{"docstring": "/*----------------------------------------------------------\n report\n\n   accept:      string to send to stderr     \n   perform:     if DEBUG is defined send the string to stderr.\n   return:      none\n   exceptions:  none\n   comments:\n----------------------------------------------------------*/\n", "func_signal": "void report(char *msg)", "code": "{\n#ifdef DEBUG\n        fprintf(stderr, msg);\n#endif /* DEBUG */\n}", "path": "src\\ParallelImp.c", "repo_name": "mazbrili/rxtx", "stars": 0, "license": "other", "language": "c", "size": 5712}
{"docstring": "/*----------------------------------------------------------\nthrow_java_exception\n\n   accept:      env (keyhole to java)\n                *exc (exception class name)\n                *foo (function name)\n                *msg (error message)\n   perform:     Throw a new java exception\n   return:      none\n   exceptions:  haha!\n   comments:\n----------------------------------------------------------*/\n", "func_signal": "void throw_java_exception( JNIEnv *env, char *exc, char *foo, char *msg )", "code": "{\n#define MSG_SIZE 128\n\tchar buf[ 128 ];\n\tjclass clazz = (*env)->FindClass( env, exc );\n\tif( !clazz )\n\t{\n\t\t(*env)->ExceptionDescribe( env );\n\t\t(*env)->ExceptionClear( env );\n\t\treturn;\n\t}\n\t/* reduce the message size if it to large for the message buffer */\n\tif(MSG_SIZE < (strlen( msg ) + strlen(foo) + 5)){\n\t\tmsg[ MSG_SIZE - strlen(foo) - 5] = 0;\n\t}\n#if defined(_GNU_SOURCE)\n\tsnprintf( buf, 60, \"%s in %s\", msg, foo );\n#else\n\tsprintf( buf,\"%s in %s\", msg, foo );\n#endif /* _GNU_SOURCE */\n\t(*env)->ThrowNew( env, clazz, buf );\n/* ct7 * Added DeleteLocalRef */\n\t(*env)->DeleteLocalRef( env, clazz );\n}", "path": "src\\ParallelImp.c", "repo_name": "mazbrili/rxtx", "stars": 0, "license": "other", "language": "c", "size": 5712}
{"docstring": "/*----------------------------------------------------------\nLPRPort.isPaperOut\n   accept:      none\n   perform:     check if printer reports paper is out\n   return:      Paper Out: JNI_TRUE  Not Paper Out: JNI_FALSE\n   exceptions:  none\n   comments:    LP_NOPA    unchanged out-of-paper input, active high\n----------------------------------------------------------*/\n", "func_signal": "JNIEXPORT jboolean JNICALL LPRPort(isPaperOut)(JNIEnv *env,\n\tjobject jobj)", "code": "{\n\n\tint fd = get_java_var( env, jobj,\"fd\",\"I\" );\n#if defined (__linux__)\n\tint status;\n\tioctl(fd, LPGETSTATUS,&status);\n\treturn( status & LP_NOPA ? JNI_TRUE : JNI_FALSE );\n#elif defined (WIN32)\n\treturn getWin32ParallelStatus( fd, PARALLEL_PAPER_EMPTY); \n#else\n/*  FIXME??  */\n\tprintf(\"ParallelImp.c LPGETSTATUS not defined\\n\");\n\treturn(JNI_TRUE);\n#endif\n}", "path": "src\\ParallelImp.c", "repo_name": "mazbrili/rxtx", "stars": 0, "license": "other", "language": "c", "size": 5712}
{"docstring": "/*----------------------------------------------------------\nLPRPort.writeByte\n\n   accept:      byte to write (passed as int)\n   perform:     write a single byte to the port\n   return:      none\n   exceptions:  IOException\n----------------------------------------------------------*/\n", "func_signal": "JNIEXPORT void JNICALL LPRPort(writeByte)( JNIEnv *env,\n\tjobject jobj, jint ji )", "code": "{\n\tunsigned char byte = (unsigned char)ji;\n\tint fd = get_java_var( env, jobj,\"fd\",\"I\" );\n\n#ifdef WIN32\n\tDWORD countWritten; /* Fixme, should be a loop until all is written */\n\tif( WriteFile( (HANDLE)fd, &byte, sizeof( unsigned char ), &countWritten, NULL ) < 0 ) return;\n#else\n\tif( write( fd, &byte, sizeof( unsigned char ) ) >= 0 ) return;\n#endif\n\tthrow_java_exception_system_msg( env, IO_EXCEPTION, \"writeByte\" );\n}", "path": "src\\ParallelImp.c", "repo_name": "mazbrili/rxtx", "stars": 0, "license": "other", "language": "c", "size": 5712}
{"docstring": "/*----------------------------------------------------------\n report_error\n\n   accept:      string to send to report as an error\n   perform:     send the string to stderr or however it needs to be reported.\n   return:      none\n   exceptions:  none\n   comments:\n----------------------------------------------------------*/\n", "func_signal": "void report_error(char *msg)", "code": "{\n#ifndef DEBUG_MW\n\tfprintf(stderr, msg);\n#else\n\tmexWarnMsgTxt( msg );\n#endif /* DEBUG_MW */\n}", "path": "src\\ParallelImp.c", "repo_name": "mazbrili/rxtx", "stars": 0, "license": "other", "language": "c", "size": 5712}
{"docstring": "/*----------------------------------------------------------\n send_event\n\n   accept:      The event type and the event state     \n   perform:     if state is > 0 send a JNI_TRUE event otherwise send JNI_FALSE\n   return:      a positive value if the port is being closed.\n   exceptions:  none\n   comments:\n----------------------------------------------------------*/\n", "func_signal": "int send_event(JNIEnv *env, jobject jobj, jint type, int flag)", "code": "{\n\tint result;\n\tjmethodID foo;\n\tjclass jclazz = (*env)->GetObjectClass( env, jobj );\n\n\tif(jclazz == NULL) return JNI_TRUE;\n\tfoo = (*env)->GetMethodID( env, jclazz, \"sendEvent\", \"(IZ)Z\" );\n\n\t(*env)->ExceptionClear(env);\n\n\tresult = (*env)->CallBooleanMethod( env, jobj, foo, type, \n\t\tflag > 0 ? JNI_TRUE : JNI_FALSE );\n\n#ifdef DEBUG\n\tif((*env)->ExceptionOccurred(env)) {\n\t\treport (\"an error occured calling sendEvent()\\n\");\n\t\t(*env)->ExceptionDescribe(env);\n\t\t(*env)->ExceptionClear(env);\n\t}\n#endif /* DEBUG */\n\t(*env)->DeleteLocalRef( env, jclazz );\n\treturn(result);\n}", "path": "src\\ParallelImp.c", "repo_name": "mazbrili/rxtx", "stars": 0, "license": "other", "language": "c", "size": 5712}
{"docstring": "/*----------------------------------------------------------\nLPRPort.isPrinterTimedOut\n   accept:       none\n   perform:      Not really sure see isPaperOut\n   return:       JNI_FALSE if the printer does not return out of paper other\n                 wise JNI_TRUE.\n   exceptions:   none\n   comments:     Is this documented right in the javadocs?\n\t         not sure this is correct FIXME\n----------------------------------------------------------*/\n", "func_signal": "JNIEXPORT jboolean JNICALL LPRPort(isPrinterTimedOut)(JNIEnv *env,\n\tjobject jobj)", "code": "{\n#if defined(__linux__)\n\tint fd = get_java_var( env, jobj,\"fd\",\"I\" );\n\tint status;\n\tioctl(fd, LPGETSTATUS, &status);\n\treturn( status & LP_BUSY ? JNI_TRUE : JNI_FALSE );\n#endif\n#if defined(__FreeBSD__)\n\tprintf(\"ParallelImp.c LPGETSTATUS not defined\\n\");\n\t/*\n\treturn( status & EBUSY ? JNI_TRUE : JNI_FALSE );\n\t*/\n#endif\n\treturn( JNI_FALSE );\n}", "path": "src\\ParallelImp.c", "repo_name": "mazbrili/rxtx", "stars": 0, "license": "other", "language": "c", "size": 5712}
{"docstring": "/*----------------------------------------------------------\nget_java_var\n\n   accept:      env (keyhole to java)\n                jobj (java RXTXPort object)\n\n   return:      the fd field from the java object\n   exceptions:  none\n   comments:\n----------------------------------------------------------*/\n", "func_signal": "int get_java_var( JNIEnv *env, jobject jobj, char *id, char *type )", "code": "{\n\tint result = 0;\n\tjclass jclazz = (*env)->GetObjectClass( env, jobj );\n\tjfieldID jfd = (*env)->GetFieldID( env, jclazz, id, type );\n\tif( !jfd )\n\t{\n\t\t(*env)->ExceptionDescribe( env );\n\t\t(*env)->ExceptionClear( env );\n\t\treturn result;\n\t}\n\tresult = (int)( (*env)->GetIntField( env, jobj, jfd ) );\n/* ct7 & gel * Added DeleteLocalRef */\n\t(*env)->DeleteLocalRef( env, jclazz );\n\treturn result;\n}", "path": "src\\ParallelImp.c", "repo_name": "mazbrili/rxtx", "stars": 0, "license": "other", "language": "c", "size": 5712}
{"docstring": "/*----------------------------------------------------------\nLPRPort.Initialize\n\n   accept:      none\n   perform:     Initialize the native library\n   return:      none\n   comments:    lots of reading to do here. FIXME\n----------------------------------------------------------*/\n", "func_signal": "JNIEXPORT void JNICALL LPRPort(Initialize)( JNIEnv *env,\n\tjclass jclazz )", "code": "{\n\t/* This bit of code checks to see if there is a signal handler installed\n\t   for SIGIO, and installs SIG_IGN if there is not.  This is necessary\n\t\tfor the native threads jdk, but we don't want to do it with green\n\t\tthreads, because it slows things down.  Go figure. */\n#if !defined(WIN32)\n\tstruct sigaction handler;\n\tsigaction( SIGIO, NULL, &handler );\n\tif( !handler.sa_handler ) signal( SIGIO, SIG_IGN );\n#endif /* !WIN32 */\n}", "path": "src\\ParallelImp.c", "repo_name": "mazbrili/rxtx", "stars": 0, "license": "other", "language": "c", "size": 5712}
{"docstring": "/*----------------------------------------------------------\nLPRPort.writeArray\n\n   accept:      jbarray: bytes used for writing\n                offset: offset in array to start writing\n                count: Number of bytes to write\n   perform:     write length bytes of jbarray\n   return:      none\n   exceptions:  IOException\n----------------------------------------------------------*/\n", "func_signal": "JNIEXPORT void JNICALL LPRPort(writeArray)( JNIEnv *env,\n\tjobject jobj, jbyteArray jbarray, jint offset, jint count )", "code": "{\n#ifdef WIN32\n\tDWORD countWritten; /* Fixme, should be a loop until all is written */\n\tCOMMTIMEOUTS timeouts;\n\tint errorCount = 0;\n#endif\n\tint fd = get_java_var( env, jobj,\"fd\",\"I\" );\n\tjbyte *body = (*env)->GetByteArrayElements( env, jbarray, 0 );\n\tunsigned char *bytes = (unsigned char *)malloc( count );\n\tint i;\n\tfor( i = 0; i < count; i++ ) bytes[ i ] = body[ i + offset ];\n\t(*env)->ReleaseByteArrayElements( env, jbarray, body, 0 );\n#ifdef WIN32\n\t/*\n\twe set a timeout because all calls are sequentiell (also with asynchron)\n\t this means that the default timeout of unlimited\n\tblocks all calls (also close and status request) if the device is down\n\t*/\n\tGetCommTimeouts( (HANDLE)fd, &timeouts );\n\ttimeouts.WriteTotalTimeoutMultiplier = 0;\n\ttimeouts.WriteTotalTimeoutConstant = 2000; /*  2000 is the min value for the default Windows NT and Windows 2000 driver */\n\tSetCommTimeouts( (HANDLE)fd, &timeouts );\n\twhile( count > 0 ){\n\t\tif(!WriteFile( (HANDLE)fd, bytes, count, &countWritten, NULL ) && countWritten == 0){\n\t\t\t/*\n\t\t\tthis are 20 * 2 seconds, in this time a printer (or other parallel device)\n\t\t\tshould solv all problems like buffer full, etc\n\t\t\t*/\n\t\t\tif(errorCount++ < 20){\n\t\t\t\tSleep( 20 ); /* make a small pause to execute all other requests in all other threads */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthrow_java_exception_system_msg( env, IO_EXCEPTION, \"writeArray\" );\n\t\t\tbreak;\n\t\t}\n\t\terrorCount = 0;\n\t\tbytes += countWritten;\n\t\tcount -= countWritten;\n\t}\n#else\n\tif( write( fd, bytes, count ) < 0 )\n\t\tthrow_java_exception_system_msg( env, IO_EXCEPTION, \"writeArray\" );\n#endif\n\tfree( bytes );\n}", "path": "src\\ParallelImp.c", "repo_name": "mazbrili/rxtx", "stars": 0, "license": "other", "language": "c", "size": 5712}
{"docstring": "/*----------------------------------------------------------\nLPRPort.isPrinterBusy\n   accept:      none\n   perform:     Check to see if the printer is printing.\n   return:      JNI_TRUE if the printer is Busy, JNI_FALSE if its idle\n   exceptions:  none\n   comments:    LP_BUSY     inverted busy input, active high\n----------------------------------------------------------*/\n", "func_signal": "JNIEXPORT jboolean JNICALL LPRPort(isPrinterBusy)(JNIEnv *env,\n\tjobject jobj)", "code": "{\n\tint fd = get_java_var( env, jobj,\"fd\",\"I\" );\n\tint status;\n#if defined (__linux__)\n\tioctl(fd, LPGETSTATUS, &status);\n#elif defined (WIN32)\n\treturn getWin32ParallelStatus( fd, PARALLEL_BUSY); \n#else\n/*  FIXME??  */\n\tprintf(\"ParallelImp.c LPGETSTATUS not defined\\n\");\n#endif\n#if defined(__linux__)\n\treturn( status & LP_BUSY ? JNI_TRUE : JNI_FALSE );\n#endif\n#if defined(__FreeBSD__)\n\treturn( status & EBUSY ? JNI_TRUE : JNI_FALSE );\n#endif\n\treturn(JNI_FALSE);\n}", "path": "src\\ParallelImp.c", "repo_name": "mazbrili/rxtx", "stars": 0, "license": "other", "language": "c", "size": 5712}
{"docstring": "/*----------------------------------------------------------\nLPRPort.isPrinterError\n   accept:      none\n   perform:     check for printer error\n   return:      JNI_TRUE if there is an printer error otherwise JNI_FALSE\n   exceptions:  none\n   comments:    LP_ERR   unchanged error input, active low\n----------------------------------------------------------*/\n", "func_signal": "JNIEXPORT jboolean JNICALL LPRPort(isPrinterError)(JNIEnv *env,\n\tjobject jobj)", "code": "{\n\tint fd = get_java_var( env, jobj,\"fd\",\"I\" );\n#if defined (__linux__)\n\tint status;\n\tioctl(fd, LPGETSTATUS, &status);\n\treturn( status & LP_ERR ? JNI_TRUE : JNI_FALSE );\n#elif defined (WIN32)\n\treturn getWin32ParallelStatus( fd, PARALLEL_PAPER_EMPTY | \n\t\t\t\t\t\t\t\t\t   PARALLEL_OFF_LINE |\n\t\t\t\t\t\t\t\t\t   PARALLEL_POWER_OFF |\n\t\t\t\t\t\t\t\t\t   PARALLEL_NOT_CONNECTED |\n\t\t\t\t\t\t\t\t\t   PARALLEL_BUSY); \n#else\n/*  FIXME??  */\n\tprintf(\"ParallelImp.c LPGETSTATUS not defined\\n\");\n\treturn(JNI_FALSE);\n#endif\n}", "path": "src\\ParallelImp.c", "repo_name": "mazbrili/rxtx", "stars": 0, "license": "other", "language": "c", "size": 5712}
{"docstring": "/*----------------------------------------------------------\nread_byte_array\n\n   accept:      int                fd   file descriptor to read from\n                unsigned char *buffer   buffer to read data into\n                int            length   number of bytes to read\n                int         threshold   receive threshold\n                int           timeout   milliseconds to wait before returning\n   perform:     read bytes from the port into a buffer\n   return:      status of read\n                -1 fail (IOException)\n                 0 timeout\n                >0 number of bytes read\n   comments:    According to the Communications API spec, a receive threshold\n                of 1 is the same as having the threshold disabled.\n----------------------------------------------------------*/\n", "func_signal": "int read_byte_array( int fd, unsigned char *buffer, int length, int threshold,\n\tint timeout )", "code": "{\n\tint ret, left, bytes = 0;\n\tfd_set rfds;\n\tstruct timeval sleep;\n\n\tFD_ZERO( &rfds );\n\tFD_SET( fd, &rfds );\n\tsleep.tv_sec = timeout / 1000;\n\tsleep.tv_usec = 1000 * ( timeout % 1000 );\n\tleft = length;\n\n\twhile( bytes < length && bytes < threshold )\n\t{\n\t\tif( timeout > 0 )\n\t\t{\n         /* FIXME: In Linux, select updates the timeout automatically, so\n            other OSes will need to update it manually if they want to have\n            the same behavior.  For those OSes, timeouts will occur after no\n            data AT ALL is received for the timeout duration.  No big deal. */\n\t\t\tdo {\n\t\t\t\tret=select( fd + 1, &rfds, NULL, NULL, &sleep );\n\t\t\t} while(ret < 0 && errno ==EINTR);\n\t\t\tif( ret == 0 ) break;\n\t\t\tif( ret < 0 ) return -1;\n\t\t}\n#if defined(WIN32)\n\t\tif(!ReadFile( (HANDLE)fd, buffer + bytes, left, (DWORD *)&ret, NULL )){\n\t\t\tYACK();\n\t\t\tret = -1;\n\t\t}\n#else\n\t\tret = read( fd, buffer + bytes, left );\n#endif\n\t\tif( ret == 0 ) break;\n\t\tif( ret < 0 ) return -1;\n\t\tbytes += ret;\n\t\tleft -= ret;\n\t}\n\treturn bytes;\n}", "path": "src\\ParallelImp.c", "repo_name": "mazbrili/rxtx", "stars": 0, "license": "other", "language": "c", "size": 5712}
{"docstring": "/*----------------------------------------------------------\nLPRPort.nativeavailable\n\n   accept:      none\n   perform:     find out the number of bytes available for reading\n   return:      available bytes\n                -1 on error\n   exceptions:  none\n----------------------------------------------------------*/\n", "func_signal": "JNIEXPORT jint JNICALL LPRPort(nativeavailable)( JNIEnv *env,\n\tjobject jobj )", "code": "{\n\tint fd = get_java_var( env, jobj,\"fd\",\"I\" );\n\tint result;\n/*\n\tchar message[80];\n\n\tENTER( \"LPRPort:nativeavailable\" );\n*/\n/*\n    On SCO OpenServer FIONREAD always fails for serial devices,\n    so try ioctl FIORDCHK instead; will only tell us whether\n    bytes are available, not how many, but better than nothing.\n\n    This turns out to be true on Solaris also.  taj.\n*/\n#ifdef FIORDCHK  /* __unixware__ __sun__ probably others */\n\tresult = ioctl(fd, FIORDCHK, 0);\n#else\n\tif( ioctl( fd, FIONREAD, &result ) < 0 )\n\t{\n\t\tgoto fail;\n\t}\n#endif /* FIORDCHK */\n\tif (result == -1) {\n\t\tgoto fail;\n\t}\n\tif( result )\n\t{\n/*\t\tsprintf(message, \"    nativeavailable: FIORDCHK result %d, \\\n\t\t\t\terrno %d\\n\", result , result == -1 ? errno : 0);\n\t\treport( message );\n*/\n\t}\n/*\n\tLEAVE( \"LPRPort:nativeavailable\" );\n*/\n\treturn (jint)result;\nfail:\n/*\n\treport(\"LPRPort:nativeavailable:  ioctl() failed\\n\");\n\tLEAVE( \"LPRPort:nativeavailable\" );\n*/\n\tthrow_java_exception_system_msg( env, IO_EXCEPTION, \"nativeavailable\" );\n\treturn (jint)result;\n}", "path": "src\\ParallelImp.c", "repo_name": "mazbrili/rxtx", "stars": 0, "license": "other", "language": "c", "size": 5712}
{"docstring": "/*----------------------------------------------------------\nLPRPort.nativeClose\n\n   accept:      none\n   perform:     get the fd from the java end and close it\n   return:      none\n   exceptions:  none\n----------------------------------------------------------*/\n", "func_signal": "JNIEXPORT void JNICALL LPRPort(nativeClose)( JNIEnv *env,\n\tjobject jobj )", "code": "{\n\tint fd = get_java_var( env, jobj,\"fd\",\"I\" );\n\n#ifdef WIN32\n\tCloseHandle( (HANDLE)fd );\n#else\n\tclose( fd );\n#endif\n\treturn;\n}", "path": "src\\ParallelImp.c", "repo_name": "mazbrili/rxtx", "stars": 0, "license": "other", "language": "c", "size": 5712}
{"docstring": "/*----------------------------------------------------------\nLPRPort.readArray\n\n   accept:       offset (bytes to skip) and Length (bytes to read)\n   perform:      read bytes from the port into a byte array\n   return:       bytes read on success\n                 0 on read timeout\n   exceptions:   IOException\n   comments:     throws IOException if asked to read > SSIZE_MAX\n----------------------------------------------------------*/\n", "func_signal": "JNIEXPORT jint JNICALL LPRPort(readArray)( JNIEnv *env,\n\tjobject jobj, jbyteArray jbarray, jint offset, jint length )", "code": "{\n\tint bytes, i, fd, threshold, timeout;\n\tjbyte *body;\n\tunsigned char *buffer;\n\tfd = get_java_var( env, jobj,\"fd\",\"I\" );\n\tthreshold = get_java_var( env, jobj,\"threshold\",\"I\" );\n\ttimeout = get_java_var( env, jobj,\"threshold\",\"I\" );\n\n\tif( (size_t) length < 1 || (size_t) length > SSIZE_MAX )\n\t{\n\t\tthrow_java_exception( env, IO_EXCEPTION, \"readArray\",\n\t\t\t\"Invalid length\" );\n\t\treturn -1;\n\t}\n\n\tbuffer = (unsigned char *)malloc( sizeof( unsigned char ) * length );\n\tif( buffer == 0 )\n\t{\n\t\tthrow_java_exception( env, IO_EXCEPTION, \"readArray\",\n\t\t\t\"Unable to allocate buffer\" );\n\n\t\treturn -1;\n\t}\n\n\tbytes = read_byte_array( fd, buffer, length, threshold, timeout );\n\tif( bytes < 0 )\n\t{\n\t\tfree( buffer );\n\t\tthrow_java_exception_system_msg( env, IO_EXCEPTION, \"readArray\" );\n\n\t\treturn -1;\n\t}\n\n\tbody = (*env)->GetByteArrayElements( env, jbarray, 0 );\n\tfor( i = 0; i < bytes; i++ ) body[ i + offset ] = buffer[ i ];\n\t(*env)->ReleaseByteArrayElements( env, jbarray, body, 0 );\n\tfree( buffer );\n\treturn (bytes ? bytes : -1);\n}", "path": "src\\ParallelImp.c", "repo_name": "mazbrili/rxtx", "stars": 0, "license": "other", "language": "c", "size": 5712}
{"docstring": "/*----------------------------------------------------------\nLPRPort.setLPRMode\n   accept:     mode\n   perform:    set the Printer communication mode\n\tLPT_MODE_ANY:     pick the best possible mode\n\tLPT_MODE_SPP:     compatibility mode/unidirectional\n\tLPT_MODE_PS2:     byte mode/bidirectional\n\tLPT_MODE_EPP:     extended parallel port\n\tLPT_MODE_ECP:     enhanced capabilities port\n\tLPT_MODE_NIBBLE:  Nibble Mode. Bi-directional. HP Bi-tronics.\n\t                  4 bits at a time.\n   return:     none\n   exceptions: UnsupportedCommOperationException\n   comments:\n----------------------------------------------------------*/\n", "func_signal": "JNIEXPORT jboolean JNICALL LPRPort(setLPRMode)(JNIEnv *env,\n\tjclass jclazz, jint mode)", "code": "{\n\tswitch(mode)\n\t{\n\t\tcase LPT_MODE_ANY:\n\t\t\tbreak;\n\t\tcase LPT_MODE_SPP:\n\t\tcase LPT_MODE_PS2:\n\t\tcase LPT_MODE_EPP:\n\t\tcase LPT_MODE_ECP:\n\t\tcase LPT_MODE_NIBBLE:\n\t\tdefault:\n\t\t\tthrow_java_exception( env, UNSUPPORTED_COMM_OPERATION,\n\t\t\t\t\"nativeSetSerialPortParams\",\n\t\t\t\t\"setLPRMode was unable to proced the requested \\\n\t\t\t\tmode\"\n\t\t\t);\n\t}\n\treturn(JNI_TRUE);\n}", "path": "src\\ParallelImp.c", "repo_name": "mazbrili/rxtx", "stars": 0, "license": "other", "language": "c", "size": 5712}
{"docstring": "/*----------------------------------------------------------\nLPRPort.open\n\n   accept:      The device to open.  ie \"/dev/lp0\"\n   perform:     open the device and return the filedescriptor\n   return:      fd\n   exceptions:  PortInUseException\n   comments:    Very often people complain about not being able to get past\n                this function and it turns out to be permissions on the\n                device file or bios has the device disabled.\n\t\tFIXME  Lock Files?\n----------------------------------------------------------*/\n", "func_signal": "JNIEXPORT jint JNICALL LPRPort(open)( JNIEnv *env, jobject jobj,\n\tjstring jstr )", "code": "{\n\t/*struct termios ttyset;*/\n\tconst char *filename = (*env)->GetStringUTFChars( env, jstr, 0 );\n#ifdef WIN32\n\tint fd = (int)CreateFile( filename, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0 );\n#else\n\tint fd = open( filename, O_RDWR | O_NONBLOCK );\n#endif\n\t(*env)->ReleaseStringUTFChars( env, jstr, NULL );\n\tif( fd < 0 ) goto fail;\n\treturn (jint)fd;\n\nfail:\n\tthrow_java_exception_system_msg( env, PORT_IN_USE_EXCEPTION, \"open\" );\n\treturn -1;\n}", "path": "src\\ParallelImp.c", "repo_name": "mazbrili/rxtx", "stars": 0, "license": "other", "language": "c", "size": 5712}
{"docstring": "/*----------------------------------------------------------\n is_interrupted\n\n   accept:      \n   perform:     see if the port is being closed. \n   return:      a positive value if the port is being closed.\n   exceptions:  none\n   comments:\n----------------------------------------------------------*/\n", "func_signal": "jboolean is_interrupted(JNIEnv *env, jobject jobj)", "code": "{\n\tjmethodID foo;\n\tjclass jclazz;\n\tint result;\n\n\t(*env)->ExceptionClear(env);\n\n\tjclazz = (*env)->GetObjectClass( env, jobj );\n\tif(jclazz == NULL) return JNI_TRUE;\n\n\tfoo = (*env)->GetMethodID( env, jclazz, \"checkMonitorThread\", \"()Z\");\n\tif(foo == NULL) return JNI_TRUE;\n\n\tresult = (*env)->CallBooleanMethod( env, jobj, foo );\n\n#ifdef DEBUG\n\tif((*env)->ExceptionOccurred(env)) {\n\t\treport (\"an error occured calling sendEvent()\\n\");\n\t\t(*env)->ExceptionDescribe(env);\n\t\t(*env)->ExceptionClear(env);\n\t}\n#endif /* DEBUG */\n\t(*env)->DeleteLocalRef( env, jclazz );\n\n\treturn(result);\n}", "path": "src\\ParallelImp.c", "repo_name": "mazbrili/rxtx", "stars": 0, "license": "other", "language": "c", "size": 5712}
{"docstring": "/*----------------------------------------------------------\nLPRPort.eventLoop\n\n   accept:      none\n   perform:     periodically check for ParallelPortEvents\n   return:      none\n   exceptions:  none\n   comments:    lots of work needed here.  Yes its a mess.\nstruct lp_stats\n{\n\tunsigned long chars;\n\tunsigned long sleeps;\n\tunsigned int maxrun;\n\tunsigned int maxwait;\n\tunsigned int meanwait;\n\tunsigned int mdev;\n};\n\n----------------------------------------------------------*/\n", "func_signal": "JNIEXPORT void JNICALL LPRPort(eventLoop)( JNIEnv *env,\n\tjobject jobj )", "code": "{\n\tint fd, ret;\n\tunsigned int pflags = 0;\n\tfd_set rfds;\n\tstruct timeval sleep;\n\tjboolean interrupted = 0;\n\n\tfd = get_java_var( env, jobj,\"fd\",\"I\" );\n\n\tinterrupted = is_interrupted(env, jobj);\n\n\tFD_ZERO( &rfds );\n\twhile( !interrupted )\n\t{\n\t\tFD_SET( fd, &rfds );\n\t\t/* Check every 1 second, or on receive data */\n\t\tsleep.tv_sec = 1;\t\n\t\tsleep.tv_usec = 0;\n\t\tdo {\n\t\t\tret = select( fd + 1, &rfds, NULL, NULL, &sleep );\n\t\t}\n\t\twhile (ret < 0 && errno == EINTR);\n\t\tif( ret < 0 ) break;\n\t\tinterrupted = is_interrupted(env, jobj);\n\t\tif(interrupted) {\n\t\t\treturn;\n\t\t}\n\n#if defined(LPGETSTATUS)\n\t\tioctl( fd, LPGETSTATUS, &pflags );\n#elif defined(WIN32)\n\t\tpflags = getWin32ParallelStatusFlags(fd);\n#else\n\t/*  FIXME??  */\n\tprintf(\"ParallelImp.c LPGETSTATUS is undefined!\\n\");\n#endif\n\n/*\n\t\t\tPAR_EV_BUFFER:\n\t\t\tPAR_EV_ERROR:\n*/\n\n#if defined(PARALLEL_BUSY)\n\t\tif (pflags & PARALLEL_BUSY)\n\t\t\tsend_event( env, jobj, PAR_EV_ERROR, JNI_TRUE );\n#elif defined(LP_BUSY)\n\t\tif (pflags&LP_BUSY)    /* inverted input, active high */\n\t\t\tsend_event( env, jobj, PAR_EV_ERROR, JNI_TRUE );\n#elif defined(EBUSY)\n\t\tif (pflags&EBUSY)    /* inverted input, active high */\n\t\t\tsend_event( env, jobj, PAR_EV_ERROR, JNI_TRUE );\n#endif /* EBUSY LP_BUSY */\n/*  FIXME  this has moved into the ifdef __kernel__?  Need to get the\n           posix documentation on this.\n\t\tif (pflags&LP_ACK)\n\t\t\tsend_event( env, jobj, PAR_EV_ERROR, JNI_TRUE );\n*/\n\n\n#if defined (__linux__)\n\t\t/* unchanged input, active low */\n\t\tif (pflags&LP_NOPA)   /* unchanged input, active high */\n\t\t\tsend_event( env, jobj, PAR_EV_ERROR, 1 );\n\t\tif (pflags&LP_SELEC)  /* unchanged input, active high */\n\t\t\tsend_event( env, jobj, PAR_EV_ERROR, 1 );\n\t\tif (pflags&LP_ERR)  /* unchanged input, active low */\n\t\t\tsend_event( env, jobj, PAR_EV_ERROR, 1 );\n#else\n\t/*  FIXME??  */\n\tprintf(\"ParallelImp.c LPGETSTATUS is undefined!\\n\");\n#endif\n\t\tusleep(1000);\n\t}\n\treturn;\n}", "path": "src\\ParallelImp.c", "repo_name": "mazbrili/rxtx", "stars": 0, "license": "other", "language": "c", "size": 5712}
{"docstring": "/**\n@brief\tfor copy the data form application buffer to Transmite buffer of the chip.\n\nThis function is being used for copy the data form application buffer to Transmite\nbuffer of the chip. It calculate the actual physical address where one has to write\nthe data in transmite buffer. Here also take care of the condition while it exceed\nthe Tx memory uper-bound of socket.\n*/\n", "func_signal": "void write_data(SOCKET s, vuint8 * src, vuint8 * dst, uint16 len)", "code": "{\n\tuint16 size;\n\tuint16 dst_mask;\n\tuint8 * dst_ptr;\n\n\tdst_mask = (uint16)dst & getIINCHIP_TxMASK(s);\n\tdst_ptr = (uint8 *)(getIINCHIP_TxBASE(s) + dst_mask);\n\t\n\tif (dst_mask + len > getIINCHIP_TxMAX(s)) \n\t{\n\t\tsize = getIINCHIP_TxMAX(s) - dst_mask;\n\t\twiz_write_buf((uint16)dst_ptr, (uint8*)src, size);\n\t\tsrc += size;\n\t\tsize = len - size;\n\t\tdst_ptr = (uint8 *)(getIINCHIP_TxBASE(s));\n\t\twiz_write_buf((uint16)dst_ptr, (uint8*)src, size);\n\t} \n\telse\n\t{\n\t\twiz_write_buf((uint16)dst_ptr, (uint8*)src, len);\n\t}\n}", "path": "hardware\\libraries\\Ethernet\\utility\\w5100.c", "repo_name": "frickel/shellduino-skel", "stars": 1, "license": "None", "language": "c", "size": 420}
{"docstring": "/**\n@brief\tThis function reads the value from W5100 registers.\n*/\n", "func_signal": "uint8 IINCHIP_READ(uint16 addr)", "code": "{\n\tuint8 data;\n\n// DIRECT MODE I/F\n\n#if (__DEF_IINCHIP_BUS__ == __DEF_IINCHIP_DIRECT_MODE__)\n\tIINCHIP_ISR_DISABLE();\n\tdata = *((vuint8*)(addr));\n\tIINCHIP_ISR_ENABLE();\n#elif(__DEF_IINCHIP_BUS__ == __DEF_IINCHIP_INDIRECT_MODE__)   \n\t   IINCHIP_ISR_DISABLE();\n\t   *((vuint8*)IDM_AR0) = (uint8)((addr & 0xFF00) >> 8);\n\t   *((vuint8*)IDM_AR1) = (uint8)(addr & 0x00FF);\n\t   data = *((vuint8*)IDM_DR);\n\t   IINCHIP_ISR_ENABLE();\n   \n#elif (__DEF_IINCHIP_BUS__ == __DEF_IINCHIP_SPI_MODE__)\n\t   IINCHIP_ISR_DISABLE();\n\tIINCHIP_SpiInit();\t\n\tIINCHIP_CSoff();                             // CS=0, SPI start\n\n\tIINCHIP_SpiSendData(0x0F);\n\tIINCHIP_SpiSendData((addr & 0xFF00) >> 8);\n\tIINCHIP_SpiSendData(addr & 0x00FF);\n\t\n\t\n\tIINCHIP_SpiSendData(0);\n\tdata = IINCHIP_SpiRecvData();\n\n\tIINCHIP_CSon();                          \t// SPI end\n\t   IINCHIP_ISR_ENABLE();\n#else\n\t#error \"unknown bus type\"\n#endif\n\treturn data;\n}", "path": "hardware\\libraries\\Ethernet\\utility\\w5100.c", "repo_name": "frickel/shellduino-skel", "stars": 1, "license": "None", "language": "c", "size": 420}
{"docstring": "/**\n@brief\tterminate PPPoE connection\n*/\n", "func_signal": "uint8 pppterm(uint8 * mac, uint8 * sessionid)", "code": "{\n\tuint16 i;\n\tuint8 isr;\n#ifdef __DEF_IINCHIP_DBG__\n\tprintf(\"pppterm()\\r\\n\");\n#endif\n\t/* Set PPPoE bit in MR(Common Mode Register) : enable socket0 pppoe */\n\tIINCHIP_WRITE(MR,IINCHIP_READ(MR) | MR_PPPOE);\n\t\n\t// write pppoe server's mac address and session id \n\t// must be setted these value.\n\tfor (i = 0; i < 6; i++) IINCHIP_WRITE((Sn_DHAR0(0)+i),mac[i]);\n\tfor (i = 0; i < 2; i++) IINCHIP_WRITE((Sn_DPORT0(0)+i),sessionid[i]);\n\tisr = IINCHIP_READ(Sn_IR(0));\n\tIINCHIP_WRITE(Sn_IR(0),isr);\n\t\n\t//open socket in pppoe mode\n\tIINCHIP_WRITE(Sn_MR(0),Sn_MR_PPPOE);\n\tIINCHIP_WRITE(Sn_CR(0),Sn_CR_OPEN);\n\t/* +20071122[chungs]:wait to process the command... */\n\twhile( IINCHIP_READ(Sn_CR(0)) ) \n\t\t;\n\t/* ------- */\n\twait_1us(1);\n\t// close pppoe connection\n\tIINCHIP_WRITE(Sn_CR(0),Sn_CR_PDISCON);\n\t/* +20071122[chungs]:wait to process the command... */\n\twhile( IINCHIP_READ(Sn_CR(0)) ) \n\t\t;\n\t/* ------- */\n\twait_10ms(100);\n\t// close socket\n\t/* +200801 (hwkim) */\n\tclose(0);\n\t/* ------- */\n\t\n\n#ifdef __DEF_IINCHIP_DBG__\n\tprintf(\"pppterm() end ..\\r\\n\");\n#endif\n\n\treturn 1;\n}", "path": "hardware\\libraries\\Ethernet\\utility\\w5100.c", "repo_name": "frickel/shellduino-skel", "stars": 1, "license": "None", "language": "c", "size": 420}
{"docstring": "/* \n * Function twi_stop\n * Desc     relinquishes bus master status\n * Input    none\n * Output   none\n */\n", "func_signal": "void twi_stop(void)", "code": "{\n  // send stop condition\n  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTO);\n\n  // wait for stop condition to be exectued on bus\n  // TWINT is not set after a stop condition!\n  while(TWCR & _BV(TWSTO)){\n    continue;\n  }\n\n  // update twi state\n  twi_state = TWI_READY;\n}", "path": "hardware\\libraries\\Wire\\utility\\twi.c", "repo_name": "frickel/shellduino-skel", "stars": 1, "license": "None", "language": "c", "size": 420}
{"docstring": "/**\n@brief\tmake PPPoE connection\n@return\t1 => success to connect, 2 => Auth fail, 3 => timeout, 4 => Auth type not support\n\n*/\n", "func_signal": "uint8 pppinit(uint8 * id, uint8 idlen, uint8 * passwd, uint8 passwdlen)", "code": "{\n\tuint8 ret;\n\tuint8 isr;\n\t\n\t// PHASE0. W5100 PPPoE(ADSL) setup\n\t// enable pppoe mode\n\tprintf(\"-- PHASE 0. W5100 PPPoE(ADSL) setup process --\\r\\n\");\n\tprintf(\"\\r\\n\");\n\tIINCHIP_WRITE(MR,IINCHIP_READ(MR) | MR_PPPOE);\n\n\t// open socket in pppoe mode\n\tisr = IINCHIP_READ(Sn_IR(0));// first clear isr(0), W5100 at present time\n\tIINCHIP_WRITE(Sn_IR(0),isr);\n\t\n\tIINCHIP_WRITE(PTIMER,200); // 5sec timeout\n\tIINCHIP_WRITE(PMAGIC,0x01); // magic number\n\tIINCHIP_WRITE(Sn_MR(0),Sn_MR_PPPOE);\n\tIINCHIP_WRITE(Sn_CR(0),Sn_CR_OPEN);\n\t\n\t/* +20071122[chungs]:wait to process the command... */\n\twhile( IINCHIP_READ(Sn_CR(0)) ) \n\t\t;\n\t/* ------- */\n\t\n\tret = pppinit_in(id, idlen, passwd, passwdlen);\n\n\t// close ppp connection socket\n\t/* +200801 (hwkim) */\n\tclose(0);\n\t/* ------- */\n\t\n\treturn ret;\n}", "path": "hardware\\libraries\\Ethernet\\utility\\w5100.c", "repo_name": "frickel/shellduino-skel", "stars": 1, "license": "None", "language": "c", "size": 420}
{"docstring": "/**\n@brief\tThese below functions are used to get the Destination Hardware Address (MAC Address), Destination IP address and Destination Port.\n*/\n", "func_signal": "void getSn_DHAR(SOCKET s, uint8 * addr)", "code": "{\n\taddr[0] = IINCHIP_READ(Sn_DHAR0(s));\n\taddr[1] = IINCHIP_READ(Sn_DHAR0(s)+1);\n\taddr[2] = IINCHIP_READ(Sn_DHAR0(s)+2);\n\taddr[3] = IINCHIP_READ(Sn_DHAR0(s)+3);\n\taddr[4] = IINCHIP_READ(Sn_DHAR0(s)+4);\n\taddr[5] = IINCHIP_READ(Sn_DHAR0(s)+5);\n}", "path": "hardware\\libraries\\Ethernet\\utility\\w5100.c", "repo_name": "frickel/shellduino-skel", "stars": 1, "license": "None", "language": "c", "size": 420}
{"docstring": "/**\n@brief\tThis function is being called by recv() also.\n\nThis function read the Rx read pointer register\nand after copy the data from receive buffer update the Rx write pointer register.\nUser should read upper byte first and lower byte later to get proper value.\n*/\n", "func_signal": "void recv_data_processing(SOCKET s, uint8 *data, uint16 len)", "code": "{\n\tuint16 ptr;\n\tptr = IINCHIP_READ(Sn_RX_RD0(s));\n\tptr = ((ptr & 0x00ff) << 8) + IINCHIP_READ(Sn_RX_RD0(s) + 1);\n#ifdef __DEF_IINCHIP_DBG__\n\tprintf(\"ISR_RX: rd_ptr : %.4x\\r\\n\", ptr);\n#endif\n\tread_data(s, (uint8 *)ptr, data, len); // read data\n\tptr += len;\n\tIINCHIP_WRITE(Sn_RX_RD0(s),(uint8)((ptr & 0xff00) >> 8));\n\tIINCHIP_WRITE((Sn_RX_RD0(s) + 1),(uint8)(ptr & 0x00ff));\n}", "path": "hardware\\libraries\\Ethernet\\utility\\w5100.c", "repo_name": "frickel/shellduino-skel", "stars": 1, "license": "None", "language": "c", "size": 420}
{"docstring": "/* \n * Function twi_releaseBus\n * Desc     releases bus control\n * Input    none\n * Output   none\n */\n", "func_signal": "void twi_releaseBus(void)", "code": "{\n  // release bus\n  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT);\n\n  // update twi state\n  twi_state = TWI_READY;\n}", "path": "hardware\\libraries\\Wire\\utility\\twi.c", "repo_name": "frickel/shellduino-skel", "stars": 1, "license": "None", "language": "c", "size": 420}
{"docstring": "/**\n@brief\t This function is being called by send() and sendto() function also. \n\nThis function read the Tx write pointer register and after copy the data in buffer update the Tx write pointer\nregister. User should read upper byte first and lower byte later to get proper value.\n*/\n", "func_signal": "void send_data_processing(SOCKET s, uint8 *data, uint16 len)", "code": "{\n\tuint16 ptr;\n\tptr = IINCHIP_READ(Sn_TX_WR0(s));\n\tptr = ((ptr & 0x00ff) << 8) + IINCHIP_READ(Sn_TX_WR0(s) + 1);\n\twrite_data(s, data, (uint8 *)(ptr), len);\n\tptr += len;\n\tIINCHIP_WRITE(Sn_TX_WR0(s),(uint8)((ptr & 0xff00) >> 8));\n\tIINCHIP_WRITE((Sn_TX_WR0(s) + 1),(uint8)(ptr & 0x00ff));\n}", "path": "hardware\\libraries\\Ethernet\\utility\\w5100.c", "repo_name": "frickel/shellduino-skel", "stars": 1, "license": "None", "language": "c", "size": 420}
{"docstring": "/**\n@brief\tThis function sets up Retransmission time.\n\nIf there is no response from the peer or delay in response then retransmission \nwill be there as per RTR (Retry Time-value Register)setting\n*/\n", "func_signal": "void setRTR(uint16 timeout)", "code": "{\n\tIINCHIP_WRITE(RTR0,(uint8)((timeout & 0xff00) >> 8));\n\tIINCHIP_WRITE((RTR0 + 1),(uint8)(timeout & 0x00ff));\n}", "path": "hardware\\libraries\\Ethernet\\utility\\w5100.c", "repo_name": "frickel/shellduino-skel", "stars": 1, "license": "None", "language": "c", "size": 420}
{"docstring": "/* \n * Function twi_init\n * Desc     readys twi pins and sets twi bitrate\n * Input    none\n * Output   none\n */\n", "func_signal": "void twi_init(void)", "code": "{\n  // initialize state\n  twi_state = TWI_READY;\n\n  #if defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) || defined(__AVR_ATmega328P__)\n    // activate internal pull-ups for twi\n    // as per note from atmega8 manual pg167\n    sbi(PORTC, 4);\n    sbi(PORTC, 5);\n  #else\n    // activate internal pull-ups for twi\n    // as per note from atmega128 manual pg204\n    sbi(PORTD, 0);\n    sbi(PORTD, 1);\n  #endif\n\n  // initialize twi prescaler and bit rate\n  cbi(TWSR, TWPS0);\n  cbi(TWSR, TWPS1);\n  TWBR = ((CPU_FREQ / TWI_FREQ) - 16) / 2;\n\n  /* twi bit rate formula from atmega128 manual pg 204\n  SCL Frequency = CPU Clock Frequency / (16 + (2 * TWBR))\n  note: TWBR should be 10 or higher for master mode\n  It is 72 for a 16mhz Wiring board with 100kHz TWI */\n\n  // enable twi module, acks, and twi interrupt\n  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA);\n\t\n  // allocate buffers\n  twi_masterBuffer = (uint8_t*) calloc(TWI_BUFFER_LENGTH, sizeof(uint8_t));\n  twi_txBuffer = (uint8_t*) calloc(TWI_BUFFER_LENGTH, sizeof(uint8_t));\n  twi_rxBuffer = (uint8_t*) calloc(TWI_BUFFER_LENGTH, sizeof(uint8_t));\n}", "path": "hardware\\libraries\\Wire\\utility\\twi.c", "repo_name": "frickel/shellduino-skel", "stars": 1, "license": "None", "language": "c", "size": 420}
{"docstring": "/* \n * Function twi_readFrom\n * Desc     attempts to become twi bus master and read a\n *          series of bytes from a device on the bus\n * Input    address: 7bit i2c device address\n *          data: pointer to byte array\n *          length: number of bytes to read into array\n * Output   number of bytes read\n */\n", "func_signal": "uint8_t twi_readFrom(uint8_t address, uint8_t* data, uint8_t length)", "code": "{\n  uint8_t i;\n\n  // ensure data will fit into buffer\n  if(TWI_BUFFER_LENGTH < length){\n    return 0;\n  }\n\n  // wait until twi is ready, become master receiver\n  while(TWI_READY != twi_state){\n    continue;\n  }\n  twi_state = TWI_MRX;\n  // reset error state (0xFF.. no error occured)\n  twi_error = 0xFF;\n\n  // initialize buffer iteration vars\n  twi_masterBufferIndex = 0;\n  twi_masterBufferLength = length-1;  // This is not intuitive, read on...\n  // On receive, the previously configured ACK/NACK setting is transmitted in\n  // response to the received byte before the interrupt is signalled. \n  // Therefor we must actually set NACK when the _next_ to last byte is\n  // received, causing that NACK to be sent in response to receiving the last\n  // expected byte of data.\n\n  // build sla+w, slave device address + w bit\n  twi_slarw = TW_READ;\n  twi_slarw |= address << 1;\n\n  // send start condition\n  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTA);\n\n  // wait for read operation to complete\n  while(TWI_MRX == twi_state){\n    continue;\n  }\n\n  if (twi_masterBufferIndex < length)\n    length = twi_masterBufferIndex;\n\n  // copy twi buffer to data\n  for(i = 0; i < length; ++i){\n    data[i] = twi_masterBuffer[i];\n  }\n\t\n  return length;\n}", "path": "hardware\\libraries\\Wire\\utility\\twi.c", "repo_name": "frickel/shellduino-skel", "stars": 1, "license": "None", "language": "c", "size": 420}
{"docstring": "/* \n * Function twi_reply\n * Desc     sends byte or readys receive line\n * Input    ack: byte indicating to ack or to nack\n * Output   none\n */\n", "func_signal": "void twi_reply(uint8_t ack)", "code": "{\n  // transmit master read ready signal, with or without ack\n  if(ack){\n    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);\n  }else{\n\t  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);\n  }\n}", "path": "hardware\\libraries\\Wire\\utility\\twi.c", "repo_name": "frickel/shellduino-skel", "stars": 1, "license": "None", "language": "c", "size": 420}
{"docstring": "/**\n@brief\tThis sets the maximum segment size of TCP in Active Mode), while in Passive Mode this is set by peer\n*/\n", "func_signal": "void setSn_MSS(SOCKET s, uint16 Sn_MSSR0)", "code": "{\n\tIINCHIP_WRITE(Sn_MSSR0(s),(uint8)((Sn_MSSR0 & 0xff00) >> 8));\n\tIINCHIP_WRITE((Sn_MSSR0(s) + 1),(uint8)(Sn_MSSR0 & 0x00ff));\n}", "path": "hardware\\libraries\\Ethernet\\utility\\w5100.c", "repo_name": "frickel/shellduino-skel", "stars": 1, "license": "None", "language": "c", "size": 420}
{"docstring": "/**\n@brief\tget socket TX free buf size\n\nThis gives free buffer size of transmit buffer. This is the data size that user can transmit.\nUser shuold check this value first and control the size of transmitting data\n*/\n", "func_signal": "uint16 getSn_TX_FSR(SOCKET s)", "code": "{\n\tuint16 val=0,val1=0;\n\tdo\n\t{\n\t\tval1 = IINCHIP_READ(Sn_TX_FSR0(s));\n\t\tval1 = (val1 << 8) + IINCHIP_READ(Sn_TX_FSR0(s) + 1);\n      if (val1 != 0)\n\t\t{\n   \t\t\tval = IINCHIP_READ(Sn_TX_FSR0(s));\n   \t\t\tval = (val << 8) + IINCHIP_READ(Sn_TX_FSR0(s) + 1);\n\t\t}\n\t} while (val != val1);\n   return val;\n}", "path": "hardware\\libraries\\Ethernet\\utility\\w5100.c", "repo_name": "frickel/shellduino-skel", "stars": 1, "license": "None", "language": "c", "size": 420}
{"docstring": "/**\n@brief\tThis function is being used for copy the data form Receive buffer of the chip to application buffer.\n\nIt calculate the actual physical address where one has to read\nthe data from Receive buffer. Here also take care of the condition while it exceed\nthe Rx memory uper-bound of socket.\n*/\n", "func_signal": "void read_data(SOCKET s, vuint8 * src, vuint8 * dst, uint16 len)", "code": "{\n\tuint16 size;\n\tuint16 src_mask;\n\tuint8 * src_ptr;\n\n\tsrc_mask = (uint16)src & getIINCHIP_RxMASK(s);\n\tsrc_ptr = (uint8 *)(getIINCHIP_RxBASE(s) + src_mask);\n\t\n\tif( (src_mask + len) > getIINCHIP_RxMAX(s) ) \n\t{\n\t\tsize = getIINCHIP_RxMAX(s) - src_mask;\n\t\twiz_read_buf((uint16)src_ptr, (uint8*)dst,size);\n\t\tdst += size;\n\t\tsize = len - size;\n\t\tsrc_ptr = (uint8 *)(getIINCHIP_RxBASE(s));\n\t\twiz_read_buf((uint16)src_ptr, (uint8*) dst,size);\n\t} \n\telse\n\t{\n\t\twiz_read_buf((uint16)src_ptr, (uint8*) dst,len);\n\t}\n}", "path": "hardware\\libraries\\Ethernet\\utility\\w5100.c", "repo_name": "frickel/shellduino-skel", "stars": 1, "license": "None", "language": "c", "size": 420}
{"docstring": "/* \n * Function twi_transmit\n * Desc     fills slave tx buffer with data\n *          must be called in slave tx event callback\n * Input    data: pointer to byte array\n *          length: number of bytes in array\n * Output   1 length too long for buffer\n *          2 not slave transmitter\n *          0 ok\n */\n", "func_signal": "uint8_t twi_transmit(uint8_t* data, uint8_t length)", "code": "{\n  uint8_t i;\n\n  // ensure data will fit into buffer\n  if(TWI_BUFFER_LENGTH < length){\n    return 1;\n  }\n  \n  // ensure we are currently a slave transmitter\n  if(TWI_STX != twi_state){\n    return 2;\n  }\n  \n  // set length and copy data into tx buffer\n  twi_txBufferLength = length;\n  for(i = 0; i < length; ++i){\n    twi_txBuffer[i] = data[i];\n  }\n  \n  return 0;\n}", "path": "hardware\\libraries\\Wire\\utility\\twi.c", "repo_name": "frickel/shellduino-skel", "stars": 1, "license": "None", "language": "c", "size": 420}
{"docstring": "/**\n@brief\tThis function writes the data into W5100 registers.\n*/\n", "func_signal": "uint8 IINCHIP_WRITE(uint16 addr,uint8 data)", "code": "{\n// DIRECT MODE I/F\n#if (__DEF_IINCHIP_BUS__ == __DEF_IINCHIP_DIRECT_MODE__)\n\tIINCHIP_ISR_DISABLE();\n\t*((vuint8*)(addr)) = data;\n\tIINCHIP_ISR_ENABLE();\n#elif(__DEF_IINCHIP_BUS__ == __DEF_IINCHIP_INDIRECT_MODE__)\t/* INDIRECT MODE I/F */\n\t   IINCHIP_ISR_DISABLE();\n\t   *((vuint8*)IDM_AR0) = (uint8)((addr & 0xFF00) >> 8);\n\t   *((vuint8*)IDM_AR1) = (uint8)(addr & 0x00FF);\n\t   *((vuint8*)IDM_DR)  = data;\n\t   IINCHIP_ISR_ENABLE();\n#elif (__DEF_IINCHIP_BUS__ == __DEF_IINCHIP_SPI_MODE__)\n\t   IINCHIP_ISR_DISABLE();\n\tIINCHIP_SpiInit();\n\t\n\t//SPI MODE I/F\n\tIINCHIP_CSoff();                             // CS=0, SPI start\n\n\tIINCHIP_SpiSendData(0xF0);\n\tIINCHIP_SpiSendData((addr & 0xFF00) >> 8);\n\tIINCHIP_SpiSendData(addr & 0x00FF);\n\tIINCHIP_SpiSendData(data);\n\n\tIINCHIP_CSon();    \n\n\t   IINCHIP_ISR_ENABLE();   \n#else\n\t#error \"unknown bus type\"\n#endif\n\treturn 1;\n}", "path": "hardware\\libraries\\Ethernet\\utility\\w5100.c", "repo_name": "frickel/shellduino-skel", "stars": 1, "license": "None", "language": "c", "size": 420}
{"docstring": "// Right now, PWM output only works on the pins with\n// hardware support.  These are defined in the appropriate\n// pins_*.c file.  For the rest of the pins, we default\n// to digital output.\n", "func_signal": "void analogWrite(uint8_t pin, int val)", "code": "{\n\t// We need to make sure the PWM output is enabled for those pins\n\t// that support it, as we turn it off when digitally reading or\n\t// writing with them.  Also, make sure the pin is in output mode\n\t// for consistenty with Wiring, which doesn't require a pinMode\n\t// call for the analog output pins.\n\tpinMode(pin, OUTPUT);\n\t\n\tif (digitalPinToTimer(pin) == TIMER1A) {\n\t\t// connect pwm to pin on timer 1, channel A\n\t\tsbi(TCCR1A, COM1A1);\n\t\t// set pwm duty\n\t\tOCR1A = val;\n\t} else if (digitalPinToTimer(pin) == TIMER1B) {\n\t\t// connect pwm to pin on timer 1, channel B\n\t\tsbi(TCCR1A, COM1B1);\n\t\t// set pwm duty\n\t\tOCR1B = val;\n#if defined(__AVR_ATmega8__)\n\t} else if (digitalPinToTimer(pin) == TIMER2) {\n\t\t// connect pwm to pin on timer 2, channel B\n\t\tsbi(TCCR2, COM21);\n\t\t// set pwm duty\n\t\tOCR2 = val;\n#else\n\t} else if (digitalPinToTimer(pin) == TIMER0A) {\n\t\tif (val == 0) {\n\t\t\tdigitalWrite(pin, LOW);\n\t\t} else {\n\t\t\t// connect pwm to pin on timer 0, channel A\n\t\t\tsbi(TCCR0A, COM0A1);\n\t\t\t// set pwm duty\n\t\t\tOCR0A = val;      \n\t\t}\n\t} else if (digitalPinToTimer(pin) == TIMER0B) {\n\t\tif (val == 0) {\n\t\t\tdigitalWrite(pin, LOW);\n\t\t} else {\n\t\t\t// connect pwm to pin on timer 0, channel B\n\t\t\tsbi(TCCR0A, COM0B1);\n\t\t\t// set pwm duty\n\t\t\tOCR0B = val;\n\t\t}\n\t} else if (digitalPinToTimer(pin) == TIMER2A) {\n\t\t// connect pwm to pin on timer 2, channel A\n\t\tsbi(TCCR2A, COM2A1);\n\t\t// set pwm duty\n\t\tOCR2A = val;\t\n\t} else if (digitalPinToTimer(pin) == TIMER2B) {\n\t\t// connect pwm to pin on timer 2, channel B\n\t\tsbi(TCCR2A, COM2B1);\n\t\t// set pwm duty\n\t\tOCR2B = val;\n#endif\n#if defined(__AVR_ATmega1280__)\n\t// XXX: need to handle other timers here\n\t} else if (digitalPinToTimer(pin) == TIMER3A) {\n\t\t// connect pwm to pin on timer 3, channel A\n\t\tsbi(TCCR3A, COM3A1);\n\t\t// set pwm duty\n\t\tOCR3A = val;\n\t} else if (digitalPinToTimer(pin) == TIMER3B) {\n\t\t// connect pwm to pin on timer 3, channel B\n\t\tsbi(TCCR3A, COM3B1);\n\t\t// set pwm duty\n\t\tOCR3B = val;\n\t} else if (digitalPinToTimer(pin) == TIMER3C) {\n\t\t// connect pwm to pin on timer 3, channel C\n\t\tsbi(TCCR3A, COM3C1);\n\t\t// set pwm duty\n\t\tOCR3C = val;\n\t} else if (digitalPinToTimer(pin) == TIMER4A) {\n\t\t// connect pwm to pin on timer 4, channel A\n\t\tsbi(TCCR4A, COM4A1);\n\t\t// set pwm duty\n\t\tOCR4A = val;\n\t} else if (digitalPinToTimer(pin) == TIMER4B) {\n\t\t// connect pwm to pin on timer 4, channel B\n\t\tsbi(TCCR4A, COM4B1);\n\t\t// set pwm duty\n\t\tOCR4B = val;\n\t} else if (digitalPinToTimer(pin) == TIMER4C) {\n\t\t// connect pwm to pin on timer 4, channel C\n\t\tsbi(TCCR4A, COM4C1);\n\t\t// set pwm duty\n\t\tOCR4C = val;\n\t} else if (digitalPinToTimer(pin) == TIMER5A) {\n\t\t// connect pwm to pin on timer 5, channel A\n\t\tsbi(TCCR5A, COM5A1);\n\t\t// set pwm duty\n\t\tOCR5A = val;\n\t} else if (digitalPinToTimer(pin) == TIMER5B) {\n\t\t// connect pwm to pin on timer 5, channel B\n\t\tsbi(TCCR5A, COM5B1);\n\t\t// set pwm duty\n\t\tOCR5B = val;\n#endif\n\t} else if (val < 128)\n\t\tdigitalWrite(pin, LOW);\n\telse\n\t\tdigitalWrite(pin, HIGH);\n}", "path": "hardware\\cores\\arduino\\wiring_analog.c", "repo_name": "frickel/shellduino-skel", "stars": 1, "license": "None", "language": "c", "size": 420}
{"docstring": "/**\n@brief\tThese below functions are used to get the Gateway, SubnetMask\n\t\tand Source Hardware Address (MAC Address) and Source IP address\n*/\n", "func_signal": "void getGAR(uint8 * addr)", "code": "{\n\taddr[0] = IINCHIP_READ(GAR0);\n\taddr[1] = IINCHIP_READ(GAR0+1);\n\taddr[2] = IINCHIP_READ(GAR0+2);\n\taddr[3] = IINCHIP_READ(GAR0+3);\n}", "path": "hardware\\libraries\\Ethernet\\utility\\w5100.c", "repo_name": "frickel/shellduino-skel", "stars": 1, "license": "None", "language": "c", "size": 420}
{"docstring": "/*NUMPY_API\n * Get a cast function to cast from the input descriptor to the\n * output type_number (must be a registered data-type).\n * Returns NULL if un-successful.\n */\n", "func_signal": "NPY_NO_EXPORT PyArray_VectorUnaryFunc *\nPyArray_GetCastFunc(PyArray_Descr *descr, int type_num)", "code": "{\n    PyArray_VectorUnaryFunc *castfunc = NULL;\n\n    if (type_num < PyArray_NTYPES) {\n        castfunc = descr->f->cast[type_num];\n    }\n    if (castfunc == NULL) {\n        PyObject *obj = descr->f->castdict;\n        if (obj && PyDict_Check(obj)) {\n            PyObject *key;\n            PyObject *cobj;\n\n            key = PyInt_FromLong(type_num);\n            cobj = PyDict_GetItem(obj, key);\n            Py_DECREF(key);\n            if (PyCObject_Check(cobj)) {\n                castfunc = PyCObject_AsVoidPtr(cobj);\n            }\n        }\n        if (castfunc) {\n            return castfunc;\n        }\n    }\n    else {\n        return castfunc;\n    }\n\n    PyErr_SetString(PyExc_ValueError, \"No cast function available.\");\n    return NULL;\n}", "path": "numpy\\core\\src\\multiarray\\convert_datatype.c", "repo_name": "chadnetzer/numpy-gaurdro", "stars": 1, "license": "bsd-3-clause", "language": "c", "size": 16606}
{"docstring": "/**********************************************************************/\n", "func_signal": "static int\ngetWriteBufferDataPtr(PyObject *buffobj, void **buff)", "code": "{\n    int rval = -1;\n    PyObject *buff2;\n    if ((buff2 = getBuffer(buffobj)))\n    {\n        if (buff2->ob_type->tp_as_buffer->bf_getwritebuffer)\n            rval = buff2->ob_type->tp_as_buffer->bf_getwritebuffer(buff2,\n                    0, buff);\n        Py_DECREF(buff2);\n    }\n    return rval;\n}", "path": "numpy\\numarray\\_capi.c", "repo_name": "chadnetzer/numpy-gaurdro", "stars": 1, "license": "bsd-3-clause", "language": "c", "size": 16606}
{"docstring": "/* ignores bytestride */\n", "func_signal": "static PyArrayObject *\nNA_NewAllFromBuffer(int ndim, maybelong *shape, NumarrayType type,\n        PyObject *bufferObject, maybelong byteoffset,\n        maybelong NPY_UNUSED(bytestride), int byteorder,\n        int NPY_UNUSED(aligned), int NPY_UNUSED(writeable))", "code": "{\n    PyArrayObject *self = NULL;\n    PyArray_Descr *dtype;\n\n    if (type == tAny)\n        type = tDefault;\n\n    dtype = PyArray_DescrFromType(type);\n    if (dtype == NULL) return NULL;\n\n    if (byteorder != NA_ByteOrder()) {\n        PyArray_Descr *temp;\n        temp = PyArray_DescrNewByteorder(dtype, PyArray_SWAP);\n        Py_DECREF(dtype);\n        if (temp == NULL) return NULL;\n        dtype = temp;\n    }\n\n    if (bufferObject == Py_None || bufferObject == NULL) {\n        self = (PyArrayObject *)        \\\n               PyArray_NewFromDescr(&PyArray_Type, dtype,\n                       ndim, shape, NULL, NULL,\n                       0, NULL);\n    }\n    else {\n        npy_intp size = 1;\n        int i;\n        PyArrayObject *newself;\n        PyArray_Dims newdims;\n        for(i=0; i<ndim; i++) {\n            size *= shape[i];\n        }\n        self = (PyArrayObject *)\\\n               PyArray_FromBuffer(bufferObject, dtype,\n                       size, byteoffset);\n\n        if (self == NULL) return self;\n        newdims.len = ndim;\n        newdims.ptr = shape;\n        newself = (PyArrayObject *)\\\n                  PyArray_Newshape(self, &newdims, PyArray_CORDER);\n        Py_DECREF(self);\n        self = newself;\n    }\n\n    return self;\n}", "path": "numpy\\numarray\\_capi.c", "repo_name": "chadnetzer/numpy-gaurdro", "stars": 1, "license": "bsd-3-clause", "language": "c", "size": 16606}
{"docstring": "/*NUMPY_API\n  Get pointer to one of correct type for array\n*/\n", "func_signal": "NPY_NO_EXPORT char *\nPyArray_One(PyArrayObject *arr)", "code": "{\n    char *oneval;\n    int ret, storeflags;\n    PyObject *obj;\n\n    if (_check_object_rec(arr->descr) < 0) {\n        return NULL;\n    }\n    oneval = PyDataMem_NEW(arr->descr->elsize);\n    if (oneval == NULL) {\n        PyErr_SetNone(PyExc_MemoryError);\n        return NULL;\n    }\n\n    obj = PyInt_FromLong((long) 1);\n    if (PyArray_ISOBJECT(arr)) {\n        memcpy(oneval, &obj, sizeof(PyObject *));\n        Py_DECREF(obj);\n        return oneval;\n    }\n\n    storeflags = arr->flags;\n    arr->flags |= BEHAVED;\n    ret = arr->descr->f->setitem(obj, oneval, arr);\n    arr->flags = storeflags;\n    Py_DECREF(obj);\n    if (ret < 0) {\n        PyDataMem_FREE(oneval);\n        return NULL;\n    }\n    return oneval;\n}", "path": "numpy\\core\\src\\multiarray\\convert_datatype.c", "repo_name": "chadnetzer/numpy-gaurdro", "stars": 1, "license": "bsd-3-clause", "language": "c", "size": 16606}
{"docstring": "/**********************************************************************/\n", "func_signal": "static int\ngetBufferSize(PyObject *buffobj)", "code": "{\n    Py_ssize_t size=0;\n    PyObject *buff2;\n    if ((buff2 = getBuffer(buffobj)))\n    {\n        (void) buff2->ob_type->tp_as_buffer->bf_getsegcount(buff2, &size);\n        Py_DECREF(buff2);\n    }\n    else\n        size = -1;\n    return size;\n}", "path": "numpy\\numarray\\_capi.c", "repo_name": "chadnetzer/numpy-gaurdro", "stars": 1, "license": "bsd-3-clause", "language": "c", "size": 16606}
{"docstring": "/*NUMPY_API\n * Cast to an already created array.\n */\n", "func_signal": "NPY_NO_EXPORT int\nPyArray_CastTo(PyArrayObject *out, PyArrayObject *mp)", "code": "{\n    int simple;\n    int same;\n    PyArray_VectorUnaryFunc *castfunc = NULL;\n    intp mpsize = PyArray_SIZE(mp);\n    int iswap, oswap;\n    NPY_BEGIN_THREADS_DEF;\n\n    if (mpsize == 0) {\n        return 0;\n    }\n    if (!PyArray_ISWRITEABLE(out)) {\n        PyErr_SetString(PyExc_ValueError, \"output array is not writeable\");\n        return -1;\n    }\n\n    castfunc = PyArray_GetCastFunc(mp->descr, out->descr->type_num);\n    if (castfunc == NULL) {\n        return -1;\n    }\n\n    same = PyArray_SAMESHAPE(out, mp);\n    simple = same && ((PyArray_ISCARRAY_RO(mp) && PyArray_ISCARRAY(out)) ||\n            (PyArray_ISFARRAY_RO(mp) && PyArray_ISFARRAY(out)));\n    if (simple) {\n#if NPY_ALLOW_THREADS\n        if (PyArray_ISNUMBER(mp) && PyArray_ISNUMBER(out)) {\n            NPY_BEGIN_THREADS;\n        }\n#endif\n        castfunc(mp->data, out->data, mpsize, mp, out);\n\n#if NPY_ALLOW_THREADS\n        if (PyArray_ISNUMBER(mp) && PyArray_ISNUMBER(out)) {\n            NPY_END_THREADS;\n        }\n#endif\n        if (PyErr_Occurred()) {\n            return -1;\n        }\n        return 0;\n    }\n\n    /*\n     * If the input or output is OBJECT, STRING, UNICODE, or VOID\n     *  then getitem and setitem are used for the cast\n     *  and byteswapping is handled by those methods\n     */\n    if (PyArray_ISFLEXIBLE(mp) || PyArray_ISOBJECT(mp) || PyArray_ISOBJECT(out) ||\n            PyArray_ISFLEXIBLE(out)) {\n        iswap = oswap = 0;\n    }\n    else {\n        iswap = PyArray_ISBYTESWAPPED(mp);\n        oswap = PyArray_ISBYTESWAPPED(out);\n    }\n\n    return _broadcast_cast(out, mp, castfunc, iswap, oswap);\n}", "path": "numpy\\core\\src\\multiarray\\convert_datatype.c", "repo_name": "chadnetzer/numpy-gaurdro", "stars": 1, "license": "bsd-3-clause", "language": "c", "size": 16606}
{"docstring": "/*NUMPY_API\n * Return the typecode of the array a Python object would be converted to\n */\n", "func_signal": "NPY_NO_EXPORT int\nPyArray_ObjectType(PyObject *op, int minimum_type)", "code": "{\n    PyArray_Descr *intype;\n    PyArray_Descr *outtype;\n    int ret;\n\n    intype = PyArray_DescrFromType(minimum_type);\n    if (intype == NULL) {\n        PyErr_Clear();\n    }\n    outtype = _array_find_type(op, intype, MAX_DIMS);\n    ret = outtype->type_num;\n    Py_DECREF(outtype);\n    Py_XDECREF(intype);\n    return ret;\n}", "path": "numpy\\core\\src\\multiarray\\convert_datatype.c", "repo_name": "chadnetzer/numpy-gaurdro", "stars": 1, "license": "bsd-3-clause", "language": "c", "size": 16606}
{"docstring": "/* Backward compatibility only */\n/* In both Zero and One\n\n***You must free the memory once you are done with it\nusing PyDataMem_FREE(ptr) or you create a memory leak***\n\nIf arr is an Object array you are getting a\nBORROWED reference to Zero or One.\nDo not DECREF.\nPlease INCREF if you will be hanging on to it.\n\nThe memory for the ptr still must be freed in any case;\n*/\n", "func_signal": "static int\n_check_object_rec(PyArray_Descr *descr)", "code": "{\n    if (PyDataType_HASFIELDS(descr) && PyDataType_REFCHK(descr)) {\n        PyErr_SetString(PyExc_TypeError, \"Not supported for this data-type.\");\n        return -1;\n    }\n    return 0;\n}", "path": "numpy\\core\\src\\multiarray\\convert_datatype.c", "repo_name": "chadnetzer/numpy-gaurdro", "stars": 1, "license": "bsd-3-clause", "language": "c", "size": 16606}
{"docstring": "/* The following routine is used in the event of a detected integer *\n ** divide by zero so that a floating divide by zero is generated.   *\n ** This is done since numarray uses the floating point exception    *\n ** sticky bits to detect errors. The last bit is an attempt to      *\n ** prevent optimization of the divide by zero away, the input value *\n ** should always be 0                                               *\n */\n", "func_signal": "static int int_dividebyzero_error(long NPY_UNUSED(value), long NPY_UNUSED(unused))", "code": "{\n    double dummy;\n    dummy = 1./numarray_zero;\n    if (dummy) /* to prevent optimizer from eliminating expression */\n        return 0;\n    else\n        return 1;\n}", "path": "numpy\\numarray\\_capi.c", "repo_name": "chadnetzer/numpy-gaurdro", "stars": 1, "license": "bsd-3-clause", "language": "c", "size": 16606}
{"docstring": "/* NA_ShapeLessThan returns 1 if a.shape[i] < b.shape[i] for all i, else 0.\n   If they have a different number of dimensions, it compares the innermost\n   overlapping dimensions of each.\n   */\n", "func_signal": "static int\nNA_ShapeLessThan(PyArrayObject *a, PyArrayObject *b)", "code": "{\n    int i;\n    int mindim, aoff, boff;\n    if (!NA_NDArrayCheck((PyObject *) a) ||\n            !NA_NDArrayCheck((PyObject *) b)) {\n        PyErr_Format(PyExc_TypeError,\n                \"NA_ShapeLessThan: non-array as parameter.\");\n        return -1;\n    }\n    mindim = MIN(a->nd, b->nd);\n    aoff = a->nd - mindim;\n    boff = b->nd - mindim;\n    for(i=0; i<mindim; i++)\n        if (a->dimensions[i+aoff] >=  b->dimensions[i+boff])\n            return 0;\n    return 1;\n}", "path": "numpy\\numarray\\_capi.c", "repo_name": "chadnetzer/numpy-gaurdro", "stars": 1, "license": "bsd-3-clause", "language": "c", "size": 16606}
{"docstring": "/* NA_OptionalOutputArray works like NA_OutputArray, but handles the case\n   where the output array 'optional' is omitted entirely at the python level,\n   resulting in 'optional'==Py_None.  When 'optional' is Py_None, the return\n   value is cloned (but with NumarrayType 't') from 'master', typically an input\n   array with the same shape as the output array.\n   */\n", "func_signal": "static PyArrayObject *\nNA_OptionalOutputArray(PyObject *optional, NumarrayType t, int requires,\n        PyArrayObject *master)", "code": "{\n    if ((optional == Py_None) || (optional == NULL)) {\n        PyObject *rval;\n        PyArray_Descr *descr;\n        if (t == tAny) descr=NULL;\n        else descr = PyArray_DescrFromType(t);\n        rval = PyArray_FromArray(\n                master, descr, NUM_C_ARRAY | NUM_COPY | NUM_WRITABLE);\n        return (PyArrayObject *)rval;\n    } else {\n        return NA_OutputArray(optional, t, requires);\n    }\n}", "path": "numpy\\numarray\\_capi.c", "repo_name": "chadnetzer/numpy-gaurdro", "stars": 1, "license": "bsd-3-clause", "language": "c", "size": 16606}
{"docstring": "/* Handle \"calling\" the cfunc object at the python level.\n   Dispatch the call to the appropriate python-c wrapper based\n   on the cfunc type.  Do this dispatch to avoid having to\n   check that python code didn't somehow create a mismatch between\n   cfunc and wrapper.\n   */\n", "func_signal": "static PyObject *\ncfunc_call(PyObject *self, PyObject *argsTuple, PyObject *NPY_UNUSED(argsDict))", "code": "{\n    CfuncObject *me = (CfuncObject *) self;\n    switch(me->descr.type) {\n    case CFUNC_UFUNC:\n        return callCUFunc(self, argsTuple);\n        break;\n    case CFUNC_STRIDING:\n        return callStrideConvCFunc(self, argsTuple);\n        break;\n    case CFUNC_NSTRIDING:\n        return callStridingCFunc(self, argsTuple);\n    case CFUNC_FROM_PY_VALUE:\n        return NumTypeFromPyValue(self, argsTuple);\n        break;\n    case CFUNC_AS_PY_VALUE:\n        return NumTypeAsPyValue(self, argsTuple);\n        break;\n    default:\n        return PyErr_Format( _Error,\n                \"cfunc_call: Can't dispatch cfunc '%s' with type: %d.\",\n                me->descr.name, me->descr.type);\n    }\n}", "path": "numpy\\numarray\\_capi.c", "repo_name": "chadnetzer/numpy-gaurdro", "stars": 1, "license": "bsd-3-clause", "language": "c", "size": 16606}
{"docstring": "/* Look up the NumarrayType which corresponds to typename */\n", "func_signal": "static int\nNA_nameToTypeNo(char *typename)", "code": "{\n    size_t i;\n    for(i=0; i<ELEM(NumarrayTypeNameMap); i++)\n        if (!strcmp(typename, NumarrayTypeNameMap[i].name))\n            return NumarrayTypeNameMap[i].typeno;\n    return -1;\n}", "path": "numpy\\numarray\\_capi.c", "repo_name": "chadnetzer/numpy-gaurdro", "stars": 1, "license": "bsd-3-clause", "language": "c", "size": 16606}
{"docstring": "/**********************************************************************/\n/*  Buffer Utility Functions                                          */\n/**********************************************************************/\n", "func_signal": "static PyObject *\ngetBuffer( PyObject *obj)", "code": "{\n    if (!obj) return PyErr_Format(PyExc_RuntimeError,\n            \"NULL object passed to getBuffer()\");\n    if (obj->ob_type->tp_as_buffer == NULL) {\n        return PyObject_CallMethod(obj, \"__buffer__\", NULL);\n    } else {\n        Py_INCREF(obj);  /* Since CallMethod returns a new object when it\n                            succeeds, We'll need to DECREF later to free it.\n                            INCREF ordinary buffers here so we don't have to\n                            remember where the buffer came from at DECREF time.\n                            */\n        return obj;\n    }\n}", "path": "numpy\\numarray\\_capi.c", "repo_name": "chadnetzer/numpy-gaurdro", "stars": 1, "license": "bsd-3-clause", "language": "c", "size": 16606}
{"docstring": "/*NUMPY_API\n  Get pointer to zero of correct type for array.\n*/\n", "func_signal": "NPY_NO_EXPORT char *\nPyArray_Zero(PyArrayObject *arr)", "code": "{\n    char *zeroval;\n    int ret, storeflags;\n    PyObject *obj;\n\n    if (_check_object_rec(arr->descr) < 0) {\n        return NULL;\n    }\n    zeroval = PyDataMem_NEW(arr->descr->elsize);\n    if (zeroval == NULL) {\n        PyErr_SetNone(PyExc_MemoryError);\n        return NULL;\n    }\n\n    obj=PyInt_FromLong((long) 0);\n    if (PyArray_ISOBJECT(arr)) {\n        memcpy(zeroval, &obj, sizeof(PyObject *));\n        Py_DECREF(obj);\n        return zeroval;\n    }\n    storeflags = arr->flags;\n    arr->flags |= BEHAVED;\n    ret = arr->descr->f->setitem(obj, zeroval, arr);\n    arr->flags = storeflags;\n    Py_DECREF(obj);\n    if (ret < 0) {\n        PyDataMem_FREE(zeroval);\n        return NULL;\n    }\n    return zeroval;\n}", "path": "numpy\\core\\src\\multiarray\\convert_datatype.c", "repo_name": "chadnetzer/numpy-gaurdro", "stars": 1, "license": "bsd-3-clause", "language": "c", "size": 16606}
{"docstring": "/* Function to call standard C Ufuncs\n **\n ** The C Ufuncs expect contiguous 1-d data numarray, input and output numarray\n ** iterate with standard increments of one data element over all numarray.\n ** (There are some exceptions like arrayrangexxx which use one or more of\n ** the data numarray as parameter or other sources of information and do not\n ** iterate over every buffer).\n **\n ** Arguments:\n **\n **   Number of iterations (simple integer value).\n **   Number of input numarray.\n **   Number of output numarray.\n **   Tuple of tuples, one tuple per input/output array. Each of these\n **     tuples consists of a buffer object and a byte offset to start.\n **\n ** Returns None\n */\n", "func_signal": "static PyObject *\nNA_callCUFuncCore(PyObject *self,\n        long niter, long ninargs, long noutargs,\n        PyObject **BufferObj, long *offset)", "code": "{\n    CfuncObject *me = (CfuncObject *) self;\n    char *buffers[MAXARGS];\n    long bsizes[MAXARGS];\n    long i, pnargs = ninargs + noutargs;\n    UFUNC ufuncptr;\n\n    if (pnargs > MAXARGS)\n        return PyErr_Format(PyExc_RuntimeError, \"NA_callCUFuncCore: too many parameters\");\n\n    if (!PyObject_IsInstance(self, (PyObject *) &CfuncType)\n            || me->descr.type != CFUNC_UFUNC)\n        return PyErr_Format(PyExc_TypeError,\n                \"NA_callCUFuncCore: problem with cfunc.\");\n\n    for (i=0; i<pnargs; i++) {\n        int readonly = (i < ninargs);\n        if (offset[i] < 0)\n            return PyErr_Format(_Error,\n                    \"%s: invalid negative offset:%d for buffer[%d]\",\n                    me->descr.name, (int) offset[i], (int) i);\n        if ((bsizes[i] = NA_getBufferPtrAndSize(BufferObj[i], readonly,\n                        (void *) &buffers[i])) < 0)\n            return PyErr_Format(_Error,\n                    \"%s: Problem with %s buffer[%d].\",\n                    me->descr.name,\n                    readonly ? \"read\" : \"write\", (int) i);\n        buffers[i] += offset[i];\n        bsizes[i]  -= offset[i]; /* \"shorten\" buffer size by offset. */\n    }\n\n    ufuncptr = (UFUNC) me->descr.fptr;\n\n    /* If it's not a self-checking ufunc, check arg count match,\n       buffer size, and alignment for all buffers */\n    if (!me->descr.chkself &&\n            (NA_checkIo(me->descr.name,\n                        me->descr.wantIn, me->descr.wantOut, ninargs, noutargs) ||\n             NA_checkNCBuffers(me->descr.name, pnargs,\n                 niter, (void **) buffers, bsizes,\n                 me->descr.sizes, me->descr.iters)))\n        return NULL;\n\n    /* Since the parameters are valid, call the C Ufunc */\n    if (!(*ufuncptr)(niter, ninargs, noutargs, (void **)buffers, bsizes)) {\n        Py_INCREF(Py_None);\n        return Py_None;\n    } else {\n        return NULL;\n    }\n}", "path": "numpy\\numarray\\_capi.c", "repo_name": "chadnetzer/numpy-gaurdro", "stars": 1, "license": "bsd-3-clause", "language": "c", "size": 16606}
{"docstring": "/* Thomas Wang 32 bits integer hash function */\n", "func_signal": "unsigned long rk_hash(unsigned long key)", "code": "{\n  key += ~(key << 15);\n  key ^=  (key >> 10);\n  key +=  (key << 3);\n  key ^=  (key >> 6);\n  key += ~(key << 11);\n  key ^=  (key >> 16);\n  return key;\n}", "path": "numpy\\random\\mtrand\\randomkit.c", "repo_name": "chadnetzer/numpy-gaurdro", "stars": 1, "license": "bsd-3-clause", "language": "c", "size": 16606}
{"docstring": "/*NUMPY_API\n * See if array scalars can be cast.\n */\n", "func_signal": "NPY_NO_EXPORT Bool\nPyArray_CanCastScalar(PyTypeObject *from, PyTypeObject *to)", "code": "{\n    int fromtype;\n    int totype;\n\n    fromtype = _typenum_fromtypeobj((PyObject *)from, 0);\n    totype = _typenum_fromtypeobj((PyObject *)to, 0);\n    if (fromtype == PyArray_NOTYPE || totype == PyArray_NOTYPE) {\n        return FALSE;\n    }\n    return (Bool) PyArray_CanCastSafely(fromtype, totype);\n}", "path": "numpy\\core\\src\\multiarray\\convert_datatype.c", "repo_name": "chadnetzer/numpy-gaurdro", "stars": 1, "license": "bsd-3-clause", "language": "c", "size": 16606}
{"docstring": "/* NA_IoArray is a combination of NA_InputArray and NA_OutputArray.\n\n   Unlike NA_OutputArray, if a temporary is required it is initialized to a copy\n   of the input array.\n\n   Unlike NA_InputArray, deallocating any resulting temporary array results in a\n   copy from the temporary back to the original.\n   */\n", "func_signal": "static PyArrayObject *\nNA_IoArray(PyObject *a, NumarrayType t, int requires)", "code": "{\n    PyArrayObject *shadow = NA_InputArray(a, t, requires | NPY_UPDATEIFCOPY );\n\n    if (!shadow) return NULL;\n\n    /* Guard against non-writable, but otherwise satisfying requires.\n       In this case,  shadow == a.\n       */\n    if (!PyArray_ISWRITABLE(shadow)) {\n        PyErr_Format(PyExc_TypeError,\n                \"NA_IoArray: I/O array must be writable array\");\n        PyArray_XDECREF_ERR(shadow);\n        return NULL;\n    }\n\n    return shadow;\n}", "path": "numpy\\numarray\\_capi.c", "repo_name": "chadnetzer/numpy-gaurdro", "stars": 1, "license": "bsd-3-clause", "language": "c", "size": 16606}
{"docstring": "/*NUMPY_API\n *Check the type coercion rules.\n */\n", "func_signal": "NPY_NO_EXPORT int\nPyArray_CanCastSafely(int fromtype, int totype)", "code": "{\n    PyArray_Descr *from, *to;\n    int felsize, telsize;\n\n    if (fromtype == totype) {\n        return 1;\n    }\n    if (fromtype == PyArray_BOOL) {\n        return 1;\n    }\n    if (totype == PyArray_BOOL) {\n        return 0;\n    }\n    if (fromtype == PyArray_DATETIME || fromtype == PyArray_TIMEDELTA ||\n            totype == PyArray_DATETIME || totype == PyArray_TIMEDELTA) {\n        return 0;\n    }\n    if (totype == PyArray_OBJECT || totype == PyArray_VOID) {\n        return 1;\n    }\n    if (fromtype == PyArray_OBJECT || fromtype == PyArray_VOID) {\n        return 0;\n    }\n    from = PyArray_DescrFromType(fromtype);\n    /*\n     * cancastto is a PyArray_NOTYPE terminated C-int-array of types that\n     * the data-type can be cast to safely.\n     */\n    if (from->f->cancastto) {\n        int *curtype;\n        curtype = from->f->cancastto;\n        while (*curtype != PyArray_NOTYPE) {\n            if (*curtype++ == totype) {\n                return 1;\n            }\n        }\n    }\n    if (PyTypeNum_ISUSERDEF(totype)) {\n        return 0;\n    }\n    to = PyArray_DescrFromType(totype);\n    telsize = to->elsize;\n    felsize = from->elsize;\n    Py_DECREF(from);\n    Py_DECREF(to);\n\n    switch(fromtype) {\n    case PyArray_BYTE:\n    case PyArray_SHORT:\n    case PyArray_INT:\n    case PyArray_LONG:\n    case PyArray_LONGLONG:\n        if (PyTypeNum_ISINTEGER(totype)) {\n            if (PyTypeNum_ISUNSIGNED(totype)) {\n                return 0;\n            }\n            else {\n                return telsize >= felsize;\n            }\n        }\n        else if (PyTypeNum_ISFLOAT(totype)) {\n            if (felsize < 8) {\n                return telsize > felsize;\n            }\n            else {\n                return telsize >= felsize;\n            }\n        }\n        else if (PyTypeNum_ISCOMPLEX(totype)) {\n            if (felsize < 8) {\n                return (telsize >> 1) > felsize;\n            }\n            else {\n                return (telsize >> 1) >= felsize;\n            }\n        }\n        else {\n            return totype > fromtype;\n        }\n    case PyArray_UBYTE:\n    case PyArray_USHORT:\n    case PyArray_UINT:\n    case PyArray_ULONG:\n    case PyArray_ULONGLONG:\n        if (PyTypeNum_ISINTEGER(totype)) {\n            if (PyTypeNum_ISSIGNED(totype)) {\n                return telsize > felsize;\n            }\n            else {\n                return telsize >= felsize;\n            }\n        }\n        else if (PyTypeNum_ISFLOAT(totype)) {\n            if (felsize < 8) {\n                return telsize > felsize;\n            }\n            else {\n                return telsize >= felsize;\n            }\n        }\n        else if (PyTypeNum_ISCOMPLEX(totype)) {\n            if (felsize < 8) {\n                return (telsize >> 1) > felsize;\n            }\n            else {\n                return (telsize >> 1) >= felsize;\n            }\n        }\n        else {\n            return totype > fromtype;\n        }\n    case PyArray_FLOAT:\n    case PyArray_DOUBLE:\n    case PyArray_LONGDOUBLE:\n        if (PyTypeNum_ISCOMPLEX(totype)) {\n            return (telsize >> 1) >= felsize;\n        }\n        else {\n            return totype > fromtype;\n        }\n    case PyArray_CFLOAT:\n    case PyArray_CDOUBLE:\n    case PyArray_CLONGDOUBLE:\n        return totype > fromtype;\n    case PyArray_STRING:\n    case PyArray_UNICODE:\n        return totype > fromtype;\n    default:\n        return 0;\n    }\n}", "path": "numpy\\core\\src\\multiarray\\convert_datatype.c", "repo_name": "chadnetzer/numpy-gaurdro", "stars": 1, "license": "bsd-3-clause", "language": "c", "size": 16606}
{"docstring": "/* Convert from base time to extended time */\n", "func_signal": "static JSInt64\nPRMJ_ToExtendedTime(JSInt32 base_time)", "code": "{\n    JSInt64 exttime;\n    JSInt64 g1970GMTMicroSeconds;\n    JSInt64 low;\n    JSInt32 diff;\n    JSInt64  tmp;\n    JSInt64  tmp1;\n\n    diff = PRMJ_LocalGMTDifference();\n    JSLL_UI2L(tmp, PRMJ_USEC_PER_SEC);\n    JSLL_I2L(tmp1,diff);\n    JSLL_MUL(tmp,tmp,tmp1);\n\n    JSLL_UI2L(g1970GMTMicroSeconds,G1970GMTMICROHI);\n    JSLL_UI2L(low,G1970GMTMICROLOW);\n#ifndef JS_HAVE_LONG_LONG\n    JSLL_SHL(g1970GMTMicroSeconds,g1970GMTMicroSeconds,16);\n    JSLL_SHL(g1970GMTMicroSeconds,g1970GMTMicroSeconds,16);\n#else\n    JSLL_SHL(g1970GMTMicroSeconds,g1970GMTMicroSeconds,32);\n#endif\n    JSLL_ADD(g1970GMTMicroSeconds,g1970GMTMicroSeconds,low);\n\n    JSLL_I2L(exttime,base_time);\n    JSLL_ADD(exttime,exttime,g1970GMTMicroSeconds);\n    JSLL_SUB(exttime,exttime,tmp);\n    return exttime;\n}", "path": "js\\src\\prmjtime.c", "repo_name": "sherpya/sjs", "stars": 1, "license": "None", "language": "c", "size": 2508}
{"docstring": "/*\n * Perl-inspired join, reverse, and sort.\n */\n", "func_signal": "static JSBool\narray_join(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)", "code": "{\n    JSString *str;\n\n    if (JSVAL_IS_VOID(argv[0])) {\n        str = NULL;\n    } else {\n        str = js_ValueToString(cx, argv[0]);\n        if (!str)\n            return JS_FALSE;\n        argv[0] = STRING_TO_JSVAL(str);\n    }\n    return array_join_sub(cx, obj, TO_STRING, str, rval);\n}", "path": "js\\src\\jsarray.c", "repo_name": "sherpya/sjs", "stars": 1, "license": "None", "language": "c", "size": 2508}
{"docstring": "/*\n * Return a string that may eval to something similar to the original object.\n */\n", "func_signal": "static JSBool\nexn_toSource(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)", "code": "{\n    jsval *vp;\n    JSString *name, *message, *filename, *lineno_as_str, *result;\n    uint32 lineno;\n    size_t lineno_length, name_length, message_length, filename_length, length;\n    jschar *chars, *cp;\n\n    vp = argv + argc;   /* beginning of explicit local roots */\n\n    if (!OBJ_GET_PROPERTY(cx, obj,\n                          ATOM_TO_JSID(cx->runtime->atomState.nameAtom),\n                          rval)) {\n        return JS_FALSE;\n    }\n    name = js_ValueToString(cx, *rval);\n    if (!name)\n        return JS_FALSE;\n    *rval = STRING_TO_JSVAL(name);\n\n    if (!JS_GetProperty(cx, obj, js_message_str, &vp[0]) ||\n        !(message = js_ValueToSource(cx, vp[0]))) {\n        return JS_FALSE;\n    }\n    vp[0] = STRING_TO_JSVAL(message);\n\n    if (!JS_GetProperty(cx, obj, js_fileName_str, &vp[1]) ||\n        !(filename = js_ValueToSource(cx, vp[1]))) {\n        return JS_FALSE;\n    }\n    vp[1] = STRING_TO_JSVAL(filename);\n\n    if (!JS_GetProperty(cx, obj, js_lineNumber_str, &vp[2]) ||\n        !js_ValueToECMAUint32 (cx, vp[2], &lineno)) {\n        return JS_FALSE;\n    }\n\n    if (lineno != 0) {\n        lineno_as_str = js_ValueToString(cx, vp[2]);\n        if (!lineno_as_str)\n            return JS_FALSE;\n        lineno_length = JSSTRING_LENGTH(lineno_as_str);\n    } else {\n        lineno_as_str = NULL;\n        lineno_length = 0;\n    }\n\n    /* Magic 8, for the characters in ``(new ())''. */\n    name_length = JSSTRING_LENGTH(name);\n    message_length = JSSTRING_LENGTH(message);\n    length = 8 + name_length + message_length;\n\n    filename_length = JSSTRING_LENGTH(filename);\n    if (filename_length != 0) {\n        /* append filename as ``, {filename}'' */\n        length += 2 + filename_length;\n        if (lineno_as_str) {\n            /* append lineno as ``, {lineno_as_str}'' */\n            length += 2 + lineno_length;\n        }\n    } else {\n        if (lineno_as_str) {\n            /*\n             * no filename, but have line number,\n             * need to append ``, \"\", {lineno_as_str}''\n             */\n            length += 6 + lineno_length;\n        }\n    }\n\n    cp = chars = (jschar*) JS_malloc(cx, (length + 1) * sizeof(jschar));\n    if (!chars)\n        return JS_FALSE;\n\n    *cp++ = '('; *cp++ = 'n'; *cp++ = 'e'; *cp++ = 'w'; *cp++ = ' ';\n    js_strncpy(cp, JSSTRING_CHARS(name), name_length);\n    cp += name_length;\n    *cp++ = '(';\n    if (message_length != 0) {\n        js_strncpy(cp, JSSTRING_CHARS(message), message_length);\n        cp += message_length;\n    }\n\n    if (filename_length != 0) {\n        /* append filename as ``, {filename}'' */\n        *cp++ = ','; *cp++ = ' ';\n        js_strncpy(cp, JSSTRING_CHARS(filename), filename_length);\n        cp += filename_length;\n    } else {\n        if (lineno_as_str) {\n            /*\n             * no filename, but have line number,\n             * need to append ``, \"\", {lineno_as_str}''\n             */\n            *cp++ = ','; *cp++ = ' '; *cp++ = '\"'; *cp++ = '\"';\n        }\n    }\n    if (lineno_as_str) {\n        /* append lineno as ``, {lineno_as_str}'' */\n        *cp++ = ','; *cp++ = ' ';\n        js_strncpy(cp, JSSTRING_CHARS(lineno_as_str), lineno_length);\n        cp += lineno_length;\n    }\n\n    *cp++ = ')'; *cp++ = ')'; *cp = 0;\n\n    result = js_NewString(cx, chars, length, 0);\n    if (!result) {\n        JS_free(cx, chars);\n        return JS_FALSE;\n    }\n    *rval = STRING_TO_JSVAL(result);\n    return JS_TRUE;\n}", "path": "js\\src\\jsexn.c", "repo_name": "sherpya/sjs", "stars": 1, "license": "None", "language": "c", "size": 2508}
{"docstring": "/*\n * Convert between a JS (Unicode) string and the XDR representation.\n */\n", "func_signal": "JS_PUBLIC_API(JSBool)\nJS_XDRString(JSXDRState *xdr, JSString **strp)", "code": "{\n    uint32 nchars;\n    jschar *chars;\n\n    if (xdr->mode == JSXDR_ENCODE)\n        nchars = JSSTRING_LENGTH(*strp);\n    if (!JS_XDRUint32(xdr, &nchars))\n        return JS_FALSE;\n\n    if (xdr->mode == JSXDR_DECODE) {\n        chars = (jschar *) JS_malloc(xdr->cx, (nchars + 1) * sizeof(jschar));\n        if (!chars)\n            return JS_FALSE;\n    } else {\n        chars = JSSTRING_CHARS(*strp);\n    }\n\n    if (!XDRChars(xdr, chars, nchars))\n        goto bad;\n    if (xdr->mode == JSXDR_DECODE) {\n        chars[nchars] = 0;\n        *strp = JS_NewUCString(xdr->cx, chars, nchars);\n        if (!*strp)\n            goto bad;\n    }\n    return JS_TRUE;\n\nbad:\n    if (xdr->mode == JSXDR_DECODE)\n        JS_free(xdr->cx, chars);\n    return JS_FALSE;\n}", "path": "js\\src\\jsxdrapi.c", "repo_name": "sherpya/sjs", "stars": 1, "license": "None", "language": "c", "size": 2508}
{"docstring": "/*\n * basic time calculation functionality for localtime and gmtime\n * setups up prtm argument with correct values based upon input number\n * of seconds.\n */\n", "func_signal": "static void\nPRMJ_basetime(JSInt64 tsecs, PRMJTime *prtm)", "code": "{\n    /* convert tsecs back to year,month,day,hour,secs */\n    JSInt32 year    = 0;\n    JSInt32 month   = 0;\n    JSInt32 yday    = 0;\n    JSInt32 mday    = 0;\n    JSInt32 wday    = 6; /* start on a Sunday */\n    JSInt32 days    = 0;\n    JSInt32 seconds = 0;\n    JSInt32 minutes = 0;\n    JSInt32 hours   = 0;\n    JSInt32 isleap  = 0;\n\n    /* Temporaries used for various computations */\n    JSInt64 result;\n    JSInt64\tresult1;\n    JSInt64\tresult2;\n\n    JSInt64 base;\n\n    /* Some variables for intermediate result storage to make computing isleap\n       easier/faster */\n    JSInt32 fourCenturyBlocks;\n    JSInt32 centuriesLeft;\n    JSInt32 fourYearBlocksLeft;\n    JSInt32 yearsLeft;\n\n    /* Since leap years work by 400/100/4 year intervals, precompute the length\n       of those in seconds if they start at the beginning of year 1. */\n    JSInt64 fourYears;\n    JSInt64 century;\n    JSInt64 fourCenturies;\n\n    JSLL_UI2L(result, PRMJ_DAY_SECONDS);\n\n    JSLL_I2L(fourYears, PRMJ_FOUR_YEARS_DAYS);\n    JSLL_MUL(fourYears, fourYears, result);\n\n    JSLL_I2L(century, PRMJ_CENTURY_DAYS);\n    JSLL_MUL(century, century, result);\n\n    JSLL_I2L(fourCenturies, PRMJ_FOUR_CENTURIES_DAYS);\n    JSLL_MUL(fourCenturies, fourCenturies, result);\n\n    /* get the base time via UTC */\n    base = PRMJ_ToExtendedTime(0);\n    JSLL_UI2L(result,  PRMJ_USEC_PER_SEC);\n    JSLL_DIV(base,base,result);\n    JSLL_ADD(tsecs,tsecs,base);\n\n    /* Compute our |year|, |isleap|, and part of |days|.  When this part is\n       done, |year| should hold the year our date falls in (number of whole\n       years elapsed before our date), isleap should hold 1 if the year the\n       date falls in is a leap year and 0 otherwise. */\n\n    /* First do year 0; it's special and nonleap. */\n    JSLL_UI2L(result, PRMJ_YEAR_SECONDS);\n    if (!JSLL_CMP(tsecs,<,result)) {\n        days = PRMJ_YEAR_DAYS;\n        year = 1;\n        JSLL_SUB(tsecs, tsecs, result);\n    }\n\n    /* Now use those constants we computed above */\n    JSLL_UDIVMOD(&result1, &result2, tsecs, fourCenturies);\n    JSLL_L2I(fourCenturyBlocks, result1);\n    year += fourCenturyBlocks * 400;\n    days += fourCenturyBlocks * PRMJ_FOUR_CENTURIES_DAYS;\n    tsecs = result2;\n\n    JSLL_UDIVMOD(&result1, &result2, tsecs, century);\n    JSLL_L2I(centuriesLeft, result1);\n    year += centuriesLeft * 100;\n    days += centuriesLeft * PRMJ_CENTURY_DAYS;\n    tsecs = result2;\n\n    JSLL_UDIVMOD(&result1, &result2, tsecs, fourYears);\n    JSLL_L2I(fourYearBlocksLeft, result1);\n    year += fourYearBlocksLeft * 4;\n    days += fourYearBlocksLeft * PRMJ_FOUR_YEARS_DAYS;\n    tsecs = result2;\n\n    /* Recall that |result| holds PRMJ_YEAR_SECONDS */\n    JSLL_UDIVMOD(&result1, &result2, tsecs, result);\n    JSLL_L2I(yearsLeft, result1);\n    year += yearsLeft;\n    days += yearsLeft * PRMJ_YEAR_DAYS;\n    tsecs = result2;\n\n    /* now compute isleap.  Note that we don't have to use %, since we've\n       already computed those remainders.  Also note that they're all offset by\n       1 because of the 1 for year 0. */\n    isleap =\n        (yearsLeft == 3) && (fourYearBlocksLeft != 24 || centuriesLeft == 3);\n    JS_ASSERT(isleap ==\n              ((year % 4 == 0) && (year % 100 != 0 || year % 400 == 0)));\n\n    JSLL_UI2L(result1,PRMJ_DAY_SECONDS);\n\n    JSLL_DIV(result,tsecs,result1);\n    JSLL_L2I(mday,result);\n\n    /* let's find the month */\n    while(((month == 1 && isleap) ?\n            (mday >= mtab[month] + 1) :\n            (mday >= mtab[month]))){\n\t yday += mtab[month];\n\t days += mtab[month];\n\n\t mday -= mtab[month];\n\n         /* it's a Feb, check if this is a leap year */\n\t if(month == 1 && isleap != 0){\n\t     yday++;\n\t     days++;\n\t     mday--;\n\t }\n\t month++;\n    }\n\n    /* now adjust tsecs */\n    JSLL_MUL(result,result,result1);\n    JSLL_SUB(tsecs,tsecs,result);\n\n    mday++; /* day of month always start with 1 */\n    days += mday;\n    wday = (days + wday) % 7;\n\n    yday += mday;\n\n    /* get the hours */\n    JSLL_UI2L(result1,PRMJ_HOUR_SECONDS);\n    JSLL_DIV(result,tsecs,result1);\n    JSLL_L2I(hours,result);\n    JSLL_MUL(result,result,result1);\n    JSLL_SUB(tsecs,tsecs,result);\n\n    /* get minutes */\n    JSLL_UI2L(result1,60);\n    JSLL_DIV(result,tsecs,result1);\n    JSLL_L2I(minutes,result);\n    JSLL_MUL(result,result,result1);\n    JSLL_SUB(tsecs,tsecs,result);\n\n    JSLL_L2I(seconds,tsecs);\n\n    prtm->tm_usec  = 0L;\n    prtm->tm_sec   = (JSInt8)seconds;\n    prtm->tm_min   = (JSInt8)minutes;\n    prtm->tm_hour  = (JSInt8)hours;\n    prtm->tm_mday  = (JSInt8)mday;\n    prtm->tm_mon   = (JSInt8)month;\n    prtm->tm_wday  = (JSInt8)wday;\n    prtm->tm_year  = (JSInt16)year;\n    prtm->tm_yday  = (JSInt16)yday;\n}", "path": "js\\src\\prmjtime.c", "repo_name": "sherpya/sjs", "stars": 1, "license": "None", "language": "c", "size": 2508}
{"docstring": "/*\n * Determine if the id represents an array index or an XML property index.\n *\n * An id is an array index according to ECMA by (15.4):\n *\n * \"Array objects give special treatment to a certain class of property names.\n * A property name P (in the form of a string value) is an array index if and\n * only if ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal\n * to 2^32-1.\"\n *\n * In our implementation, it would be sufficient to check for JSVAL_IS_INT(id)\n * except that by using signed 32-bit integers we miss the top half of the\n * valid range. This function checks the string representation itself; note\n * that calling a standard conversion routine might allow strings such as\n * \"08\" or \"4.0\" as array indices, which they are not.\n */\n", "func_signal": "JSBool\njs_IdIsIndex(jsval id, jsuint *indexp)", "code": "{\n    JSString *str;\n    jschar *cp;\n\n    if (JSVAL_IS_INT(id)) {\n        jsint i;\n        i = JSVAL_TO_INT(id);\n        if (i < 0)\n            return JS_FALSE;\n        *indexp = (jsuint)i;\n        return JS_TRUE;\n    }\n\n    /* NB: id should be a string, but jsxml.c may call us with an object id. */\n    if (!JSVAL_IS_STRING(id))\n        return JS_FALSE;\n\n    str = JSVAL_TO_STRING(id);\n    cp = JSSTRING_CHARS(str);\n    if (JS7_ISDEC(*cp) && JSSTRING_LENGTH(str) < sizeof(MAXSTR)) {\n        jsuint index = JS7_UNDEC(*cp++);\n        jsuint oldIndex = 0;\n        jsuint c = 0;\n        if (index != 0) {\n            while (JS7_ISDEC(*cp)) {\n                oldIndex = index;\n                c = JS7_UNDEC(*cp);\n                index = 10*index + c;\n                cp++;\n            }\n        }\n\n        /* Ensure that all characters were consumed and we didn't overflow. */\n        if (*cp == 0 &&\n             (oldIndex < (MAXINDEX / 10) ||\n              (oldIndex == (MAXINDEX / 10) && c < (MAXINDEX % 10))))\n        {\n            *indexp = index;\n            return JS_TRUE;\n        }\n    }\n    return JS_FALSE;\n}", "path": "js\\src\\jsarray.c", "repo_name": "sherpya/sjs", "stars": 1, "license": "None", "language": "c", "size": 2508}
{"docstring": "/* Helper function for js_MergeSort. */\n", "func_signal": "static JSBool\nMergeArrays(MSortArgs *msa, void *src, void *dest, size_t run1, size_t run2)", "code": "{\n    void *arg, *a, *b, *c;\n    size_t elsize, runtotal;\n    int cmp_result;\n    JSComparator cmp;\n    JSBool fastcopy;\n\n    runtotal = run1 + run2;\n\n    elsize = msa->elsize;\n    cmp = msa->cmp;\n    arg = msa->arg;\n    fastcopy = msa->fastcopy;\n\n#define CALL_CMP(a, b) \\\n    if (!cmp(arg, (a), (b), &cmp_result)) return JS_FALSE;\n\n    /* Copy runs already in sorted order. */\n    b = (char *)src + run1 * elsize;\n    a = (char *)b - elsize;\n    CALL_CMP(a, b);\n    if (cmp_result <= 0) {\n        memcpy(dest, src, runtotal * elsize);\n        return JS_TRUE;\n    }\n\n#define COPY_ONE(p,q,n) \\\n    (fastcopy ? (void)(*(jsval*)(p) = *(jsval*)(q)) : (void)memcpy(p, q, n))\n\n    a = src;\n    c = dest;\n    for (; runtotal != 0; runtotal--) {\n        JSBool from_a = run2 == 0;\n        if (!from_a && run1 != 0) {\n            CALL_CMP(a,b);\n            from_a = cmp_result <= 0;\n        }\n\n        if (from_a) {\n            COPY_ONE(c, a, elsize);\n            run1--;\n            a = (char *)a + elsize;\n        } else {\n            COPY_ONE(c, b, elsize);\n            run2--;\n            b = (char *)b + elsize;\n        }\n        c = (char *)c + elsize;\n    }\n#undef COPY_ONE\n#undef CALL_CMP\n\n    return JS_TRUE;\n}", "path": "js\\src\\jsarray.c", "repo_name": "sherpya/sjs", "stars": 1, "license": "None", "language": "c", "size": 2508}
{"docstring": "/*\n * Set the value of the property at the given index to v assuming v is rooted.\n */\n", "func_signal": "static JSBool\nSetArrayElement(JSContext *cx, JSObject *obj, jsuint index, jsval v)", "code": "{\n    jsid id;\n\n    if (index <= JSVAL_INT_MAX) {\n        id = INT_TO_JSID(index);\n    } else {\n        if (!BigIndexToId(cx, obj, index, JS_TRUE, &id))\n            return JS_FALSE;\n        JS_ASSERT(id != JSVAL_VOID);\n    }\n    return OBJ_SET_PROPERTY(cx, obj, id, &v);\n}", "path": "js\\src\\jsarray.c", "repo_name": "sherpya/sjs", "stars": 1, "license": "None", "language": "c", "size": 2508}
{"docstring": "/* Get the DST timezone offset for the time passed in */\n", "func_signal": "JSInt64\nPRMJ_DSTOffset(JSInt64 local_time)", "code": "{\n    JSInt64 us2s;\n    time_t local;\n    JSInt32 diff;\n    JSInt64  maxtimet;\n    struct tm tm;\n    PRMJTime prtm;\n#ifndef HAVE_LOCALTIME_R\n    struct tm *ptm;\n#endif\n\n\n    JSLL_UI2L(us2s, PRMJ_USEC_PER_SEC);\n    JSLL_DIV(local_time, local_time, us2s);\n\n    /* get the maximum of time_t value */\n    JSLL_UI2L(maxtimet,PRMJ_MAX_UNIX_TIMET);\n\n    if(JSLL_CMP(local_time,>,maxtimet)){\n        JSLL_UI2L(local_time,PRMJ_MAX_UNIX_TIMET);\n    } else if(!JSLL_GE_ZERO(local_time)){\n        /*go ahead a day to make localtime work (does not work with 0) */\n        JSLL_UI2L(local_time,PRMJ_DAY_SECONDS);\n    }\n    JSLL_L2UI(local,local_time);\n    PRMJ_basetime(local_time,&prtm);\n#ifndef HAVE_LOCALTIME_R\n    ptm = localtime(&local);\n    if(!ptm){\n        return JSLL_ZERO;\n    }\n    tm = *ptm;\n#else\n    localtime_r(&local,&tm); /* get dst information */\n#endif\n\n    diff = ((tm.tm_hour - prtm.tm_hour) * PRMJ_HOUR_SECONDS) +\n\t((tm.tm_min - prtm.tm_min) * 60);\n\n    if(diff < 0){\n\tdiff += PRMJ_DAY_SECONDS;\n    }\n\n    JSLL_UI2L(local_time,diff);\n\n    JSLL_MUL(local_time,local_time,us2s);\n\n    return(local_time);\n}", "path": "js\\src\\prmjtime.c", "repo_name": "sherpya/sjs", "stars": 1, "license": "None", "language": "c", "size": 2508}
{"docstring": "/* DEBUG */\n", "func_signal": "JSBool\njs_ErrorToException(JSContext *cx, const char *message, JSErrorReport *reportp)", "code": "{\n    JSErrNum errorNumber;\n    const JSErrorFormatString *errorString;\n    JSExnType exn;\n    jsval tv[4];\n    JSTempValueRooter tvr;\n    JSBool ok;\n    JSObject *errProto, *errObject;\n    JSString *messageStr, *filenameStr;\n\n    /*\n     * Tell our caller to report immediately if cx has no active frames, or if\n     * this report is just a warning.\n     */\n    JS_ASSERT(reportp);\n    if (!cx->fp || JSREPORT_IS_WARNING(reportp->flags))\n        return JS_FALSE;\n\n    /* Find the exception index associated with this error. */\n    errorNumber = (JSErrNum) reportp->errorNumber;\n    errorString = js_GetLocalizedErrorMessage(cx, NULL, NULL, errorNumber);\n    exn = errorString ? errorString->exnType : JSEXN_NONE;\n    JS_ASSERT(exn < JSEXN_LIMIT);\n\n#if defined( DEBUG_mccabe ) && defined ( PRINTNAMES )\n    /* Print the error name and the associated exception name to stderr */\n    fprintf(stderr, \"%s\\t%s\\n\",\n            errortoexnname[errorNumber].name,\n            errortoexnname[errorNumber].exception);\n#endif\n\n    /*\n     * Return false (no exception raised) if no exception is associated\n     * with the given error number.\n     */\n    if (exn == JSEXN_NONE)\n        return JS_FALSE;\n\n    /*\n     * Prevent runaway recursion, via cx->generatingError.  If an out-of-memory\n     * error occurs, no exception object will be created, but we don't assume\n     * that OOM is the only kind of error that subroutines of this function\n     * called below might raise.\n     */\n    if (cx->generatingError)\n        return JS_FALSE;\n\n    /* After this point the control must flow through the label out. */\n    cx->generatingError = JS_TRUE;\n\n    /* Protect the newly-created strings below from nesting GCs. */\n    memset(tv, 0, sizeof tv);\n    JS_PUSH_TEMP_ROOT(cx, sizeof tv / sizeof tv[0], tv, &tvr);\n\n    /*\n     * Try to get an appropriate prototype by looking up the corresponding\n     * exception constructor name in the scope chain of the current context's\n     * top stack frame, or in the global object if no frame is active.\n     */\n    ok = js_GetClassPrototype(cx, NULL, INT_TO_JSID(exceptions[exn].key),\n                              &errProto);\n    if (!ok)\n        goto out;\n    tv[0] = OBJECT_TO_JSVAL(errProto);\n\n    errObject = js_NewObject(cx, &js_ErrorClass, errProto, NULL);\n    if (!errObject) {\n        ok = JS_FALSE;\n        goto out;\n    }\n    tv[1] = OBJECT_TO_JSVAL(errObject);\n\n    messageStr = JS_NewStringCopyZ(cx, message);\n    if (!messageStr) {\n        ok = JS_FALSE;\n        goto out;\n    }\n    tv[2] = STRING_TO_JSVAL(messageStr);\n\n    filenameStr = JS_NewStringCopyZ(cx, reportp->filename);\n    if (!filenameStr) {\n        ok = JS_FALSE;\n        goto out;\n    }\n    tv[3] = STRING_TO_JSVAL(filenameStr);\n\n    ok = InitExnPrivate(cx, errObject, messageStr, filenameStr,\n                        reportp->lineno, reportp);\n    if (!ok)\n        goto out;\n\n    JS_SetPendingException(cx, OBJECT_TO_JSVAL(errObject));\n\n    /* Flag the error report passed in to indicate an exception was raised. */\n    reportp->flags |= JSREPORT_EXCEPTION;\n\nout:\n    JS_POP_TEMP_ROOT(cx, &tvr);\n    cx->generatingError = JS_FALSE;\n    return ok;\n}", "path": "js\\src\\jsexn.c", "repo_name": "sherpya/sjs", "stars": 1, "license": "None", "language": "c", "size": 2508}
{"docstring": "/*\n * Perl-inspired push, pop, shift, unshift, and splice methods.\n */\n", "func_signal": "static JSBool\narray_push(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)", "code": "{\n    jsuint length, newlength;\n\n    if (!js_GetLengthProperty(cx, obj, &length))\n        return JS_FALSE;\n    newlength = length + argc;\n    if (!InitArrayElements(cx, obj, length, newlength, argv))\n        return JS_FALSE;\n\n    /* Per ECMA-262, return the new array length. */\n    if (!IndexToValue(cx, newlength, rval))\n        return JS_FALSE;\n    return js_SetLengthProperty(cx, obj, newlength);\n}", "path": "js\\src\\jsarray.c", "repo_name": "sherpya/sjs", "stars": 1, "license": "None", "language": "c", "size": 2508}
{"docstring": "/*\n * Python-esque sequence operations.\n */\n", "func_signal": "static JSBool\narray_concat(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)", "code": "{\n    jsval *vp, v;\n    JSObject *nobj, *aobj;\n    jsuint length, alength, slot;\n    uintN i;\n    JSBool hole;\n\n    /* Hoist the explicit local root address computation. */\n    vp = argv + argc;\n\n    /* Treat obj as the first argument; see ECMA 15.4.4.4. */\n    --argv;\n    JS_ASSERT(obj == JSVAL_TO_OBJECT(argv[0]));\n\n    /* Create a new Array object and store it in the rval local root. */\n    nobj = js_NewArrayObject(cx, 0, NULL);\n    if (!nobj)\n        return JS_FALSE;\n    *rval = OBJECT_TO_JSVAL(nobj);\n\n    /* Loop over [0, argc] to concat args into nobj, expanding all Arrays. */\n    length = 0;\n    for (i = 0; i <= argc; i++) {\n        if (!JS_CHECK_OPERATION_LIMIT(cx, JSOW_JUMP))\n            return JS_FALSE;\n        v = argv[i];\n        if (JSVAL_IS_OBJECT(v)) {\n            aobj = JSVAL_TO_OBJECT(v);\n            if (aobj && OBJ_GET_CLASS(cx, aobj) == &js_ArrayClass) {\n                if (!OBJ_GET_PROPERTY(cx, aobj,\n                                      ATOM_TO_JSID(cx->runtime->atomState\n                                                   .lengthAtom),\n                                      vp)) {\n                    return JS_FALSE;\n                }\n                if (!ValueIsLength(cx, *vp, &alength))\n                    return JS_FALSE;\n                for (slot = 0; slot < alength; slot++) {\n                    if (!JS_CHECK_OPERATION_LIMIT(cx, JSOW_JUMP) ||\n                        !GetArrayElement(cx, aobj, slot, &hole, vp)) {\n                        return JS_FALSE;\n                    }\n\n                    /*\n                     * Per ECMA 262, 15.4.4.4, step 9, ignore non-existent\n                     * properties.\n                     */\n                    if (!hole && !SetArrayElement(cx, nobj, length + slot, *vp))\n                        return JS_FALSE;\n                }\n                length += alength;\n                continue;\n            }\n        }\n\n        if (!SetArrayElement(cx, nobj, length, v))\n            return JS_FALSE;\n        length++;\n    }\n\n    return js_SetLengthProperty(cx, nobj, length);\n}", "path": "js\\src\\jsarray.c", "repo_name": "sherpya/sjs", "stars": 1, "license": "None", "language": "c", "size": 2508}
{"docstring": "/*\n * get the difference in seconds between this time zone and UTC (GMT)\n */\n", "func_signal": "JSInt32\nPRMJ_LocalGMTDifference()", "code": "{\n    struct tm ltime;\n\n    /* get the difference between this time zone and GMT */\n    memset((char *)&ltime,0,sizeof(ltime));\n    ltime.tm_mday = 2;\n    ltime.tm_year = 70;\n#ifdef SUNOS4\n    ltime.tm_zone = 0;\n    ltime.tm_gmtoff = 0;\n    return timelocal(&ltime) - (24 * 3600);\n#else\n    return mktime(&ltime) - (24L * 3600L);\n#endif\n}", "path": "js\\src\\prmjtime.c", "repo_name": "sherpya/sjs", "stars": 1, "license": "None", "language": "c", "size": 2508}
{"docstring": "/*\n * If the property at the given index exists, get its value into location\n * pointed by vp and set *hole to false. Otherwise set *hole to true and *vp\n * to JSVAL_VOID. This function assumes that the location pointed by vp is\n * properly rooted and can be used as GC-protected storage for temporaries.\n */\n", "func_signal": "static JSBool\nGetArrayElement(JSContext *cx, JSObject *obj, jsuint index, JSBool *hole,\n                jsval *vp)", "code": "{\n    jsid id;\n    JSObject *obj2;\n    JSProperty *prop;\n\n    if (index <= JSVAL_INT_MAX) {\n        id = INT_TO_JSID(index);\n    } else {\n        if (!BigIndexToId(cx, obj, index, JS_FALSE, &id))\n            return JS_FALSE;\n        if (id == JSVAL_VOID) {\n            *hole = JS_TRUE;\n            *vp = JSVAL_VOID;\n            return JS_TRUE;\n        }\n    }\n\n    if (!OBJ_LOOKUP_PROPERTY(cx, obj, id, &obj2, &prop))\n        return JS_FALSE;\n    if (!prop) {\n        *hole = JS_TRUE;\n        *vp = JSVAL_VOID;\n    } else {\n        OBJ_DROP_PROPERTY(cx, obj2, prop);\n        if (!OBJ_GET_PROPERTY(cx, obj, id, vp))\n            return JS_FALSE;\n        *hole = JS_FALSE;\n    }\n    return JS_TRUE;\n}", "path": "js\\src\\jsarray.c", "repo_name": "sherpya/sjs", "stars": 1, "license": "None", "language": "c", "size": 2508}
{"docstring": "/**\n * Convert between a C string and the XDR representation:\n * leading 32-bit count, then counted vector of chars,\n * then possibly \\0 padding to multiple of 4.\n */\n", "func_signal": "JS_PUBLIC_API(JSBool)\nJS_XDRCString(JSXDRState *xdr, char **sp)", "code": "{\n    uint32 len;\n\n    if (xdr->mode == JSXDR_ENCODE)\n        len = strlen(*sp);\n    JS_XDRUint32(xdr, &len);\n    if (xdr->mode == JSXDR_DECODE) {\n        if (!(*sp = (char *) JS_malloc(xdr->cx, len + 1)))\n            return JS_FALSE;\n    }\n    if (!JS_XDRBytes(xdr, *sp, len)) {\n        if (xdr->mode == JSXDR_DECODE)\n            JS_free(xdr->cx, *sp);\n        return JS_FALSE;\n    }\n    if (xdr->mode == JSXDR_DECODE) {\n        (*sp)[len] = '\\0';\n    } else if (xdr->mode == JSXDR_FREE) {\n        JS_free(xdr->cx, *sp);\n        *sp = NULL;\n    }\n    return JS_TRUE;\n}", "path": "js\\src\\jsxdrapi.c", "repo_name": "sherpya/sjs", "stars": 1, "license": "None", "language": "c", "size": 2508}
{"docstring": "/*\n * Convert to string.\n *\n * This method only uses JavaScript-modifiable properties name, message.  It\n * is left to the host to check for private data and report filename and line\n * number information along with this message.\n */\n", "func_signal": "static JSBool\nexn_toString(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)", "code": "{\n    jsval v;\n    JSString *name, *message, *result;\n    jschar *chars, *cp;\n    size_t name_length, message_length, length;\n\n    if (!OBJ_GET_PROPERTY(cx, obj,\n                          ATOM_TO_JSID(cx->runtime->atomState.nameAtom),\n                          &v)) {\n        return JS_FALSE;\n    }\n    name = JSVAL_IS_STRING(v) ? JSVAL_TO_STRING(v) : cx->runtime->emptyString;\n    *rval = STRING_TO_JSVAL(name);\n\n    if (!JS_GetProperty(cx, obj, js_message_str, &v))\n        return JS_FALSE;\n    message = JSVAL_IS_STRING(v) ? JSVAL_TO_STRING(v)\n                                 : cx->runtime->emptyString;\n\n    if (JSSTRING_LENGTH(message) != 0) {\n        name_length = JSSTRING_LENGTH(name);\n        message_length = JSSTRING_LENGTH(message);\n        length = (name_length ? name_length + 2 : 0) + message_length;\n        cp = chars = (jschar*) JS_malloc(cx, (length + 1) * sizeof(jschar));\n        if (!chars)\n            return JS_FALSE;\n\n        if (name_length) {\n            js_strncpy(cp, JSSTRING_CHARS(name), name_length);\n            cp += name_length;\n            *cp++ = ':'; *cp++ = ' ';\n        }\n        js_strncpy(cp, JSSTRING_CHARS(message), message_length);\n        cp += message_length;\n        *cp = 0;\n\n        result = js_NewString(cx, chars, length, 0);\n        if (!result) {\n            JS_free(cx, chars);\n            return JS_FALSE;\n        }\n    } else {\n        result = name;\n    }\n\n    *rval = STRING_TO_JSVAL(result);\n    return JS_TRUE;\n}", "path": "js\\src\\jsexn.c", "repo_name": "sherpya/sjs", "stars": 1, "license": "None", "language": "c", "size": 2508}
{"docstring": "/*\n * This sort is stable, i.e. sequence of equal elements is preserved.\n * See also bug #224128.\n */\n", "func_signal": "JSBool\njs_MergeSort(void *src, size_t nel, size_t elsize,\n             JSComparator cmp, void *arg, void *tmp)", "code": "{\n    void *swap, *vec1, *vec2;\n    MSortArgs msa;\n    size_t i, j, lo, hi, run;\n    JSBool fastcopy;\n    int cmp_result;\n\n    fastcopy = (cmp == sort_compare || cmp == sort_compare_strings);\n#define COPY_ONE(p,q,n) \\\n    (fastcopy ? (void)(*(jsval*)(p) = *(jsval*)(q)) : (void)memcpy(p, q, n))\n#define CALL_CMP(a, b) \\\n    if (!cmp(arg, (a), (b), &cmp_result)) return JS_FALSE;\n#define INS_SORT_INT 4\n\n    /*\n     * Apply insertion sort to small chunks to reduce the number of merge\n     * passes needed.\n     */\n    for (lo = 0; lo < nel; lo += INS_SORT_INT) {\n        hi = lo + INS_SORT_INT;\n        if (hi >= nel)\n            hi = nel;\n        for (i = lo + 1; i < hi; i++) {\n            vec1 = (char *)src + i * elsize;\n            vec2 = (char *)vec1 - elsize;\n            for (j = i; j > lo; j--) {\n                CALL_CMP(vec2, vec1);\n                /* \"<=\" instead of \"<\" insures the sort is stable */\n                if (cmp_result <= 0) {\n                    break;\n                }\n\n                /* Swap elements, using \"tmp\" as tmp storage */\n                COPY_ONE(tmp, vec2, elsize);\n                COPY_ONE(vec2, vec1, elsize);\n                COPY_ONE(vec1, tmp, elsize);\n                vec1 = vec2;\n                vec2 = (char *)vec1 - elsize;\n            }\n        }\n    }\n#undef CALL_CMP\n#undef COPY_ONE\n\n    msa.elsize = elsize;\n    msa.cmp = cmp;\n    msa.arg = arg;\n    msa.fastcopy = fastcopy;\n\n    vec1 = src;\n    vec2 = tmp;\n    for (run = INS_SORT_INT; run < nel; run *= 2) {\n        for (lo = 0; lo < nel; lo += 2 * run) {\n            hi = lo + run;\n            if (hi >= nel) {\n                memcpy((char *)vec2 + lo * elsize, (char *)vec1 + lo * elsize,\n                       (nel - lo) * elsize);\n                break;\n            }\n            if (!MergeArrays(&msa, (char *)vec1 + lo * elsize,\n                             (char *)vec2 + lo * elsize, run,\n                             hi + run > nel ? nel - hi : run)) {\n                return JS_FALSE;\n            }\n        }\n        swap = vec1;\n        vec1 = vec2;\n        vec2 = swap;\n    }\n    if (src != vec1)\n        memcpy(src, tmp, nel * elsize);\n\n    return JS_TRUE;\n}", "path": "js\\src\\jsarray.c", "repo_name": "sherpya/sjs", "stars": 1, "license": "None", "language": "c", "size": 2508}
{"docstring": "/*\n * FIXME: This performs lossy conversion and we need to switch to\n * js_XDRStringAtom while allowing to read older XDR files. See bug 325202.\n */\n", "func_signal": "JSBool\njs_XDRCStringAtom(JSXDRState *xdr, JSAtom **atomp)", "code": "{\n    JSString *str;\n    char *bytes;\n    JSBool ok;\n    uint32 nbytes;\n    JSAtom *atom;\n    JSContext *cx;\n    void *mark;\n\n    if (xdr->mode == JSXDR_ENCODE) {\n        JS_ASSERT(ATOM_IS_STRING(*atomp));\n        str = ATOM_TO_STRING(*atomp);\n        bytes = js_DeflateString(xdr->cx,\n                                 JSSTRING_CHARS(str),\n                                 JSSTRING_LENGTH(str));\n        if (!bytes)\n            return JS_FALSE;\n        ok = JS_XDRCString(xdr, &bytes);\n        JS_free(xdr->cx, bytes);\n        return ok;\n    }\n\n    /*\n     * Inline JS_XDRCString when decoding not to malloc temporary buffer\n     * just to free it after atomization. See bug 321985.\n     */\n    if (!JS_XDRUint32(xdr, &nbytes))\n        return JS_FALSE;\n    atom = NULL;\n    cx = xdr->cx;\n    mark = JS_ARENA_MARK(&cx->tempPool);\n    JS_ARENA_ALLOCATE_CAST(bytes, char *, &cx->tempPool,\n                           nbytes * sizeof *bytes);\n    if (!bytes)\n        JS_ReportOutOfMemory(cx);\n    else if (JS_XDRBytes(xdr, bytes, nbytes))\n        atom = js_Atomize(cx, bytes, nbytes, 0);\n    JS_ARENA_RELEASE(&cx->tempPool, mark);\n    if (!atom)\n        return JS_FALSE;\n    *atomp = atom;\n    return JS_TRUE;\n}", "path": "js\\src\\jsxdrapi.c", "repo_name": "sherpya/sjs", "stars": 1, "license": "None", "language": "c", "size": 2508}
{"docstring": "/* Format a time value into a buffer. Same semantics as strftime() */\n", "func_signal": "size_t\nPRMJ_FormatTime(char *buf, int buflen, const char *fmt, PRMJTime *prtm)", "code": "{\n#if defined(XP_UNIX) || defined(XP_WIN) || defined(XP_OS2) || defined(XP_BEOS)\n    struct tm a;\n\n    /* Zero out the tm struct.  Linux, SunOS 4 struct tm has extra members int\n     * tm_gmtoff, char *tm_zone; when tm_zone is garbage, strftime gets\n     * confused and dumps core.  NSPR20 prtime.c attempts to fill these in by\n     * calling mktime on the partially filled struct, but this doesn't seem to\n     * work as well; the result string has \"can't get timezone\" for ECMA-valid\n     * years.  Might still make sense to use this, but find the range of years\n     * for which valid tz information exists, and map (per ECMA hint) from the\n     * given year into that range.\n\n     * N.B. This hasn't been tested with anything that actually _uses_\n     * tm_gmtoff; zero might be the wrong thing to set it to if you really need\n     * to format a time.  This fix is for jsdate.c, which only uses\n     * JS_FormatTime to get a string representing the time zone.  */\n    memset(&a, 0, sizeof(struct tm));\n\n    a.tm_sec = prtm->tm_sec;\n    a.tm_min = prtm->tm_min;\n    a.tm_hour = prtm->tm_hour;\n    a.tm_mday = prtm->tm_mday;\n    a.tm_mon = prtm->tm_mon;\n    a.tm_wday = prtm->tm_wday;\n    a.tm_year = prtm->tm_year - 1900;\n    a.tm_yday = prtm->tm_yday;\n    a.tm_isdst = prtm->tm_isdst;\n\n    /* Even with the above, SunOS 4 seems to detonate if tm_zone and tm_gmtoff\n     * are null.  This doesn't quite work, though - the timezone is off by\n     * tzoff + dst.  (And mktime seems to return -1 for the exact dst\n     * changeover time.)\n\n     */\n\n#if defined(SUNOS4)\n    if (mktime(&a) == -1) {\n        /* Seems to fail whenever the requested date is outside of the 32-bit\n         * UNIX epoch.  We could proceed at this point (setting a.tm_zone to\n         * \"\") but then strftime returns a string with a 2-digit field of\n         * garbage for the year.  So we return 0 and hope jsdate.c\n         * will fall back on toString.\n         */\n        return 0;\n    }\n#endif\n\n    return strftime(buf, buflen, fmt, &a);\n#endif\n}", "path": "js\\src\\prmjtime.c", "repo_name": "sherpya/sjs", "stars": 1, "license": "None", "language": "c", "size": 2508}
{"docstring": "/*\n * When hole is true, delete the property at the given index. Otherwise set\n * its value to v assuming v is rooted.\n */\n", "func_signal": "static JSBool\nSetOrDeleteArrayElement(JSContext *cx, JSObject *obj, jsuint index,\n                        JSBool hole, jsval v)", "code": "{\n    if (hole) {\n        JS_ASSERT(v == JSVAL_VOID);\n        return DeleteArrayElement(cx, obj, index);\n    } else {\n        return SetArrayElement(cx, obj, index, v);\n    }\n}", "path": "js\\src\\jsarray.c", "repo_name": "sherpya/sjs", "stars": 1, "license": "None", "language": "c", "size": 2508}
{"docstring": "/*\n * Renders a beautiful wired teapot...\n */\n", "func_signal": "void FGAPIENTRY glutWireTeapot( GLdouble size )", "code": "{\n    FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutWireTeapot\" );\n    /* We will use the general teapot rendering code */\n    fghTeapot( 10, size, GL_LINE );\n}", "path": "Box2D\\Contrib\\freeglut\\freeglut_teapot.c", "repo_name": "jcnossen/ncrobot", "stars": 1, "license": "None", "language": "c", "size": 3432}
{"docstring": "/*\n * Draw a stroke character\n */\n", "func_signal": "void FGAPIENTRY glutStrokeCharacter( void* fontID, int character )", "code": "{\n    const SFG_StrokeChar *schar;\n    const SFG_StrokeStrip *strip;\n    int i, j;\n    SFG_StrokeFont* font;\n    FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutStrokeCharacter\" );\n    font = fghStrokeByID( fontID );\n    freeglut_return_if_fail( character >= 0 );\n    freeglut_return_if_fail( character < font->Quantity );\n    freeglut_return_if_fail( font );\n\n    schar = font->Characters[ character ];\n    freeglut_return_if_fail( schar );\n    strip = schar->Strips;\n\n    for( i = 0; i < schar->Number; i++, strip++ )\n    {\n        glBegin( GL_LINE_STRIP );\n        for( j = 0; j < strip->Number; j++ )\n            glVertex2f( strip->Vertices[ j ].X, strip->Vertices[ j ].Y );\n        glEnd( );\n    }\n    glTranslatef( schar->Right, 0.0, 0.0 );\n}", "path": "Box2D\\Contrib\\freeglut\\freeglut_font.c", "repo_name": "jcnossen/ncrobot", "stars": 1, "license": "None", "language": "c", "size": 3432}
{"docstring": "/*\n * Returns the height of a stroke font\n */\n", "func_signal": "GLfloat FGAPIENTRY glutStrokeHeight( void* fontID )", "code": "{\n    SFG_StrokeFont* font;\n    FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutStrokeHeight\" );\n    font = fghStrokeByID( fontID );\n    freeglut_return_val_if_fail( font, 0.0 );\n    return font->Height;\n}", "path": "Box2D\\Contrib\\freeglut\\freeglut_font.c", "repo_name": "jcnossen/ncrobot", "stars": 1, "license": "None", "language": "c", "size": 3432}
{"docstring": "/*\n * Sets the game mode display string\n */\n", "func_signal": "void FGAPIENTRY glutGameModeString( const char* string )", "code": "{\n    int width = 640, height = 480, depth = 16, refresh = 72;\n\n    FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutGameModeString\" );\n\n    /*\n     * This one seems a bit easier than glutInitDisplayString. The bad thing\n     * about it that I was unable to find the game mode string definition, so\n     * that I assumed it is: \"[width]x[height]:[depth]@[refresh rate]\", which\n     * appears in all GLUT game mode programs I have seen to date.\n     */\n    if( sscanf( string, \"%ix%i:%i@%i\", &width, &height, &depth, &refresh ) !=\n        4 )\n        if( sscanf( string, \"%ix%i:%i\", &width, &height, &depth ) != 3 )\n            if( sscanf( string, \"%ix%i@%i\", &width, &height, &refresh ) != 3 )\n                if( sscanf( string, \"%ix%i\", &width, &height ) != 2 )\n                    if( sscanf( string, \":%i@%i\", &depth, &refresh ) != 2 )\n                        if( sscanf( string, \":%i\", &depth ) != 1 )\n                            if( sscanf( string, \"@%i\", &refresh ) != 1 )\n                                fgWarning(\n                                    \"unable to parse game mode string `%s'\",\n                                    string\n                                );\n\n    /* Hopefully it worked, and if not, we still have the default values */\n    fgState.GameModeSize.X  = width;\n    fgState.GameModeSize.Y  = height;\n    fgState.GameModeDepth   = depth;\n    fgState.GameModeRefresh = refresh;\n}", "path": "Box2D\\Contrib\\freeglut\\freeglut_gamemode.c", "repo_name": "jcnossen/ncrobot", "stars": 1, "license": "None", "language": "c", "size": 3432}
{"docstring": "/*\n * Restores the previously remembered visual settings\n */\n", "func_signal": "static void fghRestoreState( void )", "code": "{\n#if TARGET_HOST_UNIX_X11\n\n#   ifdef X_XF86VidModeGetAllModeLines\n    /* Restore the remembered pointer position: */\n    XWarpPointer(\n        fgDisplay.Display, None, fgDisplay.RootWindow, 0, 0, 0, 0,\n        fgDisplay.DisplayPointerX, fgDisplay.DisplayPointerY\n    );\n\n    /*\n     * This highly depends on the XFree86 extensions,\n     * not approved as X Consortium standards\n     */\n\n    if( fgDisplay.DisplayModeValid )\n    {\n        XF86VidModeModeInfo** displayModes;\n        int i, displayModesCount;\n\n        if( !XF86VidModeGetAllModeLines(\n                 fgDisplay.Display,\n                 fgDisplay.Screen,\n                 &displayModesCount,\n                 &displayModes ) )\n        {\n            fgWarning( \"XF86VidModeGetAllModeLines failed\" );\n            return;\n        }\n\n\n        /*\n         * Check every of the modes looking for one that matches our demands.\n         * If we find one, switch to it and restore the remembered viewport.\n         */\n        for( i = 0; i < displayModesCount; i++ )\n        {\n            if(displayModes[ i ]->hdisplay == fgDisplay.DisplayMode.hdisplay &&\n               displayModes[ i ]->vdisplay == fgDisplay.DisplayMode.vdisplay &&\n               displayModes[ i ]->dotclock == fgDisplay.DisplayModeClock )\n            {\n                if( !XF86VidModeSwitchToMode(\n                         fgDisplay.Display,\n                         fgDisplay.Screen,\n                         displayModes[ i ] ) )\n                {\n                    fgWarning( \"XF86VidModeSwitchToMode failed\" );\n                    break;\n                }\n\n                if( !XF86VidModeSetViewPort(\n                         fgDisplay.Display,\n                         fgDisplay.Screen,\n                         fgDisplay.DisplayViewPortX,\n                         fgDisplay.DisplayViewPortY ) )\n                    fgWarning( \"XF86VidModeSetViewPort failed\" );\n\n\n                /*\n                 * For the case this would be the last X11 call the application\n                 * calls exit() we've to flush the X11 output queue to have the\n                 * commands sent to the X server before the application exits.\n                 */\n                XFlush( fgDisplay.Display );\n\n                break;\n            }\n        }\n        XFree( displayModes );\n    }\n\n#   else\n    /*\n     * XXX warning fghRestoreState: missing XFree86 video mode extensions,\n     * XXX game mode will not change screen resolution when activated\n     */\n#   endif\n\n#elif TARGET_HOST_WIN32 || TARGET_HOST_WINCE\n\n    /* Restore the previously rememebered desktop display settings */\n    ChangeDisplaySettings( &fgDisplay.DisplayMode, 0 );\n\n#endif\n}", "path": "Box2D\\Contrib\\freeglut\\freeglut_gamemode.c", "repo_name": "jcnossen/ncrobot", "stars": 1, "license": "None", "language": "c", "size": 3432}
{"docstring": "/*\n * Returns the height of a bitmap font\n */\n", "func_signal": "int FGAPIENTRY glutBitmapHeight( void* fontID )", "code": "{\n    SFG_Font* font;\n    FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutBitmapHeight\" );\n    font = fghFontByID( fontID );\n    freeglut_return_val_if_fail( font, 0 );\n    return font->Height;\n}", "path": "Box2D\\Contrib\\freeglut\\freeglut_font.c", "repo_name": "jcnossen/ncrobot", "stars": 1, "license": "None", "language": "c", "size": 3432}
{"docstring": "/*\n * Renders a beautiful filled teapot...\n */\n", "func_signal": "void FGAPIENTRY glutSolidTeapot( GLdouble size )", "code": "{\n    FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutSolidTeapot\" );\n    /* We will use the general teapot rendering code */\n    fghTeapot( 7, size, GL_FILL );\n}", "path": "Box2D\\Contrib\\freeglut\\freeglut_teapot.c", "repo_name": "jcnossen/ncrobot", "stars": 1, "license": "None", "language": "c", "size": 3432}
{"docstring": "/*\n * Checks all display modes settings against user's preferences.\n * Returns the mode number found or -1 if none could be found.\n */\n", "func_signal": "static int fghCheckDisplayModes( GLboolean exactMatch, int displayModesCount, XF86VidModeModeInfo** displayModes )", "code": "{\n    int i;\n    for( i = 0; i < displayModesCount; i++ )\n    {\n        /* Compute the displays refresh rate, dotclock comes in kHz. */\n        int refresh = ( displayModes[ i ]->dotclock * 1000 ) /\n                      ( displayModes[ i ]->htotal * displayModes[ i ]->vtotal );\n\n        if( fghCheckDisplayMode( displayModes[ i ]->hdisplay,\n                                 displayModes[ i ]->vdisplay,\n                                 fgState.GameModeDepth,\n                                 ( exactMatch ? refresh : fgState.GameModeRefresh ) ) ) {\n            return i;\n        }\n    }\n    return -1;\n}", "path": "Box2D\\Contrib\\freeglut\\freeglut_gamemode.c", "repo_name": "jcnossen/ncrobot", "stars": 1, "license": "None", "language": "c", "size": 3432}
{"docstring": "/*\n * Matches a font ID with a SFG_StrokeFont structure pointer.\n * This was changed to match the GLUT header style.\n */\n", "func_signal": "static SFG_StrokeFont* fghStrokeByID( void* font )", "code": "{\n    if( font == GLUT_STROKE_ROMAN      )\n        return &fgStrokeRoman;\n    if( font == GLUT_STROKE_MONO_ROMAN )\n        return &fgStrokeMonoRoman;\n\n    fgWarning( \"stroke font 0x%08x not found\", font );\n    return 0;\n}", "path": "Box2D\\Contrib\\freeglut\\freeglut_font.c", "repo_name": "jcnossen/ncrobot", "stars": 1, "license": "None", "language": "c", "size": 3432}
{"docstring": "/*\n * Changes the current display mode to match user's settings\n */\n", "func_signal": "static GLboolean fghChangeDisplayMode( GLboolean haveToTest )", "code": "{\n    GLboolean success = GL_FALSE;\n#if TARGET_HOST_UNIX_X11\n\n    /*\n     * This highly depends on the XFree86 extensions,\n     * not approved as X Consortium standards\n     */\n#   ifdef X_XF86VidModeGetAllModeLines\n\n    /*\n     * This is also used by applcations which b2Assert modes by calling\n     * glutGameModeGet(GLUT_GAME_MODE_POSSIBLE), so allow the b2Assert:\n     */\n    if( haveToTest || fgDisplay.DisplayModeValid )\n    {\n        XF86VidModeModeInfo** displayModes;\n        int i, displayModesCount;\n\n        if( !XF86VidModeGetAllModeLines(\n                 fgDisplay.Display,\n                 fgDisplay.Screen,\n                 &displayModesCount,\n                 &displayModes ) )\n        {\n            fgWarning( \"XF86VidModeGetAllModeLines failed\" );\n            return success;\n        }\n\n\n        /*\n         * Check every of the modes looking for one that matches our demands,\n         * ignoring the refresh rate if no exact match could be found.\n         */\n        i = fghCheckDisplayModes( GL_TRUE, displayModesCount, displayModes );\n        if( i < 0 ) {\n            i = fghCheckDisplayModes( GL_FALSE, displayModesCount, displayModes );\n        }\n        success = ( i < 0 ) ? GL_FALSE : GL_TRUE;\n\n        if( !haveToTest && success ) {\n            if( !XF86VidModeSwitchToMode(\n                     fgDisplay.Display,\n                     fgDisplay.Screen,\n                     displayModes[ i ] ) )\n                fgWarning( \"XF86VidModeSwitchToMode failed\" );\n        }\n\n        XFree( displayModes );\n    }\n\n#   else\n\n    /*\n     * XXX warning fghChangeDisplayMode: missing XFree86 video mode extensions,\n     * XXX game mode will not change screen resolution when activated\n     */\n    success = GL_TRUE;\n\n#   endif\n\n#elif TARGET_HOST_WIN32 || TARGET_HOST_WINCE\n\n    DEVMODE  devMode;\n    char *fggmstr = NULL;\n\n    success = GL_FALSE;\n\n    EnumDisplaySettings( NULL, -1, &devMode ); \n    devMode.dmFields |= DM_PELSWIDTH | DM_PELSHEIGHT | DM_BITSPERPEL | DM_DISPLAYFREQUENCY;\n\n    devMode.dmPelsWidth  = fgState.GameModeSize.X;\n    devMode.dmPelsHeight = fgState.GameModeSize.Y;\n    devMode.dmBitsPerPel = fgState.GameModeDepth;\n    devMode.dmDisplayFrequency = fgState.GameModeRefresh;\n    devMode.dmFields = DM_PELSWIDTH | DM_PELSHEIGHT | DM_BITSPERPEL | DM_DISPLAYFREQUENCY;\n\n    switch ( ChangeDisplaySettingsEx(NULL, &devMode, NULL, haveToTest ? CDS_TEST : CDS_FULLSCREEN , NULL) )\n    {\n    case DISP_CHANGE_SUCCESSFUL:\n        success = GL_TRUE;\n\n        /* update vars in case if windows switched to proper mode */\n        EnumDisplaySettings( NULL, FREEGLUT_ENUM_CURRENT_SETTINGS, &devMode );\n        fgState.GameModeSize.X  = devMode.dmPelsWidth;        \n        fgState.GameModeSize.Y  = devMode.dmPelsHeight;\n        fgState.GameModeDepth   = devMode.dmBitsPerPel;\n        fgState.GameModeRefresh = devMode.dmDisplayFrequency;\n\t\tbreak;\n    case DISP_CHANGE_RESTART:\n        fggmstr = \"The computer must be restarted for the graphics mode to work.\";\n        break;\n    case DISP_CHANGE_BADFLAGS:\n        fggmstr = \"An invalid set of flags was passed in.\";\n        break;\n    case DISP_CHANGE_BADPARAM:\n        fggmstr = \"An invalid parameter was passed in. This can include an invalid flag or combination of flags.\";\n        break;\n    case DISP_CHANGE_FAILED:\n        fggmstr = \"The display driver failed the specified graphics mode.\";\n        break;\n    case DISP_CHANGE_BADMODE:\n        fggmstr = \"The graphics mode is not supported.\";\n        break;\n    default:\n        fggmstr = \"Unknown error in graphics mode???\"; /* dunno if it is possible,MSDN does not mention any other error */\n        break;\n    }\n\n    if ( !success )\n        fgWarning(fggmstr); /* I'd rather get info whats going on in my program than wonder about */\n                            /* magic happenings behind my back, its lib for devels at last ;) */\n#endif\n\n    return success;\n}", "path": "Box2D\\Contrib\\freeglut\\freeglut_gamemode.c", "repo_name": "jcnossen/ncrobot", "stars": 1, "license": "None", "language": "c", "size": 3432}
{"docstring": "/*\n * Return the width in pixels of a stroke character\n */\n", "func_signal": "int FGAPIENTRY glutStrokeWidth( void* fontID, int character )", "code": "{\n    const SFG_StrokeChar *schar;\n    SFG_StrokeFont* font;\n    FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutStrokeWidth\" );\n    font = fghStrokeByID( fontID );\n    freeglut_return_val_if_fail( ( character >= 0 ) &&\n                                 ( character < font->Quantity ),\n                                 0\n    );\n    freeglut_return_val_if_fail( font, 0 );\n    schar = font->Characters[ character ];\n    freeglut_return_val_if_fail( schar, 0 );\n\n    return ( int )( schar->Right + 0.5 );\n}", "path": "Box2D\\Contrib\\freeglut\\freeglut_font.c", "repo_name": "jcnossen/ncrobot", "stars": 1, "license": "None", "language": "c", "size": 3432}
{"docstring": "/*\n * Matches a font ID with a SFG_Font structure pointer.\n * This was changed to match the GLUT header style.\n */\n", "func_signal": "static SFG_Font* fghFontByID( void* font )", "code": "{\n    if( font == GLUT_BITMAP_8_BY_13        )\n        return &fgFontFixed8x13;\n    if( font == GLUT_BITMAP_9_BY_15        )\n        return &fgFontFixed9x15;\n    if( font == GLUT_BITMAP_HELVETICA_10   )\n        return &fgFontHelvetica10;\n    if( font == GLUT_BITMAP_HELVETICA_12   )\n        return &fgFontHelvetica12;\n    if( font == GLUT_BITMAP_HELVETICA_18   )\n        return &fgFontHelvetica18;\n    if( font == GLUT_BITMAP_TIMES_ROMAN_10 )\n        return &fgFontTimesRoman10;\n    if( font == GLUT_BITMAP_TIMES_ROMAN_24 )\n        return &fgFontTimesRoman24;\n\n    fgWarning( \"font 0x%08x not found\", font );\n    return 0;\n}", "path": "Box2D\\Contrib\\freeglut\\freeglut_font.c", "repo_name": "jcnossen/ncrobot", "stars": 1, "license": "None", "language": "c", "size": 3432}
{"docstring": "/*\n * Returns the width in pixels of a font's character\n */\n", "func_signal": "int FGAPIENTRY glutBitmapWidth( void* fontID, int character )", "code": "{\n    SFG_Font* font;\n    FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutBitmapWidth\" );\n    font = fghFontByID( fontID );\n    freeglut_return_val_if_fail( character > 0 && character < 256, 0 );\n    freeglut_return_val_if_fail( font, 0 );\n    return *( font->Characters[ character ] );\n}", "path": "Box2D\\Contrib\\freeglut\\freeglut_font.c", "repo_name": "jcnossen/ncrobot", "stars": 1, "license": "None", "language": "c", "size": 3432}
{"docstring": "/*\n * Return the width of a string drawn using a stroke font\n */\n", "func_signal": "int FGAPIENTRY glutStrokeLength( void* fontID, const unsigned char* string )", "code": "{\n    unsigned char c;\n    float length = 0.0;\n    float this_line_length = 0.0;\n    SFG_StrokeFont* font;\n    FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutStrokeLength\" );\n    font = fghStrokeByID( fontID );\n    freeglut_return_val_if_fail( font, 0 );\n    if ( !string || ! *string )\n        return 0;\n\n    while( ( c = *string++) )\n        if( c < font->Quantity )\n        {\n            if( c == '\\n' ) /* EOL; reset the length of this line */\n            {\n                if( length < this_line_length )\n                    length = this_line_length;\n                this_line_length = 0.0;\n            }\n            else  /* Not an EOL, increment the length of this line */\n            {\n                const SFG_StrokeChar *schar = font->Characters[ c ];\n                if( schar )\n                    this_line_length += schar->Right;\n            }\n        }\n    if( length < this_line_length )\n        length = this_line_length;\n    return( int )( length + 0.5 );\n}", "path": "Box2D\\Contrib\\freeglut\\freeglut_font.c", "repo_name": "jcnossen/ncrobot", "stars": 1, "license": "None", "language": "c", "size": 3432}
{"docstring": "/*\n * Enters the game mode\n */\n", "func_signal": "int FGAPIENTRY glutEnterGameMode( void )", "code": "{\n    FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutEnterGameMode\" );\n\n    if( fgStructure.GameMode )\n        fgAddToWindowDestroyList( fgStructure.GameMode );\n    else\n        fghRememberState( );\n\n    if( ! fghChangeDisplayMode( GL_FALSE ) )\n    {\n        fgWarning( \"failed to change screen settings\" );\n        return 0;\n    }\n\n    fgStructure.GameMode = fgCreateWindow(\n        NULL, \"FREEGLUT\", 0, 0,\n        fgState.GameModeSize.X, fgState.GameModeSize.Y, GL_TRUE, GL_FALSE\n    );\n\n    fgStructure.GameMode->State.Width  = fgState.GameModeSize.X;\n    fgStructure.GameMode->State.Height = fgState.GameModeSize.Y;\n    fgStructure.GameMode->State.NeedToResize = GL_TRUE;\n\n    fgStructure.GameMode->State.IsGameMode = GL_TRUE;\n\n#if TARGET_HOST_UNIX_X11\n\n    /*\n     * Sync needed to avoid a real race, the Xserver must have really created\n     * the window before we can grab the pointer into it:\n     */\n    XSync( fgDisplay.Display, False );\n\n    /*\n     * Grab the pointer to confine it into the window after the calls to\n     * XWrapPointer() which ensure that the pointer really enters the window.\n     *\n     * We also need to wait here until XGrabPointer() returns GrabSuccess,\n     * otherwise the new window is not viewable yet and if the next function\n     * (XSetInputFocus) is called with a not yet viewable window, it will exit\n     * the application which we have to aviod, so wait until it's viewable:\n     */\n    while( GrabSuccess != XGrabPointer(\n               fgDisplay.Display, fgStructure.GameMode->Window.Handle,\n               TRUE,\n               ButtonPressMask | ButtonReleaseMask | ButtonMotionMask\n               | PointerMotionMask,\n               GrabModeAsync, GrabModeAsync,\n               fgStructure.GameMode->Window.Handle, None, CurrentTime) )\n        usleep( 100 );\n\n    /*\n     * Change input focus to the new window. This will exit the application\n     * if the new window is not viewable yet, see the XGrabPointer loop above.\n     */\n    XSetInputFocus(\n        fgDisplay.Display,\n        fgStructure.GameMode->Window.Handle,\n        RevertToNone,\n        CurrentTime\n    );\n\n    /* Move the Pointer to the middle of the fullscreen window */\n    XWarpPointer(\n        fgDisplay.Display,\n        None,\n        fgDisplay.RootWindow,\n        0, 0, 0, 0,\n        fgState.GameModeSize.X/2, fgState.GameModeSize.Y/2\n    );\n\n#   ifdef X_XF86VidModeSetViewPort\n\n    if( fgDisplay.DisplayModeValid )\n    {\n        int x, y;\n        Window child;\n\n        /* Change to viewport to the window topleft edge: */\n        if( !XF86VidModeSetViewPort( fgDisplay.Display, fgDisplay.Screen, 0, 0 ) )\n            fgWarning( \"XF86VidModeSetViewPort failed\" );\n\n        /*\n         * Final window repositioning: It could be avoided using an undecorated\n         * window using override_redirect, but this * would possily require\n         * more changes and investigation.\n         */\n\n        /* Get the current postion of the drawable area on screen */\n        XTranslateCoordinates(\n            fgDisplay.Display,\n            fgStructure.CurrentWindow->Window.Handle,\n            fgDisplay.RootWindow,\n            0, 0, &x, &y,\n            &child\n        );\n\n        /* Move the decorataions out of the topleft corner of the display */\n        XMoveWindow( fgDisplay.Display, fgStructure.CurrentWindow->Window.Handle,\n                     -x, -y);\n    }\n\n#endif\n\n    /* Grab the keyboard, too */\n    XGrabKeyboard(\n        fgDisplay.Display,\n        fgStructure.GameMode->Window.Handle,\n        FALSE,\n        GrabModeAsync, GrabModeAsync,\n        CurrentTime\n    );\n\n#endif\n\n    return fgStructure.GameMode->ID;\n}", "path": "Box2D\\Contrib\\freeglut\\freeglut_gamemode.c", "repo_name": "jcnossen/ncrobot", "stars": 1, "license": "None", "language": "c", "size": 3432}
{"docstring": "/*\n * Draw a bitmap character\n */\n", "func_signal": "void FGAPIENTRY glutBitmapCharacter( void* fontID, int character )", "code": "{\n    const GLubyte* face;\n    SFG_Font* font;\n    FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutBitmapCharacter\" );\n    font = fghFontByID( fontID );\n    freeglut_return_if_fail( ( character >= 1 )&&( character < 256 ) );\n    freeglut_return_if_fail( font );\n\n    /*\n     * Find the character we want to draw (???)\n     */\n    face = font->Characters[ character ];\n\n    glPushClientAttrib( GL_CLIENT_PIXEL_STORE_BIT );\n    glPixelStorei( GL_UNPACK_SWAP_BYTES,  GL_FALSE );\n    glPixelStorei( GL_UNPACK_LSB_FIRST,   GL_FALSE );\n    glPixelStorei( GL_UNPACK_ROW_LENGTH,  0        );\n    glPixelStorei( GL_UNPACK_SKIP_ROWS,   0        );\n    glPixelStorei( GL_UNPACK_SKIP_PIXELS, 0        );\n    glPixelStorei( GL_UNPACK_ALIGNMENT,   1        );\n    glBitmap(\n        face[ 0 ], font->Height,      /* The bitmap's width and height  */\n        font->xorig, font->yorig,     /* The origin in the font glyph   */\n        ( float )( face[ 0 ] ), 0.0,  /* The raster advance -- inc. x,y */\n        ( face + 1 )                  /* The packed bitmap data...      */\n    );\n    glPopClientAttrib( );\n}", "path": "Box2D\\Contrib\\freeglut\\freeglut_font.c", "repo_name": "jcnossen/ncrobot", "stars": 1, "license": "None", "language": "c", "size": 3432}
{"docstring": "/*\n * Checks a single display mode settings against user's preferences.\n */\n", "func_signal": "static GLboolean fghCheckDisplayMode( int width, int height, int depth, int refresh )", "code": "{\n    /* The desired values should be stored in fgState structure... */\n    return ( width == fgState.GameModeSize.X ) &&\n           ( height == fgState.GameModeSize.Y ) &&\n           ( depth == fgState.GameModeDepth ) &&\n           ( refresh == fgState.GameModeRefresh );\n}", "path": "Box2D\\Contrib\\freeglut\\freeglut_gamemode.c", "repo_name": "jcnossen/ncrobot", "stars": 1, "license": "None", "language": "c", "size": 3432}
{"docstring": "/* -- PRIVATE FUNCTIONS ---------------------------------------------------- */\n", "func_signal": "static void fghTeapot( GLint grid, GLdouble scale, GLenum type )", "code": "{\n#if TARGET_HOST_WINCE\n\t\tint i, numV=sizeof(strip_vertices)/4, numI=sizeof(strip_normals)/4;\n#else\n    double p[4][4][3], q[4][4][3], r[4][4][3], s[4][4][3];\n    long i, j, k, l;\n#endif\n\n    glPushAttrib( GL_ENABLE_BIT | GL_EVAL_BIT );\n    glEnable( GL_AUTO_NORMAL );\n    glEnable( GL_NORMALIZE );\n    glEnable( GL_MAP2_VERTEX_3 );\n    glEnable( GL_MAP2_TEXTURE_COORD_2 );\n\n    glPushMatrix();\n    glRotated( 270.0, 1.0, 0.0, 0.0 );\n    glScaled( 0.5 * scale, 0.5 * scale, 0.5 * scale );\n    glTranslated( 0.0, 0.0, -1.5 );\n\n#if TARGET_HOST_WINCE\n    glRotated( 90.0, 1.0, 0.0, 0.0 );\n    glBegin( GL_TRIANGLE_STRIP );\n\n    for( i = 0; i < numV-1; i++ )\n    {\n        int vidx = strip_vertices[i],\n            nidx = strip_normals[i];\n\n        if( vidx != -1 )\n        {\n            glNormal3fv( normals[nidx]  );\n            glVertex3fv( vertices[vidx] );\n        }\n        else\n        {\n            glEnd();\n            glBegin( GL_TRIANGLE_STRIP );\n        }\n    }\n\n    glEnd();\n#else\n    for (i = 0; i < 10; i++) {\n      for (j = 0; j < 4; j++) {\n        for (k = 0; k < 4; k++) {\n          for (l = 0; l < 3; l++) {\n            p[j][k][l] = cpdata[patchdata[i][j * 4 + k]][l];\n            q[j][k][l] = cpdata[patchdata[i][j * 4 + (3 - k)]][l];\n            if (l == 1)\n              q[j][k][l] *= -1.0;\n            if (i < 6) {\n              r[j][k][l] =\n                cpdata[patchdata[i][j * 4 + (3 - k)]][l];\n              if (l == 0)\n                r[j][k][l] *= -1.0;\n              s[j][k][l] = cpdata[patchdata[i][j * 4 + k]][l];\n              if (l == 0)\n                s[j][k][l] *= -1.0;\n              if (l == 1)\n                s[j][k][l] *= -1.0;\n            }\n          }\n        }\n      }\n\n      glMap2d(GL_MAP2_TEXTURE_COORD_2, 0.0, 1.0, 2, 2, 0.0, 1.0, 4, 2,\n        &tex[0][0][0]);\n      glMap2d(GL_MAP2_VERTEX_3, 0.0, 1.0, 3, 4, 0.0, 1.0, 12, 4,\n        &p[0][0][0]);\n      glMapGrid2d(grid, 0.0, 1.0, grid, 0.0, 1.0);\n      glEvalMesh2(type, 0, grid, 0, grid);\n      glMap2d(GL_MAP2_VERTEX_3, 0.0, 1.0, 3, 4, 0.0, 1.0, 12, 4,\n        &q[0][0][0]);\n      glEvalMesh2(type, 0, grid, 0, grid);\n      if (i < 6) {\n        glMap2d(GL_MAP2_VERTEX_3, 0.0, 1.0, 3, 4, 0.0, 1.0, 12, 4,\n          &r[0][0][0]);\n        glEvalMesh2(type, 0, grid, 0, grid);\n        glMap2d(GL_MAP2_VERTEX_3, 0.0, 1.0, 3, 4, 0.0, 1.0, 12, 4,\n          &s[0][0][0]);\n        glEvalMesh2(type, 0, grid, 0, grid);\n      }\n    }\n#endif  /* TARGET_HOST_WINCE */\n\n    glPopMatrix();\n    glPopAttrib();\n}", "path": "Box2D\\Contrib\\freeglut\\freeglut_teapot.c", "repo_name": "jcnossen/ncrobot", "stars": 1, "license": "None", "language": "c", "size": 3432}
{"docstring": "/*\n * Leaves the game mode\n */\n", "func_signal": "void FGAPIENTRY glutLeaveGameMode( void )", "code": "{\n    FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutLeaveGameMode\" );\n\n    freeglut_return_if_fail( fgStructure.GameMode );\n\n    fgStructure.GameMode->State.IsGameMode = GL_FALSE;\n\n    fgAddToWindowDestroyList( fgStructure.GameMode );\n    fgStructure.GameMode = NULL;\n\n#if TARGET_HOST_UNIX_X11\n\n    XUngrabPointer( fgDisplay.Display, CurrentTime );\n    XUngrabKeyboard( fgDisplay.Display, CurrentTime );\n\n#endif\n\n    fghRestoreState();\n}", "path": "Box2D\\Contrib\\freeglut\\freeglut_gamemode.c", "repo_name": "jcnossen/ncrobot", "stars": 1, "license": "None", "language": "c", "size": 3432}
{"docstring": "/*\n * Returns information concerning the freeglut game mode\n */\n", "func_signal": "int FGAPIENTRY glutGameModeGet( GLenum eWhat )", "code": "{\n    FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutGameModeGet\" );\n\n    switch( eWhat )\n    {\n    case GLUT_GAME_MODE_ACTIVE:\n        return !!fgStructure.GameMode;\n\n    case GLUT_GAME_MODE_POSSIBLE:\n        return fghChangeDisplayMode( GL_TRUE );\n\n    case GLUT_GAME_MODE_WIDTH:\n        return fgState.GameModeSize.X;\n\n    case GLUT_GAME_MODE_HEIGHT:\n        return fgState.GameModeSize.Y;\n\n    case GLUT_GAME_MODE_PIXEL_DEPTH:\n        return fgState.GameModeDepth;\n\n    case GLUT_GAME_MODE_REFRESH_RATE:\n        return fgState.GameModeRefresh;\n\n    case GLUT_GAME_MODE_DISPLAY_CHANGED:\n        /*\n         * This is true if the game mode has been activated successfully..\n         */\n        return !!fgStructure.GameMode;\n    }\n\n    fgWarning( \"Unknown gamemode get: %d\", eWhat );\n    return -1;\n}", "path": "Box2D\\Contrib\\freeglut\\freeglut_gamemode.c", "repo_name": "jcnossen/ncrobot", "stars": 1, "license": "None", "language": "c", "size": 3432}
{"docstring": "/**\n * empathy_new_message_dialog_show:\n * @parent: parent #GtkWindow of the dialog\n *\n * Create a new #EmpathyNewMessageDialog and show it.\n *\n * Return value: the new #EmpathyNewMessageDialog\n */\n", "func_signal": "GtkWidget *\nempathy_new_message_dialog_show (GtkWindow *parent)", "code": "{\n\tstatic EmpathyNewMessageDialog *dialog = NULL;\n\tGtkBuilder                     *gui;\n\tgchar                          *filename;\n\tGtkEntryCompletion             *completion;\n\tGtkListStore                   *model;\n\n\tif (dialog) {\n\t\tgtk_window_present (GTK_WINDOW (dialog->dialog));\n\t\treturn dialog->dialog;\n\t}\n\n\tdialog = g_new0 (EmpathyNewMessageDialog, 1);\n\n\t/* create a contact manager */\n\tdialog->contact_manager = empathy_contact_manager_dup_singleton ();\n\n\tfilename = empathy_file_lookup (\"empathy-new-message-dialog.ui\",\n\t\t\t\t\t\"libempathy-gtk\");\n\tgui = empathy_builder_get_file (filename,\n\t\t\t\t        \"new_message_dialog\", &dialog->dialog,\n\t\t\t\t        \"table_contact\", &dialog->table_contact,\n\t\t\t\t        \"entry_id\", &dialog->entry_id,\n\t\t\t\t\t\"button_chat\", &dialog->button_chat,\n\t\t\t\t\t\"button_call\",&dialog->button_call,\n\t\t\t\t        NULL);\n\tg_free (filename);\n\n\t/* text completion */\n\tcompletion = gtk_entry_completion_new ();\n\tmodel = gtk_list_store_new (3, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING);\n\tgtk_entry_completion_set_text_column (completion, COMPLETION_COL_TEXT);\n\tgtk_entry_completion_set_match_func (completion,\n\t\t\t\t\t     new_message_dialog_match_func,\n\t\t\t\t\t     NULL, NULL);\n\tgtk_entry_completion_set_model (completion, GTK_TREE_MODEL (model));\n\tgtk_entry_set_completion (GTK_ENTRY (dialog->entry_id), completion);\n\tg_signal_connect (completion, \"match-selected\",\n\t\t\t  G_CALLBACK (new_message_dialog_match_selected_cb),\n\t\t\t  dialog);\n\tg_object_unref (completion);\n\tg_object_unref (model);\n\n\tempathy_builder_connect (gui, dialog,\n\t\t\t       \"new_message_dialog\", \"destroy\", new_message_dialog_destroy_cb,\n\t\t\t       \"new_message_dialog\", \"response\", new_message_dialog_response_cb,\n\t\t\t       \"entry_id\", \"changed\", new_message_change_state_button_cb,\n\t\t\t       NULL);\n\n\tg_object_add_weak_pointer (G_OBJECT (dialog->dialog), (gpointer) &dialog);\n\n\tg_object_unref (gui);\n\n\t/* Create account chooser */\n\tdialog->account_chooser = empathy_account_chooser_new ();\n\tgtk_table_attach_defaults (GTK_TABLE (dialog->table_contact),\n\t\t\t\t   dialog->account_chooser,\n\t\t\t\t   1, 2, 0, 1);\n\tempathy_account_chooser_set_filter (EMPATHY_ACCOUNT_CHOOSER (dialog->account_chooser),\n\t\t\t\t\t    empathy_account_chooser_filter_is_connected,\n\t\t\t\t\t    NULL);\n\tgtk_widget_show (dialog->account_chooser);\n\n\tnew_message_dialog_account_changed_cb (dialog->account_chooser, dialog);\n\tg_signal_connect (dialog->account_chooser, \"changed\",\n\t\t\t  G_CALLBACK (new_message_dialog_account_changed_cb),\n\t\t\t  dialog);\n\n\tif (parent) {\n\t\tgtk_window_set_transient_for (GTK_WINDOW (dialog->dialog),\n\t\t\t\t\t      GTK_WINDOW (parent));\n\t}\n\n\tgtk_widget_set_sensitive (dialog->button_chat, FALSE);\n\tgtk_widget_set_sensitive (dialog->button_call, FALSE);\n\n\tgtk_widget_show (dialog->dialog);\n\n\treturn dialog->dialog;\n}", "path": "libempathy-gtk\\empathy-new-message-dialog.c", "repo_name": "zenios/empathy", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6928}
{"docstring": "/**\n * empathy_account_chooser_set_filter:\n * @chooser: an #EmpathyAccountChooser\n * @filter: a filter\n * @user_data: data to pass to @filter, or %NULL\n *\n * Sets a filter on the @chooser so only accounts that are %TRUE in the eyes\n * of the filter are visible in the @chooser.\n */\n", "func_signal": "void\nempathy_account_chooser_set_filter (EmpathyAccountChooser           *chooser,\n                                    EmpathyAccountChooserFilterFunc  filter,\n                                    gpointer                         user_data)", "code": "{\n\tEmpathyAccountChooserPriv *priv;\n\tGtkTreeModel *model;\n\n\tg_return_if_fail (EMPATHY_IS_ACCOUNT_CHOOSER (chooser));\n\n\tpriv = GET_PRIV (chooser);\n\n\tpriv->filter = filter;\n\tpriv->filter_data = user_data;\n\n\t/* Refilter existing data */\n\tpriv->set_active_item = FALSE;\n\tmodel = gtk_combo_box_get_model (GTK_COMBO_BOX (chooser));\n\tgtk_tree_model_foreach (model, account_chooser_filter_foreach, chooser);\n}", "path": "libempathy-gtk\\empathy-account-chooser.c", "repo_name": "zenios/empathy", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6928}
{"docstring": "/* Called from the streaming thread */\n", "func_signal": "static void\nempathy_call_window_src_added_cb (EmpathyCallHandler *handler,\n  GstPad *src, guint media_type, gpointer user_data)", "code": "{\n  EmpathyCallWindow *self = EMPATHY_CALL_WINDOW (user_data);\n  EmpathyCallWindowPriv *priv = GET_PRIV (self);\n\n  GstPad *pad;\n\n  g_mutex_lock (priv->lock);\n\n  if (priv->connected == FALSE)\n    {\n      g_timer_start (priv->timer);\n      priv->timer_id = g_idle_add  (empathy_call_window_connected, self);\n      priv->connected = TRUE;\n    }\n\n  switch (media_type)\n    {\n      case TP_MEDIA_STREAM_TYPE_AUDIO:\n        pad = empathy_call_window_get_audio_sink_pad (self);\n        break;\n      case TP_MEDIA_STREAM_TYPE_VIDEO:\n        gtk_widget_hide (priv->remote_user_avatar_widget);\n        gtk_widget_show (priv->video_output);\n        pad = empathy_call_window_get_video_sink_pad (self);\n        break;\n      default:\n        g_assert_not_reached ();\n    }\n\n  gst_pad_link (src, pad);\n  gst_object_unref (pad);\n\n  g_mutex_unlock (priv->lock);\n}", "path": "src\\empathy-call-window.c", "repo_name": "zenios/empathy", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6928}
{"docstring": "/**\n * empathy_account_chooser_filter_is_connected:\n * @account: an #McAccount\n * @user_data: user data or %NULL\n *\n * A useful #EmpathyAccountChooserFilterFunc that one could pass into\n * empathy_account_chooser_set_filter() and only show connected accounts.\n *\n * Return value: Whether @account is connected\n */\n", "func_signal": "gboolean\nempathy_account_chooser_filter_is_connected (McAccount *account,\n\t\t\t\t\t     gpointer   user_data)", "code": "{\n\tMissionControl     *mc;\n\tTpConnectionStatus  status;\n\n\tg_return_val_if_fail (MC_IS_ACCOUNT (account), FALSE);\n\n\tmc = empathy_mission_control_dup_singleton ();\n\tstatus = mission_control_get_connection_status (mc, account, NULL);\n\tg_object_unref (mc);\n\n\treturn status == TP_CONNECTION_STATUS_CONNECTED;\n}", "path": "libempathy-gtk\\empathy-account-chooser.c", "repo_name": "zenios/empathy", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6928}
{"docstring": "/* Returns whether or not the operation was successfully claimed */\n", "func_signal": "gboolean\nempathy_dispatch_operation_claim (EmpathyDispatchOperation *operation)", "code": "{\n  EmpathyDispatchOperationPriv *priv;\n\n  g_return_val_if_fail (EMPATHY_IS_DISPATCH_OPERATION (operation), FALSE);\n\n  priv = GET_PRIV (operation);\n\n  if (priv->status == EMPATHY_DISPATCHER_OPERATION_STATE_CLAIMED)\n    return FALSE;\n\n  empathy_dispatch_operation_set_status (operation,\n    EMPATHY_DISPATCHER_OPERATION_STATE_CLAIMED);\n\n  g_signal_emit (operation, signals[CLAIMED], 0);\n\n  return TRUE;\n}", "path": "libempathy\\empathy-dispatch-operation.c", "repo_name": "zenios/empathy", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6928}
{"docstring": "/* Called with global lock held */\n", "func_signal": "static GstPad *\nempathy_call_window_get_audio_sink_pad (EmpathyCallWindow *self)", "code": "{\n  EmpathyCallWindowPriv *priv = GET_PRIV (self);\n  GstPad *pad;\n\n  if (priv->liveadder == NULL)\n    {\n      priv->liveadder = gst_element_factory_make (\"liveadder\", NULL);\n\n      gst_bin_add (GST_BIN (priv->pipeline), priv->liveadder);\n      gst_bin_add (GST_BIN (priv->pipeline), priv->audio_output);\n\n      gst_element_link (priv->liveadder, priv->audio_output);\n\n      gst_element_set_state (priv->liveadder, GST_STATE_PLAYING);\n      gst_element_set_state (priv->audio_output, GST_STATE_PLAYING);\n    }\n\n  pad = gst_element_get_request_pad (priv->liveadder, \"sink%d\");\n\n  return pad;\n}", "path": "src\\empathy-call-window.c", "repo_name": "zenios/empathy", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6928}
{"docstring": "/**\n * empathy_account_manager_dup_connections:\n * @manager: a #EmpathyAccountManager\n *\n * Get a #GList of all ready #TpConnection. The list must be freed with\n * g_list_free, and its elements must be unreffed.\n *\n * Returns: the list of connections\n **/\n", "func_signal": "GList *\nempathy_account_manager_dup_connections (EmpathyAccountManager *manager)", "code": "{\n  EmpathyAccountManagerPriv *priv;\n  GHashTableIter iter;\n  gpointer connection;\n  GList *ret = NULL;\n\n  g_return_val_if_fail (EMPATHY_IS_ACCOUNT_MANAGER (manager), NULL);\n\n  priv = GET_PRIV (manager);\n\n  g_hash_table_iter_init (&iter, priv->connections);\n  while (g_hash_table_iter_next (&iter, &connection, NULL))\n    if (connection != NULL && tp_connection_is_ready (connection))\n      ret = g_list_prepend (ret, g_object_ref (connection));\n\n  return ret;\n}", "path": "libempathy\\empathy-account-manager.c", "repo_name": "zenios/empathy", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6928}
{"docstring": "/* Called from the streaming thread */\n", "func_signal": "static void\nempathy_call_window_sink_added_cb (EmpathyCallHandler *handler,\n  GstPad *sink, guint media_type, gpointer user_data)", "code": "{\n  EmpathyCallWindow *self = EMPATHY_CALL_WINDOW (user_data);\n  EmpathyCallWindowPriv *priv = GET_PRIV (self);\n  GstPad *pad;\n\n  switch (media_type)\n    {\n      case TP_MEDIA_STREAM_TYPE_AUDIO:\n        gst_bin_add (GST_BIN (priv->pipeline), priv->audio_input);\n\n        pad = gst_element_get_static_pad (priv->audio_input, \"src\");\n        gst_pad_link (pad, sink);\n\n        gst_element_set_state (priv->audio_input, GST_STATE_PLAYING);\n        break;\n      case TP_MEDIA_STREAM_TYPE_VIDEO:\n        if (priv->video_input != NULL)\n          {\n            pad = gst_element_get_request_pad (priv->video_tee, \"src%d\");\n            gst_pad_link (pad, sink);\n          }\n        break;\n      default:\n        g_assert_not_reached ();\n    }\n\n}", "path": "src\\empathy-call-window.c", "repo_name": "zenios/empathy", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6928}
{"docstring": "/* Called with global lock held */\n", "func_signal": "static GstPad *\nempathy_call_window_get_video_sink_pad (EmpathyCallWindow *self)", "code": "{\n  EmpathyCallWindowPriv *priv = GET_PRIV (self);\n  GstPad *pad;\n\n  if (priv->funnel == NULL)\n    {\n      GstElement *output;\n\n      output = empathy_video_widget_get_element (EMPATHY_VIDEO_WIDGET\n        (priv->video_output));\n\n      priv->funnel = gst_element_factory_make (\"fsfunnel\", NULL);\n\n      gst_bin_add (GST_BIN (priv->pipeline), priv->funnel);\n      gst_bin_add (GST_BIN (priv->pipeline), output);\n\n      gst_element_link (priv->funnel, output);\n\n      gst_element_set_state (priv->funnel, GST_STATE_PLAYING);\n      gst_element_set_state (output, GST_STATE_PLAYING);\n    }\n\n  pad = gst_element_get_request_pad (priv->funnel, \"sink%d\");\n\n  return pad;\n}", "path": "src\\empathy-call-window.c", "repo_name": "zenios/empathy", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6928}
{"docstring": "/**\n * empathy_account_manager_get_count:\n * @manager: a #EmpathyAccountManager\n *\n * Get the number of accounts.\n *\n * Returns: the number of accounts.\n **/\n", "func_signal": "int\nempathy_account_manager_get_count (EmpathyAccountManager *manager)", "code": "{\n  EmpathyAccountManagerPriv *priv;\n\n  g_return_val_if_fail (EMPATHY_IS_ACCOUNT_MANAGER (manager), 0);\n\n  priv = GET_PRIV (manager);\n\n  return g_hash_table_size (priv->accounts);\n}", "path": "libempathy\\empathy-account-manager.c", "repo_name": "zenios/empathy", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6928}
{"docstring": "/**\n * empathy_account_chooser_get_has_all_option:\n * @chooser: an #EmpathyAccountChooser\n *\n * Returns whether @chooser has the #EmpathyAccountChooser:has-all-option property\n * set to true.\n *\n * Return value: whether @chooser has the #EmpathyAccountChooser:has-all-option property\n * enabled.\n */\n", "func_signal": "gboolean\nempathy_account_chooser_get_has_all_option (EmpathyAccountChooser *chooser)", "code": "{\n\tEmpathyAccountChooserPriv *priv;\n\n\tg_return_val_if_fail (EMPATHY_IS_ACCOUNT_CHOOSER (chooser), FALSE);\n\n\tpriv = GET_PRIV (chooser);\n\t\n\treturn priv->has_all_option;\n}", "path": "libempathy-gtk\\empathy-account-chooser.c", "repo_name": "zenios/empathy", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6928}
{"docstring": "/**\n * empathy_account_chooser_dup_account:\n * @chooser: an #EmpathyAccountChooser\n *\n * Returns the account which is currently selected in the chooser or %NULL\n * if there is no account selected. The #McAccount returned should be\n * unrefed with g_object_unref() when finished with.\n *\n * Return value: a new ref to the #McAccount currently selected, or %NULL.\n */\n", "func_signal": "McAccount *\nempathy_account_chooser_dup_account (EmpathyAccountChooser *chooser)", "code": "{\n\tEmpathyAccountChooserPriv *priv;\n\tMcAccount                *account;\n\tGtkTreeModel             *model;\n\tGtkTreeIter               iter;\n\n\tg_return_val_if_fail (EMPATHY_IS_ACCOUNT_CHOOSER (chooser), NULL);\n\n\tpriv = GET_PRIV (chooser);\n\n\tmodel = gtk_combo_box_get_model (GTK_COMBO_BOX (chooser));\n\tif (!gtk_combo_box_get_active_iter (GTK_COMBO_BOX (chooser), &iter)) {\n\t\treturn NULL;\n\t}\n\n\tgtk_tree_model_get (model, &iter, COL_ACCOUNT_POINTER, &account, -1);\n\n\treturn account;\n}", "path": "libempathy-gtk\\empathy-account-chooser.c", "repo_name": "zenios/empathy", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6928}
{"docstring": "/**\n * empathy_irc_network_dialog_show:\n * @network: the #EmpathyIrcNetwork to configure\n * @parent: the parent of this dialog\n *\n * Display a dialog to configure a given #EmpathyIrcNetwork.\n * This function is a singleton so if a configuration dialog already\n * exists we use this one to edit the network.\n *\n * Returns: The displayed #GtkDialog\n */\n", "func_signal": "GtkWidget *\nempathy_irc_network_dialog_show (EmpathyIrcNetwork *network,\n                                 GtkWidget *parent)", "code": "{\n  static EmpathyIrcNetworkDialog *dialog = NULL;\n  GtkBuilder *gui;\n  GtkListStore *store;\n  GtkCellRenderer *renderer;\n  GtkAdjustment *adjustment;\n  GtkTreeSelection *selection;\n  GtkTreeViewColumn *column;\n  gchar *filename;\n\n  g_return_val_if_fail (network != NULL, NULL);\n\n  if (dialog != NULL)\n    {\n      change_network (dialog, network);\n      gtk_window_present (GTK_WINDOW (dialog->dialog));\n\n      return dialog->dialog;\n    }\n\n  dialog = g_slice_new0 (EmpathyIrcNetworkDialog);\n\n  dialog->network = network;\n  g_object_ref (dialog->network);\n\n  filename = empathy_file_lookup (\"empathy-account-widget-irc.ui\",\n      \"libempathy-gtk\");\n  gui = empathy_builder_get_file (filename,\n      \"irc_network_dialog\", &dialog->dialog,\n      \"button_close\", &dialog->button_close,\n      \"entry_network\", &dialog->entry_network,\n      \"combobox_charset\", &dialog->combobox_charset,\n      \"treeview_servers\", &dialog->treeview_servers,\n      \"button_add\", &dialog->button_add,\n      \"button_remove\", &dialog->button_remove,\n      \"button_up\", &dialog->button_up,\n      \"button_down\", &dialog->button_down,\n      NULL);\n  g_free (filename);\n\n  store = gtk_list_store_new (4, G_TYPE_OBJECT, G_TYPE_STRING,\n      G_TYPE_UINT, G_TYPE_BOOLEAN);\n  gtk_tree_view_set_model (GTK_TREE_VIEW (dialog->treeview_servers),\n      GTK_TREE_MODEL (store));\n  g_object_unref (store);\n\n  /* address */\n  renderer = gtk_cell_renderer_text_new ();\n  g_object_set (renderer, \"editable\", TRUE, NULL);\n  g_signal_connect (renderer, \"edited\",\n      G_CALLBACK (irc_network_dialog_address_edited_cb), dialog);\n  gtk_tree_view_insert_column_with_attributes (\n      GTK_TREE_VIEW (dialog->treeview_servers),\n      -1, _(\"Server\"), renderer, \"text\", COL_ADR,\n      NULL);\n\n  /* port */\n  adjustment = (GtkAdjustment *) gtk_adjustment_new (6667, 1, G_MAXUINT16,\n      1, 10, 0);\n  renderer = gtk_cell_renderer_spin_new ();\n  g_object_set (renderer,\n      \"editable\", TRUE,\n      \"adjustment\", adjustment,\n      NULL);\n  g_signal_connect (renderer, \"edited\",\n      G_CALLBACK (irc_network_dialog_port_edited_cb), dialog);\n  gtk_tree_view_insert_column_with_attributes (\n      GTK_TREE_VIEW (dialog->treeview_servers),\n      -1, _(\"Port\"), renderer, \"text\", COL_PORT,\n      NULL);\n  column = gtk_tree_view_get_column (GTK_TREE_VIEW (dialog->treeview_servers),\n      1);\n  gtk_tree_view_column_set_expand (column, TRUE);\n\n  /* SSL */\n  renderer = gtk_cell_renderer_toggle_new ();\n  g_object_set (renderer, \"activatable\", TRUE, NULL);\n  g_signal_connect (renderer, \"toggled\",\n      G_CALLBACK (irc_network_dialog_ssl_toggled_cb), dialog);\n  gtk_tree_view_insert_column_with_attributes (\n      GTK_TREE_VIEW (dialog->treeview_servers),\n      -1, _(\"SSL\"), renderer, \"active\", COL_SSL,\n      NULL);\n\n  selection = gtk_tree_view_get_selection (\n      GTK_TREE_VIEW (dialog->treeview_servers));\n  gtk_tree_selection_set_mode (selection, GTK_SELECTION_SINGLE);\n\n  /* charset */\n  totem_subtitle_encoding_init (GTK_COMBO_BOX (dialog->combobox_charset));\n\n  irc_network_dialog_setup (dialog);\n\n  empathy_builder_connect (gui, dialog,\n      \"irc_network_dialog\", \"destroy\", irc_network_dialog_destroy_cb,\n      \"button_close\", \"clicked\", irc_network_dialog_close_clicked_cb,\n      \"entry_network\", \"focus-out-event\", irc_network_dialog_network_focus_cb,\n      \"button_add\", \"clicked\", irc_network_dialog_button_add_clicked_cb,\n      \"button_remove\", \"clicked\", irc_network_dialog_button_remove_clicked_cb,\n      \"button_up\", \"clicked\", irc_network_dialog_button_up_clicked_cb,\n      \"button_down\", \"clicked\", irc_network_dialog_button_down_clicked_cb,\n      \"combobox_charset\", \"changed\", irc_network_dialog_combobox_charset_changed_cb,\n      NULL);\n\n  g_object_unref (gui);\n\n  g_object_add_weak_pointer (G_OBJECT (dialog->dialog),\n      (gpointer) &dialog);\n\n  g_signal_connect (selection, \"changed\",\n      G_CALLBACK (irc_network_dialog_selection_changed_cb),\n      dialog);\n\n  gtk_window_set_transient_for (GTK_WINDOW (dialog->dialog),\n      GTK_WINDOW (parent));\n  gtk_window_set_modal (GTK_WINDOW (dialog->dialog), TRUE);\n\n  irc_network_dialog_network_update_buttons (dialog);\n  gtk_widget_show_all (dialog->dialog);\n\n  return dialog->dialog;\n}", "path": "libempathy-gtk\\empathy-irc-network-dialog.c", "repo_name": "zenios/empathy", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6928}
{"docstring": "/* Instead of specifying a width and a height, we specify only one size. That's\n   because we want a square avatar icon.  */\n", "func_signal": "static void\ninit_contact_avatar_with_size (EmpathyContact *contact, GtkWidget *image_widget,\n    gint size)", "code": "{\n\n  GdkPixbuf *pixbuf_avatar = NULL;\n\n  if (contact != NULL)\n    {\n      pixbuf_avatar = empathy_pixbuf_avatar_from_contact_scaled (contact,\n        size, size);\n    }\n\n  if (pixbuf_avatar == NULL)\n    {\n      pixbuf_avatar = empathy_pixbuf_from_icon_name_sized (\"stock_person\",\n          size);\n    }\n\n  gtk_image_set_from_pixbuf (GTK_IMAGE (image_widget), pixbuf_avatar);\n}", "path": "src\\empathy-call-window.c", "repo_name": "zenios/empathy", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6928}
{"docstring": "/**\n * empathy_account_chooser_get_connection:\n * @chooser: an #EmpathyAccountChooser\n *\n * Returns a borrowed reference to the #TpConnection associated with the\n * account currently selected. The caller must reference the returned object with\n * g_object_ref() if it will be kept\n *\n * Return value: a borrowed reference to the #TpConnection associated with the\n * account curently selected.\n */\n", "func_signal": "TpConnection *\nempathy_account_chooser_get_connection (EmpathyAccountChooser *chooser)", "code": "{\n\tEmpathyAccountChooserPriv *priv;\n\tMcAccount                 *account;\n\tTpConnection              *connection;\n\n\tg_return_val_if_fail (EMPATHY_IS_ACCOUNT_CHOOSER (chooser), NULL);\n\n\tpriv = GET_PRIV (chooser);\n\n\taccount = empathy_account_chooser_dup_account (chooser);\n\tconnection = empathy_account_manager_get_connection (priv->manager, account);\n\tg_object_unref (account);\n\n\treturn connection;\n}", "path": "libempathy-gtk\\empathy-account-chooser.c", "repo_name": "zenios/empathy", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6928}
{"docstring": "/**\n * empathy_account_chooser_set_account:\n * @chooser: an #EmpathyAccountChooser\n * @account: an #McAccount\n *\n * Sets the currently selected account to @account, if it exists in the list.\n *\n * Return value: whether the chooser was set to @account.\n */\n", "func_signal": "gboolean\nempathy_account_chooser_set_account (EmpathyAccountChooser *chooser,\n\t\t\t\t     McAccount             *account)", "code": "{\n\tGtkComboBox    *combobox;\n\tGtkTreeModel   *model;\n\tGtkTreeIter     iter;\n\tSetAccountData  data;\n\n\tg_return_val_if_fail (EMPATHY_IS_ACCOUNT_CHOOSER (chooser), FALSE);\n\n\tcombobox = GTK_COMBO_BOX (chooser);\n\tmodel = gtk_combo_box_get_model (combobox);\n\tgtk_combo_box_get_active_iter (combobox, &iter);\n\n\tdata.chooser = chooser;\n\tdata.account = account;\n\n\tgtk_tree_model_foreach (model,\n\t\t\t\t(GtkTreeModelForeachFunc) account_chooser_set_account_foreach,\n\t\t\t\t&data);\n\n\treturn data.set;\n}", "path": "libempathy-gtk\\empathy-account-chooser.c", "repo_name": "zenios/empathy", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6928}
{"docstring": "/**\n * empathy_account_chooser_new:\n *\n * Creates a new #EmpathyAccountChooser.\n *\n * Return value: A new #EmpathyAccountChooser\n */\n", "func_signal": "GtkWidget *\nempathy_account_chooser_new (void)", "code": "{\n\tGtkWidget                *chooser;\n\n\tchooser = g_object_new (EMPATHY_TYPE_ACCOUNT_CHOOSER, NULL);\n\n\treturn chooser;\n}", "path": "libempathy-gtk\\empathy-account-chooser.c", "repo_name": "zenios/empathy", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6928}
{"docstring": "/**\n * empathy_account_manager_get_connection:\n * @manager: a #EmpathyAccountManager\n * @account: a #McAccount\n *\n * Get the connection of the accounts, or NULL if account is offline or the\n * connection is not yet ready. This function does not return a new ref.\n *\n * Returns: the connection of the accounts.\n **/\n", "func_signal": "TpConnection *\nempathy_account_manager_get_connection (EmpathyAccountManager *manager,\n                                        McAccount *account)", "code": "{\n  EmpathyAccountManagerPriv *priv;\n  AccountData *data;\n\n  g_return_val_if_fail (EMPATHY_IS_ACCOUNT_MANAGER (manager), NULL);\n  g_return_val_if_fail (MC_IS_ACCOUNT (account), NULL);\n\n  priv = GET_PRIV (manager);\n\n  data = g_hash_table_lookup (priv->accounts, account);\n  if (data && data->connection && tp_connection_is_ready (data->connection))\n    return data->connection;\n\n  return NULL;\n}", "path": "libempathy\\empathy-account-manager.c", "repo_name": "zenios/empathy", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6928}
{"docstring": "/**\n * empathy_ft_factory_new_transfer_outgoing:\n * @factory: an #EmpathyFTFactory\n * @contact: the #EmpathyContact destination of the transfer\n * @source: the #GFile to be transferred to @contact\n *\n * Trigger the creation of an #EmpathyFTHandler object to send @source to\n * the specified @contact.\n */\n", "func_signal": "void\nempathy_ft_factory_new_transfer_outgoing (EmpathyFTFactory *factory,\n    EmpathyContact *contact,\n    GFile *source)", "code": "{\n  g_return_if_fail (EMPATHY_IS_FT_FACTORY (factory));\n  g_return_if_fail (EMPATHY_IS_CONTACT (contact));\n  g_return_if_fail (G_IS_FILE (source));\n\n  empathy_ft_handler_new_outgoing (contact, source,\n      ft_handler_outgoing_ready_cb, factory);\n}", "path": "libempathy\\empathy-ft-factory.c", "repo_name": "zenios/empathy", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6928}
{"docstring": "/**\n * empathy_account_chooser_set_has_all_option:\n * @chooser: an #EmpathyAccountChooser\n * @has_all_option: a new value for the #EmpathyAccountChooser:has-all-option property\n *\n * Sets the #EmpathyAccountChooser:has-all-option property.\n */\n", "func_signal": "void\nempathy_account_chooser_set_has_all_option (EmpathyAccountChooser *chooser,\n\t\t\t\t\t   gboolean              has_all_option)", "code": "{\n\tEmpathyAccountChooserPriv *priv;\n\tGtkComboBox              *combobox;\n\tGtkListStore             *store;\n\tGtkTreeModel             *model;\n\tGtkTreeIter               iter;\n\n\tg_return_if_fail (EMPATHY_IS_ACCOUNT_CHOOSER (chooser));\n\n\tpriv = GET_PRIV (chooser);\n\n\tif (priv->has_all_option == has_all_option) {\n\t\treturn;\n\t}\n\n\tcombobox = GTK_COMBO_BOX (chooser);\n\tmodel = gtk_combo_box_get_model (combobox);\n\tstore = GTK_LIST_STORE (model);\n\n\tpriv->has_all_option = has_all_option;\n\n\t/*\n\t * The first 2 options are the ALL and separator\n\t */\n\n\tif (has_all_option) {\n\t\tgtk_combo_box_set_row_separator_func (GTK_COMBO_BOX (chooser),\n\t\t\t\t\t\t      (GtkTreeViewRowSeparatorFunc)\n\t\t\t\t\t\t      account_chooser_separator_func,\n\t\t\t\t\t\t      chooser,\n\t\t\t\t\t\t      NULL);\n\n\t\tgtk_list_store_prepend (store, &iter);\n\t\tgtk_list_store_set (store, &iter,\n\t\t\t\t    COL_ACCOUNT_TEXT, NULL,\n\t\t\t\t    COL_ACCOUNT_ENABLED, TRUE,\n\t\t\t\t    COL_ACCOUNT_POINTER, NULL,\n\t\t\t\t    -1);\n\n\t\tgtk_list_store_prepend (store, &iter);\n\t\tgtk_list_store_set (store, &iter,\n\t\t\t\t    COL_ACCOUNT_TEXT, _(\"All\"),\n\t\t\t\t    COL_ACCOUNT_ENABLED, TRUE,\n\t\t\t\t    COL_ACCOUNT_POINTER, NULL,\n\t\t\t\t    -1);\n\t} else {\n\t\tif (gtk_tree_model_get_iter_first (model, &iter)) {\n\t\t\tif (gtk_list_store_remove (GTK_LIST_STORE (model), &iter)) {\n\t\t\t\tgtk_list_store_remove (GTK_LIST_STORE (model), &iter);\n\t\t\t}\n\t\t}\n\n\t\tgtk_combo_box_set_row_separator_func (GTK_COMBO_BOX (chooser),\n\t\t\t\t\t\t      (GtkTreeViewRowSeparatorFunc)\n\t\t\t\t\t\t      NULL,\n\t\t\t\t\t\t      NULL,\n\t\t\t\t\t\t      NULL);\n\t}\n\n\tg_object_notify (G_OBJECT (chooser), \"has-all-option\");\n}", "path": "libempathy-gtk\\empathy-account-chooser.c", "repo_name": "zenios/empathy", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6928}
{"docstring": "/*\n * Time of first commit along entire history\n */\n", "func_signal": "static time_t\nrev_commit_first_date (rev_commit *commit)", "code": "{\n    while (commit->parent)\n\tcommit = commit->parent;\n    return commit->date;\n}", "path": "revlist.c", "repo_name": "eatnumber1/parsecvs", "stars": 1, "license": "None", "language": "c", "size": 248}
{"docstring": "/*\n * Generate a list of files in uniq that aren't in common\n */\n", "func_signal": "static rev_file_list *\nrev_uniq_file (rev_commit *uniq, rev_commit *common, int *nuniqp)", "code": "{\n    int\ti, j;\n    int nuniq = 0;\n    rev_file_list   *head = NULL, **tail = &head, *fl;\n    \n    if (!uniq)\n\treturn NULL;\n    for (i = 0; i < uniq->ndirs; i++) {\n\trev_dir\t*dir = uniq->dirs[i];\n\tfor (j = 0; j < dir->nfiles; j++)\n\t    if (!rev_commit_has_file (common, dir->files[j])) {\n\t\tALLOC((fl = calloc (1, sizeof (rev_file_list))), \"rev_uniq_file\");\n\t\tfl->file = dir->files[j];\n\t\t*tail = fl;\n\t\ttail = &fl->next;\n\t\t++nuniq;\n\t    }\n    }\n    *nuniqp = nuniq;\n    return head;\n}", "path": "revlist.c", "repo_name": "eatnumber1/parsecvs", "stars": 1, "license": "None", "language": "c", "size": 248}
{"docstring": "/*\n * Dead file revisions get an extra rev_file object which may be\n * needed during branch merging. Clean those up before returning\n * the resulting rev_list\n */\n", "func_signal": "static void\nrev_list_free_dead_files (rev_list *rl)", "code": "{\n    rev_ref\t*h;\n    rev_commit\t*c;\n\n    for (h = rl->heads; h; h = h->next) {\n\tif (h->tail)\n\t    continue;\n\tfor (c = h->commit; c; c = c->parent) {\n\t    if (c->nfiles == 0) {\n\t\trev_file_free (c->file);\n\t\tc->file = 0;\n\t    }\n\t    if (c->tail)\n\t\tbreak;\n\t}\n    }\n}", "path": "revcvs.c", "repo_name": "eatnumber1/parsecvs", "stars": 1, "license": "None", "language": "c", "size": 248}
{"docstring": "/*\n * Add head refs\n */\n", "func_signal": "rev_ref *\nrev_list_add_head (rev_list *rl, rev_commit *commit, char *name, int degree)", "code": "{\n    rev_ref\t*r;\n    rev_ref\t**list = &rl->heads;\n\n    while (*list)\n\tlist = &(*list)->next;\n    ALLOC((r = calloc (1, sizeof (rev_ref))), \"rev_list_add_head\");\n    r->commit = commit;\n    r->name = name;\n    r->next = *list;\n    r->degree = degree;\n    *list = r;\n    return r;\n}", "path": "revlist.c", "repo_name": "eatnumber1/parsecvs", "stars": 1, "license": "None", "language": "c", "size": 248}
{"docstring": "/*\n * \"Vendor branches\" (1.1.x) are created by importing sources from\n * an external source. In X.org, this was from XFree86 and DRI. When\n * these trees are imported, cvs sets the 'default' branch in each ,v file\n * to point along this branch. This means that tags made between\n * the time the vendor branch is imported and when a new revision\n * is committed to the head branch are placed on the vendor branch\n * In addition, any files without such a commit appear to adopt\n * the vendor branch as 'head'. We fix this by merging these two\n * branches together as if they were the same\n */\n", "func_signal": "static void\nrev_list_patch_vendor_branch (rev_list *rl, cvs_file *cvs)", "code": "{\n    rev_ref\t*trunk = NULL;\n    rev_ref\t*vendor = NULL, **vendor_p = NULL;\n    rev_ref\t*h;\n    rev_commit\t*t, **tp, *v, **vp;\n    rev_commit\t*vlast;\n    rev_commit\t*tc;\n    rev_ref\t**h_p;\n    int\t\tdelete_head;\n\n    trunk = rl->heads;\n    for (h_p = &rl->heads; (h = *h_p);) {\n\tdelete_head = 0;\n\tif (h->commit && cvs_is_vendor (&h->commit->file->number))\n\t{\n\t    /*\n\t     * Find version 1.2 on the trunk.\n\t     * This will reset the default branch set\n\t     * when the initial import was done.\n\t     * Subsequent imports will *not* set the default\n\t     * branch, and should be on their own branch\n\t     */\n\t    vendor = h;\n\t    vendor_p = h_p;\n\t    t = trunk->commit;\n\t    v = vendor->commit;\n\t    for (vlast = vendor->commit; vlast; vlast = vlast->parent)\n\t\tif (!vlast->parent)\n\t\t    break;\n\t    tc = NULL;\n\t    tp = &trunk->commit;\n\t    /*\n\t     * Find the latest trunk revision older than\n\t     * the entire vendor branch\n\t     */\n\t    while ((t = *tp))\n\t    {\n\t\tif (!t->parent || \n\t\t    time_compare (vlast->file->date,\n\t\t\t\t  t->parent->file->date) >= 0)\n\t\t{\n\t\t    break;\n\t\t}\n\t\ttp = &t->parent;\n\t    }\n\t    if (t)\n\t    {\n\t\t/*\n\t\t * If the first commit is older than the last element\n\t\t * of the vendor branch, paste them together and\n\t\t * nuke the vendor branch\n\t\t */\n\t\tif (time_compare (vlast->file->date,\n\t\t\t\t  t->file->date) >= 0)\n\t\t{\n\t\t    delete_head = 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t    /*\n\t\t     * Splice out any portion of the vendor branch\n\t\t     * newer than a the next trunk commit after\n\t\t     * the oldest branch commit.\n\t\t     */\n\t\t    for (vp = &vendor->commit; (v = *vp); vp = &v->parent)\n\t\t\tif (time_compare (v->date, t->date) <= 0)\n\t\t\t    break;\n\t\t    if (vp == &vendor->commit)\n\t\t    {\n\t\t\t/*\n\t\t\t * Nothing newer, nuke vendor branch\n\t\t\t */\n\t\t\tdelete_head = 1;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t/*\n\t\t\t * Some newer stuff, patch parent\n\t\t\t */\n\t\t\t*vp = NULL;\n\t\t    }\n\t\t}\n\t    }\n\t    else\n\t\tdelete_head = 1;\n\t    /*\n\t     * Patch up the remaining vendor branch pieces\n\t     */\n\t    if (!delete_head) {\n\t\trev_commit  *vr;\n\t\tif (!vendor->name) {\n\t\t    char\trev[CVS_MAX_REV_LEN];\n\t\t    char\tname[MAXPATHLEN];\n\t\t    cvs_number\tbranch;\n\n\t\t    branch = vlast->file->number;\n\t\t    branch.c--;\n\t\t    cvs_number_string (&branch, rev);\n\t\t    snprintf (name, sizeof (name),\n\t\t\t      \"import-%s\", rev);\n\t\t    vendor->name = atom (name);\n\t\t    vendor->parent = trunk;\n\t\t    vendor->degree = vlast->file->number.c;\n\t\t}\n\t\tfor (vr = vendor->commit; vr; vr = vr->parent)\n\t\t{\n\t\t    if (!vr->parent) {\n\t\t\tvr->tail = 1;\n\t\t\tvr->parent = v;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    \n\t    /*\n\t     * Merge two branches based on dates\n\t     */\n\t    while (t && v)\n\t    {\n\t\tif (time_compare (v->file->date,\n\t\t\t\t  t->file->date) >= 0)\n\t\t{\n\t\t    *tp = v;\n\t\t    tp = &v->parent;\n\t\t    v = v->parent;\n\t\t}\n\t\telse\n\t\t{\n\t\t    *tp = t;\n\t\t    tp = &t->parent;\n\t\t    t = t->parent;\n\t\t}\n\t    }\n\t    if (t)\n\t\t*tp = t;\n\t    else\n\t\t*tp = v;\n\t}\n\tif (delete_head) {\n\t    *h_p = h->next;\n\t    free (h);\n\t} else {\n\t    h_p = &(h->next);\n\t}\n    }\n#if DEBUG\n    fprintf (stderr, \"%s spliced:\\n\", cvs->name);\n    for (t = trunk->commit; t; t = t->parent) {\n\tdump_number_file (stderr, \"\\t\", &t->file->number);\n\tfprintf (stderr, \"\\n\");\n    }\n#endif\n}", "path": "revcvs.c", "repo_name": "eatnumber1/parsecvs", "stars": 1, "license": "None", "language": "c", "size": 248}
{"docstring": "/*\n * Given a single-file tree, locate the specific version number\n */\n", "func_signal": "static rev_commit *\nrev_find_cvs_commit (rev_list *rl, cvs_number *number)", "code": "{\n    rev_ref\t*h;\n    rev_commit\t*c;\n    rev_file\t*f;\n\n    for (h = rl->heads; h; h = h->next) {\n\tif (h->tail)\n\t    continue;\n\tfor (c = h->commit; c; c = c->parent)\n\t{\n\t     f = c->file;\n\t     if (cvs_number_compare (&f->number, number) == 0)\n\t\t    return c;\n\t     if (c->tail)\n\t\t break;\n\t}\n    }\n    return NULL;\n}", "path": "revcvs.c", "repo_name": "eatnumber1/parsecvs", "stars": 1, "license": "None", "language": "c", "size": 248}
{"docstring": "/* Check if string starts with a keyword followed by a KDELIM or VDELIM */\n", "func_signal": "static enum markers trymatch(char const *string)", "code": "{\n        int j;\n\tchar const *p, *s;\n\tfor (j = sizeof(Keyword)/sizeof(*Keyword);  (--j);  ) {\n\t\tp = Keyword[j];\n\t\ts = string;\n\t\twhile (*p++ == *s++) {\n\t\t\tif (!*p) {\n\t\t\t\tswitch (*s) {\n\t\t\t\tcase KDELIM:\n\t\t\t\tcase VDELIM:\n\t\t\t\t\treturn (enum markers)j;\n\t\t\t\tdefault:\n\t\t\t\t\treturn Nomatch;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        }\n        return(Nomatch);\n}", "path": "rcs2git.c", "repo_name": "eatnumber1/parsecvs", "stars": 1, "license": "None", "language": "c", "size": 248}
{"docstring": "/*\n * Merge a set of per-file branches into a global branch\n */\n", "func_signal": "static void\nrev_branch_merge (rev_ref **branches, int nbranch,\n\t\t  rev_ref *branch, rev_list *rl)", "code": "{\n\tint nlive;\n\tint n;\n\trev_commit *prev = NULL;\n\trev_commit *head = NULL, **tail = &head;\n\trev_commit **commits;\n\trev_commit *commit;\n\trev_commit *latest;\n\trev_commit **p;\n\tint lazy = 0;\n\ttime_t start = 0;\n\n\tALLOC((commits = calloc (nbranch, sizeof (rev_commit *))), \"rev_branch_merge\");\n\tnlive = 0;\n\n//\tprintf(\"rev_branch_merge: nbranch=%d\\n\", nbranch);\n\t\n\tfor (n = 0; n < nbranch; n++) {\n\t\trev_commit *c;\n\t\t/*\n\t\t * Initialize commits to head of each branch\n\t\t */\n\t\tc = commits[n] = branches[n]->commit;\n\t\t/*\n\t\t* Compute number of branches with remaining entries\n\t\t*/\n\t\tif (!c)\n\t\t\tcontinue;\n\t\tif (branches[n]->tail) {\n\t\t\tc->tailed = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tnlive++;\n\t\twhile (c && !c->tail) {\n\t\t\tif (!start || time_compare(c->date, start) < 0)\n\t\t\t    {\n//\t\t\t\tprintf(\"  1:setting start=%ld:%s (from %s)\\n\", start, ctime_nonl(&start), c->file->name);\n\t\t\t\tstart = c->date;\n\t\t\t    }\n\t\t\tc = c->parent;\n\t\t}\n\t\tif (c && (c->file || c->date != c->parent->date)) {\n\t\t\tif (!start || time_compare(c->date, start) < 0) {\n//\t\t\t\tprintf(\"  2:setting start=%ld:%s (from %s)\\n\", start, ctime_nonl(&start), c->file->name);\n\t\t\t\tstart = c->date;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (n = 0; n < nbranch; n++) {\n\t\trev_commit *c = commits[n];\n\n#if 0\n\t\tprintf(\"Doing commit %p: @ %ld\\n\", c, c->date);\n\t\tif (c->file) printf(\"  %s\\n\", c->file->name);\n#endif\n\t\t\n\t\tif (!c->tailed)\n\t\t\tcontinue;\n\t\tif (!start || time_compare(start, c->date) >= 0)\n\t\t\tcontinue;\n\t\tif (c->file) {\n\t\t    /*\n\t\t      This case can occur if files have been added to\n\t\t      a branch since it's creation.\n\t\t    */\n\t\t\tprintf(\t\"Warning: %s too late date %s through branch %s (%ld:%ld=%ld)\\n\",\n\t\t\t\tc->file->name, ctime_nonl(&c->date), branch->name, start, c->date, start-c->date);\n\t\t\tcontinue;\n\t\t}\n\t\tcommits[n] = NULL;\n\t}\n\t/*\n\t * Walk down branches until each one has merged with the\n\t * parent branch\n\t */\n\twhile (nlive > 0 && nbranch > 0) {\n\t\tfor (n = 0, p = commits, latest = NULL; n < nbranch; n++) {\n\t\t\trev_commit *c = commits[n];\n\t\t\tif (!c)\n\t\t\t\tcontinue;\n\t\t\t*p++ = c;\n\t\t\tif (c->tailed)\n\t\t\t\tcontinue;\n\t\t\tif (!latest || time_compare(latest->date, c->date) < 0)\n\t\t\t\tlatest = c;\n\t\t}\n\t\tnbranch = p - commits;\n\n\t\t/*\n\t\t * Construct current commit\n\t\t */\n\t\tif (!lazy) {\n\t\t\tcommit = rev_commit_build (commits, latest, nbranch);\n\t\t\tif (rev_mode == ExecuteGit)\n\t\t\t\tlazy = 1;\n\t\t} else {\n\t\t\tcommit = create_tree(latest);\n\t\t}\n\n\t\t/*\n\t\t * Step each branch\n\t\t */\n\t\tnlive = 0;\n\t\tfor (n = 0; n < nbranch; n++) {\n\t\t\trev_commit *c = commits[n];\n\t\t\trev_commit *to;\n\t\t\t/* already got to parent branch? */\n\t\t\tif (c->tailed)\n\t\t\t\tcontinue;\n\t\t\t/* not affected? */\n\t\t\tif (c != latest && !rev_commit_match(c, latest)) {\n\t\t\t\tif (c->parent || c->file)\n\t\t\t\t\tnlive++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tto = c->parent;\n\t\t\t/* starts here? */\n\t\t\tif (!to)\n\t\t\t\tgoto Kill;\n\n\t\t\tif (c->tail) {\n\t\t\t\t/*\n\t\t\t\t * Adding file independently added on another\n\t\t\t\t * non-trunk branch.\n\t\t\t\t */\n\t\t\t\tif (!to->parent && !to->file)\n\t\t\t\t\tgoto Kill;\n\t\t\t\t/*\n\t\t\t\t * If the parent is at the beginning of trunk\n\t\t\t\t * and it is younger than some events on our\n\t\t\t\t * branch, we have old CVS adding file\n\t\t\t\t * independently\n\t\t\t\t * added on another branch.\n\t\t\t\t */\n\t\t\t\tif (start && time_compare(start, to->date) < 0)\n\t\t\t\t\tgoto Kill;\n\t\t\t\t/*\n\t\t\t\t * XXX: we still can't be sure that it's\n\t\t\t\t * not a file added on trunk after parent\n\t\t\t\t * branch had forked off it but before\n\t\t\t\t * our branch's creation.\n\t\t\t\t */\n\t\t\t\tto->tailed = 1;\n\t\t\t} else if (to->file) {\n\t\t\t\tnlive++;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * See if it's recent CVS adding a file\n\t\t\t\t * independently added on another branch.\n\t\t\t\t */\n\t\t\t\tif (!to->parent)\n\t\t\t\t\tgoto Kill;\n\t\t\t\tif (to->tail && to->date == to->parent->date)\n\t\t\t\t\tgoto Kill;\n\t\t\t\tnlive++;\n\t\t\t}\n\t\t\tif (to->file)\n\t\t\t\tset_commit(to);\n\t\t\telse\n\t\t\t\tdelete_commit(c);\n\t\t\tcommits[n] = to;\n\t\t\tcontinue;\nKill:\n\t\t\tdelete_commit(c);\n\t\t\tcommits[n] = NULL;\n\t\t}\n\n\t\t*tail = commit;\n\t\ttail = &commit->parent;\n\t\tprev = commit;\n\t}\n    /*\n     * Connect to parent branch\n     */\n    nbranch = rev_commit_date_sort (commits, nbranch);\n    if (nbranch && branch->parent )\n    {\n\trev_ref\t*lost;\n\tint\tpresent;\n\n//\tpresent = 0;\n\tfor (present = 0; present < nbranch; present++)\n\t    if (commits[present]->file) {\n\t\t/*\n\t\t * Skip files which appear in the repository after\n\t\t * the first commit along the branch\n\t\t */\n\t\tif (prev && commits[present]->date > prev->date &&\n\t\t    commits[present]->date == rev_commit_first_date (commits[present]))\n\t\t{\n\t\t    fprintf (stderr, \"Warning: file %s appears after branch %s date\\n\",\n\t\t\t     commits[present]->file->name, branch->name);\n\t\t    continue;\n\t\t}\n\t\tbreak;\n\t    }\n\tif (present == nbranch)\n\t    *tail = NULL;\n\telse if ((*tail = rev_commit_locate_one (branch->parent,\n\t\t\t\t\t\t commits[present])))\n\t{\n\t    if (prev && time_compare ((*tail)->date, prev->date) > 0) {\n\t\tfprintf (stderr, \"Warning: branch point %s -> %s later than branch\\n\",\n\t\t\t branch->name, branch->parent->name);\n\t\tfprintf (stderr, \"\\ttrunk(%3d):  %s %s\", n,\n\t\t\t ctime_nonl (&commits[present]->date),\n\t\t\t commits[present]->file ? \" \" : \"D\" );\n\t\tif (commits[present]->file)\n\t\t    dump_number_file (stderr,\n\t\t\t\t      commits[present]->file->name,\n\t\t\t\t      &commits[present]->file->number);\n\t\tfprintf (stderr, \"\\n\");\n\t\tfprintf (stderr, \"\\tbranch(%3d): %s  \", n,\n\t\t\t prev->file?ctime_nonl (&prev->file->date):\"no file\");\n\t\tif (prev->file) {\n\t\t    dump_number_file (stderr,\n\t\t\t\t  prev->file->name,\n\t\t\t\t  &prev->file->number);\n\t\t}\n\t\tfprintf (stderr, \"\\n\");\n\t    }\n\t} else if ((*tail = rev_commit_locate_date (branch->parent,\n\t\t\t\t\t\t  commits[present]->date)))\n\t    fprintf (stderr, \"Warning: branch point %s -> %s matched by date\\n\",\n\t\t     branch->name, branch->parent->name);\n\telse {\n\t    fprintf (stderr, \"Error: branch point %s -> %s not found.\",\n\t\t     branch->name, branch->parent->name);\n\n\t    if ((lost = rev_branch_of_commit (rl, commits[present])))\n\t\tfprintf (stderr, \" Possible match on %s.\", lost->name);\n\t    fprintf (stderr, \"\\n\");\n\t}\n\tif (*tail) {\n\t    if (prev)\n\t\tprev->tail = 1;\n\t} else \n\t    *tail = rev_commit_build (commits, commits[0], nbranch);\n    }\n    for (n = 0; n < nbranch; n++)\n\tif (commits[n])\n\t    commits[n]->tailed = 0;\n    free (commits);\n    branch->commit = head;\n}", "path": "revlist.c", "repo_name": "eatnumber1/parsecvs", "stars": 1, "license": "None", "language": "c", "size": 248}
{"docstring": "/* output the appropriate keyword value(s) */\n", "func_signal": "static void keyreplace(enum markers marker)", "code": "{\n\tconst char *target_lockedby = NULL;\t// Not wired in yet\n\n\tint c;\n\tchar const *xxp;\n\tsize_t cs, cw, ls;\n\tchar *leader = NULL;\n\tchar date_string[25];\n\tuchar *kdelim_ptr = NULL;\n\tenum expand_mode exp = Gexpand;\n\tchar const *sp = Keyword[(int)marker];\n\n\tstrftime(date_string, 25,\n\t\t\"%Y/%m/%d %H:%M:%S\", localtime(&Gversion->date));\n\n\tif (exp != EXPANDKV)\n\t\tout_printf(\"%c%s\", KDELIM, sp);\n\n\tif (exp != EXPANDKK) {\n\t\tif (exp != EXPANDKV)\n\t\t\tout_printf(\"%c%c\", VDELIM, ' ');\n\n\t\tswitch (marker) {\n\t\tcase Author:\n\t\t\tout_fputs(Gversion->author);\n\t\t\tbreak;\n\t\tcase Date:\n\t\t\tout_fputs(date_string);\n\t\t\tbreak;\n\t\tcase Id:\n\t\tcase Header:\n\t\t\tif (marker == Id )\n\t\t\t\tescape_string(basefilename(Gfilename));\n\t\t\telse\tescape_string(getfullRCSname());\n\t\t\tout_printf(\" %s %s %s %s\",\n\t\t\t\tGversion_number, date_string,\n\t\t\t\tGversion->author, Gversion->state);\n\t\t\tif (target_lockedby && exp == EXPANDKKVL)\n\t\t\t\tout_printf(\" %s\", target_lockedby);\n\t\t\tbreak;\n\t\tcase Locker:\n\t\t\tif (target_lockedby && exp == EXPANDKKVL)\n\t\t\t\tout_fputs(target_lockedby);\n\t\t\tbreak;\n\t\tcase Log:\n\t\tcase RCSfile:\n\t\t\tescape_string(basefilename(Gfilename));\n\t\t\tbreak;\n\t\tcase Revision:\n\t\t\tout_fputs(Gversion_number);\n\t\t\tbreak;\n\t\tcase Source:\n\t\t\tescape_string(getfullRCSname());\n\t\t\tbreak;\n\t\tcase State:\n\t\t\tout_fputs(Gversion->state);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (exp != EXPANDKV)\n\t\t\tout_putc(' ');\n\t}\n\n#if 0\n/* Closing delimiter is processed again in expandline */\n\tif (exp != EXPANDKV)\n\t    out_putc(KDELIM);\n#endif\n\n\tif (marker == Log) {\n\t\t/*\n\t\t * \"Closing delimiter is processed again in explandline\"\n\t\t * does not apply here, since we consume the input.\n\t\t */\n\t\tif (exp != EXPANDKV)\n\t\t\tout_putc(KDELIM);\n\n\t\tsp = Glog;\n\t\tls = strlen(Glog);\n\t\tif (sizeof(ciklog)-1<=ls && !memcmp(sp,ciklog,sizeof(ciklog)-1))\n\t\t\treturn;\n\n\t\t/* Back up to the start of the current input line */\n                int num_kdelims = 0;\n\t\tfor (;;) {\n\t\t\tc = in_buffer_ungetc();\n\t\t\tif (c == EOF)\n\t\t\t\tbreak;\n\t\t\tif (c == '\\n') {\n\t\t\t\tin_buffer_getc();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (c == KDELIM) {\n                                num_kdelims++;\n                                /* It is possible to have multiple keywords\n                                   on one line. Make sure we don't backtrack\n                                   into some other keyword! */\n                                if (num_kdelims > 2) {\n                                        in_buffer_getc();\n                                        break;\n                                }\n\t\t\t\tkdelim_ptr = in_buffer_loc();\n                        }\n\t\t}\n\n\t\t/* Copy characters before `$Log' into LEADER.  */\n\t\txxp = leader = xmalloc(kdelim_ptr - in_buffer_loc());\n\t\tfor (cs = 0; ;  cs++) {\n\t\t\tc = in_buffer_getc();\n\t\t\tif (c == KDELIM)\n\t\t\t\tbreak;\n\t\t\tleader[cs] = c;\n\t\t}\n\n\t\t/* Convert traditional C or Pascal leader to ` *'.  */\n\t\tfor (cw = 0;  cw < cs;  cw++)\n\t\t\tif (!latin1_whitespace(xxp[cw]))\n\t\t\t\tbreak;\n\t\tif (cw+1 < cs &&  xxp[cw+1] == '*' &&\n\t\t    (xxp[cw] == '/'  ||  xxp[cw] == '(')) {\n\t\t\tsize_t i = cw+1;\n\t\t\tfor (;;) {\n\t\t\t\tif (++i == cs) {\n\t\t\t\t\tleader[cw] = ' ';\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (!latin1_whitespace(xxp[i]))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* Skip `$Log ... $' string.  */\n\t\tdo {\n\t\t\tc = in_buffer_getc();\n\t\t} while (c != KDELIM);\n\n\t\tout_putc('\\n');\n\t\tout_awrite(xxp, cs);\n\t\tout_printf(\"Revision %s  %s  %s\",\n\t\t\t\tGversion_number,\n\t\t\t\tdate_string,\n\t\t\t\tGversion->author);\n\n\t\t/* Do not include state: it may change and is not updated.  */\n\t\tcw = cs;\n\t\tfor (;  cw && (xxp[cw-1]==' ' || xxp[cw-1]=='\\t');  --cw)\n\t\t\t;\n\t\tfor (;;) {\n\t\t\tout_putc('\\n');\n\t\t\tout_awrite(xxp, cw);\n\t\t\tif (!ls)\n\t\t\t\tbreak;\n\t\t\t--ls;\n\t\t\tc = *sp++;\n\t\t\tif (c != '\\n') {\n\t\t\t\tout_awrite(xxp+cw, cs-cw);\n\t\t\t\tdo {\n\t\t\t\t\tout_putc(c);\n\t\t\t\t\tif (!ls)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t--ls;\n\t\t\t\t\tc = *sp++;\n\t\t\t\t} while (c != '\\n');\n\t\t\t}\n\t\t}\n\t\tfree(leader);\n\t}\n}", "path": "rcs2git.c", "repo_name": "eatnumber1/parsecvs", "stars": 1, "license": "None", "language": "c", "size": 248}
{"docstring": "/*\n * Construct a branch using CVS revision numbers\n */\n", "func_signal": "static rev_commit *\nrev_branch_cvs (cvs_file *cvs, cvs_number *branch)", "code": "{\n    cvs_number\tn;\n    rev_commit\t*head = NULL;\n    rev_commit\t*c, *p;\n    Node\t*node;\n\n    n = *branch;\n    n.n[n.c-1] = -1;\n    for (node = cvs_find_version (cvs, &n); node; node = node->next) {\n\tcvs_version *v = node->v;\n\tcvs_patch *p = node->p;\n\trev_commit *c;\n\tif (!v)\n\t     continue;\n\tALLOC((c = calloc (1, sizeof (rev_commit))), \"rev_branch_cvs\");\n\tc->date = v->date;\n\tc->commitid = v->commitid;\n\tc->author = v->author;\n\tif (p)\n\t    c->log = p->log;\n\tif (v->dead)\n\t    c->nfiles = 0;\n\telse\n\t    c->nfiles = 1;\n\t/* leave this around so the branch merging stuff can find numbers */\n\tc->file = rev_file_rev (cvs->name, &v->number, v->date);\n\tif (!v->dead) {\n\t    node->file = c->file;\n\t    c->file->mode = cvs->mode;\n\t}\n\tc->parent = head;\n\thead = c;\n    }\n    /*\n     * Make sure the dates along the branch are well ordered. As we\n     * want to preserve current data, push previous versions back to\n     * align with newer revisions.\n     */\n    for (c = head; (p = c->parent); c = p) {\n\tif (time_compare (p->file->date, c->file->date) > 0)\n\t{\n\t    fprintf (stderr, \"Warning: %s:\", cvs->name);\n\t    dump_number_file (stderr, \" \", &p->file->number);\n\t    dump_number_file (stderr, \" is newer than\", &c->file->number);\n\t    fprintf (stderr, \", adjusting\\n\");\n\t    p->file->date = c->file->date;\n\t}\n    }\n    return head;\n}", "path": "revcvs.c", "repo_name": "eatnumber1/parsecvs", "stars": 1, "license": "None", "language": "c", "size": 248}
{"docstring": "/*\n * Given a disconnected set of branches, graft the bottom\n * of each branch where it belongs on the parent branch\n */\n", "func_signal": "static void\nrev_list_graft_branches (rev_list *rl, cvs_file *cvs)", "code": "{\n    rev_ref\t*h;\n    rev_commit\t*c;\n    cvs_version\t*cv;\n    cvs_branch\t*cb;\n\n    /*\n     * Glue branches together\n     */\n    for (h = rl->heads; h; h = h->next) {\n\t/*\n\t * skip master branch; it \"can't\" join\n\t * any other branches and it may well end with a vendor\n\t * branch revision of the file, which will then create\n\t * a loop back to the recorded branch point\n\t */\n        if (h == rl->heads)\n\t    continue;\n\tif (h->tail)\n\t    continue;\n\t/*\n\t * Find last commit on branch\n\t */\n\tfor (c = h->commit; c && c->parent; c = c->parent)\n\t    if (c->tail) {\n\t\tc = NULL;\t/* already been done, skip */\n\t\tbreak;\n\t    }\n\tif (c) {\n\t    /*\n\t     * Walk the version tree, looking for the branch location.\n\t     * Note that in the presense of vendor branches, the\n\t     * branch location may actually be out on that vendor branch\n\t     */\n\t    for (cv = cvs->versions; cv; cv = cv->next) {\n\t\tfor (cb = cv->branches; cb; cb = cb->next) {\n\t\t    if (cvs_number_compare (&cb->number,\n\t\t\t\t\t    &c->file->number) == 0)\n\t\t    {\n\t\t\tc->parent = rev_find_cvs_commit (rl, &cv->number);\n\t\t\tc->tail = 1;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tif (c->parent)\n\t\t{\n#if 0\n\t\t    /*\n\t\t     * check for a parallel vendor branch\n\t\t     */\n\t\t    for (cb = cv->branches; cb; cb = cb->next) {\n\t\t\tif (cvs_is_vendor (&cb->number)) {\n\t\t\t    cvs_number\tv_n;\n\t\t\t    rev_commit\t*v_c, *n_v_c;\n\t\t\t    fprintf (stderr, \"Found merge into vendor branch\\n\");\n\t\t\t    v_n = cb->number;\n\t\t\t    v_c = NULL;\n\t\t\t    /*\n\t\t\t     * Walk to head of vendor branch\n\t\t\t     */\n\t\t\t    while ((n_v_c = rev_find_cvs_commit (rl, &v_n)))\n\t\t\t    {\n\t\t\t\t/*\n\t\t\t\t * Stop if we reach a date after the\n\t\t\t\t * branch version date\n\t\t\t\t */\n\t\t\t\tif (time_compare (n_v_c->date, c->date) > 0)\n\t\t\t\t    break;\n\t\t\t\tv_c = n_v_c;\n\t\t\t\tv_n.n[v_n.c - 1]++;\n\t\t\t    }\n\t\t\t    if (v_c)\n\t\t\t    {\n\t\t\t\tfprintf (stderr, \"%s: rewrite branch\", cvs->name);\n\t\t\t\tdump_number_file (stderr, \" branch point\",\n\t\t\t\t\t\t  &v_c->file->number);\n\t\t\t\tdump_number_file (stderr, \" branch version\",\n\t\t\t\t\t\t  &c->file->number);\n\t\t\t\tfprintf (stderr, \"\\n\");\n\t\t\t\tc->parent = v_c;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n#endif\n\t\t    break;\n\t\t}\n\t    }\n\t}\n    }\n}", "path": "revcvs.c", "repo_name": "eatnumber1/parsecvs", "stars": 1, "license": "None", "language": "c", "size": 248}
{"docstring": "/*\n * Locate position in tree cooresponding to specific tag\n */\n", "func_signal": "static void\nrev_tag_search(Tag *tag, rev_commit **commits, rev_list *rl)", "code": "{\n\trev_commit_date_sort(commits, tag->count);\n\ttag->parent = rev_branch_of_commit(rl, commits[0]);\n\tif (tag->parent)\n\t\ttag->commit = rev_commit_locate (tag->parent, commits[0]);\n\tif (!tag->commit) {\n\t\tfprintf (stderr, \"unmatched tag %s\\n\", tag->name);\n\t\t/* AV: shouldn't we put it on some branch? */\n\t\ttag->commit = rev_commit_build(commits, commits[0], tag->count);\n\t}\n\ttag->commit->tagged = 1;\n}", "path": "revlist.c", "repo_name": "eatnumber1/parsecvs", "stars": 1, "license": "None", "language": "c", "size": 248}
{"docstring": "/*\n * Commits further than 60 minutes apart are assume to be different\n */\n", "func_signal": "static int\ncommit_time_close (time_t a, time_t b)", "code": "{\n    long\tdiff = a - b;\n    if (diff < 0) diff = -diff;\n    if (diff < commit_time_window * 60)\n\treturn 1;\n    return 0;\n}", "path": "revlist.c", "repo_name": "eatnumber1/parsecvs", "stars": 1, "license": "None", "language": "c", "size": 248}
{"docstring": "/* Before line N, insert line L.  N is 0-origin.  */\n", "func_signal": "static void insertline(unsigned long n, uchar * l)", "code": "{\n\tif (n > Glinemax - Ggapsize)\n\t\tfatal_error(\"edit script tried to insert beyond eof\");\n\tif (!Ggapsize) {\n\t\tif (Glinemax) {\n\t\t\tGgap = Ggapsize = Glinemax; Glinemax <<= 1;\n\t\t\tGline = xrealloc(Gline, sizeof(uchar *) * Glinemax);\n\t\t} else {\n\t\t\tGlinemax = Ggapsize = 1024;\n\t\t\tGline = xmalloc(sizeof(uchar *) *  Glinemax);\n\t\t}\n\t}\n\tif (n < Ggap)\n\t\tmemmove(Gline+n+Ggapsize, Gline+n, (Ggap-n) * sizeof(uchar *));\n\telse if (Ggap < n)\n\t\tmemmove(Gline+Ggap, Gline+Ggap+Ggapsize, (n-Ggap) * sizeof(uchar *));\n\tGline[n] = l;\n\tGgap = n + 1;\n\tGgapsize--;\n}", "path": "rcs2git.c", "repo_name": "eatnumber1/parsecvs", "stars": 1, "license": "None", "language": "c", "size": 248}
{"docstring": "/*\n * For each symbol, locate the appropriate commit\n */\n", "func_signal": "static rev_ref *\nrev_list_find_branch (rev_list *rl, cvs_number *number)", "code": "{\n    cvs_number\tn;\n    rev_ref\t*h;\n\n    if (number->c < 2)\n\treturn NULL;\n    n = *number;\n    h = NULL;\n    while (n.c >= 2)\n    {\n\tfor (h = rl->heads; h; h = h->next) {\n\t    if (cvs_same_branch (&h->number, &n)) {\n\t\tbreak;\n\t    }\n\t}\n\tif (h)\n\t    break;\n\tn.c -= 2;\n    }\n    return h;\n}", "path": "revcvs.c", "repo_name": "eatnumber1/parsecvs", "stars": 1, "license": "None", "language": "c", "size": 248}
{"docstring": "/* Convert relative RCS filename to absolute path */\n", "func_signal": "static char const * getfullRCSname(void)", "code": "{\n\tchar *wdbuf = NULL;\n\tint wdbuflen = 0;\n\n\tsize_t dlen;\n\n\tchar const *r;\n\tchar* d;\n\n\tif (Gfilename[0] == '/')\n\t\treturn Gfilename;\n\n\t/* If we've already calculated the absolute path, return it */\n\tif (Gabspath)\n\t\treturn Gabspath;\n\n\t/* Get working directory and strip any trailing slashes */\n\twdbuflen = _POSIX_PATH_MAX + 1;\n\twdbuf = xmalloc(wdbuflen);\n\twhile (!getcwd(wdbuf, wdbuflen)) {\n\t\tif (errno == ERANGE)\n\t\t\txrealloc(wdbuf, wdbuflen<<1);\n\t\telse\tfatal_system_error(\"getcwd\");\n\t}\n\n\t/* Trim off trailing slashes */\n\tdlen = strlen(wdbuf);\n\twhile (dlen && wdbuf[dlen-1] == '/')\n\t\t--dlen;\n\twdbuf[dlen] = 0;\n\n\t/* Ignore leading `./'s in Gfilename. */\n\tfor (r = Gfilename;  r[0]=='.' && r[1] == '/';  r += 2)\n\t\twhile (r[2] == '/')\n\t\t\tr++;\n\n\t/* Build full pathname.  */\n\tGabspath = d = xmalloc(dlen + strlen(r) + 2);\n\tmemcpy(d, wdbuf, dlen);\n\td += dlen;\n\t*d++ = '/';\n\tstrcpy(d, r);\n\tfree(wdbuf);\n\n\treturn Gabspath;\n}", "path": "rcs2git.c", "repo_name": "eatnumber1/parsecvs", "stars": 1, "license": "None", "language": "c", "size": 248}
{"docstring": "/* backup one position in the input buffer, unless at start of buffer\n *   return character at new position, or EOF if we could not back up\n */\n", "func_signal": "static int in_buffer_ungetc(void)", "code": "{\n\tint c;\n\tif (Ginbuf->read_count == 0)\n\t\treturn EOF;\n\t--Ginbuf->read_count;\n\t--Ginbuf->ptr;\n\tc = *Ginbuf->ptr;\n\tif (c == SDELIM) {\n\t\t--Ginbuf->ptr;\n\t\tc = *Ginbuf->ptr;\n\t}\n\treturn c;\n}", "path": "rcs2git.c", "repo_name": "eatnumber1/parsecvs", "stars": 1, "license": "None", "language": "c", "size": 248}
{"docstring": "/* Delete lines N through N+NLINES-1.  N is 0-origin.  */\n", "func_signal": "static void deletelines(unsigned long n, unsigned long nlines)", "code": "{\n\tunsigned long l = n + nlines;\n\tif (Glinemax-Ggapsize < l  ||  l < n)\n\t\tfatal_error(\"edit script tried to delete beyond eof\");\n\tif (l < Ggap)\n\t\tmemmove(Gline+l+Ggapsize, Gline+l, (Ggap-l) * sizeof(uchar *));\n\telse if (Ggap < n)\n\t\tmemmove(Gline+Ggap, Gline+Ggap+Ggapsize, (n-Ggap) * sizeof(uchar *));\n\tGgap = n;\n\tGgapsize += nlines;\n}", "path": "rcs2git.c", "repo_name": "eatnumber1/parsecvs", "stars": 1, "license": "None", "language": "c", "size": 248}
{"docstring": "/*\n * We keep all file lists in a canonical sorted order,\n * first by latest date and then by the address of the rev_file object\n * (which are always unique)\n */\n", "func_signal": "int\nrev_file_later (rev_file *af, rev_file *bf)", "code": "{\n    long\tt;\n\n    /*\n     * When merging file lists, we should never see the same\n     * object in both trees\n     */\n    assert (af != bf);\n\n    t = time_compare (af->date, bf->date);\n\n    if (t > 0)\n\treturn 1;\n    if (t < 0)\n\treturn 0;\n    if ((uintptr_t) af > (uintptr_t) bf)\n\treturn 1;\n    return 0;\n}", "path": "revlist.c", "repo_name": "eatnumber1/parsecvs", "stars": 1, "license": "None", "language": "c", "size": 248}
{"docstring": "/*\n  Debug code, dump the contents of a branch for a given file\n*/\n", "func_signal": "static void dump_cvs_number(cvs_number *number)", "code": "{\n    int i;\n    if (number) {\n\tfor (i=0; i<number->c; i++) {\n\t    printf(\"%d\", number->n[i]);\n\t    if (i < number->c - 1) printf (\".\");\n\t}\n    }\n}", "path": "revcvs.c", "repo_name": "eatnumber1/parsecvs", "stars": 1, "license": "None", "language": "c", "size": 248}
{"docstring": "/*\n * The display callback\n */\n", "func_signal": "void display(void)", "code": "{\n   glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n\t// ta-da!\n\tglMatrixMode(GL_MODELVIEW);\n   glLoadIdentity();\n\tgluLookAt(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ); \n\n\t//The Sun\n\tglPushMatrix();\n\tglColor3f(1.0, 1.0, 0.0);\n\tglScalef(0.1, 0.1, 0.1);\n\tglRotatef(rotation, 0.0, 1.0, 0.0);\n   glDisable(GL_LIGHTING);\n\tglutSolidSphere((GLdouble) 2.0, (GLint)20, (GLint)20);\n\tglPopMatrix();\n   glEnable(GL_LIGHT1);\n\n\t// Display the planets\n\tmercury();\n\tvenus();\n\tearth();\n\tmars();\n\tjupiter();\n\tsaturn();\n\turanus();\n\tneptune();\n\n\n   glFlush ();\n   // Never forget to swap buffers when GL_DOUBLE\n   // is on\n   glutSwapBuffers();\n}", "path": "6\\solar.c", "repo_name": "Yasumoto/computergraphics2009", "stars": 1, "license": "None", "language": "c", "size": 2384}
{"docstring": "/*\n * The menu to view different angles\n */\n", "func_signal": "void menu(GLint selected)", "code": "{\n\tswitch(selected)\n\t{\n\t\t\t  //Above\n\t\t\t  case 1:\n\t\t\t  {\n\t\t\t\t\teyeX = 0.0;\n\t\t\t\t\teyeY = 35.0;\n\t\t\t\t\teyeZ = 200.0;\n\t\t\t\t\tbreak;\n\t\t\t  }\n\t\t\t  //Below\n\t\t\t  case 2:\n\t\t\t  {\n\t\t\t\t\teyeX = 0.0;\n\t\t\t\t\teyeY = 35.0;\n\t\t\t\t\teyeZ = -200.0;\n\t\t\t\t\tbreak;\n\t\t\t  }\n\t\t\t  //Side\n\t\t\t  case 3:\n\t\t\t  {\n\t\t\t\t\teyeX = 120.0;\n\t\t\t\t\teyeY = 0.0;\n\t\t\t\t\teyeZ = 0.0;\n\t\t\t\t\tbreak;\n\t\t\t  }\n\t\t\t  //Up\n\t\t\t  case 4:\n\t\t\t  {    \n\t\t\t\t\teyeY += 150.0;\n\t\t\t\t\tbreak;\n\t\t\t  }\n\t\t\t  //Down\n\t\t\t  case 5:\n\t\t\t  {    \n\t\t\t\t\teyeY -= 150.0;\n\t\t\t\t\tbreak;\n\t\t\t  }\n\t\t\t  // Cool Moves\n\t\t\t  // (missile tracking)\n\t\t\t  case 6:\n\t\t\t  {\n\t\t\t\t  cool_moves *= -1;\n\t\t\t\t  break;\n\t\t\t  }\n\t\t\t  //Reset\n\t\t\t  case 7:\n\t\t\t  {\n\t\t\t\t\teyeX = -50.0;\n\t\t\t\t\teyeY = 20.0;\n\t\t\t\t\teyeZ = 0.0;   \n\t\t\t\t\tx_move = 0.0;\n\t\t\t\t\tz_move = 0.0;\n\t\t\t\t\tbreak;\n\t\t\t  }\n\t}\n}", "path": "final\\init.c", "repo_name": "Yasumoto/computergraphics2009", "stars": 1, "license": "None", "language": "c", "size": 2384}
{"docstring": "/*\n * Update the rotation of the planets,\n * then calculate orbits, and redisplay\n */\n", "func_signal": "void idle()", "code": "{\n\trotation += 0.01;\n\torbits();\n\tdisplay();\n}", "path": "6\\solar.c", "repo_name": "Yasumoto/computergraphics2009", "stars": 1, "license": "None", "language": "c", "size": 2384}
{"docstring": "/*\n * The menu to view different angles\n */\n", "func_signal": "void menu(GLint selected)", "code": "{\n\tswitch(selected)\n\t{\n\t\t\t  //Above\n\t\t\t  case 1:\n\t\t\t  {\n\t\t\t\t\teyeX = 0.0;\n\t\t\t\t\teyeY = 0.0;\n\t\t\t\t\teyeZ = 25.0;\n\t\t\t\t\tbreak;\n\t\t\t  }\n\t\t\t  //Below\n\t\t\t  case 2:\n\t\t\t  {\n\t\t\t\t\teyeX = 0.0;\n\t\t\t\t\teyeY = 0.0;\n\t\t\t\t\teyeZ = -25.0;\n\t\t\t\t\tbreak;\n\t\t\t  }\n\t\t\t  //Side\n\t\t\t  case 3:\n\t\t\t  {\n\t\t\t\t\teyeX = 20.0;\n\t\t\t\t\teyeY = 0.0;\n\t\t\t\t\teyeZ = 0.0;\n\t\t\t\t\tbreak;\n\t\t\t  }\n\t\t\t  //Zoom\n\t\t\t  case 4:\n\t\t\t  {    \n\t\t\t\t\teyeY -= 10.0;\n\t\t\t\t\tbreak;\n\t\t\t  }\n\t\t\t  //Reset\n\t\t\t  case 5:\n\t\t\t  {\n\t\t\t\t\teyeX = 0.0;\n\t\t\t\t\teyeY = 20.0;\n\t\t\t\t\teyeZ = 5.0;   \n\t\t\t\t\tbreak;\n\t\t\t  }\n\t}\n}", "path": "6\\solar.c", "repo_name": "Yasumoto/computergraphics2009", "stars": 1, "license": "None", "language": "c", "size": 2384}
{"docstring": "/*\n * Crazy skybox code I found \n * online (not really that crazy, just a bunch of quads);\n */\n", "func_signal": "void skyworld()", "code": "{\n\tglPushMatrix();\n   glDisable(GL_LIGHTING);\n\tglScalef(1000.0, 1000.0, 1000.0);\n\tglColor3f(1.0, 1.0, 1.0);\n\tglBindTexture(GL_TEXTURE_2D, skybox[4]);\n   glBegin(GL_QUADS);\t\t                // begin drawing a cube\n   \n   // Front Face (note that the texture's corners have to match the quad's corners)\n   glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.0f, -1.0f,  1.0f);\t// Bottom Left Of The Texture and Quad\n   glTexCoord2f(1.0f, 0.0f); glVertex3f( 1.0f, -1.0f,  1.0f);\t// Bottom Right Of The Texture and Quad\n   glTexCoord2f(1.0f, 1.0f); glVertex3f( 1.0f,  1.0f,  1.0f);\t// Top Right Of The Texture and Quad\n   glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.0f,  1.0f,  1.0f);\t// Top Left Of The Texture and Quad\n   glEnd();                                    // done with the polygon.\n   \n\tglBindTexture(GL_TEXTURE_2D, skybox[0]);\n   glBegin(GL_QUADS);\t\t                // begin drawing a cube\n   // Back Face\n   glTexCoord2f(1.0f, 0.0f); glVertex3f(-1.0f, -1.0f, -1.0f);\t// Bottom Right Of The Texture and Quad\n   glTexCoord2f(1.0f, 1.0f); glVertex3f(-1.0f,  1.0f, -1.0f);\t// Top Right Of The Texture and Quad\n   glTexCoord2f(0.0f, 1.0f); glVertex3f( 1.0f,  1.0f, -1.0f);\t// Top Left Of The Texture and Quad\n   glTexCoord2f(0.0f, 0.0f); glVertex3f( 1.0f, -1.0f, -1.0f);\t// Bottom Left Of The Texture and Quad\n   glEnd();                                    // done with the polygon.\n\t\n\tglBindTexture(GL_TEXTURE_2D, skybox[5]);\n   glBegin(GL_QUADS);\t\t                // begin drawing a cube\n   // Top Face\n   glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.0f,  1.0f, -1.0f);\t// Top Left Of The Texture and Quad\n   glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.0f,  1.0f,  1.0f);\t// Bottom Left Of The Texture and Quad\n   glTexCoord2f(1.0f, 0.0f); glVertex3f( 1.0f,  1.0f,  1.0f);\t// Bottom Right Of The Texture and Quad\n   glTexCoord2f(1.0f, 1.0f); glVertex3f( 1.0f,  1.0f, -1.0f);\t// Top Right Of The Texture and Quad\n   glEnd();                                    // done with the polygon.\n   \n\tglBindTexture(GL_TEXTURE_2D, skybox[1]);\n   glBegin(GL_QUADS);\t\t                // begin drawing a cube\n   // Bottom Face       \n   glTexCoord2f(1.0f, 1.0f); glVertex3f(-1.0f, -1.0f, -1.0f);\t// Top Right Of The Texture and Quad\n   glTexCoord2f(0.0f, 1.0f); glVertex3f( 1.0f, -1.0f, -1.0f);\t// Top Left Of The Texture and Quad\n   glTexCoord2f(0.0f, 0.0f); glVertex3f( 1.0f, -1.0f,  1.0f);\t// Bottom Left Of The Texture and Quad\n   glTexCoord2f(1.0f, 0.0f); glVertex3f(-1.0f, -1.0f,  1.0f);\t// Bottom Right Of The Texture and Quad\n   glEnd();                                    // done with the polygon.\n   \n\tglBindTexture(GL_TEXTURE_2D, skybox[3]);\n   glBegin(GL_QUADS);\t\t                // begin drawing a cube\n   // Right face\n   glTexCoord2f(1.0f, 0.0f); glVertex3f( 1.0f, -1.0f, -1.0f);\t// Bottom Right Of The Texture and Quad\n   glTexCoord2f(1.0f, 1.0f); glVertex3f( 1.0f,  1.0f, -1.0f);\t// Top Right Of The Texture and Quad\n   glTexCoord2f(0.0f, 1.0f); glVertex3f( 1.0f,  1.0f,  1.0f);\t// Top Left Of The Texture and Quad\n   glTexCoord2f(0.0f, 0.0f); glVertex3f( 1.0f, -1.0f,  1.0f);\t// Bottom Left Of The Texture and Quad\n   glEnd();                                    // done with the polygon.\n   \n\tglBindTexture(GL_TEXTURE_2D, skybox[2]);\n   glBegin(GL_QUADS);\t\t                // begin drawing a cube\n   // Left Face\n   glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.0f, -1.0f, -1.0f);\t// Bottom Left Of The Texture and Quad\n   glTexCoord2f(1.0f, 0.0f); glVertex3f(-1.0f, -1.0f,  1.0f);\t// Bottom Right Of The Texture and Quad\n   glTexCoord2f(1.0f, 1.0f); glVertex3f(-1.0f,  1.0f,  1.0f);\t// Top Right Of The Texture and Quad\n   glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.0f,  1.0f, -1.0f);\t// Top Left Of The Texture and Quad\n   \n   glEnd();                                    // done with the polygon.\n   glEnable(GL_LIGHTING);\n\tglPopMatrix();\n}", "path": "final\\init.c", "repo_name": "Yasumoto/computergraphics2009", "stars": 1, "license": "None", "language": "c", "size": 2384}
{"docstring": "/*  Initialize material property, light source, lighting model,\n *  and depth buffer.\n */\n", "func_signal": "void init(void)", "code": "{\n   // Change the light color to white\n   GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 };\n   GLfloat mat_shininess[] = { 50.0 };\n\n\t// The position of the light\n\tGLfloat light_position[] = { 1.0, 1.0, 1.0, 0.0 };\n\n   glClearColor (0.0, 0.0, 0.0, 0.0);\n   glShadeModel (GL_SMOOTH);\n\t\n   glEnable(GL_COLOR_MATERIAL);\n\n   // Specifies material info for lighting\n   // Changed to diffuse lighting\n   glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_specular);\n   glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);\n\t\n   // update the lighting\n   glLightfv(GL_LIGHT0, GL_POSITION, light_position);\n\n\n   // Turn on GL settings\n   glEnable(GL_LIGHTING);\n   glEnable(GL_LIGHT0);\n   glEnable(GL_DEPTH_TEST);\n}", "path": "5\\JoeSmith5.c", "repo_name": "Yasumoto/computergraphics2009", "stars": 1, "license": "None", "language": "c", "size": 2384}
{"docstring": "/*\n * the reshape callback function\n * set up the view window\n */\n", "func_signal": "void reshape (int w, int h)", "code": "{\n   glViewport (0, 0, (GLsizei) w, (GLsizei) h);\n   glMatrixMode (GL_PROJECTION);\n   glLoadIdentity();\n\tgluPerspective (45.0, (GLfloat)w/(GLfloat)h, 0.1, 200.0 ); \n   glMatrixMode(GL_MODELVIEW);\n}", "path": "6\\solar.c", "repo_name": "Yasumoto/computergraphics2009", "stars": 1, "license": "None", "language": "c", "size": 2384}
{"docstring": "/*  Initialize material property, light source, lighting model,\n *  and depth buffer.\n */\n", "func_signal": "void init(void)", "code": "{\n    LoadGLTextures();// Load The Texture(s) \n    glEnable(GL_TEXTURE_2D);// Enable Texture Mapping\n   // Change the light color to white\n   GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 };\n   GLfloat mat_shininess[] = { 50.0 };\n\n\t// The position of the light\n\tGLfloat light_position[] = { 5.0, 5.0, 5.0, 0.0 };\n\n   glClearColor (1.0, 1.0, 1.0, 1.0);\n   glShadeModel (GL_SMOOTH);\n\t\n   glEnable(GL_COLOR_MATERIAL);\n\n   // Specifies material info for lighting\n   // Changed to diffuse lighting\n   glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_specular);\n   glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);\n\t\n   // update the lighting\n   glLightfv(GL_LIGHT0, GL_POSITION, light_position);\n\n\n   // Turn on GL settings\n   glEnable(GL_LIGHTING);\n   glEnable(GL_LIGHT0);\n   glEnable(GL_DEPTH_TEST);\n\n\t// For more info on blending, see 231 in\n\t// the redbook\n\tglEnable(GL_BLEND);\n\tglBlendFunc(GL_ONE, GL_ONE);\n   //glDisable(GL_LIGHTING);\n}", "path": "final\\init.c", "repo_name": "Yasumoto/computergraphics2009", "stars": 1, "license": "None", "language": "c", "size": 2384}
{"docstring": "/*\n * Very simple\n */\n", "func_signal": "void fin(float* v1, float* v2, float* v3)", "code": "{\n\tglBegin(GL_TRIANGLES);\n\t\tglVertex3fv(v1);\n\t\tglVertex3fv(v2);\n\t\tglVertex3fv(v3);\n\tglEnd();\n}", "path": "final\\missile.c", "repo_name": "Yasumoto/computergraphics2009", "stars": 1, "license": "None", "language": "c", "size": 2384}
{"docstring": "/*\n * Set up q to quit, for convenience\n */\n", "func_signal": "void keys(unsigned char key, int x, int y)", "code": "{\n\tswitch (key) {\n\t\tcase 'q':\n\t\t{\n\t\t\texit(0);\n\t\t\tbreak;\n\t\t} \n\t\tcase 'k':\n\t\t{\n\t\t\t//glTranslatef(15.0, -5.0, 0.0);\n\t\t\t//glScalef(0.2, 0.2, 0.2);\n\t\t\t// Bombs away!\n\t\t\tdisplay_missile = 1;\n\t\t\tbreak;\n\t\t} \n\t\t// These rotate the jet\n\t\tcase GLUT_KEY_UP:\n\t\t{\n\t\t\tz_move += 2.1;\n\t\t\tbreak;\n\t\t}\n\t\tcase GLUT_KEY_DOWN:\n\t\t{\n\t\t\tz_move -= 2.1;\n\t\t\tbreak;\n\t\t}\n\t\tcase GLUT_KEY_LEFT:\n\t\t{\n\t\t\tx_move -= 2.1;\n\t\t\tbreak;\n\t\t}\n\t\tcase GLUT_KEY_RIGHT:\n\t\t{\n\t\t\tx_move += 2.1;\n\t\t\tbreak;\n\t\t}\n\t}\n}", "path": "final\\init.c", "repo_name": "Yasumoto/computergraphics2009", "stars": 1, "license": "None", "language": "c", "size": 2384}
{"docstring": "/*\n * The display callback\n */\n", "func_signal": "void display(void)", "code": "{\n   glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n   glLoadIdentity();\n\n\t// ta-da!\n\tglMatrixMode(GL_MODELVIEW);\n\tgluLookAt(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ); \n\n\t// Draw the sky box first, since everythiny \n\t// else should be drawn on top of it\n\tskyworld();\n\n\t// Missile Tracking enabled\n\tif (cool_moves > 0)\n\t\tglPushMatrix();\n\t//y_move += 0.1;\n\t//x_move += 0.1;\n        glRotatef(x_move, 1.0, 0.0, 0.0);\n        glRotatef(z_move, 0.0, 0.0, 1.0);\n\n\tjet();\n\tglPopMatrix();\n\n\tif (cool_moves > 0)\n\t\tglPopMatrix();\n\t\t\n\tif (!display_missile && eyeX == -50.0 && eyeY == 20.0)\n\t\tshow_ready();\n\t//glTranslatef(10.0, -5.0, 0.0);\n\tglScalef(0.3, 0.3, 0.3);\n\t// To animate the explosion\n\tif (explode_awesomeness)\n\t{\n\t\texplosion(explode_x, explode_awesomeness--);\n\t}\n\n\t// Missile has been launched\n\tif (display_missile)\n\t{\n\t\tglTranslatef(missile_distance+=0.3, 0.0, side*25.0);\n\t\tmissile();\n\t\t// TIme to explode\n\t\tif (missile_distance >= 700.0)\n\t\t{\n\t\t\t// Explode where missile was launched\n\t\t\texplode_x = missile_distance;\n\t\t\texplode_awesomeness = 500;\n\t\t\tmissile_distance = 3.0;\n\t\t\tdisplay_missile = 0;\n\t\t\t// Switch to launch missile on other side of the jet\n\t\t\tside *= -1.0;\n\t\t}\n\t}\n\n   glFlush ();\n   // Never forget to swap buffers when GL_DOUBLE\n   // is on\n   glutSwapBuffers();\n}", "path": "final\\init.c", "repo_name": "Yasumoto/computergraphics2009", "stars": 1, "license": "None", "language": "c", "size": 2384}
{"docstring": "/*\n * Model the fins\n */\n", "func_signal": "void fins()", "code": "{\n\tglPushMatrix();\n\tglTranslatef(-10.0, 0.0, 0.0);\n\tglRotatef(45, 0.0, 1.0, 0.0);\n\n\tfloat v1[3] = {0.0, 0.0, 0.0};\n  \tfloat v2[3] = {0.0, 5.0, 0.0};\n\tfloat v3[3] = {1.0, 0.0, 1.0};  \n\n\tfloat v4[3] = {0.0, 0.0, 0.0};\n  \tfloat v5[3] = {0.0, -5.0, 0.0};\n\tfloat v6[3] = {1.0, 0.0, 1.0};  \n\n\tfloat v7[3] = {0.0, 0.0, 0.0};\n  \tfloat v8[3] = {0.0, 0.0, 5.0};\n\tfloat v9[3] = {1.0, 0.0, 1.0};  \n\n\tfloat va[3] = {0.0, 0.0, 0.0};\n  \tfloat vb[3] = {0.0, 0.0, -5.0};\n\tfloat vc[3] = {1.0, 0.0, 1.0};  \n\n\tfin(v1, v2, v3);\n\tfin(v4, v5, v6);\n\tfin(v7, v8, v9);\n\tfin(va, vb, vc);\n\tglPopMatrix();\n}", "path": "final\\missile.c", "repo_name": "Yasumoto/computergraphics2009", "stars": 1, "license": "None", "language": "c", "size": 2384}
{"docstring": "/*\n * Function to actually write a string to screen\n */\n", "func_signal": "void write_stroke(char* write)", "code": "{\n\twhile (*write)\n\t\tglutStrokeCharacter(GLUT_STROKE_MONO_ROMAN, *write++);\n}", "path": "final\\init.c", "repo_name": "Yasumoto/computergraphics2009", "stars": 1, "license": "None", "language": "c", "size": 2384}
{"docstring": "/*\n * Idle function\n */\n", "func_signal": "void idle()", "code": "{\n\t// The kookity camera swing code\n\t/*if (orbit_x < 360.0)\n\t\torbit_x += 0.001;\n\telse\n\t\torbit_x = 0.0;\n\t\n\tif (orbit_y < 360.0)\n\t\torbit_y += 0.001;\n\telse\n\t\torbit_y = 0.0;\n\t\t\n\teyeX = 50.0*cos((float)orbit_x);\n\teyeY = 50.0*sin((float)orbit_y);\n\t*/\n\n\tif (flame >= 1.7)\n\t\t\t  flame = 1.0;\n\telse\n\t\t\t  flame += 0.01;\n\tdisplay();\n}", "path": "final\\init.c", "repo_name": "Yasumoto/computergraphics2009", "stars": 1, "license": "None", "language": "c", "size": 2384}
{"docstring": "/*\n * Fire a missile when left mouse button is clicked\n */\n", "func_signal": "void clicks(int button, int state, int x, int y)", "code": "{\n\t\t  if(button == GLUT_LEFT_BUTTON)\n\t\t\t\t\t display_missile = 1;\n}", "path": "final\\init.c", "repo_name": "Yasumoto/computergraphics2009", "stars": 1, "license": "None", "language": "c", "size": 2384}
{"docstring": "/*\n * What follows are the planet functions\n */\n", "func_signal": "void mercury()", "code": "{\n\tglPushMatrix();\n\tglColor3f(1.0, 1.0, 1.0);\n\tglScalef(MERCURY_SIZE);\n\tglTranslatef(EARTH_DISTANCE*cos((float)mercury_orbit), EARTH_DISTANCE*sin((float)mercury_orbit), 0.0);\n\tglRotatef(0.0, 1.0, 0.0, rotation);\n\tglutSolidSphere((GLdouble) 0.5, (GLint)20, (GLint)20);\n\tglPopMatrix();\n}", "path": "6\\solar.c", "repo_name": "Yasumoto/computergraphics2009", "stars": 1, "license": "None", "language": "c", "size": 2384}
{"docstring": "/*  Initialize material property, light source, lighting model,\n *  and depth buffer.\n */\n", "func_signal": "void init(void)", "code": "{\n   // Change the light color to white\n   GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 };\n   GLfloat mat_shininess[] = { 50.0 };\n\n\t// The position of the light\n\tGLfloat light_position[] = { 0.0, 0.0, 0.0, 1.0 };\n\n\tGLfloat light_position2[] = { 1.0, 1.0, 0.0, 1.0 };\n\n   glClearColor (0.0, 0.0, 0.0, 0.0);\n   glShadeModel (GL_SMOOTH);\n\t\n   glEnable(GL_COLOR_MATERIAL);\n\n   // Specifies material info for lighting\n   // Changed to diffuse lighting\n   glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_specular);\n   glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);\n\t\n   // update the lighting\n   glLightfv(GL_LIGHT0, GL_POSITION, light_position);\n   glLightfv(GL_LIGHT1, GL_POSITION, light_position2);\n\n\n   // Turn on GL settings\n   glEnable(GL_LIGHTING);\n   glEnable(GL_LIGHT0);\n   glEnable(GL_LIGHT1);\n   glEnable(GL_DEPTH_TEST);\n}", "path": "6\\solar.c", "repo_name": "Yasumoto/computergraphics2009", "stars": 1, "license": "None", "language": "c", "size": 2384}
{"docstring": "/*\n * The relatively simply display callback\n */\n", "func_signal": "void display(void)", "code": "{\n   glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n\tglutSolidCube(1);\n\n   glFlush ();\n   // Never forget to swap buffers when GL_DOUBLE\n   // is on\n   glutSwapBuffers();\n}", "path": "5\\JoeSmith5.c", "repo_name": "Yasumoto/computergraphics2009", "stars": 1, "license": "None", "language": "c", "size": 2384}
{"docstring": "/*\n * the reshape callback function\n * set up the view window\n */\n", "func_signal": "void reshape (int w, int h)", "code": "{\n   glViewport (0, 0, (GLsizei) w, (GLsizei) h);\n   glMatrixMode (GL_PROJECTION);\n   glLoadIdentity();\n\tgluPerspective (45.0, (GLfloat)w/(GLfloat)h, 0.1, 4000.0 ); \n   glMatrixMode(GL_MODELVIEW);\n}", "path": "final\\init.c", "repo_name": "Yasumoto/computergraphics2009", "stars": 1, "license": "None", "language": "c", "size": 2384}
{"docstring": "/*\n * Draw \"Ready!\" onto the lower right corner\n * when the missile is engaged and prepared\n * to fire\n */\n", "func_signal": "void show_ready()", "code": "{\n\tglPushMatrix();\n\t//glLoadIdentity();\n\t\n\tglTranslatef(-25.0, 0.0, 5.0);\n\tglRotatef(-90, 0.0, 1.0, 0.0);\n\tglRotatef(-20, 1.0, 0.0, 0.0);\n\tglScalef(0.01, 0.01, 0.01);\n\n\tchar* ready = \"Ready!\";\n\tglColor3f(RED);\n\twrite_stroke(ready);\n\tglPopMatrix();\n}", "path": "final\\init.c", "repo_name": "Yasumoto/computergraphics2009", "stars": 1, "license": "None", "language": "c", "size": 2384}
{"docstring": "/*\n=================\nCmd_PutAway_f\n=================\n*/\n", "func_signal": "void Cmd_PutAway_f (edict_t * ent)", "code": "{\n\tent->client->showscores = false;\n\tent->client->showhelp = false;\n\tent->client->showinventory = false;\n//FIREBLADE\n\tif (ent->client->menu)\n\t\tPMenu_Close (ent);\n//FIREBLADE\n}", "path": "source\\g_cmds.c", "repo_name": "hifi-unmaintained/aq2-tng-old", "stars": 0, "license": "None", "language": "c", "size": 672}
{"docstring": "// AQ2:TNG - Slicer : Video Check\n", "func_signal": "void Cmd_VidRef_f (edict_t * ent)", "code": "{\n\tif (video_check->value || video_check_lockpvs->value)\n\t{\n\t\tQ_strncpyz (ent->client->resp.vidref, gi.argv(1), sizeof(ent->client->resp.vidref));\n\t}\n\n}", "path": "source\\g_cmds.c", "repo_name": "hifi-unmaintained/aq2-tng-old", "stars": 0, "license": "None", "language": "c", "size": 672}
{"docstring": "/*\n=================\nCmd_Players_f\n=================\n*/\n", "func_signal": "void Cmd_Players_f (edict_t * ent)", "code": "{\n\tint i;\n\tint count = 0;\n\tchar small[64];\n\tchar large[1024];\n\tint index[256];\n\n\n\tfor (i = 0; i < maxclients->value; i++)\n\t{\n\t\tif (game.clients[i].pers.connected)\n\t\t\tindex[count++] = i;\n\t}\n\n\tif (!teamplay->value || !noscore->value)\n\t{\n\t\t// sort by frags\n\t\tqsort (index, count, sizeof (index[0]), PlayerSort);\n\t}\n\n\t// print information\n\tlarge[0] = 0;\n\n\tfor (i = 0; i < count; i++)\n\t{\n\t\tif (!teamplay->value || !noscore->value)\n\t\t\tCom_sprintf (small, sizeof (small), \"%3i %s\\n\",\n\t\t\t\tgame.clients[index[i]].ps.stats[STAT_FRAGS],\n\t\t\t\tgame.clients[index[i]].pers.netname);\n\t\telse\n\t\t\tCom_sprintf (small, sizeof (small), \"%s\\n\",\n\t\t\t\tgame.clients[index[i]].pers.netname);\n\n\t\tif (strlen(small) + strlen(large) > sizeof (large) - 20)\n\t\t{\t\t\t// can't print all of them in one packet\n\t\t\tstrcat (large, \"...\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tstrcat (large, small);\n\t}\n\n\tgi.cprintf (ent, PRINT_HIGH, \"%s\\n%i players\\n\", large, count);\n}", "path": "source\\g_cmds.c", "repo_name": "hifi-unmaintained/aq2-tng-old", "stars": 0, "license": "None", "language": "c", "size": 672}
{"docstring": "/*\n=================\nCmd_WeapLast_f\n=================\n*/\n", "func_signal": "void Cmd_WeapLast_f (edict_t * ent)", "code": "{\n\tgclient_t *cl;\n\tint index;\n\tgitem_t *it;\n\n\tif (ent->solid == SOLID_NOT && ent->deadflag != DEAD_DEAD)\n\t\treturn;\n\n\tcl = ent->client;\n\n\tif (!cl->pers.weapon || !cl->pers.lastweapon)\n\t\treturn;\n\n\tindex = ITEM_INDEX (cl->pers.lastweapon);\n\tif (!cl->pers.inventory[index])\n\t\treturn;\n\tit = &itemlist[index];\n\tif (!it->use)\n\t\treturn;\n\tif (!(it->flags & IT_WEAPON))\n\t\treturn;\n\tit->use (ent, it);\n}", "path": "source\\g_cmds.c", "repo_name": "hifi-unmaintained/aq2-tng-old", "stars": 0, "license": "None", "language": "c", "size": 672}
{"docstring": "/*\n  ============\n  T_RadiusDamage\n  ============\n*/\n", "func_signal": "void\nT_RadiusDamage (edict_t * inflictor, edict_t * attacker, float damage,\n\t\tedict_t * ignore, float radius, int mod)", "code": "{\n\tfloat points;\n\tedict_t *ent = NULL;\n\tvec3_t v;\n\tvec3_t dir;\n\n\twhile ((ent = findradius (ent, inflictor->s.origin, radius)) != NULL)\n\t{\n\t\tif (ent == ignore)\n\t\t\tcontinue;\n\t\tif (!ent->takedamage)\n\t\t\tcontinue;\n\n\t\tVectorAdd (ent->mins, ent->maxs, v);\n\t\tVectorMA (ent->s.origin, 0.5, v, v);\n\t\tVectorSubtract (inflictor->s.origin, v, v);\n\t\tpoints = damage - 0.5 * VectorLength (v);\n\t\t//zucc reduce damage for crouching, max is 32 when standing\n\t\tif (ent->maxs[2] < 20)\n\t\t{\n\t\t\tpoints = points * 0.5;\t// hefty reduction in damage\n\t\t}\n\t\t//if (ent == attacker)\n\t\t//points = points * 0.5; \n\t\tif (points > 0)\n\t\t{\n#ifdef _DEBUG\n\t\t\tif (0 == Q_stricmp (ent->classname, \"func_explosive\"))\n\t\t\t{\n\t\t\t\tCGF_SFX_ShootBreakableGlass (ent, inflictor, 0, mod);\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\tif (CanDamage (ent, inflictor))\n\t\t\t{\n\t\t\t\tVectorSubtract (ent->s.origin, inflictor->s.origin, dir);\n\t\t\t\t// zucc scaled up knockback(kick) of grenades\n\t\t\t\tT_Damage (ent, inflictor, attacker, dir, ent->s.origin,\n\t\t\t\tvec3_origin, (int) (points * .75),\n\t\t\t\t(int) (points * .75), DAMAGE_RADIUS, mod);\n\t\t\t}\n\t\t}\n\t}\n}", "path": "source\\g_combat.c", "repo_name": "hifi-unmaintained/aq2-tng-old", "stars": 0, "license": "None", "language": "c", "size": 672}
{"docstring": "/*\n=================\nClientCommand\n=================\n*/\n", "func_signal": "void ClientCommand (edict_t * ent)", "code": "{\n\tchar *cmd;\n\n\tif (!ent->client)\n\t\treturn;\t\t\t// not fully in game yet\n\t// if (level.intermissiontime)\n\t// return;\n\n\tcmd = gi.argv (0);\n\n\tif (Q_stricmp (cmd, \"players\") == 0)\n\t{\n\t\tCmd_Players_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"say\") == 0)\n\t{\n\t\tCmd_Say_f (ent, false, false, false);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"say_team\") == 0)\n\t{\n\t\tCmd_Say_f (ent, true, false, false);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"score\") == 0)\n\t{\n\t\tCmd_Score_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"help\") == 0)\n\t{\n\t\tCmd_Help_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"use\") == 0)\n\t{\n\t\tif(pause_time)\n\t\t\treturn;\n\t\tCmd_Use_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"drop\") == 0)\n\t{\n\t\tif(pause_time)\n\t\t\treturn;\n\t\tCmd_Drop_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"give\") == 0)\n\t{\n\t\tCmd_Give_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"god\") == 0)\n\t{\n\t\tCmd_God_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"notarget\") == 0)\n\t{\n\t\tCmd_Notarget_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"noclip\") == 0)\n\t{\n\t\tCmd_Noclip_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"inven\") == 0)\n\t{\n\t\tCmd_Inven_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"invnext\") == 0)\n\t{\n\t\tSelectNextItem (ent, -1);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"invprev\") == 0)\n\t{\n\t\tSelectPrevItem (ent, -1);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"invnextw\") == 0)\n\t{\n\t\tSelectNextItem (ent, IT_WEAPON);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"invprevw\") == 0)\n\t{\n\t\tSelectPrevItem (ent, IT_WEAPON);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"invnextp\") == 0)\n\t{\n\t\tSelectNextItem (ent, IT_POWERUP);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"invprevp\") == 0)\n\t{\n\t\tSelectPrevItem (ent, IT_POWERUP);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"invuse\") == 0)\n\t{\n\t\tCmd_InvUse_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"invdrop\") == 0)\n\t{\n\t\tCmd_InvDrop_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"weapprev\") == 0)\n\t{\n\t\tif(pause_time)\n\t\t\treturn;\n\t\tCmd_WeapPrev_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"weapnext\") == 0)\n\t{\n\t\tif(pause_time)\n\t\t\treturn;\n\t\tCmd_WeapNext_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"weaplast\") == 0)\n\t{\n\t\tif(pause_time)\n\t\t\treturn;\n\t\tCmd_WeapLast_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"kill\") == 0)\n\t{\n\t\tCmd_Kill_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"putaway\") == 0)\n\t{\n\t\tCmd_PutAway_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"wave\") == 0)\n\t{\n\t\tif(pause_time)\n\t\t\treturn;\n\t\tCmd_Wave_f (ent);\n\t\treturn;\n\t}\n//zucc\n//      else if (Q_stricmp (cmd, \"laser\") == 0)\n//              SP_LaserSight (ent);\n\n\t//SLIC2\n\n\telse if (Q_stricmp (cmd, \"streak\") == 0)\n\t{\n\t\tgi.cprintf(ent,PRINT_HIGH,\"Your Killing Streak is: %d\\n\",ent->client->resp.streak);\n\t\treturn;\n\t}\n\t//SLIC2\n\telse if (Q_stricmp (cmd, \"reload\") == 0)\n\t{\n\t\tif(pause_time)\n\t\t\treturn;\n\t\tCmd_New_Reload_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"weapon\") == 0)\n\t{\n\t\tif(pause_time)\n\t\t\treturn;\n\t\tCmd_New_Weapon_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"opendoor\") == 0)\n\t{\n\t\tif(pause_time)\n\t\t\treturn;\n\t\tCmd_OpenDoor_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"bandage\") == 0)\n\t{\n\t\tif(pause_time)\n\t\t\treturn;\n\t\tCmd_Bandage_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"id\") == 0)\n\t{\n\t\tCmd_ID_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"irvision\") == 0)\n\t{\n\t\tif(pause_time)\n\t\t\treturn;\n\t\tCmd_IR_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"playerlist\") == 0)\n\t{\n\t\tCmd_PlayerList_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"team\") == 0 && teamplay->value)\n\t{\n\t\tTeam_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"radio\") == 0)\n\t{\n\t\tCmd_Radio_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"radiogender\") == 0)\n\t{\n\t\tCmd_Radiogender_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"radio_power\") == 0)\n\t{\n\t\tCmd_Radio_power_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"radiopartner\") == 0)\n\t{\n\t\tCmd_Radiopartner_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"radioteam\") == 0)\n\t{\n\t\tCmd_Radioteam_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"channel\") == 0)\n\t{\n\t\tCmd_Channel_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"say_partner\") == 0)\n\t{\n\t\tCmd_Say_partner_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"partner\") == 0)\n\t{\n\t\tCmd_Partner_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"unpartner\") == 0)\n\t{\n\t\tCmd_Unpartner_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"motd\") == 0)\n\t{\n\t\tPrintMOTD (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"deny\") == 0)\n\t{\n\t\tCmd_Deny_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"choose\") == 0)\n\t{\n\t\tCmd_Choose_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"tkok\") == 0)\n\t{\n\t\tCmd_TKOk (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"time\") == 0)\n\t{\n\t\tCmd_Time (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"voice\") == 0)\n\t{\n\t\tif(pause_time)\n\t\t\treturn;\n\t\tif(use_voice->value)\n\t\t\tCmd_Voice_f (ent);\n\t\treturn;\n\t}\n//  else if (Q_stricmp (cmd, \"addpoint\") == 0 && sv_cheats->value)\n//    {\n//      Cmd_Addpoint_f (ent);\t// See TF's additions below\n//      return;\n//    }\n\telse if (Q_stricmp (cmd, \"setflag1\") == 0 && sv_cheats->value)\n\t{\n\t\tCmd_SetFlag1_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"setflag2\") == 0 && sv_cheats->value)\n\t{\n\t\tCmd_SetFlag2_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"saveflags\") == 0 && sv_cheats->value)\n\t{\n\t\tCmd_SaveFlags_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"punch\") == 0)\n\t{\n\t\tif(pause_time)\n\t\t\treturn;\n\t\tCmd_Punch_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"menu\") == 0)\n\t{\n\t\tCmd_Menu_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"rules\") == 0)\n\t{\n\t\tCmd_Rules_f (ent);\n\t\treturn;\n\t}\n\telse if (vCommand (ent, cmd) == true);\n\telse if (Q_stricmp (cmd, \"lens\") == 0)\n\t{\n\t\tif(pause_time)\n\t\t\treturn;\n\t\tCmd_Lens_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"%cpsi\") == 0)\n\t{\n\t\tCmd_CPSI_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"%!fc\") == 0)\n\t{\n\t\tCmd_VidRef_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"sub\") == 0)\n\t{\n\t\tCmd_Sub_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"captain\") == 0)\n\t{\n\t\tCmd_Captain_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"ready\") == 0)\n\t{\n\t\tCmd_Ready_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"teamname\") == 0)\n\t{\n\t\tCmd_Teamname_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"teamskin\") == 0)\n\t{\n\t\tCmd_Teamskin_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"lock\") == 0)\n\t{\n\t\tCmd_TeamLock_f(ent, 1);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"unlock\") == 0)\n\t{\n\t\tCmd_TeamLock_f(ent, 0);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"entcount\") == 0)\n\t{\n\t\tCmd_Ent_Count_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"stats\") == 0)\n\t{\n\t\tCmd_Stats_f (ent, gi.argv (1));\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"flashlight\") == 0)\n\t{\n\t\tif(pause_time)\n\t\t\treturn;\n\t\tFL_make (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"matchadmin\") == 0)\n\t{\n\t\tCmd_SetAdmin_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp(cmd, \"roundtimeleft\") == 0)\n\t{\n\t\tCmd_Roundtimeleft_f(ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"autorecord\") == 0)\n\t{\n\t\tCmd_AutoRecord_f(ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"stat_mode\") == 0 || Q_stricmp (cmd, \"cmd_stat_mode\") == 0)\n\t{\n\t\tCmd_Statmode_f (ent, gi.argv (1));\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"ghost\") == 0)\n\t{\n\t\tCmd_Ghost_f (ent);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"pausegame\") == 0)\n\t{\n\t\tCmd_TogglePause_f(ent, true);\n\t\treturn;\n\t}\n\telse if (Q_stricmp (cmd, \"unpausegame\") == 0)\n\t{\n\t\tCmd_TogglePause_f(ent, false);\n\t\treturn;\n\t}\n\telse if (Q_stricmp(cmd, \"resetscores\") == 0)\n\t{\n\t\tCmd_ResetScores_f(ent);\n\t}\n\telse\t\t\t\t// anything that doesn't match a command will be a chat\n\t\tCmd_Say_f (ent, false, true, false);\n}", "path": "source\\g_cmds.c", "repo_name": "hifi-unmaintained/aq2-tng-old", "stars": 0, "license": "None", "language": "c", "size": 672}
{"docstring": "/*\n=================\nCmd_WeapNext_f\n=================\n*/\n", "func_signal": "void Cmd_WeapNext_f (edict_t * ent)", "code": "{\n\tgclient_t *cl;\n\tint i, index;\n\tgitem_t *it;\n\tint selected_weapon;\n\n\tif (ent->solid == SOLID_NOT && ent->deadflag != DEAD_DEAD)\n\t\treturn;\n\n\tcl = ent->client;\n\n\tif (!cl->pers.weapon)\n\t\treturn;\n\n\tselected_weapon = ITEM_INDEX (cl->pers.weapon);\n\n\t// scan  for the next valid one\n\tfor (i = 1; i <= MAX_ITEMS; i++)\n\t{\n\t\tindex = (selected_weapon + MAX_ITEMS - i) % MAX_ITEMS;\n\t\tif (!cl->pers.inventory[index])\n\t\t\tcontinue;\n\t\tit = &itemlist[index];\n\t\tif (!it->use)\n\t\t\tcontinue;\n\t\tif (!(it->flags & IT_WEAPON))\n\t\t\tcontinue;\n\t\tit->use (ent, it);\n\t\tif (cl->pers.weapon == it)\n\t\t\treturn;\t\t\t// successful\n\t}\n}", "path": "source\\g_cmds.c", "repo_name": "hifi-unmaintained/aq2-tng-old", "stars": 0, "license": "None", "language": "c", "size": 672}
{"docstring": "/*\n=================\nCmd_WeapPrev_f\n=================\n*/\n", "func_signal": "void Cmd_WeapPrev_f (edict_t * ent)", "code": "{\n\tgclient_t *cl;\n\tint i, index;\n\tgitem_t *it;\n\tint selected_weapon;\n\n\tif (ent->solid == SOLID_NOT && ent->deadflag != DEAD_DEAD)\n\t\treturn;\n\n\tcl = ent->client;\n\n\tif (!cl->pers.weapon)\n\t\treturn;\n\n\tselected_weapon = ITEM_INDEX (cl->pers.weapon);\n\n\t// scan  for the next valid one\n\tfor (i = 1; i <= MAX_ITEMS; i++)\n\t{\n\t\tindex = (selected_weapon + i) % MAX_ITEMS;\n\t\tif (!cl->pers.inventory[index])\n\t\t\tcontinue;\n\t\tit = &itemlist[index];\n\t\tif (!it->use)\n\t\t\tcontinue;\n\t\tif (!(it->flags & IT_WEAPON))\n\t\t\tcontinue;\n\t\tit->use (ent, it);\n\t\tif (cl->pers.weapon == it)\n\t\t\treturn;\t\t\t// successful\n\t}\n}", "path": "source\\g_cmds.c", "repo_name": "hifi-unmaintained/aq2-tng-old", "stars": 0, "license": "None", "language": "c", "size": 672}
{"docstring": "/*\n==================\nCmd_Use_f\n\nUse an inventory item\n==================\n*/\n", "func_signal": "void Cmd_Use_f (edict_t * ent)", "code": "{\n\tgitem_t *it;\n\tchar *s;\n\n\ts = gi.args ();\n\n\t//zucc - check for \"special\"\n\tif (Q_stricmp (s, \"special\") == 0)\n\t{\n\t\tReadySpecialWeapon (ent);\n\t\treturn;\n\t}\n\n\t//zucc - alias names\n\tif (!Q_stricmp (s, \"blaster\") || !Q_stricmp (s, \"mark 23 pistol\"))\n\t\ts = MK23_NAME;\n\telse if (!Q_stricmp (s, \"A 2nd pistol\") || !Q_stricmp (s, \"railgun\"))\n\t\ts = DUAL_NAME;\n\telse if (!Q_stricmp (s, \"shotgun\"))\n\t\ts = M3_NAME;\n\telse if (!Q_stricmp (s, \"machinegun\"))\n\t\ts = HC_NAME;\n\telse if (!Q_stricmp (s, \"super shotgun\"))\n\t\ts = MP5_NAME;\n\telse if (!Q_stricmp (s, \"chaingun\"))\n\t\ts = SNIPER_NAME;\n\telse if (!Q_stricmp (s, \"bfg10k\"))\n\t\ts = KNIFE_NAME;\n\t// zucc - let people pull up a knife ready to be thrown\n\telse if (!Q_stricmp (s, \"throwing combat knife\"))\n\t{\n\t\tif (ent->client->curr_weap != KNIFE_NUM)\n\t\t{\n\t\t\tent->client->resp.knife_mode = 1;\n\t\t}\n\t\telse // switch to throwing mode if a knife is already out\n\t\t{\n\t\t\t//if(!ent->client->resp.knife_mode)\n\t\t\t\tCmd_New_Weapon_f (ent);\n\t\t}\n\t\ts = KNIFE_NAME;\n\t}\n\telse if (!Q_stricmp (s, \"slashing combat knife\"))\n\t{\n\t\tif (ent->client->curr_weap != KNIFE_NUM)\n\t\t{\n\t\t\tent->client->resp.knife_mode = 0;\n\t\t}\n\t\telse // switch to slashing mode if a knife is already out\n\t\t{\n\t\t\t//if(ent->client->resp.knife_mode)\n\t\t\t\tCmd_New_Weapon_f (ent);\n\t\t}\n\t\ts = KNIFE_NAME;\n\t}\n\telse if (!Q_stricmp (s, \"grenade launcher\"))\n\t\ts = M4_NAME;\n\telse if (!Q_stricmp (s, \"grenades\"))\n\t\ts = GRENADE_NAME;\n\n\tit = FindItem (s);\n\n\t//FIREBLADE\n\tif (!it || (ent->solid == SOLID_NOT && ent->deadflag != DEAD_DEAD))\n\t//FIREBLADE\n\t{\n\t\tgi.cprintf (ent, PRINT_HIGH, \"Unknown item: %s\\n\", s);\t// fixed capitalization -FB\n\t\treturn;\n\t}\n\n\tif (!it->use)\n\t{\n\t\tgi.cprintf (ent, PRINT_HIGH, \"Item is not usable.\\n\");\n\t\treturn;\n\t}\n\n\tif (!ent->client->pers.inventory[ITEM_INDEX (it)])\n\t{\n\t\tgi.cprintf (ent, PRINT_HIGH, \"Out of item: %s\\n\", s);\n\t\treturn;\n\t}\n\n\t//TempFile\n\tent->client->autoreloading = false;\n\t//TempFile\n\n\tit->use (ent, it);\n}", "path": "source\\g_cmds.c", "repo_name": "hifi-unmaintained/aq2-tng-old", "stars": 0, "license": "None", "language": "c", "size": 672}
{"docstring": "/*\n==================\nCmd_Notarget_f\n\nSets client to notarget\n\nargv(0) notarget\n==================\n*/\n", "func_signal": "void Cmd_Notarget_f (edict_t * ent)", "code": "{\n\tchar *msg;\n\n\tif (deathmatch->value && !sv_cheats->value)\n\t{\n\t\tgi.cprintf (ent, PRINT_HIGH,\n\t\t\"You must run the server with '+set cheats 1' to enable this command.\\n\");\n\t\treturn;\n\t}\n\n\tent->flags ^= FL_NOTARGET;\n\tif (!(ent->flags & FL_NOTARGET))\n\t\tmsg = \"notarget OFF\\n\";\n\telse\n\t\tmsg = \"notarget ON\\n\";\n\n\tgi.cprintf (ent, PRINT_HIGH, msg);\n}", "path": "source\\g_cmds.c", "repo_name": "hifi-unmaintained/aq2-tng-old", "stars": 0, "license": "None", "language": "c", "size": 672}
{"docstring": "/*\n==================\nCmd_Drop_f\n\nDrop an inventory item\n==================\n*/\n", "func_signal": "void Cmd_Drop_f (edict_t * ent)", "code": "{\n\tint index;\n\tgitem_t *it;\n\tchar *s;\n\n\tif (ent->solid == SOLID_NOT || ent->deadflag == DEAD_DEAD)\n\t\treturn;\n\n\ts = gi.args ();\n\n\t//zucc check to see if the string is weapon\n\tif (Q_stricmp (s, \"weapon\") == 0)\n\t{\n\t\tDropSpecialWeapon (ent);\n\t\treturn;\n\t}\n\n\t//zucc now for item\n\tif (Q_stricmp (s, \"item\") == 0)\n\t{\n\t\tDropSpecialItem (ent);\n\t\treturn;\n\t}\n\n\tif (Q_stricmp (s, \"flag\") == 0)\n\t{\n\t\tCTFDrop_Flag (ent, NULL);\n\t\treturn;\n\t}\n\n\t// AQ:TNG - JBravo fixing ammo clip farming\n\tif (ent->client->weaponstate == WEAPON_RELOADING)\n\t\treturn;\n\t// Ammo clip farming fix end\n\n\tit = FindItem (s);\n\tif (!it)\n\t{\n\t\tgi.cprintf (ent, PRINT_HIGH, \"unknown item: %s\\n\", s);\n\t\treturn;\n\t}\n\tif (!it->drop)\n\t{\n\t\tgi.cprintf (ent, PRINT_HIGH, \"Item is not dropable.\\n\");\n\t\treturn;\n\t}\n\tindex = ITEM_INDEX (it);\n\tif (!ent->client->pers.inventory[index])\n\t{\n\t\tgi.cprintf (ent, PRINT_HIGH, \"Out of item: %s\\n\", s);\n\t\treturn;\n\t}\n\n\tit->drop (ent, it);\n}", "path": "source\\g_cmds.c", "repo_name": "hifi-unmaintained/aq2-tng-old", "stars": 0, "license": "None", "language": "c", "size": 672}
{"docstring": "/*\n=================\nCmd_Kill_f\n=================\n*/\n", "func_signal": "void Cmd_Kill_f (edict_t * ent)", "code": "{\n\t//FIREBLADE\n\tif (ent->solid == SOLID_NOT || ent->deadflag == DEAD_DEAD)\n\t\treturn;\n\t//FIREBLADE\n\t// AQ:TNG - JBravo adding punishkills\n\tif (punishkills->value)\n\t{\n\t\tif (ent->client->attacker && ent->client->attacker->client &&\n\t\t(ent->client->attacker->client != ent->client))\n\t\t{\n\t\t\tchar deathmsg[64];\n\t\t\tCom_sprintf(deathmsg, sizeof(deathmsg), \"%s ph34rs %s so much %s committed suicide! :)\\n\",\n\t\t\t\tent->client->pers.netname, ent->client->attacker->client->pers.netname,\n\t\t\t\tent->client->resp.radio_gender ? \"she\" : \"he\");\n\t\t\tPrintDeathMessage(deathmsg, ent);\n\t\t\tif(team_round_going || !OnSameTeam(ent, ent->client->attacker)) {\n\t\t\t\tAdd_Frag (ent->client->attacker);\n\t\t\t\tSubtract_Frag (ent);\n\t\t\t\tent->client->resp.deaths++;\n\t\t\t}\n\t\t}\n\t}\n\t// End punishkills\n\n\tif ((level.time - ent->client->respawn_time) < 5)\n\t\treturn;\n\tent->flags &= ~FL_GODMODE;\n\tent->health = 0;\n\tmeansOfDeath = MOD_SUICIDE;\n\tplayer_die (ent, ent, ent, 100000, vec3_origin);\n// Forget all this... -FB\n//        // don't even bother waiting for death frames\n//        ent->deadflag = DEAD_DEAD;\n////FIREBLADE\n//        if (!teamplay->value)\n////FIREBLADE\n//                respawn (ent);\n}", "path": "source\\g_cmds.c", "repo_name": "hifi-unmaintained/aq2-tng-old", "stars": 0, "license": "None", "language": "c", "size": 672}
{"docstring": "/*\n  ============\n  Killed\n  ============\n*/\n", "func_signal": "void Killed (edict_t * targ, edict_t * inflictor, edict_t * attacker, int damage,\n\tvec3_t point)", "code": "{\n\tif (targ->health < -999)\n\t\ttarg->health = -999;\n\n\tif (targ->client)\n\t{\n\t\ttarg->client->bleeding = 0;\n\t\t//targ->client->bleedcount = 0;\n\t\ttarg->client->bleed_remain = 0;\n\t}\n\n\ttarg->enemy = attacker;\n\n\tif ((targ->svflags & SVF_MONSTER) && (targ->deadflag != DEAD_DEAD))\n\t{\n\t\t//              targ->svflags |= SVF_DEADMONSTER;       // now treat as a different content type\n\t\tif (!(targ->monsterinfo.aiflags & AI_GOOD_GUY))\n\t\t{\n\t\t\tlevel.killed_monsters++;\n\t\t\tif (coop->value && attacker->client)\n\t\t\t\tattacker->client->resp.score++;\n\t\t\t// medics won't heal monsters that they kill themselves\n\t\t\tif (strcmp (attacker->classname, \"monster_medic\") == 0)\n\t\t\t\ttarg->owner = attacker;\n\t\t}\n\t}\n\n\tif (targ->movetype == MOVETYPE_PUSH || targ->movetype == MOVETYPE_STOP\n\t|| targ->movetype == MOVETYPE_NONE)\n\t{\t\t\t\t// doors, triggers, etc\n\t\ttarg->die (targ, inflictor, attacker, damage, point);\n\t\treturn;\n\t}\n\n\tif ((targ->svflags & SVF_MONSTER) && (targ->deadflag != DEAD_DEAD))\n\t{\n\t\ttarg->touch = NULL;\n\t\tmonster_death_use (targ);\n\t}\n\n\ttarg->die (targ, inflictor, attacker, damage, point);\n}", "path": "source\\g_combat.c", "repo_name": "hifi-unmaintained/aq2-tng-old", "stars": 0, "license": "None", "language": "c", "size": 672}
{"docstring": "//SLICER\n", "func_signal": "void Cmd_Ent_Count_f (edict_t * ent)", "code": "{\n\tint x = 0;\n\tedict_t *e;\n\n\tfor (e = g_edicts; e < &g_edicts[globals.num_edicts]; e++)\n\t{\n\t\tif (e->inuse)\n\t\t\tx++;\n\t}\n\n\tgi.cprintf (ent, PRINT_HIGH, \"%d entities counted\\n\", x);\n}", "path": "source\\g_cmds.c", "repo_name": "hifi-unmaintained/aq2-tng-old", "stars": 0, "license": "None", "language": "c", "size": 672}
{"docstring": "/*\n==================\nCmd_Give_f\n\nGive items to a client\n==================\n*/\n", "func_signal": "void Cmd_Give_f (edict_t * ent)", "code": "{\n\tchar *name;\n\tchar fixedname[32];\n\tgitem_t *it;\n\tint index;\n\tint i;\n\tqboolean give_all;\n\tedict_t *it_ent;\n\tedict_t etemp;\n\n\tif (deathmatch->value && !sv_cheats->value)\n\t{\n\t\tgi.cprintf (ent, PRINT_HIGH, \"You must run the server with '+set cheats 1' to enable this command.\\n\");\n\t\treturn;\n\t}\n\n\tif (ent->solid == SOLID_NOT)\n\t{\n\t\tgi.cprintf (ent, PRINT_HIGH, \"This command can't be used by spectators.\\n\");\n\t\treturn;\n\t}\n\n\tQ_strncpyz(fixedname, gi.args (), sizeof(fixedname));\n\tname = fixedname;\n//  name = gi.args ();\n\n\tif (Q_stricmp (name, \"all\") == 0)\n\t\tgive_all = true;\n\telse\n\t\tgive_all = false;\n\n\tif (Q_stricmp (gi.argv (1), \"health\") == 0)\n\t{\n\t\t/*    if (gi.argc() == 3)\n\t\tent->health = atoi(gi.argv(2));\n\t\telse\n\t\tent->health = ent->max_health;\n\t\tif (!give_all) */\n\t\treturn;\n\t}\n\n\tif (give_all || Q_stricmp (name, \"weapons\") == 0)\n\t{\n\t\tfor (i = 0; i < game.num_items; i++)\n\t\t{\n\t\t\tit = itemlist + i;\n\t\t\tif (!it->pickup)\n\t\t\t\tcontinue;\n\t\t\tif (!(it->flags & IT_WEAPON))\n\t\t\t\tcontinue;\n\t\t\tent->client->pers.inventory[i] += 1;\n\t\t}\n\t\tif (!give_all)\n\t\t\treturn;\n\t}\n\n\tif (give_all || Q_stricmp (name, \"items\") == 0)\n\t{\n\t\tfor (i = 0; i < game.num_items; i++)\n\t\t{\n\t\t\tit = itemlist + i;\n\t\t\tif (!it->pickup)\n\t\t\t\tcontinue;\n\t\t\tif (!(it->flags & IT_ITEM))\n\t\t\t\tcontinue;\n\t\t\tetemp.item = it;\n\n\t\t\tif (ent->client->unique_item_total >= unique_items->value)\n\t\t\t\tent->client->unique_item_total = unique_items->value - 1;\n\n\t\t\tPickup_Special (&etemp, ent);\n\t\t}\n\t\tif (!give_all)\n\t\t\treturn;\n\t}\n\n\n\tif (give_all || Q_stricmp (name, \"ammo\") == 0)\n\t{\n\t\tent->client->mk23_rds = ent->client->mk23_max;\n\t\tent->client->dual_rds = ent->client->dual_max;\n\t\tent->client->mp5_rds = ent->client->mp5_max;\n\t\tent->client->m4_rds = ent->client->m4_max;\n\t\tent->client->shot_rds = ent->client->shot_max;\n\t\tent->client->sniper_rds = ent->client->sniper_max;\n\t\tent->client->cannon_rds = ent->client->cannon_max;\n\n\t\tfor (i = 0; i < game.num_items; i++)\n\t\t{\n\t\t\tit = itemlist + i;\n\t\t\tif (!it->pickup)\n\t\t\t\tcontinue;\n\t\t\tif (!(it->flags & IT_AMMO))\n\t\t\t\tcontinue;\n\t\t\tAdd_Ammo (ent, it, 1000);\n\t\t}\n\t\tif (!give_all)\n\t\t\treturn;\n\t}\n\n\tif (Q_stricmp (name, \"armor\") == 0)\n\t{\n\t\t/*\n\t\tgitem_armor_t   *info;\n\n\t\tit = FindItem(\"Jacket Armor\");\n\t\tent->client->pers.inventory[ITEM_INDEX(it)] = 0;\n\n\t\tit = FindItem(\"Combat Armor\");\n\t\tent->client->pers.inventory[ITEM_INDEX(it)] = 0;\n\n\t\tit = FindItem(\"Body Armor\");\n\t\tinfo = (gitem_armor_t *)it->info;\n\t\tent->client->pers.inventory[ITEM_INDEX(it)] = info->max_count;\n\n\t\tif (!give_all)\n\t\t*/\n\t\treturn;\n\t}\n\n\tif (Q_stricmp (name, \"Power Shield\") == 0)\n\t{\n\t\t/*it = FindItem(\"Power Shield\");\n\t\tit_ent = G_Spawn();\n\t\tit_ent->classname = it->classname;\n\t\tSpawnItem (it_ent, it);\n\t\tTouch_Item (it_ent, ent, NULL, NULL);\n\t\tif (it_ent->inuse)\n\t\tG_FreeEdict(it_ent);\n\n\t\tif (!give_all)\n\t\t*/\n\t\treturn;\n\t}\n\n\t/*if (give_all)\n\t{\n\t\tfor (i=0 ; i<game.num_items ; i++)\n\t\t{\n\t\t\tit = itemlist + i;\n\t\t\tif (!it->pickup)\n\t\t\t\tcontinue;\n\t\t\tif (it->flags & (IT_ARMOR|IT_WEAPON|IT_AMMO))\n\t\t\t\tcontinue;\n\t\t\tent->client->pers.inventory[i] = 1;\n\t\t}\n\t\treturn;\n\t} */\n\n\tif (give_all)\n\t\treturn;\n\n\tit = FindItem (name);\n\tif (!it)\n\t{\n\t\tQ_strncpyz(fixedname, gi.argv (1), sizeof(fixedname));\n\t\tname = fixedname;\n\t\t//      name = gi.argv (1);\n\t\tit = FindItem (name);\n\t\tif (!it)\n\t\t{\n\t\t\tgi.dprintf (\"unknown item\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!(it->flags & (IT_AMMO|IT_WEAPON|IT_ITEM)))\n\t\treturn;\n\n\n\tif (!it->pickup)\n\t{\n\t\tgi.dprintf (\"non-pickup item\\n\");\n\t\treturn;\n\t}\n\n\n\tindex = ITEM_INDEX (it);\n\n\tif (it->flags & IT_AMMO)\n\t{\n\t\t/*  if (gi.argc() == 5)\n\t\t\tent->client->pers.inventory[index] = atoi(gi.argv(4));\n\t\telse if ( (gi.argc() == 4)  && !(Q_stricmp(it->pickup_name, \"12 Gauge Shells\")) )\n\t\t\tent->client->pers.inventory[index] = atoi(gi.argv(3));\n\t\telse */\n\t\t\tent->client->pers.inventory[index] += it->quantity;\n\t}\n\telse if (it->flags & IT_ITEM)\n\t{\n\t\tetemp.item = it;\n\t\tif (ent->client->unique_item_total >= unique_items->value)\n\t\t\tent->client->unique_item_total = unique_items->value - 1;\n\n\t\tPickup_Special (&etemp, ent);\n\t}\n\telse\n\t{\n\t\tit_ent = G_Spawn ();\n\t\tit_ent->classname = it->classname;\n\t\tit_ent->typeNum = it->typeNum;\n\t\tSpawnItem (it_ent, it);\n\t\tTouch_Item (it_ent, ent, NULL, NULL);\n\t\tif (it_ent->inuse)\n\t\t\tG_FreeEdict (it_ent);\n\t}\n}", "path": "source\\g_cmds.c", "repo_name": "hifi-unmaintained/aq2-tng-old", "stars": 0, "license": "None", "language": "c", "size": 672}
{"docstring": "/*\n==================\nCmd_Say_f\n==================\n*/\n", "func_signal": "void Cmd_Say_f (edict_t * ent, qboolean team, qboolean arg0, qboolean partner_msg)", "code": "{\n\tint j, i, offset_of_text;\n\tedict_t *other;\n\tchar *args, text[256], *s;\n\tgclient_t *cl;\n\tint meing = 0, isadmin = 0;\n\n\tif (gi.argc() < 2 && !arg0)\n\t\treturn;\n\t\n\targs = gi.args();\n\n\tif (!sv_crlf->value)\n\t{\n\t\tif (strchr(args, '\\r') || strchr(args, '\\n'))\n\t\t{\n\t\t\tgi.cprintf (ent, PRINT_HIGH, \"No control characters in chat messages!\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t//TempFile - BEGIN\n\tif (arg0)\n\t{\n\t\tif (!Q_stricmp(\"%me\", gi.argv(0))) {\n\t\t\tmeing = 4;\n\t\t\tif(!args || !*args)\n\t\t\t\treturn;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(!args || !*args)\n\t\t\treturn;\n\n\t\tif (!Q_strnicmp(\"%me\", args, 3))\n\t\t\tmeing = 4;\n\t\telse if (!Q_strnicmp(\"%me\", args + 1, 3))\n\t\t\tmeing = 5;\n\n\t\tif(meing)\n\t\t{\n\t\t\tif (!*(args+meing-1))\n\t\t\t\treturn;\n\t\t\tif (*(args+meing-1) != ' ')\n\t\t\t\tmeing = 0;\n\t\t\telse if(!*(args+meing))\n\t\t\t\treturn;\n\t\t}\n\t}\n\t//TempFile - END\n\n\tif (!teamplay->value)\n\t{\n\t\t//FIREBLADE\n\t\tif (!((int)(dmflags->value) & (DF_MODELTEAMS | DF_SKINTEAMS)))\n\t\t\tteam = false;\n\t}\n\telse if (matchmode->value)\n\t{\t\n\t\tif (ent->client->resp.admin)\n\t\t\tisadmin = 1;\n\n\t\tif (mm_forceteamtalk->value == 1)\n\t\t{\n\t\t\tif (!ent->client->resp.captain && !partner_msg && !isadmin)\n\t\t\t\tteam = true;\n\t\t}\n\t\telse if (mm_forceteamtalk->value == 2)\n\t\t{\n\t\t\tif (!ent->client->resp.captain && !partner_msg && !isadmin &&\n\t\t\t\t(TeamsReady() || team_round_going))\n\t\t\t\tteam = true;\n\t\t}\n\t}\n\n\tif (team)\n\t{\n\t\tif (ent->client->resp.team == NOTEAM)\n\t\t{\n\t\t\tgi.cprintf (ent, PRINT_HIGH, \"You're not on a team.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif (!meing)\t\t// TempFile\n\t\t\tCom_sprintf (text, sizeof (text), \"%s(%s): \",\n\t\t\t(teamplay->value && (ent->solid == SOLID_NOT\n\t\t\t|| ent->deadflag == DEAD_DEAD)) ? \"[DEAD] \" : \"\",\n\t\t\tent->client->pers.netname);\n\t\t//TempFile - BEGIN\n\t\telse\n\t\t\tCom_sprintf (text, sizeof (text), \"(%s%s \",\n\t\t\t(teamplay->value && (ent->solid == SOLID_NOT\n\t\t\t|| ent->deadflag == DEAD_DEAD)) ? \"[DEAD] \" : \"\",\n\t\t\tent->client->pers.netname);\n\t\t//TempFile - END\n\t}\n\telse if (partner_msg)\n\t{\n\t\tif (ent->client->resp.radio_partner == NULL)\n\t\t{\n\t\t\tgi.cprintf (ent, PRINT_HIGH, \"You don't have a partner.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif (!meing)\t\t//TempFile\n\t\t\tCom_sprintf (text, sizeof (text), \"[%sPARTNER] %s: \",\n\t\t\t(teamplay->value && (ent->solid == SOLID_NOT\n\t\t\t|| ent->deadflag == DEAD_DEAD)) ? \"DEAD \" : \"\",\n\t\t\tent->client->pers.netname);\n\t\t//TempFile - BEGIN\n\t\telse\n\t\t\tCom_sprintf (text, sizeof (text), \"%s partner %s \",\n\t\t\t(teamplay->value && (ent->solid == SOLID_NOT\n\t\t\t|| ent->deadflag == DEAD_DEAD)) ? \"[DEAD] \" : \"\",\n\t\t\tent->client->pers.netname);\n\t\t//TempFile - END\n\t}\n\telse\n\t{\n\t\tif (!meing)\t\t//TempFile\n\t\t{\n\t\t\tif (isadmin)\n\t\t\t\tCom_sprintf (text, sizeof (text), \"[ADMIN] %s: \",\n\t\t\t\tent->client->pers.netname);\n\t\t\telse\n\t\t\t\tCom_sprintf (text, sizeof (text), \"%s%s: \",\n\t\t\t\t(teamplay->value && (ent->solid == SOLID_NOT\n\t\t\t\t|| ent->deadflag == DEAD_DEAD)) ? \"[DEAD] \" : \"\",\n\t\t\t\tent->client->pers.netname);\n\t\t}\n\t\telse\n\t\t\tCom_sprintf (text, sizeof (text), \"%s%s \",\n\t\t\t(teamplay->value && (ent->solid == SOLID_NOT\n\t\t\t|| ent->deadflag == DEAD_DEAD)) ? \"[DEAD] \" : \"\",\n\t\t\tent->client->pers.netname);\n\t}\n\t//TempFile - END\n\t\n\toffset_of_text = strlen (text);\t//FB 5/31/99\n\tif (!meing)\t\t//TempFile\n\t{\n\t\tif (arg0)\n\t\t{\n\t\t\tQ_strncatz(text, gi.argv (0), sizeof(text));\n\t\t\tif(*args) {\n\t\t\t\tQ_strncatz(text, \" \", sizeof(text));\n\t\t\t\tQ_strncatz(text, args, sizeof(text));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\t\n\t\t\tif (*args == '\"') {\n\t\t\t\targs++;\n\t\t\t\targs[strlen(args) - 1] = 0;\n\t\t\t}\n\t\t\tQ_strncatz(text, args, sizeof(text));\n\t\t}\n\t}\n\telse\t\t\t// if meing\n\t{\n\t\tif (arg0)\n\t\t{\n\t\t\t//this one is easy: gi.args() cuts /me off for us!\n\t\t\tQ_strncatz(text, args, sizeof(text));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// we have to cut off \"%me \".\n\t\t\targs += meing;\n\t\t\tif (args[strlen(args) - 1] == '\"')\n\t\t\t\targs[strlen(args) - 1] = 0;\n\t\t\tQ_strncatz(text, args, sizeof(text));\n\t\t}\n\t\t\n\t\tif (team)\n\t\t\tQ_strncatz(text, \")\", sizeof(text));\n\t}\n\t//TempFile - END\n\t// don't let text be too long for malicious reasons\n\tif (strlen(text) >= 254)\n\t\ttext[254] = 0;\n\t\n\tif (ent->solid != SOLID_NOT && ent->deadflag != DEAD_DEAD)\n\t{\n\t\ts = strchr(text + offset_of_text, '%');\n\t\tif(s) {\n\t\t\t// this will parse the % variables,\n\t\t\tParseSayText (ent, s, sizeof(text) - (s - text+1) - 2);\n\t\t}\n\t}\n\n\tQ_strncatz(text, \"\\n\", sizeof(text));\n\n\tif (flood_msgs->value)\n\t{\n\t\tcl = ent->client;\n\n\t\tif (realLtime < cl->flood_locktill)\n\t\t{\n\t\t\tgi.cprintf (ent, PRINT_HIGH, \"You can't talk for %d more seconds.\\n\",\n\t\t\t\t\t(int) (cl->flood_locktill - realLtime));\n\t\t\treturn;\n\t\t}\n\t\ti = cl->flood_whenhead - flood_msgs->value + 1;\n\t\tif (i < 0)\n\t\t\ti = (sizeof (cl->flood_when) / sizeof (cl->flood_when[0])) + i;\n\t\tif (cl->flood_when[i] &&\n\t\t\trealLtime - cl->flood_when[i] < flood_persecond->value)\n\t\t{\n\t\t\tcl->flood_locktill = realLtime + flood_waitdelay->value;\n\t\t\tgi.cprintf (ent, PRINT_HIGH, \"You can't talk for %d seconds.\\n\",\n\t\t\t\t(int) flood_waitdelay->value);\n\t\t\treturn;\n\t\t}\n\t\tcl->flood_whenhead = (cl->flood_whenhead + 1) %\n\t\t\t(sizeof (cl->flood_when) / sizeof (cl->flood_when[0]));\n\t\tcl->flood_when[cl->flood_whenhead] = realLtime;\n\t}\n\t\n\tif (dedicated->value) {\n\t\tgi.cprintf (NULL, PRINT_CHAT, \"%s\", text);\n\t\tif ((!team) && (!partner_msg)) {\n\t\t\tIRC_printf (IRC_T_TALK, \"%s\", text);\n\t\t}\n\t}\n\t\n\tfor (j = 1; j <= game.maxclients; j++)\n\t{\n\t\tother = &g_edicts[j];\n\t\tif (!other->inuse)\n\t\t\tcontinue;\n\t\tif (!other->client)\n\t\t\tcontinue;\n\t\tif (team)\n\t\t{\n\t\t\t// if we are the adminent... we might want to hear (if hearall is set)\n\t\t\tif (!matchmode->value || !hearall->value || !other->client->resp.admin)\t// hearall isn't set and we aren't adminent\n\t\t\t\tif (!OnSameTeam (ent, other))\n\t\t\t\t\tcontinue;\n\t\t}\n\t\tif (partner_msg)\n\t\t{\n\t\t\tif (other != ent->client->resp.radio_partner && other != ent)\n\t\t\t\tcontinue;\n\t\t}\n\t\t//FIREBLADE\n\t\tif (teamplay->value && team_round_going)\n\t\t{\n\t\t\tif ((ent->solid == SOLID_NOT || ent->deadflag == DEAD_DEAD) &&\n\t\t\t\t(other->solid != SOLID_NOT && other->deadflag != DEAD_DEAD)\n\t\t\t\t&& !ctf->value && !teamdm->value)\t//AQ2:TNG Slicer\n\t\t\t\tcontinue;\n\t\t}\n\t\t//FIREBLADE\n\t\t//PG BUND - BEGIN\n\t\tif (IsInIgnoreList (other, ent))\n\t\t\tcontinue;\n\t\t//PG BUND - END\n\t\tgi.cprintf (other, PRINT_CHAT, \"%s\", text);\n\t}\n\n}", "path": "source\\g_cmds.c", "repo_name": "hifi-unmaintained/aq2-tng-old", "stars": 0, "license": "None", "language": "c", "size": 672}
{"docstring": "/*\n=================\nCmd_InvUse_f\n=================\n*/\n", "func_signal": "void Cmd_InvUse_f (edict_t * ent)", "code": "{\n\tgitem_t *it;\n\n\t//FIREBLADE\n\tif (ent->client->menu)\n\t{\n\t\tPMenu_Select (ent);\n\t\treturn;\n\t}\n\t//FIREBLADE\n\n\tif (ent->solid == SOLID_NOT && ent->deadflag != DEAD_DEAD)\n\t\treturn;\n\n\tValidateSelectedItem (ent);\n\n\tif (ent->client->pers.selected_item == -1)\n\t{\n\t\tgi.cprintf (ent, PRINT_HIGH, \"No item to use.\\n\");\n\t\treturn;\n\t}\n\n\tit = &itemlist[ent->client->pers.selected_item];\n\tif (!it->use)\n\t{\n\t\tgi.cprintf (ent, PRINT_HIGH, \"Item is not usable.\\n\");\n\t\treturn;\n\t}\n\tit->use (ent, it);\n}", "path": "source\\g_cmds.c", "repo_name": "hifi-unmaintained/aq2-tng-old", "stars": 0, "license": "None", "language": "c", "size": 672}
{"docstring": "/*\n=================\nCmd_Inven_f\n=================\n*/\n", "func_signal": "void Cmd_Inven_f (edict_t * ent)", "code": "{\n\tint i;\n\tgclient_t *cl;\n\n\tcl = ent->client;\n\n\tcl->showscores = false;\n\tcl->showhelp = false;\n\n\t//FIREBLADE\n\tif (ent->client->menu)\n\t{\n\t\tPMenu_Close (ent);\n\t\treturn;\n\t}\n\t//FIREBLADE\n\n\tif (cl->showinventory)\n\t{\n\t\tcl->showinventory = false;\n\t\treturn;\n\t}\n\n\t//FIREBLADE\n\tif (teamdm->value || ctf->value == 2) {\n\t\tif (ent->client->resp.team == NOTEAM) {\n\t\t\tOpenJoinMenu (ent);\n\t\t\treturn;\n\t\t}\n\t}\n\telse if (teamplay->value)\n\t{\n\t\tif (ent->client->resp.team == NOTEAM)\n\t\t\tOpenJoinMenu (ent);\n\t\telse\n\t\t\tOpenWeaponMenu (ent);\n\t\treturn;\n\t}\n\t//FIREBLADE\n\n\tcl->showinventory = true;\n\n\tgi.WriteByte (svc_inventory);\n\tfor (i = 0; i < MAX_ITEMS; i++)\n\t{\n\t\tgi.WriteShort (cl->pers.inventory[i]);\n\t}\n\tgi.unicast (ent, true);\n}", "path": "source\\g_cmds.c", "repo_name": "hifi-unmaintained/aq2-tng-old", "stars": 0, "license": "None", "language": "c", "size": 672}
{"docstring": "/*\n  ============\n  CanDamage\n  \n  Returns true if the inflictor can directly damage the target.  Used for\n  explosions and melee attacks.\n  ============\n*/\n", "func_signal": "qboolean CanDamage (edict_t * targ, edict_t * inflictor)", "code": "{\n\tvec3_t dest;\n\ttrace_t trace;\n\n\t// bmodels need special checking because their origin is 0,0,0\n\t//GLASS FX\n\tif ((targ->movetype == MOVETYPE_PUSH) ||\n\t((targ->movetype == MOVETYPE_FLYMISSILE)\n\t&& (0 == Q_stricmp (\"func_explosive\", targ->classname))))\n\t//GLASS FX\n\t{\n\t\tVectorAdd (targ->absmin, targ->absmax, dest);\n\t\tVectorScale (dest, 0.5, dest);\n\t\tPRETRACE ();\n\t\ttrace = gi.trace (inflictor->s.origin, vec3_origin, vec3_origin, dest,\n\t\t\tinflictor, MASK_SOLID);\n\t\tPOSTTRACE ();\n\t\tif (trace.fraction == 1.0)\n\t\t\treturn true;\n\t\tif (trace.ent == targ)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tPRETRACE ();\n\ttrace = gi.trace (inflictor->s.origin, vec3_origin, vec3_origin, targ->s.origin,\n\t\tinflictor, MASK_SOLID);\n\tPOSTTRACE ();\n\tif (trace.fraction == 1.0)\n\t\treturn true;\n\n\tVectorCopy (targ->s.origin, dest);\n\tdest[0] += 15.0;\n\tdest[1] += 15.0;\n\tPRETRACE ();\n\ttrace = gi.trace (inflictor->s.origin, vec3_origin, vec3_origin, dest, inflictor,\n\t\tMASK_SOLID);\n\tPOSTTRACE ();\n\tif (trace.fraction == 1.0)\n\t\treturn true;\n\n\tVectorCopy (targ->s.origin, dest);\n\tdest[0] += 15.0;\n\tdest[1] -= 15.0;\n\tPRETRACE ();\n\ttrace =\tgi.trace (inflictor->s.origin, vec3_origin, vec3_origin, dest, inflictor,\n\t\tMASK_SOLID);\n\tPOSTTRACE ();\n\tif (trace.fraction == 1.0)\n\t\treturn true;\n\n\tVectorCopy (targ->s.origin, dest);\n\tdest[0] -= 15.0;\n\tdest[1] += 15.0;\n\tPRETRACE ();\n\ttrace = gi.trace (inflictor->s.origin, vec3_origin, vec3_origin, dest, inflictor,\n\t\tMASK_SOLID);\n\tPOSTTRACE ();\n\tif (trace.fraction == 1.0)\n\t\treturn true;\n\n\tVectorCopy (targ->s.origin, dest);\n\tdest[0] -= 15.0;\n\tdest[1] -= 15.0;\n\tPRETRACE ();\n\ttrace =\tgi.trace (inflictor->s.origin, vec3_origin, vec3_origin, dest, inflictor,\n\t\tMASK_SOLID);\n\tPOSTTRACE ();\n\tif (trace.fraction == 1.0)\n\t\treturn true;\n\n\treturn false;\n}", "path": "source\\g_combat.c", "repo_name": "hifi-unmaintained/aq2-tng-old", "stars": 0, "license": "None", "language": "c", "size": 672}
{"docstring": "/*\n=================\nCmd_InvDrop_f\n=================\n*/\n", "func_signal": "void Cmd_InvDrop_f (edict_t * ent)", "code": "{\n\tgitem_t *it;\n\n\t// TNG: Temp fix for INVDROP weapon farming\n\tif(teamplay->value)\n\t\treturn;\n\t// TNG: End\n\n\tif (ent->solid == SOLID_NOT && ent->deadflag != DEAD_DEAD)\n\t\treturn;\n\n\tValidateSelectedItem (ent);\n\n\tif (ent->client->pers.selected_item == -1)\n\t{\n\t\tgi.cprintf (ent, PRINT_HIGH, \"No item to drop.\\n\");\n\t\treturn;\n\t}\n\n\tit = &itemlist[ent->client->pers.selected_item];\n\tif (!it->drop)\n\t{\n\t\tgi.cprintf (ent, PRINT_HIGH, \"Item is not dropable.\\n\");\n\t\treturn;\n\t}\n\tit->drop (ent, it);\n\n}", "path": "source\\g_cmds.c", "repo_name": "hifi-unmaintained/aq2-tng-old", "stars": 0, "license": "None", "language": "c", "size": 672}
{"docstring": "/* The code that handles single-instance and startup notification is\n * copied from gedit.\n *\n * Copyright (C) 2005 - Paolo Maggi\n */\n", "func_signal": "static void\non_bacon_message_received (const char *message,\n\t\t\t   gpointer    data)", "code": "{\n\tGtkWidget *window = data;\n\tguint32    startup_timestamp;\n\n\tg_return_if_fail (message != NULL);\n\n\tDEBUG (\"Other instance launched, presenting the main window. message='%s'\",\n\t\tmessage);\n\n\tif (strcmp (message, \"accounts\") == 0) {\n\t\t/* accounts dialog requested */\n\t\tempathy_accounts_dialog_show (GTK_WINDOW (window), NULL);\n\t} else {\n\t\tstartup_timestamp = atoi (message);\n\n\t\t/* Set the proper interaction time on the window.\n\t\t * Fall back to roundtripping to the X server when we\n\t\t * don't have the timestamp, e.g. when launched from\n\t\t * terminal. We also need to make sure that the window\n\t\t * has been realized otherwise it will not work. lame. */\n\t\tif (startup_timestamp == 0) {\n\t\t\t/* Work if launched from the terminal */\n\t\t\tDEBUG (\"Using X server timestamp as a fallback\");\n\n\t\t\tif (!GTK_WIDGET_REALIZED (window)) {\n\t\t\t\tgtk_widget_realize (GTK_WIDGET (window));\n\t\t\t}\n\n\t\t\tstartup_timestamp = gdk_x11_get_server_time (window->window);\n\t\t}\n\n\t\tgtk_window_present_with_time (GTK_WINDOW (window), startup_timestamp);\n\t}\n}", "path": "src\\empathy.c", "repo_name": "zenios/empathy-branch", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6448}
{"docstring": "/* HAVE_ENCHANT */\n", "func_signal": "void\nempathy_spell_free_suggestions (GList *suggestions)", "code": "{\n\tg_list_foreach (suggestions, (GFunc) g_free, NULL);\n\tg_list_free (suggestions);\n}", "path": "libempathy-gtk\\empathy-spell.c", "repo_name": "zenios/empathy-branch", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6448}
{"docstring": "/**\n * empathy_call_handler_new_for_contact_with_streams:\n * @contact: an #EmpathyContact\n * @audio: if %TRUE the call will be started with audio\n * @video: if %TRUE the call will be started with video\n *\n * Creates a new #EmpathyCallHandler with contact @contact.\n *\n * Return value: a new #EmpathyCallHandler\n */\n", "func_signal": "EmpathyCallHandler *\nempathy_call_handler_new_for_contact_with_streams (EmpathyContact *contact,\n    gboolean audio, gboolean video)", "code": "{\n  return EMPATHY_CALL_HANDLER (g_object_new (EMPATHY_TYPE_CALL_HANDLER,\n    \"contact\", contact,\n    \"initial-audio\", audio,\n    \"initial-video\", video,\n    NULL));\n}", "path": "libempathy\\empathy-call-handler.c", "repo_name": "zenios/empathy-branch", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6448}
{"docstring": "/**\n * ephy_spinner_stop:\n * @spinner: a #EphySpinner\n *\n * Stop the spinner animation.\n **/\n", "func_signal": "void\nephy_spinner_stop (EphySpinner *spinner)", "code": "{\n\tEphySpinnerDetails *details = spinner->details;\n\n\tdetails->spinning = FALSE;\n\tdetails->current_image = 0;\n\n\tif (details->timer_task != 0)\n\t{\n\t\tephy_spinner_remove_update_callback (spinner);\n\n\t\tif (GTK_WIDGET_MAPPED (GTK_WIDGET (spinner)))\n\t\t{\n\t\t\tgtk_widget_queue_draw (GTK_WIDGET (spinner));\n\t\t}\n\t}\n}", "path": "src\\ephy-spinner.c", "repo_name": "zenios/empathy-branch", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6448}
{"docstring": "/* Called from the streaming thread */\n", "func_signal": "static void\nempathy_call_window_sink_added_cb (EmpathyCallHandler *handler,\n  GstPad *sink, guint media_type, gpointer user_data)", "code": "{\n  EmpathyCallWindow *self = EMPATHY_CALL_WINDOW (user_data);\n  EmpathyCallWindowPriv *priv = GET_PRIV (self);\n  GstPad *pad;\n\n  switch (media_type)\n    {\n      case TP_MEDIA_STREAM_TYPE_AUDIO:\n        gst_bin_add (GST_BIN (priv->pipeline), priv->audio_input);\n\n        pad = gst_element_get_static_pad (priv->audio_input, \"src\");\n        gst_pad_link (pad, sink);\n\n        gst_element_set_state (priv->audio_input, GST_STATE_PLAYING);\n        break;\n      case TP_MEDIA_STREAM_TYPE_VIDEO:\n        if (priv->video_input != NULL)\n          {\n            pad = gst_element_get_request_pad (priv->video_tee, \"src%d\");\n            gst_pad_link (pad, sink);\n          }\n        break;\n      default:\n        g_assert_not_reached ();\n    }\n\n}", "path": "src\\empathy-call-window.c", "repo_name": "zenios/empathy-branch", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6448}
{"docstring": "/**\n * empathy_avatar_image_new:\n *\n * Creates a new #EmpathyAvatarImage.\n *\n * Return value: a new #EmpathyAvatarImage\n */\n", "func_signal": "GtkWidget *\nempathy_avatar_image_new (void)", "code": "{\n\tEmpathyAvatarImage *avatar_image;\n\n\tavatar_image = g_object_new (EMPATHY_TYPE_AVATAR_IMAGE, NULL);\n\n\treturn GTK_WIDGET (avatar_image);\n}", "path": "libempathy-gtk\\empathy-avatar-image.c", "repo_name": "zenios/empathy-branch", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6448}
{"docstring": "/**\n * ephy_spinner_start:\n * @spinner: a #EphySpinner\n *\n * Start the spinner animation.\n **/\n", "func_signal": "void\nephy_spinner_start (EphySpinner *spinner)", "code": "{\n\tEphySpinnerDetails *details = spinner->details;\n\n\tdetails->spinning = TRUE;\n\n\tif (GTK_WIDGET_MAPPED (GTK_WIDGET (spinner)) &&\n\t    details->timer_task == 0 &&\n\t    ephy_spinner_load_images (spinner))\n\t{\n\t\t/* the 0th frame is the 'rest' icon */\n\t\tdetails->current_image = MIN (1, details->images->n_animation_pixbufs);\n\n\t\tdetails->timer_task =\n\t\t\tg_timeout_add_full (G_PRIORITY_LOW,\n\t\t\t                    details->timeout,\n\t\t\t\t            (GSourceFunc) bump_spinner_frame_cb,\n\t\t\t\t            spinner,\n\t\t\t\t            NULL);\n\t}\n}", "path": "src\\ephy-spinner.c", "repo_name": "zenios/empathy-branch", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6448}
{"docstring": "/**\n * empathy_call_handler_new_for_contact:\n * @contact: an #EmpathyContact\n *\n * Creates a new #EmpathyCallHandler with contact @contact.\n *\n * Return value: a new #EmpathyCallHandler\n */\n", "func_signal": "EmpathyCallHandler *\nempathy_call_handler_new_for_contact (EmpathyContact *contact)", "code": "{\n  return EMPATHY_CALL_HANDLER (g_object_new (EMPATHY_TYPE_CALL_HANDLER,\n    \"contact\", contact, NULL));\n}", "path": "libempathy\\empathy-call-handler.c", "repo_name": "zenios/empathy-branch", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6448}
{"docstring": "/**\n * empathy_ft_manager_add_tp_file:\n * @ft_manager: an #EmpathyFTManager\n * @ft: an #EmpathyFT\n *\n * Adds a file transfer to the file transfer manager dialog @ft_manager.\n * The manager dialog then shows the progress and other information about\n * @ft.\n */\n", "func_signal": "void\nempathy_ft_manager_add_tp_file (EmpathyFTManager *ft_manager,\n                                EmpathyTpFile *tp_file)", "code": "{\n  TpFileTransferState state;\n\n  g_return_if_fail (EMPATHY_IS_FT_MANAGER (ft_manager));\n  g_return_if_fail (EMPATHY_IS_TP_FILE (tp_file));\n\n  state = empathy_tp_file_get_state (tp_file, NULL);\n\n  DEBUG (\"Adding a file transfer: contact=%s, filename=%s, state=%d\",\n      empathy_contact_get_name (empathy_tp_file_get_contact (tp_file)),\n      empathy_tp_file_get_filename (tp_file), state);\n\n  if (state == TP_FILE_TRANSFER_STATE_PENDING &&\n      empathy_tp_file_is_incoming (tp_file))\n    ft_manager_display_accept_dialog (ft_manager, tp_file);\n  else\n    ft_manager_add_tp_file_to_list (ft_manager, tp_file);\n}", "path": "src\\empathy-ft-manager.c", "repo_name": "zenios/empathy-branch", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6448}
{"docstring": "/**\n * empathy_ft_manager_get_dialog:\n * @ft_manager: an #EmpathyFTManager\n *\n * Returns the #GtkWidget of @ft_manager.\n *\n * Returns: the dialog\n */\n", "func_signal": "GtkWidget *\nempathy_ft_manager_get_dialog (EmpathyFTManager *ft_manager)", "code": "{\n  g_return_val_if_fail (EMPATHY_IS_FT_MANAGER (ft_manager), NULL);\n\n  ft_manager_build_ui (ft_manager);\n\n  return ft_manager->priv->window;\n}", "path": "src\\empathy-ft-manager.c", "repo_name": "zenios/empathy-branch", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6448}
{"docstring": "/*\n * ephy_spinner_set_timeout:\n * @spinner: a #EphySpinner\n * @timeout: time delay between updates to the spinner.\n *\n * Sets the timeout delay for spinner updates.\n **/\n", "func_signal": "void\nephy_spinner_set_timeout (EphySpinner *spinner,\n\t\t\t  guint timeout)", "code": "{\n\tEphySpinnerDetails *details = spinner->details;\n\n\tif (timeout != details->timeout)\n\t{\n\t\tephy_spinner_stop (spinner);\n\n\t\tdetails->timeout = timeout;\n\n\t\tif (details->spinning)\n\t\t{\n\t\t\tephy_spinner_start (spinner);\n\t\t}\n\t}\n}", "path": "src\\ephy-spinner.c", "repo_name": "zenios/empathy-branch", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6448}
{"docstring": "/**\n * empathy_irc_network_dialog_show:\n * @network: the #EmpathyIrcNetwork to configure\n * @parent: the parent of this dialog\n *\n * Display a dialog to configure a given #EmpathyIrcNetwork.\n * This function is a singleton so if a configuration dialog already\n * exists we use this one to edit the network.\n *\n * Returns: The displayed #GtkDialog\n */\n", "func_signal": "GtkWidget *\nempathy_irc_network_dialog_show (EmpathyIrcNetwork *network,\n                                 GtkWidget *parent)", "code": "{\n  static EmpathyIrcNetworkDialog *dialog = NULL;\n  GtkBuilder *gui;\n  GtkListStore *store;\n  GtkCellRenderer *renderer;\n  GtkAdjustment *adjustment;\n  GtkTreeSelection *selection;\n  GtkTreeViewColumn *column;\n  gchar *filename;\n\n  g_return_val_if_fail (network != NULL, NULL);\n\n  if (dialog != NULL)\n    {\n      change_network (dialog, network);\n      gtk_window_present (GTK_WINDOW (dialog->dialog));\n\n      return dialog->dialog;\n    }\n\n  dialog = g_slice_new0 (EmpathyIrcNetworkDialog);\n\n  dialog->network = network;\n  g_object_ref (dialog->network);\n\n  filename = empathy_file_lookup (\"empathy-account-widget-irc.ui\",\n      \"libempathy-gtk\");\n  gui = empathy_builder_get_file (filename,\n      \"irc_network_dialog\", &dialog->dialog,\n      \"button_close\", &dialog->button_close,\n      \"entry_network\", &dialog->entry_network,\n      \"combobox_charset\", &dialog->combobox_charset,\n      \"treeview_servers\", &dialog->treeview_servers,\n      \"button_add\", &dialog->button_add,\n      \"button_remove\", &dialog->button_remove,\n      \"button_up\", &dialog->button_up,\n      \"button_down\", &dialog->button_down,\n      NULL);\n  g_free (filename);\n\n  store = gtk_list_store_new (4, G_TYPE_OBJECT, G_TYPE_STRING,\n      G_TYPE_UINT, G_TYPE_BOOLEAN);\n  gtk_tree_view_set_model (GTK_TREE_VIEW (dialog->treeview_servers),\n      GTK_TREE_MODEL (store));\n  g_object_unref (store);\n\n  /* address */\n  renderer = gtk_cell_renderer_text_new ();\n  g_object_set (renderer, \"editable\", TRUE, NULL);\n  g_signal_connect (renderer, \"edited\",\n      G_CALLBACK (irc_network_dialog_address_edited_cb), dialog);\n  gtk_tree_view_insert_column_with_attributes (\n      GTK_TREE_VIEW (dialog->treeview_servers),\n      -1, _(\"Server\"), renderer, \"text\", COL_ADR,\n      NULL);\n\n  /* port */\n  adjustment = (GtkAdjustment *) gtk_adjustment_new (6667, 1, G_MAXUINT16,\n      1, 10, 0);\n  renderer = gtk_cell_renderer_spin_new ();\n  g_object_set (renderer,\n      \"editable\", TRUE,\n      \"adjustment\", adjustment,\n      NULL);\n  g_signal_connect (renderer, \"edited\",\n      G_CALLBACK (irc_network_dialog_port_edited_cb), dialog);\n  gtk_tree_view_insert_column_with_attributes (\n      GTK_TREE_VIEW (dialog->treeview_servers),\n      -1, _(\"Port\"), renderer, \"text\", COL_PORT,\n      NULL);\n  column = gtk_tree_view_get_column (GTK_TREE_VIEW (dialog->treeview_servers),\n      1);\n  gtk_tree_view_column_set_expand (column, TRUE);\n\n  /* SSL */\n  renderer = gtk_cell_renderer_toggle_new ();\n  g_object_set (renderer, \"activatable\", TRUE, NULL);\n  g_signal_connect (renderer, \"toggled\",\n      G_CALLBACK (irc_network_dialog_ssl_toggled_cb), dialog);\n  gtk_tree_view_insert_column_with_attributes (\n      GTK_TREE_VIEW (dialog->treeview_servers),\n      -1, _(\"SSL\"), renderer, \"active\", COL_SSL,\n      NULL);\n\n  selection = gtk_tree_view_get_selection (\n      GTK_TREE_VIEW (dialog->treeview_servers));\n  gtk_tree_selection_set_mode (selection, GTK_SELECTION_SINGLE);\n\n  /* charset */\n  totem_subtitle_encoding_init (GTK_COMBO_BOX (dialog->combobox_charset));\n\n  irc_network_dialog_setup (dialog);\n\n  empathy_builder_connect (gui, dialog,\n      \"irc_network_dialog\", \"destroy\", irc_network_dialog_destroy_cb,\n      \"button_close\", \"clicked\", irc_network_dialog_close_clicked_cb,\n      \"entry_network\", \"focus-out-event\", irc_network_dialog_network_focus_cb,\n      \"button_add\", \"clicked\", irc_network_dialog_button_add_clicked_cb,\n      \"button_remove\", \"clicked\", irc_network_dialog_button_remove_clicked_cb,\n      \"button_up\", \"clicked\", irc_network_dialog_button_up_clicked_cb,\n      \"button_down\", \"clicked\", irc_network_dialog_button_down_clicked_cb,\n      \"combobox_charset\", \"changed\", irc_network_dialog_combobox_charset_changed_cb,\n      NULL);\n\n  g_object_unref (gui);\n\n  g_object_add_weak_pointer (G_OBJECT (dialog->dialog),\n      (gpointer) &dialog);\n\n  g_signal_connect (selection, \"changed\",\n      G_CALLBACK (irc_network_dialog_selection_changed_cb),\n      dialog);\n\n  gtk_window_set_transient_for (GTK_WINDOW (dialog->dialog),\n      GTK_WINDOW (parent));\n  gtk_window_set_modal (GTK_WINDOW (dialog->dialog), TRUE);\n\n  irc_network_dialog_network_update_buttons (dialog);\n  gtk_widget_show_all (dialog->dialog);\n\n  return dialog->dialog;\n}", "path": "libempathy-gtk\\empathy-irc-network-dialog.c", "repo_name": "zenios/empathy-branch", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6448}
{"docstring": "/*\n * ephy_spinner_set_size:\n * @spinner: a #EphySpinner\n * @size: the size of type %GtkIconSize\n *\n * Set the size of the spinner.\n **/\n", "func_signal": "void\nephy_spinner_set_size (EphySpinner *spinner,\n\t\t       GtkIconSize size)", "code": "{\n\tif (size == GTK_ICON_SIZE_INVALID)\n\t{\n\t\tsize = GTK_ICON_SIZE_DIALOG;\n\t}\n\n\tif (size != spinner->details->size)\n\t{\n\t\tephy_spinner_unload_images (spinner);\n\n\t\tspinner->details->size = size;\n\n\t\tgtk_widget_queue_resize (GTK_WIDGET (spinner));\n\t}\n}", "path": "src\\ephy-spinner.c", "repo_name": "zenios/empathy-branch", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6448}
{"docstring": "/* Called with global lock held */\n", "func_signal": "static GstPad *\nempathy_call_window_get_audio_sink_pad (EmpathyCallWindow *self)", "code": "{\n  EmpathyCallWindowPriv *priv = GET_PRIV (self);\n  GstPad *pad;\n\n  if (priv->liveadder == NULL)\n    {\n      priv->liveadder = gst_element_factory_make (\"liveadder\", NULL);\n\n      gst_bin_add (GST_BIN (priv->pipeline), priv->liveadder);\n      gst_bin_add (GST_BIN (priv->pipeline), priv->audio_output);\n\n      gst_element_link (priv->liveadder, priv->audio_output);\n\n      gst_element_set_state (priv->liveadder, GST_STATE_PLAYING);\n      gst_element_set_state (priv->audio_output, GST_STATE_PLAYING);\n    }\n\n  pad = gst_element_get_request_pad (priv->liveadder, \"sink%d\");\n\n  return pad;\n}", "path": "src\\empathy-call-window.c", "repo_name": "zenios/empathy-branch", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6448}
{"docstring": "/* Called from the streaming thread */\n", "func_signal": "static void\nempathy_call_window_src_added_cb (EmpathyCallHandler *handler,\n  GstPad *src, guint media_type, gpointer user_data)", "code": "{\n  EmpathyCallWindow *self = EMPATHY_CALL_WINDOW (user_data);\n  EmpathyCallWindowPriv *priv = GET_PRIV (self);\n\n  GstPad *pad;\n\n  g_mutex_lock (priv->lock);\n\n  if (priv->connected == FALSE)\n    {\n      g_timer_start (priv->timer);\n      priv->timer_id = g_idle_add  (empathy_call_window_connected, self);\n      priv->connected = TRUE;\n    }\n\n  switch (media_type)\n    {\n      case TP_MEDIA_STREAM_TYPE_AUDIO:\n        pad = empathy_call_window_get_audio_sink_pad (self);\n        break;\n      case TP_MEDIA_STREAM_TYPE_VIDEO:\n        gtk_widget_hide (priv->remote_user_avatar_widget);\n        gtk_widget_show (priv->video_output);\n        pad = empathy_call_window_get_video_sink_pad (self);\n        break;\n      default:\n        g_assert_not_reached ();\n    }\n\n  gst_pad_link (src, pad);\n  gst_object_unref (pad);\n\n  g_mutex_unlock (priv->lock);\n}", "path": "src\\empathy-call-window.c", "repo_name": "zenios/empathy-branch", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6448}
{"docstring": "/* Called with global lock held */\n", "func_signal": "static GstPad *\nempathy_call_window_get_video_sink_pad (EmpathyCallWindow *self)", "code": "{\n  EmpathyCallWindowPriv *priv = GET_PRIV (self);\n  GstPad *pad;\n\n  if (priv->funnel == NULL)\n    {\n      GstElement *output;\n\n      output = empathy_video_widget_get_element (EMPATHY_VIDEO_WIDGET\n        (priv->video_output));\n\n      priv->funnel = gst_element_factory_make (\"fsfunnel\", NULL);\n\n      gst_bin_add (GST_BIN (priv->pipeline), priv->funnel);\n      gst_bin_add (GST_BIN (priv->pipeline), output);\n\n      gst_element_link (priv->funnel, output);\n\n      gst_element_set_state (priv->funnel, GST_STATE_PLAYING);\n      gst_element_set_state (output, GST_STATE_PLAYING);\n    }\n\n  pad = gst_element_get_request_pad (priv->funnel, \"sink%d\");\n\n  return pad;\n}", "path": "src\\empathy-call-window.c", "repo_name": "zenios/empathy-branch", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6448}
{"docstring": "/* Instead of specifying a width and a height, we specify only one size. That's\n   because we want a square avatar icon.  */\n", "func_signal": "static void\ninit_contact_avatar_with_size (EmpathyContact *contact, GtkWidget *image_widget,\n    gint size)", "code": "{\n\n  GdkPixbuf *pixbuf_avatar = NULL;\n\n  if (contact != NULL)\n    {\n      pixbuf_avatar = empathy_pixbuf_avatar_from_contact_scaled (contact,\n        size, size);\n    }\n\n  if (pixbuf_avatar == NULL)\n    {\n      pixbuf_avatar = empathy_pixbuf_from_icon_name_sized (\"stock_person\",\n          size);\n    }\n\n  gtk_image_set_from_pixbuf (GTK_IMAGE (image_widget), pixbuf_avatar);\n}", "path": "src\\empathy-call-window.c", "repo_name": "zenios/empathy-branch", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6448}
{"docstring": "/**\n * empathy_avatar_image_set:\n * @avatar_image: an #EmpathyAvatarImage\n * @avatar: the #EmpathyAvatar to set @avatar_image to\n *\n * Sets @avatar_image to display the avatar indicated by @avatar.\n */\n", "func_signal": "void\nempathy_avatar_image_set (EmpathyAvatarImage *avatar_image,\n\t\t\t  EmpathyAvatar      *avatar)", "code": "{\n\tEmpathyAvatarImagePriv *priv = GET_PRIV (avatar_image);\n\tGdkPixbuf              *scaled_pixbuf;\n\n\tg_return_if_fail (EMPATHY_IS_AVATAR_IMAGE (avatar_image));\n\n\tif (priv->pixbuf) {\n\t\tg_object_unref (priv->pixbuf);\n\t\tpriv->pixbuf = NULL;\n\t}\n\n\tif (avatar) {\n\t\tpriv->pixbuf = empathy_pixbuf_from_data (avatar->data, avatar->len);\n\t}\n\n\tif (!priv->pixbuf) {\n\t\tgtk_image_set_from_icon_name (GTK_IMAGE (priv->image),\n\t\t\t\t\t      \"stock_person\",\n\t\t\t\t\t      GTK_ICON_SIZE_DIALOG);\n\t\treturn;\n\t}\n\n\tscaled_pixbuf = empathy_pixbuf_scale_down_if_necessary (priv->pixbuf, MAX_SMALL);\n\tgtk_image_set_from_pixbuf (GTK_IMAGE (priv->image), scaled_pixbuf);\n\n\tif (scaled_pixbuf != priv->pixbuf) {\n\t\tgtk_widget_set_tooltip_text (GTK_WIDGET (avatar_image),\n\t\t\t\t\t     _(\"Click to enlarge\"));\n\t} else {\n\t\tgtk_widget_set_tooltip_text (GTK_WIDGET (avatar_image),\n\t\t\t\t\t     NULL);\n\t}\n\n\tg_object_unref (scaled_pixbuf);\n}", "path": "libempathy-gtk\\empathy-avatar-image.c", "repo_name": "zenios/empathy-branch", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6448}
{"docstring": "/* This function takes ownership of handles array */\n", "func_signal": "static void\ntp_contact_list_group_add (EmpathyTpContactList *list,\n\t\t\t   const gchar          *group_name,\n\t\t\t   GArray               *handles)", "code": "{\n\tEmpathyTpContactListPriv *priv = GET_PRIV (list);\n\tTpChannel                *channel;\n\tconst gchar              *names[] = {group_name, NULL};\n\n\t/* Search the channel for that group name */\n\tchannel = g_hash_table_lookup (priv->groups, group_name);\n\tif (channel) {\n\t\ttp_cli_channel_interface_group_call_add_members (channel, -1,\n\t\t\thandles, NULL, NULL, NULL, NULL, NULL);\n\t\tg_array_free (handles, TRUE);\n\t\treturn;\n\t}\n\n\t/* That group does not exist yet, we have to:\n\t * 1) Request an handle for the group name\n\t * 2) Request a channel\n\t * 3) When NewChannel is emitted, add handles in members\n\t */\n\tg_hash_table_insert (priv->add_to_group,\n\t\t\t     g_strdup (group_name),\n\t\t\t     handles);\n\ttp_cli_connection_call_request_handles (priv->connection, -1,\n\t\t\t\t\t\tTP_HANDLE_TYPE_GROUP, names,\n\t\t\t\t\t\ttp_contact_list_group_request_handles_cb,\n\t\t\t\t\t\tNULL, NULL,\n\t\t\t\t\t\tG_OBJECT (list));\n}", "path": "libempathy\\empathy-tp-contact-list.c", "repo_name": "zenios/empathy-branch", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6448}
{"docstring": "/*\n * API to save/load and parse the chatrooms file.\n */\n", "func_signal": "static gboolean\nchatroom_manager_file_save (EmpathyChatroomManager *manager)", "code": "{\n\tEmpathyChatroomManagerPriv *priv;\n\txmlDocPtr                  doc;\n\txmlNodePtr                 root;\n\tGList                     *l;\n\n\tpriv = GET_PRIV (manager);\n\n\tdoc = xmlNewDoc (\"1.0\");\n\troot = xmlNewNode (NULL, \"chatrooms\");\n\txmlDocSetRootElement (doc, root);\n\n\tfor (l = priv->chatrooms; l; l = l->next) {\n\t\tEmpathyChatroom *chatroom;\n\t\txmlNodePtr       node;\n\t\tconst gchar     *account_id;\n\n\t\tchatroom = l->data;\n\n\t\tif (!empathy_chatroom_is_favorite (chatroom)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\taccount_id = mc_account_get_unique_name (empathy_chatroom_get_account (chatroom));\n\n\t\tnode = xmlNewChild (root, NULL, \"chatroom\", NULL);\n\t\txmlNewTextChild (node, NULL, \"name\", empathy_chatroom_get_name (chatroom));\n\t\txmlNewTextChild (node, NULL, \"room\", empathy_chatroom_get_room (chatroom));\n\t\txmlNewTextChild (node, NULL, \"account\", account_id);\n\t\txmlNewTextChild (node, NULL, \"auto_connect\",\n\t\t\tempathy_chatroom_get_auto_connect (chatroom) ? \"yes\" : \"no\");\n\t}\n\n\t/* Make sure the XML is indented properly */\n\txmlIndentTreeOutput = 1;\n\n\tDEBUG (\"Saving file:'%s'\", priv->file);\n\txmlSaveFormatFileEnc (priv->file, doc, \"utf-8\", 1);\n\txmlFreeDoc (doc);\n\n\txmlCleanupParser ();\n\txmlMemoryDump ();\n\n\treturn TRUE;\n}", "path": "libempathy\\empathy-chatroom-manager.c", "repo_name": "zenios/empathy-branch", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6448}
{"docstring": "/* ================================================================= */\n", "func_signal": "static void\nnotify_science_id_cb (AwScienceView *view)", "code": "{\n  const AwScience *science;\n  const char      *name;\n\n  science = aw_science_view_get_science (view);\n  name = aw_science_get_name (science);\n\n  hildon_banner_show_information (GTK_WIDGET (view), NULL, name);\n}", "path": "src\\showcase.c", "repo_name": "hasselmm/awui", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 376}
{"docstring": "/* ================================================================= */\n", "func_signal": "AwPlanet *\naw_planet_ref (AwPlanet *planet)", "code": "{\n  g_return_val_if_fail (NULL != planet, NULL);\n  g_atomic_int_inc (&planet->ref_count);\n  return planet;\n}", "path": "libawui\\model\\planet.c", "repo_name": "hasselmm/awui", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 376}
{"docstring": "/* ================================================================= */\n", "func_signal": "AwScienceId\naw_science_get_id (const AwScience *science)", "code": "{\n  g_return_val_if_fail (NULL != science, AW_SCIENCE_INVALID);\n  return science->id;\n}", "path": "libawui\\model\\science.c", "repo_name": "hasselmm/awui", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 376}
{"docstring": "/* ================================================================= */\n", "func_signal": "static void\nlogin_dialog_cb (GtkWindow  *parent,\n                 const char *title,\n                 gpointer    user_data)", "code": "{\n  const char *username;\n  const char *password;\n  GtkWidget  *dialog;\n\n  dialog = aw_login_dialog_new (parent);\n\n  if (GTK_RESPONSE_OK == gtk_dialog_run (GTK_DIALOG (dialog)))\n    {\n      username = aw_login_dialog_get_username (AW_LOGIN_DIALOG (dialog));\n      password = aw_login_dialog_get_password (AW_LOGIN_DIALOG (dialog));\n\n      hildon_banner_show_informationf (GTK_WIDGET (parent), NULL,\n                                       \"Username: '%s'; password: '%s'\",\n                                       username, password);\n    }\n\n  gtk_widget_destroy (dialog);\n}", "path": "src\\showcase.c", "repo_name": "hasselmm/awui", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 376}
{"docstring": "/* ================================================================= */\n", "func_signal": "static void\nregister_demo (GtkListStore   *store,\n               const char     *title,\n               const char     *details,\n               AwDemoCallback  callback,\n               gpointer        user_data)", "code": "{\n  GString        *text       = g_string_new (NULL);\n  PangoAttrList  *attributes = pango_attr_list_new ();\n  PangoAttribute *attr;\n  GtkTreeIter     iter;\n\n  g_string_append (text, title);\n  g_string_append (text, \"\\n\");\n\n  attr = pango_attr_scale_new (PANGO_SCALE_SMALL);\n  attr->start_index = text->len;\n\n  pango_attr_list_insert (attributes, attr);\n\n  /* FIXME */\n  attr = pango_attr_foreground_new (0x9999, 0x9999, 0x9999);\n  attr->start_index = text->len;\n\n  pango_attr_list_insert (attributes, attr);\n\n  g_string_append (text, details);\n\n  gtk_list_store_append (store, &iter);\n  gtk_list_store_set (store, &iter,\n                      COLUMM_TITLE, title, COLUMM_CALLBACK, callback,\n                      COLUMM_USER_DATA, user_data, COLUMM_TEXT, text->str,\n                      COLUMM_ATTRIBUTES, attributes, -1);\n\n  pango_attr_list_unref (attributes);\n  g_string_free (text, TRUE);\n}", "path": "src\\showcase.c", "repo_name": "hasselmm/awui", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 376}
{"docstring": "/* ================================================================= */\n", "func_signal": "static void\nupdate_buildings (GList *planets,\n                  GList *buildings)", "code": "{\n  while (planets && buildings)\n    {\n      aw_planet_set_building_levels (planets->data,\n                                     AW_ITEM_FARM, aw_planet_get_farm_level (buildings->data),\n                                     AW_ITEM_FACTORY, aw_planet_get_factory_level (buildings->data),\n                                     AW_ITEM_CYBERNET, aw_planet_get_cybernet_level (buildings->data),\n                                     AW_ITEM_LABORATORY, aw_planet_get_laboratory_level (buildings->data),\n                                     AW_ITEM_INVALID);\n\n      aw_planet_set_production_points (planets->data, aw_planet_get_production_points (buildings->data));\n      aw_planet_set_population (planets->data, aw_planet_get_population (buildings->data));\n\n      buildings = buildings->next;\n      planets = planets->next;\n    }\n}", "path": "src\\showcase.c", "repo_name": "hasselmm/awui", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 376}
{"docstring": "/* ================================================================= */\n", "func_signal": "int\naw_star_get_id (const AwStar *star)", "code": "{\n  g_return_val_if_fail (NULL != star, -1);\n  return star->id;\n}", "path": "libawui\\model\\star.c", "repo_name": "hasselmm/awui", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 376}
{"docstring": "/* ================================================================= */\n", "func_signal": "static void\nplanet_activated_cb (AwMapView *view,\n                     AwPlanet  *planet)", "code": "{\n  hildon_banner_show_information (GTK_WIDGET (view), NULL,\n                                  aw_planet_get_name (planet));\n}", "path": "src\\showcase.c", "repo_name": "hasselmm/awui", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 376}
{"docstring": "/* ================================================================= */\n", "func_signal": "static void\nfleet_activated_cb (AwMapView *view,\n                    AwFleet   *fleet)", "code": "{\n  hildon_banner_show_informationf (GTK_WIDGET (view), NULL, \"Fleet at: %s\",\n                                   aw_fleet_get_planet_name (fleet));\n}", "path": "src\\showcase.c", "repo_name": "hasselmm/awui", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 376}
{"docstring": "/* ================================================================= */\n", "func_signal": "int\naw_star_compare_by_name (AwStar *star_a,\n                         AwStar *star_b)", "code": "{\n  const char *name_a = NULL;\n  const char *name_b = NULL;\n\n  if (star_a)\n    name_a = aw_star_get_name (star_a);\n  if (star_b)\n    name_b = aw_star_get_name (star_b);\n\n  return g_strcmp0 (name_a, name_b);\n}", "path": "libawui\\model\\star.c", "repo_name": "hasselmm/awui", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 376}
{"docstring": "/* ================================================================= */\n", "func_signal": "static void\nempty_text_cb (GtkWindow  *parent,\n               const char *title,\n               gpointer    user_data)", "code": "{\n  GtkWidget    *window, *hbox, *widget;\n  GtkListStore *store;\n\n  window = aw_window_new (title);\n\n  hbox = gtk_hbox_new (FALSE, 0);\n  gtk_container_add (GTK_CONTAINER (window), hbox);\n\n  widget = aw_tree_view_new (HILDON_UI_MODE_NORMAL);\n  gtk_box_pack_start (GTK_BOX (hbox), widget, TRUE, TRUE, 0);\n\n  widget = gtk_vseparator_new ();\n  gtk_box_pack_start (GTK_BOX (hbox), widget, FALSE, FALSE, 0);\n\n  store = gtk_list_store_new (1, G_TYPE_STRING);\n  widget = aw_tree_view_new_with_model (HILDON_UI_MODE_NORMAL,\n                                        GTK_TREE_MODEL (store));\n  gtk_box_pack_start (GTK_BOX (hbox), widget, TRUE, TRUE, 0);\n  aw_tree_view_set_empty_text (AW_TREE_VIEW (widget), \"(No Kittens)\");\n  g_object_unref (store);\n\n  gtk_widget_show_all (window);\n}", "path": "src\\showcase.c", "repo_name": "hasselmm/awui", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 376}
{"docstring": "/* ================================================================= */\n", "func_signal": "static void\nnews_activated_cb (AwNewsView *view,\n                   AwNews     *news)", "code": "{\n  char *markup, *link, **links;\n\n  links = aw_news_get_links (news);\n\n  if (links)\n    {\n      link = g_markup_escape_text (links[0], -1);\n\n      markup = g_strdup_printf (\"%s\\n<small>&lt;%s&gt;</small>\",\n                                aw_news_get_text (news), link);\n\n      g_free (link);\n    }\n  else\n    markup = g_strdup (aw_news_get_text (news));\n\n  hildon_banner_show_information_with_markup (GTK_WIDGET (view),\n                                              NULL, markup);\n\n  g_free (markup);\n}", "path": "src\\showcase.c", "repo_name": "hasselmm/awui", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 376}
{"docstring": "/* ================================================================= */\n", "func_signal": "AwScience *\naw_science_ref (AwScience *science)", "code": "{\n  g_return_val_if_fail (NULL != science, NULL);\n  g_atomic_int_inc (&science->ref_count);\n  return science;\n}", "path": "libawui\\model\\science.c", "repo_name": "hasselmm/awui", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 376}
{"docstring": "/* ================================================================= */\n", "func_signal": "AwFleet *\naw_fleet_ref (AwFleet *fleet)", "code": "{\n  g_return_val_if_fail (NULL != fleet, NULL);\n  g_atomic_int_inc (&fleet->ref_count);\n  return fleet;\n}", "path": "libawui\\model\\fleet.c", "repo_name": "hasselmm/awui", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 376}
{"docstring": "/* ================================================================= */\n", "func_signal": "int\naw_planet_compare_by_name (AwPlanet *planet_a,\n                           AwPlanet *planet_b)", "code": "{\n  const char *name_a = NULL, *tail_a;\n  const char *name_b = NULL, *tail_b;\n  char       *key_a;\n  char       *key_b;\n  int         num_a;\n  int         num_b;\n  int         cmp;\n\n  if (planet_a)\n    name_a = aw_planet_get_name (planet_a);\n  if (planet_b)\n    name_b = aw_planet_get_name (planet_b);\n\n  if (name_a == name_b)\n    return 0;\n  if (!name_a)\n    return -1;\n  if (!name_b)\n    return +1;\n\n  tail_a = strrchr (name_a, ' ');\n  tail_b = strrchr (name_b, ' ');\n\n  key_a = g_utf8_collate_key (name_a, tail_a - name_a);\n  key_b = g_utf8_collate_key (name_b, tail_b - name_b);\n\n  cmp = strcmp (key_a, key_b);\n\n  g_free (key_a);\n  g_free (key_b);\n\n  if (0 != cmp ||\n      1 != sscanf (tail_a, \"%d\", &num_a) ||\n      1 != sscanf (tail_b, \"%d\", &num_b))\n    return cmp;\n\n  if (num_a < num_b)\n    return -1;\n  if (num_a > num_b)\n    return +1;\n\n  return 0;\n}", "path": "libawui\\model\\planet.c", "repo_name": "hasselmm/awui", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 376}
{"docstring": "/* ================================================================= */\n", "func_signal": "static void\nstar_activated_cb (AwMapView *view,\n                   AwStar    *star)", "code": "{\n  char *markup;\n\n  markup = g_markup_printf_escaped (\"<b>%s</b> (%d/%d)\\n\"\n                                    \"<small>ID: %d, Level: %d</small>\",\n                                    aw_star_get_name  (star),\n                                    aw_star_get_x     (star),\n                                    aw_star_get_y     (star),\n                                    aw_star_get_id    (star),\n                                    aw_star_get_level (star));\n\n  hildon_banner_show_information_with_markup (GTK_WIDGET (view),\n                                              NULL, markup);\n\n  g_free (markup);\n}", "path": "src\\showcase.c", "repo_name": "hasselmm/awui", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 376}
{"docstring": "/* ================================================================= */\n", "func_signal": "int\naw_fleet_get_vessel_count (const AwFleet *fleet,\n                           AwItemType     type)", "code": "{\n  g_return_val_if_fail (NULL != fleet,            -1);\n  g_return_val_if_fail (aw_item_is_vessel (type), -1);\n  return fleet->vessels[type - AW_ITEM_VESSELS_FIRST];\n}", "path": "libawui\\model\\fleet.c", "repo_name": "hasselmm/awui", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 376}
{"docstring": "/* ================================================================= */\n", "func_signal": "int\naw_planet_get_population (const AwPlanet *planet)", "code": "{\n  g_return_val_if_fail (NULL != planet, -1);\n  return planet->population;\n}", "path": "libawui\\model\\planet.c", "repo_name": "hasselmm/awui", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 376}
{"docstring": "/* ================================================================= */\n", "func_signal": "AwStar *\naw_star_ref (AwStar *star)", "code": "{\n  g_return_val_if_fail (NULL != star, NULL);\n  g_atomic_int_inc (&star->ref_count);\n  return star;\n}", "path": "libawui\\model\\star.c", "repo_name": "hasselmm/awui", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 376}
{"docstring": "/* ================================================================= */\n/* === Methods for finishing async calls                         === */\n/* ================================================================= */\n", "func_signal": "static SoupMessage *\naw_session_finish_message (AwSession            *session,\n                           GAsyncResult         *result,\n                           gpointer              source_tag,\n                           GError              **error)", "code": "{\n  SoupMessage        *message = NULL;\n  GSimpleAsyncResult *simple_result;\n\n  g_return_val_if_fail (AW_IS_SESSION (session),           FALSE);\n  g_return_val_if_fail (G_IS_SIMPLE_ASYNC_RESULT (result), FALSE);\n\n  simple_result = G_SIMPLE_ASYNC_RESULT (result);\n\n  g_return_val_if_fail\n    (g_simple_async_result_get_source_tag (simple_result) ==\n     source_tag, FALSE);\n\n  if (!g_simple_async_result_propagate_error (simple_result, error))\n    message = g_simple_async_result_get_op_res_gpointer (simple_result);\n\n  return message;\n}", "path": "libawui\\web\\session.c", "repo_name": "hasselmm/awui", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 376}
{"docstring": "/* Remove \"/../\", \"//\", \"/./\" parts from path.\n *\n * /blah/..         gets  /\n * /blah/../foo     gets  /foo\n * /abc/./xyz       gets  /abc/xyz\n * /abc//xyz        gets  /abc/xyz\n *\n * NOTE: src and dest can point to the same buffer, in which case,\n *       the operation is performed in-place.\n */\n", "func_signal": "int buffer_path_simplify(buffer *dest, buffer *src)", "code": "{\n\tint toklen;\n\tchar c, pre1;\n\tchar *start, *slash, *walk, *out;\n\tunsigned short pre;\n\n\tif (src == NULL || src->ptr == NULL || dest == NULL)\n\t\treturn -1;\n\n\tif (src == dest)\n\t\tbuffer_prepare_append(dest, 1);\n\telse\n\t\tbuffer_prepare_copy(dest, src->used + 1);\n\n\twalk  = src->ptr;\n\tstart = dest->ptr;\n\tout   = dest->ptr;\n\tslash = dest->ptr;\n\n\n#if defined(__WIN32) || defined(__CYGWIN__)\n\t/* cygwin is treating \\ and / the same, so we have to that too\n\t */\n\n\tfor (walk = src->ptr; *walk; walk++) {\n\t\tif (*walk == '\\\\') *walk = '/';\n\t}\n\twalk = src->ptr;\n#endif\n\n\twhile (*walk == ' ') {\n\t\twalk++;\n\t}\n\n\tpre1 = *(walk++);\n\tc    = *(walk++);\n\tpre  = pre1;\n\tif (pre1 != '/') {\n\t\tpre = ('/' << 8) | pre1;\n\t\t*(out++) = '/';\n\t}\n\t*(out++) = pre1;\n\n\tif (pre1 == '\\0') {\n\t\tdest->used = (out - start) + 1;\n\t\treturn 0;\n\t}\n\n\twhile (1) {\n\t\tif (c == '/' || c == '\\0') {\n\t\t\ttoklen = out - slash;\n\t\t\tif (toklen == 3 && pre == (('.' << 8) | '.')) {\n\t\t\t\tout = slash;\n\t\t\t\tif (out > start) {\n\t\t\t\t\tout--;\n\t\t\t\t\twhile (out > start && *out != '/') {\n\t\t\t\t\t\tout--;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (c == '\\0')\n\t\t\t\t\tout++;\n\t\t\t} else if (toklen == 1 || pre == (('/' << 8) | '.')) {\n\t\t\t\tout = slash;\n\t\t\t\tif (c == '\\0')\n\t\t\t\t\tout++;\n\t\t\t}\n\n\t\t\tslash = out;\n\t\t}\n\n\t\tif (c == '\\0')\n\t\t\tbreak;\n\n\t\tpre1 = c;\n\t\tpre  = (pre << 8) | pre1;\n\t\tc    = *walk;\n\t\t*out = pre1;\n\n\t\tout++;\n\t\twalk++;\n\t}\n\n\t*out = '\\0';\n\tdest->used = (out - start) + 1;\n\n\treturn 0;\n}", "path": "src\\lighttpd\\src\\buffer.c", "repo_name": "presidentbeef/sqwee", "stars": 1, "license": "None", "language": "c", "size": 6803}
{"docstring": "/* init the plugin data */\n", "func_signal": "INIT_FUNC(mod_alias_init)", "code": "{\n\tplugin_data *p;\n\n\tp = calloc(1, sizeof(*p));\n\n\n\n\treturn p;\n}", "path": "src\\lighttpd\\src\\mod_alias.c", "repo_name": "presidentbeef/sqwee", "stars": 1, "license": "None", "language": "c", "size": 6803}
{"docstring": "/**\n * init the buffer\n *\n */\n", "func_signal": "buffer_array* buffer_array_init(void)", "code": "{\n\tbuffer_array *b;\n\n\tb = malloc(sizeof(*b));\n\n\tassert(b);\n\tb->ptr = NULL;\n\tb->size = 0;\n\tb->used = 0;\n\n\treturn b;\n}", "path": "src\\lighttpd\\src\\buffer.c", "repo_name": "presidentbeef/sqwee", "stars": 1, "license": "None", "language": "c", "size": 6803}
{"docstring": "/* detroy the plugin data */\n", "func_signal": "FREE_FUNC(mod_alias_free)", "code": "{\n\tplugin_data *p = p_d;\n\n\tif (!p) return HANDLER_GO_ON;\n\n\tif (p->config_storage) {\n\t\tsize_t i;\n\n\t\tfor (i = 0; i < srv->config_context->used; i++) {\n\t\t\tplugin_config *s = p->config_storage[i];\n\n\t\t\tif(!s) continue;\n\n\t\t\tarray_free(s->alias);\n\n\t\t\tfree(s);\n\t\t}\n\t\tfree(p->config_storage);\n\t}\n\n\tfree(p);\n\n\treturn HANDLER_GO_ON;\n}", "path": "src\\lighttpd\\src\\mod_alias.c", "repo_name": "presidentbeef/sqwee", "stars": 1, "license": "None", "language": "c", "size": 6803}
{"docstring": "/* converts hex char (0-9, A-Z, a-z) to decimal.\n * returns 0xFF on invalid input.\n */\n", "func_signal": "char hex2int(unsigned char hex)", "code": "{\n\thex = hex - '0';\n\tif (hex > 9) {\n\t\thex = (hex + '0' - 1) | 0x20;\n\t\thex = hex - 'a' + 11;\n\t}\n\tif (hex > 15)\n\t\thex = 0xFF;\n\n\treturn hex;\n}", "path": "src\\lighttpd\\src\\buffer.c", "repo_name": "presidentbeef/sqwee", "stars": 1, "license": "None", "language": "c", "size": 6803}
{"docstring": "/* detroy the plugin data */\n", "func_signal": "FREE_FUNC(mod_setenv_free)", "code": "{\n\tplugin_data *p = p_d;\n\n\tUNUSED(srv);\n\n\tif (!p) return HANDLER_GO_ON;\n\n\tif (p->config_storage) {\n\t\tsize_t i;\n\t\tfor (i = 0; i < srv->config_context->used; i++) {\n\t\t\tplugin_config *s = p->config_storage[i];\n\n\t\t\tarray_free(s->request_header);\n\t\t\tarray_free(s->response_header);\n\t\t\tarray_free(s->environment);\n\n\t\t\tfree(s);\n\t\t}\n\t\tfree(p->config_storage);\n\t}\n\n\tfree(p);\n\n\treturn HANDLER_GO_ON;\n}", "path": "src\\lighttpd\\src\\mod_setenv.c", "repo_name": "presidentbeef/sqwee", "stars": 1, "license": "None", "language": "c", "size": 6803}
{"docstring": "/**\n * append a string to the end of the buffer\n *\n * the resulting buffer is terminated with a '\\0'\n * s is treated as a un-terminated string (a \\0 is handled a normal character)\n *\n * @param b a buffer\n * @param s the string\n * @param s_len size of the string (without the terminating \\0)\n */\n", "func_signal": "int buffer_append_string_len(buffer *b, const char *s, size_t s_len)", "code": "{\n\tif (!s || !b) return -1;\n\tif (s_len == 0) return 0;\n\n\tbuffer_prepare_append(b, s_len + 1);\n\tif (b->used == 0)\n\t\tb->used++;\n\n\tmemcpy(b->ptr + b->used - 1, s, s_len);\n\tb->used += s_len;\n\tb->ptr[b->used - 1] = '\\0';\n\n\treturn 0;\n}", "path": "src\\lighttpd\\src\\buffer.c", "repo_name": "presidentbeef/sqwee", "stars": 1, "license": "None", "language": "c", "size": 6803}
{"docstring": "/* init the plugin data */\n", "func_signal": "INIT_FUNC(mod_setenv_init)", "code": "{\n\tplugin_data *p;\n\n\tp = calloc(1, sizeof(*p));\n\n\treturn p;\n}", "path": "src\\lighttpd\\src\\mod_setenv.c", "repo_name": "presidentbeef/sqwee", "stars": 1, "license": "None", "language": "c", "size": 6803}
{"docstring": "/**\n * init the buffer\n *\n */\n", "func_signal": "buffer* buffer_init(void)", "code": "{\n\tbuffer *b;\n\n\tb = malloc(sizeof(*b));\n\tassert(b);\n\n\tb->ptr = NULL;\n\tb->size = 0;\n\tb->used = 0;\n\n\treturn b;\n}", "path": "src\\lighttpd\\src\\buffer.c", "repo_name": "presidentbeef/sqwee", "stars": 1, "license": "None", "language": "c", "size": 6803}
{"docstring": "/* handle plugin config and check values */\n", "func_signal": "SETDEFAULTS_FUNC(mod_setenv_set_defaults)", "code": "{\n\tplugin_data *p = p_d;\n\tsize_t i = 0;\n\n\tconfig_values_t cv[] = {\n\t\t{ \"setenv.add-request-header\",  NULL, T_CONFIG_ARRAY, T_CONFIG_SCOPE_CONNECTION },       /* 0 */\n\t\t{ \"setenv.add-response-header\", NULL, T_CONFIG_ARRAY, T_CONFIG_SCOPE_CONNECTION },       /* 1 */\n\t\t{ \"setenv.add-environment\",     NULL, T_CONFIG_ARRAY, T_CONFIG_SCOPE_CONNECTION },       /* 2 */\n\t\t{ NULL,                         NULL, T_CONFIG_UNSET, T_CONFIG_SCOPE_UNSET }\n\t};\n\n\tif (!p) return HANDLER_ERROR;\n\n\tp->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));\n\n\tfor (i = 0; i < srv->config_context->used; i++) {\n\t\tplugin_config *s;\n\n\t\ts = calloc(1, sizeof(plugin_config));\n\t\ts->request_header   = array_init();\n\t\ts->response_header  = array_init();\n\t\ts->environment      = array_init();\n\n\t\tcv[0].destination = s->request_header;\n\t\tcv[1].destination = s->response_header;\n\t\tcv[2].destination = s->environment;\n\n\t\tp->config_storage[i] = s;\n\n\t\tif (0 != config_insert_values_global(srv, ((data_config *)srv->config_context->data[i])->value, cv)) {\n\t\t\treturn HANDLER_ERROR;\n\t\t}\n\t}\n\n\treturn HANDLER_GO_ON;\n}", "path": "src\\lighttpd\\src\\mod_setenv.c", "repo_name": "presidentbeef/sqwee", "stars": 1, "license": "None", "language": "c", "size": 6803}
{"docstring": "/**\n *\n * increase the internal buffer (if neccessary) to append another 'size' byte\n * ->used isn't changed\n *\n */\n", "func_signal": "int buffer_prepare_append(buffer *b, size_t size)", "code": "{\n\tif (!b) return -1;\n\n\tif (0 == b->size) {\n\t\tb->size = size;\n\n\t\t/* always allocate a multiply of BUFFER_PIECE_SIZE */\n\t\tb->size += BUFFER_PIECE_SIZE - (b->size % BUFFER_PIECE_SIZE);\n\n\t\tb->ptr = malloc(b->size);\n\t\tb->used = 0;\n\t\tassert(b->ptr);\n\t} else if (b->used + size > b->size) {\n\t\tb->size += size;\n\n\t\t/* always allocate a multiply of BUFFER_PIECE_SIZE */\n\t\tb->size += BUFFER_PIECE_SIZE - (b->size % BUFFER_PIECE_SIZE);\n\n\t\tb->ptr = realloc(b->ptr, b->size);\n\t\tassert(b->ptr);\n\t}\n\treturn 0;\n}", "path": "src\\lighttpd\\src\\buffer.c", "repo_name": "presidentbeef/sqwee", "stars": 1, "license": "None", "language": "c", "size": 6803}
{"docstring": "/**\n * check if the rightmost bytes of the string are equal.\n *\n *\n */\n", "func_signal": "int buffer_is_equal_right_len(buffer *b1, buffer *b2, size_t len)", "code": "{\n\t/* no, len -> equal */\n\tif (len == 0) return 1;\n\n\t/* len > 0, but empty buffers -> not equal */\n\tif (b1->used == 0 || b2->used == 0) return 0;\n\n\t/* buffers too small -> not equal */\n\tif (b1->used - 1 < len || b1->used - 1 < len) return 0;\n\n\tif (0 == strncmp(b1->ptr + b1->used - 1 - len,\n\t\t\t b2->ptr + b2->used - 1 - len, len)) {\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}", "path": "src\\lighttpd\\src\\buffer.c", "repo_name": "presidentbeef/sqwee", "stars": 1, "license": "None", "language": "c", "size": 6803}
{"docstring": "/* simple-assumption:\n *\n * most parts are equal and doing a case conversion needs time\n *\n */\n", "func_signal": "int buffer_caseless_compare(const char *a, size_t a_len, const char *b, size_t b_len)", "code": "{\n\tsize_t ndx = 0, max_ndx;\n\tsize_t *al, *bl;\n\tsize_t mask = sizeof(*al) - 1;\n\n\tal = (size_t *)a;\n\tbl = (size_t *)b;\n\n\t/* is the alignment correct ? */\n\tif ( ((size_t)al & mask) == 0 &&\n\t     ((size_t)bl & mask) == 0 ) {\n\n\t\tmax_ndx = ((a_len < b_len) ? a_len : b_len) & ~mask;\n\n\t\tfor (; ndx < max_ndx; ndx += sizeof(*al)) {\n\t\t\tif (*al != *bl) break;\n\t\t\tal++; bl++;\n\n\t\t}\n\n\t}\n\n\ta = (char *)al;\n\tb = (char *)bl;\n\n\tmax_ndx = ((a_len < b_len) ? a_len : b_len);\n\n\tfor (; ndx < max_ndx; ndx++) {\n\t\tchar a1 = *a++, b1 = *b++;\n\n\t\tif (a1 != b1) {\n\t\t\tif ((a1 >= 'A' && a1 <= 'Z') && (b1 >= 'a' && b1 <= 'z'))\n\t\t\t\ta1 |= 32;\n\t\t\telse if ((a1 >= 'a' && a1 <= 'z') && (b1 >= 'A' && b1 <= 'Z'))\n\t\t\t\tb1 |= 32;\n\t\t\tif ((a1 - b1) != 0) return (a1 - b1);\n\n\t\t}\n\t}\n\n\t/* all chars are the same, and the length match too\n\t *\n\t * they are the same */\n\tif (a_len == b_len) return 0;\n\n\t/* if a is shorter then b, then b is larger */\n\treturn (a_len - b_len);\n}", "path": "src\\lighttpd\\src\\buffer.c", "repo_name": "presidentbeef/sqwee", "stars": 1, "license": "None", "language": "c", "size": 6803}
{"docstring": "/* handle plugin config and check values */\n", "func_signal": "SETDEFAULTS_FUNC(mod_alias_set_defaults)", "code": "{\n\tplugin_data *p = p_d;\n\tsize_t i = 0;\n\n\tconfig_values_t cv[] = {\n\t\t{ \"alias.url\",                  NULL, T_CONFIG_ARRAY, T_CONFIG_SCOPE_CONNECTION },       /* 0 */\n\t\t{ NULL,                         NULL, T_CONFIG_UNSET,  T_CONFIG_SCOPE_UNSET }\n\t};\n\n\tif (!p) return HANDLER_ERROR;\n\n\tp->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));\n\n\tfor (i = 0; i < srv->config_context->used; i++) {\n\t\tplugin_config *s;\n\n\t\ts = calloc(1, sizeof(plugin_config));\n\t\ts->alias = array_init();\n\t\tcv[0].destination = s->alias;\n\n\t\tp->config_storage[i] = s;\n\n\t\tif (0 != config_insert_values_global(srv, ((data_config *)srv->config_context->data[i])->value, cv)) {\n\t\t\treturn HANDLER_ERROR;\n\t\t}\n\t\tif (s->alias->used >= 2) {\n\t\t\tconst array *a = s->alias;\n\t\t\tsize_t j, k;\n\n\t\t\tfor (j = 0; j < a->used; j ++) {\n\t\t\t\tconst buffer *prefix = a->data[a->sorted[j]]->key;\n\t\t\t\tfor (k = j + 1; k < a->used; k ++) {\n\t\t\t\t\tconst buffer *key = a->data[a->sorted[k]]->key;\n\n\t\t\t\t\tif (key->used < prefix->used) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (memcmp(key->ptr, prefix->ptr, prefix->used - 1) != 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t/* ok, they have same prefix. check position */\n\t\t\t\t\tif (a->sorted[j] < a->sorted[k]) {\n\t\t\t\t\t\tlog_error_write(srv, __FILE__, __LINE__, \"SBSBS\",\n\t\t\t\t\t\t\t\"url.alias: `\", key, \"' will never match as `\", prefix, \"' matched first\");\n\t\t\t\t\t\treturn HANDLER_ERROR;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn HANDLER_GO_ON;\n}", "path": "src\\lighttpd\\src\\mod_alias.c", "repo_name": "presidentbeef/sqwee", "stars": 1, "license": "None", "language": "c", "size": 6803}
{"docstring": "/**\n * check if two buffer contain the same data\n *\n * HISTORY: this function was pretty much optimized, but didn't handled\n * alignment properly.\n */\n", "func_signal": "int buffer_is_equal(buffer *a, buffer *b)", "code": "{\n\tif (a->used != b->used) return 0;\n\tif (a->used == 0) return 1;\n\n\treturn (0 == strcmp(a->ptr, b->ptr));\n}", "path": "src\\lighttpd\\src\\buffer.c", "repo_name": "presidentbeef/sqwee", "stars": 1, "license": "None", "language": "c", "size": 6803}
{"docstring": "/* handle plugin config and check values */\n", "func_signal": "SETDEFAULTS_FUNC(mod_userdir_set_defaults)", "code": "{\n\tplugin_data *p = p_d;\n\tsize_t i;\n\n\tconfig_values_t cv[] = {\n\t\t{ \"userdir.path\",               NULL, T_CONFIG_STRING, T_CONFIG_SCOPE_CONNECTION },       /* 0 */\n\t\t{ \"userdir.exclude-user\",       NULL, T_CONFIG_ARRAY,  T_CONFIG_SCOPE_CONNECTION },       /* 1 */\n\t\t{ \"userdir.include-user\",       NULL, T_CONFIG_ARRAY,  T_CONFIG_SCOPE_CONNECTION },       /* 2 */\n\t\t{ \"userdir.basepath\",           NULL, T_CONFIG_STRING, T_CONFIG_SCOPE_CONNECTION },       /* 3 */\n\t\t{ \"userdir.letterhomes\",\tNULL, T_CONFIG_BOOLEAN,T_CONFIG_SCOPE_CONNECTION },\t  /* 4 */\n\t\t{ NULL,                         NULL, T_CONFIG_UNSET,  T_CONFIG_SCOPE_UNSET }\n\t};\n\n\tif (!p) return HANDLER_ERROR;\n\n\tp->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));\n\n\tfor (i = 0; i < srv->config_context->used; i++) {\n\t\tplugin_config *s;\n\n\t\ts = calloc(1, sizeof(plugin_config));\n\t\ts->exclude_user = array_init();\n\t\ts->include_user = array_init();\n\t\ts->path = buffer_init();\n\t\ts->basepath = buffer_init();\n\t\ts->letterhomes = 0;\n\n\t\tcv[0].destination = s->path;\n\t\tcv[1].destination = s->exclude_user;\n\t\tcv[2].destination = s->include_user;\n\t\tcv[3].destination = s->basepath;\n\t\tcv[4].destination = &(s->letterhomes);\n\n\t\tp->config_storage[i] = s;\n\n\t\tif (0 != config_insert_values_global(srv, ((data_config *)srv->config_context->data[i])->value, cv)) {\n\t\t\treturn HANDLER_ERROR;\n\t\t}\n\t}\n\n\treturn HANDLER_GO_ON;\n}", "path": "src\\lighttpd\\src\\mod_userdir.c", "repo_name": "presidentbeef/sqwee", "stars": 1, "license": "None", "language": "c", "size": 6803}
{"docstring": "/* init the plugin data */\n", "func_signal": "INIT_FUNC(mod_userdir_init)", "code": "{\n\tplugin_data *p;\n\n\tp = calloc(1, sizeof(*p));\n\n\tp->username = buffer_init();\n\tp->temp_path = buffer_init();\n\n\treturn p;\n}", "path": "src\\lighttpd\\src\\mod_userdir.c", "repo_name": "presidentbeef/sqwee", "stars": 1, "license": "None", "language": "c", "size": 6803}
{"docstring": "/**\n * free the buffer_array\n *\n */\n", "func_signal": "void buffer_array_free(buffer_array *b)", "code": "{\n\tsize_t i;\n\tif (!b) return;\n\n\tfor (i = 0; i < b->size; i++) {\n\t\tif (b->ptr[i]) buffer_free(b->ptr[i]);\n\t}\n\tfree(b->ptr);\n\tfree(b);\n}", "path": "src\\lighttpd\\src\\buffer.c", "repo_name": "presidentbeef/sqwee", "stars": 1, "license": "None", "language": "c", "size": 6803}
{"docstring": "/**\n * free the buffer\n *\n */\n", "func_signal": "void buffer_free(buffer *b)", "code": "{\n\tif (!b) return;\n\n\tfree(b->ptr);\n\tfree(b);\n}", "path": "src\\lighttpd\\src\\buffer.c", "repo_name": "presidentbeef/sqwee", "stars": 1, "license": "None", "language": "c", "size": 6803}
{"docstring": "/* detroy the plugin data */\n", "func_signal": "FREE_FUNC(mod_userdir_free)", "code": "{\n\tplugin_data *p = p_d;\n\n\tif (!p) return HANDLER_GO_ON;\n\n\tif (p->config_storage) {\n\t\tsize_t i;\n\n\t\tfor (i = 0; i < srv->config_context->used; i++) {\n\t\t\tplugin_config *s = p->config_storage[i];\n\n\t\t\tarray_free(s->include_user);\n\t\t\tarray_free(s->exclude_user);\n\t\t\tbuffer_free(s->path);\n\t\t\tbuffer_free(s->basepath);\n\n\t\t\tfree(s);\n\t\t}\n\t\tfree(p->config_storage);\n\t}\n\n\tbuffer_free(p->username);\n\tbuffer_free(p->temp_path);\n\n\tfree(p);\n\n\treturn HANDLER_GO_ON;\n}", "path": "src\\lighttpd\\src\\mod_userdir.c", "repo_name": "presidentbeef/sqwee", "stars": 1, "license": "None", "language": "c", "size": 6803}
{"docstring": "/**\n * Clip the drawing area to an rectangle.\n * @param x The x-coordinate of the rectangle.\n * @param y The y-coordinate of the rectangle.\n * @param width The width of the rectangle.\n * @param height The height of the rectangle.\n */\n", "func_signal": "void GRRLIB_ClipDrawing( int x, int y, int width, int height )", "code": "{\n    GX_SetClipMode( GX_CLIP_ENABLE );\n    GX_SetScissor( x, y, width, height );\n}", "path": "GRRLIB\\GRRLIB\\GRRLIB.c", "repo_name": "Megazig/CustomSystemMenu", "stars": 1, "license": "None", "language": "c", "size": 1956}
{"docstring": "/**\n * Initialize a tile set.\n * @param tex The texture to initialize.\n * @param tilew Width of the tile.\n * @param tileh Height of the tile.\n * @param tilestart Offset for starting position (Used in fonts).\n */\n", "func_signal": "void GRRLIB_InitTileSet(struct GRRLIB_texImg *tex, unsigned int tilew, unsigned int tileh, unsigned int tilestart)", "code": "{\n    tex->tilew = tilew;\n    tex->tileh = tileh;\n    if (tilew) // Avoid division by zero\n        tex->nbtilew = tex->w / tilew;\n    if (tileh) // Avoid division by zero\n        tex->nbtileh = tex->h / tileh;\n    tex->tilestart = tilestart;\n    tex->tiledtex = true;\n    GRRLIB_SetHandle( tex, 0, 0 );\n}", "path": "GRRLIB\\GRRLIB\\GRRLIB.c", "repo_name": "Megazig/CustomSystemMenu", "stars": 1, "license": "None", "language": "c", "size": 1956}
{"docstring": "/**\n * Flip texture vertical.\n * @see GRRLIB_FlushTex\n * @param texsrc The texture source.\n * @param texdest The texture destination.\n */\n", "func_signal": "void GRRLIB_BMFX_FlipV(struct GRRLIB_texImg *texsrc, GRRLIB_texImg *texdest)", "code": "{\n    unsigned int x, y, texHeight = texsrc->h - 1;\n\n    for (y = 0; y < texsrc->h; y++) {\n        for (x = 0; x < texsrc->w; x++) {\n            GRRLIB_SetPixelTotexImg(x, texHeight - y, texdest,\n                GRRLIB_GetPixelFromtexImg(x, y, texsrc));\n        }\n    }\n}", "path": "GRRLIB\\GRRLIB\\GRRLIB.c", "repo_name": "Megazig/CustomSystemMenu", "stars": 1, "license": "None", "language": "c", "size": 1956}
{"docstring": "/**\n * Set a texture's X and Y handles. e.g. for rotation.\n * @param tex The texture to set the handle on.\n * @param x The x-coordinate of the handle.\n * @param y The y-coordinate of the handle.\n */\n", "func_signal": "void GRRLIB_SetHandle( struct GRRLIB_texImg *tex, int x, int y )", "code": "{\n    if (tex->tiledtex) {\n        tex->handlex = -(((int)tex->tilew)/2) + x;\n        tex->handley = -(((int)tex->tileh)/2) + y;\n    } else {\n        tex->handlex = -(((int)tex->w)/2) + x;\n        tex->handley = -(((int)tex->h)/2) + y;\n    }\n}", "path": "GRRLIB\\GRRLIB\\GRRLIB.c", "repo_name": "Megazig/CustomSystemMenu", "stars": 1, "license": "None", "language": "c", "size": 1956}
{"docstring": "/****************************************************************************\n* get_fattime\n*\n* bit31:25\n*    Year from 1980 (0..127)\n* bit24:21\n*    Month (1..12)\n* bit20:16\n*    Date (1..31)\n* bit15:11\n*    Hour (0..23)\n* bit10:5\n*    Minute (0..59)\n* bit4:0\n*    Second/2 (0..29) \n*\n* I confess this is a mess - but it works!\n****************************************************************************/\n", "func_signal": "u32 get_fattime( void )", "code": "{\n  time_t rtc;\n  char realtime[128];\n  int year, month, day, hour, minute, second;\n  char mth[4];\n  char *p;\n  char *months = \"JanFebMarAprMayJunJulAugSepOctNovDec\";\n  u32 ret = 0;\n\n  rtc = time(NULL);\n  strcpy(realtime, ctime(&rtc));\n\n  /* ctime returns dates formatted to ASCII thus,\n     DDD MMM 000 HH:MM:SS CCYY\n   */\n  year = atoi( realtime + 20 );\n  day = atoi( realtime + 7 );\n  hour = atoi( realtime + 11 );\n  minute = atoi( realtime + 14 );\n  second = atoi( realtime + 17 );\n\n  memcpy(mth, realtime + 4, 3);\n  mth[3] = 0;\n  p = strstr(months, mth);\n  if ( !p )\n    month = 1;\n  else\n    month = (( p - months ) / 3 ) + 1;\n\n  /* Convert to DOS time */\n  /* YYYYYYY MMMM DDDDD HHHHH MMMMMM SSSSS */\n  /* 1098765 4321 09876 54321 098765 43210 */\n\n  year = year - 1980;\n  ret = ( year & 0x7f ) << 25;\n  ret |= ( month << 21 );\n  ret |= ( day << 16 );\n  ret |= ( hour << 11 );\n  ret |= ( minute << 5 );\n  ret |= ( second & 0x1f );\n\n  return ret;\n\n}", "path": "TFF\\diskio.c", "repo_name": "Megazig/CustomSystemMenu", "stars": 1, "license": "None", "language": "c", "size": 1956}
{"docstring": "/****************************************************************************\n* disk_status\n****************************************************************************/\n", "func_signal": "DSTATUS disk_status ( BYTE drv )", "code": "{\n  int res;\n\n  if ( drv != 0 && drv != 1 )\n    return RES_PARERR;\t\t/* Must be 0 or 1 */\n\n  res = card_readStatus( (int) drv );\n\n  if ( res == CARDIO_ERROR_READY )\n    return RES_OK;\n\n  return RES_NOTRDY;\n}", "path": "TFF\\diskio.c", "repo_name": "Megazig/CustomSystemMenu", "stars": 1, "license": "None", "language": "c", "size": 1956}
{"docstring": "/**\n * Load a texture from a buffer.\n * Take care to have the JPG finnish with 0xFF 0xD9!!\n * @author DrTwox\n * @param my_jpg The JPEG buffer to load.\n * @return A GRRLIB_texImg structure filled with image informations.\n */\n", "func_signal": "GRRLIB_texImg *GRRLIB_LoadTextureJPG(const unsigned char my_jpg[])", "code": "{\n    struct jpeg_decompress_struct cinfo;\n    struct jpeg_error_mgr jerr;\n    GRRLIB_texImg *my_texture = (struct GRRLIB_texImg *)calloc(1, sizeof(GRRLIB_texImg));\n    int n = 0;\n    unsigned int i;\n\n    if(my_texture == NULL)\n        return NULL;\n\n    if ((my_jpg[0]==0xFF) && (my_jpg[1]==0xD8) && (my_jpg[2]==0xFF)) {\n        while(true) {\n            if ((my_jpg[n]==0xFF) && (my_jpg[n+1]==0xD9))\n                break;\n            n++;\n        }\n        n+=2;\n    }\n\n    jpeg_create_decompress(&cinfo);\n    cinfo.err = jpeg_std_error(&jerr);\n    cinfo.progress = NULL;\n    jpeg_memory_src(&cinfo, my_jpg, n);\n    jpeg_read_header(&cinfo, TRUE);\n    jpeg_start_decompress(&cinfo);\n    unsigned char *tempBuffer = (unsigned char*) malloc(cinfo.output_width * cinfo.output_height * cinfo.num_components);\n    JSAMPROW row_pointer[1];\n    row_pointer[0] = (unsigned char*) malloc(cinfo.output_width * cinfo.num_components);\n    size_t location = 0;\n    while (cinfo.output_scanline < cinfo.output_height) {\n        jpeg_read_scanlines(&cinfo, row_pointer, 1);\n        for (i = 0; i < cinfo.image_width * cinfo.num_components; i++) {\n            /* Put the decoded scanline into the tempBuffer */\n            tempBuffer[ location++ ] = row_pointer[0][i];\n        }\n    }\n\n    /* Create a buffer to hold the final texture */\n    my_texture->data = memalign(32, cinfo.output_width * cinfo.output_height * 4);\n    RawTo4x4RGBA(tempBuffer, my_texture->data, cinfo.output_width, cinfo.output_height);\n\n    /* Done - Do cleanup and release allocated memory */\n    jpeg_finish_decompress(&cinfo);\n    jpeg_destroy_decompress(&cinfo);\n    free(row_pointer[0]);\n    free(tempBuffer);\n\n    my_texture->w = cinfo.output_width;\n    my_texture->h = cinfo.output_height;\n    GRRLIB_SetHandle( my_texture, 0, 0 );\n    GRRLIB_FlushTex( my_texture );\n    return my_texture;\n}", "path": "GRRLIB\\GRRLIB\\GRRLIB.c", "repo_name": "Megazig/CustomSystemMenu", "stars": 1, "license": "None", "language": "c", "size": 1956}
{"docstring": "/**\n * Load a texture from a buffer.\n * @param my_img The JPEG or PNG buffer to load.\n * @return A GRRLIB_texImg structure filled with image informations.\n */\n", "func_signal": "GRRLIB_texImg *GRRLIB_LoadTexture(const unsigned char my_img[])", "code": "{\n    if (my_img[0]==0xFF && my_img[1]==0xD8 && my_img[2]==0xFF) {\n        return (GRRLIB_LoadTextureJPG(my_img));\n    }\n    else {\n        return (GRRLIB_LoadTexturePNG(my_img));\n    }\n}", "path": "GRRLIB\\GRRLIB\\GRRLIB.c", "repo_name": "Megazig/CustomSystemMenu", "stars": 1, "license": "None", "language": "c", "size": 1956}
{"docstring": "/**\n * Initialize GRRLIB. Call this at the beginning your code.\n * @see GRRLIB_Exit\n */\n", "func_signal": "void GRRLIB_Init()", "code": "{\n    f32 yscale;\n    u32 xfbHeight;\n    Mtx44 perspective;\n\n    VIDEO_Init();\n    rmode = VIDEO_GetPreferredMode(NULL);\n    if (rmode == NULL)\n        return;\n\n\t// Video Mode Correction\n    switch (rmode->viTVMode) {\n    \tcase VI_DEBUG_PAL:\t// PAL 50hz 576i\n    \t\trmode = &TVPal574IntDfScale;\n    \t\tbreak;\n    }\n\n    // Widescreen patch by CashMan's Productions (http://www.CashMan-Productions.fr.nf)\n    if (CONF_GetAspectRatio() == CONF_ASPECT_16_9) {\n        rmode->viWidth = 678;\n        rmode->viXOrigin = (VI_MAX_WIDTH_NTSC - 678)/2;\n    }\n\n    VIDEO_Configure(rmode);\n    xfb[0] = (u32 *)MEM_K0_TO_K1(SYS_AllocateFramebuffer(rmode));\n    xfb[1] = (u32 *)MEM_K0_TO_K1(SYS_AllocateFramebuffer(rmode));\n    if (xfb[0] == NULL || xfb[1] == NULL)\n        return;\n\n    VIDEO_SetNextFramebuffer(xfb[fb]);\n    VIDEO_SetBlack(true);\n    VIDEO_Flush();\n    VIDEO_WaitVSync();\n    if (rmode->viTVMode&VI_NON_INTERLACE)\n        VIDEO_WaitVSync();\n\n    gp_fifo = (u8 *) memalign(32, DEFAULT_FIFO_SIZE);\n    if (gp_fifo == NULL)\n        return;\n    memset(gp_fifo, 0, DEFAULT_FIFO_SIZE);\n    GX_Init(gp_fifo, DEFAULT_FIFO_SIZE);\n\n    // Clears the BG to color and clears the z-buffer\n    GX_SetCopyClear((GXColor){ 0, 0, 0, 0xff }, GX_MAX_Z24);\n\n    // Other GX setup\n    yscale = GX_GetYScaleFactor(rmode->efbHeight, rmode->xfbHeight);\n    xfbHeight = GX_SetDispCopyYScale(yscale);\n    GX_SetDispCopySrc(0, 0, rmode->fbWidth, rmode->efbHeight);\n    GX_SetDispCopyDst(rmode->fbWidth, xfbHeight);\n    GX_SetCopyFilter(rmode->aa, rmode->sample_pattern, GX_TRUE, rmode->vfilter);\n    GX_SetFieldMode(rmode->field_rendering, ((rmode->viHeight == 2 * rmode->xfbHeight) ? GX_ENABLE : GX_DISABLE));\n\n    if (rmode->aa) {\n        // Set 16 bit RGB565\n        GX_SetPixelFmt(GX_PF_RGB565_Z16, GX_ZC_LINEAR);\n    } else {\n        // Set 24 bit Z24\n        GX_SetPixelFmt(GX_PF_RGB8_Z24, GX_ZC_LINEAR);\n    }\n\n    GX_SetDispCopyGamma(GX_GM_1_0);\n\n    // Setup the vertex descriptor\n    // Tells the flipper to expect direct data\n    GX_ClearVtxDesc();\n    GX_InvVtxCache();\n    GX_InvalidateTexAll();\n\n    GX_SetVtxDesc(GX_VA_TEX0, GX_NONE);\n    GX_SetVtxDesc(GX_VA_POS,  GX_DIRECT);\n    GX_SetVtxDesc(GX_VA_CLR0, GX_DIRECT);\n\n    GX_SetVtxAttrFmt(GX_VTXFMT0, GX_VA_POS,  GX_POS_XYZ,  GX_F32, 0);\n    GX_SetVtxAttrFmt(GX_VTXFMT0, GX_VA_TEX0, GX_TEX_ST,   GX_F32, 0);\n    GX_SetVtxAttrFmt(GX_VTXFMT0, GX_VA_CLR0, GX_CLR_RGBA, GX_RGBA8, 0);\n    GX_SetZMode(GX_FALSE, GX_LEQUAL, GX_TRUE);\n\n    GX_SetNumChans(1);\n    GX_SetNumTexGens(1);\n    GX_SetTevOp(GX_TEVSTAGE0, GX_PASSCLR);\n    GX_SetTevOrder(GX_TEVSTAGE0, GX_TEXCOORD0, GX_TEXMAP0, GX_COLOR0A0);\n    GX_SetTexCoordGen(GX_TEXCOORD0, GX_TG_MTX2x4, GX_TG_TEX0, GX_IDENTITY);\n\n    guMtxIdentity(GXmodelView2D);\n    guMtxTransApply(GXmodelView2D, GXmodelView2D, 0.0F, 0.0F, -100.0F);\n    GX_LoadPosMtxImm(GXmodelView2D, GX_PNMTX0);\n\n    guOrtho(perspective, 0, rmode->efbHeight, 0, rmode->fbWidth, 0, 1000.0f);\n    GX_LoadProjectionMtx(perspective, GX_ORTHOGRAPHIC);\n\n    GX_SetViewport(0, 0, rmode->fbWidth, rmode->efbHeight, 0, 1);\n    GX_SetBlendMode(GX_BM_BLEND, GX_BL_SRCALPHA, GX_BL_INVSRCALPHA, GX_LO_CLEAR);\n    GX_SetAlphaUpdate(GX_TRUE);\n    GX_SetAlphaCompare(GX_GREATER, 0, GX_AOP_AND, GX_ALWAYS, 0);\n    GX_SetColorUpdate(GX_ENABLE);\n    GX_SetCullMode(GX_CULL_NONE);\n    GRRLIB_ClipReset();\n\n    VIDEO_SetBlack(false);\n\n    // Default settings\n    GRRLIB_Settings.antialias = true;\n    GRRLIB_Settings.blend = GRRLIB_BLEND_ALPHA;\n}", "path": "GRRLIB\\GRRLIB\\GRRLIB.c", "repo_name": "Megazig/CustomSystemMenu", "stars": 1, "license": "None", "language": "c", "size": 1956}
{"docstring": "/**\n * Reads a pixel directly from the FrontBuffer.\n * Since the FB is stored in YCbCr,\n * @param x The x-coordinate within the FB.\n * @param y The y-coordinate within the FB.\n * @param R1 A pointer to a variable receiving the first Red value.\n * @param G1 A pointer to a variable receiving the first Green value.\n * @param B1 A pointer to a variable receiving the first Blue value.\n * @param R2 A pointer to a variable receiving the second Red value.\n * @param G2 A pointer to a variable receiving the second Green value.\n * @param B2 A pointer to a variable receiving the second Blue value.\n */\n", "func_signal": "void GRRLIB_GetPixelFromFB(int x, int y, u8 *R1, u8 *G1, u8 *B1, u8* R2, u8 *G2, u8 *B2 )", "code": "{\n    // Position Correction\n    if (x > (rmode->fbWidth/2)) { x = (rmode->fbWidth/2); }\n    if (x < 0) { x = 0; }\n    if (y > rmode->efbHeight) { y = rmode->efbHeight; }\n    if (y < 0) { y = 0; }\n\n    // Preparing FB for reading\n    u32 Buffer = (((u32 *)xfb[fb])[y*(rmode->fbWidth/2)+x]);\n    u8 *Colors = (u8 *) &Buffer;\n\n    /** Color channel:\n    Colors[0] = Y1\n    Colors[1] = Cb\n    Colors[2] = Y2\n    Colors[3] = Cr */\n\n    *R1 = GRRLIB_ClampVar8( 1.164 * (Colors[0] - 16) + 1.596 * (Colors[3] - 128) );\n    *G1 = GRRLIB_ClampVar8( 1.164 * (Colors[0] - 16) - 0.813 * (Colors[3] - 128) - 0.392 * (Colors[1] - 128) );\n    *B1 = GRRLIB_ClampVar8( 1.164 * (Colors[0] - 16) + 2.017 * (Colors[1] - 128) );\n\n    *R2 = GRRLIB_ClampVar8( 1.164 * (Colors[2] - 16) + 1.596 * (Colors[3] - 128) );\n    *G2 = GRRLIB_ClampVar8( 1.164 * (Colors[2] - 16) - 0.813 * (Colors[3] - 128) - 0.392 * (Colors[1] - 128) );\n    *B2 = GRRLIB_ClampVar8( 1.164 * (Colors[2] - 16) + 2.017 * (Colors[1] - 128) );\n}", "path": "GRRLIB\\GRRLIB\\GRRLIB.c", "repo_name": "Megazig/CustomSystemMenu", "stars": 1, "license": "None", "language": "c", "size": 1956}
{"docstring": "/**\n * Flip texture horizontal.\n * @see GRRLIB_FlushTex\n * @param texsrc The texture source.\n * @param texdest The texture destination.\n */\n", "func_signal": "void GRRLIB_BMFX_FlipH(struct GRRLIB_texImg *texsrc, GRRLIB_texImg *texdest)", "code": "{\n    unsigned int x, y, txtWidth = texsrc->w - 1;\n\n    for (y = 0; y < texsrc->h; y++) {\n        for (x = 0; x < texsrc->w; x++) {\n            GRRLIB_SetPixelTotexImg(txtWidth - x, y, texdest,\n                GRRLIB_GetPixelFromtexImg(x, y, texsrc));\n        }\n    }\n}", "path": "GRRLIB\\GRRLIB\\GRRLIB.c", "repo_name": "Megazig/CustomSystemMenu", "stars": 1, "license": "None", "language": "c", "size": 1956}
{"docstring": "/**\n * Draw a circle.\n * @author Dark_Link\n * @param x Specifies the x-coordinate of the circle.\n * @param y Specifies the y-coordinate of the circle.\n * @param radius The radius of the circle.\n * @param color The color of the circle in RGBA format.\n * @param filled Set to true to fill the circle.\n */\n", "func_signal": "inline void GRRLIB_Circle(f32 x, f32 y, f32 radius, u32 color, u8 filled)", "code": "{\n    Vector v[36];\n    u32 ncolor[36];\n    u32 a;\n    f32 ra;\n    f32 G_DTOR = M_DTOR * 10;\n\n    for (a = 0; a < 36; a++) {\n        ra = a * G_DTOR;\n\n        v[a].x = cos(ra) * radius + x;\n        v[a].y = sin(ra) * radius + y;\n        v[a].z = 0.0f;\n        ncolor[a]  = color;\n    }\n\n    if (!filled) {\n        GRRLIB_GXEngine(v, ncolor, 36, GX_LINESTRIP);\n    }\n    else {\n        GRRLIB_GXEngine(v, ncolor, 36, GX_TRIANGLEFAN);\n    }\n}", "path": "GRRLIB\\GRRLIB\\GRRLIB.c", "repo_name": "Megazig/CustomSystemMenu", "stars": 1, "license": "None", "language": "c", "size": 1956}
{"docstring": "/**\n * Draw a rectangle.\n * @param x Specifies the x-coordinate of the upper-left corner of the rectangle.\n * @param y Specifies the y-coordinate of the upper-left corner of the rectangle.\n * @param width The width of the rectangle.\n * @param height The height of the rectangle.\n * @param color The color of the rectangle in RGBA format.\n * @param filled Set to true to fill the rectangle.\n */\n", "func_signal": "inline void GRRLIB_Rectangle(f32 x, f32 y, f32 width, f32 height, u32 color, u8 filled)", "code": "{\n    f32 x2 = x+width;\n    f32 y2 = y+height;\n    Vector v[] = {{x,y,0.0f}, {x2,y,0.0f}, {x2,y2,0.0f}, {x,y2,0.0f}, {x,y,0.0f}};\n    u32 ncolor[]= {color,color,color,color,color};\n\n    if (!filled) {\n        GRRLIB_NGone(v, ncolor, 5);\n    }\n    else {\n        GRRLIB_NGoneFilled(v, ncolor, 4);\n    }\n}", "path": "GRRLIB\\GRRLIB\\GRRLIB.c", "repo_name": "Megazig/CustomSystemMenu", "stars": 1, "license": "None", "language": "c", "size": 1956}
{"docstring": "/**\n * A texture effect (Scatter).\n * @see GRRLIB_FlushTex\n * @param texsrc The texture source.\n * @param texdest The texture destination.\n * @param factor The factor level of the effect.\n */\n", "func_signal": "void GRRLIB_BMFX_Scatter(struct GRRLIB_texImg *texsrc, GRRLIB_texImg *texdest, u32 factor)", "code": "{\n    unsigned int x, y;\n    u32 val1, val2;\n    u32 val3, val4;\n    int factorx2 = factor*2;\n\n    for (y = 0; y < texsrc->h; y++) {\n        for (x = 0; x < texsrc->w; x++) {\n            val1 = x + (int) (factorx2 * (rand() / (RAND_MAX + 1.0))) - factor;\n            val2 = y + (int) (factorx2 * (rand() / (RAND_MAX + 1.0))) - factor;\n\n            if ((val1 >= texsrc->w) || (val2 >= texsrc->h)) {\n            }\n            else {\n                val3 = GRRLIB_GetPixelFromtexImg(x, y, texsrc);\n                val4 = GRRLIB_GetPixelFromtexImg(val1, val2, texsrc);\n                GRRLIB_SetPixelTotexImg(x, y, texdest, val4);\n                GRRLIB_SetPixelTotexImg(val1, val2, texdest, val3);\n            }\n        }\n    }\n}", "path": "GRRLIB\\GRRLIB\\GRRLIB.c", "repo_name": "Megazig/CustomSystemMenu", "stars": 1, "license": "None", "language": "c", "size": 1956}
{"docstring": "/**\n * Invert colors of the texture.\n * @see GRRLIB_FlushTex\n * @param texsrc The texture source.\n * @param texdest The texture destination.\n */\n", "func_signal": "void GRRLIB_BMFX_Invert(struct GRRLIB_texImg *texsrc, GRRLIB_texImg *texdest)", "code": "{\n    unsigned int x, y;\n    u32 color;\n\n    for (y = 0; y < texsrc->h; y++) {\n        for (x = 0; x < texsrc->w; x++) {\n            color = GRRLIB_GetPixelFromtexImg(x, y, texsrc);\n            GRRLIB_SetPixelTotexImg(x, y, texdest,\n                ((0xFFFFFF - (color >> 8 & 0xFFFFFF)) << 8)  | (color & 0xFF));\n        }\n    }\n}", "path": "GRRLIB\\GRRLIB\\GRRLIB.c", "repo_name": "Megazig/CustomSystemMenu", "stars": 1, "license": "None", "language": "c", "size": 1956}
{"docstring": "/**\n * A texture effect (Pixelate).\n * @see GRRLIB_FlushTex\n * @param texsrc The texture source.\n * @param texdest The texture destination.\n * @param factor The factor level of the effect.\n */\n", "func_signal": "void GRRLIB_BMFX_Pixelate(struct GRRLIB_texImg *texsrc, GRRLIB_texImg *texdest, u32 factor)", "code": "{\n    unsigned int x, y;\n    unsigned int xx, yy;\n    u32 rgb;\n\n    for (x = 0; x < texsrc->w - 1 - factor; x += factor) {\n        for (y = 0; y < texsrc->h - 1 - factor; y +=factor) {\n            rgb = GRRLIB_GetPixelFromtexImg(x, y, texsrc);\n                for (xx = x; xx < x + factor; xx++) {\n                    for (yy = y; yy < y + factor; yy++) {\n                        GRRLIB_SetPixelTotexImg(xx, yy, texdest, rgb);\n                    }\n                }\n        }\n    }\n}", "path": "GRRLIB\\GRRLIB\\GRRLIB.c", "repo_name": "Megazig/CustomSystemMenu", "stars": 1, "license": "None", "language": "c", "size": 1956}
{"docstring": "/**\n * Draw a textured quad.\n * @param pos Vector array of the 4 points.\n * @param tex The texture to draw.\n * @param color Color in RGBA format.\n */\n", "func_signal": "inline void GRRLIB_DrawImgQuad(Vector pos[4], struct GRRLIB_texImg *tex, u32 color)", "code": "{\n    if (tex == NULL || tex->data == NULL) { return; }\n\n    GXTexObj texObj;\n    Mtx m, m1, m2, mv;\n\n    GX_InitTexObj(&texObj, tex->data, tex->w, tex->h, GX_TF_RGBA8, GX_CLAMP, GX_CLAMP, GX_FALSE);\n    if (GRRLIB_Settings.antialias == false) {\n        GX_InitTexObjLOD(&texObj, GX_NEAR, GX_NEAR, 0.0f, 0.0f, 0.0f, 0, 0, GX_ANISO_1);\n    }\n\n    GX_LoadTexObj(&texObj, GX_TEXMAP0);\n    GX_SetTevOp(GX_TEVSTAGE0, GX_MODULATE);\n    GX_SetVtxDesc(GX_VA_TEX0, GX_DIRECT);\n\n    guMtxIdentity(m1);\n    guMtxScaleApply(m1, m1, 1, 1, 1.0);\n    Vector axis = (Vector) {0, 0, 1 };\n    guMtxRotAxisDeg (m2, &axis, 0);\n    guMtxConcat(m2, m1, m);\n\n    guMtxConcat(GXmodelView2D, m, mv);\n\n    GX_LoadPosMtxImm(mv, GX_PNMTX0);\n    GX_Begin(GX_QUADS, GX_VTXFMT0, 4);\n        GX_Position3f32(pos[0].x, pos[0].y, 0);\n        GX_Color1u32(color);\n        GX_TexCoord2f32(0, 0);\n\n        GX_Position3f32(pos[1].x, pos[1].y, 0);\n        GX_Color1u32(color);\n        GX_TexCoord2f32(1, 0);\n\n        GX_Position3f32(pos[2].x, pos[2].y, 0);\n        GX_Color1u32(color);\n        GX_TexCoord2f32(1, 1);\n\n        GX_Position3f32(pos[3].x, pos[3].y, 0);\n        GX_Color1u32(color);\n        GX_TexCoord2f32(0, 1);\n    GX_End();\n    GX_LoadPosMtxImm(GXmodelView2D, GX_PNMTX0);\n\n    GX_SetTevOp(GX_TEVSTAGE0, GX_PASSCLR);\n    GX_SetVtxDesc(GX_VA_TEX0, GX_NONE);\n}", "path": "GRRLIB\\GRRLIB\\GRRLIB.c", "repo_name": "Megazig/CustomSystemMenu", "stars": 1, "license": "None", "language": "c", "size": 1956}
{"docstring": "/**\n * Load a texture from a buffer.\n * @param my_png the PNG buffer to load.\n * @return A GRRLIB_texImg structure filled with image informations.\n */\n", "func_signal": "GRRLIB_texImg *GRRLIB_LoadTexturePNG(const unsigned char my_png[])", "code": "{\n    PNGUPROP imgProp;\n    IMGCTX ctx;\n    GRRLIB_texImg *my_texture = (struct GRRLIB_texImg *)calloc(1, sizeof(GRRLIB_texImg));\n\n    if(my_texture != NULL) {\n        ctx = PNGU_SelectImageFromBuffer(my_png);\n        PNGU_GetImageProperties(ctx, &imgProp);\n        my_texture->data = memalign(32, imgProp.imgWidth * imgProp.imgHeight * 4);\n        if(my_texture->data != NULL) {\n            PNGU_DecodeTo4x4RGBA8(ctx, imgProp.imgWidth, imgProp.imgHeight, my_texture->data, 255);\n            PNGU_ReleaseImageContext(ctx);\n            my_texture->w = imgProp.imgWidth;\n            my_texture->h = imgProp.imgHeight;\n            GRRLIB_SetHandle( my_texture, 0, 0 );\n            GRRLIB_FlushTex( my_texture );\n        }\n    }\n    return my_texture;\n}", "path": "GRRLIB\\GRRLIB\\GRRLIB.c", "repo_name": "Megazig/CustomSystemMenu", "stars": 1, "license": "None", "language": "c", "size": 1956}
{"docstring": "/**\n * Determine whether a part of a specified rectangle lies on another rectangle.\n * @param rect1x Specifies the x-coordinate of the upper-left corner of the first rectangle.\n * @param rect1y Specifies the y-coordinate of the upper-left corner of the first rectangle.\n * @param rect1w Specifies the width of the first rectangle.\n * @param rect1h Specifies the height of the first rectangle.\n * @param rect2x Specifies the x-coordinate of the upper-left corner of the second rectangle.\n * @param rect2y Specifies the y-coordinate of the upper-left corner of the second rectangle.\n * @param rect2w Specifies the width of the second rectangle.\n * @param rect2h Specifies the height of the second rectangle.\n * @return If the specified rectangle lies on the other rectangle, the return value is true otherwise it's false.\n */\n", "func_signal": "bool GRRLIB_RectOnRect(int rect1x, int rect1y, int rect1w, int rect1h, int rect2x, int rect2y, int rect2w, int rect2h)", "code": "{\n    return (GRRLIB_PtInRect(rect1x, rect1y, rect1w, rect1h, rect2x, rect2y) ||\n        GRRLIB_PtInRect(rect1x, rect1y, rect1w, rect1h, rect2x+rect2w, rect2y) ||\n        GRRLIB_PtInRect(rect1x, rect1y, rect1w, rect1h, rect2x+rect2w, rect2y+rect2h) ||\n        GRRLIB_PtInRect(rect1x, rect1y, rect1w, rect1h, rect2x, rect2y+rect2h));\n}", "path": "GRRLIB\\GRRLIB\\GRRLIB.c", "repo_name": "Megazig/CustomSystemMenu", "stars": 1, "license": "None", "language": "c", "size": 1956}
{"docstring": "/**\n * Call this before exiting your application.\n */\n", "func_signal": "void GRRLIB_Exit()", "code": "{\n    GX_SetClipMode( GX_CLIP_DISABLE );\n    GX_SetScissor( 0, 0, rmode->fbWidth, rmode->efbHeight );\n    GRRLIB_FillScreen( 0x000000FF );\n    GRRLIB_Render();\n    GX_DrawDone();\n    GX_AbortFrame();\n\n    if (xfb[0] != NULL) {\n        free(MEM_K1_TO_K0(xfb[0]));\n        xfb[0] = NULL;\n    }\n    if (xfb[1] != NULL) {\n        free(MEM_K1_TO_K0(xfb[1]));\n        xfb[1] = NULL;\n    }\n    if (gp_fifo != NULL) {\n        free(gp_fifo);\n        gp_fifo = NULL;\n    }\n}", "path": "GRRLIB\\GRRLIB\\GRRLIB.c", "repo_name": "Megazig/CustomSystemMenu", "stars": 1, "license": "None", "language": "c", "size": 1956}
{"docstring": "/* used for gbmv, gpmv and gpr.    */\n", "func_signal": "void Mjoin( PATL, syr )\n(\n   const enum ATLAS_UPLO      UPLO,\n   const int                  N,\n   const SCALAR               ALPHA,\n   const TYPE                 * X,\n   const int                  INCX,\n   TYPE                       * A,\n   const int                  LDA\n)", "code": "{\n/*\n * Purpose\n * =======\n *\n * Mjoin( PATL, syr ) performs the symmetric rank 1 operation\n *\n *    A := alpha * x * x' + A,\n *\n * where  alpha is a scalar, x is an n-element vector and A is an n by n\n * symmetric matrix.\n *\n * This is a blocked version of the algorithm.  For a more detailed des-\n * cription of  the arguments of this function, see the reference imple-\n * mentation in the ATLAS/src/blas/reference directory.\n *\n * ---------------------------------------------------------------------\n */\n/*\n * .. Local Variables ..\n */\n#ifdef TREAL\n#define    lda2               LDA\n#define    one                ATL_rone\n#else\n   const TYPE                 one[2] = { ATL_rone, ATL_rzero };\n   const int                  lda2   = ( LDA SHIFT );\n#endif\n   void                       * vx = NULL;\n   TYPE                       * x, * y, * A0, * y0;\n   int                        incA0, incA, incX, incY, incy, mb, mb1, n, nb;\n#ifdef TREAL\n#define   ger1    Mjoin( PATL, ger1_a1_x1_yX  )\n#else\n#define   ger1    Mjoin( PATL, ger1u_a1_x1_yX )\n#endif\n/* ..\n * .. Executable Statements ..\n *\n */\n   if( ( N == 0 ) || ( SCALAR_IS_ZERO( ALPHA ) ) ) return;\n\n   if( ( INCX == 1 ) && ( SCALAR_IS_ONE( ALPHA ) ) )\n   {\n      x = y = (TYPE *)(X); incy = INCX;\n   }\n   else\n   {\n      vx = (void *)malloc( ATL_Cachelen + ATL_MulBySize( N ) );\n      ATL_assert( vx ); x = ATL_AlignPtr( vx );\n      Mjoin( PATL, cpsc )( N, ALPHA, X, INCX, x, 1 );\n      y = (TYPE *)(X); incy = INCX;\n   }\n\n   ATL_GetPartR1( A, LDA, mb, nb );\n\n   mb1  = N - ( ( N - 1 ) / mb ) * mb;\n\n   if( UPLO == AtlasLower )\n   {\n      incA = ( incA0 = ( incX  = (mb SHIFT) ) ) + mb * lda2;\n\n      Mjoin( PATL, syrL )( mb1, x, y, incy, A, LDA );\n      A0 = (TYPE *)( A += (mb1 SHIFT) ); A += mb1 * lda2; x += (mb1 SHIFT);\n\n      for( n = mb1; n < N; n += mb, A0 += incA0, A += incA, x += incX )\n      {\n         ger1( mb, n, one, x, 1, y, incy, A0, LDA );\n         Mjoin( PATL, syrL )( mb, x, y + n*(incy SHIFT), incy, A, LDA );\n      }\n   }\n   else\n   {\n      incA = mb * lda2 + ( incX = (mb SHIFT) ); incY = incX * incy;\n\n      for( n  = N - mb, A0 = (TYPE *)(A) + mb * lda2, y0 = y + incY; n > 0;\n           n -= mb, A0 += incA, A += incA, x += incX, y += incY, y0 += incY )\n      {\n         Mjoin( PATL, syrU )( mb, x, y, incy, A, LDA );\n         ger1( mb, n, one, x, 1, y0, incy, A0, LDA );\n      }\n      Mjoin( PATL, syrU )( mb1, x, y, incy, A, LDA );\n   }\n\n   if( vx ) free( vx );\n/*\n * End of Mjoin( PATL, syr )\n */\n}", "path": "src\\blas\\level2\\ATL_syr.c", "repo_name": "cournape/atlas-nosse", "stars": 1, "license": "None", "language": "c", "size": 3510}
{"docstring": "/*\n * malloc/free pair that aligns data to align, but not to misalign\n */\n", "func_signal": "void *FA_malloc(size_t size, int align, int misalign)", "code": "{\n   if ((!misalign && align <= 8) || !size)\n      return(malloc(size));\n   else\n   {\n      allocQ = NewAlloc(size, allocQ, align, misalign);\n      return(allocQ->memA);\n   }\n}", "path": "tune\\blas\\gemv\\gemvtune.c", "repo_name": "cournape/atlas-nosse", "stars": 1, "license": "None", "language": "c", "size": 3510}
{"docstring": "/*\n * malloc/free pair that aligns data to align, but not to misalign\n */\n", "func_signal": "void *FA_malloc(size_t size, int align, int misalign)", "code": "{\n   if ((!misalign && align <= 8) || !size)\n      return(malloc(size));\n   else\n   {\n      allocQ = NewAlloc(size, allocQ, align, misalign);\n      return(allocQ->memA);\n   }\n}", "path": "tune\\blas\\level1\\dottest.c", "repo_name": "cournape/atlas-nosse", "stars": 1, "license": "None", "language": "c", "size": 3510}
{"docstring": "/*\n * malloc/free pair that aligns data to align, but not to misalign\n */\n", "func_signal": "void *FA_malloc(size_t size, int align, int misalign)", "code": "{\n   if ((!misalign && align <= 8) || !size)\n      return(malloc(size));\n   else\n   {\n      allocQ = NewAlloc(size, allocQ, align, misalign);\n      return(allocQ->memA);\n   }\n}", "path": "tune\\blas\\level1\\axpytime.c", "repo_name": "cournape/atlas-nosse", "stars": 1, "license": "None", "language": "c", "size": 3510}
{"docstring": "/*\n * malloc/free pair that aligns data to align, but not to misalign\n */\n", "func_signal": "void *FA_malloc(size_t size, int align, int misalign)", "code": "{\n   if ((!misalign && align <= 8) || !size)\n      return(malloc(size));\n   else\n   {\n      allocQ = NewAlloc(size, allocQ, align, misalign);\n      return(allocQ->memA);\n   }\n}", "path": "tune\\blas\\level1\\iamaxtest.c", "repo_name": "cournape/atlas-nosse", "stars": 1, "license": "None", "language": "c", "size": 3510}
{"docstring": "/*\n * malloc/free pair that aligns data to align, but not to misalign\n */\n", "func_signal": "void *FA_malloc(size_t size, int align, int misalign)", "code": "{\n   if ((!misalign && align <= 8) || !size)\n      return(malloc(size));\n   else\n   {\n      allocQ = NewAlloc(size, allocQ, align, misalign);\n      return(allocQ->memA);\n   }\n}", "path": "tune\\blas\\level1\\dottime.c", "repo_name": "cournape/atlas-nosse", "stars": 1, "license": "None", "language": "c", "size": 3510}
{"docstring": "/*\n * malloc/free pair that aligns data to align, but not to misalign\n */\n", "func_signal": "void *FA_malloc(size_t size, int align, int misalign)", "code": "{\n   if ((!misalign && align <= 8) || !size)\n      return(malloc(size));\n   else\n   {\n      allocQ = NewAlloc(size, allocQ, align, misalign);\n      return(allocQ->memA);\n   }\n}", "path": "tune\\blas\\level1\\axpytest.c", "repo_name": "cournape/atlas-nosse", "stars": 1, "license": "None", "language": "c", "size": 3510}
{"docstring": "/*\n * These two routines copy an mbxnb section of a matrix A to a block-major\n * nbxmb matrix V (A is transposed in the copy)\n */\n", "func_signal": "static void ATL_prow2blk_KB_a1(const int mb, const int nb, const SCALAR alpha,\n                               const TYPE *A, int lda, const int ldainc,TYPE *V)", "code": "{\n   TYPE *v;\n   int i, j;\n\n   if (ldainc == -1) lda--;\n   for (j=nb; j; j--)\n   {\n      v = V++;\n      for (i=0; i != mb; i++, v += nb) *v = A[i];\n      A += lda;\n      lda += ldainc;\n   }\n}", "path": "src\\blas\\pklevel3\\gpmm\\ATL_prow2blkT.c", "repo_name": "cournape/atlas-nosse", "stars": 1, "license": "None", "language": "c", "size": 3510}
{"docstring": "/* used for gbmv, gpmv and gpr.    */\n", "func_signal": "void Mjoin( PATL, hpmv )\n(\n   const enum ATLAS_UPLO      UPLO,\n   const int                  N,\n   const SCALAR               ALPHA,\n   const TYPE                 * A,\n   const TYPE                 * X,\n   const int                  INCX,\n   const SCALAR               BETA,\n   TYPE                       * Y,\n   const int                  INCY\n)", "code": "{\n/*\n * Purpose\n * =======\n *\n * Mjoin( PATL, hpmv ) performs the matrix-vector operation\n *\n *    y := alpha * A * x + beta * y,\n *\n * where alpha and beta are scalars, x and y are n-element vectors and A\n * is an n by n Hermitian matrix, supplied in packed form.\n *\n * This is a blocked version of the algorithm.  For a more detailed des-\n * cription of  the arguments of this function, see the reference imple-\n * mentation in the ATLAS/src/blas/reference directory.\n *\n * ---------------------------------------------------------------------\n */\n/*\n * .. Local Variables ..\n */\n   void                       (*gpmv0)( const int, const int, const SCALAR,\n                              const TYPE *, const int, const TYPE *, const int,\n                              const SCALAR, TYPE *, const int );\n   void                       (*gpmv1)( const int, const int, const SCALAR,\n                              const TYPE *, const int, const TYPE *, const int,\n                              const SCALAR, TYPE *, const int );\n   void                       (*gpmvN)( const int, const int, const SCALAR,\n                              const TYPE *, const int, const TYPE *, const int,\n                              const SCALAR, TYPE *, const int );\n#ifdef TREAL\n   TYPE                       alphaY, beta0;\n#define one                   ATL_rone\n#define zero                  ATL_rzero\n#else\n   const TYPE                 * alphaY, * beta0;\n   const TYPE                 one [2] = { ATL_rone,  ATL_rzero },\n                              zero[2] = { ATL_rzero, ATL_rzero };\n#endif\n   void                       * vx = NULL, * vy = NULL;\n   TYPE                       * A0, * A1, * x, * x0, * x1, * y, * y00, * y0,\n                              * y1;\n   int                        incXY, incXY1, j, jb, lda, lda0, lda1, mb, mb1,\n                              n, nb;\n/* ..\n * .. Executable Statements ..\n *\n */\n   if( N == 0 ) return;\n\n   if( SCALAR_IS_ZERO( ALPHA ) )\n   {\n      if( !( SCALAR_IS_ONE( BETA ) ) ) Mjoin( PATL, scal )( N, BETA, Y, INCY );\n      return;\n   }\n\n   if( ( INCX != 1 ) || ( ( INCY == 1 ) && !( SCALAR_IS_ONE( ALPHA ) ) ) )\n   {\n      vx = (void *)malloc( ATL_Cachelen + ATL_MulBySize( N ) );\n      ATL_assert( vx ); x = ATL_AlignPtr( vx );\n      Mjoin( PATL, cpsc )( N, ALPHA, X, INCX, x, 1 );\n      alphaY = one;\n   }\n   else { x = (TYPE *)(X); alphaY = ALPHA; }\n\n   if( ( INCY != 1 ) || !( SCALAR_IS_ONE( alphaY ) ) )\n   {\n      vy = malloc( ATL_Cachelen + ATL_MulBySize( N ) );\n      ATL_assert( vy ); y00 = y = ATL_AlignPtr( vy );\n      beta0 = zero;\n   }\n   else { y00 = y = (TYPE *)(Y); beta0 = BETA; }\n\n   ATL_GetPartSPMV( A, N, &mb, &nb );\n\n   mb1 = N - ( ( N - 1 ) / mb ) * mb; incXY1 = (nb SHIFT);\n\n   if( UPLO == AtlasUpper )\n   {\n      if(      SCALAR_IS_ZERO( beta0 ) )\n         gpmv0 = Mjoin( PATL, gpmvUC_a1_x1_b0_y1 );\n      else if( SCALAR_IS_ONE ( beta0 ) )\n         gpmv0 = Mjoin( PATL, gpmvUC_a1_x1_b1_y1 );\n      else\n         gpmv0 = Mjoin( PATL, gpmvUC_a1_x1_bX_y1 );\n      gpmv1 = Mjoin( PATL, gpmvUC_a1_x1_b1_y1 );\n      gpmvN = Mjoin( PATL, gpmvUN_a1_x1_b1_y1 );\n\n      lda = 1; lda0 = lda; A0 = (TYPE *)(A); MUpnext( mb, A0, lda0 );\n      incXY = (mb SHIFT); x0 = x + incXY; y0 = y + incXY;\n\n      for( n = N - mb; n > 0; n -= mb, x0 += incXY, x += incXY,\n           y0 += incXY, y += incXY )\n      {\n         Mjoin( PATL, hpmvU )( mb, A, lda, x, beta0, y );\n\n         for( j = 0, lda1 = lda0, A1 = A0 - (mb SHIFT), x1 = x0, y1 = y0; j < n;\n              j += nb, x1 += incXY1, y1 += incXY1 )\n         {\n            jb = n - j; jb = Mmin( jb, nb );\n            gpmv0( jb, mb, one, A1, lda1, x,  1, beta0, y1, 1 );\n            gpmvN( mb, jb, one, A1, lda1, x1, 1, one,   y,  1 );\n            MUpnext( jb, A1, lda1 ); A1 -= (jb SHIFT);\n         }\n         beta0 = one; gpmv0 = gpmv1; lda = lda0; A = A0; MUpnext( mb, A0, lda0 );\n      }\n      Mjoin( PATL, hpmvU )( mb1, A, lda, x, beta0, y );\n   }\n   else\n   {\n      if(      SCALAR_IS_ZERO( beta0 ) )\n         gpmv0 = Mjoin( PATL, gpmvLC_a1_x1_b0_y1 );\n      else if( SCALAR_IS_ONE ( beta0 ) )\n         gpmv0 = Mjoin( PATL, gpmvLC_a1_x1_b1_y1 );\n      else\n         gpmv0 = Mjoin( PATL, gpmvLC_a1_x1_bX_y1 );\n      gpmv1 = Mjoin( PATL, gpmvLC_a1_x1_b1_y1 );\n      gpmvN = Mjoin( PATL, gpmvLN_a1_x1_b1_y1 );\n\n      lda = N; lda0 = lda; A0 = (TYPE *)(A); MLpnext( N, A, lda );\n      incXY = (mb SHIFT); x0 = x; y0 = y;\n\n      for( n  = N - mb, x += ((N-mb) SHIFT), y += ((N-mb) SHIFT); n > 0;\n           n -= mb, x -= incXY, y -= incXY )\n      {\n         MLpprev( mb, A, lda );\n         Mjoin( PATL, hpmvL )( mb, A, lda, x, beta0, y );\n\n         for( j = 0, lda1 = lda0, A1 = A0 + (n SHIFT), x1 = x0, y1 = y0; j < n;\n              j += nb, x1 += incXY1, y1 += incXY1 )\n         {\n            jb = n - j; jb = Mmin( jb, nb );\n            gpmv0( jb, mb, one, A1, lda1, x,  1, beta0, y1, 1 );\n            gpmvN( mb, jb, one, A1, lda1, x1, 1, one,   y,  1 );\n            MLpnext( jb, A1, lda1 ); A1 -= (jb SHIFT);\n         }\n         beta0 = one; gpmv0 = gpmv1;\n      }\n      Mjoin( PATL, hpmvL )( mb1, A0, lda0, x0, beta0, y0 );\n   }\n\n   if( vx ) free( vx );\n   if( vy )\n   { Mjoin( PATL, axpby )( N, alphaY, y00, 1, BETA, Y, INCY ); free( vy ); }\n/*\n * End of Mjoin( PATL, hpmv )\n */\n}", "path": "src\\blas\\level2\\ATL_hpmv.c", "repo_name": "cournape/atlas-nosse", "stars": 1, "license": "None", "language": "c", "size": 3510}
{"docstring": "/* complex routine */\n", "func_signal": "void Mjoin(Mjoin(PATL,UPR),rot)\n   (const int N, TYPE *X, const int incx, TYPE *Y, const int incy,\n    const TYPE c0, const TYPE s0)", "code": "{\n   const register TYPE c = c0, s = s0;\n   register TYPE rx, ix, ry, iy;\n   const int incX = incx<<1, incY = incy<<1;\n   int i;\n\n   if (N > 0)\n   {\n      if (incx == 1 && incy == 1)\n      {\n         for (i=N; i; i--, X += 2, Y += 2)  /* maybe compiler unrolls */\n         {\n            rx = *X;  ix = X[1];\n            ry = *Y;  iy = Y[1];\n            *X   = c * rx + s * ry;\n            X[1] = c * ix + s * iy;\n            *Y   = c * ry - s * rx;\n            Y[1] = c * iy - s * ix;\n         }\n      }\n      else\n      {\n         for (i=N; i; i--, X += incX, Y += incY)  /* maybe compiler unrolls */\n         {\n            rx = *X;  ix = X[1];\n            ry = *Y;  iy = Y[1];\n            *X   = c * rx + s * ry;\n            X[1] = c * ix + s * iy;\n            *Y   = c * ry - s * rx;\n            Y[1] = c * iy - s * ix;\n         }\n      }\n   }\n}", "path": "src\\blas\\level1\\ATL_rot.c", "repo_name": "cournape/atlas-nosse", "stars": 1, "license": "None", "language": "c", "size": 3510}
{"docstring": "/*\n * malloc/free pair that aligns data to align, but not to misalign\n */\n", "func_signal": "void *FA_malloc(size_t size, int align, int misalign)", "code": "{\n   if ((!misalign && align <= 8) || !size)\n      return(malloc(size));\n   else\n   {\n      allocQ = NewAlloc(size, allocQ, align, misalign);\n      return(allocQ->memA);\n   }\n}", "path": "tune\\blas\\level1\\nrm2test.c", "repo_name": "cournape/atlas-nosse", "stars": 1, "license": "None", "language": "c", "size": 3510}
{"docstring": "/*\n * malloc/free pair that aligns data to align, but not to misalign\n */\n", "func_signal": "void *FA_malloc(size_t size, int align, int misalign)", "code": "{\n   if ((!misalign && align <= 8) || !size)\n      return(malloc(size));\n   else\n   {\n      allocQ = NewAlloc(size, allocQ, align, misalign);\n      return(allocQ->memA);\n   }\n}", "path": "tune\\blas\\level1\\settest.c", "repo_name": "cournape/atlas-nosse", "stars": 1, "license": "None", "language": "c", "size": 3510}
{"docstring": "/* used for gbmv, gpmv and gpr.    */\n", "func_signal": "void Mjoin( PATL, spmv )\n(\n   const enum ATLAS_UPLO      UPLO,\n   const int                  N,\n   const SCALAR               ALPHA,\n   const TYPE                 * A,\n   const TYPE                 * X,\n   const int                  INCX,\n   const SCALAR               BETA,\n   TYPE                       * Y,\n   const int                  INCY\n)", "code": "{\n/*\n * Purpose\n * =======\n *\n * Mjoin( PATL, spmv ) performs the matrix-vector operation\n *\n *    y := alpha * A * x + beta * y,\n *\n * where alpha and beta are scalars, x and y are n-element vectors and A\n * is an n by n symmetric matrix, supplied in packed form.\n *\n * This is a blocked version of the algorithm.  For a more detailed des-\n * cription of  the arguments of this function, see the reference imple-\n * mentation in the ATLAS/src/blas/reference directory.\n *\n * ---------------------------------------------------------------------\n */\n/*\n * .. Local Variables ..\n */\n   void                       (*gpmv0)( const int, const int, const SCALAR,\n                              const TYPE *, const int, const TYPE *, const int,\n                              const SCALAR, TYPE *, const int );\n   void                       (*gpmv1)( const int, const int, const SCALAR,\n                              const TYPE *, const int, const TYPE *, const int,\n                              const SCALAR, TYPE *, const int );\n   void                       (*gpmvN)( const int, const int, const SCALAR,\n                              const TYPE *, const int, const TYPE *, const int,\n                              const SCALAR, TYPE *, const int );\n#ifdef TREAL\n   TYPE                       alphaY, beta0;\n#define one                   ATL_rone\n#define zero                  ATL_rzero\n#else\n   const TYPE                 * alphaY, * beta0;\n   const TYPE                 one [2] = { ATL_rone,  ATL_rzero },\n                              zero[2] = { ATL_rzero, ATL_rzero };\n#endif\n   void                       * vx = NULL, * vy = NULL;\n   TYPE                       * A0, * A1, * x, * x0, * x1, * y, * y00, * y0,\n                              * y1;\n   int                        incXY, incXY1, j, jb, lda, lda0, lda1, mb, mb1,\n                              n, nb;\n/* ..\n * .. Executable Statements ..\n *\n */\n   if( N == 0 ) return;\n\n   if( SCALAR_IS_ZERO( ALPHA ) )\n   {\n      if( !( SCALAR_IS_ONE( BETA ) ) ) Mjoin( PATL, scal )( N, BETA, Y, INCY );\n      return;\n   }\n\n   if( ( INCX != 1 ) || ( ( INCY == 1 ) && !( SCALAR_IS_ONE( ALPHA ) ) ) )\n   {\n      vx = (void *)malloc( ATL_Cachelen + ATL_MulBySize( N ) );\n      ATL_assert( vx ); x = ATL_AlignPtr( vx );\n      Mjoin( PATL, cpsc )( N, ALPHA, X, INCX, x, 1 );\n      alphaY = one;\n   }\n   else { x = (TYPE *)(X); alphaY = ALPHA; }\n\n   if( ( INCY != 1 ) || !( SCALAR_IS_ONE( alphaY ) ) )\n   {\n      vy = malloc( ATL_Cachelen + ATL_MulBySize( N ) );\n      ATL_assert( vy ); y00 = y = ATL_AlignPtr( vy );\n      beta0 = zero;\n   }\n   else { y00 = y = (TYPE *)(Y); beta0 = BETA; }\n\n   ATL_GetPartSPMV( A, N, &mb, &nb );\n\n   mb1 = N - ( ( N - 1 ) / mb ) * mb; incXY1 = (nb SHIFT);\n\n   if( UPLO == AtlasUpper )\n   {\n      if(      SCALAR_IS_ZERO( beta0 ) )\n         gpmv0 = Mjoin( PATL, gpmvUT_a1_x1_b0_y1 );\n      else if( SCALAR_IS_ONE ( beta0 ) )\n         gpmv0 = Mjoin( PATL, gpmvUT_a1_x1_b1_y1 );\n      else\n         gpmv0 = Mjoin( PATL, gpmvUT_a1_x1_bX_y1 );\n      gpmv1 = Mjoin( PATL, gpmvUT_a1_x1_b1_y1 );\n      gpmvN = Mjoin( PATL, gpmvUN_a1_x1_b1_y1 );\n\n      lda = 1; lda0 = lda; A0 = (TYPE *)(A); MUpnext( mb, A0, lda0 );\n      incXY = (mb SHIFT); x0 = x + incXY; y0 = y + incXY;\n\n      for( n = N - mb; n > 0; n -= mb, x0 += incXY, x += incXY,\n           y0 += incXY, y += incXY )\n      {\n         Mjoin( PATL, spmvU )( mb, A, lda, x, beta0, y );\n\n         for( j = 0, lda1 = lda0, A1 = A0 - (mb SHIFT), x1 = x0, y1 = y0; j < n;\n              j += nb, x1 += incXY1, y1 += incXY1 )\n         {\n            jb = n - j; jb = Mmin( jb, nb );\n            gpmv0( jb, mb, one, A1, lda1, x,  1, beta0, y1, 1 );\n            gpmvN( mb, jb, one, A1, lda1, x1, 1, one,   y,  1 );\n            MUpnext( jb, A1, lda1 ); A1 -= (jb SHIFT);\n         }\n         beta0 = one; gpmv0 = gpmv1; lda = lda0; A = A0; MUpnext( mb, A0, lda0 );\n      }\n      Mjoin( PATL, spmvU )( mb1, A, lda, x, beta0, y );\n   }\n   else\n   {\n      if(      SCALAR_IS_ZERO( beta0 ) )\n         gpmv0 = Mjoin( PATL, gpmvLT_a1_x1_b0_y1 );\n      else if( SCALAR_IS_ONE ( beta0 ) )\n         gpmv0 = Mjoin( PATL, gpmvLT_a1_x1_b1_y1 );\n      else\n         gpmv0 = Mjoin( PATL, gpmvLT_a1_x1_bX_y1 );\n      gpmv1 = Mjoin( PATL, gpmvLT_a1_x1_b1_y1 );\n      gpmvN = Mjoin( PATL, gpmvLN_a1_x1_b1_y1 );\n\n      lda = N; lda0 = lda; A0 = (TYPE *)(A); MLpnext( N, A, lda );\n      incXY = (mb SHIFT); x0 = x; y0 = y;\n\n      for( n  = N - mb, x += ((N-mb) SHIFT), y += ((N-mb) SHIFT); n > 0;\n           n -= mb, x -= incXY, y -= incXY )\n      {\n         MLpprev( mb, A, lda );\n         Mjoin( PATL, spmvL )( mb, A, lda, x, beta0, y );\n\n         for( j = 0, lda1 = lda0, A1 = A0 + (n SHIFT), x1 = x0, y1 = y0; j < n;\n              j += nb, x1 += incXY1, y1 += incXY1 )\n         {\n            jb = n - j; jb = Mmin( jb, nb );\n            gpmv0( jb, mb, one, A1, lda1, x,  1, beta0, y1, 1 );\n            gpmvN( mb, jb, one, A1, lda1, x1, 1, one,   y,  1 );\n            MLpnext( jb, A1, lda1 ); A1 -= (jb SHIFT);\n         }\n         beta0 = one; gpmv0 = gpmv1;\n      }\n      Mjoin( PATL, spmvL )( mb1, A0, lda0, x0, beta0, y0 );\n   }\n\n   if( vx ) free( vx );\n   if( vy )\n   { Mjoin( PATL, axpby )( N, alphaY, y00, 1, BETA, Y, INCY ); free( vy ); }\n/*\n * End of Mjoin( PATL, spmv )\n */\n}", "path": "src\\blas\\level2\\ATL_spmv.c", "repo_name": "cournape/atlas-nosse", "stars": 1, "license": "None", "language": "c", "size": 3510}
{"docstring": "/* used for gbmv, gpmv and gpr.    */\n", "func_signal": "void Mjoin( PATL, syr2 )\n(\n   const enum ATLAS_UPLO      UPLO,\n   const int                  N,\n   const SCALAR               ALPHA,\n   const TYPE                 * X,\n   const int                  INCX,\n   const TYPE                 * Y,\n   const int                  INCY,\n   TYPE                       * A,\n   const int                  LDA\n)", "code": "{\n/*\n * Purpose\n * =======\n *\n * Mjoin( PATL, syr2 ) performs the symmetric rank 2 operation\n *\n *    A := alpha * x * y' + alpha * y * x' + A,\n *\n * where  alpha is a scalar, x and y are n-element vectors and A is an n\n * by n symmetric matrix.\n *\n * This is a blocked version of the algorithm.  For a more detailed des-\n * cription of  the arguments of this function, see the reference imple-\n * mentation in the ATLAS/src/blas/reference directory.\n *\n * ---------------------------------------------------------------------\n */\n/*\n * .. Local Variables ..\n */\n#ifdef TREAL\n#define    lda2               LDA\n#define    one                ATL_rone\n#else\n   const TYPE                 one[2] = { ATL_rone, ATL_rzero };\n   const int                  lda2   = ( LDA SHIFT );\n#endif\n   TYPE                       * A0, * A1, * x, * x0, * x1, * y, * y0, * y1;\n   void                       * vx = NULL, * vy = NULL;\n   int                        incA, incA0, incA1, incXY, incXY1, j, jb,\n                              mb, mb1, n, nb;\n#ifdef TREAL\n#define   ger1    Mjoin( PATL, ger1_a1_x1_yX  )\n#else\n#define   ger1    Mjoin( PATL, ger1u_a1_x1_yX )\n#endif\n/* ..\n * .. Executable Statements ..\n *\n */\n   if( ( N == 0 ) || ( SCALAR_IS_ZERO( ALPHA ) ) ) return;\n\n   if( INCX != 1 )\n   {\n      vx = (TYPE *)malloc( ATL_Cachelen + ATL_MulBySize( N ) );\n      ATL_assert( vx ); x = ATL_AlignPtr( vx );\n      Mjoin( PATL, cpsc )( N, ALPHA, X, INCX, x, 1 );\n   }\n   else { x = (TYPE *)(X); }\n\n   if( ( ( vx != NULL ) && ( INCY != 1 ) ) ||\n       ( ( vx == NULL ) && ( !( SCALAR_IS_ONE( ALPHA ) ) || ( INCY != 1 ) ) ) )\n   {\n      vy = (TYPE *)malloc( ATL_Cachelen + ATL_MulBySize( N ) );\n      ATL_assert( vy ); y = ATL_AlignPtr( vy );\n      if( ( vx != NULL ) && ( INCY != 1 ) )\n      {\n         Mjoin( PATL, copy )( N,        Y, INCY, y, 1 );\n      }\n      else\n      {\n         Mjoin( PATL, cpsc )( N, ALPHA, Y, INCY, y, 1 );\n      }\n   }\n   else { y = (TYPE *)(Y); }\n\n   ATL_GetPartR1( A, LDA, mb, nb );\n\n   mb1   = N - ( ( N - 1 ) / mb ) * mb;\n   incA  = ( incXY = (mb SHIFT) ) + mb * lda2;\n   incA1 = nb * lda2;   incXY1 = (nb SHIFT);\n\n   if( UPLO == AtlasLower )\n   {\n      incA0 = incXY;\n\n      Mjoin( PATL, syr2L )( mb1, x, y, A, LDA );\n\n      A0 = (TYPE *)( A += (mb1 SHIFT) ); A += mb1 * lda2;\n      x0 = x;                            x += (mb1 SHIFT);\n      y0 = y;                            y += (mb1 SHIFT);\n\n      for( n  = mb1; n < N;\n           n += mb, A0 += incA0, A += incA, x += incXY, y += incXY )\n      {\n         for( j  = 0,  A1  = A0,    x1  = x0,     y1  = y0;     j < n;\n              j += nb, A1 += incA1, x1 += incXY1, y1 += incXY1 )\n         {\n            jb = n - j; jb = Mmin( jb, nb );\n            ger1( mb, jb, one, x, 1, y1, 1, A1, LDA );\n            ger1( mb, jb, one, y, 1, x1, 1, A1, LDA );\n         }\n         Mjoin( PATL, syr2L )( mb, x, y, A, LDA );\n      }\n   }\n   else\n   {\n      for( n  = N - mb,\n           A0 = (TYPE *)(A) + mb * lda2, x0 = x + incXY, y0 = y + incXY;\n           n > 0;\n           n -= mb,\n           A += incA,  A0 += incA,\n           x += incXY, x0 += incXY, y += incXY, y0 += incXY )\n      {\n         Mjoin( PATL, syr2U )( mb, x, y, A, LDA );\n\n         for( j  = 0,  A1  = A0,    x1  = x0,     y1  = y0;     j < n;\n              j += nb, A1 += incA1, x1 += incXY1, y1 += incXY1 )\n         {\n            jb = n - j; jb = Mmin( jb, nb );\n            ger1( mb, jb, one, x, 1, y1, 1, A1, LDA );\n            ger1( mb, jb, one, y, 1, x1, 1, A1, LDA );\n         }\n      }\n      Mjoin( PATL, syr2U )( mb1, x, y, A, LDA );\n   }\n\n   if( vx ) free( vx );\n   if( vy ) free( vy );\n/*\n * End of Mjoin( PATL, syr2 )\n */\n}", "path": "src\\blas\\level2\\ATL_syr2.c", "repo_name": "cournape/atlas-nosse", "stars": 1, "license": "None", "language": "c", "size": 3510}
{"docstring": "/*\n * malloc/free pair that aligns data to align, but not to misalign\n */\n", "func_signal": "void *FA_malloc(size_t size, int align, int misalign)", "code": "{\n   if ((!misalign && align <= 8) || !size)\n      return(malloc(size));\n   else\n   {\n      allocQ = NewAlloc(size, allocQ, align, misalign);\n      return(allocQ->memA);\n   }\n}", "path": "tune\\blas\\level1\\swaptime.c", "repo_name": "cournape/atlas-nosse", "stars": 1, "license": "None", "language": "c", "size": 3510}
{"docstring": "/*\n * malloc/free pair that aligns data to align, but not to misalign\n */\n", "func_signal": "void *FA_malloc(size_t size, int align, int misalign)", "code": "{\n   if ((!misalign && align <= 8) || !size)\n      return(malloc(size));\n   else\n   {\n      allocQ = NewAlloc(size, allocQ, align, misalign);\n      return(allocQ->memA);\n   }\n}", "path": "tune\\blas\\level1\\rottest.c", "repo_name": "cournape/atlas-nosse", "stars": 1, "license": "None", "language": "c", "size": 3510}
{"docstring": "/* used for gbmv, gpmv and gpr.    */\n", "func_signal": "void Mjoin( PATL, tpsv )\n(\n   const enum ATLAS_UPLO      UPLO,\n   const enum ATLAS_TRANS     TRANS,\n   const enum ATLAS_DIAG      DIAG,\n   const int                  N,\n   const TYPE                 * A,\n   TYPE                       * X,\n   const int                  INCX\n)", "code": "{\n/*\n * Purpose\n * =======\n *\n * Mjoin( PATL, tpsv ) solves one of the systems of equations\n *\n *    A * x = b,   or   conjg( A  ) * x = b,   or\n *\n *    A'* x = b,   or   conjg( A' ) * x = b,\n *\n * where b and x are n-element vectors and  A is an n by n unit, or non-\n * unit, upper or lower triangular matrix, supplied in packed form.\n *\n * No test for  singularity  or  near-singularity  is included  in  this\n * routine. Such tests must be performed before calling this routine.\n *\n * This is a blocked version of the algorithm.  For a more detailed des-\n * cription of  the arguments of this function, see the reference imple-\n * mentation in the ATLAS/src/blas/reference directory.\n *\n * ---------------------------------------------------------------------\n */\n/*\n * .. Local Variables ..\n */\n   void                       * vx = NULL;\n   TYPE                       * x;\n/* ..\n * .. Executable Statements ..\n *\n */\n   if( N == 0 ) return;\n\n   if( INCX == 1 ) { x = X; }\n   else\n   {\n      vx = (TYPE *)malloc( ATL_Cachelen + ATL_MulBySize( N ) );\n      ATL_assert( vx ); x = ATL_AlignPtr( vx );\n      Mjoin( PATL, copy )( N, X, INCX, x, 1 );\n   }\n\n#ifdef TREAL\n   if( ( TRANS == AtlasNoTrans ) || ( TRANS == AtlasConj ) )\n#else\n   if( TRANS == AtlasNoTrans )\n#endif\n   {\n      if( UPLO == AtlasUpper ) Mjoin( PATL, tpsvUN )( DIAG, N,    A,   1, x );\n      else                     Mjoin( PATL, tpsvLN )( DIAG, N,    A,   N, x );\n   }\n#ifdef TCPLX\n   else if( TRANS == AtlasConj )\n   {\n      if( UPLO == AtlasUpper ) Mjoin( PATL, tpsvUC )( DIAG, N,    A,   1, x );\n      else                     Mjoin( PATL, tpsvLC )( DIAG, N,    A,   N, x );\n   }\n#endif\n#ifdef TREAL\n   else\n#else\n   else if( TRANS == AtlasTrans )\n#endif\n   {\n      if( UPLO == AtlasUpper ) Mjoin( PATL, tpsvUT )( DIAG, N,    A,   1, x );\n      else                     Mjoin( PATL, tpsvLT )( DIAG, N,    A,   N, x );\n   }\n#ifdef TCPLX\n   else\n   {\n      if( UPLO == AtlasUpper ) Mjoin( PATL, tpsvUH )( DIAG, N,    A,   1, x );\n      else                     Mjoin( PATL, tpsvLH )( DIAG, N,    A,   N, x );\n   }\n#endif\n   if( vx ) { Mjoin( PATL, copy )( N, x, 1, X, INCX ); free( vx ); }\n/*\n * End of Mjoin( PATL, tpsv )\n */\n}", "path": "src\\blas\\level2\\ATL_tpsv.c", "repo_name": "cournape/atlas-nosse", "stars": 1, "license": "None", "language": "c", "size": 3510}
{"docstring": "/*\n * malloc/free pair that aligns data to align, but not to misalign\n */\n", "func_signal": "void *FA_malloc(size_t size, int align, int misalign)", "code": "{\n   if ((!misalign && align <= 8) || !size)\n      return(malloc(size));\n   else\n   {\n      allocQ = NewAlloc(size, allocQ, align, misalign);\n      return(allocQ->memA);\n   }\n}", "path": "interfaces\\blas\\F77\\testing\\axpbytst.c", "repo_name": "cournape/atlas-nosse", "stars": 1, "license": "None", "language": "c", "size": 3510}
{"docstring": "/*\n * malloc/free pair that aligns data to align, but not to misalign\n */\n", "func_signal": "void *FA_malloc(size_t size, int align, int misalign)", "code": "{\n   if ((!misalign && align <= 8) || !size)\n      return(malloc(size));\n   else\n   {\n      allocQ = NewAlloc(size, allocQ, align, misalign);\n      return(allocQ->memA);\n   }\n}", "path": "interfaces\\blas\\C\\testing\\axpbytst.c", "repo_name": "cournape/atlas-nosse", "stars": 1, "license": "None", "language": "c", "size": 3510}
{"docstring": "/* used for gbmv, gpmv and gpr.    */\n", "func_signal": "void Mjoin( PATL, gbmv )\n(\n   const enum ATLAS_TRANS     TRANS,\n   const int                  M,\n   const int                  N,\n   const int                  KL,\n   const int                  KU,\n   const SCALAR               ALPHA,\n   const TYPE                 * A,\n   const int                  LDA,\n   const TYPE                 * X,\n   const int                  INCX,\n   const SCALAR               BETA,\n   TYPE                       * Y,\n   const int                  INCY\n)", "code": "{\n/*\n * .. Local Variables ..\n */\n/* ..\n * .. Executable Statements ..\n *\n */\n   if( ( M == 0 ) || ( N == 0 ) ||\n       ( ( SCALAR_IS_ZERO( ALPHA ) ) && ( SCALAR_IS_ONE( BETA ) ) ) ) return;\n\n   if( SCALAR_IS_ZERO( ALPHA ) )\n   {\n      if( !( SCALAR_IS_ONE( BETA ) ) ) Mjoin( PATL, scal )( M, BETA, Y, INCY );\n      return;\n   }\n\n   Mjoin( PATL, refgbmv )( TRANS, M, N, KL, KU, ALPHA, A, LDA, X, INCX, BETA,\n                           Y, INCY );\n/*\n * End of Mjoin( PATL, gbmv )\n */\n}", "path": "src\\blas\\level2\\ATL_gbmv.c", "repo_name": "cournape/atlas-nosse", "stars": 1, "license": "None", "language": "c", "size": 3510}
{"docstring": "/*\n * open/close all files, so that ->real_file_size gets set\n */\n", "func_signal": "static int get_file_sizes(struct thread_data *td)", "code": "{\n\tstruct fio_file *f;\n\tunsigned int i;\n\tint err = 0;\n\n\tfor_each_file(td, f, i) {\n\t\tdprint(FD_FILE, \"get file size for %p/%d/%p\\n\", f, i,\n\t\t\t\t\t\t\t\tf->file_name);\n\n\t\tif (td_io_get_file_size(td, f)) {\n\t\t\tif (td->error != ENOENT) {\n\t\t\t\tlog_err(\"%s\\n\", td->verror);\n\t\t\t\terr = 1;\n\t\t\t}\n\t\t\tclear_error(td);\n\t\t}\n\n\t\tif (f->real_file_size == -1ULL && td->o.size)\n\t\t\tf->real_file_size = td->o.size / td->o.nr_files;\n\t}\n\n\treturn err;\n}", "path": "filesetup.c", "repo_name": "mr-dunqiu/fio", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 300}
{"docstring": "/*\n * This function returns the first node (in sort order) of the tree.\n */\n", "func_signal": "struct rb_node *rb_first(struct rb_root *root)", "code": "{\n\tstruct rb_node\t*n;\n\n\tn = root->rb_node;\n\tif (!n)\n\t\treturn NULL;\n\twhile (n->rb_left)\n\t\tn = n->rb_left;\n\treturn n;\n}", "path": "rbtree.c", "repo_name": "mr-dunqiu/fio", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 300}
{"docstring": "/*\n * Prepare for seperation of verify_header and checksum header\n */\n", "func_signal": "static inline unsigned int __hdr_size(int verify_type)", "code": "{\n\tunsigned int len = len;\n\n\tswitch (verify_type) {\n\tcase VERIFY_NONE:\n\tcase VERIFY_NULL:\n\t\tlen = 0;\n\t\tbreak;\n\tcase VERIFY_MD5:\n\t\tlen = sizeof(struct vhdr_md5);\n\t\tbreak;\n\tcase VERIFY_CRC64:\n\t\tlen = sizeof(struct vhdr_crc64);\n\t\tbreak;\n\tcase VERIFY_CRC32C:\n\tcase VERIFY_CRC32:\n\tcase VERIFY_CRC32C_INTEL:\n\t\tlen = sizeof(struct vhdr_crc32);\n\t\tbreak;\n\tcase VERIFY_CRC16:\n\t\tlen = sizeof(struct vhdr_crc16);\n\t\tbreak;\n\tcase VERIFY_CRC7:\n\t\tlen = sizeof(struct vhdr_crc7);\n\t\tbreak;\n\tcase VERIFY_SHA256:\n\t\tlen = sizeof(struct vhdr_sha256);\n\t\tbreak;\n\tcase VERIFY_SHA512:\n\t\tlen = sizeof(struct vhdr_sha512);\n\t\tbreak;\n\tcase VERIFY_META:\n\t\tlen = sizeof(struct vhdr_meta);\n\t\tbreak;\n\tcase VERIFY_SHA1:\n\t\tlen = sizeof(struct vhdr_sha1);\n\t\tbreak;\n\tdefault:\n\t\tlog_err(\"fio: unknown verify header!\\n\");\n\t\tassert(0);\n\t}\n\n\treturn len + sizeof(struct verify_header);\n}", "path": "verify.c", "repo_name": "mr-dunqiu/fio", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 300}
{"docstring": "/*\n * Retrieve 'len' bytes from the fifo, refilling if necessary.\n */\n", "func_signal": "static int trace_fifo_get(struct thread_data *td, struct fifo *fifo, int fd,\n\t\t\t  void *buf, unsigned int len)", "code": "{\n\tif (fifo_len(fifo) < len) {\n\t\tint ret = refill_fifo(td, fifo, fd);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn fifo_get(fifo, buf, len);\n}", "path": "blktrace.c", "repo_name": "mr-dunqiu/fio", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 300}
{"docstring": "/*\n * Open the files and setup files sizes, creating files if necessary.\n */\n", "func_signal": "int setup_files(struct thread_data *td)", "code": "{\n\tunsigned long long total_size, extend_size;\n\tstruct fio_file *f;\n\tunsigned int i;\n\tint err = 0, need_extend;\n\n\tdprint(FD_FILE, \"setup files\\n\");\n\n\tif (td->o.read_iolog_file)\n\t\treturn 0;\n\n\t/*\n\t * if ioengine defines a setup() method, it's responsible for\n\t * opening the files and setting f->real_file_size to indicate\n\t * the valid range for that file.\n\t */\n\tif (td->io_ops->setup)\n\t\terr = td->io_ops->setup(td);\n\telse\n\t\terr = get_file_sizes(td);\n\n\tif (err)\n\t\treturn err;\n\n\t/*\n\t * check sizes. if the files/devices do not exist and the size\n\t * isn't passed to fio, abort.\n\t */\n\ttotal_size = 0;\n\tfor_each_file(td, f, i) {\n\t\tif (f->real_file_size == -1ULL)\n\t\t\ttotal_size = -1ULL;\n\t\telse\n\t\t\ttotal_size += f->real_file_size;\n\t}\n\n\t/*\n\t * device/file sizes are zero and no size given, punt\n\t */\n\tif ((!total_size || total_size == -1ULL) && !td->o.size &&\n\t    !(td->io_ops->flags & FIO_NOIO) && !td->o.fill_device) {\n\t\tlog_err(\"%s: you need to specify size=\\n\", td->o.name);\n\t\ttd_verror(td, EINVAL, \"total_file_size\");\n\t\treturn 1;\n\t}\n\n\t/*\n\t * now file sizes are known, so we can set ->io_size. if size= is\n\t * not given, ->io_size is just equal to ->real_file_size. if size\n\t * is given, ->io_size is size / nr_files.\n\t */\n\textend_size = total_size = 0;\n\tneed_extend = 0;\n\tfor_each_file(td, f, i) {\n\t\tf->file_offset = td->o.start_offset;\n\n\t\tif (!td->o.file_size_low) {\n\t\t\t/*\n\t\t\t * no file size range given, file size is equal to\n\t\t\t * total size divided by number of files. if that is\n\t\t\t * zero, set it to the real file size.\n\t\t\t */\n\t\t\tf->io_size = td->o.size / td->o.nr_files;\n\t\t\tif (!f->io_size)\n\t\t\t\tf->io_size = f->real_file_size - f->file_offset;\n\t\t} else if (f->real_file_size < td->o.file_size_low ||\n\t\t\t   f->real_file_size > td->o.file_size_high) {\n\t\t\tif (f->file_offset > td->o.file_size_low)\n\t\t\t\tgoto err_offset;\n\t\t\t/*\n\t\t\t * file size given. if it's fixed, use that. if it's a\n\t\t\t * range, generate a random size in-between.\n\t\t\t */\n\t\t\tif (td->o.file_size_low == td->o.file_size_high) {\n\t\t\t\tf->io_size = td->o.file_size_low\n\t\t\t\t\t\t- f->file_offset;\n\t\t\t} else {\n\t\t\t\tf->io_size = get_rand_file_size(td)\n\t\t\t\t\t\t- f->file_offset;\n\t\t\t}\n\t\t} else\n\t\t\tf->io_size = f->real_file_size - f->file_offset;\n\n\t\tif (f->io_size == -1ULL)\n\t\t\ttotal_size = -1ULL;\n\t\telse\n\t\t\ttotal_size += f->io_size;\n\n\t\tif (f->filetype == FIO_TYPE_FILE &&\n\t\t    (f->io_size + f->file_offset) > f->real_file_size &&\n\t\t    !(td->io_ops->flags & FIO_DISKLESSIO)) {\n\t\t\tif (!td->o.create_on_open) {\n\t\t\t\tneed_extend++;\n\t\t\t\textend_size += (f->io_size + f->file_offset);\n\t\t\t} else\n\t\t\t\tf->real_file_size = f->io_size + f->file_offset;\n\t\t\tfio_file_set_extend(f);\n\t\t}\n\t}\n\n\tif (!td->o.size || td->o.size > total_size)\n\t\ttd->o.size = total_size;\n\n\t/*\n\t * See if we need to extend some files\n\t */\n\tif (need_extend) {\n\t\ttemp_stall_ts = 1;\n\t\tif (!terse_output)\n\t\t\tlog_info(\"%s: Laying out IO file(s) (%u file(s) /\"\n\t\t\t\t \" %LuMB)\\n\", td->o.name, need_extend,\n\t\t\t\t\textend_size >> 20);\n\n\t\tfor_each_file(td, f, i) {\n\t\t\tunsigned long long old_len = -1ULL, extend_len = -1ULL;\n\n\t\t\tif (!fio_file_extend(f))\n\t\t\t\tcontinue;\n\n\t\t\tassert(f->filetype == FIO_TYPE_FILE);\n\t\t\tfio_file_clear_extend(f);\n\t\t\tif (!td->o.fill_device) {\n\t\t\t\told_len = f->real_file_size;\n\t\t\t\textend_len = f->io_size + f->file_offset - old_len;\n\t\t\t}\n\t\t\tf->real_file_size = (f->io_size + f->file_offset);\n\t\t\terr = extend_file(td, f);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\n\t\t\terr = __file_invalidate_cache(td, f, old_len,\n\t\t\t\t\t\t\t\textend_len);\n\t\t\tclose(f->fd);\n\t\t\tf->fd = -1;\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t\ttemp_stall_ts = 0;\n\t}\n\n\tif (err)\n\t\treturn err;\n\n\tif (!td->o.zone_size)\n\t\ttd->o.zone_size = td->o.size;\n\n\t/*\n\t * iolog already set the total io size, if we read back\n\t * stored entries.\n\t */\n\tif (!td->o.read_iolog_file)\n\t\ttd->total_io_size = td->o.size * td->o.loops;\n\treturn 0;\nerr_offset:\n\tlog_err(\"%s: you need to specify valid offset=\\n\", td->o.name);\n\treturn 1;\n}", "path": "filesetup.c", "repo_name": "mr-dunqiu/fio", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 300}
{"docstring": "/*\n * busy looping version for the last few usec\n */\n", "func_signal": "void usec_spin(unsigned int usec)", "code": "{\n\tstruct timeval start;\n\n\tfio_gettime(&start, NULL);\n\twhile (utime_since_now(&start) < usec)\n\t\tnop;\n}", "path": "time.c", "repo_name": "mr-dunqiu/fio", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 300}
{"docstring": "/*\n * Check that we transferred all bytes, or saw an error, etc\n */\n", "func_signal": "static int fio_vsyncio_end(struct thread_data *td, ssize_t bytes)", "code": "{\n\tstruct syncio_data *sd = td->io_ops->data;\n\tstruct io_u *io_u;\n\tunsigned int i;\n\tint err;\n\n\t/*\n\t * transferred everything, perfect\n\t */\n\tif (bytes == sd->queued_bytes)\n\t\treturn 0;\n\n\terr = errno;\n\tfor (i = 0; i < sd->queued; i++) {\n\t\tio_u = sd->io_us[i];\n\n\t\tif (bytes == -1) {\n\t\t\tio_u->error = err;\n\t\t} else {\n\t\t\tunsigned int this_io;\n\n\t\t\tthis_io = bytes;\n\t\t\tif (this_io > io_u->xfer_buflen)\n\t\t\t\tthis_io = io_u->xfer_buflen;\n\n\t\t\tio_u->resid = io_u->xfer_buflen - this_io;\n\t\t\tio_u->error = 0;\n\t\t\tbytes -= this_io;\n\t\t}\n\t}\n\n\tif (bytes == -1) {\n\t\ttd_verror(td, err, \"xfer vsync\");\n\t\treturn -err;\n\t}\n\n\treturn 0;\n}", "path": "engines\\sync.c", "repo_name": "mr-dunqiu/fio", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 300}
{"docstring": "/*\n * Returns the index that matches the filename, or -1 if not there\n */\n", "func_signal": "int get_fileno(struct thread_data *td, const char *fname)", "code": "{\n\tstruct fio_file *f;\n\tunsigned int i;\n\n\tfor_each_file(td, f, i)\n\t\tif (!strcmp(f->file_name, fname))\n\t\t\treturn i;\n\n\treturn -1;\n}", "path": "filesetup.c", "repo_name": "mr-dunqiu/fio", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 300}
{"docstring": "/*\n * The ->queue() hook is responsible for initiating io on the io_u\n * being passed in. If the io engine is a synchronous one, io may complete\n * before ->queue() returns. Required.\n *\n * The io engine must transfer in the direction noted by io_u->ddir\n * to the buffer pointed to by io_u->xfer_buf for as many bytes as\n * io_u->xfer_buflen. Residual data count may be set in io_u->residual\n * for a short read/write.\n */\n", "func_signal": "static int fio_skeleton_queue(struct thread_data *td, struct io_u *io_u)", "code": "{\n\t/*\n\t * Double sanity check to catch errant write on a readonly setup\n\t */\n\tfio_ro_check(td, io_u);\n\n\t/*\n\t * Could return FIO_Q_QUEUED for a queued request,\n\t * FIO_Q_COMPLETED for a completed request, and FIO_Q_BUSY\n\t * if we could queue no more at this point (you'd have to\n\t * define ->commit() to handle that.\n\t */\n\treturn FIO_Q_COMPLETED;\n}", "path": "engines\\skeleton_external.c", "repo_name": "mr-dunqiu/fio", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 300}
{"docstring": "/*\n * Just discard the pdu by seeking past it.\n */\n", "func_signal": "static int discard_pdu(struct thread_data *td, struct fifo *fifo, int fd,\n\t\t       struct blk_io_trace *t)", "code": "{\n\tif (t->pdu_len == 0)\n\t\treturn 0;\n\n\tdprint(FD_BLKTRACE, \"discard pdu len %u\\n\", t->pdu_len);\n\treturn trace_fifo_get(td, fifo, fd, NULL, t->pdu_len);\n}", "path": "blktrace.c", "repo_name": "mr-dunqiu/fio", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 300}
{"docstring": "/*\n * Check if this is a blktrace binary data file. We read a single trace\n * into memory and check for the magic signature.\n */\n", "func_signal": "int is_blktrace(const char *filename)", "code": "{\n\tstruct blk_io_trace t;\n\tint fd, ret;\n\n\tfd = open(filename, O_RDONLY);\n\tif (fd < 0)\n\t\treturn 0;\n\n\tret = read(fd, &t, sizeof(t));\n\tclose(fd);\n\n\tif (ret < 0) {\n\t\tperror(\"read blktrace\");\n\t\treturn 0;\n\t} else if (ret != sizeof(t)) {\n\t\tlog_err(\"fio: short read on blktrace file\\n\");\n\t\treturn 0;\n\t}\n\n\tif ((t.magic & 0xffffff00) == BLK_IO_TRACE_MAGIC)\n\t\treturn 1;\n\n\treturn 0;\n}", "path": "blktrace.c", "repo_name": "mr-dunqiu/fio", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 300}
{"docstring": "/*\n * We only care for queue traces, most of the others are side effects\n * due to internal workings of the block layer.\n */\n", "func_signal": "static void handle_trace(struct thread_data *td, struct blk_io_trace *t,\n\t\t\t unsigned long long ttime, unsigned long *ios,\n\t\t\t unsigned int *bs)", "code": "{\n\tif ((t->action & 0xffff) != __BLK_TA_QUEUE)\n\t\treturn;\n\tif (t->action & BLK_TC_ACT(BLK_TC_PC))\n\t\treturn;\n\n\tif (t->action & BLK_TC_ACT(BLK_TC_NOTIFY))\n\t\thandle_trace_notify(t);\n\telse\n\t\thandle_trace_fs(td, t, ttime, ios, bs);\n}", "path": "blktrace.c", "repo_name": "mr-dunqiu/fio", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 300}
{"docstring": "/*\n * fill body of io_u->buf with random data and add a header with the\n * crc32 or md5 sum of that data.\n */\n", "func_signal": "void populate_verify_io_u(struct thread_data *td, struct io_u *io_u)", "code": "{\n\tstruct verify_header *hdr;\n\tvoid *p = io_u->buf, *data;\n\tunsigned int hdr_inc, data_len, header_num = 0;\n\n\tif (td->o.verify == VERIFY_NULL)\n\t\treturn;\n\n\tfill_pattern(td, p, io_u->buflen);\n\n\thdr_inc = io_u->buflen;\n\tif (td->o.verify_interval)\n\t\thdr_inc = td->o.verify_interval;\n\n\tfor (; p < io_u->buf + io_u->buflen; p += hdr_inc) {\n\t\thdr = p;\n\n\t\thdr->fio_magic = FIO_HDR_MAGIC;\n\t\thdr->verify_type = td->o.verify;\n\t\thdr->len = hdr_inc;\n\t\tdata_len = hdr_inc - hdr_size(hdr);\n\n\t\tdata = p + hdr_size(hdr);\n\t\tswitch (td->o.verify) {\n\t\tcase VERIFY_MD5:\n\t\t\tdprint(FD_VERIFY, \"fill md5 io_u %p, len %u\\n\",\n\t\t\t\t\t\t\tio_u, hdr->len);\n\t\t\tfill_md5(hdr, data, data_len);\n\t\t\tbreak;\n\t\tcase VERIFY_CRC64:\n\t\t\tdprint(FD_VERIFY, \"fill crc64 io_u %p, len %u\\n\",\n\t\t\t\t\t\t\tio_u, hdr->len);\n\t\t\tfill_crc64(hdr, data, data_len);\n\t\t\tbreak;\n\t\tcase VERIFY_CRC32C:\n\t\tcase VERIFY_CRC32C_INTEL:\n\t\t\tdprint(FD_VERIFY, \"fill crc32c io_u %p, len %u\\n\",\n\t\t\t\t\t\t\tio_u, hdr->len);\n\t\t\tfill_crc32c(hdr, data, data_len);\n\t\t\tbreak;\n\t\tcase VERIFY_CRC32:\n\t\t\tdprint(FD_VERIFY, \"fill crc32 io_u %p, len %u\\n\",\n\t\t\t\t\t\t\tio_u, hdr->len);\n\t\t\tfill_crc32(hdr, data, data_len);\n\t\t\tbreak;\n\t\tcase VERIFY_CRC16:\n\t\t\tdprint(FD_VERIFY, \"fill crc16 io_u %p, len %u\\n\",\n\t\t\t\t\t\t\tio_u, hdr->len);\n\t\t\tfill_crc16(hdr, data, data_len);\n\t\t\tbreak;\n\t\tcase VERIFY_CRC7:\n\t\t\tdprint(FD_VERIFY, \"fill crc7 io_u %p, len %u\\n\",\n\t\t\t\t\t\t\tio_u, hdr->len);\n\t\t\tfill_crc7(hdr, data, data_len);\n\t\t\tbreak;\n\t\tcase VERIFY_SHA256:\n\t\t\tdprint(FD_VERIFY, \"fill sha256 io_u %p, len %u\\n\",\n\t\t\t\t\t\t\tio_u, hdr->len);\n\t\t\tfill_sha256(hdr, data, data_len);\n\t\t\tbreak;\n\t\tcase VERIFY_SHA512:\n\t\t\tdprint(FD_VERIFY, \"fill sha512 io_u %p, len %u\\n\",\n\t\t\t\t\t\t\tio_u, hdr->len);\n\t\t\tfill_sha512(hdr, data, data_len);\n\t\t\tbreak;\n\t\tcase VERIFY_META:\n\t\t\tdprint(FD_VERIFY, \"fill meta io_u %p, len %u\\n\",\n\t\t\t\t\t\t\tio_u, hdr->len);\n\t\t\tfill_meta(hdr, td, io_u, header_num);\n\t\t\tbreak;\n\t\tcase VERIFY_SHA1:\n\t\t\tdprint(FD_VERIFY, \"fill sha1 io_u %p, len %u\\n\",\n\t\t\t\t\t\t\tio_u, hdr->len);\n\t\t\tfill_sha1(hdr, data, data_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_err(\"fio: bad verify type: %d\\n\", td->o.verify);\n\t\t\tassert(0);\n\t\t}\n\t\tif (td->o.verify_offset)\n\t\t\tmemswp(p, p + td->o.verify_offset, hdr_size(hdr));\n\t\theader_num++;\n\t}\n}", "path": "verify.c", "repo_name": "mr-dunqiu/fio", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 300}
{"docstring": "/*\n * fifo refill frontend, to avoid reading data in trace sized bites\n */\n", "func_signal": "static int refill_fifo(struct thread_data *td, struct fifo *fifo, int fd)", "code": "{\n\tchar buf[TRACE_FIFO_SIZE];\n\tunsigned int total;\n\tint ret;\n\n\ttotal = sizeof(buf);\n\tif (total > fifo_room(fifo))\n\t\ttotal = fifo_room(fifo);\n\n\tret = read(fd, buf, total);\n\tif (ret < 0) {\n\t\ttd_verror(td, errno, \"read blktrace file\");\n\t\treturn -1;\n\t}\n\n\tif (ret > 0)\n\t\tret = fifo_put(fifo, buf, ret);\n\n\tdprint(FD_BLKTRACE, \"refill: filled %d bytes\\n\", ret);\n\treturn ret;\n}", "path": "blktrace.c", "repo_name": "mr-dunqiu/fio", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 300}
{"docstring": "/*\n * For log usage, where we add/open/close files automatically\n */\n", "func_signal": "void free_release_files(struct thread_data *td)", "code": "{\n\tclose_files(td);\n\ttd->files_index = 0;\n\ttd->nr_normal_files = 0;\n}", "path": "filesetup.c", "repo_name": "mr-dunqiu/fio", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 300}
{"docstring": "/*\n * Load a blktrace file by reading all the blk_io_trace entries, and storing\n * them as io_pieces like the fio text version would do.\n */\n", "func_signal": "int load_blktrace(struct thread_data *td, const char *filename)", "code": "{\n\tunsigned long long ttime, delay;\n\tstruct blk_io_trace t;\n\tunsigned long ios[2], skipped_writes;\n\tunsigned int cpu;\n\tunsigned int rw_bs[2];\n\tstruct fifo *fifo;\n\tint fd;\n\n\tfd = open(filename, O_RDONLY);\n\tif (fd < 0) {\n\t\ttd_verror(td, errno, \"open blktrace file\");\n\t\treturn 1;\n\t}\n\n\tfifo = fifo_alloc(TRACE_FIFO_SIZE);\n\n\ttd->o.size = 0;\n\n\tcpu = 0;\n\tttime = 0;\n\tios[0] = ios[1] = 0;\n\trw_bs[0] = rw_bs[1] = 0;\n\tskipped_writes = 0;\n\tdo {\n\t\tint ret = trace_fifo_get(td, fifo, fd, &t, sizeof(t));\n\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t\telse if (!ret)\n\t\t\tbreak;\n\t\telse if (ret < (int) sizeof(t)) {\n\t\t\tlog_err(\"fio: short fifo get\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((t.magic & 0xffffff00) != BLK_IO_TRACE_MAGIC) {\n\t\t\tlog_err(\"fio: bad magic in blktrace data: %x\\n\",\n\t\t\t\t\t\t\t\tt.magic);\n\t\t\tgoto err;\n\t\t}\n\t\tif ((t.magic & 0xff) != BLK_IO_TRACE_VERSION) {\n\t\t\tlog_err(\"fio: bad blktrace version %d\\n\",\n\t\t\t\t\t\t\t\tt.magic & 0xff);\n\t\t\tgoto err;\n\t\t}\n\t\tret = discard_pdu(td, fifo, fd, &t);\n\t\tif (ret < 0) {\n\t\t\ttd_verror(td, ret, \"blktrace lseek\");\n\t\t\tgoto err;\n\t\t} else if (t.pdu_len != ret) {\n\t\t\tlog_err(\"fio: discarded %d of %d\\n\", ret, t.pdu_len);\n\t\t\tgoto err;\n\t\t}\n\t\tif ((t.action & BLK_TC_ACT(BLK_TC_NOTIFY)) == 0) {\n\t\t\tif (!ttime) {\n\t\t\t\tttime = t.time;\n\t\t\t\tcpu = t.cpu;\n\t\t\t}\n\n\t\t\tdelay = 0;\n\t\t\tif (cpu == t.cpu)\n\t\t\t\tdelay = t.time - ttime;\n\t\t\tif ((t.action & BLK_TC_ACT(BLK_TC_WRITE)) && read_only)\n\t\t\t\tskipped_writes++;\n\t\t\telse\n\t\t\t\thandle_trace(td, &t, delay, ios, rw_bs);\n\n\t\t\tttime = t.time;\n\t\t\tcpu = t.cpu;\n\t\t} else {\n\t\t\tdelay = 0;\n\t\t\thandle_trace(td, &t, delay, ios, rw_bs);\n\t\t}\n\t} while (1);\n\n\tfifo_free(fifo);\n\tclose(fd);\n\n\tif (skipped_writes)\n\t\tlog_err(\"fio: %s skips replay of %lu writes due to read-only\\n\",\n\t\t\t\t\t\ttd->o.name, skipped_writes);\n\n\tif (!ios[DDIR_READ] && !ios[DDIR_WRITE]) {\n\t\tlog_err(\"fio: found no ios in blktrace data\\n\");\n\t\treturn 1;\n\t} else if (ios[DDIR_READ] && !ios[DDIR_READ]) {\n\t\ttd->o.td_ddir = TD_DDIR_READ;\n\t\ttd->o.max_bs[DDIR_READ] = rw_bs[DDIR_READ];\n\t} else if (!ios[DDIR_READ] && ios[DDIR_WRITE]) {\n\t\ttd->o.td_ddir = TD_DDIR_WRITE;\n\t\ttd->o.max_bs[DDIR_WRITE] = rw_bs[DDIR_WRITE];\n\t} else {\n\t\ttd->o.td_ddir = TD_DDIR_RW;\n\t\ttd->o.max_bs[DDIR_READ] = rw_bs[DDIR_READ];\n\t\ttd->o.max_bs[DDIR_WRITE] = rw_bs[DDIR_WRITE];\n\t}\n\n\t/*\n\t * We need to do direct/raw ios to the device, to avoid getting\n\t * read-ahead in our way.\n\t */\n\ttd->o.odirect = 1;\n\n\treturn 0;\nerr:\n\tclose(fd);\n\tfifo_free(fifo);\n\treturn 1;\n}", "path": "blktrace.c", "repo_name": "mr-dunqiu/fio", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 300}
{"docstring": "/*\n * Store blk_io_trace data in an ipo for later retrieval.\n */\n", "func_signal": "static void store_ipo(struct thread_data *td, unsigned long long offset,\n\t\t      unsigned int bytes, int rw, unsigned long long ttime)", "code": "{\n\tstruct io_piece *ipo = malloc(sizeof(*ipo));\n\n\tmemset(ipo, 0, sizeof(*ipo));\n\tINIT_FLIST_HEAD(&ipo->list);\n\t/*\n\t * the 512 is wrong here, it should be the hardware sector size...\n\t */\n\tipo->offset = offset * 512;\n\tipo->len = bytes;\n\tipo->delay = ttime / 1000;\n\tif (rw)\n\t\tipo->ddir = DDIR_WRITE;\n\telse\n\t\tipo->ddir = DDIR_READ;\n\n\tdprint(FD_BLKTRACE, \"store ddir=%d, off=%llu, len=%lu, delay=%lu\\n\",\n\t\t\t\t\t\t\tipo->ddir, ipo->offset,\n\t\t\t\t\t\t\tipo->len, ipo->delay);\n\tqueue_io_piece(td, ipo);\n}", "path": "blktrace.c", "repo_name": "mr-dunqiu/fio", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 300}
{"docstring": "/*\n * Setup the buffer area we need for io.\n */\n", "func_signal": "int allocate_io_mem(struct thread_data *td)", "code": "{\n\tunsigned int total_mem;\n\tint ret = 0;\n\n\tif (td->io_ops->flags & FIO_NOIO)\n\t\treturn 0;\n\n\ttotal_mem = td->orig_buffer_size;\n\n\tif (td->o.odirect || td->o.mem_align) {\n\t\ttotal_mem += page_mask;\n\t\tif (td->o.mem_align && td->o.mem_align > page_size)\n\t\t\ttotal_mem += td->o.mem_align - page_size;\n\t}\n\n\tif (td->o.mem_type == MEM_MALLOC)\n\t\tret = alloc_mem_malloc(td, total_mem);\n\telse if (td->o.mem_type == MEM_SHM || td->o.mem_type == MEM_SHMHUGE)\n\t\tret = alloc_mem_shm(td, total_mem);\n\telse if (td->o.mem_type == MEM_MMAP || td->o.mem_type == MEM_MMAPHUGE)\n\t\tret = alloc_mem_mmap(td, total_mem);\n\telse {\n\t\tlog_err(\"fio: bad mem type: %d\\n\", td->o.mem_type);\n\t\tret = 1;\n\t}\n\n\tif (ret)\n\t\ttd_verror(td, ENOMEM, \"iomem allocation\");\n\n\treturn ret;\n}", "path": "memory.c", "repo_name": "mr-dunqiu/fio", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 300}
{"docstring": "/*\n * Push IO verification to a separate thread\n */\n", "func_signal": "int verify_io_u_async(struct thread_data *td, struct io_u *io_u)", "code": "{\n\tif (io_u->file)\n\t\tput_file_log(td, io_u->file);\n\n\tio_u->file = NULL;\n\n\tpthread_mutex_lock(&td->io_u_lock);\n\tflist_del(&io_u->list);\n\tflist_add_tail(&io_u->list, &td->verify_list);\n\tpthread_mutex_unlock(&td->io_u_lock);\n\n\tpthread_cond_signal(&td->verify_cond);\n\tio_u->flags |= IO_U_F_FREE_DEF;\n\treturn 0;\n}", "path": "verify.c", "repo_name": "mr-dunqiu/fio", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 300}
{"docstring": "/*\n * Leaves f->fd open on success, caller must close\n */\n", "func_signal": "static int extend_file(struct thread_data *td, struct fio_file *f)", "code": "{\n\tint r, new_layout = 0, unlink_file = 0, flags;\n\tunsigned long long left;\n\tunsigned int bs;\n\tchar *b;\n\n\tif (read_only) {\n\t\tlog_err(\"fio: refusing extend of file due to read-only\\n\");\n\t\treturn 0;\n\t}\n\n\t/*\n\t * check if we need to lay the file out complete again. fio\n\t * does that for operations involving reads, or for writes\n\t * where overwrite is set\n\t */\n\tif (td_read(td) || (td_write(td) && td->o.overwrite) ||\n\t    (td_write(td) && td->io_ops->flags & FIO_NOEXTEND))\n\t\tnew_layout = 1;\n\tif (td_write(td) && !td->o.overwrite)\n\t\tunlink_file = 1;\n\n\tif (unlink_file || new_layout) {\n\t\tdprint(FD_FILE, \"layout unlink %s\\n\", f->file_name);\n\t\tif ((unlink(f->file_name) < 0) && (errno != ENOENT)) {\n\t\t\ttd_verror(td, errno, \"unlink\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tflags = O_WRONLY | O_CREAT;\n\tif (new_layout)\n\t\tflags |= O_TRUNC;\n\n\tdprint(FD_FILE, \"open file %s, flags %x\\n\", f->file_name, flags);\n\tf->fd = open(f->file_name, flags, 0644);\n\tif (f->fd < 0) {\n\t\ttd_verror(td, errno, \"open\");\n\t\treturn 1;\n\t}\n\n\tif (!new_layout)\n\t\tgoto done;\n\n\t/*\n\t * The size will be -1ULL when fill_device is used, so don't truncate\n\t * or fallocate this file, just write it\n\t */\n\tif (!td->o.fill_device) {\n\t\tdprint(FD_FILE, \"truncate file %s, size %llu\\n\", f->file_name,\n\t\t\t\t\t\t\tf->real_file_size);\n\t\tif (ftruncate(f->fd, f->real_file_size) == -1) {\n\t\t\ttd_verror(td, errno, \"ftruncate\");\n\t\t\tgoto err;\n\t\t}\n\n#ifdef FIO_HAVE_FALLOCATE\n\t\tdprint(FD_FILE, \"fallocate file %s, size %llu\\n\", f->file_name,\n\t\t\t\t\t\t\tf->real_file_size);\n\t\tr = posix_fallocate(f->fd, 0, f->real_file_size);\n\t\tif (r < 0) {\n\t\t\tlog_err(\"fio: posix_fallocate fails: %s\\n\",\n\t\t\t\t\tstrerror(-r));\n\t\t}\n#endif\n\t}\n\n\tb = malloc(td->o.max_bs[DDIR_WRITE]);\n\tmemset(b, 0, td->o.max_bs[DDIR_WRITE]);\n\n\tleft = f->real_file_size;\n\twhile (left && !td->terminate) {\n\t\tbs = td->o.max_bs[DDIR_WRITE];\n\t\tif (bs > left)\n\t\t\tbs = left;\n\n\t\tr = write(f->fd, b, bs);\n\n\t\tif (r > 0) {\n\t\t\tleft -= r;\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (r < 0) {\n\t\t\t\tint __e = errno;\n\n\t\t\t\tif (__e == ENOSPC) {\n\t\t\t\t\tif (td->o.fill_device)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tlog_info(\"fio: ENOSPC on laying out \"\n\t\t\t\t\t\t \"file, stopping\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttd_verror(td, errno, \"write\");\n\t\t\t} else\n\t\t\t\ttd_verror(td, EIO, \"write\");\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (td->terminate) {\n\t\tdprint(FD_FILE, \"terminate unlink %s\\n\", f->file_name);\n\t\tunlink(f->file_name);\n\t} else if (td->o.create_fsync) {\n\t\tif (fsync(f->fd) < 0) {\n\t\t\ttd_verror(td, errno, \"fsync\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\tif (td->o.fill_device && !td_write(td)) {\n\t\tfio_file_clear_size_known(f);\n\t\tif (td_io_get_file_size(td, f))\n\t\t\tgoto err;\n\t\tif (f->io_size > f->real_file_size)\n\t\t\tf->io_size = f->real_file_size;\n\t}\n\n\tfree(b);\ndone:\n\treturn 0;\nerr:\n\tclose(f->fd);\n\tf->fd = -1;\n\treturn 1;\n}", "path": "filesetup.c", "repo_name": "mr-dunqiu/fio", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 300}
{"docstring": "/* If t is a cast expression, return the value without the cast.  */\n", "func_signal": "static tree substitute_cast_expr(struct statement *t)", "code": "{\n#if 0\n\tif (TREE_CODE(t) == CONVERT_EXPR || TREE_CODE(t) == NOP_EXPR)\n\t\treturn TREE_OPERAND(t, 0);\n#endif\n\n\treturn NULL;\n}", "path": "tree-match.c", "repo_name": "mnagy/mysparse", "stars": 0, "license": "None", "language": "c", "size": 108}
{"docstring": "/* Check whether a variable is a temporary introduced by the compiler.  */\n", "func_signal": "static bool is_tmp_var(struct statement *var)", "code": "{\n\treturn false;\n#if 0\n\tconst char *name;\n\tif (TREE_CODE(var) != VAR_DECL)\n\t\treturn false;\n\n\t/* Artificial decls like return values have no name, so don't get hung.  */\n\tif (!DECL_NAME(var))\n\t\treturn true;\n\n\tname = IDENTIFIER_POINTER(DECL_NAME(var));\n\treturn !strncmp(name, \"D.\", 2) || strchr(name, '.');\n#endif\n}", "path": "tree-match.c", "repo_name": "mnagy/mysparse", "stars": 0, "license": "None", "language": "c", "size": 108}
{"docstring": "/* Match a tree against an atomic pattern with named holes.  */\n", "func_signal": "bool tree_match(struct statement *t, const char *fmt, cfg_node ctx_node)", "code": "{\n\tpatt_info patt;\n\tbool res;\n\thole *old_global_holes = save_global_holes();\n\n\tpatt.args_ptr = NULL;\n\tpatt.format_spec = fmt;\n\treset_local_holes();\n\tres = match_tree_pattinfo(t, &patt, \"\", ctx_node);\n\n\t/* nothing left in the pattern ? */\n\tif (res && (*patt.format_spec == '\\0'))\n\t\treturn true;\n\telse {\n\t\trestore_global_holes(old_global_holes);\t/* unbind global holes */\n\t\treturn false;\n\t}\n}", "path": "tree-match.c", "repo_name": "mnagy/mysparse", "stars": 0, "license": "None", "language": "c", "size": 108}
{"docstring": "/* Unbind all global variables.  */\n", "func_signal": "void reset_global_holes(void)", "code": "{\n\tint i;\n\tfor (i = 0; i < GLOBAL_MAX; i++) {\n\t\tglobal_holes[i].tree = NULL;\n\t\tglobal_holes[i].ctx = NULL;\n\t}\n}", "path": "tree-match.c", "repo_name": "mnagy/mysparse", "stars": 0, "license": "None", "language": "c", "size": 108}
{"docstring": "/* Match a tree with a pattern with anonymous holes, and bind the\n   corresponding subtrees to the list of extra arguments.  Returns\n   true if the tree completely matched the pattern, false otherwise.\n   Even on unsuccessful match, some holes might be filled in.  */\n", "func_signal": "bool tree_scanf(struct statement *t, const char *fmt, cfg_node ctx_node, ...)", "code": "{\n\tpatt_info patt;\n\tva_list ap;\n\tbool res;\n\n\tva_start(ap, ctx_node);\n\tpatt.args_ptr = &ap;\n\tpatt.format_spec = fmt;\n\tres = match_tree_pattinfo(t, &patt, \"\", ctx_node);\n\tva_end(ap);\n\n\t/* nothing left in the pattern ? */\n\tif (res && (*patt.format_spec == '\\0'))\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "path": "tree-match.c", "repo_name": "mnagy/mysparse", "stars": 0, "license": "None", "language": "c", "size": 108}
{"docstring": "/* Unbind all local variables.  */\n", "func_signal": "void reset_local_holes(void)", "code": "{\n\tint i;\n\tfor (i = 0; i < LOCAL_MAX; i++) {\n\t\tlocal_holes[i].tree = NULL;\n\t\tlocal_holes[i].ctx = NULL;\n\t}\n}", "path": "tree-match.c", "repo_name": "mnagy/mysparse", "stars": 0, "license": "None", "language": "c", "size": 108}
{"docstring": "/* Check if two trees are equal, modulo casts and substitutions of\n   tmp vars with their values.  */\n", "func_signal": "static bool\ntree_equal_mod_tmps(struct statement *t1, struct statement *t2, cfg_node ctx_node1, cfg_node ctx_node2)", "code": "{\n\t//struct statement *val;\n\n\tif ((!t1 || !t2))\n\t\treturn (t1 == t2);\n\n\treturn tree_equal(t1, t2, ctx_node1, ctx_node2);\n#if 0\n\treturn (tree_equal(t1, t2, ctx_node1, ctx_node2)\n\t\t|| ((val = substitute_tmp_var(t1, ctx_node1, false)) != NULL\n\t\t    && tree_equal_mod_tmps(val, t2, ctx_node1, ctx_node2))\n\t\t|| ((val = substitute_tmp_var(t2, ctx_node2, false)) != NULL\n\t\t    && tree_equal_mod_tmps(t1, val, ctx_node1, ctx_node2))\n\t\t|| ((val = substitute_cast_expr(t1)) != NULL\n\t\t    && tree_equal_mod_tmps(val, t2, ctx_node1, ctx_node2))\n\t\t|| ((val = substitute_cast_expr(t2)) != NULL\n\t\t    && tree_equal_mod_tmps(t1, val, ctx_node1, ctx_node2)));\n#endif\n}", "path": "tree-match.c", "repo_name": "mnagy/mysparse", "stars": 0, "license": "None", "language": "c", "size": 108}
{"docstring": "/* Restore the values of all global variables from a buffer.  */\n", "func_signal": "void restore_global_holes(hole_p saved)", "code": "{\n\tmemcpy(global_holes, saved, sizeof(global_holes));\n\tfree(saved);\n}", "path": "tree-match.c", "repo_name": "mnagy/mysparse", "stars": 0, "license": "None", "language": "c", "size": 108}
{"docstring": "/* Worker function for tree_equal_mod_tmps.  */\n", "func_signal": "static bool tree_equal(struct statement *t1, struct statement *t2, cfg_node ctx_node1, cfg_node ctx_node2)", "code": "{\n\tstruct tree_chunk_list *chunks1 = NULL;\n\tstruct tree_chunk_list *chunks2 = NULL;\n\tstruct tree_chunk chunk1, chunk2;\n\tint len1, len2, i;\n\tbool res = false;\n\n\tif ((!t1 || !t2))\n\t\treturn (t1 == t2);\n\n\tif (t1 == t2)\n\t\treturn true;\n\n\tchunks1 = lazy_dump_generic_node(t1);\n\tchunks2 = lazy_dump_generic_node(t2);\n\n\tlen1 = tree_chunk_list_size(chunks1);\n\tlen2 = tree_chunk_list_size(chunks2);\n\n\tif (len1 != len2)\n\t\tgoto mismatch;\n\n\t/* XXX: This loop will iterate through tree chunks and\n\t * compare them. I think that with sparse, we could just\n\t * write a function to compare the trees and be done with it.\n\t */\n\tfor (i = 0; VEC_iterate(tree_chunk, chunks1, i, chunk1); i++) {\n\t\tchunk2 = VEC_index(tree_chunk, chunks2, i);\n\n\t\tif (((chunk1->t || chunk2->t)\n\t\t     && (!(chunk1->t && chunk2->t)\n\t\t\t || !tree_equal_mod_tmps(chunk1->t, chunk2->t,\n\t\t\t\t\t\t ctx_node1, ctx_node2)))\n\t\t    || ((chunk1->s || chunk2->s)\n\t\t\t&& (!(chunk1->s && chunk2->s)\n\t\t\t    || strcmp(chunk1->s, chunk2->s)))\n\t\t    || (chunk1->c != chunk2->c))\n\t\t\tgoto mismatch;\n\t}\n\n\tres = true;\n mismatch:\n\tpp_free_list(chunks1);\n\tpp_free_list(chunks2);\n\treturn res;\n}", "path": "tree-match.c", "repo_name": "mnagy/mysparse", "stars": 0, "license": "None", "language": "c", "size": 108}
{"docstring": "/* If t is a temporary and you can find its def from current node\n   upwards in the same block, (including the current node or not),\n   return its value; otherwise return NULL.  INCLUDING_CRT is set to\n   true on recursive calls.  */\n", "func_signal": "static struct statement *substitute_tmp_var(struct statement *var, cfg_node ctx_node, bool including_crt)", "code": "{\n\treturn NULL;\n#if 0\n\tstruct statement *val;\n\tif (!is_tmp_var(var))\n\t\treturn NULL;\n\n\t/* We are at the beginning of the block, or the context is unknown.  */\n\tif (!ctx_node)\n\t\treturn NULL;\n\n\tif ((val = NULL, tree_scanf(cfg_node_stmt(ctx_node), \"%t = %t\",\n\t\t\t\t    NULL, &var, &val))\n\t    || (val = NULL,\n\t\ttree_scanf(cfg_node_stmt(ctx_node), \"%t = (%_)%t\",\n\t\t\t   NULL, &var, &val))) {\n\t\tif (including_crt) {\n\t\t\treturn val;\n\t\t} else\n\t\t\t/* We are on a def, but exclude it => don't go up.  */\n\t\t\treturn NULL;\n\t} else\n\t\t/* We are not on a def => go up and try again.  */\n\t\treturn substitute_tmp_var(var, ctx_node->prev, true);\n#endif\n}", "path": "tree-match.c", "repo_name": "mnagy/mysparse", "stars": 0, "license": "None", "language": "c", "size": 108}
{"docstring": "/* Match a tree t, consuming the pattern.  If the args in patt_info is\n   not null, the pattern has anonymous holes, indicated by the\n   va_args, so consume the args as you go.  Otherwise (args is null),\n   you have a pattern with named holes.  The ctx_node (if non-null)\n   indicates the cfg_node where the tree is supposed to occur, in case\n   some tmp vars are to be searched for from this point backwards.  */\n", "func_signal": "static bool\nmatch_tree_pattinfo(struct statement *t, patt_info * patt, const char *delim,\n\t\t    cfg_node ctx_node)", "code": "{\n\tstruct statement **pt;\n\thole *ph = NULL;\n\tbool res;\n\tint parskip = 0;\n\tstruct statement *val;\n\n\tinfo(t->pos, \"tree pattinfo\");\n\tif (patt->format_spec[0] == '%'\n\t    && *delim == pattern_lookahead(patt, 2)) {\n\t\t/* lookahead(1) ok */\n\t\tif (patt->format_spec[1] != '_') {\n\t\t\t/* not \"any\" hole */\n\t\t\tif (patt->args_ptr)\t/* anonymous holes */\n\t\t\t\tpt = va_arg(*patt->args_ptr, struct statement **);\n\t\t\telse {\n\t\t\t\t/* named holes */\n\t\t\t\tph = get_hole_named(patt->format_spec[1]);\n\n\t\t\t\tif (!ph)\n\t\t\t\t\tdie\n\t\t\t\t\t    (\"Invalid pattern variable: %%%c\\n\",\n\t\t\t\t\t     patt->format_spec[1]);\n\n\t\t\t\tpt = &ph->tree;\n\t\t\t}\n\n\t\t\tif (!*pt) {\n\t\t\t\t/* var hole */\n\t\t\t\t/* refuse to catch a tmpvar def */\n\t\t\t\t/* XXX: We don't do temporary variables.. */\n#if 0\n\t\t\t\tif (is_tmp_var(t) && ctx_node &&\n\t\t\t\t    (tree_scanf\n\t\t\t\t     (cfg_node_stmt(ctx_node), \"%t = %_\", NULL,\n\t\t\t\t      &t)\n\t\t\t\t     || tree_scanf(cfg_node_stmt(ctx_node),\n\t\t\t\t\t\t   \"%t = (%_)%_\", NULL, &t))) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n#endif\n\n\t\t\t\t*pt = t;\n\t\t\t\tif (ph)\n\t\t\t\t\tph->ctx = ctx_node;\n\t\t\t} else {\n\t\t\t\t/* instantiated hole */\n\t\t\t\tif (!tree_equal_mod_tmps\n\t\t\t\t    (*pt, t, ph ? ph->ctx : NULL, ctx_node)) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* else (%_) just go on */\n\t\tpatt->format_spec += 2;\t/* consume %h */\n\t\treturn 1;\n\t} else {\n\t\t/* Can't swallow a whole tree, must recurse on it.  */\n\t\tVEC(tree_chunk, heap) * chunks;\n\n\t\t/* Check an eventual pattern-only '(' to be skipped.  */\n\t\tif (patt->format_spec[0] == '\\\\' && patt->format_spec[1] == '(') {\n\t\t\tpatt->format_spec += 2;\n\t\t\tparskip = 1;\n\t\t}\n\n\t\t/* XXX: Commented out for now */\n#if 0\n\t\t/* On a tmpvar or a cast, there is no point to recurse directly (they\n\t\t   cannot be in the pattern), so substitute it before.  */\n\t\twhile ((val = substitute_tmp_var(t, ctx_node, false)) != NULL\n\t\t       || (val = substitute_cast_expr(t)) != NULL) {\n\t\t\tt = val;\n\t\t}\n#endif\n\n\t\t//maybe_init_pretty_print(stdout);\n\t\tchunks = lazy_dump_generic_node(t);\n\t\tres = match_chunks_pattinfo(chunks, patt, delim, ctx_node);\n\t\tpp_free_list(chunks);\n\n\t\t/* if needed, look for corresponding pattern-only ')' */\n\t\tif (res && parskip) {\n\t\t\tif (patt->format_spec[0] == '\\\\'\n\t\t\t    && patt->format_spec[1] == ')') {\n\t\t\t\tpatt->format_spec += 2;\n\t\t\t} else {\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n}", "path": "tree-match.c", "repo_name": "mnagy/mysparse", "stars": 0, "license": "None", "language": "c", "size": 108}
{"docstring": "/* Get the first non-space character in a pattern.  */\n", "func_signal": "static char pattern_lookahead(patt_info * patt, int n)", "code": "{\n\tconst char *s = patt->format_spec + n;\n\tint skip = 0;\n\n\tdo {\n\t\tif (s[0] == '\\\\' && s[1] == ')')\n\t\t\tskip = 2;\n\n\t\telse if (s[0] == ' ')\n\t\t\tskip = 1;\n\n\t\telse\n\t\t\tskip = 0;\n\n\t\ts += skip;\n\t} while (skip);\n\n\treturn s[0];\n}", "path": "tree-match.c", "repo_name": "mnagy/mysparse", "stars": 0, "license": "None", "language": "c", "size": 108}
{"docstring": "/* FIXME: These should actually DO something. */\n", "func_signal": "static struct tree_chunk_list *lazy_dump_generic_node(struct statement *stmt)", "code": "{\n\tstruct tree_chunk_list *res = NULL;\n\tstruct tree_chunk *tc = alloc_tree_chunk();\n\n\tadd_ptr_list(res, tc);\n\treturn res;\n}", "path": "tree-match.c", "repo_name": "mnagy/mysparse", "stars": 0, "license": "None", "language": "c", "size": 108}
{"docstring": "/* Save the values of all global variables in a buffer.  */\n", "func_signal": "hole *save_global_holes(void)", "code": "{\n\thole *buf = xmalloc(sizeof(global_holes));\n\tmemcpy(buf, global_holes, sizeof(global_holes));\n\treturn buf;\n}", "path": "tree-match.c", "repo_name": "mnagy/mysparse", "stars": 0, "license": "None", "language": "c", "size": 108}
{"docstring": "/* Get the hole named by a (local or global) variable name.  */\n", "func_signal": "hole *get_hole_named(char c)", "code": "{\n\tif ('a' <= c && c <= 'z')\n\t\treturn &local_holes[c - 'a'];\n\n\tif ('A' <= c && c <= 'Z')\n\t\treturn &global_holes[c - 'A'];\n\n\treturn NULL;\n}", "path": "tree-match.c", "repo_name": "mnagy/mysparse", "stars": 0, "license": "None", "language": "c", "size": 108}
{"docstring": "/* Print the list of bounded local variables.  */\n", "func_signal": "void print_local_holes(void)", "code": "{\n\tint i;\n\n\tfor (i = 0; i < LOCAL_MAX; i++) {\n\t\tif (local_holes[i].tree) {\n\t\t\tfprintf(stderr, \"local_holes[%d] == \", i);\n\t\t\t//print_generic_expr(stderr, local_holes[i].tree, 0);\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n\t}\n}", "path": "tree-match.c", "repo_name": "mnagy/mysparse", "stars": 0, "license": "None", "language": "c", "size": 108}
{"docstring": "/* Match a tree against a disjunctive pattern with named holes.  */\n", "func_signal": "bool tree_match_disj(struct statement *t, pattern patt, cfg_node ctx_node)", "code": "{\n\tif (!patt)\n\t\treturn false;\n\n\treturn (tree_match(t, patt->format_spec, ctx_node)\n\t\t|| (patt->next && tree_match_disj(t, patt->next, ctx_node)));\n}", "path": "tree-match.c", "repo_name": "mnagy/mysparse", "stars": 0, "license": "None", "language": "c", "size": 108}
{"docstring": "/* Get the first character of (the printed form of) a tree chunk.  */\n", "func_signal": "static char chunk_1st_char(tree_chunk chunk)", "code": "{\n\tif (chunk->t)\n\t\treturn tree_1st_char(chunk->t);\n\n\telse if (chunk->s)\n\t\treturn *chunk->s;\n\n\telse\n\t\treturn chunk->c;\n}", "path": "tree-match.c", "repo_name": "mnagy/mysparse", "stars": 0, "license": "None", "language": "c", "size": 108}
{"docstring": "/* Search the first chunk of a lazy list not consisting of whitespace.  */\n", "func_signal": "static tree_chunk\nchunks_lookahead(VEC(tree_chunk, heap) * chunks, unsigned int i)", "code": "{\n\ttree_chunk chunk;\n\n\tfor (; VEC_iterate(tree_chunk, chunks, i, chunk); i++)\n\t\tif (chunk->c == 0 || chunk->c != ' ')\n\t\t\tbreak;\n\n\treturn chunk;\n}", "path": "tree-match.c", "repo_name": "mnagy/mysparse", "stars": 0, "license": "None", "language": "c", "size": 108}
{"docstring": "/* Print the list of bounded global variables.  */\n", "func_signal": "void print_global_holes(void)", "code": "{\n\tint i, state = 0;\n\n\tfprintf(stderr, \"{\");\n\n\tfor (i = 0; i < GLOBAL_MAX; i++) {\n\t\tif (global_holes[i].tree) {\n\t\t\tif (state)\n\t\t\t\tfprintf(stderr, \", \");\n\t\t\tfprintf(stderr, \"%c <- \", 'A' + i);\n\t\t\t//print_generic_expr(stderr, global_holes[i].tree, 0);\n\t\t\tstate = 1;\n\t\t}\n\t}\n\n\tfprintf(stderr, \"}\");\n}", "path": "tree-match.c", "repo_name": "mnagy/mysparse", "stars": 0, "license": "None", "language": "c", "size": 108}
{"docstring": "/*\n * CRC16 compute for DDR3 SPD\n * Copied from DDR3 SPD spec.\n */\n", "func_signal": "static int\ncrc16(char *ptr, int count)", "code": "{\n\tint crc, i;\n\n\tcrc = 0;\n\twhile (--count >= 0) {\n\t\tcrc = crc ^ (int)*ptr++ << 8;\n\t\tfor (i = 0; i < 8; ++i)\n\t\t\tif (crc & 0x8000)\n\t\t\t\tcrc = crc << 1 ^ 0x1021;\n\t\t\telse\n\t\t\t\tcrc = crc << 1;\n\t}\n\treturn crc & 0xffff;\n}", "path": "common\\ddr_spd.c", "repo_name": "lichman/U-boot-2009.08_tekkaman", "stars": 1, "license": "other", "language": "c", "size": 12813}
{"docstring": "/*-----------------------------------------------------------------------\n */\n", "func_signal": "static flash_info_t *flash_get_info(ulong base)", "code": "{\n\tint i;\n\tflash_info_t * info;\n\n\tfor (i = 0; i < CONFIG_SYS_MAX_FLASH_BANKS; i ++) {\n\t\tinfo = & flash_info[i];\n\t\tif (info->start[0] <= base && base < info->start[0] + info->size)\n\t\t\tbreak;\n\t}\n\n\treturn i == CONFIG_SYS_MAX_FLASH_BANKS ? 0 : info;\n}", "path": "board\\purple\\flash.c", "repo_name": "lichman/U-boot-2009.08_tekkaman", "stars": 1, "license": "other", "language": "c", "size": 12813}
{"docstring": "/******************************************************************************\n*\n* Don't change the program architecture\n* This architecture assure the program\n* can be relocated to scratch ram\n*/\n", "func_signal": "static void flash_read_cmd(int cmd, FPWV * pFA, char * string, int strLen)", "code": "{\n\tint i,j;\n\tFPW temp,temp1;\n\tFPWV *str;\n\n\tstr = (FPWV *)string;\n\n\tj=  strLen/4;\n\n\tif(cmd == FLASH29_CMD_AUTOSELECT)\n\t   {\n\t    *(FLASH29_REG_FIRST_CYCLE)  = FLASH29_CMD_FIRST;\n\t    *(FLASH29_REG_SECOND_CYCLE) = FLASH29_CMD_SECOND;\n\t    *(FLASH29_REG_THIRD_CYCLE)  = FLASH29_CMD_AUTOSELECT;\n\t   }\n\n\tif(cmd == FLASH29_CMD_READ)\n\t   {\n\t    i = 0;\n\t    while(i<j)\n\t    {\n\t\ttemp = *pFA++;\n\t\ttemp1 = *(int *)0xa0000000;\n\t\t*(int *)0xbf0081f8 = temp1 + temp;\n\t\t*str++ = temp;\n\t\ti++;\n\t    }\n\t   }\n\n\t if(cmd == FLASH29_CMD_READ_RESET)\n\t {\n\t    *(FLASH29_REG_FIRST_CYCLE)  = FLASH29_CMD_FIRST;\n\t    *(FLASH29_REG_SECOND_CYCLE) = FLASH29_CMD_SECOND;\n\t    *(FLASH29_REG_THIRD_CYCLE)  = FLASH29_CMD_READ_RESET;\n\t }\n\n\t*(int *)0xbf0081f8 = *(int *)0xa0000000;\t/* dummy read switch back to sdram interface */\n}", "path": "board\\purple\\flash.c", "repo_name": "lichman/U-boot-2009.08_tekkaman", "stars": 1, "license": "other", "language": "c", "size": 12813}
{"docstring": "/*-----------------------------------------------------------------------\n */\n", "func_signal": "void flash_print_info (flash_info_t * info)", "code": "{\n\tint i;\n\tuchar *boottype;\n\tuchar botboot[] = \", bottom boot sect)\\n\";\n\tuchar topboot[] = \", top boot sector)\\n\";\n\n\tif (info->flash_id == FLASH_UNKNOWN) {\n\t\tprintf (\"missing or unknown FLASH type\\n\");\n\t\treturn;\n\t}\n\n\tswitch (info->flash_id & FLASH_VENDMASK) {\n\tcase FLASH_MAN_AMD:\n\t\tprintf (\"AMD \");\n\t\tbreak;\n\tcase FLASH_MAN_FUJ:\n\t\tprintf (\"FUJITSU \");\n\t\tbreak;\n\tcase FLASH_MAN_SST:\n\t\tprintf (\"SST \");\n\t\tbreak;\n\tcase FLASH_MAN_STM:\n\t\tprintf (\"STM \");\n\t\tbreak;\n\tcase FLASH_MAN_INTEL:\n\t\tprintf (\"INTEL \");\n\t\tbreak;\n\tdefault:\n\t\tprintf (\"Unknown Vendor \");\n\t\tbreak;\n\t}\n\n\tif (info->flash_id & 0x0001) {\n\t\tboottype = botboot;\n\t} else {\n\t\tboottype = topboot;\n\t}\n\n\tswitch (info->flash_id & FLASH_TYPEMASK) {\n\tcase FLASH_AM400B:\n\t\tprintf (\"AM29LV400B (4 Mbit%s\", boottype);\n\t\tbreak;\n\tcase FLASH_AM400T:\n\t\tprintf (\"AM29LV400T (4 Mbit%s\", boottype);\n\t\tbreak;\n\tcase FLASH_AM800B:\n\t\tprintf (\"AM29LV800B (8 Mbit%s\", boottype);\n\t\tbreak;\n\tcase FLASH_AM800T:\n\t\tprintf (\"AM29LV800T (8 Mbit%s\", boottype);\n\t\tbreak;\n\tcase FLASH_AM160B:\n\t\tprintf (\"AM29LV160B (16 Mbit%s\", boottype);\n\t\tbreak;\n\tcase FLASH_AM160T:\n\t\tprintf (\"AM29LV160T (16 Mbit%s\", boottype);\n\t\tbreak;\n\tcase FLASH_AM320B:\n\t\tprintf (\"AM29LV320B (32 Mbit%s\", boottype);\n\t\tbreak;\n\tcase FLASH_AM320T:\n\t\tprintf (\"AM29LV320T (32 Mbit%s\", boottype);\n\t\tbreak;\n\tcase FLASH_INTEL800B:\n\t\tprintf (\"INTEL28F800B (8 Mbit%s\", boottype);\n\t\tbreak;\n\tcase FLASH_INTEL800T:\n\t\tprintf (\"INTEL28F800T (8 Mbit%s\", boottype);\n\t\tbreak;\n\tcase FLASH_INTEL160B:\n\t\tprintf (\"INTEL28F160B (16 Mbit%s\", boottype);\n\t\tbreak;\n\tcase FLASH_INTEL160T:\n\t\tprintf (\"INTEL28F160T (16 Mbit%s\", boottype);\n\t\tbreak;\n\tcase FLASH_INTEL320B:\n\t\tprintf (\"INTEL28F320B (32 Mbit%s\", boottype);\n\t\tbreak;\n\tcase FLASH_INTEL320T:\n\t\tprintf (\"INTEL28F320T (32 Mbit%s\", boottype);\n\t\tbreak;\n\n#if 0\t\t\t\t/* enable when devices are available */\n\n\tcase FLASH_INTEL640B:\n\t\tprintf (\"INTEL28F640B (64 Mbit%s\", boottype);\n\t\tbreak;\n\tcase FLASH_INTEL640T:\n\t\tprintf (\"INTEL28F640T (64 Mbit%s\", boottype);\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\tprintf (\"Unknown Chip Type\\n\");\n\t\tbreak;\n\t}\n\n\tprintf (\"  Size: %ld MB in %d Sectors\\n\",\n\t\tinfo->size >> 20, info->sector_count);\n\n\tprintf (\"  Sector Start Addresses:\");\n\tfor (i = 0; i < info->sector_count; ++i) {\n\t\tif ((i % 5) == 0)\n\t\t\tprintf (\"\\n   \");\n\t\tprintf (\" %08lX%s\",\n\t\t\tinfo->start[i], info->protect[i] ? \" (RO)\" : \"     \");\n\t}\n\tprintf (\"\\n\");\n\treturn;\n}", "path": "board\\esteem192e\\flash.c", "repo_name": "lichman/U-boot-2009.08_tekkaman", "stars": 1, "license": "other", "language": "c", "size": 12813}
{"docstring": "/*\n * The following code cannot be run from FLASH!\n */\n", "func_signal": "ulong flash_get_size (FPWV *addr, flash_info_t *info)", "code": "{\n\tFUNCPTR_RD absEntry;\n\tFPW retValue;\n\tint flag;\n\n\tload_cmd(IN_RAM_CMD_READ);\n\tabsEntry = (FUNCPTR_RD)FLASH_READ_CMD;\n\n\tflag = disable_interrupts();\n\tabsEntry(FLASH29_CMD_AUTOSELECT,0,0,0);\n\tif (flag) enable_interrupts();\n\n\tudelay(100);\n\n\tflag = disable_interrupts();\n\tabsEntry(FLASH29_CMD_READ, addr + 1, (char *)&retValue, sizeof(retValue));\n\tabsEntry(FLASH29_CMD_READ_RESET,0,0,0);\n\tif (flag) enable_interrupts();\n\n\tudelay(100);\n\n\tswitch (retValue) {\n\n\tcase (FPW)AMD_ID_LV160B:\n\t\tinfo->flash_id += FLASH_AM160B;\n\t\tinfo->sector_count = 35;\n\t\tinfo->size = 0x00400000;\n\t\tbreak;\t\t\t\t/* => 8 or 16 MB\t*/\n\n\tdefault:\n\t\tinfo->flash_id = FLASH_UNKNOWN;\n\t\tinfo->sector_count = 0;\n\t\tinfo->size = 0;\n\t\treturn (0);\t\t\t/* => no or unknown flash */\n\t}\n\n\tflash_get_offsets((ulong)addr, info);\n\n\treturn (info->size);\n}", "path": "board\\purple\\flash.c", "repo_name": "lichman/U-boot-2009.08_tekkaman", "stars": 1, "license": "other", "language": "c", "size": 12813}
{"docstring": "/*-----------------------------------------------------------------------\n */\n", "func_signal": "static void flash_get_offsets (ulong base, flash_info_t *info)", "code": "{\n\tint i;\n\n\tif ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_AMD\n\t\t && (info->flash_id & FLASH_TYPEMASK) == FLASH_AM160B) {\n\n\t\tint bootsect_size[4];\t/* number of bytes/boot sector  */\n\t\tint sect_size;\t\t/* number of bytes/regular sector */\n\n\t\tbootsect_size[0] = 0x00008000;\n\t\tbootsect_size[1] = 0x00004000;\n\t\tbootsect_size[2] = 0x00004000;\n\t\tbootsect_size[3] = 0x00010000;\n\t\tsect_size =        0x00020000;\n\n\t\t/* set sector offsets for bottom boot block type\t*/\n\t\tfor (i = 0; i < info->sector_count; i++) {\n\t\t\tinfo->start[i] = base;\n\t\t\tbase += i < 4 ? bootsect_size[i] : sect_size;\n\t\t}\n\t}\n}", "path": "board\\purple\\flash.c", "repo_name": "lichman/U-boot-2009.08_tekkaman", "stars": 1, "license": "other", "language": "c", "size": 12813}
{"docstring": "/*-----------------------------------------------------------------------\n */\n", "func_signal": "unsigned long flash_init (void)", "code": "{\n\tvolatile immap_t *immap = (immap_t *) CONFIG_SYS_IMMR;\n\tvolatile memctl8xx_t *memctl = &immap->im_memctl;\n\tunsigned long size_b0, size_b1;\n\tint i;\n\n\t/* Init: no FLASHes known */\n\tfor (i = 0; i < CONFIG_SYS_MAX_FLASH_BANKS; ++i) {\n\t\tflash_info[i].flash_id = FLASH_UNKNOWN;\n\t}\n\n\t/* Static FLASH Bank configuration here - FIXME XXX */\n\n\tsize_b0 =\n\t\tflash_get_size ((volatile FLASH_WORD_SIZE *)\n\t\t\t\tFLASH_BASE0_PRELIM, &flash_info[0]);\n\tif (flash_info[0].flash_id == FLASH_UNKNOWN) {\n\t\tprintf (\"## Unknown FLASH on Bank 0 - Size = 0x%08lx = %ld MB\\n\", size_b0, size_b0 << 20);\n\t}\n\n\tsize_b1 =\n\t\tflash_get_size ((volatile FLASH_WORD_SIZE *)\n\t\t\t\tFLASH_BASE1_PRELIM, &flash_info[1]);\n\n\tif (size_b1 > size_b0) {\n\t\tprintf (\"## ERROR: \"\n\t\t\t\"Bank 1 (0x%08lx = %ld MB) > Bank 0 (0x%08lx = %ld MB)\\n\",\n\t\t\tsize_b1, size_b1 << 20, size_b0, size_b0 << 20);\n\t\tflash_info[0].flash_id = FLASH_UNKNOWN;\n\t\tflash_info[1].flash_id = FLASH_UNKNOWN;\n\t\tflash_info[0].sector_count = -1;\n\t\tflash_info[1].sector_count = -1;\n\t\tflash_info[0].size = 0;\n\t\tflash_info[1].size = 0;\n\t\treturn (0);\n\t}\n\n\t/* Remap FLASH according to real size */\n\tmemctl->memc_or0 = CONFIG_SYS_OR_TIMING_FLASH | (-size_b0 & 0xFFFF8000);\n\tmemctl->memc_br0 = CONFIG_SYS_FLASH_BASE | 0x00000801;\t/*  (CONFIG_SYS_FLASH_BASE & BR_BA_MSK) | BR_MS_GPCM | BR_V; */\n\n\t/* Re-do sizing to get full correct info */\n\n\tsize_b0 = flash_get_size ((volatile FLASH_WORD_SIZE *) CONFIG_SYS_FLASH_BASE,\n\t\t\t\t  &flash_info[0]);\n\tflash_get_offsets (CONFIG_SYS_FLASH_BASE, &flash_info[0]);\n\n#if CONFIG_SYS_MONITOR_BASE >= CONFIG_SYS_FLASH_BASE\n\t/* monitor protection ON by default */\n\t(void) flash_protect (FLAG_PROTECT_SET,\n\t\t\t      CONFIG_SYS_MONITOR_BASE,\n\t\t\t      CONFIG_SYS_MONITOR_BASE + monitor_flash_len - 1,\n\t\t\t      &flash_info[0]);\n#endif\n\n\tif (size_b1) {\n\t\tmemctl->memc_or1 =\n\t\t\tCONFIG_SYS_OR_TIMING_FLASH | (-size_b1 & 0xFFFF8000);\n\t\tmemctl->memc_br1 =\n\t\t\t(CONFIG_SYS_FLASH_BASE | 0x00000801) + (size_b0 & BR_BA_MSK);\n\t\t/*((CONFIG_SYS_FLASH_BASE + size_b0) & BR_BA_MSK) |\n\t\t   BR_MS_GPCM | BR_V; */\n\n\t\t/* Re-do sizing to get full correct info */\n\t\tsize_b1 =\n\t\t\tflash_get_size ((volatile FLASH_WORD_SIZE\n\t\t\t\t\t *) (CONFIG_SYS_FLASH_BASE + size_b0),\n\t\t\t\t\t&flash_info[1]);\n\n\t\tflash_get_offsets (CONFIG_SYS_FLASH_BASE + size_b0, &flash_info[1]);\n\n#if CONFIG_SYS_MONITOR_BASE >= CONFIG_SYS_FLASH_BASE\n\t\t/* monitor protection ON by default */\n\t\t(void) flash_protect (FLAG_PROTECT_SET,\n\t\t\t\t      CONFIG_SYS_MONITOR_BASE,\n\t\t\t\t      CONFIG_SYS_MONITOR_BASE + monitor_flash_len -\n\t\t\t\t      1, &flash_info[1]);\n#endif\n\t} else {\n\t\tmemctl->memc_br1 = 0;\t/* invalidate bank */\n\n\t\tflash_info[1].flash_id = FLASH_UNKNOWN;\n\t\tflash_info[1].sector_count = -1;\n\t}\n\n\tflash_info[0].size = size_b0;\n\tflash_info[1].size = size_b1;\n\n\treturn (size_b0 + size_b1);\n}", "path": "board\\esteem192e\\flash.c", "repo_name": "lichman/U-boot-2009.08_tekkaman", "stars": 1, "license": "other", "language": "c", "size": 12813}
{"docstring": "/*\n * This function is derived from PowerPC code (timebase clock frequency).\n * On ARM it returns the number of timer ticks per second.\n */\n", "func_signal": "ulong get_tbclk (void)", "code": "{\n\tulong tbclk;\n\n\ttbclk = CONFIG_SYS_HZ;\n\n\treturn tbclk;\n}", "path": "cpu\\arm920t\\imx\\timer.c", "repo_name": "lichman/U-boot-2009.08_tekkaman", "stars": 1, "license": "other", "language": "c", "size": 12813}
{"docstring": "/*\n * Miscellaneous platform dependent initialisations\n */\n", "func_signal": "int board_init (void)", "code": "{\n\t/*\n\t * set clock frequency:\n\t *\tVERSATILE_REFCLK is 32KHz\n\t *\tVERSATILE_TIMCLK is 1MHz\n\t */\n\t*(volatile unsigned int *)(VERSATILE_SCTL_BASE) |=\n\t  ((VERSATILE_TIMCLK << VERSATILE_TIMER1_EnSel) | (VERSATILE_TIMCLK << VERSATILE_TIMER2_EnSel) |\n\t   (VERSATILE_TIMCLK << VERSATILE_TIMER3_EnSel) | (VERSATILE_TIMCLK << VERSATILE_TIMER4_EnSel));\n\n\t/* arch number of Versatile Board */\n\tgd->bd->bi_arch_number = MACH_TYPE_VERSATILE_PB;\n\n\t/* adress of boot parameters */\n\tgd->bd->bi_boot_params = 0x00000100;\n\n\tgd->flags = 0;\n\n\ticache_enable ();\n\n\treturn 0;\n}", "path": "board\\armltd\\versatile\\versatile.c", "repo_name": "lichman/U-boot-2009.08_tekkaman", "stars": 1, "license": "other", "language": "c", "size": 12813}
{"docstring": "/*-----------------------------------------------------------------------\n * flash_init()\n *\n * sets up flash_info and returns size of FLASH (bytes)\n */\n", "func_signal": "unsigned long flash_init (void)", "code": "{\n\tunsigned long size = 0;\n\tint i;\n\n\tload_cmd(IN_RAM_CMD_READ);\n\n\t/* Init: no FLASHes known */\n\tfor (i=0; i < CONFIG_SYS_MAX_FLASH_BANKS; ++i) {\n\t\tulong flashbase = PHYS_FLASH_1;\n\t\tulong * buscon = (ulong *) INCA_IP_EBU_EBU_BUSCON0;\n\n\t\t/* Disable write protection */\n\t\t*buscon &= ~INCA_IP_EBU_EBU_BUSCON1_WRDIS;\n\n#if 1\n\t\tmemset(&flash_info[i], 0, sizeof(flash_info_t));\n#endif\n\n\t\tflash_info[i].size =\n\t\t\tflash_get_size((FPW *)flashbase, &flash_info[i]);\n\n\t\tif (flash_info[i].flash_id == FLASH_UNKNOWN) {\n\t\t\tprintf (\"## Unknown FLASH on Bank %d - Size = 0x%08lx\\n\",\n\t\t\ti, flash_info[i].size);\n\t\t}\n\n\t\tsize += flash_info[i].size;\n\t}\n\n#if CONFIG_SYS_MONITOR_BASE >= CONFIG_SYS_FLASH_BASE\n\t/* monitor protection ON by default */\n\tflash_protect(FLAG_PROTECT_SET,\n\t\t      CONFIG_SYS_MONITOR_BASE,\n\t\t      CONFIG_SYS_MONITOR_BASE+monitor_flash_len-1,\n\t\t      flash_get_info(CONFIG_SYS_MONITOR_BASE));\n#endif\n\n#ifdef\tCONFIG_ENV_IS_IN_FLASH\n\t/* ENV protection ON by default */\n\tflash_protect(FLAG_PROTECT_SET,\n\t\t      CONFIG_ENV_ADDR,\n\t\t      CONFIG_ENV_ADDR+CONFIG_ENV_SIZE-1,\n\t\t      flash_get_info(CONFIG_ENV_ADDR));\n#endif\n\n\treturn size;\n}", "path": "board\\purple\\flash.c", "repo_name": "lichman/U-boot-2009.08_tekkaman", "stars": 1, "license": "other", "language": "c", "size": 12813}
{"docstring": "/*-----------------------------------------------------------------------\n * Copy memory to flash, returns:\n * 0 - OK\n * 1 - write timeout\n * 2 - Flash not erased\n */\n", "func_signal": "int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)", "code": "{\n#ifndef CONFIG_FLASH_16BIT\n\tulong cp, wp, data;\n\tint l;\n#else\n\tulong cp, wp;\n\tushort data;\n#endif\n\tint i, rc;\n\n#ifndef CONFIG_FLASH_16BIT\n\n\n\twp = (addr & ~3);\t/* get lower word aligned address */\n\n\t/*\n\t * handle unaligned start bytes\n\t */\n\tif ((l = addr - wp) != 0) {\n\t\tdata = 0;\n\t\tfor (i = 0, cp = wp; i < l; ++i, ++cp) {\n\t\t\tdata = (data << 8) | (*(uchar *) cp);\n\t\t}\n\t\tfor (; i < 4 && cnt > 0; ++i) {\n\t\t\tdata = (data << 8) | *src++;\n\t\t\t--cnt;\n\t\t\t++cp;\n\t\t}\n\t\tfor (; cnt == 0 && i < 4; ++i, ++cp) {\n\t\t\tdata = (data << 8) | (*(uchar *) cp);\n\t\t}\n\n\t\tif ((rc = write_word (info, wp, data)) != 0) {\n\t\t\treturn (rc);\n\t\t}\n\t\twp += 4;\n\t}\n\n\t/*\n\t * handle word aligned part\n\t */\n\twhile (cnt >= 4) {\n\t\tdata = 0;\n\t\tfor (i = 0; i < 4; ++i) {\n\t\t\tdata = (data << 8) | *src++;\n\t\t}\n\t\tif ((rc = write_word (info, wp, data)) != 0) {\n\t\t\treturn (rc);\n\t\t}\n\t\twp += 4;\n\t\tcnt -= 4;\n\t}\n\n\tif (cnt == 0) {\n\t\treturn (0);\n\t}\n\n\t/*\n\t * handle unaligned tail bytes\n\t */\n\tdata = 0;\n\tfor (i = 0, cp = wp; i < 4 && cnt > 0; ++i, ++cp) {\n\t\tdata = (data << 8) | *src++;\n\t\t--cnt;\n\t}\n\tfor (; i < 4; ++i, ++cp) {\n\t\tdata = (data << 8) | (*(uchar *) cp);\n\t}\n\n\treturn (write_word (info, wp, data));\n\n#else\n\twp = (addr & ~1);\t/* get lower word aligned address */\n\n\t/*\n\t * handle unaligned start byte\n\t */\n\tif (addr - wp) {\n\t\tdata = 0;\n\t\tdata = (data << 8) | *src++;\n\t\t--cnt;\n\t\tif ((rc = write_short (info, wp, data)) != 0) {\n\t\t\treturn (rc);\n\t\t}\n\t\twp += 2;\n\t}\n\n\t/*\n\t * handle word aligned part\n\t */\n/*\tl = 0; used for debuging  */\n\twhile (cnt >= 2) {\n\t\tdata = 0;\n\t\tfor (i = 0; i < 2; ++i) {\n\t\t\tdata = (data << 8) | *src++;\n\t\t}\n\n/*\t\tif(!l){\n\t\t\tprintf(\"%x\",data);\n\t\t\tl = 1;\n\t\t}  used for debuging */\n\n\t\tif ((rc = write_short (info, wp, data)) != 0) {\n\t\t\treturn (rc);\n\t\t}\n\t\twp += 2;\n\t\tcnt -= 2;\n\t}\n\n\tif (cnt == 0) {\n\t\treturn (0);\n\t}\n\n\t/*\n\t * handle unaligned tail bytes\n\t */\n\tdata = 0;\n\tfor (i = 0, cp = wp; i < 2 && cnt > 0; ++i, ++cp) {\n\t\tdata = (data << 8) | *src++;\n\t\t--cnt;\n\t}\n\tfor (; i < 2; ++i, ++cp) {\n\t\tdata = (data << 8) | (*(uchar *) cp);\n\t}\n\n\treturn (write_short (info, wp, data));\n\n\n#endif\n}", "path": "board\\esteem192e\\flash.c", "repo_name": "lichman/U-boot-2009.08_tekkaman", "stars": 1, "license": "other", "language": "c", "size": 12813}
{"docstring": "/*\n * The ALPR has a NAND Flash Controller (NDFC) that handles all accesses to\n * the NAND devices.  The NDFC has command, address and data registers that\n * when accessed will set up the NAND flash pins appropriately.  We'll use the\n * hwcontrol function to save the configuration in a global variable.\n * We can then use this information in the read and write functions to\n * determine which NDFC register to access.\n *\n * There are 2 NAND devices on the board, a Hynix HY27US08561A (1 GByte).\n */\n", "func_signal": "static void alpr_nand_hwcontrol(struct mtd_info *mtd, int cmd, unsigned int ctrl)", "code": "{\n\tstruct nand_chip *this = mtd->priv;\n\n\tif (ctrl & NAND_CTRL_CHANGE) {\n\t\tif ( ctrl & NAND_CLE )\n\t\t\thwctl |= 0x1;\n\t\telse\n\t\t\thwctl &= ~0x1;\n\t\tif ( ctrl & NAND_ALE )\n\t\t\thwctl |= 0x2;\n\t\telse\n\t\t\thwctl &= ~0x2;\n\t\tif ( (ctrl & NAND_NCE) != NAND_NCE)\n\t\t\twriteb(0x00, &(alpr_ndfc->term));\n\t}\n\tif (cmd != NAND_CMD_NONE)\n\t\twriteb(cmd, this->IO_ADDR_W);\n}", "path": "board\\prodrive\\alpr\\nand.c", "repo_name": "lichman/U-boot-2009.08_tekkaman", "stars": 1, "license": "other", "language": "c", "size": 12813}
{"docstring": "/*\n * Miscellaneous platform dependent initialisations\n */\n", "func_signal": "int board_init (void)", "code": "{\n\tS3C24X0_CLOCK_POWER * const clk_power = S3C24X0_GetBase_CLOCK_POWER();\n\tS3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO();\n\n\t/* to reduce PLL lock time, adjust the LOCKTIME register */\n\tclk_power->LOCKTIME = 0xFFFFFF;\n\n\t/* configure MPLL */\n\tclk_power->MPLLCON = ((M_MDIV << 12) + (M_PDIV << 4) + M_SDIV);\n\n\t/* some delay between MPLL and UPLL */\n\tdelay (4000);\n\n\t/* configure UPLL */\n\tclk_power->UPLLCON = ((U_M_MDIV << 12) + (U_M_PDIV << 4) + U_M_SDIV);\n\n\t/* some delay between MPLL and UPLL */\n\tdelay (8000);\n\n\t/* set up the I/O ports */\n\tgpio->GPACON = 0x007FFFFF;\n\tgpio->GPBCON = 0x00044556;\n\tgpio->GPBUP = 0x000007FF;\n\tgpio->GPCCON = 0xAAAAAAAA;\n\tgpio->GPCUP = 0x0000FFFF;\n\tgpio->GPDCON = 0xAAAAAAAA;\n\tgpio->GPDUP = 0x0000FFFF;\n\tgpio->GPECON = 0xAAAAAAAA;\n\tgpio->GPEUP = 0x0000FFFF;\n\tgpio->GPFCON = 0x000055AA;\n\tgpio->GPFUP = 0x000000FF;\n\tgpio->GPGCON = 0xFF95FF3A;\n\tgpio->GPGUP = 0x0000FFFF;\n\tgpio->GPHCON = 0x0016FAAA;\n\tgpio->GPHUP = 0x000007FF;\n\n\tgpio->EXTINT0=0x22222222;\n\tgpio->EXTINT1=0x22222222;\n\tgpio->EXTINT2=0x22222222;\n\n\t/* arch number of SMDK2410-Board */\n\tgd->bd->bi_arch_number = MACH_TYPE_SMDK2410;\n\n\t/* adress of boot parameters */\n\tgd->bd->bi_boot_params = 0x30000100;\n\n\ticache_enable();\n\tdcache_enable();\n\n\treturn 0;\n}", "path": "board\\sbc2410x\\sbc2410x.c", "repo_name": "lichman/U-boot-2009.08_tekkaman", "stars": 1, "license": "other", "language": "c", "size": 12813}
{"docstring": "/*\n * Reset the cpu by setting up the watchdog timer and let him time out\n */\n", "func_signal": "void reset_cpu (ulong ignored)", "code": "{\n\t/* Disable watchdog and set Time-Out field to 0 */\n\tWCR = 0x00000000;\n\n\t/* Write Service Sequence */\n\tWSR = 0x00005555;\n\tWSR = 0x0000AAAA;\n\n\t/* Enable watchdog */\n\tWCR = 0x00000001;\n\n\twhile (1);\n\t/*NOTREACHED*/\n}", "path": "cpu\\arm920t\\imx\\timer.c", "repo_name": "lichman/U-boot-2009.08_tekkaman", "stars": 1, "license": "other", "language": "c", "size": 12813}
{"docstring": "/*-----------------------------------------------------------------------\n */\n", "func_signal": "int\tflash_erase (flash_info_t *info, int s_first, int s_last)", "code": "{\n\tFPWV *addr;\n\tint flag, prot, sect;\n\tulong start, now, last;\n\tint rcode = 0;\n\tFUNCPTR_WR absEntry;\n\n\tload_cmd(IN_RAM_CMD_WRITE);\n\tabsEntry = (FUNCPTR_WR)FLASH_WRITE_CMD;\n\n\tif ((s_first < 0) || (s_first > s_last)) {\n\t\tif (info->flash_id == FLASH_UNKNOWN) {\n\t\t\tprintf (\"- missing\\n\");\n\t\t} else {\n\t\t\tprintf (\"- no sectors to erase\\n\");\n\t\t}\n\t\treturn 1;\n\t}\n\n\tswitch (info->flash_id & FLASH_TYPEMASK) {\n\tcase FLASH_AM160B:\n\t\tbreak;\n\tcase FLASH_UNKNOWN:\n\tdefault:\n\t\tprintf (\"Can't erase unknown flash type %08lx - aborted\\n\",\n\t\t\tinfo->flash_id);\n\t\treturn 1;\n\t}\n\n\tprot = 0;\n\tfor (sect=s_first; sect<=s_last; ++sect) {\n\t\tif (info->protect[sect]) {\n\t\t\tprot++;\n\t\t}\n\t}\n\n\tif (prot) {\n\t\tprintf (\"- Warning: %d protected sectors will not be erased!\\n\",\n\t\t\tprot);\n\t} else {\n\t\tprintf (\"\\n\");\n\t}\n\n\tlast  = get_timer(0);\n\n\t/* Start erase on unprotected sectors */\n\tfor (sect = s_first; sect<=s_last && rcode == 0; sect++) {\n\n\t\tif (info->protect[sect] != 0)\t/* protected, skip it */\n\t\t\tcontinue;\n\n\t\t/* Disable interrupts which might cause a timeout here */\n\t\tflag = disable_interrupts();\n\n\t\taddr = (FPWV *)(info->start[sect]);\n\t\tabsEntry(FLASH29_CMD_SECTOR, addr, 0);\n\n\t\t/* re-enable interrupts if necessary */\n\t\tif (flag)\n\t\t\tenable_interrupts();\n\n\t\tstart = get_timer(0);\n\n\t\twhile ((now = get_timer(start)) <= CONFIG_SYS_FLASH_ERASE_TOUT) {\n\n\t\t\t/* show that we're waiting */\n\t\t\tif ((get_timer(last)) > CONFIG_SYS_HZ) {/* every second */\n\t\t\t\tputc ('.');\n\t\t\t\tlast = get_timer(0);\n\t\t\t}\n\t\t}\n\n\t\tflag = disable_interrupts();\n\t\tabsEntry(FLASH29_CMD_READ_RESET,0,0);\n\t\tif (flag)\n\t\t\tenable_interrupts();\n\t}\n\n\tprintf (\" done\\n\");\n\treturn rcode;\n}", "path": "board\\purple\\flash.c", "repo_name": "lichman/U-boot-2009.08_tekkaman", "stars": 1, "license": "other", "language": "c", "size": 12813}
{"docstring": "/*-----------------------------------------------------------------------\n */\n", "func_signal": "void flash_print_info (flash_info_t *info)", "code": "{\n\tint i;\n\tuchar *boottype;\n\tuchar *bootletter;\n\tchar *fmt;\n\tuchar botbootletter[] = \"B\";\n\tuchar topbootletter[] = \"T\";\n\tuchar botboottype[] = \"bottom boot sector\";\n\tuchar topboottype[] = \"top boot sector\";\n\n\tif (info->flash_id == FLASH_UNKNOWN) {\n\t\tprintf (\"missing or unknown FLASH type\\n\");\n\t\treturn;\n\t}\n\n\tswitch (info->flash_id & FLASH_VENDMASK) {\n\tcase FLASH_MAN_AMD:\tprintf (\"AMD \");\t\tbreak;\n\tcase FLASH_MAN_BM:\tprintf (\"BRIGHT MICRO \");\tbreak;\n\tcase FLASH_MAN_FUJ:\tprintf (\"FUJITSU \");\t\tbreak;\n\tcase FLASH_MAN_SST:\tprintf (\"SST \");\t\tbreak;\n\tcase FLASH_MAN_STM:\tprintf (\"STM \");\t\tbreak;\n\tcase FLASH_MAN_INTEL:\tprintf (\"INTEL \");\t\tbreak;\n\tdefault:\t\tprintf (\"Unknown Vendor \");\tbreak;\n\t}\n\n\t/* check for top or bottom boot, if it applies */\n\tif (info->flash_id & FLASH_BTYPE) {\n\t\tboottype = botboottype;\n\t\tbootletter = botbootletter;\n\t}\n\telse {\n\t\tboottype = topboottype;\n\t\tbootletter = topbootletter;\n\t}\n\n\tswitch (info->flash_id & FLASH_TYPEMASK) {\n\tcase FLASH_AM160B:\n\t\tfmt = \"29LV160B%s (16 Mbit, %s)\\n\";\n\t\tbreak;\n\tcase FLASH_28F800C3B:\n\tcase FLASH_28F800C3T:\n\t\tfmt = \"28F800C3%s (8 Mbit, %s)\\n\";\n\t\tbreak;\n\tcase FLASH_INTEL800B:\n\tcase FLASH_INTEL800T:\n\t\tfmt = \"28F800B3%s (8 Mbit, %s)\\n\";\n\t\tbreak;\n\tcase FLASH_28F160C3B:\n\tcase FLASH_28F160C3T:\n\t\tfmt = \"28F160C3%s (16 Mbit, %s)\\n\";\n\t\tbreak;\n\tcase FLASH_INTEL160B:\n\tcase FLASH_INTEL160T:\n\t\tfmt = \"28F160B3%s (16 Mbit, %s)\\n\";\n\t\tbreak;\n\tcase FLASH_28F320C3B:\n\tcase FLASH_28F320C3T:\n\t\tfmt = \"28F320C3%s (32 Mbit, %s)\\n\";\n\t\tbreak;\n\tcase FLASH_INTEL320B:\n\tcase FLASH_INTEL320T:\n\t\tfmt = \"28F320B3%s (32 Mbit, %s)\\n\";\n\t\tbreak;\n\tcase FLASH_28F640C3B:\n\tcase FLASH_28F640C3T:\n\t\tfmt = \"28F640C3%s (64 Mbit, %s)\\n\";\n\t\tbreak;\n\tcase FLASH_INTEL640B:\n\tcase FLASH_INTEL640T:\n\t\tfmt = \"28F640B3%s (64 Mbit, %s)\\n\";\n\t\tbreak;\n\tdefault:\n\t\tfmt = \"Unknown Chip Type\\n\";\n\t\tbreak;\n\t}\n\n\tprintf (fmt, bootletter, boottype);\n\n\tprintf (\"  Size: %ld MB in %d Sectors\\n\",\n\t\tinfo->size >> 20,\n\t\tinfo->sector_count);\n\n\tprintf (\"  Sector Start Addresses:\");\n\n\tfor (i=0; i<info->sector_count; ++i) {\n\t\tif ((i % 5) == 0) {\n\t\t\tprintf (\"\\n   \");\n\t\t}\n\n\t\tprintf (\" %08lX%s\", info->start[i],\n\t\t\tinfo->protect[i] ? \" (RO)\" : \"     \");\n\t}\n\n\tprintf (\"\\n\");\n}", "path": "board\\purple\\flash.c", "repo_name": "lichman/U-boot-2009.08_tekkaman", "stars": 1, "license": "other", "language": "c", "size": 12813}
{"docstring": "/* used for ddr1 and ddr2 spd */\n", "func_signal": "static int\nspd_check(const u8 *buf, u8 spd_rev, u8 spd_cksum)", "code": "{\n\tunsigned int cksum = 0;\n\tunsigned int i;\n\n\t/*\n\t * Check SPD revision supported\n\t * Rev 1.2 or less supported by this code\n\t */\n\tif (spd_rev > 0x12) {\n\t\tprintf(\"SPD revision %02X not supported by this code\\n\",\n\t\t       spd_rev);\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Calculate checksum\n\t */\n\tfor (i = 0; i < 63; i++) {\n\t\tcksum += *buf++;\n\t}\n\tcksum &= 0xFF;\n\n\tif (cksum != spd_cksum) {\n\t\tprintf(\"SPD checksum unexpected. \"\n\t\t\t\"Checksum in SPD = %02X, computed SPD = %02X\\n\",\n\t\t\tspd_cksum, cksum);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}", "path": "common\\ddr_spd.c", "repo_name": "lichman/U-boot-2009.08_tekkaman", "stars": 1, "license": "other", "language": "c", "size": 12813}
{"docstring": "/*-----------------------------------------------------------------------\n * Copy memory to flash, returns:\n * 0 - OK\n * 1 - write timeout\n * 2 - Flash not erased\n */\n", "func_signal": "int write_buff (flash_info_t *info, uchar *src, ulong addr, ulong cnt)", "code": "{\n    FPW data = 0; /* 16 or 32 bit word, matches flash bus width on MPC8XX */\n    int bytes;\t  /* number of bytes to program in current word\t\t*/\n    int left;\t  /* number of bytes left to program\t\t\t*/\n    int i, res;\n\n    for (left = cnt, res = 0;\n\t left > 0 && res == 0;\n\t addr += sizeof(data), left -= sizeof(data) - bytes) {\n\n\tbytes = addr & (sizeof(data) - 1);\n\taddr &= ~(sizeof(data) - 1);\n\n\t/* combine source and destination data so can program\n\t * an entire word of 16 or 32 bits\n\t */\n\tfor (i = 0; i < sizeof(data); i++) {\n\t    data <<= 8;\n\t    if (i < bytes || i - bytes >= left )\n\t\tdata += *((uchar *)addr + i);\n\t    else\n\t\tdata += *src++;\n\t}\n\n\tres = write_word(info, (FPWV *)addr, data);\n    }\n\n    return (res);\n}", "path": "board\\purple\\flash.c", "repo_name": "lichman/U-boot-2009.08_tekkaman", "stars": 1, "license": "other", "language": "c", "size": 12813}
{"docstring": "/*-----------------------------------------------------------------------\n */\n", "func_signal": "int flash_erase (flash_info_t * info, int s_first, int s_last)", "code": "{\n\n\tvolatile FLASH_WORD_SIZE *addr =\n\t\t(volatile FLASH_WORD_SIZE *) (info->start[0]);\n\tint flag, prot, sect, l_sect, barf;\n\tulong start, now, last;\n\tint rcode = 0;\n\n\tif ((s_first < 0) || (s_first > s_last)) {\n\t\tif (info->flash_id == FLASH_UNKNOWN) {\n\t\t\tprintf (\"- missing\\n\");\n\t\t} else {\n\t\t\tprintf (\"- no sectors to erase\\n\");\n\t\t}\n\t\treturn 1;\n\t}\n\n\tif ((info->flash_id == FLASH_UNKNOWN) ||\n\t    ((info->flash_id > FLASH_AMD_COMP) &&\n\t     ((info->flash_id & FLASH_VENDMASK) != FLASH_MAN_INTEL))) {\n\t\tprintf (\"Can't erase unknown flash type - aborted\\n\");\n\t\treturn 1;\n\t}\n\n\tprot = 0;\n\tfor (sect = s_first; sect <= s_last; ++sect) {\n\t\tif (info->protect[sect]) {\n\t\t\tprot++;\n\t\t}\n\t}\n\n\tif (prot) {\n\t\tprintf (\"- Warning: %d protected sectors will not be erased!\\n\", prot);\n\t} else {\n\t\tprintf (\"\\n\");\n\t}\n\n\tl_sect = -1;\n\n\t/* Disable interrupts which might cause a timeout here */\n\tflag = disable_interrupts ();\n\tif (info->flash_id < FLASH_AMD_COMP) {\n#ifndef CONFIG_FLASH_16BIT\n\t\taddr[0x0555] = 0x00AA00AA;\n\t\taddr[0x02AA] = 0x00550055;\n\t\taddr[0x0555] = 0x00800080;\n\t\taddr[0x0555] = 0x00AA00AA;\n\t\taddr[0x02AA] = 0x00550055;\n#else\n\t\taddr[0x0555] = 0x00AA;\n\t\taddr[0x02AA] = 0x0055;\n\t\taddr[0x0555] = 0x0080;\n\t\taddr[0x0555] = 0x00AA;\n\t\taddr[0x02AA] = 0x0055;\n#endif\n\t\t/* Start erase on unprotected sectors */\n\t\tfor (sect = s_first; sect <= s_last; sect++) {\n\t\t\tif (info->protect[sect] == 0) {\t/* not protected */\n\t\t\t\taddr = (volatile FLASH_WORD_SIZE *) (info->start[sect]);\n\t\t\t\taddr[0] = (0x00300030 & FLASH_ID_MASK);\n\t\t\t\tl_sect = sect;\n\t\t\t}\n\t\t}\n\n\t\t/* re-enable interrupts if necessary */\n\t\tif (flag)\n\t\t\tenable_interrupts ();\n\n\t\t/* wait at least 80us - let's wait 1 ms */\n\t\tudelay (1000);\n\n\t\t/*\n\t\t * We wait for the last triggered sector\n\t\t */\n\t\tif (l_sect < 0)\n\t\t\tgoto DONE;\n\n\t\tstart = get_timer (0);\n\t\tlast = start;\n\t\taddr = (volatile FLASH_WORD_SIZE *) (info->start[l_sect]);\n\t\twhile ((addr[0] & (0x00800080 & FLASH_ID_MASK)) !=\n\t\t       (0x00800080 & FLASH_ID_MASK)) {\n\t\t\tif ((now = get_timer (start)) > CONFIG_SYS_FLASH_ERASE_TOUT) {\n\t\t\t\tprintf (\"Timeout\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\t/* show that we're waiting */\n\t\t\tif ((now - last) > 1000) {\t/* every second */\n\t\t\t\tserial_putc ('.');\n\t\t\t\tlast = now;\n\t\t\t}\n\t\t}\n\n\t      DONE:\n\t\t/* reset to read mode */\n\t\taddr = (volatile FLASH_WORD_SIZE *) info->start[0];\n\t\taddr[0] = (0x00F000F0 & FLASH_ID_MASK);\t/* reset bank */\n\t} else {\n\n\n\t\tfor (sect = s_first; sect <= s_last; sect++) {\n\t\t\tif (info->protect[sect] == 0) {\t/* not protected */\n\t\t\t\tbarf = 0;\n#ifndef CONFIG_FLASH_16BIT\n\t\t\t\taddr = (vu_long *) (info->start[sect]);\n\t\t\t\taddr[0] = 0x00200020;\n\t\t\t\taddr[0] = 0x00D000D0;\n\t\t\t\twhile (!(addr[0] & 0x00800080));\t/* wait for error or finish */\n\t\t\t\tif (addr[0] & 0x003A003A) {\t/* check for error */\n\t\t\t\t\tbarf = addr[0] & 0x003A0000;\n\t\t\t\t\tif (barf) {\n\t\t\t\t\t\tbarf >>= 16;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbarf = addr[0] & 0x0000003A;\n\t\t\t\t\t}\n\t\t\t\t}\n#else\n\t\t\t\taddr = (vu_short *) (info->start[sect]);\n\t\t\t\taddr[0] = 0x0020;\n\t\t\t\taddr[0] = 0x00D0;\n\t\t\t\twhile (!(addr[0] & 0x0080));\t/* wait for error or finish */\n\t\t\t\tif (addr[0] & 0x003A)\t/* check for error */\n\t\t\t\t\tbarf = addr[0] & 0x003A;\n#endif\n\t\t\t\tif (barf) {\n\t\t\t\t\tprintf (\"\\nFlash error in sector at %lx\\n\", (unsigned long) addr);\n\t\t\t\t\tif (barf & 0x0002)\n\t\t\t\t\t\tprintf (\"Block locked, not erased.\\n\");\n\t\t\t\t\tif ((barf & 0x0030) == 0x0030)\n\t\t\t\t\t\tprintf (\"Command Sequence error.\\n\");\n\t\t\t\t\tif ((barf & 0x0030) == 0x0020)\n\t\t\t\t\t\tprintf (\"Block Erase error.\\n\");\n\t\t\t\t\tif (barf & 0x0008)\n\t\t\t\t\t\tprintf (\"Vpp Low error.\\n\");\n\t\t\t\t\trcode = 1;\n\t\t\t\t} else\n\t\t\t\t\tprintf (\".\");\n\t\t\t\tl_sect = sect;\n\t\t\t}\n\t\t\taddr = (volatile FLASH_WORD_SIZE *) info->start[0];\n\t\t\taddr[0] = (0x00FF00FF & FLASH_ID_MASK);\t/* reset bank */\n\n\t\t}\n\n\t}\n\tprintf (\" done\\n\");\n\treturn rcode;\n}", "path": "board\\esteem192e\\flash.c", "repo_name": "lichman/U-boot-2009.08_tekkaman", "stars": 1, "license": "other", "language": "c", "size": 12813}
{"docstring": "/******************************************************************************\n*\n* Don't change the program architecture\n* This architecture assure the program\n* can be relocated to scratch ram\n*/\n", "func_signal": "static void flash_write_cmd(int cmd, FPWV * pFA, FPW value)", "code": "{\n\t*(FLASH29_REG_FIRST_CYCLE)  = FLASH29_CMD_FIRST;\n\t*(FLASH29_REG_SECOND_CYCLE) = FLASH29_CMD_SECOND;\n\n\tif (cmd == FLASH29_CMD_SECTOR)\n\t   {\n\t    *(FLASH29_REG_THIRD_CYCLE)  = FLASH29_CMD_CHIP_ERASE;\n\t    *(FLASH29_REG_FOURTH_CYCLE) = FLASH29_CMD_FOURTH;\n\t    *(FLASH29_REG_FIFTH_CYCLE)  = FLASH29_CMD_FIFTH;\n\t    *pFA\t\t        = FLASH29_CMD_SECTOR;\n\t   }\n\n\tif (cmd == FLASH29_CMD_SIXTH)\n\t   {\n\t    *(FLASH29_REG_THIRD_CYCLE)  = FLASH29_CMD_CHIP_ERASE;\n\t    *(FLASH29_REG_FOURTH_CYCLE) = FLASH29_CMD_FOURTH;\n\t    *(FLASH29_REG_FIFTH_CYCLE)  = FLASH29_CMD_FIFTH;\n\t    *(FLASH29_REG_SIXTH_CYCLE)  = FLASH29_CMD_SIXTH;\n\t   }\n\n\tif (cmd == FLASH29_CMD_PROGRAM)\n\t   {\n\t    *(FLASH29_REG_THIRD_CYCLE)  = FLASH29_CMD_PROGRAM;\n\t    *pFA = value;\n\t   }\n\n\tif (cmd == FLASH29_CMD_READ_RESET)\n\t   {\n\t    *(FLASH29_REG_THIRD_CYCLE)  = FLASH29_CMD_READ_RESET;\n\t   }\n\n\t*(int *)0xbf0081f8 = *(int *)0xa0000000;\t/* dummy read switch back to sdram interface */\n}", "path": "board\\purple\\flash.c", "repo_name": "lichman/U-boot-2009.08_tekkaman", "stars": 1, "license": "other", "language": "c", "size": 12813}
{"docstring": "/**\n * catalina_storage_open:\n * @storage: A #CatalinaStorage\n * @env_dir: the environment directory for the database\n * @name: the name of the database\n * @error: A location for a #GError or %NULL\n *\n * Synchronously opens the underlying data-store for use.  This method is not the preferred\n * way to perform the operation.  See using catalina_storage_open_async() for the preferred\n * alternative.\n *\n * On failure, %FALSE is returned and @error is set.\n *\n * Return value: %TRUE on success\n */\n", "func_signal": "gboolean\ncatalina_storage_open (CatalinaStorage  *storage,\n                       const            gchar *env_dir,\n                       const            gchar *name,\n                       GError          **error)", "code": "{\n\tCatalinaStoragePrivate *priv;\n\tStorageTask            *task;\n\tgchar                  *real_env_dir;\n\tIrisMessage            *message;\n\tgboolean                success;\n\n\tg_return_val_if_fail (CATALINA_IS_STORAGE (storage), FALSE);\n\tg_return_val_if_fail (name != NULL, FALSE);\n\n\tpriv = storage->priv;\n\n\treal_env_dir = g_strdup (env_dir != NULL ? env_dir : \".\");\n\ttask = storage_task_new (storage, FALSE, NULL, NULL, NULL);\n\ttask->key = g_build_filename (real_env_dir, name, NULL);\n\tg_free (real_env_dir);\n\n\tmessage = iris_message_new_data (MESSAGE_OPEN, G_TYPE_POINTER, task);\n\tiris_port_post (priv->ex_port, message);\n\tiris_message_unref (message);\n\n\tsuccess = storage_task_wait (task, error);\n\tstorage_task_free (task, TRUE, FALSE);\n\n\treturn success;\n}", "path": "catalina\\catalina-storage.c", "repo_name": "cicerolneto/catalina", "stars": 0, "license": "lgpl-2.1", "language": "c", "size": 260}
{"docstring": "/**\n * catalina_storage_set_formatter:\n * @storage: A #CatalinaStorage\n * @formatter: A #CatalinaFormatter\n *\n * Sets the \"formatter\" property.\n *\n * This method is not thread-safe.\n */\n", "func_signal": "void\ncatalina_storage_set_formatter (CatalinaStorage   *storage,\n                                CatalinaFormatter *formatter)", "code": "{\n\tg_return_if_fail (CATALINA_IS_STORAGE (storage));\n\tif (CATALINA_STORAGE (storage)->priv->formatter)\n\t\tg_object_unref (CATALINA_STORAGE (storage)->priv->formatter);\n\tCATALINA_STORAGE (storage)->priv->formatter = g_object_ref (formatter);\n\tg_object_notify (G_OBJECT (storage), \"formatter\");\n}", "path": "catalina\\catalina-storage.c", "repo_name": "cicerolneto/catalina", "stars": 0, "license": "lgpl-2.1", "language": "c", "size": 260}
{"docstring": "/**\n * catalina_storage_open_async:\n * @storage: A #CatalinaStorage\n * @env_dir: environment directory for database or %NULL for current working directory\n * @name: name of the database\n * @callback: A #GAsyncReadyCallback\n * @user_data: data for @callback\n *\n * Asynchronously opens the underlying data-store.  Call catalina_storage_open_finish()\n * from within @callback to complete the request.\n */\n", "func_signal": "void\ncatalina_storage_open_async (CatalinaStorage     *storage,\n                             const gchar         *env_dir,\n                             const gchar         *name,\n                             GAsyncReadyCallback  callback,\n                             gpointer             user_data)", "code": "{\n\tCatalinaStoragePrivate *priv;\n\tStorageTask            *task;\n\tgchar                  *real_env_dir;\n\tIrisMessage            *message;\n\n\tg_return_if_fail (CATALINA_IS_STORAGE (storage));\n\tg_return_if_fail (name != NULL);\n\n\tpriv = storage->priv;\n\n\treal_env_dir = g_strdup (env_dir != NULL ? env_dir : \".\");\n\ttask = storage_task_new (storage, TRUE, callback, user_data,\n\t                         catalina_storage_open_async);\n\ttask->key = g_build_filename (real_env_dir, name, NULL);\n\tg_free (real_env_dir);\n\n\tmessage = iris_message_new_data (MESSAGE_OPEN, G_TYPE_POINTER, task);\n\tiris_port_post (priv->ex_port, message);\n\tiris_message_unref (message);\n}", "path": "catalina\\catalina-storage.c", "repo_name": "cicerolneto/catalina", "stars": 0, "license": "lgpl-2.1", "language": "c", "size": 260}
{"docstring": "/**\n * catalina_storage_open_finish:\n * @storage: A #CatalinaStorage\n * @result: A #GAsyncResult\n * @error: A location for a #GError or %NULL\n *\n * Completes an asynchronous operation to open the #CatalinaStorage.  If there was an error,\n * %FALSE is returned and @error is set.\n *\n * Return value: %TRUE on success\n */\n", "func_signal": "gboolean\ncatalina_storage_open_finish (CatalinaStorage  *storage,\n                              GAsyncResult     *result,\n                              GError          **error)", "code": "{\n\tCatalinaStoragePrivate *priv;\n\tStorageTask            *task;\n\tgboolean                success = FALSE;\n\n\tg_return_val_if_fail (CATALINA_IS_STORAGE (storage), FALSE);\n\tg_return_val_if_fail (g_simple_async_result_is_valid (result, G_OBJECT (storage),\n\t                                                      catalina_storage_open_async),\n\t                      FALSE);\n\n\tpriv = storage->priv;\n\n\tif (!(task = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (result)))) {\n\t\tg_critical (\"GSimpleAsyncResult does not have a StorageTask\");\n\t\treturn FALSE;\n\t}\n\n\tif (task->error) {\n\t\tif (error && *error == NULL)\n\t\t\t*error = g_error_copy (task->error);\n\t\tgoto cleanup;\n\t}\n\n\tpriv->flags |= FLAG_READY;\n\tsuccess = TRUE;\n\ncleanup:\n\tstorage_task_free (task, TRUE, FALSE);\n\n\treturn success;\n}", "path": "catalina\\catalina-storage.c", "repo_name": "cicerolneto/catalina", "stars": 0, "license": "lgpl-2.1", "language": "c", "size": 260}
{"docstring": "/**\n * catalina_storage_get_value:\n * @storage: A #CatalinaStorage\n * @key: A #const\n * @key_length: the length in bytes of @key or -1 if @key is %NULL terminated\n * @value: A #GValue to store the resulting value\n * @error: A location for a #GError or %NULL\n *\n * Synchronously requests the content for @key and deserializes using the instances\n * \"formatter\" property.\n *\n * Upon failure, %FALSE is returned and @error is set.\n *\n * Return value: %TRUE on success\n */\n", "func_signal": "gboolean\ncatalina_storage_get_value (CatalinaStorage  *storage,\n                            const gchar      *key,\n                            gssize            key_length,\n                            GValue           *value,\n                            GError          **error)", "code": "{\n\tCatalinaStoragePrivate *priv;\n\tgchar                  *buffer        = NULL;\n\tgsize                   buffer_length = 0;\n\tgboolean                success;\n\n\tg_return_val_if_fail (CATALINA_IS_STORAGE (storage), FALSE);\n\tg_return_val_if_fail (key != NULL, FALSE);\n\tg_return_val_if_fail (key_length == -1 || key_length > 0, FALSE);\n\tg_return_val_if_fail (value != NULL, FALSE);\n\n\tpriv = storage->priv;\n\n\tif (!priv->formatter) {\n\t\tg_set_error (error, CATALINA_STORAGE_ERROR,\n\t\t             CATALINA_STORAGE_ERROR_STATE,\n\t\t             \"CatalinaStorage is missing a formatter for deserialization\");\n\t\treturn FALSE;\n\t}\n\n\tif (!catalina_storage_get (storage, key, key_length,\n\t                           &buffer, &buffer_length, error))\n\t\treturn FALSE;\n\n\tsuccess = catalina_formatter_deserialize (priv->formatter, value,\n\t                                          buffer, buffer_length,\n\t                                          error);\n\tg_free (buffer);\n\treturn success;\n}", "path": "catalina\\catalina-storage.c", "repo_name": "cicerolneto/catalina", "stars": 0, "license": "lgpl-2.1", "language": "c", "size": 260}
{"docstring": "/**\n * catalina_storage_get_formatter:\n * @storage: A #CatalinaStorage\n *\n * This method is not thread-safe.\n *\n * Return value: The #CatalinaFormatter property\n */\n", "func_signal": "CatalinaFormatter*\ncatalina_storage_get_formatter (CatalinaStorage *storage)", "code": "{\n\tg_return_val_if_fail (CATALINA_IS_STORAGE (storage), NULL);\n\treturn CATALINA_STORAGE (storage)->priv->formatter;\n}", "path": "catalina\\catalina-storage.c", "repo_name": "cicerolneto/catalina", "stars": 0, "license": "lgpl-2.1", "language": "c", "size": 260}
{"docstring": "/**\n * catalina_storage_get_value_async:\n * @storage: A #CatalinaStorage\n * @key: the key to lookup\n * @key_length: the length of @key in bytes\n * @callback: A #GAsyncReadyCallback\n * @user_data: data for @callback\n *\n * Asynchronously requests the content for @key.  In the process, the data is retrieved from\n * storage and deserialized by the #CatalinaStorage instance's \"formatter\" property.\n */\n", "func_signal": "void\ncatalina_storage_get_value_async (CatalinaStorage     *storage,\n                                  const gchar         *key,\n                                  gssize               key_length,\n                                  GAsyncReadyCallback  callback,\n                                  gpointer             user_data)", "code": "{\n\tCatalinaStoragePrivate *priv;\n\tStorageTask            *task;\n\n\tg_return_if_fail (CATALINA_IS_STORAGE (storage));\n\n\tpriv = storage->priv;\n\n\tif (!priv->formatter)\n\t\tg_critical (\"%s called without a formatter\", __func__);\n\n\ttask = storage_task_new (storage, TRUE, callback, user_data,\n\t                         catalina_storage_get_value_async);\n\tcatalina_storage_get_async (storage, key, key_length,\n\t                            (GAsyncReadyCallback)catalina_storage_get_value_async_cb,\n\t                            task);\n}", "path": "catalina\\catalina-storage.c", "repo_name": "cicerolneto/catalina", "stars": 0, "license": "lgpl-2.1", "language": "c", "size": 260}
{"docstring": "/**\n * catalina_storage_set_use_idle:\n * @storage: A #CatalinaStorage\n * @use_idle: a #gboolean\n *\n * Sets whether or not callbacks should occur from within an idle timeout in the main-loop.\n */\n", "func_signal": "void\ncatalina_storage_set_use_idle (CatalinaStorage *storage,\n                               gboolean         use_idle)", "code": "{\n\tg_return_if_fail (CATALINA_IS_STORAGE (storage));\n\tstorage->priv->use_idle = use_idle;\n\tg_object_notify (G_OBJECT (storage), \"use-idle\");\n}", "path": "catalina\\catalina-storage.c", "repo_name": "cicerolneto/catalina", "stars": 0, "license": "lgpl-2.1", "language": "c", "size": 260}
{"docstring": "/**\n * catalina_storage_transaction_cancel_finish:\n * @storage: A #CatalinaStorage\n * @result: a #GAsyncResult\n *\n * Completes and asynchronous request to cancel the current transaction.\n *\n * The state is automatically rolled back to that of before the transaction.\n */\n", "func_signal": "void\ncatalina_storage_transaction_cancel_finish (CatalinaStorage *storage,\n                                            GAsyncResult    *result)", "code": "{\n\tCatalinaStoragePrivate *priv;\n\tStorageTask            *task;\n\n\tg_return_if_fail (CATALINA_IS_STORAGE (storage));\n\tg_return_if_fail (g_simple_async_result_is_valid (result, G_OBJECT (storage),\n\t                                                      catalina_storage_transaction_cancel_async));\n\n\tpriv = storage->priv;\n\ttask = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (result));\n\n\tstorage_task_free (task, FALSE, FALSE);\n}", "path": "catalina\\catalina-storage.c", "repo_name": "cicerolneto/catalina", "stars": 0, "license": "lgpl-2.1", "language": "c", "size": 260}
{"docstring": "/**\n * catalina_storage_close_finish:\n * @storage: A #CatalinaStorage\n * @result: A #GAsyncResult\n * @error: A #GError\n *\n * Completes the asynchronous request to close the underlying data-store.\n *\n * Upon failure, %FALSE is returned and @error is set.\n *\n * Return value: %TRUE on success\n */\n", "func_signal": "gboolean\ncatalina_storage_close_finish (CatalinaStorage  *storage,\n                               GAsyncResult     *result,\n                               GError          **error)", "code": "{\n\tCatalinaStoragePrivate *priv;\n\tStorageTask            *task;\n\tgboolean                success = FALSE;\n\n\tg_return_val_if_fail (CATALINA_IS_STORAGE (storage), FALSE);\n\tg_return_val_if_fail (g_simple_async_result_is_valid (result, G_OBJECT (storage),\n\t                                                      catalina_storage_close_async),\n\t                      FALSE);\n\n\tpriv = storage->priv;\n\n\tif (!(task = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (result)))) {\n\t\tg_critical (\"GSimpleAsyncResult does not have a StorageTask\");\n\t\treturn FALSE;\n\t}\n\n\tif (task->error) {\n\t\tif (error && *error == NULL)\n\t\t\t*error = g_error_copy (task->error);\n\t\tgoto cleanup;\n\t}\n\n\tpriv->flags = 0;\n\tsuccess = TRUE;\n\ncleanup:\n\tstorage_task_free (task, FALSE, FALSE);\n\n\treturn success;\n}", "path": "catalina\\catalina-storage.c", "repo_name": "cicerolneto/catalina", "stars": 0, "license": "lgpl-2.1", "language": "c", "size": 260}
{"docstring": "/***************************************************************************\n *     Storage Tasks - Asynchronous and Synchronous Task Encapsulation     *\n ***************************************************************************/\n", "func_signal": "StorageTask*\nstorage_task_new (CatalinaStorage     *storage,\n                  gboolean             is_async,\n                  GAsyncReadyCallback  callback,\n                  gpointer             user_data,\n                  gpointer             source_tag)", "code": "{\n\tStorageTask *task;\n\n\ttask = g_slice_new0 (StorageTask);\n\ttask->storage = storage;\n\n\tif (!is_async) {\n\t\t/* FIXME: Use IrisFreeList to re-use mutex and cond */\n\t\ttask->mutex = g_mutex_new ();\n\t\ttask->cond = g_cond_new ();\n\t\tg_mutex_lock (task->mutex);\n\t}\n\telse {\n\t\ttask->result = g_simple_async_result_new (G_OBJECT (storage),\n\t\t                                          callback, user_data,\n\t\t                                          source_tag);\n\t\tg_simple_async_result_set_op_res_gpointer (task->result, task, NULL);\n\t}\n\n\treturn task;\n}", "path": "catalina\\catalina-storage.c", "repo_name": "cicerolneto/catalina", "stars": 0, "license": "lgpl-2.1", "language": "c", "size": 260}
{"docstring": "/**\n * catalina_zlib_transform_get_level:\n * @transform: A #CatalinaZlibTransform\n *\n * Retrieves the current compression level.\n *\n * Return value: a #gint containing the compression level\n */\n", "func_signal": "gint\ncatalina_zlib_transform_get_level (CatalinaZlibTransform *transform)", "code": "{\n\tg_return_val_if_fail (CATALINA_IS_ZLIB_TRANSFORM (transform), 0);\n\treturn transform->priv->level;\n}", "path": "catalina\\catalina-zlib-transform.c", "repo_name": "cicerolneto/catalina", "stars": 0, "license": "lgpl-2.1", "language": "c", "size": 260}
{"docstring": "/**\n * catalina_zlib_transform_set_level:\n * @transform: A #CatalinaZlibTransform\n * @level: the compression level\n *\n * Sets the compression level to use by the zlib compressor.\n */\n", "func_signal": "void\ncatalina_zlib_transform_set_level (CatalinaZlibTransform *transform,\n                                   gint                   level)", "code": "{\n\tg_return_if_fail (CATALINA_IS_ZLIB_TRANSFORM (transform));\n\ttransform->priv->level = level;\n}", "path": "catalina\\catalina-zlib-transform.c", "repo_name": "cicerolneto/catalina", "stars": 0, "license": "lgpl-2.1", "language": "c", "size": 260}
{"docstring": "/**\n * catalina_storage_transaction_commit_async:\n * @storage: A #CatalinaStorage\n * @txn_id: the transaction id from a call to catalina_storage_transaction_begin_async()\n * @callback: A #GAsyncReadyCallback to call when the transaction is ready\n * @user_data: data for @callback\n *\n * Asynchronously beings the process of committing a transaction.\n *\n * Upon failure, %FALSE is returned and @error is set.  If you want to bring the storage back to a\n * consistent state, call catalina_storage_transaction_rollback().\n */\n", "func_signal": "void\ncatalina_storage_transaction_commit_async (CatalinaStorage     *storage,\n                                           gulong               txn_id,\n                                           GAsyncReadyCallback  callback,\n                                           gpointer             user_data)", "code": "{\n\tCatalinaStoragePrivate *priv;\n\tStorageTask            *task;\n\tIrisMessage            *message;\n\n\tg_return_if_fail (CATALINA_IS_STORAGE (storage));\n\n\tpriv = storage->priv;\n\ttask = storage_task_new (storage, TRUE, callback, user_data,\n\t                         catalina_storage_transaction_commit_async);\n\ttask->txn_id = txn_id;\n\n\tmessage = iris_message_new_data (MESSAGE_TXN_COMMIT, G_TYPE_POINTER, task);\n\tiris_port_post (priv->ex_port, message);\n\tiris_message_unref (message);\n}", "path": "catalina\\catalina-storage.c", "repo_name": "cicerolneto/catalina", "stars": 0, "license": "lgpl-2.1", "language": "c", "size": 260}
{"docstring": "/**\n * catalina_storage_transaction_cancel_async:\n * @storage: A #CatalinaStorage\n * @txn_id: A transaction id retrieved from catalina_storage_transaction_begin_async()\n * @callback: a callback to execute when the transaction is cancelled\n * @user_data: data for @callback\n *\n * Asynchronously cancels transaction @txn_id.  There is no need to call\n * catalina_storage_transaction_rollback_async() as the state will be rolled back automatically.\n */\n", "func_signal": "void\ncatalina_storage_transaction_cancel_async (CatalinaStorage     *storage,\n                                           gulong               txn_id,\n                                           GAsyncReadyCallback  callback,\n                                           gpointer             user_data)", "code": "{\n\tCatalinaStoragePrivate *priv;\n\tStorageTask            *task;\n\tIrisMessage            *message;\n\n\tg_return_if_fail (CATALINA_IS_STORAGE (storage));\n\n\tpriv = storage->priv;\n\ttask = storage_task_new (storage, TRUE, callback, user_data,\n\t                         catalina_storage_transaction_cancel_async);\n\ttask->txn_id = txn_id;\n\n\tmessage = iris_message_new_data (MESSAGE_TXN_CANCEL, G_TYPE_POINTER, task);\n\tiris_port_post (priv->ex_port, message);\n\tiris_message_unref (message);\n}", "path": "catalina\\catalina-storage.c", "repo_name": "cicerolneto/catalina", "stars": 0, "license": "lgpl-2.1", "language": "c", "size": 260}
{"docstring": "/**\n * catalina_storage_set_transform:\n * @storage: A #CatalinaStorage\n * @transform: A #CatalinaTransform\n *\n * Sets the #CatalinaTransform for the storage.  This is the \"transform\" property.\n *\n * This method is not thread-safe.\n */\n", "func_signal": "void\ncatalina_storage_set_transform (CatalinaStorage   *storage,\n                                CatalinaTransform *transform)", "code": "{\n\tg_return_if_fail (CATALINA_IS_STORAGE (storage));\n\tif (CATALINA_STORAGE (storage)->priv->transform)\n\t\tg_object_unref (CATALINA_STORAGE (storage)->priv->transform);\n\tCATALINA_STORAGE (storage)->priv->transform = g_object_ref (transform);\n\tg_object_notify (G_OBJECT (storage), \"transform\");\n}", "path": "catalina\\catalina-storage.c", "repo_name": "cicerolneto/catalina", "stars": 0, "license": "lgpl-2.1", "language": "c", "size": 260}
{"docstring": "/***************************************************************************\n *                           Transaction State                             *\n ***************************************************************************/\n", "func_signal": "static TxnState*\ntxn_state_new (CatalinaStorage *storage,\n               gulong           txn_id)", "code": "{\n\tTxnState *state = g_slice_new0 (TxnState);\n\tstate->txn_id = txn_id;\n\tstate->storage = storage;\n\tstate->msgs = NULL;\n\tstate->error = NULL;\n\treturn state;\n}", "path": "catalina\\catalina-storage.c", "repo_name": "cicerolneto/catalina", "stars": 0, "license": "lgpl-2.1", "language": "c", "size": 260}
{"docstring": "/**\n * catalina_storage_get_finish:\n * @storage: A #CatalinaStorage\n * @result: A #GAsyncResult\n * @value: A location for the requested buffer\n * @value_length: A location for the requested buffer size, or %NULL\n * @error: A location for a #GError or %NULL\n *\n * Completes an asynchronous get request.\n *\n * Upon failure, %FALSE is returned and @error is set.\n *\n * See catalina_storage_get_async().\n *\n * Return value: %TRUE on success\n */\n", "func_signal": "gboolean\ncatalina_storage_get_finish (CatalinaStorage  *storage,\n                             GAsyncResult     *result,\n                             gchar           **value,\n                             gsize            *value_length,\n                             GError          **error)", "code": "{\n\tCatalinaStoragePrivate *priv;\n\tStorageTask            *task;\n\tgboolean                success;\n\n\tg_return_val_if_fail (CATALINA_IS_STORAGE (storage), FALSE);\n\tg_return_val_if_fail (value != NULL, FALSE);\n\tg_return_val_if_fail (g_simple_async_result_is_valid (result, G_OBJECT (storage),\n\t                                                      catalina_storage_get_async),\n\t                      FALSE);\n\n\tpriv = storage->priv;\n\n\tif (!(task = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (result)))) {\n\t\tg_critical (\"GSimpleAsyncResult does not have a StorageTask\");\n\t\treturn FALSE;\n\t}\n\n\tsuccess = task->success;\n\n\tif (task->error) {\n\t\tif (error && *error == NULL)\n\t\t\t*error = g_error_copy (task->error);\n\t\tgoto cleanup;\n\t}\n\telse {\n\t\tif (task->data)\n\t\t\t*value = task->data;\n\t\tif (value_length)\n\t\t\t*value_length = task->data_length;\n\t}\n\ncleanup:\n\tstorage_task_free (task, TRUE, FALSE);\n\n\treturn success;\n}", "path": "catalina\\catalina-storage.c", "repo_name": "cicerolneto/catalina", "stars": 0, "license": "lgpl-2.1", "language": "c", "size": 260}
{"docstring": "/**\n * catalina_zlib_transform_get_watermark:\n * @transform: A #CatalinaZlibTransform\n *\n * Retrieves the current watermark.  The watermark is used to prevent compression of objects\n * smaller than or equal to the level in bytes.\n *\n * Return value: a #gint containing the watermark\n */\n", "func_signal": "gint\ncatalina_zlib_transform_get_watermark (CatalinaZlibTransform *transform)", "code": "{\n\tg_return_val_if_fail (CATALINA_IS_ZLIB_TRANSFORM (transform), 0);\n\treturn transform->priv->watermark;\n}", "path": "catalina\\catalina-zlib-transform.c", "repo_name": "cicerolneto/catalina", "stars": 0, "license": "lgpl-2.1", "language": "c", "size": 260}
{"docstring": "/**\n * catalina_storage_set_value_finish:\n * @storage: A #CatalinaStorage\n * @result: A #GAsyncResult\n * @error: A location for a #GError or %NULL\n *\n * Completes and asynchronous request to catalina_storage_set_value_async().\n *\n * Upon failure, %FALSE is returned and @error is set.\n *\n * Return value: %TRUE on success\n */\n", "func_signal": "gboolean\ncatalina_storage_set_value_finish (CatalinaStorage  *storage,\n                                   GAsyncResult     *result,\n                                   GError          **error)", "code": "{\n\tCatalinaStoragePrivate *priv;\n\tStorageTask            *task;\n\tgboolean                success;\n\n\tg_return_val_if_fail (CATALINA_IS_STORAGE (storage), FALSE);\n\n\tpriv = storage->priv;\n\ttask = g_simple_async_result_get_op_res_gpointer ((gpointer)result);\n\n\tsuccess = task->success;\n\tif (task->error && error && *error == NULL) {\n\t\t*error = task->error;\n\t\ttask->error = NULL;\n\t}\n\n\tstorage_task_free (task, TRUE, TRUE);\n\n\treturn success;\n}", "path": "catalina\\catalina-storage.c", "repo_name": "cicerolneto/catalina", "stars": 0, "license": "lgpl-2.1", "language": "c", "size": 260}
{"docstring": "/* set up a connection to write a buffer then free it, used for stats */\n", "func_signal": "static void write_and_free(conn *c, char *buf, int bytes)", "code": "{\n    if (buf) {\n        c->write_and_free = buf;\n        c->wcurr = buf;\n        c->wbytes = bytes;\n        conn_set_state(c, conn_write);\n        c->write_and_go = get_init_state(c);\n    } else {\n        out_string(c, \"SERVER_ERROR out of memory writing stats\");\n    }\n}", "path": "src\\p2netd\\main.c", "repo_name": "clintwebb/p2net", "stars": 1, "license": "None", "language": "c", "size": 116}
{"docstring": "/*\n * adds a delta value to a numeric item.\n *\n * it    item to adjust\n * incr  true to increment value, false to decrement\n * delta amount to adjust value by\n * buf   buffer for response string\n *\n * returns a response string to send back to the client.\n */\n", "func_signal": "char *do_add_delta(item *it, const bool incr, const int64_t delta, char *buf)", "code": "{\n    char *ptr;\n    int64_t value;\n    int res;\n\n    ptr = ITEM_data(it);\n    while ((*ptr != '\\0') && (*ptr < '0' && *ptr > '9')) ptr++;    // BUG: can't be true\n\n    value = strtoull(ptr, NULL, 10);\n\n    if(errno == ERANGE) {\n        return \"CLIENT_ERROR cannot increment or decrement non-numeric value\";\n    }\n\n    if (incr)\n        value += delta;\n    else {\n        value -= delta;\n    }\n    if(value < 0) {\n        value = 0;\n    }\n    sprintf(buf, \"%llu\", value);\n    res = strlen(buf);\n    if (res + 2 > it->nbytes) { /* need to realloc */\n        item *new_it;\n        new_it = do_item_alloc(ITEM_key(it), it->nkey, atoi(ITEM_suffix(it) + 1), it->exptime, res + 2 );\n        if (new_it == 0) {\n            return \"SERVER_ERROR out of memory in incr/decr\";\n        }\n        memcpy(ITEM_data(new_it), buf, res);\n        memcpy(ITEM_data(new_it) + res, \"\\r\\n\", 3);\n        do_item_replace(it, new_it);\n        do_item_remove(new_it);       /* release our reference */\n    } else { /* replace in-place */\n        memcpy(ITEM_data(it), buf, res);\n        memset(ITEM_data(it) + res, ' ', it->nbytes - res - 2);\n    }\n\n    return buf;\n}", "path": "src\\p2netd\\main.c", "repo_name": "clintwebb/p2net", "stars": 1, "license": "None", "language": "c", "size": 116}
{"docstring": "/* Byte swap a 64-bit number */\n", "func_signal": "static int64_t swap64(int64_t in)", "code": "{\n#ifdef ENDIAN_LITTLE\n    /* Little endian, flip the bytes around until someone makes a faster/better\n    * way to do this. */\n    int64_t rv = 0;\n    int i = 0;\n     for(i = 0; i<8; i++) {\n        rv = (rv << 8) | (in & 0xff);\n        in >>= 8;\n     }\n    return rv;\n#else\n    /* big-endian machines don't need byte swapping */\n    return in;\n#endif\n}", "path": "src\\p2netd\\main.c", "repo_name": "clintwebb/p2net", "stars": 1, "license": "None", "language": "c", "size": 116}
{"docstring": "/*\n * Adds an item to the deferred-delete list so it can be reaped later.\n *\n * Returns the result to send to the client.\n */\n", "func_signal": "char *do_defer_delete(item *it, time_t exptime)", "code": "{\n    if (delcurr >= deltotal) {\n        item **new_delete = realloc(todelete, sizeof(item *) * deltotal * 2);\n        if (new_delete) {\n            todelete = new_delete;\n            deltotal *= 2;\n        } else {\n            /*\n             * can't delete it immediately, user wants a delay,\n             * but we ran out of memory for the delete queue\n             */\n            item_remove(it);    /* release reference */\n            return \"SERVER_ERROR out of memory expanding delete queue\";\n        }\n    }\n\n    /* use its expiration time as its deletion time now */\n    it->exptime = realtime(exptime);\n    it->it_flags |= ITEM_DELETED;\n    todelete[delcurr++] = it;\n\n    return \"DELETED\";\n}", "path": "src\\p2netd\\main.c", "repo_name": "clintwebb/p2net", "stars": 1, "license": "None", "language": "c", "size": 116}
{"docstring": "/*\n * if we have a complete line in the buffer, process it.\n */\n", "func_signal": "static int try_read_command(conn *c)", "code": "{\n    char *el, *cont;\n\n    assert(c != NULL);\n    assert(c->rcurr <= (c->rbuf + c->rsize));\n\n    if (c->rbytes == 0)\n        return 0;\n    el = memchr(c->rcurr, '\\n', c->rbytes);\n    if (!el)\n        return 0;\n    cont = el + 1;\n    if ((el - c->rcurr) > 1 && *(el - 1) == '\\r') {\n        el--;\n    }\n    *el = '\\0';\n\n    assert(cont <= (c->rcurr + c->rbytes));\n\n    process_command(c, c->rcurr);\n\n    c->rbytes -= (cont - c->rcurr);\n    c->rcurr = cont;\n\n    assert(c->rcurr <= (c->rbuf + c->rsize));\n\n    return 1;\n}", "path": "src\\p2netd\\main.c", "repo_name": "clintwebb/p2net", "stars": 1, "license": "None", "language": "c", "size": 116}
{"docstring": "/* time-sensitive callers can call it by hand with this, outside the normal ever-1-second timer */\n", "func_signal": "static void set_current_time(void)", "code": "{\n    struct timeval timer;\n\n    gettimeofday(&timer, NULL);\n    current_time = (rel_time_t) (timer.tv_sec - stats.started);\n}", "path": "src\\p2netd\\main.c", "repo_name": "clintwebb/p2net", "stars": 1, "license": "None", "language": "c", "size": 116}
{"docstring": "/*\n * Stores an item in the cache according to the semantics of one of the set\n * commands. In threaded mode, this is protected by the cache lock.\n *\n * Returns true if the item was stored.\n */\n", "func_signal": "int do_store_item(item *it, int comm)", "code": "{\n    char *key = ITEM_key(it);\n    bool delete_locked = false;\n    item *old_it = do_item_get_notedeleted(key, it->nkey, &delete_locked);\n    int stored = 0;\n\n    item *new_it = NULL;\n    int flags;\n\n    if (old_it != NULL && comm == NREAD_ADD) {\n        /* add only adds a nonexistent item, but promote to head of LRU */\n        do_item_update(old_it);\n    } else if (!old_it && (comm == NREAD_REPLACE\n        || comm == NREAD_APPEND || comm == NREAD_PREPEND))\n    {\n        /* replace only replaces an existing value; don't store */\n    } else if (delete_locked && (comm == NREAD_REPLACE || comm == NREAD_ADD\n        || comm == NREAD_APPEND || comm == NREAD_PREPEND))\n    {\n        /* replace and add can't override delete locks; don't store */\n    } else if (comm == NREAD_CAS) {\n        /* validate cas operation */\n        if (delete_locked)\n            old_it = do_item_get_nocheck(key, it->nkey);\n\n        if(old_it == NULL) {\n          // LRU expired\n          stored = 3;\n        }\n        else if(it->cas_id == old_it->cas_id) {\n          // cas validates\n          do_item_replace(old_it, it);\n          stored = 1;\n        } else {\n          if(settings.verbose > 1) {\n            fprintf(stderr, \"CAS:  failure: expected %llu, got %llu\\n\",\n                old_it->cas_id, it->cas_id);\n          }\n          stored = 2;\n        }\n    } else {\n        /*\n         * Append - combine new and old record into single one. Here it's\n         * atomic and thread-safe.\n         */\n\n        if (comm == NREAD_APPEND || comm == NREAD_PREPEND) {\n\n            /* we have it and old_it here - alloc memory to hold both */\n            /* flags was already lost - so recover them from ITEM_suffix(it) */\n\n            flags = (int) strtol(ITEM_suffix(old_it), (char **) NULL, 10);\n\n            new_it = do_item_alloc(key, it->nkey, flags, old_it->exptime, it->nbytes + old_it->nbytes - 2 /* CRLF */);\n\n            if (new_it == NULL) {\n                /* SERVER_ERROR out of memory */\n                return 0;\n            }\n\n            /* copy data from it and old_it to new_it */\n\n            if (comm == NREAD_APPEND) {\n                memcpy(ITEM_data(new_it), ITEM_data(old_it), old_it->nbytes);\n                memcpy(ITEM_data(new_it) + old_it->nbytes - 2 /* CRLF */, ITEM_data(it), it->nbytes);\n            } else {\n                /* NREAD_PREPEND */\n                memcpy(ITEM_data(new_it), ITEM_data(it), it->nbytes);\n                memcpy(ITEM_data(new_it) + it->nbytes - 2 /* CRLF */, ITEM_data(old_it), old_it->nbytes);\n            }\n\n            it = new_it;\n        }\n\n        /* \"set\" commands can override the delete lock\n           window... in which case we have to find the old hidden item\n           that's in the namespace/LRU but wasn't returned by\n           item_get.... because we need to replace it */\n        if (delete_locked)\n            old_it = do_item_get_nocheck(key, it->nkey);\n\n        if (old_it != NULL)\n            do_item_replace(old_it, it);\n        else\n            do_item_link(it);\n\n        stored = 1;\n    }\n\n    if (old_it != NULL)\n        do_item_remove(old_it);         /* release our reference */\n    if (new_it != NULL)\n        do_item_remove(new_it);\n\n    return stored;\n}", "path": "src\\p2netd\\main.c", "repo_name": "clintwebb/p2net", "stars": 1, "license": "None", "language": "c", "size": 116}
{"docstring": "/* Set the given connection to its initial state.  The initial state will vary\n * base don protocol type. */\n", "func_signal": "static void conn_set_init_state(conn *c)", "code": "{\n\tassert(c != NULL);\n\n\tconn_set_state(c, get_init_state(c));\n}", "path": "src\\p2netd\\main.c", "repo_name": "clintwebb/p2net", "stars": 1, "license": "None", "language": "c", "size": 116}
{"docstring": "//-----------------------------------------------------------------------------\n// Handle the signal.  Any signal we receive can only mean that we need to exit.\n", "func_signal": "static void sig_handler(const int sig)", "code": "{\n    printf(\"SIGINT handled.\\n\");\n    exit(EXIT_SUCCESS);\n}", "path": "src\\p2netd\\main.c", "repo_name": "clintwebb/p2net", "stars": 1, "license": "None", "language": "c", "size": 116}
{"docstring": "/* These do the initial protocol switch.  At this point, we should've read\n * exactly one byte, and must treat that byte as the beginning of a command. */\n", "func_signal": "static void setup_bin_protocol(conn *c)", "code": "{\n    char *loc = (char*)c->bin_header;\n    if (settings.verbose > 1)\n        fprintf(stderr, \"Negotiated protocol as binary.\\n\");\n\n    c->protocol = binary_prot;\n    reinit_bin_connection(c);\n    /* Emulate a read of the first byte */\n    c->ritem[0] = c->rbuf[0];\n    c->ritem++;\n    c->rlbytes--;\n}", "path": "src\\p2netd\\main.c", "repo_name": "clintwebb/p2net", "stars": 1, "license": "None", "language": "c", "size": 116}
{"docstring": "/*\n * Returns a suffix buffer from the freelist, if any. Should call this using\n * suffix_from_freelist() for thread safety.\n */\n", "func_signal": "char *do_suffix_from_freelist()", "code": "{\n    char *s;\n\n    if (freesuffixcurr > 0) {\n        s = freesuffix[--freesuffixcurr];\n    } else {\n        /* If malloc fails, let the logic fall through without spamming\n         * STDERR on the server. */\n        s = malloc( SUFFIX_SIZE );\n    }\n\n    return s;\n}", "path": "src\\p2netd\\main.c", "repo_name": "clintwebb/p2net", "stars": 1, "license": "None", "language": "c", "size": 116}
{"docstring": "/*\n * Transmit the next chunk of data from our list of msgbuf structures.\n *\n * Returns:\n *   TRANSMIT_COMPLETE   All done writing.\n *   TRANSMIT_INCOMPLETE More data remaining to write.\n *   TRANSMIT_SOFT_ERROR Can't write any more right now.\n *   TRANSMIT_HARD_ERROR Can't write (c->state is set to conn_closing)\n */\n", "func_signal": "static int transmit(conn *c)", "code": "{\n    assert(c != NULL);\n\n    if (c->msgcurr < c->msgused &&\n            c->msglist[c->msgcurr].msg_iovlen == 0) {\n        /* Finished writing the current msg; advance to the next. */\n        c->msgcurr++;\n    }\n    if (c->msgcurr < c->msgused) {\n        ssize_t res;\n        struct msghdr *m = &c->msglist[c->msgcurr];\n\n        res = sendmsg(c->sfd, m, 0);\n        if (res > 0) {\n            STATS_LOCK();\n            stats.bytes_written += res;\n            STATS_UNLOCK();\n\n            /* We've written some of the data. Remove the completed\n               iovec entries from the list of pending writes. */\n            while (m->msg_iovlen > 0 && res >= m->msg_iov->iov_len) {\n                res -= m->msg_iov->iov_len;\n                m->msg_iovlen--;\n                m->msg_iov++;\n            }\n\n            /* Might have written just part of the last iovec entry;\n               adjust it so the next write will do the rest. */\n            if (res > 0) {\n                m->msg_iov->iov_base += res;\n                m->msg_iov->iov_len -= res;\n            }\n            return TRANSMIT_INCOMPLETE;\n        }\n        if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n            if (!update_event(c, EV_WRITE | EV_PERSIST)) {\n                if (settings.verbose > 0)\n                    fprintf(stderr, \"Couldn't update event\\n\");\n                conn_set_state(c, conn_closing);\n                return TRANSMIT_HARD_ERROR;\n            }\n            return TRANSMIT_SOFT_ERROR;\n        }\n        /* if res == 0 or res == -1 and error is not EAGAIN or EWOULDBLOCK,\n           we have a real error, on which we close the connection */\n        if (settings.verbose > 0)\n            perror(\"Failed to write, and not due to blocking\");\n\n        if (IS_UDP(c->protocol))\n            conn_set_state(c, conn_read);\n        else\n            conn_set_state(c, conn_closing);\n        return TRANSMIT_HARD_ERROR;\n    } else {\n        return TRANSMIT_COMPLETE;\n    }\n}", "path": "src\\p2netd\\main.c", "repo_name": "clintwebb/p2net", "stars": 1, "license": "None", "language": "c", "size": 116}
{"docstring": "/*\n * Sets a socket's send buffer size to the maximum allowed by the system.\n */\n", "func_signal": "static void maximize_sndbuf(const int sfd)", "code": "{\n    socklen_t intsize = sizeof(int);\n    int last_good = 0;\n    int min, max, avg;\n    int old_size;\n\n    /* Start with the default size. */\n    if (getsockopt(sfd, SOL_SOCKET, SO_SNDBUF, &old_size, &intsize) != 0) {\n        if (settings.verbose > 0)\n            perror(\"getsockopt(SO_SNDBUF)\");\n        return;\n    }\n\n    /* Binary-search for the real maximum. */\n    min = old_size;\n    max = MAX_SENDBUF_SIZE;\n\n    while (min <= max) {\n        avg = ((unsigned int)(min + max)) / 2;\n        if (setsockopt(sfd, SOL_SOCKET, SO_SNDBUF, (void *)&avg, intsize) == 0) {\n            last_good = avg;\n            min = avg + 1;\n        } else {\n            max = avg - 1;\n        }\n    }\n\n    if (settings.verbose > 1)\n        fprintf(stderr, \"<%d send buffer was %d, now %d\\n\", sfd, old_size, last_good);\n}", "path": "src\\p2netd\\main.c", "repo_name": "clintwebb/p2net", "stars": 1, "license": "None", "language": "c", "size": 116}
{"docstring": "/* lose root privileges if we have them */\n", "func_signal": "static void drop_privs(void)", "code": "{\n  char *username = NULL;\n\tstruct passwd *pw;\n  \n\tif (getuid() == 0 || geteuid() == 0) {\n\t\tif (username == 0 || *username == '\\0') {\n\t\t\tfprintf(stderr, \"can't run as root without the -u switch\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tif ((pw = getpwnam(username)) == 0) {\n\t\t\tfprintf(stderr, \"can't find the user %s to switch to\\n\", username);\n\t\t\treturn 1;\n\t\t}\n\t\tif (setgid(pw->pw_gid) < 0 || setuid(pw->pw_uid) < 0) {\n\t\t\tfprintf(stderr, \"failed to assume identity of user %s\\n\", username);\n\t\t\treturn 1;\n\t\t}\n\t}\n}", "path": "src\\p2netd\\main.c", "repo_name": "clintwebb/p2net", "stars": 1, "license": "None", "language": "c", "size": 116}
{"docstring": "/*\n * Sets whether we are listening for new connections or not.\n */\n", "func_signal": "void accept_new_conns(const bool do_accept)", "code": "{\n    conn *next;\n\n    if (! is_listen_thread())\n        return;\n\n    for (next = listen_conn; next; next = next->next) {\n        if (do_accept) {\n            update_event(next, EV_READ | EV_PERSIST);\n            if (listen(next->sfd, 1024) != 0) {\n                perror(\"listen\");\n            }\n        }\n        else {\n            update_event(next, 0);\n            if (listen(next->sfd, 0) != 0) {\n                perror(\"listen\");\n            }\n        }\n  }\n}", "path": "src\\p2netd\\main.c", "repo_name": "clintwebb/p2net", "stars": 1, "license": "None", "language": "c", "size": 116}
{"docstring": "/* Call run_deferred_deletes instead of this. */\n", "func_signal": "void do_run_deferred_deletes(void)", "code": "{\n    int i, j = 0;\n\n    for (i = 0; i < delcurr; i++) {\n        item *it = todelete[i];\n        if (item_delete_lock_over(it)) {\n            assert(it->refcount > 0);\n            it->it_flags &= ~ITEM_DELETED;\n            do_item_unlink(it);\n            do_item_remove(it);\n        } else {\n            todelete[j++] = it;\n        }\n    }\n    delcurr = j;\n}", "path": "src\\p2netd\\main.c", "repo_name": "clintwebb/p2net", "stars": 1, "license": "None", "language": "c", "size": 116}
{"docstring": "/* ntokens is overwritten here... shrug.. */\n", "func_signal": "static inline void process_get_command(conn *c, token_t *tokens, size_t ntokens, bool return_cas)", "code": "{\n    char *key;\n    size_t nkey;\n    int i = 0;\n    item *it;\n    token_t *key_token = &tokens[KEY_TOKEN];\n    char *suffix;\n    int stats_get_cmds   = 0;\n    int stats_get_hits   = 0;\n    int stats_get_misses = 0;\n    assert(c != NULL);\n\n    if (settings.managed) {\n        int bucket = c->bucket;\n        if (bucket == -1) {\n            out_string(c, \"CLIENT_ERROR no BG data in managed mode\");\n            return;\n        }\n        c->bucket = -1;\n        if (buckets[bucket] != c->gen) {\n            out_string(c, \"ERROR_NOT_OWNER\");\n            return;\n        }\n    }\n\n    do {\n        while(key_token->length != 0) {\n\n            key = key_token->value;\n            nkey = key_token->length;\n\n            if(nkey > KEY_MAX_LENGTH) {\n                STATS_LOCK();\n                stats.get_cmds   += stats_get_cmds;\n                stats.get_hits   += stats_get_hits;\n                stats.get_misses += stats_get_misses;\n                STATS_UNLOCK();\n                out_string(c, \"CLIENT_ERROR bad command line format\");\n                return;\n            }\n\n            stats_get_cmds++;\n            it = item_get(key, nkey);\n            if (settings.detail_enabled) {\n                stats_prefix_record_get(key, NULL != it);\n            }\n            if (it) {\n                if (i >= c->isize) {\n                    item **new_list = realloc(c->ilist, sizeof(item *) * c->isize * 2);\n                    if (new_list) {\n                        c->isize *= 2;\n                        c->ilist = new_list;\n                    } else break;\n                }\n\n                /*\n                 * Construct the response. Each hit adds three elements to the\n                 * outgoing data list:\n                 *   \"VALUE \"\n                 *   key\n                 *   \" \" + flags + \" \" + data length + \"\\r\\n\" + data (with \\r\\n)\n                 */\n\n                if(return_cas == true)\n                {\n                  /* Goofy mid-flight realloc. */\n                  if (i >= c->suffixsize) {\n                    char **new_suffix_list = realloc(c->suffixlist,\n                                           sizeof(char *) * c->suffixsize * 2);\n                    if (new_suffix_list) {\n                      c->suffixsize *= 2;\n                      c->suffixlist  = new_suffix_list;\n                    } else break;\n                  }\n\n                  suffix = suffix_from_freelist();\n                  if (suffix == NULL) {\n                    STATS_LOCK();\n                    stats.get_cmds   += stats_get_cmds;\n                    stats.get_hits   += stats_get_hits;\n                    stats.get_misses += stats_get_misses;\n                    STATS_UNLOCK();\n                    out_string(c, \"SERVER_ERROR out of memory making CAS suffix\");\n                    return;\n                  }\n                  *(c->suffixlist + i) = suffix;\n                  sprintf(suffix, \" %llu\\r\\n\", it->cas_id);\n                  if (add_iov(c, \"VALUE \", 6) != 0 ||\n                      add_iov(c, ITEM_key(it), it->nkey) != 0 ||\n                      add_iov(c, ITEM_suffix(it), it->nsuffix - 2) != 0 ||\n                      add_iov(c, suffix, strlen(suffix)) != 0 ||\n                      add_iov(c, ITEM_data(it), it->nbytes) != 0)\n                      {\n                          break;\n                      }\n                }\n                else\n                {\n                  if (add_iov(c, \"VALUE \", 6) != 0 ||\n                      add_iov(c, ITEM_key(it), it->nkey) != 0 ||\n                      add_iov(c, ITEM_suffix(it), it->nsuffix + it->nbytes) != 0)\n                      {\n                          break;\n                      }\n                }\n\n\n                if (settings.verbose > 1)\n                    fprintf(stderr, \">%d sending key %s\\n\", c->sfd, ITEM_key(it));\n\n                /* item_get() has incremented it->refcount for us */\n                stats_get_hits++;\n                item_update(it);\n                *(c->ilist + i) = it;\n                i++;\n\n            } else {\n                stats_get_misses++;\n            }\n\n            key_token++;\n        }\n\n        /*\n         * If the command string hasn't been fully processed, get the next set\n         * of tokens.\n         */\n        if(key_token->value != NULL) {\n            ntokens = tokenize_command(key_token->value, tokens, MAX_TOKENS);\n            key_token = tokens;\n        }\n\n    } while(key_token->value != NULL);\n\n    c->icurr = c->ilist;\n    c->ileft = i;\n    if (return_cas) {\n        c->suffixcurr = c->suffixlist;\n        c->suffixleft = i;\n    }\n\n    if (settings.verbose > 1)\n        fprintf(stderr, \">%d END\\n\", c->sfd);\n\n    /*\n        If the loop was terminated because of out-of-memory, it is not\n        reliable to add END\\r\\n to the buffer, because it might not end\n        in \\r\\n. So we send SERVER_ERROR instead.\n    */\n    if (key_token->value != NULL || add_iov(c, \"END\\r\\n\", 5) != 0\n        || (IS_UDP(c->protocol) && build_udp_headers(c) != 0)) {\n        out_string(c, \"SERVER_ERROR out of memory writing get response\");\n    }\n    else {\n        conn_set_state(c, conn_mwrite);\n        c->msgcurr = 0;\n    }\n\n    STATS_LOCK();\n    stats.get_cmds   += stats_get_cmds;\n    stats.get_hits   += stats_get_hits;\n    stats.get_misses += stats_get_misses;\n    STATS_UNLOCK();\n\n    return;\n}", "path": "src\\p2netd\\main.c", "repo_name": "clintwebb/p2net", "stars": 1, "license": "None", "language": "c", "size": 116}
{"docstring": "/*\n * Adds a connection to the freelist. 0 = success. Should call this using\n * conn_add_to_freelist() for thread safety.\n */\n", "func_signal": "bool do_suffix_add_to_freelist(char *s)", "code": "{\n    if (freesuffixcurr < freesuffixtotal) {\n        freesuffix[freesuffixcurr++] = s;\n        return false;\n    } else {\n        /* try to enlarge free connections array */\n        char **new_freesuffix = realloc(freesuffix, freesuffixtotal * 2);\n        if (new_freesuffix) {\n            freesuffixtotal *= 2;\n            freesuffix = new_freesuffix;\n            freesuffix[freesuffixcurr++] = s;\n            return false;\n        }\n    }\n    return true;\n}", "path": "src\\p2netd\\main.c", "repo_name": "clintwebb/p2net", "stars": 1, "license": "None", "language": "c", "size": 116}
{"docstring": "//-----------------------------------------------------------------------------\n// Main... process command line parameters, and then setup our listening \n// sockets and event loop.\n", "func_signal": "int main (int argc, char **argv)", "code": "{\n///    int c;\n///    char *pid_file = NULL;\n///    struct sigaction sa;\n    \n/* listening sockets */\n///    static int *l_socket = NULL;\n///    static int *bl_socket = NULL;\n\n\n\t/* handle SIGINT */\n\tsignal(SIGINT, sig_handler);\n\t\n\t/* init settings */\n\tsettings_init(settings);\n\n\t/* set stderr non-buffering (for running under, say, daemontools) */\n\tsetbuf(stderr, NULL);\n\n\t/* process arguments */\n\t/// Need to check the options in here, there re possibly ones that we dont need.\n\twhile ((c = getopt(argc, argv, \"p:B:m:Mc:hirvdl:u:P:f:s:n:D:\")) != -1) {\n\t\tswitch (c) {\n\t\t\tcase 'p':\n\t\t\t\tsettings.port = atoi(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'm':\n        settings.maxbytes = ((size_t)atoi(optarg)) * 1024 * 1024;\n        break;\n    \tcase 'c':\n        settings.maxconns = atoi(optarg);\n        break;\n\t\t\tcase 'h':\n\t\t\t\tusage();\n\t\t\t\texit(EXIT_SUCCESS);\n\t\t\tcase 'i':\n\t\t\t\tusage_license();\n\t\t\t\texit(EXIT_SUCCESS);\n\t\t\tcase 'v':\n\t\t\t\tsettings.verbose++;\n\t\t\t\tbreak;\n\t\t\tcase 'l':\n\t\t\t\tsettings.inter= strdup(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tdaemonize = true;\n\t\t\t\tbreak;\n\t\t\tcase 'r':\n\t\t\t\tmaxcore = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\tusername = optarg;\n\t\t\t\tbreak;\n\t\t\tcase 'P':\n\t\t\t\tpid_file = optarg;\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tsettings.factor = atof(optarg);\n\t\t\t\tif (settings.factor <= 1.0) {\n\t\t\t\t\tfprintf(stderr, \"Factor must be greater than 1\\n\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tsettings.chunk_size = atoi(optarg);\n\t\t\t\tif (settings.chunk_size == 0) {\n\t\t\t\t\tfprintf(stderr, \"Chunk size must be greater than 0\\n\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\tif (! optarg || ! optarg[0]) {\n\t\t\t\t\tfprintf(stderr, \"No delimiter specified\\n\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tsettings.prefix_delimiter = optarg[0];\n\t\t\t\tsettings.detail_enabled = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfprintf(stderr, \"Illegal argument \\\"%c\\\"\\n\", c);\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\n\t// If needed, increase rlimits to allow as many connections as needed.\n\tset_maxconns(settings->maxconns);\n\n\tdrop_privs();\n\n\t/* daemonize if requested */\n\t/* if we want to ensure our ability to dump core, don't chdir to / */\n\tif (daemonize) {\n\t\tint res;\n\t\tres = daemon(0, settings->verbose);\n\t\tif (res == -1) {\n\t\t\tfprintf(stderr, \"failed to daemon() in order to daemonize\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* initialize main thread libevent instance */\n\tmain_base = event_init();\n\n\t/* initialize other stuff */\n\tconn_init();\n    \n    /* Hacky suffix buffers. */\n    suffix_init();\n    slabs_init(settings.maxbytes, settings.factor, preallocate);\n\n    /* managed instance? alloc and zero a bucket array */\n    if (settings.managed) {\n        buckets = malloc(sizeof(int) * MAX_BUCKETS);\n        if (buckets == 0) {\n            fprintf(stderr, \"failed to allocate the bucket array\");\n            exit(EXIT_FAILURE);\n        }\n        memset(buckets, 0, sizeof(int) * MAX_BUCKETS);\n    }\n\n    /*\n     * ignore SIGPIPE signals; we can use errno == EPIPE if we\n     * need that information\n     */\n    sa.sa_handler = SIG_IGN;\n    sa.sa_flags = 0;\n    if (sigemptyset(&sa.sa_mask) == -1 ||\n        sigaction(SIGPIPE, &sa, 0) == -1) {\n        perror(\"failed to ignore SIGPIPE; sigaction\");\n        exit(EXIT_FAILURE);\n    }\n    \n    /* save the PID in if we're a daemon, do this after thread_init due to\n       a file descriptor handling bug somewhere in libevent */\n    if (settings->daemonize)\n        save_pid(getpid(), pid_file);\n        \n    /* initialise clock event */\n    clock_handler(0, 0, 0);\n    /* initialise deletion array and timer event */\n    deltotal = 200;\n    delcurr = 0;\n    if ((todelete = malloc(sizeof(item *) * deltotal)) == NULL) {\n        perror(\"failed to allocate memory for deletion array\");\n        exit(EXIT_FAILURE);\n    }\n    delete_handler(0, 0, 0); /* sets up the event */\n\n    /* create unix mode sockets after dropping privileges */\n    if (settings.socketpath != NULL) {\n        if (server_socket_unix(settings.socketpath,settings.access)) {\n          fprintf(stderr, \"failed to listen\\n\");\n          exit(EXIT_FAILURE);\n        }\n    }\n\n    /* create the listening socket, bind it, and init */\n    if (settings.socketpath == NULL) {\n        int udp_port;\n\n        if (server_socket(settings.port, negotiating_prot)) {\n            fprintf(stderr, \"failed to listen\\n\");\n            exit(EXIT_FAILURE);\n        }\n\n        /*\n         * initialization order: first create the listening sockets\n         * (may need root on low ports), then drop root if needed,\n         * then daemonise if needed, then init libevent (in some cases\n         * descriptors created by libevent wouldn't survive forking).\n         */\n        udp_port = settings.udpport ? settings.udpport : settings.port;\n\n        /* create the UDP listening socket and bind it */\n        if (server_socket(udp_port, ascii_udp_prot)) {\n            fprintf(stderr, \"failed to listen on UDP port %d\\n\", settings.udpport);\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    /* enter the event loop */\n    event_base_loop(main_base, 0);\n    /* remove the PID file if we're a daemon */\n    if (daemonize)\n        remove_pidfile(pid_file);\n    /* Clean up strdup() call for bind() address */\n    if (settings.inter)\n      free(settings.inter);\n    if (l_socket)\n      free(l_socket);\n    if (u_socket)\n      free(u_socket);\n\n    return 0;\n}", "path": "src\\p2netd\\main.c", "repo_name": "clintwebb/p2net", "stars": 1, "license": "None", "language": "c", "size": 116}
{"docstring": "/*\n * Shrinks a connection's buffers if they're too big.  This prevents\n * periodic large \"get\" requests from permanently chewing lots of server\n * memory.\n *\n * This should only be called in between requests since it can wipe output\n * buffers!\n */\n", "func_signal": "static void conn_shrink(conn *c)", "code": "{\n    assert(c != NULL);\n\n    if (c->rsize > READ_BUFFER_HIGHWAT && c->rbytes < DATA_BUFFER_SIZE) {\n        char *newbuf;\n\n        if (c->rcurr != c->rbuf)\n            memmove(c->rbuf, c->rcurr, (size_t)c->rbytes);\n\n        newbuf = (char *)realloc((void *)c->rbuf, DATA_BUFFER_SIZE);\n\n        if (newbuf) {\n            c->rbuf = newbuf;\n            c->rsize = DATA_BUFFER_SIZE;\n        }\n        /* TODO check other branch... */\n        c->rcurr = c->rbuf;\n    }\n\n    if (c->isize > ITEM_LIST_HIGHWAT) {\n        item **newbuf = (item**) realloc((void *)c->ilist, ITEM_LIST_INITIAL * sizeof(c->ilist[0]));\n        if (newbuf) {\n            c->ilist = newbuf;\n            c->isize = ITEM_LIST_INITIAL;\n        }\n    /* TODO check error condition? */\n    }\n\n    if (c->msgsize > MSG_LIST_HIGHWAT) {\n        struct msghdr *newbuf = (struct msghdr *) realloc((void *)c->msglist, MSG_LIST_INITIAL * sizeof(c->msglist[0]));\n        if (newbuf) {\n            c->msglist = newbuf;\n            c->msgsize = MSG_LIST_INITIAL;\n        }\n    /* TODO check error condition? */\n    }\n\n    if (c->iovsize > IOV_LIST_HIGHWAT) {\n        struct iovec *newbuf = (struct iovec *) realloc((void *)c->iov, IOV_LIST_INITIAL * sizeof(c->iov[0]));\n        if (newbuf) {\n            c->iov = newbuf;\n            c->iovsize = IOV_LIST_INITIAL;\n        }\n    /* TODO check return value */\n    }\n}", "path": "src\\p2netd\\main.c", "repo_name": "clintwebb/p2net", "stars": 1, "license": "None", "language": "c", "size": 116}
{"docstring": "/* Start play */\n", "func_signal": "static int\nSDL_SYS_CDPlay(SDL_CD * cdrom, int start, int length)", "code": "{\n    struct cdrom_msf playtime;\n\n    FRAMES_TO_MSF(start,\n                  &playtime.cdmsf_min0, &playtime.cdmsf_sec0,\n                  &playtime.cdmsf_frame0);\n    FRAMES_TO_MSF(start + length, &playtime.cdmsf_min1, &playtime.cdmsf_sec1,\n                  &playtime.cdmsf_frame1);\n#ifdef DEBUG_CDROM\n    fprintf(stderr, \"Trying to play from %d:%d:%d to %d:%d:%d\\n\",\n            playtime.cdmsf_min0, playtime.cdmsf_sec0, playtime.cdmsf_frame0,\n            playtime.cdmsf_min1, playtime.cdmsf_sec1, playtime.cdmsf_frame1);\n#endif\n\n    return SDL_SYS_CDioctl(cdrom->id, CDROMPLAYMSF, &playtime);\n}", "path": "SDL\\src\\cdrom\\mint\\SDL_syscdrom.c", "repo_name": "lhzhang/SDL", "stars": 1, "license": "None", "language": "c", "size": 50836}
{"docstring": "/*\n * Unlock a previously locked surface\n */\n", "func_signal": "void\nSDL_UnlockSurface(SDL_Surface * surface)", "code": "{\n    /* Only perform an unlock if we are locked */\n    if (!surface->locked || (--surface->locked > 0)) {\n        return;\n    }\n\n    /* Update RLE encoded surface with new data */\n    if ((surface->flags & SDL_RLEACCEL) == SDL_RLEACCEL) {\n        surface->flags &= ~SDL_RLEACCEL;        /* stop lying */\n        SDL_RLESurface(surface);\n    }\n}", "path": "SDL\\src\\video\\SDL_surface.c", "repo_name": "lhzhang/SDL", "stars": 1, "license": "None", "language": "c", "size": 50836}
{"docstring": "/* Create a mutex */\n", "func_signal": "SDL_mutex *\nSDL_CreateMutex(void)", "code": "{\n    SDL_mutex *mutex;\n\n    /* Allocate mutex memory */\n    mutex = (SDL_mutex *) SDL_malloc(sizeof(*mutex));\n    if (mutex) {\n        /* Create the mutex, with initial value signaled */\n        if (!pth_mutex_init(&(mutex->mutexpth_p))) {\n            SDL_SetError(\"Couldn't create mutex\");\n            SDL_free(mutex);\n            mutex = NULL;\n        }\n    } else {\n        SDL_OutOfMemory();\n    }\n    return (mutex);\n}", "path": "SDL\\src\\thread\\pth\\SDL_sysmutex.c", "repo_name": "lhzhang/SDL", "stars": 1, "license": "None", "language": "c", "size": 50836}
{"docstring": "/* This is a fairly slow function to switch from colorkey to alpha */\n", "func_signal": "static void\nSDL_ConvertColorkeyToAlpha(SDL_Surface * surface)", "code": "{\n    int x, y;\n\n    if (!surface) {\n        return;\n    }\n\n    if (!(surface->map->info.flags & SDL_COPY_COLORKEY) ||\n        !surface->format->Amask) {\n        return;\n    }\n\n    SDL_LockSurface(surface);\n\n    switch (surface->format->BytesPerPixel) {\n    case 2:\n        {\n            Uint16 *row, *spot;\n            Uint16 ckey = (Uint16) surface->map->info.colorkey;\n            Uint16 mask = (Uint16) (~surface->format->Amask);\n\n            row = (Uint16 *) surface->pixels;\n            for (y = surface->h; y--;) {\n                spot = row;\n                for (x = surface->w; x--;) {\n                    if (*spot == ckey) {\n                        *spot &= mask;\n                    }\n                    ++spot;\n                }\n                row += surface->pitch / 2;\n            }\n        }\n        break;\n    case 3:\n        /* FIXME */\n        break;\n    case 4:\n        {\n            Uint32 *row, *spot;\n            Uint32 ckey = surface->map->info.colorkey;\n            Uint32 mask = ~surface->format->Amask;\n\n            row = (Uint32 *) surface->pixels;\n            for (y = surface->h; y--;) {\n                spot = row;\n                for (x = surface->w; x--;) {\n                    if (*spot == ckey) {\n                        *spot &= mask;\n                    }\n                    ++spot;\n                }\n                row += surface->pitch / 4;\n            }\n        }\n        break;\n    }\n\n    SDL_UnlockSurface(surface);\n\n    SDL_SetColorKey(surface, 0, 0);\n    SDL_SetSurfaceBlendMode(surface, SDL_BLENDMODE_BLEND);\n}", "path": "SDL\\src\\video\\SDL_surface.c", "repo_name": "lhzhang/SDL", "stars": 1, "license": "None", "language": "c", "size": 50836}
{"docstring": "/* Get CD-ROM status */\n", "func_signal": "static CDstatus\nSDL_SYS_CDStatus(SDL_CD * cdrom, int *position)", "code": "{\n    CDstatus status;\n    struct cdrom_tochdr toc;\n    struct cdrom_subchnl info;\n\n    info.cdsc_format = CDROM_MSF;\n    if (SDL_SYS_CDioctl(cdrom->id, CDROMSUBCHNL, &info) < 0) {\n        if (ERRNO_TRAYEMPTY(errno)) {\n            status = CD_TRAYEMPTY;\n        } else {\n            status = CD_ERROR;\n        }\n    } else {\n        switch (info.cdsc_audiostatus) {\n        case CDROM_AUDIO_INVALID:\n        case CDROM_AUDIO_NO_STATUS:\n            /* Try to determine if there's a CD available */\n            if (SDL_SYS_CDioctl(cdrom->id, CDROMREADTOCHDR, &toc) == 0) {\n                status = CD_STOPPED;\n            } else {\n                status = CD_TRAYEMPTY;\n            }\n            break;\n        case CDROM_AUDIO_COMPLETED:\n            status = CD_STOPPED;\n            break;\n        case CDROM_AUDIO_PLAY:\n            status = CD_PLAYING;\n            break;\n        case CDROM_AUDIO_PAUSED:\n            /* Workaround buggy CD-ROM drive */\n            if (info.cdsc_trk == CDROM_LEADOUT) {\n                status = CD_STOPPED;\n            } else {\n                status = CD_PAUSED;\n            }\n            break;\n        default:\n            status = CD_ERROR;\n            break;\n        }\n    }\n    if (position) {\n        if (status == CD_PLAYING || (status == CD_PAUSED)) {\n            *position = MSF_TO_FRAMES(info.cdsc_absaddr.msf.minute,\n                                      info.cdsc_absaddr.msf.second,\n                                      info.cdsc_absaddr.msf.frame);\n        } else {\n            *position = 0;\n        }\n    }\n    return (status);\n}", "path": "SDL\\src\\cdrom\\mint\\SDL_syscdrom.c", "repo_name": "lhzhang/SDL", "stars": 1, "license": "None", "language": "c", "size": 50836}
{"docstring": "/* Public routines */\n/*\n * Create an empty RGB surface of the appropriate depth\n */\n", "func_signal": "SDL_Surface *\nSDL_CreateRGBSurface(Uint32 flags,\n                     int width, int height, int depth,\n                     Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask)", "code": "{\n    SDL_Surface *surface;\n\n    /* The flags are no longer used, make the compiler happy */\n    flags;\n\n    /* Allocate the surface */\n    surface = (SDL_Surface *) SDL_calloc(1, sizeof(*surface));\n    if (surface == NULL) {\n        SDL_OutOfMemory();\n        return NULL;\n    }\n\n    surface->format = SDL_AllocFormat(depth, Rmask, Gmask, Bmask, Amask);\n    if (!surface->format) {\n        SDL_FreeSurface(surface);\n        return NULL;\n    }\n    surface->w = width;\n    surface->h = height;\n    surface->pitch = SDL_CalculatePitch(surface);\n    SDL_SetClipRect(surface, NULL);\n\n    if (surface->format->BitsPerPixel <= 8) {\n        SDL_Palette *palette =\n            SDL_AllocPalette((1 << surface->format->BitsPerPixel));\n        if (!palette) {\n            SDL_FreeSurface(surface);\n            return NULL;\n        }\n        if (Rmask || Bmask || Gmask) {\n            const SDL_PixelFormat *format = surface->format;\n\n            /* create palette according to masks */\n            int i;\n            int Rm = 0, Gm = 0, Bm = 0;\n            int Rw = 0, Gw = 0, Bw = 0;\n\n            if (Rmask) {\n                Rw = 8 - format->Rloss;\n                for (i = format->Rloss; i > 0; i -= Rw)\n                    Rm |= 1 << i;\n            }\n            if (Gmask) {\n                Gw = 8 - format->Gloss;\n                for (i = format->Gloss; i > 0; i -= Gw)\n                    Gm |= 1 << i;\n            }\n            if (Bmask) {\n                Bw = 8 - format->Bloss;\n                for (i = format->Bloss; i > 0; i -= Bw)\n                    Bm |= 1 << i;\n            }\n            for (i = 0; i < palette->ncolors; ++i) {\n                int r, g, b;\n                r = (i & Rmask) >> format->Rshift;\n                r = (r << format->Rloss) | ((r * Rm) >> Rw);\n                palette->colors[i].r = r;\n\n                g = (i & Gmask) >> format->Gshift;\n                g = (g << format->Gloss) | ((g * Gm) >> Gw);\n                palette->colors[i].g = g;\n\n                b = (i & Bmask) >> format->Bshift;\n                b = (b << format->Bloss) | ((b * Bm) >> Bw);\n                palette->colors[i].b = b;\n            }\n        } else if (palette->ncolors == 2) {\n            /* Create a black and white bitmap palette */\n            palette->colors[0].r = 0xFF;\n            palette->colors[0].g = 0xFF;\n            palette->colors[0].b = 0xFF;\n            palette->colors[1].r = 0x00;\n            palette->colors[1].g = 0x00;\n            palette->colors[1].b = 0x00;\n        }\n        SDL_SetSurfacePalette(surface, palette);\n        SDL_FreePalette(palette);\n    }\n\n    /* Get the pixels */\n    if (surface->w && surface->h) {\n        surface->pixels = SDL_malloc(surface->h * surface->pitch);\n        if (!surface->pixels) {\n            SDL_FreeSurface(surface);\n            SDL_OutOfMemory();\n            return NULL;\n        }\n        /* This is important for bitmaps */\n        SDL_memset(surface->pixels, 0, surface->h * surface->pitch);\n    }\n\n    /* Allocate an empty mapping */\n    surface->map = SDL_AllocBlitMap();\n    if (!surface->map) {\n        SDL_FreeSurface(surface);\n        return NULL;\n    }\n    SDL_FormatChanged(surface);\n\n    /* By default surface with an alpha mask are set up for blending */\n    if (Amask) {\n        SDL_SetSurfaceBlendMode(surface, SDL_BLENDMODE_BLEND);\n    }\n\n    /* The surface is ready to go */\n    surface->refcount = 1;\n#ifdef CHECK_LEAKS\n    ++surfaces_allocated;\n#endif\n    return surface;\n}", "path": "SDL\\src\\video\\SDL_surface.c", "repo_name": "lhzhang/SDL", "stars": 1, "license": "None", "language": "c", "size": 50836}
{"docstring": "/* \n * Convert a surface into the specified pixel format.\n */\n", "func_signal": "SDL_Surface *\nSDL_ConvertSurface(SDL_Surface * surface, SDL_PixelFormat * format,\n                   Uint32 flags)", "code": "{\n    SDL_Surface *convert;\n    Uint32 copy_flags;\n    SDL_Rect bounds;\n\n    /* Check for empty destination palette! (results in empty image) */\n    if (format->palette != NULL) {\n        int i;\n        for (i = 0; i < format->palette->ncolors; ++i) {\n            if ((format->palette->colors[i].r != 0xFF) ||\n                (format->palette->colors[i].g != 0xFF) ||\n                (format->palette->colors[i].b != 0xFF))\n                break;\n        }\n        if (i == format->palette->ncolors) {\n            SDL_SetError(\"Empty destination palette\");\n            return (NULL);\n        }\n    }\n\n    /* Create a new surface with the desired format */\n    convert = SDL_CreateRGBSurface(flags, surface->w, surface->h,\n                                   format->BitsPerPixel, format->Rmask,\n                                   format->Gmask, format->Bmask,\n                                   format->Amask);\n    if (convert == NULL) {\n        return (NULL);\n    }\n\n    /* Copy the palette if any */\n    if (format->palette && convert->format->palette) {\n        SDL_memcpy(convert->format->palette->colors,\n                   format->palette->colors,\n                   format->palette->ncolors * sizeof(SDL_Color));\n        convert->format->palette->ncolors = format->palette->ncolors;\n    }\n\n    /* Save the original copy flags */\n    copy_flags = surface->map->info.flags;\n    surface->map->info.flags = 0;\n\n    /* Copy over the image data */\n    bounds.x = 0;\n    bounds.y = 0;\n    bounds.w = surface->w;\n    bounds.h = surface->h;\n    SDL_LowerBlit(surface, &bounds, convert, &bounds);\n\n    /* Clean up the original surface, and update converted surface */\n    convert->map->info.r = surface->map->info.r;\n    convert->map->info.g = surface->map->info.g;\n    convert->map->info.b = surface->map->info.b;\n    convert->map->info.a = surface->map->info.a;\n    convert->map->info.flags =\n        (copy_flags &\n         ~(SDL_COPY_COLORKEY | SDL_COPY_BLEND\n           | SDL_COPY_RLE_DESIRED | SDL_COPY_RLE_COLORKEY |\n           SDL_COPY_RLE_ALPHAKEY));\n    surface->map->info.flags = copy_flags;\n    if (copy_flags & SDL_COPY_COLORKEY) {\n        Uint8 keyR, keyG, keyB, keyA;\n\n        SDL_GetRGBA(surface->map->info.colorkey, surface->format, &keyR,\n                    &keyG, &keyB, &keyA);\n        SDL_SetColorKey(convert, 1,\n                        SDL_MapRGBA(convert->format, keyR, keyG, keyB, keyA));\n        /* This is needed when converting for 3D texture upload */\n        SDL_ConvertColorkeyToAlpha(convert);\n    }\n    SDL_SetClipRect(convert, &surface->clip_rect);\n\n    /* Enable alpha blending by default if the new surface has an\n     * alpha channel or alpha modulation */\n    if ((surface->format->Amask && format->Amask) ||\n        (copy_flags & SDL_COPY_MODULATE_ALPHA)) {\n        SDL_SetSurfaceBlendMode(convert, SDL_BLENDMODE_BLEND);\n    }\n    if ((copy_flags & SDL_COPY_RLE_DESIRED) || (flags & SDL_RLEACCEL)) {\n        SDL_SetSurfaceRLE(convert, SDL_RLEACCEL);\n    }\n\n    /* We're ready to go! */\n    return (convert);\n}", "path": "SDL\\src\\video\\SDL_surface.c", "repo_name": "lhzhang/SDL", "stars": 1, "license": "None", "language": "c", "size": 50836}
{"docstring": "/*\n * Free a surface created by the above function.\n */\n", "func_signal": "void\nSDL_FreeSurface(SDL_Surface * surface)", "code": "{\n    if (surface == NULL) {\n        return;\n    }\n    if (--surface->refcount > 0) {\n        return;\n    }\n    while (surface->locked > 0) {\n        SDL_UnlockSurface(surface);\n    }\n    if (surface->flags & SDL_RLEACCEL) {\n        SDL_UnRLESurface(surface, 0);\n    }\n    if (surface->format) {\n        SDL_SetSurfacePalette(surface, NULL);\n        SDL_FreeFormat(surface->format);\n        surface->format = NULL;\n    }\n    if (surface->map != NULL) {\n        SDL_FreeBlitMap(surface->map);\n        surface->map = NULL;\n    }\n    if (surface->pixels && ((surface->flags & SDL_PREALLOC) != SDL_PREALLOC)) {\n        SDL_free(surface->pixels);\n    }\n    SDL_free(surface);\n#ifdef CHECK_LEAKS\n    --surfaces_allocated;\n#endif\n}", "path": "SDL\\src\\video\\SDL_surface.c", "repo_name": "lhzhang/SDL", "stars": 1, "license": "None", "language": "c", "size": 50836}
{"docstring": "/* \n * Set up a blit between two surfaces -- split into three parts:\n * The upper part, SDL_UpperBlit(), performs clipping and rectangle \n * verification.  The lower part is a pointer to a low level\n * accelerated blitting function.\n *\n * These parts are separated out and each used internally by this \n * library in the optimimum places.  They are exported so that if\n * you know exactly what you are doing, you can optimize your code\n * by calling the one(s) you need.\n */\n", "func_signal": "int\nSDL_LowerBlit(SDL_Surface * src, SDL_Rect * srcrect,\n              SDL_Surface * dst, SDL_Rect * dstrect)", "code": "{\n    /* Check to make sure the blit mapping is valid */\n    if ((src->map->dst != dst) ||\n        (src->map->dst->format_version != src->map->format_version)) {\n        if (SDL_MapSurface(src, dst) < 0) {\n            return (-1);\n        }\n        /* just here for debugging */\n/*         printf */\n/*             (\"src = 0x%08X src->flags = %08X src->map->info.flags = %08x\\ndst = 0x%08X dst->flags = %08X dst->map->info.flags = %08X\\nsrc->map->blit = 0x%08x\\n\", */\n/*              src, dst->flags, src->map->info.flags, dst, dst->flags, */\n/*              dst->map->info.flags, src->map->blit); */\n    }\n    return (src->map->blit(src, srcrect, dst, dstrect));\n}", "path": "SDL\\src\\video\\SDL_surface.c", "repo_name": "lhzhang/SDL", "stars": 1, "license": "None", "language": "c", "size": 50836}
{"docstring": "/* Free the semaphore */\n", "func_signal": "DECLSPEC void SDLCALL\nSDL_DestroySemaphore(SDL_sem * sem)", "code": "{\n    if (sem) {\n        if (sem->id) {\n            DosCloseEventSem(sem->changed);\n            DosCloseMutexSem(sem->id);\n            sem->id = 0;\n        }\n        SDL_free(sem);\n    }\n}", "path": "SDL\\src\\thread\\os2\\SDL_syssem.c", "repo_name": "lhzhang/SDL", "stars": 1, "license": "None", "language": "c", "size": 50836}
{"docstring": "/* Lock the mutex */\n", "func_signal": "int\nSDL_mutexP(SDL_mutex * mutex)", "code": "{\n    if (mutex == NULL) {\n        SDL_SetError(\"Passed a NULL mutex\");\n        return -1;\n    }\n\n    pth_mutex_acquire(&(mutex->mutexpth_p), FALSE, NULL);\n\n    return (0);\n}", "path": "SDL\\src\\thread\\pth\\SDL_sysmutex.c", "repo_name": "lhzhang/SDL", "stars": 1, "license": "None", "language": "c", "size": 50836}
{"docstring": "/* Unlock the mutex */\n", "func_signal": "int\nSDL_mutexV(SDL_mutex * mutex)", "code": "{\n    if (mutex == NULL) {\n        SDL_SetError(\"Passed a NULL mutex\");\n        return -1;\n    }\n\n    pth_mutex_release(&(mutex->mutexpth_p));\n\n    return (0);\n}", "path": "SDL\\src\\thread\\pth\\SDL_sysmutex.c", "repo_name": "lhzhang/SDL", "stars": 1, "license": "None", "language": "c", "size": 50836}
{"docstring": "/* Turn a normal gamma value into an appropriate gamma ramp */\n", "func_signal": "void\nCalculateGamma(double gamma, Uint16 * ramp)", "code": "{\n    int i, value;\n\n    gamma = 1.0 / gamma;\n    for (i = 0; i < 256; ++i) {\n        value = (int) (pow((double) i / 256.0, gamma) * 65535.0 + 0.5);\n        if (value > 65535) {\n            value = 65535;\n        }\n        ramp[i] = (Uint16) value;\n    }\n}", "path": "SDL\\test\\testgamma.c", "repo_name": "lhzhang/SDL", "stars": 1, "license": "None", "language": "c", "size": 50836}
{"docstring": "/* Create a semaphore */\n", "func_signal": "DECLSPEC SDL_sem *SDLCALL\nSDL_CreateSemaphore(Uint32 initial_value)", "code": "{\n    SDL_sem *sem;\n    ULONG ulrc;\n\n    /* Allocate sem memory */\n    sem = (SDL_sem *) SDL_malloc(sizeof(*sem));\n    if (sem) {\n        /* Create the mutex semaphore */\n        ulrc = DosCreateMutexSem(NULL, &(sem->id), 0, TRUE);\n        if (ulrc) {\n            SDL_SetError(\"Couldn't create semaphore\");\n            SDL_free(sem);\n            sem = NULL;\n        } else {\n            DosCreateEventSem(NULL, &(sem->changed), 0, FALSE);\n            sem->value = initial_value;\n            DosReleaseMutexSem(sem->id);\n        }\n    } else {\n        SDL_OutOfMemory();\n    }\n    return (sem);\n}", "path": "SDL\\src\\thread\\os2\\SDL_syssem.c", "repo_name": "lhzhang/SDL", "stars": 1, "license": "None", "language": "c", "size": 50836}
{"docstring": "/* Call this instead of exit(), so we can clean up SDL: atexit() is evil. */\n", "func_signal": "static void\nquit(int rc)", "code": "{\n    SDL_Quit();\n    exit(rc);\n}", "path": "SDL\\test\\testgamma.c", "repo_name": "lhzhang/SDL", "stars": 1, "license": "None", "language": "c", "size": 50836}
{"docstring": "/* Free the mutex */\n", "func_signal": "void\nSDL_DestroyMutex(SDL_mutex * mutex)", "code": "{\n    if (mutex) {\n        SDL_free(mutex);\n    }\n}", "path": "SDL\\src\\thread\\pth\\SDL_sysmutex.c", "repo_name": "lhzhang/SDL", "stars": 1, "license": "None", "language": "c", "size": 50836}
{"docstring": "/*\n * Create an RGB surface from an existing memory buffer\n */\n", "func_signal": "SDL_Surface *\nSDL_CreateRGBSurfaceFrom(void *pixels,\n                         int width, int height, int depth, int pitch,\n                         Uint32 Rmask, Uint32 Gmask, Uint32 Bmask,\n                         Uint32 Amask)", "code": "{\n    SDL_Surface *surface;\n\n    surface =\n        SDL_CreateRGBSurface(0, 0, 0, depth, Rmask, Gmask, Bmask, Amask);\n    if (surface != NULL) {\n        surface->flags |= SDL_PREALLOC;\n        surface->pixels = pixels;\n        surface->w = width;\n        surface->h = height;\n        surface->pitch = pitch;\n        SDL_SetClipRect(surface, NULL);\n    }\n    return surface;\n}", "path": "SDL\\src\\video\\SDL_surface.c", "repo_name": "lhzhang/SDL", "stars": 1, "license": "None", "language": "c", "size": 50836}
{"docstring": "/* Returns the current count of the semaphore */\n", "func_signal": "DECLSPEC Uint32 SDLCALL\nSDL_SemValue(SDL_sem * sem)", "code": "{\n    if (!sem) {\n        SDL_SetError(\"Passed a NULL sem\");\n        return 0;\n    }\n    return sem->value;\n}", "path": "SDL\\src\\thread\\os2\\SDL_syssem.c", "repo_name": "lhzhang/SDL", "stars": 1, "license": "None", "language": "c", "size": 50836}
{"docstring": "/* This can be used as a general routine for all of the test programs */\n", "func_signal": "int\nget_video_args(char *argv[], int *w, int *h, int *bpp, Uint32 * flags)", "code": "{\n    int i;\n\n    *w = 640;\n    *h = 480;\n    *bpp = 0;\n    *flags = SDL_SWSURFACE;\n\n    for (i = 1; argv[i]; ++i) {\n        if (strcmp(argv[i], \"-width\") == 0) {\n            if (argv[i + 1]) {\n                *w = atoi(argv[++i]);\n            }\n        } else if (strcmp(argv[i], \"-height\") == 0) {\n            if (argv[i + 1]) {\n                *h = atoi(argv[++i]);\n            }\n        } else if (strcmp(argv[i], \"-bpp\") == 0) {\n            if (argv[i + 1]) {\n                *bpp = atoi(argv[++i]);\n            }\n        } else if (strcmp(argv[i], \"-fullscreen\") == 0) {\n            *flags |= SDL_FULLSCREEN;\n        } else if (strcmp(argv[i], \"-hw\") == 0) {\n            *flags |= SDL_HWSURFACE;\n        } else if (strcmp(argv[i], \"-hwpalette\") == 0) {\n            *flags |= SDL_HWPALETTE;\n        } else\n            break;\n    }\n    return i;\n}", "path": "SDL\\test\\testgamma.c", "repo_name": "lhzhang/SDL", "stars": 1, "license": "None", "language": "c", "size": 50836}
{"docstring": "/*\n * Lock a surface to directly access the pixels\n */\n", "func_signal": "int\nSDL_LockSurface(SDL_Surface * surface)", "code": "{\n    if (!surface->locked) {\n        /* Perform the lock */\n        if (surface->flags & SDL_RLEACCEL) {\n            SDL_UnRLESurface(surface, 1);\n            surface->flags |= SDL_RLEACCEL;     /* save accel'd state */\n        }\n    }\n\n    /* Increment the surface lock count, for recursive locks */\n    ++surface->locked;\n\n    /* Ready to go.. */\n    return (0);\n}", "path": "SDL\\src\\video\\SDL_surface.c", "repo_name": "lhzhang/SDL", "stars": 1, "license": "None", "language": "c", "size": 50836}
{"docstring": "/* read a hfsp_cat_file from memory */\n", "func_signal": "static void* record_readfile(void *p, hfsp_cat_file* file)", "code": "{\n    file->flags\t\t\t= bswabU16_inc(p);\n    file->reserved1\t\t= bswabU32_inc(p);\n    file->id\t\t\t= bswabU32_inc(p);\n    file->create_date\t\t= bswabU32_inc(p);\n    file->content_mod_date\t= bswabU32_inc(p);\n    file->attribute_mod_date\t= bswabU32_inc(p);\n    file->access_date\t\t= bswabU32_inc(p);\n    file->backup_date\t\t= bswabU32_inc(p);\n    p = record_readperm\t    (p, &file->permissions);\n    p = record_readFInfo    (p, &file->user_info);\n    p = record_readFXInfo   (p, &file->finder_info);\n    file->text_encoding\t\t= bswabU32_inc(p);\n    file->reserved2\t\t= bswabU32_inc(p);\n    p =\t    volume_readfork (p, &file->data_fork);\n    return  volume_readfork (p, &file->res_fork);\n}", "path": "fs\\hfsplus\\record.c", "repo_name": "xtlx2000/openbios", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 1776}
{"docstring": "/* read a hfsp_cat_key from memory */\n", "func_signal": "void* record_readkey(void* p, void* buf)", "code": "{\n    hfsp_cat_key*   key = (hfsp_cat_key*) buf;\n    const void*\t    check;\n    UInt16\t    key_length, len,i;\n    UInt16*\t    cp;\n\n    key->key_length = key_length    = bswabU16_inc(p);\n    check = p;\n    key->parent_cnid\t\t    = bswabU32_inc(p);\n    key->name.strlen = len\t    = bswabU16_inc(p);\n    cp = key->name.name;\n    for (i=0; i < len; i++, cp++)\n\t*cp\t\t\t    = bswabU16_inc(p);\n\t/* check if keylenght was correct */\n    if (key_length != ((char*) p) - ((char*) check))\n\t HFSP_ERROR(EINVAL, \"Invalid key length in record_readkey\");\n    return p;\n  fail:\n    return NULL;\n}", "path": "fs\\hfsplus\\record.c", "repo_name": "xtlx2000/openbios", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 1776}
{"docstring": "/* Compare two extent_keys ... */\n", "func_signal": "int record_extent_key_compare(void* k1, void* k2)", "code": "{\n    hfsp_extent_key* key1 = (hfsp_extent_key*) k1;\n    hfsp_extent_key* key2 = (hfsp_extent_key*) k2;\n    int diff = key2->fork_type - key1->fork_type;\n    if (!diff) // same type\n    {\n\tdiff = key2->file_id - key1->file_id;\n\tif (!diff) // same file\n\t    diff = key2->start_block - key1->start_block;\n    }\n    return diff;\n}", "path": "fs\\hfsplus\\record.c", "repo_name": "xtlx2000/openbios", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 1776}
{"docstring": "/* print extended File info */\n", "func_signal": "static void record_print_FXInfo(FXInfo* xinfo)", "code": "{\n    printf(  \"fdIconID            :\\t%d\\n\",   xinfo->fdIconID);\n    // xinfo -> fdUnused;\n    printf(  \"fdComment           :\\t%d\\n\",   xinfo->fdComment);\n    printf(  \"fdPutAway           :\\t%ld\\n\",  xinfo->fdPutAway);\n}", "path": "fs\\hfsplus\\record.c", "repo_name": "xtlx2000/openbios", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 1776}
{"docstring": "/* print File info */\n", "func_signal": "static void record_print_FInfo(FInfo* finfo)", "code": "{\n    printf(  \"fdType              :\\t%4.4s\\n\", (char*) &finfo->fdType);\n    printf(  \"fdCreator           :\\t%4.4s\\n\", (char*) &finfo->fdCreator);\n    printf(  \"fdFlags             :\\t0X%X\\n\", finfo->fdFlags);\n    printf(  \"fdLocation          :\\t\");     record_print_Point(&finfo->fdLocation);\n    printf(\"\\nfdFldr              :\\t%d\\n\",  finfo->fdFldr);\n}", "path": "fs\\hfsplus\\record.c", "repo_name": "xtlx2000/openbios", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 1776}
{"docstring": "/* Position node in btree so that key might be inside */\n", "func_signal": "static node_buf* record_find_node(btree* tree, void *key)", "code": "{\n    int\t\t\tstart, end, mid, comp;  // components of a binary search\n    void\t\t*p = NULL;\n    char\t\tcurr_key[tree->head.max_key_len];\n\t\t    // The current key under examination\n    hfsp_key_read\treadkey\t    = tree->kread;\n    hfsp_key_compare\tkey_compare = tree->kcomp;\n    UInt32\t\tindex;\n    node_buf*\t\tnode = btree_node_by_index(tree, tree->head.root);\n    if (!node)\n\tHFSP_ERROR(-1, \"record_find_node: Cant position to root node\");\n    while (node->desc.kind == HFSP_NODE_NDX)\n    {\n\tmid = start = 0;\n\tend  = node->desc.num_rec;\n\tcomp = -1;\n\twhile (start < end)\n\t{\n\t    mid = (start + end) >> 1;\n\t    p = btree_key_by_index(tree, node, mid);\n\t    if (!p)\n\t\tHFSP_ERROR(-1, \"record_find_node: unexpected error\");\n\t    p = readkey  (p, curr_key);\n\t    if (!p)\n\t\tHFSP_ERROR(-1, \"record_find_node: unexpected error\");\n\t    comp = key_compare(curr_key, key);\n\t    if (comp > 0)\n\t\tstart = mid + 1;\n\t    else if (comp < 0)\n\t\tend = mid;\n\t    else\n\t\tbreak;\n\t}\n\tif (!p) // Empty tree, fascinating ...\n\t    HFSP_ERROR(-1, \"record_find_node: unexpected empty node\");\n\tif (comp < 0)\t// mmh interesting key is before this key ...\n\t{\n\t    if (mid == 0)\n\t\treturn NULL;  // nothing before this key ..\n\t    p = btree_key_by_index(tree, node, mid-1);\n\t    if (!p)\n\t\tHFSP_ERROR(-1, \"record_find_node: unexpected error\");\n\t    p = readkey  (p, curr_key);\n\t    if (!p)\n\t\tHFSP_ERROR(-1, \"record_find_node: unexpected error\");\n\t}\n\n\tindex = bswabU32_inc(p);\n\tnode = btree_node_by_index(tree, index);\n    }\n    return node;\t// go on and use the found node\n  fail:\n    return NULL;\n}", "path": "fs\\hfsplus\\record.c", "repo_name": "xtlx2000/openbios", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 1776}
{"docstring": "/* read extra Directory info */\n", "func_signal": "static inline void* record_readDXInfo(void *p, DXInfo* xinfo)", "code": "{\n    xinfo->frScroll.v  = bswabU16_inc(p);\n    xinfo->frScroll.h  = bswabU16_inc(p);\n    xinfo->frOpenChain = bswabU32_inc(p);\n    xinfo->frUnused    = bswabU16_inc(p);\n    xinfo->frComment   = bswabU16_inc(p);\n    xinfo->frPutAway   = bswabU32_inc(p);\n    return p;\n}", "path": "fs\\hfsplus\\record.c", "repo_name": "xtlx2000/openbios", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 1776}
{"docstring": "/* Compare two cat_keys ... */\n", "func_signal": "int record_key_compare(void* k1, void* k2)", "code": "{\n    hfsp_cat_key* key1 = (hfsp_cat_key*) k1;\n    hfsp_cat_key* key2 = (hfsp_cat_key*) k2;\n    int diff = key2->parent_cnid - key1->parent_cnid;\n    if (!diff) // same parent\n\tdiff = fast_unicode_compare(&key1->name, &key2->name);\n    return diff;\n}", "path": "fs\\hfsplus\\record.c", "repo_name": "xtlx2000/openbios", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 1776}
{"docstring": "/* intialize the record with the given index entry in the btree. */\n", "func_signal": "static int record_init_extent(extent_record* r, btree* bt, node_buf* buf, UInt16 index)", "code": "{\n    void *p;\n    r-> tree   = bt;\n    p = btree_key_by_index(bt, buf,index);\n    if (!p)\n\treturn -1;\n    p = record_extent_readkey(p, &r->key);\n    if (!p)\n\treturn -1;\n    p = volume_readextent(p, r->extent);\n    if (!p)\n\treturn -1;\n    r->node_index = buf->index;\n    r-> keyind    = index;\n\n    return 0;\n}", "path": "fs\\hfsplus\\record.c", "repo_name": "xtlx2000/openbios", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 1776}
{"docstring": "/* move record foreward to next extent record.\n *\n * In case of an error the value of *r is undefined !\n */\n", "func_signal": "int record_next_extent(extent_record* r)", "code": "{\n    btree*\ttree   = r->tree;\n    UInt16\tindex  = r->keyind +1;\n    UInt32\tfile_id;\n    UInt8\tfork_type;\n    node_buf*\tbuf\t= prepare_next(tree, r->node_index, &index);\n\n    if (!buf)\n\treturn ENOENT;\t// No (more) such file or directory\n\n    file_id\t= r->key.file_id;\n    fork_type\t= r->key.fork_type;\n\n    if (record_init_extent(r, tree, buf, index))\n\treturn -1;\n\n    if (r->key.file_id\t != file_id ||\t    // end of current file\n\tr->key.fork_type != fork_type ||    // end of current fork\n\tindex != r->keyind)\t\t    // internal error ?\n\treturn ENOENT;\t// No (more) such file or directory\n\n    return 0;\n}", "path": "fs\\hfsplus\\record.c", "repo_name": "xtlx2000/openbios", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 1776}
{"docstring": "/* read a hfsp_extent_key from memory */\n", "func_signal": "void* record_extent_readkey(void* p, void* buf)", "code": "{\n    hfsp_extent_key* key = (hfsp_extent_key*) buf;\n    UInt16  key_length;\n\n    key->key_length = key_length    = bswabU16_inc(p);\n    key->fork_type\t\t    = bswabU8_inc(p);\n    key->filler\t\t\t    = bswabU8_inc(p);\n    if (key_length != 10)\n\tHFSP_ERROR(-1, \"Invalid key length in record_extent_readkey\");\n    key->file_id\t\t    = bswabU32_inc(p);\n    key->start_block\t\t    = bswabU32_inc(p);\n    return p;\n  fail:\n    return NULL;\n}", "path": "fs\\hfsplus\\record.c", "repo_name": "xtlx2000/openbios", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 1776}
{"docstring": "/* read extra File info */\n", "func_signal": "static inline void* record_readFXInfo(void *p, FXInfo* xinfo)", "code": "{\n    SInt16 *q;\n    xinfo->fdIconID\t= bswabU16_inc(p);\n    q=(SInt16*) p;\n    q+=4; // skip unused\n    p=(void *)q;\n    xinfo->fdComment\t= bswabU16_inc(p);\n    xinfo->fdPutAway\t= bswabU32_inc(p);\n    return p;\n}", "path": "fs\\hfsplus\\record.c", "repo_name": "xtlx2000/openbios", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 1776}
{"docstring": "/* read a hfsp_cat_entry from memory */\n", "func_signal": "static void* record_readentry(void *p, hfsp_cat_entry* entry)", "code": "{\n    UInt16 type = bswabU16_inc(p);\n    entry->type = type;\n    switch (type)\n    {\n\tcase HFSP_FOLDER:\n\t    return record_readfolder(p, &entry->u.folder);\n\tcase HFSP_FILE:\n\t    return record_readfile  (p, &entry->u.file);\n\tcase HFSP_FOLDER_THREAD:\n\tcase HFSP_FILE_THREAD:\n\t    return record_readthread(p, &entry->u.thread);\n\tdefault:\n\t    HFSP_ERROR(-1, \"Unexpected record type in record_readentry\");\n    } ;\n  fail:\n    return NULL;\n}", "path": "fs\\hfsplus\\record.c", "repo_name": "xtlx2000/openbios", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 1776}
{"docstring": "/* print Quickdraw Rect */\n", "func_signal": "static void record_print_Rect(Rect* r)", "code": "{\n    printf(\"[ top=%d, left=%d, bottom=%d, right=%d  ]\",\n\t     r->top, r->left, r->bottom, r->right);\n}", "path": "fs\\hfsplus\\record.c", "repo_name": "xtlx2000/openbios", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 1776}
{"docstring": "/* read a hfsp_cat_folder from memory */\n", "func_signal": "static void* record_readfolder(void *p, hfsp_cat_folder* folder)", "code": "{\n    folder->flags\t\t= bswabU16_inc(p);\n    folder->valence\t\t= bswabU32_inc(p);\n    folder->id\t\t\t= bswabU32_inc(p);\n    folder->create_date\t\t= bswabU32_inc(p);\n    folder->content_mod_date    = bswabU32_inc(p);\n    folder->attribute_mod_date\t= bswabU32_inc(p);\n    folder->access_date\t\t= bswabU32_inc(p);\n    folder->backup_date\t\t= bswabU32_inc(p);\n    p = record_readperm\t    (p, &folder->permissions);\n    p = record_readDInfo    (p, &folder->user_info);\n    p = record_readDXInfo   (p, &folder->finder_info);\n    folder->text_encoding\t= bswabU32_inc(p);\n    folder->reserved\t\t= bswabU32_inc(p);\n    return p;\n}", "path": "fs\\hfsplus\\record.c", "repo_name": "xtlx2000/openbios", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 1776}
{"docstring": "/* print the key of a record */\n", "func_signal": "static void record_print_key(hfsp_cat_key* key)", "code": "{\n    char buf[255]; // mh this _might_ overflow\n    unicode_uni2asc(buf, &key->name, 255);\n    printf(\"parent cnid :    %ld\\n\",   key->parent_cnid);\n    printf(\"name        :    %s\\n\", buf);\n}", "path": "fs\\hfsplus\\record.c", "repo_name": "xtlx2000/openbios", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 1776}
{"docstring": "/* search for the given key in the btree.\n *\n * returns pointer to memory just after key or NULL\n * In any case *keyind recives the index where the\n * key was found (or could be inserted.)\n */\n", "func_signal": "static void *\nrecord_find_key(btree* tree, void* key, int* keyind, UInt16* node_index)", "code": "{\n    node_buf* buf = record_find_node(tree, key);\n    if (buf)\n    {\n\tint\t\t    comp  = -1;\n\tint\t\t    start = 0; // components of a binary search\n\tint\t\t    end   = buf->desc.num_rec;\n\tint\t\t    mid   = -1;\n\tvoid\t\t    *p    = NULL;\n\tchar\t\t    curr_key[tree->head.max_key_len];\n\thfsp_key_read\t    readkey\t= tree->kread;\n\thfsp_key_compare    key_compare = tree->kcomp;\n\twhile (start < end)\n\t{\n\t    mid = (start + end) >> 1;\n\t    p = btree_key_by_index(tree, buf, mid);\n\t    if (!p)\n\t\tHFSP_ERROR(-1, \"record_init_key: unexpected error\");\n\t    p = readkey  (p, curr_key);\n\t    if (!p)\n\t\tHFSP_ERROR(-1, \"record_init_cat_key: unexpected error\");\n\t    comp = key_compare(curr_key, key);\n\t    if (comp > 0)\n\t\tstart = mid + 1;\n\t    else if (comp < 0)\n\t\tend = mid;\n\t    else\n\t\tbreak;\n\t}\n\tif (!p) // Empty tree, fascinating ...\n\t    HFSP_ERROR(ENOENT, \"record_init_key: unexpected empty node\");\n\t*keyind = mid;\n\t*node_index = buf->index;\n\tif (!comp)\t// found something ...\n\t    return p;\n    }\n    HFSP_ERROR(ENOENT, NULL);\n  fail:\n    return NULL;\n}", "path": "fs\\hfsplus\\record.c", "repo_name": "xtlx2000/openbios", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 1776}
{"docstring": "/* Dump all the record information to stdout */\n", "func_signal": "void record_print(record* r)", "code": "{\n    printf (\"keyind      :    %u\\n\", r->keyind);\n    record_print_key  (&r->key);\n    record_print_entry(&r->record);\n}", "path": "fs\\hfsplus\\record.c", "repo_name": "xtlx2000/openbios", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 1776}
{"docstring": "/* print extended Directory info */\n", "func_signal": "static void record_print_DXInfo(DXInfo* xinfo)", "code": "{\n    printf(  \"frScroll            :\\t\");    record_print_Point(&xinfo->frScroll);\n    printf(\"\\nfrOpenChain         :\\t%ld\\n\",  xinfo->frOpenChain);\n    printf(  \"frUnused            :\\t%d\\n\",   xinfo->frUnused);\n    printf(  \"frComment           :\\t%d\\n\",   xinfo->frComment);\n    printf(  \"frPutAway           :\\t%ld\\n\",  xinfo->frPutAway);\n}", "path": "fs\\hfsplus\\record.c", "repo_name": "xtlx2000/openbios", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 1776}
{"docstring": "/* print info for a file or folder thread */\n", "func_signal": "static void record_print_thread(hfsp_cat_thread* entry)", "code": "{\n    char buf[255]; // mh this _might_ overflow\n    unicode_uni2asc(buf, &entry->nodeName, 255);\n    printf(\"parent cnid :\\t%ld\\n\", entry->parentID);\n    printf(\"name        :\\t%s\\n\" , buf);\n}", "path": "fs\\hfsplus\\record.c", "repo_name": "xtlx2000/openbios", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 1776}
{"docstring": "/*\n * NAME:\tget_dir()\n * DESCRIPTION:\tget a directory listing\n */\n", "func_signal": "static mixed **get_dir(string path)", "code": "{\n    string oname, *names, dir;\n    mixed **list, *olist;\n    int i, sz;\n\n    CHECKARG(path, 1, \"get_dir\");\n    if (!this_object()) {\n\terror(\"Permission denied\");\n    }\n\n    oname = object_name(this_object());\n    path = ::find_object(DRIVER)->normalize_path(path, oname + \"/..\", creator);\n    if (creator != \"System\" &&\n\t!::find_object(ACCESSD)->access(oname, path, READ_ACCESS)) {\n\terror(\"Access denied\");\n    }\n\n    list = ::get_dir(path);\n    names = explode(path, \"/\");\n    dir = implode(names[.. sizeof(names) - 2], \"/\");\n    names = list[0];\n    olist = allocate(sz = sizeof(names));\n    if (sscanf(path, \"%*s\" + INHERITABLE_SUBDIR) != 0) {\n\t/* lib objects */\n\tfor (i = sz; --i >= 0; ) {\n\t    path = dir + \"/\" + names[i];\n\t    if ((sz=strlen(path)) >= 2 && path[sz - 2 ..] == \".c\" &&\n\t\t::find_object(path[.. sz - 3])) {\n\t\tolist[i] = TRUE;\n\t    }\n\t}\n    } else {\n\t/* ordinary objects */\n\tfor (i = sz; --i >= 0; ) {\n\t    object obj;\n\n\t    path = dir + \"/\" + names[i];\n\t    if ((sz=strlen(path)) >= 2 && path[sz - 2 ..] == \".c\" &&\n\t\t(obj=::find_object(path[.. sz - 3]))) {\n\t\tolist[i] = obj;\n\t    }\n\t}\n    }\n    return list + ({ olist });\n}", "path": "kernel\\lib\\auto.c", "repo_name": "bct/dgdunit", "stars": 1, "license": "None", "language": "c", "size": 124}
{"docstring": "/*\n * NAME:\tcall_touch()\n * DESCRIPTION:\tarrange to be warned when a function is called in an object\n */\n", "func_signal": "static void call_touch(object obj)", "code": "{\n    if (creator != \"System\") {\n\terror(\"Permission denied\");\n    }\n    ::call_touch(obj);\n}", "path": "kernel\\lib\\auto.c", "repo_name": "bct/dgdunit", "stars": 1, "license": "None", "language": "c", "size": 124}
{"docstring": "/*\n * NAME:\t_F_release()\n * DESCRIPTION:\trelease a suspended callout\n */\n", "func_signal": "nomask void _F_release(mixed handle)", "code": "{\n    if (previous_program() == RSRCD) {\n\tint i;\n\tmixed **callouts;\n\n\tcallouts = ::status(this_object())[O_CALLOUTS];\n\t::remove_call_out(handle);\n\tfor (i = sizeof(callouts); callouts[--i][CO_HANDLE] != handle; ) ;\n\thandle = allocate(::find_object(DRIVER)->query_tls_size());\n\t_F_call_limited(callouts[i][CO_FIRSTXARG],\n\t\t\tcallouts[i][CO_FIRSTXARG + 2]);\n    }\n}", "path": "kernel\\lib\\auto.c", "repo_name": "bct/dgdunit", "stars": 1, "license": "None", "language": "c", "size": 124}
{"docstring": "/*\n * NAME:\tadd_event()\n * DESCRIPTION:\tadd a new event type\n */\n", "func_signal": "static void add_event(string name)", "code": "{\n    CHECKARG(name, 1, \"add_event\");\n    if (!next && prev) {\n\terror(\"Cannot add event in non-persistent object\");\n    }\n\n    if (!events) {\n\tevents = ([ ]);\n    }\n    if (!events[name]) {\n\tevents[name] = ({ });\n    }\n}", "path": "kernel\\lib\\auto.c", "repo_name": "bct/dgdunit", "stars": 1, "license": "None", "language": "c", "size": 124}
{"docstring": "/*\n * NAME:\t_F_callout()\n * DESCRIPTION:\tcallout gate\n */\n", "func_signal": "nomask void _F_callout(string function, int suspended, mixed *args)", "code": "{\n    if (!previous_program()) {\n\tif (!suspended &&\n\t    !::find_object(RSRCD)->suspended(this_object(), owner)) {\n\t    _F_call_limited(function, args);\n\t} else {\n\t    int handle;\n\n\t    handle = ::call_out(\"_F_callout\", LONG_TIME, function, TRUE, args);\n\t    if (!suspended) {\n\t\t::find_object(RSRCD)->suspend(this_object(), owner, handle);\n\t    }\n\t}\n    }\n}", "path": "kernel\\lib\\auto.c", "repo_name": "bct/dgdunit", "stars": 1, "license": "None", "language": "c", "size": 124}
{"docstring": "/*\n * NAME:\t_F_call_limited()\n * DESCRIPTION:\tcall a function with limited stack depth and ticks\n */\n", "func_signal": "private mixed _F_call_limited(mixed arg1, mixed *args)", "code": "{\n    object rsrcd;\n    int stack, ticks;\n    string function;\n    mixed tls, *limits, result;\n\n    rsrcd = ::find_object(RSRCD);\n    function = arg1;\n    stack = ::status()[ST_STACKDEPTH];\n    ticks = ::status()[ST_TICKS];\n    rlimits (-1; -1) {\n\ttls = ::call_trace()[1][TRACE_FIRSTARG];\n\tif (tls == arg1) {\n\t    tls = arg1 = allocate(::find_object(DRIVER)->query_tls_size());\n\t}\n\tlimits = tls[0] = rsrcd->call_limits(tls[0], owner, stack, ticks);\n    }\n\n    rlimits (limits[LIM_MAXSTACK]; limits[LIM_MAXTICKS]) {\n\tresult = call_other(this_object(), function, args...);\n\n\tticks = ::status()[ST_TICKS];\n\trlimits (-1; -1) {\n\t    rsrcd->update_ticks(limits, ticks);\n\t    tls[0] = limits[LIM_NEXT];\n\n\t    return result;\n\t}\n    }\n}", "path": "kernel\\lib\\auto.c", "repo_name": "bct/dgdunit", "stars": 1, "license": "None", "language": "c", "size": 124}
{"docstring": "/*\n * NAME:\tremove_dir()\n * DESCRIPTION:\tremove a directory\n */\n", "func_signal": "static int remove_dir(string path)", "code": "{\n    string oname;\n    object driver;\n    int result;\n\n    CHECKARG(path, 1, \"remove_dir\");\n    if (!this_object()) {\n\terror(\"Permission denied\");\n    }\n\n    oname = object_name(this_object());\n    driver = ::find_object(DRIVER);\n    path = driver->normalize_path(path, oname + \"/..\", creator);\n    if (sscanf(path, \"/kernel/%*s\") != 0 ||\n\tsscanf(path, \"/include/kernel/%*s\") != 0 ||\n\t(creator != \"System\" &&\n\t !::find_object(ACCESSD)->access(oname, path, WRITE_ACCESS))) {\n\terror(\"Access denied\");\n    }\n\n    catch {\n\trlimits (-1; -1) {\n\t    result = ::remove_dir(path);\n\t    if (result != 0) {\n\t\t::find_object(RSRCD)->rsrc_incr(driver->creator(path + \"/\"),\n\t\t\t\t\t\t\"filequota\", nil, -1);\n\t    }\n\t}\n    } : error(TLSVAR2);\n    return result;\n}", "path": "kernel\\lib\\auto.c", "repo_name": "bct/dgdunit", "stars": 1, "license": "None", "language": "c", "size": 124}
{"docstring": "/*\n * NAME:\tcall_trace()\n * DESCRIPTION:\tcall trace\n */\n", "func_signal": "static mixed **call_trace()", "code": "{\n    mixed **trace, *call;\n    int i;\n    object driver;\n\n    trace = ::call_trace();\n    trace[1][TRACE_FIRSTARG] = nil;\n    if (creator != \"System\") {\n\tdriver = ::find_object(DRIVER);\n\tfor (i = sizeof(trace) - 1; --i >= 0; ) {\n\t    if (sizeof(call = trace[i]) > TRACE_FIRSTARG &&\n\t\tcreator != driver->creator(call[TRACE_PROGNAME])) {\n\t\t/* remove arguments */\n\t\ttrace[i] = call[.. TRACE_FIRSTARG - 1];\n\t    }\n\t}\n    }\n\n    return trace;\n}", "path": "kernel\\lib\\auto.c", "repo_name": "bct/dgdunit", "stars": 1, "license": "None", "language": "c", "size": 124}
{"docstring": "/*\n * NAME:\tcall_limited()\n * DESCRIPTION:\tcall a function with the current object owner's resource limits\n */\n", "func_signal": "static mixed call_limited(string function, mixed args...)", "code": "{\n    CHECKARG(function, 1, \"call_limited\");\n    if (!this_object()) {\n\treturn nil;\n    }\n    CHECKARG(function_object(function, this_object()) != AUTO ||\n\t\t\t\t\t\t\t function == \"create\",\n\t     1, \"call_limited\");\n\n    return _F_call_limited(function, args);\n}", "path": "kernel\\lib\\auto.c", "repo_name": "bct/dgdunit", "stars": 1, "license": "None", "language": "c", "size": 124}
{"docstring": "/*\n * NAME:\tclone_object()\n * DESCRIPTION:\tclone an object\n */\n", "func_signal": "static object clone_object(string path, varargs string uid)", "code": "{\n    string oname;\n    object rsrcd, obj;\n    int *rsrc, stack, ticks;\n\n    CHECKARG(path, 1, \"clone_object\");\n    if (uid) {\n\tCHECKARG(creator == \"System\", 1, \"clone_object\");\n    } else {\n\tuid = owner;\n    }\n    if (!this_object()) {\n\terror(\"Permission denied\");\n    }\n\n    /*\n     * check access\n     */\n    oname = object_name(this_object());\n    path = ::find_object(DRIVER)->normalize_path(path, oname + \"/..\", creator);\n    if ((sscanf(path, \"/kernel/%*s\") != 0 && !KERNEL()) ||\n\t(creator != \"System\" &&\n\t !::find_object(ACCESSD)->access(oname, path, READ_ACCESS))) {\n\t/*\n\t * kernel objects can only be cloned by kernel objects, and cloning\n\t * in general requires read access\n\t */\n\terror(\"Access denied\");\n    }\n\n    /*\n     * check if object can be cloned\n     */\n    if (!owner || !(obj=::find_object(path)) ||\n\tsscanf(path, \"%*s\" + CLONABLE_SUBDIR) == 0 ||\n\tsscanf(path, \"%*s\" + LIGHTWEIGHT_SUBDIR) != 0 ||\n\tsscanf(path, \"%*s\" + INHERITABLE_SUBDIR) != 0) {\n\t/*\n\t * no owner for clone, master object not compiled, or not path of\n\t * clonable\n\t */\n\terror(\"Cannot clone \" + path);\n    }\n\n    /*\n     * check resource usage\n     */\n    rsrcd = ::find_object(RSRCD);\n    if (path != BINARY_CONN && path != TELNET_CONN && path != RSRCOBJ) {\n\trsrc = rsrcd->rsrc_get(uid, \"objects\");\n\tif (rsrc[RSRC_USAGE] >= rsrc[RSRC_MAX] && rsrc[RSRC_MAX] >= 0) {\n\t    error(\"Too many objects\");\n\t}\n    }\n    if (::status()[ST_NOBJECTS] == ::status()[ST_OTABSIZE]) {\n\terror(\"Too many objects\");\n    }\n\n    /*\n     * do the cloning\n     */\n    stack = ::status()[ST_STACKDEPTH];\n    ticks = ::status()[ST_TICKS];\n    catch {\n\trlimits (-1; -1) {\n\t    if ((stack >= 0 &&\n\t\t stack - 2 < rsrcd->rsrc_get(uid, \"create stack\")[RSRC_MAX]) ||\n\t\t(ticks >= 0 &&\n\t\t ticks < rsrcd->rsrc_get(uid, \"create ticks\")[RSRC_MAX])) {\n\t\terror(\"Insufficient stack or ticks to create object\");\n\t    }\n\t    if (path != BINARY_CONN && path != TELNET_CONN && path != RSRCOBJ) {\n\t\trsrcd->rsrc_incr(uid, \"objects\", nil, 1, TRUE);\n\t    }\n\t    TLSVAR2 = uid;\n\t}\n    } : error(TLSVAR2);\n    return ::clone_object(obj);\n}", "path": "kernel\\lib\\auto.c", "repo_name": "bct/dgdunit", "stars": 1, "license": "None", "language": "c", "size": 124}
{"docstring": "/*\n * NAME:\tremove_call_out()\n * DESCRIPTION:\tremove a callout\n */\n", "func_signal": "static mixed remove_call_out(int handle)", "code": "{\n    rlimits (-1; -1) {\n\tmixed delay;\n\n\tif (!next && prev) {\n\t    error(\"No callouts in non-persistent object\");\n\t}\n\tif ((delay=::remove_call_out(handle)) != -1 &&\n\t    ::find_object(RSRCD)->remove_callout(this_object(), owner, handle))\n\t{\n\t    return 0;\n\t}\n\treturn delay;\n    }\n}", "path": "kernel\\lib\\auto.c", "repo_name": "bct/dgdunit", "stars": 1, "license": "None", "language": "c", "size": 124}
{"docstring": "/*\n * NAME:\t_F_destruct()\n * DESCRIPTION:\tprepare object for being destructed\n */\n", "func_signal": "nomask void _F_destruct()", "code": "{\n    if (previous_program() == AUTO) {\n\tobject rsrcd;\n\tint i, j;\n\n\trsrcd = ::find_object(RSRCD);\n\n\tif (events) {\n\t    object **evtlist, *objlist, obj;\n\n\t    /*\n\t     * decrease resources of other objects subscribed to events\n\t     */\n\t    evtlist = map_values(events);\n\t    i = sizeof(evtlist);\n\t    while (--i >= 0) {\n\t\tj = sizeof(objlist = evtlist[i] - ({ nil }));\n\t\twhile (--j >= 0) {\n\t\t    obj = objlist[j];\n\t\t    if (obj != this_object()) {\n\t\t\trsrcd->rsrc_incr(obj->query_owner(), \"events\", obj, -1);\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\t/*\n\t * remove callouts\n\t */\n\trsrcd->remove_callouts(this_object(), owner,\n\t\t\t       (resources && resources[\"callouts\"]) ?\n\t\t\t\tresources[\"callouts\"] : 0);\n\n\tif (resources) {\n\t    string *names;\n\t    int *values;\n\n\t    /*\n\t     * decrease resources associated with object\n\t     */\n\t    names = map_indices(resources);\n\t    values = map_values(resources);\n\t    i = sizeof(names);\n\t    while (--i >= 0) {\n\t\trsrcd->rsrc_incr(owner, names[i], this_object(), -values[i]);\n\t    }\n\t}\n\n\tif (next) {\n\t    ::find_object(OBJREGD)->unlink(this_object(), owner);\n\t    if (sscanf(object_name(this_object()), \"%*s#\") != 0) {\n\t\t/*\n\t\t * non-clones are handled by driver->remove_program()\n\t\t */\n\t\trsrcd->rsrc_incr(owner, \"objects\", nil, -1);\n\t    }\n\t}\n    }\n}", "path": "kernel\\lib\\auto.c", "repo_name": "bct/dgdunit", "stars": 1, "license": "None", "language": "c", "size": 124}
{"docstring": "/*\n * NAME:\tswapout()\n * DESCRIPTION:\tswap out all objects\n */\n", "func_signal": "static void swapout()", "code": "{\n    if (creator != \"System\") {\n\terror(\"Permission denied\");\n    }\n    ::swapout();\n}", "path": "kernel\\lib\\auto.c", "repo_name": "bct/dgdunit", "stars": 1, "license": "None", "language": "c", "size": 124}
{"docstring": "/*\n * NAME:\tread_file()\n * DESCRIPTION:\tread a string from a file\n */\n", "func_signal": "static string read_file(string path, varargs int offset, int size)", "code": "{\n    string oname;\n\n    CHECKARG(path, 1, \"read_file\");\n    if (!this_object()) {\n\terror(\"Permission denied\");\n    }\n\n    oname = object_name(this_object());\n    path = ::find_object(DRIVER)->normalize_path(path, oname + \"/..\", creator);\n    if (creator != \"System\" &&\n\t!::find_object(ACCESSD)->access(oname, path, READ_ACCESS)) {\n\terror(\"Access denied\");\n    }\n\n    return ::read_file(path, offset, size);\n}", "path": "kernel\\lib\\auto.c", "repo_name": "bct/dgdunit", "stars": 1, "license": "None", "language": "c", "size": 124}
{"docstring": "/*\n * NAME:\tremove_file()\n * DESCRIPTION:\tremove a file\n */\n", "func_signal": "static int remove_file(string path)", "code": "{\n    string oname;\n    object driver;\n    int size, result;\n\n    CHECKARG(path, 1, \"remove_file\");\n    if (!this_object()) {\n\terror(\"Permission denied\");\n    }\n\n    oname = object_name(this_object());\n    driver = ::find_object(DRIVER);\n    path = driver->normalize_path(path, oname + \"/..\", creator);\n    if (sscanf(path, \"/kernel/%*s\") != 0 ||\n\tsscanf(path, \"/include/kernel/%*s\") != 0 ||\n\t(creator != \"System\" &&\n\t !::find_object(ACCESSD)->access(oname, path, WRITE_ACCESS))) {\n\terror(\"Access denied\");\n    }\n\n    size = driver->file_size(path);\n    catch {\n\trlimits (-1; -1) {\n\t    result = ::remove_file(path);\n\t    if (result != 0 && size != 0) {\n\t\t::find_object(RSRCD)->rsrc_incr(driver->creator(path),\n\t\t\t\t\t\t\"filequota\", nil, -size);\n\t    }\n\t}\n    } : error(TLSVAR2);\n    return result;\n}", "path": "kernel\\lib\\auto.c", "repo_name": "bct/dgdunit", "stars": 1, "license": "None", "language": "c", "size": 124}
{"docstring": "/*\n * NAME:\tcompile_object()\n * DESCRIPTION:\tcompile a master object\n */\n", "func_signal": "static object compile_object(string path, string source...)", "code": "{\n    string oname, uid;\n    object driver, rsrcd, obj;\n    int *rsrc, lib, kernel, new, stack, ticks;\n\n    CHECKARG(path, 1, \"compile_object\");\n    if (!this_object()) {\n\terror(\"Permission denied\");\n    }\n\n    /*\n     * check access\n     */\n    oname = object_name(this_object());\n    driver = ::find_object(DRIVER);\n    path = driver->normalize_path(path, oname + \"/..\", creator);\n    lib = sscanf(path, \"%*s\" + INHERITABLE_SUBDIR);\n    kernel = sscanf(path, \"/kernel/%*s\");\n    uid = driver->creator(path);\n    if ((sizeof(source) != 0 && kernel) ||\n\t(creator != \"System\" &&\n\t !::find_object(ACCESSD)->access(oname, path,\n\t\t\t\t\t ((lib || !uid) &&\n\t\t\t\t\t  sizeof(source) == 0 && !kernel) ?\n\t\t\t\t\t  READ_ACCESS : WRITE_ACCESS))) {\n\terror(\"Access denied\");\n    }\n\n    /*\n     * check resource usage\n     */\n    rsrcd = ::find_object(RSRCD);\n    rsrc = rsrcd->rsrc_get(uid, \"objects\");\n    if (rsrc[RSRC_USAGE] >= rsrc[RSRC_MAX] && rsrc[RSRC_MAX] >= 0) {\n\terror(\"Too many objects\");\n    }\n\n    /*\n     * do the compiling\n     */\n    new = !::find_object(path);\n    stack = ::status()[ST_STACKDEPTH];\n    ticks = ::status()[ST_TICKS];\n    rlimits (-1; -1) {\n\tcatch {\n\t    if (new && !lib) {\n\t\tif ((stack >= 0 &&\n\t\t     stack - 2 < rsrcd->rsrc_get(uid,\n\t\t\t\t\t\t \"create stack\")[RSRC_MAX]) ||\n\t\t    (ticks >= 0 &&\n\t\t     ticks < rsrcd->rsrc_get(uid, \"create ticks\")[RSRC_MAX])) {\n\t\t    error(\"Insufficient stack or ticks to create object\");\n\t\t}\n\t    }\n\t    driver->compiling(path);\n\t    if (sizeof(source) != 0) {\n\t\tobj = ::compile_object(path, source...);\n\t    } else {\n\t\tobj = ::compile_object(path);\n\t    }\n\t    if (new) {\n\t\trsrcd->rsrc_incr(uid, \"objects\", nil, 1, TRUE);\n\t    }\n\t    if (lib) {\n\t\tdriver->compile_lib(path, uid, source...);\n\t    } else {\n\t\tdriver->compile(obj, uid, source...);\n\t    }\n\t} : {\n\t    driver->compile_failed(path, uid);\n\t    rlimits (stack; ticks) {\n\t\terror(TLSVAR2);\n\t    }\n\t}\n    }\n    if (new && !lib) {\n\tcall_other(obj, \"???\");\t/* initialize & register */\n    }\n\n    return (lib) ? nil : obj;\n}", "path": "kernel\\lib\\auto.c", "repo_name": "bct/dgdunit", "stars": 1, "license": "None", "language": "c", "size": 124}
{"docstring": "/*\n * NAME:\tsave_object()\n * DESCRIPTION:\tsave the state of an object\n */\n", "func_signal": "static void save_object(string path)", "code": "{\n    string oname, fcreator;\n    object driver, rsrcd;\n    int size, *rsrc;\n\n    CHECKARG(path, 1, \"save_object\");\n    if (!this_object()) {\n\terror(\"Permission denied\");\n    }\n\n    oname = object_name(this_object());\n    driver = ::find_object(DRIVER);\n    path = driver->normalize_path(path, oname + \"/..\", creator);\n    if ((sscanf(path, \"/kernel/%*s\") != 0 &&\n\t sscanf(oname, \"/kernel/%*s\") == 0) ||\n\tsscanf(path, \"/include/kernel/%*s\") != 0 ||\n\t(creator != \"System\" &&\n\t !::find_object(ACCESSD)->access(oname, path, WRITE_ACCESS))) {\n\terror(\"Access denied\");\n    }\n\n    fcreator = driver->creator(path);\n    rsrcd = ::find_object(RSRCD);\n    rsrc = rsrcd->rsrc_get(fcreator, \"filequota\");\n    if (creator != \"System\" && rsrc[RSRC_USAGE] >= rsrc[RSRC_MAX] &&\n\trsrc[RSRC_MAX] >= 0) {\n\terror(\"File quota exceeded\");\n    }\n\n    size = driver->file_size(path);\n    catch {\n\trlimits (-1; -1) {\n\t    ::save_object(path);\n\t    if ((size=driver->file_size(path) - size) != 0) {\n\t\trsrcd->rsrc_incr(fcreator, \"filequota\", nil, size, TRUE);\n\t    }\n\t}\n    } : error(TLSVAR2);\n}", "path": "kernel\\lib\\auto.c", "repo_name": "bct/dgdunit", "stars": 1, "license": "None", "language": "c", "size": 124}
{"docstring": "/*\n * NAME:\tsubscribe_event()\n * DESCRIPTION:\tsubscribe to an event\n */\n", "func_signal": "static void subscribe_event(object obj, string name)", "code": "{\n    CHECKARG(obj, 1, \"subscribe_event\");\n    CHECKARG(name, 2, \"subscribe_event\");\n\n    if (!next || !obj->allow_subscribe(this_object(), name) || !obj) {\n\terror(\"Cannot subscribe to event\");\n    }\n    obj->_F_subscribe_event(this_object(), owner, name, TRUE);\n}", "path": "kernel\\lib\\auto.c", "repo_name": "bct/dgdunit", "stars": 1, "license": "None", "language": "c", "size": 124}
{"docstring": "/*\n * NAME:\tevent()\n * DESCRIPTION:\tbroadcast an event\n */\n", "func_signal": "static void event(string name, mixed args...)", "code": "{\n    object *objlist;\n    string *names;\n    int i, sz;\n\n    CHECKARG(name, 1, \"event\");\n    if (!events || !(objlist=events[name])) {\n\terror(\"No such event\");\n    }\n\n    name = \"evt_\" + name;\n    args = ({ this_object() }) + args;\n    sz = sizeof(objlist);\n    objlist -= ({ nil });\n    if (sz != sizeof(objlist)) {\n\tevents[name] = objlist;\n\tsz = sizeof(objlist);\n    }\n    for (i = 0; i < sz; i++) {\n\tobjlist[i]->_F_start_event(name, args);\n    }\n}", "path": "kernel\\lib\\auto.c", "repo_name": "bct/dgdunit", "stars": 1, "license": "None", "language": "c", "size": 124}
{"docstring": "/*\n * NAME:\tstatus()\n * DESCRIPTION:\tget information about an object\n */\n", "func_signal": "static mixed *status(varargs mixed obj)", "code": "{\n    object driver;\n    string oname;\n    mixed *status, **callouts, *co;\n    int i;\n\n    if (!this_object()) {\n\treturn nil;\n    }\n    if (!obj) {\n\tmixed *precompiled;\n\n\tstatus = ::status();\n\tif (status[ST_STACKDEPTH] >= 0) {\n\t    status[ST_STACKDEPTH]++;\n\t}\n\tprecompiled = status[ST_PRECOMPILED];\n\tif (precompiled) {\n\t    for (i = sizeof(precompiled); --i >= 0; ) {\n\t\tprecompiled[i] = object_name(precompiled[i]);\n\t    }\n\t}\n\treturn status;\n    }\n\n    /*\n     * check arguments\n     */\n    driver = ::find_object(DRIVER);\n    if (typeof(obj) == T_STRING) {\n\t/* get corresponding object */\n\tobj = ::find_object(driver->normalize_path(obj,\n\t\t\t\t\t\t   object_name(this_object()) +\n\t\t\t\t\t\t   \"/..\",\n\t\t\t\t\t\t   creator));\n\tif (!obj) {\n\t    return nil;\n\t}\n    }\n    CHECKARG(typeof(obj) == T_OBJECT, 1, \"status\");\n\n    status = ::status(obj);\n    callouts = status[O_CALLOUTS];\n    if (callouts && (i=sizeof(callouts)) != 0) {\n\toname = object_name(obj);\n\tif (sscanf(oname, \"/kernel/%*s\") != 0) {\n\t    /* can't see callouts in kernel objects */\n\t    status[O_CALLOUTS] = ({ });\n\t} else if (obj != this_object() && creator != \"System\" &&\n\t\t   (!owner || owner != obj->query_owner())) {\n\t    /* remove arguments from callouts */\n\t    do {\n\t\t--i;\n\t\tco = callouts[i];\n\t\tcallouts[i] = ({ co[CO_HANDLE], co[CO_FIRSTXARG],\n\t\t\t\t (co[CO_FIRSTXARG + 1]) ? 0 : co[CO_DELAY] });\n\t    } while (i != 0);\n\t} else {\n\t    do {\n\t\t--i;\n\t\tco = callouts[i];\n\t\tcallouts[i] = ({ co[CO_HANDLE], co[CO_FIRSTXARG],\n\t\t\t\t (co[CO_FIRSTXARG + 1]) ? 0 : co[CO_DELAY] }) +\n\t\t\t      co[CO_FIRSTXARG + 2];\n\t    } while (i != 0);\n\t}\n    }\n    return status;\n}", "path": "kernel\\lib\\auto.c", "repo_name": "bct/dgdunit", "stars": 1, "license": "None", "language": "c", "size": 124}
{"docstring": "/*\tand the code magic begins here [8^)\t*/\n", "func_signal": "unsigned int\n\tSOIL_load_OGL_texture\n\t(\n\t\tconst char *filename,\n\t\tint force_channels,\n\t\tunsigned int reuse_texture_ID,\n\t\tunsigned int flags\n\t)", "code": "{\n\t/*\tvariables\t*/\n\tunsigned char* img;\n\tint width, height, channels;\n\tunsigned int tex_id;\n\t/*\tdoes the user want direct uploading of the image as a DDS file?\t*/\n\tif( flags & SOIL_FLAG_DDS_LOAD_DIRECT )\n\t{\n\t\t/*\t1st try direct loading of the image as a DDS file\n\t\t\tnote: direct uploading will only load what is in the\n\t\t\tDDS file, no MIPmaps will be generated, the image will\n\t\t\tnot be flipped, etc.\t*/\n\t\ttex_id = SOIL_direct_load_DDS( filename, reuse_texture_ID, flags, 0 );\n\t\tif( tex_id )\n\t\t{\n\t\t\t/*\they, it worked!!\t*/\n\t\t\treturn tex_id;\n\t\t}\n\t}\n\t/*\ttry to load the image\t*/\n\timg = SOIL_load_image( filename, &width, &height, &channels, force_channels );\n\t/*\tchannels holds the original number of channels, which may have been forced\t*/\n\tif( (force_channels >= 1) && (force_channels <= 4) )\n\t{\n\t\tchannels = force_channels;\n\t}\n\tif( NULL == img )\n\t{\n\t\t/*\timage loading failed\t*/\n\t\tresult_string_pointer = stbi_failure_reason();\n\t\treturn 0;\n\t}\n\t/*\tOK, make it a texture!\t*/\n\ttex_id = SOIL_internal_create_OGL_texture(\n\t\t\timg, width, height, channels,\n\t\t\treuse_texture_ID, flags,\n\t\t\tGL_TEXTURE_2D, GL_TEXTURE_2D,\n\t\t\tGL_MAX_TEXTURE_SIZE );\n\t/*\tand nuke the image data\t*/\n\tSOIL_free_image_data( img );\n\t/*\tand return the handle, such as it is\t*/\n\treturn tex_id;\n}", "path": "src\\SOIL\\SOIL.c", "repo_name": "kosievdmerwe/SMS", "stars": 1, "license": "None", "language": "c", "size": 144}
{"docstring": "// create the png data from post-deflated data\n", "func_signal": "static int create_png_image(png *a, uint8 *raw, uint32 raw_len, int out_n)", "code": "{\n   stbi *s = &a->s;\n   uint32 i,j,stride = s->img_x*out_n;\n   int k;\n   int img_n = s->img_n; // copy it into a local for later\n   assert(out_n == s->img_n || out_n == s->img_n+1);\n   a->out = (uint8 *) malloc(s->img_x * s->img_y * out_n);\n   if (!a->out) return e(\"outofmem\", \"Out of memory\");\n   if (raw_len != (img_n * s->img_x + 1) * s->img_y) return e(\"not enough pixels\",\"Corrupt PNG\");\n   for (j=0; j < s->img_y; ++j) {\n      uint8 *cur = a->out + stride*j;\n      uint8 *prior = cur - stride;\n      int filter = *raw++;\n      if (filter > 4) return e(\"invalid filter\",\"Corrupt PNG\");\n      // if first row, use special filter that doesn't sample previous row\n      if (j == 0) filter = first_row_filter[filter];\n      // handle first pixel explicitly\n      for (k=0; k < img_n; ++k) {\n         switch(filter) {\n            case F_none       : cur[k] = raw[k]; break;\n            case F_sub        : cur[k] = raw[k]; break;\n            case F_up         : cur[k] = raw[k] + prior[k]; break;\n            case F_avg        : cur[k] = raw[k] + (prior[k]>>1); break;\n            case F_paeth      : cur[k] = (uint8) (raw[k] + paeth(0,prior[k],0)); break;\n            case F_avg_first  : cur[k] = raw[k]; break;\n            case F_paeth_first: cur[k] = raw[k]; break;\n         }\n      }\n      if (img_n != out_n) cur[img_n] = 255;\n      raw += img_n;\n      cur += out_n;\n      prior += out_n;\n      // this is a little gross, so that we don't switch per-pixel or per-component\n      if (img_n == out_n) {\n         #define CASE(f) \\\n             case f:     \\\n                for (i=s->img_x-1; i >= 1; --i, raw+=img_n,cur+=img_n,prior+=img_n) \\\n                   for (k=0; k < img_n; ++k)\n         switch(filter) {\n            CASE(F_none)  cur[k] = raw[k]; break;\n            CASE(F_sub)   cur[k] = raw[k] + cur[k-img_n]; break;\n            CASE(F_up)    cur[k] = raw[k] + prior[k]; break;\n            CASE(F_avg)   cur[k] = raw[k] + ((prior[k] + cur[k-img_n])>>1); break;\n            CASE(F_paeth)  cur[k] = (uint8) (raw[k] + paeth(cur[k-img_n],prior[k],prior[k-img_n])); break;\n            CASE(F_avg_first)    cur[k] = raw[k] + (cur[k-img_n] >> 1); break;\n            CASE(F_paeth_first)  cur[k] = (uint8) (raw[k] + paeth(cur[k-img_n],0,0)); break;\n         }\n         #undef CASE\n      } else {\n         assert(img_n+1 == out_n);\n         #define CASE(f) \\\n             case f:     \\\n                for (i=s->img_x-1; i >= 1; --i, cur[img_n]=255,raw+=img_n,cur+=out_n,prior+=out_n) \\\n                   for (k=0; k < img_n; ++k)\n         switch(filter) {\n            CASE(F_none)  cur[k] = raw[k]; break;\n            CASE(F_sub)   cur[k] = raw[k] + cur[k-out_n]; break;\n            CASE(F_up)    cur[k] = raw[k] + prior[k]; break;\n            CASE(F_avg)   cur[k] = raw[k] + ((prior[k] + cur[k-out_n])>>1); break;\n            CASE(F_paeth)  cur[k] = (uint8) (raw[k] + paeth(cur[k-out_n],prior[k],prior[k-out_n])); break;\n            CASE(F_avg_first)    cur[k] = raw[k] + (cur[k-out_n] >> 1); break;\n            CASE(F_paeth_first)  cur[k] = (uint8) (raw[k] + paeth(cur[k-out_n],0,0)); break;\n         }\n         #undef CASE\n      }\n   }\n   return 1;\n}", "path": "src\\SOIL\\stb_image_aug.c", "repo_name": "kosievdmerwe/SMS", "stars": 1, "license": "None", "language": "c", "size": 144}
{"docstring": "// take a -128..127 value and clamp it and convert to 0..255\n", "func_signal": "__forceinline static uint8 clamp(int x)", "code": "{\n   x += 128;\n   // trick to use a single test to catch both cases\n   if ((unsigned int) x > 255) {\n      if (x < 0) return 0;\n      if (x > 255) return 255;\n   }\n   return (uint8) x;\n}", "path": "src\\SOIL\\stb_image_aug.c", "repo_name": "kosievdmerwe/SMS", "stars": 1, "license": "None", "language": "c", "size": 144}
{"docstring": "// these is-hdr-or-not is defined independent of whether STBI_NO_HDR is\n// defined, for API simplicity; if STBI_NO_HDR is defined, it always\n// reports false!\n", "func_signal": "int stbi_is_hdr_from_memory(stbi_uc const *buffer, int len)", "code": "{\n   #ifndef STBI_NO_HDR\n   return stbi_hdr_test_memory(buffer, len);\n   #else\n   return 0;\n   #endif\n}", "path": "src\\SOIL\\stb_image_aug.c", "repo_name": "kosievdmerwe/SMS", "stars": 1, "license": "None", "language": "c", "size": 144}
{"docstring": "/********* Actual Exposed Functions *********/\n", "func_signal": "int\n\tsave_image_as_DDS\n\t(\n\t\tconst char *filename,\n\t\tint width, int height, int channels,\n\t\tconst unsigned char *const data\n\t)", "code": "{\n\t/*\tvariables\t*/\n\tFILE *fout;\n\tunsigned char *DDS_data;\n\tDDS_header header;\n\tint DDS_size;\n\t/*\terror check\t*/\n\tif( (NULL == filename) ||\n\t\t(width < 1) || (height < 1) ||\n\t\t(channels < 1) || (channels > 4) ||\n\t\t(data == NULL ) )\n\t{\n\t\treturn 0;\n\t}\n\t/*\tConvert the image\t*/\n\tif( (channels & 1) == 1 )\n\t{\n\t\t/*\tno alpha, just use DXT1\t*/\n\t\tDDS_data = convert_image_to_DXT1( data, width, height, channels, &DDS_size );\n\t} else\n\t{\n\t\t/*\thas alpha, so use DXT5\t*/\n\t\tDDS_data = convert_image_to_DXT5( data, width, height, channels, &DDS_size );\n\t}\n\t/*\tsave it\t*/\n\tmemset( &header, 0, sizeof( DDS_header ) );\n\theader.dwMagic = ('D' << 0) | ('D' << 8) | ('S' << 16) | (' ' << 24);\n\theader.dwSize = 124;\n\theader.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT | DDSD_LINEARSIZE;\n\theader.dwWidth = width;\n\theader.dwHeight = height;\n\theader.dwPitchOrLinearSize = DDS_size;\n\theader.sPixelFormat.dwSize = 32;\n\theader.sPixelFormat.dwFlags = DDPF_FOURCC;\n\tif( (channels & 1) == 1 )\n\t{\n\t\theader.sPixelFormat.dwFourCC = ('D' << 0) | ('X' << 8) | ('T' << 16) | ('1' << 24);\n\t} else\n\t{\n\t\theader.sPixelFormat.dwFourCC = ('D' << 0) | ('X' << 8) | ('T' << 16) | ('5' << 24);\n\t}\n\theader.sCaps.dwCaps1 = DDSCAPS_TEXTURE;\n\t/*\twrite it out\t*/\n\tfout = fopen( filename, \"wb\");\n\tfwrite( &header, sizeof( DDS_header ), 1, fout );\n\tfwrite( DDS_data, 1, DDS_size, fout );\n\tfclose( fout );\n\t/*\tdone\t*/\n\tfree( DDS_data );\n\treturn 1;\n}", "path": "src\\SOIL\\image_DXT.c", "repo_name": "kosievdmerwe/SMS", "stars": 1, "license": "None", "language": "c", "size": 144}
{"docstring": "// decode one 64-entry block--\n", "func_signal": "static int decode_block(jpeg *j, short data[64], huffman *hdc, huffman *hac, int b)", "code": "{\n   int diff,dc,k;\n   int t = decode(j, hdc);\n   if (t < 0) return e(\"bad huffman code\",\"Corrupt JPEG\");\n\n   // 0 all the ac values now so we can do it 32-bits at a time\n   memset(data,0,64*sizeof(data[0]));\n\n   diff = t ? extend_receive(j, t) : 0;\n   dc = j->img_comp[b].dc_pred + diff;\n   j->img_comp[b].dc_pred = dc;\n   data[0] = (short) dc;\n\n   // decode AC components, see JPEG spec\n   k = 1;\n   do {\n      int r,s;\n      int rs = decode(j, hac);\n      if (rs < 0) return e(\"bad huffman code\",\"Corrupt JPEG\");\n      s = rs & 15;\n      r = rs >> 4;\n      if (s == 0) {\n         if (rs != 0xf0) break; // end block\n         k += 16;\n      } else {\n         k += r;\n         // decode into unzigzag'd location\n         data[dezigzag[k++]] = (short) extend_receive(j,s);\n      }\n   } while (k < 64);\n   return 1;\n}", "path": "src\\SOIL\\stb_image_aug.c", "repo_name": "kosievdmerwe/SMS", "stars": 1, "license": "None", "language": "c", "size": 144}
{"docstring": "// Microsoft/Windows BMP image\n", "func_signal": "static int bmp_test(stbi *s)", "code": "{\n   int sz;\n   if (get8(s) != 'B') return 0;\n   if (get8(s) != 'M') return 0;\n   get32le(s); // discard filesize\n   get16le(s); // discard reserved\n   get16le(s); // discard reserved\n   get32le(s); // discard data offset\n   sz = get32le(s);\n   if (sz == 12 || sz == 40 || sz == 56 || sz == 108) return 1;\n   return 0;\n}", "path": "src\\SOIL\\stb_image_aug.c", "repo_name": "kosievdmerwe/SMS", "stars": 1, "license": "None", "language": "c", "size": 144}
{"docstring": "// combined JPEG 'receive' and JPEG 'extend', since baseline\n// always extends everything it receives.\n", "func_signal": "__forceinline static int extend_receive(jpeg *j, int n)", "code": "{\n   unsigned int m = 1 << (n-1);\n   unsigned int k;\n   if (j->code_bits < n) grow_buffer_unsafe(j);\n   k = (j->code_buffer >> (j->code_bits - n)) & bmask[n];\n   j->code_bits -= n;\n   // the following test is probably a random branch that won't\n   // predict well. I tried to table accelerate it but failed.\n   // maybe it's compiling as a conditional move?\n   if (k < m)\n      return (-1 << n) + k + 1;\n   else\n      return k;\n}", "path": "src\\SOIL\\stb_image_aug.c", "repo_name": "kosievdmerwe/SMS", "stars": 1, "license": "None", "language": "c", "size": 144}
{"docstring": "// Targa Truevision - TGA\n// by Jonathan Dummer\n", "func_signal": "static int tga_test(stbi *s)", "code": "{\n\tint sz;\n\tget8u(s);\t\t//\tdiscard Offset\n\tsz = get8u(s);\t//\tcolor type\n\tif( sz > 1 ) return 0;\t//\tonly RGB or indexed allowed\n\tsz = get8u(s);\t//\timage type\n\tif( (sz != 1) && (sz != 2) && (sz != 3) && (sz != 9) && (sz != 10) && (sz != 11) ) return 0;\t//\tonly RGB or grey allowed, +/- RLE\n\tget16(s);\t\t//\tdiscard palette start\n\tget16(s);\t\t//\tdiscard palette length\n\tget8(s);\t\t\t//\tdiscard bits per palette color entry\n\tget16(s);\t\t//\tdiscard x origin\n\tget16(s);\t\t//\tdiscard y origin\n\tif( get16(s) < 1 ) return 0;\t\t//\ttest width\n\tif( get16(s) < 1 ) return 0;\t\t//\ttest height\n\tsz = get8(s);\t//\tbits per pixel\n\tif( (sz != 8) && (sz != 16) && (sz != 24) && (sz != 32) ) return 0;\t//\tonly RGB or RGBA or grey allowed\n\treturn 1;\t\t//\tseems to have passed everything\n}", "path": "src\\SOIL\\stb_image_aug.c", "repo_name": "kosievdmerwe/SMS", "stars": 1, "license": "None", "language": "c", "size": 144}
{"docstring": "/*\n\tThis function takes the YCoCg components of the image\n\tand converts them into RGB.  See above.\n*/\n", "func_signal": "int\n\tconvert_YCoCg_to_RGB\n\t(\n\t\tunsigned char* orig,\n\t\tint width, int height, int channels\n\t)", "code": "{\n\tint i;\n\t/*\terror check\t*/\n\tif( (width < 1) || (height < 1) ||\n\t\t(channels < 3) || (channels > 4) ||\n\t\t(orig == NULL) )\n\t{\n\t\t/*\tnothing to do\t*/\n\t\treturn -1;\n\t}\n\t/*\tdo the conversion\t*/\n\tif( channels == 3 )\n\t{\n\t\tfor( i = 0; i < width*height*3; i += 3 )\n\t\t{\n\t\t\tint co = orig[i+0] - 128;\n\t\t\tint y  = orig[i+1];\n\t\t\tint cg = orig[i+2] - 128;\n\t\t\t/*\tR\t*/\n\t\t\torig[i+0] = clamp_byte( y + co - cg );\n\t\t\t/*\tG\t*/\n\t\t\torig[i+1] = clamp_byte( y + cg );\n\t\t\t/*\tB\t*/\n\t\t\torig[i+2] = clamp_byte( y - co - cg );\n\t\t}\n\t} else\n\t{\n\t\tfor( i = 0; i < width*height*4; i += 4 )\n\t\t{\n\t\t\tint co = orig[i+0] - 128;\n\t\t\tint cg = orig[i+1] - 128;\n\t\t\tunsigned char a  = orig[i+2];\n\t\t\tint y  = orig[i+3];\n\t\t\t/*\tR\t*/\n\t\t\torig[i+0] = clamp_byte( y + co - cg );\n\t\t\t/*\tG\t*/\n\t\t\torig[i+1] = clamp_byte( y + cg );\n\t\t\t/*\tB\t*/\n\t\t\torig[i+2] = clamp_byte( y - co - cg );\n\t\t\t/*\tA\t*/\n\t\t\torig[i+3] = a;\n\t\t}\n\t}\n\t/*\tdone\t*/\n\treturn 0;\n}", "path": "src\\SOIL\\image_helper.c", "repo_name": "kosievdmerwe/SMS", "stars": 1, "license": "None", "language": "c", "size": 144}
{"docstring": "// after we see SOS\n", "func_signal": "static int process_scan_header(jpeg *z)", "code": "{\n   int i;\n   int Ls = get16(&z->s);\n   z->scan_n = get8(&z->s);\n   if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s.img_n) return e(\"bad SOS component count\",\"Corrupt JPEG\");\n   if (Ls != 6+2*z->scan_n) return e(\"bad SOS len\",\"Corrupt JPEG\");\n   for (i=0; i < z->scan_n; ++i) {\n      int id = get8(&z->s), which;\n      int q = get8(&z->s);\n      for (which = 0; which < z->s.img_n; ++which)\n         if (z->img_comp[which].id == id)\n            break;\n      if (which == z->s.img_n) return 0;\n      z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return e(\"bad DC huff\",\"Corrupt JPEG\");\n      z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return e(\"bad AC huff\",\"Corrupt JPEG\");\n      z->order[i] = which;\n   }\n   if (get8(&z->s) != 0) return e(\"bad SOS\",\"Corrupt JPEG\");\n   get8(&z->s); // should be 63, but might be 0\n   if (get8(&z->s) != 0) return e(\"bad SOS\",\"Corrupt JPEG\");\n\n   return 1;\n}", "path": "src\\SOIL\\stb_image_aug.c", "repo_name": "kosievdmerwe/SMS", "stars": 1, "license": "None", "language": "c", "size": 144}
{"docstring": "// returns 0..31 for the highest set bit\n", "func_signal": "static int high_bit(unsigned int z)", "code": "{\n   int n=0;\n   if (z == 0) return -1;\n   if (z >= 0x10000) n += 16, z >>= 16;\n   if (z >= 0x00100) n +=  8, z >>=  8;\n   if (z >= 0x00010) n +=  4, z >>=  4;\n   if (z >= 0x00004) n +=  2, z >>=  2;\n   if (z >= 0x00002) n +=  1, z >>=  1;\n   return n;\n}", "path": "src\\SOIL\\stb_image_aug.c", "repo_name": "kosievdmerwe/SMS", "stars": 1, "license": "None", "language": "c", "size": 144}
{"docstring": "// *************************************************************************************************\n// Photoshop PSD loader -- PD by Thatcher Ulrich, integration by Nicholas Schulz, tweaked by STB\n", "func_signal": "static int psd_test(stbi *s)", "code": "{\n\tif (get32(s) != 0x38425053) return 0;\t// \"8BPS\"\n\telse return 1;\n}", "path": "src\\SOIL\\stb_image_aug.c", "repo_name": "kosievdmerwe/SMS", "stars": 1, "license": "None", "language": "c", "size": 144}
{"docstring": "// if there's a pending marker from the entropy stream, return that\n// otherwise, fetch from the stream and get a marker. if there's no\n// marker, return 0xff, which is never a valid marker value\n", "func_signal": "static uint8 get_marker(jpeg *j)", "code": "{\n   uint8 x;\n   if (j->marker != MARKER_none) { x = j->marker; j->marker = MARKER_none; return x; }\n   x = get8u(&j->s);\n   if (x != 0xff) return MARKER_none;\n   while (x == 0xff)\n      x = get8u(&j->s);\n   return x;\n}", "path": "src\\SOIL\\stb_image_aug.c", "repo_name": "kosievdmerwe/SMS", "stars": 1, "license": "None", "language": "c", "size": 144}
{"docstring": "// after a restart interval, reset the entropy decoder and\n// the dc prediction\n", "func_signal": "static void reset(jpeg *j)", "code": "{\n   j->code_bits = 0;\n   j->code_buffer = 0;\n   j->nomore = 0;\n   j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = 0;\n   j->marker = MARKER_none;\n   j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;\n   // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,\n   // since we don't even allow 1<<30 pixels\n}", "path": "src\\SOIL\\stb_image_aug.c", "repo_name": "kosievdmerwe/SMS", "stars": 1, "license": "None", "language": "c", "size": 144}
{"docstring": "/********* Helper Functions *********/\n", "func_signal": "int convert_bit_range( int c, int from_bits, int to_bits )", "code": "{\n\tint b = (1 << (from_bits - 1)) + c * ((1 << to_bits) - 1);\n\treturn (b + (b >> from_bits)) >> from_bits;\n}", "path": "src\\SOIL\\image_DXT.c", "repo_name": "kosievdmerwe/SMS", "stars": 1, "license": "None", "language": "c", "size": 144}
{"docstring": "// .344 seconds on 3*anemones.jpg\n", "func_signal": "static void idct_block(uint8 *out, int out_stride, short data[64], uint8 *dequantize)", "code": "{\n   int i,val[64],*v=val;\n   uint8 *o,*dq = dequantize;\n   short *d = data;\n\n   // columns\n   for (i=0; i < 8; ++i,++d,++dq, ++v) {\n      // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing\n      if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0\n           && d[40]==0 && d[48]==0 && d[56]==0) {\n         //    no shortcut                 0     seconds\n         //    (1|2|3|4|5|6|7)==0          0     seconds\n         //    all separate               -0.047 seconds\n         //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds\n         int dcterm = d[0] * dq[0] << 2;\n         v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;\n      } else {\n         IDCT_1D(d[ 0]*dq[ 0],d[ 8]*dq[ 8],d[16]*dq[16],d[24]*dq[24],\n                 d[32]*dq[32],d[40]*dq[40],d[48]*dq[48],d[56]*dq[56])\n         // constants scaled things up by 1<<12; let's bring them back\n         // down, but keep 2 extra bits of precision\n         x0 += 512; x1 += 512; x2 += 512; x3 += 512;\n         v[ 0] = (x0+t3) >> 10;\n         v[56] = (x0-t3) >> 10;\n         v[ 8] = (x1+t2) >> 10;\n         v[48] = (x1-t2) >> 10;\n         v[16] = (x2+t1) >> 10;\n         v[40] = (x2-t1) >> 10;\n         v[24] = (x3+t0) >> 10;\n         v[32] = (x3-t0) >> 10;\n      }\n   }\n\n   for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {\n      // no fast case since the first 1D IDCT spread components out\n      IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])\n      // constants scaled things up by 1<<12, plus we had 1<<2 from first\n      // loop, plus horizontal and vertical each scale by sqrt(8) so together\n      // we've got an extra 1<<3, so 1<<17 total we need to remove.\n      x0 += 65536; x1 += 65536; x2 += 65536; x3 += 65536;\n      o[0] = clamp((x0+t3) >> 17);\n      o[7] = clamp((x0-t3) >> 17);\n      o[1] = clamp((x1+t2) >> 17);\n      o[6] = clamp((x1-t2) >> 17);\n      o[2] = clamp((x2+t1) >> 17);\n      o[5] = clamp((x2-t1) >> 17);\n      o[3] = clamp((x3+t0) >> 17);\n      o[4] = clamp((x3-t0) >> 17);\n   }\n}", "path": "src\\SOIL\\stb_image_aug.c", "repo_name": "kosievdmerwe/SMS", "stars": 1, "license": "None", "language": "c", "size": 144}
{"docstring": "// 0.38 seconds on 3*anemones.jpg   (0.25 with processor = Pro)\n// VC6 without processor=Pro is generating multiple LEAs per multiply!\n", "func_signal": "static void YCbCr_to_RGB_row(uint8 *out, uint8 *y, uint8 *pcb, uint8 *pcr, int count, int step)", "code": "{\n   int i;\n   for (i=0; i < count; ++i) {\n      int y_fixed = (y[i] << 16) + 32768; // rounding\n      int r,g,b;\n      int cr = pcr[i] - 128;\n      int cb = pcb[i] - 128;\n      r = y_fixed + cr*float2fixed(1.40200f);\n      g = y_fixed - cr*float2fixed(0.71414f) - cb*float2fixed(0.34414f);\n      b = y_fixed                            + cb*float2fixed(1.77200f);\n      r >>= 16;\n      g >>= 16;\n      b >>= 16;\n      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }\n      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }\n      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }\n      out[0] = (uint8)r;\n      out[1] = (uint8)g;\n      out[2] = (uint8)b;\n      out[3] = 255;\n      out += step;\n   }\n}", "path": "src\\SOIL\\stb_image_aug.c", "repo_name": "kosievdmerwe/SMS", "stars": 1, "license": "None", "language": "c", "size": 144}
{"docstring": "// clean up the temporary component buffers\n", "func_signal": "static void cleanup_jpeg(jpeg *j)", "code": "{\n   int i;\n   for (i=0; i < j->s.img_n; ++i) {\n      if (j->img_comp[i].data) {\n         free(j->img_comp[i].raw_data);\n         j->img_comp[i].data = NULL;\n      }\n      if (j->img_comp[i].linebuf) {\n         free(j->img_comp[i].linebuf);\n         j->img_comp[i].linebuf = NULL;\n      }\n   }\n}", "path": "src\\SOIL\\stb_image_aug.c", "repo_name": "kosievdmerwe/SMS", "stars": 1, "license": "None", "language": "c", "size": 144}
{"docstring": "/*\tUpscaling the image uses simple bilinear interpolation\t*/\n", "func_signal": "int\n\tup_scale_image\n\t(\n\t\tconst unsigned char* const orig,\n\t\tint width, int height, int channels,\n\t\tunsigned char* resampled,\n\t\tint resampled_width, int resampled_height\n\t)", "code": "{\n\tfloat dx, dy;\n\tint x, y, c;\n\n    /* error(s) check\t*/\n    if ( \t(width < 1) || (height < 1) ||\n            (resampled_width < 2) || (resampled_height < 2) ||\n            (channels < 1) ||\n            (NULL == orig) || (NULL == resampled) )\n    {\n        /*\tsignify badness\t*/\n        return 0;\n    }\n    /*\n\t\tfor each given pixel in the new map, find the exact location\n\t\tfrom the original map which would contribute to this guy\n\t*/\n    dx = (width - 1.0f) / (resampled_width - 1.0f);\n    dy = (height - 1.0f) / (resampled_height - 1.0f);\n    for ( y = 0; y < resampled_height; ++y )\n    {\n    \t/* find the base y index and fractional offset from that\t*/\n    \tfloat sampley = y * dy;\n    \tint inty = (int)sampley;\n    \t/*\tif( inty < 0 ) { inty = 0; } else\t*/\n\t\tif( inty > height - 2 ) { inty = height - 2; }\n\t\tsampley -= inty;\n        for ( x = 0; x < resampled_width; ++x )\n        {\n\t\t\tfloat samplex = x * dx;\n\t\t\tint intx = (int)samplex;\n\t\t\tint base_index;\n\t\t\t/* find the base x index and fractional offset from that\t*/\n\t\t\t/*\tif( intx < 0 ) { intx = 0; } else\t*/\n\t\t\tif( intx > width - 2 ) { intx = width - 2; }\n\t\t\tsamplex -= intx;\n\t\t\t/*\tbase index into the original image\t*/\n\t\t\tbase_index = (inty * width + intx) * channels;\n            for ( c = 0; c < channels; ++c )\n            {\n            \t/*\tdo the sampling\t*/\n\t\t\t\tfloat value = 0.5f;\n\t\t\t\tvalue += orig[base_index]\n\t\t\t\t\t\t\t*(1.0f-samplex)*(1.0f-sampley);\n\t\t\t\tvalue += orig[base_index+channels]\n\t\t\t\t\t\t\t*(samplex)*(1.0f-sampley);\n\t\t\t\tvalue += orig[base_index+width*channels]\n\t\t\t\t\t\t\t*(1.0f-samplex)*(sampley);\n\t\t\t\tvalue += orig[base_index+width*channels+channels]\n\t\t\t\t\t\t\t*(samplex)*(sampley);\n\t\t\t\t/*\tmove to the next channel\t*/\n\t\t\t\t++base_index;\n            \t/*\tsave the new value\t*/\n            \tresampled[y*resampled_width*channels+x*channels+c] =\n\t\t\t\t\t\t(unsigned char)(value);\n            }\n        }\n    }\n    /*\tdone\t*/\n    return 1;\n}", "path": "src\\SOIL\\image_helper.c", "repo_name": "kosievdmerwe/SMS", "stars": 1, "license": "None", "language": "c", "size": 144}
{"docstring": "/* \n * Function twi_init\n * Desc     readys twi pins and sets twi bitrate\n * Input    none\n * Output   none\n */\n", "func_signal": "void twi_init(void)", "code": "{\n  // initialize state\n  twi_state = TWI_READY;\n\n  #if defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) || defined(__AVR_ATmega328P__)\n    // activate internal pull-ups for twi\n    // as per note from atmega8 manual pg167\n    sbi(PORTC, 4);\n    sbi(PORTC, 5);\n  #else\n    // activate internal pull-ups for twi\n    // as per note from atmega128 manual pg204\n    sbi(PORTD, 0);\n    sbi(PORTD, 1);\n  #endif\n\n  // initialize twi prescaler and bit rate\n  cbi(TWSR, TWPS0);\n  cbi(TWSR, TWPS1);\n  TWBR = ((CPU_FREQ / TWI_FREQ) - 16) / 2;\n\n  /* twi bit rate formula from atmega128 manual pg 204\n  SCL Frequency = CPU Clock Frequency / (16 + (2 * TWBR))\n  note: TWBR should be 10 or higher for master mode\n  It is 72 for a 16mhz Wiring board with 100kHz TWI */\n\n  // enable twi module, acks, and twi interrupt\n  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA);\n\t\n  // allocate buffers\n  twi_masterBuffer = (uint8_t*) calloc(TWI_BUFFER_LENGTH, sizeof(uint8_t));\n  twi_txBuffer = (uint8_t*) calloc(TWI_BUFFER_LENGTH, sizeof(uint8_t));\n  twi_rxBuffer = (uint8_t*) calloc(TWI_BUFFER_LENGTH, sizeof(uint8_t));\n}", "path": "src\\skeleton\\hardware\\libraries\\Wire\\utility\\twi.c", "repo_name": "frickel/shellduino", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 540}
{"docstring": "/**\n@brief\t get socket RX recv buf size\n\nThis gives size of received data in receive buffer. \n*/\n", "func_signal": "uint16 getSn_RX_RSR(SOCKET s)", "code": "{\n\tuint16 val=0,val1=0;\n\tdo\n\t{\n\t\tval1 = IINCHIP_READ(Sn_RX_RSR0(s));\n\t\tval1 = (val1 << 8) + IINCHIP_READ(Sn_RX_RSR0(s) + 1);\n      if(val1 != 0)\n\t\t{\n   \t\t\tval = IINCHIP_READ(Sn_RX_RSR0(s));\n   \t\t\tval = (val << 8) + IINCHIP_READ(Sn_RX_RSR0(s) + 1);\n\t\t}\n\t} while (val != val1);\n   return val;\n}", "path": "src\\skeleton\\hardware\\libraries\\Ethernet\\utility\\w5100.c", "repo_name": "frickel/shellduino", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 540}
{"docstring": "/* \n * Function twi_stop\n * Desc     relinquishes bus master status\n * Input    none\n * Output   none\n */\n", "func_signal": "void twi_stop(void)", "code": "{\n  // send stop condition\n  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTO);\n\n  // wait for stop condition to be exectued on bus\n  // TWINT is not set after a stop condition!\n  while(TWCR & _BV(TWSTO)){\n    continue;\n  }\n\n  // update twi state\n  twi_state = TWI_READY;\n}", "path": "src\\skeleton\\hardware\\libraries\\Wire\\utility\\twi.c", "repo_name": "frickel/shellduino", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 540}
{"docstring": "/* \n * Function twi_transmit\n * Desc     fills slave tx buffer with data\n *          must be called in slave tx event callback\n * Input    data: pointer to byte array\n *          length: number of bytes in array\n * Output   1 length too long for buffer\n *          2 not slave transmitter\n *          0 ok\n */\n", "func_signal": "uint8_t twi_transmit(uint8_t* data, uint8_t length)", "code": "{\n  uint8_t i;\n\n  // ensure data will fit into buffer\n  if(TWI_BUFFER_LENGTH < length){\n    return 1;\n  }\n  \n  // ensure we are currently a slave transmitter\n  if(TWI_STX != twi_state){\n    return 2;\n  }\n  \n  // set length and copy data into tx buffer\n  twi_txBufferLength = length;\n  for(i = 0; i < length; ++i){\n    twi_txBuffer[i] = data[i];\n  }\n  \n  return 0;\n}", "path": "src\\skeleton\\hardware\\libraries\\Wire\\utility\\twi.c", "repo_name": "frickel/shellduino", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 540}
{"docstring": "/**\n@brief\tThese below functions are used to get the Gateway, SubnetMask\n\t\tand Source Hardware Address (MAC Address) and Source IP address\n*/\n", "func_signal": "void getGAR(uint8 * addr)", "code": "{\n\taddr[0] = IINCHIP_READ(GAR0);\n\taddr[1] = IINCHIP_READ(GAR0+1);\n\taddr[2] = IINCHIP_READ(GAR0+2);\n\taddr[3] = IINCHIP_READ(GAR0+3);\n}", "path": "src\\skeleton\\hardware\\libraries\\Ethernet\\utility\\w5100.c", "repo_name": "frickel/shellduino", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 540}
{"docstring": "/**\n@brief\tget socket TX free buf size\n\nThis gives free buffer size of transmit buffer. This is the data size that user can transmit.\nUser shuold check this value first and control the size of transmitting data\n*/\n", "func_signal": "uint16 getSn_TX_FSR(SOCKET s)", "code": "{\n\tuint16 val=0,val1=0;\n\tdo\n\t{\n\t\tval1 = IINCHIP_READ(Sn_TX_FSR0(s));\n\t\tval1 = (val1 << 8) + IINCHIP_READ(Sn_TX_FSR0(s) + 1);\n      if (val1 != 0)\n\t\t{\n   \t\t\tval = IINCHIP_READ(Sn_TX_FSR0(s));\n   \t\t\tval = (val << 8) + IINCHIP_READ(Sn_TX_FSR0(s) + 1);\n\t\t}\n\t} while (val != val1);\n   return val;\n}", "path": "src\\skeleton\\hardware\\libraries\\Ethernet\\utility\\w5100.c", "repo_name": "frickel/shellduino", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 540}
{"docstring": "/**\n@brief\tThis function reads the value from W5100 registers.\n*/\n", "func_signal": "uint8 IINCHIP_READ(uint16 addr)", "code": "{\n\tuint8 data;\n\n// DIRECT MODE I/F\n\n#if (__DEF_IINCHIP_BUS__ == __DEF_IINCHIP_DIRECT_MODE__)\n\tIINCHIP_ISR_DISABLE();\n\tdata = *((vuint8*)(addr));\n\tIINCHIP_ISR_ENABLE();\n#elif(__DEF_IINCHIP_BUS__ == __DEF_IINCHIP_INDIRECT_MODE__)   \n\t   IINCHIP_ISR_DISABLE();\n\t   *((vuint8*)IDM_AR0) = (uint8)((addr & 0xFF00) >> 8);\n\t   *((vuint8*)IDM_AR1) = (uint8)(addr & 0x00FF);\n\t   data = *((vuint8*)IDM_DR);\n\t   IINCHIP_ISR_ENABLE();\n   \n#elif (__DEF_IINCHIP_BUS__ == __DEF_IINCHIP_SPI_MODE__)\n\t   IINCHIP_ISR_DISABLE();\n\tIINCHIP_SpiInit();\t\n\tIINCHIP_CSoff();                             // CS=0, SPI start\n\n\tIINCHIP_SpiSendData(0x0F);\n\tIINCHIP_SpiSendData((addr & 0xFF00) >> 8);\n\tIINCHIP_SpiSendData(addr & 0x00FF);\n\t\n\t\n\tIINCHIP_SpiSendData(0);\n\tdata = IINCHIP_SpiRecvData();\n\n\tIINCHIP_CSon();                          \t// SPI end\n\t   IINCHIP_ISR_ENABLE();\n#else\n\t#error \"unknown bus type\"\n#endif\n\treturn data;\n}", "path": "src\\skeleton\\hardware\\libraries\\Ethernet\\utility\\w5100.c", "repo_name": "frickel/shellduino", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 540}
{"docstring": "/**\n@brief\tThis function sets up Retransmission time.\n\nIf there is no response from the peer or delay in response then retransmission \nwill be there as per RTR (Retry Time-value Register)setting\n*/\n", "func_signal": "void setRTR(uint16 timeout)", "code": "{\n\tIINCHIP_WRITE(RTR0,(uint8)((timeout & 0xff00) >> 8));\n\tIINCHIP_WRITE((RTR0 + 1),(uint8)(timeout & 0x00ff));\n}", "path": "src\\skeleton\\hardware\\libraries\\Ethernet\\utility\\w5100.c", "repo_name": "frickel/shellduino", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 540}
{"docstring": "/* Delay for the given number of microseconds.  Assumes a 8 or 16 MHz clock. \n * Disables interrupts, which will disrupt the millis() function if used\n * too frequently. */\n", "func_signal": "void delayMicroseconds(unsigned int us)", "code": "{\n\tuint8_t oldSREG;\n\n\t// calling avrlib's delay_us() function with low values (e.g. 1 or\n\t// 2 microseconds) gives delays longer than desired.\n\t//delay_us(us);\n\n#if F_CPU >= 16000000L\n\t// for the 16 MHz clock on most Arduino boards\n\n\t// for a one-microsecond delay, simply return.  the overhead\n\t// of the function call yields a delay of approximately 1 1/8 us.\n\tif (--us == 0)\n\t\treturn;\n\n\t// the following loop takes a quarter of a microsecond (4 cycles)\n\t// per iteration, so execute it four times for each microsecond of\n\t// delay requested.\n\tus <<= 2;\n\n\t// account for the time taken in the preceeding commands.\n\tus -= 2;\n#else\n\t// for the 8 MHz internal clock on the ATmega168\n\n\t// for a one- or two-microsecond delay, simply return.  the overhead of\n\t// the function calls takes more than two microseconds.  can't just\n\t// subtract two, since us is unsigned; we'd overflow.\n\tif (--us == 0)\n\t\treturn;\n\tif (--us == 0)\n\t\treturn;\n\n\t// the following loop takes half of a microsecond (4 cycles)\n\t// per iteration, so execute it twice for each microsecond of\n\t// delay requested.\n\tus <<= 1;\n    \n\t// partially compensate for the time taken by the preceeding commands.\n\t// we can't subtract any more than this or we'd overflow w/ small delays.\n\tus--;\n#endif\n\n\t// disable interrupts, otherwise the timer 0 overflow interrupt that\n\t// tracks milliseconds will make us delay longer than we want.\n\toldSREG = SREG;\n\tcli();\n\n\t// busy wait\n\t__asm__ __volatile__ (\n\t\t\"1: sbiw %0,1\" \"\\n\\t\" // 2 cycles\n\t\t\"brne 1b\" : \"=w\" (us) : \"0\" (us) // 2 cycles\n\t);\n\n\t// reenable interrupts.\n\tSREG = oldSREG;\n}", "path": "src\\skeleton\\hardware\\cores\\arduino\\wiring.c", "repo_name": "frickel/shellduino", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 540}
{"docstring": "/**\n@brief\tThis function is being used for copy the data form Receive buffer of the chip to application buffer.\n\nIt calculate the actual physical address where one has to read\nthe data from Receive buffer. Here also take care of the condition while it exceed\nthe Rx memory uper-bound of socket.\n*/\n", "func_signal": "void read_data(SOCKET s, vuint8 * src, vuint8 * dst, uint16 len)", "code": "{\n\tuint16 size;\n\tuint16 src_mask;\n\tuint8 * src_ptr;\n\n\tsrc_mask = (uint16)src & getIINCHIP_RxMASK(s);\n\tsrc_ptr = (uint8 *)(getIINCHIP_RxBASE(s) + src_mask);\n\t\n\tif( (src_mask + len) > getIINCHIP_RxMAX(s) ) \n\t{\n\t\tsize = getIINCHIP_RxMAX(s) - src_mask;\n\t\twiz_read_buf((uint16)src_ptr, (uint8*)dst,size);\n\t\tdst += size;\n\t\tsize = len - size;\n\t\tsrc_ptr = (uint8 *)(getIINCHIP_RxBASE(s));\n\t\twiz_read_buf((uint16)src_ptr, (uint8*) dst,size);\n\t} \n\telse\n\t{\n\t\twiz_read_buf((uint16)src_ptr, (uint8*) dst,len);\n\t}\n}", "path": "src\\skeleton\\hardware\\libraries\\Ethernet\\utility\\w5100.c", "repo_name": "frickel/shellduino", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 540}
{"docstring": "/* \n * Function twi_reply\n * Desc     sends byte or readys receive line\n * Input    ack: byte indicating to ack or to nack\n * Output   none\n */\n", "func_signal": "void twi_reply(uint8_t ack)", "code": "{\n  // transmit master read ready signal, with or without ack\n  if(ack){\n    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);\n  }else{\n\t  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);\n  }\n}", "path": "src\\skeleton\\hardware\\libraries\\Wire\\utility\\twi.c", "repo_name": "frickel/shellduino", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 540}
{"docstring": "/**\n@brief\tThese below functions are used to get the Destination Hardware Address (MAC Address), Destination IP address and Destination Port.\n*/\n", "func_signal": "void getSn_DHAR(SOCKET s, uint8 * addr)", "code": "{\n\taddr[0] = IINCHIP_READ(Sn_DHAR0(s));\n\taddr[1] = IINCHIP_READ(Sn_DHAR0(s)+1);\n\taddr[2] = IINCHIP_READ(Sn_DHAR0(s)+2);\n\taddr[3] = IINCHIP_READ(Sn_DHAR0(s)+3);\n\taddr[4] = IINCHIP_READ(Sn_DHAR0(s)+4);\n\taddr[5] = IINCHIP_READ(Sn_DHAR0(s)+5);\n}", "path": "src\\skeleton\\hardware\\libraries\\Ethernet\\utility\\w5100.c", "repo_name": "frickel/shellduino", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 540}
{"docstring": "/**\n@brief\tThis function writes the data into W5100 registers.\n*/\n", "func_signal": "uint8 IINCHIP_WRITE(uint16 addr,uint8 data)", "code": "{\n// DIRECT MODE I/F\n#if (__DEF_IINCHIP_BUS__ == __DEF_IINCHIP_DIRECT_MODE__)\n\tIINCHIP_ISR_DISABLE();\n\t*((vuint8*)(addr)) = data;\n\tIINCHIP_ISR_ENABLE();\n#elif(__DEF_IINCHIP_BUS__ == __DEF_IINCHIP_INDIRECT_MODE__)\t/* INDIRECT MODE I/F */\n\t   IINCHIP_ISR_DISABLE();\n\t   *((vuint8*)IDM_AR0) = (uint8)((addr & 0xFF00) >> 8);\n\t   *((vuint8*)IDM_AR1) = (uint8)(addr & 0x00FF);\n\t   *((vuint8*)IDM_DR)  = data;\n\t   IINCHIP_ISR_ENABLE();\n#elif (__DEF_IINCHIP_BUS__ == __DEF_IINCHIP_SPI_MODE__)\n\t   IINCHIP_ISR_DISABLE();\n\tIINCHIP_SpiInit();\n\t\n\t//SPI MODE I/F\n\tIINCHIP_CSoff();                             // CS=0, SPI start\n\n\tIINCHIP_SpiSendData(0xF0);\n\tIINCHIP_SpiSendData((addr & 0xFF00) >> 8);\n\tIINCHIP_SpiSendData(addr & 0x00FF);\n\tIINCHIP_SpiSendData(data);\n\n\tIINCHIP_CSon();    \n\n\t   IINCHIP_ISR_ENABLE();   \n#else\n\t#error \"unknown bus type\"\n#endif\n\treturn 1;\n}", "path": "src\\skeleton\\hardware\\libraries\\Ethernet\\utility\\w5100.c", "repo_name": "frickel/shellduino", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 540}
{"docstring": "/**\n@brief\tThis function is being called by recv() also.\n\nThis function read the Rx read pointer register\nand after copy the data from receive buffer update the Rx write pointer register.\nUser should read upper byte first and lower byte later to get proper value.\n*/\n", "func_signal": "void recv_data_processing(SOCKET s, uint8 *data, uint16 len)", "code": "{\n\tuint16 ptr;\n\tptr = IINCHIP_READ(Sn_RX_RD0(s));\n\tptr = ((ptr & 0x00ff) << 8) + IINCHIP_READ(Sn_RX_RD0(s) + 1);\n#ifdef __DEF_IINCHIP_DBG__\n\tprintf(\"ISR_RX: rd_ptr : %.4x\\r\\n\", ptr);\n#endif\n\tread_data(s, (uint8 *)ptr, data, len); // read data\n\tptr += len;\n\tIINCHIP_WRITE(Sn_RX_RD0(s),(uint8)((ptr & 0xff00) >> 8));\n\tIINCHIP_WRITE((Sn_RX_RD0(s) + 1),(uint8)(ptr & 0x00ff));\n}", "path": "src\\skeleton\\hardware\\libraries\\Ethernet\\utility\\w5100.c", "repo_name": "frickel/shellduino", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 540}
{"docstring": "/**\n@brief\tfor copy the data form application buffer to Transmite buffer of the chip.\n\nThis function is being used for copy the data form application buffer to Transmite\nbuffer of the chip. It calculate the actual physical address where one has to write\nthe data in transmite buffer. Here also take care of the condition while it exceed\nthe Tx memory uper-bound of socket.\n*/\n", "func_signal": "void write_data(SOCKET s, vuint8 * src, vuint8 * dst, uint16 len)", "code": "{\n\tuint16 size;\n\tuint16 dst_mask;\n\tuint8 * dst_ptr;\n\n\tdst_mask = (uint16)dst & getIINCHIP_TxMASK(s);\n\tdst_ptr = (uint8 *)(getIINCHIP_TxBASE(s) + dst_mask);\n\t\n\tif (dst_mask + len > getIINCHIP_TxMAX(s)) \n\t{\n\t\tsize = getIINCHIP_TxMAX(s) - dst_mask;\n\t\twiz_write_buf((uint16)dst_ptr, (uint8*)src, size);\n\t\tsrc += size;\n\t\tsize = len - size;\n\t\tdst_ptr = (uint8 *)(getIINCHIP_TxBASE(s));\n\t\twiz_write_buf((uint16)dst_ptr, (uint8*)src, size);\n\t} \n\telse\n\t{\n\t\twiz_write_buf((uint16)dst_ptr, (uint8*)src, len);\n\t}\n}", "path": "src\\skeleton\\hardware\\libraries\\Ethernet\\utility\\w5100.c", "repo_name": "frickel/shellduino", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 540}
{"docstring": "/* main program starts here */\n", "func_signal": "int main(void)", "code": "{\n\tuint8_t ch,ch2;\n\tuint16_t w;\n\n#ifdef WATCHDOG_MODS\n\tch = MCUSR;\n\tMCUSR = 0;\n\n\tWDTCSR |= _BV(WDCE) | _BV(WDE);\n\tWDTCSR = 0;\n\n\t// Check if the WDT was used to reset, in which case we dont bootload and skip straight to the code. woot.\n\tif (! (ch &  _BV(EXTRF))) // if its a not an external reset...\n\t\tapp_start();  // skip bootloader\n#else\n\tasm volatile(\"nop\\n\\t\");\n#endif\n\n\t/* set pin direction for bootloader pin and enable pullup */\n\t/* for ATmega128, two pins need to be initialized */\n#ifdef __AVR_ATmega128__\n\tBL_DDR &= ~_BV(BL0);\n\tBL_DDR &= ~_BV(BL1);\n\tBL_PORT |= _BV(BL0);\n\tBL_PORT |= _BV(BL1);\n#else\n\t/* We run the bootloader regardless of the state of this pin.  Thus, don't\n\tput it in a different state than the other pins.  --DAM, 070709\n\tThis also applies to Arduino Mega -- DC, 080930\n\tBL_DDR &= ~_BV(BL);\n\tBL_PORT |= _BV(BL);\n\t*/\n#endif\n\n\n#ifdef __AVR_ATmega128__\n\t/* check which UART should be used for booting */\n\tif(bit_is_clear(BL_PIN, BL0)) {\n\t\tbootuart = 1;\n\t}\n\telse if(bit_is_clear(BL_PIN, BL1)) {\n\t\tbootuart = 2;\n\t}\n#endif\n\n#if defined __AVR_ATmega1280__\n\t/* the mega1280 chip has four serial ports ... we could eventually use any of them, or not? */\n\t/* however, we don't wanna confuse people, to avoid making a mess, we will stick to RXD0, TXD0 */\n\tbootuart = 1;\n#endif\n\n\t/* check if flash is programmed already, if not start bootloader anyway */\n\tif(pgm_read_byte_near(0x0000) != 0xFF) {\n\n#ifdef __AVR_ATmega128__\n\t/* no UART was selected, start application */\n\tif(!bootuart) {\n\t\tapp_start();\n\t}\n#else\n\t/* check if bootloader pin is set low */\n\t/* we don't start this part neither for the m8, nor m168 */\n\t//if(bit_is_set(BL_PIN, BL)) {\n\t//      app_start();\n\t//    }\n#endif\n\t}\n\n#ifdef __AVR_ATmega128__    \n\t/* no bootuart was selected, default to uart 0 */\n\tif(!bootuart) {\n\t\tbootuart = 1;\n\t}\n#endif\n\n\n\t/* initialize UART(s) depending on CPU defined */\n#if defined(__AVR_ATmega128__) || defined(__AVR_ATmega1280__)\n\tif(bootuart == 1) {\n\t\tUBRR0L = (uint8_t)(F_CPU/(BAUD_RATE*16L)-1);\n\t\tUBRR0H = (F_CPU/(BAUD_RATE*16L)-1) >> 8;\n\t\tUCSR0A = 0x00;\n\t\tUCSR0C = 0x06;\n\t\tUCSR0B = _BV(TXEN0)|_BV(RXEN0);\n\t}\n\tif(bootuart == 2) {\n\t\tUBRR1L = (uint8_t)(F_CPU/(BAUD_RATE*16L)-1);\n\t\tUBRR1H = (F_CPU/(BAUD_RATE*16L)-1) >> 8;\n\t\tUCSR1A = 0x00;\n\t\tUCSR1C = 0x06;\n\t\tUCSR1B = _BV(TXEN1)|_BV(RXEN1);\n\t}\n#elif defined __AVR_ATmega163__\n\tUBRR = (uint8_t)(F_CPU/(BAUD_RATE*16L)-1);\n\tUBRRHI = (F_CPU/(BAUD_RATE*16L)-1) >> 8;\n\tUCSRA = 0x00;\n\tUCSRB = _BV(TXEN)|_BV(RXEN);\t\n#elif defined(__AVR_ATmega168__) || defined(__AVR_ATmega328P__)\n\n#ifdef DOUBLE_SPEED\n\tUCSR0A = (1<<U2X0); //Double speed mode USART0\n\tUBRR0L = (uint8_t)(F_CPU/(BAUD_RATE*8L)-1);\n\tUBRR0H = (F_CPU/(BAUD_RATE*8L)-1) >> 8;\n#else\n\tUBRR0L = (uint8_t)(F_CPU/(BAUD_RATE*16L)-1);\n\tUBRR0H = (F_CPU/(BAUD_RATE*16L)-1) >> 8;\n#endif\n\n\tUCSR0B = (1<<RXEN0) | (1<<TXEN0);\n\tUCSR0C = (1<<UCSZ00) | (1<<UCSZ01);\n\n\t/* Enable internal pull-up resistor on pin D0 (RX), in order\n\tto supress line noise that prevents the bootloader from\n\ttiming out (DAM: 20070509) */\n\tDDRD &= ~_BV(PIND0);\n\tPORTD |= _BV(PIND0);\n#elif defined __AVR_ATmega8__\n\t/* m8 */\n\tUBRRH = (((F_CPU/BAUD_RATE)/16)-1)>>8; \t// set baud rate\n\tUBRRL = (((F_CPU/BAUD_RATE)/16)-1);\n\tUCSRB = (1<<RXEN)|(1<<TXEN);  // enable Rx & Tx\n\tUCSRC = (1<<URSEL)|(1<<UCSZ1)|(1<<UCSZ0);  // config USART; 8N1\n#else\n\t/* m16,m32,m169,m8515,m8535 */\n\tUBRRL = (uint8_t)(F_CPU/(BAUD_RATE*16L)-1);\n\tUBRRH = (F_CPU/(BAUD_RATE*16L)-1) >> 8;\n\tUCSRA = 0x00;\n\tUCSRC = 0x06;\n\tUCSRB = _BV(TXEN)|_BV(RXEN);\n#endif\n\n#if defined __AVR_ATmega1280__\n\t/* Enable internal pull-up resistor on pin D0 (RX), in order\n\tto supress line noise that prevents the bootloader from\n\ttiming out (DAM: 20070509) */\n\t/* feature added to the Arduino Mega --DC: 080930 */\n\tDDRE &= ~_BV(PINE0);\n\tPORTE |= _BV(PINE0);\n#endif\n\n\n\t/* set LED pin as output */\n\tLED_DDR |= _BV(LED);\n\n\n\t/* flash onboard LED to signal entering of bootloader */\n#if defined(__AVR_ATmega128__) || defined(__AVR_ATmega1280__)\n\t// 4x for UART0, 5x for UART1\n\tflash_led(NUM_LED_FLASHES + bootuart);\n#else\n\tflash_led(NUM_LED_FLASHES);\n#endif\n\n\t/* 20050803: by DojoCorp, this is one of the parts provoking the\n\t\t system to stop listening, cancelled from the original */\n\t//putch('\\0');\n\n\t/* forever loop */\n\tfor (;;) {\n\n\t/* get character from UART */\n\tch = getch();\n\n\t/* A bunch of if...else if... gives smaller code than switch...case ! */\n\n\t/* Hello is anyone home ? */ \n\tif(ch=='0') {\n\t\tnothing_response();\n\t}\n\n\n\t/* Request programmer ID */\n\t/* Not using PROGMEM string due to boot block in m128 being beyond 64kB boundry  */\n\t/* Would need to selectively manipulate RAMPZ, and it's only 9 characters anyway so who cares.  */\n\telse if(ch=='1') {\n\t\tif (getch() == ' ') {\n\t\t\tputch(0x14);\n\t\t\tputch('A');\n\t\t\tputch('V');\n\t\t\tputch('R');\n\t\t\tputch(' ');\n\t\t\tputch('I');\n\t\t\tputch('S');\n\t\t\tputch('P');\n\t\t\tputch(0x10);\n\t\t} else {\n\t\t\tif (++error_count == MAX_ERROR_COUNT)\n\t\t\t\tapp_start();\n\t\t}\n\t}\n\n\n\t/* AVR ISP/STK500 board commands  DON'T CARE so default nothing_response */\n\telse if(ch=='@') {\n\t\tch2 = getch();\n\t\tif (ch2>0x85) getch();\n\t\tnothing_response();\n\t}\n\n\n\t/* AVR ISP/STK500 board requests */\n\telse if(ch=='A') {\n\t\tch2 = getch();\n\t\tif(ch2==0x80) byte_response(HW_VER);\t\t// Hardware version\n\t\telse if(ch2==0x81) byte_response(SW_MAJOR);\t// Software major version\n\t\telse if(ch2==0x82) byte_response(SW_MINOR);\t// Software minor version\n\t\telse if(ch2==0x98) byte_response(0x03);\t\t// Unknown but seems to be required by avr studio 3.56\n\t\telse byte_response(0x00);\t\t\t\t// Covers various unnecessary responses we don't care about\n\t}\n\n\n\t/* Device Parameters  DON'T CARE, DEVICE IS FIXED  */\n\telse if(ch=='B') {\n\t\tgetNch(20);\n\t\tnothing_response();\n\t}\n\n\n\t/* Parallel programming stuff  DON'T CARE  */\n\telse if(ch=='E') {\n\t\tgetNch(5);\n\t\tnothing_response();\n\t}\n\n\n\t/* P: Enter programming mode  */\n\t/* R: Erase device, don't care as we will erase one page at a time anyway.  */\n\telse if(ch=='P' || ch=='R') {\n\t\tnothing_response();\n\t}\n\n\n\t/* Leave programming mode  */\n\telse if(ch=='Q') {\n\t\tnothing_response();\n#ifdef WATCHDOG_MODS\n\t\t// autoreset via watchdog (sneaky!)\n\t\tWDTCSR = _BV(WDE);\n\t\twhile (1); // 16 ms\n#endif\n\t}\n\n\n\t/* Set address, little endian. EEPROM in bytes, FLASH in words  */\n\t/* Perhaps extra address bytes may be added in future to support > 128kB FLASH.  */\n\t/* This might explain why little endian was used here, big endian used everywhere else.  */\n\telse if(ch=='U') {\n\t\taddress.byte[0] = getch();\n\t\taddress.byte[1] = getch();\n\t\tnothing_response();\n\t}\n\n\n\t/* Universal SPI programming command, disabled.  Would be used for fuses and lock bits.  */\n\telse if(ch=='V') {\n\t\tif (getch() == 0x30) {\n\t\t\tgetch();\n\t\t\tch = getch();\n\t\t\tgetch();\n\t\t\tif (ch == 0) {\n\t\t\t\tbyte_response(SIG1);\n\t\t\t} else if (ch == 1) {\n\t\t\t\tbyte_response(SIG2); \n\t\t\t} else {\n\t\t\t\tbyte_response(SIG3);\n\t\t\t} \n\t\t} else {\n\t\t\tgetNch(3);\n\t\t\tbyte_response(0x00);\n\t\t}\n\t}\n\n\n\t/* Write memory, length is big endian and is in bytes  */\n\telse if(ch=='d') {\n\t\tlength.byte[1] = getch();\n\t\tlength.byte[0] = getch();\n\t\tflags.eeprom = 0;\n\t\tif (getch() == 'E') flags.eeprom = 1;\n\t\tfor (w=0;w<length.word;w++) {\n\t\t\tbuff[w] = getch();\t                        // Store data in buffer, can't keep up with serial data stream whilst programming pages\n\t\t}\n\t\tif (getch() == ' ') {\n\t\t\tif (flags.eeprom) {\t\t                //Write to EEPROM one byte at a time\n\t\t\t\taddress.word <<= 1;\n\t\t\t\tfor(w=0;w<length.word;w++) {\n#if defined(__AVR_ATmega168__)  || defined(__AVR_ATmega328P__)\n\t\t\t\t\twhile(EECR & (1<<EEPE));\n\t\t\t\t\tEEAR = (uint16_t)(void *)address.word;\n\t\t\t\t\tEEDR = buff[w];\n\t\t\t\t\tEECR |= (1<<EEMPE);\n\t\t\t\t\tEECR |= (1<<EEPE);\n#else\n\t\t\t\t\teeprom_write_byte((void *)address.word,buff[w]);\n#endif\n\t\t\t\t\taddress.word++;\n\t\t\t\t}\t\t\t\n\t\t\t}\n\t\t\telse {\t\t\t\t\t        //Write to FLASH one page at a time\n\t\t\t\tif (address.byte[1]>127) address_high = 0x01;\t//Only possible with m128, m256 will need 3rd address byte. FIXME\n\t\t\t\telse address_high = 0x00;\n#if defined(__AVR_ATmega128__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__)\n\t\t\t\tRAMPZ = address_high;\n#endif\n\t\t\t\taddress.word = address.word << 1;\t        //address * 2 -> byte location\n\t\t\t\t/* if ((length.byte[0] & 0x01) == 0x01) length.word++;\t//Even up an odd number of bytes */\n\t\t\t\tif ((length.byte[0] & 0x01)) length.word++;\t//Even up an odd number of bytes\n\t\t\t\tcli();\t\t\t\t\t//Disable interrupts, just to be sure\n#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__)\n\t\t\t\twhile(bit_is_set(EECR,EEPE));\t\t\t//Wait for previous EEPROM writes to complete\n#else\n\t\t\t\twhile(bit_is_set(EECR,EEWE));\t\t\t//Wait for previous EEPROM writes to complete\n#endif\n\t\t\t\tasm volatile(\n\t\t\t\t\t \"clr\tr17\t\t\\n\\t\"\t//page_word_count\n\t\t\t\t\t \"lds\tr30,address\t\\n\\t\"\t//Address of FLASH location (in bytes)\n\t\t\t\t\t \"lds\tr31,address+1\t\\n\\t\"\n\t\t\t\t\t \"ldi\tr28,lo8(buff)\t\\n\\t\"\t//Start of buffer array in RAM\n\t\t\t\t\t \"ldi\tr29,hi8(buff)\t\\n\\t\"\n\t\t\t\t\t \"lds\tr24,length\t\\n\\t\"\t//Length of data to be written (in bytes)\n\t\t\t\t\t \"lds\tr25,length+1\t\\n\\t\"\n\t\t\t\t\t \"length_loop:\t\t\\n\\t\"\t//Main loop, repeat for number of words in block\t\t\t\t\t\t\t \t\t\t\t\t\t\t \n\t\t\t\t\t \"cpi\tr17,0x00\t\\n\\t\"\t//If page_word_count=0 then erase page\n\t\t\t\t\t \"brne\tno_page_erase\t\\n\\t\"\t\t\t\t\t\t \n\t\t\t\t\t \"wait_spm1:\t\t\\n\\t\"\n\t\t\t\t\t \"lds\tr16,%0\t\t\\n\\t\"\t//Wait for previous spm to complete\n\t\t\t\t\t \"andi\tr16,1           \\n\\t\"\n\t\t\t\t\t \"cpi\tr16,1           \\n\\t\"\n\t\t\t\t\t \"breq\twait_spm1       \\n\\t\"\n\t\t\t\t\t \"ldi\tr16,0x03\t\\n\\t\"\t//Erase page pointed to by Z\n\t\t\t\t\t \"sts\t%0,r16\t\t\\n\\t\"\n\t\t\t\t\t \"spm\t\t\t\\n\\t\"\t\t\t\t\t\t\t \n#ifdef __AVR_ATmega163__\n\t\t\t\t\t \".word 0xFFFF\t\t\\n\\t\"\n\t\t\t\t\t \"nop\t\t\t\\n\\t\"\n#endif\n\t\t\t\t\t \"wait_spm2:\t\t\\n\\t\"\n\t\t\t\t\t \"lds\tr16,%0\t\t\\n\\t\"\t//Wait for previous spm to complete\n\t\t\t\t\t \"andi\tr16,1           \\n\\t\"\n\t\t\t\t\t \"cpi\tr16,1           \\n\\t\"\n\t\t\t\t\t \"breq\twait_spm2       \\n\\t\"\t\t\t\t\t\t\t\t\t \n\n\t\t\t\t\t \"ldi\tr16,0x11\t\\n\\t\"\t//Re-enable RWW section\n\t\t\t\t\t \"sts\t%0,r16\t\t\\n\\t\"\t\t\t\t\t\t \t\t\t \n\t\t\t\t\t \"spm\t\t\t\\n\\t\"\n#ifdef __AVR_ATmega163__\n\t\t\t\t\t \".word 0xFFFF\t\t\\n\\t\"\n\t\t\t\t\t \"nop\t\t\t\\n\\t\"\n#endif\n\t\t\t\t\t \"no_page_erase:\t\t\\n\\t\"\t\t\t\t\t\t\t \n\t\t\t\t\t \"ld\tr0,Y+\t\t\\n\\t\"\t//Write 2 bytes into page buffer\n\t\t\t\t\t \"ld\tr1,Y+\t\t\\n\\t\"\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t \n\t\t\t\t\t \"wait_spm3:\t\t\\n\\t\"\n\t\t\t\t\t \"lds\tr16,%0\t\t\\n\\t\"\t//Wait for previous spm to complete\n\t\t\t\t\t \"andi\tr16,1           \\n\\t\"\n\t\t\t\t\t \"cpi\tr16,1           \\n\\t\"\n\t\t\t\t\t \"breq\twait_spm3       \\n\\t\"\n\t\t\t\t\t \"ldi\tr16,0x01\t\\n\\t\"\t//Load r0,r1 into FLASH page buffer\n\t\t\t\t\t \"sts\t%0,r16\t\t\\n\\t\"\n\t\t\t\t\t \"spm\t\t\t\\n\\t\"\n\t\t\t\t\t\t\t\t \n\t\t\t\t\t \"inc\tr17\t\t\\n\\t\"\t//page_word_count++\n\t\t\t\t\t \"cpi r17,%1\t        \\n\\t\"\n\t\t\t\t\t \"brlo\tsame_page\t\\n\\t\"\t//Still same page in FLASH\n\t\t\t\t\t \"write_page:\t\t\\n\\t\"\n\t\t\t\t\t \"clr\tr17\t\t\\n\\t\"\t//New page, write current one first\n\t\t\t\t\t \"wait_spm4:\t\t\\n\\t\"\n\t\t\t\t\t \"lds\tr16,%0\t\t\\n\\t\"\t//Wait for previous spm to complete\n\t\t\t\t\t \"andi\tr16,1           \\n\\t\"\n\t\t\t\t\t \"cpi\tr16,1           \\n\\t\"\n\t\t\t\t\t \"breq\twait_spm4       \\n\\t\"\n#ifdef __AVR_ATmega163__\n\t\t\t\t\t \"andi\tr30,0x80\t\\n\\t\"\t// m163 requires Z6:Z1 to be zero during page write\n#endif\t\t\t\t\t\t\t \t\t\t\t\t\t\t \n\t\t\t\t\t \"ldi\tr16,0x05\t\\n\\t\"\t//Write page pointed to by Z\n\t\t\t\t\t \"sts\t%0,r16\t\t\\n\\t\"\n\t\t\t\t\t \"spm\t\t\t\\n\\t\"\n#ifdef __AVR_ATmega163__\n\t\t\t\t\t \".word 0xFFFF\t\t\\n\\t\"\n\t\t\t\t\t \"nop\t\t\t\\n\\t\"\n\t\t\t\t\t \"ori\tr30,0x7E\t\\n\\t\"\t// recover Z6:Z1 state after page write (had to be zero during write)\n#endif\n\t\t\t\t\t \"wait_spm5:\t\t\\n\\t\"\n\t\t\t\t\t \"lds\tr16,%0\t\t\\n\\t\"\t//Wait for previous spm to complete\n\t\t\t\t\t \"andi\tr16,1           \\n\\t\"\n\t\t\t\t\t \"cpi\tr16,1           \\n\\t\"\n\t\t\t\t\t \"breq\twait_spm5       \\n\\t\"\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t \"ldi\tr16,0x11\t\\n\\t\"\t//Re-enable RWW section\n\t\t\t\t\t \"sts\t%0,r16\t\t\\n\\t\"\t\t\t\t\t\t \t\t\t \n\t\t\t\t\t \"spm\t\t\t\\n\\t\"\t\t\t\t\t \t\t \n#ifdef __AVR_ATmega163__\n\t\t\t\t\t \".word 0xFFFF\t\t\\n\\t\"\n\t\t\t\t\t \"nop\t\t\t\\n\\t\"\n#endif\n\t\t\t\t\t \"same_page:\t\t\\n\\t\"\t\t\t\t\t\t\t \n\t\t\t\t\t \"adiw\tr30,2\t\t\\n\\t\"\t//Next word in FLASH\n\t\t\t\t\t \"sbiw\tr24,2\t\t\\n\\t\"\t//length-2\n\t\t\t\t\t \"breq\tfinal_write\t\\n\\t\"\t//Finished\n\t\t\t\t\t \"rjmp\tlength_loop\t\\n\\t\"\n\t\t\t\t\t \"final_write:\t\t\\n\\t\"\n\t\t\t\t\t \"cpi\tr17,0\t\t\\n\\t\"\n\t\t\t\t\t \"breq\tblock_done\t\\n\\t\"\n\t\t\t\t\t \"adiw\tr24,2\t\t\\n\\t\"\t//length+2, fool above check on length after short page write\n\t\t\t\t\t \"rjmp\twrite_page\t\\n\\t\"\n\t\t\t\t\t \"block_done:\t\t\\n\\t\"\n\t\t\t\t\t \"clr\t__zero_reg__\t\\n\\t\"\t//restore zero register\n#if defined __AVR_ATmega168__  || __AVR_ATmega328P__ || __AVR_ATmega128__ || __AVR_ATmega1280__ || __AVR_ATmega1281__ \n\t\t\t\t\t : \"=m\" (SPMCSR) : \"M\" (PAGE_SIZE) : \"r0\",\"r16\",\"r17\",\"r24\",\"r25\",\"r28\",\"r29\",\"r30\",\"r31\"\n#else\n\t\t\t\t\t : \"=m\" (SPMCR) : \"M\" (PAGE_SIZE) : \"r0\",\"r16\",\"r17\",\"r24\",\"r25\",\"r28\",\"r29\",\"r30\",\"r31\"\n#endif\n\t\t\t\t\t );\n\t\t\t\t/* Should really add a wait for RWW section to be enabled, don't actually need it since we never */\n\t\t\t\t/* exit the bootloader without a power cycle anyhow */\n\t\t\t}\n\t\t\tputch(0x14);\n\t\t\tputch(0x10);\n\t\t} else {\n\t\t\tif (++error_count == MAX_ERROR_COUNT)\n\t\t\t\tapp_start();\n\t\t}\t\t\n\t}\n\n\n\t/* Read memory block mode, length is big endian.  */\n\telse if(ch=='t') {\n\t\tlength.byte[1] = getch();\n\t\tlength.byte[0] = getch();\n#if defined(__AVR_ATmega128__) || defined(__AVR_ATmega1280__)\n\t\tif (address.word>0x7FFF) flags.rampz = 1;\t\t// No go with m256, FIXME\n\t\telse flags.rampz = 0;\n#endif\n\t\taddress.word = address.word << 1;\t        // address * 2 -> byte location\n\t\tif (getch() == 'E') flags.eeprom = 1;\n\t\telse flags.eeprom = 0;\n\t\tif (getch() == ' ') {\t\t                // Command terminator\n\t\t\tputch(0x14);\n\t\t\tfor (w=0;w < length.word;w++) {\t\t        // Can handle odd and even lengths okay\n\t\t\t\tif (flags.eeprom) {\t                        // Byte access EEPROM read\n#if defined(__AVR_ATmega168__)  || defined(__AVR_ATmega328P__)\n\t\t\t\t\twhile(EECR & (1<<EEPE));\n\t\t\t\t\tEEAR = (uint16_t)(void *)address.word;\n\t\t\t\t\tEECR |= (1<<EERE);\n\t\t\t\t\tputch(EEDR);\n#else\n\t\t\t\t\tputch(eeprom_read_byte((void *)address.word));\n#endif\n\t\t\t\t\taddress.word++;\n\t\t\t\t}\n\t\t\t\telse {\n\n\t\t\t\t\tif (!flags.rampz) putch(pgm_read_byte_near(address.word));\n#if defined(__AVR_ATmega128__) || defined(__AVR_ATmega1280__)\n\t\t\t\t\telse putch(pgm_read_byte_far(address.word + 0x10000));\n\t\t\t\t\t// Hmmmm, yuck  FIXME when m256 arrvies\n#endif\n\t\t\t\t\taddress.word++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tputch(0x10);\n\t\t}\n\t}\n\n\n\t/* Get device signature bytes  */\n\telse if(ch=='u') {\n\t\tif (getch() == ' ') {\n\t\t\tputch(0x14);\n\t\t\tputch(SIG1);\n\t\t\tputch(SIG2);\n\t\t\tputch(SIG3);\n\t\t\tputch(0x10);\n\t\t} else {\n\t\t\tif (++error_count == MAX_ERROR_COUNT)\n\t\t\t\tapp_start();\n\t\t}\n\t}\n\n\n\t/* Read oscillator calibration byte */\n\telse if(ch=='v') {\n\t\tbyte_response(0x00);\n\t}\n\n\n#if defined MONITOR \n\n\t/* here come the extended monitor commands by Erik Lins */\n\n\t/* check for three times exclamation mark pressed */\n\telse if(ch=='!') {\n\t\tch = getch();\n\t\tif(ch=='!') {\n\t\tch = getch();\n\t\tif(ch=='!') {\n\t\t\tPGM_P welcome = \"\";\n#if defined(__AVR_ATmega128__) || defined(__AVR_ATmega1280__)\n\t\t\tuint16_t extaddr;\n#endif\n\t\t\tuint8_t addrl, addrh;\n\n#ifdef CRUMB128\n\t\t\twelcome = \"ATmegaBOOT / Crumb128 - (C) J.P.Kyle, E.Lins - 050815\\n\\r\";\n#elif defined PROBOMEGA128\n\t\t\twelcome = \"ATmegaBOOT / PROBOmega128 - (C) J.P.Kyle, E.Lins - 050815\\n\\r\";\n#elif defined SAVVY128\n\t\t\twelcome = \"ATmegaBOOT / Savvy128 - (C) J.P.Kyle, E.Lins - 050815\\n\\r\";\n#elif defined __AVR_ATmega1280__ \n\t\t\twelcome = \"ATmegaBOOT / Arduino Mega - (C) Arduino LLC - 090930\\n\\r\";\n#endif\n\n\t\t\t/* turn on LED */\n\t\t\tLED_DDR |= _BV(LED);\n\t\t\tLED_PORT &= ~_BV(LED);\n\n\t\t\t/* print a welcome message and command overview */\n\t\t\tfor(i=0; welcome[i] != '\\0'; ++i) {\n\t\t\t\tputch(welcome[i]);\n\t\t\t}\n\n\t\t\t/* test for valid commands */\n\t\t\tfor(;;) {\n\t\t\t\tputch('\\n');\n\t\t\t\tputch('\\r');\n\t\t\t\tputch(':');\n\t\t\t\tputch(' ');\n\n\t\t\t\tch = getch();\n\t\t\t\tputch(ch);\n\n\t\t\t\t/* toggle LED */\n\t\t\t\tif(ch == 't') {\n\t\t\t\t\tif(bit_is_set(LED_PIN,LED)) {\n\t\t\t\t\t\tLED_PORT &= ~_BV(LED);\n\t\t\t\t\t\tputch('1');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLED_PORT |= _BV(LED);\n\t\t\t\t\t\tputch('0');\n\t\t\t\t\t}\n\t\t\t\t} \n\n\t\t\t\t/* read byte from address */\n\t\t\t\telse if(ch == 'r') {\n\t\t\t\t\tch = getch(); putch(ch);\n\t\t\t\t\taddrh = gethex();\n\t\t\t\t\taddrl = gethex();\n\t\t\t\t\tputch('=');\n\t\t\t\t\tch = *(uint8_t *)((addrh << 8) + addrl);\n\t\t\t\t\tputhex(ch);\n\t\t\t\t}\n\n\t\t\t\t/* write a byte to address  */\n\t\t\t\telse if(ch == 'w') {\n\t\t\t\t\tch = getch(); putch(ch);\n\t\t\t\t\taddrh = gethex();\n\t\t\t\t\taddrl = gethex();\n\t\t\t\t\tch = getch(); putch(ch);\n\t\t\t\t\tch = gethex();\n\t\t\t\t\t*(uint8_t *)((addrh << 8) + addrl) = ch;\n\t\t\t\t}\n\n\t\t\t\t/* read from uart and echo back */\n\t\t\t\telse if(ch == 'u') {\n\t\t\t\t\tfor(;;) {\n\t\t\t\t\t\tputch(getch());\n\t\t\t\t\t}\n\t\t\t\t}\n#if defined(__AVR_ATmega128__) || defined(__AVR_ATmega1280__)\n\t\t\t\t/* external bus loop  */\n\t\t\t\telse if(ch == 'b') {\n\t\t\t\t\tputch('b');\n\t\t\t\t\tputch('u');\n\t\t\t\t\tputch('s');\n\t\t\t\t\tMCUCR = 0x80;\n\t\t\t\t\tXMCRA = 0;\n\t\t\t\t\tXMCRB = 0;\n\t\t\t\t\textaddr = 0x1100;\n\t\t\t\t\tfor(;;) {\n\t\t\t\t\t\tch = *(volatile uint8_t *)extaddr;\n\t\t\t\t\t\tif(++extaddr == 0) {\n\t\t\t\t\t\t\textaddr = 0x1100;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\n\t\t\t\telse if(ch == 'j') {\n\t\t\t\t\tapp_start();\n\t\t\t\t}\n\n\t\t\t} /* end of monitor functions */\n\n\t\t}\n\t\t}\n\t}\n\t/* end of monitor */\n#endif\n\telse if (++error_count == MAX_ERROR_COUNT) {\n\t\tapp_start();\n\t}\n\t} /* end of forever loop */\n\n}", "path": "src\\skeleton\\hardware\\bootloaders\\atmega\\ATmegaBOOT_168.c", "repo_name": "frickel/shellduino", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 540}
{"docstring": "/* \n * Function twi_releaseBus\n * Desc     releases bus control\n * Input    none\n * Output   none\n */\n", "func_signal": "void twi_releaseBus(void)", "code": "{\n  // release bus\n  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT);\n\n  // update twi state\n  twi_state = TWI_READY;\n}", "path": "src\\skeleton\\hardware\\libraries\\Wire\\utility\\twi.c", "repo_name": "frickel/shellduino", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 540}
{"docstring": "/**\n@brief\tterminate PPPoE connection\n*/\n", "func_signal": "uint8 pppterm(uint8 * mac, uint8 * sessionid)", "code": "{\n\tuint16 i;\n\tuint8 isr;\n#ifdef __DEF_IINCHIP_DBG__\n\tprintf(\"pppterm()\\r\\n\");\n#endif\n\t/* Set PPPoE bit in MR(Common Mode Register) : enable socket0 pppoe */\n\tIINCHIP_WRITE(MR,IINCHIP_READ(MR) | MR_PPPOE);\n\t\n\t// write pppoe server's mac address and session id \n\t// must be setted these value.\n\tfor (i = 0; i < 6; i++) IINCHIP_WRITE((Sn_DHAR0(0)+i),mac[i]);\n\tfor (i = 0; i < 2; i++) IINCHIP_WRITE((Sn_DPORT0(0)+i),sessionid[i]);\n\tisr = IINCHIP_READ(Sn_IR(0));\n\tIINCHIP_WRITE(Sn_IR(0),isr);\n\t\n\t//open socket in pppoe mode\n\tIINCHIP_WRITE(Sn_MR(0),Sn_MR_PPPOE);\n\tIINCHIP_WRITE(Sn_CR(0),Sn_CR_OPEN);\n\t/* +20071122[chungs]:wait to process the command... */\n\twhile( IINCHIP_READ(Sn_CR(0)) ) \n\t\t;\n\t/* ------- */\n\twait_1us(1);\n\t// close pppoe connection\n\tIINCHIP_WRITE(Sn_CR(0),Sn_CR_PDISCON);\n\t/* +20071122[chungs]:wait to process the command... */\n\twhile( IINCHIP_READ(Sn_CR(0)) ) \n\t\t;\n\t/* ------- */\n\twait_10ms(100);\n\t// close socket\n\t/* +200801 (hwkim) */\n\tclose(0);\n\t/* ------- */\n\t\n\n#ifdef __DEF_IINCHIP_DBG__\n\tprintf(\"pppterm() end ..\\r\\n\");\n#endif\n\n\treturn 1;\n}", "path": "src\\skeleton\\hardware\\libraries\\Ethernet\\utility\\w5100.c", "repo_name": "frickel/shellduino", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 540}
{"docstring": "/* Measures the length (in microseconds) of a pulse on the pin; state is HIGH\n * or LOW, the type of pulse to measure.  Works on pulses from 2-3 microseconds\n * to 3 minutes in length, but must be called at least a few dozen microseconds\n * before the start of the pulse. */\n", "func_signal": "unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout)", "code": "{\n\t// cache the port and bit of the pin in order to speed up the\n\t// pulse width measuring loop and achieve finer resolution.  calling\n\t// digitalRead() instead yields much coarser resolution.\n\tuint8_t bit = digitalPinToBitMask(pin);\n\tuint8_t port = digitalPinToPort(pin);\n\tuint8_t stateMask = (state ? bit : 0);\n\tunsigned long width = 0; // keep initialization out of time critical area\n\t\n\t// convert the timeout from microseconds to a number of times through\n\t// the initial loop; it takes 16 clock cycles per iteration.\n\tunsigned long numloops = 0;\n\tunsigned long maxloops = microsecondsToClockCycles(timeout) / 16;\n\t\n\t// wait for any previous pulse to end\n\twhile ((*portInputRegister(port) & bit) == stateMask)\n\t\tif (numloops++ == maxloops)\n\t\t\treturn 0;\n\t\n\t// wait for the pulse to start\n\twhile ((*portInputRegister(port) & bit) != stateMask)\n\t\tif (numloops++ == maxloops)\n\t\t\treturn 0;\n\t\n\t// wait for the pulse to stop\n\twhile ((*portInputRegister(port) & bit) == stateMask)\n\t\twidth++;\n\n\t// convert the reading to microseconds. The loop has been determined\n\t// to be 10 clock cycles long and have about 16 clocks between the edge\n\t// and the start of the loop. There will be some error introduced by\n\t// the interrupt handlers.\n\treturn clockCyclesToMicroseconds(width * 10 + 16); \n}", "path": "src\\skeleton\\hardware\\cores\\arduino\\wiring_pulse.c", "repo_name": "frickel/shellduino", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 540}
{"docstring": "/**\n@brief\tThis sets the maximum segment size of TCP in Active Mode), while in Passive Mode this is set by peer\n*/\n", "func_signal": "void setSn_MSS(SOCKET s, uint16 Sn_MSSR0)", "code": "{\n\tIINCHIP_WRITE(Sn_MSSR0(s),(uint8)((Sn_MSSR0 & 0xff00) >> 8));\n\tIINCHIP_WRITE((Sn_MSSR0(s) + 1),(uint8)(Sn_MSSR0 & 0x00ff));\n}", "path": "src\\skeleton\\hardware\\libraries\\Ethernet\\utility\\w5100.c", "repo_name": "frickel/shellduino", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 540}
{"docstring": "/* VOID:UINT,INT (./libanjuta-iface-marshallers.list:13) */\n", "func_signal": "void\nlibanjuta_iface_cclosure_marshal_VOID__UINT_INT (GClosure     *closure,\n                                                 GValue       *return_value G_GNUC_UNUSED,\n                                                 guint         n_param_values,\n                                                 const GValue *param_values,\n                                                 gpointer      invocation_hint G_GNUC_UNUSED,\n                                                 gpointer      marshal_data)", "code": "{\n  typedef void (*GMarshalFunc_VOID__UINT_INT) (gpointer     data1,\n                                               guint        arg_1,\n                                               gint         arg_2,\n                                               gpointer     data2);\n  register GMarshalFunc_VOID__UINT_INT callback;\n  register GCClosure *cc = (GCClosure*) closure;\n  register gpointer data1, data2;\n\n  g_return_if_fail (n_param_values == 3);\n\n  if (G_CCLOSURE_SWAP_DATA (closure))\n    {\n      data1 = closure->data;\n      data2 = g_value_peek_pointer (param_values + 0);\n    }\n  else\n    {\n      data1 = g_value_peek_pointer (param_values + 0);\n      data2 = closure->data;\n    }\n  callback = (GMarshalFunc_VOID__UINT_INT) (marshal_data ? marshal_data : cc->callback);\n\n  callback (data1,\n            g_marshal_value_peek_uint (param_values + 1),\n            g_marshal_value_peek_int (param_values + 2),\n            data2);\n}", "path": "libanjuta\\interfaces\\libanjuta-iface-marshallers.c", "repo_name": "sgranjoux/projectparser", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 784}
{"docstring": "/* dispose is the first destruction step. It is used to unref object created\n * with instance_init in order to break reference counting cycles. This\n * function could be called several times. All function should still work\n * after this call. It has to called its parents.*/\n", "func_signal": "static void\nanjuta_token_file_dispose (GObject *object)", "code": "{\n\tAnjutaTokenFile *file = ANJUTA_TOKEN_FILE (object);\n\n\tanjuta_token_file_unload (file);\n\t\n\tif (file->file) g_object_unref (file->file);\n\tfile->file = NULL;\n\n\tG_OBJECT_CLASS (parent_class)->dispose (object);\n}", "path": "libanjuta\\anjuta-token-file.c", "repo_name": "sgranjoux/projectparser", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 784}
{"docstring": "/* VOID:STRING,STRING (./libanjuta-iface-marshallers.list:12) */\n", "func_signal": "void\nlibanjuta_iface_cclosure_marshal_VOID__STRING_STRING (GClosure     *closure,\n                                                      GValue       *return_value G_GNUC_UNUSED,\n                                                      guint         n_param_values,\n                                                      const GValue *param_values,\n                                                      gpointer      invocation_hint G_GNUC_UNUSED,\n                                                      gpointer      marshal_data)", "code": "{\n  typedef void (*GMarshalFunc_VOID__STRING_STRING) (gpointer     data1,\n                                                    gpointer     arg_1,\n                                                    gpointer     arg_2,\n                                                    gpointer     data2);\n  register GMarshalFunc_VOID__STRING_STRING callback;\n  register GCClosure *cc = (GCClosure*) closure;\n  register gpointer data1, data2;\n\n  g_return_if_fail (n_param_values == 3);\n\n  if (G_CCLOSURE_SWAP_DATA (closure))\n    {\n      data1 = closure->data;\n      data2 = g_value_peek_pointer (param_values + 0);\n    }\n  else\n    {\n      data1 = g_value_peek_pointer (param_values + 0);\n      data2 = closure->data;\n    }\n  callback = (GMarshalFunc_VOID__STRING_STRING) (marshal_data ? marshal_data : cc->callback);\n\n  callback (data1,\n            g_marshal_value_peek_string (param_values + 1),\n            g_marshal_value_peek_string (param_values + 2),\n            data2);\n}", "path": "libanjuta\\interfaces\\libanjuta-iface-marshallers.c", "repo_name": "sgranjoux/projectparser", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 784}
{"docstring": "/* Parser functions\n *---------------------------------------------------------------------------*/\n", "func_signal": "void\nmkp_project_add_rule (MkpProject *project, AnjutaToken *group)", "code": "{\n\tAnjutaToken *targ;\n\tAnjutaToken *dep;\n\tAnjutaToken *arg;\n\tgboolean double_colon = FALSE;\n\n\tfprintf(stdout, \"add rule\\n\");\n\tanjuta_token_dump (group);\n\t\n\ttarg = anjuta_token_first_item (group);\n\targ = anjuta_token_next_word (targ);\n\tif (anjuta_token_get_type (arg) == MK_TOKEN_DOUBLE_COLON) double_colon = TRUE;\n\tdep = anjuta_token_next_word (arg);\n\tfor (arg = anjuta_token_first_word (targ); arg != NULL; arg = anjuta_token_next_word (arg))\n\t{\n\t\tAnjutaToken *src;\n\t\tgchar *target;\n\t\tgboolean order = FALSE;\n\t\tgboolean no_token = TRUE;\n\t\tMkpRule *rule;\n\n\t\tswitch (anjuta_token_get_type (arg))\n\t\t{\n\t\tcase MK_TOKEN__PHONY:\n\t\t\tfor (src = anjuta_token_first_word (dep); src != NULL; src = anjuta_token_next_word (src))\n\t\t\t{\n\t\t\t\tif (anjuta_token_get_type (src) != MK_TOKEN_ORDER)\n\t\t\t\t{\n\t\t\t\t\ttarget = anjuta_token_evaluate (src);\n\t\t\t\t\t\n\t\t\t\t\trule = g_hash_table_lookup (project->rules, target);\n\t\t\t\t\tif (rule == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\trule = mkp_rule_new (target, NULL);\n\t\t\t\t\t\tg_hash_table_insert (project->rules, rule->name, rule);\n\t\t\t\t\t}\n\t\t\t\t\trule->phony = TRUE;\n\t\t\t\t\t\n\t\t\t\t\tg_message (\"    with target %s\", target);\n\t\t\t\t\tif (target != NULL) g_free (target);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MK_TOKEN__SUFFIXES:\n\t\t\tfor (src = anjuta_token_first_word (dep); src != NULL; src = anjuta_token_next_word (src))\n\t\t\t{\n\t\t\t\tif (anjuta_token_get_type (src) != MK_TOKEN_ORDER)\n\t\t\t\t{\n\t\t\t\t\tgchar *suffix;\n\n\t\t\t\t\tsuffix = anjuta_token_evaluate (src);\n\t\t\t\t\t/* The pointer value must only be not NULL, it does not matter if it is\n\t \t\t\t\t * invalid */\n\t\t\t\t\tg_hash_table_replace (project->suffix, suffix, suffix);\n\t\t\t\t\tg_message (\"    with suffix %s\", suffix);\n\t\t\t\t\tno_token = FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (no_token == TRUE)\n\t\t\t{\n\t\t\t\t/* Clear all suffix */\n\t\t\t\tg_hash_table_remove_all (project->suffix);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MK_TOKEN__DEFAULT:\n\t\tcase MK_TOKEN__PRECIOUS:\n\t\tcase MK_TOKEN__INTERMEDIATE:\n\t\tcase MK_TOKEN__SECONDARY:\n\t\tcase MK_TOKEN__SECONDEXPANSION:\n\t\tcase MK_TOKEN__DELETE_ON_ERROR:\n\t\tcase MK_TOKEN__IGNORE:\n\t\tcase MK_TOKEN__LOW_RESOLUTION_TIME:\n\t\tcase MK_TOKEN__SILENT:\n\t\tcase MK_TOKEN__EXPORT_ALL_VARIABLES:\n\t\tcase MK_TOKEN__NOTPARALLEL:\n\t\t\t/* Do nothing with these targets, just ignore them */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttarget = g_strstrip (anjuta_token_evaluate (arg));\n\t\t\tif (*target == '\\0') break;\t\n\t\t\tg_message (\"add rule =%s=\", target);\n\t\t\t\t\n\t\t\trule = g_hash_table_lookup (project->rules, target);\n\t\t\tif (rule == NULL)\n\t\t\t{\n\t\t\t\trule = mkp_rule_new (target, group);\n\t\t\t\tg_hash_table_insert (project->rules, rule->name, rule);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\trule->rule = group;\n\t\t\t}\n\t\t\t\t\n\t\t\tfor (src = anjuta_token_first_word (dep); src != NULL; src = anjuta_token_next_word (src))\n\t\t\t{\n\t\t\t\tgchar *src_name = anjuta_token_evaluate (src);\n\n\t\t\t\tif (src_name != NULL)\n\t\t\t\t{\n\t\t\t\t\tg_message (\"    with source %s\", src_name);\n\t\t\t\t\tif (anjuta_token_get_type (src) == MK_TOKEN_ORDER)\n\t\t\t\t\t{\n\t\t\t\t\t\torder = TRUE;\n\t\t\t\t\t}\n\t\t\t\t\trule->prerequisite = g_list_prepend (rule->prerequisite, src_name);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (target != NULL) g_free (target);\n\t\t}\n\t}\n}", "path": "src\\mk-rule.c", "repo_name": "sgranjoux/projectparser", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 784}
{"docstring": "/* class_init intialize the class itself not the instance */\n", "func_signal": "static void\nanjuta_token_file_class_init (AnjutaTokenFileClass * klass)", "code": "{\n\tGObjectClass *gobject_class;\n\n\tg_return_if_fail (klass != NULL);\n\t\n\tparent_class = G_OBJECT_CLASS (g_type_class_peek_parent (klass));\n\tgobject_class = G_OBJECT_CLASS (klass);\n\t\n\tgobject_class->dispose = anjuta_token_file_dispose;\n}", "path": "libanjuta\\anjuta-token-file.c", "repo_name": "sgranjoux/projectparser", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 784}
{"docstring": "/* VOID:ULONG,STRING,UINT (./libanjuta-iface-marshallers.list:14) */\n", "func_signal": "void\nlibanjuta_iface_cclosure_marshal_VOID__ULONG_STRING_UINT (GClosure     *closure,\n                                                          GValue       *return_value G_GNUC_UNUSED,\n                                                          guint         n_param_values,\n                                                          const GValue *param_values,\n                                                          gpointer      invocation_hint G_GNUC_UNUSED,\n                                                          gpointer      marshal_data)", "code": "{\n  typedef void (*GMarshalFunc_VOID__ULONG_STRING_UINT) (gpointer     data1,\n                                                        gulong       arg_1,\n                                                        gpointer     arg_2,\n                                                        guint        arg_3,\n                                                        gpointer     data2);\n  register GMarshalFunc_VOID__ULONG_STRING_UINT callback;\n  register GCClosure *cc = (GCClosure*) closure;\n  register gpointer data1, data2;\n\n  g_return_if_fail (n_param_values == 4);\n\n  if (G_CCLOSURE_SWAP_DATA (closure))\n    {\n      data1 = closure->data;\n      data2 = g_value_peek_pointer (param_values + 0);\n    }\n  else\n    {\n      data1 = g_value_peek_pointer (param_values + 0);\n      data2 = closure->data;\n    }\n  callback = (GMarshalFunc_VOID__ULONG_STRING_UINT) (marshal_data ? marshal_data : cc->callback);\n\n  callback (data1,\n            g_marshal_value_peek_ulong (param_values + 1),\n            g_marshal_value_peek_string (param_values + 2),\n            g_marshal_value_peek_uint (param_values + 3),\n            data2);\n}", "path": "libanjuta\\interfaces\\libanjuta-iface-marshallers.c", "repo_name": "sgranjoux/projectparser", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 784}
{"docstring": "/* Private functions\n *---------------------------------------------------------------------------*/\n", "func_signal": "static AnjutaToken*\nanjuta_token_file_find_position (AnjutaTokenFile *file, AnjutaToken *token)", "code": "{\n\tAnjutaToken *start;\n\tconst gchar *pos;\n\tconst gchar *ptr;\n\tconst gchar *end;\n\t\n\tif (token == NULL) return NULL;\n\n\tif (anjuta_token_get_length (token) == 0)\n\t{\n\t\tAnjutaToken *last = anjuta_token_last (token);\n\n\t\tfor (; (token != NULL) && (token != last); token = anjuta_token_next (token))\n\t\t{\n\t\t\tif (anjuta_token_get_length (token) != 0) break;\n\t\t}\n\n\t\tif (anjuta_token_get_length (token) == 0) return NULL;\n\t}\n\n\tpos = anjuta_token_get_string (token);\n\tfor (start = file->content; start != NULL; start = anjuta_token_next (start))\n\t{\n\t\tguint len = anjuta_token_get_length (start);\n\t\t\t\n\t\tif (len)\n\t\t{\n\t\t\tptr = anjuta_token_get_string (start);\n\t\t\tend = ptr + len;\n\n\t\t\tif ((pos >= ptr) && (pos < end)) break;\n\t\t}\n\t}\n\tif ((start != NULL) && (ptr != pos))\n\t{\n\t\tstart = anjuta_token_split (start, pos - ptr);\n\t\tstart = anjuta_token_next (start);\n\t}\n\n\treturn start;\n}", "path": "libanjuta\\anjuta-token-file.c", "repo_name": "sgranjoux/projectparser", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 784}
{"docstring": "/* VOID:INT,INT,ULONG,STRING,UINT (./libanjuta-iface-marshallers.list:6) */\n", "func_signal": "void\nlibanjuta_iface_cclosure_marshal_VOID__INT_INT_ULONG_STRING_UINT (GClosure     *closure,\n                                                                  GValue       *return_value G_GNUC_UNUSED,\n                                                                  guint         n_param_values,\n                                                                  const GValue *param_values,\n                                                                  gpointer      invocation_hint G_GNUC_UNUSED,\n                                                                  gpointer      marshal_data)", "code": "{\n  typedef void (*GMarshalFunc_VOID__INT_INT_ULONG_STRING_UINT) (gpointer     data1,\n                                                                gint         arg_1,\n                                                                gint         arg_2,\n                                                                gulong       arg_3,\n                                                                gpointer     arg_4,\n                                                                guint        arg_5,\n                                                                gpointer     data2);\n  register GMarshalFunc_VOID__INT_INT_ULONG_STRING_UINT callback;\n  register GCClosure *cc = (GCClosure*) closure;\n  register gpointer data1, data2;\n\n  g_return_if_fail (n_param_values == 6);\n\n  if (G_CCLOSURE_SWAP_DATA (closure))\n    {\n      data1 = closure->data;\n      data2 = g_value_peek_pointer (param_values + 0);\n    }\n  else\n    {\n      data1 = g_value_peek_pointer (param_values + 0);\n      data2 = closure->data;\n    }\n  callback = (GMarshalFunc_VOID__INT_INT_ULONG_STRING_UINT) (marshal_data ? marshal_data : cc->callback);\n\n  callback (data1,\n            g_marshal_value_peek_int (param_values + 1),\n            g_marshal_value_peek_int (param_values + 2),\n            g_marshal_value_peek_ulong (param_values + 3),\n            g_marshal_value_peek_string (param_values + 4),\n            g_marshal_value_peek_uint (param_values + 5),\n            data2);\n}", "path": "libanjuta\\interfaces\\libanjuta-iface-marshallers.c", "repo_name": "sgranjoux/projectparser", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 784}
{"docstring": "/* VOID:OBJECT,BOOLEAN,INT,INT,STRING (./libanjuta-iface-marshallers.list:8) */\n", "func_signal": "void\nlibanjuta_iface_cclosure_marshal_VOID__OBJECT_BOOLEAN_INT_INT_STRING (GClosure     *closure,\n                                                                      GValue       *return_value G_GNUC_UNUSED,\n                                                                      guint         n_param_values,\n                                                                      const GValue *param_values,\n                                                                      gpointer      invocation_hint G_GNUC_UNUSED,\n                                                                      gpointer      marshal_data)", "code": "{\n  typedef void (*GMarshalFunc_VOID__OBJECT_BOOLEAN_INT_INT_STRING) (gpointer     data1,\n                                                                    gpointer     arg_1,\n                                                                    gboolean     arg_2,\n                                                                    gint         arg_3,\n                                                                    gint         arg_4,\n                                                                    gpointer     arg_5,\n                                                                    gpointer     data2);\n  register GMarshalFunc_VOID__OBJECT_BOOLEAN_INT_INT_STRING callback;\n  register GCClosure *cc = (GCClosure*) closure;\n  register gpointer data1, data2;\n\n  g_return_if_fail (n_param_values == 6);\n\n  if (G_CCLOSURE_SWAP_DATA (closure))\n    {\n      data1 = closure->data;\n      data2 = g_value_peek_pointer (param_values + 0);\n    }\n  else\n    {\n      data1 = g_value_peek_pointer (param_values + 0);\n      data2 = closure->data;\n    }\n  callback = (GMarshalFunc_VOID__OBJECT_BOOLEAN_INT_INT_STRING) (marshal_data ? marshal_data : cc->callback);\n\n  callback (data1,\n            g_marshal_value_peek_object (param_values + 1),\n            g_marshal_value_peek_boolean (param_values + 2),\n            g_marshal_value_peek_int (param_values + 3),\n            g_marshal_value_peek_int (param_values + 4),\n            g_marshal_value_peek_string (param_values + 5),\n            data2);\n}", "path": "libanjuta\\interfaces\\libanjuta-iface-marshallers.c", "repo_name": "sgranjoux/projectparser", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 784}
{"docstring": "/* Properties functions\n *---------------------------------------------------------------------------*/\n", "func_signal": "AnjutaProjectPropertyList *\nanjuta_project_property_first (AnjutaProjectPropertyList *list)", "code": "{\n\tif (list != NULL)\n\t{\n\t\tAnjutaProjectPropertyInfo *info = (AnjutaProjectPropertyInfo *)list->data;\n\n\t\tif (info->override != NULL)\n\t\t{\n\t\t\tlist = g_list_first (info->override);\n\t\t}\n\t}\n\treturn list;\n}", "path": "libanjuta\\anjuta-project.c", "repo_name": "sgranjoux/projectparser", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 784}
{"docstring": "/* Public functions\n *---------------------------------------------------------------------------*/\n", "func_signal": "gboolean\namp_project_update_property (AmpProject *project, AmpPropertyInfo *info)", "code": "{\n\tAnjutaToken *token;\n\tAnjutaToken *arg;\n\tguint pos;\n\tconst gchar *value;\n\n\tpos = info->position;\n\tvalue = info->base.value;\n\t\n\tif (project->ac_init == NULL)\n\t{\n\t\tgint types[] = {AC_TOKEN_AC_PREREQ, 0};\n\t\tAnjutaToken *group;\n\n\t\ttoken = find_tokens (project->configure_token, types);\n\t\tif (token == NULL)\n\t\t{\n\t\t\ttoken = skip_comment (project->configure_token);\n\t\t\tif (token == NULL)\n\t\t\t{\n\t\t\t\ttoken = anjuta_token_append_child (project->configure_token, anjuta_token_new_string (COMMENT | ANJUTA_TOKEN_ADDED, \"#\"));\n\t\t\t\ttoken = anjuta_token_insert_after (token, anjuta_token_new_string (SPACE | ANJUTA_TOKEN_ADDED, \" Created by Anjuta project manager\"));\n\t\t\t\ttoken = anjuta_token_insert_after (token, anjuta_token_new_string (EOL | ANJUTA_TOKEN_ADDED, \"\\n\"));\n\t\t\t\ttoken = anjuta_token_insert_after (token, anjuta_token_new_string (EOL | ANJUTA_TOKEN_ADDED, \"\\n\"));\n\t\t\t}\n\t\t}\n\t\t\n\t\ttoken = anjuta_token_insert_before (token, anjuta_token_new_string (AC_TOKEN_AC_INIT | ANJUTA_TOKEN_ADDED, \"AC_INIT(\"));\n\t\tproject->ac_init = token;\n\t\tgroup = anjuta_token_insert_after (token, anjuta_token_new_static (ANJUTA_TOKEN_LIST | ANJUTA_TOKEN_ADDED, NULL));\n\t\tproject->args = group;\n\t\ttoken = anjuta_token_insert_after (group, anjuta_token_new_static (ANJUTA_TOKEN_LAST | ANJUTA_TOKEN_ADDED, NULL));\n\t\tanjuta_token_merge (group, token);\n\t\tanjuta_token_insert_after (token, anjuta_token_new_string (EOL | ANJUTA_TOKEN_ADDED, \"\\n\"));\n\t\tfprintf(stdout, \"whole file\\n\");\n\t\tanjuta_token_dump (project->configure_token);\n\t}\n\tfprintf(stdout, \"ac_init before replace\\n\");\n\tanjuta_token_dump (project->args);\n\ttoken = anjuta_token_new_string (ANJUTA_TOKEN_NAME | ANJUTA_TOKEN_ADDED, value);\n\targ = anjuta_token_insert_before (token, anjuta_token_new_static (ANJUTA_TOKEN_ITEM | ANJUTA_TOKEN_ADDED, NULL));\n\tanjuta_token_merge (arg, token);\n\tanjuta_token_replace_nth_word (project->args, pos, arg);\n\tfprintf(stdout, \"ac_init after replace\\n\");\n\tanjuta_token_dump (project->args);\n\tfprintf(stdout, \"ac_init after replace link\\n\");\n\tanjuta_token_dump_link (project->args);\n\tanjuta_token_style_format (project->arg_list, project->args);\n\tfprintf(stdout, \"ac_init after update link\\n\");\n\tanjuta_token_dump (project->args);\n\tanjuta_token_file_update (project->configure_file, token);\n\t\n\treturn TRUE;\n}", "path": "src\\ac-writer.c", "repo_name": "sgranjoux/projectparser", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 784}
{"docstring": "/* Private functions\n *---------------------------------------------------------------------------*/\n", "func_signal": "static AnjutaToken*\nfind_tokens (AnjutaToken *list, AnjutaTokenType* types)", "code": "{\n\tAnjutaToken *tok;\n\t\n\tfor (tok = list; tok != NULL; tok = anjuta_token_next (tok))\n\t{\n\t\tAnjutaTokenType *type;\n\t\tfor (type = types; *type != 0; type++)\n\t\t{\n\t\t\tif (anjuta_token_get_type (tok) == *type)\n\t\t\t{\n\t\t\t\treturn tok;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn NULL;\n}", "path": "src\\ac-writer.c", "repo_name": "sgranjoux/projectparser", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 784}
{"docstring": "/* instance_init is the constructor. All functions should work after this\n * call. */\n", "func_signal": "static void\nanjuta_token_file_instance_init (AnjutaTokenFile *file)", "code": "{\n\tfile->file = NULL;\n\tfile->content = NULL;\n\tfile->save = NULL;\n}", "path": "libanjuta\\anjuta-token-file.c", "repo_name": "sgranjoux/projectparser", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 784}
{"docstring": "/* Public functions\n *---------------------------------------------------------------------------*/\n", "func_signal": "AnjutaToken*\nanjuta_token_file_load (AnjutaTokenFile *file, GError **error)", "code": "{\n\tgchar *content;\n\tgsize length;\n\n\tanjuta_token_file_unload (file);\n\t\n\tfile->save = anjuta_token_new_static (ANJUTA_TOKEN_FILE,  NULL);\n\tfile->content = anjuta_token_new_static (ANJUTA_TOKEN_FILE,  NULL);\n\t\n\tif (g_file_load_contents (file->file, NULL, &content, &length, NULL, error))\n\t{\n\t\tAnjutaToken *token;\n\t\t\t\n\t\ttoken =\tanjuta_token_new_with_string (ANJUTA_TOKEN_FILE, content, length);\n\t\tanjuta_token_prepend_child (file->save, token);\n\t\t\n\t\ttoken =\tanjuta_token_new_static (ANJUTA_TOKEN_FILE, content);\n\t\tanjuta_token_prepend_child (file->content, token);\n\t}\n\t\n\treturn file->content;\n}", "path": "libanjuta\\anjuta-token-file.c", "repo_name": "sgranjoux/projectparser", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 784}
{"docstring": "/* Public functions\n *---------------------------------------------------------------------------*/\n", "func_signal": "void\nmkp_project_enumerate_targets (MkpProject *project, AnjutaProjectGroup *parent)", "code": "{\n\tGHashTableIter iter;\n\tgpointer key;\n\tMkpRule *rule;\n\n\t/* Check pattern rules */\n\tfor (g_hash_table_iter_init (&iter, project->rules); g_hash_table_iter_next (&iter, (gpointer)&key, (gpointer)&rule);)\n\t{\n\t\tif (rule->phony) continue;\n\n\t\tif (g_hash_table_lookup (project->suffix, rule->name))\n\t\t{\n\t\t\t/* Single suffix rule */\n\t\t\trule->pattern = TRUE;\n\t\t\trule->part = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tGString *pattern = g_string_sized_new (16);\n\t\t\tGList *suffix;\n\t\t\tGList *src;\n\t\t\t\n\t\t\t/* Check double suffix rule */\n\t\t\tsuffix = g_hash_table_get_keys (project->suffix);\n\t\t\t\n\t\t\tfor (src = g_list_first (suffix); src != NULL; src = g_list_next (src))\n\t\t\t{\n\t\t\t\tGList *obj;\n\n\t\t\t\tfor (obj = g_list_first (suffix); obj != NULL; obj = g_list_next (obj))\n\t\t\t\t{\n\t\t\t\t\tg_string_assign (pattern, src->data);\n\t\t\t\t\tg_string_append (pattern, obj->data);\n\n\t\t\t\t\tif (strcmp (pattern->str, rule->name) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\trule->pattern = TRUE;\n\t\t\t\t\t\trule->part = rule->name + strlen (src->data);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (rule->pattern) break;\n\t\t\t}\n\n\t\t\tg_string_free (pattern, TRUE);\n\t\t\tg_list_free (suffix);\n\t\t}\n\t}\n\n\t/* Create new target */\n\tfor (g_hash_table_iter_init (&iter, project->rules); g_hash_table_iter_next (&iter, (gpointer)&key, (gpointer)&rule);)\n\t{\n\t\tMkpTarget *target;\n\t\tAnjutaToken *prerequisite;\n\t\tAnjutaToken *arg;\n\n\t\tg_message (\"rule =%s=\", rule->name);\n\t\tif (rule->phony || rule->pattern) continue;\n\t\t\n\t\t/* Create target */\n\t\ttarget = mkp_target_new (rule->name, NULL);\n\t\tmkp_target_add_token (target, rule->rule);\n\t\tanjuta_project_node_append (parent, target);\n\n\t\t/* Get prerequisite */\n\t\tprerequisite = anjuta_token_first_word (rule->rule);\n\t\tif (prerequisite != NULL) prerequisite = anjuta_token_next_word (prerequisite);\n\t\tif (prerequisite != NULL) prerequisite = anjuta_token_next_word (prerequisite);\n\t\t\n\t\t/* Add prerequisite */\n\t\tfor (arg = anjuta_token_first_word (prerequisite); arg != NULL; arg = anjuta_token_next_word (arg))\n\t\t{\n\t\t\tMkpSource *source;\n\t\t\tGFile *src_file;\n\t\t\tgchar *name;\n\n\t\t\tname = anjuta_token_evaluate (arg);\n\t\t\tif (name != NULL)\n\t\t\t{\n\t\t\t\tname = g_strstrip (name);\n\t\t\t\tname = mkp_project_find_source (project, name, parent, 0);\n\t\t\t}\n\n\t\t\tif (name != NULL)\n\t\t\t{\n\t\t\t\tsrc_file = g_file_get_child (project->root_file, name);\n\t\t\t\tsource = mkp_source_new (src_file);\n\t\t\t\tg_object_unref (src_file);\n\t\t\t\tanjuta_project_node_append (target, source);\n\n\t\t\t\tg_free (name);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}", "path": "src\\mk-rule.c", "repo_name": "sgranjoux/projectparser", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 784}
{"docstring": "/* Rule object\n *---------------------------------------------------------------------------*/\n", "func_signal": "static MkpRule*\nmkp_rule_new (gchar *name, AnjutaToken *token)", "code": "{\n    MkpRule *rule = NULL;\n\n\tg_return_val_if_fail (name != NULL, NULL);\n\t\n\trule = g_slice_new0(MkpRule); \n\trule->name = g_strdup (name);\n\trule->rule = token;\n\n\treturn rule;\n}", "path": "src\\mk-rule.c", "repo_name": "sgranjoux/projectparser", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 784}
{"docstring": "/* Constructor & Destructor\n *---------------------------------------------------------------------------*/\n", "func_signal": "AnjutaTokenFile *\nanjuta_token_file_new (GFile *gfile)", "code": "{\n\tAnjutaTokenFile *file = g_object_new (ANJUTA_TOKEN_FILE_TYPE, NULL);\n\n\tif (gfile) file->file =  g_object_ref (gfile);\n\t\n\treturn file;\n}", "path": "libanjuta\\anjuta-token-file.c", "repo_name": "sgranjoux/projectparser", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 784}
{"docstring": "/* VOID:OBJECT,CHAR (./libanjuta-iface-marshallers.list:9) */\n", "func_signal": "void\nlibanjuta_iface_cclosure_marshal_VOID__OBJECT_CHAR (GClosure     *closure,\n                                                    GValue       *return_value G_GNUC_UNUSED,\n                                                    guint         n_param_values,\n                                                    const GValue *param_values,\n                                                    gpointer      invocation_hint G_GNUC_UNUSED,\n                                                    gpointer      marshal_data)", "code": "{\n  typedef void (*GMarshalFunc_VOID__OBJECT_CHAR) (gpointer     data1,\n                                                  gpointer     arg_1,\n                                                  gchar        arg_2,\n                                                  gpointer     data2);\n  register GMarshalFunc_VOID__OBJECT_CHAR callback;\n  register GCClosure *cc = (GCClosure*) closure;\n  register gpointer data1, data2;\n\n  g_return_if_fail (n_param_values == 3);\n\n  if (G_CCLOSURE_SWAP_DATA (closure))\n    {\n      data1 = closure->data;\n      data2 = g_value_peek_pointer (param_values + 0);\n    }\n  else\n    {\n      data1 = g_value_peek_pointer (param_values + 0);\n      data2 = closure->data;\n    }\n  callback = (GMarshalFunc_VOID__OBJECT_CHAR) (marshal_data ? marshal_data : cc->callback);\n\n  callback (data1,\n            g_marshal_value_peek_object (param_values + 1),\n            g_marshal_value_peek_char (param_values + 2),\n            data2);\n}", "path": "libanjuta\\interfaces\\libanjuta-iface-marshallers.c", "repo_name": "sgranjoux/projectparser", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 784}
{"docstring": "/* Find a source for target checking pattern rule. If no source is found,\n * return target, else free target and return a newly allocated source name */\n", "func_signal": "gchar *\nmkp_project_find_source (MkpProject *project, gchar *target, AnjutaProjectGroup *parent, guint backtrack)", "code": "{\n\tGFile *child;\n\tgboolean exist;\n\tGHashTableIter iter;\n\tgchar *key;\n\tMkpRule *rule;\n\n\t/* Check pattern rules */\n\tif (backtrack < MAX_DEPENDENCIES)\n\t{\n\t\tfor (g_hash_table_iter_init (&iter, project->rules); g_hash_table_iter_next (&iter, (gpointer)&key, (gpointer)&rule);)\n\t\t{\n\t\t\tif (rule->pattern)\n\t\t\t{\n\t\t\t\tgchar *source;\n\t\t\t\t\n\t\t\t\tif (rule->part == NULL)\n\t\t\t\t{\t\n\t\t\t\t\t/* simple suffix rule */\n\t\t\t\t\tsource = g_strconcat (target, rule->name, NULL);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* double suffix rule */\n\t\t\t\t\tif (strcmp (target + strlen (target) - strlen (rule->part), rule->part) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tgchar *suffix;\n\n\t\t\t\t\t\tsource = g_strconcat (target, rule->name, NULL);\n\t\t\t\t\t\tsuffix = source + strlen (target) - strlen (rule->part);\n\n\t\t\t\t\t\tmemcpy (suffix, rule->name, rule->part - rule->name);\n\t\t\t\t\t\t*(suffix + (rule->part - rule->name)) = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\tsource = mkp_project_find_source (project, source, parent, backtrack + 1);\n\n\t\t\t\tif (source != NULL)\n\t\t\t\t{\n\t\t\t\t\tg_free (target);\n\n\t\t\t\t\treturn source;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\t\n\tchild = g_file_get_child (anjuta_project_group_get_directory (parent), target);\n\texist = g_file_query_exists (child, NULL);\n\tg_message (\"target =%s= filename =%s=\", target, g_file_get_parse_name (child));\n\tg_object_unref (child);\n\n\tif (!exist)\n\t{\n\t\tg_free (target);\n\t\treturn NULL;\n\t}\n\telse\n\t{\n\t\treturn target;\n\t}\n}", "path": "src\\mk-rule.c", "repo_name": "sgranjoux/projectparser", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 784}
{"docstring": "/* VOID:INT,INT (./libanjuta-iface-marshallers.list:5) */\n", "func_signal": "void\nlibanjuta_iface_cclosure_marshal_VOID__INT_INT (GClosure     *closure,\n                                                GValue       *return_value G_GNUC_UNUSED,\n                                                guint         n_param_values,\n                                                const GValue *param_values,\n                                                gpointer      invocation_hint G_GNUC_UNUSED,\n                                                gpointer      marshal_data)", "code": "{\n  typedef void (*GMarshalFunc_VOID__INT_INT) (gpointer     data1,\n                                              gint         arg_1,\n                                              gint         arg_2,\n                                              gpointer     data2);\n  register GMarshalFunc_VOID__INT_INT callback;\n  register GCClosure *cc = (GCClosure*) closure;\n  register gpointer data1, data2;\n\n  g_return_if_fail (n_param_values == 3);\n\n  if (G_CCLOSURE_SWAP_DATA (closure))\n    {\n      data1 = closure->data;\n      data2 = g_value_peek_pointer (param_values + 0);\n    }\n  else\n    {\n      data1 = g_value_peek_pointer (param_values + 0);\n      data2 = closure->data;\n    }\n  callback = (GMarshalFunc_VOID__INT_INT) (marshal_data ? marshal_data : cc->callback);\n\n  callback (data1,\n            g_marshal_value_peek_int (param_values + 1),\n            g_marshal_value_peek_int (param_values + 2),\n            data2);\n}", "path": "libanjuta\\interfaces\\libanjuta-iface-marshallers.c", "repo_name": "sgranjoux/projectparser", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 784}
{"docstring": "/*-------------------------------------------------------------------------\n *\n *  NAME          WriteScreenDescriptor\n *\n *  DESCRIPTION   Output a screen descriptor to the current GIF-file\n *\n *  INPUT         sd      pointer to screen descriptor to output\n *\n *  RETURNS       GIF_OK       - OK\n *                GIF_ERRWRITE - Error writing to the file\n */\n", "func_signal": "static int\nWriteScreenDescriptor(ScreenDescriptor *sd)", "code": "{\n    Byte tmp;\n\n    if (WriteWord(sd->LocalScreenWidth) != GIF_OK)\n        return GIF_ERRWRITE;\n    if (WriteWord(sd->LocalScreenHeight) != GIF_OK)\n        return GIF_ERRWRITE;\n    tmp = (sd->GlobalColorTableFlag << 7)\n          | (sd->ColorResolution << 4)\n          | (sd->SortFlag << 3)\n          | sd->GlobalColorTableSize;\n    if (WriteByte(tmp) != GIF_OK)\n        return GIF_ERRWRITE;\n    if (WriteByte(sd->BackgroundColorIndex) != GIF_OK)\n        return GIF_ERRWRITE;\n    if (WriteByte(sd->PixelAspectRatio) != GIF_OK)\n        return GIF_ERRWRITE;\n\n    return GIF_OK;\n}", "path": "src\\gifsave.c", "repo_name": "denever/linrad-rev", "stars": 1, "license": "None", "language": "c", "size": 808}
{"docstring": "/*-------------------------------------------------------------------------\n *\n *  NAME          ResetOutBitFile\n *\n *  DESCRIPTION   Tidy up after using a bitfile\n *\n *  RETURNS       0 - OK, -1 - error\n */\n", "func_signal": "static int\nResetOutBitFile(void)", "code": "{\n    Byte numbytes;\n\n    /* how much is in the buffer? */\n    numbytes = Index + (BitsLeft == 8 ? 0 : 1);\n\n    /* write whatever is in the buffer to the file */\n    if (numbytes) {\n        if (WriteByte(numbytes) != GIF_OK)\n            return -1;\n\n        if (Write(Buffer, numbytes) != GIF_OK)\n            return -1;\n\n        Buffer[Index = 0] = 0;\n        BitsLeft = 8;\n    }\n    return 0;\n}", "path": "src\\gifsave.c", "repo_name": "denever/linrad-rev", "stars": 1, "license": "None", "language": "c", "size": 808}
{"docstring": "// *********************************************************************\n// Thread entries for Linux\n// *********************************************************************\n", "func_signal": "void thread_main_menu(void)", "code": "{\nint i;\nmain_menu();\ni=0;\npthread_exit(&i);\n}", "path": "src\\lxsys.c", "repo_name": "denever/linrad-rev", "stars": 1, "license": "None", "language": "c", "size": 808}
{"docstring": "// Prototype for user defined hardware drive routines.\n// These routines will replace the routines in hwaredriver.c\n// in case a routine users_hwaredriver.c is present when configure is run.\n// The Linrad package does not contain a users_hwaredriver.c file\n// so it is safe to copy a nev version on top of an old one.\n// The users_hwaredriver.c file will not be overwritten.\n", "func_signal": "void update_users_rx_frequency(void)", "code": "{};\n\n\nvoid hware_set_rxtx(int state)\n{\n// Use state to set your Rx/Tx switching.\nint i;\ni=state;\n}", "path": "src\\users.c", "repo_name": "denever/linrad-rev", "stars": 1, "license": "None", "language": "c", "size": 808}
{"docstring": "// *********************************************************\n// Graphics for X11\n// *********************************************************\n", "func_signal": "void lir_getpalettecolor(int j, int *r, int *g, int *b)", "code": "{\nint k;\nunsigned short int *ipalette;\nswitch (color_depth)\n  {\n  case 24:\n  b[0]=(int)(svga_palette[3*j  ])>>2;\n  g[0]=(int)(svga_palette[3*j+1])>>2;\n  r[0]=(int)(svga_palette[3*j+2])>>2;\n  break;\n\n  case 16:\n  ipalette=(void*)(&svga_palette[0]);\n  k=ipalette[j];\n  k<<=1;\n  b[0]=k&0x3f;\n  k>>=6;\n  g[0]=k&0x3f;\n  k>>=5;\n  r[0]=k;\n  break;\n\n  case 8:\n  b[0]=(int)(svga_palette[3*j  ]);\n  g[0]=(int)(svga_palette[3*j+1]);\n  r[0]=(int)(svga_palette[3*j+2]);\n  break;\n  }\n}", "path": "src\\xsys.c", "repo_name": "denever/linrad-rev", "stars": 1, "license": "None", "language": "c", "size": 808}
{"docstring": "//EXIT IF NO LINRAD-FREQUENCY IS SELECTED\n", "func_signal": "if(mix1_selfreq[0] < 0)", "code": "{\n  ug_msg_color=12;\n  sprintf (ug_msg0,\"NO FREQ. SELECT. ON W/F GRAPH\");\n  goto userdefined_q_exit_1;\n  }\n\n// CHECK IF TRX-FREQUENCY WITHIN RANGE AND EXIT IF NOT   \n\ntransverter_offset_raw=ug.offs_khz[ug_band_no];    //raw offset in Khz for transverter \ntransverter_offset_fine=ug.offs_hz[ug_band_no];    //fine offset in Hz for transverter \noffset_hwfreq= transverter_offset_raw +(transverter_offset_fine*.001) ; //Freq in KHz \ntransceiver_freq= (hwfreq+offset_hwfreq)*1000;\ntransceiver_freq=floor(transceiver_freq);                               //Freq in Hz \nfreq= transceiver_freq;\n\nif ((transceiver_freq < list[transceiver_number].min_transceiver_freq )\n     ||(transceiver_freq > list[transceiver_number].max_transceiver_freq))\n{\n  ug_msg_color=12;\n  sprintf (ug_msg0,\"INVALID FREQ.FOR %s\",list[transceiver_number].name); \n  goto userdefined_q_exit_2;\n}", "path": "src\\users_tr.c", "repo_name": "denever/linrad-rev", "stars": 1, "license": "None", "language": "c", "size": 808}
{"docstring": "/*-------------------------------------------------------------------------\n *\n *  NAME          InputByte\n *\n *  DESCRIPTION   Get next pixel from image. Called by the\n *                LZW_Compress()-function\n *\n *  RETURNS       Next pixelvalue, or -1 if no more pixels\n */\n", "func_signal": "static int\nInputByte(void)", "code": "{\n    int ret;\n\n    if (RelPixY >= ImageHeight)\n        return -1;\n    ret = GetPixel(ImageLeft + RelPixX, ImageTop + RelPixY);\n    if (++RelPixX >= ImageWidth) {\n        RelPixX = 0;\n        ++RelPixY;\n    }\n    return ret;\n}", "path": "src\\gifsave.c", "repo_name": "denever/linrad-rev", "stars": 1, "license": "None", "language": "c", "size": 808}
{"docstring": "/*-------------------------------------------------------------------------\n *\n *  NAME          WriteImageDescriptor\n *\n *  DESCRIPTION   Output an image descriptor to the current GIF-file\n *\n *  INPUT         id      pointer to image descriptor to output\n *\n *  RETURNS       GIF_OK       - OK\n *                GIF_ERRWRITE - Error writing to the file\n */\n", "func_signal": "static int\nWriteImageDescriptor(ImageDescriptor *id)", "code": "{\n    Byte tmp;\n\n    if (WriteByte(id->Separator) != GIF_OK)\n        return GIF_ERRWRITE;\n    if (WriteWord(id->LeftPosition) != GIF_OK)\n        return GIF_ERRWRITE;\n    if (WriteWord(id->TopPosition) != GIF_OK)\n        return GIF_ERRWRITE;\n    if (WriteWord(id->Width) != GIF_OK)\n        return GIF_ERRWRITE;\n    if (WriteWord(id->Height) != GIF_OK)\n        return GIF_ERRWRITE;\n    tmp = (id->LocalColorTableFlag << 7)\n          | (id->InterlaceFlag << 6)\n          | (id->SortFlag << 5)\n          | (id->Reserved << 3)\n          | id->LocalColorTableSize;\n    if (WriteByte(tmp) != GIF_OK)\n        return GIF_ERRWRITE;\n\n    return GIF_OK;\n}", "path": "src\\gifsave.c", "repo_name": "denever/linrad-rev", "stars": 1, "license": "None", "language": "c", "size": 808}
{"docstring": "/*-------------------------------------------------------------------------\n *\n *  NAME          FreeStrtab\n *\n *  DESCRIPTION   Free arrays used in string table routines\n */\n", "func_signal": "static void\nFreeStrtab(void)", "code": "{\n    if (StrHsh) {\n        free(StrHsh);\n        StrHsh = NULL;\n    }\n    if (StrNxt) {\n        free(StrNxt);\n        StrNxt = NULL;\n    }\n    if (StrChr) {\n        free(StrChr);\n        StrChr = NULL;\n    }\n}", "path": "src\\gifsave.c", "repo_name": "denever/linrad-rev", "stars": 1, "license": "None", "language": "c", "size": 808}
{"docstring": "// *********************************************************************\n// Thread entries for Windows\n// *********************************************************************\n", "func_signal": "DWORD WINAPI winthread_lir_server(PVOID arg)", "code": "{\nchar *c;\nc=arg;\nthread_lir_server();\nreturn 100;\n}", "path": "src\\wsys.c", "repo_name": "denever/linrad-rev", "stars": 1, "license": "None", "language": "c", "size": 808}
{"docstring": "/*-------------------------------------------------------------------------\n *\n *  NAME          AllocStrtab\n *\n *  DESCRIPTION   Allocate arrays used in string table routines\n *\n *  RETURNS       GIF_OK     - OK\n *                GIF_OUTMEM - Out of memory\n */\n", "func_signal": "static int\nAllocStrtab(void)", "code": "{\n    /* just in case */\n    FreeStrtab();\n\n    if ((StrChr = (Byte *) malloc(MAXSTR * sizeof(Byte))) == 0) {\n        FreeStrtab();\n        return GIF_OUTMEM;\n    }\n    if ((StrNxt = (Word *) malloc(MAXSTR * sizeof(Word))) == 0) {\n        FreeStrtab();\n        return GIF_OUTMEM;\n    }\n    if ((StrHsh = (Word *) malloc(HASHSIZE * sizeof(Word))) == 0) {\n        FreeStrtab();\n        return GIF_OUTMEM;\n    }\n    return GIF_OK;\n}", "path": "src\\gifsave.c", "repo_name": "denever/linrad-rev", "stars": 1, "license": "None", "language": "c", "size": 808}
{"docstring": "/*-------------------------------------------------------------------------\n *\n *  NAME          WriteWord\n *\n *  DESCRIPTION   Output one word (2 bytes with byte-swapping, like on\n *                the IBM PC) to the current OutFile.\n *\n *  INPUT         w       word to write\n *\n *  RETURNS       GIF_OK       - OK\n *                GIF_ERRWRITE - Error writing to the file\n */\n", "func_signal": "static int\nWriteWord(Word w)", "code": "{\n    if (putc(w & 0xFF, OutFile) == EOF)\n        return GIF_ERRWRITE;\n    if (putc((w >> 8), OutFile) == EOF)\n        return GIF_ERRWRITE;\n    return GIF_OK;\n}", "path": "src\\gifsave.c", "repo_name": "denever/linrad-rev", "stars": 1, "license": "None", "language": "c", "size": 808}
{"docstring": "/*-------------------------------------------------------------------------\n *\n *  NAME          ClearStrtab\n *\n *  DESCRIPTION   Mark the entire table as free, enter the 2**codesize\n *                one-byte strings, and reserve the RES_CODES reserved\n *                codes.\n *\n *  INPUT         codesize\n *                        number of bits to encode one pixel\n */\n", "func_signal": "static void\nClearStrtab(int codesize)", "code": "{\n    int q, w;\n    Word *wp;\n\n    /* no strings currently in the table */\n    NumStrings = 0;\n\n    /* mark entire hashtable as free */\n    wp = StrHsh;\n    for (q = 0; q < HASHSIZE; q++)\n        *wp++ = HASH_FREE;\n\n    /* insert 2**codesize one-character strings, and reserved codes */\n    w = (1 << codesize) + RES_CODES;\n    for (q = 0; q < w; q++)\n        AddCharString(0xFFFF, q);\n}", "path": "src\\gifsave.c", "repo_name": "denever/linrad-rev", "stars": 1, "license": "None", "language": "c", "size": 808}
{"docstring": "/*-------------------------------------------------------------------------\n *\n *  NAME          LZW_Compress\n *\n *  DESCRIPTION   Perform LZW compression as specified in the\n *                GIF-standard.\n *\n *  INPUT         codesize\n *                         number of bits needed to represent\n *                         one pixelvalue.\n *                inputbyte\n *                         function that fetches each byte to compress.\n *                         must return -1 when no more bytes.\n *\n *  RETURNS       GIF_OK     - OK\n *                GIF_OUTMEM - Out of memory\n */\n", "func_signal": "static int\nLZW_Compress(int codesize, int (*inputbyte)(void))", "code": "{\n    register int c;\n    register Word indx;\n    int  clearcode, endofinfo, numbits,errcode;\n    unsigned int limit; \n    Word prefix = 0xFFFF;\n\n    /* set up the given outfile */\n    InitBitFile();\n\n    /* set up variables and tables */\n    clearcode = 1 << codesize;\n    endofinfo = clearcode + 1;\n\n    numbits = codesize + 1;\n    limit = (1 << numbits) - 1;\n\n    if ((errcode = AllocStrtab()) != GIF_OK)\n        return errcode;\n    ClearStrtab(codesize);\n\n    /* first send a code telling the unpacker to clear the stringtable */\n    WriteBits(clearcode, numbits);\n\n    /* pack image */\n    while ((c = inputbyte()) != -1) {\n        /* now perform the packing. check if the prefix + the new\n         *  character is a string that exists in the table */\n        if ((indx = FindCharString(prefix, c)) != 0xFFFF) {\n            /* the string exists in the table. make this string the\n             * new prefix.  */\n            prefix = indx;\n        } else {\n            /* the string does not exist in the table. first write\n             * code of the old prefix to the file. */\n            WriteBits(prefix, numbits);\n\n            /* add the new string (the prefix + the new character) to\n             * the stringtable */\n            if (AddCharString(prefix, c) > limit) {\n                if (++numbits > 12) {\n                    WriteBits(clearcode, numbits - 1);\n                    ClearStrtab(codesize);\n                    numbits = codesize + 1;\n                }\n                limit = (1 << numbits) - 1;\n            }\n\n            /* set prefix to a string containing only the character\n             * read. since all possible one-character strings exists\n             * int the table, there's no need to check if it is found. */\n            prefix = c;\n        }\n    }\n\n    /* end of info is reached. write last prefix. */\n    if (prefix != 0xFFFF)\n        WriteBits(prefix, numbits);\n\n    /* erite end of info -mark, flush the buffer, and tidy up */\n    WriteBits(endofinfo, numbits);\n    ResetOutBitFile();\n    FreeStrtab();\n\n    return GIF_OK;\n}", "path": "src\\gifsave.c", "repo_name": "denever/linrad-rev", "stars": 1, "license": "None", "language": "c", "size": 808}
{"docstring": "// **************************************************************************\n// ****        END ROUTINES FOR PROCESSING Q-KEY REQUESTS                 ***\n// **************************************************************************\n", "func_signal": "void update_users_rx_frequency(void)", "code": "{\n// This routine is called from the screen thread.\nif(fabs(hwfreq-old_hwfreq) > 0.001)\n  {\n  ug_msg_color=10;\n  sprintf (ug_msg0,\"LINRAD FREQ= \");\n  edit_ugmsg(ug_msg0,floor(hwfreq*1000));\n  hide_mouse(ug.xleft, ug.xright,ug.ytop,ug.ybottom);\n  sprintf (ug_msg1,\"PRESS Q-KEY TO SET TRX FREQ\");\n  sprintf (ug_msg2,\" \");\n  show_user_parms();\n  settextcolor(7);\n  }\n}", "path": "src\\users_tr.c", "repo_name": "denever/linrad-rev", "stars": 1, "license": "None", "language": "c", "size": 808}
{"docstring": "/*-------------------------------------------------------------------------\n *\n *  NAME          GIF_SetColor\n *\n *  DESCRIPTION   Set red, green and blue components of one of the\n *                colors. The color components are all in the range\n *                [0, (1 << BitsPrPrimColor) - 1]\n *\n *  INPUT         colornum\n *                        color number to set. [0, NumColors - 1]\n *                red     red component of color\n *                green   green component of color\n *                blue    blue component of color\n */\n", "func_signal": "void\nGIF_SetColor(int colornum, int red, int green, int blue)", "code": "{\n    long maxcolor;\n    Byte *p;\n\n    maxcolor = (1L << BitsPrPrimColor) - 1L;\n    p = ColorTable + colornum * 3;\n    *p++ = (Byte) ((red * 255L) / maxcolor);\n    *p++ = (Byte) ((green * 255L) / maxcolor);\n    *p++ = (Byte) ((blue * 255L) / maxcolor);\n}", "path": "src\\gifsave.c", "repo_name": "denever/linrad-rev", "stars": 1, "license": "None", "language": "c", "size": 808}
{"docstring": "/*-------------------------------------------------------------------------\n *\n *  NAME          GIF_Close\n *\n *  DESCRIPTION   Close the GIF-file\n *\n *  RETURNS       GIF_OK       - OK\n *                GIF_ERRWRITE - Error writing to file\n */\n", "func_signal": "int\nGIF_Close(void)", "code": "{\n    ImageDescriptor ID;\n\n    /* initiate and write ending image descriptor */\n    ID.Separator = ';';\n    if (WriteImageDescriptor(&ID) != GIF_OK) return GIF_ERRWRITE;\n    fclose(OutFile);\n\n    /* release color table */\n    if (ColorTable) {\n        free(ColorTable);\n        ColorTable = NULL;\n    }\n\n    return GIF_OK;\n}", "path": "src\\gifsave.c", "repo_name": "denever/linrad-rev", "stars": 1, "license": "None", "language": "c", "size": 808}
{"docstring": "// *************************************************************\n// Set global parameters and the corresponding dummy routines.\n// *************************************************************\n", "func_signal": "void win_global_uiparms(int wn)", "code": "{\nchar s[80], ss[80], st[80], sr[80], su[80];\nint line;\nline=0;\nui.vga_mode=12;\nui.mouse_speed=8;\nif(ui.newcomer_mode!=0)\n  {\n  ui.font_scale=2;\n  ui.process_priority=1;\n  ui.parport=0;\n  ui.parport_pin=0;\n  ui.max_blocked_cpus=0;\n  }\nelse\n  {    \n  sprintf(s,\"Enter font scale (1 to 5)\"); \nfntc:;\n  if(wn==0)\n    {\n    printf(\"\\n%s, then press Enter: \",s); \n    fgets(ss,8,stdin);\n    lir_inkey=toupper(ss[0]);\n    }\n  else\n    {\n    clear_screen();\n    if(screen_width > 640)ui.vga_mode=11;\n    if(screen_width > 800)ui.vga_mode=12;\n    lir_text(0,line,s);\n    toupper_await_keyboard();\n    if(kill_all_flag) return;\n    line++;\n    if(line>=screen_last_line)line--;\n    }\n  if(lir_inkey < '1' || lir_inkey > '5')goto fntc;\n  ui.font_scale=lir_inkey-'0';\n  sprintf(s,\"Set process priority (0=NORMAL to 3=REALTIME)\"); \nprio:;\n  if(wn==0)\n    {\n    printf(\"\\n%s, then press Enter: \",s); \n    fgets(ss,8,stdin);\n    lir_inkey=toupper(ss[0]);\n    }  \n  else\n    {\n    clear_screen();\n    lir_text(0,7,s);\n    toupper_await_keyboard();\n    }\n  if(lir_inkey >='0' && lir_inkey <= '3')\n    {\n    ui.process_priority=lir_inkey-'0';\n    }\n  else\n    {\n    goto prio;\n    }\n  sprintf(s,\"Parport address (lpt1=888, none=0):\"); \nparport_gtnum:;\n  ui.vga_mode=10;\n  if(wn==0)\n    {\n    printf(\"\\n%s\\n=>\",s); \n    fgets(ss,8,stdin);\n    sscanf(ss,\"%d\", &ui.parport);\n    if(ui.parport < 0)goto parport_gtnum;\n    }\n  else\n    {\n    clear_screen();\n    lir_text(0,3,s);\n    ui.parport=lir_get_integer(36,3,5,0,99999);\n    }\n  if(ui.parport != 0)\n    {\n    sprintf (s,\"Parport read pin (ACK=10):\");\ngtpin:;\n    if(wn==0)\n      {\n      printf(\"\\n%s\\n=>\",s); \n      fgets(ss,8,stdin);\n      sscanf(ss,\"%d\", &ui.parport_pin);\n      }\n    else\n      {\n      clear_screen();\n      lir_text(0,4,s);\n      ui.parport_pin=lir_get_integer(27,4,2,10,15);\n      }\n    if( ui.parport_pin ==14 ||\n            ui.parport_pin > 15 ||\n                ui.parport_pin < 10) goto gtpin;\n    }    \n  else\n    {\n    ui.parport_pin=0;\n    }\n  if(no_of_processors > 1)\n    {\n    sprintf(s,\"This system has % d processors.\",no_of_processors);\n    sprintf(ss,\"How many do you allow Linrad to block?\");\n    sprintf(sr,\n        \"If you run several instances of Linrad on one multiprocessor\");\n    sprintf(st,\"platform it may be a bad idea to allow the total number\");\n    sprintf(su,\"of blocked CPUs to be more that the total number less one.\");        \n    if(wn==0)\n      {\n      printf(\"\\n%s\",s); \n      printf(\"\\n%s\",ss); \n      printf(\"\\n%s\",sr); \n      printf(\"\\n%s\",st); \n      printf(\"\\n%s\\n\\n=>\",su); \n      while(fgets(ss,8,stdin)==NULL);\n      sscanf(ss,\"%d\", &ui.max_blocked_cpus);\n      if(ui.max_blocked_cpus <0)ui.max_blocked_cpus=0;\n      if(ui.max_blocked_cpus >=no_of_processors)\n                                          ui.max_blocked_cpus=no_of_processors;\n      }\n    else\n      {\n      line++;\n      lir_text(0,line,s);\n      line++;\n      lir_text(0,line,ss);\n      line++;\n      lir_text(0,line,sr);\n      line++;\n      lir_text(0,line,st);\n      line++;\n      lir_text(0,line,su);\n      line+=2;\n      lir_text(0,line,\"=>\");\n      ui.max_blocked_cpus=lir_get_integer(3,line,2,0,no_of_processors-1);\n      }\n    }    \n  else\n    {\n    ui.max_blocked_cpus=0;\n    }  \n  }\nsprintf(s,\"Percentage of screen width to use:\"); \nparport_wfac:;\nif(wn==0)\n  {\n  printf(\"\\n%s\\n=>\",s); \n  fgets(ss,8,stdin);\n  sscanf(ss,\"%d\", &ui.screen_width_factor);\n  if(ui.screen_width_factor < 25 ||\n     ui.screen_width_factor > 100)goto parport_wfac;\n  }\nelse\n  {\n  clear_screen();\n  lir_text(0,6,s);\n  ui.screen_width_factor=lir_get_integer(36,6,3,0,100);\n  }\nsprintf(s,\"Percentage of screen height to use:\"); \nparport_hfac:;\nif(wn==0)\n  {\n  printf(\"\\n%s\\n=>\",s); \n  fgets(ss,8,stdin);\n  sscanf(ss,\"%d\", &ui.screen_height_factor);\n  if(ui.screen_height_factor < 25 ||\n     ui.screen_height_factor > 100)goto parport_hfac;\n  printf(\"\\n\\nLinrad will now open another window.\");\n  printf(\"\\nMinimize this window and click on the new window to continue.\");\n  printf(\n      \"\\n\\nDo not forget to save your parameters with 'W' in the main menu\");\n  fflush(NULL);\n  }\nelse\n  {\n  clear_screen();\n  lir_text(0,7,s);\n  ui.screen_height_factor=lir_get_integer(36,7,3,0,100);\n  }\nif(wn != 0)\n  {\n  if( ui.newcomer_mode != 0)\n    {\n    clear_screen();\n    lir_text(0,7,\"You are now in newcomer mode.\");\n    lir_text(0,9,\"Press 'Y' to change to normal mode or 'N' to\");\n    lir_text(0,10,\"stay in newcomer mode.\");\nask_newco:;\n    await_processed_keyboard();\n    if(lir_inkey == 'N')goto stay_newco;\n    if(lir_inkey != 'Y')goto ask_newco;\n    ui.newcomer_mode=0;\n    }\nstay_newco:;\n  clear_screen();\n  settextcolor(15);\n  lir_text(0,3,\"Save the new parameters with 'W' in the main menu.\");\n  lir_text(0,5,\"Then exit and restart Linrad for any new\");\n  lir_text(0,6,\"screen parameter to take effect.\");\n  lir_text(5,8,press_any_key);\n  await_keyboard();\n  clear_screen();\n  settextcolor(7);\n  }\n}", "path": "src\\wsys.c", "repo_name": "denever/linrad-rev", "stars": 1, "license": "None", "language": "c", "size": 808}
{"docstring": "// Define your parameters in this structure.\n// Save it to a file and recover it from init_users_control_window(void)\n", "func_signal": "void init_users_control_window(void)", "code": "{\nchar *w3szfile[10]={\"aajunkfile\"}; \nFILE *Fp;\nswitch (rx_mode)\n  {\n\ncase MODE_WCW:\n\t*w3szfile=\"aawcw_file\";  \n\tbreak;\n  case MODE_HSMS:\n   \t*w3szfile=\"aahsmsfile\"; \n  case MODE_QRSS:\n \t*w3szfile=\"aaqrssfile\"; \n  break;\n  \n  case MODE_NCW:\n \t*w3szfile=\"aancw_file\"; \n  case MODE_SSB:\n\t*w3szfile=\"aassb_file\";\n break;\n  \n  case MODE_FM:\n \t*w3szfile=\"aafm__file\"; \n  case MODE_AM:\n \t*w3szfile=\"aaam__file\"; \n  case MODE_TXTEST:\n \t*w3szfile=\"aatxtefile\"; \n  case MODE_RX_ADTEST:\n \t*w3szfile=\"aarxadfile\"; \n  case MODE_TUNE:\n \t*w3szfile=\"aatunefile\";\n\n  break;\n  }\nFp=fopen(*w3szfile,\"r\");\nif(Fp == NULL)\n  {\n// Set initial values if there is no file.\n  ug.xleft=0;\n  ug.ytop=0;\n  ug.par1=0.0;\n  ug.par2=0.0;\n  }\nelse\n  {\n  fscanf(Fp,\"%d%d%f%f\",&ug.xleft,&ug.ytop,&ug.par1,&ug.par2);\n  fclose(Fp);\n  }\nug.xright=ug.xleft+25*text_width;\nug.ybottom=ug.ytop+3.5*text_height;\n\nusers_graph_scro=no_of_scro;\nmake_users_control_graph();\nno_of_scro++;\nif(no_of_scro >= MAX_SCRO)lirerr(89);\n}", "path": "src\\users_w3sz.c", "repo_name": "denever/linrad-rev", "stars": 1, "license": "None", "language": "c", "size": 808}
{"docstring": "/*-------------------------------------------------------------------------\n *\n *  NAME          Write\n *\n *  DESCRIPTION   Output bytes to the current OutFile.\n *\n *  INPUT         buf     pointer to buffer to write\n *                len     number of bytes to write\n *\n *  RETURNS       GIF_OK       - OK\n *                GIF_ERRWRITE - Error writing to the file\n */\n", "func_signal": "static int\nWrite(const void *buf, unsigned len)", "code": "{\n    if (fwrite(buf, sizeof(Byte), len, OutFile) < len)\n        return GIF_ERRWRITE;\n    return GIF_OK;\n}", "path": "src\\gifsave.c", "repo_name": "denever/linrad-rev", "stars": 1, "license": "None", "language": "c", "size": 808}
{"docstring": "/* EXPORT-> HDrawLines: Draw multiple lines */\n", "func_signal": "void HDrawLines(HWin win, HPoint *points, int n)", "code": "{\n#ifdef WINGRAFIX\n   POINT winPoints[MAX_POINT];\n   int i;\n   HDC dc;\n   HGDIOBJ oldObject;\n\n   if (n>MAX_POINT)\n      HError(6815, \"HDrawLines: can only specify up to %d points\",MAX_POINT);\n   for(i=0; i<n; i++) {\n      winPoints[i].x=points[i].x;\n      winPoints[i].y=points[i].y;\n   }\n   dc = GetDC(win->theWindow);\n   oldObject = SelectObject(win->memDC,win->thePen);\n   Polyline(win->memDC, winPoints, n);\n   SelectObject(win->memDC,oldObject);\n   oldObject = SelectObject(dc,win->thePen);\n   Polyline(dc, winPoints, n);\n   SelectObject(dc,oldObject);\n   ReleaseDC(win->theWindow,dc);\n#endif\n#ifdef XGRAFIX\n\n    XDrawLines(win->theDisp, win->theWindow, win->theGC, (XPoint *) points, n, CoordModeOrigin);\n    XDrawLines(win->theDisp, win->thePixmap, win->theGC, (XPoint *) points, n, CoordModeOrigin);\n    win->redraw=TRUE;\n\n#endif\n}", "path": "atk160\\HTKLib\\HGraf.c", "repo_name": "terjegu/Cutemaze", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 8074}
{"docstring": "/* EXPORT-> HSetColour: Set current colour to c */\n", "func_signal": "void HSetColour(HWin win, HColour c)", "code": "{\n#ifdef WINGRAFIX\n   win->curColour = RGB(colours[c][0],colours[c][1],colours[c][2]);\n   if (win->theBrush) DeleteObject(win->theBrush);\n   win->theBrush = CreateSolidBrush(win->curColour);\n   if (win->thePen) DeleteObject(win->thePen);\n   win->thePen = CreatePen(PS_SOLID,win->lineWidth,win->curColour);\n   if (win->thinPen) DeleteObject(win->thinPen);\n   win->thinPen = CreatePen(PS_SOLID,1,win->curColour);\n#endif\n#ifdef XGRAFIX\n   XferMode  xf;\n\n\n   for (xf = GCOPY; xf < GINVERT; xf=(XferMode) (xf+1))   /* change all GCs except GINVERT*/\n     XSetForeground(win->theDisp, win->gcs[(int) xf], colours[(int) c]);\n   /*  XUnlockDisplay(win->theDisp); */\n#endif\n}", "path": "atk160\\HTKLib\\HGraf.c", "repo_name": "terjegu/Cutemaze", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 8074}
{"docstring": "/* EXPORT-> HDrawLine: Draw one line */\n", "func_signal": "void HDrawLine(HWin win, int x0, int y0, int x1, int y1)", "code": "{\n#ifdef WINGRAFIX\n   HDC dc = GetDC(win->theWindow);\n   HGDIOBJ oldObject = SelectObject(win->memDC,win->thePen);\n\n   MoveToEx(win->memDC,x0,y0,NULL);\n   LineTo(win->memDC,x1,y1);\n   SelectObject(win->memDC,oldObject);\n   oldObject = SelectObject(dc,win->thePen);\n   MoveToEx(dc,x0,y0,NULL);\n   LineTo(dc,x1,y1);\n   SelectObject(dc,oldObject);\n   ReleaseDC(win->theWindow,dc);\n#endif\n#ifdef XGRAFIX\n\n   XDrawLine(win->theDisp, win->theWindow, win->theGC, x0, y0, x1, y1);\n   XDrawLine(win->theDisp, win->thePixmap, win->theGC, x0, y0, x1, y1);\n\n   win->redraw=TRUE;\n#endif\n}", "path": "atk160\\HTKLib\\HGraf.c", "repo_name": "terjegu/Cutemaze", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 8074}
{"docstring": "/* DecodeKeyPress: decode the given keypress into char+modifier */\n", "func_signal": "static void DecodeKeyPress(XKeyEvent *xkev, HEventRec *hev)", "code": "{\n   char buf[20];\n   int n;\n   KeySym key;\n   XComposeStatus compose;\n\n   n = XLookupString(xkev,buf,20,&key,&compose);\n   hev->c = buf[0];\n   switch (key) {\n   case XK_Shift_L:\n   case XK_Shift_R:\n      hev->ktype = SHIFTKEY;\n      break;\n   case XK_Control_L:\n   case XK_Control_R:\n      hev->ktype = CONTROLKEY;\n      break;\n   case XK_Meta_L:\n   case XK_Meta_R:\n   case XK_Alt_L:\n   case XK_Alt_R:\n      hev->ktype = COMMANDKEY;\n      break;\n   case XK_Return:\n   case XK_KP_Enter:\n      hev->ktype = ENTERKEY;\n      break;\n   case XK_Escape:\n      hev->ktype = ESCKEY;\n      break;\n   case XK_BackSpace:\n   case XK_Delete:\n      hev->ktype = DELKEY;\n      break;\n   default:\n      hev->ktype = NORMALKEY;\n   }\n}", "path": "atk160\\HTKLib\\HGraf.c", "repo_name": "terjegu/Cutemaze", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 8074}
{"docstring": "/* EXPORT->HGetEvent: return next relevant event in event queue */\n", "func_signal": "HEventRec HGetEvent(HWin win, void (*action)(void))", "code": "{\n  HEventRec r={0,0,0,0,0};\n  static KeyType SavedKeyType;\n  Boolean hasEvent = FALSE;\n#ifdef WINGRAFIX\n  HWND theWindow = NULL;\n  MSG msg;\n\n  if (win!=NULL) theWindow=win->theWindow;\n  do {\n     if (action==NULL) {\n        if(GetMessage(&msg,theWindow,0,0)==0){\n           r.event=HQUIT;\n           return r;\n        }\n        hasEvent=TRUE;\n     } else {\n        hasEvent=PeekMessage(&msg,theWindow,0,0,PM_REMOVE);\n     }\n\n     if (hasEvent) {\n        TranslateMessage(&msg);\n        switch (msg.message) {\n      case WM_HTMONUPD:     /* sent when monitor display needs updating */\n         r.event = HTMONUPD;\n         break;\n      case WM_AUDOUT:\n         r.event = HAUDOUT;\n         break;\n      case WM_HTBUFFER:        /* sent when status of a buffer changes */\n         r.event = HTBUFFER;\n         r.c = (unsigned char) msg.wParam; /* id supplied by a listener */\n         break;\n      case WM_LBUTTONDOWN:\n         r.event = HMOUSEDOWN;\n\tr.x = MousePos.x = LOWORD(msg.lParam);\n\tr.y = MousePos.y = HIWORD(msg.lParam);\n\tSetCapture(theWindow);\n\tbreak;\n      case WM_LBUTTONUP:\n\tr.event = HMOUSEUP;\n\tr.x = MousePos.x = LOWORD(msg.lParam);\n\tr.y = MousePos.y = HIWORD(msg.lParam);\n\tReleaseCapture();\n\tbreak;\n      case WM_MOUSEMOVE:\n\tr.event = HMOUSEMOVE;\n\tr.x = MousePos.x = LOWORD(msg.lParam);\n\tr.y = MousePos.y = HIWORD(msg.lParam);\n\tbreak;\n#ifdef CAPTURE_ALT     /* alt key events are normally intended for the system */\n      case WM_SYSKEYDOWN:\n\tr.c = (unsigned char) msg.wParam;\n\tif (r.c == VK_MENU) {\n\t  r.ktype = COMMANDKEY;\n\t  r.event = HKEYPRESS;\n\t  r.x = MousePos.x;\n\t  r.y = MousePos.y;\n\t  AltKeyState = ALT_DOWN;\n\t  break;\n\t} /* else fall through to regular keydown */\n#endif\n      case WM_KEYDOWN:\n\tr.event = HKEYPRESS;\n\tr.x = MousePos.x;\n\tr.y = MousePos.y;\n\tr.c = (unsigned char) msg.wParam;\n\tSavedKeyType = r.ktype = HGetKeyType(r.c);\n\tif ((r.c != VK_DELETE) &&\n\t    (r.ktype != LEFTARROWKEY) &&\n\t    (r.ktype != RIGHTARROWKEY) &&\n\t    (r.ktype != CONTROLKEY) &&\n\t    (r.ktype != COMMANDKEY) &&\n\t    (r.ktype != SHIFTKEY))\n\t  hasEvent = FALSE; /* other keys will be processed by WM_CHAR */\n\t/* message which should arrive shortly */\n\tbreak;\n#ifdef CAPTURE_ALT\n      case WM_SYSCHAR:\n#endif\n      case WM_CHAR:\n\tr.event = HKEYPRESS;\n\tr.x = MousePos.x;\n\tr.y = MousePos.y;\n\tr.c = (unsigned char) msg.wParam;\n\tr.ktype = SavedKeyType; //HGetKeyType(r.c);\n\tbreak;\n#ifdef CAPTURE_ALT\n      case WM_SYSKEYUP:\n\tr.c = (unsigned char) msg.wParam;\n\tif (r.c == VK_MENU) {\n\t  r.ktype = COMMANDKEY;\n\t  r.event = HKEYRELEASE;\n\t  r.x = MousePos.x;\n\t  r.y = MousePos.y;\n\t  AltKeyState = ALT_UP;\n\t  break;\n\t} /* else fall through to regular keydown */\n#endif\n      case WM_KEYUP:\n\tr.event = HKEYRELEASE;\n\tr.x = MousePos.x;\n\tr.y = MousePos.y;\n\tr.c = (unsigned char) msg.wParam;\n\tr.ktype = HGetKeyType(r.c);\n            break;\n      case WM_PAINT:\n\tDispatchMessage(&msg);    /* force Win32 to remove message from   */\n\t/* queue even though application is dispatching this message.     */\n\t/* Applications should actually be able to ignore HREDRAW events. */\n\t/* Fall through to next messages */\n      case WM_SIZING:\n      case WM_MOVING:\n      case WM_EXITSIZEMOVE:\n         r.event = HREDRAW;\n         break;\n      case WM_NCLBUTTONDOWN:\n         if ((int)msg.wParam == HTCLOSE) {\n            r.event = HWINCLOSE;\n            HSendAllThreadsCloseEvent();\n         }else\n            r.event = HIGNORE;\n         DispatchMessage(&msg);\n         break;\n      case WM_HREQCLOSE:        /* sent when close event has been trapped */\n         r.event = HWINCLOSE;\n         break;\n      default:\n         r.event = HIGNORE;\n         DispatchMessage(&msg); /* Win32 should handle other messages */\n        }\n     }\n    else if (action != NULL) {\n      (*action)();\n    }\n  } while (!hasEvent);\n#endif\n#ifdef XGRAFIX\n  Bool found,dummy;\n   found = False;\n   do {\n/*     if(win!=NULL)\n       HError(9999,\"Xwindows window-specific queues not supported (yet)\\n\");\n*/     if( (eventsOnQueue(HThreadSelf())!=0) || (action==NULL)) {\n       r=getEventFromQueue();\n       if(r.event != HIGNORE)\n\t found=True;\n     }\n     else {\n       (*action)();\n       HFlush();\n     }\n     HFlush();\n   }\n   while(found==False);\n#endif\n   return r;\n}", "path": "atk160\\HTKLib\\HGraf.c", "repo_name": "terjegu/Cutemaze", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 8074}
{"docstring": "/* EXPORT-> HSpoolGraf: start saving an image of window in fname */\n/* must be balanced by a call to HEndSpoolGraf() */\n", "func_signal": "void HSpoolGraf(HWin win, char *fname)", "code": "{\n#ifdef WINGRAFIX\n   int wmm,hmm; /* width and height in millimeters */\n   int wpx,hpx; /* width and height in pixels */\n   char *description = \"Created by HGraf\";\n   RECT r;\n   HDC dc = GetDC(win->theWindow);\n   int er;\n\n   wmm = GetDeviceCaps(dc, HORZSIZE);\n   hmm = GetDeviceCaps(dc, VERTSIZE);\n   wpx = GetDeviceCaps(dc, HORZRES);\n   hpx = GetDeviceCaps(dc, VERTRES);\n\n   r.left = (win->clientRect.left * wmm * 100)/wpx;\n   r.top = (win->clientRect.top * hmm * 100)/hpx;\n   r.right = (win->clientRect.right * wmm * 100)/wpx;\n   r.bottom = (win->clientRect.bottom * hmm * 100)/hpx;\n\n   win->DCSaved = win->memDC;\n   win->memDC = CreateEnhMetaFile(dc,fname,&r,description);\n   er = GetLastError();\n   ReleaseDC(win->theWindow,dc);\n   win->writingToMeta = TRUE;\n#endif\n#ifdef XGRAFIX\n\n#endif\n}", "path": "atk160\\HTKLib\\HGraf.c", "repo_name": "terjegu/Cutemaze", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 8074}
{"docstring": "/* EXPORT-> HDrawArc: Draw arc from stAngle thru arcAngle degrees */\n", "func_signal": "void HDrawArc(HWin win, int x0, int y0, int x1, int y1, int stAngle, int arcAngle)", "code": "{\n#ifdef WINGRAFIX\n   int Center_x = (x0+x1)/2;\n   int Center_y = (y0+y1)/2;\n   int StartArc_x, StartArc_y;\n   int EndArc_x, EndArc_y;\n   int radius; /* major axis */\n   double startAngle, endAngle,convrt = PI/180; /* degrees to radians */\n   HGDIOBJ oldObject = SelectObject(win->memDC,win->thePen);\n   HDC dc = GetDC(win->theWindow);\n   CheckCorners(&x0,&y0,&x1,&y1);\n   startAngle = stAngle*convrt;\n   endAngle = (arcAngle+stAngle)*convrt;\n   radius = (((x1-x0) > (y1-y0)) ? x1-x0 : y1-y0)/2;\n   StartArc_x = Center_x + (int) (radius * cos((double) startAngle));\n   StartArc_y = Center_y - (int) (radius * sin((double) startAngle));\n   EndArc_x = Center_x + (int) (radius * cos((double) endAngle));\n   EndArc_y = Center_y - (int) (radius * sin((double) endAngle));\n   Arc(win->memDC,x0,y0,x1,y1,StartArc_x,StartArc_y,EndArc_x,EndArc_y);\n   SelectObject(win->memDC,oldObject);\n   oldObject = SelectObject(dc,win->thePen);\n   Arc(dc,x0,y0,x1,y1,StartArc_x,StartArc_y,EndArc_x,EndArc_y);\n   SelectObject(dc,oldObject);\n   ReleaseDC(win->theWindow,dc);\n#endif\n#ifdef XGRAFIX\n  unsigned int rw, rh;\n\n   CheckCorners(&x0,&y0,&x1,&y1);\n   /* calculate width and height */\n   rw = abs(x1 - x0); rh = abs(y1 - y0);\n   /* the angles are signed integers in 64ths of a degree */\n   stAngle *=64; arcAngle*=64;\n\n   XDrawArc(win->theDisp, win->theWindow, win->theGC, x0, y0, rw, rh, stAngle, arcAngle);\n XDrawArc(win->theDisp, win->thePixmap, win->theGC, x0, y0, rw, rh, stAngle, arcAngle);\n\n   win->redraw=TRUE;\n#endif\n}", "path": "atk160\\HTKLib\\HGraf.c", "repo_name": "terjegu/Cutemaze", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 8074}
{"docstring": "/* EXPORT->HEventsPending: Return number of events pending           */\n/* This doesn't seem to be supported in Win32. It is possible        */\n/* to see if the queue is empty, but there is no way to see if       */\n/* there is just one event or if there are many. This function       */\n/* should probably return a Boolean value. Currently it returns 1    */\n/* if there are one or more events pending, and 0 if there are none. */\n", "func_signal": "int HEventsPending(HWin win)", "code": "{\n#ifdef WINGRAFIX\n   MSG msg;\n   HWND theWindow = NULL;\n\n   if (win!=NULL) theWindow=win->theWindow;\n   if (PeekMessage(&msg,theWindow,0,0,PM_NOREMOVE)){\n      return 1;\n   }\n#endif\n#ifdef XGRAFIX\n   Display *display;\n   display=globDisp;\n/*   if(win!=NULL)\n     HError(9999, \"No support for number of events for window pending\");\n*/\n   return eventsOnQueue(HThreadSelf());\n#endif\n return 0;\n}", "path": "atk160\\HTKLib\\HGraf.c", "repo_name": "terjegu/Cutemaze", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 8074}
{"docstring": "/* EXPORT HTextHeight: return the height of s in pixels */\n", "func_signal": "int HTextHeight(HWin win, const char *str)", "code": "{\n#ifdef WINGRAFIX\n   SIZE size;\n\n   HGDIOBJ oldObject = SelectObject(win->memDC,win->theFont);\n   GetTextExtentPoint32(win->memDC,str,strlen(str),&size);\n   SelectObject(win->memDC,oldObject);\n   return  (size.cy);\n#endif\n#ifdef XGRAFIX\n  return win->CurrentFont->ascent + win->CurrentFont->descent;\n#endif\n\n}", "path": "atk160\\HTKLib\\HGraf.c", "repo_name": "terjegu/Cutemaze", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 8074}
{"docstring": "/* EXPORT-> HDrawRectangle: draw a rectangle */\n", "func_signal": "void HDrawRectangle(HWin win, int x0, int y0, int x1, int y1)", "code": "{\n#ifdef WINGRAFIX\n   POINT points[5];\n   HGDIOBJ oldObject = SelectObject(win->memDC,win->thePen);\n   HDC dc = GetDC(win->theWindow);\n\n   CheckCorners(&x0,&y0,&x1,&y1);\n   points[0].x = x0; points[0].y = y0;\n   points[1].x = x0; points[1].y = y1;\n   points[2].x = x1; points[2].y = y1;\n   points[3].x = x1; points[3].y = y0;\n   points[4].x = x0; points[4].y = y0;\n\n   Polyline(win->memDC, points, 5);\n   SelectObject(win->memDC,oldObject);\n   oldObject = SelectObject(dc,win->thePen);\n   Polyline(dc, points, 5);\n   SelectObject(dc,oldObject);\n   ReleaseDC(win->theWindow,dc);\n#endif\n#ifdef XGRAFIX\n   CheckCorners(&x0,&y0,&x1,&y1);\n\n   XDrawRectangle(win->theDisp, win->theWindow, win->theGC, x0, y0, x1 - x0, y1 - y0);\n   XDrawRectangle(win->theDisp, win->thePixmap, win->theGC, x0, y0, x1 - x0, y1 - y0);\n   win->redraw=TRUE;\n\n#endif\n\n}", "path": "atk160\\HTKLib\\HGraf.c", "repo_name": "terjegu/Cutemaze", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 8074}
{"docstring": "/* EXPORT-> HEndSpoolGraf: close file opened in HSpoolGraf() */\n/* It is recommended to redraw the window after this call.   */\n", "func_signal": "void HEndSpoolGraf(HWin win)", "code": "{\n#ifdef WINGRAFIX\n   win->writingToMeta = FALSE;\n   CloseEnhMetaFile(win->memDC);\n   win->memDC = win->DCSaved;\n#endif\n#ifdef XGRAFIX\n\n#endif\n}", "path": "atk160\\HTKLib\\HGraf.c", "repo_name": "terjegu/Cutemaze", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 8074}
{"docstring": "/* EXPORT-> HSetGrey: Set current colour to grey level g */\n", "func_signal": "void HSetGrey(HWin win, int g)", "code": "{\n#ifdef WINGRAFIX\n   win->curColour = RGB(greys[g],greys[g],greys[g]);\n   if (win->theBrush) DeleteObject(win->theBrush);\n   win->theBrush = CreateSolidBrush(win->curColour);\n   if (win->thePen) DeleteObject(win->thePen);\n   win->thePen = CreatePen(PS_SOLID,win->lineWidth,win->curColour);\n   if (win->thinPen) DeleteObject(win->thinPen);\n   win->thinPen = CreatePen(PS_SOLID,1,win->curColour);\n#endif\n#ifdef XGRAFIX\n   XferMode  xf;\n\n   for (xf = GCOPY; xf < GINVERT; xf=(XferMode) (xf+1))   /* change all GCs except GINVERT*/\n     XSetForeground(win->theDisp, win->gcs[(int) xf], greys[g]);\n\n#endif\n\n}", "path": "atk160\\HTKLib\\HGraf.c", "repo_name": "terjegu/Cutemaze", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 8074}
{"docstring": "/* FindWindowRec: find window rec given a window handle */\n", "func_signal": "HWin FindWindowRec(HWND w)", "code": "{\n   HWin p;\n\n   for (p=wroot; p!=NULL; p=p->next)\n      if (p->theWindow == w) return p;\n   return NULL;\n}", "path": "atk160\\HTKLib\\HGraf.c", "repo_name": "terjegu/Cutemaze", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 8074}
{"docstring": "/* EXPORT->HDrawImage: draw grey scale image stored in p */\n", "func_signal": "void HDrawImage(HWin win, unsigned char *p, int x, int y, int width, int height)", "code": "{\n#ifdef WINGRAFIX\n   HDC tdc = GetDC(win->theWindow);\n   HDC dc = CreateCompatibleDC(win->memDC);\n   HBITMAP bm = CreateCompatibleBitmap(tdc,width,height);\n   HGDIOBJ OldObject;\n\n   char *data = New(&gcheap,sizeof(BITMAPINFOHEADER) +\n                    sizeof(RGBQUAD)*MAX_GREYS);\n   BITMAPINFOHEADER *BitmapHeader = (BITMAPINFOHEADER *) data;\n   RGBQUAD *ColorTable = (RGBQUAD *) (data + sizeof(BITMAPINFOHEADER));\n   BITMAPINFO *Info = (BITMAPINFO *) data;\n\n   int i,j;\n\n   /* if the length of the scan line is not a */\n   /* multiple of four, the bitmap must be reshaped. */\n   /* SetDIBits() expects scan lines to start on word boundaries. */\n\n   int ScanLineLen = 4*(1+(width-1)/4);\n   unsigned char *reshaped = NULL;\n\n   BitmapHeader->biSize = sizeof(BITMAPINFOHEADER);\n   BitmapHeader->biWidth = width;\n   BitmapHeader->biHeight = -height;\n   BitmapHeader->biPlanes = 1;\n   BitmapHeader->biBitCount = 8;\n   BitmapHeader->biCompression = 0;\n   BitmapHeader->biSizeImage = 0;\n   BitmapHeader->biXPelsPerMeter = 0;\n   BitmapHeader->biYPelsPerMeter = 0;\n   BitmapHeader->biClrUsed = MAX_GREYS;\n   BitmapHeader->biClrImportant = MAX_GREYS;\n   for (i=0;i<MAX_GREYS;i++) {\n      ColorTable[i].rgbRed =\n         ColorTable[i].rgbBlue =\n         ColorTable[i].rgbGreen = greys[i];\n      ColorTable[i].rgbReserved = 0;\n   }\n\n   if (ScanLineLen != width) {\n      reshaped = (unsigned char *) New(&gcheap,height*ScanLineLen);\n      for (i=0;i<height;i++) {\n         for (j=0;j<width;j++) {\n            reshaped[i*ScanLineLen+j] = p[i*width+j];\n         }\n      }\n      SetDIBits(win->memDC,bm,0,height,reshaped,Info,DIB_RGB_COLORS);\n      Dispose(&gcheap,reshaped);\n   }\n   else {\n      SetDIBits(win->memDC,bm,0,height,p,Info,DIB_RGB_COLORS);\n   }\n\n   OldObject = SelectObject(dc,bm);\n   BitBlt(win->memDC,x,y,width,height,dc,0,0,SRCCOPY);\n   if (win->writingToMeta) { /* bitmap source location differs */\n      BitBlt(tdc,x,y,width,height,dc,x,y,SRCCOPY);\n   }\n   else {\n      BitBlt(tdc,x,y,width,height,dc,0,0,SRCCOPY);\n   }\n\n   DeleteDC(dc);\n   DeleteObject(bm);\n   ReleaseDC(win->theWindow,tdc);\n   Dispose(&gcheap,data);\n#endif\n#ifdef XGRAFIX\n   static XImage *xi = NULL;\n   static unsigned char *mem = NULL;\n   unsigned char *pix;\n   int i, j;\n\n\n   if (mem != p){\n     if (xi != NULL)\n       XDestroyImage(xi);\n     xi = XGetImage(win->theDisp,win->theWindow,x,y,width,height,AllPlanes,XYPixmap);\n     pix = mem = p;\n     for (j = 0; j < height; j++)\n       for (i = 0; i < width; i++)\n\t XPutPixel(xi, i, j, greys[(int) (*pix++)]);\n   }\n   XPutImage(win->theDisp, win->theWindow, win->theGC, xi, 0, 0, x, y, width, height);\n   XPutImage(win->theDisp, win->thePixmap, win->theGC, xi, 0, 0, x, y, width, height);\n\n\n#endif\n}", "path": "atk160\\HTKLib\\HGraf.c", "repo_name": "terjegu/Cutemaze", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 8074}
{"docstring": "/* EXPORT->RedrawHButtonList: redraw the whole list of buttons */\n", "func_signal": "void RedrawHButtonList(HButton *btnlst)", "code": "{\n   HButton *btnptr;\n\n   for (btnptr=btnlst; btnptr!=NULL; btnptr=btnptr->next){\n      HSetLineWidth(btnptr->win, BTN_LINE_WIDTH);\n      RedrawHButton(btnptr);\n   }\n}", "path": "atk160\\HTKLib\\HGraf.c", "repo_name": "terjegu/Cutemaze", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 8074}
{"docstring": "/* EXPORT->HDumpGraf: dump a BMP image of window into fname */\n", "func_signal": "void HDumpGraf(HWin win, char *fname)", "code": "{\n#ifdef WINGRAFIX\n   BITMAPFILEHEADER FileHeader;\n   BITMAPINFOHEADER BitmapHeader;\n   BITMAPINFO *Info;\n   int ColorTableSize;\n   int ImageSize;\n   FILE *fp;\n   char *img;\n   HDC dc = GetDC(win->theWindow);\n   HBITMAP temp = CreateCompatibleBitmap(win->memDC,1,1);\n\n   SelectObject(win->memDC,temp);\n\n   /* retrieve information about the bitmap */\n   BitmapHeader.biSize = sizeof(BITMAPINFOHEADER);\n   BitmapHeader.biBitCount = 0;\n   GetDIBits(win->memDC,win->theBitMap,0,0,NULL,(LPBITMAPINFO)&BitmapHeader,BI_RGB);\n\n   switch (BitmapHeader.biCompression) {\n   case BI_RGB:\n      if (BitmapHeader.biBitCount > 8) {\n         ColorTableSize = 0;\n      }\n      else {\n         ColorTableSize = BitmapHeader.biClrUsed*sizeof(RGBQUAD);\n      }\n      break;\n   case BI_RLE8:\n   case BI_RLE4:\n      ColorTableSize = BitmapHeader.biClrUsed*sizeof(RGBQUAD);\n      break;\n   case BI_BITFIELDS:\n      ColorTableSize = 3*sizeof(DWORD);\n   }\n\n   Info = (BITMAPINFO *) New(&gcheap,sizeof(BITMAPINFOHEADER) + ColorTableSize);\n   memcpy(Info,&BitmapHeader,sizeof(BITMAPINFOHEADER));\n\n   ImageSize = BitmapHeader.biSizeImage;\n   img = New(&gcheap,ImageSize);\n\n   GetDIBits(win->memDC,win->theBitMap,0,win->clientRect.bottom,img,Info,BI_RGB);\n\n   FileHeader.bfType = 0x4d42;  /* 'BM' */\n   FileHeader.bfSize = sizeof(BITMAPINFOHEADER) + sizeof(BITMAPFILEHEADER) +\n      ImageSize + ColorTableSize;\n   FileHeader.bfReserved1 = FileHeader.bfReserved2 = 0;\n   FileHeader.bfOffBits = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + ColorTableSize;\n\n   fp = fopen(fname,\"wb\");\n   fwrite(&FileHeader,1,sizeof(BITMAPFILEHEADER),fp);\n   fwrite(Info,1,sizeof(BITMAPINFOHEADER) + ColorTableSize,fp);\n   fwrite(img,1,ImageSize,fp);\n   fclose(fp);\n\n   SelectObject(win->memDC,win->theBitMap);\n   DeleteObject(temp);\n   Dispose(&gcheap,Info);\n   Dispose(&gcheap,img);\n#endif\n#ifdef XGRAFIX\n\n#endif\n}", "path": "atk160\\HTKLib\\HGraf.c", "repo_name": "terjegu/Cutemaze", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 8074}
{"docstring": "/* EXPORT-> HPrintf: works as printf on the graphics window at (x,y) */\n", "func_signal": "void HPrintf(HWin win, int x, int y, const char *format, ...)", "code": "{\n#ifdef WINGRAFIX\n   va_list arg;\n   char s[256];\n   HGDIOBJ oldObject = SelectObject(win->memDC,win->theFont);\n   HDC dc = GetDC(win->theWindow);\n\n   va_start(arg, format);\n   vsprintf(s, format, arg);\n   SetTextColor(win->memDC,win->curColour);\n   TextOut(win->memDC,x,y,s,strlen(s));\n   SelectObject(win->memDC,oldObject);\n\n   oldObject = SelectObject(dc,win->theFont);\n   SetTextColor(dc,win->curColour);\n   TextOut(dc,x,y,s,strlen(s));\n   SelectObject(dc,oldObject);\n   ReleaseDC(win->theWindow,dc);\n#endif\n#ifdef XGRAFIX\n   va_list arg;\n   char s[256];\n\n   va_start(arg, format);\n   vsprintf(s, format, arg);\n\n   XDrawString(win->theDisp, win->theWindow, win->theGC, x, y, s, strlen(s));\n   XDrawString(win->theDisp, win->thePixmap, win->theGC, x, y, s, strlen(s));\n\n   win->redraw=TRUE;\n#endif\n}", "path": "atk160\\HTKLib\\HGraf.c", "repo_name": "terjegu/Cutemaze", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 8074}
{"docstring": "/* CompressColours: if display has limited colour depth */\n", "func_signal": "static void CompressColours(HWin win)", "code": "{\n   int c;\n   LOGPALETTE *pal;\n   HPALETTE hpal;\n   HDC dc;\n\n   pal = (LOGPALETTE *)\n   New(&gcheap,2*sizeof(WORD) + (MAX_GREYS + MAX_COLOURS)*sizeof(PALETTEENTRY));\n   pal->palVersion = 0x300;\n   pal->palNumEntries = MAX_GREYS + MAX_COLOURS;\n\n   /* most important colors should be first in list. Black, White,\n      the rest of the colors, then the greys. */\n   pal->palPalEntry[0].peRed=pal->palPalEntry[0].peGreen=pal->palPalEntry[0].peBlue = 0;\n   pal->palPalEntry[1].peRed=pal->palPalEntry[1].peGreen=pal->palPalEntry[1].peBlue = 255;\n   pal->palPalEntry[1].peFlags = pal->palPalEntry[0].peFlags = 0;;\n   for (c=2;c<MAX_COLOURS;c++) {\n      pal->palPalEntry[c].peRed = colours[c-1][0];\n      pal->palPalEntry[c].peGreen = colours[c-1][1];\n      pal->palPalEntry[c].peBlue = colours[c-1][2];\n      pal->palPalEntry[c].peFlags = 0;\n   }\n   for (c=0;c<MAX_GREYS;c++) {\n      pal->palPalEntry[MAX_COLOURS+c].peRed = greys[c];\n      pal->palPalEntry[MAX_COLOURS+c].peGreen = greys[c];\n      pal->palPalEntry[MAX_COLOURS+c].peBlue = greys[c];\n      pal->palPalEntry[MAX_COLOURS+c].peFlags = 0;\n   }\n   hpal = CreatePalette(pal);\n   InstallPalette(hpal,win->memDC);\n   dc = GetDC(win->theWindow);\n   InstallPalette(hpal,dc);\n   ReleaseDC(win->theWindow,dc);\n   DeleteObject(hpal);\n}", "path": "atk160\\HTKLib\\HGraf.c", "repo_name": "terjegu/Cutemaze", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 8074}
{"docstring": "/* EXPORT-> HPlotVector: plot vector v in given rectangle */\n", "func_signal": "void HPlotVector(HWin win, int x0, int y0, int x1, int y1, Vector v,\n\t\t int st, int en, float ymax, float ymin)", "code": "{\n   float yScale, yOffset, xInc, x;\n   int   xOld, yOld, ix, iy, i;\n\n   if (st >= en || st < 1 || en > VectorSize(v))\n      HError(6815, \"HPlotVector: Plot indices %d -> %d out of range\", st, en);\n   x = (x1 - x0 - 1); xInc = x/(en - st);\n   yScale  = (y1 - y0)/(ymin - ymax);\n   yOffset = y0 - ymax*yScale;\n   x = x0; xOld = x; yOld = v[st]*yScale + yOffset;\n   for (i = st+1; i <= en; i++){\n      x += xInc; ix = x;\n      iy = v[i]*yScale + yOffset;\n      HDrawLine(win, xOld,yOld,ix,iy);\n      xOld = ix; yOld = iy;\n   }\n}", "path": "atk160\\HTKLib\\HGraf.c", "repo_name": "terjegu/Cutemaze", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 8074}
{"docstring": "/* EXPORT->TermHGraf: Terminate Graphics (also called via at_exit) */\n", "func_signal": "void TermHGraf()", "code": "{\n  HWin win;\n\n  for (win=wroot; win!=NULL; win=win->next)\n     CloseHWin(win);\n}", "path": "atk160\\HTKLib\\HGraf.c", "repo_name": "terjegu/Cutemaze", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 8074}
{"docstring": "/* Retrieve a string record in a remote database object. */\n", "func_signal": "char *tcrdbget2(TCRDB *rdb, const char *kstr)", "code": "{\n  assert(rdb && kstr);\n  int vsiz;\n  return tcrdbget(rdb, kstr, strlen(kstr), &vsiz);\n}", "path": "tcrdb.c", "repo_name": "xurenlu/tokyo-family", "stars": 1, "license": "lgpl-2.1", "language": "c", "size": 296}
{"docstring": "/* Retrieve a record in a remote database object. */\n", "func_signal": "void *tcrdbget(TCRDB *rdb, const void *kbuf, int ksiz, int *sp)", "code": "{\n  assert(rdb && kbuf && ksiz >= 0 && sp);\n  if(rdb->fd < 0){\n    rdb->ecode = TTEINVALID;\n    return NULL;\n  }\n  char *vbuf = NULL;\n  int rsiz = 2 + sizeof(uint32_t) + ksiz;\n  unsigned char stack[TTIOBUFSIZ];\n  unsigned char *buf = (rsiz < TTIOBUFSIZ) ? stack : tcmalloc(rsiz);\n  pthread_cleanup_push(free, (buf == stack) ? NULL : buf);\n  unsigned char *wp = buf;\n  *(wp++) = TTMAGICNUM;\n  *(wp++) = TTCMDGET;\n  uint32_t num;\n  num = TTHTONL((uint32_t)ksiz);\n  memcpy(wp, &num, sizeof(uint32_t));\n  wp += sizeof(uint32_t);\n  memcpy(wp, kbuf, ksiz);\n  wp += ksiz;\n  if(ttsocksend(rdb->sock, buf, wp - buf)){\n    int code = ttsockgetc(rdb->sock);\n    if(code == 0){\n      int vsiz = ttsockgetint32(rdb->sock);\n      if(!ttsockcheckend(rdb->sock) && vsiz >= 0){\n        vbuf = tcmalloc(vsiz + 1);\n        if(ttsockrecv(rdb->sock, vbuf, vsiz)){\n          vbuf[vsiz] = '\\0';\n          *sp = vsiz;\n        } else {\n          rdb->ecode = TTERECV;\n          tcfree(vbuf);\n          vbuf = NULL;\n        }\n      } else {\n        rdb->ecode = TTERECV;\n      }\n    } else {\n      rdb->ecode = (code == -1) ? TTERECV : TTENOREC;\n    }\n  } else {\n    rdb->ecode = TTESEND;\n  }\n  pthread_cleanup_pop(1);\n  return vbuf;\n}", "path": "tcrdb.c", "repo_name": "xurenlu/tokyo-family", "stars": 1, "license": "lgpl-2.1", "language": "c", "size": 296}
{"docstring": "/* Execute the search of a query object. */\n", "func_signal": "TCLIST *tcrdbqrysearch(RDBQRY *qry)", "code": "{\n  assert(qry);\n  TCLIST *rv = tcrdbmisc(qry->rdb, \"search\", RDBMONOULOG, qry->args);\n  if(!rv) tclistnew2(1);\n  return rv;\n}", "path": "tcrdb.c", "repo_name": "xurenlu/tokyo-family", "stars": 1, "license": "lgpl-2.1", "language": "c", "size": 296}
{"docstring": "/* Get the message string corresponding to an error code. */\n", "func_signal": "const char *tcrdberrmsg(int ecode)", "code": "{\n  switch(ecode){\n  case TTESUCCESS: return \"success\";\n  case TTEINVALID: return \"invalid operation\";\n  case TTENOHOST: return \"host not found\";\n  case TTEREFUSED: return \"connection refused\";\n  case TTESEND: return \"send error\";\n  case TTERECV: return \"recv error\";\n  case TTEKEEP: return \"existing record\";\n  case TTENOREC: return \"no record found\";\n  case TTEMISC: return \"miscellaneous error\";\n  }\n  return \"unknown error\";\n}", "path": "tcrdb.c", "repo_name": "xurenlu/tokyo-family", "stars": 1, "license": "lgpl-2.1", "language": "c", "size": 296}
{"docstring": "/* Store a string record into a remote object without response from the server. */\n", "func_signal": "bool tcrdbputnr2(TCRDB *rdb, const char *kstr, const char *vstr)", "code": "{\n  assert(rdb && kstr && vstr);\n  return tcrdbputnr(rdb, kstr, strlen(kstr), vstr, strlen(vstr));\n}", "path": "tcrdb.c", "repo_name": "xurenlu/tokyo-family", "stars": 1, "license": "lgpl-2.1", "language": "c", "size": 296}
{"docstring": "/* Set the order of a query object. */\n", "func_signal": "void tcrdbqrysetorder(RDBQRY *qry, const char *name, int type)", "code": "{\n  assert(qry && name);\n  TCXSTR *xstr = tcxstrnew();\n  tcxstrcat2(xstr, \"setorder\");\n  tcxstrcat(xstr, \"\\0\", 1);\n  tcxstrcat2(xstr, name);\n  tcxstrcat(xstr, \"\\0\", 1);\n  tcxstrprintf(xstr, \"%d\", type);\n  tclistpush(qry->args, tcxstrptr(xstr), tcxstrsize(xstr));\n  tcxstrdel(xstr);\n}", "path": "tcrdb.c", "repo_name": "xurenlu/tokyo-family", "stars": 1, "license": "lgpl-2.1", "language": "c", "size": 296}
{"docstring": "/* perform write command */\n", "func_signal": "static int procwrite(const char *host, int port, int tnum, int rnum,\n                     bool nr, const char *ext, bool rnd)", "code": "{\n  iprintf(\"<Writing Test>\\n  host=%s  port=%d  tnum=%d  rnum=%d  nr=%d  ext=%s  rnd=%d\\n\\n\",\n          host, port, tnum, rnum, nr, ext ? ext : \"\", rnd);\n  bool err = false;\n  double stime = tctime();\n  TCRDB *rdbs[tnum];\n  for(int i = 0; i < tnum; i++){\n    rdbs[i] = tcrdbnew();\n    if(!tcrdbopen(rdbs[i], host, port)){\n      eprint(rdbs[i], \"tcrdbopen\");\n      err = true;\n    }\n  }\n  TCRDB *rdb = rdbs[0];\n  TARGWRITE targs[tnum];\n  pthread_t threads[tnum];\n  if(tnum == 1){\n    targs[0].rdb = rdbs[0];\n    targs[0].rnum = rnum;\n    targs[0].nr = nr;\n    targs[0].ext = ext;\n    targs[0].rnd = rnd;\n    targs[0].id = 0;\n    if(threadwrite(targs) != NULL) err = true;\n  } else {\n    for(int i = 0; i < tnum; i++){\n      targs[i].rdb = rdbs[i];\n      targs[i].rnum = rnum;\n      targs[i].nr = nr;\n      targs[i].ext = ext;\n      targs[i].rnd = rnd;\n      targs[i].id = i;\n      if(pthread_create(threads + i, NULL, threadwrite, targs + i) != 0){\n        eprint(rdb, \"pthread_create\");\n        targs[i].id = -1;\n        err = true;\n      }\n    }\n    for(int i = 0; i < tnum; i++){\n      if(targs[i].id == -1) continue;\n      void *rv;\n      if(pthread_join(threads[i], &rv) != 0){\n        eprint(rdb, \"pthread_join\");\n        err = true;\n      } else if(rv){\n        err = true;\n      }\n    }\n  }\n  iprintf(\"record number: %llu\\n\", (unsigned long long)tcrdbrnum(rdb));\n  iprintf(\"size: %llu\\n\", (unsigned long long)tcrdbsize(rdb));\n  for(int i = 0; i < tnum; i++){\n    if(!tcrdbclose(rdbs[i])){\n      eprint(rdbs[i], \"tcrdbclose\");\n      err = true;\n    }\n    tcrdbdel(rdbs[i]);\n  }\n  iprintf(\"time: %.3f\\n\", tctime() - stime);\n  iprintf(\"%s\\n\\n\", err ? \"error\" : \"ok\");\n  return err ? 1 : 0;\n}", "path": "tcrmttest.c", "repo_name": "xurenlu/tokyo-family", "stars": 1, "license": "lgpl-2.1", "language": "c", "size": 296}
{"docstring": "/* Get the next key of the iterator of a remote database object. */\n", "func_signal": "void *tcrdbiternext(TCRDB *rdb, int *sp)", "code": "{\n  assert(rdb && sp);\n  if(rdb->fd < 0){\n    rdb->ecode = TTEINVALID;\n    return NULL;\n  }\n  char *vbuf = NULL;\n  unsigned char buf[TTIOBUFSIZ];\n  unsigned char *wp = buf;\n  *(wp++) = TTMAGICNUM;\n  *(wp++) = TTCMDITERNEXT;\n  if(ttsocksend(rdb->sock, buf, wp - buf)){\n    int code = ttsockgetc(rdb->sock);\n    if(code == 0){\n      int vsiz = ttsockgetint32(rdb->sock);\n      if(!ttsockcheckend(rdb->sock) && vsiz >= 0){\n        vbuf = tcmalloc(vsiz + 1);\n        if(ttsockrecv(rdb->sock, vbuf, vsiz)){\n          vbuf[vsiz] = '\\0';\n          *sp = vsiz;\n        } else {\n          rdb->ecode = TTERECV;\n          tcfree(vbuf);\n          vbuf = NULL;\n        }\n      } else {\n        rdb->ecode = TTERECV;\n      }\n    } else {\n      rdb->ecode = (code == -1) ? TTERECV : TTENOREC;\n    }\n  } else {\n    rdb->ecode = TTESEND;\n  }\n  return vbuf;\n}", "path": "tcrdb.c", "repo_name": "xurenlu/tokyo-family", "stars": 1, "license": "lgpl-2.1", "language": "c", "size": 296}
{"docstring": "/* Open a remote database. */\n", "func_signal": "bool tcrdbopen(TCRDB *rdb, const char *host, int port)", "code": "{\n  assert(rdb && host);\n  if(rdb->fd >= 0){\n    rdb->ecode = TTEINVALID;\n    return false;\n  }\n  int fd;\n  if(port < 1){\n    fd = ttopensockunix(host);\n  } else {\n    char addr[TTADDRBUFSIZ];\n    if(!ttgethostaddr(host, addr)){\n      rdb->ecode = TTENOHOST;\n      return false;\n    }\n    fd = ttopensock(addr, port);\n  }\n  if(fd == -1){\n    rdb->ecode = TTEREFUSED;\n    return false;\n  }\n  rdb->fd = fd;\n  rdb->sock = ttsocknew(fd);\n  return true;\n}", "path": "tcrdb.c", "repo_name": "xurenlu/tokyo-family", "stars": 1, "license": "lgpl-2.1", "language": "c", "size": 296}
{"docstring": "/* Call a function of the scripting language extension with string parameters. */\n", "func_signal": "char *tcrdbext2(TCRDB *rdb, const char *name, int opts, const char *kstr, const char *vstr)", "code": "{\n  assert(rdb && name && kstr && vstr);\n  int vsiz;\n  return tcrdbext(rdb, name, opts, kstr, strlen(kstr), vstr, strlen(vstr), &vsiz);\n}", "path": "tcrdb.c", "repo_name": "xurenlu/tokyo-family", "stars": 1, "license": "lgpl-2.1", "language": "c", "size": 296}
{"docstring": "/* Set the replication master of a remote database object from the update log. */\n", "func_signal": "bool tcrdbsetmst(TCRDB *rdb, const char *host, int port)", "code": "{\n  assert(rdb);\n  if(rdb->fd < 0){\n    rdb->ecode = TTEINVALID;\n    return NULL;\n  }\n  if(!host) host = \"\";\n  if(port < 0) port = 0;\n  bool err = false;\n  int hsiz = strlen(host);\n  int rsiz = 2 + sizeof(uint32_t) * 2 + hsiz;\n  unsigned char stack[TTIOBUFSIZ];\n  unsigned char *buf = (rsiz < TTIOBUFSIZ) ? stack : tcmalloc(rsiz);\n  pthread_cleanup_push(free, (buf == stack) ? NULL : buf);\n  unsigned char *wp = buf;\n  *(wp++) = TTMAGICNUM;\n  *(wp++) = TTCMDSETMST;\n  uint32_t num;\n  num = TTHTONL((uint32_t)hsiz);\n  memcpy(wp, &num, sizeof(uint32_t));\n  wp += sizeof(uint32_t);\n  num = TTHTONL((uint32_t)port);\n  memcpy(wp, &num, sizeof(uint32_t));\n  wp += sizeof(uint32_t);\n  memcpy(wp, host, hsiz);\n  wp += hsiz;\n  if(ttsocksend(rdb->sock, buf, wp - buf)){\n    int code = ttsockgetc(rdb->sock);\n    if(code != 0){\n      rdb->ecode = (code == -1) ? TTERECV : TTEMISC;\n      err = true;\n    }\n  } else {\n    rdb->ecode = TTESEND;\n    err = true;\n  }\n  pthread_cleanup_pop(1);\n  return !err;\n}", "path": "tcrdb.c", "repo_name": "xurenlu/tokyo-family", "stars": 1, "license": "lgpl-2.1", "language": "c", "size": 296}
{"docstring": "/* Get columns of a record in a search result. */\n", "func_signal": "TCMAP *tcrdbqryrescols(TCLIST *res, int index)", "code": "{\n  assert(res && index >= 0);\n  if(index >= tclistnum(res)) return NULL;\n  int csiz;\n  const char *cbuf = tclistval(res, index, &csiz);\n  return tcstrsplit4(cbuf, csiz);\n}", "path": "tcrdb.c", "repo_name": "xurenlu/tokyo-family", "stars": 1, "license": "lgpl-2.1", "language": "c", "size": 296}
{"docstring": "/* parse arguments of write command */\n", "func_signal": "static int runwrite(int argc, char **argv)", "code": "{\n  char *host = NULL;\n  char *rstr = NULL;\n  int port = DEFPORT;\n  int tnum = 1;\n  bool nr = false;\n  char *ext = NULL;\n  bool rnd = false;\n  for(int i = 2; i < argc; i++){\n    if(!host && argv[i][0] == '-'){\n      if(!strcmp(argv[i], \"-port\")){\n        if(++i >= argc) usage();\n        port = tcatoi(argv[i]);\n      } else if(!strcmp(argv[i], \"-tnum\")){\n        if(++i >= argc) usage();\n        tnum = tcatoi(argv[i]);\n      } else if(!strcmp(argv[i], \"-nr\")){\n        nr = true;\n      } else if(!strcmp(argv[i], \"-ext\")){\n        if(++i >= argc) usage();\n        ext = argv[i];\n      } else if(!strcmp(argv[i], \"-rnd\")){\n        rnd = true;\n      } else {\n        usage();\n      }\n    } else if(!host){\n      host = argv[i];\n    } else if(!rstr){\n      rstr = argv[i];\n    } else {\n      usage();\n    }\n  }\n  if(!host || !rstr || tnum < 1) usage();\n  int rnum = tcatoi(rstr);\n  if(rnum < 1) usage();\n  int rv = procwrite(host, port, tnum, rnum, nr, ext, rnd);\n  return rv;\n}", "path": "tcrmttest.c", "repo_name": "xurenlu/tokyo-family", "stars": 1, "license": "lgpl-2.1", "language": "c", "size": 296}
{"docstring": "/* parse arguments of read command */\n", "func_signal": "static int runread(int argc, char **argv)", "code": "{\n  char *host = NULL;\n  int port = DEFPORT;\n  int tnum = 1;\n  int mul = 0;\n  bool rnd = false;\n  for(int i = 2; i < argc; i++){\n    if(!host && argv[i][0] == '-'){\n      if(!strcmp(argv[i], \"-port\")){\n        if(++i >= argc) usage();\n        port = tcatoi(argv[i]);\n      } else if(!strcmp(argv[i], \"-tnum\")){\n        if(++i >= argc) usage();\n        tnum = tcatoi(argv[i]);\n      } else if(!strcmp(argv[i], \"-mul\")){\n        if(++i >= argc) usage();\n        mul = tcatoi(argv[i]);\n      } else if(!strcmp(argv[i], \"-rnd\")){\n        rnd = true;\n      } else {\n        usage();\n      }\n    } else if(!host){\n      host = argv[i];\n    } else {\n      usage();\n    }\n  }\n  if(!host || tnum < 1) usage();\n  int rv = procread(host, port, tnum, mul, rnd);\n  return rv;\n}", "path": "tcrmttest.c", "repo_name": "xurenlu/tokyo-family", "stars": 1, "license": "lgpl-2.1", "language": "c", "size": 296}
{"docstring": "/* get a random number based on normal distribution */\n", "func_signal": "static int myrandnd(int range)", "code": "{\n  int num = (int)tcdrandnd(range >> 1, range / 10);\n  return (num < 0 || num >= range) ? 0 : num;\n}", "path": "tcrmttest.c", "repo_name": "xurenlu/tokyo-family", "stars": 1, "license": "lgpl-2.1", "language": "c", "size": 296}
{"docstring": "/* Retrieve records in a remote database object. */\n", "func_signal": "bool tcrdbget3(TCRDB *rdb, TCMAP *recs)", "code": "{\n  assert(rdb && recs);\n  if(rdb->fd < 0){\n    rdb->ecode = TTEINVALID;\n    return NULL;\n  }\n  bool err = false;\n  TCXSTR *xstr = tcxstrnew();\n  pthread_cleanup_push((void (*)(void *))tcxstrdel, xstr);\n  uint8_t magic[2];\n  magic[0] = TTMAGICNUM;\n  magic[1] = TTCMDMGET;\n  tcxstrcat(xstr, magic, sizeof(magic));\n  uint32_t num;\n  num = (uint32_t)tcmaprnum(recs);\n  num = TTHTONL(num);\n  tcxstrcat(xstr, &num, sizeof(num));\n  tcmapiterinit(recs);\n  const char *kbuf;\n  int ksiz;\n  while((kbuf = tcmapiternext(recs, &ksiz)) != NULL){\n    num = TTHTONL((uint32_t)ksiz);\n    tcxstrcat(xstr, &num, sizeof(num));\n    tcxstrcat(xstr, kbuf, ksiz);\n  }\n  tcmapclear(recs);\n  char stack[TTIOBUFSIZ];\n  if(ttsocksend(rdb->sock, tcxstrptr(xstr), tcxstrsize(xstr))){\n    int code = ttsockgetc(rdb->sock);\n    int rnum = ttsockgetint32(rdb->sock);\n    if(code == 0){\n      if(!ttsockcheckend(rdb->sock) && rnum >= 0){\n        for(int i = 0; i < rnum; i++){\n          int rksiz = ttsockgetint32(rdb->sock);\n          int rvsiz = ttsockgetint32(rdb->sock);\n          if(ttsockcheckend(rdb->sock)){\n            rdb->ecode = TTERECV;\n            err = true;\n            break;\n          }\n          int rsiz = rksiz + rvsiz;\n          char *rbuf = (rsiz < TTIOBUFSIZ) ? stack : tcmalloc(rsiz + 1);\n          if(ttsockrecv(rdb->sock, rbuf, rsiz)){\n            tcmapput(recs, rbuf, rksiz, rbuf + rksiz, rvsiz);\n          } else {\n            rdb->ecode = TTERECV;\n            err = true;\n          }\n          if(rbuf != stack) tcfree(rbuf);\n        }\n      } else {\n        rdb->ecode = TTERECV;\n        err = true;\n      }\n    } else {\n      rdb->ecode = (code == -1) ? TTERECV : TTENOREC;\n      err = true;\n    }\n  } else {\n    rdb->ecode = TTESEND;\n    err = true;\n  }\n  pthread_cleanup_pop(1);\n  return !err;\n}", "path": "tcrdb.c", "repo_name": "xurenlu/tokyo-family", "stars": 1, "license": "lgpl-2.1", "language": "c", "size": 296}
{"docstring": "/* Add a real number to a record in a remote database object. */\n", "func_signal": "double tcrdbadddouble(TCRDB *rdb, const void *kbuf, int ksiz, double num)", "code": "{\n  assert(rdb && kbuf && ksiz >= 0);\n  if(rdb->fd < 0){\n    rdb->ecode = TTEINVALID;\n    return false;\n  }\n  double sum = NAN;\n  int rsiz = 2 + sizeof(uint32_t) + sizeof(uint64_t) * 2 + ksiz;\n  unsigned char stack[TTIOBUFSIZ];\n  unsigned char *buf = (rsiz < TTIOBUFSIZ) ? stack : tcmalloc(rsiz);\n  pthread_cleanup_push(free, (buf == stack) ? NULL : buf);\n  unsigned char *wp = buf;\n  *(wp++) = TTMAGICNUM;\n  *(wp++) = TTCMDADDDOUBLE;\n  uint32_t lnum;\n  lnum = TTHTONL((uint32_t)ksiz);\n  memcpy(wp, &lnum, sizeof(uint32_t));\n  wp += sizeof(uint32_t);\n  char dbuf[sizeof(uint64_t)*2];\n  ttpackdouble(num, (char *)wp);\n  wp += sizeof(dbuf);\n  memcpy(wp, kbuf, ksiz);\n  wp += ksiz;\n  if(ttsocksend(rdb->sock, buf, wp - buf)){\n    int code = ttsockgetc(rdb->sock);\n    if(code == 0){\n      if(ttsockrecv(rdb->sock, dbuf, sizeof(dbuf)) && !ttsockcheckend(rdb->sock)){\n        sum = ttunpackdouble(dbuf);\n      } else {\n        rdb->ecode = TTERECV;\n      }\n    } else {\n      rdb->ecode = (code == -1) ? TTERECV : TTEKEEP;\n    }\n  } else {\n    rdb->ecode = TTESEND;\n  }\n  pthread_cleanup_pop(1);\n  return sum;\n}", "path": "tcrdb.c", "repo_name": "xurenlu/tokyo-family", "stars": 1, "license": "lgpl-2.1", "language": "c", "size": 296}
{"docstring": "/* Get forward matching keys in a remote database object. */\n", "func_signal": "TCLIST *tcrdbfwmkeys(TCRDB *rdb, const void *pbuf, int psiz, int max)", "code": "{\n  assert(rdb && pbuf && psiz >= 0);\n  TCLIST *keys = tclistnew();\n  if(rdb->fd < 0){\n    rdb->ecode = TTEINVALID;\n    return keys;\n  }\n  int rsiz = 2 + sizeof(uint32_t) * 2 + psiz;\n  if(max < 0) max = INT_MAX;\n  unsigned char stack[TTIOBUFSIZ];\n  unsigned char *buf = (rsiz < TTIOBUFSIZ) ? stack : tcmalloc(rsiz);\n  pthread_cleanup_push(free, (buf == stack) ? NULL : buf);\n  unsigned char *wp = buf;\n  *(wp++) = TTMAGICNUM;\n  *(wp++) = TTCMDFWMKEYS;\n  uint32_t num;\n  num = TTHTONL((uint32_t)psiz);\n  memcpy(wp, &num, sizeof(uint32_t));\n  wp += sizeof(uint32_t);\n  num = TTHTONL((uint32_t)max);\n  memcpy(wp, &num, sizeof(uint32_t));\n  wp += sizeof(uint32_t);\n  memcpy(wp, pbuf, psiz);\n  wp += psiz;\n  if(ttsocksend(rdb->sock, buf, wp - buf)){\n    int code = ttsockgetc(rdb->sock);\n    if(code == 0){\n      int knum = ttsockgetint32(rdb->sock);\n      if(!ttsockcheckend(rdb->sock) && knum >= 0){\n        for(int i = 0; i < knum; i++){\n          int ksiz = ttsockgetint32(rdb->sock);\n          if(ttsockcheckend(rdb->sock)){\n            rdb->ecode = TTERECV;\n            break;\n          }\n          char *kbuf = (ksiz < TTIOBUFSIZ) ? stack : tcmalloc(ksiz + 1);\n          if(ttsockrecv(rdb->sock, kbuf, ksiz)){\n            tclistpush(keys, kbuf, ksiz);\n          } else {\n            rdb->ecode = TTERECV;\n          }\n          if(kbuf != (char *)stack) tcfree(kbuf);\n        }\n      } else {\n        rdb->ecode = TTERECV;\n      }\n    } else {\n      rdb->ecode = (code == -1) ? TTERECV : TTENOREC;\n    }\n  } else {\n    rdb->ecode = TTESEND;\n  }\n  pthread_cleanup_pop(1);\n  return keys;\n}", "path": "tcrdb.c", "repo_name": "xurenlu/tokyo-family", "stars": 1, "license": "lgpl-2.1", "language": "c", "size": 296}
{"docstring": "/* thread the write function */\n", "func_signal": "static void *threadwrite(void *targ)", "code": "{\n  TCRDB *rdb = ((TARGWRITE *)targ)->rdb;\n  int rnum = ((TARGWRITE *)targ)->rnum;\n  bool nr = ((TARGWRITE *)targ)->nr;\n  const char *ext = ((TARGWRITE *)targ)->ext;\n  bool rnd = ((TARGWRITE *)targ)->rnd;\n  int id = ((TARGWRITE *)targ)->id;\n  bool err = false;\n  int base = id * rnum;\n  for(int i = 1; i <= rnum; i++){\n    char buf[RECBUFSIZ];\n    int len = sprintf(buf, \"%08d\", base + (rnd ? myrand(i) + 1 : i));\n    if(nr){\n      if(!tcrdbputnr(rdb, buf, len, buf, len)){\n        eprint(rdb, \"tcrdbputnr\");\n        err = true;\n        break;\n      }\n    } else if(ext){\n      int rsiz;\n      char *rbuf = tcrdbext(rdb, ext, 0, buf, len, buf, len, &rsiz);\n      if(!rbuf && tcrdbecode(rdb) != TCEMISC){\n        eprint(rdb, \"tcrdbext\");\n        err = true;\n        break;\n      }\n      tcfree(rbuf);\n    } else {\n      if(!tcrdbput(rdb, buf, len, buf, len)){\n        eprint(rdb, \"tcrdbput\");\n        err = true;\n        break;\n      }\n    }\n    if(id == 0 && rnum > 250 && i % (rnum / 250) == 0){\n      putchar('.');\n      fflush(stdout);\n      if(i == rnum || i % (rnum / 10) == 0) iprintf(\" (%08d)\\n\", i);\n    }\n  }\n  return err ? \"error\" : NULL;\n}", "path": "tcrmttest.c", "repo_name": "xurenlu/tokyo-family", "stars": 1, "license": "lgpl-2.1", "language": "c", "size": 296}
{"docstring": "/* Get records corresponding to the search of a query object. */\n", "func_signal": "TCLIST *tcrdbqrysearchget(RDBQRY *qry)", "code": "{\n  assert(qry);\n  TCLIST *args = tclistdup(qry->args);\n  tclistpush2(args, \"get\");\n  TCLIST *rv = tcrdbmisc(qry->rdb, \"search\", RDBMONOULOG, args);\n  tclistdel(args);\n  return rv;\n}", "path": "tcrdb.c", "repo_name": "xurenlu/tokyo-family", "stars": 1, "license": "lgpl-2.1", "language": "c", "size": 296}
{"docstring": "/* - common */\n", "func_signal": "void setVoiceCount(int count)", "code": "{ /* set up specified number of voices. always call this before routing! */\n\tvoiceCount = count;\n\n\tsetupVoices(); /* TODO: cleanup existing voices */\n}", "path": "popcorn\\configuration\\routing.c", "repo_name": "cryptix/Gruppe42", "stars": 0, "license": "other", "language": "c", "size": 564}
{"docstring": "/* - Mixers*/\n", "func_signal": "unit *addMixer2ch(unitScope scope)", "code": "{ /* add 2 channel mixer unit */\n\tunit *newUnit = addUnit(scope); /* adding and setting up basics for new unit*/\n\tint i, iMax = ((scope == usGLOBAL) ? 1 : voiceCount);\n\n\tnewUnit->type = utMIXER2CH;\n\tnewUnit->comp = (void (*)(void *))&compMixer2ch; /* setup computing function for unit */\n\tnewUnit->reinit = NULL; /* no reinit function for this unit */\n\n\tfor (i = 0; i < iMax; i++) { /* setup one inner unit for global unit or one for every voice for local unit */\n\t\tnewUnit->units[i] = ecMalloc(sizeof(mixer2ch)); /* allocate memory for every inner unit */\n\t\tsetupMixer2ch(newUnit->units[i]); /* specific setup for 2 channel mixer */\n\t}\n\n\treturn newUnit;\n}", "path": "popcorn\\configuration\\routing.c", "repo_name": "cryptix/Gruppe42", "stars": 0, "license": "other", "language": "c", "size": 564}
{"docstring": "/* - common */\n", "func_signal": "unit *addUnit(unitScope scope)", "code": "{ /* adds a new unit and allocates memory */\n\tunit *newUnit;\n\tint i;\n\n\tif (scope == usGLOBAL) {\n\t\tgUnitCount++;\n\t\tgUnits = ecRealloc(gUnits, sizeof(unit *) * gUnitCount); /* gUnit array grows */\n\t\tnewUnit = gUnits[gUnitCount - 1] = ecMalloc(sizeof(unit));\n\n\t\tnewUnit->units = ecMalloc(sizeof(void *)); /* allocate memory for single inner unit */\n\t\tnewUnit->acts = ecMalloc(sizeof(char *));\n\t\tnewUnit->acts[0] = gBools + 1; /* sets inner unit to active */\n\t} else {\n\t\tlUnitCount++;\n\t\tlUnits = ecRealloc(lUnits, sizeof(unit *) * lUnitCount); /* lUnit array grows */\n\t\tnewUnit = lUnits[lUnitCount - 1] = ecMalloc(sizeof(unit));\n\n\t\tnewUnit->units = ecMalloc(sizeof(void *) * voiceCount); /* allocate memory for every inner unit */\n\t\tnewUnit->acts = ecMalloc(sizeof(char *) * voiceCount);\n\t\tfor (i = 0; i < voiceCount; i++) {\n\t\t\tnewUnit->acts[i] = gBools + 1; /* set all inner units to active */\n\t\t}\n\t}\n\n\tnewUnit->scope = scope;\n\n\treturn newUnit;\n}", "path": "popcorn\\configuration\\routing.c", "repo_name": "cryptix/Gruppe42", "stars": 0, "license": "other", "language": "c", "size": 564}
{"docstring": "/* - Bools */\n", "func_signal": "char **getBoolParamAddress(unit *u, boolType type, int i)", "code": "{ /* get address of bool value for cahnging it */\n\tswitch (type) {\n\t\tcase btACT: return &(u->acts[i]);\n\t\tdefault: break;\n\t}\n\n\t/* Unit-Type-Bool-Params */\n\tswitch (u->type) {\n\t\tcase utMIXER2CH:\n\t\t\tswitch (type) {\n\t\t\t\tcase btACT1: return &(((mixer2ch *)(u->units[i]))->act1);\n\t\t\t\tcase btACT2: return &(((mixer2ch *)(u->units[i]))->act2);\n\t\t\t\tdefault: return NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault: return NULL;\n\t}\n}", "path": "popcorn\\configuration\\routing.c", "repo_name": "cryptix/Gruppe42", "stars": 0, "license": "other", "language": "c", "size": 564}
{"docstring": "/* - Highpass-Filter */\n", "func_signal": "unit *addFxHighpass(unitScope scope)", "code": "{\n\tunit *newUnit = addUnit(scope); /* adding and setting up basics for new unit*/\n\tint i, iMax = ((scope == usGLOBAL) ? 1 : voiceCount);\n\n\tnewUnit->type = utFX_HIGHPASS;\n\tnewUnit->comp = (void (*)(void *))&compFxHighpass; /* setup computing function for unit */\n\tnewUnit->reinit = NULL; /* no reinit function for this unit */\n\n\tfor (i = 0; i < iMax; i++) { /* setup one inner unit for global unit or one for every voice for local unit */\n\t\tnewUnit->units[i] = ecMalloc(sizeof(fxHighpass)); /* allocate memory for every inner unit */\n\t\tsetupFxHighpass(newUnit->units[i]); /* specific setup for highpass filter */\n\t}\n\n\treturn newUnit;\n}", "path": "popcorn\\configuration\\routing.c", "repo_name": "cryptix/Gruppe42", "stars": 0, "license": "other", "language": "c", "size": 564}
{"docstring": "/* - Params */\n", "func_signal": "float *addGlobalParam()", "code": "{ /* add an allocate new static value */\n\tgValueCount++;\n\tgValues = ecRealloc(gValues, sizeof(float *) * gValueCount); /* array grows */\n\tgValues[gValueCount - 1] = ecMalloc(sizeof(float));\n\treturn gValues[gValueCount - 1];\n}", "path": "popcorn\\configuration\\routing.c", "repo_name": "cryptix/Gruppe42", "stars": 0, "license": "other", "language": "c", "size": 564}
{"docstring": "/* - Bandpass-Filter */\n", "func_signal": "unit *addFxBandpass(unitScope scope)", "code": "{\n\tunit *newUnit = addUnit(scope); /* adding and setting up basics for new unit*/\n\tint i, iMax = ((scope == usGLOBAL) ? 1 : voiceCount);\n\n\tnewUnit->type = utFX_BANDPASS;\n\tnewUnit->comp = (void (*)(void *))&compFxBandpass; /* setup computing function for unit */\n\tnewUnit->reinit = NULL; /* no reinit function for this unit */\n\n\tfor (i = 0; i < iMax; i++) { /* setup one inner unit for global unit or one for every voice for local unit */\n\t\tnewUnit->units[i] = ecMalloc(sizeof(fxBandpass)); /* allocate memory for every inner unit */\n\t\tsetupFxBandpass(newUnit->units[i]); /* specific setup for bandpass filter */\n\t}\n\n\treturn newUnit;\n}", "path": "popcorn\\configuration\\routing.c", "repo_name": "cryptix/Gruppe42", "stars": 0, "license": "other", "language": "c", "size": 564}
{"docstring": "/* - Bools */\n", "func_signal": "void setBool(unit *u, boolType type, char val)", "code": "{ /* sets bool value to static value */\n\tchar **b, *bSrc;\n\tint i, iMax = ((u->scope == usGLOBAL) ? 1 : voiceCount);\n\n\tif (val == 0) { /* bools can only have two specific values */\n\t\tbSrc = gBools + 0;\n\t} else {\n\t\tbSrc = gBools + 1;\n\t}\n\n\tfor (i = 0; i < iMax; i++) {\n\t\tb = getBoolParamAddress(u, type, i); /* get pointer to the value to set */\n\t\t*b = bSrc;\n\t}\n}", "path": "popcorn\\configuration\\routing.c", "repo_name": "cryptix/Gruppe42", "stars": 0, "license": "other", "language": "c", "size": 564}
{"docstring": "/* --- Setup --- */\n", "func_signal": "void setupVoices()", "code": "{ /* setup specified number of voices */\n\tint i;\n\n\tactVoices = 0; /* no voices are playing */\n\n\tvoices = realloc(voices, sizeof(voice) * voiceCount); /* allocate memory for voices */\n\n\tfor (i = 0; i < voiceCount; i++) {\n\t\tsetupVoice(voices + i);\n\t}\n}", "path": "popcorn\\processing\\voices.c", "repo_name": "cryptix/Gruppe42", "stars": 0, "license": "other", "language": "c", "size": 564}
{"docstring": "/* Control */\n", "func_signal": "void startVoice(int note, int velocity)", "code": "{ /* start playing a voice */\n\tint i;\n\tvoice* newVoice; /* voice to use */\n\n\tif (actVoices < voiceCount) { /* not all voices are playing -> use the next free */\n\t\tfor (i = 0; i < voiceCount; i++) {\n\t\t\tif (voices[i].act == 0) {\n\t\t\t\tnewVoice = &(voices[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (actVoices == 0) { /* no other voices are playing -> current is the first and last started voice */\n\t\t\tfirstVoice = newVoice;\n\t\t\tlastVoice = newVoice;\n\t\t}\n\n\t\tactVoices++;\n\t} else { /* all voices are playing -> use first started voice */\n\t\tnewVoice = firstVoice;\n\t\tfirstVoice = firstVoice->postVoice; /* the voice started after the first is now the first started */\n\t}\n\t\n\t/* add current voice to the end */\n\tnewVoice->preVoice = lastVoice;\n\tlastVoice->postVoice = newVoice;\n\tlastVoice = newVoice;\t\n\n\t/* set values for current voice */\n\tnewVoice->freq = getFreq(note);\n\tnewVoice->velocity = velocity / 128.0;\n\tnewVoice->act = 1;\n\n\treinitLocalUnits(newVoice - voices);\n\n#ifdef DEBUG_VOICES\n\tdebugVoices();\n#endif\n}", "path": "popcorn\\processing\\voices.c", "repo_name": "cryptix/Gruppe42", "stars": 0, "license": "other", "language": "c", "size": 564}
{"docstring": "/* --- Setup --- */\n", "func_signal": "void setupMixer2ch(mixer2ch *m)", "code": "{ /* set default static values for new 2 channel mixer */\n\tm->val = 0;\n\n\tm->act1 = gBools + 0;\n\tm->act2 = gBools + 0;\n\n\tm->vol1.val = defValues + 1;\n\tsetupParam(&(m->vol1));\n\n\tm->vol2.val = defValues + 1;\n\tsetupParam(&(m->vol2));\n\n\tm->input1.val = defValues + 0;\n\tsetupParam(&(m->input1));\n\n\tm->input2.val = defValues + 0;\n\tsetupParam(&(m->input2));\n}", "path": "popcorn\\processing\\tools.c", "repo_name": "cryptix/Gruppe42", "stars": 0, "license": "other", "language": "c", "size": 564}
{"docstring": "/* - Oscillators */\n", "func_signal": "float (*getOscFunc(oscType type))(float, float, float)", "code": "{ /* returns pointer to oscillators inner computing function of specified type */\n\n\t/* Oscillator Types */\n\tswitch (type) {\n\t\tcase otSIN: return &oscSin;\n\t\tcase otTRI: return &oscTri;\n\t\tcase otREC: return &oscRec;\n\t\tdefault: return NULL;\n\t}\n}", "path": "popcorn\\configuration\\routing.c", "repo_name": "cryptix/Gruppe42", "stars": 0, "license": "other", "language": "c", "size": 564}
{"docstring": "/* --- Computing --- */\n", "func_signal": "void compOsc(osc *o)", "code": "{ /* compute current value of an osc */\n\tfloat freq, vol, param1;\n\tfloat spp; /* samples per period */\n\n\t/* compute params */\n\tfreq = compParam(&(o->freq));\n\tvol = compParam(&(o->vol));\n\tparam1 = compParam(&(o->param1));\n\n\tspp = sampleRate / freq; /* compute current freq */\n\to->phase++;\n\tif (o->phase >= spp) o->phase -= spp; /* avoid wrap around of phase */\n\n\to->val = o->func(o->phase, spp, param1) * vol; /* use specific osc-function (oscSin, oscTri etc) */\n}", "path": "popcorn\\processing\\oscillators.c", "repo_name": "cryptix/Gruppe42", "stars": 0, "license": "other", "language": "c", "size": 564}
{"docstring": "/* - Params */\n", "func_signal": "void setParam(unit *u, paramType type, paramOption option, float val)", "code": "{ /* sets value of a param to static value */\n\tfloat **p, **pLoc;\n\tint i;\n\n\tp = getParamAddress(u, type, option, 0); /* get pointer to the value. if unit is global there is only one, if local we only need the first one here */\n\n\tif (!isGlobalParam(p)) { /* create a new static value, if value is no */\n\t\t*p = addGlobalParam();\n\t}\n\n\tif (u->scope == usLOCAL) { /* if unit is local, set all values of inner units to the same value */\n\t\tfor (i = 1; i < voiceCount; i++) {\n\t\t\tpLoc = getParamAddress(u, type, option, i); /* get pointer to the value to set */\n\t\t\t*pLoc = *p;\n\t\t}\n\t}\n\n\t**p = val; /* cahnge content of the value to specified value */\n}", "path": "popcorn\\configuration\\routing.c", "repo_name": "cryptix/Gruppe42", "stars": 0, "license": "other", "language": "c", "size": 564}
{"docstring": "/* --- Computing --- */\n", "func_signal": "void compMixer2ch(mixer2ch *m)", "code": "{ /* compute current value of a 2 channel mixer */\n\tm->val = 0;\n\n\tif (*(m->act1) == 1) m->val += compParam(&(m->input1)) * compParam(&(m->vol1));\n\tif (*(m->act2) == 1) m->val += compParam(&(m->input2)) * compParam(&(m->vol2));\n}", "path": "popcorn\\processing\\tools.c", "repo_name": "cryptix/Gruppe42", "stars": 0, "license": "other", "language": "c", "size": 564}
{"docstring": "/* pointer to global unit value for master output */\n", "func_signal": "void compute()", "code": "{\n\tint i, j;\n\n\tfor (i = 0; i < gUnitCount; i++) { /* process all global units with specified computing function */\n\t\tif (*(gUnits[i]->acts[0]) == 1) {\n\t\t\tgUnits[i]->comp(gUnits[i]->units[0]);\n\t\t}\n\t}\n\n\tfor (i = 0; i < lUnitCount; i++) { /* process all local units with specified computing function */\n\t\tfor (j = 0; j < voiceCount; j++) { /* local units have an inner unit for every voice */\n\t\t\tif (*(lUnits[i]->acts[j]) == 1) {\n\t\t\t\tlUnits[i]->comp(lUnits[i]->units[j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoicesOutput = 0;\n\tfor (i = 0; i < voiceCount; i++) { /* sum voice output values */\n\t\tvoicesOutput += *(voices[i].output);\n\t}\n}", "path": "popcorn\\processing\\compute.c", "repo_name": "cryptix/Gruppe42", "stars": 0, "license": "other", "language": "c", "size": 564}
{"docstring": "/* --- Reinit --- */\n", "func_signal": "void reinitOsc(osc *o)", "code": "{\n\to->phase = (compParam(&(o->phaseShift)) + 2) * sampleRate / compParam(&(o->freq)) / 2;\n\to->val = 0;\n}", "path": "popcorn\\processing\\oscillators.c", "repo_name": "cryptix/Gruppe42", "stars": 0, "license": "other", "language": "c", "size": 564}
{"docstring": "/* - Lowpass-Filter */\n", "func_signal": "unit *addFxLowpass(unitScope scope)", "code": "{\n\tunit *newUnit = addUnit(scope); /* adding and setting up basics for new unit*/\n\tint i, iMax = ((scope == usGLOBAL) ? 1 : voiceCount);\n\n\tnewUnit->type = utFX_LOWPASS;\n\tnewUnit->comp = (void (*)(void *))&compFxLowpass; /* setup computing function for unit */\n\tnewUnit->reinit = NULL; /* no reinit function for this unit */\n\n\tfor (i = 0; i < iMax; i++) { /* setup one inner unit for global unit or one for every voice for local unit */\n\t\tnewUnit->units[i] = ecMalloc(sizeof(fxLowpass)); /* allocate memory for every inner unit */\n\t\tsetupFxLowpass(newUnit->units[i]); /* specific setup for lowpass filter */\n\t}\n\n\treturn newUnit;\n}", "path": "popcorn\\configuration\\routing.c", "repo_name": "cryptix/Gruppe42", "stars": 0, "license": "other", "language": "c", "size": 564}
{"docstring": "/* --- Setup --- */\n", "func_signal": "void setupOsc(osc *o)", "code": "{ /* set default static vaules for new osc */\n\to->val = 0;\n\to->phase = 0;\n\to->func = &oscSin;\n\n\to->freq.val = defValues + 2;\n\tsetupParam(&(o->freq));\n\n\to->vol.val = defValues + 1;\n\tsetupParam(&(o->vol));\n\n\to->param1.val = defValues + 0;\n\tsetupParam(&(o->param1));\n\n\to->phaseShift.val = defValues + 0;\n\tsetupParam(&(o->phaseShift));\n}", "path": "popcorn\\processing\\oscillators.c", "repo_name": "cryptix/Gruppe42", "stars": 0, "license": "other", "language": "c", "size": 564}
{"docstring": "/* - Oscillators */\n", "func_signal": "unit *addOsc(unitScope scope)", "code": "{ /* add oscillator unit */\n\tunit *newUnit = addUnit(scope); /* adding and setting up basics for new unit*/\n\tint i, iMax = ((scope == usGLOBAL) ? 1 : voiceCount);\n\n\tnewUnit->type = utOSC;\n\tnewUnit->comp = (void (*)(void *))&compOsc; /* setup computing function for unit */\n\tnewUnit->reinit = (void (*)(void *))&reinitOsc; /* reinit function for unit */\n\n\tfor (i = 0; i < iMax; i++) { /* setup one inner unit for global unit or one for every voice for local unit */\n\t\tnewUnit->units[i] = ecMalloc(sizeof(osc)); /* allocate memory for every inner unit */\n\t\tsetupOsc(newUnit->units[i]); /* specific setup for oscillator */\n\t}\n\n\treturn newUnit;\n}", "path": "popcorn\\configuration\\routing.c", "repo_name": "cryptix/Gruppe42", "stars": 0, "license": "other", "language": "c", "size": 564}
{"docstring": "/*\n  -----------------------------------------------------------------------------\n  Returns the libdc1394 colour coding ID that supports the given pixel\n  coding, or 0 on error.  The bit_field argument must be non-zero.\n\n  libdc1394 presently only supports IIDC spec 1.30.  The signed and raw\n  codings should be added to the list below as soon as libdc1394\n  supports version 1.31.\n*/\n", "func_signal": "static\nunsigned int convert_pixelcoding2colorid(const Camwire_pixel coding,\n\t\t\t\t\t const quadlet_t bit_field)", "code": "{\n    switch (coding)\n    {\n\tcase CAMWIRE_PIXEL_MONO8:  /* 8 bits/pixel.*/\n\t    if (bit_field & 0x80000000)  return(COLOR_FORMAT7_MONO8);\n\t    break;\n\tcase CAMWIRE_PIXEL_YUV411:  /* 12 bits/pixel.*/\n\t    if (bit_field & 0x40000000)  return(COLOR_FORMAT7_YUV411);\n\t    break;\n\tcase CAMWIRE_PIXEL_YUV422:  /* 16 bits/pixel.*/\n\t    if (bit_field & 0x20000000)  return(COLOR_FORMAT7_YUV422);\n\t    break;\n\tcase CAMWIRE_PIXEL_YUV444:  /* 24 bits/pixel.*/\n\t    if (bit_field & 0x10000000)  return(COLOR_FORMAT7_YUV444);\n\t    break;\n\tcase CAMWIRE_PIXEL_RGB8:  /* 24 bits/pixel.*/\n\t    if (bit_field & 0x08000000)  return(COLOR_FORMAT7_RGB8);\n\t    break;\n\tcase CAMWIRE_PIXEL_MONO16:  /* 16 bits/pixel.*/\n\t    if (bit_field & 0x04000000)  return(COLOR_FORMAT7_MONO16);\n\t    break;\n\tcase CAMWIRE_PIXEL_RGB16:  /* 48 bits/pixel.*/\n\t    if (bit_field & 0x02000000)  return(COLOR_FORMAT7_RGB16);\n\t    break;\n\t    /*\n\tcase CAMWIRE_PIXEL_MONO16S:  // 16 bits/pixel.\n\t    if (bit_field & 0x01000000)  return(COLOR_FORMAT7_MONO16S);\n\t    break;\n\tcase CAMWIRE_PIXEL_RGB16S:  // 48 bits/pixel.\n\t    if (bit_field & 0x00800000)  return(COLOR_FORMAT7_RGB16S);\n\t    break;\n\tcase CAMWIRE_PIXEL_RAW8:  // 8 bits/pixel.\n\t    if (bit_field & 0x00400000)  return(COLOR_FORMAT7_RAW8);\n\t    break;\n\tcase CAMWIRE_PIXEL_RAW16:  // 16 bits/pixel.\n\t    if (bit_field & 0x00200000)  return(COLOR_FORMAT7_RAW16);\n\t    break;\n\t    */\n\tdefault:\n\t    return(0);  /* No such coding.*/\n\t    break;\n    }\n    return(0);  /* Not supported by camera.*/\n}", "path": "clib\\camwire_1394_cache_working.c", "repo_name": "madhadron/hscamwire", "stars": 1, "license": "lgpl-3.0", "language": "c", "size": 468}
{"docstring": "/*\n  -----------------------------------------------------------------------------\n  See camwire.h for documentation on this function.\n*/\n", "func_signal": "int camwire_get_frame_offset(const Camwire_handle c_handle, int *left,\n\t\t\t     int *top)", "code": "{\n    Camwire_settings *settings_cache;\n    unsigned int format, mode;\n\n    ERROR_IF_NULL(c_handle);\n    settings_cache = get_settings_cache(c_handle);\n    ERROR_IF_NULL(settings_cache);\n    if ((settings_cache->shadow & CAMWIRE_SHADOW_SETTINGS) != 0)\n    {\n\t*left = settings_cache->left;\n\t*top = settings_cache->top;\n    }\n    else\n    {\n\tformat = get_1394_format(c_handle);\n\tERROR_IF_ZERO(format);\n\tif (format == FORMAT_VGA_NONCOMPRESSED)\n\t{ \t/* Format 0.*/\n\t    *left = *top = 0;\n\t}\n\telse if (format == FORMAT_SCALABLE_IMAGE_SIZE)\n\t{ \t/* Format 7.*/\n\t    mode = get_1394_mode(c_handle);\n\t    ERROR_IF_ZERO(mode);\n\t    ERROR_IF_DC1394_FAIL(\n\t\tdc1394_query_format7_image_position(\n\t\t    camwire_bus_get_port(c_handle),\n\t\t    camwire_bus_get_node(c_handle),\n\t\t    mode,\n\t\t    (unsigned int *) left,\n\t\t    (unsigned int *) top));\n\t}\n\telse\n\t{\n\t    DPRINTF(\"Unsupported camera format in \"\n\t\t    \"camwire_get_frame_offset().\");\n\t    return(CAMWIRE_FAILURE);\n\t}\n\tsettings_cache->left = *left;\n\tsettings_cache->top = *top;\n    }\n    \n    return(CAMWIRE_SUCCESS);\n}", "path": "clib\\camwire_1394_cache_working.c", "repo_name": "madhadron/hscamwire", "stars": 1, "license": "lgpl-3.0", "language": "c", "size": 468}
{"docstring": "/* We have a concept of single-shot/continuous which is orthogonal to\n   run/stop.  The closest equivalents in libdc1394 are the\n   ISO_EN/Continuous_shot and One_shot/Multi_shot registers accessed\n   through dc1394_start/stop_iso_transmission() and\n   dc1394_set/unset_one_shot().\n\n   Our orthogonal concept is implemented with the functions\n   camwire_get/set_single_shot() and camwire_get/set_run_stop().\n   \n   We are forced to maintain our own idea of the single-shot/continuous\n   status in settings_cache->single_shot.  libdc1394 can only tell us the\n   state of the ISO_EN/Continuous_Shot register which is used to\n   describe both continuous and run statuses, and the One_Shot register\n   which asynchronously auto-clears itself after transmitting a frame.\n   We use every opportunity to re-align our internal status with the\n   hardware status.\n*/\n", "func_signal": "int camwire_get_single_shot(const Camwire_handle c_handle, int *single_shot_on)", "code": "{\n    dc1394bool_t iso_en, one_shot_set;\n    Camwire_settings *settings_cache;\n\n    ERROR_IF_NULL(c_handle);\n    settings_cache = get_settings_cache(c_handle);\n    ERROR_IF_NULL(settings_cache);\n    if ((settings_cache->shadow & CAMWIRE_SHADOW_SETTINGS) != 0)\n    {\n\t*single_shot_on = settings_cache->single_shot;\n    }\n    else\n    {  /* Don't use shadow: ask the camera:*/\n\tERROR_IF_DC1394_FAIL(\n\t    dc1394_get_iso_status(camwire_bus_get_port(c_handle),\n\t\t\t\t  camwire_bus_get_node(c_handle),\n\t\t\t\t  &iso_en));\n\t\n\tif (iso_en == DC1394_TRUE)\n\t{ \t/* Running in continuous mode.*/\n\t    settings_cache->running = 1;\n\t    *single_shot_on = 0;\n\t}\n\telse\n\t{ \t/* Running in single-shot mode or stopped.*/\n\t    ERROR_IF_DC1394_FAIL(\n\t\tdc1394_get_one_shot(camwire_bus_get_port(c_handle),\n\t\t\t\t    camwire_bus_get_node(c_handle),\n\t\t\t\t    &one_shot_set));\n\t    if (one_shot_set == DC1394_TRUE)\n\t    { \t/* Camera is running.*/\n\t\tsettings_cache->running = 1;\n\t\t*single_shot_on = 1;\n\t    }\n\t    else\n\t    { \t/* Camera is stopped.*/\n\t\tsettings_cache->running = 0;\n\t\t*single_shot_on = settings_cache->single_shot;\n\t    }\n\t}\n\tsettings_cache->single_shot = *single_shot_on;\n    }\n    return(CAMWIRE_SUCCESS);\n}", "path": "clib\\camwire_1394_cache_working.c", "repo_name": "madhadron/hscamwire", "stars": 1, "license": "lgpl-3.0", "language": "c", "size": 468}
{"docstring": "/*\n  -----------------------------------------------------------------------------\n  See camwire.h for documentation on this function.\n*/\n", "func_signal": "int camwire_read_settings(const char *filename, Camwire_settings *settings)", "code": "{\n    FILE *infile;\n    char error_message[FILE_ERROR_MAX_CHARS+1];\n    int scan_result;\n    \n    infile = fopen(filename, \"r\");\n    if (infile == NULL)\n    {\n\tsnprintf(error_message, FILE_ERROR_MAX_CHARS,\n\t\t \"Camwire could not open the file %s for reading.\", filename);\n\tDPRINTF(error_message);\n\treturn(CAMWIRE_FAILURE);\n    }\n    \n    scan_result = fscanf(infile,\n\t   \"Camwire settings:\\n\"\n\t   \"  num_frame_buffers: %d\\n\"\n\t   \"  blue_gain:         %lg\\n\"\n\t   \"  red_gain:          %lg\\n\"\n\t   \"  left:              %d\\n\"\n\t   \"  top:               %d\\n\"\n\t   \"  width:             %d\\n\"\n\t   \"  height:            %d\\n\"\n\t   \"  coding:            %d\\n\"\n\t   \"  frame_rate:        %lg\\n\"\n\t   \"  shutter:           %lg\\n\"\n\t   \"  external_trigger:  %d\\n\"\n\t   \"  trigger_polarity:  %d\\n\"\n\t   \"  single_shot:       %d\\n\"\n\t   \"  running:           %d\\n\"\n\t   \"  shadow:            %d\\n\",\n\t   &settings->num_frame_buffers,\n\t   &settings->blue_gain,\n\t   &settings->red_gain,\n\t   &settings->left,\n\t   &settings->top,\n\t   &settings->width,\n\t   &settings->height,\n\t   (int *) &settings->coding,\n\t   &settings->frame_rate,\n\t   &settings->shutter,\n\t   &settings->external_trigger,\n\t   &settings->trigger_polarity,\n\t   &settings->single_shot,\n\t   &settings->running,\n\t   &settings->shadow);\n\n    fclose(infile);\n    if (scan_result == EOF || scan_result != 15)\n    {\n\tDPRINTF(\"fscanf() failed in camwire_read_settings().\");\n\treturn(CAMWIRE_FAILURE);\n    }\n    return(CAMWIRE_SUCCESS);\n}", "path": "clib\\camwire_1394_cache_working.c", "repo_name": "madhadron/hscamwire", "stars": 1, "license": "lgpl-3.0", "language": "c", "size": 468}
{"docstring": "/*\n  -----------------------------------------------------------------------------\n  Disconnects the camera from and connects it to the bus.  Any changes\n  in the settings argument take effect, and the actual settings used are\n  returned.  The settings cache is also updated.  Note that the settings\n  argument should not point to the settings_cache, otherwise things get\n  tangled.  This function is used mainly to re-initialize the video1394\n  driver interface for things like changing the number of frame buffers,\n  frame dimensions or frame rate.  If the camera is running, it is\n  stopped and the process sleeps for at least one frame time before\n  disconnecting.  Returns CAMWIRE_SUCCESS on success or CAMWIRE_FAILURE\n  on failure.\n*/\n", "func_signal": "static int reconnect(const Camwire_handle c_handle,\n\t\t     const Camwire_settings *settings)", "code": "{\n    void * buffer;\n    \n    if (settings->running)\n    {\n\tERROR_IF_CAMWIRE_FAIL(\n\t    camwire_set_run_stop(c_handle, 0));\n\tERROR_IF_CAMWIRE_FAIL(\n\t    sleep_frametime(c_handle, 1.5));\n    }\n    \n    /* Flush all framebuffers to avoid video1394 crash on disconnect: */\n    for (;;)\n    {\n\tERROR_IF_CAMWIRE_FAIL(\n\t    camwire_point_next_frame_poll(c_handle, &buffer, NULL));\n\tif (buffer == NULL)  break;\n\tERROR_IF_CAMWIRE_FAIL(\n\t    camwire_unpoint_frame(c_handle));\n    }\n\n    disconnect(c_handle);\n    ERROR_IF_CAMWIRE_FAIL(\n\tconnect(c_handle, settings));\n    \n    return(CAMWIRE_SUCCESS);\n}", "path": "clib\\camwire_1394_cache_working.c", "repo_name": "madhadron/hscamwire", "stars": 1, "license": "lgpl-3.0", "language": "c", "size": 468}
{"docstring": "/*\n  ----------------------------------------------------------------------\n  See camwirebus.h for documentation on this function.\n*/\n", "func_signal": "void camwire_bus_reset(void)", "code": "{\n    int num_ports, num_nodes;\n    int p, h;\n    raw1394handle_t p_handle, last_port = NULL;\n\n    if (handle_array == NULL && num_cams == 0)\n    { \t/* No existing bus. */\n\tnum_ports = count_the_ports();\n\tfor (p = 0; p < num_ports; p++)\n\t{\n\t    p_handle = dc1394_create_handle(p);\n\t    if (p_handle)\n\t    {\n\t\tnum_nodes = count_the_nodes(p_handle);\n\t\tif (num_nodes > 0)  raw1394_reset_bus(p_handle);\n\t\tdc1394_destroy_handle(p_handle);\n\t    }\n\t}\n    }\n    else if (handle_array)\n    { \t/* A bus exists. */\n\tfor (h = 0; h < num_cams; h++)\n\t{\n\t    if ((h == 0) || (handle_array[h]->port != last_port)) \n\t    {\n\t\tp_handle = handle_array[h]->port;\n\t\tif (p_handle)\n\t\t{\n\t\t    num_nodes = count_the_nodes(p_handle);\n\t\t    if (num_nodes > 0)  raw1394_reset_bus(p_handle);\n\t\t    dc1394_destroy_handle(p_handle);\n\t\t}\n\t\tlast_port = p_handle;\n\t    }\n\t    free(handle_array[h]);\n\t}\n\tfree(handle_array);\n\thandle_array = NULL;\n    }\n    num_cams = 0;\n}", "path": "clib\\camwirebus_1394.c", "repo_name": "madhadron/hscamwire", "stars": 1, "license": "lgpl-3.0", "language": "c", "size": 468}
{"docstring": "/* FIXME: should take dc1394_cameracapture arg too. */\n/* FIXME: return the actual settings. */\n", "func_signal": "static int connect(const Camwire_handle c_handle,\n\t\t   const Camwire_settings *settings)", "code": "{\n    User_handle internal_status;\n    int frame_rate_index;\n    int num_packets, packet_size;\n    char *dma_device_file;\n    int depth;\n    quadlet_t bit_field; \t/* Unsigned 32-bit int (libraw1394).*/\n    unsigned int color_id;\n    double actual_frame_rate;\n    Camwire_pixel actual_coding;\n    \n    internal_status = camwire_bus_get_userdata(c_handle);\n    ERROR_IF_NULL(internal_status);\n    ERROR_IF_NULL(internal_status->capture_control);\n    if (settings == internal_status->settings_cache)\n    {\n\tDPRINTF(\"settings argument points to cache in connect().\");\n\treturn(CAMWIRE_FAILURE);\n    }\n\n    if (internal_status->config_cache->dma_device_name[0] == '\\0')\n    {\n\tdma_device_file = NULL;\n    }\n    else\n    {\n\tdma_device_file = internal_status->config_cache->dma_device_name;\n    }\n    \n    /* If dc1394_dma_release_camera() is called without a preceding\n       successful call to dc1394_dma_setup[_format7]_capture(),\n       libdc1394 gets into a tangled state.  That is why we have to keep\n       track with the capture_initialized flag, and check it in\n       disconnect(): */\n    internal_status->capture_initialized = 0;\n\n    ERROR_IF_ZERO(internal_status->config_cache->format);\n    if (internal_status->config_cache->format == FORMAT_VGA_NONCOMPRESSED)\n    { \t/* Format 0.*/\n\tframe_rate_index = convert_framerate2index(settings->frame_rate);\n\n\tERROR_IF_DC1394_FAIL(\n\t    dc1394_dma_setup_capture(camwire_bus_get_port(c_handle),\n\t\t\t\t     camwire_bus_get_node(c_handle),\n\t\t\t\t     /* Set channel = nodeid:*/\n\t\t\t\t     camwire_bus_get_node(c_handle),\n\t\t\t\t     internal_status->config_cache->format,\n\t\t\t\t     internal_status->config_cache->mode,\n\t\t\t\t     internal_status->config_cache->speed,\n\t\t\t\t     frame_rate_index,\n\t\t\t\t     settings->num_frame_buffers,\n\t\t\t\t     internal_status->config_cache->drop_frames,\n\t\t\t\t     dma_device_file,\n\t\t\t\t     internal_status->capture_control));\n\tactual_coding = convert_mode2pixelcoding(internal_status->config_cache->mode);\n\tactual_frame_rate = convert_index2framerate(frame_rate_index);\n    }\n    else if (internal_status->config_cache->format == FORMAT_SCALABLE_IMAGE_SIZE)\n    { \t/* Format 7.*/\n\t/* Prevent a segfault due to kalloc() bug in dma.c of the\n\t   linux1394 system.  This ought to be removed for later\n\t   versions: */\n\tERROR_IF_CAMWIRE_FAIL(\n\t    camwire_pixel_depth(settings->coding, &depth));\n\tif ((long) settings->num_frame_buffers *\n\t    settings->width*settings->height*depth > 8*IEEE1394_KALLOC_LIMIT)\n\t{\n\t    DPRINTF(\"Trying to allocate too large a DMA buffer in connect().\");\n\t    return(CAMWIRE_FAILURE);\n\t}\n\n\t/* Set up the color_coding_id before calling\n\t   dc1394_dma_setup_format7_capture(), otherwise the wrong DMA\n\t   buffer size may be allocated: */\n\t/* FIXME: this should be cached...*/\n\tERROR_IF_DC1394_FAIL(\n\t    dc1394_query_format7_color_coding(\n\t\tcamwire_bus_get_port(c_handle),\n\t\tcamwire_bus_get_node(c_handle),\n\t\tinternal_status->config_cache->mode,\n\t\t&bit_field));\n\tif (bit_field == 0)\n\t{\n\t    DPRINTF(\"dc1394_query_format7_color_coding() returned a null \"\n\t\t    \"bitfield in connect().\");\n\t    return(CAMWIRE_FAILURE);\n\t}\n\tcolor_id = convert_pixelcoding2colorid(settings->coding, bit_field);\n\tif (color_id == 0)\n\t{\n\t    DPRINTF(\"Pixel colour coding is invalid or not supported  by the \"\n\t\t    \"camera in connect().\");\n\t    return(CAMWIRE_FAILURE);\n\t}\n\tERROR_IF_DC1394_FAIL(\n\t    dc1394_set_format7_color_coding_id(\n\t\tcamwire_bus_get_port(c_handle),\n\t\tcamwire_bus_get_node(c_handle),\n\t\tinternal_status->config_cache->mode,\n\t\tcolor_id));\n\tactual_coding = convert_colorid2pixelcoding(color_id);\n\n\t/* Calculate the packet size from the wanted frame rate: */\n\tnum_packets =\n\t    convert_framerate2numpackets(c_handle, settings->frame_rate);\n\tpacket_size = convert_numpackets2packetsize(c_handle,\n\t\t\t\t\t\t    num_packets,\n\t\t\t\t\t\t    settings->width,\n\t\t\t\t\t\t    settings->height,\n\t\t\t\t\t\t    settings->coding);\n\n\t/* Set up the camera and DMA buffers: */\n\tERROR_IF_DC1394_FAIL(\n\t    dc1394_dma_setup_format7_capture(\n\t\tcamwire_bus_get_port(c_handle),\n\t\tcamwire_bus_get_node(c_handle),\n\t\t/* Set channel = nodeid: */\n\t\tcamwire_bus_get_node(c_handle),\n\t\tinternal_status->config_cache->mode,\n\t\tinternal_status->config_cache->speed,\n\t\tpacket_size,\n\t\tsettings->left, settings->top,\n\t\tsettings->width, settings->height,\n\t\tsettings->num_frame_buffers,\n\t\tinternal_status->config_cache->drop_frames,\n\t\tdma_device_file,\n\t\tinternal_status->capture_control));\n\tnum_packets = convert_packetsize2numpackets(c_handle,\n\t\t\t\t\t\t    packet_size,\n\t\t\t\t\t\t    settings->width,\n\t\t\t\t\t\t    settings->height,\n\t\t\t\t\t\t    actual_coding);\n\tactual_frame_rate =\n\t    convert_numpackets2framerate(c_handle, num_packets);\n    }\n    else\n    {\n\tDPRINTF(\"Unsupported camera format in connect().\");\n\treturn(CAMWIRE_FAILURE);\n    }\n    internal_status->capture_initialized = 1;\n\n    /* Update settings cache: */\n    internal_status->settings_cache->num_frame_buffers = settings->num_frame_buffers;\n    internal_status->settings_cache->left = settings->left;\n    internal_status->settings_cache->top = settings->top;\n    internal_status->settings_cache->width = settings->width;\n    internal_status->settings_cache->height = settings->height;\n    internal_status->settings_cache->coding = actual_coding;\n    internal_status->settings_cache->frame_rate = actual_frame_rate;\n\n    /* Initialize camera registers not already done by\n       dc1394_dma_setup_...() and update shadow state of these: */\n    ERROR_IF_CAMWIRE_FAIL(\n\tset_non_dma_registers(c_handle, settings));\n    return(CAMWIRE_SUCCESS);\n}", "path": "clib\\camwire_1394_cache_working.c", "repo_name": "madhadron/hscamwire", "stars": 1, "license": "lgpl-3.0", "language": "c", "size": 468}
{"docstring": "/*\n  -----------------------------------------------------------------------------\n  See camwire.h for documentation on this function.\n*/\n", "func_signal": "int camwire_set_single_shot(const Camwire_handle c_handle,\n\t\t\t    const int single_shot_on)", "code": "{\n    dc1394bool_t iso_en, one_shot_set;\n    Camwire_settings *settings_cache;\n\n    ERROR_IF_NULL(c_handle);\n    settings_cache = get_settings_cache(c_handle);\n    ERROR_IF_NULL(settings_cache);\n    if ((settings_cache->shadow & CAMWIRE_SHADOW_SETTINGS) != 0)\n    {\n\tif (settings_cache->running)\n\t{  /* We *think* the camera is running.*/\n\t    if (!settings_cache->single_shot && single_shot_on)\n\t    { \t/* Camera is running: change to single-shot:*/\n\t\tERROR_IF_DC1394_FAIL(\n\t\t    dc1394_stop_iso_transmission(\n\t\t\tcamwire_bus_get_port(c_handle),\n\t\t\tcamwire_bus_get_node(c_handle)));\n\t\tERROR_IF_DC1394_FAIL(\n\t\t    dc1394_set_one_shot(\n\t\t\tcamwire_bus_get_port(c_handle),\n\t\t\tcamwire_bus_get_node(c_handle)));\n\t    }\n\t    else if (settings_cache->single_shot && !single_shot_on)\n\t    { \t/* Don't know if camera is still runnning: let's find out:*/\n\t\tERROR_IF_DC1394_FAIL(\n\t\t    dc1394_get_one_shot(camwire_bus_get_port(c_handle),\n\t\t\t\t\tcamwire_bus_get_node(c_handle),\n\t\t\t\t\t&one_shot_set));\n\t\tif (one_shot_set == DC1394_TRUE)\n\t\t{  /* Camera is still runnning: change to continuous:*/\n\t\t    ERROR_IF_DC1394_FAIL(\n\t\t\tdc1394_unset_one_shot(camwire_bus_get_port(c_handle),\n\t\t\t\t\t      camwire_bus_get_node(c_handle)));\n\t\t    ERROR_IF_DC1394_FAIL(\n\t\t\tdc1394_start_iso_transmission(\n\t\t\t    camwire_bus_get_port(c_handle),\n\t\t\t    camwire_bus_get_node(c_handle)));\n\t\t}\n\t\telse\n\t\t{  /* Camera has finished single shot: update shadow state:*/\n\t\t    settings_cache->running = 0;\n\t\t}\n\t    }\n\t}\n\t/* else change only the internal state.*/\n    }\n    else\n    {  /* Don't use shadow: ask the camera:*/\n\tERROR_IF_DC1394_FAIL(\n\t    dc1394_get_iso_status(camwire_bus_get_port(c_handle),\n\t\t\t\t  camwire_bus_get_node(c_handle),\n\t\t\t\t  &iso_en));\n\t\n\tif (iso_en == DC1394_TRUE && single_shot_on)\n\t{ \t/* Camera is running: change to single-shot:*/\n\t    ERROR_IF_DC1394_FAIL(\n\t\tdc1394_stop_iso_transmission(camwire_bus_get_port(c_handle),\n\t\t\t\t\t     camwire_bus_get_node(c_handle)));\n\t    ERROR_IF_DC1394_FAIL(\n\t\tdc1394_set_one_shot(camwire_bus_get_port(c_handle),\n\t\t\t\t    camwire_bus_get_node(c_handle)));\n\t    settings_cache->running = 1;\n\t}\n\telse if (iso_en == DC1394_FALSE && !single_shot_on)\n\t{\n\t    ERROR_IF_DC1394_FAIL(\n\t\tdc1394_get_one_shot(camwire_bus_get_port(c_handle),\n\t\t\t\t    camwire_bus_get_node(c_handle),\n\t\t\t\t    &one_shot_set));\n\t    if (one_shot_set == DC1394_TRUE)\n\t    { \t/* Camera is still runnning: change to continuous:*/\n\t\tERROR_IF_DC1394_FAIL(\n\t\t    dc1394_unset_one_shot(camwire_bus_get_port(c_handle),\n\t\t\t\t\t  camwire_bus_get_node(c_handle)));\n\t\tERROR_IF_DC1394_FAIL(\n\t\t    dc1394_start_iso_transmission(\n\t\t\tcamwire_bus_get_port(c_handle),\n\t\t\tcamwire_bus_get_node(c_handle)));\n\t\tsettings_cache->running = 1;\n\t    }\n\t    /* else change only the internal state.*/\n\t}\n    }\n    settings_cache->single_shot = single_shot_on;\n\n    return(CAMWIRE_SUCCESS);\n}", "path": "clib\\camwire_1394_cache_working.c", "repo_name": "madhadron/hscamwire", "stars": 1, "license": "lgpl-3.0", "language": "c", "size": 468}
{"docstring": "/*\n  -----------------------------------------------------------------------------\n  See camwire.h for documentation on this function.\n*/\n/* The pixel colour coding is updated by disconnecting and reconnecting\n   the camera.  I have not been able to do it less brutally.  It seems\n   that the video1394 driver does not expect the frame size to change\n   even if enough memory has been allocated for larger frames. */\n", "func_signal": "int camwire_set_pixel_coding(const Camwire_handle c_handle,\n\t\t\t     const Camwire_pixel coding)", "code": "{\n    Camwire_config cfg;\n    Camwire_pixel old_coding;\n    quadlet_t bit_field; \t/* Unsigned 32-bit int (libraw1394).*/\n    unsigned int color_id;\n    int old_depth, new_depth;\n    Camwire_settings *settings_cache;\n    Camwire_settings set;\n    \n    ERROR_IF_NULL(c_handle);\n    ERROR_IF_CAMWIRE_FAIL(\n\tcamwire_get_config(c_handle, &cfg));\n    ERROR_IF_ZERO(cfg.format);\n    if (cfg.format == FORMAT_VGA_NONCOMPRESSED)\n    { \t/* Format 0.*/\n\tDPRINTF(\"Attempt to set pixel coding in Format 0 in \"\n\t\t\"camwire_set_pixel_coding().\");\n\treturn(CAMWIRE_FAILURE); \t/* Can't in Format 0.*/\n    }\n    else if (cfg.format == FORMAT_SCALABLE_IMAGE_SIZE)\n    { \t/* Format 7.*/\n\tERROR_IF_CAMWIRE_FAIL(\n\t    camwire_get_pixel_coding(c_handle, &old_coding));\n\n        /* Only proceed if pixel colour coding has changed: */\n\tif (coding != old_coding)\n\t{\n\t    /* Check if new pixel coding is supported by camera: */\n\t    ERROR_IF_DC1394_FAIL(\n\t\tdc1394_query_format7_color_coding(\n\t\t    camwire_bus_get_port(c_handle),\n\t\t    camwire_bus_get_node(c_handle),\n\t\t    cfg.mode,\n\t\t    &bit_field));\n\t    if (bit_field == 0)\n\t    {\n\t\tDPRINTF(\"dc1394_query_format7_color_coding() returned a null \"\n\t\t\t\"bitfield in camwire_set_pixel_coding().\");\n\t\treturn(CAMWIRE_FAILURE);\n\t    }\n\t    color_id = convert_pixelcoding2colorid(coding, bit_field);\n\t    if (color_id == 0)\n\t    {\n\t\tDPRINTF(\"Pixel colour coding is invalid or not supported  by \"\n\t\t\t\"the camera in camwire_set_pixel_coding().\");\n\t\treturn(CAMWIRE_FAILURE);\n\t    }\n\n\t    /* Set the new coding: */\n\t    ERROR_IF_CAMWIRE_FAIL(\n\t\tcamwire_pixel_depth(old_coding, &old_depth));\n\t    ERROR_IF_CAMWIRE_FAIL(\n\t\tcamwire_pixel_depth(coding, &new_depth));\n\t    if (new_depth == old_depth)\n\t    {\n\t\t/* Set the new coding directly: */\n\t\tERROR_IF_DC1394_FAIL(\n\t\t    dc1394_set_format7_color_coding_id(\n\t\t\tcamwire_bus_get_port(c_handle),\n\t\t\tcamwire_bus_get_node(c_handle),\n\t\t\tcfg.mode,\n\t\t\tcolor_id));\n\t\tsettings_cache = get_settings_cache(c_handle);\n\t\tERROR_IF_NULL(settings_cache);\n\t\tsettings_cache->coding = coding;\n\t    }\n\t    else\n\t    {\n\t\t/* Re-initialize the camera with the new coding: */\n\t\tERROR_IF_CAMWIRE_FAIL(\n\t\t    get_setting_values(c_handle, &set));\n\t\tset.coding = coding;\n\t\tERROR_IF_CAMWIRE_FAIL(\n\t\t    reconnect(c_handle, &set));\n\t    }\n\t}\n    }\n    else\n    {\n\tDPRINTF(\"Unsupported camera format in camwire_set_pixel_coding().\");\n\treturn(CAMWIRE_FAILURE);\n    }\n    return(CAMWIRE_SUCCESS);\n}", "path": "clib\\camwire_1394_cache_working.c", "repo_name": "madhadron/hscamwire", "stars": 1, "license": "lgpl-3.0", "language": "c", "size": 468}
{"docstring": "/*\n  -----------------------------------------------------------------------------\n  Returns a pointer to the Camwire_settings structure for the given camwire\n  handle, or NULL on error.  Needed by many camwire_get/set_...()\n  functions.\n*/\n", "func_signal": "inline static\nCamwire_settings * get_settings_cache(const Camwire_handle c_handle)", "code": "{\n    User_handle internal_status;\n\n    internal_status = camwire_bus_get_userdata(c_handle);\n    if (internal_status == NULL)  return(NULL);\n    return(internal_status->settings_cache);\n}", "path": "clib\\camwire_1394_cache_working.c", "repo_name": "madhadron/hscamwire", "stars": 1, "license": "lgpl-3.0", "language": "c", "size": 468}
{"docstring": "/*\n  ----------------------------------------------------------------------\n  See camwire.h for documentation on this function.\n*/\n", "func_signal": "int camwire_trigger_present(const Camwire_handle c_handle, int *has_trigger)", "code": "{\n    Cam_capabilities *features;\n    dc1394bool_t present;\n\n    ERROR_IF_NULL(c_handle);\n    features = get_features_cache(c_handle);\n    if (features == NULL)\n    { /* Cache does not yet exist.*/\n\tERROR_IF_DC1394_FAIL(\n\t    dc1394_is_feature_present(camwire_bus_get_port(c_handle),\n\t\t\t\t      camwire_bus_get_node(c_handle),\n\t\t\t\t      FEATURE_TRIGGER,\n\t\t\t\t      &present));\n\t*has_trigger = (present == DC1394_TRUE);\n    }\n    else\n    { /* Cache exists.*/\n\tif (features->trigger.feature_id != FEATURE_TRIGGER)\n\t{\t\n\t    DPRINTF(\"Bad trigger feature_id in camwire_trigger_present().\");\n\t    return(CAMWIRE_FAILURE);\n\t}\n\t*has_trigger = (features->trigger.available == DC1394_TRUE);\n    }\n    return(CAMWIRE_SUCCESS);\n}", "path": "clib\\camwire_1394_cache_working.c", "repo_name": "madhadron/hscamwire", "stars": 1, "license": "lgpl-3.0", "language": "c", "size": 468}
{"docstring": "/* FIXME: should return the changed settings. */\n", "func_signal": "static int create(const Camwire_handle c_handle,\n\t\t  const Camwire_settings *settings)", "code": "{\n    User_handle internal_status;\n\n    /* Allocate zero-filled space for internal status, and register a\n       pointer to it in the camera handle: */\n    internal_status = (struct camwire_user_data *)\n\tcalloc(1, sizeof(struct camwire_user_data));\n    /* struct camwire_user_data is defined above.*/\n    /* Note that internal_status is zero-filled by calloc().  Other\n       functions may use this fact (and the existence of a pointer to\n       it) to check if it has been initialized or not. */\n    ERROR_IF_NULL(internal_status); \t/* Allocation failure.*/\n    if (!camwire_bus_set_userdata(c_handle, internal_status))\n    {   /* Already in use.*/\n\tDPRINTF(\"camwire_bus_set_userdata() failed in create().\");\n\tfree(internal_status);\n\treturn(CAMWIRE_FAILURE);\n    }\n\n    /* Allocate and initialize the various caches: */\n    if (create_features_cache(c_handle, internal_status) == NULL ||\n\tcreate_config_cache(c_handle, internal_status) == NULL ||\n\tcreate_settings_cache(settings, internal_status) == NULL ||\n\tcreate_capture_control(internal_status) == NULL)\n    {\n\tDPRINTF(\"Allocating or initializing a cache failed in create().\");\n\tdestroy(c_handle);\n\treturn(CAMWIRE_FAILURE);\n    }\n    \n    /* Connect the camera to the bus and initialize it with our\n       settings: */\n    if (connect(c_handle, settings) != CAMWIRE_SUCCESS)\n    {\n\tDPRINTF(\"connect() failed in create().\");\n\tdestroy(c_handle);\n\treturn(CAMWIRE_FAILURE);\n    }\n\n    /* Update the settings with actual values returned from\n       connect(): */\n    \n    return(CAMWIRE_SUCCESS);\n}", "path": "clib\\camwire_1394_cache_working.c", "repo_name": "madhadron/hscamwire", "stars": 1, "license": "lgpl-3.0", "language": "c", "size": 468}
{"docstring": "/*\n  ----------------------------------------------------------------------\n  Returns the total number of IEEE 1394 cameras on all available IEEE\n  1394 ports, or -1 on error.  The number of visible ports is provided\n  in n_ports, which may be the null pointer if not needed.\n*/\n", "func_signal": "static int count_the_cameras(const int num_ports)", "code": "{\n    int camcount, p, num_nodes;\n    raw1394handle_t p_handle;\n    \n    camcount = 0;\n    for (p = 0; p < num_ports; p++)\n    {\n\tp_handle = dc1394_create_handle(p);\n\tif (p_handle == NULL)\n\t{\n\t    camcount = -1;\n\t    break;\n\t}\n\tnum_nodes = count_the_nodes(p_handle);\n\tif (num_nodes < 0)\n\t{\n\t    dc1394_destroy_handle(p_handle);\n\t    camcount = -1;\n\t    break;\n\t}\n\tcamcount += num_nodes;\n\tdc1394_destroy_handle(p_handle);\n    }\n    return(camcount);\n}", "path": "clib\\camwirebus_1394.c", "repo_name": "madhadron/hscamwire", "stars": 1, "license": "lgpl-3.0", "language": "c", "size": 468}
{"docstring": "/*\n  -----------------------------------------------------------------------------\n  See camwire.h for documentation on this function.\n*/\n", "func_signal": "int camwire_set_shutter(const Camwire_handle c_handle, const double shutter)", "code": "{\n    Camwire_settings *settings_cache;\n    dc1394bool_t has_shutter;\n    Camwire_config cfg;\n    unsigned int shutter_reg, shutter_min, shutter_max;\n\n    ERROR_IF_NULL(c_handle);\n    settings_cache = get_settings_cache(c_handle);\n    ERROR_IF_NULL(settings_cache);\n    ERROR_IF_DC1394_FAIL(\n\tdc1394_is_feature_present(camwire_bus_get_port(c_handle),\n\t\t\t\t  camwire_bus_get_node(c_handle),\n\t\t\t\t  FEATURE_SHUTTER,\n\t\t\t\t  &has_shutter));\n    if (has_shutter != DC1394_TRUE)\n    {\n\tsettings_cache->shutter = shutter;\n\tDPRINTF(\"dc1394_is_feature_present() reports no shutter in\"\n\t\t\"camwire_set_shutter().\");\n\treturn(CAMWIRE_FAILURE);\n    }\n    \n    ERROR_IF_CAMWIRE_FAIL(\n\tcamwire_get_config(c_handle, &cfg));\n\n    shutter_reg = (unsigned int)\n\t((shutter - cfg.exposure_offset)/cfg.exposure_quantum + 0.5);\n\n    /* Limit shutter_reg to the allowed range: */\n    ERROR_IF_DC1394_FAIL(\n\tdc1394_get_min_value(camwire_bus_get_port(c_handle),\n\t\t\t     camwire_bus_get_node(c_handle),\n\t\t\t     FEATURE_SHUTTER,\n\t\t\t     &shutter_min));\n    if (shutter_reg < shutter_min)  shutter_reg = shutter_min;\n\n    ERROR_IF_DC1394_FAIL(\n\tdc1394_get_max_value(camwire_bus_get_port(c_handle),\n\t\t\t     camwire_bus_get_node(c_handle),\n\t\t\t     FEATURE_SHUTTER,\n\t\t\t     &shutter_max));\n    if (shutter_reg > shutter_max)  shutter_reg = shutter_max;\n\n    ERROR_IF_DC1394_FAIL(\n\tdc1394_set_shutter(camwire_bus_get_port(c_handle),\n\t\t\t   camwire_bus_get_node(c_handle),\n\t\t\t   shutter_reg));\n    settings_cache->shutter =\n\tcfg.exposure_offset + shutter_reg*cfg.exposure_quantum;\n\n    return(CAMWIRE_SUCCESS);\n}", "path": "clib\\camwire_1394_cache_working.c", "repo_name": "madhadron/hscamwire", "stars": 1, "license": "lgpl-3.0", "language": "c", "size": 468}
{"docstring": "/*\n  -----------------------------------------------------------------------------\n  See camwire.h for documentation on this function.\n*/\n", "func_signal": "int camwire_pixel_depth(const Camwire_pixel coding, int *depth)", "code": "{\n    switch (coding)\n    {\n\tcase CAMWIRE_PIXEL_MONO8:\n\t    /* case CAMWIRE_PIXEL_RAW8: */\n\t    *depth = 8;\n\t    break;\n\tcase CAMWIRE_PIXEL_YUV411:\n\t    *depth = 12;\n\t    break;\n\tcase CAMWIRE_PIXEL_YUV422:\n\tcase CAMWIRE_PIXEL_MONO16:\n\t    /* case CAMWIRE_PIXEL_MONO16S: */\n\t    /* case CAMWIRE_PIXEL_RAW16: */\n\t    *depth = 16;\n\t    break;\n\tcase CAMWIRE_PIXEL_YUV444:\n\tcase CAMWIRE_PIXEL_RGB8:\n\t    *depth = 24;\n\t    break;\n\tcase CAMWIRE_PIXEL_RGB16:\n\t    /* case CAMWIRE_PIXEL_RGB16S: */\n\t    *depth = 48;\n\t    break;\n\tdefault:\n\t    *depth = 0;\n\t    return(CAMWIRE_FAILURE);  /* Invalid or unknown coding.*/\n\t    break;\n    }\n    return(CAMWIRE_SUCCESS);\n}", "path": "clib\\camwire_1394_cache_working.c", "repo_name": "madhadron/hscamwire", "stars": 1, "license": "lgpl-3.0", "language": "c", "size": 468}
{"docstring": "/*\n  -----------------------------------------------------------------------------\n  Returns the IEEE 1394 mode (a subdivision of the format), or 0 on\n  error.\n*/\n", "func_signal": "inline static unsigned int get_1394_mode(const Camwire_handle c_handle)", "code": "{\n    Camwire_config *config;\n\n    config = get_config_cache(c_handle);\n    if (config == NULL)\n    {\n\treturn(0);\n    }\n    return(config->mode);\n}", "path": "clib\\camwire_1394_cache_working.c", "repo_name": "madhadron/hscamwire", "stars": 1, "license": "lgpl-3.0", "language": "c", "size": 468}
{"docstring": "/*\n  -----------------------------------------------------------------------------\n  See camwire.h for documentation on this function.\n*/\n", "func_signal": "int camwire_get_frame_size(const Camwire_handle c_handle, int *width,\n\t\t\t   int *height)", "code": "{\n    Camwire_settings *settings_cache;\n    unsigned int format, mode;\n    dc1394_cameracapture *capture_control;\n\n    ERROR_IF_NULL(c_handle);\n    settings_cache = get_settings_cache(c_handle);\n    ERROR_IF_NULL(settings_cache);\n    if ((settings_cache->shadow & CAMWIRE_SHADOW_SETTINGS) != 0)\n    {\n\t*width = settings_cache->width;\n\t*height = settings_cache->height;\n    }\n    else\n    {\n\tformat = get_1394_format(c_handle);\n\tERROR_IF_ZERO(format);\n\tif (format == FORMAT_VGA_NONCOMPRESSED)\n\t{ \t/* Format 0.*/\n\t    capture_control = get_capture_control(c_handle);\n\t    ERROR_IF_NULL(capture_control);\n\t    if (capture_control->frame_width == 0 ||\n\t\tcapture_control->frame_height == 0)\n\t    {\n\t\tDPRINTF(\"dc1394_cameracapture contains a zero frame size in \"\n\t\t\t\"camwire_get_frame_size().\");\n\t\treturn(CAMWIRE_FAILURE);\n\t    }\n\t    *width = capture_control->frame_width;\n\t    *height = capture_control->frame_height;\n\t}\n\telse if (format == FORMAT_SCALABLE_IMAGE_SIZE)\n\t{ \t/* Format 7.*/\n\t    mode = get_1394_mode(c_handle);\n\t    ERROR_IF_ZERO(mode);\n\t    ERROR_IF_DC1394_FAIL(\n\t\tdc1394_query_format7_image_size(\n\t\t    camwire_bus_get_port(c_handle),\n\t\t    camwire_bus_get_node(c_handle),\n\t\t    mode,\n\t\t    (unsigned int *) width,\n\t\t    (unsigned int *) height));\n\t}\n\telse\n\t{\n\t    DPRINTF(\"Unsupported camera format in camwire_get_frame_size().\");\n\t    return(CAMWIRE_FAILURE);\n\t}\n\tsettings_cache->width = *width;\n\tsettings_cache->height = *height;\n    }\n    return(CAMWIRE_SUCCESS);\n}", "path": "clib\\camwire_1394_cache_working.c", "repo_name": "madhadron/hscamwire", "stars": 1, "license": "lgpl-3.0", "language": "c", "size": 468}
{"docstring": "/*\n  -----------------------------------------------------------------------------\n  See camwire.h for documentation on this function.\n*/\n", "func_signal": "int camwire_point_next_frame(const Camwire_handle c_handle, void **buf_ptr,\n\t\t\t     int *buffer_lag)", "code": "{\n    User_handle internal_status;\n    dc1394_cameracapture *capture_control;\n    int dc1394_return, missed_frames;\n\n    ERROR_IF_NULL(c_handle);\n    internal_status = camwire_bus_get_userdata(c_handle);\n    ERROR_IF_NULL(internal_status);\n    capture_control = internal_status->capture_control;\n    ERROR_IF_NULL(capture_control);\n\n    dc1394_return = dc1394_dma_single_capture(capture_control);\n    if (dc1394_return != DC1394_SUCCESS)\n    {\n\tDPRINTF(\"dc1394_dma_single_capture() failed in \"\n\t\t\"camwire_point_next_frame().\");\n\treturn(CAMWIRE_FAILURE);\n    }\n    *buf_ptr = (void *) capture_control->capture_buffer;\n\n    /* Increment the frame number if we have a frame: */\n    if (capture_control->drop_frames)\n    {\n\tmissed_frames = capture_control->num_dma_buffers_behind;\n    }\n    else\n    {\n\tmissed_frames = 0;\n    }\n    internal_status->frame_number += 1 + missed_frames;\n\n    if (buffer_lag != NULL)\n    {\n\tERROR_IF_CAMWIRE_FAIL(\n\t    camwire_get_framebuffer_lag(c_handle, buffer_lag));\n    }\n    return(CAMWIRE_SUCCESS);\n}", "path": "clib\\camwire_1394_cache_working.c", "repo_name": "madhadron/hscamwire", "stars": 1, "license": "lgpl-3.0", "language": "c", "size": 468}
{"docstring": "/*\n  -----------------------------------------------------------------------------\n  Allocates memory for the configuration cache and fills it with values\n  obtained from a configuration file, or from the camera and some\n  guesswork if a file does not exist.  Returns the config_cache pointer\n  on success or NULL on failure.\n*/\n", "func_signal": "static Camwire_config * create_config_cache(const Camwire_handle c_handle,\n\t\t\t\t\t    User_handle is)", "code": "{\n    is->config_initialized = 0;\n    is->config_cache = (Camwire_config *) malloc(sizeof(Camwire_config));\n    if (is->config_cache == NULL)\n    {\n\tDPRINTF(\"malloc(Camwire_config) failed in create_config_cache().\");\n\treturn(NULL);\n    }\n    if (camwire_get_config(c_handle, is->config_cache) != CAMWIRE_SUCCESS)\n    {\n\tDPRINTF(\"camwire_get_config() failed in create_config_cache().\");\n\tfree(is->config_cache);\n\treturn(NULL);\n    }\n    is->config_initialized = 1;\n    return(is->config_cache);\n}", "path": "clib\\camwire_1394_cache_working.c", "repo_name": "madhadron/hscamwire", "stars": 1, "license": "lgpl-3.0", "language": "c", "size": 468}
{"docstring": "/*\n  -----------------------------------------------------------------------------\n  See camwire.h for documentation on this function.\n*/\n", "func_signal": "int camwire_get_white_balance(const Camwire_handle c_handle, double *blue_gain,\n\t\t\t      double *red_gain)", "code": "{\n    Camwire_settings *settings_cache;\n    dc1394bool_t has_white_balance;\n    unsigned int blue, red;\n    Camwire_config cfg;\n\n    ERROR_IF_NULL(c_handle);\n    ERROR_IF_DC1394_FAIL(\n\tdc1394_is_feature_present(camwire_bus_get_port(c_handle),\n\t\t\t\t  camwire_bus_get_node(c_handle),\n\t\t\t\t  FEATURE_WHITE_BALANCE,\n\t\t\t\t  &has_white_balance));\n    if (has_white_balance != DC1394_TRUE)\n    {\n\tDPRINTF(\"dc1394_is_feature_present() reports no white balance in \"\n\t\t\"camwire_get_white_balance().\");\n\treturn(CAMWIRE_FAILURE);\n    }\n    \n    settings_cache = get_settings_cache(c_handle);\n    ERROR_IF_NULL(settings_cache);\n    if ((settings_cache->shadow & CAMWIRE_SHADOW_SETTINGS) != 0)\n    {\n\t*blue_gain = settings_cache->blue_gain;\n\t*red_gain = settings_cache->red_gain;\n    }\n    else\n    {\n\t*blue_gain = *red_gain = 1;  /* Default.*/\n\tERROR_IF_DC1394_FAIL(\n\t    dc1394_get_white_balance(camwire_bus_get_port(c_handle),\n\t\t\t\t     camwire_bus_get_node(c_handle),\n\t\t\t\t     &blue, &red));\n\tERROR_IF_CAMWIRE_FAIL(\n\t    camwire_get_config(c_handle, &cfg));\n\t*blue_gain = blue/cfg.blue_gain_norm;\n\t*red_gain = red/cfg.red_gain_norm;\n\tsettings_cache->blue_gain = *blue_gain;\n\tsettings_cache->red_gain = *red_gain;\n    }\n    return(CAMWIRE_SUCCESS);\n}", "path": "clib\\camwire_1394_cache_working.c", "repo_name": "madhadron/hscamwire", "stars": 1, "license": "lgpl-3.0", "language": "c", "size": 468}
{"docstring": "/** Purge old items from the peer_list and return the number of items that were removed. */\n", "func_signal": "size_t purge_peer_list( struct peer_info ** peer_list,\n                        time_t purge_before )", "code": "{\n  struct peer_info *scan;\n  struct peer_info *prev;\n  size_t retval=0;\n\n  scan = *peer_list;\n  prev = NULL;\n  while(scan != NULL)\n    {\n      if(scan->last_seen < purge_before)\n        {\n\t  struct peer_info *next = scan->next;\n\n\t  if(prev == NULL)\n            {\n\t      *peer_list = next;\n            }\n\t  else\n            {\n\t      prev->next = next;\n            }\n\n\t  ++retval;\n\t  free(scan);\n\t  scan = next;\n        }\n      else\n        {\n\t  prev = scan;\n\t  scan = scan->next;\n        }\n    }\n\n  return retval;\n}", "path": "n2n.c", "repo_name": "yclee/n2n", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 252}
{"docstring": "/* ************************************** */\n", "func_signal": "static\nint marshall_uint32( u_int8_t * buf, size_t * offset, u_int32_t val )", "code": "{\n    buf[*offset + 0] = ((val >> 24) & 0xff);\n    buf[*offset + 1] = ((val >> 16) & 0xff);\n    buf[*offset + 2] = ((val >>  8) & 0xff);\n    buf[*offset + 3] = ((val      ) & 0xff);\n\n    *offset += 4;\n    return 4;\n}", "path": "n2n.c", "repo_name": "yclee/n2n", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 252}
{"docstring": "/* *********************************************** */\n", "func_signal": "int main(int argc, char* argv[])", "code": "{\n  int opt; \n  u_int16_t local_port = 0;\n  n2n_sock_info_t udp_sinfo;\n  n2n_sock_info_t tcp_sinfo;\n\n#ifdef WIN32\n  initWin32();\n#endif\n\n  optarg = NULL;\n  while((opt = getopt_long(argc, argv, \"l:vh\", long_options, NULL)) != EOF) {\n    switch (opt) {\n    case 'l': /* local-port */\n      local_port = atoi(optarg) & 0xffff;\n      break;\n    case 'h': /* help */\n      help();\n      break;\n    case 'v': /* verbose */\n      traceLevel = 3;\n      break;\n    }\n  }\n\n  if(!(local_port))\n    help();\n\n  udp_sinfo.is_udp_socket=1;\n  udp_sinfo.sock = open_socket(local_port, 1, 0);\n  if(udp_sinfo.sock < 0) return(-1);\n\n  tcp_sinfo.is_udp_socket=0;\n  tcp_sinfo.sock = open_socket(local_port, 0, 1);\n  if(tcp_sinfo.sock < 0) return(-1);\n\n  traceEvent(TRACE_NORMAL, \"Supernode ready: listening on port %hu [TCP/UDP]\", local_port);\n\n  while(1) {\n    int rc, max_sock;\n    fd_set socket_mask;\n    struct timeval wait_time;\n\n    FD_ZERO(&socket_mask);\n    max_sock = max(udp_sinfo.sock, tcp_sinfo.sock);\n    FD_SET(udp_sinfo.sock, &socket_mask);\n    FD_SET(tcp_sinfo.sock, &socket_mask);\n\n    wait_time.tv_sec = 10; wait_time.tv_usec = 0;\n    rc = select(max_sock+1, &socket_mask, NULL, NULL, &wait_time);\n\n    if(rc > 0) {\n      if(FD_ISSET(udp_sinfo.sock, &socket_mask)) {\n\tchar packet[2048];\n\tsize_t len;\n\tstruct peer_addr sender;\n\tu_int8_t discarded_pkt;\n\tstruct n2n_packet_header hdr;\n\n\tlen = receive_data( &udp_sinfo, packet, sizeof(packet), &sender, &discarded_pkt, NULL, 0, &hdr);\n\n\tif(len <= 0)\n\t  traceEvent(TRACE_WARNING, \"recvfrom()=%d [%s]\\n\", len, strerror(errno));\n\telse {\n\t  handle_packet(packet, len, &sender, &udp_sinfo);\n\t}\n      } else if(FD_ISSET(tcp_sinfo.sock, &socket_mask)) {\n\tstruct sockaddr from;\n\tint from_len = sizeof(from);\n\tint new_sock = accept(tcp_sinfo.sock, (struct sockaddr*)&from,\n\t\t\t      (socklen_t*)&from_len);\n\n\tif(new_sock < 0) {\n\t  traceEvent(TRACE_WARNING, \"TCP connection accept() failed [%s]\\n\", strerror(errno));\n\t} else {\n\t  startTcpReadThread(new_sock);\n\t}\n      }\n    }\n\n    purge_expired_registrations( &known_peers );\n  } /* while */\n\n  closesocket(udp_sinfo.sock);\n  closesocket(tcp_sinfo.sock);\n\n  return(0);\n}", "path": "supernode.c", "repo_name": "yclee/n2n", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 252}
{"docstring": "/* *********************************************** */\n", "func_signal": "static void help()", "code": "{\n  print_n2n_version();\n  printf(\"supernode -l <listening port> [-v] [-h]\\n\");\n  exit(0);\n}", "path": "supernode.c", "repo_name": "yclee/n2n", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 252}
{"docstring": "/* *********************************************** */\n", "func_signal": "extern void sockaddr_in2peer_addr(struct sockaddr_in *in, struct peer_addr *out)", "code": "{\n  out->family            = (u_int8_t)in->sin_family;\n  out->port              = in->sin_port;\n  out->addr_type.v4_addr = in->sin_addr.s_addr;\n}", "path": "n2n.c", "repo_name": "yclee/n2n", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 252}
{"docstring": "/* ************************************** */\n", "func_signal": "SOCKET open_socket(u_int16_t local_port, int udp_sock, int server_mode)", "code": "{\n  SOCKET sock_fd;\n  struct sockaddr_in local_address;\n  int sockopt = 1;\n\n  if((sock_fd = socket(PF_INET, udp_sock ? SOCK_DGRAM : SOCK_STREAM, 0))  < 0) {\n    traceEvent(TRACE_ERROR, \"Unable to create socket [%s][%d]\\n\",\n\t       strerror(errno), sock_fd);\n    return(-1);\n  }\n\n#ifndef WIN32\n  /* fcntl(sock_fd, F_SETFL, O_NONBLOCK); */\n#endif\n\n  setsockopt(sock_fd, SOL_SOCKET, SO_REUSEADDR, (char *)&sockopt, sizeof(sockopt));\n\n  memset(&local_address, 0, sizeof(local_address));\n  local_address.sin_family = AF_INET;\n  local_address.sin_port = htons(local_port);\n  local_address.sin_addr.s_addr = INADDR_ANY;\n  if(bind(sock_fd, (struct sockaddr*) &local_address, sizeof(local_address)) == -1) {\n    traceEvent(TRACE_ERROR, \"Bind error [%s]\\n\", strerror(errno));\n    return(-1);\n  }\n\n  if((!udp_sock) && server_mode) {\n    if(listen(sock_fd, 255) == -1) {\n      traceEvent(TRACE_ERROR, \"Listen error [%s]\\n\", strerror(errno));\n      return(-1);\n    }\n  }\n\n  return(sock_fd);\n}", "path": "n2n.c", "repo_name": "yclee/n2n", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 252}
{"docstring": "/* *********************************************** */\n", "func_signal": "void print_n2n_version()", "code": "{\n  printf(\"Welcome to n2n v.%s for %s\\n\"\n         \"Built on %s\\n\"\n\t \"Copyright 2007-08 - http://www.ntop.org\\n\\n\",\n         version, osName, buildDate);\n}", "path": "n2n.c", "repo_name": "yclee/n2n", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 252}
{"docstring": "/* ************************************** */\n", "func_signal": "static\nint marshall_peer_addr( u_int8_t * buf, size_t * offset, const struct peer_addr * s )", "code": "{\n /* RA: I'm pretty sure that this is broken. There is no guarantee that the\n  * peer_addr structure is packed. This will always work between like hosts but\n  * is almost certainly broken between different host types. */\n  memcpy( buf + *offset, s, sizeof(struct peer_addr));\n  *offset += sizeof(struct peer_addr);\n\n  return sizeof(struct peer_addr); /* bytes written */\n}", "path": "n2n.c", "repo_name": "yclee/n2n", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 252}
{"docstring": "/* *********************************************** */\n", "func_signal": "void send_ack(n2n_sock_info_t * sinfo,\n\t      u_int16_t last_rcvd_seq_id,\n\t      struct n2n_packet_header *header,\n\t      struct peer_addr *remote_peer,\n\t      char *src_mac)", "code": "{\n\n  /* marshalling double-checked. */\n  struct n2n_packet_header hdr;\n  u_int8_t pkt[ N2N_PKT_HDR_SIZE ];\n  size_t len = sizeof(hdr);\n  size_t len2;\n  int compress_data = N2N_COMPRESSION_ENABLED;\n\n  fill_standard_header_fields(sinfo, &hdr, src_mac);\n  hdr.msg_type = MSG_TYPE_ACK_RESPONSE;\n  hdr.sequence_id = last_rcvd_seq_id;\n  memcpy(hdr.community_name, header->community_name, COMMUNITY_LEN);\n\n  len2=marshall_n2n_packet_header( pkt, &hdr );\n  assert( len2 == len );\n\n  send_packet(sinfo, (char*)pkt, &len, remote_peer, compress_data);\n}", "path": "n2n.c", "repo_name": "yclee/n2n", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 252}
{"docstring": "/* ************************************** */\n", "func_signal": "int unmarshall_n2n_packet_header( struct n2n_packet_header * hdr, const u_int8_t * buf )", "code": "{\n  size_t offset=0;\n\n  hdr->version = *(buf + offset);\n  ++offset;\n\n  hdr->msg_type = *(buf + offset);\n  ++offset;\n\n  hdr->ttl = *(buf + offset);\n  ++offset;\n\n  hdr->sent_by_supernode = *(buf + offset);\n  ++offset;\n\n  memcpy( hdr->community_name, (buf + offset), COMMUNITY_LEN );\n  offset += COMMUNITY_LEN;\n\n  memcpy( hdr->src_mac, (buf + offset), 6 );\n  offset += 6;\n\n  memcpy( hdr->dst_mac, (buf + offset), 6 );\n  offset += 6;\n\n  unmarshall_peer_addr( &(hdr->public_ip),  &offset, buf );\n  unmarshall_peer_addr( &(hdr->private_ip), &offset, buf );\n\n  hdr->pkt_type = (*(buf + offset) & 0xff); /* Make sure only 8 bits are copied. */\n  ++offset;\n\n  unmarshall_uint32( &(hdr->sequence_id), &offset, buf );\n  unmarshall_uint32( &(hdr->crc),         &offset, buf );\n\n  print_header( \"Unmarshalled \", hdr );\n\n  return offset;\n}", "path": "n2n.c", "repo_name": "yclee/n2n", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 252}
{"docstring": "/** Return the number of elements in the list.\n *\n */\n", "func_signal": "size_t peer_list_size( const struct peer_info * list )", "code": "{\n  size_t retval=0;\n\n  while ( list )\n    {\n      ++retval;\n      list = list->next;\n    }\n\n  return retval;\n}", "path": "n2n.c", "repo_name": "yclee/n2n", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 252}
{"docstring": "/* unreliable_sendto is passed a fully marshalled, packet. Its purpose is to set\n * the unreliable flags but leave the rest of the packet untouched. */\n", "func_signal": "u_int unreliable_sendto(n2n_sock_info_t * sinfo,\n\t\t\tchar *packet, size_t *packet_len,\n\t\t\tconst struct peer_addr *to, u_int8_t compress_data)", "code": "{\n  struct n2n_packet_header hdr_storage;\n  struct n2n_packet_header *hdr = &hdr_storage;\n  macstr_t src_mac_buf;\n  macstr_t dst_mac_buf;\n\n  /* REVISIT: efficiency of unmarshal + re-marshal just to change a couple of bits. */\n  unmarshall_n2n_packet_header( hdr, (u_int8_t *)packet );\n\n  hdr->sequence_id = 0; /* Unreliable messages have 0 as sequence number */\n  hdr->pkt_type    = packet_unreliable_data;\n\n  traceEvent(TRACE_INFO, \"Sent unreliable packet [msg_type=%s][seq_id=%d][src_mac=%s][dst_mac=%s]\",\n\t     msg_type2str(hdr->msg_type), hdr->sequence_id,\n\t     macaddr_str(hdr->src_mac, src_mac_buf, sizeof(src_mac_buf)),\n\t     macaddr_str(hdr->dst_mac, dst_mac_buf, sizeof(dst_mac_buf)));\n\n  marshall_n2n_packet_header( (u_int8_t *)packet, hdr );\n\n  return(send_data(sinfo, packet, packet_len, to, compress_data));\n}", "path": "n2n.c", "repo_name": "yclee/n2n", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 252}
{"docstring": "/* ******************************************************* */\n", "func_signal": "u_int send_data(n2n_sock_info_t * sinfo,\n\t\tchar *packet, size_t *packet_len,\n\t\tconst struct peer_addr *to, u_int8_t compress_data)", "code": "{\n  char compressed[1650];\n  int rc;\n  lzo_uint compressed_len=0;\n  struct sockaddr_in destsock;\n\n  if(*packet_len < N2N_PKT_HDR_SIZE) {\n    traceEvent(TRACE_WARNING, \"The packet about to be sent is too short [len=%d]\\n\", *packet_len);\n    return(-1);\n  }\n\n  memcpy(compressed, packet, N2N_PKT_HDR_SIZE);\n\n  peer_addr2sockaddr_in(to, &destsock);\n\n  if(compress_data) {\n    rc = lzo1x_1_compress((u_char*)&packet[N2N_PKT_HDR_SIZE],\n\t\t\t  *packet_len - N2N_PKT_HDR_SIZE,\n\t\t\t  (u_char*)&compressed[N2N_PKT_HDR_SIZE],\n\t\t\t  &compressed_len, wrkmem);\n\n    if ( 0 == compressed_len )\n    {\n      traceEvent(TRACE_WARNING, \"failed to compress %u bytes.\", (*packet_len - N2N_PKT_HDR_SIZE) );\n      return -1;\n    }\n\n    compressed_len += N2N_PKT_HDR_SIZE;\n\n    traceEvent(TRACE_INFO, \"%u bytes compressed into %u\", *packet_len, compressed_len);\n    /* *packet_len = compressed_len; */\n\n    if(sinfo->is_udp_socket) {\n      rc = sendto(sinfo->sock, compressed, compressed_len, 0,\n\t\t  (struct sockaddr*)&destsock, sizeof(struct sockaddr_in));\n    } else {\n      char send_len[5];\n\n      /* 4 bytes packet length */\n      snprintf(send_len, sizeof(send_len), \"%04d\", (int)compressed_len);\n      if((rc = send(sinfo->sock, send_len, 4, 0)) != 4)\n\treturn(-1);\n      if((rc = send(sinfo->sock, compressed, compressed_len, 0)) != compressed_len) {\n\ttraceEvent(TRACE_WARNING, \"send error [%d][%s]\",\n\t\t   errno, strerror(errno));\n      }\n    }\n  } else {\n    compressed_len = *packet_len;\n    if(sinfo->is_udp_socket)\n      rc = sendto(sinfo->sock, packet, compressed_len, 0,\n\t\t  (struct sockaddr*)&destsock, sizeof(struct sockaddr_in));\n    else {\n      char send_len[5];\n\n      /* 4 bytes packet length */\n      snprintf(send_len, sizeof(send_len), \"%04d\", (int)compressed_len);\n      if((rc = send(sinfo->sock, send_len, 4, 0)) != 4)\n        return(-1);\n      rc = send(sinfo->sock, compressed, compressed_len, 0);\n    }\n\n    if(rc == -1) {\n      ipstr_t ip_buf;\n\n      traceEvent(TRACE_WARNING, \"sendto() failed while attempting to send data to %s:%d\",\n\t\t intoa(ntohl(to->addr_type.v4_addr), ip_buf, sizeof(ip_buf)),\n\t\t ntohs(to->port));\n    }\n  }\n\n  if ( rc >= 0) {\n    traceEvent(TRACE_INFO, \"### Tx N2N Msg -> network\");\n  }\n\n  if(rc == compressed_len)\n    return(*packet_len); /* fake just to avoid warnings */\n  else\n    return(rc);\n}", "path": "n2n.c", "repo_name": "yclee/n2n", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 252}
{"docstring": "/* *********************************************** */\n", "func_signal": "u_int8_t is_multi_broadcast(char *dest_mac)", "code": "{\n  return(((!memcmp(broadcast_addr, dest_mac, 6))\n\t  || (!memcmp(multicast_addr, dest_mac, 3))) ? 1 : 0);\n}", "path": "n2n.c", "repo_name": "yclee/n2n", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 252}
{"docstring": "/** Forward a L2 packet. This may involve a broadcast operation.\n *\n *  Rules are as follows:\n *\n *  1. If the dest MAC is a multicast address, broadcast to all edges in the\n *  community.\n *\n *  2. If the dest MAC is known forward to the destination edge only.\n *     Else broadcast to all edges in the community.\n *\n *  @return number of copies of the packet sent\n */\n", "func_signal": "static size_t forward_packet(char *packet, u_int packet_len, \n                             struct peer_addr *sender,\n                             n2n_sock_info_t * sinfo,\n                             struct n2n_packet_header *hdr )", "code": "{\n    size_t numsent=0;\n    u_int8_t is_dst_broad_multi_cast;\n    struct peer_info *scan;\n\n    ipstr_t buf;\n    ipstr_t buf1;\n\n    hdr->ttl++; /* FIX discard packets with a high TTL */\n    is_dst_broad_multi_cast = is_multi_broadcast(hdr->dst_mac);\n\n    /* Put the original packet sender (public) address */\n    memcpy(&hdr->public_ip, sender, sizeof(struct peer_addr));\n    hdr->sent_by_supernode = 1;\n\n    marshall_n2n_packet_header( (u_int8_t *)packet, hdr );\n\n\n    if ( is_dst_broad_multi_cast )\n    {\n        traceEvent(TRACE_INFO, \"Broadcasting. Multicast address [mac=%s]\",\n                   macaddr_str(hdr->dst_mac, buf, sizeof(buf)));\n\n        numsent = broadcast_packet( packet, packet_len, sender, sinfo, hdr );\n    }\n    else\n    {\n        scan = find_peer_by_mac( known_peers, hdr->dst_mac );\n        if ( scan )\n        {\n            int data_sent_len;\n            size_t len = packet_len;\n          \n            data_sent_len = send_data( &(scan->sinfo), packet, &len, &scan->public_ip, 0);\n\n            if(data_sent_len != len)\n            {\n                ++(supernode_stats.errors);\n                traceEvent(TRACE_WARNING, \"sendto() [sent=%d][attempted_to_send=%d] [%s]\\n\",\n                           data_sent_len, len, strerror(errno));\n            }\n            else {\n                ++(supernode_stats.pkts);\n                traceEvent(TRACE_INFO, \"Sent message to remote node [%s:%hu][mac=%s]\",\n                           intoa(ntohl(scan->public_ip.addr_type.v4_addr), buf, sizeof(buf)),\n                           ntohs(scan->public_ip.port),\n                           macaddr_str(scan->mac_addr, buf1, sizeof(buf1)));\n            }\n\n            numsent = 1;\n        }\n        else\n        {\n            traceEvent(TRACE_INFO, \"Broadcasting because unknown dest [mac=%s]\",\n                       macaddr_str(hdr->dst_mac, buf, sizeof(buf)));\n            numsent = broadcast_packet( packet, packet_len, sender, sinfo, hdr );\n        }\n    }\n\n    return numsent;\n}", "path": "supernode.c", "repo_name": "yclee/n2n", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 252}
{"docstring": "/* ************************************** */\n", "func_signal": "static\nint unmarshall_peer_addr( struct peer_addr * s, size_t * offset,\n\t\t\t  const u_int8_t * buf )", "code": "{\n  memcpy(s, buf + *offset, sizeof(struct peer_addr));\n  *offset += sizeof(struct peer_addr);\n  return (sizeof(struct peer_addr)); /* bytes written */\n}", "path": "n2n.c", "repo_name": "yclee/n2n", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 252}
{"docstring": "/* ************************************** */\n", "func_signal": "int marshall_n2n_packet_header( u_int8_t * buf, const struct n2n_packet_header * hdr )", "code": "{\n  size_t offset = 0;\n\n  print_header( \"Marshalling \", hdr );\n\n  *(buf+offset) = hdr->version;\n  ++offset;\n\n  *(buf+offset) = hdr->msg_type;\n  ++offset;\n\n  *(buf+offset) = hdr->ttl;\n  ++offset;\n\n  *(buf+offset) = hdr->sent_by_supernode;\n  ++offset;\n\n  memcpy( buf+offset, hdr->community_name, COMMUNITY_LEN );\n  offset += COMMUNITY_LEN;\n\n  memcpy( buf+offset, hdr->src_mac, 6 );\n  offset += 6;\n\n  memcpy( buf+offset, hdr->dst_mac, 6 );\n  offset += 6;\n\n  marshall_peer_addr( buf, &offset, &(hdr->public_ip) );\n  marshall_peer_addr( buf, &offset, &(hdr->private_ip) );\n\n  *(buf+offset) = (hdr->pkt_type & 0xff);\n  ++offset;\n\n  marshall_uint32( buf, &offset, hdr->sequence_id );\n  marshall_uint32( buf, &offset, hdr->crc );\n\n  return offset;\n}", "path": "n2n.c", "repo_name": "yclee/n2n", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 252}
{"docstring": "/** Add new to the head of list. If list is NULL; create it.\n *\n *  The item new is added to the head of the list. New is modified during\n *  insertion. list takes ownership of new.\n */\n", "func_signal": "void peer_list_add( struct peer_info * * list,\n                    struct peer_info * new )", "code": "{\n  new->next = *list;\n  new->last_seen = time(NULL);\n  *list = new;\n}", "path": "n2n.c", "repo_name": "yclee/n2n", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 252}
{"docstring": "/* *********************************************** */\n", "func_signal": "static void startTcpReadThread(int sock_fd)", "code": "{\n#ifdef WIN32\n  HANDLE hThread;\n  DWORD dwThreadId;\n\n  hThread = CreateThread(NULL, /* no security attributes */\n\t\t\t 0,    /* use default stack size */\n\t\t\t (LPTHREAD_START_ROUTINE)tcpReadThread, /* thread function */\n\t\t\t (void*)sock_fd, /* argument to thread function */\n\t\t\t 0,              /* use default creation flags */\n\t\t\t &dwThreadId);   /* returns the thread identifier */\n#else\n  int rc;\n  pthread_t threadId;\n\n  rc = pthread_create(&threadId, NULL, tcpReadThread, (void*)sock_fd);\n#endif\n}", "path": "supernode.c", "repo_name": "yclee/n2n", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 252}
{"docstring": "/** Find the peer entry in list with mac_addr equal to mac.\n *\n *  Does not modify the list.\n *\n *  @return NULL if not found; otherwise pointer to peer entry.\n */\n", "func_signal": "struct peer_info * find_peer_by_mac( struct peer_info * list, const char * mac )", "code": "{\n  while(list != NULL)\n    {\n      if( 0 == memcmp(mac, list->mac_addr, 6) )\n        {\n\t  return list;\n        }\n      list = list->next;\n    }\n\n  return NULL;\n}", "path": "n2n.c", "repo_name": "yclee/n2n", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 252}
{"docstring": "/* See the comment in output_title_event_box_expose_event_cb() about this funny label widget */\n", "func_signal": "static gboolean\noutput_title_label_after_expose_event_cb (GtkWidget *widget, GdkEventExpose *event, gpointer data)", "code": "{\n        g_assert (GTK_IS_LABEL (widget));\n        widget->state = GTK_STATE_INSENSITIVE;\n\n        return FALSE;\n}", "path": "plugins\\xrandr\\gsd-xrandr-manager.c", "repo_name": "joeyli/gnome-settings-daemon", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 4520}
{"docstring": "/**\n * egg_virtual_accelerator_label:\n * @accelerator_key:  accelerator keyval\n * @accelerator_mods: accelerator modifier mask\n * @returns:          a newly-allocated accelerator label\n *\n * Converts an accelerator keyval and modifier mask\n * into a (possibly translated) string that can be displayed to\n * a user.\n * For example, if you pass in #GDK_q and #EGG_VIRTUAL_CONTROL_MASK,\n * and you use a German locale, this function returns \"Strg+Q\".\n *\n * The caller of this function must free the returned string.\n */\n", "func_signal": "gchar*\negg_virtual_accelerator_label (guint                  accelerator_key,\n\t\t\t       guint\t\t      keycode,\n\t\t\t       EggVirtualModifierType accelerator_mods)", "code": "{\n  gchar *gtk_label;\n  GdkModifierType gdkmods = 0;\n\n  egg_keymap_resolve_virtual_modifiers (NULL, accelerator_mods, &gdkmods);\n  gtk_label = gtk_accelerator_get_label (accelerator_key, gdkmods);\n\n  if (!accelerator_key)\n    {\n\tgchar *label;\n\tlabel = g_strdup_printf (\"%s0x%02x\", gtk_label, keycode);\n\tg_free (gtk_label);\n\treturn label;\n    }\n\n  return gtk_label;\n}", "path": "plugins\\common\\eggaccelerators.c", "repo_name": "joeyli/gnome-settings-daemon", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 4520}
{"docstring": "/* When new Keyboard is plugged in - reload the settings */\n", "func_signal": "static void\ngsd_keyboard_new_device (XklEngine * engine)", "code": "{\n\tapply_desktop_settings ();\n\tapply_xkb_settings ();\n}", "path": "plugins\\keyboard\\gsd-keyboard-xkb.c", "repo_name": "joeyli/gnome-settings-daemon", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 4520}
{"docstring": "/* Worker thread end */\n", "func_signal": "static void\ntrash_empty_start ()", "code": "{\n        GtkWidget *vbox1, *vbox2, *hbox;\n        GtkWidget *label1, *label3;\n        gchar *markup;\n        GCancellable *cancellable;\n\n        trash_empty_dialog = gtk_dialog_new ();\n        gtk_window_set_default_size (GTK_WINDOW (trash_empty_dialog), 400, -1);\n        gtk_window_set_icon_name (GTK_WINDOW (trash_empty_dialog), \"user-trash\");\n        gtk_window_set_title (GTK_WINDOW (trash_empty_dialog),\n                              _(\"Emptying the trash\"));\n\n        vbox1 = gtk_vbox_new (FALSE, 12);\n        vbox2 = gtk_vbox_new (FALSE, 0);\n        hbox = gtk_hbox_new (FALSE, 0);\n\n        label1 = gtk_label_new (NULL);\n        gtk_label_set_line_wrap (GTK_LABEL (label1), TRUE);\n        gtk_misc_set_alignment (GTK_MISC (label1), 0.0, 0.5);\n\n        label3 = gtk_label_new (NULL);\n        gtk_label_set_line_wrap (GTK_LABEL (label3), TRUE);\n        gtk_misc_set_alignment (GTK_MISC (label3), 0.0, 0.5);\n        gtk_widget_hide (label3);\n\n        location_label = gtk_label_new (NULL);\n        gtk_label_set_line_wrap (GTK_LABEL (location_label), TRUE);\n        gtk_misc_set_alignment (GTK_MISC (location_label), 0.0, 0.5);\n\n        file_label = gtk_label_new (NULL);\n        gtk_label_set_line_wrap (GTK_LABEL (file_label), TRUE);\n        gtk_misc_set_alignment (GTK_MISC (file_label), 0.0, 0.5);\n\n        progressbar = gtk_progress_bar_new ();\n        gtk_progress_bar_set_pulse_step (GTK_PROGRESS_BAR (progressbar), 0.1);\n        gtk_progress_bar_set_text (GTK_PROGRESS_BAR (progressbar), _(\"Preparing to empty trash...\"));\n\n        gtk_box_pack_start (GTK_BOX (GTK_DIALOG (trash_empty_dialog)->vbox), vbox1, TRUE, TRUE, 0);\n        gtk_box_pack_start (GTK_BOX (vbox1), label1, TRUE, TRUE, 0);\n        gtk_box_pack_start (GTK_BOX (hbox), label3, FALSE, TRUE, 0);\n        gtk_box_pack_start (GTK_BOX (hbox), location_label, TRUE, TRUE, 0);\n        gtk_box_pack_start (GTK_BOX (vbox1), hbox, TRUE, TRUE, 0);\n        gtk_box_pack_start (GTK_BOX (vbox2), progressbar, TRUE, TRUE, 0);\n        gtk_box_pack_start (GTK_BOX (vbox2), file_label, TRUE, TRUE, 0);\n        gtk_box_pack_start (GTK_BOX (vbox1), vbox2, TRUE, TRUE, 0);\n\n        gtk_widget_show (label1);\n        gtk_widget_show (vbox1);\n        gtk_widget_show_all (vbox2);\n        gtk_widget_show (hbox);\n        gtk_widget_show (location_label);\n\n        gtk_container_set_border_width (GTK_CONTAINER (GTK_DIALOG (trash_empty_dialog)->vbox), 6);\n        gtk_container_set_border_width (GTK_CONTAINER (vbox1), 6);\n\n        gtk_dialog_add_button (GTK_DIALOG (trash_empty_dialog),\n                               GTK_STOCK_CANCEL,\n                               GTK_RESPONSE_CANCEL);\n\n        markup = g_markup_printf_escaped (\"<big><b>%s</b></big>\", _(\"Emptying the trash\"));\n        gtk_label_set_markup (GTK_LABEL (label1), markup);\n        gtk_label_set_text (GTK_LABEL (label3), _(\"From: \"));\n\n        cancellable = g_cancellable_new ();\n        g_signal_connect_object (trash_empty_dialog, \"response\",\n                                 G_CALLBACK (g_cancellable_cancel),\n                                 cancellable, G_CONNECT_SWAPPED);\n        g_io_scheduler_push_job (trash_empty_job, NULL, NULL, 0, cancellable);\n\n        gtk_widget_show (trash_empty_dialog);\n\n        g_free (markup);\n        g_object_unref (cancellable);\n}", "path": "plugins\\housekeeping\\gsd-ldsm-trash-empty.c", "repo_name": "joeyli/gnome-settings-daemon", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 4520}
{"docstring": "/* DBus method for org.gnome.SettingsDaemon.XRANDR_2 ApplyConfiguration; see gsd-xrandr-manager.xml for the interface definition */\n", "func_signal": "static gboolean\ngsd_xrandr_manager_2_apply_configuration (GsdXrandrManager *manager,\n                                          gint64            parent_window_id,\n                                          gint64            timestamp,\n                                          GError          **error)", "code": "{\n        GdkWindow *parent_window;\n        gboolean result;\n\n        if (parent_window_id != 0)\n                parent_window = gdk_window_foreign_new_for_display (gdk_display_get_default (), (GdkNativeWindow) parent_window_id);\n        else\n                parent_window = NULL;\n\n        result = try_to_apply_intended_configuration (manager, parent_window, (guint32) timestamp, error);\n\n        if (parent_window)\n                g_object_unref (parent_window);\n\n        return result;\n}", "path": "plugins\\xrandr\\gsd-xrandr-manager.c", "repo_name": "joeyli/gnome-settings-daemon", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 4520}
{"docstring": "/* Owen magic */\n", "func_signal": "static GdkFilterReturn\nfilter (GdkXEvent *xevent,\n        GdkEvent  *event,\n        gpointer   data)", "code": "{\n  XEvent *xev = (XEvent *) xevent;\n  guint keyval;\n  gint group;\n\n  GdkScreen *screen = (GdkScreen *)data;\n\n  if (xev->type == KeyPress || xev->type == KeyRelease)\n    {\n      /* get the keysym */\n      group = (xev->xkey.state & KEYBOARD_GROUP_MASK) >> KEYBOARD_GROUP_SHIFT;\n      gdk_keymap_translate_keyboard_state (gdk_keymap_get_default (),\n                                           xev->xkey.keycode,\n                                           xev->xkey.state,\n                                           group,\n                                           &keyval,\n                                           NULL, NULL, NULL);\n      if (keyval == GDK_Control_L || keyval == GDK_Control_R)\n        {\n          if (xev->type == KeyPress)\n            {\n              XAllowEvents (xev->xkey.display,\n                            SyncKeyboard,\n                            xev->xkey.time);\n            }\n          else\n            {\n              XAllowEvents (xev->xkey.display,\n                            AsyncKeyboard,\n                            xev->xkey.time);\n              gsd_locate_pointer (screen);\n            }\n        }\n      else\n        {\n          XAllowEvents (xev->xkey.display,\n                        ReplayKeyboard,\n                        xev->xkey.time);\n          XUngrabKeyboard (gdk_x11_get_default_xdisplay (),\n                           xev->xkey.time);\n        }\n    }\n\n  return GDK_FILTER_CONTINUE;\n}", "path": "plugins\\mouse\\gsd-locate-pointer.c", "repo_name": "joeyli/gnome-settings-daemon", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 4520}
{"docstring": "/* We need to use reference counting for the target data, since we may\n * need to keep the data around after loosing the CLIPBOARD ownership\n * to complete incremental transfers.\n */\n", "func_signal": "static TargetData *\ntarget_data_ref (TargetData *data)", "code": "{\n        data->refcount++;\n        return data;\n}", "path": "plugins\\clipboard\\gsd-clipboard-manager.c", "repo_name": "joeyli/gnome-settings-daemon", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 4520}
{"docstring": "/**\n * gsd_delayed_show_dialog:\n * @dialog: the dialog\n *\n * Shows the dialog as with gtk_widget_show(), unless a window manager\n * hasn't been started yet, in which case it will wait up to 5 seconds\n * for that to happen before showing the dialog.\n **/\n", "func_signal": "void\ngsd_delayed_show_dialog (GtkWidget *dialog)", "code": "{\n        GdkDisplay *display = gtk_widget_get_display (dialog);\n        Display *xdisplay = GDK_DISPLAY_XDISPLAY (display);\n        GdkScreen *screen = gtk_widget_get_screen (dialog);\n        GdkAtom manager_atom;\n        char selection_name[10];\n        Atom selection_atom;\n\n        /* We can't use gdk_selection_owner_get() for this, because\n         * it's an unknown out-of-process window.\n         */\n        snprintf (selection_name, sizeof (selection_name), \"WM_S%d\",\n                  gdk_screen_get_number (screen));\n        selection_atom = XInternAtom (xdisplay, selection_name, True);\n        if (selection_atom &&\n            XGetSelectionOwner (xdisplay, selection_atom) != None) {\n                gtk_widget_show (dialog);\n                return;\n        }\n\n        dialogs = g_slist_prepend (dialogs, dialog);\n\n        manager_atom = gdk_atom_intern (\"MANAGER\", FALSE);\n        gdk_display_add_client_message_filter (display, manager_atom,\n                                               message_filter, NULL);\n\n        g_timeout_add (5000, delayed_show_timeout, NULL);\n}", "path": "plugins\\keyboard\\delayed-dialog.c", "repo_name": "joeyli/gnome-settings-daemon", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 4520}
{"docstring": "/* We use this when the XF86RotateWindows key is pressed.  That key is present\n * on some tablet PCs; they use it so that the user can rotate the tablet\n * easily.\n */\n", "func_signal": "static void\nhandle_rotate_windows (GsdXrandrManager *mgr, guint32 timestamp)", "code": "{\n        GsdXrandrManagerPrivate *priv = mgr->priv;\n        GnomeRRScreen *screen = priv->rw_screen;\n        GnomeRRConfig *current;\n        GError *error;\n        GnomeOutputInfo *rotatable_output_info;\n        int num_allowed_rotations;\n        GnomeRRRotation allowed_rotations;\n        GnomeRRRotation next_rotation;\n\n        g_debug (\"Handling XF86RotateWindows\");\n\n        /* Which output? */\n\n        current = gnome_rr_config_new_current (screen);\n\n        rotatable_output_info = get_laptop_output_info (current);\n        if (rotatable_output_info == NULL) {\n                g_debug (\"No laptop outputs found to rotate; XF86RotateWindows key will do nothing\");\n                goto out;\n        }\n\n        /* Which rotation? */\n\n        get_allowed_rotations_for_output (current, priv->rw_screen, rotatable_output_info, &num_allowed_rotations, &allowed_rotations);\n        next_rotation = get_next_rotation (allowed_rotations, rotatable_output_info->rotation);\n\n        if (next_rotation == rotatable_output_info->rotation) {\n                g_debug (\"No rotations are supported other than the current one; XF86RotateWindows key will do nothing\");\n                goto out;\n        }\n\n        /* Rotate */\n\n        rotatable_output_info->rotation = next_rotation;\n\n        error = NULL;\n        if (!gnome_rr_config_apply_with_time (current, screen, timestamp, &error)) {\n                error_message (mgr, _(\"Could not switch the monitor configuration\"), error, NULL);\n                g_error_free (error);\n        }\n\nout:\n        gnome_rr_config_free (current);\n}", "path": "plugins\\xrandr\\gsd-xrandr-manager.c", "repo_name": "joeyli/gnome-settings-daemon", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 4520}
{"docstring": "/* We want the parent process to quit after initializing all plugins,\n * but we have to do all the work in the child process.  We can't\n * initialize in parent and then fork here: that is not clean with\n * X display and DBUS where we would make the connection from one\n * process and continue using it from the other. So, we just make the\n * parent to fork early and wait. */\n", "func_signal": "static void\ndaemon_start (void)", "code": "{\n        int child_pid;\n        char buf[1];\n\n        if (no_daemon)\n                return;\n\n        gnome_settings_profile_msg (\"forking daemon\");\n\n        signal (SIGPIPE, SIG_IGN);\n        if (-1 == pipe (daemon_pipe_fds)) {\n                g_error (\"Could not create pipe: %s\", g_strerror (errno));\n                exit (EXIT_FAILURE);\n        }\n\n        child_pid = fork ();\n\n        switch (child_pid) {\n        case -1:\n                g_error (\"Could not daemonize: %s\", g_strerror (errno));\n                exit (EXIT_FAILURE);\n\n        case 0:\n                /* child */\n\n                close (daemon_pipe_fds[0]);\n\n                return;\n\n         default:\n                /* parent */\n\n                close (daemon_pipe_fds[1]);\n\n                /* Wait for child to signal that we are good to go. */\n                read (daemon_pipe_fds[0], buf, 1);\n\n                exit (EXIT_SUCCESS);\n        }\n}", "path": "gnome-settings-daemon\\main.c", "repo_name": "joeyli/gnome-settings-daemon", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 4520}
{"docstring": "/* Worker thread begin */\n", "func_signal": "static void\ntrash_empty_maybe_schedule_update (GIOSchedulerJob *job,\n                                   GFile           *file,\n                                   gsize            deleted,\n                                   gboolean         actually_deleting)", "code": "{\n        if (!trash_empty_update_pending) {\n                g_assert (trash_empty_current_file == NULL);\n\n                trash_empty_current_file = g_object_ref (file);\n                trash_empty_deleted_files = deleted;\n                trash_empty_actually_deleting = actually_deleting;\n\n                trash_empty_update_pending = TRUE;\n                g_io_scheduler_job_send_to_mainloop_async (job,\n                                                           trash_empty_update_dialog,\n                                                           NULL, NULL);\n        }\n}", "path": "plugins\\housekeeping\\gsd-ldsm-trash-empty.c", "repo_name": "joeyli/gnome-settings-daemon", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 4520}
{"docstring": "/**\n * get_exec_environment:\n *\n * Description: Modifies the current program environment to\n * ensure that $DISPLAY is set such that a launched application\n * inheriting this environment would appear on screen.\n *\n * Returns: a newly-allocated %NULL-terminated array of strings or\n * %NULL on error. Use g_strfreev() to free it.\n *\n * mainly ripped from egg_screen_exec_display_string in\n * gnome-panel/egg-screen-exec.c\n **/\n", "func_signal": "static char **\nget_exec_environment (XEvent *xevent)", "code": "{\n        char     **retval = NULL;\n        int        i;\n        int        display_index = -1;\n        GdkScreen *screen = NULL;\n        GdkWindow *window = gdk_xid_table_lookup (xevent->xkey.root);\n\n        if (window) {\n                screen = gdk_drawable_get_screen (GDK_DRAWABLE (window));\n        }\n\n        g_return_val_if_fail (GDK_IS_SCREEN (screen), NULL);\n\n        for (i = 0; environ [i]; i++) {\n                if (!strncmp (environ [i], \"DISPLAY\", 7)) {\n                        display_index = i;\n                }\n        }\n\n        if (display_index == -1) {\n                display_index = i++;\n        }\n\n        retval = g_new (char *, i + 1);\n\n        for (i = 0; environ [i]; i++) {\n                if (i == display_index) {\n                        retval [i] = screen_exec_display_string (screen);\n                } else {\n                        retval [i] = g_strdup (environ [i]);\n                }\n        }\n\n        retval [i] = NULL;\n\n        return retval;\n}", "path": "plugins\\keybindings\\gsd-keybindings-manager.c", "repo_name": "joeyli/gnome-settings-daemon", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 4520}
{"docstring": "/* Optionally filters out GNOME_RR_ERROR_NO_MATCHING_CONFIG from\n * gnome_rr_config_apply_from_filename_with_time(), since that is not usually an error.\n */\n", "func_signal": "static gboolean\napply_configuration_from_filename (GsdXrandrManager *manager,\n                                   const char       *filename,\n                                   gboolean          no_matching_config_is_an_error,\n                                   guint32           timestamp,\n                                   GError          **error)", "code": "{\n        struct GsdXrandrManagerPrivate *priv = manager->priv;\n        GError *my_error;\n        gboolean success;\n        char *str;\n\n        str = g_strdup_printf (\"Applying %s with timestamp %d\", filename, timestamp);\n        show_timestamps_dialog (manager, str);\n        g_free (str);\n\n        my_error = NULL;\n        success = gnome_rr_config_apply_from_filename_with_time (priv->rw_screen, filename, timestamp, &my_error);\n        if (success)\n                return TRUE;\n\n        if (g_error_matches (my_error, GNOME_RR_ERROR, GNOME_RR_ERROR_NO_MATCHING_CONFIG)) {\n                if (no_matching_config_is_an_error)\n                        goto fail;\n\n                /* This is not an error; the user probably changed his monitors\n                 * and so they don't match any of the stored configurations.\n                 */\n                g_error_free (my_error);\n                return TRUE;\n        }\n\nfail:\n        g_propagate_error (error, my_error);\n        return FALSE;\n}", "path": "plugins\\xrandr\\gsd-xrandr-manager.c", "repo_name": "joeyli/gnome-settings-daemon", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 4520}
{"docstring": "/* HAVE_FONTCONFIG */\n", "func_signal": "static const char *\ntype_to_string (GConfValueType type)", "code": "{\n        switch (type) {\n        case GCONF_VALUE_INT:\n                return \"int\";\n        case GCONF_VALUE_STRING:\n                return \"string\";\n        case GCONF_VALUE_FLOAT:\n                return \"float\";\n        case GCONF_VALUE_BOOL:\n                return \"bool\";\n        case GCONF_VALUE_SCHEMA:\n                return \"schema\";\n        case GCONF_VALUE_LIST:\n                return \"list\";\n        case GCONF_VALUE_PAIR:\n                return \"pair\";\n        case GCONF_VALUE_INVALID:\n                return \"*invalid*\";\n        default:\n                g_assert_not_reached();\n                return NULL; /* for warnings */\n        }\n}", "path": "plugins\\xsettings\\gsd-xsettings-manager.c", "repo_name": "joeyli/gnome-settings-daemon", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 4520}
{"docstring": "/**\n * get_server_time:\n * @display: display from which to get the time\n * @window: a #Window, used for communication with the server.\n *          The window must have PropertyChangeMask in its\n *          events mask or a hang will result.\n * \n * Routine to get the current X server time stamp. \n * \n * Return value: the time stamp.\n **/\n", "func_signal": "static Time\nget_server_time (Display *display,\n\t\t Window   window)", "code": "{\n  unsigned char c = 'a';\n  XEvent xevent;\n  TimeStampInfo info;\n\n  info.timestamp_prop_atom = XInternAtom  (display, \"_TIMESTAMP_PROP\", False);\n  info.window = window;\n\n  XChangeProperty (display, window,\n\t\t   info.timestamp_prop_atom, info.timestamp_prop_atom,\n\t\t   8, PropModeReplace, &c, 1);\n\n  XIfEvent (display, &xevent,\n\t    timestamp_predicate, (XPointer)&info);\n\n  return xevent.xproperty.time;\n}", "path": "plugins\\xsettings\\xsettings-manager.c", "repo_name": "joeyli/gnome-settings-daemon", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 4520}
{"docstring": "/*\n * Register a new media player. Most applications will want to call\n * this with time = GDK_CURRENT_TIME. This way, the last registered\n * player will receive media events. In some cases, applications\n * may want to register with a lower priority (usually 1), to grab\n * events only nobody is interested.\n */\n", "func_signal": "gboolean\ngsd_media_keys_manager_grab_media_player_keys (GsdMediaKeysManager *manager,\n                                               const char          *application,\n                                               guint32              time,\n                                               GError             **error)", "code": "{\n        GList       *iter;\n        MediaPlayer *media_player;\n\n        if (time == GDK_CURRENT_TIME) {\n                GTimeVal tv;\n\n                g_get_current_time (&tv);\n                time = tv.tv_sec * 1000 + tv.tv_usec / 1000;\n        }\n\n        iter = g_list_find_custom (manager->priv->media_players,\n                                   application,\n                                   find_by_application);\n\n        if (iter != NULL) {\n                if (((MediaPlayer *)iter->data)->time < time) {\n                        g_free (((MediaPlayer *)iter->data)->application);\n                        g_free (iter->data);\n                        manager->priv->media_players = g_list_delete_link (manager->priv->media_players, iter);\n                } else {\n                        return TRUE;\n                }\n        }\n\n        g_debug (\"Registering %s at %u\", application, time);\n        media_player = g_new0 (MediaPlayer, 1);\n        media_player->application = g_strdup (application);\n        media_player->time = time;\n\n        manager->priv->media_players = g_list_insert_sorted (manager->priv->media_players,\n                                                             media_player,\n                                                             find_by_time);\n\n        return TRUE;\n}", "path": "plugins\\media-keys\\gsd-media-keys-manager.c", "repo_name": "joeyli/gnome-settings-daemon", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 4520}
{"docstring": "/* We mirror the Xft properties both through XSETTINGS and through\n * X resources\n */\n", "func_signal": "static void\nupdate_xft_settings (GnomeXSettingsManager *manager,\n                     GConfClient           *client)", "code": "{\n        GnomeXftSettings settings;\n\n        gnome_settings_profile_start (NULL);\n\n        xft_settings_get (client, &settings);\n        xft_settings_set_xsettings (manager, &settings);\n        xft_settings_set_xresources (&settings);\n\n        gnome_settings_profile_end (NULL);\n}", "path": "plugins\\xsettings\\gsd-xsettings-manager.c", "repo_name": "joeyli/gnome-settings-daemon", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 4520}
{"docstring": "/**\n * gnome_settings_delayed_show_dialog:\n * @dialog: the dialog\n *\n * Shows the dialog as with gtk_widget_show(), unless a window manager\n * hasn't been started yet, in which case it will wait up to 5 seconds\n * for that to happen before showing the dialog.\n **/\n", "func_signal": "void\ngnome_settings_delayed_show_dialog (GtkWidget *dialog)", "code": "{\n        GdkDisplay *display = gtk_widget_get_display (dialog);\n        Display *xdisplay = GDK_DISPLAY_XDISPLAY (display);\n        GdkScreen *screen = gtk_widget_get_screen (dialog);\n        GdkAtom manager_atom;\n        char selection_name[10];\n        Atom selection_atom;\n\n        /* We can't use gdk_selection_owner_get() for this, because\n         * it's an unknown out-of-process window.\n         */\n        snprintf (selection_name, sizeof (selection_name), \"WM_S%d\",\n                  gdk_screen_get_number (screen));\n        selection_atom = XInternAtom (xdisplay, selection_name, True);\n        if (selection_atom &&\n            XGetSelectionOwner (xdisplay, selection_atom) != None) {\n                gtk_widget_show (dialog);\n                return;\n        }\n\n        dialogs = g_slist_prepend (dialogs, dialog);\n\n        manager_atom = gdk_atom_intern (\"MANAGER\", FALSE);\n        gdk_display_add_client_message_filter (display, manager_atom,\n                                               message_filter, NULL);\n\n        g_timeout_add (5000, delayed_show_timeout, NULL);\n}", "path": "plugins\\font\\delayed-dialog.c", "repo_name": "joeyli/gnome-settings-daemon", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 4520}
{"docstring": "/**\n * Scroll methods are: 0 - disabled, 1 - edge scrolling, 2 - twofinger\n * scrolling\n */\n", "func_signal": "static int\nset_edge_scroll (int method)", "code": "{\n        int numdevices, i, rc;\n        XDeviceInfo *devicelist = XListInputDevices (GDK_DISPLAY (), &numdevices);\n        XDevice *device;\n        Atom act_type, prop_edge, prop_twofinger;\n        int act_format;\n        unsigned long nitems, bytes_after;\n        unsigned char *data;\n\n        if (devicelist == NULL)\n                return 0;\n\n        prop_edge = XInternAtom (GDK_DISPLAY (), \"Synaptics Edge Scrolling\", False);\n        prop_twofinger = XInternAtom (GDK_DISPLAY (), \"Synaptics Two-Finger Scrolling\", False);\n\n        if (!prop_edge || !prop_twofinger)\n                return 0;\n\n        for (i = 0; i < numdevices; i++) {\n                if ((device = device_is_touchpad (devicelist[i]))) {\n                        gdk_error_trap_push ();\n                        rc = XGetDeviceProperty (GDK_DISPLAY (), device,\n                                                prop_edge, 0, 1, False,\n                                                XA_INTEGER, &act_type, &act_format, &nitems,\n                                                &bytes_after, &data);\n                        if (rc == Success && act_type == XA_INTEGER &&\n                                act_format == 8 && nitems >= 2) {\n                                data[0] = (method == 1) ? 1 : 0;\n                                XChangeDeviceProperty (GDK_DISPLAY (), device,\n                                                        prop_edge, XA_INTEGER, 8,\n                                                        PropModeReplace, data, nitems);\n                        }\n\n                        XFree (data);\n\n                        rc = XGetDeviceProperty (GDK_DISPLAY (), device,\n                                                prop_twofinger, 0, 1, False,\n                                                XA_INTEGER, &act_type, &act_format, &nitems,\n                                                &bytes_after, &data);\n                        if (rc == Success && act_type == XA_INTEGER &&\n                                act_format == 8 && nitems >= 2) {\n                                data[0] = (method == 2) ? 1 : 0;\n                                XChangeDeviceProperty (GDK_DISPLAY (), device,\n                                                        prop_twofinger, XA_INTEGER, 8,\n                                                        PropModeReplace, data, nitems);\n                        }\n\n                        XFree (data);\n                        XCloseDevice (GDK_DISPLAY (), device);\n                        if (gdk_error_trap_pop ()) {\n                                g_warning (\"Error in setting edge scroll on \\\"%s\\\"\", devicelist[i].name);\n                                continue;\n                        }\n                }\n        }\n\n        XFreeDeviceList (devicelist);\n        return 0;\n}", "path": "plugins\\mouse\\gsd-mouse-manager.c", "repo_name": "joeyli/gnome-settings-daemon", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 4520}
{"docstring": "/* This is an expose-event hander for the title label for each GnomeRROutput.\n * We want each title to have a colored background, so we paint that background, then\n * return FALSE to let GtkLabel expose itself (i.e. paint the label's text), and then\n * we have a signal_connect_after handler as well.  See the comments below\n * to see why that \"after\" handler is needed.\n */\n", "func_signal": "static gboolean\noutput_title_label_expose_event_cb (GtkWidget *widget, GdkEventExpose *event, gpointer data)", "code": "{\n        GsdXrandrManager *manager = GSD_XRANDR_MANAGER (data);\n        struct GsdXrandrManagerPrivate *priv = manager->priv;\n        GnomeOutputInfo *output;\n        GdkColor color;\n        cairo_t *cr;\n\n        g_assert (GTK_IS_LABEL (widget));\n\n        output = g_object_get_data (G_OBJECT (widget), \"output\");\n        g_assert (output != NULL);\n\n        g_assert (priv->labeler != NULL);\n\n        /* Draw a black rectangular border, filled with the color that corresponds to this output */\n\n        gnome_rr_labeler_get_color_for_output (priv->labeler, output, &color);\n\n        cr = gdk_cairo_create (widget->window);\n\n        cairo_set_source_rgb (cr, 0, 0, 0);\n        cairo_set_line_width (cr, OUTPUT_TITLE_ITEM_BORDER);\n        cairo_rectangle (cr,\n                         widget->allocation.x + OUTPUT_TITLE_ITEM_BORDER / 2.0,\n                         widget->allocation.y + OUTPUT_TITLE_ITEM_BORDER / 2.0,\n                         widget->allocation.width - OUTPUT_TITLE_ITEM_BORDER,\n                         widget->allocation.height - OUTPUT_TITLE_ITEM_BORDER);\n        cairo_stroke (cr);\n\n        gdk_cairo_set_source_color (cr, &color);\n        cairo_rectangle (cr,\n                         widget->allocation.x + OUTPUT_TITLE_ITEM_BORDER,\n                         widget->allocation.y + OUTPUT_TITLE_ITEM_BORDER,\n                         widget->allocation.width - 2 * OUTPUT_TITLE_ITEM_BORDER,\n                         widget->allocation.height - 2 * OUTPUT_TITLE_ITEM_BORDER);\n\n        cairo_fill (cr);\n\n        /* We want the label to always show up as if it were sensitive\n         * (\"style->fg[GTK_STATE_NORMAL]\"), even though the label is insensitive\n         * due to being inside an insensitive menu item.  So, here we have a\n         * HACK in which we frob the label's state directly.  GtkLabel's expose\n         * handler will be run after this function, so it will think that the\n         * label is in GTK_STATE_NORMAL.  We reset the label's state back to\n         * insensitive in output_title_label_after_expose_event_cb().\n         *\n         * Yay for fucking with GTK+'s internals.\n         */\n\n        widget->state = GTK_STATE_NORMAL;\n\n        return FALSE;\n}", "path": "plugins\\xrandr\\gsd-xrandr-manager.c", "repo_name": "joeyli/gnome-settings-daemon", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 4520}
{"docstring": "/* Set date of member MEMNAME in archive ARNAME to current time.\n   Returns 0 if successful,\n   -1 if file ARNAME does not exist,\n   -2 if not a valid archive,\n   -3 if other random system call error (including file read-only),\n   1 if valid but member MEMNAME does not exist.  */\n", "func_signal": "int\nar_member_touch (const char *arname, const char *memname)", "code": "{\n  long int pos = ar_scan (arname, ar_member_pos, memname);\n  int fd;\n  struct ar_hdr ar_hdr;\n  int i;\n  unsigned int ui;\n  struct stat statbuf;\n\n  if (pos < 0)\n    return (int) pos;\n  if (!pos)\n    return 1;\n\n  fd = open (arname, O_RDWR, 0666);\n  if (fd < 0)\n    return -3;\n  /* Read in this member's header */\n  if (lseek (fd, pos, 0) < 0)\n    goto lose;\n  if (AR_HDR_SIZE != read (fd, &ar_hdr, AR_HDR_SIZE))\n    goto lose;\n  /* Write back the header, thus touching the archive file.  */\n  if (lseek (fd, pos, 0) < 0)\n    goto lose;\n  if (AR_HDR_SIZE != write (fd, &ar_hdr, AR_HDR_SIZE))\n    goto lose;\n  /* The file's mtime is the time we we want.  */\n  EINTRLOOP (i, fstat (fd, &statbuf));\n  if (i < 0)\n    goto lose;\n#if defined(ARFMAG) || defined(ARFZMAG) || defined(AIAMAG) || defined(WINDOWS32)\n  /* Advance member's time to that time */\n  for (ui = 0; ui < sizeof ar_hdr.ar_date; ui++)\n    ar_hdr.ar_date[ui] = ' ';\n  sprintf (ar_hdr.ar_date, \"%ld\", (long int) statbuf.st_mtime);\n#ifdef AIAMAG\n  ar_hdr.ar_date[strlen(ar_hdr.ar_date)] = ' ';\n#endif\n#else\n  ar_hdr.ar_date = statbuf.st_mtime;\n#endif\n  /* Write back this member's header */\n  if (lseek (fd, pos, 0) < 0)\n    goto lose;\n  if (AR_HDR_SIZE != write (fd, &ar_hdr, AR_HDR_SIZE))\n    goto lose;\n  close (fd);\n  return 0;\n\n lose:\n  i = errno;\n  close (fd);\n  errno = i;\n  return -3;\n}", "path": "arscan.c", "repo_name": "mseaborn/gnu-make", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 1136}
{"docstring": "/* Search the given VPATH list for a directory where the name pointed to by\n   FILE exists.  If it is found, we return a cached name of the existing file\n   and set *MTIME_PTR (if MTIME_PTR is not NULL) to its modtime (or zero if no\n   stat call was done).  Otherwise we return NULL.  */\n", "func_signal": "static const char *\nselective_vpath_search (struct vpath *path, const char *file,\n                        FILE_TIMESTAMP *mtime_ptr)", "code": "{\n  int not_target;\n  char *name;\n  const char *n;\n  const char *filename;\n  const char **vpath = path->searchpath;\n  unsigned int maxvpath = path->maxlen;\n  unsigned int i;\n  unsigned int flen, vlen, name_dplen;\n  int exists = 0;\n\n  /* Find out if *FILE is a target.\n     If and only if it is NOT a target, we will accept prospective\n     files that don't exist but are mentioned in a makefile.  */\n  {\n    struct file *f = lookup_file (file);\n    not_target = f == 0 || !f->is_target;\n  }\n\n  flen = strlen (file);\n\n  /* Split *FILE into a directory prefix and a name-within-directory.\n     NAME_DPLEN gets the length of the prefix; FILENAME gets the pointer to\n     the name-within-directory and FLEN is its length.  */\n\n  n = strrchr (file, '/');\n#ifdef HAVE_DOS_PATHS\n  /* We need the rightmost slash or backslash.  */\n  {\n    const char *bslash = strrchr(file, '\\\\');\n    if (!n || bslash > n)\n      n = bslash;\n  }\n#endif\n  name_dplen = n != 0 ? n - file : 0;\n  filename = name_dplen > 0 ? n + 1 : file;\n  if (name_dplen > 0)\n    flen -= name_dplen + 1;\n\n  /* Get enough space for the biggest VPATH entry, a slash, the directory\n     prefix that came with FILE, another slash (although this one may not\n     always be necessary), the filename, and a null terminator.  */\n  name = alloca (maxvpath + 1 + name_dplen + 1 + flen + 1);\n\n  /* Try each VPATH entry.  */\n  for (i = 0; vpath[i] != 0; ++i)\n    {\n      int exists_in_cache = 0;\n      char *p;\n\n      p = name;\n\n      /* Put the next VPATH entry into NAME at P and increment P past it.  */\n      vlen = strlen (vpath[i]);\n      memcpy (p, vpath[i], vlen);\n      p += vlen;\n\n      /* Add the directory prefix already in *FILE.  */\n      if (name_dplen > 0)\n\t{\n#ifndef VMS\n\t  *p++ = '/';\n#endif\n\t  memcpy (p, file, name_dplen);\n\t  p += name_dplen;\n\t}\n\n#ifdef HAVE_DOS_PATHS\n      /* Cause the next if to treat backslash and slash alike.  */\n      if (p != name && p[-1] == '\\\\' )\n\tp[-1] = '/';\n#endif\n      /* Now add the name-within-directory at the end of NAME.  */\n#ifndef VMS\n      if (p != name && p[-1] != '/')\n\t{\n\t  *p = '/';\n\t  memcpy (p + 1, filename, flen + 1);\n\t}\n      else\n#endif\n\tmemcpy (p, filename, flen + 1);\n\n      /* Check if the file is mentioned in a makefile.  If *FILE is not\n\t a target, that is enough for us to decide this file exists.\n\t If *FILE is a target, then the file must be mentioned in the\n\t makefile also as a target to be chosen.\n\n\t The restriction that *FILE must not be a target for a\n\t makefile-mentioned file to be chosen was added by an\n\t inadequately commented change in July 1990; I am not sure off\n\t hand what problem it fixes.\n\n\t In December 1993 I loosened this restriction to allow a file\n\t to be chosen if it is mentioned as a target in a makefile.  This\n\t seem logical.\n\n         Special handling for -W / -o: make sure we preserve the special\n         values here.  Actually this whole thing is a little bogus: I think\n         we should ditch the name/hname thing and look into the renamed\n         capability that already exists for files: that is, have a new struct\n         file* entry for the VPATH-found file, and set the renamed field if\n         we use it.\n      */\n      {\n\tstruct file *f = lookup_file (name);\n\tif (f != 0)\n          {\n            exists = not_target || f->is_target;\n            if (exists && mtime_ptr\n                && (f->last_mtime == OLD_MTIME || f->last_mtime == NEW_MTIME))\n              {\n                *mtime_ptr = f->last_mtime;\n                mtime_ptr = 0;\n              }\n          }\n      }\n\n      if (!exists)\n\t{\n\t  /* That file wasn't mentioned in the makefile.\n\t     See if it actually exists.  */\n\n#ifdef VMS\n\t  exists_in_cache = exists = dir_file_exists_p (vpath[i], filename);\n#else\n\t  /* Clobber a null into the name at the last slash.\n\t     Now NAME is the name of the directory to look in.  */\n\t  *p = '\\0';\n\n\t  /* We know the directory is in the hash table now because either\n\t     construct_vpath_list or the code just above put it there.\n\t     Does the file we seek exist in it?  */\n\t  exists_in_cache = exists = dir_file_exists_p (name, filename);\n#endif\n\t}\n\n      if (exists)\n\t{\n\t  /* The file is in the directory cache.\n\t     Now check that it actually exists in the filesystem.\n\t     The cache may be out of date.  When vpath thinks a file\n\t     exists, but stat fails for it, confusion results in the\n\t     higher levels.  */\n\n\t  struct stat st;\n\n#ifndef VMS\n\t  /* Put the slash back in NAME.  */\n\t  *p = '/';\n#endif\n\n\t  if (exists_in_cache)\t/* Makefile-mentioned file need not exist.  */\n\t    {\n              int e;\n\n              EINTRLOOP (e, stat (name, &st)); /* Does it really exist?  */\n              if (e != 0)\n                {\n                  exists = 0;\n                  continue;\n                }\n\n              /* Store the modtime into *MTIME_PTR for the caller.  */\n              if (mtime_ptr != 0)\n                {\n                  *mtime_ptr = FILE_TIMESTAMP_STAT_MODTIME (name, st);\n                  mtime_ptr = 0;\n                }\n            }\n\n          /* We have found a file.\n             If we get here and mtime_ptr hasn't been set, record\n             UNKNOWN_MTIME to indicate this.  */\n          if (mtime_ptr != 0)\n            *mtime_ptr = UNKNOWN_MTIME;\n\n          /* Store the name we found and return it.  */\n\n          return strcache_add_len (name, (p + 1 - name) + flen);\n\t}\n    }\n\n  return 0;\n}", "path": "vpath.c", "repo_name": "mseaborn/gnu-make", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 1136}
{"docstring": "/*\n  copy 'from' to 'to' up to but not including 'upto'\n  return 0 if eos on from\n  return 1 if upto found\n\n  return 'to' at last char + 1\n  return 'from' at match + 1 or eos if no match\n\n  if as_dir == 1, change all '.' to '_'\n  else change all '.' but the last to '_'\n*/\n", "func_signal": "static int\ncopyto (char **to, const char **from, char upto, int as_dir)", "code": "{\n  const char *s;\n\n  s = strrchr (*from, '.');\n\n  while (**from)\n    {\n      if (**from == upto)\n\t{\n\t  do\n\t    {\n\t      (*from)++;\n\t    }\n\t  while (**from == upto);\n\t  return 1;\n\t}\n      if (**from == '.')\n\t{\n\t  if ((as_dir == 1)\n\t      || (*from != s))\n\t    **to = '_';\n\t  else\n\t    **to = '.';\n\t}\n      else\n\t{\n#ifdef HAVE_CASE_INSENSITIVE_FS\n\t  if (isupper ((unsigned char)**from))\n\t    **to = tolower ((unsigned char)**from);\n\t  else\n#endif\n\t    **to = **from;\n\t}\n      (*to)++;\n      (*from)++;\n    }\n\n  return 0;\n}", "path": "vmsify.c", "repo_name": "mseaborn/gnu-make", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 1136}
{"docstring": "/* Glob for MEMBER_PATTERN in archive ARNAME.\n   Return a malloc'd chain of matching elements (or nil if none).  */\n", "func_signal": "struct nameseq *\nar_glob (const char *arname, const char *member_pattern, unsigned int size)", "code": "{\n  struct ar_glob_state state;\n  struct nameseq *n;\n  const char **names;\n  char *name;\n  unsigned int i;\n\n  if (! glob_pattern_p (member_pattern, 1))\n    return 0;\n\n  /* Scan the archive for matches.\n     ar_glob_match will accumulate them in STATE.chain.  */\n  i = strlen (arname);\n  name = alloca (i + 2);\n  memcpy (name, arname, i);\n  name[i] = '(';\n  name[i + 1] = '\\0';\n  state.arname = name;\n  state.pattern = member_pattern;\n  state.size = size;\n  state.chain = 0;\n  state.n = 0;\n  ar_scan (arname, ar_glob_match, &state);\n\n  if (state.chain == 0)\n    return 0;\n\n  /* Now put the names into a vector for sorting.  */\n  names = alloca (state.n * sizeof (const char *));\n  i = 0;\n  for (n = state.chain; n != 0; n = n->next)\n    names[i++] = n->name;\n\n  /* Sort them alphabetically.  */\n  qsort (names, i, sizeof (*names), alpha_compare);\n\n  /* Put them back into the chain in the sorted order.  */\n  i = 0;\n  for (n = state.chain; n != 0; n = n->next)\n    n->name = names[i++];\n\n  return state.chain;\n}", "path": "ar.c", "repo_name": "mseaborn/gnu-make", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 1136}
{"docstring": "/* Return the modtime of NAME.  */\n", "func_signal": "time_t\nar_member_date (const char *name)", "code": "{\n  char *arname;\n  char *memname;\n  long int val;\n\n  ar_parse_name (name, &arname, &memname);\n\n  /* Make sure we know the modtime of the archive itself because we are\n     likely to be called just before commands to remake a member are run,\n     and they will change the archive itself.\n\n     But we must be careful not to enter_file the archive itself if it does\n     not exist, because pattern_search assumes that files found in the data\n     base exist or can be made.  */\n  {\n    struct file *arfile;\n    arfile = lookup_file (arname);\n    if (arfile == 0 && file_exists_p (arname))\n      arfile = enter_file (strcache_add (arname));\n\n    if (arfile != 0)\n      (void) f_mtime (arfile, 0);\n  }\n\n  val = ar_scan (arname, ar_member_date_1, memname);\n\n  free (arname);\n\n  return (val <= 0 ? (time_t) -1 : (time_t) val);\n}", "path": "ar.c", "repo_name": "mseaborn/gnu-make", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 1136}
{"docstring": "/* Search the GPATH list for a pathname string that matches the one passed\n   in.  If it is found, return 1.  Otherwise we return 0.  */\n", "func_signal": "int\ngpath_search (const char *file, unsigned int len)", "code": "{\n  const char **gp;\n\n  if (gpaths && (len <= gpaths->maxlen))\n    for (gp = gpaths->searchpath; *gp != NULL; ++gp)\n      if (strneq (*gp, file, len) && (*gp)[len] == '\\0')\n        return 1;\n\n  return 0;\n}", "path": "vpath.c", "repo_name": "mseaborn/gnu-make", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 1136}
{"docstring": "/* Parse the archive-member reference NAME into the archive and member names.\n   Creates one allocated string containing both names, pointed to by ARNAME_P.\n   MEMNAME_P points to the member.  */\n", "func_signal": "void\nar_parse_name (const char *name, char **arname_p, char **memname_p)", "code": "{\n  char *p;\n\n  *arname_p = xstrdup (name);\n  p = strchr (*arname_p, '(');\n  *(p++) = '\\0';\n  p[strlen(p) - 1] = '\\0';\n  *memname_p = p;\n}", "path": "ar.c", "repo_name": "mseaborn/gnu-make", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 1136}
{"docstring": "/* Search the VPATH list whose pattern matches FILE for a directory where FILE\n   exists.  If it is found, return the cached name of an existing file, and\n   set *MTIME_PTR (if MTIME_PTR is not NULL) to its modtime (or zero if no\n   stat call was done).  Otherwise we return 0.  */\n", "func_signal": "const char *\nvpath_search (const char *file, FILE_TIMESTAMP *mtime_ptr)", "code": "{\n  struct vpath *v;\n\n  /* If there are no VPATH entries or FILENAME starts at the root,\n     there is nothing we can do.  */\n\n  if (file[0] == '/'\n#ifdef HAVE_DOS_PATHS\n      || file[0] == '\\\\' || file[1] == ':'\n#endif\n      || (vpaths == 0 && general_vpath == 0))\n    return 0;\n\n  for (v = vpaths; v != 0; v = v->next)\n    if (pattern_matches (v->pattern, v->percent, file))\n      {\n        const char *p = selective_vpath_search (v, file, mtime_ptr);\n        if (p)\n          return p;\n      }\n\n  if (general_vpath != 0)\n    {\n      const char *p = selective_vpath_search (general_vpath, file, mtime_ptr);\n      if (p)\n        return p;\n    }\n\n  return 0;\n}", "path": "vpath.c", "repo_name": "mseaborn/gnu-make", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 1136}
{"docstring": "/* Takes three arguments ARCHIVE, FUNCTION and ARG.\n\n   Open the archive named ARCHIVE, find its members one by one,\n   and for each one call FUNCTION with the following arguments:\n     archive file descriptor for reading the data,\n     member name,\n     member name might be truncated flag,\n     member header position in file,\n     member data position in file,\n     member data size,\n     member date,\n     member uid,\n     member gid,\n     member protection mode,\n     ARG.\n\n   NOTE: on VMS systems, only name, date, and arg are meaningful!\n\n   The descriptor is poised to read the data of the member\n   when FUNCTION is called.  It does not matter how much\n   data FUNCTION reads.\n\n   If FUNCTION returns nonzero, we immediately return\n   what FUNCTION returned.\n\n   Returns -1 if archive does not exist,\n   Returns -2 if archive has invalid format.\n   Returns 0 if have scanned successfully.  */\n", "func_signal": "long int\nar_scan (const char *archive, ar_member_func_t function, const void *arg)", "code": "{\n  char *p;\n\n  static struct dsc$descriptor_s libdesc =\n    { 0, DSC$K_DTYPE_T, DSC$K_CLASS_S, NULL };\n\n  unsigned long func = LBR$C_READ;\n  unsigned long type = LBR$C_TYP_UNK;\n  unsigned long index = 1;\n\n  int status;\n\n  status = lbr$ini_control (&VMS_lib_idx, &func, &type, 0);\n\n  if (! (status & 1))\n    {\n      error (NILF, _(\"lbr$ini_control failed with status = %d\"),status);\n      return -2;\n    }\n\n  libdesc.dsc$a_pointer = archive;\n  libdesc.dsc$w_length = strlen (archive);\n\n  status = lbr$open (&VMS_lib_idx, &libdesc, 0, 0, 0, 0, 0);\n\n  if (! (status & 1))\n    {\n      error (NILF, _(\"unable to open library `%s' to lookup member `%s'\"),\n\t     archive, (char *)arg);\n      return -1;\n    }\n\n  VMS_saved_memname = (char *)arg;\n\n  /* For comparison, delete .obj from arg name.  */\n\n  p = strrchr (VMS_saved_memname, '.');\n  if (p)\n    *p = '\\0';\n\n  VMS_function = function;\n\n  VMS_member_date = (time_t) -1;\n  lbr$get_index (&VMS_lib_idx, &index, VMS_get_member_info, 0);\n\n  /* Undo the damage.  */\n  if (p)\n    *p = '.';\n\n  lbr$close (&VMS_lib_idx);\n\n  return VMS_member_date > 0 ? VMS_member_date : 0;\n}", "path": "arscan.c", "repo_name": "mseaborn/gnu-make", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 1136}
{"docstring": "/* Return nonzero if PATTERN contains any metacharacters.\n   Metacharacters can be quoted with backslashes if QUOTE is nonzero.  */\n", "func_signal": "static int\nglob_pattern_p (const char *pattern, int quote)", "code": "{\n  const char *p;\n  int open = 0;\n\n  for (p = pattern; *p != '\\0'; ++p)\n    switch (*p)\n      {\n      case '?':\n      case '*':\n\treturn 1;\n\n      case '\\\\':\n\tif (quote)\n\t  ++p;\n\tbreak;\n\n      case '[':\n\topen = 1;\n\tbreak;\n\n      case ']':\n\tif (open)\n\t  return 1;\n\tbreak;\n      }\n\n  return 0;\n}", "path": "ar.c", "repo_name": "mseaborn/gnu-make", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 1136}
{"docstring": "/* HAVE_DECL_SYS_SIGLIST */\n", "func_signal": "char *\nstrsignal (int signal)", "code": "{\n  static char buf[] = \"Signal 12345678901234567890\";\n\n#if ! HAVE_DECL_SYS_SIGLIST\n# if HAVE_DECL__SYS_SIGLIST\n#  define sys_siglist _sys_siglist\n# elif HAVE_DECL___SYS_SIGLIST\n#  define sys_siglist __sys_siglist\n# else\n  static char sig_initted = 0;\n\n  if (!sig_initted)\n    sig_initted = signame_init ();\n# endif\n#endif\n\n  if (signal > 0 || signal < NSIG)\n    return (char *) sys_siglist[signal];\n\n  sprintf (buf, \"Signal %d\", signal);\n  return buf;\n}", "path": "signame.c", "repo_name": "mseaborn/gnu-make", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 1136}
{"docstring": "/* Return nonzero iff NAME matches MEM.\n   If TRUNCATED is nonzero, MEM may be truncated to\n   sizeof (struct ar_hdr.ar_name) - 1.  */\n", "func_signal": "int\nar_name_equal (const char *name, const char *mem, int truncated)", "code": "{\n  const char *p;\n\n  p = strrchr (name, '/');\n  if (p != 0)\n    name = p + 1;\n\n#ifndef VMS\n  if (truncated)\n    {\n#ifdef AIAMAG\n      /* TRUNCATED should never be set on this system.  */\n      abort ();\n#else\n      struct ar_hdr hdr;\n#if !defined (__hpux) && !defined (cray)\n      return strneq (name, mem, sizeof(hdr.ar_name) - 1);\n#else\n      return strneq (name, mem, sizeof(hdr.ar_name) - 2);\n#endif /* !__hpux && !cray */\n#endif /* !AIAMAG */\n    }\n#endif /* !VMS */\n\n  return !strcmp (name, mem);\n}", "path": "arscan.c", "repo_name": "mseaborn/gnu-make", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 1136}
{"docstring": "/* Return nonzero if NAME is an archive-member reference, zero if not.\n   An archive-member reference is a name like `lib(member)'.\n   If a name like `lib((entry))' is used, a fatal error is signaled at\n   the attempt to use this unsupported feature.  */\n", "func_signal": "int\nar_name (const char *name)", "code": "{\n  const char *p = strchr (name, '(');\n  const char *end;\n\n  if (p == 0 || p == name)\n    return 0;\n\n  end = p + strlen (p) - 1;\n  if (*end != ')')\n    return 0;\n\n  if (p[1] == '(' && end[-1] == ')')\n    fatal (NILF, _(\"attempt to use unsupported feature: `%s'\"), name);\n\n  return 1;\n}", "path": "ar.c", "repo_name": "mseaborn/gnu-make", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 1136}
{"docstring": "/* Generate some stats output.  */\n", "func_signal": "void\nstrcache_print_stats (const char *prefix)", "code": "{\n  int numbuffs = 0, numstrs = 0;\n  int totsize = 0, avgsize, maxsize = 0, minsize = bufsize;\n  int totfree = 0, avgfree, maxfree = 0, minfree = bufsize;\n  int lastused = 0, lastfree = 0;\n\n  if (strcache)\n    {\n      const struct strcache *sp;\n\n      /* Count the first buffer separately since it's not full.  */\n      lastused = strcache->end - strcache->buffer;\n      lastfree = strcache->bytesfree;\n\n      for (sp = strcache->next; sp != NULL; sp = sp->next)\n        {\n          int bf = sp->bytesfree;\n          int sz = sp->end - sp->buffer;\n\n          ++numbuffs;\n          numstrs += sp->count;\n\n          totsize += sz;\n          maxsize = (sz > maxsize ? sz : maxsize);\n          minsize = (sz < minsize ? sz : minsize);\n\n          totfree += bf;\n          maxfree = (bf > maxfree ? bf : maxfree);\n          minfree = (bf < minfree ? bf : minfree);\n        }\n    }\n\n  avgsize = numbuffs ? (int)(totsize / numbuffs) : 0;\n  avgfree = numbuffs ? (int)(totfree / numbuffs) : 0;\n\n  printf (_(\"\\n%s # of strings in strcache: %d / lookups = %lu / hits = %lu\\n\"),\n          prefix, numstrs, total_adds, (total_adds - numstrs));\n  printf (_(\"%s # of strcache buffers: %d (* %d B/buffer = %d B)\\n\"),\n          prefix, (numbuffs + 1), bufsize, ((numbuffs + 1) * bufsize));\n  printf (_(\"%s strcache used: total = %d (%d) / max = %d / min = %d / avg = %d\\n\"),\n          prefix, totsize, lastused, maxsize, minsize, avgsize);\n  printf (_(\"%s strcache free: total = %d (%d) / max = %d / min = %d / avg = %d\\n\"),\n          prefix, totfree, lastfree, maxfree, minfree, avgfree);\n\n  fputs (_(\"\\n# strcache hash-table stats:\\n# \"), stdout);\n  hash_print_stats (&strings, stdout);\n}", "path": "strcache.c", "repo_name": "mseaborn/gnu-make", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 1136}
{"docstring": "/* Print the data base of VPATH search paths.  */\n", "func_signal": "void\nprint_vpath_data_base (void)", "code": "{\n  unsigned int nvpaths;\n  struct vpath *v;\n\n  puts (_(\"\\n# VPATH Search Paths\\n\"));\n\n  nvpaths = 0;\n  for (v = vpaths; v != 0; v = v->next)\n    {\n      register unsigned int i;\n\n      ++nvpaths;\n\n      printf (\"vpath %s \", v->pattern);\n\n      for (i = 0; v->searchpath[i] != 0; ++i)\n\tprintf (\"%s%c\", v->searchpath[i],\n\t\tv->searchpath[i + 1] == 0 ? '\\n' : PATH_SEPARATOR_CHAR);\n    }\n\n  if (vpaths == 0)\n    puts (_(\"# No `vpath' search paths.\"));\n  else\n    printf (_(\"\\n# %u `vpath' search paths.\\n\"), nvpaths);\n\n  if (general_vpath == 0)\n    puts (_(\"\\n# No general (`VPATH' variable) search path.\"));\n  else\n    {\n      const char **path = general_vpath->searchpath;\n      unsigned int i;\n\n      fputs (_(\"\\n# General (`VPATH' variable) search path:\\n# \"), stdout);\n\n      for (i = 0; path[i] != 0; ++i)\n\tprintf (\"%s%c\", path[i],\n\t\tpath[i + 1] == 0 ? '\\n' : PATH_SEPARATOR_CHAR);\n    }\n}", "path": "vpath.c", "repo_name": "mseaborn/gnu-make", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 1136}
{"docstring": "/*\n  get translation of logical name\n\n*/\n", "func_signal": "static char *\ntrnlog (const char *name)", "code": "{\n  int stat;\n  static char reslt[1024];\n  $DESCRIPTOR (reslt_dsc, reslt);\n  short resltlen;\n  struct dsc$descriptor_s name_dsc;\n  char *s;\n\n  INIT_DSC_CSTRING (name_dsc, name);\n\n  stat = lib$sys_trnlog (&name_dsc, &resltlen, &reslt_dsc);\n\n  if ((stat&1) == 0)\n    {\n      return \"\";\n    }\n  if (stat == SS$_NOTRAN)\n    {\n      return \"\";\n    }\n  reslt[resltlen] = '\\0';\n\n  s = malloc (resltlen+1);\n  if (s == 0)\n    return \"\";\n  strcpy (s, reslt);\n  return s;\n}", "path": "vmsify.c", "repo_name": "mseaborn/gnu-make", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 1136}
{"docstring": "/* Add a new buffer to the cache.  Add it at the front to reduce search time.\n   This can also increase the overhead, since it's less likely that older\n   buffers will be filled in.  However, GNU make has so many smaller strings\n   that this doesn't seem to be much of an issue in practice.\n */\n", "func_signal": "static struct strcache *\nnew_cache()", "code": "{\n  struct strcache *new;\n  new = xmalloc (sizeof (*new) + bufsize);\n  new->end = new->buffer;\n  new->count = 0;\n  new->bytesfree = bufsize;\n\n  new->next = strcache;\n  strcache = new;\n\n  return new;\n}", "path": "strcache.c", "repo_name": "mseaborn/gnu-make", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 1136}
{"docstring": "/* Returns true if the string is in the cache; false if not.  */\n", "func_signal": "int\nstrcache_iscached (const char *str)", "code": "{\n  struct strcache *sp;\n\n  for (sp = strcache; sp != 0; sp = sp->next)\n    if (str >= sp->buffer && str < sp->end)\n      return 1;\n\n  return 0;\n}", "path": "strcache.c", "repo_name": "mseaborn/gnu-make", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 1136}
{"docstring": "/*\n  convert from vms-style to unix-style\n\n  dev:[dir1.dir2]\t//dev/dir1/dir2/\n*/\n", "func_signal": "const char *\nunixify (const char *name)", "code": "{\n  static char piece[512];\n  const char *s;\n  char *p;\n\n  if (strchr (name, '/') != 0)\t\t/* already in unix style */\n    {\n      strcpy (piece, name);\n      return piece;\n    }\n\n  p = piece;\n  *p = 0;\n\n  /* device part */\n\n  s = strchr (name, ':');\n\n  if (s != 0)\n    {\n      int l = s - name;\n      *p++ = '/';\n      *p++ = '/';\n      strncpy (p, name, l);\n      p += l;\n    }\n\n  /* directory part */\n\n  *p++ = '/';\n  s = strchr (name, '[');\n\n  if (s != 0)\n    {\n      s++;\n      switch (*s)\n        {\n\t  case ']':\t\t/* [] */\n\t    strcat (p, \"./\");\n\t    break;\n\t  case '-':\t\t/* [- */\n\t    strcat (p, \"../\");\n\t    break;\n\t  case '.':\n\t    strcat (p, \"./\");\t/* [. */\n\t    break;\n\t  default:\n\t    s--;\n\t    break;\n        }\n      s++;\n      while (*s)\n        {\n\t  if (*s == '.')\n\t    *p++ = '/';\n\t  else\n\t    *p++ = *s;\n\t  s++;\n\t  if (*s == ']')\n\t    {\n\t      s++;\n\t      break;\n\t    }\n        }\n      if (*s != 0)\t\t/* more after ']' ?? */\n        {\n\t  if (*(p-1) != '/')\n\t    *p++ = '/';\n\t  strcpy (p, s);\t\t/* copy it anyway */\n        }\n    }\n\n  else\t\t/* no '[' anywhere */\n\n    {\n      *p++ = 0;\n    }\n\n  /* force end with '/' */\n\n  if (*(p-1) != '/')\n    *p++ = '/';\n  *p = 0;\n\n  return piece;\n}", "path": "vmsify.c", "repo_name": "mseaborn/gnu-make", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 1136}
{"docstring": "/* ARGSUSED */\n", "func_signal": "static long int\nar_member_pos (int desc UNUSED, const char *mem, int truncated,\n\t       long int hdrpos, long int datapos UNUSED, long int size UNUSED,\n               long int date UNUSED, int uid UNUSED, int gid UNUSED,\n               int mode UNUSED, const void *name)", "code": "{\n  if (!ar_name_equal (name, mem, truncated))\n    return 0;\n  return hdrpos;\n}", "path": "arscan.c", "repo_name": "mseaborn/gnu-make", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 1136}
{"docstring": "/* yy_get_previous_state - get the state just before the EOB char was reached */\n", "func_signal": "static yy_state_type yy_get_previous_state (void)", "code": "{\n\tregister yy_state_type yy_current_state;\n\tregister char *yy_cp;\n    \n\tyy_current_state = (yy_start);\n\n\tfor ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )\n\t\t{\n\t\tregister YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);\n\t\tif ( yy_accept[yy_current_state] )\n\t\t\t{\n\t\t\t(yy_last_accepting_state) = yy_current_state;\n\t\t\t(yy_last_accepting_cpos) = yy_cp;\n\t\t\t}\n\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t\t{\n\t\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\t\tif ( yy_current_state >= 202 )\n\t\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t\t}\n\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n\t\t}\n\n\treturn yy_current_state;\n}", "path": "pascalIntermediateCodeGenerator\\lex.yy.c", "repo_name": "Tisor/PascalCompiler", "stars": 0, "license": "None", "language": "c", "size": 316}
{"docstring": "// Prints an Undeclared Identifier error\n", "func_signal": "void undeclaredID(token id)", "code": "{\n\tif(lookup(id.key,0,0)==NULL)\n\t\tprintf(\"Line no %d: Undefined variable %s\\n\",lineNo, id.key); \n}", "path": "pascalIntermediateCodeGenerator\\y.tab.c", "repo_name": "Tisor/PascalCompiler", "stars": 0, "license": "None", "language": "c", "size": 316}
{"docstring": "/** Destroy the buffer.\n * @param b a buffer created with yy_create_buffer()\n * \n */\n", "func_signal": "void yy_delete_buffer (YY_BUFFER_STATE  b )", "code": "{\n    \n\tif ( ! b )\n\t\treturn;\n\n\tif ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */\n\t\tYY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;\n\n\tif ( b->yy_is_our_buffer )\n\t\tyyfree((void *) b->yy_ch_buf  );\n\n\tyyfree((void *) b  );\n}", "path": "pascalIntermediateCodeGenerator\\lex.yy.c", "repo_name": "Tisor/PascalCompiler", "stars": 0, "license": "None", "language": "c", "size": 316}
{"docstring": "/** Setup the input buffer state to scan directly from a user-specified character buffer.\n * @param base the character buffer\n * @param size the size in bytes of the character buffer\n * \n * @return the newly allocated buffer state object. \n */\n", "func_signal": "YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )", "code": "{\n\tYY_BUFFER_STATE b;\n    \n\tif ( size < 2 ||\n\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n\t     base[size-1] != YY_END_OF_BUFFER_CHAR )\n\t\t/* They forgot to leave room for the EOB's. */\n\t\treturn 0;\n\n\tb = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_buffer()\" );\n\n\tb->yy_buf_size = size - 2;\t/* \"- 2\" to take care of EOB's */\n\tb->yy_buf_pos = b->yy_ch_buf = base;\n\tb->yy_is_our_buffer = 0;\n\tb->yy_input_file = 0;\n\tb->yy_n_chars = b->yy_buf_size;\n\tb->yy_is_interactive = 0;\n\tb->yy_at_bol = 1;\n\tb->yy_fill_buffer = 0;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tyy_switch_to_buffer(b  );\n\n\treturn b;\n}", "path": "pascalIntermediateCodeGenerator\\lex.yy.c", "repo_name": "Tisor/PascalCompiler", "stars": 0, "license": "None", "language": "c", "size": 316}
{"docstring": "/** Removes and deletes the top of the stack, if present.\n *  The next element becomes the new top.\n *  \n */\n", "func_signal": "void yypop_buffer_state (void)", "code": "{\n    \tif (!YY_CURRENT_BUFFER)\n\t\treturn;\n\n\tyy_delete_buffer(YY_CURRENT_BUFFER );\n\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\tif ((yy_buffer_stack_top) > 0)\n\t\t--(yy_buffer_stack_top);\n\n\tif (YY_CURRENT_BUFFER) {\n\t\tyy_load_buffer_state( );\n\t\t(yy_did_buffer_switch_on_eof) = 1;\n\t}\n}", "path": "pascalIntermediateCodeGenerator\\lex.yy.c", "repo_name": "Tisor/PascalCompiler", "stars": 0, "license": "None", "language": "c", "size": 316}
{"docstring": "/** Pushes the new state onto the stack. The new state becomes\n *  the current state. This function will allocate the stack\n *  if necessary.\n *  @param new_buffer The new state.\n *  \n */\n", "func_signal": "void yypush_buffer_state (YY_BUFFER_STATE new_buffer )", "code": "{\n    \tif (new_buffer == NULL)\n\t\treturn;\n\n\tyyensure_buffer_stack();\n\n\t/* This block is copied from yy_switch_to_buffer. */\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(yy_c_buf_p) = (yy_hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\t/* Only push if top exists. Otherwise, replace top. */\n\tif (YY_CURRENT_BUFFER)\n\t\t(yy_buffer_stack_top)++;\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\n\t/* copied from yy_switch_to_buffer. */\n\tyy_load_buffer_state( );\n\t(yy_did_buffer_switch_on_eof) = 1;\n}", "path": "pascalIntermediateCodeGenerator\\lex.yy.c", "repo_name": "Tisor/PascalCompiler", "stars": 0, "license": "None", "language": "c", "size": 316}
{"docstring": "/* Initializes or reinitializes a buffer.\n * This function is sometimes called more than once on the same buffer,\n * such as during a yyrestart() or at EOF.\n */\n", "func_signal": "static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )", "code": "{\n\tint oerrno = errno;\n    \n\tyy_flush_buffer(b );\n\n\tb->yy_input_file = file;\n\tb->yy_fill_buffer = 1;\n\n    /* If b is the current buffer, then yy_init_buffer was _probably_\n     * called from yyrestart() or through yy_get_next_buffer.\n     * In that case, we don't want to reset the lineno or column.\n     */\n    if (b != YY_CURRENT_BUFFER){\n        b->yy_bs_lineno = 1;\n        b->yy_bs_column = 0;\n    }\n\n        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;\n    \n\terrno = oerrno;\n}", "path": "pascalIntermediateCodeGenerator\\lex.yy.c", "repo_name": "Tisor/PascalCompiler", "stars": 0, "license": "None", "language": "c", "size": 316}
{"docstring": "/* Allocates the stack if it does not exist.\n *  Guarantees space for at least one push.\n */\n", "func_signal": "static void yyensure_buffer_stack (void)", "code": "{\n\tint num_to_alloc;\n    \n\tif (!(yy_buffer_stack)) {\n\n\t\t/* First allocation is just for 2 elements, since we don't know if this\n\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an\n\t\t * immediate realloc on the next call.\n         */\n\t\tnum_to_alloc = 1;\n\t\t(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc\n\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t);\n\t\tif ( ! (yy_buffer_stack) )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yyensure_buffer_stack()\" );\n\t\t\t\t\t\t\t\t  \n\t\tmemset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n\t\t\t\t\n\t\t(yy_buffer_stack_max) = num_to_alloc;\n\t\t(yy_buffer_stack_top) = 0;\n\t\treturn;\n\t}\n\n\tif ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){\n\n\t\t/* Increase the buffer to prepare for a possible push. */\n\t\tint grow_size = 8 /* arbitrary grow size */;\n\n\t\tnum_to_alloc = (yy_buffer_stack_max) + grow_size;\n\t\t(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc\n\t\t\t\t\t\t\t\t((yy_buffer_stack),\n\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t);\n\t\tif ( ! (yy_buffer_stack) )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yyensure_buffer_stack()\" );\n\n\t\t/* zero only the new slots.*/\n\t\tmemset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));\n\t\t(yy_buffer_stack_max) = num_to_alloc;\n\t}\n}", "path": "pascalIntermediateCodeGenerator\\lex.yy.c", "repo_name": "Tisor/PascalCompiler", "stars": 0, "license": "None", "language": "c", "size": 316}
{"docstring": "// Converts type to an enumeration\n", "func_signal": "int getTypeNo(int type)", "code": "{\n\tswitch (type)\n\t{\n\t\tcase INTEGER: return 0;\n\t\tcase REAL: return 1;\n\t\tcase BOOL: return 2;\n\t}\n}", "path": "pascalIntermediateCodeGenerator\\y.tab.c", "repo_name": "Tisor/PascalCompiler", "stars": 0, "license": "None", "language": "c", "size": 316}
{"docstring": "/* Print the list */\n", "func_signal": "void printList( ListNodePtr currentPtr )", "code": "{\n    if ( currentPtr != NULL )\n    {\n        while ( currentPtr != NULL ) {\n            printf( \"%-15s\\t%d\\n\", currentPtr->data.key, currentPtr->data.type);\n            currentPtr = currentPtr->nextPtr;\n        }\n    }\n}", "path": "pascalIntermediateCodeGenerator\\map.c", "repo_name": "Tisor/PascalCompiler", "stars": 0, "license": "None", "language": "c", "size": 316}
{"docstring": "/** Immediately switch to a different input stream.\n * @param input_file A readable stream.\n * \n * @note This function does not reset the start condition to @c INITIAL .\n */\n", "func_signal": "void yyrestart  (FILE * input_file )", "code": "{\n    \n\tif ( ! YY_CURRENT_BUFFER ){\n        yyensure_buffer_stack ();\n\t\tYY_CURRENT_BUFFER_LVALUE =\n            yy_create_buffer(yyin,YY_BUF_SIZE );\n\t}\n\n\tyy_init_buffer(YY_CURRENT_BUFFER,input_file );\n\tyy_load_buffer_state( );\n}", "path": "pascalIntermediateCodeGenerator\\lex.yy.c", "repo_name": "Tisor/PascalCompiler", "stars": 0, "license": "None", "language": "c", "size": 316}
{"docstring": "/* Insert a new value into the list in sorted order */\n", "func_signal": "ListNodePtr insertNode( ListNodePtr *sPtr, token value )", "code": "{\n    ListNodePtr newPtr, previousPtr, currentPtr;\n    newPtr = malloc( sizeof( ListNode ) );\n    if ( newPtr != NULL ) {     /* is space available */\n        newPtr->data = value;\n        newPtr->nextPtr = NULL;\n        previousPtr = NULL;\n        currentPtr = *sPtr;\n\n        while ( currentPtr != NULL) {\n            previousPtr = currentPtr;          /* walk to ...   */\n            currentPtr = currentPtr->nextPtr; /* ... next node */\n        }\n        if ( previousPtr == NULL ) {\n            newPtr->nextPtr = *sPtr;\n            *sPtr = newPtr;\n        }\n        else {\n            previousPtr->nextPtr = newPtr;\n            newPtr->nextPtr = currentPtr;\n        }\n    }\n    else\n        printf( \"%s not inserted. No memory available.\\n\", value.key );\n\n    return newPtr;\n}", "path": "pascalIntermediateCodeGenerator\\map.c", "repo_name": "Tisor/PascalCompiler", "stars": 0, "license": "None", "language": "c", "size": 316}
{"docstring": "/* Copy into YYRESULT an error message about the unexpected token\n   YYCHAR while in state YYSTATE.  Return the number of bytes copied,\n   including the terminating null byte.  If YYRESULT is null, do not\n   copy anything; just return the number of bytes that would be\n   copied.  As a special case, return 0 if an ordinary \"syntax error\"\n   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during\n   size calculation.  */\n", "func_signal": "static YYSIZE_T\nyysyntax_error (char *yyresult, int yystate, int yychar)", "code": "{\n  int yyn = yypact[yystate];\n\n  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))\n    return 0;\n  else\n    {\n      int yytype = YYTRANSLATE (yychar);\n      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);\n      YYSIZE_T yysize = yysize0;\n      YYSIZE_T yysize1;\n      int yysize_overflow = 0;\n      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };\n      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];\n      int yyx;\n\n# if 0\n      /* This is so xgettext sees the translatable formats that are\n\t constructed on the fly.  */\n      YY_(\"syntax error, unexpected %s\");\n      YY_(\"syntax error, unexpected %s, expecting %s\");\n      YY_(\"syntax error, unexpected %s, expecting %s or %s\");\n      YY_(\"syntax error, unexpected %s, expecting %s or %s or %s\");\n      YY_(\"syntax error, unexpected %s, expecting %s or %s or %s or %s\");\n# endif\n      char *yyfmt;\n      char const *yyf;\n      static char const yyunexpected[] = \"syntax error, unexpected %s\";\n      static char const yyexpecting[] = \", expecting %s\";\n      static char const yyor[] = \" or %s\";\n      char yyformat[sizeof yyunexpected\n\t\t    + sizeof yyexpecting - 1\n\t\t    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)\n\t\t       * (sizeof yyor - 1))];\n      char const *yyprefix = yyexpecting;\n\n      /* Start YYX at -YYN if negative to avoid negative indexes in\n\t YYCHECK.  */\n      int yyxbegin = yyn < 0 ? -yyn : 0;\n\n      /* Stay within bounds of both yycheck and yytname.  */\n      int yychecklim = YYLAST - yyn + 1;\n      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;\n      int yycount = 1;\n\n      yyarg[0] = yytname[yytype];\n      yyfmt = yystpcpy (yyformat, yyunexpected);\n\n      for (yyx = yyxbegin; yyx < yyxend; ++yyx)\n\tif (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)\n\t  {\n\t    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)\n\t      {\n\t\tyycount = 1;\n\t\tyysize = yysize0;\n\t\tyyformat[sizeof yyunexpected - 1] = '\\0';\n\t\tbreak;\n\t      }\n\t    yyarg[yycount++] = yytname[yyx];\n\t    yysize1 = yysize + yytnamerr (0, yytname[yyx]);\n\t    yysize_overflow |= (yysize1 < yysize);\n\t    yysize = yysize1;\n\t    yyfmt = yystpcpy (yyfmt, yyprefix);\n\t    yyprefix = yyor;\n\t  }\n\n      yyf = YY_(yyformat);\n      yysize1 = yysize + yystrlen (yyf);\n      yysize_overflow |= (yysize1 < yysize);\n      yysize = yysize1;\n\n      if (yysize_overflow)\n\treturn YYSIZE_MAXIMUM;\n\n      if (yyresult)\n\t{\n\t  /* Avoid sprintf, as that infringes on the user's name space.\n\t     Don't have undefined behavior even if the translation\n\t     produced a string with the wrong number of \"%s\"s.  */\n\t  char *yyp = yyresult;\n\t  int yyi = 0;\n\t  while ((*yyp = *yyf) != '\\0')\n\t    {\n\t      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)\n\t\t{\n\t\t  yyp += yytnamerr (yyp, yyarg[yyi++]);\n\t\t  yyf += 2;\n\t\t}\n\t      else\n\t\t{\n\t\t  yyp++;\n\t\t  yyf++;\n\t\t}\n\t    }\n\t}\n      return yysize;\n    }\n}", "path": "pascalIntermediateCodeGenerator\\y.tab.c", "repo_name": "Tisor/PascalCompiler", "stars": 0, "license": "None", "language": "c", "size": 316}
{"docstring": "/** Switch to a different input buffer.\n * @param new_buffer The new input buffer.\n * \n */\n", "func_signal": "void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )", "code": "{\n    \n\t/* TODO. We should be able to replace this entire function body\n\t * with\n\t *\t\tyypop_buffer_state();\n\t *\t\tyypush_buffer_state(new_buffer);\n     */\n\tyyensure_buffer_stack ();\n\tif ( YY_CURRENT_BUFFER == new_buffer )\n\t\treturn;\n\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(yy_c_buf_p) = (yy_hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\tyy_load_buffer_state( );\n\n\t/* We don't actually know whether we did this switch during\n\t * EOF (yywrap()) processing, but the only time this flag\n\t * is looked at is after yywrap() is called, so it's safe\n\t * to go ahead and always set it.\n\t */\n\t(yy_did_buffer_switch_on_eof) = 1;\n}", "path": "pascalIntermediateCodeGenerator\\lex.yy.c", "repo_name": "Tisor/PascalCompiler", "stars": 0, "license": "None", "language": "c", "size": 316}
{"docstring": "/** Discard all buffered characters. On the next scan, YY_INPUT will be called.\n * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.\n * \n */\n", "func_signal": "void yy_flush_buffer (YY_BUFFER_STATE  b )", "code": "{\n    \tif ( ! b )\n\t\treturn;\n\n\tb->yy_n_chars = 0;\n\n\t/* We always need two end-of-buffer characters.  The first causes\n\t * a transition to the end-of-buffer state.  The second causes\n\t * a jam in that state.\n\t */\n\tb->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;\n\tb->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;\n\n\tb->yy_buf_pos = &b->yy_ch_buf[0];\n\n\tb->yy_at_bol = 1;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tif ( b == YY_CURRENT_BUFFER )\n\t\tyy_load_buffer_state( );\n}", "path": "pascalIntermediateCodeGenerator\\lex.yy.c", "repo_name": "Tisor/PascalCompiler", "stars": 0, "license": "None", "language": "c", "size": 316}
{"docstring": "/* Checks if the current key is already present in the hash-table */\n", "func_signal": "ListNodePtr lookup(char *key, int tableNo,int mode)", "code": "{\n    int index=hashjw(key);\n    ListNodePtr x=symbolTable[index][tableNo];\n    while(x!=NULL)\n    {\n        if(strcmp(x->data.key,key)==0)\n            return x;\n        x=x->nextPtr;\n    }\n    if(tableNo != 0)\n    {\n        ListNodePtr retFromMainST = lookup(key,0,0);\n        if(retFromMainST != NULL)\n            return retFromMainST;\n    }\n    return NULL;\n}", "path": "pascalIntermediateCodeGenerator\\map.c", "repo_name": "Tisor/PascalCompiler", "stars": 0, "license": "None", "language": "c", "size": 316}
{"docstring": "/*\n * Returns the ST entry pointer for new local variable \n * generated by the compiler\n */\n", "func_signal": "struct listNode* newTemp()", "code": "{\n\tstatic int ctr = 0;\n\tchar *varName = (char *)malloc(SIZE_OF_TEMP);\n\t//this creates a new variable __ti and increments i\n\tsprintf(varName,\"__t%d\",ctr++);\n\tListNodePtr lookupToken = lookup(varName,currentST,0);\n\tif(lookupToken != NULL)\n\t{\n\t\tprintf(\"ERROR, TERMINATING!!!\\n\");\n\t\texit(0);\n\t}\n\ttoken entry;\n\tinitToken(&entry);\n\tstrcpy(entry.key,varName);\n\tListNodePtr entryPtr=insertIntoMap(varName,entry,currentST);\n\treturn entryPtr;\n}", "path": "pascalIntermediateCodeGenerator\\y.tab.c", "repo_name": "Tisor/PascalCompiler", "stars": 0, "license": "None", "language": "c", "size": 316}
{"docstring": "/* Delete a list element */\n", "func_signal": "token deleteNode( ListNodePtr *sPtr, token value )", "code": "{\n    ListNodePtr previousPtr, currentPtr, tempPtr;\n\n    if (strcmp(value.key,(*sPtr)->data.key)) {\n        tempPtr = *sPtr;\n        *sPtr = ( *sPtr )->nextPtr; /* de-thread the node */\n        free( tempPtr );             /* free the de-threaded node */\n        return value;\n    }\n    else {\n        previousPtr = *sPtr;\n        currentPtr = ( *sPtr )->nextPtr;\n\n        while ( currentPtr != NULL && strcmp(currentPtr->data.key,value.key)!=0 ) {\n            previousPtr = currentPtr;          /* walk to ...   */\n            currentPtr = currentPtr->nextPtr;  /* ... next node */\n        }\n\n        if ( currentPtr != NULL ) {\n            tempPtr = currentPtr;\n            previousPtr->nextPtr = currentPtr->nextPtr;\n            free( tempPtr );\n            return value;\n        }\n    }\n\n    token temp;\n    strcpy(temp.key,\"\\0\");\n    return temp;\n }\n\n/* Return 1 if the list is empty, 0 otherwise */\nint isEmpty( ListNodePtr sPtr )\n{\n    return sPtr == NULL;\n}", "path": "pascalIntermediateCodeGenerator\\map.c", "repo_name": "Tisor/PascalCompiler", "stars": 0, "license": "None", "language": "c", "size": 316}
{"docstring": "/* Copy to YYRES the contents of YYSTR after stripping away unnecessary\n   quotes and backslashes, so that it's suitable for yyerror.  The\n   heuristic is that double-quoting is unnecessary unless the string\n   contains an apostrophe, a comma, or backslash (other than\n   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is\n   null, do not copy; instead, return the length of what the result\n   would have been.  */\n", "func_signal": "static YYSIZE_T\nyytnamerr (char *yyres, const char *yystr)", "code": "{\n  if (*yystr == '\"')\n    {\n      YYSIZE_T yyn = 0;\n      char const *yyp = yystr;\n\n      for (;;)\n\tswitch (*++yyp)\n\t  {\n\t  case '\\'':\n\t  case ',':\n\t    goto do_not_strip_quotes;\n\n\t  case '\\\\':\n\t    if (*++yyp != '\\\\')\n\t      goto do_not_strip_quotes;\n\t    /* Fall through.  */\n\t  default:\n\t    if (yyres)\n\t      yyres[yyn] = *yyp;\n\t    yyn++;\n\t    break;\n\n\t  case '\"':\n\t    if (yyres)\n\t      yyres[yyn] = '\\0';\n\t    return yyn;\n\t  }\n    do_not_strip_quotes: ;\n    }\n\n  if (! yyres)\n    return yystrlen (yystr);\n\n  return yystpcpy (yyres, yystr) - yyres;\n}", "path": "pascalIntermediateCodeGenerator\\y.tab.c", "repo_name": "Tisor/PascalCompiler", "stars": 0, "license": "None", "language": "c", "size": 316}
{"docstring": "/* The hashing function */\n", "func_signal": "int hashjw( char* s)", "code": "{\n    int i;\n    unsigned long int h = 0, g;         // unsigned for 32 bit int will do\n    for( i = 0 ; s[i] != '\\0' ; i ++ )\n    {\n        h = (h<<4) + s[i];\n        if ( g = h & 0xF000000 ) {\n            h = h ^ ( g >> 24 );        // h ^= (g>>24);\n            h = h ^ g;                  // h ^= g;\n        }\n    }\n    return ( h % PRIME );\n}", "path": "pascalIntermediateCodeGenerator\\map.c", "repo_name": "Tisor/PascalCompiler", "stars": 0, "license": "None", "language": "c", "size": 316}
{"docstring": "/* handler invoked by readline when input is submitted with enter */\n", "func_signal": "static void tty_executor( char *input )", "code": "{\n\tchar *c;\n\tint len;\n\n\t/* readline got EOF */\n\tif( ! input ){\n\t\tterminate++;\n\t\treturn;\n\t}\n\n\t/* empty command */\n\tif( ! *input ){\n\t\tfree( input );\n\t\treturn;\n\t}\n\n\t/* strip trailing whitespace */\n\tfor( c = input + strlen(input) - 1; c != input && isspace(*c); --c )\n\t\t*c = 0;\n\n\tadd_history(input);\n\n\t/* execute action - if one is defined */\n\n\tlen = strcspn( input, \"\\t \" );\n\tif( 0 == strcasecmp( input, \"quit\" ) ){\n\t\tterminate++;\n\n\t} else if( 0 == strcasecmp( input, \"exit\" ) ){\n\t\tterminate++;\n\n\t} else if( len ==4 && 0 == strncasecmp( input, \"user\", 4 ) ){\n\t\tcmd_user( input +4 );\n\n\t} else {\n\t\tduc_cmd( con, input );\n\t}\n\n\tfree(input);\n}", "path": "cli\\tty.c", "repo_name": "rclasen/dudlc", "stars": 0, "license": "other", "language": "c", "size": 404}
{"docstring": "/************************************************************\n * init\n */\n", "func_signal": "void events_init( dudlc *c )", "code": "{\n\tmemset(&events, 0, sizeof(events));\n\tduc_setevents( c, &events );\n\n\t//events.bcast = cb_bcast;\n\n\tevents.connect = cb_conn;\n\tevents.disconnect = cb_disc;\n\n\t//events.login = cb_login;\n\t//events.logout = cb_logout;\n\tevents.kicked = cb_kicked;\n\n\tevents.nexttrack = cb_nexttrack;\n\tevents.stopped = cb_stopped;\n\tevents.paused = cb_paused;\n\tevents.resumed = cb_resumed;\n\tevents.random = cb_random;\n\t//events.elapsed = cb_elapsed;\n\n\t//events.filter = cb_filter;\n\n\tevents.queuefetch = NULL;\n\t//events.queueadd = cb_queueadd;\n\t//events.queuedel = cb_queuedel;\n\tevents.queueclear = cb_queueclear;\n\n\tevents.sleep = cb_sleep;\n\n\t//events.tagchange = cb_tagchange;\n\t//events.tagdel = cb_tagdel;\n}", "path": "cli\\events.c", "repo_name": "rclasen/dudlc", "stars": 0, "license": "other", "language": "c", "size": 404}
{"docstring": "/************************************************************\n * sleep\n */\n", "func_signal": "static void cb_sleep( dudlc *c, int del )", "code": "{\n\ttty_msg( \"falling asleep in %d sec\\n\", del );\n\t(void)c;\n}", "path": "cli\\events.c", "repo_name": "rclasen/dudlc", "stars": 0, "license": "other", "language": "c", "size": 404}
{"docstring": "/************************************************************\n * player\n */\n", "func_signal": "static void cb_nexttrack( dudlc *c, duc_track *t )", "code": "{\n\tchar buf[BUFLENTRACK];\n\n\ttty_msg( \"%s\\n\", dfmt_track(buf, BUFLENTRACK, t ));\n\t(void)c;\n}", "path": "cli\\events.c", "repo_name": "rclasen/dudlc", "stars": 0, "license": "other", "language": "c", "size": 404}
{"docstring": "/*\n * called by readline to get one/next possible completion\n * for top-level commands.\n *\n * this adds local completions to the ones returned from the lib.\n */\n", "func_signal": "static char *tty_cgen_top( const char *text, int state )", "code": "{\n\tstatic char **next;\n\tstatic unsigned int len;\n\n\tif( state == 0 ){\n\t\tnext = topcmds;\n\t\tlen = strlen(text);\n\t}\n\n\tif( cgen ){\n\t\tchar *r;\n\n\t\tif( NULL != (r = (*cgen)( con, text, state )))\n\t\t\treturn r;\n\t}\n\n\twhile( *next ){\n\t\tif( strncasecmp(text,*next,len) == 0 )\n\t\t\treturn strdup(*(next++));\n\t\tnext++;\n\t}\n\treturn NULL;\n}", "path": "cli\\tty.c", "repo_name": "rclasen/dudlc", "stars": 0, "license": "other", "language": "c", "size": 404}
{"docstring": "/*\n * handler invoked by readline to get a list of complettions\n */\n", "func_signal": "static char **tty_completer( const char *text, int start, int end )", "code": "{\n\tduc_cgen gen;\n\n\t(void) end; /* shut up gcc */\n\n\trl_attempted_completion_over = 1;\n\n\tif( NULL == (gen = duc_cgen_find(con, rl_line_buffer, start )))\n\t\treturn NULL;\n\n\tcgen = gen;\n\n\treturn rl_completion_matches( text, start ? tty_cgen : tty_cgen_top );\n}", "path": "cli\\tty.c", "repo_name": "rclasen/dudlc", "stars": 0, "license": "other", "language": "c", "size": 404}
{"docstring": "/*\n * called by readline to get one/next possible completion\n * for commands arguments.\n */\n", "func_signal": "static char *tty_cgen( const char *text, int state )", "code": "{\n\tif( ! cgen )\n\t\treturn NULL;\n\n\treturn (*cgen)( con, text, state );\n}", "path": "cli\\tty.c", "repo_name": "rclasen/dudlc", "stars": 0, "license": "other", "language": "c", "size": 404}
{"docstring": "/* TODO: cannot specify multiple symbolic tags:\n * - val_tag takes up all non-space characters\n * - ... because idl_addclist passes the whole list as string\n *\n * either make addclist split the list before calling val_tag\n * or make val_tag onle look for alphnum chars\n */\n", "func_signal": "t_idlist *val_taglist( dudlc *con, char *in, char **end )", "code": "{\n\tt_idlist *idl;\n\n\tif( NULL == (idl = idl_new(NULL)))\n\t\treturn NULL;\n\n\tidl_addclist( idl, in, end, con, val_tag );\n\n\treturn idl;\n}", "path": "cmd\\parseval.c", "repo_name": "rclasen/dudlc", "stars": 0, "license": "other", "language": "c", "size": 404}
{"docstring": "/************************************************************\n * widget signal handler\n */\n", "func_signal": "static void shrink_y( GtkWindow *win )", "code": "{\n\tgint x;\n\tgtk_window_get_size( win, &x, NULL );\n\tgtk_window_resize( win, x, 1 );\n}", "path": "gtk\\main.c", "repo_name": "rclasen/dudlc", "stars": 0, "license": "other", "language": "c", "size": 404}
{"docstring": "/*\n * list := <item>[,...]\n * item := <parsed by t_convert function>\n */\n", "func_signal": "static int idl_addclist( t_idlist *idl, char *in, char **end, dudlc *con, t_convert conv )", "code": "{\n\tint added = 0;\n\tchar *ntok = in;\n\tchar *e;\n\n\twhile(1){\n\t\tint id;\n\n\t\tid = (*conv)( con, ntok, &e );\n\t\tif( ntok == e ){\n\t\t\tif( end )\n\t\t\t\t*end = in;\n\t\t\treturn 0;\n\t\t}\n\t\tidl_add( idl, id );\n\t\tadded ++;\n\n\t\tif( *e != ',' )\n\t\t\tbreak;\n\n\t\t++e;\n\t\tntok = e;\n\t}\n\n\tif( end )\n\t\t*end = e;\n\n\treturn added;\n}", "path": "cmd\\parseval.c", "repo_name": "rclasen/dudlc", "stars": 0, "license": "other", "language": "c", "size": 404}
{"docstring": "/*\n * selection processing\n */\n", "func_signal": "void queue_list_select_deltrack( GtkTreeView *list )", "code": "{\n\tGList *idlist = NULL, *node = NULL;\n\n\tgtk_tree_selection_selected_foreach(\n\t\tgtk_tree_view_get_selection(list),\n\t\t(GtkTreeSelectionForeachFunc)queue_list_each_deltrack, &idlist );\n\n\tfor( node = idlist; node != NULL; node = node->next ){\n\t\tduc_cmd_queuedel( con, (gint)node->data );\n\t}\n\tg_list_free(idlist);\n\n}", "path": "gtk\\queue.c", "repo_name": "rclasen/dudlc", "stars": 0, "license": "other", "language": "c", "size": 404}
{"docstring": "/************************************************************\n * dudl interaction\n */\n", "func_signal": "static gboolean detail_update_idle( gpointer data )", "code": "{\n\tduc_track *cur;\n\tduc_it_track *tracks;\n\tduc_it_album *albums;\n\n\t(void)data;\n\n\tif( !needupdate )\n\t\treturn FALSE;\n\n\tif( NULL == (cur = duc_cmd_curtrack( con )) )\n\t\treturn FALSE;\n\n\tif( NULL != (tracks = duc_cmd_tracksalbum( con, cur->album->id ))){\n\t\tcurtracks_populate( tracks );\n\t\tduc_it_track_done( tracks );\n\t}\n\n\tif( NULL != (albums = duc_cmd_albumsartist( con, cur->artist->id ))){\n\t\tcuralbums_populate( albums );\n\t\tduc_it_album_done( albums );\n\t}\n\n\tduc_track_free(cur);\n\tneedupdate=0;\n\n\treturn FALSE;\n}", "path": "gtk\\main.c", "repo_name": "rclasen/dudlc", "stars": 0, "license": "other", "language": "c", "size": 404}
{"docstring": "/*\n * track := 'c'|<id>|<aid>/<pos>\n */\n", "func_signal": "int val_track( dudlc *con, char *in, char **end )", "code": "{\n\tint a;\n\tint b;\n\tchar *s, *e;\n\tduc_track *t;\n\n\tif( end ) *end = in;\n\n\tif( *in == 'c' ){\n\t\tif(NULL == (t = duc_cmd_curtrack(con))){\n\t\t\treturn -1;\n\t\t}\n\t\ta = t->id;\n\t\tduc_track_free(t);\n\n\t\tif( end ) (*end)++;\n\t\treturn a;\n\t}\n\n\ta = strtoul( in, &e, 10 );\n\tif( e == in )\n\t\treturn -1;\n\n\tif( *e != '/' ){\n\t\tif( end ) *end = e;\n\t\treturn a;\n\t}\n\n\ts = e + 1;\n\tb = strtoul( s, &e, 10 );\n\tif( e == s )\n\t\treturn -1;\n\n\tif( end ) *end = e;\n\treturn duc_cmd_track2id(con, a, b );\n}", "path": "cmd\\parseval.c", "repo_name": "rclasen/dudlc", "stars": 0, "license": "other", "language": "c", "size": 404}
{"docstring": "/************************************************************\n * dis-/connect\n */\n", "func_signal": "static void cb_disc( dudlc *c )", "code": "{\n\ttty_msg( \"disconnected, trying to reconnect\\n\");\n\tif( duc_open(c)){\n\t\ttty_msg( \"reconnect failed\\n\" );\n\t}\n}", "path": "cli\\events.c", "repo_name": "rclasen/dudlc", "stars": 0, "license": "other", "language": "c", "size": 404}
{"docstring": "/*\n * keypress\n */\n", "func_signal": "static gboolean queue_list_on_keypress(GtkTreeView *view, GdkEventKey *ev, gpointer data)", "code": "{\n\t(void) data;\n\n\t/* TODO: gtk_accelerator_get_default_mod_mask\n\t * http://library.gnome.org/devel/gtk/stable/checklist-modifiers.html */\n\tswitch( ev->keyval ){\n\t case GDK_Delete:\n\t\tif( ! (GDK_MODIFIER_MASK & ev->state) )\n\t\t\tqueue_list_select_deltrack( view );\n\t\tbreak;\n\n\t default: /* don't care */\n\t \tbreak;\n\t}\n\n\treturn FALSE;\n}", "path": "gtk\\queue.c", "repo_name": "rclasen/dudlc", "stars": 0, "license": "other", "language": "c", "size": 404}
{"docstring": "// also update arg_userlist help\n", "func_signal": "t_idlist *val_userlist( dudlc *con, char *in, char **end )", "code": "{\n\tt_idlist *idl;\n\n\tif( NULL == (idl = idl_new(NULL)))\n\t\treturn NULL;\n\n\tidl_addclist( idl, in, end, con, val_user );\n\n\treturn idl;\n}", "path": "cmd\\parseval.c", "repo_name": "rclasen/dudlc", "stars": 0, "license": "other", "language": "c", "size": 404}
{"docstring": "// TODO: better error-reporting than stderr!!!\n", "func_signal": "dudlc *duc_new( const char *hostname, int port )", "code": "{\n\tdudlc *p;\n\n\tif( NULL == (p = malloc(sizeof(dudlc))))\n\t\treturn NULL;\n\n\t*p->code = 0;\n\tp->line = NULL;\n\tp->inreply = 0;\n\tp->ev = NULL;\n\tp->user = NULL;\n\tp->pass = NULL;\n\tp->vminor = 0;\n\tp->vminor = 0;\n\n\tif( NULL == (p->con = duc_sock_open( hostname, port )))\n\t\tgoto clean1;\n\n\treturn p;\n\nclean1:\n\tfree(p);\n\treturn NULL;\n}", "path": "lib\\session.c", "repo_name": "rclasen/dudlc", "stars": 0, "license": "other", "language": "c", "size": 404}
{"docstring": "/*\n * tag := <tagname>|<id>\n */\n", "func_signal": "int val_tag( dudlc *con, char *in, char **end )", "code": "{\n\tint id;\n\tchar *e;\n\tchar tag[10];\n\tint len;\n\n\tif( end ) *end = in;\n\n\tid = strtoul( in, &e, 10 );\n\tif( in != e ){\n\t\tif( end ) *end = e;\n\t\treturn id;\n\t}\n\n\tlen = strcspn(in, \"\\t \");\n\tif( len >= 10  )\n\t\treturn -1;\n\n\te = in +len;\n\tstrncpy( tag, in, len );\n\ttag[len] = 0;\n\n\tif( 0 > ( id = duc_cmd_tag2id( con, tag ))){\n\t\treturn -1;\n\t}\n\n\tif( end ) *end = e;\n\treturn id;\n}", "path": "cmd\\parseval.c", "repo_name": "rclasen/dudlc", "stars": 0, "license": "other", "language": "c", "size": 404}
{"docstring": "/*\n * the list view\n */\n", "func_signal": "GtkWidget *queue_list_new( void )", "code": "{\n\tGtkTreeView *view;\n\tGtkTreeModel *store;\n\tGtkTreeViewColumn *col;\n\tGtkCellRenderer *renderer;\n\n\tview = GTK_TREE_VIEW(gtk_tree_view_new());\n\n\t/* store */\n\n\tstore = GTK_TREE_MODEL(gtk_list_store_new( QUEUELIST_N_COLUMNS,\n\t\tG_TYPE_INT,\t/* QUEUELIST_ID */\n\t\tG_TYPE_INT,\t/* QUEUELIST_USER_ID */\n\t\tG_TYPE_STRING,\t/* QUEUELIST_USER */\n\t\tG_TYPE_INT,\t/* QUEUELIST_QUEUED */\n\t\tG_TYPE_INT,\t/* QUEUELIST_ALBUM_ID */\n\t\tG_TYPE_INT,\t/* QUEUELIST_ALBUM_POS */\n\t\tG_TYPE_STRING,\t/* QUEUELIST_ALBUM */\n\t\tG_TYPE_INT,\t/* QUEUELIST_DURATION */\n\t\tG_TYPE_INT,\t/* QUEUELIST_ARTIST_ID */\n\t\tG_TYPE_STRING,\t/* QUEUELIST_ARTIST */\n\t\tG_TYPE_INT,\t/* QUEUELIST_TRACK_ID */\n\t\tG_TYPE_STRING\t/* QUEUELIST_TITLE */\n\t\t) );\n\n\tgtk_tree_sortable_set_sort_func( GTK_TREE_SORTABLE(store),\n\t\tQUEUELIST_ID, sortfunc_int, (gpointer)QUEUELIST_ID, NULL);\n\n\tgtk_tree_sortable_set_sort_func( GTK_TREE_SORTABLE(store),\n\t\tQUEUELIST_USER_ID, sortfunc_int, (gpointer)QUEUELIST_USER_ID, NULL);\n\n\tgtk_tree_sortable_set_sort_func( GTK_TREE_SORTABLE(store),\n\t\tQUEUELIST_USER, sortfunc_str, (gpointer)QUEUELIST_USER, NULL);\n\n\tgtk_tree_sortable_set_sort_func( GTK_TREE_SORTABLE(store),\n\t\tQUEUELIST_QUEUED, sortfunc_int, (gpointer)QUEUELIST_QUEUED, NULL);\n\n\tgtk_tree_sortable_set_sort_func( GTK_TREE_SORTABLE(store),\n\t\tQUEUELIST_ALBUM_ID, sortfunc_int, (gpointer)QUEUELIST_ALBUM_ID, NULL);\n\n\tgtk_tree_sortable_set_sort_func( GTK_TREE_SORTABLE(store),\n\t\tQUEUELIST_ALBUM_POS, sortfunc_albumpos, (gpointer)QUEUELIST_ALBUM_POS, NULL);\n\n\tgtk_tree_sortable_set_sort_func( GTK_TREE_SORTABLE(store),\n\t\tQUEUELIST_ALBUM, sortfunc_str, (gpointer)QUEUELIST_ALBUM, NULL);\n\n\tgtk_tree_sortable_set_sort_func( GTK_TREE_SORTABLE(store),\n\t\tQUEUELIST_DURATION, sortfunc_int, (gpointer)QUEUELIST_DURATION, NULL);\n\n\tgtk_tree_sortable_set_sort_func( GTK_TREE_SORTABLE(store),\n\t\tQUEUELIST_ARTIST_ID, sortfunc_int, (gpointer)QUEUELIST_ARTIST_ID, NULL);\n\n\tgtk_tree_sortable_set_sort_func( GTK_TREE_SORTABLE(store),\n\t\tQUEUELIST_ARTIST, sortfunc_str, (gpointer)QUEUELIST_ARTIST, NULL);\n\n\tgtk_tree_sortable_set_sort_func( GTK_TREE_SORTABLE(store),\n\t\tQUEUELIST_TRACK_ID, sortfunc_int, (gpointer)QUEUELIST_TRACK_ID, NULL);\n\n\tgtk_tree_sortable_set_sort_func( GTK_TREE_SORTABLE(store),\n\t\tQUEUELIST_TITLE, sortfunc_str, (gpointer)QUEUELIST_TITLE, NULL);\n\n\n\tgtk_tree_view_set_model( GTK_TREE_VIEW(view), GTK_TREE_MODEL(store) );\n\tg_object_unref(store);\n\n\n\t/* keyboard */\n\tg_signal_connect(view, \"key-press-event\",\n\t\t(GCallback)queue_list_on_keypress, NULL);\n\n\n\t/* columns */\n\n\trenderer = gtk_cell_renderer_text_new();\n\tcol = gtk_tree_view_column_new_with_attributes(\n\t\t\t\"Id\", renderer, \"text\", QUEUELIST_ID, NULL );\n\tg_object_set_data( G_OBJECT(col), \"columnum\", (gpointer)QUEUELIST_ID);\n\tg_signal_connect(col, \"clicked\", (GCallback)tree_view_column_on_clicked, view );\n\tgtk_tree_view_column_set_resizable( col, TRUE );\n\tgtk_tree_view_column_set_sort_column_id(col, QUEUELIST_ID);\n\tgtk_tree_view_append_column( view, col );\n\n\trenderer = gtk_cell_renderer_text_new();\n\tcol = gtk_tree_view_column_new_with_attributes(\n\t\t\t\"User\", renderer, \"text\", QUEUELIST_USER, NULL );\n\tg_object_set_data( G_OBJECT(col), \"columnum\", (gpointer)QUEUELIST_USER);\n\tg_signal_connect(col, \"clicked\", (GCallback)tree_view_column_on_clicked, view );\n\tgtk_tree_view_column_set_resizable( col, TRUE );\n\tgtk_tree_view_column_set_sort_column_id(col, QUEUELIST_USER);\n\tgtk_tree_view_append_column( view, col );\n\n\trenderer = gtk_cell_renderer_text_new();\n\tcol = gtk_tree_view_column_new();\n\tg_object_set_data( G_OBJECT(col), \"columnum\", (gpointer)QUEUELIST_QUEUED);\n\tg_signal_connect(col, \"clicked\", (GCallback)tree_view_column_on_clicked, view );\n\tgtk_tree_view_column_set_title( col, \"Queued\" );\n\tgtk_tree_view_column_pack_start( col, renderer, TRUE );\n\tgtk_tree_view_column_set_cell_data_func( col, renderer,\n\t\tcellfunc_time, (gpointer)QUEUELIST_QUEUED, NULL );\n\tgtk_tree_view_column_set_resizable( col, TRUE );\n\tgtk_tree_view_column_set_sort_column_id(col, QUEUELIST_QUEUED);\n\tgtk_tree_view_append_column( view, col );\n\n\trenderer = gtk_cell_renderer_text_new();\n\tcol = gtk_tree_view_column_new();\n\tg_object_set_data( G_OBJECT(col), \"columnum\", (gpointer)QUEUELIST_ALBUM_POS);\n\tg_signal_connect(col, \"clicked\", (GCallback)tree_view_column_on_clicked, view );\n\tgtk_tree_view_column_set_title( col, \"TrackId\" );\n\tgtk_tree_view_column_pack_start( col, renderer, TRUE );\n\tgtk_tree_view_column_set_cell_data_func( col, renderer,\n\t\tcellfunc_trackid, (gpointer)QUEUELIST_ALBUM_POS, NULL );\n\tgtk_tree_view_column_set_resizable( col, TRUE );\n\tgtk_tree_view_column_set_sort_column_id(col, QUEUELIST_ALBUM_POS);\n\tgtk_tree_view_append_column( view, col );\n\n\trenderer = gtk_cell_renderer_text_new();\n\tcol = gtk_tree_view_column_new();\n\tg_object_set_data( G_OBJECT(col), \"columnum\", (gpointer)QUEUELIST_DURATION);\n\tg_signal_connect(col, \"clicked\", (GCallback)tree_view_column_on_clicked, view );\n\tgtk_tree_view_column_set_title( col, \"Duration\" );\n\tgtk_tree_view_column_pack_start( col, renderer, TRUE );\n\tgtk_tree_view_column_set_cell_data_func( col, renderer,\n\t\tcellfunc_duration, (gpointer)QUEUELIST_DURATION, NULL );\n\tgtk_tree_view_column_set_resizable( col, TRUE );\n\tgtk_tree_view_column_set_sort_column_id(col, QUEUELIST_DURATION);\n\tgtk_tree_view_append_column( view, col );\n\n\trenderer = gtk_cell_renderer_text_new();\n\tcol = gtk_tree_view_column_new_with_attributes(\n\t\t\t\"Artist\", renderer, \"text\", QUEUELIST_ARTIST, NULL );\n\tg_object_set_data( G_OBJECT(col), \"columnum\", (gpointer)QUEUELIST_ARTIST);\n\tg_signal_connect(col, \"clicked\", (GCallback)tree_view_column_on_clicked, view );\n\tgtk_tree_view_column_set_resizable( col, TRUE );\n\tgtk_tree_view_column_set_sort_column_id(col, QUEUELIST_ARTIST);\n\tgtk_tree_view_append_column( view, col );\n\n\trenderer = gtk_cell_renderer_text_new();\n\tcol = gtk_tree_view_column_new_with_attributes(\n\t\t\t\"Album\", renderer, \"text\", QUEUELIST_ALBUM, NULL );\n\tg_object_set_data( G_OBJECT(col), \"columnum\", (gpointer)QUEUELIST_ALBUM);\n\tg_signal_connect(col, \"clicked\", (GCallback)tree_view_column_on_clicked, view );\n\tgtk_tree_view_column_set_resizable( col, TRUE );\n\tgtk_tree_view_column_set_sort_column_id(col, QUEUELIST_ALBUM);\n\tgtk_tree_view_append_column( view, col );\n\n\trenderer = gtk_cell_renderer_text_new();\n\tcol = gtk_tree_view_column_new_with_attributes(\n\t\t\t\"Title\", renderer, \"text\", QUEUELIST_TITLE, NULL );\n\tg_object_set_data( G_OBJECT(col), \"columnum\", (gpointer)QUEUELIST_TITLE);\n\tg_signal_connect(col, \"clicked\", (GCallback)tree_view_column_on_clicked, view );\n\tgtk_tree_view_column_set_resizable( col, TRUE );\n\tgtk_tree_view_column_set_sort_column_id(col, QUEUELIST_TITLE);\n\tgtk_tree_view_append_column( view, col );\n\n\t/* TODO: add column with tags of track */\n\n\tgtk_tree_view_set_search_column( GTK_TREE_VIEW(view), QUEUELIST_ID );\n\tgtk_widget_show(GTK_WIDGET(view));\n\n\treturn GTK_WIDGET(view);\n}", "path": "gtk\\queue.c", "repo_name": "rclasen/dudlc", "stars": 0, "license": "other", "language": "c", "size": 404}
{"docstring": "/*\n * helper for selection processing\n */\n", "func_signal": "static void queue_list_each_deltrack(\n\tGtkTreeModel\t*model,\n\tGtkTreePath\t*path,\n\tGtkTreeIter\t*iter,\n\tGList\t\t**idlist)", "code": "{\n\tgint queueid;\n\n\t(void)path;\n\tgtk_tree_model_get (model, iter, QUEUELIST_ID, &queueid, -1);\n\t*idlist = g_list_append(*idlist, (gpointer)queueid );\n}", "path": "gtk\\queue.c", "repo_name": "rclasen/dudlc", "stars": 0, "license": "other", "language": "c", "size": 404}
{"docstring": "/*proto*/\n", "func_signal": "static INLINE PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j)", "code": "{\n    PyObject *r;\n    if (!j) return NULL;\n    r = PyObject_GetItem(o, j);\n    Py_DECREF(j);\n    return r;\n}", "path": "src\\ctotable.c", "repo_name": "brentp/totable", "stars": 1, "license": "None", "language": "c", "size": 220}
{"docstring": "/*proto*/\n", "func_signal": "static PyObject *__pyx_pf_8ctotable_3Col___invert__(PyObject *__pyx_v_self)", "code": "{\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannySetupContext(\"__invert__\");\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":513\n *     def __invert__(self):\n *         # ~Col('age') == 180\n *         self.invert = not self.invert             # <<<<<<<<<<<<<<\n *         return self\n * \n */\n  ((struct __pyx_obj_8ctotable_Col *)__pyx_v_self)->invert = (!((struct __pyx_obj_8ctotable_Col *)__pyx_v_self)->invert);\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":514\n *         # ~Col('age') == 180\n *         self.invert = not self.invert\n *         return self             # <<<<<<<<<<<<<<\n * \n *     def matches(self, pattern):\n */\n  __Pyx_XDECREF(__pyx_r);\n  __Pyx_INCREF(__pyx_v_self);\n  __pyx_r = __pyx_v_self;\n  goto __pyx_L0;\n\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}", "path": "src\\ctotable.c", "repo_name": "brentp/totable", "stars": 1, "license": "None", "language": "c", "size": 220}
{"docstring": "/*proto*/\n", "func_signal": "static INLINE PyObject* __Pyx_PyObject_Append(PyObject* L, PyObject* x)", "code": "{\n    if (likely(PyList_CheckExact(L))) {\n        if (PyList_Append(L, x) < 0) return NULL;\n        Py_INCREF(Py_None);\n        return Py_None; /* this is just to have an accurate signature */\n    }\n    else {\n        PyObject *r, *m;\n        m = __Pyx_GetAttrString(L, \"append\");\n        if (!m) return NULL;\n        r = PyObject_CallFunctionObjArgs(m, x, NULL);\n        Py_DECREF(m);\n        return r;\n    }\n}", "path": "src\\ctotable.c", "repo_name": "brentp/totable", "stars": 1, "license": "None", "language": "c", "size": 220}
{"docstring": "/* \"/usr/local/src/totable/src/ctotable.pyx\":271\n *         return self._put_keep_code(success, k)\n * \n *     cdef _put_keep_code(self, bint success, key):             # <<<<<<<<<<<<<<\n *         cdef int errorcode\n *         if not success:\n */\n", "func_signal": "static  PyObject *__pyx_f_8ctotable_7ToTable__put_keep_code(struct __pyx_obj_8ctotable_ToTable *__pyx_v_self, int __pyx_v_success, PyObject *__pyx_v_key)", "code": "{\n  int __pyx_v_errorcode;\n  PyObject *__pyx_r = NULL;\n  int __pyx_t_1;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  PyObject *__pyx_t_4 = NULL;\n  PyObject *__pyx_t_5 = NULL;\n  __Pyx_RefNannySetupContext(\"_put_keep_code\");\n  __Pyx_INCREF((PyObject *)__pyx_v_self);\n  __Pyx_INCREF(__pyx_v_key);\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":273\n *     cdef _put_keep_code(self, bint success, key):\n *         cdef int errorcode\n *         if not success:             # <<<<<<<<<<<<<<\n *             errorcode = tctdbecode(self._state)\n *             if errorcode == 21: # 'existing record'\n */\n  __pyx_t_1 = (!__pyx_v_success);\n  if (__pyx_t_1) {\n\n    /* \"/usr/local/src/totable/src/ctotable.pyx\":274\n *         cdef int errorcode\n *         if not success:\n *             errorcode = tctdbecode(self._state)             # <<<<<<<<<<<<<<\n *             if errorcode == 21: # 'existing record'\n *                 return 'keep'\n */\n    __pyx_v_errorcode = tctdbecode(__pyx_v_self->_state);\n\n    /* \"/usr/local/src/totable/src/ctotable.pyx\":275\n *         if not success:\n *             errorcode = tctdbecode(self._state)\n *             if errorcode == 21: # 'existing record'             # <<<<<<<<<<<<<<\n *                 return 'keep'\n *             else:\n */\n    __pyx_t_1 = (__pyx_v_errorcode == 21);\n    if (__pyx_t_1) {\n\n      /* \"/usr/local/src/totable/src/ctotable.pyx\":276\n *             errorcode = tctdbecode(self._state)\n *             if errorcode == 21: # 'existing record'\n *                 return 'keep'             # <<<<<<<<<<<<<<\n *             else:\n *                 self._throw('Unable to write key \"{0}\".'.format(key))\n */\n      __Pyx_XDECREF(__pyx_r);\n      __Pyx_INCREF(((PyObject *)__pyx_n_s__keep));\n      __pyx_r = ((PyObject *)__pyx_n_s__keep);\n      goto __pyx_L0;\n      goto __pyx_L4;\n    }\n    /*else*/ {\n\n      /* \"/usr/local/src/totable/src/ctotable.pyx\":278\n *                 return 'keep'\n *             else:\n *                 self._throw('Unable to write key \"{0}\".'.format(key))             # <<<<<<<<<<<<<<\n *         return 'put'\n * \n */\n      __pyx_t_2 = PyObject_GetAttr(((PyObject *)__pyx_v_self), __pyx_n_s___throw); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 278; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_2);\n      __pyx_t_3 = PyObject_GetAttr(((PyObject *)__pyx_kp_s_17), __pyx_n_s__format); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 278; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_3);\n      __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 278; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_4);\n      __Pyx_INCREF(__pyx_v_key);\n      PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_v_key);\n      __Pyx_GIVEREF(__pyx_v_key);\n      __pyx_t_5 = PyObject_Call(__pyx_t_3, __pyx_t_4, NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 278; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_5);\n      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n      __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 278; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_4);\n      PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_5);\n      __Pyx_GIVEREF(__pyx_t_5);\n      __pyx_t_5 = 0;\n      __pyx_t_5 = PyObject_Call(__pyx_t_2, __pyx_t_4, NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 278; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_5);\n      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;\n    }\n    __pyx_L4:;\n    goto __pyx_L3;\n  }\n  __pyx_L3:;\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":279\n *             else:\n *                 self._throw('Unable to write key \"{0}\".'.format(key))\n *         return 'put'             # <<<<<<<<<<<<<<\n * \n *     def setdefault(self, k, d):\n */\n  __Pyx_XDECREF(__pyx_r);\n  __Pyx_INCREF(((PyObject *)__pyx_n_s__put));\n  __pyx_r = ((PyObject *)__pyx_n_s__put);\n  goto __pyx_L0;\n\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_XDECREF(__pyx_t_4);\n  __Pyx_XDECREF(__pyx_t_5);\n  __Pyx_AddTraceback(\"ctotable.ToTable._put_keep_code\");\n  __pyx_r = 0;\n  __pyx_L0:;\n  __Pyx_DECREF((PyObject *)__pyx_v_self);\n  __Pyx_DECREF(__pyx_v_key);\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}", "path": "src\\ctotable.c", "repo_name": "brentp/totable", "stars": 1, "license": "None", "language": "c", "size": 220}
{"docstring": "/*proto*/\n", "func_signal": "static  PyObject *__pyx_f_8ctotable_7ToTable__msg(struct __pyx_obj_8ctotable_ToTable *__pyx_v_self, int __pyx_skip_dispatch)", "code": "{\n  int __pyx_v_errorcode;\n  PyObject *__pyx_r = NULL;\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  __Pyx_RefNannySetupContext(\"_msg\");\n  /* Check if called by wrapper */\n  if (unlikely(__pyx_skip_dispatch)) ;\n  /* Check if overriden in Python */\n  else if (unlikely(Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0)) {\n    __pyx_t_1 = PyObject_GetAttr(((PyObject *)__pyx_v_self), __pyx_n_s___msg); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 57; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    __Pyx_GOTREF(__pyx_t_1);\n    if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (void *)&__pyx_pf_8ctotable_7ToTable__msg)) {\n      __Pyx_XDECREF(__pyx_r);\n      __pyx_t_2 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_empty_tuple), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 57; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_2);\n      __pyx_r = __pyx_t_2;\n      __pyx_t_2 = 0;\n      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n      goto __pyx_L0;\n    }\n    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  }\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":61\n *         of *message* the last error message from the table database.\n *         '''\n *         cdef int errorcode = tctdbecode(self._state)             # <<<<<<<<<<<<<<\n *         return tctdberrmsg(errorcode)\n * \n */\n  __pyx_v_errorcode = tctdbecode(__pyx_v_self->_state);\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":62\n *         '''\n *         cdef int errorcode = tctdbecode(self._state)\n *         return tctdberrmsg(errorcode)             # <<<<<<<<<<<<<<\n * \n * \n */\n  __Pyx_XDECREF(__pyx_r);\n  __pyx_t_1 = __Pyx_PyBytes_FromString(tctdberrmsg(__pyx_v_errorcode)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 62; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_r = __pyx_t_1;\n  __pyx_t_1 = 0;\n  goto __pyx_L0;\n\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_AddTraceback(\"ctotable.ToTable._msg\");\n  __pyx_r = 0;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}", "path": "src\\ctotable.c", "repo_name": "brentp/totable", "stars": 1, "license": "None", "language": "c", "size": 220}
{"docstring": "/* Type Conversion Functions */\n", "func_signal": "static INLINE int __Pyx_PyObject_IsTrue(PyObject* x)", "code": "{\n   if (x == Py_True) return 1;\n   else if ((x == Py_False) | (x == Py_None)) return 0;\n   else return PyObject_IsTrue(x);\n}", "path": "src\\ctotable.c", "repo_name": "brentp/totable", "stars": 1, "license": "None", "language": "c", "size": 220}
{"docstring": "/* \"/usr/local/src/totable/src/ctotable.pyx\":127\n *             self._state = NULL\n * \n *     cdef TCMAP* _dict_to_tcmap(self, dict d):             # <<<<<<<<<<<<<<\n *         \"\"\"INTERNAL: take a dict and return the tcmap which must\n *         be deleted with tcmapdel(tcmap)\n */\n", "func_signal": "static  TCMAP *__pyx_f_8ctotable_7ToTable__dict_to_tcmap(struct __pyx_obj_8ctotable_ToTable *__pyx_v_self, PyObject *__pyx_v_d)", "code": "{\n  char *__pyx_v_kbuf;\n  char *__pyx_v_vbuf;\n  Py_ssize_t __pyx_v_ksiz;\n  Py_ssize_t __pyx_v_vsiz;\n  TCMAP *__pyx_v_tcmap;\n  int __pyx_v_ld;\n  PyObject *__pyx_v_key;\n  PyObject *__pyx_v_val;\n  TCMAP *__pyx_r;\n  Py_ssize_t __pyx_t_1;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  PyObject *__pyx_t_4 = NULL;\n  PyObject *__pyx_t_5 = NULL;\n  PyObject *__pyx_t_6 = NULL;\n  int __pyx_t_7;\n  __Pyx_RefNannySetupContext(\"_dict_to_tcmap\");\n  __Pyx_INCREF((PyObject *)__pyx_v_self);\n  __Pyx_INCREF(__pyx_v_d);\n  __pyx_v_key = Py_None; __Pyx_INCREF(Py_None);\n  __pyx_v_val = Py_None; __Pyx_INCREF(Py_None);\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":134\n *         cdef Py_ssize_t ksiz, vsiz\n *         cdef TCMAP *tcmap\n *         cdef int ld = len(d)             # <<<<<<<<<<<<<<\n *         tcmap = tcmapnew2(ld)\n * \n */\n  __pyx_t_1 = PyObject_Length(((PyObject *)__pyx_v_d)); if (unlikely(__pyx_t_1 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 134; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __pyx_v_ld = __pyx_t_1;\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":135\n *         cdef TCMAP *tcmap\n *         cdef int ld = len(d)\n *         tcmap = tcmapnew2(ld)             # <<<<<<<<<<<<<<\n * \n *         for key, val in d.items():\n */\n  __pyx_v_tcmap = tcmapnew2(__pyx_v_ld);\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":137\n *         tcmap = tcmapnew2(ld)\n * \n *         for key, val in d.items():             # <<<<<<<<<<<<<<\n *             ps.PyString_AsStringAndSize(key, &kbuf, &ksiz)\n *             ps.PyString_AsStringAndSize(val, &vbuf, &vsiz)\n */\n  __pyx_t_2 = PyDict_Items(((PyObject *)__pyx_v_d)); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 137; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_GOTREF(__pyx_t_2);\n  if (PyList_CheckExact(__pyx_t_2) || PyTuple_CheckExact(__pyx_t_2)) {\n    __pyx_t_1 = 0; __pyx_t_3 = __pyx_t_2; __Pyx_INCREF(__pyx_t_3);\n  } else {\n    __pyx_t_1 = -1; __pyx_t_3 = PyObject_GetIter(__pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 137; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    __Pyx_GOTREF(__pyx_t_3);\n  }\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n  for (;;) {\n    if (likely(PyList_CheckExact(__pyx_t_3))) {\n      if (__pyx_t_1 >= PyList_GET_SIZE(__pyx_t_3)) break;\n      __pyx_t_2 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_1); __Pyx_INCREF(__pyx_t_2); __pyx_t_1++;\n    } else if (likely(PyTuple_CheckExact(__pyx_t_3))) {\n      if (__pyx_t_1 >= PyTuple_GET_SIZE(__pyx_t_3)) break;\n      __pyx_t_2 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_1); __Pyx_INCREF(__pyx_t_2); __pyx_t_1++;\n    } else {\n      __pyx_t_2 = PyIter_Next(__pyx_t_3);\n      if (!__pyx_t_2) {\n        if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 137; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n        break;\n      }\n      __Pyx_GOTREF(__pyx_t_2);\n    }\n    if (PyTuple_CheckExact(__pyx_t_2) && likely(PyTuple_GET_SIZE(__pyx_t_2) == 2)) {\n      PyObject* tuple = __pyx_t_2;\n      __pyx_t_4 = PyTuple_GET_ITEM(tuple, 0); __Pyx_INCREF(__pyx_t_4);\n      __pyx_t_5 = PyTuple_GET_ITEM(tuple, 1); __Pyx_INCREF(__pyx_t_5);\n      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n      __Pyx_DECREF(__pyx_v_key);\n      __pyx_v_key = __pyx_t_4;\n      __pyx_t_4 = 0;\n      __Pyx_DECREF(__pyx_v_val);\n      __pyx_v_val = __pyx_t_5;\n      __pyx_t_5 = 0;\n    } else {\n      __pyx_t_6 = PyObject_GetIter(__pyx_t_2); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 137; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_6);\n      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n      __pyx_t_4 = __Pyx_UnpackItem(__pyx_t_6, 0); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 137; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_4);\n      __pyx_t_5 = __Pyx_UnpackItem(__pyx_t_6, 1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 137; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_5);\n      if (__Pyx_EndUnpack(__pyx_t_6) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 137; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;\n      __Pyx_DECREF(__pyx_v_key);\n      __pyx_v_key = __pyx_t_4;\n      __pyx_t_4 = 0;\n      __Pyx_DECREF(__pyx_v_val);\n      __pyx_v_val = __pyx_t_5;\n      __pyx_t_5 = 0;\n    }\n\n    /* \"/usr/local/src/totable/src/ctotable.pyx\":138\n * \n *         for key, val in d.items():\n *             ps.PyString_AsStringAndSize(key, &kbuf, &ksiz)             # <<<<<<<<<<<<<<\n *             ps.PyString_AsStringAndSize(val, &vbuf, &vsiz)\n *             tcmapput(tcmap, kbuf, ksiz, vbuf, vsiz)\n */\n    __pyx_t_7 = PyString_AsStringAndSize(__pyx_v_key, (&__pyx_v_kbuf), (&__pyx_v_ksiz)); if (unlikely(__pyx_t_7 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 138; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n\n    /* \"/usr/local/src/totable/src/ctotable.pyx\":139\n *         for key, val in d.items():\n *             ps.PyString_AsStringAndSize(key, &kbuf, &ksiz)\n *             ps.PyString_AsStringAndSize(val, &vbuf, &vsiz)             # <<<<<<<<<<<<<<\n *             tcmapput(tcmap, kbuf, ksiz, vbuf, vsiz)\n *         return tcmap\n */\n    __pyx_t_7 = PyString_AsStringAndSize(__pyx_v_val, (&__pyx_v_vbuf), (&__pyx_v_vsiz)); if (unlikely(__pyx_t_7 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 139; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n\n    /* \"/usr/local/src/totable/src/ctotable.pyx\":140\n *             ps.PyString_AsStringAndSize(key, &kbuf, &ksiz)\n *             ps.PyString_AsStringAndSize(val, &vbuf, &vsiz)\n *             tcmapput(tcmap, kbuf, ksiz, vbuf, vsiz)             # <<<<<<<<<<<<<<\n *         return tcmap\n * \n */\n    tcmapput(__pyx_v_tcmap, __pyx_v_kbuf, __pyx_v_ksiz, __pyx_v_vbuf, __pyx_v_vsiz);\n  }\n  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":141\n *             ps.PyString_AsStringAndSize(val, &vbuf, &vsiz)\n *             tcmapput(tcmap, kbuf, ksiz, vbuf, vsiz)\n *         return tcmap             # <<<<<<<<<<<<<<\n * \n *     def optimize_index(self, colname):\n */\n  __pyx_r = __pyx_v_tcmap;\n  goto __pyx_L0;\n\n  __pyx_r = 0;\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_XDECREF(__pyx_t_4);\n  __Pyx_XDECREF(__pyx_t_5);\n  __Pyx_XDECREF(__pyx_t_6);\n  __Pyx_WriteUnraisable(\"ctotable.ToTable._dict_to_tcmap\");\n  __pyx_r = 0;\n  __pyx_L0:;\n  __Pyx_DECREF(__pyx_v_key);\n  __Pyx_DECREF(__pyx_v_val);\n  __Pyx_DECREF((PyObject *)__pyx_v_self);\n  __Pyx_DECREF(__pyx_v_d);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}", "path": "src\\ctotable.c", "repo_name": "brentp/totable", "stars": 1, "license": "None", "language": "c", "size": 220}
{"docstring": "/*proto*/\n", "func_signal": "static PyObject *__pyx_pf_8ctotable_7ToTable_select(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds)", "code": "{\n  int __pyx_v_values_only;\n  PyObject *__pyx_v_args = 0;\n  PyObject *__pyx_v_kwargs = 0;\n  struct __pyx_obj_8ctotable_TCQuery *__pyx_v_q = 0;\n  TCLIST *__pyx_v_tclist;\n  PyObject *__pyx_v_li = 0;\n  int __pyx_v_count;\n  PyObject *__pyx_v_kwskip;\n  PyObject *__pyx_v_colname;\n  PyObject *__pyx_v_other;\n  PyObject *__pyx_v_col;\n  PyObject *__pyx_r = NULL;\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  Py_ssize_t __pyx_t_3;\n  PyObject *__pyx_t_4 = NULL;\n  PyObject *__pyx_t_5 = NULL;\n  PyObject *__pyx_t_6 = NULL;\n  int __pyx_t_7;\n  char *__pyx_t_8;\n  int __pyx_t_9;\n  char *__pyx_t_10;\n  static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__values_only,0};\n  __Pyx_RefNannySetupContext(\"select\");\n  __pyx_v_kwargs = PyDict_New(); if (unlikely(!__pyx_v_kwargs)) return NULL;\n  __Pyx_GOTREF(__pyx_v_kwargs);\n  if (PyTuple_GET_SIZE(__pyx_args) > 0) {\n    __pyx_v_args = PyTuple_GetSlice(__pyx_args, 0, PyTuple_GET_SIZE(__pyx_args)); __Pyx_GOTREF(__pyx_v_args);\n\n    if (unlikely(!__pyx_v_args)) {\n      __Pyx_DECREF(__pyx_v_kwargs);\n      return NULL;\n    }\n  } else {\n    __pyx_v_args = __pyx_empty_tuple; __Pyx_INCREF(__pyx_empty_tuple);\n  }\n  if (unlikely(__pyx_kwds)) {\n    Py_ssize_t kw_args = PyDict_Size(__pyx_kwds);\n    PyObject* values[1] = {0};\n    switch (PyTuple_GET_SIZE(__pyx_args)) {\n      default:\n      case  0: break;\n    }\n    if (unlikely(kw_args > 0)) {\n      if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, __pyx_v_kwargs, values, 0, \"select\") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 393; __pyx_clineno = __LINE__; goto __pyx_L3_error;}\n    }\n    if (values[0]) {\n      __pyx_v_values_only = __Pyx_PyObject_IsTrue(values[0]); if (unlikely((__pyx_v_values_only == (int)-1))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 393; __pyx_clineno = __LINE__; goto __pyx_L3_error;}\n    } else {\n      __pyx_v_values_only = ((int)0);\n    }\n  } else if (PyTuple_GET_SIZE(__pyx_args) < 0) {\n    goto __pyx_L5_argtuple_error;\n  } else {\n    __pyx_v_values_only = ((int)0);\n  }\n  goto __pyx_L4_argument_unpacking_done;\n  __pyx_L5_argtuple_error:;\n  __Pyx_RaiseArgtupleInvalid(\"select\", 0, 0, 0, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 393; __pyx_clineno = __LINE__; goto __pyx_L3_error;}\n  __pyx_L3_error:;\n  __Pyx_DECREF(__pyx_v_args);\n  __Pyx_DECREF(__pyx_v_kwargs);\n  __Pyx_AddTraceback(\"ctotable.ToTable.select\");\n  return NULL;\n  __pyx_L4_argument_unpacking_done:;\n  __Pyx_INCREF((PyObject *)__pyx_v_self);\n  __pyx_v_kwskip = Py_None; __Pyx_INCREF(Py_None);\n  __pyx_v_colname = Py_None; __Pyx_INCREF(Py_None);\n  __pyx_v_other = Py_None; __Pyx_INCREF(Py_None);\n  __pyx_v_col = Py_None; __Pyx_INCREF(Py_None);\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":397\n *         # not allowed in python 2.XX\n * \n *         cdef TCQuery q = make_query(self._state)             # <<<<<<<<<<<<<<\n *         #cdef TDBQRY* query_state = tctdbqrynew(self._state)\n *         cdef TCLIST *tclist\n */\n  __pyx_t_1 = ((PyObject *)__pyx_f_8ctotable_make_query(((struct __pyx_obj_8ctotable_ToTable *)__pyx_v_self)->_state)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 397; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_v_q = ((struct __pyx_obj_8ctotable_TCQuery *)__pyx_t_1);\n  __pyx_t_1 = 0;\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":400\n *         #cdef TDBQRY* query_state = tctdbqrynew(self._state)\n *         cdef TCLIST *tclist\n *         cdef list li = []             # <<<<<<<<<<<<<<\n *         cdef int count\n * \n */\n  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 400; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_GOTREF(((PyObject *)__pyx_t_1));\n  __pyx_v_li = __pyx_t_1;\n  __pyx_t_1 = 0;\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":403\n *         cdef int count\n * \n *         kwskip = ('delete', 'order', 'count', 'limit', 'offset', 'values_only', 'callback')             # <<<<<<<<<<<<<<\n * \n *         # tbl.select(name='fred', age=22)\n */\n  __pyx_t_1 = PyTuple_New(7); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 403; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_INCREF(((PyObject *)__pyx_n_s__delete));\n  PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)__pyx_n_s__delete));\n  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__delete));\n  __Pyx_INCREF(((PyObject *)__pyx_n_s__order));\n  PyTuple_SET_ITEM(__pyx_t_1, 1, ((PyObject *)__pyx_n_s__order));\n  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__order));\n  __Pyx_INCREF(((PyObject *)__pyx_n_s__count));\n  PyTuple_SET_ITEM(__pyx_t_1, 2, ((PyObject *)__pyx_n_s__count));\n  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__count));\n  __Pyx_INCREF(((PyObject *)__pyx_n_s__limit));\n  PyTuple_SET_ITEM(__pyx_t_1, 3, ((PyObject *)__pyx_n_s__limit));\n  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__limit));\n  __Pyx_INCREF(((PyObject *)__pyx_n_s__offset));\n  PyTuple_SET_ITEM(__pyx_t_1, 4, ((PyObject *)__pyx_n_s__offset));\n  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__offset));\n  __Pyx_INCREF(((PyObject *)__pyx_n_s__values_only));\n  PyTuple_SET_ITEM(__pyx_t_1, 5, ((PyObject *)__pyx_n_s__values_only));\n  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__values_only));\n  __Pyx_INCREF(((PyObject *)__pyx_n_s__callback));\n  PyTuple_SET_ITEM(__pyx_t_1, 6, ((PyObject *)__pyx_n_s__callback));\n  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__callback));\n  __Pyx_DECREF(__pyx_v_kwskip);\n  __pyx_v_kwskip = __pyx_t_1;\n  __pyx_t_1 = 0;\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":407\n *         # tbl.select(name='fred', age=22)\n *         # convert age=22 to Col('age') == 22\n *         args = list(args)             # <<<<<<<<<<<<<<\n *         for colname, other in kwargs.items():\n *             if colname in kwskip: continue\n */\n  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 407; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_INCREF(__pyx_v_args);\n  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_args);\n  __Pyx_GIVEREF(__pyx_v_args);\n  __pyx_t_2 = PyObject_Call(((PyObject *)((PyObject*)&PyList_Type)), __pyx_t_1, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 407; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_GOTREF(__pyx_t_2);\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __Pyx_DECREF(__pyx_v_args);\n  __pyx_v_args = __pyx_t_2;\n  __pyx_t_2 = 0;\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":408\n *         # convert age=22 to Col('age') == 22\n *         args = list(args)\n *         for colname, other in kwargs.items():             # <<<<<<<<<<<<<<\n *             if colname in kwskip: continue\n *             args.append(Col(colname) == other)\n */\n  __pyx_t_2 = PyObject_GetAttr(__pyx_v_kwargs, __pyx_n_s__items); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 408; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_GOTREF(__pyx_t_2);\n  __pyx_t_1 = PyObject_Call(__pyx_t_2, ((PyObject *)__pyx_empty_tuple), NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 408; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n  if (PyList_CheckExact(__pyx_t_1) || PyTuple_CheckExact(__pyx_t_1)) {\n    __pyx_t_3 = 0; __pyx_t_2 = __pyx_t_1; __Pyx_INCREF(__pyx_t_2);\n  } else {\n    __pyx_t_3 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 408; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    __Pyx_GOTREF(__pyx_t_2);\n  }\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  for (;;) {\n    if (likely(PyList_CheckExact(__pyx_t_2))) {\n      if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_2)) break;\n      __pyx_t_1 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_1); __pyx_t_3++;\n    } else if (likely(PyTuple_CheckExact(__pyx_t_2))) {\n      if (__pyx_t_3 >= PyTuple_GET_SIZE(__pyx_t_2)) break;\n      __pyx_t_1 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_1); __pyx_t_3++;\n    } else {\n      __pyx_t_1 = PyIter_Next(__pyx_t_2);\n      if (!__pyx_t_1) {\n        if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 408; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n        break;\n      }\n      __Pyx_GOTREF(__pyx_t_1);\n    }\n    if (PyTuple_CheckExact(__pyx_t_1) && likely(PyTuple_GET_SIZE(__pyx_t_1) == 2)) {\n      PyObject* tuple = __pyx_t_1;\n      __pyx_t_4 = PyTuple_GET_ITEM(tuple, 0); __Pyx_INCREF(__pyx_t_4);\n      __pyx_t_5 = PyTuple_GET_ITEM(tuple, 1); __Pyx_INCREF(__pyx_t_5);\n      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n      __Pyx_DECREF(__pyx_v_colname);\n      __pyx_v_colname = __pyx_t_4;\n      __pyx_t_4 = 0;\n      __Pyx_DECREF(__pyx_v_other);\n      __pyx_v_other = __pyx_t_5;\n      __pyx_t_5 = 0;\n    } else {\n      __pyx_t_6 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 408; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_6);\n      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n      __pyx_t_4 = __Pyx_UnpackItem(__pyx_t_6, 0); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 408; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_4);\n      __pyx_t_5 = __Pyx_UnpackItem(__pyx_t_6, 1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 408; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_5);\n      if (__Pyx_EndUnpack(__pyx_t_6) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 408; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;\n      __Pyx_DECREF(__pyx_v_colname);\n      __pyx_v_colname = __pyx_t_4;\n      __pyx_t_4 = 0;\n      __Pyx_DECREF(__pyx_v_other);\n      __pyx_v_other = __pyx_t_5;\n      __pyx_t_5 = 0;\n    }\n\n    /* \"/usr/local/src/totable/src/ctotable.pyx\":409\n *         args = list(args)\n *         for colname, other in kwargs.items():\n *             if colname in kwskip: continue             # <<<<<<<<<<<<<<\n *             args.append(Col(colname) == other)\n * \n */\n    __pyx_t_7 = ((PySequence_Contains(__pyx_v_kwskip, __pyx_v_colname))); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 409; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    if (__pyx_t_7) {\n      goto __pyx_L6_continue;\n      goto __pyx_L8;\n    }\n    __pyx_L8:;\n\n    /* \"/usr/local/src/totable/src/ctotable.pyx\":410\n *         for colname, other in kwargs.items():\n *             if colname in kwskip: continue\n *             args.append(Col(colname) == other)             # <<<<<<<<<<<<<<\n * \n *         for col in args:\n */\n    __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 410; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    __Pyx_GOTREF(__pyx_t_1);\n    __Pyx_INCREF(__pyx_v_colname);\n    PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_colname);\n    __Pyx_GIVEREF(__pyx_v_colname);\n    __pyx_t_5 = PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_8ctotable_Col)), __pyx_t_1, NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 410; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    __Pyx_GOTREF(__pyx_t_5);\n    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n    __pyx_t_1 = PyObject_RichCompare(__pyx_t_5, __pyx_v_other, Py_EQ); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 410; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    __Pyx_GOTREF(__pyx_t_1);\n    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;\n    __pyx_t_5 = __Pyx_PyObject_Append(__pyx_v_args, __pyx_t_1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 410; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    __Pyx_GOTREF(__pyx_t_5);\n    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;\n    __pyx_L6_continue:;\n  }\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":412\n *             args.append(Col(colname) == other)\n * \n *         for col in args:             # <<<<<<<<<<<<<<\n *             # separate these out rather than |'ing here because\n *             # they may reuse the Col object.\n */\n  if (PyList_CheckExact(__pyx_v_args) || PyTuple_CheckExact(__pyx_v_args)) {\n    __pyx_t_3 = 0; __pyx_t_2 = __pyx_v_args; __Pyx_INCREF(__pyx_t_2);\n  } else {\n    __pyx_t_3 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_v_args); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 412; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    __Pyx_GOTREF(__pyx_t_2);\n  }\n  for (;;) {\n    if (likely(PyList_CheckExact(__pyx_t_2))) {\n      if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_2)) break;\n      __pyx_t_5 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++;\n    } else if (likely(PyTuple_CheckExact(__pyx_t_2))) {\n      if (__pyx_t_3 >= PyTuple_GET_SIZE(__pyx_t_2)) break;\n      __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++;\n    } else {\n      __pyx_t_5 = PyIter_Next(__pyx_t_2);\n      if (!__pyx_t_5) {\n        if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 412; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n        break;\n      }\n      __Pyx_GOTREF(__pyx_t_5);\n    }\n    __Pyx_DECREF(__pyx_v_col);\n    __pyx_v_col = __pyx_t_5;\n    __pyx_t_5 = 0;\n\n    /* \"/usr/local/src/totable/src/ctotable.pyx\":415\n *             # separate these out rather than |'ing here because\n *             # they may reuse the Col object.\n *             if col.invert:             # <<<<<<<<<<<<<<\n *                 tctdbqryaddcond(q._state, <char *>col.colname,\n *                                 <int>(col.op | TDBQCNEGATE), <char *>col.other)\n */\n    __pyx_t_5 = PyObject_GetAttr(__pyx_v_col, __pyx_n_s__invert); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 415; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    __Pyx_GOTREF(__pyx_t_5);\n    __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 415; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;\n    if (__pyx_t_7) {\n\n      /* \"/usr/local/src/totable/src/ctotable.pyx\":416\n *             # they may reuse the Col object.\n *             if col.invert:\n *                 tctdbqryaddcond(q._state, <char *>col.colname,             # <<<<<<<<<<<<<<\n *                                 <int>(col.op | TDBQCNEGATE), <char *>col.other)\n *             else:\n */\n      __pyx_t_5 = PyObject_GetAttr(__pyx_v_col, __pyx_n_s__colname); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 416; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_5);\n      __pyx_t_8 = __Pyx_PyBytes_AsString(__pyx_t_5); if (unlikely((!__pyx_t_8) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 416; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;\n\n      /* \"/usr/local/src/totable/src/ctotable.pyx\":417\n *             if col.invert:\n *                 tctdbqryaddcond(q._state, <char *>col.colname,\n *                                 <int>(col.op | TDBQCNEGATE), <char *>col.other)             # <<<<<<<<<<<<<<\n *             else:\n *                 tctdbqryaddcond(q._state, <char *>col.colname, <int>col.op,\n */\n      __pyx_t_5 = PyObject_GetAttr(__pyx_v_col, __pyx_n_s__op); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 417; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_5);\n      __pyx_t_1 = PyInt_FromLong(TDBQCNEGATE); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 417; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_1);\n      __pyx_t_4 = PyNumber_Or(__pyx_t_5, __pyx_t_1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 417; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_4);\n      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;\n      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n      __pyx_t_9 = __Pyx_PyInt_AsInt(__pyx_t_4); if (unlikely((__pyx_t_9 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 417; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n      __pyx_t_4 = PyObject_GetAttr(__pyx_v_col, __pyx_n_s__other); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 417; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_4);\n      __pyx_t_10 = __Pyx_PyBytes_AsString(__pyx_t_4); if (unlikely((!__pyx_t_10) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 417; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n      tctdbqryaddcond(__pyx_v_q->_state, ((char *)__pyx_t_8), ((int)__pyx_t_9), ((char *)__pyx_t_10));\n      goto __pyx_L11;\n    }\n    /*else*/ {\n\n      /* \"/usr/local/src/totable/src/ctotable.pyx\":419\n *                                 <int>(col.op | TDBQCNEGATE), <char *>col.other)\n *             else:\n *                 tctdbqryaddcond(q._state, <char *>col.colname, <int>col.op,             # <<<<<<<<<<<<<<\n *                                 <char *>col.other)\n * \n */\n      __pyx_t_4 = PyObject_GetAttr(__pyx_v_col, __pyx_n_s__colname); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 419; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_4);\n      __pyx_t_10 = __Pyx_PyBytes_AsString(__pyx_t_4); if (unlikely((!__pyx_t_10) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 419; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n      __pyx_t_4 = PyObject_GetAttr(__pyx_v_col, __pyx_n_s__op); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 419; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_4);\n      __pyx_t_9 = __Pyx_PyInt_AsInt(__pyx_t_4); if (unlikely((__pyx_t_9 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 419; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n\n      /* \"/usr/local/src/totable/src/ctotable.pyx\":420\n *             else:\n *                 tctdbqryaddcond(q._state, <char *>col.colname, <int>col.op,\n *                                 <char *>col.other)             # <<<<<<<<<<<<<<\n * \n *         self._set_limit(q._state, kwargs)\n */\n      __pyx_t_4 = PyObject_GetAttr(__pyx_v_col, __pyx_n_s__other); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 420; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_4);\n      __pyx_t_8 = __Pyx_PyBytes_AsString(__pyx_t_4); if (unlikely((!__pyx_t_8) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 420; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n      tctdbqryaddcond(__pyx_v_q->_state, ((char *)__pyx_t_10), ((int)__pyx_t_9), ((char *)__pyx_t_8));\n    }\n    __pyx_L11:;\n  }\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":422\n *                                 <char *>col.other)\n * \n *         self._set_limit(q._state, kwargs)             # <<<<<<<<<<<<<<\n *         self._set_order(q._state, kwargs)\n *         self._set_callback(q._state, kwargs)\n */\n  if (!(likely(PyDict_CheckExact(__pyx_v_kwargs))||((__pyx_v_kwargs) == Py_None)||(PyErr_Format(PyExc_TypeError, \"Expected dict, got %.200s\", Py_TYPE(__pyx_v_kwargs)->tp_name), 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 422; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  ((struct __pyx_vtabstruct_8ctotable_ToTable *)((struct __pyx_obj_8ctotable_ToTable *)__pyx_v_self)->__pyx_vtab)->_set_limit(((struct __pyx_obj_8ctotable_ToTable *)__pyx_v_self), __pyx_v_q->_state, ((PyObject *)__pyx_v_kwargs));\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":423\n * \n *         self._set_limit(q._state, kwargs)\n *         self._set_order(q._state, kwargs)             # <<<<<<<<<<<<<<\n *         self._set_callback(q._state, kwargs)\n * \n */\n  if (!(likely(PyDict_CheckExact(__pyx_v_kwargs))||((__pyx_v_kwargs) == Py_None)||(PyErr_Format(PyExc_TypeError, \"Expected dict, got %.200s\", Py_TYPE(__pyx_v_kwargs)->tp_name), 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 423; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  ((struct __pyx_vtabstruct_8ctotable_ToTable *)((struct __pyx_obj_8ctotable_ToTable *)__pyx_v_self)->__pyx_vtab)->_set_order(((struct __pyx_obj_8ctotable_ToTable *)__pyx_v_self), __pyx_v_q->_state, ((PyObject *)__pyx_v_kwargs));\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":424\n *         self._set_limit(q._state, kwargs)\n *         self._set_order(q._state, kwargs)\n *         self._set_callback(q._state, kwargs)             # <<<<<<<<<<<<<<\n * \n *         if 'delete' in kwargs:\n */\n  if (!(likely(PyDict_CheckExact(__pyx_v_kwargs))||((__pyx_v_kwargs) == Py_None)||(PyErr_Format(PyExc_TypeError, \"Expected dict, got %.200s\", Py_TYPE(__pyx_v_kwargs)->tp_name), 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 424; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  ((struct __pyx_vtabstruct_8ctotable_ToTable *)((struct __pyx_obj_8ctotable_ToTable *)__pyx_v_self)->__pyx_vtab)->_set_callback(((struct __pyx_obj_8ctotable_ToTable *)__pyx_v_self), __pyx_v_q->_state, ((PyObject *)__pyx_v_kwargs));\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":426\n *         self._set_callback(q._state, kwargs)\n * \n *         if 'delete' in kwargs:             # <<<<<<<<<<<<<<\n *             return tctdbqrysearchout(q._state)\n * \n */\n  __pyx_t_7 = ((PySequence_Contains(__pyx_v_kwargs, ((PyObject *)__pyx_n_s__delete)))); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 426; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  if (__pyx_t_7) {\n\n    /* \"/usr/local/src/totable/src/ctotable.pyx\":427\n * \n *         if 'delete' in kwargs:\n *             return tctdbqrysearchout(q._state)             # <<<<<<<<<<<<<<\n * \n *         tclist = tctdbqrysearch(q._state)\n */\n    __Pyx_XDECREF(__pyx_r);\n    __pyx_t_2 = __Pyx_PyBool_FromLong(tctdbqrysearchout(__pyx_v_q->_state)); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 427; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    __Pyx_GOTREF(__pyx_t_2);\n    __pyx_r = __pyx_t_2;\n    __pyx_t_2 = 0;\n    goto __pyx_L0;\n    goto __pyx_L12;\n  }\n  __pyx_L12:;\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":429\n *             return tctdbqrysearchout(q._state)\n * \n *         tclist = tctdbqrysearch(q._state)             # <<<<<<<<<<<<<<\n *         # number of elements in the list\n *         count = tclistnum(tclist)\n */\n  __pyx_v_tclist = tctdbqrysearch(__pyx_v_q->_state);\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":431\n *         tclist = tctdbqrysearch(q._state)\n *         # number of elements in the list\n *         count = tclistnum(tclist)             # <<<<<<<<<<<<<<\n * \n *         if 'count' in kwargs:\n */\n  __pyx_v_count = tclistnum(__pyx_v_tclist);\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":433\n *         count = tclistnum(tclist)\n * \n *         if 'count' in kwargs:             # <<<<<<<<<<<<<<\n *             tclistdel(tclist)\n *             return count\n */\n  __pyx_t_7 = ((PySequence_Contains(__pyx_v_kwargs, ((PyObject *)__pyx_n_s__count)))); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 433; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  if (__pyx_t_7) {\n\n    /* \"/usr/local/src/totable/src/ctotable.pyx\":434\n * \n *         if 'count' in kwargs:\n *             tclistdel(tclist)             # <<<<<<<<<<<<<<\n *             return count\n * \n */\n    tclistdel(__pyx_v_tclist);\n\n    /* \"/usr/local/src/totable/src/ctotable.pyx\":435\n *         if 'count' in kwargs:\n *             tclistdel(tclist)\n *             return count             # <<<<<<<<<<<<<<\n * \n *         li = self._tclist_to_list(tclist, count, values_only)\n */\n    __Pyx_XDECREF(__pyx_r);\n    __pyx_t_2 = PyInt_FromLong(__pyx_v_count); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 435; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    __Pyx_GOTREF(__pyx_t_2);\n    __pyx_r = __pyx_t_2;\n    __pyx_t_2 = 0;\n    goto __pyx_L0;\n    goto __pyx_L13;\n  }\n  __pyx_L13:;\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":437\n *             return count\n * \n *         li = self._tclist_to_list(tclist, count, values_only)             # <<<<<<<<<<<<<<\n *         tclistdel(tclist)\n *         return li\n */\n  __pyx_t_2 = ((PyObject *)((struct __pyx_vtabstruct_8ctotable_ToTable *)((struct __pyx_obj_8ctotable_ToTable *)__pyx_v_self)->__pyx_vtab)->_tclist_to_list(((struct __pyx_obj_8ctotable_ToTable *)__pyx_v_self), __pyx_v_tclist, __pyx_v_count, __pyx_v_values_only)); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 437; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_GOTREF(__pyx_t_2);\n  __Pyx_DECREF(((PyObject *)__pyx_v_li));\n  __pyx_v_li = ((PyObject *)__pyx_t_2);\n  __pyx_t_2 = 0;\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":438\n * \n *         li = self._tclist_to_list(tclist, count, values_only)\n *         tclistdel(tclist)             # <<<<<<<<<<<<<<\n *         return li\n * \n */\n  tclistdel(__pyx_v_tclist);\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":439\n *         li = self._tclist_to_list(tclist, count, values_only)\n *         tclistdel(tclist)\n *         return li             # <<<<<<<<<<<<<<\n * \n * \n */\n  __Pyx_XDECREF(__pyx_r);\n  __Pyx_INCREF(((PyObject *)__pyx_v_li));\n  __pyx_r = ((PyObject *)__pyx_v_li);\n  goto __pyx_L0;\n\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_4);\n  __Pyx_XDECREF(__pyx_t_5);\n  __Pyx_XDECREF(__pyx_t_6);\n  __Pyx_AddTraceback(\"ctotable.ToTable.select\");\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_DECREF(__pyx_v_args);\n  __Pyx_DECREF(__pyx_v_kwargs);\n  __Pyx_XDECREF((PyObject *)__pyx_v_q);\n  __Pyx_XDECREF(__pyx_v_li);\n  __Pyx_DECREF(__pyx_v_kwskip);\n  __Pyx_DECREF(__pyx_v_colname);\n  __Pyx_DECREF(__pyx_v_other);\n  __Pyx_DECREF(__pyx_v_col);\n  __Pyx_DECREF((PyObject *)__pyx_v_self);\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}", "path": "src\\ctotable.c", "repo_name": "brentp/totable", "stars": 1, "license": "None", "language": "c", "size": 220}
{"docstring": "/*proto*/\n", "func_signal": "static void __pyx_pf_8ctotable_7TCQuery___dealloc__(PyObject *__pyx_v_self)", "code": "{\n  __Pyx_RefNannySetupContext(\"__dealloc__\");\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":582\n *     cdef TDBQRY* _state\n *     def __dealloc__(self):\n *         tctdbqrydel(self._state)             # <<<<<<<<<<<<<<\n * \n * cdef TCQuery make_query(TCTDB* tctdb):\n */\n  tctdbqrydel(((struct __pyx_obj_8ctotable_TCQuery *)__pyx_v_self)->_state);\n\n  __Pyx_RefNannyFinishContext();\n}", "path": "src\\ctotable.c", "repo_name": "brentp/totable", "stars": 1, "license": "None", "language": "c", "size": 220}
{"docstring": "/* \"/usr/local/src/totable/src/ctotable.pyx\":574\n *         tcmapdel(self._state)\n * \n * cdef TCMap make_tcmap():             # <<<<<<<<<<<<<<\n *     pass\n * \n */\n", "func_signal": "static  struct __pyx_obj_8ctotable_TCMap *__pyx_f_8ctotable_make_tcmap(void)", "code": "{\n  struct __pyx_obj_8ctotable_TCMap *__pyx_r = NULL;\n  __Pyx_RefNannySetupContext(\"make_tcmap\");\n\n  __pyx_r = ((struct __pyx_obj_8ctotable_TCMap *)Py_None); __Pyx_INCREF(Py_None);\n  __Pyx_XGIVEREF((PyObject *)__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}", "path": "src\\ctotable.c", "repo_name": "brentp/totable", "stars": 1, "license": "None", "language": "c", "size": 220}
{"docstring": "/*proto*/\n", "func_signal": "static PyObject *__pyx_pf_8ctotable_7ToTable_count(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds)", "code": "{\n  PyObject *__pyx_v_args = 0;\n  PyObject *__pyx_v_kwargs = 0;\n  PyObject *__pyx_r = NULL;\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  __Pyx_RefNannySetupContext(\"count\");\n  if (unlikely(__pyx_kwds) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, \"count\", 1))) return NULL;\n  __pyx_v_kwargs = (__pyx_kwds) ? PyDict_Copy(__pyx_kwds) : PyDict_New();\n  if (unlikely(!__pyx_v_kwargs)) return NULL;\n  __Pyx_GOTREF(__pyx_v_kwargs);\n  __Pyx_INCREF(__pyx_args);\n  __pyx_v_args = __pyx_args;\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":386\n * \n *     def count(self, *args, **kwargs):\n *         kwargs['count'] = True             # <<<<<<<<<<<<<<\n *         return self.select(*args, **kwargs)\n * \n */\n  __pyx_t_1 = __Pyx_PyBool_FromLong(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 386; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_GOTREF(__pyx_t_1);\n  if (PyObject_SetItem(__pyx_v_kwargs, ((PyObject *)__pyx_n_s__count), __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 386; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":387\n *     def count(self, *args, **kwargs):\n *         kwargs['count'] = True\n *         return self.select(*args, **kwargs)             # <<<<<<<<<<<<<<\n * \n *     def delete(self, *args, **kwargs):\n */\n  __Pyx_XDECREF(__pyx_r);\n  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_n_s__select); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 387; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_t_2 = PySequence_Tuple(__pyx_v_args); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 387; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_GOTREF(((PyObject *)__pyx_t_2));\n  __pyx_t_3 = PyEval_CallObjectWithKeywords(__pyx_t_1, ((PyObject *)__pyx_t_2), __pyx_v_kwargs); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 387; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_GOTREF(__pyx_t_3);\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;\n  __pyx_r = __pyx_t_3;\n  __pyx_t_3 = 0;\n  goto __pyx_L0;\n\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_AddTraceback(\"ctotable.ToTable.count\");\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_DECREF(__pyx_v_args);\n  __Pyx_DECREF(__pyx_v_kwargs);\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}", "path": "src\\ctotable.c", "repo_name": "brentp/totable", "stars": 1, "license": "None", "language": "c", "size": 220}
{"docstring": "/*proto*/\n", "func_signal": "static  int __pyx_f_8ctotable_7ToTable_size_of(struct __pyx_obj_8ctotable_ToTable *__pyx_v_self, PyObject *__pyx_v_key, int __pyx_skip_dispatch)", "code": "{\n  char *__pyx_v_kbuf;\n  Py_ssize_t __pyx_v_ksiz;\n  int __pyx_r;\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  int __pyx_t_4;\n  __Pyx_RefNannySetupContext(\"size_of\");\n  /* Check if called by wrapper */\n  if (unlikely(__pyx_skip_dispatch)) ;\n  /* Check if overriden in Python */\n  else if (unlikely(Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0)) {\n    __pyx_t_1 = PyObject_GetAttr(((PyObject *)__pyx_v_self), __pyx_n_s__size_of); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 324; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    __Pyx_GOTREF(__pyx_t_1);\n    if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (void *)&__pyx_pf_8ctotable_7ToTable_size_of)) {\n      __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 324; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_2);\n      __Pyx_INCREF(__pyx_v_key);\n      PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_key);\n      __Pyx_GIVEREF(__pyx_v_key);\n      __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 324; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_GOTREF(__pyx_t_3);\n      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n      __pyx_t_4 = __Pyx_PyInt_AsInt(__pyx_t_3); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 324; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n      __pyx_r = __pyx_t_4;\n      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n      goto __pyx_L0;\n    }\n    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  }\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":333\n *         cdef char *kbuf\n *         cdef Py_ssize_t   ksiz\n *         ps.PyString_AsStringAndSize(key, &kbuf, &ksiz)             # <<<<<<<<<<<<<<\n *         return tctdbvsiz(self._state, kbuf, <int>ksiz)\n * \n */\n  __pyx_t_4 = PyString_AsStringAndSize(__pyx_v_key, (&__pyx_v_kbuf), (&__pyx_v_ksiz)); if (unlikely(__pyx_t_4 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 333; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":334\n *         cdef Py_ssize_t   ksiz\n *         ps.PyString_AsStringAndSize(key, &kbuf, &ksiz)\n *         return tctdbvsiz(self._state, kbuf, <int>ksiz)             # <<<<<<<<<<<<<<\n * \n *     def __contains__(self, key):\n */\n  __pyx_r = tctdbvsiz(__pyx_v_self->_state, __pyx_v_kbuf, ((int)__pyx_v_ksiz));\n  goto __pyx_L0;\n\n  __pyx_r = 0;\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_WriteUnraisable(\"ctotable.ToTable.size_of\");\n  __pyx_r = 0;\n  __pyx_L0:;\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}", "path": "src\\ctotable.c", "repo_name": "brentp/totable", "stars": 1, "license": "None", "language": "c", "size": 220}
{"docstring": "/* \"/usr/local/src/totable/src/ctotable.pyx\":373\n *         pass\n * \n *     cdef void _set_order(ToTable self, TDBQRY* query_state, dict kwargs):             # <<<<<<<<<<<<<<\n *         if not 'order' in kwargs: return\n *         # TODO: handle nums. NUMASC, NUMDESC how?\n */\n", "func_signal": "static  void __pyx_f_8ctotable_7ToTable__set_order(struct __pyx_obj_8ctotable_ToTable *__pyx_v_self, TDBQRY *__pyx_v_query_state, PyObject *__pyx_v_kwargs)", "code": "{\n  PyObject *__pyx_v_col;\n  PyObject *__pyx_v_direction;\n  int __pyx_t_1;\n  int __pyx_t_2;\n  PyObject *__pyx_t_3 = NULL;\n  PyObject *__pyx_t_4 = NULL;\n  int __pyx_t_5;\n  int __pyx_t_6;\n  char *__pyx_t_7;\n  int __pyx_t_8;\n  __Pyx_RefNannySetupContext(\"_set_order\");\n  __Pyx_INCREF((PyObject *)__pyx_v_self);\n  __Pyx_INCREF(__pyx_v_kwargs);\n  __pyx_v_col = Py_None; __Pyx_INCREF(Py_None);\n  __pyx_v_direction = Py_None; __Pyx_INCREF(Py_None);\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":374\n * \n *     cdef void _set_order(ToTable self, TDBQRY* query_state, dict kwargs):\n *         if not 'order' in kwargs: return             # <<<<<<<<<<<<<<\n *         # TODO: handle nums. NUMASC, NUMDESC how?\n *         #\"order='+name' or order='-name'\n */\n  if (unlikely(((PyObject *)__pyx_v_kwargs) == Py_None)) {\n    __Pyx_RaiseNoneNotIterableError(); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 374; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  } else {\n    __pyx_t_1 = ((PyDict_Contains(((PyObject *)__pyx_v_kwargs), ((PyObject *)__pyx_n_s__order)))); if (unlikely(__pyx_t_1 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 374; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  }\n  __pyx_t_2 = (!__pyx_t_1);\n  if (__pyx_t_2) {\n    goto __pyx_L0;\n    goto __pyx_L3;\n  }\n  __pyx_L3:;\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":377\n *         # TODO: handle nums. NUMASC, NUMDESC how?\n *         #\"order='+name' or order='-name'\n *         col = kwargs['order']             # <<<<<<<<<<<<<<\n *         if col[0] not in ('+', '-'):\n *             direction = TDBQOSTRASC\n */\n  __pyx_t_3 = PyObject_GetItem(((PyObject *)__pyx_v_kwargs), ((PyObject *)__pyx_n_s__order)); if (!__pyx_t_3) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 377; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_GOTREF(__pyx_t_3);\n  __Pyx_DECREF(__pyx_v_col);\n  __pyx_v_col = __pyx_t_3;\n  __pyx_t_3 = 0;\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":378\n *         #\"order='+name' or order='-name'\n *         col = kwargs['order']\n *         if col[0] not in ('+', '-'):             # <<<<<<<<<<<<<<\n *             direction = TDBQOSTRASC\n *         else:\n */\n  __pyx_t_3 = __Pyx_GetItemInt(__pyx_v_col, 0, sizeof(long), PyInt_FromLong); if (!__pyx_t_3) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 378; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_GOTREF(__pyx_t_3);\n  __pyx_t_4 = PyObject_RichCompare(__pyx_t_3, ((PyObject *)__pyx_kp_s_19), Py_NE); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 378; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_GOTREF(__pyx_t_4);\n  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely((__pyx_t_2 == (int)-1))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 378; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n  __pyx_t_1 = ((int)__pyx_t_2);\n  if (__pyx_t_1) {\n    __pyx_t_4 = PyObject_RichCompare(__pyx_t_3, ((PyObject *)__pyx_kp_s_20), Py_NE); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 378; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    __Pyx_GOTREF(__pyx_t_4);\n    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely((__pyx_t_2 == (int)-1))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 378; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n    __pyx_t_5 = ((int)__pyx_t_2);\n    __pyx_t_2 = __pyx_t_5;\n  } else {\n    __pyx_t_2 = __pyx_t_1;\n  }\n  __pyx_t_1 = __pyx_t_2;\n  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n  if (__pyx_t_1) {\n\n    /* \"/usr/local/src/totable/src/ctotable.pyx\":379\n *         col = kwargs['order']\n *         if col[0] not in ('+', '-'):\n *             direction = TDBQOSTRASC             # <<<<<<<<<<<<<<\n *         else:\n *             direction = TDBQOSTRASC if col[0] == '+' else TDBQOSTRDESC\n */\n    __pyx_t_3 = PyInt_FromLong(TDBQOSTRASC); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 379; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    __Pyx_GOTREF(__pyx_t_3);\n    __Pyx_DECREF(__pyx_v_direction);\n    __pyx_v_direction = __pyx_t_3;\n    __pyx_t_3 = 0;\n    goto __pyx_L4;\n  }\n  /*else*/ {\n\n    /* \"/usr/local/src/totable/src/ctotable.pyx\":381\n *             direction = TDBQOSTRASC\n *         else:\n *             direction = TDBQOSTRASC if col[0] == '+' else TDBQOSTRDESC             # <<<<<<<<<<<<<<\n *             col = col[1:]\n *         tctdbqrysetorder(query_state, col, direction)\n */\n    __pyx_t_3 = __Pyx_GetItemInt(__pyx_v_col, 0, sizeof(long), PyInt_FromLong); if (!__pyx_t_3) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 381; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    __Pyx_GOTREF(__pyx_t_3);\n    __pyx_t_4 = PyObject_RichCompare(__pyx_t_3, ((PyObject *)__pyx_kp_s_19), Py_EQ); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 381; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    __Pyx_GOTREF(__pyx_t_4);\n    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n    __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_1 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 381; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;\n    if (__pyx_t_1) {\n      __pyx_t_6 = TDBQOSTRASC;\n    } else {\n      __pyx_t_6 = TDBQOSTRDESC;\n    }\n    __pyx_t_4 = PyInt_FromLong(__pyx_t_6); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 381; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    __Pyx_GOTREF(__pyx_t_4);\n    __Pyx_DECREF(__pyx_v_direction);\n    __pyx_v_direction = __pyx_t_4;\n    __pyx_t_4 = 0;\n\n    /* \"/usr/local/src/totable/src/ctotable.pyx\":382\n *         else:\n *             direction = TDBQOSTRASC if col[0] == '+' else TDBQOSTRDESC\n *             col = col[1:]             # <<<<<<<<<<<<<<\n *         tctdbqrysetorder(query_state, col, direction)\n * \n */\n    __pyx_t_4 = PySequence_GetSlice(__pyx_v_col, 1, PY_SSIZE_T_MAX); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 382; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    __Pyx_GOTREF(__pyx_t_4);\n    __Pyx_DECREF(__pyx_v_col);\n    __pyx_v_col = __pyx_t_4;\n    __pyx_t_4 = 0;\n  }\n  __pyx_L4:;\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":383\n *             direction = TDBQOSTRASC if col[0] == '+' else TDBQOSTRDESC\n *             col = col[1:]\n *         tctdbqrysetorder(query_state, col, direction)             # <<<<<<<<<<<<<<\n * \n *     def count(self, *args, **kwargs):\n */\n  __pyx_t_7 = __Pyx_PyBytes_AsString(__pyx_v_col); if (unlikely((!__pyx_t_7) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 383; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __pyx_t_8 = __Pyx_PyInt_AsInt(__pyx_v_direction); if (unlikely((__pyx_t_8 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 383; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  tctdbqrysetorder(__pyx_v_query_state, __pyx_t_7, __pyx_t_8);\n\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_XDECREF(__pyx_t_4);\n  __Pyx_WriteUnraisable(\"ctotable.ToTable._set_order\");\n  __pyx_L0:;\n  __Pyx_DECREF(__pyx_v_col);\n  __Pyx_DECREF(__pyx_v_direction);\n  __Pyx_DECREF((PyObject *)__pyx_v_self);\n  __Pyx_DECREF(__pyx_v_kwargs);\n  __Pyx_RefNannyFinishContext();\n}", "path": "src\\ctotable.c", "repo_name": "brentp/totable", "stars": 1, "license": "None", "language": "c", "size": 220}
{"docstring": "/* \"/usr/local/src/totable/src/ctotable.pyx\":584\n *         tctdbqrydel(self._state)\n * \n * cdef TCQuery make_query(TCTDB* tctdb):             # <<<<<<<<<<<<<<\n *     cdef TCQuery query = TCQuery()\n *     query._state = tctdbqrynew(tctdb)\n */\n", "func_signal": "static  struct __pyx_obj_8ctotable_TCQuery *__pyx_f_8ctotable_make_query(TCTDB *__pyx_v_tctdb)", "code": "{\n  struct __pyx_obj_8ctotable_TCQuery *__pyx_v_query = 0;\n  struct __pyx_obj_8ctotable_TCQuery *__pyx_r = NULL;\n  PyObject *__pyx_t_1 = NULL;\n  __Pyx_RefNannySetupContext(\"make_query\");\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":585\n * \n * cdef TCQuery make_query(TCTDB* tctdb):\n *     cdef TCQuery query = TCQuery()             # <<<<<<<<<<<<<<\n *     query._state = tctdbqrynew(tctdb)\n *     return query\n */\n  __pyx_t_1 = PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_8ctotable_TCQuery)), ((PyObject *)__pyx_empty_tuple), NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 585; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_v_query = ((struct __pyx_obj_8ctotable_TCQuery *)__pyx_t_1);\n  __pyx_t_1 = 0;\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":586\n * cdef TCQuery make_query(TCTDB* tctdb):\n *     cdef TCQuery query = TCQuery()\n *     query._state = tctdbqrynew(tctdb)             # <<<<<<<<<<<<<<\n *     return query\n * \n */\n  __pyx_v_query->_state = tctdbqrynew(__pyx_v_tctdb);\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":587\n *     cdef TCQuery query = TCQuery()\n *     query._state = tctdbqrynew(tctdb)\n *     return query             # <<<<<<<<<<<<<<\n * \n */\n  __Pyx_XDECREF(((PyObject *)__pyx_r));\n  __Pyx_INCREF(((PyObject *)__pyx_v_query));\n  __pyx_r = __pyx_v_query;\n  goto __pyx_L0;\n\n  __pyx_r = ((struct __pyx_obj_8ctotable_TCQuery *)Py_None); __Pyx_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_AddTraceback(\"ctotable.make_query\");\n  __pyx_r = 0;\n  __pyx_L0:;\n  __Pyx_XDECREF((PyObject *)__pyx_v_query);\n  __Pyx_XGIVEREF((PyObject *)__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}", "path": "src\\ctotable.c", "repo_name": "brentp/totable", "stars": 1, "license": "None", "language": "c", "size": 220}
{"docstring": "/*proto*/\n", "func_signal": "static PyObject *__pyx_pf_8ctotable_3Col_matches(PyObject *__pyx_v_self, PyObject *__pyx_v_pattern)", "code": "{\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannySetupContext(\"matches\");\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":517\n * \n *     def matches(self, pattern):\n *         self.op = TDBQCSTRRX             # <<<<<<<<<<<<<<\n *         self.other = pattern\n *         return self\n */\n  ((struct __pyx_obj_8ctotable_Col *)__pyx_v_self)->op = TDBQCSTRRX;\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":518\n *     def matches(self, pattern):\n *         self.op = TDBQCSTRRX\n *         self.other = pattern             # <<<<<<<<<<<<<<\n *         return self\n * \n */\n  __Pyx_INCREF(__pyx_v_pattern);\n  __Pyx_GIVEREF(__pyx_v_pattern);\n  __Pyx_GOTREF(((struct __pyx_obj_8ctotable_Col *)__pyx_v_self)->other);\n  __Pyx_DECREF(((struct __pyx_obj_8ctotable_Col *)__pyx_v_self)->other);\n  ((struct __pyx_obj_8ctotable_Col *)__pyx_v_self)->other = __pyx_v_pattern;\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":519\n *         self.op = TDBQCSTRRX\n *         self.other = pattern\n *         return self             # <<<<<<<<<<<<<<\n * \n *     def in_list(self, li):\n */\n  __Pyx_XDECREF(__pyx_r);\n  __Pyx_INCREF(__pyx_v_self);\n  __pyx_r = __pyx_v_self;\n  goto __pyx_L0;\n\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}", "path": "src\\ctotable.c", "repo_name": "brentp/totable", "stars": 1, "license": "None", "language": "c", "size": 220}
{"docstring": "/*proto*/\n", "func_signal": "static PyObject *__pyx_pf_8ctotable_3Col_like(PyObject *__pyx_v_self, PyObject *__pyx_v_other)", "code": "{\n  PyObject *__pyx_r = NULL;\n  int __pyx_t_1;\n  __Pyx_RefNannySetupContext(\"like\");\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":531\n * \n *     def like(self, other):\n *         assert isinstance(other, basestring)             # <<<<<<<<<<<<<<\n *         self.op = TDBQCSTRINC\n *         self.other = other\n */\n  #ifndef PYREX_WITHOUT_ASSERTIONS\n  __pyx_t_1 = PyObject_IsInstance(__pyx_v_other, __pyx_builtin_basestring); if (unlikely(__pyx_t_1 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 531; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  if (unlikely(!__pyx_t_1)) {\n    PyErr_SetNone(PyExc_AssertionError);\n    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 531; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  }\n  #endif\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":532\n *     def like(self, other):\n *         assert isinstance(other, basestring)\n *         self.op = TDBQCSTRINC             # <<<<<<<<<<<<<<\n *         self.other = other\n *         return self\n */\n  ((struct __pyx_obj_8ctotable_Col *)__pyx_v_self)->op = TDBQCSTRINC;\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":533\n *         assert isinstance(other, basestring)\n *         self.op = TDBQCSTRINC\n *         self.other = other             # <<<<<<<<<<<<<<\n *         return self\n * \n */\n  __Pyx_INCREF(__pyx_v_other);\n  __Pyx_GIVEREF(__pyx_v_other);\n  __Pyx_GOTREF(((struct __pyx_obj_8ctotable_Col *)__pyx_v_self)->other);\n  __Pyx_DECREF(((struct __pyx_obj_8ctotable_Col *)__pyx_v_self)->other);\n  ((struct __pyx_obj_8ctotable_Col *)__pyx_v_self)->other = __pyx_v_other;\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":534\n *         self.op = TDBQCSTRINC\n *         self.other = other\n *         return self             # <<<<<<<<<<<<<<\n * \n *     def startswith(self, other):\n */\n  __Pyx_XDECREF(__pyx_r);\n  __Pyx_INCREF(__pyx_v_self);\n  __pyx_r = __pyx_v_self;\n  goto __pyx_L0;\n\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_AddTraceback(\"ctotable.Col.like\");\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}", "path": "src\\ctotable.c", "repo_name": "brentp/totable", "stars": 1, "license": "None", "language": "c", "size": 220}
{"docstring": "/*proto*/\n", "func_signal": "static PyObject *__pyx_pf_8ctotable_3Col_startswith(PyObject *__pyx_v_self, PyObject *__pyx_v_other)", "code": "{\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannySetupContext(\"startswith\");\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":537\n * \n *     def startswith(self, other):\n *         self.other = other             # <<<<<<<<<<<<<<\n *         self.op = TDBQCSTRBW\n *         return self\n */\n  __Pyx_INCREF(__pyx_v_other);\n  __Pyx_GIVEREF(__pyx_v_other);\n  __Pyx_GOTREF(((struct __pyx_obj_8ctotable_Col *)__pyx_v_self)->other);\n  __Pyx_DECREF(((struct __pyx_obj_8ctotable_Col *)__pyx_v_self)->other);\n  ((struct __pyx_obj_8ctotable_Col *)__pyx_v_self)->other = __pyx_v_other;\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":538\n *     def startswith(self, other):\n *         self.other = other\n *         self.op = TDBQCSTRBW             # <<<<<<<<<<<<<<\n *         return self\n * \n */\n  ((struct __pyx_obj_8ctotable_Col *)__pyx_v_self)->op = TDBQCSTRBW;\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":539\n *         self.other = other\n *         self.op = TDBQCSTRBW\n *         return self             # <<<<<<<<<<<<<<\n * \n *     def endswith(self, other):\n */\n  __Pyx_XDECREF(__pyx_r);\n  __Pyx_INCREF(__pyx_v_self);\n  __pyx_r = __pyx_v_self;\n  goto __pyx_L0;\n\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}", "path": "src\\ctotable.c", "repo_name": "brentp/totable", "stars": 1, "license": "None", "language": "c", "size": 220}
{"docstring": "/*proto*/\n", "func_signal": "static int __pyx_pf_8ctotable_11transaction___init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds)", "code": "{\n  struct __pyx_obj_8ctotable_ToTable *__pyx_v_t = 0;\n  int __pyx_r;\n  static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__t,0};\n  __Pyx_RefNannySetupContext(\"__init__\");\n  if (unlikely(__pyx_kwds)) {\n    Py_ssize_t kw_args = PyDict_Size(__pyx_kwds);\n    PyObject* values[1] = {0};\n    switch (PyTuple_GET_SIZE(__pyx_args)) {\n      case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);\n      case  0: break;\n      default: goto __pyx_L5_argtuple_error;\n    }\n    switch (PyTuple_GET_SIZE(__pyx_args)) {\n      case  0:\n      values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__t);\n      if (likely(values[0])) kw_args--;\n      else goto __pyx_L5_argtuple_error;\n    }\n    if (unlikely(kw_args > 0)) {\n      if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, PyTuple_GET_SIZE(__pyx_args), \"__init__\") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 553; __pyx_clineno = __LINE__; goto __pyx_L3_error;}\n    }\n    __pyx_v_t = ((struct __pyx_obj_8ctotable_ToTable *)values[0]);\n  } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {\n    goto __pyx_L5_argtuple_error;\n  } else {\n    __pyx_v_t = ((struct __pyx_obj_8ctotable_ToTable *)PyTuple_GET_ITEM(__pyx_args, 0));\n  }\n  goto __pyx_L4_argument_unpacking_done;\n  __pyx_L5_argtuple_error:;\n  __Pyx_RaiseArgtupleInvalid(\"__init__\", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 553; __pyx_clineno = __LINE__; goto __pyx_L3_error;}\n  __pyx_L3_error:;\n  __Pyx_AddTraceback(\"ctotable.transaction.__init__\");\n  return -1;\n  __pyx_L4_argument_unpacking_done:;\n  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_t), __pyx_ptype_8ctotable_ToTable, 1, \"t\", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 553; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":554\n *     cdef ToTable table\n *     def __init__(self, ToTable t):\n *         self.table = t             # <<<<<<<<<<<<<<\n * \n *     def __enter__(self):\n */\n  __Pyx_INCREF(((PyObject *)__pyx_v_t));\n  __Pyx_GIVEREF(((PyObject *)__pyx_v_t));\n  __Pyx_GOTREF(((struct __pyx_obj_8ctotable_transaction *)__pyx_v_self)->table);\n  __Pyx_DECREF(((PyObject *)((struct __pyx_obj_8ctotable_transaction *)__pyx_v_self)->table));\n  ((struct __pyx_obj_8ctotable_transaction *)__pyx_v_self)->table = __pyx_v_t;\n\n  __pyx_r = 0;\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_AddTraceback(\"ctotable.transaction.__init__\");\n  __pyx_r = -1;\n  __pyx_L0:;\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}", "path": "src\\ctotable.c", "repo_name": "brentp/totable", "stars": 1, "license": "None", "language": "c", "size": 220}
{"docstring": "/*proto*/\n", "func_signal": "static PyObject *__pyx_pf_8ctotable_3Col_endswith(PyObject *__pyx_v_self, PyObject *__pyx_v_other)", "code": "{\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannySetupContext(\"endswith\");\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":542\n * \n *     def endswith(self, other):\n *         self.other = other             # <<<<<<<<<<<<<<\n *         self.op = TDBQCSTREW\n *         return self\n */\n  __Pyx_INCREF(__pyx_v_other);\n  __Pyx_GIVEREF(__pyx_v_other);\n  __Pyx_GOTREF(((struct __pyx_obj_8ctotable_Col *)__pyx_v_self)->other);\n  __Pyx_DECREF(((struct __pyx_obj_8ctotable_Col *)__pyx_v_self)->other);\n  ((struct __pyx_obj_8ctotable_Col *)__pyx_v_self)->other = __pyx_v_other;\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":543\n *     def endswith(self, other):\n *         self.other = other\n *         self.op = TDBQCSTREW             # <<<<<<<<<<<<<<\n *         return self\n * \n */\n  ((struct __pyx_obj_8ctotable_Col *)__pyx_v_self)->op = TDBQCSTREW;\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":544\n *         self.other = other\n *         self.op = TDBQCSTREW\n *         return self             # <<<<<<<<<<<<<<\n * \n *     def between(self, low, high):\n */\n  __Pyx_XDECREF(__pyx_r);\n  __Pyx_INCREF(__pyx_v_self);\n  __pyx_r = __pyx_v_self;\n  goto __pyx_L0;\n\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}", "path": "src\\ctotable.c", "repo_name": "brentp/totable", "stars": 1, "license": "None", "language": "c", "size": 220}
{"docstring": "/* \"/usr/local/src/totable/src/ctotable.pyx\":351\n *         return tctdbrnum(self._state)\n * \n *     cdef void _set_limit(ToTable self, TDBQRY* query_state, dict kwargs):             # <<<<<<<<<<<<<<\n *         limit = kwargs.pop('limit', None)\n *         offset = kwargs.pop('offset', None)\n */\n", "func_signal": "static  void __pyx_f_8ctotable_7ToTable__set_limit(struct __pyx_obj_8ctotable_ToTable *__pyx_v_self, TDBQRY *__pyx_v_query_state, PyObject *__pyx_v_kwargs)", "code": "{\n  PyObject *__pyx_v_limit;\n  PyObject *__pyx_v_offset;\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  int __pyx_t_4;\n  int __pyx_t_5;\n  int __pyx_t_6;\n  int __pyx_t_7;\n  int __pyx_t_8;\n  __Pyx_RefNannySetupContext(\"_set_limit\");\n  __Pyx_INCREF((PyObject *)__pyx_v_self);\n  __Pyx_INCREF(__pyx_v_kwargs);\n  __pyx_v_limit = Py_None; __Pyx_INCREF(Py_None);\n  __pyx_v_offset = Py_None; __Pyx_INCREF(Py_None);\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":352\n * \n *     cdef void _set_limit(ToTable self, TDBQRY* query_state, dict kwargs):\n *         limit = kwargs.pop('limit', None)             # <<<<<<<<<<<<<<\n *         offset = kwargs.pop('offset', None)\n *         if (limit is None and offset is None): return\n */\n  __pyx_t_1 = PyObject_GetAttr(((PyObject *)__pyx_v_kwargs), __pyx_n_s__pop); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 352; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 352; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_GOTREF(__pyx_t_2);\n  __Pyx_INCREF(((PyObject *)__pyx_n_s__limit));\n  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_n_s__limit));\n  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__limit));\n  __Pyx_INCREF(Py_None);\n  PyTuple_SET_ITEM(__pyx_t_2, 1, Py_None);\n  __Pyx_GIVEREF(Py_None);\n  __pyx_t_3 = PyObject_Call(__pyx_t_1, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 352; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_GOTREF(__pyx_t_3);\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n  __Pyx_DECREF(__pyx_v_limit);\n  __pyx_v_limit = __pyx_t_3;\n  __pyx_t_3 = 0;\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":353\n *     cdef void _set_limit(ToTable self, TDBQRY* query_state, dict kwargs):\n *         limit = kwargs.pop('limit', None)\n *         offset = kwargs.pop('offset', None)             # <<<<<<<<<<<<<<\n *         if (limit is None and offset is None): return\n *         if limit is None: limit = -1\n */\n  __pyx_t_3 = PyObject_GetAttr(((PyObject *)__pyx_v_kwargs), __pyx_n_s__pop); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 353; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_GOTREF(__pyx_t_3);\n  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 353; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_GOTREF(__pyx_t_2);\n  __Pyx_INCREF(((PyObject *)__pyx_n_s__offset));\n  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_n_s__offset));\n  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__offset));\n  __Pyx_INCREF(Py_None);\n  PyTuple_SET_ITEM(__pyx_t_2, 1, Py_None);\n  __Pyx_GIVEREF(Py_None);\n  __pyx_t_1 = PyObject_Call(__pyx_t_3, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 353; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_GOTREF(__pyx_t_1);\n  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n  __Pyx_DECREF(__pyx_v_offset);\n  __pyx_v_offset = __pyx_t_1;\n  __pyx_t_1 = 0;\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":354\n *         limit = kwargs.pop('limit', None)\n *         offset = kwargs.pop('offset', None)\n *         if (limit is None and offset is None): return             # <<<<<<<<<<<<<<\n *         if limit is None: limit = -1\n *         if offset is None: offset = 0\n */\n  __pyx_t_4 = (__pyx_v_limit == Py_None);\n  if (__pyx_t_4) {\n    __pyx_t_5 = (__pyx_v_offset == Py_None);\n    __pyx_t_6 = __pyx_t_5;\n  } else {\n    __pyx_t_6 = __pyx_t_4;\n  }\n  if (__pyx_t_6) {\n    goto __pyx_L0;\n    goto __pyx_L3;\n  }\n  __pyx_L3:;\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":355\n *         offset = kwargs.pop('offset', None)\n *         if (limit is None and offset is None): return\n *         if limit is None: limit = -1             # <<<<<<<<<<<<<<\n *         if offset is None: offset = 0\n *         tctdbqrysetlimit(query_state, <int>limit, <int>offset)\n */\n  __pyx_t_6 = (__pyx_v_limit == Py_None);\n  if (__pyx_t_6) {\n    __Pyx_INCREF(__pyx_int_neg_1);\n    __Pyx_DECREF(__pyx_v_limit);\n    __pyx_v_limit = __pyx_int_neg_1;\n    goto __pyx_L4;\n  }\n  __pyx_L4:;\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":356\n *         if (limit is None and offset is None): return\n *         if limit is None: limit = -1\n *         if offset is None: offset = 0             # <<<<<<<<<<<<<<\n *         tctdbqrysetlimit(query_state, <int>limit, <int>offset)\n * \n */\n  __pyx_t_6 = (__pyx_v_offset == Py_None);\n  if (__pyx_t_6) {\n    __Pyx_INCREF(__pyx_int_0);\n    __Pyx_DECREF(__pyx_v_offset);\n    __pyx_v_offset = __pyx_int_0;\n    goto __pyx_L5;\n  }\n  __pyx_L5:;\n\n  /* \"/usr/local/src/totable/src/ctotable.pyx\":357\n *         if limit is None: limit = -1\n *         if offset is None: offset = 0\n *         tctdbqrysetlimit(query_state, <int>limit, <int>offset)             # <<<<<<<<<<<<<<\n * \n *     cdef void _set_callback(ToTable self, TDBQRY *query_state, dict kwargs):\n */\n  __pyx_t_7 = __Pyx_PyInt_AsInt(__pyx_v_limit); if (unlikely((__pyx_t_7 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 357; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __pyx_t_8 = __Pyx_PyInt_AsInt(__pyx_v_offset); if (unlikely((__pyx_t_8 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 357; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  tctdbqrysetlimit(__pyx_v_query_state, ((int)__pyx_t_7), ((int)__pyx_t_8));\n\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_WriteUnraisable(\"ctotable.ToTable._set_limit\");\n  __pyx_L0:;\n  __Pyx_DECREF(__pyx_v_limit);\n  __Pyx_DECREF(__pyx_v_offset);\n  __Pyx_DECREF((PyObject *)__pyx_v_self);\n  __Pyx_DECREF(__pyx_v_kwargs);\n  __Pyx_RefNannyFinishContext();\n}", "path": "src\\ctotable.c", "repo_name": "brentp/totable", "stars": 1, "license": "None", "language": "c", "size": 220}
{"docstring": "/*\n * Save the command_giver, because reset() in the new object might change\n * it.\n */\n", "func_signal": "object_t *clone_object (const char * str1, int num_arg)", "code": "{\n    object_t *ob, *new_ob;\n\n#ifdef PACKAGE_UIDS\n    if (current_object && current_object->euid == 0) {\n        error(\"Object must call seteuid() prior to calling clone_object().\\n\");\n    }\n#endif\n\n    save_command_giver(command_giver);\n\n    num_objects_this_thread = 0;\n    ob = find_object(str1);\n    if (ob && !object_visible(ob))\n        ob = 0;\n    /*\n     * If the object self-destructed...\n     */\n    if (ob == 0) {              /* fix from 3.1.1 */\n        restore_command_giver();\n        pop_n_elems(num_arg);\n        return (0);\n    }\n\n    if (ob->flags & O_CLONE)\n      error(\"Cannot clone from a clone\\n\");\n\n    if(ob->flags & O_VIRTUAL) {\n      new_ob = load_virtual_object(ob->obname, 1 + num_arg);\n      restore_command_giver();\n      return new_ob;\n      /*\n       * we can skip all of the stuff below since we were already\n       * cloned once to have gotten to this stage.\n       */\n    }\n\n    /* We do not want the heart beat to be running for unused copied objects */\n    if (ob->flags & O_HEART_BEAT)\n        (void) set_heart_beat(ob, 0);\n    new_ob = get_empty_object(ob->prog->num_variables_total);\n    SETOBNAME(new_ob, make_new_name(ob->obname));\n    new_ob->flags |= (O_CLONE | (ob->flags & (O_WILL_CLEAN_UP | O_WILL_RESET)));\n    new_ob->load_time = ob->load_time;\n    new_ob->prog = ob->prog;\n    reference_prog(ob->prog, \"clone_object\");\n    DEBUG_CHECK(!current_object, \"clone_object() from no current_object !\\n\");\n\n    init_object(new_ob);\n\n    new_ob->next_all = obj_list;\n    obj_list->prev_all = new_ob;\n    new_ob->prev_all = 0;\n    obj_list = new_ob;\n    enter_object_hash(new_ob);  /* Add name to fast object lookup table */\n    call_create(new_ob, num_arg);\n    restore_command_giver();\n    /* Never know what can happen ! :-( */\n    if (new_ob->flags & O_DESTRUCTED)\n        return (0);\n    return (new_ob);\n}", "path": "driver\\fluffos\\simulate.c", "repo_name": "dyher/dock9", "stars": 0, "license": "None", "language": "c", "size": 12716}
{"docstring": "/*\n * Store a 2 byte number. It is stored in such a way as to be sure\n * that correct byte order is used, regardless of machine architecture.\n * Also beware that some machines can't write a word to odd addresses.\n */\n", "func_signal": "static void ins_short (short l)", "code": "{\n    if (prog_code + 2 > prog_code_max) {\n        mem_block_t *mbp = &mem_block[A_PROGRAM];\n        UPDATE_PROGRAM_SIZE;\n        realloc_mem_block(mbp);\n\n        prog_code = mbp->block + mbp->current_size;\n        prog_code_max = mbp->block + mbp->max_size;\n    }\n    STORE_SHORT(prog_code, l);\n}", "path": "driver\\rth\\icode.c", "repo_name": "dyher/dock9", "stars": 0, "license": "None", "language": "c", "size": 12716}
{"docstring": "/*\n * Set up a function in this object to be called with the next\n * user input string.\n */\n", "func_signal": "int input_to (svalue_t * fun, int flag, int num_arg, svalue_t * args)", "code": "{\n    sentence_t *s;\n    svalue_t *x;\n    int i;\n\n    if (!command_giver || command_giver->flags & O_DESTRUCTED)\n        return 0;\n    s = alloc_sentence();\n    if (set_call(command_giver, s, flag & ~I_SINGLE_CHAR)) {\n        /*\n         * If we have args, we copy them, and adjust the stack automatically\n         * (elsewhere) to avoid double free_svalue()'s\n         */\n        if (num_arg) {\n            i = num_arg * sizeof(svalue_t);\n            if ((x = (svalue_t *)\n                 DMALLOC(i, TAG_INPUT_TO, \"input_to: 1\")) == NULL)\n                fatal(\"Out of memory!\\n\");\n            memcpy(x, args, i);\n        } else\n            x = NULL;\n\n        command_giver->interactive->carryover = x;\n        command_giver->interactive->num_carry = num_arg;\n        if (fun->type == T_STRING) {\n            s->function.s = make_shared_string(fun->u.string);\n            s->flags = 0;\n        } else {\n            s->function.f = fun->u.fp;\n            fun->u.fp->hdr.ref++;\n            s->flags = V_FUNCTION;\n        }\n        s->ob = current_object;\n        add_ref(current_object, \"input_to\");\n        return 1;\n    }\n    free_sentence(s);\n    return 0;\n}", "path": "driver\\fluffos\\simulate.c", "repo_name": "dyher/dock9", "stars": 0, "license": "None", "language": "c", "size": 12716}
{"docstring": "/*\n * Decrement reference count for a program. If it is 0, then free the prgram.\n * The flag free_sub_strings tells if the propgram plus all used strings\n * should be freed. They normally are, except when objects are swapped,\n * as we want to be able to read the program in again from the swap area.\n * That means that strings are not swapped.\n */\n", "func_signal": "void free_prog (program_t **progp)", "code": "{\n    (*progp)->ref--;\n    if ((*progp)->ref > 0) {\n      *progp = (program_t *)2;//NULL;\n        return;\n    }\n    if ((*progp)->func_ref > 0) {\n      *progp = (program_t *)3;//NULL;\n        return;\n    }\n\n    deallocate_program(*progp);\n    *progp = (program_t *)4;//NULL;\n}", "path": "driver\\fluffos\\program.c", "repo_name": "dyher/dock9", "stars": 0, "license": "None", "language": "c", "size": 12716}
{"docstring": "/*\n * Remove an object. It is first moved into the destruct list, and\n * not really destructed until later. (see destruct2()).\n */\n", "func_signal": "void destruct_object (object_t * ob)", "code": "{\n    object_t **pp;\n    //int removed;\n#ifndef NO_ENVIRONMENT\n    object_t *super;\n    object_t *save_restrict_destruct = restrict_destruct;\n\n    if (restrict_destruct && restrict_destruct != ob)\n        error(\"Only this_object() can be destructed from move_or_destruct.\\n\");\n#endif\n\n#if defined(PACKAGE_SOCKETS) || defined(PACKAGE_EXTERNAL)\n    /*\n     * check if object has an efun socket referencing it for a callback. if\n     * so, close the efun socket.\n     */\n    if (ob->flags & O_EFUN_SOCKET) {\n        close_referencing_sockets(ob);\n    }\n#endif\n#ifdef PACKAGE_PARSER\n    if (ob->pinfo) {\n        parse_free(ob->pinfo);\n        ob->pinfo = 0;\n    }\n#endif\n\n    if (ob->flags & O_DESTRUCTED) {\n        return;\n    }\n    remove_object_from_stack(ob);\n    /*\n     * If this is the first object being shadowed by another object, then\n     * destruct the whole list of shadows.\n     */\n#ifndef NO_SHADOWS\n    if (ob->shadowed && !ob->shadowing) {\n        object_t *otmp;\n        object_t *ob2;\n\n        /*\n         * move from bottom to top of shadow chain\n         */\n        for (ob2 = ob->shadowed; ob2->shadowed; ob2 = ob2->shadowed);\n        /*\n         * remove shadows top...down being careful to unlink shadow being\n         * destructed from chain\n         */\n        for (; ob2;) {\n            otmp = ob2;\n            ob2 = ob2->shadowing;\n            if (ob2)\n                ob2->shadowed = 0;\n            otmp->shadowing = 0;\n            destruct_object(otmp);\n        }\n        return;\n    }\n    /*\n     * The chain of shadows is a double linked list. Take care to update it\n     * correctly.\n     */\n    if (ob->shadowing)\n        ob->shadowing->shadowed = ob->shadowed;\n    if (ob->shadowed)\n        ob->shadowed->shadowing = ob->shadowing;\n    ob->shadowing = 0;\n    ob->shadowed = 0;\n#endif\n\n    debug(d_flag, (\"Deobject_t /%s (ref %d)\", ob->obname, ob->ref));\n\n#ifndef NO_ENVIRONMENT\n    /* try to move our contents somewhere */\n    super = ob->super;\n\n    while (ob->contains) {\n        object_t *otmp;\n\n        otmp = ob->contains;\n        /*\n         * An error here will not leave destruct() in an inconsistent\n         * stage.\n         */\n        push_object(super);\n\n        restrict_destruct = ob->contains;\n        (void)apply(APPLY_MOVE, ob->contains, 1, ORIGIN_DRIVER);\n        restrict_destruct = save_restrict_destruct;\n        /* OUCH! we could be dested by this. -Beek */\n        if (ob->flags & O_DESTRUCTED) return;\n        if (otmp == ob->contains)\n            destruct_object(otmp);\n    }\n#endif\n\n#ifdef PACKAGE_MUDLIB_STATS\n    add_objects(&ob->stats, -1);\n#endif\n#ifdef OLD_ED\n    if (ob->interactive && ob->interactive->ed_buffer)\n        save_ed_buffer(ob);\n#else\n    if (ob->flags & O_IN_EDIT) {\n        object_save_ed_buffer(ob);\n        ob->flags &= ~O_IN_EDIT;\n    }\n#endif\n#ifndef NO_SNOOP\n    if (ob->flags & O_SNOOP) {\n        int i;\n        for (i = 0; i < max_users; i++) {\n            if (all_users[i] && all_users[i]->snooped_by == ob)\n                all_users[i]->snooped_by = 0;\n        }\n        ob->flags &= ~O_SNOOP;\n    }\n#endif\n#ifndef NO_ENVIRONMENT\n    /*\n     * Remove us out of this current room (if any). Remove all sentences\n     * defined by this object from all objects here.\n     */\n    if (ob->super) {\n#ifndef NO_LIGHT\n        add_light(ob->super, -ob->total_light);\n#endif\n        remove_sent(ob->super, ob);\n        remove_sent(ob, ob->super);\n        for (pp = &ob->super->contains; *pp;) {\n            remove_sent(*pp, ob);\n            if (*pp != ob) {\n                remove_sent(ob, *pp);\n                pp = &(*pp)->next_inv;\n            } else {\n                *pp = (*pp)->next_inv;\n            }\n        }\n    }\n#endif\n\n    /* At this point, we can still back out, but this is the very last\n     * minute we can do so.  Make sure we have a new object to replace\n     * us if this is a vital object.\n     */\n    if (ob == master_ob || ob == simul_efun_ob) {\n        object_t *new_ob, *tmp_ob;\n        const char *tmp = ob->obname;\n\n        STACK_INC;\n        sp->type = T_ERROR_HANDLER;\n        sp->u.error_handler = fix_object_names;\n        saved_master_name = master_ob->obname;\n        saved_simul_name = simul_efun_ob->obname;\n\n        /* hack to make sure we don't find ourselves at several points\n           in the following process */\n        SETOBNAME(ob, \"\");\n\n        /* handle these two carefully, since they are rather vital */\n        new_ob = load_object(tmp, compiled_version);\n        if (!new_ob) {\n            SETOBNAME(ob, tmp);\n            sp--;\n            error(\"Destruct on vital object failed: new copy failed to reload.\");\n        }\n\n        if (ob == master_ob)\n            set_master(new_ob);\n        if (ob == simul_efun_ob)\n            set_simul_efun(new_ob);\n\n        /* Set the name back so we can remove it from the hash table.\n           Also be careful not to remove the new object, which has\n           the same name. */\n        sp--; /* error handler */\n        SETOBNAME(ob, tmp);\n        tmp = new_ob->obname;\n        SETOBNAME(new_ob, \"\");\n        remove_object_hash(ob);\n        SETOBNAME(new_ob, tmp);\n\ttmp_ob = ob;\n\tfree_object(&tmp_ob, \"vital object reference\");\n\t// still need ob below!\n    } else\n        remove_object_hash(ob);\n\n    /*\n     * Now remove us out of the list of all objects. This must be done last,\n     * because an error in the above code would halt execution.\n     */\n    //removed = 0;\n    if(ob->prev_all){\n        ob->prev_all->next_all = ob->next_all;\n        if(ob->next_all)\n            ob->next_all->prev_all = ob->prev_all;\n    }else{\n        obj_list = ob->next_all;\n        obj_list->prev_all = 0;\n    }\n    /*\n    for (pp = &obj_list; *pp; pp = &(*pp)->next_all) {\n        if (*pp != ob)\n            continue;\n        *pp = (*pp)->next_all;\n        removed = 1;\n        break;\n\t}\n\tDEBUG_CHECK(!removed, \"Failed to delete object.\\n\");//*/\n\n    remove_living_name(ob);\n#ifndef NO_ENVIRONMENT\n    ob->super = 0;\n    ob->next_inv = 0;\n    ob->contains = 0;\n#endif\n    ob->next_all = obj_list_destruct;\n    if(obj_list_destruct)\n      obj_list_destruct->prev_all = ob;\n    ob->prev_all = 0;\n    obj_list_destruct = ob;\n    set_heart_beat(ob, 0);\n    ob->flags |= O_DESTRUCTED;\n    /* moved this here from destruct2() -- see comments in destruct2() */\n    if (ob->interactive)\n        remove_interactive(ob, 1);\n#ifdef F_SET_HIDE\n    if (ob->flags & O_HIDDEN)\n        num_hidden--;\n#endif\n}", "path": "driver\\fluffos\\simulate.c", "repo_name": "dyher/dock9", "stars": 0, "license": "None", "language": "c", "size": 12716}
{"docstring": "/* Currently, this procedure handles:\n * - jump threading\n */\n", "func_signal": "void\noptimize_icode (char * start, char * pc, char * end)", "code": "{\n    int instr;\n    if (start == 0) {\n        /* we don't optimize the initializer block right now b/c all the\n         * stuff we do (jump threading, etc) can't occur there.\n         */\n        start = mem_block[A_PROGRAM].block;\n        pc = start;\n        end = pc + mem_block[A_PROGRAM].current_size;\n        if (*pc == 0) {\n            /* no initializer jump */\n            pc += 3;\n        }\n    }\n    while (pc < end) {\n        switch (instr = EXTRACT_UCHAR(pc++)) {\n#if SIZEOF_LONG == 4\n        case F_NUMBER:\n#endif\n        case F_REAL:\n        case F_CALL_INHERITED:\n            pc += 4;\n            break;\n#if SIZEOF_LONG == 8\n\tcase F_NUMBER:\n\t    pc += 8;\n\t    break;\n#endif\n        case F_SIMUL_EFUN:\n        case F_CALL_FUNCTION_BY_ADDRESS:\n            pc += 3;\n            break;\n        case F_BRANCH:\n        case F_BRANCH_WHEN_ZERO:\n        case F_BRANCH_WHEN_NON_ZERO:\n        case F_BBRANCH:\n        case F_BBRANCH_WHEN_ZERO:\n        case F_BBRANCH_WHEN_NON_ZERO:\n            {\n                char *tmp;\n                short sarg;\n                /* thread jumps */\n                COPY_SHORT(&sarg, pc);\n                if (instr > F_BRANCH)\n                    tmp = pc - sarg;\n                else\n                    tmp = pc + sarg;\n                sarg = 0;\n                while (1) {\n                    if (EXTRACT_UCHAR(tmp) == F_BRANCH) {\n                        COPY_SHORT(&sarg, tmp + 1);\n                        tmp += sarg + 1;\n                    } else if (EXTRACT_UCHAR(tmp) == F_BBRANCH) {\n                        COPY_SHORT(&sarg, tmp + 1);\n                        tmp -= sarg - 1;\n                    } else break;\n                }\n                if (!sarg) {\n                    pc += 2;\n                    break;\n                }\n                /* be careful; in the process of threading a forward jump\n                 * may have changed to a reverse one or vice versa\n                 */\n                if (tmp > pc) {\n                    if (instr > F_BRANCH) {\n                        pc[-1] -= 3;   /* change to forward branch */\n                    }\n                    sarg = tmp - pc;\n                } else {\n                    if (instr <= F_BRANCH) {\n                        pc[-1] += 3;   /* change to backwards branch */\n                    }\n                    sarg = pc - tmp;\n                }\n                STORE_SHORT(pc, sarg);\n                break;\n            }\n#ifdef F_LOR\n        case F_LOR:\n        case F_LAND:\n            {\n                char *tmp;\n                short sarg;\n                /* thread jumps */\n                COPY_SHORT(&sarg, pc);\n                tmp = pc + sarg;\n                sarg = 0;\n                while (1) {\n                    if (EXTRACT_UCHAR(tmp) == F_BRANCH) {\n                        COPY_SHORT(&sarg, tmp + 1);\n                        tmp += sarg + 1;\n                    } else if (EXTRACT_UCHAR(tmp) == F_BBRANCH) {\n                        COPY_SHORT(&sarg, tmp + 1);\n                        tmp -= sarg - 1;\n                    } else break;\n                }\n                if (!sarg) {\n                    pc += 2;\n                    break;\n                }\n                /* be careful; in the process of threading a forward jump\n                 * may have changed to a reverse one or vice versa\n                 */\n                if (tmp > pc) {\n                    sarg = tmp - pc;\n                } else {\n#ifdef DEBUG\n                    fprintf(stderr,\"Optimization failed; can't || or && backwards.\\n\");\n#endif\n                    pc += 2;\n                    break;\n                }\n                STORE_SHORT(pc, sarg);\n                break;\n            }\n#endif\n        case F_CATCH:\n        case F_AGGREGATE:\n        case F_AGGREGATE_ASSOC:\n        case F_STRING:\n#ifdef F_JUMP_WHEN_ZERO\n        case F_JUMP_WHEN_ZERO:\n        case F_JUMP_WHEN_NON_ZERO:\n#endif\n#ifdef F_JUMP\n        case F_JUMP:\n#endif\n            pc += 2;\n            break;\n        case F_GLOBAL_LVALUE:\n        case F_GLOBAL:\n        case F_SHORT_STRING:\n        case F_LOOP_INCR:\n        case F_WHILE_DEC:\n        case F_LOCAL:\n        case F_LOCAL_LVALUE:\n        case F_REF:\n        case F_REF_LVALUE:\n        case F_SSCANF:\n        case F_PARSE_COMMAND:\n        case F_BYTE:\n        case F_NBYTE:\n            pc++;\n            break;\n        case F_FUNCTION_CONSTRUCTOR:\n            switch (EXTRACT_UCHAR(pc++)) {\n            case FP_SIMUL:\n            case FP_LOCAL:\n                pc += 2;\n                break;\n            case FP_FUNCTIONAL:\n            case FP_FUNCTIONAL | FP_NOT_BINDABLE:\n                pc += 3;\n                break;\n            case FP_ANONYMOUS:\n            case FP_ANONYMOUS | FP_NOT_BINDABLE:\n                pc += 4;\n                break;\n            case FP_EFUN:\n                pc += 2;\n                break;\n            }\n            break;\n        case F_SWITCH:\n            {\n                unsigned short stable, etable;\n                pc++; /* table type */\n                LOAD_SHORT(stable, pc);\n                LOAD_SHORT(etable, pc);\n                pc += 2; /* def */\n                DEBUG_CHECK(stable < pc - start || etable < pc - start\n                            || etable < stable,\n                            \"Error in switch table found while optimizing\\n\");\n                /* recursively optimize the inside of the switch */\n                optimize_icode(start, pc, start + stable);\n                pc = start + etable;\n                break;\n            }\n        case F_EFUN0:\n        case F_EFUN1:\n        case F_EFUN2:\n        case F_EFUN3:\n        case F_EFUNV:\n            instr = EXTRACT_UCHAR(pc++) + ONEARG_MAX;\n        default:\n            if ((instr >= BASE) &&\n                (instrs[instr].min_arg != instrs[instr].max_arg))\n                pc++;\n        }\n    }\n}", "path": "driver\\rth\\icode.c", "repo_name": "dyher/dock9", "stars": 0, "license": "None", "language": "c", "size": 12716}
{"docstring": "/*\n * Store a 4 byte number. It is stored in such a way as to be sure\n * that correct byte order is used, regardless of machine architecture.\n */\n", "func_signal": "static void ins_int (long l)", "code": "{\n\n    if (prog_code + SIZEOF_LONG > prog_code_max) {\n        mem_block_t *mbp = &mem_block[A_PROGRAM];\n        UPDATE_PROGRAM_SIZE;\n        realloc_mem_block(mbp);\n\n        prog_code = mbp->block + mbp->current_size;\n        prog_code_max = mbp->block + mbp->max_size;\n    }\n    STORE_INT(prog_code, l);\n}", "path": "driver\\rth\\icode.c", "repo_name": "dyher/dock9", "stars": 0, "license": "None", "language": "c", "size": 12716}
{"docstring": "/*\n * This one is called from the command \"shutdown\".\n * We don't call it directly from HUP, because it is dangerous when being\n * in an interrupt.\n */\n", "func_signal": "void shutdownMudOS (int exit_code)", "code": "{\n    int i;\n\n    shout_string(\"FluffOS driver shouts: shutting down immediately.\\n\");\n#ifdef PACKAGE_MUDLIB_STATS\n    save_stat_files();\n#endif\n#ifdef PACKAGE_DB\n    db_cleanup();\n#endif\n    ipc_remove();\n#if defined(PACKAGE_SOCKETS) || defined(PACKAGE_EXTERNAL)\n    for (i = 0; i < max_lpc_socks; i++) {\n        if (lpc_socks[i].state == STATE_CLOSED) continue;\n        while (OS_socket_close(lpc_socks[i].fd) == -1 && errno == EINTR)\n            ;\n    }\n#endif\n    for (i = 0; i < max_users; i++) {\n        if (all_users[i] && !(all_users[i]->iflags & CLOSING))\n            flush_message(all_users[i]);\n    }\n#ifdef PROFILING\n    monitor(0, 0, 0, 0, 0);     /* cause gmon.out to be written */\n#endif\n    exit(exit_code);\n}", "path": "driver\\fluffos\\simulate.c", "repo_name": "dyher/dock9", "stars": 0, "license": "None", "language": "c", "size": 12716}
{"docstring": "/* Find an object. If not loaded, load it !\n * The object may selfdestruct, which is the only case when 0 will be\n * returned.\n */\n", "func_signal": "object_t *find_object (const char * str)", "code": "{\n    object_t *ob;\n    char tmpbuf[MAX_OBJECT_NAME_SIZE];\n\n    if (!strip_name(str, tmpbuf, sizeof tmpbuf))\n        return 0;\n\n    if ((ob = lookup_object_hash(tmpbuf))) {\n        return ob;\n    }\n    ob = load_object(tmpbuf, 0);\n    if (!ob || (ob->flags & O_DESTRUCTED))      /* *sigh* */\n        return 0;\n    return ob;\n}", "path": "driver\\fluffos\\simulate.c", "repo_name": "dyher/dock9", "stars": 0, "license": "None", "language": "c", "size": 12716}
{"docstring": "/*\n * Generate the code to push a number on the stack.\n * This varies since there are several opcodes (for\n * optimizing speed and/or size).\n */\n", "func_signal": "static void write_small_number (int val)", "code": "{\n    if (try_to_push(PUSH_NUMBER, val)) return;\n    ins_byte(F_BYTE);\n    ins_byte(val);\n}", "path": "driver\\rth\\icode.c", "repo_name": "dyher/dock9", "stars": 0, "license": "None", "language": "c", "size": 12716}
{"docstring": "/*\n * Every object has a count of the number of light sources it contains.\n * Update this.\n */\n", "func_signal": "void add_light (object_t * p, int n)", "code": "{\n    if (n == 0)\n        return;\n    p->total_light += n;\n#ifndef NO_ENVIRONMENT\n    while ((p = p->super))\n        p->total_light += n;\n#endif\n}", "path": "driver\\fluffos\\simulate.c", "repo_name": "dyher/dock9", "stars": 0, "license": "None", "language": "c", "size": 12716}
{"docstring": "/* Look for a loaded object. Return 0 if non found. */\n", "func_signal": "object_t *find_object2 (const char * str)", "code": "{\n    register object_t *ob;\n    char p[MAX_OBJECT_NAME_SIZE];\n\n    if (!strip_name(str, p, sizeof p))\n        return 0;\n\n    if ((ob = lookup_object_hash(p))) {\n        return ob;\n    }\n    return 0;\n}", "path": "driver\\fluffos\\simulate.c", "repo_name": "dyher/dock9", "stars": 0, "license": "None", "language": "c", "size": 12716}
{"docstring": "//\n// F_PUSH pushes multiple data items onto the stack.  This function\n// sets up the multi push by reading the single push off the top of\n// the stack and rewriting the mult-push into the stack.\n//\n", "func_signal": "static void initialize_push (void)", "code": "{\n    int what = mem_block[A_PROGRAM].block[push_start];\n    int arg = 0;\n\n    // This is only valid if it is not a one byte const target.\n    if (what != F_CONST0 && what != F_CONST1) {\n       arg = mem_block[A_PROGRAM].block[push_start + 1];\n    }\n    prog_code = mem_block[A_PROGRAM].block + push_start;\n    ins_byte(F_PUSH);\n    push_start++; /* now points to the zero here */\n    ins_byte(0);\n\n    switch (what) {\n    case F_CONST0:\n        ins_byte(PUSH_NUMBER | 0);\n        break;\n    case F_CONST1:\n        ins_byte(PUSH_NUMBER | 1);\n        break;\n    case F_BYTE:\n        ins_byte(PUSH_NUMBER | arg);\n        break;\n    case F_SHORT_STRING:\n        ins_byte(PUSH_STRING | arg);\n        break;\n    case F_LOCAL:\n        ins_byte(PUSH_LOCAL | arg);\n        break;\n    case F_GLOBAL:\n        ins_byte(PUSH_GLOBAL | arg);\n        break;\n    }\n}", "path": "driver\\rth\\icode.c", "repo_name": "dyher/dock9", "stars": 0, "license": "None", "language": "c", "size": 12716}
{"docstring": "/*\n * Call this one when there is only little memory left. It will start\n * Armageddon.\n */\n", "func_signal": "void slow_shut_down (int minutes)", "code": "{\n    /*\n     *free some memory.\n     */\n    svalue_t *amo;\n\n    push_number(minutes);\n    amo = apply_master_ob(APPLY_SLOW_SHUTDOWN, 1);\n    /* in this case, approved means the mudlib will handle it */\n    if (!MASTER_APPROVED(amo))\n    {\n        object_t *save_current = current_object;\n\n        current_object = 0;\n        save_command_giver(0);\n        shout_string(\"FluffOS driver shouts: Out of memory.\\n\");\n        restore_command_giver();\n        current_object = save_current;\n#ifdef SIGNAL_FUNC_TAKES_INT\n        startshutdownMudOS(1);\n#else\n        startshutdownMudOS();\n#endif\n        return;\n    }\n}", "path": "driver\\fluffos\\simulate.c", "repo_name": "dyher/dock9", "stars": 0, "license": "None", "language": "c", "size": 12716}
{"docstring": "/*\n * Transfer an object.\n * The object has to be taken from one inventory list and added to another.\n * The main work is to update all command definitions, depending on what is\n * living or not. Note that all objects in the same inventory are affected.\n */\n", "func_signal": "void move_object (object_t * item, object_t * dest)", "code": "{\n    object_t **pp, *ob;\n\n    save_command_giver(command_giver);\n\n    /* Recursive moves are not allowed. */\n    for (ob = dest; ob; ob = ob->super)\n        if (ob == item)\n            error(\"Can't move object inside itself.\\n\");\n#ifndef NO_SHADOWS\n    if (item->shadowing)\n        error(\"Can't move an object that is shadowing.\\n\");\n#endif\n\n#if !defined(NO_RESETS) && defined(LAZY_RESETS)\n    try_reset(dest);\n#endif\n#ifndef NO_LIGHT\n    add_light(dest, item->total_light);\n#endif\n    if (item->super) {\n        int okay = 0;\n\n        remove_sent(item->super, item);\n        remove_sent(item, item->super);\n#ifndef NO_LIGHT\n        add_light(item->super, -item->total_light);\n#endif\n        for (pp = &item->super->contains; *pp;) {\n            if (*pp != item) {\n                remove_sent(item, *pp);\n                remove_sent(*pp, item);\n                pp = &(*pp)->next_inv;\n                continue;\n            }\n            /*\n             * unlink object from original inventory list\n             */\n            *pp = item->next_inv;\n            okay = 1;\n        }\n#ifdef DEBUG\n        if (!okay)\n            fatal(\"Failed to find object /%s in super list of /%s.\\n\",\n                  item->obname, item->super->obname);\n#endif\n    }\n    /*\n     * link object into target's inventory list\n     */\n    item->next_inv = dest->contains;\n    dest->contains = item;\n    item->super = dest;\n\n    setup_new_commands(dest, item);\n    restore_command_giver();\n}", "path": "driver\\fluffos\\simulate.c", "repo_name": "dyher/dock9", "stars": 0, "license": "None", "language": "c", "size": 12716}
{"docstring": "/*\n * This one is called when no program is executing from the main loop.\n */\n", "func_signal": "void destruct2 (object_t * ob)", "code": "{\n#ifndef NO_ADD_ACTION\n    sentence_t *s;\n#endif\n\n    debug(d_flag, (\"Destruct-2 object /%s (ref %d)\", ob->obname, ob->ref));\n\n    /*\n     * We must deallocate variables here, not in 'free_object()'. That is\n     * because one of the local variables may point to this object, and\n     * deallocation of this pointer will also decrease the reference count of\n     * this object. Otherwise, an object with a variable pointing to itself,\n     * would never be freed. Just in case the program in this object would\n     * continue to execute, change string and object variables into the\n     * number 0.\n     */\n    if (ob->prog->num_variables_total > 0) {\n        /*\n         * Deallocate variables in this object. The space of the variables\n         * are not deallocated until the object structure is freed in\n         * free_object().\n         */\n        int i;\n\n        for (i = 0; i < ob->prog->num_variables_total; i++) {\n            free_svalue(&ob->variables[i], \"destruct2\");\n            ob->variables[i] = const0u;\n        }\n    }\n\n#ifndef NO_ADD_ACTION\n    /*\n     * For much the same reason as described above, we must remove sentences\n     * for this object.  The reason is because the sentence callback could be\n     * a function pointer that is bound to this object and thus holds a\n     * reference to this object.\n     */\n    for (s = ob->sent; s;) {\n        sentence_t *next;\n\n        next = s->next;\n        free_sentence(s);\n        s = next;\n    }\n    ob->sent = 0;\n#endif\n\n#ifdef DEBUG\n    tot_dangling_object++;\n    ob->next_all = obj_list_dangling;\n    if(obj_list_dangling)\n       obj_list_dangling->prev_all = ob;\n    obj_list_dangling = ob;\n    ob->prev_all = 0;\n#endif\n\n    free_object(&ob, \"destruct_object\");\n}", "path": "driver\\fluffos\\simulate.c", "repo_name": "dyher/dock9", "stars": 0, "license": "None", "language": "c", "size": 12716}
{"docstring": "/* equivalent to strcpy(x, y); return x + strlen(y), but faster and safer */\n/* Code like:\n *\n * char buf[256];\n * strcpy(buf, ...);\n * strcat(buf, ...);\n * strcat(buf, ...);\n *\n * Should be replaced with:\n *\n * char buf[256];\n * char *p, *end = EndOf(buf);\n * p = strput(buf, end, ...);\n * p = strput(p, end, ...);\n * p = strput(p, end, ...);\n */\n", "func_signal": "char *strput (char * x, char * limit, const char * y)", "code": "{\n    while ((*x++ = *y++)) {\n        if (x == limit) {\n            *(x-1) = 0;\n            break;\n        }\n    }\n    return x - 1;\n}", "path": "driver\\fluffos\\simulate.c", "repo_name": "dyher/dock9", "stars": 0, "license": "None", "language": "c", "size": 12716}
{"docstring": "/*\n * If there is a simul_efun file, then take care of it and extract all\n * information we need.\n */\n", "func_signal": "void init_simul_efun (char * file)", "code": "{\n    char buf[512];\n    object_t *new_ob;\n    \n    if (!file || !file[0]) {\n        fprintf(stderr, \"No simul_efun\\n\");\n        return;\n    }\n    if (!strip_name(file, buf, sizeof buf))\n        error(\"Ilegal simul_efun file name '%s'\\n\", file);\n    \n    if (file[strlen(file) - 2] != '.')\n        strcat(buf, \".c\");\n\n    new_ob = load_object(buf, compiled_version);\n    if (new_ob == 0) {\n        fprintf(stderr, \"The simul_efun file %s was not loaded.\\n\", buf);\n        exit(-1);\n    }\n    set_simul_efun(new_ob);\n}", "path": "driver\\fluffos\\simul_efun.c", "repo_name": "dyher/dock9", "stars": 0, "license": "None", "language": "c", "size": 12716}
{"docstring": "/*\n * Define a new simul_efun\n */\n", "func_signal": "static void\nfind_or_add_simul_efun (function_t * funp, int runtime_index)", "code": "{\n    ident_hash_elem_t *ihe;\n    int first = 0;\n    int last = num_simul_efun - 1;\n    int i,j;\n    \n    while (first <= last) {\n        j = ((first + last) >> 1);\n        if (funp->funcname < simul_names[j].name) last = j - 1;\n        else if (funp->funcname > simul_names[j].name) first = j + 1;\n        else {\n            ihe = find_or_add_perm_ident(simul_names[j].name);\n            ihe->token |= IHE_SIMUL;\n            ihe->token &= ~IHE_ORPHAN;\n            ihe->sem_value++;\n            ihe->dn.simul_num = simul_names[j].index;\n            simuls[simul_names[j].index].index = runtime_index;\n            simuls[simul_names[j].index].func = funp;\n            return;\n        }\n    }\n    for (i=num_simul_efun - 1; i > last; i--)\n        simul_names[i+1] = simul_names[i];\n    simuls[num_simul_efun].index = runtime_index;\n    simuls[num_simul_efun].func = funp;\n    simul_names[first].name = funp->funcname;\n    simul_names[first].index = num_simul_efun;\n    ihe = find_or_add_perm_ident(funp->funcname);\n    ihe->token |= IHE_SIMUL;\n    ihe->token &= ~IHE_ORPHAN;\n    ihe->sem_value++;\n    ihe->dn.simul_num = num_simul_efun++;\n    ref_string(funp->funcname);\n}", "path": "driver\\fluffos\\simul_efun.c", "repo_name": "dyher/dock9", "stars": 0, "license": "None", "language": "c", "size": 12716}
{"docstring": "/*\n * This is here because throw constructs its own return value; we dont\n * want to replace it with the system's error string.\n */\n", "func_signal": "void throw_error()", "code": "{\n    if (((current_error_context->save_csp + 1)->framekind & FRAME_MASK) == FRAME_CATCH) {\n        LONGJMP(current_error_context->context, 1);\n        fatal(\"Throw_error failed!\");\n    }\n    error(\"Throw with no catch.\\n\");\n}", "path": "driver\\fluffos\\simulate.c", "repo_name": "dyher/dock9", "stars": 0, "license": "None", "language": "c", "size": 12716}
{"docstring": "/*\n** access functions (stack -> C)\n*/\n", "func_signal": "LUA_API int lua_type (lua_State *L, int idx)", "code": "{\n  StkId o = luaA_indexAcceptable(L, idx);\n  return (o == NULL) ? LUA_TNONE : ttype(o);\n}", "path": "src\\shared\\lua\\lapi.c", "repo_name": "madhatternc/mangos2", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 27301}
{"docstring": "/*\n** check whether list has any jump that do not produce a value\n** (or produce an inverted value)\n*/\n", "func_signal": "static int need_value (FuncState *fs, int list)", "code": "{\n  for (; list != NO_JUMP; list = getjump(fs, list)) {\n    Instruction i = *getjumpcontrol(fs, list);\n    if (GET_OPCODE(i) != OP_TESTSET) return 1;\n  }\n  return 0;  /* not found */\n}", "path": "dep\\src\\lua\\lcode.c", "repo_name": "madhatternc/mangos2", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 27301}
{"docstring": "/*\n** load precompiled chunk\n*/\n", "func_signal": "Proto* luaU_undump (lua_State* L, ZIO* Z, Mbuffer* buff)", "code": "{\n LoadState S;\n const char* s=zname(Z);\n if (*s=='@' || *s=='=')\n  S.name=s+1;\n else if (*s==LUA_SIGNATURE[0])\n  S.name=\"binary string\";\n else\n  S.name=s;\n S.L=L;\n S.Z=Z;\n S.b=buff;\n return LoadChunk(&S);\n}", "path": "src\\shared\\lua\\lundump.c", "repo_name": "madhatternc/mangos2", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 27301}
{"docstring": "/*\n** find byte order\n*/\n", "func_signal": "int luaU_endianness (void)", "code": "{\n int x=1;\n return *(char*)&x;\n}", "path": "src\\shared\\lua\\lundump.c", "repo_name": "madhatternc/mangos2", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 27301}
{"docstring": "/* }====================================================== */\n", "func_signal": "static void *l_alloc (void *ud, void *ptr, size_t osize, size_t nsize)", "code": "{\n  (void)ud;\n  (void)osize;\n  if (nsize == 0) {\n    free(ptr);\n    return NULL;\n  }\n  else\n    return realloc(ptr, nsize);\n}", "path": "dep\\src\\lua\\lauxlib.c", "repo_name": "madhatternc/mangos2", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 27301}
{"docstring": "/* }====================================================== */\n", "func_signal": "LUALIB_API const char *luaL_gsub (lua_State *L, const char *s, const char *p,\n                                                               const char *r)", "code": "{\n  const char *wild;\n  size_t l = strlen(p);\n  luaL_Buffer b;\n  luaL_buffinit(L, &b);\n  while ((wild = strstr(s, p)) != NULL) {\n    luaL_addlstring(&b, s, wild - s);  /* push prefix */\n    luaL_addstring(&b, r);  /* push replacement in place of pattern */\n    s = wild + l;  /* continue after `p' */\n  }\n  luaL_addstring(&b, s);  /* push last suffix */\n  luaL_pushresult(&b);\n  return lua_tostring(L, -1);\n}", "path": "dep\\src\\lua\\lauxlib.c", "repo_name": "madhatternc/mangos2", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 27301}
{"docstring": "/* }====================================================== */\n", "func_signal": "LUALIB_API int luaL_ref (lua_State *L, int t)", "code": "{\n  int ref;\n  t = abs_index(L, t);\n  if (lua_isnil(L, -1)) {\n    lua_pop(L, 1);  /* remove from stack */\n    return LUA_REFNIL;  /* `nil' has a unique fixed reference */\n  }\n  lua_rawgeti(L, t, FREELIST_REF);  /* get first free element */\n  ref = (int)lua_tointeger(L, -1);  /* ref = t[FREELIST_REF] */\n  lua_pop(L, 1);  /* remove it from stack */\n  if (ref != 0) {  /* any free element? */\n    lua_rawgeti(L, t, ref);  /* remove it from list */\n    lua_rawseti(L, t, FREELIST_REF);  /* (t[FREELIST_REF] = t[ref]) */\n  }\n  else {  /* no free elements */\n    ref = (int)lua_objlen(L, t);\n    ref++;  /* create new reference */\n  }\n  lua_rawseti(L, t, ref);\n  return ref;\n}", "path": "dep\\src\\lua\\lauxlib.c", "repo_name": "madhatternc/mangos2", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 27301}
{"docstring": "/*\n** returns current `pc' and marks it as a jump target (to avoid wrong\n** optimizations with consecutive instructions not in the same basic block).\n*/\n", "func_signal": "int luaK_getlabel (FuncState *fs)", "code": "{\n  fs->lasttarget = fs->pc;\n  return fs->pc;\n}", "path": "dep\\src\\lua\\lcode.c", "repo_name": "madhatternc/mangos2", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 27301}
{"docstring": "/* ------------------------------------------------------------------------ */\n", "func_signal": "char *luaZ_openspace (lua_State *L, Mbuffer *buff, size_t n)", "code": "{\n  if (n > buff->buffsize) {\n    if (n < LUA_MINBUFFER) n = LUA_MINBUFFER;\n    luaZ_resizebuffer(L, buff, n);\n  }\n  return buff->buffer;\n}", "path": "dep\\src\\lua\\lzio.c", "repo_name": "madhatternc/mangos2", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 27301}
{"docstring": "/*\n** `load' and `call' functions (run Lua code)\n*/\n", "func_signal": "LUA_API void lua_call (lua_State *L, int nargs, int nresults)", "code": "{\n  StkId func;\n  lua_lock(L);\n  api_checknelems(L, nargs+1);\n  func = L->top - (nargs+1);\n  luaD_call(L, func, nresults);\n  lua_unlock(L);\n}", "path": "src\\shared\\lua\\lapi.c", "repo_name": "madhatternc/mangos2", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 27301}
{"docstring": "/*\n** set functions (stack -> Lua)\n*/\n", "func_signal": "LUA_API void lua_settable (lua_State *L, int idx)", "code": "{\n  StkId t;\n  lua_lock(L);\n  api_checknelems(L, 2);\n  t = luaA_index(L, idx);\n  luaV_settable(L, t, L->top - 2, L->top - 1);\n  L->top -= 2;  /* pop index and value */\n  lua_unlock(L);\n}", "path": "src\\shared\\lua\\lapi.c", "repo_name": "madhatternc/mangos2", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 27301}
{"docstring": "/* this function handles only `%d', `%c', %f, and `%s' formats */\n", "func_signal": "const char *luaO_pushvfstring (lua_State *L, const char *fmt, va_list argp)", "code": "{\n  int n = 1;\n  pushstr(L, \"\");\n  for (;;) {\n    const char *e = strchr(fmt, '%');\n    if (e == NULL) break;\n    setsvalue2s(L->top, luaS_newlstr(L, fmt, e-fmt));\n    incr_top(L);\n    switch (*(e+1)) {\n      case 's':\n        pushstr(L, va_arg(argp, char *));\n        break;\n      case 'c': {\n        char buff[2];\n        buff[0] = cast(char, va_arg(argp, int));\n        buff[1] = '\\0';\n        pushstr(L, buff);\n        break;\n      }\n      case 'd':\n        setnvalue(L->top, cast(lua_Number, va_arg(argp, int)));\n        incr_top(L);\n        break;\n      case 'f':\n        setnvalue(L->top, cast(lua_Number, va_arg(argp, l_uacNumber)));\n        incr_top(L);\n        break;\n      case '%':\n        pushstr(L, \"%\");\n        break;\n      default: lua_assert(0);\n    }\n    n += 2;\n    fmt = e+2;\n  }\n  pushstr(L, fmt);\n  luaV_concat(L, n+1, L->top - L->base - 1);\n  L->top -= n;\n  return svalue(L->top - 1);\n}", "path": "src\\shared\\lua\\lobject.c", "repo_name": "madhatternc/mangos2", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 27301}
{"docstring": "/* --------------------------------------------------------------- read --- */\n", "func_signal": "size_t luaZ_read (ZIO *z, void *b, size_t n)", "code": "{\n  while (n) {\n    size_t m;\n    if (luaZ_lookahead(z) == EOZ)\n      return n;  /* return number of missing bytes */\n    m = (n <= z->n) ? n : z->n;  /* min. between n and z->n */\n    memcpy(b, z->p, m);\n    z->n -= m;\n    z->p += m;\n    b = (char *)b + m;\n    n -= m;\n  }\n  return 0;\n}", "path": "dep\\src\\lua\\lzio.c", "repo_name": "madhatternc/mangos2", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 27301}
{"docstring": "/*\n** dump Lua function as precompiled chunk\n*/\n", "func_signal": "int luaU_dump (lua_State* L, const Proto* f, lua_Writer w, void* data, int strip)", "code": "{\n DumpState D;\n D.L=L;\n D.writer=w;\n D.data=data;\n D.strip=strip;\n D.status=0;\n DumpHeader(&D);\n DumpFunction(f,NULL,&D);\n return D.status;\n}", "path": "dep\\src\\lua\\ldump.c", "repo_name": "madhatternc/mangos2", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 27301}
{"docstring": "/* }====================================================== */\n", "func_signal": "LUALIB_API int luaL_checkoption (lua_State *L, int narg, const char *def,\n                                 const char *const lst[])", "code": "{\n  const char *name = (def) ? luaL_optstring(L, narg, def) :\n                             luaL_checkstring(L, narg);\n  int i;\n  for (i=0; lst[i]; i++)\n    if (strcmp(lst[i], name) == 0)\n      return i;\n  return luaL_argerror(L, narg,\n                       lua_pushfstring(L, \"invalid option \" LUA_QS, name));\n}", "path": "dep\\src\\lua\\lauxlib.c", "repo_name": "madhatternc/mangos2", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 27301}
{"docstring": "/*\n** get functions (Lua -> stack)\n*/\n", "func_signal": "LUA_API void lua_gettable (lua_State *L, int idx)", "code": "{\n  StkId t;\n  lua_lock(L);\n  t = luaA_index(L, idx);\n  setobj2s(L->top - 1, luaV_gettable(L, t, L->top - 1, 0));\n  lua_unlock(L);\n}", "path": "src\\shared\\lua\\lapi.c", "repo_name": "madhatternc/mangos2", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 27301}
{"docstring": "/*\n** Open string library\n*/\n", "func_signal": "LUALIB_API int luaopen_string (lua_State *L)", "code": "{\n  luaL_openlib(L, LUA_STRLIBNAME, strlib, 0);\n  return 1;\n}", "path": "src\\shared\\lua\\lib\\lstrlib.c", "repo_name": "madhatternc/mangos2", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 27301}
{"docstring": "/*\n** push functions (C -> stack)\n*/\n", "func_signal": "LUA_API void lua_pushnil (lua_State *L)", "code": "{\n  lua_lock(L);\n  setnilvalue(L->top);\n  api_incr_top(L);\n  lua_unlock(L);\n}", "path": "src\\shared\\lua\\lapi.c", "repo_name": "madhatternc/mangos2", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 27301}
{"docstring": "/* a signed version for size_t */\n", "func_signal": "static int str_len (lua_State *L)", "code": "{\n  size_t l;\n  luaL_checklstring(L, 1, &l);\n  lua_pushnumber(L, (lua_Number)l);\n  return 1;\n}", "path": "src\\shared\\lua\\lib\\lstrlib.c", "repo_name": "madhatternc/mangos2", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 27301}
{"docstring": "/*\n** generic allocation routine.\n*/\n", "func_signal": "void *luaM_realloc (lua_State *L, void *block, lu_mem oldsize, lu_mem size)", "code": "{\n  lua_assert((oldsize == 0) == (block == NULL));\n  if (size == 0) {\n    if (block != NULL) {\n      l_free(block, oldsize);\n      block = NULL;\n    }\n    else return NULL;  /* avoid `nblocks' computations when oldsize==size==0 */\n  }\n  else if (size >= MAX_SIZET)\n    luaG_runerror(L, \"memory allocation error: block too big\");\n  else {\n    block = l_realloc(block, oldsize, size);\n    if (block == NULL) {\n      if (L)\n        luaD_throw(L, LUA_ERRMEM);\n      else return NULL;  /* error before creating state! */\n    }\n  }\n  if (L) {\n    lua_assert(G(L) != NULL && G(L)->nblocks > 0);\n    G(L)->nblocks -= oldsize;\n    G(L)->nblocks += size;\n  }\n  return block;\n}", "path": "src\\shared\\lua\\lmem.c", "repo_name": "madhatternc/mangos2", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 27301}
{"docstring": "/*\tkill(pid)\t*/\n", "func_signal": "static VALUE my_kill(VALUE obj, VALUE pid)", "code": "{\n    int p = NUM2INT(pid);\n    MYSQL* m = GetHandler(obj);\n    if (mysql_kill(m, p) != 0)\n\tmysql_raise(m);\n    return obj;\n}", "path": "th-mysql-config=\\usr\\local\\mysql\\bin\\mysql_config\\gems\\mysql-2.8.1\\ext\\mysql_api\\mysql.c", "repo_name": "svewag/codecritics", "stars": 1, "license": "None", "language": "c", "size": 220}
{"docstring": "/*\tautocommit()\t*/\n", "func_signal": "static VALUE autocommit(VALUE obj, VALUE mode)", "code": "{\n    MYSQL* m = GetHandler(obj);\n    int f;\n    f = (mode == Qnil || mode == Qfalse || (rb_type(mode) == T_FIXNUM && NUM2INT(mode) == 0)) ? 0 : 1;\n    if (mysql_autocommit(m, f) != 0)\n        mysql_raise(m);\n    return obj;\n}", "path": "th-mysql-config=\\usr\\local\\mysql\\bin\\mysql_config\\gems\\mysql-2.8.1\\ext\\mysql_api\\mysql.c", "repo_name": "svewag/codecritics", "stars": 1, "license": "None", "language": "c", "size": 220}
{"docstring": "/*\tstat()\t\t*/\n", "func_signal": "static VALUE my_stat(VALUE obj)", "code": "{\n    MYSQL* m = GetHandler(obj);\n    const char* s = mysql_stat(m);\n    if (s == NULL)\n\tmysql_raise(m);\n    return rb_tainted_str_new2(s);\n}", "path": "th-mysql-config=\\usr\\local\\mysql\\bin\\mysql_config\\gems\\mysql-2.8.1\\ext\\mysql_api\\mysql.c", "repo_name": "svewag/codecritics", "stars": 1, "license": "None", "language": "c", "size": 220}
{"docstring": "/*\tattr_set(option, arg)\t*/\n", "func_signal": "static VALUE stmt_attr_set(VALUE obj, VALUE opt, VALUE val)", "code": "{\n    struct mysql_stmt* s = DATA_PTR(obj);\n    check_stmt_closed(obj);\n    if (NUM2INT(opt) == STMT_ATTR_UPDATE_MAX_LENGTH) {\n\tmy_bool arg;\n\targ = (val == Qnil || val == Qfalse) ? 0 : 1;\n\tmysql_stmt_attr_set(s->stmt, STMT_ATTR_UPDATE_MAX_LENGTH, &arg);\n\treturn obj;\n    }\n    rb_raise(eMysql, \"unknown option: %d\", NUM2INT(opt));\n}", "path": "th-mysql-config=\\usr\\local\\mysql\\bin\\mysql_config\\gems\\mysql-2.8.1\\ext\\mysql_api\\mysql.c", "repo_name": "svewag/codecritics", "stars": 1, "license": "None", "language": "c", "size": 220}
{"docstring": "/*\tresult_metadata()\t*/\n", "func_signal": "static VALUE stmt_result_metadata(VALUE obj)", "code": "{\n    struct mysql_stmt* s = DATA_PTR(obj);\n    MYSQL_RES *res;\n    check_stmt_closed(obj);\n    res = mysql_stmt_result_metadata(s->stmt);\n    if (res == NULL) {\n      if (mysql_stmt_errno(s->stmt) != 0)\n\tmysql_stmt_raise(s->stmt);\n      return Qnil;\n    }\n    return mysqlres2obj(res);\n}", "path": "th-mysql-config=\\usr\\local\\mysql\\bin\\mysql_config\\gems\\mysql-2.8.1\\ext\\mysql_api\\mysql.c", "repo_name": "svewag/codecritics", "stars": 1, "license": "None", "language": "c", "size": 220}
{"docstring": "/*\tprepare(query)\t*/\n", "func_signal": "static VALUE prepare(VALUE obj, VALUE query)", "code": "{\n    VALUE st;\n    st = stmt_init(obj);\n    return stmt_prepare(st, query);\n}", "path": "th-mysql-config=\\usr\\local\\mysql\\bin\\mysql_config\\gems\\mysql-2.8.1\\ext\\mysql_api\\mysql.c", "repo_name": "svewag/codecritics", "stars": 1, "license": "None", "language": "c", "size": 220}
{"docstring": "/*\tcheck if already freed\t*/\n", "func_signal": "static void check_free(VALUE obj)", "code": "{\n    struct mysql_res* resp = DATA_PTR(obj);\n    if (resp->freed == Qtrue)\n        rb_raise(eMysql, \"Mysql::Result object is already freed\");\n}", "path": "th-mysql-config=\\usr\\local\\mysql\\bin\\mysql_config\\gems\\mysql-2.8.1\\ext\\mysql_api\\mysql.c", "repo_name": "svewag/codecritics", "stars": 1, "license": "None", "language": "c", "size": 220}
{"docstring": "/*\toptions(opt, value=nil)\t*/\n", "func_signal": "static VALUE options(int argc, VALUE* argv, VALUE obj)", "code": "{\n    VALUE opt, val;\n    int n;\n    my_bool b;\n    char* v;\n    MYSQL* m = GetHandler(obj);\n\n    rb_scan_args(argc, argv, \"11\", &opt, &val);\n    switch(NUM2INT(opt)) {\n    case MYSQL_OPT_CONNECT_TIMEOUT:\n#if MYSQL_VERSION_ID >= 40100\n    case MYSQL_OPT_PROTOCOL:\n#endif\n#if MYSQL_VERSION_ID >= 40101\n    case MYSQL_OPT_READ_TIMEOUT:\n    case MYSQL_OPT_WRITE_TIMEOUT:\n#endif\n\tif (val == Qnil)\n\t    rb_raise(rb_eArgError, \"wrong # of arguments(1 for 2)\");\n\tn = NUM2INT(val);\n\tv = (char*)&n;\n\tbreak;\n    case MYSQL_INIT_COMMAND:\n    case MYSQL_READ_DEFAULT_FILE:\n    case MYSQL_READ_DEFAULT_GROUP:\n#if MYSQL_VERSION_ID >= 32349\n    case MYSQL_SET_CHARSET_DIR:\n    case MYSQL_SET_CHARSET_NAME:\n#endif\n#if MYSQL_VERSION_ID >= 40100\n    case MYSQL_SHARED_MEMORY_BASE_NAME:\n#endif\n#if MYSQL_VERSION_ID >= 40101\n    case MYSQL_SET_CLIENT_IP:\n#endif\n\tif (val == Qnil)\n\t    rb_raise(rb_eArgError, \"wrong # of arguments(1 for 2)\");\n\tv = StringValuePtr(val);\n\tbreak;\n#if MYSQL_VERSION_ID >= 40101\n    case MYSQL_SECURE_AUTH:\n\tif (val == Qnil || val == Qfalse)\n\t    b = 1;\n\telse\n\t    b = 0;\n\tv = (char*)&b;\n\tbreak;\n#endif\n#if MYSQL_VERSION_ID >= 32349\n    case MYSQL_OPT_LOCAL_INFILE:\n\tif (val == Qnil || val == Qfalse)\n\t    v = NULL;\n\telse {\n\t    n = 1;\n\t    v = (char*)&n;\n\t}\n\tbreak;\n#endif\n    default:\n\tv = NULL;\n    }\n\n    if (mysql_options(m, NUM2INT(opt), v) != 0)\n\trb_raise(eMysql, \"unknown option: %d\", NUM2INT(opt));\n    return obj;\n}", "path": "th-mysql-config=\\usr\\local\\mysql\\bin\\mysql_config\\gems\\mysql-2.8.1\\ext\\mysql_api\\mysql.c", "repo_name": "svewag/codecritics", "stars": 1, "license": "None", "language": "c", "size": 220}
{"docstring": "/*\tshutdown()\t*/\n", "func_signal": "static VALUE my_shutdown(int argc, VALUE* argv, VALUE obj)", "code": "{\n    MYSQL* m = GetHandler(obj);\n    VALUE level;\n\n    rb_scan_args(argc, argv, \"01\", &level);\n#if MYSQL_VERSION_ID >= 40103\n    if (mysql_shutdown(m, NIL_P(level) ? SHUTDOWN_DEFAULT : NUM2INT(level)) != 0)\n#else\n    if (mysql_shutdown(m) != 0)\n#endif\n\tmysql_raise(m);\n    return obj;\n}", "path": "th-mysql-config=\\usr\\local\\mysql\\bin\\mysql_config\\gems\\mysql-2.8.1\\ext\\mysql_api\\mysql.c", "repo_name": "svewag/codecritics", "stars": 1, "license": "None", "language": "c", "size": 220}
{"docstring": "/*\tfree_result()\t*/\n", "func_signal": "static VALUE stmt_free_result(VALUE obj)", "code": "{\n    struct mysql_stmt* s = DATA_PTR(obj);\n    check_stmt_closed(obj);\n    if (mysql_stmt_free_result(s->stmt))\n\tmysql_stmt_raise(s->stmt);\n    return obj;\n}", "path": "th-mysql-config=\\usr\\local\\mysql\\bin\\mysql_config\\gems\\mysql-2.8.1\\ext\\mysql_api\\mysql.c", "repo_name": "svewag/codecritics", "stars": 1, "license": "None", "language": "c", "size": 220}
{"docstring": "/*\tssl_set(key=nil, cert=nil, ca=nil, capath=nil, cipher=nil)\t*/\n", "func_signal": "static VALUE ssl_set(int argc, VALUE* argv, VALUE obj)", "code": "{\n    VALUE key, cert, ca, capath, cipher;\n    char *s_key, *s_cert, *s_ca, *s_capath, *s_cipher;\n    MYSQL* m = GetHandler(obj);\n    rb_scan_args(argc, argv, \"05\", &key, &cert, &ca, &capath, &cipher);\n    s_key = NILorSTRING(key);\n    s_cert = NILorSTRING(cert);\n    s_ca = NILorSTRING(ca);\n    s_capath = NILorSTRING(capath);\n    s_cipher = NILorSTRING(cipher);\n    mysql_ssl_set(m, s_key, s_cert, s_ca, s_capath, s_cipher);\n    return obj;\n}", "path": "th-mysql-config=\\usr\\local\\mysql\\bin\\mysql_config\\gems\\mysql-2.8.1\\ext\\mysql_api\\mysql.c", "repo_name": "svewag/codecritics", "stars": 1, "license": "None", "language": "c", "size": 220}
{"docstring": "/*\tfield_count()\t*/\n", "func_signal": "static VALUE stmt_field_count(VALUE obj)", "code": "{\n    struct mysql_stmt* s = DATA_PTR(obj);\n    unsigned int n;\n    check_stmt_closed(obj);\n    n = mysql_stmt_field_count(s->stmt);\n    return INT2NUM(n);\n}", "path": "th-mysql-config=\\usr\\local\\mysql\\bin\\mysql_config\\gems\\mysql-2.8.1\\ext\\mysql_api\\mysql.c", "repo_name": "svewag/codecritics", "stars": 1, "license": "None", "language": "c", "size": 220}
{"docstring": "/*\tcommit()\t*/\n", "func_signal": "static VALUE commit(VALUE obj)", "code": "{\n    MYSQL* m = GetHandler(obj);\n    if (mysql_commit(m) != 0)\n        mysql_raise(m);\n    return obj;\n}", "path": "th-mysql-config=\\usr\\local\\mysql\\bin\\mysql_config\\gems\\mysql-2.8.1\\ext\\mysql_api\\mysql.c", "repo_name": "svewag/codecritics", "stars": 1, "license": "None", "language": "c", "size": 220}
{"docstring": "/*\taffected_rows()\t*/\n", "func_signal": "static VALUE stmt_affected_rows(VALUE obj)", "code": "{\n    struct mysql_stmt* s = DATA_PTR(obj);\n    my_ulonglong n;\n    check_stmt_closed(obj);\n    n = mysql_stmt_affected_rows(s->stmt);\n    return INT2NUM(n);\n}", "path": "th-mysql-config=\\usr\\local\\mysql\\bin\\mysql_config\\gems\\mysql-2.8.1\\ext\\mysql_api\\mysql.c", "repo_name": "svewag/codecritics", "stars": 1, "license": "None", "language": "c", "size": 220}
{"docstring": "/*\trow_tell()\t*/\n", "func_signal": "static VALUE stmt_row_tell(VALUE obj)", "code": "{\n    struct mysql_stmt* s = DATA_PTR(obj);\n    MYSQL_ROW_OFFSET offset;\n    check_stmt_closed(obj);\n    offset = mysql_stmt_row_tell(s->stmt);\n    return Data_Wrap_Struct(cMysqlRowOffset, 0, NULL, offset);\n}", "path": "th-mysql-config=\\usr\\local\\mysql\\bin\\mysql_config\\gems\\mysql-2.8.1\\ext\\mysql_api\\mysql.c", "repo_name": "svewag/codecritics", "stars": 1, "license": "None", "language": "c", "size": 220}
{"docstring": "/*\tfetch()\t\t*/\n", "func_signal": "static VALUE stmt_fetch(VALUE obj)", "code": "{\n    struct mysql_stmt* s = DATA_PTR(obj);\n    VALUE ret;\n    int i;\n    int r;\n\n    check_stmt_closed(obj);\n    r = mysql_stmt_fetch(s->stmt);\n    if (r == MYSQL_NO_DATA)\n\treturn Qnil;\n#ifdef MYSQL_DATA_TRUNCATED\n    if (r == MYSQL_DATA_TRUNCATED)\n        rb_raise(rb_eRuntimeError, \"unexpectedly data truncated\");\n#endif\n    if (r == 1)\n\tmysql_stmt_raise(s->stmt);\n\n    ret = rb_ary_new2(s->result.n);\n    for (i = 0; i < s->result.n; i++) {\n\tif (s->result.is_null[i])\n\t    rb_ary_push(ret, Qnil);\n\telse {\n\t    VALUE v;\n\t    MYSQL_TIME *t;\n\t    switch (s->result.bind[i].buffer_type) {\n            case MYSQL_TYPE_TINY:\n                if (s->result.bind[i].is_unsigned)\n                    v = UINT2NUM(*(unsigned char *)s->result.bind[i].buffer);\n                else\n                    v = INT2NUM(*(signed char *)s->result.bind[i].buffer);\n                break;\n            case MYSQL_TYPE_SHORT:\n            case MYSQL_TYPE_YEAR:\n                if (s->result.bind[i].is_unsigned)\n                    v = UINT2NUM(*(unsigned short *)s->result.bind[i].buffer);\n                else\n                    v = INT2NUM(*(short *)s->result.bind[i].buffer);\n                break;\n            case MYSQL_TYPE_INT24:\n            case MYSQL_TYPE_LONG:\n                if (s->result.bind[i].is_unsigned)\n                    v = UINT2NUM(*(unsigned int *)s->result.bind[i].buffer);\n                else\n                    v = INT2NUM(*(int *)s->result.bind[i].buffer);\n                break;\n            case MYSQL_TYPE_LONGLONG:\n                if (s->result.bind[i].is_unsigned)\n                    v = ULL2NUM(*(unsigned long long *)s->result.bind[i].buffer);\n                else\n                    v = LL2NUM(*(long long *)s->result.bind[i].buffer);\n                break;\n            case MYSQL_TYPE_FLOAT:\n                v = rb_float_new((double)(*(float *)s->result.bind[i].buffer));\n                break;\n            case MYSQL_TYPE_DOUBLE:\n                v = rb_float_new(*(double *)s->result.bind[i].buffer);\n                break;\n            case MYSQL_TYPE_TIME:\n            case MYSQL_TYPE_DATE:\n            case MYSQL_TYPE_DATETIME:\n            case MYSQL_TYPE_TIMESTAMP:\n                t = (MYSQL_TIME *)s->result.bind[i].buffer;\n                v = rb_obj_alloc(cMysqlTime);\n                rb_funcall(v, rb_intern(\"initialize\"), 8,\n                           INT2FIX(t->year), INT2FIX(t->month),\n                           INT2FIX(t->day), INT2FIX(t->hour),\n                           INT2FIX(t->minute), INT2FIX(t->second),\n                           (t->neg ? Qtrue : Qfalse),\n                           INT2FIX(t->second_part));\n                break;\n            case MYSQL_TYPE_DECIMAL:\n            case MYSQL_TYPE_STRING:\n            case MYSQL_TYPE_VAR_STRING:\n            case MYSQL_TYPE_TINY_BLOB:\n            case MYSQL_TYPE_BLOB:\n            case MYSQL_TYPE_MEDIUM_BLOB:\n            case MYSQL_TYPE_LONG_BLOB:\n#if MYSQL_VERSION_ID >= 50003\n            case MYSQL_TYPE_NEWDECIMAL:\n            case MYSQL_TYPE_BIT:\n#endif\n                v = rb_tainted_str_new(s->result.bind[i].buffer, s->result.length[i]);\n                break;\n            default:\n                rb_raise(rb_eTypeError, \"unknown buffer_type: %d\", s->result.bind[i].buffer_type);\n\t    }\n\t    rb_ary_push(ret, v);\n\t}\n    }\n    return ret;\n}", "path": "th-mysql-config=\\usr\\local\\mysql\\bin\\mysql_config\\gems\\mysql-2.8.1\\ext\\mysql_api\\mysql.c", "repo_name": "svewag/codecritics", "stars": 1, "license": "None", "language": "c", "size": 220}
{"docstring": "/*\tmake Mysql::Field object\t*/\n", "func_signal": "static VALUE make_field_obj(MYSQL_FIELD* f)", "code": "{\n    VALUE obj;\n    if (f == NULL)\n\treturn Qnil;\n    obj = rb_obj_alloc(cMysqlField);\n    rb_iv_set(obj, \"name\", f->name? rb_str_freeze(rb_tainted_str_new2(f->name)): Qnil);\n    rb_iv_set(obj, \"table\", f->table? rb_str_freeze(rb_tainted_str_new2(f->table)): Qnil);\n    rb_iv_set(obj, \"def\", f->def? rb_str_freeze(rb_tainted_str_new2(f->def)): Qnil);\n    rb_iv_set(obj, \"type\", INT2NUM(f->type));\n    rb_iv_set(obj, \"length\", INT2NUM(f->length));\n    rb_iv_set(obj, \"max_length\", INT2NUM(f->max_length));\n    rb_iv_set(obj, \"flags\", INT2NUM(f->flags));\n    rb_iv_set(obj, \"decimals\", INT2NUM(f->decimals));\n    return obj;\n}", "path": "th-mysql-config=\\usr\\local\\mysql\\bin\\mysql_config\\gems\\mysql-2.8.1\\ext\\mysql_api\\mysql.c", "repo_name": "svewag/codecritics", "stars": 1, "license": "None", "language": "c", "size": 220}
{"docstring": "/*\tfetch_row()\t*/\n", "func_signal": "static VALUE fetch_row(VALUE obj)", "code": "{\n    MYSQL_RES* res;\n    unsigned int n;\n    MYSQL_ROW row;\n    unsigned long* lengths;\n    VALUE ary;\n    unsigned int i;\n    check_free(obj);\n    res = GetMysqlRes(obj);\n    n = mysql_num_fields(res);\n    row = mysql_fetch_row(res);\n    lengths = mysql_fetch_lengths(res);\n    if (row == NULL)\n\treturn Qnil;\n    ary = rb_ary_new2(n);\n    for (i=0; i<n; i++)\n\trb_ary_store(ary, i, row[i]? rb_tainted_str_new(row[i], lengths[i]): Qnil);\n    return ary;\n}", "path": "th-mysql-config=\\usr\\local\\mysql\\bin\\mysql_config\\gems\\mysql-2.8.1\\ext\\mysql_api\\mysql.c", "repo_name": "svewag/codecritics", "stars": 1, "license": "None", "language": "c", "size": 220}
{"docstring": "/*\trow_tell()\t*/\n", "func_signal": "static VALUE row_tell(VALUE obj)", "code": "{\n    MYSQL_ROW_OFFSET offset;\n    check_free(obj);\n    offset = mysql_row_tell(GetMysqlRes(obj));\n    return Data_Wrap_Struct(cMysqlRowOffset, 0, NULL, offset);\n}", "path": "th-mysql-config=\\usr\\local\\mysql\\bin\\mysql_config\\gems\\mysql-2.8.1\\ext\\mysql_api\\mysql.c", "repo_name": "svewag/codecritics", "stars": 1, "license": "None", "language": "c", "size": 220}
{"docstring": "/*\tstore_result()\t*/\n", "func_signal": "static VALUE store_result(VALUE obj)", "code": "{\n    MYSQL* m = GetHandler(obj);\n    MYSQL_RES* res = mysql_store_result(m);\n    if (res == NULL)\n\tmysql_raise(m);\n    return mysqlres2obj(res);\n}", "path": "th-mysql-config=\\usr\\local\\mysql\\bin\\mysql_config\\gems\\mysql-2.8.1\\ext\\mysql_api\\mysql.c", "repo_name": "svewag/codecritics", "stars": 1, "license": "None", "language": "c", "size": 220}
{"docstring": "/**\n * nautilus_navigation_bar_activate\n * \n * Change the navigation bar to an active state.\n * \n * @bar: A NautilusNavigationBar.\n */\n", "func_signal": "void\nnautilus_navigation_bar_activate (NautilusNavigationBar *bar)", "code": "{\n\tg_return_if_fail (NAUTILUS_IS_NAVIGATION_BAR (bar));\n\n\tg_signal_emit (bar, signals[ACTIVATE], 0);\n}", "path": "src\\nautilus-navigation-bar.c", "repo_name": "Spheerys/nautilus", "stars": 0, "license": "other", "language": "c", "size": 2720}
{"docstring": "/* handle dropped tile images */\n", "func_signal": "static void\nreceive_dropped_tile_image (NautilusIconContainer *container, GdkDragAction action, GtkSelectionData *data)", "code": "{\n\tg_assert (data != NULL);\n\n\taction = get_background_drag_action (container, action);\n\n\tif (action > 0) {\n\t\tchar *uri;\n\n\t\turi = get_container_uri (container);\n\t\tnautilus_debug_log (FALSE, NAUTILUS_DEBUG_LOG_DOMAIN_USER,\n\t\t\t\t    \"dropped tile image on icon container displaying %s\", uri);\n\t\tg_free (uri);\n\n\t\teel_background_receive_dropped_background_image\n\t\t\t(eel_get_widget_background (GTK_WIDGET (container)), \n\t\t\t action, \n\t\t\t data->data);\n\t}\n}", "path": "libnautilus-private\\nautilus-icon-dnd.c", "repo_name": "Spheerys/nautilus", "stars": 0, "license": "other", "language": "c", "size": 2720}
{"docstring": "/* Adaptor function used with nautilus_icon_container_each_selected_icon\n * to help iterate over all selected items, passing uris, x, y, w and h\n * values to the iteratee\n */\n", "func_signal": "static void\neach_icon_get_data_binder (NautilusDragEachSelectedItemDataGet iteratee, \n\tgpointer iterator_context, gpointer data)", "code": "{\n\tIconGetDataBinderContext context;\n\tNautilusIconContainer *container;\n\n\tg_assert (NAUTILUS_IS_ICON_CONTAINER (iterator_context));\n\tcontainer = NAUTILUS_ICON_CONTAINER (iterator_context);\n\n\tcontext.iterator_context = iterator_context;\n\tcontext.iteratee = iteratee;\n\tcontext.iteratee_data = data;\n\tnautilus_icon_container_each_selected_icon (container, icon_get_data_binder, &context);\n}", "path": "libnautilus-private\\nautilus-icon-dnd.c", "repo_name": "Spheerys/nautilus", "stars": 0, "license": "other", "language": "c", "size": 2720}
{"docstring": "/* Target-side handling of the drag.  */\n", "func_signal": "static void\nnautilus_icon_container_position_shadow (NautilusIconContainer *container,\n\t\t\t\t\t int x, int y)", "code": "{\n\tEelCanvasItem *shadow;\n\tdouble world_x, world_y;\n\n\tshadow = container->details->dnd_info->shadow;\n\tif (shadow == NULL) {\n\t\treturn;\n\t}\n\n\tcanvas_widget_to_world (EEL_CANVAS (container), x, y,\n\t\t\t\t&world_x, &world_y);\n\n\tset_shadow_position (shadow, world_x, world_y);\n\teel_canvas_item_show (shadow);\n}", "path": "libnautilus-private\\nautilus-icon-dnd.c", "repo_name": "Spheerys/nautilus", "stars": 0, "license": "other", "language": "c", "size": 2720}
{"docstring": "/* Set the affine instead of the x and y position.\n * Simple, and setting x and y was broken at one point.\n */\n", "func_signal": "static void\nset_shadow_position (EelCanvasItem *shadow,\n\t\t     double x, double y)", "code": "{\n\teel_canvas_item_set (shadow,\n\t\t\t     \"x\", x, \"y\", y,\n\t\t\t     NULL);\n}", "path": "libnautilus-private\\nautilus-icon-dnd.c", "repo_name": "Spheerys/nautilus", "stars": 0, "license": "other", "language": "c", "size": 2720}
{"docstring": "/**\n * nautilus_navigation_bar_set_location\n * \n * Change the location displayed in the navigation bar.\n * \n * @bar: A NautilusNavigationBar.\n * @location: The uri that should be displayed.\n */\n", "func_signal": "void\nnautilus_navigation_bar_set_location (NautilusNavigationBar *bar,\n\t\t\t\t      const char *location)", "code": "{\n\tg_return_if_fail (NAUTILUS_IS_NAVIGATION_BAR (bar));\n\n\tEEL_CALL_METHOD (NAUTILUS_NAVIGATION_BAR_CLASS, bar,\n\t\t\t      set_location, (bar, location));\n}", "path": "src\\nautilus-navigation-bar.c", "repo_name": "Spheerys/nautilus", "stars": 0, "license": "other", "language": "c", "size": 2720}
{"docstring": "/**\n * application_cannot_open_location\n * \n * Handle the case where an application has been selected to be launched,\n * and it cannot handle the current uri scheme.  This can happen\n * because the default application for a file type may not be able\n * to handle some kinds of locations.   We want to tell users that their\n * default application doesn't work here, rather than switching off to\n * a different one without them noticing.\n * \n * @application: The application that was to be launched.\n * @file: The file whose location was passed as a parameter to the application\n * @parent_window: A window to use as the parent for any error dialogs.\n *  */\n", "func_signal": "static void\napplication_cannot_open_location (GAppInfo *application,\n\t\t\t\t  NautilusFile *file,\n\t\t\t\t  const char *uri_scheme,\n\t\t\t\t  GtkWindow *parent_window)", "code": "{\n#ifdef NEW_MIME_COMPLETE\n\tGtkDialog *message_dialog;\n\tLaunchParameters *launch_parameters;\n\tchar *prompt;\n\tchar *message;\n\tchar *file_name;\n\tint response;\n\n\tfile_name = nautilus_file_get_display_name (file);\n\n\tif (nautilus_mime_has_any_applications_for_file (file)) {\n\t\tif (application != NULL) {\n\t\t\tprompt = _(\"Open Failed, would you like to choose another application?\");\n\t\t\tmessage = g_strdup_printf (_(\"\\\"%s\\\" cannot open \\\"%s\\\" because \\\"%s\\\" cannot access files at \\\"%s\\\" \"\n\t\t\t\t\t\t     \"locations.\"),\n\t\t\t\t\t\t   g_app_info_get_name (application), file_name, \n\t\t\t\t\t\t   g_app_info_get_name (application), uri_scheme);\n\t\t} else {\n\t\t\tprompt = _(\"Open Failed, would you like to choose another action?\");\n\t\t\tmessage = g_strdup_printf (_(\"The default action cannot open \\\"%s\\\" because it cannot access files at \\\"%s\\\" \"\n\t\t\t\t\t\t     \"locations.\"),\n\t\t\t\t\t\t   file_name, uri_scheme);\n\t\t}\n\t\t\n\t\tmessage_dialog = eel_show_yes_no_dialog (prompt, \n\t\t                                         message,\n\t\t\t\t\t\t\t GTK_STOCK_OK,\n\t\t\t\t\t\t\t GTK_STOCK_CANCEL,\n\t\t\t\t\t\t\t parent_window);\n\t\tresponse = gtk_dialog_run (message_dialog);\n\t\tgtk_object_destroy (GTK_OBJECT (message_dialog));\n\t\t\n\t\tif (response == GTK_RESPONSE_YES) {\n\t\t\tlaunch_parameters = launch_parameters_new (file, parent_window);\n\t\t\tnautilus_choose_application_for_file \n\t\t\t\t(file,\n\t\t\t\t parent_window,\n\t\t\t\t launch_application_callback,\n\t\t\t\t launch_parameters);\n\t\t\t\t \n\t\t}\n\t\tg_free (message);\n\t} else {\n\t\tif (application != NULL) {\n\t\t\tprompt = g_strdup_printf (_(\"\\\"%s\\\" cannot open \\\"%s\\\" because \\\"%s\\\" cannot access files at \\\"%s\\\" \"\n\t\t\t\t\t\t    \"locations.\"), g_app_info_get_name (application), file_name, \n\t\t\t\t\t\t    g_app_info_get_name (application), uri_scheme);\n\t\t\tmessage = _(\"No other applications are available to view this file.  \"\n\t\t\t\t    \"If you copy this file onto your computer, you may be able to open \"\n\t\t\t\t    \"it.\");\n\t\t} else {\n\t\t\tprompt = g_strdup_printf (_(\"The default action cannot open \\\"%s\\\" because it cannot access files at \\\"%s\\\" \"\n\t\t\t\t\t\t    \"locations.\"), file_name, uri_scheme);\n     \t\t\tmessage = _(\"No other actions are available to view this file.  \"\n\t\t\t\t    \"If you copy this file onto your computer, you may be able to open \"\n\t\t\t\t    \"it.\");\n\t\t}\n\t\t\t\t\n\t\teel_show_info_dialog (prompt, message, parent_window);\n\t\tg_free (prompt);\n\t}\t\n\n\tg_free (file_name);\n#endif\n}", "path": "libnautilus-private\\nautilus-program-choosing.c", "repo_name": "Spheerys/nautilus", "stars": 0, "license": "other", "language": "c", "size": 2720}
{"docstring": "/**\n * nautilus_navigation_bar_get_location\n * \n * Return the location displayed in the navigation bar.\n * \n * @bar: A NautilusNavigationBar.\n * @location: The uri that should be displayed.\n */\n", "func_signal": "char *\nnautilus_navigation_bar_get_location (NautilusNavigationBar *bar)", "code": "{\n\tg_return_val_if_fail (NAUTILUS_IS_NAVIGATION_BAR (bar), NULL);\n\n\treturn EEL_CALL_METHOD_WITH_RETURN_VALUE\n\t\t(NAUTILUS_NAVIGATION_BAR_CLASS, bar,\n\t\t get_location, (bar));\n}", "path": "src\\nautilus-navigation-bar.c", "repo_name": "Spheerys/nautilus", "stars": 0, "license": "other", "language": "c", "size": 2720}
{"docstring": "/**\n * nautilus_launch_application_from_command:\n * \n * Fork off a process to launch an application with a given uri as\n * a parameter.\n * \n * @command_string: The application to be launched, with any desired\n * command-line options.\n * @parameter: Passed as a parameter to the application as is.\n */\n", "func_signal": "void\nnautilus_launch_application_from_command (GdkScreen  *screen,\n\t\t\t\t\t  const char *name,\n\t\t\t\t\t  const char *command_string, \n\t\t\t\t\t  const char *parameter, \n\t\t\t\t\t  gboolean use_terminal)", "code": "{\n\tchar *full_command;\n\tchar *quoted_parameter; \n\n\tif (parameter != NULL) {\n\t\tquoted_parameter = g_shell_quote (parameter);\n\t\tfull_command = g_strconcat (command_string, \" \", quoted_parameter, NULL);\n\t\tg_free (quoted_parameter);\n\t} else {\n\t\tfull_command = g_strdup (command_string);\n\t}\n\n\tif (use_terminal) {\n\t\teel_gnome_open_terminal_on_screen (full_command, screen);\n\t} else {\n\t    \tgdk_spawn_command_line_on_screen (screen, full_command, NULL);\n\t}\n\n\tg_free (full_command);\n}", "path": "libnautilus-private\\nautilus-program-choosing.c", "repo_name": "Spheerys/nautilus", "stars": 0, "license": "other", "language": "c", "size": 2720}
{"docstring": "/**\n * nautilus_launch_application:\n * \n * Fork off a process to launch an application with a given file as a\n * parameter. Provide a parent window for error dialogs. \n * \n * @application: The application to be launched.\n * @files: The files whose locations should be passed as a parameter to the application.\n * @parent_window: A window to use as the parent for any error dialogs.\n */\n", "func_signal": "void\nnautilus_launch_application (GAppInfo *application, \n\t\t\t     GList *files,\n\t\t\t     GtkWindow *parent_window)", "code": "{\n\tchar            *uri_scheme;\n\tGList           *locations, *l;\n\tGFile *location;\n\tNautilusFile    *file;\n\tgboolean        result;\n\tGError *error;\n\tEelAppLaunchContext *launch_context;\n\tNautilusIconInfo *icon;\n\n\tg_assert (files != NULL);\n\n\tlocations = NULL;\n\tfor (l = files; l != NULL; l = l->next) {\n\t\tfile = NAUTILUS_FILE (l->data);\n\t\t\n\t\tlocation = nautilus_file_get_activation_location (file);\n\n\t\tlocations = g_list_prepend (locations, location);\n\t}\n\tlocations = g_list_reverse (locations);\n\n\tlaunch_context = eel_app_launch_context_new ();\n\tif (parent_window)\n\t\teel_app_launch_context_set_screen (launch_context,\n\t\t\t\t\t\t     gtk_window_get_screen (parent_window));\n\n\tfile = NAUTILUS_FILE (files->data);\n\ticon = nautilus_file_get_icon (file, 48, 0);\n\tif (icon) {\n\t\teel_app_launch_context_set_icon_name (launch_context,\n\t\t\t\t\t\t\tnautilus_icon_info_get_used_name (icon));\n\t\tg_object_unref (icon);\n\t}\n\t\n\terror = NULL;\n\tresult = g_app_info_launch (application,\n\t\t\t\t    locations,\n\t\t\t\t    G_APP_LAUNCH_CONTEXT (launch_context),\n\t\t\t\t    &error);\n\n\tg_object_unref (launch_context);\n\t\n\tif (!result) {\n\t\tif (error->domain == G_IO_ERROR &&\n\t\t    error->code == G_IO_ERROR_NOT_SUPPORTED) {\n\t\t\turi_scheme = nautilus_file_get_uri_scheme (NAUTILUS_FILE (files->data));\n\t\t\tapplication_cannot_open_location (application,\n\t\t\t\t\t\t\t  file,\n\t\t\t\t\t\t\t  uri_scheme,\n\t\t\t\t\t\t\t  parent_window);\n\t\t\tg_free (uri_scheme);\n\t\t} else {\n#ifdef NEW_MIME_COMPLETE\n\t\t\tnautilus_program_chooser_show_invalid_message\n\t\t\t\t(GNOME_VFS_MIME_ACTION_TYPE_APPLICATION, file, parent_window);\n#else\n\t\t\tg_warning (\"Cannot open app: %s\\n\", error->message);\n#endif\n\t\t}\n\t} else {\n\t\tfor (l = files; l != NULL; l = l->next) {\n\t\t\tfile = NAUTILUS_FILE (l->data);\n\t\t\t\n\t\t\tnautilus_recent_add_file (file, application);\n\t\t}\n\t}\n\n\teel_g_object_list_free (locations);\n}", "path": "libnautilus-private\\nautilus-program-choosing.c", "repo_name": "Spheerys/nautilus", "stars": 0, "license": "other", "language": "c", "size": 2720}
{"docstring": "/* handle dropped url */\n", "func_signal": "static void\nreceive_dropped_netscape_url (NautilusIconContainer *container, const char *encoded_url, GdkDragContext *context, int x, int y)", "code": "{\n\tchar *drop_target;\n\n\tif (encoded_url == NULL) {\n\t\treturn;\n\t}\n\n\tdrop_target = nautilus_icon_container_find_drop_target (container, context, x, y, NULL, TRUE);\n\n\tg_signal_emit_by_name (container, \"handle_netscape_url\",\n\t\t\t       encoded_url,\n\t\t\t       drop_target,\n\t\t\t       context->action,\n\t\t\t       x, y);\n\n\tg_free (drop_target);\n}", "path": "libnautilus-private\\nautilus-icon-dnd.c", "repo_name": "Spheerys/nautilus", "stars": 0, "license": "other", "language": "c", "size": 2720}
{"docstring": "/* FIXME bugzilla.gnome.org 47445: Needs to become a shared function */\n", "func_signal": "static void\nget_data_on_first_target_we_support (GtkWidget *widget, GdkDragContext *context, guint32 time, int x, int y)", "code": "{\n\tGtkTargetList *list;\n\tGdkAtom target;\n\n\tif (drop_types_list == NULL) {\n\t\tdrop_types_list = gtk_target_list_new (drop_types,\n\t\t\t\t\t\t       G_N_ELEMENTS (drop_types) - 1);\n\t\tgtk_target_list_add_text_targets (drop_types_list, NAUTILUS_ICON_DND_TEXT);\n\t}\n\tif (drop_types_list_root == NULL) {\n\t\tdrop_types_list_root = gtk_target_list_new (drop_types,\n\t\t\t\t\t\t\t    G_N_ELEMENTS (drop_types));\n\t\tgtk_target_list_add_text_targets (drop_types_list_root, NAUTILUS_ICON_DND_TEXT);\n\t}\n\t\n\tif (nautilus_icon_container_get_is_desktop (NAUTILUS_ICON_CONTAINER (widget))) {\n\t\tlist = drop_types_list_root;\n\t} else {\n\t\tlist = drop_types_list;\n\t}\n\n\ttarget = gtk_drag_dest_find_target (widget, context, list);\n\tif (target != GDK_NONE) {\n\t\tguint info;\n\t\tNautilusDragInfo *drag_info;\n\t\tgboolean found;\n\n\t\tdrag_info = &(NAUTILUS_ICON_CONTAINER (widget)->details->dnd_info->drag_info);\n\n\t\tfound = gtk_target_list_find (list, target, &info);\n\t\tg_assert (found);\n\n\t\t/* Don't get_data for destructive ops */\n\t\tif ((info == NAUTILUS_ICON_DND_ROOTWINDOW_DROP ||\n\t\t     info == NAUTILUS_ICON_DND_XDNDDIRECTSAVE) &&\n\t\t    !drag_info->drop_occured) {\n\t\t\t/* We can't call get_data here, because that would\n\t\t\t   make the source execute the rootwin action or the direct save */\n\t\t\tdrag_info->got_drop_data_type = TRUE;\n\t\t\tdrag_info->data_type = info;\n\t\t} else {\n\t\t\tif (info == NAUTILUS_ICON_DND_XDNDDIRECTSAVE) {\n\t\t\t\tset_direct_save_uri (widget, context, drag_info, x, y);\n\t\t\t}\n\t\t\tgtk_drag_get_data (GTK_WIDGET (widget), context,\n\t\t\t\t\t   target, time);\n\t\t}\n\t}\n}", "path": "libnautilus-private\\nautilus-icon-dnd.c", "repo_name": "Spheerys/nautilus", "stars": 0, "license": "other", "language": "c", "size": 2720}
{"docstring": "/* handle dropped keywords */\n", "func_signal": "static void\nreceive_dropped_keyword (NautilusIconContainer *container, const char *keyword, int x, int y)", "code": "{\n\tchar *uri;\n\tdouble world_x, world_y;\n\n\tNautilusIcon *drop_target_icon;\n\tNautilusFile *file;\n\t\n\tg_assert (keyword != NULL);\n\n\t/* find the item we hit with our drop, if any */\n\tcanvas_widget_to_world (EEL_CANVAS (container), x, y, &world_x, &world_y);\n\tdrop_target_icon = nautilus_icon_container_item_at (container, world_x, world_y);\n\tif (drop_target_icon == NULL) {\n\t\treturn;\n\t}\n\n\t/* FIXME bugzilla.gnome.org 42485: \n\t * This does not belong in the icon code.\n\t * It has to be in the file manager.\n\t * The icon code has no right to deal with the file directly.\n\t * But luckily there's no issue of not getting a file object,\n\t * so we don't have to worry about async. issues here.\n\t */\n\turi = nautilus_icon_container_get_icon_uri (container, drop_target_icon);\n\n\tnautilus_debug_log (FALSE, NAUTILUS_DEBUG_LOG_DOMAIN_USER,\n\t\t\t    \"dropped emblem '%s' on icon container URI: %s\",\n\t\t\t    keyword, uri);\n\n\tfile = nautilus_file_get_by_uri (uri);\n\tg_free (uri);\n\t\n\tnautilus_drag_file_receive_dropped_keyword (file, keyword);\n\n\tnautilus_file_unref (file);\n\tnautilus_icon_container_update_icon (container, drop_target_icon);\n}", "path": "libnautilus-private\\nautilus-icon-dnd.c", "repo_name": "Spheerys/nautilus", "stars": 0, "license": "other", "language": "c", "size": 2720}
{"docstring": "/* Iterate over each selected icon in a NautilusIconContainer,\n * calling each_function on each.\n */\n", "func_signal": "static void\nnautilus_icon_container_each_selected_icon (NautilusIconContainer *container,\n\tgboolean (*each_function) (NautilusIcon *, gpointer), gpointer data)", "code": "{\n\tGList *p;\n\tNautilusIcon *icon;\n\n\tfor (p = container->details->icons; p != NULL; p = p->next) {\n\t\ticon = p->data;\n\t\tif (!icon->is_selected) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!each_function (icon, data)) {\n\t\t\treturn;\n\t\t}\n\t}\n}", "path": "libnautilus-private\\nautilus-icon-dnd.c", "repo_name": "Spheerys/nautilus", "stars": 0, "license": "other", "language": "c", "size": 2720}
{"docstring": "/* handle dropped text */\n", "func_signal": "static void\nreceive_dropped_text (NautilusIconContainer *container, const char *text, GdkDragContext *context, int x, int y)", "code": "{\t\n\tchar *drop_target;\n\n\tif (text == NULL) {\n\t\treturn;\n\t}\n\n\tdrop_target = nautilus_icon_container_find_drop_target (container, context, x, y, NULL, TRUE);\n\t\n\tg_signal_emit_by_name (container, \"handle_text\",\n\t\t\t       text,\n\t\t\t       drop_target,\n\t\t\t       context->action,\n\t\t\t       x, y);\n\n\tg_free (drop_target);\n}", "path": "libnautilus-private\\nautilus-icon-dnd.c", "repo_name": "Spheerys/nautilus", "stars": 0, "license": "other", "language": "c", "size": 2720}
{"docstring": "/* Called when the data for drag&drop is needed */\n", "func_signal": "static void\ndrag_data_get_callback (GtkWidget *widget,\n\t\t\tGdkDragContext *context,\n\t\t\tGtkSelectionData *selection_data,\n\t\t\tguint info,\n\t\t\tguint32 time,\n\t\t\tgpointer data)", "code": "{\n\tg_assert (widget != NULL);\n\tg_assert (NAUTILUS_IS_ICON_CONTAINER (widget));\n\tg_return_if_fail (context != NULL);\n\n\t/* Call common function from nautilus-drag that set's up\n\t * the selection data in the right format. Pass it means to\n\t * iterate all the selected icons.\n\t */\n\tnautilus_drag_drag_data_get (widget, context, selection_data,\n\t\tinfo, time, widget, each_icon_get_data_binder);\n}", "path": "libnautilus-private\\nautilus-icon-dnd.c", "repo_name": "Spheerys/nautilus", "stars": 0, "license": "other", "language": "c", "size": 2720}
{"docstring": "/* This function is used because the NautilusDirectory model does not\n * exist always in the desktop_icon_view, so we wait until it has been\n * instantiated.\n */\n", "func_signal": "static void\ndelayed_init (FMDesktopIconView *desktop_icon_view)", "code": "{\n\t/* Keep track of the load time. */\n\tg_signal_connect_object (fm_directory_view_get_model (FM_DIRECTORY_VIEW (desktop_icon_view)),\n\t\t\t\t \"done_loading\",\n\t\t\t\t G_CALLBACK (done_loading), desktop_icon_view, 0);\n\n\t/* Monitor desktop directory. */\n\tdesktop_icon_view->details->reload_desktop_timeout =\n\t\tg_timeout_add (RESCAN_TIMEOUT, do_desktop_rescan, desktop_icon_view);\n\n\tg_signal_handler_disconnect (desktop_icon_view,\n\t\t\t\t     desktop_icon_view->details->delayed_init_signal);\n\n\tdesktop_icon_view->details->delayed_init_signal = 0;\n}", "path": "src\\file-manager\\fm-desktop-icon-view.c", "repo_name": "Spheerys/nautilus", "stars": 0, "license": "other", "language": "c", "size": 2720}
{"docstring": "/** this callback is called in 2 cases.\n    It is called upon drag_motion events to get the actual data \n    In that case, it just makes sure it gets the data.\n    It is called upon drop_drop events to execute the actual \n    actions on the received action. In that case, it actually first makes sure\n    that we have got the data then processes it.\n*/\n", "func_signal": "static void\ndrag_data_received_callback (GtkWidget *widget,\n\t\t\t     GdkDragContext *context,\n\t\t\t     int x,\n\t\t\t     int y,\n\t\t\t     GtkSelectionData *data,\n\t\t\t     guint info,\n\t\t\t     guint32 time,\n\t\t\t     gpointer user_data)", "code": "{\n    \tNautilusDragInfo *drag_info;\n\tEelBackground *background;\n\tchar *tmp;\n\tgboolean success;\n\n\tdrag_info = &(NAUTILUS_ICON_CONTAINER (widget)->details->dnd_info->drag_info);\n\n\tdrag_info->got_drop_data_type = TRUE;\n\tdrag_info->data_type = info;\n\n\tswitch (info) {\n\tcase NAUTILUS_ICON_DND_GNOME_ICON_LIST:\n\t\tnautilus_icon_container_dropped_icon_feedback (widget, data, x, y);\n\t\tbreak;\n\tcase NAUTILUS_ICON_DND_COLOR:\n\tcase NAUTILUS_ICON_DND_BGIMAGE:\t\n\tcase NAUTILUS_ICON_DND_KEYWORD:\n\tcase NAUTILUS_ICON_DND_URI_LIST:\n\tcase NAUTILUS_ICON_DND_TEXT:\n\tcase NAUTILUS_ICON_DND_RESET_BACKGROUND:\n\tcase NAUTILUS_ICON_DND_XDNDDIRECTSAVE:\n\t\t/* Save the data so we can do the actual work on drop. */\n\t\tif (drag_info->selection_data != NULL) {\n\t\t\tgtk_selection_data_free (drag_info->selection_data);\n\t\t}\n\t\tdrag_info->selection_data = gtk_selection_data_copy (data);\n\t\tbreak;\n\n\t/* Netscape keeps sending us the data, even though we accept the first drag */\n\tcase NAUTILUS_ICON_DND_NETSCAPE_URL:\n\t\tif (drag_info->selection_data != NULL) {\n\t\t\tgtk_selection_data_free (drag_info->selection_data);\n\t\t\tdrag_info->selection_data = gtk_selection_data_copy (data);\n\t\t}\n\t\tbreak;\n\tcase NAUTILUS_ICON_DND_ROOTWINDOW_DROP:\n\t\t/* Do nothing, this won't even happen, since we don't want to call get_data twice */\n\t\tbreak;\n\t}\n\n\t/* this is the second use case of this callback.\n\t * we have to do the actual work for the drop.\n\t */\n\tif (drag_info->drop_occured) {\n\n\t\tsuccess = FALSE;\n\t\tswitch (info) {\n\t\tcase NAUTILUS_ICON_DND_GNOME_ICON_LIST:\n\t\t\tnautilus_icon_container_receive_dropped_icons\n\t\t\t\t(NAUTILUS_ICON_CONTAINER (widget),\n\t\t\t\t context, x, y);\n\t\t\tbreak;\n\t\tcase NAUTILUS_ICON_DND_COLOR:\n\t\t\treceive_dropped_color (NAUTILUS_ICON_CONTAINER (widget),\n\t\t\t\t\t       x, y,\n\t\t\t\t\t       context->action,\n\t\t\t\t\t       data);\n\t\t\tsuccess = TRUE;\n\t\t\tbreak;\n\t\tcase NAUTILUS_ICON_DND_BGIMAGE:\n\t\t\treceive_dropped_tile_image\n\t\t\t\t(NAUTILUS_ICON_CONTAINER (widget),\n\t\t\t\t context->action,\n\t\t\t\t data);\n\t\t\tbreak;\n\t\tcase NAUTILUS_ICON_DND_KEYWORD:\n\t\t\treceive_dropped_keyword\n\t\t\t\t(NAUTILUS_ICON_CONTAINER (widget),\n\t\t\t\t (char *) data->data, x, y);\n\t\t\tbreak;\n\t\tcase NAUTILUS_ICON_DND_NETSCAPE_URL:\n\t\t\treceive_dropped_netscape_url\n\t\t\t\t(NAUTILUS_ICON_CONTAINER (widget),\n\t\t\t\t (char *) data->data, context, x, y);\n\t\t\tsuccess = TRUE;\n\t\t\tbreak;\n\t\tcase NAUTILUS_ICON_DND_URI_LIST:\n\t\t\treceive_dropped_uri_list\n\t\t\t\t(NAUTILUS_ICON_CONTAINER (widget),\n\t\t\t\t (char *) data->data, context, x, y);\n\t\t\tsuccess = TRUE;\n\t\t\tbreak;\n\t\tcase NAUTILUS_ICON_DND_TEXT:\n\t\t\ttmp = gtk_selection_data_get_text (data);\n\t\t\treceive_dropped_text\n\t\t\t\t(NAUTILUS_ICON_CONTAINER (widget),\n\t\t\t\t (char *) tmp, context, x, y);\n\t\t\tsuccess = TRUE;\n\t\t\tg_free (tmp);\n\t\t\tbreak;\n\t\tcase NAUTILUS_ICON_DND_RESET_BACKGROUND:\n\t\t\tbackground = eel_get_widget_background (widget);\n\t\t\tif (background != NULL) {\n\t\t\t\teel_background_reset (background);\n\t\t\t}\n\t\t\tgtk_drag_finish (context, FALSE, FALSE, time);\t\t\t\n\t\t\tbreak;\n\t\tcase NAUTILUS_ICON_DND_ROOTWINDOW_DROP:\n\t\t\t/* Do nothing, everything is done by the sender */\n\t\t\tbreak;\n\t\tcase NAUTILUS_ICON_DND_XDNDDIRECTSAVE:\n\t\t\t/* Indicate that we don't provide \"F\" fallback */\n          \t\tif (drag_info->selection_data->format == 8 &&\n\t\t\t    drag_info->selection_data->length == 1 &&\n\t\t\t    drag_info->selection_data->data[0] == 'F') {\n\t              \t\tgdk_property_change (GDK_DRAWABLE (context->source_window),\n\t\t\t\t\t\t     gdk_atom_intern (NAUTILUS_ICON_DND_XDNDDIRECTSAVE_TYPE, FALSE),\n\t\t\t\t\t\t     gdk_atom_intern (\"text/plain\", FALSE), 8,\n\t\t\t\t\t\t     GDK_PROP_MODE_REPLACE, (const guchar *) \"\", 0);\n            \t\t} else if (drag_info->selection_data->format == 8 &&\n\t\t\t\t   drag_info->selection_data->length == 1 &&\n\t\t\t\t   drag_info->selection_data->data[0] == 'S' &&\n\t\t\t\t   drag_info->direct_save_uri != NULL) {\n\t\t\t\tGdkPoint p;\n\t\t\t\tGFile *location;\n\n\t\t\t\tlocation = g_file_new_for_uri (drag_info->direct_save_uri);\n\n\t\t\t\tnautilus_file_changes_queue_file_added (location);\n\t\t\t\tp.x = x; p.y = y;\n\t\t\t\tnautilus_file_changes_queue_schedule_position_set (location,\n\t\t\t\t\t\t\t\t\t\t   p,\n\t\t\t\t\t\t\t\t\t\t   gdk_screen_get_number (gtk_widget_get_screen (widget)));\n\t\t\t\tg_object_unref (location);\n\t\t\t\tnautilus_file_changes_consume_changes (TRUE);\n            \t\t}\n\t\t        success = TRUE;\n\t\t\tbreak;\n\t\t}\n\t\tgtk_drag_finish (context, success, FALSE, time);\n\t\t\n\t\tnautilus_icon_container_free_drag_data (NAUTILUS_ICON_CONTAINER (widget));\n\t\t\n\t\tset_drop_target (NAUTILUS_ICON_CONTAINER (widget), NULL);\n\n\t\t/* reinitialise it for the next dnd */\n\t\tdrag_info->drop_occured = FALSE;\n\t}\n\n}", "path": "libnautilus-private\\nautilus-icon-dnd.c", "repo_name": "Spheerys/nautilus", "stars": 0, "license": "other", "language": "c", "size": 2720}
{"docstring": "/* Queue a redraw of the dnd highlight rect */\n", "func_signal": "static void\ndnd_highlight_queue_redraw (GtkWidget *widget)", "code": "{\n\tNautilusIconDndInfo *dnd_info;\n\tint width, height;\n\t\n\tdnd_info = NAUTILUS_ICON_CONTAINER (widget)->details->dnd_info;\n\t\n\tif (!dnd_info->highlighted) {\n\t\treturn;\n\t}\n\n\twidth = widget->allocation.width;\n\theight = widget->allocation.height;\n\n\t/* we don't know how wide the shadow is exactly,\n\t * so we expose a 10-pixel wide border\n\t */\n\tgtk_widget_queue_draw_area (widget,\n\t\t\t\t    0, 0,\n\t\t\t\t    width, 10);\n\tgtk_widget_queue_draw_area (widget,\n\t\t\t\t    0, 0,\n\t\t\t\t    10, height);\n\tgtk_widget_queue_draw_area (widget,\n\t\t\t\t    0, height - 10,\n\t\t\t\t    width, 10);\n\tgtk_widget_queue_draw_area (widget,\n\t\t\t\t    width - 10, 0,\n\t\t\t\t    10, height);\n}", "path": "libnautilus-private\\nautilus-icon-dnd.c", "repo_name": "Spheerys/nautilus", "stars": 0, "license": "other", "language": "c", "size": 2720}
{"docstring": "/* handle dropped uri list */\n", "func_signal": "static void\nreceive_dropped_uri_list (NautilusIconContainer *container, const char *uri_list, GdkDragContext *context, int x, int y)", "code": "{\t\n\tchar *drop_target;\n\n\tif (uri_list == NULL) {\n\t\treturn;\n\t}\n\n\tdrop_target = nautilus_icon_container_find_drop_target (container, context, x, y, NULL, TRUE);\n\n\tg_signal_emit_by_name (container, \"handle_uri_list\",\n\t\t\t\t uri_list,\n\t\t\t\t drop_target,\n\t\t\t\t context->action,\n\t\t\t\t x, y);\n\n\tg_free (drop_target);\n}", "path": "libnautilus-private\\nautilus-icon-dnd.c", "repo_name": "Spheerys/nautilus", "stars": 0, "license": "other", "language": "c", "size": 2720}
{"docstring": "/******************************************************************************/\n/*\n *  Generate HTML to create a list box containing the access methods\n */\n", "func_signal": "static int aspGenerateAccessMethodList(int eid, webs_t wp, \n\t\t\t\t\t\t\t\t\t   int argc, char_t **argv)", "code": "{\n\tint\t\tnBytes;\n\n\ta_assert(wp);\n\n\tnBytes = websWrite(wp, \n\t\tT(\"<SELECT NAME=\\\"method\\\" SIZE=\\\"3\\\" TITLE=\\\"Select a Method\\\">\"));\n\tnBytes += websWrite(wp, T(\"<OPTION VALUE=\\\"%d\\\">FULL ACCESS\\n\"), \n\t\tAM_FULL);\n\tnBytes += websWrite(wp, T(\"<OPTION VALUE=\\\"%d\\\">BASIC ACCESS\\n\"), \n\t\tAM_BASIC);\n\tnBytes += websWrite(wp, T(\"<OPTION VALUE=\\\"%d\\\" SELECTED>DIGEST ACCESS\\n\"), \n\t\tAM_DIGEST);\n\tnBytes += websWrite(wp, T(\"<OPTION VALUE=\\\"%d\\\">NO ACCESS\\n\"), \n\t\tAM_NONE);\n\tnBytes += websWrite(wp, T(\"</SELECT>\"));\n\n\treturn nBytes;\n}", "path": "umui.c", "repo_name": "blondak/wive-ng-web", "stars": 1, "license": "other", "language": "c", "size": 528}
{"docstring": "/******************************************************************************/\n/*\n *  Generate HTML to create a list box containing privileges\n */\n", "func_signal": "static int aspGeneratePrivilegeList(int eid, webs_t wp, \n\t\t\t\t\t\t\t\t\tint argc, char_t **argv)", "code": "{\n\tint\t\tnBytes;\n\n\ta_assert(wp);\n\n\tnBytes = websWrite(wp, T(\"<SELECT NAME=\\\"privilege\\\" SIZE=\\\"3\\\" \"));\n\tnBytes += websWrite(wp, T(\"MULTIPLE TITLE=\\\"Choose Privileges\\\">\"));\n\tnBytes += websWrite(wp, T(\"<OPTION VALUE=\\\"%d\\\">READ\\n\"), PRIV_READ);\n\tnBytes += websWrite(wp, T(\"<OPTION VALUE=\\\"%d\\\">EXECUTE\\n\"), PRIV_WRITE);\n\tnBytes += websWrite(wp, T(\"<OPTION VALUE=\\\"%d\\\">ADMINISTRATE\\n\"), \n\t\tPRIV_ADMIN);\n\tnBytes += websWrite(wp, T(\"</SELECT>\"));\n\n\treturn nBytes;\n}", "path": "umui.c", "repo_name": "blondak/wive-ng-web", "stars": 1, "license": "other", "language": "c", "size": 528}
{"docstring": "/******************************************************************************/\n/*\n *    Perform a write to the SSL socket\n */\n", "func_signal": "int websSSLWrite(websSSL_t *wsp, char_t *buf, int len)", "code": "{\n    int sslBytesSent;\n\n    a_assert(wsp);\n    a_assert(buf);\n\n    if (wsp == NULL) {\n        return -1;\n    }\n\n    sslBytesSent = SSL_send(wsp->mocanaConnectionInstance, buf, len);\n\n    if (0 > sslBytesSent)\n        sslBytesSent = -1;\n\n    return sslBytesSent;\n}", "path": "mocana_ssl.c", "repo_name": "blondak/wive-ng-web", "stars": 1, "license": "other", "language": "c", "size": 528}
{"docstring": "/******************************************************************************/\n", "func_signal": "static int\nmocana_SSL_computeHostKeys(char** ppCertificate, unsigned int *pCertLength,\n                            char** ppRsaKeyBlob,  unsigned int *pKeyBlobLength)", "code": "{\n    int   status;\n\n    *ppCertificate = NULL;\n    *ppRsaKeyBlob  = NULL;\n\n    /* check for pre-existing set of host keys */\n    if (0 > (status = mocana_SSL_testHostKeys(ppCertificate, pCertLength, ppRsaKeyBlob, pKeyBlobLength)))\n    {\n#ifdef __ENABLE_ALL_DEBUGGING__\n        printf(\"mocana_SSL_computeHostKeys: host keys do not exist, computing new key pair.\\n\");\n#endif\n\n        /* if not, compute new host keys */\n        if (0 > (status = SSL_generateCertificate(ppCertificate, pCertLength, ppRsaKeyBlob, pKeyBlobLength, SSL_EXAMPLE_KEY_SIZE)))\n            goto exit;\n\n        if (0 > (status = MOCANA_writeFile(SSL_CERTIFICATE_DER_FILE, *ppCertificate, *pCertLength)))\n            goto exit;\n\n        status = MOCANA_writeFile(SSL_RSA_HOST_KEYS, *ppRsaKeyBlob, *pKeyBlobLength);\n\n#ifdef __ENABLE_ALL_DEBUGGING__\n        printf(\"mocana_SSL_computeHostKeys: host key computation completed.\\n\");\n#endif\n    }\n\nexit:\n    if (0 > status)\n        SSL_freeCertificate(ppCertificate, ppRsaKeyBlob);\n\n    return status;\n}", "path": "mocana_ssl.c", "repo_name": "blondak/wive-ng-web", "stars": 1, "license": "other", "language": "c", "size": 528}
{"docstring": "/******************************************************************************/\n/*\n *  Add a group\n */\n", "func_signal": "static void formAddGroup(webs_t wp, char_t *path, char_t *query)", "code": "{\n\tchar_t\t\t\t*group, *enabled, *privilege, *method, *ok, *pChar;\n\tint\t\t\t\tnCheck;\n\tshort\t\t\tpriv;\n\taccessMeth_t\tam;\n\tbool_t\t\t\tbDisable;\n\n\ta_assert(wp);\n\n\tgroup = websGetVar(wp, T(\"group\"), T(\"\")); \n\tmethod = websGetVar(wp, T(\"method\"), T(\"\")); \n\tenabled = websGetVar(wp, T(\"enabled\"), T(\"\")); \n\tprivilege = websGetVar(wp, T(\"privilege\"), T(\"\")); \n\tok = websGetVar(wp, T(\"ok\"), T(\"\")); \n\n\twebsHeader(wp);\n\twebsMsgStart(wp);\n\n\tif (gstricmp(ok, T(\"ok\")) != 0) {\n\t\twebsWrite(wp, T(\"Add Group Cancelled.\"));\n\t} else if ((group == NULL) || (*group == 0)) {\n\t\twebsWrite(wp, T(\"No Group Name was entered.\"));\n\t} else if (umGroupExists(group)) {\n\t\twebsWrite(wp, T(\"ERROR: Group, \\\"%s\\\" already exists.\"), group);\n\t} else {\n\t\tif (privilege && *privilege) {\n/*\n *\t\t\tprivilege is a mulitple <SELECT> var, and must be parsed.\n *\t\t\tValues for these variables are space delimited.\n */\n\t\t\tpriv = 0;\n\t\t\tfor (pChar = privilege; *pChar; pChar++) {\n\t\t\t\tif (*pChar == ' ') {\n\t\t\t\t\t*pChar = '\\0';\n\t\t\t\t\tpriv |= gatoi(privilege);\n\t\t\t\t\t*pChar = ' ';\n\t\t\t\t\tprivilege = pChar + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpriv |= gatoi(privilege);\n\t\t} else {\n\t\t\tpriv = 0;\n\t\t}\n\n\t\tif (method && *method) {\n\t\t\tam = (accessMeth_t) gatoi(method);\n\t\t} else {\n\t\t\tam = AM_FULL;\n\t\t}\n\n\t\tif (enabled && *enabled && (gstrcmp(enabled, T(\"on\")) == 0)) {\n\t\t\tbDisable = FALSE;\n\t\t} else {\n\t\t\tbDisable = TRUE;\n\t\t}\n\n\t\tnCheck = umAddGroup(group, priv, am, 0, bDisable);\n\t\tif (nCheck != 0) {\n\t\t\twebsWrite(wp, T(\"Unable to add group, \\\"%s\\\", code: %d \"),\n\t\t\t\tgroup, nCheck);\n\t\t} else {\n\t\t\twebsWrite(wp, T(\"Group, \\\"%s\\\" was successfully added.\"), \n\t\t\t\tgroup);\n\t\t}\n\t}\n\n\twebsMsgEnd(wp);\n\twebsFooter(wp);\n\twebsDone(wp, 200);\n}", "path": "umui.c", "repo_name": "blondak/wive-ng-web", "stars": 1, "license": "other", "language": "c", "size": 528}
{"docstring": "/******************************************************************************/\n/*\n *  Add an access limit\n */\n", "func_signal": "static void formAddAccessLimit(webs_t wp, char_t *path, char_t *query)", "code": "{\n\tchar_t\t\t\t*url, *method, *group, *secure, *ok;\n\tint\t\t\t\tnCheck;\n\taccessMeth_t\tam;\n\tshort\t\t\tnSecure;\n\n\ta_assert(wp);\n\n\turl = websGetVar(wp, T(\"url\"), T(\"\")); \n\tgroup = websGetVar(wp, T(\"group\"), T(\"\")); \n\tmethod = websGetVar(wp, T(\"method\"), T(\"\")); \n\tsecure = websGetVar(wp, T(\"secure\"), T(\"\")); \n\tok = websGetVar(wp, T(\"ok\"), T(\"\")); \n\n\twebsHeader(wp);\n\twebsMsgStart(wp);\n\n\tif (gstricmp(ok, T(\"ok\")) != 0) {\n\t\twebsWrite(wp, T(\"Add Access Limit Cancelled.\"));\n\t} else if ((url == NULL) || (*url == 0)) {\n\t\twebsWrite(wp, T(\"ERROR:  No URL was entered.\"));\n\t} else if (umAccessLimitExists(url)) {\n\t\twebsWrite(wp, T(\"ERROR:  An Access Limit for [%s] already exists.\"),\n\t\t\turl);\n\t} else {\n\t\tif (method && *method) {\n\t\t\tam = (accessMeth_t) gatoi(method);\n\t\t} else {\n\t\t\tam = AM_FULL;\n\t\t}\n\n\t\tif (secure && *secure) {\n\t\t\tnSecure = (short) gatoi(secure);\n\t\t} else {\n\t\t\tnSecure = 0;\n\t\t}\n\n\t\tnCheck = umAddAccessLimit(url, am, nSecure, group);\n\t\tif (nCheck != 0) {\n\t\t\twebsWrite(wp, T(\"Unable to add Access Limit for [%s]\"),\turl);\n\t\t} else {\n\t\t\twebsWrite(wp, T(\"Access limit for [%s], was successfully added.\"),\n\t\t\t\turl);\n\t\t}\n\t}\n\n\twebsMsgEnd(wp);\n\twebsFooter(wp);\n\twebsDone(wp, 200);\n}", "path": "umui.c", "repo_name": "blondak/wive-ng-web", "stars": 1, "license": "other", "language": "c", "size": 528}
{"docstring": "/******************************************************************************/\n/*\n *  Generate HTML to create a list box containing the users\n */\n", "func_signal": "static int aspGenerateUserList(int eid, webs_t wp, int argc, char_t **argv)", "code": "{\n\tchar_t\t*userid;\n\tint\t\trow, nBytesSent, nBytes;\n\n\ta_assert(wp);\n\n\tnBytes = websWrite(wp, \n\t\tT(\"<SELECT NAME=\\\"user\\\" SIZE=\\\"3\\\" TITLE=\\\"Select a User\\\">\"));\n\trow = 0;\n\tuserid = umGetFirstUser();\n\tnBytesSent = 0;\n\n\twhile (userid && (nBytes > 0)) {\n\t\tnBytes = websWrite(wp, T(\"<OPTION VALUE=\\\"%s\\\">%s\\n\"), \n\t\t\tuserid, userid);\n\t\tuserid = umGetNextUser(userid);\n\t\tnBytesSent += nBytes;\n\t}\n\n\tnBytesSent += websWrite(wp, T(\"</SELECT>\"));\n\n\treturn nBytesSent;\n}", "path": "umui.c", "repo_name": "blondak/wive-ng-web", "stars": 1, "license": "other", "language": "c", "size": 528}
{"docstring": "/******************************************************************************/\n/*\n *    Free SSL resources\n */\n", "func_signal": "int websSSLFree(websSSL_t *wsp)", "code": "{\n    int status;\n    if (NULL != wsp)\n    {\n        int mci;\n\n        mci = wsp->mocanaConnectionInstance;\n\n        status = SSL_closeConnection(mci);\n\n        if (0 > status)\n            status = -1;\n\n        /* Free memory here.... */\n        bfree(B_L, wsp);\n    }\n\n    return status;\n}", "path": "mocana_ssl.c", "repo_name": "blondak/wive-ng-web", "stars": 1, "license": "other", "language": "c", "size": 528}
{"docstring": "/******************************************************************************/\n/*\n *    Handler for SSL Read Events\n */\n", "func_signal": "static int websSSLReadEvent (webs_t wp)", "code": "{\n    int            ret = 07, sock;\n    socket_t    *sptr;\n    int         connectionInstance;\n\n    a_assert (wp);\n    a_assert(websValid(wp));\n\n    sptr = socketPtr(wp->sid);\n    a_assert(sptr);\n\n    sock = sptr->sock;\n\n/*\n *    Create a new SSL session for this web request\n */\n\n    connectionInstance = SSL_acceptConnection(sock);\n\n    if (0 > connectionInstance)\n    {\n#ifdef __ENABLE_ALL_DEBUGGING__\n        printf(\"websSSLReadEvent: SSL_acceptConnection failed. %d\\n\", connectionInstance);\n#endif\n\n        /* SSL error: cleanup */\n        websTimeoutCancel(wp);\n        socketCloseConnection(wp->sid);\n        websFree(wp);\n\n        return -1;\n    }\n\n/*\n *    Create the SSL data structure in the wp.\n */\n    wp->wsp = balloc(B_L, sizeof(websSSL_t));\n    a_assert (wp->wsp);\n\n    (wp->wsp)->mocanaConnectionInstance = connectionInstance;\n    (wp->wsp)->wp                       = wp;\n\n/*\n *    Call the default Read Event\n */\n    websReadEvent(wp);\n\n    return ret;\n}", "path": "mocana_ssl.c", "repo_name": "blondak/wive-ng-web", "stars": 1, "license": "other", "language": "c", "size": 528}
{"docstring": "/******************************************************************************/\n/*\n *  Delete a group\n */\n", "func_signal": "static void formDeleteGroup(webs_t wp, char_t *path, char_t *query)", "code": "{\n\tchar_t\t*group, *ok;\n\n\ta_assert(wp);\n\n\tgroup = websGetVar(wp, T(\"group\"), T(\"\")); \n\tok = websGetVar(wp, T(\"ok\"), T(\"\")); \n\n\twebsHeader(wp);\n\twebsMsgStart(wp);\n\n\tif (gstricmp(ok, T(\"ok\")) != 0) {\n\t\twebsWrite(wp, T(\"Delete Group Cancelled.\"));\n\t} else if ((group == NULL) || (*group == '\\0')) {\n\t\twebsWrite(wp, T(\"ERROR: No group was selected.\"));\n\t} else if (umGetGroupProtected(group)) {\n\t\twebsWrite(wp, T(\"ERROR: Group, \\\"%s\\\" is delete-protected.\"), group);\n\t} else if (umGetGroupInUse(group)) {\n\t\twebsWrite(wp, T(\"ERROR: Group, \\\"%s\\\" is being used.\"),\tgroup);\n\t} else if (umDeleteGroup(group) != 0) {\n\t\twebsWrite(wp, T(\"ERROR: Unable to delete group, \\\"%s\\\" \"), group);\n\t} else {\n\t\twebsWrite(wp, T(\"Group, \\\"%s\\\" was successfully deleted.\"), group);\n\t}\n\n\twebsMsgEnd(wp);\n\twebsFooter(wp);\n\twebsDone(wp, 200);\n}", "path": "umui.c", "repo_name": "blondak/wive-ng-web", "stars": 1, "license": "other", "language": "c", "size": 528}
{"docstring": "/******************************************************************************/\n/*\n *    The webs socket handler.  Called in response to I/O. We just pass control\n *    to the relevant read or write handler. A pointer to the webs structure\n *    is passed as an (int) in iwp.\n */\n", "func_signal": "static void websSSLSocketEvent(int sid, int mask, int iwp)", "code": "{\n    webs_t    wp;\n\n    wp = (webs_t) iwp;\n    a_assert(wp);\n\n    if (! websValid(wp)) {\n        return;\n    }\n\n    if (mask & SOCKET_READABLE) {\n        websSSLReadEvent(wp);\n    }\n    if (mask & SOCKET_WRITABLE) {\n        if (wp->writeSocket) {\n            (*wp->writeSocket)(wp);\n        }\n    }\n}", "path": "mocana_ssl.c", "repo_name": "blondak/wive-ng-web", "stars": 1, "license": "other", "language": "c", "size": 528}
{"docstring": "/******************************************************************************/\n/*\n *  Generate HTML to create a list box containing the groups\n */\n", "func_signal": "static int aspGenerateGroupList(int eid, webs_t wp, int argc, char_t **argv)", "code": "{\n\tchar_t\t*group;\n\tint\t\trow, nBytesSent, nBytes;\n\n\ta_assert(wp);\n\n\trow = 0;\n\tnBytesSent = 0;\n\tnBytes = websWrite(wp, \n\t\tT(\"<SELECT NAME=\\\"group\\\" SIZE=\\\"3\\\" TITLE=\\\"Select a Group\\\">\"));\n/*\n *  Add a special \"<NONE>\" element to allow de-selection\n */\n\tnBytes = websWrite(wp, T(\"<OPTION VALUE=\\\"\\\">[NONE]\\n\"));\n\n\tgroup = umGetFirstGroup();\n\twhile (group && (nBytes > 0)) {\n\t\tnBytes = websWrite(wp, T(\"<OPTION VALUE=\\\"%s\\\">%s\\n\"), group, group);\n\t\tgroup = umGetNextGroup(group);\n\t\tnBytesSent += nBytes;\n\t}\n\n\tnBytesSent += websWrite(wp, T(\"</SELECT>\"));\n\n\treturn nBytesSent;\n}", "path": "umui.c", "repo_name": "blondak/wive-ng-web", "stars": 1, "license": "other", "language": "c", "size": 528}
{"docstring": "/******************************************************************************/\n/*\n *    Return Eof for the underlying socket\n */\n", "func_signal": "int websSSLEof(websSSL_t *wsp)", "code": "{\n    webs_t      wp;\n    int         sid;\n\n    a_assert(wsp);\n\n    wp  = wsp->wp;\n    sid = wp->sid;\n\n    return socketEof(sid);\n}", "path": "mocana_ssl.c", "repo_name": "blondak/wive-ng-web", "stars": 1, "license": "other", "language": "c", "size": 528}
{"docstring": "/******************************************************************************/\n/*\n *    Stops the SSL system\n */\n", "func_signal": "void websSSLClose()", "code": "{\n    SSL_shutdown();\n    mocana_SSL_releaseHostKeys(&pCertificate, &pRsaKeyBlob);\n    SSL_releaseTables();\n    MOCANA_freeMocana();\n}", "path": "mocana_ssl.c", "repo_name": "blondak/wive-ng-web", "stars": 1, "license": "other", "language": "c", "size": 528}
{"docstring": "/******************************************************************************/\n", "func_signal": "static int\nmocana_SSL_releaseHostKeys(char **ppCertificate, char **ppRsaKeyBlob)", "code": "{\n    MOCANA_freeReadFile(ppCertificate);\n    MOCANA_freeReadFile(ppRsaKeyBlob);\n\n    return 0;\n}", "path": "mocana_ssl.c", "repo_name": "blondak/wive-ng-web", "stars": 1, "license": "other", "language": "c", "size": 528}
{"docstring": "/******************************************************************************/\n/*\n *  Add a user\n */\n", "func_signal": "static void formAddUser(webs_t wp, char_t *path, char_t *query)", "code": "{\n\tchar_t\t*userid, *pass1, *pass2, *group, *enabled, *ok;\n\tbool_t bDisable;\n\tint\tnCheck;\n\n\ta_assert(wp);\n\n\tuserid = websGetVar(wp, T(\"user\"), T(\"\")); \n\tpass1 = websGetVar(wp, T(\"password\"), T(\"\")); \n\tpass2 = websGetVar(wp, T(\"passconf\"), T(\"\")); \n\tgroup = websGetVar(wp, T(\"group\"), T(\"\")); \n\tenabled = websGetVar(wp, T(\"enabled\"), T(\"\")); \n\tok = websGetVar(wp, T(\"ok\"), T(\"\")); \n\n\twebsHeader(wp);\n\twebsMsgStart(wp);\n\n\tif (gstricmp(ok, T(\"ok\")) != 0) {\n\t\twebsWrite(wp, T(\"Add User Cancelled\"));\n\t} else if (gstrcmp(pass1, pass2) != 0) {\n\t\twebsWrite(wp, T(\"Confirmation Password did not match.\"));\n\t} else {\n\t\tif (enabled && *enabled && (gstrcmp(enabled, T(\"on\")) == 0)) {\n\t\t\tbDisable = FALSE;\n\t\t} else {\n\t\t\tbDisable = TRUE;\n\t\t}\n\n\t\tnCheck = umAddUser(userid, pass1, group, 0, bDisable);\n\t\tif (nCheck != 0) {\n\t\t\tchar_t * strError;\n\n\t\t\tswitch (nCheck) {\n\t\t\tcase UM_ERR_DUPLICATE:\n\t\t\t\tstrError = T(\"User already exists.\");\n\t\t\t\tbreak;\n\n\t\t\tcase UM_ERR_BAD_NAME:\n\t\t\t\tstrError = T(\"Invalid user name.\");\n\t\t\t\tbreak;\n\n\t\t\tcase UM_ERR_BAD_PASSWORD:\n\t\t\t\tstrError = T(\"Invalid password.\");\n\t\t\t\tbreak;\n\n\t\t\tcase UM_ERR_NOT_FOUND:\n\t\t\t\tstrError = T(\"Invalid or unselected group.\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tstrError = T(\"Error writing user record.\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\twebsWrite(wp, T(\"Unable to add user, \\\"%s\\\".  %s\"),\n\t\t\t\tuserid, strError);\n\t\t} else {\n\t\t\twebsWrite(wp, T(\"User, \\\"%s\\\" was successfully added.\"),\n\t\t\t\tuserid);\n\t\t}\n\t}\n\n\twebsMsgEnd(wp);\n\twebsFooter(wp);\n\twebsDone(wp, 200);\n}", "path": "umui.c", "repo_name": "blondak/wive-ng-web", "stars": 1, "license": "other", "language": "c", "size": 528}
{"docstring": "/******************************************************************************/\n/*\n *   Flush stub for compatibility\n */\n", "func_signal": "int websSSLFlush(websSSL_t *wsp)", "code": "{\n    a_assert(wsp);\n\n    /* Autoflush - do nothing */\n    return 0;\n}", "path": "mocana_ssl.c", "repo_name": "blondak/wive-ng-web", "stars": 1, "license": "other", "language": "c", "size": 528}
{"docstring": "/******************************************************************************/\n/*\n *    Accept a connection\n */\n", "func_signal": "int websSSLAccept(int sid, char *ipaddr, int port, int listenSid)", "code": "{\n    webs_t    wp;\n    int        wid;\n\n    a_assert(ipaddr && *ipaddr);\n    a_assert(sid >= 0);\n    a_assert(port >= 0);\n\n/*\n *    Allocate a new handle for this accepted connection. This will allocate\n *    a webs_t structure in the webs[] list\n */\n    if ((wid = websAlloc(sid)) < 0) {\n        return -1;\n    }\n    wp = webs[wid];\n    a_assert(wp);\n    wp->listenSid = listenSid;\n\n    ascToUni(wp->ipaddr, ipaddr, min(sizeof(wp->ipaddr), strlen(ipaddr)+1));\n\n/*\n *    Check if this is a request from a browser on this system. This is useful\n *    to know for permitting administrative operations only for local access\n */\n    if (gstrcmp(wp->ipaddr, T(\"127.0.0.1\")) == 0 ||\n            gstrcmp(wp->ipaddr, websIpaddr) == 0 ||\n            gstrcmp(wp->ipaddr, websHost) == 0) {\n        wp->flags |= WEBS_LOCAL_REQUEST;\n    }\n/*\n *    Since the acceptance came in on this channel, it must be secure\n */\n    wp->flags |= WEBS_SECURE;\n\n/*\n *    Arrange for websSocketEvent to be called when read data is available\n */\n    socketCreateHandler(sid, SOCKET_READABLE, websSSLSocketEvent, (int) wp);\n\n/*\n *    Arrange for a timeout to kill hung requests\n */\n    wp->timeout = emfSchedCallback(WEBS_TIMEOUT, websTimeout, (void *) wp);\n    trace(8, T(\"webs: accept request\\n\"));\n    return 0;\n}", "path": "mocana_ssl.c", "repo_name": "blondak/wive-ng-web", "stars": 1, "license": "other", "language": "c", "size": 528}
{"docstring": "/******************************************************************************/\n/*\n *    Perform a gets of the SSL socket, returning an balloc'ed string\n *\n *    Get a string from a socket. This returns data in *buf in a malloced string\n *    after trimming the '\\n'. If there is zero bytes returned, *buf will be set\n *    to NULL. If doing non-blocking I/O, it returns -1 for error, EOF or when\n *    no complete line yet read. If doing blocking I/O, it will block until an\n *    entire line is read. If a partial line is read socketInputBuffered or\n *    socketEof can be used to distinguish between EOF and partial line still\n *    buffered. This routine eats and ignores carriage returns.\n */\n", "func_signal": "int    websSSLGets(websSSL_t *wsp, char_t **buf)", "code": "{\n    socket_t    *sp;\n    ringq_t        *lq;\n    char        c;\n    int            rc, len;\n    webs_t      wp;\n    int         sid;\n    int         mci;\n    int         numBytesReceived;\n\n    a_assert(wsp);\n    a_assert(buf);\n\n    *buf = NULL;\n\n    wp  = wsp->wp;\n    sid = wp->sid;\n    mci = wsp->mocanaConnectionInstance;\n\n    if ((sp = socketPtr(sid)) == NULL) {\n        return -1;\n    }\n    lq = &sp->lineBuf;\n\n    while (1) {\n\n        if ((rc = SSL_recv(mci, &c, 1, &numBytesReceived)) < 0)\n        {\n            if (0 > rc)\n                rc = -1;\n\n            return rc;\n        }\n\n        if (numBytesReceived == 0) {\n/*\n *            If there is a partial line and we are at EOF, pretend we saw a '\\n'\n */\n            if (ringqLen(lq) > 0 && (sp->flags & SOCKET_EOF)) {\n                c = '\\n';\n            } else {\n                continue;\n            }\n        }\n/*\n *        If a newline is seen, return the data excluding the new line to the\n *        caller. If carriage return is seen, just eat it.\n */\n        if (c == '\\n') {\n            len = ringqLen(lq);\n            if (len > 0) {\n                *buf = ballocAscToUni((char *)lq->servp, len);\n            } else {\n                *buf = NULL;\n            }\n            ringqFlush(lq);\n            return len;\n\n        } else if (c == '\\r') {\n            continue;\n        }\n        ringqPutcA(lq, c);\n    }\n    return 0;\n}", "path": "mocana_ssl.c", "repo_name": "blondak/wive-ng-web", "stars": 1, "license": "other", "language": "c", "size": 528}
{"docstring": "/******************************************************************************/\n/*\n *  Delete a user\n */\n", "func_signal": "static void formDeleteUser(webs_t wp, char_t *path, char_t *query)", "code": "{\n\tchar_t\t*userid, *ok;\n\n\ta_assert(wp);\n\n\tuserid = websGetVar(wp, T(\"user\"), T(\"\")); \n\tok = websGetVar(wp, T(\"ok\"), T(\"\")); \n\n\twebsHeader(wp);\n\twebsMsgStart(wp);\n\n\tif (gstricmp(ok, T(\"ok\")) != 0) {\n\t\twebsWrite(wp, T(\"Delete User Cancelled\"));\n\t} else if (umUserExists(userid) == FALSE) {\n\t\twebsWrite(wp, T(\"ERROR: User \\\"%s\\\" not found\"), userid);\n\t} else if (umGetUserProtected(userid)) {\n\t\twebsWrite(wp, T(\"ERROR: User, \\\"%s\\\" is delete-protected.\"), userid);\n\t} else if (umDeleteUser(userid) != 0) {\n\t\twebsWrite(wp, T(\"ERROR: Unable to delete user, \\\"%s\\\" \"), userid);\n\t} else {\n\t\twebsWrite(wp, T(\"User, \\\"%s\\\" was successfully deleted.\"), userid);\n\t}\n\n\twebsMsgEnd(wp);\n\twebsFooter(wp);\n\twebsDone(wp, 200);\n}", "path": "umui.c", "repo_name": "blondak/wive-ng-web", "stars": 1, "license": "other", "language": "c", "size": 528}
{"docstring": "/*\n * Allocate a compatible register and put it on the unfenced list.\n */\n", "func_signal": "int drm_regs_alloc(struct drm_reg_manager *manager,\n\t\t   const void *data,\n\t\t   uint32_t fence_class,\n\t\t   uint32_t fence_type,\n\t\t   int interruptible, int no_wait, struct drm_reg **reg)", "code": "{\n\tstruct drm_reg *entry, *next_entry;\n\tint ret;\n\n\t*reg = NULL;\n\n\t/*\n\t * Search the unfenced list.\n\t */\n\n\tlist_for_each_entry(entry, &manager->unfenced, head) {\n\t\tif (manager->reg_reusable(entry, data)) {\n\t\t\tentry->new_fence_type |= fence_type;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * Search the lru list.\n\t */\n\n\tlist_for_each_entry_safe(entry, next_entry, &manager->lru, head) {\n\t\tstruct drm_fence_object *fence = entry->fence;\n\t\tif (fence->fence_class == fence_class &&\n\t\t    (entry->fence_type & fence_type) == entry->fence_type &&\n\t\t    manager->reg_reusable(entry, data)) {\n\t\t\tlist_del(&entry->head);\n\t\t\tentry->new_fence_type = fence_type;\n\t\t\tlist_add_tail(&entry->head, &manager->unfenced);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * Search the free list.\n\t */\n\n\tlist_for_each_entry(entry, &manager->free, head) {\n\t\tlist_del(&entry->head);\n\t\tentry->new_fence_type = fence_type;\n\t\tlist_add_tail(&entry->head, &manager->unfenced);\n\t\tgoto out;\n\t}\n\n\tif (no_wait)\n\t\treturn -EBUSY;\n\n\t/*\n\t * Go back to the lru list and try to expire fences.\n\t */\n\n\tlist_for_each_entry_safe(entry, next_entry, &manager->lru, head) {\n\t\tBUG_ON(!entry->fence);\n\t\tret = drm_fence_object_wait(entry->fence, 0, !interruptible,\n\t\t\t\t\t    entry->fence_type);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdrm_fence_usage_deref_unlocked(&entry->fence);\n\t\tlist_del(&entry->head);\n\t\tentry->new_fence_type = fence_type;\n\t\tlist_add_tail(&entry->head, &manager->unfenced);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Oops. All registers are used up :(.\n\t */\n\n\treturn -EBUSY;\nout:\n\t*reg = entry;\n\treturn 0;\n}", "path": "drm_regman.c", "repo_name": "jobi/drm-psb", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 836}
{"docstring": "/**\n * Used by mach64_dump_ring_info() to dump the contents of the current buffer\n * pointed by the ring head.\n */\n", "func_signal": "static void mach64_dump_buf_info(drm_mach64_private_t * dev_priv,\n\t\t\t\t drm_buf_t * buf)", "code": "{\n\tu32 addr = GETBUFADDR(buf);\n\tu32 used = buf->used >> 2;\n\tu32 sys_addr = MACH64_READ(MACH64_BM_SYSTEM_MEM_ADDR);\n\tu32 *p = GETBUFPTR(buf);\n\tint skipped = 0;\n\n\tDRM_INFO(\"buffer contents:\\n\");\n\n\twhile (used) {\n\t\tu32 reg, count;\n\n\t\treg = le32_to_cpu(*p++);\n\t\tif (addr <= GETBUFADDR(buf) + MACH64_DUMP_CONTEXT * 4 ||\n\t\t    (addr >= sys_addr - MACH64_DUMP_CONTEXT * 4 &&\n\t\t     addr <= sys_addr + MACH64_DUMP_CONTEXT * 4) ||\n\t\t    addr >=\n\t\t    GETBUFADDR(buf) + buf->used - MACH64_DUMP_CONTEXT * 4) {\n\t\t\tDRM_INFO(\"%08x:  0x%08x\\n\", addr, reg);\n\t\t}\n\t\taddr += 4;\n\t\tused--;\n\n\t\tcount = (reg >> 16) + 1;\n\t\treg = reg & 0xffff;\n\t\treg = MMSELECT(reg);\n\t\twhile (count && used) {\n\t\t\tif (addr <= GETBUFADDR(buf) + MACH64_DUMP_CONTEXT * 4 ||\n\t\t\t    (addr >= sys_addr - MACH64_DUMP_CONTEXT * 4 &&\n\t\t\t     addr <= sys_addr + MACH64_DUMP_CONTEXT * 4) ||\n\t\t\t    addr >=\n\t\t\t    GETBUFADDR(buf) + buf->used -\n\t\t\t    MACH64_DUMP_CONTEXT * 4) {\n\t\t\t\tDRM_INFO(\"%08x:    0x%04x = 0x%08x\\n\", addr,\n\t\t\t\t\t reg, le32_to_cpu(*p));\n\t\t\t\tskipped = 0;\n\t\t\t} else {\n\t\t\t\tif (!skipped) {\n\t\t\t\t\tDRM_INFO(\"  ...\\n\");\n\t\t\t\t\tskipped = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp++;\n\t\t\taddr += 4;\n\t\t\tused--;\n\n\t\t\treg += 4;\n\t\t\tcount--;\n\t\t}\n\t}\n\n\tDRM_INFO(\"\\n\");\n}", "path": "mach64_dma.c", "repo_name": "jobi/drm-psb", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 836}
{"docstring": "/*\n * Hooks a segment of data into the tail of the ring-buffer by\n * modifying the pause address stored in the buffer itself. If\n * the regulator has already paused, restart it.\n */\n", "func_signal": "static int via_hook_segment(drm_via_private_t * dev_priv,\n\t\t\t    uint32_t pause_addr_hi, uint32_t pause_addr_lo,\n\t\t\t    int no_pci_fire)", "code": "{\n\tint paused, count;\n\tvolatile uint32_t *paused_at = dev_priv->last_pause_ptr;\n\tuint32_t reader,ptr;\n\n\tpaused = 0;\n\tvia_flush_write_combine();\n\t(void) *(volatile uint32_t *)(via_get_dma(dev_priv) -1);\n\t*paused_at = pause_addr_lo;\n\tvia_flush_write_combine();\n\t(void) *paused_at;\n\treader = *(dev_priv->hw_addr_ptr);\n\tptr = ((volatile char *)paused_at - dev_priv->dma_ptr) +\n\t\tdev_priv->dma_offset + (uint32_t) dev_priv->agpAddr + 4;\n\tdev_priv->last_pause_ptr = via_get_dma(dev_priv) - 1;\n\n\tif ((ptr - reader) <= dev_priv->dma_diff ) {\n\t\tcount = 10000000;\n\t\twhile (!(paused = (VIA_READ(0x41c) & 0x80000000)) && count--);\n\t}\n\n\tif (paused && !no_pci_fire) {\n\t\treader = *(dev_priv->hw_addr_ptr);\n\t\tif ((ptr - reader) == dev_priv->dma_diff) {\n\n\t\t\t/*\n\t\t\t * There is a concern that these writes may stall the PCI bus\n\t\t\t * if the GPU is not idle. However, idling the GPU first\n\t\t\t * doesn't make a difference.\n\t\t\t */\n\n\t\t\tVIA_WRITE(VIA_REG_TRANSET, (HC_ParaType_PreCR << 16));\n\t\t\tVIA_WRITE(VIA_REG_TRANSPACE, pause_addr_hi);\n\t\t\tVIA_WRITE(VIA_REG_TRANSPACE, pause_addr_lo);\n\t\t\tVIA_READ(VIA_REG_TRANSPACE);\n\t\t}\n\t}\n\n\treturn paused;\n}", "path": "via_dma.c", "repo_name": "jobi/drm-psb", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 836}
{"docstring": "/*\n * Checks whether buffer head has reach the end. Rewind the ring buffer\n * when necessary.\n *\n * Returns virtual pointer to ring buffer.\n */\n", "func_signal": "static inline uint32_t *via_check_dma(drm_via_private_t * dev_priv,\n\t\t\t\t      unsigned int size)", "code": "{\n\tif ((dev_priv->dma_low + size + 4 * CMDBUF_ALIGNMENT_SIZE) >\n\t    dev_priv->dma_high) {\n\t\tvia_cmdbuf_rewind(dev_priv);\n\t}\n\tif (via_cmdbuf_wait(dev_priv, size) != 0) {\n\t\treturn NULL;\n\t}\n\n\treturn (uint32_t *) (dev_priv->dma_ptr + dev_priv->dma_low);\n}", "path": "via_dma.c", "repo_name": "jobi/drm-psb", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 836}
{"docstring": "/**\n * Wait for the draw engine to be idle.\n */\n", "func_signal": "int mach64_do_wait_for_idle(drm_mach64_private_t * dev_priv)", "code": "{\n\tint i, ret;\n\n\tret = mach64_do_wait_for_fifo(dev_priv, 16);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < dev_priv->usec_timeout; i++) {\n\t\tif (!(MACH64_READ(MACH64_GUI_STAT) & MACH64_GUI_ACTIVE)) {\n\t\t\treturn 0;\n\t\t}\n\t\tDRM_UDELAY(1);\n\t}\n\n\tDRM_INFO(\"%s failed! GUI_STAT=0x%08x\\n\", __FUNCTION__,\n\t\t MACH64_READ(MACH64_GUI_STAT));\n\tmach64_dump_ring_info(dev_priv);\n\treturn DRM_ERR(EBUSY);\n}", "path": "mach64_dma.c", "repo_name": "jobi/drm-psb", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 836}
{"docstring": "/*\n * G70\t\t0x47\n * G71\t\t0x49\n * NV45\t\t0x48\n * G72[M]\t0x46\n * G73\t\t0x4b\n * C51_G7X\t0x4c\n * C51\t\t0x4e\n */\n", "func_signal": "int\nnv40_graph_init(drm_device_t *dev)", "code": "{\n\tdrm_nouveau_private_t *dev_priv =\n\t\t(drm_nouveau_private_t *)dev->dev_private;\n\tuint32_t *ctx_voodoo;\n\tuint32_t vramsz, tmp;\n\tint i, j;\n\n\tNV_WRITE(NV03_PMC_ENABLE, NV_READ(NV03_PMC_ENABLE) &\n\t\t\t~NV_PMC_ENABLE_PGRAPH);\n\tNV_WRITE(NV03_PMC_ENABLE, NV_READ(NV03_PMC_ENABLE) |\n\t\t\t NV_PMC_ENABLE_PGRAPH);\n\n\tswitch (dev_priv->chipset) {\n\tcase 0x40: ctx_voodoo = nv40_ctx_voodoo; break;\n\tcase 0x43: ctx_voodoo = nv43_ctx_voodoo; break;\n\tcase 0x46: ctx_voodoo = nv46_ctx_voodoo; break;\n\tcase 0x4a: ctx_voodoo = nv4a_ctx_voodoo; break;\n\tcase 0x4e: ctx_voodoo = nv4e_ctx_voodoo; break;\n\tdefault:\n\t\tDRM_ERROR(\"Unknown ctx_voodoo for chipset 0x%02x\\n\",\n\t\t\t\tdev_priv->chipset);\n\t\tctx_voodoo = NULL;\n\t\tbreak;\n\t}\n\n\t/* Load the context voodoo onto the card */\n\tif (ctx_voodoo) {\n\t\tDRM_DEBUG(\"Loading context-switch voodoo\\n\");\n\t\ti = 0;\n\n\t\tNV_WRITE(0x400324, 0);\n\t\twhile (ctx_voodoo[i] != ~0) {\n\t\t\tNV_WRITE(0x400328, ctx_voodoo[i]);\n\t\t\ti++;\n\t\t}\n\t}\t\n\n\t/* No context present currently */\n\tNV_WRITE(0x40032C, 0x00000000);\n\n\tNV_WRITE(NV03_PGRAPH_INTR_EN, 0x00000000);\n\tNV_WRITE(NV03_PGRAPH_INTR   , 0xFFFFFFFF);\n\n\tNV_WRITE(NV04_PGRAPH_DEBUG_0, 0xFFFFFFFF);\n\tNV_WRITE(NV04_PGRAPH_DEBUG_0, 0x00000000);\n\tNV_WRITE(NV04_PGRAPH_DEBUG_1, 0x401287c0);\n\tNV_WRITE(NV04_PGRAPH_DEBUG_3, 0xe0de8055);\n\tNV_WRITE(NV10_PGRAPH_DEBUG_4, 0x00008000);\n\tNV_WRITE(NV04_PGRAPH_LIMIT_VIOL_PIX, 0x00be3c5f);\n\n\tNV_WRITE(NV10_PGRAPH_CTX_CONTROL, 0x10010100);\n\tNV_WRITE(NV10_PGRAPH_STATE      , 0xFFFFFFFF);\n\tNV_WRITE(NV04_PGRAPH_FIFO       , 0x00000001);\n\n\tj = NV_READ(0x1540) & 0xff;\n\tif (j) {\n\t\tfor (i=0; !(j&1); j>>=1, i++);\n\t\tNV_WRITE(0x405000, i);\n\t}\n\n\tif (dev_priv->chipset == 0x40) {\n\t\tNV_WRITE(0x4009b0, 0x83280fff);\n\t\tNV_WRITE(0x4009b4, 0x000000a0);\n\t} else {\n\t\tNV_WRITE(0x400820, 0x83280eff);\n\t\tNV_WRITE(0x400824, 0x000000a0);\n\t}\n\n\tswitch (dev_priv->chipset) {\n\tcase 0x40:\n\tcase 0x45:\n\t\tNV_WRITE(0x4009b8, 0x0078e366);\n\t\tNV_WRITE(0x4009bc, 0x0000014c);\n\t\tbreak;\n\tcase 0x41:\n\tcase 0x42: /* pciid also 0x00Cx */\n//\tcase 0x0120: //XXX (pciid)\n\t\tNV_WRITE(0x400828, 0x007596ff);\n\t\tNV_WRITE(0x40082c, 0x00000108);\n\t\tbreak;\n\tcase 0x43:\n\t\tNV_WRITE(0x400828, 0x0072cb77);\n\t\tNV_WRITE(0x40082c, 0x00000108);\n\t\tbreak;\n\tcase 0x44:\n\tcase 0x46: /* G72 */\n\tcase 0x4a:\n\tcase 0x4c: /* G7x-based C51 */\n\tcase 0x4e:\n\t\tNV_WRITE(0x400860, 0);\n\t\tNV_WRITE(0x400864, 0);\n\t\tbreak;\n\tcase 0x47: /* G70 */\n\tcase 0x49: /* G71 */\n\tcase 0x4b: /* G73 */\n\t\tNV_WRITE(0x400828, 0x07830610);\n\t\tNV_WRITE(0x40082c, 0x0000016A);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tNV_WRITE(0x400b38, 0x2ffff800);\n\tNV_WRITE(0x400b3c, 0x00006000);\n\n\t/* copy tile info from PFB */\n\tswitch (dev_priv->chipset) {\n\tcase 0x40: /* vanilla NV40 */\n\t\tfor (i=0; i<NV10_PFB_TILE__SIZE; i++) {\n\t\t\ttmp = NV_READ(NV10_PFB_TILE(i));\n\t\t\tNV_WRITE(NV40_PGRAPH_TILE0(i), tmp);\n\t\t\tNV_WRITE(NV40_PGRAPH_TILE1(i), tmp);\n\t\t\ttmp = NV_READ(NV10_PFB_TLIMIT(i));\n\t\t\tNV_WRITE(NV40_PGRAPH_TLIMIT0(i), tmp);\n\t\t\tNV_WRITE(NV40_PGRAPH_TLIMIT1(i), tmp);\n\t\t\ttmp = NV_READ(NV10_PFB_TSIZE(i));\n\t\t\tNV_WRITE(NV40_PGRAPH_TSIZE0(i), tmp);\n\t\t\tNV_WRITE(NV40_PGRAPH_TSIZE1(i), tmp);\n\t\t\ttmp = NV_READ(NV10_PFB_TSTATUS(i));\n\t\t\tNV_WRITE(NV40_PGRAPH_TSTATUS0(i), tmp);\n\t\t\tNV_WRITE(NV40_PGRAPH_TSTATUS1(i), tmp);\n\t\t}\n\t\tbreak;\n\tcase 0x44:\n\tcase 0x4a:\n\tcase 0x4e: /* NV44-based cores don't have 0x406900? */\n\t\tfor (i=0; i<NV40_PFB_TILE__SIZE_0; i++) {\n\t\t\ttmp = NV_READ(NV40_PFB_TILE(i));\n\t\t\tNV_WRITE(NV40_PGRAPH_TILE0(i), tmp);\n\t\t\ttmp = NV_READ(NV40_PFB_TLIMIT(i));\n\t\t\tNV_WRITE(NV40_PGRAPH_TLIMIT0(i), tmp);\n\t\t\ttmp = NV_READ(NV40_PFB_TSIZE(i));\n\t\t\tNV_WRITE(NV40_PGRAPH_TSIZE0(i), tmp);\n\t\t\ttmp = NV_READ(NV40_PFB_TSTATUS(i));\n\t\t\tNV_WRITE(NV40_PGRAPH_TSTATUS0(i), tmp);\n\t\t}\n\t\tbreak;\n\tcase 0x46:\n\tcase 0x47:\n\tcase 0x49:\n\tcase 0x4b: /* G7X-based cores */\n\t\tfor (i=0; i<NV40_PFB_TILE__SIZE_1; i++) {\n\t\t\ttmp = NV_READ(NV40_PFB_TILE(i));\n\t\t\tNV_WRITE(NV47_PGRAPH_TILE0(i), tmp);\n\t\t\tNV_WRITE(NV40_PGRAPH_TILE1(i), tmp);\n\t\t\ttmp = NV_READ(NV40_PFB_TLIMIT(i));\n\t\t\tNV_WRITE(NV47_PGRAPH_TLIMIT0(i), tmp);\n\t\t\tNV_WRITE(NV40_PGRAPH_TLIMIT1(i), tmp);\n\t\t\ttmp = NV_READ(NV40_PFB_TSIZE(i));\n\t\t\tNV_WRITE(NV47_PGRAPH_TSIZE0(i), tmp);\n\t\t\tNV_WRITE(NV40_PGRAPH_TSIZE1(i), tmp);\n\t\t\ttmp = NV_READ(NV40_PFB_TSTATUS(i));\n\t\t\tNV_WRITE(NV47_PGRAPH_TSTATUS0(i), tmp);\n\t\t\tNV_WRITE(NV40_PGRAPH_TSTATUS1(i), tmp);\n\t\t}\n\t\tbreak;\n\tdefault: /* everything else */\n\t\tfor (i=0; i<NV40_PFB_TILE__SIZE_0; i++) {\n\t\t\ttmp = NV_READ(NV40_PFB_TILE(i));\n\t\t\tNV_WRITE(NV40_PGRAPH_TILE0(i), tmp);\n\t\t\tNV_WRITE(NV40_PGRAPH_TILE1(i), tmp);\n\t\t\ttmp = NV_READ(NV40_PFB_TLIMIT(i));\n\t\t\tNV_WRITE(NV40_PGRAPH_TLIMIT0(i), tmp);\n\t\t\tNV_WRITE(NV40_PGRAPH_TLIMIT1(i), tmp);\n\t\t\ttmp = NV_READ(NV40_PFB_TSIZE(i));\n\t\t\tNV_WRITE(NV40_PGRAPH_TSIZE0(i), tmp);\n\t\t\tNV_WRITE(NV40_PGRAPH_TSIZE1(i), tmp);\n\t\t\ttmp = NV_READ(NV40_PFB_TSTATUS(i));\n\t\t\tNV_WRITE(NV40_PGRAPH_TSTATUS0(i), tmp);\n\t\t\tNV_WRITE(NV40_PGRAPH_TSTATUS1(i), tmp);\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* begin RAM config */\n\tvramsz = drm_get_resource_len(dev, 0) - 1;\n\tswitch (dev_priv->chipset) {\n\tcase 0x40:\n\t\tNV_WRITE(0x4009A4, NV_READ(NV04_PFB_CFG0));\n\t\tNV_WRITE(0x4009A8, NV_READ(NV04_PFB_CFG1));\n\t\tNV_WRITE(0x4069A4, NV_READ(NV04_PFB_CFG0));\n\t\tNV_WRITE(0x4069A8, NV_READ(NV04_PFB_CFG1));\n\t\tNV_WRITE(0x400820, 0);\n\t\tNV_WRITE(0x400824, 0);\n\t\tNV_WRITE(0x400864, vramsz);\n\t\tNV_WRITE(0x400868, vramsz);\n\t\tbreak;\n\tdefault:\n\t\tswitch (dev_priv->chipset) {\n\t\tcase 0x46:\n\t\tcase 0x47:\n\t\tcase 0x49:\n\t\tcase 0x4b:\n\t\t\tNV_WRITE(0x400DF0, NV_READ(NV04_PFB_CFG0));\n\t\t\tNV_WRITE(0x400DF4, NV_READ(NV04_PFB_CFG1));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNV_WRITE(0x4009F0, NV_READ(NV04_PFB_CFG0));\n\t\t\tNV_WRITE(0x4009F4, NV_READ(NV04_PFB_CFG1));\n\t\t\tbreak;\n\t\t}\n\t\tNV_WRITE(0x4069F0, NV_READ(NV04_PFB_CFG0));\n\t\tNV_WRITE(0x4069F4, NV_READ(NV04_PFB_CFG1));\n\t\tNV_WRITE(0x400840, 0);\n\t\tNV_WRITE(0x400844, 0);\n\t\tNV_WRITE(0x4008A0, vramsz);\n\t\tNV_WRITE(0x4008A4, vramsz);\n\t\tbreak;\n\t}\n\n\t/* per-context state, doesn't belong here */\n\tNV_WRITE(0x400B20, 0x00000000);\n\tNV_WRITE(0x400B04, 0xFFFFFFFF);\n\n\ttmp = NV_READ(NV10_PGRAPH_SURFACE) & 0x0007ff00;\n\tNV_WRITE(NV10_PGRAPH_SURFACE, tmp);\n\ttmp = NV_READ(NV10_PGRAPH_SURFACE) | 0x00020100;\n\tNV_WRITE(NV10_PGRAPH_SURFACE, tmp);\n\n\tNV_WRITE(NV03_PGRAPH_ABS_UCLIP_XMIN, 0);\n\tNV_WRITE(NV03_PGRAPH_ABS_UCLIP_YMIN, 0);\n\tNV_WRITE(NV03_PGRAPH_ABS_UCLIP_XMAX, 0x7fff);\n\tNV_WRITE(NV03_PGRAPH_ABS_UCLIP_YMAX, 0x7fff);\n\n\treturn 0;\n}", "path": "nv40_graph.c", "repo_name": "jobi/drm-psb", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 836}
{"docstring": "/* Save current context (from PGRAPH) into the channel's context\n *XXX: fails sometimes, not sure why..\n */\n", "func_signal": "void\nnv40_graph_context_save_current(drm_device_t *dev)", "code": "{\n\tdrm_nouveau_private_t *dev_priv =\n\t\t(drm_nouveau_private_t *)dev->dev_private;\n\tuint32_t instance;\n\tint i;\n\n\tNV_WRITE(NV04_PGRAPH_FIFO, 0);\n\n\tinstance = NV_READ(0x40032C) & 0xFFFFF;\n\tif (!instance) {\n\t\tNV_WRITE(NV04_PGRAPH_FIFO, 1);\n\t\treturn;\n\t}\n\n\tNV_WRITE(0x400784, instance);\n\tNV_WRITE(0x400310, NV_READ(0x400310) | 0x20);\n\tNV_WRITE(0x400304, 1);\n\t/* just in case, we don't want to spin in-kernel forever */\n\tfor (i=0; i<1000; i++) {\n\t\tif (NV_READ(0x40030C) == 0)\n\t\t\tbreak;\n\t}\n\tif (i==1000) {\n\t\tDRM_ERROR(\"failed to save current grctx to ramin\\n\");\n\t\tDRM_ERROR(\"instance = 0x%08x\\n\", NV_READ(0x40032C));\n\t\tDRM_ERROR(\"0x40030C = 0x%08x\\n\", NV_READ(0x40030C));\n\t\tNV_WRITE(NV04_PGRAPH_FIFO, 1);\n\t\treturn;\n\t}\n\n\tNV_WRITE(NV04_PGRAPH_FIFO, 1);\n}", "path": "nv40_graph.c", "repo_name": "jobi/drm-psb", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 836}
{"docstring": "/*******************************************************************/\n/** MMIO Pseudo-DMA (intended primarily for debugging, not performance)\n */\n", "func_signal": "int mach64_do_dispatch_pseudo_dma(drm_mach64_private_t * dev_priv)", "code": "{\n\tdrm_mach64_descriptor_ring_t *ring = &dev_priv->ring;\n\tvolatile u32 *ring_read;\n\tstruct list_head *ptr;\n\tdrm_mach64_freelist_t *entry;\n\tdrm_buf_t *buf = NULL;\n\tu32 *buf_ptr;\n\tu32 used, reg, target;\n\tint fifo, count, found, ret, no_idle_wait;\n\n\tfifo = count = reg = no_idle_wait = 0;\n\ttarget = MACH64_BM_ADDR;\n\n\tif ((ret = mach64_do_wait_for_idle(dev_priv)) < 0) {\n\t\tDRM_INFO\n\t\t    (\"%s: idle failed before pseudo-dma dispatch, resetting engine\\n\",\n\t\t     __FUNCTION__);\n\t\tmach64_dump_engine_info(dev_priv);\n\t\tmach64_do_engine_reset(dev_priv);\n\t\treturn ret;\n\t}\n\n\tring_read = (u32 *) ring->start;\n\n\twhile (ring->tail != ring->head) {\n\t\tu32 buf_addr, new_target, offset;\n\t\tu32 bytes, remaining, head, eol;\n\n\t\thead = ring->head;\n\n\t\tnew_target =\n\t\t    le32_to_cpu(ring_read[head++]) - MACH64_APERTURE_OFFSET;\n\t\tbuf_addr = le32_to_cpu(ring_read[head++]);\n\t\teol = le32_to_cpu(ring_read[head]) & MACH64_DMA_EOL;\n\t\tbytes = le32_to_cpu(ring_read[head++])\n\t\t    & ~(MACH64_DMA_HOLD_OFFSET | MACH64_DMA_EOL);\n\t\thead++;\n\t\thead &= ring->tail_mask;\n\n\t\t/* can't wait for idle between a blit setup descriptor\n\t\t * and a HOSTDATA descriptor or the engine will lock\n\t\t */\n\t\tif (new_target == MACH64_BM_HOSTDATA\n\t\t    && target == MACH64_BM_ADDR)\n\t\t\tno_idle_wait = 1;\n\n\t\ttarget = new_target;\n\n\t\tfound = 0;\n\t\toffset = 0;\n\t\tlist_for_each(ptr, &dev_priv->pending) {\n\t\t\tentry = list_entry(ptr, drm_mach64_freelist_t, list);\n\t\t\tbuf = entry->buf;\n\t\t\toffset = buf_addr - GETBUFADDR(buf);\n\t\t\tif (offset >= 0 && offset < MACH64_BUFFER_SIZE) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found || buf == NULL) {\n\t\t\tDRM_ERROR\n\t\t\t    (\"Couldn't find pending buffer: head: %u tail: %u buf_addr: 0x%08x %s\\n\",\n\t\t\t     head, ring->tail, buf_addr, (eol ? \"eol\" : \"\"));\n\t\t\tmach64_dump_ring_info(dev_priv);\n\t\t\tmach64_do_engine_reset(dev_priv);\n\t\t\treturn DRM_ERR(EINVAL);\n\t\t}\n\n\t\t/* Hand feed the buffer to the card via MMIO, waiting for the fifo\n\t\t * every 16 writes\n\t\t */\n\t\tDRM_DEBUG(\"target: (0x%08x) %s\\n\", target,\n\t\t\t  (target ==\n\t\t\t   MACH64_BM_HOSTDATA ? \"BM_HOSTDATA\" : \"BM_ADDR\"));\n\t\tDRM_DEBUG(\"offset: %u bytes: %u used: %u\\n\", offset, bytes,\n\t\t\t  buf->used);\n\n\t\tremaining = (buf->used - offset) >> 2;\t/* dwords remaining in buffer */\n\t\tused = bytes >> 2;\t/* dwords in buffer for this descriptor */\n\t\tbuf_ptr = (u32 *) ((char *)GETBUFPTR(buf) + offset);\n\n\t\twhile (used) {\n\n\t\t\tif (count == 0) {\n\t\t\t\tif (target == MACH64_BM_HOSTDATA) {\n\t\t\t\t\treg = DMAREG(MACH64_HOST_DATA0);\n\t\t\t\t\tcount =\n\t\t\t\t\t    (remaining > 16) ? 16 : remaining;\n\t\t\t\t\tfifo = 0;\n\t\t\t\t} else {\n\t\t\t\t\treg = le32_to_cpu(*buf_ptr++);\n\t\t\t\t\tused--;\n\t\t\t\t\tcount = (reg >> 16) + 1;\n\t\t\t\t}\n\n\t\t\t\treg = reg & 0xffff;\n\t\t\t\treg = MMSELECT(reg);\n\t\t\t}\n\t\t\twhile (count && used) {\n\t\t\t\tif (!fifo) {\n\t\t\t\t\tif (no_idle_wait) {\n\t\t\t\t\t\tif ((ret =\n\t\t\t\t\t\t     mach64_do_wait_for_fifo\n\t\t\t\t\t\t     (dev_priv, 16)) < 0) {\n\t\t\t\t\t\t\tno_idle_wait = 0;\n\t\t\t\t\t\t\treturn ret;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ((ret =\n\t\t\t\t\t\t     mach64_do_wait_for_idle\n\t\t\t\t\t\t     (dev_priv)) < 0) {\n\t\t\t\t\t\t\treturn ret;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfifo = 16;\n\t\t\t\t}\n\t\t\t\t--fifo;\n\t\t\t\tMACH64_WRITE(reg, le32_to_cpu(*buf_ptr++));\n\t\t\t\tused--;\n\t\t\t\tremaining--;\n\n\t\t\t\treg += 4;\n\t\t\t\tcount--;\n\t\t\t}\n\t\t}\n\t\tring->head = head;\n\t\tring->head_addr = ring->start_addr + (ring->head * sizeof(u32));\n\t\tring->space += (4 * sizeof(u32));\n\t}\n\n\tif ((ret = mach64_do_wait_for_idle(dev_priv)) < 0) {\n\t\treturn ret;\n\t}\n\tMACH64_WRITE(MACH64_BM_GUI_TABLE_CMD,\n\t\t     ring->head_addr | MACH64_CIRCULAR_BUF_SIZE_16KB);\n\n\tDRM_DEBUG(\"%s completed\\n\", __FUNCTION__);\n\treturn 0;\n}", "path": "mach64_dma.c", "repo_name": "jobi/drm-psb", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 836}
{"docstring": "/**\n * Reset the the ring buffer descriptors.\n *\n * \\sa mach64_do_engine_reset()\n */\n", "func_signal": "static void mach64_ring_reset(drm_mach64_private_t * dev_priv)", "code": "{\n\tdrm_mach64_descriptor_ring_t *ring = &dev_priv->ring;\n\n\tmach64_do_release_used_buffers(dev_priv);\n\tring->head_addr = ring->start_addr;\n\tring->head = ring->tail = 0;\n\tring->space = ring->size;\n\n\tMACH64_WRITE(MACH64_BM_GUI_TABLE_CMD,\n\t\t     ring->head_addr | MACH64_CIRCULAR_BUF_SIZE_16KB);\n\n\tdev_priv->ring_running = 0;\n}", "path": "mach64_dma.c", "repo_name": "jobi/drm-psb", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 836}
{"docstring": "/*\n * Check that the given size fits in the buffer, otherwise wait.\n */\n", "func_signal": "static inline int\nvia_cmdbuf_wait(drm_via_private_t * dev_priv, unsigned int size)", "code": "{\n\tuint32_t agp_base = dev_priv->dma_offset + (uint32_t) dev_priv->agpAddr;\n\tuint32_t cur_addr, hw_addr, next_addr;\n\tvolatile uint32_t *hw_addr_ptr;\n\tuint32_t count;\n\thw_addr_ptr = dev_priv->hw_addr_ptr;\n\tcur_addr = dev_priv->dma_low;\n\tnext_addr = cur_addr + size + 512 * 1024;\n\tcount = 1000000;\n\tdo {\n\t\thw_addr = *hw_addr_ptr - agp_base;\n\t\tif (count-- == 0) {\n\t\t\tDRM_ERROR\n\t\t\t    (\"via_cmdbuf_wait timed out hw %x cur_addr %x next_addr %x\\n\",\n\t\t\t    hw_addr, cur_addr, next_addr);\n\t\t\treturn -1;\n\t\t}\n\t} while ((cur_addr < hw_addr) && (next_addr >= hw_addr));\n\treturn 0;\n}", "path": "via_dma.c", "repo_name": "jobi/drm-psb", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 836}
{"docstring": "/**\n * Stop all DMA activity.\n */\n", "func_signal": "int mach64_do_dma_idle(drm_mach64_private_t * dev_priv)", "code": "{\n\tint ret;\n\n\t/* wait for completion */\n\tif ((ret = mach64_ring_idle(dev_priv)) < 0) {\n\t\tDRM_ERROR(\"%s failed BM_GUI_TABLE=0x%08x tail: %u\\n\",\n\t\t\t  __FUNCTION__, MACH64_READ(MACH64_BM_GUI_TABLE),\n\t\t\t  dev_priv->ring.tail);\n\t\treturn ret;\n\t}\n\n\tmach64_ring_stop(dev_priv);\n\n\t/* clean up after pass */\n\tmach64_do_release_used_buffers(dev_priv);\n\treturn 0;\n}", "path": "mach64_dma.c", "repo_name": "jobi/drm-psb", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 836}
{"docstring": "/* IMPORTANT: This function should only be called when the engine is idle or locked up,\n * as it assumes all buffers in the pending list have been completed by the hardware.\n */\n", "func_signal": "int mach64_do_release_used_buffers(drm_mach64_private_t * dev_priv)", "code": "{\n\tstruct list_head *ptr;\n\tstruct list_head *tmp;\n\tdrm_mach64_freelist_t *entry;\n\tint i;\n\n\tif (list_empty(&dev_priv->pending))\n\t\treturn 0;\n\n\t/* Iterate the pending list and move all buffers into the freelist... */\n\ti = 0;\n\tlist_for_each_safe(ptr, tmp, &dev_priv->pending) {\n\t\tentry = list_entry(ptr, drm_mach64_freelist_t, list);\n\t\tif (entry->discard) {\n\t\t\tentry->buf->pending = 0;\n\t\t\tlist_del(ptr);\n\t\t\tlist_add_tail(ptr, &dev_priv->free_list);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tDRM_DEBUG(\"%s: released %d buffers from pending list\\n\", __FUNCTION__,\n\t\t  i);\n\n\treturn 0;\n}", "path": "mach64_dma.c", "repo_name": "jobi/drm-psb", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 836}
{"docstring": "/*TODO: deciper what each offset in the context represents. The below\n *      contexts are taken from dumps just after the 3D object is\n *      created.\n */\n", "func_signal": "static void nv40_graph_context_init(drm_device_t *dev, struct mem_block *ctx)", "code": "{\n\tdrm_nouveau_private_t *dev_priv = dev->dev_private;\n\tint i;\n\n\t/* Always has the \"instance address\" of itself at offset 0 */\n\tINSTANCE_WR(ctx, 0x00000/4, nouveau_chip_instance_get(dev, ctx));\n\t/* unknown */\n\tINSTANCE_WR(ctx, 0x00024/4, 0x0000ffff);\n\tINSTANCE_WR(ctx, 0x00028/4, 0x0000ffff);\n\tINSTANCE_WR(ctx, 0x00030/4, 0x00000001);\n\tINSTANCE_WR(ctx, 0x0011c/4, 0x20010001);\n\tINSTANCE_WR(ctx, 0x00120/4, 0x0f73ef00);\n\tINSTANCE_WR(ctx, 0x00128/4, 0x02008821);\n\tINSTANCE_WR(ctx, 0x0016c/4, 0x00000040);\n\tINSTANCE_WR(ctx, 0x00170/4, 0x00000040);\n\tINSTANCE_WR(ctx, 0x00174/4, 0x00000040);\n\tINSTANCE_WR(ctx, 0x0017c/4, 0x80000000);\n\tINSTANCE_WR(ctx, 0x00180/4, 0x80000000);\n\tINSTANCE_WR(ctx, 0x00184/4, 0x80000000);\n\tINSTANCE_WR(ctx, 0x00188/4, 0x80000000);\n\tINSTANCE_WR(ctx, 0x0018c/4, 0x80000000);\n\tINSTANCE_WR(ctx, 0x0019c/4, 0x00000040);\n\tINSTANCE_WR(ctx, 0x001a0/4, 0x80000000);\n\tINSTANCE_WR(ctx, 0x001b0/4, 0x80000000);\n\tINSTANCE_WR(ctx, 0x001c0/4, 0x80000000);\n\tINSTANCE_WR(ctx, 0x001d0/4, 0x0b0b0b0c);\n\tINSTANCE_WR(ctx, 0x00340/4, 0x00040000);\n\tINSTANCE_WR(ctx, 0x00350/4, 0x55555555);\n\tINSTANCE_WR(ctx, 0x00354/4, 0x55555555);\n\tINSTANCE_WR(ctx, 0x00358/4, 0x55555555);\n\tINSTANCE_WR(ctx, 0x0035c/4, 0x55555555);\n\tINSTANCE_WR(ctx, 0x00388/4, 0x00000008);\n\tINSTANCE_WR(ctx, 0x0039c/4, 0x00000010);\n\tINSTANCE_WR(ctx, 0x00480/4, 0x00000100);\n\tINSTANCE_WR(ctx, 0x00494/4, 0x00000111);\n\tINSTANCE_WR(ctx, 0x00498/4, 0x00080060);\n\tINSTANCE_WR(ctx, 0x004b4/4, 0x00000080);\n\tINSTANCE_WR(ctx, 0x004b8/4, 0xffff0000);\n\tINSTANCE_WR(ctx, 0x004bc/4, 0x00000001);\n\tINSTANCE_WR(ctx, 0x004d0/4, 0x46400000);\n\tINSTANCE_WR(ctx, 0x004ec/4, 0xffff0000);\n\tINSTANCE_WR(ctx, 0x004f8/4, 0x0fff0000);\n\tINSTANCE_WR(ctx, 0x004fc/4, 0x0fff0000);\n\tINSTANCE_WR(ctx, 0x00504/4, 0x00011100);\n\tfor (i=0x00520; i<=0x0055c; i+=4)\n\t\tINSTANCE_WR(ctx, i/4, 0x07ff0000);\n\tINSTANCE_WR(ctx, 0x00568/4, 0x4b7fffff);\n\tINSTANCE_WR(ctx, 0x00594/4, 0x30201000);\n\tINSTANCE_WR(ctx, 0x00598/4, 0x70605040);\n\tINSTANCE_WR(ctx, 0x0059c/4, 0xb8a89888);\n\tINSTANCE_WR(ctx, 0x005a0/4, 0xf8e8d8c8);\n\tINSTANCE_WR(ctx, 0x005b4/4, 0x40100000);\n\tINSTANCE_WR(ctx, 0x005cc/4, 0x00000004);\n\tINSTANCE_WR(ctx, 0x005d8/4, 0x0000ffff);\n\tINSTANCE_WR(ctx, 0x0060c/4, 0x435185d6);\n\tINSTANCE_WR(ctx, 0x00610/4, 0x2155b699);\n\tINSTANCE_WR(ctx, 0x00614/4, 0xfedcba98);\n\tINSTANCE_WR(ctx, 0x00618/4, 0x00000098);\n\tINSTANCE_WR(ctx, 0x00628/4, 0xffffffff);\n\tINSTANCE_WR(ctx, 0x0062c/4, 0x00ff7000);\n\tINSTANCE_WR(ctx, 0x00630/4, 0x0000ffff);\n\tINSTANCE_WR(ctx, 0x00640/4, 0x00ff0000);\n\tINSTANCE_WR(ctx, 0x0067c/4, 0x00ffff00);\n\t/* 0x680-0x6BC - NV30_TCL_PRIMITIVE_3D_TX_ADDRESS_UNIT(0-15) */\n\t/* 0x6C0-0x6FC - NV30_TCL_PRIMITIVE_3D_TX_FORMAT_UNIT(0-15) */\n\tfor (i=0x006C0; i<=0x006fc; i+=4)\n\t\tINSTANCE_WR(ctx, i/4, 0x00018488);\n\t/* 0x700-0x73C - NV30_TCL_PRIMITIVE_3D_TX_WRAP_UNIT(0-15) */\n\tfor (i=0x00700; i<=0x0073c; i+=4)\n\t\tINSTANCE_WR(ctx, i/4, 0x00028202);\n\t/* 0x740-0x77C - NV30_TCL_PRIMITIVE_3D_TX_ENABLE_UNIT(0-15) */\n\t/* 0x780-0x7BC - NV30_TCL_PRIMITIVE_3D_TX_SWIZZLE_UNIT(0-15) */\n\tfor (i=0x00780; i<=0x007bc; i+=4)\n\t\tINSTANCE_WR(ctx, i/4, 0x0000aae4);\n\t/* 0x7C0-0x7FC - NV30_TCL_PRIMITIVE_3D_TX_FILTER_UNIT(0-15) */\n\tfor (i=0x007c0; i<=0x007fc; i+=4)\n\t\tINSTANCE_WR(ctx, i/4, 0x01012000);\n\t/* 0x800-0x83C - NV30_TCL_PRIMITIVE_3D_TX_XY_DIM_UNIT(0-15) */\n\tfor (i=0x00800; i<=0x0083c; i+=4)\n\t\tINSTANCE_WR(ctx, i/4, 0x00080008);\n\t/* 0x840-0x87C - NV30_TCL_PRIMITIVE_3D_TX_UNK07_UNIT(0-15) */\n\t/* 0x880-0x8BC - NV30_TCL_PRIMITIVE_3D_TX_DEPTH_UNIT(0-15) */\n\tfor (i=0x00880; i<=0x008bc; i+=4)\n\t\tINSTANCE_WR(ctx, i/4, 0x00100008);\n\t/* unknown */\n\tfor (i=0x00910; i<=0x0091c; i+=4)\n\t\tINSTANCE_WR(ctx, i/4, 0x0001bc80);\n\tfor (i=0x00920; i<=0x0092c; i+=4)\n\t\tINSTANCE_WR(ctx, i/4, 0x00000202);\n\tfor (i=0x00940; i<=0x0094c; i+=4)\n\t\tINSTANCE_WR(ctx, i/4, 0x00000008);\n\tfor (i=0x00960; i<=0x0096c; i+=4)\n\t\tINSTANCE_WR(ctx, i/4, 0x00080008);\n\tINSTANCE_WR(ctx, 0x00980/4, 0x00000002);\n\tINSTANCE_WR(ctx, 0x009b4/4, 0x00000001);\n\tINSTANCE_WR(ctx, 0x009c0/4, 0x3e020200);\n\tINSTANCE_WR(ctx, 0x009c4/4, 0x00ffffff);\n\tINSTANCE_WR(ctx, 0x009c8/4, 0x60103f00);\n\tINSTANCE_WR(ctx, 0x009d4/4, 0x00020000);\n\tINSTANCE_WR(ctx, 0x00a08/4, 0x00008100);\n\tINSTANCE_WR(ctx, 0x00aac/4, 0x00000001);\n\tINSTANCE_WR(ctx, 0x00af0/4, 0x00000001);\n\tINSTANCE_WR(ctx, 0x00af8/4, 0x80800001);\n\tINSTANCE_WR(ctx, 0x00bcc/4, 0x00000005);\n\tINSTANCE_WR(ctx, 0x00bf8/4, 0x00005555);\n\tINSTANCE_WR(ctx, 0x00bfc/4, 0x00005555);\n\tINSTANCE_WR(ctx, 0x00c00/4, 0x00005555);\n\tINSTANCE_WR(ctx, 0x00c04/4, 0x00005555);\n\tINSTANCE_WR(ctx, 0x00c08/4, 0x00005555);\n\tINSTANCE_WR(ctx, 0x00c0c/4, 0x00005555);\n\tINSTANCE_WR(ctx, 0x00c44/4, 0x00000001);\n\tfor (i=0x03008; i<=0x03080; i+=8)\n\t\tINSTANCE_WR(ctx, i/4, 0x3f800000);\n\tfor (i=0x05288; i<=0x08570; i+=24)\n\t\tINSTANCE_WR(ctx, i/4, 0x00000001);\n\tfor (i=0x08628; i<=0x08e18; i+=16)\n\t\tINSTANCE_WR(ctx, i/4, 0x3f800000);\n\tfor (i=0x0bd28; i<=0x0f010; i+=24)\n\t\tINSTANCE_WR(ctx, i/4, 0x00000001);\n\tfor (i=0x0f0c8; i<=0x0f8b8; i+=16)\n\t\tINSTANCE_WR(ctx, i/4, 0x3f800000);\n\tfor (i=0x127c8; i<=0x15ab0; i+=24)\n\t\tINSTANCE_WR(ctx, i/4, 0x00000001);\n\tfor (i=0x15b68; i<=0x16358; i+=16)\n\t\tINSTANCE_WR(ctx, i/4, 0x3f800000);\n\tfor (i=0x19268; i<=0x1c550; i+=24)\n\t\tINSTANCE_WR(ctx, i/4, 0x00000001);\n\tfor (i=0x1c608; i<=0x1cdf8; i+=16)\n\t\tINSTANCE_WR(ctx, i/4, 0x3f800000);\n\tfor (i=0x1fd08; i<=0x22ff0; i+=24)\n\t\tINSTANCE_WR(ctx, i/4, 0x00000001);\n\tfor (i=0x230a8; i<=0x23898; i+=16)\n\t\tINSTANCE_WR(ctx, i/4, 0x3f800000);\n\tfor (i=0x267a8; i<=0x29a90; i+=24)\n\t\tINSTANCE_WR(ctx, i/4, 0x00000001);\n\tfor (i=0x29b48; i<=0x2a338; i+=16)\n\t\tINSTANCE_WR(ctx, i/4, 0x3f800000);\n}", "path": "nv40_graph.c", "repo_name": "jobi/drm-psb", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 836}
{"docstring": "/**\n * Dump the ring state and contents, including the contents of the buffer being\n * processed by the graphics engine.\n */\n", "func_signal": "void mach64_dump_ring_info(drm_mach64_private_t * dev_priv)", "code": "{\n\tdrm_mach64_descriptor_ring_t *ring = &dev_priv->ring;\n\tint i, skipped;\n\n\tDRM_INFO(\"\\n\");\n\n\tDRM_INFO(\"ring contents:\\n\");\n\tDRM_INFO(\"  head_addr: 0x%08x head: %u tail: %u\\n\\n\",\n\t\t ring->head_addr, ring->head, ring->tail);\n\n\tskipped = 0;\n\tfor (i = 0; i < ring->size / sizeof(u32); i += 4) {\n\t\tif (i <= MACH64_DUMP_CONTEXT * 4 ||\n\t\t    i >= ring->size / sizeof(u32) - MACH64_DUMP_CONTEXT * 4 ||\n\t\t    (i >= ring->tail - MACH64_DUMP_CONTEXT * 4 &&\n\t\t     i <= ring->tail + MACH64_DUMP_CONTEXT * 4) ||\n\t\t    (i >= ring->head - MACH64_DUMP_CONTEXT * 4 &&\n\t\t     i <= ring->head + MACH64_DUMP_CONTEXT * 4)) {\n\t\t\tDRM_INFO(\"  0x%08x:  0x%08x 0x%08x 0x%08x 0x%08x%s%s\\n\",\n\t\t\t\t (u32)(ring->start_addr + i * sizeof(u32)),\n\t\t\t\t le32_to_cpu(((u32 *) ring->start)[i + 0]),\n\t\t\t\t le32_to_cpu(((u32 *) ring->start)[i + 1]),\n\t\t\t\t le32_to_cpu(((u32 *) ring->start)[i + 2]),\n\t\t\t\t le32_to_cpu(((u32 *) ring->start)[i + 3]),\n\t\t\t\t i == ring->head ? \" (head)\" : \"\",\n\t\t\t\t i == ring->tail ? \" (tail)\" : \"\");\n\t\t\tskipped = 0;\n\t\t} else {\n\t\t\tif (!skipped) {\n\t\t\t\tDRM_INFO(\"  ...\\n\");\n\t\t\t\tskipped = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tDRM_INFO(\"\\n\");\n\n\tif (ring->head >= 0 && ring->head < ring->size / sizeof(u32)) {\n\t\tstruct list_head *ptr;\n\t\tu32 addr = le32_to_cpu(((u32 *) ring->start)[ring->head + 1]);\n\n\t\tlist_for_each(ptr, &dev_priv->pending) {\n\t\t\tdrm_mach64_freelist_t *entry =\n\t\t\t    list_entry(ptr, drm_mach64_freelist_t, list);\n\t\t\tdrm_buf_t *buf = entry->buf;\n\n\t\t\tu32 buf_addr = GETBUFADDR(buf);\n\n\t\t\tif (buf_addr <= addr && addr < buf_addr + buf->used) {\n\t\t\t\tmach64_dump_buf_info(dev_priv, buf);\n\t\t\t}\n\t\t}\n\t}\n\n\tDRM_INFO(\"\\n\");\n\tDRM_INFO(\"       BM_GUI_TABLE = 0x%08x\\n\",\n\t\t MACH64_READ(MACH64_BM_GUI_TABLE));\n\tDRM_INFO(\"\\n\");\n\tDRM_INFO(\"BM_FRAME_BUF_OFFSET = 0x%08x\\n\",\n\t\t MACH64_READ(MACH64_BM_FRAME_BUF_OFFSET));\n\tDRM_INFO(\" BM_SYSTEM_MEM_ADDR = 0x%08x\\n\",\n\t\t MACH64_READ(MACH64_BM_SYSTEM_MEM_ADDR));\n\tDRM_INFO(\"         BM_COMMAND = 0x%08x\\n\",\n\t\t MACH64_READ(MACH64_BM_COMMAND));\n\tDRM_INFO(\"\\n\");\n\tDRM_INFO(\"          BM_STATUS = 0x%08x\\n\",\n\t\t MACH64_READ(MACH64_BM_STATUS));\n\tDRM_INFO(\"           BUS_CNTL = 0x%08x\\n\",\n\t\t MACH64_READ(MACH64_BUS_CNTL));\n\tDRM_INFO(\"          FIFO_STAT = 0x%08x\\n\",\n\t\t MACH64_READ(MACH64_FIFO_STAT));\n\tDRM_INFO(\"           GUI_STAT = 0x%08x\\n\",\n\t\t MACH64_READ(MACH64_GUI_STAT));\n\tDRM_INFO(\"           SRC_CNTL = 0x%08x\\n\",\n\t\t MACH64_READ(MACH64_SRC_CNTL));\n}", "path": "mach64_dma.c", "repo_name": "jobi/drm-psb", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 836}
{"docstring": "/**\n * Wait until all DMA requests have been processed... \n *\n * \\sa mach64_wait_ring()\n */\n", "func_signal": "static int mach64_ring_idle(drm_mach64_private_t * dev_priv)", "code": "{\n\tdrm_mach64_descriptor_ring_t *ring = &dev_priv->ring;\n\tu32 head;\n\tint i;\n\n\thead = ring->head;\n\ti = 0;\n\twhile (i < dev_priv->usec_timeout) {\n\t\tmach64_update_ring_snapshot(dev_priv);\n\t\tif (ring->head == ring->tail &&\n\t\t    !(MACH64_READ(MACH64_GUI_STAT) & MACH64_GUI_ACTIVE)) {\n\t\t\tif (i > 0) {\n\t\t\t\tDRM_DEBUG(\"%s: %d usecs\\n\", __FUNCTION__, i);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif (ring->head == head) {\n\t\t\t++i;\n\t\t} else {\n\t\t\thead = ring->head;\n\t\t\ti = 0;\n\t\t}\n\t\tDRM_UDELAY(1);\n\t}\n\n\tDRM_INFO(\"%s failed! GUI_STAT=0x%08x\\n\", __FUNCTION__,\n\t\t MACH64_READ(MACH64_GUI_STAT));\n\tmach64_dump_ring_info(dev_priv);\n\treturn DRM_ERR(EBUSY);\n}", "path": "mach64_dma.c", "repo_name": "jobi/drm-psb", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 836}
{"docstring": "/* Restore the context for a specific channel into PGRAPH\n * XXX: fails sometimes.. not sure why\n */\n", "func_signal": "void\nnv40_graph_context_restore(drm_device_t *dev, int channel)", "code": "{\n\tdrm_nouveau_private_t *dev_priv =\n\t\t(drm_nouveau_private_t *)dev->dev_private;\n\tstruct nouveau_fifo *chan = &dev_priv->fifos[channel];\n\tuint32_t instance;\n\tint i;\n\n\tinstance = nouveau_chip_instance_get(dev, chan->ramin_grctx);\n\n\tNV_WRITE(NV04_PGRAPH_FIFO, 0);\n\tNV_WRITE(0x400784, instance);\n\tNV_WRITE(0x400310, NV_READ(0x400310) | 0x40);\n\tNV_WRITE(0x400304, 1);\n\t/* just in case, we don't want to spin in-kernel forever */\n\tfor (i=0; i<1000; i++) {\n\t\tif (NV_READ(0x40030C) == 0)\n\t\t\tbreak;\n\t}\n\tif (i==1000) {\n\t\tDRM_ERROR(\"failed to restore grctx for ch%d to PGRAPH\\n\",\n\t\t\t\tchannel);\n\t\tDRM_ERROR(\"instance = 0x%08x\\n\", instance);\n\t\tDRM_ERROR(\"0x40030C = 0x%08x\\n\", NV_READ(0x40030C));\n\t\tNV_WRITE(NV04_PGRAPH_FIFO, 1);\n\t\treturn;\n\t}\n\n\n\t/* 0x40032C, no idea of it's exact function.  Could simply be a\n\t * record of the currently active PGRAPH context.  It's currently\n\t * unknown as to what bit 24 does.  The nv ddx has it set, so we will\n\t * set it here too.\n\t */\n\tNV_WRITE(0x40032C, instance | 0x01000000);\n\t/* 0x32E0 records the instance address of the active FIFO's PGRAPH\n\t * context.  If at any time this doesn't match 0x40032C, you will\n\t * recieve PGRAPH_INTR_CONTEXT_SWITCH\n\t */\n\tNV_WRITE(NV40_PFIFO_GRCTX_INSTANCE, instance);\n\tNV_WRITE(NV04_PGRAPH_FIFO, 1);\n}", "path": "nv40_graph.c", "repo_name": "jobi/drm-psb", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 836}
{"docstring": "/*\n * Block command submission and reset hardware and schedulers.\n */\n", "func_signal": "static void psb_reset_wq(struct work_struct *work)", "code": "{\n\tstruct drm_psb_private *dev_priv =\n\t    container_of(work, struct drm_psb_private, watchdog_wq);\n\tint lockup_2d;\n\tint idle_2d;\n\tunsigned long irq_flags;\n\tint ret;\n\tint reset_count = 0;\n\tstruct psb_xhw_buf buf;\n\tuint32_t xhw_lockup;\n\n\t/*\n\t * Block command submission.\n\t */\n\n\tmutex_lock(&dev_priv->reset_mutex);\n\n\tINIT_LIST_HEAD(&buf.head);\n\tif (psb_xhw_check_lockup(dev_priv, &buf, &xhw_lockup) == 0) {\n\t\tif (xhw_lockup == 0 && psb_extend_raster_timeout(dev_priv) == 0) {\n\t\t\t/*\n\t\t\t * no lockup, just re-schedule\n\t\t\t */\n\t\t\tspin_lock_irqsave(&dev_priv->watchdog_lock, irq_flags);\n\t\t\tdev_priv->timer_available = 1;\n\t\t\tspin_unlock_irqrestore(&dev_priv->watchdog_lock,\n\t\t\t\t\t       irq_flags);\n\t\t\tpsb_schedule_watchdog(dev_priv);\n\t\t\tmutex_unlock(&dev_priv->reset_mutex);\n\t\t\treturn;\n\t\t}\n\t}\n#if 0\n\tmsleep(PSB_2D_TIMEOUT_MSEC);\n\n\tpsb_seq_lockup_idle(dev_priv, PSB_ENGINE_2D, &lockup_2d, &idle_2d);\n\n\tif (lockup_2d) {\n\t\tuint32_t seq_2d;\n\t\tspin_lock(&dev_priv->sequence_lock);\n\t\tseq_2d = dev_priv->sequence[PSB_ENGINE_2D];\n\t\tspin_unlock(&dev_priv->sequence_lock);\n\t\tpsb_fence_error(dev_priv->scheduler.dev,\n\t\t\t\tPSB_ENGINE_2D,\n\t\t\t\tseq_2d, DRM_FENCE_TYPE_EXE, -EBUSY);\n\t\tDRM_INFO(\"Resetting 2D engine.\\n\");\n\t}\n\n\tpsb_reset(dev_priv, lockup_2d);\n#else\n\t(void)lockup_2d;\n\t(void)idle_2d;\n\tpsb_reset(dev_priv, 0);\n#endif\n\t(void)psb_xhw_mmu_reset(dev_priv);\n\tDRM_INFO(\"Resetting scheduler.\\n\");\n\tpsb_scheduler_pause(dev_priv);\n\tpsb_scheduler_reset(dev_priv, -EBUSY);\n\tpsb_scheduler_ta_mem_check(dev_priv);\n\n\twhile (dev_priv->ta_mem &&\n\t       !dev_priv->force_ta_mem_load && ++reset_count < 10) {\n\n\t\t/*\n\t\t * TA memory is currently fenced so offsets\n\t\t * are valid. Reload offsets into the dpm now.\n\t\t */\n\n\t\tstruct psb_xhw_buf buf;\n\t\tINIT_LIST_HEAD(&buf.head);\n\n\t\tmsleep(100);\n\t\tDRM_INFO(\"Trying to reload TA memory.\\n\");\n\t\tret = psb_xhw_ta_mem_load(dev_priv, &buf,\n\t\t\t\t\t  PSB_TA_MEM_FLAG_TA |\n\t\t\t\t\t  PSB_TA_MEM_FLAG_RASTER |\n\t\t\t\t\t  PSB_TA_MEM_FLAG_HOSTA |\n\t\t\t\t\t  PSB_TA_MEM_FLAG_HOSTD |\n\t\t\t\t\t  PSB_TA_MEM_FLAG_INIT,\n\t\t\t\t\t  dev_priv->ta_mem->ta_memory->offset,\n\t\t\t\t\t  dev_priv->ta_mem->hw_data->offset,\n\t\t\t\t\t  dev_priv->ta_mem->hw_cookie);\n\t\tif (!ret)\n\t\t\tbreak;\n\n\t\tpsb_reset(dev_priv, 0);\n\t\t(void)psb_xhw_mmu_reset(dev_priv);\n\t}\n\n\tpsb_scheduler_restart(dev_priv);\n\tspin_lock_irqsave(&dev_priv->watchdog_lock, irq_flags);\n\tdev_priv->timer_available = 1;\n\tspin_unlock_irqrestore(&dev_priv->watchdog_lock, irq_flags);\n\tmutex_unlock(&dev_priv->reset_mutex);\n}", "path": "psb_reset.c", "repo_name": "jobi/drm-psb", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 836}
{"docstring": "/*\n * Free space in command buffer.\n */\n", "func_signal": "static uint32_t via_cmdbuf_space(drm_via_private_t *dev_priv)", "code": "{\n\tuint32_t agp_base = dev_priv->dma_offset + (uint32_t) dev_priv->agpAddr;\n\tuint32_t hw_addr = *(dev_priv->hw_addr_ptr) - agp_base;\n\t\n\treturn ((hw_addr <= dev_priv->dma_low) ? \n\t\t(dev_priv->dma_high + hw_addr - dev_priv->dma_low) : \n\t\t(hw_addr - dev_priv->dma_low));\n}", "path": "via_dma.c", "repo_name": "jobi/drm-psb", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 836}
{"docstring": "/*\n * User interface to the space and lag functions.\n */\n", "func_signal": "static int via_cmdbuf_size(DRM_IOCTL_ARGS)", "code": "{\n\tDRM_DEVICE;\n\tdrm_via_cmdbuf_size_t d_siz;\n\tint ret = 0;\n\tuint32_t tmp_size, count;\n\tdrm_via_private_t *dev_priv;\n\n\tDRM_DEBUG(\"via cmdbuf_size\\n\");\n\tLOCK_TEST_WITH_RETURN( dev, filp );\n\n\tdev_priv = (drm_via_private_t *) dev->dev_private;\n\n\tif (dev_priv->ring.virtual_start == NULL) {\n\t\tDRM_ERROR(\"%s called without initializing AGP ring buffer.\\n\",\n\t\t\t  __FUNCTION__);\n\t\treturn DRM_ERR(EFAULT);\n\t}\n\n\tDRM_COPY_FROM_USER_IOCTL(d_siz, (drm_via_cmdbuf_size_t __user *) data,\n\t\t\t\t sizeof(d_siz));\n\n\n\tcount = 1000000;\n\ttmp_size = d_siz.size;\n\tswitch(d_siz.func) {\n\tcase VIA_CMDBUF_SPACE:\n\t\twhile (((tmp_size = via_cmdbuf_space(dev_priv)) < d_siz.size)\n\t\t       && count--) {\n\t\t\tif (!d_siz.wait) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!count) {\n\t\t\tDRM_ERROR(\"VIA_CMDBUF_SPACE timed out.\\n\");\n\t\t\tret = DRM_ERR(EAGAIN);\n\t\t}\n\t\tbreak;\n\tcase VIA_CMDBUF_LAG:\n\t\twhile (((tmp_size = via_cmdbuf_lag(dev_priv)) > d_siz.size)\n\t\t       && count--) {\n\t\t\tif (!d_siz.wait) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!count) {\n\t\t\tDRM_ERROR(\"VIA_CMDBUF_LAG timed out.\\n\");\n\t\t\tret = DRM_ERR(EAGAIN);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = DRM_ERR(EFAULT);\n\t}\n\td_siz.size = tmp_size;\n\n\tDRM_COPY_TO_USER_IOCTL((drm_via_cmdbuf_size_t __user *) data, d_siz,\n\t\t\t       sizeof(d_siz));\n\treturn ret;\n}", "path": "via_dma.c", "repo_name": "jobi/drm-psb", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 836}
{"docstring": "/*\n * How much does the command regulator lag behind?\n */\n", "func_signal": "static uint32_t via_cmdbuf_lag(drm_via_private_t *dev_priv)", "code": "{\n\tuint32_t agp_base = dev_priv->dma_offset + (uint32_t) dev_priv->agpAddr;\n\tuint32_t hw_addr = *(dev_priv->hw_addr_ptr) - agp_base;\n\n\treturn ((hw_addr <= dev_priv->dma_low) ?\n\t\t(dev_priv->dma_low - hw_addr) :\n\t\t(dev_priv->dma_wrap + dev_priv->dma_low - hw_addr));\n}", "path": "via_dma.c", "repo_name": "jobi/drm-psb", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 836}
{"docstring": "// ===  FUNCTION  =============================================================\n//         Name:  displayBMPHeaderInfo\n//  Description:  This will display header information and will do nothing more\n// ============================================================================\n", "func_signal": "void displayBMPHeaderInfo ( unsigned char * headerBuffer)", "code": "{\n    // We use this variable to determine the size of the bits we want to shift\n    // by, in this case it is a WORD or 4 bits.\n    const int WORD = 4;\n\n    printf(\"=== Header Info ====\\n\");\n    // This variable will show the location of where we are looking in the array\n    int location = 0;\n    unsigned char *temp = malloc(WORD);\n        \n\n    // Determines correct BMP type\n    printf(\"File type: %c%c\\n\", headerBuffer[location], headerBuffer[location + 1]);\n    location += 2;\n\n    // Displays size of BMP in bytes\n    printf(\"File size: %x %x %x %x\\n\",\n            headerBuffer[location],headerBuffer[location + 1],\n            headerBuffer[location + 2],\n            headerBuffer[location + 3]);\n    arrayInit(headerBuffer,temp,location,WORD);\n    printf(\"File size: %d\\n\", concatenateBits(temp,WORD));\n    location +=4; \n\n    // Displays application specific data\n    printf(\"Application Specific: %x %x %x %x\\n\",\n            headerBuffer[location],headerBuffer[location + 1],\n            headerBuffer[location + 2],\n            headerBuffer[location + 3]);\n    location +=4;\n\n\n    // Displays header offset\n    printf(\"Header Offset: %x %x %x %x\\n\",\n            headerBuffer[location],headerBuffer[location + 1],\n            headerBuffer[location + 2],\n            headerBuffer[location + 3]);\n    arrayInit(headerBuffer,temp,location,WORD);\n    printf(\"Header Offset: %d\\n\", concatenateBits(temp,WORD));\n    location +=4;\n    \n    // Displays byte remaining after this point   \n    printf(\"Bytes Remaining: %x %x %x %x\\n\",\n            headerBuffer[location],headerBuffer[location + 1],\n            headerBuffer[location + 2],\n            headerBuffer[location + 3]);\n    arrayInit(headerBuffer,temp,location,WORD);\n    printf(\"Bytes Remaining: %d\\n\", concatenateBits(temp,WORD));\n    location +=4;\n\n    // Width in pixels\n    printf(\"Width: %x %x %x %x\\n\",\n            headerBuffer[location],headerBuffer[location + 1],\n            headerBuffer[location + 2],\n            headerBuffer[location + 3]);\n    arrayInit(headerBuffer,temp,location,WORD);\n    printf(\"Width: %d\\n\", concatenateBits(temp,WORD));\n    location +=4;\n    \n    // Height in pixels\n    printf(\"Height: %x %x %x %x\\n\",\n            headerBuffer[location],headerBuffer[location + 1],\n            headerBuffer[location + 2],\n            headerBuffer[location + 3]);\n    arrayInit(headerBuffer,temp,location,WORD);\n    printf(\"Height: %d\\n\", concatenateBits(temp,WORD));\n    location +=4;\n\n    // We can ignore the next 12 bytes so we just add 12 to the location.\n    //----------------------------------------------------------------------\n    //  This is what the 12 bytes contain:\n    //  2: Number of color planes being used.\n    //  2: The number of bits/pixel.\n    //  4: BI_RGB, No compression used\n    //  4: The size of the raw BMP data (after this header)\n    //----------------------------------------------------------------------\n    location += 4*3;\n\n    // Horizontal resolution in pixels/meter\n    printf(\"Width resolution: %x %x %x %x\\n\",\n            headerBuffer[location],headerBuffer[location + 1],\n            headerBuffer[location + 2],\n            headerBuffer[location + 3]);\n    arrayInit(headerBuffer,temp,location,WORD);\n    printf(\"Width resolution: %d\\n\", concatenateBits(temp,WORD));\n    location +=4;\n    \n    // Vertical resolution in pixels/meter \n    printf(\"Vertical resolution: %x %x %x %x\\n\",\n            headerBuffer[location],headerBuffer[location + 1],\n            headerBuffer[location + 2],\n            headerBuffer[location + 3]);\n    arrayInit(headerBuffer,temp,location,WORD);\n    printf(\"Vertical resolution: %d\\n\", concatenateBits(temp,WORD));\n    location +=4;\n\n    // We can ignore the next 8 bytes so we just add 8 to the location.\n    //----------------------------------------------------------------------\n    //  This is what the 8 bytes contain:\n    //  4: Number of colors in the palette\n    //  4: Means all colors are important\n    //----------------------------------------------------------------------\n    location += 4*2;\n\n    // Release memory allocated for char* temp\n    free(temp);\n}", "path": "headerFunctions.c", "repo_name": "jvtrigueros/imageProcessing", "stars": 1, "license": "None", "language": "c", "size": 1189}
{"docstring": "// ===  FUNCTION  =============================================================\n//         Name:  rotateCounterClockwise\n//  Description:  Rotate the image counter clockwise\n// ============================================================================\n", "func_signal": "void rotateCounterClockwise ( pixelData **pixels, headerInfo *info )", "code": "{\n    int i,j;\n    int width = info->width;\n    int height = info->height;\n\n    // Create matrix for rotated image\n    pixelData **rotatedPixels = allocMatrix(height, width);\n\n    // Iterate through the pixels matrix\n    for ( i = 0 ; i < height ; i++ ) \n    {\n        for ( j = 0; j < width; j++ )\n        {\n            rotatedPixels[j][(height - 1) - i].Red   = pixels[i][j].Red;\n            rotatedPixels[j][(height - 1) - i].Green = pixels[i][j].Green;\n            rotatedPixels[j][(height - 1) - i].Blue  = pixels[i][j].Blue;\n        }\n    }\n\n    // Now that the rotated pixels have been copied, we can delete pixels and \n    // create a new one with different dimensions and then copy the rotated\n    // pixels\n    \n    freeImageMatrix(pixels, width, height);\n    pixels = allocMatrix(height,width);\n\n    copyImageBuffer( rotatedPixels, pixels, height, width);\n\n    // Swap the headerInfo's height and width to reflect the changes\n    info->width = height;\n    info->height = width;\n}", "path": "imageManip.c", "repo_name": "jvtrigueros/imageProcessing", "stars": 1, "license": "None", "language": "c", "size": 1189}
{"docstring": "// ===  FUNCTION  =============================================================\n//         Name:  increaseSize()\n//  Description:  Increase the size of the BMP by some factor.\n// ============================================================================\n", "func_signal": "void increaseSize ( pixelData **pixels, int width, int height, unsigned char *headerBuffer)", "code": "{\n    int factor = 2;\n            printf(\"Ok here\\n\");\n\n    pixelData **resizedImage = allocMatrix( factor*width, factor*height );\n\n    int i,j,x_offset,y_offset;\n    for( i = 0, x_offset = 0 ; i < width; x_offset = i + factor, i++)\n    {\n        for( j = 0, y_offset = 0 ; j < height; y_offset = j + factor, j++)\n        {\n            //p.0\n            resizedImage[x_offset][y_offset].Red    = pixels[i][j].Red;\n            resizedImage[x_offset][y_offset].Green  = pixels[i][j].Green;\n            resizedImage[x_offset][y_offset].Blue   = pixels[i][j].Blue;\n\n            //p.1\n            resizedImage[x_offset*factor + 1 ][y_offset].Red    = pixels[i][j].Red;\n            resizedImage[x_offset*factor + 1 ][y_offset].Green  = pixels[i][j].Green;\n            resizedImage[x_offset*factor + 1 ][y_offset].Blue   = pixels[i][j].Blue;\n\n            //p.2\n            resizedImage[x_offset][y_offset*factor + 1].Red    = pixels[i][j].Red;\n            resizedImage[x_offset][y_offset*factor + 1].Green  = pixels[i][j].Green;\n            resizedImage[x_offset][y_offset*factor + 1].Blue   = pixels[i][j].Blue;\n\n            //p.3\n            resizedImage[x_offset*factor + 1 ][y_offset*factor + 1].Red    = pixels[i][j].Red;\n            resizedImage[x_offset*factor + 1 ][y_offset*factor + 1].Green  = pixels[i][j].Green;\n            resizedImage[x_offset*factor + 1 ][y_offset*factor + 1].Blue   = pixels[i][j].Blue;\n            printf(\"Ok here\\n\");\n        }\n    }\n    setHeaderDimensions(headerBuffer, factor*width, factor*height);\n    freeImageMatrix(pixels, width, height);\n    pixels = allocMatrix( factor*width, factor*height );\n    copyImageBuffer(resizedImage,pixels, factor*width, factor*height);\n    return ;\n}", "path": "imageManip.c", "repo_name": "jvtrigueros/imageProcessing", "stars": 1, "license": "None", "language": "c", "size": 1189}
{"docstring": "// -----  end of function changeIntensity  -----\n", "func_signal": "void invertColours ( pixelData **pixels, int width, int height )", "code": "{\n    int i,j,temp;\n    \n    for ( i = 0 ; i < height ; i++ ) \n    {\n        for ( j = 0; j < width; j++ )\n        {\n            temp = 255 - pixels[i][j].Red;\n            pixels[i][j].Red = (temp < 0 ) ? 0 : temp;\n\n            temp = 255 - pixels[i][j].Green;\n            pixels[i][j].Green = (temp < 0 ) ? 0 : temp;\n\n            temp = 255 - pixels[i][j].Blue;\n            pixels[i][j].Blue = (temp < 0 ) ? 0 : temp;\n        }\n    }\n}", "path": "imageManip.c", "repo_name": "jvtrigueros/imageProcessing", "stars": 1, "license": "None", "language": "c", "size": 1189}
{"docstring": "// ===  FUNCTION  =============================================================\n//         Name:  blurImage()\n//  Description:  Applies blur to the image.\n// ============================================================================\n", "func_signal": "void blurImage( pixelData **pixels, int width, int height )", "code": "{\n    pixelData **blurredImage = allocMatrix( width, height );\n\n    int i,j;\n    for (i = 0 ; i < height ; i++ ) \n    {\n        for (j = 0; j < width; j++ )\n        {\n            pixelData temp = boxBlur( pixels, i, j); \n\n            blurredImage[i][j].Red   = temp.Red;\n            blurredImage[i][j].Green = temp.Green;\n            blurredImage[i][j].Blue  = temp.Blue;\n        }\n    }\n\n    copyImageBuffer(blurredImage, pixels,width,height);\n}", "path": "imageManip.c", "repo_name": "jvtrigueros/imageProcessing", "stars": 1, "license": "None", "language": "c", "size": 1189}
{"docstring": "// ===  FUNCTION  =============================================================\n//         Name:  readImage\n//  Description:  Reads the image and detects if it's actually there, it might\n//                return an error because it the image is non-existent. Then\n//                it returns the file pointer.\n// ============================================================================\n", "func_signal": "FILE *readImage(char *filename)", "code": "{\n    FILE *fp = fopen(filename,\"rb\");\n\n    // Test to see if the image was read properly\n    if ( fp == NULL ) \n    {\n        fputs(\"File was not read properly.\\n\", stderr);\n        exit(1);\n    }\n\n    return fp;\n}", "path": "imageIO.c", "repo_name": "jvtrigueros/imageProcessing", "stars": 1, "license": "None", "language": "c", "size": 1189}
{"docstring": "// ===  FUNCTION  =============================================================\n//         Name:  rotateClockwise\n//  Description:  Rotate the image clockwise, the trick was to realize that the\n//                bmp will is read upside down and when the rotations happen, \n//                they don't necessarily rotate the right way.\n// ============================================================================\n", "func_signal": "void rotateClockwise (  pixelData **pixels, headerInfo *info )", "code": "{\n    int i,j;\n    int width = info->width;\n    int height = info->height;\n\n    // Create matrix for rotated image\n    pixelData **rotatedPixels = allocMatrix(height, width);\n\n    // Iterate through the pixels matrix\n    for ( i = 0 ; i < height ; i++ ) \n    {\n        for ( j = 0; j < width; j++ )\n        {\n            rotatedPixels[(width - 1) -  j][i].Red   = pixels[i][j].Red;\n            rotatedPixels[(width - 1) -  j][i].Green = pixels[i][j].Green;\n            rotatedPixels[(width - 1) -  j][i].Blue  = pixels[i][j].Blue;\n        }\n    }\n\n    // Now that the rotated pixels have been copied, we can delete pixels and \n    // create a new one with different dimensions and then copy the rotated\n    // pixels\n    \n    freeImageMatrix(pixels, width, height);\n    pixels = allocMatrix(height,width);\n\n    copyImageBuffer( rotatedPixels, pixels, height, width);\n\n    // Swap the headerInfo's height and width to reflect the changes\n    info->width = height;\n    info->height = width;\n}", "path": "imageManip.c", "repo_name": "jvtrigueros/imageProcessing", "stars": 1, "license": "None", "language": "c", "size": 1189}
{"docstring": "// ===  FUNCTION  =============================================================\n//         Name:  copyImageBuffer\n//  Description:  Copies the data from pixelData A to pixelData B.\n// ============================================================================\n", "func_signal": "void copyImageBuffer ( pixelData **A, pixelData **B, int width, int height )", "code": "{\n    int i,j;\n\n    for ( i = 0 ; i < height ; i++ ) \n    {\n        for ( j = 0; j < width; j++ )\n        {\n            B[i][j].Red = A[i][j].Red;\n            B[i][j].Green = A[i][j].Green;\n            B[i][j].Blue = A[i][j].Blue;\n        }\n    }\n}", "path": "imageManip.c", "repo_name": "jvtrigueros/imageProcessing", "stars": 1, "license": "None", "language": "c", "size": 1189}
{"docstring": "// ===  FUNCTION  =============================================================\n//         Name:  createImageMatrix\n//  Description:  This will create a matrix of pixelData storing the pixel\n//                colour information in each cell.\n// ============================================================================\n", "func_signal": "pixelData **createImageMatrix ( unsigned char *imageData, int width, int height )", "code": "{\n    int startImage = 54;\n    // allocate memory for a 2D Array of pixelData, by first creating a 1D \n    pixelData **pixels = allocMatrix(width, height);\n\n    // Start putting stuff in the array from the imageData\n    // Note that the image will be upside down when read =D\n    int imageLoc = startImage;\n    int i,j;\n    // Determine padding\n    int padding = width % 4;\n\n    for(i = 0; i < height; i++)\n    {\n        // Iterate throw the current row of pixels\n        for(j = 0; j <= width; j++)\n        {\n            // We need an alternate option at the end of the row\n            if( j == width)\n            {\n                // Skip the amount determined by padding \n                imageLoc += padding;\n            }\n            else\n            {\n                // Start storing the RGB colours in BGR order..Stupid little endian\n                pixels[i][j].Blue = imageData[imageLoc];\n                pixels[i][j].Green = imageData[imageLoc + 1];\n                pixels[i][j].Red = imageData[imageLoc + 2];\n                imageLoc += 3;      // Not a magic number, it represents RGB\n            }\n        }\n    }\n\n    return pixels;\n}", "path": "imageManip.c", "repo_name": "jvtrigueros/imageProcessing", "stars": 1, "license": "None", "language": "c", "size": 1189}
{"docstring": "// ===  FUNCTION  =============================================================\n//         Name:  createImageBuffer(FILE*)\n//  Description:  This will create an image buffer and return an array with all\n//                that data.\n// ============================================================================\n", "func_signal": "unsigned char *createImageBuffer(char *filename)", "code": "{\n    // Creating FILE pointer\n    FILE *image = readImage(filename);\n\n    // Local Vars\n    long fileSize;\n    unsigned char* imageBuffer;\n    size_t check;\n\n    // Obtain the file size\n    fseek( image, 0, SEEK_END);\n    fileSize = ftell(image);\n    rewind(image);\n    \n    // Create space for header\n    imageBuffer = malloc(fileSize);\n    check = fread( imageBuffer, sizeof(imageBuffer[0]), fileSize,image);\n\n    // If what we read is not the same size fileSize then something is wrong\n    if( (int)check != (int)fileSize)\n    {\n        fputs(\"createImageBuffer: The file was not read properly\\n\", stderr);\n        exit(2);\n    }\n\n    return imageBuffer;\n}", "path": "imageIO.c", "repo_name": "jvtrigueros/imageProcessing", "stars": 1, "license": "None", "language": "c", "size": 1189}
{"docstring": "// ===  FUNCTION  =============================================================\n//         Name:  freeImageMatrix()\n//  Description:  This function will simply de-allocate all the data allocated\n//                for the image matrix.\n// ============================================================================\n", "func_signal": "void freeImageMatrix ( pixelData **pixels, int width, int height )", "code": "{\n    int i;\n\n    for ( i = 0 ; i < height ; i++ ) \n    {\n        free(pixels[i]);\n    }\n    free(pixels);\n}", "path": "imageManip.c", "repo_name": "jvtrigueros/imageProcessing", "stars": 1, "license": "None", "language": "c", "size": 1189}
{"docstring": "// ===  FUNCTION  =============================================================\n//         Name:  isBMP()\n//  Description:  TODO: Move elsewhere\n//                Determines if file is a BMP, if not it quits the program.\n// ============================================================================\n", "func_signal": "void isBMP (char *type )", "code": "{\n    if( strncmp(type, \"BM\",2) != 0 )\n    {\n        // K.O.\n        printf(\"%s\\n\",type);\n        puts(\"FATAL ERROR! Input file is not BMP! Dx\\n\");\n        exit(3);\n    }\n}", "path": "main.c", "repo_name": "jvtrigueros/imageProcessing", "stars": 1, "license": "None", "language": "c", "size": 1189}
{"docstring": "// ===  FUNCTION  =============================================================\n//         Name:  changeIntensity()\n//  Description:  Change the intensity of the picture by some factor provided\n//                by the user.\n// ============================================================================\n", "func_signal": "void changeIntensity (pixelData **pixels, double factor, int width, int height )", "code": "{\n    int i,j,temp;\n    \n    for ( i = 0 ; i < height ; i++ ) \n    {\n        for ( j = 0; j < width; j++ )\n        {\n            //----------------------------------------------------------------------\n            //  The problem was that the fields RGB are unsigned chars which go from\n            //  0-255, thus storing a number greater than that caused it to give\n            //  incorect results. \n            //----------------------------------------------------------------------\n            temp = (int)( ((pixels[i][j].Red) * factor) );\n            pixels[i][j].Red = (temp > 255 ) ? 255 : temp;\n\n            temp = (int)( ( (pixels[i][j].Green) * factor)  );\n            pixels[i][j].Green = (temp > 255 ) ? 255 : temp;\n\n            temp = (int)( ( (pixels[i][j].Blue) * factor)  );\n            pixels[i][j].Blue = (temp > 255 ) ? 255 : temp;\n\n//            difference = pixels[i][j].Red - NEUTRAL;\n//            temp = (int)( ( NEUTRAL + (factor * difference) ) );\n//            pixels[i][j].Red = ( temp  > 255 ) ? 255 : temp;\n//\n//            difference = pixels[i][j].Green - NEUTRAL;\n//            temp = (int)( ( NEUTRAL + (factor * difference) ) );\n//            pixels[i][j].Green = ( temp  > 255 ) ? 255 : temp;\n//\n//            difference = pixels[i][j].Blue - NEUTRAL;\n//            temp = (int)( ( NEUTRAL + (factor * difference) ) );\n//            pixels[i][j].Blue = ( temp  > 255 ) ? 255 : temp;\n\n//            pixels[i][j].Red = (int)( ((pixels[i][j].Red) * factor) + pixels[i][j].Red );\n//            pixels[i][j].Red = (pixels[i][j].Red > 255 ) ? 255 : pixels[i][j].Red;\n//            pixels[i][j].Green = (int)( ( (pixels[i][j].Green) * factor) + pixels[i][j].Green );\n//            pixels[i][j].Green = (pixels[i][j].Green > 255 ) ? 255 : pixels[i][j].Green;\n//            pixels[i][j].Blue = (int)( ( (pixels[i][j].Blue) * factor) + pixels[i][j].Blue );\n//            pixels[i][j].Blue = (pixels[i][j].Blue > 255 ) ? 255 : pixels[i][j].Blue;\n        }\n    }\n}", "path": "imageManip.c", "repo_name": "jvtrigueros/imageProcessing", "stars": 1, "license": "None", "language": "c", "size": 1189}
{"docstring": "// ===  FUNCTION  =============================================================\n//         Name:  flipVertical()\n//  Description:  Flips the image across the x-axis\n// ============================================================================\n", "func_signal": "void flipVertical (pixelData **pixels, int width, int height )", "code": "{\n    int i,j;\n    // Create 2D pixelData Array\n    pixelData **temp = allocMatrix(width, height);\n\n    for ( i = 0 ; i < height ; i++ ) \n    {\n        for ( j = 0; j < width; j++ )\n        {\n            temp[i][j].Red   = pixels[i][(height - 1) - j].Red;\n            temp[i][j].Green = pixels[i][(height - 1) - j].Green;\n            temp[i][j].Blue  = pixels[i][(height - 1) - j].Blue;\n        }\n    }\n\n    copyImageBuffer(temp,pixels, width, height);\n    freeImageMatrix(temp,width,height);\n}", "path": "imageManip.c", "repo_name": "jvtrigueros/imageProcessing", "stars": 1, "license": "None", "language": "c", "size": 1189}
{"docstring": "// ===  FUNCTION  =============================================================\n//         Name:  extractBMPHeaderInfo\n//  Description:  This will extract header information and for now it'll just \n//                print it out, but the plan is that this info should be put\n//                into a struct. 11/11/2009 11:54:23 PM\n//                Was stripped of all the printf-ing and only get's the stash \n//                and exits.\n// ============================================================================\n", "func_signal": "void extractBMPHeaderInfo ( unsigned char * headerBuffer, headerInfo *info )", "code": "{\n    // We use this variable to determine the size of the bits we want to shift\n    // by, in this case it is a WORD or 4 bits.\n    const int WORD = 4;\n\n    // This variable will show the location of where we are looking in the array\n    int location = 0;\n    unsigned char *temp = malloc(WORD);\n        \n\n    // Determines correct BMP type\n    info->type[0] = headerBuffer[location];\n    info->type[1] = headerBuffer[location + 1];\n    location += 2;\n\n    // Displays size of BMP in bytes\n    arrayInit(headerBuffer,temp,location,WORD);\n    info->sizeOf = concatenateBits(temp,WORD);\n    location +=4; \n\n    // Displays application specific data\n    location +=4;\n\n\n    // Displays header offset\n    location +=4;\n    \n    // Displays byte remaining after this point   \n    location +=4;\n\n    // Width in pixels\n    arrayInit(headerBuffer,temp,location,WORD);\n    info->width = concatenateBits(temp,WORD);\n    location +=4;\n    \n    // Height in pixels\n    arrayInit(headerBuffer,temp,location,WORD);\n    info->height = concatenateBits(temp,WORD);\n    location +=4;\n\n    // We can ignore the next 12 bytes so we just add 12 to the location.\n    //----------------------------------------------------------------------\n    //  This is what the 12 bytes contain:\n    //  2: Number of color planes being used.\n    //  2: The number of bits/pixel.\n    //  4: BI_RGB, No compression used\n    //  4: The size of the raw BMP data (after this header)\n    //----------------------------------------------------------------------\n    location += 4*3;\n\n    // Horizontal resolution in pixels/meter\n    location +=4;\n    \n    // Vertical resolution in pixels/meter \n    location +=4;\n\n    // We can ignore the next 8 bytes so we just add 8 to the location.\n    //----------------------------------------------------------------------\n    //  This is what the 8 bytes contain:\n    //  4: Number of colors in the palette\n    //  4: Means all colors are important\n    //----------------------------------------------------------------------\n    location += 4*2;\n\n    // Release memory allocated for char* temp\n    free(temp);\n}", "path": "headerFunctions.c", "repo_name": "jvtrigueros/imageProcessing", "stars": 1, "license": "None", "language": "c", "size": 1189}
{"docstring": "// ===  FUNCTION  =============================================================\n//         Name:  arrayInit()\n//  Description:  This function will set the value of a given array,\n//                this function is not in the header file because it should not\n//                be called by anybody else.\n// ============================================================================\n", "func_signal": "void arrayInit ( unsigned char * header, unsigned char *section, int currentLoc, int numberOfBytesToRead )", "code": "{\n    int i = 0;\n    for(;i < numberOfBytesToRead; i++)\n    {\n        section[i] = header[currentLoc + i];\n    }\n}", "path": "headerFunctions.c", "repo_name": "jvtrigueros/imageProcessing", "stars": 1, "license": "None", "language": "c", "size": 1189}
{"docstring": "// ===  FUNCTION  =============================================================\n//         Name:  allocMatrix()\n//  Description:  Simply creates a 2D array of pixelData\n// ============================================================================\n", "func_signal": "pixelData **allocMatrix( int width, int height )", "code": "{\n    // allocate memory for a 2D Array of pixelData, by first creating a 1D \n    pixelData **newMatrix = (pixelData**)malloc(height * sizeof(pixelData*));\n\n    // Now create the rest of the 2D array\n    int i;\n    for(i = 0; i < height; i++ )\n    {\n       *(newMatrix + i) = (pixelData*)malloc(width * sizeof(pixelData));\n    }\n\n    return newMatrix;\n}", "path": "imageManip.c", "repo_name": "jvtrigueros/imageProcessing", "stars": 1, "license": "None", "language": "c", "size": 1189}
{"docstring": "// ===  FUNCTION  =============================================================\n//         Name:  setHeaderDimensions\n//  Description:  Change the width and the height after rotating image or doing\n//                any other operation.\n// ============================================================================\n", "func_signal": "void setHeaderDimensions ( unsigned char * headerBuffer, int newWidth, int newHeight )", "code": "{\n    int const LENGTHOFDIM = 4;\n\n    // Location of width 18-21\n    unsigned char width[4];\n    int widthLoc = 18;\n    \n    // Location of height 22-25\n    unsigned char height[4];\n    int heightLoc = 22;\n\n    int i;\n    unsigned char temp = 0x00;\n\n    // Get the bytes for the header\n    for(i = 0; i < LENGTHOFDIM ; i++)\n    {\n        // Get bytes for width\n        temp = 0x00 | newWidth;\n        newWidth = newWidth >> 8;\n        width[i] = temp;\n\n        // reset temp \n        temp = 0x00;\n\n        // Get bytes for height\n        temp = 0x00 | newHeight;\n        newHeight = newHeight >> 8;\n        height[i] = temp;\n    }\n\n\n    // Set the width and height\n    for(i = 0; i < LENGTHOFDIM; i++, widthLoc++,heightLoc++)\n    {\n        headerBuffer[widthLoc] = width[i];\n        headerBuffer[heightLoc] = height[i];\n    }\n}", "path": "headerFunctions.c", "repo_name": "jvtrigueros/imageProcessing", "stars": 1, "license": "None", "language": "c", "size": 1189}
{"docstring": "// ===  FUNCTION  =============================================================\n//         Name:  writeBMP\n//  Description:  This function will write the buffer data to a BMP file.\n// ============================================================================\n", "func_signal": "void writeBMP ( pixelData **pixels, unsigned char *header, \n                headerInfo info, char *filename)", "code": "{\n    int const BUFFERSIZE = 54;\n    int i,j,imageLoc;\n    FILE *outputFile;\n\n    imageLoc = BUFFERSIZE;\n\n    // Will contain the BMP info\n    unsigned char* bmpBuffer = malloc(info.sizeOf);\n\n    // Copy header information into the first 54 bytes of bmpBuffer\n    for(i = 0; i < BUFFERSIZE ; i++)\n    {\n        bmpBuffer[i] = header[i];\n    }\n\n    // Copy the pixel data to the remaining of the bmpBuffer\n    for( i = 0; i < info.height; i++)\n    {\n        for(j = 0; j <= info.width; j++)\n        {\n            if( j == info.width )\n            {\n                // Add padding here!!!\n                // Determine if padding is needed and how much\n                int padding = info.width % 4;\n                if( padding != 0 )\n                {\n                    //Padding is needed =(\n                    int p;\n                    for(p = 0; p < padding ; p++,imageLoc++)\n                    {\n                        bmpBuffer[imageLoc] = 'T'; // Padding can be anything\n                    }\n                }\n            }\n            else\n            {\n                bmpBuffer[imageLoc    ] = pixels[i][j].Blue;\n                bmpBuffer[imageLoc + 1] = pixels[i][j].Green;\n                bmpBuffer[imageLoc + 2] = pixels[i][j].Red;\n                imageLoc += 3; // Not a magic number, it represents RGB\n            }\n        }\n    }\n\n    // Write the bmpBuffer to a file\n    outputFile = fopen(filename, \"wb\");\n    fwrite(bmpBuffer, 1, info.sizeOf, outputFile);\n    fclose(outputFile);\n}", "path": "imageIO.c", "repo_name": "jvtrigueros/imageProcessing", "stars": 1, "license": "None", "language": "c", "size": 1189}
{"docstring": "// -----  end of function isBMP  -----\n", "func_signal": "int main()", "code": "{\n    // Vars\n    int choice = 0;\n    int loop = 1;\n    int bmpRead = 0;\n    int lengthOfFilename = 32;\n    char * filename = malloc(lengthOfFilename);\n    headerInfo info;\n\n    puts(\"\\nBMP Image Processing Program\");\n    puts(\"----------------------------\");\n\n    while( loop )\n    {\n        // Ask for choices again\n        printMenu();\n        scanf(\"%d\", &choice);\n\n        switch (choice) \n        {\n            // Read Image\n            case 1:\t\n                // Maybe have something for when a bmp has already been read\n                bmpRead = 1;\n\n                // Get filename\n                printf(\"\\nPlease enter the name of the BMP: \");\n                scanf(\"%s\",filename);\n\n                // Extract information from BMP\n                unsigned char* imageBuffer = createImageBuffer(filename);\n                unsigned char* headerBuffer = readBMPHeader(imageBuffer);\n\n                extractBMPHeaderInfo(headerBuffer, &info);\n\n                // Check if image is BMP\n                isBMP(info.type);\n                \n                // Now we can continue to create the pixel matrix\n                pixelData **pixels = createImageMatrix(imageBuffer, info.width, info.height);\n\n                // If this is BMP Continue\n                printf(\"%s was read successfully!\\n\\n\", filename);\n\n                break;\n\n            // Write Image\n            case 2:\t\n                if ( !bmpRead ) \n                {\n                    puts(\"Please select option 1 first.\\n\"); \n                }\n                else \n                {\n                    // Now we will write the image out.\n                    printf(\"\\nEnter output file name: \");\n                    scanf(\"%s\",filename);\n                    writeBMP(pixels, headerBuffer, info, filename);\n                    printf(\"%s was written successfully!!\\n\\n\", filename);\n                }\n                break;\n\n            // Change Intensity\n            case 3:\t\n                if ( !bmpRead ) \n                {\n                    puts(\"Please select option 1 first.\\n\"); \n                }\n                else \n                {\n                    double factor;\n                    printf(\"\\nChange the intensity by a factor of: \");\n                    scanf(\"%lf\",&factor);\n                    changeIntensity(pixels, factor, info.width,info.height);\n                }\n                break;\n\n            // Flip Horz\n            case 4:\t\n                if ( !bmpRead ) \n                {\n                    puts(\"Please select option 1 first.\\n\"); \n                }\n                else \n                {\n                    flipHorizontal(pixels, info.width,info.height);\n                }\n                break;\n\n            // Flip Vert\n            case 5:\t\n                if ( !bmpRead ) \n                {\n                    puts(\"Please select option 1 first.\\n\"); \n                }\n                else \n                {\n                    flipVertical(pixels, info.width,info.height);\n                }\n                break;\n\n            // Rotate ClckWise\n            case 6:\t\n                if ( !bmpRead ) \n                {\n                    puts(\"Please select option 1 first.\\n\"); \n                }\n                else \n                {\n                   rotateClockwise(pixels, &info);\n                   setHeaderDimensions(headerBuffer, info.width, info.height);\n                }\n                break;\n\n            // Rotate CounterClckWise\n            case 7:\t\n                if ( !bmpRead ) \n                {\n                    puts(\"Please select option 1 first.\\n\"); \n                }\n                else \n                {\n                   rotateCounterClockwise(pixels, &info);\n                   setHeaderDimensions(headerBuffer, info.width, info.height);\n                }\n                break;\n\n            // Invert Colours\n            case 8:\t\n                invertColours(pixels, info.width, info.height);\n                break;\n\n            // BoxBlur\n            case 9:\t\n                if ( !bmpRead ) \n                {\n                    puts(\"Please select option 1 first.\\n\"); \n                }\n                else \n                {\n                    blurImage(pixels,info.width,info.height);\n                }\n                break;\n\n            // Increase Size\n            case 10:\t\n                increaseSize(pixels, info.width, info.height,headerBuffer);\n                break;\n\n            // Decrease Size\n            case 11:\t\n                break;\n\n            // Exit\n            case 12:\t\n                loop = 0;\n                if( bmpRead )\n                    freeImageMatrix(pixels,info.width,info.height);\n                puts(\"\\nGood Bye!!!\\n\");\n                break;\n\n\n            default:\t\n                puts(\"\\nInvalid Choice, Please Try Again :(\\n\");\n                break;\n        }\t\t\t\t// -----  end switch  -----\n\n    }\n\n    return 0;\n}", "path": "main.c", "repo_name": "jvtrigueros/imageProcessing", "stars": 1, "license": "None", "language": "c", "size": 1189}
{"docstring": "/**\n * ilookup5 - search for an inode in the inode cache\n * @sb:\t\tsuper block of file system to search\n * @hashval:\thash value (usually inode number) to search for\n * @test:\tcallback used for comparisons between inodes\n * @data:\topaque data pointer to pass to @test\n *\n * ilookup5() uses ifind() to search for the inode specified by @hashval and\n * @data in the inode cache. This is a generalized version of ilookup() for\n * file systems where the inode number is not sufficient for unique\n * identification of an inode.\n *\n * If the inode is in the cache, the inode lock is waited upon and the inode is\n * returned with an incremented reference count.\n *\n * Otherwise NULL is returned.\n *\n * Note, @test is called with the inode_lock held, so can't sleep.\n */\n", "func_signal": "struct inode *ilookup5(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)", "code": "{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\n\treturn ifind(sb, head, test, data, 1);\n}", "path": "fs\\inode.c", "repo_name": "joelagnel/fcp", "stars": 1, "license": "None", "language": "c", "size": 2092}
{"docstring": "/**\n *\tiunique - get a unique inode number\n *\t@sb: superblock\n *\t@max_reserved: highest reserved inode number\n *\n *\tObtain an inode number that is unique on the system for a given\n *\tsuperblock. This is used by file systems that have no natural\n *\tpermanent inode numbering system. An inode number is returned that\n *\tis higher than the reserved limit but unique.\n *\n *\tBUGS:\n *\tWith a large number of inodes live on the file system this function\n *\tcurrently becomes quite slow.\n */\n", "func_signal": "ino_t iunique(struct super_block *sb, ino_t max_reserved)", "code": "{\n\t/*\n\t * On a 32bit, non LFS stat() call, glibc will generate an EOVERFLOW\n\t * error if st_ino won't fit in target struct field. Use 32bit counter\n\t * here to attempt to avoid that.\n\t */\n\tstatic unsigned int counter;\n\tstruct inode *inode;\n\tstruct hlist_head *head;\n\tino_t res;\n\n\tspin_lock(&inode_lock);\n\tdo {\n\t\tif (counter <= max_reserved)\n\t\t\tcounter = max_reserved + 1;\n\t\tres = counter++;\n\t\thead = inode_hashtable + hash(sb, res);\n\t\tinode = find_inode_fast(sb, head, res);\n\t} while (inode != NULL);\n\tspin_unlock(&inode_lock);\n\n\treturn res;\n}", "path": "fs\\inode.c", "repo_name": "joelagnel/fcp", "stars": 1, "license": "None", "language": "c", "size": 2092}
{"docstring": "/**\n * ifind - internal function, you want ilookup5() or iget5().\n * @sb:\t\tsuper block of file system to search\n * @head:       the head of the list to search\n * @test:\tcallback used for comparisons between inodes\n * @data:\topaque data pointer to pass to @test\n * @wait:\tif true wait for the inode to be unlocked, if false do not\n *\n * ifind() searches for the inode specified by @data in the inode\n * cache. This is a generalized version of ifind_fast() for file systems where\n * the inode number is not sufficient for unique identification of an inode.\n *\n * If the inode is in the cache, the inode is returned with an incremented\n * reference count.\n *\n * Otherwise NULL is returned.\n *\n * Note, @test is called with the inode_lock held, so can't sleep.\n */\n", "func_signal": "static struct inode *ifind(struct super_block *sb,\n\t\tstruct hlist_head *head, int (*test)(struct inode *, void *),\n\t\tvoid *data, const int wait)", "code": "{\n\tstruct inode *inode;\n\n\tspin_lock(&inode_lock);\n\tinode = find_inode(sb, head, test, data);\n\tif (inode) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode_lock);\n\t\tif (likely(wait))\n\t\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\tspin_unlock(&inode_lock);\n\treturn NULL;\n}", "path": "fs\\inode.c", "repo_name": "joelagnel/fcp", "stars": 1, "license": "None", "language": "c", "size": 2092}
{"docstring": "/*\n * Called when we're dropping the last reference\n * to an inode. \n *\n * Call the FS \"drop()\" function, defaulting to\n * the legacy UNIX filesystem behaviour..\n *\n * NOTE! NOTE! NOTE! We're called with the inode lock\n * held, and the drop function is supposed to release\n * the lock!\n */\n", "func_signal": "static inline void iput_final(struct inode *inode)", "code": "{\n\tconst struct super_operations *op = inode->i_sb->s_op;\n\tvoid (*drop)(struct inode *) = generic_drop_inode;\n\n\tif (op && op->drop_inode)\n\t\tdrop = op->drop_inode;\n\tdrop(inode);\n}", "path": "fs\\inode.c", "repo_name": "joelagnel/fcp", "stars": 1, "license": "None", "language": "c", "size": 2092}
{"docstring": "/*\n * Scan `goal' inodes on the unused list for freeable ones. They are moved to\n * a temporary list and then are freed outside inode_lock by dispose_list().\n *\n * Any inodes which are pinned purely because of attached pagecache have their\n * pagecache removed.  We expect the final iput() on that inode to add it to\n * the front of the inode_unused list.  So look for it there and if the\n * inode is still freeable, proceed.  The right inode is found 99.9% of the\n * time in testing on a 4-way.\n *\n * If the inode has metadata buffers attached to mapping->private_list then\n * try to remove them.\n */\n", "func_signal": "static void prune_icache(int nr_to_scan)", "code": "{\n\tLIST_HEAD(freeable);\n\tint nr_pruned = 0;\n\tint nr_scanned;\n\tunsigned long reap = 0;\n\n\tmutex_lock(&iprune_mutex);\n\tspin_lock(&inode_lock);\n\tfor (nr_scanned = 0; nr_scanned < nr_to_scan; nr_scanned++) {\n\t\tstruct inode *inode;\n\n\t\tif (list_empty(&inode_unused))\n\t\t\tbreak;\n\n\t\tinode = list_entry(inode_unused.prev, struct inode, i_list);\n\n\t\tif (inode->i_state || atomic_read(&inode->i_count)) {\n\t\t\tlist_move(&inode->i_list, &inode_unused);\n\t\t\tcontinue;\n\t\t}\n\t\tif (inode_has_buffers(inode) || inode->i_data.nrpages) {\n\t\t\t__iget(inode);\n\t\t\tspin_unlock(&inode_lock);\n\t\t\tif (remove_inode_buffers(inode))\n\t\t\t\treap += invalidate_mapping_pages(&inode->i_data,\n\t\t\t\t\t\t\t\t0, -1);\n\t\t\tiput(inode);\n\t\t\tspin_lock(&inode_lock);\n\n\t\t\tif (inode != list_entry(inode_unused.next,\n\t\t\t\t\t\tstruct inode, i_list))\n\t\t\t\tcontinue;\t/* wrong inode or list_empty */\n\t\t\tif (!can_unuse(inode))\n\t\t\t\tcontinue;\n\t\t}\n\t\tlist_move(&inode->i_list, &freeable);\n\t\tinode->i_state |= I_FREEING;\n\t\tnr_pruned++;\n\t}\n\tinodes_stat.nr_unused -= nr_pruned;\n\tif (current_is_kswapd())\n\t\t__count_vm_events(KSWAPD_INODESTEAL, reap);\n\telse\n\t\t__count_vm_events(PGINODESTEAL, reap);\n\tspin_unlock(&inode_lock);\n\n\tdispose_list(&freeable);\n\tmutex_unlock(&iprune_mutex);\n}", "path": "fs\\inode.c", "repo_name": "joelagnel/fcp", "stars": 1, "license": "None", "language": "c", "size": 2092}
{"docstring": "/*\n * inode_lock must be held\n */\n", "func_signal": "void __iget(struct inode * inode)", "code": "{\n\tif (atomic_read(&inode->i_count)) {\n\t\tatomic_inc(&inode->i_count);\n\t\treturn;\n\t}\n\tatomic_inc(&inode->i_count);\n\tif (!(inode->i_state & (I_DIRTY|I_SYNC)))\n\t\tlist_move(&inode->i_list, &inode_in_use);\n\tinodes_stat.nr_unused--;\n}", "path": "fs\\inode.c", "repo_name": "joelagnel/fcp", "stars": 1, "license": "None", "language": "c", "size": 2092}
{"docstring": "/*\n * There are two policies for allocating an inode.  If the new inode is\n * a directory, then a forward search is made for a block group with both\n * free space and a low directory-to-inode ratio; if that fails, then of\n * the groups with above-average free space, that group with the fewest\n * directories already is chosen.\n *\n * For other inodes, search forward from the parent directory\\'s block\n * group to find a free inode.\n */\n", "func_signal": "static int find_group_dir(struct super_block *sb, struct inode *parent)", "code": "{\n\tint ngroups = EXT2_SB(sb)->s_groups_count;\n\tint avefreei = ext2_count_free_inodes(sb) / ngroups;\n\tstruct ext2_group_desc *desc, *best_desc = NULL;\n\tint group, best_group = -1;\n\n\tfor (group = 0; group < ngroups; group++) {\n\t\tdesc = ext2_get_group_desc (sb, group, NULL);\n\t\tif (!desc || !desc->bg_free_inodes_count)\n\t\t\tcontinue;\n\t\tif (le16_to_cpu(desc->bg_free_inodes_count) < avefreei)\n\t\t\tcontinue;\n\t\tif (!best_desc || \n\t\t    (le16_to_cpu(desc->bg_free_blocks_count) >\n\t\t     le16_to_cpu(best_desc->bg_free_blocks_count))) {\n\t\t\tbest_group = group;\n\t\t\tbest_desc = desc;\n\t\t}\n\t}\n\tif (!best_desc)\n\t\treturn -1;\n\n\treturn best_group;\n}", "path": "fs\\ext2\\ialloc.c", "repo_name": "joelagnel/fcp", "stars": 1, "license": "None", "language": "c", "size": 2092}
{"docstring": "/*\n * Read the inode allocation bitmap for a given block_group, reading\n * into the specified slot in the superblock's bitmap cache.\n *\n * Return buffer_head of bitmap on success or NULL.\n */\n", "func_signal": "static struct buffer_head *\nread_inode_bitmap(struct super_block * sb, unsigned long block_group)", "code": "{\n\tstruct ext2_group_desc *desc;\n\tstruct buffer_head *bh = NULL;\n\n\tdesc = ext2_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\tgoto error_out;\n\n\tbh = sb_bread(sb, le32_to_cpu(desc->bg_inode_bitmap));\n\tif (!bh)\n\t\text2_error(sb, \"read_inode_bitmap\",\n\t\t\t    \"Cannot read inode bitmap - \"\n\t\t\t    \"block_group = %lu, inode_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_inode_bitmap));\nerror_out:\n\treturn bh;\n}", "path": "fs\\ext2\\ialloc.c", "repo_name": "joelagnel/fcp", "stars": 1, "license": "None", "language": "c", "size": 2092}
{"docstring": "/**\n *\ttouch_atime\t-\tupdate the access time\n *\t@mnt: mount the inode is accessed on\n *\t@dentry: dentry accessed\n *\n *\tUpdate the accessed time on an inode and mark it for writeback.\n *\tThis function automatically handles read only file systems and media,\n *\tas well as the \"noatime\" flag and inode specific \"noatime\" markers.\n */\n", "func_signal": "void touch_atime(struct vfsmount *mnt, struct dentry *dentry)", "code": "{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct timespec now;\n\n\tif (inode->i_flags & S_NOATIME)\n\t\treturn;\n\tif (IS_NOATIME(inode))\n\t\treturn;\n\tif ((inode->i_sb->s_flags & MS_NODIRATIME) && S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\t/*\n\t * We may have a NULL vfsmount when coming from NFSD\n\t */\n\tif (mnt) {\n\t\tif (mnt->mnt_flags & MNT_NOATIME)\n\t\t\treturn;\n\t\tif ((mnt->mnt_flags & MNT_NODIRATIME) && S_ISDIR(inode->i_mode))\n\t\t\treturn;\n\t}\n\tnow = current_fs_time(inode->i_sb);\n\tif (mnt) {\n\t\tif (mnt->mnt_flags & MNT_RELATIME)\n\t\t\tif (!relatime_need_update(inode, now))\n\t\t\t\treturn;\n\t}\n\n\tif (timespec_equal(&inode->i_atime, &now))\n\t\treturn;\n\n\tinode->i_atime = now;\n\tmark_inode_dirty_sync(inode);\n}", "path": "fs\\inode.c", "repo_name": "joelagnel/fcp", "stars": 1, "license": "None", "language": "c", "size": 2092}
{"docstring": "/*\n * We perform asynchronous prereading of the new inode's inode block when\n * we create the inode, in the expectation that the inode will be written\n * back soon.  There are two reasons:\n *\n * - When creating a large number of files, the async prereads will be\n *   nicely merged into large reads\n * - When writing out a large number of inodes, we don't need to keep on\n *   stalling the writes while we read the inode block.\n *\n * FIXME: ext2_get_group_desc() needs to be simplified.\n */\n", "func_signal": "static void ext2_preread_inode(struct inode *inode)", "code": "{\n\tunsigned long block_group;\n\tunsigned long offset;\n\tunsigned long block;\n\tstruct ext2_group_desc * gdp;\n\tstruct backing_dev_info *bdi;\n\n\tbdi = inode->i_mapping->backing_dev_info;\n\tif (bdi_read_congested(bdi))\n\t\treturn;\n\tif (bdi_write_congested(bdi))\n\t\treturn;\n\n\tblock_group = (inode->i_ino - 1) / EXT2_INODES_PER_GROUP(inode->i_sb);\n\tgdp = ext2_get_group_desc(inode->i_sb, block_group, NULL);\n\tif (gdp == NULL)\n\t\treturn;\n\n\t/*\n\t * Figure out the offset within the block group inode table\n\t */\n\toffset = ((inode->i_ino - 1) % EXT2_INODES_PER_GROUP(inode->i_sb)) *\n\t\t\t\tEXT2_INODE_SIZE(inode->i_sb);\n\tblock = le32_to_cpu(gdp->bg_inode_table) +\n\t\t\t\t(offset >> EXT2_BLOCK_SIZE_BITS(inode->i_sb));\n\tsb_breadahead(inode->i_sb, block);\n}", "path": "fs\\ext2\\ialloc.c", "repo_name": "joelagnel/fcp", "stars": 1, "license": "None", "language": "c", "size": 2092}
{"docstring": "/*\n * Tell the filesystem that this inode is no longer of any interest and should\n * be completely destroyed.\n *\n * We leave the inode in the inode hash table until *after* the filesystem's\n * ->delete_inode completes.  This ensures that an iget (such as nfsd might\n * instigate) will always find up-to-date information either in the hash or on\n * disk.\n *\n * I_FREEING is set so that no-one will take a new reference to the inode while\n * it is being deleted.\n */\n", "func_signal": "void generic_delete_inode(struct inode *inode)", "code": "{\n\tconst struct super_operations *op = inode->i_sb->s_op;\n\n\tlist_del_init(&inode->i_list);\n\tlist_del_init(&inode->i_sb_list);\n\tinode->i_state |= I_FREEING;\n\tinodes_stat.nr_inodes--;\n\tspin_unlock(&inode_lock);\n\n\tsecurity_inode_delete(inode);\n\n\tif (op->delete_inode) {\n\t\tvoid (*delete)(struct inode *) = op->delete_inode;\n\t\tif (!is_bad_inode(inode))\n\t\t\tDQUOT_INIT(inode);\n\t\t/* Filesystems implementing their own\n\t\t * s_op->delete_inode are required to call\n\t\t * truncate_inode_pages and clear_inode()\n\t\t * internally */\n\t\tdelete(inode);\n\t} else {\n\t\ttruncate_inode_pages(&inode->i_data, 0);\n\t\tclear_inode(inode);\n\t}\n\tspin_lock(&inode_lock);\n\thlist_del_init(&inode->i_hash);\n\tspin_unlock(&inode_lock);\n\twake_up_inode(inode);\n\tBUG_ON(inode->i_state != I_CLEAR);\n\tdestroy_inode(inode);\n}", "path": "fs\\inode.c", "repo_name": "joelagnel/fcp", "stars": 1, "license": "None", "language": "c", "size": 2092}
{"docstring": "/*\n * Invalidate all inodes for a device.\n */\n", "func_signal": "static int invalidate_list(struct list_head *head, struct list_head *dispose)", "code": "{\n\tstruct list_head *next;\n\tint busy = 0, count = 0;\n\n\tnext = head->next;\n\tfor (;;) {\n\t\tstruct list_head * tmp = next;\n\t\tstruct inode * inode;\n\n\t\t/*\n\t\t * We can reschedule here without worrying about the list's\n\t\t * consistency because the per-sb list of inodes must not\n\t\t * change during umount anymore, and because iprune_mutex keeps\n\t\t * shrink_icache_memory() away.\n\t\t */\n\t\tcond_resched_lock(&inode_lock);\n\n\t\tnext = next->next;\n\t\tif (tmp == head)\n\t\t\tbreak;\n\t\tinode = list_entry(tmp, struct inode, i_sb_list);\n\t\tinvalidate_inode_buffers(inode);\n\t\tif (!atomic_read(&inode->i_count)) {\n\t\t\tlist_move(&inode->i_list, dispose);\n\t\t\tinode->i_state |= I_FREEING;\n\t\t\tcount++;\n\t\t\tcontinue;\n\t\t}\n\t\tbusy = 1;\n\t}\n\t/* only unused inodes may be cached with i_count zero */\n\tinodes_stat.nr_unused -= count;\n\treturn busy;\n}", "path": "fs\\inode.c", "repo_name": "joelagnel/fcp", "stars": 1, "license": "None", "language": "c", "size": 2092}
{"docstring": "/**\n * ilookup - search for an inode in the inode cache\n * @sb:\t\tsuper block of file system to search\n * @ino:\tinode number to search for\n *\n * ilookup() uses ifind_fast() to search for the inode @ino in the inode cache.\n * This is for file systems where the inode number is sufficient for unique\n * identification of an inode.\n *\n * If the inode is in the cache, the inode is returned with an incremented\n * reference count.\n *\n * Otherwise NULL is returned.\n */\n", "func_signal": "struct inode *ilookup(struct super_block *sb, unsigned long ino)", "code": "{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\treturn ifind_fast(sb, head, ino);\n}", "path": "fs\\inode.c", "repo_name": "joelagnel/fcp", "stars": 1, "license": "None", "language": "c", "size": 2092}
{"docstring": "/*\n * Initialize the waitqueues and inode hash table.\n */\n", "func_signal": "void __init inode_init_early(void)", "code": "{\n\tint loop;\n\n\t/* If hashes are distributed across NUMA nodes, defer\n\t * hash allocation until vmalloc space is available.\n\t */\n\tif (hashdist)\n\t\treturn;\n\n\tinode_hashtable =\n\t\talloc_large_system_hash(\"Inode-cache\",\n\t\t\t\t\tsizeof(struct hlist_head),\n\t\t\t\t\tihash_entries,\n\t\t\t\t\t14,\n\t\t\t\t\tHASH_EARLY,\n\t\t\t\t\t&i_hash_shift,\n\t\t\t\t\t&i_hash_mask,\n\t\t\t\t\t0);\n\n\tfor (loop = 0; loop < (1 << i_hash_shift); loop++)\n\t\tINIT_HLIST_HEAD(&inode_hashtable[loop]);\n}", "path": "fs\\inode.c", "repo_name": "joelagnel/fcp", "stars": 1, "license": "None", "language": "c", "size": 2092}
{"docstring": "/* Called at mount-time, super-block is locked */\n", "func_signal": "unsigned long ext2_count_dirs (struct super_block * sb)", "code": "{\n\tunsigned long count = 0;\n\tint i;\n\n\tfor (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n\t\tstruct ext2_group_desc *gdp = ext2_get_group_desc (sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tcount += le16_to_cpu(gdp->bg_used_dirs_count);\n\t}\n\treturn count;\n}", "path": "fs\\ext2\\ialloc.c", "repo_name": "joelagnel/fcp", "stars": 1, "license": "None", "language": "c", "size": 2092}
{"docstring": "/*\n * shrink_icache_memory() will attempt to reclaim some unused inodes.  Here,\n * \"unused\" means that no dentries are referring to the inodes: the files are\n * not open and the dcache references to those inodes have already been\n * reclaimed.\n *\n * This function is passed the number of inodes to scan, and it returns the\n * total number of remaining possibly-reclaimable inodes.\n */\n", "func_signal": "static int shrink_icache_memory(int nr, gfp_t gfp_mask)", "code": "{\n\tif (nr) {\n\t\t/*\n\t\t * Nasty deadlock avoidance.  We may hold various FS locks,\n\t\t * and we don't want to recurse into the FS that called us\n\t\t * in clear_inode() and friends..\n\t \t */\n\t\tif (!(gfp_mask & __GFP_FS))\n\t\t\treturn -1;\n\t\tprune_icache(nr);\n\t}\n\treturn (inodes_stat.nr_unused / 100) * sysctl_vfs_cache_pressure;\n}", "path": "fs\\inode.c", "repo_name": "joelagnel/fcp", "stars": 1, "license": "None", "language": "c", "size": 2092}
{"docstring": "/**\n *\t__insert_inode_hash - hash an inode\n *\t@inode: unhashed inode\n *\t@hashval: unsigned long value used to locate this object in the\n *\t\tinode_hashtable.\n *\n *\tAdd an inode to the inode hash for this superblock.\n */\n", "func_signal": "void __insert_inode_hash(struct inode *inode, unsigned long hashval)", "code": "{\n\tstruct hlist_head *head = inode_hashtable + hash(inode->i_sb, hashval);\n\tspin_lock(&inode_lock);\n\thlist_add_head(&inode->i_hash, head);\n\tspin_unlock(&inode_lock);\n}", "path": "fs\\inode.c", "repo_name": "joelagnel/fcp", "stars": 1, "license": "None", "language": "c", "size": 2092}
{"docstring": "/*\n * dispose_list - dispose of the contents of a local list\n * @head: the head of the list to free\n *\n * Dispose-list gets a local list with local inodes in it, so it doesn't\n * need to worry about list corruption and SMP locks.\n */\n", "func_signal": "static void dispose_list(struct list_head *head)", "code": "{\n\tint nr_disposed = 0;\n\n\twhile (!list_empty(head)) {\n\t\tstruct inode *inode;\n\n\t\tinode = list_first_entry(head, struct inode, i_list);\n\t\tlist_del(&inode->i_list);\n\n\t\tif (inode->i_data.nrpages)\n\t\t\ttruncate_inode_pages(&inode->i_data, 0);\n\t\tclear_inode(inode);\n\n\t\tspin_lock(&inode_lock);\n\t\thlist_del_init(&inode->i_hash);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_lock);\n\n\t\twake_up_inode(inode);\n\t\tdestroy_inode(inode);\n\t\tnr_disposed++;\n\t}\n\tspin_lock(&inode_lock);\n\tinodes_stat.nr_inodes -= nr_disposed;\n\tspin_unlock(&inode_lock);\n}", "path": "fs\\inode.c", "repo_name": "joelagnel/fcp", "stars": 1, "license": "None", "language": "c", "size": 2092}
{"docstring": "/*\n * We rarely want to lock two inodes that do not have a parent/child\n * relationship (such as directory, child inode) simultaneously. The\n * vast majority of file systems should be able to get along fine\n * without this. Do not use these functions except as a last resort.\n */\n", "func_signal": "void inode_double_lock(struct inode *inode1, struct inode *inode2)", "code": "{\n\tif (inode1 == NULL || inode2 == NULL || inode1 == inode2) {\n\t\tif (inode1)\n\t\t\tmutex_lock(&inode1->i_mutex);\n\t\telse if (inode2)\n\t\t\tmutex_lock(&inode2->i_mutex);\n\t\treturn;\n\t}\n\n\tif (inode1 < inode2) {\n\t\tmutex_lock_nested(&inode1->i_mutex, I_MUTEX_PARENT);\n\t\tmutex_lock_nested(&inode2->i_mutex, I_MUTEX_CHILD);\n\t} else {\n\t\tmutex_lock_nested(&inode2->i_mutex, I_MUTEX_PARENT);\n\t\tmutex_lock_nested(&inode1->i_mutex, I_MUTEX_CHILD);\n\t}\n}", "path": "fs\\inode.c", "repo_name": "joelagnel/fcp", "stars": 1, "license": "None", "language": "c", "size": 2092}
{"docstring": "/**\n *\tremove_inode_hash - remove an inode from the hash\n *\t@inode: inode to unhash\n *\n *\tRemove an inode from the superblock.\n */\n", "func_signal": "void remove_inode_hash(struct inode *inode)", "code": "{\n\tspin_lock(&inode_lock);\n\thlist_del_init(&inode->i_hash);\n\tspin_unlock(&inode_lock);\n}", "path": "fs\\inode.c", "repo_name": "joelagnel/fcp", "stars": 1, "license": "None", "language": "c", "size": 2092}
{"docstring": "//\n", "func_signal": "static int asf_write_index(AVFormatContext *s, ASFIndex *index, uint16_t max, uint32_t count)", "code": "{\n    ByteIOContext *pb = s->pb;\n    int i;\n\n    put_guid(pb, &simple_index_header);\n    put_le64(pb, 24 + 16 + 8 + 4 + 4 + (4 + 2)*count);\n    put_guid(pb, &my_guid);\n    put_le64(pb, ASF_INDEXED_INTERVAL);\n    put_le32(pb, max);\n    put_le32(pb, count);\n    for(i=0; i<count; i++) {\n        put_le32(pb, index[i].packet_number);\n        put_le16(pb, index[i].packet_count);\n    }\n\n    return 0;\n}", "path": "src\\libavformat\\asf-enc.c", "repo_name": "chattama/ffmpeg-s60", "stars": 0, "license": "None", "language": "c", "size": 3872}
{"docstring": "/**\n * \\brief read keys from keybuf into keys\n * \\param keybuf buffer containing the keys\n * \\param keys output key array containing the keys for encryption in\n *             native endianness\n */\n", "func_signal": "static void multiswap_init(const uint8_t keybuf[48], uint32_t keys[12])", "code": "{\n    int i;\n    for (i = 0; i < 12; i++)\n        keys[i] = AV_RL32(keybuf + (i << 2)) | 1;\n}", "path": "src\\libavformat\\asfcrypt.c", "repo_name": "chattama/ffmpeg-s60", "stars": 0, "license": "None", "language": "c", "size": 3872}
{"docstring": "/**\n * \\brief \"MultiSwap\" encryption\n * \\param keys 32 bit numbers in machine endianness,\n *             0-4 and 6-10 must be inverted from decryption\n * \\param key another key, this one must be the same for the decryption\n * \\param data data to encrypt\n * \\return encrypted data\n */\n", "func_signal": "static uint64_t multiswap_enc(const uint32_t keys[12], uint64_t key, uint64_t data)", "code": "{\n    uint32_t a = data;\n    uint32_t b = data >> 32;\n    uint32_t c;\n    uint32_t tmp;\n    a += key;\n    tmp = multiswap_step(keys    , a);\n    b += tmp;\n    c = (key >> 32) + tmp;\n    tmp = multiswap_step(keys + 6, b);\n    c += tmp;\n    return ((uint64_t)c << 32) | tmp;\n}", "path": "src\\libavformat\\asfcrypt.c", "repo_name": "chattama/ffmpeg-s60", "stars": 0, "license": "None", "language": "c", "size": 3872}
{"docstring": "/* write an asf chunk (only used in streaming case) */\n", "func_signal": "static void put_chunk(AVFormatContext *s, int type, int payload_length, int flags)", "code": "{\n    ASFContext *asf = s->priv_data;\n    ByteIOContext *pb = s->pb;\n    int length;\n\n    length = payload_length + 8;\n    put_le16(pb, type);\n    put_le16(pb, length);    //size\n    put_le32(pb, asf->seqno);//sequence number\n    put_le16(pb, flags); /* unknown bytes */\n    put_le16(pb, length);    //size_confirm\n    asf->seqno++;\n}", "path": "src\\libavformat\\asf-enc.c", "repo_name": "chattama/ffmpeg-s60", "stars": 0, "license": "None", "language": "c", "size": 3872}
{"docstring": "/* update header size */\n", "func_signal": "static void end_header(ByteIOContext *pb, int64_t pos)", "code": "{\n    int64_t pos1;\n\n    pos1 = url_ftell(pb);\n    url_fseek(pb, pos + 16, SEEK_SET);\n    put_le64(pb, pos1 - pos);\n    url_fseek(pb, pos1, SEEK_SET);\n}", "path": "src\\libavformat\\asf-enc.c", "repo_name": "chattama/ffmpeg-s60", "stars": 0, "license": "None", "language": "c", "size": 3872}
{"docstring": "/* NOTE: no normalisation by 1 / N is done */\n", "func_signal": "void mdct_ref(float *output, float *input, int nbits)", "code": "{\n    int n = 1<<nbits;\n    int k, i;\n    double a, s;\n\n    /* do it by hand */\n    for(k=0;k<n/2;k++) {\n        s = 0;\n        for(i=0;i<n;i++) {\n            a = (2*M_PI*(2*i+1+n/2)*(2*k+1) / (4 * n));\n            s += input[i] * cos(a);\n        }\n        output[k] = s;\n    }\n}", "path": "src\\libavcodec\\fft-test.c", "repo_name": "chattama/ffmpeg-s60", "stars": 0, "license": "None", "language": "c", "size": 3872}
{"docstring": "/* Returns the number of bytes consumed from the bytestream. Returns -1 if\n * there was an error while decoding the header */\n", "func_signal": "static int truemotion1_decode_header(TrueMotion1Context *s)", "code": "{\n    int i;\n    struct frame_header header;\n    uint8_t header_buffer[128];  /* logical maximum size of the header */\n    const uint8_t *sel_vector_table;\n\n    /* There is 1 change bit per 4 pixels, so each change byte represents\n     * 32 pixels; divide width by 4 to obtain the number of change bits and\n     * then round up to the nearest byte. */\n    s->mb_change_bits_row_size = ((s->avctx->width >> 2) + 7) >> 3;\n\n    header.header_size = ((s->buf[0] >> 5) | (s->buf[0] << 3)) & 0x7f;\n    if (s->buf[0] < 0x10)\n    {\n        av_log(s->avctx, AV_LOG_ERROR, \"invalid header size (%d)\\n\", s->buf[0]);\n        return -1;\n    }\n\n    /* unscramble the header bytes with a XOR operation */\n    memset(header_buffer, 0, 128);\n    for (i = 1; i < header.header_size; i++)\n        header_buffer[i - 1] = s->buf[i] ^ s->buf[i + 1];\n\n    header.compression = header_buffer[0];\n    header.deltaset = header_buffer[1];\n    header.vectable = header_buffer[2];\n    header.ysize = AV_RL16(&header_buffer[3]);\n    header.xsize = AV_RL16(&header_buffer[5]);\n    header.checksum = AV_RL16(&header_buffer[7]);\n    header.version = header_buffer[9];\n    header.header_type = header_buffer[10];\n    header.flags = header_buffer[11];\n    header.control = header_buffer[12];\n\n    /* Version 2 */\n    if (header.version >= 2)\n    {\n        if (header.header_type > 3)\n        {\n            av_log(s->avctx, AV_LOG_ERROR, \"invalid header type (%d)\\n\", header.header_type);\n            return -1;\n        } else if ((header.header_type == 2) || (header.header_type == 3)) {\n            s->flags = header.flags;\n            if (!(s->flags & FLAG_INTERFRAME))\n                s->flags |= FLAG_KEYFRAME;\n        } else\n            s->flags = FLAG_KEYFRAME;\n    } else /* Version 1 */\n        s->flags = FLAG_KEYFRAME;\n\n    if (s->flags & FLAG_SPRITE) {\n        av_log(s->avctx, AV_LOG_INFO, \"SPRITE frame found, please report the sample to the developers\\n\");\n        /* FIXME header.width, height, xoffset and yoffset aren't initialized */\n#if 0\n        s->w = header.width;\n        s->h = header.height;\n        s->x = header.xoffset;\n        s->y = header.yoffset;\n#else\n        return -1;\n#endif\n    } else {\n        s->w = header.xsize;\n        s->h = header.ysize;\n        if (header.header_type < 2) {\n            if ((s->w < 213) && (s->h >= 176))\n            {\n                s->flags |= FLAG_INTERPOLATED;\n                av_log(s->avctx, AV_LOG_INFO, \"INTERPOLATION selected, please report the sample to the developers\\n\");\n            }\n        }\n    }\n\n    if (header.compression >= 17) {\n        av_log(s->avctx, AV_LOG_ERROR, \"invalid compression type (%d)\\n\", header.compression);\n        return -1;\n    }\n\n    if ((header.deltaset != s->last_deltaset) ||\n        (header.vectable != s->last_vectable))\n        select_delta_tables(s, header.deltaset);\n\n    if ((header.compression & 1) && header.header_type)\n        sel_vector_table = pc_tbl2;\n    else {\n        if (header.vectable < 4)\n            sel_vector_table = tables[header.vectable - 1];\n        else {\n            av_log(s->avctx, AV_LOG_ERROR, \"invalid vector table id (%d)\\n\", header.vectable);\n            return -1;\n        }\n    }\n\n    // FIXME: where to place this ?!?!\n    if (compression_types[header.compression].algorithm == ALGO_RGB24H)\n        s->avctx->pix_fmt = PIX_FMT_RGB32;\n    else\n        s->avctx->pix_fmt = PIX_FMT_RGB555; // RGB565 is supported as well\n\n    if ((header.deltaset != s->last_deltaset) || (header.vectable != s->last_vectable))\n    {\n        if (compression_types[header.compression].algorithm == ALGO_RGB24H)\n            gen_vector_table24(s, sel_vector_table);\n        else\n        if (s->avctx->pix_fmt == PIX_FMT_RGB555)\n            gen_vector_table15(s, sel_vector_table);\n        else\n            gen_vector_table16(s, sel_vector_table);\n    }\n\n    /* set up pointers to the other key data chunks */\n    s->mb_change_bits = s->buf + header.header_size;\n    if (s->flags & FLAG_KEYFRAME) {\n        /* no change bits specified for a keyframe; only index bytes */\n        s->index_stream = s->mb_change_bits;\n    } else {\n        /* one change bit per 4x4 block */\n        s->index_stream = s->mb_change_bits +\n            (s->mb_change_bits_row_size * (s->avctx->height >> 2));\n    }\n    s->index_stream_size = s->size - (s->index_stream - s->buf);\n\n    s->last_deltaset = header.deltaset;\n    s->last_vectable = header.vectable;\n    s->compression = header.compression;\n    s->block_width = compression_types[header.compression].block_width;\n    s->block_height = compression_types[header.compression].block_height;\n    s->block_type = compression_types[header.compression].block_type;\n\n    if (s->avctx->debug & FF_DEBUG_PICT_INFO)\n        av_log(s->avctx, AV_LOG_INFO, \"tables: %d / %d c:%d %dx%d t:%d %s%s%s%s\\n\",\n            s->last_deltaset, s->last_vectable, s->compression, s->block_width,\n            s->block_height, s->block_type,\n            s->flags & FLAG_KEYFRAME ? \" KEY\" : \"\",\n            s->flags & FLAG_INTERFRAME ? \" INTER\" : \"\",\n            s->flags & FLAG_SPRITE ? \" SPRITE\" : \"\",\n            s->flags & FLAG_INTERPOLATED ? \" INTERPOL\" : \"\");\n\n    return header.header_size;\n}", "path": "src\\libavcodec\\truemotion1.c", "repo_name": "chattama/ffmpeg-s60", "stars": 0, "license": "None", "language": "c", "size": 3872}
{"docstring": "/**\n * \\brief \"MultiSwap\" decryption\n * \\param keys 32 bit numbers in machine endianness,\n *             0-4 and 6-10 must be inverted from encryption\n * \\param key another key, this one must be the same as for the encryption\n * \\param data data to decrypt\n * \\return decrypted data\n */\n", "func_signal": "static uint64_t multiswap_dec(const uint32_t keys[12], uint64_t key, uint64_t data)", "code": "{\n    uint32_t a;\n    uint32_t b;\n    uint32_t c = data >> 32;\n    uint32_t tmp = data;\n    c -= tmp;\n    b = multiswap_inv_step(keys + 6, tmp);\n    tmp = c - (key >> 32);\n    b -= tmp;\n    a = multiswap_inv_step(keys    , tmp);\n    a -= key;\n    return ((uint64_t)b << 32) | a;\n}", "path": "src\\libavformat\\asfcrypt.c", "repo_name": "chattama/ffmpeg-s60", "stars": 0, "license": "None", "language": "c", "size": 3872}
{"docstring": "/**\n * \\brief find multiplicative inverse modulo 2 ^ 32\n * \\param v number to invert, must be odd!\n * \\return number so that result * v = 1 (mod 2^32)\n */\n", "func_signal": "static uint32_t inverse(uint32_t v)", "code": "{\n    // v ^ 3 gives the inverse (mod 16), could also be implemented\n    // as table etc. (only lowest 4 bits matter!)\n    uint32_t inverse = v * v * v;\n    // uses a fixpoint-iteration that doubles the number\n    // of correct lowest bits each time\n    inverse *= 2 - v * inverse;\n    inverse *= 2 - v * inverse;\n    inverse *= 2 - v * inverse;\n    return inverse;\n}", "path": "src\\libavformat\\asfcrypt.c", "repo_name": "chattama/ffmpeg-s60", "stars": 0, "license": "None", "language": "c", "size": 3872}
{"docstring": "/* XXX: make it use less memory */\n", "func_signal": "static int av_mpeg4_decode_header(AVCodecParserContext *s1,\n                                  AVCodecContext *avctx,\n                                  const uint8_t *buf, int buf_size)", "code": "{\n    ParseContext1 *pc = s1->priv_data;\n    MpegEncContext *s = pc->enc;\n    GetBitContext gb1, *gb = &gb1;\n    int ret;\n\n    s->avctx = avctx;\n    s->current_picture_ptr = &s->current_picture;\n\n    if (avctx->extradata_size && pc->first_picture){\n        init_get_bits(gb, avctx->extradata, avctx->extradata_size*8);\n        ret = ff_mpeg4_decode_picture_header(s, gb);\n    }\n\n    init_get_bits(gb, buf, 8 * buf_size);\n    ret = ff_mpeg4_decode_picture_header(s, gb);\n    if (s->width) {\n        avcodec_set_dimensions(avctx, s->width, s->height);\n    }\n    s1->pict_type= s->pict_type;\n    pc->first_picture = 0;\n    return ret;\n}", "path": "src\\libavcodec\\mpeg4video_parser.c", "repo_name": "chattama/ffmpeg-s60", "stars": 0, "license": "None", "language": "c", "size": 3872}
{"docstring": "/**\n * Get stored dimension from bitstream.\n *\n * If the width/height is the standard one then it's coded as a 3-bit index.\n * Otherwise it is coded as escaped 8-bit portions.\n */\n", "func_signal": "static int get_dimension(GetBitContext *gb, const int *dim)", "code": "{\n    int t   = get_bits(gb, 3);\n    int val = dim[t];\n    if(val < 0)\n        val = dim[get_bits1(gb) - val];\n    if(!val){\n        do{\n            t = get_bits(gb, 8);\n            val += t << 2;\n        }while(t == 0xFF);\n    }\n    return val;\n}", "path": "src\\libavcodec\\rv40.c", "repo_name": "chattama/ffmpeg-s60", "stars": 0, "license": "None", "language": "c", "size": 3872}
{"docstring": "/**\n * Get encoded picture size - usually this is called from rv40_parse_slice_header.\n */\n", "func_signal": "static void rv40_parse_picture_size(GetBitContext *gb, int *w, int *h)", "code": "{\n    *w = get_dimension(gb, rv40_standard_widths);\n    *h = get_dimension(gb, rv40_standard_heights);\n}", "path": "src\\libavcodec\\rv40.c", "repo_name": "chattama/ffmpeg-s60", "stars": 0, "license": "None", "language": "c", "size": 3872}
{"docstring": "/**\n * Initialize all tables.\n */\n", "func_signal": "static av_cold void rv40_init_tables()", "code": "{\n    int i;\n\n    init_vlc(&aic_top_vlc, AIC_TOP_BITS, AIC_TOP_SIZE,\n             rv40_aic_top_vlc_bits,  1, 1,\n             rv40_aic_top_vlc_codes, 1, 1, INIT_VLC_USE_STATIC);\n    for(i = 0; i < AIC_MODE1_NUM; i++){\n        // Every tenth VLC table is empty\n        if((i % 10) == 9) continue;\n        init_vlc(&aic_mode1_vlc[i], AIC_MODE1_BITS, AIC_MODE1_SIZE,\n                 aic_mode1_vlc_bits[i],  1, 1,\n                 aic_mode1_vlc_codes[i], 1, 1, INIT_VLC_USE_STATIC);\n    }\n    for(i = 0; i < AIC_MODE2_NUM; i++){\n        init_vlc(&aic_mode2_vlc[i], AIC_MODE2_BITS, AIC_MODE2_SIZE,\n                 aic_mode2_vlc_bits[i],  1, 1,\n                 aic_mode2_vlc_codes[i], 2, 2, INIT_VLC_USE_STATIC);\n    }\n    for(i = 0; i < NUM_PTYPE_VLCS; i++)\n         init_vlc_sparse(&ptype_vlc[i], PTYPE_VLC_BITS, PTYPE_VLC_SIZE,\n                         ptype_vlc_bits[i],  1, 1,\n                         ptype_vlc_codes[i], 1, 1,\n                         ptype_vlc_syms,     1, 1, INIT_VLC_USE_STATIC);\n    for(i = 0; i < NUM_BTYPE_VLCS; i++)\n         init_vlc_sparse(&btype_vlc[i], BTYPE_VLC_BITS, BTYPE_VLC_SIZE,\n                         btype_vlc_bits[i],  1, 1,\n                         btype_vlc_codes[i], 1, 1,\n                         btype_vlc_syms,     1, 1, INIT_VLC_USE_STATIC);\n}", "path": "src\\libavcodec\\rv40.c", "repo_name": "chattama/ffmpeg-s60", "stars": 0, "license": "None", "language": "c", "size": 3872}
{"docstring": "/* convert from unix to windows time */\n", "func_signal": "static int64_t unix_to_file_time(int ti)", "code": "{\n    int64_t t;\n\n    t = ti * INT64_C(10000000);\n    t += INT64_C(116444736000000000);\n    return t;\n}", "path": "src\\libavformat\\asf-enc.c", "repo_name": "chattama/ffmpeg-s60", "stars": 0, "license": "None", "language": "c", "size": 3872}
{"docstring": "/**\n * Initialize decoder.\n */\n", "func_signal": "static av_cold int rv40_decode_init(AVCodecContext *avctx)", "code": "{\n    RV34DecContext *r = avctx->priv_data;\n\n    r->rv30 = 0;\n    ff_rv34_decode_init(avctx);\n    if(!aic_top_vlc.bits)\n        rv40_init_tables();\n    r->parse_slice_header = rv40_parse_slice_header;\n    r->decode_intra_types = rv40_decode_intra_types;\n    r->decode_mb_info     = rv40_decode_mb_info;\n    r->luma_dc_quant_i = rv40_luma_dc_quant[0];\n    r->luma_dc_quant_p = rv40_luma_dc_quant[1];\n    return 0;\n}", "path": "src\\libavcodec\\rv40.c", "repo_name": "chattama/ffmpeg-s60", "stars": 0, "license": "None", "language": "c", "size": 3872}
{"docstring": "/* return non zero if error */\n", "func_signal": "static int tcp_open(URLContext *h, const char *uri, int flags)", "code": "{\n    struct sockaddr_in dest_addr;\n    char hostname[1024], *q;\n    int port, fd = -1;\n    TCPContext *s = NULL;\n    fd_set wfds;\n    int fd_max, ret;\n    struct timeval tv;\n    socklen_t optlen;\n    char proto[1024],path[1024],tmp[1024];  // PETR: protocol and path strings\n\n    url_split(proto, sizeof(proto), NULL, 0, hostname, sizeof(hostname),\n      &port, path, sizeof(path), uri);  // PETR: use url_split\n    if (strcmp(proto,\"tcp\")) goto fail; // PETR: check protocol\n    if ((q = strchr(hostname,'@'))) { strcpy(tmp,q+1); strcpy(hostname,tmp); } // PETR: take only the part after '@' for tcp protocol\n\n    s = av_malloc(sizeof(TCPContext));\n    if (!s)\n        return AVERROR(ENOMEM);\n    h->priv_data = s;\n    h->is_streamed = 1;\n\n    if (port <= 0 || port >= 65536)\n        goto fail;\n\n    if(!ff_network_init())\n        return AVERROR(EIO);\n\n    dest_addr.sin_family = AF_INET;\n    dest_addr.sin_port = htons(port);\n    if (resolve_host(&dest_addr.sin_addr, hostname) < 0)\n        goto fail;\n\n    fd = socket(AF_INET, SOCK_STREAM, 0);\n    if (fd < 0)\n        goto fail;\n    ff_socket_nonblock(fd, 1);\n\n redo:\n    ret = connect(fd, (struct sockaddr *)&dest_addr,\n                  sizeof(dest_addr));\n    if (ret < 0) {\n        if (ff_neterrno() == FF_NETERROR(EINTR))\n            goto redo;\n        if (ff_neterrno() != FF_NETERROR(EINPROGRESS) &&\n            ff_neterrno() != FF_NETERROR(EAGAIN))\n            goto fail;\n\n        /* wait until we are connected or until abort */\n        for(;;) {\n            if (url_interrupt_cb()) {\n                ret = AVERROR(EINTR);\n                goto fail1;\n            }\n            fd_max = fd;\n            FD_ZERO(&wfds);\n            FD_SET(fd, &wfds);\n            tv.tv_sec = 0;\n            tv.tv_usec = 100 * 1000;\n            ret = select(fd_max + 1, NULL, &wfds, NULL, &tv);\n            if (ret > 0 && FD_ISSET(fd, &wfds))\n                break;\n        }\n\n        /* test error */\n        optlen = sizeof(ret);\n        getsockopt (fd, SOL_SOCKET, SO_ERROR, &ret, &optlen);\n        if (ret != 0)\n            goto fail;\n    }\n    s->fd = fd;\n    return 0;\n\n fail:\n    ret = AVERROR(EIO);\n fail1:\n    if (fd >= 0)\n        closesocket(fd);\n    av_free(s);\n    return ret;\n}", "path": "src\\libavformat\\tcp.c", "repo_name": "chattama/ffmpeg-s60", "stars": 0, "license": "None", "language": "c", "size": 3872}
{"docstring": "/**\n * Decode macroblock information.\n */\n", "func_signal": "static int rv40_decode_mb_info(RV34DecContext *r)", "code": "{\n    MpegEncContext *s = &r->s;\n    GetBitContext *gb = &s->gb;\n    int q, i;\n    int prev_type = 0;\n    int mb_pos = s->mb_x + s->mb_y * s->mb_stride;\n    int blocks[RV34_MB_TYPES] = {0};\n    int count = 0;\n\n    if(!r->s.mb_skip_run)\n        r->s.mb_skip_run = svq3_get_ue_golomb(gb) + 1;\n\n    if(--r->s.mb_skip_run)\n         return RV34_MB_SKIP;\n\n    if(r->avail_cache[5-1])\n        blocks[r->mb_type[mb_pos - 1]]++;\n    if(r->avail_cache[5-4]){\n        blocks[r->mb_type[mb_pos - s->mb_stride]]++;\n        if(r->avail_cache[5-2])\n            blocks[r->mb_type[mb_pos - s->mb_stride + 1]]++;\n        if(r->avail_cache[5-5])\n            blocks[r->mb_type[mb_pos - s->mb_stride - 1]]++;\n    }\n\n    for(i = 0; i < RV34_MB_TYPES; i++){\n        if(blocks[i] > count){\n            count = blocks[i];\n            prev_type = i;\n        }\n    }\n    if(s->pict_type == FF_P_TYPE){\n        prev_type = block_num_to_ptype_vlc_num[prev_type];\n        q = get_vlc2(gb, ptype_vlc[prev_type].table, PTYPE_VLC_BITS, 1);\n        if(q < PBTYPE_ESCAPE)\n            return q;\n        q = get_vlc2(gb, ptype_vlc[prev_type].table, PTYPE_VLC_BITS, 1);\n        av_log(s->avctx, AV_LOG_ERROR, \"Dquant for P-frame\\n\");\n    }else{\n        prev_type = block_num_to_btype_vlc_num[prev_type];\n        q = get_vlc2(gb, btype_vlc[prev_type].table, BTYPE_VLC_BITS, 1);\n        if(q < PBTYPE_ESCAPE)\n            return q;\n        q = get_vlc2(gb, btype_vlc[prev_type].table, BTYPE_VLC_BITS, 1);\n        av_log(s->avctx, AV_LOG_ERROR, \"Dquant for B-frame\\n\");\n    }\n    return 0;\n}", "path": "src\\libavcodec\\rv40.c", "repo_name": "chattama/ffmpeg-s60", "stars": 0, "license": "None", "language": "c", "size": 3872}
{"docstring": "/**\n * Decode 4x4 intra types array.\n */\n", "func_signal": "static int rv40_decode_intra_types(RV34DecContext *r, GetBitContext *gb, int8_t *dst)", "code": "{\n    MpegEncContext *s = &r->s;\n    int i, j, k, v;\n    int A, B, C;\n    int pattern;\n    int8_t *ptr;\n\n    for(i = 0; i < 4; i++, dst += s->b4_stride){\n        if(!i && s->first_slice_line){\n            pattern = get_vlc2(gb, aic_top_vlc.table, AIC_TOP_BITS, 1);\n            dst[0] = (pattern >> 2) & 2;\n            dst[1] = (pattern >> 1) & 2;\n            dst[2] =  pattern       & 2;\n            dst[3] = (pattern << 1) & 2;\n            continue;\n        }\n        ptr = dst;\n        for(j = 0; j < 4; j++){\n            /* Coefficients are read using VLC chosen by the prediction pattern\n             * The first one (used for retrieving a pair of coefficients) is\n             * constructed from the top, top right and left coefficients\n             * The second one (used for retrieving only one coefficient) is\n             * top + 10 * left.\n             */\n            A = ptr[-s->b4_stride + 1]; // it won't be used for the last coefficient in a row\n            B = ptr[-s->b4_stride];\n            C = ptr[-1];\n            pattern = A + (B << 4) + (C << 8);\n            for(k = 0; k < MODE2_PATTERNS_NUM; k++)\n                if(pattern == rv40_aic_table_index[k])\n                    break;\n            if(j < 3 && k < MODE2_PATTERNS_NUM){ //pattern is found, decoding 2 coefficients\n                v = get_vlc2(gb, aic_mode2_vlc[k].table, AIC_MODE2_BITS, 2);\n                *ptr++ = v/9;\n                *ptr++ = v%9;\n                j++;\n            }else{\n                if(B != -1 && C != -1)\n                    v = get_vlc2(gb, aic_mode1_vlc[B + C*10].table, AIC_MODE1_BITS, 1);\n                else{ // tricky decoding\n                    v = 0;\n                    switch(C){\n                    case -1: // code 0 -> 1, 1 -> 0\n                        if(B < 2)\n                            v = get_bits1(gb) ^ 1;\n                        break;\n                    case  0:\n                    case  2: // code 0 -> 2, 1 -> 0\n                        v = (get_bits1(gb) ^ 1) << 1;\n                        break;\n                    }\n                }\n                *ptr++ = v;\n            }\n        }\n    }\n    return 0;\n}", "path": "src\\libavcodec\\rv40.c", "repo_name": "chattama/ffmpeg-s60", "stars": 0, "license": "None", "language": "c", "size": 3872}
{"docstring": "/**\n * \\brief invert the keys so that encryption become decryption keys and\n *        the other way round.\n * \\param keys key array of ints to invert\n */\n", "func_signal": "static void multiswap_invert_keys(uint32_t keys[12])", "code": "{\n    int i;\n    for (i = 0; i < 5; i++)\n        keys[i] = inverse(keys[i]);\n    for (i = 6; i < 11; i++)\n        keys[i] = inverse(keys[i]);\n}", "path": "src\\libavformat\\asfcrypt.c", "repo_name": "chattama/ffmpeg-s60", "stars": 0, "license": "None", "language": "c", "size": 3872}
{"docstring": "/* write the header (used two times if non streamed) */\n", "func_signal": "static int asf_write_header1(AVFormatContext *s, int64_t file_size, int64_t data_chunk_size)", "code": "{\n    ASFContext *asf = s->priv_data;\n    ByteIOContext *pb = s->pb;\n    int header_size, n, extra_size, extra_size2, wav_extra_size, file_time;\n    int has_title;\n    AVCodecContext *enc;\n    int64_t header_offset, cur_pos, hpos;\n    int bit_rate;\n    int64_t duration;\n\n    duration = asf->duration + PREROLL_TIME * 10000;\n    has_title = (s->title[0] || s->author[0] || s->copyright[0] || s->comment[0]);\n\n    bit_rate = 0;\n    for(n=0;n<s->nb_streams;n++) {\n        enc = s->streams[n]->codec;\n\n        av_set_pts_info(s->streams[n], 32, 1, 1000); /* 32 bit pts in ms */\n\n        bit_rate += enc->bit_rate;\n    }\n\n    if (asf->is_streamed) {\n        put_chunk(s, 0x4824, 0, 0xc00); /* start of stream (length will be patched later) */\n    }\n\n    put_guid(pb, &asf_header);\n    put_le64(pb, -1); /* header length, will be patched after */\n    put_le32(pb, 3 + has_title + s->nb_streams); /* number of chunks in header */\n    put_byte(pb, 1); /* ??? */\n    put_byte(pb, 2); /* ??? */\n\n    /* file header */\n    header_offset = url_ftell(pb);\n    hpos = put_header(pb, &file_header);\n    put_guid(pb, &my_guid);\n    put_le64(pb, file_size);\n    file_time = 0;\n    put_le64(pb, unix_to_file_time(file_time));\n    put_le64(pb, asf->nb_packets); /* number of packets */\n    put_le64(pb, duration); /* end time stamp (in 100ns units) */\n    put_le64(pb, asf->duration); /* duration (in 100ns units) */\n    put_le64(pb, PREROLL_TIME); /* start time stamp */\n    put_le32(pb, (asf->is_streamed || url_is_streamed(pb)) ? 3 : 2); /* ??? */\n    put_le32(pb, asf->packet_size); /* packet size */\n    put_le32(pb, asf->packet_size); /* packet size */\n    put_le32(pb, bit_rate); /* Nominal data rate in bps */\n    end_header(pb, hpos);\n\n    /* unknown headers */\n    hpos = put_header(pb, &head1_guid);\n    put_guid(pb, &head2_guid);\n    put_le32(pb, 6);\n    put_le16(pb, 0);\n    end_header(pb, hpos);\n\n    /* title and other infos */\n    if (has_title) {\n        hpos = put_header(pb, &comment_header);\n        if ( s->title[0]     ) { put_le16(pb, 2 * (strlen(s->title    ) + 1)); } else { put_le16(pb, 0); }\n        if ( s->author[0]    ) { put_le16(pb, 2 * (strlen(s->author   ) + 1)); } else { put_le16(pb, 0); }\n        if ( s->copyright[0] ) { put_le16(pb, 2 * (strlen(s->copyright) + 1)); } else { put_le16(pb, 0); }\n        if ( s->comment[0]   ) { put_le16(pb, 2 * (strlen(s->comment  ) + 1)); } else { put_le16(pb, 0); }\n        put_le16(pb, 0);\n        if ( s->title[0]     ) put_str16_nolen(pb, s->title);\n        if ( s->author[0]    ) put_str16_nolen(pb, s->author);\n        if ( s->copyright[0] ) put_str16_nolen(pb, s->copyright);\n        if ( s->comment[0]   ) put_str16_nolen(pb, s->comment);\n        end_header(pb, hpos);\n    }\n\n    /* stream headers */\n    for(n=0;n<s->nb_streams;n++) {\n        int64_t es_pos;\n        //        ASFStream *stream = &asf->streams[n];\n\n        enc = s->streams[n]->codec;\n        asf->streams[n].num = n + 1;\n        asf->streams[n].seq = 0;\n\n\n        switch(enc->codec_type) {\n        case CODEC_TYPE_AUDIO:\n            wav_extra_size = 0;\n            extra_size = 18 + wav_extra_size;\n            extra_size2 = 8;\n            break;\n        default:\n        case CODEC_TYPE_VIDEO:\n            wav_extra_size = enc->extradata_size;\n            extra_size = 0x33 + wav_extra_size;\n            extra_size2 = 0;\n            break;\n        }\n\n        hpos = put_header(pb, &stream_header);\n        if (enc->codec_type == CODEC_TYPE_AUDIO) {\n            put_guid(pb, &audio_stream);\n            put_guid(pb, &audio_conceal_spread);\n        } else {\n            put_guid(pb, &video_stream);\n            put_guid(pb, &video_conceal_none);\n        }\n        put_le64(pb, 0); /* ??? */\n        es_pos = url_ftell(pb);\n        put_le32(pb, extra_size); /* wav header len */\n        put_le32(pb, extra_size2); /* additional data len */\n        put_le16(pb, n + 1); /* stream number */\n        put_le32(pb, 0); /* ??? */\n\n        if (enc->codec_type == CODEC_TYPE_AUDIO) {\n            /* WAVEFORMATEX header */\n            int wavsize = put_wav_header(pb, enc);\n            if ((enc->codec_id != CODEC_ID_MP3) && (enc->codec_id != CODEC_ID_MP2) && (enc->codec_id != CODEC_ID_ADPCM_IMA_WAV) && (enc->extradata_size==0)) {\n                wavsize += 2;\n                put_le16(pb, 0);\n            }\n\n            if (wavsize < 0)\n                return -1;\n            if (wavsize != extra_size) {\n                cur_pos = url_ftell(pb);\n                url_fseek(pb, es_pos, SEEK_SET);\n                put_le32(pb, wavsize); /* wav header len */\n                url_fseek(pb, cur_pos, SEEK_SET);\n            }\n            /* ERROR Correction */\n            put_byte(pb, 0x01);\n            if(enc->codec_id == CODEC_ID_ADPCM_G726 || !enc->block_align){\n                put_le16(pb, 0x0190);\n                put_le16(pb, 0x0190);\n            }else{\n                put_le16(pb, enc->block_align);\n                put_le16(pb, enc->block_align);\n            }\n            put_le16(pb, 0x01);\n            put_byte(pb, 0x00);\n        } else {\n            put_le32(pb, enc->width);\n            put_le32(pb, enc->height);\n            put_byte(pb, 2); /* ??? */\n            put_le16(pb, 40 + enc->extradata_size); /* size */\n\n            /* BITMAPINFOHEADER header */\n            put_bmp_header(pb, enc, codec_bmp_tags, 1);\n        }\n        end_header(pb, hpos);\n    }\n\n    /* media comments */\n\n    hpos = put_header(pb, &codec_comment_header);\n    put_guid(pb, &codec_comment1_header);\n    put_le32(pb, s->nb_streams);\n    for(n=0;n<s->nb_streams;n++) {\n        AVCodec *p;\n\n        enc = s->streams[n]->codec;\n        p = avcodec_find_encoder(enc->codec_id);\n\n        if(enc->codec_type == CODEC_TYPE_AUDIO)\n            put_le16(pb, 2);\n        else if(enc->codec_type == CODEC_TYPE_VIDEO)\n            put_le16(pb, 1);\n        else\n            put_le16(pb, -1);\n\n        if(enc->codec_id == CODEC_ID_WMAV2)\n            put_str16(pb, \"Windows Media Audio V8\");\n        else\n            put_str16(pb, p ? p->name : enc->codec_name);\n        put_le16(pb, 0); /* no parameters */\n\n\n        /* id */\n        if (enc->codec_type == CODEC_TYPE_AUDIO) {\n            put_le16(pb, 2);\n            put_le16(pb, enc->codec_tag);\n        } else {\n            put_le16(pb, 4);\n            put_le32(pb, enc->codec_tag);\n        }\n        if(!enc->codec_tag)\n            return -1;\n    }\n    end_header(pb, hpos);\n\n    /* patch the header size fields */\n\n    cur_pos = url_ftell(pb);\n    header_size = cur_pos - header_offset;\n    if (asf->is_streamed) {\n        header_size += 8 + 30 + 50;\n\n        url_fseek(pb, header_offset - 10 - 30, SEEK_SET);\n        put_le16(pb, header_size);\n        url_fseek(pb, header_offset - 2 - 30, SEEK_SET);\n        put_le16(pb, header_size);\n\n        header_size -= 8 + 30 + 50;\n    }\n    header_size += 24 + 6;\n    url_fseek(pb, header_offset - 14, SEEK_SET);\n    put_le64(pb, header_size);\n    url_fseek(pb, cur_pos, SEEK_SET);\n\n    /* movie chunk, followed by packets of packet_size */\n    asf->data_offset = cur_pos;\n    put_guid(pb, &data_header);\n    put_le64(pb, data_chunk_size);\n    put_guid(pb, &my_guid);\n    put_le64(pb, asf->nb_packets); /* nb packets */\n    put_byte(pb, 1); /* ??? */\n    put_byte(pb, 1); /* ??? */\n    return 0;\n}", "path": "src\\libavformat\\asf-enc.c", "repo_name": "chattama/ffmpeg-s60", "stars": 0, "license": "None", "language": "c", "size": 3872}
{"docstring": "/*\n\tFonction : EcrireCatalogue\n\n\tParam\u00e8tre : un pointeur sur une chaine termin\u00e9e par\n\t\tle caract\u00e8re '\\0' contenant le nom du fichier pour la sauvagarde.\n\n\tValeur de retour : le nombre de livres \u00e9crits dans le fichier\n\t\tou 0 si l'\u00e9criture l'a pu \u00eatre possible.\n\n\tRemarque : le catalogue reste inchang\u00e9.\n\n*/\n", "func_signal": "int EcrireCatalogue(const char *NomFichier)", "code": "{\n\tFILE *Fichier;\t\t/* le pointeur sur le descripteur de fichier */\n\tint NombreLivresEcrits = 0;\t/* Nombres de livres \u00e9crits dans le fichiers */\n\n\t/* Tests des param\u00e8tres: pointeur NULL ou cha\u00eene vide */\n\tif (NomFichier == NULL || NomFichier[0] == '\\0')\n\t\treturn ParametresIncorrects;\n\n\t/* Tentative d'ouverture du fichier en \u00e9criture binaire et v\u00e9rification */\n\tFichier = fopen(NomFichier, \"wb\");\n\tif (Fichier == NULL) {\n\t\t/* Impossible d'ouvrir le fichier */\n\t\treturn OuvertureFichierImpossible;\n\t}\n\n\t/* Ecriture des livres s'il y en a dans le catalogue */\n\tif (NombreOuvragesAuCatalogue != 0) {\n\t\tNombreLivresEcrits =\n\t\t    fwrite(Catalogue, sizeof(Livre),\n\t\t\t   NombreOuvragesAuCatalogue, Fichier);\n\t}\n\n\t/* Fermeture du fichier */\n\tfclose(Fichier);\n\n\t/* On retourne le nombre de livres \u00e9crits dans le fichier */\n\treturn NombreLivresEcrits;\n}", "path": "extern\\src\\GestionLivres.c", "repo_name": "pcarrier/edu-projet_sys_res", "stars": 1, "license": "other", "language": "c", "size": 1536}
{"docstring": "/*------------------------------------------------------------------*/\n/* client_ouvrir_session\t\t\t\t\t\t\t\t\t\t\t*/\n/*------------------------------------------------------------------*/\n", "func_signal": "char *client_ouvrir_session()", "code": "{\n\tif (!strcmp(protocole_courant, \"udp\")) {\n\t\treturn\n\t\t    \"Vous \u00eates en UDP, pas d'ouverture de session requise\\n\";\n\t} else if (!strcmp(protocole_courant, \"tcp\")) {\n\t} else\n\t\treturn \"Protocole non connu.\\n\";\n\n\treturn \"OK\";\n}", "path": "extern\\src\\client.c", "repo_name": "pcarrier/edu-projet_sys_res", "stars": 1, "license": "other", "language": "c", "size": 1536}
{"docstring": "/*------------------------------------------------------------------*/\n/* client_ouvrir_session\t\t\t\t\t\t\t\t\t\t\t*/\n/*------------------------------------------------------------------*/\n", "func_signal": "char* client_ouvrir_session()", "code": "{\n\tif (!strcmp(protocole_courant,\"udp\")) {\n\t\treturn \"Vous \u00eates en UDP, pas d'ouverture de session requise\\n\";\n\t} else if (!strcmp(protocole_courant,\"tcp\")) {\n\t} else \n\t\treturn \"Protocole non connu.\\n\";\n\t\t\n\treturn \"OK\"\t;\n}", "path": "extern\\old\\gampouris\\client.c", "repo_name": "pcarrier/edu-projet_sys_res", "stars": 1, "license": "other", "language": "c", "size": 1536}
{"docstring": "/*\n\tFonction : LireCatalogue\n\n\tParam\u00e8tre : un pointeur sur une chaine termin\u00e9e par\n\t\tle caract\u00e8re '\\0' contenant le nom du fichier \u00e0 charger.\n\n\tValeur de retour : le nombre de livres lus depuis le fichier,\n\t\t0 si aucun n'a pu \u00eatre lu, un code d'erreur en cas de probl\u00e8me :\n\t\t-1 si les param\u00e8tres sont incorrects\n\t\t-2 si l'on a pas pu ouvrir le fichier\n\n\tRemarque : si la fonction ne peut ouvrir le fichier, le catalogue reste\n\t\tinchang\u00e9.\n\n*/\n", "func_signal": "int LireCatalogue(const char *NomFichier)", "code": "{\n\tFILE *Fichier;\t\t/* le pointeur sur le descripteur de fichier */\n\tint NombreLivresLus;\t/* Nombres de livres lus dans le fichiers */\n\n\t/* Tests des param\u00e8tres: pointeur NULL ou cha\u00e5ne vide */\n\tif (NomFichier == NULL || NomFichier[0] == '\\0')\n\t\treturn ParametresIncorrects;\n\n\t/* Tentative d'ouverture du fichier en lecture binaire et v\u00e9rification */\n\tFichier = fopen(NomFichier, \"rb\");\n\tif (Fichier == NULL) {\n\t\t/* Impossible d'ouvrir le fichier */\n\t\treturn OuvertureFichierImpossible;\n\t}\n\n\t/* On lit au maximum NombreMaximumDeLivres livres depuis le fichier */\n\tNombreLivresLus =\n\t    fread(Catalogue, sizeof(Livre), NombreMaximumDeLivres, Fichier);\n\n\t/* Fermeture du fichier */\n\tfclose(Fichier);\n\n\t/* Mise a jours des variables du module et retour du r\u00e9sultat */\n\tNombreOuvragesAuCatalogue = NombreLivresLus;\n\n\treturn NombreLivresLus;\n}", "path": "extern\\src\\GestionLivres.c", "repo_name": "pcarrier/edu-projet_sys_res", "stars": 1, "license": "other", "language": "c", "size": 1536}
{"docstring": "/*\t\t\t    +===================+\t\t\t\t*/\n/*==========================| \tH_CONNECT\t|===============================*/\n/*\t\t\t    +===================+\t\t\t\t*/\n/*\t\t\t\t\t\t\t\t\t\t*/\n/*      Cree une connection entre 2 sockets en mode connecte\t\t\t*/\n/*\tProcedure reservee au client en mode connecte\t\t\t\t*/\n/*\t\t\t\t\t\t\t\t\t\t*/\n/* ENTREE\t\t\t\t\t\t\t\t\t*/\n/*\t\tnum_soc\t: \tNumero identifiant la socket\t\t\t*/\n/*\t\t\t\t\t\t\t\t\t\t*/\n/*              p_adr_serv :    adresses socket d'acces au service              */\n/*                                                                              */\n/* SORTIE\t\t\t\t\t\t\t\t\t*/\n/*\t     \taucune ( le rapport d'execution est envoye sur la console )\t*/\n/********************************************************************************/\n", "func_signal": "void\nh_connect (int num_soc, struct sockaddr_in *p_adr_serv)", "code": "{\n\n  int res;\t\t\t/* Entier resultat de l'operation       */\n\n#ifdef DEBUG\n  printf (\"\\n%sH_CONNECT (debut) -------------------\\n\", aff_debug);\n  printf (\"%ssocket : %d \\n\", aff_debug, num_soc);\n  printf (\"%sadresse IP serveur: %s \\n\", aff_debug,\n\t  inet_ntoa (p_adr_serv->sin_addr));\n  printf (\"%sport service : %d OK \\n\", aff_debug,\n\t  ntohs (p_adr_serv->sin_port));\n#endif\n\n  res = connect (num_soc, (struct sockaddr *) p_adr_serv,\n\t\t sizeof (struct sockaddr));\n  if (res < 0)\n    sortie_err\n      (\"\\nERREUR 'h_connect' : connexion serveur %s impossible\\n\",\n       inet_ntoa (p_adr_serv->sin_addr));\n\n#ifdef DEBUG\n  printf (\"%sH_CONNECT (fin) -------------------\\n\", aff_debug);\n#endif\n\n}", "path": "src\\reseau\\fon.c", "repo_name": "pcarrier/edu-projet_sys_res", "stars": 1, "license": "other", "language": "c", "size": 1536}
{"docstring": "/*\t\t\t    +===================+\t\t\t\t                */\n/*==============|  H_RECVFROM\t    |===============================*/\n/*\t\t\t    +===================+\t\t\t\t                */\n/* ENTREE\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t*/\n/*\t\tnum_soc\t: Numero identifiant la socket\t\t\t\t\t\t*/\n/*\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t*/\n/*\t\ttampon\t: Pointeur sur le tampon (buffer) de donnees.\t\t*/\n/*\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t*/\n/*\t\tnb_octets : Nombre d'octets du tampon.\t\t\t\t\t\t*/\n/*\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t*/\n/*\t\tp_adr_distant :\tPointeur sur les infos adresse interlocuteur. \t*/\n/*\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t*/\n/*\tSORTIE\tNombre d'octets effectivement recus\t\t\t\t\t\t*/\n/*\t     \t( le rapport d'execution est envoye sur la console )\t*/\n/********************************************************************************/\n", "func_signal": "int\nh_recvfrom (int num_soc, char *tampon, int nb_octets,\n\t    struct sockaddr_in *p_adr_distant)", "code": "{\n  int res;\t\t\t/* Entier resultat de l'operation       */\n  unsigned int taille;\n\n#ifdef DEBUG\n  printf (\"\\n%sH_RECVFROM (debut)\\n\", aff_debug);\n#endif\n\n  taille = sizeof (*p_adr_distant);\n  res = recvfrom (num_soc, tampon, nb_octets, 0,\n\t\t  (struct sockaddr *) p_adr_distant, &taille);\n  if (res < 0)\n    sortie_err\n      (\"\\nERREUR 'h_recvfrom' : reception socket %d impossible\\n\", num_soc);\n\n#ifdef DEBUG\n  printf (\"%sH_RECVFROM (fin)\\n\", aff_debug);\n#endif\n\n  return res;\n\n}", "path": "src\\reseau\\fon.c", "repo_name": "pcarrier/edu-projet_sys_res", "stars": 1, "license": "other", "language": "c", "size": 1536}
{"docstring": "/*----------------------------------------------------------*/\n/* interface_client : fonction qui g\u00e8re les requ\u00eates       */\n/*                    client en boucle                      */\n/*----------------------------------------------------------*/\n", "func_signal": "void interface_client ()", "code": "{\n\tint fin = 0;\n\t\n\tchar auteur[LongueurMaxNom]; /*  nom de l'auteur dont le livre est \u00e0 consulter/rendre */\n\tchar titre[LongueurMaxTitre];\t/*  titre du livre \u00e0 consulter/rendre */\n\t\n\twhile (!fin) {\n\t\tfprintf (stdout,\n\t\t\t\t \"===========================\\n\"\n\t\t\t\t \"  o - ouvrir une session\\n\"\n\t\t\t\t \"  t - consulter des livres (par titre)\\n\"\n\t\t\t\t \"  a - consulter des livres (par nom d'auteur)\\n\"\n\t\t\t\t \"  e - emprunter un livre\\n\"\n\t\t\t\t \"  r - rendre un livre\\n\"\n\t\t\t\t \"  f - fermer la session\\n\"\n\t\t\t\t \"  q - quitter le client\\n\" \"\\nCommande : \");\n\t\tswitch (lire_caractere ()) {\n\t\t\t\n\t\t\tcase 'o':\n\t\t\t\t /* A COMPLETER\n\t\t\t\t par la lecture des infos au clavier et \n\t\t\t\t par un appel vers une focntion impl\u00e9ment\u00e9e dans client.c\n\t\t\t\t qui traite la requete correspondante \n\t\t\t\t*/\n\t\t\t    break;\n\t\t\t\t\n\t\t    case 't':\n\t\t\t    fprintf (stdout, \"<-- Consulter les livres par titre -->\\n\");\n\t\t\t\tfprintf (stdout, \"Entrer un titre :\");\n\t\t\t\tlire_chaine(titre, LongueurMaxTitre);\n\t\t\t\t/* A COMPLETER\n\t\t\t\t par un appel vers une focntion impl\u00e9ment\u00e9e dans client.c\n\t\t\t\t qui traite la requete de consultation de livres par le titre \n\t\t\t\t*/\n\t\t\t    break;\n\t\t\t\n\t\t\tcase 'a':\n\t\t\t     /* A COMPLETER\n\t\t\t\t par la lecture des infos au clavier et \n\t\t\t\t par un appel vers une focntion impl\u00e9ment\u00e9e dans client.c\n\t\t\t\t qui traite la requete correspondante \n\t\t\t\t*/\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t    case 'e':\n\t\t\t\t /* A COMPLETER\n\t\t\t\t par la lecture des infos au clavier et \n\t\t\t\t par un appel vers une focntion impl\u00e9ment\u00e9e dans client.c\n\t\t\t\t qui traite la requete correspondante \n\t\t\t\t*/\n\t\t\t    break;\n\t\t\t\t\n\t\t    case 'r':\n\t\t\t /* A COMPLETER\n\t\t\t\t par la lecture des infos au clavier et \n\t\t\t\t par un appel vers une focntion impl\u00e9ment\u00e9e dans client.c\n\t\t\t\t qui traite la requete correspondante \n\t\t\t\t*/\t\t\t    break;\n\t\t    case 'f':\n\t\t\t    /* A COMPLETER\n\t\t\t\t par la lecture des infos au clavier et \n\t\t\t\t par un appel vers une focntion impl\u00e9ment\u00e9e dans client.c\n\t\t\t\t qui traite la requete correspondante \n\t\t\t\t*/\n\t\t\t    break;\n\t\t    case 'q':\n\t\t\t    fin = !0;\n\t\t\t    break;\n\t\t    default:\n\t\t\t    fprintf (stderr,\n\t\t\t\t\t\t \"*** erreur: commande inconnue\\n\");\n\t\t}\n\t}\n}", "path": "extern\\old\\gampouris\\interface_client.c", "repo_name": "pcarrier/edu-projet_sys_res", "stars": 1, "license": "other", "language": "c", "size": 1536}
{"docstring": "/*\t\t\t    +===================+\t\t\t\t*/\n/*==========================|\tH_WRITES\t|===============================*/\n/*\t\t\t    +===================+\t\t\t\t*/\n/*\t\t\t\t\t\t\t\t\t\t*/\n/*\tEcrit 'dans' une socket en mode connecte\t\t\t\t*/\n/*\t\t\t\t\t\t\t\t\t\t*/\n/* ENTREE\t\t\t\t\t\t\t\t\t*/\n/*\t\tnum_soc\t: Numero identifiant la socket \t\t\t\t*/\n/*\t\t\t\t\t\t\t\t\t\t*/\n/*\t\ttampon\t: Pointeur sur le tampon (buffer) de donnees.\t\t*/\n/*\t\t\t\t\t\t\t\t\t\t*/\n/*\t\tnb_octets : Nombre d'octets du tampon.\t\t\t\t*/\n/*\t\t\t\t\t\t\t\t\t\t*/\n/*\t\t\t\t\t\t\t\t\t\t*/\n/* SORTIE\tNombre d'octets effectivement ecrits ( 0 si fin de socket )\t*/\n/*\t     \t( le rapport d'execution est envoye sur la console )\t\t*/\n/********************************************************************************/\n", "func_signal": "int\nh_writes (int num_soc, char *tampon, int nb_octets)", "code": "{\n  int nb_restant, nb_ecrits;\t/* nb octets restant a ecrire, nb octets ecrits */\n\n#ifdef DEBUG\n  printf (\"\\n%sH_WRITES (debut) \t-------------------\\n\", aff_debug);\n#endif\n\n  nb_restant = nb_octets;\n  while (nb_restant > 0)\n    {\n      nb_ecrits = write (num_soc, tampon, nb_restant);\n\n      if (nb_ecrits < 0)\n\t{\n\t  sortie_err\n\t    (\"\\nERREUR 'Ecrire_mes' : ecriture socket %d impossible\\n\",\n\t     num_soc);\n\t  return (nb_ecrits);\n\t}\n\n      nb_restant = nb_restant - nb_ecrits;\n      tampon = tampon + nb_ecrits;\n    }\n\n#ifdef DEBUG\n  printf (\"%sH_WRITES (fin) \t-------------------\\n\", aff_debug);\n#endif\n\n  return (nb_octets - nb_restant);\n}", "path": "src\\reseau\\fon.c", "repo_name": "pcarrier/edu-projet_sys_res", "stars": 1, "license": "other", "language": "c", "size": 1536}
{"docstring": "/*------------------------------------------------------------------*/\n/* CLIENT\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t*/\n/*------------------------------------------------------------------*/\n", "func_signal": "char *client_init(int *argc, char **argv)", "code": "{\n\n\tprintf\n\t    (\"-------------------------------------------------------------------------------------------------\\n\");\n\tprintf\n\t    (\"Usage : client serveur(nom ou @IP) service (nom ou port)  protocole (tcp ou udp)\\n\");\n\tprintf\n\t    (\"Tous les arguments sont optionnels, si omis, des valeurs par d\u00e9faut sont utilis\u00e9s.\\n\");\n\tprintf\n\t    (\"-------------------------------------------------------------------------------------------------\\n\");\n\n\t/* Permet de passer un nombre de parametre variable a l'executable */\n\tswitch (*argc) {\n\tcase 1:\t\t/* arguments par defaut */\n\t\tbreak;\n\tcase 2:\t\t/* serveur renseigne  */\n\t\tstrcpy(serveur_courant, argv[1]);\n\t\tbreak;\n\tcase 3:\t\t/* serveur, service renseignes */\n\t\tstrcpy(serveur_courant, argv[1]);\n\t\tstrcpy(service_courant, argv[2]);\n\t\tbreak;\n\tcase 4:\t\t/* serveur, service, protocole renseignes */\n\t\tstrcpy(serveur_courant, argv[1]);\n\t\tstrcpy(service_courant, argv[2]);\n\t\tstrcpy(protocole_courant, argv[3]);\n\t\tbreak;\n\tdefault:\n\t\tprintf\n\t\t    (\"Usage:client serveur(nom ou @IP)  service (nom ou port)  protocole (tcp ou udp)\\n\");\n\t\texit(1);\n\t}\n\tprintf(\"Utilisation de serveur : %s\\n\", serveur_courant);\n\tprintf(\"Utilisation de service : %s\\n\", service_courant);\n\tprintf(\"Utilisation de protocole : %s\\n\\n\", protocole_courant);\n\n\treturn \"OK\";\n}", "path": "extern\\src\\client.c", "repo_name": "pcarrier/edu-projet_sys_res", "stars": 1, "license": "other", "language": "c", "size": 1536}
{"docstring": "/*\t\t\t    +===================+\t\t\t\t*/\n/*==========================| \tH_READS\t\t|===============================*/\n/*\t\t\t    +===================+\t\t\t\t*/\n/*\t\t\t\t\t\t\t\t\t\t*/\n/*\tlit les donnees d'une socket en mode connecte\t\t\t\t*/\n/*\t\t\t\t\t\t\t\t\t\t*/\n/* ENTREE\t\t\t\t\t\t\t\t\t*/\n/*\t\tnum_soc\t: Numero identifiant la socket \t\t\t\t*/\n/*\t\t\t\t\t\t\t\t\t\t*/\n/*\t\ttampon\t: Pointeur sur le tampon (buffer) de donnees.\t\t*/\n/*\t\t\t\t\t\t\t\t\t\t*/\n/*\t\tnb_octets : Nombre d'octets du tampon.\t\t\t\t*/\n/*\t\t\t\t\t\t\t\t\t\t*/\n/* SORTIE\tNombre d'octets effectivement lus ( 0 si fin de socket )\t*/\n/*\t     \t( le rapport d'execution est envoye sur la console )\t\t*/\n/********************************************************************************/\n", "func_signal": "int\nh_reads (int num_soc, char *tampon, int nb_octets)", "code": "{\n  int nb_restant, nb_lus;\n\n#ifdef DEBUG\n  printf (\"\\n%sH_READS (debut) \t-------------------\\n\", aff_debug);\n  printf (\"%sH_READS nb_octets : %d \\n\", aff_debug, nb_octets);\n#endif\n\n  nb_restant = nb_octets;\n  while (nb_restant > 0)\n    {\n      nb_lus = read (num_soc, tampon, nb_restant);\n\n#ifdef DEBUG\n      printf (\"%sH_READS apres read ..................\\n\", aff_debug);\n      printf (\"%sH_READS nb octets lus: %d \\n\", aff_debug, nb_lus);\n#endif\n\n      if (nb_lus < 0)\n\t{\n\t  sortie_err\n\t    (\"\\nERREUR 'Lire_mes' : lecture socket %d impossible\\n\", num_soc);\n\t  return (nb_lus);\n\t}\n\n      nb_restant = nb_restant - nb_lus;\n\n      /*if (nb_lus==0 || tampon[nb_lus]=='\\0') *//* fin transfert */\n      if (nb_lus == 0)\n\t{\n#ifdef DEBUG\n\t  printf (\"%sH_READS (fin) \t-------------------\\n\", aff_debug);\n#endif\n\t  return (nb_octets - nb_restant);\n\t}\n      tampon = tampon + nb_lus;\n\n    }\n\n#ifdef DEBUG\n  printf (\"%sH_READS (fin) \t-------------------\\n\", aff_debug);\n#endif\n\n  return (nb_octets - nb_restant);\n}", "path": "src\\reseau\\fon.c", "repo_name": "pcarrier/edu-projet_sys_res", "stars": 1, "license": "other", "language": "c", "size": 1536}
{"docstring": "/*---------------- programme serveur ------------------------------*/\n", "func_signal": "int main(int argc,char *argv[])", "code": "{\n\n\tchar *service= SERVICE_DEFAUT; /* numero de service par defaut */\n\tchar *protocole= PROTOCOLE_DEFAUT; /* protocole par defaut */\n\n\n\t/* Permet de passer un nombre de parametre variable a l'executable */\n\tswitch (argc)\n \t{\n   \tcase 1:\n\t\t  printf(\"defaut service = %s\\n\", service);\n\t\t  printf(\"defaut protocole = %s\\n\", protocole);\n\t\t  break;\n \tcase 2:\n\t\t  service=argv[1];\n\t\t  printf(\"defaut protocole = %s\\n\", protocole);\n\t\t  break;\n \tcase 3 :\n\t\t  service=argv[1];\n\t\t  protocole=argv[2];\n\t\t  break;\n\n   \tdefault :\n\t\t  printf(\"Usage:serveur service (nom ou port) protocole (TCP ou UDP)\\n\");\n\t\t  exit(1);\n \t}\n\n\t/* service est le service (ou numro de port) auquel sera affect\n\tce serveur*/\n\t/* protocole est le protocole qui sera utilis */\n\t\n\tserveur_appli(service, protocole);\n\treturn 0;\n}", "path": "extern\\doc\\ExemplesUDP\\serveur_UDP_iteratif.c", "repo_name": "pcarrier/edu-projet_sys_res", "stars": 1, "license": "other", "language": "c", "size": 1536}
{"docstring": "/*\t\t\t    +===================+\t\t\t\t*/\n/*==========================|  H_LISTEN  \t|===============================*/\n/*\t\t\t    +===================+\t\t\t\t*/\n/*\t\t\t\t\t\t\t\t\t\t*/\n/*\tMet la socket en 2tat d'attente de demandes de connections\t\t*/\n/*\tProcedure reservee au serveur en mode connecte\t\t\t\t*/\n/*\t\t\t\t\t\t\t\t\t\t*/\n/* ENTREE\t\t\t\t\t\t\t\t\t*/\n/*\tnum_soc\t: Numero identifiant la socket\t\t\t\t\t*/\n/*\t\t\t\t\t\t\t\t\t\t*/\n/*\tnb_req_att :\tNombre maximum de requetes dans la file d'attente \t*/\n/*\t\t\t\t\t\t\t\t\t\t*/\n/* SORTIE\t\t\t\t\t\t\t\t\t*/\n/*\taucune ( le rapport d'execution est envoye sur la console )\t\t*/\n/********************************************************************************/\n", "func_signal": "void\nh_listen (int num_soc, int nb_req_att)", "code": "{\n\n  int res;\t\t\t/* Entier resultat de l'operation       */\n\n#ifdef DEBUG\n  printf (\"\\n%sH_LISTEN (debut) -------------------\\n\", aff_debug);\n#endif\n\n  res = listen (num_soc, nb_req_att);\n  if (res < 0)\n    sortie_err\n      (\"\\nERREUR 'h_listen' : ecoute sur socket %d impossible \\n\", num_soc);\n\n#ifdef DEBUG\n  printf (\"%sH_LISTEN (fin)\\n\", aff_debug);\n#endif\n}", "path": "src\\reseau\\fon.c", "repo_name": "pcarrier/edu-projet_sys_res", "stars": 1, "license": "other", "language": "c", "size": 1536}
{"docstring": "/*\t\t\tAF_NS \t\t<-> protocoles Xerox NS \t\t*/\n/*\t\t\tAF_IMPLINK \t<-> protocoles IMP Link Layer\t \t*/\n/*\t\t\t\t\t\t\t\t\t\t*/\n/*\tmode\t: Mode de communication sur cette prise\t\t\t\t*/\n/*\t\t\tSOCK_STREAM\t<-> mode connecte ( TCP / AF_INET ) \t*/\n/*\t\t\t\t\t\tflots d'octets \t\t\t*/\n/*\t\t\tSOCK_DGRAM\t<-> mode non connecte ( UDP / AF_INET)\t*/\n/*\t\t\t\t\t\tdatagrammes \t\t\t*/\n/*\t\t\tSOCK_RAW\t<-> mode \"brut\" ( IP / AF_INET )\t*/\n/*\t\t\t\t\t\tprotocoles bas niveau\t\t*/\n/*\t\t\tSOCK_SEQPACET\t<-> mode sequence\t\t\t*/\n/*\t\t\t\t\t\t\t\t\t\t*/\n/*\ttype_protocole\t:  Type de protocole\t\t\t\t\t*/\n/*\t\t\t\tPour differencier eventuellement les protocoles\t*/\n/*\t\t\t\td'un meme mode. Classiquement inutile car a  \t*/\n/*\t\t\t\tchaque mode ne correspond qu'un seul protocole !*/\n/*\t\t\t\t\t\tINUTILE !!\t\t\t*/\n/*\t\t\t\t\t\t\t\t\t\t*/\n/* SORTIE\tNumero identificateur de la socket\t\t\t\t*/\n/*\t     \t( le rapport d'execution est envoye sur la console )\t\t*/\n/********************************************************************************/\n", "func_signal": "int\nh_socket (int domaine, int mode)", "code": "{\n  int res;\t\t\t/* Entier resultat de l'operation */\n  int sendbuff;\n\n#ifdef DEBUG\n  printf (\"\\n%s H_SOCKET (debut) -------------------\\n\", aff_debug);\n  printf (\"%s domaine : %d mode : %d \\n\", aff_debug, domaine, mode);\n#endif\n\n  if (domaine != AF_INET)\n    sortie_err (\" Sous internet utiliser -> AF_INET\\n\");\n  if ((mode != SOCK_STREAM) && (mode != SOCK_DGRAM))\n    sortie_err (\" Mode a choisir parmi : SOCK_STREAM, SOCK_DGRAM \\n\");\n\n  res = socket (domaine, mode, 0);\n\n  setsockopt (res, SOL_SOCKET, SO_REUSEADDR, (char *) &sendbuff,\n\t      sizeof (sendbuff));\n\n  if (res < 0)\n    sortie_err (\"\\nERREUR 'h_socket' : Creation socket impossible \\n\");\n#ifdef DEBUG\n  printf (\"%s H_SOCKET (fin) ----- socket %d cree ---\\n\", aff_debug, res);\n#endif\n  return res;\n}", "path": "src\\reseau\\fon.c", "repo_name": "pcarrier/edu-projet_sys_res", "stars": 1, "license": "other", "language": "c", "size": 1536}
{"docstring": "/*\t     \t\t    =================\t  \t\t\t      */\n/*==========================|\tSORTIE_ERR  |=================================*/\n/*\t\t\t    =================\t\t\t\t      */\n", "func_signal": "int\nsortie_err (char *format, ...)", "code": "{\n  va_list args;\n\n  va_start (args, format);\n  vfprintf (stderr, format, args);\t/* affich erreur */\n  va_end (args);\n  printf (\"\\n   Cause de l'erreur :  %s\\n\", strerror (errno));\n  /*if (errno == EACCES)\n     printf (\"numero de port protege\\n\");\n     if (errno == EADDRINUSE)\n     printf (\"numero de port deja utilise\\n\");\n     if (errno == EADDRNOTAVAIL)\n     printf (\"numero de port inexistant sur cette machine\\n\");\n     if (errno == EBADF)\n     printf (\"descripteur incorrect\\n\");\n     if (errno == EFAULT)\n     printf (\"nom incorrect\\n\");\n     if (errno == EINVAL)\n     printf (\"socket deja utilisee\\n\");\n     if (errno == EADDRNOTAVAIL)\n     printf (\"port innaccessible sur machine distante\\n\");\n     if (errno == ECONNREFUSED)\n     printf (\"demande de connection rejetee\\n\"); */\n\n  exit (1);\n  return (0);\n}", "path": "src\\reseau\\fon.c", "repo_name": "pcarrier/edu-projet_sys_res", "stars": 1, "license": "other", "language": "c", "size": 1536}
{"docstring": "/*\t\t\t    +===================+\t\t\t\t*/\n/*==========================| H_ACCEPT \t\t|===============================*/\n/*\t\t\t    +===================+\t\t\t\t*/\n/*\t\t\t\t\t\t\t\t\t\t*/\n/*\tAccepte une demande de connection (communication en mode connecte)\t*/\n/*\tProcedure reservee au serveur en mode connecte\t\t\t\t*/\n/*\t\t\t\t\t\t\t\t\t\t*/\n/* ENTREE\t\t\t\t\t\t\t\t\t*/\n/*\tnum_soc\t: Numero identifiant la socket du serveur\t\t\t*/\n/*\t\t\t\t\t\t\t\t\t\t*/\n/*\tp_adr_client\t: Pointeur sur les infos adresse client\t\t  \t*/\n/*\t\t\t\t\t\t\t\t\t\t*/\n/* SORTIE\tidentificateur de la nouvelle socket cree\t\t\t*/\n/*\t     \t( le rapport d'execution est envoye sur la console )\t\t*/\n/********************************************************************************/\n", "func_signal": "int\nh_accept (int num_soc, struct sockaddr_in *p_adr_client)", "code": "{\n\n  unsigned int longueur;\n  int res;\t\t\t/* Entier resultat de l'operation       */\n\n#ifdef DEBUG\n  printf (\"\\n%sH_ACCEPT (debut)\\n\", aff_debug);\n#endif\n\n  longueur = sizeof (struct sockaddr);\n  res = accept (num_soc, (struct sockaddr *) p_adr_client, &longueur);\n  if (res < 0)\n    sortie_err (\"\\nERREUR 'h_accept' : Acceptation impossible \\n\");\n\n#ifdef DEBUG\n  printf (\"%sH_ACCEPT (fin)\\n\", aff_debug);\n#endif\n\n  return res;\n\n}", "path": "src\\reseau\\fon.c", "repo_name": "pcarrier/edu-projet_sys_res", "stars": 1, "license": "other", "language": "c", "size": 1536}
{"docstring": "/*\t\t\t    +===================+\t\t\t\t*/\n/*==========================|\tH_CLOSE\t\t|===============================*/\n/*\t\t\t    +===================+\t\t\t\t*/\n/* ENTREE\t\t\t\t\t\t\t\t\t*/\n/*\tnum_soc\t: Numero identifiant la socket \t\t\t\t\t*/\n/*\t\t\t\t\t\t\t\t\t\t*/\n/* SORTIE\tAucune\t\t\t\t\t\t\t\t*/\n/*\t     \t( le rapport d'execution est envoye sur la console )\t\t*/\n/********************************************************************************/\n", "func_signal": "void\nh_close (int num_soc)", "code": "{\n  int res;\t\t\t/* Entier resultat de l'operation       */\n\n#ifdef DEBUG\n  printf (\"\\n%s H_CLOSE (debut)\\n\", aff_debug);\n#endif\n\n  res = close (num_soc);\n  if (res < 0)\n    sortie_err\n      (\"\\nERREUR 'h_close' : fermeture socket %d impossible\\n\", num_soc);\n\n#ifdef DEBUG\n  printf (\"%s H_CLOSE (fin)\\n\", aff_debug);\n#endif\n\n}", "path": "src\\reseau\\fon.c", "repo_name": "pcarrier/edu-projet_sys_res", "stars": 1, "license": "other", "language": "c", "size": 1536}
{"docstring": "/*\t\t\t    +===================+\t\t\t\t*/\n/*==========================|  \tH_SENDTO\t|===============================*/\n/*\t\t\t    +===================+\t\t\t\t*/\n/* ENTREE\t\t\t\t\t\t\t\t\t*/\n/*\t\tnum_soc\t: Numero identifiant la socket \t\t\t\t*/\n/*\t\t\t\t\t\t\t\t\t\t*/\n/*\t\ttampon\t: Pointeur sur le tampon (buffer) de donnees.\t\t*/\n/*\t\t\t\t\t\t\t\t\t\t*/\n/*\t\tnb_octets : Nombre d'octets du tampon.\t\t\t\t*/\n/*\t\t\t\t\t\t\t\t\t\t*/\n/*\t\tp_adr_distant :\tPointeur sur les infos adresse interlocuteur. \t*/\n/*\t\t\t\t\t\t\t\t\t\t*/\n/*\tSORTIE\tNombre d'octets effectivement emis \t\t\t\t*/\n/*\t     \t( le rapport d'execution est envoye sur la console )\t\t*/\n/********************************************************************************/\n", "func_signal": "int\nh_sendto (int num_soc,\n\t  char *tampon, int nb_octets, struct sockaddr_in *p_adr_distant)", "code": "{\n\n  int res;\t\t\t/* Entier resultat de l'operation       */\n\n#ifdef DEBUG\n  printf (\"\\n%sH_SENDTO (debut)\\n\", aff_debug);\n#endif\n\n  res = sendto (num_soc, tampon, nb_octets, 0,\n\t\t(struct sockaddr *) p_adr_distant, sizeof (*p_adr_distant));\n  if (res < 0)\n    {\n      sortie_err\n\t(\"\\nERREUR 'h_sendto' : emission socket %d impossible\\n\", num_soc);\n    }\n#ifdef DEBUG\n  printf (\"%sH_SENDTO (fin)\\n\", aff_debug);\n#endif\n\n  return res;\n\n}", "path": "src\\reseau\\fon.c", "repo_name": "pcarrier/edu-projet_sys_res", "stars": 1, "license": "other", "language": "c", "size": 1536}
{"docstring": "/*\t\t\t    +===================+\t\t\t\t*/\n/*\t\t\t\t\t\t\t\t\t\t*/\n/*  Associe une socket (numero de socket) et ses adresses (@IP, port)\t\t*/\n/*\t\t\t\t\t\t\t\t\t\t*/\n/*  En mode connecte ( TCP ) \t\t\t\t\t\t\t*/\n/*  Procedure reservee au serveur ( le socket client sera automatiquement lie \t*/\n/*   lors de l'appel a h_connect c.a.d. connect )\t\t\t\t*/\n/*\t\t\t\t\t\t\t\t\t\t*/\n/*  En mode non connecte ( UDP ) \t\t\t\t\t\t*/\n/*  Procedure utilisee par le serveur, et par le client s'il envisage ensuite \t*/\n/*\tde converser avec les procedures read et write ( comme en connecte )\t*/\n/*\t\t\t\t\t\t\t\t\t\t*/\n/* ENTREE\t\t\t\t\t\t\t\t\t*/\n/*\tnum_soc\t: \tNumero identifiant la socket\t\t\t\t*/\n/*\t\t\t\t\t\t\t\t\t\t*/\n/*\tp_adr_socket :\tpointeur sur les adresses socket\t\t\t*/\n/*\t\t\t\t\t\t\t\t\t\t*/\n/* SORTIE\t\t\t\t\t\t\t\t  \t*/\n/*\t     \taucune ( le rapport d'execution est envoye sur la console )\t*/\n/********************************************************************************/\n", "func_signal": "void\nh_bind (int num_soc, struct sockaddr_in *p_adr_socket)", "code": "{\n\n  int res;\t\t\t/* Entier resultat de l'operation       */\n#ifdef DEBUG\n  struct sockaddr_in s;\n  unsigned int lensa;\n\n  printf (\"\\n%sH_BIND (debut)\\n\", aff_debug);\n  printf (\"%ssocket : %d \\n\", aff_debug, num_soc);\n  printf (\"%sadresse IP : %s \\n\", aff_debug,\n\t  inet_ntoa (p_adr_socket->sin_addr));\n  printf (\"%sport : %d OK \\n\", aff_debug, ntohs (p_adr_socket->sin_port));\n#endif\n\n  res = bind (num_soc, (struct sockaddr *) p_adr_socket, sizeof (struct sockaddr_in));\t/* Modif PS */\n\n#ifdef DEBUG\n  /*bzero (&s,sizeof(s)); */\n  lensa = sizeof (struct sockaddr_in);\n  if (!getsockname (num_soc, (struct sockaddr *) &s, &lensa))\n    {\n      printf (\"%sport apres le bind: %d OK \\n\", aff_debug,\n\t      ntohs (s.sin_port));\n    }\n  else\n    printf (\"Probleme getsockname\\n\");\n#endif\n\n  if (res < 0)\n    sortie_err\n      (\"\\nERREUR 'h_bind' : liaison socket %d impossible\\n\", num_soc);\n\n#ifdef DEBUG\n  printf (\"%sH_BIND (fin)  \\n\", aff_debug);\n#endif\n}", "path": "src\\reseau\\fon.c", "repo_name": "pcarrier/edu-projet_sys_res", "stars": 1, "license": "other", "language": "c", "size": 1536}
{"docstring": "/*------------------------------------------------------------------*/\n/* CLIENT\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t*/\n/*------------------------------------------------------------------*/\n", "func_signal": "char* client_init(int* argc, char** argv)", "code": "{\n\t\n\tprintf (\"-------------------------------------------------------------------------------------------------\\n\");\n\tprintf (\"Usage : client serveur(nom ou @IP) service (nom ou port)  protocole (tcp ou udp)\\n\");\n\tprintf (\"Tous les arguments sont optionnels, si omis, des valeurs par d\u00e9faut sont utilis\u00e9s.\\n\");\n\tprintf (\"-------------------------------------------------------------------------------------------------\\n\");\n\t\n\t\n\t/* Permet de passer un nombre de parametre variable a l'executable */\n\tswitch (*argc)\n\t{\n\t\tcase 1:\t\t/* arguments par defaut */\n\t\t\tbreak;\n\t\tcase 2:\t\t/* serveur renseigne  */\n\t\t\tstrcpy(serveur_courant, argv[1]);\n\t\t\tbreak;\n\t\tcase 3:\t\t/* serveur, service renseignes */\n\t\t\tstrcpy(serveur_courant, argv[1]);\n\t\t\tstrcpy(service_courant,argv[2]);\n\t\t\tbreak;\n\t\tcase 4:\t\t/* serveur, service, protocole renseignes */\n\t\t\tstrcpy(serveur_courant, argv[1]);\n\t\t\tstrcpy(service_courant, argv[2]);\n\t\t\tstrcpy(protocole_courant, argv[3]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf (\"Usage:client serveur(nom ou @IP)  service (nom ou port)  protocole (tcp ou udp)\\n\");\n\t\t\texit (1);\n\t}\n\t\tprintf (\"Utilisation de serveur : %s\\n\", serveur_courant);\n\t\tprintf (\"Utilisation de service : %s\\n\", service_courant);\n\t\tprintf (\"Utilisation de protocole : %s\\n\\n\", protocole_courant);\n\t\n\treturn \"OK\";\n}", "path": "extern\\old\\gampouris\\client.c", "repo_name": "pcarrier/edu-projet_sys_res", "stars": 1, "license": "other", "language": "c", "size": 1536}
{"docstring": "/* ENTREE\t\t\t\t\t\t\t\t\t*/\n/*\tnum_soc\t: Numero identifiant la socket \t\t\t\t\t*/\n/*\tsens\t: sens de fermeture (FIN_RECEPTION, FIN_EMISSION, FIN_ECHANGES)\n*/\n/*\t\t\t\t\t\t\t\t\t\t*/\n/* SORTIE\tAucune\t\t\t\t\t\t\t\t*/\n/*\t     \t( le rapport d'execution est envoye sur la console )\t\t*/\n/********************************************************************************/\n", "func_signal": "void\nh_shutdown (int num_soc, int sens)", "code": "{\n  int res;\t\t\t/* Entier resultat de l'operation       */\n\n#ifdef DEBUG\n  printf (\"\\n%s H_SHUTDOWN (debut)\\n\", aff_debug);\n#endif\n\n  res = shutdown (num_soc, sens);\n  if (res < 0)\n    sortie_err\n      (\"\\nERREUR 'h_shutdown' : fermeture socket %d impossible\\n\", num_soc);\n\n#ifdef DEBUG\n  printf (\"%s H_SHUTDOWN (fin)\\n\", aff_debug);\n#endif\n\n}", "path": "src\\reseau\\fon.c", "repo_name": "pcarrier/edu-projet_sys_res", "stars": 1, "license": "other", "language": "c", "size": 1536}
{"docstring": "/* Get rid of all of the variables in the current context. */\n", "func_signal": "void\nkill_all_local_variables ()", "code": "{\n  VAR_CONTEXT *vc;\n\n  for (vc = shell_variables; vc; vc = vc->down)\n    if (vc_isfuncenv (vc) && vc->scope == variable_context)\n      break;\n  if (vc == 0)\n    return;\t\t/* XXX */\n\n  if (vc->table && vc_haslocals (vc))\n    {\n      delete_all_variables (vc->table);\n      hash_dispose (vc->table);\n    }\n  vc->table = (HASH_TABLE *)NULL;\n}", "path": "variables.c", "repo_name": "endu/bash-4", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 5736}
{"docstring": "/* Pop the top context off of VCXT and dispose of it, returning the rest of\n   the stack. */\n", "func_signal": "void\npop_var_context ()", "code": "{\n  VAR_CONTEXT *ret, *vcxt;\n\n  vcxt = shell_variables;\n  if (vc_isfuncenv (vcxt) == 0)\n    {\n      internal_error (_(\"pop_var_context: head of shell_variables not a function context\"));\n      return;\n    }\n\n  if (ret = vcxt->down)\n    {\n      ret->up = (VAR_CONTEXT *)NULL;\n      shell_variables = ret;\n      if (vcxt->table)\n\thash_flush (vcxt->table, push_func_var);\n      dispose_var_context (vcxt);\n    }\n  else\n    internal_error (_(\"pop_var_context: no global_variables context\"));\n}", "path": "variables.c", "repo_name": "endu/bash-4", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 5736}
{"docstring": "/* Make the environment array for the command about to be executed, if the\n   array needs making.  Otherwise, do nothing.  If a shell action could\n   change the array that commands receive for their environment, then the\n   code should `array_needs_making++'.\n\n   The order to add to the array is:\n   \ttemporary_env\n   \tlist of var contexts whose head is shell_variables\n  \tshell_functions\n\n  This is the shell variable lookup order.  We add only new variable\n  names at each step, which allows local variables and variables in\n  the temporary environments to shadow variables in the global (or\n  any previous) scope.\n*/\n", "func_signal": "static int\nn_shell_variables ()", "code": "{\n  VAR_CONTEXT *vc;\n  int n;\n\n  for (n = 0, vc = shell_variables; vc; vc = vc->down)\n    n += HASH_ENTRIES (vc->table);\n  return n;\n}", "path": "variables.c", "repo_name": "endu/bash-4", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 5736}
{"docstring": "/* Give version information about this shell. */\n", "func_signal": "char *\nshell_version_string ()", "code": "{\n  static char tt[32] = { '\\0' };\n\n  if (tt[0] == '\\0')\n    {\n      if (release_status)\n#if defined (HAVE_SNPRINTF)\n\tsnprintf (tt, sizeof (tt), \"%s.%d(%d)-%s\", dist_version, patch_level, build_version, release_status);\n#else\n\tsprintf (tt, \"%s.%d(%d)-%s\", dist_version, patch_level, build_version, release_status);\n#endif\n      else\n#if defined (HAVE_SNPRINTF)\n\tsnprintf (tt, sizeof (tt), \"%s.%d(%d)\", dist_version, patch_level, build_version);\n#else\n\tsprintf (tt, \"%s.%d(%d)\", dist_version, patch_level, build_version);\n#endif\n    }\n  return tt;\n}", "path": "version.c", "repo_name": "endu/bash-4", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 5736}
{"docstring": "/* Take all of the shell variables in the temporary environment HASH_TABLE\n   and make shell variables from them at the current variable context. */\n", "func_signal": "void\nmerge_temporary_env ()", "code": "{\n  if (temporary_env)\n    dispose_temporary_env (push_temp_var);\n}", "path": "variables.c", "repo_name": "endu/bash-4", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 5736}
{"docstring": "/* **************************************************************** */\n/*\t\t\t\t\t\t\t\t    */\n/*\t     Setting values for special shell variables\t\t    */\n/*\t\t\t\t\t\t\t\t    */\n/* **************************************************************** */\n", "func_signal": "static void\nset_machine_vars ()", "code": "{\n  SHELL_VAR *temp_var;\n\n  temp_var = set_if_not (\"HOSTTYPE\", HOSTTYPE);\n  temp_var = set_if_not (\"OSTYPE\", OSTYPE);\n  temp_var = set_if_not (\"MACHTYPE\", MACHTYPE);\n\n  temp_var = set_if_not (\"HOSTNAME\", current_host_name);\n}", "path": "variables.c", "repo_name": "endu/bash-4", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 5736}
{"docstring": "/*\n * or:\n *\tand\n *\tand '-o' or\n */\n", "func_signal": "static int\nor ()", "code": "{\n  int value, v2;\n\n  value = and ();\n  if (pos < argc && argv[pos][0] == '-' && argv[pos][1] == 'o' && !argv[pos][2])\n    {\n      advance (0);\n      v2 = or ();\n      return (value || v2);\n    }\n\n  return (value);\n}", "path": "test.c", "repo_name": "endu/bash-4", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 5736}
{"docstring": "/* Returns a pseudo-random number between 0 and 32767. */\n", "func_signal": "static int\nbrand ()", "code": "{\n#if 0\n  rseed = rseed * 1103515245 + 12345;\n  return ((unsigned int)((rseed >> 16) & 32767));\t/* was % 32768 */\n#else\n  /* From \"Random number generators: good ones are hard to find\",\n     Park and Miller, Communications of the ACM, vol. 31, no. 10,\n     October 1988, p. 1195. filtered through FreeBSD */\n  long h, l;\n\n  if (rseed == 0)\n    seedrand ();\n  h = rseed / 127773;\n  l = rseed % 127773;\n  rseed = 16807 * l - 2836 * h;\n#if 0\n  if (rseed < 0)\n    rseed += 0x7fffffff;\n#endif\n  return ((unsigned int)(rseed & 32767));\t/* was % 32768 */\n#endif\n}", "path": "variables.c", "repo_name": "endu/bash-4", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 5736}
{"docstring": "/* Only called when subshell == 0, so we don't need to check, and can\n   unconditionally pop the dollar vars off the stack. */\n", "func_signal": "void\npop_context ()", "code": "{\n  pop_dollar_vars ();\n  variable_context--;\n  pop_var_context ();\n\n  sv_ifs (\"IFS\");\t\t/* XXX here for now */\n}", "path": "variables.c", "repo_name": "endu/bash-4", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 5736}
{"docstring": "/* Special variables that need hooks to be run when they are unset as part\n   of shell reinitialization should have their sv_ functions run here. */\n", "func_signal": "void\nreinit_special_variables ()", "code": "{\n#if defined (READLINE)\n  sv_comp_wordbreaks (\"COMP_WORDBREAKS\");\n#endif\n  sv_globignore (\"GLOBIGNORE\");\n  sv_opterr (\"OPTERR\");\n}", "path": "variables.c", "repo_name": "endu/bash-4", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 5736}
{"docstring": "/* This function is not static so the tilde and readline libraries can\n   use it. */\n", "func_signal": "char *\nsh_get_home_dir ()", "code": "{\n  if (current_user.home_dir == 0)\n    get_current_user_info ();\n  return current_user.home_dir;\n}", "path": "variables.c", "repo_name": "endu/bash-4", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 5736}
{"docstring": "/*\n * term - parse a term and return 1 or 0 depending on whether the term\n *\tevaluates to true or false, respectively.\n *\n * term ::=\n *\t'-'('a'|'b'|'c'|'d'|'e'|'f'|'g'|'h'|'k'|'p'|'r'|'s'|'u'|'w'|'x') filename\n *\t'-'('G'|'L'|'O'|'S'|'N') filename\n * \t'-t' [int]\n *\t'-'('z'|'n') string\n *\t'-o' option\n *\tstring\n *\tstring ('!='|'='|'==') string\n *\t<int> '-'(eq|ne|le|lt|ge|gt) <int>\n *\tfile '-'(nt|ot|ef) file\n *\t'(' <expr> ')'\n * int ::=\n *\tpositive and negative integers\n */\n", "func_signal": "static int\nterm ()", "code": "{\n  int value;\n\n  if (pos >= argc)\n    beyond ();\n\n  /* Deal with leading `not's. */\n  if (argv[pos][0] == '!' && argv[pos][1] == '\\0')\n    {\n      value = 0;\n      while (pos < argc && argv[pos][0] == '!' && argv[pos][1] == '\\0')\n\t{\n\t  advance (1);\n\t  value = 1 - value;\n\t}\n\n      return (value ? !term() : term());\n    }\n\n  /* A paren-bracketed argument. */\n  if (argv[pos][0] == '(' && argv[pos][1] == '\\0') /* ) */\n    {\n      advance (1);\n      value = expr ();\n      if (argv[pos] == 0) /* ( */\n\ttest_syntax_error (_(\"`)' expected\"), (char *)NULL);\n      else if (argv[pos][0] != ')' || argv[pos][1]) /* ( */\n\ttest_syntax_error (_(\"`)' expected, found %s\"), argv[pos]);\n      advance (0);\n      return (value);\n    }\n\n  /* are there enough arguments left that this could be dyadic? */\n  if ((pos + 3 <= argc) && test_binop (argv[pos + 1]))\n    value = binary_operator ();\n\n  /* Might be a switch type argument */\n  else if (argv[pos][0] == '-' && argv[pos][2] == '\\0')\n    {\n      if (test_unop (argv[pos]))\n\tvalue = unary_operator ();\n      else\n\ttest_syntax_error (_(\"%s: unary operator expected\"), argv[pos]);\n    }\n  else\n    {\n      value = argv[pos][0] != '\\0';\n      advance (0);\n    }\n\n  return (value);\n}", "path": "test.c", "repo_name": "endu/bash-4", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 5736}
{"docstring": "/*\n * and:\n *\tterm\n *\tterm '-a' and\n */\n", "func_signal": "static int\nand ()", "code": "{\n  int value, v2;\n\n  value = term ();\n  if (pos < argc && argv[pos][0] == '-' && argv[pos][1] == 'a' && !argv[pos][2])\n    {\n      advance (0);\n      v2 = and ();\n      return (value && v2);\n    }\n  return (value);\n}", "path": "test.c", "repo_name": "endu/bash-4", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 5736}
{"docstring": "/* Restore the positional parameters from our stack. */\n", "func_signal": "void\npop_dollar_vars ()", "code": "{\n  if (!dollar_arg_stack || dollar_arg_stack_index == 0)\n    return;\n\n  remember_args (dollar_arg_stack[--dollar_arg_stack_index], 1);\n  dispose_words (dollar_arg_stack[dollar_arg_stack_index]);\n  dollar_arg_stack[dollar_arg_stack_index] = (WORD_LIST *)NULL;\n  set_dollar_vars_unchanged ();\n}", "path": "variables.c", "repo_name": "endu/bash-4", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 5736}
{"docstring": "/* Make a variable $PPID, which holds the pid of the shell's parent.  */\n", "func_signal": "void\nset_ppid ()", "code": "{\n  char namebuf[INT_STRLEN_BOUND(pid_t) + 1], *name;\n  SHELL_VAR *temp_var;\n\n  name = inttostr (getppid (), namebuf, sizeof(namebuf));\n  temp_var = find_variable (\"PPID\");\n  if (temp_var)\n    VUNSETATTR (temp_var, (att_readonly | att_exported));\n  temp_var = bind_variable (\"PPID\", name, 0);\n  VSETATTR (temp_var, (att_readonly | att_integer));\n}", "path": "variables.c", "repo_name": "endu/bash-4", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 5736}
{"docstring": "/* This is an implementation of a Posix.2 proposal by David Korn. */\n", "func_signal": "static int\nposixtest ()", "code": "{\n  int value;\n\n  switch (argc - 1)\t/* one extra passed in */\n    {\n      case 0:\n\tvalue = FALSE;\n\tpos = argc;\n\tbreak;\n\n      case 1:\n\tvalue = ONE_ARG_TEST(argv[1]);\n\tpos = argc;\n\tbreak;\n\n      case 2:\n\tvalue = two_arguments ();\n\tpos = argc;\n\tbreak;\n\n      case 3:\n\tvalue = three_arguments ();\n\tbreak;\n\n      case 4:\n\tif (argv[pos][0] == '!' && argv[pos][1] == '\\0')\n\t  {\n\t    advance (1);\n\t    value = !three_arguments ();\n\t    break;\n\t  }\n\t/* FALLTHROUGH */\n      default:\n\tvalue = expr ();\n    }\n\n  return (value);\n}", "path": "test.c", "repo_name": "endu/bash-4", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 5736}
{"docstring": "/* Remove arguments from BASH_ARGV array.  Pop top element off BASH_ARGC\n   array and use that value as the count of elements to remove from\n   BASH_ARGV. */\n", "func_signal": "void\npop_args ()", "code": "{\n#if defined (ARRAY_VARS) && defined (DEBUGGER)\n  SHELL_VAR *bash_argv_v, *bash_argc_v;\n  ARRAY *bash_argv_a, *bash_argc_a;\n  ARRAY_ELEMENT *ce;\n  intmax_t i;\n\n  GET_ARRAY_FROM_VAR (\"BASH_ARGV\", bash_argv_v, bash_argv_a);\n  GET_ARRAY_FROM_VAR (\"BASH_ARGC\", bash_argc_v, bash_argc_a);\n\n  ce = array_shift (bash_argc_a, 1, 0);\n  if (ce == 0 || legal_number (element_value (ce), &i) == 0)\n    i = 0;\n\n  for ( ; i > 0; i--)\n    array_pop (bash_argv_a);\n  array_dispose_element (ce);\n#endif /* ARRAY_VARS && DEBUGGER */\n}", "path": "variables.c", "repo_name": "endu/bash-4", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 5736}
{"docstring": "/* Save the existing positional parameters on a stack. */\n", "func_signal": "void\npush_dollar_vars ()", "code": "{\n  if (dollar_arg_stack_index + 2 > dollar_arg_stack_slots)\n    {\n      dollar_arg_stack = (WORD_LIST **)\n\txrealloc (dollar_arg_stack, (dollar_arg_stack_slots += 10)\n\t\t  * sizeof (WORD_LIST **));\n    }\n  dollar_arg_stack[dollar_arg_stack_index++] = list_rest_of_args ();\n  dollar_arg_stack[dollar_arg_stack_index] = (WORD_LIST *)NULL;\n}", "path": "variables.c", "repo_name": "endu/bash-4", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 5736}
{"docstring": "/* If we got PWD from the environment, update our idea of the current\n   working directory.  In any case, make sure that PWD exists before\n   checking it.  It is possible for getcwd () to fail on shell startup,\n   and in that case, PWD would be undefined.  If this is an interactive\n   login shell, see if $HOME is the current working directory, and if\n   that's not the same string as $PWD, set PWD=$HOME. */\n", "func_signal": "void\nset_pwd ()", "code": "{\n  SHELL_VAR *temp_var, *home_var;\n  char *temp_string, *home_string;\n\n  home_var = find_variable (\"HOME\");\n  home_string = home_var ? value_cell (home_var) : (char *)NULL;\n\n  temp_var = find_variable (\"PWD\");\n  if (temp_var && imported_p (temp_var) &&\n      (temp_string = value_cell (temp_var)) &&\n      same_file (temp_string, \".\", (struct stat *)NULL, (struct stat *)NULL))\n    set_working_directory (temp_string);\n  else if (home_string && interactive_shell && login_shell &&\n\t   same_file (home_string, \".\", (struct stat *)NULL, (struct stat *)NULL))\n    {\n      set_working_directory (home_string);\n      temp_var = bind_variable (\"PWD\", home_string, 0);\n      set_auto_export (temp_var);\n    }\n  else\n    {\n      temp_string = get_working_directory (\"shell-init\");\n      if (temp_string)\n\t{\n\t  temp_var = bind_variable (\"PWD\", temp_string, 0);\n\t  set_auto_export (temp_var);\n\t  free (temp_string);\n\t}\n    }\n\n  /* According to the Single Unix Specification, v2, $OLDPWD is an\n     `environment variable' and therefore should be auto-exported.\n     Make a dummy invisible variable for OLDPWD, and mark it as exported. */\n  temp_var = bind_variable (\"OLDPWD\", (char *)NULL, 0);\n  VSETATTR (temp_var, (att_exported | att_invisible));\n}", "path": "variables.c", "repo_name": "endu/bash-4", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 5736}
{"docstring": "/* Set $SHELL to the user's login shell if it is not already set.  Call\n   get_current_user_info if we haven't already fetched the shell. */\n", "func_signal": "static void\nset_shell_var ()", "code": "{\n  SHELL_VAR *temp_var;\n\n  temp_var = find_variable (\"SHELL\");\n  if (temp_var == 0)\n    {\n      if (current_user.shell == 0)\n\tget_current_user_info ();\n      temp_var = bind_variable (\"SHELL\", current_user.shell, 0);\n    }\n#if 0\n  VSETATTR (temp_var, att_exported);\n#endif\n}", "path": "variables.c", "repo_name": "endu/bash-4", "stars": 1, "license": "gpl-3.0", "language": "c", "size": 5736}
{"docstring": "/* st_del() del the xnet_site site_id relationship from the site table\n */\n", "func_signal": "int st_del(struct site_table *st, u64 site_id)", "code": "{\n    if (st->site[site_id]) {\n        xfree(st->site[site_id]);\n        st->site[site_id] = NULL;\n    } else {\n        hvfs_err(xnet, \"Trying to del a non-exist site_id(%ld).\\n\", site_id);\n        return -ENOTEXIST;\n    }\n    return 0;\n}", "path": "xnet\\xnet_simple.c", "repo_name": "macan/hvfs", "stars": 1, "license": "None", "language": "c", "size": 308}
{"docstring": "/* # of shadow lookup miss */\n", "func_signal": "void hmr_print(struct hvfs_md_reply *hmr)", "code": "{\n    struct hvfs_index *hi;\n    struct mdu *m;\n    struct link_source *ls;\n    void *p = hmr->data;\n\n    hvfs_info(mds, \"hmr-> err %d, mdu_no %d, len %d, flag 0x%x.\\n\", \n              hmr->err, hmr->mdu_no, hmr->len, hmr->flag);\n    if (!p)\n        return;\n    hi = (struct hvfs_index *)p;\n    hvfs_info(mds, \"hmr-> HI: len %d, flag 0x%x, uuid %ld, hash %ld, itbid %ld, \"\n              \"puuid %ld, psalt %ld\\n\", hi->namelen, hi->flag, hi->uuid, hi->hash,\n              hi->itbid, hi->puuid, hi->psalt);\n    p += sizeof(struct hvfs_index);\n    if (hmr->flag & MD_REPLY_WITH_MDU) {\n        m = (struct mdu *)p;\n        hvfs_info(mds, \"hmr->MDU: size %ld, dev %ld, mode 0x%x, nlink %d, uid %d, \"\n                  \"gid %d, flags 0x%x, atime %lx, ctime %lx, mtime %lx, dtime %lx, \"\n                  \"version %d\\n\", m->size, m->dev, m->mode, m->nlink, m->uid,\n                  m->gid, m->flags, m->atime, m->ctime, m->mtime, m->dtime,\n                  m->version);\n        p += sizeof(struct mdu);\n    }\n    if (hmr->flag & MD_REPLY_WITH_LS) {\n        ls = (struct link_source *)p;\n        hvfs_info(mds, \"hmr-> LS: hash %ld, puuid %ld, uuid %ld\\n\",\n                  ls->s_hash, ls->s_puuid, ls->s_uuid);\n        p += sizeof(struct link_source);\n    }\n    if (hmr->flag & MD_REPLY_WITH_BITMAP) {\n        hvfs_info(mds, \"hmr-> BM: ...\\n\");\n    }\n}", "path": "test\\mds\\cbht.c", "repo_name": "macan/hvfs", "stars": 1, "license": "None", "language": "c", "size": 308}
{"docstring": "/* mds_dh_remove()\n */\n", "func_signal": "int mds_dh_remove(struct dh *dh, u64 uuid)", "code": "{\n    struct regular_hash *rh;\n    struct dhe *e;\n    struct hlist_node *pos, *n;\n    int i;\n\n    i = mds_dh_hash(uuid);\n    rh = dh->ht + i;\n\n    xlock_lock(&rh->lock);\n    hlist_for_each_entry_safe(e, pos, n, &rh->h, hlist) {\n        if (e->uuid == uuid) {\n            hlist_del(&e->hlist);\n            hvfs_debug(mds, \"Remove dir:%8lld in DH w/  %p\\n\", uuid, e);\n            xfree(e);\n        }\n    }\n    xlock_unlock(&rh->lock);\n\n    return 0;\n}", "path": "mds\\dh.c", "repo_name": "macan/hvfs", "stars": 1, "license": "None", "language": "c", "size": 308}
{"docstring": "/* st_update_sockfd() update the related addr with the new connected fd\n */\n", "func_signal": "int st_update_sockfd(struct site_table *st, struct sockaddr_in *sin, int fd)", "code": "{\n    struct xnet_addr *xa;\n    int i;\n\n    for (i = 0; i < (1 << 20); i++) {\n        if (st->site[i]) {\n            if (st->site[i]->flag & XNET_SITE_LOCAL)\n                continue;\n            list_for_each_entry(xa, &st->site[i]->addr, list) {\n                if ((((struct sockaddr_in *)&xa->sa)->sin_addr.s_addr == \n                     sin->sin_addr.s_addr)) {\n                    /* ok, find it */\n                    hvfs_debug(xnet, \"Hoo, find it @ %d <- %d.\\n\", i, fd);\n                    xa->sockfd = fd;\n                    ((struct sockaddr_in *)&xa->sa)->sin_port = sin->sin_port;\n                }\n            }\n        }\n    }\n\n    return 0;\n}", "path": "xnet\\xnet_simple.c", "repo_name": "macan/hvfs", "stars": 1, "license": "None", "language": "c", "size": 308}
{"docstring": "/* st_lookup() return the struct xnet_site pointer\n */\n", "func_signal": "int st_lookup(struct site_table *st, struct xnet_site **xs, u64 site_id)", "code": "{\n    *xs = st->site[site_id];\n    if (!(*xs)) {\n        hvfs_debug(xnet, \"The site_id(%ld) is not mapped.\\n\", site_id);\n    }\n    return 0;\n}", "path": "xnet\\xnet_simple.c", "repo_name": "macan/hvfs", "stars": 1, "license": "None", "language": "c", "size": 308}
{"docstring": "/* mds_dh_load()\n *\n * NOTE: load the directory info from the GDT server\n *\n * Error Conversion: kernel err-ptr\n */\n", "func_signal": "struct dhe *mds_dh_load(struct dh *dh, u64 duuid)", "code": "{\n    struct hvfs_md_reply *hmr;\n    struct hvfs_index thi, *rhi;\n    struct xnet_msg *msg;\n    struct chp *p;\n    struct dhe *e = ERR_PTR(-ENOTEXIST);\n    int err = 0, no;\n\n    msg = xnet_alloc_msg(XNET_MSG_CACHE);\n    if (!msg) {\n        /* retry with slow method */\n        msg = xnet_alloc_msg(XNET_MSG_NORMAL);\n        if (!msg) {\n            hvfs_debug(mds, \"xnet_alloc_msg() in low memory.\\n\");\n            return ERR_PTR(-ENOMEM);\n        }\n    }\n\n    /* check if we are loading the GDT DH */\n    if (unlikely(duuid == hmi.gdt_uuid)) {\n        /* ok, we should send the request to the ROOT server */\n        \n        goto send_msg;\n    }\n\n    /* prepare the hvfs_index */\n    memset(&thi, 0, sizeof(thi));\n    thi.flag = INDEX_BY_UUID;\n    thi.uuid = duuid;\n    thi.hash = hvfs_hash(duuid, 0, 0, HASH_SEL_GDT);\n\n    e = mds_dh_search(dh, hmi.gdt_uuid);\n    if (IS_ERR(e)) {\n        hvfs_err(mds, \"Hoo, we can NOT find the GDT uuid %lld(%lld).\\n\",\n                 hmi.gdt_uuid, duuid);\n        hvfs_err(mds, \"This is a fatal error %ld! We must die.\\n\", \n                 PTR_ERR(e));\n        ASSERT(0, mds);\n    }\n    thi.itbid = mds_get_itbid(e, thi.hash);\n\n    /* find the MDS server */\n    p = ring_get_point(thi.itbid, hmi.gdt_salt, hmo.chring[CH_RING_MDS]);\n    if (IS_ERR(p)) {\n        hvfs_err(mds, \"ring_get_point(%lld) failed with %ld\\n\", \n                 thi.itbid, PTR_ERR(p));\n        e = ERR_PTR(-ECHP);\n        goto out_free;\n    }\n    /* prepare the msg */\n    xnet_msg_set_site(msg, p->site_id);\n    xnet_msg_fill_cmd(msg, HVFS_MDS2MDS_LD, duuid, 0);\n    xnet_msg_add_sdata(msg, &thi, sizeof(thi));\n\nsend_msg:\n    err = xnet_send(hmo.xc, msg);\n    if (err) {\n        hvfs_err(mds, \"xnet_send() failed with %d\\n\", err);\n        e = ERR_PTR(err);\n        goto out_free;\n    }\n    /* ok, we get the reply: have the mdu in the reply msg */\n    ASSERT(msg->pair, mds);\n    hmr = (struct hvfs_md_reply *)(msg->pair->xm_data);\n    if (!hmr || hmr->err) {\n        hvfs_err(mds, \"dh_load request failed %d\\n\", !hmr ? -ENOTEXIST : \n                 hmr->err);\n        e = !hmr ? ERR_PTR(-ENOTEXIST) : ERR_PTR(hmr->err);\n        goto out_free;\n    }\n    rhi = hmr_extract(hmr, EXTRACT_HI, &no);\n    if (!rhi) {\n        hvfs_err(mds, \"hmr_extract MDU failed, not found this subregion.\\n\");\n        goto out_free;\n    }\n    /* key, we got the mdu, let us insert it to the dh table */\n    e = mds_dh_insert(dh, rhi);\n    if (IS_ERR(e)) {\n        hvfs_err(mds, \"mds_dh_insert() failed %ld\\n\", PTR_ERR(e));\n        goto out_free;\n    }\n    \nout_free:\n    xnet_free_msg(msg);\n    return e;\n}", "path": "mds\\dh.c", "repo_name": "macan/hvfs", "stars": 1, "license": "None", "language": "c", "size": 308}
{"docstring": "/* xnet_send()\n */\n", "func_signal": "int xnet_send(struct xnet_context *xc, struct xnet_msg *msg)", "code": "{\n    struct epoll_event ev;\n    struct xnet_site *xs;\n    struct xnet_addr *xa;\n    int err = 0, csock = 0, found = 0, reconn = 0;\n    int bw, bt;\n    \n    st_lookup(&gst, &xs, msg->tx.dsite_id);\nretry:\n    list_for_each_entry(xa, &xs->addr, list) {\n        if (!xa->sockfd) {\n            /* not connected, dynamic connect */\n            if (!csock) {\n                csock = socket(AF_INET, SOCK_STREAM, 0);\n                if (csock < 0) {\n                    hvfs_err(xnet, \"socket() failed %d\\n\", errno);\n                    err = -errno;\n                    goto out;\n                }\n            }\n            err = connect(csock, &xa->sa, sizeof(xa->sa));\n            if (err < 0) {\n                hvfs_err(xnet, \"connect() %s %d failed %d\\n\",\n                         inet_ntoa(((struct sockaddr_in *)&xa->sa)->sin_addr),\n                         ntohs(((struct sockaddr_in *)&xa->sa)->sin_port), \n                         errno);\n                err = -errno;\n                if (reconn < 10) {\n                    reconn++;\n                    sleep(1);\n                    goto retry;\n                }\n                close(csock);\n                goto out;\n            } else {\n                struct accept_conn *ac;\n\n            realloc:                \n                ac = xzalloc(sizeof(struct accept_conn));\n                if (!ac) {\n                    hvfs_err(xnet, \"xzalloc() struct accept_conn failed\\n\");\n                    sleep(1);\n                    goto realloc;\n                }\n                INIT_LIST_HEAD(&ac->list);\n                ac->sockfd = csock;\n                list_add_tail(&ac->list, &accept_list);\n                st_update_sockfd(&gst, (struct sockaddr_in *)&xa->sa, csock);\n                \n                setnonblocking(csock);\n                setnodelay(csock);\n                ev.events = EPOLLIN | EPOLLET;\n                ev.data.fd = csock;\n                err = epoll_ctl(epfd, EPOLL_CTL_ADD, csock, &ev);\n                if (err < 0) {\n                    hvfs_err(xnet, \"epoll_ctl() add fd %d to SET(%d) failed %d\\n\",\n                             csock, epfd, errno);\n                    err = -errno;\n                    goto out;\n                }\n                \n                hvfs_debug(xnet, \"We just create connection %s %d -> fd %d\\n\",\n                           inet_ntoa(((struct sockaddr_in *)&xa->sa)->sin_addr),\n                           ntohs(((struct sockaddr_in *)&xa->sa)->sin_port), \n                           csock);\n            }\n            xa->sockfd = csock;\n            found = 1;\n            break;\n        } else {\n            found = 1;\n            if (csock)\n                close(csock);\n            break;\n        }\n    }\n\n    if (!found) {\n        hvfs_err(xnet, \"Sorry, we can not find the target site %lld\\n\",\n                 msg->tx.dsite_id);\n        err = -EINVAL;\n        goto out;\n    }\n    \n    msg->tx.ssite_id = xc->site_id;\n    msg->tx.reqno = global_reqno++;\n    if (msg->tx.type != XNET_MSG_RPY)\n        msg->tx.handle = (u64)msg;\n\n    /* already connected, just send the message */\n    hvfs_debug(xnet, \"OK, select connection %d, we will send the msg \"\n               \"site %lld -> %lld ...\\n\", xa->sockfd, \n               msg->tx.ssite_id, msg->tx.dsite_id);\n    \n#ifndef XNET_EAGER_WRITEV\n    /* send the msg tx by the selected connection */\n    bw = 0;\n    do {\n        bt = write(xa->sockfd, ((void *)&msg->tx) + bw, \n                   sizeof(struct xnet_msg_tx) - bw);\n        if (bt < 0) {\n            hvfs_err(xnet, \"write() err %d\\n\", errno);\n            if (errno == EINTR || errno == EAGAIN)\n                continue;\n            err = -errno;\n            goto out;\n        }\n        bw += bt;\n    } while (bw < sizeof(struct xnet_msg_tx));\n    atomic64_add(bw, &g_xnet_prof.outbytes);\n#endif\n\n    /* then, send the data region */\n    if (msg->siov_ulen) {\n        hvfs_debug(xnet, \"There is some data to send (iov_len %d) len %d...\\n\",\n                   msg->siov_ulen, msg->tx.len);\n        int i;\n        \n#if 1\n        bt = writev(xa->sockfd, msg->siov, msg->siov_ulen);\n        if (bt < 0 || msg->tx.len > bt) {\n            hvfs_err(xnet, \"writev() err %d, for now we do not support redo:(\\n\", \n                     errno);\n            err = -errno;\n            goto out;\n        }\n        atomic64_add(bt, &g_xnet_prof.outbytes);\n#else        \n        for (i = 0; i < msg->siov_ulen; i++) {\n            bw = 0;\n            do {\n                bt = write(xa->sockfd, msg->siov[i].iov_base + bw, \n                           msg->siov[i].iov_len - bw);\n                if (bt < 0) {\n                    hvfs_err(xnet, \"write() err %d\\n\", errno);\n                    if (errno == EINTR || errno == EAGAIN)\n                        continue;\n                    err = -errno;\n                    goto out;\n                }\n                bw += bt;\n            } while (bw < msg->siov[i].iov_len);\n            atomic64_add(bw, &g_xnet_prof.outbytes);\n        }\n#endif\n    }\n\n    hvfs_debug(xnet, \"We have sent the msg %p\\n\", msg);\n\n    /* finally, we wait for the reply msg */\n    if (msg->tx.flag & XNET_NEED_REPLY) {\n    rewait:\n        err = sem_wait(&msg->event);\n        if (err < 0) {\n            if (errno == EINTR)\n                goto rewait;\n            else\n                hvfs_err(xnet, \"sem_wait() failed %d\\n\", errno);\n        }\n\n        /* Haaaaa, we got the reply now */\n        hvfs_debug(xnet, \"We(%p) got the reply msg %p.\\n\", msg, msg->pair);\n    }\n    \nout:\n    return err;\n}", "path": "xnet\\xnet_simple.c", "repo_name": "macan/hvfs", "stars": 1, "license": "None", "language": "c", "size": 308}
{"docstring": "/* __mds_bitmap_insert()\n *\n * This function is ONLY used by the UNIT TEST program\n */\n", "func_signal": "int __mds_bitmap_insert(struct dhe *e, struct itbitmap *b)", "code": "{\n    struct itbitmap *pos;\n    int err = -EEXIST;\n\n    xlock_lock(&e->lock);\n    if (!list_empty(&e->bitmap)) {\n        list_for_each_entry(pos, &e->bitmap, list) {\n            if (pos->offset < b->offset)\n                continue;\n            if (pos->offset == b->offset) {\n                mds_bitmap_update(pos, b);\n                break;\n            }\n            if (pos->offset > b->offset) {\n                list_add_tail(&b->list, &pos->list);\n                err = 0;\n                break;\n            }\n        }\n    } else {\n        /* ok, this is an empty list */\n        list_add_tail(&b->list, &e->bitmap);\n        err = 0;\n    }\n    xlock_unlock(&e->lock);\n\n    return err;\n}", "path": "mds\\xtable.c", "repo_name": "macan/hvfs", "stars": 1, "license": "None", "language": "c", "size": 308}
{"docstring": "/* mds_bitmap_lookup()\n *\n * Test the offset in this slice, return the bit!\n */\n", "func_signal": "int mds_bitmap_lookup(struct itbitmap *b, u64 offset)", "code": "{\n    int index = offset - b->offset;\n\n    ASSERT((index >= 0 && index < XTABLE_BITMAP_SIZE), mds);\n    return test_bit(index, (u64 *)(b->array));\n}", "path": "mds\\xtable.c", "repo_name": "macan/hvfs", "stars": 1, "license": "None", "language": "c", "size": 308}
{"docstring": "/* \n * NOTE: we use unix domain socket to receive the request from\n * user/kernel-level tools, and we also support reading the conf/profiling\n * info by this approach\n */\n", "func_signal": "static void __dconf_cmd_action(struct dconf_req *dcr, int fd)", "code": "{\n    hvfs_verbose(mds, \"ACTION on CMD %lld %lld...\\n\", dcr->cmd, dcr->arg0);\n    switch (dcr->cmd) {\n    case DCONF_ECHO_CONF:\n        /* reply the configuration */\n        break;\n    case DCONF_SET_TXG_INTV:\n        if (dcr->arg0 >= 0) {\n            hvfs_info(mds, \"Changing TXG  Interval to %lld\\n\", dcr->arg0);\n            hmo.conf.txg_interval = dcr->arg0;\n        }\n        mds_reset_itimer();\n        break;\n    case DCONF_SET_PROF_INTV:\n        if (dcr->arg0 >= 0) {\n            hvfs_info(mds, \"Changing Prof Interval to %lld\\n\", dcr->arg0);\n            hmo.conf.profiling_thread_interval = dcr->arg0;\n        }\n        mds_reset_itimer();\n        break;\n    case DCONF_SET_UNLINK_INTV:\n        if (dcr->arg0 >= 0) {\n            hvfs_info(mds, \"Changing UNLK Interval to %lld\\n\", dcr->arg0);\n            hmo.conf.unlink_interval = dcr->arg0;\n        }\n        mds_reset_itimer();\n        break;\n    default:\n        ;\n    }\n}", "path": "mds\\conf.c", "repo_name": "macan/hvfs", "stars": 1, "license": "None", "language": "c", "size": 308}
{"docstring": "/* This function just return one reply message\n */\n", "func_signal": "int xnet_test_handler(struct xnet_msg *msg)", "code": "{\n    struct xnet_msg *rpy;\n    char data[100];\n\n    rpy = xnet_alloc_msg(XNET_MSG_NORMAL);\n    if (!rpy) {\n        hvfs_err(xnet, \"xnet_alloc_msg() failed\\n\");\n        return -ENOMEM;\n    }\n    xnet_msg_fill_tx(rpy, XNET_MSG_RPY, XNET_NEED_DATA_FREE, \n                     msg->tx.dsite_id, msg->tx.ssite_id);\n    xnet_msg_fill_cmd(rpy, XNET_RPY_ACK, 0, 0);\n    xnet_msg_add_sdata(rpy, data, sizeof(data));\n    rpy->tx.handle = msg->tx.handle;\n\n    xnet_send(xc, rpy);\n    \n    return 0;\n}", "path": "test\\xnet\\xnet.c", "repo_name": "macan/hvfs", "stars": 1, "license": "None", "language": "c", "size": 308}
{"docstring": "/* mds_get_itbid() may block on bitmap load\n *\n * Convert the hash to itbid by lookup the bitmap\n */\n", "func_signal": "u64 mds_get_itbid(struct dhe *e, u64 hash)", "code": "{\n    struct itbitmap *b;\n    u64 offset = hash >> ITB_DEPTH;\n    int err;\n\nretry:\n    xlock_lock(&e->lock);\n    list_for_each_entry(b, &e->bitmap, list) {\n        if (b->offset <= offset && offset < b->offset + XTABLE_BITMAP_SIZE) {\n            /* ok, we get the bitmap slice, let us test it */\n            if (mds_bitmap_lookup(b, offset)) {\n                xlock_unlock(&e->lock);\n                return offset;\n            } else {\n                /* hoo, we should reset the offset and restart the access */\n                xlock_unlock(&e->lock);\n                offset = mds_bitmap_fallback(offset);\n                goto retry;\n            }\n        } else if (b->offset > offset) {\n            /* it means that we need to load the missing slice */\n            xlock_unlock(&e->lock);\n            err = mds_bitmap_load(e, offset);\n            if (err == -ENOTEXIST) {\n                offset = mds_bitmap_fallback(offset);\n            } else if (err) {\n                /* some error occurs, we failed to the 0 position */\n                hvfs_err(mds, \"Hoo, loading DHE %lld Bitmap %lld failed\\n\", \n                         e->uuid, offset);\n                goto out;\n            }\n            goto retry;\n        } else if (offset >= b->offset + XTABLE_BITMAP_SIZE) {\n            if (b->flag & BITMAP_END) {\n                /* ok, let us just fallbacking */\n                xlock_unlock(&e->lock);\n                offset = mds_bitmap_fallback(offset);\n                goto retry;\n            }\n        }\n    }\n    xlock_unlock(&e->lock);\n\n    /* Hoo, we have not found the bitmap slice. We need to request the\n     * bitmap slice from the GDT server */\n    err = mds_bitmap_load(e, offset);\n    if (err == -ENOTEXIST) {\n        offset = mds_bitmap_fallback(offset);\n    } else if (err) {\n        hvfs_err(mds, \"Hoo, loading DHE %lld Bitmap %lld failed\\n\", \n                 e->uuid, offset);\n        goto out;\n    }\n    goto retry;\nout:\n    return 0;\n}", "path": "mds\\dh.c", "repo_name": "macan/hvfs", "stars": 1, "license": "None", "language": "c", "size": 308}
{"docstring": "/* mds_dh_init()\n *\n * NOTE: we do not provide any fast allocation\n */\n", "func_signal": "int mds_dh_init(struct dh *dh, int hsize)", "code": "{\n    int err = 0, i;\n    \n    /* regular hash init */\n    hsize = (hsize == 0) ? MDS_DH_DEFAULT_SIZE : hsize;\n    dh->ht = xzalloc(hsize * sizeof(struct regular_hash));\n    if (!dh->ht) {\n        hvfs_err(mds, \"DH hash table allocation failed\\n\");\n        err = -ENOMEM;\n        goto out;\n    }\n    for (i = 0; i < hsize; i++) {\n        INIT_HLIST_HEAD(&dh->ht[i].h);\n        xlock_init(&dh->ht[i].lock);\n    }\n    dh->hsize = hsize;\nout:\n    return err;\n}", "path": "mds\\dh.c", "repo_name": "macan/hvfs", "stars": 1, "license": "None", "language": "c", "size": 308}
{"docstring": "/* mds_bitmap_fallback()\n *\n * Fallback to the next location of ITB\n */\n", "func_signal": "u64 mds_bitmap_fallback(u64 offset)", "code": "{\n    int nr = fls(offset);       /* NOTE: we just use the low 32 bits */\n\n    if (!nr)\n        return 0;\n    __clear_bit(nr - 1, &offset);\n    return offset;\n}", "path": "mds\\xtable.c", "repo_name": "macan/hvfs", "stars": 1, "license": "None", "language": "c", "size": 308}
{"docstring": "/* st_update() update the relationship\n */\n", "func_signal": "int st_update(struct site_table *st, struct xnet_site *xs, u64 site_id)", "code": "{\n    struct xnet_site *t;\n\n    t = st->site[site_id];\n    st->site[site_id] = xs;\n    if (t)\n        xfree(t);\n    return 0;\n}", "path": "xnet\\xnet_simple.c", "repo_name": "macan/hvfs", "stars": 1, "license": "None", "language": "c", "size": 308}
{"docstring": "/* mds_dh_search() may block on dh_load\n *\n * Search in the DH(dir hash) to find the dir entry which contains\n * bitmap/salt/... etc\n *\n * NOTE: for now, we do NOT evict any dh entries. If the memory is low, we\n * first try to free the bitmap slices.\n *\n * Error Conversion: kernel err-ptr\n */\n", "func_signal": "struct dhe *mds_dh_search(struct dh *dh, u64 duuid)", "code": "{\n    struct dhe *e = ERR_PTR(-EINVAL);\n    struct regular_hash *rh;\n    struct hlist_node *l;\n    int i, found = 0;\n\n    i = mds_dh_hash(duuid);\n    rh = dh->ht + i;\n\n    xlock_lock(&rh->lock);\n    hlist_for_each_entry(e, l, &rh->h, hlist) {\n        if (e->uuid == duuid) {\n            found = 1;\n            break;\n        }\n    }\n    xlock_unlock(&rh->lock);\n\n    if (unlikely(!found)) {\n        /* Hoo, we have not found the directory. We need to request the\n         * directory information from the GDT server */\n        e = mds_dh_load(dh, duuid);\n        if (IS_ERR(e)) {\n            hvfs_err(mds, \"Hoo, loading DH %lld failed\\n\", duuid);\n            goto out;\n        }\n    }\n\n    /* OK, we have get the dh entry, just return it */\nout:\n    return e;\n}", "path": "mds\\dh.c", "repo_name": "macan/hvfs", "stars": 1, "license": "None", "language": "c", "size": 308}
{"docstring": "/* st_clean_sockfd() clean the related addr with the same fd\n */\n", "func_signal": "int st_clean_sockfd(struct site_table *st, int fd)", "code": "{\n    struct xnet_addr *xa;\n    int i;\n\n    for (i = 0; i < (1 << 20); i++) {\n        if (st->site[i]) {\n            if (st->site[i]->flag & XNET_SITE_LOCAL)\n                continue;\n            list_for_each_entry(xa, &st->site[i]->addr, list) {\n                if (xa->sockfd == fd) {\n                    hvfs_debug(xnet, \"Hoo, clean it @ %d <- %d.\\n\", i, fd);\n                    xa->sockfd = 0; /* clean the invalid fd */\n                }\n            }\n        }\n    }\n\n    close(fd);\n    return 0;\n}", "path": "xnet\\xnet_simple.c", "repo_name": "macan/hvfs", "stars": 1, "license": "None", "language": "c", "size": 308}
{"docstring": "/* __xnet_handle_tx()\n *\n * NOTE: this function should try to read from this socket hardly, until the\n * whole message is returned. At this point, we should try to read from the\n * socket either. Until EAGAIN returned, we must try to read deeply.\n */\n", "func_signal": "int __xnet_handle_tx(int fd)", "code": "{\n    struct xnet_msg *msg, *req;\n    int br, bt;\n    int next = 1;               /* this means we should retry the read */\n\n#ifdef HVFS_DEBUG_LATENCY\n    lib_timer_def();\n    lib_timer_start(&begin);\n#endif\n    msg = xnet_alloc_msg(XNET_MSG_NORMAL);\n    if (!msg) {\n        hvfs_err(xnet, \"xnet_alloc_msg() failed\\n\");\n        /* FIXME: we should put this fd in the retry queue, we can retry the\n         * receving. */\n        return next;\n    }\n\n    msg->state = XNET_MSG_RX;\n    /* receive the tx */\n    br = 0;\n    do {\n        bt = read(fd, ((void *)&msg->tx) + br, \n                  sizeof(struct xnet_msg_tx) - br);\n        if (bt < 0) {\n            if (errno == EAGAIN && !br) {\n                /* pseudo calling, just return */\n                next = 0;\n                goto out_free;\n            }\n            hvfs_err(xnet, \"read() err %d w/ br %d(%d)\\n\", \n                     errno, br, sizeof(struct xnet_msg_tx));\n            if (errno == EAGAIN || errno == EINTR)\n                continue;\n            /* FIXME: how to handle this err? */\n            next = -1;\n            goto out_free;\n        } else if (bt == 0) {\n            /* hoo, we got the EOF of the socket stream */\n            next = -1;\n            goto out_free;\n        }\n        br += bt;\n    } while (br < sizeof(struct xnet_msg_tx));\n    atomic64_add(br, &g_xnet_prof.inbytes);\n\n    hvfs_debug(xnet, \"We have recieved the MSG_TX, dpayload %lld\\n\", msg->tx.len);\n\n    /* receive the data if exists */\n#ifdef XNET_EAGER_WRITEV\n    msg->tx.len -= sizeof(struct xnet_msg_tx);\n#endif\n    if (msg->tx.len) {\n        /* we should pre-alloc the buffer */\n        void *buf = xmalloc(msg->tx.len);\n        if (!buf) {\n            hvfs_err(xnet, \"xmalloc() buffer failed\\n\");\n            ASSERT(0, xnet);\n            goto out_free;\n        }\n        br = 0;\n        do {\n            bt = read(fd, buf + br, msg->tx.len - br);\n            if (bt < 0) {\n                hvfs_debug(xnet, \"read() err %d w/ br %d(%d)\\n\", \n                         errno, br, msg->tx.len);\n                if (errno == EAGAIN || errno == EINTR) {\n                    sleep(0);\n                    continue;\n                }\n                /* This means the connection is broken, let us failed */\n                next = -1;\n                goto out_free;\n            } else if (bt == 0) {\n                next = -1;\n                goto out_free;\n            }\n            br += bt;\n        } while (br < msg->tx.len);\n\n        /* add the data to the riov */\n        xnet_msg_add_rdata(msg, buf, br);\n        atomic64_add(br, &g_xnet_prof.inbytes);\n    }\n    \n    /* find the related msg */\n    if (msg->tx.type == XNET_MSG_REQ) {\n        /* this is a fresh requst msg, just receive the data */\n        struct xnet_context *xc;\n\n        xc = __find_xc(msg->tx.dsite_id);\n        if (!xc) {\n            /* just return, nobody cares this msg */\n            goto out_free;\n        } else {\n            sem_post(&xc->wait);\n        }\n        hvfs_debug(xnet, \"We got a REQ message\\n\");\n        if (xc->ops.recv_handler)\n            xc->ops.recv_handler(msg);\n    } else if (msg->tx.type == XNET_MSG_RPY) {\n        /* we should find the original request by handle */\n        hvfs_debug(xnet, \"We got a RPY(%llx) message, handle to msg %p\\n\", \n                   msg->tx.cmd, (void *)msg->tx.handle);\n        req = (struct xnet_msg *)msg->tx.handle;\n        msg->state = XNET_MSG_PAIRED;\n\n        /* switch for REPLY/ACK/COMMIT */\n        if (msg->tx.cmd == XNET_RPY_DATA) {\n            req->state = XNET_MSG_ACKED;\n            req->pair = msg;\n        } else if (msg->tx.cmd == XNET_RPY_COMMIT) {\n            req->state = XNET_MSG_COMMITED;\n            /* auto free the commit msg */\n        } else if (msg->tx.cmd == XNET_RPY_ACK) {\n            req->state = XNET_MSG_ACKED;\n            /* auto free the ack msg */\n            req->pair = msg;\n        } else {\n            ASSERT(0, xnet);\n        }\n        sem_post(&req->event);\n    } else if (msg->tx.type == XNET_MSG_CMD) {\n        /* just receive the data */\n    } else if (msg->tx.type == XNET_MSG_NOP) {\n        hvfs_debug(xnet, \"recv NOP message, just receive the next msg.\\n\");\n    }\n#ifdef HVFS_DEBUG_LATENCY\n    lib_timer_stop(&end);\n    lib_timer_echo_plus(&begin, &end, 1, \"Total Handle Time\");\n#endif\n\n    if (next < 0) {\n        xnet_free_msg(msg);\n    }\n    return next;\nout_free:\n    xnet_free_msg(msg);\n    return next;\n}", "path": "xnet\\xnet_simple.c", "repo_name": "macan/hvfs", "stars": 1, "license": "None", "language": "c", "size": 308}
{"docstring": "/* ITB overflow\n *\n * NOTE:\n */\n", "func_signal": "int itb_overflow(struct itb *oi, struct itb **ni)", "code": "{\n    int err = 0;\n\n    return err;\n}", "path": "mds\\xtable.c", "repo_name": "macan/hvfs", "stars": 1, "license": "None", "language": "c", "size": 308}
{"docstring": "/* ITB split\n *\n * NOTE: \n */\n", "func_signal": "int itb_split(struct itb *oi, struct itb **ni)", "code": "{\n    int err = 0;\n\n    return err;\n}", "path": "mds\\xtable.c", "repo_name": "macan/hvfs", "stars": 1, "license": "None", "language": "c", "size": 308}
{"docstring": "/**\n * empathy_irc_network_manager_find_network_by_address:\n * @manager: an #EmpathyIrcNetworkManager\n * @address: the server address to look for\n *\n * Find the #EmpathyIrcNetwork which owns an #EmpathyIrcServer\n * that has the given address.\n *\n * Returns: the found #EmpathyIrcNetwork, or %NULL if not found.\n */\n", "func_signal": "EmpathyIrcNetwork *\nempathy_irc_network_manager_find_network_by_address (\n    EmpathyIrcNetworkManager *self,\n    const gchar *address)", "code": "{\n  EmpathyIrcNetworkManagerPriv *priv = GET_PRIV (self);\n  EmpathyIrcNetwork *network;\n\n  g_return_val_if_fail (address != NULL, NULL);\n\n  network = g_hash_table_find (priv->networks,\n      (GHRFunc) find_network_by_address, (gchar *) address);\n\n  return network;\n}", "path": "libempathy\\empathy-irc-network-manager.c", "repo_name": "james-w/empathy", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 7388}
{"docstring": "/*\n * API to save/load and parse the irc_networks file.\n */\n", "func_signal": "static void\nload_global_file (EmpathyIrcNetworkManager *self)", "code": "{\n  EmpathyIrcNetworkManagerPriv *priv = GET_PRIV (self);\n\n  if (priv->global_file == NULL)\n    return;\n\n  if (!g_file_test (priv->global_file, G_FILE_TEST_EXISTS))\n    {\n      DEBUG (\"Global networks file %s doesn't exist\", priv->global_file);\n      return;\n    }\n\n  irc_network_manager_file_parse (self, priv->global_file, FALSE);\n}", "path": "libempathy\\empathy-irc-network-manager.c", "repo_name": "james-w/empathy", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 7388}
{"docstring": "/* Code stolen from pidgin/gtkimhtml.c */\n", "func_signal": "static gboolean\nchat_view_scroll_cb (EmpathyChatView *view)", "code": "{\n\tEmpathyChatViewPriv *priv;\n\tGtkAdjustment      *adj;\n\tgdouble             max_val;\n\n\tpriv = GET_PRIV (view);\n\tadj = GTK_TEXT_VIEW (view)->vadjustment;\n\tmax_val = adj->upper - adj->page_size;\n\n\tg_return_val_if_fail (priv->scroll_time != NULL, FALSE);\n\n\tif (g_timer_elapsed (priv->scroll_time, NULL) > MAX_SCROLL_TIME) {\n\t\t/* time's up. jump to the end and kill the timer */\n\t\tgtk_adjustment_set_value (adj, max_val);\n\t\tg_timer_destroy (priv->scroll_time);\n\t\tpriv->scroll_time = NULL;\n\t\tpriv->scroll_timeout = 0;\n\t\treturn FALSE;\n\t}\n\n\t/* scroll by 1/3rd the remaining distance */\n\tgtk_adjustment_set_value (adj, gtk_adjustment_get_value (adj) + ((max_val - gtk_adjustment_get_value (adj)) / 3));\n\treturn TRUE;\n}", "path": "libempathy-gtk\\empathy-chat-view.c", "repo_name": "james-w/empathy", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 7388}
{"docstring": "/**\n * empathy_irc_network_manager_get_networks:\n * @manager: an #EmpathyIrcNetworkManager\n *\n * Get the list of #EmpathyIrcNetwork associated with the given\n * manager.\n *\n * Returns: a new #GSList of refed #EmpathyIrcNetwork\n */\n", "func_signal": "GSList *\nempathy_irc_network_manager_get_networks (EmpathyIrcNetworkManager *self)", "code": "{\n  EmpathyIrcNetworkManagerPriv *priv;\n  GSList *irc_networks = NULL;\n\n  g_return_val_if_fail (EMPATHY_IS_IRC_NETWORK_MANAGER (self), NULL);\n\n  priv = GET_PRIV (self);\n\n  g_hash_table_foreach (priv->networks, (GHFunc) append_network_to_list,\n      &irc_networks);\n\n  return irc_networks;\n}", "path": "libempathy\\empathy-irc-network-manager.c", "repo_name": "james-w/empathy", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 7388}
{"docstring": "/* Returns the window to open a new tab in if there is only one window\n * visble, otherwise, returns NULL indicating that a new window should\n * be added.\n */\n", "func_signal": "EmpathyChatWindow *\nempathy_chat_window_get_default (void)", "code": "{\n\tGList    *l;\n\tgboolean  separate_windows = TRUE;\n\n\tempathy_conf_get_bool (empathy_conf_get (),\n\t\t\t      EMPATHY_PREFS_UI_SEPARATE_CHAT_WINDOWS,\n\t\t\t      &separate_windows);\n\n\tif (separate_windows) {\n\t\t/* Always create a new window */\n\t\treturn NULL;\n\t}\n\n\tfor (l = chat_windows; l; l = l->next) {\n\t\tEmpathyChatWindow *chat_window;\n\t\tGtkWidget         *dialog;\n\n\t\tchat_window = l->data;\n\n\t\tdialog = empathy_chat_window_get_dialog (chat_window);\n\t\tif (empathy_window_get_is_visible (GTK_WINDOW (GTK_WINDOW (dialog)))) {\n\t\t\t/* Found a visible window on this desktop */\n\t\t\treturn chat_window;\n\t\t}\n\t}\n\n\treturn NULL;\n}", "path": "src\\empathy-chat-window.c", "repo_name": "james-w/empathy", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 7388}
{"docstring": "/* Converts the UTC timestamp to a string, also in UTC. Returns NULL on failure. */\n", "func_signal": "gchar *\nempathy_time_to_string_utc (time_t       t,\n\t\t\t    const gchar *format)", "code": "{\n\tgchar      stamp[128];\n\tstruct tm *tm;\n\n\tg_return_val_if_fail (format != NULL, NULL);\n\n\ttm = gmtime (&t);\n\tif (strftime (stamp, sizeof (stamp), format, tm) == 0) {\n\t\treturn NULL;\n\t}\n\n\treturn g_strdup (stamp);\n}", "path": "libempathy\\empathy-time.c", "repo_name": "james-w/empathy", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 7388}
{"docstring": "/**\n * empathy_irc_server_new:\n * @address: the address\n * @port: the port\n * @ssl: %TRUE if the server needs a SSL connection\n *\n * Creates a new #EmpathyIrcServer\n *\n * Returns: a new #EmpathyIrcServer\n */\n", "func_signal": "EmpathyIrcServer *\nempathy_irc_server_new (const gchar *address,\n                        guint port,\n                        gboolean ssl)", "code": "{\n  return g_object_new (EMPATHY_TYPE_IRC_SERVER,\n      \"address\", address,\n      \"port\", port,\n      \"ssl\", ssl,\n      NULL);\n}", "path": "libempathy\\empathy-irc-server.c", "repo_name": "james-w/empathy", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 7388}
{"docstring": "/* The code that handles single-instance and startup notification is\n * copied from gedit.\n *\n * Copyright (C) 2005 - Paolo Maggi \n */\n", "func_signal": "static void\non_bacon_message_received (const char *message,\n\t\t\t   gpointer    data)", "code": "{\n\tGtkWidget *window = data;\n\tguint32    startup_timestamp;\n\n\tg_return_if_fail (message != NULL);\n\n\tDEBUG (\"Other instance launched, presenting the main window. message='%s'\",\n\t\tmessage);\n\n\tstartup_timestamp = atoi (message);\n\n\t/* Set the proper interaction time on the window.\n\t * Fall back to roundtripping to the X server when we\n\t * don't have the timestamp, e.g. when launched from\n\t * terminal. We also need to make sure that the window\n\t * has been realized otherwise it will not work. lame. */\n\tif (startup_timestamp == 0) {\n\t\t/* Work if launched from the terminal */\n\t\tDEBUG (\"Using X server timestamp as a fallback\");\n\n\t\tif (!GTK_WIDGET_REALIZED (window)) {\n\t\t\tgtk_widget_realize (GTK_WIDGET (window));\n\t\t}\n\n\t\tstartup_timestamp = gdk_x11_get_server_time (window->window);\n\t}\n\n\tgtk_window_present_with_time (GTK_WINDOW (window), startup_timestamp);\n}", "path": "src\\empathy.c", "repo_name": "james-w/empathy", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 7388}
{"docstring": "/* strsplit () that retains the delimiter as part of the string. */\n", "func_signal": "static gchar **\nstrbreakup (const char *string,\n\t    const char *delimiter,\n\t    gint        max_tokens)", "code": "{\n\tGSList *string_list = NULL, *slist;\n\tgchar **str_array, *s, *casefold, *new_string;\n\tguint i, n = 1;\n\n\tg_return_val_if_fail (string != NULL, NULL);\n\tg_return_val_if_fail (delimiter != NULL, NULL);\n\n\tif (max_tokens < 1)\n\t\tmax_tokens = G_MAXINT;\n\n\ts = strstr (string, delimiter);\n\tif (s)\n\t{\n\t\tguint delimiter_len = strlen (delimiter);\n\n\t\tdo\n\t\t{\n\t\t\tguint len;\n\n\t\t\tlen = s - string + delimiter_len;\n\t\t\tnew_string = g_new (gchar, len + 1);\n\t\t\tstrncpy (new_string, string, len);\n\t\t\tnew_string[len] = 0;\n\t\t\tcasefold = g_utf8_casefold (new_string, -1);\n\t\t\tg_free (new_string);\n\t\t\tnew_string = g_utf8_normalize (casefold, -1, G_NORMALIZE_NFD);\n\t\t\tg_free (casefold);\n\t\t\tstring_list = g_slist_prepend (string_list, new_string);\n\t\t\tn++;\n\t\t\tstring = s + delimiter_len;\n\t\t\ts = strstr (string, delimiter);\n\t\t} while (--max_tokens && s);\n\t}\n\n\tif (*string)\n\t{\n\t\tn++;\n\t\tcasefold = g_utf8_casefold (string, -1);\n\t\tnew_string = g_utf8_normalize (casefold, -1, G_NORMALIZE_NFD);\n\t\tg_free (casefold);\n\t\tstring_list = g_slist_prepend (string_list, new_string);\n\t}\n\n\tstr_array = g_new (gchar*, n);\n\n\ti = n - 1;\n\n\tstr_array[i--] = NULL;\n\tfor (slist = string_list; slist; slist = slist->next)\n\t\tstr_array[i--] = slist->data;\n\n\tg_slist_free (string_list);\n\n\treturn str_array;\n}", "path": "libempathy-gtk\\empathy-ui-utils.c", "repo_name": "james-w/empathy", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 7388}
{"docstring": "/* Takes care of moving the window to the current workspace. */\n", "func_signal": "void\nempathy_window_present (GtkWindow *window,\n\t\t\tgboolean   steal_focus)", "code": "{\n\tguint32 timestamp;\n\n\tg_return_if_fail (GTK_IS_WINDOW (window));\n\n\t/* There are three cases: hidden, visible, visible on another\n\t * workspace.\n\t */\n\n\tif (!empathy_window_get_is_visible (window)) {\n\t\t/* Hide it so present brings it to the current workspace. */\n\t\tgtk_widget_hide (GTK_WIDGET (window));\n\t}\n\n\ttimestamp = gtk_get_current_event_time ();\n\tgtk_window_set_skip_taskbar_hint (window, FALSE);\n\tgtk_window_present_with_time (window, timestamp);\n\t/* FIXME: This shouldn't be required as gtk_window_present's doc says\n\t *        it deiconify automatically. */\n\tgtk_window_deiconify (window);\n}", "path": "libempathy-gtk\\empathy-ui-utils.c", "repo_name": "james-w/empathy", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 7388}
{"docstring": "/**\n * empathy_irc_network_dialog_show:\n * @network: the #EmpathyIrcNetwork to configure\n * @parent: the parent of this dialog\n *\n * Display a dialog to configure a given #EmpathyIrcNetwork.\n * This function is a singleton so if a configuration dialog already\n * exists we use this one to edit the network.\n *\n * Returns: The displayed #GtkDialog\n */\n", "func_signal": "GtkWidget *\nempathy_irc_network_dialog_show (EmpathyIrcNetwork *network,\n                                 GtkWidget *parent)", "code": "{\n  static EmpathyIrcNetworkDialog *dialog = NULL;\n  GladeXML *glade;\n  GtkListStore *store;\n  GtkCellRenderer *renderer;\n  GtkAdjustment *adjustment;\n  GtkTreeSelection *selection;\n  GtkTreeViewColumn *column;\n  gchar *filename;\n\n  g_return_val_if_fail (network != NULL, NULL);\n\n  if (dialog != NULL)\n    {\n      change_network (dialog, network);\n      gtk_window_present (GTK_WINDOW (dialog->dialog));\n\n      return dialog->dialog;\n    }\n\n  dialog = g_slice_new0 (EmpathyIrcNetworkDialog);\n\n  dialog->network = network;\n  g_object_ref (dialog->network);\n\n  filename = empathy_file_lookup (\"empathy-account-widget-irc.glade\",\n      \"libempathy-gtk\");\n  glade = empathy_glade_get_file (filename,\n      \"irc_network_dialog\",\n      NULL,\n      \"irc_network_dialog\", &dialog->dialog,\n      \"button_close\", &dialog->button_close,\n      \"entry_network\", &dialog->entry_network,\n      \"combobox_charset\", &dialog->combobox_charset,\n      \"treeview_servers\", &dialog->treeview_servers,\n      \"button_add\", &dialog->button_add,\n      \"button_remove\", &dialog->button_remove,\n      \"button_up\", &dialog->button_up,\n      \"button_down\", &dialog->button_down,\n      NULL);\n  g_free (filename);\n\n  store = gtk_list_store_new (4, G_TYPE_OBJECT, G_TYPE_STRING,\n      G_TYPE_UINT, G_TYPE_BOOLEAN);\n  gtk_tree_view_set_model (GTK_TREE_VIEW (dialog->treeview_servers),\n      GTK_TREE_MODEL (store));\n  g_object_unref (store);\n\n  /* address */\n  renderer = gtk_cell_renderer_text_new ();\n  g_object_set (renderer, \"editable\", TRUE, NULL);\n  g_signal_connect (renderer, \"edited\",\n      G_CALLBACK (irc_network_dialog_address_edited_cb), dialog);\n  gtk_tree_view_insert_column_with_attributes (\n      GTK_TREE_VIEW (dialog->treeview_servers),\n      -1, _(\"Server\"), renderer, \"text\", COL_ADR,\n      NULL);\n\n  /* port */\n  adjustment = (GtkAdjustment *) gtk_adjustment_new (6667, 1, G_MAXUINT16,\n      1, 10, 0);\n  renderer = gtk_cell_renderer_spin_new ();\n  g_object_set (renderer,\n      \"editable\", TRUE, \n      \"adjustment\", adjustment,\n      NULL);\n  g_signal_connect (renderer, \"edited\",\n      G_CALLBACK (irc_network_dialog_port_edited_cb), dialog);\n  gtk_tree_view_insert_column_with_attributes (\n      GTK_TREE_VIEW (dialog->treeview_servers),\n      -1, _(\"Port\"), renderer, \"text\", COL_PORT,\n      NULL);\n  column = gtk_tree_view_get_column (GTK_TREE_VIEW (dialog->treeview_servers),\n      1);\n  gtk_tree_view_column_set_expand (column, TRUE);\n\n  /* SSL */\n  renderer = gtk_cell_renderer_toggle_new ();\n  g_object_set (renderer, \"activatable\", TRUE, NULL);\n  g_signal_connect (renderer, \"toggled\",\n      G_CALLBACK (irc_network_dialog_ssl_toggled_cb), dialog);\n  gtk_tree_view_insert_column_with_attributes (\n      GTK_TREE_VIEW (dialog->treeview_servers),\n      -1, _(\"SSL\"), renderer, \"active\", COL_SSL,\n      NULL);\n\n  selection = gtk_tree_view_get_selection (\n      GTK_TREE_VIEW (dialog->treeview_servers));\n  gtk_tree_selection_set_mode (selection, GTK_SELECTION_SINGLE);\n\n  /* charset */\n  totem_subtitle_encoding_init (GTK_COMBO_BOX (dialog->combobox_charset));\n\n  irc_network_dialog_setup (dialog);\n\n  empathy_glade_connect (glade, dialog,\n      \"irc_network_dialog\", \"destroy\", irc_network_dialog_destroy_cb,\n      \"button_close\", \"clicked\", irc_network_dialog_close_clicked_cb,\n      \"entry_network\", \"focus-out-event\", irc_network_dialog_network_focus_cb,\n      \"button_add\", \"clicked\", irc_network_dialog_button_add_clicked_cb,\n      \"button_remove\", \"clicked\", irc_network_dialog_button_remove_clicked_cb,\n      \"button_up\", \"clicked\", irc_network_dialog_button_up_clicked_cb,\n      \"button_down\", \"clicked\", irc_network_dialog_button_down_clicked_cb,\n      \"combobox_charset\", \"changed\", irc_network_dialog_combobox_charset_changed_cb,\n      NULL);\n\n  g_object_unref (glade);\n\n  g_object_add_weak_pointer (G_OBJECT (dialog->dialog),\n      (gpointer) &dialog);\n\n  g_signal_connect (selection, \"changed\",\n      G_CALLBACK (irc_network_dialog_selection_changed_cb),\n      dialog);\n\n  gtk_window_set_transient_for (GTK_WINDOW (dialog->dialog),\n      GTK_WINDOW (parent));\n  gtk_window_set_modal (GTK_WINDOW (dialog->dialog), TRUE);\n\n  irc_network_dialog_network_update_buttons (dialog);\n\n  return dialog->dialog;\n}", "path": "libempathy-gtk\\empathy-irc-network-dialog.c", "repo_name": "james-w/empathy", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 7388}
{"docstring": "/**\n * empathy_irc_network_manager_remove:\n * @manager: an #EmpathyIrcNetworkManager\n * @network: the #EmpathyIrcNetwork to remove\n *\n * Remove an #EmpathyIrcNetwork from the given #EmpathyIrcNetworkManager.\n *\n */\n", "func_signal": "void\nempathy_irc_network_manager_remove (EmpathyIrcNetworkManager *self,\n                                    EmpathyIrcNetwork *network)", "code": "{\n  EmpathyIrcNetworkManagerPriv *priv;\n\n  g_return_if_fail (EMPATHY_IS_IRC_NETWORK_MANAGER (self));\n  g_return_if_fail (EMPATHY_IS_IRC_NETWORK (network));\n\n  priv = GET_PRIV (self);\n\n  network->user_defined = TRUE;\n  network->dropped = TRUE;\n\n  priv->have_to_save = TRUE;\n  reset_save_timeout (self);\n}", "path": "libempathy\\empathy-irc-network-manager.c", "repo_name": "james-w/empathy", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 7388}
{"docstring": "/* Format is just date, 20061201. */\n", "func_signal": "gchar *\nempathy_log_manager_get_date_readable (const gchar *date)", "code": "{\n\ttime_t t;\n\n\tt = empathy_time_parse (date);\n\n\treturn empathy_time_to_string_local (t, \"%a %d %b %Y\");\n}", "path": "libempathy\\empathy-log-manager.c", "repo_name": "james-w/empathy", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 7388}
{"docstring": "/**\n * empathy_irc_network_manager_new:\n * @global_file: the path of the global networks file, or %NULL\n * @user_file: the path of the user networks file, or %NULL\n *\n * Creates a new #EmpathyIrcNetworkManager\n *\n * Returns: a new #EmpathyIrcNetworkManager\n */\n", "func_signal": "EmpathyIrcNetworkManager *\nempathy_irc_network_manager_new (const gchar *global_file,\n                                 const gchar *user_file)", "code": "{\n  EmpathyIrcNetworkManager *manager;\n\n  manager = g_object_new (EMPATHY_TYPE_IRC_NETWORK_MANAGER,\n      \"global-file\", global_file,\n      \"user-file\", user_file,\n      NULL);\n\n  return manager;\n}", "path": "libempathy\\empathy-irc-network-manager.c", "repo_name": "james-w/empathy", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 7388}
{"docstring": "/* The format is: \"20021209T23:51:30\" and is in UTC. 0 is returned on\n * failure. The alternative format \"20021209\" is also accepted.\n */\n", "func_signal": "time_t\nempathy_time_parse (const gchar *str)", "code": "{\n\tstruct tm tm;\n\tgint      year, month;\n\tgint      n_parsed;\n\n\tmemset (&tm, 0, sizeof (struct tm));\n\n\tn_parsed = sscanf (str, \"%4d%2d%2dT%2d:%2d:%2d\",\n\t\t    &year, &month, &tm.tm_mday, &tm.tm_hour,\n\t\t\t   &tm.tm_min, &tm.tm_sec);\n\tif (n_parsed != 3 && n_parsed != 6) {\n\t\treturn 0;\n\t}\n\n\ttm.tm_year = year - 1900;\n\ttm.tm_mon = month - 1;\n\ttm.tm_isdst = -1;\n\n\treturn empathy_time_get_local_time (&tm);\n}", "path": "libempathy\\empathy-time.c", "repo_name": "james-w/empathy", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 7388}
{"docstring": "/* The URL opening code can't handle schemeless strings, so we try to be\n * smart and add http if there is no scheme or doesn't look like a mail\n * address. This should work in most cases, and let us click on strings\n * like \"www.gnome.org\".\n */\n", "func_signal": "static gchar *\nfixup_url (const gchar *url)", "code": "{\n\tif (!g_str_has_prefix (url, \"ghelp:\") &&\n\t    !strstr (url, \":/\") &&\n\t    !strstr (url, \"@\")) {\n\t\treturn g_strdup_printf (\"http://%s\", url);\n\t} else {\n\t\treturn NULL;\n\t}\n}", "path": "libempathy-gtk\\empathy-ui-utils.c", "repo_name": "james-w/empathy", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 7388}
{"docstring": "/* Pads a pixbuf to the specified size, by centering it in a larger transparent\n * pixbuf. Returns a new ref.\n */\n", "func_signal": "static GdkPixbuf *\nchat_view_pad_to_size (GdkPixbuf *pixbuf,\n\t\t       gint       width,\n\t\t       gint       height,\n\t\t       gint       extra_padding_right)", "code": "{\n\tgint       src_width, src_height;\n\tGdkPixbuf *padded;\n\tgint       x_offset, y_offset;\n\n\tsrc_width = gdk_pixbuf_get_width (pixbuf);\n\tsrc_height = gdk_pixbuf_get_height (pixbuf);\n\n\tx_offset = (width - src_width) / 2;\n\ty_offset = (height - src_height) / 2;\n\n\tpadded = gdk_pixbuf_new (gdk_pixbuf_get_colorspace (pixbuf),\n\t\t\t\t TRUE, /* alpha */\n\t\t\t\t gdk_pixbuf_get_bits_per_sample (pixbuf),\n\t\t\t\t width + extra_padding_right,\n\t\t\t\t height);\n\n\tgdk_pixbuf_fill (padded, 0);\n\n\tgdk_pixbuf_copy_area (pixbuf,\n\t\t\t      0, /* source coords */\n\t\t\t      0,\n\t\t\t      src_width,\n\t\t\t      src_height,\n\t\t\t      padded,\n\t\t\t      x_offset, /* dest coords */\n\t\t\t      y_offset);\n\n\treturn padded;\n}", "path": "libempathy-gtk\\empathy-chat-view.c", "repo_name": "james-w/empathy", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 7388}
{"docstring": "/**\n * empathy_irc_network_manager_add:\n * @manager: an #EmpathyIrcNetworkManager\n * @network: the #EmpathyIrcNetwork to add\n *\n * Add an #EmpathyIrcNetwork to the given #EmpathyIrcNetworkManager.\n *\n */\n", "func_signal": "void\nempathy_irc_network_manager_add (EmpathyIrcNetworkManager *self,\n                                 EmpathyIrcNetwork *network)", "code": "{\n  EmpathyIrcNetworkManagerPriv *priv;\n  gchar *id = NULL;\n\n  g_return_if_fail (EMPATHY_IS_IRC_NETWORK_MANAGER (self));\n  g_return_if_fail (EMPATHY_IS_IRC_NETWORK (network));\n\n  priv = GET_PRIV (self);\n\n  /* generate an id for this network */\n  do\n    {\n      g_free (id);\n      id = g_strdup_printf (\"id%u\", ++priv->last_id);\n    } while (g_hash_table_lookup (priv->networks, id) != NULL &&\n        priv->last_id < G_MAXUINT);\n\n  if (priv->last_id == G_MAXUINT)\n    {\n      DEBUG (\"Can't add network: too many networks using a similiar ID\");\n      return;\n    }\n\n  DEBUG (\"add server with \\\"%s\\\" as ID\", id);\n\n  network->user_defined = TRUE;\n  add_network (self, network, id);\n\n  priv->have_to_save = TRUE;\n  reset_save_timeout (self);\n\n  g_free (id);\n}", "path": "libempathy\\empathy-irc-network-manager.c", "repo_name": "james-w/empathy", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 7388}
{"docstring": "/*\n * API to save/load and parse the chatrooms file.\n */\n", "func_signal": "static gboolean\nchatroom_manager_get_all (EmpathyChatroomManager *manager)", "code": "{\n\tEmpathyChatroomManagerPriv *priv;\n\tgchar                     *dir;\n\tgchar                     *file_with_path = NULL;\n\n\tpriv = GET_PRIV (manager);\n\n\tdir = g_build_filename (g_get_home_dir (), \".gnome2\", PACKAGE_NAME, NULL);\n\tif (!g_file_test (dir, G_FILE_TEST_EXISTS | G_FILE_TEST_IS_DIR)) {\n\t\tg_mkdir_with_parents (dir, S_IRUSR | S_IWUSR | S_IXUSR);\n\t}\n\n\tfile_with_path = g_build_filename (dir, CHATROOMS_XML_FILENAME, NULL);\n\tg_free (dir);\n\n\t/* read file in */\n\tif (g_file_test (file_with_path, G_FILE_TEST_EXISTS) &&\n\t    !chatroom_manager_file_parse (manager, file_with_path)) {\n\t\tg_free (file_with_path);\n\t\treturn FALSE;\n\t}\n\n\tg_free (file_with_path);\n\n\treturn TRUE;\n}", "path": "libempathy\\empathy-chatroom-manager.c", "repo_name": "james-w/empathy", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 7388}
{"docstring": "/* Converts the UTC timestamp to a string, in local time. Returns NULL on failure. */\n", "func_signal": "gchar *\nempathy_time_to_string_local (time_t       t,\n\t\t\t      const gchar *format)", "code": "{\n\tgchar      stamp[128];\n\tstruct tm *tm;\n\n\tg_return_val_if_fail (format != NULL, NULL);\n\n\ttm = localtime (&t);\n\tif (strftime (stamp, sizeof (stamp), format, tm) == 0) {\n\t\treturn NULL;\n\t}\n\n\treturn g_strdup (stamp);\n}", "path": "libempathy\\empathy-time.c", "repo_name": "james-w/empathy", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 7388}
{"docstring": "/* Print the result of a function at the end of a 'finish' command.  */\n", "func_signal": "static void\nprint_return_value (struct type *func_type, struct type *value_type)", "code": "{\n  struct gdbarch *gdbarch = get_regcache_arch (stop_registers);\n  struct cleanup *old_chain;\n  struct ui_stream *stb;\n  struct value *value;\n\n  CHECK_TYPEDEF (value_type);\n  gdb_assert (TYPE_CODE (value_type) != TYPE_CODE_VOID);\n\n  /* FIXME: 2003-09-27: When returning from a nested inferior function\n     call, it's possible (with no help from the architecture vector)\n     to locate and return/print a \"struct return\" value.  This is just\n     a more complicated case of what is already being done in in the\n     inferior function call code.  In fact, when inferior function\n     calls are made async, this will likely be made the norm.  */\n\n  switch (gdbarch_return_value (gdbarch, func_type, value_type,\n  \t\t\t\tNULL, NULL, NULL))\n    {\n    case RETURN_VALUE_REGISTER_CONVENTION:\n    case RETURN_VALUE_ABI_RETURNS_ADDRESS:\n    case RETURN_VALUE_ABI_PRESERVES_ADDRESS:\n      value = allocate_value (value_type);\n      gdbarch_return_value (gdbarch, func_type, value_type, stop_registers,\n\t\t\t    value_contents_raw (value), NULL);\n      break;\n    case RETURN_VALUE_STRUCT_CONVENTION:\n      value = NULL;\n      break;\n    default:\n      internal_error (__FILE__, __LINE__, _(\"bad switch\"));\n    }\n\n  if (value)\n    {\n      struct value_print_options opts;\n\n      /* Print it.  */\n      stb = ui_out_stream_new (uiout);\n      old_chain = make_cleanup_ui_out_stream_delete (stb);\n      ui_out_text (uiout, \"Value returned is \");\n      ui_out_field_fmt (uiout, \"gdb-result-var\", \"$%d\",\n\t\t\trecord_latest_value (value));\n      ui_out_text (uiout, \" = \");\n      get_raw_print_options (&opts);\n      value_print (value, stb->stream, &opts);\n      ui_out_field_stream (uiout, \"return-value\", stb);\n      ui_out_text (uiout, \"\\n\");\n      do_cleanups (old_chain);\n    }\n  else\n    {\n      ui_out_text (uiout, \"Value returned has type: \");\n      ui_out_field_string (uiout, \"return-type\", TYPE_NAME (value_type));\n      ui_out_text (uiout, \".\");\n      ui_out_text (uiout, \" Cannot determine contents\\n\");\n    }\n}", "path": "gdb-7.0\\gdb\\infcmd.c", "repo_name": "joelagnel/gdb-kernel", "stars": 1, "license": "None", "language": "c", "size": 23464}
{"docstring": "/* finish_forward -- helper function for finish_command.  */\n", "func_signal": "static void\nfinish_forward (struct symbol *function, struct frame_info *frame)", "code": "{\n  struct gdbarch *gdbarch = get_frame_arch (frame);\n  struct symtab_and_line sal;\n  struct thread_info *tp = inferior_thread ();\n  struct breakpoint *breakpoint;\n  struct cleanup *old_chain;\n  struct finish_command_continuation_args *cargs;\n\n  sal = find_pc_line (get_frame_pc (frame), 0);\n  sal.pc = get_frame_pc (frame);\n\n  breakpoint = set_momentary_breakpoint (gdbarch, sal,\n\t\t\t\t\t get_stack_frame_id (frame),\n                                         bp_finish);\n\n  old_chain = make_cleanup_delete_breakpoint (breakpoint);\n\n  tp->proceed_to_finish = 1;    /* We want stop_registers, please...  */\n  proceed ((CORE_ADDR) -1, TARGET_SIGNAL_DEFAULT, 0);\n\n  cargs = xmalloc (sizeof (*cargs));\n\n  cargs->breakpoint = breakpoint;\n  cargs->function = function;\n  add_continuation (tp, finish_command_continuation, cargs,\n                    finish_command_continuation_free_arg);\n\n  discard_cleanups (old_chain);\n  if (!target_can_async_p ())\n    do_all_continuations ();\n}", "path": "gdb-7.0\\gdb\\infcmd.c", "repo_name": "joelagnel/gdb-kernel", "stars": 1, "license": "None", "language": "c", "size": 23464}
{"docstring": "/* Implement the \"run\" command. If TBREAK_AT_MAIN is set, then insert\n   a temporary breakpoint at the begining of the main program before\n   running the program.  */\n", "func_signal": "static void\nrun_command_1 (char *args, int from_tty, int tbreak_at_main)", "code": "{\n  char *exec_file;\n  struct cleanup *old_chain;\n  ptid_t ptid;\n\n  dont_repeat ();\n\n  kill_if_already_running (from_tty);\n\n  init_wait_for_inferior ();\n  clear_breakpoint_hit_counts ();\n\n  /* Clean up any leftovers from other runs.  Some other things from\n     this function should probably be moved into target_pre_inferior.  */\n  target_pre_inferior (from_tty);\n\n  /* The comment here used to read, \"The exec file is re-read every\n     time we do a generic_mourn_inferior, so we just have to worry\n     about the symbol file.\"  The `generic_mourn_inferior' function\n     gets called whenever the program exits.  However, suppose the\n     program exits, and *then* the executable file changes?  We need\n     to check again here.  Since reopen_exec_file doesn't do anything\n     if the timestamp hasn't changed, I don't see the harm.  */\n  reopen_exec_file ();\n  reread_symbols ();\n\n  /* Insert the temporary breakpoint if a location was specified.  */\n  if (tbreak_at_main)\n    tbreak_command (main_name (), 0);\n\n  exec_file = (char *) get_exec_file (0);\n\n  if (non_stop && !target_supports_non_stop ())\n    error (_(\"The target does not support running in non-stop mode.\"));\n\n  /* We keep symbols from add-symbol-file, on the grounds that the\n     user might want to add some symbols before running the program\n     (right?).  But sometimes (dynamic loading where the user manually\n     introduces the new symbols with add-symbol-file), the code which\n     the symbols describe does not persist between runs.  Currently\n     the user has to manually nuke all symbols between runs if they\n     want them to go away (PR 2207).  This is probably reasonable.  */\n\n  if (!args)\n    {\n      if (target_can_async_p ())\n\tasync_disable_stdin ();\n    }\n  else\n    {\n      int async_exec = strip_bg_char (&args);\n\n      /* If we get a request for running in the bg but the target\n         doesn't support it, error out. */\n      if (async_exec && !target_can_async_p ())\n\terror (_(\"Asynchronous execution not supported on this target.\"));\n\n      /* If we don't get a request of running in the bg, then we need\n         to simulate synchronous (fg) execution. */\n      if (!async_exec && target_can_async_p ())\n\t{\n\t  /* Simulate synchronous execution */\n\t  async_disable_stdin ();\n\t}\n\n      /* If there were other args, beside '&', process them. */\n      if (args)\n\t{\n          char *old_args = set_inferior_args (xstrdup (args));\n          xfree (old_args);\n\t}\n    }\n\n  if (from_tty)\n    {\n      ui_out_field_string (uiout, NULL, \"Starting program\");\n      ui_out_text (uiout, \": \");\n      if (exec_file)\n\tui_out_field_string (uiout, \"execfile\", exec_file);\n      ui_out_spaces (uiout, 1);\n      /* We call get_inferior_args() because we might need to compute\n\t the value now.  */\n      ui_out_field_string (uiout, \"infargs\", get_inferior_args ());\n      ui_out_text (uiout, \"\\n\");\n      ui_out_flush (uiout);\n    }\n\n  /* We call get_inferior_args() because we might need to compute\n     the value now.  */\n  target_create_inferior (exec_file, get_inferior_args (),\n\t\t\t  environ_vector (inferior_environ), from_tty);\n\n  /* We're starting off a new process.  When we get out of here, in\n     non-stop mode, finish the state of all threads of that process,\n     but leave other threads alone, as they may be stopped in internal\n     events --- the frontend shouldn't see them as stopped.  In\n     all-stop, always finish the state of all threads, as we may be\n     resuming more than just the new process.  */\n  if (non_stop)\n    ptid = pid_to_ptid (ptid_get_pid (inferior_ptid));\n  else\n    ptid = minus_one_ptid;\n  old_chain = make_cleanup (finish_thread_state_cleanup, &ptid);\n\n  /* Pass zero for FROM_TTY, because at this point the \"run\" command\n     has done its thing; now we are setting up the running program.  */\n  post_create_inferior (&current_target, 0);\n\n  /* Start the target running.  */\n  proceed ((CORE_ADDR) -1, TARGET_SIGNAL_0, 0);\n\n  /* Since there was no error, there's no need to finish the thread\n     states here.  */\n  discard_cleanups (old_chain);\n}", "path": "gdb-7.0\\gdb\\infcmd.c", "repo_name": "joelagnel/gdb-kernel", "stars": 1, "license": "None", "language": "c", "size": 23464}
{"docstring": "/* finish_backward -- helper function for finish_command.  */\n", "func_signal": "static void\nfinish_backward (struct symbol *function)", "code": "{\n  struct symtab_and_line sal;\n  struct thread_info *tp = inferior_thread ();\n  struct breakpoint *breakpoint;\n  struct cleanup *old_chain;\n  CORE_ADDR pc;\n  CORE_ADDR func_addr;\n  int back_up;\n\n  pc = get_frame_pc (get_current_frame ());\n\n  if (find_pc_partial_function (pc, NULL, &func_addr, NULL) == 0)\n    internal_error (__FILE__, __LINE__,\n\t\t    _(\"Finish: couldn't find function.\"));\n\n  sal = find_pc_line (func_addr, 0);\n\n  /* We don't need a return value.  */\n  tp->proceed_to_finish = 0;\n  /* Special case: if we're sitting at the function entry point,\n     then all we need to do is take a reverse singlestep.  We\n     don't need to set a breakpoint, and indeed it would do us\n     no good to do so.\n\n     Note that this can only happen at frame #0, since there's\n     no way that a function up the stack can have a return address\n     that's equal to its entry point.  */\n\n  if (sal.pc != pc)\n    {\n      struct frame_info *frame = get_selected_frame (NULL);\n      struct gdbarch *gdbarch = get_frame_arch (frame);\n\n      /* Set breakpoint and continue.  */\n      breakpoint =\n\tset_momentary_breakpoint (gdbarch, sal,\n\t\t\t\t  get_stack_frame_id (frame),\n\t\t\t\t  bp_breakpoint);\n      /* Tell the breakpoint to keep quiet.  We won't be done\n         until we've done another reverse single-step.  */\n      make_breakpoint_silent (breakpoint);\n      old_chain = make_cleanup_delete_breakpoint (breakpoint);\n      proceed ((CORE_ADDR) -1, TARGET_SIGNAL_DEFAULT, 0);\n      /* We will be stopped when proceed returns.  */\n      back_up = bpstat_find_breakpoint (tp->stop_bpstat, breakpoint) != NULL;\n      do_cleanups (old_chain);\n    }\n  else\n    back_up = 1;\n  if (back_up)\n    {\n      /* If in fact we hit the step-resume breakpoint (and not\n\t some other breakpoint), then we're almost there --\n\t we just need to back up by one more single-step.  */\n      tp->step_range_start = tp->step_range_end = 1;\n      proceed ((CORE_ADDR) -1, TARGET_SIGNAL_DEFAULT, 1);\n    }\n  return;\n}", "path": "gdb-7.0\\gdb\\infcmd.c", "repo_name": "joelagnel/gdb-kernel", "stars": 1, "license": "None", "language": "c", "size": 23464}
{"docstring": "/* This function detects whether or not a '&' character (indicating\n   background execution) has been added as *the last* of the arguments ARGS\n   of a command. If it has, it removes it and returns 1. Otherwise it\n   does nothing and returns 0. */\n", "func_signal": "static int\nstrip_bg_char (char **args)", "code": "{\n  char *p = NULL;\n\n  p = strchr (*args, '&');\n\n  if (p)\n    {\n      if (p == (*args + strlen (*args) - 1))\n\t{\n\t  if (strlen (*args) > 1)\n\t    {\n\t      do\n\t\tp--;\n\t      while (*p == ' ' || *p == '\\t');\n\t      *(p + 1) = '\\0';\n\t    }\n\t  else\n\t    *args = 0;\n\t  return 1;\n\t}\n    }\n  return 0;\n}", "path": "gdb-7.0\\gdb\\infcmd.c", "repo_name": "joelagnel/gdb-kernel", "stars": 1, "license": "None", "language": "c", "size": 23464}
{"docstring": "/* Proceed until we reach a different source line with pc greater than\n   our current one or exit the function.  We skip calls in both cases.\n\n   Note that eventually this command should probably be changed so\n   that only source lines are printed out when we hit the breakpoint\n   we set.  This may involve changes to wait_for_inferior and the\n   proceed status code.  */\n", "func_signal": "static void\nuntil_next_command (int from_tty)", "code": "{\n  struct frame_info *frame;\n  CORE_ADDR pc;\n  struct symbol *func;\n  struct symtab_and_line sal;\n  struct thread_info *tp = inferior_thread ();\n\n  clear_proceed_status ();\n  set_step_frame ();\n\n  frame = get_current_frame ();\n\n  /* Step until either exited from this function or greater\n     than the current line (if in symbolic section) or pc (if\n     not). */\n\n  pc = get_frame_pc (frame);\n  func = find_pc_function (pc);\n\n  if (!func)\n    {\n      struct minimal_symbol *msymbol = lookup_minimal_symbol_by_pc (pc);\n\n      if (msymbol == NULL)\n\terror (_(\"Execution is not within a known function.\"));\n\n      tp->step_range_start = SYMBOL_VALUE_ADDRESS (msymbol);\n      tp->step_range_end = pc;\n    }\n  else\n    {\n      sal = find_pc_line (pc, 0);\n\n      tp->step_range_start = BLOCK_START (SYMBOL_BLOCK_VALUE (func));\n      tp->step_range_end = sal.end;\n    }\n\n  tp->step_over_calls = STEP_OVER_ALL;\n\n  tp->step_multi = 0;\t\t/* Only one call to proceed */\n\n  proceed ((CORE_ADDR) -1, TARGET_SIGNAL_DEFAULT, 1);\n}", "path": "gdb-7.0\\gdb\\infcmd.c", "repo_name": "joelagnel/gdb-kernel", "stars": 1, "license": "None", "language": "c", "size": 23464}
{"docstring": "/* Add zero or more directories to the front of the execution path.  */\n", "func_signal": "static void\npath_command (char *dirname, int from_tty)", "code": "{\n  char *exec_path;\n  char *env;\n  dont_repeat ();\n  env = get_in_environ (inferior_environ, path_var_name);\n  /* Can be null if path is not set */\n  if (!env)\n    env = \"\";\n  exec_path = xstrdup (env);\n  mod_path (dirname, &exec_path);\n  set_in_environ (inferior_environ, path_var_name, exec_path);\n  xfree (exec_path);\n  if (from_tty)\n    path_info ((char *) NULL, from_tty);\n}", "path": "gdb-7.0\\gdb\\infcmd.c", "repo_name": "joelagnel/gdb-kernel", "stars": 1, "license": "None", "language": "c", "size": 23464}
{"docstring": "/*\n * detach_command --\n * takes a program previously attached to and detaches it.\n * The program resumes execution and will no longer stop\n * on signals, etc.  We better not have left any breakpoints\n * in the program or it'll die when it hits one.  For this\n * to work, it may be necessary for the process to have been\n * previously attached.  It *might* work if the program was\n * started via the normal ptrace (PTRACE_TRACEME).\n */\n", "func_signal": "void\ndetach_command (char *args, int from_tty)", "code": "{\n  dont_repeat ();\t\t/* Not for the faint of heart.  */\n\n  if (ptid_equal (inferior_ptid, null_ptid))\n    error (_(\"The program is not being run.\"));\n\n  target_detach (args, from_tty);\n\n  /* If the solist is global across inferiors, don't clear it when we\n     detach from a single inferior.  */\n  if (!gdbarch_has_global_solist (target_gdbarch))\n    no_shared_libraries (NULL, from_tty);\n\n  /* If we still have inferiors to debug, then don't mess with their\n     threads.  */\n  if (!have_inferiors ())\n    init_thread_list ();\n\n  if (deprecated_detach_hook)\n    deprecated_detach_hook ();\n}", "path": "gdb-7.0\\gdb\\infcmd.c", "repo_name": "joelagnel/gdb-kernel", "stars": 1, "license": "None", "language": "c", "size": 23464}
{"docstring": "/* Compute command-line string given argument vector.  This does the\n   same shell processing as fork_inferior.  */\n", "func_signal": "char *\nconstruct_inferior_arguments (int argc, char **argv)", "code": "{\n  char *result;\n\n  if (STARTUP_WITH_SHELL)\n    {\n      /* This holds all the characters considered special to the\n\t typical Unix shells.  We include `^' because the SunOS\n\t /bin/sh treats it as a synonym for `|'.  */\n      char *special = \"\\\"!#$&*()\\\\|[]{}<>?'\\\"`~^; \\t\\n\";\n      int i;\n      int length = 0;\n      char *out, *cp;\n\n      /* We over-compute the size.  It shouldn't matter.  */\n      for (i = 0; i < argc; ++i)\n\tlength += 3 * strlen (argv[i]) + 1 + 2 * (argv[i][0] == '\\0');\n\n      result = (char *) xmalloc (length);\n      out = result;\n\n      for (i = 0; i < argc; ++i)\n\t{\n\t  if (i > 0)\n\t    *out++ = ' ';\n\n\t  /* Need to handle empty arguments specially.  */\n\t  if (argv[i][0] == '\\0')\n\t    {\n\t      *out++ = '\\'';\n\t      *out++ = '\\'';\n\t    }\n\t  else\n\t    {\n\t      for (cp = argv[i]; *cp; ++cp)\n\t\t{\n\t\t  if (*cp == '\\n')\n\t\t    {\n\t\t      /* A newline cannot be quoted with a backslash (it\n\t\t\t just disappears), only by putting it inside\n\t\t\t quotes.  */\n\t\t      *out++ = '\\'';\n\t\t      *out++ = '\\n';\n\t\t      *out++ = '\\'';\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      if (strchr (special, *cp) != NULL)\n\t\t\t*out++ = '\\\\';\n\t\t      *out++ = *cp;\n\t\t    }\n\t\t}\n\t    }\n\t}\n      *out = '\\0';\n    }\n  else\n    {\n      /* In this case we can't handle arguments that contain spaces,\n\t tabs, or newlines -- see breakup_args().  */\n      int i;\n      int length = 0;\n\n      for (i = 0; i < argc; ++i)\n\t{\n\t  char *cp = strchr (argv[i], ' ');\n\t  if (cp == NULL)\n\t    cp = strchr (argv[i], '\\t');\n\t  if (cp == NULL)\n\t    cp = strchr (argv[i], '\\n');\n\t  if (cp != NULL)\n\t    error (_(\"can't handle command-line argument containing whitespace\"));\n\t  length += strlen (argv[i]) + 1;\n\t}\n\n      result = (char *) xmalloc (length);\n      result[0] = '\\0';\n      for (i = 0; i < argc; ++i)\n\t{\n\t  if (i > 0)\n\t    strcat (result, \" \");\n\t  strcat (result, argv[i]);\n\t}\n    }\n\n  return result;\n}", "path": "gdb-7.0\\gdb\\infcmd.c", "repo_name": "joelagnel/gdb-kernel", "stars": 1, "license": "None", "language": "c", "size": 23464}
{"docstring": "/* Start the execution of the program up until the beginning of the main\n   program.  */\n", "func_signal": "static void\nstart_command (char *args, int from_tty)", "code": "{\n  /* Some languages such as Ada need to search inside the program\n     minimal symbols for the location where to put the temporary\n     breakpoint before starting.  */\n  if (!have_minimal_symbols ())\n    error (_(\"No symbol table loaded.  Use the \\\"file\\\" command.\"));\n\n  /* Run the program until reaching the main procedure...  */\n  run_command_1 (args, from_tty, 1);\n}", "path": "gdb-7.0\\gdb\\infcmd.c", "repo_name": "joelagnel/gdb-kernel", "stars": 1, "license": "None", "language": "c", "size": 23464}
{"docstring": "/* Called after we are done with one step operation, to check whether\n   we need to step again, before we print the prompt and return control\n   to the user. If count is > 1, we will need to do one more call to\n   proceed(), via step_once(). Basically it is like step_once and\n   step_1_continuation are co-recursive. */\n", "func_signal": "static void\nstep_1_continuation (void *args)", "code": "{\n  struct step_1_continuation_args *a = args;\n\n  if (target_has_execution)\n    {\n      struct thread_info *tp;\n\n      tp = inferior_thread ();\n      if (tp->step_multi && tp->stop_step)\n\t{\n\t  /* There are more steps to make, and we did stop due to\n\t     ending a stepping range.  Do another step.  */\n\t  step_once (a->skip_subroutines, a->single_inst,\n\t\t     a->count - 1, a->thread);\n\t  return;\n\t}\n      tp->step_multi = 0;\n    }\n\n  /* We either stopped for some reason that is not stepping, or there\n     are no further steps to make.  Cleanup.  */\n  if (!a->single_inst || a->skip_subroutines)\n    delete_longjmp_breakpoint (a->thread);\n}", "path": "gdb-7.0\\gdb\\infcmd.c", "repo_name": "joelagnel/gdb-kernel", "stars": 1, "license": "None", "language": "c", "size": 23464}
{"docstring": "/* \"finish\": Set a temporary breakpoint at the place the selected\n   frame will return to, then continue.  */\n", "func_signal": "static void\nfinish_command (char *arg, int from_tty)", "code": "{\n  struct frame_info *frame;\n  struct symbol *function;\n\n  int async_exec = 0;\n\n  /* Find out whether we must run in the background.  */\n  if (arg != NULL)\n    async_exec = strip_bg_char (&arg);\n\n  /* If we must run in the background, but the target can't do it,\n     error out.  */\n  if (async_exec && !target_can_async_p ())\n    error (_(\"Asynchronous execution not supported on this target.\"));\n\n  /* Don't try to async in reverse.  */\n  if (async_exec && execution_direction == EXEC_REVERSE)\n    error (_(\"Asynchronous 'finish' not supported in reverse.\"));\n\n  /* If we are not asked to run in the bg, then prepare to run in the\n     foreground, synchronously.  */\n  if (!async_exec && target_can_async_p ())\n    {\n      /* Simulate synchronous execution.  */\n      async_disable_stdin ();\n    }\n\n  if (arg)\n    error (_(\"The \\\"finish\\\" command does not take any arguments.\"));\n  if (!target_has_execution)\n    error (_(\"The program is not running.\"));\n\n  frame = get_prev_frame (get_selected_frame (_(\"No selected frame.\")));\n  if (frame == 0)\n    error (_(\"\\\"finish\\\" not meaningful in the outermost frame.\"));\n\n  clear_proceed_status ();\n\n  /* Finishing from an inline frame is completely different.  We don't\n     try to show the \"return value\" - no way to locate it.  So we do\n     not need a completion.  */\n  if (get_frame_type (get_selected_frame (_(\"No selected frame.\")))\n      == INLINE_FRAME)\n    {\n      /* Claim we are stepping in the calling frame.  An empty step\n\t range means that we will stop once we aren't in a function\n\t called by that frame.  We don't use the magic \"1\" value for\n\t step_range_end, because then infrun will think this is nexti,\n\t and not step over the rest of this inlined function call.  */\n      struct thread_info *tp = inferior_thread ();\n      struct symtab_and_line empty_sal;\n      init_sal (&empty_sal);\n      set_step_info (frame, empty_sal);\n      tp->step_range_start = tp->step_range_end = get_frame_pc (frame);\n      tp->step_over_calls = STEP_OVER_ALL;\n\n      /* Print info on the selected frame, including level number but not\n\t source.  */\n      if (from_tty)\n\t{\n\t  printf_filtered (_(\"Run till exit from \"));\n\t  print_stack_frame (get_selected_frame (NULL), 1, LOCATION);\n\t}\n\n      proceed ((CORE_ADDR) -1, TARGET_SIGNAL_DEFAULT, 1);\n      return;\n    }\n\n  /* Find the function we will return from.  */\n\n  function = find_pc_function (get_frame_pc (get_selected_frame (NULL)));\n\n  /* Print info on the selected frame, including level number but not\n     source.  */\n  if (from_tty)\n    {\n      if (execution_direction == EXEC_REVERSE)\n\tprintf_filtered (_(\"Run back to call of \"));\n      else\n\tprintf_filtered (_(\"Run till exit from \"));\n\n      print_stack_frame (get_selected_frame (NULL), 1, LOCATION);\n    }\n\n  if (execution_direction == EXEC_REVERSE)\n    finish_backward (function);\n  else\n    finish_forward (function, frame);\n}", "path": "gdb-7.0\\gdb\\infcmd.c", "repo_name": "joelagnel/gdb-kernel", "stars": 1, "license": "None", "language": "c", "size": 23464}
{"docstring": "/* Continue program at specified address.  */\n", "func_signal": "static void\njump_command (char *arg, int from_tty)", "code": "{\n  struct gdbarch *gdbarch = get_current_arch ();\n  CORE_ADDR addr;\n  struct symtabs_and_lines sals;\n  struct symtab_and_line sal;\n  struct symbol *fn;\n  struct symbol *sfn;\n  int async_exec = 0;\n\n  ERROR_NO_INFERIOR;\n  ensure_valid_thread ();\n  ensure_not_running ();\n\n  /* Find out whether we must run in the background. */\n  if (arg != NULL)\n    async_exec = strip_bg_char (&arg);\n\n  /* If we must run in the background, but the target can't do it,\n     error out. */\n  if (async_exec && !target_can_async_p ())\n    error (_(\"Asynchronous execution not supported on this target.\"));\n\n  if (!arg)\n    error_no_arg (_(\"starting address\"));\n\n  sals = decode_line_spec_1 (arg, 1);\n  if (sals.nelts != 1)\n    {\n      error (_(\"Unreasonable jump request\"));\n    }\n\n  sal = sals.sals[0];\n  xfree (sals.sals);\n\n  if (sal.symtab == 0 && sal.pc == 0)\n    error (_(\"No source file has been specified.\"));\n\n  resolve_sal_pc (&sal);\t/* May error out */\n\n  /* See if we are trying to jump to another function. */\n  fn = get_frame_function (get_current_frame ());\n  sfn = find_pc_function (sal.pc);\n  if (fn != NULL && sfn != fn)\n    {\n      if (!query (_(\"Line %d is not in `%s'.  Jump anyway? \"), sal.line,\n\t\t  SYMBOL_PRINT_NAME (fn)))\n\t{\n\t  error (_(\"Not confirmed.\"));\n\t  /* NOTREACHED */\n\t}\n    }\n\n  if (sfn != NULL)\n    {\n      fixup_symbol_section (sfn, 0);\n      if (section_is_overlay (SYMBOL_OBJ_SECTION (sfn)) &&\n\t  !section_is_mapped (SYMBOL_OBJ_SECTION (sfn)))\n\t{\n\t  if (!query (_(\"WARNING!!!  Destination is in unmapped overlay!  Jump anyway? \")))\n\t    {\n\t      error (_(\"Not confirmed.\"));\n\t      /* NOTREACHED */\n\t    }\n\t}\n    }\n\n  addr = sal.pc;\n\n  if (from_tty)\n    {\n      printf_filtered (_(\"Continuing at \"));\n      fputs_filtered (paddress (gdbarch, addr), gdb_stdout);\n      printf_filtered (\".\\n\");\n    }\n\n  /* If we are not asked to run in the bg, then prepare to run in the\n     foreground, synchronously. */\n  if (!async_exec && target_can_async_p ())\n    {\n      /* Simulate synchronous execution */\n      async_disable_stdin ();\n    }\n\n  clear_proceed_status ();\n  proceed (addr, TARGET_SIGNAL_0, 0);\n}", "path": "gdb-7.0\\gdb\\infcmd.c", "repo_name": "joelagnel/gdb-kernel", "stars": 1, "license": "None", "language": "c", "size": 23464}
{"docstring": "/* Notice when `set args' is run.  */\n", "func_signal": "static void\nnotice_args_set (char *args, int from_tty, struct cmd_list_element *c)", "code": "{\n  inferior_argc = 0;\n  inferior_argv = 0;\n}", "path": "gdb-7.0\\gdb\\infcmd.c", "repo_name": "joelagnel/gdb-kernel", "stars": 1, "license": "None", "language": "c", "size": 23464}
{"docstring": "/*\n   attach_command --\n   takes a program started up outside of gdb and ``attaches'' to it.\n   This stops it cold in its tracks and allows us to start debugging it.\n   and wait for the trace-trap that results from attaching.  */\n", "func_signal": "static void\nattach_command_post_wait (char *args, int from_tty, int async_exec)", "code": "{\n  char *exec_file;\n  char *full_exec_path = NULL;\n  struct inferior *inferior;\n\n  inferior = current_inferior ();\n  inferior->stop_soon = NO_STOP_QUIETLY;\n\n  /* If no exec file is yet known, try to determine it from the\n     process itself.  */\n  exec_file = (char *) get_exec_file (0);\n  if (!exec_file)\n    {\n      exec_file = target_pid_to_exec_file (PIDGET (inferior_ptid));\n      if (exec_file)\n\t{\n\t  /* It's possible we don't have a full path, but rather just a\n\t     filename.  Some targets, such as HP-UX, don't provide the\n\t     full path, sigh.\n\n\t     Attempt to qualify the filename against the source path.\n\t     (If that fails, we'll just fall back on the original\n\t     filename.  Not much more we can do...)\n\t   */\n\t  if (!source_full_path_of (exec_file, &full_exec_path))\n\t    full_exec_path = xstrdup (exec_file);\n\n\t  exec_file_attach (full_exec_path, from_tty);\n\t  symbol_file_add_main (full_exec_path, from_tty);\n\t}\n    }\n  else\n    {\n      reopen_exec_file ();\n      reread_symbols ();\n    }\n\n  /* Take any necessary post-attaching actions for this platform.  */\n  target_post_attach (PIDGET (inferior_ptid));\n\n  post_create_inferior (&current_target, from_tty);\n\n  /* Install inferior's terminal modes.  */\n  target_terminal_inferior ();\n\n  if (async_exec)\n    {\n      /* The user requested an `attach&', so be sure to leave threads\n\t that didn't get a signal running.  */\n\n      /* Immediatelly resume all suspended threads of this inferior,\n\t and this inferior only.  This should have no effect on\n\t already running threads.  If a thread has been stopped with a\n\t signal, leave it be.  */\n      if (non_stop)\n\tproceed_after_attach (inferior->pid);\n      else\n\t{\n\t  if (inferior_thread ()->stop_signal == TARGET_SIGNAL_0)\n\t    {\n\t      clear_proceed_status ();\n\t      proceed ((CORE_ADDR) -1, TARGET_SIGNAL_DEFAULT, 0);\n\t    }\n\t}\n    }\n  else\n    {\n      /* The user requested a plain `attach', so be sure to leave\n\t the inferior stopped.  */\n\n      if (target_can_async_p ())\n\tasync_enable_stdin ();\n\n      /* At least the current thread is already stopped.  */\n\n      /* In all-stop, by definition, all threads have to be already\n\t stopped at this point.  In non-stop, however, although the\n\t selected thread is stopped, others may still be executing.\n\t Be sure to explicitly stop all threads of the process.  This\n\t should have no effect on already stopped threads.  */\n      if (non_stop)\n\ttarget_stop (pid_to_ptid (inferior->pid));\n\n      /* Tell the user/frontend where we're stopped.  */\n      normal_stop ();\n      if (deprecated_attach_hook)\n\tdeprecated_attach_hook ();\n    }\n}", "path": "gdb-7.0\\gdb\\infcmd.c", "repo_name": "joelagnel/gdb-kernel", "stars": 1, "license": "None", "language": "c", "size": 23464}
{"docstring": "/* Accessor routines. */\n", "func_signal": "void \nset_inferior_io_terminal (const char *terminal_name)", "code": "{\n  if (inferior_io_terminal)\n    xfree (inferior_io_terminal);\n\n  if (!terminal_name)\n    inferior_io_terminal = NULL;\n  else\n    inferior_io_terminal = xstrdup (terminal_name);\n}", "path": "gdb-7.0\\gdb\\infcmd.c", "repo_name": "joelagnel/gdb-kernel", "stars": 1, "license": "None", "language": "c", "size": 23464}
{"docstring": "/* Kill the inferior if already running.  This function is designed\n   to be called when we are about to start the execution of the program\n   from the beginning.  Ask the user to confirm that he wants to restart\n   the program being debugged when FROM_TTY is non-null.  */\n", "func_signal": "static void\nkill_if_already_running (int from_tty)", "code": "{\n  if (! ptid_equal (inferior_ptid, null_ptid) && target_has_execution)\n    {\n      /* Bail out before killing the program if we will not be able to\n\t restart it.  */\n      target_require_runnable ();\n\n      if (from_tty\n\t  && !query (_(\"The program being debugged has been started already.\\n\\\nStart it from the beginning? \")))\n\terror (_(\"Program not restarted.\"));\n      target_kill ();\n    }\n}", "path": "gdb-7.0\\gdb\\infcmd.c", "repo_name": "joelagnel/gdb-kernel", "stars": 1, "license": "None", "language": "c", "size": 23464}
{"docstring": "/* Record the starting point of a \"step\" or \"next\" command.  */\n", "func_signal": "static void\nset_step_frame (void)", "code": "{\n  struct symtab_and_line sal;\n\n  find_frame_sal (get_current_frame (), &sal);\n  set_step_info (get_current_frame (), sal);\n}", "path": "gdb-7.0\\gdb\\infcmd.c", "repo_name": "joelagnel/gdb-kernel", "stars": 1, "license": "None", "language": "c", "size": 23464}
{"docstring": "/* continue [-a] [proceed-count] [&]  */\n", "func_signal": "void\ncontinue_command (char *args, int from_tty)", "code": "{\n  int async_exec = 0;\n  int all_threads = 0;\n  ERROR_NO_INFERIOR;\n\n  /* Find out whether we must run in the background. */\n  if (args != NULL)\n    async_exec = strip_bg_char (&args);\n\n  /* If we must run in the background, but the target can't do it,\n     error out. */\n  if (async_exec && !target_can_async_p ())\n    error (_(\"Asynchronous execution not supported on this target.\"));\n\n  /* If we are not asked to run in the bg, then prepare to run in the\n     foreground, synchronously. */\n  if (!async_exec && target_can_async_p ())\n    {\n      /* Simulate synchronous execution */\n      async_disable_stdin ();\n    }\n\n  if (args != NULL)\n    {\n      if (strncmp (args, \"-a\", sizeof (\"-a\") - 1) == 0)\n\t{\n\t  all_threads = 1;\n\t  args += sizeof (\"-a\") - 1;\n\t  if (*args == '\\0')\n\t    args = NULL;\n\t}\n    }\n\n  if (!non_stop && all_threads)\n    error (_(\"`-a' is meaningless in all-stop mode.\"));\n\n  if (args != NULL && all_threads)\n    error (_(\"\\\nCan't resume all threads and specify proceed count simultaneously.\"));\n\n  /* If we have an argument left, set proceed count of breakpoint we\n     stopped at.  */\n  if (args != NULL)\n    {\n      bpstat bs = NULL;\n      int num, stat;\n      int stopped = 0;\n      struct thread_info *tp;\n\n      if (non_stop)\n\ttp = find_thread_ptid (inferior_ptid);\n      else\n\t{\n\t  ptid_t last_ptid;\n\t  struct target_waitstatus ws;\n\n\t  get_last_target_status (&last_ptid, &ws);\n\t  tp = find_thread_ptid (last_ptid);\n\t}\n      if (tp != NULL)\n\tbs = tp->stop_bpstat;\n\n      while ((stat = bpstat_num (&bs, &num)) != 0)\n\tif (stat > 0)\n\t  {\n\t    set_ignore_count (num,\n\t\t\t      parse_and_eval_long (args) - 1,\n\t\t\t      from_tty);\n\t    /* set_ignore_count prints a message ending with a period.\n\t       So print two spaces before \"Continuing.\".  */\n\t    if (from_tty)\n\t      printf_filtered (\"  \");\n\t    stopped = 1;\n\t  }\n\n      if (!stopped && from_tty)\n\t{\n\t  printf_filtered\n\t    (\"Not stopped at any breakpoint; argument ignored.\\n\");\n\t}\n    }\n\n  if (from_tty)\n    printf_filtered (_(\"Continuing.\\n\"));\n\n  continue_1 (all_threads);\n}", "path": "gdb-7.0\\gdb\\infcmd.c", "repo_name": "joelagnel/gdb-kernel", "stars": 1, "license": "None", "language": "c", "size": 23464}
{"docstring": "/* Kill the inferior process.  Make us have no inferior.  */\n", "func_signal": "static void\nkill_command (char *arg, int from_tty)", "code": "{\n  /* FIXME:  This should not really be inferior_ptid (or target_has_execution).\n     It should be a distinct flag that indicates that a target is active, cuz\n     some targets don't have processes! */\n\n  if (ptid_equal (inferior_ptid, null_ptid))\n    error (_(\"The program is not being run.\"));\n  if (!query (_(\"Kill the program being debugged? \")))\n    error (_(\"Not confirmed.\"));\n  target_kill ();\n\n  /* If we still have other inferiors to debug, then don't mess with\n     with their threads.  */\n  if (!have_inferiors ())\n    {\n      init_thread_list ();\t\t/* Destroy thread info */\n\n      /* Killing off the inferior can leave us with a core file.  If\n\t so, print the state we are left in.  */\n      if (target_has_stack)\n\t{\n\t  printf_filtered (_(\"In %s,\\n\"), target_longname);\n\t  print_stack_frame (get_selected_frame (NULL), 1, SRC_AND_LOC);\n\t}\n    }\n  bfd_cache_close_all ();\n}", "path": "gdb-7.0\\gdb\\infcmd.c", "repo_name": "joelagnel/gdb-kernel", "stars": 1, "license": "None", "language": "c", "size": 23464}
{"docstring": "/* look for an empty DAC slot */\n", "func_signal": "static hda_nid_t alc662_look_for_dac(struct hda_codec *codec, hda_nid_t pin)", "code": "{\n\tstruct alc_spec *spec = codec->spec;\n\thda_nid_t srcs[5];\n\tint i, j, num;\n\n\tnum = snd_hda_get_connections(codec, pin, srcs, ARRAY_SIZE(srcs));\n\tif (num < 0)\n\t\treturn 0;\n\tfor (i = 0; i < num; i++) {\n\t\thda_nid_t nid = alc662_mix_to_dac(srcs[i]);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tfor (j = 0; j < spec->multiout.num_dacs; j++)\n\t\t\tif (spec->multiout.dac_nids[j] == nid)\n\t\t\t\tbreak;\n\t\tif (j >= spec->multiout.num_dacs)\n\t\t\treturn nid;\n\t}\n\treturn 0;\n}", "path": "patch_realtek.c", "repo_name": "PabloCastellano/sound-2.6-hptx2000", "stars": 1, "license": "None", "language": "c", "size": 204}
{"docstring": "/* create input playback/capture controls for the given pin */\n", "func_signal": "static int alc268_new_analog_output(struct alc_spec *spec, hda_nid_t nid,\n\t\t\t\t    const char *ctlname, int idx)", "code": "{\n\thda_nid_t dac;\n\tint err;\n\n\tswitch (nid) {\n\tcase 0x14:\n\tcase 0x16:\n\t\tdac = 0x02;\n\t\tbreak;\n\tcase 0x15:\n\tcase 0x21:\n\t\tdac = 0x03;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif (spec->multiout.dac_nids[0] != dac &&\n\t    spec->multiout.dac_nids[1] != dac) {\n\t\terr = add_pb_vol_ctrl(spec, ALC_CTL_WIDGET_VOL, ctlname,\n\t\t\t\t  HDA_COMPOSE_AMP_VAL(dac, 3, idx,\n\t\t\t\t\t\t      HDA_OUTPUT));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tspec->multiout.dac_nids[spec->multiout.num_dacs++] = dac;\n\t}\n\n\tif (nid != 0x16)\n\t\terr = add_pb_sw_ctrl(spec, ALC_CTL_WIDGET_MUTE, ctlname,\n\t\t\t  HDA_COMPOSE_AMP_VAL(nid, 3, idx, HDA_OUTPUT));\n\telse /* mono */\n\t\terr = add_pb_sw_ctrl(spec, ALC_CTL_WIDGET_MUTE, ctlname,\n\t\t\t  HDA_COMPOSE_AMP_VAL(nid, 2, idx, HDA_OUTPUT));\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}", "path": "patch_realtek.c", "repo_name": "PabloCastellano/sound-2.6-hptx2000", "stars": 1, "license": "None", "language": "c", "size": 204}
{"docstring": "/* additional initialization for auto-configuration model */\n", "func_signal": "static void alc260_auto_init(struct hda_codec *codec)", "code": "{\n\tstruct alc_spec *spec = codec->spec;\n\talc260_auto_init_multi_out(codec);\n\talc260_auto_init_analog_input(codec);\n\tif (spec->unsol_event)\n\t\talc_inithook(codec);\n}", "path": "patch_realtek.c", "repo_name": "PabloCastellano/sound-2.6-hptx2000", "stars": 1, "license": "None", "language": "c", "size": 204}
{"docstring": "/*\n * BIOS auto configuration\n */\n", "func_signal": "static int alc269_parse_auto_config(struct hda_codec *codec)", "code": "{\n\tstruct alc_spec *spec = codec->spec;\n\tint err;\n\tstatic hda_nid_t alc269_ignore[] = { 0x1d, 0 };\n\thda_nid_t real_capsrc_nids;\n\n\terr = snd_hda_parse_pin_def_config(codec, &spec->autocfg,\n\t\t\t\t\t   alc269_ignore);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = alc269_auto_create_multi_out_ctls(spec, &spec->autocfg);\n\tif (err < 0)\n\t\treturn err;\n\terr = alc269_auto_create_input_ctls(codec, &spec->autocfg);\n\tif (err < 0)\n\t\treturn err;\n\n\tspec->multiout.max_channels = spec->multiout.num_dacs * 2;\n\n\tif (spec->autocfg.dig_outs)\n\t\tspec->multiout.dig_out_nid = ALC269_DIGOUT_NID;\n\n\tif (spec->kctls.list)\n\t\tadd_mixer(spec, spec->kctls.list);\n\n\tif ((alc_read_coef_idx(codec, 0) & 0x00f0) == 0x0010) {\n\t\tadd_verb(spec, alc269vb_init_verbs);\n\t\treal_capsrc_nids = alc269vb_capsrc_nids[0];\n\t\talc_ssid_check(codec, 0x21, 0x1b, 0x14);\n\t} else {\n\t\tadd_verb(spec, alc269_init_verbs);\n\t\treal_capsrc_nids = alc269_capsrc_nids[0];\n\t\talc_ssid_check(codec, 0x15, 0x1b, 0x14);\n\t}\n\n\tspec->num_mux_defs = 1;\n\tspec->input_mux = &spec->private_imux[0];\n\t/* set default input source */\n\tsnd_hda_codec_write_cache(codec, real_capsrc_nids,\n\t\t\t\t  0, AC_VERB_SET_CONNECT_SEL,\n\t\t\t\t  spec->input_mux->items[0].index);\n\n\terr = alc_auto_add_mic_boost(codec);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!spec->cap_mixer && !spec->no_analog)\n\t\tset_capture_mixer(codec);\n\n\treturn 1;\n}", "path": "patch_realtek.c", "repo_name": "PabloCastellano/sound-2.6-hptx2000", "stars": 1, "license": "None", "language": "c", "size": 204}
{"docstring": "/* additional initialization for auto-configuration model */\n", "func_signal": "static void alc880_auto_init(struct hda_codec *codec)", "code": "{\n\tstruct alc_spec *spec = codec->spec;\n\talc880_auto_init_multi_out(codec);\n\talc880_auto_init_extra_out(codec);\n\talc880_auto_init_analog_input(codec);\n\tif (spec->unsol_event)\n\t\talc_inithook(codec);\n}", "path": "patch_realtek.c", "repo_name": "PabloCastellano/sound-2.6-hptx2000", "stars": 1, "license": "None", "language": "c", "size": 204}
{"docstring": "/*\n * Common callbacks\n */\n", "func_signal": "static int alc_init(struct hda_codec *codec)", "code": "{\n\tstruct alc_spec *spec = codec->spec;\n\tunsigned int i;\n\n\talc_fix_pll(codec);\n\talc_auto_init_amp(codec, spec->init_amp);\n\n\tfor (i = 0; i < spec->num_init_verbs; i++)\n\t\tsnd_hda_sequence_write(codec, spec->init_verbs[i]);\n\n\tif (spec->init_hook)\n\t\tspec->init_hook(codec);\n\n\treturn 0;\n}", "path": "patch_realtek.c", "repo_name": "PabloCastellano/sound-2.6-hptx2000", "stars": 1, "license": "None", "language": "c", "size": 204}
{"docstring": "/* fill in the dac_nids table from the parsed pin configuration */\n", "func_signal": "static int alc861_auto_fill_dac_nids(struct hda_codec *codec,\n\t\t\t\t     const struct auto_pin_cfg *cfg)", "code": "{\n\tstruct alc_spec *spec = codec->spec;\n\tint i;\n\thda_nid_t nid, dac;\n\n\tspec->multiout.dac_nids = spec->private_dac_nids;\n\tfor (i = 0; i < cfg->line_outs; i++) {\n\t\tnid = cfg->line_out_pins[i];\n\t\tdac = alc861_look_for_dac(codec, nid);\n\t\tif (!dac)\n\t\t\tcontinue;\n\t\tspec->multiout.dac_nids[spec->multiout.num_dacs++] = dac;\n\t}\n\treturn 0;\n}", "path": "patch_realtek.c", "repo_name": "PabloCastellano/sound-2.6-hptx2000", "stars": 1, "license": "None", "language": "c", "size": 204}
{"docstring": "/* add playback controls for speaker and HP outputs */\n/* return DAC nid if any new DAC is assigned */\n", "func_signal": "static int alc662_auto_create_extra_out(struct hda_codec *codec, hda_nid_t pin,\n\t\t\t\t\tconst char *pfx)", "code": "{\n\tstruct alc_spec *spec = codec->spec;\n\thda_nid_t nid, mix;\n\tint err;\n\n\tif (!pin)\n\t\treturn 0;\n\tnid = alc662_look_for_dac(codec, pin);\n\tif (!nid) {\n\t\t/* the corresponding DAC is already occupied */\n\t\tif (!(get_wcaps(codec, pin) & AC_WCAP_OUT_AMP))\n\t\t\treturn 0; /* no way */\n\t\t/* create a switch only */\n\t\treturn add_pb_sw_ctrl(spec, ALC_CTL_WIDGET_MUTE, pfx,\n\t\t\t\t   HDA_COMPOSE_AMP_VAL(pin, 3, 0, HDA_OUTPUT));\n\t}\n\n\tmix = alc662_dac_to_mix(codec, pin, nid);\n\tif (!mix)\n\t\treturn 0;\n\terr = alc662_add_vol_ctl(spec, pfx, nid, 3);\n\tif (err < 0)\n\t\treturn err;\n\terr = alc662_add_sw_ctl(spec, pfx, mix, 3);\n\tif (err < 0)\n\t\treturn err;\n\treturn nid;\n}", "path": "patch_realtek.c", "repo_name": "PabloCastellano/sound-2.6-hptx2000", "stars": 1, "license": "None", "language": "c", "size": 204}
{"docstring": "/* turn on/off EAPD control (only if available) */\n", "func_signal": "static void set_eapd(struct hda_codec *codec, hda_nid_t nid, int on)", "code": "{\n\tif (get_wcaps_type(get_wcaps(codec, nid)) != AC_WID_PIN)\n\t\treturn;\n\tif (snd_hda_query_pin_caps(codec, nid) & AC_PINCAP_EAPD)\n\t\tsnd_hda_codec_write(codec, nid, 0, AC_VERB_SET_EAPD_BTLENABLE,\n\t\t\t\t    on ? 2 : 0);\n}", "path": "patch_realtek.c", "repo_name": "PabloCastellano/sound-2.6-hptx2000", "stars": 1, "license": "None", "language": "c", "size": 204}
{"docstring": "/*\n * channel mode setting\n */\n", "func_signal": "static int alc_ch_mode_info(struct snd_kcontrol *kcontrol,\n\t\t\t    struct snd_ctl_elem_info *uinfo)", "code": "{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\tstruct alc_spec *spec = codec->spec;\n\treturn snd_hda_ch_mode_info(codec, uinfo, spec->channel_mode,\n\t\t\t\t    spec->num_channel_mode);\n}", "path": "patch_realtek.c", "repo_name": "PabloCastellano/sound-2.6-hptx2000", "stars": 1, "license": "None", "language": "c", "size": 204}
{"docstring": "/* choose the ADC/MUX containing the input pin and initialize the setup */\n", "func_signal": "static void fixup_single_adc(struct hda_codec *codec)", "code": "{\n\tstruct alc_spec *spec = codec->spec;\n\thda_nid_t pin;\n\tint i;\n\n\t/* search for the input pin; there must be only one */\n\tfor (i = 0; i < AUTO_PIN_LAST; i++) {\n\t\tif (spec->autocfg.input_pins[i]) {\n\t\t\tpin = spec->autocfg.input_pins[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!pin)\n\t\treturn;\n\n\t/* set the default connection to that pin */\n\tfor (i = 0; i < spec->num_adc_nids; i++) {\n\t\thda_nid_t cap = spec->capsrc_nids ?\n\t\t\tspec->capsrc_nids[i] : spec->adc_nids[i];\n\t\tint idx;\n\n\t\tidx = get_connection_index(codec, cap, pin);\n\t\tif (idx < 0)\n\t\t\tcontinue;\n\t\t/* use only this ADC */\n\t\tif (spec->capsrc_nids)\n\t\t\tspec->capsrc_nids += i;\n\t\tspec->adc_nids += i;\n\t\tspec->num_adc_nids = 1;\n\t\t/* select or unmute this route */\n\t\tif (get_wcaps_type(get_wcaps(codec, cap)) == AC_WID_AUD_MIX) {\n\t\t\tsnd_hda_codec_amp_stereo(codec, cap, HDA_INPUT, idx,\n\t\t\t\t\t\t HDA_AMP_MUTE, 0);\n\t\t} else {\n\t\t\tsnd_hda_codec_write_cache(codec, cap, 0,\n\t\t\t\t\t  AC_VERB_SET_CONNECT_SEL, idx);\n\t\t}\n\t\treturn;\n\t}\n}", "path": "patch_realtek.c", "repo_name": "PabloCastellano/sound-2.6-hptx2000", "stars": 1, "license": "None", "language": "c", "size": 204}
{"docstring": "/* unsolicited event for HP jack sensing */\n", "func_signal": "static void alc662_eeepc_unsol_event(struct hda_codec *codec,\n\t\t\t\t     unsigned int res)", "code": "{\n\tif ((res >> 26) == ALC880_MIC_EVENT)\n\t\talc_mic_automute(codec);\n\telse\n\t\talc262_hippo_unsol_event(codec, res);\n}", "path": "patch_realtek.c", "repo_name": "PabloCastellano/sound-2.6-hptx2000", "stars": 1, "license": "None", "language": "c", "size": 204}
{"docstring": "/*\n * for BIOS auto-configuration\n */\n", "func_signal": "static int alc260_add_playback_controls(struct alc_spec *spec, hda_nid_t nid,\n\t\t\t\t\tconst char *pfx, int *vol_bits)", "code": "{\n\thda_nid_t nid_vol;\n\tunsigned long vol_val, sw_val;\n\tint err;\n\n\tif (nid >= 0x0f && nid < 0x11) {\n\t\tnid_vol = nid - 0x7;\n\t\tvol_val = HDA_COMPOSE_AMP_VAL(nid_vol, 3, 0, HDA_OUTPUT);\n\t\tsw_val = HDA_COMPOSE_AMP_VAL(nid, 3, 0, HDA_OUTPUT);\n\t} else if (nid == 0x11) {\n\t\tnid_vol = nid - 0x7;\n\t\tvol_val = HDA_COMPOSE_AMP_VAL(nid_vol, 2, 0, HDA_OUTPUT);\n\t\tsw_val = HDA_COMPOSE_AMP_VAL(nid, 2, 0, HDA_OUTPUT);\n\t} else if (nid >= 0x12 && nid <= 0x15) {\n\t\tnid_vol = 0x08;\n\t\tvol_val = HDA_COMPOSE_AMP_VAL(nid_vol, 3, 0, HDA_OUTPUT);\n\t\tsw_val = HDA_COMPOSE_AMP_VAL(nid, 3, 0, HDA_OUTPUT);\n\t} else\n\t\treturn 0; /* N/A */\n\n\tif (!(*vol_bits & (1 << nid_vol))) {\n\t\t/* first control for the volume widget */\n\t\terr = add_pb_vol_ctrl(spec, ALC_CTL_WIDGET_VOL, pfx, vol_val);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\t*vol_bits |= (1 << nid_vol);\n\t}\n\terr = add_pb_sw_ctrl(spec, ALC_CTL_WIDGET_MUTE, pfx, sw_val);\n\tif (err < 0)\n\t\treturn err;\n\treturn 1;\n}", "path": "patch_realtek.c", "repo_name": "PabloCastellano/sound-2.6-hptx2000", "stars": 1, "license": "None", "language": "c", "size": 204}
{"docstring": "/* ***************** Mode3 ******************************/\n", "func_signal": "static void alc663_mode3_unsol_event(struct hda_codec *codec,\n\t\t\t\t\t   unsigned int res)", "code": "{\n\tswitch (res >> 26) {\n\tcase ALC880_HP_EVENT:\n\t\talc663_two_hp_m1_speaker_automute(codec);\n\t\tbreak;\n\tcase ALC880_MIC_EVENT:\n\t\talc_mic_automute(codec);\n\t\tbreak;\n\t}\n}", "path": "patch_realtek.c", "repo_name": "PabloCastellano/sound-2.6-hptx2000", "stars": 1, "license": "None", "language": "c", "size": 204}
{"docstring": "/* add mic boosts if needed */\n", "func_signal": "static int alc_auto_add_mic_boost(struct hda_codec *codec)", "code": "{\n\tstruct alc_spec *spec = codec->spec;\n\tint err;\n\thda_nid_t nid;\n\n\tnid = spec->autocfg.input_pins[AUTO_PIN_MIC];\n\tif (nid && (get_wcaps(codec, nid) & AC_WCAP_IN_AMP)) {\n\t\terr = add_control(spec, ALC_CTL_WIDGET_VOL,\n\t\t\t\t  \"Mic Boost\",\n\t\t\t\t  HDA_COMPOSE_AMP_VAL(nid, 3, 0, HDA_INPUT));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tnid = spec->autocfg.input_pins[AUTO_PIN_FRONT_MIC];\n\tif (nid && (get_wcaps(codec, nid) & AC_WCAP_IN_AMP)) {\n\t\terr = add_control(spec, ALC_CTL_WIDGET_VOL,\n\t\t\t\t  \"Front Mic Boost\",\n\t\t\t\t  HDA_COMPOSE_AMP_VAL(nid, 3, 0, HDA_INPUT));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}", "path": "patch_realtek.c", "repo_name": "PabloCastellano/sound-2.6-hptx2000", "stars": 1, "license": "None", "language": "c", "size": 204}
{"docstring": "/* add playback controls from the parsed DAC table */\n", "func_signal": "static int alc262_auto_create_multi_out_ctls(struct alc_spec *spec,\n\t\t\t\t\t     const struct auto_pin_cfg *cfg)", "code": "{\n\tconst char *pfx;\n\tint vbits;\n\tint err;\n\n\tspec->multiout.num_dacs = 1;\t/* only use one dac */\n\tspec->multiout.dac_nids = spec->private_dac_nids;\n\tspec->multiout.dac_nids[0] = 2;\n\n\tif (!cfg->speaker_pins[0] && !cfg->hp_pins[0])\n\t\tpfx = \"Master\";\n\telse if (cfg->line_out_type == AUTO_PIN_SPEAKER_OUT)\n\t\tpfx = \"Speaker\";\n\telse\n\t\tpfx = \"Front\";\n\terr = alc262_add_out_sw_ctl(spec, cfg->line_out_pins[0], pfx);\n\tif (err < 0)\n\t\treturn err;\n\terr = alc262_add_out_sw_ctl(spec, cfg->speaker_pins[0], \"Speaker\");\n\tif (err < 0)\n\t\treturn err;\n\terr = alc262_add_out_sw_ctl(spec, cfg->hp_pins[0], \"Headphone\");\n\tif (err < 0)\n\t\treturn err;\n\n\tvbits = alc262_check_volbit(cfg->line_out_pins[0]) |\n\t\talc262_check_volbit(cfg->speaker_pins[0]) |\n\t\talc262_check_volbit(cfg->hp_pins[0]);\n\tif (vbits == 1 || vbits == 2)\n\t\tpfx = \"Master\"; /* only one mixer is used */\n\telse if (cfg->line_out_type == AUTO_PIN_SPEAKER_OUT)\n\t\tpfx = \"Speaker\";\n\telse\n\t\tpfx = \"Front\";\n\tvbits = 0;\n\terr = alc262_add_out_vol_ctl(spec, cfg->line_out_pins[0], pfx, &vbits);\n\tif (err < 0)\n\t\treturn err;\n\terr = alc262_add_out_vol_ctl(spec, cfg->speaker_pins[0], \"Speaker\",\n\t\t\t\t     &vbits);\n\tif (err < 0)\n\t\treturn err;\n\terr = alc262_add_out_vol_ctl(spec, cfg->hp_pins[0], \"Headphone\",\n\t\t\t\t     &vbits);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}", "path": "patch_realtek.c", "repo_name": "PabloCastellano/sound-2.6-hptx2000", "stars": 1, "license": "None", "language": "c", "size": 204}
{"docstring": "/* toggle speaker-output according to the hp-jack state */\n", "func_signal": "static void alc861vd_dallas_setup(struct hda_codec *codec)", "code": "{\n\tstruct alc_spec *spec = codec->spec;\n\n\tspec->autocfg.hp_pins[0] = 0x15;\n\tspec->autocfg.speaker_pins[0] = 0x14;\n}", "path": "patch_realtek.c", "repo_name": "PabloCastellano/sound-2.6-hptx2000", "stars": 1, "license": "None", "language": "c", "size": 204}
{"docstring": "/* additional initialization for auto-configuration model */\n", "func_signal": "static void alc861_auto_init(struct hda_codec *codec)", "code": "{\n\tstruct alc_spec *spec = codec->spec;\n\talc861_auto_init_multi_out(codec);\n\talc861_auto_init_hp_out(codec);\n\talc861_auto_init_analog_input(codec);\n\tif (spec->unsol_event)\n\t\talc_inithook(codec);\n}", "path": "patch_realtek.c", "repo_name": "PabloCastellano/sound-2.6-hptx2000", "stars": 1, "license": "None", "language": "c", "size": 204}
{"docstring": "/* toggle speaker-output according to the hp-jack state */\n", "func_signal": "static void alc260_replacer_672v_automute(struct hda_codec *codec)", "code": "{\n        unsigned int present;\n\n\t/* speaker --> GPIO Data 0, hp or spdif --> GPIO data 1 */\n\tpresent = snd_hda_jack_detect(codec, 0x0f);\n\tif (present) {\n\t\tsnd_hda_codec_write_cache(codec, 0x01, 0,\n\t\t\t\t\t  AC_VERB_SET_GPIO_DATA, 1);\n\t\tsnd_hda_codec_write_cache(codec, 0x0f, 0,\n\t\t\t\t\t  AC_VERB_SET_PIN_WIDGET_CONTROL,\n\t\t\t\t\t  PIN_HP);\n\t} else {\n\t\tsnd_hda_codec_write_cache(codec, 0x01, 0,\n\t\t\t\t\t  AC_VERB_SET_GPIO_DATA, 0);\n\t\tsnd_hda_codec_write_cache(codec, 0x0f, 0,\n\t\t\t\t\t  AC_VERB_SET_PIN_WIDGET_CONTROL,\n\t\t\t\t\t  PIN_OUT);\n\t}\n}", "path": "patch_realtek.c", "repo_name": "PabloCastellano/sound-2.6-hptx2000", "stars": 1, "license": "None", "language": "c", "size": 204}
{"docstring": "/* parse the BIOS configuration and set up the alc_spec */\n/* return 1 if successful, 0 if the proper config is not found,\n * or a negative error code\n */\n", "func_signal": "static int alc861_parse_auto_config(struct hda_codec *codec)", "code": "{\n\tstruct alc_spec *spec = codec->spec;\n\tint err;\n\tstatic hda_nid_t alc861_ignore[] = { 0x1d, 0 };\n\n\terr = snd_hda_parse_pin_def_config(codec, &spec->autocfg,\n\t\t\t\t\t   alc861_ignore);\n\tif (err < 0)\n\t\treturn err;\n\tif (!spec->autocfg.line_outs)\n\t\treturn 0; /* can't find valid BIOS pin config */\n\n\terr = alc861_auto_fill_dac_nids(codec, &spec->autocfg);\n\tif (err < 0)\n\t\treturn err;\n\terr = alc861_auto_create_multi_out_ctls(codec, &spec->autocfg);\n\tif (err < 0)\n\t\treturn err;\n\terr = alc861_auto_create_hp_ctls(codec, spec->autocfg.hp_pins[0]);\n\tif (err < 0)\n\t\treturn err;\n\terr = alc861_auto_create_input_ctls(codec, &spec->autocfg);\n\tif (err < 0)\n\t\treturn err;\n\n\tspec->multiout.max_channels = spec->multiout.num_dacs * 2;\n\n\tif (spec->autocfg.dig_outs)\n\t\tspec->multiout.dig_out_nid = ALC861_DIGOUT_NID;\n\n\tif (spec->kctls.list)\n\t\tadd_mixer(spec, spec->kctls.list);\n\n\tadd_verb(spec, alc861_auto_init_verbs);\n\n\tspec->num_mux_defs = 1;\n\tspec->input_mux = &spec->private_imux[0];\n\n\tspec->adc_nids = alc861_adc_nids;\n\tspec->num_adc_nids = ARRAY_SIZE(alc861_adc_nids);\n\tset_capture_mixer(codec);\n\n\talc_ssid_check(codec, 0x0e, 0x0f, 0x0b);\n\n\treturn 1;\n}", "path": "patch_realtek.c", "repo_name": "PabloCastellano/sound-2.6-hptx2000", "stars": 1, "license": "None", "language": "c", "size": 204}
{"docstring": "/* To allocate memory to many arguments. \n   The function should be called:\n   zv_get_vars(dim,&x,&y,&z,...,NULL);\n   where \n     int dim;\n     ZVEC *x, *y, *z,...;\n     The last argument should be NULL ! \n     dim is the length of vectors x,y,z,...\n     returned value is equal to the number of allocated variables\n     Other gec_... functions are similar.\n*/\n", "func_signal": "int zv_get_vars(int dim,...)", "code": "{\n   va_list ap;\n   int i=0;\n   ZVEC **par;\n   \n   va_start(ap, dim);\n   while (par = va_arg(ap,ZVEC **)) {   /* NULL ends the list*/\n      *par = zv_get(dim);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}", "path": "meschach-1.2\\zmemory.c", "repo_name": "blackball/Meschach", "stars": 0, "license": "None", "language": "c", "size": 434}
{"docstring": "/* To deallocate memory for many arguments. \n   The function should be called:\n   sp_free_vars(&x,&y,&z,...,NULL);\n   where \n     SPMAT *x, *y, *z,...;\n     The last argument should be NULL ! \n     There must be at least one not NULL argument.\n     returned value is equal to the number of allocated variables.\n     Returned value of x,y,z,.. is VNULL.\n*/\n", "func_signal": "int sp_free_vars(SPMAT **va,...)", "code": "{\n   va_list ap;\n   int i=1;\n   SPMAT **par;\n   \n   sp_free(*va);\n   *va = (SPMAT *) NULL;\n   va_start(ap, va);\n   while (par = va_arg(ap,SPMAT **)) {   /* NULL ends the list*/\n      sp_free(*par); \n      *par = (SPMAT *)NULL;\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}", "path": "meschach-1.2\\sparse.c", "repo_name": "blackball/Meschach", "stars": 0, "license": "None", "language": "c", "size": 434}
{"docstring": "/* v_linlist -- linear combinations taken from a list of arguments;\n   calling:\n      v_linlist(out,v1,a1,v2,a2,...,vn,an,NULL);\n   where vi are vectors (VEC *) and ai are numbers (double)\n*/\n", "func_signal": "VEC  *v_linlist(VEC *out,VEC *v1,double a1,...)", "code": "{\n   va_list ap;\n   VEC *par;\n   double a_par;\n\n   if ( ! v1 )\n     return VNULL;\n   \n   va_start(ap, a1);\n   out = sv_mlt(a1,v1,out);\n   \n   while (par = va_arg(ap,VEC *)) {   /* NULL ends the list*/\n      a_par = va_arg(ap,double);\n      if (a_par == 0.0) continue;\n      if ( out == par )\t\t\n\terror(E_INSITU,\"v_linlist\");\n      if ( out->dim != par->dim )\t\n\terror(E_SIZES,\"v_linlist\");\n\n      if (a_par == 1.0)\n\tout = v_add(out,par,out);\n      else if (a_par == -1.0)\n\tout = v_sub(out,par,out);\n      else\n\tout = v_mltadd(out,par,a_par,out); \n   } \n   \n   va_end(ap);\n   return out;\n}", "path": "meschach-1.2\\vecop.c", "repo_name": "blackball/Meschach", "stars": 0, "license": "None", "language": "c", "size": 434}
{"docstring": "/* To deallocate memory for many arguments. \n   The function should be called:\n   v_free_vars(&x,&y,&z,...,NULL);\n   where \n     ZVEC *x, *y, *z,...;\n     The last argument should be NULL ! \n     There must be at least one not NULL argument.\n     returned value is equal to the number of allocated variables.\n     Returned value of x,y,z,.. is VNULL.\n     Other *_free_list() functions are similar.\n*/\n", "func_signal": "int zv_free_vars(va_alist) va_dcl", "code": "{\n   va_list ap;\n   int i=0;\n   ZVEC **par;\n   \n   va_start(ap);\n   while (par = va_arg(ap,ZVEC **)) {   /* NULL ends the list*/\n      zv_free(*par); \n      *par = ZVNULL;\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}", "path": "meschach-1.2\\zmemory.c", "repo_name": "blackball/Meschach", "stars": 0, "license": "None", "language": "c", "size": 434}
{"docstring": "/* zv_linlist -- linear combinations taken from a list of arguments;\n   calling:\n      zv_linlist(out,v1,a1,v2,a2,...,vn,an,NULL);\n   where vi are vectors (ZVEC *) and ai are numbers (complex)\n*/\n", "func_signal": "ZVEC  *zv_linlist(va_alist) va_dcl", "code": "{\n   va_list ap;\n   ZVEC *par, *out;\n   complex a_par;\n\n   va_start(ap);\n   out = va_arg(ap,ZVEC *);\n   par = va_arg(ap,ZVEC *);\n   if ( ! par ) {\n      va_end(ap);\n      return ZVNULL;\n   }\n   \n   a_par = va_arg(ap,complex);\n   out = zv_mlt(a_par,par,out);\n   \n   while (par = va_arg(ap,ZVEC *)) {   /* NULL ends the list*/\n      a_par = va_arg(ap,complex);\n      if (a_par.re == 0.0 && a_par.im == 0.0) continue;\n      if ( out == par )\t\t\n\terror(E_INSITU,\"zv_linlist\");\n      if ( out->dim != par->dim )\t\n\terror(E_SIZES,\"zv_linlist\");\n\n      if (a_par.re == 1.0 && a_par.im == 0.0)\n\tout = zv_add(out,par,out);\n      else if (a_par.re == -1.0 && a_par.im == 0.0)\n\tout = zv_sub(out,par,out);\n      else\n\tout = zv_mltadd(out,par,a_par,out); \n   } \n   \n   va_end(ap);\n   return out;\n}", "path": "meschach-1.2\\zvecop.c", "repo_name": "blackball/Meschach", "stars": 0, "license": "None", "language": "c", "size": 434}
{"docstring": "/* To resize memory for many arguments. \n   The function should be called:\n   v_resize_vars(new_dim,&x,&y,&z,...,NULL);\n   where \n     int new_dim;\n     VEC *x, *y, *z,...;\n     The last argument should be NULL ! \n     rdim is the resized length of vectors x,y,z,...\n     returned value is equal to the number of allocated variables.\n     If one of x,y,z,.. arguments is NULL then memory is allocated to this \n     argument. \n     Other *_resize_list() functions are similar.\n*/\n", "func_signal": "int v_resize_vars(va_alist) va_dcl", "code": "{\n   va_list ap;\n   int i=0, new_dim;\n   VEC **par;\n   \n   va_start(ap);\n   new_dim = va_arg(ap,int);\n   while (par = va_arg(ap,VEC **)) {   /* NULL ends the list*/\n      *par = v_resize(*par,new_dim);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}", "path": "meschach-1.2\\memory.c", "repo_name": "blackball/Meschach", "stars": 0, "license": "None", "language": "c", "size": 434}
{"docstring": "/* zv_linlist -- linear combinations taken from a list of arguments;\n   calling:\n      zv_linlist(out,v1,a1,v2,a2,...,vn,an,NULL);\n   where vi are vectors (ZVEC *) and ai are numbers (complex)\n*/\n", "func_signal": "ZVEC\t*zv_linlist(ZVEC *out,ZVEC *v1,complex a1,...)", "code": "{\n   va_list ap;\n   ZVEC *par;\n   complex a_par;\n\n   if ( ! v1 )\n     return ZVNULL;\n   \n   va_start(ap, a1);\n   out = zv_mlt(a1,v1,out);\n   \n   while (par = va_arg(ap,ZVEC *)) {   /* NULL ends the list*/\n      a_par = va_arg(ap,complex);\n      if (a_par.re == 0.0 && a_par.im == 0.0) continue;\n      if ( out == par )\t\t\n\terror(E_INSITU,\"zv_linlist\");\n      if ( out->dim != par->dim )\t\n\terror(E_SIZES,\"zv_linlist\");\n\n      if (a_par.re == 1.0 && a_par.im == 0.0)\n\tout = zv_add(out,par,out);\n      else if (a_par.re == -1.0 && a_par.im == 0.0)\n\tout = zv_sub(out,par,out);\n      else\n\tout = zv_mltadd(out,par,a_par,out); \n   } \n   \n   va_end(ap);\n   return out;\n}", "path": "meschach-1.2\\zvecop.c", "repo_name": "blackball/Meschach", "stars": 0, "license": "None", "language": "c", "size": 434}
{"docstring": "/* To deallocate memory for many arguments. \n   The function should be called:\n   sp_free_vars(&x,&y,&z,...,NULL);\n   where \n     SPMAT *x, *y, *z,...;\n     The last argument should be NULL ! \n     There must be at least one not NULL argument.\n     returned value is equal to the number of allocated variables.\n     Returned value of x,y,z,.. is VNULL.\n*/\n", "func_signal": "int sp_free_vars(va_alist) va_dcl", "code": "{\n   va_list ap;\n   int i=0;\n   SPMAT **par;\n   \n   va_start(ap);\n   while (par = va_arg(ap,SPMAT **)) {   /* NULL ends the list*/\n      sp_free(*par); \n      *par = (SPMAT *)NULL;\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}", "path": "meschach-1.2\\sparse.c", "repo_name": "blackball/Meschach", "stars": 0, "license": "None", "language": "c", "size": 434}
{"docstring": "/* To allocate memory to many arguments. \n   The function should be called:\n   v_get_vars(dim,&x,&y,&z,...,VNULL);\n   where \n     int dim;\n     VEC *x, *y, *z,...;\n     The last argument should be VNULL ! \n     dim is the length of vectors x,y,z,...\n*/\n", "func_signal": "int v_get_vars(va_alist) va_dcl", "code": "{\n   va_list ap;\n   int dim,i=0;\n   VEC **par;\n   \n   va_start(ap);\n   dim = va_arg(ap,int);\n   while (par = va_arg(ap,VEC **)) {   /* NULL ends the list*/\n      *par = v_get(dim);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}", "path": "meschach-1.2\\memory.c", "repo_name": "blackball/Meschach", "stars": 0, "license": "None", "language": "c", "size": 434}
{"docstring": "/* To resize memory for many arguments. \n   The function should be called:\n   sp_resize_vars(m,n,&x,&y,&z,...,NULL);\n   where \n     int m,n;\n     SPMAT *x, *y, *z,...;\n     The last argument should be NULL ! \n     m X n is the resized dimension of matrices x,y,z,...\n     returned value is equal to the number of allocated variables.\n     If one of x,y,z,.. arguments is NULL then memory is allocated to this \n     argument. \n*/\n", "func_signal": "int sp_resize_vars(va_alist) va_dcl", "code": "{\n   va_list ap;\n   int i=0, m, n;\n   SPMAT **par;\n   \n   va_start(ap);\n   m = va_arg(ap,int);\n   n = va_arg(ap,int);\n   while (par = va_arg(ap,SPMAT **)) {   /* NULL ends the list*/\n      *par = sp_resize(*par,m,n);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}", "path": "meschach-1.2\\sparse.c", "repo_name": "blackball/Meschach", "stars": 0, "license": "None", "language": "c", "size": 434}
{"docstring": "/* To allocate memory to many arguments. \n   The function should be called:\n   mem_stat_vars(list,type,&v1,&v2,&v3,...,VNULL);\n   where \n     int list,type;\n     void **v1, **v2, **v3,...;\n     The last argument should be VNULL ! \n     type is the type of variables v1,v2,v3,...\n     (of course they must be of the same type)\n*/\n", "func_signal": "int mem_stat_reg_vars(va_alist) va_dcl", "code": "{\n   va_list ap;\n   int type,list,i=0;\n   void **par;\n   \n   va_start(ap);\n   list = va_arg(ap,int);\n   type = va_arg(ap,int);\n   while (par = va_arg(ap,void **)) {   /* NULL ends the list*/\n      mem_stat_reg_list(par,type,list);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}", "path": "meschach-1.2\\memstat.c", "repo_name": "blackball/Meschach", "stars": 0, "license": "None", "language": "c", "size": 434}
{"docstring": "/* To deallocate memory for many arguments. \n   The function should be called:\n   v_free_vars(&x,&y,&z,...,NULL);\n   where \n     VEC *x, *y, *z,...;\n     The last argument should be NULL ! \n     There must be at least one not NULL argument.\n     returned value is equal to the number of allocated variables.\n     Returned value of x,y,z,.. is VNULL.\n     Other *_free_list() functions are similar.\n*/\n", "func_signal": "int v_free_vars(VEC **pv,...)", "code": "{\n   va_list ap;\n   int i=1;\n   VEC **par;\n   \n   v_free(*pv);\n   *pv = VNULL;\n   va_start(ap, pv);\n   while (par = va_arg(ap,VEC **)) {   /* NULL ends the list*/\n      v_free(*par); \n      *par = VNULL;\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}", "path": "meschach-1.2\\memory.c", "repo_name": "blackball/Meschach", "stars": 0, "license": "None", "language": "c", "size": 434}
{"docstring": "/* To allocate memory to many arguments. \n   The function should be called:\n   mem_stat_vars(list,type,&v1,&v2,&v3,...,VNULL);\n   where \n     int list,type;\n     void **v1, **v2, **v3,...;\n     The last argument should be VNULL ! \n     type is the type of variables v1,v2,v3,...\n     (of course they must be of the same type)\n*/\n", "func_signal": "int mem_stat_reg_vars(int list,int type,...)", "code": "{\n   va_list ap;\n   int i=0;\n   void **par;\n   \n   va_start(ap, type);\n   while (par = va_arg(ap,void **)) {   /* NULL ends the list*/\n      mem_stat_reg_list(par,type,list);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}", "path": "meschach-1.2\\memstat.c", "repo_name": "blackball/Meschach", "stars": 0, "license": "None", "language": "c", "size": 434}
{"docstring": "/* To resize memory for many arguments. \n   The function should be called:\n   v_resize_vars(new_dim,&x,&y,&z,...,NULL);\n   where \n     int new_dim;\n     ZVEC *x, *y, *z,...;\n     The last argument should be NULL ! \n     rdim is the resized length of vectors x,y,z,...\n     returned value is equal to the number of allocated variables.\n     If one of x,y,z,.. arguments is NULL then memory is allocated to this \n     argument. \n     Other *_resize_list() functions are similar.\n*/\n", "func_signal": "int zv_resize_vars(int new_dim,...)", "code": "{\n   va_list ap;\n   int i=0;\n   ZVEC **par;\n   \n   va_start(ap, new_dim);\n   while (par = va_arg(ap,ZVEC **)) {   /* NULL ends the list*/\n      *par = zv_resize(*par,new_dim);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}", "path": "meschach-1.2\\zmemory.c", "repo_name": "blackball/Meschach", "stars": 0, "license": "None", "language": "c", "size": 434}
{"docstring": "/* To allocate memory to many arguments. \n   The function should be called:\n   sp_get_vars(m,n,deg,&x,&y,&z,...,NULL);\n   where \n     int m,n,deg;\n     SPMAT *x, *y, *z,...;\n     The last argument should be NULL ! \n     m x n is the dimension of matrices x,y,z,...\n     returned value is equal to the number of allocated variables\n*/\n", "func_signal": "int sp_get_vars(int m,int n,int deg,...)", "code": "{\n   va_list ap;\n   int i=0;\n   SPMAT **par;\n   \n   va_start(ap, deg);\n   while (par = va_arg(ap,SPMAT **)) {   /* NULL ends the list*/\n      *par = sp_get(m,n,deg);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}", "path": "meschach-1.2\\sparse.c", "repo_name": "blackball/Meschach", "stars": 0, "license": "None", "language": "c", "size": 434}
{"docstring": "/* To allocate memory to many arguments. \n   The function should be called:\n   sp_get_vars(m,n,deg,&x,&y,&z,...,NULL);\n   where \n     int m,n,deg;\n     SPMAT *x, *y, *z,...;\n     The last argument should be NULL ! \n     m x n is the dimension of matrices x,y,z,...\n     returned value is equal to the number of allocated variables\n*/\n", "func_signal": "int sp_get_vars(va_alist) va_dcl", "code": "{\n   va_list ap;\n   int i=0, m, n, deg;\n   SPMAT **par;\n   \n   va_start(ap);\n   m = va_arg(ap,int);\n   n = va_arg(ap,int);\n   deg = va_arg(ap,int);\n   while (par = va_arg(ap,SPMAT **)) {   /* NULL ends the list*/\n      *par = sp_get(m,n,deg);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}", "path": "meschach-1.2\\sparse.c", "repo_name": "blackball/Meschach", "stars": 0, "license": "None", "language": "c", "size": 434}
{"docstring": "/* v_linlist -- linear combinations taken from a list of arguments;\n   calling:\n      v_linlist(out,v1,a1,v2,a2,...,vn,an,NULL);\n   where vi are vectors (VEC *) and ai are numbers (double)\n*/\n", "func_signal": "VEC  *v_linlist(va_alist) va_dcl", "code": "{\n   va_list ap;\n   VEC *par, *out;\n   double a_par;\n\n   va_start(ap);\n   out = va_arg(ap,VEC *);\n   par = va_arg(ap,VEC *);\n   if ( ! par ) {\n      va_end(ap);\n      return VNULL;\n   }\n   \n   a_par = va_arg(ap,double);\n   out = sv_mlt(a_par,par,out);\n   \n   while (par = va_arg(ap,VEC *)) {   /* NULL ends the list*/\n      a_par = va_arg(ap,double);\n      if (a_par == 0.0) continue;\n      if ( out == par )\t\t\n\terror(E_INSITU,\"v_linlist\");\n      if ( out->dim != par->dim )\t\n\terror(E_SIZES,\"v_linlist\");\n\n      if (a_par == 1.0)\n\tout = v_add(out,par,out);\n      else if (a_par == -1.0)\n\tout = v_sub(out,par,out);\n      else\n\tout = v_mltadd(out,par,a_par,out); \n   } \n   \n   va_end(ap);\n   return out;\n}", "path": "meschach-1.2\\vecop.c", "repo_name": "blackball/Meschach", "stars": 0, "license": "None", "language": "c", "size": 434}
{"docstring": "/* To resize memory for many arguments. \n   The function should be called:\n   v_resize_vars(new_dim,&x,&y,&z,...,NULL);\n   where \n     int new_dim;\n     VEC *x, *y, *z,...;\n     The last argument should be NULL ! \n     rdim is the resized length of vectors x,y,z,...\n     returned value is equal to the number of allocated variables.\n     If one of x,y,z,.. arguments is NULL then memory is allocated to this \n     argument. \n     Other *_resize_list() functions are similar.\n*/\n", "func_signal": "int v_resize_vars(int new_dim,...)", "code": "{\n   va_list ap;\n   int i=0;\n   VEC **par;\n   \n   va_start(ap, new_dim);\n   while (par = va_arg(ap,VEC **)) {   /* NULL ends the list*/\n      *par = v_resize(*par,new_dim);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}", "path": "meschach-1.2\\memory.c", "repo_name": "blackball/Meschach", "stars": 0, "license": "None", "language": "c", "size": 434}
{"docstring": "/* To resize memory for many arguments. \n   The function should be called:\n   sp_resize_vars(m,n,&x,&y,&z,...,NULL);\n   where \n     int m,n;\n     SPMAT *x, *y, *z,...;\n     The last argument should be NULL ! \n     m X n is the resized dimension of matrices x,y,z,...\n     returned value is equal to the number of allocated variables.\n     If one of x,y,z,.. arguments is NULL then memory is allocated to this \n     argument. \n*/\n", "func_signal": "int sp_resize_vars(int m,int n,...)", "code": "{\n   va_list ap;\n   int i=0;\n   SPMAT **par;\n   \n   va_start(ap, n);\n   while (par = va_arg(ap,SPMAT **)) {   /* NULL ends the list*/\n      *par = sp_resize(*par,m,n);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}", "path": "meschach-1.2\\sparse.c", "repo_name": "blackball/Meschach", "stars": 0, "license": "None", "language": "c", "size": 434}
{"docstring": "/* To allocate memory to many arguments. \n   The function should be called:\n   v_get_vars(dim,&x,&y,&z,...,NULL);\n   where \n     int dim;\n     VEC *x, *y, *z,...;\n     The last argument should be NULL ! \n     dim is the length of vectors x,y,z,...\n     returned value is equal to the number of allocated variables\n     Other gec_... functions are similar.\n*/\n", "func_signal": "int v_get_vars(int dim,...)", "code": "{\n   va_list ap;\n   int i=0;\n   VEC **par;\n   \n   va_start(ap, dim);\n   while (par = va_arg(ap,VEC **)) {   /* NULL ends the list*/\n      *par = v_get(dim);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}", "path": "meschach-1.2\\memory.c", "repo_name": "blackball/Meschach", "stars": 0, "license": "None", "language": "c", "size": 434}
{"docstring": "/*===========================================================================*\n *\t\t\t\tarch_umap\t\t\t\t     *\n *===========================================================================*/\n", "func_signal": "PUBLIC int arch_umap(struct proc *pr, vir_bytes offset, vir_bytes count,\n\tint seg, phys_bytes *addr)", "code": "{\n\tswitch(seg) {\n\t\tcase BIOS_SEG:\n\t\t\t*addr = umap_bios(offset, count);\n\t\t\treturn OK;\n\t}\n\n\t/* This must be EINVAL; the umap fallback function in\n\t * lib/syslib/alloc_util.c depends on it to detect an\n\t * older kernel (as opposed to mapping error).\n\t */\n\treturn EINVAL;\n}", "path": "lottery\\arch\\i386\\memory.c", "repo_name": "Compy/Minix", "stars": 1, "license": "None", "language": "c", "size": 224}
{"docstring": "/*===========================================================================*\n *\t\t\t\tarch_init_clock\t\t\t\t     *\n *===========================================================================*/\n", "func_signal": "PUBLIC int arch_init_clock(void)", "code": "{\n\t/* Initialize channel 0 of the 8253A timer to, e.g., 60 Hz,\n\t * and register the CLOCK task's interrupt handler to be run\n\t * on every clock tick.\n\t */\n\toutb(TIMER_MODE, SQUARE_WAVE);  /* run continuously */\n\toutb(TIMER0, (TIMER_COUNT & 0xff)); /* timer low byte */\n\toutb(TIMER0, TIMER_COUNT >> 8); /* timer high byte */ \n\n\treturn OK;\n}", "path": "roundrobin\\arch\\i386\\clock.c", "repo_name": "Compy/Minix", "stars": 1, "license": "None", "language": "c", "size": 224}
{"docstring": "/*===========================================================================*\n *\t\t\t\tpick_proc\t\t\t\t     * \n *===========================================================================*/\n", "func_signal": "PRIVATE void pick_proc()", "code": "{\n/* Decide who to run now.  A new process is selected by setting 'next_ptr'.\n * When a billable process is selected, record it in 'bill_ptr', so that the \n * clock task can tell who to bill for system time.\n */\n  register struct proc *rp;\t\t\t/* process to run */\n  int q;\t\t\t\t\t/* iterate over queues */\n\n  /* Check each of the scheduling queues for ready processes. The number of\n   * queues is defined in proc.h, and priorities are set in the task table.\n   * The lowest queue contains IDLE, which is always ready.\n   */\n  for (q=0; q < NR_SCHED_QUEUES; q++) {\t\n      if ( (rp = rdy_head[q]) != NIL_PROC) {\n          next_ptr = rp;\t\t\t/* run process 'rp' next */\n#if 0\n\t  if(rp->p_endpoint != 4 && rp->p_endpoint != 5 && rp->p_endpoint != IDLE && rp->p_endpoint != SYSTEM)\n\t  \tkprintf(\"[run %s]\",  rp->p_name);\n#endif\n          if (priv(rp)->s_flags & BILLABLE)\t \t\n              bill_ptr = rp;\t\t\t/* bill for system time */\n          return;\t\t\t\t \n      }\n  }\n  minix_panic(\"no ready process\", NO_NUM);\n}", "path": "lottery\\proc.c", "repo_name": "Compy/Minix", "stars": 1, "license": "None", "language": "c", "size": 224}
{"docstring": "/*===========================================================================*\n *\t\t\t\tclock_stop\t\t\t\t     *\n *===========================================================================*/\n", "func_signal": "PUBLIC void clock_stop(void)", "code": "{\n\t/* Reset the clock to the BIOS rate. (For rebooting.) */\n\toutb(TIMER_MODE, 0x36);\n\toutb(TIMER0, 0);\n\toutb(TIMER0, 0);\n}", "path": "roundrobin\\arch\\i386\\clock.c", "repo_name": "Compy/Minix", "stars": 1, "license": "None", "language": "c", "size": 224}
{"docstring": "/*===========================================================================*\n *                              vm_contiguous                                *\n *===========================================================================*/\n", "func_signal": "PUBLIC int vm_contiguous(struct proc *targetproc, u32_t vir_buf, size_t bytes)", "code": "{\n\tint first = 1, r, boundaries = 0;\n\tu32_t prev_phys, po;\n\tu32_t prev_vir;\n\n\tvmassert(targetproc);\n\tvmassert(bytes > 0);\n\n\tif(!HASPT(targetproc))\n\t\treturn 1;\n\n\t/* Start and end at page boundary to make logic simpler. */\n\tpo = vir_buf % I386_PAGE_SIZE;\n\tif(po > 0) {\n\t\tbytes += po;\n\t\tvir_buf -= po;\n\t}\n\tpo = (vir_buf + bytes) % I386_PAGE_SIZE;\n\tif(po > 0)\n\t\tbytes += I386_PAGE_SIZE - po;\n\n\t/* Keep going as long as we cross a page boundary. */\n\twhile(bytes > 0) {\n\t\tu32_t phys;\n\n\t\tif((r=vm_lookup(targetproc, vir_buf, &phys, NULL)) != OK) {\n\t\t\tkprintf(\"vm_contiguous: vm_lookup failed, %d\\n\", r);\n\t\t\tkprintf(\"kernel stack: \");\n\t\t\tutil_stacktrace();\n\t\t\treturn 0;\n\t\t}\n\n\t\tif(!first) {\n\t\t\tif(prev_phys+I386_PAGE_SIZE != phys) {\n\t\t\t\tkprintf(\"vm_contiguous: no (0x%lx, 0x%lx)\\n\",\n\t\t\t\t\tprev_phys, phys);\n\t\t\t\tkprintf(\"kernel stack: \");\n\t\t\t\tutil_stacktrace();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tfirst = 0;\n\n\t\tprev_phys = phys;\n\t\tprev_vir = vir_buf;\n\t\tvir_buf += I386_PAGE_SIZE;\n\t\tbytes -= I386_PAGE_SIZE;\n\t\tboundaries++;\n\t}\n\n\tif(verbose_vm)\n\t\tkprintf(\"vm_contiguous: yes (%d boundaries tested)\\n\",\n\t\t\tboundaries);\n\n\treturn 1;\n}", "path": "lottery\\arch\\i386\\memory.c", "repo_name": "Compy/Minix", "stars": 1, "license": "None", "language": "c", "size": 224}
{"docstring": "/*===========================================================================*\n *\t\t\t\tannounce\t\t\t\t     *\n *===========================================================================*/\n", "func_signal": "PRIVATE void announce(void)", "code": "{\n  /* Display the MINIX startup banner. */\n  kprintf(\"\\nMINIX %s.%s. \"\n#ifdef _SVN_REVISION\n\t\"(\" _SVN_REVISION \")\\n\"\n#endif\n      \"Copyright 2009, Vrije Universiteit, Amsterdam, The Netherlands\\n\",\n      OS_RELEASE, OS_VERSION);\n  kprintf(\"MINIX is open source software, see http://www.minix3.org\\n\");\n}", "path": "roundrobin\\main.c", "repo_name": "Compy/Minix", "stars": 1, "license": "None", "language": "c", "size": 224}
{"docstring": "/*===========================================================================*\n *\t\t\t\tmain                                         *\n *===========================================================================*/\n", "func_signal": "PUBLIC void main()", "code": "{\n/* Start the ball rolling. */\n  struct boot_image *ip;\t/* boot image pointer */\n  register struct proc *rp;\t/* process pointer */\n  register struct priv *sp;\t/* privilege structure pointer */\n  register int i, j, s;\n  int hdrindex;\t\t\t/* index to array of a.out headers */\n  phys_clicks text_base;\n  vir_clicks text_clicks, data_clicks, st_clicks;\n  reg_t ktsb;\t\t\t/* kernel task stack base */\n  struct exec e_hdr;\t\t/* for a copy of an a.out header */\n\n  /* Clear the process table. Anounce each slot as empty and set up mappings \n   * for proc_addr() and proc_nr() macros. Do the same for the table with \n   * privilege structures for the system processes. \n   */\n  for (rp = BEG_PROC_ADDR, i = -NR_TASKS; rp < END_PROC_ADDR; ++rp, ++i) {\n  \trp->p_rts_flags = SLOT_FREE;\t\t/* initialize free slot */\n#if DEBUG_SCHED_CHECK\n\trp->p_magic = PMAGIC;\n#endif\n\trp->p_nr = i;\t\t\t\t/* proc number from ptr */\n\trp->p_endpoint = _ENDPOINT(0, rp->p_nr); /* generation no. 0 */\n        (pproc_addr + NR_TASKS)[i] = rp;        /* proc ptr from number */\n  }\n  for (sp = BEG_PRIV_ADDR, i = 0; sp < END_PRIV_ADDR; ++sp, ++i) {\n\tsp->s_proc_nr = NONE;\t\t\t/* initialize as free */\n\tsp->s_id = i;\t\t\t\t/* priv structure index */\n\tppriv_addr[i] = sp;\t\t\t/* priv ptr from number */\n  }\n\n  /* Set up proc table entries for processes in boot image.  The stacks of the\n   * kernel tasks are initialized to an array in data space.  The stacks\n   * of the servers have been added to the data segment by the monitor, so\n   * the stack pointer is set to the end of the data segment.  All the\n   * processes are in low memory on the 8086.  On the 386 only the kernel\n   * is in low memory, the rest is loaded in extended memory.\n   */\n\n  /* Task stacks. */\n  ktsb = (reg_t) t_stack;\n\n  for (i=0; i < NR_BOOT_PROCS; ++i) {\n\tint ci;\n\tbitchunk_t fv;\n\n\tip = &image[i];\t\t\t\t/* process' attributes */\n\trp = proc_addr(ip->proc_nr);\t\t/* get process pointer */\n\tip->endpoint = rp->p_endpoint;\t\t/* ipc endpoint */\n\trp->p_max_priority = ip->priority;\t/* max scheduling priority */\n\trp->p_priority = ip->priority;\t\t/* current priority */\n\trp->p_quantum_size = ip->quantum;\t/* quantum size in ticks */\n\trp->p_ticks_left = ip->quantum;\t\t/* current credit */\n\tstrncpy(rp->p_name, ip->proc_name, P_NAME_LEN); /* set process name */\n\t(void) get_priv(rp, (ip->flags & SYS_PROC));    /* assign structure */\n\tpriv(rp)->s_flags = ip->flags;\t\t\t/* process flags */\n\tpriv(rp)->s_trap_mask = ip->trap_mask;\t\t/* allowed traps */\n\n\t/* Warn about violations of the boot image table order consistency. */\n\tif (priv_id(rp) != s_nr_to_id(ip->proc_nr))\n\t\tkprintf(\"Warning: boot image table has wrong process order\\n\");\n\n\t/* Initialize call mask bitmap from unordered set.\n\t * A single SYS_ALL_CALLS is a special case - it\n\t * means all calls are allowed.\n\t */\n\tif(ip->nr_k_calls == 1 && ip->k_calls[0] == SYS_ALL_CALLS)\n\t\tfv = ~0;\t\t/* fill call mask */\n\telse\n\t\tfv = 0;\t\t\t/* clear call mask */\n\n\tfor(ci = 0; ci < CALL_MASK_SIZE; ci++) \t/* fill or clear call mask */\n\t\tpriv(rp)->s_k_call_mask[ci] = fv;\n\tif(!fv)\t\t\t/* not all full? enter calls bit by bit */\n\t\tfor(ci = 0; ci < ip->nr_k_calls; ci++)\n\t\t\tSET_BIT(priv(rp)->s_k_call_mask,\n\t\t\t\tip->k_calls[ci]-KERNEL_CALL);\n\n\tfor (j = 0; j < NR_SYS_PROCS && j < BITCHUNK_BITS; j++)\n\t\tif (ip->ipc_to & (1 << j))\n\t\t\tset_sendto_bit(rp, j);\t/* restrict targets */\n\n\tif (iskerneln(proc_nr(rp))) {\t\t/* part of the kernel? */ \n\t\tif (ip->stksize > 0) {\t\t/* HARDWARE stack size is 0 */\n\t\t\trp->p_priv->s_stack_guard = (reg_t *) ktsb;\n\t\t\t*rp->p_priv->s_stack_guard = STACK_GUARD;\n\t\t}\n\t\tktsb += ip->stksize;\t/* point to high end of stack */\n\t\trp->p_reg.sp = ktsb;\t/* this task's initial stack ptr */\n\t\thdrindex = 0;\t\t/* all use the first a.out header */\n\t} else {\n\t\thdrindex = 1 + i-NR_TASKS;\t/* servers, drivers, INIT */\n\t}\n\n\t/* Architecture-specific way to find out aout header of this\n\t * boot process.\n\t */\n\tarch_get_aout_headers(hdrindex, &e_hdr);\n\n\t/* Convert addresses to clicks and build process memory map */\n\ttext_base = e_hdr.a_syms >> CLICK_SHIFT;\n\ttext_clicks = (e_hdr.a_text + CLICK_SIZE-1) >> CLICK_SHIFT;\n\tdata_clicks = (e_hdr.a_data+e_hdr.a_bss + CLICK_SIZE-1) >> CLICK_SHIFT;\n\tst_clicks= (e_hdr.a_total + CLICK_SIZE-1) >> CLICK_SHIFT;\n\tif (!(e_hdr.a_flags & A_SEP))\n\t{\n\t\tdata_clicks= (e_hdr.a_text+e_hdr.a_data+e_hdr.a_bss +\n\t\t\tCLICK_SIZE-1) >> CLICK_SHIFT;\n\t\ttext_clicks = 0;\t   /* common I&D */\n\t}\n\trp->p_memmap[T].mem_phys = text_base;\n\trp->p_memmap[T].mem_len  = text_clicks;\n\trp->p_memmap[D].mem_phys = text_base + text_clicks;\n\trp->p_memmap[D].mem_len  = data_clicks;\n\trp->p_memmap[S].mem_phys = text_base + text_clicks + st_clicks;\n\trp->p_memmap[S].mem_vir  = st_clicks;\n\trp->p_memmap[S].mem_len  = 0;\n\n\t/* Set initial register values.  The processor status word for tasks \n\t * is different from that of other processes because tasks can\n\t * access I/O; this is not allowed to less-privileged processes \n\t */\n\trp->p_reg.pc = (reg_t) ip->initial_pc;\n\trp->p_reg.psw = (iskernelp(rp)) ? INIT_TASK_PSW : INIT_PSW;\n\n\t/* Initialize the server stack pointer. Take it down one word\n\t * to give crtso.s something to use as \"argc\".\n\t */\n\tif (isusern(proc_nr(rp))) {\t\t/* user-space process? */ \n\t\trp->p_reg.sp = (rp->p_memmap[S].mem_vir +\n\t\t\t\trp->p_memmap[S].mem_len) << CLICK_SHIFT;\n\t\trp->p_reg.sp -= sizeof(reg_t);\n\t}\n\n\t/* If this process has its own page table, VM will set the\n\t * PT up and manage it. VM will signal the kernel when it has\n\t * done this; until then, don't let it run.\n\t */\n\tif(priv(rp)->s_flags & PROC_FULLVM)\n\t\tRTS_SET(rp, VMINHIBIT);\n\t\n\t/* Set ready. The HARDWARE task is never ready. */\n\tif (rp->p_nr == HARDWARE) RTS_SET(rp, NO_PRIORITY);\n\tRTS_UNSET(rp, SLOT_FREE); /* remove SLOT_FREE and schedule */\n\talloc_segments(rp);\n  }\n\n#if SPROFILE\n  sprofiling = 0;      /* we're not profiling until instructed to */\n#endif /* SPROFILE */\n  cprof_procs_no = 0;  /* init nr of hash table slots used */\n\n  vm_running = 0;\n  krandom.random_sources = RANDOM_SOURCES;\n  krandom.random_elements = RANDOM_ELEMENTS;\n\n  /* MINIX is now ready. All boot image processes are on the ready queue.\n   * Return to the assembly code to start running the current process. \n   */\n  bill_ptr = proc_addr(IDLE);\t\t/* it has to point somewhere */\n  announce();\t\t\t\t/* print MINIX startup banner */\n  restart();\n}", "path": "lottery\\main.c", "repo_name": "Compy/Minix", "stars": 1, "license": "None", "language": "c", "size": 224}
{"docstring": "/*===========================================================================*\n *\t\t\t\tintr_disabled\t\t\t     \t     *\n *===========================================================================*/\n", "func_signal": "PUBLIC int intr_disabled(void)", "code": "{\n\tif(!(read_cpu_flags() & X86_FLAG_I))\n\t\treturn 1;\n\treturn 0;\n}", "path": "lottery\\arch\\i386\\i8259.c", "repo_name": "Compy/Minix", "stars": 1, "license": "None", "language": "c", "size": 224}
{"docstring": "/*===========================================================================*\n *                              vm_print                                     *\n *===========================================================================*/\n", "func_signal": "void vm_print(u32_t *root)", "code": "{\n\tint pde;\n\n\tvmassert(!((u32_t) root % I386_PAGE_SIZE));\n\n\tfor(pde = 0; pde < I386_VM_DIR_ENTRIES; pde++) {\n\t\tu32_t pde_v;\n\t\tu32_t *pte_a;\n\t\tpde_v = phys_get32((u32_t) (root + pde));\n\t\tif(!(pde_v & I386_VM_PRESENT))\n\t\t\tcontinue;\n\t\tpte_a = (u32_t *) I386_VM_PFA(pde_v);\n\t\tkprintf(\"%4d: pt %08lx %s\\n\",\n\t\t\tpde, pte_a, flagstr(pde_v, 1));\n\t\tvm_pt_print(pte_a, pde * I386_VM_PT_ENTRIES * I386_PAGE_SIZE);\n\t}\n\n\n\treturn;\n}", "path": "lottery\\arch\\i386\\memory.c", "repo_name": "Compy/Minix", "stars": 1, "license": "None", "language": "c", "size": 224}
{"docstring": "/*===========================================================================*\n *\t\t\t\tarch_pre_exec\t\t\t\t     *\n *===========================================================================*/\n", "func_signal": "PUBLIC int arch_pre_exec(struct proc *pr, u32_t ip, u32_t sp)", "code": "{\n/* wipe extra LDT entries, set program counter, and stack pointer. */\n\tmemset(pr->p_seg.p_ldt + EXTRA_LDT_INDEX, 0,\n\t\tsizeof(pr->p_seg.p_ldt[0]) * (LDT_SIZE - EXTRA_LDT_INDEX));\n\tpr->p_reg.pc = ip;\n\tpr->p_reg.sp = sp;\n}", "path": "lottery\\arch\\i386\\memory.c", "repo_name": "Compy/Minix", "stars": 1, "license": "None", "language": "c", "size": 224}
{"docstring": "/*===========================================================================*\n *                              vm_checkrange                                *\n *===========================================================================*/\n", "func_signal": "PUBLIC int vm_checkrange(struct proc *caller, struct proc *target,\n\tvir_bytes vir, vir_bytes bytes, int wrfl, int checkonly)", "code": "{\n\tu32_t flags, po, v;\n\tint r;\n\n\tif(!HASPT(target))\n\t\treturn OK;\n\n\t/* If caller has had a reply to this request, return it. */\n\tif(RTS_ISSET(caller, VMREQUEST)) {\n\t\tif(caller->p_vmrequest.who == target->p_endpoint) {\n\t\t\tif(caller->p_vmrequest.vmresult == VMSUSPEND)\n\t\t\t\tminix_panic(\"check sees VMSUSPEND?\", NO_NUM);\n\t\t\tRTS_LOCK_UNSET(caller, VMREQUEST);\n#if 0\n\t\t\tkprintf(\"SYSTEM: vm_checkrange: returning vmresult %d\\n\",\n\t\t\t\tcaller->p_vmrequest.vmresult);\n#endif\n\t\t\treturn caller->p_vmrequest.vmresult;\n\t\t} else {\n#if 0\n\t\t\tkprintf(\"SYSTEM: vm_checkrange: caller has a request for %d, \"\n\t\t\t\t\"but our target is %d\\n\",\n\t\t\t\tcaller->p_vmrequest.who, target->p_endpoint);\n#endif\n\t\t}\n\t}\n\n\tpo = vir % I386_PAGE_SIZE;\n\tif(po > 0) {\n\t\tvir -= po;\n\t\tbytes += po;\n\t}\n\n\tvmassert(target);\n\tvmassert(bytes > 0);\n\n\tfor(v = vir; v < vir + bytes;  v+= I386_PAGE_SIZE) {\n\t\tu32_t phys;\n\n\t\t/* If page exists and it's writable if desired, we're OK\n\t\t * for this page.\n\t\t */\n\t\tif(vm_lookup(target, v, &phys, &flags) == OK &&\n\t\t\t!(wrfl && !(flags & I386_VM_WRITE))) {\n\t\t\tif(vm_checkrange_verbose) {\n#if 0\n\t\t\t\tkprintf(\"SYSTEM: checkrange:%s:%d: 0x%lx: write 0x%lx, flags 0x%lx, phys 0x%lx, OK\\n\",\n\t\t\t\ttarget->p_name, target->p_endpoint, v, wrfl, flags, phys);\n#endif\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(vm_checkrange_verbose) {\n\t\t\tkprintf(\"SYSTEM: checkrange:%s:%d: 0x%lx: write 0x%lx, flags 0x%lx, phys 0x%lx, NOT OK\\n\",\n\t\t\ttarget->p_name, target->p_endpoint, v, wrfl, flags, phys);\n\t\t}\n\n\t\tif(checkonly) {\n\t\t\treturn VMSUSPEND;\n\t\t}\n\n\t\t/* This range is not OK for this process. Set parameters\n\t\t * of the request and notify VM about the pending request.\n\t\t */\n\t\tif(RTS_ISSET(caller, VMREQUEST))\n\t\t\tminix_panic(\"VMREQUEST already set\", caller->p_endpoint);\n\t\tRTS_LOCK_SET(caller, VMREQUEST);\n\n\t\t/* Set parameters in caller. */\n\t\tcaller->p_vmrequest.writeflag = wrfl;\n\t\tcaller->p_vmrequest.start = vir;\n\t\tcaller->p_vmrequest.length = bytes;\n\t\tcaller->p_vmrequest.who = target->p_endpoint;\n\n\t\t/* Set caller in target. */\n\t\ttarget->p_vmrequest.requestor = caller;\n\n\t\t/* Connect caller on vmrequest wait queue. */\n\t\tcaller->p_vmrequest.nextrequestor = vmrequest;\n\t\tvmrequest = caller;\n\t\tif(!caller->p_vmrequest.nextrequestor) {\n\t\t\tint n = 0;\n\t\t\tstruct proc *vmr;\n\t\t\tfor(vmr = vmrequest; vmr; vmr = vmr->p_vmrequest.nextrequestor)\n\t\t\t\tn++;\n\t\t\tsoft_notify(VM_PROC_NR);\n#if 0\n\t\t\tkprintf(\"(%d) \", n);\n\t\t\tkprintf(\"%d/%d \",\n\t\t\t\tcaller->p_endpoint, target->p_endpoint);\n\t\t\tutil_stacktrace();\n#endif\n\t\t}\n\n#if 0\n\t\tkprintf(\"SYSTEM: vm_checkrange: range bad for \"\n\t\t\t\"target %s:0x%lx-0x%lx, caller %s\\n\",\n\t\t\t\ttarget->p_name, vir, vir+bytes, caller->p_name);\n\n\t\tkprintf(\"vm_checkrange kernel trace: \");\n\t\tutil_stacktrace();\n\t\tkprintf(\"target trace: \");\n\t\tproc_stacktrace(target);\n#endif\n\n\t\tif(target->p_endpoint == VM_PROC_NR) {\n\t\t\tkprintf(\"caller trace: \");\n\t\t\tproc_stacktrace(caller);\n\t\t\tkprintf(\"target trace: \");\n\t\t\tproc_stacktrace(target);\n\t\t\tminix_panic(\"VM ranges should be OK\", NO_NUM);\n\t\t}\n\n\t\treturn VMSUSPEND;\n\t}\n\n\treturn OK;\n}", "path": "lottery\\arch\\i386\\memory.c", "repo_name": "Compy/Minix", "stars": 1, "license": "None", "language": "c", "size": 224}
{"docstring": "/*===========================================================================*\n *\t\t\tinit_profile_clock\t\t\t\t     *\n *===========================================================================*/\n", "func_signal": "PUBLIC void init_profile_clock(u32_t freq)", "code": "{\n  int r, irq;\n\n  intr_disable();\n\n  if((irq = arch_init_profile_clock(freq)) >= 0) {\n\t/* Register interrupt handler for statistical system profiling.  */\n\tprofile_clock_hook.proc_nr_e = CLOCK;\n\tput_irq_handler(&profile_clock_hook, irq, profile_clock_handler);\n\tenable_irq(&profile_clock_hook);\n  }\n\n  intr_enable();\n}", "path": "lottery\\profile.c", "repo_name": "Compy/Minix", "stars": 1, "license": "None", "language": "c", "size": 224}
{"docstring": "/*===========================================================================*\n *                              vm_lookup                                    *\n *===========================================================================*/\n", "func_signal": "PUBLIC int vm_lookup(struct proc *proc, vir_bytes virtual, vir_bytes *physical, u32_t *ptent)", "code": "{\n\tu32_t *root, *pt;\n\tint pde, pte;\n\tu32_t pde_v, pte_v;\n\n\tvmassert(proc);\n\tvmassert(physical);\n\tvmassert(!(proc->p_rts_flags & SLOT_FREE));\n\n\tif(!HASPT(proc)) {\n\t\t*physical = virtual;\n\t\treturn OK;\n\t}\n\n\t/* Retrieve page directory entry. */\n\troot = (u32_t *) proc->p_seg.p_cr3;\n\tvmassert(!((u32_t) root % I386_PAGE_SIZE));\n\tpde = I386_VM_PDE(virtual);\n\tvmassert(pde >= 0 && pde < I386_VM_DIR_ENTRIES);\n\tpde_v = phys_get32((u32_t) (root + pde));\n\tif(!(pde_v & I386_VM_PRESENT)) {\n#if 0\n\t\tkprintf(\"vm_lookup: %d:%s:0x%lx: cr3 0x%lx: pde %d not present\\n\",\n\t\t\tproc->p_endpoint, proc->p_name, virtual, root, pde);\n\t\tkprintf(\"kernel stack: \");\n\t\tutil_stacktrace();\n#endif\n\t\treturn EFAULT;\n\t}\n\n\t/* Retrieve page table entry. */\n\tpt = (u32_t *) I386_VM_PFA(pde_v);\n\tvmassert(!((u32_t) pt % I386_PAGE_SIZE));\n\tpte = I386_VM_PTE(virtual);\n\tvmassert(pte >= 0 && pte < I386_VM_PT_ENTRIES);\n\tpte_v = phys_get32((u32_t) (pt + pte));\n\tif(!(pte_v & I386_VM_PRESENT)) {\n#if 0\n\t\tkprintf(\"vm_lookup: %d:%s:0x%lx: cr3 %lx: pde %d: pte %d not present\\n\",\n\t\t\tproc->p_endpoint, proc->p_name, virtual, root, pde, pte);\n\t\tkprintf(\"kernel stack: \");\n\t\tutil_stacktrace();\n#endif\n\t\treturn EFAULT;\n\t}\n\n\tif(ptent) *ptent = pte_v;\n\n\t/* Actual address now known; retrieve it and add page offset. */\n\t*physical = I386_VM_PFA(pte_v);\n\t*physical += virtual % I386_PAGE_SIZE;\n\n\treturn OK;\n}", "path": "lottery\\arch\\i386\\memory.c", "repo_name": "Compy/Minix", "stars": 1, "license": "None", "language": "c", "size": 224}
{"docstring": "/*===========================================================================*\n *\t\t\t\tdata_copy\t\t\t\t     *\n *===========================================================================*/\n", "func_signal": "PUBLIC int data_copy(\n\tendpoint_t from_proc, vir_bytes from_addr,\n\tendpoint_t to_proc, vir_bytes to_addr,\n\tsize_t bytes)", "code": "{\n  struct vir_addr src, dst;\n\n  src.segment = dst.segment = D;\n  src.offset = from_addr;\n  dst.offset = to_addr;\n  src.proc_nr_e = from_proc;\n  dst.proc_nr_e = to_proc;\n\n  return virtual_copy(&src, &dst, bytes);\n}", "path": "lottery\\arch\\i386\\memory.c", "repo_name": "Compy/Minix", "stars": 1, "license": "None", "language": "c", "size": 224}
{"docstring": "/*===========================================================================*\n *\t\t\t\tmain                                         *\n *===========================================================================*/\n", "func_signal": "PUBLIC void main()", "code": "{\n/* Start the ball rolling. */\n  struct boot_image *ip;\t/* boot image pointer */\n  register struct proc *rp;\t/* process pointer */\n  register struct priv *sp;\t/* privilege structure pointer */\n  register int i, j, s;\n  int hdrindex;\t\t\t/* index to array of a.out headers */\n  phys_clicks text_base;\n  vir_clicks text_clicks, data_clicks, st_clicks;\n  reg_t ktsb;\t\t\t/* kernel task stack base */\n  struct exec e_hdr;\t\t/* for a copy of an a.out header */\n\n  /* Clear the process table. Anounce each slot as empty and set up mappings \n   * for proc_addr() and proc_nr() macros. Do the same for the table with \n   * privilege structures for the system processes. \n   */\n  for (rp = BEG_PROC_ADDR, i = -NR_TASKS; rp < END_PROC_ADDR; ++rp, ++i) {\n  \trp->p_rts_flags = SLOT_FREE;\t\t/* initialize free slot */\n#if DEBUG_SCHED_CHECK\n\trp->p_magic = PMAGIC;\n#endif\n\trp->p_nr = i;\t\t\t\t/* proc number from ptr */\n\trp->p_endpoint = _ENDPOINT(0, rp->p_nr); /* generation no. 0 */\n        (pproc_addr + NR_TASKS)[i] = rp;        /* proc ptr from number */\n  }\n  for (sp = BEG_PRIV_ADDR, i = 0; sp < END_PRIV_ADDR; ++sp, ++i) {\n\tsp->s_proc_nr = NONE;\t\t\t/* initialize as free */\n\tsp->s_id = i;\t\t\t\t/* priv structure index */\n\tppriv_addr[i] = sp;\t\t\t/* priv ptr from number */\n  }\n\n  /* Set up proc table entries for processes in boot image.  The stacks of the\n   * kernel tasks are initialized to an array in data space.  The stacks\n   * of the servers have been added to the data segment by the monitor, so\n   * the stack pointer is set to the end of the data segment.  All the\n   * processes are in low memory on the 8086.  On the 386 only the kernel\n   * is in low memory, the rest is loaded in extended memory.\n   */\n\n  /* Task stacks. */\n  ktsb = (reg_t) t_stack;\n\n  for (i=0; i < NR_BOOT_PROCS; ++i) {\n\tint ci;\n\tbitchunk_t fv;\n\n\tip = &image[i];\t\t\t\t/* process' attributes */\n\trp = proc_addr(ip->proc_nr);\t\t/* get process pointer */\n\tip->endpoint = rp->p_endpoint;\t\t/* ipc endpoint */\n\trp->p_max_priority = ip->priority;\t/* max scheduling priority */\n\trp->p_priority = ip->priority;\t\t/* current priority */\n\trp->p_quantum_size = ip->quantum;\t/* quantum size in ticks */\n\trp->p_ticks_left = ip->quantum;\t\t/* current credit */\n\tstrncpy(rp->p_name, ip->proc_name, P_NAME_LEN); /* set process name */\n\t(void) get_priv(rp, (ip->flags & SYS_PROC));    /* assign structure */\n\tpriv(rp)->s_flags = ip->flags;\t\t\t/* process flags */\n\tpriv(rp)->s_trap_mask = ip->trap_mask;\t\t/* allowed traps */\n\n\t/* Warn about violations of the boot image table order consistency. */\n\tif (priv_id(rp) != s_nr_to_id(ip->proc_nr))\n\t\tkprintf(\"Warning: boot image table has wrong process order\\n\");\n\n\t/* Initialize call mask bitmap from unordered set.\n\t * A single SYS_ALL_CALLS is a special case - it\n\t * means all calls are allowed.\n\t */\n\tif(ip->nr_k_calls == 1 && ip->k_calls[0] == SYS_ALL_CALLS)\n\t\tfv = ~0;\t\t/* fill call mask */\n\telse\n\t\tfv = 0;\t\t\t/* clear call mask */\n\n\tfor(ci = 0; ci < CALL_MASK_SIZE; ci++) \t/* fill or clear call mask */\n\t\tpriv(rp)->s_k_call_mask[ci] = fv;\n\tif(!fv)\t\t\t/* not all full? enter calls bit by bit */\n\t\tfor(ci = 0; ci < ip->nr_k_calls; ci++)\n\t\t\tSET_BIT(priv(rp)->s_k_call_mask,\n\t\t\t\tip->k_calls[ci]-KERNEL_CALL);\n\n\tfor (j = 0; j < NR_SYS_PROCS && j < BITCHUNK_BITS; j++)\n\t\tif (ip->ipc_to & (1 << j))\n\t\t\tset_sendto_bit(rp, j);\t/* restrict targets */\n\n\tif (iskerneln(proc_nr(rp))) {\t\t/* part of the kernel? */ \n\t\tif (ip->stksize > 0) {\t\t/* HARDWARE stack size is 0 */\n\t\t\trp->p_priv->s_stack_guard = (reg_t *) ktsb;\n\t\t\t*rp->p_priv->s_stack_guard = STACK_GUARD;\n\t\t}\n\t\tktsb += ip->stksize;\t/* point to high end of stack */\n\t\trp->p_reg.sp = ktsb;\t/* this task's initial stack ptr */\n\t\thdrindex = 0;\t\t/* all use the first a.out header */\n\t} else {\n\t\thdrindex = 1 + i-NR_TASKS;\t/* servers, drivers, INIT */\n\t}\n\n\t/* Architecture-specific way to find out aout header of this\n\t * boot process.\n\t */\n\tarch_get_aout_headers(hdrindex, &e_hdr);\n\n\t/* Convert addresses to clicks and build process memory map */\n\ttext_base = e_hdr.a_syms >> CLICK_SHIFT;\n\ttext_clicks = (e_hdr.a_text + CLICK_SIZE-1) >> CLICK_SHIFT;\n\tdata_clicks = (e_hdr.a_data+e_hdr.a_bss + CLICK_SIZE-1) >> CLICK_SHIFT;\n\tst_clicks= (e_hdr.a_total + CLICK_SIZE-1) >> CLICK_SHIFT;\n\tif (!(e_hdr.a_flags & A_SEP))\n\t{\n\t\tdata_clicks= (e_hdr.a_text+e_hdr.a_data+e_hdr.a_bss +\n\t\t\tCLICK_SIZE-1) >> CLICK_SHIFT;\n\t\ttext_clicks = 0;\t   /* common I&D */\n\t}\n\trp->p_memmap[T].mem_phys = text_base;\n\trp->p_memmap[T].mem_len  = text_clicks;\n\trp->p_memmap[D].mem_phys = text_base + text_clicks;\n\trp->p_memmap[D].mem_len  = data_clicks;\n\trp->p_memmap[S].mem_phys = text_base + text_clicks + st_clicks;\n\trp->p_memmap[S].mem_vir  = st_clicks;\n\trp->p_memmap[S].mem_len  = 0;\n\n\t/* Set initial register values.  The processor status word for tasks \n\t * is different from that of other processes because tasks can\n\t * access I/O; this is not allowed to less-privileged processes \n\t */\n\trp->p_reg.pc = (reg_t) ip->initial_pc;\n\trp->p_reg.psw = (iskernelp(rp)) ? INIT_TASK_PSW : INIT_PSW;\n\n\t/* Initialize the server stack pointer. Take it down one word\n\t * to give crtso.s something to use as \"argc\".\n\t */\n\tif (isusern(proc_nr(rp))) {\t\t/* user-space process? */ \n\t\trp->p_reg.sp = (rp->p_memmap[S].mem_vir +\n\t\t\t\trp->p_memmap[S].mem_len) << CLICK_SHIFT;\n\t\trp->p_reg.sp -= sizeof(reg_t);\n\t}\n\n\t/* If this process has its own page table, VM will set the\n\t * PT up and manage it. VM will signal the kernel when it has\n\t * done this; until then, don't let it run.\n\t */\n\tif(priv(rp)->s_flags & PROC_FULLVM)\n\t\tRTS_SET(rp, VMINHIBIT);\n\t\n\t/* Set ready. The HARDWARE task is never ready. */\n\tif (rp->p_nr == HARDWARE) RTS_SET(rp, NO_PRIORITY);\n\tRTS_UNSET(rp, SLOT_FREE); /* remove SLOT_FREE and schedule */\n\talloc_segments(rp);\n  }\n\n#if SPROFILE\n  sprofiling = 0;      /* we're not profiling until instructed to */\n#endif /* SPROFILE */\n  cprof_procs_no = 0;  /* init nr of hash table slots used */\n\n  vm_running = 0;\n  krandom.random_sources = RANDOM_SOURCES;\n  krandom.random_elements = RANDOM_ELEMENTS;\n\n  /* MINIX is now ready. All boot image processes are on the ready queue.\n   * Return to the assembly code to start running the current process. \n   */\n  bill_ptr = proc_addr(IDLE);\t\t/* it has to point somewhere */\n  announce();\t\t\t\t/* print MINIX startup banner */\n  restart();\n}", "path": "roundrobin\\main.c", "repo_name": "Compy/Minix", "stars": 1, "license": "None", "language": "c", "size": 224}
{"docstring": "/*===========================================================================*\n *\t\t\t\tendpoint_lookup\t\t\t\t     *\n *===========================================================================*/\n", "func_signal": "PUBLIC struct proc *endpoint_lookup(endpoint_t e)", "code": "{\n\tint n;\n\n\tif(!isokendpt(e, &n)) return NULL;\n\n\treturn proc_addr(n);\n}", "path": "lottery\\proc.c", "repo_name": "Compy/Minix", "stars": 1, "license": "None", "language": "c", "size": 224}
{"docstring": "/*===========================================================================*\n *\t\t\t\tannounce\t\t\t\t     *\n *===========================================================================*/\n", "func_signal": "PRIVATE void announce(void)", "code": "{\n  /* Display the MINIX startup banner. */\n  kprintf(\"\\nMINIX %s.%s. \"\n#ifdef _SVN_REVISION\n\t\"(\" _SVN_REVISION \")\\n\"\n#endif\n      \"Copyright 2009, Vrije Universiteit, Amsterdam, The Netherlands\\n\",\n      OS_RELEASE, OS_VERSION);\n  kprintf(\"MINIX is open source software, see http://www.minix3.org\\n\");\n}", "path": "lottery\\main.c", "repo_name": "Compy/Minix", "stars": 1, "license": "None", "language": "c", "size": 224}
{"docstring": "/*===========================================================================*\n *\t\t\t\tread_clock\t\t\t\t     *\n *===========================================================================*/\n", "func_signal": "PUBLIC clock_t read_clock(void)", "code": "{\n\t/* Read the counter of channel 0 of the 8253A timer.  This counter\n\t * counts down at a rate of TIMER_FREQ and restarts at\n\t * TIMER_COUNT-1 when it reaches zero. A hardware interrupt\n\t * (clock tick) occurs when the counter gets to zero and restarts\n\t * its cycle.\n\t */     \n\tu32_t count;\n\n\toutb(TIMER_MODE, LATCH_COUNT);\n\tcount = inb(TIMER0);\n\tcount |= (inb(TIMER0) << 8);\n \n\treturn count;\n}", "path": "roundrobin\\arch\\i386\\clock.c", "repo_name": "Compy/Minix", "stars": 1, "license": "None", "language": "c", "size": 224}
{"docstring": "/*===========================================================================*\n *\t\t\t\tstacktrace\t\t\t\t     *\n *===========================================================================*/\n", "func_signal": "PUBLIC void proc_stacktrace(struct proc *proc)", "code": "{\n\treg_t bp, v_bp, v_pc, v_hbp;\n\n\tv_bp = proc->p_reg.fp;\n\n\tkprintf(\"%8.8s %6d 0x%lx \",\n\t\tproc->p_name, proc->p_endpoint, proc->p_reg.pc);\n\n\twhile(v_bp) {\n\t        if(data_copy(proc->p_endpoint, v_bp,\n\t\t\tSYSTEM, (vir_bytes) &v_hbp, sizeof(v_hbp)) != OK) {\n\t\t\tkprintf(\"(v_bp 0x%lx ?)\", v_bp);\n\t\t\tbreak;\n\t\t}\n\t\tif(data_copy(proc->p_endpoint, v_bp + sizeof(v_pc),\n\t\t\tSYSTEM, (vir_bytes) &v_pc, sizeof(v_pc)) != OK) {\n\t\t\tkprintf(\"(v_pc 0x%lx ?)\", v_pc);\n\t\t\tbreak;\n\t\t}\n\t\tkprintf(\"0x%lx \", (unsigned long) v_pc);\n\t\tif(v_hbp != 0 && v_hbp <= v_bp) {\n\t\t\tkprintf(\"(hbp %lx ?)\", v_hbp);\n\t\t\tbreak;\n\t\t}\n\t\tv_bp = v_hbp;\n\t}\n\tkprintf(\"\\n\");\n}", "path": "lottery\\arch\\i386\\exception.c", "repo_name": "Compy/Minix", "stars": 1, "license": "None", "language": "c", "size": 224}
{"docstring": "/*===========================================================================*\n *\t\t\tprofile_clock_stop\t\t\t\t     *\n *===========================================================================*/\n", "func_signal": "PUBLIC void stop_profile_clock()", "code": "{\n  intr_disable();\n  arch_stop_profile_clock();\n  intr_enable();\n\n  /* Unregister interrupt handler. */\n  disable_irq(&profile_clock_hook);\n  rm_irq_handler(&profile_clock_hook);\n}", "path": "lottery\\profile.c", "repo_name": "Compy/Minix", "stars": 1, "license": "None", "language": "c", "size": 224}
{"docstring": "/*return the index of the first attractor in the list containing point 'x'*/\n", "func_signal": "int idmc_attractor_list_check_point(idmc_attractor* head, double* x, double eps)", "code": "{\n\tint i;\n\tsrand(0);\n\tint N = idmc_attractor_list_length(head);\n\tif(N < MAX_ATTR_CHECK_LENGTH) {\n\t\tint i=0;\n\t\twhile(head) {\n\t\t\tif( idmc_attractor_check_point(head, x, eps) )\n\t\t\t\treturn i;\n\t\t\thead = head->next;\n\t\t\ti++;\n\t\t}\n \t} else {\n\t\tfor(int j = MAX_ATTR_CHECK_LENGTH; j; j--) {\n\t\t\ti =\t(int) (   (double)rand() / ((double)(RAND_MAX)+(double)(1)) ) * N;\n\t\t\tif( idmc_attractor_check_point( idmc_attractor_list_get(head, i), x, eps ) ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t}\n\treturn N;\n}", "path": "idmclib\\src\\attractors_list.c", "repo_name": "antoniofabio/idmclib", "stars": 1, "license": "None", "language": "c", "size": 582}
{"docstring": "//(*c).draft should hold dim*dim\n", "func_signal": "int interpolated_jac(Combined* c, double t0, double* y0, double t1, double* y1, double t, double f[])", "code": "{\n\tint status1,status2;\n\tint dim=(*c).dim;\n\tdouble* draft=(*c).draft1;//(double*) malloc(dim*dim*sizeof(double));\n\t//assumes that y0 y1 hold dim elements each\n\t\n\tdouble a;\n\tif (t1==t0)\n\t\ta=0;\n\telse\n\t\ta=(t-t0)/(t1-t0);\n\tstatus1=func_jac(t0,y0,f,c);\n\tstatus2=func_jac(t1,y1,draft,c);\n\t\n\tgsl_matrix_view m1v = gsl_matrix_view_array(draft,dim,dim);\n\tgsl_matrix_view m0v = gsl_matrix_view_array(f,dim,dim);\n\tgsl_matrix_scale(&m1v.matrix,a);\n\tgsl_matrix_scale(&m0v.matrix,1-a);\n\tgsl_matrix_add(&m0v.matrix,&m1v.matrix);\n\tif (status1==GSL_SUCCESS && status2==GSL_SUCCESS) \n\t\treturn GSL_SUCCESS;\n\telse\n\t\treturn GSL_SUCCESS-1;\n}", "path": "idmclib\\src\\lexp_aux.c", "repo_name": "antoniofabio/idmclib", "stars": 1, "license": "None", "language": "c", "size": 582}
{"docstring": "/*\n * calculate the model function  specified by the string \"name\"\n * with the specified values (var) and parameters (par).\n * return the result in f.\n *\n * On error condition (IDMC_E*) the top of the stack contains the\n * lua error message string.\n * \n * Note that var and f can point to the same array\n */\n", "func_signal": "static int eval_function(\n\t\tchar *name, idmc_model *model,\n\t\tconst double par[], const double var[], double f[])", "code": "{\n\tlua_State* L = model->L;\n\n\tjmp_buf *jmpbuf = lua_touserdata(L, 1);\n\tif (setjmp(*jmpbuf) != 0) {\n\t\treturn IDMC_EERROR; // return from longjmp\n\t}\n\tlua_atpanic(L, &idmc_panic);\n\n\tlua_pushstring(L, name);   /* function name */\n\tlua_gettable(L, LUA_GLOBALSINDEX);\n\n\tfor (int i = 0; i < model->par_len; i++)\n\t\tlua_pushnumber(L, par[i]);\n\tfor (int i = 0; i < model->var_len; i++)\n\t\tlua_pushnumber(L, var[i]);\n\n\tint err;\n\terr = lua_pcall(L, \n\t\tmodel->par_len + model->var_len, // args\n\t\tmodel->var_len,                  // returns\n\t\t0);\n\tif (err != 0) {\n\t\tstoreErrorMessage(model);\n\t\tif (err == LUA_ERRRUN) {\n\t\t\treturn IDMC_ERUN;\n\t\t}\n\t\telse if (err == LUA_ERRMEM) {\n\t\t\treturn IDMC_EMEM;\n\t\t}\n\t\telse if (err == LUA_ERRERR) {\n\t\t\treturn IDMC_EERROR; // \"impossible\" condition\n\t\t}\n\t\tassert(1);\n\t\treturn IDMC_EERROR; // not reached\n\t}\n\tfor (int i = model->var_len - 1; i > -1; i--) {\n\t\tif (!lua_isnumber(L, -1)) {\n\t\t\tlua_pop(L, i+1);\n\t\t\tsprintf(model->errorMessage, \"non numeric function result\");\n\t\t\treturn IDMC_ERUN;\n\t\t}\n\t\tf[i] = lua_tonumber(L, -1);\n\t\tlua_pop(L, 1);\n\t}\n\n\treturn IDMC_OK;\n}", "path": "idmclib\\src\\model.c", "repo_name": "antoniofabio/idmclib", "stars": 1, "license": "None", "language": "c", "size": 582}
{"docstring": "/*affects a! so we might need to clone a. This is just a wrapper of GSL function\n  the result is stored in a and tau.*/\n", "func_signal": "inline void qr_coded(double* a, double* tau, int m,int n)", "code": "{\n\tgsl_matrix_view av=gsl_matrix_view_array(a,m,n);\n\tint d;\n\tif (m<n) d=m; else d=n;\n\tgsl_vector_view tv=gsl_vector_view_array(tau,d);\t\n\tgsl_linalg_QR_decomp(&av.matrix,&tv.vector);\n}", "path": "idmclib\\src\\matrices.c", "repo_name": "antoniofabio/idmclib", "stars": 1, "license": "None", "language": "c", "size": 582}
{"docstring": "/*forms asymmetric matrix with the same lower triangular part*/\n", "func_signal": "inline void asym(double* a,int n)", "code": "{\n\tint i;\n\tgsl_matrix_view av=gsl_matrix_view_array(a,n,n);\n\tfor (i=1;i<n;i++){\n\t\tgsl_vector_view vsup=gsl_matrix_superdiagonal(&av.matrix,i);\n\t\tgsl_vector_view vsub=gsl_matrix_subdiagonal(&av.matrix,i);\n\t\tgsl_vector_memcpy(&vsup.vector,&vsub.vector);\n\t\tgsl_vector_scale(&vsup.vector,-1);\n\t}\n\tgsl_vector_view vsup=gsl_matrix_superdiagonal(&av.matrix,0);\n\tgsl_vector_set_zero(&vsup.vector);\n}", "path": "idmclib\\src\\matrices.c", "repo_name": "antoniofabio/idmclib", "stars": 1, "license": "None", "language": "c", "size": 582}
{"docstring": "/*a <- a+b, so a is affected */\n", "func_signal": "inline void sum(double* a, double* b, int d)", "code": "{\n\tgsl_vector_view av=gsl_vector_view_array(a,d);\n\tgsl_vector_view bv=gsl_vector_view_array(b,d);\n\tgsl_vector_add(&av.vector,&bv.vector);\n}", "path": "idmclib\\src\\matrices.c", "repo_name": "antoniofabio/idmclib", "stars": 1, "license": "None", "language": "c", "size": 582}
{"docstring": "/*assumes we have a \"coded\" QR decomposition (a,tau) of the original matrix*/\n", "func_signal": "inline void qr_decomp(double* a, double* tau, double* q, double* r,int m,int n)", "code": "{\n\tgsl_matrix_view qv=gsl_matrix_view_array(q,m,m);\n\tgsl_matrix_view rv=gsl_matrix_view_array(r,m,n);\n\tgsl_matrix_view av=gsl_matrix_view_array(a,m,n);\n\tint d;\n\tif (m<n) d=m; else d=n;\n\tgsl_vector_view tv=gsl_vector_view_array(tau,d);\t\n\tgsl_linalg_QR_unpack(&av.matrix,&tv.vector,&qv.matrix,&rv.matrix);\n}", "path": "idmclib\\src\\matrices.c", "repo_name": "antoniofabio/idmclib", "stars": 1, "license": "None", "language": "c", "size": 582}
{"docstring": "/*\nPops last error message from lua stack and stores it in model errorMessage buffer\n*/\n", "func_signal": "static void storeErrorMessage(idmc_model *model)", "code": "{\n\tif(lua_strlen(model->L, -1)>12)\n\t\tsprintf(model->errorMessage, \"%s\", lua_tostring(model->L, -1) + 12);\n\telse\n\t\tsprintf(model->errorMessage, \"%s\", lua_tostring(model->L, -1) + 0);\n\tlua_pop(model->L, 1);\n}", "path": "idmclib\\src\\model.c", "repo_name": "antoniofabio/idmclib", "stars": 1, "license": "None", "language": "c", "size": 582}
{"docstring": "// (*c).data is 2dim+2, (*c).draft should hold 5*dim*dim (sizeof(double))\n", "func_signal": "int Qsystem (double t, const double Q[], double RHS[], void *params)", "code": "{\n\tint status;\n\tCombined* c=(Combined*) params;\n\tint dim=(*c).dim;\n\tint dd=dim*dim;\n\n\tdouble* ptr=(*c).data;\n\tdouble tt0=*ptr;\n\tdouble* yy0=ptr+1;\n\tdouble tt1=*(ptr+dim+1);\n\tdouble* yy1=ptr+(dim+2);\n\n\n\tdouble* draft=(*c).draft2;//(double*) malloc(4*dim*dim*sizeof(double));\n\tdouble* Jac=draft;\n\n\tstatus=interpolated_jac(c,tt0, yy0, tt1, yy1, t, Jac);\n\n\tdouble* Qt=Jac+dd;\n\ttranspose(Q,Qt,dim,dim);\n\n\tdouble* tmp1=Qt+dd;\n\tmmproduct(Jac,Q,tmp1,dim,dim,dim);\n\tdouble* tmp2=tmp1+dd;\n\tmmproduct(Qt,tmp1,tmp2,dim,dim,dim);\n\tasym(tmp2,dim);\n\tmmproduct(Q,tmp2,RHS,dim,dim,dim);\n\n\tif (status==GSL_SUCCESS) \n\t\treturn GSL_SUCCESS;\n\telse\n\t\treturn GSL_SUCCESS-1;\n}", "path": "idmclib\\src\\lexp_aux.c", "repo_name": "antoniofabio/idmclib", "stars": 1, "license": "None", "language": "c", "size": 582}
{"docstring": "/*matrix(m*n) times vector(n)\n  a,b are not affected */\n", "func_signal": "inline void mvproduct(double* a, double* b, double* result,int m,int n)", "code": "{\n\tgsl_vector_view vv=gsl_vector_view_array(b,n);\n\tgsl_matrix_view av=gsl_matrix_view_array(a,m,n);\n\tgsl_vector_view rv=gsl_vector_view_array(result,m);\n\tgsl_blas_dgemv(CblasNoTrans,1.0,&(av.matrix),&(vv.vector),0.0,&(rv.vector)); \n}", "path": "idmclib\\src\\matrices.c", "repo_name": "antoniofabio/idmclib", "stars": 1, "license": "None", "language": "c", "size": 582}
{"docstring": "/*merge 2 attractors into 1 attractor*/\n", "func_signal": "void idmc_attractor_list_merge(idmc_attractor* head, int a, int b)", "code": "{\n\tint tmp;\n\tif(a>b) {\n\t\ttmp=a;\n\t\ta=b;\n\t\tb=tmp;\n\t}\n\tidmc_attractor* a1 = idmc_attractor_list_get(head, a);\n\tidmc_attractor* a2 = idmc_attractor_list_get(head, b);\n\tidmc_attractor_point* tail1 = idmc_attractor_point_last( a1->hd );\n\tidmc_attractor_point* head2 = a2->hd;\n\ttail1->next = idmc_attractor_point_clone(head2, head->dim);\n\tidmc_attractor_list_drop(a2);\n}", "path": "idmclib\\src\\attractors_list.c", "repo_name": "antoniofabio/idmclib", "stars": 1, "license": "None", "language": "c", "size": 582}
{"docstring": "//y0=y, t0=0, t1 is the final time, l is the array containing the Lyap.exps.\n", "func_signal": "inline int compute_lexp(idmc_model* model, double* par, int dim, \n\t\t\t\t\t\tdouble step, double* y, double t1, double* l, double* alloc_memory)", "code": "{\n\tint s,status;\n\tstatus=IDMC_OK;\n\t\n\tint dd=dim*dim;\n\t\n\tconst  gsl_odeiv_step_type* step_type= gsl_odeiv_step_rk2;\t\n\t\n\tgsl_odeiv_step* ode_step=gsl_odeiv_step_alloc (step_type, dim);\n\tgsl_odeiv_step* Q_step=gsl_odeiv_step_alloc (step_type, dim*dim);\n\t\n\tdouble t = 0;\n\t\n\tgsl_vector_view lv=gsl_vector_view_array(l,dim);\n\tgsl_vector_set_zero(&lv.vector);\n\t\n\tdouble* work_space=alloc_memory;\n\tdouble* y_err=work_space;\n\t\n\tdouble* Q=y_err+dim;\n\tdouble* Q_err=Q+dd;\n\tdouble* point_pair=Q_err+dd;\n\t\n\tdouble* draft1=alloc_memory+3*dim+2+2*dd;\n\tdouble* draft2=draft1+dd;\n\tdouble* draft3=draft2+4*dd;\n\n\tgsl_matrix_view Qv=gsl_matrix_view_array(Q,dim,dim);\n\tgsl_matrix_set_identity(&Qv.matrix);\n\n\tCombined c;\n\tc.model=model;\n\tc.dim=dim;\n\tc.pars=par;\n\tc.data=point_pair;\n\tc.draft1=draft1;\n\tc.draft2=draft2;\n\tc.draft3=draft3;\n\tgsl_odeiv_system sys = {func, NULL, dim, &c};\n\n\twhile (t < t1){\n\t\ts = elementary_step(&c, step, ode_step, Q_step, &sys, &t, \n\t\t\t\t\t\t\t y, Q, l, y_err, Q_err);\n\t\tif (s!=GSL_SUCCESS)\n\t\t\tstatus=IDMC_OK-1;\n\t}\n\n\tgsl_vector_scale(&lv.vector,1/(t1+step));//if t1 is set to zero, does not give an error \n\tgsl_odeiv_step_free (ode_step);\n\tgsl_odeiv_step_free (Q_step);\n\treturn(status);\n}", "path": "idmclib\\src\\lexp_aux.c", "repo_name": "antoniofabio/idmclib", "stars": 1, "license": "None", "language": "c", "size": 582}
{"docstring": "/* evaluate (f^n)(x) */\n", "func_signal": "int idmc_cycles_powf(idmc_model *model, int pow, double* par, double* var, double* ans)", "code": "{\n\tint i, status;\n\tdouble *tmp = (double*) malloc(model->var_len*sizeof(double));\n\tmemcpy(tmp, var, model->var_len*sizeof(double));\n\tfor (i = 0; i < pow; i++) {\n\t\tstatus = idmc_model_f(model, par, tmp, ans);\n\t\tmemcpy(tmp, ans, model->var_len * sizeof(double));\n\t\tif (status != IDMC_OK)\n\t\t\tbreak;\n\t}\n\tfree(tmp);\n\treturn status;\n}", "path": "idmclib\\src\\cycles.c", "repo_name": "antoniofabio/idmclib", "stars": 1, "license": "None", "language": "c", "size": 582}
{"docstring": "/*returns true if point lies on the attractor*/\n", "func_signal": "int idmc_attractor_check_point(idmc_attractor* p, double* x, double eps)", "code": "{\n\tidmc_attractor_point *ap = p->hd;\n\twhile(ap) {\n\t\tif(check_points(ap->x, x, p->dim, eps))\n\t\t\treturn 1;\n\t\tap = ap->next;\n\t}\n\treturn 0;\n}", "path": "idmclib\\src\\attractor.c", "repo_name": "antoniofabio/idmclib", "stars": 1, "license": "None", "language": "c", "size": 582}
{"docstring": "/*result <- a times b */\n", "func_signal": "inline void mmproduct(const double* a, const double* b, double* result,int m,int n,int p)", "code": "{\n\tgsl_matrix_view bv=gsl_matrix_view_array((double*) b,n,p);\n\tgsl_matrix_view av=gsl_matrix_view_array((double*) a,m,n);\n\tgsl_matrix_view rv=gsl_matrix_view_array(result,m,p);\n\tgsl_blas_dgemm(CblasNoTrans,CblasNoTrans,1.0,&(av.matrix),&(bv.matrix),0.0,&(rv.matrix)); \n}", "path": "idmclib\\src\\matrices.c", "repo_name": "antoniofabio/idmclib", "stars": 1, "license": "None", "language": "c", "size": 582}
{"docstring": "/* assumes (a,tau) is the \"coded\" QR decomp. computes QS, Q=Q(m,m) S=S(m,p)\n   affects s (stores there the result) */\n", "func_signal": "inline void qr_qmproduct(double* a, double* tau, \ndouble* s, int m,int n,int p)", "code": "{\n\tgsl_matrix_view av=gsl_matrix_view_array(a,m,n);\n\tgsl_matrix_view sv=gsl_matrix_view_array(s,m,p);\n\tint d;\n\tif (m<n) d=m; else d=n;\n\tgsl_vector_view tv=gsl_vector_view_array(tau,d);\t\n\tint i;\n\tfor (i=0;i<p;i++){\n\t\tgsl_vector_view scv=gsl_matrix_column(&sv.matrix,i);\n\t\tgsl_linalg_QR_Qvec(&av.matrix,&tv.vector,&scv.vector);\n\t}\n}", "path": "idmclib\\src\\matrices.c", "repo_name": "antoniofabio/idmclib", "stars": 1, "license": "None", "language": "c", "size": 582}
{"docstring": "/*\n * evaluate the model jacobian numerically\n */\n", "func_signal": "int idmc_model_NumJf(idmc_model *model,\n\t\t\t   const double par[],const double var[], double Jf[], double util[], double util2[], double util3[])", "code": "{\n\tint i,j, tmp;\n\tint p1 = model->var_len;\n\tdouble eps;\n\ttmp = idmc_model_f(model,  par, var, util); /*store F(x0)*/\n\tif(tmp!=IDMC_OK)\n\t\treturn tmp;\n\tfor(i=0; i<p1; i++) { //for each variable\n\t\tmemcpy(util2, var, p1 * sizeof(double)); /*store x0*/\n\t\teps = ((var[i] < 1) ? 1: var[i]) * IDMC_EPS_VALUE;\n\t\tutil2[i] = var[i]+eps;\n\t\ttmp = idmc_model_f(model,  par, util2, util3);\n\t\tif(tmp!=IDMC_OK)\n\t\t\treturn tmp;\n\t\tfor(j=0;j<p1; j++) //for each map component, store estimated derivative\n\t\t\tJf[j*p1+i] = (util3[j] - util[j]) / eps;\n\t}\n\treturn IDMC_OK;\n}", "path": "idmclib\\src\\model.c", "repo_name": "antoniofabio/idmclib", "stars": 1, "license": "None", "language": "c", "size": 582}
{"docstring": "/*a <- c times a */\n", "func_signal": "inline void mcproduct(double* a,double c,int m,int n)", "code": "{\n\tgsl_matrix_view av=gsl_matrix_view_array(a,m,n);\n\tgsl_matrix_scale(&av.matrix,c);\n}", "path": "idmclib\\src\\matrices.c", "repo_name": "antoniofabio/idmclib", "stars": 1, "license": "None", "language": "c", "size": 582}
{"docstring": "/*b = a' */\n", "func_signal": "inline void transpose(const double* a, double* b, int m,int n)", "code": "{\n\tgsl_matrix_view av=gsl_matrix_view_array((double*) a,m,n);\n\tgsl_matrix_view bv=gsl_matrix_view_array(b,n,m);\n\tgsl_matrix_transpose_memcpy(&bv.matrix,&av.matrix);\n}", "path": "idmclib\\src\\matrices.c", "repo_name": "antoniofabio/idmclib", "stars": 1, "license": "None", "language": "c", "size": 582}
{"docstring": "/* defines (f^power)(x) - x */\n", "func_signal": "static int root_function(const gsl_vector * x, void *params, gsl_vector * f)", "code": "{\n\tstruct root_function_data *data = params;\n\n\tfor (int i = 0; i < data->model->var_len; i++) {\n\t\tdata->result[i] = gsl_vector_get(x, i);\n\t}\n\n\tint status;\n\n\t/* evaluate (f^n)(x) */\n\tfor (int pow = 0; pow < data->power; pow++) {\n\t\tstatus = idmc_model_f(data->model, data->parameters, data->result, data->result);\n\n        // lua may leave a string on its stack.\n        // gsl_multiroot_fsolver_iterate returns GSL_EBADFUNC\n        // if this failes\n\t\tif (status != IDMC_OK) {\n\t\t\treturn GSL_EFAILED;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < data->model->var_len; i++) {\n\t\tgsl_vector_set(f, i, data->result[i] - gsl_vector_get(x, i));\n\t}\n\n\treturn GSL_SUCCESS;\n}", "path": "idmclib\\src\\cycles.c", "repo_name": "antoniofabio/idmclib", "stars": 1, "license": "None", "language": "c", "size": 582}
{"docstring": "/**\n * Aix has no vsyslog, so we use our own.\n * We limit the output to 1000 characters. That should be \n * sufficient for most error messages.\n */\n", "func_signal": "void meta_vsyslog(int class, const char* fmt, va_list ap)", "code": "{\n\tchar err[1000];\n\n\tvsnprintf(err, sizeof err, fmt, ap);\n\tsyslog(class, err);\n}", "path": "metasystems\\highlander-0.9.91\\src\\meta_misc.c", "repo_name": "timburks/highland", "stars": 1, "license": "None", "language": "c", "size": 464}
{"docstring": "/**\n * Returns the number of units since our epoch.\n * Recall that a unit == time unit, which is specified in milliseconds\n */\n", "func_signal": "static size_t units_since_epoch(\n\tstruct timeval* epoch,\n\tstruct timeval* now,\n\tsize_t unit_duration)", "code": "{\n\tstruct timeval diff;\n\tsize_t ms, units;\n\n\t/* Compute difference in time */\n\ttimersub(now, epoch, &diff);\n\n\t/* Now we have time elapsed since (our) epoch.\n\t * How many units have passed?\n\t */\n\tunits = diff.tv_sec * (1000 / unit_duration);\n\n\t/* Now for the microseconds */\n\tms = (diff.tv_usec / 1000);\n\n\tunits += (ms / unit_duration);\n\treturn units;\n}", "path": "metasystems\\highlander-0.9.91\\src\\meta_tsb.c", "repo_name": "timburks/highland", "stars": 1, "license": "None", "language": "c", "size": 464}
{"docstring": "/**\n * This is probably bad, but the need for speed forces us to\n * do it this way. I cannot see any security issues unless the\n * user of Highlander actually wants it to fail, so here we go.\n * Decide the mime type for a file, based on extension.\n */\n", "func_signal": "const char* get_mime_type(const char* filename)", "code": "{\n\tstatic struct {\n\t\tconst char* ext;\n\t\tconst char* mime;\n\t} map[] = {\n\t\t{ \"css\",\t\"text/css\" },\n\t\t{ \"html\",\t\"text/html\" },\n\t\t{ \"htm\",\t\"text/html\" },\n\t\t{ \"c\",\t\t\"text/plain\" },\n\t\t{ \"cpp\",\t\"text/plain\" },\n\t\t{ \"cxx\",\t\"text/plain\" },\n\t\t{ \"h\",\t\t\"text/plain\" },\n\t\t{ \"java\",\t\"text/plain\" },\n\t\t{ \"txt\",\t\"text/plain\" },\n\t\t{ \"xml\",\t\"text/xml\" },\n\t\t{ \"rtf\",\t\"text/rtf\" },\n\t\t{ \"sgml\",\t\"text/sgml\" },\n\n\t\t{ \"jpeg\",\t\"image/jpeg\" },\n\t\t{ \"jpg\",\t\"image/jpeg\" },\n\t\t{ \"png\",\t\"image/png\" },\n\t\t{ \"tiff\",\t\"image/tiff\" },\n\t\t{ \"gif\",\t\"image/gif\" },\n\t};\n\n\tsize_t i, nelem = sizeof(map) / sizeof(map[0]);\n\tchar ext[100];\n\n\tif(get_extension(filename, ext, sizeof ext)) {\n\t\tfor(i = 0; i < nelem; i++) {\n\t\t\tif(strcmp(map[i].ext, ext) == 0) {\n\t\t\t\treturn map[i].mime;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"application/octet-stream\";\n}", "path": "metasystems\\highlander-0.9.91\\src\\meta_misc.c", "repo_name": "timburks/highland", "stars": 1, "license": "None", "language": "c", "size": 464}
{"docstring": "/**\n * Checks to see if the client can connect or not.\n * A client can connect if \n * a) The ip is listed in the allowed list.\n * b) The list of allowed clients is empty.\n *\n * This is new stuff, so some notes.\n * a) Allow DNS names or not? \n *    We do not want to be vulnerable to DNS spoofing attacks.\n *    At the same time we want easy configuration. \n *    Safety first, which means that we only match IP for now.\n *    DNS also means that we must do a getpeername(), which is slow.\n *\n * b) If the caller has set us up to do access control, we'll \n *    already have a precompiled regexp available. All we now\n *    have to do is to regexec.\n */\n", "func_signal": "static int client_can_connect(tcp_server srv, struct sockaddr_in* addr)", "code": "{\n\tint vaddr;\n#ifdef HAVE_INET_NTOP\n\tchar sz[INET_ADDRSTRLEN + 1];\n#else\n\tchar sz[2000 + 1];\n#endif\n\n\tassert(srv != NULL);\n\tassert(addr != NULL);\n\n\tvaddr = addr->sin_addr.s_addr;\n\tif(!srv->pattern_compiled) {\n\t\t/* No permissions set. Allow all */\n\t\treturn 1;\n\t}\n\telse if(inet_ntop(AF_INET, &vaddr, sz, sizeof(sz)) == NULL) {\n\t\t/* Crappy addr or internal error. Deny */\n\t\treturn 0;\n\t}\n\telse if(regexec(&srv->allowed_clients, sz, 0, NULL, 0) == REG_NOMATCH){\n\t\t/* Not found in pattern */\n\t\treturn 0;\n\t}\n\telse\n\t\treturn 1;\n}", "path": "metasystems\\highlander-0.9.91\\src\\tcp_server.c", "repo_name": "timburks/highland", "stars": 1, "license": "None", "language": "c", "size": 464}
{"docstring": "/**\n * Compute the difference between now and when, then convert\n * things to a timespec struct and nanosleep() for a while.\n */\n", "func_signal": "static void timeval_sleep(\n\tstruct timeval* now,\n\tstruct timeval* when)", "code": "{\n\tstruct timeval diff;\n\tstruct timespec ts;\n\n\ttimersub(when, now, &diff);\n\n\tts.tv_sec = diff.tv_sec;\n\tts.tv_nsec = diff.tv_usec * 1000;\n\n\tnanosleep(&ts, NULL);\n}", "path": "metasystems\\highlander-0.9.91\\src\\meta_tsb.c", "repo_name": "timburks/highland", "stars": 1, "license": "None", "language": "c", "size": 464}
{"docstring": "/*\n * look for name=value as in $Version=\"1\";foo=bar  and \n * add name and value to the cookie .\n * Returns 1 on success, else a http error do\n */\n", "func_signal": "static int parse_new_cookie_name(cookie c, const char* input, meta_error e)", "code": "{\n\tconst char *s, *s2;\n\tcstring str;\n\n\tif( (s = strchr(input, ';')) == NULL) \n\t\treturn set_http_error(e, HTTP_400_BAD_REQUEST);\n\n\t/* skip ; and white space (if any) */\n\tif( (s = find_first_non_space(++s)) == NULL) {\n\t\t/* If all we had was ws */\n\t\treturn set_http_error(e, HTTP_400_BAD_REQUEST);\n\t}\n\n\tif( (s2 = strchr(s, '=')) == NULL) {\n\t\t/* Missing = in Name= */\n\t\treturn set_http_error(e, HTTP_400_BAD_REQUEST);\n\t}\n\n\tif( (str = cstring_new()) == NULL)  \n\t\treturn set_os_error(e, errno);\n\n\tif(!cstring_ncopy(str, s, (size_t) (s2 - s + 1))) {\n\t\tcstring_free(str);\n\t\treturn set_os_error(e, errno);\n\t}\n\t\t\n\tif(!cookie_set_name(c, c_str(str))) {\n\t\tcstring_free(str);\n\t\treturn set_os_error(e, errno);\n\t}\n\t\t\n\ts = s2 + 1;\n\tcstring_recycle(str);\n\tif( (s2 = strchr(s, ';')) == NULL) {\n\t\t/* Missing ; in Name=value; */\n\t\tcstring_free(str);\n\t\treturn set_http_error(e, HTTP_400_BAD_REQUEST);\n\t}\n\n\tif(!cstring_ncopy(str, s, (size_t)(s2 - s + 1))) {\n\t\tcstring_free(str);\n\t\treturn set_os_error(e, errno);\n\t}\n\n\tif(!cookie_set_value(c, c_str(str))) {\n\t\tcstring_free(str);\n\t\treturn set_os_error(e, errno);\n\t}\n\n\tcstring_free(str);\n\treturn 1;\n}", "path": "metasystems\\highlander-0.9.91\\src\\cookies.c", "repo_name": "timburks/highland", "stars": 1, "license": "None", "language": "c", "size": 464}
{"docstring": "/**\n * Returns 0 if no name/value was found, 1 if it was and -1 if syntax\n * error. Note that we write to line.\n */\n", "func_signal": "static int get_name_and_value(char *line, char *name, char *value)", "code": "{\n\tchar *s, *org_name = name;\n\tint quoted = 0;\n\n\t/* Remove comments, if any */\n\tif( (s = strchr(line, '#')) != NULL)\n\t\t*s = '\\0';\n\n\t/* Get first non-ws character */\n\ts = line;\n\twhile(*s != '\\0' && isspace((unsigned char)*s))\n\t\ts++;\n\n\t/* Was the line ws only? */\n\tif(*s == '\\0') \n\t\treturn 0;\n\n\t/* Now s points to the first char in name.\n\t * Copy to the param name */\n\t while(*s != '\\0' && !isspace((unsigned char)*s)) \n\t \t*name++ = *s++;\n\n\t/* See if we found a space or not.\n\t * The space(or tab) is required */\n\tif(*s == '\\0')\n\t\treturn -1;\n\n\t/* Terminate name and look for next non-ws\n\t * which is the start of the value\n\t */\n\t*name = '\\0';\n\twhile(*s != '\\0' && isspace((unsigned char)*s))\n\t\ts++;\n\n\t/* Skip leading \", if any */\n\tif(*s == '\"') {\n\t\tquoted = 1;\n\t\ts++;\n\t}\n\n\t/* Now copy value */\n\tif(quoted) {\n\t\twhile(*s != '\\0' && *s != '\"')\n\t\t\t*value++ = *s++;\n\t}\n\telse {\n\t\twhile(*s != '\\0' && !isspace((unsigned char)*s))\n\t\t\t*value++ = *s++;\n\t}\n\n\t/* Terminate value and perform sanity check */\n\t*value = '\\0';\n\tif(strlen(org_name) == 0)\n\t\treturn -1;\n\n\treturn 1;\n}", "path": "metasystems\\highlander-0.9.91\\src\\meta_configfile.c", "repo_name": "timburks/highland", "stars": 1, "license": "None", "language": "c", "size": 464}
{"docstring": "/*\n * The old cookie format is (hopefully) name=value\n * where value may be quoted.\n */\n", "func_signal": "int parse_old_cookie(http_request req, const char* input, meta_error e)", "code": "{\n\tcookie c = NULL;\n\tcstring name = NULL, value = NULL;\n\n\tif( (name = cstring_new()) == NULL\n\t||  (value = cstring_new()) == NULL) \n\t\tgoto memerr;\n\n\twhile(*input != '\\0' && *input != '=') {\n\t\tif(!cstring_charcat(name, *input++)) \n\t\t\tgoto memerr;\n\t}\n\n\tif(*input != '=') {\n\t\tcstring_free(name);\n\t\tcstring_free(value);\n\t\treturn set_http_error(e, HTTP_400_BAD_REQUEST);\n\t}\n\n\tinput++; /* Skip '=' */\n\tif(!cstring_copy(value, input)) \n\t\tgoto memerr;\n\n\tif( (c = cookie_new()) == NULL) \n\t\tgoto memerr;\n\n\tif(!cookie_set_name(c, c_str(name)) \n\t|| !cookie_set_value(c, c_str(value))) \n\t\tgoto memerr;\n\n\tcstring_free(name);\n\tcstring_free(value);\n\tcookie_set_version(c, 0);\n\tif(!request_add_cookie(req, c)) {\n\t\tset_os_error(e, errno);\n\t\tcookie_free(c);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n\nmemerr:\n\tcstring_free(name);\n\tcstring_free(value);\n\tcookie_free(c);\n\treturn set_os_error(e, ENOMEM);\n}", "path": "metasystems\\highlander-0.9.91\\src\\cookies.c", "repo_name": "timburks/highland", "stars": 1, "license": "None", "language": "c", "size": 464}
{"docstring": "/*\n * Make the next node the current so that list_next() loops will\n * work as expected. By expected I mean that if you iterate on a 3-node list,\n * (A,B,C), and then delete B, list_next() returns C.\n */\n", "func_signal": "list_iterator list_remove_node(list lst, list_iterator old)", "code": "{\n\tlist_iterator new;\n\tlist node = old.node;\n\n\tassert(lst != NULL);\n\n\t/* Update cache */\n\tif(lst->data == node) \n\t\tlst->data = node->prev;\n\n\t/* Remove node from backward pointing list */\n\tif(node->next != NULL) \n\t\tnode->next->prev = node->prev;\n\n\t/* Now remove this node in the forward pointing list */\n\tnode->prev->next = node->next;\n\n\t/* 'Create' the new iterator */\n\tnew.node = node->next;\n\n\t/* Free memory used by the node, but do not free\n\t * memory used by the data. This is intended.\n\t */\n\tmem_free(node);\n\treturn new;\n}", "path": "metasystems\\highlander-0.9.91\\src\\meta_list.c", "repo_name": "timburks/highland", "stars": 1, "license": "None", "language": "c", "size": 464}
{"docstring": "/* Returns -1 on error, else the number */\n", "func_signal": "long fs_atol(const char* s)", "code": "{\n\tlong val = 0;\n\tassert(s != NULL);\n\n\twhile(*s) {\n\t\tif(isdigit((int)*s)) \n\t\t\tval = (val * 10) + (*s - '0');\n\t\telse \n\t\t\treturn -1;\n\n\t\ts++;\n\t}\n\n\treturn val;\n}", "path": "metasystems\\highlander-0.9.91\\src\\meta_misc.c", "repo_name": "timburks/highland", "stars": 1, "license": "None", "language": "c", "size": 464}
{"docstring": "/* Free the list only, not the data. */\n", "func_signal": "void sublist_free(list lst)", "code": "{\n\tlist p;\n\n\twhile(lst != NULL) {\n\t\tp = lst;\n\t\tlst = lst->next;\n\t\tmem_free(p);\n\t}\n}", "path": "metasystems\\highlander-0.9.91\\src\\meta_list.c", "repo_name": "timburks/highland", "stars": 1, "license": "None", "language": "c", "size": 464}
{"docstring": "/**\n * Create a timeval struct, dest, containing a proper time. The time\n * is offset since epoch, measured in units. Each unit has a duration\n * of unit_duration ms, so beware of overflows. \n */\n", "func_signal": "static void unit_to_timeval(\n\tstruct timeval* epoch,\n\tstruct timeval* dest,\n\tsize_t unit,\n\tsize_t unit_duration)", "code": "{\n\tstruct timeval tv;\n\tsize_t rest, seconds, units_per_second;\n\n\tunits_per_second = 1000/ unit_duration;\n\tassert(units_per_second != 0);\n\n\tseconds = (unit / units_per_second);\n\trest = (unit % units_per_second);\n\n\ttv.tv_sec = seconds;\n\n\t/*\n\t * Resolution is in ms, but usec is in us. We multiply with 1000 \n\t * to get things right.\n\t */\n\ttv.tv_usec = (rest * unit_duration * 1000);\n\ttimeradd(epoch, &tv, dest);\n}", "path": "metasystems\\highlander-0.9.91\\src\\meta_tsb.c", "repo_name": "timburks/highland", "stars": 1, "license": "None", "language": "c", "size": 464}
{"docstring": "/* Helper function to have the algorithm one place only */\n", "func_signal": "int parse_multivalued_fields(\n\tvoid *dest,\n\tconst char* value,\n\tint(*set_func)(void* dest, const char* value, meta_error e),\n\tmeta_error e)", "code": "{\n\tconst int sep = (int)',';\n\tchar buf[100];\n\tchar* s;\n\n\tassert(NULL != dest);\n\tassert(NULL != value);\n\n\twhile( (s = strchr(value, sep)) != NULL) {\n\t\t/* The correct type would be ptrdiff_t, but -ansi -pedantic complains */\n\t\tsize_t span = (size_t)(s - value);\n\t\tif(span + 1 > sizeof buf) {\n\t\t\t/* We don't want buffer overflow... */\n\t\t\tvalue = s + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tmemcpy(buf, value, span);\n\t\tbuf[span] = '\\0';\n\t\tif(!set_func(dest, buf, e))\n\t\t\treturn 0;\n\n\t\tvalue = s + 1;\n\t}\n\n\treturn set_func(dest, value, e);\n}", "path": "metasystems\\highlander-0.9.91\\src\\parse_http.c", "repo_name": "timburks/highland", "stars": 1, "license": "None", "language": "c", "size": 464}
{"docstring": "/* Locate an existing entry and return a list and iterator to it */\n", "func_signal": "static inline int \nsm_locate(stringmap sm, const char* s, list* plist, list_iterator* pi)", "code": "{\n\tunsigned long hashval;\n\tsize_t hid;\n\t\n\tassert(sm != NULL);\n\tassert(s != NULL);\n\tassert(strlen(s) > 0);\n\n\thashval = hash((const unsigned char*)s);\n\thid = hashval % sm->nelem;\n\t*plist = sm->hashtable[hid];\n\n\tif(*plist != NULL) {\n\t\tfor(*pi = list_first(*plist); !list_end(*pi); *pi = list_next(*pi)) {\n\t\t\tstruct entry* e = list_get(*pi);\n\t\t\tif(e->hashval == hashval && strcmp(s, e->s) == 0)\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}", "path": "metasystems\\highlander-0.9.91-patched\\src\\meta_stringmap.c", "repo_name": "timburks/highland", "stars": 1, "license": "None", "language": "c", "size": 464}
{"docstring": "/* Local helper.\n * Accepts an alphanumeric character in the range [0-9a-fA-F] \n * and returns it converted to an integer in the range 0-15. \n */\n", "func_signal": "static int hexchar2int(int c)", "code": "{\n    if(c >= '0' && c <= '9')\n        return c - '0';\n    else if(c >= 'a' && c <= 'f') \n        return 10 + c - 'a';\n    else if(c >= 'A' && c <= 'F') \n        return 10 + c - 'A';\n    else /* Illegal input. */\n        return -1;\n}", "path": "metasystems\\highlander-0.9.91-patched\\src\\rfc1738.c", "repo_name": "timburks/highland", "stars": 1, "license": "None", "language": "c", "size": 464}
{"docstring": "/* Local helper.\n * Decodes an encoded character. Returns -1 on errors, else an \n * integer which represents a decoded character. Note that hexchar2int\n * will implicitly detect end of string ('\\0').\n */\n", "func_signal": "static int decode(const char* src)", "code": "{\n    int c1, c2;\n\n\tif(*src != '%')\n\t\treturn -1;\n\n    c1 = hexchar2int((unsigned char)*++src); \n    if(c1 == -1) \n        return -1;\n\n    c2 = hexchar2int((unsigned char)*++src);\n    if(c2 == -1)\n        return -1;\n\n    return (c1 << 4) + c2;\n}", "path": "metasystems\\highlander-0.9.91-patched\\src\\rfc1738.c", "repo_name": "timburks/highland", "stars": 1, "license": "None", "language": "c", "size": 464}
{"docstring": "/* Will just enhance output by printing start of frame message: */\n", "func_signal": "static int firstslot(void* buf, void* arg)", "code": "{\n\t(void)buf;\n\t(void)arg;\n\tfprintf(stderr, \"START OF FRAME\\n\");\n\treturn 1;\n}", "path": "metasystems\\highlander-0.9.91\\src\\meta_tsb.c", "repo_name": "timburks/highland", "stars": 1, "license": "None", "language": "c", "size": 464}
{"docstring": "/* Local helper \n * Returns 1 on success, 0 on illegal input.\n */\n", "func_signal": "static int encode(int c, char* dest)", "code": "{\n    int high, low;\n\n\t/* Don't encode illegal input */\n\tif(c < 0 || c > 255)\n\t\treturn 0;\n\n    high = (c & 0xf0) >> 4;\n    low = (c & 0x0f);\n\n    if(high > 9) \n        high = 'A' + high - 10;\n    else\n        high = '0' + high;\n\n    if(low > 9)\n        low = 'A' + low - 10;\n    else\n        low = '0' + low;\n\n    *dest++ = '%';\n    *dest++ = high;\n    *dest = low;\n\treturn 1;\n}", "path": "metasystems\\highlander-0.9.91-patched\\src\\rfc1738.c", "repo_name": "timburks/highland", "stars": 1, "license": "None", "language": "c", "size": 464}
{"docstring": "/*\n * Some of the properties received belongs to the connection object\n * instead of the request object, as one connection may \"live\" longer\n * than the request.\n */\n", "func_signal": "int parse_request_headerfield(\n\tconnection conn,\n\tconst char* name,\n\tconst char* value,\n\thttp_request req, \n\tmeta_error e)", "code": "{\n\tsize_t i, size;\n\tint idx;\n\n\tentity_header eh = request_get_entity_header(req);\n\tgeneral_header gh = request_get_general_header(req);\n\n\t/* Is it a general header field? */\n\tif( (idx = find_general_header(name)) != -1)\n\t\treturn parse_general_header(idx, gh, value, e);\n\n\t/* Is it an entity header field? */\n\tif( (idx = find_entity_header(name)) != -1)\n\t\treturn parse_entity_header(idx, eh, value, e);\n\n\t/* Now locate the handling function.\n\t * Go for the connection_map first as it is smaller */\n\tsize = sizeof(connection_map) / sizeof(connection_map[0]);\n\tfor(i = 0; i < size; i++) {\n\t\tif(0 == strcmp(name, connection_map[i].name)) {\n\t\t\t/* execute the handling function and return */\n\t\t\treturn connection_map[i].handler(conn, value, e);\n\t\t}\n\t}\n\n\tif( (idx = find_request_header(name)) != -1)\n\t\treturn parse_request_header(idx, req, value, e);\n\n\t/* We have an unknown fieldname if we reach this point */\n\t#if 0\n\tfprintf(stderr, \"Ignoring unknown request header field:%s, value %s\\n\", name, value);\n\t#endif\n\treturn 1; /* Silently ignore the unknown field */\n}", "path": "metasystems\\highlander-0.9.91\\src\\parse_http.c", "repo_name": "timburks/highland", "stars": 1, "license": "None", "language": "c", "size": 464}
{"docstring": "/**\n * Checks to see if the client can connect or not.\n * A client can connect if \n * a) The ip is listed in the allowed list.\n * b) The list of allowed clients is empty.\n *\n * This is new stuff, so some notes.\n * a) Allow DNS names or not? \n *    We do not want to be vulnerable to DNS spoofing attacks.\n *    At the same time we want easy configuration. \n *    Safety first, which means that we only match IP for now.\n *    DNS also means that we must do a getpeername(), which is slow.\n *\n * b) If the caller has set us up to do access control, we'll \n *    already have a precompiled regexp available. All we now\n *    have to do is to regexec.\n */\n", "func_signal": "static int client_can_connect(tcp_server srv, struct sockaddr_in* addr)", "code": "{\n\tint vaddr;\n#ifdef HAVE_INET_NTOP\n\tchar sz[INET_ADDRSTRLEN + 1];\n#else\n\tchar sz[2000 + 1];\n#endif\n\n\tassert(srv != NULL);\n\tassert(addr != NULL);\n\n\tvaddr = addr->sin_addr.s_addr;\n\tif(!srv->pattern_compiled) {\n\t\t/* No permissions set. Allow all */\n\t\treturn 1;\n\t}\n\telse if(inet_ntop(AF_INET, &vaddr, sz, sizeof(sz)) == NULL) {\n\t\t/* Crappy addr or internal error. Deny */\n\t\treturn 0;\n\t}\n\telse if(regexec(&srv->allowed_clients, sz, 0, NULL, 0) == REG_NOMATCH){\n\t\t/* Not found in pattern */\n\t\treturn 0;\n\t}\n\telse\n\t\treturn 1;\n}", "path": "metasystems\\highlander-0.9.91-patched\\src\\tcp_server.c", "repo_name": "timburks/highland", "stars": 1, "license": "None", "language": "c", "size": 464}
{"docstring": "// word = name proc \n", "func_signal": "void code1_(long bb)", "code": "{ \n\tint nlen,nlen8; \n\tchar newword[50],*azpc; \n\tunsigned char *az_; \n\tlong *i,*ptr,lent,lw; \n\tint j; \n\tazp=*(long*)az; \n\taz_=az; \n\taz=nv; \n\tis0_4(); \n\tnlen=strlen(word); \n\tnlen8=(nlen+2+3)&(~3); \n\tstrcpy(newword,\"     \"); \n\tstrcpy(newword+(nlen8-nlen-2),word); \n\tnewword[nlen8-2]=nlen8/4-1; \n\tnewword[nlen8-1]=(0x40*(char)delhd); \n\tazpc=(char*)&azp; \n\tif ((*(azpc+3))&0x10) \n\t{ \n\t\tprintf(\"\"); \n\t\tlw=*(char*)(az_+2); \n\t\tlw=(lw & 7)*4; \n\t\tlent=*(long*)(az_-lw-8); \n\t\t//reform table \n\t\tfor (j=0;j<(-lent/4)-1;j++) \n\t\t{ \n\t\t\t*(long*)(memory+*(long*)(az_-lw+lent+j*4-4))=(long)(bb); \n\t\t} \n\t\t*(long*)(az_-lw-4)=(long)(bb); \n//\t\t*(long*)az_=(*(long*)az_)&((~0x50000000)); \n//\t\t*(long*)az_=(*(long*)az_)|(0x40000000*(char)delhd); \n\t\t*(char*)(az_+3)&=(~0x50); \n\t\t*(char*)(az_+3)|=(0x40*(char)delhd); \n\t\t//remove table \n\t\tfor (ptr=(long*)(az_-lw-4);ptr<=(long*)nv;ptr++) \n\t\t\t*(ptr+lent/4)=*ptr; \n\t\tnv+=lent; \n\t} \n\telse \n\t{ \n\t\tfor (i=(long*)nv;i>=(long*)(az);i--) \n\t\t\t*(i+nlen8/4+1)=*i; \n\t\t*(long*)az=(long)(bb); \n\t\tfor (j=0;j<nlen8/4;j++) \n\t\t\t*(long*)(az+j*4+4)=*(long*)(newword+j*4); \n\t\taz=az_; \n\t\tnv+=nlen8+4; \n\t} \n\tdelhd=1; \n}", "path": "gen\\sun\\ng.c", "repo_name": "telnov1971/DSSP-32", "stars": 0, "license": "None", "language": "c", "size": 340}
{"docstring": "//*****************************************************************\n//***   NEWCONTEXT - \u2569\u256c\u2560\u2514\u2550\u2500\u2514 \u255a\u2550\u255a\u2553\u255a\u2514\u2566\u255a\u255f\u2514\u2553\u255a\u255a \u2550\u256c\u252c\u256c\u251c\u256c \u2569\u256c\u2550\u2565\u253c\u2569\u2564\u2565\u2514    **** \n//***************************************************************** \n// \u256c\u2534\u255f\u2514\u255f\u253c\u2553 \u0442\u221a\u0447\u044e\u0442\u0440: \n//          [ PRA, CA, Addr, Len, OwnLen ] NEWCONTEXT [ ]\n// \u0443\u0444\u0445 :\n//  PRA - \u0440\u0444\u0401\u0445\u0451 \u044f\u0401\u044e\u040e\u0445\u0444\u0454\u0401\u221a, \u044e\u044f\u0401\u0445\u0444\u0445\u044b\u00a0\u25a0\u2219\u0445\u0449 \u0404\u0445\u044b\u044e \u044f\u0401\u044e\u040e\u0445\u0451\u0451\u0440 \n//   ( \u00a4\u0404\u044e \u0404\u0445\u044b\u044e \u0444\u044e\u044b\u0446\u044d\u044e \u0441\u221a\u0404\u2116 \u0448\u044d\u0404\u0445\u0401\u044f\u0401\u0445\u0404\u0448\u0401\u0454\u0445\u044c\u221a\u044c, \u0404.\u0445. \u0442 \u044f\u0401\u044e\u040e.\u044a\u044e\u0444\u0445 )         \n//  CA - \u0440\u0444\u0401\u0445\u0451 \u0441\u044b\u044e\u044a\u0440-\u044a\u044e\u044d\u0404\u0445\u044a\u0451\u0404\u0440, \u044a\u044e\u0404\u044e\u0401\u221a\u0449 \u044d\u0440\u0444\u044e \u044f\u0401\u044e\u0448\u044d\u0448\u040e\u0448\u0440\u044b\u0448\u0447\u0448\u0401\u044e\u0442\u0440\u0404\u2116\n//  Addr,Len - \u0440\u0444\u0401\u0445\u0451 \u0448 \u0444\u044b\u0448\u044d\u0440 \u0401\u0440\u0441\u044e\u045e\u0445\u0449 \u044e\u0441\u044b\u0440\u0451\u0404\u0448, \u044e\u0404\u0442\u044e\u0444\u0448\u044c\u044e\u0449 \u044f\u044e\u0444 \u0451\u0404\u0445\u044a\u0448 \n//  OwnLen - \u0444\u044b\u0448\u044d\u0440 Own-\u044e\u0441\u044b\u0440\u0451\u0404\u0448  \n//\n", "func_signal": "void _NewContext (void)", "code": "{     // NEWCONTEXT\n\tpCNTXT pCA;\t// pointer to structure of new context-block\n\tint32 Addr;\t\t// DSSP-address for workspace of new process\n\tlptr SaveCsp;\t// for saving csp\n\tint32 i,n;\t\t// for copying bytes in own region\n\n\tpCA = (pCNTXT)ADR_ML(AITEM(3));\n\tAddr= AITEM(2);\n\n\t// let's set fields of new CNTXT structure :\n\n\t// opsb, opsp\n\tpCA->_opsb= (lptr)Addr;\n\tpCA->_opsp= (lptr)Addr;\n\n\t// csb, OwnBase\n    Addr = Addr + AITEM(1) ; // Addr + Len\n\tpCA->_csb = (lptr)Addr ;\n\tpCA->_OwnBase= Addr;\n\n\t// prepare control stack and set its pointer :\n\tSaveCsp = csp ; // save csp\n\tcsp= (lptr)Addr;\n\tPut_BTrap ();\t\t// prepare Bottom Trap\n\tCPUSH((lptr)AITEM(4)+1);\t// prepare pc \n\tpCA->_csp= csp;\n\tcsp = SaveCsp ;  // restore csp\n\n\t//  now initiate other fields of CNTXT :\n\n\t// registers for data : DBAdr, TypeAdr \n\t// don't need to be initiated\n\n\t//      ............     (for future)\n  \t//// initiate interrupt flag of new process \n\t//// to be the same as that of current process\n\tpCA->_IEFlag= IEFlag;\n\n\t// now let's initiate region of own variables\n\t//// to be the same as that of current process\n    n= AT;\n    // copy n bytes from OwnBase to Addr\n    for ( i=0; i<n; i++ )\n       MB(Addr+i)= MB(OwnBase+i);\n\n\tADELn(5); // delete parameters of NEWCONTEXT from stack\n\n }//_NewContext\n\n//*******************************************************************\n//***     TRANSFER  -  \u2569\u256c\u2560\u2514\u2550\u2500\u2514 \u2567\u253c\u2568\u253c\u2569\u2566\u2590\u256b\u253c\u2550\u255a\u2580 \u2569\u256c\u2550\u2565\u253c\u2569\u2564\u2565\u256c\u252c      *********\n//*******************************************************************\n// \u256c\u2534\u255f\u2514\u255f\u253c\u2553 \u0442\u221a\u0447\u044e\u0442\u0440: \n//                 [ CA, CB ]  TRANSFER [CC]\n// \u0443\u0444\u0445 :\n// CA - \u0440\u0444\u0401\u0445\u0451 \u0441\u044b\u044e\u044a\u0440 \u0444\u044b\u00a0 \u0451\u044e\u0457\u0401\u0440\u044d\u0445\u044d\u0448\u00a0 \u0404\u0445\u044a\u0454\u2219\u0445\u0443\u044e \u044a\u044e\u044d\u0404\u0445\u044a\u0451\u0404\u0440\n//  CB - \u0440\u0444\u0401\u0445\u0451 \u0441\u044b\u044e\u044a\u0440-\u044a\u044e\u044d\u0404\u0445\u044a\u0451\u0404\u0440, \u044d\u0440 \u044a\u044e\u0404\u044e\u0401\u221a\u0449 \u044d\u0440\u0444\u044e \u044f\u0445\u0401\u0445\u044a\u044b\u25a0\u045e\u0448\u0404\u2116\u0451\u00a0\n//  CC - \u0440\u0444\u0401\u0445\u0451 \u0441\u044b\u044e\u044a\u0440-\u044a\u044e\u044d\u0404\u0445\u044a\u0451\u0404\u0440, \u0451 \u044a\u044e\u0404\u044e\u0401\u044e\u0443\u044e \u0451\u0445\u0449\u045e\u0440\u0451 \u044f\u0445\u0401\u0445\u044a\u044b\u25a0\u045e\u0448\u044b\u0448\u0451\u2116\n// \u255f\u0440\u044c\u0445\u0404\u0448\u044c, \u045e\u0404\u044e CC \u044c\u044e\u0446\u0445\u0404 \u044d\u0445 \u044e\u0441\u00a0\u0447\u0440\u0404\u0445\u044b\u2116\u044d\u044e \u0451\u044e\u0442\u044f\u0440\u0444\u0440\u0404\u2116 \u0451 \u2564B\n//\nvoid _Transfer (void) {     // TRANSFER\n\tpCNTXT\tpCB,pCA;\n\n\tAPOP(pCB);\n\tpCB=(pCNTXT)ADR_ML(pCB); // pointer to new context structure\n\tpCA=(pCNTXT)ADR_ML(AT); // pointer to current context structure\n\n\t//------------ let's save current CONTEXT in pCA-> structure\n\t// opsp, pc,csp\n\tCPUSH(pc);\n\tpCA->_opsp= opsp;\n\tpCA->_csp = csp ;\n\n\t// opsb, csb, OwnBase\n\t// this saving is not necessary :\n\tpCA->_opsb= opsb;\n\tpCA->_csb = csb ;\n\tpCA->_OwnBase= OwnBase;\n\t// because they don't been modify during process functionality\n\n\t//  now save other fields of CNTXT :\n\n\t// registers for data :\n\tpCA->_DBAdr  = DBAdr  ;\n\tpCA->_TypeAdr= TypeAdr;\n\n\t//      ............     (for future saving)\n  \t//// save interrupt flag of process \n\tpCA->_IEFlag= IEFlag;\n\n\t// ------------ let's restore new CONTEXT in pCB-> structure\n\t// in the same order :\n\n\t// opsp, pc,csp\n\topsp= pCB->_opsp ;\n\tcsp = pCB->_csp  ;\n\tCPOP(pc);\n\n\t// opsb, csb, OwnBase,\n\topsb= pCB->_opsb ;\n\tcsb = pCB->_csb ;\n\tOwnBase = pCB->_OwnBase;\n\n\t//  now restore  other fields of CNTXT :\n\n\t// registers for data :\n\tDBAdr  = pCB->_DBAdr ;\n\tTypeAdr= pCB->_TypeAdr;\n\t\n\t//      ............ (for future saving)\n  \t//// restore interrupt flag of process \n\tIEFlag= pCB->_IEFlag;\n\t  // and test state of interrupt handling\n\tTEST_INTR();  \n\t  // if IFlag then   ENABLE DSSP-interrupts     \n\t  //           else DISABLE DSSP-interrupts     \n\n\t// set parameter CC as DSSP-address of old context-block\n\tAT= DSSPADR(pCA);\n}", "path": "dssp\\contexts.c", "repo_name": "telnov1971/DSSP-32", "stars": 0, "license": "None", "language": "c", "size": 340}
{"docstring": "//------- SET VALUE for DATA BLOCK in DSSP memory ------//\n", "func_signal": "void _SetB (void)", "code": "{ // !!!MB\n       // [ V, A, n ] !!!MB [ ]\n       // Assign value V to every byte of block\n       // for n bytes, starting at A\n       int32 A, i, V;\n       i= AT-1;\n       A= AITEM(1);\n       V= AITEM(2);\n       for ( ; i>=0; i-- )\n               MB(A+i)= (byte)V;\n       ADELn(3);\n}", "path": "dssp\\kern.c", "repo_name": "telnov1971/DSSP-32", "stars": 0, "license": "None", "language": "c", "size": 340}
{"docstring": "/*********************************************************/\n/******        LOGICAL  and BIT OPERATIONS         *******/\n/*********************************************************/\n", "func_signal": "void _Lt (void)", "code": "{ // <\n       int32 tmp= ATPOP;\n       AT = (AT<tmp);\n}", "path": "dssp\\kern.c", "repo_name": "telnov1971/DSSP-32", "stars": 0, "license": "None", "language": "c", "size": 340}
{"docstring": "// Interpretation\n", "func_signal": "int32 ExecDpfCode (lptr StartPC)", "code": "{\n// execute threaded code, pointed by StartPC\n// this code must be finished by HALT operation\n// opsp points to operand stack\n// csp  points to control stack\n       int32 RetVal ; // returns Completion Code (StopFlag)\n       // local vars  for saving DSSP registers :\n       lptr    Saved_pc ;\n       lptr    Saved_cmd;\n       bool    Saved_StopFlag, Saved_IntrptFlag ;\n       // What else must be saved ?\n\n       // let's save some DSSP registers :\n       Saved_pc = pc;\n       Saved_cmd = cmd;\n       Saved_StopFlag = StopFlag;\n       Saved_IntrptFlag= IntrptFlag;\n\n       pc = StartPC;\n       StopFlag   = FALSE ;\n       IntrptFlag = FALSE ;\n       // main interpretation loop with interruption :\n       while (StopFlag==FALSE) {\n               INTLOOP;\n               // invoke interrupt handler, if it have occured\n          _Interrupt ();\n       }// while\n       RetVal = StopFlag;\n\n       // restore DSSP registers, which has been saved :\n       pc = Saved_pc;\n       cmd= Saved_cmd;\n       StopFlag= Saved_StopFlag;\n       IntrptFlag = Saved_IntrptFlag;\n\n       return (RetVal);\n}", "path": "dssp\\kern.c", "repo_name": "telnov1971/DSSP-32", "stars": 0, "license": "None", "language": "c", "size": 340}
{"docstring": "//    Console operations\n", "func_signal": "void InitConsole(void)", "code": "{ // Initiation of Console\n }\n\n\nvoid _WUp(void)\n{\n   ADEL;\n   ADEL;ADEL;ADEL;ADEL;\n   ADEL;\n}", "path": "dssp\\io_sun.c", "repo_name": "telnov1971/DSSP-32", "stars": 0, "license": "None", "language": "c", "size": 340}
{"docstring": "// write phisical memory  [l,a] !TAB [] \n", "func_signal": "void TAB(void)", "code": "{ int8 *ptr;\n   int8 l;\n   ptr=(int8*)ATPOP;\n   l=(int8)ATPOP;\n   *ptr=(int8)l;\n}", "path": "dssp\\mem.c", "repo_name": "telnov1971/DSSP-32", "stars": 0, "license": "None", "language": "c", "size": 340}
{"docstring": "//var \n", "func_signal": "void end_mem()", "code": "{     st_op[++opsp]=end_memv; } \nvoid end_memset() {     end_memv=st_op[opsp--]; } \nvoid beg_d1()     {     st_op[++opsp]=beg_d1v;  } \nvoid beg_d1set()  {     beg_d1v=st_op[opsp--];  } \nvoid beg_ptm()    {     st_op[++opsp]=beg_ptmv; } \nvoid beg_ptmset() {     beg_ptmv=st_op[opsp--]; } \nvoid end_ptm()    {     st_op[++opsp]=end_ptmv; } \nvoid end_ptmset() {     end_ptmv=st_op[opsp--]; } \nvoid csb()                {     st_op[++opsp]=csbv;             } \nvoid csbset()     {     csbv=st_op[opsp--];             } \nvoid opsb()               {     st_op[++opsp]=opsbv;    } \nvoid opsbset()    {     opsbv=st_op[opsp--];    } \nvoid end_wd1()    {     st_op[++opsp]=end_wd1v; } \nvoid end_wd1set() {     end_wd1v=st_op[opsp--]; } \nvoid beg_wd1()    {     st_op[++opsp]=beg_wd1v; } \nvoid beg_wd1set() {     beg_wd1v=st_op[opsp--]; } \nvoid end_yd1()    {     st_op[++opsp]=end_yd1v; } \nvoid end_yd1set() {     end_yd1v=st_op[opsp--]; } \nvoid beg_yd1()    {     st_op[++opsp]=beg_yd1v; } \nvoid beg_yd1set() {     beg_yd1v=st_op[opsp--]; } \nvoid platform()         {   st_op[++opsp]=platformv;}\nvoid platformset()      {   platformv=st_op[opsp--];}\nvoid nomver()    {      st_op[++opsp]=nomverv;  } \nvoid nomverset() {      nomverv=st_op[opsp--];  } \nvoid nomred()    {      st_op[++opsp]=nomredv;  } \nvoid nomredset() {      nomredv=st_op[opsp--];  } \n \nvoid __tosout()  {      st_op[++opsp]=__tosoutv;} \nvoid prtlen()    {      st_op[++opsp]=prtlenv;  } \nvoid __intrproc() {     st_op[++opsp]=__intrprocv; } \nvoid __tz()              {      st_op[++opsp]=__tzv;    } \nvoid __raise()   {      st_op[++opsp]=__raisev; } \nvoid undefcode() {      st_op[++opsp]=undefcodev;  } \nvoid intcode()   {      st_op[++opsp]=intcodev; } \nvoid varcode()   {      st_op[++opsp]=varcodev; } \nvoid cnstcode()  {      st_op[++opsp]=cnstcodev;} \nvoid txtcode()   {      st_op[++opsp]=txtcodev; } \nvoid ptxtcode()  {      st_op[++opsp]=ptxtcodev;} \nvoid intlen()    {      st_op[++opsp]=intlenv;  } \nvoid varlen()    {      st_op[++opsp]=varlenv;  } \nvoid cnstlen()   {      st_op[++opsp]=cnstlenv; } \nvoid __lvarp()   {      st_op[++opsp]=__lvarpv; } \nvoid __wvarp()   {      st_op[++opsp]=__wvarpv; } \nvoid __bvarp()   {      st_op[++opsp]=__bvarpv; } \nvoid __avarp()   {      st_op[++opsp]=__avarpv; } \nvoid __ivarp()   {      st_op[++opsp]=__ivarpv; } \nvoid __svarp()   {      st_op[++opsp]=__svarpv; } \nvoid __lvctp()   {      st_op[++opsp]=__lvctpv; } \nvoid __wvctp()   {      st_op[++opsp]=__wvctpv; } \nvoid __bvctp()   {      st_op[++opsp]=__bvctpv; } \nvoid __avctp()   {      st_op[++opsp]=__avctpv; } \nvoid __vctrp()   {      st_op[++opsp]=__vctrpv; } \nvoid __getadr()  {      st_op[++opsp]=__getadrv;} \nvoid __getadr_own() {   st_op[++opsp]=__getadr_ownv; } \nvoid __basep()   {      st_op[++opsp]=__basepv; } \nvoid __nb()              {      st_op[++opsp]=__nbv;    } \nvoid __d1()              {      st_op[++opsp]=__d1v;    } \nvoid __yd1()     {      st_op[++opsp]=__yd1v;   } \nvoid __wd1()     {      st_op[++opsp]=__wd1v;   } \nvoid __v1()              {      st_op[++opsp]=__v1v;    } \nvoid __nv1()     {      st_op[++opsp]=__nv1v;   } \n \nvoid __tosoutset()  {   __tosoutv=st_op[opsp--];        } \nvoid prtlenset()    {   prtlenv=st_op[opsp--];          } \nvoid __intrprocset() {  __intrprocv=st_op[opsp--];      } \nvoid __tzset()      {   __tzv=st_op[opsp--];            } \nvoid __raiseset()   {   __raisev=st_op[opsp--];         } \nvoid undefcodeset() {   undefcodev=st_op[opsp--];       } \nvoid intcodeset()   {   intcodev=st_op[opsp--];         } \nvoid varcodeset()   {   varcodev=st_op[opsp--];         } \nvoid cnstcodeset()  {   cnstcodev=st_op[opsp--];        } \nvoid txtcodeset()   {   txtcodev=st_op[opsp--];         } \nvoid ptxtcodeset()  {   ptxtcodev=st_op[opsp--];        } \nvoid intlenset()    {   intlenv=st_op[opsp--];          } \nvoid varlenset()    {   varlenv=st_op[opsp--];          } \nvoid cnstlenset()   {   cnstlenv=st_op[opsp--];         } \nvoid __lvarpset()   {   __lvarpv=st_op[opsp--];         } \nvoid __wvarpset()   {   __wvarpv=st_op[opsp--];         } \nvoid __bvarpset()   {   __bvarpv=st_op[opsp--];         } \nvoid __avarpset()   {   __avarpv=st_op[opsp--];         } \nvoid __ivarpset()   {   __ivarpv=st_op[opsp--];         } \nvoid __svarpset()   {   __svarpv=st_op[opsp--];         } \nvoid __lvctpset()   {   __lvctpv=st_op[opsp--];         } \nvoid __wvctpset()   {   __wvctpv=st_op[opsp--];         } \nvoid __bvctpset()   {   __bvctpv=st_op[opsp--];         } \nvoid __avctpset()   {   __avctpv=st_op[opsp--];         } \nvoid __vctrpset()   {   __vctrpv=st_op[opsp--];         } \nvoid __getadrset()  {   __getadrv=st_op[opsp--];        } \nvoid __getadr_ownset() { __getadr_ownv=st_op[opsp--];} \nvoid __basepset()   {   __basepv=st_op[opsp--];         } \nvoid __nbset()          {       __nbv=st_op[opsp--];            } \nvoid __d1set()          {       __d1v=st_op[opsp--];            } \nvoid __yd1set()         {       __yd1v=st_op[opsp--];           } \nvoid __wd1set()         {       __wd1v=st_op[opsp--];           } \nvoid __v1set()          {       __v1v=st_op[opsp--];            } \nvoid __nv1set()         {       __nv1v=st_op[opsp--];           } \nvoid __pusk()           {       st_op[++opsp]=__puskv;          } \nvoid __puskset()        {       __puskv=st_op[opsp--];          } \n \n \nvoid cfind(long c) \n{ \n        long *v1c,lw; \n \n        v1c=(long*)v1; \n        for (;;) \n        { \n                lw=*v1c; \n                if (!lw) {ba=0;az=(unsigned char*)v1c;break;} \n                lw=*(long*)(memory+lw+cnstlenv); \n                if (c==lw) {ba=*v1c;az=(unsigned char*)v1c;break;} \n                v1c++; \n        } \n}", "path": "gen\\ngold.c", "repo_name": "telnov1971/DSSP-32", "stars": 0, "license": "None", "language": "c", "size": 340}
{"docstring": "//-------------- \\G11 ----------------------\n//\n// This operation is necessary for Dssp-debugger\n//      It pops from A-stack new CSP, then\n//      gets new PC from new C-stack\n//      and then pops from A-stack new command for execution\n", "func_signal": "void _G11(void)", "code": "{    APOP(csp);\n     CPOP(pc);\n     EXECMD_(ATPOP);\n}", "path": "dssp\\debug.c", "repo_name": "telnov1971/DSSP-32", "stars": 0, "license": "None", "language": "c", "size": 340}
{"docstring": "/*********************************************************/\n/*****       INTERPRETATION  OF DSSP-PROGRAM         *****/\n/*********************************************************/\n", "func_signal": "void _Restart (void)", "code": "{ // RESTART\n       opsp= opsb;\n       csp= csb;\n       InitMS(); // init mechanism  of situations\n       pc = (lptr)DATADR(START_PC);\n\n       APUSH(1);       // AT:=1 , if Not first Start\n}", "path": "dssp\\kern.c", "repo_name": "telnov1971/DSSP-32", "stars": 0, "license": "None", "language": "c", "size": 340}
{"docstring": "//var \n", "func_signal": "void end_mem()", "code": "{\tst_op[++opsp]=end_memv; } \nvoid end_memset() {\tend_memv=st_op[opsp--]; } \nvoid beg_d1()\t  {\tst_op[++opsp]=beg_d1v;\t} \nvoid beg_d1set()  {\tbeg_d1v=st_op[opsp--];\t} \nvoid beg_ptm()\t  {\tst_op[++opsp]=beg_ptmv; } \nvoid beg_ptmset() {\tbeg_ptmv=st_op[opsp--]; } \nvoid end_ptm()\t  {\tst_op[++opsp]=end_ptmv; } \nvoid end_ptmset() {\tend_ptmv=st_op[opsp--]; } \nvoid csb()\t\t  {\tst_op[++opsp]=csbv;\t\t} \nvoid csbset()\t  {\tcsbv=st_op[opsp--];\t\t} \nvoid opsb()\t\t  {\tst_op[++opsp]=opsbv;\t} \nvoid opsbset()\t  {\topsbv=st_op[opsp--];\t} \nvoid end_wd1()\t  {\tst_op[++opsp]=end_wd1v; } \nvoid end_wd1set() {\tend_wd1v=st_op[opsp--]; } \nvoid beg_wd1()\t  {\tst_op[++opsp]=beg_wd1v; } \nvoid beg_wd1set() {\tbeg_wd1v=st_op[opsp--]; } \nvoid end_yd1()\t  {\tst_op[++opsp]=end_yd1v; } \nvoid end_yd1set() {\tend_yd1v=st_op[opsp--]; } \nvoid beg_yd1()\t  {\tst_op[++opsp]=beg_yd1v; } \nvoid beg_yd1set() {\tbeg_yd1v=st_op[opsp--]; } \nvoid nomver()\t {\tst_op[++opsp]=nomverv;\t} \nvoid nomverset() {\tnomverv=st_op[opsp--];\t} \nvoid nomred()\t { \tst_op[++opsp]=nomredv;\t} \nvoid nomredset() { \tnomredv=st_op[opsp--];\t} \n \nvoid __tosout()\t {\tst_op[++opsp]=__tosoutv;} \nvoid prtlen()\t {\tst_op[++opsp]=prtlenv;\t} \nvoid __intrproc() {\tst_op[++opsp]=__intrprocv; } \nvoid __tz()\t\t {\tst_op[++opsp]=__tzv;\t} \nvoid __raise()\t {\tst_op[++opsp]=__raisev; } \nvoid undefcode() {\tst_op[++opsp]=undefcodev;  } \nvoid intcode()\t {\tst_op[++opsp]=intcodev; } \nvoid varcode()\t {\tst_op[++opsp]=varcodev; } \nvoid cnstcode()  {\tst_op[++opsp]=cnstcodev;} \nvoid txtcode()\t {\tst_op[++opsp]=txtcodev; } \nvoid ptxtcode()  {\tst_op[++opsp]=ptxtcodev;} \nvoid intlen()\t {\tst_op[++opsp]=intlenv;\t} \nvoid varlen()\t {\tst_op[++opsp]=varlenv;\t} \nvoid cnstlen()\t {\tst_op[++opsp]=cnstlenv; } \nvoid __lvarp()\t {\tst_op[++opsp]=__lvarpv; } \nvoid __wvarp()\t {\tst_op[++opsp]=__wvarpv; } \nvoid __bvarp()\t {\tst_op[++opsp]=__bvarpv; } \nvoid __avarp()\t {\tst_op[++opsp]=__avarpv; } \nvoid __ivarp()\t {\tst_op[++opsp]=__ivarpv; } \nvoid __svarp()\t {\tst_op[++opsp]=__svarpv; } \nvoid __lvctp()\t {\tst_op[++opsp]=__lvctpv; } \nvoid __wvctp()\t {\tst_op[++opsp]=__wvctpv; } \nvoid __bvctp()\t {\tst_op[++opsp]=__bvctpv; } \nvoid __avctp()\t {\tst_op[++opsp]=__avctpv; } \nvoid __getadr()  {\tst_op[++opsp]=__getadrv;} \nvoid __getadr_own() {\tst_op[++opsp]=__getadr_ownv; } \nvoid __basep()\t {\tst_op[++opsp]=__basepv; } \nvoid __nb()\t\t {\tst_op[++opsp]=__nbv;\t} \nvoid __d1()\t\t {\tst_op[++opsp]=__d1v;\t} \nvoid __yd1()\t {\tst_op[++opsp]=__yd1v;\t} \nvoid __wd1()\t {\tst_op[++opsp]=__wd1v;\t} \nvoid __v1()\t\t {\tst_op[++opsp]=__v1v;\t} \nvoid __nv1()\t {\tst_op[++opsp]=__nv1v;\t} \n \nvoid __tosoutset()  {\t__tosoutv=st_op[opsp--];\t} \nvoid prtlenset()    {\tprtlenv=st_op[opsp--];\t\t} \nvoid __intrprocset() {\t__intrprocv=st_op[opsp--];\t} \nvoid __tzset()      {\t__tzv=st_op[opsp--];\t\t} \nvoid __raiseset()   {\t__raisev=st_op[opsp--];\t\t} \nvoid undefcodeset() {\tundefcodev=st_op[opsp--];\t} \nvoid intcodeset()   {\tintcodev=st_op[opsp--];\t\t} \nvoid varcodeset()   {\tvarcodev=st_op[opsp--];\t\t} \nvoid cnstcodeset()  { \tcnstcodev=st_op[opsp--];\t} \nvoid txtcodeset()   {\ttxtcodev=st_op[opsp--];\t\t} \nvoid ptxtcodeset()  {\tptxtcodev=st_op[opsp--];\t} \nvoid intlenset()    {\tintlenv=st_op[opsp--];\t\t} \nvoid varlenset()    {\tvarlenv=st_op[opsp--];\t\t} \nvoid cnstlenset()   { \tcnstlenv=st_op[opsp--];\t\t} \nvoid __lvarpset()   {\t__lvarpv=st_op[opsp--];\t\t} \nvoid __wvarpset()   {\t__wvarpv=st_op[opsp--];\t\t} \nvoid __bvarpset()   {\t__bvarpv=st_op[opsp--];\t\t} \nvoid __avarpset()   {\t__avarpv=st_op[opsp--];\t\t} \nvoid __ivarpset()   {\t__ivarpv=st_op[opsp--];\t\t} \nvoid __svarpset()   {\t__svarpv=st_op[opsp--];\t\t} \nvoid __lvctpset()   {\t__lvctpv=st_op[opsp--];\t\t} \nvoid __wvctpset()   {\t__wvctpv=st_op[opsp--];\t\t} \nvoid __bvctpset()   {\t__bvctpv=st_op[opsp--];\t\t} \nvoid __avctpset()   {\t__avctpv=st_op[opsp--];\t\t} \nvoid __getadrset()  { \t__getadrv=st_op[opsp--];\t} \nvoid __getadr_ownset() { __getadr_ownv=st_op[opsp--];} \nvoid __basepset()   {\t__basepv=st_op[opsp--];\t\t} \nvoid __nbset()\t\t{ \t__nbv=st_op[opsp--];\t\t} \nvoid __d1set()\t\t{\t__d1v=st_op[opsp--];\t\t} \nvoid __yd1set()\t\t{ \t__yd1v=st_op[opsp--];\t\t} \nvoid __wd1set()\t\t{ \t__wd1v=st_op[opsp--];\t\t} \nvoid __v1set()\t\t{\t__v1v=st_op[opsp--];\t\t} \nvoid __nv1set()\t\t{\t__nv1v=st_op[opsp--];\t\t} \nvoid __pusk()\t\t{\tst_op[++opsp]=__puskv;\t\t} \nvoid __puskset()\t{\t__puskv=st_op[opsp--];\t\t} \n \n \nvoid cfind(long c) \n{ \n\tlong *v1c,lw; \n \n\tv1c=(long*)v1; \n\tfor (;;) \n\t{ \n\t\tlw=*v1c; \n\t\tif (!lw) {ba=0;az=(unsigned char*)v1c;break;} \n\t\tlw=*(long*)(memory+lw+cnstlenv); \n\t\tif (c==lw) {ba=*v1c;az=(unsigned char*)v1c;break;} \n\t\tv1c++; \n\t} \n}", "path": "gen\\sun\\ng.c", "repo_name": "telnov1971/DSSP-32", "stars": 0, "license": "None", "language": "c", "size": 340}
{"docstring": "/*********** TESTS for ExecDpfCode **************/\n", "func_signal": "void _ExecDSSP (void)", "code": "{ // Exec DSSP inside DSSP !!!\n        int32 CCode;\n        APUSH(1);\n        CCode = ExecDpfCode((lptr)START_PC);\n        APUSH(CCode);\n}", "path": "dssp\\kern.c", "repo_name": "telnov1971/DSSP-32", "stars": 0, "license": "None", "language": "c", "size": 340}
{"docstring": "// word = name proc \n", "func_signal": "void code_()", "code": "{ \n\tint nlen,nlen8; \n\tchar newword[50],*azpc; \n\tunsigned char *az_; \n\tlong *i,*ptr,lent,lw; \n\tint j; \n\tazp=*(long*)az; \n\taz_=az; \n\taz=nv; \n\tis0_4(); \n\tnlen=strlen(word); \n\tnlen8=(nlen+2+3)&(~3); \n\tstrcpy(newword,\"     \"); \n\tstrcpy(newword+(nlen8-nlen-2),word); \n\tnewword[nlen8-2]=nlen8/4-1; \n\tnewword[nlen8-1]=(0x40*(char)delhd); \n\tazpc=(char*)&azp; \n\tif ((*(azpc+3))&0x10) \n\t{ \n\t\tprintf(\"\"); \n\t\tlw=*(char*)(az_+2); \n\t\tlw=(lw & 7)*4; \n\t\tlent=*(long*)(az_-lw-8); \n\t\t//reform table \n\t\tfor (j=0;j<(-lent/4)-1;j++) \n\t\t{ \n\t\t\t*(long*)(memory+*(long*)(az_-lw+lent+j*4-4))=(long)(nb-memory); \n\t\t} \n\t\t*(long*)(az_-lw-4)=(long)(nb-memory); \n\t\t*(char*)(az_+3)&=(~0x50); \n\t\t*(char*)(az_+3)|=(0x40*(char)delhd); \n//\t\t*(long*)az_=(*(long*)az_)&((~0x50000000)); \n//\t\t*(long*)az_=(*(long*)az_)|(0x40000000*(char)delhd); \n\t\t//remove table \n\t\tfor (ptr=(long*)(az_-lw-4);ptr<=(long*)nv;ptr++) \n\t\t\t*(ptr+lent/4)=*ptr; \n\t\tnv+=lent; \n\t} \n\telse \n\t{ \n\t\tfor (i=(long*)nv;i>=(long*)(az);i--) \n\t\t\t*(i+nlen8/4+1)=*i; \n\t\t*(long*)az=(long)(nb-memory); \n\t\tfor (j=0;j<nlen8/4;j++) \n\t\t\t*(long*)(az+j*4+4)=*(long*)(newword+j*4); \n\t\taz=az_; \n\t\tnv+=nlen8+4; \n\t} \n\tdelhd=1; \n}", "path": "gen\\sun\\ng.c", "repo_name": "telnov1971/DSSP-32", "stars": 0, "license": "None", "language": "c", "size": 340}
{"docstring": "//----------- GET and SET BITs in DSSP memory ---------------//\n", "func_signal": "void _ValBit (void)", "code": "{ // @BI\n       // Get bit number Top at address of SubTop\n       int32 maska;\n       int32 A,n;\n       n=ATPOP;\n       A=AT;\n//      printf(\"A=%lx \",(long)A);\n       A+=(int32)(n/8);\n       maska= 1<<(n-((int32)(n/8))*8);\n//      printf(\"A=%lx n=%lx maska=%lx @=%lx\\n\",(long)A,(long)n,(long)maska,(long)MB(A));\n       AT= (MB(A)&maska)!=0;\n}", "path": "dssp\\kern.c", "repo_name": "telnov1971/DSSP-32", "stars": 0, "license": "None", "language": "c", "size": 340}
{"docstring": "//----- SEARCH VALUE in DATA BLOCK in DSSP memory -----//\n", "func_signal": "void _SrchB (void)", "code": "{ // SRCHB\n       // [V, A, n ] SRCHB [i]\n       // search: find byte value B in byte block,\n       // from address A to A+n-1 (n>0) or\n       // from address A to A-n+1 (n<0)\n       // result (i) - offset from A or n, if not found\n       int32 n, i; bptr A; byte V;\n       n= ATPOP;\n       A= (bptr)ATPOP;\n       V= (byte) AT;\n       i=0;\n       if (n>0) {\n               while ( (i!=n)&&(MB(A+i)!=V) ) i++ ;\n       } else {\n               while ( (i!=n)&&(MB(A+i)!=V) ) i-- ;\n       }\n       AT= i;\n}", "path": "dssp\\kern.c", "repo_name": "telnov1971/DSSP-32", "stars": 0, "license": "None", "language": "c", "size": 340}
{"docstring": "//*******************************************************************\n//*** FORCECONTEXT - \u2569\u256c\u2560\u2514\u2550\u2500\u2514 \u252c\u2564\u2565\u2514\u252c\u2569\u255a \u252c\u2588\u255f\u256c\u252c\u2514 \u2567\u2568\u256c\u2553\u253c\u2500\u2559\u2568\u2588 \u0442 \u2569\u256c\u2550\u2565\u253c\u2569\u2564\u2565 **** \n//******************************************************************* \n// \u256c\u2534\u255f\u2514\u255f\u253c\u2553 \u0442\u221a\u0447\u044e\u0442\u0440: \n//          [ PROC, CA ] FORCECONTEXT [ ]\n// \u0443\u0444\u0445 :\n//  PROC - \u0440\u0444\u0401\u0445\u0451 \u0404\u0445\u044b\u0440 \u044f\u0401\u044e\u040e\u0445\u0444\u0454\u0401\u221a, \u044a\u044e\u0404\u044e\u0401\u0454\u25a0 \u044d\u0440\u0444\u044e \u0447\u0440\u0451\u0404\u0440\u0442\u0448\u0404\u2116 \u0442\u221a\u0447\u0442\u0440\u0404\u2116 \n//   ( \u00a4\u0404\u044e \u0404\u0445\u044b\u044e \u0444\u044e\u044b\u0446\u044d\u044e \u0441\u221a\u0404\u2116 \u0448\u044d\u0404\u0445\u0401\u044f\u0401\u0445\u0404\u0448\u0401\u0454\u0445\u044c\u221a\u044c, \u0404.\u0445. \u0442 \u044f\u0401\u044e\u040e.\u044a\u044e\u0444\u0445 )         \n//  CA - \u0440\u0444\u0401\u0445\u0451 \u0441\u044b\u044e\u044a\u0440-\u044a\u044e\u044d\u0404\u0445\u044a\u0451\u0404\u0440, \u0442 \u044a\u044e\u0404\u044e\u0401\u044e\u044c \u044d\u0440\u0444\u044e \u044e\u0441\u0445\u0451\u044f\u0445\u045e\u0448\u0404\u2116 \u00a4\u0404\u044e\u0404 \u0442\u221a\u0447\u044e\u0442 \n//\n", "func_signal": "void _ForceContext (void)", "code": "{     // FORCECONTEXT\n\tlptr\tcmdProc;\n\tpCNTXT pCA;\t// pointer to forced context-block\n\tAPOP(pCA); pCA= (pCNTXT)ADR_ML(pCA); \n\tAPOP(cmdProc);\n\tcmdProc++;  // address of the begining of threaded code body \n\t// push it in control stack of forced context :\n\tML(--pCA->_csp)= (int32)cmdProc;\n}", "path": "dssp\\contexts.c", "repo_name": "telnov1971/DSSP-32", "stars": 0, "license": "None", "language": "c", "size": 340}
{"docstring": "//----------- SET VALUEs in DSSP memory ---------------//\n", "func_signal": "void _TL (void)", "code": "{ // !TL\n       // Put SubTop as long value in location at address of Top\n       ML(AT)=AITEM(1);\n       ADELn(2);\n}", "path": "dssp\\kern.c", "repo_name": "telnov1971/DSSP-32", "stars": 0, "license": "None", "language": "c", "size": 340}
{"docstring": "// finish current-level interpretation ( END DSSP-procedure )\n", "func_signal": "void _K  (void)", "code": "{     CPOP(pc); }\n\nvoid _Call (void)\n{    // CALLTELO\n     // cmd->  CALLTELO\n     //    +1     ADR  // address of DSSP-procedure\n     //    +2    ... // address of this position\n     //              // will be in C-STACK\n     CPUSH(cmd+2);\n     cmd = (lptr)ML(cmd+1);\n     EXECMD;\n}", "path": "dssp\\kern.c", "repo_name": "telnov1971/DSSP-32", "stars": 0, "license": "None", "language": "c", "size": 340}
{"docstring": "/* Delete subtop from A-stack with Testing */\n", "func_signal": "void _E2D (void)", "code": "{ // E2D\n       if (ADEEP>=(2)) {\n               AITEM(1)=AT; ADEL;\n       } else {/*Error*/}\n}", "path": "dssp\\kern.c", "repo_name": "telnov1971/DSSP-32", "stars": 0, "license": "None", "language": "c", "size": 340}
{"docstring": "/*********************************************************/\n/***     KERNEL for DSSP INTERPRETER  III VARIANT      ***/\n/***  -----------------------------------------------  ***/\n/***           Phisical Memory OPERATIONS              ***/\n/***  -----------------------------------------------  ***/\n/*** written by Frantov D.,           22 dec   1998    ***/\n/***    Dmitry Frantov modification   22 dec   1998    ***/\n/***                                                   ***/\n/*********************************************************/\n", "func_signal": "void mallocD(void)", "code": "{\n  int32 len;\n  len=(int32)AT;\n  AT=(int32)malloc(len);\n}", "path": "dssp\\mem.c", "repo_name": "telnov1971/DSSP-32", "stars": 0, "license": "None", "language": "c", "size": 340}
{"docstring": "/*\n * Get the next token from the currently being parsed file. Handles\n * getting new lines.\n */\n", "func_signal": "static char *\nget_token(pconf_context *pcontext)", "code": "{\n    static char buffer[BUFSIZE];\n    char *token = NULL;\n    int in_comment = FALSE;\n\n    if (pcontext->buffer_read) {\n\ttoken = strtok(NULL, pcontext->delim);\n\n\tif (token && (*token == '#'))\n\t    in_comment = TRUE;\n    }\n\n    while ((token == NULL) || in_comment) {\n\t/*\n\t * If we're in a comment then just read the rest of the\n\t * line, if we haven't read the whole this, and discard it\n\t */\n\tif (in_comment && (pcontext->whole_line == FALSE)) {\n\t    while(1) {\n\t\tif (fgets(buffer, BUFSIZE, pcontext->file) == NULL)\n\t\t    return NULL;\n\n\t\tif (buffer[strlen(buffer) - 1] == '\\n')\n\t\t    break;\n\t    }\n\t}\n\n\tin_comment = FALSE;\n\n\t/* Read our next line to parse */\n\tif (fgets(buffer, BUFSIZE, pcontext->file) == NULL)\n\t    return NULL;\n\n\tpcontext->buffer_read = TRUE;\n\n\t/* Did we get a CR? */\n\tif (buffer[strlen(buffer) - 1] == '\\n') {\n\t    (pcontext->linenum)++;\n\t    pcontext->whole_line = TRUE;\n\t} else {\n\t    pcontext->whole_line = FALSE;\n\t}\n\n\ttoken = strtok(buffer, pcontext->delim);\n\n\tif (token && (*token == '#'))\n\t    in_comment = TRUE;\n    }\n\n    return token;\n}", "path": "parse_conf.c", "repo_name": "von/krb525", "stars": 1, "license": "None", "language": "c", "size": 176}
{"docstring": "/*\n * Read an entry and allocate a structure to hold it. Returns null if\n * there wasn't an entry to read (we're at EOL or EOF).\n *\n * terminator is set to point at the string that terminated the list\n * (will be NULL if it was terminated by EOF).\n *\n * Sets error if an error is encountered.\n */\n", "func_signal": "static pconf_entry *\nparse_entry(pconf_context *pcontext,\n\t    char **terminator,\n\t    int *error)", "code": "{\n    pconf_entry\t*entry;\n    char *string;\n\n\n    entry = new_pconf_entry();\n\n    if (entry == NULL)\n\tgoto error_return;\n\n    /* Read Lvalues */\n    entry->strings = read_list(pcontext, &string, error, IS_LVALUE);\n\n    if (*error)\n\tgoto error_return;\n\n    if (string == NULL)\t/* EOF */\n\tgoto done;\n\n    if (strcmp(string, \";\") == 0)\n\tgoto done;\n\n    if (strcmp(string, \"}\") == 0)\n\tgoto done;\t/* Must be an empty list */\n\n    /* Must have hit at \"=\" */\n    entry->values = read_list(pcontext, &string, error, !IS_LVALUE);\n\n    if (*error)\n\tgoto error_return;\n\n    /* Is it the start of another entry list? */\n    if (strcmp(string, \"{\") == 0) {\n\tentry->type = CONF_TYPE_LIST;\n\tentry->list = parse_list(pcontext, EXPECT_EOL, error);\n\tif (*error)\n\t    goto error_return;\n    } else {\n\tentry->type = CONF_TYPE_VALUE;\n    }\n\t\n   \ndone:\n    *terminator = string;\n    *error = FALSE;\n\n    /*\n     * Check and see if we actually read anything, and if not return null.\n     */\n    if (entry->strings == NULL) {\n\tfree(entry);\n\tentry = NULL;\n    }\n    return entry;\n    \nerror_return:\n    if (entry)\n\tfree_pconf_enteries(entry);\n    *error = TRUE;\n    return NULL;\n}", "path": "parse_conf.c", "repo_name": "von/krb525", "stars": 1, "license": "None", "language": "c", "size": 176}
{"docstring": "/*\n * Given a configuration filename, parse the file returning a linked\n * list of conf_entrys. Returns NULL on error and sets pconf_error.\n */\n", "func_signal": "pconf_entry *\nparse_conf(char *filename, char *delim)", "code": "{\n    pconf_context pcontext;\n    char *string;\n    pconf_entry *entry;\n    int error;\n\n    pcontext.file = fopen(filename, \"r\");\n\n    if (pcontext.file == NULL) {\n\tsprintf(pconf_error, \"Couldn't open file %s: %s\",\n\t\tfilename, strerror(errno));\n\treturn NULL;\n    }\n\n    pcontext.linenum = 0;\n    pcontext.filename = filename;\n    pcontext.delim = (delim ? delim : DEFAULT_DELIM);\n    pcontext.buffer_read = FALSE;\n    pcontext.whole_line = FALSE;\n\n    entry = parse_list(&pcontext, DONT_EXPECT_EOL, &error);\n\n    return entry;\n}", "path": "parse_conf.c", "repo_name": "von/krb525", "stars": 1, "license": "None", "language": "c", "size": 176}
{"docstring": "/*\n * Find string in list of regexs and return entry\n */\n", "func_signal": "static pconf_entry *\nfind_string_in_regex_list(pconf_entry *entry,\n\t\t\t  char *string)", "code": "{\n    while(entry) {\n\tchar **str = entry->strings;\n\n\twhile(*str) {\n\t    if (regex_compare(*str, string))\n\t\treturn entry;\n\n\t    str++;\n\t}\n\n\tentry = entry->next;\n    }\n\n    return NULL;\n}", "path": "srv_conf.c", "repo_name": "von/krb525", "stars": 1, "license": "None", "language": "c", "size": 176}
{"docstring": "/*\n * Close database\n */\n", "func_signal": "void\nk5_db_close(krb5_context context)", "code": "{\n    (void) krb5_dbm_db_fini(context);\n    (void) kadm5_destroy(handle);\n}", "path": "k5_db.c", "repo_name": "von/krb525", "stars": 1, "license": "None", "language": "c", "size": 176}
{"docstring": "/*\n * Given a linked list of pconf_enteries, free them all.\n */\n", "func_signal": "void\nfree_pconf_enteries(pconf_entry *entry)", "code": "{\n    while(entry) {\n\tpconf_entry *next = entry->next;\n\n\tif (entry->strings) {\n\t    char **string = entry->strings;\n\n\t    while(*string) {\n\t\tfree(*string);\n\t\tstring++;\n\t    }\n\t    \n\t    free(entry->strings);\n\t}\n\n\tif (entry->values) {\n\t    char **string = entry->values;\n\n\t    while(*string) {\n\t\tfree(*string);\n\t\tstring++;\n\t    }\n\t    \n\t    free(entry->values);\n\t}\n\n\n\tif (entry->list)\n\t    free_pconf_enteries(entry->list);\n\n\tfree(entry);\n\n\tentry = next;\n    }\n}", "path": "parse_conf.c", "repo_name": "von/krb525", "stars": 1, "license": "None", "language": "c", "size": 176}
{"docstring": "/*\n * Return the first string in an entry\n */\n", "func_signal": "static char *\nget_first_value(pconf_entry *entry)", "code": "{\n    if (!entry || !entry->values)\n\treturn NULL;\n\n    return *(entry->values);\n}", "path": "srv_conf.c", "repo_name": "von/krb525", "stars": 1, "license": "None", "language": "c", "size": 176}
{"docstring": "/*\n * Check the configuration file version number and see if it's\n * OK. Returns 0 if ok, -1 otherwise.\n */\n", "func_signal": "static int\ncheck_conf_version()", "code": "{\n    pconf_entry\t\t*entry;\n\n    char\t\t*conf_version_string;\n    int\t\t\tconf_version_major;\n    int\t\t\tconf_version_minor;\n    int\t\t\tconf_version_patchlevel;\n\n    int\t\t\tmy_version_major;\n    int\t\t\tmy_version_minor;\n    int\t\t\tmy_version_patchlevel;\n\n    int\t\t\tconf_newer = 0;\n\n\n    /* Check version string of configuration file */\n    entry = find_string_in_list(conf, \"version\");\n\n    conf_version_string = get_first_value(entry);\n\n    if (conf_version_string == NULL) {\n\tsprintf(srv_conf_error, \"No version number in configuration file\");\n\treturn -1;\n    }\n\n    /* Parse configuration file version */\n    if (sscanf(conf_version_string,\n\t       \"%d.%d.%d\",\n\t       &conf_version_major,\n\t       &conf_version_minor,\n\t       &conf_version_patchlevel) != 3) {\n\tsprintf(srv_conf_error,\n\t\t\"Error parsing configuration file version string\");\n\treturn -1;\n    }\n\n    /* Parse our version number */\n    if (sscanf(KRB525_VERSION_STRING,\n\t       \"%d.%d.%d\",\n\t       &my_version_major,\n\t       &my_version_minor,\n\t       &my_version_patchlevel) != 3) {\n\tsprintf(srv_conf_error,\n\t\t\"Error parsing my version string (shouldn't happen)\");\n\treturn -1;\n    }\n\n    /* Make sure file is not newer than me */\n    if (conf_version_major > my_version_major)\n\tconf_newer = 1;\n\n    if ((conf_version_major == my_version_major) &&\n\t(conf_version_minor > my_version_minor))\n\tconf_newer = 1;\n\n    /* Patchlevel should not make a difference */\n\n    if (conf_newer) {\n\tsprintf(srv_conf_error,\n\t\t\"Configuration file version number is newer than mine\");\n\treturn -1;\n    }\n\n    /* Checks for too old of a file could eventually go here */\n    return 0;\n}", "path": "srv_conf.c", "repo_name": "von/krb525", "stars": 1, "license": "None", "language": "c", "size": 176}
{"docstring": "/*\n * Check request against configuration. Returns 0 if good, -1 otherwise\n */\n", "func_signal": "int\ncheck_conf(krb525_request *request)", "code": "{\n    pconf_entry\t\t*entry;\n    pconf_entry\t\t*client_conf;\n    pconf_entry\t\t*list;\n    int\t\t\tretval = -1;\n\n\n    /*\n     * Check to be sure we're initialized\n     */\n    if (conf == NULL) {\n\tsprintf(srv_conf_error, \"Configuration not initialized\");\n\treturn -1;\n    }\n\n    /*\n     * RULE 1: Make sure requesting client is on allowed_clients list\n     */\n    entry = find_string_in_list(conf, \"allowed_clients\");\n\n    if (entry == NULL) {\n\tsprintf(srv_conf_error, \"No clients allowed!\");\n\tgoto done;\n    }\n\n    if (find_princ_in_regex_values(request->krb5_context,\n\t\t\t\t   request->client,\n\t\t\t\t   entry) == NULL) {\n\tsprintf(srv_conf_error, \"Client not allowed\");\n\tgoto done;\n    }\n\n    /*\n     * RULE 2: Make sure client isn't on disallowed_clients list, if\n     *         it exists.\n     */\n    entry = find_string_in_list(conf, \"disallowed_clients\");\n\n    if (entry) {\n\tif (find_princ_in_regex_values(request->krb5_context,\n\t\t\t\t       request->client,\n\t\t\t\t       entry) != NULL) {\n\t    sprintf(srv_conf_error, \"Client explicitily disallowed\");\n\t    goto done;\n\t}\n    }\n\n    /* See if requesting client has an individual list */\n    client_conf = find_princ_in_regex_list(request->krb5_context,\n\t\t\t\t\t   request->client,\n\t\t\t\t\t   conf);\n\n    if (client_conf != NULL) {\n\t/*\n\t * Requesting client has it's own entry of the form:\n\t *\n\t * client = {\n\t *   target_clients = <client1>, <client2>, <client3>, ... ;\n\t *   target_servers = <server1>, <server2>, <client4>, ... ;\n\t *   allowed_hosts = <host1>, <host2>, <host3>, ...;\n\t * }\n\t */\n\n\t/*\n\t * RULE 3: If the requesting client has a individual list, use that list\n\t *\t   in preference to the default lists for all further checks\n\t */\n\n\t/*\n         * RULE 3a: If the requesting client has it's own allowed_hosts\n         *          list make sure host is on the client's allowed_hosts\n         *          list otherwise make sure the client is on the default\n         *          allowed_hosts list.\n         */\n\tlist = find_string_in_list(client_conf->list, \"allowed_hosts\");\n\n\tif (list == NULL) {\n\t    /* Get default allowed_hosts list */\n\t    list = find_string_in_list(conf, \"allowed_hosts\");\n\t}\n\n\tif (list == NULL) {\n\t    sprintf(srv_conf_error, \"No hosts allowed for client\");\n\t    goto done;\n\t}\n    \n\tif (find_host_in_regex_values(list, &(request->addr)) == NULL) {\n\t    sprintf(srv_conf_error, \"Host not allowed\");\n\t    goto done;\n\t}\n\n    \t/*\n\t * Rule 3b: If the requesting client has it's own\n\t *          disallowed_hosts list make sure host is not on the\n\t *          client's disallowed_hosts list, otherwise make sure\n\t *          the host is not on the default disallowed_hosts list,\n\t *          if it exists.\n\t */\n\tentry = find_string_in_list(client_conf->list, \"disallowed_hosts\");\n\n\tif (entry == NULL) {\n\t    /* Get default disallowed_hosts list */\n\t    entry = find_string_in_list(conf, \"disallowed_hosts\");\n\t}\n\n\tif (entry) {\n\t    if (find_host_in_regex_values(entry, &(request->addr)) != NULL) {\n\t\tsprintf(srv_conf_error, \"Host explicitily disallowed\");\n\t\tgoto done;\n\t    }\n\t}\n\n\tif (!krb5_principal_compare(request->krb5_context,\n\t\t\t\t    request->client,\n\t\t\t\t    request->tkt_client)) {\n\t    /*\n\t     * Rule 3c: If the requesting client is different than the\n\t     *          ticket client, the ticket client must appear\n\t     *          in the source_clients list\n\t     */\n\t    entry = find_string_in_list(client_conf->list, \"source_clients\");\n\t    \n\t    if (entry == NULL) {\n\t\tsprintf(srv_conf_error, \"Client on ticket must match requestor\");\n\t\tgoto done;\n\t    }\n\n\t    if (find_princ_in_regex_values(request->krb5_context,\n\t\t\t\t\t   request->tkt_client,\n\t\t\t\t\t   entry) == NULL) {\n\t\tsprintf(srv_conf_error, \"Source client not allowed\");\n\t\tgoto done;\n\t    }\n\n\t    /*\n\t     * Rule 3d: If the requesting client is different than the\n\t     *          ticket client, the ticket client must not appear\n\t     *          on the disallowed_source_clients list, if it\n\t     *          exists.\n\t     */\n\t    entry = find_string_in_list(client_conf->list,\n\t\t\t\t\t\"disallowed_source_clients\");\n\n\t    if (entry) {\n\t\tif (find_princ_in_regex_values(request->krb5_context,\n\t\t\t\t\t       request->tkt_client,\n\t\t\t\t\t       entry) != NULL) {\n\t\t    sprintf(srv_conf_error,\n\t\t\t    \"Source client explicitly disallowed\");\n\t\t    goto done;\n\t\t}\n\t    }\n\t}\n\n\tif (!krb5_principal_compare(request->krb5_context,\n\t\t\t\t    request->tkt_client,\n\t\t\t\t    request->target_client)) {\n\n\t    /*\n\t     * Rule 3e: If client is changing, make sure the target client is\n\t     *          on the client's target_clients list\n\t     */\n   \n\t    entry = find_string_in_list(client_conf->list, \"target_clients\");\n\n\t    if (entry == NULL) {\n\t\tsprintf(srv_conf_error, \"No client changes allowed\");\n\t\tgoto done;\n\t    }\n\n\t    if (find_princ_in_regex_values(request->krb5_context,\n\t\t\t\t\t   request->target_client,\n\t\t\t\t\t   entry) == NULL) {\n\t\tsprintf(srv_conf_error, \"Target client not allowed\");\n\t\tgoto done;\n\t    }\n\n\t    /*\n\t     * Rule 3f: If client is changing, make sure the target client is\n\t     *          not on the client's disallowed_target_clients list,\n\t     *\t        if it exists.\n\t     */\n\t    entry = find_string_in_list(client_conf->list,\n\t\t\t\t\t\"disallowed_target_clients\");\n\n\t    if (entry) {\n\t\tif (find_princ_in_regex_values(request->krb5_context,\n\t\t\t\t\t       request->target_client,\n\t\t\t\t\t       entry) != NULL) {\n\t\t    sprintf(srv_conf_error,\n\t\t\t    \"Target client explicitily disallowed\");\n\t\t    goto done;\n\t\t}\n\t    }\n\t}\n\n\tif (!krb5_principal_compare(request->krb5_context,\n\t\t\t\t    request->tkt_server,\n\t\t\t\t    request->target_server)) {\n\n\t    /*\n\t     * Rule 3g: If the server is changing, make sure the target\n\t     *          server is on the client's target_servers list.\n\t     */\n\t    entry = find_string_in_list(client_conf->list, \"target_servers\");\n\n\t    if (entry == NULL) {\n\t\tsprintf(srv_conf_error, \"No server changes allowed\");\n\t\tgoto done;\n\t    }\n\n\t    if (find_princ_in_regex_values(request->krb5_context,\n\t\t\t\t\t   request->target_server,\n\t\t\t\t\t   entry) == NULL) {\n\t\tsprintf(srv_conf_error, \"Target server not allowed\");\n\t\tgoto done;\n\t    }\n\n\t    /*\n\t     * Rule 3h: If the server is changing, make sure the target\n\t     *          server is not on the client's\n\t     *          disallowed_target_servers list, if it exists.\n\t     */\n\t    entry = find_string_in_list(client_conf->list,\n\t\t\t\t\t\"disallowed_target_servers\");\n\n\t    if (entry) {\n\t\tif (find_princ_in_regex_values(request->krb5_context,\n\t\t\t\t\t       request->target_server,\n\t\t\t\t\t       entry) != NULL) {\n\t\t    sprintf(srv_conf_error,\n\t\t\t    \"Target service explicitily disallowed\");\n\t\t    goto done;\n\t\t}\n\t    }\n\t}\n\n\t/* Checks out OK */\n\n    } else {\n\n\t/*\n\t * Rule 4: If the client had no individual entry use the default\n\t *         lists.\n\t */\n\n\t/*\n\t * Rule 4a: Make sure the requesting client matches the client\n\t *          on the ticket.\n\t */\n\tif (!krb5_principal_compare(request->krb5_context,\n\t\t\t\t    request->client,\n\t\t\t\t    request->tkt_client)) {\n\t    sprintf(srv_conf_error,\n\t\t    \"Requesting client doesn't match client on ticket\");\n\t    goto done;\n\t}\n\n\t/*\n\t * Rule 4b: Make sure the host is on the default allowed_hosts list\n\t */\n\tlist = find_string_in_list(conf, \"allowed_hosts\");\n\n\tif (list == NULL) {\n\t    sprintf(srv_conf_error, \"No default hosts allowed\");\n\t    goto done;\n\t}\n    \n\tif (find_host_in_regex_values(list, &(request->addr)) == NULL) {\n\t    sprintf(srv_conf_error, \"Host not allowed in default list\");\n\t    goto done;\n\t}\n\n\t/*\n\t * Rule 4c: Make sure the host is not on the default disallowed_hosts\n\t *          list, if it exists.\n\t */\n\tentry = find_string_in_list(conf, \"disallowed_hosts\");\n\n\tif (entry) {\n\t    if (find_host_in_regex_values(entry, &(request->addr)) != NULL) {\n\t\tsprintf(srv_conf_error, \"Host explicitily disallowed\");\n\t\tgoto done;\n\t    }\n\t}\n\n\tif (!krb5_principal_compare(request->krb5_context,\n\t\t\t\t    request->tkt_client,\n\t\t\t\t    request->target_client)) {\n\n\t    /*\n\t     * Rule 4d: If the client is changing make sure the source\n\t     *          and target mapping appear in the client_mappings\n\t     *          list.\n\t     */\n\t    list = find_string_in_list(conf, \"client_mappings\");\n\n\t    if (list == NULL) {\n\t\tsprintf(srv_conf_error, \"No client mappings allowed\");\n\t\tgoto done;\n\t    }\n\n\t    entry = find_princ_in_regex_list(request->krb5_context, \n\t\t\t\t\t     request->tkt_client,\n\t\t\t\t\t     list->list);\n\n\t    if (entry == NULL) {\n\t\tsprintf(srv_conf_error, \"No mappings for client\");\n\t\tgoto done;\n\t    }\n\n\t    if (find_princ_in_regex_values(request->krb5_context,\n\t\t\t\t\t   request->target_client,\n\t\t\t\t\t   entry) == NULL) {\n\t\tsprintf(srv_conf_error, \"Target client not a legal mapping\");\n\t\tgoto done;\n\t    }\n\n\t    /*\n\t     * Rule 4e: If the client is changing make sure the target\n\t     *\t        client does not appear in the\n\t     *          disallowed_target_clients list, if it exists.\n\t     */\n\t    entry = find_string_in_list(conf,\n\t\t\t\t\t\"disallowed_target_clients\");\n\n\t    if (entry) {\n\t\tif (find_princ_in_regex_values(request->krb5_context,\n\t\t\t\t\t       request->target_client,\n\t\t\t\t\t       entry) != NULL) {\n\t\t    sprintf(srv_conf_error,\n\t\t\t    \"Target client explicitily disallowed\");\n\t\t    goto done;\n\t\t}\n\t    }\n\t}\n\n\tif (!krb5_principal_compare(request->krb5_context,\n\t\t\t\t    request->tkt_server,\n\t\t\t\t    request->target_server)) {\n\n\t    /*\n\t     * Rule 4f: If the server is changing, make sure the source\n\t     *          and target server mapping appear in the\n\t     *          server_mappings list.\n\t     */\n\t    list = find_string_in_list(conf, \"server_mappings\");\n\n\t    if (list == NULL) {\n\t\tsprintf(srv_conf_error, \"No server mappings allowed\");\n\t\tgoto done;\n\t    }\n\n\t    entry = find_princ_in_regex_list(request->krb5_context,\n\t\t\t\t\t     request->tkt_server,\n\t\t\t\t\t     list->list);\n\n\t    if (entry == NULL) {\n\t\tsprintf(srv_conf_error, \"No mappings for server\");\n\t\tgoto done;\n\t    }\n\n\t    if (find_princ_in_regex_values(request->krb5_context,\n\t\t\t\t\t   request->target_server,\n\t\t\t\t\t   entry) == NULL) {\n\t\tsprintf(srv_conf_error, \"Target server not a legal mapping\");\n\t\tgoto done;\n\t    }\n\n\t    /*\n\t     * Rule 4g: If the server is changing make sure the target\n\t     *          server does not appear in the\n\t     *          disallowed_target_servers list, if it exists.\n\t     */\n\t    entry = find_string_in_list(conf, \"disallowed_target_servers\");\n\n\t    if (entry) {\n\t\tif (find_princ_in_regex_values(request->krb5_context,\n\t\t\t\t\t       request->target_server,\n\t\t\t\t\t       entry) != NULL) {\n\t\t    sprintf(srv_conf_error, \"Target service explicitily disallowed\");\n\t\t    goto done;\n\t\t}\n\t    }\n\t}\n\n\t/* Checks out OK */\n    }\n\n    /*\n     * If we've gotten here, then we passed all the tests\n     */\n    retval = 0;\n\ndone:\n    return retval;\n}", "path": "srv_conf.c", "repo_name": "von/krb525", "stars": 1, "license": "None", "language": "c", "size": 176}
{"docstring": "/*\n * Seach through the list of values in entry (which are assumed to be\n * regexs). If string is found to match one, return a pointer to the one\n * it matches, otherwise return NULL.\n */\n", "func_signal": "static char *\nfind_string_in_regex_values(pconf_entry *entry,\n\t\t\t    char *string)", "code": "{\n    char\t\t**value = entry->values;\n\n\n    while(*value) {\n\tif (regex_compare(*value, string))\n\t    return *value;\n\n\tvalue++;\n    }\n    \n    return NULL;\n}", "path": "srv_conf.c", "repo_name": "von/krb525", "stars": 1, "license": "None", "language": "c", "size": 176}
{"docstring": "/*\n * Find a principal in a regex values list. First try the name as given,\n * then if it's in the default realm, try without the realm.\n */\n", "func_signal": "static char *\nfind_princ_in_regex_values(krb5_context kcontext,\n\t\t\t   krb5_principal princ,\n\t\t\t   pconf_entry *entry)", "code": "{\n    char\t\t**value = entry->values;\n\n    while (*value) {\n\tif (conf_string_matches_princ(kcontext, princ, *value))\n\t    return *value;\n\n\tvalue++;\n    }\n\n    return NULL;\n}", "path": "srv_conf.c", "repo_name": "von/krb525", "stars": 1, "license": "None", "language": "c", "size": 176}
{"docstring": "/*\n * Free any storage we had\n */\n", "func_signal": "void\nfree_conf()", "code": "{\n    free_pconf_enteries(conf);\n    conf = NULL;\n}", "path": "srv_conf.c", "repo_name": "von/krb525", "stars": 1, "license": "None", "language": "c", "size": 176}
{"docstring": "/*\n * Initialize our configuration. Return -1 on error, 0 otherwise.\n */\n", "func_signal": "int\ninit_conf(char *conf_file)", "code": "{\n\n    if ((conf = parse_conf(conf_file, NULL)) == NULL) {\n\tstrcpy(srv_conf_error, pconf_error);\n\tgoto error;\n    }\n\n    if (check_conf_version())\n\tgoto error;\n\n    return 0;\n\n error:\n    if (conf) {\n\tfree_pconf_enteries(conf);\n\tconf = NULL;\n    }\n\n    return -1;\n}", "path": "srv_conf.c", "repo_name": "von/krb525", "stars": 1, "license": "None", "language": "c", "size": 176}
{"docstring": "/*\n * Given a principal, retreive it's DB entry\n *\n * From kdc/do_as_req.c:process_as_req()\n */\n", "func_signal": "krb5_error_code\nk5_db_get_entry(krb5_context context,\n\t\tkrb5_principal princ,\n\t\tkrb5_db_entry *entry)", "code": "{\n    int\t\t\tnprincs = 1;\n    krb5_boolean\tmore;\n    krb5_error_code\tretval;\n\n    \n    if (retval = krb5_db_get_principal(context, princ, entry, &nprincs, &more)) {\n\tsprintf(k5_db_error, \"%s looking up principal\",\n\t\terror_message(retval));\n\treturn retval;\n    }\n\n    if (more) {\n\tsprintf(k5_db_error, \"Non-unique principal\");\n\treturn KRB5KDC_ERR_PRINCIPAL_NOT_UNIQUE;\n    }\n\n    if (nprincs != 1) {\n\tsprintf(k5_db_error, \"Principal not found\");\n\treturn KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n    }\n\n    return retval;\n}", "path": "k5_db.c", "repo_name": "von/krb525", "stars": 1, "license": "None", "language": "c", "size": 176}
{"docstring": "/*\n * Allocate and initialize and new pconf_entry structure.\n */\n", "func_signal": "static pconf_entry *\nnew_pconf_entry()", "code": "{\n    pconf_entry *entry;\n\n    entry = (pconf_entry *) malloc(sizeof(*entry));\n\n    if (entry == NULL) {\n\tsprintf(pconf_error, \"malloc() failed\");\n\treturn NULL;\n    }\n\n    entry->strings = NULL;\n    entry->type = CONF_TYPE_NONE;\n    entry->values = NULL;\n    entry->list = NULL;\n    entry->next = NULL;\n\n    return entry;\n}", "path": "parse_conf.c", "repo_name": "von/krb525", "stars": 1, "license": "None", "language": "c", "size": 176}
{"docstring": "/*\n * Given a principal and a key type, retreive the key\n */\n", "func_signal": "krb5_error_code\nk5_db_get_key(krb5_context context,\n\t      krb5_principal princ,\n\t      krb5_keyblock **key,\n\t      krb5_enctype ktype)", "code": "{\n    krb5_error_code\t\tretval;\n    kadm5_principal_ent_rec\tprinc_ent;\n\n\n    *key = (krb5_keyblock *) malloc(sizeof(krb5_keyblock));\n\n    if (*key == NULL) {\n\tsprintf(k5_db_error, \"malloc failed\");\n\treturn -1;\n    }\n\n    if (retval = kadm5_get_principal(handle, princ,\n\t\t\t\t      &princ_ent, KADM5_KEY_DATA)) {\n\tsprintf(k5_db_error, \"%s get principal information\",\n\t\terror_message(retval));\n\treturn retval;\n    }\n\n    if (retval = kadm5_decrypt_key(handle,\n\t\t\t\t   &princ_ent,\n\t\t\t\t   ktype,\n\t\t\t\t   -1,\n\t\t\t\t   -1,\n\t\t\t\t   *key,\n\t\t\t\t   NULL,\n\t\t\t\t   NULL))\n\tsprintf(k5_db_error, \"%s decrypting key\",\n\t\terror_message(retval));\n\n    kadm5_free_principal_ent(handle, &princ_ent);\n    return retval;\n}", "path": "k5_db.c", "repo_name": "von/krb525", "stars": 1, "license": "None", "language": "c", "size": 176}
{"docstring": "/*\n * Given a host address, look for it in the values list (which is assumed\n * to be made up of regexs) both by it dot address (e.g. 10.11.12.13) and\n * by full hostname.\n */\n", "func_signal": "static char *\nfind_host_in_regex_values(pconf_entry *entry,\n\t\t\t  struct sockaddr_in *sockaddr)", "code": "{\n    char\t\t**value = entry->values;\n    char\t\t*dot_addr;\n    char\t\t*hostname = NULL;\n    struct hostent\t*hinfo;\n\n\n    dot_addr = inet_ntoa(sockaddr->sin_addr);\n\n    hinfo = gethostbyaddr((char *) &(sockaddr->sin_addr.s_addr),\n\t\t\t  sizeof(sockaddr->sin_addr.s_addr),\n\t\t\t  sockaddr->sin_family);\n    \n    if (hinfo)\n\thostname = hinfo->h_name;\n\n    while (*value) {\n\tif (dot_addr && regex_compare(*value, dot_addr))\n\t    return *value;\n\n\tif (hostname && regex_compare(*value, hostname))\n\t    return *value;\n\n\tvalue++;\n    }\n\n    return NULL;\n}", "path": "srv_conf.c", "repo_name": "von/krb525", "stars": 1, "license": "None", "language": "c", "size": 176}
{"docstring": "/*\n * Initialize database\n */\n", "func_signal": "int\nk5_db_init(char * whoami,\n\t   krb5_context context,\n\t   kadm5_config_params *params)", "code": "{\n    int\t\t\t retval;\n\n    /*\n     * kadm5_init() is sufficient to get keys out of the database, but in\n     * order to get whole entries (with krb5_db_get_principal()) we also\n     * need to call krb5_dbm_db_init(). *shrug*\n     */\n\n    if ((retval = kadm5_init(whoami, NULL, KADM5_ADMIN_SERVICE, params,\n\t\t\t  KADM5_STRUCT_VERSION, KADM5_API_VERSION_2,\n\t\t\t  &handle))) {\n\tsprintf(k5_db_error, \"%s initializing kadm5 library\",\n\t\terror_message(retval));\n\treturn -1;\t\n    }\n\n    if (retval = krb5_dbm_db_init(context)) {\n\tsprintf(k5_db_error,\n\t\t\"%s initializing database routines (krb5_dbm_db_init())\",\n\t\terror_message(retval));\n\treturn -1;\n    }\n\n    return 0;\n}", "path": "k5_db.c", "repo_name": "von/krb525", "stars": 1, "license": "None", "language": "c", "size": 176}
{"docstring": "/*\n * Is the given principal matched by the given string from the conf file\n * 1 == yes, 0 == no or error\n */\n", "func_signal": "static int\nconf_string_matches_princ(krb5_context context,\n\t\t\t  krb5_principal princ,\n\t\t\t  char *conf_string)", "code": "{\n    krb5_error_code\t\tretval;\n    krb5_principal\t\tconf_princ;\n    int\t\t\t\tcomponent;\n    int\t\t\t\tresult = 0;\n\n\n    /* Parse the configuration string */\n    retval = krb5_parse_name(context, conf_string, &conf_princ);\n\n    if (retval) {\n\t/* No good way to get out an error */\n\treturn 0;\n    }\n\n    /* Do they match outright? If so shortcut out of here */\n    if (krb5_principal_compare(context, princ, conf_princ)) {\n\tresult = 1;\n\tgoto done;\n    }\n\n    /* A realm of '*' in the configuration file matches any realm */\n    if (strcmp(krb5_princ_realm(context, conf_princ)->data, \"*\") != 0) {\n\t/* Check and make sure realms match */\n\tif (!krb5_realm_compare(context, princ, conf_princ))\n\t    goto done;\n    }\n\n    /* Now make sure they have the same number of components */\n    if (krb5_princ_size(context, princ) != krb5_princ_size(context, conf_princ))\n\tgoto done;\n\n    /* Now check each component */\n    for (component = 0;\n\t component < krb5_princ_size(context, princ) ;\n\t component ++) {\n\t/*\n\t * A component of '*' in configuration file which matches any\n\t * anything in that component\n\t */\n\tif (strcmp(krb5_princ_component(context, conf_princ, component)->data,\n\t\t   \"*\") == 0)\n\t    continue;\n\n\t/*\n\t * otherwise make sure components match\n\t */\n\tif (strcmp(krb5_princ_component(context, conf_princ, component)->data,\n\t\t   krb5_princ_component(context, princ, component)->data) != 0)\n\t    goto done;\n    }\n\n    /* Match */\n    result = 1;\n\n done:\n    krb5_free_principal(context, conf_princ);\n\n    return result;\n}", "path": "srv_conf.c", "repo_name": "von/krb525", "stars": 1, "license": "None", "language": "c", "size": 176}
{"docstring": "/*\n * Find a principal in a regex list. First try the name as given,\n * then if it's in the default realm, try without the realm.\n */\n", "func_signal": "static pconf_entry *\nfind_princ_in_regex_list(krb5_context kcontext,\n\t\t\t krb5_principal princ,\n\t\t\t pconf_entry *entry)", "code": "{\n    while(entry) {\n\tchar **str = entry->strings;\n\n\twhile(*str) {\n\t    if (conf_string_matches_princ(kcontext,\n\t\t\t\t\t  princ,\n\t\t\t\t\t  *str))\n\t\treturn entry;\n\n\t    str++;\n\t}\n\t\n\tentry = entry->next;\n    }\n\n    return NULL;\n}", "path": "srv_conf.c", "repo_name": "von/krb525", "stars": 1, "license": "None", "language": "c", "size": 176}
{"docstring": "/**\n * Get the index of the lowest bit of the two GNUNET_hash codes that\n * differs.\n */\n", "func_signal": "static unsigned int\nget_bit_distance (const GNUNET_HashCode * h1, const GNUNET_HashCode * h2)", "code": "{\n  unsigned int i;\n  int diff;\n\n  for (i = 0; i < sizeof (GNUNET_HashCode) * 8; i++)\n    {\n      diff = GNUNET_hash_get_bit (h1, i) - GNUNET_hash_get_bit (h2, i);\n      if (diff != 0)\n        return i;\n    }\n  return sizeof (GNUNET_HashCode) * 8;\n}", "path": "src\\applications\\dht\\module\\table.c", "repo_name": "OpenSourceInternetV2/gnunet", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 64}
{"docstring": "/**\n * Send a discovery message to the other peer.\n *\n * @param cls NULL or pre-build discovery message\n */\n", "func_signal": "static void\nbroadcast_dht_discovery (const GNUNET_PeerIdentity * other, void *cls)", "code": "{\n  P2P_DHT_Discovery *disco = cls;\n  unsigned int pc;\n  unsigned int i;\n  GNUNET_PeerIdentity *pos;\n\n  if (stats != NULL)\n    stats->change (stat_dht_advertisements, 1);\n  if (disco != NULL)\n    {\n      coreAPI->ciphertext_send (other,\n                                &disco->header,\n                                GNUNET_EXTREME_PRIORITY / 4,\n                                MAINTAIN_FREQUENCY * MAINTAIN_CHANCE / 2);\n      return;\n    }\n  pc = total_peers;\n  if (pc > MAINTAIN_ADV_CAP)\n    pc = MAINTAIN_ADV_CAP;\n  if (pc == 0)\n    pc = 1;\n  disco =\n    GNUNET_malloc (pc * sizeof (GNUNET_PeerIdentity) +\n                   sizeof (P2P_DHT_Discovery));\n  disco->header.type = htons (GNUNET_P2P_PROTO_DHT_DISCOVERY);\n  disco->space_available = -1;  /* FIXME */\n  pos = (GNUNET_PeerIdentity *) & disco[1];\n  i = 0;\n  if (total_peers == 0)\n    {\n      /* put in our own identity (otherwise we get into a\n         storm of empty discovery messages) */\n      pos[0] = *coreAPI->my_identity;\n      i = 1;\n    }\n  while (i < pc)\n    {\n      if (GNUNET_OK !=\n          GNUNET_DHT_select_peer (&pos[i], &other->hashPubKey, pos, i))\n        pc--;\n      else\n        i++;\n    }\n  disco->header.size =\n    htons (pc * sizeof (GNUNET_PeerIdentity) + sizeof (P2P_DHT_Discovery));\n  coreAPI->ciphertext_send (other, &disco->header, 0,\n                            MAINTAIN_FREQUENCY * MAINTAIN_CHANCE / 2);\n  GNUNET_free (disco);\n}", "path": "src\\applications\\dht\\module\\table.c", "repo_name": "OpenSourceInternetV2/gnunet", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 64}
{"docstring": "/**\n * Starts a single gnunet daemon on a remote machine\n *\n * @param gnunetd_home directory where gnunetd is on remote machine\n * @param localConfigPath local configuration path for config file\n * @param remote_config_path remote path to copy local config to\n * @param configFileName  file to copy and use on remote machine\n * @param ip_address ip address of remote machine\n * @param username username to use for ssh (assumed to be used with ssh-agent)\n */\n", "func_signal": "int\nGNUNET_REMOTE_start_daemon (char *gnunetd_home,\n                            char *localConfigPath, char *configFileName,\n                            char *remote_config_path, char *hostname,\n                            char *username, char *remote_friend_file_path)", "code": "{\n  char *cmd;\n  int length;\n\n  length =\n    snprintf (NULL, 0, \"scp %s%s %s@%s:%s\", localConfigPath, configFileName,\n              username, hostname, remote_config_path);\n  cmd = GNUNET_malloc (length + 1);\n  GNUNET_snprintf (cmd, length + 1, \"scp %s%s %s@%s:%s\", localConfigPath,\n                   configFileName, username, hostname, remote_config_path);\n\n  /* To me this seems like information that will always be appreciated by the user\n   * if this is contested by anyone, please mark it here as well as how it should be\n   * done, and I can change it everywhere else by example! NE\n   */\n  fprintf (stderr, _(\"scp command is : %s \\n\"), cmd);\n  system (cmd);\n\n  GNUNET_free (cmd);\n\n  length =\n    snprintf (NULL, 0, \"ssh %s@%s %sgnunet-update -c %s%s\", username,\n              hostname, gnunetd_home, remote_config_path, configFileName);\n  cmd = GNUNET_malloc (length + 1);\n  snprintf (cmd, length + 1, \"ssh %s@%s %sgnunet-update -c %s%s\", username,\n            hostname, gnunetd_home, remote_config_path, configFileName);\n\n  fprintf (stderr, _(\"ssh command is : %s \\n\"), cmd);\n\n  system (cmd);\n  GNUNET_free (cmd);\n\n  length =\n    snprintf (NULL, 0, \"ssh %s@%s %sgnunetd -c %s%s\", username, hostname,\n              gnunetd_home, remote_config_path, configFileName);\n  cmd = GNUNET_malloc (length + 1);\n  snprintf (cmd, length + 1, \"ssh %s@%s %sgnunetd -c %s%s\", username,\n            hostname, gnunetd_home, remote_config_path, configFileName);\n\n  fprintf (stderr, _(\"ssh command is : %s \\n\"), cmd);\n\n  system (cmd);\n\n  GNUNET_free (cmd);\n\n\n  return GNUNET_OK;\n}", "path": "src\\applications\\testing\\remote.c", "repo_name": "OpenSourceInternetV2/gnunet", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 64}
{"docstring": "/**\n * Find the PeerInfo for the given peer. Returns NULL if peer is not\n * in our DHT routing table.\n */\n", "func_signal": "static PeerInfo *\nfindPeerEntryInBucket (PeerBucket * bucket, const GNUNET_PeerIdentity * peer)", "code": "{\n  unsigned int i;\n\n  if (bucket == NULL)\n    return NULL;\n  for (i = 0; i < bucket->peers_size; i++)\n    if (0 ==\n        memcmp (peer, &bucket->peers[i]->id, sizeof (GNUNET_PeerIdentity)))\n      return bucket->peers[i];\n  return NULL;\n}", "path": "src\\applications\\dht\\module\\table.c", "repo_name": "OpenSourceInternetV2/gnunet", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 64}
{"docstring": "/**\n * Select a peer from the routing table that would be a good routing\n * destination for sending a message for \"target\".  The resulting peer\n * must not be in the set of blocked peers.<p>\n *\n * Note that we should not ALWAYS select the closest peer to the\n * target, peers further away from the target should be chosen with\n * exponentially declining probability (this function is also used for\n * populating the target's routing table).\n *\n * @return GNUNET_OK on success, GNUNET_SYSERR on error\n */\n", "func_signal": "int\nGNUNET_DHT_select_peer (GNUNET_PeerIdentity * set,\n                        const GNUNET_HashCode * target,\n                        const GNUNET_PeerIdentity * blocked,\n                        unsigned int blocked_size)", "code": "{\n  unsigned long long total_distance;\n  unsigned long long selected;\n  unsigned int distance;\n  unsigned int bc;\n  unsigned int ec;\n  unsigned int i;\n  int match;\n  const PeerBucket *bucket;\n  const PeerInfo *pi;\n\n  GNUNET_mutex_lock (lock);\n  if (stats != NULL)\n    stats->change (stat_dht_route_looks, 1);\n  total_distance = 0;\n  for (bc = 0; bc < bucketCount; bc++)\n    {\n      bucket = &buckets[bc];\n      for (ec = 0; ec < bucket->peers_size; ec++)\n        {\n          pi = bucket->peers[ec];\n          match = GNUNET_NO;\n          for (i = 0; i < blocked_size; i++)\n            {\n              if (0 ==\n                  memcmp (&pi->id, &blocked[i], sizeof (GNUNET_PeerIdentity)))\n                {\n                  match = GNUNET_YES;\n                  break;\n                }\n            }\n          if (match == GNUNET_YES)\n            continue;\n          total_distance += inverse_distance (target, &pi->id.hashPubKey);\n        }\n    }\n  if (total_distance == 0)\n    {\n      GNUNET_mutex_unlock (lock);\n      return GNUNET_SYSERR;\n    }\n  selected = GNUNET_random_u64 (GNUNET_RANDOM_QUALITY_WEAK, total_distance);\n  for (bc = 0; bc < bucketCount; bc++)\n    {\n      bucket = &buckets[bc];\n      for (ec = 0; ec < bucket->peers_size; ec++)\n        {\n          pi = bucket->peers[ec];\n          match = GNUNET_NO;\n          for (i = 0; i < blocked_size; i++)\n            {\n              if (0 ==\n                  memcmp (&pi->id, &blocked[i], sizeof (GNUNET_PeerIdentity)))\n                {\n                  match = GNUNET_YES;\n                  break;\n                }\n            }\n          if (match == GNUNET_YES)\n            continue;\n          distance = inverse_distance (target, &pi->id.hashPubKey);\n          if (distance > selected)\n            {\n              *set = pi->id;\n              GNUNET_mutex_unlock (lock);\n              return GNUNET_OK;\n            }\n          selected -= distance;\n        }\n    }\n  GNUNET_GE_BREAK (NULL, 0);\n  GNUNET_mutex_unlock (lock);\n  return GNUNET_SYSERR;\n}", "path": "src\\applications\\dht\\module\\table.c", "repo_name": "OpenSourceInternetV2/gnunet", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 64}
{"docstring": "/**\n * We have received a pong from a peer and know it is still\n * there.\n */\n", "func_signal": "static void\npongNotify (void *cls)", "code": "{\n  GNUNET_PeerIdentity *peer = cls;\n  PeerInfo *pi;\n\n  pi = findPeerEntry (peer);\n  if (pi != NULL)\n    {\n      pi->lastActivity = GNUNET_get_time ();\n      pi->expected_latency = pi->lastActivity - pi->lastTimePingSend;\n      pi->response_count++;\n    }\n  GNUNET_free (peer);\n}", "path": "src\\applications\\dht\\module\\table.c", "repo_name": "OpenSourceInternetV2/gnunet", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 64}
{"docstring": "/**\n * Compute a (rough) estimate of the networks diameter.\n *\n * @return estimated network diameter\n */\n", "func_signal": "unsigned int\nGNUNET_DHT_estimate_network_diameter ()", "code": "{\n  unsigned int i;\n  for (i = bucketCount - 1; i > 0; i--)\n    {\n      if (buckets[i].peers_size > 0)\n        break;\n    }\n  return i + 1;\n}", "path": "src\\applications\\dht\\module\\table.c", "repo_name": "OpenSourceInternetV2/gnunet", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 64}
{"docstring": "/**\n * Check if pi is still up and running.  May also try\n * to confirm that the peer is still live.\n *\n * @return GNUNET_YES if the peer should be removed from the DHT table\n */\n", "func_signal": "static int\ncheckExpired (PeerInfo * pi)", "code": "{\n  GNUNET_CronTime now;\n\n  now = GNUNET_get_time ();\n  if (pi->lastActivity >= now)\n    return GNUNET_NO;\n  if (now - pi->lastActivity > MAINTAIN_PEER_TIMEOUT)\n    return GNUNET_YES;\n  if (now - pi->lastActivity > MAINTAIN_PEER_TIMEOUT / 2)\n    pingPeer (pi);\n  return GNUNET_NO;\n}", "path": "src\\applications\\dht\\module\\table.c", "repo_name": "OpenSourceInternetV2/gnunet", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 64}
{"docstring": "/**\n * Check for expired peers in the given bucket.\n */\n", "func_signal": "static void\ncheckExpiration (PeerBucket * bucket)", "code": "{\n  unsigned int i;\n  PeerInfo *peer;\n\n  for (i = 0; i < bucket->peers_size; i++)\n    {\n      peer = bucket->peers[i];\n      if (checkExpired (peer) == GNUNET_YES)\n        {\n          total_peers--;\n          if (stats != NULL)\n            stats->change (stat_dht_total_peers, -1);\n          GNUNET_free (peer);\n          bucket->peers[i] = bucket->peers[bucket->peers_size - 1];\n          GNUNET_array_grow (bucket->peers, bucket->peers_size,\n                             bucket->peers_size - 1);\n          i--;\n        }\n    }\n}", "path": "src\\applications\\dht\\module\\table.c", "repo_name": "OpenSourceInternetV2/gnunet", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 64}
{"docstring": "/**\n * Initialize table DHT component.\n *\n * @param capi the core API\n * @return GNUNET_OK on success\n */\n", "func_signal": "int\nGNUNET_DHT_table_init (GNUNET_CoreAPIForPlugins * capi)", "code": "{\n  unsigned long long i;\n\n  coreAPI = capi;\n  /* use less than 50% of peer's ideal number of\n     connections for DHT table size */\n  i = coreAPI->core_slots_count () / MAINTAIN_BUCKET_SIZE / 2;\n  if (i < 4)\n    i = 4;\n  GNUNET_array_grow (buckets, bucketCount, i);\n  for (i = 0; i < bucketCount; i++)\n    {\n      buckets[i].bstart = 512 * i / bucketCount;\n      buckets[i].bend = 512 * (i + 1) / bucketCount;\n    }\n  lock = capi->global_lock_get ();\n  stats = capi->service_request (\"stats\");\n  if (stats != NULL)\n    {\n      stat_dht_total_peers =\n        stats->create (gettext_noop (\"# dht connections\"));\n      stat_dht_discoveries =\n        stats->create (gettext_noop (\"# dht discovery messages received\"));\n      stat_dht_route_looks =\n        stats->create (gettext_noop (\"# dht route host lookups performed\"));\n      stat_dht_advertisements =\n        stats->create (gettext_noop (\"# dht discovery messages sent\"));\n    }\n  identity = coreAPI->service_request (\"identity\");\n  GNUNET_GE_ASSERT (coreAPI->ectx, identity != NULL);\n  pingpong = coreAPI->service_request (\"pingpong\");\n  GNUNET_GE_ASSERT (coreAPI->ectx, pingpong != NULL);\n  capi->p2p_ciphertext_handler_register (GNUNET_P2P_PROTO_DHT_DISCOVERY,\n                                         &handleDiscovery);\n  capi->p2p_ciphertext_handler_register (GNUNET_P2P_PROTO_DHT_ASK_HELLO,\n                                         &handleAskHello);\n  capi->peer_disconnect_notification_register (&peer_disconnect_handler,\n                                               NULL);\n  GNUNET_cron_add_job (coreAPI->cron, &maintain_dht_job, MAINTAIN_FREQUENCY,\n                       MAINTAIN_FREQUENCY, NULL);\n  return GNUNET_OK;\n}", "path": "src\\applications\\dht\\module\\table.c", "repo_name": "OpenSourceInternetV2/gnunet", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 64}
{"docstring": "/**\n * Convert the len characters long character sequence\n * given in input that is in the given charset\n * to UTF-8.\n * @return the converted string (0-terminated),\n *  if conversion fails, a copy of the orignal\n *  string is returned.\n */\n", "func_signal": "char *\nGNUNET_convert_string_to_utf8 (struct GNUNET_GE_Context *ectx,\n                               const char *input, size_t len,\n                               const char *charset)", "code": "{\n  char *ret;\n#if ENABLE_NLS && HAVE_ICONV\n  size_t tmpSize;\n  size_t finSize;\n  char *tmp;\n  char *itmp;\n  iconv_t cd;\n\n  cd = iconv_open (\"UTF-8\", charset);\n  if (cd == (iconv_t) - 1)\n    {\n      GNUNET_GE_LOG_STRERROR (ectx,\n                              GNUNET_GE_USER | GNUNET_GE_ADMIN |\n                              GNUNET_GE_WARNING | GNUNET_GE_BULK,\n                              \"iconv_open\");\n      ret = GNUNET_malloc (len + 1);\n      memcpy (ret, input, len);\n      ret[len] = '\\0';\n      return ret;\n    }\n  tmpSize = 3 * len + 4;\n  tmp = GNUNET_malloc (tmpSize);\n  itmp = tmp;\n  finSize = tmpSize;\n  if (iconv (cd, (char **) &input, &len, &itmp, &finSize) == (size_t) - 1)\n    {\n      GNUNET_GE_LOG_STRERROR (ectx,\n                              GNUNET_GE_USER | GNUNET_GE_WARNING |\n                              GNUNET_GE_BULK, \"iconv\");\n      iconv_close (cd);\n      GNUNET_free (tmp);\n      ret = GNUNET_malloc (len + 1);\n      memcpy (ret, input, len);\n      ret[len] = '\\0';\n      return ret;\n    }\n  ret = GNUNET_malloc (tmpSize - finSize + 1);\n  memcpy (ret, tmp, tmpSize - finSize);\n  ret[tmpSize - finSize] = '\\0';\n  GNUNET_free (tmp);\n  if (0 != iconv_close (cd))\n    GNUNET_GE_LOG_STRERROR (ectx,\n                            GNUNET_GE_ADMIN | GNUNET_GE_WARNING |\n                            GNUNET_GE_REQUEST, \"iconv_close\");\n  return ret;\n#else\n  ret = GNUNET_malloc (len + 1);\n  memcpy (ret, input, len);\n  ret[len] = '\\0';\n  return ret;\n#endif\n}", "path": "src\\util\\string\\string.c", "repo_name": "OpenSourceInternetV2/gnunet", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 64}
{"docstring": "/**\n * @return NULL if peer is the current host\n */\n", "func_signal": "static PeerBucket *\nfindBucketFor (const GNUNET_PeerIdentity * peer)", "code": "{\n  unsigned int index;\n  int i;\n\n  if (0 == memcmp (peer, coreAPI->my_identity, sizeof (GNUNET_PeerIdentity)))\n    return NULL;                /* myself! */\n  index = get_bit_distance (&peer->hashPubKey,\n                            &coreAPI->my_identity->hashPubKey);\n  i = bucketCount - 1;\n  while ((buckets[i].bstart >= index) && (i > 0))\n    i--;\n  if ((buckets[i].bstart <= index) && (buckets[i].bend >= index))\n    return &buckets[i];\n  GNUNET_GE_BREAK (NULL, 0);\n  return NULL;\n}", "path": "src\\applications\\dht\\module\\table.c", "repo_name": "OpenSourceInternetV2/gnunet", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 64}
{"docstring": "/**\n * Shutdown table DHT component.\n *\n * @return GNUNET_OK on success\n */\n", "func_signal": "int\nGNUNET_DHT_table_done ()", "code": "{\n  unsigned int i;\n  unsigned int j;\n\n  coreAPI->peer_disconnect_notification_unregister (&peer_disconnect_handler,\n                                                    NULL);\n  coreAPI->p2p_ciphertext_handler_unregister (GNUNET_P2P_PROTO_DHT_DISCOVERY,\n                                              &handleDiscovery);\n  coreAPI->p2p_ciphertext_handler_unregister (GNUNET_P2P_PROTO_DHT_ASK_HELLO,\n                                              &handleAskHello);\n  GNUNET_cron_del_job (coreAPI->cron, &maintain_dht_job, MAINTAIN_FREQUENCY,\n                       NULL);\n  if (stats != NULL)\n    {\n      coreAPI->service_release (stats);\n      stats = NULL;\n    }\n  coreAPI->service_release (identity);\n  identity = NULL;\n  coreAPI->service_release (pingpong);\n  pingpong = NULL;\n  for (i = 0; i < bucketCount; i++)\n    {\n      for (j = 0; j < buckets[i].peers_size; j++)\n        GNUNET_free (buckets[i].peers[j]);\n      GNUNET_array_grow (buckets[i].peers, buckets[i].peers_size, 0);\n    }\n  GNUNET_array_grow (buckets, bucketCount, 0);\n  lock = NULL;\n  return GNUNET_OK;\n}", "path": "src\\applications\\dht\\module\\table.c", "repo_name": "OpenSourceInternetV2/gnunet", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 64}
{"docstring": "/**\n * Complete filename (a la shell) from abbrevition.\n * @param fil the name of the file, may contain ~/ or\n *        be relative to the current directory\n * @returns the full file name,\n *          NULL is returned on error\n */\n", "func_signal": "char *\nGNUNET_expand_file_name (struct GNUNET_GE_Context *ectx, const char *fil)", "code": "{\n  char *buffer;\n#ifndef MINGW\n  size_t len;\n  size_t n;\n  char *fm;\n  const char *fil_ptr;\n#else\n  char *fn;\n  long lRet;\n#endif\n\n  if (fil == NULL)\n    return NULL;\n\n#ifndef MINGW\n  if (fil[0] == DIR_SEPARATOR)\n    /* absolute path, just copy */\n    return GNUNET_strdup (fil);\n  if (fil[0] == '~')\n    {\n      fm = getenv (\"HOME\");\n      if (fm == NULL)\n        {\n          GNUNET_GE_LOG (ectx,\n                         GNUNET_GE_USER | GNUNET_GE_ADMIN | GNUNET_GE_WARNING\n                         | GNUNET_GE_IMMEDIATE,\n                         _\n                         (\"Failed to expand `$HOME': environment variable `HOME' not set\"));\n          return NULL;\n        }\n      fm = GNUNET_strdup (fm);\n      /* do not copy '~' */\n      fil_ptr = fil + 1;\n\n      /* skip over dir seperator to be consistent */\n      if (fil_ptr[0] == DIR_SEPARATOR)\n        fil_ptr++;\n    }\n  else\n    {\n      /* relative path */\n      fil_ptr = fil;\n      len = 512;\n      fm = NULL;\n      while (1)\n        {\n          buffer = GNUNET_malloc (len);\n          if (getcwd (buffer, len) != NULL)\n            {\n              fm = buffer;\n              break;\n            }\n          if ((errno == ERANGE) && (len < 1024 * 1024 * 4))\n            {\n              len *= 2;\n              GNUNET_free (buffer);\n              continue;\n            }\n          GNUNET_free (buffer);\n          break;\n        }\n      if (fm == NULL)\n        {\n          GNUNET_GE_LOG_STRERROR (ectx,\n                                  GNUNET_GE_USER | GNUNET_GE_WARNING |\n                                  GNUNET_GE_IMMEDIATE, \"getcwd\");\n          buffer = getenv (\"PWD\");      /* alternative */\n          if (buffer != NULL)\n            fm = GNUNET_strdup (buffer);\n        }\n      if (fm == NULL)\n        fm = GNUNET_strdup (\"./\");      /* give up */\n    }\n  n = strlen (fm) + 1 + strlen (fil_ptr) + 1;\n  buffer = GNUNET_malloc (n);\n  GNUNET_snprintf (buffer, n, \"%s/%s\", fm, fil_ptr);\n  GNUNET_free (fm);\n  return buffer;\n#else\n  fn = GNUNET_malloc (MAX_PATH + 1);\n\n  if ((lRet = plibc_conv_to_win_path (fil, fn)) != ERROR_SUCCESS)\n    {\n      SetErrnoFromWinError (lRet);\n      GNUNET_GE_LOG_STRERROR (ectx,\n                              GNUNET_GE_USER | GNUNET_GE_WARNING |\n                              GNUNET_GE_IMMEDIATE, \"plibc_conv_to_win_path\");\n      return NULL;\n    }\n  /* is the path relative? */\n  if ((strncmp (fn + 1, \":\\\\\", 2) != 0) && (strncmp (fn, \"\\\\\\\\\", 2) != 0))\n    {\n      char szCurDir[MAX_PATH + 1];\n      lRet = GetCurrentDirectory (MAX_PATH + 1, szCurDir);\n      if (lRet + strlen (fn) + 1 > (MAX_PATH + 1))\n        {\n          SetErrnoFromWinError (ERROR_BUFFER_OVERFLOW);\n          GNUNET_GE_LOG_STRERROR (ectx,\n                                  GNUNET_GE_USER | GNUNET_GE_WARNING |\n                                  GNUNET_GE_IMMEDIATE, \"GetCurrentDirectory\");\n          return NULL;\n        }\n      buffer = GNUNET_malloc (MAX_PATH + 1);\n      GNUNET_snprintf (buffer, MAX_PATH + 1, \"%s\\\\%s\", szCurDir, fn);\n      GNUNET_free (fn);\n      fn = buffer;\n    }\n\n  return fn;\n#endif\n}", "path": "src\\util\\string\\string.c", "repo_name": "OpenSourceInternetV2/gnunet", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 64}
{"docstring": "/**\n * Give relative time in human-readable fancy format.\n * @param delta time in milli seconds\n */\n", "func_signal": "char *\nGNUNET_get_time_interval_as_fancy_string (unsigned long long delta)", "code": "{\n  const char *unit = _( /* time unit */ \"ms\");\n  char *ret;\n\n  if (delta > 5 * 1000)\n    {\n      delta = delta / 1000;\n      unit = _( /* time unit */ \"s\");\n      if (delta > 5 * 60)\n        {\n          delta = delta / 60;\n          unit = _( /* time unit */ \"m\");\n          if (delta > 5 * 60)\n            {\n              delta = delta / 60;\n              unit = _( /* time unit */ \"h\");\n              if (delta > 5 * 24)\n                {\n                  delta = delta / 24;\n                  unit = _( /* time unit */ \" days\");\n                }\n            }\n        }\n    }\n  ret = GNUNET_malloc (32);\n  GNUNET_snprintf (ret, 32, \"%llu%s\", delta, unit);\n  return ret;\n}", "path": "src\\util\\string\\string.c", "repo_name": "OpenSourceInternetV2/gnunet", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 64}
{"docstring": "/**\n * Cron job to maintain DHT routing table.\n */\n", "func_signal": "static void\nmaintain_dht_job (void *unused)", "code": "{\n  P2P_DHT_Discovery disc;\n\n  if (total_peers == 0)\n    {\n      disc.header.size = htons (sizeof (P2P_DHT_Discovery));\n      disc.header.type = htons (GNUNET_P2P_PROTO_DHT_DISCOVERY);\n      disc.space_available = -1;        /* FIXME */\n      coreAPI->p2p_connections_iterate (&broadcast_dht_discovery_prob, &disc);\n    }\n  else\n    {\n      coreAPI->p2p_connections_iterate (&broadcast_dht_discovery_prob, NULL);\n    }\n}", "path": "src\\applications\\dht\\module\\table.c", "repo_name": "OpenSourceInternetV2/gnunet", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 64}
{"docstring": "/**\n * Handle discovery message.\n */\n", "func_signal": "static int\nhandleDiscovery (const GNUNET_PeerIdentity * sender,\n                 const GNUNET_MessageHeader * msg)", "code": "{\n  unsigned int pc;\n  unsigned int i;\n  const P2P_DHT_Discovery *disco;\n  const GNUNET_PeerIdentity *peers;\n\n  pc =\n    (ntohs (msg->size) -\n     sizeof (P2P_DHT_Discovery)) / sizeof (GNUNET_PeerIdentity);\n  if (pc > MAINTAIN_ADV_CAP * 8)\n    {\n      GNUNET_GE_BREAK_OP (coreAPI->ectx, 0);\n      return GNUNET_SYSERR;     /* far too big */\n    }\n  if (ntohs (msg->size) !=\n      sizeof (P2P_DHT_Discovery) + pc * sizeof (GNUNET_PeerIdentity))\n    {\n      GNUNET_GE_BREAK_OP (coreAPI->ectx, 0);\n      return GNUNET_SYSERR;     /* malformed */\n    }\n  disco = (const P2P_DHT_Discovery *) msg;\n  if (stats != NULL)\n    stats->change (stat_dht_discoveries, 1);\n  if (pc == 0)\n    {\n      /* if peer has 0 connections, be sure to send discovery back */\n      broadcast_dht_discovery (sender, NULL);\n    }\n  GNUNET_mutex_lock (lock);\n  considerPeer (sender, sender);\n  peers = (const GNUNET_PeerIdentity *) &disco[1];\n  for (i = 0; i < pc; i++)\n    considerPeer (sender, &peers[i]);\n  GNUNET_mutex_unlock (lock);\n  return GNUNET_OK;\n}", "path": "src\\applications\\dht\\module\\table.c", "repo_name": "OpenSourceInternetV2/gnunet", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 64}
{"docstring": "/**\n * Consider adding the given peer to the DHT.\n */\n", "func_signal": "static void\nconsiderPeer (const GNUNET_PeerIdentity * sender,\n              const GNUNET_PeerIdentity * peer)", "code": "{\n  PeerInfo *pi;\n  PeerBucket *bucket;\n  P2P_DHT_ASK_HELLO ask;\n  GNUNET_MessageHello *hello;\n\n  bucket = findBucketFor (peer);\n  if (bucket == NULL)\n    return;                     /* peers[i] == self */\n  if (bucket->peers_size >= MAINTAIN_BUCKET_SIZE)\n    checkExpiration (bucket);\n  if (bucket->peers_size >= MAINTAIN_BUCKET_SIZE)\n    return;                     /* do not care */\n  if (NULL != findPeerEntryInBucket (bucket, peer))\n    return;                     /* already have this peer in buckets */\n  /* do we know how to contact this peer? */\n  hello =\n    identity->identity2Hello (peer, GNUNET_TRANSPORT_PROTOCOL_NUMBER_ANY,\n                              GNUNET_NO);\n  if (hello == NULL)\n    {\n      /* if identity not known, ask sender for HELLO of other peer */\n      ask.header.size = htons (sizeof (P2P_DHT_ASK_HELLO));\n      ask.header.type = htons (sizeof (GNUNET_P2P_PROTO_DHT_ASK_HELLO));\n      ask.reserved = 0;\n      ask.peer = *peer;\n      coreAPI->ciphertext_send (sender, &ask.header, 0, /* FIXME: priority */\n                                5 * GNUNET_CRON_SECONDS);\n      return;\n    }\n  GNUNET_free (hello);\n  /* check if connected, if not, send discovery */\n  if (GNUNET_OK != coreAPI->p2p_connection_status_check (peer, NULL, NULL))\n    {\n      /* not yet connected; connect sending DISCOVERY */\n      broadcast_dht_discovery (peer, NULL);\n      return;\n    }\n  /* we are connected (in core), add to bucket */\n  pi = GNUNET_malloc (sizeof (PeerInfo));\n  memset (pi, 0, sizeof (PeerInfo));\n  pi->id = *peer;\n  pingPeer (pi);\n  GNUNET_array_grow (bucket->peers, bucket->peers_size,\n                     bucket->peers_size + 1);\n  bucket->peers[bucket->peers_size - 1] = pi;\n  total_peers++;\n  if (stats != NULL)\n    stats->change (stat_dht_total_peers, 1);\n}", "path": "src\\applications\\dht\\module\\table.c", "repo_name": "OpenSourceInternetV2/gnunet", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 64}
{"docstring": "/**\n * Send a ping to the given peer to check if it is still\n * running.\n */\n", "func_signal": "static void\npingPeer (PeerInfo * pi)", "code": "{\n  GNUNET_PeerIdentity *p;\n\n  p = GNUNET_malloc (sizeof (GNUNET_PeerIdentity));\n  *p = pi->id;\n  if (GNUNET_OK == pingpong->ping (p, &pongNotify, p, GNUNET_NO, rand ()))\n    {\n      pi->lastTimePingSend = GNUNET_get_time ();\n      pi->request_count++;\n    }\n}", "path": "src\\applications\\dht\\module\\table.c", "repo_name": "OpenSourceInternetV2/gnunet", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 64}
{"docstring": "/**\n * Return a number that is the larger the closer the\n * \"have\" GNUNET_hash code is to the \"target\".  The basic\n * idea is that if \"have\" would be in the n-th lowest\n * bucket of \"target\", the returned value should be\n * 2^n.  However, the largest number we can return\n * is 2^31, so this number may have to be scaled.\n *\n * @return inverse distance metric, non-zero.\n */\n", "func_signal": "static unsigned int\ninverse_distance (const GNUNET_HashCode * target,\n                  const GNUNET_HashCode * have)", "code": "{\n  unsigned int bucket;\n  double d;\n\n  bucket = get_bit_distance (target, have);\n  d = bucket * 32;\n  d = exp2 (d / (sizeof (GNUNET_HashCode) * 8));\n  if (d > ((unsigned int) -1))\n    return -1;\n  return (unsigned int) d;\n}", "path": "src\\applications\\dht\\module\\table.c", "repo_name": "OpenSourceInternetV2/gnunet", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 64}
{"docstring": "/*\n** Implementation of the R*-tree variant of SplitNode from Beckman[1990].\n*/\n", "func_signal": "static int splitNodeStartree(\n  Rtree *pRtree,\n  RtreeCell *aCell,\n  int nCell,\n  RtreeNode *pLeft,\n  RtreeNode *pRight,\n  RtreeCell *pBboxLeft,\n  RtreeCell *pBboxRight\n)", "code": "{\n  int **aaSorted;\n  int *aSpare;\n  int ii;\n\n  int iBestDim;\n  int iBestSplit;\n  float fBestMargin;\n\n  int nByte = (pRtree->nDim+1)*(sizeof(int*)+nCell*sizeof(int));\n\n  aaSorted = (int **)sqlite3_malloc(nByte);\n  if( !aaSorted ){\n    return SQLITE_NOMEM;\n  }\n\n  aSpare = &((int *)&aaSorted[pRtree->nDim])[pRtree->nDim*nCell];\n  memset(aaSorted, 0, nByte);\n  for(ii=0; ii<pRtree->nDim; ii++){\n    int jj;\n    aaSorted[ii] = &((int *)&aaSorted[pRtree->nDim])[ii*nCell];\n    for(jj=0; jj<nCell; jj++){\n      aaSorted[ii][jj] = jj;\n    }\n    SortByDimension(pRtree, aaSorted[ii], nCell, ii, aCell, aSpare);\n  }\n\n  for(ii=0; ii<pRtree->nDim; ii++){\n    float margin = 0.0;\n    float fBestOverlap;\n    float fBestArea;\n    int iBestLeft;\n    int nLeft;\n\n    for(\n      nLeft=RTREE_MINCELLS(pRtree); \n      nLeft<=(nCell-RTREE_MINCELLS(pRtree)); \n      nLeft++\n    ){\n      RtreeCell left;\n      RtreeCell right;\n      int kk;\n      float overlap;\n      float area;\n\n      memcpy(&left, &aCell[aaSorted[ii][0]], sizeof(RtreeCell));\n      memcpy(&right, &aCell[aaSorted[ii][nCell-1]], sizeof(RtreeCell));\n      for(kk=1; kk<(nCell-1); kk++){\n        if( kk<nLeft ){\n          cellUnion(pRtree, &left, &aCell[aaSorted[ii][kk]]);\n        }else{\n          cellUnion(pRtree, &right, &aCell[aaSorted[ii][kk]]);\n        }\n      }\n      margin += cellMargin(pRtree, &left);\n      margin += cellMargin(pRtree, &right);\n      overlap = cellOverlap(pRtree, &left, &right, 1, -1);\n      area = cellArea(pRtree, &left) + cellArea(pRtree, &right);\n      if( (nLeft==RTREE_MINCELLS(pRtree))\n       || (overlap<fBestOverlap)\n       || (overlap==fBestOverlap && area<fBestArea)\n      ){\n        iBestLeft = nLeft;\n        fBestOverlap = overlap;\n        fBestArea = area;\n      }\n    }\n\n    if( ii==0 || margin<fBestMargin ){\n      iBestDim = ii;\n      fBestMargin = margin;\n      iBestSplit = iBestLeft;\n    }\n  }\n\n  memcpy(pBboxLeft, &aCell[aaSorted[iBestDim][0]], sizeof(RtreeCell));\n  memcpy(pBboxRight, &aCell[aaSorted[iBestDim][iBestSplit]], sizeof(RtreeCell));\n  for(ii=0; ii<nCell; ii++){\n    RtreeNode *pTarget = (ii<iBestSplit)?pLeft:pRight;\n    RtreeCell *pBbox = (ii<iBestSplit)?pBboxLeft:pBboxRight;\n    RtreeCell *pCell = &aCell[aaSorted[iBestDim][ii]];\n    nodeInsertCell(pRtree, pTarget, pCell);\n    cellUnion(pRtree, pBbox, pCell);\n  }\n\n  sqlite3_free(aaSorted);\n  return SQLITE_OK;\n}", "path": "ext\\sqlite-3.6.22-fts3\\sqlite3.c", "repo_name": "senko/mawire", "stars": 1, "license": "None", "language": "c", "size": 1688}
{"docstring": "/* \n** Attempt to locate an element of the hash table pH with a key\n** that matches pKey,nKey.  Return the data for this element if it is\n** found, or NULL if there is no match.\n*/\n", "func_signal": "SQLITE_PRIVATE void *sqlite3Fts3HashFind(const Fts3Hash *pH, const void *pKey, int nKey)", "code": "{\n  Fts3HashElem *pElem;            /* The element that matches key (if any) */\n\n  pElem = sqlite3Fts3HashFindElem(pH, pKey, nKey);\n  return pElem ? pElem->data : 0;\n}", "path": "ext\\sqlite-3.6.22-fts3\\sqlite3.c", "repo_name": "senko/mawire", "stars": 1, "license": "None", "language": "c", "size": 1688}
{"docstring": "/*\n** Update the accumulator memory cells for an aggregate based on\n** the current cursor position.\n*/\n", "func_signal": "static void updateAccumulator(Parse *pParse, AggInfo *pAggInfo)", "code": "{\n  Vdbe *v = pParse->pVdbe;\n  int i;\n  struct AggInfo_func *pF;\n  struct AggInfo_col *pC;\n\n  pAggInfo->directMode = 1;\n  sqlite3ExprCacheClear(pParse);\n  for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++){\n    int nArg;\n    int addrNext = 0;\n    int regAgg;\n    ExprList *pList = pF->pExpr->x.pList;\n    assert( !ExprHasProperty(pF->pExpr, EP_xIsSelect) );\n    if( pList ){\n      nArg = pList->nExpr;\n      regAgg = sqlite3GetTempRange(pParse, nArg);\n      sqlite3ExprCodeExprList(pParse, pList, regAgg, 0);\n    }else{\n      nArg = 0;\n      regAgg = 0;\n    }\n    if( pF->iDistinct>=0 ){\n      addrNext = sqlite3VdbeMakeLabel(v);\n      assert( nArg==1 );\n      codeDistinct(pParse, pF->iDistinct, addrNext, 1, regAgg);\n    }\n    if( pF->pFunc->flags & SQLITE_FUNC_NEEDCOLL ){\n      CollSeq *pColl = 0;\n      struct ExprList_item *pItem;\n      int j;\n      assert( pList!=0 );  /* pList!=0 if pF->pFunc has NEEDCOLL */\n      for(j=0, pItem=pList->a; !pColl && j<nArg; j++, pItem++){\n        pColl = sqlite3ExprCollSeq(pParse, pItem->pExpr);\n      }\n      if( !pColl ){\n        pColl = pParse->db->pDfltColl;\n      }\n      sqlite3VdbeAddOp4(v, OP_CollSeq, 0, 0, 0, (char *)pColl, P4_COLLSEQ);\n    }\n    sqlite3VdbeAddOp4(v, OP_AggStep, 0, regAgg, pF->iMem,\n                      (void*)pF->pFunc, P4_FUNCDEF);\n    sqlite3VdbeChangeP5(v, (u8)nArg);\n    sqlite3ExprCacheAffinityChange(pParse, regAgg, nArg);\n    sqlite3ReleaseTempRange(pParse, regAgg, nArg);\n    if( addrNext ){\n      sqlite3VdbeResolveLabel(v, addrNext);\n      sqlite3ExprCacheClear(pParse);\n    }\n  }\n  for(i=0, pC=pAggInfo->aCol; i<pAggInfo->nAccumulator; i++, pC++){\n    sqlite3ExprCode(pParse, pC->pExpr, pC->iMem);\n  }\n  pAggInfo->directMode = 0;\n  sqlite3ExprCacheClear(pParse);\n}", "path": "ext\\sqlite-3.6.22-fts3\\sqlite3.c", "repo_name": "senko/mawire", "stars": 1, "license": "None", "language": "c", "size": 1688}
{"docstring": "/*\n** Change the value of the P2 operand for a specific instruction.\n** This routine is useful for setting a jump destination.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3VdbeChangeP2(Vdbe *p, int addr, int val)", "code": "{\n  assert( p!=0 );\n  assert( addr>=0 );\n  if( p->nOp>addr ){\n    p->aOp[addr].p2 = val;\n  }\n}", "path": "ext\\sqlite-3.6.22-fts3\\sqlite3.c", "repo_name": "senko/mawire", "stars": 1, "license": "None", "language": "c", "size": 1688}
{"docstring": "/*\n** Read a single block from the %_segments table. If the specified block\n** does not exist, return SQLITE_CORRUPT. If some other error (malloc, IO \n** etc.) occurs, return the appropriate SQLite error code.\n**\n** Otherwise, if successful, set *pzBlock to point to a buffer containing\n** the block read from the database, and *pnBlock to the size of the read\n** block in bytes.\n**\n** WARNING: The returned buffer is only valid until the next call to \n** sqlite3Fts3ReadBlock().\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3Fts3ReadBlock(\n  Fts3Table *p,\n  sqlite3_int64 iBlock,\n  char const **pzBlock,\n  int *pnBlock\n)", "code": "{\n  sqlite3_stmt *pStmt;\n  int rc = fts3SqlStmt(p, SQL_GET_BLOCK, &pStmt, 0);\n  if( rc!=SQLITE_OK ) return rc;\n  sqlite3_reset(pStmt);\n\n  if( pzBlock ){\n    sqlite3_bind_int64(pStmt, 1, iBlock);\n    rc = sqlite3_step(pStmt); \n    if( rc!=SQLITE_ROW ){\n      return (rc==SQLITE_DONE ? SQLITE_CORRUPT : rc);\n    }\n  \n    *pnBlock = sqlite3_column_bytes(pStmt, 0);\n    *pzBlock = (char *)sqlite3_column_blob(pStmt, 0);\n    if( sqlite3_column_type(pStmt, 0)!=SQLITE_BLOB ){\n      return SQLITE_CORRUPT;\n    }\n  }\n  return SQLITE_OK;\n}", "path": "ext\\sqlite-3.6.22-fts3\\sqlite3.c", "repo_name": "senko/mawire", "stars": 1, "license": "None", "language": "c", "size": 1688}
{"docstring": "/*\n** Move the cursor down to the right-most leaf entry beneath the\n** page to which it is currently pointing.  Notice the difference\n** between moveToLeftmost() and moveToRightmost().  moveToLeftmost()\n** finds the left-most entry beneath the *entry* whereas moveToRightmost()\n** finds the right-most entry beneath the *page*.\n**\n** The right-most entry is the one with the largest key - the last\n** key in ascending order.\n*/\n", "func_signal": "static int moveToRightmost(BtCursor *pCur)", "code": "{\n  Pgno pgno;\n  int rc = SQLITE_OK;\n  MemPage *pPage = 0;\n\n  assert( cursorHoldsMutex(pCur) );\n  assert( pCur->eState==CURSOR_VALID );\n  while( rc==SQLITE_OK && !(pPage = pCur->apPage[pCur->iPage])->leaf ){\n    pgno = get4byte(&pPage->aData[pPage->hdrOffset+8]);\n    pCur->aiIdx[pCur->iPage] = pPage->nCell;\n    rc = moveToChild(pCur, pgno);\n  }\n  if( rc==SQLITE_OK ){\n    pCur->aiIdx[pCur->iPage] = pPage->nCell-1;\n    pCur->info.nSize = 0;\n    pCur->validNKey = 0;\n  }\n  return rc;\n}", "path": "ext\\sqlite-3.6.22-fts3\\sqlite3.c", "repo_name": "senko/mawire", "stars": 1, "license": "None", "language": "c", "size": 1688}
{"docstring": "/*\n** Lock the file with the lock specified by parameter locktype - one\n** of the following:\n**\n**     (1) SHARED_LOCK\n**     (2) RESERVED_LOCK\n**     (3) PENDING_LOCK\n**     (4) EXCLUSIVE_LOCK\n**\n** Sometimes when requesting one lock state, additional lock states\n** are inserted in between.  The locking might fail on one of the later\n** transitions leaving the lock state different from what it started but\n** still short of its goal.  The following chart shows the allowed\n** transitions and the inserted intermediate states:\n**\n**    UNLOCKED -> SHARED\n**    SHARED -> RESERVED\n**    SHARED -> (PENDING) -> EXCLUSIVE\n**    RESERVED -> (PENDING) -> EXCLUSIVE\n**    PENDING -> EXCLUSIVE\n**\n** This routine will only increase a lock.  Use the sqlite3OsUnlock()\n** routine to lower a locking level.\n*/\n", "func_signal": "static int proxyLock(sqlite3_file *id, int locktype)", "code": "{\n  unixFile *pFile = (unixFile*)id;\n  int rc = proxyTakeConch(pFile);\n  if( rc==SQLITE_OK ){\n    proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;\n    unixFile *proxy = pCtx->lockProxy;\n    rc = proxy->pMethod->xLock((sqlite3_file*)proxy, locktype);\n    pFile->locktype = proxy->locktype;\n  }\n  return rc;\n}", "path": "ext\\sqlite-3.6.22-fts3\\sqlite3.c", "repo_name": "senko/mawire", "stars": 1, "license": "None", "language": "c", "size": 1688}
{"docstring": "/*\n** If the cell pCell, part of page pPage contains a pointer\n** to an overflow page, insert an entry into the pointer-map\n** for the overflow page.\n*/\n", "func_signal": "static void ptrmapPutOvflPtr(MemPage *pPage, u8 *pCell, int *pRC)", "code": "{\n  CellInfo info;\n  if( *pRC ) return;\n  assert( pCell!=0 );\n  btreeParseCellPtr(pPage, pCell, &info);\n  assert( (info.nData+(pPage->intKey?0:info.nKey))==info.nPayload );\n  if( info.iOverflow ){\n    Pgno ovfl = get4byte(&pCell[info.iOverflow]);\n    ptrmapPut(pPage->pBt, ovfl, PTRMAP_OVERFLOW1, pPage->pgno, pRC);\n  }\n}", "path": "ext\\sqlite-3.6.22-fts3\\sqlite3.c", "repo_name": "senko/mawire", "stars": 1, "license": "None", "language": "c", "size": 1688}
{"docstring": "/*\n** This routine checks if there is a RESERVED lock held on the specified\n** file by this or any other process. If such a lock is held, set *pResOut\n** to a non-zero value otherwise *pResOut is set to zero.  The return value\n** is set to SQLITE_OK unless an I/O error occurs during lock checking.\n*/\n", "func_signal": "static int proxyCheckReservedLock(sqlite3_file *id, int *pResOut)", "code": "{\n  unixFile *pFile = (unixFile*)id;\n  int rc = proxyTakeConch(pFile);\n  if( rc==SQLITE_OK ){\n    proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;\n    unixFile *proxy = pCtx->lockProxy;\n    return proxy->pMethod->xCheckReservedLock((sqlite3_file*)proxy, pResOut);\n  }\n  return rc;\n}", "path": "ext\\sqlite-3.6.22-fts3\\sqlite3.c", "repo_name": "senko/mawire", "stars": 1, "license": "None", "language": "c", "size": 1688}
{"docstring": "/*\n** Return non-zero if a read (or write) transaction is active.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3BtreeIsInReadTrans(Btree *p)", "code": "{\n  assert( p );\n  assert( sqlite3_mutex_held(p->db->mutex) );\n  return p->inTrans!=TRANS_NONE;\n}", "path": "ext\\sqlite-3.6.22-fts3\\sqlite3.c", "repo_name": "senko/mawire", "stars": 1, "license": "None", "language": "c", "size": 1688}
{"docstring": "/*\n** Create a temporary file name in zBuf.  zBuf must be big enough to\n** hold at pVfs->mxPathname characters.\n*/\n", "func_signal": "static int getTempname(int nBuf, char *zBuf )", "code": "{\n  static const unsigned char zChars[] =\n    \"abcdefghijklmnopqrstuvwxyz\"\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    \"0123456789\";\n  int i, j;\n  char zTempPathBuf[3];\n  PSZ zTempPath = (PSZ)&zTempPathBuf;\n  if( sqlite3_temp_directory ){\n    zTempPath = sqlite3_temp_directory;\n  }else{\n    if( DosScanEnv( (PSZ)\"TEMP\", &zTempPath ) ){\n      if( DosScanEnv( (PSZ)\"TMP\", &zTempPath ) ){\n        if( DosScanEnv( (PSZ)\"TMPDIR\", &zTempPath ) ){\n           ULONG ulDriveNum = 0, ulDriveMap = 0;\n           DosQueryCurrentDisk( &ulDriveNum, &ulDriveMap );\n           sprintf( (char*)zTempPath, \"%c:\", (char)( 'A' + ulDriveNum - 1 ) );\n        }\n      }\n    }\n  }\n  /* Strip off a trailing slashes or backslashes, otherwise we would get *\n   * multiple (back)slashes which causes DosOpen() to fail.              *\n   * Trailing spaces are not allowed, either.                            */\n  j = sqlite3Strlen30(zTempPath);\n  while( j > 0 && ( zTempPath[j-1] == '\\\\' || zTempPath[j-1] == '/'\n                    || zTempPath[j-1] == ' ' ) ){\n    j--;\n  }\n  zTempPath[j] = '\\0';\n  if( !sqlite3_temp_directory ){\n    char *zTempPathUTF = convertCpPathToUtf8( zTempPath );\n    sqlite3_snprintf( nBuf-30, zBuf,\n                      \"%s\\\\\"SQLITE_TEMP_FILE_PREFIX, zTempPathUTF );\n    free( zTempPathUTF );\n  }else{\n    sqlite3_snprintf( nBuf-30, zBuf,\n                      \"%s\\\\\"SQLITE_TEMP_FILE_PREFIX, zTempPath );\n  }\n  j = sqlite3Strlen30( zBuf );\n  sqlite3_randomness( 20, &zBuf[j] );\n  for( i = 0; i < 20; i++, j++ ){\n    zBuf[j] = (char)zChars[ ((unsigned char)zBuf[j])%(sizeof(zChars)-1) ];\n  }\n  zBuf[j] = 0;\n  OSTRACE2( \"TEMP FILENAME: %s\\n\", zBuf );\n  return SQLITE_OK;\n}", "path": "ext\\sqlite-3.6.22-fts3\\sqlite3.c", "repo_name": "senko/mawire", "stars": 1, "license": "None", "language": "c", "size": 1688}
{"docstring": "/*\n** Delete the given Select structure and all of its substructures.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3SelectDelete(sqlite3 *db, Select *p)", "code": "{\n  if( p ){\n    clearSelect(db, p);\n    sqlite3DbFree(db, p);\n  }\n}", "path": "ext\\sqlite-3.6.22-fts3\\sqlite3.c", "repo_name": "senko/mawire", "stars": 1, "license": "None", "language": "c", "size": 1688}
{"docstring": "/*\n** Change the page size for PCache object. The caller must ensure that there\n** are no outstanding page references when this function is called.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3PcacheSetPageSize(PCache *pCache, int szPage)", "code": "{\n  assert( pCache->nRef==0 && pCache->pDirty==0 );\n  if( pCache->pCache ){\n    sqlite3GlobalConfig.pcache.xDestroy(pCache->pCache);\n    pCache->pCache = 0;\n  }\n  pCache->szPage = szPage;\n}", "path": "ext\\sqlite-3.6.22-fts3\\sqlite3.c", "repo_name": "senko/mawire", "stars": 1, "license": "None", "language": "c", "size": 1688}
{"docstring": "/*\n** Convert microsoft unicode to multibyte character string, based on the\n** user's Ansi codepage.\n**\n** Space to hold the returned string is obtained from\n** malloc().\n*/\n", "func_signal": "static char *unicodeToMbcs(const WCHAR *zWideFilename)", "code": "{\n  int nByte;\n  char *zFilename;\n  int codepage = AreFileApisANSI() ? CP_ACP : CP_OEMCP;\n\n  nByte = WideCharToMultiByte(codepage, 0, zWideFilename, -1, 0, 0, 0, 0);\n  zFilename = malloc( nByte );\n  if( zFilename==0 ){\n    return 0;\n  }\n  nByte = WideCharToMultiByte(codepage, 0, zWideFilename, -1, zFilename, nByte,\n                              0, 0);\n  if( nByte == 0 ){\n    free(zFilename);\n    zFilename = 0;\n  }\n  return zFilename;\n}", "path": "ext\\sqlite-3.6.22-fts3\\sqlite3.c", "repo_name": "senko/mawire", "stars": 1, "license": "None", "language": "c", "size": 1688}
{"docstring": "/*\n** This function returns a pointer to the array of opcodes associated with\n** the Vdbe passed as the first argument. It is the callers responsibility\n** to arrange for the returned array to be eventually freed using the \n** vdbeFreeOpArray() function.\n**\n** Before returning, *pnOp is set to the number of entries in the returned\n** array. Also, *pnMaxArg is set to the larger of its current value and \n** the number of entries in the Vdbe.apArg[] array required to execute the \n** returned program.\n*/\n", "func_signal": "SQLITE_PRIVATE VdbeOp *sqlite3VdbeTakeOpArray(Vdbe *p, int *pnOp, int *pnMaxArg)", "code": "{\n  VdbeOp *aOp = p->aOp;\n  assert( aOp && !p->db->mallocFailed );\n\n  /* Check that sqlite3VdbeUsesBtree() was not called on this VM */\n  assert( p->aMutex.nMutex==0 );\n\n  resolveP2Values(p, pnMaxArg);\n  *pnOp = p->nOp;\n  p->aOp = 0;\n  return aOp;\n}", "path": "ext\\sqlite-3.6.22-fts3\\sqlite3.c", "repo_name": "senko/mawire", "stars": 1, "license": "None", "language": "c", "size": 1688}
{"docstring": "/*\n** This function performs the parts of the \"close file\" operation \n** common to all locking schemes. It closes the directory and file\n** handles, if they are valid, and sets all fields of the unixFile\n** structure to 0.\n**\n** It is *not* necessary to hold the mutex when this routine is called,\n** even on VxWorks.  A mutex will be acquired on VxWorks by the\n** vxworksReleaseFileId() routine.\n*/\n", "func_signal": "static int closeUnixFile(sqlite3_file *id)", "code": "{\n  unixFile *pFile = (unixFile*)id;\n  if( pFile ){\n    if( pFile->dirfd>=0 ){\n      int err = close(pFile->dirfd);\n      if( err ){\n        pFile->lastErrno = errno;\n        return SQLITE_IOERR_DIR_CLOSE;\n      }else{\n        pFile->dirfd=-1;\n      }\n    }\n    if( pFile->h>=0 ){\n      int err = close(pFile->h);\n      if( err ){\n        pFile->lastErrno = errno;\n        return SQLITE_IOERR_CLOSE;\n      }\n    }\n#if OS_VXWORKS\n    if( pFile->pId ){\n      if( pFile->isDelete ){\n        unlink(pFile->pId->zCanonicalName);\n      }\n      vxworksReleaseFileId(pFile->pId);\n      pFile->pId = 0;\n    }\n#endif\n    OSTRACE2(\"CLOSE   %-3d\\n\", pFile->h);\n    OpenCounter(-1);\n    sqlite3_free(pFile->pUnused);\n    memset(pFile, 0, sizeof(unixFile));\n  }\n  return SQLITE_OK;\n}", "path": "ext\\sqlite-3.6.22-fts3\\sqlite3.c", "repo_name": "senko/mawire", "stars": 1, "license": "None", "language": "c", "size": 1688}
{"docstring": "/*\n** Convert a sorted list of elements (connected by pRight) into a binary\n** tree with depth of iDepth.  A depth of 1 means the tree contains a single\n** node taken from the head of *ppList.  A depth of 2 means a tree with\n** three nodes.  And so forth.\n**\n** Use as many entries from the input list as required and update the\n** *ppList to point to the unused elements of the list.  If the input\n** list contains too few elements, then construct an incomplete tree\n** and leave *ppList set to NULL.\n**\n** Return a pointer to the root of the constructed binary tree.\n*/\n", "func_signal": "static struct RowSetEntry *rowSetNDeepTree(\n  struct RowSetEntry **ppList,\n  int iDepth\n)", "code": "{\n  struct RowSetEntry *p;         /* Root of the new tree */\n  struct RowSetEntry *pLeft;     /* Left subtree */\n  if( *ppList==0 ){\n    return 0;\n  }\n  if( iDepth==1 ){\n    p = *ppList;\n    *ppList = p->pRight;\n    p->pLeft = p->pRight = 0;\n    return p;\n  }\n  pLeft = rowSetNDeepTree(ppList, iDepth-1);\n  p = *ppList;\n  if( p==0 ){\n    return pLeft;\n  }\n  p->pLeft = pLeft;\n  *ppList = p->pRight;\n  p->pRight = rowSetNDeepTree(ppList, iDepth-1);\n  return p;\n}", "path": "ext\\sqlite-3.6.22-fts3\\sqlite3.c", "repo_name": "senko/mawire", "stars": 1, "license": "None", "language": "c", "size": 1688}
{"docstring": "/*\n** Register a profile function.  The pArg from the previously registered \n** profile function is returned.  \n**\n** A NULL profile function means that no profiling is executes.  A non-NULL\n** profile is a pointer to a function that is invoked at the conclusion of\n** each SQL statement that is run.\n*/\n", "func_signal": "SQLITE_API void *sqlite3_profile(\n  sqlite3 *db,\n  void (*xProfile)(void*,const char*,sqlite_uint64),\n  void *pArg\n)", "code": "{\n  void *pOld;\n  sqlite3_mutex_enter(db->mutex);\n  pOld = db->pProfileArg;\n  db->xProfile = xProfile;\n  db->pProfileArg = pArg;\n  sqlite3_mutex_leave(db->mutex);\n  return pOld;\n}", "path": "ext\\sqlite-3.6.22-fts3\\sqlite3.c", "repo_name": "senko/mawire", "stars": 1, "license": "None", "language": "c", "size": 1688}
{"docstring": "/*\n** Convert pMem to type integer.  Invalidate any prior representations.\n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3VdbeMemIntegerify(Mem *pMem)", "code": "{\n  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );\n  assert( (pMem->flags & MEM_RowSet)==0 );\n  assert( EIGHT_BYTE_ALIGNMENT(pMem) );\n\n  pMem->u.i = sqlite3VdbeIntValue(pMem);\n  MemSetTypeFlag(pMem, MEM_Int);\n  return SQLITE_OK;\n}", "path": "ext\\sqlite-3.6.22-fts3\\sqlite3.c", "repo_name": "senko/mawire", "stars": 1, "license": "None", "language": "c", "size": 1688}
{"docstring": "/*\n** Close a tokenization cursor previously opened by a call to\n** porterOpen() above.\n*/\n", "func_signal": "static int porterClose(sqlite3_tokenizer_cursor *pCursor)", "code": "{\n  porter_tokenizer_cursor *c = (porter_tokenizer_cursor *) pCursor;\n  sqlite3_free(c->zToken);\n  sqlite3_free(c);\n  return SQLITE_OK;\n}", "path": "ext\\sqlite-3.6.22-fts3\\sqlite3.c", "repo_name": "senko/mawire", "stars": 1, "license": "None", "language": "c", "size": 1688}
{"docstring": "/*\n * Destroy and cleanup the global DNS cache\n */\n", "func_signal": "void Curl_global_host_cache_dtor(void)", "code": "{\n  if(host_cache_initialized) {\n    Curl_hash_clean(&hostname_cache);\n    host_cache_initialized = 0;\n  }\n}", "path": "lib\\hostip.c", "repo_name": "Kali-lightsaber/curl", "stars": 0, "license": "other", "language": "c", "size": 2748}
{"docstring": "/*\n * Curl_ip2addr() takes a 32bit ipv4 internet address as input parameter\n * together with a pointer to the string version of the address, and it\n * returns a Curl_addrinfo chain filled in correctly with information for this\n * address/host.\n *\n * The input parameters ARE NOT checked for validity but they are expected\n * to have been checked already when this is called.\n */\n", "func_signal": "Curl_addrinfo *Curl_ip2addr(in_addr_t num, const char *hostname, int port)", "code": "{\n  Curl_addrinfo *ai;\n\n#if defined(VMS) && \\\n    defined(__INITIAL_POINTER_SIZE) && (__INITIAL_POINTER_SIZE == 64)\n#pragma pointer_size save\n#pragma pointer_size short\n#pragma message disable PTRMISMATCH\n#endif\n\n  struct hostent *h;\n  struct in_addr *addrentry;\n  struct namebuf buffer;\n  struct namebuf *buf = &buffer;\n\n  h = &buf->hostentry;\n  h->h_addr_list = &buf->h_addr_list[0];\n  addrentry = &buf->addrentry;\n#ifdef _CRAYC\n  /* On UNICOS, s_addr is a bit field and for some reason assigning to it\n   * doesn't work.  There must be a better fix than this ugly hack.\n   */\n  memcpy(addrentry, &num, SIZEOF_in_addr);\n#else\n  addrentry->s_addr = num;\n#endif\n  h->h_addr_list[0] = (char*)addrentry;\n  h->h_addr_list[1] = NULL;\n  h->h_addrtype = AF_INET;\n  h->h_length = sizeof(*addrentry);\n  h->h_name = &buf->h_name[0];\n  h->h_aliases = NULL;\n\n  /* Now store the dotted version of the address */\n  snprintf((char *)h->h_name, 16, \"%s\", hostname);\n\n#if defined(VMS) && \\\n    defined(__INITIAL_POINTER_SIZE) && (__INITIAL_POINTER_SIZE == 64)\n#pragma pointer_size restore\n#pragma message enable PTRMISMATCH\n#endif\n\n  ai = Curl_he2ai(h, port);\n\n  return ai;\n}", "path": "lib\\hostip.c", "repo_name": "Kali-lightsaber/curl", "stars": 0, "license": "other", "language": "c", "size": 2748}
{"docstring": "/*\n * Curl_resolv() is the main name resolve function within libcurl. It resolves\n * a name and returns a pointer to the entry in the 'entry' argument (if one\n * is provided). This function might return immediately if we're using asynch\n * resolves. See the return codes.\n *\n * The cache entry we return will get its 'inuse' counter increased when this\n * function is used. You MUST call Curl_resolv_unlock() later (when you're\n * done using this struct) to decrease the counter again.\n *\n * Return codes:\n *\n * CURLRESOLV_ERROR   (-1) = error, no pointer\n * CURLRESOLV_RESOLVED (0) = OK, pointer provided\n * CURLRESOLV_PENDING  (1) = waiting for response, no pointer\n */\n", "func_signal": "int Curl_resolv(struct connectdata *conn,\n                const char *hostname,\n                int port,\n                struct Curl_dns_entry **entry)", "code": "{\n  char *entry_id = NULL;\n  struct Curl_dns_entry *dns = NULL;\n  size_t entry_len;\n  struct SessionHandle *data = conn->data;\n  CURLcode result;\n  int rc = CURLRESOLV_ERROR; /* default to failure */\n  *entry = NULL;\n\n#ifdef HAVE_SIGSETJMP\n  /* this allows us to time-out from the name resolver, as the timeout\n     will generate a signal and we will siglongjmp() from that here */\n  if(!data->set.no_signal) {\n    if(sigsetjmp(curl_jmpenv, 1)) {\n      /* this is coming from a siglongjmp() */\n      failf(data, \"name lookup timed out\");\n      return rc;\n    }\n  }\n#endif\n\n  /* Create an entry id, based upon the hostname and port */\n  entry_id = create_hostcache_id(hostname, port);\n  /* If we can't create the entry id, fail */\n  if(!entry_id)\n    return rc;\n\n  entry_len = strlen(entry_id);\n\n  if(data->share)\n    Curl_share_lock(data, CURL_LOCK_DATA_DNS, CURL_LOCK_ACCESS_SINGLE);\n\n  /* See if its already in our dns cache */\n  dns = Curl_hash_pick(data->dns.hostcache, entry_id, entry_len+1);\n\n  /* See whether the returned entry is stale. Done before we release lock */\n  if( remove_entry_if_stale(data, dns) )\n    dns = NULL; /* the memory deallocation is being handled by the hash */\n\n  if(dns) {\n    dns->inuse++; /* we use it! */\n    rc = CURLRESOLV_RESOLVED;\n  }\n\n  if(data->share)\n    Curl_share_unlock(data, CURL_LOCK_DATA_DNS);\n\n  /* free the allocated entry_id again */\n  free(entry_id);\n\n  if(!dns) {\n    /* The entry was not in the cache. Resolve it to IP address */\n\n    Curl_addrinfo *addr;\n    int respwait;\n\n    /* Check what IP specifics the app has requested and if we can provide it.\n     * If not, bail out. */\n    if(!Curl_ipvalid(data))\n      return CURLRESOLV_ERROR;\n\n    /* If Curl_getaddrinfo() returns NULL, 'respwait' might be set to a\n       non-zero value indicating that we need to wait for the response to the\n       resolve call */\n    addr = Curl_getaddrinfo(conn, hostname, port, &respwait);\n\n    if(!addr) {\n      if(respwait) {\n        /* the response to our resolve call will come asynchronously at\n           a later time, good or bad */\n        /* First, check that we haven't received the info by now */\n        result = Curl_is_resolved(conn, &dns);\n        if(result) /* error detected */\n          return CURLRESOLV_ERROR;\n        if(dns)\n          rc = CURLRESOLV_RESOLVED; /* pointer provided */\n        else\n          rc = CURLRESOLV_PENDING; /* no info yet */\n      }\n    }\n    else {\n      if(data->share)\n        Curl_share_lock(data, CURL_LOCK_DATA_DNS, CURL_LOCK_ACCESS_SINGLE);\n\n      /* we got a response, store it in the cache */\n      dns = Curl_cache_addr(data, addr, hostname, port);\n\n      if(data->share)\n        Curl_share_unlock(data, CURL_LOCK_DATA_DNS);\n\n      if(!dns)\n        /* returned failure, bail out nicely */\n        Curl_freeaddrinfo(addr);\n      else\n        rc = CURLRESOLV_RESOLVED;\n    }\n  }\n\n  *entry = dns;\n\n  return rc;\n}", "path": "lib\\hostip.c", "repo_name": "Kali-lightsaber/curl", "stars": 0, "license": "other", "language": "c", "size": 2748}
{"docstring": "/*\n * Curl_printable_address() returns a printable version of the 1st address\n * given in the 'ip' argument. The result will be stored in the buf that is\n * bufsize bytes big.\n *\n * If the conversion fails, it returns NULL.\n */\n", "func_signal": "const char *Curl_printable_address(const Curl_addrinfo *ip,\n                                   char *buf, size_t bufsize)", "code": "{\n  const void *ip4 = &((const struct sockaddr_in*)ip->ai_addr)->sin_addr;\n  int af = ip->ai_family;\n#ifdef CURLRES_IPV6\n  const void *ip6 = &((const struct sockaddr_in6*)ip->ai_addr)->sin6_addr;\n#else\n  const void *ip6 = NULL;\n#endif\n\n  return Curl_inet_ntop(af, af == AF_INET ? ip4 : ip6, buf, bufsize);\n}", "path": "lib\\hostip.c", "repo_name": "Kali-lightsaber/curl", "stars": 0, "license": "other", "language": "c", "size": 2748}
{"docstring": "/*\n * Curl_global_host_cache_init() initializes and sets up a global DNS cache.\n * Global DNS cache is general badness. Do not use. This will be removed in\n * a future version. Use the share interface instead!\n *\n * Returns a struct curl_hash pointer on success, NULL on failure.\n */\n", "func_signal": "struct curl_hash *Curl_global_host_cache_init(void)", "code": "{\n  int rc = 0;\n  if(!host_cache_initialized) {\n    rc = Curl_hash_init(&hostname_cache, 7, Curl_hash_str,\n                        Curl_str_key_compare, freednsentry);\n    if(!rc)\n      host_cache_initialized = 1;\n  }\n  return rc?NULL:&hostname_cache;\n}", "path": "lib\\hostip.c", "repo_name": "Kali-lightsaber/curl", "stars": 0, "license": "other", "language": "c", "size": 2748}
{"docstring": "/*\n * Curl_addrinfo_copy() performs a \"deep\" copy of a hostent into a buffer and\n * returns a pointer to the malloc()ed copy. You need to call free() on the\n * returned buffer when you're done with it.\n */\n", "func_signal": "Curl_addrinfo *Curl_addrinfo_copy(const void *org, int port)", "code": "{\n  const struct hostent *orig = org;\n\n  return Curl_he2ai(orig, port);\n}", "path": "lib\\hostip.c", "repo_name": "Kali-lightsaber/curl", "stars": 0, "license": "other", "language": "c", "size": 2748}
{"docstring": "/*\n * Simply download a HTTP file.\n */\n", "func_signal": "int main(int argc, char **argv)", "code": "{\n  CURL *http_handle;\n  CURLM *multi_handle;\n\n  int still_running; /* keep number of running handles */\n\n  http_handle = curl_easy_init();\n\n  /* set the options (I left out a few, you'll get the point anyway) */\n  curl_easy_setopt(http_handle, CURLOPT_URL, \"http://www.haxx.se/\");\n\n  /* init a multi stack */\n  multi_handle = curl_multi_init();\n\n  /* add the individual transfers */\n  curl_multi_add_handle(multi_handle, http_handle);\n\n  /* we start some action by calling perform right away */\n  while(CURLM_CALL_MULTI_PERFORM ==\n        curl_multi_perform(multi_handle, &still_running));\n\n  while(still_running) {\n    struct timeval timeout;\n    int rc; /* select() return code */\n\n    fd_set fdread;\n    fd_set fdwrite;\n    fd_set fdexcep;\n    int maxfd;\n\n    FD_ZERO(&fdread);\n    FD_ZERO(&fdwrite);\n    FD_ZERO(&fdexcep);\n\n    /* set a suitable timeout to play around with */\n    timeout.tv_sec = 1;\n    timeout.tv_usec = 0;\n\n    /* get file descriptors from the transfers */\n    curl_multi_fdset(multi_handle, &fdread, &fdwrite, &fdexcep, &maxfd);\n\n    /* In a real-world program you OF COURSE check the return code of the\n       function calls, *and* you make sure that maxfd is bigger than -1 so\n       that the call to select() below makes sense! */\n\n    rc = select(maxfd+1, &fdread, &fdwrite, &fdexcep, &timeout);\n\n    switch(rc) {\n    case -1:\n      /* select error */\n      still_running = 0;\n      printf(\"select() returns error, this is badness\\n\");\n      break;\n    case 0:\n    default:\n      /* timeout or readable/writable sockets */\n      while(CURLM_CALL_MULTI_PERFORM ==\n            curl_multi_perform(multi_handle, &still_running));\n      break;\n    }\n  }\n\n  curl_multi_cleanup(multi_handle);\n\n  curl_easy_cleanup(http_handle);\n\n  return 0;\n}", "path": "docs\\examples\\multi-single.c", "repo_name": "Kali-lightsaber/curl", "stars": 0, "license": "other", "language": "c", "size": 2748}
{"docstring": "/* #include iosbdef */\n", "func_signal": "char *getpass_r(const char *prompt, char *buffer, size_t buflen)", "code": "{\n  long sts;\n  short chan;\n\n  /* MSK, 23-JAN-2004, iosbdef.h wasn't in VAX V7.2 or CC 6.4  */\n  /* distribution so I created this.  May revert back later to */\n  /* struct _iosb iosb;                                        */\n  struct _iosb\n     {\n     short int iosb$w_status; /* status     */\n     short int iosb$w_bcnt;   /* byte count */\n     int       unused;        /* unused     */\n     } iosb;\n\n  $DESCRIPTOR(ttdesc, \"TT\");\n\n  buffer[0]='\\0';\n  sts = sys$assign(&ttdesc, &chan,0,0);\n  if (sts & 1) {\n    sts = sys$qiow(0, chan,\n                   IO$_READPROMPT | IO$M_NOECHO,\n                   &iosb, 0, 0, buffer, buflen, 0, 0,\n                   prompt, strlen(prompt));\n\n    if((sts & 1) && (iosb.iosb$w_status&1))\n      buffer[iosb.iosb$w_bcnt] = '\\0';\n\n    sts = sys$dassgn(chan);\n  }\n  return buffer; /* we always return success */\n}", "path": "src\\getpass.c", "repo_name": "Kali-lightsaber/curl", "stars": 0, "license": "other", "language": "c", "size": 2748}
{"docstring": "/*\n * Library-wide function for pruning the DNS cache. This function takes and\n * returns the appropriate locks.\n */\n", "func_signal": "void Curl_hostcache_prune(struct SessionHandle *data)", "code": "{\n  time_t now;\n\n  if((data->set.dns_cache_timeout == -1) || !data->dns.hostcache)\n    /* cache forever means never prune, and NULL hostcache means\n       we can't do it */\n    return;\n\n  if(data->share)\n    Curl_share_lock(data, CURL_LOCK_DATA_DNS, CURL_LOCK_ACCESS_SINGLE);\n\n  time(&now);\n\n  /* Remove outdated and unused entries from the hostcache */\n  hostcache_prune(data->dns.hostcache,\n                  data->set.dns_cache_timeout,\n                  now);\n\n  if(data->share)\n    Curl_share_unlock(data, CURL_LOCK_DATA_DNS);\n}", "path": "lib\\hostip.c", "repo_name": "Kali-lightsaber/curl", "stars": 0, "license": "other", "language": "c", "size": 2748}
{"docstring": "/* store the entire request in a file */\n", "func_signal": "void storerequest(char *reqbuf, ssize_t totalsize)", "code": "{\n  int error;\n  ssize_t written;\n  ssize_t writeleft;\n  FILE *dump;\n\n  if (reqbuf == NULL)\n    return;\n\n  if (totalsize == 0)\n    return;\n  else if (totalsize < 0) {\n    logmsg(\"Invalid size (%d bytes) for request input. Not written to %s\",\n           totalsize, REQUEST_DUMP);\n    return;\n  }\n\n  do {\n    dump = fopen(REQUEST_DUMP, \"ab\");\n  } while ((dump == NULL) && ((error = ERRNO) == EINTR));\n  if (dump == NULL) {\n    logmsg(\"Error opening file %s error: %d %s\",\n           REQUEST_DUMP, error, strerror(error));\n    logmsg(\"Failed to write request input to \" REQUEST_DUMP);\n    return;\n  }\n\n  writeleft = totalsize;\n  do {\n    written = (ssize_t)fwrite((void *) &reqbuf[totalsize-writeleft],\n                              1, (size_t)writeleft, dump);\n    if (written > 0)\n      writeleft -= written;\n  } while ((writeleft > 0) && ((error = ERRNO) == EINTR));\n\n  fclose(dump);  /* close it ASAP */\n\n  if (writeleft > 0) {\n    logmsg(\"Error writing file %s error: %d %s\",\n           REQUEST_DUMP, error, strerror(error));\n    logmsg(\"Wrote only (%d bytes) of (%d bytes) request input to %s\",\n           totalsize-writeleft, totalsize, REQUEST_DUMP);\n  }\n  else {\n    logmsg(\"Wrote request (%d bytes) input to \" REQUEST_DUMP,\n           totalsize);\n  }\n}", "path": "tests\\server\\sws.c", "repo_name": "Kali-lightsaber/curl", "stars": 0, "license": "other", "language": "c", "size": 2748}
{"docstring": "/*\n * Prune the DNS cache. This assumes that a lock has already been taken.\n */\n", "func_signal": "static void\nhostcache_prune(struct curl_hash *hostcache, long cache_timeout, time_t now)", "code": "{\n  struct hostcache_prune_data user;\n\n  user.cache_timeout = cache_timeout;\n  user.now = now;\n\n  Curl_hash_clean_with_criterium(hostcache,\n                                 (void *) &user,\n                                 hostcache_timestamp_remove);\n}", "path": "lib\\hostip.c", "repo_name": "Kali-lightsaber/curl", "stars": 0, "license": "other", "language": "c", "size": 2748}
{"docstring": "/*\n * Return # of adresses in a Curl_addrinfo struct\n */\n", "func_signal": "int Curl_num_addresses(const Curl_addrinfo *addr)", "code": "{\n  int i;\n  for (i = 0; addr; addr = addr->ai_next, i++)\n    ;  /* empty loop */\n  return i;\n}", "path": "lib\\hostip.c", "repo_name": "Kali-lightsaber/curl", "stars": 0, "license": "other", "language": "c", "size": 2748}
{"docstring": "/*\n * Check if the entry should be pruned. Assumes a locked cache.\n */\n", "func_signal": "static int\nremove_entry_if_stale(struct SessionHandle *data, struct Curl_dns_entry *dns)", "code": "{\n  struct hostcache_prune_data user;\n\n  if( !dns || (data->set.dns_cache_timeout == -1) || !data->dns.hostcache)\n    /* cache forever means never prune, and NULL hostcache means\n       we can't do it */\n    return 0;\n\n  time(&user.now);\n  user.cache_timeout = data->set.dns_cache_timeout;\n\n  if( !hostcache_timestamp_remove(&user,dns) )\n    return 0;\n\n  Curl_hash_clean_with_criterium(data->dns.hostcache,\n                                 (void *) &user,\n                                 hostcache_timestamp_remove);\n\n  return 1;\n}", "path": "lib\\hostip.c", "repo_name": "Kali-lightsaber/curl", "stars": 0, "license": "other", "language": "c", "size": 2748}
{"docstring": "/*\n * This function is set as a callback to be called for every entry in the DNS\n * cache when we want to prune old unused entries.\n *\n * Returning non-zero means remove the entry, return 0 to keep it in the\n * cache.\n */\n", "func_signal": "static int\nhostcache_timestamp_remove(void *datap, void *hc)", "code": "{\n  struct hostcache_prune_data *data =\n    (struct hostcache_prune_data *) datap;\n  struct Curl_dns_entry *c = (struct Curl_dns_entry *) hc;\n\n  if((data->now - c->timestamp < data->cache_timeout) ||\n      c->inuse) {\n    /* please don't remove */\n    return 0;\n  }\n\n  /* fine, remove */\n  return 1;\n}", "path": "lib\\hostip.c", "repo_name": "Kali-lightsaber/curl", "stars": 0, "license": "other", "language": "c", "size": 2748}
{"docstring": "/* returns -1 on failure */\n", "func_signal": "static int send_doc(curl_socket_t sock, struct httprequest *req)", "code": "{\n  ssize_t written;\n  size_t count;\n  const char *buffer;\n  char *ptr;\n  FILE *stream;\n  char *cmd=NULL;\n  size_t cmdsize=0;\n  FILE *dump;\n  bool persistant = TRUE;\n  size_t responsesize;\n  int error;\n\n  static char weare[256];\n\n  char partbuf[80]=\"data\";\n\n  logmsg(\"Send response number %d part %d\", req->testno, req->partno);\n\n  switch(req->rcmd) {\n  default:\n  case RCMD_NORMALREQ:\n    break; /* continue with business as usual */\n  case RCMD_STREAM:\n#define STREAMTHIS \"a string to stream 01234567890\\n\"\n    count = strlen(STREAMTHIS);\n    while(1) {\n      written = swrite(sock, STREAMTHIS, count);\n      if(written != (ssize_t)count) {\n        logmsg(\"Stopped streaming\");\n        break;\n      }\n    }\n    return -1;\n  case RCMD_IDLE:\n    /* Do nothing. Sit idle. Pretend it rains. */\n    return 0;\n  }\n\n  req->open = FALSE;\n\n  if(req->testno < 0) {\n    size_t msglen;\n    char msgbuf[64];\n\n    switch(req->testno) {\n    case DOCNUMBER_QUIT:\n      logmsg(\"Replying to QUIT\");\n      buffer = docquit;\n      break;\n    case DOCNUMBER_WERULEZ:\n      /* we got a \"friends?\" question, reply back that we sure are */\n      logmsg(\"Identifying ourselves as friends\");\n      sprintf(msgbuf, \"WE ROOLZ: %ld\\r\\n\", (long)getpid());\n      msglen = strlen(msgbuf);\n      sprintf(weare, \"HTTP/1.1 200 OK\\r\\nContent-Length: %d\\r\\n\\r\\n%s\",\n              msglen, msgbuf);\n      buffer = weare;\n      break;\n    case DOCNUMBER_INTERNAL:\n      logmsg(\"Bailing out due to internal error\");\n      return -1;\n    case DOCNUMBER_CONNECT:\n      logmsg(\"Replying to CONNECT\");\n      buffer = docconnect;\n      break;\n    case DOCNUMBER_BADCONNECT:\n      logmsg(\"Replying to a bad CONNECT\");\n      buffer = docbadconnect;\n      break;\n    case DOCNUMBER_404:\n    default:\n      logmsg(\"Replying to with a 404\");\n      buffer = doc404;\n      break;\n    }\n    ptr = NULL;\n    stream=NULL;\n\n    count = strlen(buffer);\n  }\n  else {\n    char *filename = test2file(req->testno);\n\n    if(0 != req->partno)\n      sprintf(partbuf, \"data%ld\", req->partno);\n\n    stream=fopen(filename, \"rb\");\n    if(!stream) {\n      error = ERRNO;\n      logmsg(\"fopen() failed with error: %d %s\", error, strerror(error));\n      logmsg(\"Error opening file: %s\", filename);\n      logmsg(\"Couldn't open test file\");\n      return 0;\n    }\n    else {\n      buffer = spitout(stream, \"reply\", partbuf, &count);\n      ptr = (char *)buffer;\n      fclose(stream);\n    }\n\n    /* re-open the same file again */\n    stream=fopen(filename, \"rb\");\n    if(!stream) {\n      error = ERRNO;\n      logmsg(\"fopen() failed with error: %d %s\", error, strerror(error));\n      logmsg(\"Error opening file: %s\", filename);\n      logmsg(\"Couldn't open test file\");\n      return 0;\n    }\n    else {\n      /* get the custom server control \"commands\" */\n      cmd = (char *)spitout(stream, \"reply\", \"postcmd\", &cmdsize);\n      fclose(stream);\n    }\n  }\n\n  dump = fopen(RESPONSE_DUMP, \"ab\"); /* b is for windows-preparing */\n  if(!dump) {\n    error = ERRNO;\n    logmsg(\"fopen() failed with error: %d %s\", error, strerror(error));\n    logmsg(\"Error opening file: %s\", RESPONSE_DUMP);\n    logmsg(\"couldn't create logfile: \" RESPONSE_DUMP);\n    return -1;\n  }\n\n  /* If the word 'swsclose' is present anywhere in the reply chunk, the\n     connection will be closed after the data has been sent to the requesting\n     client... */\n  if(strstr(buffer, \"swsclose\") || !count) {\n    persistant = FALSE;\n    logmsg(\"connection close instruction \\\"swsclose\\\" found in response\");\n  }\n  if(strstr(buffer, \"swsbounce\")) {\n    prevbounce = TRUE;\n    logmsg(\"enable \\\"swsbounce\\\" in the next request\");\n  }\n  else\n    prevbounce = FALSE;\n\n\n  responsesize = count;\n  do {\n    /* Ok, we send no more than 200 bytes at a time, just to make sure that\n       larger chunks are split up so that the client will need to do multiple\n       recv() calls to get it and thus we exercise that code better */\n    size_t num = count;\n    if(num > 200)\n      num = 200;\n    written = swrite(sock, buffer, num);\n    if (written < 0) {\n      fclose(dump);\n      logmsg(\"Sending response failed and we bailed out!\");\n      return -1;\n    }\n    else {\n      logmsg(\"Sent off %d bytes\", written);\n    }\n    /* write to file as well */\n    fwrite(buffer, 1, written, dump);\n\n    count -= written;\n    buffer += written;\n  } while(count>0);\n\n  fclose(dump);\n\n  logmsg(\"Response sent (%d bytes) and written to \" RESPONSE_DUMP,\n         responsesize);\n\n  if(ptr)\n    free(ptr);\n\n  if(cmdsize > 0 ) {\n    char command[32];\n    int num;\n    ptr=cmd;\n    do {\n      if(2 == sscanf(ptr, \"%31s %d\", command, &num)) {\n        if(!strcmp(\"wait\", command)) {\n          logmsg(\"Told to sleep for %d seconds\", num);\n          sleep(num); /* wait this many seconds */\n        }\n        else\n          logmsg(\"Unknown command in reply command section\");\n      }\n      ptr = strchr(ptr, '\\n');\n      if(ptr)\n        ptr++;\n      else\n        ptr = NULL;\n    } while(ptr && *ptr);\n  }\n  if(cmd)\n    free(cmd);\n\n  req->open = persistant;\n\n  prevtestno = req->testno;\n  prevpartno = req->partno;\n\n  return 0;\n}", "path": "tests\\server\\sws.c", "repo_name": "Kali-lightsaber/curl", "stars": 0, "license": "other", "language": "c", "size": 2748}
{"docstring": "/*\n * File-internal: free a cache dns entry.\n */\n", "func_signal": "static void freednsentry(void *freethis)", "code": "{\n  struct Curl_dns_entry *p = (struct Curl_dns_entry *) freethis;\n\n  Curl_freeaddrinfo(p->addr);\n\n  free(p);\n}", "path": "lib\\hostip.c", "repo_name": "Kali-lightsaber/curl", "stars": 0, "license": "other", "language": "c", "size": 2748}
{"docstring": "/* return 0 on success, non-zero on failure */\n", "func_signal": "static int get_request(curl_socket_t sock, struct httprequest *req)", "code": "{\n  int fail = 0;\n  char *reqbuf = req->reqbuf;\n  ssize_t got = 0;\n\n  char *pipereq;\n  int pipereq_length = 0;\n\n  if(req->pipelining) {\n    pipereq = reqbuf + req->checkindex;\n    pipereq_length = req->offset - req->checkindex;\n  }\n\n  /*** Init the httpreqest structure properly for the upcoming request ***/\n\n  req->checkindex = 0;\n  req->offset = 0;\n  req->testno = DOCNUMBER_NOTHING;\n  req->partno = 0;\n  req->open = TRUE;\n  req->auth_req = FALSE;\n  req->auth = FALSE;\n  req->cl = 0;\n  req->digest = FALSE;\n  req->ntlm = FALSE;\n  req->pipe = 0;\n  req->rcmd = RCMD_NORMALREQ;\n  req->prot_version = 0;\n  req->pipelining = FALSE;\n\n  /*** end of httprequest init ***/\n\n  while (req->offset < REQBUFSIZ-1) {\n    if(pipereq_length) {\n      memmove(reqbuf, pipereq, pipereq_length); \n      got = pipereq_length;\n      pipereq_length = 0;\n    }\n    else\n      got = sread(sock, reqbuf + req->offset, REQBUFSIZ-1 - req->offset);\n    if (got <= 0) {\n      if (got < 0) {\n        logmsg(\"recv() returned error: %d\", SOCKERRNO);\n        return DOCNUMBER_INTERNAL;\n      }\n      logmsg(\"Connection closed by client\");\n      reqbuf[req->offset] = '\\0';\n\n      /* dump the request receivied so far to the external file */\n      storerequest(reqbuf, req->offset);\n      return DOCNUMBER_INTERNAL;\n    }\n\n    logmsg(\"Read %d bytes\", got);\n\n    req->offset += got;\n    reqbuf[req->offset] = '\\0';\n\n    if(ProcessRequest(req)) {\n      if(req->pipe--) {\n        logmsg(\"Waiting for another piped request\");\n        continue;\n      }\n      break;\n    }\n  }\n\n  if((req->offset == REQBUFSIZ-1) && (got > 0)) {\n    logmsg(\"Request would overflow buffer, closing connection\");\n    /* dump request received so far to external file anyway */\n    reqbuf[REQBUFSIZ-1] = '\\0';\n    fail = 1;\n  }\n  else if(req->offset > REQBUFSIZ-1) {\n    logmsg(\"Request buffer overflow, closing connection\");\n    /* dump request received so far to external file anyway */\n    reqbuf[REQBUFSIZ-1] = '\\0';\n    fail = 1;\n  }\n  else\n    reqbuf[req->offset] = '\\0';\n\n  /* dump the request to an external file */\n  storerequest(reqbuf, req->pipelining ? req->checkindex : req->offset);\n\n  return fail; /* return 0 on success */\n}", "path": "tests\\server\\sws.c", "repo_name": "Kali-lightsaber/curl", "stars": 0, "license": "other", "language": "c", "size": 2748}
{"docstring": "/*\n * Curl_cache_addr() stores a 'Curl_addrinfo' struct in the DNS cache.\n *\n * When calling Curl_resolv() has resulted in a response with a returned\n * address, we call this function to store the information in the dns\n * cache etc\n *\n * Returns the Curl_dns_entry entry pointer or NULL if the storage failed.\n */\n", "func_signal": "struct Curl_dns_entry *\nCurl_cache_addr(struct SessionHandle *data,\n                Curl_addrinfo *addr,\n                const char *hostname,\n                int port)", "code": "{\n  char *entry_id;\n  size_t entry_len;\n  struct Curl_dns_entry *dns;\n  struct Curl_dns_entry *dns2;\n  time_t now;\n\n  /* Create an entry id, based upon the hostname and port */\n  entry_id = create_hostcache_id(hostname, port);\n  /* If we can't create the entry id, fail */\n  if(!entry_id)\n    return NULL;\n  entry_len = strlen(entry_id);\n\n  /* Create a new cache entry */\n  dns = (struct Curl_dns_entry *) calloc(sizeof(struct Curl_dns_entry), 1);\n  if(!dns) {\n    free(entry_id);\n    return NULL;\n  }\n\n  dns->inuse = 0;   /* init to not used */\n  dns->addr = addr; /* this is the address(es) */\n\n  /* Store the resolved data in our DNS cache. This function may return a\n     pointer to an existing struct already present in the hash, and it may\n     return the same argument we pass in. Make no assumptions. */\n  dns2 = Curl_hash_add(data->dns.hostcache, entry_id, entry_len+1,\n                       (void *)dns);\n  if(!dns2) {\n    /* Major badness, run away. */\n    free(dns);\n    free(entry_id);\n    return NULL;\n  }\n  time(&now);\n  dns = dns2;\n\n  dns->timestamp = now; /* used now */\n  dns->inuse++;         /* mark entry as in-use */\n\n  /* free the allocated entry_id again */\n  free(entry_id);\n\n  return dns;\n}", "path": "lib\\hostip.c", "repo_name": "Kali-lightsaber/curl", "stars": 0, "license": "other", "language": "c", "size": 2748}
{"docstring": "/*\n * Curl_resolv_unlock() unlocks the given cached DNS entry. When this has been\n * made, the struct may be destroyed due to pruning. It is important that only\n * one unlock is made for each Curl_resolv() call.\n */\n", "func_signal": "void Curl_resolv_unlock(struct SessionHandle *data, struct Curl_dns_entry *dns)", "code": "{\n  DEBUGASSERT(dns && (dns->inuse>0));\n\n  if(data->share)\n    Curl_share_lock(data, CURL_LOCK_DATA_DNS, CURL_LOCK_ACCESS_SINGLE);\n\n  dns->inuse--;\n\n  if(data->share)\n    Curl_share_unlock(data, CURL_LOCK_DATA_DNS);\n}", "path": "lib\\hostip.c", "repo_name": "Kali-lightsaber/curl", "stars": 0, "license": "other", "language": "c", "size": 2748}
{"docstring": "/*\n * This is a function for freeing name information in a protocol independent\n * way.\n */\n", "func_signal": "void Curl_freeaddrinfo(Curl_addrinfo *ai)", "code": "{\n  Curl_addrinfo *next;\n\n  /* walk over the list and free all entries */\n  while(ai) {\n    next = ai->ai_next;\n    if(ai->ai_canonname)\n      free(ai->ai_canonname);\n    free(ai);\n    ai = next;\n  }\n}", "path": "lib\\hostip.c", "repo_name": "Kali-lightsaber/curl", "stars": 0, "license": "other", "language": "c", "size": 2748}
{"docstring": "/*****************************************************************************\n Function: openFile\n Inputs:   the file to open, the file name, mode to open the file\n Returns:  nothing\n Description: opens file in specified mode or issues error message\n *****************************************************************************/\n", "func_signal": "void openFile( FILE **fileptr, char *filename, char *mode )", "code": "{\n  *fileptr = fopen( filename, mode );       /* open the file */\n \n  if ( !(*fileptr )) {\n    printf(\"ERROR: Failed to open file: %s with mode %s.  Exiting.\\n\\n\",\n\t   filename, mode);\n    exit(0);\n  }\n \n}", "path": "project3FazeliRosenthal\\reformat1.c", "repo_name": "clr/cos472", "stars": 1, "license": "None", "language": "c", "size": 868}
{"docstring": "/*****************************************************************************\n Function: emalloc\n Inputs:   the size of the block of memory needed\n Returns:  a pointer to the block of memory\n Description: calls malloc, but checks for failure\n *****************************************************************************/\n", "func_signal": "void *emalloc(long size)", "code": "{\n  void *p = (void *) malloc(size);     /* request memory */\n \n  if (p == NULL) {            /* quit if request failed */\n    printf(\"Unable to intitialize...out of memory.\");\n    exit(0);\n  }\n \n  return p;\n \n}", "path": "project3FazeliRosenthal\\reformat.c", "repo_name": "clr/cos472", "stars": 1, "license": "None", "language": "c", "size": 868}
{"docstring": "/*****************************************************************************\n Function: emalloc\n Inputs:   the size of the block of memory needed\n Returns:  a pointer to the block of memory\n Description: calls malloc, but checks for failure\n *****************************************************************************/\n", "func_signal": "void *emalloc(long size)", "code": "{\n  void *p = (void *) malloc(size);     /* request memory */\n\n  if (p == NULL) {            /* quit if request failed */\n    printf(\"Unable to intitialize...out of memory.\");\n    exit(0);\n  }\n\n  return p;\n\n}", "path": "lab4FazeliRosenthal\\minimax.c", "repo_name": "clr/cos472", "stars": 1, "license": "None", "language": "c", "size": 868}
{"docstring": "/*****************************************************************************\n Function: printNode\n Inputs:   node with a board in it\n Returns:  nothing\n Description:\n   print out the board for this node\n *****************************************************************************/\n", "func_signal": "void printNode (NodeP node)", "code": "{\n\n  int i,j;  /* loop counters */\n\n  /* just to test node->board[0][1] = 'o'; */\n\n  printf(\"Board is: \\n\");\n\n  for (i=0; i<DIMENSION; i++) {\n    /* possible, but doesn't look as \"pretty\":\n       printf(\"  %s\\n\", node->board[i]);\n    */\n\n    printf(\"  \");\n    for (j=0; j<DIMENSION; j++) {\n      printf(\"%c \", node->board[i][j]);\n    }\n    printf(\"\\n\");\n\n  }\n  printf(\"static score: %i\\n\", node->staticScore);\n  printf(\"minimax score: %i\\n\", node->mmScore);\n\n  printf(\"\\n\");\n\n}", "path": "lab4FazeliRosenthal\\minimax.c", "repo_name": "clr/cos472", "stars": 1, "license": "None", "language": "c", "size": 868}
{"docstring": "/*****************************************************************************\n  We run the program by calling something along the lines of:\n  guessMushroom -train mushrooms.data -test moreMushrooms.data -out mushrooms.out \n ******************************************************************************/\n", "func_signal": "int main(int argc, char* argv[])", "code": "{\n  MushroomP trainingShroomList;\n  trainingShroomList = NULL;\n  MushroomP testingShroomList;\n  testingShroomList = NULL;\n  ValueP availableValues;\n  DecisionP decisionTree;\n  availableValues = NULL;\n  decisionTree = NULL;\n  char infilenameTraining[STRLEN]; /* input file name for training data */\n  char infilenameTesting[STRLEN]; /* input file name for testing data */\n  char outfilename[STRLEN]; /* output file name for printing the results */\n \n  printf( \"This program processes data about the attributes mushrooms.\\n\" );\n  \n  /* initialize filenames to dummy strings */\n  strcpy( infilenameTraining, \"none\" );\n  strcpy( infilenameTesting, \"none\" );\n  strcpy( outfilename, \"none\" );\n  /* TAKEN FROM p5.c EXAMLPE\n     process command-line arguments */\n  while( *++argv ) {             /* while there are still command-line args */\n    if ( !strcmp( *argv, \"-train\" ) )          /* set input file name */\n      strcpy( infilenameTraining, *++argv );\n    else if( !strcmp( *argv,\"-test\" ) )          /* set input file name */\n      strcpy( infilenameTesting, *++argv );\n    else if( !strcmp( *argv,\"-out\" ) )     /* set output file name */\n      strcpy( outfilename,*++argv );\n    else {  /*  error checking */\n      printf( \"\\nERROR: option %s not recognized\\n\", *argv );\n      printf( \"...exiting program\\n\\n\" );\n      exit( 0 );\n    }\n  } /* end, while there are still command-line args */\n \n  /* this is the training data */\n  trainingShroomList = readMushrooms( infilenameTraining );\n \n  /* this is the testing data */\n  testingShroomList = readMushrooms( infilenameTesting );\n \n  availableValues = findAvailableValues( 'e', 0, trainingShroomList );\n \n  decisionTree = createDecisionTree( 'e', 0, trainingShroomList, availableValues );\n \n  printDecisionTree( decisionTree, outfilename );\n \n  printTestResults( 'e', 0, decisionTree, testingShroomList, outfilename );\n\n  /* free the list of test mushrooms */\n  freeMushrooms( trainingShroomList );\n  freeMushrooms( testingShroomList );\n  /* note that Decision structs are freed in printDecisionTree */\n  /* free value list */\n  freeValues( availableValues );\n\n\treturn (0);\n \n}", "path": "project3FazeliRosenthal\\reformat1.c", "repo_name": "clr/cos472", "stars": 1, "license": "None", "language": "c", "size": 868}
{"docstring": "/*****************************************************************************\n Function: gameOver\n Inputs:   node\n Returns:  1 if game is over; 0 if game is not over\n Description: cheating for now; just counting moves\n   to fix: should check for three in a row or full board\n     should also print out who won or that it's a cat's game\n *****************************************************************************/\n", "func_signal": "int gameOver(NodeP node)", "code": "{\n  if (MoveCount == DIMENSION*DIMENSION)\n    return 1;\n  else\n    return 0;\n}", "path": "lab4FazeliRosenthal\\minimax.c", "repo_name": "clr/cos472", "stars": 1, "license": "None", "language": "c", "size": 868}
{"docstring": "/*****************************************************************************\n  We run the program by calling something along the lines of:\n  guessMushroom -test moreMushrooms.data -out mushrooms.out \n ******************************************************************************/\n", "func_signal": "int main(int argc, char* argv[])", "code": "{\n  srand( time( 0 ) ); \n  \n  MushroomP trainingShroomList;\n  trainingShroomList = NULL;\n  MushroomP testingShroomList;\n  testingShroomList = NULL;\n  ValueP availableValues;\n  DecisionP decisionTree;\n  availableValues = NULL;\n  decisionTree = NULL;\n  char infilenameTraining[STRLEN]; /* input file name for training data */\n  char infilenameTesting[STRLEN]; /* input file name for testing data */\n  char outfilename[STRLEN]; /* output file name for printing the results */\n  int trainingShroomCount;\n  ValueP nonClassAvailableValues; /* available values minus the 0-attribute */\n  ValueP valueIterate;\n  nonClassAvailableValues = NULL;\n  valueIterate = NULL;\n\n  printf( \"This program processes data about the attributes.\\n\" );\n  \n  /* initialize filenames to dummy strings */\n  strcpy( infilenameTraining, \"none\" );\n  strcpy( infilenameTesting, \"none\" );\n  strcpy( outfilename, \"none\" );\n  /* TAKEN FROM p5.c EXAMLPE\n     process command-line arguments */\n  while( *++argv ) {             /* while there are still command-line args */\n    if ( !strcmp( *argv, \"-train\" ) )          /* set input file name */\n      strcpy( infilenameTraining, *++argv );\n    else if( !strcmp( *argv,\"-test\" ) )          /* set input file name */\n      strcpy( infilenameTesting, *++argv );\n    else if( !strcmp( *argv,\"-out\" ) )     /* set output file name */\n      strcpy( outfilename, *++argv );\n    else {  /*  error checking */\n      printf( \"\\nERROR: option %s not recognized\\n\", *argv );\n      printf( \"...exiting program\\n\\n\" );\n      exit( 0 );\n    }\n  } /* end, while there are still command-line args */\n \n  /* this is the testing data */\n  testingShroomList = readMushrooms( infilenameTesting );\n \n  /* we randomly extract some of the nodes for training data */\n  trainingShroomList = randomlyReduce( testingShroomList, (int)( 0.2 * mushroomCount( testingShroomList ) ) );\n\n  /* this is needed for the report later */\n  trainingShroomCount = mushroomCount( trainingShroomList );\n\n  availableValues = findAvailableValues( trainingShroomList );\n\n  /* remove the 0-attribute from our attributes to check for splitting on */\n  nonClassAvailableValues = cloneValues( availableValues );\n  /* fast-forward to a non-0 attribute */\n  while( nonClassAvailableValues->attribute == availableValues->attribute ){\n    nonClassAvailableValues = nonClassAvailableValues->next;\n  }\n  /* strip out the 0s */\n  valueIterate = nonClassAvailableValues;\n  while( valueIterate->next ){\n    if( valueIterate->next->attribute == availableValues->attribute ){\n      valueIterate->next = valueIterate->next->next;\n    }\n    valueIterate = valueIterate->next;\n  }\n\n  /* seed the tree looking for the first value to classify */\n  decisionTree = createDecisionTree( availableValues->letter, availableValues->attribute, trainingShroomList, nonClassAvailableValues );\n \n // printDecisionTree( decisionTree, &availableValues->letter, outfilename );\n \n  printTestResults( availableValues->letter, availableValues->attribute, decisionTree, trainingShroomCount, testingShroomList, outfilename );\n \n  /* free the list of test mushrooms */\n  freeMushrooms( trainingShroomList );\n  freeMushrooms( testingShroomList );\n  /* note that Decision structs are freed in printDecisionTree */\n  /* free value list */\n  freeValues( availableValues );\n \n\treturn (0);\n \n}", "path": "project3FazeliRosenthal\\reformat.c", "repo_name": "clr/cos472", "stars": 1, "license": "None", "language": "c", "size": 868}
{"docstring": "/*****************************************************************************\n Function: freeNode\n Inputs:   Node\n Returns:  nothing\n Description:\n   free the memory in the Node\n   note that you have to work from the bottom up\n   --> all the frees are in the opposite order of the emallocs above\n *****************************************************************************/\n", "func_signal": "void freeNode (NodeP node)", "code": "{\n\n  int i;  /* loop counter */\n\n  /* free all the offspring, if they are there, and then the array itself */\n  for (i=0; i<DIMENSION*DIMENSION; i++) {\n    if (node->offspring[i] != NULL)\n      freeNode(node->offspring[i]);\n  }\n  free(node->offspring);\n\n  /* free the rows, and then the board itself */\n  for (i=0; i<DIMENSION; i++) {\n    free(node->board[i]);\n  }\n  free(node->board);\n\n  /* free this node */\n  free(node);\n\n}", "path": "lab4FazeliRosenthal\\minimax.c", "repo_name": "clr/cos472", "stars": 1, "license": "None", "language": "c", "size": 868}
{"docstring": "/*****************************************************************************\n main\n******************************************************************************/\n", "func_signal": "int main(int argc, char* argv[])", "code": "{\n\n  NodeP root;  /* the root of the search tree */\n\n  root = newNode(); /* make the initial blank board */\n\n  playGame(root, 'x');  /* take turns with x and o; x is first */\n\n  freeNode(root);   /* free the tree */\n\n  return(0);        /* return a value */\n\n}", "path": "lab4FazeliRosenthal\\minimax.c", "repo_name": "clr/cos472", "stars": 1, "license": "None", "language": "c", "size": 868}
{"docstring": "/*****************************************************************************\n Function: lookahead\n Inputs:   rootNode, and player\n Returns:  nothing\n Description: build the lookahead search tree\n *****************************************************************************/\n", "func_signal": "void lookahead (NodeP node, char player, int depth)", "code": "{\n\n  int i, j;      /* loop counters, for the positions of the board */\n  int childNum;  /* count how many children (same as # of blanks) */\n\n  childNum = 0;  /* initialize */\n\n  /* get the static score of this node */\n  node->staticScore = staticEvaluator(node);\n\n  /* if we haven't reached the max depth, create the offspring and recurse */\n  if (depth != 0) {\n\n    for (j=0; j<(DEPTH-depth); j++)  /* indent */\n      printf(\"  \");\n    printf(\"making offspring for player %c at level %i\\n\", player, depth);\n\n    /* make a new child node for each blank spot, \n       same as parent, but with an extra mark in that blank */\n    for (i=0; i<DIMENSION; i++) {\n      for (j=0; j<DIMENSION; j++) {\n        if (node->board[i][j] == ' ') {\n          node->offspring[childNum] = makeNodeCopy(node);\n          node->offspring[childNum]->board[i][j] = player;\n          childNum++;\n        } \n      } /* done with columns */\n    }   /* done with all rows */\n\n    /* recurse with each child\n       it'll be the opponent's turn at the next level */\n    for (i=0; i<childNum; i++) {\n      lookahead(node->offspring[i], opponent(player), depth-1);\n\n      /* here is where the score propagates up */\n      node->offspring[i]->mmScore \n        = getMinimaxScore(node->offspring[i], opponent(player));\n\n      /* print the score for this node */\n      for (j=0; j<=(DEPTH-depth); j++)  /* indent */\n        printf(\"  \");\n      printf(\"-->score of child is %i\\n\", node->offspring[i]->mmScore);\n    }\n\n  } /* end, max depth not reached */\n\n\n}", "path": "lab4FazeliRosenthal\\minimax.c", "repo_name": "clr/cos472", "stars": 1, "license": "None", "language": "c", "size": 868}
{"docstring": "/*****************************************************************/\n", "func_signal": "void Schema ()", "code": "{\n  int i;\n  double expected;\n  double perf;\n  int count;\n  static int lastcount = 1;\n  char msg[40];\n  int ok;\n  static int firstflag = 1;\n  static int firstcount = 1;\n\n  static FILE *fp;\n  int j;\n  static char *S;\n\n  Trace(\"Schema entered\");\n\n  if (firstflag) {\n    /*  initialize schema S from schemafile */\n    S = malloc((unsigned) (Length + 1));\n    if ((fp = fopen(Schemafile, \"r\")) == NULL) {\n      sprintf(msg, \"Schema: can't open %s\", Schemafile);\n      Error(msg);\n    }\n    for (i=0; i<Length; i++) {\n      fscanf(fp, \"%c\", &S[i]);\n    }\n    fclose(fp);\n    S[Length] = '\\0';\n    if ((fp = fopen(Schemafile, \"w\")) == NULL) {\n      sprintf(msg, \"Schema: can't open %s\", Schemafile);\n      Error(msg);\n    }\n    fprintf(fp, \"%s\\n\", S);\n    fprintf(fp, \" Gen  Count  Incr  Expct  \");\n    fprintf(fp, \"Schema Ave    Pop. Ave\\n\");\n\n    firstflag = 0;\n  }\n\n  /* record count and expected offspring of S in current pop */\n  expected = 0.0;\n  perf = 0.0;\n  count = 0;\n  for (i=0; i<Popsize; i++) {\n    Unpack(New[i].Gene, Bitstring, Length);\n    for (ok = 1, j = 0; ok && (j<Length); j++) {\n      ok = (S[j] == '#') || (S[j] == Bitstring[j]);\n    }\n    if (ok) {\n      count++;\n      expected += (New[i].Perf - Worst) / \n\t(Ave_current_perf - Worst);\n      perf += New[i].Perf;\n    }\n  }\n\n  if (firstcount && count) {\n    lastcount = count;\n    firstcount = 0;\n  }\n\n  fprintf(fp, \"%4d  %4d \", Gen, count);\n  fprintf(fp, \" %5.3f \", (count*1.0)/lastcount);\n  if (count) {\n    fprintf(fp, \" %5.3f \", expected/count);\n    fprintf(fp, \" %10.3e \", perf/count);\n    lastcount = count;\n  }\n  else {\n    fprintf(fp, \" %5.3f \", 0.0);\n    fprintf(fp, \" %10.3e \", 0.0);\n  }\n  fprintf(fp, \" %10.3e \", Ave_current_perf);\n  fprintf(fp, \"\\n\");\n\n  Trace(\"Schema completed\");\n\n}", "path": "lab7FazeliRosenthal\\schema.c", "repo_name": "clr/cos472", "stars": 1, "license": "None", "language": "c", "size": 868}
{"docstring": "/*****************************************************************************\n Function: makeNodeCopy\n Inputs:   a node\n Returns:  pointer to the new Node, a copy of the original board\n Description: copy the board, but leave scores and offspring 0/null\n *****************************************************************************/\n", "func_signal": "NodeP makeNodeCopy (NodeP original)", "code": "{\n  NodeP copy;   /* the copied node */\n  int i, j;     /* loop counters */\n\n  copy = newNode();   /* get a new node */\n\n  /* copy the board */\n  for (i=0; i<DIMENSION; i++) {\n    for (j=0; j<DIMENSION; j++) {   /* fill in with blanks */\n      copy->board[i][j] = original->board[i][j];\n    }\n  }\n\n  return (copy);\n\n}", "path": "lab4FazeliRosenthal\\minimax.c", "repo_name": "clr/cos472", "stars": 1, "license": "None", "language": "c", "size": 868}
{"docstring": "/*****************************************************************************\n Function: bestMove\n Inputs:   node, and player\n Returns:  integer index of the best move (offspring) to take\n Description:\n   chose the best move for the given player from among the offspring\n *****************************************************************************/\n", "func_signal": "int bestMove(NodeP node, char player)", "code": "{\n  int index, value, i, score;\n\n  /* shouldn't happen, but let's check for it anyway */\n  if (node == NULL) {\n    printf(\"error in bestMove! node is NULL!\\n\");\n    printf(\"exiting...\\n\");\n    exit(0);\n  }\n\n  /*** here you determine the best move for this player and return that index\n       (index into the offspring array) ***/\n  /* remember that x is maximizing (so find the highest score)\n     and o is minimizing (so find the lowest score) */\n  /* this is a lot like getMinimaxScore, but you're returning the move, not\n     the score */\n  value = 0;\n  index = 0;\n  score = 0;\n  i = 0;\n\n  for( i=0; i < DIMENSION*DIMENSION; i++ ){\n    if( node->offspring[ i ] != NULL ){\n      if( player == 'x' ){\n        value = node->offspring[ i ]->mmScore;\n        if( value > score ){\n          score = value;\n          index = i;\n        }\n      } else {\n        value = node->offspring[ i ]->mmScore;\n        if( value < score ){\n          score = value;\n          index = i;\n        }\n      }\n    }\n  }\n\n  return index;\n}", "path": "lab4FazeliRosenthal\\minimax.c", "repo_name": "clr/cos472", "stars": 1, "license": "None", "language": "c", "size": 868}
{"docstring": "/*****************************************************************************\n Function: openFile\n Inputs:   the file to open, the file name, mode to open the file\n Returns:  nothing\n Description: opens file in specified mode or issues error message\n *****************************************************************************/\n", "func_signal": "void openFile(FILE **fileptr, char *filename, char *mode)", "code": "{\n  *fileptr = fopen(filename,mode);       /* open the file */\n\n  if ( !(*fileptr)) {\n    printf(\"ERROR: Failed to open file: %s with mode %s.  Exiting.\\n\\n\",\n           filename, mode);\n    exit(0);\n  }\n\n}", "path": "lab4FazeliRosenthal\\minimax.c", "repo_name": "clr/cos472", "stars": 1, "license": "None", "language": "c", "size": 868}
{"docstring": "/*****************************************************************************\n Function: openFile\n Inputs:   the file to open, the file name, mode to open the file\n Returns:  nothing\n Description: opens file in specified mode or issues error message\n *****************************************************************************/\n", "func_signal": "void openFile( FILE **fileptr, char *filename, char *mode )", "code": "{\n  *fileptr = fopen( filename, mode );       /* open the file */\n \n  if ( !(*fileptr )) {\n    printf(\"ERROR: Failed to open file: %s with mode %s.  Exiting.\\n\\n\",\n\t   filename, mode);\n    exit(0);\n  }\n \n}", "path": "project3FazeliRosenthal\\reformat.c", "repo_name": "clr/cos472", "stars": 1, "license": "None", "language": "c", "size": 868}
{"docstring": "/*****************************************************************************\n Function: getMinimaxScore\n Inputs:   a board and a player\n Returns:  score of the board, using minimax\n Description: look at all the offspring of this node and the player at this\n   level... propagate the best score for this player\n\n   x should return the highest score\n   o should return the lowest score\n *****************************************************************************/\n", "func_signal": "int getMinimaxScore (NodeP node, char player)", "code": "{\n  int score;  /* the score to return */\n  int i;\n  int value;\n\n  /* shouldn't happen, but let's check for it anyway */\n  if (node == NULL) {\n    printf(\"error in getMinimaxScore! node is NULL!\\n\");\n    printf(\"exiting...\\n\");\n    exit(0);\n  }\n\n  /* if there are no offspring, mmScore is staticScore */\n  else if (node->offspring[0] == NULL) {\n    score = node->staticScore;\n    return(score);\n  }\n\n  if( player == 'x' ){\n    score = 1000;\n  } else {\n    score = -1000;\n  }\n  value = 0;\n  i = 0;\n  for( i=0; i < DIMENSION*DIMENSION; i++ ){\n    if( node->offspring[ i ] != NULL ){\n      if( player == 'x' ){\n        value = getMinimaxScore( node->offspring[ i ], 'y' );\n        if( value < score ){\n          score = node->offspring[ i ]->mmScore;\n        }\n      } else {\n        value = getMinimaxScore( node->offspring[ i ], 'x' );\n        if( value > score ){\n          score = node->offspring[ i ]->mmScore;\n        }\n      }\n    }\n  }\n\n\n/*  score = node->offspring[0]->mmScore;  / * take the first score for now */\n\n  /*** here, you return the correct minimax score ***/\n  /* remember that x is maximizing (so find the highest score)\n     and o is minimizing (so find the lowest score) */\n\n  return (score);\n}", "path": "lab4FazeliRosenthal\\minimax.c", "repo_name": "clr/cos472", "stars": 1, "license": "None", "language": "c", "size": 868}
{"docstring": "/*****************************************************************************\n Function: freeMushroomss\n Inputs:   a pointer to a linked list\n Returns:  nothing\n Description:\n free the memory in the boxmashroom list note that you have to work from \n the bottom up if there were substructure to a mushroom, that would need \n to be free first\n *****************************************************************************/\n", "func_signal": "void freeMushrooms( MushroomP mushroomList )", "code": "{\n \n\tif( !mushroomList ){\n    return;\n  }\n\n  /* first, free each of the mushrooms */\n\tif( mushroomList->next ){\n    freeMushrooms( mushroomList->next );\n  }\n  free( mushroomList->attributes );\n  free( mushroomList );\n \n}", "path": "project3FazeliRosenthal\\reformat.c", "repo_name": "clr/cos472", "stars": 1, "license": "None", "language": "c", "size": 868}
{"docstring": "/*****************************************************************************\n Function: emalloc\n Inputs:   the size of the block of memory needed\n Returns:  a pointer to the block of memory\n Description: calls malloc, but checks for failure\n *****************************************************************************/\n", "func_signal": "void *emalloc(long size)", "code": "{\n  void *p = (void *) malloc(size);     /* request memory */\n \n  if (p == NULL) {            /* quit if request failed */\n    printf(\"Unable to intitialize...out of memory.\");\n    exit(0);\n  }\n \n  return p;\n \n}", "path": "project3FazeliRosenthal\\reformat1.c", "repo_name": "clr/cos472", "stars": 1, "license": "None", "language": "c", "size": 868}
{"docstring": "/*****************************************************************************\n Function: playGame\n Inputs:   node for this board, plus player (to get to this board)\n Returns:  nothing\n Description: play the game of TTT\n *****************************************************************************/\n", "func_signal": "void playGame (NodeP node, char player)", "code": "{\n\n  int bestChild;   /* which of the children to move to */\n  NodeP nextNode;  /* the node for that child */\n\n  if (!gameOver(node)) { /* if we're not yet done */\n\n    printNode(node);     /* print the board and scores */\n\n    printf(\"Next move by player %c\\n\", player);\n    \n    lookahead(node, player, DEPTH);      /* construct the lookahead tree */\n\n    bestChild = bestMove(node, player);  /* the best move for the player */\n    nextNode = node->offspring[bestChild];\n\n    /**** should free offspring of bestChild, plus all the other children */\n\n    MoveCount++;\n    playGame(nextNode, opponent(player));  /* recurse */\n  }\n\n  else {  /* game is over */\n    printf(\"Final board is: \\n\");\n    printNode(node);\n  }\n\n}", "path": "lab4FazeliRosenthal\\minimax.c", "repo_name": "clr/cos472", "stars": 1, "license": "None", "language": "c", "size": 868}
{"docstring": "/*****************************************************************************\n Function: freeMushroomss\n Inputs:   a pointer to a linked list\n Returns:  nothing\n Description:\n free the memory in the boxmashroom list note that you have to work from \n the bottom up if there were substructure to a mushroom, that would need \n to be free first\n *****************************************************************************/\n", "func_signal": "void freeMushrooms( MushroomP mushroomList )", "code": "{\n \n\tMushroomP head = mushroomList->next;\n\tMushroomP temp;\n \n\tint i; // loop  counter\n \n\t/* first, free each of the mushrooms */\n\twhile (head != NULL) {\n\t\ttemp = head->next;\n\t\tfree(head->attributes);\n\t\tfree(head);\n\t\thead = temp;\n\t}\n \n\t/* now, you can free the head pointer */\n\tfree(mushroomList->attributes);\n\tfree(mushroomList);\n \n}", "path": "project3FazeliRosenthal\\reformat1.c", "repo_name": "clr/cos472", "stars": 1, "license": "None", "language": "c", "size": 868}
{"docstring": "/* Initialize screen */\n", "func_signal": "void io_init ()", "code": "{\n   initscr ();\n   start_color ();\n   curs_set (CURSOR_INVISIBLE);\n   out_attr = A_NORMAL;\n   out_color = COLOR_WHITE;\n   noecho ();\n   /* Map colors */\n   color_map[COLOR_BLACK] = COLOR_BLACK;\n   color_map[COLOR_RED] = COLOR_RED;\n   color_map[COLOR_GREEN] = COLOR_GREEN;\n   color_map[COLOR_YELLOW] = COLOR_YELLOW;\n   color_map[COLOR_BLUE] = COLOR_BLUE;\n   color_map[COLOR_MAGENTA] = COLOR_MAGENTA;\n   color_map[COLOR_CYAN] = COLOR_CYAN;\n   color_map[COLOR_WHITE] = COLOR_WHITE;\n   /* Map attributes */\n   attr_map[ATTR_OFF] = A_NORMAL;\n   attr_map[ATTR_BOLD] = A_BOLD;\n   attr_map[ATTR_DIM] = A_DIM;\n   attr_map[ATTR_UNDERLINE] = A_UNDERLINE;\n   attr_map[ATTR_BLINK] = A_BLINK;\n   attr_map[ATTR_REVERSE] = A_REVERSE;\n   attr_map[ATTR_INVISIBLE] = A_INVIS;\n}", "path": "io.c", "repo_name": "dbb/zetris", "stars": 1, "license": "None", "language": "c", "size": 116}
{"docstring": "/* Drop the shape until it comes to rest on the bottom of the board or */\n/* on top of a resting shape */\n", "func_signal": "static int shape_drop (board_t board,shape_t *shape,int x,int *y)", "code": "{\n   int droppedlines = 0;\n   eraseshape (board,shape,x,*y);\n   while (allowed (board,shape,x,*y + 1))\n\t {\n\t\t(*y)++;\n\t\tdroppedlines++;\n\t }\n   drawshape (board,shape,x,*y);\n   return droppedlines;\n}", "path": "engine.c", "repo_name": "dbb/zetris", "stars": 1, "license": "None", "language": "c", "size": 116}
{"docstring": "/* Rotate shapes the way tetris likes it (= not mathematically correct) */\n", "func_signal": "static void fake_rotate (shape_t *shape)", "code": "{\n   switch (shape->type)\n\t {\n\t  case 0:\t/* Just rotate this one anti-clockwise and clockwise */\n\t\tif (shape->flipped) real_rotate (shape,TRUE); else real_rotate (shape,FALSE);\n\t\tshape->flipped = !shape->flipped;\n\t\tbreak;\n\t  case 1:\t/* Just rotate these two clockwise and anti-clockwise */\n\t  case 6:\n\t\tif (shape->flipped) real_rotate (shape,FALSE); else real_rotate (shape,TRUE);\n\t\tshape->flipped = !shape->flipped;\n\t\tbreak;\n\t  case 2:\t/* Rotate these three anti-clockwise */\n\t  case 4:\n\t  case 5:\n\t\treal_rotate (shape,FALSE);\n\t\tbreak;\n\t  case 3:\t/* This one is not rotated at all */\n\t\tbreak;\n\t }\n}", "path": "engine.c", "repo_name": "dbb/zetris", "stars": 1, "license": "None", "language": "c", "size": 116}
{"docstring": "/* This removes all the rows on the board that is completely filled with blocks */\n", "func_signal": "static int droplines (board_t board)", "code": "{\n   int i,x,y,ny,status,droppedlines;\n   board_t newboard;\n   /* initialize new board */\n   memset (newboard,0,sizeof (board_t));\n   for (i = 0; i < NUMCOLS; i++) newboard[i][NUMROWS - 1] = newboard[i][NUMROWS - 2] = WALL;\n   for (i = 0; i < NUMROWS; i++) newboard[0][i] = newboard[NUMCOLS - 1][i] = newboard[NUMCOLS - 2][i] = WALL;\n   /* ... */\n   ny = NUMROWS - 3;\n   droppedlines = 0;\n   for (y = NUMROWS - 3; y > 0; y--)\n\t {\n\t\tstatus = 0;\n\t\tfor (x = 1; x < NUMCOLS - 2; x++) if (board[x][y]) status++;\n\t\tif (status < NUMCOLS - 3)\n\t\t  {\n\t\t\t for (x = 1; x < NUMCOLS - 2; x++) newboard[x][ny] = board[x][y];\n\t\t\t ny--;\n\t\t  }\n\t\telse droppedlines++;\n\t }\n   memcpy (board,newboard,sizeof (board_t));\n   return droppedlines;\n}", "path": "engine.c", "repo_name": "dbb/zetris", "stars": 1, "license": "None", "language": "c", "size": 116}
{"docstring": "/* Read a character. Please note that you MUST call in_timeout() before in_getch() */\n", "func_signal": "int in_getch ()", "code": "{\n   struct timeval starttv,endtv;\n   int ch;\n   timeout (in_timeleft / 1000);\n   gettimeofday (&starttv,NULL);\n   ch = getch ();\n   gettimeofday (&endtv,NULL);\n   /* Timeout? */\n   if (ch == ERR)\n\t in_timeleft = in_timetotal;\n   /* No? Then calculate time left */\n   else\n\t {\n\t\tendtv.tv_sec -= starttv.tv_sec;\n\t\tendtv.tv_usec -= starttv.tv_usec;\n\t\tif (endtv.tv_usec < 0)\n\t\t  {\n\t\t\t endtv.tv_usec += 1000000;\n\t\t\t endtv.tv_sec--;\n\t\t  }\n\t\tin_timeleft -= endtv.tv_usec;\n\t\tif (in_timeleft <= 0) in_timeleft = in_timetotal;\n\t }\n   return ch;\n}", "path": "io.c", "repo_name": "dbb/zetris", "stars": 1, "license": "None", "language": "c", "size": 116}
{"docstring": "/*\n * Perform the given action on the specified tetris engine\n */\n", "func_signal": "void engine_move (engine_t *engine,action_t action)", "code": "{\n   switch (action)\n\t {\n\t\t/* move shape to the left if possible */\n\t  case ACTION_LEFT:\n\t\tif (shape_left (engine->board,&engine->shapes[engine->curshape],&engine->curx,engine->cury)) engine->status.moves++;\n\t\tbreak;\n\t\t/* rotate shape if possible */\n\t  case ACTION_ROTATE:\n\t\tif (shape_rotate (engine->board,&engine->shapes[engine->curshape],engine->curx,engine->cury)) engine->status.rotations++;\n\t\tbreak;\n\t\t/* move shape to the right if possible */\n\t  case ACTION_RIGHT:\n\t\tif (shape_right (engine->board,&engine->shapes[engine->curshape],&engine->curx,engine->cury)) engine->status.moves++;\n\t\tbreak;\n\t\t/* drop shape to the bottom */\n\t  case ACTION_DROP:\n\t\tengine->status.dropcount += shape_drop (engine->board,&engine->shapes[engine->curshape],engine->curx,&engine->cury);\n\t }\n}", "path": "engine.c", "repo_name": "dbb/zetris", "stars": 1, "license": "None", "language": "c", "size": 116}
{"docstring": "/* Move the shape one row down if possible */\n", "func_signal": "static bool shape_down (board_t board,shape_t *shape,int x,int *y)", "code": "{\n   bool result = FALSE;\n   eraseshape (board,shape,x,*y);\n   if (allowed (board,shape,x,*y + 1))\n\t {\n\t\t(*y)++;\n\t\tresult = TRUE;\n\t }\n   drawshape (board,shape,x,*y);\n   return result;\n}", "path": "engine.c", "repo_name": "dbb/zetris", "stars": 1, "license": "None", "language": "c", "size": 116}
{"docstring": "/*\n * Generate a random number within range\n */\n", "func_signal": "int rand_value (int range)", "code": "{\n#ifdef USE_RAND\n   return ((int) ((float) range * rand () / (RAND_MAX + 1.0)));\n#else\n   return (random () % range);\n#endif\n}", "path": "utils.c", "repo_name": "dbb/zetris", "stars": 1, "license": "None", "language": "c", "size": 116}
{"docstring": "/* This rotates a shape */\n", "func_signal": "static void real_rotate (shape_t *shape,bool clockwise)", "code": "{\n   int i,tmp;\n   if (clockwise)\n\t {\n\t\tfor (i = 0; i < NUMBLOCKS; i++)\n\t\t  {\n\t\t\t tmp = shape->block[i].x;\n\t\t\t shape->block[i].x = -shape->block[i].y;\n\t\t\t shape->block[i].y = tmp;\n\t\t  }\n\t }\n   else\n\t {\n\t\tfor (i = 0; i < NUMBLOCKS; i++)\n\t\t  {\n\t\t\t tmp = shape->block[i].x;\n\t\t\t shape->block[i].x = shape->block[i].y;\n\t\t\t shape->block[i].y = -tmp;\n\t\t  }\n\t }\n}", "path": "engine.c", "repo_name": "dbb/zetris", "stars": 1, "license": "None", "language": "c", "size": 116}
{"docstring": "/*\n * Evaluate the status of the specified tetris engine\n *\n * OUTPUT:\n *   1 = shape moved down one line\n *   0 = shape at bottom, next one released\n *  -1 = game over (board full)\n */\n", "func_signal": "int engine_evaluate (engine_t *engine)", "code": "{\n   if (shape_bottom (engine->board,&engine->shapes[engine->curshape],engine->curx,engine->cury))\n\t {\n\t\t/* increase score */\n\t\tengine->score_function (engine);\n\t\t/* update status information */\n\t\tengine->status.droppedlines += droplines (engine->board);\n\t\tengine->curx -= 5;\n\t\tengine->curx = abs (engine->curx);\n\t\tengine->status.rotations = 4 - engine->status.rotations;\n\t\tengine->status.rotations = engine->status.rotations > 0 ? 0 : engine->status.rotations;\n\t\tengine->status.efficiency += engine->status.dropcount + engine->status.rotations + (engine->curx - engine->status.moves);\n\t\tengine->status.efficiency >>= 1;\n\t\tengine->status.dropcount = engine->status.rotations = engine->status.moves = 0;\n\t\t/* intialize values */\n\t\tengine->curx = 5;\n\t\tengine->cury = 1;\n\t\tengine->curshape = engine->nextshape;\n\t\tengine->nextshape = rand_value (NUMZETRIS);\n\t\t/* initialize shapes */\n\t\tmemcpy (engine->shapes,SHAPES,sizeof (shapes_t));\n\t\t/* return games status */\n\t\treturn allowed (engine->board,&engine->shapes[engine->curshape],engine->curx,engine->cury) ? 0 : -1;\n\t }\n   shape_down (engine->board,&engine->shapes[engine->curshape],engine->curx,&engine->cury);\n   return 1;\n}", "path": "engine.c", "repo_name": "dbb/zetris", "stars": 1, "license": "None", "language": "c", "size": 116}
{"docstring": "/* Rotate the shape if possible */\n", "func_signal": "static bool shape_rotate (board_t board,shape_t *shape,int x,int y)", "code": "{\n   bool result = FALSE;\n   shape_t test;\n   eraseshape (board,shape,x,y);\n   memcpy (&test,shape,sizeof (shape_t));\n   fake_rotate (&test);\n   if (allowed (board,&test,x,y))\n\t {\n\t\tmemcpy (shape,&test,sizeof (shape_t));\n\t\tresult = TRUE;\n\t }\n   drawshape (board,shape,x,y);\n   return result;\n}", "path": "engine.c", "repo_name": "dbb/zetris", "stars": 1, "license": "None", "language": "c", "size": 116}
{"docstring": "/* Move the shape right if possible */\n", "func_signal": "static bool shape_right (board_t board,shape_t *shape,int *x,int y)", "code": "{\n   bool result = FALSE;\n   eraseshape (board,shape,*x,y);\n   if (allowed (board,shape,*x + 1,y))\n\t {\n\t\t(*x)++;\n\t\tresult = TRUE;\n\t }\n   drawshape (board,shape,*x,y);\n   return result;\n}", "path": "engine.c", "repo_name": "dbb/zetris", "stars": 1, "license": "None", "language": "c", "size": 116}
{"docstring": "/*\n * Initialize random number generator\n */\n", "func_signal": "void rand_init ()", "code": "{\n#ifdef USE_RAND\n   srand (time (NULL));\n#else\n   srandom (time (NULL));\n#endif\n}", "path": "utils.c", "repo_name": "dbb/zetris", "stars": 1, "license": "None", "language": "c", "size": 116}
{"docstring": "/* Set color */\n", "func_signal": "void out_setcolor (int fg,int bg)", "code": "{\n   out_color = (color_map[bg] << 3) + color_map[fg];\n   init_pair (out_color,color_map[fg],color_map[bg]);\n   attrset (COLOR_PAIR (out_color) | out_attr);\n}", "path": "io.c", "repo_name": "dbb/zetris", "stars": 1, "license": "None", "language": "c", "size": 116}
{"docstring": "/* Check if shape is allowed to be in this position */\n", "func_signal": "static bool allowed (board_t board,shape_t *shape,int x,int y)", "code": "{\n   int i,occupied = FALSE;\n   for (i = 0; i < NUMBLOCKS; i++) if (board[x + shape->block[i].x][y + shape->block[i].y]) occupied = TRUE;\n   return (!occupied);\n}", "path": "engine.c", "repo_name": "dbb/zetris", "stars": 1, "license": "None", "language": "c", "size": 116}
{"docstring": "/* Restore original screen state */\n", "func_signal": "void io_close ()", "code": "{\n   echo ();\n   attrset (A_NORMAL);\n   clear ();\n   curs_set (CURSOR_NORMAL);\n   refresh ();\n   endwin ();\n}", "path": "io.c", "repo_name": "dbb/zetris", "stars": 1, "license": "None", "language": "c", "size": 116}
{"docstring": "/* Erase a shape from the board */\n", "func_signal": "static void eraseshape (board_t board,shape_t *shape,int x,int y)", "code": "{\n   int i;\n   for (i = 0; i < NUMBLOCKS; i++) board[x + shape->block[i].x][y + shape->block[i].y] = COLOR_BLACK;\n}", "path": "engine.c", "repo_name": "dbb/zetris", "stars": 1, "license": "None", "language": "c", "size": 116}
{"docstring": "/* Draw a shape on the board */\n", "func_signal": "static void drawshape (board_t board,shape_t *shape,int x,int y)", "code": "{\n   int i;\n   for (i = 0; i < NUMBLOCKS; i++) board[x + shape->block[i].x][y + shape->block[i].y] = shape->color;\n}", "path": "engine.c", "repo_name": "dbb/zetris", "stars": 1, "license": "None", "language": "c", "size": 116}
{"docstring": "/*\n * Convert an str to long. Returns TRUE if successful,\n * FALSE otherwise.\n */\n", "func_signal": "bool str2int (int *i,const char *str)", "code": "{\n   char *endptr;\n   *i = strtol (str,&endptr,0);\n   if (*str == '\\0' || *endptr != '\\0' || *i == LONG_MIN || *i == LONG_MAX || *i < INT_MIN || *i > INT_MAX) return FALSE;\n   return TRUE;\n}", "path": "utils.c", "repo_name": "dbb/zetris", "stars": 1, "license": "None", "language": "c", "size": 116}
{"docstring": "/* Put a string on the screen */\n", "func_signal": "void out_printf (char *format, ...)", "code": "{\n   va_list ap;\n   va_start (ap,format);\n   vwprintw (stdscr,format,ap);\n   va_end (ap);\n}", "path": "io.c", "repo_name": "dbb/zetris", "stars": 1, "license": "None", "language": "c", "size": 116}
{"docstring": "/* expand all escapes in string STR, return pointer to allocation w/ result */\n", "func_signal": "static char *\nintern_string(char *str)", "code": "{\n  char *s, *istr;\n\n  /* resulting string cannot be longer than STR */\n  s = istr = malloc(strlen(str)+1);\n\n  if (!str || !*str || *str != '\\\"') /* \" */\n    panic(\"mal-formed string constant\");\n\n  /* skip `\"' */ /* \" */\n  str++;\n\n  while (*str)\n    {\n      if (*str == '\\\\')\n        *s++ = intern_escape(str+1, &str);\n      else\n        {\n          /* A2.6 */\n          if (*str == '\\n')\n            warn(\"ANSI C forbids newline in character constant\");\n          /* A2.6 */\n          if (*str == '\"' && str[1] != '\\0')\n            panic(\"encountered `\\\"' embedded in string constant\");\n\n          if (*str != '\\\"') /* \" */\n            *s++ = *str;\n          str++;\n        }\n    }\n  *s = '\\0';\n  return istr;\n}", "path": "simplesim-3.0\\libexo\\libexo.c", "repo_name": "tapple/simplescalar", "stars": 1, "license": "None", "language": "c", "size": 6432}
{"docstring": "/* xor checksum registers */\n", "func_signal": "word_t\nmd_xor_regs(struct regs_t *regs)", "code": "{\n  int i;\n  qword_t checksum = 0;\n\n  for (i=0; i < (MD_NUM_IREGS-1); i++)\n    checksum ^= regs->regs_R[i];\n\n  for (i=0; i < (MD_NUM_FREGS-1); i++)\n    checksum ^= regs->regs_F.q[i];\n\n  checksum ^= regs->regs_C.fpcr;\n  checksum ^= regs->regs_C.uniq;\n  checksum ^= regs->regs_PC;\n  checksum ^= regs->regs_NPC;\n\n  return (word_t)((checksum >> 32) ^ checksum);\n}", "path": "simplesim-3.0\\target-alpha\\alpha.c", "repo_name": "tapple/simplescalar", "stars": 1, "license": "None", "language": "c", "size": 6432}
{"docstring": "/* compute CRC of all registers */\n", "func_signal": "word_t\nmd_crc_regs(struct regs_t *regs)", "code": "{\n  int i;\n  word_t crc_accum = 0;\n\n  for (i=0; i < MD_NUM_IREGS; i++)\n    crc_accum = crc(crc_accum, regs->regs_R[i]);\n\n  for (i=0; i < MD_NUM_FREGS; i++)\n    crc_accum = crc(crc_accum, regs->regs_F.l[i]);\n\n  crc_accum = crc(crc_accum, regs->regs_C.hi);\n  crc_accum = crc(crc_accum, regs->regs_C.lo);\n  crc_accum = crc(crc_accum, regs->regs_C.fcc);\n  crc_accum = crc(crc_accum, regs->regs_PC);\n  crc_accum = crc(crc_accum, regs->regs_NPC);\n\n  return crc_accum;\n}", "path": "simplesim-3.0\\target-pisa\\pisa.c", "repo_name": "tapple/simplescalar", "stars": 1, "license": "None", "language": "c", "size": 6432}
{"docstring": "/* chain two EXO lists together, FORE is attached on the end of AFT */\n", "func_signal": "struct exo_term_t *\nexo_chain(struct exo_term_t *fore, struct exo_term_t *aft)", "code": "{\n  struct exo_term_t *exo, *prev;\n\n  if (!fore && !aft)\n    return NULL;\n\n  if (!fore)\n    return aft;\n\n  /* find the tail of FORE */\n  for (prev=NULL,exo=fore; exo != NULL; prev=exo,exo=exo->next)\n    /* nada */;\n  assert(prev);\n\n  /* link onto the tail of FORE */\n  prev->next = aft;\n\n  return fore;\n}", "path": "simplesim-3.0\\libexo\\libexo.c", "repo_name": "tapple/simplescalar", "stars": 1, "license": "None", "language": "c", "size": 6432}
{"docstring": "/* xor checksum registers */\n", "func_signal": "word_t\nmd_xor_regs(struct regs_t *regs)", "code": "{\n  int i;\n  word_t checksum = 0;\n\n  for (i=0; i < MD_NUM_IREGS; i++)\n    checksum ^= regs->regs_R[i];\n\n  for (i=0; i < MD_NUM_FREGS; i++)\n    checksum ^= regs->regs_F.l[i];\n\n  checksum ^= regs->regs_C.hi;\n  checksum ^= regs->regs_C.lo;\n  checksum ^= regs->regs_C.fcc;\n  checksum ^= regs->regs_PC;\n  checksum ^= regs->regs_NPC;\n\n  return checksum;\n}", "path": "simplesim-3.0\\target-pisa\\pisa.c", "repo_name": "tapple/simplescalar", "stars": 1, "license": "None", "language": "c", "size": 6432}
{"docstring": "/* return the value of an character literal sequence */\n/* A2.5.2 */\n", "func_signal": "static int\nintern_char(char *s, char **next)", "code": "{\n  unsigned char value;\n\n  if (s[0] != '\\'' || s[strlen(s)-1] != '\\'')\n    panic(\"mal-formed string constant\");\n\n  if (s[1] != '\\\\')\n    {\n      value = (unsigned)s[1];\n      if (s[2] != '\\'')\n\tpanic(\"mal-formed string constant\");\n      if (next)\n\t*next = s + 2;\n    }\n  else\n    {\n      /* escaped char constant */\n      value = intern_escape(s+2, next);\n    }\n\n  /* map to a signed char value */\n  value = (signed int)((unsigned char)((unsigned char)((unsigned int)value)));\n\n  if (UCHAR_MAX < value)\n    fatal(\"character constant out of range\");\n\n  return value;\n}", "path": "simplesim-3.0\\libexo\\libexo.c", "repo_name": "tapple/simplescalar", "stars": 1, "license": "None", "language": "c", "size": 6432}
{"docstring": "/* intialize the inst decoder, this function builds the ISA decode tables */\n", "func_signal": "void\nmd_init_decoder(void)", "code": "{\n  unsigned long max_offset = 0;\n  unsigned long offset = 0;\n\n#define DEFINST(OP,MSK,NAME,OPFORM,RES,FLAGS,O1,O2,I1,I2,I3)\t\t\\\n  if ((MSK)+offset >= MD_MAX_MASK)\t\t\t\t\t\\\n    panic(\"MASK_MAX is too small, index==%d\", (MSK)+offset);\t\t\\\n  if (md_mask2op[(MSK)+offset])\t\t\t\t\t\t\\\n    fatal(\"doubly defined opcode, index==%d\", (MSK)+offset);\t\t\\\n  md_mask2op[(MSK)+offset]=(OP); max_offset=MAX(max_offset,(MSK)+offset);\n\n#define DEFLINK(OP,MSK,NAME,MASK,SHIFT)\t\t\t\t\t\\\n  if ((MSK)+offset >= MD_MAX_MASK)\t\t\t\t\t\\\n    panic(\"MASK_MAX is too small, index==%d\", (MSK)+offset);\t\t\\\n  if (md_mask2op[(MSK)+offset])\t\t\t\t\t\t\\\n    fatal(\"doubly defined opcode, index==%d\", (MSK)+offset);\t\t\\\n  md_mask2op[(MSK)+offset]=(OP); max_offset=MAX(max_offset,(MSK)+offset);\n\n#define CONNECT(OP)\t\t\t\t\t\t\t\\\n    offset = max_offset+1; md_opoffset[OP] = offset;\n\n#include \"machine.def\"\n\n  if (max_offset >= MD_MAX_MASK)\n    panic(\"MASK_MAX is too small, index==%d\", max_offset);\n}", "path": "simplesim-3.0\\machine.c", "repo_name": "tapple/simplescalar", "stars": 1, "license": "None", "language": "c", "size": 6432}
{"docstring": "/* allocate an EXO node, fill in its type */\n", "func_signal": "static struct exo_term_t *\nexo_alloc(enum exo_class_t ec)", "code": "{\n  struct exo_term_t *exo;\n\n  exo = (struct exo_term_t *)calloc(1, sizeof(struct exo_term_t));\n  if (!exo)\n    fatal(\"out of virtual memory\");\n  exo->next = NULL;\n  exo->ec = ec;\n\n  return exo;\n}", "path": "simplesim-3.0\\libexo\\libexo.c", "repo_name": "tapple/simplescalar", "stars": 1, "license": "None", "language": "c", "size": 6432}
{"docstring": "/* deep copy an EXO structure */\n", "func_signal": "struct exo_term_t *\nexo_deepcopy(struct exo_term_t *exo)", "code": "{\n  struct exo_term_t *new_exo;\n\n  /* NULL copy */\n  if (!exo)\n    return NULL;\n\n  new_exo = exo_copy(exo);\n  switch (new_exo->ec)\n    {\n    case ec_integer:\n    case ec_address:\n    case ec_float:\n    case ec_char:\n    case ec_token:\n      /* exo_copy() == exo_deepcopy() for these node classes */\n      break;\n\n    case ec_string:\n      /* copy the referenced string */\n      new_exo->as_string.str =\n\t(unsigned char *)mystrdup((char *)exo->as_string.str);\n      break;\n\n    case ec_list:\n      /* copy all list elements */\n      {\n\tstruct exo_term_t *elt, *new_elt, *new_list;\n\n\tnew_list = NULL;\n\tfor (elt=new_exo->as_list.head; elt != NULL; elt=elt->next)\n\t  {\n\t    new_elt = exo_deepcopy(elt);\n\t    new_list = exo_chain(new_list, new_elt);\n\t  }\n\tnew_exo->as_list.head = new_list;\n      }\n      break;\n\n    case ec_array:\n      /* copy all array elements */\n      {\n\tint i;\n\n\tfor (i=0; i<new_exo->as_array.size; i++)\n\t  {\n\t    SET_EXO_ARR(new_exo, i, exo_deepcopy(EXO_ARR(exo, i)));\n\t  }\n      }\n      break;\n\n    case ec_blob:\n      new_exo->as_blob.data = malloc(new_exo->as_array.size);\n      memcpy(new_exo->as_blob.data, exo->as_blob.data, new_exo->as_array.size);\n      break;\n\n    default:\n      panic(\"bogus EXO class\");\n    }\n\n  return new_exo;\n}", "path": "simplesim-3.0\\libexo\\libexo.c", "repo_name": "tapple/simplescalar", "stars": 1, "license": "None", "language": "c", "size": 6432}
{"docstring": "/* intialize the inst decoder, this function builds the ISA decode tables */\n", "func_signal": "void\nmd_init_decoder(void)", "code": "{\n  unsigned long max_offset = 0;\n  unsigned long offset = 0;\n\n#define DEFINST(OP,MSK,NAME,OPFORM,RES,FLAGS,O1,O2,I1,I2,I3)\t\t\\\n  if ((MSK)+offset >= MD_MAX_MASK)\t\t\t\t\t\\\n    panic(\"MASK_MAX is too small, index==%d\", (MSK)+offset);\t\t\\\n  if (md_mask2op[(MSK)+offset])\t\t\t\t\t\t\\\n    fatal(\"doubly defined opcode, index==%d\", (MSK)+offset);\t\t\\\n  md_mask2op[(MSK)+offset]=(OP); max_offset=MAX(max_offset,(MSK)+offset);\n\n#define DEFLINK(OP,MSK,NAME,MASK,SHIFT)\t\t\t\t\t\\\n  if ((MSK)+offset >= MD_MAX_MASK)\t\t\t\t\t\\\n    panic(\"MASK_MAX is too small, index==%d\", (MSK)+offset);\t\t\\\n  if (md_mask2op[(MSK)+offset])\t\t\t\t\t\t\\\n    fatal(\"doubly defined opcode, index==%d\", (MSK)+offset);\t\t\\\n  md_mask2op[(MSK)+offset]=(OP); max_offset=MAX(max_offset,(MSK)+offset);\n\n#define CONNECT(OP)\t\t\t\t\t\t\t\\\n    offset = max_offset+1; md_opoffset[OP] = offset;\n\n#include \"machine.def\"\n\n  if (max_offset >= MD_MAX_MASK)\n    panic(\"MASK_MAX is too small, index==%d\", max_offset);\n}", "path": "simplesim-3.0\\target-alpha\\alpha.c", "repo_name": "tapple/simplescalar", "stars": 1, "license": "None", "language": "c", "size": 6432}
{"docstring": "/* create a register file */\n", "func_signal": "struct regs_t *\nregs_create(void)", "code": "{\n  struct regs_t *regs;\n\n  regs = calloc(1, sizeof(struct regs_t));\n  if (!regs)\n    fatal(\"out of virtual memory\");\n\n  return regs;\n}", "path": "simplesim-3.0\\regs.c", "repo_name": "tapple/simplescalar", "stars": 1, "license": "None", "language": "c", "size": 6432}
{"docstring": "/* print integer REG(S) to STREAM */\n", "func_signal": "void\nmd_print_ireg(md_gpr_t regs, int reg, FILE *stream)", "code": "{\n  myfprintf(stream, \"%4s: %16ld/0x%012lx\",\n\t    md_reg_name(rt_gpr, reg), regs[reg], regs[reg]);\n}", "path": "simplesim-3.0\\machine.c", "repo_name": "tapple/simplescalar", "stars": 1, "license": "None", "language": "c", "size": 6432}
{"docstring": "/* print integer REG(S) to STREAM */\n", "func_signal": "void\nmd_print_ireg(md_gpr_t regs, int reg, FILE *stream)", "code": "{\n  fprintf(stream, \"%4s: %12d/0x%08x\",\n\t  md_reg_name(rt_gpr, reg), regs[reg], regs[reg]);\n}", "path": "simplesim-3.0\\target-pisa\\pisa.c", "repo_name": "tapple/simplescalar", "stars": 1, "license": "None", "language": "c", "size": 6432}
{"docstring": "/* print integer REG(S) to STREAM */\n", "func_signal": "void\nmd_print_ireg(md_gpr_t regs, int reg, FILE *stream)", "code": "{\n  myfprintf(stream, \"%4s: %16ld/0x%012lx\",\n\t    md_reg_name(rt_gpr, reg), regs[reg], regs[reg]);\n}", "path": "simplesim-3.0\\target-alpha\\alpha.c", "repo_name": "tapple/simplescalar", "stars": 1, "license": "None", "language": "c", "size": 6432}
{"docstring": "/*\n * create a new EXO term, usage:\n *\n *\texo_new(ec_integer, (exo_integer_t)<int>);\n *\texo_new(ec_address, (exo_integer_t)<int>);\n *\texo_new(ec_float, (exo_float_t)<float>);\n *\texo_new(ec_char, (int)<char>);\n *      exo_new(ec_string, \"<string>\");\n *      exo_new(ec_list, <list_ent>..., NULL);\n *      exo_new(ec_array, <size>, <array_ent>..., NULL);\n *\texo_new(ec_token, \"<token>\"); \n*/\n", "func_signal": "struct exo_term_t *\nexo_new(enum exo_class_t ec, ...)", "code": "{\n  struct exo_term_t *exo;\n  va_list v;\n  va_start(v, ec);\n\n  exo = exo_alloc(ec);\n  switch (ec)\n    {\n    case ec_integer:\n      exo->as_integer.val = va_arg(v, exo_integer_t);\n      break;\n\n    case ec_address:\n      exo->as_address.val = va_arg(v, exo_address_t);\n      break;\n\n    case ec_float:\n      exo->as_float.val = va_arg(v, exo_float_t);\n      break;\n\n    case ec_char:\n      exo->as_char.val = va_arg(v, int);\n      break;\n\n    case ec_string:\n      {\n\tchar *str;\n\n\tstr = va_arg(v, char *);\n\texo->as_string.str = (unsigned char *)mystrdup(str);\n      }\n      break;\n\n    case ec_list:\n      {\n\tstruct exo_term_t *ent;\n\n\texo->as_list.head = NULL;\n\tdo {\n\t  ent = va_arg(v, struct exo_term_t *);\n\t  exo->as_list.head = exo_chain(exo->as_list.head, ent);\n\t} while (ent != NULL);\n      }\n      break;\n\n    case ec_array:\n      {\n\tint i;\n\tstruct exo_term_t *ent;\n\n\texo->as_array.size = va_arg(v, int);\n\texo->as_array.array = (struct exo_term_t **)\n\t  calloc(exo->as_array.size, sizeof(struct exo_term_t *));\n\tif (!exo->as_array.array)\n\t  fatal(\"out of virtual memory\");\n\ti = 0;\n\tdo {\n\t  ent = va_arg(v, struct exo_term_t *);\n\t  if (ent != NULL)\n\t    {\n\t      if (i == exo->as_array.size)\n\t\tfatal(\"array constructor overflow\");\n\t      SET_EXO_ARR(exo, i, ent);\n\t    }\n\t  i++;\n\t} while (ent != NULL);\n      }\n      break;\n\n    case ec_token:\n      {\n\tchar *str;\n\n\tstr = va_arg(v, char *);\n\texo->as_token.ent = exo_intern(str);\n      }\n      break;\n\n    case ec_blob:\n      {\n\tunsigned size;\n\tunsigned char *data;\n\n\tsize = va_arg(v, unsigned);\n\tdata = va_arg(v, unsigned char *);\n\n\texo->as_blob.size = size;\n\texo->as_blob.data = malloc(size);\n\tif (data != NULL)\n\t  memcpy(exo->as_blob.data, data, size);\n\telse\n\t  memset(exo->as_blob.data, 0, size);\n      }\n      break;\n\n    case ec_null:\n      break;\n\n    default:\n      panic(\"bogus EXO class\");\n    }\n\n  va_end(v);\n  return exo;\n}", "path": "simplesim-3.0\\libexo\\libexo.c", "repo_name": "tapple/simplescalar", "stars": 1, "license": "None", "language": "c", "size": 6432}
{"docstring": "/* returns a register name string */\n", "func_signal": "char *\nmd_reg_name(enum md_reg_type rt, int reg)", "code": "{\n  int i;\n\n  for (i=0; md_reg_names[i].str != NULL; i++)\n    {\n      if (md_reg_names[i].file == rt && md_reg_names[i].reg == reg)\n\treturn md_reg_names[i].str;\n    }\n\n  /* no found... */\n  return NULL;\n}", "path": "simplesim-3.0\\target-pisa\\pisa.c", "repo_name": "tapple/simplescalar", "stars": 1, "license": "None", "language": "c", "size": 6432}
{"docstring": "/* xor checksum registers */\n", "func_signal": "word_t\nmd_xor_regs(struct regs_t *regs)", "code": "{\n  int i;\n  qword_t checksum = 0;\n\n  for (i=0; i < (MD_NUM_IREGS-1); i++)\n    checksum ^= regs->regs_R[i];\n\n  for (i=0; i < (MD_NUM_FREGS-1); i++)\n    checksum ^= regs->regs_F.q[i];\n\n  checksum ^= regs->regs_C.fpcr;\n  checksum ^= regs->regs_C.uniq;\n  checksum ^= regs->regs_PC;\n  checksum ^= regs->regs_NPC;\n\n  return (word_t)((checksum >> 32) ^ checksum);\n}", "path": "simplesim-3.0\\machine.c", "repo_name": "tapple/simplescalar", "stars": 1, "license": "None", "language": "c", "size": 6432}
{"docstring": "/* probe host (simulator) byte endian format */\n", "func_signal": "enum endian_t\nendian_host_byte_order(void)", "code": "{\n  int i = 1, *p;\n\n  p = &i;\n  if (*((char *)p) == 1)\n    return endian_little;\n  else if (*((char *)p) == 0)\n    return endian_big;\n  else\n    return endian_unknown;\n}", "path": "simplesim-3.0\\endian.c", "repo_name": "tapple/simplescalar", "stars": 1, "license": "None", "language": "c", "size": 6432}
{"docstring": "/* print floating point REGS to STREAM */\n", "func_signal": "void\nmd_print_fpreg(md_fpr_t regs, int reg, FILE *stream)", "code": "{\n  fprintf(stream, \"%4s: %12d/0x%08x/%f\",\n\t  md_reg_name(rt_fpr, reg), regs.l[reg], regs.l[reg], regs.f[reg]);\n  if (/* even? */!(reg & 1))\n    {\n      fprintf(stream, \" (%4s as double: %f)\",\n\t      md_reg_name(rt_dpr, reg/2), regs.d[reg/2]);\n    }\n}", "path": "simplesim-3.0\\target-pisa\\pisa.c", "repo_name": "tapple/simplescalar", "stars": 1, "license": "None", "language": "c", "size": 6432}
{"docstring": "/* hash a string */\n", "func_signal": "static unsigned long\nhash_str(char *s)", "code": "{\n  unsigned h = 0;\n  while (*s)\n    h = (h << 1) + *s++;\n  return (h % TOKEN_HASH_SIZE);\n}", "path": "simplesim-3.0\\libexo\\libexo.c", "repo_name": "tapple/simplescalar", "stars": 1, "license": "None", "language": "c", "size": 6432}
{"docstring": "/**\n * notify_notification_set_geometry_hints:\n * @notification: The notification.\n * @screen: The #GdkScreen the notification should appear on.\n * @x: The X coordinate to point to.\n * @y: The Y coordinate to point to.\n *\n * Sets the geometry hints on the notification. This sets the screen\n * the notification should appear on and the X, Y coordinates it should\n * point to, if the particular notification supports X, Y hints.\n *\n * Since: 0.4.1\n */\n", "func_signal": "void\nnotify_notification_set_geometry_hints(NotifyNotification *notification,\n\t\t\t\t\t\t\t\t\t   GdkScreen *screen,\n\t\t\t\t\t\t\t\t\t   gint x,\n\t\t\t\t\t\t\t\t\t   gint y)", "code": "{\n\tchar *display_name;\n\n\tg_return_if_fail(notification != NULL);\n\tg_return_if_fail(NOTIFY_IS_NOTIFICATION(notification));\n\tg_return_if_fail(screen != NULL);\n\tg_return_if_fail(GDK_IS_SCREEN(screen));\n\n\tnotify_notification_set_hint_int32(notification, \"x\", x);\n\tnotify_notification_set_hint_int32(notification, \"y\", y);\n\n\tdisplay_name = gdk_screen_make_display_name(screen);\n\tnotify_notification_set_hint_string(notification, \"xdisplay\", display_name);\n\tg_free(display_name);\n}", "path": "libnotify\\notification.c", "repo_name": "CaJIbePu/libnotify", "stars": 0, "license": "lgpl-2.1", "language": "c", "size": 60}
{"docstring": "/**\n * notify_notification_clear_hints:\n * @notification: The notification.\n *\n * Clears all hints from the notification.\n */\n", "func_signal": "void\nnotify_notification_clear_hints(NotifyNotification *notification)", "code": "{\n\tg_return_if_fail(notification != NULL);\n\tg_return_if_fail(NOTIFY_IS_NOTIFICATION(notification));\n\n\tg_hash_table_foreach_remove(notification->priv->hints,\n\t\t\t\t\t\t\t\t(GHRFunc)_remove_all, NULL);\n}", "path": "libnotify\\notification.c", "repo_name": "CaJIbePu/libnotify", "stars": 0, "license": "lgpl-2.1", "language": "c", "size": 60}
{"docstring": "/**\n * notify_notification_add_action:\n * @notification: The notification.\n * @action: The action ID.\n * @label: The human-readable action label.\n * @callback: The action's callback function.\n * @user_data: Optional custom data to pass to @callback.\n * @free_func: An optional function to free @user_data when the notification\n *             is destroyed.\n *\n * Adds an action to a notification. When the action is invoked, the\n * specified callback function will be called, along with the value passed\n * to @user_data.\n */\n", "func_signal": "void\nnotify_notification_add_action(NotifyNotification *notification,\n\t\t\t\t\t\t\t   const char *action,\n\t\t\t\t\t\t\t   const char *label,\n\t\t\t\t\t\t\t   NotifyActionCallback callback,\n\t\t\t\t\t\t\t   gpointer user_data, GFreeFunc free_func)", "code": "{\n\tNotifyNotificationPrivate *priv;\n\tCallbackPair *pair;\n\n\tg_return_if_fail(notification != NULL);\n\tg_return_if_fail(NOTIFY_IS_NOTIFICATION(notification));\n\tg_return_if_fail(action != NULL && *action != '\\0');\n\tg_return_if_fail(label != NULL && *label != '\\0');\n\tg_return_if_fail(callback != NULL);\n\n\tpriv = notification->priv;\n\n\tpriv->actions = g_slist_append(priv->actions, g_strdup(action));\n\tpriv->actions = g_slist_append(priv->actions, g_strdup(label));\n\n\tpair = g_new0(CallbackPair, 1);\n\tpair->cb = callback;\n\tpair->user_data = user_data;\n\tpair->free_func = free_func;\n\tg_hash_table_insert(priv->action_map, g_strdup(action), pair);\n\n\tif (notification->priv->has_nondefault_actions &&\n\t\tg_ascii_strcasecmp(action, \"default\"))\n\t{\n\t\tnotification->priv->has_nondefault_actions = TRUE;\n\t}\n}", "path": "libnotify\\notification.c", "repo_name": "CaJIbePu/libnotify", "stars": 0, "license": "lgpl-2.1", "language": "c", "size": 60}
{"docstring": "/**\n * notify_notification_set_hint_byte_array:\n * @notification: The notification.\n * @key: The hint.\n * @value: The hint's value.\n * @len: The length of the byte array.\n *\n * Sets a hint with a byte array value. The length of @value must be passed\n * as @len.\n */\n", "func_signal": "void\nnotify_notification_set_hint_byte_array(NotifyNotification *notification,\n\t\t\t\t\t\t\t\t\t\tconst gchar *key,\n\t\t\t\t\t\t\t\t\t\tconst guchar *value, gsize len)", "code": "{\n\tGValue *hint_value;\n\tGArray *byte_array;\n\n\tg_return_if_fail(notification != NULL);\n\tg_return_if_fail(NOTIFY_IS_NOTIFICATION(notification));\n\tg_return_if_fail(key != NULL && *key != '\\0');\n\tg_return_if_fail(value != NULL);\n\tg_return_if_fail(len > 0);\n\n\tbyte_array = g_array_sized_new(FALSE, FALSE, sizeof(guchar), len);\n\tbyte_array = g_array_append_vals(byte_array, value, len);\n\n\thint_value = g_new0(GValue, 1);\n\tg_value_init(hint_value, dbus_g_type_get_collection(\"GArray\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tG_TYPE_UCHAR));\n\tg_value_set_boxed_take_ownership(hint_value, byte_array);\n\n\tg_hash_table_insert(notification->priv->hints,\n\t\t\t\t\t\tg_strdup(key), hint_value);\n}", "path": "libnotify\\notification.c", "repo_name": "CaJIbePu/libnotify", "stars": 0, "license": "lgpl-2.1", "language": "c", "size": 60}
{"docstring": "/**\n * notify_notification_set_urgency:\n * @notification: The notification.\n * @urgency: The urgency level.\n *\n * Sets the urgency level of this notification.\n *\n * See: #NotifyUrgency\n */\n", "func_signal": "void\nnotify_notification_set_urgency(NotifyNotification *notification,\n\t\t\t\t\t\t\t\tNotifyUrgency urgency)", "code": "{\n\tg_return_if_fail(notification != NULL);\n\tg_return_if_fail(NOTIFY_IS_NOTIFICATION(notification));\n\n\tnotify_notification_set_hint_byte(notification, \"urgency\", (guchar)urgency);\n}", "path": "libnotify\\notification.c", "repo_name": "CaJIbePu/libnotify", "stars": 0, "license": "lgpl-2.1", "language": "c", "size": 60}
{"docstring": "/**\n * notify_notification_set_hint_byte:\n * @notification: The notification.\n * @key: The hint.\n * @value: The hint's value.\n *\n * Sets a hint with a byte value.\n */\n", "func_signal": "void\nnotify_notification_set_hint_byte(NotifyNotification *notification,\n\t\t\t\t\t\t\t\t  const gchar *key, guchar value)", "code": "{\n\tGValue *hint_value;\n\n\tg_return_if_fail(notification != NULL);\n\tg_return_if_fail(NOTIFY_IS_NOTIFICATION(notification));\n\tg_return_if_fail(key != NULL && *key != '\\0');\n\n\thint_value = g_new0(GValue, 1);\n\tg_value_init(hint_value, G_TYPE_UCHAR);\n\tg_value_set_uchar(hint_value, value);\n\n\tg_hash_table_insert(notification->priv->hints, g_strdup(key), hint_value);\n}", "path": "libnotify\\notification.c", "repo_name": "CaJIbePu/libnotify", "stars": 0, "license": "lgpl-2.1", "language": "c", "size": 60}
{"docstring": "/**\n * notify_notification_show:\n * @notification: The notification.\n * @error: The returned error information.\n *\n * Tells the notification server to display the notification on the screen.\n *\n * Returns: %TRUE if successful. On error, this will return %FALSE and set\n *          @error.\n */\n", "func_signal": "gboolean\nnotify_notification_show(NotifyNotification *notification, GError **error)", "code": "{\n\tNotifyNotificationPrivate *priv;\n\tGError *tmp_error = NULL;\n\tgchar **action_array;\n\tDBusGProxy *proxy;\n\n\tg_return_val_if_fail(notification != NULL, FALSE);\n\tg_return_val_if_fail(NOTIFY_IS_NOTIFICATION(notification), FALSE);\n\tg_return_val_if_fail(error == NULL || *error == NULL, FALSE);\n\n\tpriv = notification->priv;\n\tproxy = _notify_get_g_proxy();\n\n\tif (!priv->signals_registered)\n\t{\n\t\tdbus_g_proxy_connect_signal(proxy, \"NotificationClosed\",\n\t\t\t\t\t\t\t\t\tG_CALLBACK(_close_signal_handler),\n\t\t\t\t\t\t\t\t\tnotification, NULL);\n\n\t\tdbus_g_proxy_connect_signal(proxy, \"ActionInvoked\",\n\t\t\t\t\t\t\t\t\tG_CALLBACK(_action_signal_handler),\n\t\t\t\t\t\t\t\t\tnotification, NULL);\n\n\t\tpriv->signals_registered = TRUE;\n\t}\n\n\t/* If attached to a widget or status icon, modify x and y in hints */\n\t_notify_notification_update_applet_hints(notification);\n\n\taction_array = _gslist_to_string_array(priv->actions);\n\n\t/* TODO: make this nonblocking */\n\tdbus_g_proxy_call(proxy, \"Notify\", &tmp_error,\n\t\t\t\t\t  G_TYPE_STRING, notify_get_app_name(),\n\t\t\t\t\t  G_TYPE_UINT, priv->id,\n\t\t\t\t\t  G_TYPE_STRING, priv->icon_name,\n\t\t\t\t\t  G_TYPE_STRING, priv->summary,\n\t\t\t\t\t  G_TYPE_STRING, priv->body,\n\t\t\t\t\t  G_TYPE_STRV, action_array,\n\t\t\t\t\t  dbus_g_type_get_map(\"GHashTable\", G_TYPE_STRING,\n\t\t\t\t\t\t\t\t\t\t  G_TYPE_VALUE), priv->hints,\n\t\t\t\t\t  G_TYPE_INT, priv->timeout,\n\t\t\t\t\t  G_TYPE_INVALID,\n\t\t\t\t\t  G_TYPE_UINT, &priv->id,\n\t\t\t\t\t  G_TYPE_INVALID);\n\n\t/* Don't free the elements because they are owned by priv->actions */\n\tg_free(action_array);\n\n\tif (tmp_error != NULL)\n\t{\n\t\tg_propagate_error(error, tmp_error);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}", "path": "libnotify\\notification.c", "repo_name": "CaJIbePu/libnotify", "stars": 0, "license": "lgpl-2.1", "language": "c", "size": 60}
{"docstring": "/**\n * notify_notification_set_hint_double:\n * @notification: The notification.\n * @key: The hint.\n * @value: The hint's value.\n *\n * Sets a hint with a double value.\n */\n", "func_signal": "void\nnotify_notification_set_hint_double(NotifyNotification *notification,\n\t\t\t\t\t\t\t\t\tconst gchar *key, gdouble value)", "code": "{\n\tGValue *hint_value;\n\n\tg_return_if_fail(notification != NULL);\n\tg_return_if_fail(NOTIFY_IS_NOTIFICATION(notification));\n\tg_return_if_fail(key != NULL && *key != '\\0');\n\n\thint_value = g_new0(GValue, 1);\n\tg_value_init(hint_value, G_TYPE_FLOAT);\n\tg_value_set_float(hint_value, value);\n\tg_hash_table_insert(notification->priv->hints,\n\t\t\t\t\t\tg_strdup(key), hint_value);\n}", "path": "libnotify\\notification.c", "repo_name": "CaJIbePu/libnotify", "stars": 0, "license": "lgpl-2.1", "language": "c", "size": 60}
{"docstring": "/**\n * notify_notification_clear_actions:\n * @notification: The notification.\n *\n * Clears all actions from the notification.\n */\n", "func_signal": "void\nnotify_notification_clear_actions(NotifyNotification *notification)", "code": "{\n\tg_return_if_fail(notification != NULL);\n\tg_return_if_fail(NOTIFY_IS_NOTIFICATION(notification));\n\n\tg_hash_table_foreach_remove(notification->priv->action_map,\n\t\t\t\t\t\t\t\t(GHRFunc)_remove_all, NULL);\n\n\tif (notification->priv->actions != NULL)\n\t{\n\t\tg_slist_foreach(notification->priv->actions, (GFunc)g_free, NULL);\n\t\tg_slist_free(notification->priv->actions);\n\t}\n\n\tnotification->priv->actions = NULL;\n\tnotification->priv->has_nondefault_actions = FALSE;\n}", "path": "libnotify\\notification.c", "repo_name": "CaJIbePu/libnotify", "stars": 0, "license": "lgpl-2.1", "language": "c", "size": 60}
{"docstring": "/**\n * notify_notification_attach_to_widget:\n * @notification: The notification.\n * @attach: The widget to attach to, or %NULL.\n *\n * Attaches the notification to a widget. This will set hints on the\n * notification requesting that the notification point to the widget's\n * location. If @attach is %NULL, the widget will be unset.\n */\n", "func_signal": "void\nnotify_notification_attach_to_widget(NotifyNotification *notification,\n\t\t\t\t\t\t\t\t\t GtkWidget *attach)", "code": "{\n\tg_return_if_fail(NOTIFY_IS_NOTIFICATION(notification));\n\n\tif (notification->priv->attached_widget == attach)\n\t\treturn;\n\n\tif (notification->priv->attached_widget != NULL)\n\t\tg_object_unref(notification->priv->attached_widget);\n\n\tnotification->priv->attached_widget =\n\t\t(attach != NULL ? g_object_ref(attach) : NULL);\n\n\tg_object_notify(G_OBJECT(notification), \"attach-widget\");\n}", "path": "libnotify\\notification.c", "repo_name": "CaJIbePu/libnotify", "stars": 0, "license": "lgpl-2.1", "language": "c", "size": 60}
{"docstring": "/**\n * notify_notification_set_hint_int32:\n * @notification: The notification.\n * @key: The hint.\n * @value: The hint's value.\n *\n * Sets a hint with a 32-bit integer value.\n */\n", "func_signal": "void\nnotify_notification_set_hint_int32(NotifyNotification *notification,\n\t\t\t\t\t\t\t\t   const gchar *key, gint value)", "code": "{\n\tGValue *hint_value;\n\n\tg_return_if_fail(notification != NULL);\n\tg_return_if_fail(NOTIFY_IS_NOTIFICATION(notification));\n\tg_return_if_fail(key != NULL && *key != '\\0');\n\n\thint_value = g_new0(GValue, 1);\n\tg_value_init(hint_value, G_TYPE_INT);\n\tg_value_set_int(hint_value, value);\n\tg_hash_table_insert(notification->priv->hints,\n\t\t\t\t\t\tg_strdup(key), hint_value);\n}", "path": "libnotify\\notification.c", "repo_name": "CaJIbePu/libnotify", "stars": 0, "license": "lgpl-2.1", "language": "c", "size": 60}
{"docstring": "/**\n * notify_notification_set_image_from_pixbuf:\n * @notification: The notification.\n * @pixbuf: The image.\n *\n * Sets the image in the notification from a #GdkPixbuf.\n *\n * This will only work when libnotify is compiled against D-BUS 0.60 or\n * higher.\n */\n", "func_signal": "void\nnotify_notification_set_image_from_pixbuf(NotifyNotification *notification,\n\t\t\t\t\t\t\t\t\t\t  GdkPixbuf *pixbuf)", "code": "{\n#if CHECK_DBUS_VERSION(0, 60)\n\tgint width;\n\tgint height;\n\tgint rowstride;\n\tgint bits_per_sample;\n\tgint n_channels;\n\tguchar *image;\n\tgsize image_len;\n\tGValueArray *image_struct;\n\tGValue *value;\n#endif\n\n\tg_return_if_fail(notification != NULL);\n\tg_return_if_fail(NOTIFY_IS_NOTIFICATION(notification));\n\n#if CHECK_DBUS_VERSION(0, 60)\n\twidth           = gdk_pixbuf_get_width(pixbuf);\n\theight          = gdk_pixbuf_get_height(pixbuf);\n\trowstride       = gdk_pixbuf_get_rowstride(pixbuf);\n\tn_channels      = gdk_pixbuf_get_n_channels(pixbuf);\n\tbits_per_sample = gdk_pixbuf_get_bits_per_sample(pixbuf);\n\timage_len       = (height - 1) * rowstride + width *\n\t                  ((n_channels * bits_per_sample + 7) / 8);\n\n\timage = gdk_pixbuf_get_pixels(pixbuf);\n\n\timage_struct = g_value_array_new(1);\n\n\t_gvalue_array_append_int(image_struct, width);\n\t_gvalue_array_append_int(image_struct, height);\n\t_gvalue_array_append_int(image_struct, rowstride);\n\t_gvalue_array_append_bool(image_struct, gdk_pixbuf_get_has_alpha(pixbuf));\n\t_gvalue_array_append_int(image_struct, bits_per_sample);\n\t_gvalue_array_append_int(image_struct, n_channels);\n\t_gvalue_array_append_byte_array(image_struct, image, image_len);\n\n\tvalue = g_new0(GValue, 1);\n\tg_value_init(value, G_TYPE_VALUE_ARRAY);\n\tg_value_set_boxed_take_ownership(value, image_struct);\n\n\tchar *hint_name = _notify_check_spec_version(0, 10)\n\t                  ? \"image_data\" : \"icon_data\";\n\tg_hash_table_insert(notification->priv->hints,\n\t\t\t\t\t\tg_strdup(hint_name), value);\n#else /* D-BUS < 0.60 */\n\tg_warning(\"Raw images and pixbufs require D-BUS >= 0.60\");\n#endif\n}", "path": "libnotify\\notification.c", "repo_name": "CaJIbePu/libnotify", "stars": 0, "license": "lgpl-2.1", "language": "c", "size": 60}
{"docstring": "/**\n * notify_notification_new_with_status_icon:\n * @summary: The required summary text.\n * @body: The optional body text.\n * @icon: The optional icon theme icon name or filename.\n * @status_icon: The required #GtkStatusIcon.\n *\n * Creates a new #NotifyNotification and attaches to a #GtkStatusIcon.\n * The summary text and @status_icon is required, but all other parameters\n * are optional.\n *\n * Returns: The new #NotifyNotification.\n *\n * Since: 0.4.1\n */\n", "func_signal": "NotifyNotification *\nnotify_notification_new_with_status_icon(const gchar *summary,\n                                         const gchar *message,\n                                         const gchar *icon,\n                                         GtkStatusIcon *status_icon)", "code": "{\n\tg_return_val_if_fail(status_icon != NULL, NULL);\n\tg_return_val_if_fail(GTK_IS_STATUS_ICON(status_icon), NULL);\n\n\treturn g_object_new(NOTIFY_TYPE_NOTIFICATION,\n\t\t\t\t\t\t\"summary\", summary,\n\t\t\t\t\t\t\"body\", message,\n\t\t\t\t\t\t\"icon-name\",  icon,\n\t\t\t\t\t\t\"status-icon\", status_icon,\n\t\t\t\t\t\tNULL);\n}", "path": "libnotify\\notification.c", "repo_name": "CaJIbePu/libnotify", "stars": 0, "license": "lgpl-2.1", "language": "c", "size": 60}
{"docstring": "/*\n * This is left here just incase we revisit autoupdating\n * One thought would be to check for updates every time the icon\n * is redrawn but we still have to deal with the race conditions\n * that could occure between the server and the client so we will\n * leave this alone for now.\n */\n", "func_signal": "static gboolean\n_idle_check_updates(void *user_data)", "code": "{\n\tNotifyNotification *n = NOTIFY_NOTIFICATION(user_data);\n\tNotifyNotificationPrivate *priv = n->priv;\n\n\tif (priv->is_visible)\n\t{\n\t\tpriv->updates_pending = _notify_notification_update_applet_hints(n);\n\n\t\tif (priv->updates_pending)\n\t\t{\n\t\t\t/* Try again if we fail on next idle */\n\t\t\tpriv->updates_pending = !notify_notification_show(n, NULL);\n\t\t}\n\t}\n\telse\n\t{\n\t\tpriv->updates_pending = FALSE;\n\t}\n\n\treturn TRUE;\n}", "path": "libnotify\\notification.c", "repo_name": "CaJIbePu/libnotify", "stars": 0, "license": "lgpl-2.1", "language": "c", "size": 60}
{"docstring": "/**\n * notify_notification_set_hint_string:\n * @notification: The notification.\n * @key: The hint.\n * @value: The hint's value.\n *\n * Sets a hint with a string value.\n */\n", "func_signal": "void\nnotify_notification_set_hint_string(NotifyNotification *notification,\n\t\t\t\t\t\t\t\t\tconst gchar *key, const gchar *value)", "code": "{\n\tGValue *hint_value;\n\n\tg_return_if_fail(notification != NULL);\n\tg_return_if_fail(NOTIFY_IS_NOTIFICATION(notification));\n\tg_return_if_fail(key != NULL && *key != '\\0');\n\n\thint_value = g_new0(GValue, 1);\n\tg_value_init(hint_value, G_TYPE_STRING);\n\tg_value_set_string(hint_value, value);\n\tg_hash_table_insert(notification->priv->hints,\n\t\t\t\t\t\tg_strdup(key), hint_value);\n}", "path": "libnotify\\notification.c", "repo_name": "CaJIbePu/libnotify", "stars": 0, "license": "lgpl-2.1", "language": "c", "size": 60}
{"docstring": "/**\n * notify_notification_update:\n * @notification: The notification to update.\n * @summary: The new required summary text.\n * @body: The optional body text.\n * @icon: The optional icon theme icon name or filename.\n *\n * Updates the notification text and icon. This won't send the update out\n * and display it on the screen. For that, you will need to call\n * notify_notification_show().\n *\n * Returns: %TRUE, unless an invalid parameter was passed.\n */\n", "func_signal": "gboolean\nnotify_notification_update(NotifyNotification *notification,\n\t\t\t\t\t\t   const gchar *summary, const gchar *body,\n\t\t\t\t\t\t   const gchar *icon)", "code": "{\n\tg_return_val_if_fail(notification != NULL,                 FALSE);\n\tg_return_val_if_fail(NOTIFY_IS_NOTIFICATION(notification), FALSE);\n\tg_return_val_if_fail(summary != NULL && *summary != '\\0',  FALSE);\n\n\tif (notification->priv->summary != summary)\n\t{\n\t\tg_free(notification->priv->summary);\n\t\tnotification->priv->summary = g_strdup(summary);\n\t\tg_object_notify(G_OBJECT(notification), \"summary\");\n\t}\n\n\tif (notification->priv->body != body)\n\t{\n\t\tg_free(notification->priv->body);\n\t\tnotification->priv->body =\n\t\t\t(body != NULL && *body != '\\0' ? g_strdup(body) : NULL);\n\t\tg_object_notify(G_OBJECT(notification), \"body\");\n\t}\n\n\tif (notification->priv->icon_name != icon)\n\t{\n\t\tg_free(notification->priv->icon_name);\n\t\tnotification->priv->icon_name =\n\t\t\t(icon != NULL && *icon != '\\0' ? g_strdup(icon) : NULL);\n\t\tg_object_notify(G_OBJECT(notification), \"icon-name\");\n\t}\n\n\tnotification->priv->updates_pending = TRUE;\n\n\treturn TRUE;\n}", "path": "libnotify\\notification.c", "repo_name": "CaJIbePu/libnotify", "stars": 0, "license": "lgpl-2.1", "language": "c", "size": 60}
{"docstring": "/**\n * notify_notification_set_category:\n * @notification: The notification.\n * @category: The category.\n *\n * Sets the category of this notification. This can be used by the\n * notification server to filter or display the data in a certain way.\n */\n", "func_signal": "void\nnotify_notification_set_category(NotifyNotification *notification,\n\t\t\t\t\t\t\t\t const char *category)", "code": "{\n\tg_return_if_fail(notification != NULL);\n\tg_return_if_fail(NOTIFY_IS_NOTIFICATION(notification));\n\n\tnotify_notification_set_hint_string(notification, \"category\", category);\n}", "path": "libnotify\\notification.c", "repo_name": "CaJIbePu/libnotify", "stars": 0, "license": "lgpl-2.1", "language": "c", "size": 60}
{"docstring": "/**\n * notify_notification_set_hint_uint32:\n * @notification: The notification.\n * @key: The hint.\n * @value: The hint's value.\n *\n * Sets a hint with an unsigned 32-bit integer value.\n */\n", "func_signal": "void\nnotify_notification_set_hint_uint32(NotifyNotification *notification,\n                                    const gchar *key, guint value)", "code": "{\n\tGValue *hint_value;\n\n\tg_return_if_fail(notification != NULL);\n\tg_return_if_fail(NOTIFY_IS_NOTIFICATION(notification));\n\tg_return_if_fail(key != NULL && *key != '\\0');\n\n\thint_value = g_new0(GValue, 1);\n\tg_value_init(hint_value, G_TYPE_UINT);\n\tg_value_set_uint(hint_value, value);\n\tg_hash_table_insert(notification->priv->hints,\n\t\t\t\t\t\tg_strdup(key), hint_value);\n}", "path": "libnotify\\notification.c", "repo_name": "CaJIbePu/libnotify", "stars": 0, "license": "lgpl-2.1", "language": "c", "size": 60}
{"docstring": "/**\n * notify_notification_close:\n * @notification: The notification.\n * @error: The returned error information.\n *\n * Tells the notification server to hide the notification on the screen.\n *\n * Returns: %TRUE if successful. On error, this will return %FALSE and set\n *          @error.\n */\n", "func_signal": "gboolean\nnotify_notification_close(NotifyNotification *notification,\n\t\t\t\t\t\t  GError **error)", "code": "{\n\tNotifyNotificationPrivate *priv;\n\tGError *tmp_error = NULL;\n\n\tg_return_val_if_fail(notification != NULL, FALSE);\n\tg_return_val_if_fail(NOTIFY_IS_NOTIFICATION(notification), FALSE);\n\tg_return_val_if_fail(error == NULL || *error == NULL, FALSE);\n\n\tpriv = notification->priv;\n\n\tdbus_g_proxy_call(_notify_get_g_proxy(), \"CloseNotification\", &tmp_error,\n\t\t\t\t\t  G_TYPE_UINT, priv->id, G_TYPE_INVALID,\n\t\t\t\t\t  G_TYPE_INVALID);\n\n\tif (tmp_error != NULL)\n\t{\n\t\tg_propagate_error(error, tmp_error);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}", "path": "libnotify\\notification.c", "repo_name": "CaJIbePu/libnotify", "stars": 0, "license": "lgpl-2.1", "language": "c", "size": 60}
{"docstring": "/**\n * notify_notification_new:\n * @summary: The required summary text.\n * @body: The optional body text.\n * @icon: The optional icon theme icon name or filename.\n * @attach: (allow-none): The optional widget to attach to.\n *\n * Creates a new #NotifyNotification. The summary text is required, but\n * all other parameters are optional.\n *\n * Returns: The new #NotifyNotification.\n */\n", "func_signal": "NotifyNotification *\nnotify_notification_new(const gchar *summary, const gchar *body,\n\t\t\t\t\t\tconst gchar *icon, GtkWidget *attach)", "code": "{\n\tg_return_val_if_fail(attach == NULL || GTK_IS_WIDGET(attach), NULL);\n\n\treturn g_object_new(NOTIFY_TYPE_NOTIFICATION,\n\t\t\t\t\t\t\"summary\", summary,\n\t\t\t\t\t\t\"body\", body,\n\t\t\t\t\t\t\"icon-name\",  icon,\n\t\t\t\t\t\t\"attach-widget\", attach,\n\t\t\t\t\t\tNULL);\n}", "path": "libnotify\\notification.c", "repo_name": "CaJIbePu/libnotify", "stars": 0, "license": "lgpl-2.1", "language": "c", "size": 60}
{"docstring": "/****************************************************************************\nREMARKS:\nHandles opcode 0xa1\n****************************************************************************/\n", "func_signal": "void x86emuOp_mov_AX_M_IMM(u8 X86EMU_UNUSED(op1))", "code": "{\n    u16 offset;\n\n    START_OF_INSTR();\n    offset = fetch_word_imm();\n    if (M.x86.mode & SYSMODE_PREFIX_DATA) {\n\tDECODE_PRINTF2(\"MOV\\tEAX,[%04x]\\n\", offset);\n    } else {\n\tDECODE_PRINTF2(\"MOV\\tAX,[%04x]\\n\", offset);\n    }\n    TRACE_AND_STEP();\n    if (M.x86.mode & SYSMODE_PREFIX_DATA) {\n\tM.x86.R_EAX = fetch_data_long(offset);\n    } else {\n\tM.x86.R_AX = fetch_data_word(offset);\n    }\n    DECODE_CLEAR_SEGOVR();\n    END_OF_INSTR();\n}", "path": "drivers\\bios_emulator\\x86emu\\ops.c", "repo_name": "edwinrong/u_boot_to_ship", "stars": 1, "license": "other", "language": "c", "size": 13016}
{"docstring": "/****************************************************************************\nREMARKS:\nHandles opcode 0xe0\n****************************************************************************/\n", "func_signal": "void x86emuOp_loopne(u8 X86EMU_UNUSED(op1))", "code": "{\n    s16 ip;\n\n    START_OF_INSTR();\n    DECODE_PRINTF(\"LOOPNE\\t\");\n    ip = (s8) fetch_byte_imm();\n    ip += (s16) M.x86.R_IP;\n    DECODE_PRINTF2(\"%04x\\n\", ip);\n    TRACE_AND_STEP();\n    M.x86.R_CX -= 1;\n    if (M.x86.R_CX != 0 && !ACCESS_FLAG(F_ZF))\t    /* CX != 0 and !ZF */\n\tM.x86.R_IP = ip;\n    DECODE_CLEAR_SEGOVR();\n    END_OF_INSTR();\n}", "path": "drivers\\bios_emulator\\x86emu\\ops.c", "repo_name": "edwinrong/u_boot_to_ship", "stars": 1, "license": "other", "language": "c", "size": 13016}
{"docstring": "/****************************************************************************\nREMARKS:\nHandles opcode 0xf3\n****************************************************************************/\n", "func_signal": "void x86emuOp_repe(u8 X86EMU_UNUSED(op1))", "code": "{\n    START_OF_INSTR();\n    DECODE_PRINTF(\"REPE\\n\");\n    TRACE_AND_STEP();\n    M.x86.mode |= SYSMODE_PREFIX_REPE;\n    DECODE_CLEAR_SEGOVR();\n    END_OF_INSTR();\n}", "path": "drivers\\bios_emulator\\x86emu\\ops.c", "repo_name": "edwinrong/u_boot_to_ship", "stars": 1, "license": "other", "language": "c", "size": 13016}
{"docstring": "/****************************************************************************\nREMARKS:\nHandles opcode 0xf7\n****************************************************************************/\n", "func_signal": "void x86emuOp_opcF7_word_RM(u8 X86EMU_UNUSED(op1))", "code": "{\n    int mod, rl, rh;\n    uint destoffset;\n\n    START_OF_INSTR();\n    FETCH_DECODE_MODRM(mod, rh, rl);\n    DECODE_PRINTF(opF6_names[rh]);\n    if (mod < 3) {\n\n\tif (M.x86.mode & SYSMODE_PREFIX_DATA) {\n\t    u32 destval, srcval;\n\n\t    DECODE_PRINTF(\"DWORD PTR \");\n\t    destoffset = decode_rmXX_address(mod, rl);\n\t    destval = fetch_data_long(destoffset);\n\n\t    switch (rh) {\n\t    case 0:\n\t\tDECODE_PRINTF(\",\");\n\t\tsrcval = fetch_long_imm();\n\t\tDECODE_PRINTF2(\"%x\\n\", srcval);\n\t\tTRACE_AND_STEP();\n\t\ttest_long(destval, srcval);\n\t\tbreak;\n\t    case 1:\n\t\tDECODE_PRINTF(\"ILLEGAL OP MOD=00 RH=01 OP=F7\\n\");\n\t\tHALT_SYS();\n\t\tbreak;\n\t    case 2:\n\t\tDECODE_PRINTF(\"\\n\");\n\t\tTRACE_AND_STEP();\n\t\tdestval = not_long(destval);\n\t\tstore_data_long(destoffset, destval);\n\t\tbreak;\n\t    case 3:\n\t\tDECODE_PRINTF(\"\\n\");\n\t\tTRACE_AND_STEP();\n\t\tdestval = neg_long(destval);\n\t\tstore_data_long(destoffset, destval);\n\t\tbreak;\n\t    case 4:\n\t\tDECODE_PRINTF(\"\\n\");\n\t\tTRACE_AND_STEP();\n\t\tmul_long(destval);\n\t\tbreak;\n\t    case 5:\n\t\tDECODE_PRINTF(\"\\n\");\n\t\tTRACE_AND_STEP();\n\t\timul_long(destval);\n\t\tbreak;\n\t    case 6:\n\t\tDECODE_PRINTF(\"\\n\");\n\t\tTRACE_AND_STEP();\n\t\tdiv_long(destval);\n\t\tbreak;\n\t    case 7:\n\t\tDECODE_PRINTF(\"\\n\");\n\t\tTRACE_AND_STEP();\n\t\tidiv_long(destval);\n\t\tbreak;\n\t    }\n\t} else {\n\t    u16 destval, srcval;\n\n\t    DECODE_PRINTF(\"WORD PTR \");\n\t    destoffset = decode_rmXX_address(mod, rl);\n\t    destval = fetch_data_word(destoffset);\n\n\t    switch (rh) {\n\t    case 0:\t    /* test word imm */\n\t\tDECODE_PRINTF(\",\");\n\t\tsrcval = fetch_word_imm();\n\t\tDECODE_PRINTF2(\"%x\\n\", srcval);\n\t\tTRACE_AND_STEP();\n\t\ttest_word(destval, srcval);\n\t\tbreak;\n\t    case 1:\n\t\tDECODE_PRINTF(\"ILLEGAL OP MOD=00 RH=01 OP=F7\\n\");\n\t\tHALT_SYS();\n\t\tbreak;\n\t    case 2:\n\t\tDECODE_PRINTF(\"\\n\");\n\t\tTRACE_AND_STEP();\n\t\tdestval = not_word(destval);\n\t\tstore_data_word(destoffset, destval);\n\t\tbreak;\n\t    case 3:\n\t\tDECODE_PRINTF(\"\\n\");\n\t\tTRACE_AND_STEP();\n\t\tdestval = neg_word(destval);\n\t\tstore_data_word(destoffset, destval);\n\t\tbreak;\n\t    case 4:\n\t\tDECODE_PRINTF(\"\\n\");\n\t\tTRACE_AND_STEP();\n\t\tmul_word(destval);\n\t\tbreak;\n\t    case 5:\n\t\tDECODE_PRINTF(\"\\n\");\n\t\tTRACE_AND_STEP();\n\t\timul_word(destval);\n\t\tbreak;\n\t    case 6:\n\t\tDECODE_PRINTF(\"\\n\");\n\t\tTRACE_AND_STEP();\n\t\tdiv_word(destval);\n\t\tbreak;\n\t    case 7:\n\t\tDECODE_PRINTF(\"\\n\");\n\t\tTRACE_AND_STEP();\n\t\tidiv_word(destval);\n\t\tbreak;\n\t    }\n\t}\n\n    } else {\t\t\t /* mod=11 */\n\n\tif (M.x86.mode & SYSMODE_PREFIX_DATA) {\n\t    u32 *destreg;\n\t    u32 srcval;\n\n\t    destreg = DECODE_RM_LONG_REGISTER(rl);\n\n\t    switch (rh) {\n\t    case 0:\t    /* test word imm */\n\t\tDECODE_PRINTF(\",\");\n\t\tsrcval = fetch_long_imm();\n\t\tDECODE_PRINTF2(\"%x\\n\", srcval);\n\t\tTRACE_AND_STEP();\n\t\ttest_long(*destreg, srcval);\n\t\tbreak;\n\t    case 1:\n\t\tDECODE_PRINTF(\"ILLEGAL OP MOD=00 RH=01 OP=F6\\n\");\n\t\tHALT_SYS();\n\t\tbreak;\n\t    case 2:\n\t\tDECODE_PRINTF(\"\\n\");\n\t\tTRACE_AND_STEP();\n\t\t*destreg = not_long(*destreg);\n\t\tbreak;\n\t    case 3:\n\t\tDECODE_PRINTF(\"\\n\");\n\t\tTRACE_AND_STEP();\n\t\t*destreg = neg_long(*destreg);\n\t\tbreak;\n\t    case 4:\n\t\tDECODE_PRINTF(\"\\n\");\n\t\tTRACE_AND_STEP();\n\t\tmul_long(*destreg);\t /*!!!\t*/\n\t\tbreak;\n\t    case 5:\n\t\tDECODE_PRINTF(\"\\n\");\n\t\tTRACE_AND_STEP();\n\t\timul_long(*destreg);\n\t\tbreak;\n\t    case 6:\n\t\tDECODE_PRINTF(\"\\n\");\n\t\tTRACE_AND_STEP();\n\t\tdiv_long(*destreg);\n\t\tbreak;\n\t    case 7:\n\t\tDECODE_PRINTF(\"\\n\");\n\t\tTRACE_AND_STEP();\n\t\tidiv_long(*destreg);\n\t\tbreak;\n\t    }\n\t} else {\n\t    u16 *destreg;\n\t    u16 srcval;\n\n\t    destreg = DECODE_RM_WORD_REGISTER(rl);\n\n\t    switch (rh) {\n\t    case 0:\t    /* test word imm */\n\t\tDECODE_PRINTF(\",\");\n\t\tsrcval = fetch_word_imm();\n\t\tDECODE_PRINTF2(\"%x\\n\", srcval);\n\t\tTRACE_AND_STEP();\n\t\ttest_word(*destreg, srcval);\n\t\tbreak;\n\t    case 1:\n\t\tDECODE_PRINTF(\"ILLEGAL OP MOD=00 RH=01 OP=F6\\n\");\n\t\tHALT_SYS();\n\t\tbreak;\n\t    case 2:\n\t\tDECODE_PRINTF(\"\\n\");\n\t\tTRACE_AND_STEP();\n\t\t*destreg = not_word(*destreg);\n\t\tbreak;\n\t    case 3:\n\t\tDECODE_PRINTF(\"\\n\");\n\t\tTRACE_AND_STEP();\n\t\t*destreg = neg_word(*destreg);\n\t\tbreak;\n\t    case 4:\n\t\tDECODE_PRINTF(\"\\n\");\n\t\tTRACE_AND_STEP();\n\t\tmul_word(*destreg);\t /*!!!\t*/\n\t\tbreak;\n\t    case 5:\n\t\tDECODE_PRINTF(\"\\n\");\n\t\tTRACE_AND_STEP();\n\t\timul_word(*destreg);\n\t\tbreak;\n\t    case 6:\n\t\tDECODE_PRINTF(\"\\n\");\n\t\tTRACE_AND_STEP();\n\t\tdiv_word(*destreg);\n\t\tbreak;\n\t    case 7:\n\t\tDECODE_PRINTF(\"\\n\");\n\t\tTRACE_AND_STEP();\n\t\tidiv_word(*destreg);\n\t\tbreak;\n\t    }\n\t}\n    }\n    DECODE_CLEAR_SEGOVR();\n    END_OF_INSTR();\n}", "path": "drivers\\bios_emulator\\x86emu\\ops.c", "repo_name": "edwinrong/u_boot_to_ship", "stars": 1, "license": "other", "language": "c", "size": 13016}
{"docstring": "/****************************************************************************\nREMARKS:\nHandles opcode 0x85\n****************************************************************************/\n", "func_signal": "void x86emuOp_test_word_RM_R(u8 X86EMU_UNUSED(op1))", "code": "{\n    int mod, rl, rh;\n    uint destoffset;\n\n    START_OF_INSTR();\n    DECODE_PRINTF(\"TEST\\t\");\n    FETCH_DECODE_MODRM(mod, rh, rl);\n    if (mod < 3) {\n\tdestoffset = decode_rmXX_address(mod, rl);\n\tif (M.x86.mode & SYSMODE_PREFIX_DATA) {\n\t    u32 destval;\n\t    u32 *srcreg;\n\n\t    DECODE_PRINTF(\",\");\n\t    destval = fetch_data_long(destoffset);\n\t    srcreg = DECODE_RM_LONG_REGISTER(rh);\n\t    DECODE_PRINTF(\"\\n\");\n\t    TRACE_AND_STEP();\n\t    test_long(destval, *srcreg);\n\t} else {\n\t    u16 destval;\n\t    u16 *srcreg;\n\n\t    DECODE_PRINTF(\",\");\n\t    destval = fetch_data_word(destoffset);\n\t    srcreg = DECODE_RM_WORD_REGISTER(rh);\n\t    DECODE_PRINTF(\"\\n\");\n\t    TRACE_AND_STEP();\n\t    test_word(destval, *srcreg);\n\t}\n    } else {\t\t\t /* register to register */\n\tif (M.x86.mode & SYSMODE_PREFIX_DATA) {\n\t    u32 *destreg,*srcreg;\n\n\t    destreg = DECODE_RM_LONG_REGISTER(rl);\n\t    DECODE_PRINTF(\",\");\n\t    srcreg = DECODE_RM_LONG_REGISTER(rh);\n\t    DECODE_PRINTF(\"\\n\");\n\t    TRACE_AND_STEP();\n\t    test_long(*destreg, *srcreg);\n\t} else {\n\t    u16 *destreg,*srcreg;\n\n\t    destreg = DECODE_RM_WORD_REGISTER(rl);\n\t    DECODE_PRINTF(\",\");\n\t    srcreg = DECODE_RM_WORD_REGISTER(rh);\n\t    DECODE_PRINTF(\"\\n\");\n\t    TRACE_AND_STEP();\n\t    test_word(*destreg, *srcreg);\n\t}\n    }\n    DECODE_CLEAR_SEGOVR();\n    END_OF_INSTR();\n}", "path": "drivers\\bios_emulator\\x86emu\\ops.c", "repo_name": "edwinrong/u_boot_to_ship", "stars": 1, "license": "other", "language": "c", "size": 13016}
{"docstring": "/****************************************************************************\nREMARKS:\nHandles opcodes 0x02, 0x0a, 0x12, 0x1a, 0x22, 0x2a, 0x32, 0x3a\n****************************************************************************/\n", "func_signal": "void x86emuOp_genop_byte_R_RM(u8 op1)", "code": "{\n    int mod, rl, rh;\n    u8 *destreg, *srcreg;\n    uint srcoffset;\n    u8 srcval;\n\n    op1 = (op1 >> 3) & 0x7;\n\n    START_OF_INSTR();\n    DECODE_PRINTF(x86emu_GenOpName[op1]);\n    DECODE_PRINTF(\"\\t\");\n    FETCH_DECODE_MODRM(mod, rh, rl);\n    if (mod < 3) {\n\tdestreg = DECODE_RM_BYTE_REGISTER(rh);\n\tDECODE_PRINTF(\",\");\n\tsrcoffset = decode_rmXX_address(mod,rl);\n\tsrcval = fetch_data_byte(srcoffset);\n    } else {\t /* register to register */\n\tdestreg = DECODE_RM_BYTE_REGISTER(rh);\n\tDECODE_PRINTF(\",\");\n\tsrcreg = DECODE_RM_BYTE_REGISTER(rl);\n\tsrcval = *srcreg;\n    }\n    DECODE_PRINTF(\"\\n\");\n    TRACE_AND_STEP();\n    *destreg = genop_byte_operation[op1](*destreg, srcval);\n\n    DECODE_CLEAR_SEGOVR();\n    END_OF_INSTR();\n}", "path": "drivers\\bios_emulator\\x86emu\\ops.c", "repo_name": "edwinrong/u_boot_to_ship", "stars": 1, "license": "other", "language": "c", "size": 13016}
{"docstring": "/****************************************************************************\nREMARKS:\nHandles opcode 0xe3\n****************************************************************************/\n", "func_signal": "void x86emuOp_jcxz(u8 X86EMU_UNUSED(op1))", "code": "{\n    u16 target;\n    s8\toffset;\n\n    /* jump to byte offset if overflow flag is set */\n    START_OF_INSTR();\n    DECODE_PRINTF(\"JCXZ\\t\");\n    offset = (s8)fetch_byte_imm();\n    target = (u16)(M.x86.R_IP + offset);\n    DECODE_PRINTF2(\"%x\\n\", target);\n    TRACE_AND_STEP();\n    if (M.x86.R_CX == 0)\n\tM.x86.R_IP = target;\n    DECODE_CLEAR_SEGOVR();\n    END_OF_INSTR();\n}", "path": "drivers\\bios_emulator\\x86emu\\ops.c", "repo_name": "edwinrong/u_boot_to_ship", "stars": 1, "license": "other", "language": "c", "size": 13016}
{"docstring": "/****************************************************************************\nREMARKS:\nHandles opcode 0x68\n****************************************************************************/\n", "func_signal": "void x86emuOp_push_word_IMM(u8 X86EMU_UNUSED(op1))", "code": "{\n    u32 imm;\n\n    START_OF_INSTR();\n    if (M.x86.mode & SYSMODE_PREFIX_DATA) {\n\timm = fetch_long_imm();\n    } else {\n\timm = fetch_word_imm();\n    }\n    DECODE_PRINTF2(\"PUSH\\t%x\\n\", imm);\n    TRACE_AND_STEP();\n    if (M.x86.mode & SYSMODE_PREFIX_DATA) {\n\tpush_long(imm);\n    } else {\n\tpush_word((u16)imm);\n    }\n    DECODE_CLEAR_SEGOVR();\n    END_OF_INSTR();\n}", "path": "drivers\\bios_emulator\\x86emu\\ops.c", "repo_name": "edwinrong/u_boot_to_ship", "stars": 1, "license": "other", "language": "c", "size": 13016}
{"docstring": "/****************************************************************************\nREMARKS:\nHandles opcode 0x36\n****************************************************************************/\n", "func_signal": "void x86emuOp_segovr_SS(u8 X86EMU_UNUSED(op1))", "code": "{\n    START_OF_INSTR();\n    DECODE_PRINTF(\"SS:\\n\");\n    TRACE_AND_STEP();\n    M.x86.mode |= SYSMODE_SEGOVR_SS;\n    /* no DECODE_CLEAR_SEGOVR ! */\n    END_OF_INSTR();\n}", "path": "drivers\\bios_emulator\\x86emu\\ops.c", "repo_name": "edwinrong/u_boot_to_ship", "stars": 1, "license": "other", "language": "c", "size": 13016}
{"docstring": "/****************************************************************************\nREMARKS:\nHandles opcode 0xaa\n****************************************************************************/\n", "func_signal": "void x86emuOp_stos_byte(u8 X86EMU_UNUSED(op1))", "code": "{\n    int inc;\n\n    START_OF_INSTR();\n    DECODE_PRINTF(\"STOS\\tBYTE\\n\");\n    if (ACCESS_FLAG(F_DF))   /* down */\n\tinc = -1;\n    else\n\tinc = 1;\n    TRACE_AND_STEP();\n    if (M.x86.mode & (SYSMODE_PREFIX_REPE | SYSMODE_PREFIX_REPNE)) {\n\t/* dont care whether REPE or REPNE */\n\t/* move them until CX is ZERO. */\n\twhile (M.x86.R_CX != 0) {\n\t    store_data_byte_abs(M.x86.R_ES, M.x86.R_DI, M.x86.R_AL);\n\t    M.x86.R_CX -= 1;\n\t    M.x86.R_DI += inc;\n\t}\n\tM.x86.mode &= ~(SYSMODE_PREFIX_REPE | SYSMODE_PREFIX_REPNE);\n    } else {\n\tstore_data_byte_abs(M.x86.R_ES, M.x86.R_DI, M.x86.R_AL);\n\tM.x86.R_DI += inc;\n    }\n    DECODE_CLEAR_SEGOVR();\n    END_OF_INSTR();\n}", "path": "drivers\\bios_emulator\\x86emu\\ops.c", "repo_name": "edwinrong/u_boot_to_ship", "stars": 1, "license": "other", "language": "c", "size": 13016}
{"docstring": "/****************************************************************************\nREMARKS:\nHandles opcode 0xc1\n****************************************************************************/\n", "func_signal": "void x86emuOp_opcC1_word_RM_MEM(u8 X86EMU_UNUSED(op1))", "code": "{\n    int mod, rl, rh;\n    uint destoffset;\n    u8 amt;\n\n    /*\n     * Yet another weirdo special case instruction format.  Part of\n     * the opcode held below in \"RH\".  Doubly nested case would\n     * result, except that the decoded instruction\n     */\n    START_OF_INSTR();\n    FETCH_DECODE_MODRM(mod, rh, rl);\n#ifdef DEBUG\n    if (DEBUG_DECODE()) {\n\t/* XXX DECODE_PRINTF may be changed to something more\n\t   general, so that it is important to leave the strings\n\t   in the same format, even though the result is that the\n\t   above test is done twice. */\n\n\tswitch (rh) {\n\tcase 0:\n\t    DECODE_PRINTF(\"ROL\\t\");\n\t    break;\n\tcase 1:\n\t    DECODE_PRINTF(\"ROR\\t\");\n\t    break;\n\tcase 2:\n\t    DECODE_PRINTF(\"RCL\\t\");\n\t    break;\n\tcase 3:\n\t    DECODE_PRINTF(\"RCR\\t\");\n\t    break;\n\tcase 4:\n\t    DECODE_PRINTF(\"SHL\\t\");\n\t    break;\n\tcase 5:\n\t    DECODE_PRINTF(\"SHR\\t\");\n\t    break;\n\tcase 6:\n\t    DECODE_PRINTF(\"SAL\\t\");\n\t    break;\n\tcase 7:\n\t    DECODE_PRINTF(\"SAR\\t\");\n\t    break;\n\t}\n    }\n#endif\n    /* know operation, decode the mod byte to find the addressing\n       mode. */\n    if (mod < 3) {\n\tif (M.x86.mode & SYSMODE_PREFIX_DATA) {\n\t    u32 destval;\n\n\t    DECODE_PRINTF(\"DWORD PTR \");\n\t    destoffset = decode_rmXX_address(mod, rl);\n\t    amt = fetch_byte_imm();\n\t    DECODE_PRINTF2(\",%x\\n\", amt);\n\t    destval = fetch_data_long(destoffset);\n\t    TRACE_AND_STEP();\n\t    destval = (*opcD1_long_operation[rh]) (destval, amt);\n\t    store_data_long(destoffset, destval);\n\t} else {\n\t    u16 destval;\n\n\t    DECODE_PRINTF(\"WORD PTR \");\n\t    destoffset = decode_rmXX_address(mod, rl);\n\t    amt = fetch_byte_imm();\n\t    DECODE_PRINTF2(\",%x\\n\", amt);\n\t    destval = fetch_data_word(destoffset);\n\t    TRACE_AND_STEP();\n\t    destval = (*opcD1_word_operation[rh]) (destval, amt);\n\t    store_data_word(destoffset, destval);\n\t}\n    } else {\t\t\t /* register to register */\n\tif (M.x86.mode & SYSMODE_PREFIX_DATA) {\n\t    u32 *destreg;\n\n\t    destreg = DECODE_RM_LONG_REGISTER(rl);\n\t    amt = fetch_byte_imm();\n\t    DECODE_PRINTF2(\",%x\\n\", amt);\n\t    TRACE_AND_STEP();\n\t    *destreg = (*opcD1_long_operation[rh]) (*destreg, amt);\n\t} else {\n\t    u16 *destreg;\n\n\t    destreg = DECODE_RM_WORD_REGISTER(rl);\n\t    amt = fetch_byte_imm();\n\t    DECODE_PRINTF2(\",%x\\n\", amt);\n\t    TRACE_AND_STEP();\n\t    *destreg = (*opcD1_word_operation[rh]) (*destreg, amt);\n\t}\n    }\n    DECODE_CLEAR_SEGOVR();\n    END_OF_INSTR();\n}", "path": "drivers\\bios_emulator\\x86emu\\ops.c", "repo_name": "edwinrong/u_boot_to_ship", "stars": 1, "license": "other", "language": "c", "size": 13016}
{"docstring": "/****************************************************************************\nREMARKS:\nHandles opcode 0x60\n****************************************************************************/\n", "func_signal": "void x86emuOp_push_all(u8 X86EMU_UNUSED(op1))", "code": "{\n    START_OF_INSTR();\n    if (M.x86.mode & SYSMODE_PREFIX_DATA) {\n\tDECODE_PRINTF(\"PUSHAD\\n\");\n    } else {\n\tDECODE_PRINTF(\"PUSHA\\n\");\n    }\n    TRACE_AND_STEP();\n    if (M.x86.mode & SYSMODE_PREFIX_DATA) {\n\tu32 old_sp = M.x86.R_ESP;\n\n\tpush_long(M.x86.R_EAX);\n\tpush_long(M.x86.R_ECX);\n\tpush_long(M.x86.R_EDX);\n\tpush_long(M.x86.R_EBX);\n\tpush_long(old_sp);\n\tpush_long(M.x86.R_EBP);\n\tpush_long(M.x86.R_ESI);\n\tpush_long(M.x86.R_EDI);\n    } else {\n\tu16 old_sp = M.x86.R_SP;\n\n\tpush_word(M.x86.R_AX);\n\tpush_word(M.x86.R_CX);\n\tpush_word(M.x86.R_DX);\n\tpush_word(M.x86.R_BX);\n\tpush_word(old_sp);\n\tpush_word(M.x86.R_BP);\n\tpush_word(M.x86.R_SI);\n\tpush_word(M.x86.R_DI);\n    }\n    DECODE_CLEAR_SEGOVR();\n    END_OF_INSTR();\n}", "path": "drivers\\bios_emulator\\x86emu\\ops.c", "repo_name": "edwinrong/u_boot_to_ship", "stars": 1, "license": "other", "language": "c", "size": 13016}
{"docstring": "/****************************************************************************\nREMARKS:\nHandles opcode 0xad\n****************************************************************************/\n", "func_signal": "void x86emuOp_lods_word(u8 X86EMU_UNUSED(op1))", "code": "{\n    int inc;\n    u32 count;\n\n    START_OF_INSTR();\n    if (M.x86.mode & SYSMODE_PREFIX_DATA) {\n\tDECODE_PRINTF(\"LODS\\tDWORD\\n\");\n\tif (ACCESS_FLAG(F_DF))\t /* down */\n\t    inc = -4;\n\telse\n\t    inc = 4;\n    } else {\n\tDECODE_PRINTF(\"LODS\\tWORD\\n\");\n\tif (ACCESS_FLAG(F_DF))\t /* down */\n\t    inc = -2;\n\telse\n\t    inc = 2;\n    }\n    TRACE_AND_STEP();\n    count = 1;\n    if (M.x86.mode & (SYSMODE_PREFIX_REPE | SYSMODE_PREFIX_REPNE)) {\n\t/* dont care whether REPE or REPNE */\n\t/* move them until CX is ZERO. */\n\tcount = M.x86.R_CX;\n\tM.x86.R_CX = 0;\n\tM.x86.mode &= ~(SYSMODE_PREFIX_REPE | SYSMODE_PREFIX_REPNE);\n    }\n    while (count--) {\n\tif (M.x86.mode & SYSMODE_PREFIX_DATA) {\n\t    M.x86.R_EAX = fetch_data_long(M.x86.R_SI);\n\t} else {\n\t    M.x86.R_AX = fetch_data_word(M.x86.R_SI);\n\t}\n\tM.x86.R_SI += inc;\n    }\n    DECODE_CLEAR_SEGOVR();\n    END_OF_INSTR();\n}", "path": "drivers\\bios_emulator\\x86emu\\ops.c", "repo_name": "edwinrong/u_boot_to_ship", "stars": 1, "license": "other", "language": "c", "size": 13016}
{"docstring": "/****************************************************************************\nREMARKS:\nHandles opcode 0xa6\n****************************************************************************/\n", "func_signal": "void x86emuOp_cmps_byte(u8 X86EMU_UNUSED(op1))", "code": "{\n    s8 val1, val2;\n    int inc;\n\n    START_OF_INSTR();\n    DECODE_PRINTF(\"CMPS\\tBYTE\\n\");\n    TRACE_AND_STEP();\n    if (ACCESS_FLAG(F_DF))   /* down */\n\tinc = -1;\n    else\n\tinc = 1;\n\n    if (M.x86.mode & (SYSMODE_PREFIX_REPE | SYSMODE_PREFIX_REPNE)) {\n\t/* REPE\t */\n\t/* move them until CX is ZERO. */\n\twhile (M.x86.R_CX != 0) {\n\t    val1 = fetch_data_byte(M.x86.R_SI);\n\t    val2 = fetch_data_byte_abs(M.x86.R_ES, M.x86.R_DI);\n\t\t     cmp_byte(val1, val2);\n\t    M.x86.R_CX -= 1;\n\t    M.x86.R_SI += inc;\n\t    M.x86.R_DI += inc;\n\t    if ( (M.x86.mode & SYSMODE_PREFIX_REPE) && (ACCESS_FLAG(F_ZF) == 0) ) break;\n\t    if ( (M.x86.mode & SYSMODE_PREFIX_REPNE) && ACCESS_FLAG(F_ZF) ) break;\n\t}\n\tM.x86.mode &= ~(SYSMODE_PREFIX_REPE | SYSMODE_PREFIX_REPNE);\n    } else {\n\tval1 = fetch_data_byte(M.x86.R_SI);\n\tval2 = fetch_data_byte_abs(M.x86.R_ES, M.x86.R_DI);\n\tcmp_byte(val1, val2);\n\tM.x86.R_SI += inc;\n\tM.x86.R_DI += inc;\n    }\n    DECODE_CLEAR_SEGOVR();\n    END_OF_INSTR();\n}", "path": "drivers\\bios_emulator\\x86emu\\ops.c", "repo_name": "edwinrong/u_boot_to_ship", "stars": 1, "license": "other", "language": "c", "size": 13016}
{"docstring": "/****************************************************************************\nREMARKS:\nHandles opcode 0x2f\n****************************************************************************/\n", "func_signal": "void x86emuOp_das(u8 X86EMU_UNUSED(op1))", "code": "{\n    START_OF_INSTR();\n    DECODE_PRINTF(\"DAS\\n\");\n    TRACE_AND_STEP();\n    M.x86.R_AL = das_byte(M.x86.R_AL);\n    DECODE_CLEAR_SEGOVR();\n    END_OF_INSTR();\n}", "path": "drivers\\bios_emulator\\x86emu\\ops.c", "repo_name": "edwinrong/u_boot_to_ship", "stars": 1, "license": "other", "language": "c", "size": 13016}
{"docstring": "/****************************************************************************\nREMARKS:\nHandles opcodes 0x01, 0x09, 0x11, 0x19, 0x21, 0x29, 0x31, 0x39\n****************************************************************************/\n", "func_signal": "void x86emuOp_genop_word_RM_R(u8 op1)", "code": "{\n    int mod, rl, rh;\n    uint destoffset;\n\n    op1 = (op1 >> 3) & 0x7;\n\n    START_OF_INSTR();\n    DECODE_PRINTF(x86emu_GenOpName[op1]);\n    DECODE_PRINTF(\"\\t\");\n    FETCH_DECODE_MODRM(mod, rh, rl);\n\n    if(mod<3) {\n\tdestoffset = decode_rmXX_address(mod,rl);\n\tif (M.x86.mode & SYSMODE_PREFIX_DATA) {\n\t    u32 destval;\n\t    u32 *srcreg;\n\n\t    DECODE_PRINTF(\",\");\n\t    destval = fetch_data_long(destoffset);\n\t    srcreg = DECODE_RM_LONG_REGISTER(rh);\n\t    DECODE_PRINTF(\"\\n\");\n\t    TRACE_AND_STEP();\n\t    destval = genop_long_operation[op1](destval, *srcreg);\n\t    store_data_long(destoffset, destval);\n\t} else {\n\t    u16 destval;\n\t    u16 *srcreg;\n\n\t    DECODE_PRINTF(\",\");\n\t    destval = fetch_data_word(destoffset);\n\t    srcreg = DECODE_RM_WORD_REGISTER(rh);\n\t    DECODE_PRINTF(\"\\n\");\n\t    TRACE_AND_STEP();\n\t    destval = genop_word_operation[op1](destval, *srcreg);\n\t    store_data_word(destoffset, destval);\n\t}\n    } else {\t\t\t/* register to register */\n\tif (M.x86.mode & SYSMODE_PREFIX_DATA) {\n\t    u32 *destreg,*srcreg;\n\n\t    destreg = DECODE_RM_LONG_REGISTER(rl);\n\t    DECODE_PRINTF(\",\");\n\t    srcreg = DECODE_RM_LONG_REGISTER(rh);\n\t    DECODE_PRINTF(\"\\n\");\n\t    TRACE_AND_STEP();\n\t    *destreg = genop_long_operation[op1](*destreg, *srcreg);\n\t} else {\n\t    u16 *destreg,*srcreg;\n\n\t    destreg = DECODE_RM_WORD_REGISTER(rl);\n\t    DECODE_PRINTF(\",\");\n\t    srcreg = DECODE_RM_WORD_REGISTER(rh);\n\t    DECODE_PRINTF(\"\\n\");\n\t    TRACE_AND_STEP();\n\t    *destreg = genop_word_operation[op1](*destreg, *srcreg);\n\t}\n    }\n    DECODE_CLEAR_SEGOVR();\n    END_OF_INSTR();\n}", "path": "drivers\\bios_emulator\\x86emu\\ops.c", "repo_name": "edwinrong/u_boot_to_ship", "stars": 1, "license": "other", "language": "c", "size": 13016}
{"docstring": "/****************************************************************************\nREMARKS:\nHandles opcode 0x17\n****************************************************************************/\n", "func_signal": "void x86emuOp_pop_SS(u8 X86EMU_UNUSED(op1))", "code": "{\n    START_OF_INSTR();\n    DECODE_PRINTF(\"POP\\tSS\\n\");\n    TRACE_AND_STEP();\n    M.x86.R_SS = pop_word();\n    DECODE_CLEAR_SEGOVR();\n    END_OF_INSTR();\n}", "path": "drivers\\bios_emulator\\x86emu\\ops.c", "repo_name": "edwinrong/u_boot_to_ship", "stars": 1, "license": "other", "language": "c", "size": 13016}
{"docstring": "/****************************************************************************\nREMARKS:\nHandles opcode 0x83\n****************************************************************************/\n", "func_signal": "void x86emuOp_opc83_word_RM_IMM(u8 X86EMU_UNUSED(op1))", "code": "{\n    int mod, rl, rh;\n    uint destoffset;\n\n    /*\n     * Weirdo special case instruction format.\tPart of the opcode\n     * held below in \"RH\".  Doubly nested case would result, except\n     * that the decoded instruction Similar to opcode 81, except that\n     * the immediate byte is sign extended to a word length.\n     */\n    START_OF_INSTR();\n    FETCH_DECODE_MODRM(mod, rh, rl);\n#ifdef DEBUG\n    if (DEBUG_DECODE()) {\n\t/* XXX DECODE_PRINTF may be changed to something more\n\t   general, so that it is important to leave the strings\n\t   in the same format, even though the result is that the\n\t   above test is done twice. */\n       switch (rh) {\n\tcase 0:\n\t    DECODE_PRINTF(\"ADD\\t\");\n\t    break;\n\tcase 1:\n\t    DECODE_PRINTF(\"OR\\t\");\n\t    break;\n\tcase 2:\n\t    DECODE_PRINTF(\"ADC\\t\");\n\t    break;\n\tcase 3:\n\t    DECODE_PRINTF(\"SBB\\t\");\n\t    break;\n\tcase 4:\n\t    DECODE_PRINTF(\"AND\\t\");\n\t    break;\n\tcase 5:\n\t    DECODE_PRINTF(\"SUB\\t\");\n\t    break;\n\tcase 6:\n\t    DECODE_PRINTF(\"XOR\\t\");\n\t    break;\n\tcase 7:\n\t    DECODE_PRINTF(\"CMP\\t\");\n\t    break;\n\t}\n    }\n#endif\n    /* know operation, decode the mod byte to find the addressing\n       mode. */\n    if (mod < 3) {\n\tDECODE_PRINTF(\"DWORD PTR \");\n\tdestoffset = decode_rmXX_address(mod,rl);\n\n\tif (M.x86.mode & SYSMODE_PREFIX_DATA) {\n\t    u32 destval,imm;\n\n\t    destval = fetch_data_long(destoffset);\n\t    imm = (s8) fetch_byte_imm();\n\t    DECODE_PRINTF2(\",%x\\n\", imm);\n\t    TRACE_AND_STEP();\n\t    destval = (*genop_long_operation[rh]) (destval, imm);\n\t    if (rh != 7)\n\t\tstore_data_long(destoffset, destval);\n\t} else {\n\t    u16 destval,imm;\n\n\t    destval = fetch_data_word(destoffset);\n\t    imm = (s8) fetch_byte_imm();\n\t    DECODE_PRINTF2(\",%x\\n\", imm);\n\t    TRACE_AND_STEP();\n\t    destval = (*genop_word_operation[rh]) (destval, imm);\n\t    if (rh != 7)\n\t\tstore_data_word(destoffset, destval);\n\t}\n    } else {\t\t\t /* register to register */\n\tif (M.x86.mode & SYSMODE_PREFIX_DATA) {\n\t    u32 *destreg;\n\t    u32 destval,imm;\n\n\t    destreg = DECODE_RM_LONG_REGISTER(rl);\n\t    imm = (s8) fetch_byte_imm();\n\t    DECODE_PRINTF2(\",%x\\n\", imm);\n\t    TRACE_AND_STEP();\n\t    destval = (*genop_long_operation[rh]) (*destreg, imm);\n\t    if (rh != 7)\n\t\t*destreg = destval;\n\t} else {\n\t    u16 *destreg;\n\t    u16 destval,imm;\n\n\t    destreg = DECODE_RM_WORD_REGISTER(rl);\n\t    imm = (s8) fetch_byte_imm();\n\t    DECODE_PRINTF2(\",%x\\n\", imm);\n\t    TRACE_AND_STEP();\n\t    destval = (*genop_word_operation[rh]) (*destreg, imm);\n\t    if (rh != 7)\n\t\t*destreg = destval;\n\t}\n    }\n    DECODE_CLEAR_SEGOVR();\n    END_OF_INSTR();\n}", "path": "drivers\\bios_emulator\\x86emu\\ops.c", "repo_name": "edwinrong/u_boot_to_ship", "stars": 1, "license": "other", "language": "c", "size": 13016}
{"docstring": "/****************************************************************************\nREMARKS:\nHandles opcode 0x82\n****************************************************************************/\n", "func_signal": "void x86emuOp_opc82_byte_RM_IMM(u8 X86EMU_UNUSED(op1))", "code": "{\n    int mod, rl, rh;\n    u8 *destreg;\n    uint destoffset;\n    u8 imm;\n    u8 destval;\n\n    /*\n     * Weirdo special case instruction format.\tPart of the opcode\n     * held below in \"RH\".  Doubly nested case would result, except\n     * that the decoded instruction Similar to opcode 81, except that\n     * the immediate byte is sign extended to a word length.\n     */\n    START_OF_INSTR();\n    FETCH_DECODE_MODRM(mod, rh, rl);\n#ifdef DEBUG\n    if (DEBUG_DECODE()) {\n\t/* XXX DECODE_PRINTF may be changed to something more\n\t   general, so that it is important to leave the strings\n\t   in the same format, even though the result is that the\n\t   above test is done twice. */\n\tswitch (rh) {\n\tcase 0:\n\t    DECODE_PRINTF(\"ADD\\t\");\n\t    break;\n\tcase 1:\n\t    DECODE_PRINTF(\"OR\\t\");\n\t    break;\n\tcase 2:\n\t    DECODE_PRINTF(\"ADC\\t\");\n\t    break;\n\tcase 3:\n\t    DECODE_PRINTF(\"SBB\\t\");\n\t    break;\n\tcase 4:\n\t    DECODE_PRINTF(\"AND\\t\");\n\t    break;\n\tcase 5:\n\t    DECODE_PRINTF(\"SUB\\t\");\n\t    break;\n\tcase 6:\n\t    DECODE_PRINTF(\"XOR\\t\");\n\t    break;\n\tcase 7:\n\t    DECODE_PRINTF(\"CMP\\t\");\n\t    break;\n\t}\n    }\n#endif\n    /* know operation, decode the mod byte to find the addressing\n       mode. */\n    if (mod < 3) {\n\tDECODE_PRINTF(\"BYTE PTR \");\n\tdestoffset = decode_rmXX_address(mod, rl);\n\tdestval = fetch_data_byte(destoffset);\n\timm = fetch_byte_imm();\n\tDECODE_PRINTF2(\",%x\\n\", imm);\n\tTRACE_AND_STEP();\n\tdestval = (*genop_byte_operation[rh]) (destval, imm);\n\tif (rh != 7)\n\t    store_data_byte(destoffset, destval);\n    } else {\t\t\t /* register to register */\n\tdestreg = DECODE_RM_BYTE_REGISTER(rl);\n\timm = fetch_byte_imm();\n\tDECODE_PRINTF2(\",%x\\n\", imm);\n\tTRACE_AND_STEP();\n\tdestval = (*genop_byte_operation[rh]) (*destreg, imm);\n\tif (rh != 7)\n\t    *destreg = destval;\n    }\n    DECODE_CLEAR_SEGOVR();\n    END_OF_INSTR();\n}", "path": "drivers\\bios_emulator\\x86emu\\ops.c", "repo_name": "edwinrong/u_boot_to_ship", "stars": 1, "license": "other", "language": "c", "size": 13016}
{"docstring": "/****************************************************************************\nREMARKS:\nHandles opcode 0xe6\n****************************************************************************/\n", "func_signal": "void x86emuOp_out_byte_IMM_AL(u8 X86EMU_UNUSED(op1))", "code": "{\n    u8 port;\n\n    START_OF_INSTR();\n    DECODE_PRINTF(\"OUT\\t\");\n\tport = (u8) fetch_byte_imm();\n    DECODE_PRINTF2(\"%x,AL\\n\", port);\n    TRACE_AND_STEP();\n    (*sys_outb)(port, M.x86.R_AL);\n    DECODE_CLEAR_SEGOVR();\n    END_OF_INSTR();\n}", "path": "drivers\\bios_emulator\\x86emu\\ops.c", "repo_name": "edwinrong/u_boot_to_ship", "stars": 1, "license": "other", "language": "c", "size": 13016}
{"docstring": "/*\n * Caller MUST hold any necessary locks\n */\n", "func_signal": "struct assoc_request *lbs_get_association_request(struct lbs_private *priv)", "code": "{\n\tstruct assoc_request * assoc_req;\n\n\tlbs_deb_enter(LBS_DEB_ASSOC);\n\tif (!priv->pending_assoc_req) {\n\t\tpriv->pending_assoc_req = kzalloc(sizeof(struct assoc_request),\n\t\t                                     GFP_KERNEL);\n\t\tif (!priv->pending_assoc_req) {\n\t\t\tlbs_pr_info(\"Not enough memory to allocate association\"\n\t\t\t\t\" request!\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t/* Copy current configuration attributes to the association request,\n\t * but don't overwrite any that are already set.\n\t */\n\tassoc_req = priv->pending_assoc_req;\n\tif (!test_bit(ASSOC_FLAG_SSID, &assoc_req->flags)) {\n\t\tmemcpy(&assoc_req->ssid, &priv->curbssparams.ssid,\n\t\t       IW_ESSID_MAX_SIZE);\n\t\tassoc_req->ssid_len = priv->curbssparams.ssid_len;\n\t}\n\n\tif (!test_bit(ASSOC_FLAG_CHANNEL, &assoc_req->flags))\n\t\tassoc_req->channel = priv->curbssparams.channel;\n\n\tif (!test_bit(ASSOC_FLAG_BAND, &assoc_req->flags))\n\t\tassoc_req->band = priv->curbssparams.band;\n\n\tif (!test_bit(ASSOC_FLAG_MODE, &assoc_req->flags))\n\t\tassoc_req->mode = priv->mode;\n\n\tif (!test_bit(ASSOC_FLAG_BSSID, &assoc_req->flags)) {\n\t\tmemcpy(&assoc_req->bssid, priv->curbssparams.bssid,\n\t\t\tETH_ALEN);\n\t}\n\n\tif (!test_bit(ASSOC_FLAG_WEP_KEYS, &assoc_req->flags)) {\n\t\tint i;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tmemcpy(&assoc_req->wep_keys[i], &priv->wep_keys[i],\n\t\t\t\tsizeof(struct enc_key));\n\t\t}\n\t}\n\n\tif (!test_bit(ASSOC_FLAG_WEP_TX_KEYIDX, &assoc_req->flags))\n\t\tassoc_req->wep_tx_keyidx = priv->wep_tx_keyidx;\n\n\tif (!test_bit(ASSOC_FLAG_WPA_MCAST_KEY, &assoc_req->flags)) {\n\t\tmemcpy(&assoc_req->wpa_mcast_key, &priv->wpa_mcast_key,\n\t\t\tsizeof(struct enc_key));\n\t}\n\n\tif (!test_bit(ASSOC_FLAG_WPA_UCAST_KEY, &assoc_req->flags)) {\n\t\tmemcpy(&assoc_req->wpa_unicast_key, &priv->wpa_unicast_key,\n\t\t\tsizeof(struct enc_key));\n\t}\n\n\tif (!test_bit(ASSOC_FLAG_SECINFO, &assoc_req->flags)) {\n\t\tmemcpy(&assoc_req->secinfo, &priv->secinfo,\n\t\t\tsizeof(struct lbs_802_11_security));\n\t}\n\n\tif (!test_bit(ASSOC_FLAG_WPA_IE, &assoc_req->flags)) {\n\t\tmemcpy(&assoc_req->wpa_ie, &priv->wpa_ie,\n\t\t\tMAX_WPA_IE_LEN);\n\t\tassoc_req->wpa_ie_len = priv->wpa_ie_len;\n\t}\n\n\tlbs_deb_leave(LBS_DEB_ASSOC);\n\treturn assoc_req;\n}", "path": "package\\libertas\\src\\assoc.c", "repo_name": "nilstoedtmann/openwrt-hub", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 69428}
{"docstring": "/**\n *  @brief Start an Adhoc Network\n *\n *  @param priv         A pointer to struct lbs_private structure\n *  @param adhocssid    The ssid of the Adhoc Network\n *  @return             0--success, -1--fail\n */\n", "func_signal": "static int lbs_start_adhoc_network(struct lbs_private *priv,\n\tstruct assoc_request *assoc_req)", "code": "{\n\tint ret = 0;\n\n\tpriv->adhoccreate = 1;\n\n\tif (priv->capability & WLAN_CAPABILITY_SHORT_PREAMBLE) {\n\t\tlbs_deb_join(\"AdhocStart: Short preamble\\n\");\n\t\tpriv->preamble = CMD_TYPE_SHORT_PREAMBLE;\n\t} else {\n\t\tlbs_deb_join(\"AdhocStart: Long preamble\\n\");\n\t\tpriv->preamble = CMD_TYPE_LONG_PREAMBLE;\n\t}\n\n\tlbs_set_radio_control(priv);\n\n\tlbs_deb_join(\"AdhocStart: channel = %d\\n\", assoc_req->channel);\n\tlbs_deb_join(\"AdhocStart: band = %d\\n\", assoc_req->band);\n\n\tret = lbs_prepare_and_send_command(priv, CMD_802_11_AD_HOC_START,\n\t\t\t\t    0, CMD_OPTION_WAITFORRSP, 0, assoc_req);\n\n\treturn ret;\n}", "path": "package\\libertas\\src\\assoc.c", "repo_name": "nilstoedtmann/openwrt-hub", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 69428}
{"docstring": "/*\n * A few low level functions.\n */\n", "func_signal": "static inline void s3c2410_ts_connect(void)", "code": "{\n\ts3c2410_gpio_cfgpin(S3C2410_GPG12, S3C2410_GPG12_XMON);\n\ts3c2410_gpio_cfgpin(S3C2410_GPG13, S3C2410_GPG13_nXPON);\n\ts3c2410_gpio_cfgpin(S3C2410_GPG14, S3C2410_GPG14_YMON);\n\ts3c2410_gpio_cfgpin(S3C2410_GPG15, S3C2410_GPG15_nYPON);\n}", "path": "target\\linux\\s3c24xx\\files-2.6.30\\drivers\\input\\touchscreen\\s3c2410_ts.c", "repo_name": "nilstoedtmann/openwrt-hub", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 69428}
{"docstring": "/**\n *  @brief Find the best AP\n *\n *  Used from association worker.\n *\n *  @param priv         A pointer to struct lbs_private structure\n *  @param pSSID        A pointer to AP's ssid\n *\n *  @return             0--success, otherwise--fail\n */\n", "func_signal": "static int lbs_find_best_network_ssid(struct lbs_private *priv,\n\tuint8_t *out_ssid, uint8_t *out_ssid_len, uint8_t preferred_mode,\n\tuint8_t *out_mode)", "code": "{\n\tint ret = -1;\n\tstruct bss_descriptor *found;\n\n\tlbs_deb_enter(LBS_DEB_SCAN);\n\n\tpriv->scan_ssid_len = 0;\n\tlbs_scan_networks(priv, 1);\n\tif (priv->surpriseremoved)\n\t\tgoto out;\n\n\tfound = lbs_find_best_ssid_in_list(priv, preferred_mode);\n\tif (found && (found->ssid_len > 0)) {\n\t\tmemcpy(out_ssid, &found->ssid, IW_ESSID_MAX_SIZE);\n\t\t*out_ssid_len = found->ssid_len;\n\t\t*out_mode = found->mode;\n\t\tret = 0;\n\t}\n\nout:\n\tlbs_deb_leave_args(LBS_DEB_SCAN, \"ret %d\", ret);\n\treturn ret;\n}", "path": "package\\libertas\\src\\assoc.c", "repo_name": "nilstoedtmann/openwrt-hub", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 69428}
{"docstring": "/**\n *  @brief Join an adhoc network found in a previous scan\n *\n *  @param priv         A pointer to struct lbs_private structure\n *  @param pbssdesc     Pointer to a BSS descriptor found in a previous scan\n *                      to attempt to join\n *\n *  @return             0--success, -1--fail\n */\n", "func_signal": "static int lbs_join_adhoc_network(struct lbs_private *priv,\n\tstruct assoc_request *assoc_req)", "code": "{\n\tstruct bss_descriptor *bss = &assoc_req->bss;\n\tint ret = 0;\n\n\tlbs_deb_join(\"current SSID '%s', ssid length %u\\n\",\n\t\tescape_essid(priv->curbssparams.ssid,\n\t\tpriv->curbssparams.ssid_len),\n\t\tpriv->curbssparams.ssid_len);\n\tlbs_deb_join(\"requested ssid '%s', ssid length %u\\n\",\n\t\tescape_essid(bss->ssid, bss->ssid_len),\n\t\tbss->ssid_len);\n\n\t/* check if the requested SSID is already joined */\n\tif (priv->curbssparams.ssid_len &&\n\t    !lbs_ssid_cmp(priv->curbssparams.ssid,\n\t\t\tpriv->curbssparams.ssid_len,\n\t\t\tbss->ssid, bss->ssid_len) &&\n\t    (priv->mode == IW_MODE_ADHOC) &&\n\t    (priv->connect_status == LBS_CONNECTED)) {\n\t\tunion iwreq_data wrqu;\n\n\t\tlbs_deb_join(\"ADHOC_J_CMD: New ad-hoc SSID is the same as \"\n\t\t\t\"current, not attempting to re-join\");\n\n\t\t/* Send the re-association event though, because the association\n\t\t * request really was successful, even if just a null-op.\n\t\t */\n\t\tmemset(&wrqu, 0, sizeof(wrqu));\n\t\tmemcpy(wrqu.ap_addr.sa_data, priv->curbssparams.bssid,\n\t\t       ETH_ALEN);\n\t\twrqu.ap_addr.sa_family = ARPHRD_ETHER;\n\t\twireless_send_event(priv->dev, SIOCGIWAP, &wrqu, NULL);\n\t\tgoto out;\n\t}\n\n\t/* Use shortpreamble only when both creator and card supports\n\t   short preamble */\n\tif (!(bss->capability & WLAN_CAPABILITY_SHORT_PREAMBLE) ||\n\t    !(priv->capability & WLAN_CAPABILITY_SHORT_PREAMBLE)) {\n\t\tlbs_deb_join(\"AdhocJoin: Long preamble\\n\");\n\t\tpriv->preamble = CMD_TYPE_LONG_PREAMBLE;\n\t} else {\n\t\tlbs_deb_join(\"AdhocJoin: Short preamble\\n\");\n\t\tpriv->preamble = CMD_TYPE_SHORT_PREAMBLE;\n\t}\n\n\tlbs_set_radio_control(priv);\n\n\tlbs_deb_join(\"AdhocJoin: channel = %d\\n\", assoc_req->channel);\n\tlbs_deb_join(\"AdhocJoin: band = %c\\n\", assoc_req->band);\n\n\tpriv->adhoccreate = 0;\n\n\tret = lbs_prepare_and_send_command(priv, CMD_802_11_AD_HOC_JOIN,\n\t\t\t\t    0, CMD_OPTION_WAITFORRSP,\n\t\t\t\t    OID_802_11_SSID, assoc_req);\n\nout:\n\treturn ret;\n}", "path": "package\\libertas\\src\\assoc.c", "repo_name": "nilstoedtmann/openwrt-hub", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 69428}
{"docstring": "/**\n *  @brief This function finds ssid in ssid list.\n *\n *  Used in association code\n *\n *  @param priv  A pointer to struct lbs_private\n *  @param ssid     SSID to find in the list\n *  @param bssid    BSSID to qualify the SSID selection (if provided)\n *  @param mode     Network mode: Infrastructure or IBSS\n *\n *  @return         index in BSSID list\n */\n", "func_signal": "static struct bss_descriptor *lbs_find_ssid_in_list(struct lbs_private *priv,\n\t\t\t\t\t     uint8_t *ssid, uint8_t ssid_len,\n\t\t\t\t\t     uint8_t *bssid, uint8_t mode,\n\t\t\t\t\t     int channel)", "code": "{\n\tu32 bestrssi = 0;\n\tstruct bss_descriptor *iter_bss = NULL;\n\tstruct bss_descriptor *found_bss = NULL;\n\tstruct bss_descriptor *tmp_oldest = NULL;\n\n\tlbs_deb_enter(LBS_DEB_SCAN);\n\n\tmutex_lock(&priv->lock);\n\n\tlist_for_each_entry(iter_bss, &priv->network_list, list) {\n\t\tif (!tmp_oldest ||\n\t\t    (iter_bss->last_scanned < tmp_oldest->last_scanned))\n\t\t\ttmp_oldest = iter_bss;\n\n\t\tif (lbs_ssid_cmp(iter_bss->ssid, iter_bss->ssid_len,\n\t\t\t\t ssid, ssid_len) != 0)\n\t\t\tcontinue; /* ssid doesn't match */\n\t\tif (bssid && compare_ether_addr(iter_bss->bssid, bssid) != 0)\n\t\t\tcontinue; /* bssid doesn't match */\n\t\tif ((channel > 0) && (iter_bss->channel != channel))\n\t\t\tcontinue; /* channel doesn't match */\n\n\t\tswitch (mode) {\n\t\tcase IW_MODE_INFRA:\n\t\tcase IW_MODE_ADHOC:\n\t\t\tif (!is_network_compatible(priv, iter_bss, mode))\n\t\t\t\tbreak;\n\n\t\t\tif (bssid) {\n\t\t\t\t/* Found requested BSSID */\n\t\t\t\tfound_bss = iter_bss;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (SCAN_RSSI(iter_bss->rssi) > bestrssi) {\n\t\t\t\tbestrssi = SCAN_RSSI(iter_bss->rssi);\n\t\t\t\tfound_bss = iter_bss;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IW_MODE_AUTO:\n\t\tdefault:\n\t\t\tif (SCAN_RSSI(iter_bss->rssi) > bestrssi) {\n\t\t\t\tbestrssi = SCAN_RSSI(iter_bss->rssi);\n\t\t\t\tfound_bss = iter_bss;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tmutex_unlock(&priv->lock);\n\tlbs_deb_leave_args(LBS_DEB_SCAN, \"found_bss %p\", found_bss);\n\treturn found_bss;\n}", "path": "package\\libertas\\src\\assoc.c", "repo_name": "nilstoedtmann/openwrt-hub", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 69428}
{"docstring": "/*\n * Manage interrupts.\n */\n", "func_signal": "static irqreturn_t stylus_updown(int irq, void *dev_id)", "code": "{\n\tunsigned long data0;\n\tunsigned long data1;\n\tint event_type;\n\n\tdata0 = readl(base_addr+S3C2410_ADCDAT0);\n\tdata1 = readl(base_addr+S3C2410_ADCDAT1);\n\n\tts.is_down = (!(data0 & S3C2410_ADCDAT0_UPDOWN)) &&\n\t\t\t\t\t    (!(data1 & S3C2410_ADCDAT0_UPDOWN));\n\n\tevent_type = ts.is_down ? 'D' : 'U';\n\n\tif (unlikely(__kfifo_put(ts.event_fifo, (unsigned char *)&event_type,\n\t\t     sizeof(int)) != sizeof(int))) /* should not happen */\n\t\tprintk(KERN_ERR __FILE__\": stylus_updown lost event!\\n\");\n\n\tif (ts.is_down)\n\t\ts3c2410_ts_start_adc_conversion();\n\telse\n\t\twritel(WAIT4INT(0), base_addr+S3C2410_ADCTSC);\n\n\tmod_timer(&event_send_timer, jiffies + 1);\n\n\treturn IRQ_HANDLED;\n}", "path": "target\\linux\\s3c24xx\\files-2.6.30\\drivers\\input\\touchscreen\\s3c2410_ts.c", "repo_name": "nilstoedtmann/openwrt-hub", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 69428}
{"docstring": "/**\n *  @brief This function finds common rates between rate1 and card rates.\n *\n * It will fill common rates in rate1 as output if found.\n *\n * NOTE: Setting the MSB of the basic rates need to be taken\n *   care, either before or after calling this function\n *\n *  @param priv     A pointer to struct lbs_private structure\n *  @param rate1       the buffer which keeps input and output\n *  @param rate1_size  the size of rate1 buffer; new size of buffer on return\n *\n *  @return            0 or -1\n */\n", "func_signal": "static int get_common_rates(struct lbs_private *priv,\n\tu8 *rates,\n\tu16 *rates_size)", "code": "{\n\tu8 *card_rates = lbs_bg_rates;\n\tsize_t num_card_rates = sizeof(lbs_bg_rates);\n\tint ret = 0, i, j;\n\tu8 tmp[30];\n\tsize_t tmp_size = 0;\n\n\t/* For each rate in card_rates that exists in rate1, copy to tmp */\n\tfor (i = 0; card_rates[i] && (i < num_card_rates); i++) {\n\t\tfor (j = 0; rates[j] && (j < *rates_size); j++) {\n\t\t\tif (rates[j] == card_rates[i])\n\t\t\t\ttmp[tmp_size++] = card_rates[i];\n\t\t}\n\t}\n\n\tlbs_deb_hex(LBS_DEB_JOIN, \"AP rates    \", rates, *rates_size);\n\tlbs_deb_hex(LBS_DEB_JOIN, \"card rates  \", card_rates, num_card_rates);\n\tlbs_deb_hex(LBS_DEB_JOIN, \"common rates\", tmp, tmp_size);\n\tlbs_deb_join(\"TX data rate 0x%02x\\n\", priv->cur_rate);\n\n\tif (!priv->auto_rate) {\n\t\tfor (i = 0; i < tmp_size; i++) {\n\t\t\tif (tmp[i] == priv->cur_rate)\n\t\t\t\tgoto done;\n\t\t}\n\t\tlbs_pr_alert(\"Previously set fixed data rate %#x isn't \"\n\t\t       \"compatible with the network.\\n\", priv->cur_rate);\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\tret = 0;\n\ndone:\n\tmemset(rates, 0, *rates_size);\n\t*rates_size = min_t(int, tmp_size, *rates_size);\n\tmemcpy(rates, tmp, *rates_size);\n\treturn ret;\n}", "path": "package\\libertas\\src\\assoc.c", "repo_name": "nilstoedtmann/openwrt-hub", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 69428}
{"docstring": "/**\n *  @brief This function converts Tx/Rx rates from IEEE80211_RADIOTAP_RATE\n *  units (500 Kb/s) into Marvell WLAN format (see Table 8 in Section 3.2.1)\n *\n *  @param rate    Input rate\n *  @return      Output Rate (0 if invalid)\n */\n", "func_signal": "static u32 convert_radiotap_rate_to_mv(u8 rate)", "code": "{\n\tswitch (rate) {\n\tcase 2:\t\t/*   1 Mbps */\n\t\treturn 0 | (1 << 4);\n\tcase 4:\t\t/*   2 Mbps */\n\t\treturn 1 | (1 << 4);\n\tcase 11:\t\t/* 5.5 Mbps */\n\t\treturn 2 | (1 << 4);\n\tcase 22:\t\t/*  11 Mbps */\n\t\treturn 3 | (1 << 4);\n\tcase 12:\t\t/*   6 Mbps */\n\t\treturn 4 | (1 << 4);\n\tcase 18:\t\t/*   9 Mbps */\n\t\treturn 5 | (1 << 4);\n\tcase 24:\t\t/*  12 Mbps */\n\t\treturn 6 | (1 << 4);\n\tcase 36:\t\t/*  18 Mbps */\n\t\treturn 7 | (1 << 4);\n\tcase 48:\t\t/*  24 Mbps */\n\t\treturn 8 | (1 << 4);\n\tcase 72:\t\t/*  36 Mbps */\n\t\treturn 9 | (1 << 4);\n\tcase 96:\t\t/*  48 Mbps */\n\t\treturn 10 | (1 << 4);\n\tcase 108:\t\t/*  54 Mbps */\n\t\treturn 11 | (1 << 4);\n\t}\n\treturn 0;\n}", "path": "package\\libertas\\src\\tx.c", "repo_name": "nilstoedtmann/openwrt-hub", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 69428}
{"docstring": "/*\n * return system type in /proc/cpuinfo\n */\n", "func_signal": "const char *get_system_type(void)", "code": "{\n\tstatic char buf[128];\n\tsnprintf(buf, sizeof (buf), \"bcm63xx/%s (0x%04x/0x%04X)\",\n\t\t board_get_name(),\n\t\t bcm63xx_get_cpu_id(), bcm63xx_get_cpu_rev());\n\treturn buf;\n}", "path": "target\\linux\\brcm63xx\\files\\arch\\mips\\bcm63xx\\setup.c", "repo_name": "nilstoedtmann/openwrt-hub", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 69428}
{"docstring": "/**\n *  @brief Send Deauthentication Request\n *\n *  @param priv      A pointer to struct lbs_private structure\n *  @return          0--success, -1--fail\n */\n", "func_signal": "int lbs_send_deauthentication(struct lbs_private *priv)", "code": "{\n\treturn lbs_prepare_and_send_command(priv, CMD_802_11_DEAUTHENTICATE,\n\t\t\t\t     0, CMD_OPTION_WAITFORRSP, 0, NULL);\n}", "path": "package\\libertas\\src\\assoc.c", "repo_name": "nilstoedtmann/openwrt-hub", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 69428}
{"docstring": "/**\n *  @brief This function prepares command of authenticate.\n *\n *  @param priv      A pointer to struct lbs_private structure\n *  @param cmd       A pointer to cmd_ds_command structure\n *  @param pdata_buf Void cast of pointer to a BSSID to authenticate with\n *\n *  @return         0 or -1\n */\n", "func_signal": "int lbs_cmd_80211_authenticate(struct lbs_private *priv,\n\t\t\t\t struct cmd_ds_command *cmd,\n\t\t\t\t void *pdata_buf)", "code": "{\n\tstruct cmd_ds_802_11_authenticate *pauthenticate = &cmd->params.auth;\n\tint ret = -1;\n\tu8 *bssid = pdata_buf;\n\tDECLARE_MAC_BUF(mac);\n\n\tlbs_deb_enter(LBS_DEB_JOIN);\n\n\tcmd->command = cpu_to_le16(CMD_802_11_AUTHENTICATE);\n\tcmd->size = cpu_to_le16(sizeof(struct cmd_ds_802_11_authenticate)\n\t\t\t+ S_DS_GEN);\n\n\t/* translate auth mode to 802.11 defined wire value */\n\tswitch (priv->secinfo.auth_mode) {\n\tcase IW_AUTH_ALG_OPEN_SYSTEM:\n\t\tpauthenticate->authtype = 0x00;\n\t\tbreak;\n\tcase IW_AUTH_ALG_SHARED_KEY:\n\t\tpauthenticate->authtype = 0x01;\n\t\tbreak;\n\tcase IW_AUTH_ALG_LEAP:\n\t\tpauthenticate->authtype = 0x80;\n\t\tbreak;\n\tdefault:\n\t\tlbs_deb_join(\"AUTH_CMD: invalid auth alg 0x%X\\n\",\n\t\t\tpriv->secinfo.auth_mode);\n\t\tgoto out;\n\t}\n\n\tmemcpy(pauthenticate->macaddr, bssid, ETH_ALEN);\n\n\tlbs_deb_join(\"AUTH_CMD: BSSID %s, auth 0x%x\\n\",\n\t\tprint_mac(mac, bssid), pauthenticate->authtype);\n\tret = 0;\n\nout:\n\tlbs_deb_leave_args(LBS_DEB_JOIN, \"ret %d\", ret);\n\treturn ret;\n}", "path": "package\\libertas\\src\\assoc.c", "repo_name": "nilstoedtmann/openwrt-hub", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 69428}
{"docstring": "/**\n *  @brief This function finds a specific compatible BSSID in the scan list\n *\n *  Used in association code\n *\n *  @param priv  A pointer to struct lbs_private\n *  @param bssid    BSSID to find in the scan list\n *  @param mode     Network mode: Infrastructure or IBSS\n *\n *  @return         index in BSSID list, or error return code (< 0)\n */\n", "func_signal": "static struct bss_descriptor *lbs_find_bssid_in_list(struct lbs_private *priv,\n\t\t\t\t\t      uint8_t *bssid, uint8_t mode)", "code": "{\n\tstruct bss_descriptor *iter_bss;\n\tstruct bss_descriptor *found_bss = NULL;\n\n\tlbs_deb_enter(LBS_DEB_SCAN);\n\n\tif (!bssid)\n\t\tgoto out;\n\n\tlbs_deb_hex(LBS_DEB_SCAN, \"looking for\", bssid, ETH_ALEN);\n\n\t/* Look through the scan table for a compatible match.  The loop will\n\t *   continue past a matched bssid that is not compatible in case there\n\t *   is an AP with multiple SSIDs assigned to the same BSSID\n\t */\n\tmutex_lock(&priv->lock);\n\tlist_for_each_entry(iter_bss, &priv->network_list, list) {\n\t\tif (compare_ether_addr(iter_bss->bssid, bssid))\n\t\t\tcontinue; /* bssid doesn't match */\n\t\tswitch (mode) {\n\t\tcase IW_MODE_INFRA:\n\t\tcase IW_MODE_ADHOC:\n\t\t\tif (!is_network_compatible(priv, iter_bss, mode))\n\t\t\t\tbreak;\n\t\t\tfound_bss = iter_bss;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfound_bss = iter_bss;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&priv->lock);\n\nout:\n\tlbs_deb_leave_args(LBS_DEB_SCAN, \"found_bss %p\", found_bss);\n\treturn found_bss;\n}", "path": "package\\libertas\\src\\assoc.c", "repo_name": "nilstoedtmann/openwrt-hub", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 69428}
{"docstring": "/**\n *  @brief This function checks the conditions and sends packet to IF\n *  layer if everything is ok.\n *\n *  @param priv    A pointer to struct lbs_private structure\n *  @param skb     A pointer to skb which includes TX packet\n *  @return \t   0 or -1\n */\n", "func_signal": "int lbs_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)", "code": "{\n\tunsigned long flags;\n\tstruct lbs_private *priv = dev->priv;\n\tstruct txpd *txpd;\n\tchar *p802x_hdr;\n\tuint16_t pkt_len;\n\tint ret;\n\n\tlbs_deb_enter(LBS_DEB_TX);\n\n\tret = NETDEV_TX_OK;\n\n\t/* We need to protect against the queues being restarted before\n\t   we get round to stopping them */\n\tspin_lock_irqsave(&priv->driver_lock, flags);\n\n\tif (priv->surpriseremoved)\n\t\tgoto free;\n\n\tif (!skb->len || (skb->len > MRVDRV_ETH_TX_PACKET_BUFFER_SIZE)) {\n\t\tlbs_deb_tx(\"tx err: skb length %d 0 or > %zd\\n\",\n\t\t       skb->len, MRVDRV_ETH_TX_PACKET_BUFFER_SIZE);\n\t\t/* We'll never manage to send this one; drop it and return 'OK' */\n\n\t\tpriv->stats.tx_dropped++;\n\t\tpriv->stats.tx_errors++;\n\t\tgoto free;\n\t}\n\n\n\tnetif_stop_queue(priv->dev);\n\tif (priv->mesh_dev)\n\t\tnetif_stop_queue(priv->mesh_dev);\n\n\tif (priv->tx_pending_len) {\n\t\t/* This can happen if packets come in on the mesh and eth\n\t\t   device simultaneously -- there's no mutual exclusion on\n\t\t   hard_start_xmit() calls between devices. */\n\t\tlbs_deb_tx(\"Packet on %s while busy\\n\", dev->name);\n\t\tret = NETDEV_TX_BUSY;\n\t\tgoto unlock;\n\t}\n\n\tpriv->tx_pending_len = -1;\n\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\n\tlbs_deb_hex(LBS_DEB_TX, \"TX Data\", skb->data, min_t(unsigned int, skb->len, 100));\n\n\ttxpd = (void *)priv->tx_pending_buf;\n\tmemset(txpd, 0, sizeof(struct txpd));\n\n\tp802x_hdr = skb->data;\n\tpkt_len = skb->len;\n\n\tif (dev == priv->rtap_net_dev) {\n\t\tstruct tx_radiotap_hdr *rtap_hdr = (void *)skb->data;\n\n\t\t/* set txpd fields from the radiotap header */\n\t\ttxpd->tx_control = cpu_to_le32(convert_radiotap_rate_to_mv(rtap_hdr->rate));\n\n\t\t/* skip the radiotap header */\n\t\tp802x_hdr += sizeof(*rtap_hdr);\n\t\tpkt_len -= sizeof(*rtap_hdr);\n\n\t\t/* copy destination address from 802.11 header */\n\t\tmemcpy(txpd->tx_dest_addr_high, p802x_hdr + 4, ETH_ALEN);\n\t} else {\n\t\t/* copy destination address from 802.3 header */\n\t\tmemcpy(txpd->tx_dest_addr_high, p802x_hdr, ETH_ALEN);\n\t}\n\n\ttxpd->tx_packet_length = cpu_to_le16(pkt_len);\n\ttxpd->tx_packet_location = cpu_to_le32(sizeof(struct txpd));\n\n\tif (dev == priv->mesh_dev)\n\t\ttxpd->tx_control |= cpu_to_le32(TxPD_MESH_FRAME);\n\n\tlbs_deb_hex(LBS_DEB_TX, \"txpd\", (u8 *) &txpd, sizeof(struct txpd));\n\n\tlbs_deb_hex(LBS_DEB_TX, \"Tx Data\", (u8 *) p802x_hdr, le16_to_cpu(txpd->tx_packet_length));\n\n\tmemcpy(&txpd[1], p802x_hdr, le16_to_cpu(txpd->tx_packet_length));\n\n\tspin_lock_irqsave(&priv->driver_lock, flags);\n\tpriv->tx_pending_len = pkt_len + sizeof(struct txpd);\n\n\tlbs_deb_tx(\"%s lined up packet\\n\", __func__);\n\n\tpriv->stats.tx_packets++;\n\tpriv->stats.tx_bytes += skb->len;\n\n\tdev->trans_start = jiffies;\n\n\tif (priv->monitormode) {\n\t\t/* Keep the skb to echo it back once Tx feedback is\n\t\t   received from FW */\n\t\tskb_orphan(skb);\n\n\t\t/* Keep the skb around for when we get feedback */\n\t\tpriv->currenttxskb = skb;\n\t} else {\n free:\n\t\tdev_kfree_skb_any(skb);\n\t}\n unlock:\n\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\twake_up(&priv->waitq);\n\n\tlbs_deb_leave_args(LBS_DEB_TX, \"ret %d\", ret);\n\treturn ret;\n}", "path": "package\\libertas\\src\\tx.c", "repo_name": "nilstoedtmann/openwrt-hub", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 69428}
{"docstring": "/*\n * The functions for inserting/removing us as a module.\n */\n", "func_signal": "static int __init s3c2410ts_probe(struct platform_device *pdev)", "code": "{\n\tint rc;\n\tstruct s3c2410_ts_mach_info *info;\n\tstruct input_dev *input_dev;\n\tint ret = 0;\n\n\tdev_info(&pdev->dev, \"Starting\\n\");\n\n\tinfo = (struct s3c2410_ts_mach_info *)pdev->dev.platform_data;\n\n\tif (!info)\n\t{\n\t\tdev_err(&pdev->dev, \"Hm... too bad: no platform data for ts\\n\");\n\t\treturn -EINVAL;\n\t}\n\n#ifdef CONFIG_TOUCHSCREEN_S3C2410_DEBUG\n\tprintk(DEBUG_LVL \"Entering s3c2410ts_init\\n\");\n#endif\n\n\tadc_clock = clk_get(NULL, \"adc\");\n\tif (!adc_clock) {\n\t\tdev_err(&pdev->dev, \"failed to get adc clock source\\n\");\n\t\treturn -ENOENT;\n\t}\n\tclk_enable(adc_clock);\n\n#ifdef CONFIG_TOUCHSCREEN_S3C2410_DEBUG\n\tprintk(DEBUG_LVL \"got and enabled clock\\n\");\n#endif\n\n\tbase_addr = ioremap(S3C2410_PA_ADC,0x20);\n\tif (base_addr == NULL) {\n\t\tdev_err(&pdev->dev, \"Failed to remap register block\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto bail0;\n\t}\n\n\n\t/* If we acutally are a S3C2410: Configure GPIOs */\n\tif (!strcmp(pdev->name, \"s3c2410-ts\"))\n\t\ts3c2410_ts_connect();\n\n\tif ((info->presc & 0xff) > 0)\n\t\twritel(S3C2410_ADCCON_PRSCEN |\n\t\t       S3C2410_ADCCON_PRSCVL(info->presc&0xFF),\n\t\t\t\t\t\t    base_addr + S3C2410_ADCCON);\n\telse\n\t\twritel(0, base_addr+S3C2410_ADCCON);\n\n\t/* Initialise registers */\n\tif ((info->delay & 0xffff) > 0)\n\t\twritel(info->delay & 0xffff,  base_addr + S3C2410_ADCDLY);\n\n\twritel(WAIT4INT(0), base_addr + S3C2410_ADCTSC);\n\n\t/* Initialise input stuff */\n\tmemset(&ts, 0, sizeof(struct s3c2410ts));\n\tinput_dev = input_allocate_device();\n\n\tif (!input_dev) {\n\t\tdev_err(&pdev->dev, \"Unable to allocate the input device\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto bail1;\n\t}\n\n\tts.dev = input_dev;\n\tts.dev->evbit[0] = BIT_MASK(EV_SYN) | BIT_MASK(EV_KEY) |\n\t\t\t   BIT_MASK(EV_ABS);\n\tts.dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\n\tinput_set_abs_params(ts.dev, ABS_X, 0, 0x3FF, 0, 0);\n\tinput_set_abs_params(ts.dev, ABS_Y, 0, 0x3FF, 0, 0);\n\tinput_set_abs_params(ts.dev, ABS_PRESSURE, 0, 1, 0, 0);\n\n\tts.dev->name = s3c2410ts_name;\n\tts.dev->id.bustype = BUS_RS232;\n\tts.dev->id.vendor = 0xDEAD;\n\tts.dev->id.product = 0xBEEF;\n\tts.dev->id.version = S3C2410TSVERSION;\n\tts.state = TS_STATE_STANDBY;\n\tts.event_fifo = kfifo_alloc(TS_EVENT_FIFO_SIZE, GFP_KERNEL, NULL);\n\tif (IS_ERR(ts.event_fifo)) {\n\t\tret = -EIO;\n\t\tgoto bail2;\n\t}\n\n\t/* create the filter chain set up for the 2 coordinates we produce */\n\tts.chain = ts_filter_chain_create(pdev, info->filter_config, 2);\n\n\tif (IS_ERR(ts.chain))\n\t\tgoto bail2;\n\n\tts_filter_chain_clear(ts.chain);\n\n\t/* Get irqs */\n\tif (request_irq(IRQ_ADC, stylus_action, IRQF_SAMPLE_RANDOM,\n\t\t\t\t\t\t    \"s3c2410_action\", ts.dev)) {\n\t\tdev_err(&pdev->dev, \"Could not allocate ts IRQ_ADC !\\n\");\n\t\tiounmap(base_addr);\n\t\tret = -EIO;\n\t\tgoto bail3;\n\t}\n\tif (request_irq(IRQ_TC, stylus_updown, IRQF_SAMPLE_RANDOM,\n\t\t\t\"s3c2410_action\", ts.dev)) {\n\t\tdev_err(&pdev->dev, \"Could not allocate ts IRQ_TC !\\n\");\n\t\tfree_irq(IRQ_ADC, ts.dev);\n\t\tiounmap(base_addr);\n\t\tret = -EIO;\n\t\tgoto bail4;\n\t}\n\n\tdev_info(&pdev->dev, \"Successfully loaded\\n\");\n\n\t/* All went ok, so register to the input system */\n\trc = input_register_device(ts.dev);\n\tif (rc) {\n\t\tret = -EIO;\n\t\tgoto bail5;\n\t}\n\n\treturn 0;\n\nbail5:\n\tfree_irq(IRQ_TC, ts.dev);\n\tfree_irq(IRQ_ADC, ts.dev);\n\tclk_disable(adc_clock);\n\tiounmap(base_addr);\n\tdisable_irq(IRQ_TC);\nbail4:\n\tdisable_irq(IRQ_ADC);\nbail3:\n\tts_filter_chain_destroy(ts.chain);\n\tkfifo_free(ts.event_fifo);\nbail2:\n\tinput_unregister_device(ts.dev);\nbail1:\n\tiounmap(base_addr);\nbail0:\n\n\treturn ret;\n}", "path": "target\\linux\\s3c24xx\\files-2.6.30\\drivers\\input\\touchscreen\\s3c2410_ts.c", "repo_name": "nilstoedtmann/openwrt-hub", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 69428}
{"docstring": "/*\n * Copied from mtdblock.c\n *\n * Cache stuff...\n * \n * Since typical flash erasable sectors are much larger than what Linux's\n * buffer cache can handle, we must implement read-modify-write on flash\n * sectors for each block write requests.  To avoid over-erasing flash sectors\n * and to speed things up, we locally cache a whole flash sector while it is\n * being written to until a different sector is required.\n */\n", "func_signal": "static void erase_callback(struct erase_info *done)", "code": "{\n\twait_queue_head_t *wait_q = (wait_queue_head_t *)done->priv;\n\twake_up(wait_q);\n}", "path": "target\\linux\\brcm47xx\\files\\drivers\\mtd\\maps\\bcm47xx-flash.c", "repo_name": "nilstoedtmann/openwrt-hub", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 69428}
{"docstring": "/*\n * attempt to detect the amount of memory installed\n */\n", "func_signal": "static unsigned int detect_memory_size(void)", "code": "{\n\tunsigned int cols = 0, rows = 0, is_32bits = 0, banks = 0;\n\tu32 val;\n\n\tif (BCMCPU_IS_6345())\n\t\treturn (8 * 1024 * 1024);\n\n\tif (BCMCPU_IS_6338() || BCMCPU_IS_6348()) {\n\t\tval = bcm_sdram_readl(SDRAM_CFG_REG);\n\t\trows = (val & SDRAM_CFG_ROW_MASK) >> SDRAM_CFG_ROW_SHIFT;\n\t\tcols = (val & SDRAM_CFG_COL_MASK) >> SDRAM_CFG_COL_SHIFT;\n\t\tis_32bits = (val & SDRAM_CFG_32B_MASK) ? 1 : 0;\n\t\tbanks = (val & SDRAM_CFG_BANK_MASK) ? 2 : 1;\n\t}\n\n\tif (BCMCPU_IS_6358()) {\n\t\tval = bcm_memc_readl(MEMC_CFG_REG);\n\t\trows = (val & MEMC_CFG_ROW_MASK) >> MEMC_CFG_ROW_SHIFT;\n\t\tcols = (val & MEMC_CFG_COL_MASK) >> MEMC_CFG_COL_SHIFT;\n\t\tis_32bits = (val & MEMC_CFG_32B_MASK) ? 0 : 1;\n\t\tbanks = 2;\n\t}\n\n\t/* 0 => 11 address bits ... 2 => 13 address bits */\n\trows += 11;\n\n\t/* 0 => 8 address bits ... 2 => 10 address bits */\n\tcols += 8;\n\n\treturn 1 << (cols + rows + (is_32bits + 1) + banks);\n}", "path": "target\\linux\\brcm63xx\\files\\arch\\mips\\bcm63xx\\cpu.c", "repo_name": "nilstoedtmann/openwrt-hub", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 69428}
{"docstring": "/**\n *  @brief This function finds the best SSID in the Scan List\n *\n *  Search the scan table for the best SSID that also matches the current\n *   adapter network preference (infrastructure or adhoc)\n *\n *  @param priv  A pointer to struct lbs_private\n *\n *  @return         index in BSSID list\n */\n", "func_signal": "static struct bss_descriptor *lbs_find_best_ssid_in_list(\n\tstruct lbs_private *priv, uint8_t mode)", "code": "{\n\tuint8_t bestrssi = 0;\n\tstruct bss_descriptor *iter_bss;\n\tstruct bss_descriptor *best_bss = NULL;\n\n\tlbs_deb_enter(LBS_DEB_SCAN);\n\n\tmutex_lock(&priv->lock);\n\n\tlist_for_each_entry(iter_bss, &priv->network_list, list) {\n\t\tswitch (mode) {\n\t\tcase IW_MODE_INFRA:\n\t\tcase IW_MODE_ADHOC:\n\t\t\tif (!is_network_compatible(priv, iter_bss, mode))\n\t\t\t\tbreak;\n\t\t\tif (SCAN_RSSI(iter_bss->rssi) <= bestrssi)\n\t\t\t\tbreak;\n\t\t\tbestrssi = SCAN_RSSI(iter_bss->rssi);\n\t\t\tbest_bss = iter_bss;\n\t\t\tbreak;\n\t\tcase IW_MODE_AUTO:\n\t\tdefault:\n\t\t\tif (SCAN_RSSI(iter_bss->rssi) <= bestrssi)\n\t\t\t\tbreak;\n\t\t\tbestrssi = SCAN_RSSI(iter_bss->rssi);\n\t\t\tbest_bss = iter_bss;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&priv->lock);\n\tlbs_deb_leave_args(LBS_DEB_SCAN, \"best_bss %p\", best_bss);\n\treturn best_bss;\n}", "path": "package\\libertas\\src\\assoc.c", "repo_name": "nilstoedtmann/openwrt-hub", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 69428}
{"docstring": "/**\n *  @brief This function sends to the host the last transmitted packet,\n *  filling the radiotap headers with transmission information.\n *\n *  @param priv     A pointer to struct lbs_private structure\n *  @param status   A 32 bit value containing transmission status.\n *\n *  @returns void\n */\n", "func_signal": "void lbs_send_tx_feedback(struct lbs_private *priv, u32 try_count)", "code": "{\n\tstruct tx_radiotap_hdr *radiotap_hdr;\n\n\tif (!priv->monitormode || priv->currenttxskb == NULL)\n\t\treturn;\n\n\tradiotap_hdr = (struct tx_radiotap_hdr *)priv->currenttxskb->data;\n\n\tradiotap_hdr->data_retries = try_count ?\n\t\t(1 + priv->txretrycount - try_count) : 0;\n\n\tpriv->currenttxskb->protocol = eth_type_trans(priv->currenttxskb,\n\t\t\t\t\t\t      priv->rtap_net_dev);\n\tnetif_rx(priv->currenttxskb);\n\n\tpriv->currenttxskb = NULL;\n\n\tif (priv->connect_status == LBS_CONNECTED)\n\t\tnetif_wake_queue(priv->dev);\n\n\tif (priv->mesh_dev && (priv->mesh_connect_status == LBS_CONNECTED))\n\t\tnetif_wake_queue(priv->mesh_dev);\n}", "path": "package\\libertas\\src\\tx.c", "repo_name": "nilstoedtmann/openwrt-hub", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 69428}
{"docstring": "/**\n *  @brief Sets the MSB on basic rates as the firmware requires\n *\n * Scan through an array and set the MSB for basic data rates.\n *\n *  @param rates     buffer of data rates\n *  @param len       size of buffer\n */\n", "func_signal": "static void lbs_set_basic_rate_flags(u8 *rates, size_t len)", "code": "{\n\tint i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (rates[i] == 0x02 || rates[i] == 0x04 ||\n\t\t    rates[i] == 0x0b || rates[i] == 0x16)\n\t\t\trates[i] |= 0x80;\n\t}\n}", "path": "package\\libertas\\src\\assoc.c", "repo_name": "nilstoedtmann/openwrt-hub", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 69428}
{"docstring": "/*\n * Convert some rows of samples to the output colorspace.\n *\n * Note that we change from noninterleaved, one-plane-per-component format\n * to interleaved-pixel format.  The output buffer is therefore three times\n * as wide as the input buffer.\n * A starting row offset is provided only for the input buffer.  The caller\n * can easily adjust the passed output_buf value to accommodate any row\n * offset required on that side.\n */\n", "func_signal": "METHODDEF(void)\nycc_rgb_convert (j_decompress_ptr cinfo,\n\t\t JSAMPIMAGE input_buf, JDIMENSION input_row,\n\t\t JSAMPARRAY output_buf, int num_rows)", "code": "{\n  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;\n  register int y, cb, cr;\n  register JSAMPROW outptr;\n  register JSAMPROW inptr0, inptr1, inptr2;\n  register JDIMENSION col;\n  JDIMENSION num_cols = cinfo->output_width;\n  /* copy these pointers into registers if possible */\n  register JSAMPLE * range_limit = cinfo->sample_range_limit;\n  register int * Crrtab = cconvert->Cr_r_tab;\n  register int * Cbbtab = cconvert->Cb_b_tab;\n  register INT32 * Crgtab = cconvert->Cr_g_tab;\n  register INT32 * Cbgtab = cconvert->Cb_g_tab;\n  SHIFT_TEMPS\n\n  while (--num_rows >= 0) {\n    inptr0 = input_buf[0][input_row];\n    inptr1 = input_buf[1][input_row];\n    inptr2 = input_buf[2][input_row];\n    input_row++;\n    outptr = *output_buf++;\n    for (col = 0; col < num_cols; col++) {\n      y  = GETJSAMPLE(inptr0[col]);\n      cb = GETJSAMPLE(inptr1[col]);\n      cr = GETJSAMPLE(inptr2[col]);\n      /* Range-limiting is essential due to noise introduced by DCT losses. */\n      outptr[RGB_RED] =   range_limit[y + Crrtab[cr]];\n      outptr[RGB_GREEN] = range_limit[y +\n\t\t\t      ((int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr],\n\t\t\t\t\t\t SCALEBITS))];\n      outptr[RGB_BLUE] =  range_limit[y + Cbbtab[cb]];\n      outptr += RGB_PIXELSIZE;\n    }\n  }\n}", "path": "jdcolor.c", "repo_name": "zsx/jpeg", "stars": 1, "license": "None", "language": "c", "size": 1052}
{"docstring": "/*\n * Adobe-style YCCK->CMYK conversion.\n * We convert YCbCr to R=1-C, G=1-M, and B=1-Y using the same\n * conversion as above, while passing K (black) unchanged.\n * We assume build_ycc_rgb_table has been called.\n */\n", "func_signal": "METHODDEF(void)\nycck_cmyk_convert (j_decompress_ptr cinfo,\n\t\t   JSAMPIMAGE input_buf, JDIMENSION input_row,\n\t\t   JSAMPARRAY output_buf, int num_rows)", "code": "{\n  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;\n  register int y, cb, cr;\n  register JSAMPROW outptr;\n  register JSAMPROW inptr0, inptr1, inptr2, inptr3;\n  register JDIMENSION col;\n  JDIMENSION num_cols = cinfo->output_width;\n  /* copy these pointers into registers if possible */\n  register JSAMPLE * range_limit = cinfo->sample_range_limit;\n  register int * Crrtab = cconvert->Cr_r_tab;\n  register int * Cbbtab = cconvert->Cb_b_tab;\n  register INT32 * Crgtab = cconvert->Cr_g_tab;\n  register INT32 * Cbgtab = cconvert->Cb_g_tab;\n  SHIFT_TEMPS\n\n  while (--num_rows >= 0) {\n    inptr0 = input_buf[0][input_row];\n    inptr1 = input_buf[1][input_row];\n    inptr2 = input_buf[2][input_row];\n    inptr3 = input_buf[3][input_row];\n    input_row++;\n    outptr = *output_buf++;\n    for (col = 0; col < num_cols; col++) {\n      y  = GETJSAMPLE(inptr0[col]);\n      cb = GETJSAMPLE(inptr1[col]);\n      cr = GETJSAMPLE(inptr2[col]);\n      /* Range-limiting is essential due to noise introduced by DCT losses. */\n      outptr[0] = range_limit[MAXJSAMPLE - (y + Crrtab[cr])];\t/* red */\n      outptr[1] = range_limit[MAXJSAMPLE - (y +\t\t\t/* green */\n\t\t\t      ((int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr],\n\t\t\t\t\t\t SCALEBITS)))];\n      outptr[2] = range_limit[MAXJSAMPLE - (y + Cbbtab[cb])];\t/* blue */\n      /* K passes through unchanged */\n      outptr[3] = inptr3[col];\t/* don't need GETJSAMPLE here */\n      outptr += 4;\n    }\n  }\n}", "path": "jdcolor.c", "repo_name": "zsx/jpeg", "stars": 1, "license": "None", "language": "c", "size": 1052}
{"docstring": "/*\n * Create a recommended progressive-JPEG script.\n * cinfo->num_components and cinfo->jpeg_color_space must be correct.\n */\n", "func_signal": "GLOBAL(void)\njpeg_simple_progression (j_compress_ptr cinfo)", "code": "{\n  int ncomps = cinfo->num_components;\n  int nscans;\n  jpeg_scan_info * scanptr;\n\n  /* Safety check to ensure start_compress not called yet. */\n  if (cinfo->global_state != CSTATE_START)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n\n  /* Figure space needed for script.  Calculation must match code below! */\n  if (ncomps == 3 && cinfo->jpeg_color_space == JCS_YCbCr) {\n    /* Custom script for YCbCr color images. */\n    nscans = 10;\n  } else {\n    /* All-purpose script for other color spaces. */\n    if (ncomps > MAX_COMPS_IN_SCAN)\n      nscans = 6 * ncomps;\t/* 2 DC + 4 AC scans per component */\n    else\n      nscans = 2 + 4 * ncomps;\t/* 2 DC scans; 4 AC scans per component */\n  }\n\n  /* Allocate space for script.\n   * We need to put it in the permanent pool in case the application performs\n   * multiple compressions without changing the settings.  To avoid a memory\n   * leak if jpeg_simple_progression is called repeatedly for the same JPEG\n   * object, we try to re-use previously allocated space, and we allocate\n   * enough space to handle YCbCr even if initially asked for grayscale.\n   */\n  if (cinfo->script_space == NULL || cinfo->script_space_size < nscans) {\n    cinfo->script_space_size = MAX(nscans, 10);\n    cinfo->script_space = (jpeg_scan_info *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,\n\t\t\tcinfo->script_space_size * SIZEOF(jpeg_scan_info));\n  }\n  scanptr = cinfo->script_space;\n  cinfo->scan_info = scanptr;\n  cinfo->num_scans = nscans;\n\n  if (ncomps == 3 && cinfo->jpeg_color_space == JCS_YCbCr) {\n    /* Custom script for YCbCr color images. */\n    /* Initial DC scan */\n    scanptr = fill_dc_scans(scanptr, ncomps, 0, 1);\n    /* Initial AC scan: get some luma data out in a hurry */\n    scanptr = fill_a_scan(scanptr, 0, 1, 5, 0, 2);\n    /* Chroma data is too small to be worth expending many scans on */\n    scanptr = fill_a_scan(scanptr, 2, 1, 63, 0, 1);\n    scanptr = fill_a_scan(scanptr, 1, 1, 63, 0, 1);\n    /* Complete spectral selection for luma AC */\n    scanptr = fill_a_scan(scanptr, 0, 6, 63, 0, 2);\n    /* Refine next bit of luma AC */\n    scanptr = fill_a_scan(scanptr, 0, 1, 63, 2, 1);\n    /* Finish DC successive approximation */\n    scanptr = fill_dc_scans(scanptr, ncomps, 1, 0);\n    /* Finish AC successive approximation */\n    scanptr = fill_a_scan(scanptr, 2, 1, 63, 1, 0);\n    scanptr = fill_a_scan(scanptr, 1, 1, 63, 1, 0);\n    /* Luma bottom bit comes last since it's usually largest scan */\n    scanptr = fill_a_scan(scanptr, 0, 1, 63, 1, 0);\n  } else {\n    /* All-purpose script for other color spaces. */\n    /* Successive approximation first pass */\n    scanptr = fill_dc_scans(scanptr, ncomps, 0, 1);\n    scanptr = fill_scans(scanptr, ncomps, 1, 5, 0, 2);\n    scanptr = fill_scans(scanptr, ncomps, 6, 63, 0, 2);\n    /* Successive approximation second pass */\n    scanptr = fill_scans(scanptr, ncomps, 1, 63, 2, 1);\n    /* Successive approximation final pass */\n    scanptr = fill_dc_scans(scanptr, ncomps, 1, 0);\n    scanptr = fill_scans(scanptr, ncomps, 1, 63, 1, 0);\n  }\n}", "path": "jcparam.c", "repo_name": "zsx/jpeg", "stars": 1, "license": "None", "language": "c", "size": 1052}
{"docstring": "/*\n * Initialize main buffer controller.\n */\n", "func_signal": "GLOBAL(void)\njinit_d_main_controller (j_decompress_ptr cinfo, boolean need_full_buffer)", "code": "{\n  my_main_ptr main;\n  int ci, rgroup, ngroups;\n  jpeg_component_info *compptr;\n\n  main = (my_main_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\tSIZEOF(my_main_controller));\n  cinfo->main = (struct jpeg_d_main_controller *) main;\n  main->pub.start_pass = start_pass_main;\n\n  if (need_full_buffer)\t\t/* shouldn't happen */\n    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);\n\n  /* Allocate the workspace.\n   * ngroups is the number of row groups we need.\n   */\n  if (cinfo->upsample->need_context_rows) {\n    if (cinfo->min_DCT_v_scaled_size < 2) /* unsupported, see comments above */\n      ERREXIT(cinfo, JERR_NOTIMPL);\n    alloc_funny_pointers(cinfo); /* Alloc space for xbuffer[] lists */\n    ngroups = cinfo->min_DCT_v_scaled_size + 2;\n  } else {\n    ngroups = cinfo->min_DCT_v_scaled_size;\n  }\n\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n       ci++, compptr++) {\n    rgroup = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /\n      cinfo->min_DCT_v_scaled_size; /* height of a row group of component */\n    main->buffer[ci] = (*cinfo->mem->alloc_sarray)\n\t\t\t((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t compptr->width_in_blocks * compptr->DCT_h_scaled_size,\n\t\t\t (JDIMENSION) (rgroup * ngroups));\n  }\n}", "path": "jdmainct.c", "repo_name": "zsx/jpeg", "stars": 1, "license": "None", "language": "c", "size": 1052}
{"docstring": "/*\n * Initialize the marker writer module.\n */\n", "func_signal": "GLOBAL(void)\njinit_marker_writer (j_compress_ptr cinfo)", "code": "{\n  my_marker_ptr marker;\n\n  /* Create the subobject */\n  marker = (my_marker_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\tSIZEOF(my_marker_writer));\n  cinfo->marker = (struct jpeg_marker_writer *) marker;\n  /* Initialize method pointers */\n  marker->pub.write_file_header = write_file_header;\n  marker->pub.write_frame_header = write_frame_header;\n  marker->pub.write_scan_header = write_scan_header;\n  marker->pub.write_file_trailer = write_file_trailer;\n  marker->pub.write_tables_only = write_tables_only;\n  marker->pub.write_marker_header = write_marker_header;\n  marker->pub.write_marker_byte = write_marker_byte;\n  /* Initialize private state */\n  marker->last_restart_interval = 0;\n}", "path": "jcmarker.c", "repo_name": "zsx/jpeg", "stars": 1, "license": "None", "language": "c", "size": 1052}
{"docstring": "/*\n * Color conversion for grayscale: just copy the data.\n * This also works for YCbCr -> grayscale conversion, in which\n * we just copy the Y (luminance) component and ignore chrominance.\n */\n", "func_signal": "METHODDEF(void)\ngrayscale_convert (j_decompress_ptr cinfo,\n\t\t   JSAMPIMAGE input_buf, JDIMENSION input_row,\n\t\t   JSAMPARRAY output_buf, int num_rows)", "code": "{\n  jcopy_sample_rows(input_buf[0], (int) input_row, output_buf, 0,\n\t\t    num_rows, cinfo->output_width);\n}", "path": "jdcolor.c", "repo_name": "zsx/jpeg", "stars": 1, "license": "None", "language": "c", "size": 1052}
{"docstring": "/*\n * Color conversion for no colorspace change: just copy the data,\n * converting from separate-planes to interleaved representation.\n */\n", "func_signal": "METHODDEF(void)\nnull_convert (j_decompress_ptr cinfo,\n\t      JSAMPIMAGE input_buf, JDIMENSION input_row,\n\t      JSAMPARRAY output_buf, int num_rows)", "code": "{\n  register JSAMPROW inptr, outptr;\n  register JDIMENSION count;\n  register int num_components = cinfo->num_components;\n  JDIMENSION num_cols = cinfo->output_width;\n  int ci;\n\n  while (--num_rows >= 0) {\n    for (ci = 0; ci < num_components; ci++) {\n      inptr = input_buf[ci][input_row];\n      outptr = output_buf[0] + ci;\n      for (count = num_cols; count > 0; count--) {\n\t*outptr = *inptr++;\t/* needn't bother with GETJSAMPLE() here */\n\toutptr += num_components;\n      }\n    }\n    input_row++;\n    output_buf++;\n  }\n}", "path": "jdcolor.c", "repo_name": "zsx/jpeg", "stars": 1, "license": "None", "language": "c", "size": 1052}
{"docstring": "/*\n * Select an appropriate JPEG colorspace for in_color_space.\n */\n", "func_signal": "GLOBAL(void)\njpeg_default_colorspace (j_compress_ptr cinfo)", "code": "{\n  switch (cinfo->in_color_space) {\n  case JCS_GRAYSCALE:\n    jpeg_set_colorspace(cinfo, JCS_GRAYSCALE);\n    break;\n  case JCS_RGB:\n    jpeg_set_colorspace(cinfo, JCS_YCbCr);\n    break;\n  case JCS_YCbCr:\n    jpeg_set_colorspace(cinfo, JCS_YCbCr);\n    break;\n  case JCS_CMYK:\n    jpeg_set_colorspace(cinfo, JCS_CMYK); /* By default, no translation */\n    break;\n  case JCS_YCCK:\n    jpeg_set_colorspace(cinfo, JCS_YCCK);\n    break;\n  case JCS_UNKNOWN:\n    jpeg_set_colorspace(cinfo, JCS_UNKNOWN);\n    break;\n  default:\n    ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n  }\n}", "path": "jcparam.c", "repo_name": "zsx/jpeg", "stars": 1, "license": "None", "language": "c", "size": 1052}
{"docstring": "/*\n * Initialize tables for YCC->RGB colorspace conversion.\n */\n", "func_signal": "LOCAL(void)\nbuild_ycc_rgb_table (j_decompress_ptr cinfo)", "code": "{\n  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;\n  int i;\n  INT32 x;\n  SHIFT_TEMPS\n\n  cconvert->Cr_r_tab = (int *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\t(MAXJSAMPLE+1) * SIZEOF(int));\n  cconvert->Cb_b_tab = (int *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\t(MAXJSAMPLE+1) * SIZEOF(int));\n  cconvert->Cr_g_tab = (INT32 *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\t(MAXJSAMPLE+1) * SIZEOF(INT32));\n  cconvert->Cb_g_tab = (INT32 *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\t(MAXJSAMPLE+1) * SIZEOF(INT32));\n\n  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {\n    /* i is the actual input pixel value, in the range 0..MAXJSAMPLE */\n    /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */\n    /* Cr=>R value is nearest int to 1.40200 * x */\n    cconvert->Cr_r_tab[i] = (int)\n\t\t    RIGHT_SHIFT(FIX(1.40200) * x + ONE_HALF, SCALEBITS);\n    /* Cb=>B value is nearest int to 1.77200 * x */\n    cconvert->Cb_b_tab[i] = (int)\n\t\t    RIGHT_SHIFT(FIX(1.77200) * x + ONE_HALF, SCALEBITS);\n    /* Cr=>G value is scaled-up -0.71414 * x */\n    cconvert->Cr_g_tab[i] = (- FIX(0.71414)) * x;\n    /* Cb=>G value is scaled-up -0.34414 * x */\n    /* We also add in ONE_HALF so that need not do it in inner loop */\n    cconvert->Cb_g_tab[i] = (- FIX(0.34414)) * x + ONE_HALF;\n  }\n}", "path": "jdcolor.c", "repo_name": "zsx/jpeg", "stars": 1, "license": "None", "language": "c", "size": 1052}
{"docstring": "/*\n * Process some data.\n * This handles the simple case where no context is required.\n */\n", "func_signal": "METHODDEF(void)\nprocess_data_simple_main (j_decompress_ptr cinfo,\n\t\t\t  JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,\n\t\t\t  JDIMENSION out_rows_avail)", "code": "{\n  my_main_ptr main = (my_main_ptr) cinfo->main;\n  JDIMENSION rowgroups_avail;\n\n  /* Read input data if we haven't filled the main buffer yet */\n  if (! main->buffer_full) {\n    if (! (*cinfo->coef->decompress_data) (cinfo, main->buffer))\n      return;\t\t\t/* suspension forced, can do nothing more */\n    main->buffer_full = TRUE;\t/* OK, we have an iMCU row to work with */\n  }\n\n  /* There are always min_DCT_scaled_size row groups in an iMCU row. */\n  rowgroups_avail = (JDIMENSION) cinfo->min_DCT_v_scaled_size;\n  /* Note: at the bottom of the image, we may pass extra garbage row groups\n   * to the postprocessor.  The postprocessor has to check for bottom\n   * of image anyway (at row resolution), so no point in us doing it too.\n   */\n\n  /* Feed the postprocessor */\n  (*cinfo->post->post_process_data) (cinfo, main->buffer,\n\t\t\t\t     &main->rowgroup_ctr, rowgroups_avail,\n\t\t\t\t     output_buf, out_row_ctr, out_rows_avail);\n\n  /* Has postprocessor consumed all the data yet? If so, mark buffer empty */\n  if (main->rowgroup_ctr >= rowgroups_avail) {\n    main->buffer_full = FALSE;\n    main->rowgroup_ctr = 0;\n  }\n}", "path": "jdmainct.c", "repo_name": "zsx/jpeg", "stars": 1, "license": "None", "language": "c", "size": 1052}
{"docstring": "/*\n * Write an abbreviated table-specification datastream.\n * This consists of SOI, DQT and DHT tables, and EOI.\n * Any table that is defined and not marked sent_table = TRUE will be\n * emitted.  Note that all tables will be marked sent_table = TRUE at exit.\n */\n", "func_signal": "METHODDEF(void)\nwrite_tables_only (j_compress_ptr cinfo)", "code": "{\n  int i;\n\n  emit_marker(cinfo, M_SOI);\n\n  for (i = 0; i < NUM_QUANT_TBLS; i++) {\n    if (cinfo->quant_tbl_ptrs[i] != NULL)\n      (void) emit_dqt(cinfo, i);\n  }\n\n  if (! cinfo->arith_code) {\n    for (i = 0; i < NUM_HUFF_TBLS; i++) {\n      if (cinfo->dc_huff_tbl_ptrs[i] != NULL)\n\temit_dht(cinfo, i, FALSE);\n      if (cinfo->ac_huff_tbl_ptrs[i] != NULL)\n\temit_dht(cinfo, i, TRUE);\n    }\n  }\n\n  emit_marker(cinfo, M_EOI);\n}", "path": "jcmarker.c", "repo_name": "zsx/jpeg", "stars": 1, "license": "None", "language": "c", "size": 1052}
{"docstring": "/*\n * Default parameter setup for compression.\n *\n * Applications that don't choose to use this routine must do their\n * own setup of all these parameters.  Alternately, you can call this\n * to establish defaults and then alter parameters selectively.  This\n * is the recommended approach since, if we add any new parameters,\n * your code will still work (they'll be set to reasonable defaults).\n */\n", "func_signal": "GLOBAL(void)\njpeg_set_defaults (j_compress_ptr cinfo)", "code": "{\n  int i;\n\n  /* Safety check to ensure start_compress not called yet. */\n  if (cinfo->global_state != CSTATE_START)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n\n  /* Allocate comp_info array large enough for maximum component count.\n   * Array is made permanent in case application wants to compress\n   * multiple images at same param settings.\n   */\n  if (cinfo->comp_info == NULL)\n    cinfo->comp_info = (jpeg_component_info *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,\n\t\t\t\t  MAX_COMPONENTS * SIZEOF(jpeg_component_info));\n\n  /* Initialize everything not dependent on the color space */\n\n  cinfo->scale_num = 1;\t\t/* 1:1 scaling */\n  cinfo->scale_denom = 1;\n  cinfo->data_precision = BITS_IN_JSAMPLE;\n  /* Set up two quantization tables using default quality of 75 */\n  jpeg_set_quality(cinfo, 75, TRUE);\n  /* Set up two Huffman tables */\n  std_huff_tables(cinfo);\n\n  /* Initialize default arithmetic coding conditioning */\n  for (i = 0; i < NUM_ARITH_TBLS; i++) {\n    cinfo->arith_dc_L[i] = 0;\n    cinfo->arith_dc_U[i] = 1;\n    cinfo->arith_ac_K[i] = 5;\n  }\n\n  /* Default is no multiple-scan output */\n  cinfo->scan_info = NULL;\n  cinfo->num_scans = 0;\n\n  /* Expect normal source image, not raw downsampled data */\n  cinfo->raw_data_in = FALSE;\n\n  /* Use Huffman coding, not arithmetic coding, by default */\n  cinfo->arith_code = FALSE;\n\n  /* By default, don't do extra passes to optimize entropy coding */\n  cinfo->optimize_coding = FALSE;\n  /* The standard Huffman tables are only valid for 8-bit data precision.\n   * If the precision is higher, force optimization on so that usable\n   * tables will be computed.  This test can be removed if default tables\n   * are supplied that are valid for the desired precision.\n   */\n  if (cinfo->data_precision > 8)\n    cinfo->optimize_coding = TRUE;\n\n  /* By default, use the simpler non-cosited sampling alignment */\n  cinfo->CCIR601_sampling = FALSE;\n\n  /* By default, apply fancy downsampling */\n  cinfo->do_fancy_downsampling = TRUE;\n\n  /* No input smoothing */\n  cinfo->smoothing_factor = 0;\n\n  /* DCT algorithm preference */\n  cinfo->dct_method = JDCT_DEFAULT;\n\n  /* No restart markers */\n  cinfo->restart_interval = 0;\n  cinfo->restart_in_rows = 0;\n\n  /* Fill in default JFIF marker parameters.  Note that whether the marker\n   * will actually be written is determined by jpeg_set_colorspace.\n   *\n   * By default, the library emits JFIF version code 1.01.\n   * An application that wants to emit JFIF 1.02 extension markers should set\n   * JFIF_minor_version to 2.  We could probably get away with just defaulting\n   * to 1.02, but there may still be some decoders in use that will complain\n   * about that; saying 1.01 should minimize compatibility problems.\n   */\n  cinfo->JFIF_major_version = 1; /* Default JFIF version = 1.01 */\n  cinfo->JFIF_minor_version = 1;\n  cinfo->density_unit = 0;\t/* Pixel size is unknown by default */\n  cinfo->X_density = 1;\t\t/* Pixel aspect ratio is square by default */\n  cinfo->Y_density = 1;\n\n  /* Choose JPEG colorspace based on input space, set defaults accordingly */\n\n  jpeg_default_colorspace(cinfo);\n}", "path": "jcparam.c", "repo_name": "zsx/jpeg", "stars": 1, "license": "None", "language": "c", "size": 1052}
{"docstring": "/*\n * Write scan header.\n * This consists of DHT or DAC markers, optional DRI, and SOS.\n * Compressed data will be written following the SOS.\n */\n", "func_signal": "METHODDEF(void)\nwrite_scan_header (j_compress_ptr cinfo)", "code": "{\n  my_marker_ptr marker = (my_marker_ptr) cinfo->marker;\n  int i;\n  jpeg_component_info *compptr;\n\n  if (cinfo->arith_code) {\n    /* Emit arith conditioning info.  We may have some duplication\n     * if the file has multiple scans, but it's so small it's hardly\n     * worth worrying about.\n     */\n    emit_dac(cinfo);\n  } else {\n    /* Emit Huffman tables.\n     * Note that emit_dht() suppresses any duplicate tables.\n     */\n    for (i = 0; i < cinfo->comps_in_scan; i++) {\n      compptr = cinfo->cur_comp_info[i];\n      if (cinfo->progressive_mode) {\n\t/* Progressive mode: only DC or only AC tables are used in one scan */\n\tif (cinfo->Ss == 0) {\n\t  if (cinfo->Ah == 0)\t/* DC needs no table for refinement scan */\n\t    emit_dht(cinfo, compptr->dc_tbl_no, FALSE);\n\t} else {\n\t  emit_dht(cinfo, compptr->ac_tbl_no, TRUE);\n\t}\n      } else {\n\t/* Sequential mode: need both DC and AC tables */\n\temit_dht(cinfo, compptr->dc_tbl_no, FALSE);\n\temit_dht(cinfo, compptr->ac_tbl_no, TRUE);\n      }\n    }\n  }\n\n  /* Emit DRI if required --- note that DRI value could change for each scan.\n   * We avoid wasting space with unnecessary DRIs, however.\n   */\n  if (cinfo->restart_interval != marker->last_restart_interval) {\n    emit_dri(cinfo);\n    marker->last_restart_interval = cinfo->restart_interval;\n  }\n\n  emit_sos(cinfo);\n}", "path": "jcmarker.c", "repo_name": "zsx/jpeg", "stars": 1, "license": "None", "language": "c", "size": 1052}
{"docstring": "/*\n * Master selection of compression modules.\n * This is done once at the start of processing an image.  We determine\n * which modules will be used and give them appropriate initialization calls.\n */\n", "func_signal": "GLOBAL(void)\njinit_compress_master (j_compress_ptr cinfo)", "code": "{\n  /* Initialize master control (includes parameter checking/processing) */\n  jinit_c_master_control(cinfo, FALSE /* full compression */);\n\n  /* Preprocessing */\n  if (! cinfo->raw_data_in) {\n    jinit_color_converter(cinfo);\n    jinit_downsampler(cinfo);\n    jinit_c_prep_controller(cinfo, FALSE /* never need full buffer here */);\n  }\n  /* Forward DCT */\n  jinit_forward_dct(cinfo);\n  /* Entropy encoding: either Huffman or arithmetic coding. */\n  if (cinfo->arith_code)\n    jinit_arith_encoder(cinfo);\n  else {\n    jinit_huff_encoder(cinfo);\n  }\n\n  /* Need a full-image coefficient buffer in any multi-pass mode. */\n  jinit_c_coef_controller(cinfo,\n\t\t(boolean) (cinfo->num_scans > 1 || cinfo->optimize_coding));\n  jinit_c_main_controller(cinfo, FALSE /* never need full buffer here */);\n\n  jinit_marker_writer(cinfo);\n\n  /* We can now tell the memory manager to allocate virtual arrays. */\n  (*cinfo->mem->realize_virt_arrays) ((j_common_ptr) cinfo);\n\n  /* Write the datastream header (SOI) immediately.\n   * Frame and scan headers are postponed till later.\n   * This lets application insert special markers after the SOI.\n   */\n  (*cinfo->marker->write_file_header) (cinfo);\n}", "path": "jcinit.c", "repo_name": "zsx/jpeg", "stars": 1, "license": "None", "language": "c", "size": 1052}
{"docstring": "/*\n * Process some data.\n * This handles the case where context rows must be provided.\n */\n", "func_signal": "METHODDEF(void)\nprocess_data_context_main (j_decompress_ptr cinfo,\n\t\t\t   JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,\n\t\t\t   JDIMENSION out_rows_avail)", "code": "{\n  my_main_ptr main = (my_main_ptr) cinfo->main;\n\n  /* Read input data if we haven't filled the main buffer yet */\n  if (! main->buffer_full) {\n    if (! (*cinfo->coef->decompress_data) (cinfo,\n\t\t\t\t\t   main->xbuffer[main->whichptr]))\n      return;\t\t\t/* suspension forced, can do nothing more */\n    main->buffer_full = TRUE;\t/* OK, we have an iMCU row to work with */\n    main->iMCU_row_ctr++;\t/* count rows received */\n  }\n\n  /* Postprocessor typically will not swallow all the input data it is handed\n   * in one call (due to filling the output buffer first).  Must be prepared\n   * to exit and restart.  This switch lets us keep track of how far we got.\n   * Note that each case falls through to the next on successful completion.\n   */\n  switch (main->context_state) {\n  case CTX_POSTPONED_ROW:\n    /* Call postprocessor using previously set pointers for postponed row */\n    (*cinfo->post->post_process_data) (cinfo, main->xbuffer[main->whichptr],\n\t\t\t&main->rowgroup_ctr, main->rowgroups_avail,\n\t\t\toutput_buf, out_row_ctr, out_rows_avail);\n    if (main->rowgroup_ctr < main->rowgroups_avail)\n      return;\t\t\t/* Need to suspend */\n    main->context_state = CTX_PREPARE_FOR_IMCU;\n    if (*out_row_ctr >= out_rows_avail)\n      return;\t\t\t/* Postprocessor exactly filled output buf */\n    /*FALLTHROUGH*/\n  case CTX_PREPARE_FOR_IMCU:\n    /* Prepare to process first M-1 row groups of this iMCU row */\n    main->rowgroup_ctr = 0;\n    main->rowgroups_avail = (JDIMENSION) (cinfo->min_DCT_v_scaled_size - 1);\n    /* Check for bottom of image: if so, tweak pointers to \"duplicate\"\n     * the last sample row, and adjust rowgroups_avail to ignore padding rows.\n     */\n    if (main->iMCU_row_ctr == cinfo->total_iMCU_rows)\n      set_bottom_pointers(cinfo);\n    main->context_state = CTX_PROCESS_IMCU;\n    /*FALLTHROUGH*/\n  case CTX_PROCESS_IMCU:\n    /* Call postprocessor using previously set pointers */\n    (*cinfo->post->post_process_data) (cinfo, main->xbuffer[main->whichptr],\n\t\t\t&main->rowgroup_ctr, main->rowgroups_avail,\n\t\t\toutput_buf, out_row_ctr, out_rows_avail);\n    if (main->rowgroup_ctr < main->rowgroups_avail)\n      return;\t\t\t/* Need to suspend */\n    /* After the first iMCU, change wraparound pointers to normal state */\n    if (main->iMCU_row_ctr == 1)\n      set_wraparound_pointers(cinfo);\n    /* Prepare to load new iMCU row using other xbuffer list */\n    main->whichptr ^= 1;\t/* 0=>1 or 1=>0 */\n    main->buffer_full = FALSE;\n    /* Still need to process last row group of this iMCU row, */\n    /* which is saved at index M+1 of the other xbuffer */\n    main->rowgroup_ctr = (JDIMENSION) (cinfo->min_DCT_v_scaled_size + 1);\n    main->rowgroups_avail = (JDIMENSION) (cinfo->min_DCT_v_scaled_size + 2);\n    main->context_state = CTX_POSTPONED_ROW;\n  }\n}", "path": "jdmainct.c", "repo_name": "zsx/jpeg", "stars": 1, "license": "None", "language": "c", "size": 1052}
{"docstring": "/*\n * Initialize for a processing pass.\n */\n", "func_signal": "METHODDEF(void)\nstart_pass_main (j_decompress_ptr cinfo, J_BUF_MODE pass_mode)", "code": "{\n  my_main_ptr main = (my_main_ptr) cinfo->main;\n\n  switch (pass_mode) {\n  case JBUF_PASS_THRU:\n    if (cinfo->upsample->need_context_rows) {\n      main->pub.process_data = process_data_context_main;\n      make_funny_pointers(cinfo); /* Create the xbuffer[] lists */\n      main->whichptr = 0;\t/* Read first iMCU row into xbuffer[0] */\n      main->context_state = CTX_PREPARE_FOR_IMCU;\n      main->iMCU_row_ctr = 0;\n    } else {\n      /* Simple case with no context needed */\n      main->pub.process_data = process_data_simple_main;\n    }\n    main->buffer_full = FALSE;\t/* Mark buffer empty */\n    main->rowgroup_ctr = 0;\n    break;\n#ifdef QUANT_2PASS_SUPPORTED\n  case JBUF_CRANK_DEST:\n    /* For last pass of 2-pass quantization, just crank the postprocessor */\n    main->pub.process_data = process_data_crank_post;\n    break;\n#endif\n  default:\n    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);\n    break;\n  }\n}", "path": "jdmainct.c", "repo_name": "zsx/jpeg", "stars": 1, "license": "None", "language": "c", "size": 1052}
{"docstring": "/*\n * Write datastream header.\n * This consists of an SOI and optional APPn markers.\n * We recommend use of the JFIF marker, but not the Adobe marker,\n * when using YCbCr or grayscale data.  The JFIF marker should NOT\n * be used for any other JPEG colorspace.  The Adobe marker is helpful\n * to distinguish RGB, CMYK, and YCCK colorspaces.\n * Note that an application can write additional header markers after\n * jpeg_start_compress returns.\n */\n", "func_signal": "METHODDEF(void)\nwrite_file_header (j_compress_ptr cinfo)", "code": "{\n  my_marker_ptr marker = (my_marker_ptr) cinfo->marker;\n\n  emit_marker(cinfo, M_SOI);\t/* first the SOI */\n\n  /* SOI is defined to reset restart interval to 0 */\n  marker->last_restart_interval = 0;\n\n  if (cinfo->write_JFIF_header)\t/* next an optional JFIF APP0 */\n    emit_jfif_app0(cinfo);\n  if (cinfo->write_Adobe_marker) /* next an optional Adobe APP14 */\n    emit_adobe_app14(cinfo);\n}", "path": "jcmarker.c", "repo_name": "zsx/jpeg", "stars": 1, "license": "None", "language": "c", "size": 1052}
{"docstring": "/*\n * Module initialization routine for output colorspace conversion.\n */\n", "func_signal": "GLOBAL(void)\njinit_color_deconverter (j_decompress_ptr cinfo)", "code": "{\n  my_cconvert_ptr cconvert;\n  int ci;\n\n  cconvert = (my_cconvert_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\tSIZEOF(my_color_deconverter));\n  cinfo->cconvert = (struct jpeg_color_deconverter *) cconvert;\n  cconvert->pub.start_pass = start_pass_dcolor;\n\n  /* Make sure num_components agrees with jpeg_color_space */\n  switch (cinfo->jpeg_color_space) {\n  case JCS_GRAYSCALE:\n    if (cinfo->num_components != 1)\n      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);\n    break;\n\n  case JCS_RGB:\n  case JCS_YCbCr:\n    if (cinfo->num_components != 3)\n      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);\n    break;\n\n  case JCS_CMYK:\n  case JCS_YCCK:\n    if (cinfo->num_components != 4)\n      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);\n    break;\n\n  default:\t\t\t/* JCS_UNKNOWN can be anything */\n    if (cinfo->num_components < 1)\n      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);\n    break;\n  }\n\n  /* Set out_color_components and conversion method based on requested space.\n   * Also clear the component_needed flags for any unused components,\n   * so that earlier pipeline stages can avoid useless computation.\n   */\n\n  switch (cinfo->out_color_space) {\n  case JCS_GRAYSCALE:\n    cinfo->out_color_components = 1;\n    if (cinfo->jpeg_color_space == JCS_GRAYSCALE ||\n\tcinfo->jpeg_color_space == JCS_YCbCr) {\n      cconvert->pub.color_convert = grayscale_convert;\n      /* For color->grayscale conversion, only the Y (0) component is needed */\n      for (ci = 1; ci < cinfo->num_components; ci++)\n\tcinfo->comp_info[ci].component_needed = FALSE;\n    } else\n      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n    break;\n\n  case JCS_RGB:\n    cinfo->out_color_components = RGB_PIXELSIZE;\n    if (cinfo->jpeg_color_space == JCS_YCbCr) {\n      cconvert->pub.color_convert = ycc_rgb_convert;\n      build_ycc_rgb_table(cinfo);\n    } else if (cinfo->jpeg_color_space == JCS_GRAYSCALE) {\n      cconvert->pub.color_convert = gray_rgb_convert;\n    } else if (cinfo->jpeg_color_space == JCS_RGB && RGB_PIXELSIZE == 3) {\n      cconvert->pub.color_convert = null_convert;\n    } else\n      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n    break;\n\n  case JCS_CMYK:\n    cinfo->out_color_components = 4;\n    if (cinfo->jpeg_color_space == JCS_YCCK) {\n      cconvert->pub.color_convert = ycck_cmyk_convert;\n      build_ycc_rgb_table(cinfo);\n    } else if (cinfo->jpeg_color_space == JCS_CMYK) {\n      cconvert->pub.color_convert = null_convert;\n    } else\n      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n    break;\n\n  default:\n    /* Permit null conversion to same output space */\n    if (cinfo->out_color_space == cinfo->jpeg_color_space) {\n      cinfo->out_color_components = cinfo->num_components;\n      cconvert->pub.color_convert = null_convert;\n    } else\t\t\t/* unsupported non-null conversion */\n      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n    break;\n  }\n\n  if (cinfo->quantize_colors)\n    cinfo->output_components = 1; /* single colormapped output component */\n  else\n    cinfo->output_components = cinfo->out_color_components;\n}", "path": "jdcolor.c", "repo_name": "zsx/jpeg", "stars": 1, "license": "None", "language": "c", "size": 1052}
{"docstring": "/*\n * Set the JPEG colorspace, and choose colorspace-dependent default values.\n */\n", "func_signal": "GLOBAL(void)\njpeg_set_colorspace (j_compress_ptr cinfo, J_COLOR_SPACE colorspace)", "code": "{\n  jpeg_component_info * compptr;\n  int ci;\n\n#define SET_COMP(index,id,hsamp,vsamp,quant,dctbl,actbl)  \\\n  (compptr = &cinfo->comp_info[index], \\\n   compptr->component_id = (id), \\\n   compptr->h_samp_factor = (hsamp), \\\n   compptr->v_samp_factor = (vsamp), \\\n   compptr->quant_tbl_no = (quant), \\\n   compptr->dc_tbl_no = (dctbl), \\\n   compptr->ac_tbl_no = (actbl) )\n\n  /* Safety check to ensure start_compress not called yet. */\n  if (cinfo->global_state != CSTATE_START)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n\n  /* For all colorspaces, we use Q and Huff tables 0 for luminance components,\n   * tables 1 for chrominance components.\n   */\n\n  cinfo->jpeg_color_space = colorspace;\n\n  cinfo->write_JFIF_header = FALSE; /* No marker for non-JFIF colorspaces */\n  cinfo->write_Adobe_marker = FALSE; /* write no Adobe marker by default */\n\n  switch (colorspace) {\n  case JCS_GRAYSCALE:\n    cinfo->write_JFIF_header = TRUE; /* Write a JFIF marker */\n    cinfo->num_components = 1;\n    /* JFIF specifies component ID 1 */\n    SET_COMP(0, 1, 1,1, 0, 0,0);\n    break;\n  case JCS_RGB:\n    cinfo->write_Adobe_marker = TRUE; /* write Adobe marker to flag RGB */\n    cinfo->num_components = 3;\n    SET_COMP(0, 0x52 /* 'R' */, 1,1, 0, 0,0);\n    SET_COMP(1, 0x47 /* 'G' */, 1,1, 0, 0,0);\n    SET_COMP(2, 0x42 /* 'B' */, 1,1, 0, 0,0);\n    break;\n  case JCS_YCbCr:\n    cinfo->write_JFIF_header = TRUE; /* Write a JFIF marker */\n    cinfo->num_components = 3;\n    /* JFIF specifies component IDs 1,2,3 */\n    /* We default to 2x2 subsamples of chrominance */\n    SET_COMP(0, 1, 2,2, 0, 0,0);\n    SET_COMP(1, 2, 1,1, 1, 1,1);\n    SET_COMP(2, 3, 1,1, 1, 1,1);\n    break;\n  case JCS_CMYK:\n    cinfo->write_Adobe_marker = TRUE; /* write Adobe marker to flag CMYK */\n    cinfo->num_components = 4;\n    SET_COMP(0, 0x43 /* 'C' */, 1,1, 0, 0,0);\n    SET_COMP(1, 0x4D /* 'M' */, 1,1, 0, 0,0);\n    SET_COMP(2, 0x59 /* 'Y' */, 1,1, 0, 0,0);\n    SET_COMP(3, 0x4B /* 'K' */, 1,1, 0, 0,0);\n    break;\n  case JCS_YCCK:\n    cinfo->write_Adobe_marker = TRUE; /* write Adobe marker to flag YCCK */\n    cinfo->num_components = 4;\n    SET_COMP(0, 1, 2,2, 0, 0,0);\n    SET_COMP(1, 2, 1,1, 1, 1,1);\n    SET_COMP(2, 3, 1,1, 1, 1,1);\n    SET_COMP(3, 4, 2,2, 0, 0,0);\n    break;\n  case JCS_UNKNOWN:\n    cinfo->num_components = cinfo->input_components;\n    if (cinfo->num_components < 1 || cinfo->num_components > MAX_COMPONENTS)\n      ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->num_components,\n\t       MAX_COMPONENTS);\n    for (ci = 0; ci < cinfo->num_components; ci++) {\n      SET_COMP(ci, ci, 1,1, 0, 0,0);\n    }\n    break;\n  default:\n    ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);\n  }\n}", "path": "jcparam.c", "repo_name": "zsx/jpeg", "stars": 1, "license": "None", "language": "c", "size": 1052}
{"docstring": "/*\n * Convert grayscale to RGB: just duplicate the graylevel three times.\n * This is provided to support applications that don't want to cope\n * with grayscale as a separate case.\n */\n", "func_signal": "METHODDEF(void)\ngray_rgb_convert (j_decompress_ptr cinfo,\n\t\t  JSAMPIMAGE input_buf, JDIMENSION input_row,\n\t\t  JSAMPARRAY output_buf, int num_rows)", "code": "{\n  register JSAMPROW inptr, outptr;\n  register JDIMENSION col;\n  JDIMENSION num_cols = cinfo->output_width;\n\n  while (--num_rows >= 0) {\n    inptr = input_buf[0][input_row++];\n    outptr = *output_buf++;\n    for (col = 0; col < num_cols; col++) {\n      /* We can dispense with GETJSAMPLE() here */\n      outptr[RGB_RED] = outptr[RGB_GREEN] = outptr[RGB_BLUE] = inptr[col];\n      outptr += RGB_PIXELSIZE;\n    }\n  }\n}", "path": "jdcolor.c", "repo_name": "zsx/jpeg", "stars": 1, "license": "None", "language": "c", "size": 1052}
{"docstring": "//\n// Text message functions\n//\n", "func_signal": "int send_text(const char *conference, int member_id, const char *text)", "code": "{\n\tstruct ast_conference  *conf;\n\tstruct ast_conf_member *member;\n\tint                    res;\n\n\tif ( conference == NULL || member_id < 0 || text == NULL )\n\t\treturn -1;\n\n\tres = 0;\n\n\t// acquire conference list mutex\n\tast_mutex_lock( &conflist_lock ) ;\n\n\tfor ( conf = conflist ; conf != NULL ; conf = conf->next )\n\t{\n\t\tif ( strcmp(conference, conf->name) == 0 )\n\t\t{\n\t\t\t// acquire conference mutex\n\t\t\tast_mutex_lock( &conf->lock );\n\n\t\t\tfor ( member = conf->memberlist ; member != NULL ; member = member->next )\n\t\t\t{\n\t\t\t\tif ( member->id == member_id )\n\t\t\t\t{\n\t\t\t\t\tres = send_text_message_to_member(member, text) == 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// release conference mutex\n\t\t\tast_mutex_unlock( &conf->lock );\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// release conference list mutex\n\tast_mutex_unlock( &conflist_lock ) ;\n\treturn res;\n}", "path": "conference.c", "repo_name": "mcr/app-conference", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 168}
{"docstring": "//\n// manager functions\n//\n", "func_signal": "void send_state_change_notifications( struct ast_conf_member* member )", "code": "{\n\t// ast_log( AST_CONF_DEBUG, \"sending state change notification\\n\" ) ;\n\n\t// loop through list of members, sending state changes\n\twhile ( member != NULL )\n\t{\n\t\t// has the state changed since last time through this loop?\n\t\tif ( member->speaking_state_notify )\n\t\t{\n\t\t\tmanager_event(\n\t\t\t\tEVENT_FLAG_CALL,\n\t\t\t\t\"ConferenceState\",\n\t\t\t\t\"Channel: %s\\r\\n\"\n\t\t\t\t\"State: %s\\r\\n\",\n\t\t\t\tmember->channel_name,\n\t\t\t\t( ( member->speaking_state == 1 ) ? \"speaking\" : \"silent\" )\n\t\t\t) ;\n\n\t\t\tast_log( AST_CONF_DEBUG, \"member state changed, channel => %s, state => %d, incoming => %d, outgoing => %d\\n\",\n\t\t\t\tmember->channel_name, member->speaking_state, member->inFramesCount, member->outFramesCount ) ;\n\n\t\t\tmember->speaking_state_notify = 0;\n\t\t}\n\n\t\t// move the pointer to the next member\n\t\tmember = member->next ;\n\t}\n\n\treturn ;\n}", "path": "member.c", "repo_name": "mcr/app-conference", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 168}
{"docstring": "// Associates two channels\n// Drives VAD-based video switching of dst_channel from audio from src_channel\n// This can be used when a member participates in a video conference but\n// talks using a telephone (simulcast) connection\n", "func_signal": "int drive_channel(const char *conference, const char *src_channel, const char *dst_channel)", "code": "{\n\tint res;\n\tstruct ast_conference *conf;\n\tstruct ast_conf_member *member;\n\tstruct ast_conf_member *src;\n\tstruct ast_conf_member *dst;\n\n\tif ( conference == NULL || src_channel == NULL )\n\t\treturn -1;\n\n\tres = 0;\n\n\t// acquire conference list mutex\n\tast_mutex_lock( &conflist_lock ) ;\n\n\tfor ( conf = conflist ; conf != NULL ; conf = conf->next )\n\t{\n\t\tif ( strcmp(conference, conf->name) == 0 )\n\t\t{\n\t\t\t// acquire conference mutex\n\t\t\tast_mutex_lock( &conf->lock );\n\n\t\t\tsrc = NULL;\n\t\t\tdst = NULL;\n\t\t\tfor ( member = conf->memberlist ; member != NULL ; member = member->next )\n\t\t\t{\n\t\t\t\tif ( strcmp(src_channel, member->channel_name) == 0 )\n\t\t\t\t\tsrc = member;\n\t\t\t\tif ( dst_channel != NULL && strcmp(dst_channel, member->channel_name) == 0 )\n\t\t\t\t\tdst = member;\n\t\t\t}\n\t\t\tif ( src != NULL )\n\t\t\t{\n\t\t\t\t// acquire member mutex\n\t\t\t\tast_mutex_lock(&src->lock);\n\n\t\t\t\tif ( dst != NULL )\n\t\t\t\t{\n\t\t\t\t\tsrc->driven_member = dst;\n\t\t\t\t\t// Make sure the driven member's speaker count is correct\n\t\t\t\t\tif ( src->speaking_state == 1 )\n\t\t\t\t\t\tincrement_speaker_count(src->driven_member, 1);\n\t\t\t\t\tres = 1;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tif ( dst_channel == NULL )\n\t\t\t\t\t{\n\t\t\t\t\t\t// Make sure the driven member's speaker count is correct\n\t\t\t\t\t\tif ( src->speaking_state == 1 )\n\t\t\t\t\t\t\tdecrement_speaker_count(src->driven_member, 1);\n\t\t\t\t\t\tsrc->driven_member = NULL;\n\t\t\t\t\t\tres = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// release member mutex\n\t\t\t\tast_mutex_unlock(&src->lock);\n\t\t\t}\n\n\t\t\t// release conference mutex\n\t\t\tast_mutex_unlock( &conf->lock );\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// release conference list mutex\n\tast_mutex_unlock( &conflist_lock ) ;\n\n\treturn res;\n}", "path": "conference.c", "repo_name": "mcr/app-conference", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 168}
{"docstring": "//This function should be called with conflist_lock and conf->lock held\n", "func_signal": "static void remove_conf( struct ast_conference *conf )", "code": "{\n  int c;\n\n\t// ast_log( AST_CONF_DEBUG, \"attempting to remove conference, name => %s\\n\", conf->name ) ;\n\n\tstruct ast_conference *conf_current = conflist ;\n\tstruct ast_conference *conf_temp = NULL ;\n\n\t// loop through list of conferences\n\twhile ( conf_current != NULL )\n\t{\n\t\t// if conf_current point to the passed conf,\n\t\tif ( conf_current == conf )\n\t\t{\n\t\t\tif ( conf_temp == NULL )\n\t\t\t{\n\t\t\t\t// this is the first conf in the list, so we just point\n\t\t\t\t// conflist past the current conf to the next\n\t\t\t\tconflist = conf_current->next ;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// this is not the first conf in the list, so we need to\n\t\t\t\t// point the preceeding conf to the next conf in the list\n\t\t\t\tconf_temp->next = conf_current->next ;\n\t\t\t}\n\n\t\t\t//\n\t\t\t// do some frame clean up\n\t\t\t//\n\n\t\t\tfor ( c = 0 ; c < AC_SUPPORTED_FORMATS ; ++c )\n\t\t\t{\n\t\t\t\t// free the translation paths\n\t\t\t\tif ( conf_current->from_slinear_paths[ c ] != NULL )\n\t\t\t\t{\n\t\t\t\t\tast_translator_free_path( conf_current->from_slinear_paths[ c ] ) ;\n\t\t\t\t\tconf_current->from_slinear_paths[ c ] = NULL ;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// calculate time in conference\n\t\t\t// total time converted to seconds\n\t\t\tlong tt = ast_tvdiff_ms(ast_tvnow(),\n\t\t\t\t\tconf_current->stats.time_entered) / 1000;\n\n\t\t\t// report accounting information\n\t\t\tif (conf->debug_flag)\n\t\t\t{\n\t\t\t\tast_log( LOG_NOTICE, \"conference accounting, fi => %ld, fo => %ld, fm => %ld, tt => %ld\\n\",\n\t\t\t\t\t conf_current->stats.frames_in, conf_current->stats.frames_out, conf_current->stats.frames_mixed, tt ) ;\n\n\t\t\t\tast_log( AST_CONF_DEBUG, \"removed conference, name => %s\\n\", conf_current->name ) ;\n\t\t\t}\n\n\t\t\tast_mutex_unlock( &conf_current->lock ) ;\n\n\t\t\tfree( conf_current ) ;\n\t\t\tconf_current = NULL ;\n\n\t\t\tbreak ;\n\t\t}\n\n\t\t// save a refence to the soon to be previous conf\n\t\tconf_temp = conf_current ;\n\n\t\t// move conf_current to the next in the list\n\t\tconf_current = conf_current->next ;\n\t}\n\n\t// count new conference\n\t--conference_count ;\n\n\treturn ;\n}", "path": "conference.c", "repo_name": "mcr/app-conference", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 168}
{"docstring": "// This function should be called with conflist_lock held\n", "func_signal": "static struct ast_conference* create_conf( char* name, struct ast_conf_member* member )", "code": "{\n\tast_log( AST_CONF_DEBUG, \"entered create_conf, name => %s\\n\", name ) ;\n\n\t//\n\t// allocate memory for conference\n\t//\n\n\tstruct ast_conference *conf = malloc( sizeof( struct ast_conference ) ) ;\n\n\tif ( conf == NULL )\n\t{\n\t\tast_log( LOG_ERROR, \"unable to malloc ast_conference\\n\" ) ;\n\t\treturn NULL ;\n\t}\n\n\t//\n\t// initialize conference\n\t//\n\n\tconf->next = NULL ;\n\tconf->memberlist = NULL ;\n\n\tconf->membercount = 0 ;\n\tconf->conference_thread = -1 ;\n\n\tconf->debug_flag = 0 ;\n\n\tconf->id_count = 0;\n\n\tconf->default_video_source_id = -1;\n\tconf->current_video_source_id = -1;\n\t//conf->current_video_source_timestamp = ast_tvnow();\n\tconf->video_locked = 0;\n\n\tconf->chat_mode_on = 0;\n\tconf->does_chat_mode = 0;\n\n\t// zero stats\n\tmemset(\t&conf->stats, 0x0, sizeof( ast_conference_stats ) ) ;\n\n\t// record start time\n\tconf->stats.time_entered = ast_tvnow();\n\n\t// copy name to conference\n\tstrncpy( (char*)&(conf->name), name, sizeof(conf->name) - 1 ) ;\n\tstrncpy( (char*)&(conf->stats.name), name, sizeof(conf->name) - 1 ) ;\n\n\t// initialize mutexes\n\tast_mutex_init( &conf->lock ) ;\n\n\t// build translation paths\n\tconf->from_slinear_paths[ AC_SLINEAR_INDEX ] = NULL ;\n\tconf->from_slinear_paths[ AC_ULAW_INDEX ] = ast_translator_build_path( AST_FORMAT_ULAW, AST_FORMAT_SLINEAR ) ;\n\tconf->from_slinear_paths[ AC_ALAW_INDEX ] = ast_translator_build_path( AST_FORMAT_ALAW, AST_FORMAT_SLINEAR ) ;\n\tconf->from_slinear_paths[ AC_GSM_INDEX ] = ast_translator_build_path( AST_FORMAT_GSM, AST_FORMAT_SLINEAR ) ;\n\tconf->from_slinear_paths[ AC_SPEEX_INDEX ] = ast_translator_build_path( AST_FORMAT_SPEEX, AST_FORMAT_SLINEAR ) ;\n#ifdef AC_USE_G729A\n\tconf->from_slinear_paths[ AC_G729A_INDEX ] = ast_translator_build_path( AST_FORMAT_G729A, AST_FORMAT_SLINEAR ) ;\n#endif\n\n\t// add the initial member\n\tadd_member( member, conf ) ;\n\n\tast_log( AST_CONF_DEBUG, \"added new conference to conflist, name => %s\\n\", name ) ;\n\n\t//\n\t// spawn thread for new conference, using conference_exec( conf )\n\t//\n\t// acquire conference mutexes\n\tast_mutex_lock( &conf->lock ) ;\n\n\tif ( ast_pthread_create( &conf->conference_thread, NULL, (void*)conference_exec, conf ) == 0 )\n\t{\n\t\t// detach the thread so it doesn't leak\n\t\tpthread_detach( conf->conference_thread ) ;\n\n\t\t// prepend new conference to conflist\n\t\tconf->next = conflist ;\n\t\tconflist = conf ;\n\n\t\t// release conference mutexes\n\t\tast_mutex_unlock( &conf->lock ) ;\n\n\t\tast_log( AST_CONF_DEBUG, \"started conference thread for conference, name => %s\\n\", conf->name ) ;\n\t}\n\telse\n\t{\n\t\tast_log( LOG_ERROR, \"unable to start conference thread for conference %s\\n\", conf->name ) ;\n\n\t\tconf->conference_thread = -1 ;\n\n\t\t// release conference mutexes\n\t\tast_mutex_unlock( &conf->lock ) ;\n\n\t\t// clean up conference\n\t\tfree( conf ) ;\n\t\tconf = NULL ;\n\t}\n\n\t// count new conference\n\tif ( conf != NULL )\n\t\t++conference_count ;\n\n\treturn conf ;\n}", "path": "conference.c", "repo_name": "mcr/app-conference", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 168}
{"docstring": "/* This function approximates the gain function \n   y = gamma(1.25)^2 * M(-.25;1;-x) / sqrt(x)  \n   which multiplied by xi/(1+xi) is the optimal gain\n   in the loudness domain ( sqrt[amplitude] )\n*/\n", "func_signal": "static float hypergeom_gain(float x)", "code": "{\n   int ind;\n   float integer, frac;\n   static float table[21] = {\n      0.82157, 1.02017, 1.20461, 1.37534, 1.53363, 1.68092, 1.81865, \n      1.94811, 2.07038, 2.18638, 2.29688, 2.40255, 2.50391, 2.60144, \n      2.69551, 2.78647, 2.87458, 2.96015, 3.04333, 3.12431, 3.20326};\n   \n   if (x>9.5)\n      return 1+.12/x;\n\n   integer = floor(x);\n   frac = x-integer;\n   ind = (int)integer;\n   \n   return ((1-frac)*table[ind] + frac*table[ind+1])/sqrt(x+.0001);\n}", "path": "libspeex\\preprocess.c", "repo_name": "mcr/app-conference", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 168}
{"docstring": "//\n// E.BUU - Manager conference end. Additional option to just kick everybody out\n// without hangin up channels\n//\n", "func_signal": "int manager_conference_end(struct mansession *s, const struct message *m)", "code": "{\n\tconst char *confname = astman_get_header(m,\"Conference\");\n\tint hangup = 1;\n\n\tconst char * h =  astman_get_header(m, \"Hangup\");\n\tif (h)\n\t{\n\t\thangup = atoi(h);\n\t}\n\n\tast_log( LOG_NOTICE, \"Terminating conference %s on manager's request. Hangup: %s.\\n\", confname, hangup?\"YES\":\"NO\" );\n        if ( end_conference( confname, hangup ) != 0 )\n        {\n\t\tast_log( LOG_ERROR, \"manager end conf: unable to terminate conference %s.\\n\", confname );\n\t\tastman_send_error(s, m, \"Failed to terminate\\r\\n\");\n\t\treturn RESULT_FAILURE;\n\t}\n\n\tastman_send_ack(s, m, \"Conference terminated\");\n\treturn RESULT_SUCCESS;\n}", "path": "cli.c", "repo_name": "mcr/app-conference", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 168}
{"docstring": "//\n// cli initialization function\n//\n", "func_signal": "void register_conference_cli( void )", "code": "{\n\tast_cli_register( &cli_restart );\n\tast_cli_register( &cli_debug ) ;\n\tast_cli_register( &cli_show_stats ) ;\n\tast_cli_register( &cli_list );\n\tast_cli_register( &cli_kick );\n\tast_cli_register( &cli_kickchannel );\n\tast_cli_register( &cli_mute );\n\tast_cli_register( &cli_mutechannel );\n\tast_cli_register( &cli_viewstream );\n\tast_cli_register( &cli_viewchannel );\n\tast_cli_register( &cli_unmute );\n\tast_cli_register( &cli_unmutechannel );\n\tast_cli_register( &cli_play_sound ) ;\n\tast_cli_register( &cli_stop_sounds ) ;\n\tast_cli_register( &cli_end );\n\tast_cli_register( &cli_lock );\n\tast_cli_register( &cli_lockchannel );\n\tast_cli_register( &cli_unlock );\n\tast_cli_register( &cli_set_default );\n\tast_cli_register( &cli_set_defaultchannel );\n\tast_cli_register( &cli_video_mute ) ;\n\tast_cli_register( &cli_video_unmute ) ;\n\tast_cli_register( &cli_video_mutechannel ) ;\n\tast_cli_register( &cli_video_unmutechannel ) ;\n\tast_cli_register( &cli_text );\n\tast_cli_register( &cli_textchannel );\n\tast_cli_register( &cli_textbroadcast );\n\tast_cli_register( &cli_drive );\n\tast_cli_register( &cli_drivechannel );\n\tast_manager_register( \"ConferenceList\", 0, manager_conference_list, \"Conference List\" );\n\tast_manager_register( \"ConferenceEnd\", EVENT_FLAG_CALL, manager_conference_end, \"Terminate a conference\" );\n\n}", "path": "cli.c", "repo_name": "mcr/app-conference", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 168}
{"docstring": "// All the VAD-based video switching magic happens here\n// This function should be called inside conference_exec\n// The conference mutex should be locked, we don't have to do it here\n", "func_signal": "static void do_VAD_switching(struct ast_conference *conf)", "code": "{\n\tstruct ast_conf_member *member;\n\tstruct timeval current_time = ast_tvnow();\n\tlong longest_speaking = 0;\n\tstruct ast_conf_member *longest_speaking_member = NULL;\n\tint current_silent = 0;\n\tint current_linger = 0;\n\tint current_no_video = 0;\n\tint current_force_switch = 0;\n\tint default_no_video = 0;\n\tint default_force_switch = 0;\n\n\t// Scan the member list looking for the longest speaking member\n\t// We also check if the currently speaking member has been silent for a while\n\t// Also, we check for camera disabled or video muted members\n\t// We say that a member is speaking after his speaking state has been on for\n\t// at least AST_CONF_VIDEO_START_TIMEOUT ms\n\t// We say that a member is silent after his speaking state has been off for\n\t// at least AST_CONF_VIDEO_STOP_TIMEOUT ms\n\tfor ( member = conf->memberlist ;\n\t      member != NULL ;\n\t      member = member->next )\n\t{\n\t\t// If a member connects via telephone, they don't have video\n\t\tif ( member->via_telephone )\n\t\t\tcontinue;\n\n\t\t// We check for no VAD switching, video-muted or camera disabled\n\t\t// If yes, this member will not be considered as a candidate for switching\n\t\t// If this is the currently speaking member, then mark it so we force a switch\n\t\tif ( !member->vad_switch )\n\t\t\tcontinue;\n\n\t\t// Extract the linger and force switch flags of the current video source\n\t\tif ( member->id == conf->current_video_source_id )\n\t\t{\n\t\t\tcurrent_linger = member->vad_linger;\n\t\t\tcurrent_force_switch = member->force_vad_switch;\n\t\t}\n\t\t\n\t\tif ( member->id == conf->default_video_source_id )\n\t\t\tdefault_force_switch = member->force_vad_switch;\n\n\t\tif ( member->no_camera || member->mute_video )\n\t\t{\n\t\t\tif ( member->id == conf->default_video_source_id )\n\t\t\t\tdefault_no_video = 1;\n\t\t\t\n\t\t\tif ( member->id == conf->current_video_source_id )\n\t\t\t\tcurrent_no_video = 1;\n\t\t\telse if ( !member->force_vad_switch )\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t// Check if current speaker has been silent for a while\n\t\tif ( member->id == conf->current_video_source_id &&\n\t\t     !member->speaking_state &&\n\t\t     ast_tvdiff_ms(current_time, member->last_state_change) > member->video_stop_timeout )\n\t\t{\n\t\t\tcurrent_silent = 1;\n\t\t}\n\n\t\t// Find a candidate to switch to by looking for the longest speaking member\n\t\t// We exclude the current video source from the search\n\t\tif ( member->id != conf->current_video_source_id && member->speaking_state == 1 )\n\t\t{\n\t\t\tlong speak_time = ast_tvdiff_ms(current_time, member->last_state_change);\n\t\t\tif ( speak_time > member->video_start_timeout && speak_time > longest_speaking )\n\t\t\t{\n\t\t\t\tlongest_speaking = speak_time;\n\t\t\t\tlongest_speaking_member = member;\n\t\t\t}\n\t\t}\n\t}\n\n\t// We got our results, now let's make a decision\n\t// If the currently speaking member has been marked as silent, then we take the longest\n\t// speaking member.  If no member is speaking, but the current member has the vad_linger\n\t// flag set, we stay put, otherwise we go to default.  If there's no default, we blank.\n\t// As a policy we don't want to switch away from a member that is speaking\n\t// however, we might need to refine this to avoid a situation when a member has a\n\t// low noise threshold or its VAD is simply stuck\n\tif ( \n\t     (conf->current_video_source_id < 0) ||\n\t     (current_silent && !current_linger) ||\n\t     (current_silent && longest_speaking_member != NULL ) ||\n\t     (current_no_video && !current_force_switch)\n\t   )\n\t{\n\t\tint new_id;\n\n\t\tif ( longest_speaking_member )\n\t\t\t// Somebody is talking, switch to that member\n\t\t\tnew_id = longest_speaking_member->id;\n\t\telse if ( conf->default_video_source_id >= 0  &&\n\t\t          (!default_no_video || default_force_switch)\n\t\t        )\n\t\t\t// No talking, but we have a default that can send video\n\t\t\tnew_id = conf->default_video_source_id;\n\t\telse\n\t\t\t// No default, switch to empty (-1)\n\t\t\tnew_id = -1;\n\n\t\tdo_video_switching(conf, new_id, 0);\n\t}\n}", "path": "conference.c", "repo_name": "mcr/app-conference", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 168}
{"docstring": "//\n// incoming frame functions\n//\n", "func_signal": "conf_frame* get_incoming_video_frame( struct ast_conf_member *member )", "code": "{\n  \tif ( member == NULL )\n\t{\n\t\tast_log( LOG_WARNING, \"unable to get frame from null member\\n\" ) ;\n\t\treturn NULL ;\n\t}\n\n\tast_mutex_lock(&member->lock);\n\n\tif ( member->inVideoFramesCount == 0 )\n\t{\n\t\tast_mutex_unlock(&member->lock);\n\t\treturn NULL ;\n\t}\n\n\t//\n\t// return the next frame in the queue\n\t//\n\n\tconf_frame* cfr = NULL ;\n\n\t// get first frame in line\n\tcfr = member->inVideoFramesTail ;\n\n\t// if it's the only frame, reset the queue,\n\t// else, move the second frame to the front\n\tif ( member->inVideoFramesTail == member->inVideoFrames )\n\t{\n\t\tmember->inVideoFramesTail = NULL ;\n\t\tmember->inVideoFrames = NULL ;\n\t}\n\telse\n\t{\n\t\t// move the pointer to the next frame\n\t\tmember->inVideoFramesTail = member->inVideoFramesTail->prev ;\n\n\t\t// reset it's 'next' pointer\n\t\tif ( member->inVideoFramesTail != NULL )\n\t\t\tmember->inVideoFramesTail->next = NULL ;\n\t}\n\n\t// separate the conf frame from the list\n\tcfr->next = NULL ;\n\tcfr->prev = NULL ;\n\n\t// decrement frame count\n\tmember->inVideoFramesCount-- ;\n\n\tast_mutex_unlock(&member->lock);\n\treturn cfr ;\n\n}", "path": "member.c", "repo_name": "mcr/app-conference", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 168}
{"docstring": "//\n// main conference function\n//\n", "func_signal": "static void conference_exec( struct ast_conference *conf )", "code": "{\n\n\tstruct ast_conf_member *next_member;\n\tstruct ast_conf_member *member, *video_source_member, *dtmf_source_member;;\n\tstruct conf_frame *cfr, *spoken_frames, *send_frames;\n\n\t// count number of speakers, number of listeners\n\tint speaker_count ;\n\tint listener_count ;\n\n\tast_log( AST_CONF_DEBUG, \"Entered conference_exec, name => %s\\n\", conf->name ) ;\n\n\t// timer timestamps\n\tstruct timeval base, curr, notify ;\n\tbase = notify = ast_tvnow();\n\n\t// holds differences of curr and base\n\tlong time_diff = 0 ;\n\tlong time_sleep = 0 ;\n\n\tint since_last_slept = 0 ;\n\n\t//\n\t// variables for checking thread frequency\n\t//\n\n\t// count to AST_CONF_FRAMES_PER_SECOND\n\tint tf_count = 0 ;\n\tlong tf_diff = 0 ;\n\tfloat tf_frequency = 0.0 ;\n\n\tstruct timeval tf_base, tf_curr ;\n\ttf_base = ast_tvnow();\n\n\t//\n\t// main conference thread loop\n\t//\n\n\n\twhile ( 42 == 42 )\n\t{\n\t\t// update the current timestamp\n\t\tcurr = ast_tvnow();\n\n\t\t// calculate difference in timestamps\n\t\ttime_diff = ast_tvdiff_ms(curr, base);\n\n\t\t// calculate time we should sleep\n\t\ttime_sleep = AST_CONF_FRAME_INTERVAL - time_diff ;\n\n\t\tif ( time_sleep > 0 )\n\t\t{\n\t\t\t// sleep for sleep_time ( as milliseconds )\n\t\t\tusleep( time_sleep * 1000 ) ;\n\n\t\t\t// reset since last slept counter\n\t\t\tsince_last_slept = 0 ;\n\n\t\t\tcontinue ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// long sleep warning\n\t\t\tif (\n\t\t\t\tsince_last_slept == 0\n\t\t\t\t&& time_diff > AST_CONF_CONFERENCE_SLEEP * 2\n\t\t\t)\n\t\t\t{\n\t\t\t\tast_log(\n\t\t\t\t\tAST_CONF_DEBUG,\n\t\t\t\t\t\"long scheduling delay, time_diff => %ld, AST_CONF_FRAME_INTERVAL => %d\\n\",\n\t\t\t\t\ttime_diff, AST_CONF_FRAME_INTERVAL\n\t\t\t\t) ;\n\t\t\t}\n\n\t\t\t// increment times since last slept\n\t\t\t++since_last_slept ;\n\n\t\t\t// sleep every other time\n\t\t\tif ( since_last_slept % 2 )\n\t\t\t\tusleep( 0 ) ;\n\t\t}\n\n\t\t// adjust the timer base ( it will be used later to timestamp outgoing frames )\n\t\tadd_milliseconds( &base, AST_CONF_FRAME_INTERVAL ) ;\n\n\t\t//\n\t\t// check thread frequency\n\t\t//\n\n\t\tif ( ++tf_count >= AST_CONF_FRAMES_PER_SECOND )\n\t\t{\n\t\t\t// update current timestamp\n\t\t\ttf_curr = ast_tvnow();\n\n\t\t\t// compute timestamp difference\n\t\t\ttf_diff = ast_tvdiff_ms(tf_curr, tf_base);\n\n\t\t\t// compute sampling frequency\n\t\t\ttf_frequency = ( float )( tf_diff ) / ( float )( tf_count ) ;\n\n\t\t\tif (\n\t\t\t\t( tf_frequency <= ( float )( AST_CONF_FRAME_INTERVAL - 1 ) )\n\t\t\t\t|| ( tf_frequency >= ( float )( AST_CONF_FRAME_INTERVAL + 1 ) )\n\t\t\t)\n\t\t\t{\n\t\t\t\tast_log(\n\t\t\t\t\tLOG_WARNING,\n\t\t\t\t\t\"processed frame frequency variation, name => %s, tf_count => %d, tf_diff => %ld, tf_frequency => %2.4f\\n\",\n\t\t\t\t\tconf->name, tf_count, tf_diff, tf_frequency\n\t\t\t\t) ;\n\t\t\t}\n\n\t\t\t// reset values\n\t\t\ttf_base = tf_curr ;\n\t\t\ttf_count = 0 ;\n\t\t}\n\n\t\t//-----------------//\n\t\t// INCOMING FRAMES //\n\t\t//-----------------//\n\n\t\t// ast_log( AST_CONF_DEBUG, \"PROCESSING FRAMES, conference => %s, step => %d, ms => %ld\\n\",\n\t\t//\tconf->name, step, ( base.tv_usec / 20000 ) ) ;\n\n\t\t//\n\t\t// check if the conference is empty and if so\n\t\t// remove it and break the loop\n\t\t//\n\n\t\t// acquire the conference list lock\n\t\tast_mutex_lock(&conflist_lock);\n\n\t\t// acquire the conference mutex\n\t\tast_mutex_lock(&conf->lock);\n\n\t\tif ( conf->membercount == 0 )\n\t\t{\n\t\t\tif (conf->debug_flag)\n\t\t\t{\n\t\t\t\tast_log( LOG_NOTICE, \"removing conference, count => %d, name => %s\\n\", conf->membercount, conf->name ) ;\n\t\t\t}\n\t\t\tremove_conf( conf ) ; // stop the conference\n\n\t\t\t// We don't need to release the conf mutex, since it was destroyed anyway\n\n\t\t\t// release the conference list lock\n\t\t\tast_mutex_unlock(&conflist_lock);\n\n\t\t\tbreak ; // break from main processing loop\n\t\t}\n\n\t\t// release the conference mutex\n\t\tast_mutex_unlock(&conf->lock);\n\n\t\t// release the conference list lock\n\t\tast_mutex_unlock(&conflist_lock);\n\n\n\t\t//\n\t\t// Start processing frames\n\t\t//\n\n\t\t// acquire conference mutex\n\t\tTIMELOG(ast_mutex_lock( &conf->lock ),1,\"conf thread conf lock\");\n\n\t\tif ( conf->membercount == 0 )\n\t\t{\n\t\t\t// release the conference mutex\n\t\t\tast_mutex_unlock(&conf->lock);\n\t\t\tcontinue; // We'll check again at the top of the loop\n\t\t}\n\n\t\t// update the current delivery time\n\t\tconf->delivery_time = base ;\n\n\t\t//\n\t\t// loop through the list of members\n\t\t// ( conf->memberlist is a single-linked list )\n\t\t//\n\n\t\t// ast_log( AST_CONF_DEBUG, \"begin processing incoming audio, name => %s\\n\", conf->name ) ;\n\n\t\t// reset speaker and listener count\n\t\tspeaker_count = 0 ;\n\t\tlistener_count = 0 ;\n\n\t\t// get list of conference members\n\t\tmember = conf->memberlist ;\n\n\t\t// reset pointer lists\n\t\tspoken_frames = NULL ;\n\n\t\t// reset video source\n\t\tvideo_source_member = NULL;\n\n                // reset dtmf source\n\t\tdtmf_source_member = NULL;\n\n\t\t// loop over member list to retrieve queued frames\n\t\twhile ( member != NULL )\n\t\t{\n\t\t\t// take note of next member - before it's too late\n\t\t\tnext_member = member->next;\n\n\t\t\t// this MIGHT delete member\n\t\t\tmember_process_spoken_frames(conf,member,&spoken_frames,time_diff,\n\t\t\t\t\t\t     &listener_count, &speaker_count);\n\n\t\t\t// adjust our pointer to the next inline\n\t\t\tmember = next_member;\n\t\t}\n\n\t\t// ast_log( AST_CONF_DEBUG, \"finished processing incoming audio, name => %s\\n\", conf->name ) ;\n\n\n\t\t//---------------//\n\t\t// MIXING FRAMES //\n\t\t//---------------//\n\n\t\t// mix frames and get batch of outgoing frames\n\t\tsend_frames = mix_frames( spoken_frames, speaker_count, listener_count ) ;\n\n\t\t// accounting: if there are frames, count them as one incoming frame\n\t\tif ( send_frames != NULL )\n\t\t{\n\t\t\t// set delivery timestamp\n\t\t\t//set_conf_frame_delivery( send_frames, base ) ;\n//\t\t\tast_log ( LOG_WARNING, \"base = %d,%d: conf->delivery_time = %d,%d\\n\",base.tv_sec,base.tv_usec, conf->delivery_time.tv_sec, conf->delivery_time.tv_usec);\n\n\t\t\t// ast_log( AST_CONF_DEBUG, \"base => %ld.%ld %d\\n\", base.tv_sec, base.tv_usec, ( int )( base.tv_usec / 1000 ) ) ;\n\n\t\t\tconf->stats.frames_in++ ;\n\t\t}\n\n\t\t//-----------------//\n\t\t// OUTGOING FRAMES //\n\t\t//-----------------//\n\n\t\t//\n\t\t// loop over member list to queue outgoing frames\n\t\t//\n\t\tfor ( member = conf->memberlist ; member != NULL ; member = member->next )\n\t\t{\n\t\t\tmember_process_outgoing_frames(conf, member, send_frames);\n\t\t}\n\n\t\t//-------//\n\t\t// VIDEO //\n\t\t//-------//\n\n\t\tcurr = ast_tvnow();\n\t\t\n\t\t// Chat mode handling\n\t\t// If there's only one member, then video gets reflected back to it\n\t\t// If there are two members, then each sees the other's video\n\t\tif ( conf->does_chat_mode &&\n\t\t     conf->membercount > 0 &&\n\t\t     conf->membercount <= 2\n\t\t   )\n\t\t{\n\t\t\tstruct ast_conf_member *m1, *m2;\n\n\t\t\tm1 = conf->memberlist;\n\t\t\tm2 = conf->memberlist->next;\n\t\t\t\n\t\t\tif ( !conf->chat_mode_on )\n\t\t\t\tconf->chat_mode_on = 1;\n\t\t\t\t\n\t\t\tstart_video(m1);\n\t\t\tif ( m2 != NULL )\n\t\t\t\tstart_video(m2);\n\t\t\t\n\t\t\tif ( conf->membercount == 1 )\n\t\t\t{\n\t\t\t\tcfr = get_incoming_video_frame(m1);\n\t\t\t\tupdate_member_broadcasting(conf, m1, cfr, curr);\n\t\t\t\twhile ( cfr )\n\t\t\t\t{\n\t\t\t\t\tqueue_outgoing_video_frame(m1, cfr->fr, conf->delivery_time);\n\t\t\t\t\tdelete_conf_frame(cfr);\n\t\t\t\t\tcfr = get_incoming_video_frame(m1);\n\t\t\t\t}\n\t\t\t} else if ( conf->membercount == 2 )\n\t\t\t{\n\t\t\t\tcfr = get_incoming_video_frame(m1);\n\t\t\t\tupdate_member_broadcasting(conf, m1, cfr, curr);\n\t\t\t\twhile ( cfr )\n\t\t\t\t{\n\t\t\t\t\tqueue_outgoing_video_frame(m2, cfr->fr, conf->delivery_time);\n\t\t\t\t\tdelete_conf_frame(cfr);\n\t\t\t\t\tcfr = get_incoming_video_frame(m1);\n\t\t\t\t}\n\n\t\t\t\tcfr = get_incoming_video_frame(m2);\n\t\t\t\tupdate_member_broadcasting(conf, m2, cfr, curr);\n\t\t\t\twhile ( cfr )\n\t\t\t\t{\n\t\t\t\t\tqueue_outgoing_video_frame(m1, cfr->fr, conf->delivery_time);\n\t\t\t\t\tdelete_conf_frame(cfr);\n\t\t\t\t\tcfr = get_incoming_video_frame(m2);\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t{\n\t\t\t// Generic conference handling (chat mode disabled or more than 2 members)\n\t\t\t// If we were previously in chat mode, turn it off and stop video from members\n\t\t\tif ( conf->chat_mode_on )\n\t\t\t{\n\t\t\t\t// Send STOPVIDEO commands to everybody except the current source, if any\n\t\t\t\tconf->chat_mode_on = 0;\n\t\t\t\tfor (member = conf->memberlist; member != NULL; member = member->next)\n\t\t\t\t{\n\t\t\t\t\tif ( member->id != conf->current_video_source_id )\n\t\t\t\t\t\tstop_video(member);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// loop over the incoming frames and send to all outgoing\n\t\t\t// TODO: this is an O(n^2) algorithm. Can we speed it up without sacrificing per-member switching?\n\t\t\tfor (video_source_member = conf->memberlist;\n\t\t\t     video_source_member != NULL;\n\t\t\t     video_source_member = video_source_member->next\n\t\t\t    )\n\t\t\t{\n\t\t\t\tcfr = get_incoming_video_frame(video_source_member);\n\t\t\t\tupdate_member_broadcasting(conf, video_source_member, cfr, curr);\n\t\t\t\twhile ( cfr )\n\t\t\t\t{\n\t\t\t\t\tfor (member = conf->memberlist; member != NULL; member = member->next)\n\t\t\t\t\t{\n\t\t\t\t\t\t// skip members that are not ready or are not supposed to receive video\n\t\t\t\t\t\tif ( !member->ready_for_outgoing || member->norecv_video )\n\t\t\t\t\t\t\tcontinue ;\n\n\t\t\t\t\t\tif ( conf->video_locked )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Always send video from the locked source\n\t\t\t\t\t\t\tif ( conf->current_video_source_id == video_source_member->id )\n\t\t\t\t\t\t\t\tqueue_outgoing_video_frame(member, cfr->fr, conf->delivery_time);\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// If the member has vad switching disabled and dtmf switching enabled, use that\n\t\t\t\t\t\t\tif ( member->dtmf_switch &&\n\t\t\t\t\t\t\t     !member->vad_switch &&\n\t\t\t\t\t\t\t     member->req_id == video_source_member->id\n\t\t\t\t\t\t\t   )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tqueue_outgoing_video_frame(member, cfr->fr, conf->delivery_time);\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// If no dtmf switching, then do VAD switching\n\t\t\t\t\t\t\t\t// The VAD switching decision code should make sure that our video source\n\t\t\t\t\t\t\t\t// is legit\n\t\t\t\t\t\t\t\tif ( (conf->current_video_source_id == video_source_member->id) ||\n\t\t\t\t\t\t\t\t     (conf->current_video_source_id < 0 &&\n\t\t\t\t\t\t\t\t      conf->default_video_source_id == video_source_member->id\n\t\t\t\t\t\t\t\t     )\n\t\t\t\t\t\t\t\t   )\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tqueue_outgoing_video_frame(member, cfr->fr, conf->delivery_time);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Garbage collection\n\t\t\t\t\tdelete_conf_frame(cfr);\n\t\t\t\t\tcfr = get_incoming_video_frame(video_source_member);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n                //------//\n\t\t// DTMF //\n\t\t//------//\n\n\t\t// loop over the incoming frames and send to all outgoing\n\t\tfor (dtmf_source_member = conf->memberlist; dtmf_source_member != NULL; dtmf_source_member = dtmf_source_member->next)\n\t\t{\n\t\t\twhile ((cfr = get_incoming_dtmf_frame( dtmf_source_member )))\n\t\t\t{\n\t\t\t\tfor (member = conf->memberlist; member != NULL; member = member->next)\n\t\t\t\t{\n\t\t\t\t\t// skip members that are not ready\n\t\t\t\t\tif ( member->ready_for_outgoing == 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue ;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (member != dtmf_source_member)\n\t\t\t\t\t{\n \t\t\t\t\t\t// Send the latest frame\n\t\t\t\t\t\tqueue_outgoing_dtmf_frame(member, cfr->fr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Garbage collection\n\t\t\t\tdelete_conf_frame(cfr);\n\t\t\t}\n\t\t}\n\n\t\t//---------//\n\t\t// CLEANUP //\n\t\t//---------//\n\n\t\t// clean up send frames\n\t\twhile ( send_frames != NULL )\n\t\t{\n\t\t\t// accouting: count all frames and mixed frames\n\t\t\tif ( send_frames->member == NULL )\n\t\t\t\tconf->stats.frames_out++ ;\n\t\t\telse\n\t\t\t\tconf->stats.frames_mixed++ ;\n\n\t\t\t// delete the frame\n\t\t\tsend_frames = delete_conf_frame( send_frames ) ;\n\t\t}\n\n\t\t//\n\t\t// notify the manager of state changes every 100 milliseconds\n\t\t// we piggyback on this for VAD switching logic\n\t\t//\n\n\t\tif ( ( ast_tvdiff_ms(curr, notify) / AST_CONF_NOTIFICATION_SLEEP ) >= 1 )\n\t\t{\n\t\t\t// Do VAD switching logic\n\t\t\t// We need to do this here since send_state_change_notifications\n\t\t\t// resets the flags\n\t\t\tif ( !conf->video_locked )\n\t\t\t\tdo_VAD_switching(conf);\n\n\t\t\t// send the notifications\n\t\t\tsend_state_change_notifications( conf->memberlist ) ;\n\n\t\t\t// increment the notification timer base\n\t\t\tadd_milliseconds( &notify, AST_CONF_NOTIFICATION_SLEEP ) ;\n\t\t}\n\n\t\t// release conference mutex\n\t\tast_mutex_unlock( &conf->lock ) ;\n\n\t\t// !!! TESTING !!!\n\t\t// usleep( 1 ) ;\n\t}\n\t// end while ( 42 == 42 )\n\n\t//\n\t// exit the conference thread\n\t//\n\n\tast_log( AST_CONF_DEBUG, \"exit conference_exec\\n\" ) ;\n\n\t// exit the thread\n\tpthread_exit( NULL ) ;\n\n\treturn ;\n}", "path": "conference.c", "repo_name": "mcr/app-conference", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 168}
{"docstring": "// get the next frame from the soundq;  must be called with member locked.\n", "func_signal": "static struct ast_frame *get_next_soundframe(struct ast_conf_member *member, struct ast_frame\n    *exampleframe)", "code": "{\n    struct ast_frame *f;\n\nagain:\n    f=ast_readframe(member->soundq->stream);\n\n    if(!f) { // we're done with this sound; remove it from the queue, and try again\n\tstruct ast_conf_soundq *toboot = member->soundq;\n\n\tast_closestream(toboot->stream);\n\tmember->soundq = toboot->next;\n\n\t//ast_log( LOG_WARNING, \"finished playing a sound, next = %x\\n\", member->soundq);\n\t// notify applications via mgr interface that this sound has been played\n\tmanager_event(\n\t\tEVENT_FLAG_CALL,\n\t\t\"ConferenceSoundComplete\",\n\t\t\"Channel: %s\\r\\n\"\n\t\t\"Sound: %s\\r\\n\",\n\t\tmember->channel_name,\n\t\ttoboot->name\n\t);\n\n\tfree(toboot);\n\tif(member->soundq) goto again;\n\n\t// if we get here, we've gotten to the end of the queue; reset write format\n\tif ( ast_set_write_format( member->chan, member->write_format ) < 0 )\n\t{\n\t\tast_log( LOG_ERROR, \"unable to set write format to %d\\n\",\n\t\t    member->write_format ) ;\n\t}\n    } else {\n\t// copy delivery from exampleframe\n\tf->delivery = exampleframe->delivery;\n    }\n\n    return f;\n}", "path": "member.c", "repo_name": "mcr/app-conference", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 168}
{"docstring": "//\n// slinear frame functions\n//\n", "func_signal": "struct ast_frame* create_slinear_frame( char* data )", "code": "{\n\tstruct ast_frame* f ;\n\n\tf = calloc( 1, sizeof( struct ast_frame ) ) ;\n\tif ( f == NULL )\n\t{\n\t\tast_log( LOG_ERROR, \"unable to allocate memory for slinear frame\\n\" ) ;\n\t\treturn NULL ;\n\t}\n\n\tf->frametype = AST_FRAME_VOICE ;\n\tf->subclass = AST_FORMAT_SLINEAR ;\n\tf->samples = AST_CONF_BLOCK_SAMPLES ;\n\tf->offset = AST_FRIENDLY_OFFSET ;\n\tf->mallocd = AST_MALLOCD_HDR | AST_MALLOCD_DATA ;\n\n\tf->datalen = AST_CONF_FRAME_DATA_SIZE ;\n\tf->data = data ;\n\n\tf->src = NULL ;\n\n\treturn f ;\n}", "path": "frame.c", "repo_name": "mcr/app-conference", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 168}
{"docstring": "// This function should be called with conflist_lock mutex being held\n", "func_signal": "static struct ast_conference* find_conf( const char* name )", "code": "{\n\t// no conferences exist\n\tif ( conflist == NULL )\n\t{\n\t\tast_log( AST_CONF_DEBUG, \"conflist has not yet been initialized, name => %s\\n\", name ) ;\n\t\treturn NULL ;\n\t}\n\n\tstruct ast_conference *conf = conflist ;\n\n\t// loop through conf list\n\twhile ( conf != NULL )\n\t{\n\t\tif ( strncasecmp( (char*)&(conf->name), name, 80 ) == 0 )\n\t\t{\n\t\t\t// found conf name match\n\t\t\tast_log( AST_CONF_DEBUG, \"found conference in conflist, name => %s\\n\", name ) ;\n\t\t\treturn conf;\n\t\t}\n\t\tconf = conf->next ;\n\t}\n\n\tast_log( AST_CONF_DEBUG, \"unable to find conference in conflist, name => %s\\n\", name ) ;\n\treturn NULL;\n}", "path": "conference.c", "repo_name": "mcr/app-conference", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 168}
{"docstring": "/* Dump list of conference info */\n", "func_signal": "int manager_conference_list( struct mansession *s, const struct message *m )", "code": "{\n\tconst char *id = astman_get_header(m,\"ActionID\");\n\tconst char *conffilter = astman_get_header(m,\"Conference\");\n\tchar idText[256] = \"\";\n\tstruct ast_conf_member *member;\n\n\tastman_send_ack(s, m, \"Conference list will follow\");\n\n  // no conferences exist\n\tif ( conflist == NULL )\n\t\tast_log( AST_CONF_DEBUG, \"conflist has not yet been initialized, name => %s\\n\", conffilter );;\n\n\tif (!ast_strlen_zero(id)) {\n\t\tsnprintf(idText,256,\"ActionID: %s\\r\\n\",id);\n\t}\n\n\t// acquire mutex\n\tast_mutex_lock( &conflist_lock ) ;\n\n\tstruct ast_conference *conf = conflist ;\n\n\t// loop through conf list\n\twhile ( conf != NULL )\n\t{\n\t\tif ( strncasecmp( (const char*)&(conf->name), conffilter, 80 ) == 0 )\n\t\t{\n\t\t\t// do the biz\n\t\t\tmember = conf->memberlist ;\n\t\t\twhile (member != NULL)\n\t\t\t  {\n\t\t\t\t\tastman_append(s, \"Event: ConferenceEntry\\r\\n\"\n\t\t\t\t\t\t\"ConferenceName: %s\\r\\n\"\n\t\t\t\t\t\t\"Member: %d\\r\\n\"\n\t\t\t\t\t\t\"Channel: %s\\r\\n\"\n\t\t\t\t\t\t\"CallerID: %s\\r\\n\"\n\t\t\t\t\t\t\"CallerIDName: %s\\r\\n\"\n\t\t\t\t\t\t\"Muted: %s\\r\\n\"\n\t\t\t\t\t\t\"VideoMuted: %s\\r\\n\"\n\t\t\t\t\t\t\"Default: %s\\r\\n\"\n\t\t\t\t\t\t\"Current: %s\\r\\n\"\n\t\t\t\t\t\t\"%s\"\n\t\t\t\t\t\t\"\\r\\n\",\n\t\t\t\t\t\tconf->name,\n\t\t\t\t\t\tmember->id,\n\t\t\t\t\t\tmember->channel_name,\n\t\t\t\t\t\tmember->chan->cid.cid_num ? member->chan->cid.cid_num : \"unknown\",\n\t\t\t\t\t\tmember->chan->cid.cid_name ? member->chan->cid.cid_name : \"unknown\",\n\t\t\t\t\t\tmember->mute_audio ? \"YES\" : \"NO\",\n\t\t\t\t\t\tmember->mute_video ? \"YES\" : \"NO\",\n\t\t\t\t\t\tmember->id == conf->default_video_source_id ? \"YES\" : \"NO\",\n\t\t\t\t\t\tmember->id == conf->current_video_source_id ? \"YES\" : \"NO\",\n\t\t\t\t\t\tidText);\n\t\t\t    member = member->next;\n\t\t\t  }\n\t\t\tbreak ;\n\t\t}\n\n\t\tconf = conf->next ;\n\t}\n\n\t// release mutex\n\tast_mutex_unlock( &conflist_lock ) ;\n\n\tastman_append(s,\n\t\t\"Event: ConferenceListComplete\\r\\n\"\n\t\t\"%s\"\n\t\t\"\\r\\n\",idText);\n\n\treturn RESULT_SUCCESS;\n}", "path": "conference.c", "repo_name": "mcr/app-conference", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 168}
{"docstring": "//\n// outgoing frame functions\n//\n", "func_signal": "conf_frame* get_outgoing_frame( struct ast_conf_member *member )", "code": "{\n\tif ( member == NULL )\n\t{\n\t\tast_log( LOG_WARNING, \"unable to get frame from null member\\n\" ) ;\n\t\treturn NULL ;\n\t}\n\n\tconf_frame* cfr ;\n\n\t// ast_log( AST_CONF_DEBUG, \"getting member frames, count => %d\\n\", member->outFramesCount ) ;\n\n\tast_mutex_lock(&member->lock);\n\n\tif ( member->outFramesCount > AST_CONF_MIN_QUEUE )\n\t{\n\t\tcfr = member->outFramesTail ;\n\n\t\t// if it's the only frame, reset the queu,\n\t\t// else, move the second frame to the front\n\t\tif ( member->outFramesTail == member->outFrames )\n\t\t{\n\t\t\tmember->outFrames = NULL ;\n\t\t\tmember->outFramesTail = NULL ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// move the pointer to the next frame\n\t\t\tmember->outFramesTail = member->outFramesTail->prev ;\n\n\t\t\t// reset it's 'next' pointer\n\t\t\tif ( member->outFramesTail != NULL )\n\t\t\t\tmember->outFramesTail->next = NULL ;\n\t\t}\n\n\t\t// separate the conf frame from the list\n\t\tcfr->next = NULL ;\n\t\tcfr->prev = NULL ;\n\n\t\t// decriment frame count\n\t\tmember->outFramesCount-- ;\n\t\tast_mutex_unlock(&member->lock);\n\t\treturn cfr ;\n\t}\n\tast_mutex_unlock(&member->lock);\n\treturn NULL ;\n}", "path": "member.c", "repo_name": "mcr/app-conference", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 168}
{"docstring": "// Functions that will increase and decrease speaker_count in a secure way, locking the member mutex if required\n// Will also set speaking_state flag.\n// Returns the previous speaking state\n", "func_signal": "int increment_speaker_count(struct ast_conf_member *member, int lock)", "code": "{\n\tint old_state;\n\n\tif ( lock )\n\t\tast_mutex_lock(&member->lock);\n\n\told_state = member->speaking_state;\n\tmember->speaker_count++;\n\tmember->speaking_state = 1;\n\n\tast_log(AST_CONF_DEBUG, \"Increment speaker count: id=%d, count=%d\\n\", member->id, member->speaker_count);\n\n\t// If this is a state change, update the timestamp\n\tif ( old_state == 0 )\n\t{\n\t\tmember->speaking_state_notify = 1;\n\t\tmember->last_state_change = ast_tvnow();\n\t}\n\n\tif ( lock )\n\t\tast_mutex_unlock(&member->lock);\n\n\treturn old_state;\n}", "path": "member.c", "repo_name": "mcr/app-conference", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 168}
{"docstring": "//\n// main member thread function\n//\n", "func_signal": "int member_exec( struct ast_channel* chan, void* data )", "code": "{\n//\tstruct timeval start, end ;\n//\tstart = ast_tvnow();\n\n\tstruct ast_conference *conf ;\n\tstruct ast_conf_member *member ;\n\n\tstruct ast_frame *f ; // frame received from ast_read()\n\n\tint left = 0 ;\n\tint res;\n\n\tast_log( AST_CONF_DEBUG, \"Begin processing member thread, channel => %s\\n\", chan->name ) ;\n\n\t//\n\t// If the call has not yet been answered, answer the call\n\t// Note: asterisk apps seem to check _state, but it seems like it's safe\n\t// to just call ast_answer.  It will just do nothing if it is up.\n\t// it will also return -1 if the channel is a zombie, or has hung up.\n\t//\n\n\tres = ast_answer( chan ) ;\n\tif ( res )\n\t{\n\t\tast_log( LOG_ERROR, \"unable to answer call\\n\" ) ;\n\t\treturn -1 ;\n\t}\n\n\t//\n\t// create a new member for the conference\n \t//\n\n//\tast_log( AST_CONF_DEBUG, \"creating new member, id => %s, flags => %s, p => %s\\n\",\n//\t\tid, flags, priority ) ;\n\n\tmember = create_member( chan, (const char*)( data ) ) ; // flags, atoi( priority ) ) ;\n\n\t// unable to create member, return an error\n\tif ( member == NULL )\n\t{\n\t\tast_log( LOG_ERROR, \"unable to create member\\n\" ) ;\n\t\treturn -1 ;\n\t}\n\n\t//\n\t// setup asterisk read/write formats\n\t//\n#if 0\n\tast_log( AST_CONF_DEBUG, \"CHANNEL INFO, CHANNEL => %s, DNID => %s, CALLER_ID => %s, ANI => %s\\n\",\n\t\tchan->name, chan->dnid, chan->callerid, chan->ani ) ;\n\n\tast_log( AST_CONF_DEBUG, \"CHANNEL CODECS, CHANNEL => %s, NATIVE => %d, READ => %d, WRITE => %d\\n\",\n\t\tchan->name, chan->nativeformats, member->read_format, member->write_format ) ;\n#endif\n\tif ( ast_set_read_format( chan, member->read_format ) < 0 )\n\t{\n\t\tast_log( LOG_ERROR, \"unable to set read format to signed linear\\n\" ) ;\n\t\tdelete_member( member ) ;\n\t\treturn -1 ;\n\t}\n\n\tif ( ast_set_write_format( chan, member->write_format ) < 0 ) // AST_FORMAT_SLINEAR, chan->nativeformats\n\t{\n\t\tast_log( LOG_ERROR, \"unable to set write format to signed linear\\n\" ) ;\n\t\tdelete_member( member ) ;\n\t\treturn -1 ;\n\t}\n\n\t//\n\t// setup a conference for the new member\n\t//\n\n\tconf = join_conference( member ) ;\n\n\tif ( conf == NULL )\n\t{\n\t\tast_log( LOG_ERROR, \"unable to setup member conference\\n\" ) ;\n\t\tdelete_member( member) ;\n\t\treturn -1 ;\n\t}\n\n\n\tmanager_event(\n\t\tEVENT_FLAG_CALL,\n\t\t\"ConferenceJoin\",\n\t\t\"ConferenceName: %s\\r\\n\"\n\t\t\"Member: %d\\r\\n\"\n\t\t\"Channel: %s\\r\\n\"\n\t\t\"CallerID: %s\\r\\n\"\n\t\t\"CallerIDName: %s\\r\\n\"\n\t\t\"Count: %d\\r\\n\",\n\t\tconf->name,\n\t\tmember->id,\n\t\tmember->channel_name,\n\t\tmember->chan->cid.cid_num ? member->chan->cid.cid_num : \"unknown\",\n\t\tmember->chan->cid.cid_name ? member->chan->cid.cid_name: \"unknown\",\n\t\tconf->membercount\n\t) ;\n\n\t// Store the CID information\n\tif ( member->chan->cid.cid_num )\n\t{\n\t\tif ( (member->callerid = malloc(strlen(member->chan->cid.cid_num)+1)) )\n\t\t\tmemcpy(member->callerid,member->chan->cid.cid_num, strlen(member->chan->cid.cid_num)+1);\n\t} else\n\t\tmember->callerid = NULL;\n\n\tif ( member->chan->cid.cid_name )\n\t{\n\t\tif ( (member->callername = malloc(strlen(member->chan->cid.cid_name)+1)) )\n\t\t\tmemcpy(member->callername, member->chan->cid.cid_name, strlen(member->chan->cid.cid_name)+1);\n\t} else\n\t\tmember->callername = NULL;\n\n\n\t//\n\t// process loop for new member ( this runs in it's own thread )\n\t//\n\n\tast_log( AST_CONF_DEBUG, \"begin member event loop, channel => %s\\n\", chan->name ) ;\n\n\t// timer timestamps\n\tstruct timeval base, curr ;\n\tbase = ast_tvnow();\n\n\t// tell conference_exec we're ready for frames\n\tmember->ready_for_outgoing = 1 ;\n\twhile ( 42 == 42 )\n\t{\n\t\t// make sure we have a channel to process\n\t\tif ( chan == NULL )\n\t\t{\n\t\t\tast_log( LOG_NOTICE, \"member channel has closed\\n\" ) ;\n\t\t\tbreak ;\n\t\t}\n\n\t\t//-----------------//\n\t\t// INCOMING FRAMES //\n\t\t//-----------------//\n\n\t\t// wait for an event on this channel\n\t\tleft = ast_waitfor( chan, AST_CONF_WAITFOR_LATENCY ) ;\n\n\t\t//ast_log( AST_CONF_DEBUG, \"received event on channel, name => %s, left => %d\\n\", chan->name, left ) ;\n\n\t\tif ( left < 0 )\n\t\t{\n\t\t\t// an error occured\n\t\t\tast_log(\n\t\t\t\tLOG_NOTICE,\n\t\t\t\t\"an error occured waiting for a frame, channel => %s, error => %d\\n\",\n\t\t\t\tchan->name, left\n\t\t\t) ;\n\t\t\tbreak; // out of the 42==42\n\t\t}\n\t\telse if ( left == 0 )\n\t\t{\n\t\t\t// no frame has arrived yet\n\t\t\t// ast_log( LOG_NOTICE, \"no frame available from channel, channel => %s\\n\", chan->name ) ;\n\t\t}\n\t\telse if ( left > 0 )\n\t\t{\n\t\t\t// a frame has come in before the latency timeout\n\t\t\t// was reached, so we process the frame\n\n\t\t\tf = ast_read( chan ) ;\n\n\t\t\tif ( f == NULL )\n\t\t\t{\n\t\t\t\tif (conf->debug_flag)\n\t\t\t\t{\n\t\t\t\t\tast_log( LOG_NOTICE, \"unable to read from channel, channel => %s\\n\", chan->name ) ;\n\t\t\t\t// They probably want to hangup...\n\t\t\t\t}\n\t\t\t\tbreak ;\n\t\t\t}\n\n\t\t\t// actually process the frame: break if we got hangup.\n\t\t\tif(process_incoming(member, conf, f)) break;\n\n\t\t}\n\n\t\tif (member_checkkick(member)) break;\n\n\t\t//-----------------//\n\t\t// OUTGOING FRAMES //\n\t\t//-----------------//\n\n\t\t// update the current timestamps\n\t\tcurr = ast_tvnow();\n\n\t\tprocess_outgoing(member);\n\t\t// back to process incoming frames\n\t\tcontinue ;\n\t}\n\n\tast_log( AST_CONF_DEBUG, \"end member event loop, time_entered => %ld\\n\", member->time_entered.tv_sec ) ;\n\n\t//\n\t// clean up\n\t//\n\n#ifdef DEBUG_OUTPUT_PCM\n\t// !!! TESTING !!!\n\tif ( incoming_fh != NULL )\n\t\tfclose( incoming_fh ) ;\n#endif\n\n\t// If we're driving another member, make sure its speaker count is correct\n\tif ( member != NULL ) member->remove_flag = 1 ;\n\n//\tend = ast_tvnow();\n//\tint expected_frames = ( int )( floor( (double)( msecdiff( &end, &start ) / AST_CONF_FRAME_INTERVAL ) ) ) ;\n//\tast_log( AST_CONF_DEBUG, \"expected_frames => %d\\n\", expected_frames ) ;\n\n\treturn 0 ;\n}", "path": "member.c", "repo_name": "mcr/app-conference", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 168}
{"docstring": "//\n// manange member functions\n//\n", "func_signal": "struct ast_conf_member* create_member( struct ast_channel *chan, const char* data )", "code": "{\n\t//\n\t// check input\n\t//\n\n\tif ( chan == NULL )\n\t{\n\t\tast_log( LOG_ERROR, \"unable to create member with null channel\\n\" ) ;\n\t\treturn NULL ;\n\t}\n\n\tif ( chan->name == NULL )\n\t{\n\t\tast_log( LOG_ERROR, \"unable to create member with null channel name\\n\" ) ;\n\t\treturn NULL ;\n\t}\n\n\t//\n\t// allocate memory for new conference member\n\t//\n\n\tstruct ast_conf_member *member = calloc( 1,  sizeof( struct ast_conf_member ) ) ;\n\n\tif ( member == NULL )\n\t{\n\t\tast_log( LOG_ERROR, \"unable to malloc ast_conf_member\\n\" ) ;\n\t\treturn NULL ;\n\t}\n\n\t// initialize mutex\n\tast_mutex_init( &member->lock ) ;\n\n\t// Default values for parameters that can get overwritten by dialplan arguments\n\tmember->video_start_timeout = AST_CONF_VIDEO_START_TIMEOUT;\n\tmember->video_stop_timeout = AST_CONF_VIDEO_STOP_TIMEOUT;\n\tmember->priority = 0;\n\tmember->vad_prob_start = AST_CONF_PROB_START;\n\tmember->vad_prob_continue = AST_CONF_PROB_CONTINUE;\n\n\t//\n\t// initialize member with passed data values\n\t//\n\tchar argstr[256] ;\n\n\t// copy the passed data\n\tstrncpy( argstr, data, sizeof(argstr) - 1 ) ;\n\n\t// point to the copied data\n\tchar *stringp = argstr;\n\n\tast_log( AST_CONF_DEBUG, \"attempting to parse passed params, stringp => %s\\n\", stringp ) ;\n\n\t// parse the id\n\tchar *token;\n\tif ( ( token = strsep( &stringp, \"/\" ) ) != NULL )\n\t{\n\t\tmember->conf_name = malloc( strlen( token ) + 1 ) ;\n\t\tstrcpy( member->conf_name, token ) ;\n\t}\n\telse\n\t{\n\t\tast_log( LOG_ERROR, \"unable to parse member id\\n\" ) ;\n\t\tfree( member ) ;\n\t\treturn NULL ;\n\t}\n\n\t// parse the flags\n\tif ( ( token = strsep( &stringp, \"/\" ) ) != NULL )\n\t{\n\t\tmember->flags = malloc( strlen( token ) + 1 ) ;\n\t\tstrcpy( member->flags, token ) ;\n\t}\n\telse\n\t{\n\t\t// make member->flags something\n\t\tmember->flags = malloc( sizeof( char ) ) ;\n\t\tmemset( member->flags, 0x0, sizeof( char ) ) ;\n\t}\n\n\twhile ( (token = strsep(&stringp, \"/\")) != NULL )\n\t{\n\t\tstatic const char arg_priority[] = \"priority\";\n\t\tstatic const char arg_vad_prob_start[] = \"vad_prob_start\";\n\t\tstatic const char arg_vad_prob_continue[] = \"vad_prob_continue\";\n\t\tstatic const char arg_video_start_timeout[] = \"video_start_timeout\";\n\t\tstatic const char arg_video_stop_timeout[] = \"video_stop_timeout\";\n\n\t\tchar *value = token;\n\t\tconst char *key = strsep(&value, \"=\");\n\t\t\n\t\tif ( key == NULL || value == NULL )\n\t\t{\n\t\t\tast_log(LOG_WARNING, \"Incorrect argument %s\\n\", token);\n\t\t\tcontinue;\n\t\t}\n\t\tif ( strncasecmp(key, arg_priority, sizeof(arg_priority) - 1) == 0 )\n\t\t{\n\t\t\tmember->priority = strtol(value, (char **)NULL, 10);\n\t\t\tast_log(AST_CONF_DEBUG, \"priority = %d\\n\", member->priority);\n\t\t} else if ( strncasecmp(key, arg_vad_prob_start, sizeof(arg_vad_prob_start) - 1) == 0 )\n\t\t{\n\t\t\tmember->vad_prob_start = strtof(value, (char **)NULL);\n\t\t\tast_log(AST_CONF_DEBUG, \"vad_prob_start = %f\\n\", member->vad_prob_start);\n\t\t} else if ( strncasecmp(key, arg_vad_prob_continue, sizeof(arg_vad_prob_continue) - 1) == 0 )\n\t\t{\n\t\t\tmember->vad_prob_continue = strtof(value, (char **)NULL);\n\t\t\tast_log(AST_CONF_DEBUG, \"vad_prob_continue = %f\\n\", member->vad_prob_continue);\n\t\t} else if ( strncasecmp(key, arg_video_start_timeout, sizeof(arg_video_start_timeout) - 1) == 0 )\n\t\t{\n\t\t\tmember->video_start_timeout = strtol(value, (char **)NULL, 10);;\n\t\t\tast_log(AST_CONF_DEBUG, \"video_start_timeout = %d\\n\", member->video_start_timeout);\n\t\t} else if ( strncasecmp(key, arg_video_stop_timeout, sizeof(arg_video_stop_timeout) - 1) == 0 )\n\t\t{\n\t\t\tmember->video_stop_timeout = strtol(value, (char **)NULL, 10);;\n\t\t\tast_log(AST_CONF_DEBUG, \"video_stop_timeout = %d\\n\", member->video_stop_timeout);\n\t\t} else\n\t\t{\n\t\t\tast_log(LOG_WARNING, \"unknown parameter %s with value %s\\n\", key, value);\n\t\t}\n\t}\n\n\t//\n\t// initialize member with default values\n\t//\n\n\t// keep pointer to member's channel\n\tmember->chan = chan ;\n\n\t// copy the channel name\n\tmember->channel_name = malloc( strlen( chan->name ) + 1 ) ;\n\tstrcpy( member->channel_name, chan->name ) ;\n\n\t// ( default can be overridden by passed flags )\n\tmember->mute_audio = 0;\n\tmember->mute_video = 0;\n\tmember->norecv_audio = 0;\n\tmember->norecv_video = 0;\n\tmember->no_camera = 0;\n\n\t// moderator?\n\tmember->ismoderator = 0;\n\n\t// ready flag\n\tmember->ready_for_outgoing = 0 ;\n\n\t// incoming frame queue\n\tmember->inFrames = NULL ;\n\tmember->inFramesTail = NULL ;\n\tmember->inFramesCount = 0 ;\n\n\tmember->inVideoFrames = NULL ;\n\tmember->inVideoFramesTail = NULL ;\n\tmember->inVideoFramesCount = 0 ;\n\n\tmember->inDTMFFrames = NULL ;\n\tmember->inDTMFFramesTail = NULL ;\n\tmember->inDTMFFramesCount = 0 ;\n\n\tmember->inTextFrames = NULL ;\n\tmember->inTextFramesTail = NULL ;\n\tmember->inTextFramesCount = 0 ;\n\n\tmember->conference = 1; // we have switched req_id\n\tmember->dtmf_switch = 0; // no dtmf switch by default\n\tmember->dtmf_relay = 0; // no dtmf relay by default\n\n\t// start of day video ids\n\tmember->req_id = -1;\n\tmember->id = -1;\n\n\tmember->first_frame_received = 0; // cause a FIR after NAT delay\n\n\t// last frame caching\n\tmember->inFramesRepeatLast = 0 ;\n\tmember->inFramesLast = NULL ;\n\tmember->okayToCacheLast = 0 ;\n\n\t// outgoing frame queue\n\tmember->outFrames = NULL ;\n\tmember->outFramesTail = NULL ;\n\tmember->outFramesCount = 0 ;\n\n\tmember->outVideoFrames = NULL ;\n\tmember->outVideoFramesTail = NULL ;\n\tmember->outVideoFramesCount = 0 ;\n\n\tmember->outDTMFFrames = NULL ;\n\tmember->outDTMFFramesTail = NULL ;\n\tmember->outDTMFFramesCount = 0 ;\n\n\tmember->outTextFrames = NULL ;\n\tmember->outTextFramesTail = NULL ;\n\tmember->outTextFramesCount = 0 ;\n\n\t// ( not currently used )\n\t// member->samplesperframe = AST_CONF_BLOCK_SAMPLES ;\n\n\t// used for determining need to mix frames\n\t// and for management interface notification\n\t// and for VAD based video switching\n\tmember->speaking_state_notify = 0 ;\n\tmember->speaking_state = 0 ;\n\tmember->local_speaking_state = 0;\n\tmember->last_state_change = (struct timeval){0, 0};\n\tmember->speaker_count = 0;\n\tmember->driven_member = NULL;\n\n\tmember->video_broadcast_active = 0;\n\tmember->last_video_frame_time = (struct timeval){0, 0};\n\n\tmember->video_started = 0;\n\n\t// linked-list pointer\n\tmember->next = NULL ;\n\n\t// account data\n\tmember->frames_in = 0 ;\n\tmember->frames_in_dropped = 0 ;\n\tmember->frames_out = 0 ;\n\tmember->frames_out_dropped = 0 ;\n\tmember->video_frames_in = 0 ;\n\tmember->video_frames_in_dropped = 0 ;\n\tmember->video_frames_out = 0 ;\n\tmember->video_frames_out_dropped = 0 ;\n\tmember->dtmf_frames_in = 0 ;\n\tmember->dtmf_frames_in_dropped = 0 ;\n\tmember->dtmf_frames_out = 0 ;\n\tmember->dtmf_frames_out_dropped = 0 ;\n\tmember->text_frames_in = 0 ;\n\tmember->text_frames_in_dropped = 0 ;\n\tmember->text_frames_out = 0 ;\n\tmember->text_frames_out_dropped = 0 ;\n\n\t// for counting sequentially dropped frames\n\tmember->sequential_drops = 0 ;\n\tmember->since_dropped = 0 ;\n\n\t// flags\n\tmember->remove_flag = 0 ;\n\tmember->kick_flag = 0;\n\n\t// record start time\n\t// init dropped frame timestamps\n\t// init state change timestamp\n\tmember->time_entered =\n\t\tmember->last_in_dropped =\n\t\tmember->last_out_dropped =\n\t\tmember->last_state_change = ast_tvnow();\n\n\t//\n\t// parse passed flags\n\t//\n\n\t// silence detection flags w/ defaults\n\tmember->vad_flag = 0 ;\n\tmember->denoise_flag = 0 ;\n\tmember->agc_flag = 0 ;\n\n\t// is this member using the telephone?\n\tmember->via_telephone = 0 ;\n\t\n\t// temp pointer to flags string\n\tchar* flags = member->flags ;\n\n\tint i;\n\n\tfor ( i = 0 ; i < strlen( flags ) ; ++i )\n\t{\n\n\t\tif (flags[i] >= (int)'0' && flags[i] <= (int)'9')\n\t\t{\n\t\t\tif (member->req_id < 0)\n\t\t\t{\n\t\t\t\tmember->req_id = flags[i] - (int)'0';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint newid = flags[i] - (int)'0';\n\t\t\t\t// need to boot anyone with this id already\n\t\t\t\t// will happen in add_member\n\t\t\t\tmember->id = newid;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// allowed flags are C, c, L, l, V, D, A, C, X, R, T, t, M, S, z, o, F\n\t\t\t// mute/no_recv options\n\t\t\tswitch ( flags[i] )\n\t\t\t{\n\t\t\tcase 'C':\n\t\t\t\tmember->mute_video = 1;\n\t\t\t\tbreak ;\n\t\t\tcase 'c':\n\t\t\t\tmember->norecv_video = 1;\n\t\t\t\tbreak ;\n\t\t\tcase 'L':\n\t\t\t\tmember->mute_audio = 1;\n\t\t\t\tbreak ;\n\t\t\tcase 'l':\n\t\t\t\tmember->norecv_audio = 1;\n\t\t\t\tbreak;\n\n\t\t\t\t// speex preprocessing options\n\t\t\tcase 'V':\n\t\t\t\tmember->vad_flag = 1 ;\n\t\t\t\tbreak ;\n\t\t\tcase 'D':\n\t\t\t\tmember->denoise_flag = 1 ;\n\t\t\t\tbreak ;\n\t\t\tcase 'A':\n\t\t\t\tmember->agc_flag = 1 ;\n\t\t\t\tbreak ;\n\n\t\t\t\t// dtmf/moderator/video switching options\n\t\t\tcase 'X':\n\t\t\t\tmember->dtmf_switch = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\tmember->dtmf_relay = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tmember->vad_switch = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'F':\n\t\t\t\tmember->force_vad_switch = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'M':\n\t\t\t\tmember->ismoderator = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'N':\n\t\t\t\tmember->no_camera = 1;\n\t\t\t\tbreak;\n\t\t\tcase 't':\n\t\t\t\tmember->does_text = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'z':\n\t\t\t\tmember->vad_linger = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'o':\n\t\t\t\tmember->does_chat_mode = 1;\n\t\t\t\tbreak;\n\n\t\t\t\t//Telephone connection\n\t\t\tcase 'T':\n\t\t\t\tmember->via_telephone = 1;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tast_log( LOG_WARNING, \"received invalid flag, chan => %s, flag => %c\\n\",\n\t\t\t\t\t chan->name, flags[i] );\n\t\t\t\tbreak ;\n\t\t\t}\n\t\t}\n\t}\n\n\t// set the dsp to null so silence detection is disabled by default\n\tmember->dsp = NULL ;\n\n#if ( SILDET == 2 )\n\t//\n\t// configure silence detection and preprocessing\n\t// if the user is coming in via the telephone,\n\t// and is not listen-only\n\t//\n\tif (\n\t\tmember->via_telephone == 1\n\t\t&& member->type != 'L'\n\t)\n\t{\n\t\t// create a speex preprocessor\n\t\tmember->dsp = speex_preprocess_state_init( AST_CONF_BLOCK_SAMPLES, AST_CONF_SAMPLE_RATE ) ;\n\n\t\tif ( member->dsp == NULL )\n\t\t{\n\t\t\tast_log( LOG_WARNING, \"unable to initialize member dsp, channel => %s\\n\", chan->name ) ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tast_log( LOG_NOTICE, \"member dsp initialized, channel => %s, v => %d, d => %d, a => %d\\n\",\n\t\t\t\tchan->name, member->vad_flag, member->denoise_flag, member->agc_flag ) ;\n\n\t\t\t// set speex preprocessor options\n\t\t\tspeex_preprocess_ctl( member->dsp, SPEEX_PREPROCESS_SET_VAD, &(member->vad_flag) ) ;\n\t\t\tspeex_preprocess_ctl( member->dsp, SPEEX_PREPROCESS_SET_DENOISE, &(member->denoise_flag) ) ;\n\t\t\tspeex_preprocess_ctl( member->dsp, SPEEX_PREPROCESS_SET_AGC, &(member->agc_flag) ) ;\n\n\t\t\tspeex_preprocess_ctl( member->dsp, SPEEX_PREPROCESS_SET_PROB_START, &member->vad_prob_start ) ;\n\t\t\tspeex_preprocess_ctl( member->dsp, SPEEX_PREPROCESS_SET_PROB_CONTINUE, &member->vad_prob_continue ) ;\n\n\t\t\tast_log( AST_CONF_DEBUG, \"speech_prob_start => %f, speech_prob_continue => %f\\n\",\n\t\t\t\tmember->dsp->speech_prob_start, member->dsp->speech_prob_continue ) ;\n\t\t}\n\t}\n#endif\n\n\t//\n\t// set connection type\n\t//\n\n\tif ( member->via_telephone == 1 )\n\t{\n\t\tmember->connection_type = 'T' ;\n\t}\n\telse if ( strncmp( member->channel_name, \"SIP\", 3 ) == 0 )\n\t{\n\t\tmember->connection_type = 'S' ;\n\t}\n\telse // default to iax\n\t{\n\t\tmember->connection_type = 'X' ;\n\t}\n\n\t//\n\t// read, write, and translation options\n\t//\n\n\t// set member's audio formats, taking dsp preprocessing into account\n\t// ( chan->nativeformats, AST_FORMAT_SLINEAR, AST_FORMAT_ULAW, AST_FORMAT_GSM )\n\tmember->read_format = ( member->dsp == NULL ) ? chan->nativeformats : AST_FORMAT_SLINEAR ;\n\n\tmember->write_format = chan->nativeformats;\n\n\t// 1.2 or 1.3+\n#ifdef AST_FORMAT_AUDIO_MASK\n\n\tmember->read_format &= AST_FORMAT_AUDIO_MASK;\n\tmember->write_format &= AST_FORMAT_AUDIO_MASK;\n#endif\n\n\t// translation paths ( ast_translator_build_path() returns null if formats match )\n\tmember->to_slinear = ast_translator_build_path( AST_FORMAT_SLINEAR, member->read_format ) ;\n\tmember->from_slinear = ast_translator_build_path( member->write_format, AST_FORMAT_SLINEAR ) ;\n\n\tast_log( AST_CONF_DEBUG, \"AST_FORMAT_SLINEAR => %d\\n\", AST_FORMAT_SLINEAR ) ;\n\n\t// index for converted_frames array\n\tswitch ( member->write_format )\n\t{\n\t\tcase AST_FORMAT_SLINEAR:\n\t\t\tmember->write_format_index = AC_SLINEAR_INDEX ;\n\t\t\tbreak ;\n\n\t\tcase AST_FORMAT_ULAW:\n\t\t\tmember->write_format_index = AC_ULAW_INDEX ;\n\t\t\tbreak ;\n\n\t        case AST_FORMAT_ALAW:\n\t\t\tmember->write_format_index = AC_ALAW_INDEX ;\n\t\t\tbreak ;\n\n\t\tcase AST_FORMAT_GSM:\n\t\t\tmember->write_format_index = AC_GSM_INDEX ;\n\t\t\tbreak ;\n\n\t\tcase AST_FORMAT_SPEEX:\n\t\t\tmember->write_format_index = AC_SPEEX_INDEX;\n\t\t\tbreak;\n\n#ifdef AC_USE_G729A\n\t\tcase AST_FORMAT_G729A:\n\t\t\tmember->write_format_index = AC_G729A_INDEX;\n\t\t\tbreak;\n#endif\n\n\t\tdefault:\n\t\t\tmember->write_format_index = 0 ;\n\t}\n\n\t// index for converted_frames array\n\tswitch ( member->read_format )\n\t{\n\t\tcase AST_FORMAT_SLINEAR:\n\t\t\tmember->read_format_index = AC_SLINEAR_INDEX ;\n\t\t\tbreak ;\n\n\t\tcase AST_FORMAT_ULAW:\n\t\t\tmember->read_format_index = AC_ULAW_INDEX ;\n\t\t\tbreak ;\n\n\t\tcase AST_FORMAT_ALAW:\n\t\t\tmember->read_format_index = AC_ALAW_INDEX ;\n\t\t\tbreak ;\n\n\t\tcase AST_FORMAT_GSM:\n\t\t\tmember->read_format_index = AC_GSM_INDEX ;\n\t\t\tbreak ;\n\n\t\tcase AST_FORMAT_SPEEX:\n\t\t\tmember->read_format_index = AC_SPEEX_INDEX;\n\t\t\tbreak;\n\n#ifdef AC_USE_G729A\n\t\tcase AST_FORMAT_G729A:\n\t\t\tmember->read_format_index = AC_G729A_INDEX;\n\t\t\tbreak;\n#endif\n\n\t\tdefault:\n\t\t\tmember->read_format_index = 0 ;\n\t}\n\n\t// smoother defaults.\n\tmember->smooth_multiple =1;\n\tmember->smooth_size_in = -1;\n\tmember->smooth_size_out = -1;\n\tmember->inSmoother= NULL;\n\tmember->outPacker= NULL;\n\n\tswitch (member->read_format){\n\t\t/* these assumptions may be incorrect */\n\t\tcase AST_FORMAT_ULAW:\n\t\tcase AST_FORMAT_ALAW:\n\t\t\tmember->smooth_size_in  = 160; //bytes\n\t\t\tmember->smooth_size_out = 160; //samples\n\t\t\tbreak;\n\t\tcase AST_FORMAT_GSM:\n\t\t\t/*\n\t\t\tmember->smooth_size_in  = 33; //bytes\n\t\t\tmember->smooth_size_out = 160;//samples\n\t\t\t*/\n\t\t\tbreak;\n\t\tcase AST_FORMAT_SPEEX:\n\t\tcase AST_FORMAT_G729A:\n\t\t\t/* this assumptions are wrong\n\t\t\tmember->smooth_multiple = 2 ;  // for testing, force to dual frame\n\t\t\tmember->smooth_size_in  = 39;  // bytes\n\t\t\tmember->smooth_size_out = 160; // samples\n\t\t\t*/\n\t\t\tbreak;\n\t\tcase AST_FORMAT_SLINEAR:\n\t\t\tmember->smooth_size_in  = 320; //bytes\n\t\t\tmember->smooth_size_out = 160; //samples\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmember->inSmoother = NULL; //don't use smoother for this type.\n\t\t\t//ast_log( AST_CONF_DEBUG, \"smoother is NULL for member->read_format => %d\\n\", member->read_format);\n\t}\n\n\tif (member->smooth_size_in > 0){\n\t\tmember->inSmoother = ast_smoother_new(member->smooth_size_in);\n\t\tast_log( AST_CONF_DEBUG, \"created smoother(%d) for %d\\n\", member->smooth_size_in , member->read_format);\n\t}\n\n\t//\n\t// finish up\n\t//\n\n\tast_log( AST_CONF_DEBUG, \"created member, type => %c, priority => %d, readformat => %d\\n\",\n\t\tmember->type, member->priority, chan->readformat ) ;\n\n\treturn member ;\n}", "path": "member.c", "repo_name": "mcr/app-conference", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 168}
{"docstring": "// process outgoing frames for the channel, playing either normal conference audio,\n// or requested sounds\n", "func_signal": "static int process_outgoing(struct ast_conf_member *member)", "code": "{\n\tconf_frame* cf ; // frame read from the output queue\n\tstruct ast_frame *f;\n\tstruct ast_frame *realframe = NULL;\n\n\tfor(;;)\n\t{\n\t\t// acquire member mutex and grab a frame.\n\t\tast_mutex_lock( &member->lock ) ;\n\t\tcf = get_outgoing_frame( member ) ;\n\n                // if there's no frames exit the loop.\n\t\tif ( !cf )\n\t\t{\n\t\t\tast_mutex_unlock( &member->lock ) ;\n\t\t\tbreak;\n\t\t}\n\n\n\t\tf = cf->fr;\n\n\t\t// if we're playing sounds, we can just replace the frame with the\n\t\t// next sound frame, and send it instead\n\t\tif ( member->soundq )\n\t\t{\n\t\t\trealframe = f;\n\t\t\tf = get_next_soundframe(member, f);\n\t\t\tif ( !f )\n\t\t\t{\n\t\t\t\t// if we didn't get anything, just revert to \"normal\"\n\t\t\t\tf = realframe;\n\t\t\t\trealframe = NULL;\n\t\t\t} else\n\t\t\t{\n\t\t\t\t// We have a sound frame now, but we need to make sure it's the same\n\t\t\t\t// format as our channel write format\n\t\t\t\tint wf = member->chan->writeformat & AST_FORMAT_AUDIO_MASK;\n\t\t\t\tif ( f->frametype == AST_FRAME_VOICE && !(wf & f->subclass) )\n\t\t\t\t{\n\t\t\t\t\t// We need to change our channel's write format\n\t\t\t\t\tast_set_write_format(member->chan, f->subclass);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tast_mutex_unlock(&member->lock);\n\n\n#ifdef DEBUG_FRAME_TIMESTAMPS\n\t\t// !!! TESTING !!!\n\t\tint delivery_diff = usecdiff( &f->delivery, &member->lastsent_timeval ) ;\n\t\tif ( delivery_diff != AST_CONF_FRAME_INTERVAL )\n\t\t{\n\t\t\tast_log( AST_CONF_DEBUG, \"unanticipated delivery time, delivery_diff => %d, delivery.tv_usec => %ld\\n\",\n\t\t\t\t delivery_diff, f->delivery.tv_usec ) ;\n\t\t}\n\n\t\t// !!! TESTING !!!\n\t\tif (\n\t\t\tf->delivery.tv_sec < member->lastsent_timeval.tv_sec\n\t\t\t|| (\n\t\t\t\tf->delivery.tv_sec == member->lastsent_timeval.tv_sec\n\t\t\t\t&& f->delivery.tv_usec <= member->lastsent_timeval.tv_usec\n\t\t\t\t)\n\t\t\t)\n\t\t{\n\t\t\tast_log( LOG_WARNING, \"queued frame timestamped in the past, %ld.%ld <= %ld.%ld\\n\",\n\t\t\t\t f->delivery.tv_sec, f->delivery.tv_usec,\n\t\t\t\t member->lastsent_timeval.tv_sec, member->lastsent_timeval.tv_usec ) ;\n\t\t}\n\t\tmember->lastsent_timeval = f->delivery ;\n#endif\n\n#ifdef DEBUG_USE_TIMELOG\n\t\tTIMELOG( ast_write( member->chan, f ), 10, \"member: ast_write\");\n#else\n\n\t\t// send the voice frame\n\t\tif ( ast_write( member->chan, f ) == 0 )\n\t\t{\n\t\t\tstruct timeval tv = ast_tvnow();\n\t\t\tast_log( AST_CONF_DEBUG, \"SENT VOICE FRAME, channel => %s, frames_out => %ld, s => %ld, ms => %ld\\n\",\n\t\t\t\t member->channel_name, member->frames_out, tv.tv_sec, tv.tv_usec ) ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// log 'dropped' outgoing frame\n\t\t\tast_log( LOG_ERROR, \"unable to write voice frame to channel, channel => %s\\n\", member->channel_name ) ;\n\n\t\t\t// accounting: count dropped outgoing frames\n\t\t\tmember->frames_out_dropped++ ;\n\t\t}\n#endif\n\t\t// clean up frame\n\t\tdelete_conf_frame( cf ) ;\n\n\t}\n\n\t// Do the same for video, suck it dry\n\tfor(;;)\n\t{\n\t\t// grab a frame.\n\t\tcf = get_outgoing_video_frame( member ) ;\n\n                // if there's no frames exit the loop.\n\t\tif(!cf){\n\t\t\tbreak;\n\t\t}\n\n\t\tf = cf->fr;\n\n\t\t// send the video frame\n\t\tif ( ast_write_video( member->chan, f ) == 1 )\n\t\t{\n\t\t\tstruct timeval tv = ast_tvnow();\n\t\t\tast_log( AST_CONF_DEBUG, \"SENT VIDEO FRAME, channel => %s, frames_out => %ld, s => %ld, ms => %ld\\n\",\n\t\t\t\t member->channel_name, member->frames_out, tv.tv_sec, tv.tv_usec ) ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// log 'dropped' outgoing frame\n\t\t\tast_log( AST_CONF_DEBUG, \"unable to write video frame to channel, channel => %s\\n\", member->channel_name ) ;\n\n\t\t\t// accounting: count dropped outgoing frames\n\t\t\tmember->video_frames_out_dropped++ ;\n\t\t}\n\n\t\t// clean up frame\n\t\tdelete_conf_frame( cf ) ;\n\n\t}\n\n        // Do the same for dtmf, suck it dry\n\tfor(;;)\n\t{\n\t\t// acquire member mutex and grab a frame.\n\t\tcf = get_outgoing_dtmf_frame( member ) ;\n\n\t\t// if there's no frames exit the loop.\n\t\tif(!cf) break;\n\n\t\t// send the dtmf frame\n\t\tif ( ast_write( member->chan, cf->fr ) == 0 )\n\t\t{\n\t\t\tstruct timeval tv = ast_tvnow();\n\t\t\tast_log( AST_CONF_DEBUG, \"SENT DTMF FRAME, channel => %s, frames_out => %ld, s => %ld, ms => %ld\\n\",\n\t\t\t\t member->channel_name, member->frames_out, tv.tv_sec, tv.tv_usec ) ;\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// log 'dropped' outgoing frame\n\t\t\tast_log( AST_CONF_DEBUG, \"unable to write dtmf frame to channel, channel => %s\\n\", member->channel_name ) ;\n\n\t\t\t// accounting: count dropped outgoing frames\n\t\t\tmember->dtmf_frames_out_dropped++ ;\n\t\t}\n\n\t\t// clean up frame\n\t\tdelete_conf_frame( cf ) ;\n\t}\n\n        // Do the same for text, hell, why not?\n\tfor(;;)\n\t{\n\t\t// acquire member mutex and grab a frame.\n\t\tcf = get_outgoing_text_frame( member ) ;\n\n\t\t// if there's no frames exit the loop.\n\t\tif(!cf) break;\n\n\t\t// send the text frame\n\t\tif ( ast_write( member->chan, cf->fr ) == 0 )\n\t\t{\n\t\t\tstruct timeval tv = ast_tvnow();\n\t\t\tast_log( AST_CONF_DEBUG, \"SENT TEXT FRAME, channel => %s, frames_out => %ld, s => %ld, ms => %ld\\n\",\n\t\t\t\t member->channel_name, member->frames_out, tv.tv_sec, tv.tv_usec ) ;\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// log 'dropped' outgoing frame\n\t\t\tast_log( AST_CONF_DEBUG, \"unable to write text frame to channel, channel => %s\\n\", member->channel_name ) ;\n\n\t\t\t// accounting: count dropped outgoing frames\n\t\t\tmember->text_frames_out_dropped++ ;\n\t\t}\n\n\t\t// clean up frame\n\t\tdelete_conf_frame( cf ) ;\n\t}\n\n\n\treturn 0;\n}", "path": "member.c", "repo_name": "mcr/app-conference", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 168}
{"docstring": "/**\n * gupnp_device_info_get_context\n * @info: A #GUPnPDeviceInfo\n *\n * Get the associated #GUPnPContext.\n *\n * Returns: A #GUPnPContext.\n **/\n", "func_signal": "GUPnPContext *\ngupnp_device_info_get_context (GUPnPDeviceInfo *info)", "code": "{\n        g_return_val_if_fail (GUPNP_IS_DEVICE_INFO (info), NULL);\n\n        return info->priv->context;\n}", "path": "libgupnp\\gupnp-device-info.c", "repo_name": "lovebug356/gupnp", "stars": 1, "license": "other", "language": "c", "size": 828}
{"docstring": "/**\n * gupnp_device_info_get_service\n * @info: A #GUPnPDeviceInfo\n * @type: The type of the service to be retrieved.\n *\n * Get the service with type @type directly contained in @info as\n * a new object implementing #GUPnPServiceInfo, or %NULL if no such device\n * was found. The returned object should be unreffed when done.\n *\n * Note that services are not cached internally, so that every time you\n * call this function a new object is created. The application\n * must cache any used services if it wishes to keep them around and re-use\n * them.\n *\n * Return value: A #GUPnPServiceInfo.\n **/\n", "func_signal": "GUPnPServiceInfo *\ngupnp_device_info_get_service (GUPnPDeviceInfo *info,\n                               const char      *type)", "code": "{\n        GUPnPDeviceInfoClass *class;\n        GUPnPServiceInfo *service;\n        xmlNode *element;\n\n        g_return_val_if_fail (GUPNP_IS_DEVICE_INFO (info), NULL);\n\n        class = GUPNP_DEVICE_INFO_GET_CLASS (info);\n\n        g_return_val_if_fail (class->get_service, NULL);\n\n        service = NULL;\n\n        element = xml_util_get_element (info->priv->element,\n                                        \"serviceList\",\n                                        NULL);\n        if (!element)\n                return NULL;\n\n        for (element = element->children; element; element = element->next) {\n                if (!strcmp (\"service\", (char *) element->name)) {\n                        xmlNode *type_element;\n                        xmlChar *type_str;\n\n                        type_element = xml_util_get_element (element,\n                                                             \"serviceType\",\n                                                             NULL);\n                        if (!type_element)\n                                continue;\n\n                        type_str = xmlNodeGetContent (type_element);\n                        if (!type_str)\n                                continue;\n\n                        if (resource_type_match (type, (char *) type_str))\n                                service = class->get_service (info, element);\n\n                        xmlFree (type_str);\n\n                        if (service)\n                                break;\n                }\n        }\n\n        return service;\n}", "path": "libgupnp\\gupnp-device-info.c", "repo_name": "lovebug356/gupnp", "stars": 1, "license": "other", "language": "c", "size": 828}
{"docstring": "/**\n * gupnp_device_info_get_manufacturer_url\n * @info: A #GUPnPDeviceInfo\n *\n * Get a URL pointing to the manufacturer's website.\n *\n * Return value: A string, or %NULL. g_free() after use.\n **/\n", "func_signal": "char *\ngupnp_device_info_get_manufacturer_url (GUPnPDeviceInfo *info)", "code": "{\n        g_return_val_if_fail (GUPNP_IS_DEVICE_INFO (info), NULL);\n\n        return xml_util_get_child_element_content_url (info->priv->element,\n                                                       \"manufacturerURL\",\n                                                       info->priv->url_base);\n}", "path": "libgupnp\\gupnp-device-info.c", "repo_name": "lovebug356/gupnp", "stars": 1, "license": "other", "language": "c", "size": 828}
{"docstring": "/**\n * gupnp_device_info_list_dlna_capabilities\n * @info: A #GUPnPDeviceInfo\n *\n * Get a #GList of strings that represent the device capabilities as\n * announced in the device description file using the\n * &lt;dlna:X_DLNACAP&gt; element.\n *\n * Return value: a #GList of newly allocated strings or %NULL if\n *               the device description doesn't contain the\n *               &lt;dlna:X_DLNACAP&gt; element.\n **/\n", "func_signal": "GList *\ngupnp_device_info_list_dlna_capabilities (GUPnPDeviceInfo *info)", "code": "{\n        xmlChar *caps;\n\n        g_return_val_if_fail (GUPNP_IS_DEVICE_INFO (info), NULL);\n\n        caps = xml_util_get_child_element_content (info->priv->element,\n                                                   \"X_DLNACAP\");\n\n        if (caps) {\n                GList         *list  = NULL;\n                const xmlChar *start = caps;\n\n                while (*start) {\n                        const xmlChar *end = start;\n\n                        while (*end && *end != ',')\n                                end++;\n\n                        if (end > start) {\n                                gchar *value;\n\n                                value = g_strndup ((const gchar *) start,\n                                                   end - start);\n\n                                list = g_list_prepend (list, value);\n                        }\n\n                        if (*end)\n                                start = end + 1;\n                        else\n                                break;\n                }\n\n                xmlFree (caps);\n\n                return g_list_reverse (list);\n        }\n\n        return NULL;\n}", "path": "libgupnp\\gupnp-device-info.c", "repo_name": "lovebug356/gupnp", "stars": 1, "license": "other", "language": "c", "size": 828}
{"docstring": "/**\n * gupnp_device_info_get_friendly_name\n * @info: A #GUPnPDeviceInfo\n *\n * Get the friendly name of the device.\n * \n * Return value: A string, or %NULL. g_free() after use.\n **/\n", "func_signal": "char *\ngupnp_device_info_get_friendly_name (GUPnPDeviceInfo *info)", "code": "{\n        g_return_val_if_fail (GUPNP_IS_DEVICE_INFO (info), NULL);\n\n        return xml_util_get_child_element_content_glib (info->priv->element,\n                                                        \"friendlyName\");\n}", "path": "libgupnp\\gupnp-device-info.c", "repo_name": "lovebug356/gupnp", "stars": 1, "license": "other", "language": "c", "size": 828}
{"docstring": "/**\n * gupnp_device_info_get_udn\n * @info: A #GUPnPDeviceInfo\n *\n * Get the Unique Device Name of the device.\n *\n * Returns: A constant string.\n **/\n", "func_signal": "const char *\ngupnp_device_info_get_udn (GUPnPDeviceInfo *info)", "code": "{\n        g_return_val_if_fail (GUPNP_IS_DEVICE_INFO (info), NULL);\n\n        if (!info->priv->udn) {\n                info->priv->udn =\n                        xml_util_get_child_element_content_glib\n                                (info->priv->element, \"UDN\");\n        }\n\n        return info->priv->udn;\n}", "path": "libgupnp\\gupnp-device-info.c", "repo_name": "lovebug356/gupnp", "stars": 1, "license": "other", "language": "c", "size": 828}
{"docstring": "/**\n * gupnp_device_info_list_device_types\n * @info: A #GUPnPDeviceInfo\n *\n * Get a #GList of strings representing the types of the devices\n * directly contained in @info.\n *\n * Return value: A #GList of strings. The elements should be g_free()'d and the\n * list should be g_list_free()'d.\n **/\n", "func_signal": "GList *\ngupnp_device_info_list_device_types (GUPnPDeviceInfo *info)", "code": "{\n        GList *device_types;\n        xmlNode *element;\n\n        g_return_val_if_fail (GUPNP_IS_DEVICE_INFO (info), NULL);\n\n        device_types = NULL;\n\n        element = xml_util_get_element (info->priv->element,\n                                        \"deviceList\",\n                                        NULL);\n        if (!element)\n                return NULL;\n\n        for (element = element->children; element; element = element->next) {\n                if (!strcmp (\"device\", (char *) element->name)) {\n                        char *type;\n\n                        type = xml_util_get_child_element_content_glib\n                                                   (element, \"deviceType\");\n                        if (!type)\n                                continue;\n\n                        device_types = g_list_prepend (device_types, type);\n                }\n        }\n\n        return device_types;\n}", "path": "libgupnp\\gupnp-device-info.c", "repo_name": "lovebug356/gupnp", "stars": 1, "license": "other", "language": "c", "size": 828}
{"docstring": "/**\n * gupnp_device_info_get_device_type\n * @info: A #GUPnPDeviceInfo\n *\n * Get the UPnP device type.\n *\n * Returns: A constant string, or %NULL.\n **/\n", "func_signal": "const char *\ngupnp_device_info_get_device_type (GUPnPDeviceInfo *info)", "code": "{\n        g_return_val_if_fail (GUPNP_IS_DEVICE_INFO (info), NULL);\n\n        if (!info->priv->device_type) {\n                info->priv->device_type =\n                        xml_util_get_child_element_content_glib\n                                (info->priv->element, \"deviceType\");\n        }\n\n        return info->priv->device_type;\n}", "path": "libgupnp\\gupnp-device-info.c", "repo_name": "lovebug356/gupnp", "stars": 1, "license": "other", "language": "c", "size": 828}
{"docstring": "/**\n * gupnp_device_info_get_model_number\n * @info: A #GUPnPDeviceInfo\n *\n * Get the model number of the device.\n *\n * Return value: A string, or %NULL. g_free() after use.\n **/\n", "func_signal": "char *\ngupnp_device_info_get_model_number (GUPnPDeviceInfo *info)", "code": "{\n        g_return_val_if_fail (GUPNP_IS_DEVICE_INFO (info), NULL);\n\n        return xml_util_get_child_element_content_glib (info->priv->element,\n                                                        \"modelNumber\");\n}", "path": "libgupnp\\gupnp-device-info.c", "repo_name": "lovebug356/gupnp", "stars": 1, "license": "other", "language": "c", "size": 828}
{"docstring": "/* Returns TRUE if @query matches against @base. \n * - If @query does not specify a version, it matches any version specified\n *   in @base.\n * - If @query specifies a version, it matches any version specified in @base\n *   that is greater or equal.\n * */\n", "func_signal": "static gboolean\nresource_type_match (const char *query,\n                     const char *base)", "code": "{\n        gboolean match;\n        guint type_len;\n        char *colon;\n        guint query_ver, base_ver;\n\n        /* Inspect last colon (if any!) on @base */\n        colon = strrchr (base, ':');\n        if (G_UNLIKELY (colon == NULL))\n                return !strcmp (query, base); /* No colon */\n\n        /* Length of type until last colon */\n        type_len = strlen (base) - strlen (colon);\n\n        /* Match initial portions */\n        match = (strncmp (query, base, type_len) == 0);\n        if (match == FALSE)\n                return FALSE;\n\n        /* Initial portions matched. Try to position pointers after\n         * last colons of both @query and @base. */\n        colon += 1;\n        if (G_UNLIKELY (*colon == 0))\n                return TRUE;\n\n        query += type_len;\n        switch (*query) {\n        case 0:\n                return TRUE; /* @query does not specify a version */\n        case ':':\n                query += 1;\n                if (G_UNLIKELY (*query == 0))\n                        return TRUE;\n\n                break;\n        default:\n                return FALSE; /* Hmm, not EOS, nor colon.. bad */\n        }\n\n        /* Parse versions */\n        query_ver = atoi (query);\n        base_ver  = atoi (colon);\n\n        /* Compare versions */\n        return (query_ver <= base_ver);\n}", "path": "libgupnp\\gupnp-device-info.c", "repo_name": "lovebug356/gupnp", "stars": 1, "license": "other", "language": "c", "size": 828}
{"docstring": "/**\n * gupnp_device_info_get_presentation_url\n * @info: A #GUPnPDeviceInfo\n *\n * Get a URL pointing to the device's presentation page, for web-based\n * administration.\n * \n * Return value: A string, or %NULL. g_free() after use.\n **/\n", "func_signal": "char *\ngupnp_device_info_get_presentation_url (GUPnPDeviceInfo *info)", "code": "{\n        g_return_val_if_fail (GUPNP_IS_DEVICE_INFO (info), NULL);\n\n        return xml_util_get_child_element_content_url (info->priv->element,\n                                                       \"presentationURL\",\n                                                       info->priv->url_base);\n}", "path": "libgupnp\\gupnp-device-info.c", "repo_name": "lovebug356/gupnp", "stars": 1, "license": "other", "language": "c", "size": 828}
{"docstring": "/**\n * gupnp_device_info_get_upc\n * @info: A #GUPnPDeviceInfo\n *\n * Get the Universal Product Code of the device.\n *\n * Return value: A string, or %NULL. g_free() after use.\n **/\n", "func_signal": "char *\ngupnp_device_info_get_upc (GUPnPDeviceInfo *info)", "code": "{\n        g_return_val_if_fail (GUPNP_IS_DEVICE_INFO (info), NULL);\n\n        return xml_util_get_child_element_content_glib (info->priv->element,\n                                                        \"UPC\");\n}", "path": "libgupnp\\gupnp-device-info.c", "repo_name": "lovebug356/gupnp", "stars": 1, "license": "other", "language": "c", "size": 828}
{"docstring": "/**\n * gupnp_device_info_get_serial_number\n * @info: A #GUPnPDeviceInfo\n *\n * Get the serial number of the device.\n * \n * Return value: A string, or %NULL. g_free() after use.\n **/\n", "func_signal": "char *\ngupnp_device_info_get_serial_number (GUPnPDeviceInfo *info)", "code": "{\n        g_return_val_if_fail (GUPNP_IS_DEVICE_INFO (info), NULL);\n\n        return xml_util_get_child_element_content_glib (info->priv->element,\n                                                        \"serialNumber\");\n}", "path": "libgupnp\\gupnp-device-info.c", "repo_name": "lovebug356/gupnp", "stars": 1, "license": "other", "language": "c", "size": 828}
{"docstring": "/**\n * gupnp_device_info_list_services\n * @info: A #GUPnPDeviceInfo\n *\n * Get a #GList of new objects implementing #GUPnPServiceInfo\n * representing the services directly contained in @info. The returned list\n * should be g_list_free()'d and the elements should be g_object_unref()'d.\n *\n * Note that services are not cached internally, so that every time you\n * call this function new objects are created. The application\n * must cache any used services if it wishes to keep them around and re-use\n * them.\n *\n * Return value: A #GList of new #GUPnPServiceInfo objects.\n **/\n", "func_signal": "GList *\ngupnp_device_info_list_services (GUPnPDeviceInfo *info)", "code": "{\n        GUPnPDeviceInfoClass *class;\n        GList *services;\n        xmlNode *element;\n\n        g_return_val_if_fail (GUPNP_IS_DEVICE_INFO (info), NULL);\n\n        class = GUPNP_DEVICE_INFO_GET_CLASS (info);\n\n        g_return_val_if_fail (class->get_service, NULL);\n\n        services = NULL;\n\n        element = xml_util_get_element (info->priv->element,\n                                        \"serviceList\",\n                                        NULL);\n        if (!element)\n                return NULL;\n\n        for (element = element->children; element; element = element->next) {\n                if (!strcmp (\"service\", (char *) element->name)) {\n                        GUPnPServiceInfo *service;\n\n                        service = class->get_service (info, element);\n                        services = g_list_prepend (services, service);\n                }\n        }\n\n        return services;\n}", "path": "libgupnp\\gupnp-device-info.c", "repo_name": "lovebug356/gupnp", "stars": 1, "license": "other", "language": "c", "size": 828}
{"docstring": "/**\n * gupnp_device_info_get_manufacturer\n * @info: A #GUPnPDeviceInfo\n *\n * Get the manufacturer of the device.\n *\n * Return value: A string, or %NULL. g_free() after use.\n **/\n", "func_signal": "char *\ngupnp_device_info_get_manufacturer (GUPnPDeviceInfo *info)", "code": "{\n        g_return_val_if_fail (GUPNP_IS_DEVICE_INFO (info), NULL);\n\n        return xml_util_get_child_element_content_glib (info->priv->element,\n                                                        \"manufacturer\");\n}", "path": "libgupnp\\gupnp-device-info.c", "repo_name": "lovebug356/gupnp", "stars": 1, "license": "other", "language": "c", "size": 828}
{"docstring": "/**\n * gupnp_device_info_get_resource_factory\n * @device_info: A #GUPnPDeviceInfo\n *\n * Get the #GUPnPResourceFactory used by the @device_info.\n *\n * Returns: A #GUPnPResourceFactory.\n **/\n", "func_signal": "GUPnPResourceFactory *\ngupnp_device_info_get_resource_factory (GUPnPDeviceInfo *info)", "code": "{\n        g_return_val_if_fail (GUPNP_IS_DEVICE_INFO (info), NULL);\n\n        return info->priv->factory;\n}", "path": "libgupnp\\gupnp-device-info.c", "repo_name": "lovebug356/gupnp", "stars": 1, "license": "other", "language": "c", "size": 828}
{"docstring": "/**\n * gupnp_device_info_get_model_description\n * @info: A #GUPnPDeviceInfo\n *\n * Get the description of the device model.\n *\n * Return value: A string, or %NULL. g_free() after use.\n **/\n", "func_signal": "char *\ngupnp_device_info_get_model_description (GUPnPDeviceInfo *info)", "code": "{\n        g_return_val_if_fail (GUPNP_IS_DEVICE_INFO (info), NULL);\n\n        return xml_util_get_child_element_content_glib (info->priv->element,\n                                                        \"modelDescription\");\n}", "path": "libgupnp\\gupnp-device-info.c", "repo_name": "lovebug356/gupnp", "stars": 1, "license": "other", "language": "c", "size": 828}
{"docstring": "/**\n * gupnp_device_info_get_location\n * @info: A #GUPnPDeviceInfo\n *\n * Get the location of the device description file.\n *\n * Returns: A constant string.\n **/\n", "func_signal": "const char *\ngupnp_device_info_get_location (GUPnPDeviceInfo *info)", "code": "{\n        g_return_val_if_fail (GUPNP_IS_DEVICE_INFO (info), NULL);\n\n        return info->priv->location;\n}", "path": "libgupnp\\gupnp-device-info.c", "repo_name": "lovebug356/gupnp", "stars": 1, "license": "other", "language": "c", "size": 828}
{"docstring": "/**\n * gupnp_device_info_get_model_name\n * @info: A #GUPnPDeviceInfo\n *\n * Get the model name of the device.\n *\n * Return value: A string, or %NULL. g_free() after use.\n **/\n", "func_signal": "char *\ngupnp_device_info_get_model_name (GUPnPDeviceInfo *info)", "code": "{\n        g_return_val_if_fail (GUPNP_IS_DEVICE_INFO (info), NULL);\n\n        return xml_util_get_child_element_content_glib (info->priv->element,\n                                                        \"modelName\");\n}", "path": "libgupnp\\gupnp-device-info.c", "repo_name": "lovebug356/gupnp", "stars": 1, "license": "other", "language": "c", "size": 828}
{"docstring": "/**\n * gupnp_device_info_get_model_url\n * @info: A #GUPnPDeviceInfo\n *\n * Get a URL pointing to the device model's website.\n * \n * Return value: A string, or %NULL. g_free() after use.\n **/\n", "func_signal": "char *\ngupnp_device_info_get_model_url (GUPnPDeviceInfo *info)", "code": "{\n        g_return_val_if_fail (GUPNP_IS_DEVICE_INFO (info), NULL);\n\n        return xml_util_get_child_element_content_url (info->priv->element,\n                                                       \"modelURL\",\n                                                       info->priv->url_base);\n}", "path": "libgupnp\\gupnp-device-info.c", "repo_name": "lovebug356/gupnp", "stars": 1, "license": "other", "language": "c", "size": 828}
{"docstring": "/*\n * TODO:\n * - Some compiler format checks would be nice.\n * - Think about log_unexpected_file_line(), maybe use something else.\n */\n", "func_signal": "void\nlog_debug(int level, const char *format, ...)", "code": "{\n\tva_list args;\n\n\tva_start(args, format);\n\tisc_log_vwrite(dns_lctx, DNS_LOGCATEGORY_DATABASE, DNS_LOGMODULE_DYNDB,\n\t\t      ISC_LOG_DEBUG(level), format, args);\n#if 0\n\t/*\n\t * For now, behave same as log_error(), so we can see every debugging\n\t * logs without the need to specify -d.\n\t */\n\tisc_log_vwrite(dns_lctx, DNS_LOGCATEGORY_DATABASE, DNS_LOGMODULE_DYNDB,\n\t\t      ISC_LOG_ERROR, format, args);\n\t(void)level;\n#endif\n\n\tva_end(args);\n}", "path": "src\\log.c", "repo_name": "mnagy/bind-dyndb-ldap", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 208}
{"docstring": "/*\n * Return a const char * type.\n */\n", "func_signal": "const char *\nstr_buf(const ld_string_t *src)", "code": "{\n\tREQUIRE(src != NULL && src->data != NULL);\n\n\treturn src->data;\n}", "path": "src\\str.c", "repo_name": "mnagy/bind-dyndb-ldap", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 208}
{"docstring": "/*\n * Initialize a semaphore.\n *\n * sem - allocated semaphore that will be initialized\n * value - number of times we can acquire the semaphore.\n */\n", "func_signal": "isc_result_t\nsemaphore_init(semaphore_t *sem, int value)", "code": "{\n\tisc_result_t result;\n\n\tREQUIRE(sem != NULL);\n\tREQUIRE(value > 0);\n\n\tsem->value = value;\n\tresult = isc_mutex_init(&sem->mutex);\n\tif (result != ISC_R_SUCCESS)\n\t\treturn result;\n\n\tresult = isc_condition_init(&sem->cond);\n\tif (result != ISC_R_SUCCESS)\n\t\tisc_mutex_destroy(&sem->mutex);\n\n\treturn result;\n}", "path": "src\\semaphore.c", "repo_name": "mnagy/bind-dyndb-ldap", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 208}
{"docstring": "/*\n * Functions.\n *\n * Most of them don't need db parameter but we are checking if it is valid.\n * Invalid db parameter indicates bug in code.\n */\n", "func_signal": "static void\nattach(dns_db_t *source, dns_db_t **targetp)", "code": "{\n\tldapdb_t *ldapdb = (ldapdb_t *)source;\n\n\tREQUIRE(VALID_LDAPDB(ldapdb));\n\n\tisc_refcount_increment(&ldapdb->refs, NULL);\n\t*targetp = source;\n}", "path": "src\\ldap_driver.c", "repo_name": "mnagy/bind-dyndb-ldap", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 208}
{"docstring": "/*\n * Make a new string and copy src to it.\n */\n", "func_signal": "isc_result_t\nstr_clone(ld_string_t **dest, const ld_string_t *src _STR_MEM_FLARG)", "code": "{\n\tisc_result_t result;\n\n\tREQUIRE(src != NULL);\n\tREQUIRE(dest != NULL && *dest == NULL);\n\n\tCHECK(str__new(src->mctx, dest _STR_MEM_FLARG_PASS));\n\tCHECK(str_copy(*dest, src));\n\n\treturn ISC_R_SUCCESS;\n\ncleanup:\n\treturn result;\n}", "path": "src\\str.c", "repo_name": "mnagy/bind-dyndb-ldap", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 208}
{"docstring": "/*\n * Wait on semaphore. This operation will try to acquire a lock on the\n * semaphore. If the semaphore is already acquired as many times at it allows,\n * the function will block until someone releases the lock.\n */\n", "func_signal": "void\nsemaphore_wait(semaphore_t *sem)", "code": "{\n\tREQUIRE(sem != NULL);\n\n\tLOCK(&sem->mutex);\n\n\tsem->value--;\n\tif (sem->value < 0)\n\t\tWAIT(&sem->cond, &sem->mutex);\n\n\tUNLOCK(&sem->mutex);\n}", "path": "src\\semaphore.c", "repo_name": "mnagy/bind-dyndb-ldap", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 208}
{"docstring": "/*\n * Concatenate char *src to string dest.\n * TODO: make str_cat_char() simply use str_cat_char_len()\n */\n", "func_signal": "isc_result_t\nstr_cat_char(ld_string_t *dest, const char *src)", "code": "{\n\tisc_result_t result;\n\tchar *from;\n\tsize_t dest_size;\n\tsize_t src_size;\n\n\tREQUIRE(dest != NULL);\n\tIGNORE_R(src == NULL);\n\n\tdest_size = str_len_internal(dest);\n\tsrc_size = strlen(src);\n\n\tIGNORE_R(src_size == 0);\n\n\tCHECK(str_alloc(dest, dest_size + src_size));\n\tfrom = dest->data + dest_size;\n\tmemcpy(from, src, src_size + 1);\n\n\treturn ISC_R_SUCCESS;\n\ncleanup:\n\treturn result;\n}", "path": "src\\str.c", "repo_name": "mnagy/bind-dyndb-ldap", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 208}
{"docstring": "/*\n * Remove duplicates between rdlists. If rm_from1 == true then remove rdata\n * from the first rdatalist. same rdata are removed from rdlist1 or 2 and are\n * returned in diff.\n */\n", "func_signal": "static void\nrdatalist_removedups(dns_rdatalist_t *rdlist1, dns_rdatalist_t *rdlist2,\n\t\t     isc_boolean_t rm_from1,\n\t\t     dns_rdatalist_t *diff)", "code": "{\n\tdns_rdata_t *rdata1, *rdata2;\n\n\trdata1 = HEAD(rdlist1->rdata);\n\twhile (rdata1 != NULL) {\n\t\trdata2 = HEAD(rdlist2->rdata);\n\t\twhile (rdata2 != NULL) {\n\t\t\tif (dns_rdata_compare(rdata1, rdata2) != 0) {\n\t\t\t\trdata2 = NEXT(rdata2, link);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* same rdata has been found */\n\t\t\tif (rm_from1) {\n\t\t\t\tISC_LIST_UNLINK(rdlist1->rdata, rdata1, link);\n\t\t\t\tAPPEND(diff->rdata, rdata1, link);\n\t\t\t} else {\n\t\t\t\tISC_LIST_UNLINK(rdlist2->rdata, rdata2, link);\n\t\t\t\tAPPEND(diff->rdata, rdata2, link);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\trdata1 = NEXT(rdata1, link);\n\t}\n}", "path": "src\\ldap_driver.c", "repo_name": "mnagy/bind-dyndb-ldap", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 208}
{"docstring": "/*\n * TODO: Review.\n */\n", "func_signal": "isc_result_t\nstr_new_split(isc_mem_t *mctx, ld_split_t **splitp)", "code": "{\n\tisc_result_t result;\n\tld_split_t *split;\n\n\tREQUIRE(splitp != NULL && *splitp == NULL);\n\n\tCHECKED_MEM_GET_PTR(mctx, split);\n\tZERO_PTR(split);\n\tisc_mem_attach(mctx, &split->mctx);\n\n\t*splitp = split;\n\treturn ISC_R_SUCCESS;\n\ncleanup:\n\treturn result;\n}", "path": "src\\str.c", "repo_name": "mnagy/bind-dyndb-ldap", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 208}
{"docstring": "/*\n * Copy string from src to dest.\n */\n", "func_signal": "isc_result_t\nstr_copy(ld_string_t *dest, const ld_string_t *src)", "code": "{\n\tisc_result_t result;\n\tsize_t len;\n\n\tREQUIRE(dest != NULL);\n\tREQUIRE(src != NULL);\n\tIGNORE_R(src->data == NULL);\n\n\tlen = str_len_internal(src);\n\tCHECK(str_alloc(dest, len));\n\tmemcpy(dest->data, src->data, len + 1);\n\n\treturn ISC_R_SUCCESS;\n\ncleanup:\n\treturn result;\n}", "path": "src\\str.c", "repo_name": "mnagy/bind-dyndb-ldap", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 208}
{"docstring": "/*\n * Clone rdlist and convert it into rdataset.\n */\n", "func_signal": "static isc_result_t\nclone_rdatalist_to_rdataset(isc_mem_t *mctx, dns_rdatalist_t *rdlist,\n\t\t\t    dns_rdataset_t *rdataset)", "code": "{\n\tisc_result_t result;\n\tdns_rdatalist_t *new_rdlist = NULL;\n\n\tREQUIRE(mctx != NULL);\n\n\tCHECK(rdatalist_clone(mctx, rdlist, &new_rdlist));\n\n\tCHECK(dns_rdatalist_tordataset(new_rdlist, rdataset));\n\trdataset->methods = &rdataset_methods;\n\tisc_mem_attach(mctx, (isc_mem_t **)&rdataset->private5);\n\n\treturn result;\n\ncleanup:\n\tif (new_rdlist != NULL) {\n\t\tfree_rdatalist(mctx, rdlist);\n\t\tisc_mem_put(mctx, new_rdlist, sizeof(*new_rdlist));\n\t}\n\n\treturn result;\n}", "path": "src\\ldap_driver.c", "repo_name": "mnagy/bind-dyndb-ldap", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 208}
{"docstring": "/* LIBDNS_VERSION_MAJOR >= 50 */\n", "func_signal": "static dns_stats_t *\ngetrrsetstats(dns_db_t *db)", "code": "{\n\tUNUSED(db);\n\n\treturn NULL;\n}", "path": "src\\ldap_driver.c", "repo_name": "mnagy/bind-dyndb-ldap", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 208}
{"docstring": "/*\n * Destroy string, i.e. also free the ld_string_t struct.\n */\n", "func_signal": "void\nstr__destroy(ld_string_t **str _STR_MEM_FLARG)", "code": "{\n\tIGNORE(str == NULL || *str == NULL);\n\n\tif ((*str)->allocated) {\n#if ISC_MEM_TRACKLINES\n\t\tisc__mem_put((*str)->mctx, (*str)->data,\n\t\t\t     (*str)->allocated * sizeof(char), file, line);\n#else\n\t\tisc_mem_put((*str)->mctx, (*str)->data,\n\t\t\t    (*str)->allocated * sizeof(char));\n#endif\n\t}\n\n#if ISC_MEM_TRACKLINES\n\tisc__mem_putanddetach(&(*str)->mctx, *str, sizeof(ld_string_t),\n\t\t\t      file, line);\n#else\n\tisc_mem_putanddetach(&(*str)->mctx, *str, sizeof(ld_string_t));\n#endif\n\n\t*str = NULL;\n}", "path": "src\\str.c", "repo_name": "mnagy/bind-dyndb-ldap", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 208}
{"docstring": "/* ldapdbnode_t functions */\n", "func_signal": "static isc_result_t\nldapdbnode_create(isc_mem_t *mctx, dns_name_t *owner, ldapdbnode_t **nodep)", "code": "{\n\tldapdbnode_t *node = NULL;\n\tisc_result_t result;\n\n\tREQUIRE(nodep != NULL && *nodep == NULL);\n\n\tCHECKED_MEM_GET_PTR(mctx, node);\n\tCHECK(isc_refcount_init(&node->refs, 1));\n\n\tdns_name_init(&node->owner, NULL);\n\tCHECK(dns_name_dup(owner, mctx, &node->owner));\n\n\tnode->magic = LDAPDBNODE_MAGIC;\n\n\tISC_LIST_INIT(node->rdatalist);\n\n\t*nodep = node;\n\n\treturn ISC_R_SUCCESS;\n\ncleanup:\n\tSAFE_MEM_PUT_PTR(mctx, node);\n\n\treturn result;\n}", "path": "src\\ldap_driver.c", "repo_name": "mnagy/bind-dyndb-ldap", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 208}
{"docstring": "/*\n * Return 1 if the argument names are equal. The argv_argument also needs to\n * contain an additional space at the end.\n */\n", "func_signal": "static int\nargs_are_equal(const char *setting_argument, const char *argv_argument)", "code": "{\n\tif (setting_argument == NULL || argv_argument == NULL)\n\t\treturn 0;\n\n\tfor (;;) {\n\t\tif (*setting_argument == '\\0')\n\t\t\tbreak;\n\t\tif (*argv_argument == '\\0')\n\t\t\treturn 0;\n\t\tif (*setting_argument != *argv_argument)\n\t\t\treturn 0;\n\t\tsetting_argument++;\n\t\targv_argument++;\n\t}\n\n\t/* Now make sure we also found a space at the end of argv_argument. */\n\tif (!isspace(*argv_argument) && *argv_argument != '\\0')\n\t\treturn 0;\n\n\treturn 1;\n}", "path": "src\\settings.c", "repo_name": "mnagy/bind-dyndb-ldap", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 208}
{"docstring": "/* XXX add support for DNAME redirection */\n", "func_signal": "static isc_result_t\nfind(dns_db_t *db, dns_name_t *name, dns_dbversion_t *version,\n     dns_rdatatype_t type, unsigned int options, isc_stdtime_t now,\n     dns_dbnode_t **nodep, dns_name_t *foundname, dns_rdataset_t *rdataset,\n     dns_rdataset_t *sigrdataset)", "code": "{\n\tldapdb_t *ldapdb = (ldapdb_t *) db;\n\tisc_result_t result;\n\tldapdbnode_t *node = NULL;\n\tdns_rdatalist_t *rdlist = NULL;\n\tisc_boolean_t is_cname = ISC_FALSE;\n\tldapdb_rdatalist_t rdatalist;\n\n\tUNUSED(now);\n\tUNUSED(options);\n\tUNUSED(sigrdataset);\n\n\tREQUIRE(VALID_LDAPDB(ldapdb));\n\tREQUIRE(!(node != NULL && type == dns_rdatatype_any));\n\t//REQUIRE(!(node == NULL && rdataset != NULL));\n\n\tif (version != NULL) {\n\t\tREQUIRE(version == ldapdb_version);\n\t}\n\n\tresult = cached_ldap_rdatalist_get(ldapdb->common.mctx,\n\t\t\t\t\t   ldapdb->ldap_cache, ldapdb->ldap_db,\n\t\t\t\t\t   name, &ldapdb->common.origin,\n\t\t\t\t\t   &rdatalist);\n\tINSIST(result != DNS_R_PARTIALMATCH); /* XXX Not yet implemented */\n\n\tif (result != ISC_R_SUCCESS && result != DNS_R_PARTIALMATCH)\n\t\treturn (result == ISC_R_NOTFOUND) ? DNS_R_NXDOMAIN : result;\n\n\tresult = ldapdb_rdatalist_findrdatatype(&rdatalist, type, &rdlist);\n\tif (result != ISC_R_SUCCESS) {\n\t\t/* No exact rdtype match. Check CNAME */\n\n\t\trdlist = HEAD(rdatalist);\n\t\twhile (rdlist != NULL && rdlist->type != dns_rdatatype_cname)\n\t\t\trdlist = NEXT(rdlist, link);\n\n\t\t/* CNAME was found */\n\t\tif (rdlist != NULL) {\n\t\t\tresult = ISC_R_SUCCESS;\n\t\t\tis_cname = ISC_TRUE;\n\t\t}\n\t}\n\n\tif (result != ISC_R_SUCCESS) {\n\t\tresult = DNS_R_NXRRSET;\n\t\tgoto cleanup;\n\t}\n\n\t/* XXX currently we implemented only exact authoritative matches */\n\tCHECK(dns_name_copy(name, foundname, NULL));\n\n\tif (rdataset != NULL && type != dns_rdatatype_any) {\n\t\t/* dns_rdatalist_tordataset returns success only */\n\t\tCHECK(clone_rdatalist_to_rdataset(ldapdb->common.mctx, rdlist,\n\t\t\t\t\t\t  rdataset));\n\t}\n\n\tif (nodep != NULL) {\n\t\tCHECK(ldapdbnode_create(ldapdb->common.mctx, name, &node));\n\t\tmemcpy(&node->rdatalist, &rdatalist, sizeof(rdatalist));\n\t\t*nodep = node;\n\t} else {\n\t\tldapdb_rdatalist_destroy(ldapdb->common.mctx, &rdatalist);\n\t}\n\n\treturn (is_cname == ISC_TRUE) ? DNS_R_CNAME : ISC_R_SUCCESS;\n\ncleanup:\n\tldapdb_rdatalist_destroy(ldapdb->common.mctx, &rdatalist);\n\treturn result;\n}", "path": "src\\ldap_driver.c", "repo_name": "mnagy/bind-dyndb-ldap", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 208}
{"docstring": "/*\n * Destroy a semaphore.\n *\n * sem - semaphore to be destroyed.\n */\n", "func_signal": "void\nsemaphore_destroy(semaphore_t *sem)", "code": "{\n\tif (sem == NULL)\n\t\treturn;\n\n\tRUNTIME_CHECK(isc_mutex_destroy(&sem->mutex) == ISC_R_SUCCESS);\n\tRUNTIME_CHECK(isc_condition_destroy(&sem->cond) == ISC_R_SUCCESS);\n}", "path": "src\\semaphore.c", "repo_name": "mnagy/bind-dyndb-ldap", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 208}
{"docstring": "/*\n * Allocate a new string.\n */\n", "func_signal": "isc_result_t\nstr__new(isc_mem_t *mctx, ld_string_t **new_str _STR_MEM_FLARG)", "code": "{\n\tld_string_t *str;\n\n\tREQUIRE(mctx != NULL);\n\tREQUIRE(new_str != NULL && *new_str == NULL);\n\n#if ISC_MEM_TRACKLINES\n\tstr = isc__mem_get(mctx, sizeof(ld_string_t), file, line);\n#else\n\tstr = isc_mem_get(mctx, sizeof(ld_string_t));\n#endif\n\tif (str == NULL)\n\t\treturn ISC_R_NOMEMORY;\n\n\tstr->data = NULL;\n\tstr->allocated = 0;\n\tstr->mctx = NULL;\n\n\tisc_mem_attach(mctx, &str->mctx);\n\n#if ISC_MEM_TRACKLINES\n\tstr->file = file;\n\tstr->line = line;\n#endif\n\n\t*new_str = str;\n\n\treturn ISC_R_SUCCESS;\n}", "path": "src\\str.c", "repo_name": "mnagy/bind-dyndb-ldap", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 208}
{"docstring": "/*\n * Release the semaphore. This will make sure that another thread (probably\n * already waiting) will be able to acquire the semaphore.\n */\n", "func_signal": "void\nsemaphore_signal(semaphore_t *sem)", "code": "{\n\tREQUIRE(sem != NULL);\n\n\tLOCK(&sem->mutex);\n\n\tsem->value++;\n\tif (sem->value >= 0)\n\t\tSIGNAL(&sem->cond);\n\n\tUNLOCK(&sem->mutex);\n}", "path": "src\\semaphore.c", "repo_name": "mnagy/bind-dyndb-ldap", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 208}
{"docstring": "/*\n * Make sure we have enough space for at least len + 1 bytes.\n * This function is private.\n */\n", "func_signal": "static isc_result_t\nstr_alloc(ld_string_t *str, size_t len)", "code": "{\n\tsize_t new_size;\n\tchar *new_buffer;\n\n\tREQUIRE(str != NULL);\n\tREQUIRE(str->mctx != NULL);\n\tIGNORE_R(str->allocated > len);\n\n\tlen++;\t/* Account for the last '\\0'. */\n\tnew_size = ISC_MAX(str->allocated, ALLOC_BASE_SIZE);\n\twhile (new_size <= len)\n\t\tnew_size *= 2;\n\n\tnew_size *= sizeof (char);\n#if ISC_MEM_TRACKLINES\n\tnew_buffer = isc__mem_get(str->mctx, new_size, str->file, str->line);\n#else\n\tnew_buffer = isc_mem_get(str->mctx, new_size);\n#endif\n\n\tif (new_buffer == NULL)\n\t\treturn ISC_R_NOMEMORY;\n\n\tif (str->data != NULL) {\n\t\tmemcpy(new_buffer, str->data, len);\n\t\tnew_buffer[len] = '\\0';\n\t\tisc_mem_put(str->mctx, str->data, str->allocated);\n\t} else {\n\t\tnew_buffer[0] = '\\0';\n\t}\n\n\tstr->data = new_buffer;\n\tstr->allocated = new_size;\n\n\treturn ISC_R_SUCCESS;\n}", "path": "src\\str.c", "repo_name": "mnagy/bind-dyndb-ldap", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 208}
{"docstring": "// IN/OUT: tm, flag\n", "func_signal": "extern void\nrtc_get_time_alarm(struct rtc_time* tm, u32_t* flag)", "code": "{\n\tu32_t temp = readw(SOCLE_RTC_TALRM);\n\trtc_u32_to_time(tm, temp);\n\t*flag = temp & (SOCLE_RTC_TALRM_CSOS\t|\n\t\t\tSOCLE_RTC_TALRM_CS\t|\n\t\t\tSOCLE_RTC_TALRM_CM\t|\n\t\t\tSOCLE_RTC_TALRM_CH\t|\n\t\t\tSOCLE_RTC_TALRM_CDOW);\n}", "path": "src\\RTC\\rtc-ctrl.c", "repo_name": "acctomhse/sq8000", "stars": 1, "license": "None", "language": "c", "size": 626}
{"docstring": "/*******************************************************************************\n*\n* sMacIntInit - Initial Interrupt\n*\n* RETURNS:\n*/\n", "func_signal": "void\tsMacIntInit\n\t(\n\tDRV_CTRL *\tpDrvCtrl\n\t)", "code": "{\n#ifdef\tSMAC_INTCOUNTER_DEBUG\n\tmemset((char *)(&(pDrvCtrl->int_counter)), 0, sizeof(INT_COUNTER));\n#endif\n#ifdef\tMAC_RX_POLLSCHEME\n\tpDrvCtrl->rxScheduled = FALSE;\n#endif\n    pDrvCtrl->txScheduled = FALSE; \n}", "path": "src\\MAC\\if_socle.c", "repo_name": "acctomhse/sq8000", "stars": 1, "license": "None", "language": "c", "size": 626}
{"docstring": "// process Intr_IN interrupt\n", "func_signal": "void process_intr_req(int ch)", "code": "{\n\tu32_t status = readw( UDC_TXSTAT(ChannelSet[ch].uIntr_IN) );\n\n\t// transmit error\n\tif ( status & TxERR ) {\n\t\tChannelSet[ch].bIntrDMAOnGoing = false;\n\n\t\tstatus = readw( UDC_TXBUF(ChannelSet[ch].uIntr_IN) );\n\n\t\tif ( status & TxURF ) {\n\t\t\t// uncheck TxNAK, TxSTALL\n\t\t\twritew( readw( UDC_TXCON(ChannelSet[ch].uIntr_IN) ) & ~( TxSTALL | TxNAK ),\n\t\t\t        UDC_TXCON(ChannelSet[ch].uIntr_IN) );\n\t\t}\n\n\t\treturn;\n\t}\n\n\t// transmit complete\n\tif ( status & TxACK ) {\n\t\tChannelSet[ch].uIntrINCount++;\n\t\tChannelSet[ch].bIntrDMAOnGoing = false;\n\n\t\treturn;\n\t}\n\n\treturn;\n}", "path": "src\\UDC\\1usbctrl.c", "repo_name": "acctomhse/sq8000", "stars": 1, "license": "None", "language": "c", "size": 626}
{"docstring": "// rtc_date_to_u32() : given RtcTime struct , fill back the data\n// IN : given tm\n// return u32 time\n", "func_signal": "static u32_t\nrtc_date_to_u32(const struct rtc_date* dt)", "code": "{\n\tu32_t\ttemp = 0;\n\n\ttemp |= (dt->day      << SOCLE_RTC_DATE_D );\n\ttemp |= (dt->ten_day  << SOCLE_RTC_DATE_TD);\n\ttemp |= (dt->mth      << SOCLE_RTC_DATE_M );\n\ttemp |= (dt->ten_mth  << SOCLE_RTC_DATE_TM);\n\ttemp |= (dt->yr       << SOCLE_RTC_DATE_Y );\n\ttemp |= (dt->ten_yr   << SOCLE_RTC_DATE_TY);\n\ttemp |= (dt->cent     << SOCLE_RTC_DATE_C );\n\ttemp |= (dt->ten_cent << SOCLE_RTC_DATE_TC);\n\n\treturn temp;\n}", "path": "src\\RTC\\rtc-ctrl.c", "repo_name": "acctomhse/sq8000", "stars": 1, "license": "None", "language": "c", "size": 626}
{"docstring": "/* SW ISSUE */\n/*******************************************************************************\n*\n* sMacMiiCheckHighRate - Get Most High Rate Setting of PHY\n*/\n", "func_signal": "USHORT sMacMiiCheckHighRate\n\t(\n    USHORT\tablitites\n    )", "code": "{\n\tif(ablitites & MII_PHY_ANA_T4AM)\t\tablitites = ablitites & MII_PHY_ANA_T4AM;\n\telse if(ablitites & MII_PHY_ANA_100F)\tablitites = ablitites & MII_PHY_ANA_100F;\n\telse if(ablitites & MII_PHY_ANA_100H)\tablitites = ablitites & MII_PHY_ANA_100H;\n\telse if(ablitites & MII_PHY_ANA_10F)\tablitites = ablitites & MII_PHY_ANA_10F;\n\telse if(ablitites & MII_PHY_ANA_10H)\tablitites = ablitites & MII_PHY_ANA_10H;\n\treturn(ablitites);\n}", "path": "src\\MAC\\if_socle.c", "repo_name": "acctomhse/sq8000", "stars": 1, "license": "None", "language": "c", "size": 626}
{"docstring": "// IN: dt,flag\n", "func_signal": "extern void\nrtc_set_date_alarm(const struct rtc_date* dt, const u32_t flag)", "code": "{\n\tu32_t temp = rtc_date_to_u32(dt);\n\twritew(temp | flag, SOCLE_RTC_DALRM);\n}", "path": "src\\RTC\\rtc-ctrl.c", "repo_name": "acctomhse/sq8000", "stars": 1, "license": "None", "language": "c", "size": 626}
{"docstring": "// IN/OUT: tm\n", "func_signal": "extern void\nrtc_get_time(struct rtc_time* tm)", "code": "{\n\tu32_t temp = readw(SOCLE_RTC_TIME);\n\n\treturn rtc_u32_to_time(tm, temp);\n}", "path": "src\\RTC\\rtc-ctrl.c", "repo_name": "acctomhse/sq8000", "stars": 1, "license": "None", "language": "c", "size": 626}
{"docstring": "// IN: tm\n", "func_signal": "extern void\nrtc_set_time(const struct rtc_time* tm)", "code": "{\n\tu32_t temp = rtc_time_to_u32(tm);\n\twritew(temp, SOCLE_RTC_TIME);\n}", "path": "src\\RTC\\rtc-ctrl.c", "repo_name": "acctomhse/sq8000", "stars": 1, "license": "None", "language": "c", "size": 626}
{"docstring": "// called on first h/w init or reset\n", "func_signal": "void initUDCController()", "code": "{\n#ifdef\tUSB11\n \t// set UDC is Full-Speed mode, default is High-Speed mode\n \twritew( readw(UDC_DEVCTL)|DEV_FULL_SPD, UDC_DEVCTL );\n#endif\n\n\t// init control endpoint\n\twritew( EN_SETUP_INTR | EN_IN0_INTR | EN_OUT0_INTR | EN_BOUTALL_INTR |\n\t\t\tEN_BINALL_INTR | EN_IINALL_INTR | EN_USBRST_INTR | EN_RSUME_INTR |\n\t\t\tEN_SUSP_INTR, UDC_ENINT );\n\n\t// INT 0,1,2 enable, level-trigger(default), high-active\n//\twritew( INT0EN | INT1EN | INT2EN | INT0HIGH_ACT | INT1HIGH_ACT | INT2HIGH_ACT , UDC_INTCON );\n\twritew( UDC_INTEN | UDC_INTHIGH_ACT, UDC_INTCON);\n\n\twritew( TxACKINTEN | TxNAK  , UDC_TX0CON );\n\twritew( RxACKINTEN | RxNAK |  RxEPEN, UDC_RX0CON );\n\n\t// UDC Channel Set 0\n\tChannelSet[0].uBulk_OUT = UDC_RX1STAT;\t\t\t// Bulk_OUT control register\n\tChannelSet[0].uBulk_IN  = UDC_TX2STAT;\t\t\t// Bulk_IN control register\n\tChannelSet[0].uIntr_IN  = UDC_TX3STAT;\t\t\t// Intr_IN control register\n//#if END_POINTER_NUM == 16\n\t// UDC Channel Set 1\n\tChannelSet[1].uBulk_OUT = UDC_RX4STAT;\t\t\t// Bulk_OUT control register\n\tChannelSet[1].uBulk_IN  = UDC_TX5STAT;\t\t\t// Bulk_IN control register\n\tChannelSet[1].uIntr_IN  = UDC_TX6STAT;\t\t\t// Intr_IN control register\n\t// UDC Channel Set 2\n\tChannelSet[2].uBulk_OUT = UDC_RX7STAT;\t\t\t// Bulk_OUT control register\n\tChannelSet[2].uBulk_IN  = UDC_TX8STAT;\t\t\t// Bulk_IN control register\n\tChannelSet[2].uIntr_IN  = UDC_TX9STAT;\t\t\t// Intr_IN control register\n\t// UDC Channel Set 3\n\tChannelSet[3].uBulk_OUT = UDC_RX10STAT;\t\t\t// Bulk_OUT control register\n\tChannelSet[3].uBulk_IN  = UDC_TX11STAT;\t\t\t// Bulk_IN control register\n\tChannelSet[3].uIntr_IN  = UDC_TX12STAT;\t\t\t// Intr_IN control register\n\t// UDC Channel Set 4\n\tChannelSet[4].uBulk_OUT = UDC_RX13STAT;\t\t\t// Bulk_OUT control register\n\tChannelSet[4].uBulk_IN  = UDC_TX14STAT;\t\t\t// Bulk_IN control register\n\tChannelSet[4].uIntr_IN  = UDC_TX15STAT;\t\t\t// Intr_IN control register\n//#endif\t/* END_POINTER_NUM */\n\n\twritew( (0x1 << 8) | RxACKINTEN  | RxEPEN, UDC_RXCON(ChannelSet[0].uBulk_OUT));\n\twritew( (0x2 << 8) | TxDMADN_EN  | TxEPEN, UDC_TXCON(ChannelSet[0].uBulk_IN));\n\twritew( (0x3 << 8) | TxACKINTEN  | TxVOIDINTEN  | TxERRINTEN  | TxEPEN,  UDC_TXCON(ChannelSet[0].uIntr_IN));\n                       \n//#if END_POINTER_NUM == 16\n\twritew( (0x4 << 8) | RxACKINTEN  | RxEPEN, UDC_RXCON(ChannelSet[1].uBulk_OUT));\n\twritew( (0x5 << 8) | TxDMADN_EN  | TxEPEN, UDC_TXCON(ChannelSet[1].uBulk_IN));\n\twritew( (0x6 << 8) | TxACKINTEN  | TxVOIDINTEN  | TxERRINTEN  | TxEPEN,  UDC_TXCON(ChannelSet[1].uIntr_IN));\n                       \n\twritew( (0x7 << 8) | RxACKINTEN  | RxEPEN, UDC_RXCON(ChannelSet[2].uBulk_OUT));\n\twritew( (0x8 << 8) | TxDMADN_EN  | TxEPEN, UDC_TXCON(ChannelSet[2].uBulk_IN));\n\twritew( (0x9 << 8) | TxACKINTEN  | TxVOIDINTEN  | TxERRINTEN  | TxEPEN,  UDC_TXCON(ChannelSet[2].uIntr_IN));\n                       \n\twritew( (0xa << 8) | RxACKINTEN  | RxEPEN, UDC_RXCON(ChannelSet[3].uBulk_OUT));\n\twritew( (0xb << 8) | TxDMADN_EN  | TxEPEN, UDC_TXCON(ChannelSet[3].uBulk_IN));\n\twritew( (0xc << 8) | TxACKINTEN  | TxVOIDINTEN  | TxERRINTEN  | TxEPEN,  UDC_TXCON(ChannelSet[3].uIntr_IN));\n                       \n\twritew( (0xd << 8) | RxACKINTEN  | RxEPEN, UDC_RXCON(ChannelSet[4].uBulk_OUT));\n\twritew( (0xe << 8) | TxDMADN_EN  | TxEPEN, UDC_TXCON(ChannelSet[4].uBulk_IN));\n\twritew( (0xf << 8) | TxACKINTEN  | TxVOIDINTEN  | TxERRINTEN  | TxEPEN,  UDC_TXCON(ChannelSet[4].uIntr_IN));\n//#endif\t/* END_POINTER_NUM */\n    \n    //writew( readw(UDC_DEVCTL)|CSR_DONE, UDC_DEVCTL );\n}", "path": "src\\UDC\\1usbctrl.c", "repo_name": "acctomhse/sq8000", "stars": 1, "license": "None", "language": "c", "size": 626}
{"docstring": "// IN: tm,flag\n", "func_signal": "extern void\nrtc_set_time_alarm(const struct rtc_time* tm, const u32_t flag)", "code": "{\n\tu32_t temp = rtc_time_to_u32(tm);\n\twritew(temp | flag, SOCLE_RTC_TALRM);\n}", "path": "src\\RTC\\rtc-ctrl.c", "repo_name": "acctomhse/sq8000", "stars": 1, "license": "None", "language": "c", "size": 626}
{"docstring": "// IN/OUT: dt\n", "func_signal": "extern void\nrtc_get_date(struct rtc_date* dt)", "code": "{\n\tu32_t temp = readw(SOCLE_RTC_DATE);\n\trtc_u32_to_date(dt, temp);\n}", "path": "src\\RTC\\rtc-ctrl.c", "repo_name": "acctomhse/sq8000", "stars": 1, "license": "None", "language": "c", "size": 626}
{"docstring": "/*******************************************************************************\n*\n* sMacTxSchedule - Check enqueued transmit buffers\n*\n*/\n", "func_signal": "void sMacTxSchedule\n\t(\n    DRV_CTRL *\tpDrvCtrl\n\t)", "code": "{\n\t#ifdef\tSMAC_ERRORDEBUG\n    pDrvCtrl->errStats.txFlushCalled++;\n\t#endif\t/* SMAC_ERRORDEBUG */\n\n    sMacTxRingClean (pDrvCtrl);\n\n    if(SMAC_TD_INDEX_NEXT(pDrvCtrl) != pDrvCtrl->txDiIndex)\n    {\n    \t//refill buffer\n    \t//Call StartOutput\n    }\n\n    pDrvCtrl->txScheduled = FALSE;\n    if(pDrvCtrl->tx_merge_number)\n    {\n    \tsMAC_INT_ENABLE (pDrvCtrl->devAdrs, (CSR7_TI ));\n    }\n    else\n    {\n    \tsMAC_INT_ENABLE (pDrvCtrl->devAdrs, (CSR7_TI | CSR7_TU));\n    }\t\n}", "path": "src\\MAC\\if_socle.c", "repo_name": "acctomhse/sq8000", "stars": 1, "license": "None", "language": "c", "size": 626}
{"docstring": "// rtc_u32_to_time(): given u32 time, fill the rtc_time struct\n// IN : given temp\n// OUT : result time struct\n", "func_signal": "static void\nrtc_u32_to_time(struct rtc_time* tm, const u32_t temp)", "code": "{\n\ttm->sos      = (temp >> SOCLE_RTC_TIME_SOS) & BIT_MASK(4);\n\ttm->sec      = (temp >> SOCLE_RTC_TIME_S)   & BIT_MASK(4);\n\ttm->ten_sec  = (temp >> SOCLE_RTC_TIME_TS)  & BIT_MASK(3);\n\ttm->min      = (temp >> SOCLE_RTC_TIME_M)   & BIT_MASK(4);\n\ttm->ten_min  = (temp >> SOCLE_RTC_TIME_TM)  & BIT_MASK(3);\n\ttm->hr       = (temp >> SOCLE_RTC_TIME_H)   & BIT_MASK(4);\n\ttm->ten_hr   = (temp >> SOCLE_RTC_TIME_TH)  & BIT_MASK(2);\n\ttm->dow      = (temp >> SOCLE_RTC_TIME_DOW) & BIT_MASK(3);\n}", "path": "src\\RTC\\rtc-ctrl.c", "repo_name": "acctomhse/sq8000", "stars": 1, "license": "None", "language": "c", "size": 626}
{"docstring": "/*******************************************************************************\n*\n* sMacTxRingClean - cleans up the transmit ring\n*\n* This routine is called at task level in the context to collect statistics\n* , and mark \"free\" all descriptors consumed by the device.\n*/\n", "func_signal": "void sMacTxRingClean\n    (\n    DRV_CTRL *pDrvCtrl\n    )", "code": "{\n    SMAC_TDE *\ttmd;            /* pointer to Xmit ring descriptor */\n\tULONG\t\ttdesc0;\n\n    while (pDrvCtrl->txDiIndex != pDrvCtrl->txIndex)\n    {\n    \t/* disposal has not caught up */\n        SMAC_GET_DTDE(tmd, pDrvCtrl);\n\n\t\ttdesc0 = sMAC_READ_DESC(&(tmd->tDesc0));\n\n        /* if the buffer is still owned by device, don't touch it */\n        if (tdesc0 & (TDESC0_OWN))\n            break;\n\n        /* now bump the tmd disposal index pointer around the ring */\n        pDrvCtrl->txDiIndex = SMAC_TD_DINDEX_NEXT(pDrvCtrl);\n        pDrvCtrl->txCount--;\n\t\t\n\t\t//Only for last Tx packet need check error\n\t\tif( tmd->tDesc1 & DESSWAP(TDESC1_LS))\n\t\t{\n\t\t\t#ifdef\tSMAC_ERRORDEBUG\n        \tif (tdesc0 & TDESC0_LO)\t\n        \t\t{pDrvCtrl->errStats.txLostCarrier++;\t}\n        \tif (tdesc0 & TDESC0_NC)\t\n        \t\t{pDrvCtrl->errStats.txNoCarrier++;\t\t}\n        \tif (tdesc0 & TDESC0_UF)\t\n        \t\t{pDrvCtrl->errStats.txUnderflow++;\t\t}\n        \telse if (tdesc0 & TDESC0_LC)\n        \t\t\t\t\t\t\t{pDrvCtrl->errStats.txLateCollision++;\t}\n        \tif (tdesc0 & TDESC0_EC)\t\n        \t\t{pDrvCtrl->errStats.txExsCollision++;\tpDrvCtrl->errStats.txCollisonCount += 16;\t}\n        \telse if (tdesc0 & TDESC0_CC_MSK)\n        \t\t\t\t\t\t\t{pDrvCtrl->errStats.txCollisonCount += TDESC0_CC_GET(tdesc0);\t}\n        \tif (tdesc0 & TDESC0_DE)\t\n        \t\t{pDrvCtrl->errStats.txDeferred++;\t\t}\n\t\t\t#endif\t/* SMAC_ERRORDEBUG */\n\n        \t/*\n        \t * TDESC0_ES is an \"OR\" of LC, NC, UF, EC LO\n        \t * here for error conditions.\n        \t */\n        \tif (tdesc0 & (TDESC0_ES))\n\t    \t{\n\t    \t\tpDrvCtrl->errStats.txErrorSum++;\n        \t    /*\n\t    \t \t * If error was due to excess collisions, bump the collision\n        \t     * counter.\n        \t     */\n\n        \t    /*\n\t    \t \t * Restart chip on fatal errors.\n        \t     * The following code handles the situation where the transmitter\n        \t     * shuts down due to an underflow error.  This is a situation that\n        \t     * will occur if the DMA cannot keep up with the transmitter.\n        \t     * It will occur if the device is being held off from DMA access\n        \t     * for too long or due to significant memory latency.  DRAM\n        \t     * refresh or slow memory could influence this.  Many\n        \t     * implementation use a dedicated device buffer.  This can be\n        \t     * static RAM to eliminate refresh conflicts; or dual-port RAM\n        \t     * so that the device can have free run of this memory during its\n        \t     * DMA transfers.\n        \t     */\n        \t}\n        }\n        tmd->tDesc0 = 0;\t/* clear all error & stat stuff */\n    }\n}", "path": "src\\MAC\\if_socle.c", "repo_name": "acctomhse/sq8000", "stars": 1, "license": "None", "language": "c", "size": 626}
{"docstring": "// IN/OUT: dt, flag\n", "func_signal": "extern void\nrtc_get_date_alarm(struct rtc_date* dt, u32_t* flag)", "code": "{\n\tu32_t temp = readw(SOCLE_RTC_DALRM);\n\trtc_u32_to_date(dt, temp);\n\t*flag = temp & (SOCLE_RTC_DALRM_CD\t|\n\t\t\tSOCLE_RTC_DALRM_CM\t|\n\t\t\tSOCLE_RTC_DALRM_CY\t|\n\t\t\tSOCLE_RTC_DALRM_CC);\n}", "path": "src\\RTC\\rtc-ctrl.c", "repo_name": "acctomhse/sq8000", "stars": 1, "license": "None", "language": "c", "size": 626}
{"docstring": "// rtc_u32_to_date() : given u32 date, fill the rtc_date struct\n// IN : given temp\n// OUT : result date struct\n", "func_signal": "static void\nrtc_u32_to_date(struct rtc_date* dt, const data_t temp)", "code": "{\n\tdt->day      = (temp >> SOCLE_RTC_DATE_D)   & BIT_MASK(4);\n\tdt->ten_day  = (temp >> SOCLE_RTC_DATE_TD)  & BIT_MASK(2);\n\tdt->mth      = (temp >> SOCLE_RTC_DATE_M)   & BIT_MASK(4);\n\tdt->ten_mth  = (temp >> SOCLE_RTC_DATE_TM)  & BIT_MASK(1);\n\tdt->yr       = (temp >> SOCLE_RTC_DATE_Y)   & BIT_MASK(4);\n\tdt->ten_yr   = (temp >> SOCLE_RTC_DATE_TY)  & BIT_MASK(4);\n\tdt->cent     = (temp >> SOCLE_RTC_DATE_C)   & BIT_MASK(4);\n\tdt->ten_cent = (temp >> SOCLE_RTC_DATE_TC)  & BIT_MASK(4);\n}", "path": "src\\RTC\\rtc-ctrl.c", "repo_name": "acctomhse/sq8000", "stars": 1, "license": "None", "language": "c", "size": 626}
{"docstring": "// tx0 handler\n", "func_signal": "void process_in0()", "code": "{\n    readw( UDC_TX0STAT ); //added by Ivan Chiang 040805\n\tif ( uControlStage == DATA_STAGE ) {\n\t\t// data stage\n\n        //;//printf(\"tx0 handler uControlDataSize = %x\\n\",uControlDataSize); \n\t\tif ( uControlDataSize > 0 )\n\t\t\tuNeedDoProcCtrlBlockNum++;\n\t\telse {\n\t\t\t// open OUT gate\n\t\t\twritew( readw( UDC_RX0CON ) & ~RxNAK, UDC_RX0CON );\n\t\t\twritew( virt_to_phy((u32_t)CtrlInBuffer), UDC_DMA0LM_OADDR );\n\t\t\twritew( ENP_DMA_START ,  UDC_DMA0CTLO );\n\t\t\tuControlStage = STATUS_STAGE;\n\t\t}\n\n\t}\n\telse if ( uControlStage == STATUS_STAGE ) {\n\t\t// status stage, close gates\n\n\t\twritew( readw( UDC_TX0CON ) | TxNAK, UDC_TX0CON );\n\t\twritew( readw( UDC_RX0CON ) | RxNAK, UDC_RX0CON );\n\t}\n\n\t//DEBUG_OUT(uControlDataSize);\n\treturn;\n}", "path": "src\\UDC\\1usbctrl.c", "repo_name": "acctomhse/sq8000", "stars": 1, "license": "None", "language": "c", "size": 626}
{"docstring": "// rx0 handler\n", "func_signal": "void process_out0()", "code": "{\n\tint len;\n\n\tif ( uControlStage == STATUS_STAGE ) {\n\t\t// status stage\n\n\t\t// read clear RX0ACK interrupt\n\t\treadw( UDC_RX0STAT );\n\n\t\t// assert both TX0NAK, RX0NAK at status stage\n\t\twritew( readw( UDC_TX0CON ) | TxNAK, UDC_TX0CON );\n\t\twritew( readw( UDC_RX0CON ) | RxNAK, UDC_RX0CON );\n\n\t} else if ( uControlStage == DATA_STAGE ) {\n\t\t// data stage\n\n\t\t// read length from H/W\n\t\tlen = readw( UDC_RX0STAT ) & RxCNT;\n\n\t\t// record received result\n\t\tuControlDataSize -= len;\n\t\t//DEBUG_OUT(uControlDataSize);\n\n\t\t// step next dma block\n\t\tuCurrentCtrlBlockNum = ++uCurrentCtrlBlockNum % MAX_CTRL_NUM;\n\t\twritew( virt_to_phy((u32_t)( CtrlInBuffer + uCurrentCtrlBlockNum * uCurrentCtrlPacketSize)), UDC_DMA0LM_OADDR );\n\t\twritew( ENP_DMA_START ,  UDC_DMA0CTLO );\n/*\n\t\tif ( uControlDataSize <= 0 ) {\n\t\t\t// open IN gate\n\t\t\twritew( readw( UDC_TX0CON ) & ~TX0NAK, UDC_TX0CON );\n\t\t\twritew( 0, UDC_TX0STAT );\n\t\t\twritew( virt_to_phy((u32_t)CtrlInBuffer) , UDC_DMA0LM_IADDR );\n\t\t\twritew( DMA0INSTA , UDC_DMA0CTLI );\n\t   \t\tuControlStage = STATUS_STAGE;\n\t\t}\n*/\n\n\t}\n\n\treturn;\n}", "path": "src\\UDC\\1usbctrl.c", "repo_name": "acctomhse/sq8000", "stars": 1, "license": "None", "language": "c", "size": 626}
{"docstring": "// IN: dt\n", "func_signal": "extern void\nrtc_set_date(const struct rtc_date* dt)", "code": "{\n\tu32_t temp = rtc_date_to_u32(dt);\n\twritew(temp, SOCLE_RTC_DATE);\n}", "path": "src\\RTC\\rtc-ctrl.c", "repo_name": "acctomhse/sq8000", "stars": 1, "license": "None", "language": "c", "size": 626}
{"docstring": "/*******************************************************************************\n*\n* sMacInit - Socle MAC Initial procedure\n*\n* RETURNS: TRUE/FALSE\n*/\n", "func_signal": "int\tsMacInit(\tDRV_CTRL *\tpDrvCtrl\t)", "code": "{\n\tint \tresult;\n\n\t// First we Reset\n\tsMacChipReset(pDrvCtrl);\n\n\t//Initail MII\n\tresult=sMacMiiInit(pDrvCtrl);\n\t//sMacMiiPhyShow(pDrvCtrl);\n\n\t#ifdef MAC_INCLUDE_EEPROM    \n\t\tinitEEP25();\n\t#endif  \n\n  if(result!=TRUE){\n   \treturn(result);\n  }\n\n\t#ifdef MAC_INCLUDE_EEPROM    \n\tpDrvCtrl->eepdevpt = openEEP25( sMAC_CSR(pDrvCtrl->devAdrs,CSR9) \n\t\t\t\t\t\t\t\t  , EEP25040\n\t\t\t\t\t\t\t\t  , CSRSWAP(CSR9_SDO)\n\t\t\t\t\t\t\t\t  , CSRSWAP(CSR9_SDI)\n\t\t\t\t\t\t\t\t  , CSRSWAP(CSR9_SCLK)\n\t\t\t\t\t\t\t\t  , CSRSWAP(CSR9_SCE));\n\t#endif    \n\n    /* SW ISSUE */\n    //After Phy get real speed and duplex we reset the opMode\n  if(pDrvCtrl->MII_Auto_Speed & MII_PHY_CR_100M)\n\t\tpDrvCtrl->OpMode &= (~CSR6_TTM);\n\telse\n\t\tpDrvCtrl->OpMode |= (CSR6_TTM);\n\tif(pDrvCtrl->MII_Auto_Duplex & MII_PHY_CR_FDX)\n\t\tpDrvCtrl->OpMode |= CSR6_FD;\n\telse\n\t\tpDrvCtrl->OpMode &= (~CSR6_FD);\n\n    //Initail CSR\n\tsMacCSRReSetup(pDrvCtrl);\n\n \t/* start and tranmit (receiver will start after filter setup)*/\n \t/* HW ISSU 4 */\n  sMAC_CSR_UPDATE (pDrvCtrl->devAdrs, CSR6, (CSR6_ST));\n\n  pDrvCtrl->rxIndex=0;\n\tpDrvCtrl->txIndex=0;\n\tpDrvCtrl->txDiIndex=0;\n\tpDrvCtrl->txCount=0;\n\tpDrvCtrl->txFrameCount=0;\n\tpDrvCtrl->rx_dead=0;\n\n\t#ifdef SMAC_ERRORDEBUG\n\t\t//Clear error debug\n  memset ((char *)&pDrvCtrl->errStats, 0, sizeof (SMAC_STATS));\n\t#endif /* SMAC_ERRORDEBUG */\n\n\t#ifdef \tMAC_DATA_BUFFER_SIZEVARIABLE\n  pDrvCtrl->rx_FristNeeded=TRUE;\n  pDrvCtrl->rx_SegLength=0;\n\tpDrvCtrl->rx_PoolCurrentPt=pDrvCtrl->rx_PoolPt->DataPool;\n  pDrvCtrl->rx_PooliRead=0;\n  pDrvCtrl->rx_PooliWrite=0;\n  pDrvCtrl->rxMultiFCount=0;\n  #endif\n \t//Initial Interrupt\n \tsMacIntInit(pDrvCtrl);\n\n    //Connect to Interrupt\n  SYS_INT_CONNECT(pDrvCtrl, sMacInt, pDrvCtrl, &result);\n\tSYS_INT_SET_TYPE(pDrvCtrl, HI_LEVEL);\n\t//SYS_INT_SET_TYPE(pDrvCtrl, LO_LEVEL);\n\n    /* clear the status register */\n  sMAC_CSR_WRITE (pDrvCtrl->devAdrs, CSR5, 0xffffffff);\n  #ifdef\tSIMULATION_ONLY\n  sMAC_CSR_WRITE (pDrvCtrl->devAdrs, CSR5, ~(0xffffffff));\n  #endif\n\n    /* set up the interrupts */\n  sMAC_CSR_WRITE (pDrvCtrl->devAdrs, CSR7, SMAC_INTMASK);\n\n  SYS_INT_ENABLE (pDrvCtrl);\n\n    /* Set our flag */\n  pDrvCtrl->attached = TRUE;\n\n\treturn(result);\n}", "path": "src\\MAC\\if_socle.c", "repo_name": "acctomhse/sq8000", "stars": 1, "license": "None", "language": "c", "size": 626}
{"docstring": "/* conjunction -> comparison AND conjunction\n * conjunction -> comparison\n */\n", "func_signal": "Node * rule_conjunction ()", "code": "{\n  Node *comp = NULL, *conj = NULL;\n\n  if (yycc == '(' || yycc == NUMBER || yycc == VAR_ID ||\n      yycc == READ || yycc == FUN_ID) {\n    comp = rule_comparison ();\n\n    if (yycc == AND) {\n      next_token ();\n\n      if (yycc == '(' || yycc == NUMBER || yycc == VAR_ID ||\n          yycc == READ || yycc == FUN_ID) {\n        conj = rule_conjunction ();\n        Node_lastSibling (comp)->next = conj;\n      } else expecting (\"expression after AND\");\n    }\n  } else expecting (\"comparison\");\n\n  if (conj != NULL) {\n    return Node_new (N_OP_EXP, Value_int (AND), NULL, comp);\n  }\n  return comp;\n}", "path": "src\\parser.c", "repo_name": "madx/compilation_classes", "stars": 1, "license": "None", "language": "c", "size": 140}
{"docstring": "/* setInstruction -> variable '=' expression ';'\n */\n", "func_signal": "Node * rule_setInstruction ()", "code": "{\n  Node *var = NULL, *expr = NULL;\n\n  if (yycc == VAR_ID) {\n    var = rule_variable ();\n\n    if (yycc == '=') {\n      next_token ();\n      expr = rule_expression ();\n      Node_lastSibling (var)->next = expr;\n\n      if (yycc == ';') {\n        next_token ();\n\n      } else expecting (\"';'\");\n    } else expecting (\"'='\");\n  } else expecting (\"variable identifier\");\n\n  return Node_new (N_SET_INST, NULL, NULL, var);\n}", "path": "src\\parser.c", "repo_name": "madx/compilation_classes", "stars": 1, "license": "None", "language": "c", "size": 140}
{"docstring": "/* varDecList2 -> ',' varDec varDecList2\n * varDecList2 -> void\n */\n", "func_signal": "Node * rule_varDecList2 ()", "code": "{\n  Node *head = NULL, *tail = NULL;\n\n  if (yycc == ',') {\n    next_token ();\n\n    if (yycc == INT) {\n      head = rule_varDec ();\n\n      if (yycc == ',') {\n        tail = rule_varDecList2 ();\n        Node_lastSibling(head)->next = tail;\n      }\n    } else expecting (\"keyword ENTIER\");\n  } else expecting (\"','\");\n\n  return Node_new (N_DEC_LIST, NULL, NULL, head);\n}", "path": "src\\parser.c", "repo_name": "madx/compilation_classes", "stars": 1, "license": "None", "language": "c", "size": 140}
{"docstring": "/* funDefList -> funDef funDefList\n * funDefList -> void\n */\n", "func_signal": "Node * rule_funDefList ()", "code": "{\n  Node *head = NULL, *tail = NULL;\n\n  if (yycc == FUN_ID) {\n    head = rule_funDef ();\n\n    if (yycc == FUN_ID) {\n      tail = rule_funDefList ();\n      Node_lastSibling(head)->next = tail;\n    }\n  } else expecting (\"function identifier\");\n\n  return Node_new (N_DEC_LIST, NULL, NULL, head);\n}", "path": "src\\parser.c", "repo_name": "madx/compilation_classes", "stars": 1, "license": "None", "language": "c", "size": 140}
{"docstring": "/* exprList -> expression exprList2\n * exprList -> void\n */\n", "func_signal": "Node * rule_exprList ()", "code": "{\n  Node *head = NULL, *tail = NULL;\n\n  if (yycc == '('  || yycc == NUMBER || yycc == VAR_ID ||\n      yycc == READ || yycc == FUN_ID) {\n    head = rule_expression ();\n\n    if (yycc == ',') {\n      tail = rule_exprList2 ();\n      Node_lastSibling(head)->next = tail;\n    }\n    return head;\n  }\n  return NULL;\n}", "path": "src\\parser.c", "repo_name": "madx/compilation_classes", "stars": 1, "license": "None", "language": "c", "size": 140}
{"docstring": "/* exprList2 -> ',' expression exprList2\n * exprList2 -> void\n */\n", "func_signal": "Node * rule_exprList2 ()", "code": "{\n  Node *head = NULL, *tail = NULL;\n\n  if (yycc == ',') {\n    next_token ();\n\n    if (yycc == '('  || yycc == NUMBER || yycc == VAR_ID ||\n      yycc == READ || yycc == FUN_ID) {\n      head = rule_expression ();\n\n      if (yycc == ',') {\n        tail = rule_exprList2 ();\n        Node_lastSibling(head)->next = tail;\n      }\n      return head;\n\n    } else expecting (\"expression\");\n  }\n\n  return NULL;\n}", "path": "src\\parser.c", "repo_name": "madx/compilation_classes", "stars": 1, "license": "None", "language": "c", "size": 140}
{"docstring": "/* paramList -> '(' varDecList ')'\n * paramList -> '(' ')'\n */\n", "func_signal": "Node * rule_paramList ()", "code": "{\n  Node *list = NULL;\n\n  if (yycc == '(') {\n    next_token ();\n\n    if (yycc == INT) {\n      list = rule_varDecList ();\n    }\n\n    if (yycc == ')') {\n      next_token ();\n\n    } else expecting (\"')'\");\n  } else expecting (\"'('\");\n\n  return list;\n}", "path": "src\\parser.c", "repo_name": "madx/compilation_classes", "stars": 1, "license": "None", "language": "c", "size": 140}
{"docstring": "/* instructionList -> instruction instructionList\n * instructionList -> void\n */\n", "func_signal": "Node * rule_instructionList ()", "code": "{\n  Node *head = NULL, *tail = NULL;\n\n  if (yycc == VAR_ID || yycc == FUN_ID || yycc == '{'    || yycc == ';' ||\n      yycc == IF     || yycc == WHILE  || yycc == RETURN || yycc == WRITE ||\n      yycc == DO ) {\n    head = rule_instruction ();\n\n    if (yycc == VAR_ID || yycc == FUN_ID || yycc == '{'    || yycc == ';' ||\n        yycc == IF     || yycc == WHILE  || yycc == RETURN || yycc == WRITE ||\n        yycc == DO ) {\n      tail = rule_instructionList ();\n      Node_lastSibling(head)->next = tail;\n    }\n\n  }\n  if (yycc != '}') expecting (\"'}'\");\n\n  return Node_new (N_INST_LIST, NULL, NULL, head);\n}", "path": "src\\parser.c", "repo_name": "madx/compilation_classes", "stars": 1, "license": "None", "language": "c", "size": 140}
{"docstring": "/* writeInstruction -> WRITE '(' expression ')' ';'\n */\n", "func_signal": "Node * rule_writeInstruction ()", "code": "{\n  Node *expr = NULL;\n\n  if (yycc == WRITE) {\n    next_token ();\n\n    if (yycc == '(') {\n      next_token ();\n\n      if (yycc == '(' || yycc == NUMBER || yycc == VAR_ID ||\n          yycc == READ || yycc == FUN_ID) {\n        expr = rule_expression ();\n\n        if (yycc == ')') {\n          next_token ();\n\n          if (yycc == ';') {\n            next_token ();\n\n          } else expecting (\"';'\");\n        } else expecting (\"')'\");\n      } else expecting (\"expression\");\n    } else expecting (\"'('\");\n  } else expecting (\"keyword WRITE\");\n\n  return Node_new (N_WRITE_INST, NULL, NULL, expr);\n}", "path": "src\\parser.c", "repo_name": "madx/compilation_classes", "stars": 1, "license": "None", "language": "c", "size": 140}
{"docstring": "/* funCallExp -> FUN_ID arguments\n */\n", "func_signal": "Node * rule_funCallExp ()", "code": "{\n  Node  *args = NULL;\n  Value *name = NULL;\n  if (yycc == FUN_ID) {\n    name = Value_str (yytext);\n    next_token ();\n    args = rule_arguments ();\n\n  } else expecting (\"function identifier\");\n\n  return Node_new (N_CALL_EXP, name, NULL, args);\n}", "path": "src\\parser.c", "repo_name": "madx/compilation_classes", "stars": 1, "license": "None", "language": "c", "size": 140}
{"docstring": "/* returnInstruction -> RETURN expression ';'\n */\n", "func_signal": "Node * rule_returnInstruction ()", "code": "{\n  Node *expr = NULL;\n\n  if (yycc == RETURN) {\n    next_token ();\n\n    if (yycc == '(' || yycc == NUMBER || yycc == VAR_ID ||\n        yycc == READ || yycc == FUN_ID) {\n      expr = rule_expression ();\n\n      if (yycc == ';') {\n        next_token ();\n\n      } else expecting (\"';'\");\n    } else expecting (\"expression\");\n  } else expecting (\"keyword RETURN\");\n\n  return Node_new (N_RETURN_INST, NULL, NULL, expr);\n}", "path": "src\\parser.c", "repo_name": "madx/compilation_classes", "stars": 1, "license": "None", "language": "c", "size": 140}
{"docstring": "/* factor -> '(' expression ')'\n * factor -> NUMBER\n * factor -> funCall\n * factor -> variable\n * factor -> READ '(' ')'\n */\n", "func_signal": "Node * rule_factor ()", "code": "{\n  Node  *out = NULL;\n  Value *val = NULL;\n\n  if (yycc == NUMBER) {\n    val = Value_int (atoi (yytext));\n    next_token ();\n    return Node_new (N_INT_EXP, val, NULL, NULL);\n\n  } else if (yycc == VAR_ID) {\n    out = rule_variable ();\n\n  } else if (yycc == FUN_ID) {\n    out = rule_funCallExp ();\n\n  } else if (yycc == '(') {\n    next_token ();\n    out = rule_expression ();\n\n    if (yycc == ')') {\n      next_token ();\n\n    } else expecting (\"')'\");\n\n  } else if (yycc == READ) {\n    next_token ();\n\n    if (yycc == '(') {\n      next_token ();\n\n      if (yycc == ')') {\n        next_token ();\n\n      } else expecting (\"')'\");\n    } else expecting (\"'('\");\n    return Node_new (N_READ_EXP, NULL, NULL, NULL);\n\n  } else expecting (\"factor\");\n\n  return out;\n}", "path": "src\\parser.c", "repo_name": "madx/compilation_classes", "stars": 1, "license": "None", "language": "c", "size": 140}
{"docstring": "/* voidInstruction -> ';'\n */\n", "func_signal": "Node * rule_voidInstruction ()", "code": "{\n  if (yycc == ';') next_token (); else expecting (\"';'\");\n  return Node_new (N_VOID_INST, NULL, NULL, NULL);\n}", "path": "src\\parser.c", "repo_name": "madx/compilation_classes", "stars": 1, "license": "None", "language": "c", "size": 140}
{"docstring": "/* arithmeticExpr -> term '+' arithmeticExpr\n * arithmeticExpr -> term '-' arithmeticExpr\n * arithmeticExpr -> term\n */\n", "func_signal": "Node * rule_arithmeticExpr ()", "code": "{\n  Node  *term = NULL, *expr = NULL;\n  Value *op = NULL;\n\n  if (yycc == '('  || yycc == NUMBER || yycc == VAR_ID ||\n      yycc == READ || yycc == FUN_ID) {\n    term = rule_term ();\n\n    if (yycc == '+' || yycc == '-') {\n      op = Value_int ((int) yycc);\n      next_token ();\n      expr = rule_arithmeticExpr ();\n      Node_lastSibling (term)->next = expr;\n    }\n  } else expecting (\"term\");\n\n  if (expr != NULL) {\n    return Node_new (N_OP_EXP, op, NULL, term);\n  }\n  return term;\n}", "path": "src\\parser.c", "repo_name": "madx/compilation_classes", "stars": 1, "license": "None", "language": "c", "size": 140}
{"docstring": "/* Utilitaires */\n", "func_signal": "void expecting (char *expected)", "code": "{\n  char type[280];\n  switch (yycc) {\n    case 330: sprintf(type, \"variable identifier (%s)\", yytext); break;\n    case 331: sprintf(type, \"function identifier (%s)\", yytext); break;\n    case 332: sprintf(type, \"number (%s)\", yytext);              break;\n    case 0:   sprintf(type, \"end of file\");                      break;\n    default:  sprintf(type, \"'%s'\", yytext);                     break;\n  }\n  fprintf (stderr, \"%s.%d: error: unexpected %s, expecting %s\\n\",\n           yyfile, yyline, type, expected);\n  exit (EXIT_FAILURE);\n}", "path": "src\\parser.c", "repo_name": "madx/compilation_classes", "stars": 1, "license": "None", "language": "c", "size": 140}
{"docstring": "/* varDec -> INT VAR_ID\n * varDec -> INT VAR_ID '[' NUMBER ']'\n */\n", "func_signal": "Node * rule_varDec ()", "code": "{\n  Value *name = NULL;\n  Node  *index = NULL;\n\n  if (yycc == INT) {\n    next_token ();\n\n    if (yycc == VAR_ID) {\n      name = Value_str (yytext);\n      next_token ();\n\n      if (yycc == '[') {\n        next_token ();\n\n        if (yycc == NUMBER) {\n          index = Node_new (N_INT_EXP,\n                            Value_int (atoi (yytext)),\n                            NULL, NULL);\n          next_token ();\n\n          if (yycc == ']') {\n            next_token ();\n\n          } else expecting (\"']'\");\n        } else expecting (\"number\");\n      }\n\n    } else expecting (\"variable identifier\");\n  } else expecting (\"keyword ENTIER\");\n\n  if (index != NULL)\n    return Node_new (N_ARR_DEC, name, NULL, index);\n\n  return Node_new (N_VAR_DEC, name, index, NULL);\n}", "path": "src\\parser.c", "repo_name": "madx/compilation_classes", "stars": 1, "license": "None", "language": "c", "size": 140}
{"docstring": "/* varDecList -> varDec varDecList2\n */\n", "func_signal": "Node * rule_varDecList ()", "code": "{\n  Node *head = NULL, *tail = NULL;\n\n  if (yycc == INT) {\n    head = rule_varDec ();\n\n    if (yycc == ',') {\n      tail = rule_varDecList2 ();\n      Node_lastSibling(head)->next = tail;\n    }\n\n  } else expecting (\"keyword ENTIER\");\n\n  return Node_new (N_DEC_LIST, NULL, NULL, head);\n}", "path": "src\\parser.c", "repo_name": "madx/compilation_classes", "stars": 1, "license": "None", "language": "c", "size": 140}
{"docstring": "/* funCall -> FUN_ID arguments\n */\n", "func_signal": "Node * rule_funCall ()", "code": "{\n  Node  *args = NULL;\n  Value *name = NULL;\n  if (yycc == FUN_ID) {\n    name = Value_str (yytext);\n    next_token ();\n    args = rule_arguments ();\n\n  } else expecting (\"function identifier\");\n\n  return Node_new (N_CALL, name, NULL, args);\n}", "path": "src\\parser.c", "repo_name": "madx/compilation_classes", "stars": 1, "license": "None", "language": "c", "size": 140}
{"docstring": "/* comparison -> arithmeticExpr COMP_OP arithmeticExpr\n * comparison -> arithmeticExpr\n */\n", "func_signal": "Node * rule_comparison ()", "code": "{\n  Node  *expr1 = NULL, *expr2 = NULL;\n  Value *op = NULL;\n\n  if (yycc == '('  || yycc == NUMBER || yycc == VAR_ID ||\n      yycc == READ || yycc == FUN_ID) {\n    expr1 = rule_arithmeticExpr ();\n\n    if (yycc == EQ || yycc == NEQ || yycc == '<' || yycc == '>' ||\n        yycc == GE || yycc == LE) {\n      op = Value_int ((int) yycc);\n      next_token ();\n\n      if (yycc == '('  || yycc == NUMBER || yycc == VAR_ID ||\n          yycc == READ || yycc == FUN_ID) {\n        expr2 = rule_arithmeticExpr ();\n        Node_lastSibling (expr1)->next = expr2;\n      } else expecting (\"arithmetic expression\");\n    }\n\n  } else expecting (\"arithmetic expression\");\n\n  if (expr2 != NULL) {\n    return Node_new (N_OP_EXP, op, NULL, expr1);\n  }\n  return expr1;\n}", "path": "src\\parser.c", "repo_name": "madx/compilation_classes", "stars": 1, "license": "None", "language": "c", "size": 140}
{"docstring": "/* expression -> conjunction OR expression\n * expression -> conjunction\n */\n", "func_signal": "Node * rule_expression ()", "code": "{\n  Node *conj = NULL, *expr = NULL;\n\n  if (yycc == '('  || yycc == NUMBER || yycc == VAR_ID ||\n      yycc == READ || yycc == FUN_ID) {\n    conj = rule_conjunction ();\n\n    if (yycc == OR) {\n      next_token ();\n\n      if (yycc == '('  || yycc == NUMBER || yycc == VAR_ID ||\n          yycc == READ || yycc == FUN_ID) {\n        expr = rule_expression ();\n        Node_lastSibling (conj)->next = expr;\n      } else expecting (\"expression after OR\");\n    }\n\n  } else expecting (\"conjunction\");\n\n  if (expr != NULL) {\n    return Node_new (N_OP_EXP, Value_int (OR), NULL, conj);\n  }\n  return conj;\n}", "path": "src\\parser.c", "repo_name": "madx/compilation_classes", "stars": 1, "license": "None", "language": "c", "size": 140}
{"docstring": "/***************************************************************************\n * Function    : SkipListFree()\n * Description : Frees the given skip list. \n * Input       : Pointer to the skip list to be freed.\n * Output      : None.\n * Returns     : None. \n ****************************************************************************/\n", "func_signal": "void\nSkipListFree( SkipList_t *list )", "code": "{\n    register SkipListNode_t *p, *q;\n    int i;\n\n    /*\n     * Go through the list and delete all nodes. \n     */\n    p = list->header->forward[0];\n\n    while ( p ) {\n \n        q = p->forward[0];\n\n        /*\n         * Call the user registered free function in order\n         * to free the element stored in this node. \n         */\n\n        list->freeFn( p->value );\n\n        /*\n         * Now, free this node. \n         */\n        skipListNodeFree( list, p );\n\n        p = q;\n\n    }\n   \n    /*\n     * Note: the header was malloc'ed not user alloced, so do a free\n     */\n \n    free(list->header);\n\n    /*\n     * All the nodes are freed and hence free the list. \n     */\n    free( list );\n}", "path": "server\\skiplist.c", "repo_name": "samuelmay/mchat", "stars": 1, "license": "None", "language": "c", "size": 208}
{"docstring": "/******************************************************************************/\n", "func_signal": "int main()", "code": "{\n    int sock, e, cliLen, inMsgLen, outMsgLen, i;\n    struct sockaddr_in servAddr, cliAddr;\n    char inMsg[MAX_MSG_LEN], outMsg[MAX_MSG_LEN];\n    RegMsg_t *regMsg;\n    RegRespMsg_t *regRespMsg;\n    struct timeval timeVal;\n    unsigned long curtime;\n    User_t dummyUser, *user;\n    SkipListNode_t *node;\n    \n    /* open socket */\n    sock = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (sock < 0) {\n\t\tprintf(\"socket creation failed errno=%d\\n\", errno);\n        exit(0);\n\t}\n    bzero((char *)&servAddr,sizeof(servAddr));\n    servAddr.sin_family = AF_INET;\n    servAddr.sin_addr.s_addr = htonl(INADDR_ANY);\n    servAddr.sin_port = htons(SERV_PORT);\n    e = bind(sock, (struct sockaddr *)&servAddr, sizeof(servAddr));\n\tif (e < 0) {\n\t\tprintf(\"socket bind failed errno=%d\\n\", errno);\n        exit(0);\n\t}\n    /* create user table */\n    serv.userTable = SkipListAlloc(userTableCmp, userTableFree);\n    /* run the server main loop */\n    while (1) {\n        cliLen = sizeof(cliAddr);\n        /* wait for msg arrival */\n        inMsgLen = recvfrom(sock, inMsg, MAX_MSG_LEN, 0,\n            (struct sockaddr *)&cliAddr, (socklen_t*)&cliLen);\n\n        e = gettimeofday(&timeVal, NULL);\n        curtime = timeVal.tv_sec;\n\tchar ip[INET_ADDRSTRLEN];\n\tinet_ntop(AF_INET,&(cliAddr.sin_addr.s_addr),ip,INET_ADDRSTRLEN);\n        printf(\"[%ld] Rcvd pkt from %s:%d\\n\",\n\t     curtime, ip, ntohs(cliAddr.sin_port));\n        /* perform some checks */\n        if (inMsgLen < 0) {\n            printf(\"Error in recvfrom() errno=%d\\n\", errno);\n            continue;\n        }\n        if (inMsgLen > MAX_MSG_LEN) {\n            printf(\"Received message too long (size=%d)\\n\", inMsgLen);\n            continue;\n        }\n        regMsg = (RegMsg_t *)inMsg;\n        /* verify if passwd is correct */\n        if (strlen(regMsg->passwd) > 16 || strcmp(regMsg->passwd,SERV_PASSWD)!=0) {\n            printf(\"Passwd mismatch\\n\");\n            continue;\n        }\n        if (strlen(regMsg->username) > 14) {\n            printf(\"Username too long\\n\");\n            continue;\n        }\n        /* determine if user already in database */\n        strcpy(dummyUser.username, regMsg->username);\n        user = (User_t *)SKIPLIST_NODE_VALUE(\n            SkipListGetNode(serv.userTable, &dummyUser));\n        if (user==NULL) { /* new user */\n            user = (User_t *)malloc(sizeof(User_t)); assert(user);\n            memset(user, 0x0, sizeof(User_t));\n            strcpy(user->username, regMsg->username);\n            user->tcpPort = regMsg->tcpPort;\n            user->ipAddr = cliAddr.sin_addr.s_addr;\n            user->timestamp = curtime + SERV_AGE_TIME;\n            /* insert user in skiplist */\n            SkipListInsert(serv.userTable, user, user, 0);\n        }\n        else { /* user already exists */\n            user->tcpPort = regMsg->tcpPort;\n            user->ipAddr = cliAddr.sin_addr.s_addr;\n            user->timestamp = curtime + SERV_AGE_TIME;\n        }\n        /* remove aged-out entries */\n        for (node = SKIPLIST_NODE_FIRST(serv.userTable); node; ) {\n            user = SKIPLIST_NODE_VALUE(node);\n            node = SKIPLIST_NODE_NEXT(node);\n            if (user->timestamp < curtime) {\n                printf(\"Aging out user=%s\\n\", user->username);\n                SkipListDelete(serv.userTable, user);\n            }\n        }\n        /* create reply */\n        regRespMsg = (RegRespMsg_t *)outMsg;\n        regRespMsg->nusers = htonl(SKIPLIST_NUM_NODES(serv.userTable));\n        for (node = SKIPLIST_NODE_FIRST(serv.userTable), i=0, outMsgLen = 4;\n             node && (i < 50);\n             node = SKIPLIST_NODE_NEXT(node),\n                 ++i, outMsgLen += sizeof(struct UserInfo_s)) {\n            user = SKIPLIST_NODE_VALUE(node);\n            strcpy(regRespMsg->user[i].username, user->username);\n            regRespMsg->user[i].tcpPort = user->tcpPort;\n            regRespMsg->user[i].ipAddr = user->ipAddr;\n        }        \n        /* send the reply */\n        e = sendto(sock, outMsg, outMsgLen, 0,\n            (struct sockaddr*)&cliAddr, cliLen);\n        if (e < 0) {\n            printf(\"sendto() failure errno=%d\\n\", errno);\n            continue;\n        }\n    } /* end of forever loop */\n\n    return 0;\n}", "path": "server\\chatRegServ.c", "repo_name": "samuelmay/mchat", "stars": 1, "license": "None", "language": "c", "size": 208}
{"docstring": "/* Start listening for incoming connections on a local port */\n", "func_signal": "int start_listening(struct options *opts)", "code": "{\n\t/* create socket */\n\tint s;\n\tif ((s = socket(AF_INET,SOCK_STREAM,0)) < 0) {\n\t\tperror(\"listening socket creation failed\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t/* 'sockaddr_in' is short for 'socket address [for] internet' */\n\tstruct sockaddr_in server_addr;\n\tstruct sockaddr *server_addr_p = (struct sockaddr *)&server_addr;\n\tsocklen_t len = sizeof(struct sockaddr_in);\n\n\t/* Populate address struct */\n\tmemset(server_addr_p,0,len);\n        /* This is an Internet Protocol socket */\n\tserver_addr.sin_family = AF_INET;\n        /* Magic */\n\tserver_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n        /* the port we will listen on */\n\tserver_addr.sin_port = opts->local_port;\n\n\t/* Bind created socket to port specified in address struct */\n\tif (bind(s,server_addr_p,len) < 0) {\n\t\tperror(\"failed to bind listening socket\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t/* If the specified port was zero, (i.e. the user didn't specify it), we\n\t * were bound to a random free port. Get the actual port we binded to,\n\t * and update the options (which we will send to the registration\n\t * server) */\n\tif (getsockname(s,server_addr_p,&len) < 0) {\n\t\tperror(\"could not get port from bind\");\n\t\texit(EXIT_FAILURE);\n\t}\n\topts->local_port = server_addr.sin_port;\n\topts->local_port_h = ntohs(server_addr.sin_port);\n\n\t/* start listening for incoming connections. */\n\tif (listen(s,10) < 0) {\n\t\tperror(\"failed to listen on listening socket\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\treturn s;\n}", "path": "client\\connection.c", "repo_name": "samuelmay/mchat", "stars": 1, "license": "None", "language": "c", "size": 208}
{"docstring": "/* Initiate a connection to a remote user */\n", "func_signal": "void connect_user(char remote_user[USERNAME_LEN])", "code": "{\n\tint s;\n\tint i;\n\tstruct sockaddr_in server_addr;\n\tstruct sockaddr *server_addr_p = (struct sockaddr *)&server_addr;\n\n\tmemset(server_addr_p,0,sizeof(struct sockaddr_in));\n\n        /* UNSAFE CONCURRENT STUFF BEGINS */\n\tpthread_mutex_lock(&user_list_lock);\n\ti = lookup_user(remote_user);\n\tif (i < 0) {\n\t\tprintf(\"that user's not logged in!\\n\");\n\t} else if (user_list[i].socket != 0) {\n\t\tprintf(\"you're already connected to that user!\\n\");\n\t} else {\n\t\t/* Populate address struct from user entry */\n\t\tserver_addr.sin_family = AF_INET;\n\t\tserver_addr.sin_port = user_list[i].port;\n\t\tserver_addr.sin_addr.s_addr = user_list[i].ip;\n\n\t\t/* create socket for connection, then call connect() with it and\n\t\t * the address struct. */\n\t\tif ((s = socket(AF_INET,SOCK_STREAM,0)) < 0 ||\n\t\t    connect(s,server_addr_p,sizeof(struct sockaddr_in)) < 0) {\n\t\t\t/* fail */\n\t\t\tperror(\"could not connect to server\");\n\t\t\tif (close(s) < 0) {\n\t\t\t\tperror(\"connect user\");\n\t\t\t}\n\t\t} else {\n\t\t\tprintf(\"connecting to user \" USERNAME_PRINT_FMT \"\\n\",\n\t\t\t       remote_user);\n\t\t\t/* Update user list entry with new connection details */\n\t\t\tuser_list[i].flags |= USER_CONNECTED;\n\t\t\tuser_list[i].socket = s;\n\t\t}\n\t}\n\tpthread_mutex_unlock(&user_list_lock);\n\t/* UNSAFE CONCURRENT STUFF ENDS */\n\n\treturn;\n}", "path": "client\\connection.c", "repo_name": "samuelmay/mchat", "stars": 1, "license": "None", "language": "c", "size": 208}
{"docstring": "/***************************************************************************\n * Function    : SkipListGetNodeOrNext()\n * Description : Gets the node or if not present, the next node\n *               in the list based on the key.. \n * Input       : Pointer to the list and the key . \n * Output      : None.\n * Returns     : Pointer to the node or if not found, the next node.\n * ***************************************************************************/\n", "func_signal": "SkipListNode_t *\nSkipListGetNodeOrNext( SkipList_t *list, void *key )", "code": "{\n    int i = 0;\n    SkipListNode_t *x= NULL;\n    \n    /*\n     * Scan all levels while (list-key<serach-key) starting\n     * with header in its level. \n     */\n    for ( x=list->header, i=list->level; i >= 0; i-- ) {\n        while ( x->forward[i] != 0 &&\n                list->cmpFn(x->forward[i]->key, key) < 0 ) {\n            x = x->forward[i];\n        }\n    }\n    x = x->forward[0];\n    return (x);  \n}", "path": "server\\skiplist.c", "repo_name": "samuelmay/mchat", "stars": 1, "license": "None", "language": "c", "size": 208}
{"docstring": "/***************************************************************************\n * Function    : SkipListDelete()\n * Description : Deletes the matching element from the list. \n * Input       : Pointer to the list and the key whose corresponding\n *               entry is to be deleted from the list. \n * Output      : None.\n * Returns     : 0 -- success, -1 -- failure\n ****************************************************************************/\n", "func_signal": "int\nSkipListDelete( SkipList_t *list, void *key )", "code": "{\n    int i = 0;\n    SkipListNode_t *x = NULL;\n    SkipListNode_t *y = NULL;\n    SkipListNode_t *update[SKIPLIST_MAXLEVEL];\n    /*\n     * Scan all levels while (list-key<serach-key) starting\n     * with header in its level. \n     */\n    for ( x=list->header, i=list->level; i >= 0; i-- ) {\n        while ( x->forward[i] != 0 &&\n                list->cmpFn(x->forward[i]->key, key) < 0 ) {\n            x = x->forward[i];\n        }\n        /*\n         * Save level pointer. \n         */\n        update[i] = x;\n    }\n    x = x->forward[0];\n    /*\n     * If key exists, delete the corresponding element.\n     */\n    if ( x && list->cmpFn(x->key, key) == 0 ) {\n        for ( i=0; i<=list->level; i++ ) {\n            if ( (y=update[i])->forward[i] == x ) {\n                y->forward[i] = x->forward[i];\n            }    \n        }\n        list->freeFn( x->value );\n        skipListNodeFree( list, x );\n        /*\n         * Set the new header level.\n         */\n        while ( list->level > 0 &&\n            list->header->forward[list->level] == NULL ) {\n            list->level--; \n        }\n        list->numNodes--;\n        return( 0 );\n    }\n    else {\n        return( -1 );\n    }    \n}", "path": "server\\skiplist.c", "repo_name": "samuelmay/mchat", "stars": 1, "license": "None", "language": "c", "size": 208}
{"docstring": "/* Accept an incoming connection from another user, given the file descriptor we\n * were listening on. */\n", "func_signal": "void accept_new_connection(int fd)", "code": "{\n\tint s;\n\tint i;\n\n\t/* Create address struct to hold details of incoming connection. The\n\t * call to accept() will populate it. */\n\tstruct sockaddr_in client_addr;\n\tstruct sockaddr *client_addr_p = (struct sockaddr *)&client_addr;\n\tsocklen_t client_addr_len = sizeof(struct sockaddr_in);\n\n\tmemset(client_addr_p,0,client_addr_len);\n\tif ((s = accept(fd,client_addr_p,&client_addr_len)) < 0) {\n\t\tperror(\"accept new connection\");\n\t\tif (close(s) < 0) {\n\t\t\tperror(\"accept new connection\");\n\t\t}\n\t\treturn;\n\t}\n\n\t/* reverse look up user details to get username */\n\t/* UNSAFE CONCURRENT STUFF BEGINS */\n\tpthread_mutex_lock(&user_list_lock);\n\n\tif ((i = lookup_ip(client_addr.sin_addr.s_addr)) < 0 ||\n\t    user_list[i].flags & USER_BLOCKED) {\n\t\t/* they're not on the user list, or they're not wanted. close connection. */\n\t\tif (close(s) < 0) {\n\t\t\tperror(\"accept new connection\");\n\t\t}\n\t} else {\n\t\t/* set the bit */\n\t\tuser_list[i].flags |= USER_CONNECTED;\n\t\t/* store the socket (file descriptor) */\n\t\tuser_list[i].socket = s;\n\t\tprintf(\"\\naccepted incoming connection from \"\n\t\t       USERNAME_PRINT_FMT \".\",\n\t\t       user_list[i].name);\n\t\tfflush(stdout);\t/* needed to force output to screen if we don't\n\t\t\t\t * print a newline */\n\t}\n\tpthread_mutex_unlock(&user_list_lock);\n\t/* UNSAFE CONCURRENT STUFF ENDS */\n\treturn;\n}", "path": "client\\connection.c", "repo_name": "samuelmay/mchat", "stars": 1, "license": "None", "language": "c", "size": 208}
{"docstring": "/***************************************************************************\n * Function    : SkipListInstert()\n * Description : Inserts the given element in the skip list at\n *               the right place based on the specified key. \n * Input       : The list in which the element is to be inserted, key,\n *               element to be inserted and a flag which indicates\n *               whether to replace the existing element, if any. \n * Output      : None.\n * Returns     : 0 -- success, -1 -- failure\n * ***************************************************************************/\n", "func_signal": "int\nSkipListInsert( SkipList_t *list, void *key, void *value, int replace )", "code": "{\n    int i = 0;\n    int newLevel = 0;\n    SkipListNode_t *x= NULL;\n    SkipListNode_t *update[SKIPLIST_MAXLEVEL];\n    \n    /*\n     * Scan all levels while (list-key<serach-key) starting\n     * with header in its level. \n     */\n    for ( x=list->header, i=list->level; i >= 0; i-- ) {\n        while ( x->forward[i] != 0 &&\n                list->cmpFn(x->forward[i]->key, key) < 0 ) {\n            x = x->forward[i];\n        }\n        /*\n         * Save level pointer. \n         */\n        update[i] = x;\n    }\n    x = x->forward[0];\n    /*\n     * Element already exists. \n     */\n    if ( x && list->cmpFn(x->key, key) == 0 ) {\n        if ( replace ) {\n            list->freeFn( x->value );\n            x->key = key;\n            x->value = value;\n            return( 0 );\n        }\n        else\n            return( -1 );\n    }\n    /*\n     * Put a new element in the list for this key.\n     * Get the new level and fix the list level.\n     */\n    newLevel = getNewLevel( list->maxLevels );\n    /*\n     * Adjust the header level. \n     */\n    if ( newLevel > list->level ) {\n        for ( i=list->level+1; i<=newLevel; i++ ) {\n            update[i] = list->header;\n        }\n        list->level = newLevel;\n    }\n    /*\n     * Make the new element and insert it in the list. \n     */\n    x = newSkipListNode( list, key, value, newLevel );\n    /*\n     * Scan all levels.\n     */\n    for ( i=0; i<=newLevel; i++ ) {\n        /*\n         * Set the next pointer of the new element. \n         */\n        x->forward[i] = update[i]->forward[i];\n        update[i]->forward[i] = x;\n    }\n    list->numNodes++;\n    \n    return(0);\n}", "path": "server\\skiplist.c", "repo_name": "samuelmay/mchat", "stars": 1, "license": "None", "language": "c", "size": 208}
{"docstring": "/* looks up user list entry for the given username details. Returns the index in\n * the user list, or -1 if not found. MUST HOLD USER LIST LOCK. */\n", "func_signal": "int lookup_user(char name[USERNAME_LEN])", "code": "{\n\tint i;\n\tfor (i = 0; i < num_users && i < 50; i++) {\n\t\tif (strncmp(name,user_list[i].name,USERNAME_LEN) == 0) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}", "path": "client\\user.c", "repo_name": "samuelmay/mchat", "stars": 1, "license": "None", "language": "c", "size": 208}
{"docstring": "/***************************************************************************\n * Function    : SkipListGetNode()\n * Description : Finds the matching node for the given key. \n * Input       : Pointer to the list and the key whose matching\n *               element is to be found. \n * Output      : None.\n * Returns     : Pointer to the matching node.\n * ***************************************************************************/\n", "func_signal": "SkipListNode_t *\nSkipListGetNode( SkipList_t *list, void *key )", "code": "{\n    int i = 0;\n    SkipListNode_t *x= NULL;\n    \n    /*\n     * Scan all levels while (list-key<serach-key) starting\n     * with header in its level. \n     */\n    for ( x=list->header, i=list->level; i >= 0; i-- ) {\n        while ( x->forward[i] != 0 &&\n                list->cmpFn(x->forward[i]->key, key) < 0 ) {\n            x = x->forward[i];\n        }\n    }\n    x = x->forward[0];\n    if ( x && list->cmpFn(x->key, key) == 0 ) {\n        return( x );\n    }\n    else {\n        return( NULL );\n    }    \n}", "path": "server\\skiplist.c", "repo_name": "samuelmay/mchat", "stars": 1, "license": "None", "language": "c", "size": 208}
{"docstring": "/* Terminate a connection with a remote user */\n", "func_signal": "void disconnect_user(char remote_user[USERNAME_LEN])", "code": "{\n\tint i;\n\t/* BEGIN UNSAFE CONCURRENT STUFF */\n\tpthread_mutex_lock(&user_list_lock);\n\ti = lookup_user(remote_user);\n\tif (i < 0) {\n\t\tprintf(\"that user's not logged in!\\n\");\n\t} else if (!(user_list[i].flags & USER_CONNECTED)) {\n\t\tprintf(\"you're not connected to that user!\\n\");\n\t} else {\n\t\t/* Just call close on the socket like any old file, then clear\n\t\t * the connection details from the user list entry. */\n\t\tif (close(user_list[i].socket) < 0) {\n\t\t\tperror(\"disconnect user\");\n\t\t}\n\t\tuser_list[i].flags &= ~USER_CONNECTED;\n\t\tuser_list[i].socket = 0;\n\t\tprintf(USERNAME_PRINT_FMT \" was disconnected.\\n\",\n\t\t       remote_user);\n\t}\n\tpthread_mutex_unlock(&user_list_lock);\n\t/* END UNSAFE CONCURRENT STUFF */\n\treturn;\n}", "path": "client\\connection.c", "repo_name": "samuelmay/mchat", "stars": 1, "license": "None", "language": "c", "size": 208}
{"docstring": "/***************************************************************************\n * Function    : SkipListDeleteNode()\n * Description : Deletes the matching node from the list. \n * Input       : Pointer to the list and the key whose corresponding\n *               NODE is to be deleted from the list. \n *               The FREE FUNCTION is NOT called.\n *               This is useful in cases where the structure needs to be preserved\n *               without having to provide a dummy free function\n * Output      : None.\n * Returns     : 0 -- success, -1 -- failure\n ****************************************************************************/\n", "func_signal": "int\nSkipListDeleteNode( SkipList_t *list, void *key )", "code": "{\n    SkipListFree_t saveFree = list->freeFn;\n    int ret;\n\n    list->freeFn = SkipListDummyFree;\n\n    ret = SkipListDelete(list,key);\n\n    list->freeFn = saveFree;\n\n    return ret;\n\n}", "path": "server\\skiplist.c", "repo_name": "samuelmay/mchat", "stars": 1, "license": "None", "language": "c", "size": 208}
{"docstring": "/***************************************************************************\n *                        S T A T I C   F U N C T I O N S\n ***************************************************************************/\n", "func_signal": "static int\ngetNewLevel( int maxLevel )", "code": "{\n    int level;\n\n    for ( level = 0; (rand() < (RAND_MAX / 2)) && level < SKIPLIST_MAXLEVEL; level++ )\n        ;\n\n    level = level > maxLevel ? maxLevel : level;\n\n    return( level );\n\n}", "path": "server\\skiplist.c", "repo_name": "samuelmay/mchat", "stars": 1, "license": "None", "language": "c", "size": 208}
{"docstring": "/******************************************************************************/\n", "func_signal": "int userTableCmp(void *k1, void *k2)", "code": "{\n    User_t *u1 = (User_t *)k1;\n    User_t *u2 = (User_t *)k2;\n    assert(u1 && u2);\n    return strcmp(u1->username, u2->username);\n}", "path": "server\\chatRegServ.c", "repo_name": "samuelmay/mchat", "stars": 1, "license": "None", "language": "c", "size": 208}
{"docstring": "/***************************************************************************\n * Function    : SkipListGetNext()\n * Description : Gets the next node in the list based on the key.\n * Input       : Pointer to the list and the key whose lexicographically\n *               next node is to be found. \n * Output      : None.\n * Returns     : Pointer to the next node in the list.\n * ***************************************************************************/\n", "func_signal": "SkipListNode_t *\nSkipListGetNext( SkipList_t *list, void *key )", "code": "{\n    int i = 0;\n    SkipListNode_t *x= NULL;\n    \n    for ( x=list->header, i=list->level; i >= 0; i-- ) {\n        while ( x->forward[i] != 0 &&\n                list->cmpFn(x->forward[i]->key, key) < 0 ) {\n            x = x->forward[i];\n        }\n    }\n    x = x->forward[0];\n    if ( x && list->cmpFn(x->key, key) == 0 ) {\n        x = x->forward[0];\n    }\n\n    return( x );\n}", "path": "server\\skiplist.c", "repo_name": "samuelmay/mchat", "stars": 1, "license": "None", "language": "c", "size": 208}
{"docstring": "/***************************************************************************\n * Function    : SkipListClear()\n * Description : Frees all data items on the skiplist.\n * Input       : Pointer to the skip list to be cleared.\n * Output      : None.\n * Returns     : None. \n ****************************************************************************/\n", "func_signal": "void\nSkipListClear( SkipList_t *list )", "code": "{\n    register SkipListNode_t *p, *q;\n    int i;    \n\n    /*\n     * Go through the list and delete all nodes. \n     * except header node\n     */\n    p = list->header->forward[0];\n\n    while ( p ) {\n\n        q = p->forward[0];\n\n        /*\n         * Call the user registered free function in order\n         * to free the element stored in this node. \n         */\n\n        list->freeFn( p->value );\n\n        /*\n         * Now, free this node. \n         */\n\n        skipListNodeFree( list, p );\n\n        p = q;\n    }\n    \n\n    /*\n     * All the nodes are freed, the list and the header node remain\n     */\n\n    for ( i=0; i<=list->maxLevels; i++ ) {\n\n        list->header->forward[i] = NULL;\n\n    }\n\n\tlist->level = 0;\n\n    list->numNodes = 0;\n    \n}", "path": "server\\skiplist.c", "repo_name": "samuelmay/mchat", "stars": 1, "license": "None", "language": "c", "size": 208}
{"docstring": "/***************************************************************************\n * Function    : SkipListNClear()\n * Description : Frees n data items on the skiplist.\n * Input       : Pointer to the skip list to be cleared.\n * Output      : None.\n * Returns     : None. \n ****************************************************************************/\n", "func_signal": "void\nSkipListNClear( SkipList_t *list , int n)", "code": "{\n    register SkipListNode_t *p, *q;\n    int i;    \n    SkipListNode_t *update[SKIPLIST_MAXLEVEL + 1];\n\tint maxUpdateLevel = -1;\n\n\tif ( !n ||\n\t\t!SKIPLIST_NUM_NODES(list) )\n\t\treturn;\n\n\n\tif ( n > SKIPLIST_NUM_NODES(list) )\n\t\tn = SKIPLIST_NUM_NODES(list);\n\n\tif ( n == SKIPLIST_NUM_NODES(list) ) {\n\t\t\t\n\t\tSkipListClear(list);\n\t\treturn;\n\n\t}\n\n\tbzero((char *)update,sizeof(update));\n\t\n    /*\n     * Go through the list and delete all nodes. \n     * except header node\n     */\n\n    p = list->header->forward[0];\n\n\tassert(p != NULL);\n\n\ti = n;\n\n    while ( i ) {\n\n        q = p->forward[0];\n\n        /*\n         * Call the user registered free function in order\n         * to free the element stored in this node. \n         */\n\n\t\tif ( p->level > maxUpdateLevel )\n\t\t\tmaxUpdateLevel = p->level;\n\n\t\tmemcpy(update,p->forward,(p->level  + 1 ) * sizeof(SkipListNode_t *));\n\n        list->freeFn( p->value );\n\n        /*\n         * Now, free this node. \n         */\n\n        skipListNodeFree( list, p );\n\n        p = q;\n\n\t\ti--;\n    }\n\n\tmemcpy(list->header->forward,update,(maxUpdateLevel + 1 ) * sizeof(SkipListNode_t *));\n\n    while ( list->level > 0 &&\n        list->header->forward[list->level] == NULL ) {\n        list->level--; \n    }\n\n    list->numNodes-=n;\n    \n}", "path": "server\\skiplist.c", "repo_name": "samuelmay/mchat", "stars": 1, "license": "None", "language": "c", "size": 208}
{"docstring": "/* for some reason a mutex must always\n\t\t\t\t\t   * be used with a condition\n\t\t\t\t\t   * variable. DO NOT USE */\n", "func_signal": "void *registration_thread(void *arg)", "code": "{\n\tstruct options *server_opts = arg;\n\tint socket_fd;\n\tu_int32_t i;\n\tint j;\n\n\t/* we build a temporary new user list from the server response here,\n\t * before copying it over to the real one. */\n\tstruct user tmp_user_list[MAX_USERS];\n\n\t/* misc structs for dealing with time and sleeping */\n\tint retval;\n\tstruct timespec timeout;\n\tstruct timeval time;\n\n\t/* Acquire the condition variable lock. Magic concurrent stuff. */\n\tpthread_mutex_lock(&registration_update_lock);\n\n\t/* create socket */\n\tif ((socket_fd = socket(AF_INET,SOCK_DGRAM,0)) < 0) {\n\t\tperror(\"registration\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t/* zero and assign server address struct  */\n\tstruct sockaddr_in reg_addr;\n\tstruct sockaddr *reg_addr_p = (struct sockaddr *)&reg_addr;\n\tsocklen_t addr_len;\n\tmemset(&reg_addr,0,sizeof(struct sockaddr_in));\n\treg_addr.sin_family = AF_INET;\n\t/* Port and IP address of login server  */\n\treg_addr.sin_port = server_opts->server_port;\n\treg_addr.sin_addr = server_opts->ip;\n\n\t/* compose and send our registration message */\n\tstruct reg_msg message;\n\tsize_t message_len = sizeof(struct reg_msg);\n\tstruct reg_resp response;\n\tsize_t response_len = sizeof(struct reg_resp);\n\n\tmemset(&message,0,message_len);\n\tstrncpy((char *)&message.password,server_opts->password,15);\n\tstrncpy((char *)&message.username,server_opts->username,13);\n\tmessage.tcp_port = server_opts->local_port;\n\n\t/* poll server continously, every 30s */\n\twhile (1) {\n  \t\t/* what do you know huh, porting programs does reveal bugs */\n\t\taddr_len=sizeof(struct sockaddr_in);\n\t\tmemset(&tmp_user_list,0,MAX_USERS*sizeof(struct user));\n\n\t\t/* printf(\"sending registration message to server...\"); */\n\t\tif (sendto(socket_fd, &message, message_len, 0,\n\t\t\t   reg_addr_p, addr_len) < message_len) {\n\t\t\tperror(\"failed to send message to registration server\");\n\t\t}\n\n\t\t/* We don't know the recieved message length, so we\n\t\t * unfortunately can't check for an incomplete read error. */\n\t\tif (recvfrom(socket_fd, &response, response_len, 0,\n\t\t\t     reg_addr_p, &addr_len) < 0) {\n\t\t\tperror(\"failed to recieve response from registration server\");\n\t\t}\n\t\t/* printf(\"recieved response!\\n\"); */\n\n\t\t/* UNSAFE CONCURRENT STUFF BEGINS */\n\t\tpthread_mutex_lock(&user_list_lock);\n\t\t/* copy response info into temporary user list. Use the flags\n\t\t * from the existing user list if they are there. */\n\t\tfor (i = 0; i < ntohl(response.nusers); i++) {\n\t\t\tstrncpy(tmp_user_list[i].name,\n\t\t\t\tresponse.user[i].username,\n\t\t\t\tUSERNAME_LEN);\n\t\t\ttmp_user_list[i].port = response.user[i].tcp_port;\n\t\t\ttmp_user_list[i].ip = response.user[i].ip_addr;\n\t\t\tj = lookup_user(response.user[i].username);\n\t\t\tif (j >= 0) {\n\t\t\t\t/* we know this user, preserve existing\n\t\t\t\t * connection details */\n\t\t\t\ttmp_user_list[i].flags = user_list[j].flags;\n\t\t\t\ttmp_user_list[i].socket = user_list[j].socket;\n\t\t\t} else {\n\t\t\t\t/* new user, initialize connection fields to\n\t\t\t\t * zero */\n\t\t\t\ttmp_user_list[i].flags = 0;\n\t\t\t\ttmp_user_list[i].socket = 0;\n\t\t\t}\n\t\t}\n\t\t/* update user list */\n\t\tnum_users = ntohl(response.nusers);\n\t\tmemcpy(user_list,tmp_user_list,\n\t\t       num_users*sizeof(struct user));\n\t\tpthread_mutex_unlock(&user_list_lock);\n\t\t/* UNSAFE CONCURRENT STUFF ENDS */\n\n\t\t/* set wait time, and sleep */\n\t\tretval = gettimeofday(&time,NULL);\n\t\ttimeout.tv_sec = time.tv_sec + SERVER_TIMEOUT/2;\n//\t\ttimeout.tv_sec = time.tv_sec + 10;\n\t\ttimeout.tv_nsec = time.tv_usec*100;\n\t\t/* Your standard 'sleep()' from unistd.h also works here. */\n\t\tretval = pthread_cond_timedwait(&registration_update,\n\t\t\t\t\t\t&registration_update_lock,\n\t\t\t\t\t\t&timeout);\n\t}\n\treturn NULL;\n}", "path": "client\\registration.c", "repo_name": "samuelmay/mchat", "stars": 1, "license": "None", "language": "c", "size": 208}
{"docstring": "/***************************************************************************\n * Function    : SkipListAlloc()\n * Description : Allocates a new skip list. \n * Input       : Pointer to the compare function which is used to compare \n *               the keys and a pointer to the free function which is used\n *               to free the element stored in each skip list node. \n * Output      : None.\n * Returns     : Pointer to the newly allocated skip list.\n * ***************************************************************************/\n", "func_signal": "SkipList_t *\nSkipListAlloc( SkipListCmp_t cmpFn, SkipListFree_t freeFn )", "code": "{\n    int        i = 0;\n    SkipList_t *list = NULL;\n\n    /*\n     * We cannot proceed without the user functions. \n     */\n    if ( cmpFn == NULL || freeFn == NULL )\n        return( NULL);\n    /*\n     * Allocate memory for the new skip list. \n     */\n    i = sizeof(SkipList_t);\n    if ( (list = (SkipList_t *)malloc( i )) == NULL )\n        return( NULL );\n    memset( list, 0, i ); \n    /*\n     * Set the initial random level for the list and\n     * initialize various list variables. \n     */\n    srand( (unsigned long)time(NULL) );\n    list->level  = 0;\n    list->cmpFn  = cmpFn;\n    list->freeFn = freeFn;\n    list->numNodes = 0;\n    list->maxLevels = SKIPLIST_MAXLEVEL - 1;\n    list->header = newSkipListNode( list, (void *)0, (void *)0, list->maxLevels );\n    \n    return( list );\n}", "path": "server\\skiplist.c", "repo_name": "samuelmay/mchat", "stars": 1, "license": "None", "language": "c", "size": 208}
{"docstring": "/* receive an incoming message from a remote user that we are connected to,\n * given their socket / file descriptor */\n", "func_signal": "void receive_message(int fd)", "code": "{\n\tchar buffer[INPUT_LEN];\n\tint i;\n\tint length;\n\n\t/* Do a read on the socket. recv() returns the length of the recieved\n\t * string. */\n\tlength = recv(fd,buffer,INPUT_LEN,0);\n\tif (length < 0) {\n\t\t/* length was shorter than specified; read was incomplete */\n\t\tperror(\"failed to receive message.\");\n\t} else if (length == 0) {\n                /* Connection was closed at remote end. Close socket and remove\n                 * from user list. */\n\t\t/* UNSAFE CONCURRENT STUFF BEGINS */\n\t\tpthread_mutex_lock(&user_list_lock);\n\t\t/* We don't care if they're not on the user list, seeing as\n\t\t * we're deleting them anyway. */\n\t\tif ((i = lookup_socket(fd)) >= 0) {\n\t\t\tuser_list[i].flags &= ~USER_CONNECTED;/*clear the bit*/\n\t\t\tuser_list[i].socket = 0;\n\t\t}\n\n\t\tprintf(\"\\n\" USERNAME_PRINT_FMT \" closed their connection.\",\n\t\t       user_list[i].name);\n\t\tfflush(stdout);\n\n\t\tif (close(fd) < 0) {\n\t\t\tperror(\"recieve message\");\n\t\t}\n\t\tpthread_mutex_unlock(&user_list_lock);\n\t\t/* UNSAFE CONCURRENT STUFF ENDS */\n\t} else {\n\t\t/* Everything is good! Print out the recieved message and the\n\t\t * user that sent it. */\n\n\t\tif (length < INPUT_LEN) {\n\t\t\tbuffer[length] = '\\0';\n\t\t}\n\n\t\tif (buffer[length-1] == '\\n') {\n\t\t\tbuffer[length-1] = '\\0';\n\t\t}\n\n\n\t\tpthread_mutex_lock(&user_list_lock);\n\t\tif ((i = lookup_socket(fd)) < 0) {\n\t\t\t/* this should never happen, as how would we have an\n\t\t\t * open connection and socket from an unknown user? */\n\t\t\tperror(\"message from unknown user\");\n\t\t} else {\n\t\t\tprintf(\"\\n\" USERNAME_PRINT_FMT \" says: \" INPUT_PRINT_FMT,\n\t\t\t       user_list[i].name, buffer);\n\t\t\tfflush(stdout);\n\t\t}\n\t\tpthread_mutex_unlock(&user_list_lock);\n\t}\n\n\treturn;\n}", "path": "client\\connection.c", "repo_name": "samuelmay/mchat", "stars": 1, "license": "None", "language": "c", "size": 208}
{"docstring": "/* find time for sector from index, returns NONE if there is no exact match */\n", "func_signal": "static GstClockTime\ngst_dvd_read_src_get_time_for_sector (GstDvdReadSrc * src, guint sector)", "code": "{\n  gint i, j;\n\n  if (src->vts_tmapt == NULL || src->vts_tmapt->nr_of_tmaps == 0)\n    return GST_CLOCK_TIME_NONE;\n\n  for (i = 0; i < src->vts_tmapt->nr_of_tmaps; ++i) {\n    for (j = 0; j < src->vts_tmapt->tmap[i].nr_of_entries; ++j) {\n      if ((src->vts_tmapt->tmap[i].map_ent[j] & 0x7fffffff) == sector)\n        return src->vts_tmapt->tmap[i].tmu * (j + 1) * GST_SECOND;\n    }\n  }\n\n  if (sector == 0)\n    return (GstClockTime) 0;\n\n  return GST_CLOCK_TIME_NONE;\n}", "path": "ext\\dvdread\\dvdreadsrc.c", "repo_name": "prajnashi/gst-plugins-ugly", "stars": 1, "license": "lgpl-2.1", "language": "c", "size": 5620}
{"docstring": "/*\n * Check for a new DVD domain area, and update the structure if\n * necessary.\n */\n", "func_signal": "static void\ngst_dvd_nav_src_set_domain (GstDvdNavSrc * src)", "code": "{\n  GstDvdNavSrcDomainType domain;\n\n  if (dvdnav_is_domain_fp (src->dvdnav)) {\n    domain = GST_DVD_NAV_SRC_DOMAIN_FP;\n  } else if (dvdnav_is_domain_vmgm (src->dvdnav)) {\n    domain = GST_DVD_NAV_SRC_DOMAIN_VMGM;\n  } else if (dvdnav_is_domain_vtsm (src->dvdnav)) {\n    domain = GST_DVD_NAV_SRC_DOMAIN_VTSM;\n  } else if (dvdnav_is_domain_vts (src->dvdnav)) {\n    domain = GST_DVD_NAV_SRC_DOMAIN_VTS;\n  } else {\n    domain = GST_DVD_NAV_SRC_DOMAIN_UNKNOWN;\n  }\n\n  /* FIXME: We may send a signal if we have a new domain. */\n  src->domain = domain;\n}", "path": "ext\\dvdnav\\dvdnavsrc.c", "repo_name": "prajnashi/gst-plugins-ugly", "stars": 1, "license": "lgpl-2.1", "language": "c", "size": 5620}
{"docstring": "/* update the time map when the title change */\n", "func_signal": "static gint\ngst_dvd_nav_src_update_tmaps (GstDvdNavSrc * src)", "code": "{\n  int32_t title, part;\n  title_info_t *info;\n  gint title_set_nr, title_ttn;\n  gint i;\n\n  /* Reset stuffs */\n  src->use_tmaps = FALSE;\n  src->title_tmap = NULL;\n\n  /* FIXME: check if the title really changed, by now it's called on every\n   * DVDNAV_CELL_CHANGE event.\n   */\n  if (dvdnav_current_title_info (src->dvdnav, &title,\n          &part) != DVDNAV_STATUS_OK) {\n    GST_LOG_OBJECT (src, \"Failed getting current title informations!\");\n    return FALSE;\n  }\n\n  GST_LOG_OBJECT (src, \"title = %d, part = %d\", title, part);\n\n  /* load the VTS information for the title set our title is in */\n\n  /* Close old vts file */\n  if (src->vts_file) {\n    ifoClose (src->vts_file);\n    src->vts_file = NULL;\n  }\n\n  /* There isn't a timemap for the menus */\n  if (title < 1) {\n    GST_LOG_OBJECT (src, \"Time map not available for menus\");\n    return FALSE;\n  }\n\n  info = &src->tt_srpt->title[title - 1];\n  title_set_nr = info->title_set_nr;\n  GST_LOG_OBJECT (src, \"title_set_nr = %d\", title_set_nr);\n  title_ttn = info->vts_ttn;\n  GST_LOG_OBJECT (src, \"title_ttn= %d\", title_ttn);\n\n  src->vts_file = ifoOpen (src->dvd, title_set_nr);\n  if (src->vts_file == NULL) {\n    GST_ELEMENT_ERROR (src, RESOURCE, OPEN_READ,\n        (_(\"Could not open DVD\")),\n        (\"ifoOpen() failed: %s\", g_strerror (errno)));\n    return FALSE;\n  }\n\n  src->vts_tmapt = src->vts_file->vts_tmapt;\n  src->vts_ptt_srpt = src->vts_file->vts_ptt_srpt;\n\n  if (src->vts_file->vts_tmapt != NULL) {\n    i = title_ttn - 1;\n    if (i >= 0 && i < src->vts_tmapt->nr_of_tmaps) {\n      src->title_tmap = &src->vts_tmapt->tmap[i];\n      GST_LOG_OBJECT (src, \"Time map table number: %d\", i);\n    } else {\n      src->title_tmap = NULL;\n      GST_LOG_OBJECT (src, \"Cannot find table number for title %d\", title_ttn);\n      return FALSE;\n    }\n  }\n\n  /* Check that the max map entry sector size is >= then the length reported\n   * by dvdnav_get_position, as looks like this function doesn't compute \n   * correctly the pos and length values.\n   */\n  guint32 pos;\n  guint32 dvdnav_length;\n\n  if (dvdnav_get_position (src->dvdnav, &pos,\n          &dvdnav_length) != DVDNAV_STATUS_OK) {\n    GST_WARNING_OBJECT (src,\n        \"Cannot get stream length by dvdnav, \"\n        \"won't enable tmaps use as we cannot check if they're interaction with dvdnav is right\");\n    return FALSE;\n  } else {\n    if (src->title_tmap) {\n      int tmap_length;\n\n      tmap_length =\n          (src->title_tmap->map_ent[src->\n              title_tmap->nr_of_entries] & 0x7fffffff);\n      if (tmap_length >= dvdnav_length) {\n        GST_LOG_OBJECT (src, \"Using time maps for seeking\");\n      } else {\n        GST_WARNING_OBJECT (src,\n            \"Time maps has max sector (%d) < than length (%d) reported by dvdnav: \"\n            \"tmap problem or dvdnav bug?\", dvdnav_length);\n      }\n    }\n  }\n\n  /* Dump all tmaps for title set for debugging */\n  if (src->vts_tmapt) {\n    gint i, j;\n\n    GST_LOG_OBJECT (src, \"nr_of_tmaps = %d\", src->vts_tmapt->nr_of_tmaps);\n    for (i = 0; i < src->vts_tmapt->nr_of_tmaps; ++i) {\n      GST_LOG_OBJECT (src, \"======= Table %d ===================\", i);\n      GST_LOG_OBJECT (src, \"Offset relative to VTS_TMAPTI: %d\",\n          src->vts_tmapt->tmap_offset[i]);\n      GST_LOG_OBJECT (src, \"Time unit (seconds)          : %d\",\n          src->vts_tmapt->tmap[i].tmu);\n      GST_LOG_OBJECT (src, \"Number of entries            : %d\",\n          src->vts_tmapt->tmap[i].nr_of_entries);\n      for (j = 0; j < src->vts_tmapt->tmap[i].nr_of_entries; j++) {\n        guint64 time;\n\n        time = src->vts_tmapt->tmap[i].tmu * (j + 1) * GST_SECOND;\n        GST_LOG_OBJECT (src, \"Time: %\" GST_TIME_FORMAT \" VOBU \"\n            \"Sector: %d %s\", GST_TIME_ARGS (time),\n            src->vts_tmapt->tmap[i].map_ent[j] & 0x7fffffff,\n            (src->vts_tmapt->tmap[i].map_ent[j] >> 31) ? \"discontinuity\" : \"\");\n      }\n    }\n  } else {\n    GST_LOG_OBJECT (src, \"no vts_tmapt to dump\");\n    return FALSE;\n  }\n\n  src->use_tmaps = TRUE;\n  return TRUE;\n}", "path": "ext\\dvdnav\\dvdnavsrc.c", "repo_name": "prajnashi/gst-plugins-ugly", "stars": 1, "license": "lgpl-2.1", "language": "c", "size": 5620}
{"docstring": "/* random access mode - just pass over to our chain function */\n", "func_signal": "static void\ngst_rmdemux_loop (GstPad * pad)", "code": "{\n  GstRMDemux *rmdemux;\n  GstBuffer *buffer;\n  GstFlowReturn ret = GST_FLOW_OK;\n  guint size;\n\n  rmdemux = GST_RMDEMUX (GST_PAD_PARENT (pad));\n\n  GST_LOG_OBJECT (rmdemux, \"loop with state=%d and offset=0x%x\",\n      rmdemux->loop_state, rmdemux->offset);\n\n  switch (rmdemux->state) {\n    case RMDEMUX_STATE_HEADER:\n      size = HEADER_SIZE;\n      break;\n    case RMDEMUX_STATE_HEADER_DATA:\n      size = DATA_SIZE;\n      break;\n    case RMDEMUX_STATE_DATA_PACKET:\n      size = rmdemux->avg_packet_size;\n      break;\n    case RMDEMUX_STATE_EOS:\n      GST_LOG_OBJECT (rmdemux, \"At EOS, pausing task\");\n      ret = GST_FLOW_UNEXPECTED;\n      goto need_pause;\n    default:\n      GST_LOG_OBJECT (rmdemux, \"Default: requires %d bytes (state is %d)\",\n          (int) rmdemux->size, rmdemux->state);\n      size = rmdemux->size;\n  }\n\n  ret = gst_pad_pull_range (pad, rmdemux->offset, size, &buffer);\n  if (ret != GST_FLOW_OK) {\n    if (rmdemux->offset == rmdemux->index_offset) {\n      /* The index isn't available so forget about it */\n      rmdemux->loop_state = RMDEMUX_LOOP_STATE_DATA;\n      rmdemux->offset = rmdemux->data_offset;\n      GST_OBJECT_LOCK (rmdemux);\n      rmdemux->running = TRUE;\n      rmdemux->seekable = FALSE;\n      GST_OBJECT_UNLOCK (rmdemux);\n      return;\n    } else {\n      GST_DEBUG_OBJECT (rmdemux, \"Unable to pull %d bytes at offset 0x%08x \"\n          \"(pull_range returned flow %s, state is %d)\", (gint) size,\n          rmdemux->offset, gst_flow_get_name (ret), GST_STATE (rmdemux));\n      goto need_pause;\n    }\n  }\n\n  size = GST_BUFFER_SIZE (buffer);\n\n  /* Defer to the chain function */\n  ret = gst_rmdemux_chain (pad, buffer);\n  if (ret != GST_FLOW_OK) {\n    GST_DEBUG_OBJECT (rmdemux, \"Chain flow failed at offset 0x%08x\",\n        rmdemux->offset);\n    goto need_pause;\n  }\n\n  rmdemux->offset += size;\n\n  switch (rmdemux->loop_state) {\n    case RMDEMUX_LOOP_STATE_HEADER:\n      if (rmdemux->offset >= rmdemux->data_offset) {\n        /* It's the end of the header */\n        rmdemux->loop_state = RMDEMUX_LOOP_STATE_INDEX;\n        rmdemux->offset = rmdemux->index_offset;\n      }\n      break;\n    case RMDEMUX_LOOP_STATE_INDEX:\n      if (rmdemux->state == RMDEMUX_STATE_HEADER) {\n        if (rmdemux->index_offset == 0) {\n          /* We've read the last index */\n          rmdemux->loop_state = RMDEMUX_LOOP_STATE_DATA;\n          rmdemux->offset = rmdemux->data_offset;\n          GST_OBJECT_LOCK (rmdemux);\n          rmdemux->running = TRUE;\n          GST_OBJECT_UNLOCK (rmdemux);\n        } else {\n          /* Get the next index */\n          rmdemux->offset = rmdemux->index_offset;\n        }\n      }\n      break;\n    case RMDEMUX_LOOP_STATE_DATA:\n      break;\n  }\n\n  return;\n\n  /* ERRORS */\nneed_pause:\n  {\n    const gchar *reason = gst_flow_get_name (ret);\n\n    GST_LOG_OBJECT (rmdemux, \"pausing task, reason %s\", reason);\n    rmdemux->segment_running = FALSE;\n    gst_pad_pause_task (rmdemux->sinkpad);\n\n    if (GST_FLOW_IS_FATAL (ret) || ret == GST_FLOW_NOT_LINKED) {\n      if (ret == GST_FLOW_UNEXPECTED) {\n        /* perform EOS logic */\n        if (rmdemux->segment.flags & GST_SEEK_FLAG_SEGMENT) {\n          gint64 stop;\n\n          /* for segment playback we need to post when (in stream time)\n           * we stopped, this is either stop (when set) or the duration. */\n          if ((stop = rmdemux->segment.stop) == -1)\n            stop = rmdemux->segment.duration;\n\n          GST_LOG_OBJECT (rmdemux, \"Sending segment done, at end of segment\");\n          gst_element_post_message (GST_ELEMENT (rmdemux),\n              gst_message_new_segment_done (GST_OBJECT (rmdemux),\n                  GST_FORMAT_TIME, stop));\n        } else {\n          /* normal playback, send EOS to all linked pads */\n          GST_LOG_OBJECT (rmdemux, \"Sending EOS, at end of stream\");\n          gst_rmdemux_send_event (rmdemux, gst_event_new_eos ());\n        }\n      } else {\n        GST_ELEMENT_ERROR (rmdemux, STREAM, FAILED,\n            (NULL), (\"stream stopped, reason %s\", reason));\n        gst_rmdemux_send_event (rmdemux, gst_event_new_eos ());\n      }\n    }\n    return;\n  }\n}", "path": "gst\\realmedia\\rmdemux.c", "repo_name": "prajnashi/gst-plugins-ugly", "stars": 1, "license": "lgpl-2.1", "language": "c", "size": 5620}
{"docstring": "/* FIXME: handle also angle format */\n", "func_signal": "static gboolean\ngst_dvd_nav_src_handle_seek_event (GstDvdNavSrc * src, GstEvent * event)", "code": "{\n  GstSeekFlags flags;\n  GstSeekType cur_type, end_type;\n  gint64 new_off;\n  GstFormat format;\n  gdouble rate;\n\n  gst_event_parse_seek (event, &rate, &format, &flags, &cur_type, &new_off,\n      &end_type, NULL);\n\n  /* Cannot seek during another seek */\n  if (src->seek_pending) {\n    GST_WARNING_OBJECT (src, \"Cannot seek during another seek\");\n    return FALSE;\n  }\n\n  /* If we are in a still frame we cannot seek */\n  if (src->still_frame) {\n    GST_WARNING_OBJECT (src, \"Cannot seek during a still frame\");\n    return FALSE;\n  }\n\n  if (rate <= 0.0) {\n    GST_DEBUG_OBJECT (src, \"cannot do backwards playback yet\");\n    return FALSE;\n  }\n\n  if ((flags & GST_SEEK_FLAG_SEGMENT) != 0) {\n    GST_DEBUG_OBJECT (src, \"segment seek not supported\");\n    return FALSE;\n  }\n\n  if ((flags & GST_SEEK_FLAG_FLUSH) == 0) {\n    GST_DEBUG_OBJECT (src, \"can only do flushing seeks at the moment\");\n    return FALSE;\n  }\n\n  if (end_type != GST_SEEK_TYPE_NONE) {\n    GST_DEBUG_OBJECT (src, \"end seek type not supported\");\n    return FALSE;\n  }\n\n  if (cur_type != GST_SEEK_TYPE_SET) {\n    GST_DEBUG_OBJECT (src, \"only SEEK_TYPE_SET is supported\");\n    return FALSE;\n  }\n\n  if (format != chapter_format && format != title_format &&\n      format != GST_FORMAT_BYTES && format != GST_FORMAT_TIME) {\n    GST_DEBUG_OBJECT (src, \"unsupported seek format %d (%s)\", format,\n        gst_format_get_name (format));\n    return FALSE;\n  }\n\n  src->seek_pending = TRUE;\n\n  return GST_BASE_SRC_CLASS (parent_class)->event (GST_BASE_SRC (src), event);\n}", "path": "ext\\dvdnav\\dvdnavsrc.c", "repo_name": "prajnashi/gst-plugins-ugly", "stars": 1, "license": "lgpl-2.1", "language": "c", "size": 5620}
{"docstring": "/* FIXME: double-check this function, compare against original */\n", "func_signal": "static gint\ngst_dvd_read_src_get_next_cell (GstDvdReadSrc * src, pgc_t * pgc, gint cell)", "code": "{\n  /* Check if we're entering an angle block. */\n  if (pgc->cell_playback[cell].block_type != BLOCK_TYPE_ANGLE_BLOCK)\n    return (cell + 1);\n\n  while (pgc->cell_playback[cell].block_mode == BLOCK_MODE_LAST_CELL)\n    ++cell;\n\n  return cell + 1;              /* really +1? (tpm) */\n}", "path": "ext\\dvdread\\dvdreadsrc.c", "repo_name": "prajnashi/gst-plugins-ugly", "stars": 1, "license": "lgpl-2.1", "language": "c", "size": 5620}
{"docstring": "/* this function is called when the pad is activated and should start\n * processing data.\n *\n * We check if we can do random access to decide if we work push or\n * pull based.\n */\n", "func_signal": "static gboolean\ngst_rmdemux_sink_activate (GstPad * sinkpad)", "code": "{\n  if (gst_pad_check_pull_range (sinkpad)) {\n    return gst_pad_activate_pull (sinkpad, TRUE);\n  } else {\n    return gst_pad_activate_push (sinkpad, TRUE);\n  }\n}", "path": "gst\\realmedia\\rmdemux.c", "repo_name": "prajnashi/gst-plugins-ugly", "stars": 1, "license": "lgpl-2.1", "language": "c", "size": 5620}
{"docstring": "/* Returns true if the pack is a NAV pack */\n", "func_signal": "static gboolean\ngst_dvd_read_src_is_nav_pack (const guint8 * data, gint lbn, dsi_t * dsi_pack)", "code": "{\n  if (GST_READ_UINT32_BE (data + 0x26) != 0x000001BF)\n    return FALSE;\n\n  /* Check that this is substream 0 (PCI) */\n  if (data[0x2c] != 0)\n    return FALSE;\n\n  if (GST_READ_UINT32_BE (data + 0x400) != 0x000001BF)\n    return FALSE;\n\n  /* Check that this is substream 1 (DSI) */\n  if (data[0x406] != 1)\n    return FALSE;\n\n  /* Check sizes of PCI and DSI packets */\n  if (GST_READ_UINT16_BE (data + 0x2a) != 0x03d4)\n    return FALSE;\n\n  if (GST_READ_UINT16_BE (data + 0x404) != 0x03fa)\n    return FALSE;\n\n  /* Read the DSI packet into the provided struct and check it */\n  navRead_DSI (dsi_pack, (unsigned char *) data + DSI_START_BYTE);\n  if (lbn != dsi_pack->dsi_gi.nv_pck_lbn)\n    return FALSE;\n\n  return TRUE;\n}", "path": "ext\\dvdread\\dvdreadsrc.c", "repo_name": "prajnashi/gst-plugins-ugly", "stars": 1, "license": "lgpl-2.1", "language": "c", "size": 5620}
{"docstring": "/* this function gets called when we activate ourselves in pull mode.\n * We can perform  random access to the resource and we start a task\n * to start reading */\n", "func_signal": "static gboolean\ngst_rmdemux_sink_activate_pull (GstPad * pad, gboolean active)", "code": "{\n  GstRMDemux *rmdemux;\n\n  rmdemux = GST_RMDEMUX (GST_PAD_PARENT (pad));\n\n  GST_DEBUG_OBJECT (rmdemux, \"activate_pull\");\n\n  if (active) {\n    rmdemux->seekable = TRUE;\n    rmdemux->offset = 0;\n    rmdemux->loop_state = RMDEMUX_LOOP_STATE_HEADER;\n    rmdemux->data_offset = G_MAXUINT;\n\n    return gst_pad_start_task (pad, (GstTaskFunction) gst_rmdemux_loop, pad);\n  } else {\n    return gst_pad_stop_task (pad);\n  }\n}", "path": "gst\\realmedia\\rmdemux.c", "repo_name": "prajnashi/gst-plugins-ugly", "stars": 1, "license": "lgpl-2.1", "language": "c", "size": 5620}
{"docstring": "/* Find time for sector using time map, does interpolation */\n", "func_signal": "static GstClockTime\ngst_dvd_nav_src_get_time_for_sector_tmap (GstDvdNavSrc * src, guint sector)", "code": "{\n  gint i;\n  guint prev_sector = 0;\n  guint cur_sector = 0;\n  GstClockTime target, diff;\n\n  if (src->vts_tmapt == NULL || src->vts_tmapt->nr_of_tmaps == 0) {\n    return GST_CLOCK_TIME_NONE;\n  }\n\n  for (i = 0; i < src->title_tmap->nr_of_entries; ++i) {\n    prev_sector = cur_sector;\n    cur_sector = src->title_tmap->map_ent[i] & 0x7fffffff;\n    if (sector >= prev_sector && sector <= cur_sector) {\n      target = src->title_tmap->tmu * i * GST_SECOND;\n      if (i < src->title_tmap->nr_of_entries - 1) {\n        diff =\n            src->title_tmap->tmu * GST_SECOND * (sector -\n            prev_sector) / (cur_sector - prev_sector);\n        target += diff;\n      }\n      return target;\n    }\n  }\n\n  if (sector == 0)\n    return (GstClockTime) 0;\n\n  return GST_CLOCK_TIME_NONE;\n}", "path": "ext\\dvdnav\\dvdnavsrc.c", "repo_name": "prajnashi/gst-plugins-ugly", "stars": 1, "license": "lgpl-2.1", "language": "c", "size": 5620}
{"docstring": "/* this function gets called when we activate ourselves in push mode.\n * We cannot seek (ourselves) in the stream */\n", "func_signal": "static gboolean\ngst_rmdemux_sink_activate_push (GstPad * pad, gboolean active)", "code": "{\n  GstRMDemux *rmdemux;\n\n  rmdemux = GST_RMDEMUX (GST_PAD_PARENT (pad));\n\n  GST_DEBUG_OBJECT (rmdemux, \"activate_push\");\n\n  rmdemux->seekable = FALSE;\n\n  return TRUE;\n}", "path": "gst\\realmedia\\rmdemux.c", "repo_name": "prajnashi/gst-plugins-ugly", "stars": 1, "license": "lgpl-2.1", "language": "c", "size": 5620}
{"docstring": "/*\n * Check for a new highlighted area, and send an spu highlight event if\n * necessary.\n */\n", "func_signal": "static void\ngst_dvd_nav_src_update_highlight (GstDvdNavSrc * src, gboolean force)", "code": "{\n  int button = 0;\n  pci_t *pci;\n  dvdnav_highlight_area_t area;\n  GstEvent *event;\n\n  if (dvdnav_get_current_highlight (src->dvdnav, &button) != DVDNAV_STATUS_OK) {\n    GST_ELEMENT_ERROR (src, LIBRARY, FAILED, (NULL),\n        (\"dvdnav_get_current_highlight: %s\",\n            dvdnav_err_to_string (src->dvdnav)));\n    return;\n  }\n\n  pci = dvdnav_get_current_nav_pci (src->dvdnav);\n  if ((button > pci->hli.hl_gi.btn_ns) || (button < 0)) {\n    /* button is out of the range of possible buttons. */\n    button = 0;\n  }\n\n  if (!pci->hli.hl_gi.hli_ss) {\n    /* Not in menu */\n    button = 0;\n  }\n\n  if (button == 0) {\n    if (src->button != 0) {\n      src->button = 0;\n\n      gst_pad_push_event (GST_BASE_SRC_PAD (src),\n          gst_dvd_nav_src_make_dvd_event (src, \"dvd-spu-reset-highlight\",\n              NULL, NULL));\n    }\n    return;\n  }\n\n  if (dvdnav_get_highlight_area (pci, button, 0, &area) != DVDNAV_STATUS_OK) {\n    GST_ELEMENT_ERROR (src, LIBRARY, FAILED, (NULL),\n        (\"dvdnav_get_highlight_area: %s\", dvdnav_err_to_string (src->dvdnav)));\n    return;\n  }\n\n  /* Check if we have a new button number, or a new highlight region. */\n  if (button != src->button || force ||\n      memcmp (&area, &(src->area), sizeof (dvdnav_highlight_area_t)) != 0) {\n    memcpy (&(src->area), &area, sizeof (dvdnav_highlight_area_t));\n\n    event = gst_dvd_nav_src_make_dvd_event (src,\n        \"dvd-spu-highlight\",\n        \"button\", G_TYPE_INT, (gint) button,\n        \"palette\", G_TYPE_INT, (gint) area.palette,\n        \"sx\", G_TYPE_INT, (gint) area.sx,\n        \"sy\", G_TYPE_INT, (gint) area.sy,\n        \"ex\", G_TYPE_INT, (gint) area.ex,\n        \"ey\", G_TYPE_INT, (gint) area.ey, NULL);\n\n    if (src->button == 0) {\n      /* When setting the button for the first time, take the\n         timestamp into account. */\n      GST_EVENT_TIMESTAMP (event) = MPEGTIME_TO_GSTTIME (area.pts);\n    }\n\n    src->button = button;\n\n    GST_DEBUG (\"Sending dvd-spu-highlight for button %d\", button);\n    int ret = gst_pad_push_event (GST_BASE_SRC_PAD (src), event);\n\n    GST_DEBUG (\"End Sending dvd-spu-highlight for button %d, ret: %d\", button,\n        ret);\n  }\n}", "path": "ext\\dvdnav\\dvdnavsrc.c", "repo_name": "prajnashi/gst-plugins-ugly", "stars": 1, "license": "lgpl-2.1", "language": "c", "size": 5620}
{"docstring": "/* returns the sector in the index at (or before) the given time, or -1 */\n", "func_signal": "static gint\ngst_dvd_read_src_get_sector_from_time (GstDvdReadSrc * src, GstClockTime ts)", "code": "{\n  gint sector, i, j;\n\n  if (src->vts_tmapt == NULL || src->vts_tmapt->nr_of_tmaps == 0)\n    return -1;\n\n  sector = 0;\n  for (i = 0; i < src->vts_tmapt->nr_of_tmaps; ++i) {\n    for (j = 0; j < src->vts_tmapt->tmap[i].nr_of_entries; ++j) {\n      GstClockTime entry_time;\n\n      entry_time = src->vts_tmapt->tmap[i].tmu * (j + 1) * GST_SECOND;\n      if (entry_time <= ts) {\n        sector = src->vts_tmapt->tmap[i].map_ent[j] & 0x7fffffff;\n      }\n      if (entry_time >= ts) {\n        return sector;\n      }\n    }\n  }\n\n  if (ts == 0)\n    return 0;\n\n  return -1;\n}", "path": "ext\\dvdread\\dvdreadsrc.c", "repo_name": "prajnashi/gst-plugins-ugly", "stars": 1, "license": "lgpl-2.1", "language": "c", "size": 5620}
{"docstring": "/* Find sector from time */\n", "func_signal": "static GstClockTime\ngst_dvd_nav_src_get_sector_from_time (GstDvdNavSrc * src, GstClockTime time)", "code": "{\n  gint sector;\n\n  GST_OBJECT_LOCK (src);\n  if (src->use_tmaps) {\n    sector = gst_dvd_nav_src_get_sector_from_time_tmap (src, time);\n    if (sector >= 0) {\n      GST_OBJECT_UNLOCK (src);\n      return sector;\n    }\n  }\n\n  /* Fallback to average sector calculation */\n  sector = (GstClockTime) ((float) time / src->pgc_length * src->sector_length);\n  GST_OBJECT_UNLOCK (src);\n\n  return sector;\n}", "path": "ext\\dvdnav\\dvdnavsrc.c", "repo_name": "prajnashi/gst-plugins-ugly", "stars": 1, "license": "lgpl-2.1", "language": "c", "size": 5620}
{"docstring": "/* FIXME: handle also title, chapter, angle format */\n", "func_signal": "static gboolean\ngst_dvd_nav_src_do_seek (GstBaseSrc * basesrc, GstSegment * s)", "code": "{\n  GstDvdNavSrc *src;\n\n  src = GST_DVD_NAV_SRC (basesrc);\n\n  /* On the first call of do_seek in gstbasesrc during gst_base_src_activate_push the dvdnav vm\n   * isn't running. Return TRUE as the seek was done.\n   */\n  if (src->first_seek == TRUE) {\n    src->first_seek = FALSE;\n    return TRUE;\n  }\n\n  GST_DEBUG_OBJECT (src, \"Seeking to %s: %12\" G_GINT64_FORMAT,\n      gst_format_get_name (s->format), s->last_stop);\n\n  if (s->format == sector_format || s->format == GST_FORMAT_BYTES\n      || s->format == GST_FORMAT_TIME) {\n    gint sector = 0;\n\n    /* Convert in sector format */\n    if (s->format == GST_FORMAT_BYTES) {\n      sector = s->last_stop / DVD_SECTOR_SIZE;\n    } else if (s->format == GST_FORMAT_TIME) {\n      sector = gst_dvd_nav_src_get_sector_from_time (src, s->last_stop);\n    }\n\n    if (dvdnav_sector_search (src->dvdnav, sector,\n            SEEK_SET) != DVDNAV_STATUS_OK) {\n      GST_DEBUG_OBJECT (src, \"seek to %s %d failed\",\n          gst_format_get_name (s->format), s->last_stop);\n      return FALSE;\n    }\n    GST_LOG_OBJECT (src, \"seek to %s %d ok\", gst_format_get_name (s->format),\n        s->last_stop);\n\n  } else {\n    g_return_val_if_reached (FALSE);\n  }\n  return TRUE;\n}", "path": "ext\\dvdnav\\dvdnavsrc.c", "repo_name": "prajnashi/gst-plugins-ugly", "stars": 1, "license": "lgpl-2.1", "language": "c", "size": 5620}
{"docstring": "/* Use libdvdread to read and cache info from the IFO file about\n * streams in each VTS\n */\n", "func_signal": "static gboolean\nread_vts_info (GstDvdNavSrc * src)", "code": "{\n  dvd_reader_t *dvdi;\n  ifo_handle_t *ifo;\n  gint i;\n  gint n_vts;\n\n  if (src->vts_attrs) {\n    g_array_free (src->vts_attrs, TRUE);\n    src->vts_attrs = NULL;\n  }\n\n  dvdi = DVDOpen (src->device);\n  if (!dvdi)\n    return FALSE;\n\n  ifo = ifoOpen (dvdi, 0);\n  if (!ifo) {\n    GST_ERROR (\"Can't open VMG info\");\n    return FALSE;\n  }\n  n_vts = ifo->vts_atrt->nr_of_vtss;\n  memcpy (&src->vmgm_attr, ifo->vmgi_mat, sizeof (vmgi_mat_t));\n  ifoClose (ifo);\n\n  GST_DEBUG (\"Reading IFO info for %d VTSs\", n_vts);\n  src->vts_attrs = g_array_sized_new (FALSE, TRUE, sizeof (vtsi_mat_t),\n      n_vts + 1);\n  if (!src->vts_attrs)\n    return FALSE;\n  g_array_set_size (src->vts_attrs, n_vts + 1);\n\n  for (i = 1; i <= n_vts; i++) {\n    ifo = ifoOpen (dvdi, i);\n    if (!ifo) {\n      GST_ERROR (\"Can't open VTS %d\", i);\n      return FALSE;\n    }\n\n    GST_DEBUG (\"VTS %d, Menu has %d audio %d subpictures. \"\n        \"Title has %d and %d\", i,\n        ifo->vtsi_mat->nr_of_vtsm_audio_streams,\n        ifo->vtsi_mat->nr_of_vtsm_subp_streams,\n        ifo->vtsi_mat->nr_of_vts_audio_streams,\n        ifo->vtsi_mat->nr_of_vts_subp_streams);\n\n    memcpy (&g_array_index (src->vts_attrs, vtsi_mat_t, i),\n        ifo->vtsi_mat, sizeof (vtsi_mat_t));\n\n    ifoClose (ifo);\n  }\n  DVDClose (dvdi);\n  return TRUE;\n}", "path": "ext\\dvdnav\\dvdnavsrc.c", "repo_name": "prajnashi/gst-plugins-ugly", "stars": 1, "license": "lgpl-2.1", "language": "c", "size": 5620}
{"docstring": "/*** Querying and seeking ***/\n", "func_signal": "static gboolean\ngst_dvd_read_src_handle_seek_event (GstDvdReadSrc * src, GstEvent * event)", "code": "{\n  GstSeekFlags flags;\n  GstSeekType cur_type, end_type;\n  gint64 new_off, total;\n  GstFormat format;\n  GstPad *srcpad;\n  gboolean query_ok;\n  gdouble rate;\n\n  gst_event_parse_seek (event, &rate, &format, &flags, &cur_type, &new_off,\n      &end_type, NULL);\n\n  if (rate <= 0.0) {\n    GST_DEBUG_OBJECT (src, \"cannot do backwards playback yet\");\n    return FALSE;\n  }\n\n  if (end_type != GST_SEEK_TYPE_NONE) {\n    if ((format != chapter_format && format != GST_FORMAT_TIME) ||\n        end_type != GST_SEEK_TYPE_SET) {\n      GST_DEBUG_OBJECT (src, \"end seek type not supported\");\n      return FALSE;\n    }\n  }\n\n  if (cur_type != GST_SEEK_TYPE_SET) {\n    GST_DEBUG_OBJECT (src, \"only SEEK_TYPE_SET is supported\");\n    return FALSE;\n  }\n\n  if (format == angle_format) {\n    GST_OBJECT_LOCK (src);\n    if (new_off < 0 || new_off >= src->num_angles) {\n      GST_OBJECT_UNLOCK (src);\n      GST_DEBUG_OBJECT (src, \"invalid angle %d, only %d available\",\n          src->num_angles, src->num_angles);\n      return FALSE;\n    }\n    src->angle = (gint) new_off;\n    GST_OBJECT_UNLOCK (src);\n    GST_DEBUG_OBJECT (src, \"switched to angle %d\", (gint) new_off + 1);\n    return TRUE;\n  }\n\n  if (format != chapter_format && format != title_format &&\n      format != GST_FORMAT_BYTES && format != GST_FORMAT_TIME) {\n    GST_DEBUG_OBJECT (src, \"unsupported seek format %d (%s)\", format,\n        gst_format_get_name (format));\n    return FALSE;\n  }\n\n  if (format == GST_FORMAT_BYTES) {\n    GST_DEBUG_OBJECT (src, \"Requested seek to byte %\" G_GUINT64_FORMAT,\n        new_off);\n  } else if (format == GST_FORMAT_TIME) {\n    GST_DEBUG_OBJECT (src, \"Requested seek to time %\" GST_TIME_FORMAT,\n        GST_TIME_ARGS (new_off));\n    if (gst_dvd_read_src_get_sector_from_time (src, new_off) < 0) {\n      GST_DEBUG_OBJECT (src, \"Can't find sector for requested time\");\n      return FALSE;\n    }\n  }\n\n  srcpad = GST_BASE_SRC_PAD (src);\n\n  /* check whether the seek looks reasonable (ie within possible range) */\n  if (format == GST_FORMAT_BYTES) {\n    GST_OBJECT_LOCK (src);\n    query_ok = gst_dvd_read_src_get_size (src, &total);\n    GST_OBJECT_UNLOCK (src);\n  } else {\n    query_ok = gst_pad_query_duration (srcpad, &format, &total);\n  }\n\n  if (!query_ok) {\n    GST_DEBUG_OBJECT (src, \"Failed to query duration in format %s\",\n        gst_format_get_name (format));\n    return FALSE;\n  }\n\n  GST_DEBUG_OBJECT (src, \"Total      %s: %12\" G_GINT64_FORMAT,\n      gst_format_get_name (format), total);\n  GST_DEBUG_OBJECT (src, \"Seek to    %s: %12\" G_GINT64_FORMAT,\n      gst_format_get_name (format), new_off);\n\n  if (new_off >= total) {\n    GST_DEBUG_OBJECT (src, \"Seek position out of range\");\n    return FALSE;\n  }\n\n  /* set segment to seek format; this allows us to use the do_seek\n   * virtual function and let the base source handle all the tricky\n   * stuff for us. We don't use the segment internally anyway */\n  /* FIXME: can't take the stream lock here - what to do? */\n  GST_OBJECT_LOCK (src);\n  GST_BASE_SRC (src)->segment.format = format;\n  GST_BASE_SRC (src)->segment.start = 0;\n  GST_BASE_SRC (src)->segment.stop = total;\n  GST_BASE_SRC (src)->segment.duration = total;\n  GST_OBJECT_UNLOCK (src);\n\n  return GST_BASE_SRC_CLASS (parent_class)->event (GST_BASE_SRC (src), event);\n}", "path": "ext\\dvdread\\dvdreadsrc.c", "repo_name": "prajnashi/gst-plugins-ugly", "stars": 1, "license": "lgpl-2.1", "language": "c", "size": 5620}
{"docstring": "/* GST_DISABLE_GST_DEBUG */\n", "func_signal": "static GstEvent *\ngst_dvd_nav_src_make_dvd_event (GstDvdNavSrc * src, const gchar * event_name,\n    const gchar * firstfield, ...)", "code": "{\n  GstEvent *event;\n  GstStructure *structure;\n  va_list varargs;\n\n  g_return_val_if_fail (event_name != NULL, NULL);\n\n  /* Create a structure with the given fields. */\n  va_start (varargs, firstfield);\n  structure = gst_structure_new (\"application/x-gst-dvd\",\n      \"event\", G_TYPE_STRING, event_name, NULL);\n  gst_structure_set_valist (structure, firstfield, varargs);\n  va_end (varargs);\n\n  /* Create the DVD event and put the structure into it. */\n  event = gst_event_new_custom (GST_EVENT_CUSTOM_DOWNSTREAM_OOB, structure);\n\n  GST_LOG_OBJECT (src, \"created event %\" GST_PTR_FORMAT, event);\n\n  return event;\n}", "path": "ext\\dvdnav\\dvdnavsrc.c", "repo_name": "prajnashi/gst-plugins-ugly", "stars": 1, "license": "lgpl-2.1", "language": "c", "size": 5620}
{"docstring": "/* Validate that this looks like a reasonable point to seek to */\n", "func_signal": "static gboolean\ngst_rmdemux_validate_offset (GstRMDemux * rmdemux)", "code": "{\n  GstBuffer *buffer;\n  GstFlowReturn flowret;\n  guint16 version, length;\n  gboolean ret = TRUE;\n\n  flowret = gst_pad_pull_range (rmdemux->sinkpad, rmdemux->offset, 4, &buffer);\n\n  if (flowret != GST_FLOW_OK) {\n    GST_DEBUG_OBJECT (rmdemux, \"Failed to pull data at offset %d\",\n        rmdemux->offset);\n    return FALSE;\n  }\n  /* TODO: Can we also be seeking to a 'DATA' chunk header? Check this.\n   * Also, for the case we currently handle, can we check any more? It's pretty\n   * sucky to not be validating a little more heavily than this... */\n  /* This should now be the start of a data packet header. That begins with\n   * a 2-byte 'version' field, which has to be 0 or 1, then a length. I'm not\n   * certain what values are valid for length, but it must always be at least\n   * 4 bytes, and we can check that it won't take us past our known total size\n   */\n\n  version = RMDEMUX_GUINT16_GET (GST_BUFFER_DATA (buffer));\n  if (version != 0 && version != 1) {\n    GST_DEBUG_OBJECT (rmdemux, \"Expected version 0 or 1, got %d\",\n        (int) version);\n    ret = FALSE;\n  }\n\n  length = RMDEMUX_GUINT16_GET (GST_BUFFER_DATA (buffer) + 2);\n  /* TODO: Also check against total stream length */\n  if (length < 4) {\n    GST_DEBUG_OBJECT (rmdemux, \"Expected length >= 4, got %d\", (int) length);\n    ret = FALSE;\n  }\n\n  if (ret) {\n    rmdemux->offset += 4;\n    gst_adapter_clear (rmdemux->adapter);\n    gst_adapter_push (rmdemux->adapter, buffer);\n  } else {\n    GST_WARNING_OBJECT (rmdemux, \"Failed to validate seek offset at %d\",\n        rmdemux->offset);\n  }\n\n  return ret;\n}", "path": "gst\\realmedia\\rmdemux.c", "repo_name": "prajnashi/gst-plugins-ugly", "stars": 1, "license": "lgpl-2.1", "language": "c", "size": 5620}
{"docstring": "/* Find sector from time using time map if available */\n/* FIXME: do interpolation as in gst_dvd_nav_src_get_time_for_sector_tmap */\n", "func_signal": "static gint\ngst_dvd_nav_src_get_sector_from_time_tmap (GstDvdNavSrc * src, GstClockTime ts)", "code": "{\n  gint sector, i;\n\n  if (src->vts_tmapt == NULL || src->vts_tmapt->nr_of_tmaps == 0)\n    return -1;\n\n  sector = 0;\n  for (i = 0; i < src->title_tmap->nr_of_entries; ++i) {\n    GstClockTime entry_time;\n\n    entry_time = src->title_tmap->tmu * (i + 1) * GST_SECOND;\n    if (entry_time <= ts) {\n      sector = src->title_tmap->map_ent[i] & 0x7fffffff;\n    }\n    if (entry_time >= ts) {\n      return sector;\n    }\n  }\n\n  if (ts == 0)\n    return 0;\n\n  return -1;\n}", "path": "ext\\dvdnav\\dvdnavsrc.c", "repo_name": "prajnashi/gst-plugins-ugly", "stars": 1, "license": "lgpl-2.1", "language": "c", "size": 5620}
{"docstring": "/*****************************************************************************\n * CallBackDirectSoundEnum: callback to enumerate available devices\n *****************************************************************************/\n", "func_signal": "static int CALLBACK CallBackDirectSoundEnum( LPGUID p_guid, LPCSTR psz_desc,\n                                             LPCSTR psz_mod, LPVOID _p_aout )", "code": "{\n    aout_instance_t *p_aout = (aout_instance_t *)_p_aout;\n\n    msg_Dbg( p_aout, \"found device: %s\", psz_desc );\n\n    if( p_aout->output.p_sys->i_device_id == 0 && p_guid )\n    {\n        p_aout->output.p_sys->p_device_guid = malloc( sizeof( GUID ) );\n        *p_aout->output.p_sys->p_device_guid = *p_guid;\n        msg_Dbg( p_aout, \"using device: %s\", psz_desc );\n    }\n\n    p_aout->output.p_sys->i_device_id--;\n    return 1;\n}", "path": "modules\\audio_output\\directx.c", "repo_name": "iparag/vlc", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 145905}
{"docstring": "/**\n * Initialize messages queues\n * This function initializes all message queues\n */\n", "func_signal": "void msg_Create (libvlc_int_t *p_libvlc)", "code": "{\n    libvlc_priv_t *priv = libvlc_priv (p_libvlc);\n    vlc_mutex_init( &priv->msg_bank.lock );\n    vlc_mutex_init( &QUEUE.lock );\n    QUEUE.b_overflow = false;\n    QUEUE.i_start = 0;\n    QUEUE.i_stop = 0;\n    QUEUE.i_sub = 0;\n    QUEUE.pp_sub = 0;\n\n#ifdef UNDER_CE\n    QUEUE.logfile =\n        CreateFile( L\"vlc-log.txt\", GENERIC_WRITE,\n                    FILE_SHARE_READ|FILE_SHARE_WRITE, NULL,\n                    CREATE_ALWAYS, 0, NULL );\n    SetFilePointer( QUEUE.logfile, 0, NULL, FILE_END );\n#endif\n}", "path": "src\\misc\\messages.c", "repo_name": "iparag/vlc", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 145905}
{"docstring": "/*****************************************************************************\n * FlushMsg\n *****************************************************************************\n * Print all messages remaining in queue. MESSAGE QUEUE MUST BE LOCKED, since\n * this function does not check the lock.\n *****************************************************************************/\n", "func_signal": "static void FlushMsg ( msg_queue_t *p_queue )", "code": "{\n    int i_index, i_start, i_stop;\n\n    /* Get the maximum message index that can be freed */\n    i_stop = p_queue->i_stop;\n\n    /* Check until which value we can free messages */\n    for( i_index = 0; i_index < p_queue->i_sub; i_index++ )\n    {\n        i_start = p_queue->pp_sub[ i_index ]->i_start;\n\n        /* If this subscriber is late, we don't free messages before\n         * his i_start value, otherwise he'll miss messages */\n        if(   ( i_start < i_stop\n               && (p_queue->i_stop <= i_start || i_stop <= p_queue->i_stop) )\n           || ( i_stop < i_start\n               && (i_stop <= p_queue->i_stop && p_queue->i_stop <= i_start) ) )\n        {\n            i_stop = i_start;\n        }\n    }\n\n    /* Free message data */\n    for( i_index = p_queue->i_start;\n         i_index != i_stop;\n         i_index = (i_index+1) % VLC_MSG_QSIZE )\n    {\n        free( p_queue->msg[i_index].psz_msg );\n        free( p_queue->msg[i_index].psz_module );\n        free( p_queue->msg[i_index].psz_header );\n    }\n\n    /* Update the new start value */\n    p_queue->i_start = i_index;\n}", "path": "src\\misc\\messages.c", "repo_name": "iparag/vlc", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 145905}
{"docstring": "/*****************************************************************************\n * InitDirectSound: handle all the gory details of DirectSound initialisation\n *****************************************************************************/\n", "func_signal": "static int InitDirectSound( aout_instance_t *p_aout )", "code": "{\n    HRESULT (WINAPI *OurDirectSoundCreate)(LPGUID, LPDIRECTSOUND *, LPUNKNOWN);\n    HRESULT (WINAPI *OurDirectSoundEnumerate)(LPDSENUMCALLBACK, LPVOID);\n\n    p_aout->output.p_sys->hdsound_dll = LoadLibrary(\"DSOUND.DLL\");\n    if( p_aout->output.p_sys->hdsound_dll == NULL )\n    {\n        msg_Warn( p_aout, \"cannot open DSOUND.DLL\" );\n        goto error;\n    }\n\n    OurDirectSoundCreate = (void *)\n        GetProcAddress( p_aout->output.p_sys->hdsound_dll,\n                        \"DirectSoundCreate\" );\n    if( OurDirectSoundCreate == NULL )\n    {\n        msg_Warn( p_aout, \"GetProcAddress FAILED\" );\n        goto error;\n    }\n\n    /* Get DirectSoundEnumerate */\n    OurDirectSoundEnumerate = (void *)\n       GetProcAddress( p_aout->output.p_sys->hdsound_dll,\n                       \"DirectSoundEnumerateA\" );\n    if( OurDirectSoundEnumerate )\n    {\n        /* Attempt enumeration */\n        if( FAILED( OurDirectSoundEnumerate( CallBackDirectSoundEnum,\n                                             p_aout ) ) )\n        {\n            msg_Dbg( p_aout, \"enumeration of DirectSound devices failed\" );\n        }\n    }\n\n    /* Create the direct sound object */\n    if FAILED( OurDirectSoundCreate( p_aout->output.p_sys->p_device_guid,\n                                     &p_aout->output.p_sys->p_dsobject,\n                                     NULL ) )\n    {\n        msg_Warn( p_aout, \"cannot create a direct sound device\" );\n        goto error;\n    }\n\n    /* Set DirectSound Cooperative level, ie what control we want over Windows\n     * sound device. In our case, DSSCL_EXCLUSIVE means that we can modify the\n     * settings of the primary buffer, but also that only the sound of our\n     * application will be hearable when it will have the focus.\n     * !!! (this is not really working as intended yet because to set the\n     * cooperative level you need the window handle of your application, and\n     * I don't know of any easy way to get it. Especially since we might play\n     * sound without any video, and so what window handle should we use ???\n     * The hack for now is to use the Desktop window handle - it seems to be\n     * working */\n    if( IDirectSound_SetCooperativeLevel( p_aout->output.p_sys->p_dsobject,\n                                          GetDesktopWindow(),\n                                          DSSCL_EXCLUSIVE) )\n    {\n        msg_Warn( p_aout, \"cannot set direct sound cooperative level\" );\n    }\n\n    return VLC_SUCCESS;\n\n error:\n    p_aout->output.p_sys->p_dsobject = NULL;\n    if( p_aout->output.p_sys->hdsound_dll )\n    {\n        FreeLibrary( p_aout->output.p_sys->hdsound_dll );\n        p_aout->output.p_sys->hdsound_dll = NULL;\n    }\n    return VLC_EGENERIC;\n\n}", "path": "modules\\audio_output\\directx.c", "repo_name": "iparag/vlc", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 145905}
{"docstring": "/*****************************************************************************\n * Probe: probe the audio device for available formats and channels\n *****************************************************************************/\n", "func_signal": "static void Probe( aout_instance_t * p_aout )", "code": "{\n    vlc_value_t val, text;\n    int i_format;\n    unsigned int i_physical_channels;\n    DWORD ui_speaker_config;\n    bool is_default_output_set = false;\n\n    var_Create( p_aout, \"audio-device\", VLC_VAR_INTEGER | VLC_VAR_HASCHOICE );\n    text.psz_string = _(\"Audio Device\");\n    var_Change( p_aout, \"audio-device\", VLC_VAR_SETTEXT, &text, NULL );\n\n    /* Test for 5.1 support */\n    i_physical_channels = AOUT_CHAN_LEFT | AOUT_CHAN_RIGHT |\n                          AOUT_CHAN_CENTER | AOUT_CHAN_REARLEFT |\n                          AOUT_CHAN_REARRIGHT | AOUT_CHAN_LFE;\n    if( p_aout->output.output.i_physical_channels == i_physical_channels )\n    {\n        if( CreateDSBufferPCM( p_aout, &i_format, i_physical_channels, 6,\n                               p_aout->output.output.i_rate, true )\n            == VLC_SUCCESS )\n        {\n            val.i_int = AOUT_VAR_5_1;\n            text.psz_string = \"5.1\";\n            var_Change( p_aout, \"audio-device\",\n                        VLC_VAR_ADDCHOICE, &val, &text );\n            var_Change( p_aout, \"audio-device\", VLC_VAR_SETDEFAULT, &val, NULL );\n            is_default_output_set = true;\n            msg_Dbg( p_aout, \"device supports 5.1 channels\" );\n        }\n    }\n\n    /* Test for 7.1 support */\n    i_physical_channels = AOUT_CHAN_LEFT | AOUT_CHAN_RIGHT |\n                             AOUT_CHAN_CENTER | AOUT_CHAN_REARLEFT |\n                             AOUT_CHAN_MIDDLELEFT | AOUT_CHAN_MIDDLERIGHT |\n                             AOUT_CHAN_REARRIGHT | AOUT_CHAN_LFE;\n       if( p_aout->output.output.i_physical_channels == i_physical_channels )\n       {\n           if( CreateDSBufferPCM( p_aout, &i_format, i_physical_channels, 8,\n                                  p_aout->output.output.i_rate, true )\n               == VLC_SUCCESS )\n           {\n               val.i_int = AOUT_VAR_7_1;\n               text.psz_string = \"7.1\";\n               var_Change( p_aout, \"audio-device\",\n                           VLC_VAR_ADDCHOICE, &val, &text );\n               var_Change( p_aout, \"audio-device\", VLC_VAR_SETDEFAULT, &val, NULL );\n               is_default_output_set = true;\n               msg_Dbg( p_aout, \"device supports 7.1 channels\" );\n           }\n       }\n\n    /* Test for 3 Front 2 Rear support */\n    i_physical_channels = AOUT_CHAN_LEFT | AOUT_CHAN_RIGHT |\n                          AOUT_CHAN_CENTER | AOUT_CHAN_REARLEFT |\n                          AOUT_CHAN_REARRIGHT;\n    if( p_aout->output.output.i_physical_channels == i_physical_channels )\n    {\n        if( CreateDSBufferPCM( p_aout, &i_format, i_physical_channels, 5,\n                               p_aout->output.output.i_rate, true )\n            == VLC_SUCCESS )\n        {\n            val.i_int = AOUT_VAR_3F2R;\n            text.psz_string = N_(\"3 Front 2 Rear\");\n            var_Change( p_aout, \"audio-device\",\n                        VLC_VAR_ADDCHOICE, &val, &text );\n            if(!is_default_output_set)\n            {\n                var_Change( p_aout, \"audio-device\", VLC_VAR_SETDEFAULT, &val, NULL );\n                is_default_output_set = true;\n            }\n            msg_Dbg( p_aout, \"device supports 5 channels\" );\n        }\n    }\n\n    /* Test for 2 Front 2 Rear support */\n    i_physical_channels = AOUT_CHAN_LEFT | AOUT_CHAN_RIGHT |\n                          AOUT_CHAN_REARLEFT | AOUT_CHAN_REARRIGHT;\n    if( ( p_aout->output.output.i_physical_channels & i_physical_channels )\n        == i_physical_channels )\n    {\n        if( CreateDSBufferPCM( p_aout, &i_format, i_physical_channels, 4,\n                               p_aout->output.output.i_rate, true )\n            == VLC_SUCCESS )\n        {\n            val.i_int = AOUT_VAR_2F2R;\n            text.psz_string = N_(\"2 Front 2 Rear\");\n            var_Change( p_aout, \"audio-device\",\n                        VLC_VAR_ADDCHOICE, &val, &text );\n            if(!is_default_output_set)\n            {\n                var_Change( p_aout, \"audio-device\", VLC_VAR_SETDEFAULT, &val, NULL );\n                is_default_output_set = true;\n            }\n            msg_Dbg( p_aout, \"device supports 4 channels\" );\n        }\n    }\n\n    /* Test for stereo support */\n    i_physical_channels = AOUT_CHAN_LEFT | AOUT_CHAN_RIGHT;\n    if( CreateDSBufferPCM( p_aout, &i_format, i_physical_channels, 2,\n                           p_aout->output.output.i_rate, true )\n        == VLC_SUCCESS )\n    {\n        val.i_int = AOUT_VAR_STEREO;\n        text.psz_string = N_(\"Stereo\");\n        var_Change( p_aout, \"audio-device\", VLC_VAR_ADDCHOICE, &val, &text );\n        if(!is_default_output_set)\n        {\n            var_Change( p_aout, \"audio-device\", VLC_VAR_SETDEFAULT, &val, NULL );\n            is_default_output_set = true;\n            msg_Dbg( p_aout, \"device supports 2 channels (DEFAULT!)\" );\n        }\n        msg_Dbg( p_aout, \"device supports 2 channels\" );\n    }\n\n    /* Test for mono support */\n    i_physical_channels = AOUT_CHAN_CENTER;\n    if( CreateDSBufferPCM( p_aout, &i_format, i_physical_channels, 1,\n                           p_aout->output.output.i_rate, true )\n        == VLC_SUCCESS )\n    {\n        val.i_int = AOUT_VAR_MONO;\n        text.psz_string = N_(\"Mono\");\n        var_Change( p_aout, \"audio-device\", VLC_VAR_ADDCHOICE, &val, &text );\n        msg_Dbg( p_aout, \"device supports 1 channel\" );\n    }\n\n    /* Check the speaker configuration to determine which channel config should\n     * be the default */\n    if FAILED( IDirectSound_GetSpeakerConfig( p_aout->output.p_sys->p_dsobject,\n                                              &ui_speaker_config ) )\n    {\n        ui_speaker_config = DSSPEAKER_STEREO;\n        msg_Dbg( p_aout, \"GetSpeakerConfig failed\" );\n    }\n    switch( DSSPEAKER_CONFIG(ui_speaker_config) )\n    {\n    case DSSPEAKER_7POINT1:\n        msg_Dbg( p_aout, \"Windows says your SpeakerConfig is 7.1\" );\n        val.i_int = AOUT_VAR_7_1;\n        break;\n    case DSSPEAKER_5POINT1:\n        msg_Dbg( p_aout, \"Windows says your SpeakerConfig is 5.1\" );\n        val.i_int = AOUT_VAR_5_1;\n        break;\n    case DSSPEAKER_QUAD:\n        msg_Dbg( p_aout, \"Windows says your SpeakerConfig is Quad\" );\n        val.i_int = AOUT_VAR_2F2R;\n        break;\n#if 0 /* Lots of people just get their settings wrong and complain that\n       * this is a problem with VLC so just don't ever set mono by default. */\n    case DSSPEAKER_MONO:\n        val.i_int = AOUT_VAR_MONO;\n        break;\n#endif\n    case DSSPEAKER_SURROUND:\n        msg_Dbg( p_aout, \"Windows says your SpeakerConfig is surround\" );\n    case DSSPEAKER_STEREO:\n        msg_Dbg( p_aout, \"Windows says your SpeakerConfig is stereo\" );\n    default:\n        /* If nothing else is found, choose stereo output */\n        val.i_int = AOUT_VAR_STEREO;\n        break;\n    }\n    var_Set( p_aout, \"audio-device\", val );\n\n    /* Test for SPDIF support */\n    if ( AOUT_FMT_NON_LINEAR( &p_aout->output.output ) )\n    {\n        if( CreateDSBuffer( p_aout, VLC_FOURCC('s','p','d','i'),\n                            p_aout->output.output.i_physical_channels,\n                            aout_FormatNbChannels( &p_aout->output.output ),\n                            p_aout->output.output.i_rate,\n                            AOUT_SPDIF_SIZE, true )\n            == VLC_SUCCESS )\n        {\n            msg_Dbg( p_aout, \"device supports A/52 over S/PDIF\" );\n            val.i_int = AOUT_VAR_SPDIF;\n            text.psz_string = N_(\"A/52 over S/PDIF\");\n            var_Change( p_aout, \"audio-device\",\n                        VLC_VAR_ADDCHOICE, &val, &text );\n            if( config_GetInt( p_aout, \"spdif\" ) )\n                var_Set( p_aout, \"audio-device\", val );\n        }\n    }\n\n    var_Change( p_aout, \"audio-device\", VLC_VAR_CHOICESCOUNT, &val, NULL );\n    if( val.i_int <= 0 )\n    {\n        /* Probe() has failed. */\n        var_Destroy( p_aout, \"audio-device\" );\n        return;\n    }\n\n    var_AddCallback( p_aout, \"audio-device\", aout_ChannelsRestart, NULL );\n\n    val.b_bool = true;\n    var_Set( p_aout, \"intf-change\", val );\n}", "path": "modules\\audio_output\\directx.c", "repo_name": "iparag/vlc", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 145905}
{"docstring": "/*****************************************************************************\n * PrintMsg: output a standard message item to stderr\n *****************************************************************************\n * Print a message to stderr, with colour formatting if needed.\n *****************************************************************************/\n", "func_signal": "static void PrintMsg ( vlc_object_t * p_this, msg_item_t * p_item )", "code": "{\n#   define COL(x)  \"\\033[\" #x \";1m\"\n#   define RED     COL(31)\n#   define GREEN   COL(32)\n#   define YELLOW  COL(33)\n#   define WHITE   COL(0)\n#   define GRAY    \"\\033[0m\"\n\n#ifdef UNDER_CE\n    int i_dummy;\n#endif\n    static const char ppsz_type[4][9] = { \"\", \" error\", \" warning\", \" debug\" };\n    static const char ppsz_color[4][8] = { WHITE, RED, YELLOW, GRAY };\n    const char *psz_object;\n    libvlc_priv_t *priv = libvlc_priv (p_this->p_libvlc);\n    int i_type = p_item->i_type;\n\n    switch( i_type )\n    {\n        case VLC_MSG_ERR:\n            if( priv->i_verbose < 0 ) return;\n            break;\n        case VLC_MSG_INFO:\n            if( priv->i_verbose < 0 ) return;\n            break;\n        case VLC_MSG_WARN:\n            if( priv->i_verbose < 1 ) return;\n            break;\n        case VLC_MSG_DBG:\n            if( priv->i_verbose < 2 ) return;\n            break;\n    }\n\n    psz_object = p_item->psz_object_type;\n\n#ifdef UNDER_CE\n#   define CE_WRITE(str) WriteFile( QUEUE.logfile, \\\n                                    str, strlen(str), &i_dummy, NULL );\n    CE_WRITE( p_item->psz_module );\n    CE_WRITE( \" \" );\n    CE_WRITE( psz_object );\n    CE_WRITE( ppsz_type[i_type] );\n    CE_WRITE( \": \" );\n    CE_WRITE( p_item->psz_msg );\n    CE_WRITE( \"\\r\\n\" );\n    FlushFileBuffers( QUEUE.logfile );\n\n#else\n    /* Send the message to stderr */\n    if( priv->b_color )\n    {\n        if( p_item->psz_header )\n        {\n            utf8_fprintf( stderr, \"[\" GREEN \"%.8i\" GRAY \"] %s %s %s%s: %s%s\" GRAY\n                              \"\\n\",\n                         p_item->i_object_id, p_item->psz_header,\n                         p_item->psz_module, psz_object,\n                         ppsz_type[i_type], ppsz_color[i_type],\n                         p_item->psz_msg );\n        }\n        else\n        {\n             utf8_fprintf( stderr, \"[\" GREEN \"%.8i\" GRAY \"] %s %s%s: %s%s\" GRAY \"\\n\",\n                         p_item->i_object_id, p_item->psz_module, psz_object,\n                         ppsz_type[i_type], ppsz_color[i_type],\n                         p_item->psz_msg );\n        }\n    }\n    else\n    {\n        if( p_item->psz_header )\n        {\n            utf8_fprintf( stderr, \"[%.8i] %s %s %s%s: %s\\n\", p_item->i_object_id,\n                         p_item->psz_header, p_item->psz_module,\n                         psz_object, ppsz_type[i_type], p_item->psz_msg );\n        }\n        else\n        {\n            utf8_fprintf( stderr, \"[%.8i] %s %s%s: %s\\n\", p_item->i_object_id,\n                         p_item->psz_module, psz_object, ppsz_type[i_type],\n                         p_item->psz_msg );\n        }\n    }\n\n#   if defined(WIN32)\n    fflush( stderr );\n#   endif\n#endif\n}", "path": "src\\misc\\messages.c", "repo_name": "iparag/vlc", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 145905}
{"docstring": "/**\n * Unsubscribe from a message queue.\n */\n", "func_signal": "void __msg_Unsubscribe( vlc_object_t *p_this, msg_subscription_t *p_sub )", "code": "{\n    libvlc_priv_t *priv = libvlc_priv (p_this->p_libvlc);\n\n    LOCK_BANK;\n    vlc_mutex_lock( &QUEUE.lock );\n    for( int j = 0 ; j< QUEUE.i_sub ; j++ )\n    {\n        if( QUEUE.pp_sub[j] == p_sub )\n        {\n            REMOVE_ELEM( QUEUE.pp_sub, QUEUE.i_sub, j );\n            free( p_sub );\n        }\n    }\n    vlc_mutex_unlock( &QUEUE.lock );\n    UNLOCK_BANK;\n}", "path": "src\\misc\\messages.c", "repo_name": "iparag/vlc", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 145905}
{"docstring": "/*****************************************************************************\n * FillBuffer: Fill in one of the direct sound frame buffers.\n *****************************************************************************\n * Returns VLC_SUCCESS on success.\n *****************************************************************************/\n", "func_signal": "static int FillBuffer( aout_instance_t *p_aout, int i_frame,\n                       aout_buffer_t *p_buffer )", "code": "{\n    notification_thread_t *p_notif = p_aout->output.p_sys->p_notif;\n    aout_sys_t *p_sys = p_aout->output.p_sys;\n    void *p_write_position, *p_wrap_around;\n    long l_bytes1, l_bytes2;\n    HRESULT dsresult;\n\n    /* Before copying anything, we have to lock the buffer */\n    dsresult = IDirectSoundBuffer_Lock(\n                p_sys->p_dsbuffer,                              /* DS buffer */\n                i_frame * p_notif->i_frame_size,             /* Start offset */\n                p_notif->i_frame_size,                    /* Number of bytes */\n                &p_write_position,                  /* Address of lock start */\n                &l_bytes1,       /* Count of bytes locked before wrap around */\n                &p_wrap_around,            /* Buffer adress (if wrap around) */\n                &l_bytes2,               /* Count of bytes after wrap around */\n                0 );                                                /* Flags */\n    if( dsresult == DSERR_BUFFERLOST )\n    {\n        IDirectSoundBuffer_Restore( p_sys->p_dsbuffer );\n        dsresult = IDirectSoundBuffer_Lock(\n                               p_sys->p_dsbuffer,\n                               i_frame * p_notif->i_frame_size,\n                               p_notif->i_frame_size,\n                               &p_write_position,\n                               &l_bytes1,\n                               &p_wrap_around,\n                               &l_bytes2,\n                               0 );\n    }\n    if( dsresult != DS_OK )\n    {\n        msg_Warn( p_notif, \"cannot lock buffer\" );\n        if( p_buffer ) aout_BufferFree( p_buffer );\n        return VLC_EGENERIC;\n    }\n\n    if( p_buffer == NULL )\n    {\n        memset( p_write_position, 0, l_bytes1 );\n    }\n    else\n    {\n        if( p_sys->b_chan_reorder )\n        {\n            /* Do the channel reordering here */\n            aout_ChannelReorder( p_buffer->p_buffer, p_buffer->i_nb_bytes,\n                                 p_sys->i_channels, p_sys->pi_chan_table,\n                                 p_sys->i_bits_per_sample );\n        }\n\n        vlc_memcpy( p_write_position, p_buffer->p_buffer, l_bytes1 );\n        aout_BufferFree( p_buffer );\n    }\n\n    /* Now the data has been copied, unlock the buffer */\n    IDirectSoundBuffer_Unlock( p_sys->p_dsbuffer, p_write_position, l_bytes1,\n                               p_wrap_around, l_bytes2 );\n\n    p_notif->i_write_slot = (i_frame + 1) % FRAMES_NUM;\n    return VLC_SUCCESS;\n}", "path": "modules\\audio_output\\directx.c", "repo_name": "iparag/vlc", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 145905}
{"docstring": "/**\n * Subscribe to a message queue.\n */\n", "func_signal": "msg_subscription_t *__msg_Subscribe( vlc_object_t *p_this )", "code": "{\n    libvlc_priv_t *priv = libvlc_priv (p_this->p_libvlc);\n    msg_subscription_t *p_sub = malloc( sizeof( msg_subscription_t ) );\n\n    if (p_sub == NULL)\n        return NULL;\n\n    LOCK_BANK;\n    vlc_mutex_lock( &QUEUE.lock );\n\n    TAB_APPEND( QUEUE.i_sub, QUEUE.pp_sub, p_sub );\n\n    p_sub->i_start = QUEUE.i_start;\n    p_sub->pi_stop = &QUEUE.i_stop;\n    p_sub->p_msg   = QUEUE.msg;\n    p_sub->p_lock  = &QUEUE.lock;\n\n    vlc_mutex_unlock( &QUEUE.lock );\n    UNLOCK_BANK;\n\n    return p_sub;\n}", "path": "src\\misc\\messages.c", "repo_name": "iparag/vlc", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 145905}
{"docstring": "/*****************************************************************************\n * CreateDSBufferPCM: creates a PCM direct sound buffer.\n *****************************************************************************\n * We first try to create a WAVE_FORMAT_IEEE_FLOAT buffer if supported by\n * the hardware, otherwise we create a WAVE_FORMAT_PCM buffer.\n ****************************************************************************/\n", "func_signal": "static int CreateDSBufferPCM( aout_instance_t *p_aout, int *i_format,\n                              int i_channels, int i_nb_channels, int i_rate,\n                              bool b_probe )", "code": "{\n    vlc_value_t val;\n\n    var_Get( p_aout, \"directx-audio-float32\", &val );\n\n    /* Float32 audio samples are not supported for 5.1 output on the emu101k */\n\n    if( !val.b_bool || i_nb_channels > 2 ||\n        CreateDSBuffer( p_aout, VLC_FOURCC('f','l','3','2'),\n                        i_channels, i_nb_channels, i_rate,\n                        FRAME_SIZE * 4 * i_nb_channels, b_probe )\n        != VLC_SUCCESS )\n    {\n        if ( CreateDSBuffer( p_aout, VLC_FOURCC('s','1','6','l'),\n                             i_channels, i_nb_channels, i_rate,\n                             FRAME_SIZE * 2 * i_nb_channels, b_probe )\n             != VLC_SUCCESS )\n        {\n            return VLC_EGENERIC;\n        }\n        else\n        {\n            *i_format = VLC_FOURCC('s','1','6','l');\n            return VLC_SUCCESS;\n        }\n    }\n    else\n    {\n        *i_format = VLC_FOURCC('f','l','3','2');\n        return VLC_SUCCESS;\n    }\n}", "path": "modules\\audio_output\\directx.c", "repo_name": "iparag/vlc", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 145905}
{"docstring": "/*****************************************************************************\n * DestroyDSBuffer\n *****************************************************************************\n * This function destroys the secondary buffer.\n *****************************************************************************/\n", "func_signal": "static void DestroyDSBuffer( aout_instance_t *p_aout )", "code": "{\n    if( p_aout->output.p_sys->p_dsbuffer )\n    {\n        IDirectSoundBuffer_Release( p_aout->output.p_sys->p_dsbuffer );\n        p_aout->output.p_sys->p_dsbuffer = NULL;\n    }\n}", "path": "modules\\audio_output\\directx.c", "repo_name": "iparag/vlc", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 145905}
{"docstring": "/*****************************************************************************\n * Init: initialize dummy video thread output method\n *****************************************************************************/\n", "func_signal": "static int Init( vout_thread_t *p_vout )", "code": "{\n    int i_index, i_chroma;\n    char *psz_chroma;\n    picture_t *p_pic;\n    bool b_chroma = 0;\n\n    psz_chroma = config_GetPsz( p_vout, \"dummy-chroma\" );\n    if( psz_chroma )\n    {\n        if( strlen( psz_chroma ) >= 4 )\n        {\n            i_chroma = VLC_FOURCC( psz_chroma[0], psz_chroma[1],\n                                   psz_chroma[2], psz_chroma[3] );\n            b_chroma = 1;\n        }\n\n        free( psz_chroma );\n    }\n\n    I_OUTPUTPICTURES = 0;\n\n    /* Initialize the output structure */\n    if( b_chroma )\n    {\n        msg_Dbg( p_vout, \"forcing chroma 0x%.8x (%4.4s)\",\n                         i_chroma, (char*)&i_chroma );\n        p_vout->output.i_chroma = i_chroma;\n        if ( i_chroma == VLC_FOURCC( 'R', 'G', 'B', '2' ) )\n        {\n            p_vout->output.pf_setpalette = SetPalette;\n        }\n        p_vout->output.i_width  = p_vout->render.i_width;\n        p_vout->output.i_height = p_vout->render.i_height;\n        p_vout->output.i_aspect = p_vout->render.i_aspect;\n    }\n    else\n    {\n        /* Use same chroma as input */\n        p_vout->output.i_chroma = p_vout->render.i_chroma;\n        p_vout->output.i_rmask  = p_vout->render.i_rmask;\n        p_vout->output.i_gmask  = p_vout->render.i_gmask;\n        p_vout->output.i_bmask  = p_vout->render.i_bmask;\n        p_vout->output.i_width  = p_vout->render.i_width;\n        p_vout->output.i_height = p_vout->render.i_height;\n        p_vout->output.i_aspect = p_vout->render.i_aspect;\n    }\n\n    /* Try to initialize DUMMY_MAX_DIRECTBUFFERS direct buffers */\n    while( I_OUTPUTPICTURES < DUMMY_MAX_DIRECTBUFFERS )\n    {\n        p_pic = NULL;\n\n        /* Find an empty picture slot */\n        for( i_index = 0 ; i_index < VOUT_MAX_PICTURES ; i_index++ )\n        {\n            if( p_vout->p_picture[ i_index ].i_status == FREE_PICTURE )\n            {\n                p_pic = p_vout->p_picture + i_index;\n                break;\n            }\n        }\n\n        /* Allocate the picture */\n        if( p_pic == NULL )\n        {\n            break;\n        }\n\n        vout_AllocatePicture( VLC_OBJECT(p_vout), p_pic, p_vout->output.i_chroma,\n                              p_vout->output.i_width, p_vout->output.i_height,\n                              p_vout->output.i_aspect );\n\n        if( p_pic->i_planes == 0 )\n        {\n            break;\n        }\n\n        p_pic->i_status = DESTROYED_PICTURE;\n        p_pic->i_type   = DIRECT_PICTURE;\n\n        PP_OUTPUTPICTURE[ I_OUTPUTPICTURES ] = p_pic;\n\n        I_OUTPUTPICTURES++;\n    }\n\n    return( 0 );\n}", "path": "modules\\misc\\dummy\\vout.c", "repo_name": "iparag/vlc", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 145905}
{"docstring": "/*****************************************************************************\n * Play: we'll start playing the directsound buffer here because at least here\n *       we know the first buffer has been put in the aout fifo and we also\n *       know its date.\n *****************************************************************************/\n", "func_signal": "static void Play( aout_instance_t *p_aout )", "code": "{\n    if( !p_aout->output.p_sys->b_playing )\n    {\n        aout_buffer_t *p_buffer;\n        int i;\n\n        p_aout->output.p_sys->b_playing = 1;\n\n        /* get the playing date of the first aout buffer */\n        p_aout->output.p_sys->p_notif->start_date =\n            aout_FifoFirstDate( p_aout, &p_aout->output.fifo );\n\n        /* fill in the first samples */\n        for( i = 0; i < FRAMES_NUM; i++ )\n        {\n            p_buffer = aout_FifoPop( p_aout, &p_aout->output.fifo );\n            if( !p_buffer ) break;\n            FillBuffer( p_aout, i, p_buffer );\n        }\n\n        /* wake up the audio output thread */\n        SetEvent( p_aout->output.p_sys->p_notif->event );\n    }\n}", "path": "modules\\audio_output\\directx.c", "repo_name": "iparag/vlc", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 145905}
{"docstring": "/*****************************************************************************\n * Control: control facility for the vout\n *****************************************************************************/\n", "func_signal": "static int Control( vout_thread_t *p_vout, int i_query, va_list args )", "code": "{\n    switch( i_query )\n    {\n       default:\n            return vout_vaControlDefault( p_vout, i_query, args );\n    }\n}", "path": "modules\\misc\\dummy\\vout.c", "repo_name": "iparag/vlc", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 145905}
{"docstring": "/**\n * Destroy the message queues\n *\n * This functions prints all messages remaining in the queues,\n * then frees all the allocated ressources\n * No other messages interface functions should be called after this one.\n */\n", "func_signal": "void msg_Destroy (libvlc_int_t *p_libvlc)", "code": "{\n    libvlc_priv_t *priv = libvlc_priv (p_libvlc);\n\n    if( QUEUE.i_sub )\n        msg_Err( p_libvlc, \"stale interface subscribers\" );\n\n    FlushMsg( &QUEUE );\n\n#ifdef UNDER_CE\n    CloseHandle( QUEUE.logfile );\n#endif\n    /* Destroy lock */\n    vlc_mutex_destroy( &QUEUE.lock );\n    vlc_mutex_destroy( &priv->msg_bank.lock);\n}", "path": "src\\misc\\messages.c", "repo_name": "iparag/vlc", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 145905}
{"docstring": "/*****************************************************************************\n * DirectSoundThread: this thread will capture play notification events.\n *****************************************************************************\n * We use this thread to emulate a callback mechanism. The thread probes for\n * event notification and fills up the DS secondary buffer when needed.\n *****************************************************************************/\n", "func_signal": "static void* DirectSoundThread( vlc_object_t *p_this )", "code": "{\n    notification_thread_t *p_notif = (notification_thread_t*)p_this;\n    aout_instance_t *p_aout = p_notif->p_aout;\n    bool b_sleek;\n    mtime_t last_time;\n    HRESULT dsresult;\n    long l_queued = 0;\n\n    /* We don't want any resampling when using S/PDIF output */\n    b_sleek = p_aout->output.output.i_format == VLC_FOURCC('s','p','d','i');\n\n    /* Tell the main thread that we are ready */\n    vlc_thread_ready( p_notif );\n\n    msg_Dbg( p_notif, \"DirectSoundThread ready\" );\n\n    /* Wait here until Play() is called */\n    WaitForSingleObject( p_notif->event, INFINITE );\n\n    if( vlc_object_alive (p_notif) )\n    {\n        mwait( p_notif->start_date - AOUT_PTS_TOLERANCE / 2 );\n\n        /* start playing the buffer */\n        dsresult = IDirectSoundBuffer_Play( p_aout->output.p_sys->p_dsbuffer,\n                                        0,                         /* Unused */\n                                        0,                         /* Unused */\n                                        DSBPLAY_LOOPING );          /* Flags */\n        if( dsresult == DSERR_BUFFERLOST )\n        {\n            IDirectSoundBuffer_Restore( p_aout->output.p_sys->p_dsbuffer );\n            dsresult = IDirectSoundBuffer_Play(\n                                            p_aout->output.p_sys->p_dsbuffer,\n                                            0,                     /* Unused */\n                                            0,                     /* Unused */\n                                            DSBPLAY_LOOPING );      /* Flags */\n        }\n        if( dsresult != DS_OK )\n        {\n            msg_Err( p_aout, \"cannot start playing buffer\" );\n        }\n    }\n    last_time = mdate();\n\n    while( vlc_object_alive (p_notif) )\n    {\n        long l_read, l_free_slots;\n        mtime_t mtime = mdate();\n        int i;\n\n        /*\n         * Fill in as much audio data as we can in our circular buffer\n         */\n\n        /* Find out current play position */\n        if FAILED( IDirectSoundBuffer_GetCurrentPosition(\n                   p_aout->output.p_sys->p_dsbuffer, &l_read, NULL ) )\n        {\n            msg_Err( p_aout, \"GetCurrentPosition() failed!\" );\n            l_read = 0;\n        }\n\n        /* Detect underruns */\n        if( l_queued && mtime - last_time >\n            INT64_C(1000000) * l_queued / p_aout->output.output.i_rate )\n        {\n            msg_Dbg( p_aout, \"detected underrun!\" );\n        }\n        last_time = mtime;\n\n        /* Try to fill in as many frame buffers as possible */\n        l_read /= p_aout->output.output.i_bytes_per_frame;\n        l_queued = p_notif->i_write_slot * FRAME_SIZE - l_read;\n        if( l_queued < 0 ) l_queued += (FRAME_SIZE * FRAMES_NUM);\n        l_free_slots = (FRAMES_NUM * FRAME_SIZE - l_queued) / FRAME_SIZE;\n\n        for( i = 0; i < l_free_slots; i++ )\n        {\n            aout_buffer_t *p_buffer = aout_OutputNextBuffer( p_aout,\n                mtime + INT64_C(1000000) * (i * FRAME_SIZE + l_queued) /\n                p_aout->output.output.i_rate, b_sleek );\n\n            /* If there is no audio data available and we have some buffered\n             * already, then just wait for the next time */\n            if( !p_buffer && (i || l_queued / FRAME_SIZE) ) break;\n\n            if( FillBuffer( p_aout, p_notif->i_write_slot % FRAMES_NUM,\n                            p_buffer ) != VLC_SUCCESS ) break;\n        }\n\n        /* Sleep a reasonable amount of time */\n        l_queued += (i * FRAME_SIZE);\n        msleep( INT64_C(1000000) * l_queued / p_aout->output.output.i_rate / 2 );\n    }\n\n    /* make sure the buffer isn't playing */\n    IDirectSoundBuffer_Stop( p_aout->output.p_sys->p_dsbuffer );\n\n    /* free the event */\n    CloseHandle( p_notif->event );\n\n    msg_Dbg( p_notif, \"DirectSoundThread exiting\" );\n    return NULL;\n}", "path": "modules\\audio_output\\directx.c", "repo_name": "iparag/vlc", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 145905}
{"docstring": "/*****************************************************************************\n * OpenVideo: activates dummy video thread output method\n *****************************************************************************\n * This function initializes a dummy vout method.\n *****************************************************************************/\n", "func_signal": "int OpenVideo ( vlc_object_t *p_this )", "code": "{\n    vout_thread_t * p_vout = (vout_thread_t *)p_this;\n\n    p_vout->pf_init = Init;\n    p_vout->pf_end = End;\n    p_vout->pf_manage = Manage;\n    p_vout->pf_render = Render;\n    p_vout->pf_display = Display;\n    p_vout->pf_control = Control;\n\n    return VLC_SUCCESS;\n}", "path": "modules\\misc\\dummy\\vout.c", "repo_name": "iparag/vlc", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 145905}
{"docstring": "/*****************************************************************************\n * __msg_*: print a message\n *****************************************************************************\n * These functions queue a message for later printing.\n *****************************************************************************/\n", "func_signal": "void __msg_Generic( vlc_object_t *p_this, int i_type, const char *psz_module,\n                    const char *psz_format, ... )", "code": "{\n    va_list args;\n\n    va_start( args, psz_format );\n    QueueMsg( p_this, i_type, psz_module, psz_format, args );\n    va_end( args );\n}", "path": "src\\misc\\messages.c", "repo_name": "iparag/vlc", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 145905}
{"docstring": "/**\n * Flush all message queues\n */\n", "func_signal": "void msg_Flush (libvlc_int_t *p_libvlc)", "code": "{\n    libvlc_priv_t *priv = libvlc_priv (p_libvlc);\n    vlc_mutex_lock( &QUEUE.lock );\n    FlushMsg( &QUEUE );\n    vlc_mutex_unlock( &QUEUE.lock );\n}", "path": "src\\misc\\messages.c", "repo_name": "iparag/vlc", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 145905}
{"docstring": "/*****************************************************************************\n * intf_Eject: eject the CDRom\n *****************************************************************************\n * returns 0 on success\n * returns 1 on failure\n * returns -1 if not implemented\n *****************************************************************************/\n/**\n * \\brief Ejects the CD /DVD\n * \\ingroup vlc_interface\n * \\param p_this the calling vlc_object_t\n * \\param psz_device the CD/DVD to eject\n * \\return 0 on success, 1 on failure, -1 if not implemented\n */\n", "func_signal": "int __intf_Eject( vlc_object_t *p_this, const char *psz_device )", "code": "{\n    VLC_UNUSED(p_this);\n    int i_ret = VLC_SUCCESS;\n\n#ifdef __APPLE__\n    FILE *p_eject;\n    char *psz_disk;\n    char sz_cmd[32];\n\n    /*\n     * The only way to cleanly unmount the disc under MacOS X\n     * is to use the 'disktool' command line utility. It uses\n     * the non-public Disk Arbitration API, which can not be\n     * used by Cocoa or Carbon applications.\n     */\n\n    if( ( psz_disk = (char *)strstr( psz_device, \"disk\" ) ) != NULL &&\n        strlen( psz_disk ) > 4 )\n    {\n#define EJECT_CMD \"/usr/sbin/disktool -e %s 0\"\n        snprintf( sz_cmd, sizeof(sz_cmd), EJECT_CMD, psz_disk );\n#undef EJECT_CMD\n\n        if( ( p_eject = popen( sz_cmd, \"r\" ) ) != NULL )\n        {\n            char psz_result[0x200];\n            i_ret = fread( psz_result, 1, sizeof(psz_result) - 1, p_eject );\n\n            if( i_ret == 0 && ferror( p_eject ) != 0 )\n            {\n                pclose( p_eject );\n                return VLC_EGENERIC;\n            }\n\n            pclose( p_eject );\n\n            psz_result[ i_ret ] = 0;\n\n            if( strstr( psz_result, \"Disk Ejected\" ) != NULL )\n            {\n                return VLC_SUCCESS;\n            }\n        }\n    }\n\n    return VLC_EGENERIC;\n\n#elif defined(UNDER_CE)\n    msg_Warn( p_this, \"CD-Rom ejection unsupported on this platform\" );\n    return i_ret;\n\n#elif defined(WIN32)\n    MCI_OPEN_PARMS op;\n    MCI_STATUS_PARMS st;\n    DWORD i_flags;\n    char psz_drive[4];\n\n    memset( &op, 0, sizeof(MCI_OPEN_PARMS) );\n    op.lpstrDeviceType = (LPCSTR)MCI_DEVTYPE_CD_AUDIO;\n\n    strcpy( psz_drive, \"X:\" );\n    psz_drive[0] = psz_device[0];\n    op.lpstrElementName = psz_drive;\n\n    /* Set the flags for the device type */\n    i_flags = MCI_OPEN_TYPE | MCI_OPEN_TYPE_ID |\n              MCI_OPEN_ELEMENT | MCI_OPEN_SHAREABLE;\n\n    if( !mciSendCommand( 0, MCI_OPEN, i_flags, (unsigned long)&op ) )\n    {\n        st.dwItem = MCI_STATUS_READY;\n        /* Eject disc */\n        i_ret = mciSendCommand( op.wDeviceID, MCI_SET, MCI_SET_DOOR_OPEN, 0 );\n        /* Release access to the device */\n        mciSendCommand( op.wDeviceID, MCI_CLOSE, MCI_WAIT, 0 );\n    }\n    else i_ret = VLC_EGENERIC;\n\n    return i_ret;\n#else   /* WIN32 */\n\n    int i_fd;\n\n    /* This code could be extended to support CD/DVD-ROM chargers */\n\n    i_fd = open( psz_device, O_RDONLY | O_NONBLOCK );\n\n    if( i_fd == -1 )\n    {\n        msg_Err( p_this, \"could not open device %s\", psz_device );\n        return VLC_EGENERIC;\n    }\n\n#if defined(__linux__) && defined(HAVE_LINUX_VERSION_H)\n    /* Try a simple ATAPI eject */\n    i_ret = ioctl( i_fd, CDROMEJECT, 0 );\n\n    if( i_ret != 0 )\n    {\n        i_ret = EjectSCSI( i_fd );\n    }\n\n    if( i_ret != 0 )\n    {\n        msg_Err( p_this, \"could not eject %s\", psz_device );\n    }\n\n#elif defined (HAVE_DVD_H)\n    i_ret = ioctl( i_fd, CDROMEJECT, 0 );\n\n#else\n    msg_Warn( p_this, \"CD-ROM ejection unsupported on this platform\" );\n    i_ret = -1;\n\n#endif\n    close( i_fd );\n\n    return i_ret;\n#endif\n}", "path": "src\\interface\\intf_eject.c", "repo_name": "iparag/vlc", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 145905}
{"docstring": "/* Given a period code or name, return a period index (1, 2, 3 or 4)\n * and update the period pointer to the correcsponding struct.\n * If no matching code is found, return 0.\n */\n", "func_signal": "int cgit_find_stats_period(const char *expr, struct cgit_period **period)", "code": "{\n\tint i;\n\tchar code = '\\0';\n\n\tif (!expr)\n\t\treturn 0;\n\n\tif (strlen(expr) == 1)\n\t\tcode = expr[0];\n\n\tfor (i = 0; i < sizeof(periods) / sizeof(periods[0]); i++)\n\t\tif (periods[i].code == code || !strcmp(periods[i].name, expr)) {\n\t\t\tif (period)\n\t\t\t\t*period = &periods[i];\n\t\t\treturn i+1;\n\t\t}\n\treturn 0;\n}", "path": "ui-stats.c", "repo_name": "trygvis/cgit", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 644}
{"docstring": "/* Read the content of the specified file into a newly allocated buffer,\n * zeroterminate the buffer and return 0 on success, errno otherwise.\n */\n", "func_signal": "int readfile(const char *path, char **buf, size_t *size)", "code": "{\n\tint fd;\n\tstruct stat st;\n\n\tfd = open(path, O_RDONLY);\n\tif (fd == -1)\n\t\treturn errno;\n\tif (fstat(fd, &st))\n\t\treturn errno;\n\tif (!S_ISREG(st.st_mode))\n\t\treturn EISDIR;\n\t*buf = xmalloc(st.st_size + 1);\n\t*size = read_in_full(fd, *buf, st.st_size);\n\t(*buf)[*size] = '\\0';\n\treturn (*size == st.st_size ? 0 : errno);\n}", "path": "shared.c", "repo_name": "trygvis/cgit", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 644}
{"docstring": "/*\n * print a single line returned from xdiff\n */\n", "func_signal": "static void print_line(char *line, int len)", "code": "{\n\tchar *class = \"ctx\";\n\tchar c = line[len-1];\n\n\tif (line[0] == '+')\n\t\tclass = \"add\";\n\telse if (line[0] == '-')\n\t\tclass = \"del\";\n\telse if (line[0] == '@')\n\t\tclass = \"hunk\";\n\n\thtmlf(\"<div class='%s'>\", class);\n\tline[len-1] = '\\0';\n\thtml_txt(line);\n\thtml(\"</div>\");\n\tline[len-1] = c;\n}", "path": "ui-diff.c", "repo_name": "trygvis/cgit", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 644}
{"docstring": "/* Check if the slot has been modified since we opened it.\n * NB: If stat() fails, we pretend the file is modified.\n */\n", "func_signal": "static int is_modified(struct cache_slot *slot)", "code": "{\n\tstruct stat st;\n\n\tif (stat(slot->cache_name, &st))\n\t\treturn 1;\n\treturn (st.st_ino != slot->cache_st.st_ino ||\n\t\tst.st_mtime != slot->cache_st.st_mtime ||\n\t\tst.st_size != slot->cache_st.st_size);\n}", "path": "cache.c", "repo_name": "trygvis/cgit", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 644}
{"docstring": "/* Check if the slot has expired */\n", "func_signal": "static int is_expired(struct cache_slot *slot)", "code": "{\n\tif (slot->ttl < 0)\n\t\treturn 0;\n\telse\n\t\treturn slot->cache_st.st_mtime + slot->ttl*60 < time(NULL);\n}", "path": "cache.c", "repo_name": "trygvis/cgit", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 644}
{"docstring": "/* Create a lockfile used to store the generated content for a cache\n * slot, and write the slot key + \\0 into it.\n * Returns 0 on success and errno otherwise.\n */\n", "func_signal": "static int lock_slot(struct cache_slot *slot)", "code": "{\n\tslot->lock_fd = open(slot->lock_name, O_RDWR|O_CREAT|O_EXCL,\n\t\t\t     S_IRUSR|S_IWUSR);\n\tif (slot->lock_fd == -1)\n\t\treturn errno;\n\tif (xwrite(slot->lock_fd, slot->key, slot->keylen + 1) < 0)\n\t\treturn errno;\n\treturn 0;\n}", "path": "cache.c", "repo_name": "trygvis/cgit", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 644}
{"docstring": "/* Print cached content to stdout, generate the content if necessary. */\n", "func_signal": "int cache_process(int size, const char *path, const char *key, int ttl,\n\t\t  cache_fill_fn fn, void *cbdata)", "code": "{\n\tunsigned long hash;\n\tint len, i;\n\tchar filename[1024];\n\tchar lockname[1024 + 5];  /* 5 = \".lock\" */\n\tstruct cache_slot slot;\n\n\t/* If the cache is disabled, just generate the content */\n\tif (size <= 0) {\n\t\tfn(cbdata);\n\t\treturn 0;\n\t}\n\n\t/* Verify input, calculate filenames */\n\tif (!path) {\n\t\tcache_log(\"[cgit] Cache path not specified, caching is disabled\\n\");\n\t\tfn(cbdata);\n\t\treturn 0;\n\t}\n\tlen = strlen(path);\n\tif (len > sizeof(filename) - 10) { /* 10 = \"/01234567\\0\" */\n\t\tcache_log(\"[cgit] Cache path too long, caching is disabled: %s\\n\",\n\t\t\t  path);\n\t\tfn(cbdata);\n\t\treturn 0;\n\t}\n\tif (!key)\n\t\tkey = \"\";\n\thash = hash_str(key) % size;\n\tstrcpy(filename, path);\n\tif (filename[len - 1] != '/')\n\t\tfilename[len++] = '/';\n\tfor(i = 0; i < 8; i++) {\n\t\tsprintf(filename + len++, \"%x\",\n\t\t\t(unsigned char)(hash & 0xf));\n\t\thash >>= 4;\n\t}\n\tfilename[len] = '\\0';\n\tstrcpy(lockname, filename);\n\tstrcpy(lockname + len, \".lock\");\n\tslot.fn = fn;\n\tslot.cbdata = cbdata;\n\tslot.ttl = ttl;\n\tslot.cache_name = filename;\n\tslot.lock_name = lockname;\n\tslot.key = key;\n\tslot.keylen = strlen(key);\n\treturn process_slot(&slot);\n}", "path": "cache.c", "repo_name": "trygvis/cgit", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 644}
{"docstring": "/* Close an open lockfile */\n", "func_signal": "static int close_lock(struct cache_slot *slot)", "code": "{\n\tint err = 0;\n\tif (slot->lock_fd > 0) {\n\t\tif (close(slot->lock_fd))\n\t\t\terr = errno;\n\t\telse\n\t\t\tslot->lock_fd = -1;\n\t}\n\treturn err;\n}", "path": "cache.c", "repo_name": "trygvis/cgit", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 644}
{"docstring": "/* Print the content of the active cache slot (but skip the key). */\n", "func_signal": "static int print_slot(struct cache_slot *slot)", "code": "{\n\tssize_t i, j;\n\n\ti = lseek(slot->cache_fd, slot->keylen + 1, SEEK_SET);\n\tif (i != slot->keylen + 1)\n\t\treturn errno;\n\n\tdo {\n\t\ti = j = xread(slot->cache_fd, slot->buf, sizeof(slot->buf));\n\t\tif (i > 0)\n\t\t\tj = xwrite(STDOUT_FILENO, slot->buf, i);\n\t} while (i > 0 && j == i);\n\n\tif (i < 0 || j != i)\n\t\treturn errno;\n\telse\n\t\treturn 0;\n}", "path": "cache.c", "repo_name": "trygvis/cgit", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 644}
{"docstring": "/* Release the current lockfile. If `replace_old_slot` is set the\n * lockfile replaces the old cache slot, otherwise the lockfile is\n * just deleted.\n */\n", "func_signal": "static int unlock_slot(struct cache_slot *slot, int replace_old_slot)", "code": "{\n\tint err;\n\n\tif (replace_old_slot)\n\t\terr = rename(slot->lock_name, slot->cache_name);\n\telse\n\t\terr = unlink(slot->lock_name);\n\n\tif (err)\n\t\treturn errno;\n\n\treturn 0;\n}", "path": "cache.c", "repo_name": "trygvis/cgit", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 644}
{"docstring": "/* Return a strftime formatted date/time\n * NB: the result from this function is to shared memory\n */\n", "func_signal": "char *sprintftime(const char *format, time_t time)", "code": "{\n\tstatic char buf[64];\n\tstruct tm *tm;\n\n\tif (!time)\n\t\treturn NULL;\n\ttm = gmtime(&time);\n\tstrftime(buf, sizeof(buf)-1, format, tm);\n\treturn buf;\n}", "path": "cache.c", "repo_name": "trygvis/cgit", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 644}
{"docstring": "/* Generate the content for the current cache slot by redirecting\n * stdout to the lock-fd and invoking the callback function\n */\n", "func_signal": "static int fill_slot(struct cache_slot *slot)", "code": "{\n\tint tmp;\n\n\t/* Preserve stdout */\n\ttmp = dup(STDOUT_FILENO);\n\tif (tmp == -1)\n\t\treturn errno;\n\n\t/* Redirect stdout to lockfile */\n\tif (dup2(slot->lock_fd, STDOUT_FILENO) == -1)\n\t\treturn errno;\n\n\t/* Generate cache content */\n\tslot->fn(slot->cbdata);\n\n\t/* Restore stdout */\n\tif (dup2(tmp, STDOUT_FILENO) == -1)\n\t\treturn errno;\n\n\t/* Close the temporary filedescriptor */\n\tif (close(tmp))\n\t\treturn errno;\n\n\treturn 0;\n}", "path": "cache.c", "repo_name": "trygvis/cgit", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 644}
{"docstring": "/* Walk the commit DAG and collect number of commits per author per\n * timeperiod into a nested string_list collection.\n */\n", "func_signal": "struct string_list collect_stats(struct cgit_context *ctx,\n\tstruct cgit_period *period)", "code": "{\n\tstruct string_list authors;\n\tstruct rev_info rev;\n\tstruct commit *commit;\n\tconst char *argv[] = {NULL, ctx->qry.head, NULL, NULL, NULL, NULL};\n\tint argc = 3;\n\ttime_t now;\n\tlong i;\n\tstruct tm *tm;\n\tchar tmp[11];\n\n\ttime(&now);\n\ttm = gmtime(&now);\n\tperiod->trunc(tm);\n\tfor (i = 1; i < period->count; i++)\n\t\tperiod->dec(tm);\n\tstrftime(tmp, sizeof(tmp), \"%Y-%m-%d\", tm);\n\targv[2] = xstrdup(fmt(\"--since=%s\", tmp));\n\tif (ctx->qry.path) {\n\t\targv[3] = \"--\";\n\t\targv[4] = ctx->qry.path;\n\t\targc += 2;\n\t}\n\tinit_revisions(&rev, NULL);\n\trev.abbrev = DEFAULT_ABBREV;\n\trev.commit_format = CMIT_FMT_DEFAULT;\n\trev.no_merges = 1;\n\trev.verbose_header = 1;\n\trev.show_root_diff = 0;\n\tsetup_revisions(argc, argv, &rev, NULL);\n\tprepare_revision_walk(&rev);\n\tmemset(&authors, 0, sizeof(authors));\n\twhile ((commit = get_revision(&rev)) != NULL) {\n\t\tadd_commit(&authors, commit, period);\n\t\tfree(commit->buffer);\n\t\tfree_commit_list(commit->parents);\n\t}\n\treturn authors;\n}", "path": "ui-stats.c", "repo_name": "trygvis/cgit", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 644}
{"docstring": "/* Try to guess the requested revision from the requested snapshot name.\n * First the format extension is stripped, e.g. \"cgit-0.7.2.tar.gz\" become\n * \"cgit-0.7.2\". If this is a valid commit object name we've got a winner.\n * Otherwise, if the snapshot name has a prefix matching the result from\n * repo_basename(), we strip the basename and any following '-' and '_'\n * characters (\"cgit-0.7.2\" -> \"0.7.2\") and check the resulting name once\n * more. If this still isn't a valid commit object name, we check if pre-\n * pending a 'v' to the remaining snapshot name (\"0.7.2\" -> \"v0.7.2\") gives\n * us something valid.\n */\n", "func_signal": "static const char *get_ref_from_filename(const char *url, const char *filename,\n\t\t\t\t\t const struct cgit_snapshot_format *format)", "code": "{\n\tconst char *reponame;\n\tunsigned char sha1[20];\n\tchar *snapshot;\n\n\tsnapshot = xstrdup(filename);\n\tsnapshot[strlen(snapshot) - strlen(format->suffix)] = '\\0';\n\tfprintf(stderr, \"snapshot=%s\\n\", snapshot);\n\n\tif (get_sha1(snapshot, sha1) == 0)\n\t\treturn snapshot;\n\n\treponame = cgit_repobasename(url);\n\tfprintf(stderr, \"reponame=%s\\n\", reponame);\n\tif (prefixcmp(snapshot, reponame) == 0) {\n\t\tsnapshot += strlen(reponame);\n\t\twhile (snapshot && (*snapshot == '-' || *snapshot == '_'))\n\t\t\tsnapshot++;\n\t}\n\n\tif (get_sha1(snapshot, sha1) == 0)\n\t\treturn snapshot;\n\n\tsnapshot = fmt(\"v%s\", snapshot);\n\tif (get_sha1(snapshot, sha1) == 0)\n\t\treturn snapshot;\n\n\treturn NULL;\n}", "path": "ui-snapshot.c", "repo_name": "trygvis/cgit", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 644}
{"docstring": "/* Close the active cache slot */\n", "func_signal": "static int close_slot(struct cache_slot *slot)", "code": "{\n\tint err = 0;\n\tif (slot->cache_fd > 0) {\n\t\tif (close(slot->cache_fd))\n\t\t\terr = errno;\n\t\telse\n\t\t\tslot->cache_fd = -1;\n\t}\n\treturn err;\n}", "path": "cache.c", "repo_name": "trygvis/cgit", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 644}
{"docstring": "/*\n * print a single line returned from xdiff\n */\n", "func_signal": "void cgit_ssdiff_line_cb(char *line, int len)", "code": "{\n\tchar c = line[len - 1];\n\n\tline[len - 1] = '\\0';\n\n\tif (line[0] == '@') {\n\t\tcurrent_old_line = line_from_hunk(line, '-');\n\t\tcurrent_new_line = line_from_hunk(line, '+');\n\t}\n\n\tif (line[0] == ' ') {\n\t\tif (deferred_old || deferred_new)\n\t\t\tcgit_ssdiff_print_deferred_lines();\n\t\tprint_ssdiff_line(\"ctx\", current_old_line, line,\n\t\t\t\t  current_new_line, line);\n\t\tcurrent_old_line += 1;\n\t\tcurrent_new_line += 1;\n\t} else if (line[0] == '+') {\n\t\tdeferred_new_add(line, current_new_line);\n\t\tcurrent_new_line += 1;\n\t} else if (line[0] == '-') {\n\t\tdeferred_old_add(line, current_old_line);\n\t\tcurrent_old_line += 1;\n\t} else if (line[0] == '@') {\n\t\thtml(\"<tr><td colspan='4' class='hunk'>\");\n\t\thtml_txt(line);\n\t\thtml(\"</td></tr>\");\n\t} else {\n\t\thtml(\"<tr><td colspan='4' class='ctx'>\");\n\t\thtml_txt(line);\n\t\thtml(\"</td></tr>\");\n\t}\n\tline[len - 1] = c;\n}", "path": "ui-ssdiff.c", "repo_name": "trygvis/cgit", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 644}
{"docstring": "/*\n * On solaris no timegm function exists,\n * we must implement it here\n */\n", "func_signal": "time_t timegm(struct tm *t)", "code": "{\n    time_t tl, tb;\n    struct tm *tg;\n\n    tl = mktime (t);\n     if (tl == -1)\n    {\n        t->tm_hour--;\n        tl = mktime (t);\n        if (tl == -1)\n            return -1; /* can't deal with output from strptime */\n        tl += 3600;\n    }\n    tg = gmtime (&tl);\n    tg->tm_isdst = 0;\n    tb = mktime (tg);\n    if (tb == -1)\n    {\n        tg->tm_hour--;\n        tb = mktime (tg);\n        if (tb == -1)\n            return -1; /* can't deal with output from gmtime */\n        tb += 3600;\n    }\n    return (tl - (tb - tl));\n}", "path": "ui-stats.c", "repo_name": "trygvis/cgit", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 644}
{"docstring": "/* Scan 'path' for git repositories, save the resulting repolist in 'cached_rc'\n * and return 0 on success.\n */\n", "func_signal": "static int generate_cached_repolist(const char *path, const char *cached_rc)", "code": "{\n\tchar *locked_rc;\n\tint idx;\n\tFILE *f;\n\n\tlocked_rc = xstrdup(fmt(\"%s.lock\", cached_rc));\n\tf = fopen(locked_rc, \"wx\");\n\tif (!f) {\n\t\t/* Inform about the error unless the lockfile already existed,\n\t\t * since that only means we've got concurrent requests.\n\t\t */\n\t\tif (errno != EEXIST)\n\t\t\tfprintf(stderr, \"[cgit] Error opening %s: %s (%d)\\n\",\n\t\t\t\tlocked_rc, strerror(errno), errno);\n\t\treturn errno;\n\t}\n\tidx = cgit_repolist.count;\n\tscan_tree(path, repo_config);\n\tprint_repolist(f, &cgit_repolist, idx);\n\tif (rename(locked_rc, cached_rc))\n\t\tfprintf(stderr, \"[cgit] Error renaming %s to %s: %s (%d)\\n\",\n\t\t\tlocked_rc, cached_rc, strerror(errno), errno);\n\tfclose(f);\n\treturn 0;\n}", "path": "cgit.c", "repo_name": "trygvis/cgit", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 644}
{"docstring": "/* Print a message to stdout */\n", "func_signal": "void cache_log(const char *format, ...)", "code": "{\n\tva_list args;\n\tva_start(args, format);\n\tvfprintf(stderr, format, args);\n\tva_end(args);\n}", "path": "cache.c", "repo_name": "trygvis/cgit", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 644}
{"docstring": "/* Create a sorted string_list with one entry per author. The util-field\n * for each author is another string_list which is used to calculate the\n * number of commits per time-interval.\n */\n", "func_signal": "void cgit_show_stats(struct cgit_context *ctx)", "code": "{\n\tstruct string_list authors;\n\tstruct cgit_period *period;\n\tint top, i;\n\tconst char *code = \"w\";\n\n\tif (ctx->qry.period)\n\t\tcode = ctx->qry.period;\n\n\ti = cgit_find_stats_period(code, &period);\n\tif (!i) {\n\t\tcgit_print_error(fmt(\"Unknown statistics type: %c\", code));\n\t\treturn;\n\t}\n\tif (i > ctx->repo->max_stats) {\n\t\tcgit_print_error(fmt(\"Statistics type disabled: %s\",\n\t\t\t\t     period->name));\n\t\treturn;\n\t}\n\tauthors = collect_stats(ctx, period);\n\tqsort(authors.items, authors.nr, sizeof(struct string_list_item),\n\t\tcmp_total_commits);\n\n\ttop = ctx->qry.ofs;\n\tif (!top)\n\t\ttop = 10;\n\thtmlf(\"<h2>Commits per author per %s\", period->name);\n\tif (ctx->qry.path) {\n\t\thtml(\" (path '\");\n\t\thtml_txt(ctx->qry.path);\n\t\thtml(\"')\");\n\t}\n\thtml(\"</h2>\");\n\n\thtml(\"<form method='get' action='' style='float: right; text-align: right;'>\");\n\tcgit_add_hidden_formfields(1, 0, \"stats\");\n\tif (ctx->repo->max_stats > 1) {\n\t\thtml(\"Period: \");\n\t\thtml(\"<select name='period' onchange='this.form.submit();'>\");\n\t\tfor (i = 0; i < ctx->repo->max_stats; i++)\n\t\t\thtmlf(\"<option value='%c'%s>%s</option>\",\n\t\t\t\tperiods[i].code,\n\t\t\t\tperiod == &periods[i] ? \" selected\" : \"\",\n\t\t\t\tperiods[i].name);\n\t\thtml(\"</select><br/><br/>\");\n\t}\n\thtml(\"Authors: \");\n\thtml(\"\");\n\thtml(\"<select name='ofs' onchange='this.form.submit();'>\");\n\thtmlf(\"<option value='10'%s>10</option>\", top == 10 ? \" selected\" : \"\");\n\thtmlf(\"<option value='25'%s>25</option>\", top == 25 ? \" selected\" : \"\");\n\thtmlf(\"<option value='50'%s>50</option>\", top == 50 ? \" selected\" : \"\");\n\thtmlf(\"<option value='100'%s>100</option>\", top == 100 ? \" selected\" : \"\");\n\thtmlf(\"<option value='-1'%s>All</option>\", top == -1 ? \" selected\" : \"\");\n\thtml(\"</select>\");\n\thtml(\"<noscript>&nbsp;&nbsp;<input type='submit' value='Reload'/></noscript>\");\n\thtml(\"</form>\");\n\tprint_authors(&authors, top, period);\n}", "path": "ui-stats.c", "repo_name": "trygvis/cgit", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 644}
{"docstring": "/* --------------------------- memalign support -------------------------- */\n", "func_signal": "static void* internal_memalign(mstate m, size_t alignment, size_t bytes)", "code": "{\n  if (alignment <= MALLOC_ALIGNMENT)    /* Can just use malloc */\n    return internal_malloc(m, bytes);\n  if (alignment <  MIN_CHUNK_SIZE) /* must be at least a minimum chunk size */\n    alignment = MIN_CHUNK_SIZE;\n  if ((alignment & (alignment-SIZE_T_ONE)) != 0) {/* Ensure a power of 2 */\n    size_t a = MALLOC_ALIGNMENT << 1;\n    while (a < alignment) a <<= 1;\n    alignment = a;\n  }\n  \n  if (bytes >= MAX_REQUEST - alignment) {\n    if (m != 0)  { /* Test isn't needed but avoids compiler warning */\n      MALLOC_FAILURE_ACTION;\n    }\n  }\n  else {\n    size_t nb = request2size(bytes);\n    size_t req = nb + alignment + MIN_CHUNK_SIZE - CHUNK_OVERHEAD;\n    char* mem = (char*)internal_malloc(m, req);\n    if (mem != 0) {\n      void* leader = 0;\n      void* trailer = 0;\n      mchunkptr p = mem2chunk(mem);\n\n      if (PREACTION(m)) return 0;\n      if ((((size_t)(mem)) % alignment) != 0) { /* misaligned */\n        /*\n          Find an aligned spot inside chunk.  Since we need to give\n          back leading space in a chunk of at least MIN_CHUNK_SIZE, if\n          the first calculation places us at a spot with less than\n          MIN_CHUNK_SIZE leader, we can move to the next aligned spot.\n          We've allocated enough total room so that this is always\n          possible.\n        */\n        char* br = (char*)mem2chunk((size_t)(((size_t)(mem +\n                                                       alignment -\n                                                       SIZE_T_ONE)) &\n                                             -alignment));\n        char* pos = ((size_t)(br - (char*)(p)) >= MIN_CHUNK_SIZE)?\n          br : br+alignment;\n        mchunkptr newp = (mchunkptr)pos;\n        size_t leadsize = pos - (char*)(p);\n        size_t newsize = chunksize(p) - leadsize;\n\n        if (is_mmapped(p)) { /* For mmapped chunks, just adjust offset */\n          newp->prev_foot = p->prev_foot + leadsize;\n          newp->head = (newsize|CINUSE_BIT);\n        }\n        else { /* Otherwise, give back leader, use the rest */\n          set_inuse(m, newp, newsize);\n          set_inuse(m, p, leadsize);\n          leader = chunk2mem(p);\n        }\n        p = newp;\n      }\n\n      /* Give back spare room at the end */\n      if (!is_mmapped(p)) {\n        size_t size = chunksize(p);\n        if (size > nb + MIN_CHUNK_SIZE) {\n          size_t remainder_size = size - nb;\n          mchunkptr remainder = chunk_plus_offset(p, nb);\n          set_inuse(m, p, nb);\n          set_inuse(m, remainder, remainder_size);\n          trailer = chunk2mem(remainder);\n        }\n      }\n\n      assert (chunksize(p) >= nb);\n      assert((((size_t)(chunk2mem(p))) % alignment) == 0);\n      check_inuse_chunk(m, p);\n      POSTACTION(m);\n      if (leader != 0) {\n        internal_free(m, leader);\n      }\n      if (trailer != 0) {\n        internal_free(m, trailer);\n      }\n      return chunk2mem(p);\n    }\n  }\n  return 0;\n}", "path": "dlmalloc.c", "repo_name": "qiuTED/wayland", "stars": 0, "license": "None", "language": "c", "size": 256}
{"docstring": "/* default corruption action */\n", "func_signal": "static void reset_on_error(mstate m)", "code": "{\n  int i;\n  ++malloc_corruption_error_count;\n  /* Reinitialize fields to forget about all memory */\n  m->smallbins = m->treebins = 0;\n  m->dvsize = m->topsize = 0;\n  m->seg.base = 0;\n  m->seg.size = 0;\n  m->seg.next = 0;\n  m->top = m->dv = 0;\n  for (i = 0; i < NTREEBINS; ++i)\n    *treebin_at(m, i) = 0;\n  init_bins(m);\n}", "path": "dlmalloc.c", "repo_name": "qiuTED/wayland", "stars": 0, "license": "None", "language": "c", "size": 256}
{"docstring": "/* Higher-level APIs.  */\n", "func_signal": "WL_EXPORT void\nwl_surface_attach_buffer(struct wl_surface *surface,\n\t\t\t struct wl_buffer *buffer)", "code": "{\n\treturn wl_surface_attach(surface, buffer->name,\n\t\t\t\t buffer->width, buffer->height, buffer->stride);\n}", "path": "wayland-client.c", "repo_name": "qiuTED/wayland", "stars": 0, "license": "None", "language": "c", "size": 256}
{"docstring": "/* Unmap and unlink any mmapped segments that don't contain used chunks */\n", "func_signal": "static size_t release_unused_segments(mstate m)", "code": "{\n  size_t released = 0;\n  msegmentptr pred = &m->seg;\n  msegmentptr sp = pred->next;\n  while (sp != 0) {\n    char* base = sp->base;\n    size_t size = sp->size;\n    msegmentptr next = sp->next;\n    if (is_mmapped_segment(sp) && !is_extern_segment(sp)) {\n      mchunkptr p = align_as_chunk(base);\n      size_t psize = chunksize(p);\n      /* Can unmap if first chunk holds entire segment and not pinned */\n      if (!cinuse(p) && (char*)p + psize >= base + size - TOP_FOOT_SIZE) {\n        tchunkptr tp = (tchunkptr)p;\n        assert(segment_holds(sp, (char*)sp));\n        if (p == m->dv) {\n          m->dv = 0;\n          m->dvsize = 0;\n        }\n        else {\n          unlink_large_chunk(m, tp);\n        }\n        if (CALL_MUNMAP(base, size) == 0) {\n          released += size;\n          m->footprint -= size;\n          /* unlink obsoleted record */\n          sp = pred;\n          sp->next = next;\n        }\n        else { /* back out if cannot unmap */\n          insert_large_chunk(m, tp, psize);\n        }\n      }\n    }\n    pred = sp;\n    sp = next;\n  }\n  return released;\n}", "path": "dlmalloc.c", "repo_name": "qiuTED/wayland", "stars": 0, "license": "None", "language": "c", "size": 256}
{"docstring": "/* Check a tree and its subtrees.  */\n", "func_signal": "static void do_check_tree(mstate m, tchunkptr t)", "code": "{\n  tchunkptr head = 0;\n  tchunkptr u = t;\n  bindex_t tindex = t->index;\n  size_t tsize = chunksize(t);\n  bindex_t idx;\n  compute_tree_index(tsize, idx);\n  assert(tindex == idx);\n  assert(tsize >= MIN_LARGE_SIZE);\n  assert(tsize >= minsize_for_tree_index(idx));\n  assert((idx == NTREEBINS-1) || (tsize < minsize_for_tree_index((idx+1))));\n\n  do { /* traverse through chain of same-sized nodes */\n    do_check_any_chunk(m, ((mchunkptr)u));\n    assert(u->index == tindex);\n    assert(chunksize(u) == tsize);\n    assert(!cinuse(u));\n    assert(!next_pinuse(u));\n    assert(u->fd->bk == u);\n    assert(u->bk->fd == u);\n    if (u->parent == 0) {\n      assert(u->child[0] == 0);\n      assert(u->child[1] == 0);\n    }\n    else {\n      assert(head == 0); /* only one node on chain has parent */\n      head = u;\n      assert(u->parent != u);\n      assert (u->parent->child[0] == u ||\n              u->parent->child[1] == u ||\n              *((tbinptr*)(u->parent)) == u);\n      if (u->child[0] != 0) {\n        assert(u->child[0]->parent == u);\n        assert(u->child[0] != u);\n        do_check_tree(m, u->child[0]);\n      }\n      if (u->child[1] != 0) {\n        assert(u->child[1]->parent == u);\n        assert(u->child[1] != u);\n        do_check_tree(m, u->child[1]);\n      }\n      if (u->child[0] != 0 && u->child[1] != 0) {\n        assert(chunksize(u->child[0]) < chunksize(u->child[1]));\n      }\n    }\n    u = u->fd;\n  } while (u != t);\n  assert(head != 0);\n}", "path": "dlmalloc.c", "repo_name": "qiuTED/wayland", "stars": 0, "license": "None", "language": "c", "size": 256}
{"docstring": "/* allocate a large request from the best fitting chunk in a treebin */\n", "func_signal": "static void* tmalloc_large(mstate m, size_t nb)", "code": "{\n  tchunkptr v = 0;\n  size_t rsize = -nb; /* Unsigned negation */\n  tchunkptr t;\n  bindex_t idx;\n  compute_tree_index(nb, idx);\n\n  if ((t = *treebin_at(m, idx)) != 0) {\n    /* Traverse tree for this bin looking for node with size == nb */\n    size_t sizebits = nb << leftshift_for_tree_index(idx);\n    tchunkptr rst = 0;  /* The deepest untaken right subtree */\n    for (;;) {\n      tchunkptr rt;\n      size_t trem = chunksize(t) - nb;\n      if (trem < rsize) {\n        v = t;\n        if ((rsize = trem) == 0)\n          break;\n      }\n      rt = t->child[1];\n      t = t->child[(sizebits >> (SIZE_T_BITSIZE-SIZE_T_ONE)) & 1];\n      if (rt != 0 && rt != t)\n        rst = rt;\n      if (t == 0) {\n        t = rst; /* set t to least subtree holding sizes > nb */\n        break;\n      }\n      sizebits <<= 1;\n    }\n  }\n\n  if (t == 0 && v == 0) { /* set t to root of next non-empty treebin */\n    binmap_t leftbits = left_bits(idx2bit(idx)) & m->treemap;\n    if (leftbits != 0) {\n      bindex_t i;\n      binmap_t leastbit = least_bit(leftbits);\n      compute_bit2idx(leastbit, i);\n      t = *treebin_at(m, i);\n    }\n  }\n\n  while (t != 0) { /* find smallest of tree or subtree */\n    size_t trem = chunksize(t) - nb;\n    if (trem < rsize) {\n      rsize = trem;\n      v = t;\n    }\n    t = leftmost_child(t);\n  }\n\n  /*  If dv is a better fit, return 0 so malloc will use it */\n  if (v != 0 && rsize < (size_t)(m->dvsize - nb)) {\n    if (RTCHECK(ok_address(m, v))) { /* split */\n      mchunkptr r = chunk_plus_offset(v, nb);\n      assert(chunksize(v) == rsize + nb);\n      if (RTCHECK(ok_next(v, r))) {\n        unlink_large_chunk(m, v);\n        if (rsize < MIN_CHUNK_SIZE)\n          set_inuse_and_pinuse(m, v, (rsize + nb));\n        else {\n          set_size_and_pinuse_of_inuse_chunk(m, v, nb);\n          set_size_and_pinuse_of_free_chunk(r, rsize);\n          insert_chunk(m, r, rsize);\n        }\n        return chunk2mem(v);\n      }\n    }\n    CORRUPTION_ERROR_ACTION(m);\n  }\n  return 0;\n}", "path": "dlmalloc.c", "repo_name": "qiuTED/wayland", "stars": 0, "license": "None", "language": "c", "size": 256}
{"docstring": "/* allocate a small request from the best fitting chunk in a treebin */\n", "func_signal": "static void* tmalloc_small(mstate m, size_t nb)", "code": "{\n  tchunkptr t, v;\n  size_t rsize;\n  bindex_t i;\n  binmap_t leastbit = least_bit(m->treemap);\n  compute_bit2idx(leastbit, i);\n\n  v = t = *treebin_at(m, i);\n  rsize = chunksize(t) - nb;\n\n  while ((t = leftmost_child(t)) != 0) {\n    size_t trem = chunksize(t) - nb;\n    if (trem < rsize) {\n      rsize = trem;\n      v = t;\n    }\n  }\n\n  if (RTCHECK(ok_address(m, v))) {\n    mchunkptr r = chunk_plus_offset(v, nb);\n    assert(chunksize(v) == rsize + nb);\n    if (RTCHECK(ok_next(v, r))) {\n      unlink_large_chunk(m, v);\n      if (rsize < MIN_CHUNK_SIZE)\n        set_inuse_and_pinuse(m, v, (rsize + nb));\n      else {\n        set_size_and_pinuse_of_inuse_chunk(m, v, nb);\n        set_size_and_pinuse_of_free_chunk(r, rsize);\n        replace_dv(m, r, rsize);\n      }\n      return chunk2mem(v);\n    }\n  }\n\n  CORRUPTION_ERROR_ACTION(m);\n  return 0;\n}", "path": "dlmalloc.c", "repo_name": "qiuTED/wayland", "stars": 0, "license": "None", "language": "c", "size": 256}
{"docstring": "/* This function supports releasing coalesed segments */\n", "func_signal": "static int win32munmap(void* ptr, size_t size)", "code": "{\n  MEMORY_BASIC_INFORMATION minfo;\n  char* cptr = ptr;\n  while (size) {\n    if (VirtualQuery(cptr, &minfo, sizeof(minfo)) == 0)\n      return -1;\n    if (minfo.BaseAddress != cptr || minfo.AllocationBase != cptr ||\n        minfo.State != MEM_COMMIT || minfo.RegionSize > size)\n      return -1;\n    if (VirtualFree(cptr, 0, MEM_RELEASE) == 0)\n      return -1;\n    cptr += minfo.RegionSize;\n    size -= minfo.RegionSize;\n  }\n  return 0;\n}", "path": "dlmalloc.c", "repo_name": "qiuTED/wayland", "stars": 0, "license": "None", "language": "c", "size": 256}
{"docstring": "/* Check properties of top chunk */\n", "func_signal": "static void do_check_top_chunk(mstate m, mchunkptr p)", "code": "{\n  msegmentptr sp = segment_holding(m, (char*)p);\n  size_t  sz = chunksize(p);\n  assert(sp != 0);\n  assert((is_aligned(chunk2mem(p))) || (p->head == FENCEPOST_HEAD));\n  assert(ok_address(m, p));\n  assert(sz == m->topsize);\n  assert(sz > 0);\n  assert(sz == ((sp->base + sp->size) - (char*)p) - TOP_FOOT_SIZE);\n  assert(pinuse(p));\n  assert(!next_pinuse(p));\n}", "path": "dlmalloc.c", "repo_name": "qiuTED/wayland", "stars": 0, "license": "None", "language": "c", "size": 256}
{"docstring": "/* Allocate chunk and prepend remainder with chunk in successor base. */\n", "func_signal": "static void* prepend_alloc(mstate m, char* newbase, char* oldbase,\n                           size_t nb)", "code": "{\n  mchunkptr p = align_as_chunk(newbase);\n  mchunkptr oldfirst = align_as_chunk(oldbase);\n  size_t psize = (char*)oldfirst - (char*)p;\n  mchunkptr q = chunk_plus_offset(p, nb);\n  size_t qsize = psize - nb;\n  set_size_and_pinuse_of_inuse_chunk(m, p, nb);\n\n  assert((char*)oldfirst > (char*)q);\n  assert(pinuse(oldfirst));\n  assert(qsize >= MIN_CHUNK_SIZE);\n\n  /* consolidate remainder with first chunk of old base */\n  if (oldfirst == m->top) {\n    size_t tsize = m->topsize += qsize;\n    m->top = q;\n    q->head = tsize | PINUSE_BIT;\n    check_top_chunk(m, q);\n  }\n  else if (oldfirst == m->dv) {\n    size_t dsize = m->dvsize += qsize;\n    m->dv = q;\n    set_size_and_pinuse_of_free_chunk(q, dsize);\n  }\n  else {\n    if (!cinuse(oldfirst)) {\n      size_t nsize = chunksize(oldfirst);\n      unlink_chunk(m, oldfirst, nsize);\n      oldfirst = chunk_plus_offset(oldfirst, nsize);\n      qsize += nsize;\n    }\n    set_free_with_pinuse(q, qsize, oldfirst);\n    insert_chunk(m, q, qsize);\n    check_free_chunk(m, q);\n  }\n\n  check_malloced_chunk(m, chunk2mem(p), nb);\n  return chunk2mem(p);\n}", "path": "dlmalloc.c", "repo_name": "qiuTED/wayland", "stars": 0, "license": "None", "language": "c", "size": 256}
{"docstring": "/* Check properties of any chunk, whether free, inuse, mmapped etc  */\n", "func_signal": "static void do_check_any_chunk(mstate m, mchunkptr p)", "code": "{\n  assert((is_aligned(chunk2mem(p))) || (p->head == FENCEPOST_HEAD));\n  assert(ok_address(m, p));\n}", "path": "dlmalloc.c", "repo_name": "qiuTED/wayland", "stars": 0, "license": "None", "language": "c", "size": 256}
{"docstring": "/* For direct MMAP, use MEM_TOP_DOWN to minimize interference */\n", "func_signal": "static void* win32direct_mmap(size_t size)", "code": "{\n  void* ptr = VirtualAlloc(0, size, MEM_RESERVE|MEM_COMMIT|MEM_TOP_DOWN,\n                           PAGE_READWRITE);\n  return (ptr != 0)? ptr: MFAIL;\n}", "path": "dlmalloc.c", "repo_name": "qiuTED/wayland", "stars": 0, "license": "None", "language": "c", "size": 256}
{"docstring": "/* ------------------------ comalloc/coalloc support --------------------- */\n", "func_signal": "static void** ialloc(mstate m,\n                     size_t n_elements,\n                     size_t* sizes,\n                     int opts,\n                     void* chunks[])", "code": "{\n  /*\n    This provides common support for independent_X routines, handling\n    all of the combinations that can result.\n\n    The opts arg has:\n    bit 0 set if all elements are same size (using sizes[0])\n    bit 1 set if elements should be zeroed\n  */\n\n  size_t    element_size;   /* chunksize of each element, if all same */\n  size_t    contents_size;  /* total size of elements */\n  size_t    array_size;     /* request size of pointer array */\n  void*     mem;            /* malloced aggregate space */\n  mchunkptr p;              /* corresponding chunk */\n  size_t    remainder_size; /* remaining bytes while splitting */\n  void**    marray;         /* either \"chunks\" or malloced ptr array */\n  mchunkptr array_chunk;    /* chunk for malloced ptr array */\n  flag_t    was_enabled;    /* to disable mmap */\n  size_t    size;\n  size_t    i;\n\n  /* compute array length, if needed */\n  if (chunks != 0) {\n    if (n_elements == 0)\n      return chunks; /* nothing to do */\n    marray = chunks;\n    array_size = 0;\n  }\n  else {\n    /* if empty req, must still return chunk representing empty array */\n    if (n_elements == 0)\n      return (void**)internal_malloc(m, 0);\n    marray = 0;\n    array_size = request2size(n_elements * (sizeof(void*)));\n  }\n\n  /* compute total element size */\n  if (opts & 0x1) { /* all-same-size */\n    element_size = request2size(*sizes);\n    contents_size = n_elements * element_size;\n  }\n  else { /* add up all the sizes */\n    element_size = 0;\n    contents_size = 0;\n    for (i = 0; i != n_elements; ++i)\n      contents_size += request2size(sizes[i]);\n  }\n\n  size = contents_size + array_size;\n\n  /*\n     Allocate the aggregate chunk.  First disable direct-mmapping so\n     malloc won't use it, since we would not be able to later\n     free/realloc space internal to a segregated mmap region.\n  */\n  was_enabled = use_mmap(m);\n  disable_mmap(m);\n  mem = internal_malloc(m, size - CHUNK_OVERHEAD);\n  if (was_enabled)\n    enable_mmap(m);\n  if (mem == 0)\n    return 0;\n\n  if (PREACTION(m)) return 0;\n  p = mem2chunk(mem);\n  remainder_size = chunksize(p);\n\n  assert(!is_mmapped(p));\n\n  if (opts & 0x2) {       /* optionally clear the elements */\n    memset((size_t*)mem, 0, remainder_size - SIZE_T_SIZE - array_size);\n  }\n\n  /* If not provided, allocate the pointer array as final part of chunk */\n  if (marray == 0) {\n    size_t  array_chunk_size;\n    array_chunk = chunk_plus_offset(p, contents_size);\n    array_chunk_size = remainder_size - contents_size;\n    marray = (void**) (chunk2mem(array_chunk));\n    set_size_and_pinuse_of_inuse_chunk(m, array_chunk, array_chunk_size);\n    remainder_size = contents_size;\n  }\n\n  /* split out elements */\n  for (i = 0; ; ++i) {\n    marray[i] = chunk2mem(p);\n    if (i != n_elements-1) {\n      if (element_size != 0)\n        size = element_size;\n      else\n        size = request2size(sizes[i]);\n      remainder_size -= size;\n      set_size_and_pinuse_of_inuse_chunk(m, p, size);\n      p = chunk_plus_offset(p, size);\n    }\n    else { /* the final element absorbs any overallocation slop */\n      set_size_and_pinuse_of_inuse_chunk(m, p, remainder_size);\n      break;\n    }\n  }\n\n#if DEBUG\n  if (marray != chunks) {\n    /* final element must have exactly exhausted chunk */\n    if (element_size != 0) {\n      assert(remainder_size == element_size);\n    }\n    else {\n      assert(remainder_size == request2size(sizes[i]));\n    }\n    check_inuse_chunk(m, mem2chunk(marray));\n  }\n  for (i = 0; i != n_elements; ++i)\n    check_inuse_chunk(m, mem2chunk(marray[i]));\n\n#endif /* DEBUG */\n\n  POSTACTION(m);\n  return marray;\n}", "path": "dlmalloc.c", "repo_name": "qiuTED/wayland", "stars": 0, "license": "None", "language": "c", "size": 256}
{"docstring": "/*\n  mspace versions of routines are near-clones of the global\n  versions. This is not so nice but better than the alternatives.\n*/\n", "func_signal": "void* mspace_malloc(mspace msp, size_t bytes)", "code": "{\n  mstate ms = (mstate)msp;\n  if (!ok_magic(ms)) {\n    USAGE_ERROR_ACTION(ms,ms);\n    return 0;\n  }\n  if (!PREACTION(ms)) {\n    void* mem;\n    size_t nb;\n    if (bytes <= MAX_SMALL_REQUEST) {\n      bindex_t idx;\n      binmap_t smallbits;\n      nb = (bytes < MIN_REQUEST)? MIN_CHUNK_SIZE : pad_request(bytes);\n      idx = small_index(nb);\n      smallbits = ms->smallmap >> idx;\n\n      if ((smallbits & 0x3U) != 0) { /* Remainderless fit to a smallbin. */\n        mchunkptr b, p;\n        idx += ~smallbits & 1;       /* Uses next bin if idx empty */\n        b = smallbin_at(ms, idx);\n        p = b->fd;\n        assert(chunksize(p) == small_index2size(idx));\n        unlink_first_small_chunk(ms, b, p, idx);\n        set_inuse_and_pinuse(ms, p, small_index2size(idx));\n        mem = chunk2mem(p);\n        check_malloced_chunk(ms, mem, nb);\n        goto postaction;\n      }\n\n      else if (nb > ms->dvsize) {\n        if (smallbits != 0) { /* Use chunk in next nonempty smallbin */\n          mchunkptr b, p, r;\n          size_t rsize;\n          bindex_t i;\n          binmap_t leftbits = (smallbits << idx) & left_bits(idx2bit(idx));\n          binmap_t leastbit = least_bit(leftbits);\n          compute_bit2idx(leastbit, i);\n          b = smallbin_at(ms, i);\n          p = b->fd;\n          assert(chunksize(p) == small_index2size(i));\n          unlink_first_small_chunk(ms, b, p, i);\n          rsize = small_index2size(i) - nb;\n          /* Fit here cannot be remainderless if 4byte sizes */\n          if (SIZE_T_SIZE != 4 && rsize < MIN_CHUNK_SIZE)\n            set_inuse_and_pinuse(ms, p, small_index2size(i));\n          else {\n            set_size_and_pinuse_of_inuse_chunk(ms, p, nb);\n            r = chunk_plus_offset(p, nb);\n            set_size_and_pinuse_of_free_chunk(r, rsize);\n            replace_dv(ms, r, rsize);\n          }\n          mem = chunk2mem(p);\n          check_malloced_chunk(ms, mem, nb);\n          goto postaction;\n        }\n\n        else if (ms->treemap != 0 && (mem = tmalloc_small(ms, nb)) != 0) {\n          check_malloced_chunk(ms, mem, nb);\n          goto postaction;\n        }\n      }\n    }\n    else if (bytes >= MAX_REQUEST)\n      nb = MAX_SIZE_T; /* Too big to allocate. Force failure (in sys alloc) */\n    else {\n      nb = pad_request(bytes);\n      if (ms->treemap != 0 && (mem = tmalloc_large(ms, nb)) != 0) {\n        check_malloced_chunk(ms, mem, nb);\n        goto postaction;\n      }\n    }\n\n    if (nb <= ms->dvsize) {\n      size_t rsize = ms->dvsize - nb;\n      mchunkptr p = ms->dv;\n      if (rsize >= MIN_CHUNK_SIZE) { /* split dv */\n        mchunkptr r = ms->dv = chunk_plus_offset(p, nb);\n        ms->dvsize = rsize;\n        set_size_and_pinuse_of_free_chunk(r, rsize);\n        set_size_and_pinuse_of_inuse_chunk(ms, p, nb);\n      }\n      else { /* exhaust dv */\n        size_t dvs = ms->dvsize;\n        ms->dvsize = 0;\n        ms->dv = 0;\n        set_inuse_and_pinuse(ms, p, dvs);\n      }\n      mem = chunk2mem(p);\n      check_malloced_chunk(ms, mem, nb);\n      goto postaction;\n    }\n\n    else if (nb < ms->topsize) { /* Split top */\n      size_t rsize = ms->topsize -= nb;\n      mchunkptr p = ms->top;\n      mchunkptr r = ms->top = chunk_plus_offset(p, nb);\n      r->head = rsize | PINUSE_BIT;\n      set_size_and_pinuse_of_inuse_chunk(ms, p, nb);\n      mem = chunk2mem(p);\n      check_top_chunk(ms, ms->top);\n      check_malloced_chunk(ms, mem, nb);\n      goto postaction;\n    }\n\n    mem = sys_alloc(ms, nb);\n\n  postaction:\n    POSTACTION(ms);\n    return mem;\n  }\n\n  return 0;\n}", "path": "dlmalloc.c", "repo_name": "qiuTED/wayland", "stars": 0, "license": "None", "language": "c", "size": 256}
{"docstring": "/* !NO_MALLINFO */\n", "func_signal": "static void internal_malloc_stats(mstate m)", "code": "{\n  if (!PREACTION(m)) {\n    size_t maxfp = 0;\n    size_t fp = 0;\n    size_t used = 0;\n    check_malloc_state(m);\n    if (is_initialized(m)) {\n      msegmentptr s = &m->seg;\n      maxfp = m->max_footprint;\n      fp = m->footprint;\n      used = fp - (m->topsize + TOP_FOOT_SIZE);\n\n      while (s != 0) {\n        mchunkptr q = align_as_chunk(s->base);\n        while (segment_holds(s, q) &&\n               q != m->top && q->head != FENCEPOST_HEAD) {\n          if (!cinuse(q))\n            used -= chunksize(q);\n          q = next_chunk(q);\n        }\n        s = s->next;\n      }\n    }\n\n    fprintf(stderr, \"max system bytes = %10lu\\n\", (unsigned long)(maxfp));\n    fprintf(stderr, \"system bytes     = %10lu\\n\", (unsigned long)(fp));\n    fprintf(stderr, \"in use bytes     = %10lu\\n\", (unsigned long)(used));\n\n    POSTACTION(m);\n  }\n}", "path": "dlmalloc.c", "repo_name": "qiuTED/wayland", "stars": 0, "license": "None", "language": "c", "size": 256}
{"docstring": "/* Return true if segment contains a segment link */\n", "func_signal": "static int has_segment_link(mstate m, msegmentptr ss)", "code": "{\n  msegmentptr sp = &m->seg;\n  for (;;) {\n    if ((char*)sp >= ss->base && (char*)sp < ss->base + ss->size)\n      return 1;\n    if ((sp = sp->next) == 0)\n      return 0;\n  }\n}", "path": "dlmalloc.c", "repo_name": "qiuTED/wayland", "stars": 0, "license": "None", "language": "c", "size": 256}
{"docstring": "/* --------------------------- realloc support --------------------------- */\n", "func_signal": "static void* internal_realloc(mstate m, void* oldmem, size_t bytes)", "code": "{\n  if (bytes >= MAX_REQUEST) {\n    MALLOC_FAILURE_ACTION;\n    return 0;\n  }\n  if (!PREACTION(m)) {\n    mchunkptr oldp = mem2chunk(oldmem);\n    size_t oldsize = chunksize(oldp);\n    mchunkptr next = chunk_plus_offset(oldp, oldsize);\n    mchunkptr newp = 0;\n    void* extra = 0;\n\n    /* Try to either shrink or extend into top. Else malloc-copy-free */\n\n    if (RTCHECK(ok_address(m, oldp) && ok_cinuse(oldp) &&\n                ok_next(oldp, next) && ok_pinuse(next))) {\n      size_t nb = request2size(bytes);\n      if (is_mmapped(oldp))\n        newp = mmap_resize(m, oldp, nb);\n      else if (oldsize >= nb) { /* already big enough */\n        size_t rsize = oldsize - nb;\n        newp = oldp;\n        if (rsize >= MIN_CHUNK_SIZE) {\n          mchunkptr remainder = chunk_plus_offset(newp, nb);\n          set_inuse(m, newp, nb);\n          set_inuse(m, remainder, rsize);\n          extra = chunk2mem(remainder);\n        }\n      }\n      else if (next == m->top && oldsize + m->topsize > nb) {\n        /* Expand into top */\n        size_t newsize = oldsize + m->topsize;\n        size_t newtopsize = newsize - nb;\n        mchunkptr newtop = chunk_plus_offset(oldp, nb);\n        set_inuse(m, oldp, nb);\n        newtop->head = newtopsize |PINUSE_BIT;\n        m->top = newtop;\n        m->topsize = newtopsize;\n        newp = oldp;\n      }\n    }\n    else {\n      USAGE_ERROR_ACTION(m, oldmem);\n      POSTACTION(m);\n      return 0;\n    }\n\n    POSTACTION(m);\n\n    if (newp != 0) {\n      if (extra != 0) {\n        internal_free(m, extra);\n      }\n      check_inuse_chunk(m, newp);\n      return chunk2mem(newp);\n    }\n    else {\n      void* newmem = internal_malloc(m, bytes);\n      if (newmem != 0) {\n        size_t oc = oldsize - overhead_for(oldp);\n        memcpy(newmem, oldmem, (oc < bytes)? oc : bytes);\n        internal_free(m, oldmem);\n      }\n      return newmem;\n    }\n  }\n  return 0;\n}", "path": "dlmalloc.c", "repo_name": "qiuTED/wayland", "stars": 0, "license": "None", "language": "c", "size": 256}
{"docstring": "/* Win32 MMAP via VirtualAlloc */\n", "func_signal": "static void* win32mmap(size_t size)", "code": "{\n  void* ptr = VirtualAlloc(0, size, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);\n  return (ptr != 0)? ptr: MFAIL;\n}", "path": "dlmalloc.c", "repo_name": "qiuTED/wayland", "stars": 0, "license": "None", "language": "c", "size": 256}
{"docstring": "/*  Check all the chunks in a smallbin.  */\n", "func_signal": "static void do_check_smallbin(mstate m, bindex_t i)", "code": "{\n  sbinptr b = smallbin_at(m, i);\n  mchunkptr p = b->bk;\n  unsigned int empty = (m->smallmap & (1U << i)) == 0;\n  if (p == b)\n    assert(empty);\n  if (!empty) {\n    for (; p != b; p = p->bk) {\n      size_t size = chunksize(p);\n      mchunkptr q;\n      /* each chunk claims to be free */\n      do_check_free_chunk(m, p);\n      /* chunk belongs in bin */\n      assert(small_index(size) == i);\n      assert(p->bk == b || chunksize(p->bk) == chunksize(p));\n      /* chunk is followed by an inuse chunk */\n      q = next_chunk(p);\n      if (q->head != FENCEPOST_HEAD)\n        do_check_inuse_chunk(m, q);\n    }\n  }\n}", "path": "dlmalloc.c", "repo_name": "qiuTED/wayland", "stars": 0, "license": "None", "language": "c", "size": 256}
{"docstring": "/* TODO: this is inefficient, it marshals data repeatedly!  */\n", "func_signal": "WL_EXPORT void\nwl_display_vsend_event(struct wl_display *display, struct wl_object *sender,\n\t\t       uint32_t opcode, va_list va)", "code": "{\n\tstruct wl_client *client;\n\n\tclient = container_of(display->client_list.next,\n\t\t\t      struct wl_client, link);\n\twhile (&client->link != &display->client_list) {\n\t\tva_list va2;\n\t\tva_copy (va2, va);\n\t\twl_connection_vmarshal(client->connection, &display->objects,\n\t\t\t\t       sender->id, opcode,\n\t\t\t\t       sender->interface->events[opcode].arguments,\n\t\t\t\t       va2);\n\n\t\tclient = container_of(client->link.next,\n\t\t\t\t   struct wl_client, link);\n\t}\n}", "path": "wayland.c", "repo_name": "qiuTED/wayland", "stars": 0, "license": "None", "language": "c", "size": 256}
{"docstring": "/*\n * call-seq: disable_stdio_buffering\n *\n * Disables any kind of buffering on the C +stdout+ and +stderr+ variables,\n * so that +fprintf()+ on +stdout+ and +stderr+ have immediate effect.\n */\n", "func_signal": "static VALUE\ndisable_stdio_buffering()", "code": "{\n\tsetvbuf(stdout, NULL, _IONBF, 0);\n\tsetvbuf(stderr, NULL, _IONBF, 0);\n\treturn Qnil;\n}", "path": "debian\\passenger\\ext\\phusion_passenger\\native_support.c", "repo_name": "colin/nginx", "stars": 1, "license": "other", "language": "c", "size": 2489}
{"docstring": "/*\n * find the middle queue element if the queue has odd number of elements\n * or the first element of the queue's second part otherwise\n */\n", "func_signal": "ngx_queue_t *\nngx_queue_middle(ngx_queue_t *queue)", "code": "{\n    ngx_queue_t  *middle, *next;\n\n    middle = ngx_queue_head(queue);\n\n    if (middle == ngx_queue_last(queue)) {\n        return middle;\n    }\n\n    next = ngx_queue_head(queue);\n\n    for ( ;; ) {\n        middle = ngx_queue_next(middle);\n\n        next = ngx_queue_next(next);\n\n        if (next == ngx_queue_last(queue)) {\n            return middle;\n        }\n\n        next = ngx_queue_next(next);\n\n        if (next == ngx_queue_last(queue)) {\n            return middle;\n        }\n    }\n}", "path": "src\\core\\ngx_queue.c", "repo_name": "colin/nginx", "stars": 1, "license": "other", "language": "c", "size": 2489}
{"docstring": "/*\n * on completion ngx_http_read_client_request_body() adds to\n * r->request_body->bufs one or two bufs:\n *    *) one memory buf that was preread in r->header_in;\n *    *) one memory or file buf that contains the rest of the body\n */\n", "func_signal": "ngx_int_t\nngx_http_read_client_request_body(ngx_http_request_t *r,\n    ngx_http_client_body_handler_pt post_handler)", "code": "{\n    size_t                     preread;\n    ssize_t                    size;\n    ngx_buf_t                 *b;\n    ngx_chain_t               *cl, **next;\n    ngx_temp_file_t           *tf;\n    ngx_http_request_body_t   *rb;\n    ngx_http_core_loc_conf_t  *clcf;\n\n    if (r->request_body || r->discard_body) {\n        post_handler(r);\n        return NGX_OK;\n    }\n\n    if (ngx_http_test_expect(r) != NGX_OK) {\n        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    rb = ngx_pcalloc(r->pool, sizeof(ngx_http_request_body_t));\n    if (rb == NULL) {\n        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    r->request_body = rb;\n\n    if (r->headers_in.content_length_n < 0) {\n        post_handler(r);\n        return NGX_OK;\n    }\n\n    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n\n    if (r->headers_in.content_length_n == 0) {\n\n        if (r->request_body_in_file_only) {\n            tf = ngx_pcalloc(r->pool, sizeof(ngx_temp_file_t));\n            if (tf == NULL) {\n                return NGX_HTTP_INTERNAL_SERVER_ERROR;\n            }\n\n            tf->file.fd = NGX_INVALID_FILE;\n            tf->file.log = r->connection->log;\n            tf->path = clcf->client_body_temp_path;\n            tf->pool = r->pool;\n            tf->warn = \"a client request body is buffered to a temporary file\";\n            tf->log_level = r->request_body_file_log_level;\n            tf->persistent = r->request_body_in_persistent_file;\n            tf->clean = r->request_body_in_clean_file;\n\n            if (r->request_body_file_group_access) {\n                tf->access = 0660;\n            }\n\n            rb->temp_file = tf;\n\n            if (ngx_create_temp_file(&tf->file, tf->path, tf->pool,\n                                     tf->persistent, tf->clean, tf->access)\n                != NGX_OK)\n            {\n                return NGX_HTTP_INTERNAL_SERVER_ERROR;\n            }\n        }\n\n        post_handler(r);\n\n        return NGX_OK;\n    }\n\n    rb->post_handler = post_handler;\n\n    /*\n     * set by ngx_pcalloc():\n     *\n     *     rb->bufs = NULL;\n     *     rb->buf = NULL;\n     *     rb->rest = 0;\n     */\n\n    preread = r->header_in->last - r->header_in->pos;\n\n    if (preread) {\n\n        /* there is the pre-read part of the request body */\n\n        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                       \"http client request body preread %uz\", preread);\n\n        b = ngx_calloc_buf(r->pool);\n        if (b == NULL) {\n            return NGX_HTTP_INTERNAL_SERVER_ERROR;\n        }\n\n        b->temporary = 1;\n        b->start = r->header_in->pos;\n        b->pos = r->header_in->pos;\n        b->last = r->header_in->last;\n        b->end = r->header_in->end;\n\n        rb->bufs = ngx_alloc_chain_link(r->pool);\n        if (rb->bufs == NULL) {\n            return NGX_HTTP_INTERNAL_SERVER_ERROR;\n        }\n\n        rb->bufs->buf = b;\n        rb->bufs->next = NULL;\n\n        rb->buf = b;\n\n        if ((off_t) preread >= r->headers_in.content_length_n) {\n\n            /* the whole request body was pre-read */\n\n            r->header_in->pos += (size_t) r->headers_in.content_length_n;\n            r->request_length += r->headers_in.content_length_n;\n\n            if (r->request_body_in_file_only) {\n                if (ngx_http_write_request_body(r, rb->bufs) != NGX_OK) {\n                    return NGX_HTTP_INTERNAL_SERVER_ERROR;\n                }\n            }\n\n            post_handler(r);\n\n            return NGX_OK;\n        }\n\n        /*\n         * to not consider the body as pipelined request in\n         * ngx_http_set_keepalive()\n         */\n        r->header_in->pos = r->header_in->last;\n\n        r->request_length += preread;\n\n        rb->rest = r->headers_in.content_length_n - preread;\n\n        if (rb->rest <= (off_t) (b->end - b->last)) {\n\n            /* the whole request body may be placed in r->header_in */\n\n            rb->to_write = rb->bufs;\n\n            r->read_event_handler = ngx_http_read_client_request_body_handler;\n\n            return ngx_http_do_read_client_request_body(r);\n        }\n\n        next = &rb->bufs->next;\n\n    } else {\n        b = NULL;\n        rb->rest = r->headers_in.content_length_n;\n        next = &rb->bufs;\n    }\n\n    size = clcf->client_body_buffer_size;\n    size += size >> 2;\n\n    if (rb->rest < size) {\n        size = (ssize_t) rb->rest;\n\n        if (r->request_body_in_single_buf) {\n            size += preread;\n        }\n\n    } else {\n        size = clcf->client_body_buffer_size;\n\n        /* disable copying buffer for r->request_body_in_single_buf */\n        b = NULL;\n    }\n\n    rb->buf = ngx_create_temp_buf(r->pool, size);\n    if (rb->buf == NULL) {\n        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    cl = ngx_alloc_chain_link(r->pool);\n    if (cl == NULL) {\n        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    cl->buf = rb->buf;\n    cl->next = NULL;\n\n    if (b && r->request_body_in_single_buf) {\n        size = b->last - b->pos;\n        ngx_memcpy(rb->buf->pos, b->pos, size);\n        rb->buf->last += size;\n\n        next = &rb->bufs;\n    }\n\n    *next = cl;\n\n    if (r->request_body_in_file_only || r->request_body_in_single_buf) {\n        rb->to_write = rb->bufs;\n\n    } else {\n        rb->to_write = rb->bufs->next ? rb->bufs->next : rb->bufs;\n    }\n\n    r->read_event_handler = ngx_http_read_client_request_body_handler;\n\n    return ngx_http_do_read_client_request_body(r);\n}", "path": "src\\http\\ngx_http_request_body.c", "repo_name": "colin/nginx", "stars": 1, "license": "other", "language": "c", "size": 2489}
{"docstring": "/*\n * call-seq: close_all_file_descriptors(exceptions)\n *\n * Close all file descriptors, except those given in the +exceptions+ array.\n * For example, the following would close all file descriptors except standard\n * input (0) and standard output (1).\n *\n *  close_all_file_descriptors([0, 1])\n */\n", "func_signal": "static VALUE\nclose_all_file_descriptors(VALUE self, VALUE exceptions)", "code": "{\n\tlong i, j;\n\t\n\tfor (i = sysconf(_SC_OPEN_MAX) - 1; i >= 0; i--) {\n\t\tint is_exception = 0;\n\t\tfor (j = 0; j < RARRAY_LEN(exceptions) && !is_exception; j++) {\n\t\t\tlong fd = NUM2INT(rb_ary_entry(exceptions, j));\n\t\t\tis_exception = i == fd;\n\t\t}\n\t\tif (!is_exception) {\n\t\t\tclose(i);\n\t\t}\n\t}\n\treturn Qnil;\n}", "path": "debian\\passenger\\ext\\phusion_passenger\\native_support.c", "repo_name": "colin/nginx", "stars": 1, "license": "other", "language": "c", "size": 2489}
{"docstring": "/* Linux strerror_r() */\n", "func_signal": "u_char *\nngx_strerror_r(int err, u_char *errstr, size_t size)", "code": "{\n    char  *str;\n\n    if (size == 0) {\n        return errstr;\n    }\n\n    errstr[0] = '\\0';\n\n    str = strerror_r(err, (char *) errstr, size);\n\n    if (str != (char *) errstr) {\n        return ngx_cpystrn(errstr, (u_char *) str, size);\n    }\n\n    while (*errstr && size) {\n        errstr++;\n        size--;\n    }\n\n    return errstr;\n}", "path": "src\\os\\unix\\ngx_errno.c", "repo_name": "colin/nginx", "stars": 1, "license": "other", "language": "c", "size": 2489}
{"docstring": "/* AF_INET only */\n", "func_signal": "static ngx_int_t\nngx_http_geo_cidr_variable(ngx_http_request_t *r, ngx_http_variable_value_t *v,\n    uintptr_t data)", "code": "{\n    ngx_http_geo_ctx_t *ctx = (ngx_http_geo_ctx_t *) data;\n\n    ngx_http_variable_value_t  *vv;\n\n    vv = (ngx_http_variable_value_t *)\n              ngx_radix32tree_find(ctx->u.tree, ngx_http_geo_addr(r, ctx));\n\n    *v = *vv;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"http geo: %v\", v);\n\n    return NGX_OK;\n}", "path": "src\\http\\modules\\ngx_http_geo_module.c", "repo_name": "colin/nginx", "stars": 1, "license": "other", "language": "c", "size": 2489}
{"docstring": "/* TODO: warn about duplicate indices */\n", "func_signal": "static char *\nngx_http_index_set_index(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)", "code": "{\n    ngx_http_index_loc_conf_t *ilcf = conf;\n\n    ngx_str_t                  *value;\n    ngx_uint_t                  i, n;\n    ngx_http_index_t           *index;\n    ngx_http_script_compile_t   sc;\n\n    if (ilcf->indices == NULL) {\n        ilcf->indices = ngx_array_create(cf->pool, 2, sizeof(ngx_http_index_t));\n        if (ilcf->indices == NULL) {\n            return NGX_CONF_ERROR;\n        }\n    }\n\n    value = cf->args->elts;\n\n    for (i = 1; i < cf->args->nelts; i++) {\n\n        if (value[i].data[0] == '/' && i != cf->args->nelts - 1) {\n            ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n                               \"only the last index in \\\"index\\\" directive \"\n                               \"should be absolute\");\n        }\n\n        if (value[i].len == 0) {\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                               \"index \\\"%V\\\" in \\\"index\\\" directive is invalid\",\n                               &value[1]);\n            return NGX_CONF_ERROR;\n        }\n\n        index = ngx_array_push(ilcf->indices);\n        if (index == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        index->name.len = value[i].len;\n        index->name.data = value[i].data;\n        index->lengths = NULL;\n        index->values = NULL;\n\n        n = ngx_http_script_variables_count(&value[i]);\n\n        if (n == 0) {\n            if (ilcf->max_index_len < index->name.len) {\n                ilcf->max_index_len = index->name.len;\n            }\n\n            if (index->name.data[0] == '/') {\n                continue;\n            }\n\n            /* include the terminating '\\0' to the length to use ngx_memcpy() */\n            index->name.len++;\n\n            continue;\n        }\n\n        ngx_memzero(&sc, sizeof(ngx_http_script_compile_t));\n\n        sc.cf = cf;\n        sc.source = &value[i];\n        sc.lengths = &index->lengths;\n        sc.values = &index->values;\n        sc.variables = n;\n        sc.complete_lengths = 1;\n        sc.complete_values = 1;\n\n        if (ngx_http_script_compile(&sc) != NGX_OK) {\n            return NGX_CONF_ERROR;\n        }\n    }\n\n    return NGX_CONF_OK;\n}", "path": "src\\http\\modules\\ngx_http_index_module.c", "repo_name": "colin/nginx", "stars": 1, "license": "other", "language": "c", "size": 2489}
{"docstring": "/*\nremoves the expired node from the upload rbtree\n*/\n", "func_signal": "static void\nngx_http_uploadprogress_cleanup(void *data)", "code": "{\n    ngx_http_uploadprogress_cleanup_t *upcln = data;\n    ngx_slab_pool_t                 *shpool;\n    ngx_rbtree_node_t               *node;\n    ngx_http_uploadprogress_ctx_t   *ctx;\n    ngx_http_uploadprogress_node_t  *up;\n    ngx_http_request_t              *r;\n\n    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, upcln->shm_zone->shm.log, 0,\n                   \"uploadprogress cleanup called\");\n\n    ctx = upcln->shm_zone->data;\n    shpool = (ngx_slab_pool_t *) upcln->shm_zone->shm.addr;\n    node = upcln->node;\n    r = upcln->r;\n    up = (ngx_http_uploadprogress_node_t *) node;\n\n    ngx_shmtx_lock(&shpool->mutex);\n    \n    up->done = 1;               /* mark the original request as done */\n    up->timeout = ngx_time() + upcln->timeout;      /* keep tracking for 60s */\n    \n    if (r != NULL ) {\n        ngx_uint_t rc = r->err_status ? r->err_status : r->headers_out.status;\n        if (rc >= NGX_HTTP_SPECIAL_RESPONSE) {\n            up->err_status = rc;\n        }\n    }\n    \n    ngx_shmtx_unlock(&shpool->mutex);\n\n    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, upcln->shm_zone->shm.log, 0,\n                   \"uploadprogress cleanup: connection %08XD to be deleted at %T\",\n                   node->key, up->timeout);\n\n}", "path": "debian\\upload-progress\\ngx_http_uploadprogress_module.c", "repo_name": "colin/nginx", "stars": 1, "license": "other", "language": "c", "size": 2489}
{"docstring": "/*\n * NGX_OK       - exact match\n * NGX_DONE     - auto redirect\n * NGX_AGAIN    - inclusive match\n * NGX_DECLINED - no match\n */\n", "func_signal": "static ngx_int_t\nngx_http_core_find_static_location(ngx_http_request_t *r,\n    ngx_http_location_tree_node_t *node)", "code": "{\n    u_char     *uri;\n    size_t      len, n;\n    ngx_int_t   rc, rv;\n\n    len = r->uri.len;\n    uri = r->uri.data;\n\n    rv = NGX_DECLINED;\n\n    for ( ;; ) {\n\n        if (node == NULL) {\n            return rv;\n        }\n\n        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                       \"test location: \\\"%*s\\\"\", node->len, node->name);\n\n        n = (len <= (size_t) node->len) ? len : node->len;\n\n        rc = ngx_filename_cmp(uri, node->name, n);\n\n        if (rc != 0) {\n            node = (rc < 0) ? node->left : node->right;\n\n            continue;\n        }\n\n        if (len > (size_t) node->len) {\n\n            if (node->inclusive) {\n\n                r->loc_conf = node->inclusive->loc_conf;\n                rv = NGX_AGAIN;\n\n                node = node->tree;\n                uri += n;\n                len -= n;\n\n                continue;\n            }\n\n            /* exact only */\n\n            node = node->right;\n\n            continue;\n        }\n\n        if (len == (size_t) node->len) {\n\n            r->loc_conf = (node->exact) ? node->exact->loc_conf:\n                                          node->inclusive->loc_conf;\n            return NGX_OK;\n        }\n\n        /* len < node->len */\n\n        if (len + 1 == (size_t) node->len && node->auto_redirect) {\n\n            r->loc_conf = (node->exact) ? node->exact->loc_conf:\n                                          node->inclusive->loc_conf;\n            rv = NGX_DONE;\n        }\n\n        node = node->left;\n    }\n}", "path": "src\\http\\ngx_http_core_module.c", "repo_name": "colin/nginx", "stars": 1, "license": "other", "language": "c", "size": 2489}
{"docstring": "/* the add procedure is optimized to add a growing up sequence */\n", "func_signal": "static char *\nngx_http_geo_add_range(ngx_conf_t *cf, ngx_http_geo_conf_ctx_t *ctx,\n    in_addr_t start, in_addr_t end)", "code": "{\n    in_addr_t              n;\n    ngx_uint_t             h, i, s, e;\n    ngx_array_t           *a;\n    ngx_http_geo_range_t  *range;\n\n    for (n = start; n <= end; n += 0x10000) {\n\n        h = n >> 16;\n\n        if (n == start) {\n            s = n & 0xffff;\n        } else {\n            s = 0;\n        }\n\n        if ((n | 0xffff) > end) {\n            e = end & 0xffff;\n\n        } else {\n            e = 0xffff;\n        }\n\n        a = (ngx_array_t *) ctx->high->low[h].ranges;\n\n        if (a == NULL) {\n            a = ngx_array_create(ctx->temp_pool, 64,\n                                 sizeof(ngx_http_geo_range_t));\n            if (a == NULL) {\n                return NGX_CONF_ERROR;\n            }\n\n            ctx->high->low[h].ranges = (ngx_http_geo_range_t *) a;\n        }\n\n        i = a->nelts;\n        range = a->elts;\n\n        while (i) {\n\n            i--;\n\n            if (e < (ngx_uint_t) range[i].start) {\n                continue;\n            }\n\n            if (s > (ngx_uint_t) range[i].end) {\n\n                /* add after the range */\n\n                range = ngx_array_push(a);\n                if (range == NULL) {\n                    return NGX_CONF_ERROR;\n                }\n\n                range = a->elts;\n\n                ngx_memcpy(&range[i + 2], &range[i + 1],\n                           (a->nelts - 2 - i) * sizeof(ngx_http_geo_range_t));\n\n                range[i + 1].start = (u_short) s;\n                range[i + 1].end = (u_short) e;\n                range[i + 1].value = ctx->value;\n\n                goto next;\n            }\n\n            if (s == (ngx_uint_t) range[i].start\n                && e == (ngx_uint_t) range[i].end)\n            {\n                ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n                    \"duplicate range \\\"%V\\\", value: \\\"%v\\\", old value: \\\"%v\\\"\",\n                    ctx->net, ctx->value, range[i].value);\n\n                range[i].value = ctx->value;\n\n                goto next;\n            }\n\n            if (s > (ngx_uint_t) range[i].start\n                && e < (ngx_uint_t) range[i].end)\n            {\n                /* split the range and insert the new one */\n\n                range = ngx_array_push(a);\n                if (range == NULL) {\n                    return NGX_CONF_ERROR;\n                }\n\n                range = ngx_array_push(a);\n                if (range == NULL) {\n                    return NGX_CONF_ERROR;\n                }\n\n                range = a->elts;\n\n                ngx_memcpy(&range[i + 3], &range[i + 1],\n                           (a->nelts - 3 - i) * sizeof(ngx_http_geo_range_t));\n\n                range[i + 2].start = (u_short) (e + 1);\n                range[i + 2].end = range[i].end;\n                range[i + 2].value = range[i].value;\n\n                range[i + 1].start = (u_short) s;\n                range[i + 1].end = (u_short) e;\n                range[i + 1].value = ctx->value;\n\n                range[i].end = (u_short) (s - 1);\n\n                goto next;\n            }\n\n            if (s == (ngx_uint_t) range[i].start\n                && e < (ngx_uint_t) range[i].end)\n            {\n                /* shift the range start and insert the new range */\n\n                range = ngx_array_push(a);\n                if (range == NULL) {\n                    return NGX_CONF_ERROR;\n                }\n\n                range = a->elts;\n\n                ngx_memcpy(&range[i + 1], &range[i],\n                           (a->nelts - 1 - i) * sizeof(ngx_http_geo_range_t));\n\n                range[i + 1].start = (u_short) (e + 1);\n\n                range[i].start = (u_short) s;\n                range[i].end = (u_short) e;\n                range[i].value = ctx->value;\n\n                goto next;\n            }\n\n            if (s > (ngx_uint_t) range[i].start\n                && e == (ngx_uint_t) range[i].end)\n            {\n                /* shift the range end and insert the new range */\n\n                range = ngx_array_push(a);\n                if (range == NULL) {\n                    return NGX_CONF_ERROR;\n                }\n\n                range = a->elts;\n\n                ngx_memcpy(&range[i + 2], &range[i + 1],\n                           (a->nelts - 2 - i) * sizeof(ngx_http_geo_range_t));\n\n                range[i + 1].start = (u_short) s;\n                range[i + 1].end = (u_short) e;\n                range[i + 1].value = ctx->value;\n\n                range[i].end = (u_short) (s - 1);\n\n                goto next;\n            }\n\n            s = (ngx_uint_t) range[i].start;\n            e = (ngx_uint_t) range[i].end;\n\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                         \"range \\\"%V\\\" overlaps \\\"%d.%d.%d.%d-%d.%d.%d.%d\\\"\",\n                         ctx->net,\n                         h >> 8, h & 0xff, s >> 8, s & 0xff,\n                         h >> 8, h & 0xff, e >> 8, e & 0xff);\n\n            return NGX_CONF_ERROR;\n        }\n\n        /* add the first range */\n\n        range = ngx_array_push(a);\n        if (range == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        range->start = (u_short) s;\n        range->end = (u_short) e;\n        range->value = ctx->value;\n\n    next:\n\n        continue;\n    }\n\n    return NGX_CONF_OK;\n}", "path": "src\\http\\modules\\ngx_http_geo_module.c", "repo_name": "colin/nginx", "stars": 1, "license": "other", "language": "c", "size": 2489}
{"docstring": "/*\n * NGX_OK:     the busy lock is held\n * NGX_AGAIN:  the all busy locks are held but we will wait the specified time\n * NGX_BUSY:   ctx->timer == 0: there are many the busy locks\n *             ctx->timer != 0: there are many the waiting locks\n */\n", "func_signal": "ngx_int_t\nngx_event_busy_lock(ngx_event_busy_lock_t *bl, ngx_event_busy_lock_ctx_t *ctx)", "code": "{\n    ngx_int_t  rc;\n\n    ngx_mutex_lock(bl->mutex);\n\n    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ctx->event->log, 0,\n                   \"event busy lock: b:%d mb:%d\",\n                   bl->busy, bl->max_busy);\n\n    if (bl->busy < bl->max_busy) {\n        bl->busy++;\n\n        rc = NGX_OK;\n\n    } else if (ctx->timer && bl->waiting < bl->max_waiting) {\n        bl->waiting++;\n        ngx_add_timer(ctx->event, ctx->timer);\n        ctx->event->handler = ngx_event_busy_lock_handler;\n\n        if (bl->events) {\n            bl->last->next = ctx;\n\n        } else {\n            bl->events = ctx;\n        }\n\n        bl->last = ctx;\n\n        rc = NGX_AGAIN;\n\n    } else {\n        rc = NGX_BUSY;\n    }\n\n    ngx_mutex_unlock(bl->mutex);\n\n    return rc;\n}", "path": "src\\event\\ngx_event_busy_lock.c", "repo_name": "colin/nginx", "stars": 1, "license": "other", "language": "c", "size": 2489}
{"docstring": "/*\n * call-seq: recv_fd(socket_fd)\n *\n * Receive a file descriptor from the given Unix socket. Returns the received\n * file descriptor as an integer. Raises +SystemCallError+ if something went\n * wrong.\n *\n * You do not have call this method directly. A convenience wrapper is\n * provided by IO#recv_io.\n */\n", "func_signal": "static VALUE\nrecv_fd(VALUE self, VALUE socket_fd)", "code": "{\n\tstruct msghdr msg;\n\tstruct iovec vec;\n\tchar dummy[1];\n\t#if defined(__APPLE__) || defined(__SOLARIS__)\n\t\t// File descriptor passing macros (CMSG_*) seem to be broken\n\t\t// on 64-bit MacOS X. This structure works around the problem.\n\t\tstruct {\n\t\t\tstruct cmsghdr header;\n\t\t\tint fd;\n\t\t} control_data;\n\t\t#define EXPECTED_CMSG_LEN sizeof(control_data)\n\t#else\n\t\tchar control_data[CMSG_SPACE(sizeof(int))];\n\t\t#define EXPECTED_CMSG_LEN CMSG_LEN(sizeof(int))\n\t#endif\n\tstruct cmsghdr *control_header;\n\n\tmsg.msg_name    = NULL;\n\tmsg.msg_namelen = 0;\n\t\n\tdummy[0]       = '\\0';\n\tvec.iov_base   = dummy;\n\tvec.iov_len    = sizeof(dummy);\n\tmsg.msg_iov    = &vec;\n\tmsg.msg_iovlen = 1;\n\n\tmsg.msg_control    = (caddr_t) &control_data;\n\tmsg.msg_controllen = sizeof(control_data);\n\tmsg.msg_flags      = 0;\n\t\n\tif (recvmsg(NUM2INT(socket_fd), &msg, 0) == -1) {\n\t\trb_sys_fail(\"Cannot read file descriptor with recvmsg()\");\n\t\treturn Qnil;\n\t}\n\t\n\tcontrol_header = CMSG_FIRSTHDR(&msg);\n\tif (control_header->cmsg_len   != EXPECTED_CMSG_LEN\n\t || control_header->cmsg_level != SOL_SOCKET\n\t || control_header->cmsg_type  != SCM_RIGHTS) {\n\t\trb_sys_fail(\"No valid file descriptor received.\");\n\t\treturn Qnil;\n\t}\n\t#if defined(__APPLE__) || defined(__SOLARIS__)\n\t\treturn INT2NUM(control_data.fd);\n\t#else\n\t\treturn INT2NUM(*((int *) CMSG_DATA(control_header)));\n\t#endif\n}", "path": "debian\\passenger\\ext\\phusion_passenger\\native_support.c", "repo_name": "colin/nginx", "stars": 1, "license": "other", "language": "c", "size": 2489}
{"docstring": "/*\n * Try to open/test the first index file before the test of directory\n * existence because valid requests should be much more than invalid ones.\n * If the file open()/stat() would fail, then the directory stat() should\n * be more quickly because some data is already cached in the kernel.\n * Besides, Win32 may return ERROR_PATH_NOT_FOUND (NGX_ENOTDIR) at once.\n * Unix has ENOTDIR error, however, it's less helpful than Win32's one:\n * it only indicates that path contains an usual file in place of directory.\n */\n", "func_signal": "static ngx_int_t\nngx_http_index_handler(ngx_http_request_t *r)", "code": "{\n    u_char                       *p, *name;\n    size_t                        len, root, reserve, allocated;\n    ngx_int_t                     rc;\n    ngx_str_t                     path, uri;\n    ngx_uint_t                    i, dir_tested;\n    ngx_http_index_t             *index;\n    ngx_open_file_info_t          of;\n    ngx_http_script_code_pt       code;\n    ngx_http_script_engine_t      e;\n    ngx_http_core_loc_conf_t     *clcf;\n    ngx_http_index_loc_conf_t    *ilcf;\n    ngx_http_script_len_code_pt   lcode;\n\n    if (r->uri.data[r->uri.len - 1] != '/') {\n        return NGX_DECLINED;\n    }\n\n    if (!(r->method & (NGX_HTTP_GET|NGX_HTTP_HEAD|NGX_HTTP_POST))) {\n        return NGX_DECLINED;\n    }\n\n    if (r->zero_in_uri) {\n        return NGX_DECLINED;\n    }\n\n    ilcf = ngx_http_get_module_loc_conf(r, ngx_http_index_module);\n    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n\n    allocated = 0;\n    root = 0;\n    dir_tested = 0;\n    name = NULL;\n    /* suppress MSVC warning */\n    path.data = NULL;\n\n    index = ilcf->indices->elts;\n    for (i = 0; i < ilcf->indices->nelts; i++) {\n\n        if (index[i].lengths == NULL) {\n\n            if (index[i].name.data[0] == '/') {\n                return ngx_http_internal_redirect(r, &index[i].name, &r->args);\n            }\n\n            reserve = ilcf->max_index_len;\n            len = index[i].name.len;\n\n        } else {\n            ngx_memzero(&e, sizeof(ngx_http_script_engine_t));\n\n            e.ip = index[i].lengths->elts;\n            e.request = r;\n            e.flushed = 1;\n\n            /* 1 is for terminating '\\0' as in static names */\n            len = 1;\n\n            while (*(uintptr_t *) e.ip) {\n                lcode = *(ngx_http_script_len_code_pt *) e.ip;\n                len += lcode(&e);\n            }\n\n            /* 16 bytes are preallocation */\n\n            reserve = len + 16;\n        }\n\n        if (reserve > allocated) {\n\n            name = ngx_http_map_uri_to_path(r, &path, &root, reserve);\n            if (name == NULL) {\n                return NGX_ERROR;\n            }\n\n            allocated = path.data + path.len - name;\n        }\n\n        if (index[i].values == NULL) {\n\n            /* index[i].name.len includes the terminating '\\0' */\n\n            ngx_memcpy(name, index[i].name.data, index[i].name.len);\n\n            path.len = (name + index[i].name.len - 1) - path.data;\n\n        } else {\n            e.ip = index[i].values->elts;\n            e.pos = name;\n\n            while (*(uintptr_t *) e.ip) {\n                code = *(ngx_http_script_code_pt *) e.ip;\n                code((ngx_http_script_engine_t *) &e);\n            }\n\n            if (*name == '/') {\n                uri.len = len - 1;\n                uri.data = name;\n                return ngx_http_internal_redirect(r, &uri, &r->args);\n            }\n\n            path.len = e.pos - path.data;\n\n            *e.pos = '\\0';\n        }\n\n        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                       \"open index \\\"%V\\\"\", &path);\n\n        ngx_memzero(&of, sizeof(ngx_open_file_info_t));\n\n        of.directio = clcf->directio;\n        of.valid = clcf->open_file_cache_valid;\n        of.min_uses = clcf->open_file_cache_min_uses;\n        of.test_only = 1;\n        of.errors = clcf->open_file_cache_errors;\n        of.events = clcf->open_file_cache_events;\n\n        if (ngx_open_cached_file(clcf->open_file_cache, &path, &of, r->pool)\n            != NGX_OK)\n        {\n            ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, of.err,\n                           \"%s \\\"%s\\\" failed\", of.failed, path.data);\n\n            if (of.err == 0) {\n                return NGX_HTTP_INTERNAL_SERVER_ERROR;\n            }\n\n            if (of.err == NGX_ENOTDIR || of.err == NGX_EACCES) {\n                return ngx_http_index_error(r, clcf, path.data, of.err);\n            }\n\n            if (!dir_tested) {\n                rc = ngx_http_index_test_dir(r, clcf, path.data, name - 1);\n\n                if (rc != NGX_OK) {\n                    return rc;\n                }\n\n                dir_tested = 1;\n            }\n\n            if (of.err == NGX_ENOENT) {\n                continue;\n            }\n\n            ngx_log_error(NGX_LOG_CRIT, r->connection->log, of.err,\n                          \"%s \\\"%s\\\" failed\", of.failed, path.data);\n\n            return NGX_HTTP_INTERNAL_SERVER_ERROR;\n        }\n\n        uri.len = r->uri.len + len - 1;\n\n        if (!clcf->alias) {\n            uri.data = path.data + root;\n\n        } else {\n            uri.data = ngx_pnalloc(r->pool, uri.len);\n            if (uri.data == NULL) {\n                return NGX_HTTP_INTERNAL_SERVER_ERROR;\n            }\n\n            p = ngx_copy(uri.data, r->uri.data, r->uri.len);\n            ngx_memcpy(p, name, len - 1);\n        }\n\n        return ngx_http_internal_redirect(r, &uri, &r->args);\n    }\n\n    return NGX_DECLINED;\n}", "path": "src\\http\\modules\\ngx_http_index_module.c", "repo_name": "colin/nginx", "stars": 1, "license": "other", "language": "c", "size": 2489}
{"docstring": "/*\n * call-seq: accept(fileno)\n *\n * Accept a new client from the given socket.\n *\n * - +fileno+ (integer): The file descriptor of the server socket.\n * - Returns: The accepted client's file descriptor.\n * - Raises +SystemCallError+ if something went wrong.\n */\n", "func_signal": "static VALUE\nf_accept(VALUE self, VALUE fileno)", "code": "{\n\tint fd = accept(NUM2INT(fileno), NULL, NULL);\n\tif (fd == -1) {\n\t\trb_sys_fail(\"accept() failed\");\n\t\treturn Qnil;\n\t} else {\n\t\treturn INT2NUM(fd);\n\t}\n}", "path": "debian\\passenger\\ext\\phusion_passenger\\native_support.c", "repo_name": "colin/nginx", "stars": 1, "license": "other", "language": "c", "size": 2489}
{"docstring": "/*\n * call-seq: send_fd(socket_fd, fd_to_send)\n *\n * Send a file descriptor over the given Unix socket. You do not have to call\n * this function directly. A convenience wrapper is provided by IO#send_io.\n *\n * - +socket_fd+ (integer): The file descriptor of the socket.\n * - +fd_to_send+ (integer): The file descriptor to send.\n * - Raises +SystemCallError+ if something went wrong.\n */\n", "func_signal": "static VALUE\nsend_fd(VALUE self, VALUE socket_fd, VALUE fd_to_send)", "code": "{\n\tstruct msghdr msg;\n\tstruct iovec vec;\n\tchar dummy[1];\n\t#if defined(__APPLE__) || defined(__SOLARIS__)\n\t\tstruct {\n\t\t\tstruct cmsghdr header;\n\t\t\tint fd;\n\t\t} control_data;\n\t#else\n\t\tchar control_data[CMSG_SPACE(sizeof(int))];\n\t#endif\n\tstruct cmsghdr *control_header;\n\tint control_payload;\n\t\n\tmsg.msg_name = NULL;\n\tmsg.msg_namelen = 0;\n\t\n\t/* Linux and Solaris require msg_iov to be non-NULL. */\n\tdummy[0]       = '\\0';\n\tvec.iov_base   = dummy;\n\tvec.iov_len    = sizeof(dummy);\n\tmsg.msg_iov    = &vec;\n\tmsg.msg_iovlen = 1;\n\t\n\tmsg.msg_control    = (caddr_t) &control_data;\n\tmsg.msg_controllen = sizeof(control_data);\n\tmsg.msg_flags      = 0;\n\t\n\tcontrol_header = CMSG_FIRSTHDR(&msg);\n\tcontrol_header->cmsg_level = SOL_SOCKET;\n\tcontrol_header->cmsg_type  = SCM_RIGHTS;\n\tcontrol_payload = NUM2INT(fd_to_send);\n\t#if defined(__APPLE__) || defined(__SOLARIS__)\n\t\tcontrol_header->cmsg_len = sizeof(control_data);\n\t\tcontrol_data.fd = control_payload;\n\t#else\n\t\tcontrol_header->cmsg_len = CMSG_LEN(sizeof(int));\n\t\tmemcpy(CMSG_DATA(control_header), &control_payload, sizeof(int));\n\t#endif\n\t\n\tif (sendmsg(NUM2INT(socket_fd), &msg, 0) == -1) {\n\t\trb_sys_fail(\"sendmsg(2)\");\n\t\treturn Qnil;\n\t}\n\t\n\treturn Qnil;\n}", "path": "debian\\passenger\\ext\\phusion_passenger\\native_support.c", "repo_name": "colin/nginx", "stars": 1, "license": "other", "language": "c", "size": 2489}
{"docstring": "/*\n * call-seq: create_unix_socket(filename, backlog)\n *\n * Create a SOCK_STREAM server Unix socket. Unlike Ruby's UNIXServer class,\n * this function is also able to create Unix sockets on the abstract namespace\n * by prepending the filename with a null byte.\n *\n * - +filename+ (string): The filename of the Unix socket to create.\n * - +backlog+ (integer): The backlog to use for listening on the socket.\n * - Returns: The file descriptor of the created Unix socket, as an integer.\n * - Raises +SystemCallError+ if something went wrong.\n */\n", "func_signal": "static VALUE\ncreate_unix_socket(VALUE self, VALUE filename, VALUE backlog)", "code": "{\n\tint fd, ret;\n\tstruct sockaddr_un addr;\n\tchar *filename_str;\n\tlong filename_length;\n\t\n\tfilename_str = RSTRING_PTR(filename);\n\tfilename_length = RSTRING_LEN(filename);\n\t\n\tfd = socket(PF_UNIX, SOCK_STREAM, 0);\n\tif (fd == -1) {\n\t\trb_sys_fail(\"Cannot create a Unix socket\");\n\t\treturn Qnil;\n\t}\n\t\n\taddr.sun_family = AF_UNIX;\n\tmemcpy(addr.sun_path, filename_str, MIN(filename_length, sizeof(addr.sun_path)));\n\taddr.sun_path[sizeof(addr.sun_path) - 1] = '\\0';\n\t\n\tret = bind(fd, (const struct sockaddr *) &addr, sizeof(addr));\n\tif (ret == -1) {\n\t\tint e = errno;\n\t\tclose(fd);\n\t\terrno = e;\n\t\trb_sys_fail(\"Cannot bind Unix socket\");\n\t\treturn Qnil;\n\t}\n\t\n\tret = listen(fd, NUM2INT(backlog));\n\tif (ret == -1) {\n\t\tint e = errno;\n\t\tclose(fd);\n\t\terrno = e;\n\t\trb_sys_fail(\"Cannot listen on Unix socket\");\n\t\treturn Qnil;\n\t}\n\treturn INT2NUM(fd);\n}", "path": "debian\\passenger\\ext\\phusion_passenger\\native_support.c", "repo_name": "colin/nginx", "stars": 1, "license": "other", "language": "c", "size": 2489}
{"docstring": "/* the stable insertion sort */\n", "func_signal": "void\nngx_queue_sort(ngx_queue_t *queue,\n    ngx_int_t (*cmp)(const ngx_queue_t *, const ngx_queue_t *))", "code": "{\n    ngx_queue_t  *q, *prev, *next;\n\n    q = ngx_queue_head(queue);\n\n    if (q == ngx_queue_last(queue)) {\n        return;\n    }\n\n    for (q = ngx_queue_next(q); q != ngx_queue_sentinel(queue); q = next) {\n\n        prev = ngx_queue_prev(q);\n        next = ngx_queue_next(q);\n\n        ngx_queue_remove(q);\n\n        do {\n            if (cmp(prev, q) <= 0) {\n                break;\n            }\n\n            prev = ngx_queue_prev(prev);\n\n        } while (prev != ngx_queue_sentinel(queue));\n\n        ngx_queue_insert_after(prev, q);\n    }\n}", "path": "src\\core\\ngx_queue.c", "repo_name": "colin/nginx", "stars": 1, "license": "other", "language": "c", "size": 2489}
{"docstring": "/* \nLet's register the upload connection in our connections rb-tree\n*/\n", "func_signal": "static ngx_int_t\nngx_http_uploadprogress_handler(ngx_http_request_t * r)", "code": "{\n    size_t                           n;\n    ngx_str_t                       *id;\n    uint32_t                         hash;\n    ngx_slab_pool_t                 *shpool;\n    ngx_rbtree_node_t               *node;\n    ngx_http_uploadprogress_conf_t  *upcf;\n    ngx_http_uploadprogress_ctx_t   *ctx;\n    ngx_http_uploadprogress_node_t  *up;\n    ngx_http_uploadprogress_cleanup_t *upcln;\n    ngx_pool_cleanup_t              *cln;\n\n    /* Is it a POST connection */\n    if (r->method != NGX_HTTP_POST) {\n        return NGX_DECLINED;\n    }\n\n    id = get_tracking_id(r);\n    if (id == NULL) {\n        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                       \"trackuploads no id found in POST upload req\");\n        return NGX_DECLINED;\n    }\n\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"trackuploads id found: %V\", id);\n\n    upcf = ngx_http_get_module_loc_conf(r, ngx_http_uploadprogress_module);\n\n    if (!upcf->track) {\n        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                       \"trackuploads not tracking in this location for id: %V\", id);\n        ngx_free(id);\n        return NGX_DECLINED;\n    }\n\n    if (upcf->shm_zone == NULL) {\n        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                       \"trackuploads no shm_zone for id: %V\", id);\n        ngx_free(id);\n        return NGX_DECLINED;\n    }\n\n    ctx = upcf->shm_zone->data;\n\n    hash = ngx_crc32_short(id->data, id->len);\n\n    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"trackuploads hash %08XD for id: %V\", hash, id);\n\n    shpool = (ngx_slab_pool_t *) upcf->shm_zone->shm.addr;\n\n    ngx_shmtx_lock(&shpool->mutex);\n\n    if (find_node(id, ctx, r->connection->log) != NULL) {\n        ngx_shmtx_unlock(&shpool->mutex);\n        /* already found a node with matching progress ID */\n        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                      \"upload_progress: tracking already registered id: %V\", id);\n\n        ngx_free(id);\n        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    cln = ngx_pool_cleanup_add(r->pool, sizeof(ngx_http_uploadprogress_cleanup_t));\n    if (cln == NULL) {\n        ngx_shmtx_unlock(&shpool->mutex);\n        ngx_free(id);\n        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    n = sizeof(ngx_http_uploadprogress_node_t)\n        + id->len;\n\n    node = ngx_slab_alloc_locked(shpool, n);\n    if (node == NULL) {\n        ngx_shmtx_unlock(&shpool->mutex);\n        ngx_free(id);\n        return NGX_HTTP_SERVICE_UNAVAILABLE;\n    }\n\n    up = (ngx_http_uploadprogress_node_t *) node;\n\n    node->key = hash;\n    up->len = (u_char) id->len;\n    up->err_status = r->err_status;\n    up->done = 0;\n    up->rest = 0;\n    up->length = 0;\n    up->timeout = 0;\n\n    up->next = ctx->list_head.next;\n    up->next->prev = up;\n    up->prev = &ctx->list_head;\n    ctx->list_head.next = up;\n\n    ngx_memcpy(up->data, id->data, id->len);\n\n    ngx_rbtree_insert(ctx->rbtree, node);\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"trackuploads: %08XD inserted in rbtree\", node->key);\n\n    if (!upcf->cleanup.timer_set) {\n        upcf->cleanup.data = upcf->shm_zone;\n        upcf->cleanup.handler = ngx_clean_old_connections;\n        upcf->cleanup.log = upcf->shm_zone->shm.log;\n        ngx_add_timer(&upcf->cleanup, TIMER_FREQUENCY);\n    }\n\n    ngx_shmtx_unlock(&shpool->mutex);\n\n    cln->handler = ngx_http_uploadprogress_cleanup;\n    upcln = cln->data;\n\n    upcln->shm_zone = upcf->shm_zone;\n    upcln->node = node;\n    upcln->timeout = upcf->timeout;\n    upcln->r = r;\n\n    ngx_free(id);\n\n    ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_uploadprogress_module_ctx_t));\n    if (ctx == NULL) {\n      return NGX_ERROR;\n    }\n\n    ngx_http_set_ctx(r, ctx, ngx_http_uploadprogress_module);\n\n    /* finally says to the core we don't handle anything */\n    return NGX_DECLINED;\n}", "path": "debian\\upload-progress\\ngx_http_uploadprogress_module.c", "repo_name": "colin/nginx", "stars": 1, "license": "other", "language": "c", "size": 2489}
{"docstring": "/***************************/\n", "func_signal": "void\nInit_native_support()", "code": "{\n\tstruct sockaddr_un addr;\n\t\n\t/* */\n\tmPassenger = rb_define_module(\"PhusionPassenger\"); // Do not remove the above comment. We want the Passenger module's rdoc to be empty.\n\t\n\t/*\n\t * Utility functions for accessing system functionality.\n\t */\n\tmNativeSupport = rb_define_module_under(mPassenger, \"NativeSupport\");\n\t\n\trb_define_singleton_method(mNativeSupport, \"send_fd\", send_fd, 2);\n\trb_define_singleton_method(mNativeSupport, \"recv_fd\", recv_fd, 1);\n\trb_define_singleton_method(mNativeSupport, \"create_unix_socket\", create_unix_socket, 2);\n\trb_define_singleton_method(mNativeSupport, \"accept\", f_accept, 1);\n\trb_define_singleton_method(mNativeSupport, \"close_all_file_descriptors\", close_all_file_descriptors, 1);\n\trb_define_singleton_method(mNativeSupport, \"disable_stdio_buffering\", disable_stdio_buffering, 0);\n\t\n\t/* The maximum length of a Unix socket path, including terminating null. */\n\trb_define_const(mNativeSupport, \"UNIX_PATH_MAX\", INT2NUM(sizeof(addr.sun_path)));\n}", "path": "debian\\passenger\\ext\\phusion_passenger\\native_support.c", "repo_name": "colin/nginx", "stars": 1, "license": "other", "language": "c", "size": 2489}
{"docstring": "/*\n * NGX_OK       - exact or regex match\n * NGX_DONE     - auto redirect\n * NGX_AGAIN    - inclusive match\n * NGX_ERROR    - regex error\n * NGX_DECLINED - no match\n */\n", "func_signal": "static ngx_int_t\nngx_http_core_find_location(ngx_http_request_t *r)", "code": "{\n    ngx_int_t                  rc;\n    ngx_http_core_loc_conf_t  *pclcf;\n#if (NGX_PCRE)\n    ngx_int_t                  n, len;\n    ngx_uint_t                 noregex;\n    ngx_http_core_loc_conf_t  *clcf, **clcfp;\n\n    noregex = 0;\n#endif\n\n    pclcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n\n    rc = ngx_http_core_find_static_location(r, pclcf->static_locations);\n\n    if (rc == NGX_AGAIN) {\n\n#if (NGX_PCRE)\n        clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n\n        noregex = clcf->noregex;\n#endif\n\n        /* look up nested locations */\n\n        rc = ngx_http_core_find_location(r);\n    }\n\n    if (rc == NGX_OK || rc == NGX_DONE) {\n        return rc;\n    }\n\n    /* rc == NGX_DECLINED or rc == NGX_AGAIN in nested location */\n\n#if (NGX_PCRE)\n\n    if (noregex == 0 && pclcf->regex_locations) {\n\n        len = 0;\n\n        for (clcfp = pclcf->regex_locations; *clcfp; clcfp++) {\n\n            ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                           \"test location: ~ \\\"%V\\\"\", &(*clcfp)->name);\n\n            if ((*clcfp)->captures) {\n\n                len = (NGX_HTTP_MAX_CAPTURES + 1) * 3;\n\n                if (r->captures == NULL) {\n                    r->captures = ngx_palloc(r->pool, len * sizeof(int));\n                    if (r->captures == NULL) {\n                        return NGX_ERROR;\n                    }\n                }\n            }\n\n            n = ngx_regex_exec((*clcfp)->regex, &r->uri, r->captures, len);\n\n            if (n == NGX_REGEX_NO_MATCHED) {\n                continue;\n            }\n\n            if (n < 0) {\n                ngx_log_error(NGX_LOG_ALERT, r->connection->log, 0,\n                              ngx_regex_exec_n\n                              \" failed: %d on \\\"%V\\\" using \\\"%V\\\"\",\n                              n, &r->uri, &(*clcfp)->name);\n                return NGX_ERROR;\n            }\n\n            /* match */\n\n            r->loc_conf = (*clcfp)->loc_conf;\n\n            r->ncaptures = len;\n            r->captures_data = r->uri.data;\n\n            /* look up nested locations */\n\n            rc = ngx_http_core_find_location(r);\n\n            return (rc == NGX_ERROR) ? rc : NGX_OK;\n        }\n    }\n#endif\n\n    return rc;\n}", "path": "src\\http\\ngx_http_core_module.c", "repo_name": "colin/nginx", "stars": 1, "license": "other", "language": "c", "size": 2489}
{"docstring": "/*\n *  Destroys a private workspace.\n *\n * Results:\n *  It's gone!\n *\n * Side effects:\n *  None.\n */\n", "func_signal": "static void g722_destroy(struct cw_translator_pvt *pvt)", "code": "{\n    free(pvt);\n    localusecnt--;\n    cw_update_use_count();\n}", "path": "codecs\\codec_g722.c", "repo_name": "macntouch/callweaver", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 5884}
{"docstring": "/** Pushes the new state onto the stack. The new state becomes\n *  the current state. This function will allocate the stack\n *  if necessary.\n *  @param new_buffer The new state.\n *  @param yyscanner The scanner object.\n */\n", "func_signal": "void ael_yypush_buffer_state (YY_BUFFER_STATE new_buffer , yyscan_t yyscanner)", "code": "{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\tif (new_buffer == NULL)\n\t\treturn;\n\n\tael_yyensure_buffer_stack(yyscanner);\n\n\t/* This block is copied from ael_yy_switch_to_buffer. */\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*yyg->yy_c_buf_p = yyg->yy_hold_char;\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = yyg->yy_c_buf_p;\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;\n\t\t}\n\n\t/* Only push if top exists. Otherwise, replace top. */\n\tif (YY_CURRENT_BUFFER)\n\t\tyyg->yy_buffer_stack_top++;\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\n\t/* copied from ael_yy_switch_to_buffer. */\n\tael_yy_load_buffer_state(yyscanner );\n\tyyg->yy_did_buffer_switch_on_eof = 1;\n}", "path": "pbx\\ael\\ael_lex.c", "repo_name": "macntouch/callweaver", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 5884}
{"docstring": "/* Allocates the stack if it does not exist.\n *  Guarantees space for at least one push.\n */\n", "func_signal": "static void ael_yyensure_buffer_stack (yyscan_t yyscanner)", "code": "{\n\tint num_to_alloc;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n\tif (!yyg->yy_buffer_stack) {\n\n\t\t/* First allocation is just for 2 elements, since we don't know if this\n\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an\n\t\t * immediate realloc on the next call.\n         */\n\t\tnum_to_alloc = 1;\n\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)ael_yyalloc\n\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t, yyscanner);\n\t\t\n\t\tmemset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n\t\t\t\t\n\t\tyyg->yy_buffer_stack_max = num_to_alloc;\n\t\tyyg->yy_buffer_stack_top = 0;\n\t\treturn;\n\t}\n\n\tif (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){\n\n\t\t/* Increase the buffer to prepare for a possible push. */\n\t\tint grow_size = 8 /* arbitrary grow size */;\n\n\t\tnum_to_alloc = yyg->yy_buffer_stack_max + grow_size;\n\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)ael_yyrealloc\n\t\t\t\t\t\t\t\t(yyg->yy_buffer_stack,\n\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t, yyscanner);\n\n\t\t/* zero only the new slots.*/\n\t\tmemset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));\n\t\tyyg->yy_buffer_stack_max = num_to_alloc;\n\t}\n}", "path": "pbx\\ael\\ael_lex.c", "repo_name": "macntouch/callweaver", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 5884}
{"docstring": "/* ael_yylex_destroy is for both reentrant and non-reentrant scanners. */\n", "func_signal": "int ael_yylex_destroy  (yyscan_t yyscanner)", "code": "{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n    /* Pop the buffer stack, destroying each element. */\n\twhile(YY_CURRENT_BUFFER){\n\t\tael_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner );\n\t\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\t\tael_yypop_buffer_state(yyscanner);\n\t}\n\n\t/* Destroy the stack itself. */\n\tael_yyfree(yyg->yy_buffer_stack ,yyscanner);\n\tyyg->yy_buffer_stack = NULL;\n\n    /* Destroy the start condition stack. */\n        ael_yyfree(yyg->yy_start_stack ,yyscanner );\n        yyg->yy_start_stack = NULL;\n\n    /* Reset the globals. This is important in a non-reentrant scanner so the next time\n     * ael_yylex() is called, initialization will occur. */\n    yy_init_globals( yyscanner);\n\n    /* Destroy the main struct (reentrant only). */\n    ael_yyfree ( yyscanner , yyscanner );\n    yyscanner = NULL;\n    return 0;\n}", "path": "pbx\\ael\\ael_lex.c", "repo_name": "macntouch/callweaver", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 5884}
{"docstring": "/* yy_try_NUL_trans - try to make a transition on the NUL character\n *\n * synopsis\n *\tnext_state = yy_try_NUL_trans( current_state );\n */\n", "func_signal": "static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)", "code": "{\n\tregister int yy_is_jam;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */\n\tregister char *yy_cp = yyg->yy_c_buf_p;\n\n\tregister YY_CHAR yy_c = 1;\n\tif ( yy_accept[yy_current_state] )\n\t\t{\n\t\tyyg->yy_last_accepting_state = yy_current_state;\n\t\tyyg->yy_last_accepting_cpos = yy_cp;\n\t\t}\n\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t{\n\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\tif ( yy_current_state >= 220 )\n\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t}\n\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n\tyy_is_jam = (yy_current_state == 219);\n\n\treturn yy_is_jam ? 0 : yy_current_state;\n}", "path": "pbx\\ael\\ael_lex.c", "repo_name": "macntouch/callweaver", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 5884}
{"docstring": "/* yy_get_next_buffer - try to read in a new buffer\n *\n * Returns a code representing an action:\n *\tEOB_ACT_LAST_MATCH -\n *\tEOB_ACT_CONTINUE_SCAN - continue scanning from current position\n *\tEOB_ACT_END_OF_FILE - end of file\n */\n", "func_signal": "static int yy_get_next_buffer (yyscan_t yyscanner)", "code": "{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\tregister char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;\n\tregister char *source = yyg->yytext_ptr;\n\tregister int number_to_move, i;\n\tint ret_val;\n\n\tif ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )\n\t\tYY_FATAL_ERROR(\n\t\t\"fatal flex scanner internal error--end of buffer missed\" );\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )\n\t\t{ /* Don't try to fill the buffer, so this is an EOF. */\n\t\tif ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )\n\t\t\t{\n\t\t\t/* We matched a single character, the EOB, so\n\t\t\t * treat this as a final EOF.\n\t\t\t */\n\t\t\treturn EOB_ACT_END_OF_FILE;\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\t/* We matched some text prior to the EOB, first\n\t\t\t * process it.\n\t\t\t */\n\t\t\treturn EOB_ACT_LAST_MATCH;\n\t\t\t}\n\t\t}\n\n\t/* Try to read more data. */\n\n\t/* First move last chars to start of buffer. */\n\tnumber_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;\n\n\tfor ( i = 0; i < number_to_move; ++i )\n\t\t*(dest++) = *(source++);\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )\n\t\t/* don't do the read, it's not guaranteed to return an EOF,\n\t\t * just force an EOF\n\t\t */\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;\n\n\telse\n\t\t{\n\t\t\tint num_to_read =\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;\n\n\t\twhile ( num_to_read <= 0 )\n\t\t\t{ /* Not enough room in the buffer - grow it. */\n\n\t\t\t/* just a shorter name for the current buffer */\n\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER;\n\n\t\t\tint yy_c_buf_p_offset =\n\t\t\t\t(int) (yyg->yy_c_buf_p - b->yy_ch_buf);\n\n\t\t\tif ( b->yy_is_our_buffer )\n\t\t\t\t{\n\t\t\t\tint new_size = b->yy_buf_size * 2;\n\n\t\t\t\tif ( new_size <= 0 )\n\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;\n\t\t\t\telse\n\t\t\t\t\tb->yy_buf_size *= 2;\n\n\t\t\t\tb->yy_ch_buf = (char *)\n\t\t\t\t\t/* Include room in for 2 EOB chars. */\n\t\t\t\t\tael_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2 ,yyscanner );\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t/* Can't grow it, we don't own it. */\n\t\t\t\tb->yy_ch_buf = 0;\n\n\t\t\tif ( ! b->yy_ch_buf )\n\t\t\t\tYY_FATAL_ERROR(\n\t\t\t\t\"fatal error - scanner input buffer overflow\" );\n\n\t\t\tyyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];\n\n\t\t\tnum_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -\n\t\t\t\t\t\tnumber_to_move - 1;\n\n\t\t\t}\n\n\t\tif ( num_to_read > YY_READ_BUF_SIZE )\n\t\t\tnum_to_read = YY_READ_BUF_SIZE;\n\n\t\t/* Read in more data. */\n\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),\n\t\t\tyyg->yy_n_chars, num_to_read );\n\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;\n\t\t}\n\n\tif ( yyg->yy_n_chars == 0 )\n\t\t{\n\t\tif ( number_to_move == YY_MORE_ADJ )\n\t\t\t{\n\t\t\tret_val = EOB_ACT_END_OF_FILE;\n\t\t\tael_yyrestart(yyin  ,yyscanner);\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\tret_val = EOB_ACT_LAST_MATCH;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status =\n\t\t\t\tYY_BUFFER_EOF_PENDING;\n\t\t\t}\n\t\t}\n\n\telse\n\t\tret_val = EOB_ACT_CONTINUE_SCAN;\n\n\tyyg->yy_n_chars += number_to_move;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;\n\n\tyyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];\n\n\treturn ret_val;\n}", "path": "pbx\\ael\\ael_lex.c", "repo_name": "macntouch/callweaver", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 5884}
{"docstring": "/** Discard all buffered characters. On the next scan, YY_INPUT will be called.\n * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.\n * @param yyscanner The scanner object.\n */\n", "func_signal": "void ael_yy_flush_buffer (YY_BUFFER_STATE  b , yyscan_t yyscanner)", "code": "{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\tif ( ! b )\n\t\treturn;\n\n\tb->yy_n_chars = 0;\n\n\t/* We always need two end-of-buffer characters.  The first causes\n\t * a transition to the end-of-buffer state.  The second causes\n\t * a jam in that state.\n\t */\n\tb->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;\n\tb->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;\n\n\tb->yy_buf_pos = &b->yy_ch_buf[0];\n\n\tb->yy_at_bol = 1;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tif ( b == YY_CURRENT_BUFFER )\n\t\tael_yy_load_buffer_state(yyscanner );\n}", "path": "pbx\\ael\\ael_lex.c", "repo_name": "macntouch/callweaver", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 5884}
{"docstring": "/** Switch to a different input buffer.\n * @param new_buffer The new input buffer.\n * @param yyscanner The scanner object.\n */\n", "func_signal": "void ael_yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer , yyscan_t yyscanner)", "code": "{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n\t/* TODO. We should be able to replace this entire function body\n\t * with\n\t *\t\tael_yypop_buffer_state();\n\t *\t\tael_yypush_buffer_state(new_buffer);\n     */\n\tael_yyensure_buffer_stack (yyscanner);\n\tif ( YY_CURRENT_BUFFER == new_buffer )\n\t\treturn;\n\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*yyg->yy_c_buf_p = yyg->yy_hold_char;\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = yyg->yy_c_buf_p;\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;\n\t\t}\n\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\tael_yy_load_buffer_state(yyscanner );\n\n\t/* We don't actually know whether we did this switch during\n\t * EOF (ael_yywrap()) processing, but the only time this flag\n\t * is looked at is after ael_yywrap() is called, so it's safe\n\t * to go ahead and always set it.\n\t */\n\tyyg->yy_did_buffer_switch_on_eof = 1;\n}", "path": "pbx\\ael\\ael_lex.c", "repo_name": "macntouch/callweaver", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 5884}
{"docstring": "/** Get the current line number.\n * @param yyscanner The scanner object.\n */\n", "func_signal": "int ael_yyget_lineno  (yyscan_t yyscanner)", "code": "{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n    \n        if (! YY_CURRENT_BUFFER)\n            return 0;\n    \n    return yylineno;\n}", "path": "pbx\\ael\\ael_lex.c", "repo_name": "macntouch/callweaver", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 5884}
{"docstring": "/*\n *  Convert a buffer of raw 16-bit signed linear PCM to a buffer of G722.\n *\n * Results:\n *  Foo\n *\n * Side effects:\n *  Leftover inbuf data gets packed, tail gets updated.\n */\n", "func_signal": "static struct cw_frame *lintog722_frameout(struct cw_translator_pvt *pvt)", "code": "{\n    struct g722_encoder_pvt *tmp = (struct g722_encoder_pvt *) pvt;\n  \n    if (tmp->tail == 0)\n        return NULL;\n    cw_fr_init_ex(&tmp->f, CW_FRAME_VOICE, CW_FORMAT_G722, __PRETTY_FUNCTION__);\n    tmp->f.samples = tmp->tail*2;\n    tmp->f.offset = CW_FRIENDLY_OFFSET;\n    tmp->f.data = tmp->outbuf;\n    tmp->f.datalen = tmp->tail;\n\n    tmp->tail = 0;\n    return &tmp->f;\n}", "path": "codecs\\codec_g722.c", "repo_name": "macntouch/callweaver", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 5884}
{"docstring": "/** Destroy the buffer.\n * @param b a buffer created with ael_yy_create_buffer()\n * @param yyscanner The scanner object.\n */\n", "func_signal": "void ael_yy_delete_buffer (YY_BUFFER_STATE  b , yyscan_t yyscanner)", "code": "{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n\tif ( ! b )\n\t\treturn;\n\n\tif ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */\n\t\tYY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;\n\n\tif ( b->yy_is_our_buffer )\n\t\tael_yyfree((void *) b->yy_ch_buf ,yyscanner );\n\n\tael_yyfree((void *) b ,yyscanner );\n}", "path": "pbx\\ael\\ael_lex.c", "repo_name": "macntouch/callweaver", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 5884}
{"docstring": "/* Accessor methods for yylval and yylloc */\n", "func_signal": "YYSTYPE * ael_yyget_lval  (yyscan_t yyscanner)", "code": "{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n    return yylval;\n}", "path": "pbx\\ael\\ael_lex.c", "repo_name": "macntouch/callweaver", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 5884}
{"docstring": "/* yy_get_previous_state - get the state just before the EOB char was reached */\n", "func_signal": "static yy_state_type yy_get_previous_state (yyscan_t yyscanner)", "code": "{\n\tregister yy_state_type yy_current_state;\n\tregister char *yy_cp;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n\tyy_current_state = yyg->yy_start;\n\n\tfor ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )\n\t\t{\n\t\tregister YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);\n\t\tif ( yy_accept[yy_current_state] )\n\t\t\t{\n\t\t\tyyg->yy_last_accepting_state = yy_current_state;\n\t\t\tyyg->yy_last_accepting_cpos = yy_cp;\n\t\t\t}\n\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t\t{\n\t\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\t\tif ( yy_current_state >= 220 )\n\t\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t\t}\n\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n\t\t}\n\n\treturn yy_current_state;\n}", "path": "pbx\\ael\\ael_lex.c", "repo_name": "macntouch/callweaver", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 5884}
{"docstring": "/* Initializes or reinitializes a buffer.\n * This function is sometimes called more than once on the same buffer,\n * such as during a ael_yyrestart() or at EOF.\n */\n", "func_signal": "static void ael_yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file , yyscan_t yyscanner)", "code": "{\n\tint oerrno = errno;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n\tael_yy_flush_buffer(b ,yyscanner);\n\n\tb->yy_input_file = file;\n\tb->yy_fill_buffer = 1;\n\n    /* If b is the current buffer, then ael_yy_init_buffer was _probably_\n     * called from ael_yyrestart() or through yy_get_next_buffer.\n     * In that case, we don't want to reset the lineno or column.\n     */\n    if (b != YY_CURRENT_BUFFER){\n        b->yy_bs_lineno = 1;\n        b->yy_bs_column = 0;\n    }\n\n        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;\n    \n\terrno = oerrno;\n}", "path": "pbx\\ael\\ael_lex.c", "repo_name": "macntouch/callweaver", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 5884}
{"docstring": "/*\n *  Fill an input buffer with G722 values if there is room left.\n *\n * Results:\n *  Foo\n *\n * Side effects:\n *  tmp->tail is the number of packed values in the buffer.\n */\n", "func_signal": "static int g722tolin_framein(struct cw_translator_pvt *pvt, struct cw_frame *f)", "code": "{\n    struct g722_decoder_pvt *tmp = (struct g722_decoder_pvt *) pvt;\n\n    if (f->datalen == 0)\n    {\n        /* Perform PLC with nominal framesize of 20ms/320 samples */\n        if ((tmp->tail + 320) > BUFFER_SIZE)\n        {\n            cw_log(LOG_WARNING, \"Out of buffer space\\n\");\n            return -1;\n        }\n        if (useplc)\n        {\n            plc_fillin(&tmp->plc, tmp->outbuf + tmp->tail, 320);\n            tmp->tail += 320;\n        }\n    }\n    else\n    {\n        if ((tmp->tail + f->datalen*2) > BUFFER_SIZE)\n        {\n            cw_log(LOG_WARNING, \"Out of buffer space\\n\");\n            return -1;\n        }\n        tmp->tail += g722_decode(&(tmp->g722_state),\n                                 tmp->outbuf + tmp->tail,\n                                 (const uint8_t *) f->data,\n                                 f->datalen);\n        if (useplc)\n            plc_rx(&tmp->plc, tmp->outbuf + tmp->tail - f->datalen*2, f->datalen*2);\n    }\n    return 0;\n}", "path": "codecs\\codec_g722.c", "repo_name": "macntouch/callweaver", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 5884}
{"docstring": "/** Removes and deletes the top of the stack, if present.\n *  The next element becomes the new top.\n *  @param yyscanner The scanner object.\n */\n", "func_signal": "void ael_yypop_buffer_state (yyscan_t yyscanner)", "code": "{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\tif (!YY_CURRENT_BUFFER)\n\t\treturn;\n\n\tael_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);\n\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\tif (yyg->yy_buffer_stack_top > 0)\n\t\t--yyg->yy_buffer_stack_top;\n\n\tif (YY_CURRENT_BUFFER) {\n\t\tael_yy_load_buffer_state(yyscanner );\n\t\tyyg->yy_did_buffer_switch_on_eof = 1;\n\t}\n}", "path": "pbx\\ael\\ael_lex.c", "repo_name": "macntouch/callweaver", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 5884}
{"docstring": "/** Setup the input buffer state to scan directly from a user-specified character buffer.\n * @param base the character buffer\n * @param size the size in bytes of the character buffer\n * @param yyscanner The scanner object.\n * @return the newly allocated buffer state object. \n */\n", "func_signal": "YY_BUFFER_STATE ael_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)", "code": "{\n\tYY_BUFFER_STATE b;\n    \n\tif ( size < 2 ||\n\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n\t     base[size-1] != YY_END_OF_BUFFER_CHAR )\n\t\t/* They forgot to leave room for the EOB's. */\n\t\treturn 0;\n\n\tb = (YY_BUFFER_STATE) ael_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in ael_yy_scan_buffer()\" );\n\n\tb->yy_buf_size = size - 2;\t/* \"- 2\" to take care of EOB's */\n\tb->yy_buf_pos = b->yy_ch_buf = base;\n\tb->yy_is_our_buffer = 0;\n\tb->yy_input_file = 0;\n\tb->yy_n_chars = b->yy_buf_size;\n\tb->yy_is_interactive = 0;\n\tb->yy_at_bol = 1;\n\tb->yy_fill_buffer = 0;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tael_yy_switch_to_buffer(b ,yyscanner );\n\n\treturn b;\n}", "path": "pbx\\ael\\ael_lex.c", "repo_name": "macntouch/callweaver", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 5884}
{"docstring": "/** Immediately switch to a different input stream.\n * @param input_file A readable stream.\n * @param yyscanner The scanner object.\n * @note This function does not reset the start condition to @c INITIAL .\n */\n", "func_signal": "void ael_yyrestart  (FILE * input_file , yyscan_t yyscanner)", "code": "{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n\tif ( ! YY_CURRENT_BUFFER ){\n        ael_yyensure_buffer_stack (yyscanner);\n\t\tYY_CURRENT_BUFFER_LVALUE =\n            ael_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);\n\t}\n\n\tael_yy_init_buffer(YY_CURRENT_BUFFER,input_file ,yyscanner);\n\tael_yy_load_buffer_state(yyscanner );\n}", "path": "pbx\\ael\\ael_lex.c", "repo_name": "macntouch/callweaver", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 5884}
{"docstring": "/** Set the user-defined data. This data is never touched by the scanner.\n * @param user_defined The data to be associated with this scanner.\n * @param yyscanner The scanner object.\n */\n", "func_signal": "void ael_yyset_extra (YY_EXTRA_TYPE  user_defined , yyscan_t yyscanner)", "code": "{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n    yyextra = user_defined ;\n}", "path": "pbx\\ael\\ael_lex.c", "repo_name": "macntouch/callweaver", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 5884}
{"docstring": "/* used elsewhere, but some local vars */\n", "func_signal": "struct pval *ael2_parse(char *filename, int *errors)", "code": "{\n\tstruct pval *pval;\n\tstruct parse_io *io;\n\tchar *buffer;\n\tstruct stat stats;\n\tFILE *fin;\n\n\t/* extern int ael_yydebug; */\n\n\tio = calloc(sizeof(struct parse_io),1);\n\t/* reset the global counters */\n\tprev_word = 0;\n\tmy_lineno = 1;\n\tinclude_stack_index=0;\n\tmy_col = 0;\n\t/* ael_yydebug = 1; */\n\tael_yylex_init(&io->scanner);\n\tfin = fopen(filename,\"r\");\n\tif ( !fin ) {\n\t\tcw_log(LOG_ERROR,\"File %s could not be opened\\n\", filename);\n\t\t*errors = 1;\n\t\treturn 0;\n\t}\n\tmy_file = strdup(filename);\n\tstat(filename, &stats);\n\tbuffer = (char*)malloc(stats.st_size+2);\n\tfread(buffer, 1, stats.st_size, fin);\n\tbuffer[stats.st_size]=0;\n\tfclose(fin);\n\n\tael_yy_scan_string (buffer ,io->scanner);\n\tael_yyset_lineno(1 , io->scanner);\n\n\t/* ael_yyset_in (fin , io->scanner);\tOLD WAY */\n\n\tael_yyparse(io);\n\n\n\tpval = io->pval;\n\t*errors = io->syntax_error_count;\n\n\tael_yylex_destroy(io->scanner);\n\tfree(buffer);\n\tfree(io);\n\n\treturn pval;\n}", "path": "pbx\\ael\\ael_lex.c", "repo_name": "macntouch/callweaver", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 5884}
{"docstring": "/* Can't afford dynamically generate this char class so have separater func */\n", "func_signal": "static void get_token_sub_part_2(cst_tokenstream *ts,\n\t\t\t\t int endclass1,\n\t\t\t\t unsigned char **buffer,\n\t\t\t\t int *buffer_max)", "code": "{\n    int p;\n\n    for (p=0; ((ts->current_char != TS_EOF) &&\n               (!ts_charclass(ts->current_char,endclass1,ts)) &&\n\t       (!ts_charclass(ts->current_char,\n\t\t\t      TS_CHARCLASS_SINGLECHAR,ts)));\n         p++)\n    {\n\tif (p >= *buffer_max) extend_buffer(buffer,buffer_max);\n\t(*buffer)[p] = ts->current_char;\n\tts_getc(ts);\n    }\n    (*buffer)[p] = '\\0';\n}", "path": "src\\utils\\cst_tokenstream.c", "repo_name": "sergei/flite", "stars": 1, "license": "other", "language": "c", "size": 10580}
{"docstring": "/*\n *\tset up coefficient array\n */\n", "func_signal": "static void\nmake_coe(cst_rateconv *filt)", "code": "{\n\tint i, q;\n\n\tfilt->coep = cst_alloc(int, filt->len * filt->up);\n\tfor (i = 0; i < filt->len; i++) {\n\t    for (q = 0; q < filt->up; q++) {\n\t\tfilt->coep[q * filt->len + i]\n\t\t\t= coefficient(i, q, filt);\n\t    }\n\t}\n}", "path": "src\\speech\\rateconv.c", "repo_name": "sergei/flite", "stars": 1, "license": "other", "language": "c", "size": 10580}
{"docstring": "/* Adaptation of rjc's mapping of fsf format to henry spencer's format */\n/* of escape sequences, as taken from EST_Regex.cc in EST              */\n", "func_signal": "static char *regularize(const char *unregex,int match)", "code": "{\n    char *reg = cst_alloc(char, strlen(unregex)*2+3);\n    char *r=reg;\n    const char *e;\n    int magic=0,last_was_bs=0;\n    const char * in_brackets=NULL;\n    const char *ex = (unregex?unregex:\"\");\n\n    if (match && *ex != '^')\n\t*(r++) = '^';\n\n    for(e=ex; *e ; e++)\n    {\n\tif (*e == '\\\\' && !last_was_bs)\n\t{\n\t    last_was_bs=1;\n\t    continue;\n\t}\n\n\tmagic=strchr((last_was_bs?fsf_magic_backslashed:fsf_magic), *e)!=NULL;\n\n\tif (in_brackets)\n\t{\n\t    *(r++) = *e;\n\t    if (*e  == ']' && (e-in_brackets)>1)\n\t\tin_brackets=0;\n\t}\n\telse if (magic)\n\t{\n\t    if (strchr(spencer_magic_backslashed, *e))\n\t\t*(r++) = '\\\\';\n\n\t    *(r++) = *e;\n\t    if (*e  == '[')\n\t\tin_brackets=e;\n\t}\n\telse \n\t{\n\t    if (strchr(spencer_magic, *e))\n\t\t*(r++) = '\\\\';\n\n\t    *(r++) = *e;\n\t}\n\tlast_was_bs=0;\n    }\n  \n    if (match && (e==ex || *(e-1) != '$'))\n    {\n\tif (last_was_bs)\n\t    *(r++) = '\\\\';\n\t*(r++) = '$';\n    }\n\n    *r='\\0';\n\n    return reg;\n}", "path": "src\\regex\\cst_regex.c", "repo_name": "sergei/flite", "stars": 1, "license": "other", "language": "c", "size": 10580}
{"docstring": "/*\n *\tdo some conversion jobs and write\n */\n", "func_signal": "int\ncst_rateconv_out(cst_rateconv *filt, short *outptr, int max)", "code": "{\n\tint outsize;\n\n\tif ((outsize = filtering_on_buffers(filt)) == 0)\n\t\treturn 0;\n\tif (max > outsize)\n\t\tmax = outsize;\n\tint_to_sample((short *)filt->sout, max);\n\tmemcpy(outptr, filt->sout, max * sizeof(short));\n\treturn max;\n}", "path": "src\\speech\\rateconv.c", "repo_name": "sergei/flite", "stars": 1, "license": "other", "language": "c", "size": 10580}
{"docstring": "/*\n *\tevaluate coefficient from i, q=n%u by sampling interpolation function \n *\tand scale it for integer multiplication used by FIR-filtering\n */\n", "func_signal": "static int\ncoefficient(int i, int q, cst_rateconv *filt)", "code": "{\n\treturn (int)(FIXMUL * filt->gain *\n\t\t     interpol_func((fmod(q* filt->down/(double)filt->up,1.0)\n\t\t\t\t    + (filt->len-1)/2.0 - i) / filt->fsin,\n\t\t\t\t   filt->fgk, filt->fgg) / filt->fsin);\n}", "path": "src\\speech\\rateconv.c", "repo_name": "sergei/flite", "stars": 1, "license": "other", "language": "c", "size": 10580}
{"docstring": "/* carts are pretty confused about strings/ints, and some features */\n/* are actually used as floats and as int/strings                  */\n", "func_signal": "const cst_val *val_string_n(int n)", "code": "{\n    if (n < val_int_const_max) /* yes I mean *int*, its the table size */\n\treturn val_string_const[n];\n    else\n\treturn val_string_const[val_int_const_max-1];\n}", "path": "src\\utils\\cst_val_const.c", "repo_name": "sergei/flite", "stars": 1, "license": "other", "language": "c", "size": 10580}
{"docstring": "/********************************************************************/\n/*    List relation related functions                               */\n/********************************************************************/\n", "func_signal": "cst_item *item_next(const cst_item *i)", "code": "{\n    if (i == NULL)\n\treturn NULL;\n    else\n\treturn i->n;\n}", "path": "src\\hrg\\cst_item.c", "repo_name": "sergei/flite", "stars": 1, "license": "other", "language": "c", "size": 10580}
{"docstring": "/*\n *\tread and convert input sample format to integer\n */\n", "func_signal": "int\ncst_rateconv_in(cst_rateconv *filt, const short *inptr, int max)", "code": "{\n\tif (max > filt->insize - filt->lag)\n\t\tmax = filt->insize - filt->lag;\n\tif (max > 0) {\n\t\tmemcpy(filt->sin + filt->lag, inptr, max * sizeof(short));\n\t\tsample_to_int((short *)(filt->sin + filt->lag), max);\n\t}\n\tfilt->incount = max;\n\treturn max;\n}", "path": "src\\speech\\rateconv.c", "repo_name": "sergei/flite", "stars": 1, "license": "other", "language": "c", "size": 10580}
{"docstring": "/*\n *\tconvert buffer of n ints to samples\n */\n", "func_signal": "static void\nint_to_sample(short *buff, int n)", "code": "{\n\tint *s;\n\tshort *e, *d;\n\n\tif (n < 1)\n\t\treturn;\t\n\ts = (int *)buff;\n\td = buff;\n\te = buff + n;\n\twhile (d != e)\n\t\t*d++ = (*s++ >> FIXSHIFT);\n}", "path": "src\\speech\\rateconv.c", "repo_name": "sergei/flite", "stars": 1, "license": "other", "language": "c", "size": 10580}
{"docstring": "/*\n *\tFIR-routines, mono and stereo\n *\tthis is where we need all the MIPS\n */\n", "func_signal": "static void\nfir_mono(int *inp, int *coep, int firlen, int *outp)", "code": "{\n\tregister int akku = 0, *endp;\n\tint n1 = (firlen / 8) * 8, n0 = firlen % 8;\n\n\tendp = coep + n1;\n\twhile (coep != endp) {\n\t\takku += *inp++ * *coep++;\n\t\takku += *inp++ * *coep++;\n\t\takku += *inp++ * *coep++;\n\t\takku += *inp++ * *coep++;\n\t\takku += *inp++ * *coep++;\n\t\takku += *inp++ * *coep++;\n\t\takku += *inp++ * *coep++;\n\t\takku += *inp++ * *coep++;\n\t}\n\n\tendp = coep + n0;\n\twhile (coep != endp) {\n\t\takku += *inp++ * *coep++;\n\t}\n\t*outp = akku;\n}", "path": "src\\speech\\rateconv.c", "repo_name": "sergei/flite", "stars": 1, "license": "other", "language": "c", "size": 10580}
{"docstring": "// 1: thumb thunk\n// 0: arm thunk\n// -1: bad src\n", "func_signal": "static int choose_thunk(uintptr_t src, Boolean srcIsThumb)", "code": "{\n    if (srcIsThumb) {\n        uint16_t insn1 = swap16(*(uint16_t *)src);\n        uint16_t insn2 = swap16(*(uint16_t *)(src+2));\n        uint16_t opcode1 = insn1 >> 11;\n        uint16_t opcode2 = insn2 >> 11;\n        if (opcode1 == 0x001e  &&  opcode2 == 0x001f) {\n            // BL: Thumb->Thumb branch, use Thumb thunk\n            return thumb;\n        } else if (opcode1 == 0x001e  &&  opcode2 == 0x001d) {\n            // BLX: Thumb->ARM branch, use ARM thunk\n            return 0;\n        } else {\n            // unknown instruction\n            return -1;\n        }\n    } else {\n        uint32_t insn = swap32(*(uint32_t *)src);\n        uint32_t cond = (insn & 0xf0000000) >> 28;\n        uint32_t opcode = (insn & 0x0e000000) >> 25;\n        if (opcode == 0x05) {\n            if (cond == 0x0f) {\n                // BLX: ARM->Thumb branch, use Thumb thunk\n                return thumb;\n            } else {\n                // Bcc, BLcc: ARM->ARM branch, use ARM thunk\n                return 0;\n            }\n        } else {\n            // unknown instruction\n            return -1;\n        }\n    }\n}", "path": "palm\\m68k_flite\\peal.c", "repo_name": "sergei/flite", "stars": 1, "license": "other", "language": "c", "size": 10580}
{"docstring": "/* INDENT ON */\n", "func_signal": "double\n__kernel_tan(double x, double y, int iy)", "code": "{\n\tdouble z, r, v, w, s;\n\tint ix, hx;\n\n\thx = __HI(x);\t\t/* high word of x */\n\tix = hx & 0x7fffffff;\t\t\t/* high word of |x| */\n\tif (ix < 0x3e300000) {\t\t\t/* x < 2**-28 */\n\t\tif ((int) x == 0) {\t\t/* generate inexact */\n\t\t\tif (((ix | __LO(x)) | (iy + 1)) == 0)\n\t\t\t\treturn one / fabs(x);\n\t\t\telse {\n\t\t\t\tif (iy == 1)\n\t\t\t\t\treturn x;\n\t\t\t\telse {\t/* compute -1 / (x+y) carefully */\n\t\t\t\t\tdouble a, t;\n\n\t\t\t\t\tz = w = x + y;\n\t\t\t\t\t__LO(z) = 0;\n\t\t\t\t\tv = y - (z - x);\n\t\t\t\t\tt = a = -one / w;\n\t\t\t\t\t__LO(t) = 0;\n\t\t\t\t\ts = one + t * z;\n\t\t\t\t\treturn t + a * (s + t * v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (ix >= 0x3FE59428) {\t/* |x| >= 0.6744 */\n\t\tif (hx < 0) {\n\t\t\tx = -x;\n\t\t\ty = -y;\n\t\t}\n\t\tz = pio4 - x;\n\t\tw = pio4lo - y;\n\t\tx = z + w;\n\t\ty = 0.0;\n\t}\n\tz = x * x;\n\tw = z * z;\n\t/*\n\t * Break x^5*(T[1]+x^2*T[2]+...) into\n\t * x^5(T[1]+x^4*T[3]+...+x^20*T[11]) +\n\t * x^5(x^2*(T[2]+x^4*T[4]+...+x^22*[T12]))\n\t */\n\tr = T[1] + w * (T[3] + w * (T[5] + w * (T[7] + w * (T[9] +\n\t\tw * T[11]))));\n\tv = z * (T[2] + w * (T[4] + w * (T[6] + w * (T[8] + w * (T[10] +\n\t\tw * T[12])))));\n\ts = z * x;\n\tr = y + z * (s * (r + v) + y);\n\tr += T[0] * s;\n\tw = x + r;\n\tif (ix >= 0x3FE59428) {\n\t\tv = (double) iy;\n\t\treturn (double) (1 - ((hx >> 30) & 2)) *\n\t\t\t(v - 2.0 * (x - (w * w / (w + v) - r)));\n\t}\n\tif (iy == 1)\n\t\treturn w;\n\telse {\n\t\t/*\n\t\t * if allow error up to 2 ulp, simply return\n\t\t * -1.0 / (x+r) here\n\t\t */\n\t\t/* compute -1.0 / (x+r) accurately */\n\t\tdouble a, t;\n\t\tz = w;\n\t\t__LO(z) = 0;\n\t\tv = r - (z - x);\t/* z+v = r+x */\n\t\tt = a = -1.0 / w;\t/* a = -1.0/w */\n\t\t__LO(t) = 0;\n\t\ts = 1.0 + t * z;\n\t\treturn t + a * (s + t * v);\n\t}\n}", "path": "palm\\fdlibm\\k_tan.c", "repo_name": "sergei/flite", "stars": 1, "license": "other", "language": "c", "size": 10580}
{"docstring": "/********************************************************************/\n/*    Tree relation related functions                               */\n/********************************************************************/\n", "func_signal": "cst_item *item_parent(const cst_item *i)", "code": "{\n    const cst_item *n;\n\n    for (n=i; item_prev(n); n=item_prev(n));\n    if (n == NULL)\n\treturn NULL;\n    else \n\treturn n->u;\n}", "path": "src\\hrg\\cst_item.c", "repo_name": "sergei/flite", "stars": 1, "license": "other", "language": "c", "size": 10580}
{"docstring": "/* Accessor functions */\n", "func_signal": "int val_int(const cst_val *v)", "code": "{\n    if (v && (CST_VAL_TYPE(v) == CST_VAL_TYPE_INT))\n\treturn CST_VAL_INT(v);\n    else if (v && (CST_VAL_TYPE(v) == CST_VAL_TYPE_FLOAT))\n\treturn (int)CST_VAL_FLOAT(v);\n    else if (v && (CST_VAL_TYPE(v) == CST_VAL_TYPE_STRING))\n\treturn atoi(CST_VAL_STRING(v));\n    else\n    {\n\tcst_errmsg(\"VAL: tried to access int in %d typed val\\n\",\n\t\t   (v ? CST_VAL_TYPE(v) : -1));\n\tcst_error();\n    }\n    return 0;\n}", "path": "src\\utils\\cst_val.c", "repo_name": "sergei/flite", "stars": 1, "license": "other", "language": "c", "size": 10580}
{"docstring": "/*\n** This routine converts from ulaw to 16 bit linear.\n**\n** Craig Reese: IDA/Supercomputing Research Center\n** 29 September 1989\n**\n** References:\n** 1) CCITT Recommendation G.711  (very difficult to follow)\n** 2) MIL-STD-188-113,\"Interoperability and Performance Standards\n**     for Analog-to_Digital Conversion Techniques,\"\n**     17 February 1987\n**\n** Input: 8 bit ulaw sample\n** Output: signed 16 bit linear sample\n*/\n", "func_signal": "short cst_ulaw_to_short( unsigned char ulawbyte )", "code": "{\n    static const int exp_lut[8] = { 0, 132, 396, 924, 1980, 4092, 8316, 16764 };\n    int sign, exponent, mantissa;\n    short sample;\n\n    ulawbyte = ~ ulawbyte;\n    sign = ( ulawbyte & 0x80 );\n    exponent = ( ulawbyte >> 4 ) & 0x07;\n    mantissa = ulawbyte & 0x0F;\n    sample = exp_lut[exponent] + ( mantissa << ( exponent + 3 ) );\n    if ( sign != 0 ) sample = -sample;\n\n    return sample;\n}", "path": "src\\speech\\cst_wave_utils.c", "repo_name": "sergei/flite", "stars": 1, "license": "other", "language": "c", "size": 10580}
{"docstring": "/*\n *\tconvert buffer of n samples to ints\n */\n", "func_signal": "static void\nsample_to_int(short *buff, int n)", "code": "{\n\tshort *s, *e;\n\tint *d;\n\n\tif (n < 1)\n\t\treturn;\t\n\ts = buff + n;\n\td = (int*)buff + n;\n\te = buff;\n\twhile (s != e) {\n\t\t*--d = (int)(*--s); \n\t}\n}", "path": "src\\speech\\rateconv.c", "repo_name": "sergei/flite", "stars": 1, "license": "other", "language": "c", "size": 10580}
{"docstring": "/* Define functions for using items, rels and utts as vals */\n", "func_signal": "CST_VAL_REGISTER_TYPE_NODEL(relation,cst_relation)\nCST_VAL_REGISTER_TYPE_NODEL(item,cst_item)\nCST_VAL_REGISTER_TYPE(utterance,cst_utterance)\nCST_VAL_REGISTER_FUNCPTR(itemfunc,cst_itemfunc)\n\ncst_item *new_item_relation(cst_relation *r,cst_item *i)", "code": "{\n    cst_item *ni;\n\n    ni = cst_utt_alloc(r->utterance, cst_item, 1);\n    ni->contents = 0;\n    ni->n = ni->p = ni->u = ni->d = 0;\n    ni->relation = r;\n    item_contents_set(ni,i);\n    return ni;\n}", "path": "src\\hrg\\cst_item.c", "repo_name": "sergei/flite", "stars": 1, "license": "other", "language": "c", "size": 10580}
{"docstring": "/* utterance functions are the modules that do the meat in synthesis */\n", "func_signal": "CST_VAL_REGISTER_FUNCPTR(uttfunc,cst_uttfunc)\n\ncst_utterance *new_utterance()", "code": "{\n    cst_utterance *u;\n\n    u = cst_alloc(struct cst_utterance_struct,1);\n    u->ctx = new_alloc_context(128*1024);\n\n    u->features = new_features_local(u->ctx);\n    u->ffunctions = new_features_local(u->ctx);\n    u->relations = new_features_local(u->ctx);\n\n    return u;\n}", "path": "src\\hrg\\cst_utterance.c", "repo_name": "sergei/flite", "stars": 1, "license": "other", "language": "c", "size": 10580}
{"docstring": "/*\n * \tfiltering from input buffer to output buffer;\n *\treturns number of processed samples in output buffer:\n *\tif it is not equal to output buffer size,\n *\tthe input buffer is expected to be refilled upon entry, so that\n *\tthe last firlen numbers of the old input buffer are\n *\tthe first firlen numbers of the new input buffer;\n *\tif it is equal to output buffer size, the output buffer\n *\tis full and is expected to be stowed away;\n *\n */\n", "func_signal": "static int\nfiltering_on_buffers(cst_rateconv *filt)", "code": "{\n\tint insize;\n\n\tDPRINTF(0, (\"filtering_on_buffers(%d)\\n\", filt->incount));\n\tinsize = filt->incount + filt->lag;\n\tif (filt->channels == 1) {\n\t\twhile (1) {\n\t\t\tfilt->inoffset = (filt->cycctr * filt->down)/filt->up;\n\t\t\tif ((filt->inbaseidx + filt->inoffset + filt->len) > insize) {\n\t\t\t\tfilt->inbaseidx -= insize - filt->len + 1;\n\t\t\t\tmemcpy(filt->sin, filt->sin + insize - filt->lag,\n\t\t\t\t       filt->lag * sizeof(int));\n\t\t\t\t/* Prevent people from re-filtering the same stuff. */\n\t\t\t\tfilt->incount = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfir_mono(filt->sin + filt->inoffset + filt->inbaseidx,\n\t\t\t\t filt->coep + filt->cycctr * filt->len,\n\t\t\t\t filt->len, filt->sout + filt->outidx);\n\t\t\tDPRINTF(1, (\"in(%d + %d) = %d cycctr %d out(%d) = %d\\n\",\n\t\t\t\t    filt->inoffset, filt->inbaseidx,\n\t\t\t\t    filt->sin[filt->inoffset + filt->inbaseidx],\n\t\t\t\t    filt->cycctr, filt->outidx,\n\t\t\t\t    filt->sout[filt->outidx] >> FIXSHIFT));\n\t\t\t++filt->outidx;\n\t\t\t++filt->cycctr;\n\t\t\tif (!(filt->cycctr %= filt->up))\n\t\t\t\tfilt->inbaseidx += filt->down;\n\t\t\tif (!(filt->outidx %= filt->outsize))\n\t\t\t\treturn filt->outsize;\n\t\t}\n\t} else if (filt->channels == 2) {\n\t\t/*\n\t\t * rule how to convert mono routine to stereo routine:\n\t\t * firlen, up, down and cycctr relate to samples in general,\n\t\t * wether mono or stereo; inbaseidx, inoffset and outidx as\n\t\t * well as insize and outsize still account for mono samples.\n\t\t */\n\t\twhile (1) {\n\t\t\tfilt->inoffset = 2*((filt->cycctr * filt->down)/filt->up);\n\t\t\tif ((filt->inbaseidx + filt->inoffset + 2*filt->len) > insize) {\n\t\t\t\tfilt->inbaseidx -= insize - 2*filt->len + 2;\n\t\t\t\treturn filt->outidx;\n\t\t\t}\n\t\t\tfir_stereo(filt->sin + filt->inoffset + filt->inbaseidx,\n\t\t\t\t   filt->coep + filt->cycctr * filt->len,\n\t\t\t\t   filt->len,\n\t\t\t\t   filt->sout + filt->outidx,\n\t\t\t\t   filt->sout + filt->outidx + 1);\n\t\t\tfilt->outidx += 2;\n\t\t\t++filt->cycctr;\n\t\t\tif (!(filt->cycctr %= filt->up))\n\t\t\t\tfilt->inbaseidx += 2*filt->down;\n\t\t\tif (!(filt->outidx %= filt->outsize))\n\t\t\t\treturn filt->outsize;\n\t\t}\n\t} else {\n\t\tcst_errmsg(\"filtering_on_buffers: only 1 or 2 channels supported!\\n\");\n\t\tcst_error();\n\t}\n\treturn 0;\n}", "path": "src\\speech\\rateconv.c", "repo_name": "sergei/flite", "stars": 1, "license": "other", "language": "c", "size": 10580}
{"docstring": "/* Dummy F0 modelling for phones, copied directly from us_f0_model.c */\n", "func_signal": "cst_utterance *flat_prosody(cst_utterance *u)", "code": "{\n    /* F0 target model */\n    cst_item *s,*t;\n    cst_relation *targ_rel;\n    float mean, stddev;\n\n    targ_rel = utt_relation_create(u,\"Target\");\n    mean = get_param_float(u->features,\"target_f0_mean\", 100.0);\n    mean *= get_param_float(u->features,\"f0_shift\", 1.0);\n    stddev = get_param_float(u->features,\"target_f0_stddev\", 12.0);\n\n    s=relation_head(utt_relation(u,\"Segment\"));\n    t = relation_append(targ_rel,NULL);\n    item_set_float(t,\"pos\",0.0);\n    item_set_float(t,\"f0\",mean+stddev);\n\n    s=relation_tail(utt_relation(u,\"Segment\"));\n    t = relation_append(targ_rel,NULL);\n\n    item_set_float(t,\"pos\",item_feat_float(s,\"end\"));\n    item_set_float(t,\"f0\",mean-stddev);\n\n    return u;\n}", "path": "src\\synth\\cst_synth.c", "repo_name": "sergei/flite", "stars": 1, "license": "other", "language": "c", "size": 10580}
{"docstring": "// Return a pointer to the first occurrence of 'c' in 's',\n// or a null pointer if the string has no 'c'.\n", "func_signal": "char *\nstrchr(const char *s, char c)", "code": "{\n\tfor (; *s; s++)\n\t\tif (*s == c)\n\t\t\treturn (char *) s;\n\treturn 0;\n}", "path": "lib\\string.c", "repo_name": "donguoxing/Lab2", "stars": 1, "license": "None", "language": "c", "size": 444}
{"docstring": "// Initialize page structure and memory free list.\n// After this point, ONLY use the page_ functions\n// to allocate and deallocate physical memory via the free_pages list,\n// and NEVER use boot_alloc() or the related boot-time functions above.\n", "func_signal": "void\npage_init(void)", "code": "{\n\t// The example code here marks all pages as free.\n\t// However this is not truly the case.  What memory is free?\n\t//  1) Mark page 0 as in use.\n\t//     This way we preserve the real-mode IDT and BIOS structures\n\t//     in case we ever need them.  (Currently we don't, but...)\n\t//  2) Mark the rest of base memory as free.\n\t//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM).\n\t//     Mark it as in use so that it can never be allocated.      \n\t//  4) Then extended memory [EXTPHYSMEM, ...).\n\t//     Some of it is in use, some is free.  Where is the kernel?\n\t//     Which pages are used for page tables and other data structures\n\t//     allocated by boot_alloc()?  (Hint: boot_alloc() will tell you\n\t//     if you give it the right argument!)\n\t//\n\t// Change the code to reflect this.\n\t//struct Page *page_begin, *page_end;\n\t//page_begin = &pages[IOPHYSMEM/PGSIZE];\n\t//page_end = boot_alloc(0);\n\tunsigned int pbegin, pend;\n\t//page's number which map IOPHYSMEM \n\tpbegin = PGNUM(IOPHYSMEM);\n\t//last page had been allocated in extended memory\n\tpend = PGNUM(PADDR(boot_alloc(0))) + 1;\n\tfor (size_t i = 0; i < npages; i++)\n\t{\n\t        // Initialize the page structure\n\t\t// Mark page0 in use\n\t\tif(i == 0)\n\t\t{\n\t\tpages[i].pp_ref = 1;\n\t\tcontinue;\n\t\t}\n\t\t//Mark IO hole and pages allocate by boot_alloc(0);\n\t\tif(i >= pbegin && i < pend)\n\t\t{\n\t\tpages[i].pp_ref = 1;\n\t\tcontinue;\n\t\t}\n\t\tpages[i].pp_ref = 0;\n\t\t//Add the free pages into the link free_pages\n\t\tpages[i].pp_next = free_pages;\n\t\tfree_pages = &pages[i];\n\t}\n}", "path": "kern\\pmap.c", "repo_name": "donguoxing/Lab2", "stars": 1, "license": "None", "language": "c", "size": 444}
{"docstring": "// Map [la, la+size) of linear address space to physical [pa, pa+size)\n// in the kernel's page table 'kern_pgdir'.  Size is a multiple of PGSIZE.\n// Use permission bits perm|PTE_P for the entries.\n//\n// This function resembles page_insert(), but is meant for use at boot time on\n// reserved portions of physical memory.\n// There's no need here to manage page reference counts or invalidate the TLB.\n", "func_signal": "static void\npage_map_segment(pte_t *pgdir, uintptr_t la, size_t size, physaddr_t pa,\n\t\t int perm)", "code": "{\n\t// LAB 2: Your code here.\n\tsize_t index;\n\tpte_t *ppte;\n\tassert((la & (PGSIZE - 1)) == 0 );\n\tassert((pa & (PGSIZE - 1)) == 0 );\n\t// Ensure size is a multiple of PGSIZE\n\tsize = round_up(size, PGSIZE);\n\t// Map linear address to physical\n\tfor(index = 0; index < size; index += PGSIZE)\n\t{\n\t\tppte = pgdir_walk(pgdir, (la + index), 1);\n\t\tassert(ppte != NULL);\n\t\t// Set permission of PTE\n\t\t(*ppte) = (pa + index) | perm | PTE_P;\n\t}\n\treturn;\n}", "path": "kern\\pmap.c", "repo_name": "donguoxing/Lab2", "stars": 1, "license": "None", "language": "c", "size": 444}
{"docstring": "// Maps the physical page 'pp' at virtual address 'va'.\n// The permissions (the low 12 bits) of the page table entry\n// are set to 'perm|PTE_P'.\n//\n// Details\n//   - If there is already a page mapped at 'va', it is page_remove()d.\n//   - If necessary, on demand, allocates a page table and inserts it into\n//     'pgdir'.\n//   - pp->pp_ref should be incremented if the insertion succeeds.\n//   - The TLB must be invalidated if a page was formerly present at 'va'.\n//   - It is safe to page_insert() a page that is already mapped at 'va'.\n//     This is useful to change permissions for a page.\n//\n// RETURNS: \n//   0 on success\n//   -E_NO_MEM, if page table couldn't be allocated\n//\n// Hint: The TA solution is implemented using pgdir_walk, page_remove,\n// and Page::physaddr.\n", "func_signal": "int\npage_insert(pde_t *pgdir, struct Page *pp, uintptr_t va, int perm)", "code": "{\n\t// Fill this function in\n\tpte_t *ppte = pgdir_walk(pgdir, va, 1);\n\t// Allocate page failed\n\tif(ppte == NULL)\n\t\treturn -E_NO_MEM;\n\tif(((*ppte) & PTE_P) != 0)\n\t{\n\t\t// Already page mapped, need be removed\n\t\tif(PTE_ADDR(*ppte) != pp->physaddr())\n\t\tpage_remove(pgdir, va);\n\t\telse\n\t\tpp->pp_ref--;\n\t}\n\t// Set permissions\n\t*ppte = pp->physaddr() | perm | PTE_P;\n\tpp->pp_ref++;\n\t// invalidate TLB of former page at 'va'\n\ttlb_invalidate(pgdir, va);\n\treturn 0;\n}", "path": "kern\\pmap.c", "repo_name": "donguoxing/Lab2", "stars": 1, "license": "None", "language": "c", "size": 444}
{"docstring": "// Allocate a physical page, without necessarily initializing it.\n// Returns a pointer to the Page struct of the newly allocated page.\n// If there were no free pages, returns NULL.\n//\n// Hint: set the Page's fields appropriately\n// Hint: the returned page's pp_ref should be zero\n// Software Engineering Hint: It can be extremely useful for later debugging\n//   if you erase allocated memory.  For instance, you might write the value\n//   0xCC (the int3 instruction) over the page before you return it.  This will\n//   cause your kernel to crash QUICKLY if you ever make a bookkeeping mistake,\n//   such as freeing a page while someone is still using it.  A quick crash is\n//   much preferable to a SLOW crash, where *maybe* a long time after your\n//   kernel boots, a data structure gets corrupted because its containing page\n//   was used twice!  Note that erasing the page with a non-zero value is\n//   usually better than erasing it with 0.  (Why might this be?)\n", "func_signal": "struct Page *\npage_alloc()", "code": "{\n\t// Fill this function in\n\tstruct Page * alloc_page;\n\tif (free_pages == NULL)\n\treturn NULL;\n\t// Get a free page from link free_pages, but no initial\n\talloc_page = free_pages;\n\t// Delete allocted page from link free_pages\n\tfree_pages = free_pages->pp_next;\n\talloc_page->pp_next = NULL;\n\t// Erase allocted memory\n\tmemset(alloc_page->data(), 0xCC, sizeof(*alloc_page));\n\treturn alloc_page;\n}", "path": "kern\\pmap.c", "repo_name": "donguoxing/Lab2", "stars": 1, "license": "None", "language": "c", "size": 444}
{"docstring": "// Read 'filesz' bytes at 'offset' from kernel into virtual address 'va',\n// then clear the memory from 'va+filesz' up to 'va+memsz' (set it to 0).\n", "func_signal": "void\nreadseg(uint32_t va, uint32_t filesz, uint32_t memsz, uint32_t offset)", "code": "{\n\tuint32_t end_va;\n\n\tva &= 0xFFFFFF;\n\tend_va = va + filesz;\n\tmemsz += va;\n\t\n\t// round down to sector boundary\n\tva &= ~(SECTSIZE - 1);\n\n\t// translate from bytes to sectors, and kernel starts at sector 1\n\toffset = (offset / SECTSIZE) + 1;\n\n\t// read sectors\n\twhile (va < end_va) {\n\t\treadsect((uint8_t*) va, offset);\n\t\tva += SECTSIZE;\n\t\toffset++;\n\t}\n\n\t// clear bss segment\n\twhile (end_va < memsz)\n\t\t*((uint8_t*) end_va++) = 0;\n}", "path": "boot\\main.c", "repo_name": "donguoxing/Lab2", "stars": 1, "license": "None", "language": "c", "size": 444}
{"docstring": "// Decrement the reference count on a page.\n// Free it if there are no more refs afterwards.\n", "func_signal": "void\npage_decref(struct Page *pp)", "code": "{\n\tif (--pp->pp_ref == 0)\n\t\tpage_free(pp);\n}", "path": "kern\\pmap.c", "repo_name": "donguoxing/Lab2", "stars": 1, "license": "None", "language": "c", "size": 444}
{"docstring": "// debuginfo_eip(addr, info)\n//\n//\tFill in the 'info' structure with information about the specified\n//\tinstruction address, 'addr'.  Returns 0 if information was found, and\n//\tnegative if not.  But even if it returns negative it has stored some\n//\tinformation into '*info'.\n//\n", "func_signal": "int\ndebuginfo_eip(uintptr_t addr, struct Eipdebuginfo *info)", "code": "{\n\tconst struct Stab *stabs, *stab_end;\n\tconst char *stabstr, *stabstr_end;\n\tint lfile, rfile, lfun, rfun, lline, rline;\n\n\t// Initialize *info\n\tinfo->eip_file = \"<unknown>\";\n\tinfo->eip_line = 0;\n\tinfo->eip_fn_name = \"<unknown>\";\n\tinfo->eip_fn_namelen = 9;\n\tinfo->eip_fn_addr = addr;\n\tinfo->eip_fn_narg = 0;\n\n\t// Find the relevant set of stabs\n\tif (addr >= ULIM) {\n\t\tstabs = __STAB_BEGIN__;\n\t\tstab_end = __STAB_END__;\n\t\tstabstr = __STABSTR_BEGIN__;\n\t\tstabstr_end = __STABSTR_END__;\n\t} else {\n\t\t// Can't search for user-level addresses yet!\n  \t        panic(\"User address\");\n\t}\n\n\t// String table validity checks\n\tif (stabstr_end <= stabstr || stabstr_end[-1] != 0)\n\t\treturn -1;\n\n\t// Now we find the right stabs that define the function containing\n\t// 'eip'.  First, we find the basic source file containing 'eip'.\n\t// Then, we look in that source file for the function.  Then we look\n\t// for the line number.\n\t\n\t// Search the entire set of stabs for the source file (type N_SO).\n\tlfile = 0;\n\trfile = (stab_end - stabs) - 1;\n\tstab_binsearch(stabs, &lfile, &rfile, N_SO, addr);\n\tif (lfile == 0)\n\t\treturn -1;\n\n\t// Search within that file's stabs for the function definition\n\t// (N_FUN).\n\tlfun = lfile;\n\trfun = rfile;\n\tstab_binsearch(stabs, &lfun, &rfun, N_FUN, addr);\n\n\tif (lfun <= rfun) {\n\t\t// stabs[lfun] points to the function name\n\t\t// in the string table, but check bounds just in case.\n\t\tif (stabs[lfun].n_strx < (uint32_t) (stabstr_end - stabstr))\n\t\t\tinfo->eip_fn_name = stabstr + stabs[lfun].n_strx;\n\t\tinfo->eip_fn_addr = stabs[lfun].n_value;\n\t\taddr -= info->eip_fn_addr;\n\t\t// Search within the function definition for the line number.\n\t\tlline = lfun;\n\t\trline = rfun;\n\t} else {\n\t\t// Couldn't find function stab!  Maybe we're in an assembly\n\t\t// file.  Search the whole file for the line number.\n\t\tinfo->eip_fn_addr = addr;\n\t\tlline = lfile;\n\t\trline = rfile;\n\t}\n\t// Ignore stuff after the colon.\n\tinfo->eip_fn_namelen =\n\t\tstrfind(info->eip_fn_name, ':') - info->eip_fn_name;\n\n\t\n\t// Search within [lline, rline] for the line number stab.\n\t// If found, set info->eip_line to the right line number.\n\t// If not found, return -1.\n\t//\n\t// Hint:\n\t//\tThere's a particular stabs type used for line numbers.\n\t//\tLook at the STABS documentation and <inc/stab.h> to find\n\t//\twhich one.\n\t// Your code here.\n\tstab_binsearch(stabs, &lline, &rline, N_SLINE, addr);\n     \tif(lline <= rline)\n              info->eip_line = stabs[lline].n_desc;\n\telse\n\t      return -1;\n\t\n\t// Search backwards from the line number for the relevant filename\n\t// stab.\n\t// We can't just use the \"lfile\" stab because inlined functions\n\t// can interpolate code from a different file!\n\t// Such included source files use the N_SOL stab type.\n\twhile (lline >= lfile\n\t       && stabs[lline].n_type != N_SOL\n\t       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))\n\t\tlline--;\n\tif (lline >= lfile\n\t    && stabs[lline].n_strx < (uint32_t) (stabstr_end - stabstr))\n\t\tinfo->eip_file = stabstr + stabs[lline].n_strx;\n\n\n\t// Set eip_fn_narg to the number of arguments taken by the function,\n\t// or 0 if there was no containing function.\n\t// Your code here.\n \tif (lfun < rfun)\n   \tfor (lline = lfun + 1; lline < rfun && stabs[lline].n_type == N_PSYM; lline++)\n\t    info->eip_fn_narg++;\n\treturn 0;\n}", "path": "kern\\kdebug.c", "repo_name": "donguoxing/Lab2", "stars": 1, "license": "None", "language": "c", "size": 444}
{"docstring": "// Check the physical page allocator (page_alloc(), page_free(),\n// and page_init()).\n", "func_signal": "static void\npage_alloc_check()", "code": "{\n\tstruct Page *pp, *pp0, *pp1, *pp2, *fl;\n\t\n        // if there's a page that shouldn't be on\n        // the free list, try to make sure it\n        // eventually causes trouble.\n\tfor (pp0 = free_pages; pp0; pp0 = pp0->pp_next)\n\t\tmemset(pp0->data(), 0x97, 128);\n\n\t// should be able to allocate three pages\n\tpp0 = page_alloc();\n\tpp1 = page_alloc();\n\tpp2 = page_alloc();\n\tassert(pp0);\n\tassert(pp1 && pp1 != pp0);\n\tassert(pp2 && pp2 != pp1 && pp2 != pp0);\n        assert(pp0->page_number() < npages);\n        assert(pp1->page_number() < npages);\n        assert(pp2->page_number() < npages);\n\n\t// temporarily steal the rest of the free pages\n\tfl = free_pages;\n\tfree_pages = NULL;\n\n\t// should be no free memory\n\tpp = page_alloc();\n\tassert(pp == NULL);\n\n        // free and re-allocate?\n        page_free(pp0);\n        page_free(pp1);\n        page_free(pp2);\n\tpp0 = page_alloc();\n\tpp1 = page_alloc();\n\tpp2 = page_alloc();\n\tassert(pp0);\n\tassert(pp1 && pp1 != pp0);\n\tassert(pp2 && pp2 != pp1 && pp2 != pp0);\n\tpp = page_alloc();\n\tassert(pp == NULL);\n\n\t// give free list back\n\tfree_pages = fl;\n\n\t// free the pages we took\n\tpage_free(pp0);\n\tpage_free(pp1);\n\tpage_free(pp2);\n\n\tcprintf(\"page_alloc_check() succeeded!\\n\");\n}", "path": "kern\\pmap.c", "repo_name": "donguoxing/Lab2", "stars": 1, "license": "None", "language": "c", "size": 444}
{"docstring": "// return the next input character from the console, or 0 if none waiting\n", "func_signal": "int\ncons_getc(void)", "code": "{\n\tint c;\n\n\t// poll for any pending input characters,\n\t// so that this function works even when interrupts are disabled\n\t// (e.g., when called from the kernel monitor).\n\tserial_intr();\n\tkbd_intr();\n\n\t// grab the next character from the input buffer.\n\tif (cons.rpos != cons.wpos) {\n\t\tc = cons.buf[cons.rpos++];\n\t\tif (cons.rpos == CONSBUFSIZE)\n\t\t\tcons.rpos = 0;\n\t\treturn c;\n\t}\n\treturn 0;\n}", "path": "kern\\console.c", "repo_name": "donguoxing/Lab2", "stars": 1, "license": "None", "language": "c", "size": 444}
{"docstring": "// Copy one screen's worth of data to or from the save buffer,\n// starting at line 'first_line'.\n", "func_signal": "static void\ncga_savebuf_copy(int first_line, bool to_screen)", "code": "{\n\t// Calculate the beginning & end of the save buffer area.\n\tuint16_t *pos = crtsave_buf + (first_line % CRT_SAVEROWS) * CRT_COLS;\n\tuint16_t *end = pos + CRT_ROWS * CRT_COLS;\n\t// Check for wraparound.\n\tuint16_t *trueend = min(end, crtsave_buf + CRT_SAVEROWS * CRT_COLS);\n\n\t// Copy the initial portion.\n\tif (to_screen)\n\t\tmemcpy(crt_buf, pos, (trueend - pos) * sizeof(uint16_t));\n\telse\n\t\tmemcpy(pos, crt_buf, (trueend - pos) * sizeof(uint16_t));\n\n\t// If there was wraparound, copy the second part of the screen.\n\tif (end == trueend)\n\t\t/* do nothing */;\n\telse if (to_screen)\n\t\tmemcpy(crt_buf + (trueend - pos), crtsave_buf, (end - trueend) * sizeof(uint16_t));\n\telse\n\t\tmemcpy(crtsave_buf, crt_buf + (trueend - pos), (end - trueend) * sizeof(uint16_t));\n}", "path": "kern\\console.c", "repo_name": "donguoxing/Lab2", "stars": 1, "license": "None", "language": "c", "size": 444}
{"docstring": "// Stupid I/O delay routine necessitated by historical PC design flaws\n", "func_signal": "static void\ndelay(void)", "code": "{\n\tinb(0x84);\n\tinb(0x84);\n\tinb(0x84);\n\tinb(0x84);\n}", "path": "kern\\console.c", "repo_name": "donguoxing/Lab2", "stars": 1, "license": "None", "language": "c", "size": 444}
{"docstring": "/* rightmost stab */\n//\t\tstab_binsearch(stabs, &left, &right, type, addr);\n//\n//\tThe search modifies *region_left and *region_right to bracket the\n//\t'addr'.  *region_left points to the matching stab that contains\n//\t'addr', and *region_right points just before the next stab.  If\n//\t*region_left > *region_right, then 'addr' is not contained in any\n//\tmatching stab.\n//\n//\tFor example, given these N_SO stabs:\n//\t\tIndex  Type   Address\n//\t\t0      SO     f0100000\n//\t\t13     SO     f0100040\n//\t\t117    SO     f0100176\n//\t\t118    SO     f0100178\n//\t\t555    SO     f0100652\n//\t\t556    SO     f0100654\n//\t\t657    SO     f0100849\n//\tthis code:\n//\t\tleft = 0, right = 657;\n//\t\tstab_binsearch(stabs, &left, &right, N_SO, 0xf0100184);\n//\twill exit setting left = 118, right = 554.\n//\n", "func_signal": "static void\nstab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,\n\t       int type, uintptr_t addr)", "code": "{\n\tint l = *region_left, r = *region_right, any_matches = 0;\n\t\n\twhile (l <= r) {\n\t\tint true_m = (l + r) / 2, m = true_m;\n\t\t\n\t\t// search for earliest stab with right type\n\t\twhile (m >= l && stabs[m].n_type != type)\n\t\t\tm--;\n\t\tif (m < l) {\t// no match in [l, m]\n\t\t\tl = true_m + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// actual binary search\n\t\tany_matches = 1;\n\t\tif (stabs[m].n_value < addr) {\n\t\t\t*region_left = m;\n\t\t\tl = true_m + 1;\n\t\t} else if (stabs[m].n_value > addr) {\n\t\t\t*region_right = m - 1;\n\t\t\tr = m - 1;\n\t\t} else {\n\t\t\t// exact match for 'addr', but continue loop to find\n\t\t\t// *region_right\n\t\t\t*region_left = m;\n\t\t\tl = m;\n\t\t\taddr++;\n\t\t}\n\t}\n\n\tif (!any_matches)\n\t\t*region_right = *region_left - 1;\n\telse {\n\t\t// find rightmost region containing 'addr'\n\t\tfor (l = *region_right;\n\t\t     l > *region_left && stabs[l].n_type != type;\n\t\t     l--)\n\t\t\t/* do nothing */;\n\t\t*region_left = l;\n\t}\n}", "path": "kern\\kdebug.c", "repo_name": "donguoxing/Lab2", "stars": 1, "license": "None", "language": "c", "size": 444}
{"docstring": "// output a character to the console\n", "func_signal": "void\ncons_putc(int c)", "code": "{\n\tlpt_putc(c);\n\tcga_putc(c);\n}", "path": "kern\\console.c", "repo_name": "donguoxing/Lab2", "stars": 1, "license": "None", "language": "c", "size": 444}
{"docstring": "// Returns the page mapped at virtual address 'va'.\n// If pte_store is not null, then '*pte_store' is set to the address\n// of the pte for this page.  This is used by page_remove.\n//\n// Returns 0 if there is no page mapped at va.\n//\n// Hint: the TA solution uses pgdir_walk.\n", "func_signal": "struct Page *\npage_lookup(pde_t *pgdir, uintptr_t va, pte_t **pte_store)", "code": "{\n\t// Fill this function in\n\t// Lookup virtual address 'va' in page direction\n\tpte_t *ppte = pgdir_walk(pgdir, va, 0);\n\tif(ppte == NULL)\n\t\treturn NULL;\n\t// Set '*pte_store' to the address of the pte\n\tif(pte_store != NULL)\n\t\t(*pte_store) = ppte;\n\t// Return the mapped page address\n\tif(*ppte & PTE_P)\n\t\treturn &pages[PGNUM(*ppte)];\n\treturn NULL;\n}", "path": "kern\\pmap.c", "repo_name": "donguoxing/Lab2", "stars": 1, "license": "None", "language": "c", "size": 444}
{"docstring": "// Given 'pgdir', a pointer to a page directory, pgdir_walk returns\n// a pointer to the page table entry (PTE) for linear address 'va'.\n// This requires walking the two-level page table structure.\n//\n// If the relevant page table doesn't exist in the page directory, then:\n//    - If create == 0, pgdir_walk returns NULL.\n//    - Otherwise, pgdir_walk tries to allocate a new page table\n//\twith page_alloc.  If this fails, pgdir_walk returns NULL.\n//    - Otherwise, pgdir_walk returns a pointer into the new page table.\n//\n// Hint: you can turn a Page * into the physical address of the\n// page it refers to with Page::physaddr() from inc/memlayout.h.\n", "func_signal": "pte_t *\npgdir_walk(pde_t *pgdir, uintptr_t va, int create)", "code": "{\n\t// Fill this function in\n\tstruct Page *newpage;\n\t// If find, return the pointer to the page table entry(PTE)\n\tif((pgdir[PDX(va)] & PTE_P) != 0)\n\treturn &(((pte_t *)KADDR(PTE_ADDR(pgdir[PDX(va)])))[PTX(va)]); \n\t// If create == 0, pgdir_walk returns NULL\n\telse if(create == 0)\n\t\treturn NULL;\n\t     else\n\t\t{\n\t// Allocate a new page table\n\t\tnewpage = page_alloc();\n\t\tif(!newpage)\n\t\t\treturn NULL;\n\t\tnewpage->pp_ref++;\n\t\tmemset(newpage->data(), 0, PGSIZE);\n\t\tpgdir[PDX(va)] = newpage->physaddr() | PTE_P | PTE_U | PTE_W;\n\t// Return the new page entry pointer\n\t\treturn &(((pte_t *)KADDR(PTE_ADDR(pgdir[PDX(va)])))[PTX(va)]);\n\t\t}\t\n\treturn NULL;\n}", "path": "kern\\pmap.c", "repo_name": "donguoxing/Lab2", "stars": 1, "license": "None", "language": "c", "size": 444}
{"docstring": "// Return a page to the free list.\n// (This function should only be called when pp->pp_ref reaches 0:\n// you may want to check this with an assert.)\n//\n// Software Engineering Hint: It can be extremely useful for later debugging\n//   if you erase each page's memory as soon as it is freed.  See the Software\n//   Engineering Hint above for reasons why.\n", "func_signal": "void\npage_free(struct Page *pp)", "code": "{\n\t// Fill this function in\n\t//Only be called when pp_ref reaches 0\n\tassert(pp->pp_ref == 0);\n\t//Add free page to link free_pages\n\tpp->pp_next = free_pages;\n\tfree_pages = pp;\n\t//erase page memory\n\tmemset(pp->data(), 0xCD, sizeof(*pp));\n}", "path": "kern\\pmap.c", "repo_name": "donguoxing/Lab2", "stars": 1, "license": "None", "language": "c", "size": 444}
{"docstring": "// Initializes virtual memory.\n//\n// Sets up the kernel's page directory 'kern_pgdir' (which contains those\n// virtual memory mappings common to all user environments), installs that\n// page directory, and turns on paging.  Then effectively turns off segments.\n// \n// This function only sets up the kernel part of the address space\n// (ie. addresses >= UTOP).  The user part of the address space\n// will be set up later.\n//\n// From UTOP to ULIM, the user is allowed to read but not write.\n// Above ULIM the user cannot read (or write). \n", "func_signal": "void\nmem_init(void)", "code": "{\n\tuint32_t cr0;\n\tsize_t n;\n\tint r;\n\tstruct Page *pp;\n\t\n\t// Remove this line when you're ready to test this function.\n\t//panic(\"mem_init: This function is not finished\\n\");\n\n\t// Find out how much memory the machine has ('npages' & 'n_base_pages')\n\ti386_mem_detect();\n\n\n\t// Allocate 'pages', an array of 'struct Page' structures, one for\n\t// each physical memory page.  So there are 'npages' elements in the\n\t// array total (see i386_mem_detect()).\n\t// We advise you set the memory to 0 after allocating it, since that\n\t// will help you catch bugs later.\n\t//\n\t// LAB 2: Your code here.\n\tn = sizeof(struct Page) * npages;\n\tpages =(Page *)boot_alloc(n);\n\n\t// Now that we've allocated the 'pages' array, initialize it\n\t// by putting all free physical pages onto a list.  After this point,\n\t// all further memory management will go through the page_* functions.\n\tpage_init();\n\t\n\t// Check your work so far.\n\tpage_alloc_check();\n\n\n\t// Allocate the kernel's initial page directory, 'kern_pgdir'.\n\t// This starts out empty (all zeros).  Any virtual\n\t// address lookup using this empty 'kern_pgdir' would fault.\n\t// Then we add mappings to 'kern_pgdir' as we go long.\n\tpp = page_alloc();\n\tpp->pp_ref++;\t\t// make sure we mark the page as used!\n\n\tkern_pgdir = (pte_t *) pp->data();\n\tmemset(kern_pgdir, 0, PGSIZE);\n\n\t// Check page mapping functions.\n\tpage_check();\n\n\n\t// Map the kernel stack at virtual address 'KSTACKTOP-KSTKSIZE'.\n\t// A large range of virtual memory, [KSTACKTOP-PTSIZE, KSTACKTOP),\n\t// is marked out for the kernel stack.  However, only part of this\n\t// range is allocated.  The rest of it is left unmapped, so that\n\t// kernel stack overflow will cause a page fault.\n\t// - [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not present\n\t// - [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- kernel RW, user NONE\n\t//\n\t// The kernel already has a stack, so it is not necessary to allocate\n\t// a new one.  That stack's bottom address is 'bootstack'.  (Q: Where\n\t// is 'bootstack' allocated?)\n\t//\n\t// LAB 2: Your code here.\n        //page_map_segment(kern_pgdir, KSTACKTOP - PTSIZE, PTSIZE - KSTKSIZE, 0x0, 0);\n        page_map_segment(kern_pgdir, KSTACKTOP - KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_P | PTE_W);\n\t// Map all of physical memory at KERNBASE.\n\t// I.e., the VA range [KERNBASE, 2^32) should map to\n\t//       the PA range [0, 2^32 - KERNBASE).\n\t// We might not have 2^32 - KERNBASE bytes of physical memory, but\n\t// we just set up the mapping anyway.\n\t// Permissions: kernel RW, user NONE\n\t//\n \t// LAB 2: Your code here.\n        page_map_segment(kern_pgdir, KERNBASE, ~KERNBASE + 1, 0x0, PTE_P | PTE_W);\n\t// Check that the initial page directory has been set up correctly.\n\tboot_mem_check();\n\n\t// On x86, segmentation maps a VA to a LA (linear addr) and\n\t// paging maps the LA to a PA; we write VA => LA => PA.  If paging is\n\t// turned off the LA is used as the PA.  There is no way to\n\t// turn off segmentation; the closest thing is to set the base\n\t// address to 0, so the VA => LA mapping is the identity.\n\n\t// The current mapping: VA KERNBASE+x => PA x.\n\t//     (segmentation base = -KERNBASE, and paging is off.)\n\n\t// From here on down we must maintain this VA KERNBASE + x => PA x\n\t// mapping, even though we are turning on paging and reconfiguring\n\t// segmentation.\n\n\t// Map VA 0:4MB same as VA KERNBASE, i.e. to PA 0:4MB.\n\t// (Limits our kernel to <4MB)\n\tkern_pgdir[0] = kern_pgdir[PDX(KERNBASE)];\n\n\t// Install page table.\n\tlcr3(PADDR(kern_pgdir));\n\n\t// Turn on paging.\n\tcr0 = rcr0();\n\tcr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_TS|CR0_EM|CR0_MP;\n\tcr0 &= ~(CR0_TS|CR0_EM);\n\tlcr0(cr0);\n\n\t// Current mapping: VA KERNBASE+x => LA x => PA x.\n\t// (x < 4MB so uses paging kern_pgdir[0])\n\n\t// Reload all segment registers.\n\tasm volatile(\"lgdt gdt_pd\");\n\tasm volatile(\"movw %%ax,%%gs\" :: \"a\" (GD_UD|3));\n\tasm volatile(\"movw %%ax,%%fs\" :: \"a\" (GD_UD|3));\n\tasm volatile(\"movw %%ax,%%es\" :: \"a\" (GD_KD));\n\tasm volatile(\"movw %%ax,%%ds\" :: \"a\" (GD_KD));\n\tasm volatile(\"movw %%ax,%%ss\" :: \"a\" (GD_KD));\n\tasm volatile(\"ljmp %0,$1f\\n 1:\\n\" :: \"i\" (GD_KT));  // reload cs\n\tasm volatile(\"lldt %%ax\" :: \"a\" (0));\n\n\t// Final mapping: VA KERNBASE+x => LA KERNBASE+x => PA x.\n\n\t// This mapping was only used after paging was turned on but\n\t// before the segment registers were reloaded.\n\tkern_pgdir[0] = 0;\n\n\t// Flush the TLB for good measure, to kill the kern_pgdir[0] mapping.\n\tlcr3(PADDR(kern_pgdir));\n}", "path": "kern\\pmap.c", "repo_name": "donguoxing/Lab2", "stars": 1, "license": "None", "language": "c", "size": 444}
{"docstring": "// Checks that the kernel part of virtual address space\n// has been set up roughly correctly (by mem_init()).\n//\n// This function doesn't test every corner case,\n// and doesn't test the permission bits at all,\n// but it is a pretty good sanity check.\n", "func_signal": "static void\nboot_mem_check(void)", "code": "{\n\tuint32_t i, n;\n\n\t// check phys mem\n\tfor (i = 0; KERNBASE + i != 0; i += PGSIZE)\n\t\tassert(check_va2pa(kern_pgdir, KERNBASE + i) == i);\n\n\t// check kernel stack\n\tfor (i = 0; i < KSTKSIZE; i += PGSIZE)\n\t\tassert(check_va2pa(kern_pgdir, KSTACKTOP - KSTKSIZE + i) == PADDR(bootstack) + i);\n\n\t// check for zero/non-zero in PDEs\n\tfor (i = 0; i < NPDENTRIES; i++) {\n\t\tswitch (i) {\n\t\tcase PDX(KSTACKTOP-1):\n\t\t\tassert(kern_pgdir[i]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (i >= PDX(KERNBASE))\n\t\t\t\tassert(kern_pgdir[i]);\n\t\t\telse\n\t\t\t\tassert(kern_pgdir[i] == 0);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tcprintf(\"boot_mem_check() succeeded!\\n\");\n}", "path": "kern\\pmap.c", "repo_name": "donguoxing/Lab2", "stars": 1, "license": "None", "language": "c", "size": 444}
{"docstring": "/*\n * Get data from the keyboard.  If we finish a character, return it.  Else 0.\n * Return -1 if no data.\n */\n", "func_signal": "static int\nkbd_proc_data(void)", "code": "{\n\tint c;\n\tuint8_t data;\n\tstatic uint32_t shift;\n\n\tif ((inb(KBSTATP) & KBS_DIB) == 0)\n\t\treturn -1;\n\n\tdata = inb(KBDATAP);\n\n\tif (data == 0xE0) {\n\t\t// E0 escape character\n\t\tshift |= E0ESC;\n\t\treturn 0;\n\t} else if (data & 0x80) {\n\t\t// Key released\n\t\tdata = (shift & E0ESC ? data : data & 0x7F);\n\t\tshift &= ~(shiftcode[data] | E0ESC);\n\t\treturn 0;\n\t} else if (shift & E0ESC) {\n\t\t// Last character was an E0 escape; or with 0x80\n\t\tdata |= 0x80;\n\t\tshift &= ~E0ESC;\n\t}\n\n\tshift |= shiftcode[data];\n\tshift ^= togglecode[data];\n\n\tc = charcode[shift & (CTL | SHIFT)][data];\n\tif (shift & CAPSLOCK) {\n\t\tif ('a' <= c && c <= 'z')\n\t\t\tc += 'A' - 'a';\n\t\telse if ('A' <= c && c <= 'Z')\n\t\t\tc += 'a' - 'A';\n\t}\n\n\t// Process special keys\n#if CRT_SAVEROWS > 0\n\t// Shift-PageUp and Shift-PageDown: scroll console\n\tif ((shift & (CTL | SHIFT)) && (c == KEY_PGUP || c == KEY_PGDN)) {\n\t\tcga_scroll(c == KEY_PGUP ? -CRT_ROWS : CRT_ROWS);\n\t\treturn 0;\n\t}\n#endif\n\t// Ctrl-Alt-Del: reboot\n\tif (!(~shift & (CTL | ALT)) && c == KEY_DEL) {\n\t\tcprintf(\"Rebooting!\\n\");\n\t\toutb(0x92, 0x3); // courtesy of Chris Frost\n\t}\n\n\treturn c;\n}", "path": "kern\\console.c", "repo_name": "donguoxing/Lab2", "stars": 1, "license": "None", "language": "c", "size": 444}
{"docstring": "/**\n * empathy_contact_set_location:\n * @contact: an #EmpathyContact\n * @location: a #GHashTable of the location\n *\n * Sets the user's location based on the location #GHashTable passed.\n * It is composed of string keys and GValues.  Keys are\n * defined in empathy-location.h such as #EMPATHY_LOCATION_COUNTRY.\n * Example: a \"city\" key would have \"Helsinki\" as string GValue,\n *          a \"latitude\" would have 65.0 as double GValue.\n */\n", "func_signal": "void\nempathy_contact_set_location (EmpathyContact *contact,\n                              GHashTable *location)", "code": "{\n  EmpathyContactPriv *priv;\n\n  g_return_if_fail (EMPATHY_CONTACT (contact));\n  g_return_if_fail (location != NULL);\n\n  priv = GET_PRIV (contact);\n\n  if (priv->location != NULL)\n    g_hash_table_unref (priv->location);\n\n  priv->location = g_hash_table_ref (location);\n  g_object_notify (G_OBJECT (contact), \"location\");\n}", "path": "libempathy\\empathy-contact.c", "repo_name": "zenios/empathy-bug--548716", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6440}
{"docstring": "/* Converts the Location's GHashTable's key to a user readable string */\n", "func_signal": "static const gchar *\nlocation_key_to_label (const gchar *key)", "code": "{\n  if (tp_strdiff (key, EMPATHY_LOCATION_COUNTRY_CODE) == FALSE)\n    return _(\"Country ISO Code:\");\n  else if (tp_strdiff (key, EMPATHY_LOCATION_COUNTRY) == FALSE)\n    return _(\"Country:\");\n  else if (tp_strdiff (key, EMPATHY_LOCATION_REGION) == FALSE)\n    return _(\"State:\");\n  else if (tp_strdiff (key, EMPATHY_LOCATION_LOCALITY) == FALSE)\n    return _(\"City:\");\n  else if (tp_strdiff (key, EMPATHY_LOCATION_AREA) == FALSE)\n    return _(\"Area:\");\n  else if (tp_strdiff (key, EMPATHY_LOCATION_POSTAL_CODE) == FALSE)\n    return _(\"Postal Code:\");\n  else if (tp_strdiff (key, EMPATHY_LOCATION_STREET) == FALSE)\n    return _(\"Street:\");\n  else if (tp_strdiff (key, EMPATHY_LOCATION_BUILDING) == FALSE)\n    return _(\"Building:\");\n  else if (tp_strdiff (key, EMPATHY_LOCATION_FLOOR) == FALSE)\n    return _(\"Floor:\");\n  else if (tp_strdiff (key, EMPATHY_LOCATION_ROOM) == FALSE)\n    return _(\"Room:\");\n  else if (tp_strdiff (key, EMPATHY_LOCATION_TEXT) == FALSE)\n    return _(\"Text:\");\n  else if (tp_strdiff (key, EMPATHY_LOCATION_DESCRIPTION) == FALSE)\n    return _(\"Description:\");\n  else if (tp_strdiff (key, EMPATHY_LOCATION_URI) == FALSE)\n    return _(\"URI:\");\n  else if (tp_strdiff (key, EMPATHY_LOCATION_ACCURACY_LEVEL) == FALSE)\n    return _(\"Accuracy Level:\");\n  else if (tp_strdiff (key, EMPATHY_LOCATION_ERROR) == FALSE)\n    return _(\"Error:\");\n  else if (tp_strdiff (key, EMPATHY_LOCATION_VERTICAL_ERROR_M) == FALSE)\n    return _(\"Vertical Error (meters):\");\n  else if (tp_strdiff (key, EMPATHY_LOCATION_HORIZONTAL_ERROR_M) == FALSE)\n    return _(\"Horizontal Error (meters):\");\n  else if (tp_strdiff (key, EMPATHY_LOCATION_SPEED) == FALSE)\n    return _(\"Speed:\");\n  else if (tp_strdiff (key, EMPATHY_LOCATION_BEARING) == FALSE)\n    return _(\"Bearing:\");\n  else if (tp_strdiff (key, EMPATHY_LOCATION_CLIMB) == FALSE)\n    return _(\"Climb Speed:\");\n  else if (tp_strdiff (key, EMPATHY_LOCATION_TIMESTAMP) == FALSE)\n    return _(\"Last Updated on:\");\n  else if (tp_strdiff (key, EMPATHY_LOCATION_LON) == FALSE)\n    return _(\"Longitude:\");\n  else if (tp_strdiff (key, EMPATHY_LOCATION_LAT) == FALSE)\n    return _(\"Latitude:\");\n  else if (tp_strdiff (key, EMPATHY_LOCATION_ALT) == FALSE)\n    return _(\"Altitude:\");\n  else\n  {\n    DEBUG (\"Unexpected Location key: %s\", key);\n    return key;\n  }\n}", "path": "libempathy-gtk\\empathy-contact-widget.c", "repo_name": "zenios/empathy-bug--548716", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6440}
{"docstring": "/* Format is just date, 20061201. */\n", "func_signal": "gchar *\nempathy_log_manager_get_date_readable (const gchar *date)", "code": "{\n  time_t t;\n\n  t = empathy_time_parse (date);\n\n  return empathy_time_to_string_local (t, \"%a %d %b %Y\");\n}", "path": "libempathy\\empathy-log-manager.c", "repo_name": "zenios/empathy-bug--548716", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6440}
{"docstring": "/*\n * ephy_spinner_set_size:\n * @spinner: a #EphySpinner\n * @size: the size of type %GtkIconSize\n *\n * Set the size of the spinner.\n **/\n", "func_signal": "void\nephy_spinner_set_size (EphySpinner *spinner,\n\t\t       GtkIconSize size)", "code": "{\n\tif (size == GTK_ICON_SIZE_INVALID)\n\t{\n\t\tsize = GTK_ICON_SIZE_DIALOG;\n\t}\n\n\tif (size != spinner->details->size)\n\t{\n\t\tephy_spinner_unload_images (spinner);\n\n\t\tspinner->details->size = size;\n\n\t\tgtk_widget_queue_resize (GTK_WIDGET (spinner));\n\t}\n}", "path": "src\\ephy-spinner.c", "repo_name": "zenios/empathy-bug--548716", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6440}
{"docstring": "/**\n * empathy_profile_chooser_n_profiles:\n * @widget: an #EmpathyProfileChooser\n *\n * Returns the number of profiles in @widget.\n *\n * Return value: the number of profiles in @widget\n */\n", "func_signal": "gint\nempathy_profile_chooser_n_profiles (GtkWidget *widget)", "code": "{\n\tGtkTreeModel *model;\n\n\tmodel = gtk_combo_box_get_model (GTK_COMBO_BOX (widget));\n\n\treturn gtk_tree_model_iter_n_children (model, NULL);\n}", "path": "libempathy-gtk\\empathy-profile-chooser.c", "repo_name": "zenios/empathy-bug--548716", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6440}
{"docstring": "/*\n * ephy_spinner_set_timeout:\n * @spinner: a #EphySpinner\n * @timeout: time delay between updates to the spinner.\n *\n * Sets the timeout delay for spinner updates.\n **/\n", "func_signal": "void\nephy_spinner_set_timeout (EphySpinner *spinner,\n\t\t\t  guint timeout)", "code": "{\n\tEphySpinnerDetails *details = spinner->details;\n\n\tif (timeout != details->timeout)\n\t{\n\t\tephy_spinner_stop (spinner);\n\n\t\tdetails->timeout = timeout;\n\n\t\tif (details->spinning)\n\t\t{\n\t\t\tephy_spinner_start (spinner);\n\t\t}\n\t}\n}", "path": "src\\ephy-spinner.c", "repo_name": "zenios/empathy-bug--548716", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6440}
{"docstring": "/**\n * empathy_contact_widget_get_contact:\n * @widget: an #EmpathyContactWidget\n *\n * Get the #EmpathyContact related with the #EmpathyContactWidget @widget.\n *\n * Returns: the #EmpathyContact associated with @widget\n */\n", "func_signal": "EmpathyContact *\nempathy_contact_widget_get_contact (GtkWidget *widget)", "code": "{\n  EmpathyContactWidget *information;\n\n  g_return_val_if_fail (GTK_IS_WIDGET (widget), NULL);\n\n  information = g_object_get_data (G_OBJECT (widget), \"EmpathyContactWidget\");\n  if (!information)\n      return NULL;\n\n  return information->contact;\n}", "path": "libempathy-gtk\\empathy-contact-widget.c", "repo_name": "zenios/empathy-bug--548716", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6440}
{"docstring": "/**\n * empathy_ft_manager_add_tp_file:\n * @ft_manager: an #EmpathyFTManager\n * @ft: an #EmpathyFT\n *\n * Adds a file transfer to the file transfer manager dialog @ft_manager.\n * The manager dialog then shows the progress and other information about\n * @ft.\n */\n", "func_signal": "void\nempathy_ft_manager_add_tp_file (EmpathyFTManager *ft_manager,\n                                EmpathyTpFile *tp_file)", "code": "{\n  TpFileTransferState state;\n\n  g_return_if_fail (EMPATHY_IS_FT_MANAGER (ft_manager));\n  g_return_if_fail (EMPATHY_IS_TP_FILE (tp_file));\n\n  state = empathy_tp_file_get_state (tp_file, NULL);\n\n  DEBUG (\"Adding a file transfer: contact=%s, filename=%s, state=%d\",\n      empathy_contact_get_name (empathy_tp_file_get_contact (tp_file)),\n      empathy_tp_file_get_filename (tp_file), state);\n\n  if (state == TP_FILE_TRANSFER_STATE_PENDING &&\n      empathy_tp_file_is_incoming (tp_file))\n    ft_manager_display_accept_dialog (ft_manager, tp_file);\n  else\n    ft_manager_add_tp_file_to_list (ft_manager, tp_file);\n}", "path": "src\\empathy-ft-manager.c", "repo_name": "zenios/empathy-bug--548716", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6440}
{"docstring": "/**\n * empathy_contact_widget_set_contact:\n * @widget: an #EmpathyContactWidget\n * @contact: a different #EmpathyContact\n *\n * Change the #EmpathyContact related with the #EmpathyContactWidget @widget.\n */\n", "func_signal": "void\nempathy_contact_widget_set_contact (GtkWidget *widget,\n                                    EmpathyContact *contact)", "code": "{\n  EmpathyContactWidget *information;\n\n  g_return_if_fail (GTK_IS_WIDGET (widget));\n  g_return_if_fail (EMPATHY_IS_CONTACT (contact));\n\n  information = g_object_get_data (G_OBJECT (widget), \"EmpathyContactWidget\");\n  if (!information)\n    return;\n\n  contact_widget_set_contact (information, contact);\n}", "path": "libempathy-gtk\\empathy-contact-widget.c", "repo_name": "zenios/empathy-bug--548716", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6440}
{"docstring": "/**\n * empathy_irc_server_new:\n * @address: the address\n * @port: the port\n * @ssl: %TRUE if the server needs a SSL connection\n *\n * Creates a new #EmpathyIrcServer\n *\n * Returns: a new #EmpathyIrcServer\n */\n", "func_signal": "EmpathyIrcServer *\nempathy_irc_server_new (const gchar *address,\n                        guint port,\n                        gboolean ssl)", "code": "{\n  return g_object_new (EMPATHY_TYPE_IRC_SERVER,\n      \"address\", address,\n      \"port\", port,\n      \"ssl\", ssl,\n      NULL);\n}", "path": "libempathy\\empathy-irc-server.c", "repo_name": "zenios/empathy-bug--548716", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6440}
{"docstring": "/**\n * empathy_profile_chooser_dup_selected:\n * @widget: an #EmpathyProfileChooser\n *\n * Returns a new reference to the selected #McProfile in @widget. The returned\n * #McProfile should be unrefed with g_object_unref() when finished with.\n *\n * Return value: a new reference to the selected #McProfile\n */\n", "func_signal": "McProfile *\nempathy_profile_chooser_dup_selected (GtkWidget *widget)", "code": "{\n\tGtkTreeModel *model;\n\tGtkTreeIter   iter;\n\tMcProfile    *profile = NULL;\n\n\tmodel = gtk_combo_box_get_model (GTK_COMBO_BOX (widget));\n\tif (gtk_combo_box_get_active_iter (GTK_COMBO_BOX (widget), &iter)) {\n\t\tgtk_tree_model_get (model, &iter,\n\t\t\t\t    COL_PROFILE, &profile,\n\t\t\t\t    -1);\n\t}\n\n\treturn profile;\n}", "path": "libempathy-gtk\\empathy-profile-chooser.c", "repo_name": "zenios/empathy-bug--548716", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6440}
{"docstring": "/*\n * API to save/load and parse the chatrooms file.\n */\n", "func_signal": "static gboolean\nchatroom_manager_file_save (EmpathyChatroomManager *manager)", "code": "{\n\tEmpathyChatroomManagerPriv *priv;\n\txmlDocPtr                  doc;\n\txmlNodePtr                 root;\n\tGList                     *l;\n\n\tpriv = GET_PRIV (manager);\n\n\tdoc = xmlNewDoc (\"1.0\");\n\troot = xmlNewNode (NULL, \"chatrooms\");\n\txmlDocSetRootElement (doc, root);\n\n\tfor (l = priv->chatrooms; l; l = l->next) {\n\t\tEmpathyChatroom *chatroom;\n\t\txmlNodePtr       node;\n\t\tconst gchar     *account_id;\n\n\t\tchatroom = l->data;\n\n\t\tif (!empathy_chatroom_is_favorite (chatroom)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\taccount_id = mc_account_get_unique_name (empathy_chatroom_get_account (chatroom));\n\n\t\tnode = xmlNewChild (root, NULL, \"chatroom\", NULL);\n\t\txmlNewTextChild (node, NULL, \"name\", empathy_chatroom_get_name (chatroom));\n\t\txmlNewTextChild (node, NULL, \"room\", empathy_chatroom_get_room (chatroom));\n\t\txmlNewTextChild (node, NULL, \"account\", account_id);\n\t\txmlNewTextChild (node, NULL, \"auto_connect\",\n\t\t\tempathy_chatroom_get_auto_connect (chatroom) ? \"yes\" : \"no\");\n\t}\n\n\t/* Make sure the XML is indented properly */\n\txmlIndentTreeOutput = 1;\n\n\tDEBUG (\"Saving file:'%s'\", priv->file);\n\txmlSaveFormatFileEnc (priv->file, doc, \"utf-8\", 1);\n\txmlFreeDoc (doc);\n\n\txmlCleanupParser ();\n\txmlMemoryDump ();\n\n\treturn TRUE;\n}", "path": "libempathy\\empathy-chatroom-manager.c", "repo_name": "zenios/empathy-bug--548716", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6440}
{"docstring": "/**\n * ephy_spinner_stop:\n * @spinner: a #EphySpinner\n *\n * Stop the spinner animation.\n **/\n", "func_signal": "void\nephy_spinner_stop (EphySpinner *spinner)", "code": "{\n\tEphySpinnerDetails *details = spinner->details;\n\n\tdetails->spinning = FALSE;\n\tdetails->current_image = 0;\n\n\tif (details->timer_task != 0)\n\t{\n\t\tephy_spinner_remove_update_callback (spinner);\n\n\t\tif (GTK_WIDGET_MAPPED (GTK_WIDGET (spinner)))\n\t\t{\n\t\t\tgtk_widget_queue_draw (GTK_WIDGET (spinner));\n\t\t}\n\t}\n}", "path": "src\\ephy-spinner.c", "repo_name": "zenios/empathy-bug--548716", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6440}
{"docstring": "/**\n * empathy_contact_get_location:\n * @contact: an #EmpathyContact\n *\n * Returns the user's location if available.  The keys are defined in\n * empathy-location.h. If the contact doesn't have location\n * information, the GHashTable will be empthy. Use #g_hash_table_unref when\n * you are done with the #GHashTable.\n *\n * It is composed of string keys and GValues.  Keys are\n * defined in empathy-location.h such as #EMPATHY_LOCATION_COUNTRY.\n * Example: a \"city\" key would have \"Helsinki\" as string GValue,\n *          a \"latitude\" would have 65.0 as double GValue.\n *\n * Returns: a #GHashTable of location values\n */\n", "func_signal": "GHashTable *\nempathy_contact_get_location (EmpathyContact *contact)", "code": "{\n  EmpathyContactPriv *priv;\n\n  g_return_val_if_fail (EMPATHY_CONTACT (contact), NULL);\n\n  priv = GET_PRIV (contact);\n\n  return priv->location;\n}", "path": "libempathy\\empathy-contact.c", "repo_name": "zenios/empathy-bug--548716", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6440}
{"docstring": "/**\n * empathy_ft_manager_get_dialog:\n * @ft_manager: an #EmpathyFTManager\n *\n * Returns the #GtkWidget of @ft_manager.\n *\n * Returns: the dialog\n */\n", "func_signal": "GtkWidget *\nempathy_ft_manager_get_dialog (EmpathyFTManager *ft_manager)", "code": "{\n  g_return_val_if_fail (EMPATHY_IS_FT_MANAGER (ft_manager), NULL);\n\n  ft_manager_build_ui (ft_manager);\n\n  return ft_manager->priv->window;\n}", "path": "src\\empathy-ft-manager.c", "repo_name": "zenios/empathy-bug--548716", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6440}
{"docstring": "/**\n * empathy_contact_widget_new:\n * @contact: an #EmpathyContact\n * @flags: #EmpathyContactWidgetFlags for the new contact widget\n *\n * Creates a new #EmpathyContactWidget.\n *\n * Return value: a new #EmpathyContactWidget\n */\n", "func_signal": "GtkWidget *\nempathy_contact_widget_new (EmpathyContact *contact,\n                            EmpathyContactWidgetFlags flags)", "code": "{\n  EmpathyContactWidget *information;\n  GtkBuilder *gui;\n  gchar *filename;\n\n  g_return_val_if_fail (contact == NULL || EMPATHY_IS_CONTACT (contact), NULL);\n\n  information = g_slice_new0 (EmpathyContactWidget);\n  information->flags = flags;\n\n  filename = empathy_file_lookup (\"empathy-contact-widget.ui\",\n      \"libempathy-gtk\");\n  gui = empathy_builder_get_file (filename,\n       \"vbox_contact_widget\", &information->vbox_contact_widget,\n       \"vbox_contact\", &information->vbox_contact,\n       \"hbox_presence\", &information->hbox_presence,\n       \"label_alias\", &information->label_alias,\n       \"image_state\", &information->image_state,\n       \"label_status\", &information->label_status,\n       \"table_contact\", &information->table_contact,\n       \"vbox_avatar\", &information->vbox_avatar,\n       \"vbox_location\", &information->vbox_location,\n       \"subvbox_location\", &information->subvbox_location,\n       \"label_location\", &information->label_location,\n#if HAVE_LIBCHAMPLAIN\n       \"viewport_map\", &information->viewport_map,\n#endif\n       \"vbox_groups\", &information->vbox_groups,\n       \"entry_group\", &information->entry_group,\n       \"button_group\", &information->button_group,\n       \"treeview_groups\", &information->treeview_groups,\n       \"vbox_details\", &information->vbox_details,\n       \"table_details\", &information->table_details,\n       \"hbox_details_requested\", &information->hbox_details_requested,\n       \"vbox_client\", &information->vbox_client,\n       \"table_client\", &information->table_client,\n       \"hbox_client_requested\", &information->hbox_client_requested,\n       NULL);\n  g_free (filename);\n\n  empathy_builder_connect (gui, information,\n      \"vbox_contact_widget\", \"destroy\", contact_widget_destroy_cb,\n      \"entry_group\", \"changed\", contact_widget_entry_group_changed_cb,\n      \"entry_group\", \"activate\", contact_widget_entry_group_activate_cb,\n      \"button_group\", \"clicked\", contact_widget_button_group_clicked_cb,\n      NULL);\n  information->table_location = NULL;\n\n  g_object_set_data (G_OBJECT (information->vbox_contact_widget),\n      \"EmpathyContactWidget\",\n      information);\n\n  /* Create widgets */\n  contact_widget_contact_setup (information);\n  contact_widget_groups_setup (information);\n  contact_widget_details_setup (information);\n  contact_widget_client_setup (information);\n\n  if (contact != NULL)\n    contact_widget_set_contact (information, contact);\n\n  else if (information->flags & EMPATHY_CONTACT_WIDGET_EDIT_ACCOUNT ||\n      information->flags & EMPATHY_CONTACT_WIDGET_EDIT_ID)\n    contact_widget_change_contact (information);\n\n  return empathy_builder_unref_and_keep_widget (gui,\n    information->vbox_contact_widget);\n}", "path": "libempathy-gtk\\empathy-contact-widget.c", "repo_name": "zenios/empathy-bug--548716", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6440}
{"docstring": "/**\n * empathy_contact_widget_set_account_filter:\n * @widget: an #EmpathyContactWidget\n * @filter: a #EmpathyAccountChooserFilterFunc\n * @user_data: user data to pass to @filter, or %NULL\n *\n * Set a filter on the #EmpathyAccountChooser included in the\n * #EmpathyContactWidget.\n */\n", "func_signal": "void\nempathy_contact_widget_set_account_filter (\n    GtkWidget *widget,\n    EmpathyAccountChooserFilterFunc filter,\n    gpointer user_data)", "code": "{\n  EmpathyContactWidget *information;\n  EmpathyAccountChooser *chooser;\n\n  g_return_if_fail (GTK_IS_WIDGET (widget));\n\n  information = g_object_get_data (G_OBJECT (widget), \"EmpathyContactWidget\");\n  if (!information)\n    return;\n\n  chooser = EMPATHY_ACCOUNT_CHOOSER (information->widget_account);\n  if (chooser)\n      empathy_account_chooser_set_filter (chooser, filter, user_data);\n}", "path": "libempathy-gtk\\empathy-contact-widget.c", "repo_name": "zenios/empathy-bug--548716", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6440}
{"docstring": "/* Note: This function takes the ownership of str */\n", "func_signal": "static EmpathySmiley *\nsmiley_new (GdkPixbuf *pixbuf, gchar *str)", "code": "{\n\tEmpathySmiley *smiley;\n\n\tsmiley = g_slice_new0 (EmpathySmiley);\n\tif (pixbuf) {\n\t\tsmiley->pixbuf = g_object_ref (pixbuf);\n\t}\n\tsmiley->str = str;\n\n\treturn smiley;\n}", "path": "libempathy-gtk\\empathy-smiley-manager.c", "repo_name": "zenios/empathy-bug--548716", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6440}
{"docstring": "/**\n * ephy_spinner_start:\n * @spinner: a #EphySpinner\n *\n * Start the spinner animation.\n **/\n", "func_signal": "void\nephy_spinner_start (EphySpinner *spinner)", "code": "{\n\tEphySpinnerDetails *details = spinner->details;\n\n\tdetails->spinning = TRUE;\n\n\tif (GTK_WIDGET_MAPPED (GTK_WIDGET (spinner)) &&\n\t    details->timer_task == 0 &&\n\t    ephy_spinner_load_images (spinner))\n\t{\n\t\t/* the 0th frame is the 'rest' icon */\n\t\tdetails->current_image = MIN (1, details->images->n_animation_pixbufs);\n\n\t\tdetails->timer_task =\n\t\t\tg_timeout_add_full (G_PRIORITY_LOW,\n\t\t\t                    details->timeout,\n\t\t\t\t            (GSourceFunc) bump_spinner_frame_cb,\n\t\t\t\t            spinner,\n\t\t\t\t            NULL);\n\t}\n}", "path": "src\\ephy-spinner.c", "repo_name": "zenios/empathy-bug--548716", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6440}
{"docstring": "/**\n * empathy_profile_chooser_new:\n *\n * Creates a new #EmpathyProfileChooser widget.\n *\n * Return value: a new #EmpathyProfileChooser widget\n */\n", "func_signal": "GtkWidget *\nempathy_profile_chooser_new (void)", "code": "{\n\tGList           *profiles, *l, *seen;\n\tGtkListStore    *store;\n\tGtkCellRenderer *renderer;\n\tGtkWidget       *combo_box;\n\tGtkTreeIter      iter;\n\tgboolean         iter_set = FALSE;\n\tMcManager       *btf_cm;\n\n\t/* set up combo box with new store */\n\tstore = gtk_list_store_new (COL_COUNT,\n\t\t\t\t    G_TYPE_STRING,    /* Icon name */\n\t\t\t\t    G_TYPE_STRING,    /* Label     */\n\t\t\t\t    MC_TYPE_PROFILE); /* Profile   */\n\tcombo_box = gtk_combo_box_new_with_model (GTK_TREE_MODEL (store));\n\n\n\trenderer = gtk_cell_renderer_pixbuf_new ();\n\tgtk_cell_layout_pack_start (GTK_CELL_LAYOUT (combo_box), renderer, FALSE);\n\tgtk_cell_layout_set_attributes (GTK_CELL_LAYOUT (combo_box), renderer,\n\t\t\t\t\t\"icon-name\", COL_ICON,\n\t\t\t\t\tNULL);\n\tg_object_set (renderer, \"stock-size\", GTK_ICON_SIZE_BUTTON, NULL);\n\n\trenderer = gtk_cell_renderer_text_new ();\n\tgtk_cell_layout_pack_start (GTK_CELL_LAYOUT (combo_box), renderer, TRUE);\n\tgtk_cell_layout_set_attributes (GTK_CELL_LAYOUT (combo_box), renderer,\n\t\t\t\t\t\"text\", COL_LABEL,\n\t\t\t\t\tNULL);\n\n\tbtf_cm = mc_manager_lookup (\"butterfly\");\n\tprofiles = mc_profiles_list ();\n\tseen = NULL;\n\tfor (l = profiles; l; l = l->next) {\n\t\tMcProfile   *profile;\n\t\tMcProtocol  *protocol;\n\t\tconst gchar *unique_name;\n\n\t\tprofile = l->data;\n\n\t\t/* Check if the CM is installed, otherwise skip that profile.\n\t\t * Workaround SF bug #1688779 */\n\t\tprotocol = mc_profile_get_protocol (profile);\n\t\tif (!protocol) {\n\t\t\tcontinue;\n\t\t}\n\t\tg_object_unref (protocol);\n\n\t\t/* Skip MSN-Haze if we have butterfly */\n\t\tunique_name = mc_profile_get_unique_name (profile);\n\t\tif (btf_cm && strcmp (unique_name, \"msn-haze\") == 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (g_list_find_custom (seen, unique_name, (GCompareFunc) strcmp)) {\n\t\t\tcontinue;\n\t\t}\n\t\tseen = g_list_append (seen, (char *) unique_name);\n\n\t\tgtk_list_store_insert_with_values (store, &iter, 0,\n\t\t\t\t\t\t   COL_ICON, mc_profile_get_icon_name (profile),\n\t\t\t\t\t\t   COL_LABEL, mc_profile_get_display_name (profile),\n\t\t\t\t\t\t   COL_PROFILE, profile,\n\t\t\t\t\t\t   -1);\n                iter_set = TRUE;\n\t}\n\n\tg_list_free (seen);\n\n\tif (btf_cm) {\n\t\tg_object_unref (btf_cm);\n\t}\n\n\t/* Set the profile sort function */\n\tgtk_tree_sortable_set_sort_func (GTK_TREE_SORTABLE (store),\n\t\t\t\t\t COL_PROFILE,\n\t\t\t\t\t profile_chooser_sort_func,\n\t\t\t\t\t NULL, NULL);\n\tgtk_tree_sortable_set_sort_column_id (GTK_TREE_SORTABLE (store),\n\t\t\t\t\t      COL_PROFILE,\n\t\t\t\t\t      GTK_SORT_ASCENDING);\n\n        if (iter_set) {\n\t\tgtk_combo_box_set_active_iter (GTK_COMBO_BOX (combo_box), &iter);\n        }\n\n\tmc_profiles_free_list (profiles);\n\tg_object_unref (store);\n\n\treturn combo_box;\n}", "path": "libempathy-gtk\\empathy-profile-chooser.c", "repo_name": "zenios/empathy-bug--548716", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6440}
{"docstring": "/*\n * Initialize (means CONFIGURE) the display driver.\n * params:\n *   src_width,srcheight: image source size\n *   dst_width,dst_height: size of the requested window size, just a hint\n *   fullscreen: flag, 0=windowd 1=fullscreen, just a hint\n *   title: window title, if available\n *   format: fourcc of pixel format\n * returns : zero on successful initialization, non-zero on error.\n */\n", "func_signal": "static int config(uint32_t src_width, uint32_t src_height,\n\t\t       uint32_t dst_width, uint32_t dst_height, uint32_t flags,\n\t\t       char *title, uint32_t format)", "code": "{\n    w100_priv_t *priv = &st_w100_priv;\n    int fs = flags & VOFLAG_FULLSCREEN;\n    int vm = flags & VOFLAG_MODESWITCHING;\n    int zoom = flags & VOFLAG_SWSCALE;\n    int y_pitch, uv_pitch;\n    int x_res = 480, y_res = 640;\n    uint32_t apitch;\n    int i;\n    uint32_t plane_flags = 0;\n\n    mp_msg(MSGT_VO, MSGL_DBG2, \"vo_w100: config() was called\\n\");\n    mp_msg(MSGT_VO, MSGL_V, \"vo_w100: src_width:%d, src_height:%d, dst_width:%d, dst_height:%d\\n\",\n\t   src_width, src_height, dst_width, dst_height);\n\n    if (!query_format(format)) {\n\tprintf(\"vo_w100: unsupported fourcc for this w100 driver: %x (%s)\\n\",\n\t       format, vo_format_name(format));\n\treturn -1;\n    }\n    priv->format = format;\n\n    // rotate\n    if (priv->rotate < 0) {\n\tif (src_width > src_height) {\n\t    priv->current_rotate = 3;\n\t} else {\n\t    priv->current_rotate = 0;\n\t}\n    } else\n\tpriv->current_rotate = priv->rotate;\n    if (priv->current_rotate != 0 && priv->current_rotate != 3) {\n\tmp_msg(MSGT_VO, MSGL_FATAL, \"vo_w100: Rotate %d not supported\\n\", priv->current_rotate);\n\treturn -1;\n    }\n\n    if (priv->current_rotate == 1 || priv->current_rotate == 3) {\n\ti = src_width;\n\tsrc_width = src_height;\n\tsrc_height = i;\n    }\n\n    dst_width = src_width;\n    dst_height = src_height;\n\n    if (fs) {\n\tint arg[] = { 0, 0, 1, 1, 2, 2, 2, 2, 3 };\n\tint arg2[] = { 1, 2, 4, 8 };\n\tint hor_exp = x_res / src_width;\n\tint ver_exp = y_res / (src_height - 32);\n\tint expand;\n\tmp_msg(MSGT_VO, MSGL_V, \"vo_w100: hor_exp:%d, ver_exp:%d\\n\",\n\t       hor_exp, ver_exp);\n\tif ((hor_exp > 0 && hor_exp <= 8 && arg[hor_exp] >= 0) &&\n\t    (ver_exp > 0 && ver_exp <= 8 && arg[ver_exp] >= 0)) {\n\t    if (arg[hor_exp] > arg[ver_exp])\n\t\texpand = arg[ver_exp];\n\t    else\n\t\texpand = arg[hor_exp];\n\t}\n\tpriv->overlay_expand_h = priv->overlay_expand_v = expand;\n\tdst_width *= arg2[expand];\n\tdst_height *= arg2[expand];\n\tif (dst_height > y_res)\n\t    dst_height = y_res;\n    }\n\n    // \u027d\u03b0\uda57\udee5\udb57\udfe5\n    priv->overlay_pos_x = (x_res - dst_width) / 2;\n    priv->overlay_pos_y = (y_res - dst_height) / 2;\n\n    // Hardware scaling\n    geometry(&priv->overlay_pos_x, &priv->overlay_pos_y,\n\t     &dst_width, &dst_height, x_res, y_res);\n    mp_msg(MSGT_VO, MSGL_V, \"vo_w100: overlay pos(%d, %d)\\n\",\n\t   priv->overlay_pos_x, priv->overlay_pos_y);\n    mp_msg(MSGT_VO, MSGL_V, \"vo_w100: src size(%dx%d), dst size(%dx%d)\\n\",\n\t   src_width, src_height, dst_width, dst_height);\n\n    /* select first frame */\n    priv->current_frame = 0;\n\n    priv->src_width = src_width;\n    priv->src_height = src_height;\n    priv->overlay_pitch_y = 16;\n    priv->overlay_pitch_u = 16;\n    priv->overlay_pitch_v = 16;\n\n    switch (format) {\n    case IMGFMT_YV12:\n    case IMGFMT_IYUV:\n    case IMGFMT_I420:\n    case IMGFMT_YVU9:\n    case IMGFMT_IF09:\n    case IMGFMT_Y8:\n    case IMGFMT_Y800:\n\ty_pitch = (src_width + 15) & ~15;\n\tuv_pitch = ((src_width / 2) + 7) & ~7;\n\tbreak;\n    default:\n\treturn -1;\n    }\n\n    /* \u0565\u00a2VRAM\u02fc\u07a4\u02a4\u03e1V-PlaneVRAM\u0264\u0424 */\n    if (y_pitch * src_height + uv_pitch * src_height > priv->vram_size[INTERNAL_VRAM])\n\tplane_flags = 4;\n\n    if (vo_doublebuffering) {\n\tif (y_pitch * src_height + uv_pitch * src_height * 2> priv->vram_size[INTERNAL_VRAM])\n\t    plane_flags = 4;\n    }\n\n    /* VRAM\u02e5\u05e5\uc87c\u05a4\u03e1Graphic window\u06a4\u02a4\u0232 */\n/*     priv->is_graphic_window_enabled = (plane_flags != 0) ? 0 : 1; */\n    priv->is_graphic_window_enabled = 0;\n\n    uint32_t p[2] = {\n\tVRAM_OFFSET_INTERNAL,\n\tVRAM_OFFSET_EXTERNAL + 640 * 480 * 2\n    };\n    i = 0;\n    while (i < MAX_FRAMES) {\n\tint sel, j;\n\t/* Y-plane */\n\tsel = plane_flags & 1 ? EXTERNAL_VRAM : INTERNAL_VRAM;\n\tpriv->frame_offsets[i].y = (void *)p[sel];\n\tpriv->frame_addrs[i].y = w100_offset2addr(p[sel]);\n\tp[sel] += y_pitch * src_height;\n\t/* U-plane */\n\tsel = plane_flags & 2 ? EXTERNAL_VRAM : INTERNAL_VRAM;\n\tpriv->frame_offsets[i].u = (void *)p[sel];\n\tpriv->frame_addrs[i].u = w100_offset2addr(p[sel]);\n\tp[sel] += uv_pitch * (src_height / 2);\n\t/* V-plane */\n\tsel = plane_flags & 4 ? EXTERNAL_VRAM : INTERNAL_VRAM;\n\tpriv->frame_offsets[i].v = (void *)p[sel];\n\tpriv->frame_addrs[i].v = w100_offset2addr(p[sel]);\n\tp[sel] += uv_pitch * (src_height / 2);\n\tif ((p[INTERNAL_VRAM] - VRAM_OFFSET_INTERNAL >= priv->vram_size[INTERNAL_VRAM]) ||\n\t    (p[EXTERNAL_VRAM] - VRAM_OFFSET_EXTERNAL >= priv->vram_size[EXTERNAL_VRAM]))\n\t    break;\n\tmp_msg(MSGT_VO, MSGL_V, \"vo_w100: frame_offsets[%d].y = 0x%08x\\n\", i, priv->frame_offsets[i].y);\n\tmp_msg(MSGT_VO, MSGL_V, \"vo_w100: frame_offsets[%d].u = 0x%08x\\n\", i, priv->frame_offsets[i].u);\n\tmp_msg(MSGT_VO, MSGL_V, \"vo_w100: frame_offsets[%d].v = 0x%08x\\n\", i, priv->frame_offsets[i].v);\n\t++i;\n    }\n    priv->nframes = i;\n    if (priv->nframes > MAX_FRAMES)\n\tpriv->nframes = MAX_FRAMES;\n    mp_msg(MSGT_VO, MSGL_V, \"vo_w100: nframes = %d\\n\", priv->nframes);\n\n    priv->overlay_prop.lpSrcBitmap = (void *)(priv->frame_offsets[0].y);\n    priv->overlay_prop.XCoord = 0;\n    priv->overlay_prop.YCoord = 0;\n    priv->overlay_prop.SrcPitch = y_pitch;\n    priv->overlay_prop.SrcHeight = src_height;\n    priv->overlay_prop.OverlayWidth = dst_width;\n    priv->overlay_prop.OverlayHeight = dst_height;\n    priv->overlay_prop.lpOverlayKey = 0;\n    priv->overlay_prop.OverlayFormat = OVLTYPE_YUV420;\n\n    priv->display_brightness = 127;\n\n    w100_set_yuv_addrs(priv, &priv->frame_offsets[0]);\n\n    /* clear every frame */\n    memset(priv->vram_addr[INTERNAL_VRAM], 0, priv->vram_size[INTERNAL_VRAM]);\n    memset(priv->vram_addr[EXTERNAL_VRAM] + 640 * 480 * 2, 0,\n\t   priv->vram_size[EXTERNAL_VRAM] - 640 * 480 * 2);\n\n    switch (format) {\n    case IMGFMT_YV12:\n    case IMGFMT_I420:\n    case IMGFMT_IYUV:\n    case IMGFMT_YVU9:\n    case IMGFMT_IF09:\n    case IMGFMT_Y800:\n    case IMGFMT_Y8:\n\tapitch = priv->overlay_pitch_y - 1;\n\tdstrides.y = (src_width + apitch) & ~apitch;\n\tapitch = priv->overlay_pitch_v - 1;\n\tdstrides.v = (src_width + apitch) & ~apitch;\n\tapitch = priv->overlay_pitch_u - 1;\n\tdstrides.u = (src_width + apitch) & ~apitch;\n/* \tst_image_bpp = 1; */\n\tbreak;\n    case IMGFMT_RGB32:\n    case IMGFMT_BGR32:\n\tapitch = priv->overlay_pitch_y - 1;\n\tdstrides.y = (src_width * 4 + apitch) & ~apitch;\n\tdstrides.u = dstrides.v = 0;\n/* \tst_image_bpp = 4; */\n\tbreak;\n    case IMGFMT_RGB24:\n    case IMGFMT_BGR24:\n\tapitch = priv->overlay_pitch_y - 1;\n\tdstrides.y = (src_width * 3 + apitch) & ~apitch;\n\tdstrides.u = dstrides.v = 0;\n/* \tst_image_bpp = 3; */\n\tbreak;\n    default:\n\tapitch = priv->overlay_pitch_y - 1;\n\tdstrides.y = (src_width * 2 + apitch) & ~apitch;\n\tdstrides.u = dstrides.v = 0;\n/* \tst_image_bpp = 2; */\n\tbreak;\n    }\n\n    if (format == IMGFMT_YV12 || format == IMGFMT_I420 || format == IMGFMT_IYUV) {\n\tswitch (priv->current_rotate) {\n\tcase 0:\n\t    video_out_w100.draw_slice = w100_draw_slice_420;\n\t    break;\n\tcase 1:\n\t    break;\n\tcase 2:\n\t    break;\n\tcase 3:\n\t    video_out_w100.draw_slice = w100_draw_slice_420_rotate3;\n\t    break;\n\tdefault:\n\t    video_out_w100.draw_slice = w100_draw_slice_420;\n\t    break;\n\t}\n    }\n    /* \telse if (format == IMGFMT_YVU9 || format == IMGFMT_IF09) */\n    /* \t    vo_server->draw_slice = w100_draw_slice_410; */\n    else\n\tvideo_out_w100.draw_slice = w100_draw_slice_packed;\n\n    if (!w100_setup(priv))\n\treturn -1;\n\n    return 0;\n}", "path": "recipes\\mplayer\\files\\vo_w100.c", "repo_name": "klausf/oe-imx", "stars": 1, "license": "mit", "language": "c", "size": 108250}
{"docstring": "// ---------------------------------------------------------------- interfaces\n/*\n * Preinitializes driver (real INITIALIZATION)\n *   arg - currently it's vo_subdevice\n *   returns: zero on successful initialization, non-zero on error.\n */\n", "func_signal": "static int preinit(const char *vo_subdevice)", "code": "{\n    w100_priv_t *priv = &st_w100_priv;\n\n    mp_msg(MSGT_VO, MSGL_DBG2, \"vo_w100: preinit() was called\\n\");\n\n    if (!AtiCore_ProcessAttach())\n\treturn -1;\n\n    /* fill w100_priv_t information */\n    memset(priv, 0, sizeof(*priv));\n    priv->rotate = -1;\n\n    if (subopt_parse(vo_subdevice, subopts) != 0) {\n\treturn -1;\n    }\n\n    priv->is_graphic_window_enabled = 1;\n    priv->eq_brightness = 0;\t/* FIXME */\n\n    GetAvailableVideoMem(&priv->vram_size[INTERNAL_VRAM],\n\t\t\t &priv->vram_size[EXTERNAL_VRAM]);\n    mp_msg(MSGT_VO, MSGL_V, \"vo_w100: VRAM size %dKB/%dKB\\n\",\n\t   priv->vram_size[INTERNAL_VRAM] / 1024,\n\t   priv->vram_size[EXTERNAL_VRAM] / 1024);\n\n    priv->vram_addr[INTERNAL_VRAM] = w100_offset2addr(VRAM_OFFSET_INTERNAL);\n    priv->vram_addr[EXTERNAL_VRAM] = w100_offset2addr(VRAM_OFFSET_EXTERNAL);\n    mp_msg(MSGT_VO, MSGL_V, \"vo_w100: VRAM address 0x%08x/0x%08x\\n\",\n\t   priv->vram_addr[INTERNAL_VRAM], priv->vram_addr[EXTERNAL_VRAM]);\n\n    lcd_background_color_u lbc;\n    lbc.f.lcd_bg_red = 0;\n    lbc.f.lcd_bg_green = 0;\n    lbc.f.lcd_bg_blue = 0;\n    AtiCore_WriteReg(mmLCD_BACKGROUND_COLOR, &lbc);\n\n    return 0;\n}", "path": "recipes\\mplayer\\files\\vo_w100.c", "repo_name": "klausf/oe-imx", "stars": 1, "license": "mit", "language": "c", "size": 108250}
{"docstring": "/*\n * Blit/Flip buffer to the screen. Must be called after each frame!\n */\n", "func_signal": "void flip_page(void)", "code": "{\n    w100_priv_t *priv = &st_w100_priv;\n\n    mp_msg(MSGT_VO, MSGL_DBG2, \"vo_w100: flip_page() was called\\n\");\n    if (vo_doublebuffering) {\n\tw100_set_yuv_addrs(priv, &priv->frame_offsets[priv->current_frame]);\n\tpriv->current_frame = (priv->current_frame + 1) % priv->nframes;\n    }\n}", "path": "recipes\\mplayer\\files\\vo_w100.c", "repo_name": "klausf/oe-imx", "stars": 1, "license": "mit", "language": "c", "size": 108250}
{"docstring": "/*\n * Closes driver. Should restore the original state of the system.\n */\n", "func_signal": "static void uninit(void)", "code": "{\n    mp_msg(MSGT_VO, MSGL_V, \"vo_w100: uninit() was called\\n\");\n\n    AtiCore_SetOverlayOnOff(st_w100_priv.overlay_handle, 0);\n    AtiCore_ReleaseOverlay(st_w100_priv.overlay_handle);\n    AtiCore_SetGraphicWindowOnOff(1);\n    AtiCore_ProcessDetach();\n}", "path": "recipes\\mplayer\\files\\vo_w100.c", "repo_name": "klausf/oe-imx", "stars": 1, "license": "mit", "language": "c", "size": 108250}
{"docstring": "/*****************************************************************************\n *\n * control\n *\n * Control display\n *\n ****************************************************************************/\n", "func_signal": "static int control(uint32_t request, void *data, ...)", "code": "{\n    mp_msg(MSGT_VO, MSGL_V, \"vo_pxa: control %08x\\n\", request );\n    \n    switch( request )\n    {\n        case VOCTRL_QUERY_FORMAT:\n            return( vo_pxa_query_format( *(uint32_t *)data ) );\n            break;\n    }\n    \n    return VO_NOTIMPL;\n}", "path": "recipes\\mplayer\\files\\vo_pxa.c", "repo_name": "klausf/oe-imx", "stars": 1, "license": "mit", "language": "c", "size": 108250}
{"docstring": "/*****************************************************************************\n * preinit\n *\n * Preinitializes driver\n *   arg - currently it's vo_subdevice\n *   returns: zero on successful initialization, non-zero on error.\n *\n ****************************************************************************/\n", "func_signal": "static int preinit(const char *vo_subdevice)", "code": "{\n    pxa_priv_t *priv = &st_pxa_priv;\n    int rc;\n    \n    mp_msg(MSGT_VO, MSGL_V, \"vo_pxa: preinit() was called\\n\");\n\n    /* fill pxa_priv_t information */\n    memset(priv, 0, sizeof(*priv));\n    priv->fd = -1;\n    \n    /* We need to open the base framebuffer device, to change and restore modes */\n    priv->base_fd = open( \"/dev/fb0\", O_RDWR );\n    \n    if( priv->base_fd < 0 )\n    {\n        mp_msg( MSGT_VO, MSGL_ERR, \"vo_pxa: Could not open base framebuffer device\\n\");\n        return -1;\n    }\n    \n    /* Get the base fb var data, so we can restore if we change video modes */\n    rc = ioctl( priv->base_fd, FBIOGET_VSCREENINFO, &(priv->base_orig_fb_var) );\n    \n    if( rc == -1 )\n    {\n        mp_msg( MSGT_VO, MSGL_ERR, \"vo_pxa: FBIOGET_VSCREENINFO preinit base_fd failed %d\\n\",\n                errno );\n        \n        /* If this failed, close down the FD so we don't try to set this again */\n        close( priv->base_fd );\n        priv->base_fd = -1;\n        \n        return -1;\n    }\n    \n    return 0;\n}", "path": "recipes\\mplayer\\files\\vo_pxa.c", "repo_name": "klausf/oe-imx", "stars": 1, "license": "mit", "language": "c", "size": 108250}
{"docstring": "/**************************************************************************/\n/**\n*   Dumps a page of output for debugging purposes.\n*/\n", "func_signal": "void DumpMem( const char *prefix, unsigned address, const void *inData, unsigned numBytes )", "code": "{\n    const uint8_t  *data = (const uint8_t *)inData;\n    unsigned        byteOffset;\n\n    if ( numBytes == 0 )\n    {\n        Log( \"%s: No data\\n\", prefix );\n        return;\n    }\n\n#define LINE_WIDTH  16\n\n    for ( byteOffset = 0; byteOffset < numBytes; byteOffset += LINE_WIDTH ) \n    {\n        unsigned    i;\n\n        Log( \"%s: %04x: \", prefix, address + byteOffset );\n\n        for ( i = 0; i < LINE_WIDTH; i++ ) \n        {\n            if (( byteOffset + i ) < numBytes )\n            {\n                Log( \"%02.2X \", data[ byteOffset + i ] );\n            }\n            else\n            {\n                Log( \"   \" );\n            }\n        }\n        for ( i = 0; i < LINE_WIDTH; i++ ) \n        {\n            if (( byteOffset + i ) < numBytes )\n            {\n                unsigned char ch = data[ byteOffset + i ];\n                if (( ch < ' ' ) || ( ch > '~' ))\n                {\n                    Log( \".\" );\n                }\n                else\n                {\n                    Log( \"%c\", ch );\n                }\n            }\n            else\n            {\n                break;\n            }\n        }\n        Log( \"\\n\" );\n    }\n\n}", "path": "recipes\\i2c\\files\\DumpMem.c", "repo_name": "klausf/oe-imx", "stars": 1, "license": "mit", "language": "c", "size": 108250}
{"docstring": "/*\n * Display a new RGB/BGR frame of the video to the screen.\n * params:\n *   src[0] - pointer to the image\n */\n", "func_signal": "int draw_frame(uint8_t *src[])", "code": "{\n    mp_msg(MSGT_VO, MSGL_V, \"vo_w100: dummy draw_frame() was called\\n\");\n    return -1;\n}", "path": "recipes\\mplayer\\files\\vo_w100.c", "repo_name": "klausf/oe-imx", "stars": 1, "license": "mit", "language": "c", "size": 108250}
{"docstring": "/*****************************************************************************\n *\n * draw_frame\n *\n * Display a new RGB/BGR frame of the video to the screen.\n * params:\n *   src[0] - pointer to the image\n *\n ****************************************************************************/\n", "func_signal": "int draw_frame(uint8_t *src[])", "code": "{\n    /* This is not implimented */\n    mp_msg(MSGT_VO, MSGL_ERR, \"vo_pxa: dummy draw_frame() was called\\n\");\n    return -1;\n}", "path": "recipes\\mplayer\\files\\vo_pxa.c", "repo_name": "klausf/oe-imx", "stars": 1, "license": "mit", "language": "c", "size": 108250}
{"docstring": "//***************************************************************************\n/**\n*\n*   Sets the I2C address that we'll be communicating with, as well as whether\n*   the device uses smbus PEC (CRC).\n*/\n", "func_signal": "void I2cSetSlaveAddress( int i2cDev, I2C_Addr_t i2cAddr, int useCrc )", "code": "{\n    gI2cAddr = i2cAddr;\n    gUseCrc  = useCrc;\n\n    LogDebug( \"----- I2cSetSlaveAddress i2cAddr:0x%02x useCrc:%d -----\\n\",\n              i2cAddr, useCrc );\n\n    // Indicate which slave we wish to speak to\n\n    if ( ioctl( i2cDev, I2C_SLAVE, gI2cAddr ) < 0 )\n    {\n        LogError( \"I2cSetSlaveAddress: Error trying to set slave address to 0x%02x (%d %s)\\n\", \n                  gI2cAddr, errno, strerror( errno ));\n    }\n\n    // We do the CRC calculation ourself, so we don't need to tell the driver\n    // that we're using it.\n\n#if 0\n    // Indicate that we use PEC (aka CRCs)\n\n    if ( ioctl( i2cDev, I2C_PEC, 1 ) < 0 )\n    {\n        LogError( \"I2cSetSlaveAddress: Error trying to set PEC mode\\n\" );\n    }\n#endif\n\n}", "path": "recipes\\i2c-tools\\picodlp-control\\i2c-api.c", "repo_name": "klausf/oe-imx", "stars": 1, "license": "mit", "language": "c", "size": 108250}
{"docstring": "/*****************************************************************************\n * config\n *\n * Config the display driver.\n * params:\n *   src_width,srcheight: image source size\n *   dst_width,dst_height: size of the requested window size, just a hint\n *   fullscreen: flag, 0=windowd 1=fullscreen, just a hint\n *   title: window title, if available\n *   format: fourcc of pixel format\n * returns : zero on successful initialization, non-zero on error.\n *\n ****************************************************************************/\n", "func_signal": "static int config(uint32_t src_width, uint32_t src_height,\n                  uint32_t dst_width, uint32_t dst_height, uint32_t flags,\n                  char *title, uint32_t format)", "code": "{\n    pxa_priv_t *priv = &st_pxa_priv;\n    int rc;\n    int i;\n    \n    mp_msg(MSGT_VO, MSGL_V, \"vo_pxa: config() src_width:%d, src_height:%d, dst_width:%d, dst_height:%d\\n\",\n\t   src_width, src_height, dst_width, dst_height);\n\n    /* Check format */\n    if( !vo_pxa_query_format(format) )\n    {\n        mp_msg( MSGT_VO, MSGL_ERR, \"vo_pxa: unsupported fourcc for this driver: %x (%s)\\n\",\n                format, vo_format_name(format) );\n        goto err_out;\n    }\n    priv->format = format;\n    \n    /* Change resolution? */\n    priv->vm = flags & VOFLAG_MODESWITCHING;\n    if( priv->vm )\n    {\n        priv->my_fb_var = priv->base_orig_fb_var;\n        \n        /* Hard coded values suck, never mind */\n        priv->my_fb_var.xres = 240;\n        priv->my_fb_var.yres = 320;\n        priv->my_fb_var.pixclock = 134617;\n        priv->my_fb_var.left_margin = 20;\n        priv->my_fb_var.right_margin = 46;\n        priv->my_fb_var.upper_margin = 1;\n        priv->my_fb_var.lower_margin = 0;\n        priv->my_fb_var.hsync_len = 20;\n        priv->my_fb_var.vsync_len = 2;\n    \n        rc = ioctl( priv->base_fd, FBIOPUT_VSCREENINFO, &(priv->my_fb_var) );\n        \n        if( rc == -1 )\n        {\n            mp_msg( MSGT_VO, MSGL_ERR, \"vo_pxa: config() Set FBIOPUT_VSCREENINFO on base_fd failed %d\\n\",\n                    errno );\n            priv->vm = 0;\n            goto err_out;\n        }\n        \n        /* We need this sleep, to make the change in resolution actually happen, before we open the overlay */\n        sleep(1);\n    }\n \n   \n    /* Open up the overlay fbdev */\n    priv->fd = open( \"/dev/fb2\", O_RDWR );\n\n    if( priv->fd < 0 )\n    {\n        mp_msg( MSGT_VO, MSGL_ERR, \"vo_pxa: Could not open /dev/fb2: %d\\n\", errno );\n        goto err_out;\n    }\n    \n    /* Read in fb var data */\n    rc = ioctl( priv->fd, FBIOGET_VSCREENINFO, &(priv->my_fb_var) );\n    \n    if( rc == -1 )\n    {\n        mp_msg( MSGT_VO, MSGL_ERR, \"vo_pxa: config() FBIOGET_VSCREENINFO from fd failed %d\\n\",\n                errno );\n        goto err_out;\n    }\n    \n    /* Store away the source dimensions, so we can place in centre of screen later in vm mode */\n    priv->src_width = src_width;\n    priv->src_height = src_height;\n    \n    /* Set up the buffer */\n    if( priv->vm )\n    {\n        /* Ignore size, as the rest of the screen is toast. Use max size */\n        priv->my_fb_var.xres = 240;\n        priv->my_fb_var.yres = 320;\n\n        /* Do we need to rotate? */\n        if( priv->src_width > priv->src_height )\n        {\n            /* Yes */\n            priv->rotate = 1;\n        }\n\n        priv->width  = 240;\n        priv->height = 320;\n    }\n    else\n    {\n        priv->my_fb_var.xres = src_width;\n        priv->my_fb_var.yres = src_height;\n        priv->width = src_width;\n        priv->height = src_height;\n    }\n    \n    priv->my_fb_var.nonstd = ( 4 << 20)  /* Format YV12 */\n                           | ( 0 <<  0)  /* x position */\n                           | ( 0 << 10); /* y position */ \n    /* We have to set the bits per pixel to a valid value, even though it is\n     * incorrect for YV12\n     */\n    priv->my_fb_var.bits_per_pixel = 16;\n    \n    rc = ioctl( priv->fd, FBIOPUT_VSCREENINFO, &(priv->my_fb_var) );\n    \n    if( rc == -1 )\n    {\n        mp_msg( MSGT_VO, MSGL_ERR, \"vo_pxa: config() FBIOPUT_VSCREENINFO to fd failed: %d\\n\",\n                errno );\n        goto err_out;\n    }\n        \n    /* Next get the fixed fbvars, so we can mmap the data for all 3 planes */\n    rc = ioctl( priv->fd, FBIOGET_FSCREENINFO, &(priv->my_fb_fix) );\n    \n    if( rc == -1 )\n    {\n        mp_msg( MSGT_VO, MSGL_ERR, \"vo_pxa: config() FBIOGET_FSCREENINFO from fd failed: %d\\n\", \n                errno );\n        goto err_out;\n    }\n    \n    priv->fb_mem_base = mmap( NULL, priv->my_fb_fix.smem_len, (PROT_READ | PROT_WRITE ),\n                        MAP_SHARED,\n                        priv->fd,\n                        0 );\n\n    if( priv->fb_mem_base == MAP_FAILED )\n    {\n        mp_msg( MSGT_VO, MSGL_ERR, \"vo_pxa: mmap fd buffer failed: %d\\n\", errno );\n        goto err_out;\n    }\n\n    /* Finally, find the offsets of each plane by getting the var data again */\n    rc = ioctl( priv->fd, FBIOGET_VSCREENINFO, &(priv->my_fb_var) );\n    \n    if( rc == -1 )\n    {\n        mp_msg( MSGT_VO, MSGL_ERR, \"vo_pxa: config() FBIOGET_VSCREENINFO from fd (2) failed %d\\n\", \n                errno );\n        goto err_out;\n    }\n    \n    /* Fill the overlay with black */\n    memset( priv->fb_mem_base + priv->my_fb_var.red.offset, 16, priv->my_fb_var.red.length );\n    memset( priv->fb_mem_base + priv->my_fb_var.green.offset, 128, priv->my_fb_var.green.length );\n    memset( priv->fb_mem_base + priv->my_fb_var.blue.offset, 128, priv->my_fb_var.blue.length );\n    \n    /* Now open the OSD overlay - overlay 1, and fill with transparent */\n    sleep( 1 );\n    \n    priv->overlay_fd = open( \"/dev/fb1\", O_RDWR );\n\n    if( priv->overlay_fd < 0 )\n    {\n        mp_msg( MSGT_VO, MSGL_ERR, \"vo_pxa: Could not open /dev/fb1: %d\\n\", errno );\n        goto err_out;\n    }\n    \n    /* Read in fb var data */\n    rc = ioctl( priv->overlay_fd, FBIOGET_VSCREENINFO, &(priv->osd_fb_var) );\n    \n    if( rc == -1 )\n    {\n        mp_msg( MSGT_VO, MSGL_ERR, \"vo_pxa: config() FBIOGET_VSCREENINFO from overlay_fd failed; %d\\n\",\n                errno );\n        goto err_out;\n    }\n\n    priv->osd_fb_var.xres = priv->width;\n    priv->osd_fb_var.yres = priv->height;\n    priv->osd_fb_var.nonstd = ( 0 <<  0)  /* x position */\n                            | ( 0 << 10); /* y position */\n    /* Use 15 bit mode, with top bit transparency */\n    priv->osd_fb_var.bits_per_pixel = 16;\n    \n    rc = ioctl( priv->overlay_fd, FBIOPUT_VSCREENINFO, &(priv->osd_fb_var) );\n    \n    if( rc == -1 )\n    {\n        mp_msg( MSGT_VO, MSGL_ERR, \"vo_pxa: config() FBIOPUT_VSCREENINFO to overlay_fd failed: %d\\n\",\n                errno );\n        goto err_out;\n    }\n        \n    /* Next get the fixed fbvars, so we can mmap the data */\n    rc = ioctl( priv->overlay_fd, FBIOGET_FSCREENINFO, &(priv->osd_fb_fix) );\n    \n    if( rc == -1 )\n    {\n        mp_msg( MSGT_VO, MSGL_ERR, \"vo_pxa: config() FBIOGET_FSCREENINFO from overlay_fd failed %d\\n\",\n                errno );\n        goto err_out;\n    }\n    \n    priv->osd_mem_base = mmap( NULL, priv->osd_fb_fix.smem_len, (PROT_READ | PROT_WRITE ),\n                               MAP_SHARED,\n                               priv->overlay_fd,\n                               0 );\n\n    if( priv->osd_mem_base == MAP_FAILED )\n    {\n        mp_msg( MSGT_VO, MSGL_ERR, \"vo_pxa: mmap osd_mem_base failed: %d\\n\", errno );\n        goto err_out;\n    }\n    \n    /* Fill the overlay with transparent */\n    vo_pxa_clear_osd( priv->osd_mem_base, priv->osd_fb_fix.smem_len );\n\n    /* We are good to go! */\n    mp_msg( MSGT_VO, MSGL_V, \"vo_pxa: Opened video overlay %d x %d fourcc %s\\n\",\n            priv->my_fb_var.xres,\n            priv->my_fb_var.yres,\n            vo_format_name(format) );\n    \n    return 0;\n    \n    err_out:\n\n    /* Don't do anything here for the moment */\n    return -1;\n}", "path": "recipes\\mplayer\\files\\vo_pxa.c", "repo_name": "klausf/oe-imx", "stars": 1, "license": "mit", "language": "c", "size": 108250}
{"docstring": "// - - - - -\n", "func_signal": "static void ignore(u8 ignored)", "code": "{};\n\n// - - - - -\n#define BIT_DMZ         0x01\n#define BIT_DIAG        0x04\n\nvoid (*set_diag)(u8 state);\nvoid (*set_dmz)(u8 state);\n\nstatic unsigned int diag = 0;\n\nstatic void diag_change()\n{\n\tprintk(KERN_INFO \"led -> %02x\\n\",diag);\n\n\tset_diag(0xFF); // off\n\tset_dmz(0xFF); // off\n\n\tif(diag & BIT_DIAG)\n\t\tset_diag(0x00); // on\n\tif(diag & BIT_DMZ)\n\t\tset_dmz(0x00); // on\n}", "path": "recipes\\linux\\linux-wrt-2.4.20\\diag.c", "repo_name": "klausf/oe-imx", "stars": 1, "license": "mit", "language": "c", "size": 108250}
{"docstring": "/*****************************************************************************\n *\n * Internal functions, not part of mplayer API\n *\n ****************************************************************************/\n", "func_signal": "static int vo_pxa_query_format( uint32_t format )", "code": "{\n    mp_msg(MSGT_VO, MSGL_V, \"vo_pxa: vo_pxa_query_format was called: %x (%s)\\n\",\n\t   format, vo_format_name(format));\n\n    switch (format)\n    {\n        /* Planar YUV Formats */\n        /* Warning! dropthrough */\n        case IMGFMT_YV12:\n        case IMGFMT_IYUV:\n        case IMGFMT_I420:\n            return( VFCAP_CSP_SUPPORTED | VFCAP_CSP_SUPPORTED_BY_HW\n                    | VFCAP_HWSCALE_UP | VFCAP_HWSCALE_DOWN | VFCAP_OSD\n                    | VFCAP_ACCEPT_STRIDE );\n            break;\n    }\n        \n    return 0;\n}", "path": "recipes\\mplayer\\files\\vo_pxa.c", "repo_name": "klausf/oe-imx", "stars": 1, "license": "mit", "language": "c", "size": 108250}
{"docstring": "/*****************************************************************************\n *\n * draw_slice\n *\n * Draw a planar YUV slice to the buffer:\n * params:\n *   src[3] = source image planes (Y,U,V)\n *   stride[3] = source image planes line widths (in bytes)\n *   w,h = width*height of area to be copied (in Y pixels)\n *   x,y = position at the destination image (in Y pixels)\n *\n ****************************************************************************/\n", "func_signal": "int draw_slice(uint8_t *src[], int stride[], int w,int h, int x,int y)", "code": "{\n    pxa_priv_t *priv = &st_pxa_priv;\n    \n    /* This routine is only display routine actually implimented */\n    mp_msg(MSGT_VO, MSGL_V, \"vo_pxa: draw_slice() w %d h %d x %d y %d stride %d %d %d\\n\",\n           w, h, x, y, stride[0], stride[1], stride[2] );\n    \n    /* It would be faster to check if source and dest have same geometry and copy\n     * whole block\n     * For the moment we just copy a line at a time\n     */\n\n    /* In vm mode rotate if wider than long */\n    if( priv->vm )\n    {\n        /* Do we nee to rotate? */\n        if( priv->rotate )\n        {\n            /* Yes, rotated version */\n            int dst_x_offset = 0;\n            int dst_y_offset = 0;\n            int src_x_offset = 0;\n            int src_y_offset = 0;\n        \n            /* Figure out  dst offset */\n            if( priv->src_width < 320 )\n            {\n                dst_x_offset = ( ( 320 -  priv->src_width ) / 2 );\n                /* Make it a multiple of 16 */\n                dst_x_offset &= ~(0xf);\n            }\n        \n            if( priv->src_height < 240 )\n            {\n                dst_y_offset = ( ( 240 -  priv->src_height ) / 2 );\n                /* Make it a multiple of 16 */\n                dst_y_offset &= ~(0xf);\n            }\n        \n            dst_x_offset += x;\n            dst_y_offset += y;\n        \n            if( ( dst_x_offset >= 320 ) || ( dst_y_offset >= 240 ) )\n            {\n                /* Nothing to do - drawing off the screen! */\n                return( 0 );\n            }\n        \n            /* Limit to drawable area */\n            if( ( w + dst_x_offset ) > 320 )\n            {\n                w = ( 320 - dst_x_offset );\n            }\n        \n            if( ( h + dst_y_offset ) > 240 )\n            {\n                h = ( 240 - dst_y_offset );\n            }\n            \n            /* And source offset */\n            if( priv->src_width > 320 )\n            {\n                src_x_offset = ( ( priv->src_width - 320 ) / 2 );\n                /* Make it a multiple of 16 */\n                src_x_offset &= ~(0xf);\n            }\n        \n            if( priv->src_height > 240 )\n            {\n                src_y_offset = ( ( priv->src_height - 240 ) / 2 );\n                /* Make it a multiple of 16 */\n                src_y_offset &= ~(0xf);\n            }\n            \n        \n            /* Y first */\n            vo_pxa_copy_and_rotate( src[0] + src_x_offset + (src_y_offset * stride[0]), stride[0],\n                                    priv->fb_mem_base + priv->my_fb_var.red.offset  + (240 * dst_x_offset) + (240 - dst_y_offset - h),\n                                    w, h, 240 );\n            /* Now U */\n            vo_pxa_copy_and_rotate( src[1] + src_x_offset/2 + (src_y_offset/2 * stride[1]), stride[1],\n                                    priv->fb_mem_base + priv->my_fb_var.green.offset + (120 * dst_x_offset/2) + (120 - dst_y_offset/2 - h/2),\n                                    w/2, h/2, 120 );\n            vo_pxa_copy_and_rotate( src[2] + src_x_offset/2 + (src_y_offset/2 * stride[2]), stride[2],\n                                    priv->fb_mem_base + priv->my_fb_var.blue.offset + (120 * dst_x_offset/2) + (120 - dst_y_offset/2 - h/2),\n                                    w/2, h/2, 120 );\n        }\n        else\n        {\n            /* Don't rotate */\n            int i;\n            uint8_t *my_src;\n            uint8_t *dest;\n            int dst_x_offset = 0;\n            int dst_y_offset = 0;\n            int src_x_offset = 0;\n            int src_y_offset = 0;\n        \n            /* Figure out  dst offset */\n            if( priv->src_width < 240 )\n            {\n                dst_x_offset = ( ( 240 -  priv->src_width ) / 2 );\n                /* Make it a multiple of 16 */\n                dst_x_offset &= ~(0xf);\n            }\n        \n            if( priv->src_height < 320 )\n            {\n                dst_y_offset = ( ( 320 -  priv->src_height ) / 2 );\n                /* Make it a multiple of 16 */\n                dst_y_offset &= ~(0xf);\n            }\n        \n            dst_x_offset += x;\n            dst_y_offset += y;\n        \n            if( ( dst_x_offset >= 240 ) || ( dst_y_offset >= 320 ) )\n            {\n                /* Nothing to do - drawing off the screen! */\n                return( 0 );\n            }\n        \n            /* Limit to drawable area */\n            if( ( w + dst_x_offset ) > 240 )\n            {\n                w = ( 240 - dst_x_offset );\n            }\n        \n            if( ( h + dst_y_offset ) > 320 )\n            {\n                h = ( 320 - dst_y_offset );\n            }\n\n            /* And source offset */\n            if( priv->src_width > 240 )\n            {\n                src_x_offset = ( ( priv->src_width - 240 ) / 2 );\n                /* Make it a multiple of 16 */\n                src_x_offset &= ~(0xf);\n            }\n        \n            if( priv->src_height > 320 )\n            {\n                src_y_offset = ( ( priv->src_height - 320 ) / 2 );\n                /* Make it a multiple of 16 */\n                src_y_offset &= ~(0xf);\n            }\n            \n            /* First Y */\n            for( i = 0; i<h; i++ )\n            {\n                dest = priv->fb_mem_base + \n                    priv->my_fb_var.red.offset + \n                    ( (dst_y_offset+i) * priv->my_fb_fix.line_length ) +\n                    dst_x_offset;\n                my_src = src[0] + src_x_offset + (stride[0] * (i+src_y_offset));\n                memcpy( dest, my_src, w );\n            }\n\n            /* Now U */\n            for( i = 0; i<(h/2); i++ )\n            {\n                dest = priv->fb_mem_base + \n                    priv->my_fb_var.green.offset + \n                    ( ((dst_y_offset/2)+i) * (priv->my_fb_fix.line_length/2) ) +\n                    dst_x_offset/2;\n                my_src = src[1] + src_x_offset/2 + (stride[1] * (i+(src_y_offset/2)));\n                memcpy( dest, my_src, w/2 );\n            }\n    \n            /* Finaly V */\n            for( i = 0; i<(h/2); i++ )\n            {\n                dest = priv->fb_mem_base + \n                    priv->my_fb_var.blue.offset + \n                    ( ((dst_y_offset/2)+i) * (priv->my_fb_fix.line_length/2) ) +\n                    dst_x_offset/2;\n                my_src = src[2] + src_x_offset/2 + (stride[2] * (i+(src_y_offset/2)));\n                memcpy( dest, my_src, w/2 );\n            }\n            \n        }\n    }\n    else\n    {\n        /* Not full screen mode */\n        uint8_t *my_src;\n        uint8_t *dest;\n        size_t length;\n        int i;\n        \n        /* It would be faster to check if source and dest have same geometry and copy\n         * whole block\n         * For the moment we just copy a line at a time\n         */\n\n        /* Limit area written to */\n        if( x >= priv->my_fb_fix.line_length )\n        {\n            return 0;\n        }\n    \n        if( w + x > priv->my_fb_fix.line_length )\n        {\n            w = priv->my_fb_fix.line_length - x;\n        }\n    \n        if( y>= priv->my_fb_var.yres )\n        {\n            return 0;\n        }\n    \n        if( h + y > priv->my_fb_var.yres )\n        {\n            h = priv->my_fb_var.yres - y;\n        }\n    \n        /* First Y */\n        for( i = 0; i<h; i++ )\n        {\n            dest = priv->fb_mem_base + \n                priv->my_fb_var.red.offset + \n                ( (y+i) * priv->my_fb_fix.line_length ) +\n                x;\n            my_src = src[0] + stride[0] * i;\n            memcpy( dest, my_src, w );\n        }\n\n        /* Now U */\n        for( i = 0; i<(h/2); i++ )\n        {\n            dest = priv->fb_mem_base + \n                priv->my_fb_var.green.offset + \n                ( ((y/2)+i) * (priv->my_fb_fix.line_length/2) ) +\n                x;\n            my_src = src[1] + stride[1] * i;\n            memcpy( dest, my_src, w/2 );\n        }\n    \n        /* Finaly V */\n        for( i = 0; i<(h/2); i++ )\n        {\n            dest = priv->fb_mem_base + \n                priv->my_fb_var.blue.offset + \n                ( ((y/2)+i) * (priv->my_fb_fix.line_length/2) ) +\n                x;\n            my_src = src[2] + stride[2] * i;\n            memcpy( dest, my_src, w/2 );\n        }\n    }\n    return 0;\n}", "path": "recipes\\mplayer\\files\\vo_pxa.c", "repo_name": "klausf/oe-imx", "stars": 1, "license": "mit", "language": "c", "size": 108250}
{"docstring": "/*\n * Control interface\n */\n", "func_signal": "static int control(uint32_t request, void *data, ...)", "code": "{\n    w100_priv_t *priv = &st_w100_priv;\n    switch (request) {\n    case VOCTRL_GET_IMAGE:\n\treturn w100_get_image(data);\n    case VOCTRL_QUERY_FORMAT:\n\treturn query_format(*((uint32_t *)data));\n    case VOCTRL_SET_EQUALIZER:\n      {\n\tva_list ap;\n\tint value;\n\n\tva_start(ap, data);\n\tvalue = va_arg(ap, int);\n\tva_end(ap);\n\n\tif (!strcasecmp(data, \"brightness\")) {\n\t    int br;\n\t    priv->eq_brightness = value * 10;\n\t    br = (priv->eq_brightness + 1000) * 127 / 2000;\n\t    if (br < 0)\n\t\tbr = 0;\n\t    if (br > 127)\n\t\tbr = 127;\n\t    if (br > 64)\n\t\tbr -= 64;\n\t    else\n\t\tbr += 64;\n\t    priv->display_brightness = br;\n\n\t    mp_msg(MSGT_VO, MSGL_V,\n\t\t   \"vo_w100: control(VOCTRL_SET_EQUALIZER) %d %d\\n\",\n\t\t   value, br);\n\n\t    if (AtiCore_SetDisplayBrightness(priv->display_brightness))\n\t\treturn VO_TRUE;\n\t    else\n\t\treturn VO_FALSE;\n\t}\n      }\n    case VOCTRL_GET_EQUALIZER:\n      {\n\tva_list ap;\n\tint *value;\n\n\tva_start(ap, data);\n\tvalue = va_arg(ap, int*);\n\tva_end(ap);\n\n\tif (!strcasecmp(data, \"brightness\")) {\n\t    *value = priv->eq_brightness;\n\t    return VO_TRUE;\n\t} else\n\t    return VO_FALSE;\n      }\n    }\n\n    return VO_NOTIMPL;\n}", "path": "recipes\\mplayer\\files\\vo_w100.c", "repo_name": "klausf/oe-imx", "stars": 1, "license": "mit", "language": "c", "size": 108250}
{"docstring": "/*\n * Draw a planar YUV slice to the buffer:\n * params:\n *   src[3] = source image planes (Y,U,V)\n *   stride[3] = source image planes line widths (in bytes)\n *   w,h = width*height of area to be copied (in Y pixels)\n *   x,y = position at the destination image (in Y pixels)\n */\n", "func_signal": "int draw_slice(uint8_t *src[], int stride[], int w,int h, int x,int y)", "code": "{\n    mp_msg(MSGT_VO, MSGL_V, \"vo_w100: dummy draw_slice() was called\\n\");\n    return -1;\n}", "path": "recipes\\mplayer\\files\\vo_w100.c", "repo_name": "klausf/oe-imx", "stars": 1, "license": "mit", "language": "c", "size": 108250}
{"docstring": "// ----------------------------------------------------------------\n", "func_signal": "static int query_format(uint32_t format)", "code": "{\n    mp_msg(MSGT_VO, MSGL_V, \"vo_w100: query_format was called: %x (%s)\\n\",\n\t   format, vo_format_name(format));\n\n    if (IMGFMT_IS_RGB(format)) {\n\t/* RGB/BGR Formats */\n\t// TODO\n\treturn 0;\n\n\tswitch (IMGFMT_RGB_DEPTH(format)) {\n\tcase 16:\n\t    return VFCAP_CSP_SUPPORTED | VFCAP_CSP_SUPPORTED_BY_HW\n\t\t| VFCAP_HWSCALE_UP | VFCAP_HWSCALE_DOWN | VFCAP_OSD | VFCAP_ACCEPT_STRIDE;\n\t    break;\n\t}\n    } else {\n\t/* Planar YUV Formats */\n\tswitch (format) {\n\tcase IMGFMT_YV12:\n\tcase IMGFMT_IYUV:\n\tcase IMGFMT_I420:\n\tcase IMGFMT_YVU9:\n\tcase IMGFMT_IF09:\n\tcase IMGFMT_Y8:\n\tcase IMGFMT_Y800:\n\t    return VFCAP_CSP_SUPPORTED | VFCAP_CSP_SUPPORTED_BY_HW\n\t\t| VFCAP_HWSCALE_UP | VFCAP_HWSCALE_DOWN | VFCAP_OSD | VFCAP_ACCEPT_STRIDE;\n\t    break;\n\t}\n    }\n\n    return 0;\n}", "path": "recipes\\mplayer\\files\\vo_w100.c", "repo_name": "klausf/oe-imx", "stars": 1, "license": "mit", "language": "c", "size": 108250}
{"docstring": "/*****************************************************************************\n *\n * uninit\n *\n *\n ****************************************************************************/\n", "func_signal": "static void uninit(void)", "code": "{\n    pxa_priv_t *priv = &st_pxa_priv;\n    int rc;\n\n    mp_msg(MSGT_VO, MSGL_V, \"vo_pxa: uninit() was called\\n\");\n    \n    if( priv->vm )\n    {\n        /* We need these sleeps, to make the change in resolution actually happen */\n        sleep(1);\n\n        /* Restore original resolution */\n        if( priv->base_fd >= 0 )\n        {\n            rc = ioctl( priv->base_fd, FBIOPUT_VSCREENINFO, &(priv->base_orig_fb_var) );\n    \n            if( rc == -1 )\n            {\n                mp_msg( MSGT_VO, MSGL_ERR, \"vo_pxa: uninit() FBIOPUT_VSCREENINFO to base_fd failed %d\\n\",\n                        errno );\n            }\n        }\n        /* We need these sleeps, to make the change in resolution actually happen */\n        /* For some reason, if we change the reolution the overlay buffer never gets deleted? */\n        sleep(1);\n    }\n    \n\n    /* We need to force the overlays to be really disabled, otherwise they\n     * will come back as zombies after suspend, resume\n     * This trick seems to work, but will not be needed once kernel driver\n     * is fixed\n     */\n    if( priv->fd >= 0 )\n    {\n        rc = ioctl( priv->fd, FBIOGET_VSCREENINFO, &(priv->my_fb_var) );\n\n        if( rc == -1 )\n        {\n            mp_msg( MSGT_VO, MSGL_ERR, \"vo_pxa: uninit() FBIOGET_VSCREENINFO from fd failed %d\\n\",\n                    errno );\n        }\n\tpriv->my_fb_var.bits_per_pixel = 0;\n\n        rc = ioctl( priv->fd, FBIOPUT_VSCREENINFO, &(priv->my_fb_var) );\n\n        if( rc == -1 )\n        {\n            mp_msg( MSGT_VO, MSGL_ERR, \"vo_pxa: uninit() FBIOPUT_VSCREENINFO from fd failed %d\\n\",\n                    errno );\n        }\n    }\n\n    if( priv->overlay_fd >= 0 )\n    {\n        rc = ioctl( priv->overlay_fd, FBIOGET_VSCREENINFO, &(priv->my_fb_var) );\n\n        if( rc == -1 )\n        {\n            mp_msg( MSGT_VO, MSGL_ERR, \"vo_pxa: uninit() FBIOGET_VSCREENINFO from overlay_fd failed %d\\n\",\n                    errno );\n        }\n        priv->my_fb_var.bits_per_pixel = 0;\n\n        rc = ioctl( priv->overlay_fd, FBIOPUT_VSCREENINFO, &(priv->my_fb_var) );\n\n        if( rc == -1 )\n        {\n            mp_msg( MSGT_VO, MSGL_ERR, \"vo_pxa: uninit() FBIOPUT_VSCREENINFO from overlay_fd failed %d\\n\",\n                    errno );\n        }\n    }\n\n    if( priv->base_fd >= 0 )\n    {\n        close( priv->base_fd );\n        priv->base_fd = -1;\n    }\n}", "path": "recipes\\mplayer\\files\\vo_pxa.c", "repo_name": "klausf/oe-imx", "stars": 1, "license": "mit", "language": "c", "size": 108250}
{"docstring": "/*\n  w must be multiple of 8\n */\n", "func_signal": "static uint32_t w100_draw_slice_420_rotate3(uint8_t *image[], int stride[],\n\t\t\t\t\t    int w, int h, int x, int y)", "code": "{\n    w100_priv_t *priv = &st_w100_priv;\n    void *src, *dest;\n    int i, dpitch2, h_;\n\n    h_ = h;\n\n    for (i = 0; i < 3; ++i) {\n\tsrc = image[i];\n\tswitch (i) {\n\tcase 0:\n\t    dest = priv->frame_addrs[priv->current_frame].y;\n\t    dest += dstrides.y * x + dstrides.y - y;\n\t    dpitch2 = dstrides.y << 1;\n\t    break;\n\tcase 1:\n\t    dest = priv->frame_addrs[priv->current_frame].u;\n\t    dest += (dstrides.y >> 1) * (x >> 1) + (dstrides.y >> 1) - (y >> 1);\n\t    dpitch2 = dstrides.y;\n\t    h = h_ >> 1;\n\t    w >>= 1;\n\t    break;\n\tcase 2:\n\t    dest = priv->frame_addrs[priv->current_frame].v;\n\t    dest += (dstrides.y >> 1) * (x >> 1) + (dstrides.y >> 1) - (y >> 1);\n\t    h = h_ >> 1;\n\t    dpitch2 = dstrides.y;\n\t    break;\n\t}\n\n\t__asm__ __volatile__ (\n\t    \"1:\t\t\t\t\t\\n\\t\"\n\t    \"mov\tr8, %[w]\t\t\t\\n\\t\"\n\t    \"sub\t%[dest], %[dest], #1\t\t\\n\\t\"\n\t    \"mov\tr4, %[dest]\t\t\t\\n\\t\"\n\t    \"add\tr5, %[dest], %[dpitch2], lsr #1\t\t\t\\n\\t\"\n\n\t    \"2:\t\t\t\t\t\\n\\t\"\n\t    \"ldrb\tr0, [%[src]]\t\t\t\\n\\t\"\n\t    \"ldrb\tr1, [%[src], #1]\t\t\\n\\t\"\n\t    \"add\t%[src], %[src], #2\t\t\\n\\t\"\n\t    \"strb\tr0, [r4]\t\t\t\\n\\t\"\n\t    \"strb\tr1, [r5]\t\t\t\\n\\t\"\n\t    \"add\tr4, r4, %[dpitch2]\t\t\\n\\t\"\n\t    \"add\tr5, r5, %[dpitch2]\t\t\\n\\t\"\n\t    \"ldrb\tr0, [%[src]]\t\t\t\\n\\t\"\n\t    \"ldrb\tr1, [%[src], #1]\t\t\\n\\t\"\n\t    \"add\t%[src], %[src], #2\t\t\\n\\t\"\n\t    \"strb\tr0, [r4]\t\t\t\\n\\t\"\n\t    \"strb\tr1, [r5]\t\t\t\\n\\t\"\n\t    \"add\tr4, r4, %[dpitch2]\t\t\\n\\t\"\n\t    \"add\tr5, r5, %[dpitch2]\t\t\\n\\t\"\n\t    \"subs\tr8, r8, #4\t\t\t\\n\\t\"\n\t    \"bne\t2b\t\t\t\t\\n\\t\"\n\n\t    \"add\t%[src], %[src], %[srcdiff]\t\\n\\t\"\n\t    \"subs\t%[h], %[h], #1\t\t\t\\n\\t\"\n\t    \"bne\t1b\t\t\t\t\\n\\t\"\n\t    : [src]\"+r\"(src), [dest]\"+r\"(dest), [h]\"+r\"(h)\n\t    : [dpitch2]\"r\"(dpitch2), [w]\"r\"(w), [srcdiff]\"r\"(stride[i] - w)\n\t    : \"memory\", \"r0\", \"r1\", \"r4\", \"r5\", \"r8\");\n    }\n}", "path": "recipes\\mplayer\\files\\vo_w100.c", "repo_name": "klausf/oe-imx", "stars": 1, "license": "mit", "language": "c", "size": 108250}
{"docstring": "/*\n * Draws OSD to the screen buffer\n */\n", "func_signal": "static void draw_osd(void)", "code": "{\n    mp_msg(MSGT_VO, MSGL_DBG2, \"vo_w100: draw_osd() was called\\n\");\n    vo_draw_text(st_w100_priv.src_height, st_w100_priv.src_width, draw_alpha);\n}", "path": "recipes\\mplayer\\files\\vo_w100.c", "repo_name": "klausf/oe-imx", "stars": 1, "license": "mit", "language": "c", "size": 108250}
{"docstring": "/*!\n * \\brief Delete all asyncronous events of a module or script.\n *\n * This functions kills all asyncronous events of a given module or script\n * by calling the *_delete_by_owner() functions of all event types.\n *\n * \\param module The module whose bots should be deleted.\n * \\param script The script whose bots should be deleted. NULL matches everything.\n *\n * \\return The number of deleted events.\n *\n * \\bug Not all event types have a *_delete_by_owner() function yet.\n *      sockets, socketfilters and scripting functions are missing.\n */\n", "func_signal": "int script_remove_events_by_owner(egg_module_t *module, void *script)", "code": "{\n\tint removed = 0;\n\n\tremoved += botnet_delete_by_owner(module, script);\n\tremoved += partymember_delete_by_owner(module, script);\n\tremoved += kill_binds_by_owner(module, script);\n\tremoved += timer_destroy_by_owner(module, script);\n\tremoved += egg_dns_cancel_by_owner(module, script);\n\tremoved += egg_ident_cancel_by_owner(module, script);\n\treturn removed;\n}", "path": "lib\\eggdrop\\script.c", "repo_name": "sarang25491/eggdrop-1.9", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6288}
{"docstring": "/* Handles case where .match was given attributes to match against */\n", "func_signal": "static int party_matchattr(partymember_t *p, const char *mask, const char *rest)", "code": "{\n\tchar *channel = NULL, *strstart = NULL, *strlimit = NULL;\n\tlong start, limit;\n\tint ischan = 0;\n\n\tegg_get_args(rest, NULL, &channel, &strstart, &strlimit, NULL);\n\n\t/* This is probably the easiest way to conclude if content of 'channel'\n\tis *NOT* a number, and thus it is a candidate for a valid channel name */\n\tif (channel && (*channel < '0' || *channel > '9'))\n\t\tischan = 1;\n\n\n\tif (strlimit) /* .match <flags> <channel> <start> <limit> */\n\t\tparty_match_getbounds(strstart, strlimit, &start, &limit);\n\telse if (strstart) /* .match <flags> <channel|start> <limit> */\n\t\tparty_match_getbounds(ischan?strstart:channel, ischan?NULL:strstart, &start, &limit);\n\telse if (ischan) { /* .match <flags> <channel> */\n\t\tstart = 0;\n\t\tlimit = 20;\n\t}\n\telse /* .match <flags> [limit] */\n\t\tparty_match_getbounds(channel, NULL, &start, &limit);\n\n\tfree(strstart);\n\tfree(strlimit);\n\n\tif (start == -1 || limit == -1)\n\t\tpartymember_printf(p, _(\"Error: 'start' and 'limit' must be positive integers\"));\n\telse\n\t\tpartyline_cmd_match_attr(p, mask, ischan?channel:NULL, start, limit);\n\n\tfree(channel);\n\n\treturn 0;\n}", "path": "src\\core_party.c", "repo_name": "sarang25491/eggdrop-1.9", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6288}
{"docstring": "/* Called by scripting modules to unregister themselves. */\n", "func_signal": "int script_unregister_module(script_module_t *module)", "code": "{\n\tint i;\n\n\tfor (i = 0; i < nscript_modules; i++) {\n\t\tif (script_modules[i] == module) break;\n\t}\n\tif (i == nscript_modules) return(-1);\n\tmemmove(script_modules+i, script_modules+i+1, sizeof(script_module_t) * (nscript_modules-i-1));\n\tnscript_modules--;\n\treturn(0);\n}", "path": "lib\\eggdrop\\script.c", "repo_name": "sarang25491/eggdrop-1.9", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6288}
{"docstring": "/* match <attr> [channel] [[start] limit] */\n/* match <mask> [[start] limit] */\n", "func_signal": "static int party_match(partymember_t *p, const char *nick, user_t *u, const char *cmd, const char *text)", "code": "{\n\n\tchar *attr = NULL;\n\tconst char *rest = NULL;\n\n/* FIXME - Check if user is allowed to see results.. if !chan && !glob_master && -> error\n\tI have left it available to everyone because 'whois' was that way too.\n\tWe should update both or neither */\n\n\tegg_get_args(text, &rest, &attr, NULL);\n\n\tif (!attr) {\n\t\tpartymember_printf(p, _(\"Syntax: match <attr> [channel] [[start] limit]\"));\n\t\tpartymember_printf(p, _(\"    or: match <mask> [[start] limit]\"));\n\t\tfree(attr);\n\t\treturn 0;\n\t}\n\n\tif (*attr == '+' || *attr == '-' || *attr == '|')\n\t\tparty_matchattr(p, attr, rest);\n\telse if (*attr != '&')\n\t\tparty_matchwild(p, attr, rest);\n\n\tfree(attr);\n\n\treturn(BIND_RET_LOG);\n}", "path": "src\\core_party.c", "repo_name": "sarang25491/eggdrop-1.9", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6288}
{"docstring": "/* Syntax: chattr <user> [chan] <flags> */\n", "func_signal": "static int party_chattr(partymember_t *p, const char *nick, user_t *u, const char *cmd, const char *text)", "code": "{\n\tconst char *next;\n\tchar *who, *flags, *chan;\n\tuser_t *dest;\n\tflags_t flagstruct;\n\tchar flagstr[64];\n\tint n;\n\n\tn = egg_get_args(text, &next, &who, &chan, &flags, NULL);\n\tif (!chan || !*chan) {\n\t\tif (who) free(who);\n\t\tpartymember_printf(p, _(\"Syntax: chattr <handle> [channel] <+/-flags>\"));\n\t\treturn(0);\n\t}\n\tif (!flags || !*flags) {\n\t\tflags = chan;\n\t\tchan = NULL;\n\t}\n\tdest = user_lookup_by_handle(who);\n\tif (dest) {\n\t\tuser_set_flags_str(dest, chan, flags);\n\t\tuser_get_flags(dest, chan, &flagstruct);\n\t\tflag_to_str(&flagstruct, flagstr);\n\t\tpartymember_printf(p, _(\"Flags for %s are now '%s'.\"), who, flagstr);\n\t}\n\telse partymember_printf(p, _(\"'%s' is not a valid user.\"), who);\n\tfree(who);\n\tfree(flags);\n\tif (chan) free(chan);\n\treturn(0);\n}", "path": "src\\core_party.c", "repo_name": "sarang25491/eggdrop-1.9", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6288}
{"docstring": "/* Ahh, the client scripting interface. */\n", "func_signal": "int script_load(char *filename)", "code": "{\n\tint i, ret;\n\n\tegg_assert_val (filename != NULL, 0);\n\n\t/* check if we have at least one script module loaded. */\n\tif (nscript_modules == 0) {\n\t\tputlog (LOG_MISC, \"*\", _(\"Failed to load script '%s': no script modules loaded.\"),\n\t\t\tfilename);\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < nscript_modules; i++) {\n\t\tret = script_modules[i]->load_script(script_modules[i]->client_data, filename);\n\n\t\tswitch (ret) {\n\n\t\t\t/* The current module was responsible and everything worked fine\n\t\t\t */\n\t\t\tcase (SCRIPT_OK):\n\t\t\t\tputlog (LOG_MISC, \"*\", _(\"Script loaded: %s\"), filename);\n\t\t\t\treturn 1;\n\t\n\t\t\t/* The current module is not responsible for this type of\n\t\t\t * script. */\n\t\t\tcase (SCRIPT_ERR_NOT_RESPONSIBLE):\n\t\t\t\tbreak;\n\n\t\t\t/* Code error, script implementation (hopefully) put a log\n\t\t\t * message for a detailed error description. */\n\t\t\tcase (SCRIPT_ERR_CODE):\n\t\t\t\treturn 0;\n\n\t\t}\n\t}\n\n\tputlog (LOG_MISC, \"*\", _(\"Failed to load script '%s': no appropiate script module.\"), filename);\n\t\n\treturn 0;\n}", "path": "lib\\eggdrop\\script.c", "repo_name": "sarang25491/eggdrop-1.9", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6288}
{"docstring": "/* Based on TclpGetTime from Tcl 8.3.3 */\n", "func_signal": "int timer_get_time(egg_timeval_t *curtime)", "code": "{\n\tstruct timeval tv;\n\n\t(void) gettimeofday(&tv, NULL);\n\tcurtime->sec = tv.tv_sec;\n\tcurtime->usec = tv.tv_usec;\n\treturn(0);\n}", "path": "lib\\eggdrop\\timer.c", "repo_name": "sarang25491/eggdrop-1.9", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6288}
{"docstring": "/* Makes sure 'start' and 'limit' arguments for .match are reasonable, or else sets them -1 */\n", "func_signal": "static int party_match_getbounds(const char *strstart, const char *strlimit, long *start, long *limit)", "code": "{\n\tchar *tmpptr;\n\n\tif (strstart) {\n\t\t*start = strtol(strstart, &tmpptr, 10);\n\t\tif (!*strstart || *tmpptr || *start < 1) { /* Invalid input*/\n\t\t\t*start = -1;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (strlimit) { /* 'start' was really a start and this is now 'limit' */\n\t\t\t*limit = strtol(strlimit, &tmpptr, 10);\n\t\t\tif (!*strlimit || *tmpptr || *limit < 1) { /* Invalid input*/\n\t\t\t\t*limit = -1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\telse { /* Ah, no, the only argument specified was the 'limit' */\n\t\t\t*limit = *start;\n\t\t\t*start = 0;\n\t\t}\n\t}\n\telse {\n\t\t*limit = 20;\n\t\t*start = 0;\n\t}\n\n\treturn 0;\n}", "path": "src\\core_party.c", "repo_name": "sarang25491/eggdrop-1.9", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6288}
{"docstring": "/* Called by scripting modules to receive the full list of linked variables\n\tand functions. */\n", "func_signal": "int script_playback(script_module_t *module)", "code": "{\n\tint i;\n\n\tfor (i = 0; i < njournal_events; i++) {\n\t\tswitch (journal_events[i].event) {\n\t\t\tcase EVENT_VAR:\n\t\t\t\tmodule->link_var(module->client_data, journal_events[i].data);\n\t\t\t\tbreak;\n\t\t\tcase EVENT_CMD:\n\t\t\t\tmodule->create_command(module->client_data, journal_events[i].data);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn(0);\n}", "path": "lib\\eggdrop\\script.c", "repo_name": "sarang25491/eggdrop-1.9", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6288}
{"docstring": "/* Type corresponds to the mIRC mask types. */\n", "func_signal": "char *ircmask_create_separate(int type, const char *nick, const char *user, const char *host)", "code": "{\n\tchar *mask;\n\tchar ustar[2] = {0, 0};\n\tchar *domain;\n/*\n\tint replace_numbers = 0;\n\n\tif (type >= 10) {\n\t\treplace_numbers = 1;\n\t\ttype -= 10;\n\t}\n*/\n\tif (type < 5) nick = \"*\";\n\tif (type == 2 || type == 4 || type == 7 || type == 9) user = \"*\";\n\telse if (type == 1 || type == 3 || type == 6 || type == 8) {\n\t\twhile (*user && !isalnum(*user)) user++;\n\t\tustar[0] = '*';\n\t}\n\telse {\n\t\tuser = \"\";\n\t\tustar[0] = '*';\n\t}\n\n\tdomain = strdup(host);\n\tif (type == 3 || type == 4 || type == 8 || type == 9) {\n\t\tchar *dot = strrchr(host, '.');\n\t\tchar *colon = strrchr(host, ':');\n\t\tif (colon || (dot && isdigit(*(dot+1)))) {\n\t\t\t/* ipv6 or dotted decimal. */\n\t\t\tif (dot < colon) dot = colon;\n\t\t\tdomain[host-dot+1] = '*';\n\t\t\tdomain[host-dot+2] = 0;\n\t\t}\n\t\telse if (dot) {\n\t\t\tchar *dot2;\n\t\t\tdot = strchr(host, '.');\n\t\t\tif ((dot2 = strchr(dot+1, '.'))) {\n\t\t\t\tif (strlen(dot2+1) > 2) {\n\t\t\t\t\tfree(domain);\n\t\t\t\t\tdomain = egg_mprintf(\"*%s\", dot);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmask = egg_mprintf(\"%s!%s%s@%s\", nick, ustar, user, domain);\n\tfree(domain);\n\t/* replaces numbers with '?' \n\tif (replace_numbers) {\n\t\tchar *c = NULL;\n\n\t\tfor (c = mask; *c; ++c)\n\t\t\tif (isdigit((unsigned char) *c)) *c = '?';\n\t}\n\t*/\n\treturn(mask);\n}", "path": "lib\\eggdrop\\ircmasks.c", "repo_name": "sarang25491/eggdrop-1.9", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6288}
{"docstring": "/* We shall provide a handy callback interface, to reduce the amount of\n\twork in other places. */\n", "func_signal": "static int my_command_handler(void *client_data, script_args_t *args, script_var_t *retval)", "code": "{\n\tscript_command_t *cmd = client_data;\n\tvoid *static_argstack[20], *static_free_args[20];\n\tvoid **argstack, **free_args;\n\tscript_callback_t **callbacks, *static_callbacks[20];\n\tint argstack_len, nfree_args, ncallbacks;\n\tchar *syntax;\n\tint i, skip, nopts, err;\n\tvoid *simple_retval;\n\tscript_var_t var;\n\tvoid *(*callback)();\n\n\t/* Check if there is an argument count error. */\n\tif (cmd->flags & SCRIPT_VAR_ARGS) err = (cmd->nargs > args->len);\n\telse err = (cmd->nargs != args->len);\n\n\tif (err) {\n\t\tretval->type = SCRIPT_STRING | SCRIPT_ERROR;\n\t\tretval->value = cmd->syntax_error;\n\t\treturn(-1);\n\t}\n\n\t/* Get space for the argument conversion.\n\t\tWe'll try to use stack space instead of a calloc(). */\n\tif (args->len+3 > 20) {\n\t\targstack = calloc(args->len+3, sizeof(void *));\n\t\tfree_args = calloc(args->len, sizeof(void *));\n\t\tcallbacks = calloc(args->len, sizeof(*callbacks));\n\t}\n\telse {\n\t\tmemset(static_argstack, 0, sizeof(static_argstack));\n\t\targstack = static_argstack;\n\t\tfree_args = static_free_args;\n\t\tcallbacks = static_callbacks;\n\t}\n\targstack_len = 3;\n\tnfree_args = 0;\n\tncallbacks = 0;\n\n\t/* Figure out how many args to skip. */\n\tsyntax = cmd->syntax;\n\tif (cmd->flags & SCRIPT_VAR_FRONT) {\n\t\tskip = strlen(syntax) - args->len;\n\t\tif (skip < 0) skip = 0;\n\t\targstack_len += skip;\n\t\tsyntax += skip;\n\t}\n\telse skip = 0;\n\n\t/* Now start converting arguments according to the command's syntax\n\t\tstring. */\n\tfor (i = 0; i < args->len; i++) {\n\t\terr = script_get_arg(args, i, &var, *syntax);\n\t\tif (err) {\n\t\t\tretval->value = cmd->syntax_error;\n\t\t\tretval->type = SCRIPT_STRING | SCRIPT_ERROR;\n\t\t\tgoto cleanup_args;\n\t\t}\n\t\tif (var.type & SCRIPT_FREE) free_args[nfree_args++] = var.value;\n\t\telse if (*syntax == SCRIPT_CALLBACK) callbacks[ncallbacks++] = var.value;\n\t\targstack[argstack_len++] = var.value;\n\t\tsyntax++;\n\t}\n\n\t/* Calculate the optional args we want for the callback.\n\t\tThis is why we saved space for 3 args earlier on. */\n\tnopts = 3;\n\tif (cmd->flags & SCRIPT_PASS_COUNT) {\n\t\tnopts--;\n\t\targstack[nopts] = (void *)(argstack_len - 3 - skip);\n\t}\n\tif (cmd->flags & SCRIPT_PASS_RETVAL) {\n\t\tnopts--;\n\t\targstack[nopts] = retval;\n\t}\n\tif (cmd->flags & SCRIPT_PASS_CDATA) {\n\t\tnopts--;\n\t\targstack[nopts] = cmd->client_data;\n\t}\n\n\t/* Adjust the base of the argument stack. */\n\targstack += nopts;\n\targstack_len -= nopts;\n\n\t/* Execute the callback. */\n\tcallback = (void *(*)())cmd->callback;\n\tif (cmd->flags & SCRIPT_PASS_ARRAY) {\n\t\tsimple_retval = callback(argstack_len, argstack);\n\t}\n\telse {\n\t\tsimple_retval = callback(argstack[0], argstack[1],\n\t\t\targstack[2], argstack[3], argstack[4], argstack[5],\n\t\t\targstack[6], argstack[7], argstack[8], argstack[9]);\n\t}\n\n\targstack -= nopts;\n\targstack_len += nopts;\n\n\t/* Process the return value. */\n\tif (!(cmd->flags & SCRIPT_PASS_RETVAL)) {\n\t\tretval->type = cmd->retval_type;\n\t\tretval->len = -1;\n\t\tretval->value = simple_retval;\n\t}\n\ncleanup_args:\n\tfor (i = 0; i < nfree_args; i++) {\n\t\tif (free_args[i]) free(free_args[i]);\n\t}\n\tif (err) {\n\t\tfor (i = 0; i < ncallbacks; i++) {\n\t\t\tif (callbacks[i] && callbacks[i]->owner && callbacks[i]->owner->on_delete) callbacks[i]->owner->on_delete(callbacks[i]->owner, callbacks[i]);\n\t\t}\n\t}\n\tif (argstack != static_argstack) {\n\t\tfree(argstack);\n\t\tfree(free_args);\n\t\tfree(callbacks);\n\t}\n\n\treturn(0);\n}", "path": "lib\\eggdrop\\script.c", "repo_name": "sarang25491/eggdrop-1.9", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6288}
{"docstring": "/* Syntax: chhandle <old_handle> <new_handle> */\n", "func_signal": "static int party_chhandle(partymember_t *p, const char *nick, user_t *u, const char *cmd, const char *text)", "code": "{\n\tconst char *error;\n\tchar *old = NULL, *newh = NULL;\n\tuser_t *dest;\n\n\tegg_get_args(text, NULL, &old, &newh, NULL);\n\tif (!old || !newh || !*old || !*newh) {\n\t\tif (old) free(old);\n\t\tif (newh) free(newh);\n\t\tpartymember_printf(p, _(\"Syntax: chhandle <old_handle> <new_handle>\"));\n\t\treturn 0;\n\t}\n\n\tdest = user_lookup_by_handle(old);\n\tif (!dest) {\n\t\tpartymember_printf(p, _(\"Error: User '%s' does not exist.\"), old);\n\t\tfree(old);\n\t\tfree(newh);\n\t\treturn 0;\n\t}\n\n\terror = user_invalid_handle(newh);\n\tif (error) {\n\t\tpartymember_printf(p, _(\"Error: %s\"), error);\n\t\tfree(old);\n\t\tfree(newh);\n\t\treturn 0;\n\t}\n\n\tif (!user_change_handle(dest, newh))\n\t\tpartymember_printf(p, _(\"Ok, changed.\"));\n\n\tfree(newh);\n\tfree(old);\n\n\treturn(BIND_RET_LOG);\n}", "path": "src\\core_party.c", "repo_name": "sarang25491/eggdrop-1.9", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6288}
{"docstring": "/* Handles case where .match was given mask to match against */\n", "func_signal": "static int party_matchwild(partymember_t *p, const char *mask, const char *rest)", "code": "{\n\tchar *strstart = NULL, *strlimit = NULL;\n\tlong start, limit;\n\n\tegg_get_args(rest, NULL, &strstart, &strlimit, NULL);\n\n\tparty_match_getbounds(strstart, strlimit, &start, &limit);\n\tif (start == -1 || limit == -1)\n\t\tpartymember_printf(p, _(\"Error: 'start' and 'limit' must be positive integers\"));\n\telse\n\t\tpartyline_cmd_match_ircmask(p, mask, start, limit);\n\n\tfree(strstart);\n\tfree(strlimit);\n\n\treturn 0;\n}", "path": "src\\core_party.c", "repo_name": "sarang25491/eggdrop-1.9", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6288}
{"docstring": "/* Syntax: chpass <handle> [new_pass] */\n", "func_signal": "static int party_chpass(partymember_t *p, const char *nick, user_t *u, const char *cmd, const char *text)", "code": "{\n\tchar *user = NULL, *pass = NULL;\n\tuser_t *dest;\n\n\tegg_get_args(text, NULL, &user, &pass, NULL);\n\n\tif (!user || !*user) {\n\t\tpartymember_printf(p, _(\"Syntax: chpass <handle> [pass]\"));\n\t\tgoto chpassend;\n\t}\n\n\tdest = user_lookup_by_handle(user);\n\tif (!dest) {\n\t\tpartymember_printf(p, _(\"Error: User '%s' does not exist.\"), user);\n\t\tgoto chpassend;\n\t}\n\n\tif (pass && *pass && strlen(pass) < 6) {\n\t\tpartymember_printf(p, _(\"Error: Please use at least 6 characters.\"));\n\t\tgoto chpassend;\n\t}\n\n\tif (user_set_pass(dest, pass))\n\t\tpartymember_printf(p, _(\"Removed password for %s.\"), user);\n\telse\n\t\tpartymember_printf(p, _(\"Password for %s is now '%s'.\"), user, pass);\n\nchpassend:\n\tfree(user);\n\tfree(pass);\n\n\treturn(BIND_RET_LOG_COMMAND);\n}", "path": "src\\core_party.c", "repo_name": "sarang25491/eggdrop-1.9", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6288}
{"docstring": "/* Cancel an event from the journal. */\n", "func_signal": "static void *journal_del(int event, void *key)", "code": "{\n\tint i;\n\tvoid *data = NULL;\n\n\tfor (i = 0; i < njournal_events; i++) {\n\t\tif (journal_events[i].event == event && journal_events[i].key == key) break;\n\t}\n\tif (i < njournal_events) {\n\t\tdata = journal_events[i].data;\n\t\tmemmove(journal_events+i, journal_events+i+1, sizeof(*journal_events) * (njournal_events-i-1));\n\t\tnjournal_events--;\n\t}\n\n\treturn(data);\n}", "path": "lib\\eggdrop\\script.c", "repo_name": "sarang25491/eggdrop-1.9", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6288}
{"docstring": "/* Called by scripting modules to register themselves. */\n", "func_signal": "int script_register_module(script_module_t *module)", "code": "{\n\tscript_modules = realloc(script_modules, sizeof(*script_modules) * (nscript_modules+1));\n\tscript_modules[nscript_modules] = module;\n\tnscript_modules++;\n\treturn(0);\n}", "path": "lib\\eggdrop\\script.c", "repo_name": "sarang25491/eggdrop-1.9", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6288}
{"docstring": "/* SHUTDOWN_*, core_shutdown, core_restart\t*/\n", "func_signal": "static int party_help(partymember_t *p, const char *nick, user_t *u, const char *cmd, const char *text)", "code": "{\n\thelp_summary_t *entry;\n\thelp_search_t *search;\n\tint hits = 0;\n\txml_node_t *node, *arg, *desc, *see;\n\tchar *argname, *argdesc;\n\tint optional;\n\n\n\tif (!text || !*text) {\n\t\tpartymember_printf(p, \"Syntax: help <command|variable|*search*>\");\n\t\treturn(0);\n\t}\n\t/* First try to look up an exact match. */\n\tentry = help_lookup_summary(text);\n\tif (entry) {\n\t\tnode = help_lookup_entry(entry);\n\t\tpartymember_printf(p, \"Syntax:\");\n\t\tpartymember_printf(p, \"    %s\", entry->syntax);\n\t\tpartymember_printf(p, \"\");\n\t\tpartymember_printf(p, \"Summary:\");\n\t\tpartymember_printf(p, \"    %s\", entry->summary);\n\t\tpartymember_printf(p, \"\");\n\t\txml_node_get_vars(node, \"nnn\", \"desc.line\", &desc, \"args.arg\", &arg, \"seealso.see\", &see);\n\t\tif (arg) {\n\t\t\tpartymember_printf(p, \"Arguments:\");\n\t\t\tfor (; arg; arg = arg->next_sibling) {\n\t\t\t\txml_node_get_vars(arg, \"sis\", \"name\", &argname, \"optional\", &optional, \"desc\", &argdesc);\n\t\t\t\tpartymember_printf(p, \"    %s%s - %s\", argname, optional ? \" (optional)\" : \"\", argdesc);\n\t\t\t}\n\t\t\tpartymember_printf(p, \"\");\n\t\t}\n\t\tpartymember_printf(p, \"Description:\");\n\t\tfor (; desc; desc = desc->next_sibling) {\n\t\t\tpartymember_printf(p, \"    %s\", xml_node_str(desc, \"\"));\n\t\t}\n\t\tpartymember_printf(p, \"\");\n\t\tif (see) {\n\t\t\tpartymember_printf(p, \"See also:\");\n\t\t\tfor (; see; see = see->next_sibling) {\n\t\t\t\tpartymember_printf(p, \"    %s\", xml_node_str(see, \"\"));\n\t\t\t}\n\t\t}\n\t\txml_node_delete(node);\n\t\treturn(0);\n\t}\n\n\t/* No, do a search. */\n\tif (!strchr(text, '*') && !strchr(text, '?')) {\n\t\tpartymember_printf(p, \"No help was found! Try searching with wildcards, e.g. *%s*\", text);\n\t\treturn(0);\n\t}\n\n\tsearch = help_search_new(text);\n\twhile ((entry = help_search_result(search))) {\n\t\tpartymember_printf(p, \"%s - %s\", entry->syntax, entry->summary);\n\t\thits++;\n\t}\n\tif (hits == 0) {\n\t\tpartymember_printf(p, \"No help was found! Try more wildcards...\");\n\t}\n\thelp_search_end(search);\n\treturn(0);\n}", "path": "src\\core_party.c", "repo_name": "sarang25491/eggdrop-1.9", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6288}
{"docstring": "/* Add an event to our internal journal. */\n", "func_signal": "static void journal_add(int event, void *data, void *key)", "code": "{\n\tjournal_events = realloc(journal_events, sizeof(*journal_events) * (njournal_events+1));\n\tjournal_events[njournal_events].event = event;\n\tjournal_events[njournal_events].data = data;\n\tjournal_events[njournal_events].key = key;\n\tnjournal_events++;\n}", "path": "lib\\eggdrop\\script.c", "repo_name": "sarang25491/eggdrop-1.9", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6288}
{"docstring": "/* Find difference between two timers. */\n", "func_signal": "int timer_diff(egg_timeval_t *from_time, egg_timeval_t *to_time, egg_timeval_t *diff)", "code": "{\n\tdiff->sec = to_time->sec - from_time->sec;\n\tif (diff->sec < 0) {\n\t\tdiff->sec = 0;\n\t\tdiff->usec = 0;\n\t\treturn(1);\n\t}\n\n\tdiff->usec = to_time->usec - from_time->usec;\n\n\tif (diff->usec < 0) {\n\t\tif (diff->sec == 0) {\n\t\t\tdiff->usec = 0;\n\t\t\treturn(1);\n\t\t}\n\t\tdiff->sec -= 1;\n\t\tdiff->usec += 1000000;\n\t}\n\n\treturn(0);\n}", "path": "lib\\eggdrop\\timer.c", "repo_name": "sarang25491/eggdrop-1.9", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6288}
{"docstring": "/*!\n * \\brief Send a broadcast event out.\n *\n * Send a broadcast (ct) out. eggdrop1.6 expects broadcasts to originate from\n * a bot. If the source is a person, change it to the bot the person is on.\n *\n * \\param client_data The ::oldbotnet_t struct of the bot.\n * \\param src The source of the broadcast.\n * \\param text The string to broadcast.\n * \\param len The string length.\n *\n * \\return Always 0.\n */\n", "func_signal": "static int on_bcast(void *client_data, botnet_entity_t *src, const char *text, int len)", "code": "{\n\tbot_t *b = client_data;\n\n\tegg_iprintf(b->idx, \":%s broadcast :%s\", entity_net_name(src), text ? text : \"\");\n\n\treturn 0;\n}", "path": "modules\\botnet\\events.c", "repo_name": "sarang25491/eggdrop-1.9", "stars": 1, "license": "gpl-2.0", "language": "c", "size": 6288}
{"docstring": "/*\n * Protocol transceive\n */\n", "func_signal": "int ifd_protocol_transceive(ifd_protocol_t * p, int dad, const void *sbuf,\n\t\t\t    size_t slen, void *rbuf, size_t rlen)", "code": "{\n\tint rc;\n\n\tif (!p || !p->ops || !p->ops->transceive)\n\t\treturn IFD_ERROR_NOT_SUPPORTED;\n\n\tifd_debug(1, \"cmd: %s\", ct_hexdump(sbuf, slen));\n\trc = p->ops->transceive(p, dad, sbuf, slen, rbuf, rlen);\n\n\tif (rc >= 0)\n\t\tifd_debug(1, \"resp:%s\", ct_hexdump(rbuf, rc));\n\telse\n\t\tifd_debug(1, \"transceive error: %s\", ct_strerror(rc));\n\n\treturn rc;\n}", "path": "src\\ifd\\protocol.c", "repo_name": "lumag/o2scr-openct", "stars": 1, "license": "None", "language": "c", "size": 1708}
{"docstring": "/*\n * Lock file handling\n */\n", "func_signal": "static int ct_status_lock(void)", "code": "{\n\tint fd, retries = 10;\n\tint ret = -1;\n\tchar status_lock_path[PATH_MAX];\n\tchar status_temp_path[PATH_MAX];\n\n\tif (!ct_format_path(status_lock_path, PATH_MAX, \"status.lock\")) {\n\t\treturn -1;\n\t}\n\n\tsnprintf(status_temp_path, PATH_MAX,\n\t\t \"%s.%u\", status_lock_path, (unsigned int)getpid());\n\n\tif ((fd = open(status_temp_path, O_CREAT | O_RDWR, 0600)) < 0)\n\t\treturn -1;\n\n\twhile (retries--) {\n\t\tif (link(status_temp_path, status_lock_path) >= 0) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tclose(fd);\n\tunlink(status_temp_path);\n\treturn ret;\n}", "path": "src\\ct\\status.c", "repo_name": "lumag/o2scr-openct", "stars": 1, "license": "None", "language": "c", "size": 1708}
{"docstring": "/*\n * Functions for setting the SW\n */\n", "func_signal": "static int ctapi_put_sw(ct_buf_t * bp, unsigned int sw)", "code": "{\n\tunsigned char temp[2];\n\n\ttemp[0] = sw >> 8;\n\ttemp[1] = sw & 0xff;\n\n\tif (ct_buf_put(bp, temp, 2) < 0)\n\t\treturn ERR_INVALID;\n\treturn 2;\n}", "path": "src\\ctapi\\ctapi.c", "repo_name": "lumag/o2scr-openct", "stars": 1, "license": "None", "language": "c", "size": 1708}
{"docstring": "/*\n * Force the protocol driver to resynchronize\n */\n", "func_signal": "int ifd_protocol_resynchronize(ifd_protocol_t * p, int nad)", "code": "{\n\tifd_debug(1, \"called.\");\n\tif (!p || !p->ops || !p->ops->resynchronize)\n\t\treturn IFD_ERROR_NOT_SUPPORTED;\n\n\treturn p->ops->resynchronize(p, nad);\n}", "path": "src\\ifd\\protocol.c", "repo_name": "lumag/o2scr-openct", "stars": 1, "license": "None", "language": "c", "size": 1708}
{"docstring": "/*\n * Debugging aid: print packet\n */\n", "func_signal": "void ria_print_packet(ct_socket_t * sock, int level, const char *func,\n\t\t      header_t * hdr, ct_buf_t * args)", "code": "{\n\tct_buf_t temp = *args;\n\tchar buffer[128], *msg;\n\tunsigned char cmd;\n\tunsigned int len;\n\n\tif (level > ct_config.debug)\n\t\treturn;\n\n\tif (hdr->dest) {\n\t\tint err = hdr->error;\n\n\t\tmsg = \"RESP\";\n\t\tif (err) {\n\t\t\tsnprintf(buffer, sizeof(buffer),\n\t\t\t\t \"RESP, err=%d (%s)\", err, ct_strerror(err));\n\t\t\tmsg = buffer;\n\t\t}\n\t} else if (ct_buf_get(&temp, &cmd, 1) < 0) {\n\t\tmsg = \"TRUNC-CALL\";\n\t} else {\n\t\tswitch (cmd) {\n\t\tcase RIA_MGR_LIST:\n\t\t\tmsg = \"LIST\";\n\t\t\tbreak;\n\t\tcase RIA_MGR_INFO:\n\t\t\tmsg = \"INFO\";\n\t\t\tbreak;\n\t\tcase RIA_MGR_CLAIM:\n\t\t\tmsg = \"CLAIM\";\n\t\t\tbreak;\n\t\tcase RIA_MGR_REGISTER:\n\t\t\tmsg = \"REGISTER\";\n\t\t\tbreak;\n\t\tcase RIA_RESET_DEVICE:\n\t\t\tmsg = \"RESET_DEVICE\";\n\t\t\tbreak;\n\t\tcase RIA_FLUSH_DEVICE:\n\t\t\tmsg = \"FLUSH_DEVICE\";\n\t\t\tbreak;\n\t\tcase RIA_SEND_BREAK:\n\t\t\tmsg = \"SEND_BREAK\";\n\t\t\tbreak;\n\t\tcase RIA_SERIAL_GET_CONFIG:\n\t\t\tmsg = \"SERIAL_GET_CONFIG\";\n\t\t\tbreak;\n\t\tcase RIA_SERIAL_SET_CONFIG:\n\t\t\tmsg = \"SERIAL_SET_CONFIG\";\n\t\t\tbreak;\n\t\tcase RIA_DATA:\n\t\t\tmsg = \"DATA\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnprintf(buffer, sizeof(buffer), \"CALL%u\", cmd);\n\t\t\tmsg = buffer;\n\t\t}\n\t}\n\n\tlen = ct_buf_avail(&temp);\n\tif (len == 0) {\n\t\tct_debug(\"%s: [%08x] %s\", func, hdr->xid, msg);\n\t} else if (len < 16) {\n\t\tct_debug(\"%s: [%08x] %s, args%s\", func, hdr->xid, msg,\n\t\t\t ct_hexdump(ct_buf_head(&temp), len));\n\t} else {\n\t\tct_debug(\"%s: [%08x] %s, args%s ... (%u bytes total)\",\n\t\t\t func, hdr->xid, msg,\n\t\t\t ct_hexdump(ct_buf_head(&temp), 16), len);\n\t}\n}", "path": "src\\ifd\\ria.c", "repo_name": "lumag/o2scr-openct", "stars": 1, "license": "None", "language": "c", "size": 1708}
{"docstring": "/*\n * Read/write synchronous ICCs\n */\n", "func_signal": "int ifd_protocol_read_memory(ifd_protocol_t * p, int slot, unsigned short addr,\n\t\t\t     unsigned char *rbuf, size_t rlen)", "code": "{\n\tint rc;\n\n\tif (!p || !p->ops || !p->ops->sync_read)\n\t\treturn IFD_ERROR_NOT_SUPPORTED;\n\n\tifd_debug(1, \"read %u@%04x (%s)\", (unsigned int)rlen, addr,\n\t\t  p->ops->name);\n\trc = p->ops->sync_read(p, slot, addr, rbuf, rlen);\n\n\tif (rc >= 0)\n\t\tifd_debug(1, \"resp:%s\", ct_hexdump(rbuf, rc));\n\n\treturn rc;\n}", "path": "src\\ifd\\protocol.c", "repo_name": "lumag/o2scr-openct", "stars": 1, "license": "None", "language": "c", "size": 1708}
{"docstring": "/*\n * Initialize card terminal #N.\n */\n", "func_signal": "char CT_init(unsigned short ctn, unsigned short pn)", "code": "{\n\tstruct CardTerminal *ct;\n\tct_handle *h;\n\tct_info_t info;\n\tint i;\n\n\tct = (struct CardTerminal *)malloc(sizeof(struct CardTerminal));\n\tif (ct == NULL)\n\t\treturn ERR_MEMORY;\n\tif (!(h = ct_reader_connect(pn))) {\n\t\tfree(ct);\n\t\treturn ERR_INVALID;\n\t}\n\tmemset(ct, 0, sizeof(struct CardTerminal));\n\tct->ctn = ctn;\n\tct->h = h;\n\tct->next = cardTerminals;\n\tcardTerminals = ct;\n\tct->cwd = &ct->mf;\n\tct_reader_info(pn, &info);\n\tct->mf.id = 0x3f00;\n\tct->mf.gen = dir;\n\tct->mf.dir[0] = &ct->mf;\n\tct->mf.dir[1] = &ct->ctcf;\n\tct->mf.dir[2] = &ct->ctdir;\n\tfor (i = 0; i < info.ct_slots; ++i) {\n\t\tct->mf.dir[3 + i] = &ct->iccdir[i];\n\t}\n\tct->ctcf.id = 0x0020;\n\tct->ctcf.gen = ctcf;\n\tct->ctcf.dir[0] = &ct->mf;\n\tct->ctdir.id = 0x7f60;\n\tct->ctdir.gen = dir;\n\tct->ctdir.dir[0] = &ct->mf;\n\tfor (i = 0; i < info.ct_slots; ++i) {\n\t\tct->iccdir[i].id = 0x7f70 + i;\n\t\tct->iccdir[i].gen = dir;\n\t\tct->iccdir[i].dir[0] = &ct->iccdir[i];\n\t}\n\tct->hostcf.id = 0xff10;\n\tct->hostcf.gen = hostcf;\n\tct->hostcf.dir[0] = &ct->hostcf;\n\tct->hoststatus.id = 0xff11;\n\tct->hoststatus.gen = hoststatus;\n\tct->hoststatus.dir[0] = &ct->hoststatus;\n\tif (ct_card_lock(h, 0, IFD_LOCK_EXCLUSIVE, &ct->lock) < 0) {\n\t\tCT_close(ctn);\n\t\treturn ERR_HTSI;\n\t}\n\treturn OK;\n}", "path": "src\\ctapi\\ctapi.c", "repo_name": "lumag/o2scr-openct", "stars": 1, "license": "None", "language": "c", "size": 1708}
{"docstring": "/*\n * List available protocols\n */\n", "func_signal": "unsigned int ifd_protocols_list(const char **names, unsigned int max)", "code": "{\n\tstruct ifd_protocol_info *info;\n\tunsigned int n;\n\n\tfor (info = list, n = 0; info && n < max; info = info->next, n++) {\n\t\tnames[n] = info->ops->name;\n\t}\n\treturn n;\n}", "path": "src\\ifd\\protocol.c", "repo_name": "lumag/o2scr-openct", "stars": 1, "license": "None", "language": "c", "size": 1708}
{"docstring": "/*\n * Device specific portion of RIA client\n */\n", "func_signal": "static int ifd_remote_get_params(ifd_device_t * dev,\n\t\t\t\t ifd_device_params_t * params)", "code": "{\n\tria_client_t *clnt = (ria_client_t *) dev->user_data;\n\n\tifd_debug(2, \"called\");\n\tif (clnt == NULL)\n\t\treturn IFD_ERROR_DEVICE_DISCONNECTED;\n\n\tif (dev->type == IFD_DEVICE_TYPE_SERIAL) {\n\t\tria_serial_conf_t rconf;\n\t\tint rc;\n\n\t\trc = ria_command(clnt, RIA_SERIAL_GET_CONFIG,\n\t\t\t\t NULL, 0, &rconf, sizeof(rconf), -1);\n\t\tparams->serial.speed = ntohl(rconf.speed);\n\t\tparams->serial.bits = rconf.bits;\n\t\tparams->serial.stopbits = rconf.stopbits;\n\t\tparams->serial.parity = rconf.parity;\n\t\tparams->serial.check_parity = rconf.check_parity;\n\t\tparams->serial.rts = rconf.rts;\n\t\tparams->serial.dtr = rconf.dtr;\n\t\treturn 0;\n\t}\n\n\treturn IFD_ERROR_NOT_SUPPORTED;\n}", "path": "src\\ifd\\ria.c", "repo_name": "lumag/o2scr-openct", "stars": 1, "license": "None", "language": "c", "size": 1708}
{"docstring": "/*\n * Select a protocol.\n */\n", "func_signal": "static int rutoken_set_protocol(ifd_reader_t * reader, int nslot, int proto)", "code": "{\n\tifd_slot_t *slot;\n\tifd_protocol_t *p;\n\n\tifd_debug(6, \"proto=%d\", proto);\n\tif (proto != IFD_PROTOCOL_T0 && proto != IFD_PROTOCOL_TRANSPARENT) {\n\t\tct_error(\"%s: protocol %d not supported\", reader->name, proto);\n\t\treturn IFD_ERROR_NOT_SUPPORTED;\n\t}\n\tslot = &reader->slot[nslot];\n\tp = ifd_protocol_new(IFD_PROTOCOL_TRANSPARENT, reader, slot->dad);\n\tif (p == NULL) {\n\t\tct_error(\"%s: internal error\", reader->name);\n\t\treturn IFD_ERROR_GENERIC;\n\t}\n\tif (slot->proto) {\n\t\tifd_protocol_free(slot->proto);\n\t\tslot->proto = NULL;\n\t}\n\tslot->proto = p;\n\tifd_debug(6, \"success\");\n\treturn 0;\n}", "path": "src\\ifd\\ifd-rutoken.c", "repo_name": "lumag/o2scr-openct", "stars": 1, "license": "None", "language": "c", "size": 1708}
{"docstring": "/*\n * Register a protocol\n */\n", "func_signal": "int ifd_protocol_register(struct ifd_protocol_ops *ops)", "code": "{\n\tstruct ifd_protocol_info *info, **ptr;\n\n\tinfo = (struct ifd_protocol_info *)calloc(1, sizeof(*info));\n\tif (!info) {\n\t\tct_error(\"out of memory\");\n\t\treturn IFD_ERROR_NO_MEMORY;\n\t}\n\tinfo->ops = ops;\n\n\tfor (ptr = &list; *ptr; ptr = &(*ptr)->next) ;\n\t*ptr = info;\n\treturn 0;\n}", "path": "src\\ifd\\protocol.c", "repo_name": "lumag/o2scr-openct", "stars": 1, "license": "None", "language": "c", "size": 1708}
{"docstring": "/*\n * Handle card transactions\n */\n", "func_signal": "static int ctapi_transact(struct CardTerminal *ct, int nslot,\n\t\t\t  const unsigned char *cmd, size_t cmd_len, void *rsp,\n\t\t\t  size_t rsp_len)", "code": "{\n\tstatic const unsigned char select_kvk[11] =\n\t    { 0x00, 0xa4, 0x04, 0x00, 0x06, 0xd2, 0x80, 0x00, 0x00, 0x01,\n\t\t0x01\n\t};\n\tstatic const unsigned char read_binary[2] = { 0x00, 0xb0 };\n\tct_buf_t sbuf, rbuf;\n\tint rc;\n\tint le = 0;\n\n\tct_buf_set(&sbuf, (void *)cmd, cmd_len);\n\tct_buf_init(&rbuf, rsp, rsp_len);\n\n\tif (cmd_len == 4) {\n\t\tle = 0;\n\t\tct_buf_get(&sbuf, NULL, 4);\n\t} else if (cmd_len == 5 + (unsigned char)cmd[4]) {\n\t\tle = 0;\n\t\tct_buf_get(&sbuf, NULL, 5);\n\t} else {\n\t\tle = (unsigned char)cmd[4];\n\t\tct_buf_get(&sbuf, NULL, 5);\n\t}\n\tif (le == 0)\n\t\tle = 256;\n\n\tif (cmd_len == 11 && memcmp(cmd, select_kvk, 11) == 0) {\n\t\tif (ctapi_put_sw(&rbuf, 0x9000) < 0)\n\t\t\treturn ctapi_error(&rbuf, CTBCS_SW_BAD_LENGTH);\n\t\treturn ct_buf_avail(&rbuf);\n\t} else if ((ct->sync & (1 << nslot)) && cmd_len >= 5\n\t\t   && memcmp(cmd, read_binary, 2) == 0) {\n\t\tunsigned char buf[256];\n\n\t\tif ((rc =\n\t\t     ct_card_read_memory(ct->h, nslot,\n\t\t\t\t\t (((unsigned char)cmd[2]) << 8) |\n\t\t\t\t\t ((unsigned char)cmd[3]), buf,\n\t\t\t\t\t le)) < 0) {\n#if 0\n\t\t\tprintf(\"rc is %d\\n\", rc);\n#endif\n\t\t\treturn rc;\n\t\t}\n\t\tif (ct_buf_put(&rbuf, buf, rc) < 0\n\t\t    || ctapi_put_sw(&rbuf, 0x9000) < 0)\n\t\t\treturn ctapi_error(&rbuf, CTBCS_SW_BAD_LENGTH);\n\t\treturn ct_buf_avail(&rbuf);\n\t} else\n\t\treturn ct_card_transact(ct->h, 0, cmd, cmd_len, rsp, rsp_len);\n}", "path": "src\\ctapi\\ctapi.c", "repo_name": "lumag/o2scr-openct", "stars": 1, "license": "None", "language": "c", "size": 1708}
{"docstring": "/*\n * Set a protocol specific parameter\n */\n", "func_signal": "int ifd_protocol_set_parameter(ifd_protocol_t * p, int type, long value)", "code": "{\n\tif (!p || !p->ops || !p->ops->set_param)\n\t\treturn -1;\n\treturn p->ops->set_param(p, type, value);\n}", "path": "src\\ifd\\protocol.c", "repo_name": "lumag/o2scr-openct", "stars": 1, "license": "None", "language": "c", "size": 1708}
{"docstring": "/*\n * Free protocol object\n */\n", "func_signal": "void ifd_protocol_free(ifd_protocol_t * p)", "code": "{\n\tif (p->ops) {\n\t\tif (p->ops->release)\n\t\t\tp->ops->release(p);\n\t\tmemset(p, 0, p->ops->size);\n\t} else {\n\t\tmemset(p, 0, sizeof(*p));\n\t}\n\tfree(p);\n}", "path": "src\\ifd\\protocol.c", "repo_name": "lumag/o2scr-openct", "stars": 1, "license": "None", "language": "c", "size": 1708}
{"docstring": "/*\n * Reset remote device\n */\n", "func_signal": "static int ifd_remote_reset(ifd_device_t * dev)", "code": "{\n\tria_client_t *clnt = (ria_client_t *) dev->user_data;\n\n\tifd_debug(2, \"called\");\n\tif (clnt == NULL)\n\t\treturn IFD_ERROR_DEVICE_DISCONNECTED;\n\treturn ria_command(clnt, RIA_RESET_DEVICE, NULL, 0, NULL, 0, -1);\n}", "path": "src\\ifd\\ria.c", "repo_name": "lumag/o2scr-openct", "stars": 1, "license": "None", "language": "c", "size": 1708}
{"docstring": "/*\n * Create new protocol object\n */\n", "func_signal": "ifd_protocol_t *ifd_protocol_new(int id, ifd_reader_t * reader,\n\t\t\t\t unsigned int dad)", "code": "{\n\tstruct ifd_protocol_ops *ops;\n\tifd_protocol_t *p;\n\n\tif (reader == NULL)\n\t\treturn NULL;\n\n\tif (!(ops = ifd_protocol_by_id(id))) {\n\t\tct_error(\"unknown protocol id %d\", id);\n\t\treturn NULL;\n\t}\n\n\tp = (ifd_protocol_t *) calloc(1, ops->size);\n\tif (!p) {\n\t\tct_error(\"out of memory\");\n\t\treturn p;\n\t}\n\tp->reader = reader;\n\tp->ops = ops;\n\tp->dad = dad;\n\n\tif (ops->init && ops->init(p) < 0) {\n\t\tct_error(\"Protocol initialization failed\");\n\t\tifd_protocol_free(p);\n\t\treturn NULL;\n\t}\n\n\treturn p;\n}", "path": "src\\ifd\\protocol.c", "repo_name": "lumag/o2scr-openct", "stars": 1, "license": "None", "language": "c", "size": 1708}
{"docstring": "// return how mach byte send\n// sbuf - APDU bufer\n// slen\n", "func_signal": "static int rutoken_send_tpducomand(ifd_reader_t * reader, int dad, const void *sbuf, \n\t\tsize_t slen, void *rbuf, size_t rlen, int iscase4)", "code": "{\n\tifd_debug(6, \"send tpdu command %s, len: %d\", ct_hexdump(sbuf, slen), slen);\n\tint rrecv = 0;\n\tunsigned char status;\n\tunsigned char sw[2];\n\tifd_iso_apdu_t iso;\n\tif ( ifd_iso_apdu_parse(sbuf, slen, &iso) < 0)\n\t\treturn -1;\n\tunsigned char hdr[T0_HDR_LEN]={iso.cla, iso.ins, iso.p1, iso.p2, 0};\n\tswitch(iso.cse){\n\t\tcase\tIFD_APDU_CASE_1:\n\t\t\t// {cla, ins, p1, p2, 0};\n\t\t\tifd_debug(6, \"case 1\");\n\t\t\tbreak;\n\t\tcase    IFD_APDU_CASE_2S:\n\t\t\t// {cla, ins, p1, p2, le};\n\t\t\t// Rutoken Bug!!!\n\t\t\tifd_debug(6, \"case 2\");\n\t\t\tif(iso.ins == 0xa4){\n\t\t\t\thdr[4] = 0x20;\n\t\t\t\tiso.le = 0x20;\n\t\t\t}\n\t\t\telse{\n\t\t\t\thdr[4] = iso.le;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase    IFD_APDU_CASE_3S:\n\t\t\t// {cla, ins, p1, p2, lc};\n\t\t\tifd_debug(6, \"case 3\");\n\t\t\thdr[4] = iso.lc;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\t//send TPDU header\n\tif (rutoken_send(reader, 0, hdr, T0_HDR_LEN) < 0)\n\t\treturn -1;\n\t// send TPDU data or get answere and sw\n\tswitch(iso.cse){\n\t\tcase\tIFD_APDU_CASE_1:\n\t\t\t// get sw\n\t\t\tif (rutoken_recv_sw(reader, 0, sw) < 0)\n\t\t\t\treturn -2;\n\t\t\tbreak;\n\t\tcase    IFD_APDU_CASE_2S:\n\t\t\t// get answere\n\t\t\tifd_debug(6, \"Get Data %d\", iso.le);\n\t\t\tif(rutoken_getstatus(reader, &status) == ICC_STATUS_READY_DATA)\n\t\t\t{\n\t\t\t\trrecv = rutoken_recv(reader, 0, rbuf, iso.le, 10000);\n\t\t\t\tif (rrecv < 0)\n\t\t\t\t\treturn -2;\n\t\t\t\tifd_debug(6, \"Get TPDU Anser %s\", \n\t\t\t\t\t\tct_hexdump(rbuf, iso.le));\n\t\t\t}\n\t\t\tif (rutoken_recv_sw(reader, 0, sw) < 0)\n\t\t\t\treturn -2;\n\t\t\tif ( sw[0] == 0x67) {\n\t\t\t\t// Le definitely not accepted\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( (sw[0] == 0x6c) ) {\n\t\t\t\tunsigned char sbuftmp[slen];\n\t\t\t\tmemcpy(sbuftmp, sbuf, slen);\n\t\t\t\tsbuftmp[4] = sw[1];\n\t\t\t\treturn rutoken_send_tpducomand(reader, dad, sbuftmp, \n\t\t\t\t\t\tslen, rbuf,  rlen, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase    IFD_APDU_CASE_3S:\n\t\t\t// send data\n\t\t\tifd_debug(6, \"Send Data %d\", iso.lc);\n\t\t\tif(rutoken_getstatus(reader, &status) == ICC_STATUS_READY_DATA)\n\t\t\t{\n\t\t\t\tifd_debug(6, \"Send TPDU Data %s\", \n\t\t\t\t\t\tct_hexdump(iso.data, iso.lc));\n\t\t\t\tif (rutoken_send(reader, 0, iso.data, iso.lc) < 0)\n\t\t\t\t\treturn -4;\n\t\t\t} else return -3;\n\t\t\t// get sw\n\t\t\tif (rutoken_recv_sw(reader, 0, sw) < 0)\n\t\t\t\treturn -2;\n\n\t\t\t// NOT STANDART TPDU!!! BEGIN\n\t\t\tif ( sw[0]== 0x61){\n\t\t\t\tunsigned char lx = sw[1];\n\t\t\t\thdr[0] = 0x00;  //  iso.cla; (ruTokens specific)\n\t\t\t\thdr[1] = 0xc0; // ins get response\n\t\t\t\thdr[2] = 0; // p1\n\t\t\t\thdr[3] = 0; // p2\n\t\t\t\thdr[4] = lx ; //lx (case 2)\n\t\t\t\tif(iscase4)\n\t\t\t\t\treturn rutoken_send_tpducomand(reader, dad, hdr, \n\t\t\t\t\t\t\tT0_HDR_LEN, rbuf, rlen, 0);\n\t\t\t\telse {\n\t\t\t\t\tint recvtmp = rutoken_send_tpducomand(reader,dad,\n\t\t\t\t\t\t\thdr, T0_HDR_LEN, rbuf, rlen, 0);\n\t\t\t\t\trrecv = 0;\n\t\t\t\t\tmemcpy(sw, (unsigned char*)rbuf+recvtmp-2, 2);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( (sw[0] == 0x90) && (sw[1] == 0x00))\n\t\t\t{\n\t\t\t\thdr[0] = 0x00; //iso.cla;\n\t\t\t\thdr[1] = 0xc0; // ins get response\n\t\t\t\thdr[2] = 0; // p1\n\t\t\t\thdr[3] = 0; // p2\n\t\t\t\thdr[4] = iso.le; // le (case 2)\n\t\t\t\tif(iscase4)\n\t\t\t\t\treturn rutoken_send_tpducomand(reader, dad, hdr, \n\t\t\t\t\t\t\tT0_HDR_LEN, rbuf, rlen, 0);\n\t\t\t}\n\t\t\t// NOT STANDART TPDU!!! END\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\t// Add SW to respond\n\tmemcpy(((char *)rbuf)+rrecv, sw, 2);\n\trrecv+=2;\n\tifd_debug(6, \"Recv %d bytes\", rrecv);\n\treturn rrecv;\n}", "path": "src\\ifd\\ifd-rutoken.c", "repo_name": "lumag/o2scr-openct", "stars": 1, "license": "None", "language": "c", "size": 1708}
{"docstring": "/*\n * Handle CTBCS messages\n */\n", "func_signal": "static int ctapi_control(struct CardTerminal *ct, const unsigned char *cmd,\n\t\t\t size_t cmd_len, void *rsp, size_t rsp_len)", "code": "{\n\tct_buf_t sbuf, rbuf;\n\tint rc;\n\tint le = 0;\n\tunsigned char id[2];\n\n\tif (rsp_len < 2)\n\t\treturn ERR_INVALID;\n\n\tif (cmd_len < 4)\n\t\treturn ctapi_error(&rbuf, CTBCS_SW_BAD_LENGTH);\n\n\tct_buf_set(&sbuf, (void *)cmd, cmd_len);\n\tct_buf_init(&rbuf, rsp, rsp_len);\n\n\tif (cmd_len == 4) {\n\t\tle = 0;\n\t\tct_buf_get(&sbuf, NULL, 4);\n\t} else if (cmd_len == 5 + cmd[4]) {\n\t\tle = 0;\n\t\tct_buf_get(&sbuf, NULL, 5);\n\t} else {\n\t\tle = cmd[4];\n\t\tct_buf_get(&sbuf, NULL, 5);\n\t}\n\tif (le == 0)\n\t\tle = 256;\n\n\tswitch ((cmd[0] << 8) | cmd[1]) {\n\tcase (CTBCS_CLA << 8) | 0x10:\t/* B1 compatibility reset command */\n\t\tif (cmd_len != 5)\n\t\t\treturn ctapi_error(&rbuf, CTBCS_SW_BAD_LENGTH);\n\t\tif ((cmd_len == 5) && (cmd[4] != 0x00))\n\t\t\treturn ctapi_error(&rbuf, CTBCS_SW_BAD_LE);\n\t\trc = ctapi_reset(ct, cmd[2], cmd[3], &rbuf, 0, NULL);\n\t\tbreak;\n\tcase (CTBCS_CLA << 8) | CTBCS_INS_RESET:\t/* RESET_CT command */\n\t\tif (cmd_len > 5)\n\t\t\treturn ctapi_error(&rbuf, CTBCS_SW_BAD_LENGTH);\n\t\tif ((cmd_len == 5) && (cmd[4] != 0x00))\n\t\t\treturn ctapi_error(&rbuf, CTBCS_SW_BAD_LE);\n\t\trc = ctapi_reset(ct, cmd[2], cmd[3], &rbuf, 0, NULL);\n\t\tbreak;\n\tcase (CTBCS_CLA << 8) | CTBCS_INS_REQUEST_ICC:\n\t\trc = ctapi_request_icc(ct, cmd[2], cmd[3], &sbuf, &rbuf);\n\t\tbreak;\n\tcase (CTBCS_CLA << 8) | CTBCS_INS_STATUS:\n\t\trc = ctapi_status(ct->h, &rbuf);\n\t\tbreak;\n\tcase (0x00 << 8) | 0xb0:\n\t\trc = CardTerminalFile_read(ct, &rbuf, (cmd[2] << 8) | cmd[3],\n\t\t\t\t\t   le);\n\t\tbreak;\n\tcase (0x00 << 8) | 0xa4:\n\t\tif (cmd[4] != 2 || ct_buf_get(&sbuf, id, 2) == -1) {\n\t\t\tct_error(\"Bad SELECT FILE ID\");\n\t\t\trc = ctapi_error(&rbuf, CTBCS_SW_BAD_CLASS);\n\t\t} else\n\t\t\trc = CardTerminalFile_select(ct, (id[0] << 8) | id[1],\n\t\t\t\t\t\t     &rbuf);\n\t\tbreak;\n\tcase (CTBCS_CLA_2 << 8) | CTBCS_INS_SET_INTERFACE_PARAM:\n\t\trc = ctapi_set_interface_parameter(ct, cmd[2], cmd[3], &sbuf,\n\t\t\t\t\t\t   &rbuf);\n\t\tbreak;\n\tdefault:\n\t\tif (cmd[0] != CTBCS_CLA && cmd[0] != 0x00) {\n\t\t\tct_error(\"Bad CTBCS APDU, cla=0x%02x\", cmd[0]);\n\t\t\trc = ctapi_error(&rbuf, CTBCS_SW_BAD_CLASS);\n\t\t} else {\n\t\t\tct_error(\"Bad CTBCS APDU, ins=0x%02x\", cmd[1]);\n\t\t\trc = ctapi_error(&rbuf, CTBCS_SW_BAD_INS);\n\t\t}\n\t}\n\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif (ct_buf_avail(&rbuf) > le + 2)\n\t\treturn ctapi_error(&rbuf, CTBCS_SW_BAD_LENGTH);\n\n\treturn ct_buf_avail(&rbuf);\n}", "path": "src\\ctapi\\ctapi.c", "repo_name": "lumag/o2scr-openct", "stars": 1, "license": "None", "language": "c", "size": 1708}
{"docstring": "/*\n * Request ICC\n */\n", "func_signal": "static int ctapi_request_icc(struct CardTerminal *ct, char p1, char p2,\n\t\t\t     ct_buf_t * sbuf, ct_buf_t * rbuf)", "code": "{\n\ttime_t timeout = 0;\n\tchar msgbuf[256], *message;\n\n\tswitch (p2 >> 4) {\n\tcase 0x00:\n\t\t/* use default label, or label specified\n\t\t * in data. An empty message string indicates\n\t\t * the default message */\n\t\tmessage = msgbuf;\n\t\tmsgbuf[0] = '\\0';\n\t\tbreak;\n\tcase 0x0f:\n\t\t/* No message */\n\t\tmessage = NULL;\n\tdefault:\n\t\treturn ctapi_error(rbuf, CTBCS_SW_BAD_PARAMS);\n\t}\n\n\twhile (ct_buf_avail(sbuf)) {\n\t\tunsigned char type, len, val;\n\n\t\tif (ct_buf_get(sbuf, &type, 1) < 0\n\t\t    || ct_buf_get(sbuf, &len, 1) < 0\n\t\t    || ct_buf_avail(sbuf) < len)\n\t\t\tgoto bad_length;\n\n\t\tif (type == 0x50) {\n\t\t\tct_buf_get(sbuf, msgbuf, len);\n\t\t\tmsgbuf[len] = '\\0';\n\t\t} else if (type == 0x80) {\n\t\t\tif (len != 1)\n\t\t\t\tgoto bad_length;\n\t\t\tct_buf_get(sbuf, &val, 1);\n\t\t\ttimeout = val;\n\t\t} else {\n\t\t\t/* Ignore unknown tag */\n\t\t\tct_buf_get(sbuf, NULL, len);\n\t\t}\n\t}\n\n\t/* ctapi_reset does all the rest of the work */\n\treturn ctapi_reset(ct, p1, p2, rbuf, timeout, message);\n\n      bad_length:\n\treturn ctapi_error(rbuf, CTBCS_SW_BAD_LENGTH);\n}", "path": "src\\ctapi\\ctapi.c", "repo_name": "lumag/o2scr-openct", "stars": 1, "license": "None", "language": "c", "size": 1708}
{"docstring": "/*\n * Select a protocol\n */\n", "func_signal": "ifd_protocol_t *ifd_protocol_select(ifd_reader_t * reader, int nslot,\n\t\t\t\t    int preferred)", "code": "{\n\tconst ifd_driver_t *drv;\n\tifd_slot_t *slot = &reader->slot[nslot];\n\tunsigned char *atr, TDi;\n\tunsigned int supported = 0;\n\tint def_proto = -1, n, len;\n\n\tifd_debug(1, \"atr=%s\", ct_hexdump(slot->atr, slot->atr_len));\n\n\t/* FIXME: use ifd_atr_parse() instead */\n\tatr = slot->atr;\n\tlen = slot->atr_len;\n\tif (len < 2)\n\t\treturn NULL;\n\n\t/* Ignore hysterical bytes */\n\tlen -= atr[1] & 0x0f;\n\n\tn = 2;\n\tdo {\n\t\tint prot;\n\n\t\tTDi = atr[n - 1];\n\t\tif (n != 2) {\n\t\t\tprot = TDi & 0x0f;\n\t\t\tsupported |= (1 << prot);\n\t\t\tif (def_proto < 0)\n\t\t\t\tdef_proto = prot;\n\t\t}\n\n\t\tn += ifd_count_bits(TDi & 0xF0);\n\t} while (n < len && (TDi & 0x80));\n\n\tif (supported == 0)\n\t\tsupported |= 0x01;\n\tif (def_proto < 0)\n\t\tdef_proto = IFD_PROTOCOL_T0;\n\n\tifd_debug(1, \"default T=%d, supported protocols=0x%x\",\n\t\t  def_proto, supported);\n\n\tif (preferred >= 0\n\t    && preferred != def_proto && (supported & (1 << preferred))) {\n\t\t/* XXX perform PTS */\n\t\tifd_debug(1, \"protocol selection not supported\");\n\t}\n\n\tif ((drv = reader->driver) && drv->ops && drv->ops->set_protocol) {\n\t\tif (drv->ops->set_protocol(reader, nslot, def_proto) < 0)\n\t\t\treturn NULL;\n\t} else {\n\t\tslot->proto = ifd_protocol_new(def_proto, reader, slot->dad);\n\t}\n\n\treturn slot->proto;\n}", "path": "src\\ifd\\protocol.c", "repo_name": "lumag/o2scr-openct", "stars": 1, "license": "None", "language": "c", "size": 1708}
{"docstring": "/* IDE PCI access for pc */\n", "func_signal": "static uint8_t ide_pci_port_read (bloc_device_t *bd, int port)", "code": "{\n    uint8_t value;\n    value = inb(bd->io_base + port);\n    return value;\n}", "path": "src\\bloc.c", "repo_name": "ralic/openhackware", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 260}
{"docstring": "/* SCSI subset */\n/* SPC: primary commands, common to all devices */\n", "func_signal": "static int spc_inquiry_req (void *buffer, int maxlen)", "code": "{\n    uint8_t *p;\n    \n    p = buffer;\n    p[0] = 0x12;\n    /* No page code */\n    p[1] = 0x00;\n    p[2] = 0x00;\n    p[3] = maxlen >> 8;\n    p[4] = maxlen;\n    p[5] = 0x00;\n\n    return 6;\n}", "path": "src\\bloc.c", "repo_name": "ralic/openhackware", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 260}
{"docstring": "/* XXX: debug stuff only ! (TOFIX with a generic debug console) */\n", "func_signal": "int serial_write (const void *buffer, int len)", "code": "{\n    const char *p;\n\n    for (p = buffer; len > 0; len--) {\n        if (!(inb(0x3F8 + PC_SERIAL_LSR_OFFSET) & 0x20))\n            usleep(100);\n        outb(0x3F8, *p++);\n    }\n\n    return 0;\n}", "path": "src\\char.c", "repo_name": "ralic/openhackware", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 260}
{"docstring": "/* GNU extension */\n", "func_signal": "char *strndup (const char *s, size_t n)", "code": "{\n    char *dest;\n    size_t len;\n\n    len = strlen(s) + 1;\n    if (len > n)\n        len = n;\n    dest = malloc(len);\n    if (dest != NULL) {\n        memcpy(dest, s, len - 1);\n        dest[len - 1] = '\\0';\n    }\n\n    return dest;\n}", "path": "src\\libc\\src\\str.c", "repo_name": "ralic/openhackware", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 260}
{"docstring": "/* PCI devices discovery helpers */\n", "func_signal": "static inline void pci_fill_common (pci_common_t *comm, pci_u_t *parent,\n                                    int type, pci_dev_t *device)", "code": "{\n    comm->type = type;\n    comm->device = device;\n    comm->parent = parent;\n}", "path": "src\\pci.c", "repo_name": "ralic/openhackware", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 260}
{"docstring": "/* copy from (xs, ys) to (xd, yd) a rectangle of size (w, h) */\n", "func_signal": "void vga_bitblt(int xs, int ys, int xd, int yd, int w, int h)", "code": "{\n    const uint8_t *s;\n    uint8_t *d;\n    int wb, y;\n\n    wb = w * vga_fb_bpp;\n    if (yd <= ys) {\n        s = (uint8_t *)vga_fb_phys_addr + \n            vga_fb_linesize * ys + vga_fb_bpp * xs;\n        d = (uint8_t *)vga_fb_phys_addr + \n            vga_fb_linesize * yd + vga_fb_bpp * xd;\n        for (y = 0; y < h; y++) {\n            memmove(d, s, wb);\n            d += vga_fb_linesize;\n            s += vga_fb_linesize;\n        }\n    } else {\n        s = (uint8_t *)vga_fb_phys_addr + \n            vga_fb_linesize * (ys + h - 1) + vga_fb_bpp * xs;\n        d = (uint8_t *)vga_fb_phys_addr + \n            vga_fb_linesize * (yd + h - 1) + vga_fb_bpp * xd;\n       for (y = 0; y < h; y++) {\n            memmove(d, s, wb);\n            d -= vga_fb_linesize;\n            s -= vga_fb_linesize;\n        }\n    }\n}", "path": "src\\vga.c", "repo_name": "ralic/openhackware", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 260}
{"docstring": "/* Check and relocate all ADB devices as suggested in\n * ADB_manager Apple documentation\n */\n", "func_signal": "int adb_bus_init (adb_bus_t *bus)", "code": "{\n    uint8_t buffer[ADB_BUF_SIZE];\n    uint8_t adb_addresses[16] =\n        { 8, 9, 10, 11, 12, 13, 14, -1, -1, -1, -1, -1, -1, -1, 0, };\n    adb_dev_t tmp_device, **cur;\n    int address;\n    int reloc = 0, next_free = 7;\n    int keep;\n\n    /* Reset the bus */\n    ADB_DPRINTF(\"\\n\");\n    adb_reset(bus);\n    cur = &bus->devices;\n    memset(&tmp_device, 0, sizeof(adb_dev_t));\n    tmp_device.bus = bus;\n    for (address = 1; address < 8 && adb_addresses[reloc] > 0;) {\n        if (address == ADB_RES) {\n            /* Reserved */\n            address++;\n            continue;\n        }\n        ADB_DPRINTF(\"Check device on ADB address %d\\n\", address);\n        tmp_device.addr = address;\n        switch (adb_reg_get(&tmp_device, 3, buffer)) {\n        case 0:\n            ADB_DPRINTF(\"No device on ADB address %d\\n\", address);\n            /* Register this address as free */\n            if (adb_addresses[next_free] != 0)\n                adb_addresses[next_free++] = address;\n            /* Check next ADB address */\n            address++;\n            break;\n        case 2:\n            /* One device answered :\n             * make it available and relocate it to a free address\n             */\n            if (buffer[0] == ADB_CHADDR) {\n                /* device self test failed */\n                ADB_DPRINTF(\"device on ADB address %d self-test failed \"\n                            \"%02x %02x %02x\\n\", address,\n                            buffer[0], buffer[1], buffer[2]);\n                keep = 0;\n            } else {\n                ADB_DPRINTF(\"device on ADB address %d self-test OK\\n\",\n                            address);\n                keep = 1;\n            }\n            ADB_DPRINTF(\"Relocate device on ADB address %d to %d (%d)\\n\",\n                        address, adb_addresses[reloc], reloc);\n            buffer[0] = ((buffer[0] & 0x40) & ~0x90) | adb_addresses[reloc];\n            if (keep == 1)\n                buffer[0] |= 0x20;\n            buffer[1] = ADB_CHADDR_NOCOLL;\n            if (adb_reg_set(&tmp_device, 3, buffer, 2) < 0) {\n                ADB_DPRINTF(\"ADB device relocation failed\\n\");\n                return -1;\n            }\n            if (keep == 1) {\n                *cur = malloc(sizeof(adb_dev_t));\n                if (*cur == NULL) {\n                    return -1;\n                }\n                (*cur)->type = address;\n                (*cur)->bus = bus;\n                (*cur)->addr = adb_addresses[reloc++];\n                /* Flush buffers */\n                adb_flush(*cur);\n                switch ((*cur)->type) {\n                case ADB_PROTECT:\n                    ADB_DPRINTF(\"Found one protected device\\n\");\n                    break;\n                case ADB_KEYBD:\n                    ADB_DPRINTF(\"Found one keyboard\\n\");\n                    adb_kbd_new(*cur);\n                    break;\n                case ADB_MOUSE:\n                    ADB_DPRINTF(\"Found one mouse\\n\");\n                    chardev_register(CHARDEV_MOUSE, &adb_mouse_ops, *cur);\n                    break;\n                case ADB_ABS:\n                    ADB_DPRINTF(\"Found one absolute positioning device\\n\");\n                    break;\n                case ADB_MODEM:\n                    ADB_DPRINTF(\"Found one modem\\n\");\n                    break;\n                case ADB_RES:\n                    ADB_DPRINTF(\"Found one ADB res device\\n\");\n                    break;\n                case ADB_MISC:\n                    ADB_DPRINTF(\"Found one ADB misc device\\n\");\n                    break;\n                }\n                cur = &((*cur)->next);\n            }\n            break;\n        case 1:\n        case 3 ... 7:\n            /* SHOULD NOT HAPPEN : register 3 is always two bytes long */\n            ADB_DPRINTF(\"Invalid returned len for ADB register 3\\n\");\n            return -1;\n        case -1:\n            /* ADB ERROR */\n            ADB_DPRINTF(\"error gettting ADB register 3\\n\");\n            return -1;\n        }\n    }\n\n    return 0;\n}", "path": "src\\char.c", "repo_name": "ralic/openhackware", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 260}
{"docstring": "/* for depth = 8 mode, set a hardware palette entry */\n", "func_signal": "void vga_set_palette(int i, unsigned int rgba)", "code": "{\n    unsigned int r, g, b;\n\n    r = (rgba >> 16) & 0xff;\n    g = (rgba >> 8) & 0xff;\n    b = (rgba) & 0xff;\n    outb(0x3c8, i);\n    outb(0x3c9, r >> 2);\n    outb(0x3c9, g >> 2);\n    outb(0x3c9, b >> 2);\n}", "path": "src\\vga.c", "repo_name": "ralic/openhackware", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 260}
{"docstring": "/* MMC: multimedia commands */\n", "func_signal": "static int mmc_read_capacity_req (void *buffer)", "code": "{\n    uint8_t *p;\n    \n    p = buffer;\n    p[0] = 0x25;\n    p[1] = 0x00;\n    p[2] = 0x00;\n    p[3] = 0x00;\n    p[4] = 0x00;\n    p[5] = 0x00;\n    p[6] = 0x00;\n    p[7] = 0x00;\n    p[8] = 0x00;\n    p[9] = 0x00;\n\n    return 10;\n}", "path": "src\\bloc.c", "repo_name": "ralic/openhackware", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 260}
{"docstring": "/* Uninorth PCI host */\n", "func_signal": "static uint32_t macrisc_cfg_address (pci_bridge_t *bridge,\n                                     uint8_t bus, uint8_t devfn,\n                                     uint8_t offset)", "code": "{\n    uint32_t addr;\n    int i;\n\n    /* Kind of magic... */\n    if (bridge->cfg_base == 0xF2000000) {\n        if (bus != 0) {\n#if 0\n            printf(\"Skip bus: %d dev: %x offset: %x\\n\", bus, devfn, offset);\n#endif\n            return -1;\n        }\n        addr = (1 << (devfn >> 3));\n    } else {\n        addr = (bus << 16) | ((devfn & 0xF8) << 8) | 0x01;\n    }\n    addr |= ((devfn & 0x07) << 8) | (offset & 0xFC);\n    /* Avoid looping forever */\n#if 0\n    printf(\"Translate %0x %0x %d %x %x => %0x\",\n           bridge->cfg_addr, bridge->cfg_data, bus, devfn, offset, addr);\n#endif\n    for (i = 0; i < 100; i++) {\n        stswap32((uint32_t *)bridge->cfg_addr, addr);\n        eieio();\n        if (ldswap32((uint32_t *)bridge->cfg_addr) == addr)\n            break;\n    }\n    if (i == 100) {\n#if 1\n    printf(\"Translate %0x %0x %d %x %x => %0x\",\n           bridge->cfg_addr, bridge->cfg_data, bus, devfn, offset, addr);\n        printf(\"\\nTimeout accessing PCI bridge cfg address\\n\");\n#endif\n        return -1;\n    }\n    if (bridge->flags & BRIDGE_TYPE_UNINORTH)\n        offset &= 0x07;\n    else\n        offset &= 0x03;\n#if 0\n    printf(\" %0x\\n\", bridge->cfg_data + offset);\n#endif\n\n    return bridge->cfg_data + offset;\n}", "path": "src\\pci.c", "repo_name": "ralic/openhackware", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 260}
{"docstring": "/* convert a RGBA color to a color index usable in graphic primitives */\n", "func_signal": "unsigned int vga_get_color(unsigned int rgba)", "code": "{\n    unsigned int r, g, b, color;\n\n    switch(vga_fb_depth) {\n    case 8:\n        r = (rgba >> 16) & 0xff;\n        g = (rgba >> 8) & 0xff;\n        b = (rgba) & 0xff;\n        color = (rgb_to_index[r] * 6 * 6) + \n            (rgb_to_index[g] * 6) + \n            (rgb_to_index[b]);\n        break;\n    case 15:\n        r = (rgba >> 16) & 0xff;\n        g = (rgba >> 8) & 0xff;\n        b = (rgba) & 0xff;\n        color = ((r >> 3) << 10) | ((g >> 3) << 5) | (b >> 3);\n        break;\n    case 16:\n        r = (rgba >> 16) & 0xff;\n        g = (rgba >> 8) & 0xff;\n        b = (rgba) & 0xff;\n        color = ((r >> 3) << 11) | ((g >> 2) << 5) | (b >> 3);\n        break;\n    case 32:\n    default:\n        color = rgba;\n        break;\n    }\n    return color;\n}", "path": "src\\vga.c", "repo_name": "ralic/openhackware", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 260}
{"docstring": "/* Grackle PCI host */\n", "func_signal": "static uint32_t grackle_cfg_address (pci_bridge_t *bridge,\n                                     uint8_t bus, uint8_t devfn,\n                                     uint8_t offset)", "code": "{\n    uint32_t addr;\n    addr = 0x80000000 | (bus << 16) | (devfn << 8) | (offset & 0xfc);\n    stswap32((uint32_t *)bridge->cfg_addr, addr);\n    return bridge->cfg_data + (offset & 3);\n}", "path": "src\\pci.c", "repo_name": "ralic/openhackware", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 260}
{"docstring": "/* Cuda ADB glue */\n", "func_signal": "static int cuda_adb_req (void *host, const uint8_t *snd_buf, int len,\n                         uint8_t *rcv_buf)", "code": "{\n    uint8_t buffer[CUDA_BUF_SIZE], *pos;\n\n    CUDA_DPRINTF(\"len: %d %02x\\n\", len, snd_buf[0]);\n    len = cuda_request(host, ADB_PACKET, snd_buf, len, buffer);\n    if (len > 1 && buffer[0] == ADB_PACKET) {\n        pos = buffer + 2;\n        len -= 2;\n    } else {\n        pos = buffer + 1;\n        len = -1;\n    }\n    memcpy(rcv_buf, pos, len);\n\n    return len;\n}", "path": "src\\char.c", "repo_name": "ralic/openhackware", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 260}
{"docstring": "/* build standard RGB palette */\n", "func_signal": "void vga_build_rgb_palette(void)", "code": "{\n    static const uint8_t pal_value[6] = { 0x00, 0x33, 0x66, 0x99, 0xcc, 0xff };\n    int i, r, g, b;\n\n    i = 0;\n    for(r = 0; r < 6; r++) {\n        for(g = 0; g < 6; g++) {\n            for(b = 0; b < 6; b++) {\n                vga_set_palette(i, RGB(pal_value[r], pal_value[g], \n                                       pal_value[b]));\n                i++;\n            }\n        }\n    }\n    for(i = 0; i < 256; i++) {\n        rgb_to_index[i] = ((i * 5) + 128) / 255;\n    }\n}", "path": "src\\vga.c", "repo_name": "ralic/openhackware", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 260}
{"docstring": "/* depth = 8, 15, 16 or 32 */\n", "func_signal": "void vga_set_mode(int width, int height, int depth)", "code": "{\n    vbe_outw(VBE_DISPI_INDEX_XRES, width);\n    vbe_outw(VBE_DISPI_INDEX_YRES, height);\n    vbe_outw(VBE_DISPI_INDEX_BPP, depth);\n    vbe_outw(VBE_DISPI_INDEX_ENABLE, VBE_DISPI_ENABLED);\n    outb(0x3c0, 0x20); /* disable blanking */\n\n    if (vga_fb_phys_addr == 0x00000000)\n        vga_fb_phys_addr = VBE_DISPI_LFB_PHYSICAL_ADDRESS;\n    vga_fb_width = width;\n    vga_fb_height = height;\n    vga_fb_depth = depth;\n    vga_fb_bpp = (depth + 7) >> 3;\n    vga_fb_linesize = width * vga_fb_bpp;\n    \n    if (depth == 8)\n        vga_build_rgb_palette();\n    vga_text_init();\n}", "path": "src\\vga.c", "repo_name": "ralic/openhackware", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 260}
{"docstring": "/* GNU extension */\n", "func_signal": "char *strchrnul (const char *s, int c)", "code": "{\n    for (; *s != '\\0' && *s != c; s++)\n        continue;\n\n    return (char *)s;\n}", "path": "src\\libc\\src\\str.c", "repo_name": "ralic/openhackware", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 260}
{"docstring": "/* Memory image access driver */\n", "func_signal": "static int mem_initialize (bloc_device_t *bd, int device)", "code": "{\n    bd->seclen = 512;\n    bd->private = NULL;\n    bd->heads = 1;\n    bd->sects = 1;\n    bd->trks = 1;\n\n    return device == 'm';\n}", "path": "src\\bloc.c", "repo_name": "ralic/openhackware", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 260}
{"docstring": "/* FDC driver entry points */\n", "func_signal": "static int fdc_initialize (bloc_device_t *bd, int device)", "code": "{\n    uint8_t fifo[10];\n#if 0\n    uint32_t tape;\n#endif\n    int status;\n\n    if (device > 1)\n        return -1;\n    DPRINTF(\"Init FDC drive %d\\n\", device);\n    /* Manage 1.44 MB disks only, for now */\n    bd->drv = device;\n    bd->heads = 2;\n    bd->trks = 80;\n    bd->sects = 18;\n    bd->seclen = 512;\n    bd->tmp = -1;\n    fdc_reset();\n    /* Dump registers */\n    if (fdc_write_cmd(0x0E) < 0) {\n#if 0\n        ERROR(\"fdc_reset: DUMP_REGISTER != WRITE_CMD\\n\");\n#endif\n        return -1;\n    }\n    if (fdc_read_data(fifo, 10) < 0) {\n        ERROR(\"fdc_reset: DUMP_REGISTER data\\n\");\n        return -1;\n    }\n    /* SPECIFY: be sure we're not in DMA mode */\n    if (fdc_write_cmd(0x03) < 0) {\n        ERROR(\"fdc_reset: SPECIFY != WRITE_CMD\\n\");\n        return -1;\n    }\n    if (fdc_write_cmd(fifo[4]) < 0 || fdc_write_cmd(fifo[5] | 0x01)) {\n        ERROR(\"fdc_reset: SPECIFY data\\n\");\n        return -1;\n    }\n    /* Status should be WRITE_CMD right now */\n    status = inb(FDC_MAIN_STATUS);\n    if ((status & 0xD0) != 0x80) {\n        ERROR(\"fdc_initialise: read data status != WRITE_CMD: %0x\\n\",\n               status);\n        return -1;\n    }\n    /* RECALIBRATE */\n    if (fdc_recalibrate(device) < 0) {\n        printf(\"fd%c: no floppy inserted\\n\", 'a' + device);\n        return -1;\n    }\n    printf(\"fd%c initialized\\n\", 'a' + device);\n\n    return 0;\n}", "path": "src\\bloc.c", "repo_name": "ralic/openhackware", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 260}
{"docstring": "/* should base it on PCI ID, not on arch */\n", "func_signal": "static int ide_config_cb (unused pci_device_t *device)", "code": "{\n    printf(\"Register IDE controller\\n\");\n    switch (arch) {\n    case ARCH_MAC99:\n        ide_pci_pmac_register(device->regions[0] & ~0x0000000F,\n                              device->regions[1] & ~0x0000000F,\n                              device->common.OF_private);\n        break;\n    default:\n        break;\n    }\n    return 0;\n}", "path": "src\\pci.c", "repo_name": "ralic/openhackware", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 260}
{"docstring": "/* XXX: to be suppressed */\n", "func_signal": "void bd_set_boot_part (bloc_device_t *bd, part_t *partition, int partnum)", "code": "{\n    dprintf(\"%s: part %p (%p) %d\\n\", __func__, partition, bd->boot_part, partnum);\n    if (bd->boot_part == NULL) {\n        bd->boot_part = partition;\n        bd->bpartnum = partnum;\n    }\n}", "path": "src\\bloc.c", "repo_name": "ralic/openhackware", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 260}
{"docstring": "/* Board init.  */\n", "func_signal": "static void an5206_init(ram_addr_t ram_size, int vga_ram_size,\n                     const char *boot_device,\n                     const char *kernel_filename, const char *kernel_cmdline,\n                     const char *initrd_filename, const char *cpu_model)", "code": "{\n    CPUState *env;\n    int kernel_size;\n    uint64_t elf_entry;\n    target_ulong entry;\n\n    if (!cpu_model)\n        cpu_model = \"m5206\";\n    env = cpu_init(cpu_model);\n    if (!env) {\n        cpu_abort(env, \"Unable to find m68k CPU definition\\n\");\n    }\n\n    /* Initialize CPU registers.  */\n    env->vbr = 0;\n    /* TODO: allow changing MBAR and RAMBAR.  */\n    env->mbar = AN5206_MBAR_ADDR | 1;\n    env->rambar0 = AN5206_RAMBAR_ADDR | 1;\n\n    /* DRAM at address zero */\n    cpu_register_physical_memory(0, ram_size,\n        qemu_ram_alloc(ram_size) | IO_MEM_RAM);\n\n    /* Internal SRAM.  */\n    cpu_register_physical_memory(AN5206_RAMBAR_ADDR, 512,\n        qemu_ram_alloc(512) | IO_MEM_RAM);\n\n    mcf5206_init(AN5206_MBAR_ADDR, env);\n\n    /* Load kernel.  */\n    if (!kernel_filename) {\n        fprintf(stderr, \"Kernel image must be specified\\n\");\n        exit(1);\n    }\n\n    kernel_size = load_elf(kernel_filename, 0, &elf_entry, NULL, NULL);\n    entry = elf_entry;\n    if (kernel_size < 0) {\n        kernel_size = load_uimage(kernel_filename, &entry, NULL, NULL);\n    }\n    if (kernel_size < 0) {\n        kernel_size = load_image(kernel_filename,\n                                 phys_ram_base + KERNEL_LOAD_ADDR);\n        entry = KERNEL_LOAD_ADDR;\n    }\n    if (kernel_size < 0) {\n        fprintf(stderr, \"qemu: could not load kernel '%s'\\n\", kernel_filename);\n        exit(1);\n    }\n\n    env->pc = entry;\n}", "path": "hw\\an5206.c", "repo_name": "horms/qemu-xen-3.4-testing", "stars": 1, "license": "other", "language": "c", "size": 19844}
{"docstring": "/* generate a push. It depends on ss32, addseg and dflag */\n/* slower version for T1, only used for call Ev */\n", "func_signal": "static void gen_push_T1(DisasContext *s)", "code": "{\n#ifdef TARGET_X86_64\n    if (CODE64(s)) {\n        gen_op_movq_A0_reg(R_ESP);\n        if (s->dflag) {\n            gen_op_addq_A0_im(-8);\n            gen_op_st_T1_A0(OT_QUAD + s->mem_index);\n        } else {\n            gen_op_addq_A0_im(-2);\n            gen_op_st_T0_A0(OT_WORD + s->mem_index);\n        }\n        gen_op_mov_reg_A0(2, R_ESP);\n    } else\n#endif\n    {\n        gen_op_movl_A0_reg(R_ESP);\n        if (!s->dflag)\n            gen_op_addl_A0_im(-2);\n        else\n            gen_op_addl_A0_im(-4);\n        if (s->ss32) {\n            if (s->addseg) {\n                gen_op_addl_A0_seg(R_SS);\n            }\n        } else {\n            gen_op_andl_A0_ffff();\n            gen_op_addl_A0_seg(R_SS);\n        }\n        gen_op_st_T1_A0(s->dflag + 1 + s->mem_index);\n\n        if (s->ss32 && !s->addseg)\n            gen_op_mov_reg_A0(1, R_ESP);\n        else\n            gen_stack_update(s, (-2) << s->dflag);\n    }\n}", "path": "target-i386\\translate.c", "repo_name": "horms/qemu-xen-3.4-testing", "stars": 1, "license": "other", "language": "c", "size": 19844}
{"docstring": "/* compute eflags.C to reg */\n", "func_signal": "static void gen_compute_eflags_c(TCGv reg)", "code": "{\n    gen_helper_cc_compute_c(cpu_tmp2_i32, cpu_cc_op);\n    tcg_gen_extu_i32_tl(reg, cpu_tmp2_i32);\n}", "path": "target-i386\\translate.c", "repo_name": "horms/qemu-xen-3.4-testing", "stars": 1, "license": "other", "language": "c", "size": 19844}
{"docstring": "/* XXX: does not work with gdbstub \"ice\" single step - not a\n   serious problem */\n", "func_signal": "static int gen_jz_ecx_string(DisasContext *s, target_ulong next_eip)", "code": "{\n    int l1, l2;\n\n    l1 = gen_new_label();\n    l2 = gen_new_label();\n    gen_op_jnz_ecx(s->aflag, l1);\n    gen_set_label(l2);\n    gen_jmp_tb(s, next_eip, 1);\n    gen_set_label(l1);\n    return l2;\n}", "path": "target-i386\\translate.c", "repo_name": "horms/qemu-xen-3.4-testing", "stars": 1, "license": "other", "language": "c", "size": 19844}
{"docstring": "/* generate a generic end of block. Trace exception is also generated\n   if needed */\n", "func_signal": "static void gen_eob(DisasContext *s)", "code": "{\n    if (s->cc_op != CC_OP_DYNAMIC)\n        gen_op_set_cc_op(s->cc_op);\n    if (s->tb->flags & HF_INHIBIT_IRQ_MASK) {\n        gen_helper_reset_inhibit_irq();\n    }\n    if (s->singlestep_enabled) {\n        gen_helper_debug();\n    } else if (s->tf) {\n\tgen_helper_single_step();\n    } else {\n        tcg_gen_exit_tb(0);\n    }\n    s->is_jmp = 3;\n}", "path": "target-i386\\translate.c", "repo_name": "horms/qemu-xen-3.4-testing", "stars": 1, "license": "other", "language": "c", "size": 19844}
{"docstring": "/* generate a conditional jump to label 'l1' according to jump opcode\n   value 'b'. In the fast case, T0 is guaranted not to be used. */\n", "func_signal": "static inline void gen_jcc1(DisasContext *s, int cc_op, int b, int l1)", "code": "{\n    int inv, jcc_op, size, cond;\n    TCGv t0;\n\n    inv = b & 1;\n    jcc_op = (b >> 1) & 7;\n\n    switch(cc_op) {\n        /* we optimize the cmp/jcc case */\n    case CC_OP_SUBB:\n    case CC_OP_SUBW:\n    case CC_OP_SUBL:\n    case CC_OP_SUBQ:\n        \n        size = cc_op - CC_OP_SUBB;\n        switch(jcc_op) {\n        case JCC_Z:\n        fast_jcc_z:\n            switch(size) {\n            case 0:\n                tcg_gen_andi_tl(cpu_tmp0, cpu_cc_dst, 0xff);\n                t0 = cpu_tmp0;\n                break;\n            case 1:\n                tcg_gen_andi_tl(cpu_tmp0, cpu_cc_dst, 0xffff);\n                t0 = cpu_tmp0;\n                break;\n#ifdef TARGET_X86_64\n            case 2:\n                tcg_gen_andi_tl(cpu_tmp0, cpu_cc_dst, 0xffffffff);\n                t0 = cpu_tmp0;\n                break;\n#endif\n            default:\n                t0 = cpu_cc_dst;\n                break;\n            }\n            tcg_gen_brcondi_tl(inv ? TCG_COND_NE : TCG_COND_EQ, t0, 0, l1);\n            break;\n        case JCC_S:\n        fast_jcc_s:\n            switch(size) {\n            case 0:\n                tcg_gen_andi_tl(cpu_tmp0, cpu_cc_dst, 0x80);\n                tcg_gen_brcondi_tl(inv ? TCG_COND_EQ : TCG_COND_NE, cpu_tmp0, \n                                   0, l1);\n                break;\n            case 1:\n                tcg_gen_andi_tl(cpu_tmp0, cpu_cc_dst, 0x8000);\n                tcg_gen_brcondi_tl(inv ? TCG_COND_EQ : TCG_COND_NE, cpu_tmp0, \n                                   0, l1);\n                break;\n#ifdef TARGET_X86_64\n            case 2:\n                tcg_gen_andi_tl(cpu_tmp0, cpu_cc_dst, 0x80000000);\n                tcg_gen_brcondi_tl(inv ? TCG_COND_EQ : TCG_COND_NE, cpu_tmp0, \n                                   0, l1);\n                break;\n#endif\n            default:\n                tcg_gen_brcondi_tl(inv ? TCG_COND_GE : TCG_COND_LT, cpu_cc_dst, \n                                   0, l1);\n                break;\n            }\n            break;\n            \n        case JCC_B:\n            cond = inv ? TCG_COND_GEU : TCG_COND_LTU;\n            goto fast_jcc_b;\n        case JCC_BE:\n            cond = inv ? TCG_COND_GTU : TCG_COND_LEU;\n        fast_jcc_b:\n            tcg_gen_add_tl(cpu_tmp4, cpu_cc_dst, cpu_cc_src);\n            switch(size) {\n            case 0:\n                t0 = cpu_tmp0;\n                tcg_gen_andi_tl(cpu_tmp4, cpu_tmp4, 0xff);\n                tcg_gen_andi_tl(t0, cpu_cc_src, 0xff);\n                break;\n            case 1:\n                t0 = cpu_tmp0;\n                tcg_gen_andi_tl(cpu_tmp4, cpu_tmp4, 0xffff);\n                tcg_gen_andi_tl(t0, cpu_cc_src, 0xffff);\n                break;\n#ifdef TARGET_X86_64\n            case 2:\n                t0 = cpu_tmp0;\n                tcg_gen_andi_tl(cpu_tmp4, cpu_tmp4, 0xffffffff);\n                tcg_gen_andi_tl(t0, cpu_cc_src, 0xffffffff);\n                break;\n#endif\n            default:\n                t0 = cpu_cc_src;\n                break;\n            }\n            tcg_gen_brcond_tl(cond, cpu_tmp4, t0, l1);\n            break;\n            \n        case JCC_L:\n            cond = inv ? TCG_COND_GE : TCG_COND_LT;\n            goto fast_jcc_l;\n        case JCC_LE:\n            cond = inv ? TCG_COND_GT : TCG_COND_LE;\n        fast_jcc_l:\n            tcg_gen_add_tl(cpu_tmp4, cpu_cc_dst, cpu_cc_src);\n            switch(size) {\n            case 0:\n                t0 = cpu_tmp0;\n                tcg_gen_ext8s_tl(cpu_tmp4, cpu_tmp4);\n                tcg_gen_ext8s_tl(t0, cpu_cc_src);\n                break;\n            case 1:\n                t0 = cpu_tmp0;\n                tcg_gen_ext16s_tl(cpu_tmp4, cpu_tmp4);\n                tcg_gen_ext16s_tl(t0, cpu_cc_src);\n                break;\n#ifdef TARGET_X86_64\n            case 2:\n                t0 = cpu_tmp0;\n                tcg_gen_ext32s_tl(cpu_tmp4, cpu_tmp4);\n                tcg_gen_ext32s_tl(t0, cpu_cc_src);\n                break;\n#endif\n            default:\n                t0 = cpu_cc_src;\n                break;\n            }\n            tcg_gen_brcond_tl(cond, cpu_tmp4, t0, l1);\n            break;\n            \n        default:\n            goto slow_jcc;\n        }\n        break;\n        \n        /* some jumps are easy to compute */\n    case CC_OP_ADDB:\n    case CC_OP_ADDW:\n    case CC_OP_ADDL:\n    case CC_OP_ADDQ:\n        \n    case CC_OP_ADCB:\n    case CC_OP_ADCW:\n    case CC_OP_ADCL:\n    case CC_OP_ADCQ:\n        \n    case CC_OP_SBBB:\n    case CC_OP_SBBW:\n    case CC_OP_SBBL:\n    case CC_OP_SBBQ:\n        \n    case CC_OP_LOGICB:\n    case CC_OP_LOGICW:\n    case CC_OP_LOGICL:\n    case CC_OP_LOGICQ:\n        \n    case CC_OP_INCB:\n    case CC_OP_INCW:\n    case CC_OP_INCL:\n    case CC_OP_INCQ:\n        \n    case CC_OP_DECB:\n    case CC_OP_DECW:\n    case CC_OP_DECL:\n    case CC_OP_DECQ:\n        \n    case CC_OP_SHLB:\n    case CC_OP_SHLW:\n    case CC_OP_SHLL:\n    case CC_OP_SHLQ:\n        \n    case CC_OP_SARB:\n    case CC_OP_SARW:\n    case CC_OP_SARL:\n    case CC_OP_SARQ:\n        switch(jcc_op) {\n        case JCC_Z:\n            size = (cc_op - CC_OP_ADDB) & 3;\n            goto fast_jcc_z;\n        case JCC_S:\n            size = (cc_op - CC_OP_ADDB) & 3;\n            goto fast_jcc_s;\n        default:\n            goto slow_jcc;\n        }\n        break;\n    default:\n    slow_jcc:\n        gen_setcc_slow_T0(s, jcc_op);\n        tcg_gen_brcondi_tl(inv ? TCG_COND_EQ : TCG_COND_NE, \n                           cpu_T[0], 0, l1);\n        break;\n    }\n}", "path": "target-i386\\translate.c", "repo_name": "horms/qemu-xen-3.4-testing", "stars": 1, "license": "other", "language": "c", "size": 19844}
{"docstring": "/* XXX: add faster immediate = 1 case */\n", "func_signal": "static void gen_rotc_rm_T1(DisasContext *s, int ot, int op1, \n                           int is_right)", "code": "{\n    int label1;\n\n    if (s->cc_op != CC_OP_DYNAMIC)\n        gen_op_set_cc_op(s->cc_op);\n\n    /* load */\n    if (op1 == OR_TMP0)\n        gen_op_ld_T0_A0(ot + s->mem_index);\n    else\n        gen_op_mov_TN_reg(ot, 0, op1);\n    \n    if (is_right) {\n        switch (ot) {\n        case 0: gen_helper_rcrb(cpu_T[0], cpu_T[0], cpu_T[1]); break;\n        case 1: gen_helper_rcrw(cpu_T[0], cpu_T[0], cpu_T[1]); break;\n        case 2: gen_helper_rcrl(cpu_T[0], cpu_T[0], cpu_T[1]); break;\n#ifdef TARGET_X86_64\n        case 3: gen_helper_rcrq(cpu_T[0], cpu_T[0], cpu_T[1]); break;\n#endif\n        }\n    } else {\n        switch (ot) {\n        case 0: gen_helper_rclb(cpu_T[0], cpu_T[0], cpu_T[1]); break;\n        case 1: gen_helper_rclw(cpu_T[0], cpu_T[0], cpu_T[1]); break;\n        case 2: gen_helper_rcll(cpu_T[0], cpu_T[0], cpu_T[1]); break;\n#ifdef TARGET_X86_64\n        case 3: gen_helper_rclq(cpu_T[0], cpu_T[0], cpu_T[1]); break;\n#endif\n        }\n    }\n    /* store */\n    if (op1 == OR_TMP0)\n        gen_op_st_T0_A0(ot + s->mem_index);\n    else\n        gen_op_mov_reg_T0(ot, op1);\n\n    /* update eflags */\n    label1 = gen_new_label();\n    tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_cc_tmp, -1, label1);\n\n    tcg_gen_mov_tl(cpu_cc_src, cpu_cc_tmp);\n    tcg_gen_discard_tl(cpu_cc_dst);\n    tcg_gen_movi_i32(cpu_cc_op, CC_OP_EFLAGS);\n        \n    gen_set_label(label1);\n    s->cc_op = CC_OP_DYNAMIC; /* cannot predict flags after */\n}", "path": "target-i386\\translate.c", "repo_name": "horms/qemu-xen-3.4-testing", "stars": 1, "license": "other", "language": "c", "size": 19844}
{"docstring": "/* generate a push. It depends on ss32, addseg and dflag */\n", "func_signal": "static void gen_push_T0(DisasContext *s)", "code": "{\n#ifdef TARGET_X86_64\n    if (CODE64(s)) {\n        gen_op_movq_A0_reg(R_ESP);\n        if (s->dflag) {\n            gen_op_addq_A0_im(-8);\n            gen_op_st_T0_A0(OT_QUAD + s->mem_index);\n        } else {\n            gen_op_addq_A0_im(-2);\n            gen_op_st_T0_A0(OT_WORD + s->mem_index);\n        }\n        gen_op_mov_reg_A0(2, R_ESP);\n    } else\n#endif\n    {\n        gen_op_movl_A0_reg(R_ESP);\n        if (!s->dflag)\n            gen_op_addl_A0_im(-2);\n        else\n            gen_op_addl_A0_im(-4);\n        if (s->ss32) {\n            if (s->addseg) {\n                tcg_gen_mov_tl(cpu_T[1], cpu_A0);\n                gen_op_addl_A0_seg(R_SS);\n            }\n        } else {\n            gen_op_andl_A0_ffff();\n            tcg_gen_mov_tl(cpu_T[1], cpu_A0);\n            gen_op_addl_A0_seg(R_SS);\n        }\n        gen_op_st_T0_A0(s->dflag + 1 + s->mem_index);\n        if (s->ss32 && !s->addseg)\n            gen_op_mov_reg_A0(1, R_ESP);\n        else\n            gen_op_mov_reg_T1(s->ss32 + 1, R_ESP);\n    }\n}", "path": "target-i386\\translate.c", "repo_name": "horms/qemu-xen-3.4-testing", "stars": 1, "license": "other", "language": "c", "size": 19844}
{"docstring": "/* an interrupt is different from an exception because of the\n   privilege checks */\n", "func_signal": "static void gen_interrupt(DisasContext *s, int intno,\n                          target_ulong cur_eip, target_ulong next_eip)", "code": "{\n    if (s->cc_op != CC_OP_DYNAMIC)\n        gen_op_set_cc_op(s->cc_op);\n    gen_jmp_im(cur_eip);\n    gen_helper_raise_interrupt(tcg_const_i32(intno), \n                               tcg_const_i32(next_eip - cur_eip));\n    s->is_jmp = 3;\n}", "path": "target-i386\\translate.c", "repo_name": "horms/qemu-xen-3.4-testing", "stars": 1, "license": "other", "language": "c", "size": 19844}
{"docstring": "/* two step pop is necessary for precise exceptions */\n", "func_signal": "static void gen_pop_T0(DisasContext *s)", "code": "{\n#ifdef TARGET_X86_64\n    if (CODE64(s)) {\n        gen_op_movq_A0_reg(R_ESP);\n        gen_op_ld_T0_A0((s->dflag ? OT_QUAD : OT_WORD) + s->mem_index);\n    } else\n#endif\n    {\n        gen_op_movl_A0_reg(R_ESP);\n        if (s->ss32) {\n            if (s->addseg)\n                gen_op_addl_A0_seg(R_SS);\n        } else {\n            gen_op_andl_A0_ffff();\n            gen_op_addl_A0_seg(R_SS);\n        }\n        gen_op_ld_T0_A0(s->dflag + 1 + s->mem_index);\n    }\n}", "path": "target-i386\\translate.c", "repo_name": "horms/qemu-xen-3.4-testing", "stars": 1, "license": "other", "language": "c", "size": 19844}
{"docstring": "/* generate intermediate code in gen_opc_buf and gen_opparam_buf for\n   basic block 'tb'. If search_pc is TRUE, also generate PC\n   information for each intermediate instruction. */\n", "func_signal": "static inline void gen_intermediate_code_internal(CPUState *env,\n                                                  TranslationBlock *tb,\n                                                  int search_pc)", "code": "{\n    DisasContext dc1, *dc = &dc1;\n    target_ulong pc_ptr;\n    uint16_t *gen_opc_end;\n    CPUBreakpoint *bp;\n    int j, lj, cflags;\n    uint64_t flags;\n    target_ulong pc_start;\n    target_ulong cs_base;\n    int num_insns;\n    int max_insns;\n\n    /* generate intermediate code */\n    pc_start = tb->pc;\n    cs_base = tb->cs_base;\n    flags = tb->flags;\n    cflags = tb->cflags;\n\n    dc->pe = (flags >> HF_PE_SHIFT) & 1;\n    dc->code32 = (flags >> HF_CS32_SHIFT) & 1;\n    dc->ss32 = (flags >> HF_SS32_SHIFT) & 1;\n    dc->addseg = (flags >> HF_ADDSEG_SHIFT) & 1;\n    dc->f_st = 0;\n    dc->vm86 = (flags >> VM_SHIFT) & 1;\n    dc->cpl = (flags >> HF_CPL_SHIFT) & 3;\n    dc->iopl = (flags >> IOPL_SHIFT) & 3;\n    dc->tf = (flags >> TF_SHIFT) & 1;\n    dc->singlestep_enabled = env->singlestep_enabled;\n    dc->cc_op = CC_OP_DYNAMIC;\n    dc->cs_base = cs_base;\n    dc->tb = tb;\n    dc->popl_esp_hack = 0;\n    /* select memory access functions */\n    dc->mem_index = 0;\n    if (flags & HF_SOFTMMU_MASK) {\n        if (dc->cpl == 3)\n            dc->mem_index = 2 * 4;\n        else\n            dc->mem_index = 1 * 4;\n    }\n    dc->cpuid_features = env->cpuid_features;\n    dc->cpuid_ext_features = env->cpuid_ext_features;\n    dc->cpuid_ext2_features = env->cpuid_ext2_features;\n    dc->cpuid_ext3_features = env->cpuid_ext3_features;\n#ifdef TARGET_X86_64\n    dc->lma = (flags >> HF_LMA_SHIFT) & 1;\n    dc->code64 = (flags >> HF_CS64_SHIFT) & 1;\n#endif\n    dc->flags = flags;\n    dc->jmp_opt = !(dc->tf || env->singlestep_enabled ||\n                    (flags & HF_INHIBIT_IRQ_MASK)\n#ifndef CONFIG_SOFTMMU\n                    || (flags & HF_SOFTMMU_MASK)\n#endif\n                    );\n#if 0\n    /* check addseg logic */\n    if (!dc->addseg && (dc->vm86 || !dc->pe || !dc->code32))\n        printf(\"ERROR addseg\\n\");\n#endif\n\n    cpu_T[0] = tcg_temp_new();\n    cpu_T[1] = tcg_temp_new();\n    cpu_A0 = tcg_temp_new();\n    cpu_T3 = tcg_temp_new();\n\n    cpu_tmp0 = tcg_temp_new();\n    cpu_tmp1_i64 = tcg_temp_new_i64();\n    cpu_tmp2_i32 = tcg_temp_new_i32();\n    cpu_tmp3_i32 = tcg_temp_new_i32();\n    cpu_tmp4 = tcg_temp_new();\n    cpu_tmp5 = tcg_temp_new();\n    cpu_tmp6 = tcg_temp_new();\n    cpu_ptr0 = tcg_temp_new_ptr();\n    cpu_ptr1 = tcg_temp_new_ptr();\n\n    gen_opc_end = gen_opc_buf + OPC_MAX_SIZE;\n\n    dc->is_jmp = DISAS_NEXT;\n    pc_ptr = pc_start;\n    lj = -1;\n    num_insns = 0;\n    max_insns = tb->cflags & CF_COUNT_MASK;\n    if (max_insns == 0)\n        max_insns = CF_COUNT_MASK;\n\n    gen_icount_start();\n    for(;;) {\n        if (unlikely(!TAILQ_EMPTY(&env->breakpoints))) {\n            TAILQ_FOREACH(bp, &env->breakpoints, entry) {\n                if (bp->pc == pc_ptr) {\n                    gen_debug(dc, pc_ptr - dc->cs_base);\n                    break;\n                }\n            }\n        }\n        if (search_pc) {\n            j = gen_opc_ptr - gen_opc_buf;\n            if (lj < j) {\n                lj++;\n                while (lj < j)\n                    gen_opc_instr_start[lj++] = 0;\n            }\n            gen_opc_pc[lj] = pc_ptr;\n            gen_opc_cc_op[lj] = dc->cc_op;\n            gen_opc_instr_start[lj] = 1;\n            gen_opc_icount[lj] = num_insns;\n        }\n        if (num_insns + 1 == max_insns && (tb->cflags & CF_LAST_IO))\n            gen_io_start();\n\n        pc_ptr = disas_insn(dc, pc_ptr);\n        num_insns++;\n        /* stop translation if indicated */\n        if (dc->is_jmp)\n            break;\n        /* if single step mode, we generate only one instruction and\n           generate an exception */\n        /* if irq were inhibited with HF_INHIBIT_IRQ_MASK, we clear\n           the flag and abort the translation to give the irqs a\n           change to be happen */\n        if (dc->tf || dc->singlestep_enabled ||\n            (flags & HF_INHIBIT_IRQ_MASK)) {\n            gen_jmp_im(pc_ptr - dc->cs_base);\n            gen_eob(dc);\n            break;\n        }\n        /* if too long translation, stop generation too */\n        if (gen_opc_ptr >= gen_opc_end ||\n            (pc_ptr - pc_start) >= (TARGET_PAGE_SIZE - 32) ||\n            num_insns >= max_insns) {\n            gen_jmp_im(pc_ptr - dc->cs_base);\n            gen_eob(dc);\n            break;\n        }\n    }\n    if (tb->cflags & CF_LAST_IO)\n        gen_io_end();\n    gen_icount_end(tb, num_insns);\n    *gen_opc_ptr = INDEX_op_end;\n    /* we don't forget to fill the last values */\n    if (search_pc) {\n        j = gen_opc_ptr - gen_opc_buf;\n        lj++;\n        while (lj <= j)\n            gen_opc_instr_start[lj++] = 0;\n    }\n\n#ifdef DEBUG_DISAS\n    log_cpu_state_mask(CPU_LOG_TB_CPU, env, X86_DUMP_CCOP);\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n        int disas_flags;\n        qemu_log(\"----------------\\n\");\n        qemu_log(\"IN: %s\\n\", lookup_symbol(pc_start));\n#ifdef TARGET_X86_64\n        if (dc->code64)\n            disas_flags = 2;\n        else\n#endif\n            disas_flags = !dc->code32;\n        log_target_disas(pc_start, pc_ptr - pc_start, disas_flags);\n        qemu_log(\"\\n\");\n    }\n#endif\n\n    if (!search_pc) {\n        tb->size = pc_ptr - pc_start;\n        tb->icount = num_insns;\n    }\n}", "path": "target-i386\\translate.c", "repo_name": "horms/qemu-xen-3.4-testing", "stars": 1, "license": "other", "language": "c", "size": 19844}
{"docstring": "/* NOTE the exception in \"r\" op ordering */\n", "func_signal": "static void gen_helper_fp_arith_STN_ST0(int op, int opreg)", "code": "{\n    TCGv_i32 tmp = tcg_const_i32(opreg);\n    switch (op) {\n    case 0: gen_helper_fadd_STN_ST0(tmp); break;\n    case 1: gen_helper_fmul_STN_ST0(tmp); break;\n    case 4: gen_helper_fsubr_STN_ST0(tmp); break;\n    case 5: gen_helper_fsub_STN_ST0(tmp); break;\n    case 6: gen_helper_fdivr_STN_ST0(tmp); break;\n    case 7: gen_helper_fdiv_STN_ST0(tmp); break;\n    }\n}", "path": "target-i386\\translate.c", "repo_name": "horms/qemu-xen-3.4-testing", "stars": 1, "license": "other", "language": "c", "size": 19844}
{"docstring": "/* if d == OR_TMP0, it means memory operand (address in A0) */\n", "func_signal": "static void gen_inc(DisasContext *s1, int ot, int d, int c)", "code": "{\n    if (d != OR_TMP0)\n        gen_op_mov_TN_reg(ot, 0, d);\n    else\n        gen_op_ld_T0_A0(ot + s1->mem_index);\n    if (s1->cc_op != CC_OP_DYNAMIC)\n        gen_op_set_cc_op(s1->cc_op);\n    if (c > 0) {\n        tcg_gen_addi_tl(cpu_T[0], cpu_T[0], 1);\n        s1->cc_op = CC_OP_INCB + ot;\n    } else {\n        tcg_gen_addi_tl(cpu_T[0], cpu_T[0], -1);\n        s1->cc_op = CC_OP_DECB + ot;\n    }\n    if (d != OR_TMP0)\n        gen_op_mov_reg_T0(ot, d);\n    else\n        gen_op_st_T0_A0(ot + s1->mem_index);\n    gen_compute_eflags_c(cpu_cc_src);\n    tcg_gen_mov_tl(cpu_cc_dst, cpu_T[0]);\n}", "path": "target-i386\\translate.c", "repo_name": "horms/qemu-xen-3.4-testing", "stars": 1, "license": "other", "language": "c", "size": 19844}
{"docstring": "/* NOTE: wrap around in 16 bit not fully handled */\n", "func_signal": "static void gen_pusha(DisasContext *s)", "code": "{\n    int i;\n    gen_op_movl_A0_reg(R_ESP);\n    gen_op_addl_A0_im(-16 <<  s->dflag);\n    if (!s->ss32)\n        gen_op_andl_A0_ffff();\n    tcg_gen_mov_tl(cpu_T[1], cpu_A0);\n    if (s->addseg)\n        gen_op_addl_A0_seg(R_SS);\n    for(i = 0;i < 8; i++) {\n        gen_op_mov_TN_reg(OT_LONG, 0, 7 - i);\n        gen_op_st_T0_A0(OT_WORD + s->dflag + s->mem_index);\n        gen_op_addl_A0_im(2 <<  s->dflag);\n    }\n    gen_op_mov_reg_T1(OT_WORD + s->ss32, R_ESP);\n}", "path": "target-i386\\translate.c", "repo_name": "horms/qemu-xen-3.4-testing", "stars": 1, "license": "other", "language": "c", "size": 19844}
{"docstring": "/* convert one instruction. s->is_jmp is set if the translation must\n   be stopped. Return the next pc value */\n", "func_signal": "static target_ulong disas_insn(DisasContext *s, target_ulong pc_start)", "code": "{\n    int b, prefixes, aflag, dflag;\n    int shift, ot;\n    int modrm, reg, rm, mod, reg_addr, op, opreg, offset_addr, val;\n    target_ulong next_eip, tval;\n    int rex_w, rex_r;\n\n    if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP)))\n        tcg_gen_debug_insn_start(pc_start);\n    s->pc = pc_start;\n    prefixes = 0;\n    aflag = s->code32;\n    dflag = s->code32;\n    s->override = -1;\n    rex_w = -1;\n    rex_r = 0;\n#ifdef TARGET_X86_64\n    s->rex_x = 0;\n    s->rex_b = 0;\n    x86_64_hregs = 0;\n#endif\n    s->rip_offset = 0; /* for relative ip address */\n next_byte:\n    b = ldub_code(s->pc);\n    s->pc++;\n    /* check prefixes */\n#ifdef TARGET_X86_64\n    if (CODE64(s)) {\n        switch (b) {\n        case 0xf3:\n            prefixes |= PREFIX_REPZ;\n            goto next_byte;\n        case 0xf2:\n            prefixes |= PREFIX_REPNZ;\n            goto next_byte;\n        case 0xf0:\n            prefixes |= PREFIX_LOCK;\n            goto next_byte;\n        case 0x2e:\n            s->override = R_CS;\n            goto next_byte;\n        case 0x36:\n            s->override = R_SS;\n            goto next_byte;\n        case 0x3e:\n            s->override = R_DS;\n            goto next_byte;\n        case 0x26:\n            s->override = R_ES;\n            goto next_byte;\n        case 0x64:\n            s->override = R_FS;\n            goto next_byte;\n        case 0x65:\n            s->override = R_GS;\n            goto next_byte;\n        case 0x66:\n            prefixes |= PREFIX_DATA;\n            goto next_byte;\n        case 0x67:\n            prefixes |= PREFIX_ADR;\n            goto next_byte;\n        case 0x40 ... 0x4f:\n            /* REX prefix */\n            rex_w = (b >> 3) & 1;\n            rex_r = (b & 0x4) << 1;\n            s->rex_x = (b & 0x2) << 2;\n            REX_B(s) = (b & 0x1) << 3;\n            x86_64_hregs = 1; /* select uniform byte register addressing */\n            goto next_byte;\n        }\n        if (rex_w == 1) {\n            /* 0x66 is ignored if rex.w is set */\n            dflag = 2;\n        } else {\n            if (prefixes & PREFIX_DATA)\n                dflag ^= 1;\n        }\n        if (!(prefixes & PREFIX_ADR))\n            aflag = 2;\n    } else\n#endif\n    {\n        switch (b) {\n        case 0xf3:\n            prefixes |= PREFIX_REPZ;\n            goto next_byte;\n        case 0xf2:\n            prefixes |= PREFIX_REPNZ;\n            goto next_byte;\n        case 0xf0:\n            prefixes |= PREFIX_LOCK;\n            goto next_byte;\n        case 0x2e:\n            s->override = R_CS;\n            goto next_byte;\n        case 0x36:\n            s->override = R_SS;\n            goto next_byte;\n        case 0x3e:\n            s->override = R_DS;\n            goto next_byte;\n        case 0x26:\n            s->override = R_ES;\n            goto next_byte;\n        case 0x64:\n            s->override = R_FS;\n            goto next_byte;\n        case 0x65:\n            s->override = R_GS;\n            goto next_byte;\n        case 0x66:\n            prefixes |= PREFIX_DATA;\n            goto next_byte;\n        case 0x67:\n            prefixes |= PREFIX_ADR;\n            goto next_byte;\n        }\n        if (prefixes & PREFIX_DATA)\n            dflag ^= 1;\n        if (prefixes & PREFIX_ADR)\n            aflag ^= 1;\n    }\n\n    s->prefix = prefixes;\n    s->aflag = aflag;\n    s->dflag = dflag;\n\n    /* lock generation */\n    if (prefixes & PREFIX_LOCK)\n        gen_helper_lock();\n\n    /* now check op code */\n reswitch:\n    switch(b) {\n    case 0x0f:\n        /**************************/\n        /* extended op code */\n        b = ldub_code(s->pc++) | 0x100;\n        goto reswitch;\n\n        /**************************/\n        /* arith & logic */\n    case 0x00 ... 0x05:\n    case 0x08 ... 0x0d:\n    case 0x10 ... 0x15:\n    case 0x18 ... 0x1d:\n    case 0x20 ... 0x25:\n    case 0x28 ... 0x2d:\n    case 0x30 ... 0x35:\n    case 0x38 ... 0x3d:\n        {\n            int op, f, val;\n            op = (b >> 3) & 7;\n            f = (b >> 1) & 3;\n\n            if ((b & 1) == 0)\n                ot = OT_BYTE;\n            else\n                ot = dflag + OT_WORD;\n\n            switch(f) {\n            case 0: /* OP Ev, Gv */\n                modrm = ldub_code(s->pc++);\n                reg = ((modrm >> 3) & 7) | rex_r;\n                mod = (modrm >> 6) & 3;\n                rm = (modrm & 7) | REX_B(s);\n                if (mod != 3) {\n                    gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n                    opreg = OR_TMP0;\n                } else if (op == OP_XORL && rm == reg) {\n                xor_zero:\n                    /* xor reg, reg optimisation */\n                    gen_op_movl_T0_0();\n                    s->cc_op = CC_OP_LOGICB + ot;\n                    gen_op_mov_reg_T0(ot, reg);\n                    gen_op_update1_cc();\n                    break;\n                } else {\n                    opreg = rm;\n                }\n                gen_op_mov_TN_reg(ot, 1, reg);\n                gen_op(s, op, ot, opreg);\n                break;\n            case 1: /* OP Gv, Ev */\n                modrm = ldub_code(s->pc++);\n                mod = (modrm >> 6) & 3;\n                reg = ((modrm >> 3) & 7) | rex_r;\n                rm = (modrm & 7) | REX_B(s);\n                if (mod != 3) {\n                    gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n                    gen_op_ld_T1_A0(ot + s->mem_index);\n                } else if (op == OP_XORL && rm == reg) {\n                    goto xor_zero;\n                } else {\n                    gen_op_mov_TN_reg(ot, 1, rm);\n                }\n                gen_op(s, op, ot, reg);\n                break;\n            case 2: /* OP A, Iv */\n                val = insn_get(s, ot);\n                gen_op_movl_T1_im(val);\n                gen_op(s, op, ot, OR_EAX);\n                break;\n            }\n        }\n        break;\n\n    case 0x82:\n        if (CODE64(s))\n            goto illegal_op;\n    case 0x80: /* GRP1 */\n    case 0x81:\n    case 0x83:\n        {\n            int val;\n\n            if ((b & 1) == 0)\n                ot = OT_BYTE;\n            else\n                ot = dflag + OT_WORD;\n\n            modrm = ldub_code(s->pc++);\n            mod = (modrm >> 6) & 3;\n            rm = (modrm & 7) | REX_B(s);\n            op = (modrm >> 3) & 7;\n\n            if (mod != 3) {\n                if (b == 0x83)\n                    s->rip_offset = 1;\n                else\n                    s->rip_offset = insn_const_size(ot);\n                gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n                opreg = OR_TMP0;\n            } else {\n                opreg = rm;\n            }\n\n            switch(b) {\n            default:\n            case 0x80:\n            case 0x81:\n            case 0x82:\n                val = insn_get(s, ot);\n                break;\n            case 0x83:\n                val = (int8_t)insn_get(s, OT_BYTE);\n                break;\n            }\n            gen_op_movl_T1_im(val);\n            gen_op(s, op, ot, opreg);\n        }\n        break;\n\n        /**************************/\n        /* inc, dec, and other misc arith */\n    case 0x40 ... 0x47: /* inc Gv */\n        ot = dflag ? OT_LONG : OT_WORD;\n        gen_inc(s, ot, OR_EAX + (b & 7), 1);\n        break;\n    case 0x48 ... 0x4f: /* dec Gv */\n        ot = dflag ? OT_LONG : OT_WORD;\n        gen_inc(s, ot, OR_EAX + (b & 7), -1);\n        break;\n    case 0xf6: /* GRP3 */\n    case 0xf7:\n        if ((b & 1) == 0)\n            ot = OT_BYTE;\n        else\n            ot = dflag + OT_WORD;\n\n        modrm = ldub_code(s->pc++);\n        mod = (modrm >> 6) & 3;\n        rm = (modrm & 7) | REX_B(s);\n        op = (modrm >> 3) & 7;\n        if (mod != 3) {\n            if (op == 0)\n                s->rip_offset = insn_const_size(ot);\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n            gen_op_ld_T0_A0(ot + s->mem_index);\n        } else {\n            gen_op_mov_TN_reg(ot, 0, rm);\n        }\n\n        switch(op) {\n        case 0: /* test */\n            val = insn_get(s, ot);\n            gen_op_movl_T1_im(val);\n            gen_op_testl_T0_T1_cc();\n            s->cc_op = CC_OP_LOGICB + ot;\n            break;\n        case 2: /* not */\n            tcg_gen_not_tl(cpu_T[0], cpu_T[0]);\n            if (mod != 3) {\n                gen_op_st_T0_A0(ot + s->mem_index);\n            } else {\n                gen_op_mov_reg_T0(ot, rm);\n            }\n            break;\n        case 3: /* neg */\n            tcg_gen_neg_tl(cpu_T[0], cpu_T[0]);\n            if (mod != 3) {\n                gen_op_st_T0_A0(ot + s->mem_index);\n            } else {\n                gen_op_mov_reg_T0(ot, rm);\n            }\n            gen_op_update_neg_cc();\n            s->cc_op = CC_OP_SUBB + ot;\n            break;\n        case 4: /* mul */\n            switch(ot) {\n            case OT_BYTE:\n                gen_op_mov_TN_reg(OT_BYTE, 1, R_EAX);\n                tcg_gen_ext8u_tl(cpu_T[0], cpu_T[0]);\n                tcg_gen_ext8u_tl(cpu_T[1], cpu_T[1]);\n                /* XXX: use 32 bit mul which could be faster */\n                tcg_gen_mul_tl(cpu_T[0], cpu_T[0], cpu_T[1]);\n                gen_op_mov_reg_T0(OT_WORD, R_EAX);\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T[0]);\n                tcg_gen_andi_tl(cpu_cc_src, cpu_T[0], 0xff00);\n                s->cc_op = CC_OP_MULB;\n                break;\n            case OT_WORD:\n                gen_op_mov_TN_reg(OT_WORD, 1, R_EAX);\n                tcg_gen_ext16u_tl(cpu_T[0], cpu_T[0]);\n                tcg_gen_ext16u_tl(cpu_T[1], cpu_T[1]);\n                /* XXX: use 32 bit mul which could be faster */\n                tcg_gen_mul_tl(cpu_T[0], cpu_T[0], cpu_T[1]);\n                gen_op_mov_reg_T0(OT_WORD, R_EAX);\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T[0]);\n                tcg_gen_shri_tl(cpu_T[0], cpu_T[0], 16);\n                gen_op_mov_reg_T0(OT_WORD, R_EDX);\n                tcg_gen_mov_tl(cpu_cc_src, cpu_T[0]);\n                s->cc_op = CC_OP_MULW;\n                break;\n            default:\n            case OT_LONG:\n#ifdef TARGET_X86_64\n                gen_op_mov_TN_reg(OT_LONG, 1, R_EAX);\n                tcg_gen_ext32u_tl(cpu_T[0], cpu_T[0]);\n                tcg_gen_ext32u_tl(cpu_T[1], cpu_T[1]);\n                tcg_gen_mul_tl(cpu_T[0], cpu_T[0], cpu_T[1]);\n                gen_op_mov_reg_T0(OT_LONG, R_EAX);\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T[0]);\n                tcg_gen_shri_tl(cpu_T[0], cpu_T[0], 32);\n                gen_op_mov_reg_T0(OT_LONG, R_EDX);\n                tcg_gen_mov_tl(cpu_cc_src, cpu_T[0]);\n#else\n                {\n                    TCGv_i64 t0, t1;\n                    t0 = tcg_temp_new_i64();\n                    t1 = tcg_temp_new_i64();\n                    gen_op_mov_TN_reg(OT_LONG, 1, R_EAX);\n                    tcg_gen_extu_i32_i64(t0, cpu_T[0]);\n                    tcg_gen_extu_i32_i64(t1, cpu_T[1]);\n                    tcg_gen_mul_i64(t0, t0, t1);\n                    tcg_gen_trunc_i64_i32(cpu_T[0], t0);\n                    gen_op_mov_reg_T0(OT_LONG, R_EAX);\n                    tcg_gen_mov_tl(cpu_cc_dst, cpu_T[0]);\n                    tcg_gen_shri_i64(t0, t0, 32);\n                    tcg_gen_trunc_i64_i32(cpu_T[0], t0);\n                    gen_op_mov_reg_T0(OT_LONG, R_EDX);\n                    tcg_gen_mov_tl(cpu_cc_src, cpu_T[0]);\n                }\n#endif\n                s->cc_op = CC_OP_MULL;\n                break;\n#ifdef TARGET_X86_64\n            case OT_QUAD:\n                gen_helper_mulq_EAX_T0(cpu_T[0]);\n                s->cc_op = CC_OP_MULQ;\n                break;\n#endif\n            }\n            break;\n        case 5: /* imul */\n            switch(ot) {\n            case OT_BYTE:\n                gen_op_mov_TN_reg(OT_BYTE, 1, R_EAX);\n                tcg_gen_ext8s_tl(cpu_T[0], cpu_T[0]);\n                tcg_gen_ext8s_tl(cpu_T[1], cpu_T[1]);\n                /* XXX: use 32 bit mul which could be faster */\n                tcg_gen_mul_tl(cpu_T[0], cpu_T[0], cpu_T[1]);\n                gen_op_mov_reg_T0(OT_WORD, R_EAX);\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T[0]);\n                tcg_gen_ext8s_tl(cpu_tmp0, cpu_T[0]);\n                tcg_gen_sub_tl(cpu_cc_src, cpu_T[0], cpu_tmp0);\n                s->cc_op = CC_OP_MULB;\n                break;\n            case OT_WORD:\n                gen_op_mov_TN_reg(OT_WORD, 1, R_EAX);\n                tcg_gen_ext16s_tl(cpu_T[0], cpu_T[0]);\n                tcg_gen_ext16s_tl(cpu_T[1], cpu_T[1]);\n                /* XXX: use 32 bit mul which could be faster */\n                tcg_gen_mul_tl(cpu_T[0], cpu_T[0], cpu_T[1]);\n                gen_op_mov_reg_T0(OT_WORD, R_EAX);\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T[0]);\n                tcg_gen_ext16s_tl(cpu_tmp0, cpu_T[0]);\n                tcg_gen_sub_tl(cpu_cc_src, cpu_T[0], cpu_tmp0);\n                tcg_gen_shri_tl(cpu_T[0], cpu_T[0], 16);\n                gen_op_mov_reg_T0(OT_WORD, R_EDX);\n                s->cc_op = CC_OP_MULW;\n                break;\n            default:\n            case OT_LONG:\n#ifdef TARGET_X86_64\n                gen_op_mov_TN_reg(OT_LONG, 1, R_EAX);\n                tcg_gen_ext32s_tl(cpu_T[0], cpu_T[0]);\n                tcg_gen_ext32s_tl(cpu_T[1], cpu_T[1]);\n                tcg_gen_mul_tl(cpu_T[0], cpu_T[0], cpu_T[1]);\n                gen_op_mov_reg_T0(OT_LONG, R_EAX);\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T[0]);\n                tcg_gen_ext32s_tl(cpu_tmp0, cpu_T[0]);\n                tcg_gen_sub_tl(cpu_cc_src, cpu_T[0], cpu_tmp0);\n                tcg_gen_shri_tl(cpu_T[0], cpu_T[0], 32);\n                gen_op_mov_reg_T0(OT_LONG, R_EDX);\n#else\n                {\n                    TCGv_i64 t0, t1;\n                    t0 = tcg_temp_new_i64();\n                    t1 = tcg_temp_new_i64();\n                    gen_op_mov_TN_reg(OT_LONG, 1, R_EAX);\n                    tcg_gen_ext_i32_i64(t0, cpu_T[0]);\n                    tcg_gen_ext_i32_i64(t1, cpu_T[1]);\n                    tcg_gen_mul_i64(t0, t0, t1);\n                    tcg_gen_trunc_i64_i32(cpu_T[0], t0);\n                    gen_op_mov_reg_T0(OT_LONG, R_EAX);\n                    tcg_gen_mov_tl(cpu_cc_dst, cpu_T[0]);\n                    tcg_gen_sari_tl(cpu_tmp0, cpu_T[0], 31);\n                    tcg_gen_shri_i64(t0, t0, 32);\n                    tcg_gen_trunc_i64_i32(cpu_T[0], t0);\n                    gen_op_mov_reg_T0(OT_LONG, R_EDX);\n                    tcg_gen_sub_tl(cpu_cc_src, cpu_T[0], cpu_tmp0);\n                }\n#endif\n                s->cc_op = CC_OP_MULL;\n                break;\n#ifdef TARGET_X86_64\n            case OT_QUAD:\n                gen_helper_imulq_EAX_T0(cpu_T[0]);\n                s->cc_op = CC_OP_MULQ;\n                break;\n#endif\n            }\n            break;\n        case 6: /* div */\n            switch(ot) {\n            case OT_BYTE:\n                gen_jmp_im(pc_start - s->cs_base);\n                gen_helper_divb_AL(cpu_T[0]);\n                break;\n            case OT_WORD:\n                gen_jmp_im(pc_start - s->cs_base);\n                gen_helper_divw_AX(cpu_T[0]);\n                break;\n            default:\n            case OT_LONG:\n                gen_jmp_im(pc_start - s->cs_base);\n                gen_helper_divl_EAX(cpu_T[0]);\n                break;\n#ifdef TARGET_X86_64\n            case OT_QUAD:\n                gen_jmp_im(pc_start - s->cs_base);\n                gen_helper_divq_EAX(cpu_T[0]);\n                break;\n#endif\n            }\n            break;\n        case 7: /* idiv */\n            switch(ot) {\n            case OT_BYTE:\n                gen_jmp_im(pc_start - s->cs_base);\n                gen_helper_idivb_AL(cpu_T[0]);\n                break;\n            case OT_WORD:\n                gen_jmp_im(pc_start - s->cs_base);\n                gen_helper_idivw_AX(cpu_T[0]);\n                break;\n            default:\n            case OT_LONG:\n                gen_jmp_im(pc_start - s->cs_base);\n                gen_helper_idivl_EAX(cpu_T[0]);\n                break;\n#ifdef TARGET_X86_64\n            case OT_QUAD:\n                gen_jmp_im(pc_start - s->cs_base);\n                gen_helper_idivq_EAX(cpu_T[0]);\n                break;\n#endif\n            }\n            break;\n        default:\n            goto illegal_op;\n        }\n        break;\n\n    case 0xfe: /* GRP4 */\n    case 0xff: /* GRP5 */\n        if ((b & 1) == 0)\n            ot = OT_BYTE;\n        else\n            ot = dflag + OT_WORD;\n\n        modrm = ldub_code(s->pc++);\n        mod = (modrm >> 6) & 3;\n        rm = (modrm & 7) | REX_B(s);\n        op = (modrm >> 3) & 7;\n        if (op >= 2 && b == 0xfe) {\n            goto illegal_op;\n        }\n        if (CODE64(s)) {\n            if (op == 2 || op == 4) {\n                /* operand size for jumps is 64 bit */\n                ot = OT_QUAD;\n            } else if (op == 3 || op == 5) {\n                /* for call calls, the operand is 16 or 32 bit, even\n                   in long mode */\n                ot = dflag ? OT_LONG : OT_WORD;\n            } else if (op == 6) {\n                /* default push size is 64 bit */\n                ot = dflag ? OT_QUAD : OT_WORD;\n            }\n        }\n        if (mod != 3) {\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n            if (op >= 2 && op != 3 && op != 5)\n                gen_op_ld_T0_A0(ot + s->mem_index);\n        } else {\n            gen_op_mov_TN_reg(ot, 0, rm);\n        }\n\n        switch(op) {\n        case 0: /* inc Ev */\n            if (mod != 3)\n                opreg = OR_TMP0;\n            else\n                opreg = rm;\n            gen_inc(s, ot, opreg, 1);\n            break;\n        case 1: /* dec Ev */\n            if (mod != 3)\n                opreg = OR_TMP0;\n            else\n                opreg = rm;\n            gen_inc(s, ot, opreg, -1);\n            break;\n        case 2: /* call Ev */\n            /* XXX: optimize if memory (no 'and' is necessary) */\n            if (s->dflag == 0)\n                gen_op_andl_T0_ffff();\n            next_eip = s->pc - s->cs_base;\n            gen_movtl_T1_im(next_eip);\n            gen_push_T1(s);\n            gen_op_jmp_T0();\n            gen_eob(s);\n            break;\n        case 3: /* lcall Ev */\n            gen_op_ld_T1_A0(ot + s->mem_index);\n            gen_add_A0_im(s, 1 << (ot - OT_WORD + 1));\n            gen_op_ldu_T0_A0(OT_WORD + s->mem_index);\n        do_lcall:\n            if (s->pe && !s->vm86) {\n                if (s->cc_op != CC_OP_DYNAMIC)\n                    gen_op_set_cc_op(s->cc_op);\n                gen_jmp_im(pc_start - s->cs_base);\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n                gen_helper_lcall_protected(cpu_tmp2_i32, cpu_T[1],\n                                           tcg_const_i32(dflag), \n                                           tcg_const_i32(s->pc - pc_start));\n            } else {\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n                gen_helper_lcall_real(cpu_tmp2_i32, cpu_T[1],\n                                      tcg_const_i32(dflag), \n                                      tcg_const_i32(s->pc - s->cs_base));\n            }\n            gen_eob(s);\n            break;\n        case 4: /* jmp Ev */\n            if (s->dflag == 0)\n                gen_op_andl_T0_ffff();\n            gen_op_jmp_T0();\n            gen_eob(s);\n            break;\n        case 5: /* ljmp Ev */\n            gen_op_ld_T1_A0(ot + s->mem_index);\n            gen_add_A0_im(s, 1 << (ot - OT_WORD + 1));\n            gen_op_ldu_T0_A0(OT_WORD + s->mem_index);\n        do_ljmp:\n            if (s->pe && !s->vm86) {\n                if (s->cc_op != CC_OP_DYNAMIC)\n                    gen_op_set_cc_op(s->cc_op);\n                gen_jmp_im(pc_start - s->cs_base);\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n                gen_helper_ljmp_protected(cpu_tmp2_i32, cpu_T[1],\n                                          tcg_const_i32(s->pc - pc_start));\n            } else {\n                gen_op_movl_seg_T0_vm(R_CS);\n                gen_op_movl_T0_T1();\n                gen_op_jmp_T0();\n            }\n            gen_eob(s);\n            break;\n        case 6: /* push Ev */\n            gen_push_T0(s);\n            break;\n        default:\n            goto illegal_op;\n        }\n        break;\n\n    case 0x84: /* test Ev, Gv */\n    case 0x85:\n        if ((b & 1) == 0)\n            ot = OT_BYTE;\n        else\n            ot = dflag + OT_WORD;\n\n        modrm = ldub_code(s->pc++);\n        mod = (modrm >> 6) & 3;\n        rm = (modrm & 7) | REX_B(s);\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        gen_ldst_modrm(s, modrm, ot, OR_TMP0, 0);\n        gen_op_mov_TN_reg(ot, 1, reg);\n        gen_op_testl_T0_T1_cc();\n        s->cc_op = CC_OP_LOGICB + ot;\n        break;\n\n    case 0xa8: /* test eAX, Iv */\n    case 0xa9:\n        if ((b & 1) == 0)\n            ot = OT_BYTE;\n        else\n            ot = dflag + OT_WORD;\n        val = insn_get(s, ot);\n\n        gen_op_mov_TN_reg(ot, 0, OR_EAX);\n        gen_op_movl_T1_im(val);\n        gen_op_testl_T0_T1_cc();\n        s->cc_op = CC_OP_LOGICB + ot;\n        break;\n\n    case 0x98: /* CWDE/CBW */\n#ifdef TARGET_X86_64\n        if (dflag == 2) {\n            gen_op_mov_TN_reg(OT_LONG, 0, R_EAX);\n            tcg_gen_ext32s_tl(cpu_T[0], cpu_T[0]);\n            gen_op_mov_reg_T0(OT_QUAD, R_EAX);\n        } else\n#endif\n        if (dflag == 1) {\n            gen_op_mov_TN_reg(OT_WORD, 0, R_EAX);\n            tcg_gen_ext16s_tl(cpu_T[0], cpu_T[0]);\n            gen_op_mov_reg_T0(OT_LONG, R_EAX);\n        } else {\n            gen_op_mov_TN_reg(OT_BYTE, 0, R_EAX);\n            tcg_gen_ext8s_tl(cpu_T[0], cpu_T[0]);\n            gen_op_mov_reg_T0(OT_WORD, R_EAX);\n        }\n        break;\n    case 0x99: /* CDQ/CWD */\n#ifdef TARGET_X86_64\n        if (dflag == 2) {\n            gen_op_mov_TN_reg(OT_QUAD, 0, R_EAX);\n            tcg_gen_sari_tl(cpu_T[0], cpu_T[0], 63);\n            gen_op_mov_reg_T0(OT_QUAD, R_EDX);\n        } else\n#endif\n        if (dflag == 1) {\n            gen_op_mov_TN_reg(OT_LONG, 0, R_EAX);\n            tcg_gen_ext32s_tl(cpu_T[0], cpu_T[0]);\n            tcg_gen_sari_tl(cpu_T[0], cpu_T[0], 31);\n            gen_op_mov_reg_T0(OT_LONG, R_EDX);\n        } else {\n            gen_op_mov_TN_reg(OT_WORD, 0, R_EAX);\n            tcg_gen_ext16s_tl(cpu_T[0], cpu_T[0]);\n            tcg_gen_sari_tl(cpu_T[0], cpu_T[0], 15);\n            gen_op_mov_reg_T0(OT_WORD, R_EDX);\n        }\n        break;\n    case 0x1af: /* imul Gv, Ev */\n    case 0x69: /* imul Gv, Ev, I */\n    case 0x6b:\n        ot = dflag + OT_WORD;\n        modrm = ldub_code(s->pc++);\n        reg = ((modrm >> 3) & 7) | rex_r;\n        if (b == 0x69)\n            s->rip_offset = insn_const_size(ot);\n        else if (b == 0x6b)\n            s->rip_offset = 1;\n        gen_ldst_modrm(s, modrm, ot, OR_TMP0, 0);\n        if (b == 0x69) {\n            val = insn_get(s, ot);\n            gen_op_movl_T1_im(val);\n        } else if (b == 0x6b) {\n            val = (int8_t)insn_get(s, OT_BYTE);\n            gen_op_movl_T1_im(val);\n        } else {\n            gen_op_mov_TN_reg(ot, 1, reg);\n        }\n\n#ifdef TARGET_X86_64\n        if (ot == OT_QUAD) {\n            gen_helper_imulq_T0_T1(cpu_T[0], cpu_T[0], cpu_T[1]);\n        } else\n#endif\n        if (ot == OT_LONG) {\n#ifdef TARGET_X86_64\n                tcg_gen_ext32s_tl(cpu_T[0], cpu_T[0]);\n                tcg_gen_ext32s_tl(cpu_T[1], cpu_T[1]);\n                tcg_gen_mul_tl(cpu_T[0], cpu_T[0], cpu_T[1]);\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T[0]);\n                tcg_gen_ext32s_tl(cpu_tmp0, cpu_T[0]);\n                tcg_gen_sub_tl(cpu_cc_src, cpu_T[0], cpu_tmp0);\n#else\n                {\n                    TCGv_i64 t0, t1;\n                    t0 = tcg_temp_new_i64();\n                    t1 = tcg_temp_new_i64();\n                    tcg_gen_ext_i32_i64(t0, cpu_T[0]);\n                    tcg_gen_ext_i32_i64(t1, cpu_T[1]);\n                    tcg_gen_mul_i64(t0, t0, t1);\n                    tcg_gen_trunc_i64_i32(cpu_T[0], t0);\n                    tcg_gen_mov_tl(cpu_cc_dst, cpu_T[0]);\n                    tcg_gen_sari_tl(cpu_tmp0, cpu_T[0], 31);\n                    tcg_gen_shri_i64(t0, t0, 32);\n                    tcg_gen_trunc_i64_i32(cpu_T[1], t0);\n                    tcg_gen_sub_tl(cpu_cc_src, cpu_T[1], cpu_tmp0);\n                }\n#endif\n        } else {\n            tcg_gen_ext16s_tl(cpu_T[0], cpu_T[0]);\n            tcg_gen_ext16s_tl(cpu_T[1], cpu_T[1]);\n            /* XXX: use 32 bit mul which could be faster */\n            tcg_gen_mul_tl(cpu_T[0], cpu_T[0], cpu_T[1]);\n            tcg_gen_mov_tl(cpu_cc_dst, cpu_T[0]);\n            tcg_gen_ext16s_tl(cpu_tmp0, cpu_T[0]);\n            tcg_gen_sub_tl(cpu_cc_src, cpu_T[0], cpu_tmp0);\n        }\n        gen_op_mov_reg_T0(ot, reg);\n        s->cc_op = CC_OP_MULB + ot;\n        break;\n    case 0x1c0:\n    case 0x1c1: /* xadd Ev, Gv */\n        if ((b & 1) == 0)\n            ot = OT_BYTE;\n        else\n            ot = dflag + OT_WORD;\n        modrm = ldub_code(s->pc++);\n        reg = ((modrm >> 3) & 7) | rex_r;\n        mod = (modrm >> 6) & 3;\n        if (mod == 3) {\n            rm = (modrm & 7) | REX_B(s);\n            gen_op_mov_TN_reg(ot, 0, reg);\n            gen_op_mov_TN_reg(ot, 1, rm);\n            gen_op_addl_T0_T1();\n            gen_op_mov_reg_T1(ot, reg);\n            gen_op_mov_reg_T0(ot, rm);\n        } else {\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n            gen_op_mov_TN_reg(ot, 0, reg);\n            gen_op_ld_T1_A0(ot + s->mem_index);\n            gen_op_addl_T0_T1();\n            gen_op_st_T0_A0(ot + s->mem_index);\n            gen_op_mov_reg_T1(ot, reg);\n        }\n        gen_op_update2_cc();\n        s->cc_op = CC_OP_ADDB + ot;\n        break;\n    case 0x1b0:\n    case 0x1b1: /* cmpxchg Ev, Gv */\n        {\n            int label1, label2;\n            TCGv t0, t1, t2, a0;\n\n            if ((b & 1) == 0)\n                ot = OT_BYTE;\n            else\n                ot = dflag + OT_WORD;\n            modrm = ldub_code(s->pc++);\n            reg = ((modrm >> 3) & 7) | rex_r;\n            mod = (modrm >> 6) & 3;\n            t0 = tcg_temp_local_new();\n            t1 = tcg_temp_local_new();\n            t2 = tcg_temp_local_new();\n            a0 = tcg_temp_local_new();\n            gen_op_mov_v_reg(ot, t1, reg);\n            if (mod == 3) {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_mov_v_reg(ot, t0, rm);\n            } else {\n                gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n                tcg_gen_mov_tl(a0, cpu_A0);\n                gen_op_ld_v(ot + s->mem_index, t0, a0);\n                rm = 0; /* avoid warning */\n            }\n            label1 = gen_new_label();\n            tcg_gen_ld_tl(t2, cpu_env, offsetof(CPUState, regs[R_EAX]));\n            tcg_gen_sub_tl(t2, t2, t0);\n            gen_extu(ot, t2);\n            tcg_gen_brcondi_tl(TCG_COND_EQ, t2, 0, label1);\n            if (mod == 3) {\n                label2 = gen_new_label();\n                gen_op_mov_reg_v(ot, R_EAX, t0);\n                tcg_gen_br(label2);\n                gen_set_label(label1);\n                gen_op_mov_reg_v(ot, rm, t1);\n                gen_set_label(label2);\n            } else {\n                tcg_gen_mov_tl(t1, t0);\n                gen_op_mov_reg_v(ot, R_EAX, t0);\n                gen_set_label(label1);\n                /* always store */\n                gen_op_st_v(ot + s->mem_index, t1, a0);\n            }\n            tcg_gen_mov_tl(cpu_cc_src, t0);\n            tcg_gen_mov_tl(cpu_cc_dst, t2);\n            s->cc_op = CC_OP_SUBB + ot;\n            tcg_temp_free(t0);\n            tcg_temp_free(t1);\n            tcg_temp_free(t2);\n            tcg_temp_free(a0);\n        }\n        break;\n    case 0x1c7: /* cmpxchg8b */\n        modrm = ldub_code(s->pc++);\n        mod = (modrm >> 6) & 3;\n        if ((mod == 3) || ((modrm & 0x38) != 0x8))\n            goto illegal_op;\n#ifdef TARGET_X86_64\n        if (dflag == 2) {\n            if (!(s->cpuid_ext_features & CPUID_EXT_CX16))\n                goto illegal_op;\n            gen_jmp_im(pc_start - s->cs_base);\n            if (s->cc_op != CC_OP_DYNAMIC)\n                gen_op_set_cc_op(s->cc_op);\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n            gen_helper_cmpxchg16b(cpu_A0);\n        } else\n#endif        \n        {\n            if (!(s->cpuid_features & CPUID_CX8))\n                goto illegal_op;\n            gen_jmp_im(pc_start - s->cs_base);\n            if (s->cc_op != CC_OP_DYNAMIC)\n                gen_op_set_cc_op(s->cc_op);\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n            gen_helper_cmpxchg8b(cpu_A0);\n        }\n        s->cc_op = CC_OP_EFLAGS;\n        break;\n\n        /**************************/\n        /* push/pop */\n    case 0x50 ... 0x57: /* push */\n        gen_op_mov_TN_reg(OT_LONG, 0, (b & 7) | REX_B(s));\n        gen_push_T0(s);\n        break;\n    case 0x58 ... 0x5f: /* pop */\n        if (CODE64(s)) {\n            ot = dflag ? OT_QUAD : OT_WORD;\n        } else {\n            ot = dflag + OT_WORD;\n        }\n        gen_pop_T0(s);\n        /* NOTE: order is important for pop %sp */\n        gen_pop_update(s);\n        gen_op_mov_reg_T0(ot, (b & 7) | REX_B(s));\n        break;\n    case 0x60: /* pusha */\n        if (CODE64(s))\n            goto illegal_op;\n        gen_pusha(s);\n        break;\n    case 0x61: /* popa */\n        if (CODE64(s))\n            goto illegal_op;\n        gen_popa(s);\n        break;\n    case 0x68: /* push Iv */\n    case 0x6a:\n        if (CODE64(s)) {\n            ot = dflag ? OT_QUAD : OT_WORD;\n        } else {\n            ot = dflag + OT_WORD;\n        }\n        if (b == 0x68)\n            val = insn_get(s, ot);\n        else\n            val = (int8_t)insn_get(s, OT_BYTE);\n        gen_op_movl_T0_im(val);\n        gen_push_T0(s);\n        break;\n    case 0x8f: /* pop Ev */\n        if (CODE64(s)) {\n            ot = dflag ? OT_QUAD : OT_WORD;\n        } else {\n            ot = dflag + OT_WORD;\n        }\n        modrm = ldub_code(s->pc++);\n        mod = (modrm >> 6) & 3;\n        gen_pop_T0(s);\n        if (mod == 3) {\n            /* NOTE: order is important for pop %sp */\n            gen_pop_update(s);\n            rm = (modrm & 7) | REX_B(s);\n            gen_op_mov_reg_T0(ot, rm);\n        } else {\n            /* NOTE: order is important too for MMU exceptions */\n            s->popl_esp_hack = 1 << ot;\n            gen_ldst_modrm(s, modrm, ot, OR_TMP0, 1);\n            s->popl_esp_hack = 0;\n            gen_pop_update(s);\n        }\n        break;\n    case 0xc8: /* enter */\n        {\n            int level;\n            val = lduw_code(s->pc);\n            s->pc += 2;\n            level = ldub_code(s->pc++);\n            gen_enter(s, val, level);\n        }\n        break;\n    case 0xc9: /* leave */\n        /* XXX: exception not precise (ESP is updated before potential exception) */\n        if (CODE64(s)) {\n            gen_op_mov_TN_reg(OT_QUAD, 0, R_EBP);\n            gen_op_mov_reg_T0(OT_QUAD, R_ESP);\n        } else if (s->ss32) {\n            gen_op_mov_TN_reg(OT_LONG, 0, R_EBP);\n            gen_op_mov_reg_T0(OT_LONG, R_ESP);\n        } else {\n            gen_op_mov_TN_reg(OT_WORD, 0, R_EBP);\n            gen_op_mov_reg_T0(OT_WORD, R_ESP);\n        }\n        gen_pop_T0(s);\n        if (CODE64(s)) {\n            ot = dflag ? OT_QUAD : OT_WORD;\n        } else {\n            ot = dflag + OT_WORD;\n        }\n        gen_op_mov_reg_T0(ot, R_EBP);\n        gen_pop_update(s);\n        break;\n    case 0x06: /* push es */\n    case 0x0e: /* push cs */\n    case 0x16: /* push ss */\n    case 0x1e: /* push ds */\n        if (CODE64(s))\n            goto illegal_op;\n        gen_op_movl_T0_seg(b >> 3);\n        gen_push_T0(s);\n        break;\n    case 0x1a0: /* push fs */\n    case 0x1a8: /* push gs */\n        gen_op_movl_T0_seg((b >> 3) & 7);\n        gen_push_T0(s);\n        break;\n    case 0x07: /* pop es */\n    case 0x17: /* pop ss */\n    case 0x1f: /* pop ds */\n        if (CODE64(s))\n            goto illegal_op;\n        reg = b >> 3;\n        gen_pop_T0(s);\n        gen_movl_seg_T0(s, reg, pc_start - s->cs_base);\n        gen_pop_update(s);\n        if (reg == R_SS) {\n            /* if reg == SS, inhibit interrupts/trace. */\n            /* If several instructions disable interrupts, only the\n               _first_ does it */\n            if (!(s->tb->flags & HF_INHIBIT_IRQ_MASK))\n                gen_helper_set_inhibit_irq();\n            s->tf = 0;\n        }\n        if (s->is_jmp) {\n            gen_jmp_im(s->pc - s->cs_base);\n            gen_eob(s);\n        }\n        break;\n    case 0x1a1: /* pop fs */\n    case 0x1a9: /* pop gs */\n        gen_pop_T0(s);\n        gen_movl_seg_T0(s, (b >> 3) & 7, pc_start - s->cs_base);\n        gen_pop_update(s);\n        if (s->is_jmp) {\n            gen_jmp_im(s->pc - s->cs_base);\n            gen_eob(s);\n        }\n        break;\n\n        /**************************/\n        /* mov */\n    case 0x88:\n    case 0x89: /* mov Gv, Ev */\n        if ((b & 1) == 0)\n            ot = OT_BYTE;\n        else\n            ot = dflag + OT_WORD;\n        modrm = ldub_code(s->pc++);\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        /* generate a generic store */\n        gen_ldst_modrm(s, modrm, ot, reg, 1);\n        break;\n    case 0xc6:\n    case 0xc7: /* mov Ev, Iv */\n        if ((b & 1) == 0)\n            ot = OT_BYTE;\n        else\n            ot = dflag + OT_WORD;\n        modrm = ldub_code(s->pc++);\n        mod = (modrm >> 6) & 3;\n        if (mod != 3) {\n            s->rip_offset = insn_const_size(ot);\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n        }\n        val = insn_get(s, ot);\n        gen_op_movl_T0_im(val);\n        if (mod != 3)\n            gen_op_st_T0_A0(ot + s->mem_index);\n        else\n            gen_op_mov_reg_T0(ot, (modrm & 7) | REX_B(s));\n        break;\n    case 0x8a:\n    case 0x8b: /* mov Ev, Gv */\n        if ((b & 1) == 0)\n            ot = OT_BYTE;\n        else\n            ot = OT_WORD + dflag;\n        modrm = ldub_code(s->pc++);\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        gen_ldst_modrm(s, modrm, ot, OR_TMP0, 0);\n        gen_op_mov_reg_T0(ot, reg);\n        break;\n    case 0x8e: /* mov seg, Gv */\n        modrm = ldub_code(s->pc++);\n        reg = (modrm >> 3) & 7;\n        if (reg >= 6 || reg == R_CS)\n            goto illegal_op;\n        gen_ldst_modrm(s, modrm, OT_WORD, OR_TMP0, 0);\n        gen_movl_seg_T0(s, reg, pc_start - s->cs_base);\n        if (reg == R_SS) {\n            /* if reg == SS, inhibit interrupts/trace */\n            /* If several instructions disable interrupts, only the\n               _first_ does it */\n            if (!(s->tb->flags & HF_INHIBIT_IRQ_MASK))\n                gen_helper_set_inhibit_irq();\n            s->tf = 0;\n        }\n        if (s->is_jmp) {\n            gen_jmp_im(s->pc - s->cs_base);\n            gen_eob(s);\n        }\n        break;\n    case 0x8c: /* mov Gv, seg */\n        modrm = ldub_code(s->pc++);\n        reg = (modrm >> 3) & 7;\n        mod = (modrm >> 6) & 3;\n        if (reg >= 6)\n            goto illegal_op;\n        gen_op_movl_T0_seg(reg);\n        if (mod == 3)\n            ot = OT_WORD + dflag;\n        else\n            ot = OT_WORD;\n        gen_ldst_modrm(s, modrm, ot, OR_TMP0, 1);\n        break;\n\n    case 0x1b6: /* movzbS Gv, Eb */\n    case 0x1b7: /* movzwS Gv, Eb */\n    case 0x1be: /* movsbS Gv, Eb */\n    case 0x1bf: /* movswS Gv, Eb */\n        {\n            int d_ot;\n            /* d_ot is the size of destination */\n            d_ot = dflag + OT_WORD;\n            /* ot is the size of source */\n            ot = (b & 1) + OT_BYTE;\n            modrm = ldub_code(s->pc++);\n            reg = ((modrm >> 3) & 7) | rex_r;\n            mod = (modrm >> 6) & 3;\n            rm = (modrm & 7) | REX_B(s);\n\n            if (mod == 3) {\n                gen_op_mov_TN_reg(ot, 0, rm);\n                switch(ot | (b & 8)) {\n                case OT_BYTE:\n                    tcg_gen_ext8u_tl(cpu_T[0], cpu_T[0]);\n                    break;\n                case OT_BYTE | 8:\n                    tcg_gen_ext8s_tl(cpu_T[0], cpu_T[0]);\n                    break;\n                case OT_WORD:\n                    tcg_gen_ext16u_tl(cpu_T[0], cpu_T[0]);\n                    break;\n                default:\n                case OT_WORD | 8:\n                    tcg_gen_ext16s_tl(cpu_T[0], cpu_T[0]);\n                    break;\n                }\n                gen_op_mov_reg_T0(d_ot, reg);\n            } else {\n                gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n                if (b & 8) {\n                    gen_op_lds_T0_A0(ot + s->mem_index);\n                } else {\n                    gen_op_ldu_T0_A0(ot + s->mem_index);\n                }\n                gen_op_mov_reg_T0(d_ot, reg);\n            }\n        }\n        break;\n\n    case 0x8d: /* lea */\n        ot = dflag + OT_WORD;\n        modrm = ldub_code(s->pc++);\n        mod = (modrm >> 6) & 3;\n        if (mod == 3)\n            goto illegal_op;\n        reg = ((modrm >> 3) & 7) | rex_r;\n        /* we must ensure that no segment is added */\n        s->override = -1;\n        val = s->addseg;\n        s->addseg = 0;\n        gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n        s->addseg = val;\n        gen_op_mov_reg_A0(ot - OT_WORD, reg);\n        break;\n\n    case 0xa0: /* mov EAX, Ov */\n    case 0xa1:\n    case 0xa2: /* mov Ov, EAX */\n    case 0xa3:\n        {\n            target_ulong offset_addr;\n\n            if ((b & 1) == 0)\n                ot = OT_BYTE;\n            else\n                ot = dflag + OT_WORD;\n#ifdef TARGET_X86_64\n            if (s->aflag == 2) {\n                offset_addr = ldq_code(s->pc);\n                s->pc += 8;\n                gen_op_movq_A0_im(offset_addr);\n            } else\n#endif\n            {\n                if (s->aflag) {\n                    offset_addr = insn_get(s, OT_LONG);\n                } else {\n                    offset_addr = insn_get(s, OT_WORD);\n                }\n                gen_op_movl_A0_im(offset_addr);\n            }\n            gen_add_A0_ds_seg(s);\n            if ((b & 2) == 0) {\n                gen_op_ld_T0_A0(ot + s->mem_index);\n                gen_op_mov_reg_T0(ot, R_EAX);\n            } else {\n                gen_op_mov_TN_reg(ot, 0, R_EAX);\n                gen_op_st_T0_A0(ot + s->mem_index);\n            }\n        }\n        break;\n    case 0xd7: /* xlat */\n#ifdef TARGET_X86_64\n        if (s->aflag == 2) {\n            gen_op_movq_A0_reg(R_EBX);\n            gen_op_mov_TN_reg(OT_QUAD, 0, R_EAX);\n            tcg_gen_andi_tl(cpu_T[0], cpu_T[0], 0xff);\n            tcg_gen_add_tl(cpu_A0, cpu_A0, cpu_T[0]);\n        } else\n#endif\n        {\n            gen_op_movl_A0_reg(R_EBX);\n            gen_op_mov_TN_reg(OT_LONG, 0, R_EAX);\n            tcg_gen_andi_tl(cpu_T[0], cpu_T[0], 0xff);\n            tcg_gen_add_tl(cpu_A0, cpu_A0, cpu_T[0]);\n            if (s->aflag == 0)\n                gen_op_andl_A0_ffff();\n            else\n                tcg_gen_andi_tl(cpu_A0, cpu_A0, 0xffffffff);\n        }\n        gen_add_A0_ds_seg(s);\n        gen_op_ldu_T0_A0(OT_BYTE + s->mem_index);\n        gen_op_mov_reg_T0(OT_BYTE, R_EAX);\n        break;\n    case 0xb0 ... 0xb7: /* mov R, Ib */\n        val = insn_get(s, OT_BYTE);\n        gen_op_movl_T0_im(val);\n        gen_op_mov_reg_T0(OT_BYTE, (b & 7) | REX_B(s));\n        break;\n    case 0xb8 ... 0xbf: /* mov R, Iv */\n#ifdef TARGET_X86_64\n        if (dflag == 2) {\n            uint64_t tmp;\n            /* 64 bit case */\n            tmp = ldq_code(s->pc);\n            s->pc += 8;\n            reg = (b & 7) | REX_B(s);\n            gen_movtl_T0_im(tmp);\n            gen_op_mov_reg_T0(OT_QUAD, reg);\n        } else\n#endif\n        {\n            ot = dflag ? OT_LONG : OT_WORD;\n            val = insn_get(s, ot);\n            reg = (b & 7) | REX_B(s);\n            gen_op_movl_T0_im(val);\n            gen_op_mov_reg_T0(ot, reg);\n        }\n        break;\n\n    case 0x91 ... 0x97: /* xchg R, EAX */\n        ot = dflag + OT_WORD;\n        reg = (b & 7) | REX_B(s);\n        rm = R_EAX;\n        goto do_xchg_reg;\n    case 0x86:\n    case 0x87: /* xchg Ev, Gv */\n        if ((b & 1) == 0)\n            ot = OT_BYTE;\n        else\n            ot = dflag + OT_WORD;\n        modrm = ldub_code(s->pc++);\n        reg = ((modrm >> 3) & 7) | rex_r;\n        mod = (modrm >> 6) & 3;\n        if (mod == 3) {\n            rm = (modrm & 7) | REX_B(s);\n        do_xchg_reg:\n            gen_op_mov_TN_reg(ot, 0, reg);\n            gen_op_mov_TN_reg(ot, 1, rm);\n            gen_op_mov_reg_T0(ot, rm);\n            gen_op_mov_reg_T1(ot, reg);\n        } else {\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n            gen_op_mov_TN_reg(ot, 0, reg);\n            /* for xchg, lock is implicit */\n            if (!(prefixes & PREFIX_LOCK))\n                gen_helper_lock();\n            gen_op_ld_T1_A0(ot + s->mem_index);\n            gen_op_st_T0_A0(ot + s->mem_index);\n            if (!(prefixes & PREFIX_LOCK))\n                gen_helper_unlock();\n            gen_op_mov_reg_T1(ot, reg);\n        }\n        break;\n    case 0xc4: /* les Gv */\n        if (CODE64(s))\n            goto illegal_op;\n        op = R_ES;\n        goto do_lxx;\n    case 0xc5: /* lds Gv */\n        if (CODE64(s))\n            goto illegal_op;\n        op = R_DS;\n        goto do_lxx;\n    case 0x1b2: /* lss Gv */\n        op = R_SS;\n        goto do_lxx;\n    case 0x1b4: /* lfs Gv */\n        op = R_FS;\n        goto do_lxx;\n    case 0x1b5: /* lgs Gv */\n        op = R_GS;\n    do_lxx:\n        ot = dflag ? OT_LONG : OT_WORD;\n        modrm = ldub_code(s->pc++);\n        reg = ((modrm >> 3) & 7) | rex_r;\n        mod = (modrm >> 6) & 3;\n        if (mod == 3)\n            goto illegal_op;\n        gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n        gen_op_ld_T1_A0(ot + s->mem_index);\n        gen_add_A0_im(s, 1 << (ot - OT_WORD + 1));\n        /* load the segment first to handle exceptions properly */\n        gen_op_ldu_T0_A0(OT_WORD + s->mem_index);\n        gen_movl_seg_T0(s, op, pc_start - s->cs_base);\n        /* then put the data */\n        gen_op_mov_reg_T1(ot, reg);\n        if (s->is_jmp) {\n            gen_jmp_im(s->pc - s->cs_base);\n            gen_eob(s);\n        }\n        break;\n\n        /************************/\n        /* shifts */\n    case 0xc0:\n    case 0xc1:\n        /* shift Ev,Ib */\n        shift = 2;\n    grp2:\n        {\n            if ((b & 1) == 0)\n                ot = OT_BYTE;\n            else\n                ot = dflag + OT_WORD;\n\n            modrm = ldub_code(s->pc++);\n            mod = (modrm >> 6) & 3;\n            op = (modrm >> 3) & 7;\n\n            if (mod != 3) {\n                if (shift == 2) {\n                    s->rip_offset = 1;\n                }\n                gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n                opreg = OR_TMP0;\n            } else {\n                opreg = (modrm & 7) | REX_B(s);\n            }\n\n            /* simpler op */\n            if (shift == 0) {\n                gen_shift(s, op, ot, opreg, OR_ECX);\n            } else {\n                if (shift == 2) {\n                    shift = ldub_code(s->pc++);\n                }\n                gen_shifti(s, op, ot, opreg, shift);\n            }\n        }\n        break;\n    case 0xd0:\n    case 0xd1:\n        /* shift Ev,1 */\n        shift = 1;\n        goto grp2;\n    case 0xd2:\n    case 0xd3:\n        /* shift Ev,cl */\n        shift = 0;\n        goto grp2;\n\n    case 0x1a4: /* shld imm */\n        op = 0;\n        shift = 1;\n        goto do_shiftd;\n    case 0x1a5: /* shld cl */\n        op = 0;\n        shift = 0;\n        goto do_shiftd;\n    case 0x1ac: /* shrd imm */\n        op = 1;\n        shift = 1;\n        goto do_shiftd;\n    case 0x1ad: /* shrd cl */\n        op = 1;\n        shift = 0;\n    do_shiftd:\n        ot = dflag + OT_WORD;\n        modrm = ldub_code(s->pc++);\n        mod = (modrm >> 6) & 3;\n        rm = (modrm & 7) | REX_B(s);\n        reg = ((modrm >> 3) & 7) | rex_r;\n        if (mod != 3) {\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n            opreg = OR_TMP0;\n        } else {\n            opreg = rm;\n        }\n        gen_op_mov_TN_reg(ot, 1, reg);\n\n        if (shift) {\n            val = ldub_code(s->pc++);\n            tcg_gen_movi_tl(cpu_T3, val);\n        } else {\n            tcg_gen_ld_tl(cpu_T3, cpu_env, offsetof(CPUState, regs[R_ECX]));\n        }\n        gen_shiftd_rm_T1_T3(s, ot, opreg, op);\n        break;\n\n        /************************/\n        /* floats */\n    case 0xd8 ... 0xdf:\n        if (s->flags & (HF_EM_MASK | HF_TS_MASK)) {\n            /* if CR0.EM or CR0.TS are set, generate an FPU exception */\n            /* XXX: what to do if illegal op ? */\n            gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n            break;\n        }\n        modrm = ldub_code(s->pc++);\n        mod = (modrm >> 6) & 3;\n        rm = modrm & 7;\n        op = ((b & 7) << 3) | ((modrm >> 3) & 7);\n        if (mod != 3) {\n            /* memory op */\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n            switch(op) {\n            case 0x00 ... 0x07: /* fxxxs */\n            case 0x10 ... 0x17: /* fixxxl */\n            case 0x20 ... 0x27: /* fxxxl */\n            case 0x30 ... 0x37: /* fixxx */\n                {\n                    int op1;\n                    op1 = op & 7;\n\n                    switch(op >> 4) {\n                    case 0:\n                        gen_op_ld_T0_A0(OT_LONG + s->mem_index);\n                        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n                        gen_helper_flds_FT0(cpu_tmp2_i32);\n                        break;\n                    case 1:\n                        gen_op_ld_T0_A0(OT_LONG + s->mem_index);\n                        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n                        gen_helper_fildl_FT0(cpu_tmp2_i32);\n                        break;\n                    case 2:\n                        tcg_gen_qemu_ld64(cpu_tmp1_i64, cpu_A0, \n                                          (s->mem_index >> 2) - 1);\n                        gen_helper_fldl_FT0(cpu_tmp1_i64);\n                        break;\n                    case 3:\n                    default:\n                        gen_op_lds_T0_A0(OT_WORD + s->mem_index);\n                        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n                        gen_helper_fildl_FT0(cpu_tmp2_i32);\n                        break;\n                    }\n\n                    gen_helper_fp_arith_ST0_FT0(op1);\n                    if (op1 == 3) {\n                        /* fcomp needs pop */\n                        gen_helper_fpop();\n                    }\n                }\n                break;\n            case 0x08: /* flds */\n            case 0x0a: /* fsts */\n            case 0x0b: /* fstps */\n            case 0x18 ... 0x1b: /* fildl, fisttpl, fistl, fistpl */\n            case 0x28 ... 0x2b: /* fldl, fisttpll, fstl, fstpl */\n            case 0x38 ... 0x3b: /* filds, fisttps, fists, fistps */\n                switch(op & 7) {\n                case 0:\n                    switch(op >> 4) {\n                    case 0:\n                        gen_op_ld_T0_A0(OT_LONG + s->mem_index);\n                        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n                        gen_helper_flds_ST0(cpu_tmp2_i32);\n                        break;\n                    case 1:\n                        gen_op_ld_T0_A0(OT_LONG + s->mem_index);\n                        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n                        gen_helper_fildl_ST0(cpu_tmp2_i32);\n                        break;\n                    case 2:\n                        tcg_gen_qemu_ld64(cpu_tmp1_i64, cpu_A0, \n                                          (s->mem_index >> 2) - 1);\n                        gen_helper_fldl_ST0(cpu_tmp1_i64);\n                        break;\n                    case 3:\n                    default:\n                        gen_op_lds_T0_A0(OT_WORD + s->mem_index);\n                        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n                        gen_helper_fildl_ST0(cpu_tmp2_i32);\n                        break;\n                    }\n                    break;\n                case 1:\n                    /* XXX: the corresponding CPUID bit must be tested ! */\n                    switch(op >> 4) {\n                    case 1:\n                        gen_helper_fisttl_ST0(cpu_tmp2_i32);\n                        tcg_gen_extu_i32_tl(cpu_T[0], cpu_tmp2_i32);\n                        gen_op_st_T0_A0(OT_LONG + s->mem_index);\n                        break;\n                    case 2:\n                        gen_helper_fisttll_ST0(cpu_tmp1_i64);\n                        tcg_gen_qemu_st64(cpu_tmp1_i64, cpu_A0, \n                                          (s->mem_index >> 2) - 1);\n                        break;\n                    case 3:\n                    default:\n                        gen_helper_fistt_ST0(cpu_tmp2_i32);\n                        tcg_gen_extu_i32_tl(cpu_T[0], cpu_tmp2_i32);\n                        gen_op_st_T0_A0(OT_WORD + s->mem_index);\n                        break;\n                    }\n                    gen_helper_fpop();\n                    break;\n                default:\n                    switch(op >> 4) {\n                    case 0:\n                        gen_helper_fsts_ST0(cpu_tmp2_i32);\n                        tcg_gen_extu_i32_tl(cpu_T[0], cpu_tmp2_i32);\n                        gen_op_st_T0_A0(OT_LONG + s->mem_index);\n                        break;\n                    case 1:\n                        gen_helper_fistl_ST0(cpu_tmp2_i32);\n                        tcg_gen_extu_i32_tl(cpu_T[0], cpu_tmp2_i32);\n                        gen_op_st_T0_A0(OT_LONG + s->mem_index);\n                        break;\n                    case 2:\n                        gen_helper_fstl_ST0(cpu_tmp1_i64);\n                        tcg_gen_qemu_st64(cpu_tmp1_i64, cpu_A0, \n                                          (s->mem_index >> 2) - 1);\n                        break;\n                    case 3:\n                    default:\n                        gen_helper_fist_ST0(cpu_tmp2_i32);\n                        tcg_gen_extu_i32_tl(cpu_T[0], cpu_tmp2_i32);\n                        gen_op_st_T0_A0(OT_WORD + s->mem_index);\n                        break;\n                    }\n                    if ((op & 7) == 3)\n                        gen_helper_fpop();\n                    break;\n                }\n                break;\n            case 0x0c: /* fldenv mem */\n                if (s->cc_op != CC_OP_DYNAMIC)\n                    gen_op_set_cc_op(s->cc_op);\n                gen_jmp_im(pc_start - s->cs_base);\n                gen_helper_fldenv(\n                                   cpu_A0, tcg_const_i32(s->dflag));\n                break;\n            case 0x0d: /* fldcw mem */\n                gen_op_ld_T0_A0(OT_WORD + s->mem_index);\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n                gen_helper_fldcw(cpu_tmp2_i32);\n                break;\n            case 0x0e: /* fnstenv mem */\n                if (s->cc_op != CC_OP_DYNAMIC)\n                    gen_op_set_cc_op(s->cc_op);\n                gen_jmp_im(pc_start - s->cs_base);\n                gen_helper_fstenv(cpu_A0, tcg_const_i32(s->dflag));\n                break;\n            case 0x0f: /* fnstcw mem */\n                gen_helper_fnstcw(cpu_tmp2_i32);\n                tcg_gen_extu_i32_tl(cpu_T[0], cpu_tmp2_i32);\n                gen_op_st_T0_A0(OT_WORD + s->mem_index);\n                break;\n            case 0x1d: /* fldt mem */\n                if (s->cc_op != CC_OP_DYNAMIC)\n                    gen_op_set_cc_op(s->cc_op);\n                gen_jmp_im(pc_start - s->cs_base);\n                gen_helper_fldt_ST0(cpu_A0);\n                break;\n            case 0x1f: /* fstpt mem */\n                if (s->cc_op != CC_OP_DYNAMIC)\n                    gen_op_set_cc_op(s->cc_op);\n                gen_jmp_im(pc_start - s->cs_base);\n                gen_helper_fstt_ST0(cpu_A0);\n                gen_helper_fpop();\n                break;\n            case 0x2c: /* frstor mem */\n                if (s->cc_op != CC_OP_DYNAMIC)\n                    gen_op_set_cc_op(s->cc_op);\n                gen_jmp_im(pc_start - s->cs_base);\n                gen_helper_frstor(cpu_A0, tcg_const_i32(s->dflag));\n                break;\n            case 0x2e: /* fnsave mem */\n                if (s->cc_op != CC_OP_DYNAMIC)\n                    gen_op_set_cc_op(s->cc_op);\n                gen_jmp_im(pc_start - s->cs_base);\n                gen_helper_fsave(cpu_A0, tcg_const_i32(s->dflag));\n                break;\n            case 0x2f: /* fnstsw mem */\n                gen_helper_fnstsw(cpu_tmp2_i32);\n                tcg_gen_extu_i32_tl(cpu_T[0], cpu_tmp2_i32);\n                gen_op_st_T0_A0(OT_WORD + s->mem_index);\n                break;\n            case 0x3c: /* fbld */\n                if (s->cc_op != CC_OP_DYNAMIC)\n                    gen_op_set_cc_op(s->cc_op);\n                gen_jmp_im(pc_start - s->cs_base);\n                gen_helper_fbld_ST0(cpu_A0);\n                break;\n            case 0x3e: /* fbstp */\n                if (s->cc_op != CC_OP_DYNAMIC)\n                    gen_op_set_cc_op(s->cc_op);\n                gen_jmp_im(pc_start - s->cs_base);\n                gen_helper_fbst_ST0(cpu_A0);\n                gen_helper_fpop();\n                break;\n            case 0x3d: /* fildll */\n                tcg_gen_qemu_ld64(cpu_tmp1_i64, cpu_A0, \n                                  (s->mem_index >> 2) - 1);\n                gen_helper_fildll_ST0(cpu_tmp1_i64);\n                break;\n            case 0x3f: /* fistpll */\n                gen_helper_fistll_ST0(cpu_tmp1_i64);\n                tcg_gen_qemu_st64(cpu_tmp1_i64, cpu_A0, \n                                  (s->mem_index >> 2) - 1);\n                gen_helper_fpop();\n                break;\n            default:\n                goto illegal_op;\n            }\n        } else {\n            /* register float ops */\n            opreg = rm;\n\n            switch(op) {\n            case 0x08: /* fld sti */\n                gen_helper_fpush();\n                gen_helper_fmov_ST0_STN(tcg_const_i32((opreg + 1) & 7));\n                break;\n            case 0x09: /* fxchg sti */\n            case 0x29: /* fxchg4 sti, undocumented op */\n            case 0x39: /* fxchg7 sti, undocumented op */\n                gen_helper_fxchg_ST0_STN(tcg_const_i32(opreg));\n                break;\n            case 0x0a: /* grp d9/2 */\n                switch(rm) {\n                case 0: /* fnop */\n                    /* check exceptions (FreeBSD FPU probe) */\n                    if (s->cc_op != CC_OP_DYNAMIC)\n                        gen_op_set_cc_op(s->cc_op);\n                    gen_jmp_im(pc_start - s->cs_base);\n                    gen_helper_fwait();\n                    break;\n                default:\n                    goto illegal_op;\n                }\n                break;\n            case 0x0c: /* grp d9/4 */\n                switch(rm) {\n                case 0: /* fchs */\n                    gen_helper_fchs_ST0();\n                    break;\n                case 1: /* fabs */\n                    gen_helper_fabs_ST0();\n                    break;\n                case 4: /* ftst */\n                    gen_helper_fldz_FT0();\n                    gen_helper_fcom_ST0_FT0();\n                    break;\n                case 5: /* fxam */\n                    gen_helper_fxam_ST0();\n                    break;\n                default:\n                    goto illegal_op;\n                }\n                break;\n            case 0x0d: /* grp d9/5 */\n                {\n                    switch(rm) {\n                    case 0:\n                        gen_helper_fpush();\n                        gen_helper_fld1_ST0();\n                        break;\n                    case 1:\n                        gen_helper_fpush();\n                        gen_helper_fldl2t_ST0();\n                        break;\n                    case 2:\n                        gen_helper_fpush();\n                        gen_helper_fldl2e_ST0();\n                        break;\n                    case 3:\n                        gen_helper_fpush();\n                        gen_helper_fldpi_ST0();\n                        break;\n                    case 4:\n                        gen_helper_fpush();\n                        gen_helper_fldlg2_ST0();\n                        break;\n                    case 5:\n                        gen_helper_fpush();\n                        gen_helper_fldln2_ST0();\n                        break;\n                    case 6:\n                        gen_helper_fpush();\n                        gen_helper_fldz_ST0();\n                        break;\n                    default:\n                        goto illegal_op;\n                    }\n                }\n                break;\n            case 0x0e: /* grp d9/6 */\n                switch(rm) {\n                case 0: /* f2xm1 */\n                    gen_helper_f2xm1();\n                    break;\n                case 1: /* fyl2x */\n                    gen_helper_fyl2x();\n                    break;\n                case 2: /* fptan */\n                    gen_helper_fptan();\n                    break;\n                case 3: /* fpatan */\n                    gen_helper_fpatan();\n                    break;\n                case 4: /* fxtract */\n                    gen_helper_fxtract();\n                    break;\n                case 5: /* fprem1 */\n                    gen_helper_fprem1();\n                    break;\n                case 6: /* fdecstp */\n                    gen_helper_fdecstp();\n                    break;\n                default:\n                case 7: /* fincstp */\n                    gen_helper_fincstp();\n                    break;\n                }\n                break;\n            case 0x0f: /* grp d9/7 */\n                switch(rm) {\n                case 0: /* fprem */\n                    gen_helper_fprem();\n                    break;\n                case 1: /* fyl2xp1 */\n                    gen_helper_fyl2xp1();\n                    break;\n                case 2: /* fsqrt */\n                    gen_helper_fsqrt();\n                    break;\n                case 3: /* fsincos */\n                    gen_helper_fsincos();\n                    break;\n                case 5: /* fscale */\n                    gen_helper_fscale();\n                    break;\n                case 4: /* frndint */\n                    gen_helper_frndint();\n                    break;\n                case 6: /* fsin */\n                    gen_helper_fsin();\n                    break;\n                default:\n                case 7: /* fcos */\n                    gen_helper_fcos();\n                    break;\n                }\n                break;\n            case 0x00: case 0x01: case 0x04 ... 0x07: /* fxxx st, sti */\n            case 0x20: case 0x21: case 0x24 ... 0x27: /* fxxx sti, st */\n            case 0x30: case 0x31: case 0x34 ... 0x37: /* fxxxp sti, st */\n                {\n                    int op1;\n\n                    op1 = op & 7;\n                    if (op >= 0x20) {\n                        gen_helper_fp_arith_STN_ST0(op1, opreg);\n                        if (op >= 0x30)\n                            gen_helper_fpop();\n                    } else {\n                        gen_helper_fmov_FT0_STN(tcg_const_i32(opreg));\n                        gen_helper_fp_arith_ST0_FT0(op1);\n                    }\n                }\n                break;\n            case 0x02: /* fcom */\n            case 0x22: /* fcom2, undocumented op */\n                gen_helper_fmov_FT0_STN(tcg_const_i32(opreg));\n                gen_helper_fcom_ST0_FT0();\n                break;\n            case 0x03: /* fcomp */\n            case 0x23: /* fcomp3, undocumented op */\n            case 0x32: /* fcomp5, undocumented op */\n                gen_helper_fmov_FT0_STN(tcg_const_i32(opreg));\n                gen_helper_fcom_ST0_FT0();\n                gen_helper_fpop();\n                break;\n            case 0x15: /* da/5 */\n                switch(rm) {\n                case 1: /* fucompp */\n                    gen_helper_fmov_FT0_STN(tcg_const_i32(1));\n                    gen_helper_fucom_ST0_FT0();\n                    gen_helper_fpop();\n                    gen_helper_fpop();\n                    break;\n                default:\n                    goto illegal_op;\n                }\n                break;\n            case 0x1c:\n                switch(rm) {\n                case 0: /* feni (287 only, just do nop here) */\n                    break;\n                case 1: /* fdisi (287 only, just do nop here) */\n                    break;\n                case 2: /* fclex */\n                    gen_helper_fclex();\n                    break;\n                case 3: /* fninit */\n                    gen_helper_fninit();\n                    break;\n                case 4: /* fsetpm (287 only, just do nop here) */\n                    break;\n                default:\n                    goto illegal_op;\n                }\n                break;\n            case 0x1d: /* fucomi */\n                if (s->cc_op != CC_OP_DYNAMIC)\n                    gen_op_set_cc_op(s->cc_op);\n                gen_helper_fmov_FT0_STN(tcg_const_i32(opreg));\n                gen_helper_fucomi_ST0_FT0();\n                s->cc_op = CC_OP_EFLAGS;\n                break;\n            case 0x1e: /* fcomi */\n                if (s->cc_op != CC_OP_DYNAMIC)\n                    gen_op_set_cc_op(s->cc_op);\n                gen_helper_fmov_FT0_STN(tcg_const_i32(opreg));\n                gen_helper_fcomi_ST0_FT0();\n                s->cc_op = CC_OP_EFLAGS;\n                break;\n            case 0x28: /* ffree sti */\n                gen_helper_ffree_STN(tcg_const_i32(opreg));\n                break;\n            case 0x2a: /* fst sti */\n                gen_helper_fmov_STN_ST0(tcg_const_i32(opreg));\n                break;\n            case 0x2b: /* fstp sti */\n            case 0x0b: /* fstp1 sti, undocumented op */\n            case 0x3a: /* fstp8 sti, undocumented op */\n            case 0x3b: /* fstp9 sti, undocumented op */\n                gen_helper_fmov_STN_ST0(tcg_const_i32(opreg));\n                gen_helper_fpop();\n                break;\n            case 0x2c: /* fucom st(i) */\n                gen_helper_fmov_FT0_STN(tcg_const_i32(opreg));\n                gen_helper_fucom_ST0_FT0();\n                break;\n            case 0x2d: /* fucomp st(i) */\n                gen_helper_fmov_FT0_STN(tcg_const_i32(opreg));\n                gen_helper_fucom_ST0_FT0();\n                gen_helper_fpop();\n                break;\n            case 0x33: /* de/3 */\n                switch(rm) {\n                case 1: /* fcompp */\n                    gen_helper_fmov_FT0_STN(tcg_const_i32(1));\n                    gen_helper_fcom_ST0_FT0();\n                    gen_helper_fpop();\n                    gen_helper_fpop();\n                    break;\n                default:\n                    goto illegal_op;\n                }\n                break;\n            case 0x38: /* ffreep sti, undocumented op */\n                gen_helper_ffree_STN(tcg_const_i32(opreg));\n                gen_helper_fpop();\n                break;\n            case 0x3c: /* df/4 */\n                switch(rm) {\n                case 0:\n                    gen_helper_fnstsw(cpu_tmp2_i32);\n                    tcg_gen_extu_i32_tl(cpu_T[0], cpu_tmp2_i32);\n                    gen_op_mov_reg_T0(OT_WORD, R_EAX);\n                    break;\n                default:\n                    goto illegal_op;\n                }\n                break;\n            case 0x3d: /* fucomip */\n                if (s->cc_op != CC_OP_DYNAMIC)\n                    gen_op_set_cc_op(s->cc_op);\n                gen_helper_fmov_FT0_STN(tcg_const_i32(opreg));\n                gen_helper_fucomi_ST0_FT0();\n                gen_helper_fpop();\n                s->cc_op = CC_OP_EFLAGS;\n                break;\n            case 0x3e: /* fcomip */\n                if (s->cc_op != CC_OP_DYNAMIC)\n                    gen_op_set_cc_op(s->cc_op);\n                gen_helper_fmov_FT0_STN(tcg_const_i32(opreg));\n                gen_helper_fcomi_ST0_FT0();\n                gen_helper_fpop();\n                s->cc_op = CC_OP_EFLAGS;\n                break;\n            case 0x10 ... 0x13: /* fcmovxx */\n            case 0x18 ... 0x1b:\n                {\n                    int op1, l1;\n                    static const uint8_t fcmov_cc[8] = {\n                        (JCC_B << 1),\n                        (JCC_Z << 1),\n                        (JCC_BE << 1),\n                        (JCC_P << 1),\n                    };\n                    op1 = fcmov_cc[op & 3] | (((op >> 3) & 1) ^ 1);\n                    l1 = gen_new_label();\n                    gen_jcc1(s, s->cc_op, op1, l1);\n                    gen_helper_fmov_ST0_STN(tcg_const_i32(opreg));\n                    gen_set_label(l1);\n                }\n                break;\n            default:\n                goto illegal_op;\n            }\n        }\n        break;\n        /************************/\n        /* string ops */\n\n    case 0xa4: /* movsS */\n    case 0xa5:\n        if ((b & 1) == 0)\n            ot = OT_BYTE;\n        else\n            ot = dflag + OT_WORD;\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n            gen_repz_movs(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n        } else {\n            gen_movs(s, ot);\n        }\n        break;\n\n    case 0xaa: /* stosS */\n    case 0xab:\n        if ((b & 1) == 0)\n            ot = OT_BYTE;\n        else\n            ot = dflag + OT_WORD;\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n            gen_repz_stos(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n        } else {\n            gen_stos(s, ot);\n        }\n        break;\n    case 0xac: /* lodsS */\n    case 0xad:\n        if ((b & 1) == 0)\n            ot = OT_BYTE;\n        else\n            ot = dflag + OT_WORD;\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n            gen_repz_lods(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n        } else {\n            gen_lods(s, ot);\n        }\n        break;\n    case 0xae: /* scasS */\n    case 0xaf:\n        if ((b & 1) == 0)\n            ot = OT_BYTE;\n        else\n            ot = dflag + OT_WORD;\n        if (prefixes & PREFIX_REPNZ) {\n            gen_repz_scas(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 1);\n        } else if (prefixes & PREFIX_REPZ) {\n            gen_repz_scas(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 0);\n        } else {\n            gen_scas(s, ot);\n            s->cc_op = CC_OP_SUBB + ot;\n        }\n        break;\n\n    case 0xa6: /* cmpsS */\n    case 0xa7:\n        if ((b & 1) == 0)\n            ot = OT_BYTE;\n        else\n            ot = dflag + OT_WORD;\n        if (prefixes & PREFIX_REPNZ) {\n            gen_repz_cmps(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 1);\n        } else if (prefixes & PREFIX_REPZ) {\n            gen_repz_cmps(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 0);\n        } else {\n            gen_cmps(s, ot);\n            s->cc_op = CC_OP_SUBB + ot;\n        }\n        break;\n    case 0x6c: /* insS */\n    case 0x6d:\n        if ((b & 1) == 0)\n            ot = OT_BYTE;\n        else\n            ot = dflag ? OT_LONG : OT_WORD;\n        gen_op_mov_TN_reg(OT_WORD, 0, R_EDX);\n        gen_op_andl_T0_ffff();\n        gen_check_io(s, ot, pc_start - s->cs_base, \n                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes) | 4);\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n            gen_repz_ins(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n        } else {\n            gen_ins(s, ot);\n            if (use_icount) {\n                gen_jmp(s, s->pc - s->cs_base);\n            }\n        }\n        break;\n    case 0x6e: /* outsS */\n    case 0x6f:\n        if ((b & 1) == 0)\n            ot = OT_BYTE;\n        else\n            ot = dflag ? OT_LONG : OT_WORD;\n        gen_op_mov_TN_reg(OT_WORD, 0, R_EDX);\n        gen_op_andl_T0_ffff();\n        gen_check_io(s, ot, pc_start - s->cs_base,\n                     svm_is_rep(prefixes) | 4);\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n            gen_repz_outs(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n        } else {\n            gen_outs(s, ot);\n            if (use_icount) {\n                gen_jmp(s, s->pc - s->cs_base);\n            }\n        }\n        break;\n\n        /************************/\n        /* port I/O */\n\n    case 0xe4:\n    case 0xe5:\n        if ((b & 1) == 0)\n            ot = OT_BYTE;\n        else\n            ot = dflag ? OT_LONG : OT_WORD;\n        val = ldub_code(s->pc++);\n        gen_op_movl_T0_im(val);\n        gen_check_io(s, ot, pc_start - s->cs_base,\n                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes));\n        if (use_icount)\n            gen_io_start();\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n        gen_helper_in_func(ot, cpu_T[1], cpu_tmp2_i32);\n        gen_op_mov_reg_T1(ot, R_EAX);\n        if (use_icount) {\n            gen_io_end();\n            gen_jmp(s, s->pc - s->cs_base);\n        }\n        break;\n    case 0xe6:\n    case 0xe7:\n        if ((b & 1) == 0)\n            ot = OT_BYTE;\n        else\n            ot = dflag ? OT_LONG : OT_WORD;\n        val = ldub_code(s->pc++);\n        gen_op_movl_T0_im(val);\n        gen_check_io(s, ot, pc_start - s->cs_base,\n                     svm_is_rep(prefixes));\n        gen_op_mov_TN_reg(ot, 1, R_EAX);\n\n        if (use_icount)\n            gen_io_start();\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n        tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff);\n        tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[1]);\n        gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);\n        if (use_icount) {\n            gen_io_end();\n            gen_jmp(s, s->pc - s->cs_base);\n        }\n        break;\n    case 0xec:\n    case 0xed:\n        if ((b & 1) == 0)\n            ot = OT_BYTE;\n        else\n            ot = dflag ? OT_LONG : OT_WORD;\n        gen_op_mov_TN_reg(OT_WORD, 0, R_EDX);\n        gen_op_andl_T0_ffff();\n        gen_check_io(s, ot, pc_start - s->cs_base,\n                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes));\n        if (use_icount)\n            gen_io_start();\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n        gen_helper_in_func(ot, cpu_T[1], cpu_tmp2_i32);\n        gen_op_mov_reg_T1(ot, R_EAX);\n        if (use_icount) {\n            gen_io_end();\n            gen_jmp(s, s->pc - s->cs_base);\n        }\n        break;\n    case 0xee:\n    case 0xef:\n        if ((b & 1) == 0)\n            ot = OT_BYTE;\n        else\n            ot = dflag ? OT_LONG : OT_WORD;\n        gen_op_mov_TN_reg(OT_WORD, 0, R_EDX);\n        gen_op_andl_T0_ffff();\n        gen_check_io(s, ot, pc_start - s->cs_base,\n                     svm_is_rep(prefixes));\n        gen_op_mov_TN_reg(ot, 1, R_EAX);\n\n        if (use_icount)\n            gen_io_start();\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n        tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff);\n        tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[1]);\n        gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);\n        if (use_icount) {\n            gen_io_end();\n            gen_jmp(s, s->pc - s->cs_base);\n        }\n        break;\n\n        /************************/\n        /* control */\n    case 0xc2: /* ret im */\n        val = ldsw_code(s->pc);\n        s->pc += 2;\n        gen_pop_T0(s);\n        if (CODE64(s) && s->dflag)\n            s->dflag = 2;\n        gen_stack_update(s, val + (2 << s->dflag));\n        if (s->dflag == 0)\n            gen_op_andl_T0_ffff();\n        gen_op_jmp_T0();\n        gen_eob(s);\n        break;\n    case 0xc3: /* ret */\n        gen_pop_T0(s);\n        gen_pop_update(s);\n        if (s->dflag == 0)\n            gen_op_andl_T0_ffff();\n        gen_op_jmp_T0();\n        gen_eob(s);\n        break;\n    case 0xca: /* lret im */\n        val = ldsw_code(s->pc);\n        s->pc += 2;\n    do_lret:\n        if (s->pe && !s->vm86) {\n            if (s->cc_op != CC_OP_DYNAMIC)\n                gen_op_set_cc_op(s->cc_op);\n            gen_jmp_im(pc_start - s->cs_base);\n            gen_helper_lret_protected(tcg_const_i32(s->dflag),\n                                      tcg_const_i32(val));\n        } else {\n            gen_stack_A0(s);\n            /* pop offset */\n            gen_op_ld_T0_A0(1 + s->dflag + s->mem_index);\n            if (s->dflag == 0)\n                gen_op_andl_T0_ffff();\n            /* NOTE: keeping EIP updated is not a problem in case of\n               exception */\n            gen_op_jmp_T0();\n            /* pop selector */\n            gen_op_addl_A0_im(2 << s->dflag);\n            gen_op_ld_T0_A0(1 + s->dflag + s->mem_index);\n            gen_op_movl_seg_T0_vm(R_CS);\n            /* add stack offset */\n            gen_stack_update(s, val + (4 << s->dflag));\n        }\n        gen_eob(s);\n        break;\n    case 0xcb: /* lret */\n        val = 0;\n        goto do_lret;\n    case 0xcf: /* iret */\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_IRET);\n        if (!s->pe) {\n            /* real mode */\n            gen_helper_iret_real(tcg_const_i32(s->dflag));\n            s->cc_op = CC_OP_EFLAGS;\n        } else if (s->vm86) {\n            if (s->iopl != 3) {\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n            } else {\n                gen_helper_iret_real(tcg_const_i32(s->dflag));\n                s->cc_op = CC_OP_EFLAGS;\n            }\n        } else {\n            if (s->cc_op != CC_OP_DYNAMIC)\n                gen_op_set_cc_op(s->cc_op);\n            gen_jmp_im(pc_start - s->cs_base);\n            gen_helper_iret_protected(tcg_const_i32(s->dflag), \n                                      tcg_const_i32(s->pc - s->cs_base));\n            s->cc_op = CC_OP_EFLAGS;\n        }\n        gen_eob(s);\n        break;\n    case 0xe8: /* call im */\n        {\n            if (dflag)\n                tval = (int32_t)insn_get(s, OT_LONG);\n            else\n                tval = (int16_t)insn_get(s, OT_WORD);\n            next_eip = s->pc - s->cs_base;\n            tval += next_eip;\n            if (s->dflag == 0)\n                tval &= 0xffff;\n            gen_movtl_T0_im(next_eip);\n            gen_push_T0(s);\n            gen_jmp(s, tval);\n        }\n        break;\n    case 0x9a: /* lcall im */\n        {\n            unsigned int selector, offset;\n\n            if (CODE64(s))\n                goto illegal_op;\n            ot = dflag ? OT_LONG : OT_WORD;\n            offset = insn_get(s, ot);\n            selector = insn_get(s, OT_WORD);\n\n            gen_op_movl_T0_im(selector);\n            gen_op_movl_T1_imu(offset);\n        }\n        goto do_lcall;\n    case 0xe9: /* jmp im */\n        if (dflag)\n            tval = (int32_t)insn_get(s, OT_LONG);\n        else\n            tval = (int16_t)insn_get(s, OT_WORD);\n        tval += s->pc - s->cs_base;\n        if (s->dflag == 0)\n            tval &= 0xffff;\n        else if(!CODE64(s))\n            tval &= 0xffffffff;\n        gen_jmp(s, tval);\n        break;\n    case 0xea: /* ljmp im */\n        {\n            unsigned int selector, offset;\n\n            if (CODE64(s))\n                goto illegal_op;\n            ot = dflag ? OT_LONG : OT_WORD;\n            offset = insn_get(s, ot);\n            selector = insn_get(s, OT_WORD);\n\n            gen_op_movl_T0_im(selector);\n            gen_op_movl_T1_imu(offset);\n        }\n        goto do_ljmp;\n    case 0xeb: /* jmp Jb */\n        tval = (int8_t)insn_get(s, OT_BYTE);\n        tval += s->pc - s->cs_base;\n        if (s->dflag == 0)\n            tval &= 0xffff;\n        gen_jmp(s, tval);\n        break;\n    case 0x70 ... 0x7f: /* jcc Jb */\n        tval = (int8_t)insn_get(s, OT_BYTE);\n        goto do_jcc;\n    case 0x180 ... 0x18f: /* jcc Jv */\n        if (dflag) {\n            tval = (int32_t)insn_get(s, OT_LONG);\n        } else {\n            tval = (int16_t)insn_get(s, OT_WORD);\n        }\n    do_jcc:\n        next_eip = s->pc - s->cs_base;\n        tval += next_eip;\n        if (s->dflag == 0)\n            tval &= 0xffff;\n        gen_jcc(s, b, tval, next_eip);\n        break;\n\n    case 0x190 ... 0x19f: /* setcc Gv */\n        modrm = ldub_code(s->pc++);\n        gen_setcc(s, b);\n        gen_ldst_modrm(s, modrm, OT_BYTE, OR_TMP0, 1);\n        break;\n    case 0x140 ... 0x14f: /* cmov Gv, Ev */\n        {\n            int l1;\n            TCGv t0;\n\n            ot = dflag + OT_WORD;\n            modrm = ldub_code(s->pc++);\n            reg = ((modrm >> 3) & 7) | rex_r;\n            mod = (modrm >> 6) & 3;\n            t0 = tcg_temp_local_new();\n            if (mod != 3) {\n                gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n                gen_op_ld_v(ot + s->mem_index, t0, cpu_A0);\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_mov_v_reg(ot, t0, rm);\n            }\n#ifdef TARGET_X86_64\n            if (ot == OT_LONG) {\n                /* XXX: specific Intel behaviour ? */\n                l1 = gen_new_label();\n                gen_jcc1(s, s->cc_op, b ^ 1, l1);\n                tcg_gen_st32_tl(t0, cpu_env, offsetof(CPUState, regs[reg]) + REG_L_OFFSET);\n                gen_set_label(l1);\n                tcg_gen_movi_tl(cpu_tmp0, 0);\n                tcg_gen_st32_tl(cpu_tmp0, cpu_env, offsetof(CPUState, regs[reg]) + REG_LH_OFFSET);\n            } else\n#endif\n            {\n                l1 = gen_new_label();\n                gen_jcc1(s, s->cc_op, b ^ 1, l1);\n                gen_op_mov_reg_v(ot, reg, t0);\n                gen_set_label(l1);\n            }\n            tcg_temp_free(t0);\n        }\n        break;\n\n        /************************/\n        /* flags */\n    case 0x9c: /* pushf */\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_PUSHF);\n        if (s->vm86 && s->iopl != 3) {\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n        } else {\n            if (s->cc_op != CC_OP_DYNAMIC)\n                gen_op_set_cc_op(s->cc_op);\n            gen_helper_read_eflags(cpu_T[0]);\n            gen_push_T0(s);\n        }\n        break;\n    case 0x9d: /* popf */\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_POPF);\n        if (s->vm86 && s->iopl != 3) {\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n        } else {\n            gen_pop_T0(s);\n            if (s->cpl == 0) {\n                if (s->dflag) {\n                    gen_helper_write_eflags(cpu_T[0],\n                                       tcg_const_i32((TF_MASK | AC_MASK | ID_MASK | NT_MASK | IF_MASK | IOPL_MASK)));\n                } else {\n                    gen_helper_write_eflags(cpu_T[0],\n                                       tcg_const_i32((TF_MASK | AC_MASK | ID_MASK | NT_MASK | IF_MASK | IOPL_MASK) & 0xffff));\n                }\n            } else {\n                if (s->cpl <= s->iopl) {\n                    if (s->dflag) {\n                        gen_helper_write_eflags(cpu_T[0],\n                                           tcg_const_i32((TF_MASK | AC_MASK | ID_MASK | NT_MASK | IF_MASK)));\n                    } else {\n                        gen_helper_write_eflags(cpu_T[0],\n                                           tcg_const_i32((TF_MASK | AC_MASK | ID_MASK | NT_MASK | IF_MASK) & 0xffff));\n                    }\n                } else {\n                    if (s->dflag) {\n                        gen_helper_write_eflags(cpu_T[0],\n                                           tcg_const_i32((TF_MASK | AC_MASK | ID_MASK | NT_MASK)));\n                    } else {\n                        gen_helper_write_eflags(cpu_T[0],\n                                           tcg_const_i32((TF_MASK | AC_MASK | ID_MASK | NT_MASK) & 0xffff));\n                    }\n                }\n            }\n            gen_pop_update(s);\n            s->cc_op = CC_OP_EFLAGS;\n            /* abort translation because TF flag may change */\n            gen_jmp_im(s->pc - s->cs_base);\n            gen_eob(s);\n        }\n        break;\n    case 0x9e: /* sahf */\n        if (CODE64(s) && !(s->cpuid_ext3_features & CPUID_EXT3_LAHF_LM))\n            goto illegal_op;\n        gen_op_mov_TN_reg(OT_BYTE, 0, R_AH);\n        if (s->cc_op != CC_OP_DYNAMIC)\n            gen_op_set_cc_op(s->cc_op);\n        gen_compute_eflags(cpu_cc_src);\n        tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, CC_O);\n        tcg_gen_andi_tl(cpu_T[0], cpu_T[0], CC_S | CC_Z | CC_A | CC_P | CC_C);\n        tcg_gen_or_tl(cpu_cc_src, cpu_cc_src, cpu_T[0]);\n        s->cc_op = CC_OP_EFLAGS;\n        break;\n    case 0x9f: /* lahf */\n        if (CODE64(s) && !(s->cpuid_ext3_features & CPUID_EXT3_LAHF_LM))\n            goto illegal_op;\n        if (s->cc_op != CC_OP_DYNAMIC)\n            gen_op_set_cc_op(s->cc_op);\n        gen_compute_eflags(cpu_T[0]);\n        /* Note: gen_compute_eflags() only gives the condition codes */\n        tcg_gen_ori_tl(cpu_T[0], cpu_T[0], 0x02);\n        gen_op_mov_reg_T0(OT_BYTE, R_AH);\n        break;\n    case 0xf5: /* cmc */\n        if (s->cc_op != CC_OP_DYNAMIC)\n            gen_op_set_cc_op(s->cc_op);\n        gen_compute_eflags(cpu_cc_src);\n        tcg_gen_xori_tl(cpu_cc_src, cpu_cc_src, CC_C);\n        s->cc_op = CC_OP_EFLAGS;\n        break;\n    case 0xf8: /* clc */\n        if (s->cc_op != CC_OP_DYNAMIC)\n            gen_op_set_cc_op(s->cc_op);\n        gen_compute_eflags(cpu_cc_src);\n        tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, ~CC_C);\n        s->cc_op = CC_OP_EFLAGS;\n        break;\n    case 0xf9: /* stc */\n        if (s->cc_op != CC_OP_DYNAMIC)\n            gen_op_set_cc_op(s->cc_op);\n        gen_compute_eflags(cpu_cc_src);\n        tcg_gen_ori_tl(cpu_cc_src, cpu_cc_src, CC_C);\n        s->cc_op = CC_OP_EFLAGS;\n        break;\n    case 0xfc: /* cld */\n        tcg_gen_movi_i32(cpu_tmp2_i32, 1);\n        tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, offsetof(CPUState, df));\n        break;\n    case 0xfd: /* std */\n        tcg_gen_movi_i32(cpu_tmp2_i32, -1);\n        tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, offsetof(CPUState, df));\n        break;\n\n        /************************/\n        /* bit operations */\n    case 0x1ba: /* bt/bts/btr/btc Gv, im */\n        ot = dflag + OT_WORD;\n        modrm = ldub_code(s->pc++);\n        op = (modrm >> 3) & 7;\n        mod = (modrm >> 6) & 3;\n        rm = (modrm & 7) | REX_B(s);\n        if (mod != 3) {\n            s->rip_offset = 1;\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n            gen_op_ld_T0_A0(ot + s->mem_index);\n        } else {\n            gen_op_mov_TN_reg(ot, 0, rm);\n        }\n        /* load shift */\n        val = ldub_code(s->pc++);\n        gen_op_movl_T1_im(val);\n        if (op < 4)\n            goto illegal_op;\n        op -= 4;\n        goto bt_op;\n    case 0x1a3: /* bt Gv, Ev */\n        op = 0;\n        goto do_btx;\n    case 0x1ab: /* bts */\n        op = 1;\n        goto do_btx;\n    case 0x1b3: /* btr */\n        op = 2;\n        goto do_btx;\n    case 0x1bb: /* btc */\n        op = 3;\n    do_btx:\n        ot = dflag + OT_WORD;\n        modrm = ldub_code(s->pc++);\n        reg = ((modrm >> 3) & 7) | rex_r;\n        mod = (modrm >> 6) & 3;\n        rm = (modrm & 7) | REX_B(s);\n        gen_op_mov_TN_reg(OT_LONG, 1, reg);\n        if (mod != 3) {\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n            /* specific case: we need to add a displacement */\n            gen_exts(ot, cpu_T[1]);\n            tcg_gen_sari_tl(cpu_tmp0, cpu_T[1], 3 + ot);\n            tcg_gen_shli_tl(cpu_tmp0, cpu_tmp0, ot);\n            tcg_gen_add_tl(cpu_A0, cpu_A0, cpu_tmp0);\n            gen_op_ld_T0_A0(ot + s->mem_index);\n        } else {\n            gen_op_mov_TN_reg(ot, 0, rm);\n        }\n    bt_op:\n        tcg_gen_andi_tl(cpu_T[1], cpu_T[1], (1 << (3 + ot)) - 1);\n        switch(op) {\n        case 0:\n            tcg_gen_shr_tl(cpu_cc_src, cpu_T[0], cpu_T[1]);\n            tcg_gen_movi_tl(cpu_cc_dst, 0);\n            break;\n        case 1:\n            tcg_gen_shr_tl(cpu_tmp4, cpu_T[0], cpu_T[1]);\n            tcg_gen_movi_tl(cpu_tmp0, 1);\n            tcg_gen_shl_tl(cpu_tmp0, cpu_tmp0, cpu_T[1]);\n            tcg_gen_or_tl(cpu_T[0], cpu_T[0], cpu_tmp0);\n            break;\n        case 2:\n            tcg_gen_shr_tl(cpu_tmp4, cpu_T[0], cpu_T[1]);\n            tcg_gen_movi_tl(cpu_tmp0, 1);\n            tcg_gen_shl_tl(cpu_tmp0, cpu_tmp0, cpu_T[1]);\n            tcg_gen_not_tl(cpu_tmp0, cpu_tmp0);\n            tcg_gen_and_tl(cpu_T[0], cpu_T[0], cpu_tmp0);\n            break;\n        default:\n        case 3:\n            tcg_gen_shr_tl(cpu_tmp4, cpu_T[0], cpu_T[1]);\n            tcg_gen_movi_tl(cpu_tmp0, 1);\n            tcg_gen_shl_tl(cpu_tmp0, cpu_tmp0, cpu_T[1]);\n            tcg_gen_xor_tl(cpu_T[0], cpu_T[0], cpu_tmp0);\n            break;\n        }\n        s->cc_op = CC_OP_SARB + ot;\n        if (op != 0) {\n            if (mod != 3)\n                gen_op_st_T0_A0(ot + s->mem_index);\n            else\n                gen_op_mov_reg_T0(ot, rm);\n            tcg_gen_mov_tl(cpu_cc_src, cpu_tmp4);\n            tcg_gen_movi_tl(cpu_cc_dst, 0);\n        }\n        break;\n    case 0x1bc: /* bsf */\n    case 0x1bd: /* bsr */\n        {\n            int label1;\n            TCGv t0;\n\n            ot = dflag + OT_WORD;\n            modrm = ldub_code(s->pc++);\n            reg = ((modrm >> 3) & 7) | rex_r;\n            gen_ldst_modrm(s, modrm, ot, OR_TMP0, 0);\n            gen_extu(ot, cpu_T[0]);\n            label1 = gen_new_label();\n            tcg_gen_movi_tl(cpu_cc_dst, 0);\n            t0 = tcg_temp_local_new();\n            tcg_gen_mov_tl(t0, cpu_T[0]);\n            tcg_gen_brcondi_tl(TCG_COND_EQ, t0, 0, label1);\n            if (b & 1) {\n                gen_helper_bsr(cpu_T[0], t0);\n            } else {\n                gen_helper_bsf(cpu_T[0], t0);\n            }\n            gen_op_mov_reg_T0(ot, reg);\n            tcg_gen_movi_tl(cpu_cc_dst, 1);\n            gen_set_label(label1);\n            tcg_gen_discard_tl(cpu_cc_src);\n            s->cc_op = CC_OP_LOGICB + ot;\n            tcg_temp_free(t0);\n        }\n        break;\n        /************************/\n        /* bcd */\n    case 0x27: /* daa */\n        if (CODE64(s))\n            goto illegal_op;\n        if (s->cc_op != CC_OP_DYNAMIC)\n            gen_op_set_cc_op(s->cc_op);\n        gen_helper_daa();\n        s->cc_op = CC_OP_EFLAGS;\n        break;\n    case 0x2f: /* das */\n        if (CODE64(s))\n            goto illegal_op;\n        if (s->cc_op != CC_OP_DYNAMIC)\n            gen_op_set_cc_op(s->cc_op);\n        gen_helper_das();\n        s->cc_op = CC_OP_EFLAGS;\n        break;\n    case 0x37: /* aaa */\n        if (CODE64(s))\n            goto illegal_op;\n        if (s->cc_op != CC_OP_DYNAMIC)\n            gen_op_set_cc_op(s->cc_op);\n        gen_helper_aaa();\n        s->cc_op = CC_OP_EFLAGS;\n        break;\n    case 0x3f: /* aas */\n        if (CODE64(s))\n            goto illegal_op;\n        if (s->cc_op != CC_OP_DYNAMIC)\n            gen_op_set_cc_op(s->cc_op);\n        gen_helper_aas();\n        s->cc_op = CC_OP_EFLAGS;\n        break;\n    case 0xd4: /* aam */\n        if (CODE64(s))\n            goto illegal_op;\n        val = ldub_code(s->pc++);\n        if (val == 0) {\n            gen_exception(s, EXCP00_DIVZ, pc_start - s->cs_base);\n        } else {\n            gen_helper_aam(tcg_const_i32(val));\n            s->cc_op = CC_OP_LOGICB;\n        }\n        break;\n    case 0xd5: /* aad */\n        if (CODE64(s))\n            goto illegal_op;\n        val = ldub_code(s->pc++);\n        gen_helper_aad(tcg_const_i32(val));\n        s->cc_op = CC_OP_LOGICB;\n        break;\n        /************************/\n        /* misc */\n    case 0x90: /* nop */\n        /* XXX: xchg + rex handling */\n        /* XXX: correct lock test for all insn */\n        if (prefixes & PREFIX_LOCK)\n            goto illegal_op;\n        if (prefixes & PREFIX_REPZ) {\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_PAUSE);\n        }\n        break;\n    case 0x9b: /* fwait */\n        if ((s->flags & (HF_MP_MASK | HF_TS_MASK)) ==\n            (HF_MP_MASK | HF_TS_MASK)) {\n            gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n        } else {\n            if (s->cc_op != CC_OP_DYNAMIC)\n                gen_op_set_cc_op(s->cc_op);\n            gen_jmp_im(pc_start - s->cs_base);\n            gen_helper_fwait();\n        }\n        break;\n    case 0xcc: /* int3 */\n        gen_interrupt(s, EXCP03_INT3, pc_start - s->cs_base, s->pc - s->cs_base);\n        break;\n    case 0xcd: /* int N */\n        val = ldub_code(s->pc++);\n        if (s->vm86 && s->iopl != 3) {\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n        } else {\n            gen_interrupt(s, val, pc_start - s->cs_base, s->pc - s->cs_base);\n        }\n        break;\n    case 0xce: /* into */\n        if (CODE64(s))\n            goto illegal_op;\n        if (s->cc_op != CC_OP_DYNAMIC)\n            gen_op_set_cc_op(s->cc_op);\n        gen_jmp_im(pc_start - s->cs_base);\n        gen_helper_into(tcg_const_i32(s->pc - pc_start));\n        break;\n#ifdef WANT_ICEBP\n    case 0xf1: /* icebp (undocumented, exits to external debugger) */\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_ICEBP);\n#if 1\n        gen_debug(s, pc_start - s->cs_base);\n#else\n        /* start debug */\n        tb_flush(cpu_single_env);\n        cpu_set_log(CPU_LOG_INT | CPU_LOG_TB_IN_ASM);\n#endif\n        break;\n#endif\n    case 0xfa: /* cli */\n        if (!s->vm86) {\n            if (s->cpl <= s->iopl) {\n                gen_helper_cli();\n            } else {\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n            }\n        } else {\n            if (s->iopl == 3) {\n                gen_helper_cli();\n            } else {\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n            }\n        }\n        break;\n    case 0xfb: /* sti */\n        if (!s->vm86) {\n            if (s->cpl <= s->iopl) {\n            gen_sti:\n                gen_helper_sti();\n                /* interruptions are enabled only the first insn after sti */\n                /* If several instructions disable interrupts, only the\n                   _first_ does it */\n                if (!(s->tb->flags & HF_INHIBIT_IRQ_MASK))\n                    gen_helper_set_inhibit_irq();\n                /* give a chance to handle pending irqs */\n                gen_jmp_im(s->pc - s->cs_base);\n                gen_eob(s);\n            } else {\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n            }\n        } else {\n            if (s->iopl == 3) {\n                goto gen_sti;\n            } else {\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n            }\n        }\n        break;\n    case 0x62: /* bound */\n        if (CODE64(s))\n            goto illegal_op;\n        ot = dflag ? OT_LONG : OT_WORD;\n        modrm = ldub_code(s->pc++);\n        reg = (modrm >> 3) & 7;\n        mod = (modrm >> 6) & 3;\n        if (mod == 3)\n            goto illegal_op;\n        gen_op_mov_TN_reg(ot, 0, reg);\n        gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n        gen_jmp_im(pc_start - s->cs_base);\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n        if (ot == OT_WORD)\n            gen_helper_boundw(cpu_A0, cpu_tmp2_i32);\n        else\n            gen_helper_boundl(cpu_A0, cpu_tmp2_i32);\n        break;\n    case 0x1c8 ... 0x1cf: /* bswap reg */\n        reg = (b & 7) | REX_B(s);\n#ifdef TARGET_X86_64\n        if (dflag == 2) {\n            gen_op_mov_TN_reg(OT_QUAD, 0, reg);\n            tcg_gen_bswap_i64(cpu_T[0], cpu_T[0]);\n            gen_op_mov_reg_T0(OT_QUAD, reg);\n        } else\n        {\n            TCGv_i32 tmp0;\n            gen_op_mov_TN_reg(OT_LONG, 0, reg);\n            \n            tmp0 = tcg_temp_new_i32();\n            tcg_gen_trunc_i64_i32(tmp0, cpu_T[0]);\n            tcg_gen_bswap_i32(tmp0, tmp0);\n            tcg_gen_extu_i32_i64(cpu_T[0], tmp0);\n            gen_op_mov_reg_T0(OT_LONG, reg);\n        }\n#else\n        {\n            gen_op_mov_TN_reg(OT_LONG, 0, reg);\n            tcg_gen_bswap_i32(cpu_T[0], cpu_T[0]);\n            gen_op_mov_reg_T0(OT_LONG, reg);\n        }\n#endif\n        break;\n    case 0xd6: /* salc */\n        if (CODE64(s))\n            goto illegal_op;\n        if (s->cc_op != CC_OP_DYNAMIC)\n            gen_op_set_cc_op(s->cc_op);\n        gen_compute_eflags_c(cpu_T[0]);\n        tcg_gen_neg_tl(cpu_T[0], cpu_T[0]);\n        gen_op_mov_reg_T0(OT_BYTE, R_EAX);\n        break;\n    case 0xe0: /* loopnz */\n    case 0xe1: /* loopz */\n    case 0xe2: /* loop */\n    case 0xe3: /* jecxz */\n        {\n            int l1, l2, l3;\n\n            tval = (int8_t)insn_get(s, OT_BYTE);\n            next_eip = s->pc - s->cs_base;\n            tval += next_eip;\n            if (s->dflag == 0)\n                tval &= 0xffff;\n\n            l1 = gen_new_label();\n            l2 = gen_new_label();\n            l3 = gen_new_label();\n            b &= 3;\n            switch(b) {\n            case 0: /* loopnz */\n            case 1: /* loopz */\n                if (s->cc_op != CC_OP_DYNAMIC)\n                    gen_op_set_cc_op(s->cc_op);\n                gen_op_add_reg_im(s->aflag, R_ECX, -1);\n                gen_op_jz_ecx(s->aflag, l3);\n                gen_compute_eflags(cpu_tmp0);\n                tcg_gen_andi_tl(cpu_tmp0, cpu_tmp0, CC_Z);\n                if (b == 0) {\n                    tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_tmp0, 0, l1);\n                } else {\n                    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_tmp0, 0, l1);\n                }\n                break;\n            case 2: /* loop */\n                gen_op_add_reg_im(s->aflag, R_ECX, -1);\n                gen_op_jnz_ecx(s->aflag, l1);\n                break;\n            default:\n            case 3: /* jcxz */\n                gen_op_jz_ecx(s->aflag, l1);\n                break;\n            }\n\n            gen_set_label(l3);\n            gen_jmp_im(next_eip);\n            tcg_gen_br(l2);\n\n            gen_set_label(l1);\n            gen_jmp_im(tval);\n            gen_set_label(l2);\n            gen_eob(s);\n        }\n        break;\n    case 0x130: /* wrmsr */\n    case 0x132: /* rdmsr */\n        if (s->cpl != 0) {\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n        } else {\n            if (s->cc_op != CC_OP_DYNAMIC)\n                gen_op_set_cc_op(s->cc_op);\n            gen_jmp_im(pc_start - s->cs_base);\n            if (b & 2) {\n                gen_helper_rdmsr();\n            } else {\n                gen_helper_wrmsr();\n            }\n        }\n        break;\n    case 0x131: /* rdtsc */\n        if (s->cc_op != CC_OP_DYNAMIC)\n            gen_op_set_cc_op(s->cc_op);\n        gen_jmp_im(pc_start - s->cs_base);\n        if (use_icount)\n            gen_io_start();\n        gen_helper_rdtsc();\n        if (use_icount) {\n            gen_io_end();\n            gen_jmp(s, s->pc - s->cs_base);\n        }\n        break;\n    case 0x133: /* rdpmc */\n        if (s->cc_op != CC_OP_DYNAMIC)\n            gen_op_set_cc_op(s->cc_op);\n        gen_jmp_im(pc_start - s->cs_base);\n        gen_helper_rdpmc();\n        break;\n    case 0x134: /* sysenter */\n        /* For Intel SYSENTER is valid on 64-bit */\n        if (CODE64(s) && cpu_single_env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1)\n            goto illegal_op;\n        if (!s->pe) {\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n        } else {\n            if (s->cc_op != CC_OP_DYNAMIC) {\n                gen_op_set_cc_op(s->cc_op);\n                s->cc_op = CC_OP_DYNAMIC;\n            }\n            gen_jmp_im(pc_start - s->cs_base);\n            gen_helper_sysenter();\n            gen_eob(s);\n        }\n        break;\n    case 0x135: /* sysexit */\n        /* For Intel SYSEXIT is valid on 64-bit */\n        if (CODE64(s) && cpu_single_env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1)\n            goto illegal_op;\n        if (!s->pe) {\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n        } else {\n            if (s->cc_op != CC_OP_DYNAMIC) {\n                gen_op_set_cc_op(s->cc_op);\n                s->cc_op = CC_OP_DYNAMIC;\n            }\n            gen_jmp_im(pc_start - s->cs_base);\n            gen_helper_sysexit(tcg_const_i32(dflag));\n            gen_eob(s);\n        }\n        break;\n#ifdef TARGET_X86_64\n    case 0x105: /* syscall */\n        /* XXX: is it usable in real mode ? */\n        if (s->cc_op != CC_OP_DYNAMIC) {\n            gen_op_set_cc_op(s->cc_op);\n            s->cc_op = CC_OP_DYNAMIC;\n        }\n        gen_jmp_im(pc_start - s->cs_base);\n        gen_helper_syscall(tcg_const_i32(s->pc - pc_start));\n        gen_eob(s);\n        break;\n    case 0x107: /* sysret */\n        if (!s->pe) {\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n        } else {\n            if (s->cc_op != CC_OP_DYNAMIC) {\n                gen_op_set_cc_op(s->cc_op);\n                s->cc_op = CC_OP_DYNAMIC;\n            }\n            gen_jmp_im(pc_start - s->cs_base);\n            gen_helper_sysret(tcg_const_i32(s->dflag));\n            /* condition codes are modified only in long mode */\n            if (s->lma)\n                s->cc_op = CC_OP_EFLAGS;\n            gen_eob(s);\n        }\n        break;\n#endif\n    case 0x1a2: /* cpuid */\n        if (s->cc_op != CC_OP_DYNAMIC)\n            gen_op_set_cc_op(s->cc_op);\n        gen_jmp_im(pc_start - s->cs_base);\n        gen_helper_cpuid();\n        break;\n    case 0xf4: /* hlt */\n        if (s->cpl != 0) {\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n        } else {\n            if (s->cc_op != CC_OP_DYNAMIC)\n                gen_op_set_cc_op(s->cc_op);\n            gen_jmp_im(pc_start - s->cs_base);\n            gen_helper_hlt(tcg_const_i32(s->pc - pc_start));\n            s->is_jmp = 3;\n        }\n        break;\n    case 0x100:\n        modrm = ldub_code(s->pc++);\n        mod = (modrm >> 6) & 3;\n        op = (modrm >> 3) & 7;\n        switch(op) {\n        case 0: /* sldt */\n            if (!s->pe || s->vm86)\n                goto illegal_op;\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_LDTR_READ);\n            tcg_gen_ld32u_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,ldt.selector));\n            ot = OT_WORD;\n            if (mod == 3)\n                ot += s->dflag;\n            gen_ldst_modrm(s, modrm, ot, OR_TMP0, 1);\n            break;\n        case 2: /* lldt */\n            if (!s->pe || s->vm86)\n                goto illegal_op;\n            if (s->cpl != 0) {\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n            } else {\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_LDTR_WRITE);\n                gen_ldst_modrm(s, modrm, OT_WORD, OR_TMP0, 0);\n                gen_jmp_im(pc_start - s->cs_base);\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n                gen_helper_lldt(cpu_tmp2_i32);\n            }\n            break;\n        case 1: /* str */\n            if (!s->pe || s->vm86)\n                goto illegal_op;\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_TR_READ);\n            tcg_gen_ld32u_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,tr.selector));\n            ot = OT_WORD;\n            if (mod == 3)\n                ot += s->dflag;\n            gen_ldst_modrm(s, modrm, ot, OR_TMP0, 1);\n            break;\n        case 3: /* ltr */\n            if (!s->pe || s->vm86)\n                goto illegal_op;\n            if (s->cpl != 0) {\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n            } else {\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_TR_WRITE);\n                gen_ldst_modrm(s, modrm, OT_WORD, OR_TMP0, 0);\n                gen_jmp_im(pc_start - s->cs_base);\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n                gen_helper_ltr(cpu_tmp2_i32);\n            }\n            break;\n        case 4: /* verr */\n        case 5: /* verw */\n            if (!s->pe || s->vm86)\n                goto illegal_op;\n            gen_ldst_modrm(s, modrm, OT_WORD, OR_TMP0, 0);\n            if (s->cc_op != CC_OP_DYNAMIC)\n                gen_op_set_cc_op(s->cc_op);\n            if (op == 4)\n                gen_helper_verr(cpu_T[0]);\n            else\n                gen_helper_verw(cpu_T[0]);\n            s->cc_op = CC_OP_EFLAGS;\n            break;\n        default:\n            goto illegal_op;\n        }\n        break;\n    case 0x101:\n        modrm = ldub_code(s->pc++);\n        mod = (modrm >> 6) & 3;\n        op = (modrm >> 3) & 7;\n        rm = modrm & 7;\n        switch(op) {\n        case 0: /* sgdt */\n            if (mod == 3)\n                goto illegal_op;\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_GDTR_READ);\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n            tcg_gen_ld32u_tl(cpu_T[0], cpu_env, offsetof(CPUX86State, gdt.limit));\n            gen_op_st_T0_A0(OT_WORD + s->mem_index);\n            gen_add_A0_im(s, 2);\n            tcg_gen_ld_tl(cpu_T[0], cpu_env, offsetof(CPUX86State, gdt.base));\n            if (!s->dflag)\n                gen_op_andl_T0_im(0xffffff);\n            gen_op_st_T0_A0(CODE64(s) + OT_LONG + s->mem_index);\n            break;\n        case 1:\n            if (mod == 3) {\n                switch (rm) {\n                case 0: /* monitor */\n                    if (!(s->cpuid_ext_features & CPUID_EXT_MONITOR) ||\n                        s->cpl != 0)\n                        goto illegal_op;\n                    if (s->cc_op != CC_OP_DYNAMIC)\n                        gen_op_set_cc_op(s->cc_op);\n                    gen_jmp_im(pc_start - s->cs_base);\n#ifdef TARGET_X86_64\n                    if (s->aflag == 2) {\n                        gen_op_movq_A0_reg(R_EAX);\n                    } else\n#endif\n                    {\n                        gen_op_movl_A0_reg(R_EAX);\n                        if (s->aflag == 0)\n                            gen_op_andl_A0_ffff();\n                    }\n                    gen_add_A0_ds_seg(s);\n                    gen_helper_monitor(cpu_A0);\n                    break;\n                case 1: /* mwait */\n                    if (!(s->cpuid_ext_features & CPUID_EXT_MONITOR) ||\n                        s->cpl != 0)\n                        goto illegal_op;\n                    if (s->cc_op != CC_OP_DYNAMIC) {\n                        gen_op_set_cc_op(s->cc_op);\n                        s->cc_op = CC_OP_DYNAMIC;\n                    }\n                    gen_jmp_im(pc_start - s->cs_base);\n                    gen_helper_mwait(tcg_const_i32(s->pc - pc_start));\n                    gen_eob(s);\n                    break;\n                default:\n                    goto illegal_op;\n                }\n            } else { /* sidt */\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_IDTR_READ);\n                gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n                tcg_gen_ld32u_tl(cpu_T[0], cpu_env, offsetof(CPUX86State, idt.limit));\n                gen_op_st_T0_A0(OT_WORD + s->mem_index);\n                gen_add_A0_im(s, 2);\n                tcg_gen_ld_tl(cpu_T[0], cpu_env, offsetof(CPUX86State, idt.base));\n                if (!s->dflag)\n                    gen_op_andl_T0_im(0xffffff);\n                gen_op_st_T0_A0(CODE64(s) + OT_LONG + s->mem_index);\n            }\n            break;\n        case 2: /* lgdt */\n        case 3: /* lidt */\n            if (mod == 3) {\n                if (s->cc_op != CC_OP_DYNAMIC)\n                    gen_op_set_cc_op(s->cc_op);\n                gen_jmp_im(pc_start - s->cs_base);\n                switch(rm) {\n                case 0: /* VMRUN */\n                    if (!(s->flags & HF_SVME_MASK) || !s->pe)\n                        goto illegal_op;\n                    if (s->cpl != 0) {\n                        gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n                        break;\n                    } else {\n                        gen_helper_vmrun(tcg_const_i32(s->aflag),\n                                         tcg_const_i32(s->pc - pc_start));\n                        tcg_gen_exit_tb(0);\n                        s->is_jmp = 3;\n                    }\n                    break;\n                case 1: /* VMMCALL */\n                    if (!(s->flags & HF_SVME_MASK))\n                        goto illegal_op;\n                    gen_helper_vmmcall();\n                    break;\n                case 2: /* VMLOAD */\n                    if (!(s->flags & HF_SVME_MASK) || !s->pe)\n                        goto illegal_op;\n                    if (s->cpl != 0) {\n                        gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n                        break;\n                    } else {\n                        gen_helper_vmload(tcg_const_i32(s->aflag));\n                    }\n                    break;\n                case 3: /* VMSAVE */\n                    if (!(s->flags & HF_SVME_MASK) || !s->pe)\n                        goto illegal_op;\n                    if (s->cpl != 0) {\n                        gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n                        break;\n                    } else {\n                        gen_helper_vmsave(tcg_const_i32(s->aflag));\n                    }\n                    break;\n                case 4: /* STGI */\n                    if ((!(s->flags & HF_SVME_MASK) &&\n                         !(s->cpuid_ext3_features & CPUID_EXT3_SKINIT)) || \n                        !s->pe)\n                        goto illegal_op;\n                    if (s->cpl != 0) {\n                        gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n                        break;\n                    } else {\n                        gen_helper_stgi();\n                    }\n                    break;\n                case 5: /* CLGI */\n                    if (!(s->flags & HF_SVME_MASK) || !s->pe)\n                        goto illegal_op;\n                    if (s->cpl != 0) {\n                        gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n                        break;\n                    } else {\n                        gen_helper_clgi();\n                    }\n                    break;\n                case 6: /* SKINIT */\n                    if ((!(s->flags & HF_SVME_MASK) && \n                         !(s->cpuid_ext3_features & CPUID_EXT3_SKINIT)) || \n                        !s->pe)\n                        goto illegal_op;\n                    gen_helper_skinit();\n                    break;\n                case 7: /* INVLPGA */\n                    if (!(s->flags & HF_SVME_MASK) || !s->pe)\n                        goto illegal_op;\n                    if (s->cpl != 0) {\n                        gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n                        break;\n                    } else {\n                        gen_helper_invlpga(tcg_const_i32(s->aflag));\n                    }\n                    break;\n                default:\n                    goto illegal_op;\n                }\n            } else if (s->cpl != 0) {\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n            } else {\n                gen_svm_check_intercept(s, pc_start,\n                                        op==2 ? SVM_EXIT_GDTR_WRITE : SVM_EXIT_IDTR_WRITE);\n                gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n                gen_op_ld_T1_A0(OT_WORD + s->mem_index);\n                gen_add_A0_im(s, 2);\n                gen_op_ld_T0_A0(CODE64(s) + OT_LONG + s->mem_index);\n                if (!s->dflag)\n                    gen_op_andl_T0_im(0xffffff);\n                if (op == 2) {\n                    tcg_gen_st_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,gdt.base));\n                    tcg_gen_st32_tl(cpu_T[1], cpu_env, offsetof(CPUX86State,gdt.limit));\n                } else {\n                    tcg_gen_st_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,idt.base));\n                    tcg_gen_st32_tl(cpu_T[1], cpu_env, offsetof(CPUX86State,idt.limit));\n                }\n            }\n            break;\n        case 4: /* smsw */\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_READ_CR0);\n#if defined TARGET_X86_64 && defined WORDS_BIGENDIAN\n            tcg_gen_ld32u_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,cr[0]) + 4);\n#else\n            tcg_gen_ld32u_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,cr[0]));\n#endif\n            gen_ldst_modrm(s, modrm, OT_WORD, OR_TMP0, 1);\n            break;\n        case 6: /* lmsw */\n            if (s->cpl != 0) {\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n            } else {\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_CR0);\n                gen_ldst_modrm(s, modrm, OT_WORD, OR_TMP0, 0);\n                gen_helper_lmsw(cpu_T[0]);\n                gen_jmp_im(s->pc - s->cs_base);\n                gen_eob(s);\n            }\n            break;\n        case 7: /* invlpg */\n            if (s->cpl != 0) {\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n            } else {\n                if (mod == 3) {\n#ifdef TARGET_X86_64\n                    if (CODE64(s) && rm == 0) {\n                        /* swapgs */\n                        tcg_gen_ld_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,segs[R_GS].base));\n                        tcg_gen_ld_tl(cpu_T[1], cpu_env, offsetof(CPUX86State,kernelgsbase));\n                        tcg_gen_st_tl(cpu_T[1], cpu_env, offsetof(CPUX86State,segs[R_GS].base));\n                        tcg_gen_st_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,kernelgsbase));\n                    } else\n#endif\n                    {\n                        goto illegal_op;\n                    }\n                } else {\n                    if (s->cc_op != CC_OP_DYNAMIC)\n                        gen_op_set_cc_op(s->cc_op);\n                    gen_jmp_im(pc_start - s->cs_base);\n                    gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n                    gen_helper_invlpg(cpu_A0);\n                    gen_jmp_im(s->pc - s->cs_base);\n                    gen_eob(s);\n                }\n            }\n            break;\n        default:\n            goto illegal_op;\n        }\n        break;\n    case 0x108: /* invd */\n    case 0x109: /* wbinvd */\n        if (s->cpl != 0) {\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n        } else {\n            gen_svm_check_intercept(s, pc_start, (b & 2) ? SVM_EXIT_INVD : SVM_EXIT_WBINVD);\n            /* nothing to do */\n        }\n        break;\n    case 0x63: /* arpl or movslS (x86_64) */\n#ifdef TARGET_X86_64\n        if (CODE64(s)) {\n            int d_ot;\n            /* d_ot is the size of destination */\n            d_ot = dflag + OT_WORD;\n\n            modrm = ldub_code(s->pc++);\n            reg = ((modrm >> 3) & 7) | rex_r;\n            mod = (modrm >> 6) & 3;\n            rm = (modrm & 7) | REX_B(s);\n\n            if (mod == 3) {\n                gen_op_mov_TN_reg(OT_LONG, 0, rm);\n                /* sign extend */\n                if (d_ot == OT_QUAD)\n                    tcg_gen_ext32s_tl(cpu_T[0], cpu_T[0]);\n                gen_op_mov_reg_T0(d_ot, reg);\n            } else {\n                gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n                if (d_ot == OT_QUAD) {\n                    gen_op_lds_T0_A0(OT_LONG + s->mem_index);\n                } else {\n                    gen_op_ld_T0_A0(OT_LONG + s->mem_index);\n                }\n                gen_op_mov_reg_T0(d_ot, reg);\n            }\n        } else\n#endif\n        {\n            int label1;\n            TCGv t0, t1, t2;\n\n            if (!s->pe || s->vm86)\n                goto illegal_op;\n            t0 = tcg_temp_local_new();\n            t1 = tcg_temp_local_new();\n            t2 = tcg_temp_local_new();\n            ot = OT_WORD;\n            modrm = ldub_code(s->pc++);\n            reg = (modrm >> 3) & 7;\n            mod = (modrm >> 6) & 3;\n            rm = modrm & 7;\n            if (mod != 3) {\n                gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n                gen_op_ld_v(ot + s->mem_index, t0, cpu_A0);\n            } else {\n                gen_op_mov_v_reg(ot, t0, rm);\n            }\n            gen_op_mov_v_reg(ot, t1, reg);\n            tcg_gen_andi_tl(cpu_tmp0, t0, 3);\n            tcg_gen_andi_tl(t1, t1, 3);\n            tcg_gen_movi_tl(t2, 0);\n            label1 = gen_new_label();\n            tcg_gen_brcond_tl(TCG_COND_GE, cpu_tmp0, t1, label1);\n            tcg_gen_andi_tl(t0, t0, ~3);\n            tcg_gen_or_tl(t0, t0, t1);\n            tcg_gen_movi_tl(t2, CC_Z);\n            gen_set_label(label1);\n            if (mod != 3) {\n                gen_op_st_v(ot + s->mem_index, t0, cpu_A0);\n            } else {\n                gen_op_mov_reg_v(ot, rm, t0);\n            }\n            if (s->cc_op != CC_OP_DYNAMIC)\n                gen_op_set_cc_op(s->cc_op);\n            gen_compute_eflags(cpu_cc_src);\n            tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, ~CC_Z);\n            tcg_gen_or_tl(cpu_cc_src, cpu_cc_src, t2);\n            s->cc_op = CC_OP_EFLAGS;\n            tcg_temp_free(t0);\n            tcg_temp_free(t1);\n            tcg_temp_free(t2);\n        }\n        break;\n    case 0x102: /* lar */\n    case 0x103: /* lsl */\n        {\n            int label1;\n            TCGv t0;\n            if (!s->pe || s->vm86)\n                goto illegal_op;\n            ot = dflag ? OT_LONG : OT_WORD;\n            modrm = ldub_code(s->pc++);\n            reg = ((modrm >> 3) & 7) | rex_r;\n            gen_ldst_modrm(s, modrm, OT_WORD, OR_TMP0, 0);\n            t0 = tcg_temp_local_new();\n            if (s->cc_op != CC_OP_DYNAMIC)\n                gen_op_set_cc_op(s->cc_op);\n            if (b == 0x102)\n                gen_helper_lar(t0, cpu_T[0]);\n            else\n                gen_helper_lsl(t0, cpu_T[0]);\n            tcg_gen_andi_tl(cpu_tmp0, cpu_cc_src, CC_Z);\n            label1 = gen_new_label();\n            tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_tmp0, 0, label1);\n            gen_op_mov_reg_v(ot, reg, t0);\n            gen_set_label(label1);\n            s->cc_op = CC_OP_EFLAGS;\n            tcg_temp_free(t0);\n        }\n        break;\n    case 0x118:\n        modrm = ldub_code(s->pc++);\n        mod = (modrm >> 6) & 3;\n        op = (modrm >> 3) & 7;\n        switch(op) {\n        case 0: /* prefetchnta */\n        case 1: /* prefetchnt0 */\n        case 2: /* prefetchnt0 */\n        case 3: /* prefetchnt0 */\n            if (mod == 3)\n                goto illegal_op;\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n            /* nothing more to do */\n            break;\n        default: /* nop (multi byte) */\n            gen_nop_modrm(s, modrm);\n            break;\n        }\n        break;\n    case 0x119 ... 0x11f: /* nop (multi byte) */\n        modrm = ldub_code(s->pc++);\n        gen_nop_modrm(s, modrm);\n        break;\n    case 0x120: /* mov reg, crN */\n    case 0x122: /* mov crN, reg */\n        if (s->cpl != 0) {\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n        } else {\n            modrm = ldub_code(s->pc++);\n            if ((modrm & 0xc0) != 0xc0)\n                goto illegal_op;\n            rm = (modrm & 7) | REX_B(s);\n            reg = ((modrm >> 3) & 7) | rex_r;\n            if (CODE64(s))\n                ot = OT_QUAD;\n            else\n                ot = OT_LONG;\n            switch(reg) {\n            case 0:\n            case 2:\n            case 3:\n            case 4:\n            case 8:\n                if (s->cc_op != CC_OP_DYNAMIC)\n                    gen_op_set_cc_op(s->cc_op);\n                gen_jmp_im(pc_start - s->cs_base);\n                if (b & 2) {\n                    gen_op_mov_TN_reg(ot, 0, rm);\n                    gen_helper_write_crN(tcg_const_i32(reg), cpu_T[0]);\n                    gen_jmp_im(s->pc - s->cs_base);\n                    gen_eob(s);\n                } else {\n                    gen_helper_read_crN(cpu_T[0], tcg_const_i32(reg));\n                    gen_op_mov_reg_T0(ot, rm);\n                }\n                break;\n            default:\n                goto illegal_op;\n            }\n        }\n        break;\n    case 0x121: /* mov reg, drN */\n    case 0x123: /* mov drN, reg */\n        if (s->cpl != 0) {\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n        } else {\n            modrm = ldub_code(s->pc++);\n            if ((modrm & 0xc0) != 0xc0)\n                goto illegal_op;\n            rm = (modrm & 7) | REX_B(s);\n            reg = ((modrm >> 3) & 7) | rex_r;\n            if (CODE64(s))\n                ot = OT_QUAD;\n            else\n                ot = OT_LONG;\n            /* XXX: do it dynamically with CR4.DE bit */\n            if (reg == 4 || reg == 5 || reg >= 8)\n                goto illegal_op;\n            if (b & 2) {\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_DR0 + reg);\n                gen_op_mov_TN_reg(ot, 0, rm);\n                gen_helper_movl_drN_T0(tcg_const_i32(reg), cpu_T[0]);\n                gen_jmp_im(s->pc - s->cs_base);\n                gen_eob(s);\n            } else {\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_READ_DR0 + reg);\n                tcg_gen_ld_tl(cpu_T[0], cpu_env, offsetof(CPUX86State,dr[reg]));\n                gen_op_mov_reg_T0(ot, rm);\n            }\n        }\n        break;\n    case 0x106: /* clts */\n        if (s->cpl != 0) {\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n        } else {\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_CR0);\n            gen_helper_clts();\n            /* abort block because static cpu state changed */\n            gen_jmp_im(s->pc - s->cs_base);\n            gen_eob(s);\n        }\n        break;\n    /* MMX/3DNow!/SSE/SSE2/SSE3/SSSE3/SSE4 support */\n    case 0x1c3: /* MOVNTI reg, mem */\n        if (!(s->cpuid_features & CPUID_SSE2))\n            goto illegal_op;\n        ot = s->dflag == 2 ? OT_QUAD : OT_LONG;\n        modrm = ldub_code(s->pc++);\n        mod = (modrm >> 6) & 3;\n        if (mod == 3)\n            goto illegal_op;\n        reg = ((modrm >> 3) & 7) | rex_r;\n        /* generate a generic store */\n        gen_ldst_modrm(s, modrm, ot, reg, 1);\n        break;\n    case 0x1ae:\n        modrm = ldub_code(s->pc++);\n        mod = (modrm >> 6) & 3;\n        op = (modrm >> 3) & 7;\n        switch(op) {\n        case 0: /* fxsave */\n            if (mod == 3 || !(s->cpuid_features & CPUID_FXSR) ||\n                (s->flags & HF_EM_MASK))\n                goto illegal_op;\n            if (s->flags & HF_TS_MASK) {\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n                break;\n            }\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n            if (s->cc_op != CC_OP_DYNAMIC)\n                gen_op_set_cc_op(s->cc_op);\n            gen_jmp_im(pc_start - s->cs_base);\n            gen_helper_fxsave(cpu_A0, tcg_const_i32((s->dflag == 2)));\n            break;\n        case 1: /* fxrstor */\n            if (mod == 3 || !(s->cpuid_features & CPUID_FXSR) ||\n                (s->flags & HF_EM_MASK))\n                goto illegal_op;\n            if (s->flags & HF_TS_MASK) {\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n                break;\n            }\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n            if (s->cc_op != CC_OP_DYNAMIC)\n                gen_op_set_cc_op(s->cc_op);\n            gen_jmp_im(pc_start - s->cs_base);\n            gen_helper_fxrstor(cpu_A0, tcg_const_i32((s->dflag == 2)));\n            break;\n        case 2: /* ldmxcsr */\n        case 3: /* stmxcsr */\n            if (s->flags & HF_TS_MASK) {\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n                break;\n            }\n            if ((s->flags & HF_EM_MASK) || !(s->flags & HF_OSFXSR_MASK) ||\n                mod == 3)\n                goto illegal_op;\n            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n            if (op == 2) {\n                gen_op_ld_T0_A0(OT_LONG + s->mem_index);\n                tcg_gen_st32_tl(cpu_T[0], cpu_env, offsetof(CPUX86State, mxcsr));\n            } else {\n                tcg_gen_ld32u_tl(cpu_T[0], cpu_env, offsetof(CPUX86State, mxcsr));\n                gen_op_st_T0_A0(OT_LONG + s->mem_index);\n            }\n            break;\n        case 5: /* lfence */\n        case 6: /* mfence */\n            if ((modrm & 0xc7) != 0xc0 || !(s->cpuid_features & CPUID_SSE))\n                goto illegal_op;\n            break;\n        case 7: /* sfence / clflush */\n            if ((modrm & 0xc7) == 0xc0) {\n                /* sfence */\n                /* XXX: also check for cpuid_ext2_features & CPUID_EXT2_EMMX */\n                if (!(s->cpuid_features & CPUID_SSE))\n                    goto illegal_op;\n            } else {\n                /* clflush */\n                if (!(s->cpuid_features & CPUID_CLFLUSH))\n                    goto illegal_op;\n                gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n            }\n            break;\n        default:\n            goto illegal_op;\n        }\n        break;\n    case 0x10d: /* 3DNow! prefetch(w) */\n        modrm = ldub_code(s->pc++);\n        mod = (modrm >> 6) & 3;\n        if (mod == 3)\n            goto illegal_op;\n        gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);\n        /* ignore for now */\n        break;\n    case 0x1aa: /* rsm */\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_RSM);\n        if (!(s->flags & HF_SMM_MASK))\n            goto illegal_op;\n        if (s->cc_op != CC_OP_DYNAMIC) {\n            gen_op_set_cc_op(s->cc_op);\n            s->cc_op = CC_OP_DYNAMIC;\n        }\n        gen_jmp_im(s->pc - s->cs_base);\n        gen_helper_rsm();\n        gen_eob(s);\n        break;\n    case 0x1b8: /* SSE4.2 popcnt */\n        if ((prefixes & (PREFIX_REPZ | PREFIX_LOCK | PREFIX_REPNZ)) !=\n             PREFIX_REPZ)\n            goto illegal_op;\n        if (!(s->cpuid_ext_features & CPUID_EXT_POPCNT))\n            goto illegal_op;\n\n        modrm = ldub_code(s->pc++);\n        reg = ((modrm >> 3) & 7);\n\n        if (s->prefix & PREFIX_DATA)\n            ot = OT_WORD;\n        else if (s->dflag != 2)\n            ot = OT_LONG;\n        else\n            ot = OT_QUAD;\n\n        gen_ldst_modrm(s, modrm, ot, OR_TMP0, 0);\n        gen_helper_popcnt(cpu_T[0], cpu_T[0], tcg_const_i32(ot));\n        gen_op_mov_reg_T0(ot, reg);\n\n        s->cc_op = CC_OP_EFLAGS;\n        break;\n    case 0x10e ... 0x10f:\n        /* 3DNow! instructions, ignore prefixes */\n        s->prefix &= ~(PREFIX_REPZ | PREFIX_REPNZ | PREFIX_DATA);\n    case 0x110 ... 0x117:\n    case 0x128 ... 0x12f:\n    case 0x138 ... 0x13a:\n    case 0x150 ... 0x177:\n    case 0x17c ... 0x17f:\n    case 0x1c2:\n    case 0x1c4 ... 0x1c6:\n    case 0x1d0 ... 0x1fe:\n        gen_sse(s, b, pc_start, rex_r);\n        break;\n    default:\n        goto illegal_op;\n    }\n    /* lock generation */\n    if (s->prefix & PREFIX_LOCK)\n        gen_helper_unlock();\n    return s->pc;\n illegal_op:\n    if (s->prefix & PREFIX_LOCK)\n        gen_helper_unlock();\n    /* XXX: ensure that no lock was generated */\n    gen_exception(s, EXCP06_ILLOP, pc_start - s->cs_base);\n    return s->pc;\n}", "path": "target-i386\\translate.c", "repo_name": "horms/qemu-xen-3.4-testing", "stars": 1, "license": "other", "language": "c", "size": 19844}
{"docstring": "/* return true if setcc_slow is not needed (WARNING: must be kept in\n   sync with gen_jcc1) */\n", "func_signal": "static int is_fast_jcc_case(DisasContext *s, int b)", "code": "{\n    int jcc_op;\n    jcc_op = (b >> 1) & 7;\n    switch(s->cc_op) {\n        /* we optimize the cmp/jcc case */\n    case CC_OP_SUBB:\n    case CC_OP_SUBW:\n    case CC_OP_SUBL:\n    case CC_OP_SUBQ:\n        if (jcc_op == JCC_O || jcc_op == JCC_P)\n            goto slow_jcc;\n        break;\n\n        /* some jumps are easy to compute */\n    case CC_OP_ADDB:\n    case CC_OP_ADDW:\n    case CC_OP_ADDL:\n    case CC_OP_ADDQ:\n\n    case CC_OP_LOGICB:\n    case CC_OP_LOGICW:\n    case CC_OP_LOGICL:\n    case CC_OP_LOGICQ:\n\n    case CC_OP_INCB:\n    case CC_OP_INCW:\n    case CC_OP_INCL:\n    case CC_OP_INCQ:\n\n    case CC_OP_DECB:\n    case CC_OP_DECW:\n    case CC_OP_DECL:\n    case CC_OP_DECQ:\n\n    case CC_OP_SHLB:\n    case CC_OP_SHLW:\n    case CC_OP_SHLL:\n    case CC_OP_SHLQ:\n        if (jcc_op != JCC_Z && jcc_op != JCC_S)\n            goto slow_jcc;\n        break;\n    default:\n    slow_jcc:\n        return 0;\n    }\n    return 1;\n}", "path": "target-i386\\translate.c", "repo_name": "horms/qemu-xen-3.4-testing", "stars": 1, "license": "other", "language": "c", "size": 19844}
{"docstring": "/* generate modrm memory load or store of 'reg'. TMP0 is used if reg ==\n   OR_TMP0 */\n", "func_signal": "static void gen_ldst_modrm(DisasContext *s, int modrm, int ot, int reg, int is_store)", "code": "{\n    int mod, rm, opreg, disp;\n\n    mod = (modrm >> 6) & 3;\n    rm = (modrm & 7) | REX_B(s);\n    if (mod == 3) {\n        if (is_store) {\n            if (reg != OR_TMP0)\n                gen_op_mov_TN_reg(ot, 0, reg);\n            gen_op_mov_reg_T0(ot, rm);\n        } else {\n            gen_op_mov_TN_reg(ot, 0, rm);\n            if (reg != OR_TMP0)\n                gen_op_mov_reg_T0(ot, reg);\n        }\n    } else {\n        gen_lea_modrm(s, modrm, &opreg, &disp);\n        if (is_store) {\n            if (reg != OR_TMP0)\n                gen_op_mov_TN_reg(ot, 0, reg);\n            gen_op_st_T0_A0(ot + s->mem_index);\n        } else {\n            gen_op_ld_T0_A0(ot + s->mem_index);\n            if (reg != OR_TMP0)\n                gen_op_mov_reg_T0(ot, reg);\n        }\n    }\n}", "path": "target-i386\\translate.c", "repo_name": "horms/qemu-xen-3.4-testing", "stars": 1, "license": "other", "language": "c", "size": 19844}
{"docstring": "/* if d == OR_TMP0, it means memory operand (address in A0) */\n", "func_signal": "static void gen_op(DisasContext *s1, int op, int ot, int d)", "code": "{\n    if (d != OR_TMP0) {\n        gen_op_mov_TN_reg(ot, 0, d);\n    } else {\n        gen_op_ld_T0_A0(ot + s1->mem_index);\n    }\n    switch(op) {\n    case OP_ADCL:\n        if (s1->cc_op != CC_OP_DYNAMIC)\n            gen_op_set_cc_op(s1->cc_op);\n        gen_compute_eflags_c(cpu_tmp4);\n        tcg_gen_add_tl(cpu_T[0], cpu_T[0], cpu_T[1]);\n        tcg_gen_add_tl(cpu_T[0], cpu_T[0], cpu_tmp4);\n        if (d != OR_TMP0)\n            gen_op_mov_reg_T0(ot, d);\n        else\n            gen_op_st_T0_A0(ot + s1->mem_index);\n        tcg_gen_mov_tl(cpu_cc_src, cpu_T[1]);\n        tcg_gen_mov_tl(cpu_cc_dst, cpu_T[0]);\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_tmp4);\n        tcg_gen_shli_i32(cpu_tmp2_i32, cpu_tmp2_i32, 2);\n        tcg_gen_addi_i32(cpu_cc_op, cpu_tmp2_i32, CC_OP_ADDB + ot);\n        s1->cc_op = CC_OP_DYNAMIC;\n        break;\n    case OP_SBBL:\n        if (s1->cc_op != CC_OP_DYNAMIC)\n            gen_op_set_cc_op(s1->cc_op);\n        gen_compute_eflags_c(cpu_tmp4);\n        tcg_gen_sub_tl(cpu_T[0], cpu_T[0], cpu_T[1]);\n        tcg_gen_sub_tl(cpu_T[0], cpu_T[0], cpu_tmp4);\n        if (d != OR_TMP0)\n            gen_op_mov_reg_T0(ot, d);\n        else\n            gen_op_st_T0_A0(ot + s1->mem_index);\n        tcg_gen_mov_tl(cpu_cc_src, cpu_T[1]);\n        tcg_gen_mov_tl(cpu_cc_dst, cpu_T[0]);\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_tmp4);\n        tcg_gen_shli_i32(cpu_tmp2_i32, cpu_tmp2_i32, 2);\n        tcg_gen_addi_i32(cpu_cc_op, cpu_tmp2_i32, CC_OP_SUBB + ot);\n        s1->cc_op = CC_OP_DYNAMIC;\n        break;\n    case OP_ADDL:\n        gen_op_addl_T0_T1();\n        if (d != OR_TMP0)\n            gen_op_mov_reg_T0(ot, d);\n        else\n            gen_op_st_T0_A0(ot + s1->mem_index);\n        gen_op_update2_cc();\n        s1->cc_op = CC_OP_ADDB + ot;\n        break;\n    case OP_SUBL:\n        tcg_gen_sub_tl(cpu_T[0], cpu_T[0], cpu_T[1]);\n        if (d != OR_TMP0)\n            gen_op_mov_reg_T0(ot, d);\n        else\n            gen_op_st_T0_A0(ot + s1->mem_index);\n        gen_op_update2_cc();\n        s1->cc_op = CC_OP_SUBB + ot;\n        break;\n    default:\n    case OP_ANDL:\n        tcg_gen_and_tl(cpu_T[0], cpu_T[0], cpu_T[1]);\n        if (d != OR_TMP0)\n            gen_op_mov_reg_T0(ot, d);\n        else\n            gen_op_st_T0_A0(ot + s1->mem_index);\n        gen_op_update1_cc();\n        s1->cc_op = CC_OP_LOGICB + ot;\n        break;\n    case OP_ORL:\n        tcg_gen_or_tl(cpu_T[0], cpu_T[0], cpu_T[1]);\n        if (d != OR_TMP0)\n            gen_op_mov_reg_T0(ot, d);\n        else\n            gen_op_st_T0_A0(ot + s1->mem_index);\n        gen_op_update1_cc();\n        s1->cc_op = CC_OP_LOGICB + ot;\n        break;\n    case OP_XORL:\n        tcg_gen_xor_tl(cpu_T[0], cpu_T[0], cpu_T[1]);\n        if (d != OR_TMP0)\n            gen_op_mov_reg_T0(ot, d);\n        else\n            gen_op_st_T0_A0(ot + s1->mem_index);\n        gen_op_update1_cc();\n        s1->cc_op = CC_OP_LOGICB + ot;\n        break;\n    case OP_CMPL:\n        gen_op_cmpl_T0_T1_cc();\n        s1->cc_op = CC_OP_SUBB + ot;\n        break;\n    }\n}", "path": "target-i386\\translate.c", "repo_name": "horms/qemu-xen-3.4-testing", "stars": 1, "license": "other", "language": "c", "size": 19844}
{"docstring": "/* move T0 to seg_reg and compute if the CPU state may change. Never\n   call this function with seg_reg == R_CS */\n", "func_signal": "static void gen_movl_seg_T0(DisasContext *s, int seg_reg, target_ulong cur_eip)", "code": "{\n    if (s->pe && !s->vm86) {\n        /* XXX: optimize by finding processor state dynamically */\n        if (s->cc_op != CC_OP_DYNAMIC)\n            gen_op_set_cc_op(s->cc_op);\n        gen_jmp_im(cur_eip);\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);\n        gen_helper_load_seg(tcg_const_i32(seg_reg), cpu_tmp2_i32);\n        /* abort translation because the addseg value may change or\n           because ss32 may change. For R_SS, translation must always\n           stop as a special handling must be done to disable hardware\n           interrupts for the next instruction */\n        if (seg_reg == R_SS || (s->code32 && seg_reg < R_FS))\n            s->is_jmp = 3;\n    } else {\n        gen_op_movl_seg_T0_vm(seg_reg);\n        if (seg_reg == R_SS)\n            s->is_jmp = 3;\n    }\n}", "path": "target-i386\\translate.c", "repo_name": "horms/qemu-xen-3.4-testing", "stars": 1, "license": "other", "language": "c", "size": 19844}
{"docstring": "/* used for LEA and MOV AX, mem */\n", "func_signal": "static void gen_add_A0_ds_seg(DisasContext *s)", "code": "{\n    int override, must_add_seg;\n    must_add_seg = s->addseg;\n    override = R_DS;\n    if (s->override >= 0) {\n        override = s->override;\n        must_add_seg = 1;\n    } else {\n        override = R_DS;\n    }\n    if (must_add_seg) {\n#ifdef TARGET_X86_64\n        if (CODE64(s)) {\n            gen_op_addq_A0_seg(override);\n        } else\n#endif\n        {\n            gen_op_addl_A0_seg(override);\n        }\n    }\n}", "path": "target-i386\\translate.c", "repo_name": "horms/qemu-xen-3.4-testing", "stars": 1, "license": "other", "language": "c", "size": 19844}
{"docstring": "/************************************************************************/\n/*                                main()                                */\n/************************************************************************/\n", "func_signal": "int main(int argc, char **argv)", "code": "{\n    char *arg, **eargv = argv, *from_argv[MAX_PARGS], *to_argv[MAX_PARGS],\n        **iargv = argv;\n    FILE *fid;\n    int from_argc=0, to_argc=0, iargc = argc, eargc = 0, c, mon = 0;\n    int have_to_flag = 0, inverse = 0, i;\n\n    if (emess_dat.Prog_name = strrchr(*argv,DIR_CHAR))\n        ++emess_dat.Prog_name;\n    else emess_dat.Prog_name = *argv;\n    inverse = ! strncmp(emess_dat.Prog_name, \"inv\", 3);\n    if (argc <= 1 ) {\n        (void)fprintf(stderr, usage, pj_get_release(), emess_dat.Prog_name);\n        exit (0);\n    }\n    /* process run line arguments */\n    while (--argc > 0) { /* collect run line arguments */\n        if(**++argv == '-') for(arg = *argv;;) {\n            switch(*++arg) {\n              case '\\0': /* position of \"stdin\" */\n                if (arg[-1] == '-') eargv[eargc++] = \"-\";\n                break;\n              case 'v': /* monitor dump of initialization */\n                mon = 1;\n                continue;\n              case 'I': /* alt. method to spec inverse */\n                inverse = 1;\n                continue;\n              case 'E': /* echo ascii input to ascii output */\n                echoin = 1;\n                continue;\n              case 't': /* set col. one char */\n                if (arg[1]) tag = *++arg;\n                else emess(1,\"missing -t col. 1 tag\");\n                continue;\n              case 'l': /* list projections, ellipses or units */\n                if (!arg[1] || arg[1] == 'p' || arg[1] == 'P') {\n                    /* list projections */\n                    struct PJ_LIST *lp;\n                    int do_long = arg[1] == 'P', c;\n                    char *str;\n\n                    for (lp = pj_get_list_ref() ; lp->id ; ++lp) {\n                        (void)printf(\"%s : \", lp->id);\n                        if (do_long)  /* possibly multiline description */\n                            (void)puts(*lp->descr);\n                        else { /* first line, only */\n                            str = *lp->descr;\n                            while ((c = *str++) && c != '\\n')\n                                putchar(c);\n                            putchar('\\n');\n                        }\n                    }\n                } else if (arg[1] == '=') { /* list projection 'descr' */\n                    struct PJ_LIST *lp;\n\n                    arg += 2;\n                    for (lp = pj_get_list_ref() ; lp->id ; ++lp)\n                        if (!strcmp(lp->id, arg)) {\n                            (void)printf(\"%9s : %s\\n\", lp->id, *lp->descr);\n                            break;\n                        }\n                } else if (arg[1] == 'e') { /* list ellipses */\n                    struct PJ_ELLPS *le;\n\n                    for (le = pj_get_ellps_ref(); le->id ; ++le)\n                        (void)printf(\"%9s %-16s %-16s %s\\n\",\n                                     le->id, le->major, le->ell, le->name);\n                } else if (arg[1] == 'u') { /* list units */\n                    struct PJ_UNITS *lu;\n\n                    for (lu = pj_get_units_ref(); lu->id ; ++lu)\n                        (void)printf(\"%12s %-20s %s\\n\",\n                                     lu->id, lu->to_meter, lu->name);\n                } else if (arg[1] == 'd') { /* list datums */\n                    struct PJ_DATUMS *ld;\n\n                    printf(\"__datum_id__ __ellipse___ __definition/comments______________________________\\n\" );\n                    for (ld = pj_get_datums_ref(); ld->id ; ++ld)\n                    {\n                        printf(\"%12s %-12s %-30s\\n\",\n                               ld->id, ld->ellipse_id, ld->defn);\n                        if( ld->comments != NULL && strlen(ld->comments) > 0 )\n                            printf( \"%25s %s\\n\", \" \", ld->comments );\n                    }\n                } else if( arg[1] == 'm') { /* list prime meridians */\n                    struct PJ_PRIME_MERIDIANS *lpm;\n\n                    for (lpm = pj_get_prime_meridians_ref(); lpm->id ; ++lpm)\n                        (void)printf(\"%12s %-30s\\n\",\n                                     lpm->id, lpm->defn);\n                } else\n                    emess(1,\"invalid list option: l%c\",arg[1]);\n                exit(0);\n                continue; /* artificial */\n              case 'e': /* error line alternative */\n                if (--argc <= 0)\n                    noargument:\t\t\t   \n                emess(1,\"missing argument for -%c\",*arg);\n                oterr = *++argv;\n                continue;\n              case 'W': /* specify seconds precision */\n              case 'w': /* -W for constant field width */\n                if ((c = arg[1]) != 0 && isdigit(c)) {\n                    set_rtodms(c - '0', *arg == 'W');\n                    ++arg;\n                } else\n                    emess(1,\"-W argument missing or non-digit\");\n                continue;\n              case 'f': /* alternate output format degrees or xy */\n                if (--argc <= 0) goto noargument;\n                oform = *++argv;\n                continue;\n              case 'r': /* reverse input */\n                reversein = 1;\n                continue;\n              case 's': /* reverse output */\n                reverseout = 1;\n                continue;\n              default:\n                emess(1, \"invalid option: -%c\",*arg);\n                break;\n            }\n            break;\n\n        } else if (strcmp(*argv,\"+to\") == 0 ) {\n            have_to_flag = 1;\n\n        } else if (**argv == '+') { /* + argument */\n            if( have_to_flag )\n            {\n                if( to_argc < MAX_PARGS )\n                    to_argv[to_argc++] = *argv + 1;\n                else\n                    emess(1,\"overflowed + argument table\");\n            }\n            else \n            {\n                if (from_argc < MAX_PARGS)\n                    from_argv[from_argc++] = *argv + 1;\n                else\n                    emess(1,\"overflowed + argument table\");\n            }\n        } else /* assumed to be input file name(s) */\n            eargv[eargc++] = *argv;\n    }\n    if (eargc == 0 ) /* if no specific files force sysin */\n        eargv[eargc++] = \"-\";\n\n    /* \n     * If the user has requested inverse, then just reverse the\n     * coordinate systems.\n     */\n    if( inverse )\n    {\n        int     argcount;\n        \n        for( i = 0; i < MAX_PARGS; i++ )\n        {\n            char *arg;\n\n            arg = from_argv[i];\n            from_argv[i] = to_argv[i];\n            to_argv[i] = arg;\n        }\n\n        argcount = from_argc;\n        from_argc = to_argc;\n        to_argc = argcount;\n    }\n\n    if (!(fromProj = pj_init(from_argc, from_argv)))\n    {\n        printf( \"Using from definition: \" );\n        for( i = 0; i < from_argc; i++ )\n            printf( \"%s \", from_argv[i] );\n        printf( \"\\n\" );\n\n        emess(3,\"projection initialization failure\\ncause: %s\",\n              pj_strerrno(pj_errno));\n    }\n\n    if( to_argc == 0 )\n    {\n        if (!(toProj = pj_latlong_from_proj( fromProj )))\n        {\n            printf( \"Using to definition: \" );\n            for( i = 0; i < to_argc; i++ )\n                printf( \"%s \", to_argv[i] );\n            printf( \"\\n\" );\n            \n            emess(3,\"projection initialization failure\\ncause: %s\",\n                  pj_strerrno(pj_errno));\n        }   \n    }\n    else if (!(toProj = pj_init(to_argc, to_argv)))\n    {\n        printf( \"Using to definition: \" );\n        for( i = 0; i < to_argc; i++ )\n            printf( \"%s \", to_argv[i] );\n        printf( \"\\n\" );\n\n        emess(3,\"projection initialization failure\\ncause: %s\",\n              pj_strerrno(pj_errno));\n    }\n\n    if (mon) {\n        printf( \"%c ---- From Coordinate System ----\\n\", tag );\n        pj_pr_list(fromProj);\n        printf( \"%c ---- To Coordinate System ----\\n\", tag );\n        pj_pr_list(toProj);\n    }\n\n    /* set input formating control */\n    if( !fromProj->is_latlong )\n        informat = strtod;\n    else {\n        informat = dmstor;\n    }\n\n    if( !toProj->is_latlong && !oform )\n        oform = \"%.2f\";\n\n    /* process input file list */\n    for ( ; eargc-- ; ++eargv) {\n        if (**eargv == '-') {\n            fid = stdin;\n            emess_dat.File_name = \"<stdin>\";\n\n        } else {\n            if ((fid = fopen(*eargv, \"rt\")) == NULL) {\n                emess(-2, *eargv, \"input file\");\n                continue;\n            }\n            emess_dat.File_name = *eargv;\n        }\n        emess_dat.File_line = 0;\n        process(fid);\n        fclose(fid);\n        emess_dat.File_name = 0;\n    }\n\n    if( fromProj != NULL )\n        pj_free( fromProj );\n    if( toProj != NULL )\n        pj_free( toProj );\n\n    pj_deallocate_grids();\n\n    exit(0); /* normal completion */\n}", "path": "src\\cs2cs.c", "repo_name": "h4ck3rm1k3/ProjC--", "stars": 1, "license": "other", "language": "c", "size": 6532}
{"docstring": "/* END OF Get_Geocentric_Parameters */\n", "func_signal": "long pj_Convert_Geodetic_To_Geocentric (GeocentricInfo *gi,\n                                        double Latitude,\n                                        double Longitude,\n                                        double Height,\n                                        double *X,\n                                        double *Y,\n                                        double *Z)", "code": "{ /* BEGIN Convert_Geodetic_To_Geocentric */\n/*\n * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates\n * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),\n * according to the current ellipsoid parameters.\n *\n *    Latitude  : Geodetic latitude in radians                     (input)\n *    Longitude : Geodetic longitude in radians                    (input)\n *    Height    : Geodetic height, in meters                       (input)\n *    X         : Calculated Geocentric X coordinate, in meters    (output)\n *    Y         : Calculated Geocentric Y coordinate, in meters    (output)\n *    Z         : Calculated Geocentric Z coordinate, in meters    (output)\n *\n */\n  long Error_Code = GEOCENT_NO_ERROR;\n  double Rn;            /*  Earth radius at location  */\n  double Sin_Lat;       /*  sin(Latitude)  */\n  double Sin2_Lat;      /*  Square of sin(Latitude)  */\n  double Cos_Lat;       /*  cos(Latitude)  */\n\n  /*\n  ** Don't blow up if Latitude is just a little out of the value\n  ** range as it may just be a rounding issue.  Also removed longitude\n  ** test, it should be wrapped by cos() and sin().  NFW for PROJ.4, Sep/2001.\n  */\n  if( Latitude < -PI_OVER_2 && Latitude > -1.001 * PI_OVER_2 )\n      Latitude = -PI_OVER_2;\n  else if( Latitude > PI_OVER_2 && Latitude < 1.001 * PI_OVER_2 )\n      Latitude = PI_OVER_2;\n  else if ((Latitude < -PI_OVER_2) || (Latitude > PI_OVER_2))\n  { /* Latitude out of range */\n    Error_Code |= GEOCENT_LAT_ERROR;\n  }\n\n  if (!Error_Code)\n  { /* no errors */\n    if (Longitude > PI)\n      Longitude -= (2*PI);\n    Sin_Lat = sin(Latitude);\n    Cos_Lat = cos(Latitude);\n    Sin2_Lat = Sin_Lat * Sin_Lat;\n    Rn = gi->Geocent_a / (sqrt(1.0e0 - gi->Geocent_e2 * Sin2_Lat));\n    *X = (Rn + Height) * Cos_Lat * cos(Longitude);\n    *Y = (Rn + Height) * Cos_Lat * sin(Longitude);\n    *Z = ((Rn * (1 - gi->Geocent_e2)) + Height) * Sin_Lat;\n\n  }\n  return (Error_Code);\n}", "path": "src\\geocent.c", "repo_name": "h4ck3rm1k3/ProjC--", "stars": 1, "license": "other", "language": "c", "size": 6532}
{"docstring": "/*!\n * \\brief\n * executes reprojection \n * \n * JNI informations:\n * Class:     org_proj4_Projections\n * Method:    transform\n * Signature: ([D[D[DLjava/lang/String;Ljava/lang/String;JI)V\n * \n *\n * \\param env - parameter used by jni (see JNI specification)\n * \\param parent - parameter used by jni (see JNI specification)\n * \\param firstcoord - array of x coordinates\n * \\param secondcoord - array of y coordinates\n * \\param values - array of z coordinates\n * \\param src - definition of the source projection\n * \\param dest - definition of the destination projection\n * \\param pcount\n * \\param poffset\n*/\n", "func_signal": "JNIEXPORT void JNICALL Java_org_proj4_Projections_transform\n  (JNIEnv * env, jobject parent, jdoubleArray firstcoord, jdoubleArray secondcoord, jdoubleArray values, jstring src, jstring dest, jlong pcount, jint poffset)", "code": "{\n\tint i;\n\tprojPJ src_pj, dst_pj;\n\tchar * srcproj_def = (char *) (*env)->GetStringUTFChars (env, src, 0); \n\tchar * destproj_def = (char *) (*env)->GetStringUTFChars (env, dest, 0);\n\n\tif (!(src_pj = pj_init_plus(srcproj_def)))\n\t\texit(1);\n\tif (!(dst_pj = pj_init_plus(destproj_def)))\n\t\texit(1);\n\n\tdouble *xcoord = (* env)-> GetDoubleArrayElements(env, firstcoord, NULL); \n\tdouble *ycoord = (* env) -> GetDoubleArrayElements(env, secondcoord, NULL); \n\tdouble *zcoord = (* env) -> GetDoubleArrayElements(env, values, NULL); \n\n        pj_transform( src_pj, dst_pj, pcount,poffset, xcoord, ycoord, zcoord);\n\n\t(* env)->ReleaseDoubleArrayElements(env,firstcoord,(jdouble *) xcoord,JNI_COMMIT);\n\t(* env)->ReleaseDoubleArrayElements(env,secondcoord,(jdouble *) ycoord,JNI_COMMIT);\n\t(* env)->ReleaseDoubleArrayElements(env,values,(jdouble *) zcoord,JNI_COMMIT);\n\n\tpj_free( src_pj );\n\tpj_free( dst_pj );\n}", "path": "src\\jniproj.c", "repo_name": "h4ck3rm1k3/ProjC--", "stars": 1, "license": "other", "language": "c", "size": 6532}
{"docstring": "/************************************************************************/\n/*                        pj_deallocate_grids()                         */\n/*                                                                      */\n/*      Deallocate all loaded grids.                                    */\n/************************************************************************/\n", "func_signal": "void pj_deallocate_grids()", "code": "{\n    while( grid_list != NULL )\n    {\n        PJ_GRIDINFO *item = grid_list;\n        grid_list = grid_list->next;\n        item->next = NULL;\n\n        pj_gridinfo_free( item );\n    }\n\n    if( last_nadgrids != NULL )\n    {\n        pj_dalloc( last_nadgrids );\n        last_nadgrids = NULL;\n\n        pj_dalloc( last_nadgrids_list );\n        last_nadgrids_list = NULL;\n\n        last_nadgrids_count = 0;\n        last_nadgrids_max = 0;\n    }\n}", "path": "src\\pj_gridlist.c", "repo_name": "h4ck3rm1k3/ProjC--", "stars": 1, "license": "other", "language": "c", "size": 6532}
{"docstring": "/* note: coefficients are always from C_1 to C_n\n**\ti.e. C_0 == (0., 0)\n**\tn should always be >= 1 though no checks are made\n*/\n", "func_signal": "COMPLEX\npj_zpoly1(COMPLEX z, COMPLEX *C, int n)", "code": "{\n\tCOMPLEX a;\n\tdouble t;\n\n\ta = *(C += n);\n\twhile (n-- > 0) {\n\t\ta.r = (--C)->r + z.r * (t = a.r) - z.i * a.i;\n\t\ta.i = C->i + z.r * a.i + z.i * t;\n\t}\n\ta.r = z.r * (t = a.r) - z.i * a.i;\n\ta.i = z.r * a.i + z.i * t;\n\treturn a;\n}", "path": "src\\pj_zpoly1.c", "repo_name": "h4ck3rm1k3/ProjC--", "stars": 1, "license": "other", "language": "c", "size": 6532}
{"docstring": "/*!\n * \\brief\n * retrieves projection parameters\n * \n * JNI informations:\n * Class:     org_proj4_Projections\n * Method:    getProjInfo\n * Signature: (Ljava/lang/String;)Ljava/lang/String;\n * \n *\n * \\param env - parameter used by jni (see JNI specification)\n * \\param parent - parameter used by jni (see JNI specification)\n * \\param projdefinition - definition of the projection\n*/\n", "func_signal": "JNIEXPORT jstring JNICALL Java_org_proj4_Projections_getProjInfo\n  (JNIEnv * env, jobject parent, jstring projdefinition)", "code": "{\n\tPJ *pj;\n\tchar * pjdesc;\n\tchar info[arraysize];\n\t\n\tchar * proj_def = (char *) (*env)->GetStringUTFChars (env, projdefinition, 0);\n\t\n\tif (!(pj = pj_init_plus(proj_def)))\n\t\texit(1);\n\t\n\t// put together all the info of the projection and free the pointer to pjdesc\n\tpjdesc = pj_get_def(pj, 0);\n\tstrcpy(info,pjdesc);\n\tpj_dalloc(pjdesc);\n\t\n\treturn (*env)->NewStringUTF(env,info); \n}", "path": "src\\jniproj.c", "repo_name": "h4ck3rm1k3/ProjC--", "stars": 1, "license": "other", "language": "c", "size": 6532}
{"docstring": "/* print link list of projection parameters */\n", "func_signal": "pj_pr_list(PJ *P)", "code": "{\n\tchar const *s;\n\n\t(void)putchar('#');\n\tfor (s = P->descr; *s ; ++s) {\n\t\t(void)putchar(*s);\n\t\tif (*s == '\\n')\n\t\t\t(void)putchar('#');\n\t}\n\t(void)putchar('\\n');\n\tif (pr_list(P, 0)) {\n\t\t(void)fputs(\"#--- following specified but NOT used\\n\", stdout);\n\t\t(void)pr_list(P, 1);\n\t}\n}", "path": "src\\pj_pr_list.c", "repo_name": "h4ck3rm1k3/ProjC--", "stars": 1, "license": "other", "language": "c", "size": 6532}
{"docstring": "/************************************************************************/\n/*                     pj_gridlist_from_nadgrids()                      */\n/*                                                                      */\n/*      This functions loads the list of grids corresponding to a       */\n/*      particular nadgrids string into a list, and returns it.  The    */\n/*      list is kept around till a request is made with a different     */\n/*      string in order to cut down on the string parsing cost, and     */\n/*      the cost of building the list of tables each time.              */\n/************************************************************************/\n", "func_signal": "PJ_GRIDINFO **pj_gridlist_from_nadgrids( const char *nadgrids, int *grid_count)", "code": "{\n    const char *s;\n\n    pj_errno = 0;\n    *grid_count = 0;\n\n    pj_acquire_lock();\n    if( last_nadgrids != NULL \n        && strcmp(nadgrids,last_nadgrids) == 0 )\n    {\n        PJ_GRIDINFO **ret = last_nadgrids_list;\n        *grid_count = last_nadgrids_count;\n        if( *grid_count == 0 )\n            pj_errno = -38;\n\n        pj_release_lock();\n        return ret;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Free old one, if any, and make space for new list.              */\n/* -------------------------------------------------------------------- */\n    if( last_nadgrids != NULL )\n    {\n        pj_dalloc(last_nadgrids);\n    }\n    \n    last_nadgrids = (char *) pj_malloc(strlen(nadgrids)+1);\n    strcpy( last_nadgrids, nadgrids );\n\n    last_nadgrids_count = 0;\n\n/* -------------------------------------------------------------------- */\n/*      Loop processing names out of nadgrids one at a time.            */\n/* -------------------------------------------------------------------- */\n    for( s = nadgrids; *s != '\\0'; )\n    {\n        int   end_char;\n        int   required = 1;\n        char  name[128];\n\n        if( *s == '@' )\n        {\n            required = 0;\n            s++;\n        }\n\n        for( end_char = 0; \n             s[end_char] != '\\0' && s[end_char] != ','; \n             end_char++ ) {}\n\n        if( end_char > sizeof(name) )\n        {\n            pj_errno = -38;\n            pj_release_lock();\n            return NULL;\n        }\n        \n        strncpy( name, s, end_char );\n        name[end_char] = '\\0';\n\n        s += end_char;\n        if( *s == ',' )\n            s++;\n\n        if( !pj_gridlist_merge_gridfile( name ) && required )\n        {\n            pj_errno = -38;\n            pj_release_lock();\n            return NULL;\n        }\n        else\n            pj_errno = 0;\n    }\n\n    if( last_nadgrids_count > 0 )\n    {\n        PJ_GRIDINFO **ret = last_nadgrids_list;\n        *grid_count = last_nadgrids_count;\n        pj_release_lock();\n        return ret;\n    }\n    else\n    {\n        pj_release_lock();\n        return NULL;\n    }\n}", "path": "src\\pj_gridlist.c", "repo_name": "h4ck3rm1k3/ProjC--", "stars": 1, "license": "other", "language": "c", "size": 6532}
{"docstring": "/* file processing function */\n", "func_signal": "process(FILE *fid)", "code": "{\n\tchar line[MAXLINE+3], *s;\n\n\tfor (;;) {\n\t\t++emess_dat.File_line;\n\t\tif (!(s = fgets(line, MAXLINE, fid)))\n\t\t\tbreak;\n\t\tif (!strchr(s, '\\n')) { /* overlong line */\n\t\t\tint c;\n\t\t\tstrcat(s, \"\\n\");\n\t\t\t/* gobble up to newline */\n\t\t\twhile ((c = fgetc(fid)) != EOF && c != '\\n') ;\n\t\t}\n\t\tif (*s == tag) {\n\t\t\tfputs(line, stdout);\n\t\t\tcontinue;\n\t\t}\n\t\tphi1 = dmstor(s, &s);\n\t\tlam1 = dmstor(s, &s);\n\t\tif (inverse) {\n\t\t\tphi2 = dmstor(s, &s);\n\t\t\tlam2 = dmstor(s, &s);\n\t\t\tgeod_inv();\n\t\t} else {\n\t\t\tal12 = dmstor(s, &s);\n\t\t\tgeod_S = strtod(s, &s) * to_meter;\n\t\t\tgeod_pre();\n\t\t\tgeod_for();\n\t\t}\n\t\tif (!*s && (s > line)) --s; /* assumed we gobbled \\n */\n\t\tif (pos_azi) {\n\t\t\tif (al12 < 0.) al12 += TWOPI;\n\t\t\tif (al21 < 0.) al21 += TWOPI;\n\t\t}\n\t\tif (fullout) {\n\t\t\tprintLL(phi1, lam1); TAB;\n\t\t\tprintLL(phi2, lam2); TAB;\n\t\t\tif (oform) {\n\t\t\t\t(void)printf(oform, al12 * RAD_TO_DEG); TAB;\n\t\t\t\t(void)printf(oform, al21 * RAD_TO_DEG); TAB;\n\t\t\t\t(void)printf(osform, geod_S * fr_meter);\n\t\t\t}  else {\n\t\t\t\t(void)fputs(rtodms(pline, al12, 0, 0), stdout); TAB;\n\t\t\t\t(void)fputs(rtodms(pline, al21, 0, 0), stdout); TAB;\n\t\t\t\t(void)printf(osform, geod_S * fr_meter);\n\t\t\t}\n\t\t} else if (inverse)\n\t\t\tif (oform) {\n\t\t\t\t(void)printf(oform, al12 * RAD_TO_DEG); TAB;\n\t\t\t\t(void)printf(oform, al21 * RAD_TO_DEG); TAB;\n\t\t\t\t(void)printf(osform, geod_S * fr_meter);\n\t\t\t} else {\n\t\t\t\t(void)fputs(rtodms(pline, al12, 0, 0), stdout); TAB;\n\t\t\t\t(void)fputs(rtodms(pline, al21, 0, 0), stdout); TAB;\n\t\t\t\t(void)printf(osform, geod_S * fr_meter);\n\t\t\t}\n\t\telse {\n\t\t\tprintLL(phi2, lam2); TAB;\n\t\t\tif (oform)\n\t\t\t\t(void)printf(oform, al21 * RAD_TO_DEG);\n\t\t\telse\n\t\t\t\t(void)fputs(rtodms(pline, al21, 0, 0), stdout);\n\t\t}\n\t\t(void)fputs(s, stdout);\n\t}\n}", "path": "src\\geod.c", "repo_name": "h4ck3rm1k3/ProjC--", "stars": 1, "license": "other", "language": "c", "size": 6532}
{"docstring": "/***************************************************************************/\n/*\n *                              FUNCTIONS     \n */\n", "func_signal": "long pj_Set_Geocentric_Parameters (GeocentricInfo *gi, double a, double b)", "code": "{ /* BEGIN Set_Geocentric_Parameters */\n/*\n * The function Set_Geocentric_Parameters receives the ellipsoid parameters\n * as inputs and sets the corresponding state variables.\n *\n *    a  : Semi-major axis, in meters.          (input)\n *    b  : Semi-minor axis, in meters.          (input)\n */\n    long Error_Code = GEOCENT_NO_ERROR;\n\n    if (a <= 0.0)\n        Error_Code |= GEOCENT_A_ERROR;\n    if (b <= 0.0)\n        Error_Code |= GEOCENT_B_ERROR;\n    if (a < b)\n        Error_Code |= GEOCENT_A_LESS_B_ERROR;\n    if (!Error_Code)\n    {\n        gi->Geocent_a = a;\n        gi->Geocent_b = b;\n        gi->Geocent_a2 = a * a;\n        gi->Geocent_b2 = b * b;\n        gi->Geocent_e2 = (gi->Geocent_a2 - gi->Geocent_b2) / gi->Geocent_a2;\n        gi->Geocent_ep2 = (gi->Geocent_a2 - gi->Geocent_b2) / gi->Geocent_b2;\n    }\n    return (Error_Code);\n}", "path": "src\\geocent.c", "repo_name": "h4ck3rm1k3/ProjC--", "stars": 1, "license": "other", "language": "c", "size": 6532}
{"docstring": "/* evaluate complex polynomial and derivative */\n", "func_signal": "COMPLEX\npj_zpolyd1(COMPLEX z, COMPLEX *C, int n, COMPLEX *der)", "code": "{\n\tCOMPLEX a, b;\n\tdouble t;\n\tint first = 1;\n\n\ta = *(C += n);\n\twhile (n-- > 0) {\n\t\tif (first) {\n\t\t\tfirst = 0;\n\t\t\tb = a;\n\t\t} else {\n\t\t\tb.r = a.r + z.r * (t = b.r) - z.i * b.i;\n\t\t\tb.i = a.i + z.r * b.i + z.i * t;\n\t\t}\n\t\ta.r = (--C)->r + z.r * (t = a.r) - z.i * a.i;\n\t\ta.i = C->i + z.r * a.i + z.i * t;\n\t}\n\tb.r = a.r + z.r * (t = b.r) - z.i * b.i;\n\tb.i = a.i + z.r * b.i + z.i * t;\n\ta.r = z.r * (t = a.r) - z.i * a.i;\n\ta.i = z.r * a.i + z.i * t;\n\t*der = b;\n\treturn a;\n}", "path": "src\\pj_zpoly1.c", "repo_name": "h4ck3rm1k3/ProjC--", "stars": 1, "license": "other", "language": "c", "size": 6532}
{"docstring": "/************************************************************************/\n/*                              process()                               */\n/*                                                                      */\n/*      File processing function.                                       */\n/************************************************************************/\n", "func_signal": "static void process(FILE *fid)", "code": "{\n    char line[MAX_LINE+3], *s, pline[40];\n    projUV data;\n\n    for (;;) {\n        double z;\n\n        ++emess_dat.File_line;\n        if (!(s = fgets(line, MAX_LINE, fid)))\n            break;\n        if (!strchr(s, '\\n')) { /* overlong line */\n            int c;\n            (void)strcat(s, \"\\n\");\n\t\t\t\t/* gobble up to newline */\n            while ((c = fgetc(fid)) != EOF && c != '\\n') ;\n        }\n        if (*s == tag) {\n            fputs(line, stdout);\n            continue;\n        }\n\n        if (reversein) {\n            data.v = (*informat)(s, &s);\n            data.u = (*informat)(s, &s);\n        } else {\n            data.u = (*informat)(s, &s);\n            data.v = (*informat)(s, &s);\n        }\n\n        z = strtod( s, &s );\n\n        if (data.v == HUGE_VAL)\n            data.u = HUGE_VAL;\n\n        if (!*s && (s > line)) --s; /* assumed we gobbled \\n */\n\n        if ( echoin) {\n            int t;\n            t = *s;\n            *s = '\\0';\n            (void)fputs(line, stdout);\n            *s = t;\n            putchar('\\t');\n        }\n\n        if (data.u != HUGE_VAL) {\n            if( pj_transform( fromProj, toProj, 1, 0, \n                              &(data.u), &(data.v), &z ) != 0 )\n            {\n                data.u = HUGE_VAL;\n                data.v = HUGE_VAL;\n            }\n        }\n\n        if (data.u == HUGE_VAL) /* error output */\n            fputs(oterr, stdout);\n\n        else if (pj_is_latlong(toProj) && !oform) {\t/*ascii DMS output */\n            if (reverseout) {\n                fputs(rtodms(pline, data.v, 'N', 'S'), stdout);\n                putchar('\\t');\n                fputs(rtodms(pline, data.u, 'E', 'W'), stdout);\n            } else {\n                fputs(rtodms(pline, data.u, 'E', 'W'), stdout);\n                putchar('\\t');\n                fputs(rtodms(pline, data.v, 'N', 'S'), stdout);\n            }\n\n        } else {\t/* x-y or decimal degree ascii output */\n            if ( pj_is_latlong(toProj) ) {\n                data.v *= RAD_TO_DEG;\n                data.u *= RAD_TO_DEG;\n            }\n            if (reverseout) {\n                printf(oform,data.v); putchar('\\t');\n                printf(oform,data.u);\n            } else {\n                printf(oform,data.u); putchar('\\t');\n                printf(oform,data.v);\n            }\n        }\n\n        putchar(' ');\n        if( oform != NULL )\n            printf( oform, z );\n        else\n            printf( \"%.3f\", z );\n        if( s )\n            printf( \"%s\", s );\n        else\n            printf( \"\\n\" );\n    }\n}", "path": "src\\cs2cs.c", "repo_name": "h4ck3rm1k3/ProjC--", "stars": 1, "license": "other", "language": "c", "size": 6532}
{"docstring": "/* generate intermediate geodesic coordinates */\n", "func_signal": "do_geod(void)", "code": "{\n\tdouble phil, laml, del_S;\n\n\tphil = phi2;\n\tlaml = lam2;\n\tprintLL(phi1, lam1); putchar('\\n');\n\tfor ( geod_S = del_S = geod_S / n_S; --n_S; geod_S += del_S) {\n\t\tgeod_for();\n\t\tprintLL(phi2, lam2); putchar('\\n');\n\t}\n\tprintLL(phil, laml); putchar('\\n');\n}", "path": "src\\geod.c", "repo_name": "h4ck3rm1k3/ProjC--", "stars": 1, "license": "other", "language": "c", "size": 6532}
{"docstring": "/* two dimension array */\n", "func_signal": "vector2(int nrows, int ncols, int size)", "code": "{\n\tvoid **s;\n\n\tif (s = (void **)pj_malloc(sizeof(void *) * nrows)) {\n\t\tint rsize, i;\n\n\t\trsize = size * ncols;\n\t\tfor (i = 0; i < nrows; ++i)\n\t\t\tif (!(s[i] = pj_malloc(rsize))) {\n\t\t\t\tfreev2(s, i);\n\t\t\t\treturn (void **)0;\n\t\t\t}\n\t}\n\treturn s;\n}", "path": "src\\vector1.c", "repo_name": "h4ck3rm1k3/ProjC--", "stars": 1, "license": "other", "language": "c", "size": 6532}
{"docstring": "/* END OF Set_Geocentric_Parameters */\n", "func_signal": "void pj_Get_Geocentric_Parameters (GeocentricInfo *gi,\n                                   double *a, \n                                   double *b)", "code": "{ /* BEGIN Get_Geocentric_Parameters */\n/*\n * The function Get_Geocentric_Parameters returns the ellipsoid parameters\n * to be used in geocentric coordinate conversions.\n *\n *    a  : Semi-major axis, in meters.          (output)\n *    b  : Semi-minor axis, in meters.          (output)\n */\n\n    *a = gi->Geocent_a;\n    *b = gi->Geocent_b;\n}", "path": "src\\geocent.c", "repo_name": "h4ck3rm1k3/ProjC--", "stars": 1, "license": "other", "language": "c", "size": 6532}
{"docstring": "/************************************************************************/\n/*                             pj_get_def()                             */\n/*                                                                      */\n/*      Returns the PROJ.4 command string that would produce this       */\n/*      definition expanded as much as possible.  For instance,         */\n/*      +init= calls and +datum= defintions would be expanded.          */\n/************************************************************************/\n", "func_signal": "char *pj_get_def( PJ *P, int options )", "code": "{\n    paralist *t;\n    int l;\n    char *definition;\n    int  def_max = 10;\n\n    definition = (char *) pj_malloc(def_max);\n    definition[0] = '\\0';\n\n    for (t = P->params; t; t = t->next)\n    {\n        /* skip unused parameters ... mostly appended defaults and stuff */\n        if (!t->used)\n            continue;\n\n        /* grow the resulting string if needed */\n        l = strlen(t->param) + 1;\n        if( strlen(definition) + l + 5 > def_max )\n        {\n            char *def2;\n\n            def_max = def_max * 2 + l + 5;\n            def2 = (char *) pj_malloc(def_max);\n            strcpy( def2, definition );\n            pj_dalloc( definition );\n            definition = def2;\n        }\n\n        /* append this parameter */\n        strcat( definition, \" +\" );\n        strcat( definition, t->param );\n    }\n\n    return definition;\n}", "path": "src\\pj_pr_list.c", "repo_name": "h4ck3rm1k3/ProjC--", "stars": 1, "license": "other", "language": "c", "size": 6532}
{"docstring": "/************************************************************************/\n/*                         pj_apply_gridshift()                         */\n/************************************************************************/\n", "func_signal": "int pj_apply_gridshift( const char *nadgrids, int inverse, \n                        long point_count, int point_offset,\n                        double *x, double *y, double *z )", "code": "{\n    int grid_count = 0;\n    PJ_GRIDINFO   **tables;\n    int  i;\n    int debug_flag = getenv( \"PROJ_DEBUG\" ) != NULL;\n    static int debug_count = 0;\n\n    pj_errno = 0;\n\n    tables = pj_gridlist_from_nadgrids( nadgrids, &grid_count);\n    if( tables == NULL || grid_count == 0 )\n        return pj_errno;\n\n    for( i = 0; i < point_count; i++ )\n    {\n        long io = i * point_offset;\n        LP   input, output;\n        int  itable;\n\n        input.phi = y[io];\n        input.lam = x[io];\n        output.phi = HUGE_VAL;\n        output.lam = HUGE_VAL;\n\n        /* keep trying till we find a table that works */\n        for( itable = 0; itable < grid_count; itable++ )\n        {\n            PJ_GRIDINFO *gi = tables[itable];\n            struct CTABLE *ct = gi->ct;\n\n            /* skip tables that don't match our point at all.  */\n            if( ct->ll.phi > input.phi || ct->ll.lam > input.lam\n                || ct->ll.phi + (ct->lim.phi-1) * ct->del.phi < input.phi\n                || ct->ll.lam + (ct->lim.lam-1) * ct->del.lam < input.lam )\n                continue;\n\n            /* If we have child nodes, check to see if any of them apply. */\n            if( gi->child != NULL )\n            {\n                PJ_GRIDINFO *child;\n\n                for( child = gi->child; child != NULL; child = child->next )\n                {\n                    struct CTABLE *ct1 = child->ct;\n\n                    if( ct1->ll.phi > input.phi || ct1->ll.lam > input.lam\n                      || ct1->ll.phi+(ct1->lim.phi-1)*ct1->del.phi < input.phi\n                      || ct1->ll.lam+(ct1->lim.lam-1)*ct1->del.lam < input.lam)\n                        continue;\n\n                    break;\n                }\n\n                /* we found a more refined child node to use */\n                if( child != NULL )\n                {\n                    gi = child;\n                    ct = child->ct;\n                }\n            }\n\n            /* load the grid shift info if we don't have it. */\n            if( ct->cvs == NULL && !pj_gridinfo_load( gi ) )\n            {\n                pj_errno = -38;\n                return pj_errno;\n            }\n            \n            output = nad_cvt( input, inverse, ct );\n            if( output.lam != HUGE_VAL )\n            {\n                if( debug_flag && debug_count++ < 20 )\n                    fprintf( stderr,\n                             \"pj_apply_gridshift(): used %s\\n\",\n                             ct->id );\n                break;\n            }\n        }\n\n        if( output.lam == HUGE_VAL )\n        {\n            if( debug_flag )\n            {\n                fprintf( stderr, \n                         \"pj_apply_gridshift(): failed to find a grid shift table for\\n\"\n                         \"                      location (%.7fdW,%.7fdN)\\n\",\n                         x[io] * RAD_TO_DEG, \n                         y[io] * RAD_TO_DEG );\n                fprintf( stderr, \n                         \"   tried: %s\\n\", nadgrids );\n            }\n        \n            pj_errno = -38;\n            return pj_errno;\n        }\n        else\n        {\n            y[io] = output.phi;\n            x[io] = output.lam;\n        }\n    }\n\n    return 0;\n}", "path": "src\\pj_apply_gridshift.c", "repo_name": "h4ck3rm1k3/ProjC--", "stars": 1, "license": "other", "language": "c", "size": 6532}
{"docstring": "/*!\n * \\brief\n * retrieves ellipsoid parameters\n * \n * JNI informations:\n * Class:     org_proj4_Projections\n * Method:    getEllipsInfo\n * Signature: (Ljava/lang/String;)Ljava/lang/String;\n * \n *\n * \\param env - parameter used by jni (see JNI specification)\n * \\param parent - parameter used by jni (see JNI specification)\n * \\param projdefinition - definition of the projection\n*/\n", "func_signal": "JNIEXPORT jstring JNICALL Java_org_proj4_Projections_getEllipsInfo\n  (JNIEnv * env, jobject parent, jstring projdefinition)", "code": "{\n\tPJ *pj;\n\tchar * pjdesc;\n\tchar ellipseinfo[arraysize];\n\tchar temp[50];\n\t\n\tchar * proj_def = (char *) (*env)->GetStringUTFChars (env, projdefinition, 0);\n\t\n\tif (!(pj = pj_init_plus(proj_def)))\n\t\texit(1);\n\t\n\t// put together all the info of the ellipsoid \n/* \tsprintf(temp,\"name: %s;\", pj->descr); */\n\tsprintf(temp,\"name: not available;\");\n\tstrcpy(ellipseinfo,temp);\n\tsprintf(temp,\"a: %lf;\", pj->a);\n\tstrcat(ellipseinfo,temp);\n\tsprintf(temp,\"e: %lf;\", pj->e);\n\tstrcat(ellipseinfo,temp);\n\tsprintf(temp,\"es: %lf;\", pj->es);\n\tstrcat(ellipseinfo,temp);\n\tsprintf(temp,\"ra: %lf;\", pj->ra);\n\tstrcat(ellipseinfo,temp);\n\tsprintf(temp,\"one_es: %lf;\", pj->one_es);\n\tstrcat(ellipseinfo,temp);\n\tsprintf(temp,\"rone_es: %lf;\", pj->rone_es);\n\tstrcat(ellipseinfo,temp);\n\tsprintf(temp,\"lam0: %lf;\", pj->lam0);\n\tstrcat(ellipseinfo,temp);\n\tsprintf(temp,\"phi0: %lf;\", pj->phi0);\n\tstrcat(ellipseinfo,temp);\n\tsprintf(temp,\"x0: %lf;\", pj->x0);\n\tstrcat(ellipseinfo,temp);\n\tsprintf(temp,\"y0: %lf;\", pj->y0);\n\tstrcat(ellipseinfo,temp);\n\tsprintf(temp,\"k0: %lf;\", pj->k0);\n\tstrcat(ellipseinfo,temp);\n\tsprintf(temp,\"to_meter: %lf;\", pj->to_meter);\n\tstrcat(ellipseinfo,temp);\n\tsprintf(temp,\"fr_meter: %lf;\", pj->fr_meter);\n\tstrcat(ellipseinfo,temp);\n\n\treturn (*env)->NewStringUTF(env,ellipseinfo); \n}", "path": "src\\jniproj.c", "repo_name": "h4ck3rm1k3/ProjC--", "stars": 1, "license": "other", "language": "c", "size": 6532}
{"docstring": "/* one dimension array */\n", "func_signal": "vector1(int nvals, int size)", "code": "{ return((void *)pj_malloc(size * nvals)); }\n\tvoid /* free 2D array */\nfreev2(void **v, int nrows) {\n\tif (v) {\n\t\tfor (v += nrows; nrows > 0; --nrows)\n\t\t\tpj_dalloc(*--v);\n\t\tpj_dalloc(v);\n\t}\n}", "path": "src\\vector1.c", "repo_name": "h4ck3rm1k3/ProjC--", "stars": 1, "license": "other", "language": "c", "size": 6532}
{"docstring": "/************************************************************************/\n/*                       pj_gridlist_merge_grid()                       */\n/*                                                                      */\n/*      Find/load the named gridfile and merge it into the              */\n/*      last_nadgrids_list.                                             */\n/************************************************************************/\n", "func_signal": "static int pj_gridlist_merge_gridfile( const char *gridname )", "code": "{\n    int i, got_match=0;\n    PJ_GRIDINFO *this_grid, *tail = NULL;\n\n/* -------------------------------------------------------------------- */\n/*      Try to find in the existing list of loaded grids.  Add all      */\n/*      matching grids as with NTv2 we can get many grids from one      */\n/*      file (one shared gridname).                                     */\n/* -------------------------------------------------------------------- */\n    for( this_grid = grid_list; this_grid != NULL; this_grid = this_grid->next)\n    {\n        if( strcmp(this_grid->gridname,gridname) == 0 )\n        {\n            got_match = 1;\n\n            /* dont add to the list if it is invalid. */\n            if( this_grid->ct == NULL )\n                return 0;\n\n            /* do we need to grow the list? */\n            if( last_nadgrids_count >= last_nadgrids_max - 2 )\n            {\n                PJ_GRIDINFO **new_list;\n                int new_max = last_nadgrids_max + 20;\n\n                new_list = (PJ_GRIDINFO **) pj_malloc(sizeof(void*) * new_max);\n                if( last_nadgrids_list != NULL )\n                {\n                    memcpy( new_list, last_nadgrids_list, \n                            sizeof(void*) * last_nadgrids_max );\n                    pj_dalloc( last_nadgrids_list );\n                }\n\n                last_nadgrids_list = new_list;\n                last_nadgrids_max = new_max;\n            }\n\n            /* add to the list */\n            last_nadgrids_list[last_nadgrids_count++] = this_grid;\n            last_nadgrids_list[last_nadgrids_count] = NULL;\n        }\n\n        tail = this_grid;\n    }\n\n    if( got_match )\n        return 1;\n\n/* -------------------------------------------------------------------- */\n/*      Try to load the named grid.                                     */\n/* -------------------------------------------------------------------- */\n    this_grid = pj_gridinfo_init( gridname );\n\n    if( this_grid == NULL )\n    {\n        /* we should get at least a stub grid with a missing \"ct\" member */\n        assert( FALSE );\n        return 0;\n    }\n    \n    if( tail != NULL )\n        tail->next = this_grid;\n    else\n        grid_list = this_grid;\n\n/* -------------------------------------------------------------------- */\n/*      Recurse to add the grid now that it is loaded.                  */\n/* -------------------------------------------------------------------- */\n    return pj_gridlist_merge_gridfile( gridname );\n}", "path": "src\\pj_gridlist.c", "repo_name": "h4ck3rm1k3/ProjC--", "stars": 1, "license": "other", "language": "c", "size": 6532}
{"docstring": "/*\n * Initialize for a Huffman-compressed scan.\n * If gather_statistics is TRUE, we do not output anything during the scan,\n * just count the Huffman symbols used and generate Huffman code tables.\n */\n", "func_signal": "METHODDEF(void)\nstart_pass_huff (j_compress_ptr cinfo, boolean gather_statistics)", "code": "{\n  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;\n  int ci, dctbl, actbl;\n  jpeg_component_info * compptr;\n\n  if (gather_statistics) {\n#ifdef ENTROPY_OPT_SUPPORTED\n    entropy->pub.encode_mcu = encode_mcu_gather;\n    entropy->pub.finish_pass = finish_pass_gather;\n#else\n    ERREXIT(cinfo, JERR_NOT_COMPILED);\n#endif\n  } else {\n    entropy->pub.encode_mcu = encode_mcu_huff;\n    entropy->pub.finish_pass = finish_pass_huff;\n  }\n\n  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n    compptr = cinfo->cur_comp_info[ci];\n    dctbl = compptr->dc_tbl_no;\n    actbl = compptr->ac_tbl_no;\n    if (gather_statistics) {\n#ifdef ENTROPY_OPT_SUPPORTED\n      /* Check for invalid table indexes */\n      /* (make_c_derived_tbl does this in the other path) */\n      if (dctbl < 0 || dctbl >= NUM_HUFF_TBLS)\n\tERREXIT1(cinfo, JERR_NO_HUFF_TABLE, dctbl);\n      if (actbl < 0 || actbl >= NUM_HUFF_TBLS)\n\tERREXIT1(cinfo, JERR_NO_HUFF_TABLE, actbl);\n      /* Allocate and zero the statistics tables */\n      /* Note that jpeg_gen_optimal_table expects 257 entries in each table! */\n      if (entropy->dc_count_ptrs[dctbl] == NULL)\n\tentropy->dc_count_ptrs[dctbl] = (long *)\n\t  (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\t      257 * SIZEOF(long));\n      MEMZERO(entropy->dc_count_ptrs[dctbl], 257 * SIZEOF(long));\n      if (entropy->ac_count_ptrs[actbl] == NULL)\n\tentropy->ac_count_ptrs[actbl] = (long *)\n\t  (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\t      257 * SIZEOF(long));\n      MEMZERO(entropy->ac_count_ptrs[actbl], 257 * SIZEOF(long));\n#endif\n    } else {\n      /* Compute derived values for Huffman tables */\n      /* We may do this more than once for a table, but it's not expensive */\n      jpeg_make_c_derived_tbl(cinfo, TRUE, dctbl,\n\t\t\t      & entropy->dc_derived_tbls[dctbl]);\n      jpeg_make_c_derived_tbl(cinfo, FALSE, actbl,\n\t\t\t      & entropy->ac_derived_tbls[actbl]);\n    }\n    /* Initialize DC predictions to 0 */\n    entropy->saved.last_dc_val[ci] = 0;\n  }\n\n  /* Initialize bit buffer to empty */\n  entropy->saved.put_buffer = 0;\n  entropy->saved.put_bits = 0;\n\n  /* Initialize restart stuff */\n  entropy->restarts_to_go = cinfo->restart_interval;\n  entropy->next_restart_num = 0;\n}", "path": "src\\ashxp\\jpeg-6b\\jchuff.c", "repo_name": "Kur0N3k0/Puff-UAF", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 10872}
{"docstring": "/* Process a single block's worth of coefficients */\n", "func_signal": "LOCAL(void)\nhtest_one_block (j_compress_ptr cinfo, JCOEFPTR block, int last_dc_val,\n\t\t long dc_counts[], long ac_counts[])", "code": "{\n  register int temp;\n  register int nbits;\n  register int k, r;\n  \n  /* Encode the DC coefficient difference per section F.1.2.1 */\n  \n  temp = block[0] - last_dc_val;\n  if (temp < 0)\n    temp = -temp;\n  \n  /* Find the number of bits needed for the magnitude of the coefficient */\n  nbits = 0;\n  while (temp) {\n    nbits++;\n    temp >>= 1;\n  }\n  /* Check for out-of-range coefficient values.\n   * Since we're encoding a difference, the range limit is twice as much.\n   */\n  if (nbits > MAX_COEF_BITS+1)\n    ERREXIT(cinfo, JERR_BAD_DCT_COEF);\n\n  /* Count the Huffman symbol for the number of bits */\n  dc_counts[nbits]++;\n  \n  /* Encode the AC coefficients per section F.1.2.2 */\n  \n  r = 0;\t\t\t/* r = run length of zeros */\n  \n  for (k = 1; k < DCTSIZE2; k++) {\n    if ((temp = block[jpeg_natural_order[k]]) == 0) {\n      r++;\n    } else {\n      /* if run length > 15, must emit special run-length-16 codes (0xF0) */\n      while (r > 15) {\n\tac_counts[0xF0]++;\n\tr -= 16;\n      }\n      \n      /* Find the number of bits needed for the magnitude of the coefficient */\n      if (temp < 0)\n\ttemp = -temp;\n      \n      /* Find the number of bits needed for the magnitude of the coefficient */\n      nbits = 1;\t\t/* there must be at least one 1 bit */\n      while ((temp >>= 1))\n\tnbits++;\n      /* Check for out-of-range coefficient values */\n      if (nbits > MAX_COEF_BITS)\n\tERREXIT(cinfo, JERR_BAD_DCT_COEF);\n      \n      /* Count Huffman symbol for run length / number of bits */\n      ac_counts[(r << 4) + nbits]++;\n      \n      r = 0;\n    }\n  }\n\n  /* If the last coef(s) were zero, emit an end-of-block code */\n  if (r > 0)\n    ac_counts[0]++;\n}", "path": "src\\ashxp\\jpeg-6b\\jchuff.c", "repo_name": "Kur0N3k0/Puff-UAF", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 10872}
{"docstring": "/*\n * Module initialization routine for merged upsampling/color conversion.\n *\n * NB: this is called under the conditions determined by use_merged_upsample()\n * in jdmaster.c.  That routine MUST correspond to the actual capabilities\n * of this module; no safety checks are made here.\n */\n", "func_signal": "GLOBAL(void)\njinit_merged_upsampler (j_decompress_ptr cinfo)", "code": "{\n  my_upsample_ptr upsample;\n\n  upsample = (my_upsample_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\tSIZEOF(my_upsampler));\n  cinfo->upsample = (struct jpeg_upsampler *) upsample;\n  upsample->pub.start_pass = start_pass_merged_upsample;\n  upsample->pub.need_context_rows = FALSE;\n\n  upsample->out_row_width = cinfo->output_width * cinfo->out_color_components;\n\n  if (cinfo->max_v_samp_factor == 2) {\n    upsample->pub.upsample = merged_2v_upsample;\n    upsample->upmethod = h2v2_merged_upsample;\n    /* Allocate a spare row buffer */\n    upsample->spare_row = (JSAMPROW)\n      (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t(size_t) (upsample->out_row_width * SIZEOF(JSAMPLE)));\n  } else {\n    upsample->pub.upsample = merged_1v_upsample;\n    upsample->upmethod = h2v1_merged_upsample;\n    /* No spare row needed */\n    upsample->spare_row = NULL;\n  }\n\n  build_ycc_rgb_table(cinfo);\n}", "path": "src\\ashxp\\jpeg-6b\\jdmerge.c", "repo_name": "Kur0N3k0/Puff-UAF", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 10872}
{"docstring": "/*\n * Module initialization routine for Huffman entropy encoding.\n */\n", "func_signal": "GLOBAL(void)\njinit_huff_encoder (j_compress_ptr cinfo)", "code": "{\n  huff_entropy_ptr entropy;\n  int i;\n\n  entropy = (huff_entropy_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\tSIZEOF(huff_entropy_encoder));\n  cinfo->entropy = (struct jpeg_entropy_encoder *) entropy;\n  entropy->pub.start_pass = start_pass_huff;\n\n  /* Mark tables unallocated */\n  for (i = 0; i < NUM_HUFF_TBLS; i++) {\n    entropy->dc_derived_tbls[i] = entropy->ac_derived_tbls[i] = NULL;\n#ifdef ENTROPY_OPT_SUPPORTED\n    entropy->dc_count_ptrs[i] = entropy->ac_count_ptrs[i] = NULL;\n#endif\n  }\n}", "path": "src\\ashxp\\jpeg-6b\\jchuff.c", "repo_name": "Kur0N3k0/Puff-UAF", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 10872}
{"docstring": "/*\n * Determine whether merged upsample/color conversion should be used.\n * CRUCIAL: this must match the actual capabilities of jdmerge.c!\n */\n", "func_signal": "LOCAL(boolean)\nuse_merged_upsample (j_decompress_ptr cinfo)", "code": "{\n#ifdef UPSAMPLE_MERGING_SUPPORTED\n  /* Merging is the equivalent of plain box-filter upsampling */\n  if (cinfo->do_fancy_upsampling || cinfo->CCIR601_sampling)\n    return FALSE;\n  /* jdmerge.c only supports YCC=>RGB color conversion */\n  if (cinfo->jpeg_color_space != JCS_YCbCr || cinfo->num_components != 3 ||\n      cinfo->out_color_space != JCS_RGB ||\n      cinfo->out_color_components != RGB_PIXELSIZE)\n    return FALSE;\n  /* and it only handles 2h1v or 2h2v sampling ratios */\n  if (cinfo->comp_info[0].h_samp_factor != 2 ||\n      cinfo->comp_info[1].h_samp_factor != 1 ||\n      cinfo->comp_info[2].h_samp_factor != 1 ||\n      cinfo->comp_info[0].v_samp_factor >  2 ||\n      cinfo->comp_info[1].v_samp_factor != 1 ||\n      cinfo->comp_info[2].v_samp_factor != 1)\n    return FALSE;\n  /* furthermore, it doesn't work if we've scaled the IDCTs differently */\n  if (cinfo->comp_info[0].DCT_scaled_size != cinfo->min_DCT_scaled_size ||\n      cinfo->comp_info[1].DCT_scaled_size != cinfo->min_DCT_scaled_size ||\n      cinfo->comp_info[2].DCT_scaled_size != cinfo->min_DCT_scaled_size)\n    return FALSE;\n  /* ??? also need to test for upsample-time rescaling, when & if supported */\n  return TRUE;\t\t\t/* by golly, it'll work... */\n#else\n  return FALSE;\n#endif\n}", "path": "src\\ashxp\\jpeg-6b\\jdmaster.c", "repo_name": "Kur0N3k0/Puff-UAF", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 10872}
{"docstring": "/*\n * Initialize tables for YCC->RGB colorspace conversion.\n * This is taken directly from jdcolor.c; see that file for more info.\n */\n", "func_signal": "LOCAL(void)\nbuild_ycc_rgb_table (j_decompress_ptr cinfo)", "code": "{\n  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;\n  int i;\n  INT32 x;\n  SHIFT_TEMPS\n\n  upsample->Cr_r_tab = (int *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\t(MAXJSAMPLE+1) * SIZEOF(int));\n  upsample->Cb_b_tab = (int *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\t(MAXJSAMPLE+1) * SIZEOF(int));\n  upsample->Cr_g_tab = (INT32 *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\t(MAXJSAMPLE+1) * SIZEOF(INT32));\n  upsample->Cb_g_tab = (INT32 *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\t(MAXJSAMPLE+1) * SIZEOF(INT32));\n\n  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {\n    /* i is the actual input pixel value, in the range 0..MAXJSAMPLE */\n    /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */\n    /* Cr=>R value is nearest int to 1.40200 * x */\n    upsample->Cr_r_tab[i] = (int)\n\t\t    RIGHT_SHIFT(FIX(1.40200) * x + ONE_HALF, SCALEBITS);\n    /* Cb=>B value is nearest int to 1.77200 * x */\n    upsample->Cb_b_tab[i] = (int)\n\t\t    RIGHT_SHIFT(FIX(1.77200) * x + ONE_HALF, SCALEBITS);\n    /* Cr=>G value is scaled-up -0.71414 * x */\n    upsample->Cr_g_tab[i] = (- FIX(0.71414)) * x;\n    /* Cb=>G value is scaled-up -0.34414 * x */\n    /* We also add in ONE_HALF so that need not do it in inner loop */\n    upsample->Cb_g_tab[i] = (- FIX(0.34414)) * x + ONE_HALF;\n  }\n}", "path": "src\\ashxp\\jpeg-6b\\jdmerge.c", "repo_name": "Kur0N3k0/Puff-UAF", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 10872}
{"docstring": "/*\n * Encode and output one MCU's worth of Huffman-compressed coefficients.\n */\n", "func_signal": "METHODDEF(boolean)\nencode_mcu_huff (j_compress_ptr cinfo, JBLOCKROW *MCU_data)", "code": "{\n  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;\n  working_state state;\n  int blkn, ci;\n  jpeg_component_info * compptr;\n\n  /* Load up working state */\n  state.next_output_byte = cinfo->dest->next_output_byte;\n  state.free_in_buffer = cinfo->dest->free_in_buffer;\n  ASSIGN_STATE(state.cur, entropy->saved);\n  state.cinfo = cinfo;\n\n  /* Emit restart marker if needed */\n  if (cinfo->restart_interval) {\n    if (entropy->restarts_to_go == 0)\n      if (! emit_restart(&state, entropy->next_restart_num))\n\treturn FALSE;\n  }\n\n  /* Encode the MCU data blocks */\n  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {\n    ci = cinfo->MCU_membership[blkn];\n    compptr = cinfo->cur_comp_info[ci];\n    if (! encode_one_block(&state,\n\t\t\t   MCU_data[blkn][0], state.cur.last_dc_val[ci],\n\t\t\t   entropy->dc_derived_tbls[compptr->dc_tbl_no],\n\t\t\t   entropy->ac_derived_tbls[compptr->ac_tbl_no]))\n      return FALSE;\n    /* Update last_dc_val */\n    state.cur.last_dc_val[ci] = MCU_data[blkn][0][0];\n  }\n\n  /* Completed MCU, so update state */\n  cinfo->dest->next_output_byte = state.next_output_byte;\n  cinfo->dest->free_in_buffer = state.free_in_buffer;\n  ASSIGN_STATE(entropy->saved, state.cur);\n\n  /* Update restart-interval state too */\n  if (cinfo->restart_interval) {\n    if (entropy->restarts_to_go == 0) {\n      entropy->restarts_to_go = cinfo->restart_interval;\n      entropy->next_restart_num++;\n      entropy->next_restart_num &= 7;\n    }\n    entropy->restarts_to_go--;\n  }\n\n  return TRUE;\n}", "path": "src\\ashxp\\jpeg-6b\\jchuff.c", "repo_name": "Kur0N3k0/Puff-UAF", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 10872}
{"docstring": "/*\n * Finish up at end of an output pass.\n */\n", "func_signal": "METHODDEF(void)\nfinish_output_pass (j_decompress_ptr cinfo)", "code": "{\n  my_master_ptr master = (my_master_ptr) cinfo->master;\n\n  if (cinfo->quantize_colors)\n    (*cinfo->cquantize->finish_pass) (cinfo);\n  master->pass_number++;\n}", "path": "src\\ashxp\\jpeg-6b\\jdmaster.c", "repo_name": "Kur0N3k0/Puff-UAF", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 10872}
{"docstring": "/*\n * Finish up at the end of a Huffman-compressed scan.\n */\n", "func_signal": "METHODDEF(void)\nfinish_pass_huff (j_compress_ptr cinfo)", "code": "{\n  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;\n  working_state state;\n\n  /* Load up working state ... flush_bits needs it */\n  state.next_output_byte = cinfo->dest->next_output_byte;\n  state.free_in_buffer = cinfo->dest->free_in_buffer;\n  ASSIGN_STATE(state.cur, entropy->saved);\n  state.cinfo = cinfo;\n\n  /* Flush out the last data */\n  if (! flush_bits(&state))\n    ERREXIT(cinfo, JERR_CANT_SUSPEND);\n\n  /* Update state */\n  cinfo->dest->next_output_byte = state.next_output_byte;\n  cinfo->dest->free_in_buffer = state.free_in_buffer;\n  ASSIGN_STATE(entropy->saved, state.cur);\n}", "path": "src\\ashxp\\jpeg-6b\\jchuff.c", "repo_name": "Kur0N3k0/Puff-UAF", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 10872}
{"docstring": "/*\n * Write an abbreviated table-specification datastream.\n * This consists of SOI, DQT and DHT tables, and EOI.\n * Any table that is defined and not marked sent_table = TRUE will be\n * emitted.  Note that all tables will be marked sent_table = TRUE at exit.\n */\n", "func_signal": "METHODDEF(void)\nwrite_tables_only (j_compress_ptr cinfo)", "code": "{\n  int i;\n\n  emit_marker(cinfo, M_SOI);\n\n  for (i = 0; i < NUM_QUANT_TBLS; i++) {\n    if (cinfo->quant_tbl_ptrs[i] != NULL)\n      (void) emit_dqt(cinfo, i);\n  }\n\n  if (! cinfo->arith_code) {\n    for (i = 0; i < NUM_HUFF_TBLS; i++) {\n      if (cinfo->dc_huff_tbl_ptrs[i] != NULL)\n\temit_dht(cinfo, i, FALSE);\n      if (cinfo->ac_huff_tbl_ptrs[i] != NULL)\n\temit_dht(cinfo, i, TRUE);\n    }\n  }\n\n  emit_marker(cinfo, M_EOI);\n}", "path": "src\\ashxp\\jpeg-6b\\jcmarker.c", "repo_name": "Kur0N3k0/Puff-UAF", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 10872}
{"docstring": "/*\n * Trial-encode one MCU's worth of Huffman-compressed coefficients.\n * No data is actually output, so no suspension return is possible.\n */\n", "func_signal": "METHODDEF(boolean)\nencode_mcu_gather (j_compress_ptr cinfo, JBLOCKROW *MCU_data)", "code": "{\n  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;\n  int blkn, ci;\n  jpeg_component_info * compptr;\n\n  /* Take care of restart intervals if needed */\n  if (cinfo->restart_interval) {\n    if (entropy->restarts_to_go == 0) {\n      /* Re-initialize DC predictions to 0 */\n      for (ci = 0; ci < cinfo->comps_in_scan; ci++)\n\tentropy->saved.last_dc_val[ci] = 0;\n      /* Update restart state */\n      entropy->restarts_to_go = cinfo->restart_interval;\n    }\n    entropy->restarts_to_go--;\n  }\n\n  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {\n    ci = cinfo->MCU_membership[blkn];\n    compptr = cinfo->cur_comp_info[ci];\n    htest_one_block(cinfo, MCU_data[blkn][0], entropy->saved.last_dc_val[ci],\n\t\t    entropy->dc_count_ptrs[compptr->dc_tbl_no],\n\t\t    entropy->ac_count_ptrs[compptr->ac_tbl_no]);\n    entropy->saved.last_dc_val[ci] = MCU_data[blkn][0][0];\n  }\n\n  return TRUE;\n}", "path": "src\\ashxp\\jpeg-6b\\jchuff.c", "repo_name": "Kur0N3k0/Puff-UAF", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 10872}
{"docstring": "/*\n * Finish up a statistics-gathering pass and create the new Huffman tables.\n */\n", "func_signal": "METHODDEF(void)\nfinish_pass_gather (j_compress_ptr cinfo)", "code": "{\n  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;\n  int ci, dctbl, actbl;\n  jpeg_component_info * compptr;\n  JHUFF_TBL **htblptr;\n  boolean did_dc[NUM_HUFF_TBLS];\n  boolean did_ac[NUM_HUFF_TBLS];\n\n  /* It's important not to apply jpeg_gen_optimal_table more than once\n   * per table, because it clobbers the input frequency counts!\n   */\n  MEMZERO(did_dc, SIZEOF(did_dc));\n  MEMZERO(did_ac, SIZEOF(did_ac));\n\n  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n    compptr = cinfo->cur_comp_info[ci];\n    dctbl = compptr->dc_tbl_no;\n    actbl = compptr->ac_tbl_no;\n    if (! did_dc[dctbl]) {\n      htblptr = & cinfo->dc_huff_tbl_ptrs[dctbl];\n      if (*htblptr == NULL)\n\t*htblptr = jpeg_alloc_huff_table((j_common_ptr) cinfo);\n      jpeg_gen_optimal_table(cinfo, *htblptr, entropy->dc_count_ptrs[dctbl]);\n      did_dc[dctbl] = TRUE;\n    }\n    if (! did_ac[actbl]) {\n      htblptr = & cinfo->ac_huff_tbl_ptrs[actbl];\n      if (*htblptr == NULL)\n\t*htblptr = jpeg_alloc_huff_table((j_common_ptr) cinfo);\n      jpeg_gen_optimal_table(cinfo, *htblptr, entropy->ac_count_ptrs[actbl]);\n      did_ac[actbl] = TRUE;\n    }\n  }\n}", "path": "src\\ashxp\\jpeg-6b\\jchuff.c", "repo_name": "Kur0N3k0/Puff-UAF", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 10872}
{"docstring": "/*\n * Compute the derived values for a Huffman table.\n * This routine also performs some validation checks on the table.\n *\n * Note this is also used by jcphuff.c.\n */\n", "func_signal": "GLOBAL(void)\njpeg_make_c_derived_tbl (j_compress_ptr cinfo, boolean isDC, int tblno,\n\t\t\t c_derived_tbl ** pdtbl)", "code": "{\n  JHUFF_TBL *htbl;\n  c_derived_tbl *dtbl;\n  int p, i, l, lastp, si, maxsymbol;\n  char huffsize[257];\n  unsigned int huffcode[257];\n  unsigned int code;\n\n  /* Note that huffsize[] and huffcode[] are filled in code-length order,\n   * paralleling the order of the symbols themselves in htbl->huffval[].\n   */\n\n  /* Find the input Huffman table */\n  if (tblno < 0 || tblno >= NUM_HUFF_TBLS)\n    ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);\n  htbl =\n    isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];\n  if (htbl == NULL)\n    ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);\n\n  /* Allocate a workspace if we haven't already done so. */\n  if (*pdtbl == NULL)\n    *pdtbl = (c_derived_tbl *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\t  SIZEOF(c_derived_tbl));\n  dtbl = *pdtbl;\n  \n  /* Figure C.1: make table of Huffman code length for each symbol */\n\n  p = 0;\n  for (l = 1; l <= 16; l++) {\n    i = (int) htbl->bits[l];\n    if (i < 0 || p + i > 256)\t/* protect against table overrun */\n      ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);\n    while (i--)\n      huffsize[p++] = (char) l;\n  }\n  huffsize[p] = 0;\n  lastp = p;\n  \n  /* Figure C.2: generate the codes themselves */\n  /* We also validate that the counts represent a legal Huffman code tree. */\n\n  code = 0;\n  si = huffsize[0];\n  p = 0;\n  while (huffsize[p]) {\n    while (((int) huffsize[p]) == si) {\n      huffcode[p++] = code;\n      code++;\n    }\n    /* code is now 1 more than the last code used for codelength si; but\n     * it must still fit in si bits, since no code is allowed to be all ones.\n     */\n    if (((INT32) code) >= (((INT32) 1) << si))\n      ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);\n    code <<= 1;\n    si++;\n  }\n  \n  /* Figure C.3: generate encoding tables */\n  /* These are code and size indexed by symbol value */\n\n  /* Set all codeless symbols to have code length 0;\n   * this lets us detect duplicate VAL entries here, and later\n   * allows emit_bits to detect any attempt to emit such symbols.\n   */\n  MEMZERO(dtbl->ehufsi, SIZEOF(dtbl->ehufsi));\n\n  /* This is also a convenient place to check for out-of-range\n   * and duplicated VAL entries.  We allow 0..255 for AC symbols\n   * but only 0..15 for DC.  (We could constrain them further\n   * based on data depth and mode, but this seems enough.)\n   */\n  maxsymbol = isDC ? 15 : 255;\n\n  for (p = 0; p < lastp; p++) {\n    i = htbl->huffval[p];\n    if (i < 0 || i > maxsymbol || dtbl->ehufsi[i])\n      ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);\n    dtbl->ehufco[i] = huffcode[p];\n    dtbl->ehufsi[i] = huffsize[p];\n  }\n}", "path": "src\\ashxp\\jpeg-6b\\jchuff.c", "repo_name": "Kur0N3k0/Puff-UAF", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 10872}
{"docstring": "/*\n * Initialize master decompression control and select active modules.\n * This is performed at the start of jpeg_start_decompress.\n */\n", "func_signal": "GLOBAL(void)\njinit_master_decompress (j_decompress_ptr cinfo)", "code": "{\n  my_master_ptr master;\n\n  master = (my_master_ptr)\n      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\t  SIZEOF(my_decomp_master));\n  cinfo->master = (struct jpeg_decomp_master *) master;\n  master->pub.prepare_for_output_pass = prepare_for_output_pass;\n  master->pub.finish_output_pass = finish_output_pass;\n\n  master->pub.is_dummy_pass = FALSE;\n\n  master_selection(cinfo);\n}", "path": "src\\ashxp\\jpeg-6b\\jdmaster.c", "repo_name": "Kur0N3k0/Puff-UAF", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 10872}
{"docstring": "/*\n * Perform dequantization and inverse DCT on one block of coefficients.\n */\n", "func_signal": "GLOBAL(void)\njpeg_idct_islow (j_decompress_ptr cinfo, jpeg_component_info * compptr,\n\t\t JCOEFPTR coef_block,\n\t\t JSAMPARRAY output_buf, JDIMENSION output_col)", "code": "{\n  INT32 tmp0, tmp1, tmp2, tmp3;\n  INT32 tmp10, tmp11, tmp12, tmp13;\n  INT32 z1, z2, z3, z4, z5;\n  JCOEFPTR inptr;\n  ISLOW_MULT_TYPE * quantptr;\n  int * wsptr;\n  JSAMPROW outptr;\n  JSAMPLE *range_limit = IDCT_range_limit(cinfo);\n  int ctr;\n  int workspace[DCTSIZE2];\t/* buffers data between passes */\n  SHIFT_TEMPS\n\n  /* Pass 1: process columns from input, store into work array. */\n  /* Note results are scaled up by sqrt(8) compared to a true IDCT; */\n  /* furthermore, we scale the results by 2**PASS1_BITS. */\n\n  inptr = coef_block;\n  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;\n  wsptr = workspace;\n  for (ctr = DCTSIZE; ctr > 0; ctr--) {\n    /* Due to quantization, we will usually find that many of the input\n     * coefficients are zero, especially the AC terms.  We can exploit this\n     * by short-circuiting the IDCT calculation for any column in which all\n     * the AC terms are zero.  In that case each output is equal to the\n     * DC coefficient (with scale factor as needed).\n     * With typical images and quantization tables, half or more of the\n     * column DCT calculations can be simplified this way.\n     */\n    \n    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&\n\tinptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&\n\tinptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&\n\tinptr[DCTSIZE*7] == 0) {\n      /* AC terms all zero */\n      int dcval = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]) << PASS1_BITS;\n      \n      wsptr[DCTSIZE*0] = dcval;\n      wsptr[DCTSIZE*1] = dcval;\n      wsptr[DCTSIZE*2] = dcval;\n      wsptr[DCTSIZE*3] = dcval;\n      wsptr[DCTSIZE*4] = dcval;\n      wsptr[DCTSIZE*5] = dcval;\n      wsptr[DCTSIZE*6] = dcval;\n      wsptr[DCTSIZE*7] = dcval;\n      \n      inptr++;\t\t\t/* advance pointers to next column */\n      quantptr++;\n      wsptr++;\n      continue;\n    }\n    \n    /* Even part: reverse the even part of the forward DCT. */\n    /* The rotator is sqrt(2)*c(-6). */\n    \n    z2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);\n    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);\n    \n    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);\n    tmp2 = z1 + MULTIPLY(z3, - FIX_1_847759065);\n    tmp3 = z1 + MULTIPLY(z2, FIX_0_765366865);\n    \n    z2 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);\n    z3 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);\n\n    tmp0 = (z2 + z3) << CONST_BITS;\n    tmp1 = (z2 - z3) << CONST_BITS;\n    \n    tmp10 = tmp0 + tmp3;\n    tmp13 = tmp0 - tmp3;\n    tmp11 = tmp1 + tmp2;\n    tmp12 = tmp1 - tmp2;\n    \n    /* Odd part per figure 8; the matrix is unitary and hence its\n     * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.\n     */\n    \n    tmp0 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);\n    tmp1 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);\n    tmp2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);\n    tmp3 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);\n    \n    z1 = tmp0 + tmp3;\n    z2 = tmp1 + tmp2;\n    z3 = tmp0 + tmp2;\n    z4 = tmp1 + tmp3;\n    z5 = MULTIPLY(z3 + z4, FIX_1_175875602); /* sqrt(2) * c3 */\n    \n    tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */\n    tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */\n    tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */\n    tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */\n    z1 = MULTIPLY(z1, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */\n    z2 = MULTIPLY(z2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */\n    z3 = MULTIPLY(z3, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */\n    z4 = MULTIPLY(z4, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */\n    \n    z3 += z5;\n    z4 += z5;\n    \n    tmp0 += z1 + z3;\n    tmp1 += z2 + z4;\n    tmp2 += z2 + z3;\n    tmp3 += z1 + z4;\n    \n    /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */\n    \n    wsptr[DCTSIZE*0] = (int) DESCALE(tmp10 + tmp3, CONST_BITS-PASS1_BITS);\n    wsptr[DCTSIZE*7] = (int) DESCALE(tmp10 - tmp3, CONST_BITS-PASS1_BITS);\n    wsptr[DCTSIZE*1] = (int) DESCALE(tmp11 + tmp2, CONST_BITS-PASS1_BITS);\n    wsptr[DCTSIZE*6] = (int) DESCALE(tmp11 - tmp2, CONST_BITS-PASS1_BITS);\n    wsptr[DCTSIZE*2] = (int) DESCALE(tmp12 + tmp1, CONST_BITS-PASS1_BITS);\n    wsptr[DCTSIZE*5] = (int) DESCALE(tmp12 - tmp1, CONST_BITS-PASS1_BITS);\n    wsptr[DCTSIZE*3] = (int) DESCALE(tmp13 + tmp0, CONST_BITS-PASS1_BITS);\n    wsptr[DCTSIZE*4] = (int) DESCALE(tmp13 - tmp0, CONST_BITS-PASS1_BITS);\n    \n    inptr++;\t\t\t/* advance pointers to next column */\n    quantptr++;\n    wsptr++;\n  }\n  \n  /* Pass 2: process rows from work array, store into output array. */\n  /* Note that we must descale the results by a factor of 8 == 2**3, */\n  /* and also undo the PASS1_BITS scaling. */\n\n  wsptr = workspace;\n  for (ctr = 0; ctr < DCTSIZE; ctr++) {\n    outptr = output_buf[ctr] + output_col;\n    /* Rows of zeroes can be exploited in the same way as we did with columns.\n     * However, the column calculation has created many nonzero AC terms, so\n     * the simplification applies less often (typically 5% to 10% of the time).\n     * On machines with very fast multiplication, it's possible that the\n     * test takes more time than it's worth.  In that case this section\n     * may be commented out.\n     */\n    \n#ifndef NO_ZERO_ROW_TEST\n    if (wsptr[1] == 0 && wsptr[2] == 0 && wsptr[3] == 0 && wsptr[4] == 0 &&\n\twsptr[5] == 0 && wsptr[6] == 0 && wsptr[7] == 0) {\n      /* AC terms all zero */\n      JSAMPLE dcval = range_limit[(int) DESCALE((INT32) wsptr[0], PASS1_BITS+3)\n\t\t\t\t  & RANGE_MASK];\n      \n      outptr[0] = dcval;\n      outptr[1] = dcval;\n      outptr[2] = dcval;\n      outptr[3] = dcval;\n      outptr[4] = dcval;\n      outptr[5] = dcval;\n      outptr[6] = dcval;\n      outptr[7] = dcval;\n\n      wsptr += DCTSIZE;\t\t/* advance pointer to next row */\n      continue;\n    }\n#endif\n    \n    /* Even part: reverse the even part of the forward DCT. */\n    /* The rotator is sqrt(2)*c(-6). */\n    \n    z2 = (INT32) wsptr[2];\n    z3 = (INT32) wsptr[6];\n    \n    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);\n    tmp2 = z1 + MULTIPLY(z3, - FIX_1_847759065);\n    tmp3 = z1 + MULTIPLY(z2, FIX_0_765366865);\n    \n    tmp0 = ((INT32) wsptr[0] + (INT32) wsptr[4]) << CONST_BITS;\n    tmp1 = ((INT32) wsptr[0] - (INT32) wsptr[4]) << CONST_BITS;\n    \n    tmp10 = tmp0 + tmp3;\n    tmp13 = tmp0 - tmp3;\n    tmp11 = tmp1 + tmp2;\n    tmp12 = tmp1 - tmp2;\n    \n    /* Odd part per figure 8; the matrix is unitary and hence its\n     * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.\n     */\n    \n    tmp0 = (INT32) wsptr[7];\n    tmp1 = (INT32) wsptr[5];\n    tmp2 = (INT32) wsptr[3];\n    tmp3 = (INT32) wsptr[1];\n    \n    z1 = tmp0 + tmp3;\n    z2 = tmp1 + tmp2;\n    z3 = tmp0 + tmp2;\n    z4 = tmp1 + tmp3;\n    z5 = MULTIPLY(z3 + z4, FIX_1_175875602); /* sqrt(2) * c3 */\n    \n    tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */\n    tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */\n    tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */\n    tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */\n    z1 = MULTIPLY(z1, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */\n    z2 = MULTIPLY(z2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */\n    z3 = MULTIPLY(z3, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */\n    z4 = MULTIPLY(z4, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */\n    \n    z3 += z5;\n    z4 += z5;\n    \n    tmp0 += z1 + z3;\n    tmp1 += z2 + z4;\n    tmp2 += z2 + z3;\n    tmp3 += z1 + z4;\n    \n    /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */\n    \n    outptr[0] = range_limit[(int) DESCALE(tmp10 + tmp3,\n\t\t\t\t\t  CONST_BITS+PASS1_BITS+3)\n\t\t\t    & RANGE_MASK];\n    outptr[7] = range_limit[(int) DESCALE(tmp10 - tmp3,\n\t\t\t\t\t  CONST_BITS+PASS1_BITS+3)\n\t\t\t    & RANGE_MASK];\n    outptr[1] = range_limit[(int) DESCALE(tmp11 + tmp2,\n\t\t\t\t\t  CONST_BITS+PASS1_BITS+3)\n\t\t\t    & RANGE_MASK];\n    outptr[6] = range_limit[(int) DESCALE(tmp11 - tmp2,\n\t\t\t\t\t  CONST_BITS+PASS1_BITS+3)\n\t\t\t    & RANGE_MASK];\n    outptr[2] = range_limit[(int) DESCALE(tmp12 + tmp1,\n\t\t\t\t\t  CONST_BITS+PASS1_BITS+3)\n\t\t\t    & RANGE_MASK];\n    outptr[5] = range_limit[(int) DESCALE(tmp12 - tmp1,\n\t\t\t\t\t  CONST_BITS+PASS1_BITS+3)\n\t\t\t    & RANGE_MASK];\n    outptr[3] = range_limit[(int) DESCALE(tmp13 + tmp0,\n\t\t\t\t\t  CONST_BITS+PASS1_BITS+3)\n\t\t\t    & RANGE_MASK];\n    outptr[4] = range_limit[(int) DESCALE(tmp13 - tmp0,\n\t\t\t\t\t  CONST_BITS+PASS1_BITS+3)\n\t\t\t    & RANGE_MASK];\n    \n    wsptr += DCTSIZE;\t\t/* advance pointer to next row */\n  }\n}", "path": "src\\ashxp\\jpeg-6b\\jidctint.c", "repo_name": "Kur0N3k0/Puff-UAF", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 10872}
{"docstring": "/*\n * Switch to a new external colormap between output passes.\n */\n", "func_signal": "GLOBAL(void)\njpeg_new_colormap (j_decompress_ptr cinfo)", "code": "{\n  my_master_ptr master = (my_master_ptr) cinfo->master;\n\n  /* Prevent application from calling me at wrong times */\n  if (cinfo->global_state != DSTATE_BUFIMAGE)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n\n  if (cinfo->quantize_colors && cinfo->enable_external_quant &&\n      cinfo->colormap != NULL) {\n    /* Select 2-pass quantizer for external colormap use */\n    cinfo->cquantize = master->quantizer_2pass;\n    /* Notify quantizer of colormap change */\n    (*cinfo->cquantize->new_color_map) (cinfo);\n    master->pub.is_dummy_pass = FALSE; /* just in case */\n  } else\n    ERREXIT(cinfo, JERR_MODE_CHANGE);\n}", "path": "src\\ashxp\\jpeg-6b\\jdmaster.c", "repo_name": "Kur0N3k0/Puff-UAF", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 10872}
{"docstring": "/*\n * Initialize the marker writer module.\n */\n", "func_signal": "GLOBAL(void)\njinit_marker_writer (j_compress_ptr cinfo)", "code": "{\n  my_marker_ptr marker;\n\n  /* Create the subobject */\n  marker = (my_marker_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\tSIZEOF(my_marker_writer));\n  cinfo->marker = (struct jpeg_marker_writer *) marker;\n  /* Initialize method pointers */\n  marker->pub.write_file_header = write_file_header;\n  marker->pub.write_frame_header = write_frame_header;\n  marker->pub.write_scan_header = write_scan_header;\n  marker->pub.write_file_trailer = write_file_trailer;\n  marker->pub.write_tables_only = write_tables_only;\n  marker->pub.write_marker_header = write_marker_header;\n  marker->pub.write_marker_byte = write_marker_byte;\n  /* Initialize private state */\n  marker->last_restart_interval = 0;\n}", "path": "src\\ashxp\\jpeg-6b\\jcmarker.c", "repo_name": "Kur0N3k0/Puff-UAF", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 10872}
{"docstring": "/*\n * Master selection of decompression modules.\n * This is done once at jpeg_start_decompress time.  We determine\n * which modules will be used and give them appropriate initialization calls.\n * We also initialize the decompressor input side to begin consuming data.\n *\n * Since jpeg_read_header has finished, we know what is in the SOF\n * and (first) SOS markers.  We also have all the application parameter\n * settings.\n */\n", "func_signal": "LOCAL(void)\nmaster_selection (j_decompress_ptr cinfo)", "code": "{\n  my_master_ptr master = (my_master_ptr) cinfo->master;\n  boolean use_c_buffer;\n  long samplesperrow;\n  JDIMENSION jd_samplesperrow;\n\n  /* Initialize dimensions and other stuff */\n  jpeg_calc_output_dimensions(cinfo);\n  prepare_range_limit_table(cinfo);\n\n  /* Width of an output scanline must be representable as JDIMENSION. */\n  samplesperrow = (long) cinfo->output_width * (long) cinfo->out_color_components;\n  jd_samplesperrow = (JDIMENSION) samplesperrow;\n  if ((long) jd_samplesperrow != samplesperrow)\n    ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);\n\n  /* Initialize my private state */\n  master->pass_number = 0;\n  master->using_merged_upsample = use_merged_upsample(cinfo);\n\n  /* Color quantizer selection */\n  master->quantizer_1pass = NULL;\n  master->quantizer_2pass = NULL;\n  /* No mode changes if not using buffered-image mode. */\n  if (! cinfo->quantize_colors || ! cinfo->buffered_image) {\n    cinfo->enable_1pass_quant = FALSE;\n    cinfo->enable_external_quant = FALSE;\n    cinfo->enable_2pass_quant = FALSE;\n  }\n  if (cinfo->quantize_colors) {\n    if (cinfo->raw_data_out)\n      ERREXIT(cinfo, JERR_NOTIMPL);\n    /* 2-pass quantizer only works in 3-component color space. */\n    if (cinfo->out_color_components != 3) {\n      cinfo->enable_1pass_quant = TRUE;\n      cinfo->enable_external_quant = FALSE;\n      cinfo->enable_2pass_quant = FALSE;\n      cinfo->colormap = NULL;\n    } else if (cinfo->colormap != NULL) {\n      cinfo->enable_external_quant = TRUE;\n    } else if (cinfo->two_pass_quantize) {\n      cinfo->enable_2pass_quant = TRUE;\n    } else {\n      cinfo->enable_1pass_quant = TRUE;\n    }\n\n    if (cinfo->enable_1pass_quant) {\n#ifdef QUANT_1PASS_SUPPORTED\n      jinit_1pass_quantizer(cinfo);\n      master->quantizer_1pass = cinfo->cquantize;\n#else\n      ERREXIT(cinfo, JERR_NOT_COMPILED);\n#endif\n    }\n\n    /* We use the 2-pass code to map to external colormaps. */\n    if (cinfo->enable_2pass_quant || cinfo->enable_external_quant) {\n#ifdef QUANT_2PASS_SUPPORTED\n      jinit_2pass_quantizer(cinfo);\n      master->quantizer_2pass = cinfo->cquantize;\n#else\n      ERREXIT(cinfo, JERR_NOT_COMPILED);\n#endif\n    }\n    /* If both quantizers are initialized, the 2-pass one is left active;\n     * this is necessary for starting with quantization to an external map.\n     */\n  }\n\n  /* Post-processing: in particular, color conversion first */\n  if (! cinfo->raw_data_out) {\n    if (master->using_merged_upsample) {\n#ifdef UPSAMPLE_MERGING_SUPPORTED\n      jinit_merged_upsampler(cinfo); /* does color conversion too */\n#else\n      ERREXIT(cinfo, JERR_NOT_COMPILED);\n#endif\n    } else {\n      jinit_color_deconverter(cinfo);\n      jinit_upsampler(cinfo);\n    }\n    jinit_d_post_controller(cinfo, cinfo->enable_2pass_quant);\n  }\n  /* Inverse DCT */\n  jinit_inverse_dct(cinfo);\n  /* Entropy decoding: either Huffman or arithmetic coding. */\n  if (cinfo->arith_code) {\n    ERREXIT(cinfo, JERR_ARITH_NOTIMPL);\n  } else {\n    if (cinfo->progressive_mode) {\n#ifdef D_PROGRESSIVE_SUPPORTED\n      jinit_phuff_decoder(cinfo);\n#else\n      ERREXIT(cinfo, JERR_NOT_COMPILED);\n#endif\n    } else\n      jinit_huff_decoder(cinfo);\n  }\n\n  /* Initialize principal buffer controllers. */\n  use_c_buffer = cinfo->inputctl->has_multiple_scans || cinfo->buffered_image;\n  jinit_d_coef_controller(cinfo, use_c_buffer);\n\n  if (! cinfo->raw_data_out)\n    jinit_d_main_controller(cinfo, FALSE /* never need full buffer here */);\n\n  /* We can now tell the memory manager to allocate virtual arrays. */\n  (*cinfo->mem->realize_virt_arrays) ((j_common_ptr) cinfo);\n\n  /* Initialize input side of decompressor to consume first scan. */\n  (*cinfo->inputctl->start_input_pass) (cinfo);\n\n#ifdef D_MULTISCAN_FILES_SUPPORTED\n  /* If jpeg_start_decompress will read the whole file, initialize\n   * progress monitoring appropriately.  The input step is counted\n   * as one pass.\n   */\n  if (cinfo->progress != NULL && ! cinfo->buffered_image &&\n      cinfo->inputctl->has_multiple_scans) {\n    int nscans;\n    /* Estimate number of scans to set pass_limit. */\n    if (cinfo->progressive_mode) {\n      /* Arbitrarily estimate 2 interleaved DC scans + 3 AC scans/component. */\n      nscans = 2 + 3 * cinfo->num_components;\n    } else {\n      /* For a nonprogressive multiscan file, estimate 1 scan per component. */\n      nscans = cinfo->num_components;\n    }\n    cinfo->progress->pass_counter = 0L;\n    cinfo->progress->pass_limit = (long) cinfo->total_iMCU_rows * nscans;\n    cinfo->progress->completed_passes = 0;\n    cinfo->progress->total_passes = (cinfo->enable_2pass_quant ? 3 : 2);\n    /* Count the input pass as done */\n    master->pass_number++;\n  }\n#endif /* D_MULTISCAN_FILES_SUPPORTED */\n}", "path": "src\\ashxp\\jpeg-6b\\jdmaster.c", "repo_name": "Kur0N3k0/Puff-UAF", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 10872}
{"docstring": "/*\n * Write frame header.\n * This consists of DQT and SOFn markers.\n * Note that we do not emit the SOF until we have emitted the DQT(s).\n * This avoids compatibility problems with incorrect implementations that\n * try to error-check the quant table numbers as soon as they see the SOF.\n */\n", "func_signal": "METHODDEF(void)\nwrite_frame_header (j_compress_ptr cinfo)", "code": "{\n  int ci, prec;\n  boolean is_baseline;\n  jpeg_component_info *compptr;\n  \n  /* Emit DQT for each quantization table.\n   * Note that emit_dqt() suppresses any duplicate tables.\n   */\n  prec = 0;\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n       ci++, compptr++) {\n    prec += emit_dqt(cinfo, compptr->quant_tbl_no);\n  }\n  /* now prec is nonzero iff there are any 16-bit quant tables. */\n\n  /* Check for a non-baseline specification.\n   * Note we assume that Huffman table numbers won't be changed later.\n   */\n  if (cinfo->arith_code || cinfo->progressive_mode ||\n      cinfo->data_precision != 8) {\n    is_baseline = FALSE;\n  } else {\n    is_baseline = TRUE;\n    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n\t ci++, compptr++) {\n      if (compptr->dc_tbl_no > 1 || compptr->ac_tbl_no > 1)\n\tis_baseline = FALSE;\n    }\n    if (prec && is_baseline) {\n      is_baseline = FALSE;\n      /* If it's baseline except for quantizer size, warn the user */\n      TRACEMS(cinfo, 0, JTRC_16BIT_TABLES);\n    }\n  }\n\n  /* Emit the proper SOF marker */\n  if (cinfo->arith_code) {\n    emit_sof(cinfo, M_SOF9);\t/* SOF code for arithmetic coding */\n  } else {\n    if (cinfo->progressive_mode)\n      emit_sof(cinfo, M_SOF2);\t/* SOF code for progressive Huffman */\n    else if (is_baseline)\n      emit_sof(cinfo, M_SOF0);\t/* SOF code for baseline implementation */\n    else\n      emit_sof(cinfo, M_SOF1);\t/* SOF code for non-baseline Huffman file */\n  }\n}", "path": "src\\ashxp\\jpeg-6b\\jcmarker.c", "repo_name": "Kur0N3k0/Puff-UAF", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 10872}
{"docstring": "/*\n * Per-pass setup.\n * This is called at the beginning of each output pass.  We determine which\n * modules will be active during this pass and give them appropriate\n * start_pass calls.  We also set is_dummy_pass to indicate whether this\n * is a \"real\" output pass or a dummy pass for color quantization.\n * (In the latter case, jdapistd.c will crank the pass to completion.)\n */\n", "func_signal": "METHODDEF(void)\nprepare_for_output_pass (j_decompress_ptr cinfo)", "code": "{\n  my_master_ptr master = (my_master_ptr) cinfo->master;\n\n  if (master->pub.is_dummy_pass) {\n#ifdef QUANT_2PASS_SUPPORTED\n    /* Final pass of 2-pass quantization */\n    master->pub.is_dummy_pass = FALSE;\n    (*cinfo->cquantize->start_pass) (cinfo, FALSE);\n    (*cinfo->post->start_pass) (cinfo, JBUF_CRANK_DEST);\n    (*cinfo->main->start_pass) (cinfo, JBUF_CRANK_DEST);\n#else\n    ERREXIT(cinfo, JERR_NOT_COMPILED);\n#endif /* QUANT_2PASS_SUPPORTED */\n  } else {\n    if (cinfo->quantize_colors && cinfo->colormap == NULL) {\n      /* Select new quantization method */\n      if (cinfo->two_pass_quantize && cinfo->enable_2pass_quant) {\n\tcinfo->cquantize = master->quantizer_2pass;\n\tmaster->pub.is_dummy_pass = TRUE;\n      } else if (cinfo->enable_1pass_quant) {\n\tcinfo->cquantize = master->quantizer_1pass;\n      } else {\n\tERREXIT(cinfo, JERR_MODE_CHANGE);\n      }\n    }\n    (*cinfo->idct->start_pass) (cinfo);\n    (*cinfo->coef->start_output_pass) (cinfo);\n    if (! cinfo->raw_data_out) {\n      if (! master->using_merged_upsample)\n\t(*cinfo->cconvert->start_pass) (cinfo);\n      (*cinfo->upsample->start_pass) (cinfo);\n      if (cinfo->quantize_colors)\n\t(*cinfo->cquantize->start_pass) (cinfo, master->pub.is_dummy_pass);\n      (*cinfo->post->start_pass) (cinfo,\n\t    (master->pub.is_dummy_pass ? JBUF_SAVE_AND_PASS : JBUF_PASS_THRU));\n      (*cinfo->main->start_pass) (cinfo, JBUF_PASS_THRU);\n    }\n  }\n\n  /* Set up progress monitor's pass info if present */\n  if (cinfo->progress != NULL) {\n    cinfo->progress->completed_passes = master->pass_number;\n    cinfo->progress->total_passes = master->pass_number +\n\t\t\t\t    (master->pub.is_dummy_pass ? 2 : 1);\n    /* In buffered-image mode, we assume one more output pass if EOI not\n     * yet reached, but no more passes if EOI has been reached.\n     */\n    if (cinfo->buffered_image && ! cinfo->inputctl->eoi_reached) {\n      cinfo->progress->total_passes += (cinfo->enable_2pass_quant ? 2 : 1);\n    }\n  }\n}", "path": "src\\ashxp\\jpeg-6b\\jdmaster.c", "repo_name": "Kur0N3k0/Puff-UAF", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 10872}
{"docstring": "/**\n  * @brief  Clears the SPIx CRC Error (CRCERR) flag.\n  * @param  SPIx: where x can be\n  *   - 1, 2 or 3 in SPI mode \n  * @param  SPI_I2S_FLAG: specifies the SPI flag to clear. \n  *   This function clears only CRCERR flag.\n  * @note\n  *   - OVR (OverRun error) flag is cleared by software sequence: a read \n  *     operation to SPI_DR register (SPI_I2S_ReceiveData()) followed by a read \n  *     operation to SPI_SR register (SPI_I2S_GetFlagStatus()).\n  *   - UDR (UnderRun error) flag is cleared by a read operation to \n  *     SPI_SR register (SPI_I2S_GetFlagStatus()).\n  *   - MODF (Mode Fault) flag is cleared by software sequence: a read/write \n  *     operation to SPI_SR register (SPI_I2S_GetFlagStatus()) followed by a \n  *     write operation to SPI_CR1 register (SPI_Cmd() to enable the SPI).\n  * @retval None\n  */\n", "func_signal": "void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_SPI_ALL_PERIPH(SPIx));\n  assert_param(IS_SPI_I2S_CLEAR_FLAG(SPI_I2S_FLAG));\n    \n    /* Clear the selected SPI CRC Error (CRCERR) flag */\n    SPIx->SR = (uint16_t)~SPI_I2S_FLAG;\n}", "path": "SensorTest\\lib\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_spi.c", "repo_name": "adamgreig/Robot4", "stars": 1, "license": "None", "language": "c", "size": 348}
{"docstring": "/**\n  * @brief  Selects the data transfer direction in bi-directional mode for the specified SPI.\n  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.\n  * @param  SPI_Direction: specifies the data transfer direction in bi-directional mode. \n  *   This parameter can be one of the following values:\n  *     @arg SPI_Direction_Tx: Selects Tx transmission direction\n  *     @arg SPI_Direction_Rx: Selects Rx receive direction\n  * @retval None\n  */\n", "func_signal": "void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_SPI_ALL_PERIPH(SPIx));\n  assert_param(IS_SPI_DIRECTION(SPI_Direction));\n  if (SPI_Direction == SPI_Direction_Tx)\n  {\n    /* Set the Tx only mode */\n    SPIx->CR1 |= SPI_Direction_Tx;\n  }\n  else\n  {\n    /* Set the Rx only mode */\n    SPIx->CR1 &= SPI_Direction_Rx;\n  }\n}", "path": "SensorTest\\lib\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_spi.c", "repo_name": "adamgreig/Robot4", "stars": 1, "license": "None", "language": "c", "size": 348}
{"docstring": "/**\n  * @brief  Returns the most recent received data by the SPIx/I2Sx peripheral. \n  * @param  SPIx: where x can be\n  *   - 1, 2 or 3 in SPI mode \n  *   - 2 or 3 in I2S mode\n  * @retval The value of the received data.\n  */\n", "func_signal": "uint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_SPI_ALL_PERIPH(SPIx));\n  \n  /* Return the data in the DR register */\n  return SPIx->DR;\n}", "path": "SensorTest\\lib\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_spi.c", "repo_name": "adamgreig/Robot4", "stars": 1, "license": "None", "language": "c", "size": 348}
{"docstring": "/**\n  * @brief  Enables or disables the specified SPI peripheral (in I2S mode).\n  * @param  SPIx: where x can be 2 or 3 to select the SPI peripheral.\n  * @param  NewState: new state of the SPIx peripheral. \n  *   This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_SPI_23_PERIPH(SPIx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE)\n  {\n    /* Enable the selected SPI peripheral (in I2S mode) */\n    SPIx->I2SCFGR |= I2SCFGR_I2SE_Set;\n  }\n  else\n  {\n    /* Disable the selected SPI peripheral (in I2S mode) */\n    SPIx->I2SCFGR &= I2SCFGR_I2SE_Reset;\n  }\n}", "path": "SensorTest\\lib\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_spi.c", "repo_name": "adamgreig/Robot4", "stars": 1, "license": "None", "language": "c", "size": 348}
{"docstring": "/**\n  * @brief  Enables or disables the specified SPI/I2S interrupts.\n  * @param  SPIx: where x can be\n  *   - 1, 2 or 3 in SPI mode \n  *   - 2 or 3 in I2S mode\n  * @param  SPI_I2S_IT: specifies the SPI/I2S interrupt source to be enabled or disabled. \n  *   This parameter can be one of the following values:\n  *     @arg SPI_I2S_IT_TXE: Tx buffer empty interrupt mask\n  *     @arg SPI_I2S_IT_RXNE: Rx buffer not empty interrupt mask\n  *     @arg SPI_I2S_IT_ERR: Error interrupt mask\n  * @param  NewState: new state of the specified SPI/I2S interrupt.\n  *   This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState)", "code": "{\n  uint16_t itpos = 0, itmask = 0 ;\n  /* Check the parameters */\n  assert_param(IS_SPI_ALL_PERIPH(SPIx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  assert_param(IS_SPI_I2S_CONFIG_IT(SPI_I2S_IT));\n\n  /* Get the SPI/I2S IT index */\n  itpos = SPI_I2S_IT >> 4;\n\n  /* Set the IT mask */\n  itmask = (uint16_t)1 << (uint16_t)itpos;\n\n  if (NewState != DISABLE)\n  {\n    /* Enable the selected SPI/I2S interrupt */\n    SPIx->CR2 |= itmask;\n  }\n  else\n  {\n    /* Disable the selected SPI/I2S interrupt */\n    SPIx->CR2 &= (uint16_t)~itmask;\n  }\n}", "path": "SensorTest\\lib\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_spi.c", "repo_name": "adamgreig/Robot4", "stars": 1, "license": "None", "language": "c", "size": 348}
{"docstring": "/**\n  * @brief  Fills each SPI_InitStruct member with its default value.\n  * @param  SPI_InitStruct : pointer to a SPI_InitTypeDef structure which will be initialized.\n  * @retval None\n  */\n", "func_signal": "void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)", "code": "{\n/*--------------- Reset SPI init structure parameters values -----------------*/\n  /* Initialize the SPI_Direction member */\n  SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;\n  /* initialize the SPI_Mode member */\n  SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;\n  /* initialize the SPI_DataSize member */\n  SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;\n  /* Initialize the SPI_CPOL member */\n  SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;\n  /* Initialize the SPI_CPHA member */\n  SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;\n  /* Initialize the SPI_NSS member */\n  SPI_InitStruct->SPI_NSS = SPI_NSS_Hard;\n  /* Initialize the SPI_BaudRatePrescaler member */\n  SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;\n  /* Initialize the SPI_FirstBit member */\n  SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;\n  /* Initialize the SPI_CRCPolynomial member */\n  SPI_InitStruct->SPI_CRCPolynomial = 7;\n}", "path": "SensorTest\\lib\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_spi.c", "repo_name": "adamgreig/Robot4", "stars": 1, "license": "None", "language": "c", "size": 348}
{"docstring": "/**\n  * @brief  Transmits a Data through the SPIx/I2Sx peripheral.\n  * @param  SPIx: where x can be\n  *   - 1, 2 or 3 in SPI mode \n  *   - 2 or 3 in I2S mode\n  * @param  Data : Data to be transmitted.\n  * @retval None\n  */\n", "func_signal": "void SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_SPI_ALL_PERIPH(SPIx));\n  \n  /* Write in the DR register the data to be sent */\n  SPIx->DR = Data;\n}", "path": "SensorTest\\lib\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_spi.c", "repo_name": "adamgreig/Robot4", "stars": 1, "license": "None", "language": "c", "size": 348}
{"docstring": "/**\n  * @brief  Enables or disables the CRC value calculation of the transfered bytes.\n  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.\n  * @param  NewState: new state of the SPIx CRC value calculation.\n  *   This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_SPI_ALL_PERIPH(SPIx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE)\n  {\n    /* Enable the selected SPI CRC calculation */\n    SPIx->CR1 |= CR1_CRCEN_Set;\n  }\n  else\n  {\n    /* Disable the selected SPI CRC calculation */\n    SPIx->CR1 &= CR1_CRCEN_Reset;\n  }\n}", "path": "SensorTest\\lib\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_spi.c", "repo_name": "adamgreig/Robot4", "stars": 1, "license": "None", "language": "c", "size": 348}
{"docstring": "/**\n  * @brief  Fills each I2S_InitStruct member with its default value.\n  * @param  I2S_InitStruct : pointer to a I2S_InitTypeDef structure which will be initialized.\n  * @retval None\n  */\n", "func_signal": "void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)", "code": "{\n/*--------------- Reset I2S init structure parameters values -----------------*/\n  /* Initialize the I2S_Mode member */\n  I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;\n  \n  /* Initialize the I2S_Standard member */\n  I2S_InitStruct->I2S_Standard = I2S_Standard_Phillips;\n  \n  /* Initialize the I2S_DataFormat member */\n  I2S_InitStruct->I2S_DataFormat = I2S_DataFormat_16b;\n  \n  /* Initialize the I2S_MCLKOutput member */\n  I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;\n  \n  /* Initialize the I2S_AudioFreq member */\n  I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;\n  \n  /* Initialize the I2S_CPOL member */\n  I2S_InitStruct->I2S_CPOL = I2S_CPOL_Low;\n}", "path": "SensorTest\\lib\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_spi.c", "repo_name": "adamgreig/Robot4", "stars": 1, "license": "None", "language": "c", "size": 348}
{"docstring": "/**\n  * @brief  Enables or disables the specified SPI peripheral.\n  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.\n  * @param  NewState: new state of the SPIx peripheral. \n  *   This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_SPI_ALL_PERIPH(SPIx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE)\n  {\n    /* Enable the selected SPI peripheral */\n    SPIx->CR1 |= CR1_SPE_Set;\n  }\n  else\n  {\n    /* Disable the selected SPI peripheral */\n    SPIx->CR1 &= CR1_SPE_Reset;\n  }\n}", "path": "SensorTest\\lib\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_spi.c", "repo_name": "adamgreig/Robot4", "stars": 1, "license": "None", "language": "c", "size": 348}
{"docstring": "/**\n  * @brief  Configures the data size for the selected SPI.\n  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.\n  * @param  SPI_DataSize: specifies the SPI data size.\n  *   This parameter can be one of the following values:\n  *     @arg SPI_DataSize_16b: Set data frame format to 16bit\n  *     @arg SPI_DataSize_8b: Set data frame format to 8bit\n  * @retval None\n  */\n", "func_signal": "void SPI_DataSizeConfig(SPI_TypeDef* SPIx, uint16_t SPI_DataSize)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_SPI_ALL_PERIPH(SPIx));\n  assert_param(IS_SPI_DATASIZE(SPI_DataSize));\n  /* Clear DFF bit */\n  SPIx->CR1 &= (uint16_t)~SPI_DataSize_16b;\n  /* Set new DFF bit value */\n  SPIx->CR1 |= SPI_DataSize;\n}", "path": "SensorTest\\lib\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_spi.c", "repo_name": "adamgreig/Robot4", "stars": 1, "license": "None", "language": "c", "size": 348}
{"docstring": "/**\n  * @brief  Enables or disables the SS output for the selected SPI.\n  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.\n  * @param  NewState: new state of the SPIx SS output. \n  *   This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\n", "func_signal": "void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_SPI_ALL_PERIPH(SPIx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE)\n  {\n    /* Enable the selected SPI SS output */\n    SPIx->CR2 |= CR2_SSOE_Set;\n  }\n  else\n  {\n    /* Disable the selected SPI SS output */\n    SPIx->CR2 &= CR2_SSOE_Reset;\n  }\n}", "path": "SensorTest\\lib\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_spi.c", "repo_name": "adamgreig/Robot4", "stars": 1, "license": "None", "language": "c", "size": 348}
{"docstring": "/**\n  * @brief  Initializes the SPIx peripheral according to the specified \n  *   parameters in the SPI_InitStruct.\n  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.\n  * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure that\n  *   contains the configuration information for the specified SPI peripheral.\n  * @retval None\n  */\n", "func_signal": "void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)", "code": "{\n  uint16_t tmpreg = 0;\n  \n  /* check the parameters */\n  assert_param(IS_SPI_ALL_PERIPH(SPIx));   \n  \n  /* Check the SPI parameters */\n  assert_param(IS_SPI_DIRECTION_MODE(SPI_InitStruct->SPI_Direction));\n  assert_param(IS_SPI_MODE(SPI_InitStruct->SPI_Mode));\n  assert_param(IS_SPI_DATASIZE(SPI_InitStruct->SPI_DataSize));\n  assert_param(IS_SPI_CPOL(SPI_InitStruct->SPI_CPOL));\n  assert_param(IS_SPI_CPHA(SPI_InitStruct->SPI_CPHA));\n  assert_param(IS_SPI_NSS(SPI_InitStruct->SPI_NSS));\n  assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_InitStruct->SPI_BaudRatePrescaler));\n  assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));\n  assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));\n\n/*---------------------------- SPIx CR1 Configuration ------------------------*/\n  /* Get the SPIx CR1 value */\n  tmpreg = SPIx->CR1;\n  /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */\n  tmpreg &= CR1_CLEAR_Mask;\n  /* Configure SPIx: direction, NSS management, first transmitted bit, BaudRate prescaler\n     master/salve mode, CPOL and CPHA */\n  /* Set BIDImode, BIDIOE and RxONLY bits according to SPI_Direction value */\n  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */\n  /* Set LSBFirst bit according to SPI_FirstBit value */\n  /* Set BR bits according to SPI_BaudRatePrescaler value */\n  /* Set CPOL bit according to SPI_CPOL value */\n  /* Set CPHA bit according to SPI_CPHA value */\n  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |\n                  SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  \n                  SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  \n                  SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);\n  /* Write to SPIx CR1 */\n  SPIx->CR1 = tmpreg;\n  \n  /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */\n  SPIx->I2SCFGR &= SPI_Mode_Select;\t\t\n\n/*---------------------------- SPIx CRCPOLY Configuration --------------------*/\n  /* Write to SPIx CRCPOLY */\n  SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;\n}", "path": "SensorTest\\lib\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_spi.c", "repo_name": "adamgreig/Robot4", "stars": 1, "license": "None", "language": "c", "size": 348}
{"docstring": "/**\n  * @brief  Returns the transmit or the receive CRC register value for the specified SPI.\n  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.\n  * @param  SPI_CRC: specifies the CRC register to be read.\n  *   This parameter can be one of the following values:\n  *     @arg SPI_CRC_Tx: Selects Tx CRC register\n  *     @arg SPI_CRC_Rx: Selects Rx CRC register\n  * @retval The selected CRC register value..\n  */\n", "func_signal": "uint16_t SPI_GetCRC(SPI_TypeDef* SPIx, uint8_t SPI_CRC)", "code": "{\n  uint16_t crcreg = 0;\n  /* Check the parameters */\n  assert_param(IS_SPI_ALL_PERIPH(SPIx));\n  assert_param(IS_SPI_CRC(SPI_CRC));\n  if (SPI_CRC != SPI_CRC_Rx)\n  {\n    /* Get the Tx CRC register */\n    crcreg = SPIx->TXCRCR;\n  }\n  else\n  {\n    /* Get the Rx CRC register */\n    crcreg = SPIx->RXCRCR;\n  }\n  /* Return the selected CRC register */\n  return crcreg;\n}", "path": "SensorTest\\lib\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_spi.c", "repo_name": "adamgreig/Robot4", "stars": 1, "license": "None", "language": "c", "size": 348}
{"docstring": "/**\n  * @brief  Initializes the SPIx peripheral according to the specified \n  *   parameters in the I2S_InitStruct.\n  * @param  SPIx: where x can be  2 or 3 to select the SPI peripheral\n  *   (configured in I2S mode).\n  * @param  I2S_InitStruct: pointer to an I2S_InitTypeDef structure that\n  *   contains the configuration information for the specified SPI peripheral\n  *   configured in I2S mode.\n  * @note\n  *  The function calculates the optimal prescaler needed to obtain the most \n  *  accurate audio frequency (depending on the I2S clock source, the PLL values \n  *  and the product configuration). But in case the prescaler value is greater \n  *  than 511, the default value (0x02) will be configured instead.  *   \n  * @retval None\n  */\n", "func_signal": "void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)", "code": "{\n  uint16_t tmpreg = 0, i2sdiv = 2, i2sodd = 0, packetlength = 1;\n  uint32_t tmp = 0;\n  RCC_ClocksTypeDef RCC_Clocks;\n  uint32_t sourceclock = 0;\n  \n  /* Check the I2S parameters */\n  assert_param(IS_SPI_23_PERIPH(SPIx));\n  assert_param(IS_I2S_MODE(I2S_InitStruct->I2S_Mode));\n  assert_param(IS_I2S_STANDARD(I2S_InitStruct->I2S_Standard));\n  assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));\n  assert_param(IS_I2S_MCLK_OUTPUT(I2S_InitStruct->I2S_MCLKOutput));\n  assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));\n  assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  \n\n/*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/\n  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */\n  SPIx->I2SCFGR &= I2SCFGR_CLEAR_Mask; \n  SPIx->I2SPR = 0x0002;\n  \n  /* Get the I2SCFGR register value */\n  tmpreg = SPIx->I2SCFGR;\n  \n  /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/\n  if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)\n  {\n    i2sodd = (uint16_t)0;\n    i2sdiv = (uint16_t)2;   \n  }\n  /* If the requested audio frequency is not the default, compute the prescaler */\n  else\n  {\n    /* Check the frame length (For the Prescaler computing) */\n    if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)\n    {\n      /* Packet length is 16 bits */\n      packetlength = 1;\n    }\n    else\n    {\n      /* Packet length is 32 bits */\n      packetlength = 2;\n    }\n\n    /* Get the I2S clock source mask depending on the peripheral number */\n    if(((uint32_t)SPIx) == SPI2_BASE)\n    {\n      /* The mask is relative to I2S2 */\n      tmp = I2S2_CLOCK_SRC;\n    }\n    else \n    {\n      /* The mask is relative to I2S3 */      \n      tmp = I2S3_CLOCK_SRC;\n    }\n\n    /* Check the I2S clock source configuration depending on the Device:\n       Only Connectivity line devices have the PLL3 VCO clock */\n#ifdef STM32F10X_CL\n    if((RCC->CFGR2 & tmp) != 0)\n    {\n      /* Get the configuration bits of RCC PLL3 multiplier */\n      tmp = (uint32_t)((RCC->CFGR2 & I2S_MUL_MASK) >> 12);\n\n      /* Get the value of the PLL3 multiplier */      \n      if((tmp > 5) && (tmp < 15))\n      {\n        /* Multplier is between 8 and 14 (value 15 is forbidden) */\n        tmp += 2;\n      }\n      else\n      {\n        if (tmp == 15)\n        {\n          /* Multiplier is 20 */\n          tmp = 20;\n        }\n      }      \n      /* Get the PREDIV2 value */\n      sourceclock = (uint32_t)(((RCC->CFGR2 & I2S_DIV_MASK) >> 4) + 1);\n      \n      /* Calculate the Source Clock frequency based on PLL3 and PREDIV2 values */\n      sourceclock = (uint32_t) ((HSE_Value / sourceclock) * tmp * 2); \n    }\n    else\n    {\n      /* I2S Clock source is System clock: Get System Clock frequency */\n      RCC_GetClocksFreq(&RCC_Clocks);      \n      \n      /* Get the source clock value: based on System Clock value */\n      sourceclock = RCC_Clocks.SYSCLK_Frequency;\n    }        \n#else /* STM32F10X_HD */\n    /* I2S Clock source is System clock: Get System Clock frequency */\n    RCC_GetClocksFreq(&RCC_Clocks);      \n      \n    /* Get the source clock value: based on System Clock value */\n    sourceclock = RCC_Clocks.SYSCLK_Frequency;    \n#endif /* STM32F10X_CL */    \n\n    /* Compute the Real divider depending on the MCLK output state with a flaoting point */\n    if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)\n    {\n      /* MCLK output is enabled */\n      tmp = (uint16_t)(((((sourceclock / 256) * 10) / I2S_InitStruct->I2S_AudioFreq)) + 5);\n    }\n    else\n    {\n      /* MCLK output is disabled */\n      tmp = (uint16_t)(((((sourceclock / (32 * packetlength)) *10 ) / I2S_InitStruct->I2S_AudioFreq)) + 5);\n    }\n    \n    /* Remove the flaoting point */\n    tmp = tmp / 10;  \n      \n    /* Check the parity of the divider */\n    i2sodd = (uint16_t)(tmp & (u16)0x0001);\n   \n    /* Compute the i2sdiv prescaler */\n    i2sdiv = (uint16_t)((tmp - i2sodd) / 2);\n   \n    /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */\n    i2sodd = (uint16_t) (i2sodd << 8);\n  }\n  \n  /* Test if the divider is 1 or 0 or greater than 0xFF */\n  if ((i2sdiv < 2) || (i2sdiv > 0xFF))\n  {\n    /* Set the default values */\n    i2sdiv = 2;\n    i2sodd = 0;\n  }\n\n  /* Write to SPIx I2SPR register the computed value */\n  SPIx->I2SPR = (uint16_t)(i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));  \n \n  /* Configure the I2S with the SPI_InitStruct values */\n  tmpreg |= (uint16_t)(I2S_Mode_Select | (uint16_t)(I2S_InitStruct->I2S_Mode | \\\n                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \\\n                  (uint16_t)I2S_InitStruct->I2S_CPOL))));\n \n  /* Write to SPIx I2SCFGR */  \n  SPIx->I2SCFGR = tmpreg;   \n}", "path": "SensorTest\\lib\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_spi.c", "repo_name": "adamgreig/Robot4", "stars": 1, "license": "None", "language": "c", "size": 348}
{"docstring": "/**\n  * @brief  Configures internally by software the NSS pin for the selected SPI.\n  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.\n  * @param  SPI_NSSInternalSoft: specifies the SPI NSS internal state.\n  *   This parameter can be one of the following values:\n  *     @arg SPI_NSSInternalSoft_Set: Set NSS pin internally\n  *     @arg SPI_NSSInternalSoft_Reset: Reset NSS pin internally\n  * @retval None\n  */\n", "func_signal": "void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_SPI_ALL_PERIPH(SPIx));\n  assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));\n  if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)\n  {\n    /* Set NSS pin internally by software */\n    SPIx->CR1 |= SPI_NSSInternalSoft_Set;\n  }\n  else\n  {\n    /* Reset NSS pin internally by software */\n    SPIx->CR1 &= SPI_NSSInternalSoft_Reset;\n  }\n}", "path": "SensorTest\\lib\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_spi.c", "repo_name": "adamgreig/Robot4", "stars": 1, "license": "None", "language": "c", "size": 348}
{"docstring": "/**\n  * @brief  Checks whether the specified SPI/I2S flag is set or not.\n  * @param  SPIx: where x can be\n  *   - 1, 2 or 3 in SPI mode \n  *   - 2 or 3 in I2S mode\n  * @param  SPI_I2S_FLAG: specifies the SPI/I2S flag to check. \n  *   This parameter can be one of the following values:\n  *     @arg SPI_I2S_FLAG_TXE: Transmit buffer empty flag.\n  *     @arg SPI_I2S_FLAG_RXNE: Receive buffer not empty flag.\n  *     @arg SPI_I2S_FLAG_BSY: Busy flag.\n  *     @arg SPI_I2S_FLAG_OVR: Overrun flag.\n  *     @arg SPI_FLAG_MODF: Mode Fault flag.\n  *     @arg SPI_FLAG_CRCERR: CRC Error flag.\n  *     @arg I2S_FLAG_UDR: Underrun Error flag.\n  *     @arg I2S_FLAG_CHSIDE: Channel Side flag.\n  * @retval The new state of SPI_I2S_FLAG (SET or RESET).\n  */\n", "func_signal": "FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)", "code": "{\n  FlagStatus bitstatus = RESET;\n  /* Check the parameters */\n  assert_param(IS_SPI_ALL_PERIPH(SPIx));\n  assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));\n  /* Check the status of the specified SPI/I2S flag */\n  if ((SPIx->SR & SPI_I2S_FLAG) != (uint16_t)RESET)\n  {\n    /* SPI_I2S_FLAG is set */\n    bitstatus = SET;\n  }\n  else\n  {\n    /* SPI_I2S_FLAG is reset */\n    bitstatus = RESET;\n  }\n  /* Return the SPI_I2S_FLAG status */\n  return  bitstatus;\n}", "path": "SensorTest\\lib\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_spi.c", "repo_name": "adamgreig/Robot4", "stars": 1, "license": "None", "language": "c", "size": 348}
{"docstring": "/**\n  * @brief  Checks whether the specified SPI/I2S interrupt has occurred or not.\n  * @param  SPIx: where x can be\n  *   - 1, 2 or 3 in SPI mode \n  *   - 2 or 3 in I2S mode\n  * @param  SPI_I2S_IT: specifies the SPI/I2S interrupt source to check. \n  *   This parameter can be one of the following values:\n  *     @arg SPI_I2S_IT_TXE: Transmit buffer empty interrupt.\n  *     @arg SPI_I2S_IT_RXNE: Receive buffer not empty interrupt.\n  *     @arg SPI_I2S_IT_OVR: Overrun interrupt.\n  *     @arg SPI_IT_MODF: Mode Fault interrupt.\n  *     @arg SPI_IT_CRCERR: CRC Error interrupt.\n  *     @arg I2S_IT_UDR: Underrun Error interrupt.\n  * @retval The new state of SPI_I2S_IT (SET or RESET).\n  */\n", "func_signal": "ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)", "code": "{\n  ITStatus bitstatus = RESET;\n  uint16_t itpos = 0, itmask = 0, enablestatus = 0;\n\n  /* Check the parameters */\n  assert_param(IS_SPI_ALL_PERIPH(SPIx));\n  assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));\n\n  /* Get the SPI/I2S IT index */\n  itpos = 0x01 << (SPI_I2S_IT & 0x0F);\n\n  /* Get the SPI/I2S IT mask */\n  itmask = SPI_I2S_IT >> 4;\n\n  /* Set the IT mask */\n  itmask = 0x01 << itmask;\n\n  /* Get the SPI_I2S_IT enable bit status */\n  enablestatus = (SPIx->CR2 & itmask) ;\n\n  /* Check the status of the specified SPI/I2S interrupt */\n  if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)\n  {\n    /* SPI_I2S_IT is set */\n    bitstatus = SET;\n  }\n  else\n  {\n    /* SPI_I2S_IT is reset */\n    bitstatus = RESET;\n  }\n  /* Return the SPI_I2S_IT status */\n  return bitstatus;\n}", "path": "SensorTest\\lib\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_spi.c", "repo_name": "adamgreig/Robot4", "stars": 1, "license": "None", "language": "c", "size": 348}
{"docstring": "/**\n  * @brief  Returns the CRC Polynomial register value for the specified SPI.\n  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.\n  * @retval The CRC Polynomial register value.\n  */\n", "func_signal": "uint16_t SPI_GetCRCPolynomial(SPI_TypeDef* SPIx)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_SPI_ALL_PERIPH(SPIx));\n  \n  /* Return the CRC polynomial register */\n  return SPIx->CRCPR;\n}", "path": "SensorTest\\lib\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_spi.c", "repo_name": "adamgreig/Robot4", "stars": 1, "license": "None", "language": "c", "size": 348}
{"docstring": "/**\n  * @brief  Transmit the SPIx CRC value.\n  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.\n  * @retval None\n  */\n", "func_signal": "void SPI_TransmitCRC(SPI_TypeDef* SPIx)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_SPI_ALL_PERIPH(SPIx));\n  \n  /* Enable the selected SPI CRC transmission */\n  SPIx->CR1 |= CR1_CRCNext_Set;\n}", "path": "SensorTest\\lib\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_spi.c", "repo_name": "adamgreig/Robot4", "stars": 1, "license": "None", "language": "c", "size": 348}
{"docstring": "/*\n=for apidoc av_fill\n\nSet the highest index in the array to the given number, equivalent to\nPerl's C<$#array = $fill;>.\n\nThe number of elements in the an array will be C<fill + 1> after\nav_fill() returns.  If the array was previously shorter then the\nadditional elements appended are set to C<PL_sv_undef>.  If the array\nwas longer, then the excess elements are freed.  C<av_fill(av, -1)> is\nthe same as C<av_clear(av)>.\n\n=cut\n*/\n", "func_signal": "void\nPerl_av_fill(pTHX_ register AV *av, I32 fill)", "code": "{\n    dVAR;\n    MAGIC *mg;\n\n    assert(av);\n\n    if (fill < 0)\n\tfill = -1;\n    if ((mg = SvTIED_mg((SV*)av, PERL_MAGIC_tied))) {\n\tdSP;            \n\tENTER;\n\tSAVETMPS;\n\tPUSHSTACKi(PERLSI_MAGIC);\n\tPUSHMARK(SP);\n\tEXTEND(SP,2);\n\tPUSHs(SvTIED_obj((SV*)av, mg));\n\tPUSHs(sv_2mortal(newSViv(fill+1)));\n\tPUTBACK;\n\tcall_method(\"STORESIZE\", G_SCALAR|G_DISCARD);\n\tPOPSTACK;\n\tFREETMPS;\n\tLEAVE;\n\treturn;\n    }\n    if (fill <= AvMAX(av)) {\n\tI32 key = AvFILLp(av);\n\tSV** const ary = AvARRAY(av);\n\n\tif (AvREAL(av)) {\n\t    while (key > fill) {\n\t\tSvREFCNT_dec(ary[key]);\n\t\tary[key--] = &PL_sv_undef;\n\t    }\n\t}\n\telse {\n\t    while (key < fill)\n\t\tary[++key] = &PL_sv_undef;\n\t}\n\t    \n\tAvFILLp(av) = fill;\n\tif (SvSMAGICAL(av))\n\t    mg_set((SV*)av);\n    }\n    else\n\t(void)av_store(av,fill,&PL_sv_undef);\n}", "path": "data\\lcov-perl\\av.c", "repo_name": "ggoossen/perlbenchapps", "stars": 1, "license": "None", "language": "c", "size": 5856}
{"docstring": "/*\n=for apidoc newAV\n\nCreates a new AV.  The reference count is set to 1.\n\n=cut\n*/\n", "func_signal": "AV *\nPerl_newAV(pTHX)", "code": "{\n    register AV * const av = (AV*)newSV_type(SVt_PVAV);\n    /* sv_upgrade does AvREAL_only()  */\n    AvALLOC(av) = 0;\n    AvARRAY(av) = NULL;\n    AvMAX(av) = AvFILLp(av) = -1;\n    return av;\n}", "path": "data\\lcov-perl\\av.c", "repo_name": "ggoossen/perlbenchapps", "stars": 1, "license": "None", "language": "c", "size": 5856}
{"docstring": "/* XXXX This code assumes that buffer size >=2, but does not check it... */\n", "func_signal": "SSize_t\nPerlIOCrlf_get_cnt(pTHX_ PerlIO *f)", "code": "{\n    PerlIOBuf * const b = PerlIOSelf(f, PerlIOBuf);\n    if (!b->buf)\n\tPerlIO_get_base(f);\n    if (PerlIOBase(f)->flags & PERLIO_F_RDBUF) {\n\tPerlIOCrlf * const c = PerlIOSelf(f, PerlIOCrlf);\n\tif ((PerlIOBase(f)->flags & PERLIO_F_CRLF) && (!c->nl || *c->nl == 0xd)) {\n\t    STDCHAR *nl = (c->nl) ? c->nl : b->ptr;\n\t  scan:\n\t    while (nl < b->end && *nl != 0xd)\n\t\tnl++;\n\t    if (nl < b->end && *nl == 0xd) {\n\t      test:\n\t\tif (nl + 1 < b->end) {\n\t\t    if (nl[1] == 0xa) {\n\t\t\t*nl = '\\n';\n\t\t\tc->nl = nl;\n\t\t    }\n\t\t    else {\n\t\t\t/*\n\t\t\t * Not CR,LF but just CR\n\t\t\t */\n\t\t\tnl++;\n\t\t\tgoto scan;\n\t\t    }\n\t\t}\n\t\telse {\n\t\t    /*\n\t\t     * Blast - found CR as last char in buffer\n\t\t     */\n\n\t\t    if (b->ptr < nl) {\n\t\t\t/*\n\t\t\t * They may not care, defer work as long as\n\t\t\t * possible\n\t\t\t */\n\t\t\tc->nl = nl;\n\t\t\treturn (nl - b->ptr);\n\t\t    }\n\t\t    else {\n\t\t\tint code;\n\t\t\tb->ptr++;       /* say we have read it as far as\n\t\t\t\t\t * flush() is concerned */\n\t\t\tb->buf++;       /* Leave space in front of buffer */\n\t\t\t/* Note as we have moved buf up flush's\n\t\t\t   posn += ptr-buf\n\t\t\t   will naturally make posn point at CR\n\t\t\t */\n\t\t\tb->bufsiz--;    /* Buffer is thus smaller */\n\t\t\tcode = PerlIO_fill(f);  /* Fetch some more */\n\t\t\tb->bufsiz++;    /* Restore size for next time */\n\t\t\tb->buf--;       /* Point at space */\n\t\t\tb->ptr = nl = b->buf;   /* Which is what we hand\n\t\t\t\t\t\t * off */\n\t\t\t*nl = 0xd;      /* Fill in the CR */\n\t\t\tif (code == 0)\n\t\t\t    goto test;  /* fill() call worked */\n\t\t\t/*\n\t\t\t * CR at EOF - just fall through\n\t\t\t */\n\t\t\t/* Should we clear EOF though ??? */\n\t\t    }\n\t\t}\n\t    }\n\t}\n\treturn (((c->nl) ? (c->nl + 1) : b->end) - b->ptr);\n    }\n    return 0;\n}", "path": "data\\lcov-perl\\perlio.c", "repo_name": "ggoossen/perlbenchapps", "stars": 1, "license": "None", "language": "c", "size": 5856}
{"docstring": "/*\n=for apidoc av_fetch\n\nReturns the SV at the specified index in the array.  The C<key> is the\nindex.  If C<lval> is set then the fetch will be part of a store.  Check\nthat the return value is non-null before dereferencing it to a C<SV*>.\n\nSee L<perlguts/\"Understanding the Magic of Tied Hashes and Arrays\"> for\nmore information on how to use this function on tied arrays. \n\n=cut\n*/\n", "func_signal": "SV**\nPerl_av_fetch(pTHX_ register AV *av, I32 key, I32 lval)", "code": "{\n    dVAR;\n\n    assert(av);\n\n    if (SvRMAGICAL(av)) {\n        const MAGIC * const tied_magic = mg_find((SV*)av, PERL_MAGIC_tied);\n        if (tied_magic || mg_find((SV*)av, PERL_MAGIC_regdata)) {\n\t    SV *sv;\n\t    if (key < 0) {\n\t\tI32 adjust_index = 1;\n\t\tif (tied_magic) {\n\t\t    /* Handle negative array indices 20020222 MJD */\n\t\t    SV * const * const negative_indices_glob =\n\t\t\thv_fetch(SvSTASH(SvRV(SvTIED_obj((SV *)av, tied_magic))),\n\t\t\t\tNEGATIVE_INDICES_VAR, 16, 0);\n\n\t\t    if (negative_indices_glob && SvTRUE(GvSV(*negative_indices_glob)))\n\t\t\tadjust_index = 0;\n\t\t}\n\n\t\tif (adjust_index) {\n\t\t    key += AvFILL(av) + 1;\n\t\t    if (key < 0)\n\t\t\treturn NULL;\n\t\t}\n\t    }\n\n            sv = sv_newmortal();\n\t    sv_upgrade(sv, SVt_PVLV);\n\t    mg_copy((SV*)av, sv, 0, key);\n\t    LvTYPE(sv) = 't';\n\t    LvTARG(sv) = sv; /* fake (SV**) */\n\t    return &(LvTARG(sv));\n        }\n    }\n\n    if (key < 0) {\n\tkey += AvFILL(av) + 1;\n\tif (key < 0)\n\t    return NULL;\n    }\n\n    if (key > AvFILLp(av)) {\n\tif (!lval)\n\t    return NULL;\n\treturn av_store(av,key,newSV(0));\n    }\n    if (AvARRAY(av)[key] == &PL_sv_undef) {\n    emptyness:\n\tif (lval)\n\t    return av_store(av,key,newSV(0));\n\treturn NULL;\n    }\n    else if (AvREIFY(av)\n\t     && (!AvARRAY(av)[key]\t/* eg. @_ could have freed elts */\n\t\t || SvIS_FREED(AvARRAY(av)[key]))) {\n\tAvARRAY(av)[key] = &PL_sv_undef;\t/* 1/2 reify */\n\tgoto emptyness;\n    }\n    return &AvARRAY(av)[key];\n}", "path": "data\\lcov-perl\\av.c", "repo_name": "ggoossen/perlbenchapps", "stars": 1, "license": "None", "language": "c", "size": 5856}
{"docstring": "/*\n\n=for apidoc av_create_and_push\n\nPush an SV onto the end of the array, creating the array if necessary.\nA small internal helper function to remove a commonly duplicated idiom.\n\n=cut\n*/\n", "func_signal": "void\nPerl_av_create_and_push(pTHX_ AV **const avp, SV *const val)", "code": "{\n    if (!*avp)\n\t*avp = newAV();\n    av_push(*avp, val);\n}", "path": "data\\lcov-perl\\av.c", "repo_name": "ggoossen/perlbenchapps", "stars": 1, "license": "None", "language": "c", "size": 5856}
{"docstring": "/*--------------------------------------------------------------------------------------*/\n", "func_signal": "char *\nPerlIO_getname(PerlIO *f, char *buf)", "code": "{\n    dTHX;\n#ifdef VMS\n    char *name = NULL;\n    bool exported = FALSE;\n    FILE *stdio = PerlIOSelf(f, PerlIOStdio)->stdio;\n    if (!stdio) {\n\tstdio = PerlIO_exportFILE(f,0);\n\texported = TRUE;\n    }\n    if (stdio) {\n\tname = fgetname(stdio, buf);\n\tif (exported) PerlIO_releaseFILE(f,stdio);\n    }\n    return name;\n#else\n    PERL_UNUSED_ARG(f);\n    PERL_UNUSED_ARG(buf);\n    Perl_croak(aTHX_ \"Don't know how to get file name\");\n    return NULL;\n#endif\n}", "path": "data\\lcov-perl\\perlio.c", "repo_name": "ggoossen/perlbenchapps", "stars": 1, "license": "None", "language": "c", "size": 5856}
{"docstring": "/*\n=for apidoc av_shift\n\nShifts an SV off the beginning of the array.\n\n=cut\n*/\n", "func_signal": "SV *\nPerl_av_shift(pTHX_ register AV *av)", "code": "{\n    dVAR;\n    SV *retval;\n    MAGIC* mg;\n\n    assert(av);\n\n    if (SvREADONLY(av))\n\tPerl_croak(aTHX_ PL_no_modify);\n    if ((mg = SvTIED_mg((SV*)av, PERL_MAGIC_tied))) {\n\tdSP;\n\tPUSHSTACKi(PERLSI_MAGIC);\n\tPUSHMARK(SP);\n\tXPUSHs(SvTIED_obj((SV*)av, mg));\n\tPUTBACK;\n\tENTER;\n\tif (call_method(\"SHIFT\", G_SCALAR)) {\n\t    retval = newSVsv(*PL_stack_sp--);            \n\t} else {    \n\t    retval = &PL_sv_undef;\n\t}     \n\tLEAVE;\n\tPOPSTACK;\n\treturn retval;\n    }\n    if (AvFILL(av) < 0)\n      return &PL_sv_undef;\n    retval = *AvARRAY(av);\n    if (AvREAL(av))\n\t*AvARRAY(av) = &PL_sv_undef;\n    AvARRAY(av) = AvARRAY(av) + 1;\n    AvMAX(av)--;\n    AvFILLp(av)--;\n    if (SvSMAGICAL(av))\n\tmg_set((SV*)av);\n    return retval;\n}", "path": "data\\lcov-perl\\av.c", "repo_name": "ggoossen/perlbenchapps", "stars": 1, "license": "None", "language": "c", "size": 5856}
{"docstring": "/*\n=for apidoc av_exists\n\nReturns true if the element indexed by C<key> has been initialized.\n\nThis relies on the fact that uninitialized array elements are set to\nC<&PL_sv_undef>.\n\n=cut\n*/\n", "func_signal": "bool\nPerl_av_exists(pTHX_ AV *av, I32 key)", "code": "{\n    dVAR;\n    assert(av);\n\n    if (SvRMAGICAL(av)) {\n        const MAGIC * const tied_magic = mg_find((SV*)av, PERL_MAGIC_tied);\n        if (tied_magic || mg_find((SV*)av, PERL_MAGIC_regdata)) {\n\t    SV * const sv = sv_newmortal();\n            MAGIC *mg;\n            /* Handle negative array indices 20020222 MJD */\n            if (key < 0) {\n                unsigned adjust_index = 1;\n                if (tied_magic) {\n\t\t    SV * const * const negative_indices_glob =\n                        hv_fetch(SvSTASH(SvRV(SvTIED_obj((SV *)av, \n                                                         tied_magic))), \n                                 NEGATIVE_INDICES_VAR, 16, 0);\n                    if (negative_indices_glob\n                        && SvTRUE(GvSV(*negative_indices_glob)))\n                        adjust_index = 0;\n                }\n                if (adjust_index) {\n                    key += AvFILL(av) + 1;\n                    if (key < 0)\n                        return FALSE;\n                }\n            }\n\n            mg_copy((SV*)av, sv, 0, key);\n            mg = mg_find(sv, PERL_MAGIC_tiedelem);\n            if (mg) {\n                magic_existspack(sv, mg);\n                return (bool)SvTRUE(sv);\n            }\n\n        }\n    }\n\n    if (key < 0) {\n\tkey += AvFILL(av) + 1;\n\tif (key < 0)\n\t    return FALSE;\n    }\n\n    if (key <= AvFILLp(av) && AvARRAY(av)[key] != &PL_sv_undef\n\t&& AvARRAY(av)[key])\n    {\n\treturn TRUE;\n    }\n    else\n\treturn FALSE;\n}", "path": "data\\lcov-perl\\av.c", "repo_name": "ggoossen/perlbenchapps", "stars": 1, "license": "None", "language": "c", "size": 5856}
{"docstring": "/*\n * This \"flush\" is akin to sfio's sync in that it handles files in either\n * read or write state.  For write state, we put the postponed data through\n * the next layers.  For read state, we seek() the next layers to the\n * offset given by current position in the buffer, and discard the buffer\n * state (XXXX supposed to be for seek()able buffers only, but now it is done\n * in any case?).  Then the pass the stick further in chain.\n */\n", "func_signal": "IV\nPerlIOBuf_flush(pTHX_ PerlIO *f)", "code": "{\n    PerlIOBuf * const b = PerlIOSelf(f, PerlIOBuf);\n    int code = 0;\n    PerlIO *n = PerlIONext(f);\n    if (PerlIOBase(f)->flags & PERLIO_F_WRBUF) {\n\t/*\n\t * write() the buffer\n\t */\n\tconst STDCHAR *buf = b->buf;\n\tconst STDCHAR *p = buf;\n\twhile (p < b->ptr) {\n\t    SSize_t count = PerlIO_write(n, p, b->ptr - p);\n\t    if (count > 0) {\n\t\tp += count;\n\t    }\n\t    else if (count < 0 || PerlIO_error(n)) {\n\t\tPerlIOBase(f)->flags |= PERLIO_F_ERROR;\n\t\tcode = -1;\n\t\tbreak;\n\t    }\n\t}\n\tb->posn += (p - buf);\n    }\n    else if (PerlIOBase(f)->flags & PERLIO_F_RDBUF) {\n\tSTDCHAR *buf = PerlIO_get_base(f);\n\t/*\n\t * Note position change\n\t */\n\tb->posn += (b->ptr - buf);\n\tif (b->ptr < b->end) {\n\t    /* We did not consume all of it - try and seek downstream to\n\t       our logical position\n\t     */\n\t    if (PerlIOValid(n) && PerlIO_seek(n, b->posn, SEEK_SET) == 0) {\n\t\t/* Reload n as some layers may pop themselves on seek */\n\t\tb->posn = PerlIO_tell(n = PerlIONext(f));\n\t    }\n\t    else {\n\t\t/* Seek failed (e.g. pipe or tty). Do NOT clear buffer or pre-read\n\t\t   data is lost for good - so return saying \"ok\" having undone\n\t\t   the position adjust\n\t\t */\n\t\tb->posn -= (b->ptr - buf);\n\t\treturn code;\n\t    }\n\t}\n    }\n    b->ptr = b->end = b->buf;\n    PerlIOBase(f)->flags &= ~(PERLIO_F_RDBUF | PERLIO_F_WRBUF);\n    /* We check for Valid because of dubious decision to make PerlIO_flush(NULL) flush all */\n    if (PerlIOValid(n) && PerlIO_flush(n) != 0)\n\tcode = -1;\n    return code;\n}", "path": "data\\lcov-perl\\perlio.c", "repo_name": "ggoossen/perlbenchapps", "stars": 1, "license": "None", "language": "c", "size": 5856}
{"docstring": "/*\n=for apidoc av_clear\n\nClears an array, making it empty.  Does not free the memory used by the\narray itself.\n\n=cut\n*/\n", "func_signal": "void\nPerl_av_clear(pTHX_ register AV *av)", "code": "{\n    dVAR;\n    I32 extra;\n\n    assert(av);\n#ifdef DEBUGGING\n    if (SvREFCNT(av) == 0 && ckWARN_d(WARN_DEBUGGING)) {\n\tPerl_warner(aTHX_ packWARN(WARN_DEBUGGING), \"Attempt to clear deleted array\");\n    }\n#endif\n\n    if (SvREADONLY(av))\n\tPerl_croak(aTHX_ PL_no_modify);\n\n    /* Give any tie a chance to cleanup first */\n    if (SvRMAGICAL(av)) {\n\tconst MAGIC* const mg = SvMAGIC(av);\n\tif (PL_delaymagic && mg->mg_type == PERL_MAGIC_isa)\n\t    PL_delaymagic |= DM_ARRAY;\n        else\n\t    mg_clear((SV*)av); \n    }\n\n    if (AvMAX(av) < 0)\n\treturn;\n\n    if (AvREAL(av)) {\n\tSV** const ary = AvARRAY(av);\n\tI32 index = AvFILLp(av) + 1;\n\twhile (index) {\n\t    SV * const sv = ary[--index];\n\t    /* undef the slot before freeing the value, because a\n\t     * destructor might try to modify this array */\n\t    ary[index] = &PL_sv_undef;\n\t    SvREFCNT_dec(sv);\n\t}\n    }\n    extra = AvARRAY(av) - AvALLOC(av);\n    if (extra) {\n\tAvMAX(av) += extra;\n\tAvARRAY(av) = AvALLOC(av);\n    }\n    AvFILLp(av) = -1;\n\n}", "path": "data\\lcov-perl\\av.c", "repo_name": "ggoossen/perlbenchapps", "stars": 1, "license": "None", "language": "c", "size": 5856}
{"docstring": "/*\n=for apidoc av_delete\n\nDeletes the element indexed by C<key> from the array.  Returns the\ndeleted element. If C<flags> equals C<G_DISCARD>, the element is freed\nand null is returned.\n\n=cut\n*/\n", "func_signal": "SV *\nPerl_av_delete(pTHX_ AV *av, I32 key, I32 flags)", "code": "{\n    dVAR;\n    SV *sv;\n\n    assert(av);\n\n    if (SvREADONLY(av))\n\tPerl_croak(aTHX_ PL_no_modify);\n\n    if (SvRMAGICAL(av)) {\n        const MAGIC * const tied_magic = mg_find((SV*)av, PERL_MAGIC_tied);\n        if ((tied_magic || mg_find((SV*)av, PERL_MAGIC_regdata))) {\n            /* Handle negative array indices 20020222 MJD */\n            SV **svp;\n            if (key < 0) {\n                unsigned adjust_index = 1;\n                if (tied_magic) {\n\t\t    SV * const * const negative_indices_glob =\n                        hv_fetch(SvSTASH(SvRV(SvTIED_obj((SV *)av, \n                                                         tied_magic))), \n                                 NEGATIVE_INDICES_VAR, 16, 0);\n                    if (negative_indices_glob\n                        && SvTRUE(GvSV(*negative_indices_glob)))\n                        adjust_index = 0;\n                }\n                if (adjust_index) {\n                    key += AvFILL(av) + 1;\n                    if (key < 0)\n\t\t\treturn NULL;\n                }\n            }\n            svp = av_fetch(av, key, TRUE);\n            if (svp) {\n                sv = *svp;\n                mg_clear(sv);\n                if (mg_find(sv, PERL_MAGIC_tiedelem)) {\n                    sv_unmagic(sv, PERL_MAGIC_tiedelem); /* No longer an element */\n                    return sv;\n                }\n\t\treturn NULL;\n            }\n        }\n    }\n\n    if (key < 0) {\n\tkey += AvFILL(av) + 1;\n\tif (key < 0)\n\t    return NULL;\n    }\n\n    if (key > AvFILLp(av))\n\treturn NULL;\n    else {\n\tif (!AvREAL(av) && AvREIFY(av))\n\t    av_reify(av);\n\tsv = AvARRAY(av)[key];\n\tif (key == AvFILLp(av)) {\n\t    AvARRAY(av)[key] = &PL_sv_undef;\n\t    do {\n\t\tAvFILLp(av)--;\n\t    } while (--key >= 0 && AvARRAY(av)[key] == &PL_sv_undef);\n\t}\n\telse\n\t    AvARRAY(av)[key] = &PL_sv_undef;\n\tif (SvSMAGICAL(av))\n\t    mg_set((SV*)av);\n    }\n    if (flags & G_DISCARD) {\n\tSvREFCNT_dec(sv);\n\tsv = NULL;\n    }\n    else if (AvREAL(av))\n\tsv = sv_2mortal(sv);\n    return sv;\n}", "path": "data\\lcov-perl\\av.c", "repo_name": "ggoossen/perlbenchapps", "stars": 1, "license": "None", "language": "c", "size": 5856}
{"docstring": "/*\n=for apidoc av_push\n\nPushes an SV onto the end of the array.  The array will grow automatically\nto accommodate the addition.\n\n=cut\n*/\n", "func_signal": "void\nPerl_av_push(pTHX_ register AV *av, SV *val)", "code": "{             \n    dVAR;\n    MAGIC *mg;\n    assert(av);\n\n    if (SvREADONLY(av))\n\tPerl_croak(aTHX_ PL_no_modify);\n\n    if ((mg = SvTIED_mg((SV*)av, PERL_MAGIC_tied))) {\n\tdSP;\n\tPUSHSTACKi(PERLSI_MAGIC);\n\tPUSHMARK(SP);\n\tEXTEND(SP,2);\n\tPUSHs(SvTIED_obj((SV*)av, mg));\n\tPUSHs(val);\n\tPUTBACK;\n\tENTER;\n\tcall_method(\"PUSH\", G_SCALAR|G_DISCARD);\n\tLEAVE;\n\tPOPSTACK;\n\treturn;\n    }\n    av_store(av,AvFILLp(av)+1,val);\n}", "path": "data\\lcov-perl\\av.c", "repo_name": "ggoossen/perlbenchapps", "stars": 1, "license": "None", "language": "c", "size": 5856}
{"docstring": "/*--------------------------------------------------------------------------------------*/\n/*\n * Given the abstraction above the public API functions\n */\n", "func_signal": "int\nPerlIO_binmode(pTHX_ PerlIO *f, int iotype, int mode, const char *names)", "code": "{\n    PerlIO_debug(\"PerlIO_binmode f=%p %s %c %x %s\\n\", (void*)f,\n                 (PerlIOBase(f)) ? PerlIOBase(f)->tab->name : \"(Null)\",\n                 iotype, mode, (names) ? names : \"(Null)\");\n\n    if (names) {\n\t/* Do not flush etc. if (e.g.) switching encodings.\n\t   if a pushed layer knows it needs to flush lower layers\n\t   (for example :unix which is never going to call them)\n\t   it can do the flush when it is pushed.\n\t */\n\treturn PerlIO_apply_layers(aTHX_ f, NULL, names) == 0 ? TRUE : FALSE;\n    }\n    else {\n\t/* Fake 5.6 legacy of using this call to turn ON O_TEXT */\n#ifdef PERLIO_USING_CRLF\n\t/* Legacy binmode only has meaning if O_TEXT has a value distinct from\n\t   O_BINARY so we can look for it in mode.\n\t */\n\tif (!(mode & O_BINARY)) {\n\t    /* Text mode */\n\t    /* FIXME?: Looking down the layer stack seems wrong,\n\t       but is a way of reaching past (say) an encoding layer\n\t       to flip CRLF-ness of the layer(s) below\n\t     */\n\t    while (*f) {\n\t\t/* Perhaps we should turn on bottom-most aware layer\n\t\t   e.g. Ilya's idea that UNIX TTY could serve\n\t\t */\n\t\tif (PerlIOBase(f)->tab->kind & PERLIO_K_CANCRLF) {\n\t\t    if (!(PerlIOBase(f)->flags & PERLIO_F_CRLF)) {\n\t\t\t/* Not in text mode - flush any pending stuff and flip it */\n\t\t\tPerlIO_flush(f);\n\t\t\tPerlIOBase(f)->flags |= PERLIO_F_CRLF;\n\t\t    }\n\t\t    /* Only need to turn it on in one layer so we are done */\n\t\t    return TRUE;\n\t\t}\n\t\tf = PerlIONext(f);\n\t    }\n\t    /* Not finding a CRLF aware layer presumably means we are binary\n\t       which is not what was requested - so we failed\n\t       We _could_ push :crlf layer but so could caller\n\t     */\n\t    return FALSE;\n\t}\n#endif\n\t/* Legacy binmode is now _defined_ as being equivalent to pushing :raw\n\t   So code that used to be here is now in PerlIORaw_pushed().\n\t */\n\treturn PerlIO_push(aTHX_ f, PERLIO_FUNCS_CAST(&PerlIO_raw), NULL, NULL) ? TRUE : FALSE;\n    }\n}", "path": "data\\lcov-perl\\perlio.c", "repo_name": "ggoossen/perlbenchapps", "stars": 1, "license": "None", "language": "c", "size": 5856}
{"docstring": "/*======================================================================================*/\n/*\n * Now some functions in terms of above which may be needed even if we are\n * not in true PerlIO mode\n */\n", "func_signal": "const char *\nPerl_PerlIO_context_layers(pTHX_ const char *mode)", "code": "{\n    dVAR;\n    const char *direction = NULL;\n    SV *layers;\n    /*\n     * Need to supply default layer info from open.pm\n     */\n\n    if (!PL_curcop)\n\treturn NULL;\n\n    if (mode && mode[0] != 'r') {\n\tif (PL_curcop->cop_hints & HINT_LEXICAL_IO_OUT)\n\t    direction = \"open>\";\n    } else {\n\tif (PL_curcop->cop_hints & HINT_LEXICAL_IO_IN)\n\t    direction = \"open<\";\n    }\n    if (!direction)\n\treturn NULL;\n\n    layers = Perl_refcounted_he_fetch(aTHX_ PL_curcop->cop_hints_hash,\n\t\t\t\t      0, direction, 5, 0, 0);\n\n    assert(layers);\n    return SvOK(layers) ? SvPV_nolen_const(layers) : NULL;\n}", "path": "data\\lcov-perl\\perlio.c", "repo_name": "ggoossen/perlbenchapps", "stars": 1, "license": "None", "language": "c", "size": 5856}
{"docstring": "/*\n=for apidoc av_pop\n\nPops an SV off the end of the array.  Returns C<&PL_sv_undef> if the array\nis empty.\n\n=cut\n*/\n", "func_signal": "SV *\nPerl_av_pop(pTHX_ register AV *av)", "code": "{\n    dVAR;\n    SV *retval;\n    MAGIC* mg;\n\n    assert(av);\n\n    if (SvREADONLY(av))\n\tPerl_croak(aTHX_ PL_no_modify);\n    if ((mg = SvTIED_mg((SV*)av, PERL_MAGIC_tied))) {\n\tdSP;    \n\tPUSHSTACKi(PERLSI_MAGIC);\n\tPUSHMARK(SP);\n\tXPUSHs(SvTIED_obj((SV*)av, mg));\n\tPUTBACK;\n\tENTER;\n\tif (call_method(\"POP\", G_SCALAR)) {\n\t    retval = newSVsv(*PL_stack_sp--);    \n\t} else {    \n\t    retval = &PL_sv_undef;\n\t}\n\tLEAVE;\n\tPOPSTACK;\n\treturn retval;\n    }\n    if (AvFILL(av) < 0)\n\treturn &PL_sv_undef;\n    retval = AvARRAY(av)[AvFILLp(av)];\n    AvARRAY(av)[AvFILLp(av)--] = &PL_sv_undef;\n    if (SvSMAGICAL(av))\n\tmg_set((SV*)av);\n    return retval;\n}", "path": "data\\lcov-perl\\av.c", "repo_name": "ggoossen/perlbenchapps", "stars": 1, "license": "None", "language": "c", "size": 5856}
{"docstring": "/* USE_ATTIBUTES_FOR_PERLIO */\n", "func_signal": "SV *\nPerlIO_tab_sv(pTHX_ PerlIO_funcs *tab)", "code": "{\n    HV * const stash = gv_stashpvs(\"PerlIO::Layer\", GV_ADD);\n    SV * const sv = sv_bless(newRV_noinc(newSViv(PTR2IV(tab))), stash);\n    return sv;\n}", "path": "data\\lcov-perl\\perlio.c", "repo_name": "ggoossen/perlbenchapps", "stars": 1, "license": "None", "language": "c", "size": 5856}
{"docstring": "/*--------------------------------------------------------------------------------------*/\n/*\n * XS Interface for perl code\n */\n", "func_signal": "PerlIO_funcs *\nPerlIO_find_layer(pTHX_ const char *name, STRLEN len, int load)", "code": "{\n    dVAR;\n    IV i;\n    if ((SSize_t) len <= 0)\n\tlen = strlen(name);\n    for (i = 0; i < PL_known_layers->cur; i++) {\n\tPerlIO_funcs * const f = PL_known_layers->array[i].funcs;\n\tif (memEQ(f->name, name, len) && f->name[len] == 0) {\n\t    PerlIO_debug(\"%.*s => %p\\n\", (int) len, name, (void*)f);\n\t    return f;\n\t}\n    }\n    if (load && PL_subname && PL_def_layerlist\n\t&& PL_def_layerlist->cur >= 2) {\n\tif (PL_in_load_module) {\n\t    Perl_croak(aTHX_ \"Recursive call to Perl_load_module in PerlIO_find_layer\");\n\t    return NULL;\n\t} else {\n\t    SV * const pkgsv = newSVpvs(\"PerlIO\");\n\t    SV * const layer = newSVpvn(name, len);\n\t    CV * const cv    = Perl_get_cvn_flags(aTHX_ STR_WITH_LEN(\"PerlIO::Layer::NoWarnings\"), 0);\n\t    ENTER;\n\t    SAVEINT(PL_in_load_module);\n\t    if (cv) {\n\t\tSAVEGENERICSV(PL_warnhook);\n\t\tPL_warnhook = (SV *) (SvREFCNT_inc_simple_NN(cv));\n\t    }\n\t    PL_in_load_module++;\n\t    /*\n\t     * The two SVs are magically freed by load_module\n\t     */\n\t    Perl_load_module(aTHX_ 0, pkgsv, NULL, layer, NULL);\n\t    PL_in_load_module--;\n\t    LEAVE;\n\t    return PerlIO_find_layer(aTHX_ name, len, 0);\n\t}\n    }\n    PerlIO_debug(\"Cannot find %.*s\\n\", (int) len, name);\n    return NULL;\n}", "path": "data\\lcov-perl\\perlio.c", "repo_name": "ggoossen/perlbenchapps", "stars": 1, "license": "None", "language": "c", "size": 5856}
{"docstring": "/* Note that calls to PerlIO_exportFILE() are reversed using\n * PerlIO_releaseFILE(), not importFILE. */\n", "func_signal": "FILE *\nPerlIO_exportFILE(PerlIO * f, const char *mode)", "code": "{\n    dTHX;\n    FILE *stdio = NULL;\n    if (PerlIOValid(f)) {\n\tchar buf[8];\n\tPerlIO_flush(f);\n\tif (!mode || !*mode) {\n\t    mode = PerlIO_modestr(f, buf);\n\t}\n\tstdio = PerlSIO_fdopen(PerlIO_fileno(f), mode);\n\tif (stdio) {\n\t    PerlIOl *l = *f;\n\t    PerlIO *f2;\n\t    /* De-link any lower layers so new :stdio sticks */\n\t    *f = NULL;\n\t    if ((f2 = PerlIO_push(aTHX_ f, PERLIO_FUNCS_CAST(&PerlIO_stdio), buf, NULL))) {\n\t\tPerlIOStdio *s = PerlIOSelf((f = f2), PerlIOStdio);\n\t\ts->stdio = stdio;\n\t\tPerlIOUnix_refcnt_inc(fileno(stdio));\n\t\t/* Link previous lower layers under new one */\n\t\t*PerlIONext(f) = l;\n\t    }\n\t    else {\n\t\t/* restore layers list */\n\t\t*f = l;\n\t    }\n\t}\n    }\n    return stdio;\n}", "path": "data\\lcov-perl\\perlio.c", "repo_name": "ggoossen/perlbenchapps", "stars": 1, "license": "None", "language": "c", "size": 5856}
{"docstring": "/*\n=for apidoc av_unshift\n\nUnshift the given number of C<undef> values onto the beginning of the\narray.  The array will grow automatically to accommodate the addition.  You\nmust then use C<av_store> to assign values to these new elements.\n\n=cut\n*/\n", "func_signal": "void\nPerl_av_unshift(pTHX_ register AV *av, register I32 num)", "code": "{\n    dVAR;\n    register I32 i;\n    MAGIC* mg;\n\n    assert(av);\n\n    if (SvREADONLY(av))\n\tPerl_croak(aTHX_ PL_no_modify);\n\n    if ((mg = SvTIED_mg((SV*)av, PERL_MAGIC_tied))) {\n\tdSP;\n\tPUSHSTACKi(PERLSI_MAGIC);\n\tPUSHMARK(SP);\n\tEXTEND(SP,1+num);\n\tPUSHs(SvTIED_obj((SV*)av, mg));\n\twhile (num-- > 0) {\n\t    PUSHs(&PL_sv_undef);\n\t}\n\tPUTBACK;\n\tENTER;\n\tcall_method(\"UNSHIFT\", G_SCALAR|G_DISCARD);\n\tLEAVE;\n\tPOPSTACK;\n\treturn;\n    }\n\n    if (num <= 0)\n      return;\n    if (!AvREAL(av) && AvREIFY(av))\n\tav_reify(av);\n    i = AvARRAY(av) - AvALLOC(av);\n    if (i) {\n\tif (i > num)\n\t    i = num;\n\tnum -= i;\n    \n\tAvMAX(av) += i;\n\tAvFILLp(av) += i;\n\tAvARRAY(av) = AvARRAY(av) - i;\n    }\n    if (num) {\n\tregister SV **ary;\n\tconst I32 i = AvFILLp(av);\n\t/* Create extra elements */\n\tconst I32 slide = i > 0 ? i : 0;\n\tnum += slide;\n\tav_extend(av, i + num);\n\tAvFILLp(av) += num;\n\tary = AvARRAY(av);\n\tMove(ary, ary + num, i + 1, SV*);\n\tdo {\n\t    ary[--num] = &PL_sv_undef;\n\t} while (num);\n\t/* Make extra elements into a buffer */\n\tAvMAX(av) -= slide;\n\tAvFILLp(av) -= slide;\n\tAvARRAY(av) = AvARRAY(av) + slide;\n    }\n}", "path": "data\\lcov-perl\\av.c", "repo_name": "ggoossen/perlbenchapps", "stars": 1, "license": "None", "language": "c", "size": 5856}
{"docstring": "/* Inherit the PERLIO_F_UTF8 flag from previous layer.\n * Otherwise the :crlf layer would always revert back to\n * raw mode.\n */\n", "func_signal": "static void\nS_inherit_utf8_flag(PerlIO *f)", "code": "{\n    PerlIO *g = PerlIONext(f);\n    if (PerlIOValid(g)) {\n\tif (PerlIOBase(g)->flags & PERLIO_F_UTF8) {\n\t    PerlIOBase(f)->flags |= PERLIO_F_UTF8;\n\t}\n    }\n}", "path": "data\\lcov-perl\\perlio.c", "repo_name": "ggoossen/perlbenchapps", "stars": 1, "license": "None", "language": "c", "size": 5856}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "void\nudp_recv(struct udp_pcb *pcb,\n\t void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,\n\t\t       struct ip_addr *addr, uint16_t port),\n\t void *recv_arg)", "code": "{\n  pcb->recv = recv;\n  pcb->recv_arg = recv_arg;\n}", "path": "BIR-sw-20091012\\lwtcp\\udp.c", "repo_name": "alexanderkatovsky/bir", "stars": 1, "license": "None", "language": "c", "size": 1008}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "err_t\nudp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, uint16_t port)", "code": "{\n  struct udp_pcb *ipcb;\n  ip_addr_set(&pcb->local_ip, ipaddr);\n  pcb->local_port = port;\n\n  /* Insert UDP PCB into the list of active UDP PCBs. */\n  for(ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {\n    if(pcb == ipcb) {\n      /* Already on the list, just return. */\n      return ERR_OK;\n    }\n  }\n  /* We need to place the PCB on the list. */\n  pcb->next = udp_pcbs;\n  udp_pcbs = pcb;\n\n  DEBUGF(UDP_DEBUG, (\"udp_bind: bound to port %d\\n\", port));\n  return ERR_OK;\n}", "path": "BIR-sw-20091012\\lwtcp\\udp.c", "repo_name": "alexanderkatovsky/bir", "stars": 1, "license": "None", "language": "c", "size": 1008}
{"docstring": "/*-----------------------------------------------------------------------------\n * Method: sr_log_packet()\n * Scope: Local \n *\n *---------------------------------------------------------------------------*/\n", "func_signal": "void sr_log_packet(struct sr_instance* sr, uint8_t* buf, int len )", "code": "{\n    struct pcap_pkthdr h;\n    int size;\n\n    /* REQUIRES */\n    assert(sr);\n\n    if(!sr->logfile)\n    {return; }\n\n    size = min(PACKET_DUMP_SIZE, len);\n\n    gettimeofday(&h.ts, 0);\n    h.caplen = size;\n    h.len = (size < PACKET_DUMP_SIZE) ? size : PACKET_DUMP_SIZE;\n\n    sr_dump(sr->logfile, &h, buf);\n    fflush(sr->logfile);\n}", "path": "stub\\sr_vns_comm.c", "repo_name": "alexanderkatovsky/bir", "stars": 1, "license": "None", "language": "c", "size": 1008}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "err_t\nudp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, uint16_t port)", "code": "{\n  struct udp_pcb *ipcb;\n  ip_addr_set(&pcb->remote_ip, ipaddr);\n  pcb->remote_port = port;\n\n  /* Insert UDP PCB into the list of active UDP PCBs. */\n  for(ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {\n    if(pcb == ipcb) {\n      /* Already on the list, just return. */\n      return ERR_OK;\n    }\n  }\n  /* We need to place the PCB on the list. */\n  pcb->next = udp_pcbs;\n  udp_pcbs = pcb;\n  return ERR_OK;\n}", "path": "BIR-sw-20091012\\lwtcp\\udp.c", "repo_name": "alexanderkatovsky/bir", "stars": 1, "license": "None", "language": "c", "size": 1008}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n/* ip_output:\n *\n * Simple interface to ip_output_if. It finds the outgoing network\n * interface and calls upon ip_output_if to do the actual work.\n */\n/*-----------------------------------------------------------------------------------*/\n", "func_signal": "err_t\nip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,\n\t  u8_t ttl, u8_t proto)", "code": "{\n  static struct netif *netif;\n\n  \n  if((netif = ip_route(dest)) == NULL) {\n    DEBUGF(IP_DEBUG, (\"ip_output: No route to 0x%lx\\n\", dest->addr));\n\n#ifdef IP_STATS\n    ++stats.ip.rterr;\n#endif /* IP_STATS */\n    pbuf_free(p);\n    return ERR_RTE;\n  }\n\n  return ip_output_if(p, src, dest, ttl, proto, netif);\n}", "path": "BIR-sw-20091012\\lwtcp\\ipv4\\ip.c", "repo_name": "alexanderkatovsky/bir", "stars": 1, "license": "None", "language": "c", "size": 1008}
{"docstring": "/*\n * readReg - read a register\n */\n", "func_signal": "int readReg(struct nf2device *nf2, unsigned reg, unsigned *val)", "code": "{\n\tif (nf2->net_iface)\n\t{\n\t\treturn readRegNet(nf2, reg, val);\n\t}\n\telse\n\t{\n\t\treturn readRegFile(nf2, reg, val);\n\t}\n}", "path": "BIR-sw-20091012\\nf2util.c", "repo_name": "alexanderkatovsky/bir", "stars": 1, "license": "None", "language": "c", "size": 1008}
{"docstring": "/*\n * writeRegNet - write a register, using a network socket\n */\n", "func_signal": "static int writeRegNet(struct nf2device *nf2, unsigned reg, unsigned val)", "code": "{\n        struct ifreq ifreq;\n\tstruct nf2reg nf2reg;\n\tint ret;\n\n\tnf2reg.reg = reg;\n\tnf2reg.val = val;\n\n\t/* Set up the ifreq structure */\n\tifreq.ifr_data = (char *)&nf2reg;\n        strncpy(ifreq.ifr_ifrn.ifrn_name, nf2->device_name, IFNAMSIZ);\n        /*if (setsockopt(nf2->fd, SOL_SOCKET, SO_BINDTODEVICE,\n                       (char *)&ifreq, sizeof(ifreq)) < 0) {\n                perror(\"sendpacket: setting SO_BINDTODEVICE\");\n                return -1;\n        } */\n\n\t/* Call the ioctl */\n\tif ((ret = ioctl(nf2->fd, SIOCREGWRITE, &ifreq)) == 0)\n\t{\n\t\treturn 0;\n\t}\n\telse\n\t{\n                perror(\"sendpacket: ioctl failed in writeRegNet\");\n                return -1;\n\t}\n}", "path": "BIR-sw-20091012\\nf2util.c", "repo_name": "alexanderkatovsky/bir", "stars": 1, "license": "None", "language": "c", "size": 1008}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n/* ip_output_if:\n *\n * Sends an IP packet on a network interface. This function constructs\n * the IP header and calculates the IP header checksum. If the source\n * IP address is NULL, the IP address of the outgoing network\n * interface is filled in as source address.\n */\n/*-----------------------------------------------------------------------------------*/\n", "func_signal": "err_t\nip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,\n\t     u8_t ttl,\n\t     u8_t proto, struct netif *netif)", "code": "{\n  static struct ip_hdr *iphdr;\n  static u16_t ip_id = 0;\n\n  \n  \n  if(dest != IP_HDRINCL) {\n    if(pbuf_header(p, IP_HLEN)) {\n      DEBUGF(IP_DEBUG, (\"ip_output: not enough room for IP header in pbuf\\n\"));\n      \n#ifdef IP_STATS\n      ++stats.ip.err;\n#endif /* IP_STATS */\n      pbuf_free(p);\n      return ERR_BUF;\n    }\n    \n    iphdr = p->payload;\n    \n    IPH_TTL_SET(iphdr, ttl);\n    IPH_PROTO_SET(iphdr, proto);\n    \n    ip_addr_set(&(iphdr->dest), dest);\n\n    IPH_VHLTOS_SET(iphdr, 4, IP_HLEN / 4, 0);\n    IPH_LEN_SET(iphdr, htons(p->tot_len));\n    IPH_OFFSET_SET(iphdr, htons(IP_DF));\n    IPH_ID_SET(iphdr, htons(++ip_id));\n\n    if(ip_addr_isany(src)) {\n      ip_addr_set(&(iphdr->src), &(netif->ip_addr));\n    } else {\n      ip_addr_set(&(iphdr->src), src);\n    }\n\n    IPH_CHKSUM_SET(iphdr, 0);\n    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));\n  } else {\n    iphdr = p->payload;\n    dest = &(iphdr->dest);\n  }\n\n#ifdef IP_STATS\n  stats.ip.xmit++;\n#endif /* IP_STATS */\n  DEBUGF(IP_DEBUG, (\"ip_output_if: %c%c \", netif->name[0], netif->name[1]));\n#if IP_DEBUG\n  ip_debug_print(p);\n#endif /* IP_DEBUG */\n\n\n  return netif->output(netif, p, dest);  \n}", "path": "BIR-sw-20091012\\lwtcp\\ipv4\\ip.c", "repo_name": "alexanderkatovsky/bir", "stars": 1, "license": "None", "language": "c", "size": 1008}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n/* ip_forward:\n *\n * Forwards an IP packet. It finds an appropriate route for the\n * packet, decrements the TTL value of the packet, adjusts the\n * checksum and outputs the packet on the appropriate interface.\n */\n/*-----------------------------------------------------------------------------------*/\n", "func_signal": "static void\nip_forward(struct pbuf *p, struct ip_hdr *iphdr, struct netif *inp)", "code": "{\n  static struct netif *netif;\n  \n  PERF_START;\n  \n  if((netif = ip_route((struct ip_addr *)&(iphdr->dest))) == NULL) {\n\n    DEBUGF(IP_DEBUG, (\"ip_forward: no forwarding route for 0x%lx found\\n\",\n\t\t      iphdr->dest.addr));\n\n    return;\n  }\n\n  /* Don't forward packets onto the same network interface on which\n     they arrived. */\n  if(netif == inp) {\n    DEBUGF(IP_DEBUG, (\"ip_forward: not forward packets back on incoming interface.\\n\"));\n\n    return;\n  }\n  \n  /* Decrement TTL and send ICMP if ttl == 0. */\n  IPH_TTL_SET(iphdr, IPH_TTL(iphdr) - 1);\n  if(IPH_TTL(iphdr) == 0) {\n    /* Don't send ICMP messages in response to ICMP messages */\n    if(IPH_PROTO(iphdr) != IP_PROTO_ICMP) {\n      icmp_time_exceeded(p, ICMP_TE_TTL);\n    }\n    return;       \n  }\n  \n  /* Incremental update of the IP checksum. */\n  if(IPH_CHKSUM(iphdr) >= htons(0xffff - 0x100)) {\n    IPH_CHKSUM_SET(iphdr, IPH_CHKSUM(iphdr) + htons(0x100) + 1);\n  } else {\n    IPH_CHKSUM_SET(iphdr, IPH_CHKSUM(iphdr) + htons(0x100));\n  }\n\n  DEBUGF(IP_DEBUG, (\"ip_forward: forwarding packet to 0x%lx\\n\",\n\t\t    iphdr->dest.addr));\n\n#ifdef IP_STATS\n  ++stats.ip.fw;\n  ++stats.ip.xmit;\n#endif /* IP_STATS */\n\n  PERF_STOP(\"ip_forward\");\n  \n  netif->output(netif, p, (struct ip_addr *)&(iphdr->dest));\n}", "path": "BIR-sw-20091012\\lwtcp\\ipv4\\ip.c", "repo_name": "alexanderkatovsky/bir", "stars": 1, "license": "None", "language": "c", "size": 1008}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "void\nudp_remove(struct udp_pcb *pcb)", "code": "{\n  struct udp_pcb *pcb2;\n  \n  if(udp_pcbs == pcb) {\n    udp_pcbs = udp_pcbs->next;\n  } else for(pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {\n    if(pcb2->next != NULL && pcb2->next == pcb) {\n      pcb2->next = pcb->next;\n    }\n  }\n\n  memp_free(MEMP_UDP_PCB, pcb);  \n}", "path": "BIR-sw-20091012\\lwtcp\\udp.c", "repo_name": "alexanderkatovsky/bir", "stars": 1, "license": "None", "language": "c", "size": 1008}
{"docstring": "/*\n * Check the iface name to make sure we can find the interface\n */\n", "func_signal": "int check_iface(struct nf2device *nf2)", "code": "{\n\tstruct stat buf;\n\tchar filename[PATHLEN];\n\n\t/* See if we can find the interface name as a network device */\n\n\t/* Test the length first of all */\n\tif (strlen(nf2->device_name) > IFNAMSIZ)\n\t{\n\t\tfprintf(stderr, \"Interface name is too long: %s\\n\", nf2->device_name);\n\t\treturn -1;\n\t}\n\n\t/* Check for /sys/class/net/iface_name */\n\tstrcpy(filename, \"/sys/class/net/\");\n\tstrcat(filename, nf2->device_name);\n\tif (stat(filename, &buf) == 0)\n\t{\n#ifdef _DEBUG_\n\t\tfprintf(stderr, \"Found net device: %s\\n\", nf2->device_name);\n#endif\n\t\tnf2->net_iface = 1;\n\t\treturn 0;\n\t}\n\n\t/* Check for /dev/iface_name */\n\tstrcpy(filename, \"/dev/\");\n\tstrcat(filename, nf2->device_name);\n\tif (stat(filename, &buf) == 0)\n\t{\n#ifdef _DEBUG_\n\t\tfprintf(stderr, \"Found dev device: %s\\n\", nf2->device_name);\n#endif\n\t\tnf2->net_iface = 0;\n\t\treturn 0;\n\t}\n\n\tfprintf(stderr, \"Can't find device: %s\\n\", nf2->device_name);\n\treturn -1;\n}", "path": "BIR-sw-20091012\\nf2util.c", "repo_name": "alexanderkatovsky/bir", "stars": 1, "license": "None", "language": "c", "size": 1008}
{"docstring": "/*\n * readRegNet - read a register, using a network socket\n */\n", "func_signal": "static int readRegNet(struct nf2device *nf2, unsigned reg, unsigned *val)", "code": "{\n        struct ifreq ifreq;\n\tstruct nf2reg nf2reg;\n\tint ret;\n\n\tnf2reg.reg = reg;\n\n\t/* Set up the ifreq structure */\n\tifreq.ifr_data = (char *)&nf2reg;\n        strncpy(ifreq.ifr_ifrn.ifrn_name, nf2->device_name, IFNAMSIZ);\n        /*if (setsockopt(nf2->fd, SOL_SOCKET, SO_BINDTODEVICE,\n                       (char *)&ifreq, sizeof(ifreq)) < 0) {\n                perror(\"sendpacket: setting SO_BINDTODEVICE\");\n                return -1;\n        } */\n\n\t/* Call the ioctl */\n\tif ((ret = ioctl(nf2->fd, SIOCREGREAD, &ifreq)) == 0)\n\t{\n\t\t*val = nf2reg.val;\n\t\treturn 0;\n\t}\n\telse\n\t{\n                perror(\"sendpacket: ioctl failed in readRegNet\");\n                return -1;\n\t}\n}", "path": "BIR-sw-20091012\\nf2util.c", "repo_name": "alexanderkatovsky/bir", "stars": 1, "license": "None", "language": "c", "size": 1008}
{"docstring": "/*\n *  Read the version info from the board\n */\n", "func_signal": "void read_info( struct nf2device *nf2  )", "code": "{\n  int i;\n\n  // Read the version and revision\n  readReg(nf2, DEV_ID_DEVICE_ID, &nf2->info.nf2_device_id);\n  readReg(nf2, DEV_ID_REVISION, &nf2->info.nf2_revision);\n\n  // Read the version string\n  for (i = 0; i < DEVICE_STR_NUM_REGS; i++)\n  {\n    readReg(nf2, DEV_ID_DEV_STR_0 + i * 4, (unsigned *)(nf2->info.nf2_device_str + i * 4));\n\n    // Perform byte swapping if necessary\n    *(unsigned *)(nf2->info.nf2_device_str + i * 4) = ntohl(*(unsigned *)(nf2->info.nf2_device_str + i * 4));\n  }\n  nf2->info.nf2_device_str[DEVICE_STR_LEN - 1] = '\\0';\n}", "path": "BIR-sw-20091012\\nf2util.c", "repo_name": "alexanderkatovsky/bir", "stars": 1, "license": "None", "language": "c", "size": 1008}
{"docstring": "/*\n * writeRegFile - write a register, using a file descriptor\n */\n", "func_signal": "static int writeRegFile(struct nf2device *nf2, unsigned reg, unsigned val)", "code": "{\n\tstruct nf2reg nf2reg;\n\tint ret;\n\n\tnf2reg.reg = reg;\n\tnf2reg.val = val;\n\n\t/* Call the ioctl */\n\tif ((ret = ioctl(nf2->fd, SIOCREGWRITE, &nf2reg)) == 0)\n\t{\n\t\treturn 0;\n\t}\n\telse\n\t{\n                perror(\"sendpacket: ioctl failed in writeRegFile\");\n                return -1;\n\t}\n}", "path": "BIR-sw-20091012\\nf2util.c", "repo_name": "alexanderkatovsky/bir", "stars": 1, "license": "None", "language": "c", "size": 1008}
{"docstring": "/*\n * readRegFile - read a register, using a file descriptor\n */\n", "func_signal": "static int readRegFile(struct nf2device *nf2, unsigned reg, unsigned *val)", "code": "{\n\tstruct nf2reg nf2reg;\n\tint ret;\n\n\tnf2reg.reg = reg;\n\n\t/* Call the ioctl */\n\tif ((ret = ioctl(nf2->fd, SIOCREGREAD, &nf2reg)) == 0)\n\t{\n\t\t*val = nf2reg.val;\n\t\treturn 0;\n\t}\n\telse\n\t{\n                perror(\"sendpacket: ioctl failed in readRegFile\");\n                return -1;\n\t}\n}", "path": "BIR-sw-20091012\\nf2util.c", "repo_name": "alexanderkatovsky/bir", "stars": 1, "license": "None", "language": "c", "size": 1008}
{"docstring": "/*-----------------------------------------------------------------------------\n * Method: sr_handle_hwinfo(..) \n * scope: global \n *\n *\n * Read, from the server, the hardware information for the reserved host.\n *\n *---------------------------------------------------------------------------*/\n", "func_signal": "int sr_handle_hwinfo(struct sr_instance* sr, c_hwinfo* hwinfo)", "code": "{\n    int num_entries;\n    int i = 0;\n\n    /* REQUIRES */\n    assert(sr);\n    assert(hwinfo);\n\n    num_entries = (ntohl(hwinfo->mLen) - (2*sizeof(uint32_t)))/sizeof(c_hw_entry);\n\n    /* Debug(\"Received Hardware Info with %d entries\\n\",num_entries); */\n\n    for ( i=0; i<num_entries; i++ )\n    {\n        switch( ntohl(hwinfo->mHWInfo[i].mKey))\n        {\n            case HWFIXEDIP:\n                Debug(\"Fixed IP: %s\\n\",inet_ntoa(\n                            *((struct in_addr*)(hwinfo->mHWInfo[i].value))));\n                break;    \n            case HWINTERFACE:    \n                Debug(\"INTERFACE: %s\\n\",hwinfo->mHWInfo[i].value);\n                sr_add_interface(sr,hwinfo->mHWInfo[i].value);\n                break;\n            case HWSPEED:    \n                Debug(\"Speed: %d\\n\",\n                        ntohl(*((unsigned int*)hwinfo->mHWInfo[i].value))); \n                break;\n            case HWSUBNET:\n                Debug(\"Subnet: %s\\n\",inet_ntoa(\n                            *((struct in_addr*)(hwinfo->mHWInfo[i].value))));\n                break;\n            case HWMASK:\n                Debug(\"Mask: %s\\n\",inet_ntoa(\n                            *((struct in_addr*)(hwinfo->mHWInfo[i].value)))); \n                break;\n            case HWETHIP:    \n                Debug(\"IP: %s\\n\",inet_ntoa(\n                            *((struct in_addr*)(hwinfo->mHWInfo[i].value))));\n                sr_set_ether_ip(sr,*((uint32_t*)hwinfo->mHWInfo[i].value));\n                break;\n            case HWETHER:\n                Debug(\"\\tHardware Address: \");\n                DebugMAC(hwinfo->mHWInfo[i].value);\n                Debug(\"\\n\"); \n                sr_set_ether_addr(sr,(unsigned char*)hwinfo->mHWInfo[i].value);\n                break;\n            default:\n                printf (\" %d \\n\",ntohl(hwinfo->mHWInfo[i].mKey));\n        } /* -- switch -- */\n    } /* -- for -- */\n\n    printf(\"Router interfaces:\\n\");\n    sr_print_if_list(sr);\n\n    return num_entries;\n}", "path": "stub\\sr_vns_comm.c", "repo_name": "alexanderkatovsky/bir", "stars": 1, "license": "None", "language": "c", "size": 1008}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "struct udp_pcb *\nudp_new(void)", "code": "{\n  struct udp_pcb *pcb;\n  pcb = memp_malloc(MEMP_UDP_PCB);\n  if(pcb != NULL) {\n    bzero(pcb, sizeof(struct udp_pcb));\n    return pcb;\n  }\n  return NULL;\n\n}", "path": "BIR-sw-20091012\\lwtcp\\udp.c", "repo_name": "alexanderkatovsky/bir", "stars": 1, "license": "None", "language": "c", "size": 1008}
{"docstring": "/*\n * Close the descriptor associated with the device name\n */\n", "func_signal": "int closeDescriptor(struct nf2device *nf2)", "code": "{\n\tif (nf2->net_iface)\n\t{\n\t\tclose(nf2->fd);\n\t}\n\telse\n\t{\n\t\tclose(nf2->fd);\n\t}\n\n\treturn 0;\n}", "path": "BIR-sw-20091012\\nf2util.c", "repo_name": "alexanderkatovsky/bir", "stars": 1, "license": "None", "language": "c", "size": 1008}
{"docstring": "/*-----------------------------------------------------------------------------\n * Method: sr_connect_to_server()\n * Scope: Global \n *\n * Connect to the virtual server\n * \n * RETURN VALUES:\n *\n *  0 on success \n *  something other than zero on error\n *\n *---------------------------------------------------------------------------*/\n", "func_signal": "int sr_connect_to_server(struct sr_instance* sr,unsigned short port,\n                         char* server)", "code": "{\n    struct hostent *hp;\n    c_open command;\n\n    /* REQUIRES */\n    assert(sr);\n    assert(server);\n\n    /* purify UMR be gone ! */\n    memset((void*)&command,0,sizeof(c_open));\n\n    /* zero out server address struct */\n    memset(&(sr->sr_addr),0,sizeof(struct sockaddr_in));\n\n    sr->sr_addr.sin_family = AF_INET;\n    sr->sr_addr.sin_port = htons(port);\n\n    /* grab hosts address from domain name */\n    if ((hp = gethostbyname(server))==0) \n    {\n        perror(\"gethostbyname:sr_client.c::sr_connect_to_server(..)\");\n        return -1;\n    }\n\n    /* set server address */\n    memcpy(&(sr->sr_addr.sin_addr),hp->h_addr_list[0],hp->h_length);\n\n    /* create socket */\n    if ((sr->sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)\n    {\n        perror(\"socket(..):sr_client.c::sr_connect_to_server(..)\");\n        return -1;\n    }\n\n    /* attempt to connect to the server */\n    if (connect(sr->sockfd, (struct sockaddr *)&(sr->sr_addr), \n                sizeof(sr->sr_addr)) < 0)\n    {\n        perror(\"connect(..):sr_client.c::sr_connect_to_server(..)\");\n        close(sr->sockfd);\n        return -1;\n    }\n\n    /* send sr_OPEN message to server */ \n    command.mLen   = htonl(sizeof(c_open));\n    command.mType  = htonl(VNSOPEN);\n    command.topoID = htons(sr->topo_id);\n    strncpy( command.mVirtualHostID, sr->host,  IDSIZE);\n    strncpy( command.mUID, sr->user, IDSIZE);\n\n    if (send(sr->sockfd, (void *)&command, sizeof(c_open), 0) != sizeof(c_open))\n    {\n        perror(\"send(..):sr_client.c::sr_connect_to_server()\");\n        return -1;\n    }\n\n    return 0;\n}", "path": "stub\\sr_vns_comm.c", "repo_name": "alexanderkatovsky/bir", "stars": 1, "license": "None", "language": "c", "size": 1008}
{"docstring": "/*-----------------------------------------------------------------------------------*/\n", "func_signal": "err_t\nudp_send(struct udp_pcb *pcb, struct pbuf *p)", "code": "{\n  struct udp_hdr *udphdr;\n  struct ip_addr *src_ip;\n  err_t err;\n  struct pbuf *q;\n  \n  if(pbuf_header(p, UDP_HLEN)) {\n    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);\n    if(q == NULL) {\n      return ERR_MEM;\n    }\n    pbuf_chain(q, p);\n    p = q;\n  }\n\n  udphdr = p->payload;\n  udphdr->src = htons(pcb->local_port);\n  udphdr->dest = htons(pcb->remote_port);\n  udphdr->chksum = 0x0000;\n\n  src_ip = &(pcb->local_ip);\n  \n  DEBUGF(UDP_DEBUG, (\"udp_send: sending datagram of length %d\\n\", p->tot_len));\n  \n  if(pcb->flags & UDP_FLAGS_UDPLITE) {\n    udphdr->len = htons(pcb->chksum_len);\n    /* calculate checksum */\n    udphdr->chksum = inet_chksum_pseudo(p, src_ip, &(pcb->remote_ip),\n\t\t\t\t\tIP_PROTO_UDP, pcb->chksum_len);\n    if(udphdr->chksum == 0x0000) {\n      udphdr->chksum = 0xffff;\n    }\n    err = sr_lwip_output(p, &pcb->local_ip, &pcb->remote_ip, IP_PROTO_UDPLITE);\n  } else {\n    udphdr->len = htons(p->tot_len);\n    /* calculate checksum */\n    if((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {\n      udphdr->chksum = inet_chksum_pseudo(p, src_ip, &pcb->remote_ip,\n\t\t\t\t\t  IP_PROTO_UDP, p->tot_len);\n      if(udphdr->chksum == 0x0000) {\n\tudphdr->chksum = 0xffff;\n      }\n    }\n    err = sr_lwip_output(p,&pcb->local_ip, &pcb->remote_ip, IP_PROTO_UDP);\n  }\n  \n#ifdef UDP_STATS\n  ++stats.udp.xmit;\n#endif /* UDP_STATS */\n  return err;\n}", "path": "BIR-sw-20091012\\lwtcp\\udp.c", "repo_name": "alexanderkatovsky/bir", "stars": 1, "license": "None", "language": "c", "size": 1008}
{"docstring": "/**\n * malloc\u0143G[o\ua347\u0315o\u0342B\n * @param \u0590nB\n * @return int EXIT_FAILURE\u0502B\n */\n", "func_signal": "int error_malloc(char *string)", "code": "{\n\tprintf(\"%s\u0143m\u06c2\u024es\u0702B\\n\", string);\n\treturn EXIT_FAILURE;\n}", "path": "gonzo_system\\common.c", "repo_name": "gitfas/works", "stars": 1, "license": "None", "language": "c", "size": 10528}
{"docstring": "/**\n * j[\ud802\udf8c`o\u0342(eLXg)\n * @param char string[][PRINT_FORMAT_LEN] j[\n * @param int cnt j[\u0310\n */\n", "func_signal": "void format_print_menu(char string[][PRINT_FORMAT_LEN], int cnt)", "code": "{\n\tint i,j;\n#ifdef DEBUG_PRINT\n\tprintf(\"j[\u0310:%d\\n\", cnt);\n#endif\n\n\tfor(i = 0; i < cnt; i++) {\n\t\tprintf(\"  | %d. %s \", (i + 1), string[i]);\n\t\tfor(j = 0; j < (PRINT_FORMAT_LEN - (strlen(string[i])/3*2) - 4); j++) {\n\t\t\tprintf(\" \");\n\t\t}\n\t\tprintf(\"|\\n\");\n\t}\n}", "path": "gonzo_system\\common.c", "repo_name": "gitfas/works", "stars": 1, "license": "None", "language": "c", "size": 10528}
{"docstring": "/**\n * yes/no \u0342ATrue/False\u0502B\n * @retval TRUE \"Y\",\"y\"\u0342\ua347\u0255\u0502B\n * @retval FALSE \"N\",\"n\"\u0342\ua347\u0255\u0502B\n */\n", "func_signal": "int query_ok_ng()", "code": "{\n\t// `A\n\tint\t\tc;\n\tint\t\tflag;\n\tint\t\tresult;\n\n\tprintf(\"\u020f\u0313o^e\u0142\ub0b5\u0142BY/N:\");\n\twhile((c = getchar()) != EOF) {\n\t\tswitch(c) {\n\t\t\tcase YES:\n\t\t\tcase yes:\n\t\t\t\tflag = TRUE;\n\t\t\t\tresult = TRUE;\n\t\t\t\tbreak;\n\t\t\tcase NO:\n\t\t\tcase no:\n\t\t\t\tflag = TRUE;\n\t\t\t\tresult = TRUE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"Y/N \u0342\u0102B\\n\");\n\t\t\t\tbreak;\n\t\t}\n\t\tif (flag == TRUE) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}", "path": "gonzo_system\\common.c", "repo_name": "gitfas/works", "stars": 1, "license": "None", "language": "c", "size": 10528}
{"docstring": "/**\n * \ud8ca\ude42AJ}iCj\u0308\u0292uB\n * @param nB\n * @retval int J}\u0292u\u0502B\n * @retval 0 J}\u0082\u0202\ua347\u0255\u0502B\n */\n", "func_signal": "int cammna_search(char *str, int now)", "code": "{\n\tchar *comma = \",\";\n\tchar *place;\n\n\tplace = strstr((str + now), comma);\n#ifdef DEBUG_PRINT\n\tprintf(\"'%s'\u0312\u024c'%s'\u0182%d\u0682\u0242.\\n\", str, comma, place - str + 1);\n#endif\n\tif (place == NULL) {\n\t\treturn -1;\n\t} else {\n\t\treturn (int)(place - str + 1);\n\t}\n}", "path": "gonzo_system\\common.c", "repo_name": "gitfas/works", "stars": 1, "license": "None", "language": "c", "size": 10528}
{"docstring": "/**\n * material \ud802\udf8c`\u0115\\\n * @param material\\\u0302nB\n */\n", "func_signal": "void format_material(struct material tmp_mtrl)", "code": "{\n\tprintf(\"------------------------------\\n\");\n\tprintf(\"id:%d\\n\", tmp_mtrl.id);\n\tprintf(\"f:%s\\n\", tmp_mtrl.model);\n\tprintf(\"^:%s\\n\", tmp_mtrl.model_name);\n\tprintf(\"\u01d7\u050d:%s\\n\", tmp_mtrl.control_id);\n\tprintf(\"\u0296:%s\\n\", tmp_mtrl.alias);\n\tprintf(\":%s\\n\", tmp_mtrl.status);\n\tprintf(\"\u0752n:%s\\n\", tmp_mtrl.place);\n\tprintf(\"\u04d4C:%s\\n\", tmp_mtrl.blame);\n\tprintf(\"\u014fIXV:%s\\n\", tmp_mtrl.date);\n\tprintf(\"------------------------------\\n\");\n}", "path": "gonzo_system\\material.c", "repo_name": "gitfas/works", "stars": 1, "license": "None", "language": "c", "size": 10528}
{"docstring": "/**\n * @\u0788\ua5d7\n */\n", "func_signal": "void page_show_all()", "code": "{\n\t// `A\n\tint cnt;\n\n\tprintf(\"@\u0788\ua5d7\\\u0702\\n\");\n\tprintf(\"|f   | ^     | \u01d7\u050d | \u0296 | l     | \u0311   |\\n\");\n\tprintf(\"----------------------------------------------------------------\\n\");\n\n\t// \u0502l\u024d\\\u0302\u0312\u0502\n\tcnt = material_file_read();\n\tprintf(\"cnt : %d\\n\", cnt);\n\tcnt = EXIT_FAILURE;\n\n\tprintf(\"%d\", EXIT_FAILURE);\n\t// \u030am\u06c2\u024es\ua347\n\tif (cnt == EXIT_FAILURE) {\n\t\tprintf(\"I\\n\");\n\t\tstatus = PAGE_START;\n\t\treturn;\n\t}\n\n\tprintf(\"\\n\");\n\tfree(mtrl_ptr);\n\tstatus = PAGE_START;\n}", "path": "gonzo_system\\page.c", "repo_name": "gitfas/works", "stars": 1, "license": "None", "language": "c", "size": 10528}
{"docstring": "/**\n * \u0313\u034etsB\n * 255oCg\u0702\u0153\u0349\u0094\\B\n * @param char* \u0342i[|C^\n */\n", "func_signal": "void common_string_input(char* string)", "code": "{\n\t/* `A */\n\t/* A\u0342\udaca\udfce\u0303G[\u0702AB*/\n\tchar\tinput[STRING_BUFFER];\n\tint\t\tflag;\n\tint\t\tcnt;\n\tflag = FALSE;\n\n\tprintf(\"\u034et[]F\");\n\tfgets(input, sizeof(input), stdin);\n\tfflush(stdin);\n\n\tif (input[256 - 2] != '\\0') {\n\t\tcnt = 256 - 2;\n\t\twhile (1) {\n\t\t\tif (input[cnt] <= 0x7f) {\n\t\t\t\tbreak; // 1oCg,R[h\n\t\t\t} else if (input[cnt] <= 0xbf) {\n\t\t\t\tinput[cnt--] = '\\0';\n\t\t\t} else if (input[cnt] <= 0xfd) {\n\t\t\t\tinput[cnt--] = '\\0';\n\t\t\t\tbreak; // 2-6oCg\n\t\t\t}\n\t\t}\n\t}\n\tstrncpy(string, input, 256);\n}", "path": "gonzo_system\\common.c", "repo_name": "gitfas/works", "stars": 1, "license": "None", "language": "c", "size": 10528}
{"docstring": "/**\n * `o\u0342\u0303Co\u0342(eLXg)\n */\n", "func_signal": "void format_print_line()", "code": "{\n\tint i;\n\n\tprintf(\"  +\");\n\tfor(i = 0; i < PRINT_FORMAT_LEN + 1; i++) {\n\t\tprintf(\"-\");\n\t}\n\tprintf(\"+\\n\");\n}", "path": "gonzo_system\\common.c", "repo_name": "gitfas/works", "stars": 1, "license": "None", "language": "c", "size": 10528}
{"docstring": "/**\n * materialB\n * @param materialnB\n */\n", "func_signal": "void init_material(struct material *mtrl)", "code": "{\n\tmtrl -> id\t\t\t = 0;\n\tmtrl -> model\t\t = (char*)malloc(STRING_BUFFER);\n\tmtrl -> model_name\t = (char*)malloc(STRING_BUFFER);\n\tmtrl -> control_id\t = (char*)malloc(STRING_BUFFER);\n\tmtrl -> alias\t\t = (char*)malloc(STRING_BUFFER);\n\tmtrl -> status\t\t = (char*)malloc(STRING_BUFFER);\n\tmtrl -> place\t\t = (char*)malloc(STRING_BUFFER);\n\tmtrl -> blame\t\t = (char*)malloc(STRING_BUFFER);\n\tmtrl -> date\t\t = (char*)malloc(STRING_BUFFER);\n}", "path": "gonzo_system\\material.c", "repo_name": "gitfas/works", "stars": 1, "license": "None", "language": "c", "size": 10528}
{"docstring": "/**\n * io^\n */\n", "func_signal": "void page_equipment_regist()", "code": "{\n\t// `A\n\tstruct material regist;\n\n\tprintf(\"io^\\n\");\n\t// \u034et\n\tregist = input_material();\n\t// `\\\n\tformat_material(regist);\n\t// yes/no\n\tif (query_ok_ng() == TRUE) {\n\t\t// t@C\u058f\n\t\tprintf(\"file write\");\n\t}\n\n\t// malloc\u0102\u9554\u030aJ\n\tfree_material(&regist);\n\tstatus = PAGE_START;\n}", "path": "gonzo_system\\page.c", "repo_name": "gitfas/works", "stars": 1, "license": "None", "language": "c", "size": 10528}
{"docstring": "/**\n * UTF-8\u0315\u0315JEgB\n * @param UTF-8\u0315nB\n * @return int JEg\u0502B\n */\n", "func_signal": "int count_UTF8(const unsigned char *string)", "code": "{\n\tint len = 0;\n\n\twhile(*string) {\n\t\tif (*string < 0x1f || *string == 0x7f) {\n\t\t\t//R[h\n\t\t} else if (*string <= 0x7f) {\n\t\t\t++len; // 1oCg\n\t\t} else if (*string <= 0xbf) {\n\t\t\t// \u0311\n\t\t} else if (*string <= 0xdf) {\n\t\t\t++len; // 2oCg\n\t\t} else if (*string <= 0xef) {\n\t\t\t++len; // 3oCg\n\t\t} else if (*string <= 0xf7) {\n\t\t\t++len; // 4oCg\n\t\t} else if (*string <= 0xfb) {\n\t\t\t++len; // 5oCg\n\t\t} else if (*string <= 0xfd) {\n\t\t\t++len; // 6oCg\n\t\t} else {\n\t\t\t// g\u0102\u0202\n\t\t}\n\t\tstring++;\n\t}\n\n\treturn len;\n}", "path": "gonzo_system\\common.c", "repo_name": "gitfas/works", "stars": 1, "license": "None", "language": "c", "size": 10528}
{"docstring": "/**\n * i\u074foL^XV\n */\n", "func_signal": "void page_lend_renew()", "code": "{\n\tprintf(\"i\u030f\u0502XV\u0702\\n\");\n\tprintf(\"\\n\u0154i\ua5d7\\\\n\\n\");\n\tprintf(\"\u01c2\u030b@\u0782\u030bL^XV\u0702H\\n\");\n\n\tint input;\n\tscanf(\"ID:%d\", &input);\n\tprintf(\"id %d \u030b@\u0782\u030bL^XV\u0702\\n\", input);\n\n\tstatus = PAGE_START;\n}", "path": "gonzo_system\\page.c", "repo_name": "gitfas/works", "stars": 1, "license": "None", "language": "c", "size": 10528}
{"docstring": "/**\n * material t@C\u0592\u01c9\u0742B\n * @retval EXIT_SUCCESS \u01c9\u0742\u0250\u0502B\n * @retval EXIT_FAILURE \u01c9\u0742\u024es\u0502B\n */\n", "func_signal": "int material_file_write_add(struct material tmp_mtrl)", "code": "{\n\t// `A\n\tFILE *fp;\n\tint i;\n\tchar *joint_str[] = {\n\t\t(char *)tmp_mtrl.id,\n\t\ttmp_mtrl.model,\n\t\ttmp_mtrl.model_name,\n\t\ttmp_mtrl.control_id,\n\t\ttmp_mtrl.alias,\n\t\ttmp_mtrl.status,\n\t\ttmp_mtrl.place,\n\t\ttmp_mtrl.blame,\n\t\ttmp_mtrl.date\n\t};\n\tchar jointed[sizeof(struct material)];\n\n\tif ((fp = fopen(MATERIAL_FILE, \"a\")) == NULL) {\n\t\tprintf(\"[%s]t@CJ\u0702B\\n\", MATERIAL_FILE);\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tfor (i = 0; i < 7; i++) {\n\t\tstrcat(jointed, joint_str[i]);\n\t}\n\tfputs(jointed, fp);\n\tfclose(fp);\n\n\treturn EXIT_SUCCESS;\n}", "path": "gonzo_system\\material.c", "repo_name": "gitfas/works", "stars": 1, "license": "None", "language": "c", "size": 10528}
{"docstring": "/**\n * \u0342v material \u024ai[B\n * @return struct material \u0342\\\u0302\u0251\u0115\u0502B\n */\n", "func_signal": "struct material input_material(void)", "code": "{\n\t// `A\n\tstruct material tmp_mtrl;\n\t// |C^\u0251\u0382\u0117\u0308\u63c9As\n\tinit_material(&tmp_mtrl);\n\n\t// ID\u80aaR\u0102\n\ttmp_mtrl.id = 10;\n\n\tprintf(\"f:\");\n\tcommon_string_input(tmp_mtrl.model);\n\n\tprintf(\"^:\");\n\tcommon_string_input(tmp_mtrl.model_name);\n\n\tprintf(\"\u01d7\u050d:\");\n\tcommon_string_input(tmp_mtrl.control_id);\n\n\tprintf(\"\u0296:\");\n\tcommon_string_input(tmp_mtrl.alias);\n\n\tprintf(\"\u0502:\");\n\tcommon_string_input(tmp_mtrl.status);\n\n\tprintf(\"\u0752n:\");\n\tcommon_string_input(tmp_mtrl.place);\n\n\tprintf(\"\u04d4C\u0482:\");\n\tcommon_string_input(tmp_mtrl.blame);\n\n\tprintf(\"\u014fIXV:\");\n\tcommon_string_input(tmp_mtrl.date);\n\n\treturn tmp_mtrl;\n}", "path": "gonzo_system\\material.c", "repo_name": "gitfas/works", "stars": 1, "license": "None", "language": "c", "size": 10528}
{"docstring": "/**\n * C\n * @return int \u0282\u0502B\n */\n", "func_signal": "int main ()", "code": "{\n  int while_flag = TRUE;\n  init();\n  \n  while (while_flag == TRUE) {\n    switch (status) {\n    case PAGE_START :\n      ptr = page_start;\n      break;\n    case PAGE_SHOW_ALL :\n      ptr = page_show_all;\n      break;\n    case PAGE_LEND_RENEW :\n      ptr = page_lend_renew;\n      break;\n    case PAGE_LEND_LOG :\n      ptr = page_lend_log;\n      break;\n    case PAGE_EQUIPMENT_REGIST :\n      ptr = page_equipment_regist;\n      break;\n    case PAGE_EQUIPMENT_DELETE :\n      ptr = page_equipment_delete;\n      break;\n    case PAGE_EQUIPMENT_EDIT :\n      ptr = page_equipment_edit;\n      break;\n    default :\n      while_flag = FALSE;\n      break;\n    }\n    (*ptr)();\n  }\n  return 0;\n}", "path": "gonzo_system\\gonzo.c", "repo_name": "gitfas/works", "stars": 1, "license": "None", "language": "c", "size": 10528}
{"docstring": "/**\n * \u074foO\n */\n", "func_signal": "void page_lend_log()", "code": "{\n\tprintf(\"\u074foO\");\n\tstatus = PAGE_START;\n}", "path": "gonzo_system\\page.c", "repo_name": "gitfas/works", "stars": 1, "license": "None", "language": "c", "size": 10528}
{"docstring": "/**\n * i\u048fW\n */\n", "func_signal": "void page_equipment_edit()", "code": "{\n\tprintf(\"i\u048fW\");\n\tstatus = PAGE_START;\n}", "path": "gonzo_system\\page.c", "repo_name": "gitfas/works", "stars": 1, "license": "None", "language": "c", "size": 10528}
{"docstring": "/**\n * ^Cg\ud802\udf8c`o\u0342(eLXg)\n * @param char* string ^Cg\n */\n", "func_signal": "void format_print_title(char string[PRINT_FORMAT_LEN])", "code": "{\n\tint i;\n\n\tprintf(\"  +----- %s \", string);\n\tfor(i = 0; i < (PRINT_FORMAT_LEN - strlen(string)) + 2; i++) {\n\t\tprintf(\"-\");\n\t}\n\tprintf(\"+\\n\");\n}", "path": "gonzo_system\\common.c", "repo_name": "gitfas/works", "stars": 1, "license": "None", "language": "c", "size": 10528}
{"docstring": "/**\n * \n */\n", "func_signal": "static void init()", "code": "{\n  status = PAGE_START;\n  ptr = NULL;\n}", "path": "gonzo_system\\gonzo.c", "repo_name": "gitfas/works", "stars": 1, "license": "None", "language": "c", "size": 10528}
{"docstring": "/**\n * \u0313\u034etsB\n * @param int* \u0342i[|C^\n */\n", "func_signal": "void common_int_input(int* num)", "code": "{\n\t/* `A */\n\tchar\tinput[256];\n\tint\t\tflag;\n\tflag = FALSE;\n\n\tprintf(\"\u034et[]F\");\n\tfgets(input, sizeof(input), stdin);\n\tfflush(stdin);\n\n\t*num = atoi(input);\n}", "path": "gonzo_system\\common.c", "repo_name": "gitfas/works", "stars": 1, "license": "None", "language": "c", "size": 10528}
{"docstring": "/**\n * gssdp_resource_group_set_message_delay\n * @resource_group: A #GSSDPResourceGroup\n * @message_delay: The message delay in ms.\n *\n * Sets the minimum time between each SSDP message.\n **/\n", "func_signal": "void\ngssdp_resource_group_set_message_delay (GSSDPResourceGroup *resource_group,\n                                        guint               message_delay)", "code": "{\n        g_return_if_fail (GSSDP_IS_RESOURCE_GROUP (resource_group));\n\n        if (resource_group->priv->message_delay == message_delay)\n                return;\n\n        resource_group->priv->message_delay = message_delay;\n        \n        g_object_notify (G_OBJECT (resource_group), \"message-delay\");\n}", "path": "libgssdp\\gssdp-resource-group.c", "repo_name": "mjrr/gssdp-win32", "stars": 1, "license": "other", "language": "c", "size": 246}
{"docstring": "/*\n * Get the host IP for the specified interface. If no interface is specified,\n * it gets the IP of the first up & running interface and sets @interface\n * appropriately.\n */\n", "func_signal": "static char *\nget_host_ip (char **interface)", "code": "{\n        struct ifaddrs *ifa_list, *ifa;\n        char *ret;\n        GList *up_ifaces, *iface;\n\n        ret = NULL;\n        up_ifaces = NULL;\n\n        if (getifaddrs (&ifa_list) != 0) {\n                g_error (\"Failed to retrieve list of network interfaces:\\n%s\\n\",\n                         strerror (errno));\n\n                return NULL;\n        }\n\n        for (ifa = ifa_list; ifa != NULL; ifa = ifa->ifa_next) {\n                if (ifa->ifa_addr == NULL)\n                        continue;\n\n                if (*interface && strcmp (*interface, ifa->ifa_name) != 0)\n                        continue;\n                else if (!(ifa->ifa_flags & IFF_UP))\n                        continue;\n\n                /* Loopback and IPv6 interfaces go at the bottom on the list */\n                if (ifa->ifa_flags & IFF_LOOPBACK ||\n                    ifa->ifa_addr->sa_family == AF_INET6)\n                        up_ifaces = g_list_append (up_ifaces, ifa);\n                else\n                        up_ifaces = g_list_prepend (up_ifaces, ifa);\n        }\n\n        for (iface = up_ifaces; iface != NULL; iface = iface->next) {\n                char ip[INET6_ADDRSTRLEN];\n                const char *p;\n                struct sockaddr_in *s4;\n                struct sockaddr_in6 *s6;\n\n                p = NULL;\n\n                ifa = iface->data;\n\n                switch (ifa->ifa_addr->sa_family) {\n                case AF_INET:\n                        s4 = (struct sockaddr_in *) ifa->ifa_addr;\n                        p = inet_ntop (AF_INET,\n                                       &s4->sin_addr, ip, sizeof (ip));\n                        break;\n                case AF_INET6:\n                        s6 = (struct sockaddr_in6 *) ifa->ifa_addr;\n                        p = inet_ntop (AF_INET6,\n                                       &s6->sin6_addr, ip, sizeof (ip));\n                        break;\n                default:\n                        continue; /* Unknown: ignore */\n                }\n\n                if (p != NULL) {\n                        ret = g_strdup (p);\n\n                        if (*interface == NULL)\n                                *interface = g_strdup (ifa->ifa_name);\n                        break;\n                }\n        }\n\n        g_list_free (up_ifaces);\n        freeifaddrs (ifa_list);\n\n        return ret;\n}", "path": "libgssdp\\gssdp-client.c", "repo_name": "mjrr/gssdp-win32", "stars": 1, "license": "other", "language": "c", "size": 246}
{"docstring": "/**\n * Sets the #GSSDPClient @resource_group is associated with @client\n **/\n", "func_signal": "static void\ngssdp_resource_group_set_client (GSSDPResourceGroup *resource_group,\n                                 GSSDPClient        *client)", "code": "{\n        g_return_if_fail (GSSDP_IS_RESOURCE_GROUP (resource_group));\n        g_return_if_fail (GSSDP_IS_CLIENT (client));\n\n        resource_group->priv->client = g_object_ref (client);\n\n        resource_group->priv->message_received_id =\n                g_signal_connect_object (resource_group->priv->client,\n                                         \"message-received\",\n                                         G_CALLBACK (message_received_cb),\n                                         resource_group,\n                                         0);\n\n        g_object_notify (G_OBJECT (resource_group), \"client\");\n}", "path": "libgssdp\\gssdp-resource-group.c", "repo_name": "mjrr/gssdp-win32", "stars": 1, "license": "other", "language": "c", "size": 246}
{"docstring": "/**\n * Called to re-announce all resources periodically\n **/\n", "func_signal": "static gboolean\nresource_group_timeout (gpointer user_data)", "code": "{\n        GSSDPResourceGroup *resource_group;\n        GList *l;\n\n        resource_group = GSSDP_RESOURCE_GROUP (user_data);\n\n        /* Re-announce all resources */\n        for (l = resource_group->priv->resources; l; l = l->next)\n                resource_alive (l->data);\n\n        return TRUE;\n}", "path": "libgssdp\\gssdp-resource-group.c", "repo_name": "mjrr/gssdp-win32", "stars": 1, "license": "other", "language": "c", "size": 246}
{"docstring": "/**\n * gssdp_socket_source_get_fd\n *\n * Return value: The socket's FD.\n **/\n", "func_signal": "int\ngssdp_socket_source_get_fd (GSSDPSocketSource *socket_source)", "code": "{\n        g_return_val_if_fail (socket_source != NULL, -1);\n        \n        return socket_source->poll_fd.fd;\n}", "path": "libgssdp\\gssdp-socket-source.c", "repo_name": "mjrr/gssdp-win32", "stars": 1, "license": "other", "language": "c", "size": 246}
{"docstring": "/**\n * Free a Resource structure and its contained data\n **/\n", "func_signal": "static void\nresource_free (Resource *resource)", "code": "{\n        while (resource->responses)\n                discovery_response_free (resource->responses->data);\n\n        if (resource->resource_group->priv->available)\n                resource_byebye (resource);\n\n        g_free (resource->usn);\n        g_free (resource->target);\n\n        if (resource->target_regex)\n                g_regex_unref (resource->target_regex);\n\n        while (resource->locations) {\n                g_free (resource->locations->data);\n                resource->locations = g_list_delete_link (resource->locations,\n                                                         resource->locations);\n        }\n\n        g_slice_free (Resource, resource);\n}", "path": "libgssdp\\gssdp-resource-group.c", "repo_name": "mjrr/gssdp-win32", "stars": 1, "license": "other", "language": "c", "size": 246}
{"docstring": "/**\n * gssdp_resource_group_set_max_age\n * @resource_group: A #GSSDPResourceGroup\n * @max_age: The number of seconds advertisements are valid\n *\n * Sets the number of seconds advertisements are valid to @max_age.\n **/\n", "func_signal": "void\ngssdp_resource_group_set_max_age (GSSDPResourceGroup *resource_group,\n                                  guint               max_age)", "code": "{\n        g_return_if_fail (GSSDP_IS_RESOURCE_GROUP (resource_group));\n\n        if (resource_group->priv->max_age == max_age)\n                return;\n\n        resource_group->priv->max_age = max_age;\n        \n        g_object_notify (G_OBJECT (resource_group), \"max-age\");\n}", "path": "libgssdp\\gssdp-resource-group.c", "repo_name": "mjrr/gssdp-win32", "stars": 1, "license": "other", "language": "c", "size": 246}
{"docstring": "/**\n * gssdp_client_get_server_id\n * @client: A #GSSDPClient\n *\n * Return value: The server ID.\n **/\n", "func_signal": "const char *\ngssdp_client_get_server_id (GSSDPClient *client)", "code": "{\n        g_return_val_if_fail (GSSDP_IS_CLIENT (client), NULL);\n\n        return client->priv->server_id;\n}", "path": "libgssdp\\gssdp-client.c", "repo_name": "mjrr/gssdp-win32", "stars": 1, "license": "other", "language": "c", "size": 246}
{"docstring": "/**\n * gssdp_resource_group_get_client\n * @resource_group: A #GSSDPResourceGroup\n *\n * Return value: The #GSSDPClient @resource_group is associated with.\n **/\n", "func_signal": "GSSDPClient *\ngssdp_resource_group_get_client (GSSDPResourceGroup *resource_group)", "code": "{\n        g_return_val_if_fail (GSSDP_IS_RESOURCE_GROUP (resource_group), NULL);\n\n        return resource_group->priv->client;\n}", "path": "libgssdp\\gssdp-resource-group.c", "repo_name": "mjrr/gssdp-win32", "stars": 1, "license": "other", "language": "c", "size": 246}
{"docstring": "/**\n * Add a message to sending queue\n * \n * Do not free @message.\n **/\n", "func_signal": "static void\nqueue_message (GSSDPResourceGroup *resource_group,\n               char               *message)", "code": "{\n        g_queue_push_tail (resource_group->priv->message_queue, \n                           message);\n\n        if (resource_group->priv->message_src == NULL) {\n                /* nothing in the queue: process message immediately \n                   and add a timeout for (possible) next message */\n                GMainContext *context;\n\n                process_queue (resource_group);\n                resource_group->priv->message_src = g_timeout_source_new (\n                    resource_group->priv->message_delay);\n                g_source_set_callback (resource_group->priv->message_src,\n                    process_queue, resource_group, NULL);\n                context = gssdp_client_get_main_context (\n                    resource_group->priv->client);\n                g_source_attach (resource_group->priv->message_src, context);\n                g_source_unref (resource_group->priv->message_src);\n        }\n}", "path": "libgssdp\\gssdp-resource-group.c", "repo_name": "mjrr/gssdp-win32", "stars": 1, "license": "other", "language": "c", "size": 246}
{"docstring": "/**\n * Send the next queued message, if any\n **/\n", "func_signal": "static gboolean\nprocess_queue (gpointer data)", "code": "{\n        GSSDPResourceGroup *resource_group;\n\n        resource_group = GSSDP_RESOURCE_GROUP (data);\n\n        if (g_queue_is_empty (resource_group->priv->message_queue)) {\n                /* this is the timeout after last message in queue */\n                resource_group->priv->message_src = NULL;\n\n                return FALSE;\n        } else {\n                GSSDPClient *client;\n                char *message;\n\n                client = resource_group->priv->client;\n                message = g_queue_pop_head\n                        (resource_group->priv->message_queue);\n\n                _gssdp_client_send_message (client,\n                                            NULL,\n                                            0,\n                                            message);\n                g_free (message);\n\n                return TRUE;\n        }\n}", "path": "libgssdp\\gssdp-resource-group.c", "repo_name": "mjrr/gssdp-win32", "stars": 1, "license": "other", "language": "c", "size": 246}
{"docstring": "/**\n * gssdp_client_new\n * @main_context: The #GMainContext to associate with, or NULL\n * @interface: The name of the network interface, or %NULL for auto-detection.\n * @error: Location to store error, or NULL\n *\n * Return value: A new #GSSDPClient object.\n **/\n", "func_signal": "GSSDPClient *\ngssdp_client_new (GMainContext *main_context,\n                  const char   *interface,\n                  GError      **error)", "code": "{\n        return g_object_new (GSSDP_TYPE_CLIENT,\n                             \"main-context\", main_context,\n                             \"interface\", interface,\n                             \"error\", error,\n                             NULL);\n}", "path": "libgssdp\\gssdp-client.c", "repo_name": "mjrr/gssdp-win32", "stars": 1, "license": "other", "language": "c", "size": 246}
{"docstring": "/**\n * _gssdp_client_send_message\n * @client: A #GSSDPClient\n * @dest_ip: The destination IP address, or NULL to broadcast\n * @dest_port: The destination port, or NULL for default\n * @message: The message to send\n *\n * Sends @message to @dest_ip.\n **/\n", "func_signal": "void\n_gssdp_client_send_message (GSSDPClient *client,\n                            const char  *dest_ip,\n                            gushort      dest_port,\n                            const char  *message)", "code": "{\n        struct sockaddr_in addr;\n        int socket_fd, res;\n\n        g_return_if_fail (GSSDP_IS_CLIENT (client));\n        g_return_if_fail (message != NULL);\n\n        if (!client->priv->active)\n                /* We don't send messages in passive mode */\n                return;\n\n        /* Broadcast if @dest_ip is NULL */\n        if (dest_ip == NULL)\n                dest_ip = SSDP_ADDR;\n\n        /* Use default port if no port was explicitly specified */\n        if (dest_port == 0)\n                dest_port = SSDP_PORT;\n\n        socket_fd = gssdp_socket_source_get_fd (client->priv->request_socket);\n\n        memset (&addr, 0, sizeof (addr));\n\n        addr.sin_family      = AF_INET;\n        addr.sin_port        = htons (dest_port);\n        addr.sin_addr.s_addr = inet_addr (dest_ip);\n\n        res = sendto (socket_fd,\n                      message,\n                      strlen (message),\n                      0,\n                      (struct sockaddr *) &addr,\n                      sizeof (addr));\n\n        if (res == -1) {\n                g_warning (\"sendto: Error %d sending message: %s\",\n                           errno, strerror (errno));\n        }\n}", "path": "libgssdp\\gssdp-client.c", "repo_name": "mjrr/gssdp-win32", "stars": 1, "license": "other", "language": "c", "size": 246}
{"docstring": "/**\n * gssdp_resource_group_set_available\n * @resource_group: A #GSSDPResourceGroup\n * @available: TRUE if @resource_group should be available (advertised)\n *\n * Sets @resource_group<!-- -->s availability to @available. Changing\n * @resource_group<!-- -->s availability causes it to announce its new state\n * to listening SSDP clients.\n **/\n", "func_signal": "void\ngssdp_resource_group_set_available (GSSDPResourceGroup *resource_group,\n                                    gboolean            available)", "code": "{\n        GList *l;\n\n        g_return_if_fail (GSSDP_IS_RESOURCE_GROUP (resource_group));\n\n        if (resource_group->priv->available == available)\n                return;\n\n        resource_group->priv->available = available;\n\n        if (available) {\n                GMainContext *context;\n                int timeout;\n\n                /* We want to re-announce before actually timing out */\n                timeout = resource_group->priv->max_age;\n                if (timeout > 2)\n                        timeout = timeout / 2 - 1;\n\n                /* Add re-announcement timer */\n                resource_group->priv->timeout_src =\n                        g_timeout_source_new_seconds (timeout);\n\t\tg_source_set_callback (resource_group->priv->timeout_src,\n\t\t\t\t       resource_group_timeout,\n\t\t\t\t       resource_group, NULL);\n\n                context = gssdp_client_get_main_context\n                        (resource_group->priv->client);\n\t\tg_source_attach (resource_group->priv->timeout_src, context);\n\n                g_source_unref (resource_group->priv->timeout_src);\n\n                /* Announce all resources */\n                for (l = resource_group->priv->resources; l; l = l->next)\n                        resource_alive (l->data);\n        } else {\n                /* Unannounce all resources */\n                for (l = resource_group->priv->resources; l; l = l->next)\n                        resource_byebye (l->data);\n\n                /* Remove re-announcement timer */\n                g_source_destroy (resource_group->priv->timeout_src);\n                resource_group->priv->timeout_src = NULL;\n        }\n        \n        g_object_notify (G_OBJECT (resource_group), \"available\");\n}", "path": "libgssdp\\gssdp-resource-group.c", "repo_name": "mjrr/gssdp-win32", "stars": 1, "license": "other", "language": "c", "size": 246}
{"docstring": "/**\n * Generates the default server ID\n **/\n", "func_signal": "static char *\nmake_server_id (void)", "code": "{\n        struct utsname sysinfo;\n\n        uname (&sysinfo);\n        \n        return g_strdup_printf (\"%s/%s GSSDP/%s\",\n                                sysinfo.sysname,\n                                sysinfo.version,\n                                VERSION);\n}", "path": "libgssdp\\gssdp-client.c", "repo_name": "mjrr/gssdp-win32", "stars": 1, "license": "other", "language": "c", "size": 246}
{"docstring": "/**\n * gssdp_client_get_interface\n * @client: A #GSSDPClient\n *\n * Get the name of the network interface associated to @client.\n *\n * Return value: The network interface name. This string should not be freed.\n **/\n", "func_signal": "const char *\ngssdp_client_get_interface (GSSDPClient *client)", "code": "{\n        g_return_val_if_fail (GSSDP_IS_CLIENT (client), NULL);\n\n        return client->priv->interface;\n}", "path": "libgssdp\\gssdp-client.c", "repo_name": "mjrr/gssdp-win32", "stars": 1, "license": "other", "language": "c", "size": 246}
{"docstring": "/**\n * gssdp_resource_group_get_available\n * @resource_group: A #GSSDPResourceGroup\n *\n * Return value: TRUE if @resource_group is available (advertised).\n **/\n", "func_signal": "gboolean\ngssdp_resource_group_get_available (GSSDPResourceGroup *resource_group)", "code": "{\n        g_return_val_if_fail (GSSDP_IS_RESOURCE_GROUP (resource_group), FALSE);\n\n        return resource_group->priv->available;\n}", "path": "libgssdp\\gssdp-resource-group.c", "repo_name": "mjrr/gssdp-win32", "stars": 1, "license": "other", "language": "c", "size": 246}
{"docstring": "/**\n * gssdp_client_get_active\n * @client: A #GSSDPClient\n *\n * Return value: %TRUE if @client is active, %FALSE otherwise.\n **/\n", "func_signal": "gboolean\ngssdp_client_get_active (GSSDPClient *client)", "code": "{\n        g_return_val_if_fail (GSSDP_IS_CLIENT (client), FALSE);\n\n        return client->priv->active;\n}", "path": "libgssdp\\gssdp-client.c", "repo_name": "mjrr/gssdp-win32", "stars": 1, "license": "other", "language": "c", "size": 246}
{"docstring": "/**\n * gssdp_client_get_main_context\n * @client: A #GSSDPClient\n *\n * Return value: The #GMainContext @client is associated with, or NULL.\n **/\n", "func_signal": "GMainContext *\ngssdp_client_get_main_context (GSSDPClient *client)", "code": "{\n        g_return_val_if_fail (GSSDP_IS_CLIENT (client), NULL);\n\n        return client->priv->main_context;\n}", "path": "libgssdp\\gssdp-client.c", "repo_name": "mjrr/gssdp-win32", "stars": 1, "license": "other", "language": "c", "size": 246}
{"docstring": "/**\n * Called when data can be read from the socket\n **/\n", "func_signal": "static gboolean\nsocket_source_cb (GSSDPSocketSource *socket, GSSDPClient *client)", "code": "{\n        int fd, type, len;\n        size_t bytes;\n        char buf[BUF_SIZE], *end;\n        struct sockaddr_in addr;\n        socklen_t addr_size;\n        SoupMessageHeaders *headers;\n        struct in_addr our_addr;\n        in_addr_t our_network;\n        in_addr_t recv_network;\n\n        /* Get FD */\n        fd = gssdp_socket_source_get_fd (socket);\n\n        /* Read data */\n        addr_size = sizeof (addr);\n        \n        bytes = recvfrom (fd,\n                          buf,\n                          BUF_SIZE - 1, /* Leave space for trailing \\0 */\n                          MSG_TRUNC,\n                          (struct sockaddr *) &addr,\n                          &addr_size);\n\n        /* We need the following lines to make sure the right client received\n         * the packet. We won't need to do this if there was any way to tell\n         * Mr. Unix that we are only interested in receiving multicast packets\n         * on this socket from a particular interface but AFAIK that is not\n         * possible, at least not in a portable way.\n         */\n        recv_network = inet_netof (addr.sin_addr);\n        our_addr.s_addr = inet_addr (gssdp_client_get_host_ip (client));\n        our_network = inet_netof (our_addr);\n        if (recv_network != our_network)\n                return TRUE;\n\n        if (bytes >= BUF_SIZE) {\n                g_warning (\"Received packet of %u bytes, but the maximum \"\n                           \"buffer size is %d. Packed dropped.\",\n                           (unsigned int) bytes, BUF_SIZE);\n\n                return TRUE;\n        }\n\n        /* Add trailing \\0 */\n        buf[bytes] = '\\0';\n\n        /* Find length */\n        end = strstr (buf, \"\\r\\n\\r\\n\");\n        if (!end) {\n                g_warning (\"Received packet lacks \\\"\\\\r\\\\n\\\\r\\\\n\\\" sequence. \"\n                           \"Packed dropped.\");\n\n                return TRUE;\n        }\n\n        len = end - buf + 2;\n        \n        /* Parse message */\n        type = -1;\n        headers = NULL;\n\n        if (!parse_http_request (buf,\n                                 len,\n                                 &headers,\n                                 &type)) {\n                if (!parse_http_response (buf,\n                                          len,\n                                          &headers,\n                                          &type)) {\n                        g_warning (\"Unhandled message '%s'\", buf);\n                }\n        }\n        \n        /* Emit signal if parsing succeeded */\n        if (type >= 0) {\n                g_signal_emit (client,\n                               signals[MESSAGE_RECEIVED],\n                               0,\n                               inet_ntoa (addr.sin_addr),\n                               ntohs (addr.sin_port),\n                               type,\n                               headers);\n        }\n\n        if (headers)\n                soup_message_headers_free (headers);\n\n        return TRUE;\n}", "path": "libgssdp\\gssdp-client.c", "repo_name": "mjrr/gssdp-win32", "stars": 1, "license": "other", "language": "c", "size": 246}
{"docstring": "/*! \\todo Finish function documentation!!!\n *  \\brief\n *  \\par Function Documentation\n *\n */\n", "func_signal": "void x_color_allocate (void)", "code": "{\n  int error;\n  int i;\t\t\n  COLOR c;\n\n  gdk_color_parse (\"black\", &black);\n  if (!gdk_colormap_alloc_color (colormap,\n                                 &black,\n                                 FALSE,\n                                 TRUE)) {\n    fprintf (stderr, _(\"Could not allocate the color %s!\\n\"), _(\"black\"));\n    exit (-1);\n  }\n\n  gdk_color_parse (\"white\", &white);\n  if (!gdk_colormap_alloc_color (colormap,\n                                 &white,\n                                 FALSE,\n                                 TRUE)) {\n    fprintf (stderr, _(\"Could not allocate the color %s!\\n\"), _(\"white\"));\n    exit (-1);\n  }\n\n  for (i = 0; i < MAX_COLORS; i++) {\n\n    if (display_colors[i].enabled) {\n      gdk_colors[i] = (GdkColor *)\n        g_malloc(sizeof(GdkColor));\n\n      c = display_colors[i];\n\n      /* Interpolate 8-bpp colours into 16-bpp GDK color\n       * space. N.b. ignore transparency because GDK doesn't\n       * understand it. */\n      gdk_colors[i]->red = c.r + (c.r<<8);\n      gdk_colors[i]->green = c.g + (c.g<<8);\n      gdk_colors[i]->blue = c.b + (c.b<<8);\n\n      error = gdk_color_alloc(colormap, gdk_colors[i]);\n\n      if (error == FALSE) {\n        g_error (_(\"Could not allocate display color %i!\\n\"), i);\n      }\n    } else {\n      gdk_colors[i] = NULL;\n    }\n\n    if (display_outline_colors[i].enabled) {\n      gdk_outline_colors[i] = (GdkColor *)\n        g_malloc(sizeof(GdkColor));\n\n      c = display_outline_colors[i];\n\n      /* Interpolate 8-bpp colours into 16-bpp GDK color\n       * space. N.b. ignore transparency because GDK doesn't\n       * understand it. */\n      gdk_outline_colors[i]->red = c.r + (c.r<<8);\n      gdk_outline_colors[i]->green = c.g + (c.g<<8);\n      gdk_outline_colors[i]->blue = c.b + (c.b<<8);\n\n      error = gdk_color_alloc(colormap, gdk_outline_colors[i]);\n\n      if (error == FALSE) {\n        g_error (_(\"Could not allocate outline color %i!\\n\"), i);\n      }\n    } else {\n      gdk_outline_colors[i] = NULL;\n    }\n  }\n}", "path": "gschem\\src\\x_color.c", "repo_name": "manasdas17/geda-gaf", "stars": 0, "license": "None", "language": "c", "size": 19372}
{"docstring": "/*------------------------------------------------------------------*/\n/*! \\brief This fcn destroys the old table.  \n * Use it after reading in a new\n * page to get rid of the old table before building a new one.\n *\n *------------------------------------------------------------------*/\n", "func_signal": "void s_table_destroy(TABLE **table, int row_count, int col_count)", "code": "{\n  int i, j;\n\n  if (table == NULL)\n    return;\n\n  for (i = 0; i < row_count; i++) {\n    for (j = 0; j < col_count; j++) {\n      g_free( (table[i][j]).attrib_value );\n      g_free( (table[i][j]).row_name );\n      g_free( (table[i][j]).col_name );\n    }\n  }\n\n  for (i = 0; i < row_count; i++) {\n    g_free( table[i] );\n  }\n\n  g_free(table);\n  table = NULL;\n\n  return;\n}", "path": "gattrib\\src\\s_table.c", "repo_name": "manasdas17/geda-gaf", "stars": 0, "license": "None", "language": "c", "size": 19372}
{"docstring": "/*------------------------------------------------------------------*/\n/*! \\brief This fcn takes a table, a row list, and a row name, \n * and returns a list holding\n * name=value pairs for all attribs pertainent to that particular\n * row.\n * If the row holds no attribs, it just returns NULL.\n *\n *------------------------------------------------------------------*/\n", "func_signal": "STRING_LIST *s_table_create_attrib_pair(gchar *row_name, \n\t\t\t\t\tTABLE **table, \n\t\t\t\t\tSTRING_LIST *row_list,\n\t\t\t\t\tint num_attribs)", "code": "{\n  STRING_LIST *attrib_pair_list;\n  char *attrib_name, *attrib_value, *name_value_pair;\n  int row, col;\n  int count = 0;\n  \n  attrib_pair_list = s_string_list_new();\n\n  row = s_table_get_index(row_list, row_name);\n  /* Sanity check */\n  if (row == -1) {\n    /* we didn't find the item in the list */\n    fprintf (stderr,\n             \"In s_table_create_attrib_pair, we didn't find the row name in the row list!\\n\");\n    return attrib_pair_list;\n  }\n\n  for (col = 0; col < num_attribs; col++) {\n    /* pull attrib from table.  If non-null, add it to attrib_pair_list  */\n    if ( (table[row][col]).attrib_value != NULL) {\n      attrib_name = (table[row][col]).col_name;\n      attrib_value = (table[row][col]).attrib_value;\n      name_value_pair = g_strconcat(attrib_name, \"=\", attrib_value, NULL);\n      s_string_list_add_item(attrib_pair_list, &count, name_value_pair);\n      g_free(name_value_pair);\n    }\n  }\n\n  return attrib_pair_list;\n}", "path": "gattrib\\src\\s_table.c", "repo_name": "manasdas17/geda-gaf", "stars": 0, "license": "None", "language": "c", "size": 19372}
{"docstring": "/*! \\todo Finish function documentation!!!\n *  \\brief\n *  \\par Function Documentation\n *\n *  \\todo this has to change... to the right code\n */\n", "func_signal": "COLOR *x_color_lookup_dark (int color)", "code": "{\n  if (color < 0 || color >= MAX_COLORS ||\n      !display_outline_colors[color].enabled) {\n    g_warning (_(\"Tried to get an invalid outline color: %d\\n\"), color);\n    return &display_outline_colors[DEFAULT_COLOR];\n  } else {\n    return &display_outline_colors[color];\n  }\n\n}", "path": "gschem\\src\\x_color.c", "repo_name": "manasdas17/geda-gaf", "stars": 0, "license": "None", "language": "c", "size": 19372}
{"docstring": "/*! \\brief Frees memory used by the color system.\n *  \\par Function Documentation\n *  This function frees the colors from colormap along with\n *  \\b black and \\b white.\n */\n", "func_signal": "void\nx_color_free (void)", "code": "{\n  int i;\n\n  gdk_colormap_free_colors (colormap, &black, 1);\n  gdk_colormap_free_colors (colormap, &white, 1);\n\n  for (i = 0; i < MAX_COLORS; i++) {\n    if (display_colors[i].enabled)\n      gdk_colormap_free_colors (colormap, gdk_colors[i], 1);\n    if (display_outline_colors[i].enabled)\n      gdk_colormap_free_colors (colormap, gdk_outline_colors[i], 1);\n  }\n}", "path": "gschem\\src\\x_color.c", "repo_name": "manasdas17/geda-gaf", "stars": 0, "license": "None", "language": "c", "size": 19372}
{"docstring": "/*------------------------------------------------------------------*/\n/*! \\brief This fcn returns the index number \n * when given a STRING_LIST and a \n * string to match.  It finds the index\n * number by iterating through the master  list.\n *\n *------------------------------------------------------------------*/\n", "func_signal": "int s_table_get_index(STRING_LIST *local_list, char *local_string)", "code": "{\n  int count = 0;\n  STRING_LIST *list_element;\n\n#ifdef DEBUG\n  printf(\"In s_table_get_index, examining %s to see if it is in the list.\\n\", local_string);\n#endif\n\n\n  list_element = local_list;\n  while (list_element != NULL) {\n    if (strcmp(list_element->data, local_string) == 0) {\n      return count;\n    }\n    count++;\n    list_element = list_element->next;\n  }\n  return(-1);  /* return code when string is not in master_list  */\n}", "path": "gattrib\\src\\s_table.c", "repo_name": "manasdas17/geda-gaf", "stars": 0, "license": "None", "language": "c", "size": 19372}
{"docstring": "/*! \\brief Calculates the distance between the given point and the closest\n *  point on the perimeter of the polygon.\n *\n *  \\param [in] points The polygon, where polygon != NULL.\n *  \\param [in] x      The x coordinate of the given point.\n *  \\param [in] y      The y coordinate of the given point.\n *  \\param [in] closed If TRUE, the function treats the polygon as a closed\n *  shape, creating a line between the first and last points, if needed.  If\n *  the first and last points are equal, or inherintly closed, this parameter\n *  does not matter.\n *  \\return The shortest distance from the polygon to the point.  With an\n *  invalid parameter, this function returns G_MAXDOUBLE.\n */\n", "func_signal": "double m_polygon_shortest_distance (GArray *points, int x, int y, gboolean closed)", "code": "{\n  gdouble shortest = G_MAXDOUBLE;\n\n  if (points->len > 0) {\n    int i = 0;\n    sPOINT point;\n\n    if (closed) {\n      point = g_array_index (points, sPOINT, points->len - 1);\n    } else {\n      point = g_array_index (points, sPOINT, i++);\n    }\n\n    while (i < points->len) {\n      double distance;\n      LINE line;\n\n      line.x[0] = point.x;\n      line.y[0] = point.y;\n\n      point = g_array_index (points, sPOINT, i++);\n\n      line.x[1] = point.x;\n      line.y[1] = point.y;\n\n      distance = m_line_shortest_distance (&line, x, y);\n\n      shortest = min (shortest, distance);\n    }\n  }\n\n  return shortest;\n}", "path": "libgeda\\src\\m_polygon.c", "repo_name": "manasdas17/geda-gaf", "stars": 0, "license": "None", "language": "c", "size": 19372}
{"docstring": "/*------------------------------------------------------------------*/\n/*! \\brief This fcn recreates the table with \n * a new size.  It can only increase\n * the number of cols.  You can't increase the number of rows since\n * gattrib doesn't allow you to input new components.  Decreasing the \n * number of cols is also TBD.\n * \n *------------------------------------------------------------------*/\n", "func_signal": "TABLE **s_table_resize(TABLE **table, \n\t\t       int rows, int old_cols, int new_cols)", "code": "{\n  int i, j;\n\n  /* Here I am trying to resize the 2 dimensional array of structs */\n  for (i = 0; i < rows; i++) {\n    table[i] = (TABLE *) realloc(table[i], new_cols*sizeof(TABLE) );\n    if (table[i] == NULL) exit(-1);  /* die if failed to realloc new memory */\n  }\n\n  /* Now pre-load new cols with NULLs */\n  for (i = 0; i < rows; i++) {\n    for (j = old_cols; j < new_cols; j++) {\n      (table[i][j]).attrib_value = NULL;\n      (table[i][j]).row_name = NULL;\n      (table[i][j]).col_name = NULL;\n      (table[i][j]).row = i;\n      (table[i][j]).col = j;\n      (table[i][j]).visibility = VISIBLE;\n      (table[i][j]).show_name_value = SHOW_VALUE;\n    }\n  }\n\n  return table;\n}", "path": "gattrib\\src\\s_table.c", "repo_name": "manasdas17/geda-gaf", "stars": 0, "license": "None", "language": "c", "size": 19372}
{"docstring": "/*! \\todo Finish function documentation!!!\n *  \\brief\n *  \\par Function Documentation\n *\n */\n", "func_signal": "GdkColor *x_get_color(int color)", "code": "{\n  if ((color < 0) || (color >= MAX_COLORS)\n      || (gdk_colors[color] == NULL)) {\n    g_warning (_(\"Tried to get an invalid color: %d\\n\"), color);\n    return(&white);\n  } else {\n    return(gdk_colors[color]);\n  }\n}", "path": "gschem\\src\\x_color.c", "repo_name": "manasdas17/geda-gaf", "stars": 0, "license": "None", "language": "c", "size": 19372}
{"docstring": "/*------------------------------------------------------------------*/\n/*! \\brief This fcn is the table creator.  It returns a pointer to \n * an initialized TABLE struct.  As calling args, it needs\n * the number of rows and cols to allocate.  The table is a\n * dynamically allocated 2D array of structs.  To access data in\n * a cell in the table, you reference (for example):\n * ((sheet_data->comp_table)[i][j]).attrib_value\n * (Parens used only for clarity.  It works without parens.)\n *\n *------------------------------------------------------------------*/\n", "func_signal": "TABLE **s_table_new(int rows, int cols)", "code": "{\n  TABLE **new_table;\n  int i, j;\n\n  /* Here I am trying to create a 2 dimensional array of structs */\n  new_table = (TABLE **) g_malloc(rows*sizeof(TABLE *));\n  for (i = 0; i < rows; i++) {\n    new_table[i] = (TABLE *) g_malloc(cols * sizeof(TABLE));\n    /* Note that I should put some checks in here to verify that \n     * malloc worked correctly. */\n  }\n\n  /* Now pre-load the table with NULLs */\n  for (i = 0; i < rows; i++) {\n    for (j = 0; j < cols; j++) {\n      (new_table[i][j]).attrib_value = NULL;\n      (new_table[i][j]).row_name = NULL;\n      (new_table[i][j]).col_name = NULL;\n      (new_table[i][j]).row = i;\n      (new_table[i][j]).col = j;\n      (new_table[i][j]).visibility = VISIBLE; \n      (new_table[i][j]).show_name_value = SHOW_VALUE;\n    }\n  }\n\n  return (new_table);\n\n}", "path": "gattrib\\src\\s_table.c", "repo_name": "manasdas17/geda-gaf", "stars": 0, "license": "None", "language": "c", "size": 19372}
{"docstring": "/*! \\brief Determines if a point lies inside a polygon\n *\n *  TODO Untested\n *\n *  \\param points [in] The vertices of the polygon.  This function assumes the\n *  list of points represents a closed polygon.  If the first and last point do\n *  not match, the line segment between them is implied.  This parameter must\n *  not be NULL.\n *  \\param x [in] The x coordinate of the given point.\n *  \\param y [in] The y coordinate of the given point.\n *  \\returns TRUE if the point lies inside the polygon, FALSE if the point lies\n *  outside the polygon.\n */\n", "func_signal": "gboolean m_polygon_interior_point (GArray *points, int x, int y)", "code": "{\n  int count = 0;\n\n  if (points->len > 0) {\n    int i;\n    sPOINT p1 = g_array_index (points, sPOINT, points->len - 1);\n\n    for (i=0; i < points->len; i++) {\n      sPOINT p0 = p1;\n      double xi;\n\n      p1 = g_array_index (points, sPOINT, i);\n\n      if (y < p0.y && y < p1.y)\n        continue;\n\n      if (y >= p0.y && y >= p1.y)\n        continue;\n\n      xi = ((double) (p1.x - p0.x)) * (y - p0.y) / (p1.y - p0.y) + p0.x;\n\n      if (x < xi)\n        count++;\n    }\n  }\n  return (count % 2) == 1;  /* odd */\n}", "path": "libgeda\\src\\m_polygon.c", "repo_name": "manasdas17/geda-gaf", "stars": 0, "license": "None", "language": "c", "size": 19372}
{"docstring": "/*! \\brief Appends a bezier curve to the polygon\n *\n *  \\param points [inout] The vertices of the polygon. This parameter must not\n *  be NULL.\n *  \\param bezier [in] The bezier curve to append.\n *  \\param segments [in] The number of segments to subdivide the bezier curve into.\n */\n", "func_signal": "void m_polygon_append_bezier (GArray *points, BEZIER *bezier, int segments)", "code": "{\n  m_polygon_append_point (points, bezier->x[0], bezier->y[0]);\n\n  if (segments > 1) {\n    int i;\n\n    double a = 3 / (double) segments;\n    double b = 6 / pow (segments, 2);\n    double c = 6 / pow (segments, 3);\n\n    double x = bezier->x[0];\n    double xd = a * (bezier->x[1] - bezier->x[0]);\n    double xdd = b * (bezier->x[0] - 2 * bezier->x[1] + bezier->x[2]);\n    double xddd = c * (3 * (bezier->x[1] - bezier->x[2]) + bezier->x[3] - bezier->x[0]);\n\n    double xdd_div2 = xdd / 2;\n    double xddd_div2 = xddd / 2;\n    double xddd_div6 = xddd / 6;\n\n    double y = bezier->y[0];\n    double yd = a * (bezier->y[1] - bezier->y[0]);\n    double ydd = b * (bezier->y[0] - 2 * bezier->y[1] + bezier->y[2]);\n    double yddd = c * (3 * (bezier->y[1] - bezier->y[2]) + bezier->y[3] - bezier->y[0]);\n\n    double ydd_div2 = ydd / 2;\n    double yddd_div2 = yddd / 2;\n    double yddd_div6 = yddd / 6;\n\n    for (i=1; i < segments; i++) {\n      x += xd + xdd_div2 + xddd_div6;\n      xd += xdd + xddd_div2;\n      xdd += xddd;\n      xdd_div2 += xddd_div2;\n\n      y += yd + ydd_div2 + yddd_div6;\n      yd += ydd + yddd_div2;\n      ydd += yddd;\n      ydd_div2 += yddd_div2;\n\n      m_polygon_append_point (points, round (x), round (y));\n    }\n  }\n\n  m_polygon_append_point (points, bezier->x[3], bezier->y[3]);\n}", "path": "libgeda\\src\\m_polygon.c", "repo_name": "manasdas17/geda-gaf", "stars": 0, "license": "None", "language": "c", "size": 19372}
{"docstring": "/*------------------------------------------------------------------*/\n/*! \\brief This fcn through the spreadsheet, \n * extracts the attribs from\n * the cells, and places them back into TABLE.  This is the\n * first step in saving out a project.\n *\n *------------------------------------------------------------------*/\n", "func_signal": "void s_table_gtksheet_to_all_tables()", "code": "{\n\n  int num_rows;\n  int num_cols;\n  STRING_LIST *master_row_list;\n  STRING_LIST *master_col_list;\n  TABLE **local_table;\n  GtkSheet *local_gtk_sheet;     \n\n  /* First handle component sheet */\n  num_rows = sheet_head->comp_count;\n  num_cols = sheet_head->comp_attrib_count;\n  local_gtk_sheet = sheets[0];\n  master_row_list = sheet_head->master_comp_list_head;\n  master_col_list = sheet_head->master_comp_attrib_list_head;\n\n  local_table = sheet_head->component_table;\n\n  /* now fill out new table */\n#ifdef DEBUG\n  printf(\"In s_table_gtksheet_to_all_tables, now about to fill out new component table.\\n\");\n#endif\n  s_table_gtksheet_to_table(local_gtk_sheet, master_row_list, \n\t\t       master_col_list, local_table,\n\t\t       num_rows, num_cols);\n\n#if 0\n  /* Next handle net sheet */\n  num_rows = sheet_head->net_count;\n  num_cols = sheet_head->net_attrib_count;\n  local_gtk_sheet = sheets[1];\n  master_row_list = sheet_head->master_net_list_head;\n  master_col_list = sheet_head->master_net_attrib_list_head;\n  local_table = sheet_head->net_table;\n\n  s_table_gtksheet_to_table(local_gtk_sheet, master_row_list, \n\t\t       master_col_list, local_table,\n\t\t       num_rows, num_cols);\n#endif\n\n#ifdef UNIMPLEMENTED_FEATURES\n  /* Finally, handle component pin sheet */\n  num_rows = sheet_head->pin_count;\n  num_cols = sheet_head->pin_attrib_count;\n  local_gtk_sheet = sheets[2];\n  master_row_list = sheet_head->master_pin_list_head;\n  master_col_list = sheet_head->master_pin_attrib_list_head;\n  /*  local_table = s_table_new(num_rows, num_cols);  */\n  local_table = sheet_head->pin_table;\n\n  s_table_gtksheet_to_table(local_gtk_sheet, master_row_list, \n\t\t       master_col_list, local_table,\n\t\t       num_rows, num_cols);\n#endif\n\n  return;\n}", "path": "gattrib\\src\\s_table.c", "repo_name": "manasdas17/geda-gaf", "stars": 0, "license": "None", "language": "c", "size": 19372}
{"docstring": "/*! \\todo Finish function documentation!!!\n *  \\brief\n *  \\par Function Documentation\n *\n *  \\todo this has to change... to the right code\n */\n", "func_signal": "GdkColor *x_get_darkcolor(int color)", "code": "{\n  if ((color < 0) || (color >= MAX_COLORS)\n      || (gdk_outline_colors[color] == NULL)) {\n    g_warning (_(\"Tried to get an invalid color: %d\\n\"), color);\n    return(&white);\n  } else {\n    return(gdk_outline_colors[color]);\n  }\n}", "path": "gschem\\src\\x_color.c", "repo_name": "manasdas17/geda-gaf", "stars": 0, "license": "None", "language": "c", "size": 19372}
{"docstring": "/* ===================  Private Functions  ====================== */\n/*------------------------------------------------------------------*/\n/*! \\brief This fcn does the actual heaving lifting of looping \n * through the spreadsheet, extracting the attribs from\n * the cells, and placing them back into TABLE.  This is the\n * first step in saving out a project.\n *\n *------------------------------------------------------------------*/\n", "func_signal": "void s_table_gtksheet_to_table(GtkSheet *local_gtk_sheet, STRING_LIST *master_row_list, \n\t\t\t STRING_LIST *master_col_list, TABLE **local_table,\n\t\t\t int num_rows, int num_cols)", "code": "{\n  int row, col;\n\n  STRING_LIST *row_list_item;\n  gchar *row_title;\n\n  STRING_LIST *col_list_item;\n  gchar *col_title;\n  \n  gchar *attrib_value;\n\n#ifdef DEBUG\n      printf(\"**********    Entering s_table_gtksheet_to_table     ******************\\n\");\n#endif\n\n\n  row_list_item = master_row_list;\n  for (row = 0; row < num_rows; row++) {\n    row_title = (gchar *) g_strdup(row_list_item->data);\n\n    col_list_item = master_col_list;\n    for (col = 0; col < num_cols; col++) {\n      col_title = (gchar *) g_strdup(col_list_item->data);\n\n      /* get value of attrib in cell  */\n      attrib_value = (gchar *) gtk_sheet_cell_get_text(GTK_SHEET(local_gtk_sheet), row, col);\n\n#if 0\n      if (strlen(attrib_value) == 0) {\n\t/* g_free(attrib_value);  */   /* sometimes we have spurious, zero length strings creep */\n\tattrib_value = NULL;    /* into the GtkSheet                                     */\n      }\n#endif\n\n\n#ifdef DEBUG\n      printf(\"In s_table_gtksheet_to_table, found attrib_value = %s in cell row=%d, col=%d\\n\", \n\t     attrib_value, row, col);\n#endif\n\n      /* first handle attrib value in cell */\n#ifdef DEBUG\n      printf(\"     Updating attrib_value %s\\n\", attrib_value);\n#endif\n      g_free( local_table[row][col].attrib_value );\n      if (attrib_value != NULL) {\n\tlocal_table[row][col].attrib_value = (gchar *) g_strdup(attrib_value);\n      } else {\n\tlocal_table[row][col].attrib_value = NULL;\n      }\n\n      /* next handle name of row (also held in TABLE cell) */\n#ifdef DEBUG\n      printf(\"     Updating row_name %s\\n\", row_title);\n#endif\n      g_free( local_table[row][col].row_name );\n      if (row_title != NULL) {\n\tlocal_table[row][col].row_name = (gchar *) g_strdup(row_title);\n      } else {\n\tlocal_table[row][col].row_name = NULL;\n      }\n\n      /* finally handle name of col */\n#ifdef DEBUG\n      printf(\"     Updating col_name %s\\n\", col_title);\n#endif\n      g_free( local_table[row][col].col_name );\n      if (col_title != NULL) {\n\tlocal_table[row][col].col_name = (gchar *) g_strdup(col_title);\n      } else {\n\tlocal_table[row][col].col_name = NULL;\n      }\n\n      /* get next col list item and then iterate. */\n      col_list_item = col_list_item->next;\n    }\n\n    row_list_item = row_list_item->next;\n  }\n\n  return;\n}", "path": "gattrib\\src\\s_table.c", "repo_name": "manasdas17/geda-gaf", "stars": 0, "license": "None", "language": "c", "size": 19372}
{"docstring": "/*------------------------------------------------------------------*/\n/*! \\brief This fcn iterates over adds all \n * objects found on this page looking\n * for components.  When it finds a component, it finds all component\n * attribs and sticks them in the TABLE.\n *\n *------------------------------------------------------------------*/\n", "func_signal": "void s_table_add_toplevel_comp_items_to_comp_table (const GList *obj_list)", "code": "{\n  gchar *temp_uref;\n  int row, col;\n  gchar *attrib_text;\n  gchar *attrib_name;\n  gchar *attrib_value;\n  const GList *o_iter;\n  GList *a_iter;\n  OBJECT *a_current;\n  gint old_visibility, old_show_name_value;\n\n\n  if (verbose_mode) {\n    printf(\"- Starting internal component TABLE creation\\n\");\n  }\n\n#ifdef DEBUG\n  fflush(stderr);\n  fflush(stdout);\n  printf(\"=========== Just entered  s_table_add_toplevel_comp_items_to_comp_table!  ==============\\n\");\n#endif\n\n  /* -----  Iterate through all objects found on page  ----- */\n  for (o_iter = obj_list; o_iter != NULL; o_iter = g_list_next (o_iter)) {\n    OBJECT *o_current = o_iter->data;\n\n#ifdef DEBUG\n      printf(\"   ---> In s_table_add_toplevel_comp_items_to_comp_table, examining o_current->name = %s\\n\", o_current->name);\n#endif\n\n    /* -----  Now process objects found on page  ----- */\n    if (o_current->type == OBJ_COMPLEX &&\n        o_current->attribs != NULL) {\n\n      /* ---- Don't process part if it lacks a refdes ----- */\n      temp_uref = g_strdup(s_attrib_get_refdes(o_current));\n      if (temp_uref) {\n\n#if DEBUG\n        printf(\"      In s_table_add_toplevel_comp_items_to_comp_table, found component on page. Refdes = %s\\n\", temp_uref);\n#endif\n        verbose_print(\" C\");\n\n        /* Having found a component, we loop over all attribs in this\n         * component, and stick them\n         * into cells in the table. */\n        a_iter = o_current->attribs;\n        while (a_iter != NULL) {\n          a_current = a_iter->data;\n          if (a_current->type == OBJ_TEXT\n              && a_current->text != NULL) {  /* found an attribute */\n            /* may need to check more thoroughly here. . . . */\n            attrib_text = g_strdup(a_current->text->string);\n            o_attrib_get_name_value(attrib_text, &attrib_name, &attrib_value);\n            attrib_name = u_basic_breakup_string(attrib_text, '=', 0);\n            attrib_value = s_misc_remaining_string(attrib_text, '=', 1);\n\t    old_visibility = a_current->visibility;\n\t    old_show_name_value = a_current->show_name_value;\n\n\t    /* Don't include \"refdes\" or \"slot\" because they form the row name. */\n\t    /* Also don't include \"net\" per bug found by Steve W.  4.3.2007 -- SDB */\n            if ( (strcmp(attrib_name, \"refdes\") != 0) &&\n\t\t (strcmp(attrib_name, \"net\") != 0) &&\n\t\t (strcmp(attrib_name, \"slot\") != 0) ) {\n               \n              /* Get row and col where to put this attrib */\n              row = s_table_get_index(sheet_head->master_comp_list_head, temp_uref);\n              col = s_table_get_index(sheet_head->master_comp_attrib_list_head, attrib_name);\n              /* Sanity check */\n              if (row == -1 || col == -1) {\n                /* we didn't find the item in the table */\n                fprintf (stderr,\n                         \"In s_table_add_toplevel_comp_items_to_comp_table, we didn't find either row or col in the lists!\\n\");\n              } else {\n\n#if DEBUG\n                printf(\"       In s_table_add_toplevel_comp_items_to_comp_table, about to add row %d, col %d, attrib_value = %s\\n\",\n                       row, col, attrib_value);\n                printf(\" . . . current address of attrib_value cell is [%p]\\n\", &((sheet_head->component_table)[row][col]).attrib_value);\n#endif\n                /* Is there a compelling reason for me to put this into a separate fcn? */\n                ((sheet_head->component_table)[row][col]).row = row;\n                ((sheet_head->component_table)[row][col]).col = col;\n                ((sheet_head->component_table)[row][col]).row_name = g_strdup(temp_uref);\n                ((sheet_head->component_table)[row][col]).col_name = g_strdup(attrib_name);\n                ((sheet_head->component_table)[row][col]).attrib_value = g_strdup(attrib_value);\n                ((sheet_head->component_table)[row][col]).visibility = old_visibility;\n                ((sheet_head->component_table)[row][col]).show_name_value = old_show_name_value;\n              }\n            }\n            g_free(attrib_name);\n            g_free(attrib_text);\n            g_free(attrib_value);\n          }\n          a_iter = g_list_next (a_iter);\n           \n        }  /* while (a_current != NULL) */\n        g_free(temp_uref);\n      }  /* if (temp_uref) */\n    }    /* if (o_current->type == OBJ_COMPLEX)  */\n  }\n \n  verbose_done();\n \n}", "path": "gattrib\\src\\s_table.c", "repo_name": "manasdas17/geda-gaf", "stars": 0, "license": "None", "language": "c", "size": 19372}
{"docstring": "/*! \\brief Initializes the color system for the application.\n *  \\par Function Documentation\n *\n *  Initialises the color maps to defaults.\n */\n", "func_signal": "void\nx_color_init (void)", "code": "{\n  colormap = gdk_colormap_get_system ();\n\n  /* Initialise default color maps */\n  s_color_map_defaults (display_colors);\n  s_color_map_defaults (display_outline_colors);\n}", "path": "gschem\\src\\x_color.c", "repo_name": "manasdas17/geda-gaf", "stars": 0, "license": "None", "language": "c", "size": 19372}
{"docstring": "/*! \\todo Finish function documentation!!!\n *  \\brief\n *  \\par Function Documentation\n *\n */\n", "func_signal": "COLOR *x_color_lookup (int color)", "code": "{\n  if (color < 0 || color >= MAX_COLORS ||\n      !display_colors[color].enabled) {\n    fprintf(stderr, _(\"Tried to get an invalid color: %d\\n\"), color);\n    return &display_colors[DEFAULT_COLOR];\n  } else {\n    return &display_colors[color];\n  }\n}", "path": "gschem\\src\\x_color.c", "repo_name": "manasdas17/geda-gaf", "stars": 0, "license": "None", "language": "c", "size": 19372}
{"docstring": "/*! \\brief Appends a point to the list of vertices in a polygon\n *\n *  \\param points [inout] The vertices of the polygon. This parameter must not\n *  be NULL.\n *  \\param x [in] The x coordinate of the point to append.\n *  \\param y [in] The y coordinate of the point to append.\n */\n", "func_signal": "void m_polygon_append_point (GArray *points, int x, int y)", "code": "{\n  sPOINT point = { x, y };\n\n  point.x = x;\n  point.y = y;\n\n  if (points->len == 0 ||\n      memcmp (&g_array_index (points, sPOINT, points->len - 1),\n              &point, sizeof (sPOINT)) != 0) {\n    g_array_append_val (points, point);\n  }\n}", "path": "libgeda\\src\\m_polygon.c", "repo_name": "manasdas17/geda-gaf", "stars": 0, "license": "None", "language": "c", "size": 19372}
{"docstring": "/*------------------------------------------------------------------*/\n/*! \\brief This fcn iterates over adds all items found on this page\n * looking for pins.  WHen it finds a pin, it gathers all\n * pin attribs and sticks them into the pin table. \n *\n *------------------------------------------------------------------*/\n", "func_signal": "void s_table_add_toplevel_pin_items_to_pin_table (const GList *obj_list)", "code": "{\n  gchar *temp_uref;\n  gchar *pinnumber;\n  gchar *row_label;\n  int row, col;\n  gchar *attrib_text;\n  gchar *attrib_name;\n  gchar *attrib_value;\n  const GList *o_iter;\n  GList *a_iter;\n  GList *o_lower_iter;\n  OBJECT *pin_attrib;\n\n  if (verbose_mode) {\n    printf(\"- Starting internal pin TABLE creation\\n\");\n  }\n\n#ifdef DEBUG\n  printf(\"=========== Just entered  s_table_add_toplevel_pin_items_to_pin_table!  ==============\\n\");\n#endif\n\n  /* -----  Iterate through all objects found on page  ----- */\n  for (o_iter = obj_list; o_iter != NULL; o_iter = g_list_next (o_iter)) {\n    OBJECT *o_current = o_iter->data;\n\n#ifdef DEBUG\n      printf(\"   ---> In s_table_add_toplevel_pin_items_to_pin_table, examining o_current->name = %s\\n\", o_current->name);\n#endif\n\n    /* -----  Now process objects found on page  ----- */\n    if (o_current->type == OBJ_COMPLEX &&\n        o_current->attribs != NULL) {\n\n      /* ---- Don't process part if it lacks a refdes ----- */\n      temp_uref = s_attrib_get_refdes(o_current);\n      if (temp_uref) {\n\n\t/* -----  Now iterate through lower level objects looking for pins.  ----- */\n        for (o_lower_iter = o_current->complex->prim_objs;\n             o_lower_iter != NULL;\n             o_lower_iter = g_list_next (o_lower_iter)) {\n          OBJECT *o_lower_current = o_lower_iter->data;\n\n\t  if (o_lower_current->type == OBJ_PIN) {\n\t    /* -----  Found a pin.  First get its pinnumber.  then get attrib head and loop on attribs.  ----- */\n\t    pinnumber = o_attrib_search_name_single(o_lower_current, \"pinnumber\", NULL);\n\t    row_label = g_strconcat(temp_uref, \":\", pinnumber, NULL);\n\n#if DEBUG\n        printf(\"      In s_table_add_toplevel_pin_items_to_pin_table, examining pin %s\\n\", row_label);\n#endif\n\n\t    a_iter = o_lower_current->attribs;\n\t    while (a_iter != NULL) {\n\t      pin_attrib = a_iter->data;\n\t      if (pin_attrib->type == OBJ_TEXT\n\t\t  && pin_attrib->text != NULL) {  /* found an attribute */\n\t\tattrib_text = g_strdup(pin_attrib->text->string);\n\t\tattrib_name = u_basic_breakup_string(attrib_text, '=', 0);\n\t\tattrib_value = s_misc_remaining_string(attrib_text, '=', 1);\n \n\t\tif ( (strcmp(attrib_name, \"pinnumber\") != 0) \n\t\t     && (attrib_value != 0) ) {\n\t\t  /* Don't include \"pinnumber\" because it is already in other master list.\n\t\t   * Also must ensure that value is non-null; certain symbols are not well formed.\n\t\t   */\n\n\t\t  /* Get row and col where to put this attrib */\n\t\t  row = s_table_get_index(sheet_head->master_pin_list_head, row_label);\n\t\t  col = s_table_get_index(sheet_head->master_pin_attrib_list_head, attrib_name);\n                  /* Sanity check */\n                  if (row == -1 || col == -1) {\n                    /* we didn't find the item in the table */\n                    fprintf (stderr,\n                             \"In s_table_add_toplevel_pin_items_to_pin_table, we didn't find either row or col in the lists!\\n\");\n                  } else {\n\n#if DEBUG\n                    printf(\"       In s_table_add_toplevel_pin_items_to_pin_table, about to add row %d, col %d, attrib_value = %s\\n\",\n                           row, col, attrib_value);\n                    printf(\" . . . current address of attrib_value cell is [%p]\\n\", &((sheet_head->component_table)[row][col]).attrib_value);\n#endif\n                    /* Is there a compelling reason for me to put this into a separate fcn? */\n                    ((sheet_head->pin_table)[row][col]).row = row;\n                    ((sheet_head->pin_table)[row][col]).col = col;\n                    ((sheet_head->pin_table)[row][col]).row_name = g_strdup(row_label);\n                    ((sheet_head->pin_table)[row][col]).col_name = g_strdup(attrib_name);\n                    ((sheet_head->pin_table)[row][col]).attrib_value = g_strdup(attrib_value);\n                  }\n                }\n\t\tg_free(attrib_name);\n\t\tg_free(attrib_text);\n\t\tg_free(attrib_value);\n\t      }\n\t      a_iter = g_list_next (a_iter);\n           \n\t    }  /* while (pin_attrib != NULL) */\n\t    g_free(pinnumber);\n\t    g_free(row_label);\n\t  }\n\n        }\n      }\n\n      g_free(temp_uref);\n    }\n\n  }\n \n  verbose_done();\n}", "path": "gattrib\\src\\s_table.c", "repo_name": "manasdas17/geda-gaf", "stars": 0, "license": "None", "language": "c", "size": 19372}
{"docstring": "/* predict what lock level we'll be dropping down to on behalf\n * of another node, and return true if the currently wanted\n * level will be compatible with it. */\n", "func_signal": "static inline int\nuser_may_continue_on_blocked_lock(struct user_lock_res *lockres,\n\t\t\t\t  int wanted)", "code": "{\n\tBUG_ON(!(lockres->l_flags & USER_LOCK_BLOCKED));\n\n\treturn wanted <= user_highest_compat_lock_level(lockres->l_blocking);\n}", "path": "fs\\ocfs2\\dlm\\userdlm.c", "repo_name": "zcchina/linux-omap", "stars": 1, "license": "other", "language": "c", "size": 321204}
{"docstring": "/*\n * Helper that calls task->tk_ops->rpc_call_done if it exists\n */\n", "func_signal": "void rpc_exit_task(struct rpc_task *task)", "code": "{\n\ttask->tk_action = NULL;\n\tif (task->tk_ops->rpc_call_done != NULL) {\n\t\ttask->tk_ops->rpc_call_done(task, task->tk_calldata);\n\t\tif (task->tk_action != NULL) {\n\t\t\tWARN_ON(RPC_ASSASSINATED(task));\n\t\t\t/* Always release the RPC slot and buffer memory */\n\t\t\txprt_release(task);\n\t\t}\n\t}\n}", "path": "net\\sunrpc\\sched.c", "repo_name": "zcchina/linux-omap", "stars": 1, "license": "other", "language": "c", "size": 321204}
{"docstring": "/**\n * rpc_malloc - allocate an RPC buffer\n * @task: RPC task that will use this buffer\n * @size: requested byte size\n *\n * To prevent rpciod from hanging, this allocator never sleeps,\n * returning NULL if the request cannot be serviced immediately.\n * The caller can arrange to sleep in a way that is safe for rpciod.\n *\n * Most requests are 'small' (under 2KiB) and can be serviced from a\n * mempool, ensuring that NFS reads and writes can always proceed,\n * and that there is good locality of reference for these buffers.\n *\n * In order to avoid memory starvation triggering more writebacks of\n * NFS requests, we avoid using GFP_KERNEL.\n */\n", "func_signal": "void *rpc_malloc(struct rpc_task *task, size_t size)", "code": "{\n\tstruct rpc_buffer *buf;\n\tgfp_t gfp = RPC_IS_SWAPPER(task) ? GFP_ATOMIC : GFP_NOWAIT;\n\n\tsize += sizeof(struct rpc_buffer);\n\tif (size <= RPC_BUFFER_MAXSIZE)\n\t\tbuf = mempool_alloc(rpc_buffer_mempool, gfp);\n\telse\n\t\tbuf = kmalloc(size, gfp);\n\n\tif (!buf)\n\t\treturn NULL;\n\n\tbuf->len = size;\n\tdprintk(\"RPC: %5u allocated buffer of size %zu at %p\\n\",\n\t\t\ttask->tk_pid, size, buf);\n\treturn &buf->data;\n}", "path": "net\\sunrpc\\sched.c", "repo_name": "zcchina/linux-omap", "stars": 1, "license": "other", "language": "c", "size": 321204}
{"docstring": "/* CONFIG_SSB_BLOCKIO */\n", "func_signal": "static void ssb_pci_write8(struct ssb_device *dev, u16 offset, u8 value)", "code": "{\n\tstruct ssb_bus *bus = dev->bus;\n\n\tif (unlikely(ssb_pci_assert_buspower(bus)))\n\t\treturn;\n\tif (unlikely(bus->mapped_device != dev)) {\n\t\tif (unlikely(ssb_pci_switch_core(bus, dev)))\n\t\t\treturn;\n\t}\n\tiowrite8(value, bus->mmio + offset);\n}", "path": "drivers\\ssb\\pci.c", "repo_name": "zcchina/linux-omap", "stars": 1, "license": "other", "language": "c", "size": 321204}
{"docstring": "/*\n * Disable the timer for a given RPC task. Should be called with\n * queue->lock and bh_disabled in order to avoid races within\n * rpc_run_timer().\n */\n", "func_signal": "static void\n__rpc_disable_timer(struct rpc_wait_queue *queue, struct rpc_task *task)", "code": "{\n\tif (task->tk_timeout == 0)\n\t\treturn;\n\tdprintk(\"RPC: %5u disabling timer\\n\", task->tk_pid);\n\ttask->tk_timeout = 0;\n\tlist_del(&task->u.tk_wait.timer_list);\n\tif (list_empty(&queue->timer_list.list))\n\t\tdel_timer(&queue->timer_list.timer);\n}", "path": "net\\sunrpc\\sched.c", "repo_name": "zcchina/linux-omap", "stars": 1, "license": "other", "language": "c", "size": 321204}
{"docstring": "/*\n * Creation and deletion of RPC task structures\n */\n", "func_signal": "static void rpc_init_task(struct rpc_task *task, const struct rpc_task_setup *task_setup_data)", "code": "{\n\tmemset(task, 0, sizeof(*task));\n\tatomic_set(&task->tk_count, 1);\n\ttask->tk_flags  = task_setup_data->flags;\n\ttask->tk_ops = task_setup_data->callback_ops;\n\ttask->tk_calldata = task_setup_data->callback_data;\n\tINIT_LIST_HEAD(&task->tk_task);\n\n\t/* Initialize retry counters */\n\ttask->tk_garb_retry = 2;\n\ttask->tk_cred_retry = 2;\n\n\ttask->tk_priority = task_setup_data->priority - RPC_PRIORITY_LOW;\n\ttask->tk_owner = current->tgid;\n\n\t/* Initialize workqueue for async tasks */\n\ttask->tk_workqueue = task_setup_data->workqueue;\n\n\ttask->tk_client = task_setup_data->rpc_client;\n\tif (task->tk_client != NULL) {\n\t\tkref_get(&task->tk_client->cl_kref);\n\t\tif (task->tk_client->cl_softrtry)\n\t\t\ttask->tk_flags |= RPC_TASK_SOFT;\n\t}\n\n\tif (task->tk_ops->rpc_call_prepare != NULL)\n\t\ttask->tk_action = rpc_prepare_task;\n\n\tif (task_setup_data->rpc_message != NULL) {\n\t\ttask->tk_msg.rpc_proc = task_setup_data->rpc_message->rpc_proc;\n\t\ttask->tk_msg.rpc_argp = task_setup_data->rpc_message->rpc_argp;\n\t\ttask->tk_msg.rpc_resp = task_setup_data->rpc_message->rpc_resp;\n\t\t/* Bind the user cred */\n\t\trpcauth_bindcred(task, task_setup_data->rpc_message->rpc_cred, task_setup_data->flags);\n\t\tif (task->tk_action == NULL)\n\t\t\trpc_call_start(task);\n\t}\n\n\t/* starting timestamp */\n\ttask->tk_start = jiffies;\n\n\tdprintk(\"RPC:       new task initialized, procpid %u\\n\",\n\t\t\t\ttask_pid_nr(current));\n}", "path": "net\\sunrpc\\sched.c", "repo_name": "zcchina/linux-omap", "stars": 1, "license": "other", "language": "c", "size": 321204}
{"docstring": "/* Lowlevel coreswitching */\n", "func_signal": "int ssb_pci_switch_coreidx(struct ssb_bus *bus, u8 coreidx)", "code": "{\n\tint err;\n\tint attempts = 0;\n\tu32 cur_core;\n\n\twhile (1) {\n\t\terr = pci_write_config_dword(bus->host_pci, SSB_BAR0_WIN,\n\t\t\t\t\t     (coreidx * SSB_CORE_SIZE)\n\t\t\t\t\t     + SSB_ENUM_BASE);\n\t\tif (err)\n\t\t\tgoto error;\n\t\terr = pci_read_config_dword(bus->host_pci, SSB_BAR0_WIN,\n\t\t\t\t\t    &cur_core);\n\t\tif (err)\n\t\t\tgoto error;\n\t\tcur_core = (cur_core - SSB_ENUM_BASE)\n\t\t\t   / SSB_CORE_SIZE;\n\t\tif (cur_core == coreidx)\n\t\t\tbreak;\n\n\t\tif (attempts++ > SSB_BAR0_MAX_RETRIES)\n\t\t\tgoto error;\n\t\tudelay(10);\n\t}\n\treturn 0;\nerror:\n\tssb_printk(KERN_ERR PFX \"Failed to switch to core %u\\n\", coreidx);\n\treturn -ENODEV;\n}", "path": "drivers\\ssb\\pci.c", "repo_name": "zcchina/linux-omap", "stars": 1, "license": "other", "language": "c", "size": 321204}
{"docstring": "/*\n * Make an RPC task runnable.\n *\n * Note: If the task is ASYNC, this must be called with\n * the spinlock held to protect the wait queue operation.\n */\n", "func_signal": "static void rpc_make_runnable(struct rpc_task *task)", "code": "{\n\trpc_clear_queued(task);\n\tif (rpc_test_and_set_running(task))\n\t\treturn;\n\t/* We might have raced */\n\tif (RPC_IS_QUEUED(task)) {\n\t\trpc_clear_running(task);\n\t\treturn;\n\t}\n\tif (RPC_IS_ASYNC(task)) {\n\t\tint status;\n\n\t\tINIT_WORK(&task->u.tk_work, rpc_async_schedule);\n\t\tstatus = queue_work(rpciod_workqueue, &task->u.tk_work);\n\t\tif (status < 0) {\n\t\t\tprintk(KERN_WARNING \"RPC: failed to add task to queue: error: %d!\\n\", status);\n\t\t\ttask->tk_status = status;\n\t\t\treturn;\n\t\t}\n\t} else\n\t\twake_up_bit(&task->tk_runstate, RPC_TASK_QUEUED);\n}", "path": "net\\sunrpc\\sched.c", "repo_name": "zcchina/linux-omap", "stars": 1, "license": "other", "language": "c", "size": 321204}
{"docstring": "/* Select RFBI or bypass mode */\n", "func_signal": "static void enable_rfbi_mode(int enable)", "code": "{\n\tu32 l;\n\n\tl = dispc_read_reg(DISPC_CONTROL);\n\t/* Enable RFBI, GPIO0/1 */\n\tl &= ~((1 << 11) | (1 << 15) | (1 << 16));\n\tl |= enable ? (1 << 11) : 0;\n\t/* RFBI En: GPIO0/1=10  RFBI Dis: GPIO0/1=11 */\n\tl |= 1 << 15;\n\tl |= enable ? 0 : (1 << 16);\n\tdispc_write_reg(DISPC_CONTROL, l);\n\n\t/* Set bypass mode in RFBI module */\n\tl = __raw_readl(IO_ADDRESS(RFBI_CONTROL));\n\tl |= enable ? 0 : (1 << 1);\n\t__raw_writel(l, IO_ADDRESS(RFBI_CONTROL));\n}", "path": "drivers\\video\\omap\\dispc.c", "repo_name": "zcchina/linux-omap", "stars": 1, "license": "other", "language": "c", "size": 321204}
{"docstring": "/*\n * Mark an RPC call as having completed by clearing the 'active' bit\n */\n", "func_signal": "static void rpc_mark_complete_task(struct rpc_task *task)", "code": "{\n\tsmp_mb__before_clear_bit();\n\tclear_bit(RPC_TASK_ACTIVE, &task->tk_runstate);\n\tsmp_mb__after_clear_bit();\n\twake_up_bit(&task->tk_runstate, RPC_TASK_ACTIVE);\n}", "path": "net\\sunrpc\\sched.c", "repo_name": "zcchina/linux-omap", "stars": 1, "license": "other", "language": "c", "size": 321204}
{"docstring": "/*\n * Set up a timer for the current task.\n */\n", "func_signal": "static void\n__rpc_add_timer(struct rpc_wait_queue *queue, struct rpc_task *task)", "code": "{\n\tif (!task->tk_timeout)\n\t\treturn;\n\n\tdprintk(\"RPC: %5u setting alarm for %lu ms\\n\",\n\t\t\ttask->tk_pid, task->tk_timeout * 1000 / HZ);\n\n\ttask->u.tk_wait.expires = jiffies + task->tk_timeout;\n\tif (list_empty(&queue->timer_list.list) || time_before(task->u.tk_wait.expires, queue->timer_list.expires))\n\t\trpc_set_queue_timer(queue, task->u.tk_wait.expires);\n\tlist_add(&task->u.tk_wait.timer_list, &queue->timer_list.list);\n}", "path": "net\\sunrpc\\sched.c", "repo_name": "zcchina/linux-omap", "stars": 1, "license": "other", "language": "c", "size": 321204}
{"docstring": "/*\n * Create a new task for the specified client.\n */\n", "func_signal": "struct rpc_task *rpc_new_task(const struct rpc_task_setup *setup_data)", "code": "{\n\tstruct rpc_task\t*task = setup_data->task;\n\tunsigned short flags = 0;\n\n\tif (task == NULL) {\n\t\ttask = rpc_alloc_task();\n\t\tif (task == NULL)\n\t\t\tgoto out;\n\t\tflags = RPC_TASK_DYNAMIC;\n\t}\n\n\trpc_init_task(task, setup_data);\n\n\ttask->tk_flags |= flags;\n\tdprintk(\"RPC:       allocated task %p\\n\", task);\nout:\n\treturn task;\n}", "path": "net\\sunrpc\\sched.c", "repo_name": "zcchina/linux-omap", "stars": 1, "license": "other", "language": "c", "size": 321204}
{"docstring": "/*\n * Remove request from a priority queue.\n */\n", "func_signal": "static void __rpc_remove_wait_queue_priority(struct rpc_task *task)", "code": "{\n\tstruct rpc_task *t;\n\n\tif (!list_empty(&task->u.tk_wait.links)) {\n\t\tt = list_entry(task->u.tk_wait.links.next, struct rpc_task, u.tk_wait.list);\n\t\tlist_move(&t->u.tk_wait.list, &task->u.tk_wait.list);\n\t\tlist_splice_init(&task->u.tk_wait.links, &t->u.tk_wait.links);\n\t}\n}", "path": "net\\sunrpc\\sched.c", "repo_name": "zcchina/linux-omap", "stars": 1, "license": "other", "language": "c", "size": 321204}
{"docstring": "/* Enable/disable the on board crystal oscillator and/or PLL. */\n", "func_signal": "int ssb_pci_xtal(struct ssb_bus *bus, u32 what, int turn_on)", "code": "{\n\tint err;\n\tu32 in, out, outenable;\n\tu16 pci_status;\n\n\tif (bus->bustype != SSB_BUSTYPE_PCI)\n\t\treturn 0;\n\n\terr = pci_read_config_dword(bus->host_pci, SSB_GPIO_IN, &in);\n\tif (err)\n\t\tgoto err_pci;\n\terr = pci_read_config_dword(bus->host_pci, SSB_GPIO_OUT, &out);\n\tif (err)\n\t\tgoto err_pci;\n\terr = pci_read_config_dword(bus->host_pci, SSB_GPIO_OUT_ENABLE, &outenable);\n\tif (err)\n\t\tgoto err_pci;\n\n\toutenable |= what;\n\n\tif (turn_on) {\n\t\t/* Avoid glitching the clock if GPRS is already using it.\n\t\t * We can't actually read the state of the PLLPD so we infer it\n\t\t * by the value of XTAL_PU which *is* readable via gpioin.\n\t\t */\n\t\tif (!(in & SSB_GPIO_XTAL)) {\n\t\t\tif (what & SSB_GPIO_XTAL) {\n\t\t\t\t/* Turn the crystal on */\n\t\t\t\tout |= SSB_GPIO_XTAL;\n\t\t\t\tif (what & SSB_GPIO_PLL)\n\t\t\t\t\tout |= SSB_GPIO_PLL;\n\t\t\t\terr = pci_write_config_dword(bus->host_pci, SSB_GPIO_OUT, out);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto err_pci;\n\t\t\t\terr = pci_write_config_dword(bus->host_pci, SSB_GPIO_OUT_ENABLE,\n\t\t\t\t\t\t\t     outenable);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto err_pci;\n\t\t\t\tmsleep(1);\n\t\t\t}\n\t\t\tif (what & SSB_GPIO_PLL) {\n\t\t\t\t/* Turn the PLL on */\n\t\t\t\tout &= ~SSB_GPIO_PLL;\n\t\t\t\terr = pci_write_config_dword(bus->host_pci, SSB_GPIO_OUT, out);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto err_pci;\n\t\t\t\tmsleep(5);\n\t\t\t}\n\t\t}\n\n\t\terr = pci_read_config_word(bus->host_pci, PCI_STATUS, &pci_status);\n\t\tif (err)\n\t\t\tgoto err_pci;\n\t\tpci_status &= ~PCI_STATUS_SIG_TARGET_ABORT;\n\t\terr = pci_write_config_word(bus->host_pci, PCI_STATUS, pci_status);\n\t\tif (err)\n\t\t\tgoto err_pci;\n\t} else {\n\t\tif (what & SSB_GPIO_XTAL) {\n\t\t\t/* Turn the crystal off */\n\t\t\tout &= ~SSB_GPIO_XTAL;\n\t\t}\n\t\tif (what & SSB_GPIO_PLL) {\n\t\t\t/* Turn the PLL off */\n\t\t\tout |= SSB_GPIO_PLL;\n\t\t}\n\t\terr = pci_write_config_dword(bus->host_pci, SSB_GPIO_OUT, out);\n\t\tif (err)\n\t\t\tgoto err_pci;\n\t\terr = pci_write_config_dword(bus->host_pci, SSB_GPIO_OUT_ENABLE, outenable);\n\t\tif (err)\n\t\t\tgoto err_pci;\n\t}\n\nout:\n\treturn err;\n\nerr_pci:\n\tprintk(KERN_ERR PFX \"Error: ssb_pci_xtal() could not access PCI config space!\\n\");\n\terr = -EBUSY;\n\tgoto out;\n}", "path": "drivers\\ssb\\pci.c", "repo_name": "zcchina/linux-omap", "stars": 1, "license": "other", "language": "c", "size": 321204}
{"docstring": "/*\n * Prepare for sleeping on a wait queue.\n * By always appending tasks to the list we ensure FIFO behavior.\n * NB: An RPC task will only receive interrupt-driven events as long\n * as it's on a wait queue.\n */\n", "func_signal": "static void __rpc_sleep_on(struct rpc_wait_queue *q, struct rpc_task *task,\n\t\t\trpc_action action)", "code": "{\n\tdprintk(\"RPC: %5u sleep_on(queue \\\"%s\\\" time %lu)\\n\",\n\t\t\ttask->tk_pid, rpc_qname(q), jiffies);\n\n\tif (!RPC_IS_ASYNC(task) && !RPC_IS_ACTIVATED(task)) {\n\t\tprintk(KERN_ERR \"RPC: Inactive synchronous task put to sleep!\\n\");\n\t\treturn;\n\t}\n\n\t__rpc_add_wait_queue(q, task);\n\n\tBUG_ON(task->tk_callback != NULL);\n\ttask->tk_callback = action;\n\t__rpc_add_timer(q, task);\n}", "path": "net\\sunrpc\\sched.c", "repo_name": "zcchina/linux-omap", "stars": 1, "license": "other", "language": "c", "size": 321204}
{"docstring": "/*\n * Add new request to wait queue.\n *\n * Swapper tasks always get inserted at the head of the queue.\n * This should avoid many nasty memory deadlocks and hopefully\n * improve overall performance.\n * Everyone else gets appended to the queue to ensure proper FIFO behavior.\n */\n", "func_signal": "static void __rpc_add_wait_queue(struct rpc_wait_queue *queue, struct rpc_task *task)", "code": "{\n\tBUG_ON (RPC_IS_QUEUED(task));\n\n\tif (RPC_IS_PRIORITY(queue))\n\t\t__rpc_add_wait_queue_priority(queue, task);\n\telse if (RPC_IS_SWAPPER(task))\n\t\tlist_add(&task->u.tk_wait.list, &queue->tasks[0]);\n\telse\n\t\tlist_add_tail(&task->u.tk_wait.list, &queue->tasks[0]);\n\ttask->tk_waitqueue = queue;\n\tqueue->qlen++;\n\trpc_set_queued(task);\n\n\tdprintk(\"RPC: %5u added to queue %p \\\"%s\\\"\\n\",\n\t\t\ttask->tk_pid, queue, rpc_qname(queue));\n}", "path": "net\\sunrpc\\sched.c", "repo_name": "zcchina/linux-omap", "stars": 1, "license": "other", "language": "c", "size": 321204}
{"docstring": "/*\n * Wake up the next task on the wait queue.\n */\n", "func_signal": "struct rpc_task * rpc_wake_up_next(struct rpc_wait_queue *queue)", "code": "{\n\tstruct rpc_task\t*task = NULL;\n\n\tdprintk(\"RPC:       wake_up_next(%p \\\"%s\\\")\\n\",\n\t\t\tqueue, rpc_qname(queue));\n\tspin_lock_bh(&queue->lock);\n\tif (RPC_IS_PRIORITY(queue))\n\t\ttask = __rpc_wake_up_next_priority(queue);\n\telse {\n\t\ttask_for_first(task, &queue->tasks[0])\n\t\t\trpc_wake_up_task_queue_locked(queue, task);\n\t}\n\tspin_unlock_bh(&queue->lock);\n\n\treturn task;\n}", "path": "net\\sunrpc\\sched.c", "repo_name": "zcchina/linux-omap", "stars": 1, "license": "other", "language": "c", "size": 321204}
{"docstring": "/**\n * rpc_wake_up_status - wake up all rpc_tasks and set their status value.\n * @queue: rpc_wait_queue on which the tasks are sleeping\n * @status: status value to set\n *\n * Grabs queue->lock\n */\n", "func_signal": "void rpc_wake_up_status(struct rpc_wait_queue *queue, int status)", "code": "{\n\tstruct rpc_task *task, *next;\n\tstruct list_head *head;\n\n\tspin_lock_bh(&queue->lock);\n\thead = &queue->tasks[queue->maxpriority];\n\tfor (;;) {\n\t\tlist_for_each_entry_safe(task, next, head, u.tk_wait.list) {\n\t\t\ttask->tk_status = status;\n\t\t\trpc_wake_up_task_queue_locked(queue, task);\n\t\t}\n\t\tif (head == &queue->tasks[0])\n\t\t\tbreak;\n\t\thead--;\n\t}\n\tspin_unlock_bh(&queue->lock);\n}", "path": "net\\sunrpc\\sched.c", "repo_name": "zcchina/linux-omap", "stars": 1, "license": "other", "language": "c", "size": 321204}
{"docstring": "/*\n * Wake up the next task on a priority queue.\n */\n", "func_signal": "static struct rpc_task * __rpc_wake_up_next_priority(struct rpc_wait_queue *queue)", "code": "{\n\tstruct list_head *q;\n\tstruct rpc_task *task;\n\n\t/*\n\t * Service a batch of tasks from a single owner.\n\t */\n\tq = &queue->tasks[queue->priority];\n\tif (!list_empty(q)) {\n\t\ttask = list_entry(q->next, struct rpc_task, u.tk_wait.list);\n\t\tif (queue->owner == task->tk_owner) {\n\t\t\tif (--queue->nr)\n\t\t\t\tgoto out;\n\t\t\tlist_move_tail(&task->u.tk_wait.list, q);\n\t\t}\n\t\t/*\n\t\t * Check if we need to switch queues.\n\t\t */\n\t\tif (--queue->count)\n\t\t\tgoto new_owner;\n\t}\n\n\t/*\n\t * Service the next queue.\n\t */\n\tdo {\n\t\tif (q == &queue->tasks[0])\n\t\t\tq = &queue->tasks[queue->maxpriority];\n\t\telse\n\t\t\tq = q - 1;\n\t\tif (!list_empty(q)) {\n\t\t\ttask = list_entry(q->next, struct rpc_task, u.tk_wait.list);\n\t\t\tgoto new_queue;\n\t\t}\n\t} while (q != &queue->tasks[queue->priority]);\n\n\trpc_reset_waitqueue_priority(queue);\n\treturn NULL;\n\nnew_queue:\n\trpc_set_waitqueue_priority(queue, (unsigned int)(q - &queue->tasks[0]));\nnew_owner:\n\trpc_set_waitqueue_owner(queue, task->tk_owner);\nout:\n\trpc_wake_up_task_queue_locked(queue, task);\n\treturn task;\n}", "path": "net\\sunrpc\\sched.c", "repo_name": "zcchina/linux-omap", "stars": 1, "license": "other", "language": "c", "size": 321204}
{"docstring": "/*\n * This is the RPC `scheduler' (or rather, the finite state machine).\n */\n", "func_signal": "static void __rpc_execute(struct rpc_task *task)", "code": "{\n\tint\t\tstatus = 0;\n\n\tdprintk(\"RPC: %5u __rpc_execute flags=0x%x\\n\",\n\t\t\ttask->tk_pid, task->tk_flags);\n\n\tBUG_ON(RPC_IS_QUEUED(task));\n\n\tfor (;;) {\n\n\t\t/*\n\t\t * Execute any pending callback.\n\t\t */\n\t\tif (task->tk_callback) {\n\t\t\tvoid (*save_callback)(struct rpc_task *);\n\n\t\t\t/*\n\t\t\t * We set tk_callback to NULL before calling it,\n\t\t\t * in case it sets the tk_callback field itself:\n\t\t\t */\n\t\t\tsave_callback = task->tk_callback;\n\t\t\ttask->tk_callback = NULL;\n\t\t\tsave_callback(task);\n\t\t}\n\n\t\t/*\n\t\t * Perform the next FSM step.\n\t\t * tk_action may be NULL when the task has been killed\n\t\t * by someone else.\n\t\t */\n\t\tif (!RPC_IS_QUEUED(task)) {\n\t\t\tif (task->tk_action == NULL)\n\t\t\t\tbreak;\n\t\t\ttask->tk_action(task);\n\t\t}\n\n\t\t/*\n\t\t * Lockless check for whether task is sleeping or not.\n\t\t */\n\t\tif (!RPC_IS_QUEUED(task))\n\t\t\tcontinue;\n\t\trpc_clear_running(task);\n\t\tif (RPC_IS_ASYNC(task)) {\n\t\t\t/* Careful! we may have raced... */\n\t\t\tif (RPC_IS_QUEUED(task))\n\t\t\t\treturn;\n\t\t\tif (rpc_test_and_set_running(task))\n\t\t\t\treturn;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* sync task: sleep here */\n\t\tdprintk(\"RPC: %5u sync task going to sleep\\n\", task->tk_pid);\n\t\tstatus = out_of_line_wait_on_bit(&task->tk_runstate,\n\t\t\t\tRPC_TASK_QUEUED, rpc_wait_bit_killable,\n\t\t\t\tTASK_KILLABLE);\n\t\tif (status == -ERESTARTSYS) {\n\t\t\t/*\n\t\t\t * When a sync task receives a signal, it exits with\n\t\t\t * -ERESTARTSYS. In order to catch any callbacks that\n\t\t\t * clean up after sleeping on some queue, we don't\n\t\t\t * break the loop here, but go around once more.\n\t\t\t */\n\t\t\tdprintk(\"RPC: %5u got signal\\n\", task->tk_pid);\n\t\t\ttask->tk_flags |= RPC_TASK_KILLED;\n\t\t\trpc_exit(task, -ERESTARTSYS);\n\t\t\trpc_wake_up_task(task);\n\t\t}\n\t\trpc_set_running(task);\n\t\tdprintk(\"RPC: %5u sync task resuming\\n\", task->tk_pid);\n\t}\n\n\tdprintk(\"RPC: %5u return %d, status %d\\n\", task->tk_pid, status,\n\t\t\ttask->tk_status);\n\t/* Release all resources associated with the task */\n\trpc_release_task(task);\n}", "path": "net\\sunrpc\\sched.c", "repo_name": "zcchina/linux-omap", "stars": 1, "license": "other", "language": "c", "size": 321204}
{"docstring": "/* Wait TIMEOUT_MSECS for input from the NFDS file descriptors stored in FDS.\n   Return Qnil if any input was serviced, Qt if the timeout expired, rep_NULL\n   for an error. */\n", "func_signal": "repv\nrep_accept_input_for_fds (unsigned long timeout_msecs, int nfds, int *fds)", "code": "{\n    fd_set copy;\n    int ready, i;\n    FD_ZERO(&copy);\n    for(i = 0; i < nfds; i++)\n    {\n\tif(FD_ISSET(fds[i], &input_fdset))\n\t    FD_SET(fds[i], &copy);\n    }\n    ready = wait_for_input(&copy, timeout_msecs);\n    if(ready > 0 && !rep_INTERRUPTP)\n\thandle_input(&copy, ready);\n    if(rep_INTERRUPTP)\n\treturn rep_NULL;\n    else\n\treturn ready > 0 ? Qnil : Qt;\n}", "path": "src\\unix_main.c", "repo_name": "juergenhoetzel/librep", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 3648}
{"docstring": "/* Similar to above, but also tries to make file name local to the\n   underlying fs if at all possible. */\n", "func_signal": "repv\nrep_localise_and_get_handler(repv *file_namep, int op)", "code": "{\n    repv file_name = *file_namep, handler;\n    rep_DECLARE1(file_name, rep_STRINGP);\n    file_name = Flocal_file_name(file_name);\n    if(!file_name)\n\treturn rep_NULL;\n    if(rep_NILP(file_name))\n    {\n\tfile_name = Fexpand_file_name(*file_namep, Qnil);\n\tif(!file_name)\n\t    return rep_NULL;\n    }\n    handler = rep_get_file_handler(file_name, op);\n    *file_namep = file_name;\n    return handler;\n}", "path": "src\\files.c", "repo_name": "juergenhoetzel/librep", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 3648}
{"docstring": "/* Handle the READY fds with pending input (defined by fdset INPUTS).\n   Return true if the display might require updating. Returns immediately\n   if a Lisp error has occurred. */\n", "func_signal": "static rep_bool\nhandle_input(fd_set *inputs, int ready)", "code": "{\n    static long idle_period;\n    rep_bool refreshp = rep_FALSE;\n\n    if(ready > 0)\n    {\n\tint i;\n\n\tidle_period = 0;\n\n\tfor(i = 0; i < FD_SETSIZE && ready > 0 && !rep_INTERRUPTP; i++)\n\t{\n\t    if(FD_ISSET(i, inputs))\n\t    {\n\t\tready--;\n\t\tif(FD_ISSET(i, &input_pending))\n\t\t{\n\t\t    FD_CLR(i, &input_pending);\n\t\t    input_pending_count--;\n\t\t}\n\t\tif(input_actions[i] != NULL)\n\t\t{\n\t\t    input_actions[i](i);\n\t\t    refreshp = rep_TRUE;\n\t\t}\n\t    }\n\t}\n    }\n    else if(ready == 0)\n    {\n\t/* A timeout. */\n\tif(rep_INTERRUPTP || rep_on_idle(idle_period))\n\t    refreshp = rep_TRUE;\n\n\tidle_period++;\n    }\n\n    if(!rep_INTERRUPTP && rep_proc_periodically())\n\trefreshp = rep_TRUE;\n\n    return refreshp;\n}", "path": "src\\unix_main.c", "repo_name": "juergenhoetzel/librep", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 3648}
{"docstring": "/* Invoked by SIGINT (i.e. ^C) */\n", "func_signal": "static RETSIGTYPE\ninterrupt_signal_handler(int sig)", "code": "{\n    if (rep_throw_value == rep_int_cell)\n    {\n\tsignal (sig, SIG_DFL);\n\traise (sig);\n    }\n    else\n    {\n\trep_throw_value = rep_int_cell;\n\tsignal (sig, interrupt_signal_handler);\n    }\n}", "path": "src\\unix_main.c", "repo_name": "juergenhoetzel/librep", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 3648}
{"docstring": "/* The input handler loop. */\n", "func_signal": "repv\nrep_event_loop(void)", "code": "{\n    repv result = Qnil;\n\n    if (rep_redisplay_fun != 0)\n\t(*rep_redisplay_fun)();\n\n    while(1)\n    {\n\tint ready;\n\trep_bool refreshp = rep_FALSE;\n\tfd_set copy;\n\n\tif (rep_throw_value == rep_NULL)\n\t{\n\t    memcpy(&copy, &input_fdset, sizeof(copy));\n\t    ready = wait_for_input(&copy, rep_input_timeout_secs * 1000);\n\t    refreshp = handle_input(&copy, ready);\n\t}\n\n\t/* Check for exceptional conditions. */\n\tif(rep_throw_value != rep_NULL)\n\t{\n\t    if(rep_handle_input_exception(&result))\n\t\treturn result;\n\t    else\n\t\trefreshp = rep_TRUE;\n\t}\n\n\tif(refreshp && rep_redisplay_fun != 0)\n\t    (*rep_redisplay_fun)();\n    }\n\n    return result;\n}", "path": "src\\unix_main.c", "repo_name": "juergenhoetzel/librep", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 3648}
{"docstring": "/* Note that this function never returns rep_NULL. It preserves the\n   regexp match data throughout. */\n", "func_signal": "repv\nrep_get_file_handler(repv file_name, int op)", "code": "{\n    repv list = Fsymbol_value(Qfile_handler_alist, Qt);\n    struct rep_saved_regexp_data matches;\n    if(!list)\n\treturn Qnil;\n    rep_DECLARE1(file_name, rep_STRINGP);\n    rep_push_regexp_data(&matches);\n    while(rep_CONSP(list) && rep_CONSP(rep_CAR(list)))\n    {\n\trepv tem = Fstring_match(rep_CAR(rep_CAR(list)), file_name,\n\t\t\t\t     Qnil, Qnil);\n\tif(tem && !rep_NILP(tem))\n\t{\n\t    /* Check that this operation isn't already active. */\n\t    struct blocked_op *ptr = rep_blocked_ops[op];\n\t    repv handler = rep_CDR(rep_CAR(list));\n\t    while(ptr != 0 && ptr->handler != handler)\n\t\tptr = ptr->next;\n\t    if(ptr == 0)\n\t    {\n\t\trep_pop_regexp_data();\n\t\treturn handler;\n\t    }\n\t}\n\tlist = rep_CDR(list);\n\trep_TEST_INT;\n\tif(rep_INTERRUPTP)\n\t    break;\n    }\n    rep_pop_regexp_data();\n    return Qnil;\n}", "path": "src\\files.c", "repo_name": "juergenhoetzel/librep", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 3648}
{"docstring": "/* File structures */\n", "func_signal": "static repv\nmake_file(void)", "code": "{\n    repv file = rep_VAL(rep_ALLOC_CELL(sizeof(rep_file)));\n    if(file == rep_NULL)\n\treturn rep_mem_error();\n    rep_data_after_gc += sizeof (rep_file);\n    rep_FILE(file)->car = rep_file_type | rep_LFF_BOGUS_LINE_NUMBER;\n    rep_FILE(file)->name = Qnil;\n    rep_FILE(file)->handler = Qnil;\n    rep_FILE(file)->handler_data = Qnil;\n    rep_FILE(file)->file.stream = Qnil;\n    rep_FILE(file)->next = file_list;\n    file_list = rep_FILE(file);\n    return file;\n}", "path": "src\\files.c", "repo_name": "juergenhoetzel/librep", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 3648}
{"docstring": "/* Invoked by SIGUSR1 or SIGUSR2 */\n", "func_signal": "static RETSIGTYPE\nusr_signal_handler (int sig)", "code": "{\n    switch (sig)\n    {\n    case SIGUSR1:\n\tfprintf(stderr, \"\\n\\nLisp backtrace:\\n\");\n\tFbacktrace(Fstderr_file());\n\tfputs(\"\\n\\n\", stderr);\n\tbreak;\n\n    case SIGUSR2:\n\tfprintf (stderr, \"\\n\\nDebug buffers:\\n\");\n\trep_db_spew_all ();\n\tfputc ('\\n', stderr);\n\tbreak;\n    }\n    signal (sig, usr_signal_handler);\n}", "path": "src\\unix_main.c", "repo_name": "juergenhoetzel/librep", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 3648}
{"docstring": "/* *rep_FILEP may be an opened file, or the name of a file. Returns the handler\n   to call, or nil if no handler exists, or rep_NULL if an error occurred.\n   Expands *rep_FILEP to its canonical form, leaving this value in *rep_FILEP. */\n", "func_signal": "repv\nrep_get_handler_from_file_or_name(repv *filep, int op)", "code": "{\n    repv file = *filep, handler;\n    if(!rep_FILEP(file) && !rep_STRINGP(file))\n\treturn rep_signal_arg_error(file, 1);\n    if(rep_FILEP(file))\n    {\n\tif(rep_NILP(rep_FILE(file)->name))\n\t    return rep_unbound_file_error(file);\n\thandler = rep_FILE(file)->handler;\n\tif(handler == Qt)\n\t    handler = Qnil;\n    }\n    else\n    {\n\tfile = Fexpand_file_name(file, Qnil);\n\tif(file)\n\t{\n\t    *filep = file;\n\t    handler = rep_get_file_handler(file, op);\n\t}\n\telse\n\t    handler = Qnil;\n    }\n    return handler;\n}", "path": "src\\files.c", "repo_name": "juergenhoetzel/librep", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 3648}
{"docstring": "/* this is duplicated in rep/io/file-handlers.jl */\n", "func_signal": "static inline repv\nfile_handler_ref (repv handler)", "code": "{\n    repv tem = Fget_structure (Qrep_io_file_handlers);\n    if (tem != Qnil)\n    {\n\ttem = F_structure_ref (tem, handler);\n\tif (!tem || rep_VOIDP (tem))\n\t    tem = Qnil;\n    }\n    return tem;\n}", "path": "src\\files.c", "repo_name": "juergenhoetzel/librep", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 3648}
{"docstring": "/* Utility functions */\n", "func_signal": "repv\nrep_file_fdopen (int fd, char *mode)", "code": "{\n    rep_file *ptr;\n    for (ptr = file_list; ptr != 0; ptr = ptr->next)\n    {\n\tif (rep_LOCAL_FILE_P (rep_VAL (ptr)) && fileno (ptr->file.fh) == fd)\n\t    return rep_VAL (ptr);\n    }\n    ptr = rep_FILE (make_file ());\n    ptr->handler = Qt;\n    ptr->file.fh = fdopen (fd, mode);\n    if (ptr->file.fh == 0)\n\treturn rep_NULL;\n    else\n\treturn rep_VAL (ptr);\n}", "path": "src\\files.c", "repo_name": "juergenhoetzel/librep", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 3648}
{"docstring": "/* init */\n", "func_signal": "void\nrep_files_init(void)", "code": "{\n    repv tem;\n\n    Qfh_env_key = Fmake_symbol (rep_VAL (&str_fh_env_key));\n    rep_mark_static (&Qfh_env_key);\n\n    rep_INTERN_SPECIAL(file_handler_alist);\n    Fset (Qfile_handler_alist, Qnil);\n\n    rep_INTERN_SPECIAL(default_directory);\n    tem = rep_getpwd();\n    if (tem == rep_NULL)\n\ttem = rep_null_string ();\n    Fset (Qdefault_directory, tem);\n\n    rep_INTERN(file_name_absolute_p);\n    rep_INTERN(expand_file_name);\n    rep_INTERN(local_file_name);\n    rep_INTERN(canonical_file_name);\n    rep_INTERN(file_name_nondirectory);\n    rep_INTERN(file_name_directory);\n    rep_INTERN(file_name_as_directory);\n    rep_INTERN(directory_file_name);\n    rep_INTERN(open_file);\n    rep_INTERN(close_file);\n    rep_INTERN(flush_file);\n    rep_INTERN(seek_file);\n    rep_INTERN(delete_file);\n    rep_INTERN(rename_file);\n    rep_INTERN(make_directory);\n    rep_INTERN(delete_directory);\n    rep_INTERN(copy_file);\n    rep_INTERN(copy_file_to_local_fs);\n    rep_INTERN(copy_file_from_local_fs);\n    rep_INTERN(file_readable_p);\n    rep_INTERN(file_writable_p);\n    rep_INTERN(file_executable_p);\n    rep_INTERN(file_exists_p);\n    rep_INTERN(file_regular_p);\n    rep_INTERN(file_directory_p);\n    rep_INTERN(file_symlink_p);\n    rep_INTERN(file_owner_p);\n    rep_INTERN(file_gid_p);\n    rep_INTERN(file_uid_p);\n    rep_INTERN(file_nlinks);\n    rep_INTERN(file_size);\n    rep_INTERN(file_modes);\n    rep_INTERN(set_file_modes);\n    rep_INTERN(file_modes_as_string);\n    rep_INTERN(file_modtime);\n    rep_INTERN(directory_files);\n    rep_INTERN(read_symlink);\n    rep_INTERN(make_symlink);\n\n    rep_INTERN(start); rep_INTERN(end);\n    rep_INTERN(read); rep_INTERN(write); rep_INTERN(append);\n\n    rep_INTERN(rep_io_file_handlers);\n\n    tem = rep_push_structure (\"rep.io.files\");\n\n    rep_ADD_SUBR(Sfilep);\n    rep_ADD_SUBR(Sfile_binding);\n    rep_ADD_SUBR(Sfile_ttyp);\n    rep_ADD_SUBR(Sfile_bound_stream);\n    rep_ADD_SUBR(Sfile_handler_data);\n    rep_ADD_SUBR(Sset_file_handler_data);\n\n    rep_ADD_SUBR(Sfile_name_absolute_p);\n    rep_ADD_SUBR(Sexpand_file_name);\n    rep_ADD_SUBR(Slocal_file_name);\n    rep_ADD_SUBR(Scanonical_file_name);\n    rep_ADD_SUBR(Sfile_name_nondirectory);\n    rep_ADD_SUBR(Sfile_name_directory);\n    rep_ADD_SUBR(Sfile_name_as_directory);\n    rep_ADD_SUBR(Sdirectory_file_name);\n\n    rep_ADD_SUBR(Sset_input_handler);\n\n    rep_ADD_SUBR(Sopen_file);\n    rep_ADD_SUBR(Smake_file_from_stream);\n    rep_ADD_SUBR(Sclose_file);\n    rep_ADD_SUBR(Sflush_file);\n    rep_ADD_SUBR(Sseek_file);\n    rep_ADD_SUBR(Sset_file_ignore_errors);\n\n    rep_ADD_SUBR_INT(Sdelete_file);\n    rep_ADD_SUBR_INT(Srename_file);\n    rep_ADD_SUBR_INT(Scopy_file);\n    rep_ADD_SUBR_INT(Smake_directory);\n    rep_ADD_SUBR_INT(Sdelete_directory);\n\n    rep_ADD_SUBR(Sfile_readable_p);\n    rep_ADD_SUBR(Sfile_writable_p);\n    rep_ADD_SUBR(Sfile_executable_p);\n    rep_ADD_SUBR(Sfile_exists_p);\n    rep_ADD_SUBR(Sfile_regular_p);\n    rep_ADD_SUBR(Sfile_directory_p);\n    rep_ADD_SUBR(Sfile_symlink_p);\n    rep_ADD_SUBR(Sfile_owner_p);\n    rep_ADD_SUBR(Sfile_gid_p);\n    rep_ADD_SUBR(Sfile_uid_p);\n    rep_ADD_SUBR(Sfile_nlinks);\n    rep_ADD_SUBR(Sfile_size);\n    rep_ADD_SUBR(Sfile_modes);\n    rep_ADD_SUBR(Sset_file_modes);\n    rep_ADD_SUBR(Sfile_modes_as_string);\n    rep_ADD_SUBR(Sfile_modtime);\n    rep_ADD_SUBR(Sdirectory_files);\n    rep_ADD_SUBR(Sread_symlink);\n    rep_ADD_SUBR(Smake_symlink);\n\n    rep_ADD_SUBR(Sstdin_file);\n    rep_ADD_SUBR(Sstdout_file);\n    rep_ADD_SUBR(Sstderr_file);\n    rep_ADD_SUBR(Smake_temp_name);\n    rep_ADD_SUBR(Sset_file_handler_environment);\n\n    rep_pop_structure (tem);\n\n    /* Initialise the type information. */\n    rep_file_type = rep_register_new_type(\"file\", rep_ptr_cmp,\n\t\t\t\t\t  file_prin, file_prin, file_sweep,\n\t\t\t\t\t  file_mark, mark_input_handlers,\n\t\t\t\t\t  0, 0, 0, 0, 0, 0);\n}", "path": "src\\files.c", "repo_name": "juergenhoetzel/librep", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 3648}
{"docstring": "/* Expand *FILE-NAME leaving the result in *FILE-NAME, and find\n   its handler for OP. Return the handler or nil. */\n", "func_signal": "repv\nrep_expand_and_get_handler(repv *file_namep, int op)", "code": "{\n    repv file_name = *file_namep, handler;\n    rep_DECLARE1(file_name, rep_STRINGP);\n    file_name = Fexpand_file_name(file_name, Qnil);\n    if(!file_name)\n\treturn rep_NULL;\n    handler = rep_get_file_handler(file_name, op);\n    *file_namep = file_name;\n    return handler;\n}", "path": "src\\files.c", "repo_name": "juergenhoetzel/librep", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 3648}
{"docstring": "/* Wait for input for no longer than TIMEOUT-MSECS for input fds defined\n   by INPUTS. If input arrived return the number of ready fds, with the\n   actual fds defined by the fdset INPUTS. Return zero if the timeout\n   was reached. */\n", "func_signal": "static int\nwait_for_input(fd_set *inputs, unsigned long timeout_msecs)", "code": "{\n    fd_set copy;\n    int ready = -1;\n\n    if(input_pending_count > 0)\n    {\n\t/* Check the pending inputs first.. */\n\tfd_set out;\n\tint i, count = 0, seen = 0;\n\tfor(i = 0; seen < input_pending_count && i < FD_SETSIZE; i++)\n\t{\n\t    if(FD_ISSET(i, &input_pending))\n\t    {\n\t\tseen++;\n\t\tif(FD_ISSET(i, inputs))\n\t\t{\n\t\t    if(count == 0)\n\t\t\tFD_ZERO(&out);\n\t\t    FD_SET(i, &out);\n\t\t    count++;\n\t\t}\n\t    }\n\t}\n\tif(count > 0)\n\t{\n\t    memcpy(inputs, &out, sizeof(out));\n\t    return count;\n\t}\n    }\n\n    /* Allow embedders to override this part of the function. */\n\n    if (rep_wait_for_input_fun != 0)\n\treturn (*rep_wait_for_input_fun) (inputs, timeout_msecs);\n\n    /* Break the timeout into one-second chunks, then check for\n       interrupt between each call to select. */\n    do {\n\tstruct timeval timeout;\n\tunsigned long max_sleep = rep_max_sleep_for ();\n\tunsigned long this_timeout_msecs = MIN (timeout_msecs,\n\t\t\t\t\t rep_input_timeout_secs * 1000);\n\tunsigned long actual_timeout_msecs = MIN (this_timeout_msecs, max_sleep);\n\n\ttimeout.tv_sec = actual_timeout_msecs / 1000;\n\ttimeout.tv_usec = (actual_timeout_msecs % 1000) * 1000;\n\tmemcpy (&copy, inputs, sizeof (copy));\n\n\t/* Dont test for interrupts before the first call to select() */\n\tif (ready == 0)\n\t{\n\t    rep_TEST_INT_SLOW;\n\t    if (rep_INTERRUPTP)\n\t\tbreak;\n\t}\n\n\t/* Don't want select() to restart after a SIGCHLD or SIGALRM;\n\t   there may be a notification to dispatch.  */\n\trep_sig_restart(SIGCHLD, rep_FALSE);\n\trep_sig_restart(SIGALRM, rep_FALSE);\n\tready = select(FD_SETSIZE, &copy, NULL, NULL, &timeout);\n\trep_sig_restart(SIGALRM, rep_TRUE);\n\trep_sig_restart(SIGCHLD, rep_TRUE);\n\n\tif (ready == 0 && actual_timeout_msecs < this_timeout_msecs)\n\t{\n\t    Fthread_suspend (Qnil, rep_MAKE_INT (this_timeout_msecs\n\t\t\t\t\t\t - actual_timeout_msecs));\n\t}\n\t\n\ttimeout_msecs -= this_timeout_msecs;\n    } while (ready == 0 && timeout_msecs > 0);\n\n    memcpy (inputs, &copy, sizeof (copy));\n    return ready;\n}", "path": "src\\unix_main.c", "repo_name": "juergenhoetzel/librep", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 3648}
{"docstring": "/* from symbols.c */\n", "func_signal": "static inline repv\ninlined_search_special_bindings (repv sym)", "code": "{\n    register repv env;\n    for (env = rep_special_bindings; env != Qnil; env = rep_CDR (env))\n    {\n\tif (rep_CAAR(env) == sym)\n\t    return rep_CAR (env);\n    }\n    return Qnil;\n}", "path": "src\\fluids.c", "repo_name": "juergenhoetzel/librep", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 3648}
{"docstring": "/* DL hooks */\n", "func_signal": "repv\nrep_dl_init(void)", "code": "{\n    repv tem;\n    rep_INTERN(rl_completion_generator);\n    rep_INTERN(boundp);\n    completions = Qnil;\n    completion_fun = Qnil;\n    rep_mark_static (&completions);\n    rep_mark_static (&completion_fun);\n\n#ifdef HAVE_LIBREADLINE\n    rl_completion_entry_function = (void *) completion_generator;\n    rl_basic_quote_characters = \"\\\"\";\n    if (isatty (0) && getenv(\"HOME\"))\n    {\n      history_file=(char*) malloc((uint) strlen(getenv(\"HOME\")) + (uint) strlen(\"/.rep_history\") +2);\n      if (history_file) {\n       sprintf(history_file, \"%s/.rep_history\",getenv(\"HOME\"));\n       read_history(history_file);\n      }\n    }\n    init_bouncing_parens();\n#endif\n    tem = rep_push_structure (\"rep.io.readline\");\n    /* ::alias:readline rep.io.readline:: */\n    rep_alias_structure (\"readline\");\n    rep_ADD_SUBR(Sreadline);\n    return rep_pop_structure (tem);\n}", "path": "src\\readline.c", "repo_name": "juergenhoetzel/librep", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 3648}
{"docstring": "/* Turns on or off restarted system calls for SIG */\n", "func_signal": "void\nrep_sig_restart(int sig, rep_bool flag)", "code": "{\n#if defined (HAVE_SIGINTERRUPT)\n    siginterrupt (sig, !flag);\n#else\n    struct sigaction act;\n    sigaction (sig, 0, &act);\n    if(flag)\n    {\n# if defined (SA_RESTART)\n\tact.sa_flags |= SA_RESTART;\n# elif defined (SA_INTERRUPT)\n\tact.sa_flags &= ~SA_INTERRUPT;\n# endif\n    }\n    else\n    {\n# if defined (SA_RESTART)\n\tact.sa_flags &= ~SA_RESTART;\n# elif defined (SA_INTERRUPT)\n\tact.sa_flags |= SA_INTERRUPT;\n# endif\n    }\n    sigaction(sig, &act, 0);\n#endif /* !HAVE_SIGINTERRUPT */\n}", "path": "src\\unix_main.c", "repo_name": "juergenhoetzel/librep", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 3648}
{"docstring": "/* Call the file handler function HANDLER, for file operation\n   OP/SYM. Pass NARGS arguments to it (each a lisp object). Note that\n   for the duration of the call, all args and HANDLER will be\n   gc-protected, and the the regexp match data is preserved. */\n", "func_signal": "repv\nrep_call_file_handler(repv handler, int op, repv sym, int nargs, ...)", "code": "{\n    struct blocked_op op_data;\n    struct rep_saved_regexp_data matches;\n    repv arg_list = Qnil;\n    repv *ptr = &arg_list;\n    repv res;\n    int i;\n    va_list args;\n\n    va_start(args, nargs);\n    for(i = 0; i < nargs; i++)\n    {\n\t*ptr = Fcons((repv)va_arg(args, repv), Qnil);\n\tptr = &rep_CDR(*ptr);\n    }\n    va_end(args);\n    arg_list = Fcons(sym, arg_list);\n\n    /* before it gets dereferenced */\n    op_data.handler = handler;\n\n    if (rep_SYMBOLP(handler))\n    {\n\trepv fh_env = get_fh_env ();\n\tif (fh_env == Qt)\n\t    handler = file_handler_ref (handler);\n\telse\n\t{\n\t    repv tem = Fassq (handler, fh_env);\n\t    if (tem && rep_CONSP(tem))\n\t    {\n\t\tif (rep_CDR(tem) == Qt)\n\t\t    handler = file_handler_ref (handler);\n\t\telse if (rep_FUNARGP(rep_CDR(tem)))\n\t\t    handler = rep_CDR(tem);\n\t    }\n\t}\n    }\n\n    if (handler != rep_NULL && !rep_VOIDP (handler))\n    {\n\trep_push_regexp_data(&matches);\n\top_data.next = rep_blocked_ops[op];\n\trep_blocked_ops[op] = &op_data;\n\t/* handler and arg_list are automatically protected by rep_funcall */\n\tres = rep_funcall(handler, arg_list, rep_FALSE);\n\trep_blocked_ops[op] = op_data.next;\n\trep_pop_regexp_data();\n    }\n    else\n\tres = rep_NULL;\n\n    return res;\n}", "path": "src\\files.c", "repo_name": "juergenhoetzel/librep", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 3648}
{"docstring": "/* This function is called _before_ almost anything else; but\n   most importantly, it's called before sys_init() (i.e. we\n   start opening displays) */\n", "func_signal": "void\nrep_pre_sys_os_init(void)", "code": "{\n    FD_ZERO(&input_fdset);\n    FD_ZERO(&input_pending);\n\n    /* First the error signals */\n#ifndef IGNORE_FATAL_SIGNALS\n#ifdef SIGFPE\n    if(signal(SIGFPE, fatal_signal_handler) == SIG_IGN)\n\tsignal(SIGFPE, SIG_IGN);\n#endif\n#ifdef SIGILL\n    if(signal(SIGILL, fatal_signal_handler) == SIG_IGN)\n\tsignal(SIGILL, SIG_IGN);\n#endif\n#ifdef SIGSEGV\n    if(signal(SIGSEGV, fatal_signal_handler) == SIG_IGN)\n\tsignal(SIGSEGV, SIG_IGN);\n#endif\n#ifdef SIGBUS\n    if(signal(SIGBUS, fatal_signal_handler) == SIG_IGN)\n\tsignal(SIGBUS, SIG_IGN);\n#endif\n#ifdef SIGQUIT\n    if(signal(SIGQUIT, fatal_signal_handler) == SIG_IGN)\n\tsignal(SIGQUIT, SIG_IGN);\n#endif\n#ifdef SIGABRT\n    if(signal(SIGABRT, fatal_signal_handler) == SIG_IGN)\n\tsignal(SIGABRT, SIG_IGN);\n#endif\n#endif\n\n    /* Install the interrupt handler */\n#ifdef SIGINT\n    if(signal(SIGINT, interrupt_signal_handler) == SIG_IGN)\n\tsignal(SIGINT, SIG_IGN);\n    else\n\trep_sig_restart (SIGINT, rep_FALSE);\n#endif\n\n    /* Finally, the termination signals */\n#ifdef SIGTERM\n    if(signal(SIGTERM, termination_signal_handler) == SIG_IGN)\n\tsignal(SIGTERM, SIG_IGN);\n    else\n\trep_sig_restart (SIGTERM, rep_FALSE);\n#endif\n#ifdef SIGHUP\n    if(signal(SIGHUP, termination_signal_handler) == SIG_IGN)\n\tsignal(SIGHUP, SIG_IGN);\n    else\n\trep_sig_restart (SIGHUP, rep_FALSE);\n#endif\n\n#ifdef SIGUSR1\n    signal(SIGUSR1, usr_signal_handler);\n#endif\n#ifdef SIGUSR2\n    signal(SIGUSR2, usr_signal_handler);\n#endif\n}", "path": "src\\unix_main.c", "repo_name": "juergenhoetzel/librep", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 3648}
{"docstring": "/* More normal initialisation. */\n", "func_signal": "void\nrep_sys_os_init(void)", "code": "{\n    repv env;\n    char **ptr;\n\n    /* Initialise process-environment variable */\n    env = Qnil;\n    if (environ != 0)\n    {\n\tptr = environ;\n\twhile(*ptr != 0)\n\t    env = Fcons(rep_string_dup(*ptr++), env);\n    }\n    Fset (Qprocess_environment, env);\n\n#ifdef DEBUG_SYS_ALLOC\n    { repv tem = rep_push_structure (\"rep.lang.debug\");\n      rep_ADD_SUBR(Sunix_print_allocations);\n      rep_pop_structure (tem); }\n#endif\n\n    rep_proc_init();\n}", "path": "src\\unix_main.c", "repo_name": "juergenhoetzel/librep", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 3648}
{"docstring": "//  Pedir dos archivos para compararlos y comparar byte por byte\n//  Crea una barra de progreso para indicar el avance\n//\n", "func_signal": "BOOL CompararArchivos (HWND             hwnd,\n                       HINSTANCE        hinst,\n                       HWND             hwndStatus,\n                       LPINFOCOMPARAR   lpic)", "code": "{\n\nOPENFILENAME    ofn;\nchar            szFile [MAX_PATH + 1];\nBOOL            bTemp;\nBOOL            bSkip = FALSE;\nHANDLE          hArchivo1;\nHANDLE          hArchivo2; \nchar            *buff1 = NULL;\nchar            *buff2 = NULL;\nDWORD           dwTamanyo1;\nDWORD           dwTamanyo2;\nDWORD           dwTamanyoHigh;\nDWORD           dw, dw1, dw2;\nDWORD           dwRange;\nint             k, nByts, n = 0;\nHWND            hwndProgress = NULL;\n\n\n    // Pedir primer archivo\n    ZeroMemory (szFile, sizeof(szFile));\n    bTemp = MostrarDlgComunAbrir (hwnd,\n                                  & ofn,\n                                  szFile,\n                                  sizeof(szFile),\n                                  \"Selecciona el primer archivo a comparar:\",\n                                  \"Todos los archivos\\0*.*\\0\",\n                                  NULL,\n                                  OFN_FILEMUSTEXIST |\n                                  OFN_PATHMUSTEXIST |\n                                  OFN_HIDEREADONLY);\n    if (bTemp)\n    {\n        strcpy (lpic->szFile1, ofn.lpstrFile);\n\n        // Pedir segundo archivo\n        ZeroMemory (szFile, sizeof(szFile));\n        bTemp = MostrarDlgComunAbrir (hwnd,\n                                      & ofn,\n                                      szFile,\n                                      sizeof(szFile),\n                                      \"Selecciona el segundo archivo a comparar:\",\n                                      \"Todos los archivos\\0*.*\\0\",\n                                      NULL,\n                                      OFN_FILEMUSTEXIST |\n                                      OFN_PATHMUSTEXIST |\n                                      OFN_HIDEREADONLY);\n        if (bTemp)\n        {\n            strcpy (lpic->szFile2, ofn.lpstrFile);\n\n            if (!lstrcmpi (lpic->szFile1, lpic->szFile2))\n            {\n                MessageBox (NULL, \"Archivos identicos\", \"CODI\", MB_OK);\n                return FALSE;\n            }\n            else\n            {\n                UpdateWindow (hwnd);\n                \n                // Abrimos los archivos para lectura\n                hArchivo1 = CreateFile (lpic->szFile1,\n                                        GENERIC_READ,\n                                        0,              //No se permite compartir\n                                        NULL,           //No seguridad\n                                        OPEN_EXISTING,  //Falla si no existe\n                                        FILE_ATTRIBUTE_NORMAL,\n                                        NULL);\n                if (hArchivo1 == INVALID_HANDLE_VALUE)\n                {   \n                    MessageBox (NULL,\"El primer archivo no pudo ser abierto. Verifica que existe y NO esta siendo usado\", NULL, MB_OK | MB_ICONERROR);\n                    return FALSE;\n                }\n                else\n                {\n                    hArchivo2 = CreateFile (lpic->szFile2,\n                                            GENERIC_READ,\n                                            0,              //No se permite compartir\n                                            NULL,           //No seguridad\n                                            OPEN_EXISTING,  //Falla si no existe\n                                            FILE_ATTRIBUTE_NORMAL,\n                                            NULL);\n                    if (hArchivo2 == INVALID_HANDLE_VALUE)\n                    {   \n                        MessageBox (NULL,\"El segundo archivo no pudo ser abierto. Verifica que existe y NO esta siendo usado\", NULL, MB_OK | MB_ICONERROR);\n                        CloseHandle (hArchivo1);\n                        return FALSE;\n                    }\n                    else\n                    {\n                        // Comparamos tamaos\n                        dwTamanyo1 = GetFileSize (hArchivo1, & dwTamanyoHigh);\n                        if (dwTamanyo1 != 0xFFFFFFFF)\n                        {\n                            if (dwTamanyoHigh != 0)\n                            {\nERR_TAMANYO:\n                                MessageBox (NULL,\"CODI solo maneja archivos de menos de 1 Gigabyte\", \"Error\",MB_OK | MB_ICONERROR);\nERR_SALIR:\n                                if (hwndProgress)\n                                    DestroyWindow(hwndProgress);\n                                CloseHandle (hArchivo1);\n                                CloseHandle (hArchivo2);\n                                return FALSE;\n                            }\n                        }\n                        else\n                        {\n                            if ( (dw = GetLastError()) != NO_ERROR)\n                            {\nERR_INDEF_TAM:\n                                MessageBox (NULL,\"No se pudo calcular el tamao del archivo.\", \"Error\",MB_OK | MB_ICONERROR);\n                                goto ERR_SALIR;\n                            }\n                        }\n\n                        dwTamanyo2 = GetFileSize (hArchivo2, & dwTamanyoHigh);\n                        if (dwTamanyo2 != 0xFFFFFFFF)\n                        {\n                            if (dwTamanyoHigh != 0)\n                                goto ERR_TAMANYO;\n                        }\n                        else\n                        {\n                            if ( (dw = GetLastError()) != NO_ERROR)\n                                goto ERR_INDEF_TAM;\n                        }\n\n                        if (dwTamanyo1 != dwTamanyo2)\n                        {\n                            lpic->bIgual = FALSE;\nEXIT_TRUE:\n                            if (hwndProgress)\n                                DestroyWindow(hwndProgress);\n                            if (buff1)\n                                free (buff1);\n                            if (buff2)\n                                free (buff2);\n                            CloseHandle (hArchivo1);\n                            CloseHandle (hArchivo2);\n                            return TRUE;\n                        }\n                        else\n                        {\n                            // Asignamos memoria para los buffers\n                            buff1 = (char*) malloc (NUM_BYTS);\n                            if (!buff1)\n                            {\nERR_MEMORIA:\n                                MessageBox (NULL, \"Insuficiente memoria\", NULL, MB_OK | MB_ICONERROR);\n                                goto ERR_SALIR;\n                            }\n\n                            buff2 = (char*) malloc (NUM_BYTS);\n                            if (!buff2)\n                            {\n                                free (buff1);\n                                goto ERR_MEMORIA;\n                            }\n\n                            // Creamos barra de progreso\n                            hwndProgress = CrearProgressBar (hwnd, hinst, hwndStatus);\n                            if (hwndProgress)\n                            {\n                                // Set the range and increment of the progress bar.\n                                dwRange = (dwTamanyo1 / NUM_BYTS);\n                                if (dwRange > 65000)\n                                {   \n                                    // Si el archivo pasa de los 250 MB\n                                    dwRange /= 10;\n                                    bSkip = TRUE;\n                                    dwRange ++;\n                                }\n                                dwRange ++;\n                                SendMessage(hwndProgress, PBM_SETRANGE, 0, MAKELPARAM(0, LOWORD(dwRange)));\n                                SendMessage(hwndProgress, PBM_SETSTEP, (WPARAM) 1, 0);\n                                SendMessage(hwndProgress, PBM_STEPIT, 0, 0);\n                            }\n                            \n                            // Leemos los bytes de ambos archivos y comparamos\n                            do\n                            {\n                                if (ReadFile (hArchivo1, buff1, NUM_BYTS, &dw1, NULL))\n                                {\n                                    if (ReadFile (hArchivo2, buff2, NUM_BYTS, &dw2, NULL))\n                                    {\n                                        if (dw1 != dw2)\n                                        {\n                                            MessageBox (NULL, \"Error interno\", \"Comparar\", MB_OK | MB_ICONERROR);\n                                            goto ERR_SALIR;\n                                        }\n                                        else\n                                        {\n                                            if (dw1 < NUM_BYTS)\n                                                nByts = dw1;\n                                            else\n                                                nByts = NUM_BYTS;\n                                        }\n                                        \n                                        for( k = 0; k < nByts; k++)\n                                        {\n                                            if (buff1 [k] != buff2 [k])\n                                            {\n                                                lpic->bIgual = FALSE;\n                                                goto EXIT_TRUE;\n                                            }\n                                        }\n                                        \n                                        // Refrescamos barra de progreso\n                                        if (!bSkip)\n                                            SendMessage(hwndProgress, PBM_STEPIT, 0, 0);\n                                        else\n                                        {\n                                            n++;\n                                            if (n >= 10)\n                                            {\n                                                SendMessage(hwndProgress, PBM_STEPIT, 0, 0);\n                                                n = 0;\n                                            }\n                                        }\n                                    }\n                                    else\n                                        goto ERR_LECTURA;\n                                }\n                                else\n                                {\nERR_LECTURA:\n                                    MessageBox (NULL, \"Error de lectura\", \"Comparar\", MB_OK | MB_ICONERROR);\n                                    goto ERR_SALIR;\n                                }\n                            }while (dw1 == NUM_BYTS);\n\n                            lpic->bIgual = TRUE;\n                            goto EXIT_TRUE;\n                        }\n                    }\n                }\n            }\n        }\n        else\n            return FALSE;\n    }\n    else\n        return FALSE;\n\n}", "path": "codifunc.c", "repo_name": "ex/Codi-1.1", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 320}
{"docstring": "//  Esta funcion crea el Wizard para el comando Partir\n//  \n", "func_signal": "VOID CrearWizardPartir (HWND        hwndOwner,\n                        HINSTANCE   hInstance)", "code": "{\n\nPROPSHEETPAGE psp[NUM_WIZ_PARTIR];\nPROPSHEETHEADER psh;\n\n    psp[0].dwSize = sizeof(PROPSHEETPAGE);\n    psp[0].dwFlags = 0;\n    psp[0].hInstance = hInstance;\n    psp[0].pszTemplate = MAKEINTRESOURCE(IDD_BUSCAR_ARCHIVO);\n    psp[0].pfnDlgProc = BuscarArchivoPartirDialogProc;\n    psp[0].lParam = 0;\n\n    psp[1].dwSize = sizeof(PROPSHEETPAGE);\n    psp[1].dwFlags = 0;\n    psp[1].hInstance = hInstance;\n    psp[1].pszTemplate = MAKEINTRESOURCE(IDD_NUMERO_ARCHIVOS);\n    psp[1].pfnDlgProc = NumeroArchivosPartirDialogProc;\n    psp[1].lParam = 0;\n\n    psp[2].dwSize = sizeof(PROPSHEETPAGE);\n    psp[2].dwFlags = 0;\n    psp[2].hInstance = hInstance;\n    psp[2].pszTemplate = MAKEINTRESOURCE(IDD_FINALIZAR);\n    psp[2].pfnDlgProc = FinalizarPartirDialogProc;\n    psp[2].lParam = 0;\n   \n    psh.dwSize = sizeof(PROPSHEETHEADER);\n    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_WIZARD | PSH_NOAPPLYNOW;\n    psh.hwndParent = hwndOwner;\n    psh.hInstance = hInstance;\n    psh.nPages = sizeof(psp) / sizeof(PROPSHEETPAGE);\n    psh.nStartPage = 0;\n    psh.ppsp = (LPCPROPSHEETPAGE) &psp;\n\n    PropertySheet(&psh);\n\n    return;\n}", "path": "codifunc.c", "repo_name": "ex/Codi-1.1", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 320}
{"docstring": "//  Esta funcion procesa los mensajes de la primera hoja del Wizard Cripto\n//\n", "func_signal": "LRESULT CALLBACK CriptoDialogProc (HWND hDlg,\n                                   UINT message,\n                                   UINT wParam,\n                                   LONG lParam)", "code": "{\n\nOPENFILENAME    ofn;\nBOOL            bTemp;\nchar            szFile[MAX_PATH + 1];\nchar            cad[MAX_PATH];\nchar            szCodigo[LNG_CODIGO + 1];\nchar            szConfirmacion[LNG_CODIGO + 1];\nHWND            hWndParent;\nHWND            hWndBtn;\nUINT            ui;\nRECT            rc;\nint             k;\n\n    switch (message)\n    {\n        case WM_INITDIALOG:\n            // Centramos el wizard\n            hWndParent = GetParent (hDlg);\n            GetWindowRect (hWndParent, & rc);\n            MoveWindow (hWndParent,\n                        (GetSystemMetrics (SM_CXSCREEN) - (rc.right - rc.left)) / 2,\n                        (GetSystemMetrics (SM_CYSCREEN) - (rc.bottom - rc.top)) / 2,\n                        (rc.right - rc.left),\n                        (rc.bottom - rc.top ),\n                        TRUE);\n            // Inicializamos valores\n            wci.bFin = FALSE;\n            if (g_bDrag)\n            {\n                strcpy (wci.szNombreArchivoFuente, g_InfDrag.szFileDrag);\n                // Sacamos la ruta (con el ultimo '\\\\'):\n                strcpy (wci.szCarpetaFuente, g_InfDrag.szFileDrag);\n                // Buscamos el ultimo caracter '\\\\'\n                for( k = strlen (wci.szCarpetaFuente) - 1; k > 0; k--)\n                {\n                    if (wci.szCarpetaFuente [k] == '\\\\')\n                    {\n                        // Guardamos el nombre del archivo solo:\n                        strcpy (wci.szNombreSoloFuente, & wci.szCarpetaFuente [k + 1]);\n                        // Truncamos la ruta\n                        wci.szCarpetaFuente [k + 1] = 0;\n                        break;\n                    }\n                }\n                if (wci.bEstamosEncriptando)\n                {\n                    // Crear nombre de destino automatico\n                    strcpy (wci.szNombreArchivoDestino, g_InfDrag.szFileDrag);\n                    if (strlen (wci.szNombreArchivoDestino) > MAX_PATH - 10)\n                        wci.bNombreAutomaticoCreado = FALSE;\n                    else\n                    {\n                        // Buscamos el punto de la extension\n                        for( k = strlen (wci.szNombreArchivoDestino); k > 0; k--)\n                        {\n                            if (wci.szNombreArchivoDestino [k] == '.')\n                                break;\n                        }\n                        if (k)\n                            wci.szNombreArchivoDestino [k] = '_';\n                        strcat (wci.szNombreArchivoDestino, \".cx$\");\n                        wci.bNombreAutomaticoCreado = TRUE;\n                    }\n                }\n                wci.bArchivoFuenteElegido = TRUE;\n                hWndBtn = GetDlgItem (hDlg, IDBT_FUENTE);\n                EnableWindow (hWndBtn, FALSE);\n            }\n            else\n                wci.bArchivoFuenteElegido = FALSE;\n\n            wci.bArchivoDestinoElegido = FALSE;\n            wci.bAutomatico = TRUE;\n            wci.bMascara = TRUE;\n            hWndBtn = GetDlgItem (hDlg, IDBT_DESTINO);\n            EnableWindow (hWndBtn, FALSE);\n            CheckDlgButton (hDlg, IDCHK_AUTOMATICO, BST_CHECKED);\n            CheckDlgButton (hDlg, IDCHK_MASCARA, BST_CHECKED);\n            SendDlgItemMessage (hDlg, IDTXT_CODIGO, EM_SETPASSWORDCHAR, (WPARAM) (UINT) '*', 0);\n            SendDlgItemMessage (hDlg, IDTXT_CODIGO, EM_SETLIMITTEXT, (WPARAM) 9, 0);\n            SendDlgItemMessage (hDlg, IDTXT_CONFIRMACION, EM_SETLIMITTEXT, (WPARAM) 9, 0);\n            if (wci.bEstamosEncriptando)\n            {\n                SendDlgItemMessage (hDlg, IDFRA_CODIGO, WM_SETTEXT, 0, (LPARAM)(LPCTSTR) \"Ingresa el cdigo con que quieres Encriptarlo :\");\n                SendDlgItemMessage (hDlg, IDBT_FUENTE, WM_SETTEXT, 0, (LPARAM)(LPCTSTR) \"&Elegir Archivo a Encriptar\");\n                if (g_bDrag)\n                    SendDlgItemMessage (hDlg, IDFRA_CRIPTO, WM_SETTEXT, 0, (LPARAM)(LPCTSTR) \"El archivo a Encriptar ya fue elegido!\");\n                else\n                    SendDlgItemMessage (hDlg, IDFRA_CRIPTO, WM_SETTEXT, 0, (LPARAM)(LPCTSTR) \"Elige el archivo a Encriptar:\");\n            }\n            else\n            {\n                SendDlgItemMessage (hDlg, IDBT_FUENTE, WM_SETTEXT , 0, (LPARAM)(LPCTSTR) \"&Elegir Archivo a Desencriptar\");\n                SendDlgItemMessage (hDlg, IDFRA_CODIGO, WM_SETTEXT , 0, (LPARAM)(LPCTSTR) \"Ingresa el cdigo con el que lo Encriptaste :\");\n                if (g_bDrag)\n                    SendDlgItemMessage (hDlg, IDFRA_CRIPTO, WM_SETTEXT, 0, (LPARAM)(LPCTSTR) \"El archivo a Desencriptar ya fue elegido!\");\n                else\n                    SendDlgItemMessage (hDlg, IDFRA_CRIPTO, WM_SETTEXT , 0, (LPARAM)(LPCTSTR) \"Elige el archivo a Desencriptar:\");\n            }\n            return TRUE;\n\n    \n        case WM_COMMAND:\n            if (HIWORD(wParam) == BN_CLICKED)\n            {    \n                switch( LOWORD(wParam))\n                {\n                    case IDBT_FUENTE:\n                        // Ningun archivo inicial que mostrar en el Dialogo Abrir\n                        ZeroMemory (szFile, sizeof(szFile));\n                        // Necesitamos este Handle si queremos un cuadro de dialogo MODAL\n                        hWndParent = GetParent (hDlg);\n                        if (wci.bEstamosEncriptando)\n                            strcpy (cad, \"Selecciona el archivo a encriptar:\");\n                        else\n                            strcpy (cad, \"Selecciona el archivo a desencriptar:\");\n                        bTemp = MostrarDlgComunAbrir (hWndParent,\n                                                      & ofn,\n                                                      szFile,\n                                                      sizeof(szFile),\n                                                      cad,\n                                                      \"Todos los archivos\\0*.*\\0\",\n                                                      NULL,\n                                                      OFN_FILEMUSTEXIST |\n                                                      OFN_PATHMUSTEXIST |\n                                                      OFN_HIDEREADONLY);\n                        if (bTemp)\n                        {\n                            strcpy (wci.szNombreArchivoFuente, ofn.lpstrFile);\n                            strcpy (wci.szNombreSoloFuente, ofn.lpstrFile + ofn.nFileOffset);\n                            strcpy (wci.szCarpetaFuente, ofn.lpstrFile);\n                            // Solo conservamos la ruta (con el ultimo '\\\\')\n                            wci.szCarpetaFuente [ofn.nFileOffset] = '\\0';\n                            if (wci.bEstamosEncriptando)\n                            {\n                                // Crear nombre de destino automatico\n                                strcpy (wci.szNombreArchivoDestino, ofn.lpstrFile);\n                                if (lstrlen (wci.szNombreArchivoDestino) > MAX_PATH - 10)\n                                    wci.bNombreAutomaticoCreado = FALSE;\n                                else\n                                {\n                                    wci.szNombreArchivoDestino [ofn.nFileExtension - 1] = '_';\n                                    strcat (wci.szNombreArchivoDestino, \".cx$\");\n                                    wci.bNombreAutomaticoCreado = TRUE;\n                                }\n                            }\n                            wci.bArchivoFuenteElegido = TRUE;\n                        }\n                        return TRUE;\n\n                    case IDBT_DESTINO:\n                        ZeroMemory (szFile, sizeof(szFile));\n                        hWndParent = GetParent (hDlg);\n                        bTemp = MostrarDlgComunGuardar (hWndParent,\n                                                        & ofn,\n                                                        szFile,\n                                                        sizeof(szFile),\n                                                        \"Ingresa el nombre del archivo destino:\",\n                                                        \"Todos los Archivos\\0*.*\\0\",\n                                                        NULL,\n                                                        NULL,\n                                                        OFN_HIDEREADONLY |\n                                                        OFN_OVERWRITEPROMPT);\n                        if (bTemp)\n                        {\n                            strcpy (wci.szNombreArchivoDestino, ofn.lpstrFile);\n                            wci.bArchivoDestinoElegido = TRUE;\n                        }\n                        return TRUE;\n\n                    case IDCHK_AUTOMATICO:\n                        ui = IsDlgButtonChecked (hDlg, IDCHK_AUTOMATICO);\n                        if (ui == BST_CHECKED)\n                        {\n                            hWndBtn = GetDlgItem (hDlg, IDBT_DESTINO);\n                            EnableWindow (hWndBtn, FALSE);\n                            wci.bAutomatico = TRUE;\n                        }\n                        else\n                        {\n                            hWndBtn = GetDlgItem (hDlg, IDBT_DESTINO);\n                            EnableWindow (hWndBtn, TRUE);\n                            wci.bAutomatico = FALSE;\n                        }\n                        return TRUE;\n\n                    case IDCHK_MASCARA:\n                        ui = IsDlgButtonChecked (hDlg, IDCHK_MASCARA);\n                        if (ui == BST_CHECKED)\n                        {\n                            hWndBtn = GetDlgItem (hDlg, IDTXT_CONFIRMACION);\n                            EnableWindow (hWndBtn, TRUE);\n                            SendDlgItemMessage (hDlg, IDTXT_CODIGO, EM_SETPASSWORDCHAR, (WPARAM) (UINT) '*', 0);\n                            GetDlgItemText (hDlg, IDTXT_CODIGO, szCodigo, LNG_CODIGO + 1);\n                            SendDlgItemMessage (hDlg, IDTXT_CODIGO, WM_SETTEXT, 0, (LPARAM)(LPCTSTR) szCodigo);\n                            wci.bMascara = TRUE;\n                        }\n                        else\n                        {\n                            hWndBtn = GetDlgItem (hDlg, IDTXT_CONFIRMACION);\n                            EnableWindow (hWndBtn, FALSE);\n                            GetDlgItemText (hDlg, IDTXT_CODIGO, szCodigo, LNG_CODIGO + 1);\n                            SendDlgItemMessage (hDlg, IDTXT_CODIGO, EM_SETPASSWORDCHAR, (WPARAM) (UINT) '\\0', 0);\n                            SendDlgItemMessage (hDlg, IDTXT_CODIGO, WM_SETTEXT, 0, (LPARAM)(LPCTSTR) szCodigo);\n                            wci.bMascara = FALSE;\n                        }\n                        return TRUE;\n\n                    default:\n                        return FALSE;\n                }\n            }\n            return FALSE;\n\n\n        case WM_NOTIFY:\n            switch (((NMHDR FAR *) lParam)->code) \n            {\n                case PSN_SETACTIVE:\n                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);\n                    break;\n\n                case PSN_WIZNEXT:\n                    if (!wci.bArchivoFuenteElegido)\n                    {\n                        MessageBox(NULL,\"Debes elegir un archivo primero\",NULL,MB_OK | MB_ICONEXCLAMATION);\n                        SetWindowLong(hDlg, DWL_MSGRESULT, TRUE);\n                    }\n                    else\n                    {\n                        if (wci.bAutomatico)\n                        {   // No quites esta llave\n                            if (!wci.bNombreAutomaticoCreado && wci.bEstamosEncriptando)\n                            {\n                                MessageBox(NULL,\"El nombre automtico es muy largo. Selecciona un destino\",NULL,MB_OK | MB_ICONEXCLAMATION);\n                                hWndBtn = GetDlgItem (hDlg, IDBT_DESTINO);\n                                EnableWindow (hWndBtn, TRUE);\n                                CheckDlgButton (hDlg, IDCHK_AUTOMATICO, BST_UNCHECKED);\n                                SetWindowLong(hDlg, DWL_MSGRESULT, TRUE);\n                                break;\n                            }\n                        }\n                        else\n                        {\n                            if (!wci.bArchivoDestinoElegido)\n                            {\n                                MessageBox(NULL,\"Selecciona automatico o elige un destino\",NULL,MB_OK | MB_ICONEXCLAMATION);\n                                SetWindowLong(hDlg, DWL_MSGRESULT, TRUE);\n                                break;\n                            }\n                        }\n                        GetDlgItemText (hDlg, IDTXT_CODIGO, szCodigo, LNG_CODIGO + 1);\n                        if (strlen (szCodigo) != LNG_CODIGO)\n                        {\n                            MessageBox(NULL,\"El codigo no tiene 9 digitos\",NULL,MB_OK | MB_ICONEXCLAMATION);\n                            SetWindowLong(hDlg, DWL_MSGRESULT, TRUE);\n                        }\n                        else\n                        {\n                            if (wci.bMascara)\n                            {\n                                GetDlgItemText (hDlg, IDTXT_CONFIRMACION, szConfirmacion, LNG_CODIGO + 1);\n                                if (strcmp (szCodigo, szConfirmacion))\n                                {\n                                    MessageBox(NULL,\"La confirmacion no concuerda\",NULL,MB_OK | MB_ICONEXCLAMATION);\n                                    SetWindowLong(hDlg, DWL_MSGRESULT, TRUE);\n                                    break;\n                                }\n                            }\n                            strcpy (wci.codigo, szCodigo);\n                            SetWindowLong(hDlg, DWL_MSGRESULT, FALSE);\n                        }\n                    }\n                    break;\n\n                default:\n                    return FALSE;\n            }\n            return TRUE;\n\n        default:\n            return FALSE;\n    }\n    return FALSE;\n}", "path": "codi.c", "repo_name": "ex/Codi-1.1", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 320}
{"docstring": "// Esta funcion verifica si hay espacio en el disco\n//\n", "func_signal": "BOOL VerificarEspacioDisco (char    szRuta [],\n                            DWORD   dwEspacio)", "code": "{\nULARGE_INTEGER  uliEspacioLibreUser;\nULARGE_INTEGER  uliEspacioTotal;\nULARGE_INTEGER  uliEspacioTotalLibre;\n\n    if (!GetDiskFreeSpaceEx (szRuta, &uliEspacioLibreUser, &uliEspacioTotal, &uliEspacioTotalLibre))\n        return FALSE;\n    else\n    {\n        if (dwEspacio >= uliEspacioLibreUser.LowPart)\n        {\n            MessageBox (NULL,\"No hay suficiente espacio de almacenamiento en el destino!\", NULL,MB_OK | MB_ICONERROR);\n            return FALSE;\n        }\n        else\n            return TRUE;\n    }\n}", "path": "corefunc.c", "repo_name": "ex/Codi-1.1", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 320}
{"docstring": "//  Esta funcion crea el Wizard para el comando Reunir\n//  \n", "func_signal": "VOID CrearWizardReunir (HWND        hwndOwner,\n                        HINSTANCE   hInstance)", "code": "{\n\nPROPSHEETPAGE psp[NUM_WIZ_REUNIR];\nPROPSHEETHEADER psh;\n\n    psp[0].dwSize = sizeof(PROPSHEETPAGE);\n    psp[0].dwFlags = 0;\n    psp[0].hInstance = hInstance;\n    psp[0].pszTemplate = MAKEINTRESOURCE(IDD_BUSCAR_CARPETA);\n    psp[0].pfnDlgProc = BuscarCarpetaReunirDialogProc;\n    psp[0].lParam = 0;\n\n    psp[1].dwSize = sizeof(PROPSHEETPAGE);\n    psp[1].dwFlags = 0;\n    psp[1].hInstance = hInstance;\n    psp[1].pszTemplate = MAKEINTRESOURCE(IDD_FINALIZAR);\n    psp[1].pfnDlgProc = FinalizarReunirDialogProc;\n    psp[1].lParam = 0;\n\n    psh.dwSize = sizeof(PROPSHEETHEADER);\n    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_WIZARD | PSH_NOAPPLYNOW;\n    psh.hwndParent = hwndOwner;\n    psh.hInstance = hInstance;\n    psh.nPages = sizeof(psp) / sizeof(PROPSHEETPAGE);\n    psh.nStartPage = 0;\n    psh.ppsp = (LPCPROPSHEETPAGE) &psp;\n\n    PropertySheet(&psh);\n\n    return;\n}", "path": "codifunc.c", "repo_name": "ex/Codi-1.1", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 320}
{"docstring": "//  Esta funcion convierte los menus del recurso en owner-draw items.\n//\n", "func_signal": "VOID CrearMenuOwnerDrawn (HWND          hwnd,\n                          HINSTANCE     hinst,\n                          MIMENUITEM    menus[])", "code": "{\n\nHMENU           hmenuBar = GetMenu (hwnd);\nHMENU           hmenuPopup;\nMENUITEMINFO    mii;\nLPMIMENUITEM    lpmItem;\nint             k;\n                        // Indice menu raiz - ID Menu - ID Bitmap - ID Cadena\nUINT            MD [] = {0, IDM_COMPARAR,  IDB_MENUCOMPARAR, IDS_MENUCOMPARAR,\n                         0, IDM_BORRAR,  IDB_MENUBORRAR, IDS_MENUBORRAR,\n                         1, IDM_ENCRIPTAR, IDB_MENUCRIPTO, IDS_MENUCRIPTO,\n                         1, IDM_DESENCRIPTAR, IDB_MENUDESENCRIPTAR, IDS_MENUDESENCRIPTAR,\n                         2, IDM_EXPLORAR, IDB_MENUEXPLORAR, IDS_MENUEXPLORAR,\n                         3, IDM_COMPLEMENTOS, IDB_MENUCOMPLEMENTOS, IDS_MENUCOMPLEMENTOS,\n                         4, IDM_CONTENIDO, IDB_MENUHELP, IDS_MENUCONTENIDO};\n\n\n    for( k = 0; k < (sizeof(MD)/sizeof(UINT)) ; k += 4)\n    {\n        lpmItem = &menus [k/4];\n        \n        // Obtener handle del menu raiz del cual se origina el menu OD\n        hmenuPopup = GetSubMenu (hmenuBar, MD[k]);\n\n        // Llenar la estructura con el texto y longitud del texto\n        LoadString (hinst, MD [k + 3], lpmItem->szText, MAX_LONG_MENU);\n        lpmItem->nLongText = lstrlen (lpmItem->szText);\n\n        // Asociar el mapa de bits\n        lpmItem->hBitmap = (HBITMAP) LoadBitmap (hinst, MAKEINTRESOURCE(MD [k + 2]));\n\n        // Modificar item\n        mii.cbSize = sizeof(MENUITEMINFO);\n        mii.fMask = MIIM_TYPE | MIIM_DATA;\n        mii.fType = MFT_OWNERDRAW;\n        mii.dwItemData = (DWORD) lpmItem;\n        SetMenuItemInfo (hmenuPopup, MD [k + 1], FALSE, &mii);\n    }\n}", "path": "codifunc.c", "repo_name": "ex/Codi-1.1", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 320}
{"docstring": "//   FUNCTION: WinMain(HANDLE, HANDLE, LPSTR, int)\n//   PURPOSE: Main entry point for the application. \n//   This function calls the initialization functions and processes\n//   the main message loop.\n//\n", "func_signal": "int APIENTRY WinMain (HINSTANCE hInst,\n                      HINSTANCE hPrevInstance,\n                      LPSTR     lpCmdLine,\n                      int       nCmdShow)", "code": "{\n    MSG msg;\n    HACCEL hAccel;\n        \n    InitCommonControls();   //Para inicializar controles comunes\n\n    hInstance = hInst;      //Necesario porque se vuelve a llamar a la instancia fuera de esta funcion  \n\n    // if the initialization fails, return.\n    if (!InitApplication(hInstance)) return (FALSE);     \n\n    // Perform initializations that apply to a specific instance \n    if (!InitInstance(hInstance, nCmdShow)) return (FALSE);\n\n    hAccel= LoadAccelerators(hInstance,MAKEINTRESOURCE(IDR_ACCELERATOR));\n\n    // Acquire and dispatch messages until a WM_QUIT message is received. \n    while (GetMessage(&msg,NULL,0,0))                 \n    {\n        if (!TranslateAccelerator(hWndMain,hAccel,&msg))\n        {\n        TranslateMessage(&msg);\n        DispatchMessage(&msg); \n        }\n    }\n    return (msg.wParam);  \n}", "path": "codi.c", "repo_name": "ex/Codi-1.1", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 320}
{"docstring": "//  Esta funcion procesa los mensajes de la segunda hoja del Wizard Password\n//\n", "func_signal": "LRESULT CALLBACK FinalizarPasswordDialogProc (HWND hDlg,\n                                              UINT message,\n                                              UINT wParam,\n                                              LONG lParam)", "code": "{\n\n        char    linea[MAX_PATH + 15];   // +4 para los espacios +10 para el tamao\n        HWND    hLista;\n        int     n, m, k;\nstatic  char    sz [MAX_RESPUESTA + 1];\n        char    st [8];\n        char    *p;\n\n\n    switch (message)\n    {\n        case WM_INITDIALOG:     \n            return TRUE;\n\n        case WM_NOTIFY:\n            switch (((NMHDR FAR *) lParam)->code)\n            {\n                case PSN_SETACTIVE:\n                    PropSheet_SetWizButtons(GetParent(hDlg),  PSWIZB_BACK | PSWIZB_FINISH);\n                    // limpiar lista:\n                    SendDlgItemMessage (hDlg, IDL_RESUMEN, LB_RESETCONTENT, 0, 0);\n\n                    // Calculamos el numero de password\n                    {   \n                        n = wpwi.nAnyo % 10;\n                        m = wpwi.nAnyo / 10;\n                        sz [0] = (char) (m % 19);\n                        sz [1] = (char) (m % 17);\n                        sz [2] = (char) (m % 13);\n                        sz [3] = (char) (n * 11);\n                        sz [4] = (char) wpwi.nMes;\n                        sz [5] = (char) (wpwi.nMes * 7);\n                        sz [6] = (char) wpwi.nDia;\n                        sz [7] = (char) (wpwi.nDia * 3);\n                        sz [8] = (char) (wpwi.nDia + wpwi.nMes) + wpwi.opcion;\n\n                        for( k = 0; k < MAX_RESPUESTA; k++)\n                            sz [k] = ((sz [k] + wpwi.szRespuesta [k]) % 10) + 48;\n                        \n                        sz [9] = 0;\n                    }\n\n                    // Mostrar la informacion\n                    hLista = GetDlgItem (hDlg, IDL_RESUMEN);\n                    if (wpwi.opcion == 0)\n                        strcpy (st, \"AZUL\");\n                    else\n                        if (wpwi.opcion == 1)\n                            strcpy (st, \"ROJA\");\n                        else\n                            strcpy (st, \"VERDE\");\n                    wsprintf (linea, \"[ RESPUESTA A LA PREGUNTA %s ]\", st);\n                    SendMessage (hLista, LB_ADDSTRING, 0, (LPARAM) linea);\n                    strcpy (linea, \"    \");\n                    strcat (linea, wpwi.szRespuesta);\n                    SendMessage (hLista, LB_ADDSTRING, 0, (LPARAM) linea);\n                    strcpy (linea, \" \");\n                    SendMessage (hLista, LB_ADDSTRING, 0, (LPARAM) linea);\n\n                    strcpy (linea, \"[ FECHA QUE RECUERDAS SIEMPRE ]\");\n                    SendMessage (hLista, LB_ADDSTRING, 0, (LPARAM) linea);\n                    wsprintf (linea, \"    (d/m/a):  %d/%d/%d\", wpwi.nDia, wpwi.nMes, wpwi.nAnyo);\n                    SendMessage (hLista, LB_ADDSTRING, 0, (LPARAM) linea);\n                    strcpy (linea, \" \");\n                    SendMessage (hLista, LB_ADDSTRING, 0, (LPARAM) linea);\n\n                    strcpy (linea, \"[ CODIGO GENERADO ]\");\n                    SendMessage (hLista, LB_ADDSTRING, 0, (LPARAM) linea);\n                    wsprintf (linea, \"    %s\", sz);\n                    SendMessage (hLista, LB_ADDSTRING, 0, (LPARAM) linea);\n                    strcpy (linea, \" \");\n                    SendMessage (hLista, LB_ADDSTRING, 0, (LPARAM) linea);\n\n                    strcpy (linea, \" Elegir <FINALIZAR> copiar este cdigo al\");\n                    SendMessage (hLista, LB_ADDSTRING, 0, (LPARAM) linea);\n                    strcpy (linea, \" clipboard. Pgala <Ctrl + V> donde quieras..\");\n                    SendMessage (hLista, LB_ADDSTRING, 0, (LPARAM) linea);\n                    break;\n\n                case PSN_WIZFINISH:\n                    if ( OpenClipboard(hWndMain))\n                    {\n                        EmptyClipboard ();\n                        hGout = GlobalAlloc (GHND |         // Combines the GMEM_MOVEABLE and GMEM_ZEROINIT flags\n                                             GMEM_DDESHARE, \n                                             MAX_RESPUESTA + 1);\n                        if (hGout == NULL) \n                        { \n                            CloseClipboard(); \n                            break; \n                        } \n                        p = GlobalLock (hGout);\n                        strcpy (p, sz);\n                        GlobalUnlock (hGout);\n                        SetClipboardData (CF_TEXT, hGout);\n                        CloseClipboard ();\n                    }\n                    break;\n\n                default:\n                    return FALSE;\n\n            }\n            return TRUE;\n    }\n    return FALSE;\n}", "path": "codi.c", "repo_name": "ex/Codi-1.1", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 320}
{"docstring": "//  Esta funcion crea un control Treeview, lo inicializa y devuelve un manejador a el.\n//  Para esto crea un control ImageList y lo inicializa.\n//  InitCommonControls() debe haber sido llamada antes.\n//\n", "func_signal": "HWND CrearTreeview (HWND        hWnd,\n                    HINSTANCE   hInstance,\n                    HWND        hWndStatus,\n                    int         iTopTree,\n                    int         gibmpTV[])", "code": "{\n\nHIMAGELIST  hIml;               // handle to image list\nHBITMAP     hBmp;               // handle to bitmap \nHWND        hWndTree;\nRECT        rc;\nRECT        rcSB;\n\n    // Get the size and position of the parent window.\n    GetClientRect (hWnd, &rc);\n    GetClientRect (hWndStatus, &rcSB);\n\n    // Create the tree view window.\n    hWndTree = CreateWindowEx ( 0,\n                                WC_TREEVIEW,                // tree view class\n                                (LPCTSTR) NULL,             // no default text\n                                WS_VISIBLE | WS_CHILD |\n                                TVS_HASLINES | TVS_HASBUTTONS |\n                                TVS_LINESATROOT |TVS_DISABLEDRAGDROP ,\n                                TV_MARGEN_IZQ,\n                                iTopTree,\n                                rc.right - TV_MARGEN_IZQ,\n                                rc.bottom - iTopTree - rcSB.bottom,\n                                hWnd,\n                                (HMENU)ID_TREEVIEW,\n                                hInstance,\n                                NULL);\n\n    if (hWndTree == NULL)\n        MessageBox (NULL, \"No se pudo crear TreeView\", NULL, MB_OK);\n    else\n    {\n        // Initialize the tree view window.\n        // First create the image list you will need.\n        hIml = ImageList_Create (BITMAP_WIDTH,          // width\n                                 BITMAP_HEIGHT,         // height\n                                 ILC_MASK,              // IMPORTANTE si quieres imagenes transparentes\n                                 NUM_BITMAPS_TV,        // number of images\n                                 0);                    // amount this list can grow\n        if (hIml == NULL)\n        {\n            MessageBox (NULL, \"No se pudo crear ImageList\", NULL, MB_OK);\n            return NULL;\n        }\n\n        // Load the bitmaps and add them to the image list.\n        // Las imagenes tienen un fondo azul que se vera transparente.\n        hBmp = LoadBitmap (hInstance, MAKEINTRESOURCE (IDB_TAREA));\n        gibmpTV[0] = ImageList_AddMasked (hIml, hBmp, RGB(0, 0, 255));\n        DeleteObject(hBmp); \n\n        hBmp = LoadBitmap (hInstance, MAKEINTRESOURCE (IDB_ARCHIVO_FUENTE));\n        gibmpTV[1] = ImageList_AddMasked (hIml, hBmp, RGB(0, 0, 255));\n        DeleteObject(hBmp); \n\n        hBmp = LoadBitmap (hInstance, MAKEINTRESOURCE (IDB_CARPETA_CERRADA));\n        gibmpTV[2] = ImageList_AddMasked (hIml, hBmp, RGB(0, 0, 255));\n        DeleteObject(hBmp); \n\n        hBmp = LoadBitmap (hInstance, MAKEINTRESOURCE (IDB_ARCHIVO_CORTADO));\n        gibmpTV[3] = ImageList_AddMasked (hIml, hBmp, RGB(0, 0, 255));\n        DeleteObject(hBmp);\n\n        hBmp = LoadBitmap (hInstance, MAKEINTRESOURCE (IDB_CODI));\n        gibmpTV[4] = ImageList_AddMasked (hIml, hBmp, RGB(0, 0, 255));\n        DeleteObject(hBmp);\n\n        hBmp = LoadBitmap (hInstance, MAKEINTRESOURCE (IDB_MENUCOMPARAR));\n        gibmpTV[5] = ImageList_AddMasked (hIml, hBmp, RGB(255, 0, 0));\n        DeleteObject(hBmp);\n\n        // Be sure that all the bitmaps were added.\n        if (ImageList_GetImageCount (hIml) < NUM_BITMAPS_TV) \n            return NULL;\n        \n        // Associate the image list with the tree view control.\n        TreeView_SetImageList (hWndTree, hIml, TVSIL_NORMAL);\n            \n        // Si queremos especificar una mayor separacion para los items del Treeview:\n        //      TreeView_SetItemHeight(hWndTree, TV_ESPACIOY + lFontY);\n        // Donde lFontY es la altura de la fuente para los iconos del sistema.\n        // y TV_ESPACIOY un valor adicional (aqui fue 7)\n    }\n\n    return hWndTree;\n}", "path": "codifunc.c", "repo_name": "ex/Codi-1.1", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 320}
{"docstring": "//  Esta funcion procesa los mensajes de la tercera hoja del Wizard Partir\n//\n", "func_signal": "LRESULT CALLBACK FinalizarPartirDialogProc (HWND hDlg,\n                                            UINT message,\n                                            UINT wParam,\n                                            LONG lParam)", "code": "{\n\nchar    linea[MAX_PATH + 5];    // +4 para los espacios\nHWND    hLista;\nint     k;\nDWORD   t;\n\n    switch (message)\n    {\n        case WM_INITDIALOG:     \n            // Especificamos el ancho visible en pxls de la Lista (por HScroll) \n            SendDlgItemMessage (hDlg, IDL_RESUMEN, LB_SETHORIZONTALEXTENT, (WPARAM) 1600, 0);\n            return TRUE;\n\n        case WM_NOTIFY:\n            switch (((NMHDR FAR *) lParam)->code)\n            {\n                case PSN_SETACTIVE:\n                    PropSheet_SetWizButtons(GetParent(hDlg),  PSWIZB_BACK | PSWIZB_FINISH);\n                    // limpiar lista:\n                    SendDlgItemMessage (hDlg, IDL_RESUMEN, LB_RESETCONTENT, 0, 0);\n\n                    // Mostrar la informacion\n                    hLista = GetDlgItem(hDlg, IDL_RESUMEN);\n                    strcpy (linea, \"[ ARCHIVO FUENTE ]\\0\");\n                    SendMessage (hLista, LB_ADDSTRING, 0, (LPARAM) linea);\n                    strcpy (linea, \"    \\0\");\n                    strcat (linea, wpi.szNombreArchivoFuente);\n                    SendMessage (hLista, LB_ADDSTRING, 0, (LPARAM) linea);\n                    wsprintf (linea, \"    DE TAMAO: %lu (Bytes)\", wpi.dwTamanyoFuenteLow);\n                    SendMessage (hLista, LB_ADDSTRING, 0, (LPARAM) linea);\n                    strcpy (linea, \" \\0\");\n                    SendMessage (hLista, LB_ADDSTRING, 0, (LPARAM) linea);\n\n                    wsprintf (linea, \"[ SE PARTIRA EN %lu ARCHIVOS ]\", wpi.iNumArch);\n                    SendMessage (hLista, LB_ADDSTRING, 0, (LPARAM) linea);\n                    t = wpi.dwTamanyoMaxPartido + sizeof(INFOFILEFRAG);\n                    wsprintf (linea, \"    TAMAO MAXIMO: %lu (Bytes)\", t);\n                    SendMessage (hLista, LB_ADDSTRING, 0, (LPARAM) linea);\n                    strcpy (linea, \" \\0\");\n                    SendMessage (hLista, LB_ADDSTRING, 0, (LPARAM) linea);\n\n                    strcpy (linea, \"[ CARPETA DE DESTINO ]\\0\");\n                    SendMessage (hLista, LB_ADDSTRING, 0, (LPARAM) linea);\n                    strcpy (linea, \"    \\0\");\n                    strcat (linea, wpi.szCarpetaDestino);\n                    SendMessage (hLista, LB_ADDSTRING, 0, (LPARAM) linea);\n                    strcpy (linea, \" \\0\");\n                    SendMessage (hLista, LB_ADDSTRING, 0, (LPARAM) linea);\n\n                    strcpy (linea, \"[ ARCHIVOS GENERADOS ]\\0\");\n                    SendMessage (hLista, LB_ADDSTRING, 0, (LPARAM) linea);\n                    t = strlen (wpi.szNombreArchivoGenerico);\n                    for( k = 0; k < wpi.iNumArch; k++)\n                    {\n                        strcpy (linea, \"    \\0\");\n                        wpi.szNombreArchivoGenerico[t-6] = (char) (48 + (k / 10));\n                        wpi.szNombreArchivoGenerico[t-5] = (char) (48 + (k % 10));\n                        strcat (linea, wpi.szNombreArchivoGenerico);\n                        SendMessage (hLista, LB_ADDSTRING, 0, (LPARAM) linea);\n                    }\n                    break;\n\n                case PSN_WIZFINISH:\n                    wpi.bFin = TRUE;\n                    break;\n\n                default:\n                    return FALSE;\n\n            }\n            return TRUE;\n    }\n    return FALSE;\n}", "path": "codi.c", "repo_name": "ex/Codi-1.1", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 320}
{"docstring": "// Esta funcion suma cadenas de digitos\n", "func_signal": "BOOL szSumar(char   a [],\n             char   b [],\n             char   c [],\n             int    tam_c)", "code": "{\n\nint     A = 1;\nint     B = 1;\nint     k;\nint     iSuma;\nint     iDig;\nint     iLleva = 0;\nint     max;\nint     min;\nint     t1, t2;\n\n\n    t1 = lstrlen (a);\n    t2 = lstrlen (b);\n\n    if (t1 > t2)\n    {\n        max = t1;\n        min = t2;\n    }\n    else\n    {   max = t2;\n        min = t1;\n    }\n    if (max > tam_c - 2)\n        return FALSE;\n\n    // sumar digitos cadena\n    for( k = 0; k < max; k++)\n    {\n        if (k >= t1)\n            A = 0;\n        if (k >= t2)\n            B = 0;\n        iSuma = (A * (int)(a [k])) + (B * (int)(b [k])) + iLleva - (A + B) * 48;\n        iDig =  iSuma % 10;\n        if (iSuma > 9)\n            iLleva = 1;\n        else\n            iLleva = 0;\n        c [k] = (char)(iDig + 48);\n    }\n    \n    // k ya ha sido incrementado en el bucle for, por eso:\n    if (iLleva)\n    {\n        c [k] = '1';\n        c [k + 1] = 0;\n    }\n    else\n        c [k] = 0;\n\n    return TRUE;\n\n}", "path": "corefunc.c", "repo_name": "ex/Codi-1.1", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 320}
{"docstring": "//  Esta funcion crea un Toolbar, la inicializa y devuelve un manejador a ella.\n//  InitCommonControls() debe haber sido llamada antes.\n//\n", "func_signal": "HWND CrearToolbar(HWND      hWnd,\n                  HINSTANCE hInstance)", "code": "{\n\nHIMAGELIST              himl, himlHot;\nHWND                    hWndToolbar;\nchar                    szBuf[MAX_IDS];\nint                     j[NUM_BOTONES];\nTBBUTTON                tbb[NUM_BOTONES];\n\n\n    // Create the toolbar control to be added.\n    hWndToolbar = CreateWindowEx (WS_EX_TOOLWINDOW,\n                                  TOOLBARCLASSNAME,\n                                  (LPSTR) NULL, \n                                  WS_CHILD | TBSTYLE_FLAT |\n                                  WS_CLIPCHILDREN | TBSTYLE_TOOLTIPS |\n                                  WS_CLIPSIBLINGS | CCS_NORESIZE ,  // Si quieres un marco alrededor del toolbar: | WS_DLGFRAME ,\n                                  0, 0, 0, 0,\n                                  hWnd,\n                                  NULL,     // se usara imagelist\n                                  hInstance,\n                                  NULL);\n\n    if (hWndToolbar == NULL )\n      MessageBox (NULL, \"No se pudo crear barra de herramientas\", NULL, MB_OK );\n    else\n    {\n        // Send the TB_BUTTONSTRUCTSIZE message, which is required for backward compatibility. \n        SendMessage(hWndToolbar, TB_BUTTONSTRUCTSIZE, (WPARAM) sizeof(TBBUTTON), 0); \n\n        // Agregamos las imagenes de los botones en estado NORMAL\n        // Create, fill, and assign the image list for normal buttons.\n        himl = ImageList_Create (TB_IMAGEX, TB_IMAGEY, ILC_COLOR8 | ILC_MASK, NUM_BOTONES, 0);      \n\n        ImageList_AddMasked (himl, LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_TOOL1)), RGB(255,255,0));\n        ImageList_AddMasked (himl, LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_TOOL2)), RGB(255,255,0));   \n        ImageList_AddMasked (himl, LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_TOOL3)), RGB(255,255,0));\n        ImageList_AddMasked (himl, LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_TOOL4)), RGB(255,255,0));\n        ImageList_AddMasked (himl, LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_TOOL6)), RGB(255,255,0));\n        ImageList_AddMasked (himl, LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_TOOL5)), RGB(255,255,0));\n        ImageList_AddMasked (himl, LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_TOOL7)), RGB(255,255,0));\n        \n        SendMessage(hWndToolbar, TB_SETIMAGELIST, 0, (LPARAM)himl);\n\n        // Agregamos las imagenes de los botones en estado HOT\n        // Create, fill, and assign the image list for hot buttons.\n        himlHot = ImageList_Create (TB_IMAGEX, TB_IMAGEY, ILC_COLOR8 | ILC_MASK, NUM_BOTONES, 0); \n\n        ImageList_AddMasked (himlHot, LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_HOT1)), RGB(192,192,192));\n        ImageList_AddMasked (himlHot, LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_HOT2)), RGB(192,192,192));   \n        ImageList_AddMasked (himlHot, LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_HOT3)), RGB(192,192,192));\n        ImageList_AddMasked (himlHot, LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_HOT4)), RGB(192,192,192));\n        ImageList_AddMasked (himlHot, LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_HOT6)), RGB(192,192,192));\n        ImageList_AddMasked (himlHot, LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_HOT5)), RGB(192,192,192));\n        ImageList_AddMasked (himlHot, LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_HOT7)), RGB(192,192,192));\n        \n        SendMessage(hWndToolbar, TB_SETHOTIMAGELIST, 0, (LPARAM)himlHot);\n      \n        // Add the button strings to the toolbar. \n        LoadString (hInstance, IDS_PARTIR, (LPSTR) &szBuf, MAX_IDS);\n        j[0] = SendMessage (hWndToolbar, TB_ADDSTRING, 0, (LPARAM) (LPSTR) szBuf);\n        \n        LoadString (hInstance, IDS_REUNIR, (LPSTR) &szBuf, MAX_IDS); \n        j[1] = SendMessage (hWndToolbar, TB_ADDSTRING,0, (LPARAM) (LPSTR) szBuf); \n\n        LoadString (hInstance, IDS_ENCRIPTAR, (LPSTR) &szBuf, MAX_IDS); \n        j[2] = SendMessage (hWndToolbar, TB_ADDSTRING, 0, (LPARAM) (LPSTR) szBuf); \n\n        LoadString (hInstance, IDS_DESENCRIPTAR, (LPSTR) &szBuf, MAX_IDS); \n        j[3] = SendMessage (hWndToolbar, TB_ADDSTRING, 0, (LPARAM) (LPSTR) szBuf);\n\n        LoadString (hInstance, IDS_CONTENIDO, (LPSTR) &szBuf, MAX_IDS); \n        j[4] = SendMessage (hWndToolbar, TB_ADDSTRING, 0, (LPARAM) (LPSTR) szBuf);\n\n        LoadString (hInstance, IDS_ACERCADE, (LPSTR) &szBuf, MAX_IDS);\n        j[5] = SendMessage (hWndToolbar, TB_ADDSTRING, 0, (LPARAM) (LPSTR) szBuf);\n\n        LoadString (hInstance, IDS_SALIR, (LPSTR) &szBuf, MAX_IDS);\n        j[6] = SendMessage (hWndToolbar, TB_ADDSTRING, 0, (LPARAM) (LPSTR) szBuf);\n\n        \n        // Fill the TBBUTTON array with button information, and add the buttons to the toolbar. \n        tbb[0].iBitmap = 0; \n        tbb[0].idCommand = IDM_PARTIR; \n        tbb[0].fsState = TBSTATE_ENABLED; \n        tbb[0].fsStyle = TBSTYLE_BUTTON; \n        tbb[0].dwData = 0; \n        tbb[0].iString = j[0]; \n\n        tbb[1].iBitmap = 1; \n        tbb[1].idCommand = IDM_REUNIR; \n        tbb[1].fsState = TBSTATE_ENABLED; \n        tbb[1].fsStyle = TBSTYLE_BUTTON; \n        tbb[1].dwData = 0; \n        tbb[1].iString = j[1]; \n\n        tbb[2].iBitmap = 2; \n        tbb[2].idCommand = IDM_ENCRIPTAR; \n        tbb[2].fsState = TBSTATE_ENABLED; \n        tbb[2].fsStyle = TBSTYLE_BUTTON; \n        tbb[2].dwData = 0; \n        tbb[2].iString = j[2]; \n\n        tbb[3].iBitmap = 3; \n        tbb[3].idCommand = IDM_DESENCRIPTAR; \n        tbb[3].fsState = TBSTATE_ENABLED; \n        tbb[3].fsStyle = TBSTYLE_BUTTON; \n        tbb[3].dwData = 0; \n        tbb[3].iString = j[3]; \n\n        tbb[4].iBitmap = 4; \n        tbb[4].idCommand = IDM_CONTENIDO; \n        tbb[4].fsState = TBSTATE_ENABLED; \n        tbb[4].fsStyle = TBSTYLE_BUTTON; \n        tbb[4].dwData = 0; \n        tbb[4].iString = j[4]; \n\n        tbb[5].iBitmap = 5; \n        tbb[5].idCommand = IDM_ACERCADE; \n        tbb[5].fsState = TBSTATE_ENABLED; \n        tbb[5].fsStyle = TBSTYLE_BUTTON; \n        tbb[5].dwData = 0; \n        tbb[5].iString = j[5]; \n\n        tbb[6].iBitmap = 6; \n        tbb[6].idCommand = IDM_SALIR; \n        tbb[6].fsState = TBSTATE_ENABLED; \n        tbb[6].fsStyle = TBSTYLE_BUTTON; \n        tbb[6].dwData = 0; \n        tbb[6].iString = j[6];\n\n        //  Inserta los botones en la barra de herramientas\n        SendMessage(hWndToolbar, TB_ADDBUTTONS, (WPARAM) NUM_BOTONES, (LPARAM) (LPTBBUTTON) &tbb);\n    }\n\n    return (hWndToolbar);\n}", "path": "codifunc.c", "repo_name": "ex/Codi-1.1", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 320}
{"docstring": "//  Esta funcion crea los menus con dibujos\n//\n", "func_signal": "VOID PonerDibujoMenu (HWND      hWnd, \n                      HINSTANCE hInstance)", "code": "{\n\nHBITMAP hbmpDibujoMenu1;\nHBITMAP hbmpDibujoMenu2;\nHMENU   hmenu = GetMenu (hWnd);     // handle to main menu\n\n\n    // (dibujaremos un signo de interrogacion al costado del IDM_ACERCADE)\n    hbmpDibujoMenu1 = DameMiDibujoMenu ((UINT)IDB_MENUACERCADE, hInstance);\n    SetMenuItemBitmaps (hmenu, IDM_ACERCADE, MF_BYCOMMAND, hbmpDibujoMenu1, hbmpDibujoMenu1);\n    \n    // (dibujaremos una x al costado del IDM_SALIR)\n    hbmpDibujoMenu2 = DameMiDibujoMenu ((UINT)IDB_MENUSALIR, hInstance);\n    SetMenuItemBitmaps (hmenu, IDM_SALIR, MF_BYCOMMAND, hbmpDibujoMenu2, hbmpDibujoMenu2);\n}", "path": "codifunc.c", "repo_name": "ex/Codi-1.1", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 320}
{"docstring": "//  Esta funcion responde al mensaje enviado por el sistema WM_DRAWITEM\n//  es la que controla lo que aparecera en el menu.\n//  De manera aleatoria: First-chance exception in CODI.exe (GDI32.DLL): 0xC0000005: Access Violation.\n//  (aun me aparece este mensaje de forma aleatoria (no al inicio) y no adivino por que)\n//------------------------------------------------------------------------------------------\n//  Version: 1.1 No me sale la excepcion esa en XP pero cuando depuro se congela el VC++ 6\n//------------------------------------------------------------------------------------------\n", "func_signal": "VOID OnDrawItem (HWND               hwnd,\n                 LPDRAWITEMSTRUCT   lpdis)", "code": "{\n\nLPMIMENUITEM    lpmItem = (LPMIMENUITEM) lpdis->itemData;\nHBRUSH          hbrTargetOld;\nHBRUSH          hbrBackground;\nHBRUSH          hbr3DHiLight;\nHBRUSH          hbr3DShadow;\nHBITMAP         hbmpSourceOld;\nHBITMAP         hbmpTargetOld;\nHBITMAP         hBitmapOld;\nHBITMAP         hbmpBitmapMenu;\nBITMAP          bmBitmap;\nHDC             hDcMem;\nHDC             hdcSource;\nHDC             hdcTarget;\nCOLORREF        clrPrevText;\nCOLORREF        crBackground;\nCOLORREF        cr3DHiLight;\nCOLORREF        cr3DShadow;\nint             x, y;\nint             oldSetBkMode;\nWORD            wBitmapX;\nWORD            wBitmapY;\nSIZE            sz;\n\n    //-----------------------------------------------------------------------------\n    // Version: 1.1\n    //-----------------------------------------------------------------------------\n    // Ya no se agrandara el tamao de estos menus de acuerdo al tamao del menu\n    // que tenga el sistema (se ve feo), pero si es mas grande se centrar.\n    //-----------------------------------------------------------------------------\n    int x0 = 0, y0 = 0;\n\n    // Dibujar el texto transparente\n    oldSetBkMode = SetBkMode(lpdis->hDC, TRANSPARENT);\n\n    // Crear el bitmap para el menu:\n    // ----------------------------\n    // If this handle is NULL, the function creates a memory device context compatible with the application's current screen.\n    hdcSource = CreateCompatibleDC ((HDC) NULL);\n    hdcTarget = CreateCompatibleDC (hdcSource);\n\n    // Get the menu background color and create a solid brush with that color. \n    crBackground = GetSysColor (COLOR_MENU);\n    hbrBackground = CreateSolidBrush (crBackground);\n\n    // Calculamos el tamao\n    wBitmapY = (UINT) (lpdis->rcItem.bottom - lpdis->rcItem.top);\n    wBitmapX = wBitmapY + 1;\n\n    // Crear bitmap para el menu (del tamao esperado)\n    hbmpBitmapMenu = CreateCompatibleBitmap (lpdis->hDC, wBitmapX, wBitmapY);   // No: hdcTarget\n\n    // Select the background brush and bitmap into the target DC.\n    hbrTargetOld = SelectObject (hdcTarget, hbrBackground);\n    hbmpTargetOld = SelectObject (hdcTarget, hbmpBitmapMenu);\n    \n    // Use the selected brush to initialize the background color\n    // of the bitmap in the target device context.\n    PatBlt (hdcTarget, 0, 0, wBitmapX, wBitmapY, PATCOPY);\n    \n    // Cargamos el bitmap del menu\n    hbmpSourceOld = SelectObject (hdcSource, lpmItem->hBitmap);\n\n    // Llena una structura BITMAP con informacion acerca de tu mapa de bits de recurso\n    GetObject (lpmItem->hBitmap, sizeof(BITMAP), &bmBitmap);\n\n    //-----------------------------------------------------------------------------\n    // Version: 1.1\n    //-----------------------------------------------------------------------------\n    x0 = wBitmapX - 16;\n    if (x0 > 0)\n    {\n        x0 = (int) (x0 / 2);\n    }\n\n    y0 = wBitmapY - 16;\n    if (y0 > 0)\n    {\n        y0 = (int) (y0 / 2);\n    }\n    //-----------------------------------------------------------------------------\n\n    // Copiamos el bitmap al destino (el rojo es transparente)\n    // (Dc destino - up X dest - up Y dest - W dest - H dest - DC orig - up X orig - up Y orig - W orig - H orig - color transparente)\n    TransparentBlt (hdcTarget, x0 + 1, y0, bmBitmap.bmWidth, bmBitmap.bmHeight, hdcSource, 0, 0, bmBitmap.bmWidth, bmBitmap.bmHeight, RGB(255,0,0));\n\n    // Hacer el efecto de sobresalte\n    if (lpdis->itemState & ODS_SELECTED)\n    {\n        // Get the COLOR_3DLIGHT color and create a solid brush with that color. \n        cr3DHiLight = GetSysColor (COLOR_3DHILIGHT);\n        hbr3DHiLight = CreateSolidBrush (cr3DHiLight);\n\n        SelectObject (hdcTarget, hbr3DHiLight);\n        PatBlt (hdcTarget, 0, 0, wBitmapX, 1, PATCOPY);\n        PatBlt (hdcTarget, 0, 0, 1, wBitmapY, PATCOPY);\n        DeleteObject (hbr3DHiLight);\n\n        // Get the COLOR_3DSHADOW color and create a solid brush with that color. \n        cr3DShadow = GetSysColor (COLOR_3DSHADOW);\n        hbr3DShadow = CreateSolidBrush (cr3DShadow);\n\n        SelectObject (hdcTarget, hbr3DShadow);\n        PatBlt (hdcTarget, wBitmapX - 1, 0, 1, wBitmapY, PATCOPY);\n        PatBlt (hdcTarget, 0, wBitmapY - 1, wBitmapX, 1, PATCOPY);\n        DeleteObject (hbr3DShadow);\n    }\n\n    // Select the old source and destination bitmaps into the\n    // source and destination DCs, and then delete the DCs and \n    // the background brush.\n    SelectObject (hdcSource, hbmpSourceOld);\n    SelectObject (hdcTarget, hbrTargetOld); \n    hbmpBitmapMenu = SelectObject (hdcTarget, hbmpTargetOld);\n    DeleteObject (hbrBackground);\n    DeleteObject (hdcSource);\n    DeleteObject (hdcTarget);\n\n    // Simulamos el efecto de seleccionar el menu\n    lpdis->rcItem.left += wBitmapX;\n    if (lpdis->itemState & ODS_SELECTED)\n    {\n        FillRect(lpdis->hDC, &lpdis->rcItem, CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHT)));\n        clrPrevText = SetTextColor(lpdis->hDC, GetSysColor (COLOR_HIGHLIGHTTEXT));\n    }\n    else\n    {\n        FillRect(lpdis->hDC, &lpdis->rcItem, CreateSolidBrush(GetSysColor(COLOR_MENU)));\n        clrPrevText = SetTextColor(lpdis->hDC, GetSysColor (COLOR_MENUTEXT));\n    }\n    lpdis->rcItem.left -= wBitmapX;\n\n    // Pinta el bitmap\n    hDcMem = CreateCompatibleDC (lpdis->hDC);\n    hBitmapOld = SelectObject (hDcMem, hbmpBitmapMenu);\n    BitBlt (lpdis->hDC, lpdis->rcItem.left, lpdis->rcItem.top, wBitmapX, wBitmapY, hDcMem, 0, 0, SRCCOPY);\n    SelectObject (hDcMem, hBitmapOld);\n    DeleteDC (hDcMem);\n\n    // Poner el texto:\n    // --------------\n    // Determinar la ubicacion para el texto\n    x = wBitmapX + 2;\n    GetTextExtentPoint32 (lpdis->hDC, lpmItem->szText, lpmItem->nLongText, &sz);\n    y = lpdis->rcItem.top + (wBitmapY - sz.cy)/2;\n\n    // Imprimir el texto del men\n    TextOut (lpdis->hDC, x, y, (LPSTR) lpmItem->szText, lpmItem->nLongText);\n\n    SetBkMode(lpdis->hDC, oldSetBkMode);\n    SetTextColor(lpdis->hDC, clrPrevText);\n\n}", "path": "codifunc.c", "repo_name": "ex/Codi-1.1", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 320}
{"docstring": "//  Esta funcion procesa los mensajes de la segunda hoja del Wizard Cripto\n//\n", "func_signal": "LRESULT CALLBACK FinalizarCriptoDialogProc (HWND hDlg,\n                                            UINT message,\n                                            UINT wParam,\n                                            LONG lParam)", "code": "{\n\nchar    linea[MAX_PATH + 15];   // +4 para los espacios +10 para el tamao\nHWND    hLista;\n\n\n    switch (message)\n    {\n        case WM_INITDIALOG:     \n            // Especificamos el ancho visible en pxls de la Lista (por HScroll) \n            SendDlgItemMessage (hDlg, IDL_RESUMEN, LB_SETHORIZONTALEXTENT, (WPARAM) 1600, 0);\n            return TRUE;\n\n        case WM_NOTIFY:\n            switch (((NMHDR FAR *) lParam)->code)\n            {\n                case PSN_SETACTIVE:\n                    PropSheet_SetWizButtons(GetParent(hDlg),  PSWIZB_BACK | PSWIZB_FINISH);\n                    // limpiar lista:\n                    SendDlgItemMessage (hDlg, IDL_RESUMEN, LB_RESETCONTENT, 0, 0);\n\n                    // Mostrar la informacion\n                    hLista = GetDlgItem (hDlg, IDL_RESUMEN);\n                    strcpy (linea, \"[ ARCHIVO FUENTE ]\");\n                    SendMessage (hLista, LB_ADDSTRING, 0, (LPARAM) linea);\n                    strcpy (linea, \"    \");\n                    strcat (linea, wci.szNombreArchivoFuente);\n                    SendMessage (hLista, LB_ADDSTRING, 0, (LPARAM) linea);\n                    strcpy (linea, \" \");\n                    SendMessage (hLista, LB_ADDSTRING, 0, (LPARAM) linea);\n\n                    strcpy (linea, \"[ ARCHIVO DESTINO ]\");\n                    SendMessage (hLista, LB_ADDSTRING, 0, (LPARAM) linea);\n                    strcpy (linea, \"    \");\n                    if (wci.bAutomatico && !wci.bEstamosEncriptando)\n                        strcat (linea, \"<Automatico>\");\n                    else\n                        strcat (linea, wci.szNombreArchivoDestino);\n                    SendMessage (hLista, LB_ADDSTRING, 0, (LPARAM) linea);\n                    strcpy (linea, \" \");\n                    SendMessage (hLista, LB_ADDSTRING, 0, (LPARAM) linea);\n\n                    strcpy (linea, \"[ CODIGO ENCRIPTACION ]\");\n                    SendMessage (hLista, LB_ADDSTRING, 0, (LPARAM) linea);\n                    strcpy (linea, \"    \");\n                    if (!wci.bMascara)\n                        strcat (linea, wci.codigo);\n                    else\n                        strcat (linea, \"<Personal>\");\n                    SendMessage (hLista, LB_ADDSTRING, 0, (LPARAM) linea);\n                    break;\n\n                case PSN_WIZFINISH:\n                    wci.bFin = TRUE;\n                    break;\n\n                default:\n                    return FALSE;\n\n            }\n            return TRUE;\n    }\n    return FALSE;\n}", "path": "codi.c", "repo_name": "ex/Codi-1.1", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 320}
{"docstring": "//  Esta funcion agrega un Item al Treeview.\n//\n", "func_signal": "HTREEITEM AddOneItem (HTREEITEM hParent,\n                      LPSTR     szText,\n                      HTREEITEM hInsAfter,\n                      int       iImage,\n                      int       iImageSelected,\n                      HWND      hwndTree)", "code": "{\nHTREEITEM hItem;\nTV_ITEM tvI;\nTV_INSERTSTRUCT tvIns;\n\n    // The pszText, iImage, and iSelectedImage members are filled out.\n    tvI.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;\n    tvI.pszText = szText;\n    tvI.cchTextMax = lstrlen (szText);\n    tvI.iImage = iImage;\n    tvI.iSelectedImage = iImageSelected;\n\n    tvIns.item = tvI;\n    tvIns.hInsertAfter = hInsAfter;\n    tvIns.hParent = hParent;\n\n    // Insert the item into the tree.\n    hItem = (HTREEITEM) SendMessage (hwndTree, TVM_INSERTITEM, 0,(LPARAM)(LPTV_INSERTSTRUCT)&tvIns);\n\n    return (hItem);\n}", "path": "codifunc.c", "repo_name": "ex/Codi-1.1", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 320}
{"docstring": "//  Esta funcion procesa los mensajes de la primera hoja del Wizard Reunir\n//\n", "func_signal": "LRESULT CALLBACK BuscarCarpetaReunirDialogProc (HWND hDlg,\n                                                UINT message,\n                                                UINT wParam,\n                                                LONG lParam)", "code": "{\n\nchar            szFile[MAX_PATH + 1];\nchar            ch;\nHWND            hWndParent;\nHWND            hWndBtn;\nBROWSEINFO      bi;\nLPITEMIDLIST    pidlBrowse;                 // PIDL selected by user \nBOOL            bTemp;\nOPENFILENAME    ofn;\nUINT            ui;\nRECT            rc;\n\n    switch (message)\n    {\n        case WM_INITDIALOG:\n            // Centramos el wizard\n            hWndParent = GetParent (hDlg);\n            GetWindowRect (hWndParent, & rc);\n            MoveWindow (hWndParent,\n                        (GetSystemMetrics (SM_CXSCREEN) - (rc.right - rc.left)) / 2,\n                        (GetSystemMetrics (SM_CYSCREEN) - (rc.bottom - rc.top)) / 2,\n                        (rc.right - rc.left),\n                        (rc.bottom - rc.top ),\n                        TRUE);\n            // Inicializamos valores\n            wri.bFin = FALSE;\n            wri.iNumArch = 0;\n            if (g_bDrag)\n            {\n                hWndBtn = GetDlgItem (hDlg, IDLB_1);\n                EnableWindow (hWndBtn, FALSE);\n                hWndBtn = GetDlgItem (hDlg, IDLB_2);\n                EnableWindow (hWndBtn, FALSE);\n                hWndBtn = GetDlgItem (hDlg, IDBT_ELEGIR_CARPETA);\n                EnableWindow (hWndBtn, FALSE);\n                SendDlgItemMessage (hDlg, IDLB_REUNIR, WM_SETTEXT , 0, (LPARAM)(LPCTSTR) \"La carpeta con los archivos a reunir ya fue elegida!\");\n                strcpy (wri.szCarpetaFuente, g_InfDrag.szFileDrag);\n                wri.bCarpetaFuenteElegida = TRUE;\n            }\n            else\n                wri.bCarpetaFuenteElegida = FALSE;\n            wri.bArchivoDestinoElegido = FALSE;\n            wri.bAutomatico = TRUE;\n            hWndBtn = GetDlgItem (hDlg, IDBT_REUNIR_DESTINO);\n            EnableWindow (hWndBtn, FALSE);\n            strcpy (wri.szNombreArchivoDestino, \"<Automatico>\");\n            CheckDlgButton (hDlg, IDCHK_AUTOMATICO, BST_CHECKED);\n            return TRUE;\n\n    \n        case WM_COMMAND:\n            if (HIWORD(wParam) == BN_CLICKED)\n            {    \n                switch( LOWORD(wParam))\n                {\n                    case IDBT_ELEGIR_CARPETA:\n                        ZeroMemory (szFile, sizeof(szFile));\n                        hWndParent = GetParent (hDlg);\n                        // Get the shell's allocator. \n                        if (!SUCCEEDED(SHGetMalloc(&g_pMalloc)))\n                        {\n                            MessageBox (NULL, \"Problemas con el Shell de Windows\", NULL, MB_OK |MB_ICONERROR);\n                            return TRUE;\n                        }\n                        // Llenamos la estructura para pedir informacion:\n                        bi.hwndOwner = hWndParent;\n                        bi.pidlRoot = NULL;\n                        bi.pszDisplayName = szFile;\n                        bi.lpszTitle = \"Selecciona la carpeta en donde copiaste los archivos fragmentados\"; \n                        bi.ulFlags = BIF_RETURNONLYFSDIRS;      // Solo folderes fisicos del sistema (no \"MiPC\" por ejemplo)\n                        bi.lpfn = NULL;\n                        bi.lParam = 0; \n                        bi.iImage = 0;\n                        pidlBrowse = SHBrowseForFolder(&bi);\n                        if (pidlBrowse)         // Devuelve NULL cuando se elige CANCELAR\n                        {\n                            if (SHGetPathFromIDList (pidlBrowse, szFile))\n                            {\n                                ch = szFile[strlen(szFile) - 1];\n                                if (ch == '\\\\')\n                                    MessageBox (NULL, \"No se acepta el directorio raiz\", NULL, MB_OK | MB_ICONERROR);\n                                else\n                                {\n                                    strcpy (wri.szCarpetaFuente, szFile);\n                                    wri.bCarpetaFuenteElegida = TRUE;\n                                }\n                            }\n                            else\n                                MessageBox (NULL, \"El sistema no pudo reconocer dicha carpeta\", NULL, MB_OK | MB_ICONERROR);\n                            // Free the PIDL returned by SHBrowseForFolder.\n                            g_pMalloc->lpVtbl->Free(g_pMalloc, pidlBrowse);\n                        }\n                        return TRUE;\n\n                    case IDBT_REUNIR_DESTINO:\n                        ZeroMemory (szFile, sizeof(szFile));\n                        hWndParent = GetParent (hDlg);\n                        bTemp = MostrarDlgComunGuardar (hWndParent,\n                                                        & ofn,\n                                                        szFile,\n                                                        sizeof(szFile),\n                                                        \"Ingresa el nombre del archivo a formar:\",\n                                                        \"Todos los Archivos\\0*.*\\0\",\n                                                        NULL,\n                                                        NULL,\n                                                        OFN_HIDEREADONLY |\n                                                        OFN_OVERWRITEPROMPT);\n                        if (bTemp)\n                        {\n                            strcpy (wri.szNombreArchivoDestino, ofn.lpstrFile);\n                            wri.bArchivoDestinoElegido = TRUE;\n                        }\n                        return TRUE;\n                    \n                    case IDCHK_AUTOMATICO:\n                        ui = IsDlgButtonChecked (hDlg, IDCHK_AUTOMATICO);\n                        if (ui == BST_CHECKED)\n                        {\n                            hWndBtn = GetDlgItem (hDlg, IDBT_REUNIR_DESTINO);\n                            EnableWindow (hWndBtn, FALSE);\n                            wri.bAutomatico = TRUE;\n                        }\n                        else\n                        {\n                            hWndBtn = GetDlgItem (hDlg, IDBT_REUNIR_DESTINO);\n                            EnableWindow (hWndBtn, TRUE);\n                            wri.bAutomatico = FALSE;\n                        }\n                        return TRUE;\n\n                    default:\n                        return FALSE;\n                }\n            }\n            return FALSE;\n\n\n        case WM_NOTIFY:\n            switch (((NMHDR FAR *) lParam)->code) \n            {\n                case PSN_SETACTIVE:\n                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);\n                    break;\n\n                case PSN_WIZNEXT:\n                    if (!wri.bCarpetaFuenteElegida)\n                    {\n                        MessageBox(NULL,\"Debes especificar el folder que creaste\",NULL,MB_OK | MB_ICONEXCLAMATION);\n                        SetWindowLong(hDlg, DWL_MSGRESULT, TRUE);\n                    }\n                    else\n                    {\n                        if (!wri.bAutomatico && !wri.bArchivoDestinoElegido)\n                        {\n                            MessageBox(NULL,\"Selecciona automatico o elige un destino\",NULL,MB_OK | MB_ICONEXCLAMATION);\n                            SetWindowLong(hDlg, DWL_MSGRESULT, TRUE);\n                        }\n                        else\n                            SetWindowLong(hDlg, DWL_MSGRESULT, FALSE);\n                    }\n                    break;\n\n                default:\n                    return FALSE;\n            }\n            return TRUE;\n\n        default:\n            return FALSE;\n    }\n    return FALSE;\n}", "path": "codi.c", "repo_name": "ex/Codi-1.1", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 320}
{"docstring": "//  Esta funcion crea el Wizard para el comando Password\n//  \n", "func_signal": "VOID CrearWizardPassword (HWND      hwndOwner,\n                          HINSTANCE hInstance)", "code": "{\n\nPROPSHEETPAGE psp[2];\nPROPSHEETHEADER psh;\n\n    psp[0].dwSize = sizeof(PROPSHEETPAGE);\n    psp[0].dwFlags = 0;\n    psp[0].hInstance = hInstance;\n    psp[0].pszTemplate = MAKEINTRESOURCE(IDD_PASSWORD);\n    psp[0].pfnDlgProc = PasswordDialogProc;\n    psp[0].lParam = 0;\n\n    psp[1].dwSize = sizeof(PROPSHEETPAGE);\n    psp[1].dwFlags = 0;\n    psp[1].hInstance = hInstance;\n    psp[1].pszTemplate = MAKEINTRESOURCE(IDD_FINALIZAR);\n    psp[1].pfnDlgProc = FinalizarPasswordDialogProc;\n    psp[1].lParam = 0;\n\n    psh.dwSize = sizeof(PROPSHEETHEADER);\n    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_WIZARD | PSH_NOAPPLYNOW;\n    psh.hwndParent = hwndOwner;\n    psh.hInstance = hInstance;\n    psh.nPages = sizeof(psp) / sizeof(PROPSHEETPAGE);\n    psh.nStartPage = 0;\n    psh.ppsp = (LPCPROPSHEETPAGE) &psp;\n\n    PropertySheet(&psh);\n\n    return;\n}", "path": "codifunc.c", "repo_name": "ex/Codi-1.1", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 320}
{"docstring": "//   FUNCTION: InitApplication(HANDLE) \n//   PURPOSE: Initializes window data and registers window class \n//   This function registers the window class for the main window.  \n// \n", "func_signal": "BOOL InitApplication(HANDLE hInstance)", "code": "{\n    WNDCLASS  wcCODI;\n\n    wcCODI.style = 0;                     \n    wcCODI.lpfnWndProc = (WNDPROC)MainWndProc;  // Puntero a la funcion que maneja\n                                                // los procedimientos de la ventana\n    wcCODI.cbClsExtra = 0;              \n    wcCODI.cbWndExtra = 0;              \n    wcCODI.hInstance = hInstance;       \n    wcCODI.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_CODI_ICON));\n    wcCODI.hCursor = LoadCursor(NULL, IDC_ARROW);\n    wcCODI.hbrBackground =  (HBRUSH) (COLOR_WINDOW + 1);    // Color de la ventana del usuario.\n    wcCODI.lpszMenuName =  MAKEINTRESOURCE(IDR_CODI_MENU);  // El nombre del menu de la ventana\n    wcCODI.lpszClassName = \"CODIWClass\"; \n\n    return (RegisterClass(&wcCODI));\n\n}", "path": "codi.c", "repo_name": "ex/Codi-1.1", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 320}
{"docstring": "//  Esta funcion responde al mensaje enviado por el sistema WM_DROPFILES\n//\n", "func_signal": "VOID OnDropFiles (HWND          hwnd,\n                  HINSTANCE     hInstance,\n                  WPARAM        wParam,\n                  LPINFODRAG    lpInfDrag,\n                  BOOL          *pg_bDrag)", "code": "{\n\nint                 iFiles;\nHDROP               hDropInfo = (HDROP) wParam;\nWIN32_FIND_DATA     FileData;\nHANDLE              handle;\nWORD                wMensaje;\nint                 k;\n\n    \n    iFiles = DragQueryFile (hDropInfo, (DWORD)(-1), (LPSTR)NULL, 0);\n    if (iFiles != 1)\n    {\n        MessageBox (NULL, \"Hey! Uno a la vez, please.\", NULL, MB_OK | MB_ICONERROR);\n        DragFinish (hDropInfo);\n    }\n    else\n    {\n        // Pedimos informacion del archivo y lo guardamos en el buffer\n        DragQueryFile (hDropInfo, 0, lpInfDrag->szFileDrag, sizeof (lpInfDrag->szFileDrag));\n        DragFinish (hDropInfo);\n\n        handle = FindFirstFile(lpInfDrag->szFileDrag, & FileData);\n        if (handle == INVALID_HANDLE_VALUE)\n            MessageBox (NULL, \"No se pudo acceder al archivo.\", NULL, MB_OK | MB_ICONERROR);\n        else\n        {\n            FindClose (handle);\n            if (FileData.dwFileAttributes == FILE_ATTRIBUTE_DIRECTORY)\n            {\n                // Si es un directorio suponemos que el usuario quiere reunir sus archivos\n                wMensaje = IDM_REUNIR;\n                goto ENVIAR_MENSAJE;\n            }\n            else\n            {\n                // Cuando el nombre es chico el campo <FileData.cAlternateFileName> no se llena (!)\n                // Buscamos la extension => buscamos el ultimo caracter '.' \n                for( k = strlen (lpInfDrag->szFileDrag) - 1; k > 0; k--)\n                {\n                    if (lpInfDrag->szFileDrag [k] == '.')\n                        break;\n                }\n\n                // Si no tiene extension la comparacion sera falsa\n                if (!lstrcmpi (& lpInfDrag->szFileDrag [k + 1], \"cd$\"))\n                {\nOP_DRAG_REUNIR:\n                    // Si es un archivo *.cd$ buscamos el directorio al que pertenece\n                    // y suponemos que el usuario quiere reunir sus archivos.\n                    // Buscamos el ultimo caracter '\\\\' \n                    for( k = strlen (lpInfDrag->szFileDrag) - 1; k > 0; k--)\n                    {\n                        if (lpInfDrag->szFileDrag [k] == '\\\\')\n                        {\n                            lpInfDrag->szFileDrag [k] = 0;\n                            break;\n                        }\n                    }\n                    // Si es el directorio raiz:\n                    if (strlen (lpInfDrag->szFileDrag) < 3)\n                    {\n                        MessageBox (NULL, \"No se acepta el directorio raiz\", NULL, MB_OK);\n                        return;\n                    }\n                    wMensaje = IDM_REUNIR;\n                    goto ENVIAR_MENSAJE;\n                }\n                else\n                {\n                    if (!lstrcmpi (& lpInfDrag->szFileDrag [k + 1], \"cx$\"))\n                        // Si es un archivo *.cx$ suponemos que el usuario quiere desencriptarlo\n                        goto OP_DRAG_DESENCRIPTAR;\n                    else\n                    {\n                        // En otro caso pedimos al usuario la accion a realizar\n                        DialogBox (hInstance, MAKEINTRESOURCE(IDD_DRAGFILES), hwnd, (DLGPROC)OpcionDragDlg);\n                        switch (lpInfDrag->nOpcion)\n                        {\n                            case DRAG_REUNIR:\n                                // Es necesaro buscar el directorio al que pertenece\n                                goto OP_DRAG_REUNIR;\n\n                            case DRAG_PARTIR:\n                                wMensaje = IDM_PARTIR;\n                                goto ENVIAR_MENSAJE;\n\n                            case DRAG_ENCRIPTAR:\n                                wMensaje = IDM_ENCRIPTAR;\n                                goto ENVIAR_MENSAJE;\n\n                            case DRAG_DESENCRIPTAR:\nOP_DRAG_DESENCRIPTAR:\n                                wMensaje = IDM_DESENCRIPTAR;\n                                goto ENVIAR_MENSAJE;\n\n                            default:\n                                return;\n                        }\n\nENVIAR_MENSAJE:\n                            * pg_bDrag = TRUE;\n                            SendMessage (hwnd, WM_COMMAND, MAKEWPARAM (wMensaje, 0), 0);\n                            * pg_bDrag = FALSE;\n                    }\n                }\n            }\n        }\n    }\n}", "path": "codifunc.c", "repo_name": "ex/Codi-1.1", "stars": 0, "license": "gpl-2.0", "language": "c", "size": 320}
{"docstring": "/* ------------------------------------------------------------------------- */\n", "func_signal": "static int mxl5007t_synth_lock_status(struct mxl5007t_state *state,\n\t\t\t\t      int *rf_locked, int *ref_locked)", "code": "{\n\tu8 d;\n\tint ret;\n\n\t*rf_locked = 0;\n\t*ref_locked = 0;\n\n\tret = mxl5007t_read_reg(state, 0xcf, &d);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tif ((d & 0x0c) == 0x0c)\n\t\t*rf_locked = 1;\n\n\tif ((d & 0x03) == 0x03)\n\t\t*ref_locked = 1;\nfail:\n\treturn ret;\n}", "path": "drivers\\media\\common\\tuners\\mxl5007t.c", "repo_name": "zhoukejun/android-2.6.27-yf255", "stars": 1, "license": "other", "language": "c", "size": 72596}
{"docstring": "/* ------------------------------------------------------------------------- */\n", "func_signal": "static void mxl5007t_set_mode_bits(struct mxl5007t_state *state,\n\t\t\t\t   enum mxl5007t_mode mode,\n\t\t\t\t   s32 if_diff_out_level)", "code": "{\n\tswitch (mode) {\n\tcase MxL_MODE_OTA_DVBT_ATSC:\n\t\tset_reg_bits(state->tab_init, 0x32, 0x0f, 0x06);\n\t\tset_reg_bits(state->tab_init, 0x35, 0xff, 0x0e);\n\t\tbreak;\n\tcase MxL_MODE_OTA_ISDBT:\n\t\tset_reg_bits(state->tab_init, 0x32, 0x0f, 0x06);\n\t\tset_reg_bits(state->tab_init, 0x35, 0xff, 0x12);\n\t\tbreak;\n\tcase MxL_MODE_OTA_NTSC_PAL_GH:\n\t\tset_reg_bits(state->tab_init, 0x16, 0x70, 0x00);\n\t\tset_reg_bits(state->tab_init, 0x32, 0xff, 0x85);\n\t\tbreak;\n\tcase MxL_MODE_OTA_PAL_IB:\n\t\tset_reg_bits(state->tab_init, 0x16, 0x70, 0x10);\n\t\tset_reg_bits(state->tab_init, 0x32, 0xff, 0x85);\n\t\tbreak;\n\tcase MxL_MODE_OTA_PAL_D_SECAM_KL:\n\t\tset_reg_bits(state->tab_init, 0x16, 0x70, 0x20);\n\t\tset_reg_bits(state->tab_init, 0x32, 0xff, 0x85);\n\t\tbreak;\n\tcase MxL_MODE_CABLE_DIGITAL:\n\t\tset_reg_bits(state->tab_init_cable, 0x71, 0xff, 0x01);\n\t\tset_reg_bits(state->tab_init_cable, 0x72, 0xff,\n\t\t\t     8 - if_diff_out_level);\n\t\tset_reg_bits(state->tab_init_cable, 0x74, 0xff, 0x17);\n\t\tbreak;\n\tcase MxL_MODE_CABLE_NTSC_PAL_GH:\n\t\tset_reg_bits(state->tab_init, 0x16, 0x70, 0x00);\n\t\tset_reg_bits(state->tab_init, 0x32, 0xff, 0x85);\n\t\tset_reg_bits(state->tab_init_cable, 0x71, 0xff, 0x01);\n\t\tset_reg_bits(state->tab_init_cable, 0x72, 0xff,\n\t\t\t     8 - if_diff_out_level);\n\t\tset_reg_bits(state->tab_init_cable, 0x74, 0xff, 0x17);\n\t\tbreak;\n\tcase MxL_MODE_CABLE_PAL_IB:\n\t\tset_reg_bits(state->tab_init, 0x16, 0x70, 0x10);\n\t\tset_reg_bits(state->tab_init, 0x32, 0xff, 0x85);\n\t\tset_reg_bits(state->tab_init_cable, 0x71, 0xff, 0x01);\n\t\tset_reg_bits(state->tab_init_cable, 0x72, 0xff,\n\t\t\t     8 - if_diff_out_level);\n\t\tset_reg_bits(state->tab_init_cable, 0x74, 0xff, 0x17);\n\t\tbreak;\n\tcase MxL_MODE_CABLE_PAL_D_SECAM_KL:\n\t\tset_reg_bits(state->tab_init, 0x16, 0x70, 0x20);\n\t\tset_reg_bits(state->tab_init, 0x32, 0xff, 0x85);\n\t\tset_reg_bits(state->tab_init_cable, 0x71, 0xff, 0x01);\n\t\tset_reg_bits(state->tab_init_cable, 0x72, 0xff,\n\t\t\t     8 - if_diff_out_level);\n\t\tset_reg_bits(state->tab_init_cable, 0x74, 0xff, 0x17);\n\t\tbreak;\n\tcase MxL_MODE_CABLE_SCTE40:\n\t\tset_reg_bits(state->tab_init_cable, 0x36, 0xff, 0x08);\n\t\tset_reg_bits(state->tab_init_cable, 0x68, 0xff, 0xbc);\n\t\tset_reg_bits(state->tab_init_cable, 0x71, 0xff, 0x01);\n\t\tset_reg_bits(state->tab_init_cable, 0x72, 0xff,\n\t\t\t     8 - if_diff_out_level);\n\t\tset_reg_bits(state->tab_init_cable, 0x74, 0xff, 0x17);\n\t\tbreak;\n\tdefault:\n\t\tmxl_fail(-EINVAL);\n\t}\n\treturn;\n}", "path": "drivers\\media\\common\\tuners\\mxl5007t.c", "repo_name": "zhoukejun/android-2.6.27-yf255", "stars": 1, "license": "other", "language": "c", "size": 72596}
{"docstring": "/* replace or extend an acl cache hit */\n", "func_signal": "void coda_cache_enter(struct inode *inode, int mask)", "code": "{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (cii->c_uid != current->fsuid) {\n                cii->c_uid = current->fsuid;\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n}", "path": "fs\\coda\\cache.c", "repo_name": "zhoukejun/android-2.6.27-yf255", "stars": 1, "license": "other", "language": "c", "size": 72596}
{"docstring": "/* ------------------------------------------------------------------------- */\n", "func_signal": "static int mxl5007t_set_params(struct dvb_frontend *fe,\n\t\t\t       struct dvb_frontend_parameters *params)", "code": "{\n\tstruct mxl5007t_state *state = fe->tuner_priv;\n\tenum mxl5007t_bw_mhz bw;\n\tenum mxl5007t_mode mode;\n\tint ret;\n\tu32 freq = params->frequency;\n\n\tif (fe->ops.info.type == FE_ATSC) {\n\t\tswitch (params->u.vsb.modulation) {\n\t\tcase VSB_8:\n\t\tcase VSB_16:\n\t\t\tmode = MxL_MODE_OTA_DVBT_ATSC;\n\t\t\tbreak;\n\t\tcase QAM_64:\n\t\tcase QAM_256:\n\t\t\tmode = MxL_MODE_CABLE_DIGITAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmxl_err(\"modulation not set!\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbw = MxL_BW_6MHz;\n\t} else if (fe->ops.info.type == FE_OFDM) {\n\t\tswitch (params->u.ofdm.bandwidth) {\n\t\tcase BANDWIDTH_6_MHZ:\n\t\t\tbw = MxL_BW_6MHz;\n\t\t\tbreak;\n\t\tcase BANDWIDTH_7_MHZ:\n\t\t\tbw = MxL_BW_7MHz;\n\t\t\tbreak;\n\t\tcase BANDWIDTH_8_MHZ:\n\t\t\tbw = MxL_BW_8MHz;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmxl_err(\"bandwidth not set!\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmode = MxL_MODE_OTA_DVBT_ATSC;\n\t} else {\n\t\tmxl_err(\"modulation type not supported!\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\tmutex_lock(&state->lock);\n\n\tret = mxl5007t_tuner_init(state, mode);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tret = mxl5007t_tuner_rf_tune(state, freq, bw);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tstate->frequency = freq;\n\tstate->bandwidth = (fe->ops.info.type == FE_OFDM) ?\n\t\tparams->u.ofdm.bandwidth : 0;\nfail:\n\tmutex_unlock(&state->lock);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\treturn ret;\n}", "path": "drivers\\media\\common\\tuners\\mxl5007t.c", "repo_name": "zhoukejun/android-2.6.27-yf255", "stars": 1, "license": "other", "language": "c", "size": 72596}
{"docstring": "/* ------------------------------------------------------------------------- */\n", "func_signal": "static int mxl5007t_get_status(struct dvb_frontend *fe, u32 *status)", "code": "{\n\tstruct mxl5007t_state *state = fe->tuner_priv;\n\tint rf_locked, ref_locked;\n\ts32 rf_input_level;\n\tint ret;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\tret = mxl5007t_synth_lock_status(state, &rf_locked, &ref_locked);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tmxl_debug(\"%s%s\", rf_locked ? \"rf locked \" : \"\",\n\t\t  ref_locked ? \"ref locked\" : \"\");\n\n\tret = mxl5007t_check_rf_input_power(state, &rf_input_level);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\tmxl_debug(\"rf input power: %d\", rf_input_level);\nfail:\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\treturn ret;\n}", "path": "drivers\\media\\common\\tuners\\mxl5007t.c", "repo_name": "zhoukejun/android-2.6.27-yf255", "stars": 1, "license": "other", "language": "c", "size": 72596}
{"docstring": "/* this won't do any harm: just flag all children */\n", "func_signal": "static void coda_flag_children(struct dentry *parent, int flag)", "code": "{\n\tstruct list_head *child;\n\tstruct dentry *de;\n\n\tspin_lock(&dcache_lock);\n\tlist_for_each(child, &parent->d_subdirs)\n\t{\n\t\tde = list_entry(child, struct dentry, d_u.d_child);\n\t\t/* don't know what to do with negative dentries */\n\t\tif ( ! de->d_inode ) \n\t\t\tcontinue;\n\t\tcoda_flag_inode(de->d_inode, flag);\n\t}\n\tspin_unlock(&dcache_lock);\n\treturn; \n}", "path": "fs\\coda\\cache.c", "repo_name": "zhoukejun/android-2.6.27-yf255", "stars": 1, "license": "other", "language": "c", "size": 72596}
{"docstring": "/*\n * l4_setcal() programs the L4 with calibration values.\n */\n", "func_signal": "static int l4_setcal(int port, int *cal)", "code": "{\n\tint i, result = -1;\n\n\toutb(L4_SELECT_ANALOG, L4_PORT);\n\toutb(L4_SELECT_DIGITAL + (port >> 2), L4_PORT);\n\tif (inb(L4_PORT) & L4_BUSY)\n\t\tgoto out;\n\n\toutb(L4_CMD_SETCAL, L4_PORT);\n\tif (l4_wait_ready())\n\t\tgoto out;\n\n\tif (inb(L4_PORT) != L4_SELECT_DIGITAL + (port >> 2))\n\t\tgoto out;\n\n\tif (l4_wait_ready())\n\t\tgoto out;\n        outb(port & 3, L4_PORT);\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (l4_wait_ready())\n\t\t\tgoto out;\n\t\toutb(cal[i], L4_PORT);\n\t}\n\n\tresult = 0;\n\nout:\toutb(L4_SELECT_ANALOG, L4_PORT);\n\treturn result;\n}", "path": "drivers\\input\\gameport\\lightning.c", "repo_name": "zhoukejun/android-2.6.27-yf255", "stars": 1, "license": "other", "language": "c", "size": 72596}
{"docstring": "/* net device transmit always called with no BH (preempt_disabled) */\n", "func_signal": "int br_dev_xmit(struct sk_buff *skb, struct net_device *dev)", "code": "{\n\tstruct net_bridge *br = netdev_priv(dev);\n\tconst unsigned char *dest = skb->data;\n\tstruct net_bridge_fdb_entry *dst;\n\n\tdev->stats.tx_packets++;\n\tdev->stats.tx_bytes += skb->len;\n\n\tskb_reset_mac_header(skb);\n\tskb_pull(skb, ETH_HLEN);\n\n\tif (dest[0] & 1)\n\t\tbr_flood_deliver(br, skb);\n\telse if ((dst = __br_fdb_get(br, dest)) != NULL)\n\t\tbr_deliver(dst->dst, skb);\n\telse\n\t\tbr_flood_deliver(br, skb);\n\n\treturn 0;\n}", "path": "net\\bridge\\br_device.c", "repo_name": "zhoukejun/android-2.6.27-yf255", "stars": 1, "license": "other", "language": "c", "size": 72596}
{"docstring": "/* check if the mask has been matched against the acl already */\n", "func_signal": "int coda_cache_check(struct inode *inode, int mask)", "code": "{\n\tstruct coda_inode_info *cii = ITOC(inode);\n        int hit;\n\t\n        hit = (mask & cii->c_cached_perm) == mask &&\n\t\tcii->c_uid == current->fsuid &&\n\t\tcii->c_cached_epoch == atomic_read(&permission_epoch);\n\n        return hit;\n}", "path": "fs\\coda\\cache.c", "repo_name": "zhoukejun/android-2.6.27-yf255", "stars": 1, "license": "other", "language": "c", "size": 72596}
{"docstring": "/* remove cached acl from an inode */\n", "func_signal": "void coda_cache_clear_inode(struct inode *inode)", "code": "{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch) - 1;\n}", "path": "fs\\coda\\cache.c", "repo_name": "zhoukejun/android-2.6.27-yf255", "stars": 1, "license": "other", "language": "c", "size": 72596}
{"docstring": "/* Allow setting mac address to any valid ethernet address. */\n", "func_signal": "static int br_set_mac_address(struct net_device *dev, void *p)", "code": "{\n\tstruct net_bridge *br = netdev_priv(dev);\n\tstruct sockaddr *addr = p;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EINVAL;\n\n\tspin_lock_bh(&br->lock);\n\tmemcpy(dev->dev_addr, addr->sa_data, ETH_ALEN);\n\tbr_stp_change_bridge_id(br, addr->sa_data);\n\tbr->flags |= BR_SET_MAC_ADDR;\n\tspin_unlock_bh(&br->lock);\n\n\treturn 0;\n}", "path": "net\\bridge\\br_device.c", "repo_name": "zhoukejun/android-2.6.27-yf255", "stars": 1, "license": "other", "language": "c", "size": 72596}
{"docstring": "/*\n * l4_getcal() reads the L4 with calibration values.\n */\n", "func_signal": "static int l4_getcal(int port, int *cal)", "code": "{\n\tint i, result = -1;\n\n\toutb(L4_SELECT_ANALOG, L4_PORT);\n\toutb(L4_SELECT_DIGITAL + (port >> 2), L4_PORT);\n\tif (inb(L4_PORT) & L4_BUSY)\n\t\tgoto out;\n\n\toutb(L4_CMD_GETCAL, L4_PORT);\n\tif (l4_wait_ready())\n\t\tgoto out;\n\n\tif (inb(L4_PORT) != L4_SELECT_DIGITAL + (port >> 2))\n\t\tgoto out;\n\n\tif (l4_wait_ready())\n\t\tgoto out;\n        outb(port & 3, L4_PORT);\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (l4_wait_ready())\n\t\t\tgoto out;\n\t\tcal[i] = inb(L4_PORT);\n\t}\n\n\tresult = 0;\n\nout:\toutb(L4_SELECT_ANALOG, L4_PORT);\n\treturn result;\n}", "path": "drivers\\input\\gameport\\lightning.c", "repo_name": "zhoukejun/android-2.6.27-yf255", "stars": 1, "license": "other", "language": "c", "size": 72596}
{"docstring": "/* ------------------------------------------------------------------------- */\n", "func_signal": "static int mxl5007t_get_frequency(struct dvb_frontend *fe, u32 *frequency)", "code": "{\n\tstruct mxl5007t_state *state = fe->tuner_priv;\n\t*frequency = state->frequency;\n\treturn 0;\n}", "path": "drivers\\media\\common\\tuners\\mxl5007t.c", "repo_name": "zhoukejun/android-2.6.27-yf255", "stars": 1, "license": "other", "language": "c", "size": 72596}
{"docstring": "/*\n * l4_cooked_read() reads data from the Lightning 4.\n */\n", "func_signal": "static int l4_cooked_read(struct gameport *gameport, int *axes, int *buttons)", "code": "{\n\tstruct l4 *l4 = gameport->port_data;\n\tunsigned char status;\n\tint i, result = -1;\n\n\toutb(L4_SELECT_ANALOG, L4_PORT);\n\toutb(L4_SELECT_DIGITAL + (l4->port >> 2), L4_PORT);\n\n\tif (inb(L4_PORT) & L4_BUSY) goto fail;\n\toutb(l4->port & 3, L4_PORT);\n\n\tif (l4_wait_ready()) goto fail;\n\tstatus = inb(L4_PORT);\n\n\tfor (i = 0; i < 4; i++)\n\t\tif (status & (1 << i)) {\n\t\t\tif (l4_wait_ready()) goto fail;\n\t\t\taxes[i] = inb(L4_PORT);\n\t\t\tif (axes[i] > 252) axes[i] = -1;\n\t\t}\n\n\tif (status & 0x10) {\n\t\tif (l4_wait_ready()) goto fail;\n\t\t*buttons = inb(L4_PORT) & 0x0f;\n\t}\n\n\tresult = 0;\n\nfail:\toutb(L4_SELECT_ANALOG, L4_PORT);\n\treturn result;\n}", "path": "drivers\\input\\gameport\\lightning.c", "repo_name": "zhoukejun/android-2.6.27-yf255", "stars": 1, "license": "other", "language": "c", "size": 72596}
{"docstring": "/*\n * Called after processes are frozen, but before we shutdown devices.\n */\n", "func_signal": "static int at91_pm_begin(suspend_state_t state)", "code": "{\n\ttarget_state = state;\n\treturn 0;\n}", "path": "arch\\arm\\mach-at91\\pm.c", "repo_name": "zhoukejun/android-2.6.27-yf255", "stars": 1, "license": "other", "language": "c", "size": 72596}
{"docstring": "/* ------------------------------------------------------------------------- */\n", "func_signal": "static int mxl5007t_init(struct dvb_frontend *fe)", "code": "{\n\tstruct mxl5007t_state *state = fe->tuner_priv;\n\tint ret;\n\tu8 d;\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\n\tret = mxl5007t_read_reg(state, 0x05, &d);\n\tif (mxl_fail(ret))\n\t\tgoto fail;\n\n\tret = mxl5007t_write_reg(state, 0x05, d | 0x01);\n\tmxl_fail(ret);\nfail:\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 0);\n\n\treturn ret;\n}", "path": "drivers\\media\\common\\tuners\\mxl5007t.c", "repo_name": "zhoukejun/android-2.6.27-yf255", "stars": 1, "license": "other", "language": "c", "size": 72596}
{"docstring": "/* called by _init and _rftun to manipulate the register arrays */\n", "func_signal": "static void set_reg_bits(struct reg_pair_t *reg_pair, u8 reg, u8 mask, u8 val)", "code": "{\n\tunsigned int i = 0;\n\n\twhile (reg_pair[i].reg || reg_pair[i].val) {\n\t\tif (reg_pair[i].reg == reg) {\n\t\t\treg_pair[i].val &= ~mask;\n\t\t\treg_pair[i].val |= val;\n\t\t}\n\t\ti++;\n\n\t}\n\treturn;\n}", "path": "drivers\\media\\common\\tuners\\mxl5007t.c", "repo_name": "zhoukejun/android-2.6.27-yf255", "stars": 1, "license": "other", "language": "c", "size": 72596}
{"docstring": "/* ------------------------------------------------------------------------- */\n", "func_signal": "static int mxl5007t_write_reg(struct mxl5007t_state *state, u8 reg, u8 val)", "code": "{\n\tu8 buf[] = { reg, val };\n\tstruct i2c_msg msg = { .addr = state->i2c_props.addr, .flags = 0,\n\t\t\t       .buf = buf, .len = 2 };\n\tint ret;\n\n\tret = i2c_transfer(state->i2c_props.adap, &msg, 1);\n\tif (ret != 1) {\n\t\tmxl_err(\"failed!\");\n\t\treturn -EREMOTEIO;\n\t}\n\treturn 0;\n}", "path": "drivers\\media\\common\\tuners\\mxl5007t.c", "repo_name": "zhoukejun/android-2.6.27-yf255", "stars": 1, "license": "other", "language": "c", "size": 72596}
{"docstring": "/*\n * l4_wait_ready() waits for the L4 to become ready.\n */\n", "func_signal": "static int l4_wait_ready(void)", "code": "{\n\tunsigned int t = L4_TIMEOUT;\n\n\twhile ((inb(L4_PORT) & L4_BUSY) && t > 0) t--;\n\treturn -(t <= 0);\n}", "path": "drivers\\input\\gameport\\lightning.c", "repo_name": "zhoukejun/android-2.6.27-yf255", "stars": 1, "license": "other", "language": "c", "size": 72596}
{"docstring": "/*\n * l4_calibrate() calibrates the L4 for the attached device, so\n * that the device's resistance fits into the L4's 8-bit range.\n */\n", "func_signal": "static int l4_calibrate(struct gameport *gameport, int *axes, int *max)", "code": "{\n\tint i, t;\n\tint cal[4];\n\tstruct l4 *l4 = gameport->port_data;\n\n\tif (l4_getcal(l4->port, cal))\n\t\treturn -1;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tt = (max[i] * cal[i]) / 200;\n\t\tt = (t < 1) ? 1 : ((t > 255) ? 255 : t);\n\t\taxes[i] = (axes[i] < 0) ? -1 : (axes[i] * cal[i]) / t;\n\t\taxes[i] = (axes[i] > 252) ? 252 : axes[i];\n\t\tcal[i] = t;\n\t}\n\n\tif (l4_setcal(l4->port, cal))\n\t\treturn -1;\n\n\treturn 0;\n}", "path": "drivers\\input\\gameport\\lightning.c", "repo_name": "zhoukejun/android-2.6.27-yf255", "stars": 1, "license": "other", "language": "c", "size": 72596}
{"docstring": "// Find the minimum separating axis for the give poly and axis list.\n", "func_signal": "static inline int\nfindMSA(cpPolyShape *poly, cpPolyShapeAxis *axes, int num, cpFloat *min_out)", "code": "{\n\tint min_index = 0;\n\tcpFloat min = cpPolyShapeValueOnAxis(poly, axes->n, axes->d);\n\tif(min > 0.0) return -1;\n\t\n\tfor(int i=1; i<num; i++){\n\t\tcpFloat dist = cpPolyShapeValueOnAxis(poly, axes[i].n, axes[i].d);\n\t\tif(dist > 0.0) {\n\t\t\treturn -1;\n\t\t} else if(dist > min){\n\t\t\tmin = dist;\n\t\t\tmin_index = i;\n\t\t}\n\t}\n\t\n\t(*min_out) = min;\n\treturn min_index;\n}", "path": "lib\\Chipmunk-4.1.0\\ruby\\cpCollision.c", "repo_name": "HamptonMakes/spacebrawl", "stars": 1, "license": "None", "language": "c", "size": 1199}
{"docstring": "// Callback from the spatial hash.\n// TODO: Refactor this into separate functions?\n", "func_signal": "static int\nqueryFunc(void *p1, void *p2, void *data)", "code": "{\n\t// Cast the generic pointers from the spatial hash back to usefull types\n\tcpShape *a = (cpShape *)p1;\n\tcpShape *b = (cpShape *)p2;\n\tcpSpace *space = (cpSpace *)data;\n\t\n\t// Reject any of the simple cases\n\tif(queryReject(a,b)) return 0;\n\t\n\t// Shape 'a' should have the lower shape type. (required by cpCollideShapes() )\n\tif(a->klass->type > b->klass->type){\n\t\tcpShape *temp = a;\n\t\ta = b;\n\t\tb = temp;\n\t}\n\t\n\t// Find the collision pair function for the shapes.\n\tunsigned int ids[] = {a->collision_type, b->collision_type};\n\tunsigned int hash = CP_HASH_PAIR(a->collision_type, b->collision_type);\n\tcpCollPairFunc *pairFunc = (cpCollPairFunc *)cpHashSetFind(space->collFuncSet, hash, ids);\n\tif(!pairFunc->func) return 0; // A NULL pair function means don't collide at all.\n\t\n\t// Narrow-phase collision detection.\n\tcpContact *contacts = NULL;\n\tint numContacts = cpCollideShapes(a, b, &contacts);\n\tif(!numContacts) return 0; // Shapes are not colliding.\n\t\n\t// The collision pair function requires objects to be ordered by their collision types.\n\tcpShape *pair_a = a;\n\tcpShape *pair_b = b;\n\tcpFloat normal_coef = 1.0f;\n\t\n\t// Swap them if necessary.\n\tif(pair_a->collision_type != pairFunc->a){\n\t\tcpShape *temp = pair_a;\n\t\tpair_a = pair_b;\n\t\tpair_b = temp;\n\t\tnormal_coef = -1.0f;\n\t}\n\t\n\tif(pairFunc->func(pair_a, pair_b, contacts, numContacts, normal_coef, pairFunc->data)){\n\t\t// The collision pair function OKed the collision. Record the contact information.\n\t\t\n\t\t// Get an arbiter from space->contactSet for the two shapes.\n\t\t// This is where the persistant contact magic comes from.\n\t\tcpShape *shape_pair[] = {a, b};\n\t\tcpArbiter *arb = (cpArbiter *)cpHashSetInsert(space->contactSet, CP_HASH_PAIR(a, b), shape_pair, space);\n\t\t\n\t\t// Timestamp the arbiter.\n\t\tarb->stamp = space->stamp;\n\t\tarb->a = a; arb->b = b; // TODO: Investigate why this is still necessary?\n\t\t// Inject the new contact points into the arbiter.\n\t\tcpArbiterInject(arb, contacts, numContacts);\n\t\t\n\t\t// Add the arbiter to the list of active arbiters.\n\t\tcpArrayPush(space->arbiters, arb);\n\t\t\n\t\treturn numContacts;\n\t} else {\n\t\t// The collision pair function rejected the collision.\n\t\t\n\t\tfree(contacts);\n\t\treturn 0;\n\t}\n}", "path": "lib\\Chipmunk-4.1.0\\src\\cpSpace.c", "repo_name": "HamptonMakes/spacebrawl", "stars": 1, "license": "None", "language": "c", "size": 1199}
{"docstring": "// Helper function for allocating contact point lists.\n", "func_signal": "static cpContact *\naddContactPoint(cpContact **arr, int *max, int *num)", "code": "{\n\tif(*arr == NULL){\n\t\t// Allocate the array if it hasn't been done.\n\t\t(*max) = 2;\n\t\t(*num) = 0;\n\t\t(*arr) = (cpContact *)malloc((*max)*sizeof(cpContact));\n\t} else if(*num == *max){\n\t\t// Extend it if necessary.\n\t\t(*max) *= 2;\n\t\t(*arr) = (cpContact *)realloc(*arr, (*max)*sizeof(cpContact));\n\t}\n\t\n\tcpContact *con = &(*arr)[*num];\n\t(*num)++;\n\t\n\treturn con;\n}", "path": "lib\\Chipmunk-4.1.0\\ruby\\cpCollision.c", "repo_name": "HamptonMakes/spacebrawl", "stars": 1, "license": "None", "language": "c", "size": 1199}
{"docstring": "// This one is complicated and gross. Just don't go there...\n// TODO: Comment me!\n", "func_signal": "static int\nseg2poly(cpShape *shape1, cpShape *shape2, cpContact **arr)", "code": "{\n\tcpSegmentShape *seg = (cpSegmentShape *)shape1;\n\tcpPolyShape *poly = (cpPolyShape *)shape2;\n\tcpPolyShapeAxis *axes = poly->tAxes;\n\t\n\tcpFloat segD = cpvdot(seg->tn, seg->ta);\n\tcpFloat minNorm = cpPolyShapeValueOnAxis(poly, seg->tn, segD) - seg->r;\n\tcpFloat minNeg = cpPolyShapeValueOnAxis(poly, cpvneg(seg->tn), -segD) - seg->r;\n\tif(minNeg > 0.0f || minNorm > 0.0f) return 0;\n\t\n\tint mini = 0;\n\tcpFloat poly_min = segValueOnAxis(seg, axes->n, axes->d);\n\tif(poly_min > 0.0f) return 0;\n\tfor(int i=0; i<poly->numVerts; i++){\n\t\tcpFloat dist = segValueOnAxis(seg, axes[i].n, axes[i].d);\n\t\tif(dist > 0.0f){\n\t\t\treturn 0;\n\t\t} else if(dist > poly_min){\n\t\t\tpoly_min = dist;\n\t\t\tmini = i;\n\t\t}\n\t}\n\t\n\tint max = 0;\n\tint num = 0;\n\t\n\tcpVect poly_n = cpvneg(axes[mini].n);\n\t\n\tcpVect va = cpvadd(seg->ta, cpvmult(poly_n, seg->r));\n\tcpVect vb = cpvadd(seg->tb, cpvmult(poly_n, seg->r));\n\tif(cpPolyShapeContainsVert(poly, va))\n\t\tcpContactInit(addContactPoint(arr, &max, &num), va, poly_n, poly_min, CP_HASH_PAIR(seg, 0));\n\tif(cpPolyShapeContainsVert(poly, vb))\n\t\tcpContactInit(addContactPoint(arr, &max, &num), vb, poly_n, poly_min, CP_HASH_PAIR(seg, 1));\n\n\t// Floating point precision problems here.\n\t// This will have to do for now.\n\tpoly_min -= cp_collision_slop;\n\tif(minNorm >= poly_min || minNeg >= poly_min) {\n\t\tif(minNorm > minNeg)\n\t\t\tfindPointsBehindSeg(arr, &max, &num, seg, poly, minNorm, 1.0f);\n\t\telse\n\t\t\tfindPointsBehindSeg(arr, &max, &num, seg, poly, minNeg, -1.0f);\n\t}\n\t\n\t// If no other collision points are found, try colliding endpoints.\n\tif(num == 0){\n\t\tcpVect poly_a = poly->tVerts[mini];\n\t\tcpVect poly_b = poly->tVerts[(mini + 1)%poly->numVerts];\n\t\t\n\t\tif(circle2circleQuery(seg->ta, poly_a, seg->r, 0.0f, arr))\n\t\t\treturn 1;\n\t\t\t\n\t\tif(circle2circleQuery(seg->tb, poly_a, seg->r, 0.0f, arr))\n\t\t\treturn 1;\n\t\t\t\n\t\tif(circle2circleQuery(seg->ta, poly_b, seg->r, 0.0f, arr))\n\t\t\treturn 1;\n\t\t\t\n\t\tif(circle2circleQuery(seg->tb, poly_b, seg->r, 0.0f, arr))\n\t\t\treturn 1;\n\t}\n\n\treturn num;\n}", "path": "lib\\Chipmunk-4.1.0\\ruby\\cpCollision.c", "repo_name": "HamptonMakes/spacebrawl", "stars": 1, "license": "None", "language": "c", "size": 1199}
{"docstring": "// Identify vertexes that have penetrated the segment.\n", "func_signal": "static inline void\nfindPointsBehindSeg(cpContact **arr, int *max, int *num, cpSegmentShape *seg, cpPolyShape *poly, cpFloat pDist, cpFloat coef)", "code": "{\n\tcpFloat dta = cpvcross(seg->tn, seg->ta);\n\tcpFloat dtb = cpvcross(seg->tn, seg->tb);\n\tcpVect n = cpvmult(seg->tn, coef);\n\t\n\tfor(int i=0; i<poly->numVerts; i++){\n\t\tcpVect v = poly->tVerts[i];\n\t\tif(cpvdot(v, n) < cpvdot(seg->tn, seg->ta)*coef + seg->r){\n\t\t\tcpFloat dt = cpvcross(seg->tn, v);\n\t\t\tif(dta >= dt && dt >= dtb){\n\t\t\t\tcpContactInit(addContactPoint(arr, max, num), v, n, pDist, CP_HASH_PAIR(poly, i));\n\t\t\t}\n\t\t}\n\t}\n}", "path": "lib\\Chipmunk-4.1.0\\ruby\\cpCollision.c", "repo_name": "HamptonMakes/spacebrawl", "stars": 1, "license": "None", "language": "c", "size": 1199}
{"docstring": "// BBfunc callback for the spatial hash.\n", "func_signal": "static cpBB\nbbfunc(void *ptr)", "code": "{\n\tcpShape *shape = (cpShape *)ptr;\n\treturn shape->bb;\n}", "path": "lib\\Chipmunk-4.1.0\\src\\cpSpace.c", "repo_name": "HamptonMakes/spacebrawl", "stars": 1, "license": "None", "language": "c", "size": 1199}
{"docstring": "// Equals function for collFuncSet.\n", "func_signal": "static int\ncollFuncSetEql(void *ptr, void *elt)", "code": "{\n\tunsigned int *ids = (unsigned int *)ptr;\n\tunsigned int a = ids[0];\n\tunsigned int b = ids[1];\n\t\n\tcpCollPairFunc *pair = (cpCollPairFunc *)elt;\n\t\n\treturn ((a == pair->a && b == pair->b) || (b == pair->a && a == pair->b));\n}", "path": "lib\\Chipmunk-4.1.0\\src\\cpSpace.c", "repo_name": "HamptonMakes/spacebrawl", "stars": 1, "license": "None", "language": "c", "size": 1199}
{"docstring": "// Collide circles to segment shapes.\n", "func_signal": "static int\ncircle2segment(cpShape *circleShape, cpShape *segmentShape, cpContact **con)", "code": "{\n\tcpCircleShape *circ = (cpCircleShape *)circleShape;\n\tcpSegmentShape *seg = (cpSegmentShape *)segmentShape;\n\t\n\t// Radius sum\n\tcpFloat rsum = circ->r + seg->r;\n\t\n\t// Calculate normal distance from segment.\n\tcpFloat dn = cpvdot(seg->tn, circ->tc) - cpvdot(seg->ta, seg->tn);\n\tcpFloat dist = fabs(dn) - rsum;\n\tif(dist > 0.0f) return 0;\n\t\n\t// Calculate tangential distance along segment.\n\tcpFloat dt = -cpvcross(seg->tn, circ->tc);\n\tcpFloat dtMin = -cpvcross(seg->tn, seg->ta);\n\tcpFloat dtMax = -cpvcross(seg->tn, seg->tb);\n\t\n\t// Decision tree to decide which feature of the segment to collide with.\n\tif(dt < dtMin){\n\t\tif(dt < (dtMin - rsum)){\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn circle2circleQuery(circ->tc, seg->ta, circ->r, seg->r, con);\n\t\t}\n\t} else {\n\t\tif(dt < dtMax){\n\t\t\tcpVect n = (dn < 0.0f) ? seg->tn : cpvneg(seg->tn);\n\t\t\t(*con) = (cpContact *)malloc(sizeof(cpContact));\n\t\t\tcpContactInit(\n\t\t\t\t(*con),\n\t\t\t\tcpvadd(circ->tc, cpvmult(n, circ->r + dist*0.5f)),\n\t\t\t\tn,\n\t\t\t\tdist,\n\t\t\t\t0\t\t\t\t \n\t\t\t);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tif(dt < (dtMax + rsum)) {\n\t\t\t\treturn circle2circleQuery(circ->tc, seg->tb, circ->r, seg->r, con);\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 1;\n}", "path": "lib\\Chipmunk-4.1.0\\ruby\\cpCollision.c", "repo_name": "HamptonMakes/spacebrawl", "stars": 1, "license": "None", "language": "c", "size": 1199}
{"docstring": "// Iterator function used for updating shape BBoxes.\n", "func_signal": "static void\nupdateBBCache(void *ptr, void *unused)", "code": "{\n\tcpShape *shape = (cpShape *)ptr;\n\tcpShapeCacheBB(shape);\n}", "path": "lib\\Chipmunk-4.1.0\\src\\cpSpace.c", "repo_name": "HamptonMakes/spacebrawl", "stars": 1, "license": "None", "language": "c", "size": 1199}
{"docstring": "// Transformation function for collFuncSet.\n", "func_signal": "static void *\ncollFuncSetTrans(void *ptr, void *data)", "code": "{\n\tunsigned int *ids = (unsigned int *)ptr;\n\tcollFuncData *funcData = (collFuncData *)data;\n\n\tcpCollPairFunc *pair = (cpCollPairFunc *)malloc(sizeof(cpCollPairFunc));\n\tpair->a = ids[0];\n\tpair->b = ids[1];\n\tpair->func = funcData->func;\n\tpair->data = funcData->data;\n\n\treturn pair;\n}", "path": "lib\\Chipmunk-4.1.0\\src\\cpSpace.c", "repo_name": "HamptonMakes/spacebrawl", "stars": 1, "license": "None", "language": "c", "size": 1199}
{"docstring": "// Collide poly shapes together.\n", "func_signal": "static int\npoly2poly(cpShape *shape1, cpShape *shape2, cpContact **arr)", "code": "{\n\tcpPolyShape *poly1 = (cpPolyShape *)shape1;\n\tcpPolyShape *poly2 = (cpPolyShape *)shape2;\n\t\n\tcpFloat min1;\n\tint mini1 = findMSA(poly2, poly1->tAxes, poly1->numVerts, &min1);\n\tif(mini1 == -1) return 0;\n\t\n\tcpFloat min2;\n\tint mini2 = findMSA(poly1, poly2->tAxes, poly2->numVerts, &min2);\n\tif(mini2 == -1) return 0;\n\t\n\t// There is overlap, find the penetrating verts\n\tif(min1 > min2)\n\t\treturn findVerts(arr, poly1, poly2, poly1->tAxes[mini1].n, min1);\n\telse\n\t\treturn findVerts(arr, poly1, poly2, cpvneg(poly2->tAxes[mini2].n), min2);\n}", "path": "lib\\Chipmunk-4.1.0\\ruby\\cpCollision.c", "repo_name": "HamptonMakes/spacebrawl", "stars": 1, "license": "None", "language": "c", "size": 1199}
{"docstring": "// Iterator for active/static hash collisions.\n", "func_signal": "static void\nactive2staticIter(void *ptr, void *data)", "code": "{\n\tcpShape *shape = (cpShape *)ptr;\n\tcpSpace *space = (cpSpace *)data;\n\tcpSpaceHashQuery(space->staticShapes, shape, shape->bb, &queryFunc, space);\n}", "path": "lib\\Chipmunk-4.1.0\\src\\cpSpace.c", "repo_name": "HamptonMakes/spacebrawl", "stars": 1, "license": "None", "language": "c", "size": 1199}
{"docstring": "// Iterator functions for destructors.\n", "func_signal": "static void        freeWrap(void *ptr, void *unused)", "code": "{          free(             ptr);}\nstatic void   shapeFreeWrap(void *ptr, void *unused){   cpShapeFree((cpShape *)  ptr);}\nstatic void arbiterFreeWrap(void *ptr, void *unused){ cpArbiterFree((cpArbiter *)ptr);}\nstatic void    bodyFreeWrap(void *ptr, void *unused){    cpBodyFree((cpBody *)   ptr);}\nstatic void   jointFreeWrap(void *ptr, void *unused){   cpJointFree((cpJoint *)  ptr);}\n\ncpSpace*\ncpSpaceAlloc(void)\n{\n\treturn (cpSpace *)calloc(1, sizeof(cpSpace));\n}", "path": "lib\\Chipmunk-4.1.0\\src\\cpSpace.c", "repo_name": "HamptonMakes/spacebrawl", "stars": 1, "license": "None", "language": "c", "size": 1199}
{"docstring": "// Like cpPolyValueOnAxis(), but for segments.\n", "func_signal": "static inline float\nsegValueOnAxis(cpSegmentShape *seg, cpVect n, cpFloat d)", "code": "{\n\tcpFloat a = cpvdot(n, seg->ta) - seg->r;\n\tcpFloat b = cpvdot(n, seg->tb) - seg->r;\n\treturn cpfmin(a, b) - d;\n}", "path": "lib\\Chipmunk-4.1.0\\ruby\\cpCollision.c", "repo_name": "HamptonMakes/spacebrawl", "stars": 1, "license": "None", "language": "c", "size": 1199}
{"docstring": "//cpPoly\n", "func_signal": "static VALUE\nrb_cpPolyAlloc(VALUE klass)", "code": "{\n\tcpPolyShape *poly = cpPolyShapeAlloc();\n\treturn Data_Wrap_Struct(klass, NULL, cpShapeFree, poly);\n}", "path": "lib\\Chipmunk-4.1.0\\ruby\\rb_cpShape.c", "repo_name": "HamptonMakes/spacebrawl", "stars": 1, "license": "None", "language": "c", "size": 1199}
{"docstring": "// This one is less gross, but still gross.\n// TODO: Comment me!\n", "func_signal": "static int\ncircle2poly(cpShape *shape1, cpShape *shape2, cpContact **con)", "code": "{\n\tcpCircleShape *circ = (cpCircleShape *)shape1;\n\tcpPolyShape *poly = (cpPolyShape *)shape2;\n\tcpPolyShapeAxis *axes = poly->tAxes;\n\t\n\tint mini = 0;\n\tcpFloat min = cpvdot(axes->n, circ->tc) - axes->d - circ->r;\n\tfor(int i=0; i<poly->numVerts; i++){\n\t\tcpFloat dist = cpvdot(axes[i].n, circ->tc) - axes[i].d - circ->r;\n\t\tif(dist > 0.0){\n\t\t\treturn 0;\n\t\t} else if(dist > min) {\n\t\t\tmin = dist;\n\t\t\tmini = i;\n\t\t}\n\t}\n\t\n\tcpVect n = axes[mini].n;\n\tcpVect a = poly->tVerts[mini];\n\tcpVect b = poly->tVerts[(mini + 1)%poly->numVerts];\n\tcpFloat dta = cpvcross(n, a);\n\tcpFloat dtb = cpvcross(n, b);\n\tcpFloat dt = cpvcross(n, circ->tc);\n\t\t\n\tif(dt < dtb){\n\t\treturn circle2circleQuery(circ->tc, b, circ->r, 0.0f, con);\n\t} else if(dt < dta) {\n\t\t(*con) = (cpContact *)malloc(sizeof(cpContact));\n\t\tcpContactInit(\n\t\t\t(*con),\n\t\t\tcpvsub(circ->tc, cpvmult(n, circ->r + min/2.0f)),\n\t\t\tcpvneg(n),\n\t\t\tmin,\n\t\t\t0\t\t\t\t \n\t\t);\n\t\n\t\treturn 1;\n\t} else {\n\t\treturn circle2circleQuery(circ->tc, a, circ->r, 0.0f, con);\n\t}\n}", "path": "lib\\Chipmunk-4.1.0\\ruby\\cpCollision.c", "repo_name": "HamptonMakes/spacebrawl", "stars": 1, "license": "None", "language": "c", "size": 1199}
{"docstring": "//cpCircle\n", "func_signal": "static VALUE\nrb_cpCircleAlloc(VALUE klass)", "code": "{\n\tcpCircleShape *circle = cpCircleShapeAlloc();\n\treturn Data_Wrap_Struct(klass, NULL, cpShapeFree, circle);\n}", "path": "lib\\Chipmunk-4.1.0\\ruby\\rb_cpShape.c", "repo_name": "HamptonMakes/spacebrawl", "stars": 1, "license": "None", "language": "c", "size": 1199}
{"docstring": "// Transformation function for contactSet.\n", "func_signal": "static void *\ncontactSetTrans(void *ptr, void *data)", "code": "{\n\tcpShape **shapes = (cpShape **)ptr;\n\tcpShape *a = shapes[0];\n\tcpShape *b = shapes[1];\n\t\n\tcpSpace *space = (cpSpace *)data;\n\t\n\treturn cpArbiterNew(a, b, space->stamp);\n}", "path": "lib\\Chipmunk-4.1.0\\src\\cpSpace.c", "repo_name": "HamptonMakes/spacebrawl", "stars": 1, "license": "None", "language": "c", "size": 1199}
{"docstring": "// Equal function for contactSet.\n", "func_signal": "static int\ncontactSetEql(void *ptr, void *elt)", "code": "{\n\tcpShape **shapes = (cpShape **)ptr;\n\tcpShape *a = shapes[0];\n\tcpShape *b = shapes[1];\n\t\n\tcpArbiter *arb = (cpArbiter *)elt;\n\t\n\treturn ((a == arb->a && b == arb->b) || (b == arb->a && a == arb->b));\n}", "path": "lib\\Chipmunk-4.1.0\\src\\cpSpace.c", "repo_name": "HamptonMakes/spacebrawl", "stars": 1, "license": "None", "language": "c", "size": 1199}
{"docstring": "// Add contacts for penetrating vertexes.\n", "func_signal": "static inline int\nfindVerts(cpContact **arr, cpPolyShape *poly1, cpPolyShape *poly2, cpVect n, cpFloat dist)", "code": "{\n\tint max = 0;\n\tint num = 0;\n\t\n\tfor(int i=0; i<poly1->numVerts; i++){\n\t\tcpVect v = poly1->tVerts[i];\n\t\tif(cpPolyShapeContainsVertPartial(poly2, v, cpvneg(n)))\n\t\t\tcpContactInit(addContactPoint(arr, &max, &num), v, n, dist, CP_HASH_PAIR(poly1, i));\n\t}\n\t\n\tfor(int i=0; i<poly2->numVerts; i++){\n\t\tcpVect v = poly2->tVerts[i];\n\t\tif(cpPolyShapeContainsVertPartial(poly1, v, n))\n\t\t\tcpContactInit(addContactPoint(arr, &max, &num), v, n, dist, CP_HASH_PAIR(poly2, i));\n\t}\n\t\n\t//\tif(!num)\n\t//\t\taddContactPoint(arr, &size, &num, cpContactNew(shape1->body->p, n, dist, 0));\n\n\treturn num;\n}", "path": "lib\\Chipmunk-4.1.0\\ruby\\cpCollision.c", "repo_name": "HamptonMakes/spacebrawl", "stars": 1, "license": "None", "language": "c", "size": 1199}
