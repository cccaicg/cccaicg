{"docstring": "/*Compute V(_n,_k), as well as U(_n,0..._k+1).\n  _u: On exit, _u[i] contains U(_n,i) for i in [0..._k+1].*/\n", "func_signal": "static opus_uint32 ncwrs_urow(unsigned _n,unsigned _k,opus_uint32 *_u)", "code": "{\n  opus_uint32 um2;\n  unsigned      len;\n  unsigned      k;\n  len=_k+2;\n  /*We require storage at least 3 values (e.g., _k>0).*/\n  celt_assert(len>=3);\n  _u[0]=0;\n  _u[1]=um2=1;\n  /*If _n==0, _u[0] should be 1 and the rest should be 0.*/\n  /*If _n==1, _u[i] should be 1 for i>1.*/\n  celt_assert(_n>=2);\n  /*If _k==0, the following do-while loop will overflow the buffer.*/\n  celt_assert(_k>0);\n  k=2;\n  do _u[k]=(k<<1)-1;\n  while(++k<len);\n  for(k=2;k<_n;k++)unext(_u+1,_k+1,1);\n  return _u[_k]+_u[_k+1];\n}", "path": "opus/celt/cwrs.c", "commit_date": "2018-03-27 00:00:00", "repo_name": "xiph/opus", "stars": 2037, "license": "other", "language": "c", "size": 15204}
{"docstring": "/* CUSTOM_MODES */\n", "func_signal": "int celt_decoder_init(CELTDecoder *st, opus_int32 sampling_rate, int channels)", "code": "{\n   int ret;\n   ret = opus_custom_decoder_init(st, opus_custom_mode_create(48000, 960, NULL), channels);\n   if (ret != OPUS_OK)\n      return ret;\n   st->downsample = resampling_factor(sampling_rate);\n   if (st->downsample==0)\n      return OPUS_BAD_ARG;\n   else\n      return OPUS_OK;\n}", "path": "opus/celt/celt_decoder.c", "commit_date": "2020-04-13 00:00:00", "repo_name": "xiph/opus", "stars": 2037, "license": "other", "language": "c", "size": 15204}
{"docstring": "/* CUSTOM_MODES */\n", "func_signal": "static int opus_custom_encoder_init_arch(CELTEncoder *st, const CELTMode *mode,\n                                         int channels, int arch)", "code": "{\n   if (channels < 0 || channels > 2)\n      return OPUS_BAD_ARG;\n\n   if (st==NULL || mode==NULL)\n      return OPUS_ALLOC_FAIL;\n\n   OPUS_CLEAR((char*)st, opus_custom_encoder_get_size(mode, channels));\n\n   st->mode = mode;\n   st->stream_channels = st->channels = channels;\n\n   st->upsample = 1;\n   st->start = 0;\n   st->end = st->mode->effEBands;\n   st->signalling = 1;\n   st->arch = arch;\n\n   st->constrained_vbr = 1;\n   st->clip = 1;\n\n   st->bitrate = OPUS_BITRATE_MAX;\n   st->vbr = 0;\n   st->force_intra  = 0;\n   st->complexity = 5;\n   st->lsb_depth=24;\n\n   opus_custom_encoder_ctl(st, OPUS_RESET_STATE);\n\n   return OPUS_OK;\n}", "path": "opus/celt/celt_encoder.c", "commit_date": "2020-05-26 00:00:00", "repo_name": "xiph/opus", "stars": 2037, "license": "other", "language": "c", "size": 15204}
{"docstring": "/*Returns the _i'th combination of _k elements chosen from a set of size _n\n   with associated sign bits.\n  _y: Returns the vector of pulses.\n  _u: Must contain entries [0..._k+1] of row _n of U() on input.\n      Its contents will be destructively modified.*/\n", "func_signal": "static opus_val32 cwrsi(int _n,int _k,opus_uint32 _i,int *_y,opus_uint32 *_u)", "code": "{\n  int j;\n  opus_int16 val;\n  opus_val32 yy=0;\n  celt_assert(_n>0);\n  j=0;\n  do{\n    opus_uint32 p;\n    int           s;\n    int           yj;\n    p=_u[_k+1];\n    s=-(_i>=p);\n    _i-=p&s;\n    yj=_k;\n    p=_u[_k];\n    while(p>_i)p=_u[--_k];\n    _i-=p;\n    yj-=_k;\n    val=(yj+s)^s;\n    _y[j]=val;\n    yy=MAC16_16(yy,val,val);\n    uprev(_u,_k+2,0);\n  }\n  while(++j<_n);\n  return yy;\n}", "path": "opus/celt/cwrs.c", "commit_date": "2018-03-27 00:00:00", "repo_name": "xiph/opus", "stars": 2037, "license": "other", "language": "c", "size": 15204}
{"docstring": "/* Looks for sudden increases of energy to decide whether we need to patch\n   the transient decision */\n", "func_signal": "static int patch_transient_decision(opus_val16 *newE, opus_val16 *oldE, int nbEBands,\n      int start, int end, int C)", "code": "{\n   int i, c;\n   opus_val32 mean_diff=0;\n   opus_val16 spread_old[26];\n   /* Apply an aggressive (-6 dB/Bark) spreading function to the old frame to\n      avoid false detection caused by irrelevant bands */\n   if (C==1)\n   {\n      spread_old[start] = oldE[start];\n      for (i=start+1;i<end;i++)\n         spread_old[i] = MAX16(spread_old[i-1]-QCONST16(1.0f, DB_SHIFT), oldE[i]);\n   } else {\n      spread_old[start] = MAX16(oldE[start],oldE[start+nbEBands]);\n      for (i=start+1;i<end;i++)\n         spread_old[i] = MAX16(spread_old[i-1]-QCONST16(1.0f, DB_SHIFT),\n                               MAX16(oldE[i],oldE[i+nbEBands]));\n   }\n   for (i=end-2;i>=start;i--)\n      spread_old[i] = MAX16(spread_old[i], spread_old[i+1]-QCONST16(1.0f, DB_SHIFT));\n   /* Compute mean increase */\n   c=0; do {\n      for (i=IMAX(2,start);i<end-1;i++)\n      {\n         opus_val16 x1, x2;\n         x1 = MAX16(0, newE[i + c*nbEBands]);\n         x2 = MAX16(0, spread_old[i]);\n         mean_diff = ADD32(mean_diff, EXTEND32(MAX16(0, SUB16(x1, x2))));\n      }\n   } while (++c<C);\n   mean_diff = DIV32(mean_diff, C*(end-1-IMAX(2,start)));\n   /*printf(\"%f %f %d\\n\", mean_diff, max_diff, count);*/\n   return mean_diff > QCONST16(1.f, DB_SHIFT);\n}", "path": "opus/celt/celt_encoder.c", "commit_date": "2020-05-26 00:00:00", "repo_name": "xiph/opus", "stars": 2037, "license": "other", "language": "c", "size": 15204}
{"docstring": "/* CUSTOM_MODES */\n", "func_signal": "static int transient_analysis(const opus_val32 * OPUS_RESTRICT in, int len, int C,\n                              opus_val16 *tf_estimate, int *tf_chan, int allow_weak_transients,\n                              int *weak_transient)", "code": "{\n   int i;\n   VARDECL(opus_val16, tmp);\n   opus_val32 mem0,mem1;\n   int is_transient = 0;\n   opus_int32 mask_metric = 0;\n   int c;\n   opus_val16 tf_max;\n   int len2;\n   /* Forward masking: 6.7 dB/ms. */\n#ifdef FIXED_POINT\n   int forward_shift = 4;\n#else\n   opus_val16 forward_decay = QCONST16(.0625f,15);\n#endif\n   /* Table of 6*64/x, trained on real data to minimize the average error */\n   static const unsigned char inv_table[128] = {\n         255,255,156,110, 86, 70, 59, 51, 45, 40, 37, 33, 31, 28, 26, 25,\n          23, 22, 21, 20, 19, 18, 17, 16, 16, 15, 15, 14, 13, 13, 12, 12,\n          12, 12, 11, 11, 11, 10, 10, 10,  9,  9,  9,  9,  9,  9,  8,  8,\n           8,  8,  8,  7,  7,  7,  7,  7,  7,  6,  6,  6,  6,  6,  6,  6,\n           6,  6,  6,  6,  6,  6,  6,  6,  6,  5,  5,  5,  5,  5,  5,  5,\n           5,  5,  5,  5,  5,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,\n           4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  3,  3,\n           3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  2,\n   };\n   SAVE_STACK;\n   ALLOC(tmp, len, opus_val16);\n\n   *weak_transient = 0;\n   /* For lower bitrates, let's be more conservative and have a forward masking\n      decay of 3.3 dB/ms. This avoids having to code transients at very low\n      bitrate (mostly for hybrid), which can result in unstable energy and/or\n      partial collapse. */\n   if (allow_weak_transients)\n   {\n#ifdef FIXED_POINT\n      forward_shift = 5;\n#else\n      forward_decay = QCONST16(.03125f,15);\n#endif\n   }\n   len2=len/2;\n   for (c=0;c<C;c++)\n   {\n      opus_val32 mean;\n      opus_int32 unmask=0;\n      opus_val32 norm;\n      opus_val16 maxE;\n      mem0=0;\n      mem1=0;\n      /* High-pass filter: (1 - 2*z^-1 + z^-2) / (1 - z^-1 + .5*z^-2) */\n      for (i=0;i<len;i++)\n      {\n         opus_val32 x,y;\n         x = SHR32(in[i+c*len],SIG_SHIFT);\n         y = ADD32(mem0, x);\n#ifdef FIXED_POINT\n         mem0 = mem1 + y - SHL32(x,1);\n         mem1 = x - SHR32(y,1);\n#else\n         mem0 = mem1 + y - 2*x;\n         mem1 = x - .5f*y;\n#endif\n         tmp[i] = SROUND16(y, 2);\n         /*printf(\"%f \", tmp[i]);*/\n      }\n      /*printf(\"\\n\");*/\n      /* First few samples are bad because we don't propagate the memory */\n      OPUS_CLEAR(tmp, 12);\n\n#ifdef FIXED_POINT\n      /* Normalize tmp to max range */\n      {\n         int shift=0;\n         shift = 14-celt_ilog2(MAX16(1, celt_maxabs16(tmp, len)));\n         if (shift!=0)\n         {\n            for (i=0;i<len;i++)\n               tmp[i] = SHL16(tmp[i], shift);\n         }\n      }\n#endif\n\n      mean=0;\n      mem0=0;\n      /* Grouping by two to reduce complexity */\n      /* Forward pass to compute the post-echo threshold*/\n      for (i=0;i<len2;i++)\n      {\n         opus_val16 x2 = PSHR32(MULT16_16(tmp[2*i],tmp[2*i]) + MULT16_16(tmp[2*i+1],tmp[2*i+1]),16);\n         mean += x2;\n#ifdef FIXED_POINT\n         /* FIXME: Use PSHR16() instead */\n         tmp[i] = mem0 + PSHR32(x2-mem0,forward_shift);\n#else\n         tmp[i] = mem0 + MULT16_16_P15(forward_decay,x2-mem0);\n#endif\n         mem0 = tmp[i];\n      }\n\n      mem0=0;\n      maxE=0;\n      /* Backward pass to compute the pre-echo threshold */\n      for (i=len2-1;i>=0;i--)\n      {\n         /* Backward masking: 13.9 dB/ms. */\n#ifdef FIXED_POINT\n         /* FIXME: Use PSHR16() instead */\n         tmp[i] = mem0 + PSHR32(tmp[i]-mem0,3);\n#else\n         tmp[i] = mem0 + MULT16_16_P15(QCONST16(0.125f,15),tmp[i]-mem0);\n#endif\n         mem0 = tmp[i];\n         maxE = MAX16(maxE, mem0);\n      }\n      /*for (i=0;i<len2;i++)printf(\"%f \", tmp[i]/mean);printf(\"\\n\");*/\n\n      /* Compute the ratio of the \"frame energy\" over the harmonic mean of the energy.\n         This essentially corresponds to a bitrate-normalized temporal noise-to-mask\n         ratio */\n\n      /* As a compromise with the old transient detector, frame energy is the\n         geometric mean of the energy and half the max */\n#ifdef FIXED_POINT\n      /* Costs two sqrt() to avoid overflows */\n      mean = MULT16_16(celt_sqrt(mean), celt_sqrt(MULT16_16(maxE,len2>>1)));\n#else\n      mean = celt_sqrt(mean * maxE*.5*len2);\n#endif\n      /* Inverse of the mean energy in Q15+6 */\n      norm = SHL32(EXTEND32(len2),6+14)/ADD32(EPSILON,SHR32(mean,1));\n      /* Compute harmonic mean discarding the unreliable boundaries\n         The data is smooth, so we only take 1/4th of the samples */\n      unmask=0;\n      /* We should never see NaNs here. If we find any, then something really bad happened and we better abort\n         before it does any damage later on. If these asserts are disabled (no hardening), then the table\n         lookup a few lines below (id = ...) is likely to crash dur to an out-of-bounds read. DO NOT FIX\n         that crash on NaN since it could result in a worse issue later on. */\n      celt_assert(!celt_isnan(tmp[0]));\n      celt_assert(!celt_isnan(norm));\n      for (i=12;i<len2-5;i+=4)\n      {\n         int id;\n#ifdef FIXED_POINT\n         id = MAX32(0,MIN32(127,MULT16_32_Q15(tmp[i]+EPSILON,norm))); /* Do not round to nearest */\n#else\n         id = (int)MAX32(0,MIN32(127,floor(64*norm*(tmp[i]+EPSILON)))); /* Do not round to nearest */\n#endif\n         unmask += inv_table[id];\n      }\n      /*printf(\"%d\\n\", unmask);*/\n      /* Normalize, compensate for the 1/4th of the sample and the factor of 6 in the inverse table */\n      unmask = 64*unmask*4/(6*(len2-17));\n      if (unmask>mask_metric)\n      {\n         *tf_chan = c;\n         mask_metric = unmask;\n      }\n   }\n   is_transient = mask_metric>200;\n   /* For low bitrates, define \"weak transients\" that need to be\n      handled differently to avoid partial collapse. */\n   if (allow_weak_transients && is_transient && mask_metric<600) {\n      is_transient = 0;\n      *weak_transient = 1;\n   }\n   /* Arbitrary metric for VBR boost */\n   tf_max = MAX16(0,celt_sqrt(27*mask_metric)-42);\n   /* *tf_estimate = 1 + MIN16(1, sqrt(MAX16(0, tf_max-30))/20); */\n   *tf_estimate = celt_sqrt(MAX32(0, SHL32(MULT16_16(QCONST16(0.0069,14),MIN16(163,tf_max)),14)-QCONST32(0.139,28)));\n   /*printf(\"%d %f\\n\", tf_max, mask_metric);*/\n   RESTORE_STACK;\n#ifdef FUZZING\n   is_transient = rand()&0x1;\n#endif\n   /*printf(\"%d %f %d\\n\", is_transient, (float)*tf_estimate, tf_max);*/\n   return is_transient;\n}", "path": "opus/celt/celt_encoder.c", "commit_date": "2020-05-26 00:00:00", "repo_name": "xiph/opus", "stars": 2037, "license": "other", "language": "c", "size": 15204}
{"docstring": "/** Apply window and compute the MDCT for all sub-frames and\n    all channels in a frame */\n", "func_signal": "static void compute_mdcts(const CELTMode *mode, int shortBlocks, celt_sig * OPUS_RESTRICT in,\n                          celt_sig * OPUS_RESTRICT out, int C, int CC, int LM, int upsample,\n                          int arch)", "code": "{\n   const int overlap = mode->overlap;\n   int N;\n   int B;\n   int shift;\n   int i, b, c;\n   if (shortBlocks)\n   {\n      B = shortBlocks;\n      N = mode->shortMdctSize;\n      shift = mode->maxLM;\n   } else {\n      B = 1;\n      N = mode->shortMdctSize<<LM;\n      shift = mode->maxLM-LM;\n   }\n   c=0; do {\n      for (b=0;b<B;b++)\n      {\n         /* Interleaving the sub-frames while doing the MDCTs */\n         clt_mdct_forward(&mode->mdct, in+c*(B*N+overlap)+b*N,\n                          &out[b+c*N*B], mode->window, overlap, shift, B,\n                          arch);\n      }\n   } while (++c<CC);\n   if (CC==2&&C==1)\n   {\n      for (i=0;i<B*N;i++)\n         out[i] = ADD32(HALF32(out[i]), HALF32(out[B*N+i]));\n   }\n   if (upsample != 1)\n   {\n      c=0; do\n      {\n         int bound = B*N/upsample;\n         for (i=0;i<bound;i++)\n            out[c*B*N+i] *= upsample;\n         OPUS_CLEAR(&out[c*B*N+bound], B*N-bound);\n      } while (++c<C);\n   }\n}", "path": "opus/celt/celt_encoder.c", "commit_date": "2020-05-26 00:00:00", "repo_name": "xiph/opus", "stars": 2037, "license": "other", "language": "c", "size": 15204}
{"docstring": "/* This test exercises the heck out of the libopus parser.\n   It is much larger than the parser itself in part because\n   it tries to hit a lot of corner cases that could never\n   fail with the libopus code, but might be problematic for\n   other implementations. */\n", "func_signal": "opus_int32 test_parse(void)", "code": "{\n   opus_int32 i,j,jj,sz;\n   unsigned char packet[1276];\n   opus_int32 cfgs,cfgs_total;\n   unsigned char toc;\n   const unsigned char *frames[48];\n   short size[48];\n   int payload_offset, ret;\n   fprintf(stdout,\"\\n  Packet header parsing tests\\n\");\n   fprintf(stdout,\"  ---------------------------------------------------\\n\");\n   memset(packet,0,sizeof(char)*1276);\n   packet[0]=63<<2;\n   if(opus_packet_parse(packet,1,&toc,frames,0,&payload_offset)!=OPUS_BAD_ARG)test_failed();\n   cfgs_total=cfgs=1;\n   /*code 0*/\n   for(i=0;i<64;i++)\n   {\n      packet[0]=i<<2;\n      UNDEFINE_FOR_PARSE\n      ret=opus_packet_parse(packet,4,&toc,frames,size,&payload_offset);\n      cfgs++;\n      if(ret!=1)test_failed();\n      if(size[0]!=3)test_failed();\n      if(frames[0]!=packet+1)test_failed();\n   }\n   fprintf(stdout,\"    code 0 (%2d cases) ............................ OK.\\n\",cfgs);\n   cfgs_total+=cfgs;cfgs=0;\n\n   /*code 1, two frames of the same size*/\n   for(i=0;i<64;i++)\n   {\n      packet[0]=(i<<2)+1;\n      for(jj=0;jj<=1275*2+3;jj++)\n      {\n         UNDEFINE_FOR_PARSE\n         ret=opus_packet_parse(packet,jj,&toc,frames,size,&payload_offset);\n         cfgs++;\n         if((jj&1)==1 && jj<=2551)\n         {\n            /* Must pass if payload length even (packet length odd) and\n               size<=2551, must fail otherwise. */\n            if(ret!=2)test_failed();\n            if(size[0]!=size[1] || size[0]!=((jj-1)>>1))test_failed();\n            if(frames[0]!=packet+1)test_failed();\n            if(frames[1]!=frames[0]+size[0])test_failed();\n            if((toc>>2)!=i)test_failed();\n         } else if(ret!=OPUS_INVALID_PACKET)test_failed();\n      }\n   }\n   fprintf(stdout,\"    code 1 (%6d cases) ........................ OK.\\n\",cfgs);\n   cfgs_total+=cfgs;cfgs=0;\n\n   for(i=0;i<64;i++)\n   {\n      /*code 2, length code overflow*/\n      packet[0]=(i<<2)+2;\n      UNDEFINE_FOR_PARSE\n      ret=opus_packet_parse(packet,1,&toc,frames,size,&payload_offset);\n      cfgs++;\n      if(ret!=OPUS_INVALID_PACKET)test_failed();\n      packet[1]=252;\n      UNDEFINE_FOR_PARSE\n      ret=opus_packet_parse(packet,2,&toc,frames,size,&payload_offset);\n      cfgs++;\n      if(ret!=OPUS_INVALID_PACKET)test_failed();\n      for(j=0;j<1275;j++)\n      {\n         if(j<252)packet[1]=j;\n         else{packet[1]=252+(j&3);packet[2]=(j-252)>>2;}\n         /*Code 2, one too short*/\n         UNDEFINE_FOR_PARSE\n         ret=opus_packet_parse(packet,j+(j<252?2:3)-1,&toc,frames,size,&payload_offset);\n         cfgs++;\n         if(ret!=OPUS_INVALID_PACKET)test_failed();\n         /*Code 2, one too long*/\n         UNDEFINE_FOR_PARSE\n         ret=opus_packet_parse(packet,j+(j<252?2:3)+1276,&toc,frames,size,&payload_offset);\n         cfgs++;\n         if(ret!=OPUS_INVALID_PACKET)test_failed();\n         /*Code 2, second zero*/\n         UNDEFINE_FOR_PARSE\n         ret=opus_packet_parse(packet,j+(j<252?2:3),&toc,frames,size,&payload_offset);\n         cfgs++;\n         if(ret!=2)test_failed();\n         if(size[0]!=j||size[1]!=0)test_failed();\n         if(frames[1]!=frames[0]+size[0])test_failed();\n         if((toc>>2)!=i)test_failed();\n         /*Code 2, normal*/\n         UNDEFINE_FOR_PARSE\n         ret=opus_packet_parse(packet,(j<<1)+4,&toc,frames,size,&payload_offset);\n         cfgs++;\n         if(ret!=2)test_failed();\n         if(size[0]!=j||size[1]!=(j<<1)+3-j-(j<252?1:2))test_failed();\n         if(frames[1]!=frames[0]+size[0])test_failed();\n         if((toc>>2)!=i)test_failed();\n      }\n   }\n   fprintf(stdout,\"    code 2 (%6d cases) ........................ OK.\\n\",cfgs);\n   cfgs_total+=cfgs;cfgs=0;\n\n   for(i=0;i<64;i++)\n   {\n      packet[0]=(i<<2)+3;\n      /*code 3, length code overflow*/\n      UNDEFINE_FOR_PARSE\n      ret=opus_packet_parse(packet,1,&toc,frames,size,&payload_offset);\n      cfgs++;\n      if(ret!=OPUS_INVALID_PACKET)test_failed();\n   }\n   fprintf(stdout,\"    code 3 m-truncation (%2d cases) ............... OK.\\n\",cfgs);\n   cfgs_total+=cfgs;cfgs=0;\n\n   for(i=0;i<64;i++)\n   {\n      /*code 3, m is zero or 49-63*/\n      packet[0]=(i<<2)+3;\n      for(jj=49;jj<=64;jj++)\n      {\n        packet[1]=0+(jj&63); /*CBR, no padding*/\n        UNDEFINE_FOR_PARSE\n        ret=opus_packet_parse(packet,1275,&toc,frames,size,&payload_offset);\n        cfgs++;\n        if(ret!=OPUS_INVALID_PACKET)test_failed();\n        packet[1]=128+(jj&63); /*VBR, no padding*/\n        UNDEFINE_FOR_PARSE\n        ret=opus_packet_parse(packet,1275,&toc,frames,size,&payload_offset);\n        cfgs++;\n        if(ret!=OPUS_INVALID_PACKET)test_failed();\n        packet[1]=64+(jj&63); /*CBR, padding*/\n        UNDEFINE_FOR_PARSE\n        ret=opus_packet_parse(packet,1275,&toc,frames,size,&payload_offset);\n        cfgs++;\n        if(ret!=OPUS_INVALID_PACKET)test_failed();\n        packet[1]=128+64+(jj&63); /*VBR, padding*/\n        UNDEFINE_FOR_PARSE\n        ret=opus_packet_parse(packet,1275,&toc,frames,size,&payload_offset);\n        cfgs++;\n        if(ret!=OPUS_INVALID_PACKET)test_failed();\n      }\n   }\n   fprintf(stdout,\"    code 3 m=0,49-64 (%2d cases) ................ OK.\\n\",cfgs);\n   cfgs_total+=cfgs;cfgs=0;\n\n   for(i=0;i<64;i++)\n   {\n      packet[0]=(i<<2)+3;\n      /*code 3, m is one, cbr*/\n      packet[1]=1;\n      for(j=0;j<1276;j++)\n      {\n        UNDEFINE_FOR_PARSE\n        ret=opus_packet_parse(packet,j+2,&toc,frames,size,&payload_offset);\n        cfgs++;\n        if(ret!=1)test_failed();\n        if(size[0]!=j)test_failed();\n        if((toc>>2)!=i)test_failed();\n      }\n      UNDEFINE_FOR_PARSE\n      ret=opus_packet_parse(packet,1276+2,&toc,frames,size,&payload_offset);\n      cfgs++;\n      if(ret!=OPUS_INVALID_PACKET)test_failed();\n   }\n   fprintf(stdout,\"    code 3 m=1 CBR (%2d cases) ................. OK.\\n\",cfgs);\n   cfgs_total+=cfgs;cfgs=0;\n\n   for(i=0;i<64;i++)\n   {\n      int frame_samp;\n      /*code 3, m>1 CBR*/\n      packet[0]=(i<<2)+3;\n      frame_samp=opus_packet_get_samples_per_frame(packet,48000);\n      for(j=2;j<49;j++)\n      {\n         packet[1]=j;\n         for(sz=2;sz<((j+2)*1275);sz++)\n         {\n            UNDEFINE_FOR_PARSE\n            ret=opus_packet_parse(packet,sz,&toc,frames,size,&payload_offset);\n            cfgs++;\n            /*Must be <=120ms, must be evenly divisible, can't have frames>1275 bytes*/\n            if(frame_samp*j<=5760 && (sz-2)%j==0 && (sz-2)/j<1276)\n            {\n               if(ret!=j)test_failed();\n               for(jj=1;jj<ret;jj++)if(frames[jj]!=frames[jj-1]+size[jj-1])test_failed();\n               if((toc>>2)!=i)test_failed();\n            } else if(ret!=OPUS_INVALID_PACKET)test_failed();\n         }\n      }\n      /*Super jumbo packets*/\n      packet[1]=5760/frame_samp;\n      UNDEFINE_FOR_PARSE\n      ret=opus_packet_parse(packet,1275*packet[1]+2,&toc,frames,size,&payload_offset);\n      cfgs++;\n      if(ret!=packet[1])test_failed();\n      for(jj=0;jj<ret;jj++)if(size[jj]!=1275)test_failed();\n   }\n   fprintf(stdout,\"    code 3 m=1-48 CBR (%2d cases) .......... OK.\\n\",cfgs);\n   cfgs_total+=cfgs;cfgs=0;\n\n   for(i=0;i<64;i++)\n   {\n      int frame_samp;\n      /*Code 3 VBR, m one*/\n      packet[0]=(i<<2)+3;\n      packet[1]=128+1;\n      frame_samp=opus_packet_get_samples_per_frame(packet,48000);\n      for(jj=0;jj<1276;jj++)\n      {\n         UNDEFINE_FOR_PARSE\n         ret=opus_packet_parse(packet,2+jj,&toc,frames,size,&payload_offset);\n         cfgs++;\n         if(ret!=1)test_failed();\n         if(size[0]!=jj)test_failed();\n         if((toc>>2)!=i)test_failed();\n      }\n      UNDEFINE_FOR_PARSE\n      ret=opus_packet_parse(packet,2+1276,&toc,frames,size,&payload_offset);\n      cfgs++;\n      if(ret!=OPUS_INVALID_PACKET)test_failed();\n      for(j=2;j<49;j++)\n      {\n         packet[1]=128+j;\n         /*Length code overflow*/\n         UNDEFINE_FOR_PARSE\n         ret=opus_packet_parse(packet,2+j-2,&toc,frames,size,&payload_offset);\n         cfgs++;\n         if(ret!=OPUS_INVALID_PACKET)test_failed();\n         packet[2]=252;\n         packet[3]=0;\n         for(jj=4;jj<2+j;jj++)packet[jj]=0;\n         UNDEFINE_FOR_PARSE\n         ret=opus_packet_parse(packet,2+j,&toc,frames,size,&payload_offset);\n         cfgs++;\n         if(ret!=OPUS_INVALID_PACKET)test_failed();\n         /*One byte too short*/\n         for(jj=2;jj<2+j;jj++)packet[jj]=0;\n         UNDEFINE_FOR_PARSE\n         ret=opus_packet_parse(packet,2+j-2,&toc,frames,size,&payload_offset);\n         cfgs++;\n         if(ret!=OPUS_INVALID_PACKET)test_failed();\n         /*One byte too short thanks to length coding*/\n         packet[2]=252;\n         packet[3]=0;\n         for(jj=4;jj<2+j;jj++)packet[jj]=0;\n         UNDEFINE_FOR_PARSE\n         ret=opus_packet_parse(packet,2+j+252-1,&toc,frames,size,&payload_offset);\n         cfgs++;\n         if(ret!=OPUS_INVALID_PACKET)test_failed();\n         /*Most expensive way of coding zeros*/\n         for(jj=2;jj<2+j;jj++)packet[jj]=0;\n         UNDEFINE_FOR_PARSE\n         ret=opus_packet_parse(packet,2+j-1,&toc,frames,size,&payload_offset);\n         cfgs++;\n         if(frame_samp*j<=5760){\n            if(ret!=j)test_failed();\n            for(jj=0;jj<j;jj++)if(size[jj]!=0)test_failed();\n            if((toc>>2)!=i)test_failed();\n         } else if(ret!=OPUS_INVALID_PACKET)test_failed();\n         /*Quasi-CBR use of mode 3*/\n         for(sz=0;sz<8;sz++)\n         {\n            const int tsz[8]={50,201,403,700,1472,5110,20400,61298};\n            int pos=0;\n            int as=(tsz[sz]+i-j-2)/j;\n            for(jj=0;jj<j-1;jj++)\n            {\n              if(as<252){packet[2+pos]=as;pos++;}\n              else{packet[2+pos]=252+(as&3);packet[3+pos]=(as-252)>>2;pos+=2;}\n            }\n            UNDEFINE_FOR_PARSE\n            ret=opus_packet_parse(packet,tsz[sz]+i,&toc,frames,size,&payload_offset);\n            cfgs++;\n            if(frame_samp*j<=5760 && as<1276 && (tsz[sz]+i-2-pos-as*(j-1))<1276){\n               if(ret!=j)test_failed();\n               for(jj=0;jj<j-1;jj++)if(size[jj]!=as)test_failed();\n               if(size[j-1]!=(tsz[sz]+i-2-pos-as*(j-1)))test_failed();\n               if((toc>>2)!=i)test_failed();\n            } else if(ret!=OPUS_INVALID_PACKET)test_failed();\n         }\n      }\n   }\n   fprintf(stdout,\"    code 3 m=1-48 VBR (%2d cases) ............. OK.\\n\",cfgs);\n   cfgs_total+=cfgs;cfgs=0;\n\n   for(i=0;i<64;i++)\n   {\n      packet[0]=(i<<2)+3;\n      /*Padding*/\n      packet[1]=128+1+64;\n      /*Overflow the length coding*/\n      for(jj=2;jj<127;jj++)packet[jj]=255;\n      UNDEFINE_FOR_PARSE\n      ret=opus_packet_parse(packet,127,&toc,frames,size,&payload_offset);\n      cfgs++;\n      if(ret!=OPUS_INVALID_PACKET)test_failed();\n\n      for(sz=0;sz<4;sz++)\n      {\n         const int tsz[4]={0,72,512,1275};\n         for(jj=sz;jj<65025;jj+=11)\n         {\n            int pos;\n            for(pos=0;pos<jj/254;pos++)packet[2+pos]=255;\n            packet[2+pos]=jj%254;\n            pos++;\n            if(sz==0&&i==63)\n            {\n               /*Code more padding than there is room in the packet*/\n               UNDEFINE_FOR_PARSE\n               ret=opus_packet_parse(packet,2+jj+pos-1,&toc,frames,size,&payload_offset);\n               cfgs++;\n               if(ret!=OPUS_INVALID_PACKET)test_failed();\n            }\n            UNDEFINE_FOR_PARSE\n            ret=opus_packet_parse(packet,2+jj+tsz[sz]+i+pos,&toc,frames,size,&payload_offset);\n            cfgs++;\n            if(tsz[sz]+i<1276)\n            {\n               if(ret!=1)test_failed();\n               if(size[0]!=tsz[sz]+i)test_failed();\n               if((toc>>2)!=i)test_failed();\n            } else if (ret!=OPUS_INVALID_PACKET)test_failed();\n         }\n      }\n   }\n   fprintf(stdout,\"    code 3 padding (%2d cases) ............... OK.\\n\",cfgs);\n   cfgs_total+=cfgs;\n   fprintf(stdout,\"    opus_packet_parse ............................ OK.\\n\");\n   fprintf(stdout,\"                      All packet parsing tests passed\\n\");\n   fprintf(stdout,\"                          (%d API invocations)\\n\",cfgs_total);\n   return cfgs_total;\n}", "path": "opus/tests/test_opus_api.c", "commit_date": "2018-07-22 00:00:00", "repo_name": "xiph/opus", "stars": 2037, "license": "other", "language": "c", "size": 15204}
{"docstring": "/*Returns the index of the given combination of K elements chosen from a set\n   of size _n with associated sign bits.\n  _y:  The vector of pulses, whose sum of absolute values must be _k.\n  _nc: Returns V(_n,_k).*/\n", "func_signal": "static OPUS_INLINE opus_uint32 icwrs(int _n,int _k,opus_uint32 *_nc,const int *_y,\n opus_uint32 *_u)", "code": "{\n  opus_uint32 i;\n  int         j;\n  int         k;\n  /*We can't unroll the first two iterations of the loop unless _n>=2.*/\n  celt_assert(_n>=2);\n  _u[0]=0;\n  for(k=1;k<=_k+1;k++)_u[k]=(k<<1)-1;\n  i=icwrs1(_y+_n-1,&k);\n  j=_n-2;\n  i+=_u[k];\n  k+=abs(_y[j]);\n  if(_y[j]<0)i+=_u[k+1];\n  while(j-->0){\n    unext(_u,_k+2,0);\n    i+=_u[k];\n    k+=abs(_y[j]);\n    if(_y[j]<0)i+=_u[k+1];\n  }\n  *_nc=_u[k]+_u[k+1];\n  return i;\n}", "path": "opus/celt/cwrs.c", "commit_date": "2018-03-27 00:00:00", "repo_name": "xiph/opus", "stars": 2037, "license": "other", "language": "c", "size": 15204}
{"docstring": "/*The probability of having a \"one\" is 1/(1<<_logp).*/\n", "func_signal": "int ec_dec_bit_logp(ec_dec *_this,unsigned _logp)", "code": "{\n  opus_uint32 r;\n  opus_uint32 d;\n  opus_uint32 s;\n  int         ret;\n  r=_this->rng;\n  d=_this->val;\n  s=r>>_logp;\n  ret=d<s;\n  if(!ret)_this->val=d-s;\n  _this->rng=ret?s:r-s;\n  ec_dec_normalize(_this);\n  return ret;\n}", "path": "opus/celt/entdec.c", "commit_date": "2014-01-20 00:00:00", "repo_name": "xiph/opus", "stars": 2037, "license": "other", "language": "c", "size": 15204}
{"docstring": "/*Computes the next row/column of any recurrence that obeys the relation\n   u[i][j]=u[i-1][j]+u[i][j-1]+u[i-1][j-1].\n  _ui0 is the base case for the new row/column.*/\n", "func_signal": "static OPUS_INLINE void unext(opus_uint32 *_ui,unsigned _len,opus_uint32 _ui0)", "code": "{\n  opus_uint32 ui1;\n  unsigned      j;\n  /*This do-while will overrun the array if we don't have storage for at least\n     2 values.*/\n  j=1; do {\n    ui1=UADD32(UADD32(_ui[j],_ui[j-1]),_ui0);\n    _ui[j-1]=_ui0;\n    _ui0=ui1;\n  } while (++j<_len);\n  _ui[j-1]=_ui0;\n}", "path": "opus/celt/cwrs.c", "commit_date": "2018-03-27 00:00:00", "repo_name": "xiph/opus", "stars": 2037, "license": "other", "language": "c", "size": 15204}
{"docstring": "/* Special case for stereo with no downsampling and no accumulation. This is\n   quite common and we can make it faster by processing both channels in the\n   same loop, reducing overhead due to the dependency loop in the IIR filter. */\n", "func_signal": "static void deemphasis_stereo_simple(celt_sig *in[], opus_val16 *pcm, int N, const opus_val16 coef0,\n      celt_sig *mem)", "code": "{\n   celt_sig * OPUS_RESTRICT x0;\n   celt_sig * OPUS_RESTRICT x1;\n   celt_sig m0, m1;\n   int j;\n   x0=in[0];\n   x1=in[1];\n   m0 = mem[0];\n   m1 = mem[1];\n   for (j=0;j<N;j++)\n   {\n      celt_sig tmp0, tmp1;\n      /* Add VERY_SMALL to x[] first to reduce dependency chain. */\n      tmp0 = x0[j] + VERY_SMALL + m0;\n      tmp1 = x1[j] + VERY_SMALL + m1;\n      m0 = MULT16_32_Q15(coef0, tmp0);\n      m1 = MULT16_32_Q15(coef0, tmp1);\n      pcm[2*j  ] = SCALEOUT(SIG2WORD16(tmp0));\n      pcm[2*j+1] = SCALEOUT(SIG2WORD16(tmp1));\n   }\n   mem[0] = m0;\n   mem[1] = m1;\n}", "path": "opus/celt/celt_decoder.c", "commit_date": "2020-04-13 00:00:00", "repo_name": "xiph/opus", "stars": 2037, "license": "other", "language": "c", "size": 15204}
{"docstring": "/* CUSTOM_MODES */\n", "func_signal": "void encode_pulses(const int *_y,int _n,int _k,ec_enc *_enc)", "code": "{\n  opus_uint32 i;\n  VARDECL(opus_uint32,u);\n  opus_uint32 nc;\n  SAVE_STACK;\n  celt_assert(_k>0);\n  ALLOC(u,_k+2U,opus_uint32);\n  i=icwrs(_n,_k,&nc,_y,u);\n  ec_enc_uint(_enc,i,nc);\n  RESTORE_STACK;\n}", "path": "opus/celt/cwrs.c", "commit_date": "2018-03-27 00:00:00", "repo_name": "xiph/opus", "stars": 2037, "license": "other", "language": "c", "size": 15204}
{"docstring": "/*Normalizes the contents of val and rng so that rng lies entirely in the\n   high-order symbol.*/\n", "func_signal": "static void ec_dec_normalize(ec_dec *_this)", "code": "{\n  /*If the range is too small, rescale it and input some bits.*/\n  while(_this->rng<=EC_CODE_BOT){\n    int sym;\n    _this->nbits_total+=EC_SYM_BITS;\n    _this->rng<<=EC_SYM_BITS;\n    /*Use up the remaining bits from our last symbol.*/\n    sym=_this->rem;\n    /*Read the next value from the input.*/\n    _this->rem=ec_read_byte(_this);\n    /*Take the rest of the bits we need from this new symbol.*/\n    sym=(sym<<EC_SYM_BITS|_this->rem)>>(EC_SYM_BITS-EC_CODE_EXTRA);\n    /*And subtract them from val, capped to be less than EC_CODE_TOP.*/\n    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);\n  }\n}", "path": "opus/celt/entdec.c", "commit_date": "2014-01-20 00:00:00", "repo_name": "xiph/opus", "stars": 2037, "license": "other", "language": "c", "size": 15204}
{"docstring": "/* CUSTOM_MODES */\n", "func_signal": "int opus_custom_decoder_ctl(CELTDecoder * OPUS_RESTRICT st, int request, ...)", "code": "{\n   va_list ap;\n\n   va_start(ap, request);\n   switch (request)\n   {\n      case CELT_SET_START_BAND_REQUEST:\n      {\n         opus_int32 value = va_arg(ap, opus_int32);\n         if (value<0 || value>=st->mode->nbEBands)\n            goto bad_arg;\n         st->start = value;\n      }\n      break;\n      case CELT_SET_END_BAND_REQUEST:\n      {\n         opus_int32 value = va_arg(ap, opus_int32);\n         if (value<1 || value>st->mode->nbEBands)\n            goto bad_arg;\n         st->end = value;\n      }\n      break;\n      case CELT_SET_CHANNELS_REQUEST:\n      {\n         opus_int32 value = va_arg(ap, opus_int32);\n         if (value<1 || value>2)\n            goto bad_arg;\n         st->stream_channels = value;\n      }\n      break;\n      case CELT_GET_AND_CLEAR_ERROR_REQUEST:\n      {\n         opus_int32 *value = va_arg(ap, opus_int32*);\n         if (value==NULL)\n            goto bad_arg;\n         *value=st->error;\n         st->error = 0;\n      }\n      break;\n      case OPUS_GET_LOOKAHEAD_REQUEST:\n      {\n         opus_int32 *value = va_arg(ap, opus_int32*);\n         if (value==NULL)\n            goto bad_arg;\n         *value = st->overlap/st->downsample;\n      }\n      break;\n      case OPUS_RESET_STATE:\n      {\n         int i;\n         opus_val16 *lpc, *oldBandE, *oldLogE, *oldLogE2;\n         lpc = (opus_val16*)(st->_decode_mem+(DECODE_BUFFER_SIZE+st->overlap)*st->channels);\n         oldBandE = lpc+st->channels*LPC_ORDER;\n         oldLogE = oldBandE + 2*st->mode->nbEBands;\n         oldLogE2 = oldLogE + 2*st->mode->nbEBands;\n         OPUS_CLEAR((char*)&st->DECODER_RESET_START,\n               opus_custom_decoder_get_size(st->mode, st->channels)-\n               ((char*)&st->DECODER_RESET_START - (char*)st));\n         for (i=0;i<2*st->mode->nbEBands;i++)\n            oldLogE[i]=oldLogE2[i]=-QCONST16(28.f,DB_SHIFT);\n         st->skip_plc = 1;\n      }\n      break;\n      case OPUS_GET_PITCH_REQUEST:\n      {\n         opus_int32 *value = va_arg(ap, opus_int32*);\n         if (value==NULL)\n            goto bad_arg;\n         *value = st->postfilter_period;\n      }\n      break;\n      case CELT_GET_MODE_REQUEST:\n      {\n         const CELTMode ** value = va_arg(ap, const CELTMode**);\n         if (value==0)\n            goto bad_arg;\n         *value=st->mode;\n      }\n      break;\n      case CELT_SET_SIGNALLING_REQUEST:\n      {\n         opus_int32 value = va_arg(ap, opus_int32);\n         st->signalling = value;\n      }\n      break;\n      case OPUS_GET_FINAL_RANGE_REQUEST:\n      {\n         opus_uint32 * value = va_arg(ap, opus_uint32 *);\n         if (value==0)\n            goto bad_arg;\n         *value=st->rng;\n      }\n      break;\n      case OPUS_SET_PHASE_INVERSION_DISABLED_REQUEST:\n      {\n          opus_int32 value = va_arg(ap, opus_int32);\n          if(value<0 || value>1)\n          {\n             goto bad_arg;\n          }\n          st->disable_inv = value;\n      }\n      break;\n      case OPUS_GET_PHASE_INVERSION_DISABLED_REQUEST:\n      {\n          opus_int32 *value = va_arg(ap, opus_int32*);\n          if (!value)\n          {\n             goto bad_arg;\n          }\n          *value = st->disable_inv;\n      }\n      break;\n      default:\n         goto bad_request;\n   }\n   va_end(ap);\n   return OPUS_OK;\nbad_arg:\n   va_end(ap);\n   return OPUS_BAD_ARG;\nbad_request:\n      va_end(ap);\n  return OPUS_UNIMPLEMENTED;\n}", "path": "opus/celt/celt_decoder.c", "commit_date": "2020-04-13 00:00:00", "repo_name": "xiph/opus", "stars": 2037, "license": "other", "language": "c", "size": 15204}
{"docstring": "/* Make basic checks on the CELT state to ensure we don't end\n   up writing all over memory. */\n", "func_signal": "void validate_celt_decoder(CELTDecoder *st)", "code": "{\n#ifndef CUSTOM_MODES\n   celt_assert(st->mode == opus_custom_mode_create(48000, 960, NULL));\n   celt_assert(st->overlap == 120);\n   celt_assert(st->end <= 21);\n#else\n/* From Section 4.3 in the spec: \"The normal CELT layer uses 21 of those bands,\n   though Opus Custom (see Section 6.2) may use a different number of bands\"\n\n   Check if it's within the maximum number of Bark frequency bands instead */\n   celt_assert(st->end <= 25);\n#endif\n   celt_assert(st->channels == 1 || st->channels == 2);\n   celt_assert(st->stream_channels == 1 || st->stream_channels == 2);\n   celt_assert(st->downsample > 0);\n   celt_assert(st->start == 0 || st->start == 17);\n   celt_assert(st->start < st->end);\n#ifdef OPUS_ARCHMASK\n   celt_assert(st->arch >= 0);\n   celt_assert(st->arch <= OPUS_ARCHMASK);\n#endif\n   celt_assert(st->last_pitch_index <= PLC_PITCH_LAG_MAX);\n   celt_assert(st->last_pitch_index >= PLC_PITCH_LAG_MIN || st->last_pitch_index == 0);\n   celt_assert(st->postfilter_period < MAX_PERIOD);\n   celt_assert(st->postfilter_period >= COMBFILTER_MINPERIOD || st->postfilter_period == 0);\n   celt_assert(st->postfilter_period_old < MAX_PERIOD);\n   celt_assert(st->postfilter_period_old >= COMBFILTER_MINPERIOD || st->postfilter_period_old == 0);\n   celt_assert(st->postfilter_tapset <= 2);\n   celt_assert(st->postfilter_tapset >= 0);\n   celt_assert(st->postfilter_tapset_old <= 2);\n   celt_assert(st->postfilter_tapset_old >= 0);\n}", "path": "opus/celt/celt_decoder.c", "commit_date": "2020-04-13 00:00:00", "repo_name": "xiph/opus", "stars": 2037, "license": "other", "language": "c", "size": 15204}
{"docstring": "/* CUSTOM_MODES */\n", "func_signal": "int opus_custom_encoder_ctl(CELTEncoder * OPUS_RESTRICT st, int request, ...)", "code": "{\n   va_list ap;\n\n   va_start(ap, request);\n   switch (request)\n   {\n      case OPUS_SET_COMPLEXITY_REQUEST:\n      {\n         int value = va_arg(ap, opus_int32);\n         if (value<0 || value>10)\n            goto bad_arg;\n         st->complexity = value;\n      }\n      break;\n      case CELT_SET_START_BAND_REQUEST:\n      {\n         opus_int32 value = va_arg(ap, opus_int32);\n         if (value<0 || value>=st->mode->nbEBands)\n            goto bad_arg;\n         st->start = value;\n      }\n      break;\n      case CELT_SET_END_BAND_REQUEST:\n      {\n         opus_int32 value = va_arg(ap, opus_int32);\n         if (value<1 || value>st->mode->nbEBands)\n            goto bad_arg;\n         st->end = value;\n      }\n      break;\n      case CELT_SET_PREDICTION_REQUEST:\n      {\n         int value = va_arg(ap, opus_int32);\n         if (value<0 || value>2)\n            goto bad_arg;\n         st->disable_pf = value<=1;\n         st->force_intra = value==0;\n      }\n      break;\n      case OPUS_SET_PACKET_LOSS_PERC_REQUEST:\n      {\n         int value = va_arg(ap, opus_int32);\n         if (value<0 || value>100)\n            goto bad_arg;\n         st->loss_rate = value;\n      }\n      break;\n      case OPUS_SET_VBR_CONSTRAINT_REQUEST:\n      {\n         opus_int32 value = va_arg(ap, opus_int32);\n         st->constrained_vbr = value;\n      }\n      break;\n      case OPUS_SET_VBR_REQUEST:\n      {\n         opus_int32 value = va_arg(ap, opus_int32);\n         st->vbr = value;\n      }\n      break;\n      case OPUS_SET_BITRATE_REQUEST:\n      {\n         opus_int32 value = va_arg(ap, opus_int32);\n         if (value<=500 && value!=OPUS_BITRATE_MAX)\n            goto bad_arg;\n         value = IMIN(value, 260000*st->channels);\n         st->bitrate = value;\n      }\n      break;\n      case CELT_SET_CHANNELS_REQUEST:\n      {\n         opus_int32 value = va_arg(ap, opus_int32);\n         if (value<1 || value>2)\n            goto bad_arg;\n         st->stream_channels = value;\n      }\n      break;\n      case OPUS_SET_LSB_DEPTH_REQUEST:\n      {\n          opus_int32 value = va_arg(ap, opus_int32);\n          if (value<8 || value>24)\n             goto bad_arg;\n          st->lsb_depth=value;\n      }\n      break;\n      case OPUS_GET_LSB_DEPTH_REQUEST:\n      {\n          opus_int32 *value = va_arg(ap, opus_int32*);\n          *value=st->lsb_depth;\n      }\n      break;\n      case OPUS_SET_PHASE_INVERSION_DISABLED_REQUEST:\n      {\n          opus_int32 value = va_arg(ap, opus_int32);\n          if(value<0 || value>1)\n          {\n             goto bad_arg;\n          }\n          st->disable_inv = value;\n      }\n      break;\n      case OPUS_GET_PHASE_INVERSION_DISABLED_REQUEST:\n      {\n          opus_int32 *value = va_arg(ap, opus_int32*);\n          if (!value)\n          {\n             goto bad_arg;\n          }\n          *value = st->disable_inv;\n      }\n      break;\n      case OPUS_RESET_STATE:\n      {\n         int i;\n         opus_val16 *oldBandE, *oldLogE, *oldLogE2;\n         oldBandE = (opus_val16*)(st->in_mem+st->channels*(st->mode->overlap+COMBFILTER_MAXPERIOD));\n         oldLogE = oldBandE + st->channels*st->mode->nbEBands;\n         oldLogE2 = oldLogE + st->channels*st->mode->nbEBands;\n         OPUS_CLEAR((char*)&st->ENCODER_RESET_START,\n               opus_custom_encoder_get_size(st->mode, st->channels)-\n               ((char*)&st->ENCODER_RESET_START - (char*)st));\n         for (i=0;i<st->channels*st->mode->nbEBands;i++)\n            oldLogE[i]=oldLogE2[i]=-QCONST16(28.f,DB_SHIFT);\n         st->vbr_offset = 0;\n         st->delayedIntra = 1;\n         st->spread_decision = SPREAD_NORMAL;\n         st->tonal_average = 256;\n         st->hf_average = 0;\n         st->tapset_decision = 0;\n      }\n      break;\n#ifdef CUSTOM_MODES\n      case CELT_SET_INPUT_CLIPPING_REQUEST:\n      {\n         opus_int32 value = va_arg(ap, opus_int32);\n         st->clip = value;\n      }\n      break;\n#endif\n      case CELT_SET_SIGNALLING_REQUEST:\n      {\n         opus_int32 value = va_arg(ap, opus_int32);\n         st->signalling = value;\n      }\n      break;\n      case CELT_SET_ANALYSIS_REQUEST:\n      {\n         AnalysisInfo *info = va_arg(ap, AnalysisInfo *);\n         if (info)\n            OPUS_COPY(&st->analysis, info, 1);\n      }\n      break;\n      case CELT_SET_SILK_INFO_REQUEST:\n      {\n         SILKInfo *info = va_arg(ap, SILKInfo *);\n         if (info)\n            OPUS_COPY(&st->silk_info, info, 1);\n      }\n      break;\n      case CELT_GET_MODE_REQUEST:\n      {\n         const CELTMode ** value = va_arg(ap, const CELTMode**);\n         if (value==0)\n            goto bad_arg;\n         *value=st->mode;\n      }\n      break;\n      case OPUS_GET_FINAL_RANGE_REQUEST:\n      {\n         opus_uint32 * value = va_arg(ap, opus_uint32 *);\n         if (value==0)\n            goto bad_arg;\n         *value=st->rng;\n      }\n      break;\n      case OPUS_SET_LFE_REQUEST:\n      {\n          opus_int32 value = va_arg(ap, opus_int32);\n          st->lfe = value;\n      }\n      break;\n      case OPUS_SET_ENERGY_MASK_REQUEST:\n      {\n          opus_val16 *value = va_arg(ap, opus_val16*);\n          st->energy_mask = value;\n      }\n      break;\n      default:\n         goto bad_request;\n   }\n   va_end(ap);\n   return OPUS_OK;\nbad_arg:\n   va_end(ap);\n   return OPUS_BAD_ARG;\nbad_request:\n   va_end(ap);\n   return OPUS_UNIMPLEMENTED;\n}", "path": "opus/celt/celt_encoder.c", "commit_date": "2020-05-26 00:00:00", "repo_name": "xiph/opus", "stars": 2037, "license": "other", "language": "c", "size": 15204}
{"docstring": "/*Computes the previous row/column of any recurrence that obeys the relation\n   u[i-1][j]=u[i][j]-u[i][j-1]-u[i-1][j-1].\n  _ui0 is the base case for the new row/column.*/\n", "func_signal": "static OPUS_INLINE void uprev(opus_uint32 *_ui,unsigned _n,opus_uint32 _ui0)", "code": "{\n  opus_uint32 ui1;\n  unsigned      j;\n  /*This do-while will overrun the array if we don't have storage for at least\n     2 values.*/\n  j=1; do {\n    ui1=USUB32(USUB32(_ui[j],_ui[j-1]),_ui0);\n    _ui[j-1]=_ui0;\n    _ui0=ui1;\n  } while (++j<_n);\n  _ui[j-1]=_ui0;\n}", "path": "opus/celt/cwrs.c", "commit_date": "2018-03-27 00:00:00", "repo_name": "xiph/opus", "stars": 2037, "license": "other", "language": "c", "size": 15204}
{"docstring": "/*Returns the index of the given combination of K elements chosen from a set\n   of size 1 with associated sign bits.\n  _y: The vector of pulses, whose sum of absolute values is K.\n  _k: Returns K.*/\n", "func_signal": "static OPUS_INLINE opus_uint32 icwrs1(const int *_y,int *_k)", "code": "{\n  *_k=abs(_y[0]);\n  return _y[0]<0;\n}", "path": "opus/celt/cwrs.c", "commit_date": "2018-03-27 00:00:00", "repo_name": "xiph/opus", "stars": 2037, "license": "other", "language": "c", "size": 15204}
{"docstring": "/*Guaranteed to return a conservatively large estimate of the binary logarithm\n   with frac bits of fractional precision.\n  Tested for all possible 32-bit inputs with frac=4, where the maximum\n   overestimation is 0.06254243 bits.*/\n", "func_signal": "int log2_frac(opus_uint32 val, int frac)", "code": "{\n  int l;\n  l=EC_ILOG(val);\n  if(val&(val-1)){\n    /*This is (val>>l-16), but guaranteed to round up, even if adding a bias\n       before the shift would cause overflow (e.g., for 0xFFFFxxxx).\n       Doesn't work for val=0, but that case fails the test above.*/\n    if(l>16)val=((val-1)>>(l-16))+1;\n    else val<<=16-l;\n    l=(l-1)<<frac;\n    /*Note that we always need one iteration, since the rounding up above means\n       that we might need to adjust the integer part of the logarithm.*/\n    do{\n      int b;\n      b=(int)(val>>16);\n      l+=b<<frac;\n      val=(val+b)>>b;\n      val=(val*val+0x7FFF)>>15;\n    }\n    while(frac-->0);\n    /*If val is not exactly 0x8000, then we have to round up the remainder.*/\n    return l+(val>0x8000);\n  }\n  /*Exact powers of two require no rounding.*/\n  else return (l-1)<<frac;\n}", "path": "opus/celt/cwrs.c", "commit_date": "2018-03-27 00:00:00", "repo_name": "xiph/opus", "stars": 2037, "license": "other", "language": "c", "size": 15204}
{"docstring": "/*\n** Open an apnd file handle.\n*/\n", "func_signal": "static int apndOpen(\n  sqlite3_vfs *pVfs,\n  const char *zName,\n  sqlite3_file *pFile,\n  int flags,\n  int *pOutFlags\n)", "code": "{\n  ApndFile *p;\n  sqlite3_file *pSubFile;\n  sqlite3_vfs *pSubVfs;\n  int rc;\n  sqlite3_int64 sz;\n  pSubVfs = ORIGVFS(pVfs);\n  if( (flags & SQLITE_OPEN_MAIN_DB)==0 ){\n    return pSubVfs->xOpen(pSubVfs, zName, pFile, flags, pOutFlags);\n  }\n  p = (ApndFile*)pFile;\n  memset(p, 0, sizeof(*p));\n  pSubFile = ORIGFILE(pFile);\n  p->base.pMethods = &apnd_io_methods;\n  rc = pSubVfs->xOpen(pSubVfs, zName, pSubFile, flags, pOutFlags);\n  if( rc ) goto apnd_open_done;\n  rc = pSubFile->pMethods->xFileSize(pSubFile, &sz);\n  if( rc ){\n    pSubFile->pMethods->xClose(pSubFile);\n    goto apnd_open_done;\n  }\n  if( apndIsOrdinaryDatabaseFile(sz, pSubFile) ){\n    memmove(pFile, pSubFile, pSubVfs->szOsFile);\n    return SQLITE_OK;\n  }\n  p->iMark = 0;\n  p->iPgOne = apndReadMark(sz, pFile);\n  if( p->iPgOne>0 ){\n    return SQLITE_OK;\n  }\n  if( (flags & SQLITE_OPEN_CREATE)==0 ){\n    pSubFile->pMethods->xClose(pSubFile);\n    rc = SQLITE_CANTOPEN;\n  }\n  p->iPgOne = (sz+0xfff) & ~(sqlite3_int64)0xfff;\napnd_open_done:\n  if( rc ) pFile->pMethods = 0;\n  return rc;\n}", "path": "litetree/shell.c", "commit_date": "2019-03-12 00:00:00", "repo_name": "aergoio/litetree", "stars": 1612, "license": "mit", "language": "c", "size": 8153}
{"docstring": "/*\n** Print a schema statement.  Part of MODE_Semi and MODE_Pretty output.\n**\n** This routine converts some CREATE TABLE statements for shadow tables\n** in FTS3/4/5 into CREATE TABLE IF NOT EXISTS statements.\n*/\n", "func_signal": "static void printSchemaLine(FILE *out, const char *z, const char *zTail)", "code": "{\n  if( sqlite3_strglob(\"CREATE TABLE ['\\\"]*\", z)==0 ){\n    utf8_printf(out, \"CREATE TABLE IF NOT EXISTS %s%s\", z+13, zTail);\n  }else{\n    utf8_printf(out, \"%s%s\", z, zTail);\n  }\n}", "path": "litetree/shell.c", "commit_date": "2019-03-12 00:00:00", "repo_name": "aergoio/litetree", "stars": 1612, "license": "mit", "language": "c", "size": 8153}
{"docstring": "/*\n** Make sure the database is open.  If it is not, then open it.  If\n** the database fails to open, print an error message and exit.\n*/\n", "func_signal": "static void open_db(ShellState *p, int openFlags)", "code": "{\n  if( p->db==0 ){\n    if( p->openMode==SHELL_OPEN_UNSPEC ){\n      if( p->zDbFilename==0 || p->zDbFilename[0]==0 ){\n        p->openMode = SHELL_OPEN_NORMAL;\n      }else{\n        p->openMode = (u8)deduceDatabaseType(p->zDbFilename, \n                             (openFlags & OPEN_DB_ZIPFILE)!=0);\n      }\n    }\n    switch( p->openMode ){\n      case SHELL_OPEN_APPENDVFS: {\n        sqlite3_open_v2(p->zDbFilename, &p->db, \n           SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE, \"apndvfs\");\n        break;\n      }\n      case SHELL_OPEN_HEXDB:\n      case SHELL_OPEN_DESERIALIZE: {\n        sqlite3_open(0, &p->db);\n        break;\n      }\n      case SHELL_OPEN_ZIPFILE: {\n        sqlite3_open(\":memory:\", &p->db);\n        break;\n      }\n      case SHELL_OPEN_READONLY: {\n        sqlite3_open_v2(p->zDbFilename, &p->db, SQLITE_OPEN_READONLY, 0);\n        break;\n      }\n      case SHELL_OPEN_UNSPEC:\n      case SHELL_OPEN_NORMAL: {\n        sqlite3_open(p->zDbFilename, &p->db);\n        break;\n      }\n    }\n    globalDb = p->db;\n    if( p->db==0 || SQLITE_OK!=sqlite3_errcode(p->db) ){\n      utf8_printf(stderr,\"Error: unable to open database \\\"%s\\\": %s\\n\",\n          p->zDbFilename, sqlite3_errmsg(p->db));\n      if( openFlags & OPEN_DB_KEEPALIVE ){\n        sqlite3_open(\":memory:\", &p->db);\n        return;\n      }\n      exit(1);\n    }\n#ifndef SQLITE_OMIT_LOAD_EXTENSION\n    sqlite3_enable_load_extension(p->db, 1);\n#endif\n    sqlite3_fileio_init(p->db, 0, 0);\n    sqlite3_shathree_init(p->db, 0, 0);\n    sqlite3_completion_init(p->db, 0, 0);\n#ifdef SQLITE_HAVE_ZLIB\n    sqlite3_zipfile_init(p->db, 0, 0);\n    sqlite3_sqlar_init(p->db, 0, 0);\n#endif\n    sqlite3_create_function(p->db, \"shell_add_schema\", 3, SQLITE_UTF8, 0,\n                            shellAddSchemaName, 0, 0);\n    sqlite3_create_function(p->db, \"shell_module_schema\", 1, SQLITE_UTF8, 0,\n                            shellModuleSchema, 0, 0);\n    sqlite3_create_function(p->db, \"shell_putsnl\", 1, SQLITE_UTF8, p,\n                            shellPutsFunc, 0, 0);\n#ifndef SQLITE_NOHAVE_SYSTEM\n    sqlite3_create_function(p->db, \"edit\", 1, SQLITE_UTF8, 0,\n                            editFunc, 0, 0);\n    sqlite3_create_function(p->db, \"edit\", 2, SQLITE_UTF8, 0,\n                            editFunc, 0, 0);\n#endif\n    if( p->openMode==SHELL_OPEN_ZIPFILE ){\n      char *zSql = sqlite3_mprintf(\n         \"CREATE VIRTUAL TABLE zip USING zipfile(%Q);\", p->zDbFilename);\n      sqlite3_exec(p->db, zSql, 0, 0, 0);\n      sqlite3_free(zSql);\n    }\n#ifdef SQLITE_ENABLE_DESERIALIZE\n    else\n    if( p->openMode==SHELL_OPEN_DESERIALIZE || p->openMode==SHELL_OPEN_HEXDB ){\n      int rc;\n      int nData = 0;\n      unsigned char *aData;\n      if( p->openMode==SHELL_OPEN_DESERIALIZE ){\n        aData = (unsigned char*)readFile(p->zDbFilename, &nData);\n      }else{\n        aData = readHexDb(p, &nData);\n        if( aData==0 ){\n          utf8_printf(stderr, \"Error in hexdb input\\n\");\n          return;\n        }\n      }\n      rc = sqlite3_deserialize(p->db, \"main\", aData, nData, nData,\n                   SQLITE_DESERIALIZE_RESIZEABLE |\n                   SQLITE_DESERIALIZE_FREEONCLOSE);\n      if( rc ){\n        utf8_printf(stderr, \"Error: sqlite3_deserialize() returns %d\\n\", rc);\n      }\n      if( p->szMax>0 ){\n        sqlite3_file_control(p->db, \"main\", SQLITE_FCNTL_SIZE_LIMIT, &p->szMax);\n      }\n    }\n#endif\n  }\n}", "path": "litetree/shell.c", "commit_date": "2019-03-12 00:00:00", "repo_name": "aergoio/litetree", "stars": 1612, "license": "mit", "language": "c", "size": 8153}
{"docstring": "/*\n** If compiled statement pSql appears to be an EXPLAIN statement, allocate\n** and populate the ShellState.aiIndent[] array with the number of\n** spaces each opcode should be indented before it is output.\n**\n** The indenting rules are:\n**\n**     * For each \"Next\", \"Prev\", \"VNext\" or \"VPrev\" instruction, indent\n**       all opcodes that occur between the p2 jump destination and the opcode\n**       itself by 2 spaces.\n**\n**     * For each \"Goto\", if the jump destination is earlier in the program\n**       and ends on one of:\n**          Yield  SeekGt  SeekLt  RowSetRead  Rewind\n**       or if the P1 parameter is one instead of zero,\n**       then indent all opcodes between the earlier instruction\n**       and \"Goto\" by 2 spaces.\n*/\n", "func_signal": "static void explain_data_prepare(ShellState *p, sqlite3_stmt *pSql)", "code": "{\n  const char *zSql;               /* The text of the SQL statement */\n  const char *z;                  /* Used to check if this is an EXPLAIN */\n  int *abYield = 0;               /* True if op is an OP_Yield */\n  int nAlloc = 0;                 /* Allocated size of p->aiIndent[], abYield */\n  int iOp;                        /* Index of operation in p->aiIndent[] */\n\n  const char *azNext[] = { \"Next\", \"Prev\", \"VPrev\", \"VNext\", \"SorterNext\", 0 };\n  const char *azYield[] = { \"Yield\", \"SeekLT\", \"SeekGT\", \"RowSetRead\",\n                            \"Rewind\", 0 };\n  const char *azGoto[] = { \"Goto\", 0 };\n\n  /* Try to figure out if this is really an EXPLAIN statement. If this\n  ** cannot be verified, return early.  */\n  if( sqlite3_column_count(pSql)!=8 ){\n    p->cMode = p->mode;\n    return;\n  }\n  zSql = sqlite3_sql(pSql);\n  if( zSql==0 ) return;\n  for(z=zSql; *z==' ' || *z=='\\t' || *z=='\\n' || *z=='\\f' || *z=='\\r'; z++);\n  if( sqlite3_strnicmp(z, \"explain\", 7) ){\n    p->cMode = p->mode;\n    return;\n  }\n\n  for(iOp=0; SQLITE_ROW==sqlite3_step(pSql); iOp++){\n    int i;\n    int iAddr = sqlite3_column_int(pSql, 0);\n    const char *zOp = (const char*)sqlite3_column_text(pSql, 1);\n\n    /* Set p2 to the P2 field of the current opcode. Then, assuming that\n    ** p2 is an instruction address, set variable p2op to the index of that\n    ** instruction in the aiIndent[] array. p2 and p2op may be different if\n    ** the current instruction is part of a sub-program generated by an\n    ** SQL trigger or foreign key.  */\n    int p2 = sqlite3_column_int(pSql, 3);\n    int p2op = (p2 + (iOp-iAddr));\n\n    /* Grow the p->aiIndent array as required */\n    if( iOp>=nAlloc ){\n      if( iOp==0 ){\n        /* Do further verfication that this is explain output.  Abort if\n        ** it is not */\n        static const char *explainCols[] = {\n           \"addr\", \"opcode\", \"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"comment\" };\n        int jj;\n        for(jj=0; jj<ArraySize(explainCols); jj++){\n          if( strcmp(sqlite3_column_name(pSql,jj),explainCols[jj])!=0 ){\n            p->cMode = p->mode;\n            sqlite3_reset(pSql);\n            return;\n          }\n        }\n      }\n      nAlloc += 100;\n      p->aiIndent = (int*)sqlite3_realloc64(p->aiIndent, nAlloc*sizeof(int));\n      if( p->aiIndent==0 ) shell_out_of_memory();\n      abYield = (int*)sqlite3_realloc64(abYield, nAlloc*sizeof(int));\n      if( abYield==0 ) shell_out_of_memory();\n    }\n    abYield[iOp] = str_in_array(zOp, azYield);\n    p->aiIndent[iOp] = 0;\n    p->nIndent = iOp+1;\n\n    if( str_in_array(zOp, azNext) ){\n      for(i=p2op; i<iOp; i++) p->aiIndent[i] += 2;\n    }\n    if( str_in_array(zOp, azGoto) && p2op<p->nIndent\n     && (abYield[p2op] || sqlite3_column_int(pSql, 2))\n    ){\n      for(i=p2op; i<iOp; i++) p->aiIndent[i] += 2;\n    }\n  }\n\n  p->iIndent = 0;\n  sqlite3_free(abYield);\n  sqlite3_reset(pSql);\n}", "path": "litetree/shell.c", "commit_date": "2019-03-12 00:00:00", "repo_name": "aergoio/litetree", "stars": 1612, "license": "mit", "language": "c", "size": 8153}
{"docstring": "/*\n** Output the given string with characters that are special to\n** HTML escaped.\n*/\n", "func_signal": "static void output_html_string(FILE *out, const char *z)", "code": "{\n  int i;\n  if( z==0 ) z = \"\";\n  while( *z ){\n    for(i=0;   z[i]\n            && z[i]!='<'\n            && z[i]!='&'\n            && z[i]!='>'\n            && z[i]!='\\\"'\n            && z[i]!='\\'';\n        i++){}\n    if( i>0 ){\n      utf8_printf(out,\"%.*s\",i,z);\n    }\n    if( z[i]=='<' ){\n      raw_printf(out,\"&lt;\");\n    }else if( z[i]=='&' ){\n      raw_printf(out,\"&amp;\");\n    }else if( z[i]=='>' ){\n      raw_printf(out,\"&gt;\");\n    }else if( z[i]=='\\\"' ){\n      raw_printf(out,\"&quot;\");\n    }else if( z[i]=='\\'' ){\n      raw_printf(out,\"&#39;\");\n    }else{\n      break;\n    }\n    z += i + 1;\n  }\n}", "path": "litetree/shell.c", "commit_date": "2019-03-12 00:00:00", "repo_name": "aergoio/litetree", "stars": 1612, "license": "mit", "language": "c", "size": 8153}
{"docstring": "/*\n** This function is designed to convert a Win32 FILETIME structure into the\n** number of seconds since the Unix Epoch (1970-01-01 00:00:00 UTC).\n*/\n", "func_signal": "static sqlite3_uint64 fileTimeToUnixTime(\n  LPFILETIME pFileTime\n)", "code": "{\n  SYSTEMTIME epochSystemTime;\n  ULARGE_INTEGER epochIntervals;\n  FILETIME epochFileTime;\n  ULARGE_INTEGER fileIntervals;\n\n  memset(&epochSystemTime, 0, sizeof(SYSTEMTIME));\n  epochSystemTime.wYear = 1970;\n  epochSystemTime.wMonth = 1;\n  epochSystemTime.wDay = 1;\n  SystemTimeToFileTime(&epochSystemTime, &epochFileTime);\n  epochIntervals.LowPart = epochFileTime.dwLowDateTime;\n  epochIntervals.HighPart = epochFileTime.dwHighDateTime;\n\n  fileIntervals.LowPart = pFileTime->dwLowDateTime;\n  fileIntervals.HighPart = pFileTime->dwHighDateTime;\n\n  return (fileIntervals.QuadPart - epochIntervals.QuadPart) / 10000000;\n}", "path": "litetree/shell.c", "commit_date": "2019-03-12 00:00:00", "repo_name": "aergoio/litetree", "stars": 1612, "license": "mit", "language": "c", "size": 8153}
{"docstring": "/*\n** Argument zFile is the name of a file that will be created and/or written\n** by SQL function writefile(). This function ensures that the directory\n** zFile will be written to exists, creating it if required. The permissions\n** for any path components created by this function are set to (mode&0777).\n**\n** If an OOM condition is encountered, SQLITE_NOMEM is returned. Otherwise,\n** SQLITE_OK is returned if the directory is successfully created, or\n** SQLITE_ERROR otherwise.\n*/\n", "func_signal": "static int makeDirectory(\n  const char *zFile,\n  mode_t mode\n)", "code": "{\n  char *zCopy = sqlite3_mprintf(\"%s\", zFile);\n  int rc = SQLITE_OK;\n\n  if( zCopy==0 ){\n    rc = SQLITE_NOMEM;\n  }else{\n    int nCopy = (int)strlen(zCopy);\n    int i = 1;\n\n    while( rc==SQLITE_OK ){\n      struct stat sStat;\n      int rc2;\n\n      for(; zCopy[i]!='/' && i<nCopy; i++);\n      if( i==nCopy ) break;\n      zCopy[i] = '\\0';\n\n      rc2 = fileStat(zCopy, &sStat);\n      if( rc2!=0 ){\n        if( mkdir(zCopy, mode & 0777) ) rc = SQLITE_ERROR;\n      }else{\n        if( !S_ISDIR(sStat.st_mode) ) rc = SQLITE_ERROR;\n      }\n      zCopy[i] = '/';\n      i++;\n    }\n\n    sqlite3_free(zCopy);\n  }\n\n  return rc;\n}", "path": "litetree/shell.c", "commit_date": "2019-03-12 00:00:00", "repo_name": "aergoio/litetree", "stars": 1612, "license": "mit", "language": "c", "size": 8153}
{"docstring": "/*\n** Implementation of the POSIX getenv() function using the Win32 API.\n** This function is not thread-safe.\n*/\n", "func_signal": "const char *windirent_getenv(\n  const char *name\n)", "code": "{\n  static char value[32768]; /* Maximum length, per MSDN */\n  DWORD dwSize = sizeof(value) / sizeof(char); /* Size in chars */\n  DWORD dwRet; /* Value returned by GetEnvironmentVariableA() */\n\n  memset(value, 0, sizeof(value));\n  dwRet = GetEnvironmentVariableA(name, value, dwSize);\n  if( dwRet==0 || dwRet>dwSize ){\n    /*\n    ** The function call to GetEnvironmentVariableA() failed -OR-\n    ** the buffer is not large enough.  Either way, return NULL.\n    */\n    return 0;\n  }else{\n    /*\n    ** The function call to GetEnvironmentVariableA() succeeded\n    ** -AND- the buffer contains the entire value.\n    */\n    return value;\n  }\n}", "path": "litetree/shell.c", "commit_date": "2019-03-12 00:00:00", "repo_name": "aergoio/litetree", "stars": 1612, "license": "mit", "language": "c", "size": 8153}
{"docstring": "/* Begin tracing memory allocations to out. */\n", "func_signal": "int sqlite3MemTraceActivate(FILE *out)", "code": "{\n  int rc = SQLITE_OK;\n  if( memtraceBase.xMalloc==0 ){\n    rc = sqlite3_config(SQLITE_CONFIG_GETMALLOC, &memtraceBase);\n    if( rc==SQLITE_OK ){\n      rc = sqlite3_config(SQLITE_CONFIG_MALLOC, &ersaztMethods);\n    }\n  }\n  memtraceOut = out;\n  return rc;\n}", "path": "litetree/shell.c", "commit_date": "2019-03-12 00:00:00", "repo_name": "aergoio/litetree", "stars": 1612, "license": "mit", "language": "c", "size": 8153}
{"docstring": "/*\n** Decode the LFH record in buffer aBuf into (*pLFH). Return SQLITE_ERROR\n** if the record is not well-formed, or SQLITE_OK otherwise.\n*/\n", "func_signal": "static int zipfileReadLFH(\n  u8 *aBuffer,\n  ZipfileLFH *pLFH\n)", "code": "{\n  u8 *aRead = aBuffer;\n  int rc = SQLITE_OK;\n\n  u32 sig = zipfileRead32(aRead);\n  if( sig!=ZIPFILE_SIGNATURE_LFH ){\n    rc = SQLITE_ERROR;\n  }else{\n    pLFH->iVersionExtract = zipfileRead16(aRead);\n    pLFH->flags = zipfileRead16(aRead);\n    pLFH->iCompression = zipfileRead16(aRead);\n    pLFH->mTime = zipfileRead16(aRead);\n    pLFH->mDate = zipfileRead16(aRead);\n    pLFH->crc32 = zipfileRead32(aRead);\n    pLFH->szCompressed = zipfileRead32(aRead);\n    pLFH->szUncompressed = zipfileRead32(aRead);\n    pLFH->nFile = zipfileRead16(aRead);\n    pLFH->nExtra = zipfileRead16(aRead);\n  }\n  return rc;\n}", "path": "litetree/shell.c", "commit_date": "2019-03-12 00:00:00", "repo_name": "aergoio/litetree", "stars": 1612, "license": "mit", "language": "c", "size": 8153}
{"docstring": "/*\n** If string zIn is quoted, dequote it in place. Otherwise, if the string\n** is not quoted, do nothing.\n*/\n", "func_signal": "static void zipfileDequote(char *zIn)", "code": "{\n  char q = zIn[0];\n  if( q=='\"' || q=='\\'' || q=='`' || q=='[' ){\n    int iIn = 1;\n    int iOut = 0;\n    if( q=='[' ) q = ']';\n    while( ALWAYS(zIn[iIn]) ){\n      char c = zIn[iIn++];\n      if( c==q && zIn[iIn++]!=q ) break;\n      zIn[iOut++] = c;\n    }\n    zIn[iOut] = '\\0';\n  }\n}", "path": "litetree/shell.c", "commit_date": "2019-03-12 00:00:00", "repo_name": "aergoio/litetree", "stars": 1612, "license": "mit", "language": "c", "size": 8153}
{"docstring": "/*\n** Return true if zId must be quoted in order to use it as an SQL\n** identifier, or false otherwise.\n*/\n", "func_signal": "static int idxIdentifierRequiresQuotes(const char *zId)", "code": "{\n  int i;\n  for(i=0; zId[i]; i++){\n    if( !(zId[i]=='_')\n     && !(zId[i]>='0' && zId[i]<='9')\n     && !(zId[i]>='a' && zId[i]<='z')\n     && !(zId[i]>='A' && zId[i]<='Z')\n    ){\n      return 1;\n    }\n  }\n  return 0;\n}", "path": "litetree/shell.c", "commit_date": "2019-03-12 00:00:00", "repo_name": "aergoio/litetree", "stars": 1612, "license": "mit", "language": "c", "size": 8153}
{"docstring": "/*\n** Begin timing an operation\n*/\n", "func_signal": "static void beginTimer(void)", "code": "{\n  if( enableTimer ){\n    getrusage(RUSAGE_SELF, &sBegin);\n    iBegin = timeOfDay();\n  }\n}", "path": "litetree/shell.c", "commit_date": "2019-03-12 00:00:00", "repo_name": "aergoio/litetree", "stars": 1612, "license": "mit", "language": "c", "size": 8153}
{"docstring": "/*\n** Add a new entry to the EXPLAIN QUERY PLAN data\n*/\n", "func_signal": "static void eqp_append(ShellState *p, int iEqpId, int p2, const char *zText)", "code": "{\n  EQPGraphRow *pNew;\n  int nText = strlen30(zText);\n  if( p->autoEQPtest ){\n    utf8_printf(p->out, \"%d,%d,%s\\n\", iEqpId, p2, zText);\n  }\n  pNew = sqlite3_malloc64( sizeof(*pNew) + nText );\n  if( pNew==0 ) shell_out_of_memory();\n  pNew->iEqpId = iEqpId;\n  pNew->iParentId = p2;\n  memcpy(pNew->zText, zText, nText+1);\n  pNew->pNext = 0;\n  if( p->sGraph.pLast ){\n    p->sGraph.pLast->pNext = pNew;\n  }else{\n    p->sGraph.pRow = pNew;\n  }\n  p->sGraph.pLast = pNew;\n}", "path": "litetree/shell.c", "commit_date": "2019-03-12 00:00:00", "repo_name": "aergoio/litetree", "stars": 1612, "license": "mit", "language": "c", "size": 8153}
{"docstring": "/*\n** Return a 32-bit timestamp in UNIX epoch format.\n**\n** If the value passed as the only argument is either NULL or an SQL NULL,\n** return the current time. Otherwise, return the value stored in (*pVal)\n** cast to a 32-bit unsigned integer.\n*/\n", "func_signal": "static u32 zipfileGetTime(sqlite3_value *pVal)", "code": "{\n  if( pVal==0 || sqlite3_value_type(pVal)==SQLITE_NULL ){\n    return zipfileTime();\n  }\n  return (u32)sqlite3_value_int64(pVal);\n}", "path": "litetree/shell.c", "commit_date": "2019-03-12 00:00:00", "repo_name": "aergoio/litetree", "stars": 1612, "license": "mit", "language": "c", "size": 8153}
{"docstring": "/*\n** This routine reads a line of text from FILE in, stores\n** the text in memory obtained from malloc() and returns a pointer\n** to the text.  NULL is returned at end of file, or if malloc()\n** fails.\n**\n** If zLine is not NULL then it is a malloced buffer returned from\n** a previous call to this routine that may be reused.\n*/\n", "func_signal": "static char *local_getline(char *zLine, FILE *in)", "code": "{\n  int nLine = zLine==0 ? 0 : 100;\n  int n = 0;\n\n  while( 1 ){\n    if( n+100>nLine ){\n      nLine = nLine*2 + 100;\n      zLine = realloc(zLine, nLine);\n      if( zLine==0 ) shell_out_of_memory();\n    }\n    if( fgets(&zLine[n], nLine - n, in)==0 ){\n      if( n==0 ){\n        free(zLine);\n        return 0;\n      }\n      zLine[n] = 0;\n      break;\n    }\n    while( zLine[n] ) n++;\n    if( n>0 && zLine[n-1]=='\\n' ){\n      n--;\n      if( n>0 && zLine[n-1]=='\\r' ) n--;\n      zLine[n] = 0;\n      break;\n    }\n  }\n#if defined(_WIN32) || defined(WIN32)\n  /* For interactive input on Windows systems, translate the\n  ** multi-byte characterset characters into UTF-8. */\n  if( stdin_is_interactive && in==stdin ){\n    char *zTrans = sqlite3_win32_mbcs_to_utf8_v2(zLine, 0);\n    if( zTrans ){\n      int nTrans = strlen30(zTrans)+1;\n      if( nTrans>nLine ){\n        zLine = realloc(zLine, nTrans);\n        if( zLine==0 ) shell_out_of_memory();\n      }\n      memcpy(zLine, zTrans, nTrans);\n      sqlite3_free(zTrans);\n    }\n  }\n#endif /* defined(_WIN32) || defined(WIN32) */\n  return zLine;\n}", "path": "litetree/shell.c", "commit_date": "2019-03-12 00:00:00", "repo_name": "aergoio/litetree", "stars": 1612, "license": "mit", "language": "c", "size": 8153}
{"docstring": "/*\n** Print the current sqlite3_errmsg() value to stderr and return 1.\n*/\n", "func_signal": "static int shellDatabaseError(sqlite3 *db)", "code": "{\n  const char *zErr = sqlite3_errmsg(db);\n  utf8_printf(stderr, \"Error: %s\\n\", zErr);\n  return 1;\n}", "path": "litetree/shell.c", "commit_date": "2019-03-12 00:00:00", "repo_name": "aergoio/litetree", "stars": 1612, "license": "mit", "language": "c", "size": 8153}
{"docstring": "/*\n** Compare the string as a command-line option with either one or two\n** initial \"-\" characters.\n*/\n", "func_signal": "static int optionMatch(const char *zStr, const char *zOpt)", "code": "{\n  if( zStr[0]!='-' ) return 0;\n  zStr++;\n  if( zStr[0]=='-' ) zStr++;\n  return strcmp(zStr, zOpt)==0;\n}", "path": "litetree/shell.c", "commit_date": "2019-03-12 00:00:00", "repo_name": "aergoio/litetree", "stars": 1612, "license": "mit", "language": "c", "size": 8153}
{"docstring": "/*\n** Determines if a string is a number of not.\n*/\n", "func_signal": "static int isNumber(const char *z, int *realnum)", "code": "{\n  if( *z=='-' || *z=='+' ) z++;\n  if( !IsDigit(*z) ){\n    return 0;\n  }\n  z++;\n  if( realnum ) *realnum = 0;\n  while( IsDigit(*z) ){ z++; }\n  if( *z=='.' ){\n    z++;\n    if( !IsDigit(*z) ) return 0;\n    while( IsDigit(*z) ){ z++; }\n    if( realnum ) *realnum = 1;\n  }\n  if( *z=='e' || *z=='E' ){\n    z++;\n    if( *z=='+' || *z=='-' ) z++;\n    if( !IsDigit(*z) ) return 0;\n    while( IsDigit(*z) ){ z++; }\n    if( realnum ) *realnum = 1;\n  }\n  return *z==0;\n}", "path": "litetree/shell.c", "commit_date": "2019-03-12 00:00:00", "repo_name": "aergoio/litetree", "stars": 1612, "license": "mit", "language": "c", "size": 8153}
{"docstring": "/*\n** Set the error message for the virtual table associated with cursor\n** pCur to the results of vprintf(zFmt, ...).\n*/\n", "func_signal": "static void fsdirSetErrmsg(fsdir_cursor *pCur, const char *zFmt, ...)", "code": "{\n  va_list ap;\n  va_start(ap, zFmt);\n  pCur->base.pVtab->zErrMsg = sqlite3_vmprintf(zFmt, ap);\n  va_end(ap);\n}", "path": "litetree/shell.c", "commit_date": "2019-03-12 00:00:00", "repo_name": "aergoio/litetree", "stars": 1612, "license": "mit", "language": "c", "size": 8153}
{"docstring": "/* test that WM_DRAWCLIPBOARD can be delivered for a previous change during OleSetClipboard */\n", "func_signal": "static void test_set_clipboard_DRAWCLIPBOARD(void)", "code": "{\n    LPDATAOBJECT data;\n    HRESULT hr;\n    WNDCLASSA cls;\n    HWND viewer;\n    int ret;\n    HANDLE thread;\n\n    hr = DataObjectImpl_CreateText(\"data\", &data);\n    ok(hr == S_OK, \"Failed to create data object: 0x%08x\\n\", hr);\n\n    memset(&cls, 0, sizeof(cls));\n    cls.lpfnWndProc = clipboard_wnd_proc;\n    cls.hInstance = GetModuleHandleA(NULL);\n    cls.lpszClassName = \"clipboard_test\";\n    RegisterClassA(&cls);\n\n    viewer = CreateWindowA(\"clipboard_test\", NULL, 0, 0, 0, 0, 0, NULL, 0, NULL, 0);\n    ok(viewer != NULL, \"CreateWindow failed: %d\\n\", GetLastError());\n    next_wnd = SetClipboardViewer( viewer );\n\n    ret = SendMessageA( viewer, WM_USER, 0, 0 );\n    ok( ret == 1, \"%u WM_DRAWCLIPBOARD received\\n\", ret );\n\n    hr = OleInitialize(NULL);\n    ok(hr == S_OK, \"OleInitialize failed with error 0x%08x\\n\", hr);\n\n    ret = SendMessageA( viewer, WM_USER, 0, 0 );\n    ok( !ret, \"%u WM_DRAWCLIPBOARD received\\n\", ret );\n\n    thread = CreateThread(NULL, 0, set_clipboard_thread, NULL, 0, NULL);\n    ok(thread != NULL, \"CreateThread failed (%d)\\n\", GetLastError());\n    ret = WaitForSingleObject(thread, 5000);\n    ok(ret == WAIT_OBJECT_0, \"WaitForSingleObject returned %x\\n\", ret);\n\n    clip_data = data;\n    hr = OleSetClipboard(data);\n    ok(hr == S_OK, \"failed to set clipboard to data, hr = 0x%08x\\n\", hr);\n\n    ret = SendMessageA( viewer, WM_USER, 0, 0 );\n    ok( ret == 2, \"%u WM_DRAWCLIPBOARD received\\n\", ret );\n\n    clip_data = NULL;\n    hr = OleFlushClipboard();\n    ok(hr == S_OK, \"failed to flush clipboard, hr = 0x%08x\\n\", hr);\n    ret = IDataObject_Release(data);\n    ok(ret == 0, \"got %d\\n\", ret);\n\n    OleUninitialize();\n    ChangeClipboardChain( viewer, next_wnd );\n    DestroyWindow( viewer );\n}", "path": "wine/dlls/ole32/tests/clipboard.c", "commit_date": "2020-01-03 00:00:00", "repo_name": "ValveSoftware/wine", "stars": 1077, "license": "other", "language": "c", "size": 518660}
{"docstring": "/******************************************************************************\n *  copy_handle\n *\n * Copies a handle. Increments the reference count of the object referenced\n * by the handle.\n *\n * PARAMS\n *  lpTable [I] Pointer to the handle table, which holds the handle to be copied.\n *  handle  [I] The handle to be copied.\n *  copy    [O] Pointer to a handle variable, where the copied handle is put.\n *\n * RETURNS\n *  TRUE,      if successful\n *  FALSE,     if not successful (invalid handle or out of memory)\n */\n", "func_signal": "BOOL copy_handle(struct handle_table *lpTable, HCRYPTKEY handle, DWORD dwType, HCRYPTKEY *copy)", "code": "{\n    OBJECTHDR *pObject;\n    BOOL ret;\n\n    TRACE(\"(lpTable=%p, handle=%ld, copy=%p)\\n\", lpTable, handle, copy);\n\n    EnterCriticalSection(&lpTable->mutex);\n    if (!lookup_handle(lpTable, handle, dwType, &pObject)) \n    {\n        *copy = (HCRYPTKEY)INVALID_HANDLE_VALUE;\n        LeaveCriticalSection(&lpTable->mutex);\n        return FALSE;\n    }\n\n    ret = alloc_handle(lpTable, pObject, copy);\n    LeaveCriticalSection(&lpTable->mutex);\n    return ret;\n}", "path": "wine/dlls/rsaenh/handle.c", "commit_date": "2013-11-25 00:00:00", "repo_name": "ValveSoftware/wine", "stars": 1077, "license": "other", "language": "c", "size": 518660}
{"docstring": "/* load a single input file */\n", "func_signal": "static int load_file( const char *input_name, const char *output_name )", "code": "{\n    int ret;\n\n    /* Run the preprocessor on the input */\n    if(!no_preprocess)\n    {\n        FILE *output;\n        int ret, fd;\n        char *name;\n\n        /*\n         * Preprocess the input to a temp-file, or stdout if\n         * no output was given.\n         */\n\n        if (preprocess_only)\n        {\n            if (output_name)\n            {\n                if (!(output = fopen( output_name, \"w\" )))\n                    fatal_perror( \"Could not open %s for writing\", output_name );\n                ret = wpp_parse( input_name, output );\n                fclose( output );\n            }\n            else ret = wpp_parse( input_name, stdout );\n\n            if (ret) return ret;\n            output_name = NULL;\n            exit(0);\n        }\n\n        if (output_name && output_name[0]) name = strmake( \"%s.XXXXXX\", output_name );\n        else name = xstrdup( \"wrc.XXXXXX\" );\n\n        if ((fd = mkstemps( name, 0 )) == -1)\n            error(\"Could not generate a temp name from %s\\n\", name);\n\n        temp_name = name;\n        if (!(output = fdopen(fd, \"wt\")))\n            error(\"Could not open fd %s for writing\\n\", name);\n\n        ret = wpp_parse( input_name, output );\n        fclose( output );\n        if (ret) return ret;\n        input_name = name;\n    }\n\n    /* Reset the language */\n    currentlanguage = dup_language( defaultlanguage );\n    check_utf8 = 1;\n\n    /* Go from .rc to .res */\n    chat(\"Starting parse\\n\");\n\n    if(!(parser_in = fopen(input_name, \"rb\")))\n        fatal_perror(\"Could not open %s for input\", input_name);\n\n    ret = parser_parse();\n    fclose(parser_in);\n    parser_lex_destroy();\n    if (temp_name)\n    {\n        unlink( temp_name );\n        temp_name = NULL;\n    }\n    free( currentlanguage );\n    return ret;\n}", "path": "wine/tools/wrc/wrc.c", "commit_date": "2020-04-30 00:00:00", "repo_name": "ValveSoftware/wine", "stars": 1077, "license": "other", "language": "c", "size": 518660}
{"docstring": "/* Advances a collection enumeration by one context, if possible, where\n * advancing means:\n * - calling the current store's enumeration function once, and returning\n *   the enumerated context if one is returned\n * - moving to the next store if the current store has no more items, and\n *   recursively calling itself to get the next item.\n * Returns NULL if the collection contains no more items or on error.\n * Assumes the collection store's lock is held.\n */\n", "func_signal": "static context_t *CRYPT_CollectionAdvanceEnum(WINE_COLLECTIONSTORE *store,\n WINE_STORE_LIST_ENTRY *storeEntry, const CONTEXT_FUNCS *contextFuncs,\n context_t *prev)", "code": "{\n    context_t *child, *ret;\n    struct list *storeNext = list_next(&store->stores, &storeEntry->entry);\n\n    TRACE(\"(%p, %p, %p)\\n\", store, storeEntry, prev);\n\n    if (prev)\n    {\n        /* Ref-counting funny business: \"duplicate\" (addref) the child, because\n         * the free(pPrev) below can cause the ref count to become negative.\n         */\n        child = prev->linked;\n        Context_AddRef(child);\n        child = contextFuncs->enumContext(storeEntry->store, child);\n        Context_Release(prev);\n    }\n    else\n    {\n        child = contextFuncs->enumContext(storeEntry->store, NULL);\n    }\n    if (child) {\n        ret = CRYPT_CollectionCreateContextFromChild(store, storeEntry, child);\n        Context_Release(child);\n    }\n    else\n    {\n        if (storeNext)\n        {\n            /* We always want the same function pointers (from certs, crls)\n             * in the next store, so use the same offset into the next store.\n             */\n            size_t offset = (const BYTE *)contextFuncs - (LPBYTE)storeEntry->store->vtbl;\n            WINE_STORE_LIST_ENTRY *storeNextEntry =\n             LIST_ENTRY(storeNext, WINE_STORE_LIST_ENTRY, entry);\n            CONTEXT_FUNCS *storeNextContexts =\n             (CONTEXT_FUNCS*)((LPBYTE)storeNextEntry->store->vtbl + offset);\n\n            ret = CRYPT_CollectionAdvanceEnum(store, storeNextEntry,\n             storeNextContexts, NULL);\n        }\n        else\n        {\n            SetLastError(CRYPT_E_NOT_FOUND);\n            ret = NULL;\n        }\n    }\n    TRACE(\"returning %p\\n\", ret);\n    return ret;\n}", "path": "wine/dlls/crypt32/collectionstore.c", "commit_date": "2017-10-03 00:00:00", "repo_name": "ValveSoftware/wine", "stars": 1077, "license": "other", "language": "c", "size": 518660}
{"docstring": "/* Remove the given test directory and the attribute test files, if any */\n", "func_signal": "static void tear_down_attribute_test(const WCHAR *testdir)", "code": "{\n    int i;\n\n    for (i = 0; i < test_dir_count; i++) {\n        int ret;\n        WCHAR buf[MAX_PATH];\n        if (lstrcmpW(testfiles[i].name, dotW) == 0 || lstrcmpW(testfiles[i].name, dotdotW) == 0)\n            continue;\n        lstrcpyW( buf, testdir );\n        lstrcatW( buf, backslashW );\n        lstrcatW( buf, testfiles[i].name );\n        if (testfiles[i].attr & FILE_ATTRIBUTE_DIRECTORY) {\n            ret = RemoveDirectoryW(buf);\n            ok(ret || (GetLastError() == ERROR_PATH_NOT_FOUND),\n               \"Failed to rmdir %s, error %d\\n\", wine_dbgstr_w(buf), GetLastError());\n        } else {\n            ret = DeleteFileW(buf);\n            ok(ret || (GetLastError() == ERROR_PATH_NOT_FOUND),\n               \"Failed to rm %s, error %d\\n\", wine_dbgstr_w(buf), GetLastError());\n        }\n    }\n    RemoveDirectoryW(testdir);\n}", "path": "wine/dlls/ntdll/tests/directory.c", "commit_date": "2020-07-24 00:00:00", "repo_name": "ValveSoftware/wine", "stars": 1077, "license": "other", "language": "c", "size": 518660}
{"docstring": "/* Match one found file against testfiles[], increment count if found */\n", "func_signal": "static void tally_test_file(FILE_BOTH_DIRECTORY_INFORMATION *dir_info)", "code": "{\n    int i;\n    DWORD attribmask =\n      (FILE_ATTRIBUTE_SYSTEM|FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_DIRECTORY|FILE_ATTRIBUTE_REPARSE_POINT);\n    DWORD attrib = dir_info->FileAttributes & attribmask;\n    WCHAR *nameW = dir_info->FileName;\n    int namelen = dir_info->FileNameLength / sizeof(WCHAR);\n\n    for (i = 0; i < test_dir_count; i++) {\n        int len = lstrlenW(testfiles[i].name);\n        if (namelen != len || memcmp(nameW, testfiles[i].name, len*sizeof(WCHAR)))\n            continue;\n        if (!testfiles[i].attr_done) {\n            todo_wine_if (testfiles[i].todo)\n                ok (attrib == (testfiles[i].attr & attribmask), \"file %s: expected %s (%x), got %x (is your linux new enough?)\\n\", wine_dbgstr_w(testfiles[i].name), testfiles[i].description, testfiles[i].attr, attrib);\n            testfiles[i].attr_done = TRUE;\n        }\n        testfiles[i].nfound++;\n        break;\n    }\n    ok(i < test_dir_count, \"unexpected file found %s\\n\", wine_dbgstr_wn(dir_info->FileName, namelen));\n}", "path": "wine/dlls/ntdll/tests/directory.c", "commit_date": "2020-07-24 00:00:00", "repo_name": "ValveSoftware/wine", "stars": 1077, "license": "other", "language": "c", "size": 518660}
{"docstring": "/***********************************************************************\n *           ICONTITLE_SetTitlePos\n */\n", "func_signal": "static BOOL ICONTITLE_SetTitlePos( HWND hwnd, HWND owner )", "code": "{\n    WCHAR str[80];\n    HDC hDC;\n    HFONT hPrevFont;\n    RECT rect;\n    INT cx, cy;\n    POINT pt;\n\n    int length = GetWindowTextW( owner, str, ARRAY_SIZE( str ));\n\n    while (length && str[length - 1] == ' ') /* remove trailing spaces */\n        str[--length] = 0;\n\n    if( !length )\n    {\n        lstrcpyW( str, L\"<...>\" );\n        length = lstrlenW( str );\n    }\n\n    if (!(hDC = GetDC( hwnd ))) return FALSE;\n\n    hPrevFont = SelectObject( hDC, hIconTitleFont );\n\n    SetRect( &rect, 0, 0, GetSystemMetrics(SM_CXICONSPACING) -\n             GetSystemMetrics(SM_CXBORDER) * 2,\n             GetSystemMetrics(SM_CYBORDER) * 2 );\n\n    DrawTextW( hDC, str, length, &rect, DT_CALCRECT | DT_CENTER | DT_NOPREFIX | DT_WORDBREAK |\n               (( bMultiLineTitle ) ? 0 : DT_SINGLELINE) );\n\n    SelectObject( hDC, hPrevFont );\n    ReleaseDC( hwnd, hDC );\n\n    cx = rect.right - rect.left +  4 * GetSystemMetrics(SM_CXBORDER);\n    cy = rect.bottom - rect.top;\n\n    pt.x = (GetSystemMetrics(SM_CXICON) - cx) / 2;\n    pt.y = GetSystemMetrics(SM_CYICON);\n\n    /* point is relative to owner, make it relative to parent */\n    MapWindowPoints( owner, GetParent(hwnd), &pt, 1 );\n\n    SetWindowPos( hwnd, owner, pt.x, pt.y, cx, cy, SWP_NOACTIVATE );\n    return TRUE;\n}", "path": "wine/dlls/user32/icontitle.c", "commit_date": "2020-09-21 00:00:00", "repo_name": "ValveSoftware/wine", "stars": 1077, "license": "other", "language": "c", "size": 518660}
{"docstring": "/******************************************************************************\n *  alloc_handle\n *\n * Allocates a new handle to the specified object in a given handle table.\n *\n * PARAMS\n *  lpTable  [I] Pointer to the handle table, from which the new handle is \n *               allocated.\n *  lpObject [I] Pointer to the object, for which a handle shall be allocated.\n *  lpHandle [O] Pointer to a handle variable, into which the handle value will\n *               be stored. If not successful, this will be \n *               INVALID_HANDLE_VALUE\n * RETURNS\n *  TRUE,      if successful\n *  FALSE,     if not successful (no free handle)\n */\n", "func_signal": "static BOOL alloc_handle(struct handle_table *lpTable, OBJECTHDR *lpObject, HCRYPTKEY *lpHandle)", "code": "{\n    BOOL ret = FALSE;\n\n    TRACE(\"(lpTable=%p, lpObject=%p, lpHandle=%p)\\n\", lpTable, lpObject, lpHandle);\n        \n    EnterCriticalSection(&lpTable->mutex);\n    if (lpTable->iFirstFree >= lpTable->iEntries) \n        if (!grow_handle_table(lpTable))\n        {\n            *lpHandle = (HCRYPTKEY)INVALID_HANDLE_VALUE;\n            goto exit;\n        }\n\n    *lpHandle = INDEX2HANDLE(lpTable->iFirstFree);\n    \n    lpTable->paEntries[lpTable->iFirstFree].pObject = lpObject;\n    lpTable->iFirstFree = lpTable->paEntries[lpTable->iFirstFree].iNextFree;\n    InterlockedIncrement(&lpObject->refcount);\n\n    ret = TRUE;\nexit:\n    LeaveCriticalSection(&lpTable->mutex);\n    return ret;\n}", "path": "wine/dlls/rsaenh/handle.c", "commit_date": "2013-11-25 00:00:00", "repo_name": "ValveSoftware/wine", "stars": 1077, "license": "other", "language": "c", "size": 518660}
{"docstring": "/* This one adds all namespaces defined in document to a cache, without anything\n   associated with uri obviously.\n   Unfortunately namespace:: axis implementation in libxml2 differs from what we need,\n   it uses additional node type to describe namespace definition attribute while\n   in msxml it's expected to be a normal attribute - as a workaround document is\n   queried at libxml2 level here. */\n", "func_signal": "HRESULT cache_from_doc_ns(IXMLDOMSchemaCollection2 *iface, xmlnode *node)", "code": "{\n    schema_cache* This = impl_from_IXMLDOMSchemaCollection2(iface);\n    static const xmlChar query[] = \"//*/namespace::*\";\n    xmlXPathObjectPtr nodeset;\n    xmlXPathContextPtr ctxt;\n\n    This->read_only = 1;\n\n    ctxt = xmlXPathNewContext(node->node->doc);\n\n    nodeset = xmlXPathEvalExpression(query, ctxt);\n    xmlXPathFreeContext(ctxt);\n\n    if (nodeset)\n    {\n        int pos = 0, len = xmlXPathNodeSetGetLength(nodeset->nodesetval);\n\n        while (pos < len)\n        {\n            xmlNodePtr node = xmlXPathNodeSetItem(nodeset->nodesetval, pos);\n            if (node->type == XML_NAMESPACE_DECL)\n            {\n                static const xmlChar defns[] = \"http://www.w3.org/XML/1998/namespace\";\n                xmlNsPtr ns = (xmlNsPtr)node;\n                cache_entry *entry;\n\n                /* filter out default uri */\n                if (xmlStrEqual(ns->href, defns))\n                {\n                    pos++;\n                    continue;\n                }\n\n                entry = heap_alloc(sizeof(cache_entry));\n                entry->type = CacheEntryType_NS;\n                entry->ref = 1;\n                entry->schema = NULL;\n                entry->doc = NULL;\n\n                cache_add_entry(This, ns->href, entry);\n            }\n            pos++;\n        }\n\n        xmlXPathFreeObject(nodeset);\n    }\n\n    return S_OK;\n}", "path": "wine/dlls/msxml3/schema.c", "commit_date": "2019-01-15 00:00:00", "repo_name": "ValveSoftware/wine", "stars": 1077, "license": "other", "language": "c", "size": 518660}
{"docstring": "/******************************************************************************\n *  is_valid_handle\n *\n * Tests if handle is valid given the specified handle table\n * \n * PARAMS\n *  lpTable [I] Pointer to the handle table, with respect to which the handle's \n *              validness is tested.\n *  handle  [I] The handle tested for validness.\n *  dwType  [I] A magic value that identifies the referenced object's type.\n *\n * RETURNS\n *  TRUE,      if handle is valid.\n *  FALSE,     if handle is not valid.\n */\n", "func_signal": "BOOL is_valid_handle(struct handle_table *lpTable, HCRYPTKEY handle, DWORD dwType)", "code": "{\n    unsigned int index = HANDLE2INDEX(handle);\n    BOOL ret = FALSE;\n\n    TRACE(\"(lpTable=%p, handle=%ld)\\n\", lpTable, handle);\n    \n    EnterCriticalSection(&lpTable->mutex);\n        \n    /* We don't use zero handle values */\n    if (!handle) goto exit;\n \n    /* Check for index out of table bounds */    \n    if (index >= lpTable->iEntries) goto exit;\n    \n    /* Check if this handle is currently allocated */\n    if (!lpTable->paEntries[index].pObject) goto exit;\n    \n    /* Check if this handle references an object of the correct type. */\n    if (lpTable->paEntries[index].pObject->dwType != dwType) goto exit;\n\n    ret = TRUE;\nexit:\n    LeaveCriticalSection(&lpTable->mutex);\n    return ret;\n}", "path": "wine/dlls/rsaenh/handle.c", "commit_date": "2013-11-25 00:00:00", "repo_name": "ValveSoftware/wine", "stars": 1077, "license": "other", "language": "c", "size": 518660}
{"docstring": "/******************************************************************************\n *  lookup_handle\n *\n * Returns the object identified by the handle in the given handle table\n *\n * PARAMS\n *  lpTable    [I] Pointer to the handle table, in which the handle is looked up.\n *  handle     [I] The handle, which is to be looked up\n *  lplpObject [O] Pointer to the variable, into which the pointer to the\n *                 object looked up is copied.\n * RETURNS\n *  TRUE,      if successful\n *  FALSE,     if not successful (invalid handle)\n */\n", "func_signal": "BOOL lookup_handle(struct handle_table *lpTable, HCRYPTKEY handle, DWORD dwType, OBJECTHDR **lplpObject)", "code": "{\n    BOOL ret = FALSE;\n\n    TRACE(\"(lpTable=%p, handle=%ld, lplpObject=%p)\\n\", lpTable, handle, lplpObject);\n    \n    EnterCriticalSection(&lpTable->mutex);\n    if (!is_valid_handle(lpTable, handle, dwType)) \n    {\n        *lplpObject = NULL;\n        goto exit;\n    }\n    *lplpObject = lpTable->paEntries[HANDLE2INDEX(handle)].pObject;\n\n    ret = TRUE;\nexit:\n    LeaveCriticalSection(&lpTable->mutex);\n    return ret;\n}", "path": "wine/dlls/rsaenh/handle.c", "commit_date": "2013-11-25 00:00:00", "repo_name": "ValveSoftware/wine", "stars": 1077, "license": "other", "language": "c", "size": 518660}
{"docstring": "/***********************************************************************\n *              MsiSIPGetSignedDataMsg  (MSISIP.@)\n */\n", "func_signal": "BOOL WINAPI MsiSIPGetSignedDataMsg(SIP_SUBJECTINFO *pSubjectInfo,\n DWORD *pdwEncodingType, DWORD dwIndex, DWORD *pcbSignedDataMsg,\n BYTE *pbSignedDataMsg)", "code": "{\n    BOOL ret = FALSE;\n    IStorage *stg = NULL;\n    HRESULT r;\n    IStream *stm = NULL;\n    BYTE hdr[2], len[sizeof(DWORD)];\n    DWORD count, lenBytes, dataBytes;\n\n    TRACE(\"(%p %p %d %p %p)\\n\", pSubjectInfo, pdwEncodingType, dwIndex,\n          pcbSignedDataMsg, pbSignedDataMsg);\n\n    r = StgOpenStorage(pSubjectInfo->pwsFileName, NULL,\n     STGM_DIRECT|STGM_READ|STGM_SHARE_DENY_WRITE, NULL, 0, &stg);\n    if (FAILED(r))\n    {\n        TRACE(\"couldn't open %s\\n\", debugstr_w(pSubjectInfo->pwsFileName));\n        goto end;\n    }\n\n    r = IStorage_OpenStream(stg, L\"\\5DigitalSignature\", 0,\n     STGM_READ|STGM_SHARE_EXCLUSIVE, 0, &stm);\n    if (FAILED(r))\n    {\n        TRACE(\"couldn't find digital signature stream\\n\");\n        goto freestorage;\n    }\n\n    r = IStream_Read(stm, hdr, sizeof(hdr), &count);\n    if (FAILED(r) || count != sizeof(hdr))\n        goto freestream;\n    if (hdr[0] != 0x30)\n    {\n        WARN(\"unexpected data in digital sig: 0x%02x%02x\\n\", hdr[0], hdr[1]);\n        goto freestream;\n    }\n\n    /* Read the asn.1 length from the stream.  Only supports definite-length\n     * values, which DER-encoded signatures should be.\n     */\n    if (hdr[1] == 0x80)\n    {\n        WARN(\"indefinite-length encoding not supported!\\n\");\n        goto freestream;\n    }\n    else if (hdr[1] & 0x80)\n    {\n        DWORD temp;\n        LPBYTE ptr;\n\n        lenBytes = hdr[1] & 0x7f;\n        if (lenBytes > sizeof(DWORD))\n        {\n            WARN(\"asn.1 length too long (%d)\\n\", lenBytes);\n            goto freestream;\n        }\n        r = IStream_Read(stm, len, lenBytes, &count);\n        if (FAILED(r) || count != lenBytes)\n            goto freestream;\n        dataBytes = 0;\n        temp = lenBytes;\n        ptr = len;\n        while (temp--)\n        {\n            dataBytes <<= 8;\n            dataBytes |= *ptr++;\n        }\n    }\n    else\n    {\n        lenBytes = 0;\n        dataBytes = hdr[1];\n    }\n\n    if (!pbSignedDataMsg)\n    {\n        *pcbSignedDataMsg = 2 + lenBytes + dataBytes;\n        ret = TRUE;\n    }\n    else if (*pcbSignedDataMsg < 2 + lenBytes + dataBytes)\n    {\n        SetLastError(ERROR_INSUFFICIENT_BUFFER);\n        *pcbSignedDataMsg = 2 + lenBytes + dataBytes;\n    }\n    else\n    {\n        LPBYTE ptr = pbSignedDataMsg;\n\n        memcpy(ptr, hdr, sizeof(hdr));\n        ptr += sizeof(hdr);\n        if (lenBytes)\n        {\n            memcpy(ptr, len, lenBytes);\n            ptr += lenBytes;\n        }\n        r = IStream_Read(stm, ptr, dataBytes, &count);\n        if (SUCCEEDED(r) && count == dataBytes)\n        {\n            *pdwEncodingType = X509_ASN_ENCODING | PKCS_7_ASN_ENCODING;\n            *pcbSignedDataMsg = 2 + lenBytes + dataBytes;\n            ret = TRUE;\n        }\n    }\n\nfreestream:\n    IStream_Release(stm);\nfreestorage:\n    IStorage_Release(stg);\nend:\n\n    TRACE(\"returning %d\\n\", ret);\n    return ret;\n}", "path": "wine/dlls/msisip/main.c", "commit_date": "2020-10-15 00:00:00", "repo_name": "ValveSoftware/wine", "stars": 1077, "license": "other", "language": "c", "size": 518660}
{"docstring": "/******************************************************************************\n *  init_handle_table\n *\n * Initializes the HANDLETABLE structure pointed to by lpTable\n *\n * PARAMS\n *  lpTable [I] Pointer to the HANDLETABLE structure, which is to be initialized.\n *\n * NOTES\n *  You have to call destroy_handle_table when you don't need the table\n *  any more.\n */\n", "func_signal": "void init_handle_table(struct handle_table *lpTable)", "code": "{\n    TRACE(\"(lpTable=%p)\\n\", lpTable);\n        \n    lpTable->paEntries = NULL;\n    lpTable->iEntries = 0;\n    lpTable->iFirstFree = 0;\n    InitializeCriticalSection(&lpTable->mutex);\n    lpTable->mutex.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ \": HANDLETABLE.mutex\");\n}", "path": "wine/dlls/rsaenh/handle.c", "commit_date": "2013-11-25 00:00:00", "repo_name": "ValveSoftware/wine", "stars": 1077, "license": "other", "language": "c", "size": 518660}
{"docstring": "/******************************************************************************\n *  release_handle\n *\n * Releases resources occupied by the specified handle in the given table.\n * The reference count of the handled object is decremented. If it becomes\n * zero and if the 'destructor' function pointer member is non NULL, the\n * destructor function will be called. Note that release_handle does not \n * release resources other than the handle itself. If this is wanted, do it\n * in the destructor function.\n *\n * PARAMS\n *  lpTable [I] Pointer to the handle table, from which a handle is to be \n *              released.\n *  handle  [I] The handle, which is to be released\n *  dwType  [I] Identifier for the type of the object, for which a handle is\n *              to be released.\n *\n * RETURNS\n *  TRUE,      if successful\n *  FALSE,     if not successful (invalid handle)\n */\n", "func_signal": "BOOL release_handle(struct handle_table *lpTable, HCRYPTKEY handle, DWORD dwType)", "code": "{\n    unsigned int index = HANDLE2INDEX(handle);\n    OBJECTHDR *pObject;\n    BOOL ret = FALSE;\n\n    TRACE(\"(lpTable=%p, handle=%ld)\\n\", lpTable, handle);\n    \n    EnterCriticalSection(&lpTable->mutex);\n    \n    if (!is_valid_handle(lpTable, handle, dwType))\n        goto exit;\n\n    pObject = lpTable->paEntries[index].pObject;\n    if (InterlockedDecrement(&pObject->refcount) == 0)\n    {\n        TRACE(\"destroying handle %ld\\n\", handle);\n        if (pObject->destructor)\n            pObject->destructor(pObject);\n    }\n\n    lpTable->paEntries[index].pObject = NULL;\n    lpTable->paEntries[index].iNextFree = lpTable->iFirstFree;\n    lpTable->iFirstFree = index;\n\n    ret = TRUE;\nexit:\n    LeaveCriticalSection(&lpTable->mutex);\n    return ret;\n}", "path": "wine/dlls/rsaenh/handle.c", "commit_date": "2013-11-25 00:00:00", "repo_name": "ValveSoftware/wine", "stars": 1077, "license": "other", "language": "c", "size": 518660}
{"docstring": "/******************************************************************************\n *  grow_handle_table [Internal]\n *\n * Grows the number of entries in the given table by TABLE_SIZE_INCREMENT\n *\n * PARAMS \n *  lpTable [I] Pointer to the table, which is to be grown\n *\n * RETURNS\n *  TRUE,      if successful\n *  FALSE,     if not successful (out of memory on process heap)\n *\n * NOTES\n *  This is a support function for alloc_handle. Do not call!\n */\n", "func_signal": "static BOOL grow_handle_table(struct handle_table *lpTable)", "code": "{\n    struct handle_table_entry *newEntries;\n    unsigned int i, newIEntries;\n\n    newIEntries = lpTable->iEntries + TABLE_SIZE_INCREMENT;\n\n    newEntries = HeapAlloc(GetProcessHeap(), 0, sizeof(struct handle_table_entry)*newIEntries);\n    if (!newEntries)\n        return FALSE;\n\n    if (lpTable->paEntries)\n    {\n        memcpy(newEntries, lpTable->paEntries, sizeof(struct handle_table_entry)*lpTable->iEntries);\n        HeapFree(GetProcessHeap(), 0, lpTable->paEntries);\n    }\n\n    for (i=lpTable->iEntries; i<newIEntries; i++)\n    {\n        newEntries[i].pObject = NULL;\n        newEntries[i].iNextFree = i+1;\n    }\n\n    lpTable->paEntries = newEntries;\n    lpTable->iEntries = newIEntries;\n\n    return TRUE;\n}", "path": "wine/dlls/rsaenh/handle.c", "commit_date": "2013-11-25 00:00:00", "repo_name": "ValveSoftware/wine", "stars": 1077, "license": "other", "language": "c", "size": 518660}
{"docstring": "/******************************************************************************\n *  destroy_handle_table\n *\n * Destroys the handle table.\n * \n * PARAMS\n *  lpTable [I] Pointer to the handle table, which is to be destroyed.\n */\n", "func_signal": "void destroy_handle_table(struct handle_table *lpTable)", "code": "{\n    TRACE(\"(lpTable=%p)\\n\", lpTable);\n        \n    HeapFree(GetProcessHeap(), 0, lpTable->paEntries);\n    lpTable->mutex.DebugInfo->Spare[0] = 0;\n    DeleteCriticalSection(&lpTable->mutex);\n}", "path": "wine/dlls/rsaenh/handle.c", "commit_date": "2013-11-25 00:00:00", "repo_name": "ValveSoftware/wine", "stars": 1077, "license": "other", "language": "c", "size": 518660}
{"docstring": "/***********************************************************************\n *           ICONTITLE_Paint\n */\n", "func_signal": "static BOOL ICONTITLE_Paint( HWND hwnd, HWND owner, HDC hDC, BOOL bActive )", "code": "{\n    RECT rect;\n    HFONT hPrevFont;\n    HBRUSH hBrush;\n    COLORREF textColor = 0;\n\n    if( bActive )\n    {\n\thBrush = GetSysColorBrush(COLOR_ACTIVECAPTION);\n\ttextColor = GetSysColor(COLOR_CAPTIONTEXT);\n    }\n    else\n    {\n        if( GetWindowLongA( hwnd, GWL_STYLE ) & WS_CHILD )\n\t{\n\t    hBrush = (HBRUSH) GetClassLongPtrW(hwnd, GCLP_HBRBACKGROUND);\n\t    if( hBrush )\n\t    {\n\t\tINT level;\n\t\tLOGBRUSH logBrush;\n\t\tGetObjectA( hBrush, sizeof(logBrush), &logBrush );\n\t\tlevel = GetRValue(logBrush.lbColor) +\n\t\t\t   GetGValue(logBrush.lbColor) +\n\t\t\t      GetBValue(logBrush.lbColor);\n\t\tif( level < (0x7F * 3) )\n\t\t    textColor = RGB( 0xFF, 0xFF, 0xFF );\n\t    }\n\t    else\n\t\thBrush = GetStockObject( WHITE_BRUSH );\n\t}\n\telse\n\t{\n\t    hBrush = GetStockObject( BLACK_BRUSH );\n\t    textColor = RGB( 0xFF, 0xFF, 0xFF );\n\t}\n    }\n\n    GetClientRect( hwnd, &rect );\n    DPtoLP( hDC, (LPPOINT)&rect, 2 );\n    FillRect( hDC, &rect, hBrush );\n\n    hPrevFont = SelectObject( hDC, hIconTitleFont );\n    if( hPrevFont )\n    {\n\tWCHAR buffer[80];\n\n        INT length = GetWindowTextW( owner, buffer, ARRAY_SIZE( buffer ));\n        SetTextColor( hDC, textColor );\n        SetBkMode( hDC, TRANSPARENT );\n\n        DrawTextW( hDC, buffer, length, &rect, DT_CENTER | DT_NOPREFIX |\n                   DT_WORDBREAK | ((bMultiLineTitle) ? 0 : DT_SINGLELINE) );\n\n\tSelectObject( hDC, hPrevFont );\n    }\n    return (hPrevFont != 0);\n}", "path": "wine/dlls/user32/icontitle.c", "commit_date": "2020-09-21 00:00:00", "repo_name": "ValveSoftware/wine", "stars": 1077, "license": "other", "language": "c", "size": 518660}
{"docstring": "/***********************************************************************\n *           IconTitleWndProc\n */\n", "func_signal": "LRESULT WINAPI IconTitleWndProc( HWND hWnd, UINT msg,\n                                 WPARAM wParam, LPARAM lParam )", "code": "{\n    HWND owner = GetWindow( hWnd, GW_OWNER );\n\n    if (!IsWindow(hWnd)) return 0;\n\n    switch( msg )\n    {\n        case WM_CREATE:\n            if (!hIconTitleFont)\n            {\n                LOGFONTA logFont;\n                SystemParametersInfoA( SPI_GETICONTITLELOGFONT, 0, &logFont, 0 );\n                SystemParametersInfoA( SPI_GETICONTITLEWRAP, 0, &bMultiLineTitle, 0 );\n                hIconTitleFont = CreateFontIndirectA( &logFont );\n            }\n            return (hIconTitleFont ? 0 : -1);\n\tcase WM_NCHITTEST:\n\t     return HTCAPTION;\n\tcase WM_NCMOUSEMOVE:\n\tcase WM_NCLBUTTONDBLCLK:\n\t     return SendMessageW( owner, msg, wParam, lParam );\n\tcase WM_ACTIVATE:\n\t     if( wParam ) SetActiveWindow( owner );\n             return 0;\n\tcase WM_CLOSE:\n\t     return 0;\n\tcase WM_SHOWWINDOW:\n             if (wParam) ICONTITLE_SetTitlePos( hWnd, owner );\n\t     return 0;\n\tcase WM_ERASEBKGND:\n            if( GetWindowLongW( owner, GWL_STYLE ) & WS_CHILD )\n                lParam = SendMessageW( owner, WM_ISACTIVEICON, 0, 0 );\n            else\n                lParam = (owner == GetActiveWindow());\n            if( ICONTITLE_Paint( hWnd, owner, (HDC)wParam, (BOOL)lParam ) )\n                ValidateRect( hWnd, NULL );\n            return 1;\n    }\n    return DefWindowProcW( hWnd, msg, wParam, lParam );\n}", "path": "wine/dlls/user32/icontitle.c", "commit_date": "2020-09-21 00:00:00", "repo_name": "ValveSoftware/wine", "stars": 1077, "license": "other", "language": "c", "size": 518660}
{"docstring": "/* returns index or -1 if not found */\n", "func_signal": "static int cache_free_uri(schema_cache *cache, const xmlChar *uri)", "code": "{\n    int i;\n\n    for (i = 0; i < cache->count; i++)\n        if (xmlStrEqual(cache->uris[i], uri))\n        {\n            heap_free(cache->uris[i]);\n            return i;\n        }\n\n    return -1;\n}", "path": "wine/dlls/msxml3/schema.c", "commit_date": "2019-01-15 00:00:00", "repo_name": "ValveSoftware/wine", "stars": 1077, "license": "other", "language": "c", "size": 518660}
{"docstring": "/***********************************************************************\n *              MsiSIPIsMyTypeOfFile (MSISIP.@)\n */\n", "func_signal": "BOOL WINAPI MsiSIPIsMyTypeOfFile(WCHAR *name, GUID *subject)", "code": "{\n    BOOL ret = FALSE;\n    IStorage *stg = NULL;\n    HRESULT r;\n\n    TRACE(\"(%s, %p)\\n\", debugstr_w(name), subject);\n\n    r = StgOpenStorage(name, NULL, STGM_DIRECT|STGM_READ|STGM_SHARE_DENY_WRITE,\n     NULL, 0, &stg);\n    if (SUCCEEDED(r))\n    {\n        STATSTG stat;\n\n        r = IStorage_Stat(stg, &stat, STATFLAG_NONAME);\n        if (SUCCEEDED(r))\n        {\n            if (IsEqualGUID(&stat.clsid, &CLSID_MsiDatabase) ||\n             IsEqualGUID(&stat.clsid, &CLSID_MsiPatch) ||\n             IsEqualGUID(&stat.clsid, &CLSID_MsiTransform))\n            {\n                ret = TRUE;\n                *subject = mySubject;\n            }\n        }\n        IStorage_Release(stg);\n    }\n    return ret;\n}", "path": "wine/dlls/msisip/main.c", "commit_date": "2020-10-15 00:00:00", "repo_name": "ValveSoftware/wine", "stars": 1077, "license": "other", "language": "c", "size": 518660}
{"docstring": "/* CONFIG_RTW_NAPI */\n", "func_signal": "inline void dbg_rtw_skb_queue_purge(struct sk_buff_head *list, enum mstat_f flags, const char *func, int line)", "code": "{\n\tstruct sk_buff *skb;\n\n\twhile ((skb = skb_dequeue(list)) != NULL)\n\t\tdbg_rtw_skb_free(skb, flags, func, line);\n}", "path": "RTL88x2BU-Linux-Driver/os_dep/osdep_service.c", "commit_date": "2020-11-20 00:00:00", "repo_name": "RinCat/RTL88x2BU-Linux-Driver", "stars": 1122, "license": "gpl-2.0", "language": "c", "size": 8634}
{"docstring": "/*\n\nCaller must check if the list is empty before calling rtw_list_delete\n\n*/\n", "func_signal": "void _rtw_init_sema(_sema\t*sema, int init_val)", "code": "{\n\n#ifdef PLATFORM_LINUX\n\n\tsema_init(sema, init_val);\n\n#endif\n#ifdef PLATFORM_FREEBSD\n\tsema_init(sema, init_val, \"rtw_drv\");\n#endif\n#ifdef PLATFORM_OS_XP\n\n\tKeInitializeSemaphore(sema, init_val,  SEMA_UPBND); /* count=0; */\n\n#endif\n\n#ifdef PLATFORM_OS_CE\n\tif (*sema == NULL)\n\t\t*sema = CreateSemaphore(NULL, init_val, SEMA_UPBND, NULL);\n#endif\n\n}", "path": "RTL88x2BU-Linux-Driver/os_dep/osdep_service.c", "commit_date": "2020-11-20 00:00:00", "repo_name": "RinCat/RTL88x2BU-Linux-Driver", "stars": 1122, "license": "gpl-2.0", "language": "c", "size": 8634}
{"docstring": "/* set ODM_CMNINFO_IC_TYPE based on chip_type */\n", "func_signal": "void rtw_odm_init_ic_type(_adapter *adapter)", "code": "{\n\tstruct dm_struct *odm = adapter_to_phydm(adapter);\n\tu32 ic_type = chip_type_to_odm_ic_type(rtw_get_chip_type(adapter));\n\n\trtw_warn_on(!ic_type);\n\n\todm_cmn_info_init(odm, ODM_CMNINFO_IC_TYPE, ic_type);\n}", "path": "RTL88x2BU-Linux-Driver/core/rtw_odm.c", "commit_date": "2020-08-02 00:00:00", "repo_name": "RinCat/RTL88x2BU-Linux-Driver", "stars": 1122, "license": "gpl-2.0", "language": "c", "size": 8634}
{"docstring": "/*\n* Test if the specifi @param path is a direct and readable\n* @param path the path of the direct to test\n* @return _TRUE or _FALSE\n*/\n", "func_signal": "int rtw_is_dir_readable(const char *path)", "code": "{\n#ifdef PLATFORM_LINUX\n\tif (isDirReadable(path, NULL) == 0)\n\t\treturn _TRUE;\n\telse\n\t\treturn _FALSE;\n#else\n\t/* Todo... */\n\treturn _FALSE;\n#endif\n}", "path": "RTL88x2BU-Linux-Driver/os_dep/osdep_service.c", "commit_date": "2020-11-20 00:00:00", "repo_name": "RinCat/RTL88x2BU-Linux-Driver", "stars": 1122, "license": "gpl-2.0", "language": "c", "size": 8634}
{"docstring": "/*\n* Translate the OS dependent @param error_code to OS independent RTW_STATUS_CODE\n* @return: one of RTW_STATUS_CODE\n*/\n", "func_signal": "inline int RTW_STATUS_CODE(int error_code)", "code": "{\n\tif (error_code >= 0)\n\t\treturn _SUCCESS;\n\n\tswitch (error_code) {\n\t/* case -ETIMEDOUT: */\n\t/*\treturn RTW_STATUS_TIMEDOUT; */\n\tdefault:\n\t\treturn _FAIL;\n\t}\n}", "path": "RTL88x2BU-Linux-Driver/os_dep/osdep_service.c", "commit_date": "2020-11-20 00:00:00", "repo_name": "RinCat/RTL88x2BU-Linux-Driver", "stars": 1122, "license": "gpl-2.0", "language": "c", "size": 8634}
{"docstring": "/**\n * rtw_cbuf_push - push a pointer into cbuf\n * @cbuf: pointer of struct rtw_cbuf\n * @buf: pointer to push in\n *\n * Lock free operation, be careful of the use scheme\n * Returns: _TRUE push success\n */\n", "func_signal": "bool rtw_cbuf_push(struct rtw_cbuf *cbuf, void *buf)", "code": "{\n\tif (rtw_cbuf_full(cbuf))\n\t\treturn _FAIL;\n\n\tif (0)\n\t\tRTW_INFO(\"%s on %u\\n\", __func__, cbuf->write);\n\tcbuf->bufs[cbuf->write] = buf;\n\tcbuf->write = (cbuf->write + 1) % cbuf->size;\n\n\treturn _SUCCESS;\n}", "path": "RTL88x2BU-Linux-Driver/os_dep/osdep_service.c", "commit_date": "2020-11-20 00:00:00", "repo_name": "RinCat/RTL88x2BU-Linux-Driver", "stars": 1122, "license": "gpl-2.0", "language": "c", "size": 8634}
{"docstring": "/* CONFIG_RTW_NAPI */\n", "func_signal": "void _rtw_skb_queue_purge(struct sk_buff_head *list)", "code": "{\n\tstruct sk_buff *skb;\n\n\twhile ((skb = skb_dequeue(list)) != NULL)\n\t\t_rtw_skb_free(skb);\n}", "path": "RTL88x2BU-Linux-Driver/os_dep/osdep_service.c", "commit_date": "2020-11-20 00:00:00", "repo_name": "RinCat/RTL88x2BU-Linux-Driver", "stars": 1122, "license": "gpl-2.0", "language": "c", "size": 8634}
{"docstring": "/**\n* is_null -\n*\n* Return\tTRUE if c is null character\n*\t\tFALSE otherwise.\n*/\n", "func_signal": "inline BOOLEAN is_null(char c)", "code": "{\n\tif (c == '\\0')\n\t\treturn _TRUE;\n\telse\n\t\treturn _FALSE;\n}", "path": "RTL88x2BU-Linux-Driver/os_dep/osdep_service.c", "commit_date": "2020-11-20 00:00:00", "repo_name": "RinCat/RTL88x2BU-Linux-Driver", "stars": 1122, "license": "gpl-2.0", "language": "c", "size": 8634}
{"docstring": "/*\n* Test if the specifi @param path is a file and readable\n* @param path the path of the file to test\n* @return _TRUE or _FALSE\n*/\n", "func_signal": "int rtw_is_file_readable(const char *path)", "code": "{\n#ifdef PLATFORM_LINUX\n\tif (isFileReadable(path, NULL) == 0)\n\t\treturn _TRUE;\n\telse\n\t\treturn _FALSE;\n#else\n\t/* Todo... */\n\treturn _FALSE;\n#endif\n}", "path": "RTL88x2BU-Linux-Driver/os_dep/osdep_service.c", "commit_date": "2020-11-20 00:00:00", "repo_name": "RinCat/RTL88x2BU-Linux-Driver", "stars": 1122, "license": "gpl-2.0", "language": "c", "size": 8634}
{"docstring": "/**\n * rtw_cbuf_pop - pop a pointer from cbuf\n * @cbuf: pointer of struct rtw_cbuf\n *\n * Lock free operation, be careful of the use scheme\n * Returns: pointer popped out\n */\n", "func_signal": "void *rtw_cbuf_pop(struct rtw_cbuf *cbuf)", "code": "{\n\tvoid *buf;\n\tif (rtw_cbuf_empty(cbuf))\n\t\treturn NULL;\n\n\tif (0)\n\t\tRTW_INFO(\"%s on %u\\n\", __func__, cbuf->read);\n\tbuf = cbuf->bufs[cbuf->read];\n\tcbuf->read = (cbuf->read + 1) % cbuf->size;\n\n\treturn buf;\n}", "path": "RTL88x2BU-Linux-Driver/os_dep/osdep_service.c", "commit_date": "2020-11-20 00:00:00", "repo_name": "RinCat/RTL88x2BU-Linux-Driver", "stars": 1122, "license": "gpl-2.0", "language": "c", "size": 8634}
{"docstring": "/*\n* Open the file with @param path and retrive the file content into memory starting from @param buf for @param sz at most\n* @param path the path of the file to open and read\n* @param buf the starting address of the buffer to store file content\n* @param sz how many bytes to read at most\n* @return the byte we've read\n*/\n", "func_signal": "int rtw_retrieve_from_file(const char *path, u8 *buf, u32 sz)", "code": "{\n#ifdef PLATFORM_LINUX\n\tint ret = retriveFromFile(path, buf, sz);\n\treturn ret >= 0 ? ret : 0;\n#else\n\t/* Todo... */\n\treturn 0;\n#endif\n}", "path": "RTL88x2BU-Linux-Driver/os_dep/osdep_service.c", "commit_date": "2020-11-20 00:00:00", "repo_name": "RinCat/RTL88x2BU-Linux-Driver", "stars": 1122, "license": "gpl-2.0", "language": "c", "size": 8634}
{"docstring": "/*\n* Close the file with the specific @param fp\n* @param fp the pointer of struct file to close\n* @return always 0\n*/\n", "func_signal": "static int closeFile(struct file *fp)", "code": "{\n\tfilp_close(fp, NULL);\n\treturn 0;\n}", "path": "RTL88x2BU-Linux-Driver/os_dep/osdep_service.c", "commit_date": "2020-11-20 00:00:00", "repo_name": "RinCat/RTL88x2BU-Linux-Driver", "stars": 1122, "license": "gpl-2.0", "language": "c", "size": 8634}
{"docstring": "/*\n* Test if the specifi @param pathname is a direct and readable\n* If readable, @param sz is not used\n* @param pathname the name of the path to test\n* @return Linux specific error code\n*/\n", "func_signal": "static int isDirReadable(const char *pathname, u32 *sz)", "code": "{\n\tstruct path path;\n\tint error = 0;\n\n\treturn kern_path(pathname, LOOKUP_FOLLOW, &path);\n}", "path": "RTL88x2BU-Linux-Driver/os_dep/osdep_service.c", "commit_date": "2020-11-20 00:00:00", "repo_name": "RinCat/RTL88x2BU-Linux-Driver", "stars": 1122, "license": "gpl-2.0", "language": "c", "size": 8634}
{"docstring": "/**\n* is_space -\n*\n* Return\tTRUE if c is represent for space\n*\t\tFALSE otherwise.\n*/\n", "func_signal": "inline BOOLEAN is_space(char c)", "code": "{\n\tif (c == ' ' || c == '\\t')\n\t\treturn _TRUE;\n\telse\n\t\treturn _FALSE;\n}", "path": "RTL88x2BU-Linux-Driver/os_dep/osdep_service.c", "commit_date": "2020-11-20 00:00:00", "repo_name": "RinCat/RTL88x2BU-Linux-Driver", "stars": 1122, "license": "gpl-2.0", "language": "c", "size": 8634}
{"docstring": "/*\n * Copy a buffer from userspace and write into kernel address\n * space.\n *\n * This emulation just calls the FreeBSD copyin function (to\n * copy data from user space buffer into a kernel space buffer)\n * and is designed to be used with the above io_write_wrapper.\n *\n * This function should return the number of bytes not copied.\n * I.e. success results in a zero value.\n * Negative error values are not returned.\n */\n", "func_signal": "unsigned long\ncopy_from_user(void *to, const void *from, unsigned long n)", "code": "{\n\tif (copyin(from, to, n) != 0) {\n\t\t/* Any errors will be treated as a failure\n\t\t   to copy any of the requested bytes */\n\t\treturn n;\n\t}\n\n\treturn 0;\n}", "path": "RTL88x2BU-Linux-Driver/os_dep/osdep_service.c", "commit_date": "2020-11-20 00:00:00", "repo_name": "RinCat/RTL88x2BU-Linux-Driver", "stars": 1122, "license": "gpl-2.0", "language": "c", "size": 8634}
{"docstring": "/*\n * The usb_register and usb_deregister functions are used to register\n * usb drivers with the usb subsystem. In this compatibility layer\n * emulation a list of drivers (struct usb_driver) is maintained\n * and is used for probing/attaching etc.\n *\n * usb_register and usb_deregister simply call these functions.\n */\n", "func_signal": "int\nusb_register(struct usb_driver *driver)", "code": "{\n\trtw_usb_linux_register(driver);\n\treturn 0;\n}", "path": "RTL88x2BU-Linux-Driver/os_dep/osdep_service.c", "commit_date": "2020-11-20 00:00:00", "repo_name": "RinCat/RTL88x2BU-Linux-Driver", "stars": 1122, "license": "gpl-2.0", "language": "c", "size": 8634}
{"docstring": "/* PLATFORM_FREEBSD */\n", "func_signal": "void\t_rtw_spinlock(_lock\t*plock)", "code": "{\n\n#ifdef PLATFORM_LINUX\n\n\tspin_lock(plock);\n\n#endif\n#ifdef PLATFORM_FREEBSD\n\tmtx_lock(plock);\n#endif\n#ifdef PLATFORM_WINDOWS\n\n\tNdisAcquireSpinLock(plock);\n\n#endif\n\n}", "path": "RTL88x2BU-Linux-Driver/os_dep/osdep_service.c", "commit_date": "2020-11-20 00:00:00", "repo_name": "RinCat/RTL88x2BU-Linux-Driver", "stars": 1122, "license": "gpl-2.0", "language": "c", "size": 8634}
{"docstring": "/*\n* Test if the specifi @param path is a readable file with valid size.\n* If readable, @param sz is got\n* @param path the path of the file to test\n* @return _TRUE or _FALSE\n*/\n", "func_signal": "int rtw_readable_file_sz_chk(const char *path, u32 sz)", "code": "{\n\tu32 fsz;\n\n\tif (rtw_is_file_readable_with_size(path, &fsz) == _FALSE)\n\t\treturn _FALSE;\n\n\tif (fsz > sz)\n\t\treturn _FALSE;\n\t\n\treturn _TRUE;\n}", "path": "RTL88x2BU-Linux-Driver/os_dep/osdep_service.c", "commit_date": "2020-11-20 00:00:00", "repo_name": "RinCat/RTL88x2BU-Linux-Driver", "stars": 1122, "license": "gpl-2.0", "language": "c", "size": 8634}
{"docstring": "/* PLATFORM_FREEBSD */\n", "func_signal": "inline struct sk_buff *_rtw_skb_alloc(u32 sz)", "code": "{\n#ifdef PLATFORM_LINUX\n\treturn __dev_alloc_skb(sz, in_interrupt() ? GFP_ATOMIC : GFP_KERNEL);\n#endif /* PLATFORM_LINUX */\n\n#ifdef PLATFORM_FREEBSD\n\treturn dev_alloc_skb(sz);\n#endif /* PLATFORM_FREEBSD */\n}", "path": "RTL88x2BU-Linux-Driver/os_dep/osdep_service.c", "commit_date": "2020-11-20 00:00:00", "repo_name": "RinCat/RTL88x2BU-Linux-Driver", "stars": 1122, "license": "gpl-2.0", "language": "c", "size": 8634}
{"docstring": "/*\n* Open the file with @param path and wirte @param sz byte of data starting from @param buf into the file\n* @param path the path of the file to open and write\n* @param buf the starting address of the data to write into file\n* @param sz how many bytes to write at most\n* @return the byte we've written\n*/\n", "func_signal": "int rtw_store_to_file(const char *path, u8 *buf, u32 sz)", "code": "{\n#ifdef PLATFORM_LINUX\n\tint ret = storeToFile(path, buf, sz);\n\treturn ret >= 0 ? ret : 0;\n#else\n\t/* Todo... */\n\treturn 0;\n#endif\n}", "path": "RTL88x2BU-Linux-Driver/os_dep/osdep_service.c", "commit_date": "2020-11-20 00:00:00", "repo_name": "RinCat/RTL88x2BU-Linux-Driver", "stars": 1122, "license": "gpl-2.0", "language": "c", "size": 8634}
{"docstring": "/*******************************************************************************\n **\n ** Function         app_mgr_write_remote_devices\n **\n ** Description      This function is used to write the XML bluetooth remote device file\n **\n ** Returns          void\n **\n *******************************************************************************/\n", "func_signal": "int app_mgr_write_remote_devices(void)", "code": "{\n    int status;\n\n    status = app_xml_write_db(APP_XML_REM_DEVICES_FILE_PATH, app_xml_remote_devices_db,\n            APP_NUM_ELEMENTS(app_xml_remote_devices_db));\n\n    if (status < 0)\n    {\n        BT_LOGE(\"app_xml_write_db failed:%d\", status);\n        return -1;\n    }\n    else\n    {\n        BT_LOGD(\"app_xml_write_db ok\");\n    }\n    return 0;\n}", "path": "yodaos/hardware/modules/bluetooth/bsa_ampak/app_manager.c", "commit_date": "2019-11-14 00:00:00", "repo_name": "yodaos-project/yodaos", "stars": 1182, "license": "apache-2.0", "language": "c", "size": 73276}
{"docstring": "/*******************************************************************************\n **\n ** Function         app_mgr_set_connectable\n **\n ** Description      Set the device connectable for a specific time\n **\n ** Parameters\n **\n ** Returns          void\n **\n *******************************************************************************/\n", "func_signal": "void app_mgr_set_connectable(void)", "code": "{\n    tBSA_DM_SET_CONFIG bsa_dm_set_config;\n    if (BSA_DmSetConfigInit(&bsa_dm_set_config) != BSA_SUCCESS)\n    {\n        BT_LOGE(\"BSA_DmSetConfigInit failed\");\n        return;\n    }\n    bsa_dm_set_config.connectable = 1;\n    bsa_dm_set_config.config_mask = BSA_DM_CONFIG_VISIBILITY_MASK;\n    if (BSA_DmSetConfig(&bsa_dm_set_config) != BSA_SUCCESS)\n    {\n        BT_LOGE(\"BSA_DmSetConfig failed\");\n        return;\n    }\n}", "path": "yodaos/hardware/modules/bluetooth/bsa_ampak/app_manager.c", "commit_date": "2019-11-14 00:00:00", "repo_name": "yodaos-project/yodaos", "stars": 1182, "license": "apache-2.0", "language": "c", "size": 73276}
{"docstring": "/*******************************************************************************\n **\n ** Function        app_mgr_get_dual_stack_mode_desc\n **\n ** Description     Get Dual Stack Mode description\n **\n ** Parameters      None\n **\n ** Returns         Description string\n **\n *******************************************************************************/\n", "func_signal": "char *app_mgr_get_dual_stack_mode_desc(void)", "code": "{\n    switch(app_mgr_cb.dual_stack_mode)\n    {\n    case BSA_DM_DUAL_STACK_MODE_BSA:\n        return \"DUAL_STACK_MODE_BSA\";\n    case BSA_DM_DUAL_STACK_MODE_MM:\n        return \"DUAL_STACK_MODE_MM/Kernel\";\n    case BSA_DM_DUAL_STACK_MODE_BTC:\n        return \"DUAL_STACK_MODE_BTC\";\n    default:\n        return \"Unknown Dual Stack Mode\";\n    }\n}", "path": "yodaos/hardware/modules/bluetooth/bsa_ampak/app_manager.c", "commit_date": "2019-11-14 00:00:00", "repo_name": "yodaos-project/yodaos", "stars": 1182, "license": "apache-2.0", "language": "c", "size": 73276}
{"docstring": "/*******************************************************************************\n **\n ** Function         app_mgr_set_non_discoverable\n **\n ** Description      Set the device non discoverable\n **\n ** Parameters\n **\n ** Returns          void\n **\n *******************************************************************************/\n", "func_signal": "void app_mgr_set_non_discoverable(void)", "code": "{\n    tBSA_DM_SET_CONFIG bsa_dm_set_config;\n    if (BSA_DmSetConfigInit(&bsa_dm_set_config) != BSA_SUCCESS)\n    {\n        BT_LOGE(\"BSA_DmSetConfigInit failed\");\n        return;\n    }\n    bsa_dm_set_config.discoverable = 0;\n    bsa_dm_set_config.config_mask = BSA_DM_CONFIG_VISIBILITY_MASK;\n    if (BSA_DmSetConfig(&bsa_dm_set_config) != BSA_SUCCESS)\n    {\n        BT_LOGE(\"BSA_DmSetConfig failed\");\n        return;\n    }\n}", "path": "yodaos/hardware/modules/bluetooth/bsa_ampak/app_manager.c", "commit_date": "2019-11-14 00:00:00", "repo_name": "yodaos-project/yodaos", "stars": 1182, "license": "apache-2.0", "language": "c", "size": 73276}
{"docstring": "/*******************************************************************************\n **\n ** Function         app_mgr_read_oob\n **\n ** Description      This function is used to read local OOB data from local controller\n **\n ** Parameters\n **\n ** Returns          void\n **\n *******************************************************************************/\n", "func_signal": "void app_mgr_read_oob_data()", "code": "{\n    tBSA_SEC_READ_OOB bsa_sec_read_oob;\n    if (BSA_SecReadOOBInit(&bsa_sec_read_oob) != BSA_SUCCESS)\n    {\n        BT_LOGE(\"BSA_DmSetConfigInit failed\");\n        return;\n    }\n\n    if (BSA_SecReadOOB(&bsa_sec_read_oob) != BSA_SUCCESS)\n    {\n        BT_LOGE(\"BSA_DmSetConfig failed\");\n        return;\n    }\n}", "path": "yodaos/hardware/modules/bluetooth/bsa_ampak/app_manager.c", "commit_date": "2019-11-14 00:00:00", "repo_name": "yodaos-project/yodaos", "stars": 1182, "license": "apache-2.0", "language": "c", "size": 73276}
{"docstring": "/*******************************************************************************\n **\n ** Function         app_mgr_security_callback\n **\n ** Description      Security callback\n **\n ** Parameters\n **\n ** Returns          void\n **\n *******************************************************************************/\n", "func_signal": "void app_mgr_security_callback(tBSA_SEC_EVT event, tBSA_SEC_MSG *p_data)", "code": "{\n    int status;\n    int indexDisc;\n    tBSA_SEC_PIN_CODE_REPLY pin_code_reply;\n    tBSA_SEC_AUTH_REPLY autorize_reply;\n\n    BT_LOGD(\"event:%d\", event);\n\n    switch(event)\n    {\n    case BSA_SEC_LINK_UP_EVT:       /* A device is physically connected (for info) */\n        BT_LOGI(\"BSA_SEC_LINK_UP_EVT bd_addr: %02x:%02x:%02x:%02x:%02x:%02x\",\n                p_data->link_up.bd_addr[0], p_data->link_up.bd_addr[1],\n                p_data->link_up.bd_addr[2], p_data->link_up.bd_addr[3],\n                p_data->link_up.bd_addr[4], p_data->link_up.bd_addr[5]);\n\n        BT_LOGI(\"ClassOfDevice:%02x:%02x:%02x => %s\",\n                p_data->link_up.class_of_device[0],\n                p_data->link_up.class_of_device[1],\n                p_data->link_up.class_of_device[2],\n                app_get_cod_string(p_data->link_up.class_of_device));\n#if (defined(BLE_INCLUDED) && BLE_INCLUDED == TRUE)\n        BT_LOGD(\"LinkType: %d\", p_data->link_up.link_type);\n#endif\n        if (rokidbt_a2dp_sink_get_open_pending_addr(_global_bt_ctx, A2DP_SINK_OPEN_PENDING_LINK_ADDR) == 1) {\n            if (bdcmp(A2DP_SINK_OPEN_PENDING_LINK_ADDR, p_data->link_up.bd_addr) == 0) {\n                A2DP_SINK_OPEN_PENDING_LINK_UP = 1;\n                BT_LOGI(\"A2DP_SINK_OPEN_PENDING_LINK_UP\");\n            }\n        }\n\n        break;\n    case BSA_SEC_LINK_DOWN_EVT:     /* A device is physically disconnected (for info)*/\n        BT_LOGI(\"BSA_SEC_LINK_DOWN_EVT bd_addr: %02x:%02x:%02x:%02x:%02x:%02x\",\n                p_data->link_down.bd_addr[0], p_data->link_down.bd_addr[1],\n                p_data->link_down.bd_addr[2], p_data->link_down.bd_addr[3],\n                p_data->link_down.bd_addr[4], p_data->link_down.bd_addr[5]);\n        BT_LOGI(\"Reason: %d\", p_data->link_down.status);\n#if (defined(BLE_INCLUDED) && BLE_INCLUDED == TRUE)\n        BT_LOGD(\"LinkType: %d\", p_data->link_down.link_type);\n#endif\n\n        if (bdcmp(A2DP_SINK_OPEN_PENDING_LINK_ADDR, p_data->link_down.bd_addr) == 0) {\n            A2DP_SINK_OPEN_PENDING_LINK_UP = 0;\n            BT_LOGI(\"A2DP_SINK_OPEN_PENDING_LINK down\");\n        }\n\n        break;\n\n    case BSA_SEC_PIN_REQ_EVT:\n        BT_LOGD(\"BSA_SEC_PIN_REQ_EVT (Pin Code Request) received from: %02x:%02x:%02x:%02x:%02x:%02x\",\n                p_data->pin_req.bd_addr[0], p_data->pin_req.bd_addr[1],\n                p_data->pin_req.bd_addr[2], p_data->pin_req.bd_addr[3],\n                p_data->pin_req.bd_addr[4],p_data->pin_req.bd_addr[5]);\n\n        BT_LOGD(\"call BSA_SecPinCodeReply pin:%s len:%d\",\n                app_xml_config.pin_code, app_xml_config.pin_len);\n\n        BSA_SecPinCodeReplyInit(&pin_code_reply);\n        bdcpy(pin_code_reply.bd_addr, p_data->pin_req.bd_addr);\n        pin_code_reply.pin_len = app_xml_config.pin_len;\n        strncpy((char *)pin_code_reply.pin_code, (char *)app_xml_config.pin_code,\n                app_xml_config.pin_len);\n        /* note that this code will not work if pin_len = 16 */\n        pin_code_reply.pin_code[PIN_CODE_LEN-1] = '\\0';\n        status = BSA_SecPinCodeReply(&pin_code_reply);\n        break;\n\n    case BSA_SEC_AUTH_CMPL_EVT:\n        BT_LOGD(\"BSA_SEC_AUTH_CMPL_EVT (name=%s,success=%d)\",\n                   p_data->auth_cmpl.bd_name, p_data->auth_cmpl.success);\n        if (!p_data->auth_cmpl.success)\n        {\n            BT_LOGD(\"    fail_reason=%d\", p_data->auth_cmpl.fail_reason);\n        }\n        BT_LOGD(\"    bd_addr:%02x:%02x:%02x:%02x:%02x:%02x\",\n                p_data->auth_cmpl.bd_addr[0], p_data->auth_cmpl.bd_addr[1], p_data->auth_cmpl.bd_addr[2],\n                p_data->auth_cmpl.bd_addr[3], p_data->auth_cmpl.bd_addr[4], p_data->auth_cmpl.bd_addr[5]);\n        if (p_data->auth_cmpl.key_present != FALSE)\n        {\n            BT_LOGD(\"    LinkKey:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\",\n                    p_data->auth_cmpl.key[0], p_data->auth_cmpl.key[1], p_data->auth_cmpl.key[2], p_data->auth_cmpl.key[3],\n                    p_data->auth_cmpl.key[4], p_data->auth_cmpl.key[5], p_data->auth_cmpl.key[6], p_data->auth_cmpl.key[7],\n                    p_data->auth_cmpl.key[8], p_data->auth_cmpl.key[9], p_data->auth_cmpl.key[10], p_data->auth_cmpl.key[11],\n                    p_data->auth_cmpl.key[12], p_data->auth_cmpl.key[13], p_data->auth_cmpl.key[14], p_data->auth_cmpl.key[15]);\n        }\n\n        /* If success */\n        if (p_data->auth_cmpl.success != 0)\n        {\n            /* Read the Remote device xml file to have a fresh view */\n            app_mgr_read_remote_devices();\n\n            if (strlen((char *)p_data->auth_cmpl.bd_name) > 0) {\n                app_xml_update_name_db(app_xml_remote_devices_db,\n                                       APP_NUM_ELEMENTS(app_xml_remote_devices_db),\n                                       p_data->auth_cmpl.bd_addr,\n                                       p_data->auth_cmpl.bd_name);\n            }\n\n            if (p_data->auth_cmpl.key_present != FALSE)\n            {\n                app_xml_update_key_db(app_xml_remote_devices_db,\n                                      APP_NUM_ELEMENTS(app_xml_remote_devices_db),\n                                      p_data->auth_cmpl.bd_addr,\n                                      p_data->auth_cmpl.key,\n                                      p_data->auth_cmpl.key_type);\n            }\n\n            /* Unfortunately, the BSA_SEC_AUTH_CMPL_EVT does not contain COD, let's look in the Discovery database */\n            for (indexDisc = 0 ; indexDisc < BT_DISC_NB_DEVICES ; indexDisc++)\n            {\n                if ((_global_bt_ctx->discovery_devs[indexDisc].in_use != FALSE) && \n                    (bdcmp(_global_bt_ctx->discovery_devs[indexDisc].device.bd_addr, p_data->auth_cmpl.bd_addr) == 0))\n\n                {\n                    app_xml_update_cod_db(app_xml_remote_devices_db,\n                                          APP_NUM_ELEMENTS(app_xml_remote_devices_db),\n                                          p_data->auth_cmpl.bd_addr,\n                                          _global_bt_ctx->discovery_devs[indexDisc].device.class_of_device);\n                }\n            }\n\n            status = app_mgr_write_remote_devices();\n            if (status < 0)\n            {\n                BT_LOGE(\"app_mgr_write_remote_devices failed:%d\", status);\n            }\n\n#ifdef BSA_PEER_IOS\n            /* Start device info discovery */\n            //app_disc_start_dev_info(p_data->auth_cmpl.bd_addr, NULL);\n#endif\n        }\n        break;\n\n    case BSA_SEC_BOND_CANCEL_CMPL_EVT:\n        BT_LOGD(\"BSA_SEC_BOND_CANCEL_CMPL_EVT status=%d\",\n                   p_data->bond_cancel.status);\n        break;\n\n    case BSA_SEC_AUTHORIZE_EVT:  /* Authorization request */\n        BT_LOGD(\"BSA_SEC_AUTHORIZE_EVT\");\n        BT_LOGD(\"    Remote device:%s\", p_data->authorize.bd_name);\n        BT_LOGD(\"    bd_addr: %02x:%02x:%02x:%02x:%02x:%02x\",\n                p_data->authorize.bd_addr[0], p_data->authorize.bd_addr[1],\n                p_data->authorize.bd_addr[2], p_data->authorize.bd_addr[3],\n                p_data->authorize.bd_addr[4],p_data->authorize.bd_addr[5]);\n        BT_LOGD(\"    Request access to service:%x (%s)\",\n                (int)p_data->authorize.service,\n                app_service_id_to_string(p_data->authorize.service));\n        BT_LOGD(\"    Access Granted (permanently)\");\n        status = BSA_SecAuthorizeReplyInit(&autorize_reply);\n        bdcpy(autorize_reply.bd_addr, p_data->authorize.bd_addr);\n        autorize_reply.trusted_service = p_data->authorize.service;\n        autorize_reply.auth = BSA_SEC_AUTH_PERM;\n        status = BSA_SecAuthorizeReply(&autorize_reply);\n        /*\n         * Update XML database\n         */\n        /* Read the Remote device xml file to have a fresh view */\n        app_mgr_read_remote_devices();\n        /* Add AV service for this devices in XML database */\n        app_xml_add_trusted_services_db(app_xml_remote_devices_db,\n                APP_NUM_ELEMENTS(app_xml_remote_devices_db), p_data->authorize.bd_addr,\n                1 << p_data->authorize.service);\n\n        if (strlen((char *)p_data->authorize.bd_name) > 0)\n            app_xml_update_name_db(app_xml_remote_devices_db,\n                    APP_NUM_ELEMENTS(app_xml_remote_devices_db),\n                    p_data->authorize.bd_addr, p_data->authorize.bd_name);\n\n        /* Update database => write on disk */\n        status = app_mgr_write_remote_devices();\n        if (status < 0)\n        {\n            BT_LOGE(\"app_mgr_write_remote_devices failed:%d\", status);\n        }\n        break;\n\n    case BSA_SEC_SP_CFM_REQ_EVT: /* Simple Pairing confirm request */\n        BT_LOGD(\"BSA_SEC_SP_CFM_REQ_EVT\");\n        BT_LOGD(\"    Remote device:%s\", p_data->cfm_req.bd_name);\n        BT_LOGD(\"    bd_addr: %02x:%02x:%02x:%02x:%02x:%02x\",\n                p_data->cfm_req.bd_addr[0], p_data->cfm_req.bd_addr[1],\n                p_data->cfm_req.bd_addr[2], p_data->cfm_req.bd_addr[3],\n                p_data->cfm_req.bd_addr[4], p_data->cfm_req.bd_addr[5]);\n\n        BT_LOGD(\"    ClassOfDevice:%02x:%02x:%02x => %s\",\n                p_data->cfm_req.class_of_device[0], p_data->cfm_req.class_of_device[1], p_data->cfm_req.class_of_device[2],\n                app_get_cod_string(p_data->cfm_req.class_of_device));\n        BT_LOGD(\"    Just Work:%s\", p_data->cfm_req.just_works == TRUE ? \"TRUE\" : \"FALSE\");\n        BT_LOGD(\"    Numeric Value:%d\", p_data->cfm_req.num_val);\n        BT_LOGD(\"    Remote is %s device\", p_data->cfm_req.is_ble ? \"LE\" : \"BR/EDR\");\n        //BT_LOGD(\"    You must accept or refuse using menu\\n\");\n        //bdcpy(app_sec_db_addr, p_data->cfm_req.bd_addr);\n        app_sec_is_ble = p_data->cfm_req.is_ble;\n\n        {\n            BT_LOGD(\"\\tAccept it automatically\");\n            app_mgr_sp_cfm_reply(TRUE, p_data->cfm_req.bd_addr);\n        }\n        break;\n\n    case BSA_SEC_SP_KEY_NOTIF_EVT: /* Simple Pairing Passkey Notification */\n        BT_LOGD(\"BSA_SEC_SP_KEY_NOTIF_EVT\");\n        BT_LOGD(\"    bd_addr: %02x:%02x:%02x:%02x:%02x:%02x\",\n                p_data->key_notif.bd_addr[0], p_data->key_notif.bd_addr[1], p_data->key_notif.bd_addr[2],\n                p_data->key_notif.bd_addr[3], p_data->key_notif.bd_addr[4], p_data->key_notif.bd_addr[5]);\n        BT_LOGD(\"    ClassOfDevice:%02x:%02x:%02x => %s\",\n                p_data->key_notif.class_of_device[0], p_data->key_notif.class_of_device[1], p_data->key_notif.class_of_device[2],\n                app_get_cod_string(p_data->key_notif.class_of_device));\n        BT_LOGD(\"    Numeric Value:%d\", p_data->key_notif.passkey);\n#if (defined(BLE_INCLUDED) && BLE_INCLUDED == TRUE)\n        BT_LOGD(\"    LinkType: %d\", p_data->key_notif.link_type);\n#endif\n        BT_LOGD(\"    You must enter this value on peer device's keyboard\");\n        break;\n\n    case BSA_SEC_SP_KEY_REQ_EVT: /* Simple Pairing Passkey request Notification */\n        BT_LOGD(\"BSA_SEC_SP_KEY_REQ_EVT\");\n        BT_LOGD(\"    bd_addr: %02x:%02x:%02x:%02x:%02x:%02x\",\n                p_data->key_notif.bd_addr[0], p_data->key_notif.bd_addr[1], p_data->key_notif.bd_addr[2],\n                p_data->key_notif.bd_addr[3], p_data->key_notif.bd_addr[4], p_data->key_notif.bd_addr[5]);\n        BT_LOGD(\"    ClassOfDevice:%02x:%02x:%02x => %s\",\n                p_data->key_notif.class_of_device[0], p_data->key_notif.class_of_device[1], p_data->key_notif.class_of_device[2],\n                app_get_cod_string(p_data->key_notif.class_of_device));\n        BT_LOGD(\"    Numeric Value:%d\", p_data->key_notif.passkey);\n#if (defined(BLE_INCLUDED) && BLE_INCLUDED == TRUE)\n        BT_LOGD(\"    LinkType: %d\", p_data->key_notif.link_type);\n#endif\n        BT_LOGD(\"    You must enter this value on peer device's keyboard\");\n\n        memset(&g_passkey_reply, 0, sizeof(g_passkey_reply));\n        bdcpy(g_passkey_reply.bd_addr, p_data->pin_req.bd_addr);\n        break;\n\n    case BSA_SEC_SP_KEYPRESS_EVT: /* Simple Pairing Key press notification event. */\n        BT_LOGD(\"BSA_SEC_SP_KEYPRESS_EVT (type:%d)\", p_data->key_press.notif_type);\n        BT_LOGD(\"    bd_addr: %02x:%02x:%02x:%02x:%02x:%02x\",\n                p_data->key_press.bd_addr[0], p_data->key_press.bd_addr[1], p_data->key_press.bd_addr[2],\n                p_data->key_press.bd_addr[3], p_data->key_press.bd_addr[4], p_data->key_press.bd_addr[5]);\n        break;\n\n   case BSA_SEC_SP_RMT_OOB_EVT: /* Simple Pairing Remote OOB Data request. */\n       BT_LOGD(\"BSA_SEC_SP_RMT_OOB_EVT received - Handled internally if Peer OOB already set\");\n       break;\n\n    case BSA_SEC_LOCAL_OOB_DATA_EVT: /* Local OOB Data response */\n        BT_LOGD(\"BSA_SEC_LOCAL_OOB_DATA_EVT received\");\n        app_mgr_local_oob_evt_data(&p_data->local_oob);\n        break;\n\n    case BSA_SEC_SUSPENDED_EVT: /* Connection Suspended */\n        BT_LOGI(\"BSA_SEC_SUSPENDED_EVT bd_addr: %02x:%02x:%02x:%02x:%02x:%02x\",\n                p_data->suspended.bd_addr[0], p_data->suspended.bd_addr[1],\n                p_data->suspended.bd_addr[2], p_data->suspended.bd_addr[3],\n                p_data->suspended.bd_addr[4], p_data->suspended.bd_addr[5]);\n        break;\n\n    case BSA_SEC_RESUMED_EVT: /* Connection Resumed */\n        BT_LOGI(\"BSA_SEC_RESUMED_EVT bd_addr: %02x:%02x:%02x:%02x:%02x:%02x\",\n                p_data->resumed.bd_addr[0], p_data->resumed.bd_addr[1],\n                p_data->resumed.bd_addr[2], p_data->resumed.bd_addr[3],\n                p_data->resumed.bd_addr[4], p_data->resumed.bd_addr[5]);\n        break;\n\n#if (defined(BLE_INCLUDED) && BLE_INCLUDED == TRUE)\n    case BSA_SEC_BLE_KEY_EVT: /* BLE KEY event */\n        BT_LOGI(\"BSA_SEC_BLE_KEY_EVT\");\n        switch (p_data->ble_key.key_type)\n        {\n        case BSA_LE_KEY_PENC:\n            BT_LOGD(\"\\t key_type: BTM_LE_KEY_PENC(%d)\", p_data->ble_key.key_type);\n            APP_DUMP(\"LTK\", p_data->ble_key.key_value.penc_key.ltk, 16);\n            APP_DUMP(\"RAND\", p_data->ble_key.key_value.penc_key.rand, 8);\n            BT_LOGD(\"ediv: 0x%x:\", p_data->ble_key.key_value.penc_key.ediv);\n            BT_LOGD(\"sec_level: 0x%x:\", p_data->ble_key.key_value.penc_key.sec_level);\n            BT_LOGD(\"key_size: %d:\", p_data->ble_key.key_value.penc_key.key_size);\n            break;\n        case BSA_LE_KEY_PID:\n            BT_LOGD(\"\\t key_type: BTM_LE_KEY_PID(%d)\", p_data->ble_key.key_type);\n            APP_DUMP(\"IRK\", p_data->ble_key.key_value.pid_key.irk, 16);\n            BT_LOGD(\"addr_type: 0x%x:\", p_data->ble_key.key_value.pid_key.addr_type);\n            BT_LOGD(\"static_addr: %02X-%02X-%02X-%02X-%02X-%02X\",\n                p_data->ble_key.key_value.pid_key.static_addr[0],\n                p_data->ble_key.key_value.pid_key.static_addr[1],\n                p_data->ble_key.key_value.pid_key.static_addr[2],\n                p_data->ble_key.key_value.pid_key.static_addr[3],\n                p_data->ble_key.key_value.pid_key.static_addr[4],\n                p_data->ble_key.key_value.pid_key.static_addr[5]);\n            break;\n        case BSA_LE_KEY_PCSRK:\n            BT_LOGD(\"\\t key_type: BTM_LE_KEY_PCSRK(%d)\", p_data->ble_key.key_type);\n            BT_LOGD(\"counter: 0x%x:\", p_data->ble_key.key_value.pcsrk_key.counter);\n            APP_DUMP(\"CSRK\", p_data->ble_key.key_value.pcsrk_key.csrk, 16);\n            BT_LOGD(\"sec_level: %d:\", p_data->ble_key.key_value.pcsrk_key.sec_level);\n            break;\n        case BSA_LE_KEY_LCSRK:\n            BT_LOGD(\"\\t key_type: BTM_LE_KEY_LCSRK(%d)\", p_data->ble_key.key_type);\n            BT_LOGD(\"counter: 0x%x:\", p_data->ble_key.key_value.lcsrk_key.counter);\n            BT_LOGD(\"div: %d:\", p_data->ble_key.key_value.lcsrk_key.div);\n            BT_LOGD(\"sec_level: 0x%x:\", p_data->ble_key.key_value.lcsrk_key.sec_level);\n            break;\n        case BSA_LE_KEY_LENC:\n            BT_LOGD(\"\\t key_type: BTM_LE_KEY_LENC(%d)\", p_data->ble_key.key_type);\n            BT_LOGD(\"div: 0x%x:\", p_data->ble_key.key_value.lenc_key.div);\n            BT_LOGD(\"key_size: %d:\", p_data->ble_key.key_value.lenc_key.key_size);\n            BT_LOGD(\"sec_level: 0x%x:\", p_data->ble_key.key_value.lenc_key.sec_level);\n            break;\n        case BSA_LE_KEY_LID:\n            BT_LOGD(\"\\t key_type: BTM_LE_KEY_LID(%d)\", p_data->ble_key.key_type);\n            break;\n        default:\n            BT_LOGD(\"\\t key_type: Unknown key(%d)\", p_data->ble_key.key_type);\n            break;\n        }\n\n        /* Read the Remote device xml file to have a fresh view */\n        app_mgr_read_remote_devices();\n\n        app_xml_update_device_type_db(app_xml_remote_devices_db,\n                APP_NUM_ELEMENTS(app_xml_remote_devices_db), p_data->ble_key.bd_addr,\n                BT_DEVICE_TYPE_BLE);\n\n        app_xml_update_ble_key_db(app_xml_remote_devices_db,\n                APP_NUM_ELEMENTS(app_xml_remote_devices_db),\n                p_data->ble_key.bd_addr,\n                p_data->ble_key.key_value,\n                p_data->ble_key.key_type);\n\n        status = app_mgr_write_remote_devices();\n        if (status < 0)\n        {\n            BT_LOGE(\"app_mgr_write_remote_devices failed:%d\", status);\n        }\n        break;\n\n    case BSA_SEC_BLE_PASSKEY_REQ_EVT:\n        BT_LOGI(\"BSA_SEC_BLE_PASSKEY_REQ_EVT (Passkey Request) received from:\");\n        BT_LOGI(\"\\tbd_addr: %02x:%02x:%02x:%02x:%02x:%02x\",\n                p_data->ble_passkey_req.bd_addr[0], p_data->ble_passkey_req.bd_addr[1],\n                p_data->ble_passkey_req.bd_addr[2], p_data->ble_passkey_req.bd_addr[3],\n                p_data->ble_passkey_req.bd_addr[4], p_data->ble_passkey_req.bd_addr[5]);\n\n        memset(&g_pin_code_reply, 0, sizeof(g_pin_code_reply));\n        bdcpy(g_pin_code_reply.bd_addr, p_data->pin_req.bd_addr);\n        break;\n#endif\n\n    case BSA_SEC_RSSI_EVT:\n        BT_LOGI(\"BSA_SEC_RSSI_EVT received for BdAddr: %02x:%02x:%02x:%02x:%02x:%02x\",\n                p_data->sig_strength.bd_addr[0], p_data->sig_strength.bd_addr[1],\n                p_data->sig_strength.bd_addr[2], p_data->sig_strength.bd_addr[3],\n                p_data->sig_strength.bd_addr[4], p_data->sig_strength.bd_addr[5]);\n        if (p_data->sig_strength.mask & BSA_SEC_SIG_STRENGTH_RSSI)\n        {\n            if (p_data->sig_strength.link_type == BSA_TRANSPORT_BR_EDR)\n            {\n                /* For BasicRate & EnhancedDataRate links, the RSSI is an attenuation (dB) */\n                BT_LOGI(\"\\tRSSI: %d (dB)\", p_data->sig_strength.rssi_value);\n            }\n            else\n            {\n                /* For Low Energy links, the RSSI is a strength (dBm) */\n                BT_LOGI(\"\\tRSSI: %d (dBm)\", p_data->sig_strength.rssi_value);\n            }\n        }\n\n        if (p_data->sig_strength.mask & BSA_SEC_SIG_STRENGTH_RAW_RSSI)\n        {\n            /* Raw RSSI is always a strength (dBm) */\n            BT_LOGI(\"\\tRaw RSSI: %d (dBm)\", p_data->sig_strength.raw_rssi_value);\n        }\n\n        if (p_data->sig_strength.mask & BSA_SEC_SIG_STRENGTH_LINK_QUALITY)\n        {\n            BT_LOGI(\"\\tLink Quality: %d\", p_data->sig_strength.link_quality_value);\n        }\n        break;\n    case BSA_SEC_UNKNOWN_LINKKEY_EVT:\n        BT_LOGI(\"BSA_SEC_UNKNOWN_LINKKEY_EVT received for BdAddr: %02x:%02x:%02x:%02x:%02x:%02x\",\n                  p_data->lost_link_key.bd_addr[0], p_data->lost_link_key.bd_addr[1],\n                  p_data->lost_link_key.bd_addr[2], p_data->lost_link_key.bd_addr[3],\n                  p_data->lost_link_key.bd_addr[4], p_data->lost_link_key.bd_addr[5]);\n        break;\n\n    default:\n        BT_LOGE(\"unknown event:%d\", event);\n        break;\n    }\n}", "path": "yodaos/hardware/modules/bluetooth/bsa_ampak/app_manager.c", "commit_date": "2019-11-14 00:00:00", "repo_name": "yodaos-project/yodaos", "stars": 1182, "license": "apache-2.0", "language": "c", "size": 73276}
{"docstring": "/*******************************************************************************\n **\n ** Function         app_mgr_send_passkey\n **\n ** Description      Sends simple pairing passkey to server\n **\n ** Parameters       passkey\n **\n ** Returns          void\n **\n *******************************************************************************/\n", "func_signal": "void app_mgr_send_passkey(UINT32 passkey)", "code": "{\n    g_passkey_reply.passkey = passkey;\n    BSA_SecSpPasskeyReply(&g_passkey_reply);\n}", "path": "yodaos/hardware/modules/bluetooth/bsa_ampak/app_manager.c", "commit_date": "2019-11-14 00:00:00", "repo_name": "yodaos-project/yodaos", "stars": 1182, "license": "apache-2.0", "language": "c", "size": 73276}
{"docstring": "/*\n * Print all feature names, that have its related flags enabled.\n */\n", "func_signal": "static void print_flagged_features(u8 flags)", "code": "{\n\tint i;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (flags & (1 << i))\n\t\t\tprintf(\"%s \", pwrman_feat[i]);\n\t}\n}", "path": "yodaos/boot/rpi/board/egnite/ethernut5/ethernut5_pwrman.c", "commit_date": "2019-11-14 00:00:00", "repo_name": "yodaos-project/yodaos", "stars": 1182, "license": "apache-2.0", "language": "c", "size": 73276}
{"docstring": "/*\n * Enable Ethernut 5 power management.\n *\n * This function must be called during board initialization.\n * While we are using u-boot's I2C subsystem, it may be required\n * to enable the serial port before calling this function,\n * in particular when debugging is enabled.\n *\n * If board specific commands are not available, we will activate\n * all board components.\n */\n", "func_signal": "void ethernut5_power_init(void)", "code": "{\n\tpwrman_minor = i2c_reg_read(PWRMAN_I2C_ADDR, PWRMAN_REG_VERS);\n\tpwrman_major = pwrman_minor >> 4;\n\tpwrman_minor &= 15;\n\n#ifndef CONFIG_CMD_BSP\n\t/* Do not modify anything, if we do not have a known version. */\n\tif (pwrman_major == 2) {\n\t\t/* Without board specific commands we enable all features. */\n\t\ti2c_reg_write(PWRMAN_I2C_ADDR, PWRMAN_REG_ENA, ~PWRMAN_ETHRST);\n\t\ti2c_reg_write(PWRMAN_I2C_ADDR, PWRMAN_REG_DIS, PWRMAN_ETHRST);\n\t}\n#endif\n}", "path": "yodaos/boot/rpi/board/egnite/ethernut5/ethernut5_pwrman.c", "commit_date": "2019-11-14 00:00:00", "repo_name": "yodaos-project/yodaos", "stars": 1182, "license": "apache-2.0", "language": "c", "size": 73276}
{"docstring": "/**\n * eeprom_field_print_ascii() - print a field which contains ASCII data\n * @field:\tan initialized field to print\n */\n", "func_signal": "void eeprom_field_print_ascii(const struct eeprom_field *field)", "code": "{\n\tchar format[8];\n\n\tsprintf(format, \"%%.%ds\\n\", field->size);\n\tprintf(PRINT_FIELD_SEGMENT, field->name);\n\tprintf(format, field->buf);\n}", "path": "yodaos/boot/rpi/common/eeprom/eeprom_field.c", "commit_date": "2019-11-14 00:00:00", "repo_name": "yodaos-project/yodaos", "stars": 1182, "license": "apache-2.0", "language": "c", "size": 73276}
{"docstring": "/*******************************************************************************\n **\n ** Function         app_get_cod\n **\n ** Description      Get a class of device from the user\n **\n ** Parameters       COD return value\n **\n ** Returns          status: 0 if success / -1 otherwise\n **\n *******************************************************************************/\n", "func_signal": "int app_get_cod(DEV_CLASS cod)", "code": "{\n    DEV_CLASS cods[7] = {\n        { 0x00, 0x00, 0x00 },\n        { 0x00, 0x04, 0x24 },   /* STB */\n        { 0x00, 0x01, 0x00 },   /* HID host (computer) */\n        { 0x00, 0x05, 0x40 },   /* HID KB */\n        { 0x00, 0x05, 0x80 },   /* HID mpuse */\n        { 0x00, 0x02, 0x00 },   /* phone */\n        { 0x00, 0x04, 0x18 }    /* headset */\n    };\n\n    /* set top box (default), hid host, hid device, phone, headset, etc. */\n    printf(\"Ener COD for local device:\\n\");\n    printf(\"1 - Set top box (default) \\n\");\n    printf(\"2 - HID host\\n\");\n    printf(\"3 - HID keyboard\\n\");\n    printf(\"4 - HID mouse\\n\");\n    printf(\"5 - Phone\\n\");\n    printf(\"6 - Headset\\n\");\n    printf(\"7 - Custom\\n\");\n\n    int i = (app_get_choice(\"Select=>\"));\n    if (i == 7)\n    {\n        char cod_str[20];\n        unsigned int cod_0, cod_1, cod_2;\n        memset(cod_str, 0, sizeof(cod_str));\n        printf(\"Enter 3 byte COD, 1 byte for each in hex format:\\n\");\n        if (2 != app_get_string(\"Service class\",cod_str, 3))\n            return -1;\n        if (2 != app_get_string(\"Major device class\",&(cod_str[2]), 3))\n            return -1;\n        if (2 != app_get_string(\"Minor device class\",&(cod_str[4]), 3))\n            return -1;\n\n        if (3 != sscanf(cod_str,\"%02x%02x%02x\", &cod_0, &cod_1, &cod_2))\n            return -1;\n        cod[0] = (UINT8)cod_0;\n        cod[1] = (UINT8)cod_1;\n        cod[2] = (UINT8)cod_2;\n        return 0;\n    }\n    if (i <= 0 || i > 6)\n        return -1;\n    cod[0] = cods[i][0];\n    cod[1] = cods[i][1];\n    cod[2] = cods[i][2];\n    return 0;\n}", "path": "yodaos/hardware/modules/bluetooth/bsa_ampak/app_manager.c", "commit_date": "2019-11-14 00:00:00", "repo_name": "yodaos-project/yodaos", "stars": 1182, "license": "apache-2.0", "language": "c", "size": 73276}
{"docstring": "/*******************************************************************************\n **\n ** Function         app_mgr_set_link_policy\n **\n ** Description      Set the device link policy\n **                  This function sets/clears the link policy mask to the given\n **                  bd_addr.\n **                  If clearing the sniff or park mode mask, the link is put\n **                  in active mode.\n **\n ** Parameters\n **\n ** Returns          void\n **\n *******************************************************************************/\n", "func_signal": "void app_mgr_set_link_policy(BD_ADDR bd_addr, tBSA_DM_LP_MASK policy_mask, BOOLEAN set)", "code": "{\n    tBSA_DM_SET_CONFIG bsa_dm_set_config;\n    if (BSA_DmSetConfigInit(&bsa_dm_set_config) != BSA_SUCCESS)\n    {\n        BT_LOGE(\"BSA_DmSetConfigInit failed\");\n        return;\n    }\n\n    bsa_dm_set_config.config_mask = BSA_DM_CONFIG_LINK_POLICY_MASK;\n\n    bdcpy(bsa_dm_set_config.policy_param.link_bd_addr, bd_addr);\n    bsa_dm_set_config.policy_param.policy_mask = policy_mask;\n    bsa_dm_set_config.policy_param.set = set;\n\n    if (BSA_DmSetConfig(&bsa_dm_set_config) != BSA_SUCCESS)\n    {\n        BT_LOGE(\"BSA_DmSetConfig failed\");\n        return;\n    }\n}", "path": "yodaos/hardware/modules/bluetooth/bsa_ampak/app_manager.c", "commit_date": "2019-11-14 00:00:00", "repo_name": "yodaos-project/yodaos", "stars": 1182, "license": "apache-2.0", "language": "c", "size": 73276}
{"docstring": "/*******************************************************************************\n **\n ** Function         app_mgr_set_discoverable\n **\n ** Description      Set the device discoverable for a specific time\n **\n ** Parameters\n **\n ** Returns          void\n **\n *******************************************************************************/\n", "func_signal": "void app_mgr_set_discoverable(void)", "code": "{\n    tBSA_DM_SET_CONFIG bsa_dm_set_config;\n    if (BSA_DmSetConfigInit(&bsa_dm_set_config) != BSA_SUCCESS)\n    {\n        BT_LOGE(\"BSA_DmSetConfigInit failed\");\n        return;\n    }\n    bsa_dm_set_config.discoverable = 1;\n    bsa_dm_set_config.config_mask = BSA_DM_CONFIG_VISIBILITY_MASK;\n    if (BSA_DmSetConfig(&bsa_dm_set_config) != BSA_SUCCESS)\n    {\n        BT_LOGE(\"BSA_DmSetConfig failed\");\n        return;\n    }\n}", "path": "yodaos/hardware/modules/bluetooth/bsa_ampak/app_manager.c", "commit_date": "2019-11-14 00:00:00", "repo_name": "yodaos-project/yodaos", "stars": 1182, "license": "apache-2.0", "language": "c", "size": 73276}
{"docstring": "/*******************************************************************************\n **\n ** Function         app_mgr_set_non_connectable\n **\n ** Description      Set the device non connectable\n **\n ** Parameters\n **\n ** Returns          void\n **\n *******************************************************************************/\n", "func_signal": "void app_mgr_set_non_connectable(void)", "code": "{\n    tBSA_DM_SET_CONFIG bsa_dm_set_config;\n    if (BSA_DmSetConfigInit(&bsa_dm_set_config) != BSA_SUCCESS)\n    {\n        BT_LOGE(\"BSA_DmSetConfigInit failed\");\n        return;\n    }\n    bsa_dm_set_config.connectable = 0;\n    bsa_dm_set_config.config_mask = BSA_DM_CONFIG_VISIBILITY_MASK;\n    if (BSA_DmSetConfig(&bsa_dm_set_config) != BSA_SUCCESS)\n    {\n        BT_LOGE(\"BSA_DmSetConfig failed\");\n        return;\n    }\n}", "path": "yodaos/hardware/modules/bluetooth/bsa_ampak/app_manager.c", "commit_date": "2019-11-14 00:00:00", "repo_name": "yodaos-project/yodaos", "stars": 1182, "license": "apache-2.0", "language": "c", "size": 73276}
{"docstring": "/*******************************************************************************\n **\n ** Function         app_mgr_get_bt_config\n **\n ** Description      This function is used to get the bluetooth configuration\n **\n ** Parameters\n **\n ** Returns          void\n **\n *******************************************************************************/\n", "func_signal": "int app_mgr_get_bt_config(void)", "code": "{\n    int status;\n    tBSA_DM_GET_CONFIG bt_config;\n\n    /*\n     * Get bluetooth configuration\n     */\n    status = BSA_DmGetConfigInit(&bt_config);\n    status = BSA_DmGetConfig(&bt_config);\n    if (status != BSA_SUCCESS)\n    {\n        BT_LOGE(\"BSA_DmGetConfig failed:%d\", status);\n        return(-1);\n    }\n    if (bdcmp(bt_config.bd_addr, app_xml_config.bd_addr)) {\n        /*save  module bd addr*/\n        BT_LOGI(\"save module bd addr\");\n        bdcpy(app_xml_config.bd_addr, bt_config.bd_addr);\n        app_mgr_write_config();\n    }\n    BT_LOGD(\"Enable:%d\", bt_config.enable);\n    BT_LOGD(\"Discoverable:%d\", bt_config.discoverable);\n    BT_LOGD(\"Connectable:%d\", bt_config.connectable);\n    BT_LOGD(\"Name:%s\", bt_config.name);\n    BT_LOGD(\"Bdaddr %02x:%02x:%02x:%02x:%02x:%02x\",\n             bt_config.bd_addr[0], bt_config.bd_addr[1],\n             bt_config.bd_addr[2], bt_config.bd_addr[3],\n             bt_config.bd_addr[4], bt_config.bd_addr[5]);\n    BT_LOGD(\"ClassOfDevice:%02x:%02x:%02x\", bt_config.class_of_device[0],\n            bt_config.class_of_device[1], bt_config.class_of_device[2]);\n    BT_LOGD(\"First host disabled channel:%d\", bt_config.first_disabled_channel);\n    BT_LOGD(\"Last host disabled channel:%d\", bt_config.last_disabled_channel);\n\n    return 0;\n\n}", "path": "yodaos/hardware/modules/bluetooth/bsa_ampak/app_manager.c", "commit_date": "2019-11-14 00:00:00", "repo_name": "yodaos-project/yodaos", "stars": 1182, "license": "apache-2.0", "language": "c", "size": 73276}
{"docstring": "/*******************************************************************************\n **\n ** Function         app_mgr_config\n **\n ** Description      Configure the BSA server\n **\n ** Parameters       None\n **\n ** Returns          Status of the operation\n **\n *******************************************************************************/\n", "func_signal": "int app_mgr_config(const char *name)", "code": "{\n    int                 status;\n    int                 index;\n    BD_ADDR             local_bd_addr = APP_DEFAULT_BD_ADDR;\n    DEV_CLASS           local_class_of_device = APP_DEFAULT_CLASS_OF_DEVICE;\n    tBSA_SEC_ADD_DEV    bsa_add_dev_param;\n    tBSA_SEC_ADD_SI_DEV bsa_add_si_dev_param;\n\n    /*\n     * The rest of the initialization function must be done\n     * for application boot and when Bluetooth is restarted\n     */\n\n    /* Example of function to read the XML file which contains the\n     * Local Bluetooth configuration\n     * */\n    status = app_mgr_read_config();\n    if (status < 0)\n    {\n        BT_LOGI(\"Creating default XML config file\");\n        app_xml_config.enable = TRUE;\n        app_xml_config.discoverable = TRUE;\n        app_xml_config.connectable = TRUE;\n        strncpy((char *)app_xml_config.name, DEFAULT_BT_NAME, sizeof(app_xml_config.name));\n        app_xml_config.name[sizeof(app_xml_config.name) - 1] = '\\0';\n        bdcpy(app_xml_config.bd_addr, local_bd_addr);\n        /* let's use a random number for the last two bytes of the BdAddr */\n //       gettimeofday(&tv, NULL);\n //       rand_seed = tv.tv_sec * tv.tv_usec * getpid();\n //       app_xml_config.bd_addr[4] = rand_r(&rand_seed);\n //       app_xml_config.bd_addr[5] = rand_r(&rand_seed);\n        memcpy(app_xml_config.class_of_device, local_class_of_device, sizeof(DEV_CLASS));\n        strncpy(app_xml_config.root_path, APP_DEFAULT_ROOT_PATH, sizeof(app_xml_config.root_path));\n        app_xml_config.root_path[sizeof(app_xml_config.root_path) - 1] = '\\0';\n\n        strncpy((char *)app_xml_config.pin_code, APP_DEFAULT_PIN_CODE, APP_DEFAULT_PIN_LEN);\n        /* The following code will not work if APP_DEFAULT_PIN_LEN is 16 bytes */\n        app_xml_config.pin_code[APP_DEFAULT_PIN_LEN] = '\\0';\n        app_xml_config.pin_len = APP_DEFAULT_PIN_LEN;\n        app_xml_config.io_cap = APP_SEC_IO_CAPABILITIES;\n\n        status = app_mgr_write_config();\n        if (status < 0)\n        {\n            BT_LOGE(\"Unable to Create default XML config file\");\n            app_mgt_close();\n            return status;\n        }\n    }\n    if (name) {\n        snprintf((char *)app_xml_config.name, sizeof(app_xml_config.name), \"%s\", name);\n    }\n\n    /* Example of function to read the database of remote devices */\n    status = app_mgr_read_remote_devices();\n    if (status < 0)\n    {\n        BT_LOGE(\"No remote device database found\");\n    }\n    else\n    {\n        app_xml_display_devices(app_xml_remote_devices_db, APP_NUM_ELEMENTS(app_xml_remote_devices_db));\n    }\n\n     /* Example of function to get the Local Bluetooth configuration */\n    app_mgr_get_bt_config();\n\n    /* Example of function to set the Bluetooth Security */\n    status = app_mgr_sec_set_security();\n    if (status < 0)\n    {\n        BT_LOGE(\"app_mgr_sec_set_security failed:%d\", status);\n        app_mgt_close();\n        return status;\n    }\n\n    /* Add every devices found in remote device database */\n    /* They will be able to connect to our device */\n    BT_LOGI(\"Add all devices found in database\");\n    for (index = 0 ; index < APP_NUM_ELEMENTS(app_xml_remote_devices_db) ; index++)\n    {\n        if (app_xml_remote_devices_db[index].in_use != FALSE)\n        {\n            BT_LOGI(\"Adding:%s\", app_xml_remote_devices_db[index].name);\n            BSA_SecAddDeviceInit(&bsa_add_dev_param);\n            bdcpy(bsa_add_dev_param.bd_addr,\n                    app_xml_remote_devices_db[index].bd_addr);\n            memcpy(bsa_add_dev_param.class_of_device,\n                    app_xml_remote_devices_db[index].class_of_device,\n                    sizeof(DEV_CLASS));\n            memcpy(bsa_add_dev_param.link_key,\n                    app_xml_remote_devices_db[index].link_key,\n                    sizeof(LINK_KEY));\n            bsa_add_dev_param.link_key_present = app_xml_remote_devices_db[index].link_key_present;\n            bsa_add_dev_param.trusted_services = app_xml_remote_devices_db[index].trusted_services;\n            bsa_add_dev_param.is_trusted = TRUE;\n            bsa_add_dev_param.key_type = app_xml_remote_devices_db[index].key_type;\n            bsa_add_dev_param.io_cap = app_xml_remote_devices_db[index].io_cap;\n#if (defined(BLE_INCLUDED) && BLE_INCLUDED == TRUE)\n            bsa_add_dev_param.ble_addr_type = app_xml_remote_devices_db[index].ble_addr_type;\n            bsa_add_dev_param.device_type = app_xml_remote_devices_db[index].device_type;\n            bsa_add_dev_param.inq_result_type = app_xml_remote_devices_db[index].inq_result_type;\n            if(app_xml_remote_devices_db[index].ble_link_key_present)\n            {\n                bsa_add_dev_param.ble_link_key_present = TRUE;\n\n                /* Fill PENC Key */\n                memcpy(bsa_add_dev_param.le_penc_key.ltk,\n                    app_xml_remote_devices_db[index].penc_ltk,\n                    sizeof(app_xml_remote_devices_db[index].penc_ltk));\n                memcpy(bsa_add_dev_param.le_penc_key.rand,\n                    app_xml_remote_devices_db[index].penc_rand,\n                    sizeof(app_xml_remote_devices_db[index].penc_rand));\n                bsa_add_dev_param.le_penc_key.ediv = app_xml_remote_devices_db[index].penc_ediv;\n                bsa_add_dev_param.le_penc_key.sec_level = app_xml_remote_devices_db[index].penc_sec_level;\n                bsa_add_dev_param.le_penc_key.key_size = app_xml_remote_devices_db[index].penc_key_size;\n\n                /* Fill PID Key */\n                memcpy(bsa_add_dev_param.le_pid_key.irk,\n                    app_xml_remote_devices_db[index].pid_irk,\n                    sizeof(app_xml_remote_devices_db[index].pid_irk));\n                bsa_add_dev_param.le_pid_key.addr_type = app_xml_remote_devices_db[index].pid_addr_type;\n                memcpy(bsa_add_dev_param.le_pid_key.static_addr,\n                    app_xml_remote_devices_db[index].pid_static_addr,\n                    sizeof(app_xml_remote_devices_db[index].pid_static_addr));\n\n                /* Fill PCSRK Key */\n                bsa_add_dev_param.le_pcsrk_key.counter = app_xml_remote_devices_db[index].pcsrk_counter;\n                memcpy(bsa_add_dev_param.le_pcsrk_key.csrk,\n                    app_xml_remote_devices_db[index].pcsrk_csrk,\n                    sizeof(app_xml_remote_devices_db[index].pcsrk_csrk));\n                bsa_add_dev_param.le_pcsrk_key.sec_level = app_xml_remote_devices_db[index].pcsrk_sec_level;\n\n                /* Fill LCSRK Key */\n                bsa_add_dev_param.le_lcsrk_key.counter = app_xml_remote_devices_db[index].lcsrk_counter;\n                bsa_add_dev_param.le_lcsrk_key.div = app_xml_remote_devices_db[index].lcsrk_div;\n                bsa_add_dev_param.le_lcsrk_key.sec_level = app_xml_remote_devices_db[index].lcsrk_sec_level;\n\n                /* Fill LENC Key */\n                bsa_add_dev_param.le_lenc_key.div = app_xml_remote_devices_db[index].lenc_div;\n                bsa_add_dev_param.le_lenc_key.key_size = app_xml_remote_devices_db[index].lenc_key_size;\n                bsa_add_dev_param.le_lenc_key.sec_level = app_xml_remote_devices_db[index].lenc_sec_level;\n            }\n#endif\n            BSA_SecAddDevice(&bsa_add_dev_param);\n        }\n    }\n\n    /* Add stored SI devices to BSA server */\n    app_read_xml_si_devices();\n    for (index = 0 ; index < APP_NUM_ELEMENTS(app_xml_si_devices_db) ; index++)\n    {\n        if (app_xml_si_devices_db[index].in_use)\n        {\n            BSA_SecAddSiDevInit(&bsa_add_si_dev_param);\n            bdcpy(bsa_add_si_dev_param.bd_addr, app_xml_si_devices_db[index].bd_addr);\n            bsa_add_si_dev_param.platform = app_xml_si_devices_db[index].platform;\n            BSA_SecAddSiDev(&bsa_add_si_dev_param);\n        }\n    }\n\n    /* Example of function to set the Local Bluetooth configuration */\n    app_mgr_set_bt_config(app_xml_config.enable);\n\n    return 0;\n}", "path": "yodaos/hardware/modules/bluetooth/bsa_ampak/app_manager.c", "commit_date": "2019-11-14 00:00:00", "repo_name": "yodaos-project/yodaos", "stars": 1182, "license": "apache-2.0", "language": "c", "size": 73276}
{"docstring": "/*******************************************************************************\n **\n ** Function         app_mgr_set_remote_oob\n **\n ** Description      This function is used to set OOB data for peer device\n **                  During pairing stack uses this information to pair\n **\n ** Parameters\n **\n ** Returns          void\n **\n *******************************************************************************/\n", "func_signal": "void app_mgr_set_remote_oob()", "code": "{\n    int uarr[16];\n    char szInput[64];\n    int  i;\n\n    if (BSA_SecSetRemoteOOBInit(&bsa_sec_set_remote_oob) != BSA_SUCCESS)\n    {\n        BT_LOGE(\"app_mgr_set_remote_oob failed\");\n        return;\n    }\n\n    BT_LOGI(\"Enter BDA of Peer device: AABBCCDDEEFF\");\n    memset(szInput, 0, sizeof(szInput));\n    app_get_string(\"Enter BDA: \", szInput, sizeof(szInput));\n    sscanf (szInput, \"%02x%02x%02x%02x%02x%02x\",\n                   &uarr[0], &uarr[1], &uarr[2], &uarr[3], &uarr[4], &uarr[5]);\n\n    for(i=0; i < 6; i++)\n        bsa_sec_set_remote_oob.bd_addr[i] = (UINT8) uarr[i];\n\n    bsa_sec_set_remote_oob.result = TRUE;   /* TRUE to accept; FALSE to reject */\n\n    BT_LOGI(\"Enter 16 byte C Hash in this format: FA87C0D0AFAC11DE8A390800200C9A66\");\n    memset(szInput, 0, sizeof(szInput));\n    app_get_string(\"C Hash: \", szInput, sizeof(szInput));\n    sscanf (szInput, \"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\",\n                   &uarr[0], &uarr[1], &uarr[2], &uarr[3], &uarr[4], &uarr[5], &uarr[6], &uarr[7], &uarr[8],\n            &uarr[9], &uarr[10], &uarr[11], &uarr[12], &uarr[13], &uarr[14], &uarr[15]);\n\n    for(i=0; i < 16; i++)\n        bsa_sec_set_remote_oob.p_c[i] = (UINT8) uarr[i];\n\n    BT_LOGI(\"Enter 16 byte R Randomizer in this format: FA87C0D0AFAC11DE8A390800200C9A66\");\n    memset(szInput, 0, sizeof(szInput));\n    app_get_string(\"R Randomizer: \", szInput, sizeof(szInput));\n    sscanf (szInput, \"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\",\n                   &uarr[0], &uarr[1], &uarr[2], &uarr[3], &uarr[4], &uarr[5], &uarr[6], &uarr[7], &uarr[8],\n            &uarr[9], &uarr[10], &uarr[11], &uarr[12], &uarr[13], &uarr[14], &uarr[15]);\n\n    for(i=0; i < 16; i++)\n        bsa_sec_set_remote_oob.p_r[i] = (UINT8) uarr[i];\n\n    if (BSA_SecSetRemoteOOB(&bsa_sec_set_remote_oob) != BSA_SUCCESS)\n    {\n        BT_LOGE(\"BSA_SecSetRemoteOOB failed\");\n        return;\n    }\n}", "path": "yodaos/hardware/modules/bluetooth/bsa_ampak/app_manager.c", "commit_date": "2019-11-14 00:00:00", "repo_name": "yodaos-project/yodaos", "stars": 1182, "license": "apache-2.0", "language": "c", "size": 73276}
{"docstring": "/*\n * Return flags of a given list of feature names.\n *\n * The function stops at the first unknown list entry and\n * returns the number of detected names as a function result.\n */\n", "func_signal": "static int feature_flags(char * const names[], int num, u8 *flags)", "code": "{\n\tint i, j;\n\n\t*flags = 0;\n\tfor (i = 0; i < num; i++) {\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tif (strcmp(pwrman_feat[j], names[i]) == 0) {\n\t\t\t\t*flags |= 1 << j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j > 7)\n\t\t\tbreak;\n\t}\n\treturn i;\n}", "path": "yodaos/boot/rpi/board/egnite/ethernut5/ethernut5_pwrman.c", "commit_date": "2019-11-14 00:00:00", "repo_name": "yodaos-project/yodaos", "stars": 1182, "license": "apache-2.0", "language": "c", "size": 73276}
{"docstring": "/*******************************************************************************\n **\n ** Function         app_mgr_read_version\n **\n ** Description      This function is used to read BSA and FW version\n **\n ** Parameters\n **\n ** Returns          int\n **\n *******************************************************************************/\n", "func_signal": "int app_mgr_read_version(void)", "code": "{\n    tBSA_TM_READ_VERSION bsa_read_version;\n    tBSA_STATUS bsa_status;\n\n    bsa_status = BSA_TmReadVersionInit(&bsa_read_version);\n    bsa_status = BSA_TmReadVersion(&bsa_read_version);\n    if (bsa_status != BSA_SUCCESS)\n    {\n        BT_LOGE(\"BSA_TmReadVersion failed status:%d\", bsa_status);\n        return(-1);\n    }\n\n    BT_LOGI(\"Server status:%d\", bsa_read_version.status);\n    BT_LOGI(\"FW Version:%d.%d.%d.%d\",\n            bsa_read_version.fw_version.major,\n            bsa_read_version.fw_version.minor,\n            bsa_read_version.fw_version.build,\n            bsa_read_version.fw_version.config);\n    BT_LOGI(\"BSA Server Version:%s\", bsa_read_version.bsa_server_version);\n    return 0;\n}", "path": "yodaos/hardware/modules/bluetooth/bsa_ampak/app_manager.c", "commit_date": "2019-11-14 00:00:00", "repo_name": "yodaos-project/yodaos", "stars": 1182, "license": "apache-2.0", "language": "c", "size": 73276}
{"docstring": "/**\n * eeprom_field_print_reserved() - print the \"Reserved fields\" field\n *\n * Print a notice that the following field_size bytes are reserved.\n *\n * Sample output:\n *      Reserved fields              (64 bytes)\n *\n * @field:\tan initialized field to print\n */\n", "func_signal": "void eeprom_field_print_reserved(const struct eeprom_field *field)", "code": "{\n\tprintf(PRINT_FIELD_SEGMENT, \"Reserved fields\\t\");\n\tprintf(\"(%d bytes)\\n\", field->size);\n}", "path": "yodaos/boot/rpi/common/eeprom/eeprom_field.c", "commit_date": "2019-11-14 00:00:00", "repo_name": "yodaos-project/yodaos", "stars": 1182, "license": "apache-2.0", "language": "c", "size": 73276}
{"docstring": "/** Raw API TCP poll callback */\n", "func_signal": "static err_t\nsmtp_tcp_poll(void *arg, struct altcp_pcb *pcb)", "code": "{\n  if (arg != NULL) {\n    struct smtp_session *s = (struct smtp_session*)arg;\n    if (s->timer != 0) {\n      s->timer--;\n    }\n  }\n  smtp_process(arg, pcb, NULL);\n  return ERR_OK;\n}", "path": "badvpn/lwip/src/apps/smtp/smtp.c", "commit_date": "2017-09-25 00:00:00", "repo_name": "ambrop72/badvpn", "stars": 1827, "license": "other", "language": "c", "size": 6042}
{"docstring": "/** Send data with sequence numbers that wrap around the u32_t range.\n * Then, provoke fast retransmission by duplicate ACKs and check that all\n * segment lists are still properly sorted. */\n", "func_signal": "START_TEST(test_tcp_fast_rexmit_wraparound)", "code": "{\n  struct netif netif;\n  struct test_tcp_txcounters txcounters;\n  struct test_tcp_counters counters;\n  struct tcp_pcb* pcb;\n  struct pbuf* p;\n  err_t err;\n  u16_t i, sent_total = 0;\n  LWIP_UNUSED_ARG(_i);\n\n  for (i = 0; i < sizeof(tx_data); i++) {\n    tx_data[i] = (u8_t)i;\n  }\n\n  /* initialize local vars */\n  test_tcp_init_netif(&netif, &txcounters, &test_local_ip, &test_netmask);\n  memset(&counters, 0, sizeof(counters));\n\n  /* create and initialize the pcb */\n  tcp_ticks = SEQNO1 - ISS;\n  pcb = test_tcp_new_counters_pcb(&counters);\n  EXPECT_RET(pcb != NULL);\n  tcp_set_state(pcb, ESTABLISHED, &test_local_ip, &test_remote_ip, TEST_LOCAL_PORT, TEST_REMOTE_PORT);\n  pcb->mss = TCP_MSS;\n  /* disable initial congestion window (we don't send a SYN here...) */\n  pcb->cwnd = 2*TCP_MSS;\n  /* start in congestion advoidance */\n  pcb->ssthresh = pcb->cwnd;\n\n  /* send 6 mss-sized segments */\n  for (i = 0; i < 6; i++) {\n    err = tcp_write(pcb, &tx_data[sent_total], TCP_MSS, TCP_WRITE_FLAG_COPY);\n    EXPECT_RET(err == ERR_OK);\n    sent_total += TCP_MSS;\n  }\n  check_seqnos(pcb->unsent, 6, seqnos);\n  EXPECT(pcb->unacked == NULL);\n  err = tcp_output(pcb);\n  EXPECT(txcounters.num_tx_calls == 2);\n  EXPECT(txcounters.num_tx_bytes == 2 * (TCP_MSS + 40U));\n  memset(&txcounters, 0, sizeof(txcounters));\n\n  check_seqnos(pcb->unacked, 2, seqnos);\n  check_seqnos(pcb->unsent, 4, &seqnos[2]);\n\n  /* ACK the first segment */\n  p = tcp_create_rx_segment(pcb, NULL, 0, 0, TCP_MSS, TCP_ACK);\n  test_tcp_input(p, &netif);\n  /* ensure this didn't trigger a retransmission. Only one\n  segment should be transmitted because cwnd opened up by\n  TCP_MSS and a fraction since we are in congestion avoidance */\n  EXPECT(txcounters.num_tx_calls == 1);\n  EXPECT(txcounters.num_tx_bytes == TCP_MSS + 40U);\n  memset(&txcounters, 0, sizeof(txcounters));\n  check_seqnos(pcb->unacked, 2, &seqnos[1]);\n  check_seqnos(pcb->unsent, 3, &seqnos[3]);\n\n  /* 3 dupacks */\n  EXPECT(pcb->dupacks == 0);\n  p = tcp_create_rx_segment(pcb, NULL, 0, 0, 0, TCP_ACK);\n  test_tcp_input(p, &netif);\n  EXPECT(txcounters.num_tx_calls == 0);\n  EXPECT(pcb->dupacks == 1);\n  p = tcp_create_rx_segment(pcb, NULL, 0, 0, 0, TCP_ACK);\n  test_tcp_input(p, &netif);\n  EXPECT(txcounters.num_tx_calls == 0);\n  EXPECT(pcb->dupacks == 2);\n  /* 3rd dupack -> fast rexmit */\n  p = tcp_create_rx_segment(pcb, NULL, 0, 0, 0, TCP_ACK);\n  test_tcp_input(p, &netif);\n  EXPECT(pcb->dupacks == 3);\n  EXPECT(txcounters.num_tx_calls == 4);\n  memset(&txcounters, 0, sizeof(txcounters));\n  EXPECT(pcb->unsent == NULL);\n  check_seqnos(pcb->unacked, 5, &seqnos[1]);\n\n  /* make sure the pcb is freed */\n  EXPECT_RET(MEMP_STATS_GET(used, MEMP_TCP_PCB) == 1);\n  tcp_abort(pcb);\n  EXPECT_RET(MEMP_STATS_GET(used, MEMP_TCP_PCB) == 0);\n}", "path": "badvpn/lwip/test/unit/tcp/test_tcp.c", "commit_date": "2017-09-25 00:00:00", "repo_name": "ambrop72/badvpn", "stars": 1827, "license": "other", "language": "c", "size": 6042}
{"docstring": "/** @ingroup smtp\n * Same as smtp_send_mail but takes a struct smtp_send_request as single\n * parameter which contains all the other parameters.\n * To be used with tcpip_callback to send mail from interrupt context or from\n * another thread.\n *\n * WARNING: server and authentication must stay untouched until this function has run!\n *\n * Usage example:\n * - allocate a struct smtp_send_request (in a way that is allowed in interrupt context)\n * - fill the members of the struct as if calling smtp_send_mail\n * - specify a callback_function\n * - set callback_arg to the structure itself\n * - call this function\n * - wait for the callback function to be called\n * - in the callback function, deallocate the structure (passed as arg)\n */\n", "func_signal": "void\nsmtp_send_mail_int(void *arg)", "code": "{\n  struct smtp_send_request *req = (struct smtp_send_request*)arg;\n  err_t err;\n\n  LWIP_ASSERT(\"smtp_send_mail_int: no argument given\", arg != NULL);\n\n  if (req->static_data) {\n    err = smtp_send_mail_static(req->from, req->to, req->subject, req->body,\n      req->callback_fn, req->callback_arg);\n  } else {\n    err = smtp_send_mail(req->from, req->to, req->subject, req->body,\n      req->callback_fn, req->callback_arg);\n  }\n  if ((err != ERR_OK) && (req->callback_fn != NULL)) {\n    req->callback_fn(req->callback_arg, SMTP_RESULT_ERR_UNKNOWN, 0, err);\n  }\n}", "path": "badvpn/lwip/src/apps/smtp/smtp.c", "commit_date": "2017-09-25 00:00:00", "repo_name": "ambrop72/badvpn", "stars": 1827, "license": "other", "language": "c", "size": 6042}
{"docstring": "/** State machine-like implementation of an SMTP client.\n */\n", "func_signal": "static void\nsmtp_process(void *arg, struct altcp_pcb *pcb, struct pbuf *p)", "code": "{\n  struct smtp_session* s = (struct smtp_session*)arg;\n  u16_t response_code = 0;\n  u16_t tx_buf_len = 0;\n  enum smtp_session_state next_state;\n\n  if (arg == NULL) {\n    /* already closed SMTP connection */\n    if (p != NULL) {\n      LWIP_DEBUGF(SMTP_DEBUG_TRACE, (\"Received %d bytes after closing: %s\\n\",\n        p->tot_len, smtp_pbuf_str(p)));\n      pbuf_free(p);\n    }\n    return;\n  }\n\n  next_state = s->state;\n\n  if (p != NULL) {\n    /* received data */\n    if (s->p == NULL) {\n      s->p = p;\n    } else {\n      pbuf_cat(s->p, p);\n    }\n  } else {\n    /* idle timer, close connection if timed out */\n    if (s->timer == 0) {\n      LWIP_DEBUGF(SMTP_DEBUG_WARN_STATE, (\"smtp_process: connection timed out, closing\\n\"));\n      smtp_close(s, pcb, SMTP_RESULT_ERR_TIMEOUT, 0, ERR_TIMEOUT);\n      return;\n    }\n    if (s->state == SMTP_BODY) {\n      smtp_send_body(s, pcb);\n      return;\n    }\n  }\n  response_code = smtp_is_response(s);\n  if (response_code) {\n    LWIP_DEBUGF(SMTP_DEBUG_TRACE, (\"smtp_process: received response code: %d\\n\", response_code));\n    if (smtp_is_response_finished(s) != ERR_OK) {\n      LWIP_DEBUGF(SMTP_DEBUG_TRACE, (\"smtp_process: partly received response code: %d\\n\", response_code));\n      /* wait for next packet to complete the respone */\n      return;\n    }\n  } else {\n    if (s->p != NULL) {\n      LWIP_DEBUGF(SMTP_DEBUG_WARN, (\"smtp_process: unknown data received (%s)\\n\",\n        smtp_pbuf_str(s->p)));\n      pbuf_free(s->p);\n      s->p = NULL;\n    }\n    return;\n  }\n\n  switch(s->state)\n  {\n  case(SMTP_NULL):\n    /* wait for 220 */\n    if (response_code == 220) {\n      /* then send EHLO */\n      next_state = smtp_prepare_helo(s, &tx_buf_len, pcb);\n    }\n    break;\n  case(SMTP_HELO):\n    /* wait for 250 */\n    if (response_code == 250) {\n#if SMTP_SUPPORT_AUTH_PLAIN || SMTP_SUPPORT_AUTH_LOGIN\n      /* then send AUTH or MAIL */\n      next_state = smtp_prepare_auth_or_mail(s, &tx_buf_len);\n    }\n    break;\n  case(SMTP_AUTH_LOGIN):\n  case(SMTP_AUTH_PLAIN):\n    /* wait for 235 */\n    if (response_code == 235) {\n#endif /* SMTP_SUPPORT_AUTH_PLAIN || SMTP_SUPPORT_AUTH_LOGIN */\n      /* send MAIL */\n      next_state = smtp_prepare_mail(s, &tx_buf_len);\n    }\n    break;\n#if SMTP_SUPPORT_AUTH_LOGIN\n  case(SMTP_AUTH_LOGIN_UNAME):\n    /* wait for 334 Username */\n    if (response_code == 334) {\n      if (pbuf_strstr(s->p, SMTP_RESP_LOGIN_UNAME) != 0xFFFF) {\n        /* send username */\n        next_state = smtp_prepare_auth_login_uname(s, &tx_buf_len);\n      }\n    }\n    break;\n  case(SMTP_AUTH_LOGIN_PASS):\n    /* wait for 334 Password */\n    if (response_code == 334) {\n      if (pbuf_strstr(s->p, SMTP_RESP_LOGIN_PASS) != 0xFFFF) {\n        /* send username */\n        next_state = smtp_prepare_auth_login_pass(s, &tx_buf_len);\n      }\n    }\n    break;\n#endif /* SMTP_SUPPORT_AUTH_LOGIN */\n  case(SMTP_MAIL):\n    /* wait for 250 */\n    if (response_code == 250) {\n      /* send RCPT */\n      next_state = smtp_prepare_rcpt(s, &tx_buf_len);\n    }\n    break;\n  case(SMTP_RCPT):\n    /* wait for 250 */\n    if (response_code == 250) {\n      /* send DATA */\n      SMEMCPY(s->tx_buf, SMTP_CMD_DATA, SMTP_CMD_DATA_LEN);\n      tx_buf_len = SMTP_CMD_DATA_LEN;\n      next_state = SMTP_DATA;\n    }\n    break;\n  case(SMTP_DATA):\n    /* wait for 354 */\n    if (response_code == 354) {\n      /* send email header */\n      next_state = smtp_prepare_header(s, &tx_buf_len);\n    }\n    break;\n  case(SMTP_BODY):\n    /* nothing to be done here, handled somewhere else */\n    break;\n  case(SMTP_QUIT):\n    /* wait for 250 */\n    if (response_code == 250) {\n      /* send QUIT */\n      next_state = smtp_prepare_quit(s, &tx_buf_len);\n    }\n    break;\n  case(SMTP_CLOSED):\n    /* nothing to do, wait for connection closed from server */\n    return;\n  default:\n    LWIP_DEBUGF(SMTP_DEBUG_SERIOUS, (\"Invalid state: %d/%s\\n\", (int)s->state,\n      smtp_state_str[s->state]));\n    break;\n  }\n  if (s->state == next_state) {\n    LWIP_DEBUGF(SMTP_DEBUG_WARN_STATE, (\"smtp_process[%s]: unexpected response_code, closing: %d (%s)\\n\",\n      smtp_state_str[s->state], response_code, smtp_pbuf_str(s->p)));\n    /* close connection */\n    smtp_close(s, pcb, SMTP_RESULT_ERR_SVR_RESP, response_code, ERR_OK);\n    return;\n  }\n  if (tx_buf_len > 0) {\n    SMTP_TX_BUF_MAX(tx_buf_len);\n    if (altcp_write(pcb, s->tx_buf, tx_buf_len, TCP_WRITE_FLAG_COPY) == ERR_OK) {\n      LWIP_DEBUGF(SMTP_DEBUG_TRACE, (\"smtp_process[%s]: received command %d (%s)\\n\",\n        smtp_state_str[s->state], response_code, smtp_pbuf_str(s->p)));\n      LWIP_DEBUGF(SMTP_DEBUG_TRACE, (\"smtp_process[%s]: sent %\"U16_F\" bytes: \\\"%s\\\"\\n\",\n        smtp_state_str[s->state], tx_buf_len, s->tx_buf));\n      s->timer = SMTP_TIMEOUT;\n      pbuf_free(s->p);\n      s->p = NULL;\n      LWIP_DEBUGF(SMTP_DEBUG_STATE, (\"smtp_process: changing state from %s to %s\\n\",\n        smtp_state_str[s->state], smtp_state_str[next_state]));\n      s->state = next_state;\n      if (next_state == SMTP_BODY) {\n        /* try to stream-send body data right now */\n        smtp_send_body(s, pcb);\n      } else if (next_state == SMTP_CLOSED) {\n        /* sent out all data, delete structure */\n        altcp_arg(pcb, NULL);\n        smtp_free(s, SMTP_RESULT_OK, 0, ERR_OK);\n      }\n    }\n  }\n}", "path": "badvpn/lwip/src/apps/smtp/smtp.c", "commit_date": "2017-09-25 00:00:00", "repo_name": "ambrop72/badvpn", "stars": 1827, "license": "other", "language": "c", "size": 6042}
{"docstring": "/** Frees the smtp_session and calls the callback function */\n", "func_signal": "static void\nsmtp_free(struct smtp_session *s, u8_t result, u16_t srv_err, err_t err)", "code": "{\n  smtp_result_fn fn = s->callback_fn;\n  void *arg = s->callback_arg;\n  if (s->p != NULL) {\n    pbuf_free(s->p);\n  }\n  smtp_free_struct(s);\n  if (fn != NULL) {\n    fn(arg, result, srv_err, err);\n  }\n}", "path": "badvpn/lwip/src/apps/smtp/smtp.c", "commit_date": "2017-09-25 00:00:00", "repo_name": "ambrop72/badvpn", "stars": 1827, "license": "other", "language": "c", "size": 6042}
{"docstring": "/*\n * demand_discard - set each network protocol to discard packets\n * with an error.\n */\n", "func_signal": "void\ndemand_discard()", "code": "{\n    struct packet *pkt, *nextpkt;\n    int i;\n    const struct protent *protp;\n\n    for (i = 0; (protp = protocols[i]) != NULL; ++i)\n\tif (protp->demand_conf != NULL)\n\t    sifnpmode(pcb, protp->protocol & ~0x8000, NPMODE_ERROR);\n    get_loop_output();\n\n    /* discard all saved packets */\n    for (pkt = pend_q; pkt != NULL; pkt = nextpkt) {\n\tnextpkt = pkt->next;\n\tfree(pkt);\n    }\n    pend_q = NULL;\n    framelen = 0;\n    flush_flag = 0;\n    escape_flag = 0;\n    fcs = PPP_INITFCS;\n}", "path": "badvpn/lwip/src/netif/ppp/demand.c", "commit_date": "2017-09-25 00:00:00", "repo_name": "ambrop72/badvpn", "stars": 1827, "license": "other", "language": "c", "size": 6042}
{"docstring": "/** Create an ESTABLISHED pcb and check if receive callback is called if a segment\n * overlapping rcv_nxt is received */\n", "func_signal": "START_TEST(test_tcp_recv_inseq_trim)", "code": "{\n  struct test_tcp_counters counters;\n  struct tcp_pcb* pcb;\n  struct pbuf* p;\n  char data[PBUF_POOL_BUFSIZE*2];\n  u16_t data_len;\n  struct netif netif;\n  struct test_tcp_txcounters txcounters;\n  const u32_t new_data_len = 40;\n  LWIP_UNUSED_ARG(_i);\n\n  /* initialize local vars */\n  test_tcp_init_netif(&netif, &txcounters, &test_local_ip, &test_netmask);\n  data_len = sizeof(data);\n  memset(data, 0, sizeof(data));\n  /* initialize counter struct */\n  memset(&counters, 0, sizeof(counters));\n  counters.expected_data_len = data_len;\n  counters.expected_data = data;\n\n  /* create and initialize the pcb */\n  pcb = test_tcp_new_counters_pcb(&counters);\n  EXPECT_RET(pcb != NULL);\n  tcp_set_state(pcb, ESTABLISHED, &test_local_ip, &test_remote_ip, TEST_LOCAL_PORT, TEST_REMOTE_PORT);\n\n  /* create a segment (with an overlapping/old seqno so that the new data begins in the 2nd pbuf) */\n  p = tcp_create_rx_segment(pcb, counters.expected_data, data_len, (u32_t)(0-(data_len-new_data_len)), 0, 0);\n  EXPECT(p != NULL);\n  if (p != NULL) {\n    EXPECT(p->next != NULL);\n    if (p->next != NULL) {\n      EXPECT(p->next->next != NULL);\n    }\n  }\n  if ((p != NULL) && (p->next != NULL) && (p->next->next != NULL)) {\n    /* pass the segment to tcp_input */\n    test_tcp_input(p, &netif);\n    /* check if counters are as expected */\n    EXPECT(counters.close_calls == 0);\n    EXPECT(counters.recv_calls == 1);\n    EXPECT(counters.recved_bytes == new_data_len);\n    EXPECT(counters.err_calls == 0);\n  }\n\n  /* make sure the pcb is freed */\n  EXPECT(MEMP_STATS_GET(used, MEMP_TCP_PCB) == 1);\n  tcp_abort(pcb);\n  EXPECT(MEMP_STATS_GET(used, MEMP_TCP_PCB) == 0);\n}", "path": "badvpn/lwip/test/unit/tcp/test_tcp.c", "commit_date": "2017-09-25 00:00:00", "repo_name": "ambrop72/badvpn", "stars": 1827, "license": "other", "language": "c", "size": 6042}
{"docstring": "/*\n * demand_conf - configure the interface for doing dial-on-demand.\n */\n", "func_signal": "void\ndemand_conf()", "code": "{\n    int i;\n    const struct protent *protp;\n\n/*    framemax = lcp_allowoptions[0].mru;\n    if (framemax < PPP_MRU) */\n\tframemax = PPP_MRU;\n    framemax += PPP_HDRLEN + PPP_FCSLEN;\n    frame = malloc(framemax);\n    if (frame == NULL)\n\tnovm(\"demand frame\");\n    framelen = 0;\n    pend_q = NULL;\n    escape_flag = 0;\n    flush_flag = 0;\n    fcs = PPP_INITFCS;\n\n    netif_set_mtu(pcb, LWIP_MIN(lcp_allowoptions[0].mru, PPP_MRU));\n    if (ppp_send_config(pcb, PPP_MRU, (u32_t) 0, 0, 0) < 0\n\t|| ppp_recv_config(pcb, PPP_MRU, (u32_t) 0, 0, 0) < 0)\n\t    fatal(\"Couldn't set up demand-dialled PPP interface: %m\");\n\n#ifdef PPP_FILTER\n    set_filters(&pass_filter, &active_filter);\n#endif\n\n    /*\n     * Call the demand_conf procedure for each protocol that's got one.\n     */\n    for (i = 0; (protp = protocols[i]) != NULL; ++i)\n\tif (protp->demand_conf != NULL)\n\t    ((*protp->demand_conf)(pcb));\n/* FIXME: find a way to die() here */\n#if 0\n\t    if (!((*protp->demand_conf)(pcb)))\n\t\tdie(1);\n#endif\n}", "path": "badvpn/lwip/src/netif/ppp/demand.c", "commit_date": "2017-09-25 00:00:00", "repo_name": "ambrop72/badvpn", "stars": 1827, "license": "other", "language": "c", "size": 6042}
{"docstring": "/* SMTP_BODYDH */\n", "func_signal": "static struct altcp_pcb*\nsmtp_setup_pcb(struct smtp_session *s, const ip_addr_t* remote_ip)", "code": "{\n  struct altcp_pcb* pcb;\n  LWIP_UNUSED_ARG(remote_ip);\n\n  pcb = altcp_tcp_new_ip_type(IP_GET_TYPE(remote_ip));\n  if (pcb != NULL) {\n#if LWIP_ALTCP && LWIP_ALTCP_TLS\n    if (smtp_server_tls_config) {\n      struct altcp_pcb *pcb_tls = altcp_tls_new(smtp_server_tls_config, pcb);\n      if (pcb_tls == NULL) {\n        altcp_close(pcb);\n        return NULL;\n      }\n      pcb = pcb_tls;\n    }\n#endif\n    altcp_arg(pcb, s);\n    altcp_recv(pcb, smtp_tcp_recv);\n    altcp_err(pcb, smtp_tcp_err);\n    altcp_poll(pcb, smtp_tcp_poll, SMTP_POLL_INTERVAL);\n    altcp_sent(pcb, smtp_tcp_sent);\n  }\n  return pcb;\n}", "path": "badvpn/lwip/src/apps/smtp/smtp.c", "commit_date": "2017-09-25 00:00:00", "repo_name": "ambrop72/badvpn", "stars": 1827, "license": "other", "language": "c", "size": 6042}
{"docstring": "/** Elementary sub-function to send data\n *\n * @returns: BDHALLDATASENT all data has been written\n *           BDHSOMEDATASENT some data has been written\n *           0 no data has been written\n */\n", "func_signal": "static int\nsmtp_send_bodyh_data(struct altcp_pcb *pcb, const char **from, u16_t *howmany)", "code": "{\n  err_t err;\n  u16_t len = *howmany;\n\n  len = (u16_t)LWIP_MIN(len, altcp_sndbuf(pcb));\n  err = altcp_write(pcb, *from, len, TCP_WRITE_FLAG_COPY);\n  if (err == ERR_OK) {\n    *from += len;\n    if ((*howmany -= len) > 0) {\n      return BDHSOMEDATASENT;\n    }\n    return BDHALLDATASENT;\n  }\n  return 0;\n}", "path": "badvpn/lwip/src/apps/smtp/smtp.c", "commit_date": "2017-09-25 00:00:00", "repo_name": "ambrop72/badvpn", "stars": 1827, "license": "other", "language": "c", "size": 6042}
{"docstring": "/** Prepare HELO/EHLO message */\n", "func_signal": "static enum smtp_session_state\nsmtp_prepare_helo(struct smtp_session *s, u16_t *tx_buf_len, struct altcp_pcb *pcb)", "code": "{\n  size_t ipa_len;\n  const char *ipa = ipaddr_ntoa(altcp_get_ip(pcb, 1));\n  LWIP_ASSERT(\"ipaddr_ntoa returned NULL\", ipa != NULL);\n  ipa_len = strlen(ipa);\n  LWIP_ASSERT(\"string too long\", ipa_len <= (SMTP_TX_BUF_LEN-SMTP_CMD_EHLO_1_LEN-SMTP_CMD_EHLO_2_LEN));\n\n  *tx_buf_len = (u16_t)(SMTP_CMD_EHLO_1_LEN + (u16_t)ipa_len + SMTP_CMD_EHLO_2_LEN);\n  LWIP_ASSERT(\"tx_buf overflow detected\", *tx_buf_len <= SMTP_TX_BUF_LEN);\n\n  SMEMCPY(s->tx_buf, SMTP_CMD_EHLO_1, SMTP_CMD_EHLO_1_LEN);\n  MEMCPY(&s->tx_buf[SMTP_CMD_EHLO_1_LEN], ipa, ipa_len);\n  SMEMCPY(&s->tx_buf[SMTP_CMD_EHLO_1_LEN + ipa_len], SMTP_CMD_EHLO_2, SMTP_CMD_EHLO_2_LEN);\n  return SMTP_HELO;\n}", "path": "badvpn/lwip/src/apps/smtp/smtp.c", "commit_date": "2017-09-25 00:00:00", "repo_name": "ambrop72/badvpn", "stars": 1827, "license": "other", "language": "c", "size": 6042}
{"docstring": "/** Prepare RCPT message */\n", "func_signal": "static enum smtp_session_state\nsmtp_prepare_rcpt(struct smtp_session *s, u16_t *tx_buf_len)", "code": "{\n  char *target = s->tx_buf;\n  LWIP_ASSERT(\"tx_buf overflow detected\", s->to_len <= (SMTP_TX_BUF_LEN - SMTP_CMD_RCPT_1_LEN - SMTP_CMD_RCPT_2_LEN));\n  *tx_buf_len = (u16_t)(SMTP_CMD_RCPT_1_LEN + SMTP_CMD_RCPT_2_LEN + s->to_len);\n  target[*tx_buf_len] = 0;\n\n  SMEMCPY(target, SMTP_CMD_RCPT_1, SMTP_CMD_RCPT_1_LEN);\n  target += SMTP_CMD_RCPT_1_LEN;\n  MEMCPY(target, s->to, s->to_len);\n  target += s->to_len;\n  SMEMCPY(target, SMTP_CMD_RCPT_2, SMTP_CMD_RCPT_2_LEN);\n  return SMTP_RCPT;\n}", "path": "badvpn/lwip/src/apps/smtp/smtp.c", "commit_date": "2017-09-25 00:00:00", "repo_name": "ambrop72/badvpn", "stars": 1827, "license": "other", "language": "c", "size": 6042}
{"docstring": "/** @ingroup smtp\n * Set IP address or DNS name for next SMTP connection\n *\n * @param server IP address (in ASCII representation) or DNS name of the server\n */\n", "func_signal": "err_t\nsmtp_set_server_addr(const char* server)", "code": "{\n  size_t len = 0;\n  if (server != NULL) {\n    /* strnlen: returns length WITHOUT terminating 0 byte OR\n     * SMTP_MAX_SERVERNAME_LEN+1 when string is too long */\n    len = strnlen(server, SMTP_MAX_SERVERNAME_LEN+1);\n  }\n  if (len > SMTP_MAX_SERVERNAME_LEN) {\n    return ERR_MEM;\n  }\n  if (len != 0) {\n    MEMCPY(smtp_server, server, len);\n  }\n  smtp_server[len] = 0; /* always OK because of smtp_server[SMTP_MAX_SERVERNAME_LEN + 1] */\n  return ERR_OK;\n}", "path": "badvpn/lwip/src/apps/smtp/smtp.c", "commit_date": "2017-09-25 00:00:00", "repo_name": "ambrop72/badvpn", "stars": 1827, "license": "other", "language": "c", "size": 6042}
{"docstring": "/** Prepare header of body */\n", "func_signal": "static enum smtp_session_state\nsmtp_prepare_header(struct smtp_session *s, u16_t *tx_buf_len)", "code": "{\n  char *target = s->tx_buf;\n  int len = SMTP_CMD_HEADER_1_LEN + SMTP_CMD_HEADER_2_LEN +\n    SMTP_CMD_HEADER_3_LEN + SMTP_CMD_HEADER_4_LEN + s->from_len + s->to_len +\n    s->subject_len;\n  LWIP_ASSERT(\"tx_buf overflow detected\", len > 0 && len <= SMTP_TX_BUF_LEN);\n  *tx_buf_len = (u16_t)len;\n  target[*tx_buf_len] = 0;\n\n  SMEMCPY(target, SMTP_CMD_HEADER_1, SMTP_CMD_HEADER_1_LEN);\n  target += SMTP_CMD_HEADER_1_LEN;\n  MEMCPY(target, s->from, s->from_len);\n  target += s->from_len;\n  SMEMCPY(target, SMTP_CMD_HEADER_2, SMTP_CMD_HEADER_2_LEN);\n  target += SMTP_CMD_HEADER_2_LEN;\n  MEMCPY(target, s->to, s->to_len);\n  target += s->to_len;\n  SMEMCPY(target, SMTP_CMD_HEADER_3, SMTP_CMD_HEADER_3_LEN);\n  target += SMTP_CMD_HEADER_3_LEN;\n  MEMCPY(target, s->subject, s->subject_len);\n  target += s->subject_len;\n  SMEMCPY(target, SMTP_CMD_HEADER_4, SMTP_CMD_HEADER_4_LEN);\n\n  return SMTP_BODY;\n}", "path": "badvpn/lwip/src/apps/smtp/smtp.c", "commit_date": "2017-09-25 00:00:00", "repo_name": "ambrop72/badvpn", "stars": 1827, "license": "other", "language": "c", "size": 6042}
{"docstring": "/** Raw API TCP recv callback */\n", "func_signal": "static err_t\nsmtp_tcp_recv(void *arg, struct altcp_pcb *pcb, struct pbuf *p, err_t err)", "code": "{\n  LWIP_UNUSED_ARG(err);\n  if (p != NULL) {\n    altcp_recved(pcb, p->tot_len);\n    smtp_process(arg, pcb, p);\n  } else {\n    LWIP_DEBUGF(SMTP_DEBUG_WARN_STATE, (\"smtp_tcp_recv: connection closed by remote host\\n\"));\n    smtp_close((struct smtp_session*)arg, pcb, SMTP_RESULT_ERR_CLOSED, 0, err);\n  }\n  return ERR_OK;\n}", "path": "badvpn/lwip/src/apps/smtp/smtp.c", "commit_date": "2017-09-25 00:00:00", "repo_name": "ambrop72/badvpn", "stars": 1827, "license": "other", "language": "c", "size": 6042}
{"docstring": "/** Send base64-encoded username */\n", "func_signal": "static enum smtp_session_state\nsmtp_prepare_auth_login_uname(struct smtp_session *s, u16_t *tx_buf_len)", "code": "{\n  size_t base64_len = smtp_base64_encode(s->tx_buf, SMTP_TX_BUF_LEN,\n    SMTP_USERNAME(s), strlen(SMTP_USERNAME(s)));\n  /* @todo: support base64-encoded longer than 64k */\n  LWIP_ASSERT(\"string too long\", base64_len <= 0xffff);\n  LWIP_ASSERT(\"tx_buf overflow detected\", base64_len <= SMTP_TX_BUF_LEN - SMTP_CRLF_LEN);\n  *tx_buf_len = (u16_t)(base64_len + SMTP_CRLF_LEN);\n\n  SMEMCPY(&s->tx_buf[base64_len], SMTP_CRLF, SMTP_CRLF_LEN);\n  s->tx_buf[*tx_buf_len] = 0;\n  return SMTP_AUTH_LOGIN_PASS;\n}", "path": "badvpn/lwip/src/apps/smtp/smtp.c", "commit_date": "2017-09-25 00:00:00", "repo_name": "ambrop72/badvpn", "stars": 1827, "license": "other", "language": "c", "size": 6042}
{"docstring": "/** If in state SMTP_BODY, try to send more body data */\n", "func_signal": "static void\nsmtp_send_body(struct smtp_session *s, struct altcp_pcb *pcb)", "code": "{\n  err_t err;\n\n  if (s->state == SMTP_BODY) {\n#if SMTP_BODYDH\n    if (s->bodydh) {\n      smtp_send_body_data_handler(s, pcb);\n    } else\n#endif /* SMTP_BODYDH */\n    {\n      u16_t send_len = (u16_t)(s->body_len - s->body_sent);\n      if (send_len > 0) {\n        u16_t snd_buf = altcp_sndbuf(pcb);\n        if (send_len > snd_buf) {\n          send_len = snd_buf;\n        }\n        if (send_len > 0) {\n          /* try to send something out */\n          err = altcp_write(pcb, &s->body[s->body_sent], (u16_t)send_len, TCP_WRITE_FLAG_COPY);\n          if (err == ERR_OK) {\n            s->timer = SMTP_TIMEOUT_DATABLOCK;\n            s->body_sent = (u16_t)(s->body_sent + send_len);\n            if (s->body_sent < s->body_len) {\n              LWIP_DEBUGF(SMTP_DEBUG_STATE, (\"smtp_send_body: %d of %d bytes written\\n\",\n                s->body_sent, s->body_len));\n            }\n          }\n        }\n      }\n    }\n    if (s->body_sent == s->body_len) {\n      /* the whole body has been written, write last line */\n      LWIP_DEBUGF(SMTP_DEBUG_STATE, (\"smtp_send_body: body completely written (%d bytes), appending end-of-body\\n\",\n        s->body_len));\n      err = altcp_write(pcb, SMTP_CMD_BODY_FINISHED, SMTP_CMD_BODY_FINISHED_LEN, 0);\n      if (err == ERR_OK) {\n        s->timer = SMTP_TIMEOUT_DATATERM;\n        LWIP_DEBUGF(SMTP_DEBUG_STATE, (\"smtp_send_body: end-of-body written, changing state to %s\\n\",\n          smtp_state_str[SMTP_QUIT]));\n        /* last line written, change state, wait for confirmation */\n        s->state = SMTP_QUIT;\n      }\n    }\n  }\n}", "path": "badvpn/lwip/src/apps/smtp/smtp.c", "commit_date": "2017-09-25 00:00:00", "repo_name": "ambrop72/badvpn", "stars": 1827, "license": "other", "language": "c", "size": 6042}
{"docstring": "/** Check that we handle malformed tcp headers, and discard the pbuf(s) */\n", "func_signal": "START_TEST(test_tcp_malformed_header)", "code": "{\n  struct test_tcp_counters counters;\n  struct tcp_pcb* pcb;\n  struct pbuf* p;\n  char data[] = {1, 2, 3, 4};\n  u16_t data_len, chksum;\n  struct netif netif;\n  struct test_tcp_txcounters txcounters;\n  struct tcp_hdr *hdr;\n  LWIP_UNUSED_ARG(_i);\n\n  /* initialize local vars */\n  test_tcp_init_netif(&netif, &txcounters, &test_local_ip, &test_netmask);\n  data_len = sizeof(data);\n  /* initialize counter struct */\n  memset(&counters, 0, sizeof(counters));\n  counters.expected_data_len = data_len;\n  counters.expected_data = data;\n\n  /* create and initialize the pcb */\n  pcb = test_tcp_new_counters_pcb(&counters);\n  EXPECT_RET(pcb != NULL);\n  tcp_set_state(pcb, ESTABLISHED, &test_local_ip, &test_remote_ip, TEST_LOCAL_PORT, TEST_REMOTE_PORT);\n\n  /* create a segment */\n  p = tcp_create_rx_segment(pcb, counters.expected_data, data_len, 0, 0, 0);\n\n  pbuf_header(p, -(s16_t)sizeof(struct ip_hdr));\n\n  hdr = (struct tcp_hdr *)p->payload;\n  TCPH_HDRLEN_FLAGS_SET(hdr, 15, 0x3d1);\n\n  hdr->chksum = 0;\n\n  chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,\n                             &test_remote_ip, &test_local_ip);\n\n  hdr->chksum = chksum;\n\n  pbuf_header(p, sizeof(struct ip_hdr));\n\n  EXPECT(p != NULL);\n  EXPECT(p->next == NULL);\n  if (p != NULL) {\n    /* pass the segment to tcp_input */\n    test_tcp_input(p, &netif);\n    /* check if counters are as expected */\n    EXPECT(counters.close_calls == 0);\n    EXPECT(counters.recv_calls == 0);\n    EXPECT(counters.recved_bytes == 0);\n    EXPECT(counters.err_calls == 0);\n  }\n\n  /* make sure the pcb is freed */\n  EXPECT(MEMP_STATS_GET(used, MEMP_TCP_PCB) == 1);\n  tcp_abort(pcb);\n  EXPECT(MEMP_STATS_GET(used, MEMP_TCP_PCB) == 0);\n}", "path": "badvpn/lwip/test/unit/tcp/test_tcp.c", "commit_date": "2017-09-25 00:00:00", "repo_name": "ambrop72/badvpn", "stars": 1827, "license": "other", "language": "c", "size": 6042}
{"docstring": "/** Raw API TCP err callback: pcb is already deallocated */\n", "func_signal": "static void\nsmtp_tcp_err(void *arg, err_t err)", "code": "{\n  LWIP_UNUSED_ARG(err);\n  if (arg != NULL) {\n    LWIP_DEBUGF(SMTP_DEBUG_WARN_STATE, (\"smtp_tcp_err: connection reset by remote host\\n\"));\n    smtp_free((struct smtp_session*)arg, SMTP_RESULT_ERR_CLOSED, 0, err);\n  }\n}", "path": "badvpn/lwip/src/apps/smtp/smtp.c", "commit_date": "2017-09-25 00:00:00", "repo_name": "ambrop72/badvpn", "stars": 1827, "license": "other", "language": "c", "size": 6042}
{"docstring": "/*\n * demand_unblock - set each enabled network protocol to pass packets.\n */\n", "func_signal": "void\ndemand_unblock()", "code": "{\n    int i;\n    const struct protent *protp;\n\n    for (i = 0; (protp = protocols[i]) != NULL; ++i)\n\tif (protp->demand_conf != NULL)\n\t    sifnpmode(pcb, protp->protocol & ~0x8000, NPMODE_PASS);\n}", "path": "badvpn/lwip/src/netif/ppp/demand.c", "commit_date": "2017-09-25 00:00:00", "repo_name": "ambrop72/badvpn", "stars": 1827, "license": "other", "language": "c", "size": 6042}
{"docstring": "/*\n    outLen should contain the size of out buffer when input. outLen is than set\n    to the final output length.\n    returns 0 on success\n */\n", "func_signal": "int wc_ed25519_export_public(ed25519_key* key, byte* out, word32* outLen)", "code": "{\n    /* sanity check on arguments */\n    if (key == NULL || out == NULL || outLen == NULL)\n        return BAD_FUNC_ARG;\n\n    if (*outLen < ED25519_PUB_KEY_SIZE) {\n        *outLen = ED25519_PUB_KEY_SIZE;\n        return BUFFER_E;\n    }\n\n    *outLen = ED25519_PUB_KEY_SIZE;\n    XMEMCPY(out, key->p, ED25519_PUB_KEY_SIZE);\n\n    return 0;\n}", "path": "Arduino-HomeKit-ESP8266/src/wolfcrypt/src/ed25519.c", "commit_date": "2020-02-16 00:00:00", "repo_name": "Mixiaoxiao/Arduino-HomeKit-ESP8266", "stars": 1421, "license": "mit", "language": "c", "size": 2660}
{"docstring": "/**\n  * API to encrypt/decrypt a message of any size.\n  */\n", "func_signal": "int wc_Chacha_Process(ChaCha* ctx, byte* output, const byte* input,\n                      word32 msglen)", "code": "{\n    if (ctx == NULL)\n        return BAD_FUNC_ARG;\n\n#ifdef USE_INTEL_CHACHA_SPEEDUP\n    #ifdef HAVE_INTEL_AVX2\n    if (IS_INTEL_AVX2(cpuid_get_flags())) {\n        chacha_encrypt_avx2(ctx, input, output, msglen);\n        return 0;\n    }\n    #endif\n    if (IS_INTEL_AVX1(cpuid_get_flags())) {\n        chacha_encrypt_avx(ctx, input, output, msglen);\n        return 0;\n    }\n#endif\n    wc_Chacha_encrypt_bytes(ctx, input, output, msglen);\n\n    return 0;\n}", "path": "Arduino-HomeKit-ESP8266/src/wolfcrypt/src/chacha.c", "commit_date": "2020-02-16 00:00:00", "repo_name": "Mixiaoxiao/Arduino-HomeKit-ESP8266", "stars": 1421, "license": "mit", "language": "c", "size": 2660}
{"docstring": "/* returns the size of signature in bytes */\n", "func_signal": "int wc_ed25519_sig_size(ed25519_key* key)", "code": "{\n    if (key == NULL)\n        return BAD_FUNC_ARG;\n\n    return ED25519_SIG_SIZE;\n}", "path": "Arduino-HomeKit-ESP8266/src/wolfcrypt/src/ed25519.c", "commit_date": "2020-02-16 00:00:00", "repo_name": "Mixiaoxiao/Arduino-HomeKit-ESP8266", "stars": 1421, "license": "mit", "language": "c", "size": 2660}
{"docstring": "/*\n    For importing a private key.\n */\n", "func_signal": "int wc_ed25519_import_private_only(const byte* priv, word32 privSz,\n                                                               ed25519_key* key)", "code": "{\n    /* sanity check on arguments */\n    if (priv == NULL || key == NULL)\n        return BAD_FUNC_ARG;\n\n    /* key size check */\n    if (privSz < ED25519_KEY_SIZE)\n        return BAD_FUNC_ARG;\n\n    XMEMCPY(key->k, priv, ED25519_KEY_SIZE);\n\n    return 0;\n}", "path": "Arduino-HomeKit-ESP8266/src/wolfcrypt/src/ed25519.c", "commit_date": "2020-02-16 00:00:00", "repo_name": "Mixiaoxiao/Arduino-HomeKit-ESP8266", "stars": 1421, "license": "mit", "language": "c", "size": 2660}
{"docstring": "/*\n   Test if the public key can be uncompressed and negate it (-X,Y,Z,-T)\n   return 0 on success\n */\n", "func_signal": "int ge_frombytes_negate_vartime(ge_p3 *p,const unsigned char *s)", "code": "{\n\n    byte parity;\n    byte x[F25519_SIZE];\n    byte y[F25519_SIZE];\n    byte a[F25519_SIZE];\n    byte b[F25519_SIZE];\n    byte c[F25519_SIZE];\n    int ret = 0;\n\n    /* unpack the key s */\n    parity = s[31] >> 7;\n    lm_copy(y, s);\n    y[31] &= 127;\n\n    fe_mul__distinct(c, y, y);\n    fe_mul__distinct(b, c, ed25519_d);\n    lm_add(a, b, f25519_one);\n    fe_inv__distinct(b, a);\n    lm_sub(a, c, f25519_one);\n    fe_mul__distinct(c, a, b);\n    fe_sqrt(a, c);\n    lm_neg(b, a);\n    fe_select(x, a, b, (a[0] ^ parity) & 1);\n\n    /* test that x^2 is equal to c */\n    fe_mul__distinct(a, x, x);\n    fe_normalize(a);\n    fe_normalize(c);\n    ret |= ConstantCompare(a, c, F25519_SIZE);\n\n    /* project the key s onto p */\n    lm_copy(p->X, x);\n    lm_copy(p->Y, y);\n    fe_load(p->Z, 1);\n    fe_mul__distinct(p->T, x, y);\n\n    /* negate, the point becomes (-X,Y,Z,-T) */\n    lm_neg(p->X,p->X);\n    lm_neg(p->T,p->T);\n\n    return ret;\n}", "path": "Arduino-HomeKit-ESP8266/src/wolfcrypt/src/ge_low_mem.c", "commit_date": "2020-03-11 00:00:00", "repo_name": "Mixiaoxiao/Arduino-HomeKit-ESP8266", "stars": 1421, "license": "mit", "language": "c", "size": 2660}
{"docstring": "// Return a string value. Returns NULL if value does not exist.\n// Caller is responsible for freeing returned value.\n", "func_signal": "char *tlv_get_string_value(const tlv_values_t *values, byte type)", "code": "{\n    tlv_t *t = tlv_get_value(values, type);\n    if (!t)\n        return NULL;\n\n    return strndup((char*)t->value, t->size);\n}", "path": "Arduino-HomeKit-ESP8266/src/tlv.c", "commit_date": "2020-02-16 00:00:00", "repo_name": "Mixiaoxiao/Arduino-HomeKit-ESP8266", "stars": 1421, "license": "mit", "language": "c", "size": 2660}
{"docstring": "/* generate an ed25519 key pair.\n * returns 0 on success\n */\n", "func_signal": "int wc_ed25519_make_key(WC_RNG* rng, int keySz, ed25519_key* key)", "code": "{\n    byte  az[ED25519_PRV_KEY_SIZE];\n    int   ret;\n#if !defined(FREESCALE_LTC_ECC)\n    ge_p3 A;\n#endif\n\n    if (rng == NULL || key == NULL)\n        return BAD_FUNC_ARG;\n\n    /* ed25519 has 32 byte key sizes */\n    if (keySz != ED25519_KEY_SIZE)\n        return BAD_FUNC_ARG;\n\n    ret  = wc_RNG_GenerateBlock(rng, key->k, ED25519_KEY_SIZE);\n    if (ret != 0)\n        return ret;\n    ret = wc_Sha512Hash(key->k, ED25519_KEY_SIZE, az);\n    if (ret != 0) {\n        ForceZero(key->k, ED25519_KEY_SIZE);\n        return ret;\n    }\n\n    /* apply clamp */\n    az[0]  &= 248;\n    az[31] &= 63; /* same than az[31] &= 127 because of az[31] |= 64 */\n    az[31] |= 64;\n\n#ifdef FREESCALE_LTC_ECC\n    ltc_pkha_ecc_point_t publicKey = {0};\n    publicKey.X = key->pointX;\n    publicKey.Y = key->pointY;\n    LTC_PKHA_Ed25519_PointMul(LTC_PKHA_Ed25519_BasePoint(), az, ED25519_KEY_SIZE, &publicKey, kLTC_Ed25519 /* result on Ed25519 */);\n    LTC_PKHA_Ed25519_Compress(&publicKey, key->p);\n#else\n    ge_scalarmult_base(&A, az);\n    ge_p3_tobytes(key->p, &A);\n#endif\n    /* put public key after private key, on the same buffer */\n    XMEMMOVE(key->k + ED25519_KEY_SIZE, key->p, ED25519_PUB_KEY_SIZE);\n\n    return ret;\n}", "path": "Arduino-HomeKit-ESP8266/src/wolfcrypt/src/ed25519.c", "commit_date": "2020-02-16 00:00:00", "repo_name": "Mixiaoxiao/Arduino-HomeKit-ESP8266", "stars": 1421, "license": "mit", "language": "c", "size": 2660}
{"docstring": "// Deserializes a TLV value and returns it. Returns NULL if value does not exist\n// or incorrect. Caller is responsible for freeing returned value.\n", "func_signal": "tlv_values_t *tlv_get_tlv_value(const tlv_values_t *values, byte type)", "code": "{\n    tlv_t *t = tlv_get_value(values, type);\n    if (!t)\n        return NULL;\n\n    tlv_values_t *value = tlv_new();\n    int r = tlv_parse(t->value, t->size, value);\n\n    if (r) {\n        tlv_free(value);\n        return NULL;\n    }\n\n    return value;\n}", "path": "Arduino-HomeKit-ESP8266/src/tlv.c", "commit_date": "2020-02-16 00:00:00", "repo_name": "Mixiaoxiao/Arduino-HomeKit-ESP8266", "stars": 1421, "license": "mit", "language": "c", "size": 2660}
{"docstring": "/* returns the private key size (secret + public) in bytes */\n", "func_signal": "int wc_ed25519_priv_size(ed25519_key* key)", "code": "{\n    if (key == NULL)\n        return BAD_FUNC_ARG;\n\n    return ED25519_PRV_KEY_SIZE;\n}", "path": "Arduino-HomeKit-ESP8266/src/wolfcrypt/src/ed25519.c", "commit_date": "2020-02-16 00:00:00", "repo_name": "Mixiaoxiao/Arduino-HomeKit-ESP8266", "stars": 1421, "license": "mit", "language": "c", "size": 2660}
{"docstring": "/* pack the point h into array s */\n", "func_signal": "void ge_p3_tobytes(unsigned char *s,const ge_p3 *h)", "code": "{\n    byte x[F25519_SIZE];\n    byte y[F25519_SIZE];\n    byte z1[F25519_SIZE];\n    byte parity;\n\n    fe_inv__distinct(z1, h->Z);\n    fe_mul__distinct(x, h->X, z1);\n    fe_mul__distinct(y, h->Y, z1);\n\n    fe_normalize(x);\n    fe_normalize(y);\n\n    parity = (x[0] & 1) << 7;\n    lm_copy(s, y);\n    fe_normalize(s);\n    s[31] |= parity;\n}", "path": "Arduino-HomeKit-ESP8266/src/wolfcrypt/src/ge_low_mem.c", "commit_date": "2020-03-11 00:00:00", "repo_name": "Mixiaoxiao/Arduino-HomeKit-ESP8266", "stars": 1421, "license": "mit", "language": "c", "size": 2660}
{"docstring": "/**\n  * Set up iv(nonce). Earlier versions used 64 bits instead of 96, this version\n  * uses the typical AEAD 96 bit nonce and can do record sizes of 256 GB.\n  */\n", "func_signal": "int wc_Chacha_SetIV(ChaCha* ctx, const byte* inIv, word32 counter)", "code": "{\n    word32 temp[CHACHA_IV_WORDS];/* used for alignment of memory */\n\n#ifdef CHACHA_AEAD_TEST\n    word32 i;\n    printf(\"NONCE : \");\n    for (i = 0; i < CHACHA_IV_BYTES; i++) {\n        printf(\"%02x\", inIv[i]);\n    }\n    printf(\"\\n\\n\");\n#endif\n\n    if (ctx == NULL)\n        return BAD_FUNC_ARG;\n\n    XMEMCPY(temp, inIv, CHACHA_IV_BYTES);\n\n    ctx->X[CHACHA_IV_BYTES+0] = counter;           /* block counter */\n    ctx->X[CHACHA_IV_BYTES+1] = LITTLE32(temp[0]); /* fixed variable from nonce */\n    ctx->X[CHACHA_IV_BYTES+2] = LITTLE32(temp[1]); /* counter from nonce */\n    ctx->X[CHACHA_IV_BYTES+3] = LITTLE32(temp[2]); /* counter from nonce */\n\n    return 0;\n}", "path": "Arduino-HomeKit-ESP8266/src/wolfcrypt/src/chacha.c", "commit_date": "2020-02-16 00:00:00", "repo_name": "Mixiaoxiao/Arduino-HomeKit-ESP8266", "stars": 1421, "license": "mit", "language": "c", "size": 2660}
{"docstring": "/* pack the point h into array s */\n", "func_signal": "void ge_tobytes(unsigned char *s,const ge_p2 *h)", "code": "{\n    byte x[F25519_SIZE];\n    byte y[F25519_SIZE];\n    byte z1[F25519_SIZE];\n    byte parity;\n\n    fe_inv__distinct(z1, h->Z);\n    fe_mul__distinct(x, h->X, z1);\n    fe_mul__distinct(y, h->Y, z1);\n\n    fe_normalize(x);\n    fe_normalize(y);\n\n    parity = (x[0] & 1) << 7;\n    lm_copy(s, y);\n    fe_normalize(s);\n    s[31] |= parity;\n}", "path": "Arduino-HomeKit-ESP8266/src/wolfcrypt/src/ge_low_mem.c", "commit_date": "2020-03-11 00:00:00", "repo_name": "Mixiaoxiao/Arduino-HomeKit-ESP8266", "stars": 1421, "license": "mit", "language": "c", "size": 2660}
{"docstring": "/*\n    Imports a compressed/uncompressed public key.\n    in    the byte array containing the public key\n    inLen the length of the byte array being passed in\n    key   ed25519 key struct to put the public key in\n */\n", "func_signal": "int wc_ed25519_import_public(const byte* in, word32 inLen, ed25519_key* key)", "code": "{\n    int    ret;\n\n    /* sanity check on arguments */\n    if (in == NULL || key == NULL)\n        return BAD_FUNC_ARG;\n\n    if (inLen < ED25519_PUB_KEY_SIZE)\n        return BAD_FUNC_ARG;\n\n    /* compressed prefix according to draft\n       http://www.ietf.org/id/draft-koch-eddsa-for-openpgp-02.txt */\n    if (in[0] == 0x40 && inLen > ED25519_PUB_KEY_SIZE) {\n        /* key is stored in compressed format so just copy in */\n        XMEMCPY(key->p, (in + 1), ED25519_PUB_KEY_SIZE);\n#ifdef FREESCALE_LTC_ECC\n        /* recover X coordinate */\n        ltc_pkha_ecc_point_t pubKey;\n        pubKey.X = key->pointX;\n        pubKey.Y = key->pointY;\n        LTC_PKHA_Ed25519_PointDecompress(key->p, ED25519_PUB_KEY_SIZE, &pubKey);\n#endif\n        return 0;\n    }\n\n    /* importing uncompressed public key */\n    if (in[0] == 0x04 && inLen > 2*ED25519_PUB_KEY_SIZE) {\n#ifdef FREESCALE_LTC_ECC\n        /* reverse bytes for little endian byte order */\n        for (int i = 0; i < ED25519_KEY_SIZE; i++)\n        {\n            key->pointX[i] = *(in + ED25519_KEY_SIZE - i);\n            key->pointY[i] = *(in + 2*ED25519_KEY_SIZE - i);\n        }\n        XMEMCPY(key->p, key->pointY, ED25519_KEY_SIZE);\n        ret = 0;\n#else\n        /* pass in (x,y) and store compressed key */\n        ret = ge_compress_key(key->p, in+1,\n                              in+1+ED25519_PUB_KEY_SIZE, ED25519_PUB_KEY_SIZE);\n#endif /* FREESCALE_LTC_ECC */\n        return ret;\n    }\n\n    /* if not specified compressed or uncompressed check key size\n       if key size is equal to compressed key size copy in key */\n    if (inLen == ED25519_PUB_KEY_SIZE) {\n        XMEMCPY(key->p, in, ED25519_PUB_KEY_SIZE);\n#ifdef FREESCALE_LTC_ECC\n        /* recover X coordinate */\n        ltc_pkha_ecc_point_t pubKey;\n        pubKey.X = key->pointX;\n        pubKey.Y = key->pointY;\n        LTC_PKHA_Ed25519_PointDecompress(key->p, ED25519_PUB_KEY_SIZE, &pubKey);\n#endif\n        return 0;\n    }\n\n    /* bad public key format */\n    return BAD_FUNC_ARG;\n}", "path": "Arduino-HomeKit-ESP8266/src/wolfcrypt/src/ed25519.c", "commit_date": "2020-02-16 00:00:00", "repo_name": "Mixiaoxiao/Arduino-HomeKit-ESP8266", "stars": 1421, "license": "mit", "language": "c", "size": 2660}
{"docstring": "/*\n    For importing a private key and its associated public key.\n */\n", "func_signal": "int wc_ed25519_import_private_key(const byte* priv, word32 privSz,\n                                const byte* pub, word32 pubSz, ed25519_key* key)", "code": "{\n    int    ret;\n\n    /* sanity check on arguments */\n    if (priv == NULL || pub == NULL || key == NULL)\n        return BAD_FUNC_ARG;\n\n    /* key size check */\n    if (privSz < ED25519_KEY_SIZE || pubSz < ED25519_PUB_KEY_SIZE)\n        return BAD_FUNC_ARG;\n\n    /* import public key */\n    ret = wc_ed25519_import_public(pub, pubSz, key);\n    if (ret != 0)\n        return ret;\n\n    /* make the private key (priv + pub) */\n    XMEMCPY(key->k, priv, ED25519_KEY_SIZE);\n    XMEMCPY(key->k + ED25519_KEY_SIZE, key->p, ED25519_PUB_KEY_SIZE);\n\n    return ret;\n}", "path": "Arduino-HomeKit-ESP8266/src/wolfcrypt/src/ed25519.c", "commit_date": "2020-02-16 00:00:00", "repo_name": "Mixiaoxiao/Arduino-HomeKit-ESP8266", "stars": 1421, "license": "mit", "language": "c", "size": 2660}
{"docstring": "/* export full private key and public key\n   return 0 on success\n */\n", "func_signal": "int wc_ed25519_export_key(ed25519_key* key,\n                          byte* priv, word32 *privSz,\n                          byte* pub, word32 *pubSz)", "code": "{\n    int ret;\n\n    /* export 'full' private part */\n    ret = wc_ed25519_export_private(key, priv, privSz);\n    if (ret != 0)\n        return ret;\n\n    /* export public part */\n    ret = wc_ed25519_export_public(key, pub, pubSz);\n\n    return ret;\n}", "path": "Arduino-HomeKit-ESP8266/src/wolfcrypt/src/ed25519.c", "commit_date": "2020-02-16 00:00:00", "repo_name": "Mixiaoxiao/Arduino-HomeKit-ESP8266", "stars": 1421, "license": "mit", "language": "c", "size": 2660}
{"docstring": "/*!\t\\brief Increment index\n**\t\\details Increment buffer index \\b pIdx rolling back to \\b start when limit \\b end is reached\n**\t\\param [in,out] pIdx - pointer to index value\n**\t\\param [in] end - counter upper limit value\n**\t\\param [in] start - counter lower limit value\n**/\n", "func_signal": "static inline void __attribute__((nonnull, always_inline)) inc_idx(uint16_t * const pIdx, const uint16_t end, const uint16_t start)", "code": "{\n//\t(*pIdx)++;\n//\t*pIdx %= end;\n\tif (*pIdx < end - 1)\t{ (*pIdx)++; }\n\telse\t\t\t\t\t{ *pIdx = start; }\n}", "path": "Arduino-HomeKit-ESP8266/src/cQueue.c", "commit_date": "2020-02-16 00:00:00", "repo_name": "Mixiaoxiao/Arduino-HomeKit-ESP8266", "stars": 1421, "license": "mit", "language": "c", "size": 2660}
{"docstring": "/* Reduce coefficients of r before calling reduce_add_sub */\n", "func_signal": "static void reduce_add_sub(word32 *r)", "code": "{\n  word32 pb = 0;\n  word32 b;\n  word32 mask;\n  int i;\n  unsigned char t[32];\n\n  for(i=0;i<32;i++)\n  {\n    pb += m[i];\n    b = lt(r[i],pb);\n    t[i] = r[i]-pb+(b<<8);\n    pb = b;\n  }\n  mask = b - 1;\n  for(i=0;i<32;i++)\n    r[i] ^= mask & (r[i] ^ t[i]);\n}", "path": "Arduino-HomeKit-ESP8266/src/wolfcrypt/src/ge_low_mem.c", "commit_date": "2020-03-11 00:00:00", "repo_name": "Mixiaoxiao/Arduino-HomeKit-ESP8266", "stars": 1421, "license": "mit", "language": "c", "size": 2660}
{"docstring": "/* initialize information and memory for key */\n", "func_signal": "int wc_ed25519_init(ed25519_key* key)", "code": "{\n    if (key == NULL)\n        return BAD_FUNC_ARG;\n\n    XMEMSET(key, 0, sizeof(ed25519_key));\n\n#ifndef FREESCALE_LTC_ECC\n    fe_init();\n#endif\n\n    return 0;\n}", "path": "Arduino-HomeKit-ESP8266/src/wolfcrypt/src/ed25519.c", "commit_date": "2020-02-16 00:00:00", "repo_name": "Mixiaoxiao/Arduino-HomeKit-ESP8266", "stars": 1421, "license": "mit", "language": "c", "size": 2660}
{"docstring": "/* clear memory of key */\n", "func_signal": "void wc_ed25519_free(ed25519_key* key)", "code": "{\n    if (key == NULL)\n        return;\n\n    ForceZero(key, sizeof(ed25519_key));\n}", "path": "Arduino-HomeKit-ESP8266/src/wolfcrypt/src/ed25519.c", "commit_date": "2020-02-16 00:00:00", "repo_name": "Mixiaoxiao/Arduino-HomeKit-ESP8266", "stars": 1421, "license": "mit", "language": "c", "size": 2660}
{"docstring": "/* assumes input is big endian format */\n", "func_signal": "int wc_bigint_from_unsigned_bin(WC_BIGINT* a, const byte* in, word32 inlen)", "code": "{\n    int err;\n\n    if (a == NULL || in == NULL || inlen == 0)\n        return BAD_FUNC_ARG;\n\n    err = wc_bigint_alloc(a, inlen);\n    if (err == 0) {\n        XMEMCPY(a->buf, in, inlen);\n    }\n\n    return err;\n}", "path": "Arduino-HomeKit-ESP8266/src/wolfcrypt/src/wolfmath.c", "commit_date": "2020-02-16 00:00:00", "repo_name": "Mixiaoxiao/Arduino-HomeKit-ESP8266", "stars": 1421, "license": "mit", "language": "c", "size": 2660}
{"docstring": "/*\n * ColumnList takes in the planner's information about this foreign table. The\n * function then finds all columns needed for query execution, including those\n * used in projections, joins, and filter clauses, de-duplicates these columns,\n * and returns them in a new list. This function is taken from mongo_fdw with\n * slight modifications.\n */\n", "func_signal": "static List *\nColumnList(RelOptInfo *baserel, Oid foreignTableId)", "code": "{\n\tList *columnList = NIL;\n\tList *neededColumnList = NIL;\n\tAttrNumber columnIndex = 1;\n\tAttrNumber columnCount = baserel->max_attr;\n#if PG_VERSION_NUM >= 90600\n\tList *targetColumnList = baserel->reltarget->exprs;\n#else\n\tList *targetColumnList = baserel->reltargetlist;\n#endif\n\tListCell *targetColumnCell = NULL;\n\tList *restrictInfoList = baserel->baserestrictinfo;\n\tListCell *restrictInfoCell = NULL;\n\tconst AttrNumber wholeRow = 0;\n\tRelation relation = heap_open(foreignTableId, AccessShareLock);\n\tTupleDesc tupleDescriptor = RelationGetDescr(relation);\n\n\t/* first add the columns used in joins and projections */\n\tforeach(targetColumnCell, targetColumnList)\n\t{\n\t\tList *targetVarList = NIL;\n\t\tNode *targetExpr = (Node *) lfirst(targetColumnCell);\n\n#if PG_VERSION_NUM >= 90600\n\t\ttargetVarList = pull_var_clause(targetExpr,\n\t\t\t\t\t\t\t\t\t\tPVC_RECURSE_AGGREGATES |\n\t\t\t\t\t\t\t\t\t\tPVC_RECURSE_PLACEHOLDERS);\n#else\n\t\ttargetVarList = pull_var_clause(targetExpr,\n\t\t\t\t\t\t\t\t\t\tPVC_RECURSE_AGGREGATES,\n\t\t\t\t\t\t\t\t\t\tPVC_RECURSE_PLACEHOLDERS);\n#endif\n\n\t\tneededColumnList = list_union(neededColumnList, targetVarList);\n\t}\n\n\t/* then walk over all restriction clauses, and pull up any used columns */\n\tforeach(restrictInfoCell, restrictInfoList)\n\t{\n\t\tRestrictInfo *restrictInfo = (RestrictInfo *) lfirst(restrictInfoCell);\n\t\tNode *restrictClause = (Node *) restrictInfo->clause;\n\t\tList *clauseColumnList = NIL;\n\n\t\t/* recursively pull up any columns used in the restriction clause */\n#if PG_VERSION_NUM >= 90600\n\t\tclauseColumnList = pull_var_clause(restrictClause,\n\t\t\t\t\t\t\t\t\t\t   PVC_RECURSE_AGGREGATES |\n\t\t\t\t\t\t\t\t\t\t   PVC_RECURSE_PLACEHOLDERS);\n#else\n\t\tclauseColumnList = pull_var_clause(restrictClause,\n\t\t\t\t\t\t\t\t\t\t   PVC_RECURSE_AGGREGATES,\n\t\t\t\t\t\t\t\t\t\t   PVC_RECURSE_PLACEHOLDERS);\n#endif\n\n\t\tneededColumnList = list_union(neededColumnList, clauseColumnList);\n\t}\n\n\t/* walk over all column definitions, and de-duplicate column list */\n\tfor (columnIndex = 1; columnIndex <= columnCount; columnIndex++)\n\t{\n\t\tListCell *neededColumnCell = NULL;\n\t\tVar *column = NULL;\n\t\tForm_pg_attribute attributeForm =  TupleDescAttr(tupleDescriptor, columnIndex - 1);\n\n\t\tif (attributeForm->attisdropped)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* look for this column in the needed column list */\n\t\tforeach(neededColumnCell, neededColumnList)\n\t\t{\n\t\t\tVar *neededColumn = (Var *) lfirst(neededColumnCell);\n\t\t\tif (neededColumn->varattno == columnIndex)\n\t\t\t{\n\t\t\t\tcolumn = neededColumn;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (neededColumn->varattno == wholeRow)\n\t\t\t{\n\t\t\t\tIndex tableId = neededColumn->varno;\n\n\t\t\t\tcolumn = makeVar(tableId, columnIndex, attributeForm->atttypid,\n\t\t\t\t\t\t\t\t attributeForm->atttypmod, attributeForm->attcollation,\n\t\t\t\t\t\t\t\t 0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (column != NULL)\n\t\t{\n\t\t\tcolumnList = lappend(columnList, column);\n\t\t}\n\t}\n\n\theap_close(relation, AccessShareLock);\n\n\treturn columnList;\n}", "path": "cstore_fdw/cstore_fdw.c", "commit_date": "2020-02-18 00:00:00", "repo_name": "citusdata/cstore_fdw", "stars": 1740, "license": "apache-2.0", "language": "c", "size": 821}
{"docstring": "/* PageCount calculates and returns the number of pages in a file. */\n", "func_signal": "static BlockNumber\nPageCount(const char *filename)", "code": "{\n\tBlockNumber pageCount = 0;\n\tstruct stat statBuffer;\n\n\t/* if file doesn't exist at plan time, use default estimate for its size */\n\tint statResult = stat(filename, &statBuffer);\n\tif (statResult < 0)\n\t{\n\t\tstatBuffer.st_size = 10 * BLCKSZ;\n\t}\n\n\tpageCount = (statBuffer.st_size + (BLCKSZ - 1)) / BLCKSZ;\n\tif (pageCount < 1)\n\t{\n\t\tpageCount = 1;\n\t}\n\n\treturn pageCount;\n}", "path": "cstore_fdw/cstore_fdw.c", "commit_date": "2020-02-18 00:00:00", "repo_name": "citusdata/cstore_fdw", "stars": 1740, "license": "apache-2.0", "language": "c", "size": 821}
{"docstring": "/*\n * UpdateBlockSkipNodeMinMax takes the given column value, and checks if this\n * value falls outside the range of minimum/maximum values of the given column\n * block skip node. If it does, the function updates the column block skip node\n * accordingly.\n */\n", "func_signal": "static void\nUpdateBlockSkipNodeMinMax(ColumnBlockSkipNode *blockSkipNode, Datum columnValue,\n\t\t\t\t\t\t  bool columnTypeByValue, int columnTypeLength,\n\t\t\t\t\t\t  Oid columnCollation, FmgrInfo *comparisonFunction)", "code": "{\n\tbool hasMinMax = blockSkipNode->hasMinMax;\n\tDatum previousMinimum = blockSkipNode->minimumValue;\n\tDatum previousMaximum = blockSkipNode->maximumValue;\n\tDatum currentMinimum = 0;\n\tDatum currentMaximum = 0;\n\n\t/* if type doesn't have a comparison function, skip min/max values */\n\tif (comparisonFunction == NULL)\n\t{\n\t\treturn;\n\t}\n\n\tif (!hasMinMax)\n\t{\n\t\tcurrentMinimum = DatumCopy(columnValue, columnTypeByValue, columnTypeLength);\n\t\tcurrentMaximum = DatumCopy(columnValue, columnTypeByValue, columnTypeLength);\n\t}\n\telse\n\t{\n\t\tDatum minimumComparisonDatum = FunctionCall2Coll(comparisonFunction,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t columnCollation, columnValue,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t previousMinimum);\n\t\tDatum maximumComparisonDatum = FunctionCall2Coll(comparisonFunction,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t columnCollation, columnValue,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t previousMaximum);\n\t\tint minimumComparison = DatumGetInt32(minimumComparisonDatum);\n\t\tint maximumComparison = DatumGetInt32(maximumComparisonDatum);\n\n\t\tif (minimumComparison < 0)\n\t\t{\n\t\t\tcurrentMinimum = DatumCopy(columnValue, columnTypeByValue, columnTypeLength);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcurrentMinimum = previousMinimum;\n\t\t}\n\n\t\tif (maximumComparison > 0)\n\t\t{\n\t\t\tcurrentMaximum = DatumCopy(columnValue, columnTypeByValue, columnTypeLength);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcurrentMaximum = previousMaximum;\n\t\t}\n\t}\n\n\tblockSkipNode->hasMinMax = true;\n\tblockSkipNode->minimumValue = currentMinimum;\n\tblockSkipNode->maximumValue = currentMaximum;\n}", "path": "cstore_fdw/cstore_writer.c", "commit_date": "2020-02-17 00:00:00", "repo_name": "citusdata/cstore_fdw", "stars": 1740, "license": "apache-2.0", "language": "c", "size": 821}
{"docstring": "/* Flushes, syncs, and closes the given file pointer and checks for errors. */\n", "func_signal": "static void\nSyncAndCloseFile(FILE *file)", "code": "{\n\tint flushResult = 0;\n\tint syncResult = 0;\n\tint errorResult = 0;\n\tint freeResult = 0;\n\n\terrno = 0;\n\tflushResult = fflush(file);\n\tif (flushResult != 0)\n\t{\n\t\tereport(ERROR, (errcode_for_file_access(),\n\t\t\t\t\t\terrmsg(\"could not flush file: %m\")));\n\t}\n\n\tsyncResult = pg_fsync(fileno(file));\n\tif (syncResult != 0)\n\t{\n\t\tereport(ERROR, (errcode_for_file_access(),\n\t\t\t\t\t\terrmsg(\"could not sync file: %m\")));\n\t}\n\n\terrorResult = ferror(file);\n\tif (errorResult != 0)\n\t{\n\t\tereport(ERROR, (errcode_for_file_access(),\n\t\t\t\t\t\terrmsg(\"error in file: %m\")));\n\t}\n\n\tfreeResult = FreeFile(file);\n\tif (freeResult != 0)\n\t{\n\t\tereport(ERROR, (errcode_for_file_access(),\n\t\t\t\t\t\terrmsg(\"could not close file: %m\")));\n\t}\n}", "path": "cstore_fdw/cstore_writer.c", "commit_date": "2020-02-17 00:00:00", "repo_name": "citusdata/cstore_fdw", "stars": 1740, "license": "apache-2.0", "language": "c", "size": 821}
{"docstring": "/* CreateDirectory creates a new directory with the given directory name. */\n", "func_signal": "static void\nCreateDirectory(StringInfo directoryName)", "code": "{\n\tint makeOK = mkdir(directoryName->data, S_IRWXU);\n\tif (makeOK != 0)\n\t{\n\t\tereport(ERROR, (errcode_for_file_access(),\n\t\t\t\t\t\terrmsg(\"could not create directory \\\"%s\\\": %m\",\n\t\t\t\t\t\t\t   directoryName->data)));\n\t}\n}", "path": "cstore_fdw/cstore_fdw.c", "commit_date": "2020-02-18 00:00:00", "repo_name": "citusdata/cstore_fdw", "stars": 1740, "license": "apache-2.0", "language": "c", "size": 821}
{"docstring": "/*\n * CreateSkipListBufferArray serializes the skip list for each column of the\n * given stripe and returns the result as an array.\n */\n", "func_signal": "static StringInfo *\nCreateSkipListBufferArray(StripeSkipList *stripeSkipList, TupleDesc tupleDescriptor)", "code": "{\n\tStringInfo *skipListBufferArray = NULL;\n\tuint32 columnIndex = 0;\n\tuint32 columnCount = stripeSkipList->columnCount;\n\n\tskipListBufferArray = palloc0(columnCount * sizeof(StringInfo));\n\tfor (columnIndex = 0; columnIndex < columnCount; columnIndex++)\n\t{\n\t\tStringInfo skipListBuffer = NULL;\n\t\tColumnBlockSkipNode *blockSkipNodeArray =\n\t\t\tstripeSkipList->blockSkipNodeArray[columnIndex];\n\t\tForm_pg_attribute attributeForm = TupleDescAttr(tupleDescriptor, columnIndex);\n\n\t\tskipListBuffer = SerializeColumnSkipList(blockSkipNodeArray,\n\t\t\t\t\t\t\t\t\t\t\t\t stripeSkipList->blockCount,\n\t\t\t\t\t\t\t\t\t\t\t\t attributeForm->attbyval,\n\t\t\t\t\t\t\t\t\t\t\t\t attributeForm->attlen);\n\n\t\tskipListBufferArray[columnIndex] = skipListBuffer;\n\t}\n\n\treturn skipListBufferArray;\n}", "path": "cstore_fdw/cstore_writer.c", "commit_date": "2020-02-17 00:00:00", "repo_name": "citusdata/cstore_fdw", "stars": 1740, "license": "apache-2.0", "language": "c", "size": 821}
{"docstring": "/*\n * GetSlotHeapTuple abstracts getting HeapTuple from TupleTableSlot between versions\n */\n", "func_signal": "static HeapTuple\nGetSlotHeapTuple(TupleTableSlot *tts)", "code": "{\n#if PG_VERSION_NUM >= 120000\n\treturn tts->tts_ops->copy_heap_tuple(tts);\n#else\n\treturn tts->tts_tuple;\n#endif\n}", "path": "cstore_fdw/cstore_fdw.c", "commit_date": "2020-02-18 00:00:00", "repo_name": "citusdata/cstore_fdw", "stars": 1740, "license": "apache-2.0", "language": "c", "size": 821}
{"docstring": "/*\n * ValidateForeignTableOptions verifies if given options are valid cstore_fdw\n * foreign table options. This function errors out if given option value is\n * considered invalid.\n */\n", "func_signal": "static void\nValidateForeignTableOptions(char *filename, char *compressionTypeString,\n\t\t\t\t\t\t\tchar *stripeRowCountString, char *blockRowCountString)", "code": "{\n\t/* we currently do not have any checks for filename */\n\t(void) filename;\n\n\t/* check if the provided compression type is valid */\n\tif (compressionTypeString != NULL)\n\t{\n\t\tCompressionType compressionType = ParseCompressionType(compressionTypeString);\n\t\tif (compressionType == COMPRESSION_TYPE_INVALID)\n\t\t{\n\t\t\tereport(ERROR, (errmsg(\"invalid compression type\"),\n\t\t\t\t\t\t\terrhint(\"Valid options are: %s\",\n\t\t\t\t\t\t\t\t\tCOMPRESSION_STRING_DELIMITED_LIST)));\n\t\t}\n\t}\n\n\t/* check if the provided stripe row count has correct format and range */\n\tif (stripeRowCountString != NULL)\n\t{\n\t\t/* pg_atoi() errors out if the given string is not a valid 32-bit integer */\n\t\tint32 stripeRowCount = pg_atoi(stripeRowCountString, sizeof(int32), 0);\n\t\tif (stripeRowCount < STRIPE_ROW_COUNT_MINIMUM ||\n\t\t\tstripeRowCount > STRIPE_ROW_COUNT_MAXIMUM)\n\t\t{\n\t\t\tereport(ERROR, (errmsg(\"invalid stripe row count\"),\n\t\t\t\t\t\t\terrhint(\"Stripe row count must be an integer between \"\n\t\t\t\t\t\t\t\t\t\"%d and %d\", STRIPE_ROW_COUNT_MINIMUM,\n\t\t\t\t\t\t\t\t\tSTRIPE_ROW_COUNT_MAXIMUM)));\n\t\t}\n\t}\n\n\t/* check if the provided block row count has correct format and range */\n\tif (blockRowCountString != NULL)\n\t{\n\t\t/* pg_atoi() errors out if the given string is not a valid 32-bit integer */\n\t\tint32 blockRowCount = pg_atoi(blockRowCountString, sizeof(int32), 0);\n\t\tif (blockRowCount < BLOCK_ROW_COUNT_MINIMUM ||\n\t\t\tblockRowCount > BLOCK_ROW_COUNT_MAXIMUM)\n\t\t{\n\t\t\tereport(ERROR, (errmsg(\"invalid block row count\"),\n\t\t\t\t\t\t\terrhint(\"Block row count must be an integer between \"\n\t\t\t\t\t\t\t\t\t\"%d and %d\", BLOCK_ROW_COUNT_MINIMUM,\n\t\t\t\t\t\t\t\t\tBLOCK_ROW_COUNT_MAXIMUM)));\n\t\t}\n\t}\n}", "path": "cstore_fdw/cstore_fdw.c", "commit_date": "2020-02-18 00:00:00", "repo_name": "citusdata/cstore_fdw", "stars": 1740, "license": "apache-2.0", "language": "c", "size": 821}
{"docstring": "/*\n * CreateEmptyStripeBuffers allocates an empty StripeBuffers structure with the given\n * column count.\n */\n", "func_signal": "static StripeBuffers *\nCreateEmptyStripeBuffers(uint32 stripeMaxRowCount, uint32 blockRowCount,\n\t\t\t\t\t\t uint32 columnCount)", "code": "{\n\tStripeBuffers *stripeBuffers = NULL;\n\tuint32 columnIndex = 0;\n\tuint32 maxBlockCount = (stripeMaxRowCount / blockRowCount) + 1;\n\tColumnBuffers **columnBuffersArray = palloc0(columnCount * sizeof(ColumnBuffers *));\n\n\tfor (columnIndex = 0; columnIndex < columnCount; columnIndex++)\n\t{\n\t\tuint32 blockIndex = 0;\n\t\tColumnBlockBuffers **blockBuffersArray =\n\t\t\tpalloc0(maxBlockCount * sizeof(ColumnBlockBuffers *));\n\n\t\tfor (blockIndex = 0; blockIndex < maxBlockCount; blockIndex++)\n\t\t{\n\t\t\tblockBuffersArray[blockIndex] = palloc0(sizeof(ColumnBlockBuffers));\n\t\t\tblockBuffersArray[blockIndex]->existsBuffer = NULL;\n\t\t\tblockBuffersArray[blockIndex]->valueBuffer = NULL;\n\t\t\tblockBuffersArray[blockIndex]->valueCompressionType = COMPRESSION_NONE;\n\t\t}\n\n\t\tcolumnBuffersArray[columnIndex] = palloc0(sizeof(ColumnBuffers));\n\t\tcolumnBuffersArray[columnIndex]->blockBuffersArray = blockBuffersArray;\n\t}\n\n\tstripeBuffers = palloc0(sizeof(StripeBuffers));\n\tstripeBuffers->columnBuffersArray = columnBuffersArray;\n\tstripeBuffers->columnCount = columnCount;\n\tstripeBuffers->rowCount = 0;\n\n\treturn stripeBuffers;\n}", "path": "cstore_fdw/cstore_writer.c", "commit_date": "2020-02-17 00:00:00", "repo_name": "citusdata/cstore_fdw", "stars": 1740, "license": "apache-2.0", "language": "c", "size": 821}
{"docstring": "/*\n * CStoreAcquireSampleRows acquires a random sample of rows from the foreign\n * table. Selected rows are returned in the caller allocated sampleRows array,\n * which must have at least target row count entries. The actual number of rows\n * selected is returned as the function result. We also count the number of rows\n * in the collection and return it in total row count. We also always set dead\n * row count to zero.\n *\n * Note that the returned list of rows does not always follow their actual order\n * in the cstore file. Therefore, correlation estimates derived later could be\n * inaccurate, but that's OK. We currently don't use correlation estimates (the\n * planner only pays attention to correlation for index scans).\n */\n", "func_signal": "static int\nCStoreAcquireSampleRows(Relation relation, int logLevel,\n\t\t\t\t\t\tHeapTuple *sampleRows, int targetRowCount,\n\t\t\t\t\t\tdouble *totalRowCount, double *totalDeadRowCount)", "code": "{\n\tint sampleRowCount = 0;\n\tdouble rowCount = 0.0;\n\tdouble rowCountToSkip = -1;\t/* -1 means not set yet */\n\tdouble selectionState = 0;\n\tMemoryContext oldContext = CurrentMemoryContext;\n\tMemoryContext tupleContext = NULL;\n\tDatum *columnValues = NULL;\n\tbool *columnNulls = NULL;\n\tTupleTableSlot *scanTupleSlot = NULL;\n\tList *columnList = NIL;\n\tList *foreignPrivateList = NULL;\n\tForeignScanState *scanState = NULL;\n\tForeignScan *foreignScan = NULL;\n\tchar *relationName = NULL;\n\tint executorFlags = 0;\n\n\tTupleDesc tupleDescriptor = RelationGetDescr(relation);\n\tuint32 columnCount = tupleDescriptor->natts;\n\n\n\t/* create list of columns of the relation */\n\tuint32 columnIndex = 0;\n\tfor (columnIndex = 0; columnIndex < columnCount; columnIndex++)\n\t{\n\t\tForm_pg_attribute attributeForm = TupleDescAttr(tupleDescriptor, columnIndex);\n\t\tconst Index tableId = 1;\n\n\t\tif (!attributeForm->attisdropped)\n\t\t{\n\t\t\tVar *column = makeVar(tableId, columnIndex + 1, attributeForm->atttypid,\n\t\t\t\t\t\t\t\t  attributeForm->atttypmod, attributeForm->attcollation, 0);\n\t\t\tcolumnList = lappend(columnList, column);\n\t\t}\n\t}\n\n\t/* setup foreign scan plan node */\n\tforeignPrivateList = list_make1(columnList);\n\tforeignScan = makeNode(ForeignScan);\n\tforeignScan->fdw_private = foreignPrivateList;\n\n\t/* set up tuple slot */\n\tcolumnValues = palloc0(columnCount * sizeof(Datum));\n\tcolumnNulls = palloc0(columnCount * sizeof(bool));\n#if PG_VERSION_NUM >= 120000\n\tscanTupleSlot = MakeTupleTableSlot(NULL, &TTSOpsVirtual);\n#elif PG_VERSION_NUM >= 110000\n\tscanTupleSlot = MakeTupleTableSlot(NULL);\n#else\n\tscanTupleSlot = MakeTupleTableSlot();\n#endif\n\tscanTupleSlot->tts_tupleDescriptor = tupleDescriptor;\n\tscanTupleSlot->tts_values = columnValues;\n\tscanTupleSlot->tts_isnull = columnNulls;\n\n\t/* setup scan state */\n\tscanState = makeNode(ForeignScanState);\n\tscanState->ss.ss_currentRelation = relation;\n\tscanState->ss.ps.plan = (Plan *) foreignScan;\n\tscanState->ss.ss_ScanTupleSlot = scanTupleSlot;\n\n\t/*\n\t * Use per-tuple memory context to prevent leak of memory used to read and\n\t * parse rows from the file.\n\t */\n\ttupleContext = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t \"cstore_fdw temporary context\",\n\t\t\t\t\t\t\t\t\t\t ALLOCSET_DEFAULT_SIZES);\n\n\tCStoreBeginForeignScan(scanState, executorFlags);\n\n\t/* prepare for sampling rows */\n\tselectionState = anl_init_selection_state(targetRowCount);\n\n\tfor (;;)\n\t{\n\t\t/* check for user-requested abort or sleep */\n\t\tvacuum_delay_point();\n\n\t\tmemset(columnValues, 0, columnCount * sizeof(Datum));\n\t\tmemset(columnNulls, true, columnCount * sizeof(bool));\n\n\t\tMemoryContextReset(tupleContext);\n\t\tMemoryContextSwitchTo(tupleContext);\n\n\t\t/* read the next record */\n\t\tCStoreIterateForeignScan(scanState);\n\n\t\tMemoryContextSwitchTo(oldContext);\n\n\t\t/* if there are no more records to read, break */\n\t\tif (TTS_EMPTY(scanTupleSlot))\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * The first targetRowCount sample rows are simply copied into the\n\t\t * reservoir. Then we start replacing tuples in the sample until we\n\t\t * reach the end of the relation. This algorithm is from Jeff Vitter's\n\t\t * paper (see more info in commands/analyze.c).\n\t\t */\n\t\tif (sampleRowCount < targetRowCount)\n\t\t{\n\t\t\tsampleRows[sampleRowCount] = heap_form_tuple(tupleDescriptor, columnValues,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t columnNulls);\n\t\t\tsampleRowCount++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * t in Vitter's paper is the number of records already processed.\n\t\t\t * If we need to compute a new S value, we must use the \"not yet\n\t\t\t * incremented\" value of rowCount as t.\n\t\t\t */\n\t\t\tif (rowCountToSkip < 0)\n\t\t\t{\n\t\t\t\trowCountToSkip = anl_get_next_S(rowCount, targetRowCount,\n\t\t\t\t\t\t\t\t\t\t\t\t&selectionState);\n\t\t\t}\n\n\t\t\tif (rowCountToSkip <= 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Found a suitable tuple, so save it, replacing one old tuple\n\t\t\t\t * at random.\n\t\t\t\t */\n\t\t\t\tint rowIndex = (int) (targetRowCount * anl_random_fract());\n\t\t\t\tAssert(rowIndex >= 0);\n\t\t\t\tAssert(rowIndex < targetRowCount);\n\n\t\t\t\theap_freetuple(sampleRows[rowIndex]);\n\t\t\t\tsampleRows[rowIndex] = heap_form_tuple(tupleDescriptor,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   columnValues, columnNulls);\n\t\t\t}\n\n\t\t\trowCountToSkip--;\n\t\t}\n\n\t\trowCount++;\n\t}\n\n\t/* clean up */\n\tMemoryContextDelete(tupleContext);\n\tpfree(columnValues);\n\tpfree(columnNulls);\n\n\tCStoreEndForeignScan(scanState);\n\n\t/* emit some interesting relation info */\n\trelationName = RelationGetRelationName(relation);\n\tereport(logLevel, (errmsg(\"\\\"%s\\\": file contains %.0f rows; %d rows in sample\",\n\t\t\t\t\t\t\t  relationName, rowCount, sampleRowCount)));\n\n\t(*totalRowCount) = rowCount;\n\t(*totalDeadRowCount) = 0;\n\n\treturn sampleRowCount;\n}", "path": "cstore_fdw/cstore_fdw.c", "commit_date": "2020-02-18 00:00:00", "repo_name": "citusdata/cstore_fdw", "stars": 1740, "license": "apache-2.0", "language": "c", "size": 821}
{"docstring": "/* CStoreEndForeignScan finishes scanning the foreign table. */\n", "func_signal": "static void\nCStoreEndForeignScan(ForeignScanState *scanState)", "code": "{\n\tTableReadState *readState = (TableReadState *) scanState->fdw_state;\n\tif (readState != NULL)\n\t{\n\t\tCStoreEndRead(readState);\n\t}\n}", "path": "cstore_fdw/cstore_fdw.c", "commit_date": "2020-02-18 00:00:00", "repo_name": "citusdata/cstore_fdw", "stars": 1740, "license": "apache-2.0", "language": "c", "size": 821}
{"docstring": "/*\n * SerializeBoolArray serializes the given boolean array and returns the result\n * as a StringInfo. This function packs every 8 boolean values into one byte.\n */\n", "func_signal": "static StringInfo\nSerializeBoolArray(bool *boolArray, uint32 boolArrayLength)", "code": "{\n\tStringInfo boolArrayBuffer = NULL;\n\tuint32 boolArrayIndex = 0;\n\tuint32 byteCount = (boolArrayLength + 7) / 8;\n\n\tboolArrayBuffer = makeStringInfo();\n\tenlargeStringInfo(boolArrayBuffer, byteCount);\n\tboolArrayBuffer->len = byteCount;\n\tmemset(boolArrayBuffer->data, 0, byteCount);\n\n\tfor (boolArrayIndex = 0; boolArrayIndex < boolArrayLength; boolArrayIndex++)\n\t{\n\t\tif (boolArray[boolArrayIndex])\n\t\t{\n\t\t\tuint32 byteIndex = boolArrayIndex / 8;\n\t\t\tuint32 bitIndex = boolArrayIndex % 8;\n\t\t\tboolArrayBuffer->data[byteIndex] |= (1 << bitIndex);\n\t\t}\n\t}\n\n\treturn boolArrayBuffer;\n}", "path": "cstore_fdw/cstore_writer.c", "commit_date": "2020-02-17 00:00:00", "repo_name": "citusdata/cstore_fdw", "stars": 1740, "license": "apache-2.0", "language": "c", "size": 821}
{"docstring": "/* FindCStoreTables returns list of CStore tables from given table list */\n", "func_signal": "static List *\nFindCStoreTables(List *tableList)", "code": "{\n\tList *cstoreTableList = NIL;\n\tListCell *relationCell = NULL;\n\tforeach(relationCell, tableList)\n\t{\n\t\tRangeVar *rangeVar = (RangeVar *) lfirst(relationCell);\n\t\tOid relationId = RangeVarGetRelid(rangeVar, AccessShareLock, true);\n\t\tif (CStoreTable(relationId) && !DistributedTable(relationId))\n\t\t{\n\t\t\tcstoreTableList = lappend(cstoreTableList, rangeVar);\n\t\t}\n\t}\n\n\treturn cstoreTableList;\n}", "path": "cstore_fdw/cstore_fdw.c", "commit_date": "2020-02-18 00:00:00", "repo_name": "citusdata/cstore_fdw", "stars": 1740, "license": "apache-2.0", "language": "c", "size": 821}
{"docstring": "/* Writes the given data to the given file pointer and checks for errors. */\n", "func_signal": "static void\nWriteToFile(FILE *file, void *data, uint32 dataLength)", "code": "{\n\tint writeResult = 0;\n\tint errorResult = 0;\n\n\tif (dataLength == 0)\n\t{\n\t\treturn;\n\t}\n\n\terrno = 0;\n\twriteResult = fwrite(data, dataLength, 1, file);\n\tif (writeResult != 1)\n\t{\n\t\tereport(ERROR, (errcode_for_file_access(),\n\t\t\t\t\t\terrmsg(\"could not write file: %m\")));\n\t}\n\n\terrorResult = ferror(file);\n\tif (errorResult != 0)\n\t{\n\t\tereport(ERROR, (errcode_for_file_access(),\n\t\t\t\t\t\terrmsg(\"error in file: %m\")));\n\t}\n}", "path": "cstore_fdw/cstore_writer.c", "commit_date": "2020-02-17 00:00:00", "repo_name": "citusdata/cstore_fdw", "stars": 1740, "license": "apache-2.0", "language": "c", "size": 821}
{"docstring": "/*\n * CopyFromCStoreTable handles a \"COPY cstore_table TO ...\" statement. Statement\n * is converted to \"COPY (SELECT * FROM cstore_table) TO ...\" and forwarded to\n * postgres native COPY handler. Function returns number of files copied to external\n * stream. Copying selected columns from cstore table is not currently supported.\n */\n", "func_signal": "static uint64\nCopyOutCStoreTable(CopyStmt* copyStatement, const char* queryString)", "code": "{\n\tuint64 processedCount = 0;\n\tRangeVar *relation = NULL;\n\tchar *qualifiedName = NULL;\n\tList *queryList = NIL;\n\tNode *rawQuery = NULL;\n\n\tStringInfo newQuerySubstring = makeStringInfo();\n\n\tif (copyStatement->attlist != NIL)\n\t{\n\t\tereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\terrmsg(\"copy column list is not supported\"),\n\t\t\t\t\t\terrhint(\"use 'copy (select <columns> from <table>) to \"\n\t\t\t\t\t\t\t\t\"...' instead\")));\n\t}\n\n\trelation = copyStatement->relation;\n\tqualifiedName = quote_qualified_identifier(relation->schemaname,\n\t\t\t\t\t\t\t\t\t\t\t   relation->relname);\n\tappendStringInfo(newQuerySubstring, \"select * from %s\", qualifiedName);\n\tqueryList = raw_parser(newQuerySubstring->data);\n\n\t/* take the first parse tree */\n\trawQuery = linitial(queryList);\n\n\t/*\n\t * Set the relation field to NULL so that COPY command works on\n\t * query field instead.\n\t */\n\tcopyStatement->relation = NULL;\n\n#if (PG_VERSION_NUM >= 100000)\n\t/*\n\t * raw_parser returns list of RawStmt* in PG 10+ we need to\n\t * extract actual query from it.\n\t */\n\t{\n\t\tParseState *pstate = make_parsestate(NULL);\n\t\tRawStmt *rawStatement = (RawStmt *) rawQuery;\n\n\t\tpstate->p_sourcetext = newQuerySubstring->data;\n\t\tcopyStatement->query = rawStatement->stmt;\n\n\t\tDoCopy(pstate, copyStatement, -1, -1, &processedCount);\n\t\tfree_parsestate(pstate);\n\t}\n#else\n\tcopyStatement->query = rawQuery;\n\n\tDoCopy(copyStatement, queryString, &processedCount);\n#endif\n\n\treturn processedCount;\n}", "path": "cstore_fdw/cstore_fdw.c", "commit_date": "2020-02-18 00:00:00", "repo_name": "citusdata/cstore_fdw", "stars": 1740, "license": "apache-2.0", "language": "c", "size": 821}
{"docstring": "/*\n * cstore_ddl_event_end_trigger is the event trigger function which is called on\n * ddl_command_end event. This function creates required directories after the\n * CREATE SERVER statement and valid data and footer files after the CREATE FOREIGN\n * TABLE statement.\n */\n", "func_signal": "Datum\ncstore_ddl_event_end_trigger(PG_FUNCTION_ARGS)", "code": "{\n\tEventTriggerData *triggerData = NULL;\n\tNode *parseTree = NULL;\n\n\t/* error if event trigger manager did not call this function */\n\tif (!CALLED_AS_EVENT_TRIGGER(fcinfo))\n\t{\n\t\tereport(ERROR, (errmsg(\"trigger not fired by event trigger manager\")));\n\t}\n\n\ttriggerData = (EventTriggerData *) fcinfo->context;\n\tparseTree = triggerData->parsetree;\n\n\tif (nodeTag(parseTree) == T_CreateForeignServerStmt)\n\t{\n\t\tCreateForeignServerStmt *serverStatement = (CreateForeignServerStmt *) parseTree;\n\n\t\tchar *foreignWrapperName = serverStatement->fdwname;\n\t\tif (strncmp(foreignWrapperName, CSTORE_FDW_NAME, NAMEDATALEN) == 0)\n\t\t{\n\t\t\tCreateCStoreDatabaseDirectory(MyDatabaseId);\n\t\t}\n\t}\n\telse if (nodeTag(parseTree) == T_CreateForeignTableStmt)\n\t{\n\t\tCreateForeignTableStmt *createStatement = (CreateForeignTableStmt *) parseTree;\n\t\tchar *serverName = createStatement->servername;\n\n\t\tbool missingOK = false;\n\t\tForeignServer *server = GetForeignServerByName(serverName, missingOK);\n\t\tif (CStoreServer(server))\n\t\t{\n\t\t\tOid relationId = RangeVarGetRelid(createStatement->base.relation,\n\t\t\t\t\t\t\t\t\t\t\t  AccessShareLock, false);\n\t\t\tRelation relation = heap_open(relationId, AccessExclusiveLock);\n\n\t\t\t/*\n\t\t\t * Make sure database directory exists before creating a table.\n\t\t\t * This is necessary when a foreign server is created inside\n\t\t\t * a template database and a new database is created out of it.\n\t\t\t * We have no chance to hook into server creation to create data\n\t\t\t * directory for it during database creation time.\n\t\t\t */\n\t\t\tCreateCStoreDatabaseDirectory(MyDatabaseId);\n\n\t\t\tInitializeCStoreTableFile(relationId, relation);\n\t\t\theap_close(relation, AccessExclusiveLock);\n\t\t}\n\t}\n\n\tPG_RETURN_NULL();\n}", "path": "cstore_fdw/cstore_fdw.c", "commit_date": "2020-02-18 00:00:00", "repo_name": "citusdata/cstore_fdw", "stars": 1740, "license": "apache-2.0", "language": "c", "size": 821}
{"docstring": "/*\n * CStoreAnalyzeForeignTable sets the total page count and the function pointer\n * used to acquire a random sample of rows from the foreign file.\n */\n", "func_signal": "static bool\nCStoreAnalyzeForeignTable(Relation relation,\n\t\t\t\t\t\t  AcquireSampleRowsFunc *acquireSampleRowsFunc,\n\t\t\t\t\t\t  BlockNumber *totalPageCount)", "code": "{\n\tOid foreignTableId = RelationGetRelid(relation);\n\tCStoreFdwOptions *cstoreFdwOptions = CStoreGetOptions(foreignTableId);\n\tstruct stat statBuffer;\n\n\tint statResult = stat(cstoreFdwOptions->filename, &statBuffer);\n\tif (statResult < 0)\n\t{\n\t\tereport(ERROR, (errcode_for_file_access(),\n\t\t\t\t\t\terrmsg(\"could not stat file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\t   cstoreFdwOptions->filename)));\n\t}\n\n\t(*totalPageCount) = PageCount(cstoreFdwOptions->filename);\n\t(*acquireSampleRowsFunc) = CStoreAcquireSampleRows;\n\n\treturn true;\n}", "path": "cstore_fdw/cstore_fdw.c", "commit_date": "2020-02-18 00:00:00", "repo_name": "citusdata/cstore_fdw", "stars": 1740, "license": "apache-2.0", "language": "c", "size": 821}
{"docstring": "/*\n * CheckSuperuserPrivilegesForCopy checks if superuser privilege is required by\n * copy operation and reports error if user does not have superuser rights.\n */\n", "func_signal": "static void\nCheckSuperuserPrivilegesForCopy(const CopyStmt* copyStatement)", "code": "{\n\t/*\n\t * We disallow copy from file or program except to superusers. These checks\n\t * are based on the checks in DoCopy() function of copy.c.\n\t */\n\tif (copyStatement->filename != NULL && !superuser())\n\t{\n\t\tif (copyStatement->is_program)\n\t\t{\n\t\t\tereport(ERROR, (errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t errmsg(\"must be superuser to COPY to or from a program\"),\n\t\t\t\t\t errhint(\"Anyone can COPY to stdout or from stdin. \"\n\t\t\t\t\t\t\t \"psql's \\\\copy command also works for anyone.\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tereport(ERROR, (errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t\t errmsg(\"must be superuser to COPY to or from a file\"),\n\t\t\t\t\t errhint(\"Anyone can COPY to stdout or from stdin. \"\n\t\t\t\t\t\t\t \"psql's \\\\copy command also works for anyone.\")));\n\t\t}\n\t}\n}", "path": "cstore_fdw/cstore_fdw.c", "commit_date": "2020-02-18 00:00:00", "repo_name": "citusdata/cstore_fdw", "stars": 1740, "license": "apache-2.0", "language": "c", "size": 821}
{"docstring": "/*\n * CStoreEndWrite finishes a cstore data load operation. If we have an unflushed\n * stripe, we flush it. Then, we sync and close the cstore data file. Last, we\n * flush the footer to a temporary file, and atomically rename this temporary\n * file to the original footer file.\n */\n", "func_signal": "void\nCStoreEndWrite(TableWriteState *writeState)", "code": "{\n\tStringInfo tableFooterFilename = NULL;\n\tStringInfo tempTableFooterFileName = NULL;\n\tint renameResult = 0;\n\tint columnCount = writeState->tupleDescriptor->natts;\n\tStripeBuffers *stripeBuffers = writeState->stripeBuffers;\n\n\tif (stripeBuffers != NULL)\n\t{\n\t\tMemoryContext oldContext = MemoryContextSwitchTo(writeState->stripeWriteContext);\n\n\t\tStripeMetadata stripeMetadata = FlushStripe(writeState);\n\t\tMemoryContextReset(writeState->stripeWriteContext);\n\n\t\tMemoryContextSwitchTo(oldContext);\n\t\tAppendStripeMetadata(writeState->tableFooter, stripeMetadata);\n\t}\n\n\tSyncAndCloseFile(writeState->tableFile);\n\n\ttableFooterFilename = writeState->tableFooterFilename;\n\ttempTableFooterFileName = makeStringInfo();\n\tappendStringInfo(tempTableFooterFileName, \"%s%s\", tableFooterFilename->data,\n\t\t\t\t\t CSTORE_TEMP_FILE_SUFFIX);\n\n\tCStoreWriteFooter(tempTableFooterFileName, writeState->tableFooter);\n\n\trenameResult = rename(tempTableFooterFileName->data, tableFooterFilename->data);\n\tif (renameResult != 0)\n\t{\n\t\tereport(ERROR, (errcode_for_file_access(),\n\t\t\t\t\t\terrmsg(\"could not rename file \\\"%s\\\" to \\\"%s\\\": %m\",\n\t\t\t\t\t\t\t   tempTableFooterFileName->data,\n\t\t\t\t\t\t\t   tableFooterFilename->data)));\n\t}\n\n\tpfree(tempTableFooterFileName->data);\n\tpfree(tempTableFooterFileName);\n\n\tMemoryContextDelete(writeState->stripeWriteContext);\n\tlist_free_deep(writeState->tableFooter->stripeMetadataList);\n\tpfree(writeState->tableFooter);\n\tpfree(writeState->tableFooterFilename->data);\n\tpfree(writeState->tableFooterFilename);\n\tpfree(writeState->comparisonFunctionArray);\n\tFreeColumnBlockDataArray(writeState->blockDataArray, columnCount);\n\tpfree(writeState);\n}", "path": "cstore_fdw/cstore_writer.c", "commit_date": "2020-02-17 00:00:00", "repo_name": "citusdata/cstore_fdw", "stars": 1740, "license": "apache-2.0", "language": "c", "size": 821}
{"docstring": "/*\n * CStoreBeginWrite initializes a cstore data load operation and returns a table\n * handle. This handle should be used for adding the row values and finishing the\n * data load operation. If the cstore footer file already exists, we read the\n * footer and then seek to right after the last stripe  where the new stripes\n * will be added.\n */\n", "func_signal": "TableWriteState *\nCStoreBeginWrite(const char *filename, CompressionType compressionType,\n\t\t\t\t uint64 stripeMaxRowCount, uint32 blockRowCount,\n\t\t\t\t TupleDesc tupleDescriptor)", "code": "{\n\tTableWriteState *writeState = NULL;\n\tFILE *tableFile = NULL;\n\tStringInfo tableFooterFilename = NULL;\n\tTableFooter *tableFooter = NULL;\n\tFmgrInfo **comparisonFunctionArray = NULL;\n\tMemoryContext stripeWriteContext = NULL;\n\tuint64 currentFileOffset = 0;\n\tuint32 columnCount = 0;\n\tuint32 columnIndex = 0;\n\tstruct stat statBuffer;\n\tint statResult = 0;\n\tbool *columnMaskArray = NULL;\n\tColumnBlockData **blockData = NULL;\n\n\ttableFooterFilename = makeStringInfo();\n\tappendStringInfo(tableFooterFilename, \"%s%s\", filename, CSTORE_FOOTER_FILE_SUFFIX);\n\n\tstatResult = stat(tableFooterFilename->data, &statBuffer);\n\tif (statResult < 0)\n\t{\n\t\ttableFile = AllocateFile(filename, \"w\");\n\t\tif (tableFile == NULL)\n\t\t{\n\t\t\tereport(ERROR, (errcode_for_file_access(),\n\t\t\t\t\t\t\terrmsg(\"could not open file \\\"%s\\\" for writing: %m\",\n\t\t\t\t\t\t\t\t   filename)));\n\t\t}\n\n\t\ttableFooter = palloc0(sizeof(TableFooter));\n\t\ttableFooter->blockRowCount = blockRowCount;\n\t\ttableFooter->stripeMetadataList = NIL;\n\t}\n\telse\n\t{\n\t\ttableFile = AllocateFile(filename, \"r+\");\n\t\tif (tableFile == NULL)\n\t\t{\n\t\t\tereport(ERROR, (errcode_for_file_access(),\n\t\t\t\t\t\t\terrmsg(\"could not open file \\\"%s\\\" for writing: %m\",\n\t\t\t\t\t\t\t\t   filename)));\n\t\t}\n\n\t\ttableFooter = CStoreReadFooter(tableFooterFilename);\n\t}\n\n\t/*\n\t * If stripeMetadataList is not empty, jump to the position right after\n\t * the last position.\n\t */\n\tif (tableFooter->stripeMetadataList != NIL)\n\t{\n\t\tStripeMetadata *lastStripe = NULL;\n\t\tuint64 lastStripeSize = 0;\n\t\tint fseekResult = 0;\n\n\t\tlastStripe = llast(tableFooter->stripeMetadataList);\n\t\tlastStripeSize += lastStripe->skipListLength;\n\t\tlastStripeSize += lastStripe->dataLength;\n\t\tlastStripeSize += lastStripe->footerLength;\n\n\t\tcurrentFileOffset = lastStripe->fileOffset + lastStripeSize;\n\n\t\terrno = 0;\n\t\tfseekResult = fseeko(tableFile, currentFileOffset, SEEK_SET);\n\t\tif (fseekResult != 0)\n\t\t{\n\t\t\tereport(ERROR, (errcode_for_file_access(),\n\t\t\t\t\t\t\terrmsg(\"could not seek in file \\\"%s\\\": %m\", filename)));\n\t\t}\n\t}\n\n\t/* get comparison function pointers for each of the columns */\n\tcolumnCount = tupleDescriptor->natts;\n\tcomparisonFunctionArray = palloc0(columnCount * sizeof(FmgrInfo *));\n\tfor (columnIndex = 0; columnIndex < columnCount; columnIndex++)\n\t{\n\t\tFmgrInfo *comparisonFunction = NULL;\n\t\tFormData_pg_attribute *attributeForm = TupleDescAttr(tupleDescriptor, columnIndex);\n\n\t\tif (!attributeForm->attisdropped)\n\t\t{\n\t\t\tOid typeId = attributeForm->atttypid;\n\n\t\t\tcomparisonFunction = GetFunctionInfoOrNull(typeId, BTREE_AM_OID, BTORDER_PROC);\n\t\t}\n\n\t\tcomparisonFunctionArray[columnIndex] = comparisonFunction;\n\t}\n\n\t/*\n\t * We allocate all stripe specific data in the stripeWriteContext, and\n\t * reset this memory context once we have flushed the stripe to the file.\n\t * This is to avoid memory leaks.\n\t */\n\tstripeWriteContext = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t   \"Stripe Write Memory Context\",\n\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\n\tcolumnMaskArray = palloc(columnCount * sizeof(bool));\n\tmemset(columnMaskArray, true, columnCount);\n\n\tblockData = CreateEmptyBlockDataArray(columnCount, columnMaskArray, blockRowCount);\n\n\twriteState = palloc0(sizeof(TableWriteState));\n\twriteState->tableFile = tableFile;\n\twriteState->tableFooterFilename = tableFooterFilename;\n\twriteState->tableFooter = tableFooter;\n\twriteState->compressionType = compressionType;\n\twriteState->stripeMaxRowCount = stripeMaxRowCount;\n\twriteState->tupleDescriptor = tupleDescriptor;\n\twriteState->currentFileOffset = currentFileOffset;\n\twriteState->comparisonFunctionArray = comparisonFunctionArray;\n\twriteState->stripeBuffers = NULL;\n\twriteState->stripeSkipList = NULL;\n\twriteState->stripeWriteContext = stripeWriteContext;\n\twriteState->blockDataArray = blockData;\n\twriteState->compressionBuffer = NULL;\n\n\treturn writeState;\n}", "path": "cstore_fdw/cstore_writer.c", "commit_date": "2020-02-17 00:00:00", "repo_name": "citusdata/cstore_fdw", "stars": 1740, "license": "apache-2.0", "language": "c", "size": 821}
{"docstring": "/*\n * Returns false if there are no snapshots with dependent clones in this\n * subtree or if all of those clones are also in this subtree.  Returns\n * true if there is an error or there are external dependents.\n */\n", "func_signal": "static boolean_t\nexternal_dependents(libzfs_handle_t *hdl, zfs_graph_t *zgp, const char *dataset)", "code": "{\n\tzfs_cmd_t zc = {\"\\0\"};\n\n\t/*\n\t * Check whether this dataset is a clone or has clones since\n\t * iterate_children() only checks the children.\n\t */\n\t(void) strlcpy(zc.zc_name, dataset, sizeof (zc.zc_name));\n\tif (zfs_ioctl(hdl, ZFS_IOC_OBJSET_STATS, &zc) != 0)\n\t\treturn (B_TRUE);\n\n\tif (zc.zc_objset_stats.dds_origin[0] != '\\0') {\n\t\tif (zfs_graph_add(hdl, zgp,\n\t\t    zc.zc_objset_stats.dds_origin, zc.zc_name,\n\t\t    zc.zc_objset_stats.dds_creation_txg) != 0)\n\t\t\treturn (B_TRUE);\n\t\tif (isa_child_of(zc.zc_objset_stats.dds_origin, dataset))\n\t\t\tzgp->zg_clone_count--;\n\t}\n\n\tif ((zc.zc_objset_stats.dds_num_clones) ||\n\t    iterate_children(hdl, zgp, dataset))\n\t\treturn (B_TRUE);\n\n\treturn (zgp->zg_clone_count != 0);\n}", "path": "ZFSin/ZFSin/zfs/lib/libzfs/libzfs_graph.c", "commit_date": "2017-03-23 00:00:00", "repo_name": "openzfsonwindows/ZFSin", "stars": 1185, "license": "None", "language": "c", "size": 12371}
{"docstring": "/*\n * Given a vertex, add an edge to the destination vertex.\n */\n", "func_signal": "static int\nzfs_vertex_add_edge(libzfs_handle_t *hdl, zfs_vertex_t *zvp,\n    zfs_vertex_t *dest)", "code": "{\n\tzfs_edge_t *zep = zfs_edge_create(hdl, dest);\n\n\tif (zep == NULL)\n\t\treturn (-1);\n\n\tif (zvp->zv_edgecount == zvp->zv_edgealloc) {\n\t\tvoid *ptr;\n\n\t\tif ((ptr = zfs_realloc(hdl, zvp->zv_edges,\n\t\t    zvp->zv_edgealloc * sizeof (void *),\n\t\t    zvp->zv_edgealloc * 2 * sizeof (void *))) == NULL)\n\t\t\treturn (-1);\n\n\t\tzvp->zv_edges = ptr;\n\t\tzvp->zv_edgealloc *= 2;\n\t}\n\n\tzvp->zv_edges[zvp->zv_edgecount++] = zep;\n\n\treturn (0);\n}", "path": "ZFSin/ZFSin/zfs/lib/libzfs/libzfs_graph.c", "commit_date": "2017-03-23 00:00:00", "repo_name": "openzfsonwindows/ZFSin", "stars": 1185, "license": "None", "language": "c", "size": 12371}
{"docstring": "/*\n * NB: dataset must not be changing on-disk (eg, is a snapshot or we are\n * in syncing context).\n */\n", "func_signal": "static int\ntraverse_impl(spa_t *spa, dsl_dataset_t *ds, uint64_t objset, blkptr_t *rootbp,\n    uint64_t txg_start, zbookmark_phys_t *resume, int flags,\n    blkptr_cb_t func, void *arg)", "code": "{\n\ttraverse_data_t *td;\n\tprefetch_data_t *pd;\n\tzbookmark_phys_t *czb;\n\tint err;\n\n\tASSERT(ds == NULL || objset == ds->ds_object);\n\tASSERT(!(flags & TRAVERSE_PRE) || !(flags & TRAVERSE_POST));\n\n\ttd = kmem_alloc(sizeof (traverse_data_t), KM_SLEEP);\n\tpd = kmem_zalloc(sizeof (prefetch_data_t), KM_SLEEP);\n\tczb = kmem_alloc(sizeof (zbookmark_phys_t), KM_SLEEP);\n\n\ttd->td_spa = spa;\n\ttd->td_objset = objset;\n\ttd->td_rootbp = rootbp;\n\ttd->td_min_txg = txg_start;\n\ttd->td_resume = resume;\n\ttd->td_func = func;\n\ttd->td_arg = arg;\n\ttd->td_pfd = pd;\n\ttd->td_flags = flags;\n\ttd->td_paused = B_FALSE;\n\ttd->td_realloc_possible = (txg_start == 0 ? B_FALSE : B_TRUE);\n\n\tif (spa_feature_is_active(spa, SPA_FEATURE_HOLE_BIRTH)) {\n\t\tVERIFY(spa_feature_enabled_txg(spa,\n\t\t    SPA_FEATURE_HOLE_BIRTH, &td->td_hole_birth_enabled_txg));\n\t} else {\n\t\ttd->td_hole_birth_enabled_txg = UINT64_MAX;\n\t}\n\n\tpd->pd_flags = flags;\n\tif (resume != NULL)\n\t\tpd->pd_resume = *resume;\n\tmutex_init(&pd->pd_mtx, NULL, MUTEX_DEFAULT, NULL);\n\tcv_init(&pd->pd_cv, NULL, CV_DEFAULT, NULL);\n\n\tSET_BOOKMARK(czb, td->td_objset,\n\t    ZB_ROOT_OBJECT, ZB_ROOT_LEVEL, ZB_ROOT_BLKID);\n\n\t/* See comment on ZIL traversal in dsl_scan_visitds. */\n\tif (ds != NULL && !ds->ds_is_snapshot && !BP_IS_HOLE(rootbp)) {\n\t\tenum zio_flag zio_flags = ZIO_FLAG_CANFAIL;\n\t\tarc_flags_t flags = ARC_FLAG_WAIT;\n\t\tobjset_phys_t *osp;\n\t\tarc_buf_t *buf;\n\n\t\tif ((td->td_flags & TRAVERSE_NO_DECRYPT) &&\n\t\t    BP_IS_PROTECTED(rootbp))\n\t\t\tzio_flags |= ZIO_FLAG_RAW;\n\n\t\terr = arc_read(NULL, td->td_spa, rootbp, arc_getbuf_func,\n\t\t    &buf, ZIO_PRIORITY_ASYNC_READ, zio_flags, &flags, czb);\n\t\tif (err != 0)\n\t\t\treturn (err);\n\n\t\tosp = buf->b_data;\n\t\ttraverse_zil(td, &osp->os_zil_header);\n\t\tarc_buf_destroy(buf, &buf);\n\t}\n\n\tif (!(flags & TRAVERSE_PREFETCH_DATA) ||\n\t    0 == taskq_dispatch(system_taskq, traverse_prefetch_thread,\n\t    td, TQ_NOQUEUE))\n\t\tpd->pd_exited = B_TRUE;\n\n\terr = traverse_visitbp(td, NULL, rootbp, czb);\n\n\tmutex_enter(&pd->pd_mtx);\n\tpd->pd_cancel = B_TRUE;\n\tcv_broadcast(&pd->pd_cv);\n\twhile (!pd->pd_exited)\n\t\tcv_wait_sig(&pd->pd_cv, &pd->pd_mtx);\n\tmutex_exit(&pd->pd_mtx);\n\n\tmutex_destroy(&pd->pd_mtx);\n\tcv_destroy(&pd->pd_cv);\n\n\tkmem_free(czb, sizeof (zbookmark_phys_t));\n\tkmem_free(pd, sizeof (struct prefetch_data));\n\tkmem_free(td, sizeof (struct traverse_data));\n\n\treturn (err);\n}", "path": "ZFSin/ZFSin/zfs/module/zfs/dmu_traverse.c", "commit_date": "2019-10-11 00:00:00", "repo_name": "openzfsonwindows/ZFSin", "stars": 1185, "license": "None", "language": "c", "size": 12371}
{"docstring": "/*\n * Construct a complete graph of all necessary vertices.  First, iterate over\n * only our object's children.  If no cloned snapshots are found, or all of\n * the cloned snapshots are in this subtree then return a graph of the subtree.\n * Otherwise, start at the root of the pool and iterate over all datasets.\n */\n", "func_signal": "static zfs_graph_t *\nconstruct_graph(libzfs_handle_t *hdl, const char *dataset)", "code": "{\n\tzfs_graph_t *zgp = zfs_graph_create(hdl, dataset, ZFS_GRAPH_SIZE);\n\tint ret = 0;\n\n\tif (zgp == NULL)\n\t\treturn (zgp);\n\n\tif ((strchr(dataset, '/') == NULL) ||\n\t    (external_dependents(hdl, zgp, dataset))) {\n\t\t/*\n\t\t * Determine pool name and try again.\n\t\t */\n\t\tint len = strcspn(dataset, \"/@\") + 1;\n\t\tchar *pool = zfs_alloc(hdl, len);\n\n\t\tif (pool == NULL) {\n\t\t\tzfs_graph_destroy(zgp);\n\t\t\treturn (NULL);\n\t\t}\n\t\t(void) strlcpy(pool, dataset, len);\n\n\t\tif (iterate_children(hdl, zgp, pool) == -1 ||\n\t\t    zfs_graph_add(hdl, zgp, pool, NULL, 0) != 0) {\n\t\t\tfree(pool);\n\t\t\tzfs_graph_destroy(zgp);\n\t\t\treturn (NULL);\n\t\t}\n\t\tfree(pool);\n\t}\n\n\tif (ret == -1 || zfs_graph_add(hdl, zgp, dataset, NULL, 0) != 0) {\n\t\tzfs_graph_destroy(zgp);\n\t\treturn (NULL);\n\t}\n\n\treturn (zgp);\n}", "path": "ZFSin/ZFSin/zfs/lib/libzfs/libzfs_graph.c", "commit_date": "2017-03-23 00:00:00", "repo_name": "openzfsonwindows/ZFSin", "stars": 1185, "license": "None", "language": "c", "size": 12371}
{"docstring": "/*\n * NB: pool must not be changing on-disk (eg, from zdb or sync context).\n */\n", "func_signal": "int\ntraverse_pool(spa_t *spa, uint64_t txg_start, int flags,\n    blkptr_cb_t func, void *arg)", "code": "{\n\tint err;\n\tdsl_pool_t *dp = spa_get_dsl(spa);\n\tobjset_t *mos = dp->dp_meta_objset;\n\tboolean_t hard = (flags & TRAVERSE_HARD);\n\n\t/* visit the MOS */\n\terr = traverse_impl(spa, NULL, 0, spa_get_rootblkptr(spa),\n\t    txg_start, NULL, flags, func, arg);\n\tif (err != 0)\n\t\treturn (err);\n\n\t/* visit each dataset */\n\tfor (uint64_t obj = 1; err == 0;\n\t    err = dmu_object_next(mos, &obj, B_FALSE, txg_start)) {\n\t\tdmu_object_info_t doi;\n\n\t\terr = dmu_object_info(mos, obj, &doi);\n\t\tif (err != 0) {\n\t\t\tif (hard)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (doi.doi_bonus_type == DMU_OT_DSL_DATASET) {\n\t\t\tdsl_dataset_t *ds;\n\t\t\tuint64_t txg = txg_start;\n\n\t\t\tdsl_pool_config_enter(dp, FTAG);\n\t\t\terr = dsl_dataset_hold_obj(dp, obj, FTAG, &ds);\n\t\t\tdsl_pool_config_exit(dp, FTAG);\n\t\t\tif (err != 0) {\n\t\t\t\tif (hard)\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (dsl_dataset_phys(ds)->ds_prev_snap_txg > txg)\n\t\t\t\ttxg = dsl_dataset_phys(ds)->ds_prev_snap_txg;\n\t\t\terr = traverse_dataset(ds, txg, flags, func, arg);\n\t\t\tdsl_dataset_rele(ds, FTAG);\n\t\t\tif (err != 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (err == ESRCH)\n\t\terr = 0;\n\treturn (err);\n}", "path": "ZFSin/ZFSin/zfs/module/zfs/dmu_traverse.c", "commit_date": "2019-10-11 00:00:00", "repo_name": "openzfsonwindows/ZFSin", "stars": 1185, "license": "None", "language": "c", "size": 12371}
{"docstring": "/*\n * Construct a new graph object.  We allow the size to be specified as a\n * parameter so in the future we can size the hash according to the number of\n * datasets in the pool.\n */\n", "func_signal": "static zfs_graph_t *\nzfs_graph_create(libzfs_handle_t *hdl, const char *dataset, size_t size)", "code": "{\n\tzfs_graph_t *zgp = zfs_alloc(hdl, sizeof (zfs_graph_t));\n\n\tif (zgp == NULL)\n\t\treturn (NULL);\n\n\tzgp->zg_size = size;\n\tif ((zgp->zg_hash = zfs_alloc(hdl,\n\t    size * sizeof (zfs_vertex_t *))) == NULL) {\n\t\tfree(zgp);\n\t\treturn (NULL);\n\t}\n\n\tzgp->zg_root = dataset;\n\tzgp->zg_clone_count = 0;\n\n\treturn (zgp);\n}", "path": "ZFSin/ZFSin/zfs/lib/libzfs/libzfs_graph.c", "commit_date": "2017-03-23 00:00:00", "repo_name": "openzfsonwindows/ZFSin", "stars": 1185, "license": "None", "language": "c", "size": 12371}
{"docstring": "/*\n * The only public interface for this file.  Do the dirty work of constructing a\n * child list for the given object.  Construct the graph, do the toplogical\n * sort, and then return the array of strings to the caller.\n *\n * The 'allowrecursion' parameter controls behavior when cycles are found.  If\n * it is set, the the cycle is ignored and the results returned as if the cycle\n * did not exist.  If it is not set, then the routine will generate an error if\n * a cycle is found.\n */\n", "func_signal": "int\nget_dependents(libzfs_handle_t *hdl, boolean_t allowrecursion,\n    const char *dataset, char ***result, size_t *count)", "code": "{\n\tzfs_graph_t *zgp;\n\tzfs_vertex_t *zvp;\n\n\tif ((zgp = construct_graph(hdl, dataset)) == NULL)\n\t\treturn (-1);\n\n\tif ((*result = zfs_alloc(hdl,\n\t    zgp->zg_nvertex * sizeof (char *))) == NULL) {\n\t\tzfs_graph_destroy(zgp);\n\t\treturn (-1);\n\t}\n\n\tif ((zvp = zfs_graph_lookup(hdl, zgp, dataset, 0)) == NULL) {\n\t\tfree(*result);\n\t\tzfs_graph_destroy(zgp);\n\t\treturn (-1);\n\t}\n\n\t*count = 0;\n\tif (topo_sort(hdl, allowrecursion, *result, count, zvp) != 0) {\n\t\tfree(*result);\n\t\tzfs_graph_destroy(zgp);\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Get rid of the last entry, which is our starting vertex and not\n\t * strictly a dependent.\n\t */\n\tassert(*count > 0);\n\tfree((*result)[*count - 1]);\n\t(*count)--;\n\n\tzfs_graph_destroy(zgp);\n\n\treturn (0);\n}", "path": "ZFSin/ZFSin/zfs/lib/libzfs/libzfs_graph.c", "commit_date": "2017-03-23 00:00:00", "repo_name": "openzfsonwindows/ZFSin", "stars": 1185, "license": "None", "language": "c", "size": 12371}
{"docstring": "/*\n * NB: dataset must not be changing on-disk (eg, is a snapshot or we are\n * in syncing context).\n */\n", "func_signal": "int\ntraverse_dataset_resume(dsl_dataset_t *ds, uint64_t txg_start,\n    zbookmark_phys_t *resume,\n    int flags, blkptr_cb_t func, void *arg)", "code": "{\n\treturn (traverse_impl(ds->ds_dir->dd_pool->dp_spa, ds, ds->ds_object,\n\t    &dsl_dataset_phys(ds)->ds_bp, txg_start, resume, flags, func, arg));\n}", "path": "ZFSin/ZFSin/zfs/module/zfs/dmu_traverse.c", "commit_date": "2019-10-11 00:00:00", "repo_name": "openzfsonwindows/ZFSin", "stars": 1185, "license": "None", "language": "c", "size": 12371}
{"docstring": "/*\n * Allocate a new edge pointing to the target vertex.\n */\n", "func_signal": "static zfs_edge_t *\nzfs_edge_create(libzfs_handle_t *hdl, zfs_vertex_t *dest)", "code": "{\n\tzfs_edge_t *zep = zfs_alloc(hdl, sizeof (zfs_edge_t));\n\n\tif (zep == NULL)\n\t\treturn (NULL);\n\n\tzep->ze_dest = dest;\n\n\treturn (zep);\n}", "path": "ZFSin/ZFSin/zfs/lib/libzfs/libzfs_graph.c", "commit_date": "2017-03-23 00:00:00", "repo_name": "openzfsonwindows/ZFSin", "stars": 1185, "license": "None", "language": "c", "size": 12371}
{"docstring": "/* ARGSUSED */\n", "func_signal": "static int\ntraverse_prefetcher(spa_t *spa, zilog_t *zilog, const blkptr_t *bp,\n    const zbookmark_phys_t *zb, const dnode_phys_t *dnp, void *arg)", "code": "{\n\tprefetch_data_t *pfd = arg;\n\tint zio_flags = ZIO_FLAG_CANFAIL | ZIO_FLAG_SPECULATIVE;\n\tarc_flags_t aflags = ARC_FLAG_NOWAIT | ARC_FLAG_PREFETCH |\n\t    ARC_FLAG_PRESCIENT_PREFETCH;\n\n\tASSERT(pfd->pd_bytes_fetched >= 0);\n\tif (bp == NULL)\n\t\treturn (0);\n\tif (pfd->pd_cancel)\n\t\treturn (SET_ERROR(EINTR));\n\n\tif (!prefetch_needed(pfd, bp))\n\t\treturn (0);\n\n\tmutex_enter(&pfd->pd_mtx);\n\twhile (!pfd->pd_cancel && pfd->pd_bytes_fetched >= zfs_pd_bytes_max)\n\t\tcv_wait_sig(&pfd->pd_cv, &pfd->pd_mtx);\n\tpfd->pd_bytes_fetched += BP_GET_LSIZE(bp);\n\tcv_broadcast(&pfd->pd_cv);\n\tmutex_exit(&pfd->pd_mtx);\n\n\tif ((pfd->pd_flags & TRAVERSE_NO_DECRYPT) && BP_IS_PROTECTED(bp))\n\t\tzio_flags |= ZIO_FLAG_RAW;\n\n\t(void) arc_read(NULL, spa, bp, NULL, NULL, ZIO_PRIORITY_ASYNC_READ,\n\t    zio_flags, &aflags, zb);\n\n\treturn (0);\n}", "path": "ZFSin/ZFSin/zfs/module/zfs/dmu_traverse.c", "commit_date": "2019-10-11 00:00:00", "repo_name": "openzfsonwindows/ZFSin", "stars": 1185, "license": "None", "language": "c", "size": 12371}
{"docstring": "/*\n * Given two dataset names, create an edge between them.  For the source vertex,\n * mark 'zv_visited' to indicate that we have seen this vertex, and not simply\n * created it as a destination of another edge.  If 'dest' is NULL, then this\n * is an individual vertex (i.e. the starting vertex), so don't add an edge.\n */\n", "func_signal": "static int\nzfs_graph_add(libzfs_handle_t *hdl, zfs_graph_t *zgp, const char *source,\n    const char *dest, uint64_t txg)", "code": "{\n\tzfs_vertex_t *svp, *dvp;\n\n\tif ((svp = zfs_graph_lookup(hdl, zgp, source, 0)) == NULL)\n\t\treturn (-1);\n\tsvp->zv_visited = VISIT_SEEN;\n\tif (dest != NULL) {\n\t\tdvp = zfs_graph_lookup(hdl, zgp, dest, txg);\n\t\tif (dvp == NULL)\n\t\t\treturn (-1);\n\t\tif (zfs_vertex_add_edge(hdl, svp, dvp) != 0)\n\t\t\treturn (-1);\n\t}\n\n\treturn (0);\n}", "path": "ZFSin/ZFSin/zfs/lib/libzfs/libzfs_graph.c", "commit_date": "2017-03-23 00:00:00", "repo_name": "openzfsonwindows/ZFSin", "stars": 1185, "license": "None", "language": "c", "size": 12371}
{"docstring": "/*\n * Sort the given vertex edges according to the creation txg of each vertex.\n */\n", "func_signal": "static void\nzfs_vertex_sort_edges(zfs_vertex_t *zvp)", "code": "{\n\tif (zvp->zv_edgecount == 0)\n\t\treturn;\n\n\tqsort(zvp->zv_edges, zvp->zv_edgecount, sizeof (void *),\n\t    zfs_edge_compare);\n}", "path": "ZFSin/ZFSin/zfs/lib/libzfs/libzfs_graph.c", "commit_date": "2017-03-23 00:00:00", "repo_name": "openzfsonwindows/ZFSin", "stars": 1185, "license": "None", "language": "c", "size": 12371}
{"docstring": "/*\n * Graph hash function.  Classic bernstein k=33 hash function, taken from\n * usr/src/cmd/sgs/tools/common/strhash.c\n */\n", "func_signal": "static size_t\nzfs_graph_hash(zfs_graph_t *zgp, const char *str)", "code": "{\n\tsize_t hash = 5381;\n\tint c;\n\n\twhile ((c = *str++) != 0)\n\t\thash = ((hash << 5) + hash) + c; /* hash * 33 + c */\n\n\treturn (hash % zgp->zg_size);\n}", "path": "ZFSin/ZFSin/zfs/lib/libzfs/libzfs_graph.c", "commit_date": "2017-03-23 00:00:00", "repo_name": "openzfsonwindows/ZFSin", "stars": 1185, "license": "None", "language": "c", "size": 12371}
{"docstring": "/*\n * Given a graph, do a recursive topological sort into the given array.  This is\n * really just a depth first search, so that the deepest nodes appear first.\n * hijack the 'zv_visited' marker to avoid visiting the same vertex twice.\n */\n", "func_signal": "static int\ntopo_sort(libzfs_handle_t *hdl, boolean_t allowrecursion, char **result,\n    size_t *idx, zfs_vertex_t *zgv)", "code": "{\n\tint i;\n\n\tif (zgv->zv_visited == VISIT_SORT_PRE && !allowrecursion) {\n\t\t/*\n\t\t * If we've already seen this vertex as part of our depth-first\n\t\t * search, then we have a cyclic dependency, and we must return\n\t\t * an error.\n\t\t */\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"recursive dependency at '%s'\"),\n\t\t    zgv->zv_dataset);\n\t\treturn (zfs_error(hdl, EZFS_RECURSIVE,\n\t\t    dgettext(TEXT_DOMAIN,\n\t\t    \"cannot determine dependent datasets\")));\n\t} else if (zgv->zv_visited >= VISIT_SORT_PRE) {\n\t\t/*\n\t\t * If we've already processed this as part of the topological\n\t\t * sort, then don't bother doing so again.\n\t\t */\n\t\treturn (0);\n\t}\n\n\tzgv->zv_visited = VISIT_SORT_PRE;\n\n\t/* avoid doing a search if we don't have to */\n\tzfs_vertex_sort_edges(zgv);\n\tfor (i = 0; i < zgv->zv_edgecount; i++) {\n\t\tif (topo_sort(hdl, allowrecursion, result, idx,\n\t\t    zgv->zv_edges[i]->ze_dest) != 0)\n\t\t\treturn (-1);\n\t}\n\n\t/* we may have visited this in the course of the above */\n\tif (zgv->zv_visited == VISIT_SORT_POST)\n\t\treturn (0);\n\n\tif ((result[*idx] = zfs_alloc(hdl,\n\t    strlen(zgv->zv_dataset) + 1)) == NULL)\n\t\treturn (-1);\n\n\t(void) strcpy(result[*idx], zgv->zv_dataset);\n\t*idx += 1;\n\tzgv->zv_visited = VISIT_SORT_POST;\n\treturn (0);\n}", "path": "ZFSin/ZFSin/zfs/lib/libzfs/libzfs_graph.c", "commit_date": "2017-03-23 00:00:00", "repo_name": "openzfsonwindows/ZFSin", "stars": 1185, "license": "None", "language": "c", "size": 12371}
{"docstring": "/*\n * Destroy a vertex.  Frees up any associated edges.\n */\n", "func_signal": "static void\nzfs_vertex_destroy(zfs_vertex_t *zvp)", "code": "{\n\tint i;\n\n\tfor (i = 0; i < zvp->zv_edgecount; i++)\n\t\tzfs_edge_destroy(zvp->zv_edges[i]);\n\n\tfree(zvp->zv_edges);\n\tfree(zvp);\n}", "path": "ZFSin/ZFSin/zfs/lib/libzfs/libzfs_graph.c", "commit_date": "2017-03-23 00:00:00", "repo_name": "openzfsonwindows/ZFSin", "stars": 1185, "license": "None", "language": "c", "size": 12371}
{"docstring": "/*\n * Given a dataset name, finds the associated vertex, creating it if necessary.\n */\n", "func_signal": "static zfs_vertex_t *\nzfs_graph_lookup(libzfs_handle_t *hdl, zfs_graph_t *zgp, const char *dataset,\n    uint64_t txg)", "code": "{\n\tsize_t idx = zfs_graph_hash(zgp, dataset);\n\tzfs_vertex_t *zvp;\n\n\tfor (zvp = zgp->zg_hash[idx]; zvp != NULL; zvp = zvp->zv_next) {\n\t\tif (strcmp(zvp->zv_dataset, dataset) == 0) {\n\t\t\tif (zvp->zv_txg == 0)\n\t\t\t\tzvp->zv_txg = txg;\n\t\t\treturn (zvp);\n\t\t}\n\t}\n\n\tif ((zvp = zfs_vertex_create(hdl, dataset)) == NULL)\n\t\treturn (NULL);\n\n\tzvp->zv_next = zgp->zg_hash[idx];\n\tzvp->zv_txg = txg;\n\tzgp->zg_hash[idx] = zvp;\n\tzgp->zg_nvertex++;\n\n\treturn (zvp);\n}", "path": "ZFSin/ZFSin/zfs/lib/libzfs/libzfs_graph.c", "commit_date": "2017-03-23 00:00:00", "repo_name": "openzfsonwindows/ZFSin", "stars": 1185, "license": "None", "language": "c", "size": 12371}
{"docstring": "/*\n * Destroy a graph object.  We have to iterate over all the hash chains,\n * destroying each vertex in the process.\n */\n", "func_signal": "static void\nzfs_graph_destroy(zfs_graph_t *zgp)", "code": "{\n\tint i;\n\tzfs_vertex_t *current, *next;\n\n\tfor (i = 0; i < zgp->zg_size; i++) {\n\t\tcurrent = zgp->zg_hash[i];\n\t\twhile (current != NULL) {\n\t\t\tnext = current->zv_next;\n\t\t\tzfs_vertex_destroy(current);\n\t\t\tcurrent = next;\n\t\t}\n\t}\n\n\tfree(zgp->zg_hash);\n\tfree(zgp);\n}", "path": "ZFSin/ZFSin/zfs/lib/libzfs/libzfs_graph.c", "commit_date": "2017-03-23 00:00:00", "repo_name": "openzfsonwindows/ZFSin", "stars": 1185, "license": "None", "language": "c", "size": 12371}
{"docstring": "/*\n * Allocate a new vertex with the given name.\n */\n", "func_signal": "static zfs_vertex_t *\nzfs_vertex_create(libzfs_handle_t *hdl, const char *dataset)", "code": "{\n\tzfs_vertex_t *zvp = zfs_alloc(hdl, sizeof (zfs_vertex_t));\n\n\tif (zvp == NULL)\n\t\treturn (NULL);\n\n\tassert(strlen(dataset) < ZFS_MAX_DATASET_NAME_LEN);\n\n\t(void) strlcpy(zvp->zv_dataset, dataset, sizeof (zvp->zv_dataset));\n\n\tif ((zvp->zv_edges = zfs_alloc(hdl,\n\t    MIN_EDGECOUNT * sizeof (void *))) == NULL) {\n\t\tfree(zvp);\n\t\treturn (NULL);\n\t}\n\n\tzvp->zv_edgealloc = MIN_EDGECOUNT;\n\n\treturn (zvp);\n}", "path": "ZFSin/ZFSin/zfs/lib/libzfs/libzfs_graph.c", "commit_date": "2017-03-23 00:00:00", "repo_name": "openzfsonwindows/ZFSin", "stars": 1185, "license": "None", "language": "c", "size": 12371}
{"docstring": "/*\n * Iterate over all children of the given dataset, adding any vertices\n * as necessary.  Returns -1 if there was an error, or 0 otherwise.\n * This is a simple recursive algorithm - the ZFS namespace typically\n * is very flat.  We manually invoke the necessary ioctl() calls to\n * avoid the overhead and additional semantics of zfs_open().\n */\n", "func_signal": "static int\niterate_children(libzfs_handle_t *hdl, zfs_graph_t *zgp, const char *dataset)", "code": "{\n\tzfs_cmd_t zc = {\"\\0\"};\n\tzfs_vertex_t *zvp;\n\n\t/*\n\t * Look up the source vertex, and avoid it if we've seen it before.\n\t */\n\tzvp = zfs_graph_lookup(hdl, zgp, dataset, 0);\n\tif (zvp == NULL)\n\t\treturn (-1);\n\tif (zvp->zv_visited == VISIT_SEEN)\n\t\treturn (0);\n\n\t/*\n\t * Iterate over all children\n\t */\n\tfor ((void) strlcpy(zc.zc_name, dataset, sizeof (zc.zc_name));\n\t    zfs_ioctl(hdl, ZFS_IOC_DATASET_LIST_NEXT, &zc) == 0;\n\t    (void) strlcpy(zc.zc_name, dataset, sizeof (zc.zc_name))) {\n\t\t/*\n\t\t * Get statistics for this dataset, to determine the type of the\n\t\t * dataset and clone statistics.  If this fails, the dataset has\n\t\t * since been removed, and we're pretty much screwed anyway.\n\t\t */\n\t\tzc.zc_objset_stats.dds_origin[0] = '\\0';\n\t\tif (zfs_ioctl(hdl, ZFS_IOC_OBJSET_STATS, &zc) != 0)\n\t\t\tcontinue;\n\n\t\tif (zc.zc_objset_stats.dds_origin[0] != '\\0') {\n\t\t\tif (zfs_graph_add(hdl, zgp,\n\t\t\t    zc.zc_objset_stats.dds_origin, zc.zc_name,\n\t\t\t    zc.zc_objset_stats.dds_creation_txg) != 0)\n\t\t\t\treturn (-1);\n\t\t\t/*\n\t\t\t * Count origins only if they are contained in the graph\n\t\t\t */\n\t\t\tif (isa_child_of(zc.zc_objset_stats.dds_origin,\n\t\t\t    zgp->zg_root))\n\t\t\t\tzgp->zg_clone_count--;\n\t\t}\n\n\t\t/*\n\t\t * Add an edge between the parent and the child.\n\t\t */\n\t\tif (zfs_graph_add(hdl, zgp, dataset, zc.zc_name,\n\t\t    zc.zc_objset_stats.dds_creation_txg) != 0)\n\t\t\treturn (-1);\n\n\t\t/*\n\t\t * Recursively visit child\n\t\t */\n\t\tif (iterate_children(hdl, zgp, zc.zc_name))\n\t\t\treturn (-1);\n\t}\n\n\t/*\n\t * Now iterate over all snapshots.\n\t */\n\tbzero(&zc, sizeof (zc));\n\n\tfor ((void) strlcpy(zc.zc_name, dataset, sizeof (zc.zc_name));\n\t    zfs_ioctl(hdl, ZFS_IOC_SNAPSHOT_LIST_NEXT, &zc) == 0;\n\t    (void) strlcpy(zc.zc_name, dataset, sizeof (zc.zc_name))) {\n\n\t\t/*\n\t\t * Get statistics for this dataset, to determine the type of the\n\t\t * dataset and clone statistics.  If this fails, the dataset has\n\t\t * since been removed, and we're pretty much screwed anyway.\n\t\t */\n\t\tif (zfs_ioctl(hdl, ZFS_IOC_OBJSET_STATS, &zc) != 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Add an edge between the parent and the child.\n\t\t */\n\t\tif (zfs_graph_add(hdl, zgp, dataset, zc.zc_name,\n\t\t    zc.zc_objset_stats.dds_creation_txg) != 0)\n\t\t\treturn (-1);\n\n\t\tzgp->zg_clone_count += zc.zc_objset_stats.dds_num_clones;\n\t}\n\n\tzvp->zv_visited = VISIT_SEEN;\n\n\treturn (0);\n}", "path": "ZFSin/ZFSin/zfs/lib/libzfs/libzfs_graph.c", "commit_date": "2017-03-23 00:00:00", "repo_name": "openzfsonwindows/ZFSin", "stars": 1185, "license": "None", "language": "c", "size": 12371}
{"docstring": "/*\n * Returns RESUME_SKIP_ALL if td indicates that we are resuming a traversal and\n * the block indicated by zb does not need to be visited at all. Returns\n * RESUME_SKIP_CHILDREN if we are resuming a post traversal and we reach the\n * resume point. This indicates that this block should be visited but not its\n * children (since they must have been visited in a previous traversal).\n * Otherwise returns RESUME_SKIP_NONE.\n */\n", "func_signal": "static resume_skip_t\nresume_skip_check(traverse_data_t *td, const dnode_phys_t *dnp,\n    const zbookmark_phys_t *zb)", "code": "{\n\tif (td->td_resume != NULL && !ZB_IS_ZERO(td->td_resume)) {\n\t\t/*\n\t\t * If we already visited this bp & everything below,\n\t\t * don't bother doing it again.\n\t\t */\n\t\tif (zbookmark_subtree_completed(dnp, zb, td->td_resume))\n\t\t\treturn (RESUME_SKIP_ALL);\n\n\t\t/*\n\t\t * If we found the block we're trying to resume from, zero\n\t\t * the bookmark out to indicate that we have resumed.\n\t\t */\n\t\tif (bcmp(zb, td->td_resume, sizeof (*zb)) == 0) {\n\t\t\tbzero(td->td_resume, sizeof (*zb));\n\t\t\tif (td->td_flags & TRAVERSE_POST)\n\t\t\t\treturn (RESUME_SKIP_CHILDREN);\n\t\t}\n\t}\n\treturn (RESUME_SKIP_NONE);\n}", "path": "ZFSin/ZFSin/zfs/module/zfs/dmu_traverse.c", "commit_date": "2019-10-11 00:00:00", "repo_name": "openzfsonwindows/ZFSin", "stars": 1185, "license": "None", "language": "c", "size": 12371}
{"docstring": "/**\n * Go back to 2D mode (contributed by chris_c aka DaShAmAn).\n */\n", "func_signal": "void GRRLIB_2dMode()", "code": "{\n\tMtx view, m;\n\n\tGX_SetZMode(GX_FALSE, GX_LEQUAL, GX_TRUE);\n\n\tGX_SetBlendMode(GX_BM_BLEND, GX_BL_SRCALPHA, GX_BL_INVSRCALPHA, GX_LO_CLEAR);\n\n\tguOrtho(m, 0, rmode->efbHeight, 0, rmode->fbWidth, 0, 1000.0f);\n\tGX_LoadProjectionMtx(m, GX_ORTHOGRAPHIC);\n\n\tguMtxIdentity(view);\n\tguMtxTransApply(view, view, 0, 0, -100.0F);\n\tGX_LoadPosMtxImm(view, GX_PNMTX0);\n\n\tGX_ClearVtxDesc();\n\tGX_SetVtxDesc(GX_VA_POS, GX_DIRECT);\n\tGX_SetVtxDesc(GX_VA_CLR0, GX_DIRECT);\n\tGX_SetVtxDesc(GX_VA_TEX0, GX_NONE);\n\tGX_SetVtxAttrFmt(GX_VTXFMT0, GX_VA_POS, GX_POS_XYZ, GX_F32, 0);\n\tGX_SetVtxAttrFmt(GX_VTXFMT0, GX_VA_CLR0, GX_CLR_RGBA, GX_RGBA8, 0);\n\tGX_SetVtxAttrFmt(GX_VTXFMT0, GX_VA_TEX0, GX_TEX_ST, GX_F32, 0);\n\n\tGX_SetNumTexGens(1);  // One texture exists\n\tGX_SetTevOp(GX_TEVSTAGE0, GX_PASSCLR);\n\tGX_SetTevOrder(GX_TEVSTAGE0, GX_TEXCOORD0, GX_TEXMAP0, GX_COLOR0A0);\n\tGX_SetTexCoordGen(GX_TEXCOORD0, GX_TG_MTX2x4, GX_TG_TEX0, GX_IDENTITY);\n\n\tGX_SetNumTevStages(1);\n\n\tGX_SetTevOp  (GX_TEVSTAGE0, GX_PASSCLR);\n\n\tGX_SetNumChans(1);\n\tGX_SetChanCtrl(GX_COLOR0A0, GX_DISABLE, GX_SRC_VTX, GX_SRC_VTX, 0, GX_DF_NONE, GX_AF_NONE);\n\tGX_SetTevOrder(GX_TEVSTAGE0, GX_TEXCOORD0, GX_TEXMAP0, GX_COLOR0A0);\n\n\tGRRLIB_Settings.lights  = 0;\n}", "path": "Nintendont/loader/source/grrlib.c", "commit_date": "2016-12-01 00:00:00", "repo_name": "FIX94/Nintendont", "stars": 1760, "license": "None", "language": "c", "size": 105542}
{"docstring": "/**\n * Print function for TTF font.\n * @author wplaat and DrTwox\n * @param x Specifies the x-coordinate of the upper-left corner of the text.\n * @param y Specifies the y-coordinate of the upper-left corner of the text.\n * @param myFont A TTF.\n * @param utf32 Text to draw.\n * @param fontSize Size of the font.\n * @param color Text color in RGBA format.\n */\n", "func_signal": "void GRRLIB_PrintfTTFW(int x, int y, GRRLIB_ttfFont *myFont, const wchar_t *utf32, unsigned int fontSize, const u32 color)", "code": "{\n\tif(myFont == NULL || utf32 == NULL)\n\t\treturn;\n\n\tFT_Face Face = (FT_Face)myFont->face;\n\tint penX = 0;\n\tint penY = fontSize;\n\tFT_GlyphSlot slot = Face->glyph;\n\tFT_UInt glyphIndex = 0;\n\tFT_UInt previousGlyph = 0;\n\tu8 cR = R(color), cG = G(color), cB = B(color);\n\n\tif (FT_Set_Pixel_Sizes(Face, 0, fontSize)) {\n\t\tFT_Set_Pixel_Sizes(Face, 0, 12);\n\t}\n\n\t/* Loop over each character, until the\n\t * end of the string is reached, or until the pixel width is too wide */\n\twhile(*utf32) {\n\t\tglyphIndex = FT_Get_Char_Index(myFont->face, *utf32++);\n\n\t\tif (myFont->kerning && previousGlyph && glyphIndex) {\n\t\t\tFT_Vector delta;\n\t\t\tFT_Get_Kerning(myFont->face, previousGlyph, glyphIndex, FT_KERNING_DEFAULT, &delta);\n\t\t\tpenX += delta.x >> 6;\n\t\t}\n\t\tif (FT_Load_Glyph(myFont->face, glyphIndex, FT_LOAD_RENDER)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tDrawBitmap(&slot->bitmap,\n\t\t\t\t   penX + slot->bitmap_left + x,\n\t\t\t\t   penY - slot->bitmap_top + y,\n\t\t\t\t   cR, cG, cB);\n\t\tpenX += slot->advance.x >> 6;\n\t\tpreviousGlyph = glyphIndex;\n\t}\n}", "path": "Nintendont/loader/source/grrlib.c", "commit_date": "2016-12-01 00:00:00", "repo_name": "FIX94/Nintendont", "stars": 1760, "license": "None", "language": "c", "size": 105542}
{"docstring": "/**\n * Change a texture to sepia (old photo style).\n * @see GRRLIB_FlushTex\n * @param texsrc The texture source.\n * @param texdest The texture destination.\n * @author elisherer\n */\n", "func_signal": "void  GRRLIB_BMFX_Sepia (const GRRLIB_texImg *texsrc, GRRLIB_texImg *texdest)", "code": "{\n\tunsigned int  x, y;\n\tu16           sr, sg, sb;\n\tu32           color;\n\n\tfor (y = 0; y < texsrc->h; y++) {\n\t\tfor (x = 0; x < texsrc->w; x++) {\n\t\t\tcolor = GRRLIB_GetPixelFromtexImg(x, y, texsrc);\n\t\t\tsr = R(color)*0.393 + G(color)*0.769 + B(color)*0.189;\n\t\t\tsg = R(color)*0.349 + G(color)*0.686 + B(color)*0.168;\n\t\t\tsb = R(color)*0.272 + G(color)*0.534 + B(color)*0.131;\n\t\t\tif (sr>255) {\n\t\t\t\tsr=255;\n\t\t\t}\n\t\t\tif (sg>255) {\n\t\t\t\tsg=255;\n\t\t\t}\n\t\t\tif (sb>255) {\n\t\t\t\tsb=255;\n\t\t\t}\n\t\t\tGRRLIB_SetPixelTotexImg(x, y, texdest,\n\t\t\t\t\t\t\t\t\tRGBA(sr,sg,sb,A(color)));\n\t\t}\n\t}\n\tGRRLIB_SetHandle(texdest, 0, 0);\n}", "path": "Nintendont/loader/source/grrlib.c", "commit_date": "2016-12-01 00:00:00", "repo_name": "FIX94/Nintendont", "stars": 1760, "license": "None", "language": "c", "size": 105542}
{"docstring": "/**\n * Draw a character on the screen.\n * @param bitmap Bitmap to draw.\n * @param offset x-coordinate offset.\n * @param top y-coordinate.\n * @param cR Red component of the colour.\n * @param cG Green component of the colour.\n * @param cB Blue component of the colour.\n */\n", "func_signal": "static void DrawBitmap(FT_Bitmap *bitmap, int offset, int top, const u8 cR, const u8 cG, const u8 cB)", "code": "{\n\tFT_Int i, j, p, q;\n\tFT_Int x_max = offset + bitmap->width;\n\tFT_Int y_max = top + bitmap->rows;\n\n\tfor ( i = offset, p = 0; i < x_max; i++, p++ ) {\n\t\tfor ( j = top, q = 0; j < y_max; j++, q++ ) {\n\t\t\tGX_Begin(GX_POINTS, GX_VTXFMT0, 1);\n\t\t\t\tGX_Position3f32(i, j, 0);\n\t\t\t\tGX_Color4u8(cR, cG, cB,\n\t\t\t\t\t\t\tbitmap->buffer[ q * bitmap->width + p ]);\n\t\t\tGX_End();\n\t\t}\n\t}\n}", "path": "Nintendont/loader/source/grrlib.c", "commit_date": "2016-12-01 00:00:00", "repo_name": "FIX94/Nintendont", "stars": 1760, "license": "None", "language": "c", "size": 105542}
{"docstring": "/**\n * Draw a tile.\n * @param xpos Specifies the x-coordinate of the upper-left corner.\n * @param ypos Specifies the y-coordinate of the upper-left corner.\n * @param tex The texture containing the tile to draw.\n * @param degrees Angle of rotation.\n * @param scaleX Specifies the x-coordinate scale. -1 could be used for flipping the texture horizontally.\n * @param scaleY Specifies the y-coordinate scale. -1 could be used for flipping the texture vertically.\n * @param color Color in RGBA format.\n * @param frame Specifies the frame to draw.\n */\n", "func_signal": "void  GRRLIB_DrawTile (const f32 xpos, const f32 ypos, const GRRLIB_texImg *tex, const f32 degrees, const f32 scaleX, const f32 scaleY, const u32 color, const int frame)", "code": "{\n\tGXTexObj  texObj;\n\tf32       width, height;\n\tMtx       m, m1, m2, mv;\n\tf32       s1, s2, t1, t2;\n\n\tif (tex == NULL || tex->data == NULL)  return;\n\n\t// The 0.001f/x is the frame correction formula by spiffen\n\ts1 = (frame % tex->nbtilew) * tex->ofnormaltexx;\n\ts2 = s1 + tex->ofnormaltexx;\n\tt1 = (int)(frame/tex->nbtilew) * tex->ofnormaltexy;\n\tt2 = t1 + tex->ofnormaltexy;\n\n\tGX_InitTexObj(&texObj, tex->data,\n\t\t\t\t  tex->tilew * tex->nbtilew, tex->tileh * tex->nbtileh,\n\t\t\t\t  GX_TF_RGBA8, GX_CLAMP, GX_CLAMP, GX_FALSE);\n\n\tif (GRRLIB_Settings.antialias == false) {\n\t\tGX_InitTexObjLOD(&texObj, GX_NEAR, GX_NEAR,\n\t\t\t\t\t\t 0.0f, 0.0f, 0.0f, 0, 0, GX_ANISO_1);\n\t\tGX_SetCopyFilter(GX_FALSE, rmode->sample_pattern, GX_FALSE, rmode->vfilter);\n\t}\n\telse {\n\t\tGX_SetCopyFilter(rmode->aa, rmode->sample_pattern, GX_TRUE, rmode->vfilter);\n\t}\n\n\tGX_LoadTexObj(&texObj,      GX_TEXMAP0);\n\tGX_SetTevOp  (GX_TEVSTAGE0, GX_MODULATE);\n\tGX_SetVtxDesc(GX_VA_TEX0,   GX_DIRECT);\n\n\twidth  = tex->tilew * 0.5f;\n\theight = tex->tileh * 0.5f;\n\n\tguMtxIdentity  (m1);\n\tguMtxScaleApply(m1, m1, scaleX, scaleY, 1.0f);\n\tguMtxRotAxisDeg(m2, &axis, degrees);\n\tguMtxConcat    (m2, m1, m);\n\n\tguMtxTransApply(m, m,\n\t\txpos +width  +tex->handlex\n\t\t\t-tex->offsetx +( scaleX *(-tex->handley *sin(-DegToRad(degrees))\n\t\t\t\t\t\t\t\t\t  -tex->handlex *cos(-DegToRad(degrees))) ),\n\t\typos +height +tex->handley\n\t\t\t-tex->offsety +( scaleY *(-tex->handley *cos(-DegToRad(degrees))\n\t\t\t\t\t\t\t\t\t  +tex->handlex *sin(-DegToRad(degrees))) ),\n\t\t0);\n\n\tguMtxConcat(GXmodelView2D, m, mv);\n\n\tGX_LoadPosMtxImm(mv, GX_PNMTX0);\n\tGX_Begin(GX_QUADS, GX_VTXFMT0, 4);\n\t\tGX_Position3f32(-width, -height, 0);\n\t\tGX_Color1u32   (color);\n\t\tGX_TexCoord2f32(s1, t1);\n\n\t\tGX_Position3f32(width, -height,  0);\n\t\tGX_Color1u32   (color);\n\t\tGX_TexCoord2f32(s2, t1);\n\n\t\tGX_Position3f32(width, height,  0);\n\t\tGX_Color1u32   (color);\n\t\tGX_TexCoord2f32(s2, t2);\n\n\t\tGX_Position3f32(-width, height,  0);\n\t\tGX_Color1u32   (color);\n\t\tGX_TexCoord2f32(s1, t2);\n\tGX_End();\n\tGX_LoadPosMtxImm(GXmodelView2D, GX_PNMTX0);\n\n\tGX_SetTevOp  (GX_TEVSTAGE0, GX_PASSCLR);\n\tGX_SetVtxDesc(GX_VA_TEX0,   GX_NONE);\n}", "path": "Nintendont/loader/source/grrlib.c", "commit_date": "2016-12-01 00:00:00", "repo_name": "FIX94/Nintendont", "stars": 1760, "license": "None", "language": "c", "size": 105542}
{"docstring": "/**\n * Load a TTF from a buffer.\n * @param file_base Buffer with TTF data. You must not deallocate the memory before calling GRRLIB_FreeTTF.\n * @param file_size Size of the TTF buffer.\n * @return A handle to a given TTF font object.\n * @see GRRLIB_FreeTTF\n */\n", "func_signal": "GRRLIB_ttfFont* GRRLIB_LoadTTF (const u8* file_base, s32 file_size)", "code": "{\n\tFT_Face Face;\n\tGRRLIB_ttfFont* myFont = (GRRLIB_ttfFont*)malloc(sizeof(GRRLIB_ttfFont));\n\tFT_New_Memory_Face(ftLibrary, file_base, file_size, 0, &Face);\n\tmyFont->kerning = FT_HAS_KERNING(Face);\n/*\n\tif (FT_Set_Pixel_Sizes(Face, 0, fontSize)) {\n\t\tFT_Set_Pixel_Sizes(Face, 0, 12);\n\t}\n*/\n\tmyFont->face = Face;\n\treturn myFont;\n}", "path": "Nintendont/loader/source/grrlib.c", "commit_date": "2016-12-01 00:00:00", "repo_name": "FIX94/Nintendont", "stars": 1760, "license": "None", "language": "c", "size": 105542}
{"docstring": "/**\n * Print formatted output.\n * @param xpos Specifies the x-coordinate of the upper-left corner of the text.\n * @param ypos Specifies the y-coordinate of the upper-left corner of the text.\n * @param tex The texture containing the character set.\n * @param color Text color in RGBA format. The alpha channel is used to change the opacity of the text.\n * @param zoom This is a factor by which the text size will be increase or decrease.\n * @param text Text to draw.\n * @param ... Optional arguments.\n */\n", "func_signal": "void  GRRLIB_Printf (const f32 xpos, const f32 ypos,\n\t\t\t\t\t const GRRLIB_texImg *tex, const u32 color,\n\t\t\t\t\t const f32 zoom, const char *text, ...)", "code": "{\n\tif (tex == NULL || tex->data == NULL) {\n\t\treturn;\n\t}\n\n\tint i, size;\n\tchar tmp[1024];\n\tf32 offset = tex->tilew * zoom;\n\n\tva_list argp;\n\tva_start(argp, text);\n\tsize = vsnprintf(tmp, sizeof(tmp), text, argp);\n\tva_end(argp);\n\n\tfor (i = 0; i < size; i++) {\n\t\tGRRLIB_DrawTile(xpos+i*offset, ypos, tex, 0, zoom, zoom, color,\n\t\t\ttmp[i] - tex->tilestart);\n\t}\n}", "path": "Nintendont/loader/source/grrlib.c", "commit_date": "2016-12-01 00:00:00", "repo_name": "FIX94/Nintendont", "stars": 1760, "license": "None", "language": "c", "size": 105542}
{"docstring": "/**\n * Set up the position matrix (contributed by chris_c aka DaShAmAn).\n * @param minDist Minimal distance for the camera.\n * @param maxDist Maximal distance for the camera.\n * @param fov Field of view for the camera.\n * @param texturemode False, GX won't need texture coordinate, True, GX will need texture coordinate.\n * @param normalmode False, GX won't need normal coordinate, True, GX will need normal coordinate.\n */\n", "func_signal": "void GRRLIB_3dMode(f32 minDist, f32 maxDist, f32 fov, bool texturemode, bool normalmode)", "code": "{\n\tMtx m;\n\n\tguLookAt(_GRR_view, &_GRR_cam, &_GRR_up, &_GRR_look);\n\tguPerspective(m, fov, (f32)rmode->fbWidth/rmode->efbHeight, minDist, maxDist);\n\tGX_LoadProjectionMtx(m, GX_PERSPECTIVE);\n\tGX_SetZMode (GX_TRUE, GX_LEQUAL, GX_TRUE);\n\n\tGX_SetCullMode(GX_CULL_NONE);\n\n\tGX_ClearVtxDesc();\n\tGX_SetVtxDesc(GX_VA_POS, GX_DIRECT);\n\tif(normalmode)   GX_SetVtxDesc(GX_VA_NRM, GX_DIRECT);\n\tGX_SetVtxDesc(GX_VA_CLR0, GX_DIRECT);\n\tif(texturemode)  GX_SetVtxDesc(GX_VA_TEX0, GX_DIRECT);\n\n\tGX_SetVtxAttrFmt(GX_VTXFMT0, GX_VA_POS, GX_POS_XYZ, GX_F32, 0);\n\tif(normalmode)   GX_SetVtxAttrFmt(GX_VTXFMT0, GX_VA_NRM, GX_NRM_XYZ, GX_F32, 0);\n\tGX_SetVtxAttrFmt(GX_VTXFMT0, GX_VA_CLR0, GX_CLR_RGBA, GX_RGBA8, 0);\n\tif(texturemode)  GX_SetVtxAttrFmt(GX_VTXFMT0, GX_VA_TEX0, GX_TEX_ST, GX_F32, 0);\n\n\tif(texturemode)  GX_SetTevOp(GX_TEVSTAGE0, GX_MODULATE);\n\telse             GX_SetTevOp(GX_TEVSTAGE0, GX_PASSCLR);\n}", "path": "Nintendont/loader/source/grrlib.c", "commit_date": "2016-12-01 00:00:00", "repo_name": "FIX94/Nintendont", "stars": 1760, "license": "None", "language": "c", "size": 105542}
{"docstring": "/**\n * Draw a cone (with normal).\n * @param r Radius of the cone.\n * @param h High of the cone.\n * @param d Dencity of slice.\n * @param filled Wired or not.\n * @param col Color of the cone.\n */\n", "func_signal": "void GRRLIB_DrawCone(f32 r, f32 h, int d, bool filled, u32 col)", "code": "{\n\tint i;\n\tf32 dx, dy;\n\n\tif(filled) GX_Begin(GX_TRIANGLESTRIP, GX_VTXFMT0, 2 * (d+1));\n\telse       GX_Begin(GX_LINESTRIP, GX_VTXFMT0, 2 * (d+1));\n\tfor(i = 0 ; i <= d ; i++) {\n\t\tdx = cosf( M_PI * 2.0f * i / d );\n\t\tdy = sinf( M_PI * 2.0f * i / d );\n\t\tGX_Position3f32( 0, -0.5f * h,0);\n\t\tGX_Normal3f32( dx, 0.0f, dy );\n\t\tGX_Color1u32(col);\n\t\tGX_Position3f32( r * dx, 0.5f * h, r * dy );\n\t\tGX_Normal3f32( dx, 0.0f, dy );\n\t\tGX_Color1u32(col);\n\t}\n\tGX_End();\n\n\tif(filled) GX_Begin(GX_TRIANGLEFAN, GX_VTXFMT0, d+2);\n\telse       GX_Begin(GX_LINESTRIP, GX_VTXFMT0, d+2);\n\tGX_Position3f32(0.0f, 0.5f * h, 0.0f);\n\tGX_Normal3f32(0.0f, 1.0f, 0.0f);\n\tGX_Color1u32(col);\n\tfor(i = 0 ; i <= d ; i++) {\n\t\tGX_Position3f32( r * cosf( M_PI * 2.0f * i / d ), 0.5f * h, r * sinf( M_PI * 2.0f * i / d ) );\n\t\tGX_Normal3f32(0.0f, 1.0f, 0.0f);\n\t\tGX_Color1u32(col);\n\t}\n\tGX_End();\n}", "path": "Nintendont/loader/source/grrlib.c", "commit_date": "2016-12-01 00:00:00", "repo_name": "FIX94/Nintendont", "stars": 1760, "license": "None", "language": "c", "size": 105542}
{"docstring": "/**\n * A texture effect (Scatter).\n * @see GRRLIB_FlushTex\n * @param texsrc The texture source.\n * @param texdest The texture destination.\n * @param factor The factor level of the effect.\n */\n", "func_signal": "void  GRRLIB_BMFX_Scatter (const GRRLIB_texImg *texsrc,\n\t\t\t\t\t\t\t\t GRRLIB_texImg *texdest, const u32 factor)", "code": "{\n\tunsigned int x, y;\n\tu32 val1, val2;\n\tu32 val3, val4;\n\tint factorx2 = factor*2;\n\n\tfor (y = 0; y < texsrc->h; y++) {\n\t\tfor (x = 0; x < texsrc->w; x++) {\n\t\t\tval1 = x + (int) (factorx2 * (rand() / (RAND_MAX + 1.0))) - factor;\n\t\t\tval2 = y + (int) (factorx2 * (rand() / (RAND_MAX + 1.0))) - factor;\n\n\t\t\tif ((val1 >= texsrc->w) || (val2 >= texsrc->h)) {\n\t\t\t}\n\t\t\telse {\n\t\t\t\tval3 = GRRLIB_GetPixelFromtexImg(x, y, texsrc);\n\t\t\t\tval4 = GRRLIB_GetPixelFromtexImg(val1, val2, texsrc);\n\t\t\t\tGRRLIB_SetPixelTotexImg(x, y, texdest, val4);\n\t\t\t\tGRRLIB_SetPixelTotexImg(val1, val2, texdest, val3);\n\t\t\t}\n\t\t}\n\t}\n}", "path": "Nintendont/loader/source/grrlib.c", "commit_date": "2016-12-01 00:00:00", "repo_name": "FIX94/Nintendont", "stars": 1760, "license": "None", "language": "c", "size": 105542}
{"docstring": "/**\n * Set the view matrix to draw object (in this order scale, rotate AND trans).\n * @param posx x position of the object.\n * @param posy y position of the object.\n * @param posz z position of the object.\n * @param angx x rotation angle of the object.\n * @param angy y rotation angle of the object.\n * @param angz z rotation angle of the object.\n * @param scalx x scale of the object.\n * @param scaly y scale of the object.\n * @param scalz z scale of the object.\n */\n", "func_signal": "void GRRLIB_ObjectView(f32 posx, f32 posy, f32 posz, f32 angx, f32 angy, f32 angz, f32 scalx, f32 scaly, f32 scalz)", "code": "{\n\tMtx ObjTransformationMtx;\n\tMtx m, rx,ry,rz;\n\tMtx mv, mvi;\n\n\tguMtxIdentity(ObjTransformationMtx);\n\n\tif((scalx !=1.0f) || (scaly !=1.0f) || (scalz !=1.0f)) {\n\t\tguMtxIdentity(m);\n\t\tguMtxScaleApply(m, m, scalx, scaly, scalz);\n\n\t\tguMtxConcat(m, ObjTransformationMtx, ObjTransformationMtx);\n\t}\n\n\tif((angx !=0.0f) || (angy !=0.0f) || (angz !=0.0f)) {\n\t\tguMtxIdentity(m);\n\t\tguMtxRotAxisDeg(rx, &_GRRaxisx, angx);\n\t\tguMtxRotAxisDeg(ry, &_GRRaxisy, angy);\n\t\tguMtxRotAxisDeg(rz, &_GRRaxisz, angz);\n\t\tguMtxConcat(ry, rx, m);\n\t\tguMtxConcat(m, rz, m);\n\n\t\tguMtxConcat(m, ObjTransformationMtx, ObjTransformationMtx);\n\t}\n\n\tif((posx !=0.0f) || (posy !=0.0f) || (posz !=0.0f)) {\n\t\tguMtxIdentity(m);\n\t\tguMtxTransApply(m, m, posx, posy, posz);\n\n\t\tguMtxConcat(m, ObjTransformationMtx, ObjTransformationMtx);\n\t}\n\n\tguMtxConcat(_GRR_view, ObjTransformationMtx, mv);\n\tGX_LoadPosMtxImm(mv, GX_PNMTX0);\n\n\tguMtxInverse(mv, mvi);\n\tguMtxTranspose(mvi, mv);\n\tGX_LoadNrmMtxImm(mv, GX_PNMTX0);\n}", "path": "Nintendont/loader/source/grrlib.c", "commit_date": "2016-12-01 00:00:00", "repo_name": "FIX94/Nintendont", "stars": 1760, "license": "None", "language": "c", "size": 105542}
{"docstring": "/**\n * Load a texture from a buffer.\n * Take care to have the JPG finish with 0xFF 0xD9!\n * @param my_jpg The JPEG buffer to load.\n * @return A GRRLIB_texImg structure filled with image information.\n */\n", "func_signal": "GRRLIB_texImg*  GRRLIB_LoadTextureJPG (const u8 *my_jpg)", "code": "{\n\tint n = 0;\n\n\tif ((my_jpg[0]==0xFF) && (my_jpg[1]==0xD8) && (my_jpg[2]==0xFF)) {\n\t\twhile(true) {\n\t\t\tif ((my_jpg[n]==0xFF) && (my_jpg[n+1]==0xD9))\n\t\t\t\tbreak;\n\t\t\tn++;\n\t\t}\n\t\tn+=2;\n\t}\n\n#ifdef ENABLE_JPEG\n\treturn GRRLIB_LoadTextureJPGEx(my_jpg, n);\n#else\n    return NULL;\n#endif\n}", "path": "Nintendont/loader/source/grrlib.c", "commit_date": "2016-12-01 00:00:00", "repo_name": "FIX94/Nintendont", "stars": 1760, "license": "None", "language": "c", "size": 105542}
{"docstring": "/* Functions for PSO Keyboard */\n", "func_signal": "static void kbDoSpecial(u8 *in, u8 *out)", "code": "{\n\tif((*in)&0x02)\n\t{\n\t\t*in = (*in)&(~0x02);\n\t\t*out = 0x54;\n\t}\n\telse if((*in)&0x20)\n\t{\n\t\t*in = (*in)&(~0x20);\n\t\t*out = 0x55;\n\t}\n\telse if((*in)&0x11)\n\t{\n\t\t*in = (*in)&(~0x11);\n\t\t*out = 0x56;\n\t}\n\telse if((*in)&0x04)\n\t{\n\t\t*in = (*in)&(~0x04);\n\t\t*out = 0x57;\n\t} //special for french, german and spanish layouts\n\telse if((*in)&0x40)\n\t{\n\t\t*in = (*in)&(~0x40);\n\t\t*out = 0x5B;\n\t}\n}", "path": "Nintendont/loader/source/ppc/PADReadGC/source/PADReadGC.c", "commit_date": "2019-10-06 00:00:00", "repo_name": "FIX94/Nintendont", "stars": 1760, "license": "None", "language": "c", "size": 105542}
{"docstring": "/**\n * Set the camera parameter (contributed my chris_c aka DaShAmAn).\n * @param posx x position of the camera.\n * @param posy y position of the camera.\n * @param posz z position of the camera.\n * @param upx Alpha component.\n * @param upy Alpha component.\n * @param upz Alpha component.\n * @param lookx x up position of the camera.\n * @param looky y up position of the camera.\n * @param lookz z up position of the camera.\n */\n", "func_signal": "void GRRLIB_Camera3dSettings(f32 posx, f32 posy, f32 posz,\n\tf32 upx, f32 upy, f32 upz,\n\tf32 lookx, f32 looky, f32 lookz)", "code": "{\n\n   _GRR_cam.x=posx;\n   _GRR_cam.y=posy;\n   _GRR_cam.z=posz;\n\n   _GRR_up.x=upx;\n   _GRR_up.y=upy;\n   _GRR_up.z=upz;\n\n   _GRR_look.x=lookx;\n   _GRR_look.y=looky;\n   _GRR_look.z=lookz;\n}", "path": "Nintendont/loader/source/grrlib.c", "commit_date": "2016-12-01 00:00:00", "repo_name": "FIX94/Nintendont", "stars": 1760, "license": "None", "language": "c", "size": 105542}
{"docstring": "// General ES functions\n", "func_signal": "void ES_Init()", "code": "{\n//Used in Ioctlvs\n\tpath\t\t= (char*)malloca(\t\t0x40,  32 );\n\tsize\t\t= (u32*) malloca( sizeof(u32), 32 );\n\tiTitleID\t= (u64*) malloca( sizeof(u64), 32 );\n\n\tCNTMap\t\t= (u8*)NULL;\n\tDITicket\t= (u8*)NULL;\n\tKeyID\t\t= (u32*)NULL;\n\n\tCNTSize\t\t= (u32*)malloca( 4, 32 );\n\tCNTMapDirty\t= (u32*)malloca( 4, 32 );\n\t*CNTMapDirty= 1;\n\t\n\tTTitles\t\t\t= (u64*)NULL;\n\tTTitlesO\t\t= (u64*)NULL;\n\n\tTOCount\t\t\t= 0;\n\tTOCountDirty\t= 0;\n\tTOCountDirty\t= 1;\n\n\tES_BootSystem();\n}", "path": "Nintendont/kernel/ES.c", "commit_date": "2017-09-17 00:00:00", "repo_name": "FIX94/Nintendont", "stars": 1760, "license": "None", "language": "c", "size": 105542}
{"docstring": "/**\n * Print formatted output with a ByteMap font.\n * This function could be slow, it should be used with GRRLIB_CompoStart and GRRLIB_CompoEnd.\n * @param xpos Specifies the x-coordinate of the upper-left corner of the text.\n * @param ypos Specifies the y-coordinate of the upper-left corner of the text.\n * @param bmf The ByteMap font to use.\n * @param text Text to draw.\n * @param ... Optional arguments.\n */\n", "func_signal": "void  GRRLIB_PrintBMF (const f32 xpos, const f32 ypos,\n\t\t\t\t\t   const GRRLIB_bytemapFont *bmf,\n\t\t\t\t\t   const char *text, ...)", "code": "{\n\tuint  i, size;\n\tu8    *pdata;\n\tu8    x, y;\n\tchar  tmp[1024];\n\tf32   xoff = xpos;\n\tconst GRRLIB_bytemapChar *pchar;\n\n\tva_list argp;\n\tva_start(argp, text);\n\tsize = vsnprintf(tmp, sizeof(tmp), text, argp);\n\tva_end(argp);\n\n\tfor (i=0; i<size; i++) {\n\t\tpchar = &bmf->charDef[(u8)tmp[i]];\n\t\tpdata = pchar->data;\n\t\tfor (y=0; y<pchar->height; y++) {\n\t\t\tfor (x=0; x<pchar->width; x++) {\n\t\t\t\tif (*pdata) {\n\t\t\t\t\tGRRLIB_Plot(xoff + x + pchar->relx,\n\t\t\t\t\t\t\t\typos + y + pchar->rely,\n\t\t\t\t\t\t\t\tbmf->palette[*pdata]);\n\t\t\t\t}\n\t\t\t\tpdata++;\n\t\t\t}\n\t\t}\n\t\txoff += pchar->kerning + bmf->tracking;\n\t}\n}", "path": "Nintendont/loader/source/grrlib.c", "commit_date": "2016-12-01 00:00:00", "repo_name": "FIX94/Nintendont", "stars": 1760, "license": "None", "language": "c", "size": 105542}
{"docstring": "/**\n * Flip texture horizontal.\n * @see GRRLIB_FlushTex\n * @param texsrc The texture source.\n * @param texdest The texture destination.\n */\n", "func_signal": "void  GRRLIB_BMFX_FlipH (const GRRLIB_texImg *texsrc, GRRLIB_texImg *texdest)", "code": "{\n\tunsigned int x, y, txtWidth = texsrc->w - 1;\n\n\tfor (y = 0; y < texsrc->h; y++) {\n\t\tfor (x = 0; x < texsrc->w; x++) {\n\t\t\tGRRLIB_SetPixelTotexImg(txtWidth - x, y, texdest,\n\t\t\t\tGRRLIB_GetPixelFromtexImg(x, y, texsrc));\n\t\t}\n\t}\n}", "path": "Nintendont/loader/source/grrlib.c", "commit_date": "2016-12-01 00:00:00", "repo_name": "FIX94/Nintendont", "stars": 1760, "license": "None", "language": "c", "size": 105542}
{"docstring": "/**\n * Draw a cube (with normal).\n * @param size Size of the cube edge.\n * @param filled Wired or not.\n * @param col Color of the cube.\n */\n", "func_signal": "void GRRLIB_DrawCube(f32 size, bool filled, u32 col)", "code": "{\n\tstatic f32 n[6][3] =\n\t{\n\t\t{-1.0, 0.0, 0.0},\n\t\t{0.0, 1.0, 0.0},\n\t\t{1.0, 0.0, 0.0},\n\t\t{0.0, -1.0, 0.0},\n\t\t{0.0, 0.0, 1.0},\n\t\t{0.0, 0.0, -1.0}\n\t};\n\tstatic int faces[6][4] =\n\t{\n\t\t{0, 1, 2, 3},\n\t\t{3, 2, 6, 7},\n\t\t{7, 6, 5, 4},\n\t\t{4, 5, 1, 0},\n\t\t{5, 6, 2, 1},\n\t\t{7, 4, 0, 3}\n\t};\n\tf32 v[8][3];\n\tint i;\n\n\tv[0][0] = v[1][0] = v[2][0] = v[3][0] = -size / 2;\n\tv[4][0] = v[5][0] = v[6][0] = v[7][0] = size / 2;\n\tv[0][1] = v[1][1] = v[4][1] = v[5][1] = -size / 2;\n\tv[2][1] = v[3][1] = v[6][1] = v[7][1] = size / 2;\n\tv[0][2] = v[3][2] = v[4][2] = v[7][2] = -size / 2;\n\tv[1][2] = v[2][2] = v[5][2] = v[6][2] = size / 2;\n\n\tfor (i = 5; i >= 0; i--) {\n\t\tif(filled) GX_Begin(GX_QUADS, GX_VTXFMT0, 4);\n\t\telse       GX_Begin(GX_LINESTRIP, GX_VTXFMT0, 5);\n\t\tGX_Position3f32(v[faces[i][0]][0], v[faces[i][0]][1], v[faces[i][0]][2] );\n\t\tGX_Normal3f32(n[i][0], n[i][1], n[i][2]);\n\t\tGX_Color1u32(col);\n\t\tGX_Position3f32(v[faces[i][1]][0], v[faces[i][1]][1], v[faces[i][1]][2]);\n\t\tGX_Normal3f32(n[i][0], n[i][1], n[i][2]);\n\t\tGX_Color1u32(col);\n\t\tGX_Position3f32(v[faces[i][2]][0], v[faces[i][2]][1], v[faces[i][2]][2]);\n\t\tGX_Normal3f32(n[i][0], n[i][1], n[i][2]);\n\t\tGX_Color1u32(col);\n\t\tGX_Position3f32(v[faces[i][3]][0], v[faces[i][3]][1], v[faces[i][3]][2]);\n\t\tGX_Normal3f32(n[i][0], n[i][1], n[i][2]);\n\t\tGX_Color1u32(col);\n\t\tif(!filled) {\n\t\t\tGX_Position3f32(v[faces[i][0]][0], v[faces[i][0]][1], v[faces[i][0]][2]);\n\t\t\tGX_Normal3f32(n[i][0], n[i][1], n[i][2]);\n\t\t\tGX_Color1u32(col);\n\t\t}\n\t\tGX_End();\n\t}\n}", "path": "Nintendont/loader/source/grrlib.c", "commit_date": "2016-12-01 00:00:00", "repo_name": "FIX94/Nintendont", "stars": 1760, "license": "None", "language": "c", "size": 105542}
{"docstring": "/**\n * Rotate the object matrix to draw object .\n * @param angx x rotation angle of the object.\n * @param angy y rotation angle of the object.\n * @param angz z rotation angle of the object.\n */\n", "func_signal": "void GRRLIB_ObjectViewRotate(f32 angx, f32 angy, f32 angz)", "code": "{\n\tMtx m, rx,ry,rz;\n\n\tguMtxIdentity(m);\n\tguMtxRotAxisDeg(rx, &_GRRaxisx, angx);\n\tguMtxRotAxisDeg(ry, &_GRRaxisy, angy);\n\tguMtxRotAxisDeg(rz, &_GRRaxisz, angz);\n\tguMtxConcat(ry, rx, m);\n\tguMtxConcat(m, rz, m);\n\n\tguMtxConcat(m, _ObjTransformationMtx, _ObjTransformationMtx);\n}", "path": "Nintendont/loader/source/grrlib.c", "commit_date": "2016-12-01 00:00:00", "repo_name": "FIX94/Nintendont", "stars": 1760, "license": "None", "language": "c", "size": 105542}
{"docstring": "/**\n * Set specular light parameters.\n * @param num Number of the light. It's a number from 0 to 7.\n * @param dir Direction of the specular ray (x/y/z).\n * @param shy Shyniness of the specular. ( between 4 and 254)\n * @param lightcolor Color of the light in RGBA format.\n * @param speccolor Specular color in RGBA format..\n */\n", "func_signal": "void GRRLIB_SetLightSpec(u8 num, guVector dir, f32 shy, u32 lightcolor, u32 speccolor)", "code": "{\n\tMtx mr,mv;\n\tGXLightObj MyLight;\n\tguVector ldir = {dir.x, dir.y, dir.z};\n\n\tGRRLIB_Settings.lights |= (1<<num);\n\n\tguMtxInverse(_GRR_view,mr);\n\tguMtxTranspose(mr,mv);\n\tguVecMultiplySR(mv, &ldir,&ldir);\n\tGX_InitSpecularDirv(&MyLight, &ldir);\n\n\tGX_InitLightShininess(&MyLight, shy);  // between 4 and 255 !!!\n\tGX_InitLightColor(&MyLight, (GXColor) { R(lightcolor), G(lightcolor), B(lightcolor), 0xFF });\n\tGX_LoadLightObj(&MyLight, (1<<num));\n\n\t/////////////////////// Turn light ON ////////////////////////////////////////////////\n\tGX_SetNumChans(2);    // use two color channels\n\tGX_SetChanCtrl(GX_COLOR0, GX_ENABLE, GX_SRC_REG, GX_SRC_VTX, GX_LIGHT0, GX_DF_CLAMP, GX_AF_NONE);\n\tGX_SetChanCtrl(GX_COLOR1, GX_ENABLE, GX_SRC_REG, GX_SRC_REG, GX_LIGHT0, GX_DF_NONE, GX_AF_SPEC);\n\tGX_SetChanCtrl(GX_ALPHA0, GX_DISABLE, GX_SRC_REG, GX_SRC_REG, GX_LIGHTNULL, GX_DF_NONE, GX_AF_NONE);\n\tGX_SetChanCtrl(GX_ALPHA1, GX_DISABLE, GX_SRC_REG, GX_SRC_REG, GX_LIGHTNULL, GX_DF_NONE, GX_AF_NONE);\n\n\n\tGX_SetNumTevStages(2);\n\tGX_SetTevOrder(GX_TEVSTAGE0, GX_TEXCOORDNULL, GX_TEXMAP_NULL, GX_COLOR0A0 );\n\tGX_SetTevOrder(GX_TEVSTAGE1, GX_TEXCOORDNULL, GX_TEXMAP_NULL, GX_COLOR1A1 );\n\tGX_SetTevOp(GX_TEVSTAGE0, GX_PASSCLR);\n\tGX_SetTevColorOp(GX_TEVSTAGE1, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_ENABLE, GX_TEVPREV );\n\tGX_SetTevColorIn(GX_TEVSTAGE1, GX_CC_ZERO, GX_CC_RASC, GX_CC_ONE, GX_CC_CPREV );\n\n\t/////////////////////// Define Material and Ambiant color and draw object /////////////////////////////////////\n\tGX_SetChanAmbColor(GX_COLOR1, (GXColor){0x00,0x00,0x00,0xFF});  // specualr ambient forced to black\n\tGX_SetChanMatColor(GX_COLOR1, (GXColor) { R(speccolor), G(speccolor), B(speccolor), 0xFF }); // couleur du reflet specular\n}", "path": "Nintendont/loader/source/grrlib.c", "commit_date": "2016-12-01 00:00:00", "repo_name": "FIX94/Nintendont", "stars": 1760, "license": "None", "language": "c", "size": 105542}
{"docstring": "/*! @abstract Check if l_begin, m_begin, m0_begin (m0_begin < m_begin) can be\n * expanded to a match of length at least 3.\n * @param m_begin new string to match.\n * @param m0_begin candidate old string.\n * @param src source buffer, with valid indices src_begin <= i < src_end.\n * (src_begin may be <0)\n * @return If a match can be found, return 1 and set all \\p match fields,\n * otherwise return 0.\n * @note \\p *match should be 0 before the call. */\n", "func_signal": "static inline int lzvn_find_match(const unsigned char *src,\n                                  lzvn_offset src_begin,\n                                  lzvn_offset src_end, lzvn_offset l_begin,\n                                  lzvn_offset m0_begin, lzvn_offset m_begin,\n                                  lzvn_match_info *match)", "code": "{\n  lzvn_offset n = nmatch4(src, m_begin, m0_begin);\n  if (n < 3)\n    return 0; // no match\n\n  lzvn_offset D = m_begin - m0_begin; // actual distance\n  if (D <= 0 || D > LZVN_ENCODE_MAX_DISTANCE)\n    return 0; // distance out of range\n\n  // Expand forward\n  lzvn_offset m_end = m_begin + n;\n  while (n == 4 && m_end + 4 < src_end) {\n    n = nmatch4(src, m_end, m_end - D);\n    m_end += n;\n  }\n\n  // Expand backwards over literal\n  while (m0_begin > src_begin && m_begin > l_begin &&\n         src[m_begin - 1] == src[m0_begin - 1]) {\n    m0_begin--;\n    m_begin--;\n  }\n\n  // OK, we keep it, update MATCH\n  lzvn_offset M = m_end - m_begin; // match length\n  match->m_begin = m_begin;\n  match->m_end = m_end;\n  match->K = M - ((D < 0x600) ? 2 : 3);\n  match->M = M;\n  match->D = D;\n\n  return 1; // OK\n}", "path": "lzfse/src/lzvn_encode_base.c", "commit_date": "2016-08-15 00:00:00", "repo_name": "lzfse/lzfse", "stars": 1748, "license": "bsd-3-clause", "language": "c", "size": 95}
{"docstring": "/*! @abstract Copy at least \\p nbytes bytes from \\p src to \\p dst, by blocks\n * of 8 bytes (may go beyond range). No overlap.\n * @return \\p dst + \\p nbytes. */\n", "func_signal": "static inline unsigned char *lzvn_copy64(unsigned char *restrict dst,\n                                         const unsigned char *restrict src,\n                                         size_t nbytes)", "code": "{\n  for (size_t i = 0; i < nbytes; i += 8)\n    store8(dst + i, load8(src + i));\n  return dst + nbytes;\n}", "path": "lzfse/src/lzvn_encode_base.c", "commit_date": "2016-08-15 00:00:00", "repo_name": "lzfse/lzfse", "stars": 1748, "license": "bsd-3-clause", "language": "c", "size": 95}
{"docstring": "/*! @abstract Initialize encoder table in \\p state, uses current I/O parameters. */\n", "func_signal": "static inline void lzvn_init_table(lzvn_encoder_state *state)", "code": "{\n  lzvn_offset index = -LZVN_ENCODE_MAX_DISTANCE; // max match distance\n  if (index < state->src_begin)\n    index = state->src_begin;\n  uint32_t value = load4(state->src + index);\n\n  lzvn_encode_entry_type e;\n  for (int i = 0; i < 4; i++) {\n    e.indices[i] = offset_to_s32(index);\n    e.values[i] = value;\n  }\n  for (int u = 0; u < LZVN_ENCODE_HASH_VALUES; u++)\n    state->table[u] = e; // fill entire table\n}", "path": "lzfse/src/lzvn_encode_base.c", "commit_date": "2016-08-15 00:00:00", "repo_name": "lzfse/lzfse", "stars": 1748, "license": "bsd-3-clause", "language": "c", "size": 95}
{"docstring": "/*! @abstract Same as lzvn_find_match, but we already know that N bytes do\n *  match (N<=4). */\n", "func_signal": "static inline int lzvn_find_matchN(const unsigned char *src,\n                                   lzvn_offset src_begin,\n                                   lzvn_offset src_end, lzvn_offset l_begin,\n                                   lzvn_offset m0_begin, lzvn_offset m_begin,\n                                   lzvn_offset n, lzvn_match_info *match)", "code": "{\n  // We can skip the first comparison on 4 bytes\n  if (n < 3)\n    return 0; // no match\n\n  lzvn_offset D = m_begin - m0_begin; // actual distance\n  if (D <= 0 || D > LZVN_ENCODE_MAX_DISTANCE)\n    return 0; // distance out of range\n\n  // Expand forward\n  lzvn_offset m_end = m_begin + n;\n  while (n == 4 && m_end + 4 < src_end) {\n    n = nmatch4(src, m_end, m_end - D);\n    m_end += n;\n  }\n\n  // Expand backwards over literal\n  while (m0_begin > src_begin && m_begin > l_begin &&\n         src[m_begin - 1] == src[m0_begin - 1]) {\n    m0_begin--;\n    m_begin--;\n  }\n\n  // OK, we keep it, update MATCH\n  lzvn_offset M = m_end - m_begin; // match length\n  match->m_begin = m_begin;\n  match->m_end = m_end;\n  match->K = M - ((D < 0x600) ? 2 : 3);\n  match->M = M;\n  match->D = D;\n\n  return 1; // OK\n}", "path": "lzfse/src/lzvn_encode_base.c", "commit_date": "2016-08-15 00:00:00", "repo_name": "lzfse/lzfse", "stars": 1748, "license": "bsd-3-clause", "language": "c", "size": 95}
{"docstring": "/*! @abstract Emit end-of-stream and update state.\n * @return number of bytes written to \\p dst. May be 0 if there is no more space\n * in \\p dst to emit the instruction. */\n", "func_signal": "static inline lzvn_offset lzvn_emit_end_of_stream(lzvn_encoder_state *state)", "code": "{\n  // Do we have 8 byte in dst?\n  if (state->dst_end < state->dst + 8)\n    return 0; // FULL\n\n  // Insert end marker and update state\n  store8(state->dst, 0x06); // end-of-stream command\n  state->dst += 8;\n  return 8; // dst_used\n}", "path": "lzfse/src/lzvn_encode_base.c", "commit_date": "2016-08-15 00:00:00", "repo_name": "lzfse/lzfse", "stars": 1748, "license": "bsd-3-clause", "language": "c", "size": 95}
{"docstring": "// Initialize encoder table T[NSYMBOLS].\n// NSTATES = sum FREQ[i] is the number of states (a power of 2)\n// NSYMBOLS is the number of symbols.\n// FREQ[NSYMBOLS] is a normalized histogram of symbol frequencies, with FREQ[i]\n// >= 0.\n// Some symbols may have a 0 frequency.  In that case, they should not be\n// present in the data.\n", "func_signal": "void fse_init_encoder_table(int nstates, int nsymbols,\n                            const uint16_t *__restrict freq,\n                            fse_encoder_entry *__restrict t)", "code": "{\n  int offset = 0; // current offset\n  int n_clz = __builtin_clz(nstates);\n  for (int i = 0; i < nsymbols; i++) {\n    int f = (int)freq[i];\n    if (f == 0)\n      continue; // skip this symbol, no occurrences\n    int k =\n        __builtin_clz(f) - n_clz; // shift needed to ensure N <= (F<<K) < 2*N\n    t[i].s0 = (int16_t)((f << k) - nstates);\n    t[i].k = (int16_t)k;\n    t[i].delta0 = (int16_t)(offset - f + (nstates >> k));\n    t[i].delta1 = (int16_t)(offset - f + (nstates >> (k - 1)));\n    offset += f;\n  }\n}", "path": "lzfse/src/lzfse_fse.c", "commit_date": "2016-06-19 00:00:00", "repo_name": "lzfse/lzfse", "stars": 1748, "license": "bsd-3-clause", "language": "c", "size": 95}
{"docstring": "// Initialize decoder table T[NSTATES].\n// NSTATES = sum FREQ[i] is the number of states (a power of 2)\n// NSYMBOLS is the number of symbols.\n// FREQ[NSYMBOLS] is a normalized histogram of symbol frequencies, with FREQ[i]\n// >= 0.\n// Some symbols may have a 0 frequency.  In that case, they should not be\n// present in the data.\n", "func_signal": "int fse_init_decoder_table(int nstates, int nsymbols,\n                           const uint16_t *__restrict freq,\n                           int32_t *__restrict t)", "code": "{\n  assert(nsymbols <= 256);\n  assert(fse_check_freq(freq, nsymbols, nstates) == 0);\n  int n_clz = __builtin_clz(nstates);\n  int sum_of_freq = 0;\n  for (int i = 0; i < nsymbols; i++) {\n    int f = (int)freq[i];\n    if (f == 0)\n      continue; // skip this symbol, no occurrences\n\n    sum_of_freq += f;\n\n    if (sum_of_freq > nstates) {\n      return -1;\n    }\n\n    int k =\n        __builtin_clz(f) - n_clz; // shift needed to ensure N <= (F<<K) < 2*N\n    int j0 = ((2 * nstates) >> k) - f;\n\n    // Initialize all states S reached by this symbol: OFFSET <= S < OFFSET + F\n    for (int j = 0; j < f; j++) {\n      fse_decoder_entry e;\n\n      e.symbol = (uint8_t)i;\n      if (j < j0) {\n        e.k = (int8_t)k;\n        e.delta = (int16_t)(((f + j) << k) - nstates);\n      } else {\n        e.k = (int8_t)(k - 1);\n        e.delta = (int16_t)((j - j0) << (k - 1));\n      }\n\n      memcpy(t, &e, sizeof(e));\n      t++;\n    }\n  }\n\n  return 0; // OK\n}", "path": "lzfse/src/lzfse_fse.c", "commit_date": "2016-06-19 00:00:00", "repo_name": "lzfse/lzfse", "stars": 1748, "license": "bsd-3-clause", "language": "c", "size": 95}
{"docstring": "/*! @abstract Emit (L,0,0) instructions (final literal).\n * We read at most \\p L bytes from \\p p.\n * @param p input stream\n * @param q1 the first byte after the output buffer.\n * @return pointer to the next output, <= \\p q1.\n * @return \\p q1 if output is full. In that case, output will be partially invalid.\n */\n", "func_signal": "static inline unsigned char *emit_literal(const unsigned char *p,\n                                          unsigned char *q, unsigned char *q1,\n                                          size_t L)", "code": "{\n  size_t x;\n  while (L > 15) {\n    x = L < 271 ? L : 271;\n    if (q + x + 10 >= q1)\n      goto OUT_FULL;\n    store2(q, 0xE0 + ((x - 16) << 8));\n    q += 2;\n    L -= x;\n    q = lzvn_copy8(q, p, x);\n    p += x;\n  }\n  if (L > 0) {\n    if (q + L + 10 >= q1)\n      goto OUT_FULL;\n    *q++ = 0xE0 + L; // 1110LLLL\n    q = lzvn_copy8(q, p, L);\n  }\n  return q;\n\nOUT_FULL:\n  return q1;\n}", "path": "lzfse/src/lzvn_encode_base.c", "commit_date": "2016-08-15 00:00:00", "repo_name": "lzfse/lzfse", "stars": 1748, "license": "bsd-3-clause", "language": "c", "size": 95}
{"docstring": "/*! @abstract Emit a match and update state.\n * @return number of bytes written to \\p dst. May be 0 if there is no more space\n * in \\p dst to emit the match. */\n", "func_signal": "static inline lzvn_offset lzvn_emit_match(lzvn_encoder_state *state,\n                                          lzvn_match_info match)", "code": "{\n  size_t L = (size_t)(match.m_begin - state->src_literal); // literal count\n  size_t M = (size_t)match.M;                              // match length\n  size_t D = (size_t)match.D;                              // match distance\n  size_t D_prev = (size_t)state->d_prev; // previously emitted match distance\n  unsigned char *dst = emit(state->src + state->src_literal, state->dst,\n                            state->dst_end, L, M, D, D_prev);\n  // Check if DST is full\n  if (dst >= state->dst_end) {\n    return 0; // FULL\n  }\n\n  // Update state\n  lzvn_offset dst_used = dst - state->dst;\n  state->d_prev = match.D;\n  state->dst = dst;\n  state->src_literal = match.m_end;\n  return dst_used;\n}", "path": "lzfse/src/lzvn_encode_base.c", "commit_date": "2016-08-15 00:00:00", "repo_name": "lzfse/lzfse", "stars": 1748, "license": "bsd-3-clause", "language": "c", "size": 95}
{"docstring": "/*! @abstract Extracts up to 32 bits from a 64-bit field beginning at\n *  \\p offset, and zero-extends them to a \\p uint32_t.\n *\n *  If we number the bits of \\p v from 0 (least significant) to 63 (most\n *  significant), the result is bits \\p offset to \\p offset+nbits-1. */\n", "func_signal": "static inline uint32_t get_field(uint64_t v, int offset, int nbits)", "code": "{\n  assert(offset + nbits < 64 && offset >= 0 && nbits <= 32);\n  if (nbits == 32)\n    return (uint32_t)(v >> offset);\n  return (uint32_t)((v >> offset) & ((1 << nbits) - 1));\n}", "path": "lzfse/src/lzfse_decode_base.c", "commit_date": "2016-06-08 00:00:00", "repo_name": "lzfse/lzfse", "stars": 1748, "license": "bsd-3-clause", "language": "c", "size": 95}
{"docstring": "/*! @abstract Emit a n-bytes literal and update state.\n * @return number of bytes written to \\p dst. May be 0 if there is no more space\n * in \\p dst to emit the literal. */\n", "func_signal": "static inline lzvn_offset lzvn_emit_literal(lzvn_encoder_state *state,\n                                            lzvn_offset n)", "code": "{\n  size_t L = (size_t)n;\n  unsigned char *dst = emit_literal(state->src + state->src_literal, state->dst,\n                                    state->dst_end, L);\n  // Check if DST is full\n  if (dst >= state->dst_end)\n    return 0; // FULL\n\n  // Update state\n  lzvn_offset dst_used = dst - state->dst;\n  state->dst = dst;\n  state->src_literal += n;\n  return dst_used;\n}", "path": "lzfse/src/lzvn_encode_base.c", "commit_date": "2016-08-15 00:00:00", "repo_name": "lzfse/lzfse", "stars": 1748, "license": "bsd-3-clause", "language": "c", "size": 95}
{"docstring": "/*! @abstract Return the number [0, 4] of matching chars between values at\n * \\p src+i and \\p src+j, starting from the least significant byte.\n * Assumes we can read 4 chars from each position. */\n", "func_signal": "static inline lzvn_offset nmatch4(const unsigned char *src, lzvn_offset i,\n                                  lzvn_offset j)", "code": "{\n  uint32_t vi = load4(src + i);\n  uint32_t vj = load4(src + j);\n  return trailing_zero_bytes(vi ^ vj);\n}", "path": "lzfse/src/lzvn_encode_base.c", "commit_date": "2016-08-15 00:00:00", "repo_name": "lzfse/lzfse", "stars": 1748, "license": "bsd-3-clause", "language": "c", "size": 95}
{"docstring": "/*! @abstract Return 32-bit value to store for offset x. */\n", "func_signal": "static inline int32_t offset_to_s32(lzvn_offset x)", "code": "{ return (int32_t)x; }\n\n/*! @abstract Get offset from 32-bit stored value x. */\nstatic inline lzvn_offset offset_from_s32(int32_t x) { return (lzvn_offset)x; }\n\n// ===============================================================\n// Hash and Matching\n\n/*! @abstract Get hash in range \\c [0,LZVN_ENCODE_HASH_VALUES-1] from 3 bytes in i. */\nstatic inline uint32_t hash3i(uint32_t i) {\n  i &= 0xffffff; // truncate to 24-bit input (slightly increases compression ratio)\n  uint32_t h = (i * (1 + (1 << 6) + (1 << 12))) >> 12;\n  return h & (LZVN_ENCODE_HASH_VALUES - 1);\n}", "path": "lzfse/src/lzvn_encode_base.c", "commit_date": "2016-08-15 00:00:00", "repo_name": "lzfse/lzfse", "stars": 1748, "license": "bsd-3-clause", "language": "c", "size": 95}
{"docstring": "/*! @abstract Copy exactly \\p nbytes bytes from \\p src to \\p dst (respects range).\n * No overlap.\n * @return \\p dst + \\p nbytes. */\n", "func_signal": "static inline unsigned char *lzvn_copy8(unsigned char *restrict dst,\n                                        const unsigned char *restrict src,\n                                        size_t nbytes)", "code": "{\n  for (size_t i = 0; i < nbytes; i++)\n    dst[i] = src[i];\n  return dst + nbytes;\n}", "path": "lzfse/src/lzvn_encode_base.c", "commit_date": "2016-08-15 00:00:00", "repo_name": "lzfse/lzfse", "stars": 1748, "license": "bsd-3-clause", "language": "c", "size": 95}
{"docstring": "/*! @abstract Decode an entry value from next bits of stream.\n *  Return \\p value, and set \\p *nbits to the number of bits to consume\n *  (starting with LSB). */\n", "func_signal": "static inline int lzfse_decode_v1_freq_value(uint32_t bits, int *nbits)", "code": "{\n  static const int8_t lzfse_freq_nbits_table[32] = {\n      2, 3, 2, 5, 2, 3, 2, 8, 2, 3, 2, 5, 2, 3, 2, 14,\n      2, 3, 2, 5, 2, 3, 2, 8, 2, 3, 2, 5, 2, 3, 2, 14};\n  static const int8_t lzfse_freq_value_table[32] = {\n      0, 2, 1, 4, 0, 3, 1, -1, 0, 2, 1, 5, 0, 3, 1, -1,\n      0, 2, 1, 6, 0, 3, 1, -1, 0, 2, 1, 7, 0, 3, 1, -1};\n\n  uint32_t b = bits & 31; // lower 5 bits\n  int n = lzfse_freq_nbits_table[b];\n  *nbits = n;\n\n  // Special cases for > 5 bits encoding\n  if (n == 8)\n    return 8 + ((bits >> 4) & 0xf);\n  if (n == 14)\n    return 24 + ((bits >> 4) & 0x3ff);\n\n  // <= 5 bits encoding from table\n  return lzfse_freq_value_table[b];\n}", "path": "lzfse/src/lzfse_decode_base.c", "commit_date": "2016-06-08 00:00:00", "repo_name": "lzfse/lzfse", "stars": 1748, "license": "bsd-3-clause", "language": "c", "size": 95}
{"docstring": "/*! @abstract Emit (L,M,D) instructions. M>=3.\n * @param p input stream pointing to the beginning of the literal. We read at\n * most \\p L+4 bytes from \\p p.\n * @param q1 the first byte after the output buffer.\n * @return pointer to the next output, <= \\p q1.\n * @return \\p q1 if output is full. In that case, output will be partially invalid.\n */\n", "func_signal": "static inline unsigned char *emit(const unsigned char *p, unsigned char *q,\n                                  unsigned char *q1, size_t L, size_t M,\n                                  size_t D, size_t D_prev)", "code": "{\n  size_t x;\n  while (L > 15) {\n    x = L < 271 ? L : 271;\n    if (q + x + 10 >= q1)\n      goto OUT_FULL;\n    store2(q, 0xE0 + ((x - 16) << 8));\n    q += 2;\n    L -= x;\n    q = lzvn_copy64(q, p, x);\n    p += x;\n  }\n  if (L > 3) {\n    if (q + L + 10 >= q1)\n      goto OUT_FULL;\n    *q++ = 0xE0 + L; // 1110LLLL\n    q = lzvn_copy64(q, p, L);\n    p += L;\n    L = 0;\n  }\n  x = M <= 10 - 2 * L ? M : 10 - 2 * L; // x = min(10-2*L,M)\n  M -= x;\n  x -= 3; // M = (x+3) + M'    max value for x is 7-2*L\n\n  // Here L<4 literals remaining, we read them here\n  uint32_t literal = load4(p);\n  // P is not accessed after this point\n\n  // Relaxed capacity test covering all cases\n  if (q + 8 >= q1)\n    goto OUT_FULL;\n\n  if (D == D_prev) {\n    if (L == 0) {\n      *q++ = 0xF0 + (x + 3); // XM!\n    } else {\n      *q++ = (L << 6) + (x << 3) + 6; //  LLxxx110\n    }\n    store4(q, literal);\n    q += L;\n  } else if (D < 2048 - 2 * 256) {\n    // Short dist    D>>8 in 0..5\n    *q++ = (D >> 8) + (L << 6) + (x << 3); // LLxxxDDD\n    *q++ = D & 0xFF;\n    store4(q, literal);\n    q += L;\n  } else if (D >= (1 << 14) || M == 0 || (x + 3) + M > 34) {\n    // Long dist\n    *q++ = (L << 6) + (x << 3) + 7;\n    store2(q, D);\n    q += 2;\n    store4(q, literal);\n    q += L;\n  } else {\n    // Medium distance\n    x += M;\n    M = 0;\n    *q++ = 0xA0 + (x >> 2) + (L << 3);\n    store2(q, D << 2 | (x & 3));\n    q += 2;\n    store4(q, literal);\n    q += L;\n  }\n\n  // Issue remaining match\n  while (M > 15) {\n    if (q + 2 >= q1)\n      goto OUT_FULL;\n    x = M < 271 ? M : 271;\n    store2(q, 0xf0 + ((x - 16) << 8));\n    q += 2;\n    M -= x;\n  }\n  if (M > 0) {\n    if (q + 1 >= q1)\n      goto OUT_FULL;\n    *q++ = 0xF0 + M; // M = 0..15\n  }\n\n  return q;\n\nOUT_FULL:\n  return q1;\n}", "path": "lzfse/src/lzvn_encode_base.c", "commit_date": "2016-08-15 00:00:00", "repo_name": "lzfse/lzfse", "stars": 1748, "license": "bsd-3-clause", "language": "c", "size": 95}
{"docstring": "/*! @abstract Decode all fields from a \\c lzfse_compressed_block_header_v2 to a\n * \\c lzfse_compressed_block_header_v1.\n * @return 0 on success.\n * @return -1 on failure. */\n", "func_signal": "static inline int lzfse_decode_v1(lzfse_compressed_block_header_v1 *out,\n                                const lzfse_compressed_block_header_v2 *in)", "code": "{\n  // Clear all fields\n  memset(out, 0x00, sizeof(lzfse_compressed_block_header_v1));\n\n  uint64_t v0 = in->packed_fields[0];\n  uint64_t v1 = in->packed_fields[1];\n  uint64_t v2 = in->packed_fields[2];\n\n  out->magic = LZFSE_COMPRESSEDV1_BLOCK_MAGIC;\n  out->n_raw_bytes = in->n_raw_bytes;\n\n  // Literal state\n  out->n_literals = get_field(v0, 0, 20);\n  out->n_literal_payload_bytes = get_field(v0, 20, 20);\n  out->literal_bits = (int)get_field(v0, 60, 3) - 7;\n  out->literal_state[0] = get_field(v1, 0, 10);\n  out->literal_state[1] = get_field(v1, 10, 10);\n  out->literal_state[2] = get_field(v1, 20, 10);\n  out->literal_state[3] = get_field(v1, 30, 10);\n\n  // L,M,D state\n  out->n_matches = get_field(v0, 40, 20);\n  out->n_lmd_payload_bytes = get_field(v1, 40, 20);\n  out->lmd_bits = (int)get_field(v1, 60, 3) - 7;\n  out->l_state = get_field(v2, 32, 10);\n  out->m_state = get_field(v2, 42, 10);\n  out->d_state = get_field(v2, 52, 10);\n\n  // Total payload size\n  out->n_payload_bytes =\n      out->n_literal_payload_bytes + out->n_lmd_payload_bytes;\n\n  // Freq tables\n  uint16_t *dst = &(out->l_freq[0]);\n  const uint8_t *src = &(in->freq[0]);\n  const uint8_t *src_end =\n      (const uint8_t *)in + get_field(v2, 0, 32); // first byte after header\n  uint32_t accum = 0;\n  int accum_nbits = 0;\n\n  // No freq tables?\n  if (src_end == src)\n    return 0; // OK, freq tables were omitted\n\n  for (int i = 0; i < LZFSE_ENCODE_L_SYMBOLS + LZFSE_ENCODE_M_SYMBOLS +\n                          LZFSE_ENCODE_D_SYMBOLS + LZFSE_ENCODE_LITERAL_SYMBOLS;\n       i++) {\n    // Refill accum, one byte at a time, until we reach end of header, or accum\n    // is full\n    while (src < src_end && accum_nbits + 8 <= 32) {\n      accum |= (uint32_t)(*src) << accum_nbits;\n      accum_nbits += 8;\n      src++;\n    }\n\n    // Decode and store value\n    int nbits = 0;\n    dst[i] = lzfse_decode_v1_freq_value(accum, &nbits);\n\n    if (nbits > accum_nbits)\n      return -1; // failed\n\n    // Consume nbits bits\n    accum >>= nbits;\n    accum_nbits -= nbits;\n  }\n\n  if (accum_nbits >= 8 || src != src_end)\n    return -1; // we need to end up exactly at the end of header, with less than\n               // 8 bits in accumulator\n\n  return 0;\n}", "path": "lzfse/src/lzfse_decode_base.c", "commit_date": "2016-06-08 00:00:00", "repo_name": "lzfse/lzfse", "stars": 1748, "license": "bsd-3-clause", "language": "c", "size": 95}
{"docstring": "// ===============================================================\n// API entry points\n", "func_signal": "size_t lzvn_encode_scratch_size(void)", "code": "{ return LZVN_ENCODE_WORK_SIZE; }\n\nstatic size_t lzvn_encode_partial(void *__restrict dst, size_t dst_size,\n                                  const void *__restrict src, size_t src_size,\n                                  size_t *src_used, void *__restrict work) {\n  // Min size checks to avoid accessing memory outside buffers.\n  if (dst_size < LZVN_ENCODE_MIN_DST_SIZE) {\n    *src_used = 0;\n    return 0;\n  }\n  // Max input size check (limit to offsets on uint32_t).\n  if (src_size > LZVN_ENCODE_MAX_SRC_SIZE) {\n    src_size = LZVN_ENCODE_MAX_SRC_SIZE;\n  }\n\n  // Setup encoder state\n  lzvn_encoder_state state;\n  memset(&state, 0, sizeof(state));\n\n  state.src = src;\n  state.src_begin = 0;\n  state.src_end = (lzvn_offset)src_size;\n  state.src_literal = 0;\n  state.src_current = 0;\n  state.dst = dst;\n  state.dst_begin = dst;\n  state.dst_end = (unsigned char *)dst + dst_size - 8; // reserve 8 bytes for end-of-stream\n  state.table = work;\n\n  // Do not encode if the input buffer is too small. We'll emit a literal instead.\n  if (src_size >= LZVN_ENCODE_MIN_SRC_SIZE) {\n\n    state.src_current_end = (lzvn_offset)src_size - LZVN_ENCODE_MIN_MARGIN;\n    lzvn_init_table(&state);\n    lzvn_encode(&state);\n\n  }\n\n  // No need to test the return value: src_literal will not be updated on failure,\n  // and we will fail later.\n  lzvn_emit_literal(&state, state.src_end - state.src_literal);\n\n  // Restore original size, so end-of-stream always succeeds, and emit it\n  state.dst_end = (unsigned char *)dst + dst_size;\n  lzvn_emit_end_of_stream(&state);\n\n  *src_used = state.src_literal;\n  return (size_t)(state.dst - state.dst_begin);\n}", "path": "lzfse/src/lzvn_encode_base.c", "commit_date": "2016-08-15 00:00:00", "repo_name": "lzfse/lzfse", "stars": 1748, "license": "bsd-3-clause", "language": "c", "size": 95}
{"docstring": "// Remove states from symbols until the correct number of states is used.\n", "func_signal": "static void fse_adjust_freqs(uint16_t *freq, int overrun, int nsymbols)", "code": "{\n  for (int shift = 3; overrun != 0; shift--) {\n    for (int sym = 0; sym < nsymbols; sym++) {\n      if (freq[sym] > 1) {\n        int n = (freq[sym] - 1) >> shift;\n        if (n > overrun)\n          n = overrun;\n        freq[sym] -= n;\n        overrun -= n;\n        if (overrun == 0)\n          break;\n      }\n    }\n  }\n}", "path": "lzfse/src/lzfse_fse.c", "commit_date": "2016-06-19 00:00:00", "repo_name": "lzfse/lzfse", "stars": 1748, "license": "bsd-3-clause", "language": "c", "size": 95}
{"docstring": "// Normalize a table T[NSYMBOLS] of occurrences to FREQ[NSYMBOLS].\n", "func_signal": "void fse_normalize_freq(int nstates, int nsymbols, const uint32_t *__restrict t,\n                        uint16_t *__restrict freq)", "code": "{\n  uint32_t s_count = 0;\n  int remaining = nstates; // must be signed; this may become < 0\n  int max_freq = 0;\n  int max_freq_sym = 0;\n  int shift = __builtin_clz(nstates) - 1;\n  uint32_t highprec_step;\n\n  // Compute the total number of symbol occurrences\n  for (int i = 0; i < nsymbols; i++)\n    s_count += t[i];\n\n  if (s_count == 0)\n    highprec_step = 0; // no symbols used\n  else\n    highprec_step = ((uint32_t)1 << 31) / s_count;\n\n  for (int i = 0; i < nsymbols; i++) {\n\n    // Rescale the occurrence count to get the normalized frequency.\n    // Round up if the fractional part is >= 0.5; otherwise round down.\n    // For efficiency, we do this calculation using integer arithmetic.\n    int f = (((t[i] * highprec_step) >> shift) + 1) >> 1;\n\n    // If a symbol was used, it must be given a nonzero normalized frequency.\n    if (f == 0 && t[i] != 0)\n      f = 1;\n\n    freq[i] = f;\n    remaining -= f;\n\n    // Remember the maximum frequency and which symbol had it.\n    if (f > max_freq) {\n      max_freq = f;\n      max_freq_sym = i;\n    }\n  }\n\n  // If there remain states to be assigned, then just assign them to the most\n  // frequent symbol.  Alternatively, if we assigned more states than were\n  // actually available, then either remove states from the most frequent symbol\n  // (for minor overruns) or use the slower adjustment algorithm (for major\n  // overruns).\n  if (-remaining < (max_freq >> 2)) {\n    freq[max_freq_sym] += remaining;\n  } else {\n    fse_adjust_freqs(freq, -remaining, nsymbols);\n  }\n}", "path": "lzfse/src/lzfse_fse.c", "commit_date": "2016-06-19 00:00:00", "repo_name": "lzfse/lzfse", "stars": 1748, "license": "bsd-3-clause", "language": "c", "size": 95}
{"docstring": "/*\n** Return a copy of the linked list of Window objects passed as the\n** second argument.\n*/\n", "func_signal": "SQLITE_PRIVATE Window *sqlite3WindowListDup(sqlite3 *db, Window *p)", "code": "{\n  Window *pWin;\n  Window *pRet = 0;\n  Window **pp = &pRet;\n\n  for(pWin=p; pWin; pWin=pWin->pNextWin){\n    *pp = sqlite3WindowDup(db, 0, pWin);\n    if( *pp==0 ) break;\n    pp = &((*pp)->pNextWin);\n  }\n\n  return pRet;\n}", "path": "rediSQL/redisql_lib/src/CDeps/SQLite/sqlite3.c", "commit_date": "2019-01-09 00:00:00", "repo_name": "RedBeardLab/rediSQL", "stars": 1538, "license": "other", "language": "c", "size": 20542}
{"docstring": "/*\n** Fill the Index.aiRowEst[] array with default information - information\n** to be used when we have not run the ANALYZE command.\n**\n** aiRowEst[0] is supposed to contain the number of elements in the index.\n** Since we do not know, guess 1 million.  aiRowEst[1] is an estimate of the\n** number of rows in the table that match any particular value of the\n** first column of the index.  aiRowEst[2] is an estimate of the number\n** of rows that match any particular combination of the first 2 columns\n** of the index.  And so forth.  It must always be the case that\n*\n**           aiRowEst[N]<=aiRowEst[N-1]\n**           aiRowEst[N]>=1\n**\n** Apart from that, we have little to go on besides intuition as to\n** how aiRowEst[] should be initialized.  The numbers generated here\n** are based on typical values found in actual indices.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3DefaultRowEst(Index *pIdx)", "code": "{\n  /*                10,  9,  8,  7,  6 */\n  LogEst aVal[] = { 33, 32, 30, 28, 26 };\n  LogEst *a = pIdx->aiRowLogEst;\n  int nCopy = MIN(ArraySize(aVal), pIdx->nKeyCol);\n  int i;\n\n  /* Indexes with default row estimates should not have stat1 data */\n  assert( !pIdx->hasStat1 );\n\n  /* Set the first entry (number of rows in the index) to the estimated \n  ** number of rows in the table, or half the number of rows in the table\n  ** for a partial index.   But do not let the estimate drop below 10. */\n  a[0] = pIdx->pTable->nRowLogEst;\n  if( pIdx->pPartIdxWhere!=0 ) a[0] -= 10;  assert( 10==sqlite3LogEst(2) );\n  if( a[0]<33 ) a[0] = 33;                  assert( 33==sqlite3LogEst(10) );\n\n  /* Estimate that a[1] is 10, a[2] is 9, a[3] is 8, a[4] is 7, a[5] is\n  ** 6 and each subsequent value (if any) is 5.  */\n  memcpy(&a[1], aVal, nCopy*sizeof(LogEst));\n  for(i=nCopy+1; i<=pIdx->nKeyCol; i++){\n    a[i] = 23;                    assert( 23==sqlite3LogEst(5) );\n  }\n\n  assert( 0==sqlite3LogEst(1) );\n  if( IsUniqueIndex(pIdx) ) a[pIdx->nKeyCol] = 0;\n}", "path": "rediSQL/redisql_lib/src/CDeps/SQLite/sqlite3.c", "commit_date": "2019-01-09 00:00:00", "repo_name": "RedBeardLab/rediSQL", "stars": 1538, "license": "other", "language": "c", "size": 20542}
{"docstring": "/* porter rule condition: (m > 1 and (*S or *T)) */\n", "func_signal": "static int fts5Porter_MGt1_and_S_or_T(char *zStem, int nStem)", "code": "{\n  assert( nStem>0 );\n  return (zStem[nStem-1]=='s' || zStem[nStem-1]=='t') \n      && fts5Porter_MGt1(zStem, nStem);\n}", "path": "rediSQL/redisql_lib/src/CDeps/SQLite/sqlite3.c", "commit_date": "2019-01-09 00:00:00", "repo_name": "RedBeardLab/rediSQL", "stars": 1538, "license": "other", "language": "c", "size": 20542}
{"docstring": "/*\n** If this routine is invoked from within an xColumn method of a virtual\n** table, then it returns true if and only if the the call is during an\n** UPDATE operation and the value of the column will not be modified\n** by the UPDATE.\n**\n** If this routine is called from any context other than within the\n** xColumn method of a virtual table, then the return value is meaningless\n** and arbitrary.\n**\n** Virtual table implements might use this routine to optimize their\n** performance by substituting a NULL result, or some other light-weight\n** value, as a signal to the xUpdate routine that the column is unchanged.\n*/\n", "func_signal": "SQLITE_API int sqlite3_vtab_nochange(sqlite3_context *p)", "code": "{\n  assert( p );\n  return sqlite3_value_nochange(p->pOut);\n}", "path": "rediSQL/redisql_lib/src/CDeps/SQLite/sqlite3.c", "commit_date": "2019-01-09 00:00:00", "repo_name": "RedBeardLab/rediSQL", "stars": 1538, "license": "other", "language": "c", "size": 20542}
{"docstring": "/*\n** Return the mutex associated with a database connection.\n*/\n", "func_signal": "SQLITE_API sqlite3_mutex *sqlite3_db_mutex(sqlite3 *db)", "code": "{\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( !sqlite3SafetyCheckOk(db) ){\n    (void)SQLITE_MISUSE_BKPT;\n    return 0;\n  }\n#endif\n  return db->mutex;\n}", "path": "rediSQL/redisql_lib/src/CDeps/SQLite/sqlite3.c", "commit_date": "2019-01-09 00:00:00", "repo_name": "RedBeardLab/rediSQL", "stars": 1538, "license": "other", "language": "c", "size": 20542}
{"docstring": "/*\n** idxNum:\n**\n**     0     schema=main, full table scan\n**     1     schema=main, pgno=?1\n**     2     schema=?1, full table scan\n**     3     schema=?1, pgno=?2\n*/\n", "func_signal": "static int dbpageBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo)", "code": "{\n  int i;\n  int iPlan = 0;\n\n  /* If there is a schema= constraint, it must be honored.  Report a\n  ** ridiculously large estimated cost if the schema= constraint is\n  ** unavailable\n  */\n  for(i=0; i<pIdxInfo->nConstraint; i++){\n    struct sqlite3_index_constraint *p = &pIdxInfo->aConstraint[i];\n    if( p->iColumn!=DBPAGE_COLUMN_SCHEMA ) continue;\n    if( p->op!=SQLITE_INDEX_CONSTRAINT_EQ ) continue;\n    if( !p->usable ){\n      /* No solution. */\n      return SQLITE_CONSTRAINT;\n    }\n    iPlan = 2;\n    pIdxInfo->aConstraintUsage[i].argvIndex = 1;\n    pIdxInfo->aConstraintUsage[i].omit = 1;\n    break;\n  }\n\n  /* If we reach this point, it means that either there is no schema=\n  ** constraint (in which case we use the \"main\" schema) or else the\n  ** schema constraint was accepted.  Lower the estimated cost accordingly\n  */\n  pIdxInfo->estimatedCost = 1.0e6;\n\n  /* Check for constraints against pgno */\n  for(i=0; i<pIdxInfo->nConstraint; i++){\n    struct sqlite3_index_constraint *p = &pIdxInfo->aConstraint[i];\n    if( p->usable && p->iColumn<=0 && p->op==SQLITE_INDEX_CONSTRAINT_EQ ){\n      pIdxInfo->estimatedRows = 1;\n      pIdxInfo->idxFlags = SQLITE_INDEX_SCAN_UNIQUE;\n      pIdxInfo->estimatedCost = 1.0;\n      pIdxInfo->aConstraintUsage[i].argvIndex = iPlan ? 2 : 1;\n      pIdxInfo->aConstraintUsage[i].omit = 1;\n      iPlan |= 1;\n      break;\n    }\n  }\n  pIdxInfo->idxNum = iPlan;\n\n  if( pIdxInfo->nOrderBy>=1\n   && pIdxInfo->aOrderBy[0].iColumn<=0\n   && pIdxInfo->aOrderBy[0].desc==0\n  ){\n    pIdxInfo->orderByConsumed = 1;\n  }\n  return SQLITE_OK;\n}", "path": "rediSQL/redisql_lib/src/CDeps/SQLite/sqlite3.c", "commit_date": "2019-01-09 00:00:00", "repo_name": "RedBeardLab/rediSQL", "stars": 1538, "license": "other", "language": "c", "size": 20542}
{"docstring": "/*\n** The xSavepoint() method.\n**\n** Flush the contents of the pending-terms table to disk.\n*/\n", "func_signal": "static int fts3SavepointMethod(sqlite3_vtab *pVtab, int iSavepoint)", "code": "{\n  int rc = SQLITE_OK;\n  UNUSED_PARAMETER(iSavepoint);\n  assert( ((Fts3Table *)pVtab)->inTransaction );\n  assert( ((Fts3Table *)pVtab)->mxSavepoint <= iSavepoint );\n  TESTONLY( ((Fts3Table *)pVtab)->mxSavepoint = iSavepoint );\n  if( ((Fts3Table *)pVtab)->bIgnoreSavepoint==0 ){\n    rc = fts3SyncMethod(pVtab);\n  }\n  return rc;\n}", "path": "rediSQL/redisql_lib/src/CDeps/SQLite/sqlite3.c", "commit_date": "2019-01-09 00:00:00", "repo_name": "RedBeardLab/rediSQL", "stars": 1538, "license": "other", "language": "c", "size": 20542}
{"docstring": "/*\n** The first argument is a file-handle open on a temporary file. The file\n** is guaranteed to be nByte bytes or smaller in size. This function\n** attempts to extend the file to nByte bytes in size and to ensure that\n** the VFS has memory mapped it.\n**\n** Whether or not the file does end up memory mapped of course depends on\n** the specific VFS implementation.\n*/\n", "func_signal": "static void vdbeSorterExtendFile(sqlite3 *db, sqlite3_file *pFd, i64 nByte)", "code": "{\n  if( nByte<=(i64)(db->nMaxSorterMmap) && pFd->pMethods->iVersion>=3 ){\n    void *p = 0;\n    int chunksize = 4*1024;\n    sqlite3OsFileControlHint(pFd, SQLITE_FCNTL_CHUNK_SIZE, &chunksize);\n    sqlite3OsFileControlHint(pFd, SQLITE_FCNTL_SIZE_HINT, &nByte);\n    sqlite3OsFetch(pFd, 0, (int)nByte, &p);\n    sqlite3OsUnfetch(pFd, 0, p);\n  }\n}", "path": "rediSQL/redisql_lib/src/CDeps/SQLite/sqlite3.c", "commit_date": "2019-01-09 00:00:00", "repo_name": "RedBeardLab/rediSQL", "stars": 1538, "license": "other", "language": "c", "size": 20542}
{"docstring": "/*\n** Return 1 if database is read-only or 0 if read/write.  Return -1 if\n** no such database exists.\n*/\n", "func_signal": "SQLITE_API int sqlite3_db_readonly(sqlite3 *db, const char *zDbName)", "code": "{\n  Btree *pBt;\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( !sqlite3SafetyCheckOk(db) ){\n    (void)SQLITE_MISUSE_BKPT;\n    return -1;\n  }\n#endif\n  pBt = sqlite3DbNameToBtree(db, zDbName);\n  return pBt ? sqlite3BtreeIsReadonly(pBt) : -1;\n}", "path": "rediSQL/redisql_lib/src/CDeps/SQLite/sqlite3.c", "commit_date": "2019-01-09 00:00:00", "repo_name": "RedBeardLab/rediSQL", "stars": 1538, "license": "other", "language": "c", "size": 20542}
{"docstring": "/*\n** Given a page number of a regular database page, return the page\n** number for the pointer-map page that contains the entry for the\n** input page number.\n**\n** Return 0 (not a valid page) for pgno==1 since there is\n** no pointer map associated with page 1.  The integrity_check logic\n** requires that ptrmapPageno(*,1)!=1.\n*/\n", "func_signal": "static Pgno ptrmapPageno(BtShared *pBt, Pgno pgno)", "code": "{\n  int nPagesPerMapPage;\n  Pgno iPtrMap, ret;\n  assert( sqlite3_mutex_held(pBt->mutex) );\n  if( pgno<2 ) return 0;\n  nPagesPerMapPage = (pBt->usableSize/5)+1;\n  iPtrMap = (pgno-2)/nPagesPerMapPage;\n  ret = (iPtrMap*nPagesPerMapPage) + 2; \n  if( ret==PENDING_BYTE_PAGE(pBt) ){\n    ret++;\n  }\n  return ret;\n}", "path": "rediSQL/redisql_lib/src/CDeps/SQLite/sqlite3.c", "commit_date": "2019-01-09 00:00:00", "repo_name": "RedBeardLab/rediSQL", "stars": 1538, "license": "other", "language": "c", "size": 20542}
{"docstring": "/*\n** Close the blob handle at p->pSegments, if it is open. See comments above\n** the sqlite3Fts3ReadBlock() function for details.\n*/\n", "func_signal": "SQLITE_PRIVATE void sqlite3Fts3SegmentsClose(Fts3Table *p)", "code": "{\n  sqlite3_blob_close(p->pSegments);\n  p->pSegments = 0;\n}", "path": "rediSQL/redisql_lib/src/CDeps/SQLite/sqlite3.c", "commit_date": "2019-01-09 00:00:00", "repo_name": "RedBeardLab/rediSQL", "stars": 1538, "license": "other", "language": "c", "size": 20542}
{"docstring": "/*\n** Allocate an RbuState object and load the contents of the rbu_state \n** table into it. Return a pointer to the new object. It is the \n** responsibility of the caller to eventually free the object using\n** sqlite3_free().\n**\n** If an error occurs, leave an error code and message in the rbu handle\n** and return NULL.\n*/\n", "func_signal": "static RbuState *rbuLoadState(sqlite3rbu *p)", "code": "{\n  RbuState *pRet = 0;\n  sqlite3_stmt *pStmt = 0;\n  int rc;\n  int rc2;\n\n  pRet = (RbuState*)rbuMalloc(p, sizeof(RbuState));\n  if( pRet==0 ) return 0;\n\n  rc = prepareFreeAndCollectError(p->dbRbu, &pStmt, &p->zErrmsg, \n      sqlite3_mprintf(\"SELECT k, v FROM %s.rbu_state\", p->zStateDb)\n  );\n  while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){\n    switch( sqlite3_column_int(pStmt, 0) ){\n      case RBU_STATE_STAGE:\n        pRet->eStage = sqlite3_column_int(pStmt, 1);\n        if( pRet->eStage!=RBU_STAGE_OAL\n         && pRet->eStage!=RBU_STAGE_MOVE\n         && pRet->eStage!=RBU_STAGE_CKPT\n        ){\n          p->rc = SQLITE_CORRUPT;\n        }\n        break;\n\n      case RBU_STATE_TBL:\n        pRet->zTbl = rbuStrndup((char*)sqlite3_column_text(pStmt, 1), &rc);\n        break;\n\n      case RBU_STATE_IDX:\n        pRet->zIdx = rbuStrndup((char*)sqlite3_column_text(pStmt, 1), &rc);\n        break;\n\n      case RBU_STATE_ROW:\n        pRet->nRow = sqlite3_column_int(pStmt, 1);\n        break;\n\n      case RBU_STATE_PROGRESS:\n        pRet->nProgress = sqlite3_column_int64(pStmt, 1);\n        break;\n\n      case RBU_STATE_CKPT:\n        pRet->iWalCksum = sqlite3_column_int64(pStmt, 1);\n        break;\n\n      case RBU_STATE_COOKIE:\n        pRet->iCookie = (u32)sqlite3_column_int64(pStmt, 1);\n        break;\n\n      case RBU_STATE_OALSZ:\n        pRet->iOalSz = (u32)sqlite3_column_int64(pStmt, 1);\n        break;\n\n      case RBU_STATE_PHASEONESTEP:\n        pRet->nPhaseOneStep = sqlite3_column_int64(pStmt, 1);\n        break;\n\n      case RBU_STATE_DATATBL:\n        pRet->zDataTbl = rbuStrndup((char*)sqlite3_column_text(pStmt, 1), &rc);\n        break;\n\n      default:\n        rc = SQLITE_CORRUPT;\n        break;\n    }\n  }\n  rc2 = sqlite3_finalize(pStmt);\n  if( rc==SQLITE_OK ) rc = rc2;\n\n  p->rc = rc;\n  return pRet;\n}", "path": "rediSQL/redisql_lib/src/CDeps/SQLite/sqlite3.c", "commit_date": "2019-01-09 00:00:00", "repo_name": "RedBeardLab/rediSQL", "stars": 1538, "license": "other", "language": "c", "size": 20542}
{"docstring": "/*\n** Allocate a new rowid. This is used for \"external content\" tables when\n** a NULL value is inserted into the rowid column. The new rowid is allocated\n** by inserting a dummy row into the %_docsize table. The dummy will be\n** overwritten later.\n**\n** If the %_docsize table does not exist, SQLITE_MISMATCH is returned. In\n** this case the user is required to provide a rowid explicitly.\n*/\n", "func_signal": "static int fts5StorageNewRowid(Fts5Storage *p, i64 *piRowid)", "code": "{\n  int rc = SQLITE_MISMATCH;\n  if( p->pConfig->bColumnsize ){\n    sqlite3_stmt *pReplace = 0;\n    rc = fts5StorageGetStmt(p, FTS5_STMT_REPLACE_DOCSIZE, &pReplace, 0);\n    if( rc==SQLITE_OK ){\n      sqlite3_bind_null(pReplace, 1);\n      sqlite3_bind_null(pReplace, 2);\n      sqlite3_step(pReplace);\n      rc = sqlite3_reset(pReplace);\n    }\n    if( rc==SQLITE_OK ){\n      *piRowid = sqlite3_last_insert_rowid(p->pConfig->db);\n    }\n  }\n  return rc;\n}", "path": "rediSQL/redisql_lib/src/CDeps/SQLite/sqlite3.c", "commit_date": "2019-01-09 00:00:00", "repo_name": "RedBeardLab/rediSQL", "stars": 1538, "license": "other", "language": "c", "size": 20542}
{"docstring": "/*\n** Return 1 if pMem represents true, and return 0 if pMem represents false.\n** Return the value ifNull if pMem is NULL.  \n*/\n", "func_signal": "SQLITE_PRIVATE int sqlite3VdbeBooleanValue(Mem *pMem, int ifNull)", "code": "{\n  if( pMem->flags & MEM_Int ) return pMem->u.i!=0;\n  if( pMem->flags & MEM_Null ) return ifNull;\n  return sqlite3VdbeRealValue(pMem)!=0.0;\n}", "path": "rediSQL/redisql_lib/src/CDeps/SQLite/sqlite3.c", "commit_date": "2019-01-09 00:00:00", "repo_name": "RedBeardLab/rediSQL", "stars": 1538, "license": "other", "language": "c", "size": 20542}
{"docstring": "/*\n** This method is called to \"rewind\" the stmt_cursor object back\n** to the first row of output.  This method is always called at least\n** once prior to any call to stmtColumn() or stmtRowid() or \n** stmtEof().\n*/\n", "func_signal": "static int stmtFilter(\n  sqlite3_vtab_cursor *pVtabCursor, \n  int idxNum, const char *idxStr,\n  int argc, sqlite3_value **argv\n)", "code": "{\n  stmt_cursor *pCur = (stmt_cursor *)pVtabCursor;\n  pCur->pStmt = 0;\n  pCur->iRowid = 0;\n  return stmtNext(pVtabCursor);\n}", "path": "rediSQL/redisql_lib/src/CDeps/SQLite/sqlite3.c", "commit_date": "2019-01-09 00:00:00", "repo_name": "RedBeardLab/rediSQL", "stars": 1538, "license": "other", "language": "c", "size": 20542}
{"docstring": "/*\n** Convert a UTF-16 string in the native encoding into a UTF-8 string.\n** Memory to hold the UTF-8 string is obtained from sqlite3_malloc and must\n** be freed by the calling function.\n**\n** NULL is returned if there is an allocation error.\n*/\n", "func_signal": "SQLITE_PRIVATE char *sqlite3Utf16to8(sqlite3 *db, const void *z, int nByte, u8 enc)", "code": "{\n  Mem m;\n  memset(&m, 0, sizeof(m));\n  m.db = db;\n  sqlite3VdbeMemSetStr(&m, z, nByte, enc, SQLITE_STATIC);\n  sqlite3VdbeChangeEncoding(&m, SQLITE_UTF8);\n  if( db->mallocFailed ){\n    sqlite3VdbeMemRelease(&m);\n    m.z = 0;\n  }\n  assert( (m.flags & MEM_Term)!=0 || db->mallocFailed );\n  assert( (m.flags & MEM_Str)!=0 || db->mallocFailed );\n  assert( m.z || db->mallocFailed );\n  return m.z;\n}", "path": "rediSQL/redisql_lib/src/CDeps/SQLite/sqlite3.c", "commit_date": "2019-01-09 00:00:00", "repo_name": "RedBeardLab/rediSQL", "stars": 1538, "license": "other", "language": "c", "size": 20542}
{"docstring": "/*\n** Functions to serialize a 16 bit integer, 32 bit real number and\n** 64 bit integer. The value returned is the number of bytes written\n** to the argument buffer (always 2, 4 and 8 respectively).\n*/\n", "func_signal": "static void writeInt16(u8 *p, int i)", "code": "{\n  p[0] = (i>> 8)&0xFF;\n  p[1] = (i>> 0)&0xFF;\n}", "path": "rediSQL/redisql_lib/src/CDeps/SQLite/sqlite3.c", "commit_date": "2019-01-09 00:00:00", "repo_name": "RedBeardLab/rediSQL", "stars": 1538, "license": "other", "language": "c", "size": 20542}
{"docstring": "/*\n** Release a reference to page pPg. pPg must have been returned by an \n** earlier call to pagerAcquireMapPage().\n*/\n", "func_signal": "static void pagerReleaseMapPage(PgHdr *pPg)", "code": "{\n  Pager *pPager = pPg->pPager;\n  pPager->nMmapOut--;\n  pPg->pDirty = pPager->pMmapFreelist;\n  pPager->pMmapFreelist = pPg;\n\n  assert( pPager->fd->pMethods->iVersion>=3 );\n  sqlite3OsUnfetch(pPager->fd, (i64)(pPg->pgno-1)*pPager->pageSize, pPg->pData);\n}", "path": "rediSQL/redisql_lib/src/CDeps/SQLite/sqlite3.c", "commit_date": "2019-01-09 00:00:00", "repo_name": "RedBeardLab/rediSQL", "stars": 1538, "license": "other", "language": "c", "size": 20542}
{"docstring": "/*\n** The zeroblob(N) function returns a zero-filled blob of size N bytes.\n*/\n", "func_signal": "static void zeroblobFunc(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n)", "code": "{\n  i64 n;\n  int rc;\n  assert( argc==1 );\n  UNUSED_PARAMETER(argc);\n  n = sqlite3_value_int64(argv[0]);\n  if( n<0 ) n = 0;\n  rc = sqlite3_result_zeroblob64(context, n); /* IMP: R-00293-64994 */\n  if( rc ){\n    sqlite3_result_error_code(context, rc);\n  }\n}", "path": "rediSQL/redisql_lib/src/CDeps/SQLite/sqlite3.c", "commit_date": "2019-01-09 00:00:00", "repo_name": "RedBeardLab/rediSQL", "stars": 1538, "license": "other", "language": "c", "size": 20542}
{"docstring": "/*\n** xSetOutputs callback used by detail=none tables.\n*/\n", "func_signal": "static void fts5IterSetOutputs_None(Fts5Iter *pIter, Fts5SegIter *pSeg)", "code": "{\n  assert( pIter->pIndex->pConfig->eDetail==FTS5_DETAIL_NONE );\n  pIter->base.iRowid = pSeg->iRowid;\n  pIter->base.nData = pSeg->nPos;\n}", "path": "rediSQL/redisql_lib/src/CDeps/SQLite/sqlite3.c", "commit_date": "2019-01-09 00:00:00", "repo_name": "RedBeardLab/rediSQL", "stars": 1538, "license": "other", "language": "c", "size": 20542}
{"docstring": "/* Copy len chars from string, collapsing chars escaped with a backslash. */\n", "func_signal": "static char *\ncopy_arg(const char *src, size_t len)", "code": "{\n    const char *src_end = src + len;\n    char *copy, *dst;\n    debug_decl(copy_arg, SUDOERS_DEBUG_UTIL);\n\n    if ((copy = malloc(len + 1)) != NULL) {\n\tfor (dst = copy; src < src_end; ) {\n\t    if (*src == '\\\\') {\n\t\tsrc++;\n\t\tcontinue;\n\t    }\n\t    *dst++ = *src++;\n\t}\n\t*dst = '\\0';\n    }\n\n    debug_return_ptr(copy);\n}", "path": "sudo/plugins/sudoers/editor.c", "commit_date": "2020-11-12 00:00:00", "repo_name": "sudo-project/sudo", "stars": 1059, "license": "other", "language": "c", "size": 197004}
{"docstring": "/*\n * Store the name of the tty to which the process is attached in name.\n * Returns name on success and NULL on failure, setting errno.\n */\n", "func_signal": "char *\nget_process_ttyname(char *name, size_t namelen)", "code": "{\n    const char path[] = \"/proc/self/stat\";\n    char *cp, buf[1024];\n    char *ret = NULL;\n    int serrno = errno;\n    ssize_t nread;\n    int fd;\n    debug_decl(get_process_ttyname, SUDO_DEBUG_UTIL);\n\n    /*\n     * Try to determine the tty from tty_nr in /proc/self/stat.\n     * Ignore /proc/self/stat if it contains embedded NUL bytes.\n     */\n    if ((fd = open(path, O_RDONLY | O_NOFOLLOW)) != -1) {\n\tcp = buf;\n\twhile ((nread = read(fd, cp, buf + sizeof(buf) - cp)) != 0) {\n\t    if (nread == -1) {\n\t\tif (errno == EAGAIN || errno == EINTR)\n\t\t    continue;\n\t\tbreak;\n\t    }\n\t    cp += nread;\n\t    if (cp >= buf + sizeof(buf))\n\t\tbreak;\n\t}\n\tif (nread == 0 && memchr(buf, '\\0', cp - buf) == NULL) {\n\t    /*\n\t     * Field 7 is the tty dev (0 if no tty).\n\t     * Since the process name at field 2 \"(comm)\" may include\n\t     * whitespace (including newlines), start at the last ')' found.\n\t     */\n\t    *cp = '\\0';\n\t    cp = strrchr(buf, ')');\n\t    if (cp != NULL) {\n\t\tchar *ep = cp;\n\t\tconst char *errstr;\n\t\tint field = 1;\n\n\t\twhile (*++ep != '\\0') {\n\t\t    if (*ep == ' ') {\n\t\t\t*ep = '\\0';\n\t\t\tif (++field == 7) {\n\t\t\t    int tty_nr = sudo_strtonum(cp, INT_MIN, INT_MAX,\n\t\t\t\t&errstr);\n\t\t\t    if (errstr) {\n\t\t\t\tsudo_debug_printf(SUDO_DEBUG_ERROR|SUDO_DEBUG_LINENO,\n\t\t\t\t    \"%s: tty device %s: %s\", path, cp, errstr);\n\t\t\t    }\n\t\t\t    if (tty_nr != 0) {\n\t\t\t\t/*\n\t\t\t\t * Avoid sign extension when assigning tdev.\n\t\t\t\t * tty_nr in /proc/self/stat is printed as a\n\t\t\t\t * signed int but the actual device number is an\n\t\t\t\t * unsigned int and dev_t is unsigned long long.\n\t\t\t\t */\n\t\t\t\tdev_t tdev = (unsigned int)tty_nr;\n\t\t\t\terrno = serrno;\n\t\t\t\tret = sudo_ttyname_dev(tdev, name, namelen);\n\t\t\t\tgoto done;\n\t\t\t    }\n\t\t\t    break;\n\t\t\t}\n\t\t\tcp = ep + 1;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    errno = ENOENT;\n\ndone:\n    if (fd != -1)\n\tclose(fd);\n    if (ret == NULL)\n\tsudo_debug_printf(SUDO_DEBUG_WARN|SUDO_DEBUG_LINENO|SUDO_DEBUG_ERRNO,\n\t    \"unable to resolve tty via %s\", path);\n\n    debug_return_str(ret);\n}", "path": "sudo/src/ttyname.c", "commit_date": "2020-09-25 00:00:00", "repo_name": "sudo-project/sudo", "stars": 1059, "license": "other", "language": "c", "size": 197004}
{"docstring": "/* -- see zlib.h -- */\n", "func_signal": "int ZEXPORTVA gzvprintf(gzFile file, const char *format, va_list va)", "code": "{\n    int len;\n    unsigned left;\n    char *next;\n    gz_statep state;\n    z_streamp strm;\n\n    /* get internal structure */\n    if (file == NULL)\n        return Z_STREAM_ERROR;\n    state = (gz_statep)file;\n    strm = &(state->strm);\n\n    /* check that we're writing and that there's no error */\n    if (state->mode != GZ_WRITE || state->err != Z_OK)\n        return Z_STREAM_ERROR;\n\n    /* make sure we have some buffer space */\n    if (state->size == 0 && gz_init(state) == -1)\n        return state->err;\n\n    /* check for seek request */\n    if (state->seek) {\n        state->seek = 0;\n        if (gz_zero(state, state->skip) == -1)\n            return state->err;\n    }\n\n    /* do the printf() into the input buffer, put length in len -- the input\n       buffer is double-sized just for this function, so there is guaranteed to\n       be state->size bytes available after the current contents */\n    if (strm->avail_in == 0)\n        strm->next_in = state->in;\n    next = (char *)(state->in + (strm->next_in - state->in) + strm->avail_in);\n    next[state->size - 1] = 0;\n#ifdef NO_vsnprintf\n#  ifdef HAS_vsprintf_void\n    (void)vsprintf(next, format, va);\n    for (len = 0; len < state->size; len++)\n        if (next[len] == 0) break;\n#  else\n    len = vsprintf(next, format, va);\n#  endif\n#else\n#  ifdef HAS_vsnprintf_void\n    (void)vsnprintf(next, state->size, format, va);\n    len = strlen(next);\n#  else\n    len = vsnprintf(next, state->size, format, va);\n#  endif\n#endif\n\n    /* check that printf() results fit in buffer */\n    if (len == 0 || (unsigned)len >= state->size || next[state->size - 1] != 0)\n        return 0;\n\n    /* update buffer and position, compress first half if past that */\n    strm->avail_in += (unsigned)len;\n    state->x.pos += len;\n    if (strm->avail_in >= state->size) {\n        left = strm->avail_in - state->size;\n        strm->avail_in = state->size;\n        if (gz_comp(state, Z_NO_FLUSH) == -1)\n            return state->err;\n        memcpy(state->in, state->in + state->size, left);\n        strm->next_in = state->in;\n        strm->avail_in = left;\n    }\n    return len;\n}", "path": "sudo/lib/zlib/gzwrite.c", "commit_date": "2017-01-25 00:00:00", "repo_name": "sudo-project/sudo", "stars": 1059, "license": "other", "language": "c", "size": 197004}
{"docstring": "/*\n * Store the name of the tty to which the process is attached in name.\n * Returns name on success and NULL on failure, setting errno.\n */\n", "func_signal": "char *\nget_process_ttyname(char *name, size_t namelen)", "code": "{\n    char path[PATH_MAX], *ret = NULL;\n    struct psinfo psinfo;\n    ssize_t nread;\n    int fd, serrno = errno;\n    debug_decl(get_process_ttyname, SUDO_DEBUG_UTIL);\n\n    /* Try to determine the tty from pr_ttydev in /proc/pid/psinfo. */\n    (void)snprintf(path, sizeof(path), \"/proc/%u/psinfo\", (unsigned int)getpid());\n    if ((fd = open(path, O_RDONLY, 0)) != -1) {\n\tnread = read(fd, &psinfo, sizeof(psinfo));\n\tclose(fd);\n\tif (nread == (ssize_t)sizeof(psinfo)) {\n\t    dev_t rdev = (dev_t)psinfo.pr_ttydev;\n#if defined(_AIX) && defined(DEVNO64)\n\t    if ((psinfo.pr_ttydev & DEVNO64) && sizeof(dev_t) == 4)\n\t\trdev = makedev(major64(psinfo.pr_ttydev), minor64(psinfo.pr_ttydev));\n#endif\n\t    if (rdev != (dev_t)-1) {\n\t\terrno = serrno;\n\t\tret = sudo_ttyname_dev(rdev, name, namelen);\n\t\tgoto done;\n\t    }\n\t}\n    }\n    errno = ENOENT;\n\ndone:\n    if (ret == NULL)\n\tsudo_debug_printf(SUDO_DEBUG_WARN|SUDO_DEBUG_LINENO|SUDO_DEBUG_ERRNO,\n\t    \"unable to resolve tty via %s\", path);\n\n    debug_return_str(ret);\n}", "path": "sudo/src/ttyname.c", "commit_date": "2020-09-25 00:00:00", "repo_name": "sudo-project/sudo", "stars": 1059, "license": "other", "language": "c", "size": 197004}
{"docstring": "/*\n * Reverse memchr()\n * Find the last occurrence of 'c' in the buffer 's' of size 'n'.\n */\n", "func_signal": "void *\nsudo_memrchr(const void *s, int c, size_t n)", "code": "{\n    const unsigned char *cp;\n\n    if (n != 0) {\n\tcp = (unsigned char *)s + n;\n\tdo {\n\t    if (*(--cp) == (unsigned char)c)\n\t\treturn (void *)cp;\n\t} while (--n != 0);\n    }\n    return (void *)0;\n}", "path": "sudo/lib/util/memrchr.c", "commit_date": "2019-04-29 00:00:00", "repo_name": "sudo-project/sudo", "stars": 1059, "license": "other", "language": "c", "size": 197004}
{"docstring": "/*\n * Determine which editor to use based on the SUDO_EDITOR, VISUAL and\n * EDITOR environment variables as well as the editor path in sudoers.\n * If env_error is true, an editor environment variable that cannot be\n * resolved is an error.\n *\n * Returns the path to be executed on success, else NULL.\n * The caller is responsible for freeing the returned editor path\n * as well as the argument vector.\n */\n", "func_signal": "char *\nfind_editor(int nfiles, char **files, int *argc_out, char ***argv_out,\n     char * const *allowlist, const char **env_editor, bool env_error)", "code": "{\n    char *ev[3], *editor_path = NULL;\n    unsigned int i;\n    debug_decl(find_editor, SUDOERS_DEBUG_UTIL);\n\n    /*\n     * If any of SUDO_EDITOR, VISUAL or EDITOR are set, choose the first one.\n     */\n    *env_editor = NULL;\n    ev[0] = \"SUDO_EDITOR\";\n    ev[1] = \"VISUAL\";\n    ev[2] = \"EDITOR\";\n    for (i = 0; i < nitems(ev); i++) {\n\tchar *editor = getenv(ev[i]);\n\n\tif (editor != NULL && *editor != '\\0') {\n\t    *env_editor = editor;\n\t    editor_path = resolve_editor(editor, strlen(editor),\n\t\tnfiles, files, argc_out, argv_out, allowlist);\n\t    if (editor_path != NULL)\n\t\tbreak;\n\t    if (errno != ENOENT)\n\t\tdebug_return_str(NULL);\n\t}\n    }\n    if (editor_path == NULL) {\n\tconst char *def_editor_end = def_editor + strlen(def_editor);\n\tconst char *cp, *ep;\n\n\tif (env_error && *env_editor != NULL) {\n\t    /* User-specified editor could not be found. */\n\t    debug_return_str(NULL);\n\t}\n\n\t/* def_editor could be a path, split it up, avoiding strtok() */\n\tfor (cp = sudo_strsplit(def_editor, def_editor_end, \":\", &ep);\n\t    cp != NULL; cp = sudo_strsplit(NULL, def_editor_end, \":\", &ep)) {\n\t    editor_path = resolve_editor(cp, (size_t)(ep - cp), nfiles,\n\t\tfiles, argc_out, argv_out, allowlist);\n\t    if (editor_path != NULL)\n\t\tbreak;\n\t    if (errno != ENOENT)\n\t\tdebug_return_str(NULL);\n\t}\n    }\n\n    debug_return_str(editor_path);\n}", "path": "sudo/plugins/sudoers/editor.c", "commit_date": "2020-11-12 00:00:00", "repo_name": "sudo-project/sudo", "stars": 1059, "license": "other", "language": "c", "size": 197004}
{"docstring": "/*\n * Read in /etc/netsvc.conf (like nsswitch.conf on AIX)\n * Returns a tail queue of matches.\n */\n", "func_signal": "struct sudo_nss_list *\nsudo_read_nss(void)", "code": "{\n    FILE *fp;\n    char *cp, *ep, *last, *line = NULL;\n    size_t linesize = 0;\n#ifdef HAVE_SSSD\n    bool saw_sss = false;\n#endif\n    bool saw_files = false;\n    bool saw_ldap = false;\n    bool got_match = false;\n    static struct sudo_nss_list snl = TAILQ_HEAD_INITIALIZER(snl);\n    debug_decl(sudo_read_nss, SUDOERS_DEBUG_NSS);\n\n    if ((fp = fopen(_PATH_NETSVC_CONF, \"r\")) == NULL)\n\tgoto nomatch;\n\n    while (sudo_parseln(&line, &linesize, NULL, fp, 0) != -1) {\n\t/* Skip blank or comment lines */\n\tif (*(cp = line) == '\\0')\n\t    continue;\n\n\t/* Look for a line starting with \"sudoers = \" */\n\tif (strncasecmp(cp, \"sudoers\", 7) != 0)\n\t    continue;\n\tcp += 7;\n\twhile (isspace((unsigned char)*cp))\n\t    cp++;\n\tif (*cp++ != '=')\n\t    continue;\n\n\t/* Parse line */\n\tfor ((cp = strtok_r(cp, \",\", &last)); cp != NULL; (cp = strtok_r(NULL, \",\", &last))) {\n\t    /* Trim leading whitespace. */\n\t    while (isspace((unsigned char)*cp))\n\t\tcp++;\n\n\t    if (!saw_files && strncasecmp(cp, \"files\", 5) == 0 &&\n\t\t(isspace((unsigned char)cp[5]) || cp[5] == '\\0')) {\n\t\tTAILQ_INSERT_TAIL(&snl, &sudo_nss_file, entries);\n\t\tgot_match = saw_files = true;\n\t\tep = &cp[5];\n#ifdef HAVE_LDAP\n\t    } else if (!saw_ldap && strncasecmp(cp, \"ldap\", 4) == 0 &&\n\t\t(isspace((unsigned char)cp[4]) || cp[4] == '\\0')) {\n\t\tTAILQ_INSERT_TAIL(&snl, &sudo_nss_ldap, entries);\n\t\tgot_match = saw_ldap = true;\n\t\tep = &cp[4];\n#endif\n#ifdef HAVE_SSSD\n\t    } else if (!saw_sss && strncasecmp(cp, \"sss\", 3) == 0 &&\n\t\t(isspace((unsigned char)cp[3]) || cp[3] == '\\0')) {\n\t\tTAILQ_INSERT_TAIL(&snl, &sudo_nss_sss, entries);\n\t\tgot_match = saw_sss = true;\n\t\tep = &cp[3];\n#endif\n\t    } else {\n\t\tgot_match = false;\n\t    }\n\n\t    /* check for = auth qualifier */\n\t    if (got_match && *ep) {\n\t\tcp = ep;\n\t\twhile (isspace((unsigned char)*cp) || *cp == '=')\n\t\t    cp++;\n\t\tif (strncasecmp(cp, \"auth\", 4) == 0 &&\n\t\t    (isspace((unsigned char)cp[4]) || cp[4] == '\\0')) {\n\t\t    TAILQ_LAST(&snl, sudo_nss_list)->ret_if_found = true;\n\t\t}\n\t    }\n\t}\n\t/* Only parse the first \"sudoers\" line */\n\tbreak;\n    }\n    fclose(fp);\n\nnomatch:\n    /* Default to files only if no matches */\n    if (TAILQ_EMPTY(&snl))\n\tTAILQ_INSERT_TAIL(&snl, &sudo_nss_file, entries);\n\n    debug_return_ptr(&snl);\n}", "path": "sudo/plugins/sudoers/sudo_nss.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "sudo-project/sudo", "stars": 1059, "license": "other", "language": "c", "size": 197004}
{"docstring": "/*\n * Return a malloc()ed copy of the system hostname, or NULL if \n * malloc() or gethostname() fails.\n */\n", "func_signal": "char *\nsudo_gethostname_v1(void)", "code": "{\n    char *hname;\n    size_t host_name_max;\n\n#ifdef _SC_HOST_NAME_MAX\n    host_name_max = (size_t)sysconf(_SC_HOST_NAME_MAX);\n    if (host_name_max == (size_t)-1)\n#endif\n\thost_name_max = 255;\t/* POSIX and historic BSD */\n\n    hname = malloc(host_name_max + 1);\n    if (hname != NULL) {\n\tif (gethostname(hname, host_name_max + 1) == 0 && *hname != '\\0') {\n\t    /* Old gethostname() may not NUL-terminate if there is no room. */\n\t    hname[host_name_max] = '\\0';\n\t} else {\n\t    free(hname);\n\t    hname = NULL;\n\t}\n    }\n    return hname;\n}", "path": "sudo/lib/util/gethostname.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "sudo-project/sudo", "stars": 1059, "license": "other", "language": "c", "size": 197004}
{"docstring": "/*\n * Verify that path is the right type and not writable by other users.\n */\n", "func_signal": "static int\nsudo_secure_path(const char *path, unsigned int type, uid_t uid, gid_t gid, struct stat *sbp)", "code": "{\n    struct stat sb;\n    int ret = SUDO_PATH_MISSING;\n    debug_decl(sudo_secure_path, SUDO_DEBUG_UTIL);\n\n    if (path != NULL && stat(path, &sb) == 0) {\n\tif ((sb.st_mode & _S_IFMT) != type) {\n\t    ret = SUDO_PATH_BAD_TYPE;\n\t} else if (uid != (uid_t)-1 && sb.st_uid != uid) {\n\t    ret = SUDO_PATH_WRONG_OWNER;\n\t} else if (sb.st_mode & S_IWOTH) {\n\t    ret = SUDO_PATH_WORLD_WRITABLE;\n\t} else if (ISSET(sb.st_mode, S_IWGRP) &&\n\t    (gid == (gid_t)-1 || sb.st_gid != gid)) {\n\t    ret = SUDO_PATH_GROUP_WRITABLE;\n\t} else {\n\t    ret = SUDO_PATH_SECURE;\n\t}\n\tif (sbp)\n\t    (void) memcpy(sbp, &sb, sizeof(struct stat));\n    }\n\n    debug_return_int(ret);\n}", "path": "sudo/lib/util/secure_path.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "sudo-project/sudo", "stars": 1059, "license": "other", "language": "c", "size": 197004}
{"docstring": "/*\n * Store the name of the tty to which the process is attached in name.\n * Returns name on success and NULL on failure, setting errno.\n */\n", "func_signal": "char *\nget_process_ttyname(char *name, size_t namelen)", "code": "{\n    struct sudo_kinfo_proc *ki_proc = NULL;\n    size_t size = sizeof(*ki_proc);\n    int mib[6], rc, serrno = errno;\n    char *ret = NULL;\n    debug_decl(get_process_ttyname, SUDO_DEBUG_UTIL);\n\n    /*\n     * Lookup controlling tty for this process via sysctl.\n     * This will work even if std{in,out,err} are redirected.\n     */\n    mib[0] = CTL_KERN;\n    mib[1] = SUDO_KERN_PROC;\n    mib[2] = KERN_PROC_PID;\n    mib[3] = (int)getpid();\n    mib[4] = sizeof(*ki_proc);\n    mib[5] = 1;\n    do {\n\tstruct sudo_kinfo_proc *kp;\n\n\tsize += size / 10;\n\tif ((kp = realloc(ki_proc, size)) == NULL) {\n\t    rc = -1;\n\t    break;\t\t/* really out of memory. */\n\t}\n\tki_proc = kp;\n\trc = sysctl(mib, sudo_kp_namelen, ki_proc, &size, NULL, 0);\n    } while (rc == -1 && errno == ENOMEM);\n    errno = ENOENT;\n    if (rc != -1) {\n\tif ((dev_t)ki_proc->sudo_kp_tdev != (dev_t)-1) {\n\t    errno = serrno;\n\t    ret = sudo_ttyname_dev(ki_proc->sudo_kp_tdev, name, namelen);\n\t    if (ret == NULL) {\n\t\tsudo_debug_printf(SUDO_DEBUG_WARN|SUDO_DEBUG_LINENO|SUDO_DEBUG_ERRNO,\n\t\t    \"unable to map device number %u to name\",\n\t\t    ki_proc->sudo_kp_tdev);\n\t    }\n\t}\n    } else {\n\tsudo_debug_printf(SUDO_DEBUG_WARN|SUDO_DEBUG_LINENO|SUDO_DEBUG_ERRNO,\n\t    \"unable to resolve tty via KERN_PROC\");\n    }\n    free(ki_proc);\n\n    debug_return_str(ret);\n}", "path": "sudo/src/ttyname.c", "commit_date": "2020-09-25 00:00:00", "repo_name": "sudo-project/sudo", "stars": 1059, "license": "other", "language": "c", "size": 197004}
{"docstring": "/*\n * Simple test driver for sudo_parseln().\n * Behaves similarly to \"cat -n\" but with comment removal\n * and line continuation.\n */\n", "func_signal": "int\nmain(int argc, char *argv[])", "code": "{\n    unsigned int lineno = 0;\n    size_t linesize = 0;\n    char *line = NULL;\n\n    initprogname(argc > 0 ? argv[0] : \"parseln_test\");\n\n    while (sudo_parseln(&line, &linesize, &lineno, stdin, 0) != -1)\n\tprintf(\"%6u\\t%s\\n\", lineno, line);\n    free(line);\n    exit(EXIT_SUCCESS);\n}", "path": "sudo/lib/util/regress/sudo_parseln/parseln_test.c", "commit_date": "2020-08-12 00:00:00", "repo_name": "sudo-project/sudo", "stars": 1059, "license": "other", "language": "c", "size": 197004}
{"docstring": "/* portably return maximum value for an int (when limits.h presumed not\n   available) -- we need to do this to cover cases where 2's complement not\n   used, since C standard permits 1's complement and sign-bit representations,\n   otherwise we could just use ((unsigned)-1) >> 1 */\n", "func_signal": "unsigned ZLIB_INTERNAL gz_intmax()", "code": "{\n    unsigned p, q;\n\n    p = 1;\n    do {\n        q = p;\n        p <<= 1;\n        p++;\n    } while (p > q);\n    return q >> 1;\n}", "path": "sudo/lib/zlib/gzlib.c", "commit_date": "2017-01-25 00:00:00", "repo_name": "sudo-project/sudo", "stars": 1059, "license": "other", "language": "c", "size": 197004}
{"docstring": "/*\n * Parse a timestamp in Generalized Time format as per RFC4517.\n * E.g. yyyymmddHHMMSS.FZ or yyyymmddHHMMSS.F[+-]TZOFF\n * where minutes, seconds and fraction are optional.\n * Returns the time in Unix time format or -1 on error.\n */\n", "func_signal": "time_t\nparse_gentime(const char *timestr)", "code": "{\n    char tcopy[sizeof(\"yyyymmddHHMMSS.F\")];\n    const char *cp;\n    time_t result;\n    struct tm tm;\n    size_t len;\n    int items, tzoff = 0;\n    bool islocal = false;\n    debug_decl(parse_gentime, SUDOERS_DEBUG_PARSER);\n\n    /* Make a copy of the time without time zone for easy parsing. */\n    len = strspn(timestr, \"0123456789.,\");\n    if (len >= sizeof(tcopy)) {\n\tsudo_debug_printf(SUDO_DEBUG_ERROR|SUDO_DEBUG_LINENO,\n\t    \"unable to parse general time string %s\", timestr);\n\tdebug_return_time_t(-1);\n    }\n    memcpy(tcopy, timestr, len);\n    tcopy[len] = '\\0';\n\n    /* Parse general time, ignoring the timezone for now. */\n    memset(&tm, 0, sizeof(tm));\n    items = sscanf(tcopy, \"%4d%2d%2d%2d%2d%2d\", &tm.tm_year, &tm.tm_mon,\n\t&tm.tm_mday, &tm.tm_hour, &tm.tm_min, &tm.tm_sec);\n    if (items == EOF || items < 4) {\n\tsudo_debug_printf(SUDO_DEBUG_ERROR|SUDO_DEBUG_LINENO,\n\t    \"only parsed %d items in general time string %s\", items, timestr); \n\tdebug_return_time_t(-1);\n    }\n    cp = timestr + ((items + 1) * 2);\n\n    /* Parse optional fractional hours/minute/second if present. */\n    if ((cp[0] == '.' || cp[0] == ',') && isdigit((unsigned char)cp[1])) {\n\tint frac = cp[1] - '0';\n\tswitch (items) {\n\tcase 4:\n\t    /* convert fractional hour -> minutes */\n\t    tm.tm_min += 60 / 10 * frac;\n\t    break;\n\tcase 5:\n\t    /* convert fractional minute -> seconds */\n\t    tm.tm_sec += 60 / 10 * frac;\n\t    break;\n\tcase 6:\n\t    /* ignore fractional second */\n\t    break;\n\t}\n\tcp += 2;\t/* skip over radix and fraction */\n    }\n\n    switch (*cp) {\n    case '-':\n    case '+': {\n\tint hour = 0, min = 0;\n\n\t/* No DST */\n\ttm.tm_isdst = 0;\n\t/* parse time zone offset */\n\titems = sscanf(cp + 1, \"%2d%2d\", &hour, &min);\n\tif (items == EOF || items < 1) {\n\t    sudo_debug_printf(SUDO_DEBUG_ERROR|SUDO_DEBUG_LINENO,\n\t\t\"unable to parse time zone offset in %s, items %d\",\n\t\ttimestr, items);\n\t    debug_return_time_t(-1);\n\t}\n\tif (*cp == '-')\n\t    tzoff = -((hour * 60) + min) * 60;\n\telse\n\t    tzoff = ((hour * 60) + min) * 60;\n\tcp += 1 + (items * 2);\n\tbreak;\n    }\n    case 'Z':\n\t/* GMT/UTC, no DST */\n\ttm.tm_isdst = 0;\n\tcp++;\n\tbreak;\n    case '\\0':\n\t/* no zone specified, use local time */\n\ttm.tm_isdst = -1;\n\tislocal = true;\n\tbreak;\n    default:\n\tsudo_debug_printf(SUDO_DEBUG_ERROR|SUDO_DEBUG_LINENO,\n\t    \"unable to parse general time string %s\", timestr);\n\tdebug_return_time_t(-1);\n    }\n    if (*cp != '\\0') {\n\tsudo_debug_printf(SUDO_DEBUG_ERROR|SUDO_DEBUG_LINENO,\n\t    \"trailing garbage in general time string %s\", timestr);\n\tdebug_return_time_t(-1);\n    }\n\n    /* Adjust from Generalized Time to struct tm */\n    tm.tm_year -= 1900;\n    tm.tm_mon--;\n\n    result = mktime(&tm);\n    if (result != -1) {\n\tif (!islocal) {\n\t    /* Not local time, convert to GMT */\n\t    result += get_gmtoff(&result);\n\t    /* Adjust time based on supplied GMT offset. */\n\t    result -= tzoff;\n\t}\n    }\n\n    debug_return_time_t(result);\n}", "path": "sudo/plugins/sudoers/gentime.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "sudo-project/sudo", "stars": 1059, "license": "other", "language": "c", "size": 197004}
{"docstring": "/*\n * Store the name of the tty to which the process is attached in name.\n * Returns name on success and NULL on failure, setting errno.\n */\n", "func_signal": "char *\nget_process_ttyname(char *name, size_t namelen)", "code": "{\n    struct pst_status pst;\n    char *ret = NULL;\n    int rc, serrno = errno;\n    debug_decl(get_process_ttyname, SUDO_DEBUG_UTIL);\n\n    /*\n     * Determine the tty from psdev in struct pst_status.\n     * EOVERFLOW is not a fatal error for the fields we use.\n     * See the \"EOVERFLOW Error\" section of pstat_getvminfo(3).\n     */\n    rc = pstat_getproc(&pst, sizeof(pst), 0, getpid());\n    if (rc != -1 || errno == EOVERFLOW) {\n\tif (pst.pst_term.psd_major != -1 && pst.pst_term.psd_minor != -1) {\n\t    errno = serrno;\n\t    ret = sudo_ttyname_dev(makedev(pst.pst_term.psd_major,\n\t\tpst.pst_term.psd_minor), name, namelen);\n\t    goto done;\n\t}\n    }\n    errno = ENOENT;\n\ndone:\n    if (ret == NULL)\n\tsudo_debug_printf(SUDO_DEBUG_WARN|SUDO_DEBUG_LINENO|SUDO_DEBUG_ERRNO,\n\t    \"unable to resolve tty via pstat\");\n\n    debug_return_str(ret);\n}", "path": "sudo/src/ttyname.c", "commit_date": "2020-09-25 00:00:00", "repo_name": "sudo-project/sudo", "stars": 1059, "license": "other", "language": "c", "size": 197004}
{"docstring": "/*\n * Non-nsswitch.conf version with hard-coded order.\n */\n", "func_signal": "struct sudo_nss_list *\nsudo_read_nss(void)", "code": "{\n    static struct sudo_nss_list snl = TAILQ_HEAD_INITIALIZER(snl);\n    debug_decl(sudo_read_nss, SUDOERS_DEBUG_NSS);\n\n#  ifdef HAVE_SSSD\n    TAILQ_INSERT_TAIL(&snl, &sudo_nss_sss, entries);\n#  endif\n#  ifdef HAVE_LDAP\n    TAILQ_INSERT_TAIL(&snl, &sudo_nss_ldap, entries);\n#  endif\n    TAILQ_INSERT_TAIL(&snl, &sudo_nss_file, entries);\n\n    debug_return_ptr(&snl);\n}", "path": "sudo/plugins/sudoers/sudo_nss.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "sudo-project/sudo", "stars": 1059, "license": "other", "language": "c", "size": 197004}
{"docstring": "/* HAVE_LDAP && _PATH_NSSWITCH_CONF */\n", "func_signal": "bool\nsudo_nss_can_continue(struct sudo_nss *nss, int match)", "code": "{\n    debug_decl(sudo_nss_should_continue, SUDOERS_DEBUG_NSS);\n\n    /* Handle [NOTFOUND=return] */\n    if (nss->ret_if_notfound && match == UNSPEC)\n\tdebug_return_bool(false);\n\n    /* Handle [SUCCESS=return] */\n    if (nss->ret_if_found && match != UNSPEC)\n\tdebug_return_bool(false);\n\n    debug_return_bool(true);\n}", "path": "sudo/plugins/sudoers/sudo_nss.c", "commit_date": "2020-05-18 00:00:00", "repo_name": "sudo-project/sudo", "stars": 1059, "license": "other", "language": "c", "size": 197004}
{"docstring": "/*\n * Store the name of the tty to which the process is attached in name.\n * Returns name on success and NULL on failure, setting errno.\n */\n", "func_signal": "char *\nget_process_ttyname(char *name, size_t namelen)", "code": "{\n    char *tty;\n    debug_decl(get_process_ttyname, SUDO_DEBUG_UTIL);\n\n    if ((tty = ttyname(STDIN_FILENO)) == NULL) {\n\tif ((tty = ttyname(STDOUT_FILENO)) == NULL)\n\t    tty = ttyname(STDERR_FILENO);\n    }\n    if (tty != NULL) {\n\tif (strlcpy(name, tty, namelen) < namelen)\n\t    debug_return_str(name);\n\terrno = ERANGE;\n\tsudo_debug_printf(SUDO_DEBUG_WARN|SUDO_DEBUG_LINENO|SUDO_DEBUG_ERRNO,\n\t    \"unable to store tty from ttyname\");\n    } else {\n\tsudo_debug_printf(SUDO_DEBUG_WARN|SUDO_DEBUG_LINENO|SUDO_DEBUG_ERRNO,\n\t    \"unable to resolve tty via ttyname\");\n\terrno = ENOENT;\n    }\n\n    debug_return_str(NULL);\n}", "path": "sudo/src/ttyname.c", "commit_date": "2020-09-25 00:00:00", "repo_name": "sudo-project/sudo", "stars": 1059, "license": "other", "language": "c", "size": 197004}
{"docstring": "/*\n * Exit codes defined in sudo_exec.h:\n *  SESH_SUCCESS (0)         ... successful operation\n *  SESH_ERR_FAILURE (1)     ... unspecified error\n *  SESH_ERR_INVALID (30)    ... invalid -e arg value\n *  SESH_ERR_BAD_PATHS (31)  ... odd number of paths\n *  SESH_ERR_NO_FILES (32)   ... copy error, no files copied\n *  SESH_ERR_SOME_FILES (33) ... copy error, no files copied\n */\n", "func_signal": "int\nmain(int argc, char *argv[], char *envp[])", "code": "{\n    int ret;\n    debug_decl(main, SUDO_DEBUG_MAIN);\n\n    initprogname(argc > 0 ? argv[0] : \"sesh\");\n\n    setlocale(LC_ALL, \"\");\n    bindtextdomain(PACKAGE_NAME, LOCALEDIR);\n    textdomain(PACKAGE_NAME);\n\n    if (argc < 2)\n\tsudo_fatalx(\"%s\", U_(\"requires at least one argument\"));\n\n    /* Read sudo.conf and initialize the debug subsystem. */\n    if (sudo_conf_read(NULL, SUDO_CONF_DEBUG) == -1)\n\texit(EXIT_FAILURE);\n    sudo_debug_register(getprogname(), NULL, NULL,\n\tsudo_conf_debug_files(getprogname()));\n\n    if (strcmp(argv[1], \"-e\") == 0) {\n\tret = sesh_sudoedit(argc, argv);\n    } else {\n\tbool login_shell, noexec = false;\n\tchar *cp, *cmnd;\n\tint fd = -1;\n\n\t/* If the first char of argv[0] is '-', we are running a login shell. */\n\tlogin_shell = argv[0][0] == '-';\n\n\t/* If argv[0] ends in -noexec, pass the flag to sudo_execve() */\n\tif ((cp = strrchr(argv[0], '-')) != NULL && cp != argv[0])\n\t    noexec = strcmp(cp, \"-noexec\") == 0;\n\n\t/* If argv[1] is --execfd=%d, extract the fd to exec with. */\n\tif (strncmp(argv[1], \"--execfd=\", 9) == 0) {\n\t    const char *errstr;\n\n\t    cp = argv[1] + 9;\n\t    fd = sudo_strtonum(cp, 0, INT_MAX, &errstr);\n\t    if (errstr != NULL)\n\t\tsudo_fatalx(U_(\"invalid file descriptor number: %s\"), cp);\n\t    argv++;\n\t    argc--;\n\t}\n\n\t/* Shift argv and make a copy of the command to execute. */\n\targv++;\n\targc--;\n\tif ((cmnd = strdup(argv[0])) == NULL)\n\t    sudo_fatalx(U_(\"%s: %s\"), __func__, U_(\"unable to allocate memory\"));\n\n\t/* If invoked as a login shell, modify argv[0] accordingly. */\n\tif (login_shell) {\n\t    if ((cp = strrchr(argv[0], '/')) == NULL)\n\t\tsudo_fatal(U_(\"unable to run %s as a login shell\"), argv[0]);\n\t    *cp = '-';\n\t    argv[0] = cp;\n\t}\n\tsudo_execve(fd, cmnd, argv, envp, noexec);\n\tsudo_warn(U_(\"unable to execute %s\"), cmnd);\n\tret = SESH_ERR_FAILURE;\n    }\n    sudo_debug_exit_int(__func__, __FILE__, __LINE__, sudo_debug_subsys, ret);\n    _exit(ret);\n}", "path": "sudo/src/sesh.c", "commit_date": "2020-08-12 00:00:00", "repo_name": "sudo-project/sudo", "stars": 1059, "license": "other", "language": "c", "size": 197004}
{"docstring": "/*\n * Search for the specified editor in the user's PATH, checking\n * the result against allowlist if non-NULL.  An argument vector\n * suitable for execve() is allocated and stored in argv_out.\n * If nfiles is non-zero, files[] is added to the end of argv_out.\n *\n * Returns the path to be executed on success, else NULL.\n * The caller is responsible for freeing the returned editor path\n * as well as the argument vector.\n */\n", "func_signal": "static char *\nresolve_editor(const char *ed, size_t edlen, int nfiles, char **files,\n    int *argc_out, char ***argv_out, char * const *allowlist)", "code": "{\n    char **nargv = NULL, *editor = NULL, *editor_path = NULL;\n    const char *cp, *ep, *tmp;\n    const char *edend = ed + edlen;\n    struct stat user_editor_sb;\n    int nargc;\n    debug_decl(resolve_editor, SUDOERS_DEBUG_UTIL);\n\n    /*\n     * Split editor into an argument vector, including files to edit.\n     * The EDITOR and VISUAL environment variables may contain command\n     * line args so look for those and alloc space for them too.\n     */\n    cp = wordsplit(ed, edend, &ep);\n    if (cp == NULL)\n\tdebug_return_str(NULL);\n    editor = copy_arg(cp, ep - cp);\n    if (editor == NULL)\n\tgoto oom;\n\n    /* If we can't find the editor in the user's PATH, give up. */\n    if (find_path(editor, &editor_path, &user_editor_sb, getenv(\"PATH\"), NULL,\n\t    0, allowlist) != FOUND) {\n\tfree(editor);\n\terrno = ENOENT;\n\tdebug_return_str(NULL);\n    }\n\n    /* Count rest of arguments and allocate editor argv. */\n    for (nargc = 1, tmp = ep; wordsplit(NULL, edend, &tmp) != NULL; )\n\tnargc++;\n    if (nfiles != 0)\n\tnargc += nfiles + 1;\n    nargv = reallocarray(NULL, nargc + 1, sizeof(char *));\n    if (nargv == NULL)\n\tgoto oom;\n\n    /* Fill in editor argv (assumes files[] is NULL-terminated). */\n    nargv[0] = editor;\n    editor = NULL;\n    for (nargc = 1; (cp = wordsplit(NULL, edend, &ep)) != NULL; nargc++) {\n\t/* Copy string, collapsing chars escaped with a backslash. */\n\tnargv[nargc] = copy_arg(cp, ep - cp);\n\tif (nargv[nargc] == NULL)\n\t    goto oom;\n    }\n    if (nfiles != 0) {\n\tnargv[nargc++] = \"--\";\n\twhile (nfiles--)\n\t    nargv[nargc++] = *files++;\n    }\n    nargv[nargc] = NULL;\n\n    *argc_out = nargc;\n    *argv_out = nargv;\n    debug_return_str(editor_path);\noom:\n    sudo_warnx(U_(\"%s: %s\"), __func__, U_(\"unable to allocate memory\"));\n    free(editor);\n    free(editor_path);\n    if (nargv != NULL) {\n\twhile (nargc--)\n\t    free(nargv[nargc]);\n\tfree(nargv);\n    }\n    debug_return_str(NULL);\n}", "path": "sudo/plugins/sudoers/editor.c", "commit_date": "2020-11-12 00:00:00", "repo_name": "sudo-project/sudo", "stars": 1059, "license": "other", "language": "c", "size": 197004}
{"docstring": "/*\n * Non-destructive word-split that handles single and double quotes and\n * escaped white space.  Quotes are only recognized at the start of a word.\n * They are treated as normal characters inside a word.\n */\n", "func_signal": "static const char *\nwordsplit(const char *str, const char *endstr, const char **last)", "code": "{\n    const char *cp;\n    debug_decl(wordsplit, SUDO_DEBUG_UTIL);\n\n    /* If no str specified, use last ptr (if any). */\n    if (str == NULL) {\n\tstr = *last;\n\t/* Consume end quote if present. */\n\tif (*str == '\"' || *str == '\\'')\n\t    str++;\n    }\n\n    /* Skip leading white space characters. */\n    while (str < endstr && (*str == ' ' || *str == '\\t'))\n\tstr++;\n\n    /* Empty string? */\n    if (str >= endstr) {\n\t*last = endstr;\n\tdebug_return_ptr(NULL);\n    }\n\n    /* If word is quoted, skip to end quote and return. */\n    if (*str == '\"' || *str == '\\'') {\n\tconst char *endquote = memchr(str + 1, *str, endstr - str);\n\tif (endquote != NULL) {\n\t    *last = endquote;\n\t    debug_return_const_ptr(str + 1);\n\t}\n    }\n\n    /* Scan str until we encounter white space. */\n    for (cp = str; cp < endstr; cp++) {\n\tif (*cp == '\\\\') {\n\t    /* quoted char, do not interpret */\n\t    cp++;\n\t    continue;\n\t}\n\tif (*cp == ' ' || *cp == '\\t') {\n\t    /* end of word */\n\t    break;\n\t}\n    }\n    *last = cp;\n    debug_return_const_ptr(str);\n}", "path": "sudo/plugins/sudoers/editor.c", "commit_date": "2020-11-12 00:00:00", "repo_name": "sudo-project/sudo", "stars": 1059, "license": "other", "language": "c", "size": 197004}
{"docstring": "/*\n * Checks a single display mode settings against user's preferences.\n */\n", "func_signal": "static GLboolean fghCheckDisplayMode( int width, int height, int depth, int refresh )", "code": "{\n    /* The desired values should be stored in fgState structure... */\n    return ( width == fgState.GameModeSize.X ) &&\n           ( height == fgState.GameModeSize.Y ) &&\n           ( depth == fgState.GameModeDepth ) &&\n           ( refresh == fgState.GameModeRefresh );\n}", "path": "box2d.js/Box2D_v2.2.1/freeglut/freeglut_gamemode.c", "commit_date": "2014-08-15 00:00:00", "repo_name": "kripken/box2d.js", "stars": 1294, "license": "None", "language": "c", "size": 11745}
{"docstring": "/*\n * Returns information concerning the freeglut game mode\n */\n", "func_signal": "int FGAPIENTRY glutGameModeGet( GLenum eWhat )", "code": "{\n    FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutGameModeGet\" );\n\n    switch( eWhat )\n    {\n    case GLUT_GAME_MODE_ACTIVE:\n        return !!fgStructure.GameModeWindow;\n\n    case GLUT_GAME_MODE_POSSIBLE:\n        return fghChangeDisplayMode( GL_TRUE );\n\n    case GLUT_GAME_MODE_WIDTH:\n        return fgState.GameModeSize.X;\n\n    case GLUT_GAME_MODE_HEIGHT:\n        return fgState.GameModeSize.Y;\n\n    case GLUT_GAME_MODE_PIXEL_DEPTH:\n        return fgState.GameModeDepth;\n\n    case GLUT_GAME_MODE_REFRESH_RATE:\n        return fgState.GameModeRefresh;\n\n    case GLUT_GAME_MODE_DISPLAY_CHANGED:\n        /*\n         * This is true if the game mode has been activated successfully..\n         */\n        return !!fgStructure.GameModeWindow;\n    }\n\n    fgWarning( \"Unknown gamemode get: %d\", eWhat );\n    return -1;\n}", "path": "box2d.js/Box2D_v2.2.1/freeglut/freeglut_gamemode.c", "commit_date": "2014-08-15 00:00:00", "repo_name": "kripken/box2d.js", "stars": 1294, "license": "None", "language": "c", "size": 11745}
{"docstring": "/*\n * Mark appropriate window to be displayed\n */\n", "func_signal": "void FGAPIENTRY glutPostWindowRedisplay( int windowID )", "code": "{\n    SFG_Window* window;\n\n    FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutPostWindowRedisplay\" );\n    window = fgWindowByID( windowID );\n    freeglut_return_if_fail( window );\n    window->State.Redisplay = GL_TRUE;\n}", "path": "box2d.js/Box2D_v2.2.1/freeglut/freeglut_display.c", "commit_date": "2014-08-15 00:00:00", "repo_name": "kripken/box2d.js", "stars": 1294, "license": "None", "language": "c", "size": 11745}
{"docstring": "/*\n * Sets the game mode display string\n */\n", "func_signal": "void FGAPIENTRY glutGameModeString( const char* string )", "code": "{\n    int width = 640, height = 480, depth = 16, refresh = 72;\n\n    FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutGameModeString\" );\n\n    /*\n     * This one seems a bit easier than glutInitDisplayString. The bad thing\n     * about it that I was unable to find the game mode string definition, so\n     * that I assumed it is: \"[width]x[height]:[depth]@[refresh rate]\", which\n     * appears in all GLUT game mode programs I have seen to date.\n     */\n    if( sscanf( string, \"%ix%i:%i@%i\", &width, &height, &depth, &refresh ) !=\n        4 )\n        if( sscanf( string, \"%ix%i:%i\", &width, &height, &depth ) != 3 )\n            if( sscanf( string, \"%ix%i@%i\", &width, &height, &refresh ) != 3 )\n                if( sscanf( string, \"%ix%i\", &width, &height ) != 2 )\n                    if( sscanf( string, \":%i@%i\", &depth, &refresh ) != 2 )\n                        if( sscanf( string, \":%i\", &depth ) != 1 )\n                            if( sscanf( string, \"@%i\", &refresh ) != 1 )\n                                fgWarning(\n                                    \"unable to parse game mode string `%s'\",\n                                    string\n                                );\n\n    /* Hopefully it worked, and if not, we still have the default values */\n    fgState.GameModeSize.X  = width;\n    fgState.GameModeSize.Y  = height;\n    fgState.GameModeDepth   = depth;\n    fgState.GameModeRefresh = refresh;\n}", "path": "box2d.js/Box2D_v2.2.1/freeglut/freeglut_gamemode.c", "commit_date": "2014-08-15 00:00:00", "repo_name": "kripken/box2d.js", "stars": 1294, "license": "None", "language": "c", "size": 11745}
{"docstring": "/*\n * Returns the width in pixels of a font's character\n */\n", "func_signal": "int FGAPIENTRY glutBitmapWidth( void* fontID, int character )", "code": "{\n    SFG_Font* font;\n    FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutBitmapWidth\" );\n    font = fghFontByID( fontID );\n    freeglut_return_val_if_fail( character > 0 && character < 256, 0 );\n    freeglut_return_val_if_fail( font, 0 );\n    return *( font->Characters[ character ] );\n}", "path": "box2d.js/Box2D_v2.2.1/freeglut/freeglut_font.c", "commit_date": "2014-08-15 00:00:00", "repo_name": "kripken/box2d.js", "stars": 1294, "license": "None", "language": "c", "size": 11745}
{"docstring": "// Return raw time\n//\n", "func_signal": "static uint64_t getRawTime(void)", "code": "{\n#if defined(CLOCK_MONOTONIC)\n    if (_glfw.x11.timer.monotonic)\n    {\n        struct timespec ts;\n\n        clock_gettime(CLOCK_MONOTONIC, &ts);\n        return (uint64_t) ts.tv_sec * (uint64_t) 1000000000 + (uint64_t) ts.tv_nsec;\n    }\n    else\n#endif\n    {\n        struct timeval tv;\n\n        gettimeofday(&tv, NULL);\n        return (uint64_t) tv.tv_sec * (uint64_t) 1000000 + (uint64_t) tv.tv_usec;\n    }\n}", "path": "box2d.js/Box2D_v2.3.1/glfw/x11_time.c", "commit_date": "2014-12-30 00:00:00", "repo_name": "kripken/box2d.js", "stars": 1294, "license": "None", "language": "c", "size": 11745}
{"docstring": "/*\n * Matches a font ID with a SFG_StrokeFont structure pointer.\n * This was changed to match the GLUT header style.\n */\n", "func_signal": "static SFG_StrokeFont* fghStrokeByID( void* font )", "code": "{\n    if( font == GLUT_STROKE_ROMAN      )\n        return &fgStrokeRoman;\n    if( font == GLUT_STROKE_MONO_ROMAN )\n        return &fgStrokeMonoRoman;\n\n    fgWarning( \"stroke font 0x%08x not found\", font );\n    return 0;\n}", "path": "box2d.js/Box2D_v2.2.1/freeglut/freeglut_font.c", "commit_date": "2014-08-15 00:00:00", "repo_name": "kripken/box2d.js", "stars": 1294, "license": "None", "language": "c", "size": 11745}
{"docstring": "/*\n * Matches a font ID with a SFG_Font structure pointer.\n * This was changed to match the GLUT header style.\n */\n", "func_signal": "static SFG_Font* fghFontByID( void* font )", "code": "{\n    if( font == GLUT_BITMAP_8_BY_13        )\n        return &fgFontFixed8x13;\n    if( font == GLUT_BITMAP_9_BY_15        )\n        return &fgFontFixed9x15;\n    if( font == GLUT_BITMAP_HELVETICA_10   )\n        return &fgFontHelvetica10;\n    if( font == GLUT_BITMAP_HELVETICA_12   )\n        return &fgFontHelvetica12;\n    if( font == GLUT_BITMAP_HELVETICA_18   )\n        return &fgFontHelvetica18;\n    if( font == GLUT_BITMAP_TIMES_ROMAN_10 )\n        return &fgFontTimesRoman10;\n    if( font == GLUT_BITMAP_TIMES_ROMAN_24 )\n        return &fgFontTimesRoman24;\n\n    fgWarning( \"font 0x%08x not found\", font );\n    return 0;\n}", "path": "box2d.js/Box2D_v2.2.1/freeglut/freeglut_font.c", "commit_date": "2014-08-15 00:00:00", "repo_name": "kripken/box2d.js", "stars": 1294, "license": "None", "language": "c", "size": 11745}
{"docstring": "/*\n * Draw a bitmap character\n */\n", "func_signal": "void FGAPIENTRY glutBitmapCharacter( void* fontID, int character )", "code": "{\n    const GLubyte* face;\n    SFG_Font* font;\n    FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutBitmapCharacter\" );\n    font = fghFontByID( fontID );\n    freeglut_return_if_fail( ( character >= 1 )&&( character < 256 ) );\n    freeglut_return_if_fail( font );\n\n    /*\n     * Find the character we want to draw (???)\n     */\n    face = font->Characters[ character ];\n\n    glPushClientAttrib( GL_CLIENT_PIXEL_STORE_BIT );\n    glPixelStorei( GL_UNPACK_SWAP_BYTES,  GL_FALSE );\n    glPixelStorei( GL_UNPACK_LSB_FIRST,   GL_FALSE );\n    glPixelStorei( GL_UNPACK_ROW_LENGTH,  0        );\n    glPixelStorei( GL_UNPACK_SKIP_ROWS,   0        );\n    glPixelStorei( GL_UNPACK_SKIP_PIXELS, 0        );\n    glPixelStorei( GL_UNPACK_ALIGNMENT,   1        );\n    glBitmap(\n        face[ 0 ], font->Height,      /* The bitmap's width and height  */\n        font->xorig, font->yorig,     /* The origin in the font glyph   */\n        ( float )( face[ 0 ] ), 0.0,  /* The raster advance -- inc. x,y */\n        ( face + 1 )                  /* The packed bitmap data...      */\n    );\n    glPopClientAttrib( );\n}", "path": "box2d.js/Box2D_v2.2.1/freeglut/freeglut_font.c", "commit_date": "2014-08-15 00:00:00", "repo_name": "kripken/box2d.js", "stars": 1294, "license": "None", "language": "c", "size": 11745}
{"docstring": "/*\n * Swaps the buffers for the current window (if any)\n */\n", "func_signal": "void FGAPIENTRY glutSwapBuffers( void )", "code": "{\n    FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutSwapBuffers\" );\n    FREEGLUT_EXIT_IF_NO_WINDOW ( \"glutSwapBuffers\" );\n\n    /*\n     * \"glXSwapBuffers\" already performs an implicit call to \"glFlush\". What\n     * about \"SwapBuffers\"?\n     */\n    glFlush( );\n    if( ! fgStructure.CurrentWindow->Window.DoubleBuffered )\n        return;\n\n#if TARGET_HOST_POSIX_X11\n    glXSwapBuffers( fgDisplay.Display, fgStructure.CurrentWindow->Window.Handle );\n#elif TARGET_HOST_MS_WINDOWS\n    SwapBuffers( fgStructure.CurrentWindow->Window.Device );\n#endif\n\n    /* GLUT_FPS env var support */\n    if( fgState.FPSInterval )\n    {\n        GLint t = glutGet( GLUT_ELAPSED_TIME );\n        fgState.SwapCount++;\n        if( fgState.SwapTime == 0 )\n            fgState.SwapTime = t;\n        else if( t - fgState.SwapTime > fgState.FPSInterval )\n        {\n            float time = 0.001f * ( t - fgState.SwapTime );\n            float fps = ( float )fgState.SwapCount / time;\n            fprintf( stderr,\n                     \"freeglut: %d frames in %.2f seconds = %.2f FPS\\n\",\n                     fgState.SwapCount, time, fps );\n            fgState.SwapTime = t;\n            fgState.SwapCount = 0;\n        }\n    }\n}", "path": "box2d.js/Box2D_v2.2.1/freeglut/freeglut_display.c", "commit_date": "2014-08-15 00:00:00", "repo_name": "kripken/box2d.js", "stars": 1294, "license": "None", "language": "c", "size": 11745}
{"docstring": "/*\n * Returns the height of a stroke font\n */\n", "func_signal": "GLfloat FGAPIENTRY glutStrokeHeight( void* fontID )", "code": "{\n    SFG_StrokeFont* font;\n    FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutStrokeHeight\" );\n    font = fghStrokeByID( fontID );\n    freeglut_return_val_if_fail( font, 0.0 );\n    return font->Height;\n}", "path": "box2d.js/Box2D_v2.2.1/freeglut/freeglut_font.c", "commit_date": "2014-08-15 00:00:00", "repo_name": "kripken/box2d.js", "stars": 1294, "license": "None", "language": "c", "size": 11745}
{"docstring": "/*\n * Returns the height of a bitmap font\n */\n", "func_signal": "int FGAPIENTRY glutBitmapHeight( void* fontID )", "code": "{\n    SFG_Font* font;\n    FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutBitmapHeight\" );\n    font = fghFontByID( fontID );\n    freeglut_return_val_if_fail( font, 0 );\n    return font->Height;\n}", "path": "box2d.js/Box2D_v2.2.1/freeglut/freeglut_font.c", "commit_date": "2014-08-15 00:00:00", "repo_name": "kripken/box2d.js", "stars": 1294, "license": "None", "language": "c", "size": 11745}
{"docstring": "//////////////////////////////////////////////////////////////////////////\n//////                       GLFW platform API                      //////\n//////////////////////////////////////////////////////////////////////////\n", "func_signal": "double _glfwPlatformGetTime(void)", "code": "{\n    return (double) (getRawTime() - _glfw.x11.timer.base) *\n        _glfw.x11.timer.resolution;\n}", "path": "box2d.js/Box2D_v2.3.1/glfw/x11_time.c", "commit_date": "2014-12-30 00:00:00", "repo_name": "kripken/box2d.js", "stars": 1294, "license": "None", "language": "c", "size": 11745}
{"docstring": "/*\n * Return the width in pixels of a stroke character\n */\n", "func_signal": "int FGAPIENTRY glutStrokeWidth( void* fontID, int character )", "code": "{\n    const SFG_StrokeChar *schar;\n    SFG_StrokeFont* font;\n    FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutStrokeWidth\" );\n    font = fghStrokeByID( fontID );\n    freeglut_return_val_if_fail( ( character >= 0 ) &&\n                                 ( character < font->Quantity ),\n                                 0\n    );\n    freeglut_return_val_if_fail( font, 0 );\n    schar = font->Characters[ character ];\n    freeglut_return_val_if_fail( schar, 0 );\n\n    return ( int )( schar->Right + 0.5 );\n}", "path": "box2d.js/Box2D_v2.2.1/freeglut/freeglut_font.c", "commit_date": "2014-08-15 00:00:00", "repo_name": "kripken/box2d.js", "stars": 1294, "license": "None", "language": "c", "size": 11745}
{"docstring": "// Initialise timer\n//\n", "func_signal": "void _glfwInitTimer(void)", "code": "{\n#if defined(CLOCK_MONOTONIC)\n    struct timespec ts;\n\n    if (clock_gettime(CLOCK_MONOTONIC, &ts) == 0)\n    {\n        _glfw.x11.timer.monotonic = GL_TRUE;\n        _glfw.x11.timer.resolution = 1e-9;\n    }\n    else\n#endif\n    {\n        _glfw.x11.timer.resolution = 1e-6;\n    }\n\n    _glfw.x11.timer.base = getRawTime();\n}", "path": "box2d.js/Box2D_v2.3.1/glfw/x11_time.c", "commit_date": "2014-12-30 00:00:00", "repo_name": "kripken/box2d.js", "stars": 1294, "license": "None", "language": "c", "size": 11745}
{"docstring": "/*\n * Restores the previously remembered visual settings\n */\n", "func_signal": "static void fghRestoreState( void )", "code": "{\n#if TARGET_HOST_POSIX_X11\n\n#   ifdef X_XF86VidModeGetAllModeLines\n    /* Restore the remembered pointer position: */\n    XWarpPointer(\n        fgDisplay.Display, None, fgDisplay.RootWindow, 0, 0, 0, 0,\n        fgDisplay.DisplayPointerX, fgDisplay.DisplayPointerY\n    );\n\n    /*\n     * This highly depends on the XFree86 extensions,\n     * not approved as X Consortium standards\n     */\n\n    if( fgDisplay.DisplayModeValid )\n    {\n        XF86VidModeModeInfo** displayModes;\n        int i, displayModesCount;\n\n        if( !XF86VidModeGetAllModeLines(\n                 fgDisplay.Display,\n                 fgDisplay.Screen,\n                 &displayModesCount,\n                 &displayModes ) )\n        {\n            fgWarning( \"XF86VidModeGetAllModeLines failed\" );\n            return;\n        }\n\n\n        /*\n         * Check every of the modes looking for one that matches our demands.\n         * If we find one, switch to it and restore the remembered viewport.\n         */\n        for( i = 0; i < displayModesCount; i++ )\n        {\n            if(displayModes[ i ]->hdisplay == fgDisplay.DisplayMode.hdisplay &&\n               displayModes[ i ]->vdisplay == fgDisplay.DisplayMode.vdisplay &&\n               displayModes[ i ]->dotclock == fgDisplay.DisplayModeClock )\n            {\n                if( !XF86VidModeSwitchToMode(\n                         fgDisplay.Display,\n                         fgDisplay.Screen,\n                         displayModes[ i ] ) )\n                {\n                    fgWarning( \"XF86VidModeSwitchToMode failed\" );\n                    break;\n                }\n\n                if( !XF86VidModeSetViewPort(\n                         fgDisplay.Display,\n                         fgDisplay.Screen,\n                         fgDisplay.DisplayViewPortX,\n                         fgDisplay.DisplayViewPortY ) )\n                    fgWarning( \"XF86VidModeSetViewPort failed\" );\n\n\n                /*\n                 * For the case this would be the last X11 call the application\n                 * calls exit() we've to flush the X11 output queue to have the\n                 * commands sent to the X server before the application exits.\n                 */\n                XFlush( fgDisplay.Display );\n\n                break;\n            }\n        }\n        XFree( displayModes );\n    }\n\n#   else\n    /*\n     * XXX warning fghRestoreState: missing XFree86 video mode extensions,\n     * XXX game mode will not change screen resolution when activated\n     */\n#   endif\n\n#elif TARGET_HOST_MS_WINDOWS\n\n    /* Restore the previously rememebered desktop display settings */\n    ChangeDisplaySettings( &fgDisplay.DisplayMode, 0 );\n\n#endif\n}", "path": "box2d.js/Box2D_v2.2.1/freeglut/freeglut_gamemode.c", "commit_date": "2014-08-15 00:00:00", "repo_name": "kripken/box2d.js", "stars": 1294, "license": "None", "language": "c", "size": 11745}
{"docstring": "/*\n * Changes the current display mode to match user's settings\n */\n", "func_signal": "static GLboolean fghChangeDisplayMode( GLboolean haveToTest )", "code": "{\n    GLboolean success = GL_FALSE;\n#if TARGET_HOST_POSIX_X11\n\n    /*\n     * This highly depends on the XFree86 extensions,\n     * not approved as X Consortium standards\n     */\n#   ifdef X_XF86VidModeGetAllModeLines\n\n    /*\n     * This is also used by applcations which check modes by calling\n     * glutGameModeGet(GLUT_GAME_MODE_POSSIBLE), so allow the check:\n     */\n    if( haveToTest || fgDisplay.DisplayModeValid )\n    {\n        XF86VidModeModeInfo** displayModes;\n        int i, displayModesCount;\n\n        if( !XF86VidModeGetAllModeLines(\n                 fgDisplay.Display,\n                 fgDisplay.Screen,\n                 &displayModesCount,\n                 &displayModes ) )\n        {\n            fgWarning( \"XF86VidModeGetAllModeLines failed\" );\n            return success;\n        }\n\n\n        /*\n         * Check every of the modes looking for one that matches our demands,\n         * ignoring the refresh rate if no exact match could be found.\n         */\n        i = fghCheckDisplayModes( GL_TRUE, displayModesCount, displayModes );\n        if( i < 0 ) {\n            i = fghCheckDisplayModes( GL_FALSE, displayModesCount, displayModes );\n        }\n        success = ( i < 0 ) ? GL_FALSE : GL_TRUE;\n\n        if( !haveToTest && success ) {\n            if( !XF86VidModeSwitchToMode(\n                     fgDisplay.Display,\n                     fgDisplay.Screen,\n                     displayModes[ i ] ) )\n                fgWarning( \"XF86VidModeSwitchToMode failed\" );\n        }\n\n        XFree( displayModes );\n    }\n\n#   else\n\n    /*\n     * XXX warning fghChangeDisplayMode: missing XFree86 video mode extensions,\n     * XXX game mode will not change screen resolution when activated\n     */\n    success = GL_TRUE;\n\n#   endif\n\n#elif TARGET_HOST_MS_WINDOWS\n\n    DEVMODE  devMode;\n    char *fggmstr = NULL;\n\n    success = GL_FALSE;\n\n    EnumDisplaySettings( NULL, -1, &devMode ); \n    devMode.dmFields |= DM_PELSWIDTH | DM_PELSHEIGHT | DM_BITSPERPEL | DM_DISPLAYFREQUENCY;\n\n    devMode.dmPelsWidth  = fgState.GameModeSize.X;\n    devMode.dmPelsHeight = fgState.GameModeSize.Y;\n    devMode.dmBitsPerPel = fgState.GameModeDepth;\n    devMode.dmDisplayFrequency = fgState.GameModeRefresh;\n    devMode.dmFields = DM_PELSWIDTH | DM_PELSHEIGHT | DM_BITSPERPEL | DM_DISPLAYFREQUENCY;\n\n    switch ( ChangeDisplaySettingsEx(NULL, &devMode, NULL, haveToTest ? CDS_TEST : CDS_FULLSCREEN , NULL) )\n    {\n    case DISP_CHANGE_SUCCESSFUL:\n        success = GL_TRUE;\n\n        /* update vars in case if windows switched to proper mode */\n        EnumDisplaySettings( NULL, FREEGLUT_ENUM_CURRENT_SETTINGS, &devMode );\n        fgState.GameModeSize.X  = devMode.dmPelsWidth;        \n        fgState.GameModeSize.Y  = devMode.dmPelsHeight;\n        fgState.GameModeDepth   = devMode.dmBitsPerPel;\n        fgState.GameModeRefresh = devMode.dmDisplayFrequency;\n\t\tbreak;\n    case DISP_CHANGE_RESTART:\n        fggmstr = \"The computer must be restarted for the graphics mode to work.\";\n        break;\n    case DISP_CHANGE_BADFLAGS:\n        fggmstr = \"An invalid set of flags was passed in.\";\n        break;\n    case DISP_CHANGE_BADPARAM:\n        fggmstr = \"An invalid parameter was passed in. This can include an invalid flag or combination of flags.\";\n        break;\n    case DISP_CHANGE_FAILED:\n        fggmstr = \"The display driver failed the specified graphics mode.\";\n        break;\n    case DISP_CHANGE_BADMODE:\n        fggmstr = \"The graphics mode is not supported.\";\n        break;\n    default:\n        fggmstr = \"Unknown error in graphics mode???\"; /* dunno if it is possible,MSDN does not mention any other error */\n        break;\n    }\n\n    if ( !success )\n        fgWarning(fggmstr); /* I'd rather get info whats going on in my program than wonder about */\n                            /* magic happenings behind my back, its lib for devels at last ;) */\n#endif\n\n    return success;\n}", "path": "box2d.js/Box2D_v2.2.1/freeglut/freeglut_gamemode.c", "commit_date": "2014-08-15 00:00:00", "repo_name": "kripken/box2d.js", "stars": 1294, "license": "None", "language": "c", "size": 11745}
{"docstring": "/*\n * Return the width of a string drawn using a bitmap font\n */\n", "func_signal": "int FGAPIENTRY glutBitmapLength( void* fontID, const unsigned char* string )", "code": "{\n    unsigned char c;\n    int length = 0, this_line_length = 0;\n    SFG_Font* font;\n    FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutBitmapLength\" );\n    font = fghFontByID( fontID );\n    freeglut_return_val_if_fail( font, 0 );\n    if ( !string || ! *string )\n        return 0;\n\n    while( ( c = *string++) )\n    {\n        if( c != '\\n' )/* Not an EOL, increment length of line */\n            this_line_length += *( font->Characters[ c ]);\n        else  /* EOL; reset the length of this line */\n        {\n            if( length < this_line_length )\n                length = this_line_length;\n            this_line_length = 0;\n        }\n    }\n    if ( length < this_line_length )\n        length = this_line_length;\n\n    return length;\n}", "path": "box2d.js/Box2D_v2.2.1/freeglut/freeglut_font.c", "commit_date": "2014-08-15 00:00:00", "repo_name": "kripken/box2d.js", "stars": 1294, "license": "None", "language": "c", "size": 11745}
{"docstring": "/*\n * Leaves the game mode\n */\n", "func_signal": "void FGAPIENTRY glutLeaveGameMode( void )", "code": "{\n    FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutLeaveGameMode\" );\n\n    freeglut_return_if_fail( fgStructure.GameModeWindow );\n\n    fgAddToWindowDestroyList( fgStructure.GameModeWindow );\n    fgStructure.GameModeWindow = NULL;\n\n#if TARGET_HOST_POSIX_X11\n\n    XUngrabPointer( fgDisplay.Display, CurrentTime );\n    XUngrabKeyboard( fgDisplay.Display, CurrentTime );\n\n#endif\n\n    fghRestoreState();\n}", "path": "box2d.js/Box2D_v2.2.1/freeglut/freeglut_gamemode.c", "commit_date": "2014-08-15 00:00:00", "repo_name": "kripken/box2d.js", "stars": 1294, "license": "None", "language": "c", "size": 11745}
{"docstring": "/*\n * Return the width of a string drawn using a stroke font\n */\n", "func_signal": "int FGAPIENTRY glutStrokeLength( void* fontID, const unsigned char* string )", "code": "{\n    unsigned char c;\n    float length = 0.0;\n    float this_line_length = 0.0;\n    SFG_StrokeFont* font;\n    FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutStrokeLength\" );\n    font = fghStrokeByID( fontID );\n    freeglut_return_val_if_fail( font, 0 );\n    if ( !string || ! *string )\n        return 0;\n\n    while( ( c = *string++) )\n        if( c < font->Quantity )\n        {\n            if( c == '\\n' ) /* EOL; reset the length of this line */\n            {\n                if( length < this_line_length )\n                    length = this_line_length;\n                this_line_length = 0.0;\n            }\n            else  /* Not an EOL, increment the length of this line */\n            {\n                const SFG_StrokeChar *schar = font->Characters[ c ];\n                if( schar )\n                    this_line_length += schar->Right;\n            }\n        }\n    if( length < this_line_length )\n        length = this_line_length;\n    return( int )( length + 0.5 );\n}", "path": "box2d.js/Box2D_v2.2.1/freeglut/freeglut_font.c", "commit_date": "2014-08-15 00:00:00", "repo_name": "kripken/box2d.js", "stars": 1294, "license": "None", "language": "c", "size": 11745}
{"docstring": "/*\u4efb\u52a1\u63d2\u5165\u961f\u5217\u5c3e*/\n", "func_signal": "int insert_task(struct task_struct *p,sem_queue* q)", "code": "{\n\t// printk(\"Insert %d\",p->pid);\n\tif(is_full(q))\n\t{\n\t\tprintk(\"Queue is full!\\n\");\n\t\treturn -1;\n\t}\n\tq->wait_tasks[q->rear] = p;\n\tq->rear = (q->rear+1)%QUE_LEN;\n\treturn 1;\n}", "path": "HIT-OSLab/lab4/sem.c", "commit_date": "2015-01-09 00:00:00", "repo_name": "hoverwinter/HIT-OSLab", "stars": 2045, "license": "None", "language": "c", "size": 30952}
{"docstring": "/*\n *\tfind_entry()\n *\n * finds an entry in the specified directory with the wanted name. It\n * returns the cache buffer in which the entry was found, and the entry\n * itself (as a parameter - res_dir). It does NOT read the inode of the\n * entry - you'll have to do that yourself if you want to.\n *\n * This also takes care of the few special cases due to '..'-traversal\n * over a pseudo-root and a mount point.\n */\n", "func_signal": "static struct buffer_head * find_entry(struct m_inode ** dir,\n\tconst char * name, int namelen, struct dir_entry ** res_dir)", "code": "{\n\tint entries;\n\tint block,i;\n\tstruct buffer_head * bh;\n\tstruct dir_entry * de;\n\tstruct super_block * sb;\n\n#ifdef NO_TRUNCATE\n\tif (namelen > NAME_LEN)\n\t\treturn NULL;\n#else\n\tif (namelen > NAME_LEN)\n\t\tnamelen = NAME_LEN;\n#endif\n\tentries = (*dir)->i_size / (sizeof (struct dir_entry));\n\t*res_dir = NULL;\n\tif (!namelen)\n\t\treturn NULL;\n/* check for '..', as we might have to do some \"magic\" for it */\n\tif (namelen==2 && get_fs_byte(name)=='.' && get_fs_byte(name+1)=='.') {\n/* '..' in a pseudo-root results in a faked '.' (just change namelen) */\n\t\tif ((*dir) == current->root)\n\t\t\tnamelen=1;\n\t\telse if ((*dir)->i_num == ROOT_INO) {\n/* '..' over a mount-point results in 'dir' being exchanged for the mounted\n   directory-inode. NOTE! We set mounted, so that we can iput the new dir */\n\t\t\tsb=get_super((*dir)->i_dev);\n\t\t\tif (sb->s_imount) {\n\t\t\t\tiput(*dir);\n\t\t\t\t(*dir)=sb->s_imount;\n\t\t\t\t(*dir)->i_count++;\n\t\t\t}\n\t\t}\n\t}\n\tif (!(block = (*dir)->i_zone[0]))\n\t\treturn NULL;\n\tif (!(bh = bread((*dir)->i_dev,block)))\n\t\treturn NULL;\n\ti = 0;\n\tde = (struct dir_entry *) bh->b_data;\n\twhile (i < entries) {\n\t\tif ((char *)de >= BLOCK_SIZE+bh->b_data) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\tif (!(block = bmap(*dir,i/DIR_ENTRIES_PER_BLOCK)) ||\n\t\t\t    !(bh = bread((*dir)->i_dev,block))) {\n\t\t\t\ti += DIR_ENTRIES_PER_BLOCK;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tde = (struct dir_entry *) bh->b_data;\n\t\t}\n\t\tif (match(namelen,name,de)) {\n\t\t\t*res_dir = de;\n\t\t\treturn bh;\n\t\t}\n\t\tde++;\n\t\ti++;\n\t}\n\tbrelse(bh);\n\treturn NULL;\n}", "path": "HIT-OSLab/lab8/fs/namei.c", "commit_date": "2015-10-16 00:00:00", "repo_name": "hoverwinter/HIT-OSLab", "stars": 2045, "license": "None", "language": "c", "size": 30952}
{"docstring": "/*P\u539f\u5b50\u64cd\u4f5c*/\n", "func_signal": "int sys_sem_wait(sem_t* sem)", "code": "{\n\tcli();\n\tsem->value--;\n\tif(sem->value < 0)\n\t{\n\t\t/*\u53c2\u89c1sleep_on*/\n\t\tcurrent->state = TASK_UNINTERRUPTIBLE;\n\t\tinsert_task(current,&(sem->wait_queue));\n\t\tschedule();\n\t}\n\tsti();\n\treturn 0;\n}", "path": "HIT-OSLab/lab4/sem.c", "commit_date": "2015-01-09 00:00:00", "repo_name": "hoverwinter/HIT-OSLab", "stars": 2045, "license": "None", "language": "c", "size": 30952}
{"docstring": "/*\n * ok, we cannot use strncmp, as the name is not in our data space.\n * Thus we'll have to use match. No big problem. Match also makes\n * some sanity tests.\n *\n * NOTE! unlike strncmp, match returns 1 for success, 0 for failure.\n */\n", "func_signal": "static int match(int len,const char * name,struct dir_entry * de)", "code": "{\n\tregister int same ;\n\n\tif (!de || !de->inode || len > NAME_LEN)\n\t\treturn 0;\n\tif (len < NAME_LEN && de->name[len])\n\t\treturn 0;\n\t__asm__(\"cld\\n\\t\"\n\t\t\"fs ; repe ; cmpsb\\n\\t\"\n\t\t\"setz %%al\"\n\t\t:\"=a\" (same)\n\t\t:\"0\" (0),\"S\" ((long) name),\"D\" ((long) de->name),\"c\" (len)\n\t\t);\n\treturn same;\n}", "path": "HIT-OSLab/lab8/fs/namei.c", "commit_date": "2015-10-16 00:00:00", "repo_name": "hoverwinter/HIT-OSLab", "stars": 2045, "license": "None", "language": "c", "size": 30952}
{"docstring": "/*\n * routine to check that the specified directory is empty (for rmdir)\n */\n", "func_signal": "static int empty_dir(struct m_inode * inode)", "code": "{\n\tint nr,block;\n\tint len;\n\tstruct buffer_head * bh;\n\tstruct dir_entry * de;\n\n\tlen = inode->i_size / sizeof (struct dir_entry);\n\tif (len<2 || !inode->i_zone[0] ||\n\t    !(bh=bread(inode->i_dev,inode->i_zone[0]))) {\n\t    \tprintk(\"warning - bad directory on dev %04x\\n\",inode->i_dev);\n\t\treturn 0;\n\t}\n\tde = (struct dir_entry *) bh->b_data;\n\tif (de[0].inode != inode->i_num || !de[1].inode || \n\t    strcmp(\".\",de[0].name) || strcmp(\"..\",de[1].name)) {\n\t    \tprintk(\"warning - bad directory on dev %04x\\n\",inode->i_dev);\n\t\treturn 0;\n\t}\n\tnr = 2;\n\tde += 2;\n\twhile (nr<len) {\n\t\tif ((void *) de >= (void *) (bh->b_data+BLOCK_SIZE)) {\n\t\t\tbrelse(bh);\n\t\t\tblock=bmap(inode,nr/DIR_ENTRIES_PER_BLOCK);\n\t\t\tif (!block) {\n\t\t\t\tnr += DIR_ENTRIES_PER_BLOCK;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!(bh=bread(inode->i_dev,block)))\n\t\t\t\treturn 0;\n\t\t\tde = (struct dir_entry *) bh->b_data;\n\t\t}\n\t\tif (de->inode) {\n\t\t\tbrelse(bh);\n\t\t\treturn 0;\n\t\t}\n\t\tde++;\n\t\tnr++;\n\t}\n\tbrelse(bh);\n\treturn 1;\n}", "path": "HIT-OSLab/lab8/fs/namei.c", "commit_date": "2015-10-16 00:00:00", "repo_name": "hoverwinter/HIT-OSLab", "stars": 2045, "license": "None", "language": "c", "size": 30952}
{"docstring": "/*\n *\topen_namei()\n *\n * namei for open - this is in fact almost the whole open-routine.\n */\n", "func_signal": "int open_namei(const char * pathname, int flag, int mode,\n\tstruct m_inode ** res_inode)", "code": "{\n\tconst char * basename;\n\tint inr,dev,namelen;\n\tstruct m_inode * dir, *inode;\n\tstruct buffer_head * bh;\n\tstruct dir_entry * de;\n\n\tif ((flag & O_TRUNC) && !(flag & O_ACCMODE))\n\t\tflag |= O_WRONLY;\n\tmode &= 0777 & ~current->umask;\n\tmode |= I_REGULAR;\n\tif (!(dir = dir_namei(pathname,&namelen,&basename)))\n\t\treturn -ENOENT;\n\tif (!namelen) {\t\t\t/* special case: '/usr/' etc */\n\t\tif (!(flag & (O_ACCMODE|O_CREAT|O_TRUNC))) {\n\t\t\t*res_inode=dir;\n\t\t\treturn 0;\n\t\t}\n\t\tiput(dir);\n\t\treturn -EISDIR;\n\t}\n\tbh = find_entry(&dir,basename,namelen,&de);\n\tif (!bh) {\n\t\tif (!(flag & O_CREAT)) {\n\t\t\tiput(dir);\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tif (!permission(dir,MAY_WRITE)) {\n\t\t\tiput(dir);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tinode = new_inode(dir->i_dev);\n\t\tif (!inode) {\n\t\t\tiput(dir);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\tinode->i_uid = current->euid;\n\t\tinode->i_mode = mode;\n\t\tinode->i_dirt = 1;\n\t\tbh = add_entry(dir,basename,namelen,&de);\n\t\tif (!bh) {\n\t\t\tinode->i_nlinks--;\n\t\t\tiput(inode);\n\t\t\tiput(dir);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\tde->inode = inode->i_num;\n\t\tbh->b_dirt = 1;\n\t\tbrelse(bh);\n\t\tiput(dir);\n\t\t*res_inode = inode;\n\t\treturn 0;\n\t}\n\tinr = de->inode;\n\tdev = dir->i_dev;\n\tbrelse(bh);\n\tiput(dir);\n\tif (flag & O_EXCL)\n\t\treturn -EEXIST;\n\tif (!(inode=iget(dev,inr)))\n\t\treturn -EACCES;\n\tif ((S_ISDIR(inode->i_mode) && (flag & O_ACCMODE)) ||\n\t    !permission(inode,ACC_MODE(flag))) {\n\t\tiput(inode);\n\t\treturn -EPERM;\n\t}\n\tinode->i_atime = CURRENT_TIME;\n\tif (flag & O_TRUNC)\n\t\ttruncate(inode);\n\t*res_inode = inode;\n\treturn 0;\n}", "path": "HIT-OSLab/lab8/fs/namei.c", "commit_date": "2015-10-16 00:00:00", "repo_name": "hoverwinter/HIT-OSLab", "stars": 2045, "license": "None", "language": "c", "size": 30952}
{"docstring": "/*V\u539f\u5b50\u64cd\u4f5c*/\n", "func_signal": "int sys_sem_post(sem_t* sem)", "code": "{\n\tcli();\n\tstruct task_struct *p;\n\tsem->value++;\n\tif(sem->value <= 0)\n\t{\n\t\tp = get_task(&(sem->wait_queue));\n\t\tif(p != NULL)\n\t\t{\n\t\t\t(*p).state = TASK_RUNNING;\n\t\t}\n\t}\n\tsti();\n\treturn 0;\n}", "path": "HIT-OSLab/lab4/sem.c", "commit_date": "2015-01-09 00:00:00", "repo_name": "hoverwinter/HIT-OSLab", "stars": 2045, "license": "None", "language": "c", "size": 30952}
{"docstring": "/*\n *\tnamei()\n *\n * is used by most simple commands to get the inode of a specified name.\n * Open, link etc use their own routines, but this is enough for things\n * like 'chmod' etc.\n */\n", "func_signal": "struct m_inode * namei(const char * pathname)", "code": "{\n\tconst char * basename;\n\tint inr,dev,namelen;\n\tstruct m_inode * dir;\n\tstruct buffer_head * bh;\n\tstruct dir_entry * de;\n\n\tif (!(dir = dir_namei(pathname,&namelen,&basename)))\n\t\treturn NULL;\n\tif (!namelen)\t\t\t/* special case: '/usr/' etc */\n\t\treturn dir;\n\tbh = find_entry(&dir,basename,namelen,&de);\n\tif (!bh) {\n\t\tiput(dir);\n\t\treturn NULL;\n\t}\n\tinr = de->inode;\n\tdev = dir->i_dev;\n\tbrelse(bh);\n\tiput(dir);\n\tdir=iget(dev,inr);\n\tif (dir) {\n\t\tdir->i_atime=CURRENT_TIME;\n\t\tdir->i_dirt=1;\n\t}\n\treturn dir;\n}", "path": "HIT-OSLab/lab8/fs/namei.c", "commit_date": "2015-10-16 00:00:00", "repo_name": "hoverwinter/HIT-OSLab", "stars": 2045, "license": "None", "language": "c", "size": 30952}
{"docstring": "/*\n *\tget_dir()\n *\n * Getdir traverses the pathname until it hits the topmost directory.\n * It returns NULL on failure.\n */\n", "func_signal": "static struct m_inode * get_dir(const char * pathname)", "code": "{\n\tchar c;\n\tconst char * thisname;\n\tstruct m_inode * inode;\n\tstruct buffer_head * bh;\n\tint namelen,inr,idev;\n\tstruct dir_entry * de;\n\n\tif (!current->root || !current->root->i_count)\n\t\tpanic(\"No root inode\");\n\tif (!current->pwd || !current->pwd->i_count)\n\t\tpanic(\"No cwd inode\");\n\tif ((c=get_fs_byte(pathname))=='/') {\n\t\tinode = current->root;\n\t\tpathname++;\n\t} else if (c)\n\t\tinode = current->pwd;\n\telse\n\t\treturn NULL;\t/* empty name is bad */\n\tinode->i_count++;\n\twhile (1) {\n\t\tthisname = pathname;\n\t\tif (!S_ISDIR(inode->i_mode) || !permission(inode,MAY_EXEC)) {\n\t\t\tiput(inode);\n\t\t\treturn NULL;\n\t\t}\n\t\tfor(namelen=0;(c=get_fs_byte(pathname++))&&(c!='/');namelen++)\n\t\t\t/* nothing */ ;\n\t\tif (!c)\n\t\t\treturn inode;\n\t\tif (!(bh = find_entry(&inode,thisname,namelen,&de))) {\n\t\t\tiput(inode);\n\t\t\treturn NULL;\n\t\t}\n\t\tinr = de->inode;\n\t\tidev = inode->i_dev;\n\t\tbrelse(bh);\n\t\tiput(inode);\n\t\tif (!(inode = iget(idev,inr)))\n\t\t\treturn NULL;\n\t}\n}", "path": "HIT-OSLab/lab8/fs/namei.c", "commit_date": "2015-10-16 00:00:00", "repo_name": "hoverwinter/HIT-OSLab", "stars": 2045, "license": "None", "language": "c", "size": 30952}
{"docstring": "/*\n *\tadd_entry()\n *\n * adds a file entry to the specified directory, using the same\n * semantics as find_entry(). It returns NULL if it failed.\n *\n * NOTE!! The inode part of 'de' is left at 0 - which means you\n * may not sleep between calling this and putting something into\n * the entry, as someone else might have used it while you slept.\n */\n", "func_signal": "static struct buffer_head * add_entry(struct m_inode * dir,\n\tconst char * name, int namelen, struct dir_entry ** res_dir)", "code": "{\n\tint block,i;\n\tstruct buffer_head * bh;\n\tstruct dir_entry * de;\n\n\t*res_dir = NULL;\n#ifdef NO_TRUNCATE\n\tif (namelen > NAME_LEN)\n\t\treturn NULL;\n#else\n\tif (namelen > NAME_LEN)\n\t\tnamelen = NAME_LEN;\n#endif\n\tif (!namelen)\n\t\treturn NULL;\n\tif (!(block = dir->i_zone[0]))\n\t\treturn NULL;\n\tif (!(bh = bread(dir->i_dev,block)))\n\t\treturn NULL;\n\ti = 0;\n\tde = (struct dir_entry *) bh->b_data;\n\twhile (1) {\n\t\tif ((char *)de >= BLOCK_SIZE+bh->b_data) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\tblock = create_block(dir,i/DIR_ENTRIES_PER_BLOCK);\n\t\t\tif (!block)\n\t\t\t\treturn NULL;\n\t\t\tif (!(bh = bread(dir->i_dev,block))) {\n\t\t\t\ti += DIR_ENTRIES_PER_BLOCK;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tde = (struct dir_entry *) bh->b_data;\n\t\t}\n\t\tif (i*sizeof(struct dir_entry) >= dir->i_size) {\n\t\t\tde->inode=0;\n\t\t\tdir->i_size = (i+1)*sizeof(struct dir_entry);\n\t\t\tdir->i_dirt = 1;\n\t\t\tdir->i_ctime = CURRENT_TIME;\n\t\t}\n\t\tif (!de->inode) {\n\t\t\tdir->i_mtime = CURRENT_TIME;\n\t\t\tfor (i=0; i < NAME_LEN ; i++)\n\t\t\t\tde->name[i]=(i<namelen)?get_fs_byte(name+i):0;\n\t\t\tbh->b_dirt = 1;\n\t\t\t*res_dir = de;\n\t\t\treturn bh;\n\t\t}\n\t\tde++;\n\t\ti++;\n\t}\n\tbrelse(bh);\n\treturn NULL;\n}", "path": "HIT-OSLab/lab8/fs/namei.c", "commit_date": "2015-10-16 00:00:00", "repo_name": "hoverwinter/HIT-OSLab", "stars": 2045, "license": "None", "language": "c", "size": 30952}
{"docstring": "/*\n *  Ok, this is the main fork-routine. It copies the system process\n * information (task[nr]) and sets up the necessary registers. It\n * also copies the data segment in it's entirety.\n */\n", "func_signal": "int copy_process(int nr,long ebp,long edi,long esi,long gs,long none,\n\t\tlong ebx,long ecx,long edx,\n\t\tlong fs,long es,long ds,\n\t\tlong eip,long cs,long eflags,long esp,long ss)", "code": "{\n\tstruct task_struct *p;\n\tint i;\n\tstruct file *f;\n\n\tp = (struct task_struct *) get_free_page();\n\tif (!p)\n\t\treturn -EAGAIN;\n\ttask[nr] = p;\n\t*p = *current;\t/* NOTE! this doesn't copy the supervisor stack */\n\tp->state = TASK_UNINTERRUPTIBLE;\n\tp->pid = last_pid;\n\t/*  \u7ebf\u7a0b\u521d\u59cb\u5316 */\n\tp->tid = 0;\n\tp->tid_num = 1;\n\t/*  ******* */\n\tp->father = current->pid;\n\tp->counter = p->priority;\n\tp->signal = 0;\n\tp->alarm = 0;\n\tp->leader = 0;\t\t/* process leadership doesn't inherit */\n\tp->utime = p->stime = 0;\n\tp->cutime = p->cstime = 0;\n\tp->start_time = jiffies;\n\tp->tss.back_link = 0;\n\tp->tss.esp0 = PAGE_SIZE + (long) p;\n\tp->tss.ss0 = 0x10;\n\tp->tss.eip = eip;\n\tp->tss.eflags = eflags;\n\tp->tss.eax = 0;\n\tp->tss.ecx = ecx;\n\tp->tss.edx = edx;\n\tp->tss.ebx = ebx;\n\tp->tss.esp = esp;\n\tp->tss.ebp = ebp;\n\tp->tss.esi = esi;\n\tp->tss.edi = edi;\n\tp->tss.es = es & 0xffff;\n\tp->tss.cs = cs & 0xffff;\n\tp->tss.ss = ss & 0xffff;\n\tp->tss.ds = ds & 0xffff;\n\tp->tss.fs = fs & 0xffff;\n\tp->tss.gs = gs & 0xffff;\n\tp->tss.ldt = _LDT(nr);\n\tp->tss.trace_bitmap = 0x80000000;\n\tif (last_task_used_math == current)\n\t\t__asm__(\"clts ; fnsave %0\"::\"m\" (p->tss.i387));\n\tif (copy_mem(nr,p)) {\n\t\ttask[nr] = NULL;\n\t\tfree_page((long) p);\n\t\treturn -EAGAIN;\n\t}\n\tfor (i=0; i<NR_OPEN;i++)\n\t\tif ((f=p->filp[i]))\n\t\t\tf->f_count++;\n\tif (current->pwd)\n\t\tcurrent->pwd->i_count++;\n\tif (current->root)\n\t\tcurrent->root->i_count++;\n\tif (current->executable)\n\t\tcurrent->executable->i_count++;\n\tset_tss_desc(gdt+(nr<<1)+FIRST_TSS_ENTRY,&(p->tss));\n\tset_ldt_desc(gdt+(nr<<1)+FIRST_LDT_ENTRY,&(p->ldt));\n\tp->state = TASK_RUNNING;\t/* do this last, just in case */\n\treturn last_pid;\n}", "path": "HIT-OSLab/lab8/kernel/fork.c", "commit_date": "2015-10-16 00:00:00", "repo_name": "hoverwinter/HIT-OSLab", "stars": 2045, "license": "None", "language": "c", "size": 30952}
{"docstring": "/*\u91ca\u653e\u4fe1\u53f7\u91cf*/\n", "func_signal": "int sys_sem_unlink(const char *name)", "code": "{  \n    char tmp[16];\n    char c;\n\tint i;\n\tfor( i = 0; i<16; i++)\n\t{\n\t\tc = get_fs_byte(name+i);\n\t\ttmp[i] = c;\n\t\tif(c =='\\0') break;\n\t}\n\tif(c >= 16) \n\t{\n\t\tprintk(\"Semphore name is too long!\");\n\t\treturn -1;\n\t}\n    int ret = sem_location(tmp); \n    if(ret != -1)\n    {\n    \tsemaphores[ret].value = 0;\n    \tstrcpy(semaphores[ret].name,\"\\0\");\n    \tsemaphores[ret].occupied = 0;\n    \treturn 0;\n    }   \n    return -1;  \n}", "path": "HIT-OSLab/lab4/sem.c", "commit_date": "2015-01-09 00:00:00", "repo_name": "hoverwinter/HIT-OSLab", "stars": 2045, "license": "None", "language": "c", "size": 30952}
{"docstring": "/*\n * XXX need to check permissions needed to send signals to process\n * groups, etc. etc.  kill() permissions semantics are tricky!\n */\n", "func_signal": "int sys_kill(int pid,int sig)", "code": "{\n\tstruct task_struct **p = NR_TASKS + task;\n\tint err, retval = 0;\n\n\tif (!pid) while (--p > &FIRST_TASK) {\n\t\tif (*p && (*p)->pgrp == current->pid) \n\t\t\tif ((err=send_sig(sig,*p,1)))\n\t\t\t\tretval = err;\n\t} else if (pid>0) while (--p > &FIRST_TASK) {\n\t\tif (*p && (*p)->pid == pid) \n\t\t\tif ((err=send_sig(sig,*p,0)))\n\t\t\t\tretval = err;\n\t} else if (pid == -1) while (--p > &FIRST_TASK) {\n\t\tif ((err = send_sig(sig,*p,0)))\n\t\t\tretval = err;\n\t} else while (--p > &FIRST_TASK)\n\t\tif (*p && (*p)->pgrp == -pid)\n\t\t\tif ((err = send_sig(sig,*p,0)))\n\t\t\t\tretval = err;\n\treturn retval;\n}", "path": "HIT-OSLab/lab3/exit.c", "commit_date": "2015-01-09 00:00:00", "repo_name": "hoverwinter/HIT-OSLab", "stars": 2045, "license": "None", "language": "c", "size": 30952}
{"docstring": "/*\n * This routine gets called when tty_write has put something into\n * the write_queue. It must check wheter the queue is empty, and\n * set the interrupt register accordingly\n *\n *\tvoid _rs_write(struct tty_struct * tty);\n */\n", "func_signal": "void rs_write(struct tty_struct * tty)", "code": "{\n\tcli();\n\tif (!EMPTY(tty->write_q))\n\t\toutb(inb_p(tty->write_q.data+1)|0x02,tty->write_q.data+1);\n\tsti();\n}", "path": "HIT-OSLab/lab8/kernel/chr_drv/serial.c", "commit_date": "2015-10-16 00:00:00", "repo_name": "hoverwinter/HIT-OSLab", "stars": 2045, "license": "None", "language": "c", "size": 30952}
{"docstring": "/*\n *\tpermission()\n *\n * is used to check for read/write/execute permissions on a file.\n * I don't know if we should look at just the euid or both euid and\n * uid, but that should be easily changed.\n */\n", "func_signal": "static int permission(struct m_inode * inode,int mask)", "code": "{\n\tint mode = inode->i_mode;\n\n/* special case: not even root can read/write a deleted file */\n\tif (inode->i_dev && !inode->i_nlinks)\n\t\treturn 0;\n\telse if (current->euid==inode->i_uid)\n\t\tmode >>= 6;\n\telse if (current->egid==inode->i_gid)\n\t\tmode >>= 3;\n\tif (((mode & mask & 0007) == mask) || suser())\n\t\treturn 1;\n\treturn 0;\n}", "path": "HIT-OSLab/lab8/fs/namei.c", "commit_date": "2015-10-16 00:00:00", "repo_name": "hoverwinter/HIT-OSLab", "stars": 2045, "license": "None", "language": "c", "size": 30952}
{"docstring": "/*\u83b7\u5f97\u961f\u5217\u5934\u7b2c\u4e00\u4e2a\u4efb\u52a1*/\n", "func_signal": "struct task_struct * get_task(sem_queue* q)", "code": "{\n\tif(is_empty(q)) \n\t{\n\t\tprintk(\"Queue is empty!\\n\");\n\t\treturn NULL;\n\t}\n\tstruct task_struct *tmp = q->wait_tasks[q->front]; \n\tq->front = (q->front+1)%QUE_LEN;\n\treturn tmp;\n}", "path": "HIT-OSLab/lab4/sem.c", "commit_date": "2015-01-09 00:00:00", "repo_name": "hoverwinter/HIT-OSLab", "stars": 2045, "license": "None", "language": "c", "size": 30952}
{"docstring": "/*\u4fe1\u53f7\u91cf\u662f\u5426\u5df2\u6253\u5f00\uff0c\u662f\u8fd4\u56de\u4f4d\u7f6e*/\n", "func_signal": "int sem_location(const char* name)", "code": "{  \n    int i;\n    for(i = 0;i < SEM_COUNT; i++)  \n    {  \n        if(strcmp(name,semaphores[i].name) == 0 && semaphores[i].occupied == 1) \n        {     \n            return i;  \n        }  \n    }  \n    return -1; \n}", "path": "HIT-OSLab/lab4/sem.c", "commit_date": "2015-01-09 00:00:00", "repo_name": "hoverwinter/HIT-OSLab", "stars": 2045, "license": "None", "language": "c", "size": 30952}
{"docstring": "/*\n *\tdir_namei()\n *\n * dir_namei() returns the inode of the directory of the\n * specified name, and the name within that directory.\n */\n", "func_signal": "static struct m_inode * dir_namei(const char * pathname,\n\tint * namelen, const char ** name)", "code": "{\n\tchar c;\n\tconst char * basename;\n\tstruct m_inode * dir;\n\n\tif (!(dir = get_dir(pathname)))\n\t\treturn NULL;\n\tbasename = pathname;\n\twhile ((c=get_fs_byte(pathname++)))\n\t\tif (c=='/')\n\t\t\tbasename=pathname;\n\t*namelen = pathname-basename-1;\n\t*name = basename;\n\treturn dir;\n}", "path": "HIT-OSLab/lab8/fs/namei.c", "commit_date": "2015-10-16 00:00:00", "repo_name": "hoverwinter/HIT-OSLab", "stars": 2045, "license": "None", "language": "c", "size": 30952}
{"docstring": "/*\u6253\u5f00\u4fe1\u53f7\u91cf*/\n", "func_signal": "sem_t* sys_sem_open(const char* name,unsigned int value)", "code": "{\n\tchar tmp[16];\n\tchar c;\n\tint i;\n\tfor( i = 0; i<16; i++)\n\t{\n\t\tc = get_fs_byte(name+i);\n\t\ttmp[i] = c;\n\t\tif(c =='\\0') break;\n\t}\n\tif(c >= 16) \n\t{ \t\n\t\tprintk(\"Semaphore name is too long!\");\n\t\treturn NULL;\n\t}\n\tif((i = sem_location(tmp)) != -1)\n\t{\n\t\treturn &semaphores[i];\n\t}\n\tfor(i = 0;i< SEM_COUNT; i++)\n\t{\n\t\tif(!semaphores[i].occupied)\n\t\t{\n\t\t\tstrcpy(semaphores[i].name,tmp);\n\t\t\tsemaphores[i].occupied = 1;\n\t\t\tsemaphores[i].value = value;\n\t\t\tinit_queue(&(semaphores[i].wait_queue));\n\t\t\t// printk(\"%d %d %d %s\\n\",semaphores[i].occupied,i,semaphores[i].value,semaphores[i].name);\n\t\t\t// printk(\"%p\\n\",&semaphores[i]); \n\t\t\treturn &semaphores[i];\n\t\t}\n\t}\t\n\tprintk(\"Numbers of semaphores are limited!\\n\");\n\treturn NULL;\n}", "path": "HIT-OSLab/lab4/sem.c", "commit_date": "2015-01-09 00:00:00", "repo_name": "hoverwinter/HIT-OSLab", "stars": 2045, "license": "None", "language": "c", "size": 30952}
{"docstring": "/*\n * XXX need to check permissions needed to send signals to process\n * groups, etc. etc.  kill() permissions semantics are tricky!\n */\n", "func_signal": "int sys_kill(int pid,int sig)", "code": "{\n\tstruct task_struct **p = NR_TASKS + task;\n\tint err, retval = 0;\n\n\tif (!pid) while (--p > &FIRST_TASK) {\n\t\tif (*p && (*p)->pgrp == current->pid) \n\t\t\tif ((err=send_sig(sig,*p,1)))\n\t\t\t\tretval = err;\n\t} else if (pid>0) while (--p > &FIRST_TASK) {\n\t\tif (*p && (*p)->pid == pid) \n\t\t\tif ((err=send_sig(sig,*p,0)))\n\t\t\t\tretval = err;\n\t} else if (pid == -1) while (--p > &FIRST_TASK) {\n\t\tif ((err = send_sig(sig,*p,0)))\n\t\t\tretval = err;\n\t} else while (--p > &FIRST_TASK)\n\t\tif (*p && (*p)->pgrp == -pid)\n\t\t\tif ((err = send_sig(sig,*p,0)))\n\t\t\t\tretval = err;\n\treturn retval;\n}", "path": "HIT-OSLab/lab8/kernel/exit.c", "commit_date": "2015-10-16 00:00:00", "repo_name": "hoverwinter/HIT-OSLab", "stars": 2045, "license": "None", "language": "c", "size": 30952}
{"docstring": "/*\n * Implementation of ISO-8859-1.\n * Probably on most architectures this compiles to less than 256 bytes\n * of code, so we can save space by not having a table for this one.\n */\n", "func_signal": "static int mbtowc_iso1(void *map, int *pwc, const char *s, size_t n)", "code": "{\n  int wc;\n\n  (void)map;\n  if (!n || !s)\n    return 0;\n  wc = (uint8_t)*s;\n  if (wc & ~0xff)\n    return -1;\n  if (pwc)\n    *pwc = wc;\n  return wc ? 1 : 0;\n}", "path": "flac/src/share/utf8/charset.c", "commit_date": "2017-01-19 00:00:00", "repo_name": "xiph/flac", "stars": 1464, "license": "other", "language": "c", "size": 8677}
{"docstring": "/*\n * Function to convert a buffer from one encoding to another.\n * Invalid bytes are replaced by '#', and characters that are\n * not available in the target encoding are replaced by '?'.\n * Each of TO and TOLEN may be zero, if the result is not needed.\n * The output buffer is null-terminated, so it is all right to\n * use charset_convert(fromcode, tocode, s, strlen(s), &t, 0).\n */\n", "func_signal": "int charset_convert(const char *fromcode, const char *tocode,\n\t\t    const char *from, size_t fromlen,\n\t\t    char **to, size_t *tolen)", "code": "{\n  int ret = 0;\n  struct charset *charset1, *charset2;\n  char *tobuf, *p;\n  int i, j, wc;\n\n  charset1 = charset_find(fromcode);\n  charset2 = charset_find(tocode);\n  if (!charset1 || !charset2 )\n    return -1;\n\n  tobuf = safe_malloc_mul2add_(fromlen, /*times*/charset2->max, /*+*/1);\n  if (!tobuf)\n    return -2;\n\n  for (p = tobuf; fromlen; from += i, fromlen -= i, p += j) {\n    i = charset_mbtowc(charset1, &wc, from, fromlen);\n    if (!i)\n      i = 1;\n    else if (i == -1) {\n      i  = 1;\n      wc = '#';\n      ret = 2;\n    }\n    j = charset_wctomb(charset2, p, wc);\n    if (j == -1) {\n      if (!ret)\n\tret = 1;\n      j = charset_wctomb(charset2, p, '?');\n      if (j == -1)\n\tj = 0;\n    }\n  }\n\n  if (tolen)\n    *tolen = p - tobuf;\n  *p++ = '\\0';\n  if (to) {\n    char *tobuf_saved = tobuf;\n    *to = realloc(tobuf, p - tobuf);\n    if (*to == NULL)\n      *to = tobuf_saved;\n  }\n  else\n    free(tobuf);\n\n  return ret;\n}", "path": "flac/src/share/utf8/charset.c", "commit_date": "2017-01-19 00:00:00", "repo_name": "xiph/flac", "stars": 1464, "license": "other", "language": "c", "size": 8677}
{"docstring": "/* 4-term -92dB side-lobe */\n", "func_signal": "void FLAC__window_blackman_harris_4term_92db_sidelobe(FLAC__real *window, const FLAC__int32 L)", "code": "{\n\tconst FLAC__int32 N = L - 1;\n\tFLAC__int32 n;\n\n\tfor (n = 0; n <= N; n++)\n\t\twindow[n] = (FLAC__real)(0.35875f - 0.48829f * cosf(2.0f * M_PI * n / N) + 0.14128f * cosf(4.0f * M_PI * n / N) - 0.01168f * cosf(6.0f * M_PI * n / N));\n}", "path": "flac/src/libFLAC/window.c", "commit_date": "2019-09-15 00:00:00", "repo_name": "xiph/flac", "stars": 1464, "license": "other", "language": "c", "size": 8677}
{"docstring": "/* for memcmp() */\n", "func_signal": "FLAC__bool mutils__compare_block_data_streaminfo(const FLAC__StreamMetadata_StreamInfo *block, const FLAC__StreamMetadata_StreamInfo *blockcopy)", "code": "{\n\tif(blockcopy->min_blocksize != block->min_blocksize) {\n\t\tprintf(\"FAILED, min_blocksize mismatch, expected %u, got %u\\n\", block->min_blocksize, blockcopy->min_blocksize);\n\t\treturn false;\n\t}\n\tif(blockcopy->max_blocksize != block->max_blocksize) {\n\t\tprintf(\"FAILED, max_blocksize mismatch, expected %u, got %u\\n\", block->max_blocksize, blockcopy->max_blocksize);\n\t\treturn false;\n\t}\n\tif(blockcopy->min_framesize != block->min_framesize) {\n\t\tprintf(\"FAILED, min_framesize mismatch, expected %u, got %u\\n\", block->min_framesize, blockcopy->min_framesize);\n\t\treturn false;\n\t}\n\tif(blockcopy->max_framesize != block->max_framesize) {\n\t\tprintf(\"FAILED, max_framesize mismatch, expected %u, got %u\\n\", block->max_framesize, blockcopy->max_framesize);\n\t\treturn false;\n\t}\n\tif(blockcopy->sample_rate != block->sample_rate) {\n\t\tprintf(\"FAILED, sample_rate mismatch, expected %u, got %u\\n\", block->sample_rate, blockcopy->sample_rate);\n\t\treturn false;\n\t}\n\tif(blockcopy->channels != block->channels) {\n\t\tprintf(\"FAILED, channels mismatch, expected %u, got %u\\n\", block->channels, blockcopy->channels);\n\t\treturn false;\n\t}\n\tif(blockcopy->bits_per_sample != block->bits_per_sample) {\n\t\tprintf(\"FAILED, bits_per_sample mismatch, expected %u, got %u\\n\", block->bits_per_sample, blockcopy->bits_per_sample);\n\t\treturn false;\n\t}\n\tif(blockcopy->total_samples != block->total_samples) {\n\t\tprintf(\"FAILED, total_samples mismatch, expected %\" PRIu64 \", got %\" PRIu64 \"\\n\", block->total_samples, blockcopy->total_samples);\n\t\treturn false;\n\t}\n\tif(0 != memcmp(blockcopy->md5sum, block->md5sum, sizeof(block->md5sum))) {\n\t\tprintf(\"FAILED, md5sum mismatch, expected %02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X, got %02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X\\n\",\n\t\t\t(uint32_t)block->md5sum[0],\n\t\t\t(uint32_t)block->md5sum[1],\n\t\t\t(uint32_t)block->md5sum[2],\n\t\t\t(uint32_t)block->md5sum[3],\n\t\t\t(uint32_t)block->md5sum[4],\n\t\t\t(uint32_t)block->md5sum[5],\n\t\t\t(uint32_t)block->md5sum[6],\n\t\t\t(uint32_t)block->md5sum[7],\n\t\t\t(uint32_t)block->md5sum[8],\n\t\t\t(uint32_t)block->md5sum[9],\n\t\t\t(uint32_t)block->md5sum[10],\n\t\t\t(uint32_t)block->md5sum[11],\n\t\t\t(uint32_t)block->md5sum[12],\n\t\t\t(uint32_t)block->md5sum[13],\n\t\t\t(uint32_t)block->md5sum[14],\n\t\t\t(uint32_t)block->md5sum[15],\n\t\t\t(uint32_t)blockcopy->md5sum[0],\n\t\t\t(uint32_t)blockcopy->md5sum[1],\n\t\t\t(uint32_t)blockcopy->md5sum[2],\n\t\t\t(uint32_t)blockcopy->md5sum[3],\n\t\t\t(uint32_t)blockcopy->md5sum[4],\n\t\t\t(uint32_t)blockcopy->md5sum[5],\n\t\t\t(uint32_t)blockcopy->md5sum[6],\n\t\t\t(uint32_t)blockcopy->md5sum[7],\n\t\t\t(uint32_t)blockcopy->md5sum[8],\n\t\t\t(uint32_t)blockcopy->md5sum[9],\n\t\t\t(uint32_t)blockcopy->md5sum[10],\n\t\t\t(uint32_t)blockcopy->md5sum[11],\n\t\t\t(uint32_t)blockcopy->md5sum[12],\n\t\t\t(uint32_t)blockcopy->md5sum[13],\n\t\t\t(uint32_t)blockcopy->md5sum[14],\n\t\t\t(uint32_t)blockcopy->md5sum[15]\n\t\t);\n\t\treturn false;\n\t}\n\treturn true;\n}", "path": "flac/src/test_libs_common/metadata_utils.c", "commit_date": "2017-01-14 00:00:00", "repo_name": "xiph/flac", "stars": 1464, "license": "other", "language": "c", "size": 8677}
{"docstring": "/* When calling this procedure, make sure that ip[-order] and op[-order] point to real data! */\n", "func_signal": "static void\nfilter ( const flac_float_t* input, flac_float_t* output, size_t nSamples, const flac_float_t* a, const flac_float_t* b, size_t order, uint32_t downsample )", "code": "{\n    double  y;\n    size_t  i;\n    size_t  k;\n\n    const flac_float_t* input_head = input;\n    const flac_float_t* input_tail;\n\n    flac_float_t* output_head = output;\n    flac_float_t* output_tail;\n\n    for ( i = 0; i < nSamples; i++, input_head += downsample, ++output_head ) {\n\n        input_tail = input_head;\n        output_tail = output_head;\n\n        y = *input_head * b[0];\n\n        for ( k = 1; k <= order; k++ ) {\n            input_tail -= downsample;\n            --output_tail;\n            y += *input_tail * b[k] - *output_tail * a[k];\n        }\n\n        output[i] = (flac_float_t)y;\n    }\n}", "path": "flac/src/share/replaygain_analysis/replaygain_analysis.c", "commit_date": "2019-12-08 00:00:00", "repo_name": "xiph/flac", "stars": 1464, "license": "other", "language": "c", "size": 8677}
{"docstring": "/* #define HASH(i) 0 */\n/* #define HASH(i) 99 */\n", "func_signal": "static struct inverse_map *make_inverse_map(const uint16_t *from)", "code": "{\n  struct inverse_map *to;\n  char used[256];\n  int i, j, k;\n\n  to = malloc(sizeof(struct inverse_map));\n  if (!to)\n    return 0;\n  for (i = 0; i < 256; i++)\n    to->first[i] = to->next[i] = used[i] = 0;\n  for (i = 255; i >= 0; i--)\n    if (from[i] != 0xffff) {\n      k = HASH(from[i]);\n      to->next[i] = to->first[k];\n      to->first[k] = i;\n      used[k] = 1;\n    }\n\n  /* Point the empty buckets at an empty list. */\n  for (i = 0; i < 256; i++)\n    if (!to->next[i])\n      break;\n  if (i < 256)\n    for (j = 0; j < 256; j++)\n      if (!used[j])\n\tto->first[j] = i;\n\n  return to;\n}", "path": "flac/src/share/utf8/charset.c", "commit_date": "2017-01-19 00:00:00", "repo_name": "xiph/flac", "stars": 1464, "license": "other", "language": "c", "size": 8677}
{"docstring": "/*@@@@add to tests*/\n", "func_signal": "FLAC_API FLAC__bool FLAC__metadata_simple_iterator_is_last(const FLAC__Metadata_SimpleIterator *iterator)", "code": "{\n\tFLAC__ASSERT(0 != iterator);\n\tFLAC__ASSERT(0 != iterator->file);\n\n\treturn iterator->is_last;\n}", "path": "flac/src/libFLAC/metadata_iterators.c", "commit_date": "2019-09-15 00:00:00", "repo_name": "xiph/flac", "stars": 1464, "license": "other", "language": "c", "size": 8677}
{"docstring": "/*\n * Implementation of US-ASCII.\n * Probably on most architectures this compiles to less than 256 bytes\n * of code, so we can save space by not having a table for this one.\n */\n", "func_signal": "static int mbtowc_ascii(void *map, int *pwc, const char *s, size_t n)", "code": "{\n  int wc;\n\n  (void)map;\n  if (!n || !s)\n    return 0;\n  wc = (uint8_t)*s;\n  if (wc & ~0x7f)\n    return -1;\n  if (pwc)\n    *pwc = wc;\n  return wc ? 1 : 0;\n}", "path": "flac/src/share/utf8/charset.c", "commit_date": "2017-01-19 00:00:00", "repo_name": "xiph/flac", "stars": 1464, "license": "other", "language": "c", "size": 8677}
{"docstring": "/* returns GAIN_ANALYSIS_OK if successful, GAIN_ANALYSIS_ERROR if not */\n", "func_signal": "int\nAnalyzeSamples ( const flac_float_t* left_samples, const flac_float_t* right_samples, size_t num_samples, int num_channels )", "code": "{\n    uint32_t        downsample = replaygainfilter->downsample;\n    const flac_float_t*  curleft;\n    const flac_float_t*  curright;\n    long            prebufsamples;\n    long            batchsamples;\n    long            cursamples;\n    long            cursamplepos;\n    int             i;\n\n    num_samples /= downsample;\n\n    if ( num_samples == 0 )\n        return GAIN_ANALYSIS_OK;\n\n    cursamplepos = 0;\n    batchsamples = num_samples;\n\n    switch ( num_channels) {\n    case  1: right_samples = left_samples;\n    case  2: break;\n    default: return GAIN_ANALYSIS_ERROR;\n    }\n\n    prebufsamples = MAX_ORDER;\n    if ((size_t) prebufsamples > num_samples)\n        prebufsamples = num_samples;\n\n    for ( i = 0; i < prebufsamples; ++i ) {\n        linprebuf[i+MAX_ORDER] = left_samples [i * downsample];\n        rinprebuf[i+MAX_ORDER] = right_samples[i * downsample];\n    }\n\n    while ( batchsamples > 0 ) {\n        cursamples = batchsamples > (long)(sampleWindow-totsamp)  ?  (long)(sampleWindow - totsamp)  :  batchsamples;\n        if ( cursamplepos < MAX_ORDER ) {\n            downsample = 1;\n            curleft  = linpre+cursamplepos;\n            curright = rinpre+cursamplepos;\n            if (cursamples > MAX_ORDER - cursamplepos )\n                cursamples = MAX_ORDER - cursamplepos;\n        }\n        else {\n            downsample = replaygainfilter->downsample;\n            curleft  = left_samples  + cursamplepos * downsample;\n            curright = right_samples + cursamplepos * downsample;\n        }\n\n        filter ( curleft , lstep + totsamp, cursamples, replaygainfilter->AYule, replaygainfilter->BYule, YULE_ORDER, downsample );\n        filter ( curright, rstep + totsamp, cursamples, replaygainfilter->AYule, replaygainfilter->BYule, YULE_ORDER, downsample );\n\n        filter ( lstep + totsamp, lout + totsamp, cursamples, replaygainfilter->AButter, replaygainfilter->BButter, BUTTER_ORDER, 1 );\n        filter ( rstep + totsamp, rout + totsamp, cursamples, replaygainfilter->AButter, replaygainfilter->BButter, BUTTER_ORDER, 1 );\n\n        for ( i = 0; i < cursamples; i++ ) {             /* Get the squared values */\n            lsum += lout [totsamp+i] * lout [totsamp+i];\n            rsum += rout [totsamp+i] * rout [totsamp+i];\n        }\n\n        batchsamples -= cursamples;\n        cursamplepos += cursamples;\n        totsamp      += cursamples;\n        if ( totsamp == sampleWindow ) {  /* Get the Root Mean Square (RMS) for this set of samples */\n            double  val  = STEPS_per_dB * 10. * log10 ( (lsum+rsum) / totsamp * 0.5 + 1.e-37 );\n            int     ival = (int) val;\n            if ( ival <                     0 ) ival = 0;\n            if ( ival >= (int)(sizeof(A)/sizeof(*A)) ) ival = (int)(sizeof(A)/sizeof(*A)) - 1;\n            A [ival]++;\n            lsum = rsum = 0.;\n            memmove ( loutbuf , loutbuf  + totsamp, MAX_ORDER * sizeof(flac_float_t) );\n            memmove ( routbuf , routbuf  + totsamp, MAX_ORDER * sizeof(flac_float_t) );\n            memmove ( lstepbuf, lstepbuf + totsamp, MAX_ORDER * sizeof(flac_float_t) );\n            memmove ( rstepbuf, rstepbuf + totsamp, MAX_ORDER * sizeof(flac_float_t) );\n            totsamp = 0;\n        }\n        if ( totsamp > sampleWindow )   /* somehow I really screwed up: Error in programming! Contact author about totsamp > sampleWindow */\n            return GAIN_ANALYSIS_ERROR;\n    }\n\n    if ( num_samples < MAX_ORDER ) {\n        memmove ( linprebuf,                           linprebuf + num_samples, (MAX_ORDER-num_samples) * sizeof(flac_float_t) );\n        memmove ( rinprebuf,                           rinprebuf + num_samples, (MAX_ORDER-num_samples) * sizeof(flac_float_t) );\n        memcpy  ( linprebuf + MAX_ORDER - num_samples, left_samples,          num_samples             * sizeof(flac_float_t) );\n        memcpy  ( rinprebuf + MAX_ORDER - num_samples, right_samples,         num_samples             * sizeof(flac_float_t) );\n    }\n    else {\n        downsample = replaygainfilter->downsample;\n\n        left_samples  += (num_samples - MAX_ORDER) * downsample;\n        right_samples += (num_samples - MAX_ORDER) * downsample;\n\n        for ( i = 0; i < MAX_ORDER; ++i ) {\n            linprebuf[i] = left_samples [i * downsample];\n            rinprebuf[i] = right_samples[i * downsample];\n        }\n    }\n\n    return GAIN_ANALYSIS_OK;\n}", "path": "flac/src/share/replaygain_analysis/replaygain_analysis.c", "commit_date": "2019-12-08 00:00:00", "repo_name": "xiph/flac", "stars": 1464, "license": "other", "language": "c", "size": 8677}
{"docstring": "/* returns a INIT_GAIN_ANALYSIS_OK if successful, INIT_GAIN_ANALYSIS_ERROR if not */\n", "func_signal": "static struct ReplayGainFilter*\nCreateGainFilter ( long samplefreq )", "code": "{\n    uint32_t i;\n    long maxrate = 0;\n    uint32_t downsample = 1;\n    struct ReplayGainFilter* gainfilter = malloc(sizeof(*gainfilter));\n\n    if ( !gainfilter )\n        return 0;\n\n    while (1) {\n        for ( i = 0; i < sizeof(ReplayGainFilters)/sizeof(ReplayGainFilters[0]); ++i ) {\n            if (maxrate < ReplayGainFilters[i].rate)\n                maxrate = ReplayGainFilters[i].rate;\n\n            if ( ReplayGainFilters[i].rate == samplefreq ) {\n                *gainfilter = ReplayGainFilters[i];\n                gainfilter->downsample = downsample;\n                return gainfilter;\n            }\n        }\n\n        if (samplefreq < maxrate)\n            break;\n\n        while (samplefreq > maxrate) {\n            downsample *= 2;\n            samplefreq /= 2;\n        }\n    }\n\n    free(gainfilter);\n\n    return 0;\n}", "path": "flac/src/share/replaygain_analysis/replaygain_analysis.c", "commit_date": "2019-12-08 00:00:00", "repo_name": "xiph/flac", "stars": 1464, "license": "other", "language": "c", "size": 8677}
{"docstring": "/*\n * UTF-8 equivalents of the C library's wctomb() and mbtowc().\n */\n", "func_signal": "int utf8_mbtowc(int *pwc, const char *s, size_t n)", "code": "{\n  uint8_t c;\n  int wc, i, k;\n\n  if (!n || !s)\n    return 0;\n\n  c = *s;\n  if (c < 0x80) {\n    if (pwc)\n      *pwc = c;\n    return c ? 1 : 0;\n  }\n  else if (c < 0xc2)\n    return -1;\n  else if (c < 0xe0) {\n    if (n >= 2 && (s[1] & 0xc0) == 0x80) {\n      if (pwc)\n\t*pwc = ((c & 0x1f) << 6) | (s[1] & 0x3f);\n      return 2;\n    }\n    else\n      return -1;\n  }\n  else if (c < 0xf0)\n    k = 3;\n  else if (c < 0xf8)\n    k = 4;\n  else if (c < 0xfc)\n    k = 5;\n  else if (c < 0xfe)\n    k = 6;\n  else\n    return -1;\n\n  if (n < (size_t)k)\n    return -1;\n  wc = *s++ & ((1 << (7 - k)) - 1);\n  for (i = 1; i < k; i++) {\n    if ((*s & 0xc0) != 0x80)\n      return -1;\n    wc = (wc << 6) | (*s++ & 0x3f);\n  }\n  if (wc < (1 << (5 * k - 4)))\n    return -1;\n  if (pwc)\n    *pwc = wc;\n  return k;\n}", "path": "flac/src/share/utf8/charset.c", "commit_date": "2017-01-19 00:00:00", "repo_name": "xiph/flac", "stars": 1464, "license": "other", "language": "c", "size": 8677}
{"docstring": "/* return meanings:\n * 0: ok\n * 1: read error\n * 2: seek error\n * 3: not a FLAC file\n */\n", "func_signal": "uint32_t seek_to_first_metadata_block_cb_(FLAC__IOHandle handle, FLAC__IOCallback_Read read_cb, FLAC__IOCallback_Seek seek_cb)", "code": "{\n\tFLAC__byte buffer[4];\n\tsize_t n;\n\tuint32_t i;\n\n\tFLAC__ASSERT(FLAC__STREAM_SYNC_LENGTH == sizeof(buffer));\n\n\t/* skip any id3v2 tag */\n\terrno = 0;\n\tn = read_cb(buffer, 1, 4, handle);\n\tif(errno)\n\t\treturn 1;\n\telse if(n != 4)\n\t\treturn 3;\n\telse if(0 == memcmp(buffer, \"ID3\", 3)) {\n\t\tuint32_t tag_length = 0;\n\n\t\t/* skip to the tag length */\n\t\tif(seek_cb(handle, 2, SEEK_CUR) < 0)\n\t\t\treturn 2;\n\n\t\t/* read the length */\n\t\tfor(i = 0; i < 4; i++) {\n\t\t\tif(read_cb(buffer, 1, 1, handle) < 1 || buffer[0] & 0x80)\n\t\t\t\treturn 1;\n\t\t\ttag_length <<= 7;\n\t\t\ttag_length |= (buffer[0] & 0x7f);\n\t\t}\n\n\t\t/* skip the rest of the tag */\n\t\tif(seek_cb(handle, tag_length, SEEK_CUR) < 0)\n\t\t\treturn 2;\n\n\t\t/* read the stream sync code */\n\t\terrno = 0;\n\t\tn = read_cb(buffer, 1, 4, handle);\n\t\tif(errno)\n\t\t\treturn 1;\n\t\telse if(n != 4)\n\t\t\treturn 3;\n\t}\n\n\t/* check for the fLaC signature */\n\tif(0 == memcmp(FLAC__STREAM_SYNC_STRING, buffer, FLAC__STREAM_SYNC_LENGTH))\n\t\treturn 0;\n\telse\n\t\treturn 3;\n}", "path": "flac/src/libFLAC/metadata_iterators.c", "commit_date": "2019-09-15 00:00:00", "repo_name": "xiph/flac", "stars": 1464, "license": "other", "language": "c", "size": 8677}
{"docstring": "/*\n * Implementation of UTF-8.\n */\n", "func_signal": "static int mbtowc_utf8(void *map, int *pwc, const char *s, size_t n)", "code": "{\n  (void)map;\n  return utf8_mbtowc(pwc, s, n);\n}", "path": "flac/src/share/utf8/charset.c", "commit_date": "2017-01-19 00:00:00", "repo_name": "xiph/flac", "stars": 1464, "license": "other", "language": "c", "size": 8677}
{"docstring": "/* assumes 'handle' is already at beginning of file */\n", "func_signal": "static FLAC__bool chain_rewrite_file_cb_(FLAC__Metadata_Chain *chain, FLAC__IOHandle handle, FLAC__IOCallback_Read read_cb, FLAC__IOCallback_Seek seek_cb, FLAC__IOCallback_Eof eof_cb, FLAC__IOHandle temp_handle, FLAC__IOCallback_Write temp_write_cb)", "code": "{\n\tFLAC__Metadata_SimpleIteratorStatus status;\n\tconst FLAC__Metadata_Node *node;\n\n\tFLAC__ASSERT(0 != chain);\n\tFLAC__ASSERT(0 == chain->filename);\n\tFLAC__ASSERT(0 != chain->head);\n\n\t/* copy the file prefix (data up to first metadata block */\n\tif(!copy_n_bytes_from_file_cb_(handle, read_cb, temp_handle, temp_write_cb, chain->first_offset, &status)) {\n\t\tchain->status = get_equivalent_status_(status);\n\t\treturn false;\n\t}\n\n\t/* write the metadata */\n\tfor(node = chain->head; node; node = node->next) {\n\t\tif(!write_metadata_block_header_cb_(temp_handle, temp_write_cb, node->data)) {\n\t\t\tchain->status = FLAC__METADATA_CHAIN_STATUS_WRITE_ERROR;\n\t\t\treturn false;\n\t\t}\n\t\tif(!write_metadata_block_data_cb_(temp_handle, temp_write_cb, node->data)) {\n\t\t\tchain->status = FLAC__METADATA_CHAIN_STATUS_WRITE_ERROR;\n\t\t\treturn false;\n\t\t}\n\t}\n\t/*FLAC__ASSERT(fflush(), ftello() == chain->last_offset);*/\n\n\t/* copy the file postfix (everything after the metadata) */\n\tif(0 != seek_cb(handle, chain->last_offset, SEEK_SET)) {\n\t\tchain->status = FLAC__METADATA_CHAIN_STATUS_SEEK_ERROR;\n\t\treturn false;\n\t}\n\tif(!copy_remaining_bytes_from_file_cb_(handle, read_cb, eof_cb, temp_handle, temp_write_cb, &status)) {\n\t\tchain->status = get_equivalent_status_(status);\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "path": "flac/src/libFLAC/metadata_iterators.c", "commit_date": "2019-09-15 00:00:00", "repo_name": "xiph/flac", "stars": 1464, "license": "other", "language": "c", "size": 8677}
{"docstring": "/*@@@@add to tests*/\n", "func_signal": "FLAC_API off_t FLAC__metadata_simple_iterator_get_block_offset(const FLAC__Metadata_SimpleIterator *iterator)", "code": "{\n\tFLAC__ASSERT(0 != iterator);\n\tFLAC__ASSERT(0 != iterator->file);\n\n\treturn iterator->offset[iterator->depth];\n}", "path": "flac/src/libFLAC/metadata_iterators.c", "commit_date": "2019-09-15 00:00:00", "repo_name": "xiph/flac", "stars": 1464, "license": "other", "language": "c", "size": 8677}
{"docstring": "/****************************************************************************\n *\n * Local function definitions\n *\n ***************************************************************************/\n", "func_signal": "void pack_uint32_(FLAC__uint32 val, FLAC__byte *b, uint32_t bytes)", "code": "{\n\tuint32_t i;\n\n\tb += bytes;\n\n\tfor(i = 0; i < bytes; i++) {\n\t\t*(--b) = (FLAC__byte)(val & 0xff);\n\t\tval >>= 8;\n\t}\n}", "path": "flac/src/libFLAC/metadata_iterators.c", "commit_date": "2019-09-15 00:00:00", "repo_name": "xiph/flac", "stars": 1464, "license": "other", "language": "c", "size": 8677}
{"docstring": "/* Returns the new length of the chain, or 0 if there was an error. */\n/* WATCHOUT: This can get called multiple times before a write, so\n * it should still work when this happens.\n */\n/* WATCHOUT: Make sure to also update the logic in\n * FLAC__metadata_chain_check_if_tempfile_needed() if the logic here changes.\n */\n", "func_signal": "static FLAC__off_t chain_prepare_for_write_(FLAC__Metadata_Chain *chain, FLAC__bool use_padding)", "code": "{\n\tFLAC__off_t current_length = chain_calculate_length_(chain);\n\n\tif(use_padding) {\n\t\t/* if the metadata shrank and the last block is padding, we just extend the last padding block */\n\t\tif(current_length < chain->initial_length && chain->tail->data->type == FLAC__METADATA_TYPE_PADDING) {\n\t\t\tconst FLAC__off_t delta = chain->initial_length - current_length;\n\t\t\tchain->tail->data->length += delta;\n\t\t\tcurrent_length += delta;\n\t\t\tFLAC__ASSERT(current_length == chain->initial_length);\n\t\t}\n\t\t/* if the metadata shrank more than 4 bytes then there's room to add another padding block */\n\t\telse if(current_length + (FLAC__off_t)FLAC__STREAM_METADATA_HEADER_LENGTH <= chain->initial_length) {\n\t\t\tFLAC__StreamMetadata *padding;\n\t\t\tFLAC__Metadata_Node *node;\n\t\t\tif(0 == (padding = FLAC__metadata_object_new(FLAC__METADATA_TYPE_PADDING))) {\n\t\t\t\tchain->status = FLAC__METADATA_CHAIN_STATUS_MEMORY_ALLOCATION_ERROR;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpadding->length = chain->initial_length - (FLAC__STREAM_METADATA_HEADER_LENGTH + current_length);\n\t\t\tif(0 == (node = node_new_())) {\n\t\t\t\tFLAC__metadata_object_delete(padding);\n\t\t\t\tchain->status = FLAC__METADATA_CHAIN_STATUS_MEMORY_ALLOCATION_ERROR;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tnode->data = padding;\n\t\t\tchain_append_node_(chain, node);\n\t\t\tcurrent_length = chain_calculate_length_(chain);\n\t\t\tFLAC__ASSERT(current_length == chain->initial_length);\n\t\t}\n\t\t/* if the metadata grew but the last block is padding, try cutting the padding to restore the original length so we don't have to rewrite the whole file */\n\t\telse if(current_length > chain->initial_length) {\n\t\t\tconst FLAC__off_t delta = current_length - chain->initial_length;\n\t\t\tif(chain->tail->data->type == FLAC__METADATA_TYPE_PADDING) {\n\t\t\t\t/* if the delta is exactly the size of the last padding block, remove the padding block */\n\t\t\t\tif((FLAC__off_t)chain->tail->data->length + (FLAC__off_t)FLAC__STREAM_METADATA_HEADER_LENGTH == delta) {\n\t\t\t\t\tchain_delete_node_(chain, chain->tail);\n\t\t\t\t\tcurrent_length = chain_calculate_length_(chain);\n\t\t\t\t\tFLAC__ASSERT(current_length == chain->initial_length);\n\t\t\t\t}\n\t\t\t\t/* if there is at least 'delta' bytes of padding, trim the padding down */\n\t\t\t\telse if((FLAC__off_t)chain->tail->data->length >= delta) {\n\t\t\t\t\tchain->tail->data->length -= delta;\n\t\t\t\t\tcurrent_length -= delta;\n\t\t\t\t\tFLAC__ASSERT(current_length == chain->initial_length);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* check sizes of all metadata blocks; reduce padding size if necessary */\n\t{\n\t\tFLAC__Metadata_Node *node;\n\t\tfor (node = chain->head; node; node = node->next) {\n\t\t\tif(node->data->length >= (1u << FLAC__STREAM_METADATA_LENGTH_LEN)) {\n\t\t\t\tif(node->data->type == FLAC__METADATA_TYPE_PADDING) {\n\t\t\t\t\tnode->data->length = (1u << FLAC__STREAM_METADATA_LENGTH_LEN) - 1;\n\t\t\t\t\tcurrent_length = chain_calculate_length_(chain);\n\t\t\t\t} else {\n\t\t\t\t\tchain->status = FLAC__METADATA_CHAIN_STATUS_BAD_METADATA;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn current_length;\n}", "path": "flac/src/libFLAC/metadata_iterators.c", "commit_date": "2019-09-15 00:00:00", "repo_name": "xiph/flac", "stars": 1464, "license": "other", "language": "c", "size": 8677}
{"docstring": "/* rbps stands for residual bits per sample\n *\n *             (ln(2) * err)\n * rbps = log  (-----------)\n *           2 (     n     )\n */\n", "func_signal": "static FLAC__fixedpoint local__compute_rbps_integerized(FLAC__uint32 err, FLAC__uint32 n)", "code": "{\n\tFLAC__uint32 rbps;\n\tuint32_t bits; /* the number of bits required to represent a number */\n\tint fracbits; /* the number of bits of rbps that comprise the fractional part */\n\n\tFLAC__ASSERT(sizeof(rbps) == sizeof(FLAC__fixedpoint));\n\tFLAC__ASSERT(err > 0);\n\tFLAC__ASSERT(n > 0);\n\n\tFLAC__ASSERT(n <= FLAC__MAX_BLOCK_SIZE);\n\tif(err <= n)\n\t\treturn 0;\n\t/*\n\t * The above two things tell us 1) n fits in 16 bits; 2) err/n > 1.\n\t * These allow us later to know we won't lose too much precision in the\n\t * fixed-point division (err<<fracbits)/n.\n\t */\n\n\tfracbits = (8*sizeof(err)) - (FLAC__bitmath_ilog2(err)+1);\n\n\terr <<= fracbits;\n\terr /= n;\n\t/* err now holds err/n with fracbits fractional bits */\n\n\t/*\n\t * Whittle err down to 16 bits max.  16 significant bits is enough for\n\t * our purposes.\n\t */\n\tFLAC__ASSERT(err > 0);\n\tbits = FLAC__bitmath_ilog2(err)+1;\n\tif(bits > 16) {\n\t\terr >>= (bits-16);\n\t\tfracbits -= (bits-16);\n\t}\n\trbps = (FLAC__uint32)err;\n\n\t/* Multiply by fixed-point version of ln(2), with 16 fractional bits */\n\trbps *= FLAC__FP_LN2;\n\tfracbits += 16;\n\tFLAC__ASSERT(fracbits >= 0);\n\n\t/* FLAC__fixedpoint_log2 requires fracbits%4 to be 0 */\n\t{\n\t\tconst int f = fracbits & 3;\n\t\tif(f) {\n\t\t\trbps >>= f;\n\t\t\tfracbits -= f;\n\t\t}\n\t}\n\n\trbps = FLAC__fixedpoint_log2(rbps, fracbits, (uint32_t)(-1));\n\n\tif(rbps == 0)\n\t\treturn 0;\n\n\t/*\n\t * The return value must have 16 fractional bits.  Since the whole part\n\t * of the base-2 log of a 32 bit number must fit in 5 bits, and fracbits\n\t * must be >= -3, these assertion allows us to be able to shift rbps\n\t * left if necessary to get 16 fracbits without losing any bits of the\n\t * whole part of rbps.\n\t *\n\t * There is a slight chance due to accumulated error that the whole part\n\t * will require 6 bits, so we use 6 in the assertion.  Really though as\n\t * long as it fits in 13 bits (32 - (16 - (-3))) we are fine.\n\t */\n\tFLAC__ASSERT((int)FLAC__bitmath_ilog2(rbps)+1 <= fracbits + 6);\n\tFLAC__ASSERT(fracbits >= -3);\n\n\t/* now shift the decimal point into place */\n\tif(fracbits < 16)\n\t\treturn rbps << (16-fracbits);\n\telse if(fracbits > 16)\n\t\treturn rbps >> (fracbits-16);\n\telse\n\t\treturn rbps;\n}", "path": "flac/src/libFLAC/fixed.c", "commit_date": "2017-01-14 00:00:00", "repo_name": "xiph/flac", "stars": 1464, "license": "other", "language": "c", "size": 8677}
{"docstring": "/*@@@@add to tests*/\n", "func_signal": "FLAC_API uint32_t FLAC__metadata_simple_iterator_get_block_length(const FLAC__Metadata_SimpleIterator *iterator)", "code": "{\n\tFLAC__ASSERT(0 != iterator);\n\tFLAC__ASSERT(0 != iterator->file);\n\n\treturn iterator->length;\n}", "path": "flac/src/libFLAC/metadata_iterators.c", "commit_date": "2019-09-15 00:00:00", "repo_name": "xiph/flac", "stars": 1464, "license": "other", "language": "c", "size": 8677}
{"docstring": "/*\n * This is like the standard strcasecmp, but it does not depend\n * on the locale. Locale-dependent functions can be dangerous:\n * we once had a bug involving strcasecmp(\"iso\", \"ISO\") in a\n * Turkish locale!\n *\n * (I'm not really sure what the official standard says\n * about the sign of strcasecmp(\"Z\", \"[\"), but usually\n * we're only interested in whether it's zero.)\n */\n", "func_signal": "static int ascii_strcasecmp(const char *s1, const char *s2)", "code": "{\n  char c1, c2;\n\n  for (;; s1++, s2++) {\n    if (!*s1 || !*s2)\n      break;\n    if (*s1 == *s2)\n      continue;\n    c1 = *s1;\n    if ('a' <= c1 && c1 <= 'z')\n      c1 += 'A' - 'a';\n    c2 = *s2;\n    if ('a' <= c2 && c2 <= 'z')\n      c2 += 'A' - 'a';\n    if (c1 != c2)\n      break;\n  }\n  return (uint8_t)*s1 - (uint8_t)*s2;\n}", "path": "flac/src/share/utf8/charset.c", "commit_date": "2017-01-19 00:00:00", "repo_name": "xiph/flac", "stars": 1464, "license": "other", "language": "c", "size": 8677}
{"docstring": "// Create a Status Info Attribute\n", "func_signal": "SSTP_ATTRIBUTE *SstpNewStatusInfoAttribute(UCHAR attrib_id, UINT status)", "code": "{\n\tSSTP_ATTRIBUTE *a;\n\tUCHAR uc;\n\tBUF *b = NewBuf();\n\n\tuc = 0;\n\tWriteBuf(b, &uc, 1);\n\tWriteBuf(b, &uc, 1);\n\tWriteBuf(b, &uc, 1);\n\tWriteBuf(b, &attrib_id, 1);\n\n\tWriteBufInt(b, status);\n\n\ta = SstpNewAttribute(SSTP_ATTRIB_STATUS_INFO, b->Buf, b->Size);\n\n\tFreeBuf(b);\n\n\treturn a;\n}", "path": "SoftEtherVPN_Stable/src/Cedar/Interop_SSTP.c", "commit_date": "2019-02-28 00:00:00", "repo_name": "SoftEtherVPN/SoftEtherVPN_Stable", "stars": 1694, "license": "apache-2.0", "language": "c", "size": 531035}
{"docstring": "// Build the Attribute\n", "func_signal": "BUF *SstpBuildAttribute(SSTP_ATTRIBUTE *a)", "code": "{\n\tUCHAR uc;\n\tUSHORT us;\n\tBUF *b;\n\t// Validate arguments\n\tif (a == NULL)\n\t{\n\t\treturn NULL;\n\t}\n\n\tb = NewBuf();\n\n\t// Reserved\n\tuc = 0;\n\tWriteBuf(b, &uc, sizeof(UCHAR));\n\n\t// Attribute ID\n\tuc = a->AttributeId;\n\tWriteBuf(b, &uc, sizeof(UCHAR));\n\n\t// LengthPacket\n\ta->TotalLength = a->DataSize + 4;\n\tus = (USHORT)a->TotalLength;\n\tus = Endian16(us);\n\tWriteBuf(b, &us, sizeof(USHORT));\n\n\t// Data\n\tWriteBuf(b, a->Data, a->DataSize);\n\n\treturn b;\n}", "path": "SoftEtherVPN_Stable/src/Cedar/Interop_SSTP.c", "commit_date": "2019-02-28 00:00:00", "repo_name": "SoftEtherVPN/SoftEtherVPN_Stable", "stars": 1694, "license": "apache-2.0", "language": "c", "size": 531035}
{"docstring": "// Release the Attibute\n", "func_signal": "void SstpFreeAttribute(SSTP_ATTRIBUTE *a)", "code": "{\n\t// Validate arguments\n\tif (a == NULL)\n\t{\n\t\treturn;\n\t}\n\n\tFree(a->Data);\n\n\tFree(a);\n}", "path": "SoftEtherVPN_Stable/src/Cedar/Interop_SSTP.c", "commit_date": "2019-02-28 00:00:00", "repo_name": "SoftEtherVPN/SoftEtherVPN_Stable", "stars": 1694, "license": "apache-2.0", "language": "c", "size": 531035}
{"docstring": "// Release the Attribute list\n", "func_signal": "void SstpFreeAttributeList(LIST *o)", "code": "{\n\tUINT i;\n\t// Validate arguments\n\tif (o == NULL)\n\t{\n\t\treturn;\n\t}\n\n\tfor (i = 0;i < LIST_NUM(o);i++)\n\t{\n\t\tSSTP_ATTRIBUTE *a = LIST_DATA(o, i);\n\n\t\tSstpFreeAttribute(a);\n\t}\n\n\tReleaseList(o);\n}", "path": "SoftEtherVPN_Stable/src/Cedar/Interop_SSTP.c", "commit_date": "2019-02-28 00:00:00", "repo_name": "SoftEtherVPN/SoftEtherVPN_Stable", "stars": 1694, "license": "apache-2.0", "language": "c", "size": 531035}
{"docstring": "// Process the SSTP control packet reception\n", "func_signal": "void SstpProcessControlPacket(SSTP_SERVER *s, SSTP_PACKET *p)", "code": "{\n\t// Validate arguments\n\tif (s == NULL || p == NULL || p->IsControl == false)\n\t{\n\t\treturn;\n\t}\n\n\tDebug(\"SSTP Control Packet Recv: Msg = %u, Num = %u\\n\", p->MessageType, LIST_NUM(p->AttibuteList));\n\n\tswitch (p->MessageType)\n\t{\n\tcase SSTP_MSG_CALL_CONNECT_REQUEST:\t\t// Receive a connection request from a client\n\t\tif (s->Aborting == false && s->Disconnecting == false)\n\t\t{\n\t\t\tif (s->Status == SSTP_SERVER_STATUS_REQUEST_PENGING)\n\t\t\t{\n\t\t\t\tSSTP_ATTRIBUTE *protocol_id = SstpFindAttribute(p, SSTP_ATTRIB_ENCAPSULATED_PROTOCOL_ID);\n\t\t\t\tif (protocol_id != NULL && protocol_id->DataSize == 2 &&\n\t\t\t\t\tREAD_USHORT(protocol_id->Data) == SSTP_ENCAPSULATED_PROTOCOL_PPP)\n\t\t\t\t{\n\t\t\t\t\t// Accept the connection request by the PPP protocol\n\t\t\t\t\tSSTP_PACKET *ret;\n\n\t\t\t\t\t// Generation of random numbers\n\t\t\t\t\tRand(s->SentNonce, SSTP_NONCE_SIZE);\n\n\t\t\t\t\tret = SstpNewControlPacketWithAnAttribute(SSTP_MSG_CALL_CONNECT_ACK,\n\t\t\t\t\t\tSstpNewCryptoBindingRequestAttribute(CERT_HASH_PROTOCOL_SHA256, s->SentNonce));\n\n\t\t\t\t\tSstpSendPacket(s, ret);\n\n\t\t\t\t\tSstpFreePacket(ret);\n\n\t\t\t\t\ts->Status = SSTP_SERVER_STATUS_CONNECTED_PENDING;\n\n\t\t\t\t\ts->EstablishedCount++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Refuse to accept for a connection request other than the PPP protocol\n\t\t\t\t\tSSTP_PACKET *ret = SstpNewControlPacketWithAnAttribute(SSTP_MSG_CALL_CONNECT_NAK,\n\t\t\t\t\t\tSstpNewStatusInfoAttribute(SSTP_ATTRIB_ENCAPSULATED_PROTOCOL_ID, ATTRIB_STATUS_VALUE_NOT_SUPPORTED));\n\n\t\t\t\t\tSstpSendPacket(s, ret);\n\n\t\t\t\t\tSstpFreePacket(ret);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase SSTP_MSG_CALL_CONNECTED:\t\t\t// Connection from the client complete\n\t\tif (s->Aborting == false && s->Disconnecting == false)\n\t\t{\n\t\t\tif (s->Status == SSTP_SERVER_STATUS_CONNECTED_PENDING)\n\t\t\t{\n\t\t\t\ts->Status = SSTP_SERVER_STATUS_ESTABLISHED;\n\n\t\t\t\tDebug(\"SSTP Connected.\\n\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase SSTP_MSG_CALL_DISCONNECT:\t\t\t// Receive a disconnect request from the client\n\tcase SSTP_MSG_CALL_DISCONNECT_ACK:\n\t\ts->DisconnectRecved = true;\n\t\tSstpDisconnect(s);\n\t\tbreak;\n\n\tcase SSTP_MSG_CALL_ABORT:\t\t\t\t// Receive a disconnect request from the client\n\t\ts->AbortReceived = true;\n\t\tSstpAbort(s);\n\t\tbreak;\n\t}\n}", "path": "SoftEtherVPN_Stable/src/Cedar/Interop_SSTP.c", "commit_date": "2019-02-28 00:00:00", "repo_name": "SoftEtherVPN/SoftEtherVPN_Stable", "stars": 1694, "license": "apache-2.0", "language": "c", "size": 531035}
{"docstring": "// Send a SSTP packet\n", "func_signal": "void SstpSendPacket(SSTP_SERVER *s, SSTP_PACKET *p)", "code": "{\n\tBUF *b;\n\tBLOCK *block;\n\t// Validate arguments\n\tif (s == NULL || p == NULL)\n\t{\n\t\treturn;\n\t}\n\n\tif (p->IsControl)\n\t{\n\t\tDebug(\"SSTP Control Packet Send: Msg = %u, Num = %u\\n\", p->MessageType, LIST_NUM(p->AttibuteList));\n\t}\n\telse\n\t{\n\t\t//Debug(\"SSTP Data Packet Send: Size=%u\\n\", p->DataSize);\n\t}\n\n\tb = SstpBuildPacket(p);\n\tif (b == NULL)\n\t{\n\t\treturn;\n\t}\n\n\tblock = NewBlock(b->Buf, b->Size, 0);\n\tblock->PriorityQoS = p->IsControl;\n\tFree(b);\n\n\tInsertQueue(s->SendQueue, block);\n}", "path": "SoftEtherVPN_Stable/src/Cedar/Interop_SSTP.c", "commit_date": "2019-02-28 00:00:00", "repo_name": "SoftEtherVPN/SoftEtherVPN_Stable", "stars": 1694, "license": "apache-2.0", "language": "c", "size": 531035}
{"docstring": "// Create a SSTP server\n", "func_signal": "SSTP_SERVER *NewSstpServer(CEDAR *cedar, IP *client_ip, UINT client_port, IP *server_ip,\n\t\t\t\t\t\t   UINT server_port, SOCK_EVENT *se,\n\t\t\t\t\t\t   char *client_host_name, char *crypt_name)", "code": "{\n\tSSTP_SERVER *s = ZeroMalloc(sizeof(SSTP_SERVER));\n\n\ts->LastRecvTick = Tick64();\n\n\tStrCpy(s->ClientHostName, sizeof(s->ClientHostName), client_host_name);\n\tStrCpy(s->ClientCipherName, sizeof(s->ClientCipherName), crypt_name);\n\n\ts->Cedar = cedar;\n\tAddRef(s->Cedar->ref);\n\n\tNewTubePair(&s->TubeSend, &s->TubeRecv, 0);\n\tSetTubeSockEvent(s->TubeSend, se);\n\n\ts->Now = Tick64();\n\n\tCopy(&s->ClientIp, client_ip, sizeof(IP));\n\ts->ClientPort = client_port;\n\tCopy(&s->ServerIp, server_ip, sizeof(IP));\n\ts->ServerPort = server_port;\n\n\ts->SockEvent = se;\n\n\tAddRef(s->SockEvent->ref);\n\n\ts->RecvQueue = NewQueueFast();\n\ts->SendQueue = NewQueueFast();\n\n\ts->Interrupt = NewInterruptManager();\n\n\treturn s;\n}", "path": "SoftEtherVPN_Stable/src/Cedar/Interop_SSTP.c", "commit_date": "2019-02-28 00:00:00", "repo_name": "SoftEtherVPN/SoftEtherVPN_Stable", "stars": 1694, "license": "apache-2.0", "language": "c", "size": 531035}
{"docstring": "// Create a new SSTP control packet\n", "func_signal": "SSTP_PACKET *SstpNewControlPacket(USHORT message_type)", "code": "{\n\tSSTP_PACKET *p = ZeroMalloc(sizeof(SSTP_PACKET));\n\n\tp->IsControl = true;\n\tp->MessageType = message_type;\n\tp->Version = SSTP_VERSION_1;\n\tp->AttibuteList = NewListFast(NULL);\n\n\treturn p;\n}", "path": "SoftEtherVPN_Stable/src/Cedar/Interop_SSTP.c", "commit_date": "2019-02-28 00:00:00", "repo_name": "SoftEtherVPN/SoftEtherVPN_Stable", "stars": 1694, "license": "apache-2.0", "language": "c", "size": 531035}
{"docstring": "// Parse the Attribute list\n", "func_signal": "LIST *SstpParseAttributeList(UCHAR *data, UINT size, SSTP_PACKET *p)", "code": "{\n\tLIST *o;\n\tUSHORT us;\n\tUINT num;\n\t// Validate arguments\n\tif (size == 0 || data == NULL || p == NULL)\n\t{\n\t\treturn NULL;\n\t}\n\n\tif (size < 4)\n\t{\n\t\treturn NULL;\n\t}\n\n\t// Message Type\n\tus = READ_USHORT(data);\n\tp->MessageType = us;\n\tdata += sizeof(USHORT);\n\tsize -= sizeof(USHORT);\n\n\t// Num Attributes\n\tnum = READ_USHORT(data);\n\tdata += sizeof(USHORT);\n\tsize -= sizeof(USHORT);\n\n\t// Attibutes List\n\to = NewListFast(NULL);\n\n\twhile (LIST_NUM(o) < num)\n\t{\n\t\tSSTP_ATTRIBUTE *a = SstpParseAttribute(data, size);\n\n\t\tif (a == NULL)\n\t\t{\n\t\t\tSstpFreeAttributeList(o);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (a->TotalLength > size)\n\t\t{\n\t\t\tSstpFreeAttribute(a);\n\t\t\tSstpFreeAttributeList(o);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tAdd(o, a);\n\n\t\tdata += a->TotalLength;\n\t\tsize -= a->TotalLength;\n\t}\n\n\treturn o;\n}", "path": "SoftEtherVPN_Stable/src/Cedar/Interop_SSTP.c", "commit_date": "2019-02-28 00:00:00", "repo_name": "SoftEtherVPN/SoftEtherVPN_Stable", "stars": 1694, "license": "apache-2.0", "language": "c", "size": 531035}
{"docstring": "// Get the Attibute with the specified ID from SSTP packet\n", "func_signal": "SSTP_ATTRIBUTE *SstpFindAttribute(SSTP_PACKET *p, UCHAR attribute_id)", "code": "{\n\tUINT i;\n\t// Validate arguments\n\tif (p == NULL)\n\t{\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0;i < LIST_NUM(p->AttibuteList);i++)\n\t{\n\t\tSSTP_ATTRIBUTE *a = LIST_DATA(p->AttibuteList, i);\n\n\t\tif (a->AttributeId == attribute_id)\n\t\t{\n\t\t\treturn a;\n\t\t}\n\t}\n\n\treturn NULL;\n}", "path": "SoftEtherVPN_Stable/src/Cedar/Interop_SSTP.c", "commit_date": "2019-02-28 00:00:00", "repo_name": "SoftEtherVPN/SoftEtherVPN_Stable", "stars": 1694, "license": "apache-2.0", "language": "c", "size": 531035}
{"docstring": "// Parse the SSTP packet\n", "func_signal": "SSTP_PACKET *SstpParsePacket(UCHAR *data, UINT size)", "code": "{\n\tSSTP_PACKET *p;\n\tUSHORT len;\n\t// Validate arguments\n\tif (data == NULL || size == 0)\n\t{\n\t\treturn NULL;\n\t}\n\n\tif (size < 4)\n\t{\n\t\treturn NULL;\n\t}\n\n\tp = ZeroMalloc(sizeof(SSTP_PACKET));\n\n\t// Version\n\tp->Version = *((UCHAR *)data);\n\tdata++;\n\tsize--;\n\n\tif (p->Version != SSTP_VERSION_1)\n\t{\n\t\t// Invalid version\n\t\tSstpFreePacket(p);\n\t\treturn NULL;\n\t}\n\n\t// Flag\n\tif ((*((UCHAR *)data)) & 0x01)\n\t{\n\t\tp->IsControl = true;\n\t}\n\tdata++;\n\tsize--;\n\n\t// Length\n\tlen = READ_USHORT(data) & 0xFFF;\n\tdata += sizeof(USHORT);\n\tsize -= sizeof(USHORT);\n\n\tif (len < 4)\n\t{\n\t\t// Invalid size\n\t\tSstpFreePacket(p);\n\t\treturn NULL;\n\t}\n\n\tif (((UINT)(len - 4)) > size)\n\t{\n\t\t// Oversized\n\t\tSstpFreePacket(p);\n\t\treturn NULL;\n\t}\n\n\t// Data\n\tp->DataSize = len - 4;\n\tp->Data = Clone(data, p->DataSize);\n\n\tif (p->IsControl)\n\t{\n\t\t// Parse the Attribute list\n\t\tp->AttibuteList = SstpParseAttributeList(p->Data, p->DataSize, p);\n\n\t\tif (p->AttibuteList == NULL)\n\t\t{\n\t\t\t// Failure of parsing list\n\t\t\tSstpFreePacket(p);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn p;\n}", "path": "SoftEtherVPN_Stable/src/Cedar/Interop_SSTP.c", "commit_date": "2019-02-28 00:00:00", "repo_name": "SoftEtherVPN/SoftEtherVPN_Stable", "stars": 1694, "license": "apache-2.0", "language": "c", "size": 531035}
{"docstring": "// Disconnect the SSTP abnormally\n", "func_signal": "void SstpAbort(SSTP_SERVER *s)", "code": "{\n\t// Validate arguments\n\tif (s == NULL)\n\t{\n\t\treturn;\n\t}\n\n\ts->Aborting = true;\n}", "path": "SoftEtherVPN_Stable/src/Cedar/Interop_SSTP.c", "commit_date": "2019-02-28 00:00:00", "repo_name": "SoftEtherVPN/SoftEtherVPN_Stable", "stars": 1694, "license": "apache-2.0", "language": "c", "size": 531035}
{"docstring": "// Handle the communication of SSTP protocol\n", "func_signal": "bool ProcessSstpHttps(CEDAR *cedar, SOCK *s, SOCK_EVENT *se)", "code": "{\n\tUINT tmp_size = 65536;\n\tUCHAR *tmp_buf;\n\tFIFO *recv_fifo;\n\tFIFO *send_fifo;\n\tSSTP_SERVER *sstp;\n\tbool ret = false;\n\t// Validate arguments\n\tif (cedar == NULL || s == NULL || se == NULL)\n\t{\n\t\treturn false;\n\t}\n\n\ttmp_buf = Malloc(tmp_size);\n\trecv_fifo = NewFifo();\n\tsend_fifo = NewFifo();\n\n\tsstp = NewSstpServer(cedar, &s->RemoteIP, s->RemotePort, &s->LocalIP, s->LocalPort, se,\n\t\ts->RemoteHostname, s->CipherName);\n\n\twhile (true)\n\t{\n\t\tUINT r;\n\t\tbool is_disconnected = false;\n\t\tbool state_changed = false;\n\n\t\t// Receive data over SSL\n\t\twhile (true)\n\t\t{\n\t\t\tr = Recv(s, tmp_buf, tmp_size, true);\n\t\t\tif (r == 0)\n\t\t\t{\n\t\t\t\t// SSL is disconnected\n\t\t\t\tis_disconnected = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (r == SOCK_LATER)\n\t\t\t{\n\t\t\t\t// Data is not received any more\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Queue the received data\n\t\t\t\tWriteFifo(recv_fifo, tmp_buf, r);\n\t\t\t\tstate_changed = true;\n\t\t\t}\n\t\t}\n\n\t\twhile (recv_fifo->size >= 4)\n\t\t{\n\t\t\tUCHAR *first4;\n\t\t\tUINT read_size = 0;\n\t\t\tbool ok = false;\n\t\t\t// Read 4 bytes from the beginning of the receive queue\n\t\t\tfirst4 = ((UCHAR *)recv_fifo->p) + recv_fifo->pos;\n\t\t\tif (first4[0] == SSTP_VERSION_1)\n\t\t\t{\n\t\t\t\tUSHORT len = READ_USHORT(first4 + 2) & 0xFFF;\n\t\t\t\tif (len >= 4)\n\t\t\t\t{\n\t\t\t\t\tok = true;\n\n\t\t\t\t\tif (recv_fifo->size >= len)\n\t\t\t\t\t{\n\t\t\t\t\t\tUCHAR *data;\n\t\t\t\t\t\tBLOCK *b;\n\n\t\t\t\t\t\tread_size = len;\n\t\t\t\t\t\tdata = Malloc(read_size);\n\n\t\t\t\t\t\tReadFifo(recv_fifo, data, read_size);\n\n\t\t\t\t\t\tb = NewBlock(data, read_size, 0);\n\n\t\t\t\t\t\tInsertQueue(sstp->RecvQueue, b);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (read_size == 0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (ok == false)\n\t\t\t{\n\t\t\t\t// Disconnect the connection since a bad packet received\n\t\t\t\tis_disconnected = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Process the timer interrupt\n\t\tSstpProcessInterrupt(sstp);\n\n\t\tif (sstp->Disconnected)\n\t\t{\n\t\t\tis_disconnected = true;\n\t\t}\n\n\t\t// Put the transmission data that SSTP module has generated into the transmission queue\n\t\twhile (true)\n\t\t{\n\t\t\tBLOCK *b = GetNext(sstp->SendQueue);\n\n\t\t\tif (b == NULL)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// When transmit a data packet, If there are packets of more than about\n\t\t\t// 2.5 MB in the transmission queue of the TCP, discard without transmission\n\t\t\tif (b->PriorityQoS || (send_fifo->size <= MAX_BUFFERING_PACKET_SIZE))\n\t\t\t{\n\t\t\t\tWriteFifo(send_fifo, b->Buf, b->Size);\n\t\t\t}\n\n\t\t\tFreeBlock(b);\n\t\t}\n\n\t\t// Data is transmitted over SSL\n\t\twhile (send_fifo->size != 0)\n\t\t{\n\t\t\tr = Send(s, ((UCHAR *)send_fifo->p) + send_fifo->pos, send_fifo->size, true);\n\t\t\tif (r == 0)\n\t\t\t{\n\t\t\t\t// SSL is disconnected\n\t\t\t\tis_disconnected = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (r == SOCK_LATER)\n\t\t\t{\n\t\t\t\t// Can not send any more\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Advance the transmission queue by the amount of the transmitted\n\t\t\t\tReadFifo(send_fifo, NULL, r);\n\t\t\t\tstate_changed = true;\n\t\t\t}\n\t\t}\n\n\t\tif (is_disconnected)\n\t\t{\n\t\t\t// Disconnected\n\t\t\tbreak;\n\t\t}\n\n\t\t// Wait for the next state change\n\t\tif (state_changed == false)\n\t\t{\n\t\t\tUINT select_time = SELECT_TIME;\n\t\t\tUINT r = GetNextIntervalForInterrupt(sstp->Interrupt);\n\t\t\tWaitSockEvent(se, MIN(r, select_time));\n\t\t}\n\t}\n\n\tif (sstp != NULL && sstp->EstablishedCount >= 1)\n\t{\n\t\tret = true;\n\t}\n\n\tFreeSstpServer(sstp);\n\n\tReleaseFifo(recv_fifo);\n\tReleaseFifo(send_fifo);\n\tFree(tmp_buf);\n\n\tYieldCpu();\n\tDisconnect(s);\n\n\treturn ret;\n}", "path": "SoftEtherVPN_Stable/src/Cedar/Interop_SSTP.c", "commit_date": "2019-02-28 00:00:00", "repo_name": "SoftEtherVPN/SoftEtherVPN_Stable", "stars": 1694, "license": "apache-2.0", "language": "c", "size": 531035}
{"docstring": "// Building the SSTP packet\n", "func_signal": "BUF *SstpBuildPacket(SSTP_PACKET *p)", "code": "{\n\tBUF *b;\n\tUCHAR uc;\n\tUSHORT us;\n\t// Validate arguments\n\tif (p == NULL)\n\t{\n\t\treturn NULL;\n\t}\n\n\tb = NewBuf();\n\n\tif (p->IsControl)\n\t{\n\t\tBUF *ab;\n\n\t\tif (p->Data != NULL)\n\t\t{\n\t\t\tFree(p->Data);\n\t\t}\n\n\t\tab = SstpBuildAttributeList(p->AttibuteList, p->MessageType);\n\t\tp->Data = ab->Buf;\n\t\tp->DataSize = ab->Size;\n\t\tFree(ab);\n\t}\n\n\t// Version\n\tuc = SSTP_VERSION_1;\n\tWriteBuf(b, &uc, sizeof(UCHAR));\n\n\t// Flag\n\tuc = p->IsControl ? 1 : 0;\n\tWriteBuf(b, &uc, sizeof(UCHAR));\n\n\t// Length Packet\n\tus = Endian16(p->DataSize + 4);\n\tWriteBuf(b, &us, sizeof(USHORT));\n\n\t// Data\n\tWriteBuf(b, p->Data, p->DataSize);\n\n\treturn b;\n}", "path": "SoftEtherVPN_Stable/src/Cedar/Interop_SSTP.c", "commit_date": "2019-02-28 00:00:00", "repo_name": "SoftEtherVPN/SoftEtherVPN_Stable", "stars": 1694, "license": "apache-2.0", "language": "c", "size": 531035}
{"docstring": "// Release the SSTP server\n", "func_signal": "void FreeSstpServer(SSTP_SERVER *s)", "code": "{\n\t// Validate arguments\n\tif (s == NULL)\n\t{\n\t\treturn;\n\t}\n\n\tTubeDisconnect(s->TubeRecv);\n\tTubeDisconnect(s->TubeSend);\n\n\tWaitThread(s->PPPThread, INFINITE);\n\tReleaseThread(s->PPPThread);\n\n\twhile (true)\n\t{\n\t\tBLOCK *b = GetNext(s->RecvQueue);\n\n\t\tif (b == NULL)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tFreeBlock(b);\n\t}\n\n\twhile (true)\n\t{\n\t\tBLOCK *b = GetNext(s->SendQueue);\n\n\t\tif (b == NULL)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tFreeBlock(b);\n\t}\n\n\tReleaseQueue(s->RecvQueue);\n\tReleaseQueue(s->SendQueue);\n\n\tReleaseSockEvent(s->SockEvent);\n\n\tFreeInterruptManager(s->Interrupt);\n\n\tReleaseCedar(s->Cedar);\n\n\tReleaseTube(s->TubeSend);\n\tReleaseTube(s->TubeRecv);\n\n\tFree(s);\n}", "path": "SoftEtherVPN_Stable/src/Cedar/Interop_SSTP.c", "commit_date": "2019-02-28 00:00:00", "repo_name": "SoftEtherVPN/SoftEtherVPN_Stable", "stars": 1694, "license": "apache-2.0", "language": "c", "size": 531035}
{"docstring": "// Parse the Attribute\n", "func_signal": "SSTP_ATTRIBUTE *SstpParseAttribute(UCHAR *data, UINT size)", "code": "{\n\tSSTP_ATTRIBUTE *a;\n\t// Validate arguments\n\tif (data == NULL || size == 0)\n\t{\n\t\treturn NULL;\n\t}\n\n\ta = ZeroMalloc(sizeof(SSTP_ATTRIBUTE));\n\n\tif (size < 4)\n\t{\n\t\tSstpFreeAttribute(a);\n\t\treturn NULL;\n\t}\n\n\tdata++;\n\tsize--;\n\n\t// Attribute ID\n\ta->AttributeId = *((UCHAR *)data);\n\tdata++;\n\tsize--;\n\n\t// Length\n\ta->TotalLength = READ_USHORT(data) & 0xFFF;\n\tdata += sizeof(USHORT);\n\tsize -= sizeof(USHORT);\n\n\tif (a->TotalLength < 4)\n\t{\n\t\t// Length fraud\n\t\tSstpFreeAttribute(a);\n\t\treturn NULL;\n\t}\n\n\ta->DataSize = a->TotalLength - 4;\n\tif (a->DataSize > size)\n\t{\n\t\t// Length excess\n\t\tSstpFreeAttribute(a);\n\t\treturn NULL;\n\t}\n\n\ta->Data = Clone(data, a->DataSize);\n\n\treturn a;\n}", "path": "SoftEtherVPN_Stable/src/Cedar/Interop_SSTP.c", "commit_date": "2019-02-28 00:00:00", "repo_name": "SoftEtherVPN/SoftEtherVPN_Stable", "stars": 1694, "license": "apache-2.0", "language": "c", "size": 531035}
{"docstring": "// Process the SSTP received packet\n", "func_signal": "void SstpProcessPacket(SSTP_SERVER *s, SSTP_PACKET *p)", "code": "{\n\t// Validate arguments\n\tif (s == NULL || p == NULL)\n\t{\n\t\treturn;\n\t}\n\n\ts->LastRecvTick = s->Now;\n\n\tif (p->IsControl)\n\t{\n\t\t// Control packet\n\t\tSstpProcessControlPacket(s, p);\n\t}\n\telse\n\t{\n\t\t// Data packet\n\t\tSstpProcessDataPacket(s, p);\n\t}\n}", "path": "SoftEtherVPN_Stable/src/Cedar/Interop_SSTP.c", "commit_date": "2019-02-28 00:00:00", "repo_name": "SoftEtherVPN/SoftEtherVPN_Stable", "stars": 1694, "license": "apache-2.0", "language": "c", "size": 531035}
{"docstring": "// Process the SSTP received data packet\n", "func_signal": "void SstpProcessDataPacket(SSTP_SERVER *s, SSTP_PACKET *p)", "code": "{\n\t// Validate arguments\n\tif (s == NULL || p == NULL || p->IsControl)\n\t{\n\t\treturn;\n\t}\n\n\t//Debug(\"SSTP Data Packet Recv: Size = %u\\n\", p->DataSize);\n\n\tif (s->PPPThread == NULL)\n\t{\n\t\t// Create a thread to initialize the new PPP module\n\t\ts->PPPThread = NewPPPSession(s->Cedar, &s->ClientIp, s->ClientPort, &s->ServerIp, s->ServerPort,\n\t\t\ts->TubeSend, s->TubeRecv, SSTP_IPC_POSTFIX, SSTP_IPC_CLIENT_NAME,\n\t\t\ts->ClientHostName, s->ClientCipherName, 0);\n\t}\n\n\t// Pass the received data to the PPP module\n\tTubeSendEx(s->TubeRecv, p->Data, p->DataSize, NULL, true);\n\ts->FlushRecvTube = true;\n}", "path": "SoftEtherVPN_Stable/src/Cedar/Interop_SSTP.c", "commit_date": "2019-02-28 00:00:00", "repo_name": "SoftEtherVPN/SoftEtherVPN_Stable", "stars": 1694, "license": "apache-2.0", "language": "c", "size": 531035}
{"docstring": "// Create a Crypto Binding Request Attribute\n", "func_signal": "SSTP_ATTRIBUTE *SstpNewCryptoBindingRequestAttribute(UCHAR hash_protocol_bitmask, UCHAR *nonce_32bytes)", "code": "{\n\tSSTP_ATTRIBUTE *a;\n\tUCHAR uc;\n\tBUF *b = NewBuf();\n\n\tuc = 0;\n\tWriteBuf(b, &uc, 1);\n\tWriteBuf(b, &uc, 1);\n\tWriteBuf(b, &uc, 1);\n\tWriteBuf(b, &hash_protocol_bitmask, 1);\n\n\tWriteBuf(b, nonce_32bytes, SSTP_NONCE_SIZE);\n\n\ta = SstpNewAttribute(SSTP_ATTRIB_CRYPTO_BINDING_REQ, b->Buf, b->Size);\n\n\tFreeBuf(b);\n\n\treturn a;\n}", "path": "SoftEtherVPN_Stable/src/Cedar/Interop_SSTP.c", "commit_date": "2019-02-28 00:00:00", "repo_name": "SoftEtherVPN/SoftEtherVPN_Stable", "stars": 1694, "license": "apache-2.0", "language": "c", "size": 531035}
{"docstring": "// Release the SSTP packet\n", "func_signal": "void SstpFreePacket(SSTP_PACKET *p)", "code": "{\n\t// Validate arguments\n\tif (p == NULL)\n\t{\n\t\treturn;\n\t}\n\n\tif (p->AttibuteList != NULL)\n\t{\n\t\tSstpFreeAttributeList(p->AttibuteList);\n\t}\n\n\tif (p->Data != NULL)\n\t{\n\t\tFree(p->Data);\n\t}\n\n\tFree(p);\n}", "path": "SoftEtherVPN_Stable/src/Cedar/Interop_SSTP.c", "commit_date": "2019-02-28 00:00:00", "repo_name": "SoftEtherVPN/SoftEtherVPN_Stable", "stars": 1694, "license": "apache-2.0", "language": "c", "size": 531035}
{"docstring": "/**\n * Return command list element at specified time position\n */\n", "func_signal": "LList* VGM_getCommandElementAtTime(VGM* vgm, int time)", "code": "{\n    LList* c = vgm->commands;\n    int result = 0;\n\n    while(c != NULL)\n    {\n        VGMCommand* command = c->element;\n\n        if (result >= time)\n            return c;\n\n        result += VGMCommand_getWaitValue(command);\n        c = c->next;\n    }\n\n    return NULL;\n}", "path": "SGDK/tools/xgmtool/src/vgm.c", "commit_date": "2020-03-06 00:00:00", "repo_name": "Stephane-D/SGDK", "stars": 1616, "license": "mit", "language": "c", "size": 153435}
{"docstring": "// obsolete: replaced by assembly function\n", "func_signal": "void BMP_setPixelsFast_V2D_old(const Vect2D_u16 *crd, u8 col, u16 num)", "code": "{\n    const Vect2D_u16 *v;\n    u8* base;\n    u16 i;\n\n    const u8 mu = 0xF0;\n    const u8 md = 0x0F;\n    const u8 cu = col & mu;\n    const u8 cd = col & md;\n\n    base = bmp_buffer_write;\n    v = crd;\n    i = num;\n\n    while (i--)\n    {\n        const u16 x = v->x;\n        const u16 y = v->y;\n        const u16 off = (y * BMP_PITCH) + (x >> 1);\n        u8* dst = base + off;\n\n        if (x & 1) *dst = (*dst & mu) | cd;\n        else *dst = (*dst & md) | cu;\n\n        // next pixel\n        v++;\n    }\n}", "path": "SGDK/src/bmp.c", "commit_date": "2020-11-02 00:00:00", "repo_name": "Stephane-D/SGDK", "stars": 1616, "license": "mit", "language": "c", "size": 153435}
{"docstring": "/**\n * Return the dual entry for this reg (or NULL if no dual entry)\n */\n", "func_signal": "int* YM2612_getDualReg(int reg)", "code": "{\n    int i;\n\n    for (i = 0; i < DUALS_SIZE; i++)\n    {\n        const int* dual = duals[i];\n\n        if ((dual[0] == reg) || (dual[1] == reg))\n            return (int*) dual;\n    }\n\n    return NULL;\n}", "path": "SGDK/tools/xgmtool/src/ym2612.c", "commit_date": "2015-07-21 00:00:00", "repo_name": "Stephane-D/SGDK", "stars": 1616, "license": "mit", "language": "c", "size": 153435}
{"docstring": "// inlining allow C functions to perform better than assembly methods\n", "func_signal": "inline void BMP_setPixelFast(u16 x, u16 y, u8 col)", "code": "{\n    const u16 off = (y * BMP_PITCH) + (x >> 1);\n    u8* dst = bmp_buffer_write + off;\n\n    if (x & 1) *dst = (*dst & 0xF0) | (col & 0x0F);\n    else *dst = (*dst & 0x0F) | (col & 0xF0);\n}", "path": "SGDK/src/bmp.c", "commit_date": "2020-11-02 00:00:00", "repo_name": "Stephane-D/SGDK", "stars": 1616, "license": "mit", "language": "c", "size": 153435}
{"docstring": "// works only for 8 bits image (x doubled)\n", "func_signal": "void BMP_scale(const u8 *src_buf, u16 src_wb, u16 src_h, u16 src_pitch, u8 *dst_buf, u16 dst_wb, u16 dst_h, u16 dst_pitch)", "code": "{\n    const s32 yd = ((src_h / dst_h) * src_wb) - src_wb;\n    const u16 yr = src_h % dst_h;\n    const s32 xd = src_wb / dst_wb;\n    const u16 xr = src_wb % dst_wb;\n\n    const u32 adj_src = src_pitch - src_wb;\n    const u32 adj_dst = dst_pitch - dst_wb;\n\n    const u8 *src = src_buf;\n    u8 *dst = dst_buf;\n\n    u16 y = dst_h;\n    s16 ye = 0;\n\n    while(y--)\n    {\n        u16 x = dst_wb;\n        s16 xe = 0;\n\n        while(x--)\n        {\n            // write pixel\n            *dst++ = *src;\n\n            // adjust offset\n            src += xd;\n\n            if ((xe += xr) >= (s16) dst_wb)\n            {\n                xe -= dst_wb;\n                src++;\n            }\n        }\n\n        src += adj_src;\n        dst += adj_dst;\n\n        // adjust offset\n        src += yd;\n\n        if ((ye += yr) >= (s16) dst_h)\n        {\n            ye -= dst_h;\n            src += src_wb;\n        }\n    }\n}", "path": "SGDK/src/bmp.c", "commit_date": "2020-11-02 00:00:00", "repo_name": "Stephane-D/SGDK", "stars": 1616, "license": "mit", "language": "c", "size": 153435}
{"docstring": "// obsolete: replaced by assembly function\n", "func_signal": "void BMP_setPixels_old(const Pixel *pixels, u16 num)", "code": "{\n    const Pixel *p;\n    u8* base;\n    u16 i;\n\n    const u8 mu = 0xF0;\n    const u8 md = 0x0F;\n\n    base = bmp_buffer_write;\n    p = pixels;\n    i = num;\n\n    while (i--)\n    {\n        const u16 x = p->pt.x;\n        const u16 y = p->pt.y;\n\n        if ((x < BMP_WIDTH) && (y < BMP_HEIGHT))\n        {\n            const u16 off = (y * BMP_PITCH) + (x >> 1);\n            u8* dst = base + off;\n            const u8 c = p->col;\n\n            if (x & 1) *dst = (*dst & mu) | (c & md);\n            else *dst = (*dst & md) | (c & mu);\n        }\n\n        // next pixel\n        p++;\n    }\n}", "path": "SGDK/src/bmp.c", "commit_date": "2020-11-02 00:00:00", "repo_name": "Stephane-D/SGDK", "stars": 1616, "license": "mit", "language": "c", "size": 153435}
{"docstring": "/*\n * Pack free blocks and return first matching free block\n */\n", "func_signal": "static u16* pack(VRAMRegion *region, u16 nsize)", "code": "{\n    u16 *b;\n    u16 *best;\n    u16 bsize, psize;\n\n    b = region->vram;\n    best = b;\n    bsize = 0;\n\n    while ((psize = *b))\n    {\n        if (psize & USED_MASK)\n        {\n            if (bsize != 0)\n            {\n                 // store packed free memory for this block\n                *best = bsize;\n\n                if (bsize >= nsize)\n                    return best;\n\n                 // reset packed free size\n                 bsize = 0;\n            }\n\n            // point to next memory block\n            b += psize & SIZE_MASK;\n            // remember it in case it becomes free\n            best = b;\n        }\n        else\n        {\n            // increment free size\n            bsize += psize;\n            // clear this memory block as it will be packed\n            *b = 0;\n            // point to next memory block\n            b += psize;\n        }\n    }\n\n    // last free block update\n    if (bsize != 0)\n    {\n        // store packed free size\n        *best = bsize;\n\n        if (bsize >= nsize)\n            return best;\n    }\n\n    return NULL;\n}", "path": "SGDK/src/vram.c", "commit_date": "2020-10-21 00:00:00", "repo_name": "Stephane-D/SGDK", "stars": 1616, "license": "mit", "language": "c", "size": 153435}
{"docstring": "/**\n * Return true if write can be ignored\n */\n", "func_signal": "bool YM2612_canIgnore(int port, int reg)", "code": "{\n    switch (reg)\n    {\n        case 0x22:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x2B:\n            return (port == 1);\n    }\n\n    if ((reg >= 0x30) && (reg < 0xB8))\n        return ((reg & 3) == 3);\n\n    return true;\n}", "path": "SGDK/tools/xgmtool/src/ym2612.c", "commit_date": "2015-07-21 00:00:00", "repo_name": "Stephane-D/SGDK", "stars": 1616, "license": "mit", "language": "c", "size": 153435}
{"docstring": "/**\n * Return the offset of the specified command\n */\n", "func_signal": "int VGM_getOffset(VGM* vgm, VGMCommand* command)", "code": "{\n    LList* curCom = vgm->commands;\n    int result = 0;\n\n    while(curCom != NULL)\n    {\n        VGMCommand* c = curCom->element;\n\n        if (c == command)\n            return result;\n        result += c->size;\n\n        curCom = curCom->next;\n    }\n\n    return -1;\n}", "path": "SGDK/tools/xgmtool/src/vgm.c", "commit_date": "2020-03-06 00:00:00", "repo_name": "Stephane-D/SGDK", "stars": 1616, "license": "mit", "language": "c", "size": 153435}
{"docstring": "/**\n * Return elapsed time when specified command happen\n */\n", "func_signal": "LList* XGC_getCommandElementAtTime(XGM* source, int time)", "code": "{\n    LList* com = source->commands;\n    const int adjTime = (time * 60) / 44100;\n    int result = 0;\n\n    while(com != NULL)\n    {\n        XGMCommand* command = com->element;\n\n        if (result >= adjTime)\n            return com;\n        if (XGCCommand_isFrameSize(command))\n            result++;\n\n        com = com->next;\n    }\n\n    return com;\n}", "path": "SGDK/tools/xgmtool/src/xgc.c", "commit_date": "2018-06-16 00:00:00", "repo_name": "Stephane-D/SGDK", "stars": 1616, "license": "mit", "language": "c", "size": 153435}
{"docstring": "// called on h-interrupt\n", "func_signal": "static void hint()", "code": "{\n    // vborder low\n    if (phase == 0)\n    {\n        const u16 vcnt = GET_VCOUNTER;\n        const u16 scrh = screenHeight;\n        const u16 vborder = (scrh - BMP_HEIGHT) >> 1;\n\n        // enable VDP\n        VDP_setEnable(1);\n        // prepare hint to disable VDP and doing blit process\n        VDP_setHIntCounter((scrh - vborder) - (VDP_getHIntCounter() + vcnt + 3));\n        // update phase\n        phase = 1;\n    }\n    // in active screen\n    else if (phase == 1)\n    {\n        phase = 2;\n    }\n    // vborder high\n    else if (phase == 2)\n    {\n        // disable VDP\n        VDP_setEnable(0);\n        // prepare hint to re enable VDP\n        VDP_setHIntCounter(((screenHeight - BMP_HEIGHT) >> 1) - 1);\n        // update phase\n        phase = 3;\n\n        // flip requested or not complete ? --> start / continu flip\n        if (state & BMP_STAT_FLIPPING) doFlip();\n    }\n}", "path": "SGDK/src/bmp.c", "commit_date": "2020-11-02 00:00:00", "repo_name": "Stephane-D/SGDK", "stars": 1616, "license": "mit", "language": "c", "size": 153435}
{"docstring": "/**\n * Returns commands list to update to the specified YM2612 state\n */\n", "func_signal": "LList* YM2612_getDelta(YM2612* source, YM2612* state)", "code": "{\n    LList* result;\n    int i, port, reg;\n\n    result = NULL;\n\n    // do dual reg first\n    for (i = 0; i < DUALS_SIZE; i++)\n    {\n        const int* dual = duals[i];\n        const int reg0 = dual[0];\n        const int reg1 = dual[1];\n\n        // value is different\n        if (YM2612_isDiff(source, state, 0, reg0) || YM2612_isDiff(source, state, 0, reg1))\n        {\n            // add commands\n            result = insertAfterLList(result, VGMCommand_createYMCommand(0, reg0, YM2612_get(state, 0, reg0)));\n            result = insertAfterLList(result, VGMCommand_createYMCommand(0, reg1, YM2612_get(state, 0, reg1)));\n        }\n        // port 1 too ?\n        if (dual[0] > 0x30)\n        {\n            if (YM2612_isDiff(source, state, 1, reg0) || YM2612_isDiff(source, state, 1, reg1))\n            {\n                // add commands\n                result = insertAfterLList(result, VGMCommand_createYMCommand(1, reg0, YM2612_get(state, 1, reg0)));\n                result = insertAfterLList(result, VGMCommand_createYMCommand(1, reg1, YM2612_get(state, 1, reg1)));\n            }\n        }\n    }\n\n    for (port = 0; port < 2; port++)\n    {\n        for (reg = 0; reg < 0x100; reg++)\n        {\n            // can ignore or special case of KEY ON/OFF register\n            if (YM2612_canIgnore(port, reg) || ((port == 0) && (reg == 0x28)))\n                continue;\n\n            // ignore dual reg\n            if (YM2612_getDualReg(reg) != NULL)\n                continue;\n\n            // value is different --> add command\n            if (YM2612_isDiff(source, state, port, reg))\n                result = insertAfterLList(result, VGMCommand_createYMCommand(port, reg, YM2612_get(state, port, reg)));\n        }\n    }\n\n    return getHeadLList(result);\n}", "path": "SGDK/tools/xgmtool/src/ym2612.c", "commit_date": "2015-07-21 00:00:00", "repo_name": "Stephane-D/SGDK", "stars": 1616, "license": "mit", "language": "c", "size": 153435}
{"docstring": "// obsolete: replaced by assembly function\n", "func_signal": "void BMP_setPixels_V2D_old(const Vect2D_u16 *crd, u8 col, u16 num)", "code": "{\n    const Vect2D_u16 *v;\n    u8* base;\n    u16 i;\n\n    const u8 mu = 0xF0;\n    const u8 md = 0x0F;\n    const u8 cu = col & mu;\n    const u8 cd = col & md;\n\n    base = bmp_buffer_write;\n    v = crd;\n    i = num;\n\n    while (i--)\n    {\n        const u16 x = v->x;\n        const u16 y = v->y;\n\n        if ((x < BMP_WIDTH) && (y < BMP_HEIGHT))\n        {\n            const u16 off = (y * BMP_PITCH) + (x >> 1);\n            u8* dst = base + off;\n\n            if (x & 1) *dst = (*dst & mu) | cd;\n            else *dst = (*dst & md) | cu;\n        }\n\n        // next pixel\n        v++;\n    }\n}", "path": "SGDK/src/bmp.c", "commit_date": "2020-11-02 00:00:00", "repo_name": "Stephane-D/SGDK", "stars": 1616, "license": "mit", "language": "c", "size": 153435}
{"docstring": "/**\n * Return elapsed time when specified command happen\n */\n", "func_signal": "VGMCommand* VGM_getCommandAtTime(VGM* vgm, int time)", "code": "{\n    LList* c = VGM_getCommandElementAtTime(vgm, time);\n\n    if (c != NULL) return c->element;\n\n    return NULL;\n}", "path": "SGDK/tools/xgmtool/src/vgm.c", "commit_date": "2020-03-06 00:00:00", "repo_name": "Stephane-D/SGDK", "stars": 1616, "license": "mit", "language": "c", "size": 153435}
{"docstring": "// inlining allow C functions to perform better than assembly methods\n", "func_signal": "inline u8 BMP_getPixel(u16 x, u16 y)", "code": "{\n    // pixel in screen ?\n    if ((x < BMP_WIDTH) && (y < BMP_HEIGHT)) return BMP_getPixelFast(x, y);\n\n    return 0;\n}", "path": "SGDK/src/bmp.c", "commit_date": "2020-11-02 00:00:00", "repo_name": "Stephane-D/SGDK", "stars": 1616, "license": "mit", "language": "c", "size": 153435}
{"docstring": "// internals helper methods\n///////////////////////////\n", "func_signal": "static void initTilemap(u16 index)", "code": "{\n    vu32 *plctrl;\n    vu16 *pwdata;\n    u16 tile_ind;\n    u32 addr_tilemap;\n    u16 i, j;\n\n    VDP_setAutoInc(2);\n\n    // calculated\n    const u32 offset = BMP_FBTILEMAP_OFFSET;\n\n    if (index == 0)\n    {\n        addr_tilemap = BMP_FB0TILEMAP_BASE + offset;\n        tile_ind = TILE_ATTR_FULL(pal, prio, 0, 0, BMP_FB0TILEINDEX);\n    }\n    else\n    {\n        addr_tilemap = BMP_FB1TILEMAP_BASE + offset;\n        tile_ind = TILE_ATTR_FULL(pal, prio, 0, 0, BMP_FB1TILEINDEX);\n    }\n\n    // point to vdp port\n    plctrl = (u32 *) GFX_CTRL_PORT;\n    pwdata = (u16 *) GFX_DATA_PORT;\n\n    i = BMP_CELLHEIGHT;\n\n    while(i--)\n    {\n        // set destination address for tilemap\n        *plctrl = GFX_WRITE_VRAM_ADDR(addr_tilemap);\n\n        // write tilemap line to VDP\n        j = BMP_CELLWIDTH >> 3;\n\n        while(j--)\n        {\n            *pwdata = tile_ind++;\n            *pwdata = tile_ind++;\n            *pwdata = tile_ind++;\n            *pwdata = tile_ind++;\n            *pwdata = tile_ind++;\n            *pwdata = tile_ind++;\n            *pwdata = tile_ind++;\n            *pwdata = tile_ind++;\n        }\n\n        addr_tilemap += BMP_PLANWIDTH * 2;\n    }\n}", "path": "SGDK/src/bmp.c", "commit_date": "2020-11-02 00:00:00", "repo_name": "Stephane-D/SGDK", "stars": 1616, "license": "mit", "language": "c", "size": 153435}
{"docstring": "/**\n * Return elapsed time (in 1/44100th of second) when specified command happen\n */\n", "func_signal": "int VGM_getTime(VGM* vgm, VGMCommand* command)", "code": "{\n    LList* curCom = vgm->commands;\n    int result = 0;\n\n    while(curCom != NULL)\n    {\n        VGMCommand* c = curCom->element;\n\n        if (c == command)\n            return result;\n        result += VGMCommand_getWaitValue(c);\n\n        curCom = curCom->next;\n    }\n\n    return 0;\n}", "path": "SGDK/tools/xgmtool/src/vgm.c", "commit_date": "2020-03-06 00:00:00", "repo_name": "Stephane-D/SGDK", "stars": 1616, "license": "mit", "language": "c", "size": 153435}
{"docstring": "// inlining allow C functions to perform better than assembly methods\n", "func_signal": "inline u8 BMP_getPixelFast(u16 x, u16 y)", "code": "{\n    const u16 off = (y * BMP_PITCH) + (x >> 1);\n    u8* dst = bmp_buffer_write + off;\n\n    if (x & 1) return *dst >> 4;\n    else  return *dst & 0x0F;\n}", "path": "SGDK/src/bmp.c", "commit_date": "2020-11-02 00:00:00", "repo_name": "Stephane-D/SGDK", "stars": 1616, "license": "mit", "language": "c", "size": 153435}
{"docstring": "// obsolete: replaced by assembly function\n", "func_signal": "void BMP_setPixelsFast_old(const Pixel *pixels, u16 num)", "code": "{\n    const Pixel *p;\n    u8* base;\n    u16 i;\n\n    const u8 mu = 0xF0;\n    const u8 md = 0x0F;\n\n    base = bmp_buffer_write;\n    p = pixels;\n    i = num;\n\n    while (i--)\n    {\n        const u16 x = p->pt.x;\n        const u16 y = p->pt.y;\n        const u16 off = (y * BMP_PITCH) + (x >> 1);\n        u8* dst = base + off;\n        const u8 c = p->col;\n\n        if (x & 1) *dst = (*dst & mu) | (c & md);\n        else *dst = (*dst & md) | (c & mu);\n\n        // next pixel\n        p++;\n    }\n}", "path": "SGDK/src/bmp.c", "commit_date": "2020-11-02 00:00:00", "repo_name": "Stephane-D/SGDK", "stars": 1616, "license": "mit", "language": "c", "size": 153435}
{"docstring": "/**\n * Return elapsed time when specified command happen (in 1/44100 of second)\n */\n", "func_signal": "int XGC_getTime(XGM* source, XGMCommand* command)", "code": "{\n    LList* com = source->commands;\n    int result = -1;\n\n    while(com != NULL)\n    {\n        XGMCommand* c = com->element;\n\n        if (XGCCommand_isFrameSize(c))\n            result++;\n        if (c == command)\n            break;\n\n        com = com->next;\n    }\n\n    // convert in sample (44100 Hz)\n    return (result * 44100) / (source->pal ? 50 : 60);\n}", "path": "SGDK/tools/xgmtool/src/xgc.c", "commit_date": "2018-06-16 00:00:00", "repo_name": "Stephane-D/SGDK", "stars": 1616, "license": "mit", "language": "c", "size": 153435}
{"docstring": "/* This is called directly if the machine doesn't allow varargs\n * macros. */\n", "func_signal": "void\nrs_log_notice_nofn(char const *s, ...)", "code": "{\n    va_list    va;\n\n    va_start(va, s);\n    rs_log_va(RS_LOG_NOTICE, NULL, s, va);\n    va_end(va);\n}", "path": "distcc/src/trace.c", "commit_date": "2019-05-22 00:00:00", "repo_name": "distcc/distcc", "stars": 1984, "license": "gpl-2.0", "language": "c", "size": 18169}
{"docstring": "/**\n * Remove only the logger that exactly matches the specified parameters\n **/\n", "func_signal": "void rs_remove_logger(rs_logger_fn fn,\n                      int max_level,\n                      void *private_ptr,\n                      int private_int)", "code": "{\n    struct rs_logger_list *l, **pl;\n\n    for (pl = &logger_list; *pl; pl = &((*pl)->next)) {\n        l = *pl;\n        if (l->fn == fn\n            && l->max_level == max_level\n            && l->private_ptr == private_ptr\n            && l->private_int == private_int) {\n            /* unhook from list by adjusting whoever points to this. */\n            *pl = l->next;\n            free(l);\n            return;\n        }\n    }\n}", "path": "distcc/src/trace.c", "commit_date": "2019-05-22 00:00:00", "repo_name": "distcc/distcc", "stars": 1984, "license": "gpl-2.0", "language": "c", "size": 18169}
{"docstring": "/**********************************************************************\n * Functions for manipulating the list of loggers\n **********************************************************************/\n", "func_signal": "void rs_remove_all_loggers(void)", "code": "{\n    struct rs_logger_list *l, *next;\n\n    for (l = logger_list; l; l = next) {\n        next = l -> next;       /* save before destruction */\n        free(l);\n    }\n    logger_list = NULL;\n}", "path": "distcc/src/trace.c", "commit_date": "2019-05-22 00:00:00", "repo_name": "distcc/distcc", "stars": 1984, "license": "gpl-2.0", "language": "c", "size": 18169}
{"docstring": "/**\n * Work out a log level from a string name.\n *\n * Returns -1 for invalid names.\n */\n", "func_signal": "int\nrs_loglevel_from_name(const char *name)", "code": "{\n    if (!strcmp(name, \"emerg\") || !strcmp(name, \"emergency\"))\n        return RS_LOG_EMERG;\n    else if (!strcmp(name, \"alert\"))\n        return RS_LOG_ALERT;\n    else if (!strcmp(name, \"critical\") || !strcmp(name, \"crit\"))\n        return RS_LOG_CRIT;\n    else if (!strcmp(name, \"error\") || !strcmp(name, \"err\"))\n        return RS_LOG_ERR;\n    else if (!strcmp(name, \"warning\") || !strcmp(name, \"warn\"))\n        return RS_LOG_WARNING;\n    else if (!strcmp(name, \"notice\") || !strcmp(name, \"note\"))\n        return RS_LOG_NOTICE;\n    else if (!strcmp(name, \"info\"))\n        return RS_LOG_INFO;\n    else if (!strcmp(name, \"debug\"))\n        return RS_LOG_DEBUG;\n\n    return -1;\n}", "path": "distcc/src/trace.c", "commit_date": "2019-05-22 00:00:00", "repo_name": "distcc/distcc", "stars": 1984, "license": "gpl-2.0", "language": "c", "size": 18169}
{"docstring": "/* Heart of the matter */\n", "func_signal": "static void\nrs_log_va(int flags, char const *caller_fn_name, char const *fmt, va_list va)", "code": "{\n    int level = flags & RS_LOG_PRIMASK;\n    struct rs_logger_list *l;\n\n    rs_lazy_default();\n\n    if (level <= rs_trace_level)\n      for (l = logger_list; l; l = l->next)\n          if (level <= l->max_level) {\n              /* We need to use va_copy() here, because functions like vsprintf\n               * may destructively modify their va_list argument, but we need\n               * to ensure that it's still valid next time around the loop. */\n              va_list copied_va;\n              VA_COPY(copied_va, va);\n              l->fn(flags, caller_fn_name,\n                    fmt, copied_va, l->private_ptr, l->private_int);\n              VA_COPY_END(copied_va);\n          }\n}", "path": "distcc/src/trace.c", "commit_date": "2019-05-22 00:00:00", "repo_name": "distcc/distcc", "stars": 1984, "license": "gpl-2.0", "language": "c", "size": 18169}
{"docstring": "/**\n * Prepend @p root_dir to arguments of include options that are absolute.\n **/\n", "func_signal": "static int tweak_include_arguments_for_server(char **argv,\n                                              const char *root_dir)", "code": "{\n    int index_of_first_filename_char = 0;\n    const char *include_option;\n    unsigned int i, j;\n    for (i = 0; argv[i]; ++i) {\n        for (j = 0; include_options[j]; ++j) {\n            if (str_startswith(include_options[j], argv[i])) {\n                if (strcmp(argv[i], include_options[j]) == 0) {\n                    /* \"-I foo\" , change the next argument */\n                    ++i;\n                    include_option = \"\";\n                    index_of_first_filename_char = 0;\n                } else {\n                    /* \"-Ifoo\", change this argument */\n                    include_option = include_options[j];\n                    index_of_first_filename_char = strlen(include_option);\n                }\n                if (argv[i] != NULL) {  /* in case of a dangling -I */\n                    if (argv[i][index_of_first_filename_char] == '/') {\n                        char *buf;\n                        checked_asprintf(&buf, \"%s%s%s\",\n                                 include_option,\n                                 root_dir,\n                                 argv[i] + index_of_first_filename_char);\n                        if (buf == NULL) {\n                            return EXIT_OUT_OF_MEMORY;\n                        }\n                        free(argv[i]);\n                        argv[i] = buf;\n                    }\n                }\n                break;  /* from the inner loop; go look at the next argument */\n            }\n        }\n    }\n    return 0;\n}", "path": "distcc/src/serve.c", "commit_date": "2020-12-18 00:00:00", "repo_name": "distcc/distcc", "stars": 1984, "license": "gpl-2.0", "language": "c", "size": 18169}
{"docstring": "/**\n * Add -MMD and -MF to get a .d file.\n * Find what the dotd target should be (if any).\n * Prepend @p root_dir to every command\n * line argument that refers to a file/dir by an absolute name.\n **/\n", "func_signal": "static int tweak_arguments_for_server(char **argv,\n                                      const char *root_dir,\n                                      const char *deps_fname,\n                                      char **dotd_target,\n                                      char ***tweaked_argv)", "code": "{\n    int ret;\n    *dotd_target = 0;\n    if ((ret = dcc_copy_argv(argv, tweaked_argv, 3)))\n      return 1;\n\n    if ((ret = dcc_convert_mt_to_dotd_target(*tweaked_argv, dotd_target)))\n      return 1;\n\n    if (!dcc_argv_search(*tweaked_argv, \"-MD\") && !dcc_argv_search(*tweaked_argv, \"-MMD\")) {\n        dcc_argv_append(*tweaked_argv, strdup(\"-MMD\"));\n    }\n    dcc_argv_append(*tweaked_argv, strdup(\"-MF\"));\n    dcc_argv_append(*tweaked_argv, strdup(deps_fname));\n\n    tweak_include_arguments_for_server(*tweaked_argv, root_dir);\n    tweak_input_argument_for_server(*tweaked_argv, root_dir);\n    return 0;\n}", "path": "distcc/src/serve.c", "commit_date": "2020-12-18 00:00:00", "repo_name": "distcc/distcc", "stars": 1984, "license": "gpl-2.0", "language": "c", "size": 18169}
{"docstring": "/* This is called directly if the machine doesn't allow varargs\n * macros. */\n", "func_signal": "void\nrs_log_trace_nofn(char const *s, ...)", "code": "{\n    va_list    va;\n\n    va_start(va, s);\n    rs_log_va(RS_LOG_DEBUG, NULL, s, va);\n    va_end(va);\n}", "path": "distcc/src/trace.c", "commit_date": "2019-05-22 00:00:00", "repo_name": "distcc/distcc", "stars": 1984, "license": "gpl-2.0", "language": "c", "size": 18169}
{"docstring": "/**\n * If you don't initialize a logger before first logging, then we\n * write to stderr by default.\n **/\n", "func_signal": "static void rs_lazy_default(void)", "code": "{\n    static int called;\n\n    if (called)\n        return;\n\n    called = 1;\n    if (logger_list == NULL)\n        rs_add_logger(rs_logger_file, RS_LOG_WARNING, NULL, STDERR_FILENO);\n}", "path": "distcc/src/trace.c", "commit_date": "2019-05-22 00:00:00", "repo_name": "distcc/distcc", "stars": 1984, "license": "gpl-2.0", "language": "c", "size": 18169}
{"docstring": "/* Read and execute a job to/from socket.  This is the common entry point no\n * matter what mode the daemon is running in: preforked, nonforked, or\n * ssh/inetd.\n */\n", "func_signal": "int dcc_service_job(int in_fd,\n                    int out_fd,\n                    struct sockaddr *cli_addr,\n                    int cli_len)", "code": "{\n    int ret;\n\n    dcc_job_summary_clear();\n\n    /* Log client name and check access if appropriate.  For ssh connections\n     * the client comes from a unix-domain socket and that's always\n     * allowed. */\n    if ((ret = dcc_check_client(cli_addr, cli_len, opt_allowed)) != 0)\n        goto out;\n\n#ifdef HAVE_GSSAPI\n    /* If requested perform authentication. */\n    if (dcc_auth_enabled) {\n\t    rs_log_info(\"Performing authentication.\");\n\n        if ((ret = dcc_gssapi_check_client(in_fd, out_fd)) != 0) {\n            goto out;\n        }\n    } else {\n\t    rs_log_info(\"No authentication requested.\");\n    }\n\n    /* Context deleted here as we no longer need it.  However, we have it available */\n    /* in case we want to use confidentiality/integrity type services in the future. */\n    if (dcc_auth_enabled) {\n        dcc_gssapi_delete_ctx(&distccd_ctx_handle);\n    }\n#endif\n\n    ret = dcc_run_job(in_fd, out_fd);\n\n    dcc_job_summary();\n\nout:\n    return ret;\n}", "path": "distcc/src/serve.c", "commit_date": "2020-12-18 00:00:00", "repo_name": "distcc/distcc", "stars": 1984, "license": "gpl-2.0", "language": "c", "size": 18169}
{"docstring": "/* This is called directly if the machine doesn't allow varargs\n * macros. */\n", "func_signal": "void\nrs_log_info_nofn(char const *s, ...)", "code": "{\n    va_list    va;\n\n    va_start(va, s);\n    rs_log_va(RS_LOG_INFO, NULL, s, va);\n    va_end(va);\n}", "path": "distcc/src/trace.c", "commit_date": "2019-05-22 00:00:00", "repo_name": "distcc/distcc", "stars": 1984, "license": "gpl-2.0", "language": "c", "size": 18169}
{"docstring": "/**\n * Called by a macro, used on platforms where we can't determine the\n * calling function name.\n */\n", "func_signal": "void\nrs_log0_nofn(int level, char const *fmt, ...)", "code": "{\n    va_list         va;\n\n    va_start(va, fmt);\n    rs_log_va(level, NULL, fmt, va);\n    va_end(va);\n}", "path": "distcc/src/trace.c", "commit_date": "2019-05-22 00:00:00", "repo_name": "distcc/distcc", "stars": 1984, "license": "gpl-2.0", "language": "c", "size": 18169}
{"docstring": "/**\n * Return true if the library contains trace code; otherwise false.\n * If this returns false, then trying to turn trace on will achieve\n * nothing.\n */\n", "func_signal": "int\nrs_supports_trace(void)", "code": "{\n#ifdef DO_RS_TRACE\n    return 1;\n#else\n    return 0;\n#endif                /* !DO_RS_TRACE */\n}", "path": "distcc/src/trace.c", "commit_date": "2019-05-22 00:00:00", "repo_name": "distcc/distcc", "stars": 1984, "license": "gpl-2.0", "language": "c", "size": 18169}
{"docstring": "/* This is called directly if the machine doesn't allow varargs\n * macros. */\n", "func_signal": "void\nrs_log_error_nofn(char const *s, ...)", "code": "{\n    va_list    va;\n\n    va_start(va, s);\n    rs_log_va(RS_LOG_ERR, NULL, s, va);\n    va_end(va);\n}", "path": "distcc/src/trace.c", "commit_date": "2019-05-22 00:00:00", "repo_name": "distcc/distcc", "stars": 1984, "license": "gpl-2.0", "language": "c", "size": 18169}
{"docstring": "/* This is called directly if the machine doesn't allow varargs\n * macros. */\n", "func_signal": "void\nrs_log_warning_nofn(char const *s, ...)", "code": "{\n    va_list    va;\n\n    va_start(va, s);\n    rs_log_va(RS_LOG_WARNING, NULL, s, va);\n    va_end(va);\n}", "path": "distcc/src/trace.c", "commit_date": "2019-05-22 00:00:00", "repo_name": "distcc/distcc", "stars": 1984, "license": "gpl-2.0", "language": "c", "size": 18169}
{"docstring": "/**\n * Make sure there is a masquerade to distcc in LIBDIR/distcc in order to\n * execute a binary of the same name.\n *\n * Before this it was possible to execute arbitrary command after connecting\n * to distcc, which is quite a security risk when combined with any local root\n * privilege escalation exploit. See CVE 2004-2687\n *\n * https://nvd.nist.gov/vuln/detail/CVE-2004-2687\n * https://github.com/distcc/distcc/issues/155\n **/\n", "func_signal": "static int dcc_check_compiler_whitelist(char *_compiler_name)", "code": "{\n    char *compiler_name = _compiler_name;\n\n    /* Support QtCreator by treating /usr/bin and /bin absolute paths as non-absolute\n     * see https://github.com/distcc/distcc/issues/279\n     */\n    const char *creator_paths[] = { \"/bin/\", \"/usr/bin/\", NULL };\n    int i;\n    for (i = 0 ; creator_paths[i] ; ++i) {\n        size_t len = strlen(creator_paths[i]);\n        // /bin and /usr/bin are absolute paths (= compare from the string start)\n        // use strncasecmp() to support case-insensitive / (= on Mac).\n        if (strncasecmp(_compiler_name, creator_paths[i], len) == 0) {\n            compiler_name = _compiler_name + len;\n            // stop at the first hit\n            break;\n        }\n    }\n\n    if (strchr(compiler_name, '/')) {\n        rs_log_crit(\"compiler name <%s> cannot be an absolute path (or must set DISTCC_CMDLIST or pass --enable-tcp-insecure)\", _compiler_name);\n        return EXIT_BAD_ARGUMENTS;\n    }\n\n#ifdef HAVE_FSTATAT\n    int dirfd = open(LIBDIR \"/distcc\", O_RDONLY);\n    if (dirfd < 0) {\n        if (errno == ENOENT)\n            rs_log_crit(\"no %s\", LIBDIR \"/distcc\");\n        return EXIT_DISTCC_FAILED;\n    }\n\n    if (faccessat(dirfd, compiler_name, X_OK, 0) < 0) {\n        char *compiler_path = NULL;\n        if (asprintf(&compiler_path, \"/usr/lib/distcc/%s\", compiler_name) && compiler_path) {\n            if (access(compiler_path, X_OK) < 0) {\n                rs_log_crit(\"%s not in %s or %s whitelist.\", compiler_name, LIBDIR \"/distcc\", \"/usr/lib/distcc\");\n                return EXIT_BAD_ARGUMENTS;           /* ENOENT, EACCESS, etc */\n            }\n            free(compiler_path);\n        }\n    }\n\n    rs_trace(\"%s in\" LIBDIR \"/distcc whitelist\", compiler_name);\n    return 0;\n#else\n    // make do with access():\n    char *compiler_path = NULL;\n    int ret = 0;\n    if (asprintf(&compiler_path, \"%s/distcc/%s\", LIBDIR, compiler_name) && compiler_path) {\n        if (access(compiler_path, X_OK) < 0) {\n            free(compiler_path);\n            /* check /usr/lib/distcc too */\n            if (asprintf(&compiler_path, \"/usr/lib/distcc/%s\", compiler_name) && compiler_path) {\n                if (access(compiler_path, X_OK) < 0) {\n                    rs_log_crit(\"%s not in %s or %s whitelist.\", compiler_name, LIBDIR \"/distcc\", \"/usr/lib/distcc\");\n                    ret = EXIT_BAD_ARGUMENTS;           /* ENOENT, EACCESS, etc */\n                }\n            }\n        }\n        rs_trace(\"%s in\" LIBDIR \"/distcc whitelist\", compiler_name);\n    } else {\n        rs_log_crit(\"Couldn't check if %s is in %s whitelist.\", compiler_name, LIBDIR \"/distcc\");\n        ret = EXIT_DISTCC_FAILED;\n    }\n    if (compiler_path) {\n        free(compiler_path);\n    }\n    return ret;\n#endif\n}", "path": "distcc/src/serve.c", "commit_date": "2020-12-18 00:00:00", "repo_name": "distcc/distcc", "stars": 1984, "license": "gpl-2.0", "language": "c", "size": 18169}
{"docstring": "/* The -MT command line flag does not work as advertised for distcc:\n * it augments, rather than replace, the list of targets in the dotd file.\n * The behavior we want though, is the replacing behavior.\n * So here we delete the \"-MT target\" arguments, and we return the target,\n * for use in the .d rewriting in dotd.c.\n */\n", "func_signal": "static int dcc_convert_mt_to_dotd_target(char **argv, char **dotd_target)", "code": "{\n    int i;\n    *dotd_target = NULL;\n\n    for (i = 0; argv[i]; ++i) {\n        if (strcmp(argv[i], \"-MT\") == 0) {\n            break;\n        }\n    }\n\n    /* if we reached the end without finding -MT, fine. */\n    if (argv[i] == NULL)\n        return 0;\n\n    /* if we find -MT but only at the very end, that's an error. */\n    if (argv[i+1] == NULL) {\n        rs_trace(\"found -MT at the end of the command line\");\n        return 1;\n    }\n\n    /* the dotd_target is the argument of -MT */\n    *dotd_target = argv[i+1];\n\n    /* copy the next-next argument on top of this. */\n    for (; argv[i+2]; ++i) {\n        argv[i] = argv[i+2];\n    }\n\n    /* and then put the terminal null in. */\n    argv[i] = argv[i+2];\n\n    return 0;\n}", "path": "distcc/src/serve.c", "commit_date": "2020-12-18 00:00:00", "repo_name": "distcc/distcc", "stars": 1984, "license": "gpl-2.0", "language": "c", "size": 18169}
{"docstring": "/**\n * Prepend @p root_dir string to source file if absolute.\n **/\n", "func_signal": "static int tweak_input_argument_for_server(char **argv,\n                                           const char *root_dir)", "code": "{\n    unsigned i;\n    /* Look for the source file and act if absolute. Note: dcc_scan_args\n     * rejects compilations with more than one source file. */\n    for (i=0; argv[i]; i++)\n        if (dcc_is_source(argv[i]) && argv[i][0]=='/') {\n            unsigned j = 0;\n            char *prefixed_name;\n            while (argv[i][j] == '/') j++;\n            if (asprintf(&prefixed_name, \"%s/%s\",\n                         root_dir,\n                         argv[i] + j) == -1) {\n                rs_log_crit(\"asprintf failed\");\n                return EXIT_OUT_OF_MEMORY;\n            }\n            rs_trace(\"changed input from \\\"%s\\\" to \\\"%s\\\"\", argv[i],\n                     prefixed_name);\n            free(argv[i]);\n            argv[i] = prefixed_name;\n            dcc_trace_argv(\"command after\", argv);\n            return 0;\n        }\n    return 0;\n}", "path": "distcc/src/serve.c", "commit_date": "2020-12-18 00:00:00", "repo_name": "distcc/distcc", "stars": 1984, "license": "gpl-2.0", "language": "c", "size": 18169}
{"docstring": "/**\n * Copy all server messages to the error file, so that they can be\n * echoed back to the client if necessary.\n **/\n", "func_signal": "static int dcc_add_log_to_file(const char *err_fname)", "code": "{\n    if (dcc_compile_log_fd != -1) {\n        rs_log_crit(\"compile log already open?\");\n        return 0;               /* continue? */\n    }\n\n    dcc_compile_log_fd = open(err_fname, O_WRONLY|O_CREAT|O_TRUNC, 0600);\n    if (dcc_compile_log_fd == -1) {\n        rs_log_error(\"failed to open %s: %s\", err_fname, strerror(errno));\n        return EXIT_IO_ERROR;\n    }\n\n    /* Only send fairly serious errors back */\n    rs_add_logger(rs_logger_file, RS_LOG_WARNING, NULL, dcc_compile_log_fd);\n\n    return 0;\n}", "path": "distcc/src/serve.c", "commit_date": "2020-12-18 00:00:00", "repo_name": "distcc/distcc", "stars": 1984, "license": "gpl-2.0", "language": "c", "size": 18169}
{"docstring": "/**\n * Read a request, run the compiler, and send a response.\n **/\n", "func_signal": "static int dcc_run_job(int in_fd,\n                       int out_fd)", "code": "{\n    char **argv = NULL;\n    char **tweaked_argv = NULL;\n    int status = 0;\n    char *temp_i = NULL, *temp_o = NULL;\n    char *err_fname = NULL, *out_fname = NULL, *deps_fname = NULL;\n    char *temp_dir = NULL; /* for receiving multiple files */\n    int ret = 0, compile_ret = 0;\n    char *orig_input = NULL, *orig_output = NULL;\n    char *orig_input_tmp, *orig_output_tmp;\n    char *dotd_target = NULL;\n    pid_t cc_pid;\n    enum dcc_protover protover;\n    enum dcc_compress compr;\n    struct timeval start, end;\n    int time_ms;\n    char *time_str;\n    int job_result = -1;\n    enum dcc_cpp_where cpp_where;\n    char *server_cwd = NULL;\n    char *client_cwd = NULL;\n    int changed_directory = 0;\n\n    gettimeofday(&start, NULL);\n\n    if ((ret = dcc_make_tmpnam(\"distcc\", \".deps\", &deps_fname)))\n        goto out_cleanup;\n    if ((ret = dcc_make_tmpnam(\"distcc\", \".stderr\", &err_fname)))\n        goto out_cleanup;\n    if ((ret = dcc_make_tmpnam(\"distcc\", \".stdout\", &out_fname)))\n        goto out_cleanup;\n\n    dcc_remove_if_exists(deps_fname);\n    dcc_remove_if_exists(err_fname);\n    dcc_remove_if_exists(out_fname);\n\n    /* Capture any messages relating to this compilation to the same file as\n     * compiler errors so that they can all be sent back to the client. */\n    dcc_add_log_to_file(err_fname);\n\n    /* Ignore SIGPIPE; we consistently check error codes and will see the\n     * EPIPE.  Note that it is set back to the default behaviour when spawning\n     * a child, to handle cases like the assembler dying while its being fed\n     * from the compiler */\n    dcc_ignore_sigpipe(1);\n\n    /* Allow output to accumulate into big packets. */\n    tcp_cork_sock(out_fd, 1);\n\n    if ((ret = dcc_r_request_header(in_fd, &protover)))\n        goto out_cleanup;\n\n    dcc_get_features_from_protover(protover, &compr, &cpp_where);\n\n    if (cpp_where == DCC_CPP_ON_SERVER) {\n        if ((ret = make_temp_dir_and_chdir_for_cpp(in_fd,\n                          &temp_dir, &client_cwd, &server_cwd)))\n            goto out_cleanup;\n        changed_directory = 1;\n    }\n\n    if ((ret = dcc_r_argv(in_fd, \"ARGC\", \"ARGV\", &argv))\n        || (ret = dcc_scan_args(argv, &orig_input_tmp, &orig_output_tmp,\n                                &tweaked_argv)))\n        goto out_cleanup;\n\n    /* The orig_input_tmp and orig_output_tmp values returned by dcc_scan_args()\n     * are aliased with some element of tweaked_argv.  We need to copy them,\n     * because the calls to dcc_set_input() and dcc_set_output() below will\n     * free those elements. */\n    orig_input = strdup(orig_input_tmp);\n    orig_output = strdup(orig_output_tmp);\n    if (orig_input == NULL || orig_output == NULL) {\n      ret = EXIT_OUT_OF_MEMORY;\n      goto out_cleanup;\n    }\n\n    /* Our new argv is what dcc_scan_args put into tweaked_argv */\n    /* Put tweaked_argv into argv, and free old argv */\n    dcc_free_argv(argv);\n    argv = tweaked_argv;\n    tweaked_argv = NULL;\n\n    rs_trace(\"output file %s\", orig_output);\n    if ((ret = dcc_make_tmpnam(\"distccd\", \".o\", &temp_o)))\n        goto out_cleanup;\n\n    /* if the protocol is multi-file, then we need to do the following\n     * in a loop.\n     */\n    if (cpp_where == DCC_CPP_ON_SERVER) {\n        if (dcc_r_many_files(in_fd, temp_dir, compr)\n            || dcc_set_output(argv, temp_o)\n            || tweak_arguments_for_server(argv, temp_dir, deps_fname,\n                                          &dotd_target, &tweaked_argv))\n            goto out_cleanup;\n        /* Repeat the switcharoo trick a few lines above. */\n        dcc_free_argv(argv);\n        argv = tweaked_argv;\n        tweaked_argv = NULL;\n    } else {\n        if ((ret = dcc_input_tmpnam(orig_input, &temp_i)))\n            goto out_cleanup;\n        if ((ret = dcc_r_token_file(in_fd, \"DOTI\", temp_i, compr))\n            || (ret = dcc_set_input(argv, temp_i))\n            || (ret = dcc_set_output(argv, temp_o)))\n            goto out_cleanup;\n    }\n\n    if (!dcc_remap_compiler(&argv[0]))\n        goto out_cleanup;\n\n    if ((ret = dcc_check_compiler_masq(argv[0])))\n        goto out_cleanup;\n\n    if (!opt_enable_tcp_insecure &&\n        !getenv(\"DISTCC_CMDLIST\") &&\n        dcc_check_compiler_whitelist(argv[0]))\n        goto out_cleanup;\n\n    /* unsafe compiler options. See  https://youtu.be/bSkpMdDe4g4?t=53m12s\n       on securing https://godbolt.org/ */\n    char *a;\n    int i;\n    for (i = 0; (a = argv[i]); i++)\n        if (strncmp(a, \"-fplugin=\", strlen(\"-fplugin=\")) == 0 ||\n            strncmp(a, \"-specs=\", strlen(\"-specs=\")) == 0) {\n            rs_log_warning(\"-fplugin= and/or -specs= passed, which are insecure and not supported.\");\n            goto out_cleanup;\n    }\n\n    if ((compile_ret = dcc_spawn_child(argv, &cc_pid,\n                                       \"/dev/null\", out_fname, err_fname))\n        || (compile_ret = dcc_collect_child(\"cc\", cc_pid, &status, in_fd))) {\n        /* We didn't get around to finding a wait status from the actual\n         * compiler */\n        status = W_EXITCODE(compile_ret, 0);\n    }\n\n    if ((ret = dcc_x_result_header(out_fd, protover))\n        || (ret = dcc_x_cc_status(out_fd, status))\n        || (ret = dcc_x_file(out_fd, err_fname, \"SERR\", compr, NULL))\n        || (ret = dcc_x_file(out_fd, out_fname, \"SOUT\", compr, NULL))) {\n          /* We get a protocol derailment if we send DOTO 0 here */\n\n        if (job_result == -1)\n            job_result = STATS_COMPILE_ERROR;\n    } else if (WIFSIGNALED(status) || WEXITSTATUS(status)) {\n        /* Something went wrong, so send DOTO 0 */\n        dcc_x_token_int(out_fd, \"DOTO\", 0);\n\n        if (job_result == -1)\n            job_result = STATS_COMPILE_ERROR;\n    } else {\n        if (cpp_where == DCC_CPP_ON_SERVER) {\n          rs_trace(\"fixing up debug info\");\n          /*\n           * We update the debugging information, replacing all occurrences\n           * of temp_dir (the server temp directory that corresponds to the\n           * client's root directory) with \"/\", to convert server path\n           * names to client path names.  This is safe to do only because\n           * temp_dir is of the form \"/var/tmp/distccd-XXXXXX\" where XXXXXX\n           * is randomly chosen by mkdtemp(), which makes it inconceivably\n           * unlikely that this pattern could occur in the debug info by\n           * chance.\n           */\n          if ((ret = dcc_fix_debug_info(temp_o, \"/\", temp_dir)))\n            goto out_cleanup;\n        }\n        if ((ret = dcc_x_file(out_fd, temp_o, \"DOTO\", compr, NULL)))\n            goto out_cleanup;\n\n        if (cpp_where == DCC_CPP_ON_SERVER) {\n            char *cleaned_dotd;\n            ret = dcc_cleanup_dotd(deps_fname,\n                                   &cleaned_dotd,\n                                   temp_dir,\n                                   dotd_target ? dotd_target : orig_output,\n                                   temp_o);\n            if (ret) goto out_cleanup;\n            ret = dcc_x_file(out_fd, cleaned_dotd, \"DOTD\", compr, NULL);\n            free(cleaned_dotd);\n        }\n\n        job_result = STATS_COMPILE_OK;\n    }\n\n    if (compile_ret == EXIT_IO_ERROR) {\n        job_result = STATS_CLI_DISCONN;\n    } else if (compile_ret == EXIT_TIMEOUT) {\n        job_result = STATS_COMPILE_TIMEOUT;\n    }\n\n    dcc_critique_status(status, argv[0], orig_input, dcc_hostdef_local,\n                        0);\n    tcp_cork_sock(out_fd, 0);\n\n    rs_log(RS_LOG_INFO|RS_LOG_NONAME, \"job complete\");\n\nout_cleanup:\n\n    /* Restore the working directory, if needed. */\n    if (changed_directory) {\n      if (chdir(dcc_daemon_wd) != 0) {\n        rs_log_warning(\"chdir(%s) failed: %s\", dcc_daemon_wd, strerror(errno));\n      }\n    }\n\n    switch (ret) {\n    case EXIT_BUSY: /* overloaded */\n        job_result = STATS_REJ_OVERLOAD;\n        break;\n    case EXIT_IO_ERROR: /* probably client disconnected */\n        job_result = STATS_CLI_DISCONN;\n        break;\n    case EXIT_PROTOCOL_ERROR:\n        job_result = STATS_REJ_BAD_REQ;\n        break;\n    default:\n        if (job_result != STATS_COMPILE_ERROR\n            && job_result != STATS_COMPILE_OK\n        && job_result != STATS_CLI_DISCONN\n        && job_result != STATS_COMPILE_TIMEOUT) {\n            job_result = STATS_OTHER;\n        }\n    }\n\n    gettimeofday(&end, NULL);\n    time_ms = (end.tv_sec - start.tv_sec) * 1000 + (end.tv_usec - start.tv_usec) / 1000;\n\n    dcc_job_summary_append(\" \");\n    dcc_job_summary_append(stats_text[job_result]);\n\n    if (job_result == STATS_COMPILE_OK) {\n        /* special case, also log compiler, file and time */\n        dcc_stats_compile_ok(argv[0], orig_input, start, end, time_ms);\n    } else {\n        dcc_stats_event(job_result);\n    }\n\n    checked_asprintf(&time_str, \" exit:%d sig:%d core:%d ret:%d time:%dms \",\n                     WEXITSTATUS(status), WTERMSIG(status), WCOREDUMP(status),\n                     ret, time_ms);\n    if (time_str != NULL) dcc_job_summary_append(time_str);\n    free(time_str);\n\n    /* append compiler and input file info */\n    if (job_result == STATS_COMPILE_ERROR\n        || job_result == STATS_COMPILE_OK) {\n        dcc_job_summary_append(argv[0]);\n        dcc_job_summary_append(\" \");\n        dcc_job_summary_append(orig_input);\n    }\n\n    dcc_remove_log_to_file();\n    dcc_cleanup_tempfiles();\n\n    free(orig_input);\n    free(orig_output);\n\n    if (argv)\n        dcc_free_argv(argv);\n    if (tweaked_argv)\n        dcc_free_argv(tweaked_argv);\n\n    free(temp_dir);\n    free(temp_i);\n    free(temp_o);\n\n    free(deps_fname);\n    free(err_fname);\n    free(out_fname);\n\n    free(client_cwd);\n    free(server_cwd);\n\n    return ret;\n}", "path": "distcc/src/serve.c", "commit_date": "2020-12-18 00:00:00", "repo_name": "distcc/distcc", "stars": 1984, "license": "gpl-2.0", "language": "c", "size": 18169}
{"docstring": "/*\n * This file implement a virtual file systems (VFS) for the JX9 engine.\n */\n/*\n * Given a string containing the path of a file or directory, this function \n * return the parent directory's path.\n */\n", "func_signal": "JX9_PRIVATE const char * jx9ExtractDirName(const char *zPath, int nByte, int *pLen)", "code": "{\n\tconst char *zEnd = &zPath[nByte - 1];\n\tint c, d;\n\tc = d = '/';\n#ifdef __WINNT__\n\td = '\\\\';\n#endif\n\twhile( zEnd > zPath && ( (int)zEnd[0] != c && (int)zEnd[0] != d ) ){\n\t\tzEnd--;\n\t}\n\t*pLen = (int)(zEnd-zPath);\n#ifdef __WINNT__\n\tif( (*pLen) == (int)sizeof(char) && zPath[0] == '/' ){\n\t\t/* Normalize path on windows */\n\t\treturn \"\\\\\";\n\t}\n#endif\n\tif( zEnd == zPath && ( (int)zEnd[0] != c && (int)zEnd[0] != d) ){\n\t\t/* No separator, return \".\" as the current directory */\n\t\t*pLen = sizeof(char);\n\t\treturn \".\";\n\t}\n\tif( (*pLen) == 0 ){\n\t\t*pLen = sizeof(char);\n#ifdef __WINNT__\n\t\treturn \"\\\\\";\n#else\n\t\treturn \"/\";\n#endif\n\t}\n\treturn zPath;\n}", "path": "unqlite/unqlite.c", "commit_date": "2020-11-11 00:00:00", "repo_name": "symisc/unqlite", "stars": 2019, "license": "other", "language": "c", "size": 2928}
{"docstring": "/*\n * string implode_recursive(string $glue, array $pieces, ...)\n * Purpose\n *  Same as implode() but recurse on arrays.\n * Example:\n *   $a = array('usr', array('home', 'dean'));\n *   print implode_recursive(\"/\", $a);\n *   Will output\n *     usr/home/dean.\n *   While the standard implode would produce.\n *    usr/Array.\n * Parameter\n *  Refer to implode().\n * Return\n *  Refer to implode().\n */\n", "func_signal": "static int jx9Builtin_implode_recursive(jx9_context *pCtx, int nArg, jx9_value **apArg)", "code": "{\n\tstruct implode_data imp_data;\n\tint i = 1;\n\tif( nArg < 1 ){\n\t\t/* Missing argument, return NULL */\n\t\tjx9_result_null(pCtx);\n\t\treturn JX9_OK;\n\t}\n\t/* Prepare the implode context */\n\timp_data.pCtx = pCtx;\n\timp_data.bRecursive = 1;\n\timp_data.bFirst = 1;\n\timp_data.nRecCount = 0;\n\tif( !jx9_value_is_json_array(apArg[0]) ){\n\t\timp_data.zSep = jx9_value_to_string(apArg[0], &imp_data.nSeplen);\n\t}else{\n\t\timp_data.zSep = 0;\n\t\timp_data.nSeplen = 0;\n\t\ti = 0;\n\t}\n\tjx9_result_string(pCtx, \"\", 0); /* Set an empty stirng */\n\t/* Start the 'join' process */\n\twhile( i < nArg ){\n\t\tif( jx9_value_is_json_array(apArg[i]) ){\n\t\t\t/* Iterate throw array entries */\n\t\t\tjx9_array_walk(apArg[i], implode_callback, &imp_data);\n\t\t}else{\n\t\t\tconst char *zData;\n\t\t\tint nLen;\n\t\t\t/* Extract the string representation of the jx9 value */\n\t\t\tzData = jx9_value_to_string(apArg[i], &nLen);\n\t\t\tif( nLen > 0 ){\n\t\t\t\tif( imp_data.nSeplen > 0 ){\n\t\t\t\t\tif( !imp_data.bFirst ){\n\t\t\t\t\t\t/* append the separator first */\n\t\t\t\t\t\tjx9_result_string(pCtx, imp_data.zSep, imp_data.nSeplen);\n\t\t\t\t\t}else{\n\t\t\t\t\t\timp_data.bFirst = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tjx9_result_string(pCtx, zData, nLen);\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\treturn JX9_OK;\n}", "path": "unqlite/unqlite.c", "commit_date": "2020-11-11 00:00:00", "repo_name": "symisc/unqlite", "stars": 2019, "license": "other", "language": "c", "size": 2928}
{"docstring": "/* jx9_int64 (*xRead)(void *, void *, jx9_int64); */\n", "func_signal": "static jx9_int64 UnixFile_Read(void *pUserData, void *pBuffer, jx9_int64 nDatatoRead)", "code": "{\n\tssize_t nRd;\n\tnRd = read(SX_PTR_TO_INT(pUserData), pBuffer, (size_t)nDatatoRead);\n\tif( nRd < 1 ){\n\t\t/* EOF or IO error */\n\t\treturn -1;\n\t}\n\treturn (jx9_int64)nRd;\n}", "path": "unqlite/unqlite.c", "commit_date": "2020-11-11 00:00:00", "repo_name": "symisc/unqlite", "stars": 2019, "license": "other", "language": "c", "size": 2928}
{"docstring": "/*\n * array func_get_args(void)\n *   Returns an array comprising a copy of function's argument list.\n * Parameters\n *  None.\n * Return\n *  Returns an array in which each element is a copy of the corresponding\n *  member of the current user-defined function's argument list.\n *  Otherwise FALSE is returned on failure.\n */\n", "func_signal": "static int vm_builtin_func_get_args(jx9_context *pCtx, int nArg, jx9_value **apArg)", "code": "{\n\tjx9_value *pObj = 0;\n\tjx9_value *pArray;\n\tVmFrame *pFrame;\n\tVmSlot *aSlot;\n\tsxu32 n;\n\t/* Point to the current frame */\n\tpFrame = pCtx->pVm->pFrame;\n\tif( pFrame->pParent == 0 ){\n\t\t/* Global frame, return FALSE */\n\t\tjx9_context_throw_error(pCtx, JX9_CTX_WARNING, \"Called in the global scope\");\n\t\tjx9_result_bool(pCtx, 0);\n\t\treturn SXRET_OK;\n\t}\n\t/* Create a new array */\n\tpArray = jx9_context_new_array(pCtx);\n\tif( pArray == 0 ){\n\t\tSXUNUSED(nArg); /* cc warning */\n\t\tSXUNUSED(apArg);\n\t\tjx9_result_bool(pCtx, 0);\n\t\treturn SXRET_OK;\n\t}\n\t/* Start filling the array with the given arguments */\n\taSlot = (VmSlot *)SySetBasePtr(&pFrame->sArg);\n\tfor( n = 0;  n < SySetUsed(&pFrame->sArg) ; n++ ){\n\t\tpObj = (jx9_value *)SySetAt(&pCtx->pVm->aMemObj, aSlot[n].nIdx);\n\t\tif( pObj ){\n\t\t\tjx9_array_add_elem(pArray, 0/* Automatic index assign*/, pObj);\n\t\t}\n\t}\n\t/* Return the freshly created array */\n\tjx9_result_value(pCtx, pArray);\n\treturn SXRET_OK;\n}", "path": "unqlite/unqlite.c", "commit_date": "2020-11-11 00:00:00", "repo_name": "symisc/unqlite", "stars": 2019, "license": "other", "language": "c", "size": 2928}
{"docstring": "/*\n * [CAPIREF: jx9_array_walk()]\n * Please refer to the official documentation for function purpose and expected parameters.\n */\n", "func_signal": "JX9_PRIVATE int jx9_array_walk(jx9_value *pArray, int (*xWalk)(jx9_value *pValue, jx9_value *, void *), void *pUserData)", "code": "{\n\tint rc;\n\tif( xWalk == 0 ){\n\t\treturn JX9_CORRUPT;\n\t}\n\t/* Make sure we are dealing with a valid hashmap */\n\tif( (pArray->iFlags & MEMOBJ_HASHMAP) == 0 ){\n\t\treturn JX9_CORRUPT;\n\t}\n\t/* Start the walk process */\n\trc = jx9HashmapWalk((jx9_hashmap *)pArray->x.pOther, xWalk, pUserData);\n\treturn rc != JX9_OK ? JX9_ABORT /* User callback request an operation abort*/ : JX9_OK;\n}", "path": "unqlite/unqlite.c", "commit_date": "2020-11-11 00:00:00", "repo_name": "symisc/unqlite", "stars": 2019, "license": "other", "language": "c", "size": 2928}
{"docstring": "/*\n * Return data length.\n */\n", "func_signal": "static int lhCursorDataLength(unqlite_kv_cursor *pCursor,unqlite_int64 *pLen)", "code": "{\n\tlhash_kv_cursor *pCur = (lhash_kv_cursor *)pCursor;\n\tlhcell *pCell;\n\t\n\tif( pCur->iState != L_HASH_CURSOR_STATE_CELL || pCur->pCell == 0 ){\n\t\t/* Invalid state */\n\t\treturn UNQLITE_INVALID;\n\t}\n\t/* Point to the target cell */\n\tpCell = pCur->pCell;\n\t/* Return data length */\n\t*pLen = (unqlite_int64)pCell->nData;\n\treturn UNQLITE_OK;\n}", "path": "unqlite/unqlite.c", "commit_date": "2020-11-11 00:00:00", "repo_name": "symisc/unqlite", "stars": 2019, "license": "other", "language": "c", "size": 2928}
{"docstring": "/*\n * string ltrim(string $str[, string $charlist ])\n *  Strip whitespace (or other characters) from the beginning and end of a string.\n * Parameters\n *  $str\n *   The string that will be trimmed.\n * $charlist\n *   Optionally, the stripped characters can also be specified using the charlist parameter.\n *   Simply list all characters that you want to be stripped.\n *   With .. you can specify a range of characters.\n * Returns.\n *  The processed string.\n */\n", "func_signal": "static int jx9Builtin_ltrim(jx9_context *pCtx, int nArg, jx9_value **apArg)", "code": "{\n\tconst char *zString;\n\tint nLen;\n\tif( nArg < 1 ){\n\t\t/* Missing arguments, return null */\n\t\tjx9_result_null(pCtx);\n\t\treturn JX9_OK;\n\t}\n\t/* Extract the target string */\n\tzString = jx9_value_to_string(apArg[0], &nLen);\n\tif( nLen < 1 ){\n\t\t/* Empty string, return */\n\t\tjx9_result_string(pCtx, \"\", 0);\n\t\treturn JX9_OK;\n\t}\n\t/* Start the trim process */\n\tif( nArg < 2 ){\n\t\tSyString sStr;\n\t\t/* Remove white spaces and NUL byte */\n\t\tSyStringInitFromBuf(&sStr, zString, nLen);\n\t\tSyStringLeftTrimSafe(&sStr);\n\t\tjx9_result_string(pCtx, sStr.zString, (int)sStr.nByte);\n\t}else{\n\t\t/* Char list */\n\t\tconst char *zList;\n\t\tint nListlen;\n\t\tzList = jx9_value_to_string(apArg[1], &nListlen);\n\t\tif( nListlen < 1 ){\n\t\t\t/* Return the string unchanged */\n\t\t\tjx9_result_string(pCtx, zString, nLen);\n\t\t}else{\n\t\t\tconst char *zEnd = &zString[nLen];\n\t\t\tconst char *zCur = zString;\n\t\t\tconst char *zPtr;\n\t\t\tint i;\n\t\t\t/* Left trim */\n\t\t\tfor(;;){\n\t\t\t\tif( zCur >= zEnd ){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tzPtr = zCur;\n\t\t\t\tfor( i = 0 ; i < nListlen ; i++ ){\n\t\t\t\t\tif( zCur < zEnd && zCur[0] == zList[i] ){\n\t\t\t\t\t\tzCur++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( zCur == zPtr ){\n\t\t\t\t\t/* No match, break immediately */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( zCur >= zEnd ){\n\t\t\t\t/* Return the empty string */\n\t\t\t\tjx9_result_string(pCtx, \"\", 0);\n\t\t\t}else{\n\t\t\t\tjx9_result_string(pCtx, zCur, (int)(zEnd-zCur));\n\t\t\t}\n\t\t}\n\t}\n\treturn JX9_OK;\n}", "path": "unqlite/unqlite.c", "commit_date": "2020-11-11 00:00:00", "repo_name": "symisc/unqlite", "stars": 2019, "license": "other", "language": "c", "size": 2928}
{"docstring": "/*\n * [CAPIREF: unqlite_result_string_format()]\n * Please refer to the official documentation for function purpose and expected parameters.\n */\n", "func_signal": "int unqlite_result_string_format(unqlite_context *pCtx, const char *zFormat, ...)", "code": "{\n\tjx9_value *p;\n\tva_list ap;\n\tint rc;\n\tp = pCtx->pRet;\n\tif( (p->iFlags & MEMOBJ_STRING) == 0 ){\n\t\t/* Invalidate any prior representation */\n\t\tjx9MemObjRelease(p);\n\t\tMemObjSetType(p, MEMOBJ_STRING);\n\t}\n\t/* Format the given string */\n\tva_start(ap, zFormat);\n\trc = SyBlobFormatAp(&p->sBlob, zFormat, ap);\n\tva_end(ap);\n\treturn rc;\n}", "path": "unqlite/unqlite.c", "commit_date": "2020-11-11 00:00:00", "repo_name": "symisc/unqlite", "stars": 2019, "license": "other", "language": "c", "size": 2928}
{"docstring": "/*\n * string trim(string $str[, string $charlist ])\n *  Strip whitespace (or other characters) from the beginning and end of a string.\n * Parameters\n *  $str\n *   The string that will be trimmed.\n * $charlist\n *   Optionally, the stripped characters can also be specified using the charlist parameter.\n *   Simply list all characters that you want to be stripped.\n *   With .. you can specify a range of characters.\n * Returns.\n *  Thr processed string.\n */\n", "func_signal": "static int jx9Builtin_trim(jx9_context *pCtx, int nArg, jx9_value **apArg)", "code": "{\n\tconst char *zString;\n\tint nLen;\n\tif( nArg < 1 ){\n\t\t/* Missing arguments, return null */\n\t\tjx9_result_null(pCtx);\n\t\treturn JX9_OK;\n\t}\n\t/* Extract the target string */\n\tzString = jx9_value_to_string(apArg[0], &nLen);\n\tif( nLen < 1 ){\n\t\t/* Empty string, return */\n\t\tjx9_result_string(pCtx, \"\", 0);\n\t\treturn JX9_OK;\n\t}\n\t/* Start the trim process */\n\tif( nArg < 2 ){\n\t\tSyString sStr;\n\t\t/* Remove white spaces and NUL bytes */\n\t\tSyStringInitFromBuf(&sStr, zString, nLen);\n\t\tSyStringFullTrimSafe(&sStr);\n\t\tjx9_result_string(pCtx, sStr.zString, (int)sStr.nByte);\n\t}else{\n\t\t/* Char list */\n\t\tconst char *zList;\n\t\tint nListlen;\n\t\tzList = jx9_value_to_string(apArg[1], &nListlen);\n\t\tif( nListlen < 1 ){\n\t\t\t/* Return the string unchanged */\n\t\t\tjx9_result_string(pCtx, zString, nLen);\n\t\t}else{\n\t\t\tconst char *zEnd = &zString[nLen];\n\t\t\tconst char *zCur = zString;\n\t\t\tconst char *zPtr;\n\t\t\tint i;\n\t\t\t/* Left trim */\n\t\t\tfor(;;){\n\t\t\t\tif( zCur >= zEnd ){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tzPtr = zCur;\n\t\t\t\tfor( i = 0 ; i < nListlen ; i++ ){\n\t\t\t\t\tif( zCur < zEnd && zCur[0] == zList[i] ){\n\t\t\t\t\t\tzCur++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( zCur == zPtr ){\n\t\t\t\t\t/* No match, break immediately */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Right trim */\n\t\t\tzEnd--;\n\t\t\tfor(;;){\n\t\t\t\tif( zEnd <= zCur ){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tzPtr = zEnd;\n\t\t\t\tfor( i = 0 ; i < nListlen ; i++ ){\n\t\t\t\t\tif( zEnd > zCur && zEnd[0] == zList[i] ){\n\t\t\t\t\t\tzEnd--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( zEnd == zPtr ){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( zCur >= zEnd ){\n\t\t\t\t/* Return the empty string */\n\t\t\t\tjx9_result_string(pCtx, \"\", 0);\n\t\t\t}else{\n\t\t\t\tzEnd++;\n\t\t\t\tjx9_result_string(pCtx, zCur, (int)(zEnd-zCur));\n\t\t\t}\n\t\t}\n\t}\n\treturn JX9_OK;\n}", "path": "unqlite/unqlite.c", "commit_date": "2020-11-11 00:00:00", "repo_name": "symisc/unqlite", "stars": 2019, "license": "other", "language": "c", "size": 2928}
{"docstring": "/*\n * bool feof(resource $handle)\n *  Tests for end-of-file on a file pointer.\n * Parameters\n *  $handle\n *   The file pointer.\n * Return\n *  Returns TRUE if the file pointer is at EOF.FALSE otherwise\n */\n", "func_signal": "static int jx9Builtin_feof(jx9_context *pCtx, int nArg, jx9_value **apArg)", "code": "{\n\tconst jx9_io_stream *pStream;\n\tio_private *pDev;\n\tint rc;\n\tif( nArg < 1 || !jx9_value_is_resource(apArg[0]) ){\n\t\t/* Missing/Invalid arguments */\n\t\tjx9_context_throw_error(pCtx, JX9_CTX_WARNING, \"Expecting an IO handle\");\n\t\tjx9_result_bool(pCtx, 1);\n\t\treturn JX9_OK;\n\t}\n\t/* Extract our private data */\n\tpDev = (io_private *)jx9_value_to_resource(apArg[0]);\n\t/* Make sure we are dealing with a valid io_private instance */\n\tif( IO_PRIVATE_INVALID(pDev) ){\n\t\t/*Expecting an IO handle */\n\t\tjx9_context_throw_error(pCtx, JX9_CTX_WARNING, \"Expecting an IO handle\");\n\t\tjx9_result_bool(pCtx, 1);\n\t\treturn JX9_OK;\n\t}\n\t/* Point to the target IO stream device */\n\tpStream = pDev->pStream;\n\tif( pStream == 0 ){\n\t\tjx9_context_throw_error_format(pCtx, JX9_CTX_WARNING, \n\t\t\t\"IO routine(%s) not implemented in the underlying stream(%s) device, JX9 is returning FALSE\", \n\t\t\tjx9_function_name(pCtx), pStream ? pStream->zName : \"null_stream\"\n\t\t\t);\n\t\tjx9_result_bool(pCtx, 1);\n\t\treturn JX9_OK;\n\t}\n\trc = SXERR_EOF;\n\t/* Perform the requested operation */\n\tif( SyBlobLength(&pDev->sBuffer) - pDev->nOfft > 0 ){\n\t\t/* Data is available */\n\t\trc = JX9_OK;\n\t}else{\n\t\tchar zBuf[4096];\n\t\tjx9_int64 n;\n\t\t/* Perform a buffered read */\n\t\tn = pStream->xRead(pDev->pHandle, zBuf, sizeof(zBuf));\n\t\tif( n > 0 ){\n\t\t\t/* Copy buffered data */\n\t\t\tSyBlobAppend(&pDev->sBuffer, zBuf, (sxu32)n);\n\t\t\trc = JX9_OK;\n\t\t}\n\t}\n\t/* EOF or not */\n\tjx9_result_bool(pCtx, rc == SXERR_EOF);\n\treturn JX9_OK;\t\n}", "path": "unqlite/unqlite.c", "commit_date": "2020-11-11 00:00:00", "repo_name": "symisc/unqlite", "stars": 2019, "license": "other", "language": "c", "size": 2928}
{"docstring": "/*\n** Truncate an open file to a specified size\n*/\n", "func_signal": "static int unixTruncate(unqlite_file *id, sxi64 nByte)", "code": "{\n  unixFile *pFile = (unixFile *)id;\n  int rc;\n\n  rc = ftruncate(pFile->h, (off_t)nByte);\n  if( rc ){\n    pFile->lastErrno = errno;\n    return UNQLITE_IOERR;\n  }else{\n    return UNQLITE_OK;\n  }\n}", "path": "unqlite/unqlite.c", "commit_date": "2020-11-11 00:00:00", "repo_name": "symisc/unqlite", "stars": 2019, "license": "other", "language": "c", "size": 2928}
{"docstring": "/*\n * [CAPIREF: unqlite_util_random_string()]\n * Please refer to the official documentation for function purpose and expected parameters.\n */\n", "func_signal": "UNQLITE_APIEXPORT int unqlite_util_random_string(unqlite *pDb,char *zBuf,unsigned int buf_size)", "code": "{\n\tif( UNQLITE_DB_MISUSE(pDb) ){\n\t\treturn UNQLITE_CORRUPT;\n\t}\n\tif( zBuf == 0 || buf_size < 3 ){\n\t\t/* Buffer must be long enough to hold three bytes */\n\t\treturn UNQLITE_INVALID;\n\t}\n#if defined(UNQLITE_ENABLE_THREADS)\n\t /* Acquire DB mutex */\n\t SyMutexEnter(sUnqlMPGlobal.pMutexMethods, pDb->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\n\t if( sUnqlMPGlobal.nThreadingLevel > UNQLITE_THREAD_LEVEL_SINGLE && \n\t\t UNQLITE_THRD_DB_RELEASE(pDb) ){\n\t\t\t return UNQLITE_ABORT; /* Another thread have released this instance */\n\t }\n#endif\n\t /* Generate the random string */\n\t unqlitePagerRandomString(pDb->sDB.pPager,zBuf,buf_size);\n#if defined(UNQLITE_ENABLE_THREADS)\n\t /* Leave DB mutex */\n\t SyMutexLeave(sUnqlMPGlobal.pMutexMethods,pDb->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\n#endif\n\t return UNQLITE_OK;\n}", "path": "unqlite/unqlite.c", "commit_date": "2020-11-11 00:00:00", "repo_name": "symisc/unqlite", "stars": 2019, "license": "other", "language": "c", "size": 2928}
{"docstring": "/*\n * Release all resources consumed by the library.\n * Note: This call is not thread safe. Refer to [unqlite_lib_shutdown()].\n */\n", "func_signal": "static void unqliteCoreShutdown(void)", "code": "{\n\tunqlite *pDb, *pNext;\n\t/* Release all active databases handles */\n\tpDb = sUnqlMPGlobal.pDB;\n\tfor(;;){\n\t\tif( sUnqlMPGlobal.nDB < 1 ){\n\t\t\tbreak;\n\t\t}\n\t\tpNext = pDb->pNext;\n\t\tunqliteDbRelease(pDb); \n\t\tpDb = pNext;\n\t\tsUnqlMPGlobal.nDB--;\n\t}\n\t/* Release the storage methods container */\n\tSySetRelease(&sUnqlMPGlobal.kv_storage);\n#if defined(UNQLITE_ENABLE_THREADS)\n\t/* Release the mutex subsystem */\n\tif( sUnqlMPGlobal.pMutexMethods ){\n\t\tif( sUnqlMPGlobal.pMutex ){\n\t\t\tSyMutexRelease(sUnqlMPGlobal.pMutexMethods, sUnqlMPGlobal.pMutex);\n\t\t\tsUnqlMPGlobal.pMutex = 0;\n\t\t}\n\t\tif( sUnqlMPGlobal.pMutexMethods->xGlobalRelease ){\n\t\t\tsUnqlMPGlobal.pMutexMethods->xGlobalRelease();\n\t\t}\n\t\tsUnqlMPGlobal.pMutexMethods = 0;\n\t}\n\tsUnqlMPGlobal.nThreadingLevel = 0;\n#endif\n\tif( sUnqlMPGlobal.sAllocator.pMethods ){\n\t\t/* Release the memory backend */\n\t\tSyMemBackendRelease(&sUnqlMPGlobal.sAllocator);\n\t}\n\tsUnqlMPGlobal.nMagic = 0x1764;\n\t/* Finally, shutdown the Jx9 library */\n\tjx9_lib_shutdown();\n}", "path": "unqlite/unqlite.c", "commit_date": "2020-11-11 00:00:00", "repo_name": "symisc/unqlite", "stars": 2019, "license": "other", "language": "c", "size": 2928}
{"docstring": "/*\n * float exp(float $arg )\n *  Calculates the exponent of e.\n * Parameter\n *  The number to process.\n * Return\n *  'e' raised to the power of arg.\n */\n", "func_signal": "static int jx9Builtin_exp(jx9_context *pCtx, int nArg, jx9_value **apArg)", "code": "{\n\tdouble r, x;\n\tif( nArg < 1 ){\n\t\t/* Missing argument, return 0 */\n\t\tjx9_result_int(pCtx, 0);\n\t\treturn JX9_OK;\n\t}\n\tx = jx9_value_to_double(apArg[0]);\n\t/* Perform the requested operation */\n\tr = exp(x);\n\t/* store the result back */\n\tjx9_result_double(pCtx, r);\n\treturn JX9_OK;\n}", "path": "unqlite/unqlite.c", "commit_date": "2020-11-11 00:00:00", "repo_name": "symisc/unqlite", "stars": 2019, "license": "other", "language": "c", "size": 2928}
{"docstring": "/*\n * JX9_QUERY_RFC3986\n * Expand 1\n */\n", "func_signal": "static void JX9_JX9_QUERY_RFC3986_Const(jx9_value *pVal, void *pUserData)", "code": "{\n\tSXUNUSED(pUserData); /* cc warning */\n\tjx9_value_int(pVal, 2);\n}", "path": "unqlite/unqlite.c", "commit_date": "2020-11-11 00:00:00", "repo_name": "symisc/unqlite", "stars": 2019, "license": "other", "language": "c", "size": 2928}
{"docstring": "/*\n * float log(float $arg, [int/float $base])\n *  Natural logarithm.\n * Parameter\n *  $arg: The number to process.\n *  $base: The optional logarithmic base to use. (only base-10 is supported)\n * Return\n *  The logarithm of arg to base, if given, or the natural logarithm.\n * Note: \n *  only Natural log and base-10 log are supported. \n */\n", "func_signal": "static int jx9Builtin_log(jx9_context *pCtx, int nArg, jx9_value **apArg)", "code": "{\n\tdouble r, x;\n\tif( nArg < 1 ){\n\t\t/* Missing argument, return 0 */\n\t\tjx9_result_int(pCtx, 0);\n\t\treturn JX9_OK;\n\t}\n\tx = jx9_value_to_double(apArg[0]);\n\t/* Perform the requested operation */\n\tif( nArg == 2 && jx9_value_is_numeric(apArg[1]) && jx9_value_to_int(apArg[1]) == 10 ){\n\t\t/* Base-10 log */\n\t\tr = log10(x);\n\t}else{\n\t\tr = log(x);\n\t}\n\t/* store the result back */\n\tjx9_result_double(pCtx, r);\n\treturn JX9_OK;\n}", "path": "unqlite/unqlite.c", "commit_date": "2020-11-11 00:00:00", "repo_name": "symisc/unqlite", "stars": 2019, "license": "other", "language": "c", "size": 2928}
{"docstring": "/*\n * bool rsort(array &$array[, int $sort_flags = SORT_REGULAR ] )\n * Sort an array in reverse order.\n * Parameters\n *  $array\n *   The input array.\n * $sort_flags\n *  The optional second parameter sort_flags may be used to modify the sorting behavior using these values:\n *  Sorting type flags:\n *   SORT_REGULAR - compare items normally (don't change types)\n *   SORT_NUMERIC - compare items numerically\n *   SORT_STRING - compare items as strings\n * Return\n *  TRUE on success or FALSE on failure.\n */\n", "func_signal": "static int jx9_hashmap_rsort(jx9_context *pCtx, int nArg, jx9_value **apArg)", "code": "{\n\tjx9_hashmap *pMap;\n\t/* Make sure we are dealing with a valid hashmap */\n\tif( nArg < 1 || !jx9_value_is_json_array(apArg[0]) ){\n\t\t/* Missing/Invalid arguments, return FALSE */\n\t\tjx9_result_bool(pCtx, 0);\n\t\treturn JX9_OK;\n\t}\n\t/* Point to the internal representation of the input hashmap */\n\tpMap = (jx9_hashmap *)apArg[0]->x.pOther;\n\tif( pMap->nEntry > 1 ){\n\t\tsxi32 iCmpFlags = 0;\n\t\tif( nArg > 1 ){\n\t\t\t/* Extract comparison flags */\n\t\t\tiCmpFlags = jx9_value_to_int(apArg[1]);\n\t\t\tif( iCmpFlags == 3 /* SORT_REGULAR */ ){\n\t\t\t\tiCmpFlags = 0; /* Standard comparison */\n\t\t\t}\n\t\t}\n\t\t/* Do the merge sort */\n\t\tHashmapMergeSort(pMap, HashmapCmpCallback3, SX_INT_TO_PTR(iCmpFlags));\n\t\t/* Rehash [Do not maintain index association as requested by the JX9 specification] */\n\t\tHashmapSortRehash(pMap);\n\t}\n\t/* All done, return TRUE */\n\tjx9_result_bool(pCtx, 1);\n\treturn JX9_OK;\n}", "path": "unqlite/unqlite.c", "commit_date": "2020-11-11 00:00:00", "repo_name": "symisc/unqlite", "stars": 2019, "license": "other", "language": "c", "size": 2928}
{"docstring": "/*\n * [CAPIREF: unqlite_vm_new_scalar()]\n * Please refer to the official documentation for function purpose and expected parameters.\n */\n", "func_signal": "unqlite_value * unqlite_vm_new_scalar(unqlite_vm *pVm)", "code": "{\n\tunqlite_value *pValue;\n\tif( UNQLITE_VM_MISUSE(pVm) ){\n\t\treturn 0;\n\t}\n#if defined(UNQLITE_ENABLE_THREADS)\n\t /* Acquire VM mutex */\n\t SyMutexEnter(sUnqlMPGlobal.pMutexMethods, pVm->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\n\t if( sUnqlMPGlobal.nThreadingLevel > UNQLITE_THREAD_LEVEL_SINGLE && \n\t\t UNQLITE_THRD_VM_RELEASE(pVm) ){\n\t\t\t return 0; /* Another thread have released this instance */\n\t }\n#endif\n\t pValue = jx9_new_scalar(pVm->pJx9Vm);\n#if defined(UNQLITE_ENABLE_THREADS)\n\t /* Leave DB mutex */\n\t SyMutexLeave(sUnqlMPGlobal.pMutexMethods,pVm->pMutex); /* NO-OP if sUnqlMPGlobal.nThreadingLevel != UNQLITE_THREAD_LEVEL_MULTI */\n#endif\n\treturn pValue;\n}", "path": "unqlite/unqlite.c", "commit_date": "2020-11-11 00:00:00", "repo_name": "symisc/unqlite", "stars": 2019, "license": "other", "language": "c", "size": 2928}
{"docstring": "/*\n * Install a cell in the page table.\n */\n", "func_signal": "static int lhInstallCell(lhcell *pCell)", "code": "{\n\tlhpage *pPage = pCell->pPage->pMaster;\n\tsxu32 iBucket;\n\tif( pPage->nCell < 1 ){\n\t\tsxu32 nTableSize = 32; /* Must be a power of two */\n\t\tlhcell **apTable;\n\t\t/* Allocate a new cell table */\n\t\tapTable = (lhcell **)SyMemBackendAlloc(&pPage->pHash->sAllocator, nTableSize * sizeof(lhcell *));\n\t\tif( apTable == 0 ){\n\t\t\treturn UNQLITE_NOMEM;\n\t\t}\n\t\t/* Zero the new table */\n\t\tSyZero((void *)apTable, nTableSize * sizeof(lhcell *));\n\t\t/* Install it */\n\t\tpPage->apCell = apTable;\n\t\tpPage->nCellSize = nTableSize;\n\t}\n\tiBucket = pCell->nHash & (pPage->nCellSize - 1);\n\tpCell->pNextCol = pPage->apCell[iBucket];\n\tif( pPage->apCell[iBucket] ){\n\t\tpPage->apCell[iBucket]->pPrevCol = pCell;\n\t}\n\tpPage->apCell[iBucket] = pCell;\n\tif( pPage->pFirst == 0 ){\n\t\tpPage->pFirst = pPage->pList = pCell;\n\t}else{\n\t\tMACRO_LD_PUSH(pPage->pList,pCell);\n\t}\n\tpPage->nCell++;\n\tif( (pPage->nCell >= pPage->nCellSize * 3) && pPage->nCell < 100000 ){\n\t\t/* Allocate a new larger table */\n\t\tsxu32 nNewSize = pPage->nCellSize << 1;\n\t\tlhcell *pEntry;\n\t\tlhcell **apNew;\n\t\tsxu32 n;\n\t\t\n\t\tapNew = (lhcell **)SyMemBackendAlloc(&pPage->pHash->sAllocator, nNewSize * sizeof(lhcell *));\n\t\tif( apNew ){\n\t\t\t/* Zero the new table */\n\t\t\tSyZero((void *)apNew, nNewSize * sizeof(lhcell *));\n\t\t\t/* Rehash all entries */\n\t\t\tn = 0;\n\t\t\tpEntry = pPage->pList;\n\t\t\tfor(;;){\n\t\t\t\t/* Loop one */\n\t\t\t\tif( n >= pPage->nCell ){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpEntry->pNextCol = pEntry->pPrevCol = 0;\n\t\t\t\t/* Install in the new bucket */\n\t\t\t\tiBucket = pEntry->nHash & (nNewSize - 1);\n\t\t\t\tpEntry->pNextCol = apNew[iBucket];\n\t\t\t\tif( apNew[iBucket]  ){\n\t\t\t\t\tapNew[iBucket]->pPrevCol = pEntry;\n\t\t\t\t}\n\t\t\t\tapNew[iBucket] = pEntry;\n\t\t\t\t/* Point to the next entry */\n\t\t\t\tpEntry = pEntry->pNext;\n\t\t\t\tn++;\n\t\t\t}\n\t\t\t/* Release the old table and reflect the change */\n\t\t\tSyMemBackendFree(&pPage->pHash->sAllocator,(void *)pPage->apCell);\n\t\t\tpPage->apCell = apNew;\n\t\t\tpPage->nCellSize  = nNewSize;\n\t\t}\n\t}\n\treturn UNQLITE_OK;\n}", "path": "unqlite/unqlite.c", "commit_date": "2020-11-11 00:00:00", "repo_name": "symisc/unqlite", "stars": 2019, "license": "other", "language": "c", "size": 2928}
{"docstring": "/*\n * string strftime(string $format [, int $timestamp = time() ] )\n *  Format a local time/date (PLATFORM INDEPENDANT IMPLEENTATION NOT BASED ON LOCALE)\n * Parameters\n *  $format\n *   The format of the outputted date string (See code above)\n * $timestamp\n *   The optional timestamp parameter is an integer Unix timestamp\n *   that defaults to the current local time if a timestamp is not given.\n *   In other words, it defaults to the value of time(). \n * Return\n * Returns a string formatted according format using the given timestamp\n * or the current local time if no timestamp is given.\n */\n", "func_signal": "static int jx9Builtin_strftime(jx9_context *pCtx, int nArg, jx9_value **apArg)", "code": "{\n\tconst char *zFormat;\n\tint nLen;\n\tSytm sTm;\n\tif( nArg < 1 || !jx9_value_is_string(apArg[0]) ){\n\t\t/* Missing/Invalid argument, return FALSE */\n\t\tjx9_result_bool(pCtx, 0);\n\t\treturn JX9_OK;\n\t}\n\tzFormat = jx9_value_to_string(apArg[0], &nLen);\n\tif( nLen < 1 ){\n\t\t/* Don't bother processing return FALSE */\n\t\tjx9_result_bool(pCtx, 0);\n\t}\n\tif( nArg < 2 ){\n#ifdef __WINNT__\n\t\tSYSTEMTIME sOS;\n\t\tGetSystemTime(&sOS);\n\t\tSYSTEMTIME_TO_SYTM(&sOS, &sTm);\n#else\n\t\tstruct tm *pTm;\n\t\ttime_t t;\n\t\ttime(&t);\n\t\tpTm = localtime(&t);\n\t\tSTRUCT_TM_TO_SYTM(pTm, &sTm);\n#endif\n\t}else{\n\t\t/* Use the given timestamp */\n\t\ttime_t t;\n\t\tstruct tm *pTm;\n\t\tif( jx9_value_is_int(apArg[1]) ){\n\t\t\tt = (time_t)jx9_value_to_int64(apArg[1]);\n\t\t\tpTm = localtime(&t);\n\t\t\tif( pTm == 0 ){\n\t\t\t\ttime(&t);\n\t\t\t}\n\t\t}else{\n\t\t\ttime(&t);\n\t\t}\n\t\tpTm = localtime(&t);\n\t\tSTRUCT_TM_TO_SYTM(pTm, &sTm);\n\t}\n\t/* Format the given string */\n\tjx9Strftime(pCtx, zFormat, nLen, &sTm);\n\tif( jx9_context_result_buf_length(pCtx) < 1 ){\n\t\t/* Nothing was formatted, return FALSE */\n\t\tjx9_result_bool(pCtx, 0);\n\t}\n\treturn JX9_OK;\n}", "path": "unqlite/unqlite.c", "commit_date": "2020-11-11 00:00:00", "repo_name": "symisc/unqlite", "stars": 2019, "license": "other", "language": "c", "size": 2928}
{"docstring": "/**\n *  Reallocate the buffer\n *  @param  str         the buffer to reallocate\n *  @param  size        new size\n */\n", "func_signal": "mystatus_t myhtml_serialization_reallocate(mycore_string_raw_t *str, size_t size)", "code": "{\n    // construct a buffer\n    char *data = (char*)mycore_realloc(str->data, size * sizeof(char));\n\n    // was it ok?\n    if(data == NULL) {\n        memset(str, 0, sizeof(mycore_string_raw_t));\n        return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n    }\n    else {\n        // reallocation succeeded\n        str->data = data;\n        str->size = size;\n    }\n    \n    return MyCORE_STATUS_OK;\n}", "path": "myhtml/source/myhtml/serialization.c", "commit_date": "2018-06-02 00:00:00", "repo_name": "lexborisov/myhtml", "stars": 1622, "license": "lgpl-2.1", "language": "c", "size": 16681}
{"docstring": "/////////////////////////////////////////////////////////\n//// Append API\n////\n/////////////////////////////////////////////////////////\n", "func_signal": "void mycore_string_append(mycore_string_t* str, const char* buff, size_t length)", "code": "{\n    MyCORE_STRING_REALLOC_IF_NEED(str, (length + 1), 0);\n    \n    memcpy(&str->data[str->length], buff, (sizeof(char) * length));\n    \n    str->length += length;\n    str->data[str->length] = '\\0';\n}", "path": "myhtml/source/mycore/mystring.c", "commit_date": "2017-03-21 00:00:00", "repo_name": "lexborisov/myhtml", "stars": 1622, "license": "lgpl-2.1", "language": "c", "size": 16681}
{"docstring": "/////////////////////////////////////////////////////////\n//// Init, Clean, Destroy\n////\n/////////////////////////////////////////////////////////\n", "func_signal": "char * mycore_string_init(mchar_async_t *mchar, size_t node_idx, mycore_string_t* str, size_t size)", "code": "{\n    str->data     = mchar_async_malloc(mchar, node_idx, size);\n    str->size     = size;\n    str->node_idx = node_idx;\n    str->mchar    = mchar;\n    \n    mycore_string_clean(str);\n    \n    return str->data;\n}", "path": "myhtml/source/mycore/mystring.c", "commit_date": "2017-03-21 00:00:00", "repo_name": "lexborisov/myhtml", "stars": 1622, "license": "lgpl-2.1", "language": "c", "size": 16681}
{"docstring": "/* special tonek list */\n", "func_signal": "mystatus_t myhtml_tree_special_list_init(myhtml_tree_special_token_list_t* special)", "code": "{\n    special->size   = 1024;\n    special->length = 0;\n    special->list   = (myhtml_tree_special_token_t *)mycore_malloc(special->size * sizeof(myhtml_tree_special_token_t));\n    \n    if(special->list == NULL)\n        return MyHTML_STATUS_ERROR_MEMORY_ALLOCATION;\n    \n    return MyHTML_STATUS_OK;\n}", "path": "myhtml/source/myhtml/tree.c", "commit_date": "2019-09-06 00:00:00", "repo_name": "lexborisov/myhtml", "stars": 1622, "license": "lgpl-2.1", "language": "c", "size": 16681}
{"docstring": "// stack of template insertion modes\n", "func_signal": "myhtml_tree_insertion_list_t * myhtml_tree_template_insertion_init(myhtml_tree_t* tree)", "code": "{\n    myhtml_tree_insertion_list_t* list = mycore_malloc(sizeof(myhtml_tree_insertion_list_t));\n    \n    list->length = 0;\n    list->size = 1024;\n    list->list = (enum myhtml_insertion_mode*)mycore_malloc(sizeof(enum myhtml_insertion_mode) * list->size);\n    \n    tree->template_insertion = list;\n    \n    return list;\n}", "path": "myhtml/source/myhtml/tree.c", "commit_date": "2019-09-06 00:00:00", "repo_name": "lexborisov/myhtml", "stars": 1622, "license": "lgpl-2.1", "language": "c", "size": 16681}
{"docstring": "/*\n * Entries functions, for all threads\n */\n", "func_signal": "mystatus_t mythread_entry_join(mythread_entry_t* entry, mythread_callback_before_entry_join_f before_join, void* ctx)", "code": "{\n    if(before_join)\n        before_join(entry->context.mythread, entry, ctx);\n    \n    if(mythread_thread_join(entry->context.mythread, entry->thread))\n        return MyCORE_STATUS_ERROR;\n    \n    return MyCORE_STATUS_OK;\n}", "path": "myhtml/source/mycore/mythread.c", "commit_date": "2017-03-21 00:00:00", "repo_name": "lexborisov/myhtml", "stars": 1622, "license": "lgpl-2.1", "language": "c", "size": 16681}
{"docstring": "/**\n *  The serialize function for a single node\n *  @param  tree        the tree to be serialized\n *  @param  node        the node that is going to be serialized \n *  @param  callback    function that will be called for all strings that have to be printed\n *  @param  ptr         user-supplied pointer\n *  @return bool\n */\n", "func_signal": "mystatus_t myhtml_serialization_node_callback(myhtml_tree_node_t* node, mycore_callback_serialize_f callback, void *ptr)", "code": "{\n    switch (node->tag_id) {\n        case MyHTML_TAG__TEXT: {\n            if(myhtml_serialization_node_append_text_node(node, callback, ptr))\n                return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n            \n            break;\n        }\n        case MyHTML_TAG__COMMENT: {\n            if(callback(\"<!--\", 4, ptr))\n                return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n            \n            if(node->token && node->token->str.data) {\n                if(callback(node->token->str.data, node->token->str.length, ptr))\n                    return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n            }\n            \n            if(callback(\"-->\", 3, ptr))\n                return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n            \n            break;\n        }\n        case MyHTML_TAG__DOCTYPE: {\n            if(callback(\"<!DOCTYPE\", 9, ptr))\n                return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n            \n            if(callback(\" \", 1, ptr))\n                return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n            \n            if(node->token) {\n                myhtml_tree_attr_t* attr = node->token->attr_first;\n                \n                if(attr && attr->key.data && attr->key.length) {\n                    if(callback(attr->key.data, attr->key.length, ptr))\n                        return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n                    \n                    attr = attr->next;\n                    \n                    if(attr) {\n                        myhtml_tree_attr_t *system_id = NULL, *public_id = NULL;\n                        \n                        if(attr->value.length == 6) {\n                            if(mycore_strcasecmp(attr->value.data, \"SYSTEM\") == 0) {\n                                system_id = attr->next;\n                            } else if(mycore_strcasecmp(attr->value.data, \"PUBLIC\") == 0) {\n                                public_id = attr->next;\n                                system_id = public_id ? public_id->next : NULL;\n                            }\n                        }\n                        \n                        if(public_id && public_id->value.length > 0) {\n                            if(callback(\" PUBLIC \\\"\", 9, ptr))\n                                return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n                            \n                            if(callback(public_id->value.data, public_id->value.length, ptr))\n                                return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n                            \n                            if(callback(\"\\\"\", 1, ptr))\n                                return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n                        }\n                        \n                        if(system_id && system_id->value.length > 0) {\n                            if(!public_id || public_id->value.length == 0) {\n                                if(callback(\" SYSTEM\", 7, ptr))\n                                    return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n                            }\n                            \n                            if(callback(\" \\\"\", 2, ptr))\n                                return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n                            \n                            if(system_id->value.data && system_id->value.length) {\n                                if(callback(system_id->value.data, system_id->value.length, ptr))\n                                    return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n                            }\n                            \n                            if(callback(\"\\\"\", 1, ptr))\n                                return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n                        }\n                    }\n                }\n            }\n            \n            if(callback(\">\", 1, ptr))\n                return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n            \n            break;\n        }\n        default: {\n            size_t length;\n            const char *tag = myhtml_tag_name_by_id(node->tree, node->tag_id, &length);\n\n            if(callback(\"<\", 1, ptr))\n                return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n            \n            if(callback(tag, length, ptr))\n                return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n            \n            if(node->token) {\n                if(myhtml_serialization_attributes(node->tree, node->token->attr_first, callback, ptr))\n                    return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n            }\n            \n            if(callback(\">\", 1, ptr))\n                return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n            \n            break;\n        }\n    }\n    \n    return MyCORE_STATUS_OK;\n}", "path": "myhtml/source/myhtml/serialization.c", "commit_date": "2018-06-02 00:00:00", "repo_name": "lexborisov/myhtml", "stars": 1622, "license": "lgpl-2.1", "language": "c", "size": 16681}
{"docstring": "// // //\n// convert only one 002345 (\\002345) to code point\n//\n", "func_signal": "size_t mycore_incoming_buffer_convert_one_escaped_to_code_point(mycore_incoming_buffer_t **inc_buf, size_t *relative_pos)", "code": "{\n    const unsigned char *u_data;\n    mycore_incoming_buffer_t *current = *inc_buf;\n    \n    if(*relative_pos >= current->size) {\n        *relative_pos = 0;\n        current = current->next;\n    }\n    \n    u_data = (const unsigned char*)current->data;\n    \n    unsigned int consume = 0;\n    size_t code_point = 0;\n    \n    while(current)\n    {\n        if(mycore_string_chars_num_map[ u_data[*relative_pos] ] != 0xff && consume < 6) {\n            code_point <<= 4;\n            code_point |= mycore_string_chars_hex_map[ u_data[*relative_pos] ];\n            \n            ++consume;\n        }\n        else\n            break;\n        \n        *relative_pos += 1;\n        \n        if(*relative_pos >= current->size)\n        {\n            if(current->next == NULL)\n                break;\n            \n            *relative_pos = 0;\n            \n            u_data  = (const unsigned char*)current->data;\n            current = current->next;\n        }\n    }\n    \n    *inc_buf = current;\n    \n    return code_point;\n}", "path": "myhtml/source/mycore/incoming.c", "commit_date": "2017-03-21 00:00:00", "repo_name": "lexborisov/myhtml", "stars": 1622, "license": "lgpl-2.1", "language": "c", "size": 16681}
{"docstring": "/*\n * Global functions, for all threads\n */\n", "func_signal": "mystatus_t mythread_join(mythread_t *mythread, mythread_callback_before_entry_join_f before_join, void* ctx)", "code": "{\n    for (size_t i = 0; i < mythread->entries_length; i++) {\n        if(before_join)\n            before_join(mythread, &mythread->entries[i], ctx);\n        \n        if(mythread_thread_join(mythread, mythread->entries[i].thread))\n            return MyCORE_STATUS_ERROR;\n    }\n    \n    return MyCORE_STATUS_OK;\n}", "path": "myhtml/source/mycore/mythread.c", "commit_date": "2017-03-21 00:00:00", "repo_name": "lexborisov/myhtml", "stars": 1622, "license": "lgpl-2.1", "language": "c", "size": 16681}
{"docstring": "/**\n *  Internal method to process a buffer that could contain to-be-quoted output\n *  @param  data\n *  @param  size\n *  @param  callback\n *  @param  ptr\n */\n", "func_signal": "mystatus_t myhtml_serialization_append(const char *data, size_t size, mycore_callback_serialize_f callback, void* ptr)", "code": "{\n    // number of chars not yet displayed\n    size_t notwritten = 0;\n    \n    // iterate over the buffer\n    for (size_t i = 0; i < size; ++i) {\n        switch ((unsigned char)data[i]) {\n        case '&':\n            if(notwritten) {\n                if(callback(data + i - notwritten, notwritten, ptr))\n                    return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n            }\n            \n            if(callback(\"&amp;\", 5, ptr))\n                return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n            \n            notwritten = 0;\n            break;\n        case '<':\n            if(notwritten) {\n                if(callback(data + i - notwritten, notwritten, ptr))\n                    return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n            }\n            \n            if(callback(\"&lt;\", 4, ptr))\n                return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n            \n            notwritten = 0;\n            break;\n        case '>':\n            if(notwritten) {\n                if(callback(data + i - notwritten, notwritten, ptr))\n                    return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n            }\n            \n            if(callback(\"&gt;\", 4, ptr))\n                return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n            \n            notwritten = 0;\n            break;\n        case 0xA0:\n            if(i > 0 && (unsigned char)(data[(i - 1)]) == 0xC2) {\n                if(notwritten) {\n                    if(callback(data + i - notwritten, (notwritten - 1), ptr))\n                        return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n                }\n                \n                if(callback(\"&nbsp;\", 6, ptr))\n                    return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n                \n                notwritten = 0;\n            }\n            else {\n                ++notwritten;\n            }\n            \n            break;\n        default:\n            ++notwritten;\n            break;\n        }\n    }\n    \n    if(notwritten)\n        if(callback(data + size - notwritten, notwritten, ptr))\n            return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n    \n    return MyCORE_STATUS_OK;\n}", "path": "myhtml/source/myhtml/serialization.c", "commit_date": "2018-06-02 00:00:00", "repo_name": "lexborisov/myhtml", "stars": 1622, "license": "lgpl-2.1", "language": "c", "size": 16681}
{"docstring": "// other\n", "func_signal": "void myhtml_tree_tags_close_p(myhtml_tree_t* tree, myhtml_token_node_t* token)", "code": "{\n    myhtml_tree_generate_implied_end_tags(tree, MyHTML_TAG_P, MyHTML_NAMESPACE_HTML);\n    \n    myhtml_tree_node_t* current_node = myhtml_tree_current_node(tree);\n    if(myhtml_is_html_node(current_node, MyHTML_TAG_P) == false) {\n        // parse error\n        /* %EXTERNAL% VALIDATOR:RULES HAVE_NEED STATUS:ELEMENT_NO_EXPECTED LEVEL:ERROR */\n        /* %EXTERNAL% VALIDATOR:RULES HAVE_NEED_ADD HAVE:current_node->token NEED:NULL HAVE_TAG_ID:current_node->tag_id HAVE_NS:current_node->ns NEED_TAG_ID:MyHTML_TAG_P NEED_NS:MyHTML_NAMESPACE_HTML */\n    }\n    \n    myhtml_tree_open_elements_pop_until(tree, MyHTML_TAG_P, MyHTML_NAMESPACE_HTML, false);\n}", "path": "myhtml/source/myhtml/tree.c", "commit_date": "2019-09-06 00:00:00", "repo_name": "lexborisov/myhtml", "stars": 1622, "license": "lgpl-2.1", "language": "c", "size": 16681}
{"docstring": "/**\n *  Internal method to process an attribute\n *  @param  data\n *  @param  size\n *  @param  callback\n *  @param  ptr\n */\n", "func_signal": "mystatus_t myhtml_serialization_append_attr(const char* data, size_t size, mycore_callback_serialize_f callback, void* ptr)", "code": "{\n    // number of chars not yet displayed\n    size_t notwritten = 0;\n    \n    // iterate over the buffer\n    for (size_t i = 0; i < size; ++i) {\n        switch ((unsigned char)data[i]) {\n        case '&':\n            if(notwritten) {\n                if(callback(data + i - notwritten, notwritten, ptr))\n                    return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n            }\n            \n            if(callback(\"&amp;\", 5, ptr))\n                return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n            \n            notwritten = 0;\n            break;\n        case '\"':\n            if(notwritten) {\n                if(callback(data + i - notwritten, notwritten, ptr))\n                    return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n            }\n            \n            if(callback(\"&quot;\", 6, ptr))\n                return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n            \n            notwritten = 0;\n            break;\n        case 0xA0:\n            if(i > 0 && (unsigned char)(data[(i - 1)]) == 0xC2) {\n                if(notwritten) {\n                    if(callback(data + i - notwritten, (notwritten - 1), ptr))\n                        return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n                }\n                \n                if(callback(\"&nbsp;\", 6, ptr))\n                    return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n                \n                notwritten = 0;\n            }\n            else {\n                ++notwritten;\n            }\n            \n            break;\n        default:\n            ++notwritten;\n            break;\n        }\n    }\n    \n    if(notwritten) {\n        if(callback(data + size - notwritten, notwritten, ptr))\n            return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n    }\n    \n    return MyCORE_STATUS_OK;\n}", "path": "myhtml/source/myhtml/serialization.c", "commit_date": "2018-06-02 00:00:00", "repo_name": "lexborisov/myhtml", "stars": 1622, "license": "lgpl-2.1", "language": "c", "size": 16681}
{"docstring": "/***********************************************************************************\n *\n * For all unix system. POSIX pthread\n *\n ***********************************************************************************/\n", "func_signal": "void * mythread_thread_create(mythread_t *mythread, mythread_process_f process_func, void* ctx)", "code": "{\n    void *thread = mycore_calloc(1, sizeof(pthread_t));\n    \n    if(thread == NULL)\n        return NULL;\n    \n    if(pthread_create(&(*((pthread_t*)thread)), mythread->attr, process_func, ctx) == 0)\n        return thread;\n    \n    return NULL;\n}", "path": "myhtml/source/myport/posix/mycore/thread.c", "commit_date": "2017-03-21 00:00:00", "repo_name": "lexborisov/myhtml", "stars": 1622, "license": "lgpl-2.1", "language": "c", "size": 16681}
{"docstring": "/* depth-first lefthand tree walk */\n", "func_signal": "static void walk_subtree(myhtml_tree_t* tree, myhtml_tree_node_t* root, int level)", "code": "{\n    if (!root) {\n        return;\n    }\n\n    /* Check if we handle this node type */\n    if (!filter_node(root)) {\n        return;\n    }\n\n    /* start sexpr */\n    putchar('(');\n\n    /* print this node */\n    printf(\"%s\", myhtml_tag_name_by_id(tree, myhtml_node_tag_id(root), NULL));\n    myhtml_tree_attr_t* attr = myhtml_node_attribute_first(root);\n    while (attr != NULL) {\n        /* attribute sexpr (name value)*/\n        const char *key = myhtml_attribute_key(attr, NULL);\n        const char *value = myhtml_attribute_value(attr, NULL);\n        \n        if(key == NULL)\n            printf(\"(KEY IS NULL)\");\n        else if (value)\n            printf(\"(%s \\'%s\\')\", key, value);\n        else\n            printf(\"(%s)\", key);\n        \n        attr = myhtml_attribute_next(attr);\n    }\n\n    /* left hand depth-first recoursion */\n    myhtml_tree_node_t* child = myhtml_node_child(root);\n    while (child != NULL) {\n        walk_subtree(tree, child, level + 1);\n        child = myhtml_node_next(child);\n    }\n\n    /* close sexpr */\n    putchar(')');\n}", "path": "myhtml/examples/myhtml/html2sexpr.c", "commit_date": "2017-03-21 00:00:00", "repo_name": "lexborisov/myhtml", "stars": 1622, "license": "lgpl-2.1", "language": "c", "size": 16681}
{"docstring": "/* spinlock */\n", "func_signal": "void * mcsync_spin_create(void)", "code": "{\n#ifndef MyCORE_MCSYNC_SPINLOCK_PRESENT\n    return mcsync_mutex_create();\n#else\n    return mycore_calloc(1, sizeof(int));\n#endif\n}", "path": "myhtml/source/myport/posix/mycore/utils/mcsync.c", "commit_date": "2017-05-19 00:00:00", "repo_name": "lexborisov/myhtml", "stars": 1622, "license": "lgpl-2.1", "language": "c", "size": 16681}
{"docstring": "/* spinlock */\n", "func_signal": "void * mcsync_spin_create(void)", "code": "{\n    CRITICAL_SECTION *spinlock = mycore_calloc(1, sizeof(CRITICAL_SECTION));\n    if(spinlock == NULL)\n        return NULL;\n    \n    if(InitializeCriticalSectionAndSpinCount(spinlock, 0x00000400))\n        return spinlock;\n    \n    return mycore_free(spinlock);\n}", "path": "myhtml/source/myport/windows_nt/mycore/utils/mcsync.c", "commit_date": "2017-03-21 00:00:00", "repo_name": "lexborisov/myhtml", "stars": 1622, "license": "lgpl-2.1", "language": "c", "size": 16681}
{"docstring": "/**\n *  Implementation of the mycore_callback_serialize_f function for internal\n *  use that concatenats everything to a string\n *  @param  data\n *  @param  size\n */\n", "func_signal": "mystatus_t myhtml_serialization_concatenate(const char* data, size_t length, void *ptr)", "code": "{\n    mycore_string_raw_t *str = (mycore_string_raw_t*)ptr;\n    \n    // do we still have enough size in the output buffer?\n    if ((length + str->length) >= str->size) {\n        if(myhtml_serialization_reallocate(str, length + str->length + 4096))\n            return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n    }\n    \n    // copy data\n    strncpy(&str->data[ str->length ], data, length);\n    \n    // update counters\n    str->length += length;\n    str->data[ str->length ] = '\\0';\n    \n    return MyCORE_STATUS_OK;\n}", "path": "myhtml/source/myhtml/serialization.c", "commit_date": "2018-06-02 00:00:00", "repo_name": "lexborisov/myhtml", "stars": 1622, "license": "lgpl-2.1", "language": "c", "size": 16681}
{"docstring": "/* mutex */\n", "func_signal": "void * mcsync_mutex_create(void)", "code": "{\n    void *mutex = mycore_calloc(1, sizeof(pthread_mutex_t));\n    if(mutex == NULL)\n        return NULL;\n    \n    return mutex;\n}", "path": "myhtml/source/myport/posix/mycore/utils/mcsync.c", "commit_date": "2017-05-19 00:00:00", "repo_name": "lexborisov/myhtml", "stars": 1622, "license": "lgpl-2.1", "language": "c", "size": 16681}
{"docstring": "/**\n *  Internal function to process a text node\n *  @param  tree\n *  @param  node\n *  @param  callback\n *  @param  ptr\n */\n", "func_signal": "mystatus_t myhtml_serialization_node_append_text_node(myhtml_tree_node_t* node, mycore_callback_serialize_f callback, void* ptr)", "code": "{\n    if(node->token == NULL || node->token->str.data == NULL) return MyCORE_STATUS_OK;\n    \n    if(node->parent == NULL) {\n        if(myhtml_serialization_append(node->token->str.data, node->token->str.length, callback, ptr))\n            return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n        \n        return MyCORE_STATUS_OK;\n    }\n    \n    switch (node->parent->tag_id) {\n        case MyHTML_TAG_STYLE:\n        case MyHTML_TAG_SCRIPT:\n        case MyHTML_TAG_XMP:\n        case MyHTML_TAG_IFRAME:\n        case MyHTML_TAG_NOEMBED:\n        case MyHTML_TAG_NOFRAMES:\n        case MyHTML_TAG_PLAINTEXT:\n            if(callback(node->token->str.data, node->token->str.length, ptr))\n                return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n            break;\n        default:\n            if(myhtml_serialization_append(node->token->str.data, node->token->str.length, callback, ptr))\n                return MyCORE_STATUS_ERROR_MEMORY_ALLOCATION;\n            \n            break;\n    }\n    \n    return MyCORE_STATUS_OK;\n}", "path": "myhtml/source/myhtml/serialization.c", "commit_date": "2018-06-02 00:00:00", "repo_name": "lexborisov/myhtml", "stars": 1622, "license": "lgpl-2.1", "language": "c", "size": 16681}
{"docstring": "/* Callbacks */\n", "func_signal": "void mythread_callback_quit(mythread_t* mythread, mythread_entry_t* entry, void* ctx)", "code": "{\n    while((entry->context.opt & MyTHREAD_OPT_QUIT) == 0)\n        mythread_nanosleep_sleep(mythread->timespec);\n}", "path": "myhtml/source/mycore/mythread.c", "commit_date": "2017-03-21 00:00:00", "repo_name": "lexborisov/myhtml", "stars": 1622, "license": "lgpl-2.1", "language": "c", "size": 16681}
{"docstring": "/* This function is called when the XSurface is really gone.\n */\n", "func_signal": "static void\ngdk_broadway_surface_destroy_notify (GdkSurface *surface)", "code": "{\n  if (!GDK_SURFACE_DESTROYED (surface))\n    _gdk_surface_destroy (surface, TRUE);\n\n  g_object_unref (surface);\n}", "path": "gtk/gdk/broadway/gdksurface-broadway.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "GNOME/gtk", "stars": 1328, "license": "other", "language": "c", "size": 702591}
{"docstring": "/**\n * gtk_filter_list_model_get_pending:\n * @self: a #GtkFilterListModel\n *\n * Returns the number of items that have not been filtered yet.\n *\n * You can use this value to check if @self is busy filtering by\n * comparing the return value to 0 or you can compute the percentage\n * of the filter remaining by dividing the return value by the total\n * number of items in the underlying model:\n *\n * |[\n *   pending = gtk_filter_list_model_get_pending (self);\n *   model = gtk_filter_list_model_get_model (self);\n *   percentage = pending / (double) g_list_model_get_n_items (model);\n * ]|\n *\n * If no filter operation is ongoing - in particular when\n * #GtkFilterListModel:incremental is %FALSE - this function returns 0.\n *\n * Returns: The number of items not yet filtered\n **/\n", "func_signal": "guint\ngtk_filter_list_model_get_pending (GtkFilterListModel *self)", "code": "{\n  g_return_val_if_fail (GTK_IS_FILTER_LIST_MODEL (self), FALSE);\n\n  if (self->pending == NULL)\n    return 0;\n\n  return gtk_bitset_get_size (self->pending);\n}", "path": "gtk/gtk/gtkfilterlistmodel.c", "commit_date": "2020-08-03 00:00:00", "repo_name": "GNOME/gtk", "stars": 1328, "license": "other", "language": "c", "size": 702591}
{"docstring": "/* Private API */\n", "func_signal": "void\n_gdk_device_reset_axes (GdkDevice *device)", "code": "{\n  int i;\n\n  for (i = device->axes->len - 1; i >= 0; i--)\n    g_array_remove_index (device->axes, i);\n\n  g_object_notify_by_pspec (G_OBJECT (device), device_props[PROP_N_AXES]);\n}", "path": "gtk/gdk/gdkdevice.c", "commit_date": "2020-09-12 00:00:00", "repo_name": "GNOME/gtk", "stars": 1328, "license": "other", "language": "c", "size": 702591}
{"docstring": "/**\n * gdk_device_get_surface_at_position:\n * @device: pointer #GdkDevice to query info to.\n * @win_x: (out) (allow-none): return location for the X coordinate of the device location,\n *         relative to the surface origin, or %NULL.\n * @win_y: (out) (allow-none): return location for the Y coordinate of the device location,\n *         relative to the surface origin, or %NULL.\n *\n * Obtains the surface underneath @device, returning the location of the device in @win_x and @win_y in\n * double precision. Returns %NULL if the surface tree under @device is not known to GDK (for example,\n * belongs to another application).\n *\n * Returns: (nullable) (transfer none): the #GdkSurface under the\n *   device position, or %NULL.\n **/\n", "func_signal": "GdkSurface *\ngdk_device_get_surface_at_position (GdkDevice *device,\n                                    double    *win_x,\n                                    double    *win_y)", "code": "{\n  double tmp_x, tmp_y;\n  GdkSurface *surface;\n\n  g_return_val_if_fail (GDK_IS_DEVICE (device), NULL);\n  g_return_val_if_fail (device->source != GDK_SOURCE_KEYBOARD, NULL);\n\n  surface = _gdk_device_surface_at_position (device, &tmp_x, &tmp_y, NULL);\n\n  if (win_x)\n    *win_x = tmp_x;\n  if (win_y)\n    *win_y = tmp_y;\n\n  return surface;\n}", "path": "gtk/gdk/gdkdevice.c", "commit_date": "2020-09-12 00:00:00", "repo_name": "GNOME/gtk", "stars": 1328, "license": "other", "language": "c", "size": 702591}
{"docstring": "/*< private >\n * gtk_password_entry_toggle_peek:\n * @entry: a #GtkPasswordEntry\n *\n * Toggles the text visibility.\n */\n", "func_signal": "void\ngtk_password_entry_toggle_peek (GtkPasswordEntry *entry)", "code": "{\n  gboolean visibility;\n\n  visibility = gtk_text_get_visibility (GTK_TEXT (entry->entry));\n  gtk_text_set_visibility (GTK_TEXT (entry->entry), !visibility);\n}", "path": "gtk/gtk/gtkpasswordentry.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "GNOME/gtk", "stars": 1328, "license": "other", "language": "c", "size": 702591}
{"docstring": "/**\n * gdk_device_get_axis_use:\n * @device: a pointer #GdkDevice.\n * @index_: the index of the axis.\n *\n * Returns the axis use for @index_.\n *\n * Returns: a #GdkAxisUse specifying how the axis is used.\n **/\n", "func_signal": "GdkAxisUse\ngdk_device_get_axis_use (GdkDevice *device,\n                         guint      index_)", "code": "{\n  GdkAxisInfo *info;\n\n  g_return_val_if_fail (GDK_IS_DEVICE (device), GDK_AXIS_IGNORE);\n  g_return_val_if_fail (device->source != GDK_SOURCE_KEYBOARD, GDK_AXIS_IGNORE);\n  g_return_val_if_fail (index_ < device->axes->len, GDK_AXIS_IGNORE);\n\n  info = &g_array_index (device->axes, GdkAxisInfo, index_);\n\n  return info->use;\n}", "path": "gtk/gdk/gdkdevice.c", "commit_date": "2020-09-12 00:00:00", "repo_name": "GNOME/gtk", "stars": 1328, "license": "other", "language": "c", "size": 702591}
{"docstring": "/*\n * gdk_device_get_axis: (skip)\n * @device: a #GdkDevice\n * @axes: (array): pointer to an array of axes\n * @use: the use to look for\n * @value: (out): location to store the found value.\n *\n * Interprets an array of double as axis values for a given device,\n * and locates the value in the array for a given axis use.\n *\n * Returns: %TRUE if the given axis use was found, otherwise %FALSE\n **/\n", "func_signal": "gboolean\ngdk_device_get_axis (GdkDevice  *device,\n                     double     *axes,\n                     GdkAxisUse  use,\n                     double     *value)", "code": "{\n  int i;\n\n  g_return_val_if_fail (GDK_IS_DEVICE (device), FALSE);\n  g_return_val_if_fail (device->source != GDK_SOURCE_KEYBOARD, FALSE);\n\n  if (axes == NULL)\n    return FALSE;\n\n  g_return_val_if_fail (device->axes != NULL, FALSE);\n\n  for (i = 0; i < device->axes->len; i++)\n    {\n      GdkAxisInfo axis_info;\n\n      axis_info = g_array_index (device->axes, GdkAxisInfo, i);\n\n      if (axis_info.use != use)\n        continue;\n\n      if (value)\n        *value = axes[i];\n\n      return TRUE;\n    }\n\n  return FALSE;\n}", "path": "gtk/gdk/gdkdevice.c", "commit_date": "2020-09-12 00:00:00", "repo_name": "GNOME/gtk", "stars": 1328, "license": "other", "language": "c", "size": 702591}
{"docstring": "/**\n * gtk_filter_list_model_set_model:\n * @self: a #GtkFilterListModel\n * @model: (allow-none): The model to be filtered\n *\n * Sets the model to be filtered.\n *\n * Note that GTK makes no effort to ensure that @model conforms to\n * the item type of @self. It assumes that the caller knows what they\n * are doing and have set up an appropriate filter to ensure that item\n * types match.\n **/\n", "func_signal": "void\ngtk_filter_list_model_set_model (GtkFilterListModel *self,\n                                 GListModel         *model)", "code": "{\n  guint removed, added;\n\n  g_return_if_fail (GTK_IS_FILTER_LIST_MODEL (self));\n  g_return_if_fail (model == NULL || G_IS_LIST_MODEL (model));\n  /* Note: We don't check for matching item type here, we just assume the\n   * filter func takes care of filtering wrong items. */\n\n  if (self->model == model)\n    return;\n\n  removed = g_list_model_get_n_items (G_LIST_MODEL (self));\n  gtk_filter_list_model_clear_model (self);\n\n  if (model)\n    {\n      self->model = g_object_ref (model);\n      g_signal_connect (model, \"items-changed\", G_CALLBACK (gtk_filter_list_model_items_changed_cb), self);\n      if (removed == 0)\n        {\n          self->strictness = GTK_FILTER_MATCH_NONE;\n          gtk_filter_list_model_refilter (self, GTK_FILTER_CHANGE_LESS_STRICT);\n          added = 0;\n        }\n      else if (self->matches)\n        {\n          gtk_filter_list_model_start_filtering (self, gtk_bitset_new_range (0, g_list_model_get_n_items (model)));\n          added = gtk_bitset_get_size (self->matches);\n        }\n      else\n        {\n          added = g_list_model_get_n_items (model);\n        }\n    }\n  else\n    {\n      self->strictness = GTK_FILTER_MATCH_NONE;\n      added = 0;\n    }\n\n  if (removed > 0 || added > 0)\n    g_list_model_items_changed (G_LIST_MODEL (self), 0, removed, added);\n\n  g_object_notify_by_pspec (G_OBJECT (self), properties[PROP_MODEL]);\n}", "path": "gtk/gtk/gtkfilterlistmodel.c", "commit_date": "2020-08-03 00:00:00", "repo_name": "GNOME/gtk", "stars": 1328, "license": "other", "language": "c", "size": 702591}
{"docstring": "/* Applies the algorithm outlined in\n * http://dev.w3.org/csswg/css3-images/#default-sizing\n */\n", "func_signal": "void\n_gtk_css_image_get_concrete_size (GtkCssImage *image,\n                                  double       specified_width,\n                                  double       specified_height,\n                                  double       default_width,\n                                  double       default_height,\n                                  double      *concrete_width,\n                                  double      *concrete_height)", "code": "{\n  double image_width, image_height, image_aspect;\n\n  gtk_internal_return_if_fail (GTK_IS_CSS_IMAGE (image));\n  gtk_internal_return_if_fail (specified_width >= 0);\n  gtk_internal_return_if_fail (specified_height >= 0);\n  gtk_internal_return_if_fail (default_width > 0);\n  gtk_internal_return_if_fail (default_height > 0);\n  gtk_internal_return_if_fail (concrete_width != NULL);\n  gtk_internal_return_if_fail (concrete_height != NULL);\n\n  /* If the specified size is a definite width and height,\n   * the concrete object size is given that width and height.\n   */\n  if (specified_width && specified_height)\n    {\n      *concrete_width = specified_width;\n      *concrete_height = specified_height;\n      return;\n    }\n\n  image_width  = _gtk_css_image_get_width (image);\n  image_height = _gtk_css_image_get_height (image);\n  image_aspect = _gtk_css_image_get_aspect_ratio (image);\n\n  /* If the specified size has neither a definite width nor height,\n   * and has no additional constraints, the dimensions of the concrete\n   * object size are calculated as follows:\n   */\n  if (specified_width == 0.0 && specified_height == 0.0)\n    {\n      /* If the object has only an intrinsic aspect ratio,\n       * the concrete object size must have that aspect ratio,\n       * and additionally be as large as possible without either\n       * its height or width exceeding the height or width of the\n       * default object size.\n       */\n      if (image_aspect > 0 && image_width == 0 && image_height == 0)\n        {\n          if (image_aspect * default_height > default_width)\n            {\n              *concrete_width = default_width;\n              *concrete_height = default_width / image_aspect;\n            }\n          else\n            {\n              *concrete_width = default_height * image_aspect;\n              *concrete_height = default_height;\n            }\n        }\n      else\n        {\n          /* Otherwise, the width and height of the concrete object\n           * size is the same as the object's intrinsic width and\n           * intrinsic height, if they exist.\n           * If the concrete object size is still missing a width or\n           * height, and the object has an intrinsic aspect ratio,\n           * the missing dimension is calculated from the present\n           * dimension and the intrinsic aspect ratio.\n           * Otherwise, the missing dimension is taken from the default\n           * object size. \n           */\n          if (image_width)\n            *concrete_width = image_width;\n          else if (image_aspect)\n            *concrete_width = image_height * image_aspect;\n          else\n            *concrete_width = default_width;\n\n          if (image_height)\n            *concrete_height = image_height;\n          else if (image_aspect)\n            *concrete_height = image_width / image_aspect;\n          else\n            *concrete_height = default_height;\n        }\n\n      return;\n    }\n\n  /* If the specified size has only a width or height, but not both,\n   * then the concrete object size is given that specified width or height.\n   * The other dimension is calculated as follows:\n   * If the object has an intrinsic aspect ratio, the missing dimension of\n   * the concrete object size is calculated using the intrinsic aspect-ratio\n   * and the present dimension.\n   * Otherwise, if the missing dimension is present in the object's intrinsic\n   * dimensions, the missing dimension is taken from the object's intrinsic\n   * dimensions.\n   * Otherwise, the missing dimension of the concrete object size is taken\n   * from the default object size. \n   */\n  if (specified_width)\n    {\n      *concrete_width = specified_width;\n      if (image_aspect)\n        *concrete_height = specified_width / image_aspect;\n      else if (image_height)\n        *concrete_height = image_height;\n      else\n        *concrete_height = default_height;\n    }\n  else\n    {\n      *concrete_height = specified_height;\n      if (image_aspect)\n        *concrete_width = specified_height * image_aspect;\n      else if (image_width)\n        *concrete_width = image_width;\n      else\n        *concrete_width = default_width;\n    }\n}", "path": "gtk/gtk/gtkcssimage.c", "commit_date": "2020-12-03 00:00:00", "repo_name": "GNOME/gtk", "stars": 1328, "license": "other", "language": "c", "size": 702591}
{"docstring": "/**\n * gdk_device_get_num_lock_state:\n * @device: a #GdkDevice\n *\n * Retrieves whether the Num Lock modifier of the\n * keyboard is locked, if @device is a keyboard device.\n *\n * Returns: %TRUE if Num Lock is on for @device\n */\n", "func_signal": "gboolean\ngdk_device_get_num_lock_state (GdkDevice *device)", "code": "{\n  GdkKeymap *keymap = gdk_display_get_keymap (device->display);\n\n  if (device->source == GDK_SOURCE_KEYBOARD)\n    return gdk_keymap_get_num_lock_state (keymap);\n\n  return FALSE;\n}", "path": "gtk/gdk/gdkdevice.c", "commit_date": "2020-09-12 00:00:00", "repo_name": "GNOME/gtk", "stars": 1328, "license": "other", "language": "c", "size": 702591}
{"docstring": "/**\n * gtk_password_entry_get_show_peek_icon:\n * @entry: a #GtkPasswordEntry\n *\n * Returns whether the entry is showing a clickable icon\n * to reveal the contents of the entry in clear text.\n *\n * Returns: %TRUE if an icon is shown\n */\n", "func_signal": "gboolean\ngtk_password_entry_get_show_peek_icon (GtkPasswordEntry *entry)", "code": "{\n  g_return_val_if_fail (GTK_IS_PASSWORD_ENTRY (entry), FALSE);\n\n  return entry->peek_icon != NULL;\n}", "path": "gtk/gtk/gtkpasswordentry.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "GNOME/gtk", "stars": 1328, "license": "other", "language": "c", "size": 702591}
{"docstring": "/**\n * gdk_device_get_name:\n * @device: a #GdkDevice\n *\n * Determines the name of the device, suitable\n * for showing in a user interface.\n *\n * Returns: a name\n **/\n", "func_signal": "const char *\ngdk_device_get_name (GdkDevice *device)", "code": "{\n  g_return_val_if_fail (GDK_IS_DEVICE (device), NULL);\n\n  return device->name;\n}", "path": "gtk/gdk/gdkdevice.c", "commit_date": "2020-09-12 00:00:00", "repo_name": "GNOME/gtk", "stars": 1328, "license": "other", "language": "c", "size": 702591}
{"docstring": "/**\n * gdk_device_get_device_tool:\n * @device: a #GdkDevice\n *\n * Retrieves the #GdkDeviceTool associated to @device.\n *\n * Returns: (transfer none): the #GdkDeviceTool\n */\n", "func_signal": "GdkDeviceTool *\ngdk_device_get_device_tool (GdkDevice *device)", "code": "{\n  g_return_val_if_fail (GDK_IS_DEVICE (device), NULL);\n\n  return device->last_tool;\n}", "path": "gtk/gdk/gdkdevice.c", "commit_date": "2020-09-12 00:00:00", "repo_name": "GNOME/gtk", "stars": 1328, "license": "other", "language": "c", "size": 702591}
{"docstring": "/*\n * gdk_device_list_physical_devices:\n * @device: a logical #GdkDevice\n *\n * Returns the list of physical devices attached to the given logical\n * #GdkDevice.\n *\n * Returns: (nullable) (transfer container) (element-type GdkDevice):\n *   the list of physical devices attached to a logical #GdkDevice\n */\n", "func_signal": "GList *\ngdk_device_list_physical_devices (GdkDevice *device)", "code": "{\n  g_return_val_if_fail (GDK_IS_DEVICE (device), NULL);\n\n  return g_list_copy (device->physical_devices);\n}", "path": "gtk/gdk/gdkdevice.c", "commit_date": "2020-09-12 00:00:00", "repo_name": "GNOME/gtk", "stars": 1328, "license": "other", "language": "c", "size": 702591}
{"docstring": "/**\n * gdk_device_get_scroll_lock_state:\n * @device: a #GdkDevice\n *\n * Retrieves whether the Scroll Lock modifier of the\n * keyboard is locked, if @device is a keyboard device.\n *\n * Returns: %TRUE if Scroll Lock is on for @device\n */\n", "func_signal": "gboolean\ngdk_device_get_scroll_lock_state (GdkDevice *device)", "code": "{\n  GdkKeymap *keymap = gdk_display_get_keymap (device->display);\n\n  if (device->source == GDK_SOURCE_KEYBOARD)\n    return gdk_keymap_get_scroll_lock_state (keymap);\n\n  return FALSE;\n}", "path": "gtk/gdk/gdkdevice.c", "commit_date": "2020-09-12 00:00:00", "repo_name": "GNOME/gtk", "stars": 1328, "license": "other", "language": "c", "size": 702591}
{"docstring": "/**\n * gdk_device_has_bidi_layouts:\n * @device: a #GdkDevice\n *\n * Determines if keyboard layouts for both right-to-left and\n * left-to-right languages are in use on the keyboard, if\n * @device is a keyboard device.\n *\n * Returns: %TRUE if there are layouts with both directions,\n *     %FALSE otherwise\n */\n", "func_signal": "gboolean\ngdk_device_has_bidi_layouts (GdkDevice *device)", "code": "{\n  GdkKeymap *keymap = gdk_display_get_keymap (device->display);\n\n  if (device->source == GDK_SOURCE_KEYBOARD)\n    return gdk_keymap_have_bidi_layouts (keymap);\n\n  return FALSE;\n}", "path": "gtk/gdk/gdkdevice.c", "commit_date": "2020-09-12 00:00:00", "repo_name": "GNOME/gtk", "stars": 1328, "license": "other", "language": "c", "size": 702591}
{"docstring": "/**\n * gdk_device_get_product_id:\n * @device: a physical #GdkDevice\n *\n * Returns the product ID of this device, or %NULL if this information couldn't\n * be obtained. This ID is retrieved from the device, and is thus constant for\n * it. See gdk_device_get_vendor_id() for more information.\n *\n * Returns: (nullable): the product ID, or %NULL\n */\n", "func_signal": "const char *\ngdk_device_get_product_id (GdkDevice *device)", "code": "{\n  g_return_val_if_fail (GDK_IS_DEVICE (device), NULL);\n\n  return device->product_id;\n}", "path": "gtk/gdk/gdkdevice.c", "commit_date": "2020-09-12 00:00:00", "repo_name": "GNOME/gtk", "stars": 1328, "license": "other", "language": "c", "size": 702591}
{"docstring": "/**\n * gtk_password_entry_set_show_peek_icon:\n * @entry: a #GtkPasswordEntry\n * @show_peek_icon: whether to show the peek icon\n *\n * Sets whether the entry should have a clickable icon\n * to show the contents of the entry in clear text.\n *\n * Setting this to %FALSE also hides the text again.\n */\n", "func_signal": "void\ngtk_password_entry_set_show_peek_icon (GtkPasswordEntry *entry,\n                                       gboolean          show_peek_icon)", "code": "{\n  g_return_if_fail (GTK_IS_PASSWORD_ENTRY (entry));\n\n  show_peek_icon = !!show_peek_icon;\n\n  if (show_peek_icon == (entry->peek_icon != NULL))\n    return;\n\n  if (show_peek_icon)\n    {\n      GtkGesture *press;\n\n      entry->peek_icon = gtk_image_new_from_icon_name (\"eye-not-looking-symbolic\");\n      gtk_widget_set_tooltip_text (entry->peek_icon, _(\"Show text\"));\n      gtk_widget_set_parent (entry->peek_icon, GTK_WIDGET (entry));\n\n      press = gtk_gesture_click_new ();\n      g_signal_connect_swapped (press, \"released\",\n                                G_CALLBACK (gtk_password_entry_toggle_peek), entry);\n      gtk_widget_add_controller (entry->peek_icon, GTK_EVENT_CONTROLLER (press));\n\n      g_signal_connect (entry->entry, \"notify::visibility\",\n                        G_CALLBACK (visibility_toggled), entry);\n      visibility_toggled (G_OBJECT (entry->entry), NULL, entry);\n    }\n  else\n    {\n      g_clear_pointer (&entry->peek_icon, gtk_widget_unparent);\n      gtk_text_set_visibility (GTK_TEXT (entry->entry), FALSE);\n      g_signal_handlers_disconnect_by_func (entry->entry,\n                                            visibility_toggled,\n                                            entry);\n    }\n\n  if (entry->keyboard)\n    caps_lock_state_changed (entry->keyboard, NULL, GTK_WIDGET (entry));\n\n  g_object_notify_by_pspec (G_OBJECT (entry), props[PROP_SHOW_PEEK_ICON]);\n}", "path": "gtk/gtk/gtkpasswordentry.c", "commit_date": "2020-12-16 00:00:00", "repo_name": "GNOME/gtk", "stars": 1328, "license": "other", "language": "c", "size": 702591}
{"docstring": "/**\n * gtk_event_controller_legacy_new:\n *\n * Creates a new legacy event controller.\n *\n * Returns: the newly created event controller.\n */\n", "func_signal": "GtkEventController *\ngtk_event_controller_legacy_new (void)", "code": "{\n  return g_object_new (GTK_TYPE_EVENT_CONTROLLER_LEGACY,\n                       NULL);\n}", "path": "gtk/gtk/gtkeventcontrollerlegacy.c", "commit_date": "2020-04-16 00:00:00", "repo_name": "GNOME/gtk", "stars": 1328, "license": "other", "language": "c", "size": 702591}
{"docstring": "/**\n * gtk_filter_list_model_get_incremental:\n * @self: a #GtkFilterListModel\n *\n * Returns whether incremental filtering was enabled via\n * gtk_filter_list_model_set_incremental().\n *\n * Returns: %TRUE if incremental filtering is enabled\n **/\n", "func_signal": "gboolean\ngtk_filter_list_model_get_incremental (GtkFilterListModel *self)", "code": "{\n  g_return_val_if_fail (GTK_IS_FILTER_LIST_MODEL (self), FALSE);\n\n  return self->incremental;\n}", "path": "gtk/gtk/gtkfilterlistmodel.c", "commit_date": "2020-08-03 00:00:00", "repo_name": "GNOME/gtk", "stars": 1328, "license": "other", "language": "c", "size": 702591}
{"docstring": "/**\n * @param\n *\n * @return\n *\n */\n", "func_signal": "int shutdown (int fd, int how)", "code": "{\n    ANS_FD_DEBUG(\"ans shutdown fd %d, how %d,  pid %d \\n\", fd, how, getpid());\n\n    if(inited && fd > ANS_FD_BASE) \n    {\n        fd -= ANS_FD_BASE;\n\n        return anssock_shutdown(fd, how);;\n    }\n    else\n    {\n        return real_shutdown(fd, how);\n    }\n}", "path": "dpdk-ans/examples/https_server/ans_module.c", "commit_date": "2019-05-04 00:00:00", "repo_name": "ansyun/dpdk-ans", "stars": 1134, "license": "bsd-3-clause", "language": "c", "size": 17003}
{"docstring": "/**********************************************************************\n*@description:\n*\n*\n*@parameters:\n* [in]:\n* [in]:\n*\n*@return values:\n*\n**********************************************************************/\n", "func_signal": "static int ans_parse_portmask(const char *portmask)", "code": "{\n  char *end = NULL;\n  unsigned long pm;\n\n  /* parse hexadecimal string */\n  pm = strtoul(portmask, &end, 16);\n  if ((portmask[0] == '\\0') || (end == NULL) || (*end != '\\0'))\n    return -1;\n\n  if (pm == 0)\n    return -1;\n\n  return pm;\n}", "path": "dpdk-ans/ans/ans_param.c", "commit_date": "2020-02-01 00:00:00", "repo_name": "ansyun/dpdk-ans", "stars": 1134, "license": "bsd-3-clause", "language": "c", "size": 17003}
{"docstring": "/**\n * @param \n *\n * @return  \n *\n */\n", "func_signal": "ssize_t read(int fd, void *buf, size_t count)", "code": "{\n    ssize_t rc;\n    if(inited && fd > ANS_FD_BASE) \n    {\n        fd -= ANS_FD_BASE;\n\n        rc = anssock_read(fd, buf, count);\n\n        ANS_FD_DEBUG(\"ans fd %d read data len %ld, %d \\n\", fd, rc, errno);\n        \n        return rc;\n    } \n    else\n    {\n        rc =real_read(fd, buf, count);\n   //     ANS_FD_DEBUG(\"linux fd %d read data len %ld  \\n\", fd, rc);\n\n        return rc;\n    }\n}", "path": "dpdk-ans/examples/https_server/ans_module.c", "commit_date": "2019-05-04 00:00:00", "repo_name": "ansyun/dpdk-ans", "stars": 1134, "license": "bsd-3-clause", "language": "c", "size": 17003}
{"docstring": "/**\n * @param \n *\n * @return  \n *\n */\n", "func_signal": "int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen)", "code": "{\n\n    ANS_FD_DEBUG(\"fd(%d) start to connect \\n\", sockfd);\n\n    if(inited && sockfd > ANS_FD_BASE) \n    {\n        sockfd -= ANS_FD_BASE;\n        return anssock_connect(sockfd, addr, addrlen);\n    } \n    else \n    {\n        return real_connect(sockfd, addr, addrlen);\n    }\n    \n}", "path": "dpdk-ans/examples/https_server/ans_module.c", "commit_date": "2019-05-04 00:00:00", "repo_name": "ansyun/dpdk-ans", "stars": 1134, "license": "bsd-3-clause", "language": "c", "size": 17003}
{"docstring": "/**\n * @param\n *\n * @return\n *\n */\n", "func_signal": "ssize_t writev(int fd, const struct iovec *iov, int iovcnt)", "code": "{\n    ssize_t rc;\n\n    if (inited && fd > ANS_FD_BASE)\n    {\n        fd -= ANS_FD_BASE;\n\n        ANS_FD_DEBUG(\"ans writev data fd %d , iovcnt %d \\n\", fd, iovcnt);\n        rc = anssock_writev(fd, iov, iovcnt);\n    }\n    else\n    {\n     //   ANS_FD_DEBUG(\"linux writev data fd %d , len %d \\n\", fd, iovcnt);\n\n        rc = real_writev(fd, iov, iovcnt);\n    }\n    return rc;\n}", "path": "dpdk-ans/examples/https_server/ans_module.c", "commit_date": "2019-05-04 00:00:00", "repo_name": "ansyun/dpdk-ans", "stars": 1134, "license": "bsd-3-clause", "language": "c", "size": 17003}
{"docstring": "/**********************************************************************\n*@description:\n*  display usage\n*\n*@parameters:\n* [in]:\n* [in]:\n*\n*@return values:\n*\n**********************************************************************/\n", "func_signal": "int ans_check_port_config(struct ans_user_config *user_conf)", "code": "{\n    unsigned portid;\n    uint16_t i;\n\n    for (i = 0; i < user_conf->rx_nb; i++)\n    {\n        portid = user_conf->lcore_rx[i].port_id;\n\n        if ((user_conf->port_mask & (1 << portid)) == 0)\n        {\n            printf(\"port %u is not enabled in port mask\\n\", portid);\n            return -1;\n        }\n        \n        if (!rte_eth_dev_is_valid_port(portid)) \n        {\n            printf(\"port %u is not present on the board\\n\", portid);\n            return -1;\n        }\n    }\n    return 0;\n}", "path": "dpdk-ans/ans/ans_param.c", "commit_date": "2020-02-01 00:00:00", "repo_name": "ansyun/dpdk-ans", "stars": 1134, "license": "bsd-3-clause", "language": "c", "size": 17003}
{"docstring": "/**\n * @param \n *\n * @return  \n *\n */\n", "func_signal": "int getsockopt(int sockfd, int level ,int optname, void *optval, socklen_t *optlen)", "code": "{\n    if(inited && sockfd > ANS_FD_BASE) \n    {\n        return -2;\n    }\n    else\n    {\n        return real_getsockopt(sockfd, level, optname, optval, optlen);\n    }\n}", "path": "dpdk-ans/examples/https_server/ans_module.c", "commit_date": "2019-05-04 00:00:00", "repo_name": "ansyun/dpdk-ans", "stars": 1134, "license": "bsd-3-clause", "language": "c", "size": 17003}
{"docstring": "/**\n * @param\n *\n * @return\n *\n */\n", "func_signal": "int getsockname(int sockfd, struct sockaddr *addr, socklen_t *addrlen)", "code": "{\n    if(inited && sockfd > ANS_FD_BASE) \n    {\n        sockfd -= ANS_FD_BASE;\n\n        return anssock_getsockname(sockfd, addr, addrlen);\n    }\n    else\n    {\n        return real_getsockname(sockfd, addr, addrlen);\n    }\n}", "path": "dpdk-ans/examples/https_server/ans_module.c", "commit_date": "2019-05-04 00:00:00", "repo_name": "ansyun/dpdk-ans", "stars": 1134, "license": "bsd-3-clause", "language": "c", "size": 17003}
{"docstring": "/**\n * @param\n *\n * @return\n *\n */\n", "func_signal": "int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)", "code": "{\n    int rc;\n\n    ANS_FD_DEBUG(\"epoll ctl  start, epfd %d ,op %d, fd %d, event:0x%x \\n\", epfd, op, fd, event->events);\n\n    if (inited && epfd > ANS_FD_BASE)\n    {\n        if(fd <= ANS_FD_BASE)\n        {\n            printf(\"skip linux fd %d \\n\", fd);\n            return 0;\n        }\n        epfd -= ANS_FD_BASE;\n        fd -= ANS_FD_BASE;\n\n        rc = anssock_epoll_ctl(epfd, op, fd, event);\n    }\n    else\n    {\n        if(inited && fd > ANS_FD_BASE)\n        {\n            printf(\"skip ans fd %d \\n\", fd);\n            return 0;\n        }\n\n        rc = real_epoll_ctl(epfd, op, fd, event);\n    }\n    return rc;\n}", "path": "dpdk-ans/examples/https_server/ans_module.c", "commit_date": "2019-05-04 00:00:00", "repo_name": "ansyun/dpdk-ans", "stars": 1134, "license": "bsd-3-clause", "language": "c", "size": 17003}
{"docstring": "/**\n * @param\n *\n * @return\n *\n */\n", "func_signal": "int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)", "code": "{\n    int rc;\n\n    if(inited && sockfd > ANS_FD_BASE) \n    {\n        sockfd -= ANS_FD_BASE;\n\n        rc = anssock_accept(sockfd, addr, addrlen);\n        addr->sa_family = AF_INET;\n\n        ANS_FD_DEBUG(\"ans accept fd %d \\n\", rc);\n        if(rc > 0 )\n            rc += ANS_FD_BASE;\n    }\n    else\n    {\n        rc = real_accept(sockfd, addr, addrlen);\n        ANS_FD_DEBUG(\"linux accept fd %d \\n\", rc);\n\n    }\n    return rc;\n}", "path": "dpdk-ans/examples/https_server/ans_module.c", "commit_date": "2019-05-04 00:00:00", "repo_name": "ansyun/dpdk-ans", "stars": 1134, "license": "bsd-3-clause", "language": "c", "size": 17003}
{"docstring": "/**********************************************************************\n*@description:\n*\n*\n*@parameters:\n* [in]:\n* [in]:\n*\n*@return values:\n*\n**********************************************************************/\n", "func_signal": "static int ans_parse_config(const char *q_arg, struct ans_user_config *user_conf)", "code": "{\n    char s[256];\n    const char *p, *p0 = q_arg;\n    char *end;\n\n    enum fieldnames\n    {\n      FLD_PORT = 0,\n      FLD_QUEUE,\n      FLD_LCORE,\n      _NUM_FLD\n    };\n\n    unsigned long int_fld[_NUM_FLD];\n    char *str_fld[_NUM_FLD];\n    int i;\n    unsigned size;\n    uint8_t lcore_id;\n    \n    while ((p = strchr(p0,'(')) != NULL)\n    {\n        ++p;\n        if((p0 = strchr(p,')')) == NULL)\n            return -1;\n\n        size = p0 - p;\n        if(size >= sizeof(s))\n            return -1;\n\n        snprintf(s, sizeof(s), \"%.*s\", size, p);\n        if (rte_strsplit(s, sizeof(s), str_fld, _NUM_FLD, ',') != _NUM_FLD)\n            return -1;\n\n        for (i = 0; i < _NUM_FLD; i++)\n        {\n            errno = 0;\n            int_fld[i] = strtoul(str_fld[i], &end, 0);\n            if (errno != 0 || end == str_fld[i] || int_fld[i] > 255)\n              return -1;\n        }\n\n        if (user_conf->rx_nb >= ANS_MAX_NB_LCORE)\n        {\n            printf(\"exceeded max number of lcore params: %hu\\n\", user_conf->rx_nb);\n            return -1;\n        }\n\n        lcore_id = (uint8_t)int_fld[FLD_LCORE];\n        if (rte_lcore_is_enabled(lcore_id) == 0) \n        {\n            printf(\"lcore %d isn't enable \\n\", lcore_id);\n            return -1;\n        }\n\n        user_conf->lcore_rx[user_conf->rx_nb].port_id = (uint8_t)int_fld[FLD_PORT];\n        user_conf->lcore_rx[user_conf->rx_nb].queue_id = (uint8_t)int_fld[FLD_QUEUE];\n        user_conf->lcore_rx[user_conf->rx_nb].lcore_id = (uint8_t)int_fld[FLD_LCORE];\n\n        ++user_conf->rx_nb;\n    }\n\n    return 0;\n}", "path": "dpdk-ans/ans/ans_param.c", "commit_date": "2020-02-01 00:00:00", "repo_name": "ansyun/dpdk-ans", "stars": 1134, "license": "bsd-3-clause", "language": "c", "size": 17003}
{"docstring": "/**\n * @param \n *\n * @return  \n *\n */\n", "func_signal": "ssize_t send (int sockfd, const void *buf, size_t len, int flags)", "code": "{\n    ssize_t n;\n    \n    ANS_FD_DEBUG(\"send data fd %d , len %lu \\n\", sockfd, len);\n\n    if(inited && sockfd > ANS_FD_BASE) \n    {\n        sockfd -= ANS_FD_BASE;\n        ANS_FD_DEBUG(\"ans send data fd %d , len %lu \\n\", sockfd, len);\n\n        n = anssock_send(sockfd, buf, len, flags);  \n        \n        ANS_FD_DEBUG(\"ans send: fd %d , len %lu, return value:%ld, errno:%d, strerror = %s \\n\", sockfd, len, n, errno, strerror(errno));\n\n        return n;\n\n    }\n    else \n    {\n        ANS_FD_DEBUG(\"linux send data fd %d , len %lu \\n\", sockfd, len);\n\n        return real_send(sockfd, buf, len, flags);\n    }\n}", "path": "dpdk-ans/examples/https_server/ans_module.c", "commit_date": "2019-05-04 00:00:00", "repo_name": "ansyun/dpdk-ans", "stars": 1134, "license": "bsd-3-clause", "language": "c", "size": 17003}
{"docstring": "/**\n * @param\n *\n * @return\n *\n */\n", "func_signal": "int accept4(int sockfd, struct sockaddr *addr, socklen_t *addrlen, int flags)", "code": "{\n    int rc;\n\n    if(inited && sockfd > ANS_FD_BASE) \n    {\n        sockfd -= ANS_FD_BASE;\n\n        rc = anssock_accept(sockfd, addr, addrlen);\n        addr->sa_family = AF_INET;\n\n        ANS_FD_DEBUG(\"ans accep4t fd %d, errno %d \\n\", rc, errno);\n\n        if(rc > 0 )\n            rc += ANS_FD_BASE;\n\n    }\n    else\n    {\n        rc = real_accept4(sockfd, addr, addrlen, flags);\n        ANS_FD_DEBUG(\"linux accept4 fd %d, errno %d \\n\", rc, errno);\n    }\n    return rc;\n}", "path": "dpdk-ans/examples/https_server/ans_module.c", "commit_date": "2019-05-04 00:00:00", "repo_name": "ansyun/dpdk-ans", "stars": 1134, "license": "bsd-3-clause", "language": "c", "size": 17003}
{"docstring": "/**********************************************************************\n*@description:\n*  display usage\n*\n*@parameters:\n* [in]:\n* [in]:\n*\n*@return values:\n*\n**********************************************************************/\n", "func_signal": "static void ans_print_usage(const char *prgname)", "code": "{\n  printf (\"%s [EAL options] -- -p PORTMASK -P \\n\"\n    \"  -p PORTMASK: hexadecimal bitmask of ports to configure\\n\"\n    \"  -P : enable promiscuous mode\\n\"\n    \"  --config (port,queue,lcore): rx queues configuration\\n\"\n    \"  --worker (lcore,lcore...): worker lcore configuration\\n\"\n    \"  --no-numa: optional, disable numa awareness\\n\"\n    \"  --enable-kni: optional, disable kni awareness\\n\"\n    \"  --enable-ipsync: optional, sync ip/route from kernel kni interface\\n\"\n    \"  --enable-jumbo: enable jumbo frame\"\n    \" which max packet len is PKTLEN in decimal (64-9600)\\n\",\n    prgname);\n}", "path": "dpdk-ans/ans/ans_param.c", "commit_date": "2020-02-01 00:00:00", "repo_name": "ansyun/dpdk-ans", "stars": 1134, "license": "bsd-3-clause", "language": "c", "size": 17003}
{"docstring": "/**\n * @param\n *\n * @return\n *\n */\n", "func_signal": "ssize_t readv(int fd, const struct iovec *iov, int iovcnt)", "code": "{\n    ssize_t rc;\n\n    if (inited && fd > ANS_FD_BASE)\n    {\n        fd -= ANS_FD_BASE;\n\n        ANS_FD_DEBUG(\"ans fd %d readv with iovcnt %d \\n\", fd, iovcnt);\n        rc =anssock_readv(fd, iov, iovcnt);\n        return rc;\n    }\n    else\n    {\n        rc =real_readv(fd, iov, iovcnt);\n\n        return rc;\n    }\n\n}", "path": "dpdk-ans/examples/https_server/ans_module.c", "commit_date": "2019-05-04 00:00:00", "repo_name": "ansyun/dpdk-ans", "stars": 1134, "license": "bsd-3-clause", "language": "c", "size": 17003}
{"docstring": "/**\n * @param\n *\n * @return\n *\n */\n", "func_signal": "int ioctl(int fd, int request, void *p)", "code": "{\n    if (inited && fd > ANS_FD_BASE)\n    {\n        fd -= ANS_FD_BASE;\n\n        //return anssock_ioctl(fd, request, p);\n        return 0;\n    }\n    else\n    {\n        return real_ioctl(fd, request, p);\n    }\n}", "path": "dpdk-ans/examples/https_server/ans_module.c", "commit_date": "2019-05-04 00:00:00", "repo_name": "ansyun/dpdk-ans", "stars": 1134, "license": "bsd-3-clause", "language": "c", "size": 17003}
{"docstring": "/**\n * @param \n *\n * @return  \n *\n */\n", "func_signal": "int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)", "code": "{\n    struct sockaddr_in *in_addr; \n    in_addr = (struct sockaddr_in *)addr;\n\n    ANS_FD_DEBUG(\"bind ip: %x , port %d, family:%d \\n\", in_addr->sin_addr.s_addr, ntohs(in_addr->sin_port), in_addr->sin_family);\n\n    if(inited && sockfd > ANS_FD_BASE) \n    {\n        sockfd -= ANS_FD_BASE;\n        return anssock_bind(sockfd, addr, addrlen);\n    } \n    else \n    {\n        return real_bind(sockfd, addr, addrlen);\n    }\n}", "path": "dpdk-ans/examples/https_server/ans_module.c", "commit_date": "2019-05-04 00:00:00", "repo_name": "ansyun/dpdk-ans", "stars": 1134, "license": "bsd-3-clause", "language": "c", "size": 17003}
{"docstring": "/**\n * @param \n *\n * @return  \n *\n */\n", "func_signal": "int socketpair(int domain, int type, int protocol, int sv[2])", "code": "{\n    if (inited)\n    {\n        return -1;\n    }\n    else\n    {\n        return real_socketpair(domain, type, protocol, sv);\n    }\n}", "path": "dpdk-ans/examples/https_server/ans_module.c", "commit_date": "2019-05-04 00:00:00", "repo_name": "ansyun/dpdk-ans", "stars": 1134, "license": "bsd-3-clause", "language": "c", "size": 17003}
{"docstring": "/**\n * @param \n *\n * @return  \n *\n */\n", "func_signal": "int socket(int domain, int type, int protocol)", "code": "{\n    int rc;\n\n     ANS_FD_DEBUG(\"socket create start , domain %d, type %d \\n\", domain, type);    \n   \n    if ((inited == 0) ||  (AF_INET != domain) || (SOCK_STREAM != type && SOCK_DGRAM != type))\n    {\n        rc = real_socket(domain, type, protocol);\n        ANS_FD_DEBUG(\"linux socket fd %d \\n\", rc);    \n\n        return rc;\n    }\n\n    assert(inited);\n    rc = anssock_socket(domain, type, protocol);\n    \n    if(rc > 0)\n        rc += ANS_FD_BASE;\n    \n    ANS_FD_DEBUG(\"ans socket fd %d \\n\", rc);    \n    return rc;\n}", "path": "dpdk-ans/examples/https_server/ans_module.c", "commit_date": "2019-05-04 00:00:00", "repo_name": "ansyun/dpdk-ans", "stars": 1134, "license": "bsd-3-clause", "language": "c", "size": 17003}
{"docstring": "/**\n * @param \n *\n * @return  \n *\n */\n", "func_signal": "ssize_t write(int fd, const void *buf, size_t count)", "code": "{\n    ssize_t n;\n\n//    ANS_FD_DEBUG(\"write data fd %d , len %lu \\n\", fd, count);\n\n    if(inited && fd > ANS_FD_BASE) \n    {\n        fd -= ANS_FD_BASE;\n\n        n = anssock_write(fd, buf, count);\n        \n        ANS_FD_DEBUG(\"ans write: fd %d , len %lu, return value:%ld, errno:%d, strerror = %s \\n\", fd, count, n, errno, strerror(errno));\n\n        return n;\n\n    }\n    else \n    {\n\n        n = real_write(fd, buf, count);\n        \n        ANS_FD_DEBUG(\"linux write: fd %d , len %lu, return value:%ld, errno:%d, strerror = %s \\n\", fd, count, n, errno, strerror(errno));\n     \n        return n;\n    }\n}", "path": "dpdk-ans/examples/https_server/ans_module.c", "commit_date": "2019-05-04 00:00:00", "repo_name": "ansyun/dpdk-ans", "stars": 1134, "license": "bsd-3-clause", "language": "c", "size": 17003}
{"docstring": "/* OMX_SetupTunnel */\n", "func_signal": "OMX_ERRORTYPE OMX_APIENTRY OMX_SetupTunnel(\n   OMX_IN  OMX_HANDLETYPE hOutput,\n   OMX_IN  OMX_U32 nPortOutput,\n   OMX_IN  OMX_HANDLETYPE hInput,\n   OMX_IN  OMX_U32 nPortInput)", "code": "{\n   OMX_ERRORTYPE eError = OMX_ErrorNone;\n   OMX_COMPONENTTYPE *pCompIn, *pCompOut;\n   OMX_TUNNELSETUPTYPE oTunnelSetup;\n\n   if ((hOutput == NULL && hInput == NULL) || ilcs_service == NULL)\n      return OMX_ErrorBadParameter;\n\n   oTunnelSetup.nTunnelFlags = 0;\n   oTunnelSetup.eSupplier = OMX_BufferSupplyUnspecified;\n\n   pCompOut = (OMX_COMPONENTTYPE*)hOutput;\n\n   if (hOutput){\n      eError = pCompOut->ComponentTunnelRequest(hOutput, nPortOutput, hInput, nPortInput, &oTunnelSetup);\n   }\n\n   if (eError == OMX_ErrorNone && hInput) {\n      pCompIn = (OMX_COMPONENTTYPE*)hInput;\n      eError = pCompIn->ComponentTunnelRequest(hInput, nPortInput, hOutput, nPortOutput, &oTunnelSetup);\n\n      if (eError != OMX_ErrorNone && hOutput) {\n         /* cancel tunnel request on output port since input port failed */\n         pCompOut->ComponentTunnelRequest(hOutput, nPortOutput, NULL, 0, NULL);\n      }\n   }\n   return eError;\n}", "path": "moonlight-embedded/third_party/ilclient/ilcore.c", "commit_date": "2015-05-26 00:00:00", "repo_name": "moonlight-stream/moonlight-embedded", "stars": 1455, "license": "gpl-3.0", "language": "c", "size": 10635}
{"docstring": "/* OMX_GetHandle */\n", "func_signal": "OMX_ERRORTYPE OMX_APIENTRY OMX_GetHandle(\n   OMX_OUT OMX_HANDLETYPE* pHandle,\n   OMX_IN  OMX_STRING cComponentName,\n   OMX_IN  OMX_PTR pAppData,\n   OMX_IN  OMX_CALLBACKTYPE* pCallBacks)", "code": "{\n   OMX_ERRORTYPE eError;\n   OMX_COMPONENTTYPE *pComp;\n   OMX_HANDLETYPE hHandle = 0;\n\n   if (pHandle == NULL || cComponentName == NULL || pCallBacks == NULL || ilcs_service == NULL)\n   {\n      if(pHandle)\n         *pHandle = NULL;\n      return OMX_ErrorBadParameter;\n   }\n\n   {\n      pComp = (OMX_COMPONENTTYPE *)malloc(sizeof(OMX_COMPONENTTYPE));\n      if (!pComp)\n      {\n         vcos_assert(0);\n         return OMX_ErrorInsufficientResources;\n      }\n      memset(pComp, 0, sizeof(OMX_COMPONENTTYPE));\n      hHandle = (OMX_HANDLETYPE)pComp;\n      pComp->nSize = sizeof(OMX_COMPONENTTYPE);\n      pComp->nVersion.nVersion = OMX_VERSION;\n      eError = vcil_out_create_component(ilcs_get_common(ilcs_service), hHandle, cComponentName);\n\n      if (eError == OMX_ErrorNone) {\n         // Check that all function pointers have been filled in.\n         // All fields should be non-zero.\n         int i;\n         uint32_t *p = (uint32_t *) pComp;\n         for(i=0; i<sizeof(OMX_COMPONENTTYPE)>>2; i++)\n            if(*p++ == 0)\n               eError = OMX_ErrorInvalidComponent;\n\n         if(eError != OMX_ErrorNone && pComp->ComponentDeInit)\n            pComp->ComponentDeInit(hHandle);\n      }      \n\n      if (eError == OMX_ErrorNone) {\n         eError = pComp->SetCallbacks(hHandle,pCallBacks,pAppData);\n         if (eError != OMX_ErrorNone)\n            pComp->ComponentDeInit(hHandle);\n      }\n      if (eError == OMX_ErrorNone) {\n         *pHandle = hHandle;\n      }\n      else {\n         *pHandle = NULL;\n         free(pComp);\n      }\n   } \n\n   if (eError == OMX_ErrorNone) {\n      vcos_mutex_lock(&lock);\n      nActiveHandles++;\n      vcos_mutex_unlock(&lock);\n   }\n\n   return eError;\n}", "path": "moonlight-embedded/third_party/ilclient/ilcore.c", "commit_date": "2015-05-26 00:00:00", "repo_name": "moonlight-stream/moonlight-embedded", "stars": 1455, "license": "gpl-3.0", "language": "c", "size": 10635}
{"docstring": "/* OMX_FreeHandle */\n", "func_signal": "OMX_ERRORTYPE OMX_APIENTRY OMX_FreeHandle(\n   OMX_IN  OMX_HANDLETYPE hComponent)", "code": "{\n   OMX_ERRORTYPE eError = OMX_ErrorNone;\n   OMX_COMPONENTTYPE *pComp;\n\n   if (hComponent == NULL || ilcs_service == NULL)\n      return OMX_ErrorBadParameter;\n\n   pComp = (OMX_COMPONENTTYPE*)hComponent;\n\n   if (ilcs_service == NULL)\n      return OMX_ErrorBadParameter;\n\n   eError = (pComp->ComponentDeInit)(hComponent);\n   if (eError == OMX_ErrorNone) {\n      vcos_mutex_lock(&lock);\n      --nActiveHandles;\n      vcos_mutex_unlock(&lock);\n      free(pComp);\n   }\n\n   vcos_assert(nActiveHandles >= 0);\n\n   return eError;\n}", "path": "moonlight-embedded/third_party/ilclient/ilcore.c", "commit_date": "2015-05-26 00:00:00", "repo_name": "moonlight-stream/moonlight-embedded", "stars": 1455, "license": "gpl-3.0", "language": "c", "size": 10635}
{"docstring": "// This function must be called before\n// any other decoding functions\n", "func_signal": "int ffmpeg_init(int videoFormat, int width, int height, int perf_lvl, int buffer_count, int thread_count)", "code": "{\n  // Initialize the avcodec library and register codecs\n  av_log_set_level(AV_LOG_QUIET);\n#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(58,10,100)\n  avcodec_register_all();\n#endif\n\n  av_init_packet(&pkt);\n\n  ffmpeg_decoder = perf_lvl & VAAPI_ACCELERATION ? VAAPI : SOFTWARE;\n  switch (videoFormat) {\n    case VIDEO_FORMAT_H264:\n      decoder = avcodec_find_decoder_by_name(\"h264\");\n      break;\n    case VIDEO_FORMAT_H265:\n      decoder = avcodec_find_decoder_by_name(\"hevc\");\n      break;\n  }\n\n  if (decoder == NULL) {\n    printf(\"Couldn't find decoder\\n\");\n    return -1;\n  }\n\n  decoder_ctx = avcodec_alloc_context3(decoder);\n  if (decoder_ctx == NULL) {\n    printf(\"Couldn't allocate context\");\n    return -1;\n  }\n\n  if (perf_lvl & DISABLE_LOOP_FILTER)\n    // Skip the loop filter for performance reasons\n    decoder_ctx->skip_loop_filter = AVDISCARD_ALL;\n\n  if (perf_lvl & LOW_LATENCY_DECODE)\n    // Use low delay single threaded encoding\n    decoder_ctx->flags |= AV_CODEC_FLAG_LOW_DELAY;\n\n  if (perf_lvl & SLICE_THREADING)\n    decoder_ctx->thread_type = FF_THREAD_SLICE;\n  else\n    decoder_ctx->thread_type = FF_THREAD_FRAME;\n\n  decoder_ctx->thread_count = thread_count;\n\n  decoder_ctx->width = width;\n  decoder_ctx->height = height;\n  decoder_ctx->pix_fmt = AV_PIX_FMT_YUV420P;\n\n  int err = avcodec_open2(decoder_ctx, decoder, NULL);\n  if (err < 0) {\n    printf(\"Couldn't open codec\");\n    return err;\n  }\n\n  dec_frames_cnt = buffer_count;\n  dec_frames = malloc(buffer_count * sizeof(AVFrame*));\n  if (dec_frames == NULL) {\n    fprintf(stderr, \"Couldn't allocate frames\");\n    return -1;\n  }\n\n  for (int i = 0; i < buffer_count; i++) {\n    dec_frames[i] = av_frame_alloc();\n    if (dec_frames[i] == NULL) {\n      fprintf(stderr, \"Couldn't allocate frame\");\n      return -1;\n    }\n  }\n\n  #ifdef HAVE_VAAPI\n  if (ffmpeg_decoder == VAAPI)\n    vaapi_init(decoder_ctx);\n  #endif\n\n  return 0;\n}", "path": "moonlight-embedded/src/video/ffmpeg.c", "commit_date": "2019-10-05 00:00:00", "repo_name": "moonlight-stream/moonlight-embedded", "stars": 1455, "license": "gpl-3.0", "language": "c", "size": 10635}
{"docstring": "/* OMX_ComponentNameEnum */\n", "func_signal": "OMX_ERRORTYPE OMX_APIENTRY OMX_ComponentNameEnum(\n   OMX_OUT OMX_STRING cComponentName,\n   OMX_IN  OMX_U32 nNameLength,\n   OMX_IN  OMX_U32 nIndex)", "code": "{\n   if(ilcs_service == NULL)\n      return OMX_ErrorBadParameter;\n\n   return vcil_out_component_name_enum(ilcs_get_common(ilcs_service), cComponentName, nNameLength, nIndex);\n}", "path": "moonlight-embedded/third_party/ilclient/ilcore.c", "commit_date": "2015-05-26 00:00:00", "repo_name": "moonlight-stream/moonlight-embedded", "stars": 1455, "license": "gpl-3.0", "language": "c", "size": 10635}
{"docstring": "// D.1 SEI payload syntax\n", "func_signal": "void read_sei_payload(h264_stream_t* h, bs_t* b, int payloadType, int payloadSize)", "code": "{\n    sei_t* s = h->sei;\n\n    s->payload = (uint8_t*)malloc(payloadSize);\n\n    int i;\n\n    for ( i = 0; i < payloadSize; i++ )\n        s->payload[i] = bs_read_u(b, 8);\n        \n    //read_sei_end_bits(h, b);\n}", "path": "moonlight-embedded/third_party/h264bitstream/h264_sei.c", "commit_date": "2015-05-26 00:00:00", "repo_name": "moonlight-stream/moonlight-embedded", "stars": 1455, "license": "gpl-3.0", "language": "c", "size": 10635}
{"docstring": "/**\n Find the beginning and end of a NAL (Network Abstraction Layer) unit in a byte buffer containing H264 bitstream data.\n @param[in]   buf        the buffer\n @param[in]   size       the size of the buffer\n @param[out]  nal_start  the beginning offset of the nal\n @param[out]  nal_end    the end offset of the nal\n @return                 the length of the nal, or 0 if did not find start of nal, or -1 if did not find end of nal\n */\n// DEPRECATED - this will be replaced by a similar function with a slightly different API\n", "func_signal": "int find_nal_unit(uint8_t* buf, int size, int* nal_start, int* nal_end)", "code": "{\n    int i;\n    // find start\n    *nal_start = 0;\n    *nal_end = 0;\n    \n    i = 0;\n    while (   //( next_bits( 24 ) != 0x000001 && next_bits( 32 ) != 0x00000001 )\n        (buf[i] != 0 || buf[i+1] != 0 || buf[i+2] != 0x01) && \n        (buf[i] != 0 || buf[i+1] != 0 || buf[i+2] != 0 || buf[i+3] != 0x01) \n        )\n    {\n        i++; // skip leading zero\n        if (i+4 >= size) { return 0; } // did not find nal start\n    }\n\n    if  (buf[i] != 0 || buf[i+1] != 0 || buf[i+2] != 0x01) // ( next_bits( 24 ) != 0x000001 )\n    {\n        i++;\n    }\n\n    if  (buf[i] != 0 || buf[i+1] != 0 || buf[i+2] != 0x01) { /* error, should never happen */ return 0; }\n    i+= 3;\n    *nal_start = i;\n    \n    while (   //( next_bits( 24 ) != 0x000000 && next_bits( 24 ) != 0x000001 )\n        (buf[i] != 0 || buf[i+1] != 0 || buf[i+2] != 0) && \n        (buf[i] != 0 || buf[i+1] != 0 || buf[i+2] != 0x01) \n        )\n    {\n        i++;\n        // FIXME the next line fails when reading a nal that ends exactly at the end of the data\n        if (i+3 >= size) { *nal_end = size; return -1; } // did not find nal end, stream ended first\n    }\n    \n    *nal_end = i;\n    return (*nal_end - *nal_start);\n}", "path": "moonlight-embedded/third_party/h264bitstream/h264_nal.c", "commit_date": "2015-05-26 00:00:00", "repo_name": "moonlight-stream/moonlight-embedded", "stars": 1455, "license": "gpl-3.0", "language": "c", "size": 10635}
{"docstring": "/* OMX_Deinit */\n", "func_signal": "OMX_ERRORTYPE OMX_APIENTRY OMX_Deinit(void)", "code": "{\n   if(coreInit == 0) // || (coreInit == 1 && nActiveHandles > 0))\n      return OMX_ErrorNotReady;\n\n   vcos_mutex_lock(&lock);\n\n   coreInit--;\n\n   if(coreInit == 0)\n   {\n      // we need to teardown the ILCS connection to VideoCore\n      ilcs_deinit(ilcs_service);\n      ilcs_service = NULL;\n   }\n\n   vcos_mutex_unlock(&lock);\n   \n   return OMX_ErrorNone;\n}", "path": "moonlight-embedded/third_party/ilclient/ilcore.c", "commit_date": "2015-05-26 00:00:00", "repo_name": "moonlight-stream/moonlight-embedded", "stars": 1455, "license": "gpl-3.0", "language": "c", "size": 10635}
{"docstring": "/* OMX_Init */\n", "func_signal": "OMX_ERRORTYPE OMX_APIENTRY OMX_Init(void)", "code": "{\n   VCOS_STATUS_T status;\n   OMX_ERRORTYPE err = OMX_ErrorNone;\n\n   status = vcos_once(&once, initOnce);\n   vcos_demand(status == VCOS_SUCCESS);\n\n   vcos_mutex_lock(&lock);\n   \n   if(coreInit == 0)\n   {\n      // we need to connect via an ILCS connection to VideoCore\n      VCHI_INSTANCE_T initialise_instance;\n      VCHI_CONNECTION_T *connection;\n      ILCS_CONFIG_T config;\n\n      vc_host_get_vchi_state(&initialise_instance, &connection);\n\n      vcilcs_config(&config);\n\n      ilcs_service = ilcs_init((VCHIQ_INSTANCE_T) initialise_instance, (void **) &connection, &config, 0);\n\n      if(ilcs_service == NULL)\n      {\n         err = OMX_ErrorHardware;\n         goto end;\n      }\n\n      coreInit = 1;\n   }\n   else\n      coreInit++;\n\nend:\n   vcos_mutex_unlock(&lock);\n   return err;\n}", "path": "moonlight-embedded/third_party/ilclient/ilcore.c", "commit_date": "2015-05-26 00:00:00", "repo_name": "moonlight-stream/moonlight-embedded", "stars": 1455, "license": "gpl-3.0", "language": "c", "size": 10635}
{"docstring": "// D.1 SEI payload syntax\n", "func_signal": "void write_sei_payload(h264_stream_t* h, bs_t* b, int payloadType, int payloadSize)", "code": "{\n    sei_t* s = h->sei;\n\n    int i;\n    for ( i = 0; i < s->payloadSize; i++ )\n        bs_write_u(b, 8, s->payload[i]);\n}", "path": "moonlight-embedded/third_party/h264bitstream/h264_sei.c", "commit_date": "2015-05-26 00:00:00", "repo_name": "moonlight-stream/moonlight-embedded", "stars": 1455, "license": "gpl-3.0", "language": "c", "size": 10635}
{"docstring": "/* Atomic creation of lock protecting shared state */\n", "func_signal": "static void initOnce(void)", "code": "{\n   VCOS_STATUS_T status;\n   status = vcos_mutex_create(&lock, VCOS_FUNCTION);\n   vcos_demand(status == VCOS_SUCCESS);\n}", "path": "moonlight-embedded/third_party/ilclient/ilcore.c", "commit_date": "2015-05-26 00:00:00", "repo_name": "moonlight-stream/moonlight-embedded", "stars": 1455, "license": "gpl-3.0", "language": "c", "size": 10635}
{"docstring": "/**\n Read only the NAL headers (enough to determine unit type) from a byte buffer.\n @return unit type if read successfully, or -1 if this doesn't look like a nal\n*/\n", "func_signal": "int peek_nal_unit(h264_stream_t* h, uint8_t* buf, int size)", "code": "{\n    nal_t* nal = h->nal;\n\n    bs_t* b = bs_new(buf, size);\n\n    nal->forbidden_zero_bit = bs_read_f(b,1);\n    nal->nal_ref_idc = bs_read_u(b,2);\n    nal->nal_unit_type = bs_read_u(b,5);\n\n    bs_free(b);\n\n    // basic verification, per 7.4.1\n    if ( nal->forbidden_zero_bit ) { return -1; }\n    if ( nal->nal_unit_type <= 0 || nal->nal_unit_type > 20 ) { return -1; }\n    if ( nal->nal_unit_type > 15 && nal->nal_unit_type < 19 ) { return -1; }\n\n    if ( nal->nal_ref_idc == 0 )\n    {\n        if ( nal->nal_unit_type == NAL_UNIT_TYPE_CODED_SLICE_IDR )\n        {\n            return -1;\n        }\n    }\n    else \n    {\n        if ( nal->nal_unit_type ==  NAL_UNIT_TYPE_SEI || \n             nal->nal_unit_type == NAL_UNIT_TYPE_AUD || \n             nal->nal_unit_type == NAL_UNIT_TYPE_END_OF_SEQUENCE || \n             nal->nal_unit_type == NAL_UNIT_TYPE_END_OF_STREAM || \n             nal->nal_unit_type == NAL_UNIT_TYPE_FILLER ) \n        {\n            return -1;\n        }\n    }\n\n    return nal->nal_unit_type;\n}", "path": "moonlight-embedded/third_party/h264bitstream/h264_nal.c", "commit_date": "2015-05-26 00:00:00", "repo_name": "moonlight-stream/moonlight-embedded", "stars": 1455, "license": "gpl-3.0", "language": "c", "size": 10635}
{"docstring": "/**\n Free an existing H264 stream object.  Frees all contained structures.\n @param[in,out] h   the stream object\n */\n", "func_signal": "void h264_free(h264_stream_t* h)", "code": "{\n    free(h->nal);\n\n    for ( int i = 0; i < 32; i++ ) { free( h->sps_table[i] ); }\n    for ( int i = 0; i < 256; i++ ) { free( h->pps_table[i] ); }\n\n    free(h->aud);\n    if(h->seis != NULL)\n    {\n        for( int i = 0; i < h->num_seis; i++ )\n        {\n            sei_t* sei = h->seis[i];\n            sei_free(sei);\n        }\n        free(h->seis);\n    }\n    free(h->sh);\n    free(h);\n}", "path": "moonlight-embedded/third_party/h264bitstream/h264_nal.c", "commit_date": "2015-05-26 00:00:00", "repo_name": "moonlight-stream/moonlight-embedded", "stars": 1455, "license": "gpl-3.0", "language": "c", "size": 10635}
{"docstring": "/**\n   Convert RBSP data to NAL data (Annex B format).\n   The size of nal_buf must be 4/3 * the size of the rbsp_buf (rounded up) to guarantee the output will fit.\n   If that is not true, output may be truncated and an error will be returned.\n   If that is true, there is no possible error during this conversion.\n   @param[in] rbsp_buf   the rbsp data\n   @param[in] rbsp_size  pointer to the size of the rbsp data\n   @param[in,out] nal_buf   allocated memory in which to put the nal data\n   @param[in,out] nal_size  as input, pointer to the maximum size of the nal data; as output, filled in with the actual size of the nal data\n   @return  actual size of nal data, or -1 on error\n */\n// 7.3.1 NAL unit syntax\n// 7.4.1.1 Encapsulation of an SODB within an RBSP\n", "func_signal": "int rbsp_to_nal(const uint8_t* rbsp_buf, const int* rbsp_size, uint8_t* nal_buf, int* nal_size)", "code": "{\n    int i;\n    int j     = 0;\n    int count = 0;\n\n    for ( i = 0; i < *rbsp_size ; i++ )\n    {\n        if ( j >= *nal_size ) \n        {\n            // error, not enough space\n            return -1;\n        }\n\n        if ( ( count == 2 ) && !(rbsp_buf[i] & 0xFC) ) // HACK 0xFC\n        {\n            nal_buf[j] = 0x03;\n            j++;\n            count = 0;\n        }\n        nal_buf[j] = rbsp_buf[i];\n        if ( rbsp_buf[i] == 0x00 )\n        {\n            count++;\n        }\n        else\n        {\n            count = 0;\n        }\n        j++;\n    }\n\n    *nal_size = j;\n    return j;\n}", "path": "moonlight-embedded/third_party/h264bitstream/h264_nal.c", "commit_date": "2015-05-26 00:00:00", "repo_name": "moonlight-stream/moonlight-embedded", "stars": 1455, "license": "gpl-3.0", "language": "c", "size": 10635}
{"docstring": "/* OMX_GetRolesOfComponent */\n", "func_signal": "OMX_ERRORTYPE OMX_GetRolesOfComponent (\n   OMX_IN      OMX_STRING compName,\n   OMX_INOUT   OMX_U32 *pNumRoles,\n   OMX_OUT     OMX_U8 **roles)", "code": "{\n   OMX_ERRORTYPE eError = OMX_ErrorNone;\n\n   *pNumRoles = 0;\n   return eError;\n}", "path": "moonlight-embedded/third_party/ilclient/ilcore.c", "commit_date": "2015-05-26 00:00:00", "repo_name": "moonlight-stream/moonlight-embedded", "stars": 1455, "license": "gpl-3.0", "language": "c", "size": 10635}
{"docstring": "// packets must be decoded in order\n// indata must be inlen + AV_INPUT_BUFFER_PADDING_SIZE in length\n", "func_signal": "int ffmpeg_decode(unsigned char* indata, int inlen)", "code": "{\n  int err;\n\n  pkt.data = indata;\n  pkt.size = inlen;\n\n  err = avcodec_send_packet(decoder_ctx, &pkt);\n  if (err < 0) {\n    char errorstring[512];\n    av_strerror(err, errorstring, sizeof(errorstring));\n    fprintf(stderr, \"Decode failed - %s\\n\", errorstring);\n  }\n\n  return err < 0 ? err : 0;\n}", "path": "moonlight-embedded/src/video/ffmpeg.c", "commit_date": "2019-10-05 00:00:00", "repo_name": "moonlight-stream/moonlight-embedded", "stars": 1455, "license": "gpl-3.0", "language": "c", "size": 10635}
{"docstring": "/* OMX_GetComponentsOfRole */\n", "func_signal": "OMX_ERRORTYPE OMX_GetComponentsOfRole (\n   OMX_IN      OMX_STRING role,\n   OMX_INOUT   OMX_U32 *pNumComps,\n   OMX_INOUT   OMX_U8  **compNames)", "code": "{\n   OMX_ERRORTYPE eError = OMX_ErrorNone;\n\n   *pNumComps = 0;\n   return eError;\n}", "path": "moonlight-embedded/third_party/ilclient/ilcore.c", "commit_date": "2015-05-26 00:00:00", "repo_name": "moonlight-stream/moonlight-embedded", "stars": 1455, "license": "gpl-3.0", "language": "c", "size": 10635}
{"docstring": "/* OMX_GetDebugInformation */\n", "func_signal": "OMX_ERRORTYPE OMX_GetDebugInformation (\n   OMX_OUT    OMX_STRING debugInfo,\n   OMX_INOUT  OMX_S32 *pLen)", "code": "{\n   if(ilcs_service == NULL)\n      return OMX_ErrorBadParameter;\n\n   return vcil_out_get_debug_information(ilcs_get_common(ilcs_service), debugInfo, pLen);\n}", "path": "moonlight-embedded/third_party/ilclient/ilcore.c", "commit_date": "2015-05-26 00:00:00", "repo_name": "moonlight-stream/moonlight-embedded", "stars": 1455, "license": "gpl-3.0", "language": "c", "size": 10635}
{"docstring": "/**\n   Convert NAL data (Annex B format) to RBSP data.\n   The size of rbsp_buf must be the same as size of the nal_buf to guarantee the output will fit.\n   If that is not true, output may be truncated and an error will be returned. \n   Additionally, certain byte sequences in the input nal_buf are not allowed in the spec and also cause the conversion to fail and an error to be returned.\n   @param[in] nal_buf   the nal data\n   @param[in,out] nal_size  as input, pointer to the size of the nal data; as output, filled in with the actual size of the nal data\n   @param[in,out] rbsp_buf   allocated memory in which to put the rbsp data\n   @param[in,out] rbsp_size  as input, pointer to the maximum size of the rbsp data; as output, filled in with the actual size of rbsp data\n   @return  actual size of rbsp data, or -1 on error\n */\n// 7.3.1 NAL unit syntax\n// 7.4.1.1 Encapsulation of an SODB within an RBSP\n", "func_signal": "int nal_to_rbsp(const uint8_t* nal_buf, int* nal_size, uint8_t* rbsp_buf, int* rbsp_size)", "code": "{\n    int i;\n    int j     = 0;\n    int count = 0;\n  \n    for( i = 0; i < *nal_size; i++ )\n    { \n        // in NAL unit, 0x000000, 0x000001 or 0x000002 shall not occur at any byte-aligned position\n        if( ( count == 2 ) && ( nal_buf[i] < 0x03) ) \n        {\n            return -1;\n        }\n\n        if( ( count == 2 ) && ( nal_buf[i] == 0x03) )\n        {\n            // check the 4th byte after 0x000003, except when cabac_zero_word is used, in which case the last three bytes of this NAL unit must be 0x000003\n            if((i < *nal_size - 1) && (nal_buf[i+1] > 0x03))\n            {\n                return -1;\n            }\n\n            // if cabac_zero_word is used, the final byte of this NAL unit(0x03) is discarded, and the last two bytes of RBSP must be 0x0000\n            if(i == *nal_size - 1)\n            {\n                break;\n            }\n\n            i++;\n            count = 0;\n        }\n\n        if ( j >= *rbsp_size ) \n        {\n            // error, not enough space\n            return -1;\n        }\n\n        rbsp_buf[j] = nal_buf[i];\n        if(nal_buf[i] == 0x00)\n        {\n            count++;\n        }\n        else\n        {\n            count = 0;\n        }\n        j++;\n    }\n\n    *nal_size = i;\n    *rbsp_size = j;\n    return j;\n}", "path": "moonlight-embedded/third_party/h264bitstream/h264_nal.c", "commit_date": "2015-05-26 00:00:00", "repo_name": "moonlight-stream/moonlight-embedded", "stars": 1455, "license": "gpl-3.0", "language": "c", "size": 10635}
{"docstring": "/**\n Create a new H264 stream object.  Allocates all structures contained within it.\n @return    the stream object\n */\n", "func_signal": "h264_stream_t* h264_new()", "code": "{\n    h264_stream_t* h = (h264_stream_t*)calloc(1, sizeof(h264_stream_t));\n\n    h->nal = (nal_t*)calloc(1, sizeof(nal_t));\n\n    // initialize tables\n    for ( int i = 0; i < 32; i++ ) { h->sps_table[i] = (sps_t*)calloc(1, sizeof(sps_t)); }\n    for ( int i = 0; i < 256; i++ ) { h->pps_table[i] = (pps_t*)calloc(1, sizeof(pps_t)); }\n\n    h->sps = h->sps_table[0];\n    h->pps = h->pps_table[0];\n    h->aud = (aud_t*)calloc(1, sizeof(aud_t));\n    h->num_seis = 0;\n    h->seis = NULL;\n    h->sei = NULL;  //This is a TEMP pointer at whats in h->seis...\n    h->sh = (slice_header_t*)calloc(1, sizeof(slice_header_t));\n    h->slice_data = (slice_data_rbsp_t*)calloc(1, sizeof(slice_data_rbsp_t));\n\n    return h;   \n}", "path": "moonlight-embedded/third_party/h264bitstream/h264_nal.c", "commit_date": "2015-05-26 00:00:00", "repo_name": "moonlight-stream/moonlight-embedded", "stars": 1455, "license": "gpl-3.0", "language": "c", "size": 10635}
{"docstring": "/*\n** check whether cached closure in prototype 'p' may be reused, that is,\n** whether there is a cached closure with the same upvalues needed by\n** new closure to be created.\n*/\n", "func_signal": "static Closure *getcached (Proto *p, UpVal **encup, StkId base)", "code": "{\n  Closure *c = p->cache;\n  if (c != NULL) {  /* is there a cached closure? */\n    int nup = p->sizeupvalues;\n    Upvaldesc *uv = p->upvalues;\n    int i;\n    for (i = 0; i < nup; i++) {  /* check whether it has right upvalues */\n      TValue *v = uv[i].instack ? base + uv[i].idx : encup[uv[i].idx]->v;\n      if (c->l.upvals[i]->v != v)\n        return NULL;  /* wrong upvalue; cannot reuse closure */\n    }\n  }\n  return c;  /* return cached closure (or NULL if no cached closure) */\n}", "path": "MLN/MLN-Android/mlncore/src/main/jni/lua/lvm.c", "commit_date": "2019-09-19 00:00:00", "repo_name": "momotech/MLN", "stars": 1597, "license": "mit", "language": "c", "size": 312730}
{"docstring": "/*\n** \"export\" pending gotos to outer level, to check them against\n** outer labels; if the block being exited has upvalues, and\n** the goto exits the scope of any variable (which can be the\n** upvalue), close those variables being exited.\n*/\n", "func_signal": "static void movegotosout (FuncState *fs, BlockCnt *bl)", "code": "{\n  int i = bl->firstgoto;\n  Labellist *gl = &fs->ls->dyd->gt;\n  /* correct pending gotos to current block and try to close it\n     with visible labels */\n  while (i < gl->n) {\n    Labeldesc *gt = &gl->arr[i];\n    if (gt->nactvar > bl->nactvar) {\n      if (bl->upval)\n        luaK_patchclose(fs, gt->pc, bl->nactvar);\n      gt->nactvar = bl->nactvar;\n    }\n    if (!findlabel(fs->ls, i))\n      i++;  /* move to next one */\n  }\n}", "path": "MLN/MLN-Android/mlncore/src/main/jni/lua/lparser.c", "commit_date": "2019-09-19 00:00:00", "repo_name": "momotech/MLN", "stars": 1597, "license": "mit", "language": "c", "size": 312730}
{"docstring": "/*\n** check whether current token is in the follow set of a block.\n** 'until' closes syntactical blocks, but do not close scope,\n** so it handled in separate.\n*/\n", "func_signal": "static int block_follow (LexState *ls, int withuntil)", "code": "{\n  switch (ls->t.token) {\n    case TK_ELSE: case TK_ELSEIF:\n    case TK_END: case TK_EOS:\n      return 1;\n    case TK_UNTIL: return withuntil;\n    default: return 0;\n  }\n}", "path": "MLN/MLN-Android/mlncore/src/main/jni/lua/lparser.c", "commit_date": "2019-09-19 00:00:00", "repo_name": "momotech/MLN", "stars": 1597, "license": "mit", "language": "c", "size": 312730}
{"docstring": "/* skip no-op statements */\n", "func_signal": "static void skipnoopstat (LexState *ls)", "code": "{\n  while (ls->t.token == ';' || ls->t.token == TK_DBCOLON)\n    statement(ls);\n}", "path": "MLN/MLN-Android/mlncore/src/main/jni/lua/lparser.c", "commit_date": "2019-09-19 00:00:00", "repo_name": "momotech/MLN", "stars": 1597, "license": "mit", "language": "c", "size": 312730}
{"docstring": "/*\n** Look for n-th local variable at line `line' in function `func'.\n** Returns NULL if not found.\n*/\n", "func_signal": "const char *luaF_getlocalname (const Proto *f, int local_number, int pc)", "code": "{\n  int i;\n  for (i = 0; i<f->sizelocvars && f->locvars[i].startpc <= pc; i++) {\n    if (pc < f->locvars[i].endpc) {  /* is variable active? */\n      local_number--;\n      if (local_number == 0)\n        return getstr(f->locvars[i].varname);\n    }\n  }\n  return NULL;  /* not found */\n}", "path": "MLN/MLN-Android/mlncore/src/main/jni/lua/lfunc.c", "commit_date": "2019-09-19 00:00:00", "repo_name": "momotech/MLN", "stars": 1597, "license": "mit", "language": "c", "size": 312730}
{"docstring": "/*\n** adds a new prototype into list of prototypes\n*/\n", "func_signal": "static Proto *addprototype (LexState *ls)", "code": "{\n  Proto *clp;\n  lua_State *L = ls->L;\n  FuncState *fs = ls->fs;\n  Proto *f = fs->f;  /* prototype of current function */\n  if (fs->np >= f->sizep) {\n    int oldsize = f->sizep;\n    luaM_growvector(L, f->p, fs->np, f->sizep, Proto *, MAXARG_Bx, \"functions\");\n    while (oldsize < f->sizep) f->p[oldsize++] = NULL;\n  }\n  f->p[fs->np++] = clp = luaF_newproto(L);\n  luaC_objbarrier(L, f, clp);\n  return clp;\n}", "path": "MLN/MLN-Android/mlncore/src/main/jni/lua/lparser.c", "commit_date": "2019-09-19 00:00:00", "repo_name": "momotech/MLN", "stars": 1597, "license": "mit", "language": "c", "size": 312730}
{"docstring": "/*\n  Mark block where variable at given level was defined\n  (to emit close instructions later).\n*/\n", "func_signal": "static void markupval (FuncState *fs, int level)", "code": "{\n  BlockCnt *bl = fs->bl;\n  while (bl->nactvar > level) bl = bl->previous;\n  bl->upval = 1;\n}", "path": "MLN/MLN-Android/mlncore/src/main/jni/lua/lparser.c", "commit_date": "2019-09-19 00:00:00", "repo_name": "momotech/MLN", "stars": 1597, "license": "mit", "language": "c", "size": 312730}
{"docstring": "/*\n  Find variable with given name 'n'. If it is an upvalue, add this\n  upvalue into all intermediate functions.\n*/\n", "func_signal": "static int singlevaraux (FuncState *fs, TString *n, expdesc *var, int base)", "code": "{\n  if (fs == NULL)  /* no more levels? */\n    return VVOID;  /* default is global */\n  else {\n    int v = searchvar(fs, n);  /* look up locals at current level */\n    if (v >= 0) {  /* found? */\n      init_exp(var, VLOCAL, v);  /* variable is local */\n      if (!base)\n        markupval(fs, v);  /* local will be used as an upval */\n      return VLOCAL;\n    }\n    else {  /* not found as local at current level; try upvalues */\n      int idx = searchupvalue(fs, n);  /* try existing upvalues */\n      if (idx < 0) {  /* not found? */\n        if (singlevaraux(fs->prev, n, var, 0) == VVOID) /* try upper levels */\n          return VVOID;  /* not found; is a global */\n        /* else was LOCAL or UPVAL */\n        idx  = newupvalue(fs, n, var);  /* will be a new upvalue */\n      }\n      init_exp(var, VUPVAL, idx);\n      return VUPVAL;\n    }\n  }\n}", "path": "MLN/MLN-Android/mlncore/src/main/jni/lua/lparser.c", "commit_date": "2019-09-19 00:00:00", "repo_name": "momotech/MLN", "stars": 1597, "license": "mit", "language": "c", "size": 312730}
{"docstring": "/*\n** codes instruction to create new closure in parent function.\n** The OP_CLOSURE instruction must use the last available register,\n** so that, if it invokes the GC, the GC knows which registers\n** are in use at that time.\n*/\n", "func_signal": "static void codeclosure (LexState *ls, expdesc *v)", "code": "{\n  FuncState *fs = ls->fs->prev;\n  init_exp(v, VRELOCABLE, luaK_codeABx(fs, OP_CLOSURE, 0, fs->np - 1));\n  luaK_exp2nextreg(fs, v);  /* fix it at the last register */\n}", "path": "MLN/MLN-Android/mlncore/src/main/jni/lua/lparser.c", "commit_date": "2019-09-19 00:00:00", "repo_name": "momotech/MLN", "stars": 1597, "license": "mit", "language": "c", "size": 312730}
{"docstring": "/*\n** check whether new label 'lb' matches any pending gotos in current\n** block; solves forward jumps\n*/\n", "func_signal": "static void findgotos (LexState *ls, Labeldesc *lb)", "code": "{\n  Labellist *gl = &ls->dyd->gt;\n  int i = ls->fs->bl->firstgoto;\n  while (i < gl->n) {\n    if (luaS_eqstr(gl->arr[i].name, lb->name))\n      closegoto(ls, i, lb);\n    else\n      i++;\n  }\n}", "path": "MLN/MLN-Android/mlncore/src/main/jni/lua/lparser.c", "commit_date": "2019-09-19 00:00:00", "repo_name": "momotech/MLN", "stars": 1597, "license": "mit", "language": "c", "size": 312730}
{"docstring": "/*\n** create a new Lua closure, push it in the stack, and initialize\n** its upvalues. Note that the call to 'luaC_barrierproto' must come\n** before the assignment to 'p->cache', as the function needs the\n** original value of that field.\n*/\n", "func_signal": "static void pushclosure (lua_State *L, Proto *p, UpVal **encup, StkId base,\n                         StkId ra)", "code": "{\n  int nup = p->sizeupvalues;\n  Upvaldesc *uv = p->upvalues;\n  int i;\n  Closure *ncl = luaF_newLclosure(L, nup);\n  ncl->l.p = p;\n  setclLvalue(L, ra, ncl);  /* anchor new closure in stack */\n  for (i = 0; i < nup; i++) {  /* fill in its upvalues */\n    if (uv[i].instack)  /* upvalue refers to local variable? */\n      ncl->l.upvals[i] = luaF_findupval(L, base + uv[i].idx);\n    else  /* get upvalue from enclosing function */\n      ncl->l.upvals[i] = encup[uv[i].idx];\n  }\n  luaC_barrierproto(L, p, ncl);\n  p->cache = ncl;  /* save it on cache for reuse */\n}", "path": "MLN/MLN-Android/mlncore/src/main/jni/lua/lvm.c", "commit_date": "2019-09-19 00:00:00", "repo_name": "momotech/MLN", "stars": 1597, "license": "mit", "language": "c", "size": 312730}
{"docstring": "/*\n** equality of Lua values. L == NULL means raw equality (no metamethods)\n*/\n", "func_signal": "int luaV_equalobj_ (lua_State *L, const TValue *t1, const TValue *t2)", "code": "{\n  const TValue *tm;\n  lua_assert(ttisequal(t1, t2));\n  switch (ttype(t1)) {\n    case LUA_TNIL: return 1;\n    case LUA_TNUMBER: return luai_numeq(nvalue(t1), nvalue(t2));\n    case LUA_TBOOLEAN: return bvalue(t1) == bvalue(t2);  /* true must be 1 !! */\n    case LUA_TLIGHTUSERDATA: return pvalue(t1) == pvalue(t2);\n    case LUA_TLCF: return fvalue(t1) == fvalue(t2);\n    case LUA_TSHRSTR: return eqshrstr(rawtsvalue(t1), rawtsvalue(t2));\n    case LUA_TLNGSTR: return luaS_eqlngstr(rawtsvalue(t1), rawtsvalue(t2));\n    case LUA_TUSERDATA: {\n      if (uvalue(t1) == uvalue(t2)) return 1;\n      else if (L == NULL) return 0;\n      tm = get_equalTM(L, uvalue(t1)->metatable, uvalue(t2)->metatable, TM_EQ);\n      break;  /* will try TM */\n    }\n    case LUA_TTABLE: {\n      if (hvalue(t1) == hvalue(t2)) return 1;\n      else if (L == NULL) return 0;\n      tm = get_equalTM(L, hvalue(t1)->metatable, hvalue(t2)->metatable, TM_EQ);\n      break;  /* will try TM */\n    }\n    default:\n      lua_assert(iscollectable(t1));\n      return gcvalue(t1) == gcvalue(t2);\n  }\n  if (tm == NULL) return 0;  /* no TM? */\n  callTM(L, tm, t1, t2, L->top, 1);  /* call TM */\n  return !l_isfalse(L->top);\n}", "path": "MLN/MLN-Android/mlncore/src/main/jni/lua/lvm.c", "commit_date": "2019-09-19 00:00:00", "repo_name": "momotech/MLN", "stars": 1597, "license": "mit", "language": "c", "size": 312730}
{"docstring": "/*\n** check whether, in an assignment to an upvalue/local variable, the\n** upvalue/local variable is begin used in a previous assignment to a\n** table. If so, save original upvalue/local value in a safe place and\n** use this safe copy in the previous assignment.\n*/\n", "func_signal": "static void check_conflict (LexState *ls, struct LHS_assign *lh, expdesc *v)", "code": "{\n  FuncState *fs = ls->fs;\n  int extra = fs->freereg;  /* eventual position to save local variable */\n  int conflict = 0;\n  for (; lh; lh = lh->prev) {  /* check all previous assignments */\n    if (lh->v.k == VINDEXED) {  /* assigning to a table? */\n      /* table is the upvalue/local being assigned now? */\n      if (lh->v.u.ind.vt == v->k && lh->v.u.ind.t == v->u.info) {\n        conflict = 1;\n        lh->v.u.ind.vt = VLOCAL;\n        lh->v.u.ind.t = extra;  /* previous assignment will use safe copy */\n      }\n      /* index is the local being assigned? (index cannot be upvalue) */\n      if (v->k == VLOCAL && lh->v.u.ind.idx == v->u.info) {\n        conflict = 1;\n        lh->v.u.ind.idx = extra;  /* previous assignment will use safe copy */\n      }\n    }\n  }\n  if (conflict) {\n    /* copy upvalue/local value to a temporary (in position 'extra') */\n    OpCode op = (v->k == VLOCAL) ? OP_MOVE : OP_GETUPVAL;\n    luaK_codeABC(fs, op, extra, v->u.info, 0);\n    luaK_reserveregs(fs, 1);\n  }\n}", "path": "MLN/MLN-Android/mlncore/src/main/jni/lua/lparser.c", "commit_date": "2019-09-19 00:00:00", "repo_name": "momotech/MLN", "stars": 1597, "license": "mit", "language": "c", "size": 312730}
{"docstring": "/*\n** generic allocation routine.\n*/\n", "func_signal": "void *luaM_realloc_ (lua_State *L, void *block, size_t osize, size_t nsize)", "code": "{\n  void *newblock;\n  global_State *g = G(L);\n  size_t realosize = (block) ? osize : 0;\n  lua_assert((realosize == 0) == (block == NULL));\n#if defined(HARDMEMTESTS)\n  if (nsize > realosize && g->gcrunning)\n    luaC_fullgc(L, 1);  /* force a GC whenever possible */\n#endif\n  newblock = (*g->frealloc)(g->ud, block, osize, nsize);\n  if (newblock == NULL && nsize > 0) {\n    api_check(L, nsize > realosize,\n                 \"realloc cannot fail when shrinking a block\");\n    if (g->gcrunning) {\n      luaC_fullgc(L, 1);  /* try to free some memory... */\n      newblock = (*g->frealloc)(g->ud, block, osize, nsize);  /* try again */\n    }\n    if (newblock == NULL)\n      luaD_throw(L, LUA_ERRMEM);\n  }\n  lua_assert((nsize == 0) == (newblock == NULL));\n  g->GCdebt = (g->GCdebt + nsize) - realosize;\n  return newblock;\n}", "path": "MLN/MLN-Android/mlncore/src/main/jni/lua/lmem.c", "commit_date": "2019-09-19 00:00:00", "repo_name": "momotech/MLN", "stars": 1597, "license": "mit", "language": "c", "size": 312730}
{"docstring": "/*\n** compiles the main function, which is a regular vararg function with an\n** upvalue named LUA_ENV\n*/\n", "func_signal": "static void mainfunc (LexState *ls, FuncState *fs)", "code": "{\n  BlockCnt bl;\n  expdesc v;\n  open_func(ls, fs, &bl);\n  fs->f->is_vararg = 1;  /* main function is always vararg */\n  init_exp(&v, VLOCAL, 0);  /* create and... */\n  newupvalue(fs, ls->envn, &v);  /* ...set environment upvalue */\n  luaX_next(ls);  /* read first token */\n  statlist(ls);  /* parse main body */\n  check(ls, TK_EOS);\n  close_func(ls);\n}", "path": "MLN/MLN-Android/mlncore/src/main/jni/lua/lparser.c", "commit_date": "2019-09-19 00:00:00", "repo_name": "momotech/MLN", "stars": 1597, "license": "mit", "language": "c", "size": 312730}
{"docstring": "/*\n** finish execution of an opcode interrupted by an yield\n*/\n", "func_signal": "void luaV_finishOp (lua_State *L)", "code": "{\n  CallInfo *ci = L->ci;\n  StkId base = ci->u.l.base;\n  Instruction inst = *(ci->u.l.savedpc - 1);  /* interrupted instruction */\n  OpCode op = GET_OPCODE(inst);\n  switch (op) {  /* finish its execution */\n    case OP_ADD: case OP_SUB: case OP_MUL: case OP_DIV:\n    case OP_MOD: case OP_POW: case OP_UNM: case OP_LEN:\n    case OP_GETTABUP: case OP_GETTABLE: case OP_SELF: {\n      setobjs2s(L, base + GETARG_A(inst), --L->top);\n      break;\n    }\n    case OP_LE: case OP_LT: case OP_EQ: {\n      int res = !l_isfalse(L->top - 1);\n      L->top--;\n      /* metamethod should not be called when operand is K */\n      lua_assert(!ISK(GETARG_B(inst)));\n      if (op == OP_LE &&  /* \"<=\" using \"<\" instead? */\n          ttisnil(luaT_gettmbyobj(L, base + GETARG_B(inst), TM_LE)))\n        res = !res;  /* invert result */\n      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_JMP);\n      if (res != GETARG_A(inst))  /* condition failed? */\n        ci->u.l.savedpc++;  /* skip jump instruction */\n      break;\n    }\n    case OP_CONCAT: {\n      StkId top = L->top - 1;  /* top when 'call_binTM' was called */\n      int b = GETARG_B(inst);      /* first element to concatenate */\n      int total = cast_int(top - 1 - (base + b));  /* yet to concatenate */\n      setobj2s(L, top - 2, top);  /* put TM result in proper position */\n      if (total > 1) {  /* are there elements to concat? */\n        L->top = top - 1;  /* top is one after last element (at top-2) */\n        luaV_concat(L, total);  /* concat them (may yield again) */\n      }\n      /* move final result to final position */\n      setobj2s(L, ci->u.l.base + GETARG_A(inst), L->top - 1);\n      L->top = ci->top;  /* restore top */\n      break;\n    }\n    case OP_TFORCALL: {\n      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_TFORLOOP);\n      L->top = ci->top;  /* correct top */\n      break;\n    }\n    case OP_CALL: {\n      if (GETARG_C(inst) - 1 >= 0)  /* nresults >= 0? */\n        L->top = ci->top;  /* adjust results */\n      break;\n    }\n    case OP_TAILCALL: case OP_SETTABUP: case OP_SETTABLE:\n      break;\n    default: lua_assert(0);\n  }\n}", "path": "MLN/MLN-Android/mlncore/src/main/jni/lua/lvm.c", "commit_date": "2019-09-19 00:00:00", "repo_name": "momotech/MLN", "stars": 1597, "license": "mit", "language": "c", "size": 312730}
{"docstring": "/* check for repeated labels on the same block */\n", "func_signal": "static void checkrepeated (FuncState *fs, Labellist *ll, TString *label)", "code": "{\n  int i;\n  for (i = fs->bl->firstlabel; i < ll->n; i++) {\n    if (luaS_eqstr(label, ll->arr[i].name)) {\n      const char *msg = luaO_pushfstring(fs->ls->L,\n                          \"label \" LUA_QS \" already defined on line %d\",\n                          getstr(label), ll->arr[i].line);\n      semerror(fs->ls, msg);\n    }\n  }\n}", "path": "MLN/MLN-Android/mlncore/src/main/jni/lua/lparser.c", "commit_date": "2019-09-19 00:00:00", "repo_name": "momotech/MLN", "stars": 1597, "license": "mit", "language": "c", "size": 312730}
{"docstring": "/* semantic error */\n", "func_signal": "static l_noret semerror (LexState *ls, const char *msg)", "code": "{\n  ls->t.token = 0;  /* remove 'near to' from final message */\n  luaX_syntaxerror(ls, msg);\n}", "path": "MLN/MLN-Android/mlncore/src/main/jni/lua/lparser.c", "commit_date": "2019-09-19 00:00:00", "repo_name": "momotech/MLN", "stars": 1597, "license": "mit", "language": "c", "size": 312730}
{"docstring": "/*\n** create a label named \"break\" to resolve break statements\n*/\n", "func_signal": "static void breaklabel (LexState *ls)", "code": "{\n  TString *n = luaS_new(ls->L, \"break\");\n  int l = newlabelentry(ls, &ls->dyd->label, n, 0, ls->fs->pc);\n  findgotos(ls, &ls->dyd->label.arr[l]);\n}", "path": "MLN/MLN-Android/mlncore/src/main/jni/lua/lparser.c", "commit_date": "2019-09-19 00:00:00", "repo_name": "momotech/MLN", "stars": 1597, "license": "mit", "language": "c", "size": 312730}
{"docstring": "/*\n** generates an error for an undefined 'goto'; choose appropriate\n** message when label name is a reserved word (which can only be 'break')\n*/\n", "func_signal": "static l_noret undefgoto (LexState *ls, Labeldesc *gt)", "code": "{\n  const char *msg = isreserved(gt->name)\n                    ? \"<%s> at line %d not inside a loop\"\n                    : \"no visible label \" LUA_QS \" for <goto> at line %d\";\n  msg = luaO_pushfstring(ls->L, msg, getstr(gt->name), gt->line);\n  semerror(ls, msg);\n}", "path": "MLN/MLN-Android/mlncore/src/main/jni/lua/lparser.c", "commit_date": "2019-09-19 00:00:00", "repo_name": "momotech/MLN", "stars": 1597, "license": "mit", "language": "c", "size": 312730}
{"docstring": "/* BufferFormatCheck */\n", "func_signal": "static void __Pyx_BufFmt_Init(__Pyx_BufFmt_Context* ctx,\n                              __Pyx_BufFmt_StackElem* stack,\n                              __Pyx_TypeInfo* type)", "code": "{\n  stack[0].field = &ctx->root;\n  stack[0].parent_offset = 0;\n  ctx->root.type = type;\n  ctx->root.name = \"buffer dtype\";\n  ctx->root.offset = 0;\n  ctx->head = stack;\n  ctx->head->field = &ctx->root;\n  ctx->fmt_offset = 0;\n  ctx->head->parent_offset = 0;\n  ctx->new_packmode = '@';\n  ctx->enc_packmode = '@';\n  ctx->new_count = 1;\n  ctx->enc_count = 0;\n  ctx->enc_type = 0;\n  ctx->is_complex = 0;\n  ctx->is_valid_array = 0;\n  ctx->struct_alignment = 0;\n  while (type->typegroup == 'S') {\n    ++ctx->head;\n    ctx->head->field = type->fields;\n    ctx->head->parent_offset = 0;\n    type = type->fields->type;\n  }\n}", "path": "invoice/text/detector/utils/cython_nms.c", "commit_date": "2019-08-02 00:00:00", "repo_name": "guanshuicheng/invoice", "stars": 1593, "license": "mit", "language": "c", "size": 7963}
{"docstring": "/* CheckBinaryVersion */\n", "func_signal": "static int __Pyx_check_binary_version(void)", "code": "{\n    char ctversion[4], rtversion[4];\n    PyOS_snprintf(ctversion, 4, \"%d.%d\", PY_MAJOR_VERSION, PY_MINOR_VERSION);\n    PyOS_snprintf(rtversion, 4, \"%s\", Py_GetVersion());\n    if (ctversion[0] != rtversion[0] || ctversion[2] != rtversion[2]) {\n        char message[200];\n        PyOS_snprintf(message, sizeof(message),\n                      \"compiletime version %s of module '%.100s' \"\n                      \"does not match runtime version %s\",\n                      ctversion, __Pyx_MODULE_NAME, rtversion);\n        return PyErr_WarnEx(NULL, message, 1);\n    }\n    return 0;\n}", "path": "invoice/text/detector/utils/cython_nms.c", "commit_date": "2019-08-02 00:00:00", "repo_name": "guanshuicheng/invoice", "stars": 1593, "license": "mit", "language": "c", "size": 7963}
{"docstring": "/* RaiseDoubleKeywords */\n", "func_signal": "static void __Pyx_RaiseDoubleKeywordsError(\n    const char* func_name,\n    PyObject* kw_name)", "code": "{\n    PyErr_Format(PyExc_TypeError,\n        #if PY_MAJOR_VERSION >= 3\n        \"%s() got multiple values for keyword argument '%U'\", func_name, kw_name);\n        #else\n        \"%s() got multiple values for keyword argument '%s'\", func_name,\n        PyString_AsString(kw_name));\n        #endif\n}", "path": "invoice/text/detector/utils/cython_nms.c", "commit_date": "2019-08-02 00:00:00", "repo_name": "guanshuicheng/invoice", "stars": 1593, "license": "mit", "language": "c", "size": 7963}
{"docstring": "/* CIntFromPy */\n", "func_signal": "static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *x)", "code": "{\n    const long neg_one = (long) -1, const_zero = (long) 0;\n    const int is_unsigned = neg_one > const_zero;\n#if PY_MAJOR_VERSION < 3\n    if (likely(PyInt_Check(x))) {\n        if (sizeof(long) < sizeof(long)) {\n            __PYX_VERIFY_RETURN_INT(long, long, PyInt_AS_LONG(x))\n        } else {\n            long val = PyInt_AS_LONG(x);\n            if (is_unsigned && unlikely(val < 0)) {\n                goto raise_neg_overflow;\n            }\n            return (long) val;\n        }\n    } else\n#endif\n    if (likely(PyLong_Check(x))) {\n        if (is_unsigned) {\n#if CYTHON_USE_PYLONG_INTERNALS\n            const digit* digits = ((PyLongObject*)x)->ob_digit;\n            switch (Py_SIZE(x)) {\n                case  0: return (long) 0;\n                case  1: __PYX_VERIFY_RETURN_INT(long, digit, digits[0])\n                case 2:\n                    if (8 * sizeof(long) > 1 * PyLong_SHIFT) {\n                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {\n                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))\n                        } else if (8 * sizeof(long) >= 2 * PyLong_SHIFT) {\n                            return (long) (((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));\n                        }\n                    }\n                    break;\n                case 3:\n                    if (8 * sizeof(long) > 2 * PyLong_SHIFT) {\n                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {\n                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))\n                        } else if (8 * sizeof(long) >= 3 * PyLong_SHIFT) {\n                            return (long) (((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));\n                        }\n                    }\n                    break;\n                case 4:\n                    if (8 * sizeof(long) > 3 * PyLong_SHIFT) {\n                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {\n                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))\n                        } else if (8 * sizeof(long) >= 4 * PyLong_SHIFT) {\n                            return (long) (((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));\n                        }\n                    }\n                    break;\n            }\n#endif\n#if CYTHON_COMPILING_IN_CPYTHON\n            if (unlikely(Py_SIZE(x) < 0)) {\n                goto raise_neg_overflow;\n            }\n#else\n            {\n                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);\n                if (unlikely(result < 0))\n                    return (long) -1;\n                if (unlikely(result == 1))\n                    goto raise_neg_overflow;\n            }\n#endif\n            if (sizeof(long) <= sizeof(unsigned long)) {\n                __PYX_VERIFY_RETURN_INT_EXC(long, unsigned long, PyLong_AsUnsignedLong(x))\n#ifdef HAVE_LONG_LONG\n            } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {\n                __PYX_VERIFY_RETURN_INT_EXC(long, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))\n#endif\n            }\n        } else {\n#if CYTHON_USE_PYLONG_INTERNALS\n            const digit* digits = ((PyLongObject*)x)->ob_digit;\n            switch (Py_SIZE(x)) {\n                case  0: return (long) 0;\n                case -1: __PYX_VERIFY_RETURN_INT(long, sdigit, (sdigit) (-(sdigit)digits[0]))\n                case  1: __PYX_VERIFY_RETURN_INT(long,  digit, +digits[0])\n                case -2:\n                    if (8 * sizeof(long) - 1 > 1 * PyLong_SHIFT) {\n                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {\n                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))\n                        } else if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {\n                            return (long) (((long)-1)*(((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));\n                        }\n                    }\n                    break;\n                case 2:\n                    if (8 * sizeof(long) > 1 * PyLong_SHIFT) {\n                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {\n                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))\n                        } else if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {\n                            return (long) ((((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));\n                        }\n                    }\n                    break;\n                case -3:\n                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {\n                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {\n                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))\n                        } else if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {\n                            return (long) (((long)-1)*(((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));\n                        }\n                    }\n                    break;\n                case 3:\n                    if (8 * sizeof(long) > 2 * PyLong_SHIFT) {\n                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {\n                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))\n                        } else if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {\n                            return (long) ((((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));\n                        }\n                    }\n                    break;\n                case -4:\n                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {\n                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {\n                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))\n                        } else if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {\n                            return (long) (((long)-1)*(((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));\n                        }\n                    }\n                    break;\n                case 4:\n                    if (8 * sizeof(long) > 3 * PyLong_SHIFT) {\n                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {\n                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))\n                        } else if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {\n                            return (long) ((((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));\n                        }\n                    }\n                    break;\n            }\n#endif\n            if (sizeof(long) <= sizeof(long)) {\n                __PYX_VERIFY_RETURN_INT_EXC(long, long, PyLong_AsLong(x))\n#ifdef HAVE_LONG_LONG\n            } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {\n                __PYX_VERIFY_RETURN_INT_EXC(long, PY_LONG_LONG, PyLong_AsLongLong(x))\n#endif\n            }\n        }\n        {\n#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)\n            PyErr_SetString(PyExc_RuntimeError,\n                            \"_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers\");\n#else\n            long val;\n            PyObject *v = __Pyx_PyNumber_IntOrLong(x);\n #if PY_MAJOR_VERSION < 3\n            if (likely(v) && !PyLong_Check(v)) {\n                PyObject *tmp = v;\n                v = PyNumber_Long(tmp);\n                Py_DECREF(tmp);\n            }\n #endif\n            if (likely(v)) {\n                int one = 1; int is_little = (int)*(unsigned char *)&one;\n                unsigned char *bytes = (unsigned char *)&val;\n                int ret = _PyLong_AsByteArray((PyLongObject *)v,\n                                              bytes, sizeof(val),\n                                              is_little, !is_unsigned);\n                Py_DECREF(v);\n                if (likely(!ret))\n                    return val;\n            }\n#endif\n            return (long) -1;\n        }\n    } else {\n        long val;\n        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);\n        if (!tmp) return (long) -1;\n        val = __Pyx_PyInt_As_long(tmp);\n        Py_DECREF(tmp);\n        return val;\n    }\nraise_overflow:\n    PyErr_SetString(PyExc_OverflowError,\n        \"value too large to convert to long\");\n    return (long) -1;\nraise_neg_overflow:\n    PyErr_SetString(PyExc_OverflowError,\n        \"can't convert negative value to long\");\n    return (long) -1;\n}", "path": "invoice/text/detector/utils/cython_nms.c", "commit_date": "2019-08-02 00:00:00", "repo_name": "guanshuicheng/invoice", "stars": 1593, "license": "mit", "language": "c", "size": 7963}
{"docstring": "/* \"../../../../../../../anaconda3/envs/chineseocr/lib/python3.6/site-packages/Cython/Includes/numpy/__init__.pxd\":1002\n *         raise ImportError(\"numpy.core.multiarray failed to import\")\n * \n * cdef inline int import_umath() except -1:             # <<<<<<<<<<<<<<\n *     try:\n *         _import_umath()\n */\n", "func_signal": "static CYTHON_INLINE int __pyx_f_5numpy_import_umath(void)", "code": "{\n  int __pyx_r;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  int __pyx_t_4;\n  PyObject *__pyx_t_5 = NULL;\n  PyObject *__pyx_t_6 = NULL;\n  PyObject *__pyx_t_7 = NULL;\n  PyObject *__pyx_t_8 = NULL;\n  __Pyx_RefNannySetupContext(\"import_umath\", 0);\n\n  /* \"../../../../../../../anaconda3/envs/chineseocr/lib/python3.6/site-packages/Cython/Includes/numpy/__init__.pxd\":1003\n * \n * cdef inline int import_umath() except -1:\n *     try:             # <<<<<<<<<<<<<<\n *         _import_umath()\n *     except Exception:\n */\n  {\n    __Pyx_PyThreadState_declare\n    __Pyx_PyThreadState_assign\n    __Pyx_ExceptionSave(&__pyx_t_1, &__pyx_t_2, &__pyx_t_3);\n    __Pyx_XGOTREF(__pyx_t_1);\n    __Pyx_XGOTREF(__pyx_t_2);\n    __Pyx_XGOTREF(__pyx_t_3);\n    /*try:*/ {\n\n      /* \"../../../../../../../anaconda3/envs/chineseocr/lib/python3.6/site-packages/Cython/Includes/numpy/__init__.pxd\":1004\n * cdef inline int import_umath() except -1:\n *     try:\n *         _import_umath()             # <<<<<<<<<<<<<<\n *     except Exception:\n *         raise ImportError(\"numpy.core.umath failed to import\")\n */\n      __pyx_t_4 = _import_umath(); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(1, 1004, __pyx_L3_error)\n\n      /* \"../../../../../../../anaconda3/envs/chineseocr/lib/python3.6/site-packages/Cython/Includes/numpy/__init__.pxd\":1003\n * \n * cdef inline int import_umath() except -1:\n *     try:             # <<<<<<<<<<<<<<\n *         _import_umath()\n *     except Exception:\n */\n    }\n    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;\n    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;\n    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;\n    goto __pyx_L8_try_end;\n    __pyx_L3_error:;\n\n    /* \"../../../../../../../anaconda3/envs/chineseocr/lib/python3.6/site-packages/Cython/Includes/numpy/__init__.pxd\":1005\n *     try:\n *         _import_umath()\n *     except Exception:             # <<<<<<<<<<<<<<\n *         raise ImportError(\"numpy.core.umath failed to import\")\n * \n */\n    __pyx_t_4 = __Pyx_PyErr_ExceptionMatches(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));\n    if (__pyx_t_4) {\n      __Pyx_AddTraceback(\"numpy.import_umath\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n      if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7) < 0) __PYX_ERR(1, 1005, __pyx_L5_except_error)\n      __Pyx_GOTREF(__pyx_t_5);\n      __Pyx_GOTREF(__pyx_t_6);\n      __Pyx_GOTREF(__pyx_t_7);\n\n      /* \"../../../../../../../anaconda3/envs/chineseocr/lib/python3.6/site-packages/Cython/Includes/numpy/__init__.pxd\":1006\n *         _import_umath()\n *     except Exception:\n *         raise ImportError(\"numpy.core.umath failed to import\")             # <<<<<<<<<<<<<<\n * \n * cdef inline int import_ufunc() except -1:\n */\n      __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_ImportError, __pyx_tuple__30, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 1006, __pyx_L5_except_error)\n      __Pyx_GOTREF(__pyx_t_8);\n      __Pyx_Raise(__pyx_t_8, 0, 0, 0);\n      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;\n      __PYX_ERR(1, 1006, __pyx_L5_except_error)\n    }\n    goto __pyx_L5_except_error;\n    __pyx_L5_except_error:;\n\n    /* \"../../../../../../../anaconda3/envs/chineseocr/lib/python3.6/site-packages/Cython/Includes/numpy/__init__.pxd\":1003\n * \n * cdef inline int import_umath() except -1:\n *     try:             # <<<<<<<<<<<<<<\n *         _import_umath()\n *     except Exception:\n */\n    __Pyx_XGIVEREF(__pyx_t_1);\n    __Pyx_XGIVEREF(__pyx_t_2);\n    __Pyx_XGIVEREF(__pyx_t_3);\n    __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);\n    goto __pyx_L1_error;\n    __pyx_L8_try_end:;\n  }\n\n  /* \"../../../../../../../anaconda3/envs/chineseocr/lib/python3.6/site-packages/Cython/Includes/numpy/__init__.pxd\":1002\n *         raise ImportError(\"numpy.core.multiarray failed to import\")\n * \n * cdef inline int import_umath() except -1:             # <<<<<<<<<<<<<<\n *     try:\n *         _import_umath()\n */\n\n  /* function exit code */\n  __pyx_r = 0;\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_5);\n  __Pyx_XDECREF(__pyx_t_6);\n  __Pyx_XDECREF(__pyx_t_7);\n  __Pyx_XDECREF(__pyx_t_8);\n  __Pyx_AddTraceback(\"numpy.import_umath\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = -1;\n  __pyx_L0:;\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}", "path": "invoice/text/detector/utils/cython_nms.c", "commit_date": "2019-08-02 00:00:00", "repo_name": "guanshuicheng/invoice", "stars": 1593, "license": "mit", "language": "c", "size": 7963}
{"docstring": "/* \"../../../../../../../anaconda3/envs/chineseocr/lib/python3.6/site-packages/Cython/Includes/numpy/__init__.pxd\":790\n *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)\n * \n * cdef inline tuple PyDataType_SHAPE(dtype d):             # <<<<<<<<<<<<<<\n *     if PyDataType_HASSUBARRAY(d):\n *         return <tuple>d.subarray.shape\n */\n", "func_signal": "static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyDataType_SHAPE(PyArray_Descr *__pyx_v_d)", "code": "{\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  int __pyx_t_1;\n  __Pyx_RefNannySetupContext(\"PyDataType_SHAPE\", 0);\n\n  /* \"../../../../../../../anaconda3/envs/chineseocr/lib/python3.6/site-packages/Cython/Includes/numpy/__init__.pxd\":791\n * \n * cdef inline tuple PyDataType_SHAPE(dtype d):\n *     if PyDataType_HASSUBARRAY(d):             # <<<<<<<<<<<<<<\n *         return <tuple>d.subarray.shape\n *     else:\n */\n  __pyx_t_1 = (PyDataType_HASSUBARRAY(__pyx_v_d) != 0);\n  if (__pyx_t_1) {\n\n    /* \"../../../../../../../anaconda3/envs/chineseocr/lib/python3.6/site-packages/Cython/Includes/numpy/__init__.pxd\":792\n * cdef inline tuple PyDataType_SHAPE(dtype d):\n *     if PyDataType_HASSUBARRAY(d):\n *         return <tuple>d.subarray.shape             # <<<<<<<<<<<<<<\n *     else:\n *         return ()\n */\n    __Pyx_XDECREF(__pyx_r);\n    __Pyx_INCREF(((PyObject*)__pyx_v_d->subarray->shape));\n    __pyx_r = ((PyObject*)__pyx_v_d->subarray->shape);\n    goto __pyx_L0;\n\n    /* \"../../../../../../../anaconda3/envs/chineseocr/lib/python3.6/site-packages/Cython/Includes/numpy/__init__.pxd\":791\n * \n * cdef inline tuple PyDataType_SHAPE(dtype d):\n *     if PyDataType_HASSUBARRAY(d):             # <<<<<<<<<<<<<<\n *         return <tuple>d.subarray.shape\n *     else:\n */\n  }\n\n  /* \"../../../../../../../anaconda3/envs/chineseocr/lib/python3.6/site-packages/Cython/Includes/numpy/__init__.pxd\":794\n *         return <tuple>d.subarray.shape\n *     else:\n *         return ()             # <<<<<<<<<<<<<<\n * \n * cdef inline char* _util_dtypestring(dtype descr, char* f, char* end, int* offset) except NULL:\n */\n  /*else*/ {\n    __Pyx_XDECREF(__pyx_r);\n    __Pyx_INCREF(__pyx_empty_tuple);\n    __pyx_r = __pyx_empty_tuple;\n    goto __pyx_L0;\n  }\n\n  /* \"../../../../../../../anaconda3/envs/chineseocr/lib/python3.6/site-packages/Cython/Includes/numpy/__init__.pxd\":790\n *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)\n * \n * cdef inline tuple PyDataType_SHAPE(dtype d):             # <<<<<<<<<<<<<<\n *     if PyDataType_HASSUBARRAY(d):\n *         return <tuple>d.subarray.shape\n */\n\n  /* function exit code */\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}", "path": "invoice/text/detector/utils/cython_nms.c", "commit_date": "2019-08-02 00:00:00", "repo_name": "guanshuicheng/invoice", "stars": 1593, "license": "mit", "language": "c", "size": 7963}
{"docstring": "//From Berkeley Vision's Caffe!\n//https://github.com/BVLC/caffe/blob/master/LICENSE\n", "func_signal": "void im2col_cpu(float* data_im,\n     int channels,  int height,  int width,\n     int ksize,  int stride, int pad, float* data_col)", "code": "{\n    int c,h,w;\n    int height_col = (height + 2*pad - ksize) / stride + 1;\n    int width_col = (width + 2*pad - ksize) / stride + 1;\n\n    int channels_col = channels * ksize * ksize;\n    for (c = 0; c < channels_col; ++c) {\n        int w_offset = c % ksize;\n        int h_offset = (c / ksize) % ksize;\n        int c_im = c / ksize / ksize;\n        for (h = 0; h < height_col; ++h) {\n            for (w = 0; w < width_col; ++w) {\n                int im_row = h_offset + h * stride;\n                int im_col = w_offset + w * stride;\n                int col_index = (c * height_col + h) * width_col + w;\n                data_col[col_index] = im2col_get_pixel(data_im, height, width, channels,\n                        im_row, im_col, c_im, pad);\n            }\n        }\n    }\n}", "path": "invoice/darknet/src/im2col.c", "commit_date": "2019-08-02 00:00:00", "repo_name": "guanshuicheng/invoice", "stars": 1593, "license": "mit", "language": "c", "size": 7963}
{"docstring": "/* __GNUC__ */\n", "func_signal": "static CYTHON_INLINE void __Pyx_pretend_to_initialize(void* ptr)", "code": "{ (void)ptr; }\n\nstatic PyObject *__pyx_m = NULL;\nstatic PyObject *__pyx_d;\nstatic PyObject *__pyx_b;\nstatic PyObject *__pyx_cython_runtime = NULL;\nstatic PyObject *__pyx_empty_tuple;\nstatic PyObject *__pyx_empty_bytes;\nstatic PyObject *__pyx_empty_unicode;\nstatic int __pyx_lineno;\nstatic int __pyx_clineno = 0;\nstatic const char * __pyx_cfilenm= __FILE__;\nstatic const char *__pyx_filename;\n\n/* Header.proto */\n#if !defined(CYTHON_CCOMPLEX)\n  #if defined(__cplusplus)\n    #define CYTHON_CCOMPLEX 1\n  #elif defined(_Complex_I)\n    #define CYTHON_CCOMPLEX 1\n  #else\n    #define CYTHON_CCOMPLEX 0\n  #endif\n#endif\n#if CYTHON_CCOMPLEX\n  #ifdef __cplusplus\n    #include <complex>\n  #else\n    #include <complex.h>\n  #endif\n#endif\n#if CYTHON_CCOMPLEX && !defined(__cplusplus) && defined(__sun__) && defined(__GNUC__)\n  #undef _Complex_I\n  #define _Complex_I 1.0fj\n#endif\n\n\nstatic const char *__pyx_f[] = {\n  \"cython_nms.pyx\",\n  \"__init__.pxd\",\n  \"type.pxd\",\n}", "path": "invoice/text/detector/utils/cython_nms.c", "commit_date": "2019-08-02 00:00:00", "repo_name": "guanshuicheng/invoice", "stars": 1593, "license": "mit", "language": "c", "size": 7963}
{"docstring": "/* \"../../../../../../../anaconda3/envs/chineseocr/lib/python3.6/site-packages/Cython/Includes/numpy/__init__.pxd\":787\n *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)\n * \n * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):             # <<<<<<<<<<<<<<\n *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)\n * \n */\n", "func_signal": "static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew5(PyObject *__pyx_v_a, PyObject *__pyx_v_b, PyObject *__pyx_v_c, PyObject *__pyx_v_d, PyObject *__pyx_v_e)", "code": "{\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  __Pyx_RefNannySetupContext(\"PyArray_MultiIterNew5\", 0);\n\n  /* \"../../../../../../../anaconda3/envs/chineseocr/lib/python3.6/site-packages/Cython/Includes/numpy/__init__.pxd\":788\n * \n * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):\n *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)             # <<<<<<<<<<<<<<\n * \n * cdef inline tuple PyDataType_SHAPE(dtype d):\n */\n  __Pyx_XDECREF(__pyx_r);\n  __pyx_t_1 = PyArray_MultiIterNew(5, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c), ((void *)__pyx_v_d), ((void *)__pyx_v_e)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 788, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_r = __pyx_t_1;\n  __pyx_t_1 = 0;\n  goto __pyx_L0;\n\n  /* \"../../../../../../../anaconda3/envs/chineseocr/lib/python3.6/site-packages/Cython/Includes/numpy/__init__.pxd\":787\n *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)\n * \n * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):             # <<<<<<<<<<<<<<\n *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)\n * \n */\n\n  /* function exit code */\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_AddTraceback(\"numpy.PyArray_MultiIterNew5\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = 0;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}", "path": "invoice/text/detector/utils/cython_nms.c", "commit_date": "2019-08-02 00:00:00", "repo_name": "guanshuicheng/invoice", "stars": 1593, "license": "mit", "language": "c", "size": 7963}
{"docstring": "/* \"../../../../../../../anaconda3/envs/chineseocr/lib/python3.6/site-packages/Cython/Includes/numpy/__init__.pxd\":1008\n *         raise ImportError(\"numpy.core.umath failed to import\")\n * \n * cdef inline int import_ufunc() except -1:             # <<<<<<<<<<<<<<\n *     try:\n *         _import_umath()\n */\n", "func_signal": "static CYTHON_INLINE int __pyx_f_5numpy_import_ufunc(void)", "code": "{\n  int __pyx_r;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  int __pyx_t_4;\n  PyObject *__pyx_t_5 = NULL;\n  PyObject *__pyx_t_6 = NULL;\n  PyObject *__pyx_t_7 = NULL;\n  PyObject *__pyx_t_8 = NULL;\n  __Pyx_RefNannySetupContext(\"import_ufunc\", 0);\n\n  /* \"../../../../../../../anaconda3/envs/chineseocr/lib/python3.6/site-packages/Cython/Includes/numpy/__init__.pxd\":1009\n * \n * cdef inline int import_ufunc() except -1:\n *     try:             # <<<<<<<<<<<<<<\n *         _import_umath()\n *     except Exception:\n */\n  {\n    __Pyx_PyThreadState_declare\n    __Pyx_PyThreadState_assign\n    __Pyx_ExceptionSave(&__pyx_t_1, &__pyx_t_2, &__pyx_t_3);\n    __Pyx_XGOTREF(__pyx_t_1);\n    __Pyx_XGOTREF(__pyx_t_2);\n    __Pyx_XGOTREF(__pyx_t_3);\n    /*try:*/ {\n\n      /* \"../../../../../../../anaconda3/envs/chineseocr/lib/python3.6/site-packages/Cython/Includes/numpy/__init__.pxd\":1010\n * cdef inline int import_ufunc() except -1:\n *     try:\n *         _import_umath()             # <<<<<<<<<<<<<<\n *     except Exception:\n *         raise ImportError(\"numpy.core.umath failed to import\")\n */\n      __pyx_t_4 = _import_umath(); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(1, 1010, __pyx_L3_error)\n\n      /* \"../../../../../../../anaconda3/envs/chineseocr/lib/python3.6/site-packages/Cython/Includes/numpy/__init__.pxd\":1009\n * \n * cdef inline int import_ufunc() except -1:\n *     try:             # <<<<<<<<<<<<<<\n *         _import_umath()\n *     except Exception:\n */\n    }\n    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;\n    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;\n    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;\n    goto __pyx_L8_try_end;\n    __pyx_L3_error:;\n\n    /* \"../../../../../../../anaconda3/envs/chineseocr/lib/python3.6/site-packages/Cython/Includes/numpy/__init__.pxd\":1011\n *     try:\n *         _import_umath()\n *     except Exception:             # <<<<<<<<<<<<<<\n *         raise ImportError(\"numpy.core.umath failed to import\")\n */\n    __pyx_t_4 = __Pyx_PyErr_ExceptionMatches(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));\n    if (__pyx_t_4) {\n      __Pyx_AddTraceback(\"numpy.import_ufunc\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n      if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7) < 0) __PYX_ERR(1, 1011, __pyx_L5_except_error)\n      __Pyx_GOTREF(__pyx_t_5);\n      __Pyx_GOTREF(__pyx_t_6);\n      __Pyx_GOTREF(__pyx_t_7);\n\n      /* \"../../../../../../../anaconda3/envs/chineseocr/lib/python3.6/site-packages/Cython/Includes/numpy/__init__.pxd\":1012\n *         _import_umath()\n *     except Exception:\n *         raise ImportError(\"numpy.core.umath failed to import\")             # <<<<<<<<<<<<<<\n */\n      __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_ImportError, __pyx_tuple__31, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 1012, __pyx_L5_except_error)\n      __Pyx_GOTREF(__pyx_t_8);\n      __Pyx_Raise(__pyx_t_8, 0, 0, 0);\n      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;\n      __PYX_ERR(1, 1012, __pyx_L5_except_error)\n    }\n    goto __pyx_L5_except_error;\n    __pyx_L5_except_error:;\n\n    /* \"../../../../../../../anaconda3/envs/chineseocr/lib/python3.6/site-packages/Cython/Includes/numpy/__init__.pxd\":1009\n * \n * cdef inline int import_ufunc() except -1:\n *     try:             # <<<<<<<<<<<<<<\n *         _import_umath()\n *     except Exception:\n */\n    __Pyx_XGIVEREF(__pyx_t_1);\n    __Pyx_XGIVEREF(__pyx_t_2);\n    __Pyx_XGIVEREF(__pyx_t_3);\n    __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);\n    goto __pyx_L1_error;\n    __pyx_L8_try_end:;\n  }\n\n  /* \"../../../../../../../anaconda3/envs/chineseocr/lib/python3.6/site-packages/Cython/Includes/numpy/__init__.pxd\":1008\n *         raise ImportError(\"numpy.core.umath failed to import\")\n * \n * cdef inline int import_ufunc() except -1:             # <<<<<<<<<<<<<<\n *     try:\n *         _import_umath()\n */\n\n  /* function exit code */\n  __pyx_r = 0;\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_5);\n  __Pyx_XDECREF(__pyx_t_6);\n  __Pyx_XDECREF(__pyx_t_7);\n  __Pyx_XDECREF(__pyx_t_8);\n  __Pyx_AddTraceback(\"numpy.import_ufunc\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = -1;\n  __pyx_L0:;\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}", "path": "invoice/text/detector/utils/cython_nms.c", "commit_date": "2019-08-02 00:00:00", "repo_name": "guanshuicheng/invoice", "stars": 1593, "license": "mit", "language": "c", "size": 7963}
{"docstring": "/* RaiseArgTupleInvalid */\n", "func_signal": "static void __Pyx_RaiseArgtupleInvalid(\n    const char* func_name,\n    int exact,\n    Py_ssize_t num_min,\n    Py_ssize_t num_max,\n    Py_ssize_t num_found)", "code": "{\n    Py_ssize_t num_expected;\n    const char *more_or_less;\n    if (num_found < num_min) {\n        num_expected = num_min;\n        more_or_less = \"at least\";\n    } else {\n        num_expected = num_max;\n        more_or_less = \"at most\";\n    }\n    if (exact) {\n        more_or_less = \"exactly\";\n    }\n    PyErr_Format(PyExc_TypeError,\n                 \"%.200s() takes %.8s %\" CYTHON_FORMAT_SSIZE_T \"d positional argument%.1s (%\" CYTHON_FORMAT_SSIZE_T \"d given)\",\n                 func_name, more_or_less, num_expected,\n                 (num_expected == 1) ? \"\" : \"s\", num_found);\n}", "path": "invoice/text/detector/utils/cython_nms.c", "commit_date": "2019-08-02 00:00:00", "repo_name": "guanshuicheng/invoice", "stars": 1593, "license": "mit", "language": "c", "size": 7963}
{"docstring": "/* \"../../../../../../../anaconda3/envs/chineseocr/lib/python3.6/site-packages/Cython/Includes/numpy/__init__.pxd\":977\n * \n * \n * cdef inline void set_array_base(ndarray arr, object base):             # <<<<<<<<<<<<<<\n *      cdef PyObject* baseptr\n *      if base is None:\n */\n", "func_signal": "static CYTHON_INLINE void __pyx_f_5numpy_set_array_base(PyArrayObject *__pyx_v_arr, PyObject *__pyx_v_base)", "code": "{\n  PyObject *__pyx_v_baseptr;\n  __Pyx_RefNannyDeclarations\n  int __pyx_t_1;\n  int __pyx_t_2;\n  __Pyx_RefNannySetupContext(\"set_array_base\", 0);\n\n  /* \"../../../../../../../anaconda3/envs/chineseocr/lib/python3.6/site-packages/Cython/Includes/numpy/__init__.pxd\":979\n * cdef inline void set_array_base(ndarray arr, object base):\n *      cdef PyObject* baseptr\n *      if base is None:             # <<<<<<<<<<<<<<\n *          baseptr = NULL\n *      else:\n */\n  __pyx_t_1 = (__pyx_v_base == Py_None);\n  __pyx_t_2 = (__pyx_t_1 != 0);\n  if (__pyx_t_2) {\n\n    /* \"../../../../../../../anaconda3/envs/chineseocr/lib/python3.6/site-packages/Cython/Includes/numpy/__init__.pxd\":980\n *      cdef PyObject* baseptr\n *      if base is None:\n *          baseptr = NULL             # <<<<<<<<<<<<<<\n *      else:\n *          Py_INCREF(base) # important to do this before decref below!\n */\n    __pyx_v_baseptr = NULL;\n\n    /* \"../../../../../../../anaconda3/envs/chineseocr/lib/python3.6/site-packages/Cython/Includes/numpy/__init__.pxd\":979\n * cdef inline void set_array_base(ndarray arr, object base):\n *      cdef PyObject* baseptr\n *      if base is None:             # <<<<<<<<<<<<<<\n *          baseptr = NULL\n *      else:\n */\n    goto __pyx_L3;\n  }\n\n  /* \"../../../../../../../anaconda3/envs/chineseocr/lib/python3.6/site-packages/Cython/Includes/numpy/__init__.pxd\":982\n *          baseptr = NULL\n *      else:\n *          Py_INCREF(base) # important to do this before decref below!             # <<<<<<<<<<<<<<\n *          baseptr = <PyObject*>base\n *      Py_XDECREF(arr.base)\n */\n  /*else*/ {\n    Py_INCREF(__pyx_v_base);\n\n    /* \"../../../../../../../anaconda3/envs/chineseocr/lib/python3.6/site-packages/Cython/Includes/numpy/__init__.pxd\":983\n *      else:\n *          Py_INCREF(base) # important to do this before decref below!\n *          baseptr = <PyObject*>base             # <<<<<<<<<<<<<<\n *      Py_XDECREF(arr.base)\n *      arr.base = baseptr\n */\n    __pyx_v_baseptr = ((PyObject *)__pyx_v_base);\n  }\n  __pyx_L3:;\n\n  /* \"../../../../../../../anaconda3/envs/chineseocr/lib/python3.6/site-packages/Cython/Includes/numpy/__init__.pxd\":984\n *          Py_INCREF(base) # important to do this before decref below!\n *          baseptr = <PyObject*>base\n *      Py_XDECREF(arr.base)             # <<<<<<<<<<<<<<\n *      arr.base = baseptr\n * \n */\n  Py_XDECREF(__pyx_v_arr->base);\n\n  /* \"../../../../../../../anaconda3/envs/chineseocr/lib/python3.6/site-packages/Cython/Includes/numpy/__init__.pxd\":985\n *          baseptr = <PyObject*>base\n *      Py_XDECREF(arr.base)\n *      arr.base = baseptr             # <<<<<<<<<<<<<<\n * \n * cdef inline object get_array_base(ndarray arr):\n */\n  __pyx_v_arr->base = __pyx_v_baseptr;\n\n  /* \"../../../../../../../anaconda3/envs/chineseocr/lib/python3.6/site-packages/Cython/Includes/numpy/__init__.pxd\":977\n * \n * \n * cdef inline void set_array_base(ndarray arr, object base):             # <<<<<<<<<<<<<<\n *      cdef PyObject* baseptr\n *      if base is None:\n */\n\n  /* function exit code */\n  __Pyx_RefNannyFinishContext();\n}", "path": "invoice/text/detector/utils/cython_nms.c", "commit_date": "2019-08-02 00:00:00", "repo_name": "guanshuicheng/invoice", "stars": 1593, "license": "mit", "language": "c", "size": 7963}
{"docstring": "/*\n// old timing. is it better? who knows!!\ndouble get_wall_time()\n{\n    struct timeval time;\n    if (gettimeofday(&time,NULL)){\n        return 0;\n    }\n    return (double)time.tv_sec + (double)time.tv_usec * .000001;\n}\n*/\n", "func_signal": "double what_time_is_it_now()", "code": "{\n    struct timeval time;\n    if (gettimeofday(&time,NULL)){\n        return 0;\n    }\n    return (double)time.tv_sec + (double)time.tv_usec * .000001;\n}", "path": "invoice/darknet/src/utils.c", "commit_date": "2019-08-02 00:00:00", "repo_name": "guanshuicheng/invoice", "stars": 1593, "license": "mit", "language": "c", "size": 7963}
{"docstring": "/* ExtTypeTest */\n", "func_signal": "static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type)", "code": "{\n    if (unlikely(!type)) {\n        PyErr_SetString(PyExc_SystemError, \"Missing type object\");\n        return 0;\n    }\n    if (likely(__Pyx_TypeCheck(obj, type)))\n        return 1;\n    PyErr_Format(PyExc_TypeError, \"Cannot convert %.200s to %.200s\",\n                 Py_TYPE(obj)->tp_name, type->tp_name);\n    return 0;\n}", "path": "invoice/text/detector/utils/cython_nms.c", "commit_date": "2019-08-02 00:00:00", "repo_name": "guanshuicheng/invoice", "stars": 1593, "license": "mit", "language": "c", "size": 7963}
{"docstring": "/* BufferIndexError */\n", "func_signal": "static void __Pyx_RaiseBufferIndexError(int axis)", "code": "{\n  PyErr_Format(PyExc_IndexError,\n     \"Out of bounds on buffer access (axis %d)\", axis);\n}", "path": "invoice/text/detector/utils/cython_nms.c", "commit_date": "2019-08-02 00:00:00", "repo_name": "guanshuicheng/invoice", "stars": 1593, "license": "mit", "language": "c", "size": 7963}
{"docstring": "/* InitStrings */\n", "func_signal": "static int __Pyx_InitStrings(__Pyx_StringTabEntry *t)", "code": "{\n    while (t->p) {\n        #if PY_MAJOR_VERSION < 3\n        if (t->is_unicode) {\n            *t->p = PyUnicode_DecodeUTF8(t->s, t->n - 1, NULL);\n        } else if (t->intern) {\n            *t->p = PyString_InternFromString(t->s);\n        } else {\n            *t->p = PyString_FromStringAndSize(t->s, t->n - 1);\n        }\n        #else\n        if (t->is_unicode | t->is_str) {\n            if (t->intern) {\n                *t->p = PyUnicode_InternFromString(t->s);\n            } else if (t->encoding) {\n                *t->p = PyUnicode_Decode(t->s, t->n - 1, t->encoding, NULL);\n            } else {\n                *t->p = PyUnicode_FromStringAndSize(t->s, t->n - 1);\n            }\n        } else {\n            *t->p = PyBytes_FromStringAndSize(t->s, t->n - 1);\n        }\n        #endif\n        if (!*t->p)\n            return -1;\n        if (PyObject_Hash(*t->p) == -1)\n            return -1;\n        ++t;\n    }\n    return 0;\n}", "path": "invoice/text/detector/utils/cython_nms.c", "commit_date": "2019-08-02 00:00:00", "repo_name": "guanshuicheng/invoice", "stars": 1593, "license": "mit", "language": "c", "size": 7963}
{"docstring": "/* CIntFromPy */\n", "func_signal": "static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *x)", "code": "{\n    const int neg_one = (int) -1, const_zero = (int) 0;\n    const int is_unsigned = neg_one > const_zero;\n#if PY_MAJOR_VERSION < 3\n    if (likely(PyInt_Check(x))) {\n        if (sizeof(int) < sizeof(long)) {\n            __PYX_VERIFY_RETURN_INT(int, long, PyInt_AS_LONG(x))\n        } else {\n            long val = PyInt_AS_LONG(x);\n            if (is_unsigned && unlikely(val < 0)) {\n                goto raise_neg_overflow;\n            }\n            return (int) val;\n        }\n    } else\n#endif\n    if (likely(PyLong_Check(x))) {\n        if (is_unsigned) {\n#if CYTHON_USE_PYLONG_INTERNALS\n            const digit* digits = ((PyLongObject*)x)->ob_digit;\n            switch (Py_SIZE(x)) {\n                case  0: return (int) 0;\n                case  1: __PYX_VERIFY_RETURN_INT(int, digit, digits[0])\n                case 2:\n                    if (8 * sizeof(int) > 1 * PyLong_SHIFT) {\n                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {\n                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))\n                        } else if (8 * sizeof(int) >= 2 * PyLong_SHIFT) {\n                            return (int) (((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));\n                        }\n                    }\n                    break;\n                case 3:\n                    if (8 * sizeof(int) > 2 * PyLong_SHIFT) {\n                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {\n                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))\n                        } else if (8 * sizeof(int) >= 3 * PyLong_SHIFT) {\n                            return (int) (((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));\n                        }\n                    }\n                    break;\n                case 4:\n                    if (8 * sizeof(int) > 3 * PyLong_SHIFT) {\n                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {\n                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))\n                        } else if (8 * sizeof(int) >= 4 * PyLong_SHIFT) {\n                            return (int) (((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));\n                        }\n                    }\n                    break;\n            }\n#endif\n#if CYTHON_COMPILING_IN_CPYTHON\n            if (unlikely(Py_SIZE(x) < 0)) {\n                goto raise_neg_overflow;\n            }\n#else\n            {\n                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);\n                if (unlikely(result < 0))\n                    return (int) -1;\n                if (unlikely(result == 1))\n                    goto raise_neg_overflow;\n            }\n#endif\n            if (sizeof(int) <= sizeof(unsigned long)) {\n                __PYX_VERIFY_RETURN_INT_EXC(int, unsigned long, PyLong_AsUnsignedLong(x))\n#ifdef HAVE_LONG_LONG\n            } else if (sizeof(int) <= sizeof(unsigned PY_LONG_LONG)) {\n                __PYX_VERIFY_RETURN_INT_EXC(int, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))\n#endif\n            }\n        } else {\n#if CYTHON_USE_PYLONG_INTERNALS\n            const digit* digits = ((PyLongObject*)x)->ob_digit;\n            switch (Py_SIZE(x)) {\n                case  0: return (int) 0;\n                case -1: __PYX_VERIFY_RETURN_INT(int, sdigit, (sdigit) (-(sdigit)digits[0]))\n                case  1: __PYX_VERIFY_RETURN_INT(int,  digit, +digits[0])\n                case -2:\n                    if (8 * sizeof(int) - 1 > 1 * PyLong_SHIFT) {\n                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {\n                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))\n                        } else if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {\n                            return (int) (((int)-1)*(((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));\n                        }\n                    }\n                    break;\n                case 2:\n                    if (8 * sizeof(int) > 1 * PyLong_SHIFT) {\n                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {\n                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))\n                        } else if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {\n                            return (int) ((((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));\n                        }\n                    }\n                    break;\n                case -3:\n                    if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {\n                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {\n                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))\n                        } else if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {\n                            return (int) (((int)-1)*(((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));\n                        }\n                    }\n                    break;\n                case 3:\n                    if (8 * sizeof(int) > 2 * PyLong_SHIFT) {\n                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {\n                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))\n                        } else if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {\n                            return (int) ((((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));\n                        }\n                    }\n                    break;\n                case -4:\n                    if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {\n                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {\n                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))\n                        } else if (8 * sizeof(int) - 1 > 4 * PyLong_SHIFT) {\n                            return (int) (((int)-1)*(((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));\n                        }\n                    }\n                    break;\n                case 4:\n                    if (8 * sizeof(int) > 3 * PyLong_SHIFT) {\n                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {\n                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))\n                        } else if (8 * sizeof(int) - 1 > 4 * PyLong_SHIFT) {\n                            return (int) ((((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));\n                        }\n                    }\n                    break;\n            }\n#endif\n            if (sizeof(int) <= sizeof(long)) {\n                __PYX_VERIFY_RETURN_INT_EXC(int, long, PyLong_AsLong(x))\n#ifdef HAVE_LONG_LONG\n            } else if (sizeof(int) <= sizeof(PY_LONG_LONG)) {\n                __PYX_VERIFY_RETURN_INT_EXC(int, PY_LONG_LONG, PyLong_AsLongLong(x))\n#endif\n            }\n        }\n        {\n#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)\n            PyErr_SetString(PyExc_RuntimeError,\n                            \"_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers\");\n#else\n            int val;\n            PyObject *v = __Pyx_PyNumber_IntOrLong(x);\n #if PY_MAJOR_VERSION < 3\n            if (likely(v) && !PyLong_Check(v)) {\n                PyObject *tmp = v;\n                v = PyNumber_Long(tmp);\n                Py_DECREF(tmp);\n            }\n #endif\n            if (likely(v)) {\n                int one = 1; int is_little = (int)*(unsigned char *)&one;\n                unsigned char *bytes = (unsigned char *)&val;\n                int ret = _PyLong_AsByteArray((PyLongObject *)v,\n                                              bytes, sizeof(val),\n                                              is_little, !is_unsigned);\n                Py_DECREF(v);\n                if (likely(!ret))\n                    return val;\n            }\n#endif\n            return (int) -1;\n        }\n    } else {\n        int val;\n        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);\n        if (!tmp) return (int) -1;\n        val = __Pyx_PyInt_As_int(tmp);\n        Py_DECREF(tmp);\n        return val;\n    }\nraise_overflow:\n    PyErr_SetString(PyExc_OverflowError,\n        \"value too large to convert to int\");\n    return (int) -1;\nraise_neg_overflow:\n    PyErr_SetString(PyExc_OverflowError,\n        \"can't convert negative value to int\");\n    return (int) -1;\n}", "path": "invoice/text/detector/utils/cython_nms.c", "commit_date": "2019-08-02 00:00:00", "repo_name": "guanshuicheng/invoice", "stars": 1593, "license": "mit", "language": "c", "size": 7963}
{"docstring": "/* \"../../../../../../../anaconda3/envs/chineseocr/lib/python3.6/site-packages/Cython/Includes/numpy/__init__.pxd\":781\n *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)\n * \n * cdef inline object PyArray_MultiIterNew3(a, b, c):             # <<<<<<<<<<<<<<\n *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)\n * \n */\n", "func_signal": "static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew3(PyObject *__pyx_v_a, PyObject *__pyx_v_b, PyObject *__pyx_v_c)", "code": "{\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  __Pyx_RefNannySetupContext(\"PyArray_MultiIterNew3\", 0);\n\n  /* \"../../../../../../../anaconda3/envs/chineseocr/lib/python3.6/site-packages/Cython/Includes/numpy/__init__.pxd\":782\n * \n * cdef inline object PyArray_MultiIterNew3(a, b, c):\n *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)             # <<<<<<<<<<<<<<\n * \n * cdef inline object PyArray_MultiIterNew4(a, b, c, d):\n */\n  __Pyx_XDECREF(__pyx_r);\n  __pyx_t_1 = PyArray_MultiIterNew(3, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 782, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_r = __pyx_t_1;\n  __pyx_t_1 = 0;\n  goto __pyx_L0;\n\n  /* \"../../../../../../../anaconda3/envs/chineseocr/lib/python3.6/site-packages/Cython/Includes/numpy/__init__.pxd\":781\n *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)\n * \n * cdef inline object PyArray_MultiIterNew3(a, b, c):             # <<<<<<<<<<<<<<\n *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)\n * \n */\n\n  /* function exit code */\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_AddTraceback(\"numpy.PyArray_MultiIterNew3\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = 0;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}", "path": "invoice/text/detector/utils/cython_nms.c", "commit_date": "2019-08-02 00:00:00", "repo_name": "guanshuicheng/invoice", "stars": 1593, "license": "mit", "language": "c", "size": 7963}
{"docstring": "/* ParseKeywords */\n", "func_signal": "static int __Pyx_ParseOptionalKeywords(\n    PyObject *kwds,\n    PyObject **argnames[],\n    PyObject *kwds2,\n    PyObject *values[],\n    Py_ssize_t num_pos_args,\n    const char* function_name)", "code": "{\n    PyObject *key = 0, *value = 0;\n    Py_ssize_t pos = 0;\n    PyObject*** name;\n    PyObject*** first_kw_arg = argnames + num_pos_args;\n    while (PyDict_Next(kwds, &pos, &key, &value)) {\n        name = first_kw_arg;\n        while (*name && (**name != key)) name++;\n        if (*name) {\n            values[name-argnames] = value;\n            continue;\n        }\n        name = first_kw_arg;\n        #if PY_MAJOR_VERSION < 3\n        if (likely(PyString_CheckExact(key)) || likely(PyString_Check(key))) {\n            while (*name) {\n                if ((CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**name) == PyString_GET_SIZE(key))\n                        && _PyString_Eq(**name, key)) {\n                    values[name-argnames] = value;\n                    break;\n                }\n                name++;\n            }\n            if (*name) continue;\n            else {\n                PyObject*** argname = argnames;\n                while (argname != first_kw_arg) {\n                    if ((**argname == key) || (\n                            (CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**argname) == PyString_GET_SIZE(key))\n                             && _PyString_Eq(**argname, key))) {\n                        goto arg_passed_twice;\n                    }\n                    argname++;\n                }\n            }\n        } else\n        #endif\n        if (likely(PyUnicode_Check(key))) {\n            while (*name) {\n                int cmp = (**name == key) ? 0 :\n                #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3\n                    (PyUnicode_GET_SIZE(**name) != PyUnicode_GET_SIZE(key)) ? 1 :\n                #endif\n                    PyUnicode_Compare(**name, key);\n                if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;\n                if (cmp == 0) {\n                    values[name-argnames] = value;\n                    break;\n                }\n                name++;\n            }\n            if (*name) continue;\n            else {\n                PyObject*** argname = argnames;\n                while (argname != first_kw_arg) {\n                    int cmp = (**argname == key) ? 0 :\n                    #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3\n                        (PyUnicode_GET_SIZE(**argname) != PyUnicode_GET_SIZE(key)) ? 1 :\n                    #endif\n                        PyUnicode_Compare(**argname, key);\n                    if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;\n                    if (cmp == 0) goto arg_passed_twice;\n                    argname++;\n                }\n            }\n        } else\n            goto invalid_keyword_type;\n        if (kwds2) {\n            if (unlikely(PyDict_SetItem(kwds2, key, value))) goto bad;\n        } else {\n            goto invalid_keyword;\n        }\n    }\n    return 0;\narg_passed_twice:\n    __Pyx_RaiseDoubleKeywordsError(function_name, key);\n    goto bad;\ninvalid_keyword_type:\n    PyErr_Format(PyExc_TypeError,\n        \"%.200s() keywords must be strings\", function_name);\n    goto bad;\ninvalid_keyword:\n    PyErr_Format(PyExc_TypeError,\n    #if PY_MAJOR_VERSION < 3\n        \"%.200s() got an unexpected keyword argument '%.200s'\",\n        function_name, PyString_AsString(key));\n    #else\n        \"%s() got an unexpected keyword argument '%U'\",\n        function_name, key);\n    #endif\nbad:\n    return -1;\n}", "path": "invoice/text/detector/utils/cython_nms.c", "commit_date": "2019-08-02 00:00:00", "repo_name": "guanshuicheng/invoice", "stars": 1593, "license": "mit", "language": "c", "size": 7963}
{"docstring": "// ./darknet nightmare cfg/extractor.recon.cfg ~/trained/yolo-coco.conv frame6.png -reconstruct -iters 500 -i 3 -lambda .1 -rate .01 -smooth 2\n", "func_signal": "float abs_mean(float *x, int n)", "code": "{\n    int i;\n    float sum = 0;\n    for (i = 0; i < n; ++i){\n        sum += fabs(x[i]);\n    }\n    return sum/n;\n}", "path": "invoice/darknet/examples/nightmare.c", "commit_date": "2019-08-02 00:00:00", "repo_name": "guanshuicheng/invoice", "stars": 1593, "license": "mit", "language": "c", "size": 7963}
{"docstring": "/* compress from file to def until provided buffer is full or end of\n   input reached; return last deflate() return value, or Z_ERRNO if\n   there was read error on the file */\n", "func_signal": "local int partcompress(FILE *in, z_streamp def)", "code": "{\n    int ret, flush;\n    unsigned char raw[RAWLEN];\n\n    flush = Z_SYNC_FLUSH;\n    do {\n        def->avail_in = (uInt)fread(raw, 1, RAWLEN, in);\n        if (ferror(in))\n            return Z_ERRNO;\n        def->next_in = raw;\n        if (feof(in))\n            flush = Z_FINISH;\n        LOG_FITBLK(\"partcompress1 avail_in=%d total_in=%d avail_out=%d total_out=%d\\n\", (int)def->avail_in, (int)def->total_in, (int)def->avail_out, (int)def->total_out);\n        ret = deflate(def, flush);\n        LOG_FITBLK(\"partcompress2 ret=%d avail_in=%d total_in=%d avail_out=%d total_out=%d\\n\", ret, (int)def->avail_in, (int)def->total_in, (int)def->avail_out, (int)def->total_out);\n        assert(ret != Z_STREAM_ERROR);\n    } while (def->avail_out != 0 && flush == Z_SYNC_FLUSH);\n    return ret;\n}", "path": "MMseqs2/lib/zstd/zlibWrapper/examples/fitblk.c", "commit_date": "2018-12-05 00:00:00", "repo_name": "soedinglab/MMseqs2", "stars": 1208, "license": "gpl-3.0", "language": "c", "size": 31120}
{"docstring": "/*! HUF_writeCTable_wksp() :\n\t`CTable` : Huffman tree to save, using huf representation.\n\t@return : size of saved CTable */\n", "func_signal": "size_t HUF_writeCTable_wksp(void *dst, size_t maxDstSize, const HUF_CElt *CTable, U32 maxSymbolValue, U32 huffLog, void *workspace, size_t workspaceSize)", "code": "{\n\tBYTE *op = (BYTE *)dst;\n\tU32 n;\n\n\tBYTE *bitsToWeight;\n\tBYTE *huffWeight;\n\tsize_t spaceUsed32 = 0;\n\n\tbitsToWeight = (BYTE *)((U32 *)workspace + spaceUsed32);\n\tspaceUsed32 += ALIGN(HUF_TABLELOG_MAX + 1, sizeof(U32)) >> 2;\n\thuffWeight = (BYTE *)((U32 *)workspace + spaceUsed32);\n\tspaceUsed32 += ALIGN(HUF_SYMBOLVALUE_MAX, sizeof(U32)) >> 2;\n\n\tif ((spaceUsed32 << 2) > workspaceSize)\n\t\treturn ERROR(tableLog_tooLarge);\n\tworkspace = (U32 *)workspace + spaceUsed32;\n\tworkspaceSize -= (spaceUsed32 << 2);\n\n\t/* check conditions */\n\tif (maxSymbolValue > HUF_SYMBOLVALUE_MAX)\n\t\treturn ERROR(maxSymbolValue_tooLarge);\n\n\t/* convert to weight */\n\tbitsToWeight[0] = 0;\n\tfor (n = 1; n < huffLog + 1; n++)\n\t\tbitsToWeight[n] = (BYTE)(huffLog + 1 - n);\n\tfor (n = 0; n < maxSymbolValue; n++)\n\t\thuffWeight[n] = bitsToWeight[CTable[n].nbBits];\n\n\t/* attempt weights compression by FSE */\n\t{\n\t\tCHECK_V_F(hSize, HUF_compressWeights_wksp(op + 1, maxDstSize - 1, huffWeight, maxSymbolValue, workspace, workspaceSize));\n\t\tif ((hSize > 1) & (hSize < maxSymbolValue / 2)) { /* FSE compressed */\n\t\t\top[0] = (BYTE)hSize;\n\t\t\treturn hSize + 1;\n\t\t}\n\t}\n\n\t/* write raw values as 4-bits (max : 15) */\n\tif (maxSymbolValue > (256 - 128))\n\t\treturn ERROR(GENERIC); /* should not happen : likely means source cannot be compressed */\n\tif (((maxSymbolValue + 1) / 2) + 1 > maxDstSize)\n\t\treturn ERROR(dstSize_tooSmall); /* not enough space within dst buffer */\n\top[0] = (BYTE)(128 /*special case*/ + (maxSymbolValue - 1));\n\thuffWeight[maxSymbolValue] = 0; /* to be sure it doesn't cause msan issue in final combination */\n\tfor (n = 0; n < maxSymbolValue; n += 2)\n\t\top[(n / 2) + 1] = (BYTE)((huffWeight[n] << 4) + huffWeight[n + 1]);\n\treturn ((maxSymbolValue + 1) / 2) + 1;\n}", "path": "MMseqs2/lib/zstd/contrib/linux-kernel/lib/zstd/huf_compress.c", "commit_date": "2018-12-05 00:00:00", "repo_name": "soedinglab/MMseqs2", "stars": 1208, "license": "gpl-3.0", "language": "c", "size": 31120}
{"docstring": "/* recompress from inf's input to def's output; the input for inf and\n   the output for def are set in those structures before calling;\n   return last deflate() return value, or Z_MEM_ERROR if inflate()\n   was not able to allocate enough memory when it needed to */\n", "func_signal": "local int recompress(z_streamp inf, z_streamp def)", "code": "{\n    int ret, flush;\n    unsigned char raw[RAWLEN];\n\n    flush = Z_NO_FLUSH;\n    LOG_FITBLK(\"recompress start\\n\");\n    do {\n        /* decompress */\n        inf->avail_out = RAWLEN;\n        inf->next_out = raw;\n        LOG_FITBLK(\"recompress1inflate avail_in=%d total_in=%d avail_out=%d total_out=%d\\n\", (int)inf->avail_in, (int)inf->total_in, (int)inf->avail_out, (int)inf->total_out);\n        ret = inflate(inf, Z_NO_FLUSH);\n        LOG_FITBLK(\"recompress2inflate avail_in=%d total_in=%d avail_out=%d total_out=%d\\n\", (int)inf->avail_in, (int)inf->total_in, (int)inf->avail_out, (int)inf->total_out);\n        assert(ret != Z_STREAM_ERROR && ret != Z_DATA_ERROR &&\n               ret != Z_NEED_DICT);\n        if (ret == Z_MEM_ERROR)\n            return ret;\n\n        /* compress what was decompresed until done or no room */\n        def->avail_in = RAWLEN - inf->avail_out;\n        def->next_in = raw;\n        if (inf->avail_out != 0)\n            flush = Z_FINISH;\n        LOG_FITBLK(\"recompress1deflate avail_in=%d total_in=%d avail_out=%d total_out=%d\\n\", (int)def->avail_in, (int)def->total_in, (int)def->avail_out, (int)def->total_out);\n        ret = deflate(def, flush);\n        LOG_FITBLK(\"recompress2deflate ret=%d avail_in=%d total_in=%d avail_out=%d total_out=%d\\n\", ret, (int)def->avail_in, (int)def->total_in, (int)def->avail_out, (int)def->total_out);\n        assert(ret != Z_STREAM_ERROR);\n    } while (ret != Z_STREAM_END && def->avail_out != 0);\n    return ret;\n}", "path": "MMseqs2/lib/zstd/zlibWrapper/examples/fitblk.c", "commit_date": "2018-12-05 00:00:00", "repo_name": "soedinglab/MMseqs2", "stars": 1208, "license": "gpl-3.0", "language": "c", "size": 31120}
{"docstring": "/* @return : 0 on success, 1 on error */\n", "func_signal": "int POOL_resize(POOL_ctx* ctx, size_t numThreads)", "code": "{\n    int result;\n    if (ctx==NULL) return 1;\n    ZSTD_pthread_mutex_lock(&ctx->queueMutex);\n    result = POOL_resize_internal(ctx, numThreads);\n    ZSTD_pthread_cond_broadcast(&ctx->queuePopCond);\n    ZSTD_pthread_mutex_unlock(&ctx->queueMutex);\n    return result;\n}", "path": "MMseqs2/lib/zstd/lib/common/pool.c", "commit_date": "2018-12-05 00:00:00", "repo_name": "soedinglab/MMseqs2", "stars": 1208, "license": "gpl-3.0", "language": "c", "size": 31120}
{"docstring": "/*_*******************************************************\n*  Command line\n*********************************************************/\n", "func_signal": "static int FUZ_usage(const char* programName)", "code": "{\n    DISPLAY( \"Usage :\\n\");\n    DISPLAY( \"      %s [args]\\n\", programName);\n    DISPLAY( \"\\n\");\n    DISPLAY( \"Arguments :\\n\");\n    DISPLAY( \" -i#    : Nb of tests (default:%u) \\n\", nbTestsDefault);\n    DISPLAY( \" -s#    : Select seed (default:prompt user)\\n\");\n    DISPLAY( \" -t#    : Select starting test number (default:0)\\n\");\n    DISPLAY( \" -P#    : Select compressibility in %% (default:%u%%)\\n\", FUZ_compressibility_default);\n    DISPLAY( \" -v     : verbose\\n\");\n    DISPLAY( \" -p     : pause at the end\\n\");\n    DISPLAY( \" -h     : display help and exit\\n\");\n    return 0;\n}", "path": "MMseqs2/lib/zstd/tests/fuzzer.c", "commit_date": "2018-12-05 00:00:00", "repo_name": "soedinglab/MMseqs2", "stars": 1208, "license": "gpl-3.0", "language": "c", "size": 31120}
{"docstring": "/**\n * Returns 1 if the queue is full and 0 otherwise.\n *\n * When queueSize is 1 (pool was created with an intended queueSize of 0),\n * then a queue is empty if there is a thread free _and_ no job is waiting.\n */\n", "func_signal": "static int isQueueFull(POOL_ctx const* ctx)", "code": "{\n    if (ctx->queueSize > 1) {\n        return ctx->queueHead == ((ctx->queueTail + 1) % ctx->queueSize);\n    } else {\n        return (ctx->numThreadsBusy == ctx->threadLimit) ||\n               !ctx->queueEmpty;\n    }\n}", "path": "MMseqs2/lib/zstd/lib/common/pool.c", "commit_date": "2018-12-05 00:00:00", "repo_name": "soedinglab/MMseqs2", "stars": 1208, "license": "gpl-3.0", "language": "c", "size": 31120}
{"docstring": "/* @return : 0 on success, 1 on error */\n", "func_signal": "static int POOL_resize_internal(POOL_ctx* ctx, size_t numThreads)", "code": "{\n    if (numThreads <= ctx->threadCapacity) {\n        if (!numThreads) return 1;\n        ctx->threadLimit = numThreads;\n        return 0;\n    }\n    /* numThreads > threadCapacity */\n    {   ZSTD_pthread_t* const threadPool = (ZSTD_pthread_t*)ZSTD_malloc(numThreads * sizeof(ZSTD_pthread_t), ctx->customMem);\n        if (!threadPool) return 1;\n        /* replace existing thread pool */\n        memcpy(threadPool, ctx->threads, ctx->threadCapacity * sizeof(*threadPool));\n        ZSTD_free(ctx->threads, ctx->customMem);\n        ctx->threads = threadPool;\n        /* Initialize additional threads */\n        {   size_t threadId;\n            for (threadId = ctx->threadCapacity; threadId < numThreads; ++threadId) {\n                if (ZSTD_pthread_create(&threadPool[threadId], NULL, &POOL_thread, ctx)) {\n                    ctx->threadCapacity = threadId;\n                    return 1;\n            }   }\n    }   }\n    /* successfully expanded */\n    ctx->threadCapacity = numThreads;\n    ctx->threadLimit = numThreads;\n    return 0;\n}", "path": "MMseqs2/lib/zstd/lib/common/pool.c", "commit_date": "2018-12-05 00:00:00", "repo_name": "soedinglab/MMseqs2", "stars": 1208, "license": "gpl-3.0", "language": "c", "size": 31120}
{"docstring": "/* fake FSE_CTable, for rle input (always same symbol) */\n", "func_signal": "size_t FSE_buildCTable_rle (FSE_CTable* ct, BYTE symbolValue)", "code": "{\n    void* ptr = ct;\n    U16* tableU16 = ( (U16*) ptr) + 2;\n    void* FSCTptr = (U32*)ptr + 2;\n    FSE_symbolCompressionTransform* symbolTT = (FSE_symbolCompressionTransform*) FSCTptr;\n\n    /* header */\n    tableU16[-2] = (U16) 0;\n    tableU16[-1] = (U16) symbolValue;\n\n    /* Build table */\n    tableU16[0] = 0;\n    tableU16[1] = 0;   /* just in case */\n\n    /* Build Symbol Transformation Table */\n    symbolTT[symbolValue].deltaNbBits = 0;\n    symbolTT[symbolValue].deltaFindState = 0;\n\n    return 0;\n}", "path": "MMseqs2/lib/zstd/lib/compress/fse_compress.c", "commit_date": "2018-12-05 00:00:00", "repo_name": "soedinglab/MMseqs2", "stars": 1208, "license": "gpl-3.0", "language": "c", "size": 31120}
{"docstring": "/*-**************************************************************\n*  FSE Compression Code\n****************************************************************/\n", "func_signal": "FSE_CTable* FSE_createCTable (unsigned maxSymbolValue, unsigned tableLog)", "code": "{\n    size_t size;\n    if (tableLog > FSE_TABLELOG_ABSOLUTE_MAX) tableLog = FSE_TABLELOG_ABSOLUTE_MAX;\n    size = FSE_CTABLE_SIZE_U32 (tableLog, maxSymbolValue) * sizeof(U32);\n    return (FSE_CTable*)malloc(size);\n}", "path": "MMseqs2/lib/zstd/lib/compress/fse_compress.c", "commit_date": "2018-12-05 00:00:00", "repo_name": "soedinglab/MMseqs2", "stars": 1208, "license": "gpl-3.0", "language": "c", "size": 31120}
{"docstring": "/*=============================================\n*   Unit tests\n=============================================*/\n", "func_signal": "static int basicUnitTests(U32 seed, double compressibility)", "code": "{\n    size_t const CNBuffSize = 5 MB;\n    void* const CNBuffer = malloc(CNBuffSize);\n    size_t const compressedBufferSize = ZSTD_compressBound(CNBuffSize);\n    void* const compressedBuffer = malloc(compressedBufferSize);\n    void* const decodedBuffer = malloc(CNBuffSize);\n    ZSTD_DCtx* dctx = ZSTD_createDCtx();\n    int testResult = 0;\n    U32 testNb=0;\n    size_t cSize;\n\n    /* Create compressible noise */\n    if (!CNBuffer || !compressedBuffer || !decodedBuffer) {\n        DISPLAY(\"Not enough memory, aborting\\n\");\n        testResult = 1;\n        goto _end;\n    }\n    RDG_genBuffer(CNBuffer, CNBuffSize, compressibility, 0., seed);\n\n    /* Basic tests */\n    DISPLAYLEVEL(3, \"test%3i : ZSTD_getErrorName : \", testNb++);\n    {   const char* errorString = ZSTD_getErrorName(0);\n        DISPLAYLEVEL(3, \"OK : %s \\n\", errorString);\n    }\n\n    DISPLAYLEVEL(3, \"test%3i : ZSTD_getErrorName with wrong value : \", testNb++);\n    {   const char* errorString = ZSTD_getErrorName(499);\n        DISPLAYLEVEL(3, \"OK : %s \\n\", errorString);\n    }\n\n    DISPLAYLEVEL(3, \"test%3i : min compression level : \", testNb++);\n    {   int const mcl = ZSTD_minCLevel();\n        DISPLAYLEVEL(3, \"%i (OK) \\n\", mcl);\n    }\n\n    DISPLAYLEVEL(3, \"test%3i : compress %u bytes : \", testNb++, (U32)CNBuffSize);\n    {   ZSTD_CCtx* const cctx = ZSTD_createCCtx();\n        if (cctx==NULL) goto _output_error;\n        CHECKPLUS(r, ZSTD_compressCCtx(cctx,\n                            compressedBuffer, compressedBufferSize,\n                            CNBuffer, CNBuffSize, 1),\n                  cSize=r );\n        DISPLAYLEVEL(3, \"OK (%u bytes : %.2f%%)\\n\", (U32)cSize, (double)cSize/CNBuffSize*100);\n\n        DISPLAYLEVEL(3, \"test%3i : size of cctx for level 1 : \", testNb++);\n        {   size_t const cctxSize = ZSTD_sizeof_CCtx(cctx);\n            DISPLAYLEVEL(3, \"%u bytes \\n\", (U32)cctxSize);\n        }\n        ZSTD_freeCCtx(cctx);\n    }\n\n\n    DISPLAYLEVEL(3, \"test%3i : ZSTD_getFrameContentSize test : \", testNb++);\n    {   unsigned long long const rSize = ZSTD_getFrameContentSize(compressedBuffer, cSize);\n        if (rSize != CNBuffSize) goto _output_error;\n    }\n    DISPLAYLEVEL(3, \"OK \\n\");\n\n    DISPLAYLEVEL(3, \"test%3i : ZSTD_findDecompressedSize test : \", testNb++);\n    {   unsigned long long const rSize = ZSTD_findDecompressedSize(compressedBuffer, cSize);\n        if (rSize != CNBuffSize) goto _output_error;\n    }\n    DISPLAYLEVEL(3, \"OK \\n\");\n\n    DISPLAYLEVEL(3, \"test%3i : decompress %u bytes : \", testNb++, (U32)CNBuffSize);\n    { size_t const r = ZSTD_decompress(decodedBuffer, CNBuffSize, compressedBuffer, cSize);\n      if (r != CNBuffSize) goto _output_error; }\n    DISPLAYLEVEL(3, \"OK \\n\");\n\n    DISPLAYLEVEL(3, \"test%3i : check decompressed result : \", testNb++);\n    {   size_t u;\n        for (u=0; u<CNBuffSize; u++) {\n            if (((BYTE*)decodedBuffer)[u] != ((BYTE*)CNBuffer)[u]) goto _output_error;;\n    }   }\n    DISPLAYLEVEL(3, \"OK \\n\");\n\n\n    DISPLAYLEVEL(3, \"test%3i : decompress with null dict : \", testNb++);\n    { size_t const r = ZSTD_decompress_usingDict(dctx, decodedBuffer, CNBuffSize, compressedBuffer, cSize, NULL, 0);\n      if (r != CNBuffSize) goto _output_error; }\n    DISPLAYLEVEL(3, \"OK \\n\");\n\n    DISPLAYLEVEL(3, \"test%3i : decompress with null DDict : \", testNb++);\n    { size_t const r = ZSTD_decompress_usingDDict(dctx, decodedBuffer, CNBuffSize, compressedBuffer, cSize, NULL);\n      if (r != CNBuffSize) goto _output_error; }\n    DISPLAYLEVEL(3, \"OK \\n\");\n\n    DISPLAYLEVEL(3, \"test%3i : decompress with 1 missing byte : \", testNb++);\n    { size_t const r = ZSTD_decompress(decodedBuffer, CNBuffSize, compressedBuffer, cSize-1);\n      if (!ZSTD_isError(r)) goto _output_error;\n      if (ZSTD_getErrorCode((size_t)r) != ZSTD_error_srcSize_wrong) goto _output_error; }\n    DISPLAYLEVEL(3, \"OK \\n\");\n\n    DISPLAYLEVEL(3, \"test%3i : decompress with 1 too much byte : \", testNb++);\n    { size_t const r = ZSTD_decompress(decodedBuffer, CNBuffSize, compressedBuffer, cSize+1);\n      if (!ZSTD_isError(r)) goto _output_error;\n      if (ZSTD_getErrorCode(r) != ZSTD_error_srcSize_wrong) goto _output_error; }\n    DISPLAYLEVEL(3, \"OK \\n\");\n\n    DISPLAYLEVEL(3, \"test%3i : decompress too large input : \", testNb++);\n    { size_t const r = ZSTD_decompress(decodedBuffer, CNBuffSize, compressedBuffer, compressedBufferSize);\n      if (!ZSTD_isError(r)) goto _output_error;\n      if (ZSTD_getErrorCode(r) != ZSTD_error_srcSize_wrong) goto _output_error; }\n    DISPLAYLEVEL(3, \"OK \\n\");\n\n    DISPLAYLEVEL(3, \"test%3d : check CCtx size after compressing empty input : \", testNb++);\n    {   ZSTD_CCtx* const cctx = ZSTD_createCCtx();\n        size_t const r = ZSTD_compressCCtx(cctx, compressedBuffer, compressedBufferSize, NULL, 0, 19);\n        if (ZSTD_isError(r)) goto _output_error;\n        if (ZSTD_sizeof_CCtx(cctx) > (1U << 20)) goto _output_error;\n        ZSTD_freeCCtx(cctx);\n        cSize = r;\n    }\n    DISPLAYLEVEL(3, \"OK \\n\");\n\n    DISPLAYLEVEL(3, \"test%3d : decompress empty frame into NULL : \", testNb++);\n    {   size_t const r = ZSTD_decompress(NULL, 0, compressedBuffer, cSize);\n        if (ZSTD_isError(r)) goto _output_error;\n        if (r != 0) goto _output_error;\n    }\n    {   ZSTD_CCtx* const cctx = ZSTD_createCCtx();\n        ZSTD_outBuffer output;\n        if (cctx==NULL) goto _output_error;\n        output.dst = compressedBuffer;\n        output.size = compressedBufferSize;\n        output.pos = 0;\n        CHECK_Z( ZSTD_initCStream(cctx, 1) );    /* content size unknown */\n        CHECK_Z( ZSTD_flushStream(cctx, &output) );   /* ensure no possibility to \"concatenate\" and determine the content size */\n        CHECK_Z( ZSTD_endStream(cctx, &output) );\n        ZSTD_freeCCtx(cctx);\n        /* single scan decompression */\n        {   size_t const r = ZSTD_decompress(NULL, 0, compressedBuffer, output.pos);\n            if (ZSTD_isError(r)) goto _output_error;\n            if (r != 0) goto _output_error;\n        }\n        /* streaming decompression */\n        {   ZSTD_DCtx* const dstream = ZSTD_createDStream();\n            ZSTD_inBuffer dinput;\n            ZSTD_outBuffer doutput;\n            size_t ipos;\n            if (dstream==NULL) goto _output_error;\n            dinput.src = compressedBuffer;\n            dinput.size = 0;\n            dinput.pos = 0;\n            doutput.dst = NULL;\n            doutput.size = 0;\n            doutput.pos = 0;\n            CHECK_Z ( ZSTD_initDStream(dstream) );\n            for (ipos=1; ipos<=output.pos; ipos++) {\n                dinput.size = ipos;\n                CHECK_Z ( ZSTD_decompressStream(dstream, &doutput, &dinput) );\n            }\n            if (doutput.pos != 0) goto _output_error;\n            ZSTD_freeDStream(dstream);\n        }\n    }\n    DISPLAYLEVEL(3, \"OK \\n\");\n\n    DISPLAYLEVEL(3, \"test%3d : re-use CCtx with expanding block size : \", testNb++);\n    {   ZSTD_CCtx* const cctx = ZSTD_createCCtx();\n        ZSTD_parameters const params = ZSTD_getParams(1, ZSTD_CONTENTSIZE_UNKNOWN, 0);\n        assert(params.fParams.contentSizeFlag == 1);  /* block size will be adapted if pledgedSrcSize is enabled */\n        CHECK_Z( ZSTD_compressBegin_advanced(cctx, NULL, 0, params, 1 /*pledgedSrcSize*/) );\n        CHECK_Z( ZSTD_compressEnd(cctx, compressedBuffer, compressedBufferSize, CNBuffer, 1) ); /* creates a block size of 1 */\n\n        CHECK_Z( ZSTD_compressBegin_advanced(cctx, NULL, 0, params, ZSTD_CONTENTSIZE_UNKNOWN) );  /* re-use same parameters */\n        {   size_t const inSize = 2* 128 KB;\n            size_t const outSize = ZSTD_compressBound(inSize);\n            CHECK_Z( ZSTD_compressEnd(cctx, compressedBuffer, outSize, CNBuffer, inSize) );\n            /* will fail if blockSize is not resized */\n        }\n        ZSTD_freeCCtx(cctx);\n    }\n    DISPLAYLEVEL(3, \"OK \\n\");\n\n    DISPLAYLEVEL(3, \"test%3d : re-using a CCtx should compress the same : \", testNb++);\n    {   int i;\n        for (i=0; i<20; i++)\n            ((char*)CNBuffer)[i] = (char)i;   /* ensure no match during initial section */\n        memcpy((char*)CNBuffer + 20, CNBuffer, 10);   /* create one match, starting from beginning of sample, which is the difficult case (see #1241) */\n        for (i=1; i<=19; i++) {\n            ZSTD_CCtx* const cctx = ZSTD_createCCtx();\n            size_t size1, size2;\n            DISPLAYLEVEL(5, \"l%i \", i);\n            size1 = ZSTD_compressCCtx(cctx, compressedBuffer, compressedBufferSize, CNBuffer, 30, i);\n            CHECK_Z(size1);\n            size2 = ZSTD_compressCCtx(cctx, compressedBuffer, compressedBufferSize, CNBuffer, 30, i);\n            CHECK_Z(size2);\n            CHECK_EQ(size1, size2);\n\n            ZSTD_freeCCtx(cctx);\n        }\n    }\n    DISPLAYLEVEL(3, \"OK \\n\");\n\n    DISPLAYLEVEL(3, \"test%3d : ZSTD_CCtx_getParameter() : \", testNb++);\n    {   ZSTD_CCtx* const cctx = ZSTD_createCCtx();\n        ZSTD_outBuffer out = {NULL, 0, 0};\n        ZSTD_inBuffer in = {NULL, 0, 0};\n        unsigned value;\n\n        CHECK_Z(ZSTD_CCtx_getParameter(cctx, ZSTD_p_compressionLevel, &value));\n        CHECK_EQ(value, 3);\n        CHECK_Z(ZSTD_CCtx_getParameter(cctx, ZSTD_p_hashLog, &value));\n        CHECK_EQ(value, 0);\n        CHECK_Z(ZSTD_CCtx_setParameter(cctx, ZSTD_p_hashLog, ZSTD_HASHLOG_MIN));\n        CHECK_Z(ZSTD_CCtx_getParameter(cctx, ZSTD_p_compressionLevel, &value));\n        CHECK_EQ(value, 3);\n        CHECK_Z(ZSTD_CCtx_getParameter(cctx, ZSTD_p_hashLog, &value));\n        CHECK_EQ(value, ZSTD_HASHLOG_MIN);\n        CHECK_Z(ZSTD_CCtx_setParameter(cctx, ZSTD_p_compressionLevel, 7));\n        CHECK_Z(ZSTD_CCtx_getParameter(cctx, ZSTD_p_compressionLevel, &value));\n        CHECK_EQ(value, 7);\n        CHECK_Z(ZSTD_CCtx_getParameter(cctx, ZSTD_p_hashLog, &value));\n        CHECK_EQ(value, ZSTD_HASHLOG_MIN);\n        /* Start a compression job */\n        ZSTD_compress_generic(cctx, &out, &in, ZSTD_e_continue);\n        CHECK_Z(ZSTD_CCtx_getParameter(cctx, ZSTD_p_compressionLevel, &value));\n        CHECK_EQ(value, 7);\n        CHECK_Z(ZSTD_CCtx_getParameter(cctx, ZSTD_p_hashLog, &value));\n        CHECK_EQ(value, ZSTD_HASHLOG_MIN);\n        /* Reset the CCtx */\n        ZSTD_CCtx_reset(cctx);\n        CHECK_Z(ZSTD_CCtx_getParameter(cctx, ZSTD_p_compressionLevel, &value));\n        CHECK_EQ(value, 7);\n        CHECK_Z(ZSTD_CCtx_getParameter(cctx, ZSTD_p_hashLog, &value));\n        CHECK_EQ(value, ZSTD_HASHLOG_MIN);\n        /* Reset the parameters */\n        ZSTD_CCtx_resetParameters(cctx);\n        CHECK_Z(ZSTD_CCtx_getParameter(cctx, ZSTD_p_compressionLevel, &value));\n        CHECK_EQ(value, 3);\n        CHECK_Z(ZSTD_CCtx_getParameter(cctx, ZSTD_p_hashLog, &value));\n        CHECK_EQ(value, 0);\n\n        ZSTD_freeCCtx(cctx);\n    }\n    DISPLAYLEVEL(3, \"OK \\n\");\n\n    /* this test is really too long, and should be made faster */\n    DISPLAYLEVEL(3, \"test%3d : overflow protection with large windowLog : \", testNb++);\n    {   ZSTD_CCtx* const cctx = ZSTD_createCCtx();\n        ZSTD_parameters params = ZSTD_getParams(-9, ZSTD_CONTENTSIZE_UNKNOWN, 0);\n        size_t const nbCompressions = ((1U << 31) / CNBuffSize) + 1;   /* ensure U32 overflow protection is triggered */\n        size_t cnb;\n        assert(cctx != NULL);\n        params.fParams.contentSizeFlag = 0;\n        params.cParams.windowLog = ZSTD_WINDOWLOG_MAX;\n        for (cnb = 0; cnb < nbCompressions; ++cnb) {\n            DISPLAYLEVEL(6, \"run %zu / %zu \\n\", cnb, nbCompressions);\n            CHECK_Z( ZSTD_compressBegin_advanced(cctx, NULL, 0, params, ZSTD_CONTENTSIZE_UNKNOWN) );  /* re-use same parameters */\n            CHECK_Z( ZSTD_compressEnd(cctx, compressedBuffer, compressedBufferSize, CNBuffer, CNBuffSize) );\n        }\n        ZSTD_freeCCtx(cctx);\n    }\n    DISPLAYLEVEL(3, \"OK \\n\");\n\n    DISPLAYLEVEL(3, \"test%3d : size down context : \", testNb++);\n    {   ZSTD_CCtx* const largeCCtx = ZSTD_createCCtx();\n        assert(largeCCtx != NULL);\n        CHECK_Z( ZSTD_compressBegin(largeCCtx, 19) );   /* streaming implies ZSTD_CONTENTSIZE_UNKNOWN, which maximizes memory usage */\n        CHECK_Z( ZSTD_compressEnd(largeCCtx, compressedBuffer, compressedBufferSize, CNBuffer, 1) );\n        {   size_t const largeCCtxSize = ZSTD_sizeof_CCtx(largeCCtx);   /* size of context must be measured after compression */\n            {   ZSTD_CCtx* const smallCCtx = ZSTD_createCCtx();\n                assert(smallCCtx != NULL);\n                CHECK_Z(ZSTD_compressCCtx(smallCCtx, compressedBuffer, compressedBufferSize, CNBuffer, 1, 1));\n                {   size_t const smallCCtxSize = ZSTD_sizeof_CCtx(smallCCtx);\n                    DISPLAYLEVEL(5, \"(large) %zuKB > 32*%zuKB (small) : \",\n                                largeCCtxSize>>10, smallCCtxSize>>10);\n                    assert(largeCCtxSize > 32* smallCCtxSize);  /* note : \"too large\" definition is handled within zstd_compress.c .\n                                                                 * make this test case extreme, so that it doesn't depend on a possibly fluctuating definition */\n                }\n                ZSTD_freeCCtx(smallCCtx);\n            }\n            {   U32 const maxNbAttempts = 1100;   /* nb of usages before triggering size down is handled within zstd_compress.c.\n                                                   * currently defined as 128x, but could be adjusted in the future.\n                                                   * make this test long enough so that it's not too much tied to the current definition within zstd_compress.c */\n                U32 u;\n                for (u=0; u<maxNbAttempts; u++) {\n                    CHECK_Z(ZSTD_compressCCtx(largeCCtx, compressedBuffer, compressedBufferSize, CNBuffer, 1, 1));\n                    if (ZSTD_sizeof_CCtx(largeCCtx) < largeCCtxSize) break;   /* sized down */\n                }\n                DISPLAYLEVEL(5, \"size down after %u attempts : \", u);\n                if (u==maxNbAttempts) goto _output_error;   /* no sizedown happened */\n            }\n        }\n        ZSTD_freeCCtx(largeCCtx);\n    }\n    DISPLAYLEVEL(3, \"OK \\n\");\n\n    /* Static CCtx tests */\n#define STATIC_CCTX_LEVEL 3\n    DISPLAYLEVEL(3, \"test%3i : create static CCtx for level %u :\", testNb++, STATIC_CCTX_LEVEL);\n    {   size_t const staticCCtxSize = ZSTD_estimateCStreamSize(STATIC_CCTX_LEVEL);\n        void* const staticCCtxBuffer = malloc(staticCCtxSize);\n        size_t const staticDCtxSize = ZSTD_estimateDCtxSize();\n        void* const staticDCtxBuffer = malloc(staticDCtxSize);\n        if (staticCCtxBuffer==NULL || staticDCtxBuffer==NULL) {\n            free(staticCCtxBuffer);\n            free(staticDCtxBuffer);\n            DISPLAY(\"Not enough memory, aborting\\n\");\n            testResult = 1;\n            goto _end;\n        }\n        {   ZSTD_CCtx* staticCCtx = ZSTD_initStaticCCtx(staticCCtxBuffer, staticCCtxSize);\n            ZSTD_DCtx* staticDCtx = ZSTD_initStaticDCtx(staticDCtxBuffer, staticDCtxSize);\n            if ((staticCCtx==NULL) || (staticDCtx==NULL)) goto _output_error;\n            DISPLAYLEVEL(3, \"OK \\n\");\n\n            DISPLAYLEVEL(3, \"test%3i : init CCtx for level %u : \", testNb++, STATIC_CCTX_LEVEL);\n            { size_t const r = ZSTD_compressBegin(staticCCtx, STATIC_CCTX_LEVEL);\n              if (ZSTD_isError(r)) goto _output_error; }\n            DISPLAYLEVEL(3, \"OK \\n\");\n\n            DISPLAYLEVEL(3, \"test%3i : simple compression test with static CCtx : \", testNb++);\n            CHECKPLUS(r, ZSTD_compressCCtx(staticCCtx,\n                            compressedBuffer, compressedBufferSize,\n                            CNBuffer, CNBuffSize, STATIC_CCTX_LEVEL),\n                      cSize=r );\n            DISPLAYLEVEL(3, \"OK (%u bytes : %.2f%%)\\n\",\n                            (U32)cSize, (double)cSize/CNBuffSize*100);\n\n            DISPLAYLEVEL(3, \"test%3i : simple decompression test with static DCtx : \", testNb++);\n            { size_t const r = ZSTD_decompressDCtx(staticDCtx,\n                                                decodedBuffer, CNBuffSize,\n                                                compressedBuffer, cSize);\n              if (r != CNBuffSize) goto _output_error; }\n            DISPLAYLEVEL(3, \"OK \\n\");\n\n            DISPLAYLEVEL(3, \"test%3i : check decompressed result : \", testNb++);\n            {   size_t u;\n                for (u=0; u<CNBuffSize; u++) {\n                    if (((BYTE*)decodedBuffer)[u] != ((BYTE*)CNBuffer)[u])\n                        goto _output_error;;\n            }   }\n            DISPLAYLEVEL(3, \"OK \\n\");\n\n            DISPLAYLEVEL(3, \"test%3i : init CCtx for too large level (must fail) : \", testNb++);\n            { size_t const r = ZSTD_compressBegin(staticCCtx, ZSTD_maxCLevel());\n              if (!ZSTD_isError(r)) goto _output_error; }\n            DISPLAYLEVEL(3, \"OK \\n\");\n\n            DISPLAYLEVEL(3, \"test%3i : init CCtx for small level %u (should work again) : \", testNb++, 1);\n            { size_t const r = ZSTD_compressBegin(staticCCtx, 1);\n              if (ZSTD_isError(r)) goto _output_error; }\n            DISPLAYLEVEL(3, \"OK \\n\");\n\n            DISPLAYLEVEL(3, \"test%3i : init CStream for small level %u : \", testNb++, 1);\n            { size_t const r = ZSTD_initCStream(staticCCtx, 1);\n              if (ZSTD_isError(r)) goto _output_error; }\n            DISPLAYLEVEL(3, \"OK \\n\");\n\n            DISPLAYLEVEL(3, \"test%3i : init CStream with dictionary (should fail) : \", testNb++);\n            { size_t const r = ZSTD_initCStream_usingDict(staticCCtx, CNBuffer, 64 KB, 1);\n              if (!ZSTD_isError(r)) goto _output_error; }\n            DISPLAYLEVEL(3, \"OK \\n\");\n\n            DISPLAYLEVEL(3, \"test%3i : init DStream (should fail) : \", testNb++);\n            { size_t const r = ZSTD_initDStream(staticDCtx);\n              if (ZSTD_isError(r)) goto _output_error; }\n            {   ZSTD_outBuffer output = { decodedBuffer, CNBuffSize, 0 };\n                ZSTD_inBuffer input = { compressedBuffer, ZSTD_FRAMEHEADERSIZE_MAX+1, 0 };\n                size_t const r = ZSTD_decompressStream(staticDCtx, &output, &input);\n                if (!ZSTD_isError(r)) goto _output_error;\n            }\n            DISPLAYLEVEL(3, \"OK \\n\");\n        }\n        free(staticCCtxBuffer);\n        free(staticDCtxBuffer);\n    }\n\n\n    /* ZSTDMT simple MT compression test */\n    DISPLAYLEVEL(3, \"test%3i : create ZSTDMT CCtx : \", testNb++);\n    {   ZSTDMT_CCtx* mtctx = ZSTDMT_createCCtx(2);\n        if (mtctx==NULL) {\n            DISPLAY(\"mtctx : mot enough memory, aborting \\n\");\n            testResult = 1;\n            goto _end;\n        }\n        DISPLAYLEVEL(3, \"OK \\n\");\n\n        DISPLAYLEVEL(3, \"test%3i : compress %u bytes with 2 threads : \", testNb++, (U32)CNBuffSize);\n        CHECKPLUS(r, ZSTDMT_compressCCtx(mtctx,\n                                compressedBuffer, compressedBufferSize,\n                                CNBuffer, CNBuffSize,\n                                1),\n                  cSize=r );\n        DISPLAYLEVEL(3, \"OK (%u bytes : %.2f%%)\\n\", (U32)cSize, (double)cSize/CNBuffSize*100);\n\n        DISPLAYLEVEL(3, \"test%3i : decompressed size test : \", testNb++);\n        {   unsigned long long const rSize = ZSTD_getFrameContentSize(compressedBuffer, cSize);\n            if (rSize != CNBuffSize)  {\n                DISPLAY(\"ZSTD_getFrameContentSize incorrect : %u != %u \\n\", (U32)rSize, (U32)CNBuffSize);\n                goto _output_error;\n        }   }\n        DISPLAYLEVEL(3, \"OK \\n\");\n\n        DISPLAYLEVEL(3, \"test%3i : decompress %u bytes : \", testNb++, (U32)CNBuffSize);\n        { size_t const r = ZSTD_decompress(decodedBuffer, CNBuffSize, compressedBuffer, cSize);\n          if (r != CNBuffSize) goto _output_error; }\n        DISPLAYLEVEL(3, \"OK \\n\");\n\n        DISPLAYLEVEL(3, \"test%3i : check decompressed result : \", testNb++);\n        {   size_t u;\n            for (u=0; u<CNBuffSize; u++) {\n                if (((BYTE*)decodedBuffer)[u] != ((BYTE*)CNBuffer)[u]) goto _output_error;;\n        }   }\n        DISPLAYLEVEL(3, \"OK \\n\");\n\n        DISPLAYLEVEL(3, \"test%3i : compress -T2 with checksum : \", testNb++);\n        {   ZSTD_parameters params = ZSTD_getParams(1, CNBuffSize, 0);\n            params.fParams.checksumFlag = 1;\n            params.fParams.contentSizeFlag = 1;\n            CHECKPLUS(r, ZSTDMT_compress_advanced(mtctx,\n                                    compressedBuffer, compressedBufferSize,\n                                    CNBuffer, CNBuffSize,\n                                    NULL, params, 3 /*overlapRLog*/),\n                      cSize=r );\n        }\n        DISPLAYLEVEL(3, \"OK (%u bytes : %.2f%%)\\n\", (U32)cSize, (double)cSize/CNBuffSize*100);\n\n        DISPLAYLEVEL(3, \"test%3i : decompress %u bytes : \", testNb++, (U32)CNBuffSize);\n        { size_t const r = ZSTD_decompress(decodedBuffer, CNBuffSize, compressedBuffer, cSize);\n          if (r != CNBuffSize) goto _output_error; }\n        DISPLAYLEVEL(3, \"OK \\n\");\n\n        ZSTDMT_freeCCtx(mtctx);\n    }\n\n\n    /* Simple API multiframe test */\n    DISPLAYLEVEL(3, \"test%3i : compress multiple frames : \", testNb++);\n    {   size_t off = 0;\n        int i;\n        int const segs = 4;\n        /* only use the first half so we don't push against size limit of compressedBuffer */\n        size_t const segSize = (CNBuffSize / 2) / segs;\n        for (i = 0; i < segs; i++) {\n            CHECK_V(r, ZSTD_compress(\n                            (BYTE *)compressedBuffer + off, CNBuffSize - off,\n                            (BYTE *)CNBuffer + segSize * i,\n                            segSize, 5));\n            off += r;\n            if (i == segs/2) {\n                /* insert skippable frame */\n                const U32 skipLen = 129 KB;\n                MEM_writeLE32((BYTE*)compressedBuffer + off, ZSTD_MAGIC_SKIPPABLE_START);\n                MEM_writeLE32((BYTE*)compressedBuffer + off + 4, skipLen);\n                off += skipLen + ZSTD_skippableHeaderSize;\n            }\n        }\n        cSize = off;\n    }\n    DISPLAYLEVEL(3, \"OK \\n\");\n\n    DISPLAYLEVEL(3, \"test%3i : get decompressed size of multiple frames : \", testNb++);\n    {   unsigned long long const r = ZSTD_findDecompressedSize(compressedBuffer, cSize);\n        if (r != CNBuffSize / 2) goto _output_error; }\n    DISPLAYLEVEL(3, \"OK \\n\");\n\n    DISPLAYLEVEL(3, \"test%3i : decompress multiple frames : \", testNb++);\n    {   CHECK_V(r, ZSTD_decompress(decodedBuffer, CNBuffSize, compressedBuffer, cSize));\n        if (r != CNBuffSize / 2) goto _output_error; }\n    DISPLAYLEVEL(3, \"OK \\n\");\n\n    DISPLAYLEVEL(3, \"test%3i : check decompressed result : \", testNb++);\n    if (memcmp(decodedBuffer, CNBuffer, CNBuffSize / 2) != 0) goto _output_error;\n    DISPLAYLEVEL(3, \"OK \\n\");\n\n    /* Dictionary and CCtx Duplication tests */\n    {   ZSTD_CCtx* const ctxOrig = ZSTD_createCCtx();\n        ZSTD_CCtx* const ctxDuplicated = ZSTD_createCCtx();\n        static const size_t dictSize = 551;\n\n        DISPLAYLEVEL(3, \"test%3i : copy context too soon : \", testNb++);\n        { size_t const copyResult = ZSTD_copyCCtx(ctxDuplicated, ctxOrig, 0);\n          if (!ZSTD_isError(copyResult)) goto _output_error; }   /* error must be detected */\n        DISPLAYLEVEL(3, \"OK \\n\");\n\n        DISPLAYLEVEL(3, \"test%3i : load dictionary into context : \", testNb++);\n        CHECK( ZSTD_compressBegin_usingDict(ctxOrig, CNBuffer, dictSize, 2) );\n        CHECK( ZSTD_copyCCtx(ctxDuplicated, ctxOrig, 0) ); /* Begin_usingDict implies unknown srcSize, so match that */\n        DISPLAYLEVEL(3, \"OK \\n\");\n\n        DISPLAYLEVEL(3, \"test%3i : compress with flat dictionary : \", testNb++);\n        cSize = 0;\n        CHECKPLUS(r, ZSTD_compressEnd(ctxOrig, compressedBuffer, compressedBufferSize,\n                                           (const char*)CNBuffer + dictSize, CNBuffSize - dictSize),\n                  cSize += r);\n        DISPLAYLEVEL(3, \"OK (%u bytes : %.2f%%)\\n\", (U32)cSize, (double)cSize/CNBuffSize*100);\n\n        DISPLAYLEVEL(3, \"test%3i : frame built with flat dictionary should be decompressible : \", testNb++);\n        CHECKPLUS(r, ZSTD_decompress_usingDict(dctx,\n                                       decodedBuffer, CNBuffSize,\n                                       compressedBuffer, cSize,\n                                       CNBuffer, dictSize),\n                  if (r != CNBuffSize - dictSize) goto _output_error);\n        DISPLAYLEVEL(3, \"OK \\n\");\n\n        DISPLAYLEVEL(3, \"test%3i : compress with duplicated context : \", testNb++);\n        {   size_t const cSizeOrig = cSize;\n            cSize = 0;\n            CHECKPLUS(r, ZSTD_compressEnd(ctxDuplicated, compressedBuffer, compressedBufferSize,\n                                               (const char*)CNBuffer + dictSize, CNBuffSize - dictSize),\n                      cSize += r);\n            if (cSize != cSizeOrig) goto _output_error;   /* should be identical ==> same size */\n        }\n        DISPLAYLEVEL(3, \"OK (%u bytes : %.2f%%)\\n\", (U32)cSize, (double)cSize/CNBuffSize*100);\n\n        DISPLAYLEVEL(3, \"test%3i : frame built with duplicated context should be decompressible : \", testNb++);\n        CHECKPLUS(r, ZSTD_decompress_usingDict(dctx,\n                                           decodedBuffer, CNBuffSize,\n                                           compressedBuffer, cSize,\n                                           CNBuffer, dictSize),\n                  if (r != CNBuffSize - dictSize) goto _output_error);\n        DISPLAYLEVEL(3, \"OK \\n\");\n\n        DISPLAYLEVEL(3, \"test%3i : decompress with DDict : \", testNb++);\n        {   ZSTD_DDict* const ddict = ZSTD_createDDict(CNBuffer, dictSize);\n            size_t const r = ZSTD_decompress_usingDDict(dctx, decodedBuffer, CNBuffSize, compressedBuffer, cSize, ddict);\n            if (r != CNBuffSize - dictSize) goto _output_error;\n            DISPLAYLEVEL(3, \"OK (size of DDict : %u) \\n\", (U32)ZSTD_sizeof_DDict(ddict));\n            ZSTD_freeDDict(ddict);\n        }\n\n        DISPLAYLEVEL(3, \"test%3i : decompress with static DDict : \", testNb++);\n        {   size_t const ddictBufferSize = ZSTD_estimateDDictSize(dictSize, ZSTD_dlm_byCopy);\n            void* ddictBuffer = malloc(ddictBufferSize);\n            if (ddictBuffer == NULL) goto _output_error;\n            {   const ZSTD_DDict* const ddict = ZSTD_initStaticDDict(ddictBuffer, ddictBufferSize, CNBuffer, dictSize, ZSTD_dlm_byCopy, ZSTD_dct_auto);\n                size_t const r = ZSTD_decompress_usingDDict(dctx, decodedBuffer, CNBuffSize, compressedBuffer, cSize, ddict);\n                if (r != CNBuffSize - dictSize) goto _output_error;\n            }\n            free(ddictBuffer);\n            DISPLAYLEVEL(3, \"OK (size of static DDict : %u) \\n\", (U32)ddictBufferSize);\n        }\n\n        DISPLAYLEVEL(3, \"test%3i : check content size on duplicated context : \", testNb++);\n        {   size_t const testSize = CNBuffSize / 3;\n            {   ZSTD_parameters p = ZSTD_getParams(2, testSize, dictSize);\n                p.fParams.contentSizeFlag = 1;\n                CHECK( ZSTD_compressBegin_advanced(ctxOrig, CNBuffer, dictSize, p, testSize-1) );\n            }\n            CHECK( ZSTD_copyCCtx(ctxDuplicated, ctxOrig, testSize) );\n\n            CHECKPLUS(r, ZSTD_compressEnd(ctxDuplicated, compressedBuffer, ZSTD_compressBound(testSize),\n                                          (const char*)CNBuffer + dictSize, testSize),\n                      cSize = r);\n            {   ZSTD_frameHeader zfh;\n                if (ZSTD_getFrameHeader(&zfh, compressedBuffer, cSize)) goto _output_error;\n                if ((zfh.frameContentSize != testSize) && (zfh.frameContentSize != 0)) goto _output_error;\n        }   }\n        DISPLAYLEVEL(3, \"OK \\n\");\n\n        ZSTD_freeCCtx(ctxOrig);\n        ZSTD_freeCCtx(ctxDuplicated);\n    }\n\n    /* Dictionary and dictBuilder tests */\n    {   ZSTD_CCtx* const cctx = ZSTD_createCCtx();\n        size_t const dictBufferCapacity = 16 KB;\n        void* dictBuffer = malloc(dictBufferCapacity);\n        size_t const totalSampleSize = 1 MB;\n        size_t const sampleUnitSize = 8 KB;\n        U32 const nbSamples = (U32)(totalSampleSize / sampleUnitSize);\n        size_t* const samplesSizes = (size_t*) malloc(nbSamples * sizeof(size_t));\n        size_t dictSize;\n        U32 dictID;\n\n        if (dictBuffer==NULL || samplesSizes==NULL) {\n            free(dictBuffer);\n            free(samplesSizes);\n            goto _output_error;\n        }\n\n        DISPLAYLEVEL(3, \"test%3i : dictBuilder on cyclic data : \", testNb++);\n        assert(compressedBufferSize >= totalSampleSize);\n        { U32 u; for (u=0; u<totalSampleSize; u++) ((BYTE*)decodedBuffer)[u] = (BYTE)u; }\n        { U32 u; for (u=0; u<nbSamples; u++) samplesSizes[u] = sampleUnitSize; }\n        {   size_t const sDictSize = ZDICT_trainFromBuffer(dictBuffer, dictBufferCapacity,\n                                         decodedBuffer, samplesSizes, nbSamples);\n            if (ZDICT_isError(sDictSize)) goto _output_error;\n            DISPLAYLEVEL(3, \"OK, created dictionary of size %u \\n\", (U32)sDictSize);\n        }\n\n        DISPLAYLEVEL(3, \"test%3i : dictBuilder : \", testNb++);\n        { U32 u; for (u=0; u<nbSamples; u++) samplesSizes[u] = sampleUnitSize; }\n        dictSize = ZDICT_trainFromBuffer(dictBuffer, dictBufferCapacity,\n                                         CNBuffer, samplesSizes, nbSamples);\n        if (ZDICT_isError(dictSize)) goto _output_error;\n        DISPLAYLEVEL(3, \"OK, created dictionary of size %u \\n\", (U32)dictSize);\n\n        DISPLAYLEVEL(3, \"test%3i : Multithreaded COVER dictBuilder : \", testNb++);\n        { U32 u; for (u=0; u<nbSamples; u++) samplesSizes[u] = sampleUnitSize; }\n        {   ZDICT_cover_params_t coverParams;\n            memset(&coverParams, 0, sizeof(coverParams));\n            coverParams.steps = 8;\n            coverParams.nbThreads = 4;\n            dictSize = ZDICT_optimizeTrainFromBuffer_cover(\n                dictBuffer, dictBufferCapacity,\n                CNBuffer, samplesSizes, nbSamples,\n                &coverParams);\n            if (ZDICT_isError(dictSize)) goto _output_error;\n        }\n        DISPLAYLEVEL(3, \"OK, created dictionary of size %u \\n\", (U32)dictSize);\n\n        DISPLAYLEVEL(3, \"test%3i : Multithreaded FASTCOVER dictBuilder : \", testNb++);\n        { U32 u; for (u=0; u<nbSamples; u++) samplesSizes[u] = sampleUnitSize; }\n        {   ZDICT_fastCover_params_t fastCoverParams;\n            memset(&fastCoverParams, 0, sizeof(fastCoverParams));\n            fastCoverParams.steps = 8;\n            fastCoverParams.nbThreads = 4;\n            dictSize = ZDICT_optimizeTrainFromBuffer_fastCover(\n                dictBuffer, dictBufferCapacity,\n                CNBuffer, samplesSizes, nbSamples,\n                &fastCoverParams);\n            if (ZDICT_isError(dictSize)) goto _output_error;\n        }\n        DISPLAYLEVEL(3, \"OK, created dictionary of size %u \\n\", (U32)dictSize);\n\n        DISPLAYLEVEL(3, \"test%3i : check dictID : \", testNb++);\n        dictID = ZDICT_getDictID(dictBuffer, dictSize);\n        if (dictID==0) goto _output_error;\n        DISPLAYLEVEL(3, \"OK : %u \\n\", dictID);\n\n        DISPLAYLEVEL(3, \"test%3i : compress with dictionary : \", testNb++);\n        cSize = ZSTD_compress_usingDict(cctx, compressedBuffer, compressedBufferSize,\n                                        CNBuffer, CNBuffSize,\n                                        dictBuffer, dictSize, 4);\n        if (ZSTD_isError(cSize)) goto _output_error;\n        DISPLAYLEVEL(3, \"OK (%u bytes : %.2f%%)\\n\", (U32)cSize, (double)cSize/CNBuffSize*100);\n\n        DISPLAYLEVEL(3, \"test%3i : retrieve dictID from dictionary : \", testNb++);\n        {   U32 const did = ZSTD_getDictID_fromDict(dictBuffer, dictSize);\n            if (did != dictID) goto _output_error;   /* non-conformant (content-only) dictionary */\n        }\n        DISPLAYLEVEL(3, \"OK \\n\");\n\n        DISPLAYLEVEL(3, \"test%3i : retrieve dictID from frame : \", testNb++);\n        {   U32 const did = ZSTD_getDictID_fromFrame(compressedBuffer, cSize);\n            if (did != dictID) goto _output_error;   /* non-conformant (content-only) dictionary */\n        }\n        DISPLAYLEVEL(3, \"OK \\n\");\n\n        DISPLAYLEVEL(3, \"test%3i : frame built with dictionary should be decompressible : \", testNb++);\n        CHECKPLUS(r, ZSTD_decompress_usingDict(dctx,\n                                       decodedBuffer, CNBuffSize,\n                                       compressedBuffer, cSize,\n                                       dictBuffer, dictSize),\n                  if (r != CNBuffSize) goto _output_error);\n        DISPLAYLEVEL(3, \"OK \\n\");\n\n        DISPLAYLEVEL(3, \"test%3i : estimate CDict size : \", testNb++);\n        {   ZSTD_compressionParameters const cParams = ZSTD_getCParams(1, CNBuffSize, dictSize);\n            size_t const estimatedSize = ZSTD_estimateCDictSize_advanced(dictSize, cParams, ZSTD_dlm_byRef);\n            DISPLAYLEVEL(3, \"OK : %u \\n\", (U32)estimatedSize);\n        }\n\n        DISPLAYLEVEL(3, \"test%3i : compress with CDict \", testNb++);\n        {   ZSTD_compressionParameters const cParams = ZSTD_getCParams(1, CNBuffSize, dictSize);\n            ZSTD_CDict* const cdict = ZSTD_createCDict_advanced(dictBuffer, dictSize,\n                                            ZSTD_dlm_byRef, ZSTD_dct_auto,\n                                            cParams, ZSTD_defaultCMem);\n            DISPLAYLEVEL(3, \"(size : %u) : \", (U32)ZSTD_sizeof_CDict(cdict));\n            cSize = ZSTD_compress_usingCDict(cctx, compressedBuffer, compressedBufferSize,\n                                                 CNBuffer, CNBuffSize, cdict);\n            ZSTD_freeCDict(cdict);\n            if (ZSTD_isError(cSize)) goto _output_error;\n        }\n        DISPLAYLEVEL(3, \"OK (%u bytes : %.2f%%)\\n\", (U32)cSize, (double)cSize/CNBuffSize*100);\n\n        DISPLAYLEVEL(3, \"test%3i : retrieve dictID from frame : \", testNb++);\n        {   U32 const did = ZSTD_getDictID_fromFrame(compressedBuffer, cSize);\n            if (did != dictID) goto _output_error;   /* non-conformant (content-only) dictionary */\n        }\n        DISPLAYLEVEL(3, \"OK \\n\");\n\n        DISPLAYLEVEL(3, \"test%3i : frame built with dictionary should be decompressible : \", testNb++);\n        CHECKPLUS(r, ZSTD_decompress_usingDict(dctx,\n                                       decodedBuffer, CNBuffSize,\n                                       compressedBuffer, cSize,\n                                       dictBuffer, dictSize),\n                  if (r != CNBuffSize) goto _output_error);\n        DISPLAYLEVEL(3, \"OK \\n\");\n\n        DISPLAYLEVEL(3, \"test%3i : compress with static CDict : \", testNb++);\n        {   int const maxLevel = ZSTD_maxCLevel();\n            int level;\n            for (level = 1; level <= maxLevel; ++level) {\n                ZSTD_compressionParameters const cParams = ZSTD_getCParams(level, CNBuffSize, dictSize);\n                size_t const cdictSize = ZSTD_estimateCDictSize_advanced(dictSize, cParams, ZSTD_dlm_byCopy);\n                void* const cdictBuffer = malloc(cdictSize);\n                if (cdictBuffer==NULL) goto _output_error;\n                {   const ZSTD_CDict* const cdict = ZSTD_initStaticCDict(\n                                                cdictBuffer, cdictSize,\n                                                dictBuffer, dictSize,\n                                                ZSTD_dlm_byCopy, ZSTD_dct_auto,\n                                                cParams);\n                    if (cdict == NULL) {\n                        DISPLAY(\"ZSTD_initStaticCDict failed \");\n                        goto _output_error;\n                    }\n                    cSize = ZSTD_compress_usingCDict(cctx,\n                                    compressedBuffer, compressedBufferSize,\n                                    CNBuffer, MIN(10 KB, CNBuffSize), cdict);\n                    if (ZSTD_isError(cSize)) {\n                        DISPLAY(\"ZSTD_compress_usingCDict failed \");\n                        goto _output_error;\n                }   }\n                free(cdictBuffer);\n        }   }\n        DISPLAYLEVEL(3, \"OK (%u bytes : %.2f%%)\\n\", (U32)cSize, (double)cSize/CNBuffSize*100);\n\n        DISPLAYLEVEL(3, \"test%3i : ZSTD_compress_usingCDict_advanced, no contentSize, no dictID : \", testNb++);\n        {   ZSTD_frameParameters const fParams = { 0 /* frameSize */, 1 /* checksum */, 1 /* noDictID*/ };\n            ZSTD_compressionParameters const cParams = ZSTD_getCParams(1, CNBuffSize, dictSize);\n            ZSTD_CDict* const cdict = ZSTD_createCDict_advanced(dictBuffer, dictSize, ZSTD_dlm_byRef, ZSTD_dct_auto, cParams, ZSTD_defaultCMem);\n            cSize = ZSTD_compress_usingCDict_advanced(cctx, compressedBuffer, compressedBufferSize,\n                                                 CNBuffer, CNBuffSize, cdict, fParams);\n            ZSTD_freeCDict(cdict);\n            if (ZSTD_isError(cSize)) goto _output_error;\n        }\n        DISPLAYLEVEL(3, \"OK (%u bytes : %.2f%%)\\n\", (U32)cSize, (double)cSize/CNBuffSize*100);\n\n        DISPLAYLEVEL(3, \"test%3i : try retrieving contentSize from frame : \", testNb++);\n        {   U64 const contentSize = ZSTD_getFrameContentSize(compressedBuffer, cSize);\n            if (contentSize != ZSTD_CONTENTSIZE_UNKNOWN) goto _output_error;\n        }\n        DISPLAYLEVEL(3, \"OK (unknown)\\n\");\n\n        DISPLAYLEVEL(3, \"test%3i : frame built without dictID should be decompressible : \", testNb++);\n        CHECKPLUS(r, ZSTD_decompress_usingDict(dctx,\n                                       decodedBuffer, CNBuffSize,\n                                       compressedBuffer, cSize,\n                                       dictBuffer, dictSize),\n                  if (r != CNBuffSize) goto _output_error);\n        DISPLAYLEVEL(3, \"OK \\n\");\n\n        DISPLAYLEVEL(3, \"test%3i : ZSTD_compress_advanced, no dictID : \", testNb++);\n        {   ZSTD_parameters p = ZSTD_getParams(3, CNBuffSize, dictSize);\n            p.fParams.noDictIDFlag = 1;\n            cSize = ZSTD_compress_advanced(cctx, compressedBuffer, compressedBufferSize,\n                                           CNBuffer, CNBuffSize,\n                                           dictBuffer, dictSize, p);\n            if (ZSTD_isError(cSize)) goto _output_error;\n        }\n        DISPLAYLEVEL(3, \"OK (%u bytes : %.2f%%)\\n\", (U32)cSize, (double)cSize/CNBuffSize*100);\n\n        DISPLAYLEVEL(3, \"test%3i : frame built without dictID should be decompressible : \", testNb++);\n        CHECKPLUS(r, ZSTD_decompress_usingDict(dctx,\n                                       decodedBuffer, CNBuffSize,\n                                       compressedBuffer, cSize,\n                                       dictBuffer, dictSize),\n                  if (r != CNBuffSize) goto _output_error);\n        DISPLAYLEVEL(3, \"OK \\n\");\n\n        DISPLAYLEVEL(3, \"test%3i : dictionary containing only header should return error : \", testNb++);\n        {\n          const size_t ret = ZSTD_decompress_usingDict(\n              dctx, decodedBuffer, CNBuffSize, compressedBuffer, cSize,\n              \"\\x37\\xa4\\x30\\xec\\x11\\x22\\x33\\x44\", 8);\n          if (ZSTD_getErrorCode(ret) != ZSTD_error_dictionary_corrupted) goto _output_error;\n        }\n        DISPLAYLEVEL(3, \"OK \\n\");\n\n        DISPLAYLEVEL(3, \"test%3i : Building cdict w/ ZSTD_dm_fullDict on a good dictionary : \", testNb++);\n        {   ZSTD_compressionParameters const cParams = ZSTD_getCParams(1, CNBuffSize, dictSize);\n            ZSTD_CDict* const cdict = ZSTD_createCDict_advanced(dictBuffer, dictSize, ZSTD_dlm_byRef, ZSTD_dct_fullDict, cParams, ZSTD_defaultCMem);\n            if (cdict==NULL) goto _output_error;\n            ZSTD_freeCDict(cdict);\n        }\n        DISPLAYLEVEL(3, \"OK \\n\");\n\n        DISPLAYLEVEL(3, \"test%3i : Building cdict w/ ZSTD_dm_fullDict on a rawContent (must fail) : \", testNb++);\n        {   ZSTD_compressionParameters const cParams = ZSTD_getCParams(1, CNBuffSize, dictSize);\n            ZSTD_CDict* const cdict = ZSTD_createCDict_advanced((const char*)dictBuffer+1, dictSize-1, ZSTD_dlm_byRef, ZSTD_dct_fullDict, cParams, ZSTD_defaultCMem);\n            if (cdict!=NULL) goto _output_error;\n            ZSTD_freeCDict(cdict);\n        }\n        DISPLAYLEVEL(3, \"OK \\n\");\n\n        DISPLAYLEVEL(3, \"test%3i : Loading rawContent starting with dict header w/ ZSTD_dm_auto should fail : \", testNb++);\n        {\n            size_t ret;\n            MEM_writeLE32((char*)dictBuffer+2, ZSTD_MAGIC_DICTIONARY);\n            ret = ZSTD_CCtx_loadDictionary_advanced(\n                    cctx, (const char*)dictBuffer+2, dictSize-2, ZSTD_dlm_byRef, ZSTD_dct_auto);\n            if (!ZSTD_isError(ret)) goto _output_error;\n        }\n        DISPLAYLEVEL(3, \"OK \\n\");\n\n        DISPLAYLEVEL(3, \"test%3i : Loading rawContent starting with dict header w/ ZSTD_dm_rawContent should pass : \", testNb++);\n        {\n            size_t ret;\n            MEM_writeLE32((char*)dictBuffer+2, ZSTD_MAGIC_DICTIONARY);\n            ret = ZSTD_CCtx_loadDictionary_advanced(\n                    cctx, (const char*)dictBuffer+2, dictSize-2, ZSTD_dlm_byRef, ZSTD_dct_rawContent);\n            if (ZSTD_isError(ret)) goto _output_error;\n        }\n        DISPLAYLEVEL(3, \"OK \\n\");\n\n        DISPLAYLEVEL(3, \"test%3i : Dictionary with non-default repcodes : \", testNb++);\n        { U32 u; for (u=0; u<nbSamples; u++) samplesSizes[u] = sampleUnitSize; }\n        dictSize = ZDICT_trainFromBuffer(dictBuffer, dictSize,\n                                         CNBuffer, samplesSizes, nbSamples);\n        if (ZDICT_isError(dictSize)) goto _output_error;\n        /* Set all the repcodes to non-default */\n        {\n            BYTE* dictPtr = (BYTE*)dictBuffer;\n            BYTE* dictLimit = dictPtr + dictSize - 12;\n            /* Find the repcodes */\n            while (dictPtr < dictLimit &&\n                   (MEM_readLE32(dictPtr) != 1 || MEM_readLE32(dictPtr + 4) != 4 ||\n                    MEM_readLE32(dictPtr + 8) != 8)) {\n                ++dictPtr;\n            }\n            if (dictPtr >= dictLimit) goto _output_error;\n            MEM_writeLE32(dictPtr + 0, 10);\n            MEM_writeLE32(dictPtr + 4, 10);\n            MEM_writeLE32(dictPtr + 8, 10);\n            /* Set the last 8 bytes to 'x' */\n            memset((BYTE*)dictBuffer + dictSize - 8, 'x', 8);\n        }\n        /* The optimal parser checks all the repcodes.\n         * Make sure at least one is a match >= targetLength so that it is\n         * immediately chosen. This will make sure that the compressor and\n         * decompressor agree on at least one of the repcodes.\n         */\n        {   size_t dSize;\n            BYTE data[1024];\n            ZSTD_compressionParameters const cParams = ZSTD_getCParams(19, CNBuffSize, dictSize);\n            ZSTD_CDict* const cdict = ZSTD_createCDict_advanced(dictBuffer, dictSize,\n                                            ZSTD_dlm_byRef, ZSTD_dct_auto,\n                                            cParams, ZSTD_defaultCMem);\n            memset(data, 'x', sizeof(data));\n            cSize = ZSTD_compress_usingCDict(cctx, compressedBuffer, compressedBufferSize,\n                                             data, sizeof(data), cdict);\n            ZSTD_freeCDict(cdict);\n            if (ZSTD_isError(cSize)) { DISPLAYLEVEL(5, \"Compression error %s : \", ZSTD_getErrorName(cSize)); goto _output_error; }\n            dSize = ZSTD_decompress_usingDict(dctx, decodedBuffer, sizeof(data), compressedBuffer, cSize, dictBuffer, dictSize);\n            if (ZSTD_isError(dSize)) { DISPLAYLEVEL(5, \"Decompression error %s : \", ZSTD_getErrorName(dSize)); goto _output_error; }\n            if (memcmp(data, decodedBuffer, sizeof(data))) { DISPLAYLEVEL(5, \"Data corruption : \"); goto _output_error; }\n        }\n        DISPLAYLEVEL(3, \"OK \\n\");\n\n        ZSTD_freeCCtx(cctx);\n        free(dictBuffer);\n        free(samplesSizes);\n    }\n\n    /* COVER dictionary builder tests */\n    {   ZSTD_CCtx* const cctx = ZSTD_createCCtx();\n        size_t dictSize = 16 KB;\n        size_t optDictSize = dictSize;\n        void* dictBuffer = malloc(dictSize);\n        size_t const totalSampleSize = 1 MB;\n        size_t const sampleUnitSize = 8 KB;\n        U32 const nbSamples = (U32)(totalSampleSize / sampleUnitSize);\n        size_t* const samplesSizes = (size_t*) malloc(nbSamples * sizeof(size_t));\n        ZDICT_cover_params_t params;\n        U32 dictID;\n\n        if (dictBuffer==NULL || samplesSizes==NULL) {\n            free(dictBuffer);\n            free(samplesSizes);\n            goto _output_error;\n        }\n\n        DISPLAYLEVEL(3, \"test%3i : ZDICT_trainFromBuffer_cover : \", testNb++);\n        { U32 u; for (u=0; u<nbSamples; u++) samplesSizes[u] = sampleUnitSize; }\n        memset(&params, 0, sizeof(params));\n        params.d = 1 + (FUZ_rand(&seed) % 16);\n        params.k = params.d + (FUZ_rand(&seed) % 256);\n        dictSize = ZDICT_trainFromBuffer_cover(dictBuffer, dictSize,\n                                               CNBuffer, samplesSizes, nbSamples,\n                                               params);\n        if (ZDICT_isError(dictSize)) goto _output_error;\n        DISPLAYLEVEL(3, \"OK, created dictionary of size %u \\n\", (U32)dictSize);\n\n        DISPLAYLEVEL(3, \"test%3i : check dictID : \", testNb++);\n        dictID = ZDICT_getDictID(dictBuffer, dictSize);\n        if (dictID==0) goto _output_error;\n        DISPLAYLEVEL(3, \"OK : %u \\n\", dictID);\n\n        DISPLAYLEVEL(3, \"test%3i : ZDICT_optimizeTrainFromBuffer_cover : \", testNb++);\n        memset(&params, 0, sizeof(params));\n        params.steps = 4;\n        optDictSize = ZDICT_optimizeTrainFromBuffer_cover(dictBuffer, optDictSize,\n                                                          CNBuffer, samplesSizes,\n                                                          nbSamples / 4, &params);\n        if (ZDICT_isError(optDictSize)) goto _output_error;\n        DISPLAYLEVEL(3, \"OK, created dictionary of size %u \\n\", (U32)optDictSize);\n\n        DISPLAYLEVEL(3, \"test%3i : check dictID : \", testNb++);\n        dictID = ZDICT_getDictID(dictBuffer, optDictSize);\n        if (dictID==0) goto _output_error;\n        DISPLAYLEVEL(3, \"OK : %u \\n\", dictID);\n\n        ZSTD_freeCCtx(cctx);\n        free(dictBuffer);\n        free(samplesSizes);\n    }\n\n    /* Decompression defense tests */\n    DISPLAYLEVEL(3, \"test%3i : Check input length for magic number : \", testNb++);\n    { size_t const r = ZSTD_decompress(decodedBuffer, CNBuffSize, CNBuffer, 3);   /* too small input */\n      if (!ZSTD_isError(r)) goto _output_error;\n      if (ZSTD_getErrorCode(r) != ZSTD_error_srcSize_wrong) goto _output_error; }\n    DISPLAYLEVEL(3, \"OK \\n\");\n\n    DISPLAYLEVEL(3, \"test%3i : Check magic Number : \", testNb++);\n    ((char*)(CNBuffer))[0] = 1;\n    { size_t const r = ZSTD_decompress(decodedBuffer, CNBuffSize, CNBuffer, 4);\n      if (!ZSTD_isError(r)) goto _output_error; }\n    DISPLAYLEVEL(3, \"OK \\n\");\n\n    /* content size verification test */\n    DISPLAYLEVEL(3, \"test%3i : Content size verification : \", testNb++);\n    {   ZSTD_CCtx* const cctx = ZSTD_createCCtx();\n        size_t const srcSize = 5000;\n        size_t const wrongSrcSize = (srcSize + 1000);\n        ZSTD_parameters params = ZSTD_getParams(1, wrongSrcSize, 0);\n        params.fParams.contentSizeFlag = 1;\n        CHECK( ZSTD_compressBegin_advanced(cctx, NULL, 0, params, wrongSrcSize) );\n        {   size_t const result = ZSTD_compressEnd(cctx, decodedBuffer, CNBuffSize, CNBuffer, srcSize);\n            if (!ZSTD_isError(result)) goto _output_error;\n            if (ZSTD_getErrorCode(result) != ZSTD_error_srcSize_wrong) goto _output_error;\n            DISPLAYLEVEL(3, \"OK : %s \\n\", ZSTD_getErrorName(result));\n        }\n        ZSTD_freeCCtx(cctx);\n    }\n\n    /* negative compression level test : ensure simple API and advanced API produce same result */\n    DISPLAYLEVEL(3, \"test%3i : negative compression level : \", testNb++);\n    {   ZSTD_CCtx* const cctx = ZSTD_createCCtx();\n        size_t const srcSize = CNBuffSize / 5;\n        int const compressionLevel = -1;\n\n        assert(cctx != NULL);\n        {   ZSTD_parameters const params = ZSTD_getParams(compressionLevel, srcSize, 0);\n            size_t const cSize_1pass = ZSTD_compress_advanced(cctx,\n                                        compressedBuffer, compressedBufferSize,\n                                        CNBuffer, srcSize,\n                                        NULL, 0,\n                                        params);\n            if (ZSTD_isError(cSize_1pass)) goto _output_error;\n\n            CHECK( ZSTD_CCtx_setParameter(cctx, ZSTD_p_compressionLevel, (unsigned)compressionLevel) );\n            {   ZSTD_inBuffer in = { CNBuffer, srcSize, 0 };\n                ZSTD_outBuffer out = { compressedBuffer, compressedBufferSize, 0 };\n                size_t const compressionResult = ZSTD_compress_generic(cctx, &out, &in, ZSTD_e_end);\n                DISPLAYLEVEL(5, \"simple=%zu vs %zu=advanced : \", cSize_1pass, out.pos);\n                if (ZSTD_isError(compressionResult)) goto _output_error;\n                if (out.pos != cSize_1pass) goto _output_error;\n        }   }\n        ZSTD_freeCCtx(cctx);\n    }\n    DISPLAYLEVEL(3, \"OK \\n\");\n\n    /* parameters order test */\n    {   size_t const inputSize = CNBuffSize / 2;\n        U64 xxh64;\n\n        {   ZSTD_CCtx* const cctx = ZSTD_createCCtx();\n            DISPLAYLEVEL(3, \"test%3i : parameters in order : \", testNb++);\n            assert(cctx != NULL);\n            CHECK( ZSTD_CCtx_setParameter(cctx, ZSTD_p_compressionLevel, 2) );\n            CHECK( ZSTD_CCtx_setParameter(cctx, ZSTD_p_enableLongDistanceMatching, 1) );\n            CHECK( ZSTD_CCtx_setParameter(cctx, ZSTD_p_windowLog, 18) );\n            {   ZSTD_inBuffer in = { CNBuffer, inputSize, 0 };\n                ZSTD_outBuffer out = { compressedBuffer, ZSTD_compressBound(inputSize), 0 };\n                size_t const result = ZSTD_compress_generic(cctx, &out, &in, ZSTD_e_end);\n                if (result != 0) goto _output_error;\n                if (in.pos != in.size) goto _output_error;\n                cSize = out.pos;\n                xxh64 = XXH64(out.dst, out.pos, 0);\n            }\n            DISPLAYLEVEL(3, \"OK (compress : %u -> %u bytes)\\n\", (U32)inputSize, (U32)cSize);\n            ZSTD_freeCCtx(cctx);\n        }\n\n        {   ZSTD_CCtx* cctx = ZSTD_createCCtx();\n            DISPLAYLEVEL(3, \"test%3i : parameters disordered : \", testNb++);\n            CHECK( ZSTD_CCtx_setParameter(cctx, ZSTD_p_windowLog, 18) );\n            CHECK( ZSTD_CCtx_setParameter(cctx, ZSTD_p_enableLongDistanceMatching, 1) );\n            CHECK( ZSTD_CCtx_setParameter(cctx, ZSTD_p_compressionLevel, 2) );\n            {   ZSTD_inBuffer in = { CNBuffer, inputSize, 0 };\n                ZSTD_outBuffer out = { compressedBuffer, ZSTD_compressBound(inputSize), 0 };\n                size_t const result = ZSTD_compress_generic(cctx, &out, &in, ZSTD_e_end);\n                if (result != 0) goto _output_error;\n                if (in.pos != in.size) goto _output_error;\n                if (out.pos != cSize) goto _output_error;   /* must result in same compressed result, hence same size */\n                if (XXH64(out.dst, out.pos, 0) != xxh64) goto _output_error;  /* must result in exactly same content, hence same hash */\n                DISPLAYLEVEL(3, \"OK (compress : %u -> %u bytes)\\n\", (U32)inputSize, (U32)out.pos);\n            }\n            ZSTD_freeCCtx(cctx);\n        }\n    }\n\n    /* custom formats tests */\n    {   ZSTD_CCtx* const cctx = ZSTD_createCCtx();\n        size_t const inputSize = CNBuffSize / 2;   /* won't cause pb with small dict size */\n\n        /* basic block compression */\n        DISPLAYLEVEL(3, \"test%3i : magic-less format test : \", testNb++);\n        CHECK( ZSTD_CCtx_setParameter(cctx, ZSTD_p_format, ZSTD_f_zstd1_magicless) );\n        {   ZSTD_inBuffer in = { CNBuffer, inputSize, 0 };\n            ZSTD_outBuffer out = { compressedBuffer, ZSTD_compressBound(inputSize), 0 };\n            size_t const result = ZSTD_compress_generic(cctx, &out, &in, ZSTD_e_end);\n            if (result != 0) goto _output_error;\n            if (in.pos != in.size) goto _output_error;\n            cSize = out.pos;\n        }\n        DISPLAYLEVEL(3, \"OK (compress : %u -> %u bytes)\\n\", (U32)inputSize, (U32)cSize);\n\n        DISPLAYLEVEL(3, \"test%3i : decompress normally (should fail) : \", testNb++);\n        {   size_t const decodeResult = ZSTD_decompressDCtx(dctx, decodedBuffer, CNBuffSize, compressedBuffer, cSize);\n            if (ZSTD_getErrorCode(decodeResult) != ZSTD_error_prefix_unknown) goto _output_error;\n            DISPLAYLEVEL(3, \"OK : %s \\n\", ZSTD_getErrorName(decodeResult));\n        }\n\n        DISPLAYLEVEL(3, \"test%3i : decompress of magic-less frame : \", testNb++);\n        ZSTD_DCtx_reset(dctx);\n        CHECK( ZSTD_DCtx_setFormat(dctx, ZSTD_f_zstd1_magicless) );\n        {   ZSTD_frameHeader zfh;\n            size_t const zfhrt = ZSTD_getFrameHeader_advanced(&zfh, compressedBuffer, cSize, ZSTD_f_zstd1_magicless);\n            if (zfhrt != 0) goto _output_error;\n        }\n        {   ZSTD_inBuffer in = { compressedBuffer, cSize, 0 };\n            ZSTD_outBuffer out = { decodedBuffer, CNBuffSize, 0 };\n            size_t const result = ZSTD_decompress_generic(dctx, &out, &in);\n            if (result != 0) goto _output_error;\n            if (in.pos != in.size) goto _output_error;\n            if (out.pos != inputSize) goto _output_error;\n            DISPLAYLEVEL(3, \"OK : regenerated %u bytes \\n\", (U32)out.pos);\n        }\n\n        ZSTD_freeCCtx(cctx);\n    }\n\n    /* block API tests */\n    {   ZSTD_CCtx* const cctx = ZSTD_createCCtx();\n        static const size_t dictSize = 65 KB;\n        static const size_t blockSize = 100 KB;   /* won't cause pb with small dict size */\n        size_t cSize2;\n\n        /* basic block compression */\n        DISPLAYLEVEL(3, \"test%3i : Block compression test : \", testNb++);\n        CHECK( ZSTD_compressBegin(cctx, 5) );\n        CHECK( ZSTD_getBlockSize(cctx) >= blockSize);\n        cSize = ZSTD_compressBlock(cctx, compressedBuffer, ZSTD_compressBound(blockSize), CNBuffer, blockSize);\n        if (ZSTD_isError(cSize)) goto _output_error;\n        DISPLAYLEVEL(3, \"OK \\n\");\n\n        DISPLAYLEVEL(3, \"test%3i : Block decompression test : \", testNb++);\n        CHECK( ZSTD_decompressBegin(dctx) );\n        { CHECK_V(r, ZSTD_decompressBlock(dctx, decodedBuffer, CNBuffSize, compressedBuffer, cSize) );\n          if (r != blockSize) goto _output_error; }\n        DISPLAYLEVEL(3, \"OK \\n\");\n\n        /* very long stream of block compression */\n        DISPLAYLEVEL(3, \"test%3i : Huge block streaming compression test : \", testNb++);\n        CHECK( ZSTD_compressBegin(cctx, -99) );  /* we just want to quickly overflow internal U32 index */\n        CHECK( ZSTD_getBlockSize(cctx) >= blockSize);\n        {   U64 const toCompress = 5000000000ULL;   /* > 4 GB */\n            U64 compressed = 0;\n            while (compressed < toCompress) {\n                size_t const blockCSize = ZSTD_compressBlock(cctx, compressedBuffer, ZSTD_compressBound(blockSize), CNBuffer, blockSize);\n                if (ZSTD_isError(cSize)) goto _output_error;\n                compressed += blockCSize;\n            }\n        }\n        DISPLAYLEVEL(3, \"OK \\n\");\n\n        /* dictionary block compression */\n        DISPLAYLEVEL(3, \"test%3i : Dictionary Block compression test : \", testNb++);\n        CHECK( ZSTD_compressBegin_usingDict(cctx, CNBuffer, dictSize, 5) );\n        cSize = ZSTD_compressBlock(cctx, compressedBuffer, ZSTD_compressBound(blockSize), (char*)CNBuffer+dictSize, blockSize);\n        if (ZSTD_isError(cSize)) goto _output_error;\n        cSize2 = ZSTD_compressBlock(cctx, (char*)compressedBuffer+cSize, ZSTD_compressBound(blockSize), (char*)CNBuffer+dictSize+blockSize, blockSize);\n        if (ZSTD_isError(cSize2)) goto _output_error;\n        memcpy((char*)compressedBuffer+cSize, (char*)CNBuffer+dictSize+blockSize, blockSize);   /* fake non-compressed block */\n        cSize2 = ZSTD_compressBlock(cctx, (char*)compressedBuffer+cSize+blockSize, ZSTD_compressBound(blockSize),\n                                          (char*)CNBuffer+dictSize+2*blockSize, blockSize);\n        if (ZSTD_isError(cSize2)) goto _output_error;\n        DISPLAYLEVEL(3, \"OK \\n\");\n\n        DISPLAYLEVEL(3, \"test%3i : Dictionary Block decompression test : \", testNb++);\n        CHECK( ZSTD_decompressBegin_usingDict(dctx, CNBuffer, dictSize) );\n        { CHECK_V( r, ZSTD_decompressBlock(dctx, decodedBuffer, CNBuffSize, compressedBuffer, cSize) );\n          if (r != blockSize) goto _output_error; }\n        ZSTD_insertBlock(dctx, (char*)decodedBuffer+blockSize, blockSize);   /* insert non-compressed block into dctx history */\n        { CHECK_V( r, ZSTD_decompressBlock(dctx, (char*)decodedBuffer+2*blockSize, CNBuffSize, (char*)compressedBuffer+cSize+blockSize, cSize2) );\n          if (r != blockSize) goto _output_error; }\n        DISPLAYLEVEL(3, \"OK \\n\");\n\n        DISPLAYLEVEL(3, \"test%3i : Block compression with CDict : \", testNb++);\n        {   ZSTD_CDict* const cdict = ZSTD_createCDict(CNBuffer, dictSize, 3);\n            if (cdict==NULL) goto _output_error;\n            CHECK( ZSTD_compressBegin_usingCDict(cctx, cdict) );\n            CHECK( ZSTD_compressBlock(cctx, compressedBuffer, ZSTD_compressBound(blockSize), (char*)CNBuffer+dictSize, blockSize) );\n            ZSTD_freeCDict(cdict);\n        }\n        DISPLAYLEVEL(3, \"OK \\n\");\n\n        ZSTD_freeCCtx(cctx);\n    }\n    ZSTD_freeDCtx(dctx);\n\n    /* long rle test */\n    {   size_t sampleSize = 0;\n        DISPLAYLEVEL(3, \"test%3i : Long RLE test : \", testNb++);\n        RDG_genBuffer(CNBuffer, sampleSize, compressibility, 0., seed+1);\n        memset((char*)CNBuffer+sampleSize, 'B', 256 KB - 1);\n        sampleSize += 256 KB - 1;\n        RDG_genBuffer((char*)CNBuffer+sampleSize, 96 KB, compressibility, 0., seed+2);\n        sampleSize += 96 KB;\n        cSize = ZSTD_compress(compressedBuffer, ZSTD_compressBound(sampleSize), CNBuffer, sampleSize, 1);\n        if (ZSTD_isError(cSize)) goto _output_error;\n        { CHECK_V(regenSize, ZSTD_decompress(decodedBuffer, sampleSize, compressedBuffer, cSize));\n          if (regenSize!=sampleSize) goto _output_error; }\n        DISPLAYLEVEL(3, \"OK \\n\");\n    }\n\n    /* All zeroes test (test bug #137) */\n    #define ZEROESLENGTH 100\n    DISPLAYLEVEL(3, \"test%3i : compress %u zeroes : \", testNb++, ZEROESLENGTH);\n    memset(CNBuffer, 0, ZEROESLENGTH);\n    { CHECK_V(r, ZSTD_compress(compressedBuffer, ZSTD_compressBound(ZEROESLENGTH), CNBuffer, ZEROESLENGTH, 1) );\n      cSize = r; }\n    DISPLAYLEVEL(3, \"OK (%u bytes : %.2f%%)\\n\", (U32)cSize, (double)cSize/ZEROESLENGTH*100);\n\n    DISPLAYLEVEL(3, \"test%3i : decompress %u zeroes : \", testNb++, ZEROESLENGTH);\n    { CHECK_V(r, ZSTD_decompress(decodedBuffer, ZEROESLENGTH, compressedBuffer, cSize) );\n      if (r != ZEROESLENGTH) goto _output_error; }\n    DISPLAYLEVEL(3, \"OK \\n\");\n\n    /* nbSeq limit test */\n    #define _3BYTESTESTLENGTH 131000\n    #define NB3BYTESSEQLOG   9\n    #define NB3BYTESSEQ     (1 << NB3BYTESSEQLOG)\n    #define NB3BYTESSEQMASK (NB3BYTESSEQ-1)\n    /* creates a buffer full of 3-bytes sequences */\n    {   BYTE _3BytesSeqs[NB3BYTESSEQ][3];\n        U32 rSeed = 1;\n\n        /* create batch of 3-bytes sequences */\n        {   int i;\n            for (i=0; i < NB3BYTESSEQ; i++) {\n                _3BytesSeqs[i][0] = (BYTE)(FUZ_rand(&rSeed) & 255);\n                _3BytesSeqs[i][1] = (BYTE)(FUZ_rand(&rSeed) & 255);\n                _3BytesSeqs[i][2] = (BYTE)(FUZ_rand(&rSeed) & 255);\n        }   }\n\n        /* randomly fills CNBuffer with prepared 3-bytes sequences */\n        {   int i;\n            for (i=0; i < _3BYTESTESTLENGTH; i += 3) {   /* note : CNBuffer size > _3BYTESTESTLENGTH+3 */\n                U32 const id = FUZ_rand(&rSeed) & NB3BYTESSEQMASK;\n                ((BYTE*)CNBuffer)[i+0] = _3BytesSeqs[id][0];\n                ((BYTE*)CNBuffer)[i+1] = _3BytesSeqs[id][1];\n                ((BYTE*)CNBuffer)[i+2] = _3BytesSeqs[id][2];\n    }   }   }\n    DISPLAYLEVEL(3, \"test%3i : growing nbSeq : \", testNb++);\n    {   ZSTD_CCtx* const cctx = ZSTD_createCCtx();\n        size_t const maxNbSeq = _3BYTESTESTLENGTH / 3;\n        size_t const bound = ZSTD_compressBound(_3BYTESTESTLENGTH);\n        size_t nbSeq = 1;\n        while (nbSeq <= maxNbSeq) {\n          CHECK(ZSTD_compressCCtx(cctx, compressedBuffer, bound, CNBuffer, nbSeq * 3, 19));\n          /* Check every sequence for the first 100, then skip more rapidly. */\n          if (nbSeq < 100) {\n            ++nbSeq;\n          } else {\n            nbSeq += (nbSeq >> 2);\n          }\n        }\n        ZSTD_freeCCtx(cctx);\n    }\n    DISPLAYLEVEL(3, \"OK \\n\");\n\n    DISPLAYLEVEL(3, \"test%3i : compress lots 3-bytes sequences : \", testNb++);\n    { CHECK_V(r, ZSTD_compress(compressedBuffer, ZSTD_compressBound(_3BYTESTESTLENGTH),\n                                 CNBuffer, _3BYTESTESTLENGTH, 19) );\n      cSize = r; }\n    DISPLAYLEVEL(3, \"OK (%u bytes : %.2f%%)\\n\", (U32)cSize, (double)cSize/_3BYTESTESTLENGTH*100);\n\n    DISPLAYLEVEL(3, \"test%3i : decompress lots 3-bytes sequence : \", testNb++);\n    { CHECK_V(r, ZSTD_decompress(decodedBuffer, _3BYTESTESTLENGTH, compressedBuffer, cSize) );\n      if (r != _3BYTESTESTLENGTH) goto _output_error; }\n    DISPLAYLEVEL(3, \"OK \\n\");\n\n\n    DISPLAYLEVEL(3, \"test%3i : growing literals buffer : \", testNb++);\n    RDG_genBuffer(CNBuffer, CNBuffSize, 0.0, 0.1, seed);\n    {   ZSTD_CCtx* const cctx = ZSTD_createCCtx();\n        size_t const bound = ZSTD_compressBound(CNBuffSize);\n        size_t size = 1;\n        while (size <= CNBuffSize) {\n          CHECK(ZSTD_compressCCtx(cctx, compressedBuffer, bound, CNBuffer, size, 3));\n          /* Check every size for the first 100, then skip more rapidly. */\n          if (size < 100) {\n            ++size;\n          } else {\n            size += (size >> 2);\n          }\n        }\n        ZSTD_freeCCtx(cctx);\n    }\n    DISPLAYLEVEL(3, \"OK \\n\");\n\n    DISPLAYLEVEL(3, \"test%3i : incompressible data and ill suited dictionary : \", testNb++);\n    {   /* Train a dictionary on low characters */\n        size_t dictSize = 16 KB;\n        void* const dictBuffer = malloc(dictSize);\n        size_t const totalSampleSize = 1 MB;\n        size_t const sampleUnitSize = 8 KB;\n        U32 const nbSamples = (U32)(totalSampleSize / sampleUnitSize);\n        size_t* const samplesSizes = (size_t*) malloc(nbSamples * sizeof(size_t));\n        if (!dictBuffer || !samplesSizes) goto _output_error;\n        { U32 u; for (u=0; u<nbSamples; u++) samplesSizes[u] = sampleUnitSize; }\n        dictSize = ZDICT_trainFromBuffer(dictBuffer, dictSize, CNBuffer, samplesSizes, nbSamples);\n        if (ZDICT_isError(dictSize)) goto _output_error;\n        /* Reverse the characters to make the dictionary ill suited */\n        {   U32 u;\n            for (u = 0; u < CNBuffSize; ++u) {\n              ((BYTE*)CNBuffer)[u] = 255 - ((BYTE*)CNBuffer)[u];\n            }\n        }\n        {   /* Compress the data */\n            size_t const inputSize = 500;\n            size_t const outputSize = ZSTD_compressBound(inputSize);\n            void* const outputBuffer = malloc(outputSize);\n            ZSTD_CCtx* const cctx = ZSTD_createCCtx();\n            if (!outputBuffer || !cctx) goto _output_error;\n            CHECK(ZSTD_compress_usingDict(cctx, outputBuffer, outputSize, CNBuffer, inputSize, dictBuffer, dictSize, 1));\n            free(outputBuffer);\n            ZSTD_freeCCtx(cctx);\n        }\n\n        free(dictBuffer);\n        free(samplesSizes);\n    }\n    DISPLAYLEVEL(3, \"OK \\n\");\n\n\n    /* findFrameCompressedSize on skippable frames */\n    DISPLAYLEVEL(3, \"test%3i : frame compressed size of skippable frame : \", testNb++);\n    {   const char* frame = \"\\x50\\x2a\\x4d\\x18\\x05\\x0\\x0\\0abcde\";\n        size_t const frameSrcSize = 13;\n        if (ZSTD_findFrameCompressedSize(frame, frameSrcSize) != frameSrcSize) goto _output_error; }\n    DISPLAYLEVEL(3, \"OK \\n\");\n\n    /* error string tests */\n    DISPLAYLEVEL(3, \"test%3i : testing ZSTD error code strings : \", testNb++);\n    if (strcmp(\"No error detected\", ZSTD_getErrorName((ZSTD_ErrorCode)(0-ZSTD_error_no_error))) != 0) goto _output_error;\n    if (strcmp(\"No error detected\", ZSTD_getErrorString(ZSTD_error_no_error)) != 0) goto _output_error;\n    if (strcmp(\"Unspecified error code\", ZSTD_getErrorString((ZSTD_ErrorCode)(0-ZSTD_error_GENERIC))) != 0) goto _output_error;\n    if (strcmp(\"Error (generic)\", ZSTD_getErrorName((size_t)0-ZSTD_error_GENERIC)) != 0) goto _output_error;\n    if (strcmp(\"Error (generic)\", ZSTD_getErrorString(ZSTD_error_GENERIC)) != 0) goto _output_error;\n    if (strcmp(\"No error detected\", ZSTD_getErrorName(ZSTD_error_GENERIC)) != 0) goto _output_error;\n    DISPLAYLEVEL(3, \"OK \\n\");\n\n    DISPLAYLEVEL(3, \"test%3i : testing ZSTD dictionary sizes : \", testNb++);\n    RDG_genBuffer(CNBuffer, CNBuffSize, compressibility, 0., seed);\n    {\n        size_t const size = MIN(128 KB, CNBuffSize);\n        ZSTD_CCtx* const cctx = ZSTD_createCCtx();\n        ZSTD_CDict* const lgCDict = ZSTD_createCDict(CNBuffer, size, 1);\n        ZSTD_CDict* const smCDict = ZSTD_createCDict(CNBuffer, 1 KB, 1);\n        ZSTD_frameHeader lgHeader;\n        ZSTD_frameHeader smHeader;\n\n        CHECK_Z(ZSTD_compress_usingCDict(cctx, compressedBuffer, compressedBufferSize, CNBuffer, size, lgCDict));\n        CHECK_Z(ZSTD_getFrameHeader(&lgHeader, compressedBuffer, compressedBufferSize));\n        CHECK_Z(ZSTD_compress_usingCDict(cctx, compressedBuffer, compressedBufferSize, CNBuffer, size, smCDict));\n        CHECK_Z(ZSTD_getFrameHeader(&smHeader, compressedBuffer, compressedBufferSize));\n\n        if (lgHeader.windowSize != smHeader.windowSize) goto _output_error;\n\n        ZSTD_freeCDict(smCDict);\n        ZSTD_freeCDict(lgCDict);\n        ZSTD_freeCCtx(cctx);\n    }\n    DISPLAYLEVEL(3, \"OK \\n\");\n\n    DISPLAYLEVEL(3, \"test%3i : testing FSE_normalizeCount() PR#1255: \", testNb++);\n    {\n        short norm[32];\n        unsigned count[32];\n        unsigned const tableLog = 5;\n        size_t const nbSeq = 32;\n        unsigned const maxSymbolValue = 31;\n        size_t i;\n\n        for (i = 0; i < 32; ++i)\n            count[i] = 1;\n        /* Calling FSE_normalizeCount() on a uniform distribution should not\n         * cause a division by zero.\n         */\n        FSE_normalizeCount(norm, tableLog, count, nbSeq, maxSymbolValue);\n    }\n    DISPLAYLEVEL(3, \"OK \\n\");\n\n_end:\n    free(CNBuffer);\n    free(compressedBuffer);\n    free(decodedBuffer);\n    return testResult;\n\n_output_error:\n    testResult = 1;\n    DISPLAY(\"Error detected in Unit tests ! \\n\");\n    goto _end;\n}", "path": "MMseqs2/lib/zstd/tests/fuzzer.c", "commit_date": "2018-12-05 00:00:00", "repo_name": "soedinglab/MMseqs2", "stars": 1208, "license": "gpl-3.0", "language": "c", "size": 31120}
{"docstring": "/*! POOL_join() :\n    Shutdown the queue, wake any sleeping threads, and join all of the threads.\n*/\n", "func_signal": "static void POOL_join(POOL_ctx* ctx)", "code": "{\n    /* Shut down the queue */\n    ZSTD_pthread_mutex_lock(&ctx->queueMutex);\n    ctx->shutdown = 1;\n    ZSTD_pthread_mutex_unlock(&ctx->queueMutex);\n    /* Wake up sleeping threads */\n    ZSTD_pthread_cond_broadcast(&ctx->queuePushCond);\n    ZSTD_pthread_cond_broadcast(&ctx->queuePopCond);\n    /* Join all of the threads */\n    {   size_t i;\n        for (i = 0; i < ctx->threadCapacity; ++i) {\n            ZSTD_pthread_join(ctx->threads[i], NULL);  /* note : could fail */\n    }   }\n}", "path": "MMseqs2/lib/zstd/lib/common/pool.c", "commit_date": "2018-12-05 00:00:00", "repo_name": "soedinglab/MMseqs2", "stars": 1208, "license": "gpl-3.0", "language": "c", "size": 31120}
{"docstring": "/* Secondary normalization method.\n   To be used when primary method fails. */\n", "func_signal": "static size_t FSE_normalizeM2(short* norm, U32 tableLog, const unsigned* count, size_t total, U32 maxSymbolValue)", "code": "{\n    short const NOT_YET_ASSIGNED = -2;\n    U32 s;\n    U32 distributed = 0;\n    U32 ToDistribute;\n\n    /* Init */\n    U32 const lowThreshold = (U32)(total >> tableLog);\n    U32 lowOne = (U32)((total * 3) >> (tableLog + 1));\n\n    for (s=0; s<=maxSymbolValue; s++) {\n        if (count[s] == 0) {\n            norm[s]=0;\n            continue;\n        }\n        if (count[s] <= lowThreshold) {\n            norm[s] = -1;\n            distributed++;\n            total -= count[s];\n            continue;\n        }\n        if (count[s] <= lowOne) {\n            norm[s] = 1;\n            distributed++;\n            total -= count[s];\n            continue;\n        }\n\n        norm[s]=NOT_YET_ASSIGNED;\n    }\n    ToDistribute = (1 << tableLog) - distributed;\n\n    if (ToDistribute == 0)\n        return 0;\n\n    if ((total / ToDistribute) > lowOne) {\n        /* risk of rounding to zero */\n        lowOne = (U32)((total * 3) / (ToDistribute * 2));\n        for (s=0; s<=maxSymbolValue; s++) {\n            if ((norm[s] == NOT_YET_ASSIGNED) && (count[s] <= lowOne)) {\n                norm[s] = 1;\n                distributed++;\n                total -= count[s];\n                continue;\n        }   }\n        ToDistribute = (1 << tableLog) - distributed;\n    }\n\n    if (distributed == maxSymbolValue+1) {\n        /* all values are pretty poor;\n           probably incompressible data (should have already been detected);\n           find max, then give all remaining points to max */\n        U32 maxV = 0, maxC = 0;\n        for (s=0; s<=maxSymbolValue; s++)\n            if (count[s] > maxC) { maxV=s; maxC=count[s]; }\n        norm[maxV] += (short)ToDistribute;\n        return 0;\n    }\n\n    if (total == 0) {\n        /* all of the symbols were low enough for the lowOne or lowThreshold */\n        for (s=0; ToDistribute > 0; s = (s+1)%(maxSymbolValue+1))\n            if (norm[s] > 0) { ToDistribute--; norm[s]++; }\n        return 0;\n    }\n\n    {   U64 const vStepLog = 62 - tableLog;\n        U64 const mid = (1ULL << (vStepLog-1)) - 1;\n        U64 const rStep = ((((U64)1<<vStepLog) * ToDistribute) + mid) / total;   /* scale on remaining */\n        U64 tmpTotal = mid;\n        for (s=0; s<=maxSymbolValue; s++) {\n            if (norm[s]==NOT_YET_ASSIGNED) {\n                U64 const end = tmpTotal + (count[s] * rStep);\n                U32 const sStart = (U32)(tmpTotal >> vStepLog);\n                U32 const sEnd = (U32)(end >> vStepLog);\n                U32 const weight = sEnd - sStart;\n                if (weight < 1)\n                    return ERROR(GENERIC);\n                norm[s] = (short)weight;\n                tmpTotal = end;\n    }   }   }\n\n    return 0;\n}", "path": "MMseqs2/lib/zstd/lib/compress/fse_compress.c", "commit_date": "2018-12-05 00:00:00", "repo_name": "soedinglab/MMseqs2", "stars": 1208, "license": "gpl-3.0", "language": "c", "size": 31120}
{"docstring": "/*-**************************************************************\n*  FSE NCount encoding\n****************************************************************/\n", "func_signal": "size_t FSE_NCountWriteBound(unsigned maxSymbolValue, unsigned tableLog)", "code": "{\n    size_t const maxHeaderSize = (((maxSymbolValue+1) * tableLog) >> 3) + 3;\n    return maxSymbolValue ? maxHeaderSize : FSE_NCOUNTBOUND;  /* maxSymbolValue==0 ? use default */\n}", "path": "MMseqs2/lib/zstd/lib/compress/fse_compress.c", "commit_date": "2018-12-05 00:00:00", "repo_name": "soedinglab/MMseqs2", "stars": 1208, "license": "gpl-3.0", "language": "c", "size": 31120}
{"docstring": "/* `workSpace` must a table of at least 1024 unsigned */\n", "func_signal": "static size_t HUF_compress_internal(void *dst, size_t dstSize, const void *src, size_t srcSize, unsigned maxSymbolValue, unsigned huffLog,\n\t\t\t\t    unsigned singleStream, void *workSpace, size_t wkspSize, HUF_CElt *oldHufTable, HUF_repeat *repeat, int preferRepeat)", "code": "{\n\tBYTE *const ostart = (BYTE *)dst;\n\tBYTE *const oend = ostart + dstSize;\n\tBYTE *op = ostart;\n\n\tU32 *count;\n\tsize_t const countSize = sizeof(U32) * (HUF_SYMBOLVALUE_MAX + 1);\n\tHUF_CElt *CTable;\n\tsize_t const CTableSize = sizeof(HUF_CElt) * (HUF_SYMBOLVALUE_MAX + 1);\n\n\t/* checks & inits */\n\tif (wkspSize < sizeof(huffNodeTable) + countSize + CTableSize)\n\t\treturn ERROR(GENERIC);\n\tif (!srcSize)\n\t\treturn 0; /* Uncompressed (note : 1 means rle, so first byte must be correct) */\n\tif (!dstSize)\n\t\treturn 0; /* cannot fit within dst budget */\n\tif (srcSize > HUF_BLOCKSIZE_MAX)\n\t\treturn ERROR(srcSize_wrong); /* curr block size limit */\n\tif (huffLog > HUF_TABLELOG_MAX)\n\t\treturn ERROR(tableLog_tooLarge);\n\tif (!maxSymbolValue)\n\t\tmaxSymbolValue = HUF_SYMBOLVALUE_MAX;\n\tif (!huffLog)\n\t\thuffLog = HUF_TABLELOG_DEFAULT;\n\n\tcount = (U32 *)workSpace;\n\tworkSpace = (BYTE *)workSpace + countSize;\n\twkspSize -= countSize;\n\tCTable = (HUF_CElt *)workSpace;\n\tworkSpace = (BYTE *)workSpace + CTableSize;\n\twkspSize -= CTableSize;\n\n\t/* Heuristic : If we don't need to check the validity of the old table use the old table for small inputs */\n\tif (preferRepeat && repeat && *repeat == HUF_repeat_valid) {\n\t\treturn HUF_compressCTable_internal(ostart, op, oend, src, srcSize, singleStream, oldHufTable);\n\t}\n\n\t/* Scan input and build symbol stats */\n\t{\n\t\tCHECK_V_F(largest, FSE_count_wksp(count, &maxSymbolValue, (const BYTE *)src, srcSize, (U32 *)workSpace));\n\t\tif (largest == srcSize) {\n\t\t\t*ostart = ((const BYTE *)src)[0];\n\t\t\treturn 1;\n\t\t} /* single symbol, rle */\n\t\tif (largest <= (srcSize >> 7) + 1)\n\t\t\treturn 0; /* Fast heuristic : not compressible enough */\n\t}\n\n\t/* Check validity of previous table */\n\tif (repeat && *repeat == HUF_repeat_check && !HUF_validateCTable(oldHufTable, count, maxSymbolValue)) {\n\t\t*repeat = HUF_repeat_none;\n\t}\n\t/* Heuristic : use existing table for small inputs */\n\tif (preferRepeat && repeat && *repeat != HUF_repeat_none) {\n\t\treturn HUF_compressCTable_internal(ostart, op, oend, src, srcSize, singleStream, oldHufTable);\n\t}\n\n\t/* Build Huffman Tree */\n\thuffLog = HUF_optimalTableLog(huffLog, srcSize, maxSymbolValue);\n\t{\n\t\tCHECK_V_F(maxBits, HUF_buildCTable_wksp(CTable, count, maxSymbolValue, huffLog, workSpace, wkspSize));\n\t\thuffLog = (U32)maxBits;\n\t\t/* Zero the unused symbols so we can check it for validity */\n\t\tmemset(CTable + maxSymbolValue + 1, 0, CTableSize - (maxSymbolValue + 1) * sizeof(HUF_CElt));\n\t}\n\n\t/* Write table description header */\n\t{\n\t\tCHECK_V_F(hSize, HUF_writeCTable_wksp(op, dstSize, CTable, maxSymbolValue, huffLog, workSpace, wkspSize));\n\t\t/* Check if using the previous table will be beneficial */\n\t\tif (repeat && *repeat != HUF_repeat_none) {\n\t\t\tsize_t const oldSize = HUF_estimateCompressedSize(oldHufTable, count, maxSymbolValue);\n\t\t\tsize_t const newSize = HUF_estimateCompressedSize(CTable, count, maxSymbolValue);\n\t\t\tif (oldSize <= hSize + newSize || hSize + 12 >= srcSize) {\n\t\t\t\treturn HUF_compressCTable_internal(ostart, op, oend, src, srcSize, singleStream, oldHufTable);\n\t\t\t}\n\t\t}\n\t\t/* Use the new table */\n\t\tif (hSize + 12ul >= srcSize) {\n\t\t\treturn 0;\n\t\t}\n\t\top += hSize;\n\t\tif (repeat) {\n\t\t\t*repeat = HUF_repeat_none;\n\t\t}\n\t\tif (oldHufTable) {\n\t\t\tmemcpy(oldHufTable, CTable, CTableSize);\n\t\t} /* Save the new table */\n\t}\n\treturn HUF_compressCTable_internal(ostart, op, oend, src, srcSize, singleStream, CTable);\n}", "path": "MMseqs2/lib/zstd/contrib/linux-kernel/lib/zstd/huf_compress.c", "commit_date": "2018-12-05 00:00:00", "repo_name": "soedinglab/MMseqs2", "stars": 1208, "license": "gpl-3.0", "language": "c", "size": 31120}
{"docstring": "/* compress from stdin to fixed-size block on stdout */\n", "func_signal": "int main(int argc, char **argv)", "code": "{\n    int ret;                /* return code */\n    unsigned size;          /* requested fixed output block size */\n    unsigned have;          /* bytes written by deflate() call */\n    unsigned char *blk;     /* intermediate and final stream */\n    unsigned char *tmp;     /* close to desired size stream */\n    z_stream def, inf;      /* zlib deflate and inflate states */\n\n    /* get requested output size */\n    if (argc != 2)\n        quit(\"need one argument: size of output block\");\n    ret = (int)strtol(argv[1], argv + 1, 10);\n    if (argv[1][0] != 0)\n        quit(\"argument must be a number\");\n    if (ret < 8)            /* 8 is minimum zlib stream size */\n        quit(\"need positive size of 8 or greater\");\n    size = (unsigned)ret;\n\n    printf(\"zlib version %s\\n\", ZLIB_VERSION);\n    if (ZWRAP_isUsingZSTDcompression()) printf(\"zstd version %s\\n\", zstdVersion());\n\n    /* allocate memory for buffers and compression engine */\n    blk = malloc(size + EXCESS);\n    def.zalloc = Z_NULL;\n    def.zfree = Z_NULL;\n    def.opaque = Z_NULL;\n    ret = deflateInit(&def, Z_DEFAULT_COMPRESSION);\n    if (ret != Z_OK || blk == NULL)\n        quit(\"out of memory\");\n\n    /* compress from stdin until output full, or no more input */\n    def.avail_out = size + EXCESS;\n    def.next_out = blk;\n    LOG_FITBLK(\"partcompress1 total_in=%d total_out=%d\\n\", (int)def.total_in, (int)def.total_out);\n    ret = partcompress(stdin, &def);\n    printf(\"partcompress total_in=%d total_out=%d\\n\", (int)def.total_in, (int)def.total_out);\n    if (ret == Z_ERRNO)\n        quit(\"error reading input\");\n\n    /* if it all fit, then size was undersubscribed -- done! */\n    if (ret == Z_STREAM_END && def.avail_out >= EXCESS) {\n        /* write block to stdout */\n        have = size + EXCESS - def.avail_out;\n   //     if (fwrite(blk, 1, have, stdout) != have || ferror(stdout))\n   //         quit(\"error writing output\");\n\n        /* clean up and print results to stderr */\n        ret = deflateEnd(&def);\n        assert(ret != Z_STREAM_ERROR);\n        free(blk);\n        fprintf(stderr,\n                \"%u bytes unused out of %u requested (all input)\\n\",\n                size - have, size);\n        return 0;\n    }\n\n    /* it didn't all fit -- set up for recompression */\n    inf.zalloc = Z_NULL;\n    inf.zfree = Z_NULL;\n    inf.opaque = Z_NULL;\n    inf.avail_in = 0;\n    inf.next_in = Z_NULL;\n    ret = inflateInit(&inf);\n    tmp = malloc(size + EXCESS);\n    if (ret != Z_OK || tmp == NULL)\n        quit(\"out of memory\");\n    ret = deflateReset(&def);\n    assert(ret != Z_STREAM_ERROR);\n\n    /* do first recompression close to the right amount */\n    inf.avail_in = size + EXCESS;\n    inf.next_in = blk;\n    def.avail_out = size + EXCESS;\n    def.next_out = tmp;\n    LOG_FITBLK(\"recompress1 inf.total_in=%d def.total_out=%d\\n\", (int)inf.total_in, (int)def.total_out);\n    ret = recompress(&inf, &def);\n    LOG_FITBLK(\"recompress1 inf.total_in=%d def.total_out=%d\\n\", (int)inf.total_in, (int)def.total_out);\n    if (ret == Z_MEM_ERROR)\n        quit(\"out of memory\");\n\n    /* set up for next reocmpression */\n    ret = inflateReset(&inf);\n    assert(ret != Z_STREAM_ERROR);\n    ret = deflateReset(&def);\n    assert(ret != Z_STREAM_ERROR);\n\n    /* do second and final recompression (third compression) */\n    inf.avail_in = size - MARGIN;   /* assure stream will complete */\n    inf.next_in = tmp;\n    def.avail_out = size;\n    def.next_out = blk;\n    LOG_FITBLK(\"recompress2 inf.total_in=%d def.total_out=%d\\n\", (int)inf.total_in, (int)def.total_out);\n    ret = recompress(&inf, &def);\n    LOG_FITBLK(\"recompress2 inf.total_in=%d def.total_out=%d\\n\", (int)inf.total_in, (int)def.total_out);\n    if (ret == Z_MEM_ERROR)\n        quit(\"out of memory\");\n    assert(ret == Z_STREAM_END);    /* otherwise MARGIN too small */\n\n    /* done -- write block to stdout */\n    have = size - def.avail_out;\n//    if (fwrite(blk, 1, have, stdout) != have || ferror(stdout))\n//        quit(\"error writing output\");\n\n    /* clean up and print results to stderr */\n    free(tmp);\n    ret = inflateEnd(&inf);\n    assert(ret != Z_STREAM_ERROR);\n    ret = deflateEnd(&def);\n    assert(ret != Z_STREAM_ERROR);\n    free(blk);\n    fprintf(stderr,\n            \"%u bytes unused out of %u requested (%lu input)\\n\",\n            size - have, size, def.total_in);\n    return 0;\n}", "path": "MMseqs2/lib/zstd/zlibWrapper/examples/fitblk.c", "commit_date": "2018-12-05 00:00:00", "repo_name": "soedinglab/MMseqs2", "stars": 1208, "license": "gpl-3.0", "language": "c", "size": 31120}
{"docstring": "/* POOL_thread() :\n * Work thread for the thread pool.\n * Waits for jobs and executes them.\n * @returns : NULL on failure else non-null.\n */\n", "func_signal": "static void* POOL_thread(void* opaque)", "code": "{\n    POOL_ctx* const ctx = (POOL_ctx*)opaque;\n    if (!ctx) { return NULL; }\n    for (;;) {\n        /* Lock the mutex and wait for a non-empty queue or until shutdown */\n        ZSTD_pthread_mutex_lock(&ctx->queueMutex);\n\n        while ( ctx->queueEmpty\n            || (ctx->numThreadsBusy >= ctx->threadLimit) ) {\n            if (ctx->shutdown) {\n                /* even if !queueEmpty, (possible if numThreadsBusy >= threadLimit),\n                 * a few threads will be shutdown while !queueEmpty,\n                 * but enough threads will remain active to finish the queue */\n                ZSTD_pthread_mutex_unlock(&ctx->queueMutex);\n                return opaque;\n            }\n            ZSTD_pthread_cond_wait(&ctx->queuePopCond, &ctx->queueMutex);\n        }\n        /* Pop a job off the queue */\n        {   POOL_job const job = ctx->queue[ctx->queueHead];\n            ctx->queueHead = (ctx->queueHead + 1) % ctx->queueSize;\n            ctx->numThreadsBusy++;\n            ctx->queueEmpty = ctx->queueHead == ctx->queueTail;\n            /* Unlock the mutex, signal a pusher, and run the job */\n            ZSTD_pthread_cond_signal(&ctx->queuePushCond);\n            ZSTD_pthread_mutex_unlock(&ctx->queueMutex);\n\n            job.function(job.opaque);\n\n            /* If the intended queue size was 0, signal after finishing job */\n            ZSTD_pthread_mutex_lock(&ctx->queueMutex);\n            ctx->numThreadsBusy--;\n            if (ctx->queueSize == 1) {\n                ZSTD_pthread_cond_signal(&ctx->queuePushCond);\n            }\n            ZSTD_pthread_mutex_unlock(&ctx->queueMutex);\n        }\n    }  /* for (;;) */\n    assert(0);  /* Unreachable */\n}", "path": "MMseqs2/lib/zstd/lib/common/pool.c", "commit_date": "2018-12-05 00:00:00", "repo_name": "soedinglab/MMseqs2", "stars": 1208, "license": "gpl-3.0", "language": "c", "size": 31120}
{"docstring": "/*! readU32FromChar() :\n    @return : unsigned integer value read from input in `char` format\n    allows and interprets K, KB, KiB, M, MB and MiB suffix.\n    Will also modify `*stringPtr`, advancing it to position where it stopped reading.\n    Note : function result can overflow if digit string > MAX_UINT */\n", "func_signal": "static unsigned readU32FromChar(const char** stringPtr)", "code": "{\n    unsigned result = 0;\n    while ((**stringPtr >='0') && (**stringPtr <='9'))\n        result *= 10, result += **stringPtr - '0', (*stringPtr)++ ;\n    if ((**stringPtr=='K') || (**stringPtr=='M')) {\n        result <<= 10;\n        if (**stringPtr=='M') result <<= 10;\n        (*stringPtr)++ ;\n        if (**stringPtr=='i') (*stringPtr)++;\n        if (**stringPtr=='B') (*stringPtr)++;\n    }\n    return result;\n}", "path": "MMseqs2/lib/zstd/tests/fuzzer.c", "commit_date": "2018-12-05 00:00:00", "repo_name": "soedinglab/MMseqs2", "stars": 1208, "license": "gpl-3.0", "language": "c", "size": 31120}
{"docstring": "/* createDict() :\n   `dictFileName` is supposed to have been created using `zstd --train` */\n", "func_signal": "static ZSTD_DDict* createDict_orDie(const char* dictFileName)", "code": "{\n    size_t dictSize;\n    printf(\"loading dictionary %s \\n\", dictFileName);\n    void* const dictBuffer = loadFile_orDie(dictFileName, &dictSize);\n    ZSTD_DDict* const ddict = ZSTD_createDDict(dictBuffer, dictSize);\n    if (ddict==NULL) { fprintf(stderr, \"ZSTD_createDDict error \\n\"); exit(5); }\n    free(dictBuffer);\n    return ddict;\n}", "path": "MMseqs2/lib/zstd/examples/dictionary_decompression.c", "commit_date": "2018-12-05 00:00:00", "repo_name": "soedinglab/MMseqs2", "stars": 1208, "license": "gpl-3.0", "language": "c", "size": 31120}
{"docstring": "/* print nastygram and leave */\n", "func_signal": "local void quit(char *why)", "code": "{\n    fprintf(stderr, \"fitblk abort: %s\\n\", why);\n    exit(1);\n}", "path": "MMseqs2/lib/zstd/zlibWrapper/examples/fitblk.c", "commit_date": "2018-12-05 00:00:00", "repo_name": "soedinglab/MMseqs2", "stars": 1208, "license": "gpl-3.0", "language": "c", "size": 31120}
{"docstring": "/* fake FSE_CTable, for raw (uncompressed) input */\n", "func_signal": "size_t FSE_buildCTable_raw (FSE_CTable* ct, unsigned nbBits)", "code": "{\n    const unsigned tableSize = 1 << nbBits;\n    const unsigned tableMask = tableSize - 1;\n    const unsigned maxSymbolValue = tableMask;\n    void* const ptr = ct;\n    U16* const tableU16 = ( (U16*) ptr) + 2;\n    void* const FSCT = ((U32*)ptr) + 1 /* header */ + (tableSize>>1);   /* assumption : tableLog >= 1 */\n    FSE_symbolCompressionTransform* const symbolTT = (FSE_symbolCompressionTransform*) (FSCT);\n    unsigned s;\n\n    /* Sanity checks */\n    if (nbBits < 1) return ERROR(GENERIC);             /* min size */\n\n    /* header */\n    tableU16[-2] = (U16) nbBits;\n    tableU16[-1] = (U16) maxSymbolValue;\n\n    /* Build table */\n    for (s=0; s<tableSize; s++)\n        tableU16[s] = (U16)(tableSize + s);\n\n    /* Build Symbol Transformation Table */\n    {   const U32 deltaNbBits = (nbBits << 16) - (1 << nbBits);\n        for (s=0; s<=maxSymbolValue; s++) {\n            symbolTT[s].deltaNbBits = deltaNbBits;\n            symbolTT[s].deltaFindState = s-1;\n    }   }\n\n    return 0;\n}", "path": "MMseqs2/lib/zstd/lib/compress/fse_compress.c", "commit_date": "2018-12-05 00:00:00", "repo_name": "soedinglab/MMseqs2", "stars": 1208, "license": "gpl-3.0", "language": "c", "size": 31120}
{"docstring": "// Get negative value: out = -in\n// Requires in[i] < 2^63,\n// ensures out[0] < 2^56, out[1] < 2^56, out[2] < 2^56, out[3] <= 2^56 + 2^16\n", "func_signal": "static void p224_felem_neg(p224_felem out, const p224_felem in)", "code": "{\n  p224_widefelem tmp = {0};\n  p224_felem_diff_128_64(tmp, in);\n  p224_felem_reduce(out, tmp);\n}", "path": "boringssl/crypto/fipsmodule/ec/p224-64.c", "commit_date": "2020-06-30 00:00:00", "repo_name": "google/boringssl", "stars": 1666, "license": "other", "language": "c", "size": 325672}
{"docstring": "// p224_get_bit returns the |i|th bit in |in|\n", "func_signal": "static crypto_word_t p224_get_bit(const p224_felem_bytearray in, size_t i)", "code": "{\n  if (i >= 224) {\n    return 0;\n  }\n  return (in[i >> 3] >> (i & 7)) & 1;\n}", "path": "boringssl/crypto/fipsmodule/ec/p224-64.c", "commit_date": "2020-06-30 00:00:00", "repo_name": "google/boringssl", "stars": 1666, "license": "other", "language": "c", "size": 325672}
{"docstring": "// Zero-check: returns 1 if input is 0, and 0 otherwise. We know that field\n// elements are reduced to in < 2^225, so we only need to check three cases: 0,\n// 2^224 - 2^96 + 1, and 2^225 - 2^97 + 2\n", "func_signal": "static p224_limb p224_felem_is_zero(const p224_felem in)", "code": "{\n  p224_limb zero = in[0] | in[1] | in[2] | in[3];\n  zero = (((int64_t)(zero)-1) >> 63) & 1;\n\n  p224_limb two224m96p1 = (in[0] ^ 1) | (in[1] ^ 0x00ffff0000000000) |\n                     (in[2] ^ 0x00ffffffffffffff) |\n                     (in[3] ^ 0x00ffffffffffffff);\n  two224m96p1 = (((int64_t)(two224m96p1)-1) >> 63) & 1;\n  p224_limb two225m97p2 = (in[0] ^ 2) | (in[1] ^ 0x00fffe0000000000) |\n                     (in[2] ^ 0x00ffffffffffffff) |\n                     (in[3] ^ 0x01ffffffffffffff);\n  two225m97p2 = (((int64_t)(two225m97p2)-1) >> 63) & 1;\n  return (zero | two224m96p1 | two225m97p2);\n}", "path": "boringssl/crypto/fipsmodule/ec/p224-64.c", "commit_date": "2020-06-30 00:00:00", "repo_name": "google/boringssl", "stars": 1666, "license": "other", "language": "c", "size": 325672}
{"docstring": "// rand_get_seed fills |seed| with entropy and sets |*out_used_cpu| to one if\n// that entropy came directly from the CPU and zero otherwise.\n", "func_signal": "static void rand_get_seed(struct rand_thread_state *state,\n                          uint8_t seed[CTR_DRBG_ENTROPY_LEN],\n                          int *out_used_cpu)", "code": "{\n  // If not in FIPS mode, we don't overread from the system entropy source and\n  // we don't depend only on the hardware RDRAND.\n  CRYPTO_sysrand(seed, CTR_DRBG_ENTROPY_LEN);\n  *out_used_cpu = 0;\n}", "path": "boringssl/crypto/fipsmodule/rand/rand.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "google/boringssl", "stars": 1666, "license": "other", "language": "c", "size": 325672}
{"docstring": "// Subtract field elements: out -= in\n// Assumes in[i] < 2^57\n", "func_signal": "static void p224_felem_diff(p224_felem out, const p224_felem in)", "code": "{\n  static const p224_limb two58p2 =\n      (((p224_limb)1) << 58) + (((p224_limb)1) << 2);\n  static const p224_limb two58m2 =\n      (((p224_limb)1) << 58) - (((p224_limb)1) << 2);\n  static const p224_limb two58m42m2 =\n      (((p224_limb)1) << 58) - (((p224_limb)1) << 42) - (((p224_limb)1) << 2);\n\n  // Add 0 mod 2^224-2^96+1 to ensure out > in\n  out[0] += two58p2;\n  out[1] += two58m42m2;\n  out[2] += two58m2;\n  out[3] += two58m2;\n\n  out[0] -= in[0];\n  out[1] -= in[1];\n  out[2] -= in[2];\n  out[3] -= in[3];\n}", "path": "boringssl/crypto/fipsmodule/ec/p224-64.c", "commit_date": "2020-06-30 00:00:00", "repo_name": "google/boringssl", "stars": 1666, "license": "other", "language": "c", "size": 325672}
{"docstring": "// Multiply an unreduced field element by a scalar: out = out * scalar\n// The scalars we actually use are small, so results fit without overflow\n", "func_signal": "static void p224_widefelem_scalar(p224_widefelem out,\n                                  const p224_widelimb scalar)", "code": "{\n  out[0] *= scalar;\n  out[1] *= scalar;\n  out[2] *= scalar;\n  out[3] *= scalar;\n  out[4] *= scalar;\n  out[5] *= scalar;\n  out[6] *= scalar;\n}", "path": "boringssl/crypto/fipsmodule/ec/p224-64.c", "commit_date": "2020-06-30 00:00:00", "repo_name": "google/boringssl", "stars": 1666, "license": "other", "language": "c", "size": 325672}
{"docstring": "// Helper functions to convert field elements to/from internal representation\n", "func_signal": "static void p224_bin28_to_felem(p224_felem out, const uint8_t in[28])", "code": "{\n  out[0] = p224_load_u64(in) & 0x00ffffffffffffff;\n  out[1] = p224_load_u64(in + 7) & 0x00ffffffffffffff;\n  out[2] = p224_load_u64(in + 14) & 0x00ffffffffffffff;\n  out[3] = p224_load_u64(in + 20) >> 8;\n}", "path": "boringssl/crypto/fipsmodule/ec/p224-64.c", "commit_date": "2020-06-30 00:00:00", "repo_name": "google/boringssl", "stars": 1666, "license": "other", "language": "c", "size": 325672}
{"docstring": "// Field operations, using the internal representation of field elements.\n// NB! These operations are specific to our point multiplication and cannot be\n// expected to be correct in general - e.g., multiplication with a large scalar\n// will cause an overflow.\n", "func_signal": "static void p224_felem_assign(p224_felem out, const p224_felem in)", "code": "{\n  out[0] = in[0];\n  out[1] = in[1];\n  out[2] = in[2];\n  out[3] = in[3];\n}", "path": "boringssl/crypto/fipsmodule/ec/p224-64.c", "commit_date": "2020-06-30 00:00:00", "repo_name": "google/boringssl", "stars": 1666, "license": "other", "language": "c", "size": 325672}
{"docstring": "// rdrand should only be called if either |have_rdrand| or |have_fast_rdrand|\n// returned true.\n", "func_signal": "static int rdrand(uint8_t *buf, const size_t len)", "code": "{\n  const size_t len_multiple8 = len & ~7;\n  if (!CRYPTO_rdrand_multiple8_buf(buf, len_multiple8)) {\n    return 0;\n  }\n  const size_t remainder = len - len_multiple8;\n\n  if (remainder != 0) {\n    assert(remainder < 8);\n\n    uint8_t rand_buf[8];\n    if (!CRYPTO_rdrand(rand_buf)) {\n      return 0;\n    }\n    OPENSSL_memcpy(buf + len_multiple8, rand_buf, remainder);\n  }\n\n  return 1;\n}", "path": "boringssl/crypto/fipsmodule/rand/rand.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "google/boringssl", "stars": 1666, "license": "other", "language": "c", "size": 325672}
{"docstring": "// fiat_p256_get_bit returns the |i|th bit in |in|\n", "func_signal": "static crypto_word_t fiat_p256_get_bit(const uint8_t *in, int i)", "code": "{\n  if (i < 0 || i >= 256) {\n    return 0;\n  }\n  return (in[i >> 3] >> (i & 7)) & 1;\n}", "path": "boringssl/crypto/fipsmodule/ec/p256.c", "commit_date": "2020-06-30 00:00:00", "repo_name": "google/boringssl", "stars": 1666, "license": "other", "language": "c", "size": 325672}
{"docstring": "// fiat_p256_point_double calculates 2*(x_in, y_in, z_in)\n//\n// The method is taken from:\n//   http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b\n//\n// Coq transcription and correctness proof:\n// <https://github.com/mit-plv/fiat-crypto/blob/79f8b5f39ed609339f0233098dee1a3c4e6b3080/src/Curves/Weierstrass/Jacobian.v#L93>\n// <https://github.com/mit-plv/fiat-crypto/blob/79f8b5f39ed609339f0233098dee1a3c4e6b3080/src/Curves/Weierstrass/Jacobian.v#L201>\n//\n// Outputs can equal corresponding inputs, i.e., x_out == x_in is allowed.\n// while x_out == y_in is not (maybe this works, but it's not tested).\n", "func_signal": "static void fiat_p256_point_double(fiat_p256_felem x_out, fiat_p256_felem y_out,\n                                   fiat_p256_felem z_out,\n                                   const fiat_p256_felem x_in,\n                                   const fiat_p256_felem y_in,\n                                   const fiat_p256_felem z_in)", "code": "{\n  fiat_p256_felem delta, gamma, beta, ftmp, ftmp2, tmptmp, alpha, fourbeta;\n  // delta = z^2\n  fiat_p256_square(delta, z_in);\n  // gamma = y^2\n  fiat_p256_square(gamma, y_in);\n  // beta = x*gamma\n  fiat_p256_mul(beta, x_in, gamma);\n\n  // alpha = 3*(x-delta)*(x+delta)\n  fiat_p256_sub(ftmp, x_in, delta);\n  fiat_p256_add(ftmp2, x_in, delta);\n\n  fiat_p256_add(tmptmp, ftmp2, ftmp2);\n  fiat_p256_add(ftmp2, ftmp2, tmptmp);\n  fiat_p256_mul(alpha, ftmp, ftmp2);\n\n  // x' = alpha^2 - 8*beta\n  fiat_p256_square(x_out, alpha);\n  fiat_p256_add(fourbeta, beta, beta);\n  fiat_p256_add(fourbeta, fourbeta, fourbeta);\n  fiat_p256_add(tmptmp, fourbeta, fourbeta);\n  fiat_p256_sub(x_out, x_out, tmptmp);\n\n  // z' = (y + z)^2 - gamma - delta\n  fiat_p256_add(delta, gamma, delta);\n  fiat_p256_add(ftmp, y_in, z_in);\n  fiat_p256_square(z_out, ftmp);\n  fiat_p256_sub(z_out, z_out, delta);\n\n  // y' = alpha*(4*beta - x') - 8*gamma^2\n  fiat_p256_sub(y_out, fourbeta, x_out);\n  fiat_p256_add(gamma, gamma, gamma);\n  fiat_p256_square(gamma, gamma);\n  fiat_p256_mul(y_out, alpha, y_out);\n  fiat_p256_add(gamma, gamma, gamma);\n  fiat_p256_sub(y_out, y_out, gamma);\n}", "path": "boringssl/crypto/fipsmodule/ec/p256.c", "commit_date": "2020-06-30 00:00:00", "repo_name": "google/boringssl", "stars": 1666, "license": "other", "language": "c", "size": 325672}
{"docstring": "// Multiply a field element by a scalar: out = out * scalar\n// The scalars we actually use are small, so results fit without overflow\n", "func_signal": "static void p224_felem_scalar(p224_felem out, const p224_limb scalar)", "code": "{\n  out[0] *= scalar;\n  out[1] *= scalar;\n  out[2] *= scalar;\n  out[3] *= scalar;\n}", "path": "boringssl/crypto/fipsmodule/ec/p224-64.c", "commit_date": "2020-06-30 00:00:00", "repo_name": "google/boringssl", "stars": 1666, "license": "other", "language": "c", "size": 325672}
{"docstring": "// Requires 0 <= in < 2*p (always call p224_felem_reduce first)\n", "func_signal": "static void p224_felem_to_generic(EC_FELEM *out, const p224_felem in)", "code": "{\n  // Reduce to unique minimal representation.\n  static const int64_t two56 = ((p224_limb)1) << 56;\n  // 0 <= in < 2*p, p = 2^224 - 2^96 + 1\n  // if in > p , reduce in = in - 2^224 + 2^96 - 1\n  int64_t tmp[4], a;\n  tmp[0] = in[0];\n  tmp[1] = in[1];\n  tmp[2] = in[2];\n  tmp[3] = in[3];\n  // Case 1: a = 1 iff in >= 2^224\n  a = (in[3] >> 56);\n  tmp[0] -= a;\n  tmp[1] += a << 40;\n  tmp[3] &= 0x00ffffffffffffff;\n  // Case 2: a = 0 iff p <= in < 2^224, i.e., the high 128 bits are all 1 and\n  // the lower part is non-zero\n  a = ((in[3] & in[2] & (in[1] | 0x000000ffffffffff)) + 1) |\n      (((int64_t)(in[0] + (in[1] & 0x000000ffffffffff)) - 1) >> 63);\n  a &= 0x00ffffffffffffff;\n  // turn a into an all-one mask (if a = 0) or an all-zero mask\n  a = (a - 1) >> 63;\n  // subtract 2^224 - 2^96 + 1 if a is all-one\n  tmp[3] &= a ^ 0xffffffffffffffff;\n  tmp[2] &= a ^ 0xffffffffffffffff;\n  tmp[1] &= (a ^ 0xffffffffffffffff) | 0x000000ffffffffff;\n  tmp[0] -= 1 & a;\n\n  // eliminate negative coefficients: if tmp[0] is negative, tmp[1] must\n  // be non-zero, so we only need one step\n  a = tmp[0] >> 63;\n  tmp[0] += two56 & a;\n  tmp[1] -= 1 & a;\n\n  // carry 1 -> 2 -> 3\n  tmp[2] += tmp[1] >> 56;\n  tmp[1] &= 0x00ffffffffffffff;\n\n  tmp[3] += tmp[2] >> 56;\n  tmp[2] &= 0x00ffffffffffffff;\n\n  // Now 0 <= tmp < p\n  p224_felem tmp2;\n  tmp2[0] = tmp[0];\n  tmp2[1] = tmp[1];\n  tmp2[2] = tmp[2];\n  tmp2[3] = tmp[3];\n\n  p224_felem_to_bin28(out->bytes, tmp2);\n  // 224 is not a multiple of 64, so zero the remaining bytes.\n  OPENSSL_memset(out->bytes + 28, 0, 32 - 28);\n}", "path": "boringssl/crypto/fipsmodule/ec/p224-64.c", "commit_date": "2020-06-30 00:00:00", "repo_name": "google/boringssl", "stars": 1666, "license": "other", "language": "c", "size": 325672}
{"docstring": "// Double an elliptic curve point:\n// (X', Y', Z') = 2 * (X, Y, Z), where\n// X' = (3 * (X - Z^2) * (X + Z^2))^2 - 8 * X * Y^2\n// Y' = 3 * (X - Z^2) * (X + Z^2) * (4 * X * Y^2 - X') - 8 * Y^2\n// Z' = (Y + Z)^2 - Y^2 - Z^2 = 2 * Y * Z\n// Outputs can equal corresponding inputs, i.e., x_out == x_in is allowed,\n// while x_out == y_in is not (maybe this works, but it's not tested).\n", "func_signal": "static void p224_point_double(p224_felem x_out, p224_felem y_out,\n                              p224_felem z_out, const p224_felem x_in,\n                              const p224_felem y_in, const p224_felem z_in)", "code": "{\n  p224_widefelem tmp, tmp2;\n  p224_felem delta, gamma, beta, alpha, ftmp, ftmp2;\n\n  p224_felem_assign(ftmp, x_in);\n  p224_felem_assign(ftmp2, x_in);\n\n  // delta = z^2\n  p224_felem_square(tmp, z_in);\n  p224_felem_reduce(delta, tmp);\n\n  // gamma = y^2\n  p224_felem_square(tmp, y_in);\n  p224_felem_reduce(gamma, tmp);\n\n  // beta = x*gamma\n  p224_felem_mul(tmp, x_in, gamma);\n  p224_felem_reduce(beta, tmp);\n\n  // alpha = 3*(x-delta)*(x+delta)\n  p224_felem_diff(ftmp, delta);\n  // ftmp[i] < 2^57 + 2^58 + 2 < 2^59\n  p224_felem_sum(ftmp2, delta);\n  // ftmp2[i] < 2^57 + 2^57 = 2^58\n  p224_felem_scalar(ftmp2, 3);\n  // ftmp2[i] < 3 * 2^58 < 2^60\n  p224_felem_mul(tmp, ftmp, ftmp2);\n  // tmp[i] < 2^60 * 2^59 * 4 = 2^121\n  p224_felem_reduce(alpha, tmp);\n\n  // x' = alpha^2 - 8*beta\n  p224_felem_square(tmp, alpha);\n  // tmp[i] < 4 * 2^57 * 2^57 = 2^116\n  p224_felem_assign(ftmp, beta);\n  p224_felem_scalar(ftmp, 8);\n  // ftmp[i] < 8 * 2^57 = 2^60\n  p224_felem_diff_128_64(tmp, ftmp);\n  // tmp[i] < 2^116 + 2^64 + 8 < 2^117\n  p224_felem_reduce(x_out, tmp);\n\n  // z' = (y + z)^2 - gamma - delta\n  p224_felem_sum(delta, gamma);\n  // delta[i] < 2^57 + 2^57 = 2^58\n  p224_felem_assign(ftmp, y_in);\n  p224_felem_sum(ftmp, z_in);\n  // ftmp[i] < 2^57 + 2^57 = 2^58\n  p224_felem_square(tmp, ftmp);\n  // tmp[i] < 4 * 2^58 * 2^58 = 2^118\n  p224_felem_diff_128_64(tmp, delta);\n  // tmp[i] < 2^118 + 2^64 + 8 < 2^119\n  p224_felem_reduce(z_out, tmp);\n\n  // y' = alpha*(4*beta - x') - 8*gamma^2\n  p224_felem_scalar(beta, 4);\n  // beta[i] < 4 * 2^57 = 2^59\n  p224_felem_diff(beta, x_out);\n  // beta[i] < 2^59 + 2^58 + 2 < 2^60\n  p224_felem_mul(tmp, alpha, beta);\n  // tmp[i] < 4 * 2^57 * 2^60 = 2^119\n  p224_felem_square(tmp2, gamma);\n  // tmp2[i] < 4 * 2^57 * 2^57 = 2^116\n  p224_widefelem_scalar(tmp2, 8);\n  // tmp2[i] < 8 * 2^116 = 2^119\n  p224_widefelem_diff(tmp, tmp2);\n  // tmp[i] < 2^119 + 2^120 < 2^121\n  p224_felem_reduce(y_out, tmp);\n}", "path": "boringssl/crypto/fipsmodule/ec/p224-64.c", "commit_date": "2020-06-30 00:00:00", "repo_name": "google/boringssl", "stars": 1666, "license": "other", "language": "c", "size": 325672}
{"docstring": "// This file implements the wNAF-based interleaving multi-exponentiation method\n// at:\n//   http://link.springer.com/chapter/10.1007%2F3-540-45537-X_13\n//   http://www.bmoeller.de/pdf/TI-01-08.multiexp.pdf\n", "func_signal": "void ec_compute_wNAF(const EC_GROUP *group, int8_t *out,\n                     const EC_SCALAR *scalar, size_t bits, int w)", "code": "{\n  // 'int8_t' can represent integers with absolute values less than 2^7.\n  assert(0 < w && w <= 7);\n  assert(bits != 0);\n  int bit = 1 << w;         // 2^w, at most 128\n  int next_bit = bit << 1;  // 2^(w+1), at most 256\n  int mask = next_bit - 1;  // at most 255\n\n  int window_val = scalar->words[0] & mask;\n  for (size_t j = 0; j < bits + 1; j++) {\n    assert(0 <= window_val && window_val <= next_bit);\n    int digit = 0;\n    if (window_val & 1) {\n      assert(0 < window_val && window_val < next_bit);\n      if (window_val & bit) {\n        digit = window_val - next_bit;\n        // We know -next_bit < digit < 0 and window_val - digit = next_bit.\n\n        // modified wNAF\n        if (j + w + 1 >= bits) {\n          // special case for generating modified wNAFs:\n          // no new bits will be added into window_val,\n          // so using a positive digit here will decrease\n          // the total length of the representation\n\n          digit = window_val & (mask >> 1);\n          // We know 0 < digit < bit and window_val - digit = bit.\n        }\n      } else {\n        digit = window_val;\n        // We know 0 < digit < bit and window_val - digit = 0.\n      }\n\n      window_val -= digit;\n\n      // Now window_val is 0 or 2^(w+1) in standard wNAF generation.\n      // For modified window NAFs, it may also be 2^w.\n      //\n      // See the comments above for the derivation of each of these bounds.\n      assert(window_val == 0 || window_val == next_bit || window_val == bit);\n      assert(-bit < digit && digit < bit);\n\n      // window_val was odd, so digit is also odd.\n      assert(digit & 1);\n    }\n\n    out[j] = digit;\n\n    // Incorporate the next bit. Previously, |window_val| <= |next_bit|, so if\n    // we shift and add at most one copy of |bit|, this will continue to hold\n    // afterwards.\n    window_val >>= 1;\n    window_val +=\n        bit * bn_is_bit_set_words(scalar->words, group->order.width, j + w + 1);\n    assert(window_val <= next_bit);\n  }\n\n  // bits + 1 entries should be sufficient to consume all bits.\n  assert(window_val == 0);\n}", "path": "boringssl/crypto/fipsmodule/ec/wnaf.c", "commit_date": "2020-05-14 00:00:00", "repo_name": "google/boringssl", "stars": 1666, "license": "other", "language": "c", "size": 325672}
{"docstring": "// compute_precomp sets |out[i]| to (2*i+1)*p, for i from 0 to |len|.\n", "func_signal": "static void compute_precomp(const EC_GROUP *group, EC_RAW_POINT *out,\n                            const EC_RAW_POINT *p, size_t len)", "code": "{\n  ec_GFp_simple_point_copy(&out[0], p);\n  EC_RAW_POINT two_p;\n  ec_GFp_mont_dbl(group, &two_p, p);\n  for (size_t i = 1; i < len; i++) {\n    ec_GFp_mont_add(group, &out[i], &out[i - 1], &two_p);\n  }\n}", "path": "boringssl/crypto/fipsmodule/ec/wnaf.c", "commit_date": "2020-05-14 00:00:00", "repo_name": "google/boringssl", "stars": 1666, "license": "other", "language": "c", "size": 325672}
{"docstring": "// Square a field element: out = in^2\n", "func_signal": "static void p224_felem_square(p224_widefelem out, const p224_felem in)", "code": "{\n  p224_limb tmp0, tmp1, tmp2;\n  tmp0 = 2 * in[0];\n  tmp1 = 2 * in[1];\n  tmp2 = 2 * in[2];\n  out[0] = ((p224_widelimb)in[0]) * in[0];\n  out[1] = ((p224_widelimb)in[0]) * tmp1;\n  out[2] = ((p224_widelimb)in[0]) * tmp2 + ((p224_widelimb)in[1]) * in[1];\n  out[3] = ((p224_widelimb)in[3]) * tmp0 + ((p224_widelimb)in[1]) * tmp2;\n  out[4] = ((p224_widelimb)in[3]) * tmp1 + ((p224_widelimb)in[2]) * in[2];\n  out[5] = ((p224_widelimb)in[3]) * tmp2;\n  out[6] = ((p224_widelimb)in[3]) * in[3];\n}", "path": "boringssl/crypto/fipsmodule/ec/p224-64.c", "commit_date": "2020-06-30 00:00:00", "repo_name": "google/boringssl", "stars": 1666, "license": "other", "language": "c", "size": 325672}
{"docstring": "// Reduce seven 128-bit coefficients to four 64-bit coefficients.\n// Requires in[i] < 2^126,\n// ensures out[0] < 2^56, out[1] < 2^56, out[2] < 2^56, out[3] <= 2^56 + 2^16\n", "func_signal": "static void p224_felem_reduce(p224_felem out, const p224_widefelem in)", "code": "{\n  static const p224_widelimb two127p15 =\n      (((p224_widelimb)1) << 127) + (((p224_widelimb)1) << 15);\n  static const p224_widelimb two127m71 =\n      (((p224_widelimb)1) << 127) - (((p224_widelimb)1) << 71);\n  static const p224_widelimb two127m71m55 = (((p224_widelimb)1) << 127) -\n                                            (((p224_widelimb)1) << 71) -\n                                            (((p224_widelimb)1) << 55);\n  p224_widelimb output[5];\n\n  // Add 0 mod 2^224-2^96+1 to ensure all differences are positive\n  output[0] = in[0] + two127p15;\n  output[1] = in[1] + two127m71m55;\n  output[2] = in[2] + two127m71;\n  output[3] = in[3];\n  output[4] = in[4];\n\n  // Eliminate in[4], in[5], in[6]\n  output[4] += in[6] >> 16;\n  output[3] += (in[6] & 0xffff) << 40;\n  output[2] -= in[6];\n\n  output[3] += in[5] >> 16;\n  output[2] += (in[5] & 0xffff) << 40;\n  output[1] -= in[5];\n\n  output[2] += output[4] >> 16;\n  output[1] += (output[4] & 0xffff) << 40;\n  output[0] -= output[4];\n\n  // Carry 2 -> 3 -> 4\n  output[3] += output[2] >> 56;\n  output[2] &= 0x00ffffffffffffff;\n\n  output[4] = output[3] >> 56;\n  output[3] &= 0x00ffffffffffffff;\n\n  // Now output[2] < 2^56, output[3] < 2^56, output[4] < 2^72\n\n  // Eliminate output[4]\n  output[2] += output[4] >> 16;\n  // output[2] < 2^56 + 2^56 = 2^57\n  output[1] += (output[4] & 0xffff) << 40;\n  output[0] -= output[4];\n\n  // Carry 0 -> 1 -> 2 -> 3\n  output[1] += output[0] >> 56;\n  out[0] = output[0] & 0x00ffffffffffffff;\n\n  output[2] += output[1] >> 56;\n  // output[2] < 2^57 + 2^72\n  out[1] = output[1] & 0x00ffffffffffffff;\n  output[3] += output[2] >> 56;\n  // output[3] <= 2^56 + 2^16\n  out[2] = output[2] & 0x00ffffffffffffff;\n\n  // out[0] < 2^56, out[1] < 2^56, out[2] < 2^56,\n  // out[3] <= 2^56 + 2^16 (due to final carry),\n  // so out < 2*p\n  out[3] = output[3];\n}", "path": "boringssl/crypto/fipsmodule/ec/p224-64.c", "commit_date": "2020-06-30 00:00:00", "repo_name": "google/boringssl", "stars": 1666, "license": "other", "language": "c", "size": 325672}
{"docstring": "// rand_thread_state_free frees a |rand_thread_state|. This is called when a\n// thread exits.\n", "func_signal": "static void rand_thread_state_free(void *state_in)", "code": "{\n  struct rand_thread_state *state = state_in;\n\n  if (state_in == NULL) {\n    return;\n  }\n\n#if defined(BORINGSSL_FIPS)\n  CRYPTO_STATIC_MUTEX_lock_write(thread_states_list_lock_bss_get());\n\n  if (state->prev != NULL) {\n    state->prev->next = state->next;\n  } else {\n    *thread_states_list_bss_get() = state->next;\n  }\n\n  if (state->next != NULL) {\n    state->next->prev = state->prev;\n  }\n\n  CRYPTO_STATIC_MUTEX_unlock_write(thread_states_list_lock_bss_get());\n\n  CTR_DRBG_clear(&state->drbg);\n#endif\n\n  OPENSSL_free(state);\n}", "path": "boringssl/crypto/fipsmodule/rand/rand.c", "commit_date": "2020-12-10 00:00:00", "repo_name": "google/boringssl", "stars": 1666, "license": "other", "language": "c", "size": 325672}
{"docstring": "/* Return 1 if the character is permitted in a PrintableString */\n", "func_signal": "static int is_printable(uint32_t value)", "code": "{\n    int ch;\n    if (value > 0x7f)\n        return 0;\n    ch = (int)value;\n    /*\n     * Note: we can't use 'isalnum' because certain accented characters may\n     * count as alphanumeric in some environments.\n     */\n    if ((ch >= 'a') && (ch <= 'z'))\n        return 1;\n    if ((ch >= 'A') && (ch <= 'Z'))\n        return 1;\n    if ((ch >= '0') && (ch <= '9'))\n        return 1;\n    if ((ch == ' ') || strchr(\"'()+,-./:=?\", ch))\n        return 1;\n    return 0;\n}", "path": "boringssl/crypto/asn1/a_mbstr.c", "commit_date": "2018-05-11 00:00:00", "repo_name": "google/boringssl", "stars": 1666, "license": "other", "language": "c", "size": 325672}
{"docstring": "/**\n  Append a single tile to the copy buffer.\n****************************************************************************/\n", "func_signal": "void edit_buffer_copy(struct edit_buffer *ebuf, const struct tile *ptile)", "code": "{\n  struct tile *vtile;\n  struct unit *vunit;\n  bool copied = FALSE;\n\n  if (!ebuf || !ptile) {\n    return;\n  }\n\n  vtile = tile_virtual_new(NULL);\n  vtile->index = tile_index(ptile);\n\n  edit_buffer_type_iterate(ebuf, type) {\n    switch (type) {\n    case EBT_TERRAIN:\n      if (tile_terrain(ptile)) {\n        tile_set_terrain(vtile, tile_terrain(ptile));\n        copied = TRUE;\n      }\n      break;\n    case EBT_RESOURCE:\n      if (tile_resource(ptile)) {\n        tile_set_resource(vtile, tile_resource(ptile));\n        copied = TRUE;\n      }\n      break;\n    case EBT_SPECIAL:\n      extra_type_by_cause_iterate(EC_SPECIAL, pextra) {\n        if (tile_has_extra(ptile, pextra)) {\n          tile_add_extra(vtile, pextra);\n          copied = TRUE;\n        }\n      } extra_type_by_cause_iterate_end;\n      break;\n    case EBT_BASE:\n      extra_type_iterate(pextra) {\n        if (tile_has_extra(ptile, pextra)\n            && is_extra_caused_by(pextra, EC_BASE)) {\n          tile_add_extra(vtile, pextra);\n          copied = TRUE;\n        }\n      } extra_type_iterate_end;\n      break;\n    case EBT_ROAD:\n      extra_type_iterate(pextra) {\n        if (tile_has_extra(ptile, pextra)\n            && is_extra_caused_by(pextra, EC_ROAD)) {\n          tile_add_extra(vtile, pextra);\n          copied = TRUE;\n        }\n      } extra_type_iterate_end;\n      break;\n    case EBT_UNIT:\n      unit_list_iterate(ptile->units, punit) {\n        if (!punit) {\n          continue;\n        }\n        vunit = unit_virtual_create(unit_owner(punit), NULL,\n                                    unit_type_get(punit), punit->veteran);\n        vunit->homecity = punit->homecity;\n        vunit->hp = punit->hp;\n        unit_list_append(vtile->units, vunit);\n        copied = TRUE;\n      } unit_list_iterate_end;\n      break;\n    case EBT_CITY:\n      if (tile_city(ptile)) {\n        struct city *pcity, *vcity;\n        char name[MAX_LEN_NAME];\n\n        pcity = tile_city(ptile);\n        fc_snprintf(name, sizeof(name), \"Copy of %s\",\n                    city_name_get(pcity));\n        vcity = create_city_virtual(city_owner(pcity), NULL, name);\n        city_size_set(vcity, city_size_get(pcity));\n        improvement_iterate(pimprove) {\n          if (!is_improvement(pimprove)\n              || !city_has_building(pcity, pimprove)) {\n            continue;\n          }\n          city_add_improvement(vcity, pimprove);\n        } improvement_iterate_end;\n        tile_set_worked(vtile, vcity);\n        copied = TRUE;\n      }\n      break;\n    default:\n      break;\n    }\n  } edit_buffer_type_iterate_end;\n\n  if (copied) {\n    tile_list_append(ebuf->vtiles, vtile);\n  } else {\n    tile_virtual_destroy(vtile);\n  }\n}", "path": "freeciv/client/editor.c", "commit_date": "2020-02-24 00:00:00", "repo_name": "freeciv/freeciv", "stars": 1168, "license": "gpl-2.0", "language": "c", "size": 909621}
{"docstring": "/**\n  Handle a request to edit the properties for the given tile. If the tile\n  is part of a selection, then all selected tiles are passed to the\n  property editor.\n****************************************************************************/\n", "func_signal": "static void popup_properties(struct tile *ptile)", "code": "{\n  struct tile_list *tiles;\n\n  if (!ptile) {\n    return;\n  }\n\n  tiles = tile_list_new();\n\n  if (editor_tile_is_selected(ptile)) {\n    tile_hash_iterate(editor->selected_tile_table, sel_tile) {\n      if (can_edit_tile_properties(sel_tile)) {\n        tile_list_append(tiles, sel_tile);\n      }\n    } tile_hash_iterate_end;\n  } else {\n    if (can_edit_tile_properties(ptile)) {\n      tile_list_append(tiles, ptile);\n    }\n  }\n\n  editgui_popup_properties(tiles, NUM_OBJTYPES);\n\n  tile_list_destroy(tiles);\n}", "path": "freeciv/client/editor.c", "commit_date": "2020-02-24 00:00:00", "repo_name": "freeciv/freeciv", "stars": 1168, "license": "gpl-2.0", "language": "c", "size": 909621}
{"docstring": "/**\n  Helper function to fill in an edit packet with the tile's current values.\n****************************************************************************/\n", "func_signal": "static void fill_tile_edit_packet(struct packet_edit_tile *packet,\n                                  const struct tile *ptile)", "code": "{\n  const struct extra_type *presource;\n  const struct terrain *pterrain;\n\n  if (!packet || !ptile) {\n    return;\n  }\n  packet->tile = tile_index(ptile);\n  packet->extras = *tile_extras(ptile);\n\n  presource = tile_resource(ptile);\n  packet->resource = presource\n                     ? extra_number(presource)\n                     : extra_count();\n\n  pterrain = tile_terrain(ptile);\n  packet->terrain = pterrain\n                    ? terrain_number(pterrain)\n                    : terrain_count();\n  if (ptile->extras_owner != NULL) {\n    packet->eowner = player_number(ptile->extras_owner);\n  } else {\n    packet->eowner = MAP_TILE_OWNER_NULL;\n  }\n\n  if (ptile->label == NULL) {\n    packet->label[0] = '\\0';\n  } else {\n    sz_strlcpy(packet->label, ptile->label);\n  }\n}", "path": "freeciv/client/editor.c", "commit_date": "2020-02-24 00:00:00", "repo_name": "freeciv/freeciv", "stars": 1168, "license": "gpl-2.0", "language": "c", "size": 909621}
{"docstring": "/**\n  Returns the 'count' parameter for the editor tool.\n****************************************************************************/\n", "func_signal": "int editor_tool_get_count(enum editor_tool_type ett)", "code": "{\n  if (!editor || !(ett < NUM_EDITOR_TOOL_TYPES)) {\n    return 1;\n  }\n  return editor->tools[ett].count;\n}", "path": "freeciv/client/editor.c", "commit_date": "2020-02-24 00:00:00", "repo_name": "freeciv/freeciv", "stars": 1168, "license": "gpl-2.0", "language": "c", "size": 909621}
{"docstring": "/**\n  Initialize editor tool data.\n****************************************************************************/\n", "func_signal": "static void tool_init(enum editor_tool_type ett, const char *name,\n                      int flags, const char *tooltip)", "code": "{\n  struct editor_tool *tool;\n\n  if (!editor || !(ett < NUM_EDITOR_TOOL_TYPES)) {\n    return;\n  }\n\n  tool = editor->tools + ett;\n\n  if (ett == ETT_COPYPASTE) {\n    tool->mode = ETM_COPY;\n  } else {\n    tool->mode = ETM_PAINT;\n  }\n  tool->name = name;\n  tool->flags = flags;\n  tool->tooltip = tooltip;\n  tool->size = 1;\n  tool->count = 1;\n  tool->applied_player_no = 0;\n\n  tool_set_init_value(ett);\n}", "path": "freeciv/client/editor.c", "commit_date": "2020-02-24 00:00:00", "repo_name": "freeciv/freeciv", "stars": 1168, "license": "gpl-2.0", "language": "c", "size": 909621}
{"docstring": "/**\n  Returns TRUE if the given tool type has sub-values (e.g. the terrain\n  tool has values corresponding to the terrain types).\n****************************************************************************/\n", "func_signal": "bool editor_tool_has_value(enum editor_tool_type ett)", "code": "{\n  if (!editor || !(ett < NUM_EDITOR_TOOL_TYPES)) {\n    return FALSE;\n  }\n  return editor->tools[ett].flags & ETF_HAS_VALUE;\n}", "path": "freeciv/client/editor.c", "commit_date": "2020-02-24 00:00:00", "repo_name": "freeciv/freeciv", "stars": 1168, "license": "gpl-2.0", "language": "c", "size": 909621}
{"docstring": "/**\n  Apply the current editor tool to the given tile. This function is\n  suitable to called over multiple tiles at once. Once the batch of\n  operations is finished you should call editor_notify_edit_finished.\n  The 'part_of_selection' parameter should be TRUE if the tool is\n  being applied to a tile from a selection.\n****************************************************************************/\n", "func_signal": "void editor_apply_tool(const struct tile *ptile,\n                       bool part_of_selection)", "code": "{\n  enum editor_tool_type ett;\n  enum editor_tool_mode etm;\n  int value, size, count, apno, tile, id;\n  bool erase;\n  struct connection *my_conn = &client.conn;\n\n  if (editor == NULL || ptile == NULL) {\n    return;\n  }\n\n  ett = editor_get_tool();\n  etm = editor_tool_get_mode(ett);\n  size = editor_tool_get_size(ett);\n  count = editor_tool_get_count(ett);\n  value = editor_tool_get_value(ett);\n  apno = editor_tool_get_applied_player(ett);\n\n  if (ett != ETT_VISION && !client_is_global_observer()\n      && client_has_player()\n      && tile_get_known(ptile, client_player()) == TILE_UNKNOWN) {\n    return;\n  }\n\n  if (editor_tool_has_applied_player(ett)\n      && player_by_number(apno) == NULL) {\n    return;\n  }\n\n  if (ett == ETT_COPYPASTE) {\n    struct edit_buffer *ebuf;\n    ebuf = editor_get_copy_buffer();\n    if (etm == ETM_COPY) {\n      if (part_of_selection) {\n        edit_buffer_copy(ebuf, ptile);\n      } else {\n        edit_buffer_clear(ebuf);\n        edit_buffer_copy_square(ebuf, ptile, size);\n        editgui_refresh();\n      }\n    } else if (etm == ETM_PAINT || etm == ETM_PASTE) {\n      edit_buffer_paste(ebuf, ptile);\n    }\n    return;\n  }\n\n  if (part_of_selection && ett != ETT_CITY) {\n    size = 1;\n  }\n\n  erase = (etm == ETM_ERASE);\n  tile = tile_index(ptile);\n\n  switch (ett) {\n\n  case ETT_TERRAIN:\n    dsend_packet_edit_tile_terrain(my_conn, tile, erase ? 0 : value, size);\n    break;\n\n  case ETT_TERRAIN_RESOURCE:\n  case ETT_TERRAIN_SPECIAL:\n  case ETT_ROAD:\n  case ETT_MILITARY_BASE:\n    dsend_packet_edit_tile_extra(my_conn, tile, value, erase, apno, size);\n    break;\n\n  case ETT_UNIT:\n    if (erase) {\n      dsend_packet_edit_unit_remove(my_conn, apno, tile, value, count);\n    } else {\n      dsend_packet_edit_unit_create(my_conn, apno, tile, value, count, 0);\n    }\n    break;\n\n  case ETT_CITY:\n    if (erase) {\n      struct city *pcity = tile_city(ptile);\n      if (pcity != NULL) {\n        id = pcity->id;\n        dsend_packet_edit_city_remove(my_conn, id);\n      }\n    } else {\n      dsend_packet_edit_city_create(my_conn, apno, tile, size, 0);\n    }\n    break;\n\n  case ETT_VISION:\n    if (client_has_player()) {\n      id = client_player_number();\n      dsend_packet_edit_player_vision(my_conn, id, tile, !erase, size);\n    }\n    break;\n\n  case ETT_STARTPOS:\n    dsend_packet_edit_startpos(my_conn, tile, erase, 0);\n    break;\n\n  default:\n    break;\n  }\n}", "path": "freeciv/client/editor.c", "commit_date": "2020-02-24 00:00:00", "repo_name": "freeciv/freeciv", "stars": 1168, "license": "gpl-2.0", "language": "c", "size": 909621}
{"docstring": "/**\n  Handle a change in the size of the selection rectangle. The given point\n  is the new extremity of the rectangle.\n****************************************************************************/\n", "func_signal": "static void editor_resize_selection_rectangle(int canvas_x, int canvas_y)", "code": "{\n  int xl, yt, xr, yb;\n\n  if (editor->selrect_start_x <= canvas_x) {\n    xl = editor->selrect_start_x;\n    xr = canvas_x;\n  } else {\n    xl = canvas_x;\n    xr = editor->selrect_start_x;\n  }\n\n  if (editor->selrect_start_y <= canvas_y) {\n    yt = editor->selrect_start_y;\n    yb = canvas_y;\n  } else {\n    yt = canvas_y;\n    yb = editor->selrect_start_y;\n  }\n\n  /* Erase the previously drawn rectangle. */\n  editor_draw_selrect();\n\n  if (xl == xr || yt == yb) {\n    editor->selrect_width = 0;\n    editor->selrect_height = 0;\n    return;\n  }\n\n  editor->selrect_x = xl;\n  editor->selrect_y = yt;\n  editor->selrect_width = xr - xl;\n  editor->selrect_height = yb - yt;\n\n  editor_draw_selrect();\n}", "path": "freeciv/client/editor.c", "commit_date": "2020-02-24 00:00:00", "repo_name": "freeciv/freeciv", "stars": 1168, "license": "gpl-2.0", "language": "c", "size": 909621}
{"docstring": "/**\n  Creates a virtual unit (like unit_virtual_create) based on the current\n  editor state. You should free() the unit when it is no longer needed.\n  If creation is not possible, then NULL is returned.\n\n  The virtual unit has no homecity or tile. It is owned by the player\n  corresponding to the current 'applied player' parameter and has unit type\n  given by the sub-value of the unit tool (ETT_UNIT).\n****************************************************************************/\n", "func_signal": "struct unit *editor_unit_virtual_create(void)", "code": "{\n  struct unit *vunit;\n  struct player *pplayer;\n  struct unit_type *putype;\n  int apno, value;\n\n  value = editor_tool_get_value(ETT_UNIT);\n  putype = utype_by_number(value);\n\n  if (!putype) {\n    return NULL;\n  }\n\n  apno = editor_tool_get_applied_player(ETT_UNIT);\n  pplayer = player_by_number(apno);\n  if (!pplayer) {\n    return NULL;\n  }\n\n  vunit = unit_virtual_create(pplayer, NULL, putype, 0);\n\n  return vunit;\n}", "path": "freeciv/client/editor.c", "commit_date": "2020-02-24 00:00:00", "repo_name": "freeciv/freeciv", "stars": 1168, "license": "gpl-2.0", "language": "c", "size": 909621}
{"docstring": "/**\n  Sets the size parameter for the given tool.\n****************************************************************************/\n", "func_signal": "void editor_tool_set_size(enum editor_tool_type ett, int size)", "code": "{\n  if (!editor || !(ett < NUM_EDITOR_TOOL_TYPES)) {\n    return;\n  }\n  editor->tools[ett].size = MAX(1, size);\n}", "path": "freeciv/client/editor.c", "commit_date": "2020-02-24 00:00:00", "repo_name": "freeciv/freeciv", "stars": 1168, "license": "gpl-2.0", "language": "c", "size": 909621}
{"docstring": "/**\n  Returns the translated string name for the given mode.\n****************************************************************************/\n", "func_signal": "const char *editor_tool_get_mode_name(enum editor_tool_type ett,\n                                      enum editor_tool_mode etm)", "code": "{\n  bool value_erase;\n\n  value_erase = editor_tool_has_value_erase(ett);\n\n  switch (etm) {\n  case ETM_PAINT:\n    return _(\"Paint\");\n    break;\n  case ETM_ERASE:\n    if (value_erase) {\n      return _(\"Erase Value\");\n    } else {\n      return _(\"Erase\");\n    }\n    break;\n  case ETM_COPY:\n    return _(\"Copy\");\n    break;\n  case ETM_PASTE:\n    return _(\"Paste\");\n    break;\n  default:\n    log_error(\"Unrecognized editor tool mode %d \"\n              \"in editor_tool_get_mode_name().\", etm);\n    break;\n  }\n\n  return \"\";\n}", "path": "freeciv/client/editor.c", "commit_date": "2020-02-24 00:00:00", "repo_name": "freeciv/freeciv", "stars": 1168, "license": "gpl-2.0", "language": "c", "size": 909621}
{"docstring": "/**\n  Record the start of the selection rectangle.\n****************************************************************************/\n", "func_signal": "static void editor_start_selection_rectangle(int canvas_x, int canvas_y)", "code": "{\n  if (!editor) {\n    return;\n  }\n\n  if (editor->selection_mode == SELECTION_MODE_NEW\n      && editor_selection_count() > 0) {\n    editor_selection_clear();\n    update_map_canvas_visible();\n  }\n\n  editor->selrect_start_x = canvas_x;\n  editor->selrect_start_y = canvas_y;\n  editor->selrect_width = 0;\n  editor->selrect_height = 0;\n  editor->selrect_active = TRUE;\n}", "path": "freeciv/client/editor.c", "commit_date": "2020-02-24 00:00:00", "repo_name": "freeciv/freeciv", "stars": 1168, "license": "gpl-2.0", "language": "c", "size": 909621}
{"docstring": "/**\n  Free all memory allocated for the edit buffer.\n****************************************************************************/\n", "func_signal": "void edit_buffer_free(struct edit_buffer *ebuf)", "code": "{\n  if (!ebuf) {\n    return;\n  }\n\n  if (ebuf->vtiles) {\n    tile_list_iterate(ebuf->vtiles, vtile) {\n      tile_virtual_destroy(vtile);\n    } tile_list_iterate_end;\n    tile_list_destroy(ebuf->vtiles);\n    ebuf->vtiles = NULL;\n  }\n  free(ebuf);\n}", "path": "freeciv/client/editor.c", "commit_date": "2020-02-24 00:00:00", "repo_name": "freeciv/freeciv", "stars": 1168, "license": "gpl-2.0", "language": "c", "size": 909621}
{"docstring": "/**\n  Sets the editor tool's applied player number to the given value.\n****************************************************************************/\n", "func_signal": "void editor_tool_set_applied_player(enum editor_tool_type ett,\n                                    int player_no)", "code": "{\n  if (!editor || !(ett < NUM_EDITOR_TOOL_TYPES)) {\n    return;\n  }\n  editor->tools[ett].applied_player_no = player_no;\n}", "path": "freeciv/client/editor.c", "commit_date": "2020-02-24 00:00:00", "repo_name": "freeciv/freeciv", "stars": 1168, "license": "gpl-2.0", "language": "c", "size": 909621}
{"docstring": "/**\n  Returns the copy buffer for the given tool.\n****************************************************************************/\n", "func_signal": "struct edit_buffer *editor_get_copy_buffer(void)", "code": "{\n  if (!editor) {\n    return NULL;\n  }\n  return editor->copybuf;\n}", "path": "freeciv/client/editor.c", "commit_date": "2020-02-24 00:00:00", "repo_name": "freeciv/freeciv", "stars": 1168, "license": "gpl-2.0", "language": "c", "size": 909621}
{"docstring": "/**\n  Returns TRUE if the given tool makes use of the editor's applied player\n  number.\n****************************************************************************/\n", "func_signal": "bool editor_tool_has_applied_player(enum editor_tool_type ett)", "code": "{\n  if (!editor || !(ett < NUM_EDITOR_TOOL_TYPES)) {\n    return FALSE;\n  }\n  return editor->tools[ett].flags & ETF_HAS_APPLIED_PLAYER;\n}", "path": "freeciv/client/editor.c", "commit_date": "2020-02-24 00:00:00", "repo_name": "freeciv/freeciv", "stars": 1168, "license": "gpl-2.0", "language": "c", "size": 909621}
{"docstring": "/**\n  Get the mode for the tool.\n****************************************************************************/\n", "func_signal": "enum editor_tool_mode editor_tool_get_mode(enum editor_tool_type ett)", "code": "{\n  if (editor == NULL || !(ett < NUM_EDITOR_TOOL_TYPES)) {\n    return NUM_EDITOR_TOOL_MODES;\n  }\n  return editor->tools[ett].mode;\n}", "path": "freeciv/client/editor.c", "commit_date": "2020-02-24 00:00:00", "repo_name": "freeciv/freeciv", "stars": 1168, "license": "gpl-2.0", "language": "c", "size": 909621}
{"docstring": "/**\n  Get the translated name of the given tool type.\n****************************************************************************/\n", "func_signal": "const char *editor_tool_get_name(enum editor_tool_type ett)", "code": "{\n  if (!editor || !(ett < NUM_EDITOR_TOOL_TYPES)) {\n    return \"\";\n  }\n\n  return editor->tools[ett].name;\n}", "path": "freeciv/client/editor.c", "commit_date": "2020-02-24 00:00:00", "repo_name": "freeciv/freeciv", "stars": 1168, "license": "gpl-2.0", "language": "c", "size": 909621}
{"docstring": "/**\n  Get the tile that the user's mouse pointer is currently over.\n****************************************************************************/\n", "func_signal": "const struct tile *editor_get_current_tile(void)", "code": "{\n  if (editor == NULL) {\n    return NULL;\n  }\n  \n  return editor->current_tile;\n}", "path": "freeciv/client/editor.c", "commit_date": "2020-02-24 00:00:00", "repo_name": "freeciv/freeciv", "stars": 1168, "license": "gpl-2.0", "language": "c", "size": 909621}
{"docstring": "/**\n  Handle the mouse moving over the map canvas.\n****************************************************************************/\n", "func_signal": "void editor_mouse_move(int canvas_x, int canvas_y, int modifiers)", "code": "{\n  const struct tile *ptile, *old;\n\n  if (!editor) {\n    return;\n  }\n\n  old = editor_get_current_tile();\n  ptile = canvas_pos_to_tile(canvas_x, canvas_y);\n\n  if (!ptile) {\n    return;\n  }\n\n  if (editor->tool_active && old != NULL && old != ptile) {\n    editor_apply_tool(ptile, FALSE);\n    editor_notify_edit_finished();\n    editor_set_current_tile(ptile);\n  }\n\n  if (editor->selrect_active) {\n    editor_resize_selection_rectangle(canvas_x, canvas_y);\n  }\n}", "path": "freeciv/client/editor.c", "commit_date": "2020-02-24 00:00:00", "repo_name": "freeciv/freeciv", "stars": 1168, "license": "gpl-2.0", "language": "c", "size": 909621}
{"docstring": "/*******************************************************************************\n* Function Name  : Resume\n* Description    : This is the state machine handling resume operations and\n*                 timing sequence. The control is based on the Resume structure\n*                 variables and on the ESOF interrupt calling this subroutine\n*                 without changing machine state.\n* Input          : a state machine value (RESUME_STATE)\n*                  RESUME_ESOF doesn't change ResumeS.eState allowing\n*                  decrementing of the ESOF counter in different states.\n* Output         : None.\n* Return         : None.\n*******************************************************************************/\n", "func_signal": "void Resume(RESUME_STATE eResumeSetVal)", "code": "{\n  uint16_t wCNTR;\n\n  if (eResumeSetVal != RESUME_ESOF)\n    ResumeS.eState = eResumeSetVal;\n  switch (ResumeS.eState)\n  {\n    case RESUME_EXTERNAL:\n      if (remotewakeupon ==0)\n      {\n        Resume_Init();\n        ResumeS.eState = RESUME_OFF;\n      }\n      else /* RESUME detected during the RemoteWAkeup signalling => keep RemoteWakeup handling*/\n      {\n        ResumeS.eState = RESUME_ON;\n      }\n      break;\n    case RESUME_INTERNAL:\n      Resume_Init();\n      ResumeS.eState = RESUME_START;\n      remotewakeupon = 1;\n      break;\n    case RESUME_LATER:\n      ResumeS.bESOFcnt = 2;\n      ResumeS.eState = RESUME_WAIT;\n      break;\n    case RESUME_WAIT:\n      ResumeS.bESOFcnt--;\n      if (ResumeS.bESOFcnt == 0)\n        ResumeS.eState = RESUME_START;\n      break;\n    case RESUME_START:\n      wCNTR = _GetCNTR();\n      wCNTR |= CNTR_RESUME;\n      _SetCNTR(wCNTR);\n      ResumeS.eState = RESUME_ON;\n      ResumeS.bESOFcnt = 10;\n      break;\n    case RESUME_ON:    \n      ResumeS.bESOFcnt--;\n      if (ResumeS.bESOFcnt == 0)\n      {\n        wCNTR = _GetCNTR();\n        wCNTR &= (~CNTR_RESUME);\n        _SetCNTR(wCNTR);\n        ResumeS.eState = RESUME_OFF;\n        remotewakeupon = 0;\n      }\n      break;\n    case RESUME_OFF:\n    case RESUME_ESOF:\n    default:\n      ResumeS.eState = RESUME_OFF;\n      break;\n  }\n}", "path": "Avem/libs/STM32_USB-FS-Device_Lib_V4.0.0/Projects/Composite_Example/src/usb_pwr.c", "commit_date": "2016-08-10 00:00:00", "repo_name": "avem-labs/Avem", "stars": 1690, "license": "mit", "language": "c", "size": 30219}
{"docstring": "/*******************************************************************************\n* Function Name  : PowerOff\n* Description    : handles switch-off conditions\n* Input          : None.\n* Output         : None.\n* Return         : USB_SUCCESS.\n*******************************************************************************/\n", "func_signal": "RESULT PowerOff()", "code": "{\n  /* disable all interrupts and force USB reset */\n  _SetCNTR(CNTR_FRES);\n  /* clear interrupt status register */\n  _SetISTR(0);\n  /* Disable the Pull-Up*/\n  USB_Cable_Config(DISABLE);\n  /* switch-off device */\n  _SetCNTR(CNTR_FRES + CNTR_PDWN);\n  /* sw variables reset */\n  /* ... */\n\n  return USB_SUCCESS;\n}", "path": "Avem/libs/STM32_USB-FS-Device_Lib_V4.0.0/Projects/Composite_Example/src/usb_pwr.c", "commit_date": "2016-08-10 00:00:00", "repo_name": "avem-labs/Avem", "stars": 1690, "license": "mit", "language": "c", "size": 30219}
{"docstring": "/**\n  * @brief  Writes buffer of data to the I2C EEPROM.\n  * @param  sEEInitStruct : Pointer to sEE Device structure\n  * @param  pBuffer : pointer to the buffer  containing the data to be written \n  *         to the EEPROM.\n  * @param  WriteAddr : EEPROM's internal address to write to.\n  * @param  NumByteToWrite : number of bytes to write to the EEPROM.\n  * @retval None\n  */\n", "func_signal": "uint32_t sEE_WriteBuffer(sEE_InitTypeDef* sEEInitStruct, uint8_t* pBuffer, \\\n                         uint16_t WriteAddr, uint32_t NumByteToWrite)", "code": "{   \n  uint32_t  DataNum = 0;\n  uint16_t count = 0;\n  uint16_t Addr = 0;\n  \n  if (sEEInitStruct->sEEState == sEE_STATE_IDLE)\n  {\n    sEEInitStruct->sEEState = sEE_STATE_WRITING;\n    \n    sEE_WriteStructures[sEEInitStruct->sEE_CPALStructure->CPAL_Dev]->sEEDataNum = 0;\n    sEE_WriteStructures[sEEInitStruct->sEE_CPALStructure->CPAL_Dev]->sEEWriteAddr = 0;\n    sEE_WriteStructures[sEEInitStruct->sEE_CPALStructure->CPAL_Dev]->sEEpBuffer = pNULL;\n    sEE_WriteStructures[sEEInitStruct->sEE_CPALStructure->CPAL_Dev]->sEENumOfPage = 0;\n    sEE_WriteStructures[sEEInitStruct->sEE_CPALStructure->CPAL_Dev]->sEENextWrite = 0;\n    sEE_WriteStructures[sEEInitStruct->sEE_CPALStructure->CPAL_Dev]->sEENumOfSingle = 0;\n    \n    /* if one data will be written */\n    if (NumByteToWrite == 1)\n    { \n      /* Transfer complete */\n      sEE_WriteStructures[sEEInitStruct->sEE_CPALStructure->CPAL_Dev]->sEENextWrite = 0;\n      \n      /* update number od data for write */\n      DataNum = NumByteToWrite;\n      \n      if(sEE_WritePage(sEEInitStruct, pBuffer, WriteAddr, DataNum) != CPAL_PASS)\n      {    \n        return CPAL_FAIL;\n      }      \n    }\n    /* Use Write page */\n    else\n    {            \n      /* if Address aligned reset count value to 0 */\n      Addr = WriteAddr % sEEInitStruct->sEEPageSize;\n      \n      if (Addr == 0)\n      {\n        count = 0;\n      }\n      else\n      { \n       count = sEEInitStruct->sEEPageSize - Addr;\n       \n       if (NumByteToWrite <= count)\n        {\n          count = NumByteToWrite;\n        }        \n      }\n      \n      /* Get Number of page for write and number of single byte */\n      sEE_WriteStructures[sEEInitStruct->sEE_CPALStructure->CPAL_Dev]->sEENumOfPage = \\\n                                 (uint16_t)((NumByteToWrite - count) / sEEInitStruct->sEEPageSize);\n      sEE_WriteStructures[sEEInitStruct->sEE_CPALStructure->CPAL_Dev]->sEENumOfSingle = \\\n                                  (uint8_t)((NumByteToWrite - count) % sEEInitStruct->sEEPageSize);\n           \n      /* If WriteAddr is sEE_PAGESIZE is not aligned  */\n      if (Addr != 0) \n      {\n        /* Update Number of data to write */\n        sEE_WriteStructures[sEEInitStruct->sEE_CPALStructure->CPAL_Dev]->sEEDataNum = count; \n      }    \n      /* If WriteAddr is sEE_PAGESIZE is aligned  */\n      else\n      {\n        /* if only single byte must be written */\n        if (sEE_WriteStructures[sEEInitStruct->sEE_CPALStructure->CPAL_Dev]->sEENumOfPage == 0)\n        {\n          /* update number of data to write */\n          sEE_WriteStructures[sEEInitStruct->sEE_CPALStructure->CPAL_Dev]->sEEDataNum = \\\n            sEE_WriteStructures[sEEInitStruct->sEE_CPALStructure->CPAL_Dev]->sEENumOfSingle;\n          \n          /* reset number of single */\n          sEE_WriteStructures[sEEInitStruct->sEE_CPALStructure->CPAL_Dev]->sEENumOfSingle = 0;\n        }\n        else\n        {\n          /* update number of data to write */\n          sEE_WriteStructures[sEEInitStruct->sEE_CPALStructure->CPAL_Dev]->sEEDataNum =  (uint32_t)((uint16_t)sEEInitStruct->sEEPageSize); \n          \n          /* update number of page */\n          sEE_WriteStructures[sEEInitStruct->sEE_CPALStructure->CPAL_Dev]->sEENumOfPage--;\n        }      \n      }\n      \n      /* update global variable */\n      DataNum = sEE_WriteStructures[sEEInitStruct->sEE_CPALStructure->CPAL_Dev]->sEEDataNum;\n      sEE_WriteStructures[sEEInitStruct->sEE_CPALStructure->CPAL_Dev]->sEEWriteAddr = (uint32_t)((uint16_t)WriteAddr);\n      sEE_WriteStructures[sEEInitStruct->sEE_CPALStructure->CPAL_Dev]->sEEpBuffer = pBuffer;\n            \n      /* If there are remaining data to transfer */\n      if ((sEE_WriteStructures[sEEInitStruct->sEE_CPALStructure->CPAL_Dev]->sEENumOfPage != 0) \n          || (sEE_WriteStructures[sEEInitStruct->sEE_CPALStructure->CPAL_Dev]->sEENumOfSingle != 0))\n      {     \n        /* update global variable */\n        sEE_WriteStructures[sEEInitStruct->sEE_CPALStructure->CPAL_Dev]->sEENextWrite = 1;         \n      } \n           \n      /* Write data on EEPROM */\n      if (sEE_WritePage(sEEInitStruct, pBuffer, WriteAddr, DataNum) != CPAL_PASS)\n      {\n        return CPAL_FAIL;\n      }     \n      \n    }  \n    return CPAL_PASS;\n  }\n  else\n  {\n    return CPAL_FAIL;\n  }\n}", "path": "Avem/libs/STM32_USB-FS-Device_Lib_V4.0.0/Utilities/STM32_EVAL/STM32303C_EVAL/stm32303c_eval_i2c_ee_cpal.c", "commit_date": "2016-08-10 00:00:00", "repo_name": "avem-labs/Avem", "stars": 1690, "license": "mit", "language": "c", "size": 30219}
{"docstring": "/*******************************************************************************\n* Function Name  : Suspend\n* Description    : sets suspend mode operating conditions\n* Input          : None.\n* Output         : None.\n* Return         : USB_SUCCESS.\n*******************************************************************************/\n", "func_signal": "void Suspend(void)", "code": "{\n\tuint32_t i =0;\n\tuint16_t wCNTR;\n\tuint32_t tmpreg = 0;\n  __IO uint32_t savePWR_CR=0;\n\t/* suspend preparation */\n\t/* ... */\n\t\n\t/*Store CNTR value */\n\twCNTR = _GetCNTR();  \n\n    /* This a sequence to apply a force RESET to handle a robustness case */\n    \n\t/*Store endpoints registers status */\n    for (i=0;i<8;i++) EP[i] = _GetENDPOINT(i);\n\t\n\t/* unmask RESET flag */\n\twCNTR|=CNTR_RESETM;\n\t_SetCNTR(wCNTR);\n\t\n\t/*apply FRES */\n\twCNTR|=CNTR_FRES;\n\t_SetCNTR(wCNTR);\n\t\n\t/*clear FRES*/\n\twCNTR&=~CNTR_FRES;\n\t_SetCNTR(wCNTR);\n\t\n\t/*poll for RESET flag in ISTR*/\n\twhile((_GetISTR()&ISTR_RESET) == 0);\n\t\n\t/* clear RESET flag in ISTR */\n\t_SetISTR((uint16_t)CLR_RESET);\n\t\n\t/*restore Enpoints*/\n\tfor (i=0;i<8;i++)\n\t_SetENDPOINT(i, EP[i]);\n\t\n\t/* Now it is safe to enter macrocell in suspend mode */\n\twCNTR |= CNTR_FSUSP;\n\t_SetCNTR(wCNTR);\n\t\n\t/* force low-power mode in the macrocell */\n\twCNTR = _GetCNTR();\n\twCNTR |= CNTR_LPMODE;\n\t_SetCNTR(wCNTR);\n\t\n\t/*prepare entry in low power mode (STOP mode)*/\n\t/* Select the regulator state in STOP mode*/\n\tsavePWR_CR = PWR->CR;\n\ttmpreg = PWR->CR;\n\t/* Clear PDDS and LPDS bits */\n\ttmpreg &= ((uint32_t)0xFFFFFFFC);\n\t/* Set LPDS bit according to PWR_Regulator value */\n\ttmpreg |= PWR_Regulator_LowPower;\n\t/* Store the new value */\n\tPWR->CR = tmpreg;\n\t/* Set SLEEPDEEP bit of Cortex System Control Register */\n#if defined (STM32F30X) || defined (STM32F37X)\n        SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;\n#else\n        SCB->SCR |= SCB_SCR_SLEEPDEEP;       \n#endif\n\t\n\t/* enter system in STOP mode, only when wakeup flag in not set */\n\tif((_GetISTR()&ISTR_WKUP)==0)\n\t{\n\t\t__WFI();\n\t\t/* Reset SLEEPDEEP bit of Cortex System Control Register */\n#if defined (STM32F30X) || defined (STM32F37X)\n                SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk); \n#else\n                SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP); \n#endif\n\t}\n\telse\n\t{\n\t\t/* Clear Wakeup flag */\n\t\t_SetISTR(CLR_WKUP);\n\t\t/* clear FSUSP to abort entry in suspend mode  */\n        wCNTR = _GetCNTR();\n        wCNTR&=~CNTR_FSUSP;\n        _SetCNTR(wCNTR);\n\t\t\n\t\t/*restore sleep mode configuration */ \n\t\t/* restore Power regulator config in sleep mode*/\n\t\tPWR->CR = savePWR_CR;\n\t\t\n\t\t/* Reset SLEEPDEEP bit of Cortex System Control Register */\n#if defined (STM32F30X) || defined (STM32F37X)\t\t\n                SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);\n#else\n                SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP);\n#endif\n    }\n}", "path": "Avem/libs/STM32_USB-FS-Device_Lib_V4.0.0/Projects/Composite_Example/src/usb_pwr.c", "commit_date": "2016-08-10 00:00:00", "repo_name": "avem-labs/Avem", "stars": 1690, "license": "mit", "language": "c", "size": 30219}
{"docstring": "/**\n  * @brief  Initializes peripherals used by the I2C EEPROM driver.\n  * @param  None\n  * @retval None\n  */\n", "func_signal": "void sEE_Init(void)", "code": "{ \n  I2C_InitTypeDef  I2C_InitStructure;\n  \n  sEE_LowLevel_Init();\n  \n  /*!< I2C configuration */\n  /* sEE_I2C configuration */\n  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;\n  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;\n  I2C_InitStructure.I2C_OwnAddress1 = I2C_SLAVE_ADDRESS7;\n  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;\n  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;\n  I2C_InitStructure.I2C_ClockSpeed = I2C_SPEED;\n  \n  /* sEE_I2C Peripheral Enable */\n  I2C_Cmd(sEE_I2C, ENABLE);\n  /* Apply sEE_I2C configuration after enabling it */\n  I2C_Init(sEE_I2C, &I2C_InitStructure);\n\n  /* Enable the sEE_I2C peripheral DMA requests */\n  I2C_DMACmd(sEE_I2C, ENABLE);\n  \n#if defined (sEE_M24C64_32)\n  /*!< Select the EEPROM address according to the state of E0, E1, E2 pins */\n  sEEAddress = sEE_HW_ADDRESS;  \n#elif defined (sEE_M24C08)\n  /*!< depending on the sEE Address selected in the i2c_ee.h file */\n #ifdef sEE_Block0_ADDRESS\n  /*!< Select the sEE Block0 to write on */\n  sEEAddress = sEE_Block0_ADDRESS;\n #endif\n  \n #ifdef sEE_Block1_ADDRESS\n  /*!< Select the sEE Block1 to write on */\n  sEEAddress = sEE_Block1_ADDRESS;\n #endif\n\n #ifdef sEE_Block2_ADDRESS\n  /*!< Select the sEE Block2 to write on */\n  sEEAddress = sEE_Block2_ADDRESS;\n #endif\n  \n #ifdef sEE_Block3_ADDRESS\n  /*!< Select the sEE Block3 to write on */\n  sEEAddress = sEE_Block3_ADDRESS;\n #endif \n#endif /*!< sEE_M24C64_32 */    \n}", "path": "Avem/libs/STM32_USB-FS-Device_Lib_V4.0.0/Utilities/STM32_EVAL/STM32L152_EVAL/stm32l152_eval_i2c_ee.c", "commit_date": "2016-08-10 00:00:00", "repo_name": "avem-labs/Avem", "stars": 1690, "license": "mit", "language": "c", "size": 30219}
{"docstring": "/**\n  * @brief  Initialize sEE CPAL Structure used by the I2C EEPROM driver.\n  * @param  sEEInitStruct : Pointer to sEE Device structure\n  * @retval None\n  */\n", "func_signal": "void sEE_StructInit(sEE_InitTypeDef* sEEInitStruct)", "code": "{   \n  /* Set CPAL structure parameters to their default values */  \n  CPAL_I2C_StructInit(sEEInitStruct->sEE_CPALStructure);\n  \n  /* Set I2C clock speed */\n  sEEInitStruct->sEE_CPALStructure->pCPAL_I2C_Struct->I2C_Timing = sEE_I2C_TIMING;\n  \n  sEEInitStruct->sEE_CPALStructure->wCPAL_Options = 0;\n\n#ifdef sEE_IT\n  /* Select Interrupt programming model and disable all options */\n  sEEInitStruct->sEE_CPALStructure->CPAL_ProgModel =  CPAL_PROGMODEL_INTERRUPT; \n#else\n  /* Select DMA programming model and activate TX_DMA_TC and RX_DMA_TC interrupts */\n  sEEInitStruct->sEE_CPALStructure->CPAL_ProgModel =  CPAL_PROGMODEL_DMA;\n#endif /* sEE_IT */\n  \n}", "path": "Avem/libs/STM32_USB-FS-Device_Lib_V4.0.0/Utilities/STM32_EVAL/STM32303C_EVAL/stm32303c_eval_i2c_ee_cpal.c", "commit_date": "2016-08-10 00:00:00", "repo_name": "avem-labs/Avem", "stars": 1690, "license": "mit", "language": "c", "size": 30219}
{"docstring": "/**\n  * @brief  Handle EEPROM Write operation \n  * @param  Device : sEE CPAL device instance\n  * @retval None\n  */\n", "func_signal": "uint32_t sEE_WriteHandler(CPAL_DevTypeDef Device)", "code": "{  \n  uint32_t  DataNum = 0;\n  \n  /* wait until EEPROM ready for transfer */\n  while (sEE_WaitEepromStandbyState(Device) == CPAL_FAIL);\n  \n  /* if there are remaining data for write */\n  if (sEE_WriteStructures[Device]->sEENextWrite != 0)\n  {  \n    sEE_WriteStructures[Device]->sEEWriteAddr += sEE_WriteStructures[Device]->sEEDataNum;\n    sEE_WriteStructures[Device]->sEEpBuffer += sEE_WriteStructures[Device]->sEEDataNum;\n    sEE_WriteStructures[Device]->sEENextWrite = 0;\n        \n    /* if page must be written in EEPROM */\n    if(sEE_WriteStructures[Device]->sEENumOfPage != 0)\n    {\n      sEE_WriteStructures[Device]->sEEDataNum = (uint32_t)((uint16_t)sEE_DevStructures[Device]->sEEPageSize);\n      sEE_WriteStructures[Device]->sEENumOfPage--;\n    }\n    /* if single byte must be written in EEPROM */\n    else if (sEE_WriteStructures[Device]->sEENumOfSingle != 0)\n    {\n      sEE_WriteStructures[Device]->sEEDataNum = (uint32_t)((uint8_t)sEE_WriteStructures[Device]->sEENumOfSingle);\n      sEE_WriteStructures[Device]->sEENumOfSingle = 0;\n      sEE_WriteStructures[Device]->sEENextWrite = 0;\n    }\n    \n    /* update number of date for write */\n    DataNum = sEE_WriteStructures[Device]->sEEDataNum;\n    \n     /* if another data must be written */\n    if ((sEE_WriteStructures[Device]->sEENumOfPage != 0) \n        || (sEE_WriteStructures[Device]->sEENumOfSingle != 0))\n    {      \n      sEE_WriteStructures[Device]->sEENextWrite = 1;\n    }   \n    \n    /* write data in EEPROM */\n    sEE_WritePage(sEE_DevStructures[Device],(uint8_t*)sEE_WriteStructures[Device]->sEEpBuffer, \\\n                                            sEE_WriteStructures[Device]->sEEWriteAddr, DataNum); \n  }\n  else\n  {\n    if (sEE_DevStructures[Device]->sEEState != sEE_STATE_ERROR)\n    {\n      /* Reset EEPROM State */\n      sEE_DevStructures[Device]->sEEState = sEE_STATE_IDLE;\n    }\n  }\n  \n  return CPAL_PASS;\n}", "path": "Avem/libs/STM32_USB-FS-Device_Lib_V4.0.0/Utilities/STM32_EVAL/STM32303C_EVAL/stm32303c_eval_i2c_ee_cpal.c", "commit_date": "2016-08-10 00:00:00", "repo_name": "avem-labs/Avem", "stars": 1690, "license": "mit", "language": "c", "size": 30219}
{"docstring": "/*******************************************************************************\n* Function Name  : NOR_If_Write\n* Description    : Write sectors\n* Input          : None\n* Output         : None\n* Return         : None\n*******************************************************************************/\n", "func_signal": "uint16_t NOR_If_Write(uint32_t Address, uint32_t DataLength)", "code": "{\n  if ((DataLength & 1) == 1) /* Not an aligned data */\n  {\n    DataLength += 1;\n    MAL_Buffer[DataLength-1] = 0xFF;\n  }\n  \n  FSMC_NOR_WriteBuffer((uint16_t *)MAL_Buffer, (Address&0x00FFFFFF), DataLength >> 1);  \n  \n  return MAL_OK;\n}", "path": "Avem/libs/STM32_USB-FS-Device_Lib_V4.0.0/Projects/Device_Firmware_Upgrade/src/nor_if.c", "commit_date": "2016-08-10 00:00:00", "repo_name": "avem-labs/Avem", "stars": 1690, "license": "mit", "language": "c", "size": 30219}
{"docstring": "/**\n  * @brief  Writes buffer of data to the I2C EEPROM.\n  * @param  pBuffer : pointer to the buffer  containing the data to be written \n  *         to the EEPROM.\n  * @param  WriteAddr : EEPROM's internal address to write to.\n  * @param  NumByteToWrite : number of bytes to write to the EEPROM.\n  * @retval None\n  */\n", "func_signal": "void sEE_WriteBuffer(uint8_t* pBuffer, uint16_t WriteAddr, uint16_t NumByteToWrite)", "code": "{\n  uint16_t NumOfPage = 0, NumOfSingle = 0, count = 0;\n  uint16_t Addr = 0;\n\n  Addr = WriteAddr % sEE_PAGESIZE;\n  count = sEE_PAGESIZE - Addr;\n  NumOfPage =  NumByteToWrite / sEE_PAGESIZE;\n  NumOfSingle = NumByteToWrite % sEE_PAGESIZE;\n \n  /*!< If WriteAddr is sEE_PAGESIZE aligned  */\n  if(Addr == 0) \n  {\n    /*!< If NumByteToWrite < sEE_PAGESIZE */\n    if(NumOfPage == 0) \n    {\n      /* Store the number of data to be written */\n      sEEDataNum = NumOfSingle;\n      /* Start writing data */\n      sEE_WritePage(pBuffer, WriteAddr, (uint8_t*)(&sEEDataNum));\n      /* Wait transfer through DMA to be complete */\n      sEETimeout = sEE_LONG_TIMEOUT;\n      while (sEEDataNum > 0)\n      {\n        if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};\n      }\n      sEE_WaitEepromStandbyState();\n    }\n    /*!< If NumByteToWrite > sEE_PAGESIZE */\n    else  \n    {\n      while(NumOfPage--)\n      {\n        /* Store the number of data to be written */\n        sEEDataNum = sEE_PAGESIZE;        \n        sEE_WritePage(pBuffer, WriteAddr, (uint8_t*)(&sEEDataNum)); \n        /* Wait transfer through DMA to be complete */\n        sEETimeout = sEE_LONG_TIMEOUT;\n        while (sEEDataNum > 0)\n        {\n          if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};\n        }      \n        sEE_WaitEepromStandbyState();\n        WriteAddr +=  sEE_PAGESIZE;\n        pBuffer += sEE_PAGESIZE;\n      }\n\n      if(NumOfSingle!=0)\n      {\n        /* Store the number of data to be written */\n        sEEDataNum = NumOfSingle;          \n        sEE_WritePage(pBuffer, WriteAddr, (uint8_t*)(&sEEDataNum));\n        /* Wait transfer through DMA to be complete */\n        sEETimeout = sEE_LONG_TIMEOUT;\n        while (sEEDataNum > 0)\n        {\n          if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};\n        }    \n        sEE_WaitEepromStandbyState();\n      }\n    }\n  }\n  /*!< If WriteAddr is not sEE_PAGESIZE aligned  */\n  else \n  {\n    /*!< If NumByteToWrite < sEE_PAGESIZE */\n    if(NumOfPage== 0) \n    {\n      /*!< If the number of data to be written is more than the remaining space \n      in the current page: */\n      if (NumByteToWrite > count)\n      {\n        /* Store the number of data to be written */\n        sEEDataNum = count;        \n        /*!< Write the data conained in same page */\n        sEE_WritePage(pBuffer, WriteAddr, (uint8_t*)(&sEEDataNum));\n        /* Wait transfer through DMA to be complete */\n        sEETimeout = sEE_LONG_TIMEOUT;\n        while (sEEDataNum > 0)\n        {\n          if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};\n        }          \n        sEE_WaitEepromStandbyState();      \n        \n        /* Store the number of data to be written */\n        sEEDataNum = (NumByteToWrite - count);          \n        /*!< Write the remaining data in the following page */\n        sEE_WritePage((uint8_t*)(pBuffer + count), (WriteAddr + count), (uint8_t*)(&sEEDataNum));\n        /* Wait transfer through DMA to be complete */\n        sEETimeout = sEE_LONG_TIMEOUT;\n        while (sEEDataNum > 0)\n        {\n          if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};\n        }     \n        sEE_WaitEepromStandbyState();        \n      }      \n      else      \n      {\n        /* Store the number of data to be written */\n        sEEDataNum = NumOfSingle;         \n        sEE_WritePage(pBuffer, WriteAddr, (uint8_t*)(&sEEDataNum));\n        /* Wait transfer through DMA to be complete */\n        sEETimeout = sEE_LONG_TIMEOUT;\n        while (sEEDataNum > 0)\n        {\n          if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};\n        }          \n        sEE_WaitEepromStandbyState();        \n      }     \n    }\n    /*!< If NumByteToWrite > sEE_PAGESIZE */\n    else\n    {\n      NumByteToWrite -= count;\n      NumOfPage =  NumByteToWrite / sEE_PAGESIZE;\n      NumOfSingle = NumByteToWrite % sEE_PAGESIZE;\n      \n      if(count != 0)\n      {  \n        /* Store the number of data to be written */\n        sEEDataNum = count;         \n        sEE_WritePage(pBuffer, WriteAddr, (uint8_t*)(&sEEDataNum));\n        /* Wait transfer through DMA to be complete */\n        sEETimeout = sEE_LONG_TIMEOUT;\n        while (sEEDataNum > 0)\n        {\n          if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};\n        }     \n        sEE_WaitEepromStandbyState();\n        WriteAddr += count;\n        pBuffer += count;\n      } \n      \n      while(NumOfPage--)\n      {\n        /* Store the number of data to be written */\n        sEEDataNum = sEE_PAGESIZE;          \n        sEE_WritePage(pBuffer, WriteAddr, (uint8_t*)(&sEEDataNum));\n        /* Wait transfer through DMA to be complete */\n        sEETimeout = sEE_LONG_TIMEOUT;\n        while (sEEDataNum > 0)\n        {\n          if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};\n        }        \n        sEE_WaitEepromStandbyState();\n        WriteAddr +=  sEE_PAGESIZE;\n        pBuffer += sEE_PAGESIZE;  \n      }\n      if(NumOfSingle != 0)\n      {\n        /* Store the number of data to be written */\n        sEEDataNum = NumOfSingle;           \n        sEE_WritePage(pBuffer, WriteAddr, (uint8_t*)(&sEEDataNum)); \n        /* Wait transfer through DMA to be complete */\n        sEETimeout = sEE_LONG_TIMEOUT;\n        while (sEEDataNum > 0)\n        {\n          if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};\n        }         \n        sEE_WaitEepromStandbyState();\n      }\n    }\n  }  \n}", "path": "Avem/libs/STM32_USB-FS-Device_Lib_V4.0.0/Utilities/STM32_EVAL/STM32L152_EVAL/stm32l152_eval_i2c_ee.c", "commit_date": "2016-08-10 00:00:00", "repo_name": "avem-labs/Avem", "stars": 1690, "license": "mit", "language": "c", "size": 30219}
{"docstring": "/**\n  * @brief  Basic management of the timeout situation.\n  * @param  None.\n  * @retval None.\n  */\n", "func_signal": "uint32_t sEE_TIMEOUT_UserCallback(void)", "code": "{\n  /* Block communication and all processes */\n  while (1)\n  {   \n  }\n}", "path": "Avem/libs/STM32_USB-FS-Device_Lib_V4.0.0/Utilities/STM32_EVAL/STM32L152_EVAL/stm32l152_eval_i2c_ee.c", "commit_date": "2016-08-10 00:00:00", "repo_name": "avem-labs/Avem", "stars": 1690, "license": "mit", "language": "c", "size": 30219}
{"docstring": "/**\n  * @brief  This function handles the DMA Rx Channel interrupt Handler.\n  * @param  None\n  * @retval None\n  */\n", "func_signal": "void sEE_I2C_DMA_RX_IRQHandler(void)", "code": "{\n  /* Check if the DMA transfer is complete */\n  if(DMA_GetFlagStatus(sEE_I2C_DMA_FLAG_RX_TC) != RESET)\n  {      \n    /*!< Send STOP Condition */\n    I2C_GenerateSTOP(sEE_I2C, ENABLE);    \n    \n    /* Disable the DMA Rx Channel and Clear all its Flags */  \n    DMA_Cmd(sEE_I2C_DMA_CHANNEL_RX, DISABLE);\n    DMA_ClearFlag(sEE_I2C_DMA_FLAG_RX_GL);\n    \n    /* Reset the variable holding the number of data to be read */\n    *sEEDataReadPointer = 0;\n  }\n}", "path": "Avem/libs/STM32_USB-FS-Device_Lib_V4.0.0/Utilities/STM32_EVAL/STM32L152_EVAL/stm32l152_eval_i2c_ee.c", "commit_date": "2016-08-10 00:00:00", "repo_name": "avem-labs/Avem", "stars": 1690, "license": "mit", "language": "c", "size": 30219}
{"docstring": "/*******************************************************************************\n* Function Name  : Resume_Init\n* Description    : Handles wake-up restoring normal operations\n* Input          : None.\n* Output         : None.\n* Return         : USB_SUCCESS.\n*******************************************************************************/\n", "func_signal": "void Resume_Init(void)", "code": "{\n  uint16_t wCNTR;\n  \n  /* ------------------ ONLY WITH BUS-POWERED DEVICES ---------------------- */\n  /* restart the clocks */\n  /* ...  */\n\n  /* CNTR_LPMODE = 0 */\n  wCNTR = _GetCNTR();\n  wCNTR &= (~CNTR_LPMODE);\n  _SetCNTR(wCNTR);    \n  \n  /* restore full power */\n  /* ... on connected devices */\n  Leave_LowPowerMode();\n\n  /* reset FSUSP bit */\n  _SetCNTR(IMR_MSK);\n\n  /* reverse suspend preparation */\n  /* ... */ \n\n}", "path": "Avem/libs/STM32_USB-FS-Device_Lib_V4.0.0/Projects/Composite_Example/src/usb_pwr.c", "commit_date": "2016-08-10 00:00:00", "repo_name": "avem-labs/Avem", "stars": 1690, "license": "mit", "language": "c", "size": 30219}
{"docstring": "/*******************************************************************************\n* Function Name  : NOR_If_Erase\n* Description    : Erase sector\n* Input          : None\n* Output         : None\n* Return         : None\n*******************************************************************************/\n", "func_signal": "uint16_t NOR_If_Erase(uint32_t Address)", "code": "{\n  /* Erase the destination memory */\n  FSMC_NOR_EraseBlock(Address & 0x00FFFFFF);    \n\n  return MAL_OK;\n}", "path": "Avem/libs/STM32_USB-FS-Device_Lib_V4.0.0/Projects/Device_Firmware_Upgrade/src/nor_if.c", "commit_date": "2016-08-10 00:00:00", "repo_name": "avem-labs/Avem", "stars": 1690, "license": "mit", "language": "c", "size": 30219}
{"docstring": "/**\n  * @brief  Wait for EEPROM Standby state\n  * @param  Device : sEE CPAL device instance\n  * @retval None\n  */\n", "func_signal": "uint32_t sEE_WaitEepromStandbyState(CPAL_DevTypeDef Device)", "code": "{   \n  sEE_DevStructures[Device]->sEE_CPALStructure->pCPAL_TransferTx = sEE_TXTransfer[Device];     \n  sEE_DevStructures[Device]->sEE_CPALStructure->pCPAL_TransferTx->wAddr1 = \\\n                            (uint32_t)((uint8_t)sEE_DevStructures[Device]->sEEAddress);\n  \n  return CPAL_I2C_IsDeviceReady(sEE_DevStructures[Device]->sEE_CPALStructure);\n}", "path": "Avem/libs/STM32_USB-FS-Device_Lib_V4.0.0/Utilities/STM32_EVAL/STM32303C_EVAL/stm32303c_eval_i2c_ee_cpal.c", "commit_date": "2016-08-10 00:00:00", "repo_name": "avem-labs/Avem", "stars": 1690, "license": "mit", "language": "c", "size": 30219}
{"docstring": "/*******************************************************************************\n* Function Name  : NOR_If_Init\n* Description    : Initializes the Media on the STM32\n* Input          : None\n* Output         : None\n* Return         : None\n*******************************************************************************/\n", "func_signal": "uint16_t NOR_If_Init(void)", "code": "{\n  /* Configure FSMC Bank1 NOR/SRAM2 */\n  FSMC_NOR_Init();\n\n  /* Enable FSMC Bank1 NOR/SRAM2 */\n  FSMC_NORSRAMCmd(FSMC_Bank1_NORSRAM2, ENABLE);\n\n  return MAL_OK;\n}", "path": "Avem/libs/STM32_USB-FS-Device_Lib_V4.0.0/Projects/Device_Firmware_Upgrade/src/nor_if.c", "commit_date": "2016-08-10 00:00:00", "repo_name": "avem-labs/Avem", "stars": 1690, "license": "mit", "language": "c", "size": 30219}
{"docstring": "/*******************************************************************************\n* Function Name  : PowerOn\n* Description    :\n* Input          : None.\n* Output         : None.\n* Return         : USB_SUCCESS.\n*******************************************************************************/\n", "func_signal": "RESULT PowerOn(void)", "code": "{\n  uint16_t wRegVal;\n\n  /*** cable plugged-in ? ***/\n  USB_Cable_Config(ENABLE);\n\n  /*** CNTR_PWDN = 0 ***/\n  wRegVal = CNTR_FRES;\n  _SetCNTR(wRegVal);\n\n  /*** CNTR_FRES = 0 ***/\n  wInterrupt_Mask = 0;\n  _SetCNTR(wInterrupt_Mask);\n  /*** Clear pending interrupts ***/\n  _SetISTR(0);\n  /*** Set interrupt mask ***/\n  wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM;\n  _SetCNTR(wInterrupt_Mask);\n  \n  return USB_SUCCESS;\n}", "path": "Avem/libs/STM32_USB-FS-Device_Lib_V4.0.0/Projects/Composite_Example/src/usb_pwr.c", "commit_date": "2016-08-10 00:00:00", "repo_name": "avem-labs/Avem", "stars": 1690, "license": "mit", "language": "c", "size": 30219}
{"docstring": "/**\n  * @brief  Handle EEPROM Read operation \n  * @param  Device : sEE CPAL device instance\n  * @retval None\n  */\n", "func_signal": "uint32_t sEE_ReadHandler(CPAL_DevTypeDef Device)", "code": "{  \n  if (sEE_DevStructures[Device]->sEEState != sEE_STATE_ERROR)\n  {\n    /* Reset EEPROM State */\n    sEE_DevStructures[Device]->sEEState = sEE_STATE_IDLE;\n  }\n  \n  return CPAL_PASS;\n}", "path": "Avem/libs/STM32_USB-FS-Device_Lib_V4.0.0/Utilities/STM32_EVAL/STM32303C_EVAL/stm32303c_eval_i2c_ee_cpal.c", "commit_date": "2016-08-10 00:00:00", "repo_name": "avem-labs/Avem", "stars": 1690, "license": "mit", "language": "c", "size": 30219}
{"docstring": "/**\n  * @brief  This function handles the DMA Tx Channel interrupt Handler.\n  * @param  None\n  * @retval None\n  */\n", "func_signal": "void sEE_I2C_DMA_TX_IRQHandler(void)", "code": "{\n  /* Check if the DMA transfer is complete */\n  if(DMA_GetFlagStatus(sEE_I2C_DMA_FLAG_TX_TC) != RESET)\n  {  \n    /* Disable the DMA Tx Channel and Clear all its Flags */  \n    DMA_Cmd(sEE_I2C_DMA_CHANNEL_TX, DISABLE);\n    DMA_ClearFlag(sEE_I2C_DMA_FLAG_TX_GL);\n\n    /*!< Wait till all data have been physically transferred on the bus */\n    sEETimeout = sEE_LONG_TIMEOUT;\n    while(!I2C_GetFlagStatus(sEE_I2C, I2C_FLAG_BTF))\n    {\n      if((sEETimeout--) == 0) sEE_TIMEOUT_UserCallback();\n    }\n    \n    /*!< Send STOP condition */\n    I2C_GenerateSTOP(sEE_I2C, ENABLE);\n    \n    /* Reset the variable holding the number of data to be written */\n    *sEEDataWritePointer = 0;  \n  }\n}", "path": "Avem/libs/STM32_USB-FS-Device_Lib_V4.0.0/Utilities/STM32_EVAL/STM32L152_EVAL/stm32l152_eval_i2c_ee.c", "commit_date": "2016-08-10 00:00:00", "repo_name": "avem-labs/Avem", "stars": 1690, "license": "mit", "language": "c", "size": 30219}
{"docstring": "/**\n  * @brief  Wait for EEPROM Standby state.\n  * \n  * @note  This function allows to wait and check that EEPROM has finished the \n  *        last operation. It is mostly used after Write operation: after receiving\n  *        the buffer to be written, the EEPROM may need additional time to actually\n  *        perform the write operation. During this time, it doesn't answer to\n  *        I2C packets addressed to it. Once the write operation is complete\n  *        the EEPROM responds to its address.\n  * \n  * @param  None\n  * @retval sEE_OK (0) if operation is correctly performed, else return value \n  *         different from sEE_OK (0) or the timeout user callback.\n  */\n", "func_signal": "uint32_t sEE_WaitEepromStandbyState(void)", "code": "{\n  __IO uint16_t tmpSR1 = 0;\n  __IO uint32_t sEETrials = 0;\n\n  /*!< While the bus is busy */\n  sEETimeout = sEE_LONG_TIMEOUT;\n  while(I2C_GetFlagStatus(sEE_I2C, I2C_FLAG_BUSY))\n  {\n    if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();\n  }\n\n  /* Keep looping till the slave acknowledge his address or maximum number \n     of trials is reached (this number is defined by sEE_MAX_TRIALS_NUMBER define\n     in stm32l152_eval_i2c_ee.h file) */\n  while (1)\n  {\n    /*!< Send START condition */\n    I2C_GenerateSTART(sEE_I2C, ENABLE);\n\n    /*!< Test on EV5 and clear it */\n    sEETimeout = sEE_FLAG_TIMEOUT;\n    while(!I2C_CheckEvent(sEE_I2C, I2C_EVENT_MASTER_MODE_SELECT))\n    {\n      if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();\n    }    \n\n    /*!< Send EEPROM address for write */\n    I2C_Send7bitAddress(sEE_I2C, sEEAddress, I2C_Direction_Transmitter);\n    \n    /* Wait for ADDR flag to be set (Slave acknowledged his address) */\n    sEETimeout = sEE_LONG_TIMEOUT;\n    do\n    {     \n      /* Get the current value of the SR1 register */\n      tmpSR1 = sEE_I2C->SR1;\n      \n      /* Update the timeout value and exit if it reach 0 */\n      if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();\n    }\n    /* Keep looping till the Address is acknowledged or the AF flag is \n       set (address not acknowledged at time) */\n    while((tmpSR1 & (I2C_SR1_ADDR | I2C_SR1_AF)) == 0);\n     \n    /* Check if the ADDR flag has been set */\n    if (tmpSR1 & I2C_SR1_ADDR)\n    {\n      /* Clear ADDR Flag by reading SR1 then SR2 registers (SR1 have already \n         been read) */\n      (void)sEE_I2C->SR2;\n      \n      /*!< STOP condition */    \n      I2C_GenerateSTOP(sEE_I2C, ENABLE);\n        \n      /* Exit the function */\n      return sEE_OK;\n    }\n    else\n    {\n      /*!< Clear AF flag */\n      I2C_ClearFlag(sEE_I2C, I2C_FLAG_AF);                  \n    }\n    \n    /* Check if the maximum allowed numbe of trials has bee reached */\n    if (sEETrials++ == sEE_MAX_TRIALS_NUMBER)\n    {\n      /* If the maximum number of trials has been reached, exit the function */\n      return sEE_TIMEOUT_UserCallback();\n    }\n  }\n}", "path": "Avem/libs/STM32_USB-FS-Device_Lib_V4.0.0/Utilities/STM32_EVAL/STM32L152_EVAL/stm32l152_eval_i2c_ee.c", "commit_date": "2016-08-10 00:00:00", "repo_name": "avem-labs/Avem", "stars": 1690, "license": "mit", "language": "c", "size": 30219}
{"docstring": "/**\n  * @brief  Configures the System clock source, PLL Multiplier and Divider factors,\n  *               AHB/APBx prescalers and Flash settings\n  * @note   This function should be called only once the RCC clock configuration  \n  *         is reset to the default reset state (done in SystemInit() function).             \n  * @param  None\n  * @retval None\n  */\n", "func_signal": "static void SetSysClock(void)", "code": "{\n  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;\n\n/******************************************************************************/\n/*            PLL (clocked by HSE) used as System clock source                */\n/******************************************************************************/\n\n  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration -----------*/\n  /* Enable HSE */\n  RCC->CR |= ((uint32_t)RCC_CR_HSEON);\n \n  /* Wait till HSE is ready and if Time out is reached exit */\n  do\n  {\n    HSEStatus = RCC->CR & RCC_CR_HSERDY;\n    StartUpCounter++;\n  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));\n\n  if ((RCC->CR & RCC_CR_HSERDY) != RESET)\n  {\n    HSEStatus = (uint32_t)0x01;\n  }\n  else\n  {\n    HSEStatus = (uint32_t)0x00;\n  }\n\n  if (HSEStatus == (uint32_t)0x01)\n  {\n    /* Enable Prefetch Buffer and set Flash Latency */\n    FLASH->ACR = FLASH_ACR_PRFTBE | (uint32_t)FLASH_ACR_LATENCY_1;\n \n     /* HCLK = SYSCLK / 1 */\n     RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;\n       \n     /* PCLK2 = HCLK / 1 */\n     RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;\n     \n     /* PCLK1 = HCLK / 2 */\n     RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;\n\n    /* PLL configuration */\n    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL));\n    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_PREDIV1 | RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLMULL9);\n\n    /* Enable PLL */\n    RCC->CR |= RCC_CR_PLLON;\n\n    /* Wait till PLL is ready */\n    while((RCC->CR & RCC_CR_PLLRDY) == 0)\n    {\n    }\n    \n    /* Select PLL as system clock source */\n    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));\n    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;\n\n    /* Wait till PLL is used as system clock source */\n    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)RCC_CFGR_SWS_PLL)\n    {\n    }\n  }\n  else\n  { /* If HSE fails to start-up, the application will have wrong clock\n         configuration. User can add here some code to deal with this error */\n  }\n}", "path": "Avem/libs/STM32_USB-FS-Device_Lib_V4.0.0/Projects/VirtualComport_Loopback/src/system_stm32f30x.c", "commit_date": "2016-08-10 00:00:00", "repo_name": "avem-labs/Avem", "stars": 1690, "license": "mit", "language": "c", "size": 30219}
{"docstring": "/*-------------------------------------------------------------------------\npassArgs_ARM7\nCopies the command line arguments to the end of the ARM9 binary,\nthen sets a flag in memory for the loaded NDS to use\n--------------------------------------------------------------------------*/\n", "func_signal": "static void passArgs_ARM7 (void)", "code": "{\n\tu32 ARM9_DST = *((u32*)(NDS_HEADER + 0x028));\n\tu32 ARM9_LEN = *((u32*)(NDS_HEADER + 0x02C));\n\tu32* argSrc;\n\tu32* argDst;\n\n\tif (!argStart || !argSize) return;\n\n\targSrc = (u32*)(argStart + (int)&_start);\n\n\targDst = (u32*)((ARM9_DST + ARM9_LEN + 3) & ~3);\t\t// Word aligned\n\n\tcopyLoop(argDst, argSrc, argSize);\n\n\t__system_argv->argvMagic = ARGV_MAGIC;\n\t__system_argv->commandLine = (char*)argDst;\n\t__system_argv->length = argSize;\n}", "path": "nds-bootstrap/hb/bootloader/source/arm7/main.arm7.c", "commit_date": "2020-06-22 00:00:00", "repo_name": "DS-Homebrew/nds-bootstrap", "stars": 1105, "license": "gpl-3.0", "language": "c", "size": 23485}
{"docstring": "//fs functs\n", "func_signal": "int nitroFSOpen(struct _reent *r, void *fileStruct, const char *path, int flags, int mode)", "code": "{\n    struct nitroFSStruct *fatStruct = (struct nitroFSStruct *)fileStruct;\n    struct nitroDIRStruct dirStruct;\n    DIR_ITER dirState;\n    dirState.dirStruct = &dirStruct; //create a temp dirstruct\n    struct _reent dre;\n    struct stat st;                     //all these are just used for reading the dir ~_~\n    char dirfilename[NITROMAXPATHLEN];  // to hold a full path (i tried to avoid using so much stack but blah :/)\n    char *filename;                     // to hold filename\n    char *cptr;                         //used to string searching and manipulation\n    cptr = (char *)path + strlen(path); //find the end...\n    filename = NULL;\n    do\n    {\n        if ((*cptr == '/') || (*cptr == ':'))\n        { // split at either / or : (whichever comes first form the end!)\n            cptr++;\n            strncpy(dirfilename, path, cptr - path); //copy string up till and including/ or : zero rest\n            dirfilename[cptr - path] = 0;            //it seems strncpy doesnt always zero?!\n            filename = cptr;                         //filename = now remainder of string\n            break;\n        }\n    } while (cptr-- != path); //search till start\n    if (!filename)\n    {                            //we didnt find a / or : ? shouldnt realyl happen but if it does...\n        filename = (char *)path; //filename = complete path\n        dirfilename[0] = 0;      //make directory path \"\"\n    }\n    if (nitroFSDirOpen(&dre, &dirState, dirfilename))\n    {\n        fatStruct->start = 0;\n        while (nitroFSDirNext(&dre, &dirState, dirfilename, &st) == 0)\n        {\n            if (!(st.st_mode & S_IFDIR) && (strcmp(dirfilename, filename) == 0))\n            { //Found the *file* youre looking for!!\n                fatStruct->start = dirStruct.romfat.top;\n                fatStruct->end = dirStruct.romfat.bottom;\n                if (hasLoader)\n                {\n                    fatStruct->start += LOADEROFFSET;\n                    fatStruct->end += LOADEROFFSET;\n                }\n                break;\n            }\n        }\n        if (fatStruct->start)\n        {\n            nitroSubSeek(&fatStruct->pos, fatStruct->start, SEEK_SET); //seek to start of file\n            return (0);                                                //woot!\n        }\n        nitroFSDirClose(&dre, &dirState);\n    }\n    if (r->_errno == 0)\n    {\n        r->_errno = ENOENT;\n    }\n    return (-1); //teh fail\n}", "path": "nds-bootstrap/retail/arm9/source/nitrofs.c", "commit_date": "2019-08-24 00:00:00", "repo_name": "DS-Homebrew/nds-bootstrap", "stars": 1105, "license": "gpl-3.0", "language": "c", "size": 23485}
{"docstring": "//Figure out if its gba or ds, setup stuff\n", "func_signal": "int __itcm\nnitroFSInit(const char *ndsfile)", "code": "{\n    off_t pos = 0;\n    char romstr[0x10];\n    chdirpathid = NITROROOT;\n    ndsFileLastpos = 0;\n    ndsFile = NULL;\n    if (ndsfile != NULL)\n    {\n        if ((ndsFile = fopen(ndsfile, \"rb\")))\n        {\n            nitroSubRead(&pos, romstr, strlen(LOADERSTR));\n            if (strncmp(romstr, LOADERSTR, strlen(LOADERSTR)) == 0)\n            {\n                nitroSubSeek(&pos, LOADEROFFSET + FNTOFFSET, SEEK_SET);\n                nitroSubRead(&pos, &fntOffset, sizeof(fntOffset));\n                nitroSubSeek(&pos, LOADEROFFSET + FATOFFSET, SEEK_SET);\n                nitroSubRead(&pos, &fatOffset, sizeof(fatOffset));\n                fatOffset += LOADEROFFSET;\n                fntOffset += LOADEROFFSET;\n                hasLoader = true;\n            }\n            else\n            {\n                nitroSubSeek(&pos, FNTOFFSET, SEEK_SET);\n                nitroSubRead(&pos, &fntOffset, sizeof(fntOffset));\n                nitroSubSeek(&pos, FATOFFSET, SEEK_SET);\n                nitroSubRead(&pos, &fatOffset, sizeof(fatOffset));\n                hasLoader = false;\n            }\n            setvbuf(ndsFile, NULL, _IONBF, 0); //we dont need double buffs u_u\n            AddDevice(&nitroFSdevoptab);\n            return (1);\n        }\n    }\n    REG_EXMEMCNT &= ~ARM7_OWNS_CARD; //give us gba slot ownership\n    if (strncmp(((const char *)GBAROM) + LOADERSTROFFSET, LOADERSTR, strlen(LOADERSTR)) == 0)\n    { // We has gba rahm\n        printf(\"yes i think this is GBA?!\\n\");\n        if (strncmp(((const char *)GBAROM) + LOADERSTROFFSET + LOADEROFFSET, LOADERSTR, strlen(LOADERSTR)) == 0)\n        { //Look for second magic string, if found its a sc.nds or nds.gba\n            printf(\"sc/gba\\n\");\n            fntOffset = ((u32) * (u32 *)(((const char *)GBAROM) + FNTOFFSET + LOADEROFFSET)) + LOADEROFFSET;\n            fatOffset = ((u32) * (u32 *)(((const char *)GBAROM) + FATOFFSET + LOADEROFFSET)) + LOADEROFFSET;\n            hasLoader = true;\n            AddDevice(&nitroFSdevoptab);\n            return (1);\n        }\n        else\n        { //Ok, its not a .gba build, so must be emulator\n            printf(\"gba, must be emu\\n\");\n            fntOffset = ((u32) * (u32 *)(((const char *)GBAROM) + FNTOFFSET));\n            fatOffset = ((u32) * (u32 *)(((const char *)GBAROM) + FATOFFSET));\n            hasLoader = false;\n            AddDevice(&nitroFSdevoptab);\n            return (1);\n        }\n    }\n    return (0);\n}", "path": "nds-bootstrap/retail/arm9/source/nitrofs.c", "commit_date": "2019-08-24 00:00:00", "repo_name": "DS-Homebrew/nds-bootstrap", "stars": 1105, "license": "gpl-3.0", "language": "c", "size": 23485}
{"docstring": "/* return true if the command is completed and false if it is still ongoing */\n", "func_signal": "static bool sdmmc_check_command_ndma(struct mmcdevice *ctx, u32 cmd, int ndmaSlot)", "code": "{\n\tconst bool getSDRESP = (cmd << 15) >> 31;\n    u16 flags = (cmd << 15) >> 31;\n\tconst bool readdata = cmd & 0x20000;\n\tconst bool writedata = cmd & 0x40000;\n\n\tif(readdata || writedata)\n\t{\n\t\tflags |= TMIO_STAT0_DATAEND;\n\t}\n    u16 status0 = 0;\n\n    volatile u16 status1 = sdmmc_read16(REG_SDSTATUS1);\n\n    if(status1 & TMIO_MASK_GW)\n\t{\n\t\tctx->error |= 4;\n\n        ctx->stat0 = sdmmc_read16(REG_SDSTATUS0);\n      \tctx->stat1 = sdmmc_read16(REG_SDSTATUS1);\n      \tsdmmc_write16(REG_SDSTATUS0,0);\n      \tsdmmc_write16(REG_SDSTATUS1,0);\n\n      \tif(getSDRESP != 0)\n      \t{\n      \t\tctx->ret[0] = (u32)(sdmmc_read16(REG_SDRESP0) | (sdmmc_read16(REG_SDRESP1) << 16));\n      \t\tctx->ret[1] = (u32)(sdmmc_read16(REG_SDRESP2) | (sdmmc_read16(REG_SDRESP3) << 16));\n      \t\tctx->ret[2] = (u32)(sdmmc_read16(REG_SDRESP4) | (sdmmc_read16(REG_SDRESP5) << 16));\n      \t\tctx->ret[3] = (u32)(sdmmc_read16(REG_SDRESP6) | (sdmmc_read16(REG_SDRESP7) << 16));\n      \t}\n        *(u32*)(0x400411C+(ndmaSlot*0x1C)) = 0x48064000;\n        return true;\n    }\n\n    if(!(status1 & TMIO_STAT1_CMD_BUSY))\n\t{\n\t\tstatus0 = sdmmc_read16(REG_SDSTATUS0);\n\t\tif(sdmmc_read16(REG_SDSTATUS0) & TMIO_STAT0_CMDRESPEND)\n\t\t{\n\t\t\tctx->error |= 0x1;\n\t\t}\n\t\tif(status0 & TMIO_STAT0_DATAEND)\n\t\t{\n\t\t\tctx->error |= 0x2;\n\t\t}\n\n        if((status0 & flags) != flags)\n        {\n            return false;\n        }\n\n        ctx->stat0 = sdmmc_read16(REG_SDSTATUS0);\n      \tctx->stat1 = sdmmc_read16(REG_SDSTATUS1);\n      \tsdmmc_write16(REG_SDSTATUS0,0);\n      \tsdmmc_write16(REG_SDSTATUS1,0);\n\n      \tif(getSDRESP != 0)\n      \t{\n      \t\tctx->ret[0] = (u32)(sdmmc_read16(REG_SDRESP0) | (sdmmc_read16(REG_SDRESP1) << 16));\n      \t\tctx->ret[1] = (u32)(sdmmc_read16(REG_SDRESP2) | (sdmmc_read16(REG_SDRESP3) << 16));\n      \t\tctx->ret[2] = (u32)(sdmmc_read16(REG_SDRESP4) | (sdmmc_read16(REG_SDRESP5) << 16));\n      \t\tctx->ret[3] = (u32)(sdmmc_read16(REG_SDRESP6) | (sdmmc_read16(REG_SDRESP7) << 16));\n      \t}\n        *(u32*)(0x400411C+(ndmaSlot*0x1C)) = 0x48004000;\n        return true;\n\t} else return false;\n}", "path": "nds-bootstrap/hb/common/source/my_sdmmc.c", "commit_date": "2020-05-13 00:00:00", "repo_name": "DS-Homebrew/nds-bootstrap", "stars": 1105, "license": "gpl-3.0", "language": "c", "size": 23485}
{"docstring": "/*\n * decrypt_arm9\n */\n", "func_signal": "bool decrypt_arm9ntr(const tDSiHeader* dsiHeader)", "code": "{\n\t// Decrypt NDS secure area\n\tu32 *p = (u32*)dsiHeader->ndshdr.arm9destination;\n\n\tif (p[0] == 0 || (p[0] == 0xE7FFDEFF && p[1] == 0xE7FFDEFF)) {\n\t\treturn false;\n\t}\n\n\tu32 cardheader_gamecode = *(u32*)dsiHeader->ndshdr.gameCode;\n\n\tinit1(cardheader_gamecode);\n\tdecrypt(card_hash, p+1, p);\n\targ2[1] <<= 1;\n\targ2[2] >>= 1;\t\n\tinit2(card_hash, arg2);\n\tdecrypt(card_hash, p+1, p);\n\n\tif (p[0] == MAGIC30 && p[1] == MAGIC34)\n\t{\n\t\t*p++ = 0xE7FFDEFF;\n\t\t*p++ = 0xE7FFDEFF;\n\t}\n\telse p+=2;\n\tu32 size = 0x800 - 8;\n\twhile (size > 0)\n\t{\n\t\tdecrypt(card_hash, p+1, p);\n\t\tp += 2;\n\t\tsize -= 8;\n\t}\n\n\treturn true;\n}", "path": "nds-bootstrap/retail/bootloader/source/arm7/decompress.c", "commit_date": "2020-03-20 00:00:00", "repo_name": "DS-Homebrew/nds-bootstrap", "stars": 1105, "license": "gpl-3.0", "language": "c", "size": 23485}
{"docstring": "//seek around\n", "func_signal": "inline void nitroSubSeek(off_t *npos, int pos, int dir)", "code": "{\n    if ((dir == SEEK_SET) || (dir == SEEK_END)) //otherwise just set the pos :)\n        *npos = pos;\n    else if (dir == SEEK_CUR)\n        *npos += pos; //see ez!\n}", "path": "nds-bootstrap/retail/arm9/source/nitrofs.c", "commit_date": "2019-08-24 00:00:00", "repo_name": "DS-Homebrew/nds-bootstrap", "stars": 1105, "license": "gpl-3.0", "language": "c", "size": 23485}
{"docstring": "/*-----------------------------------------------------------------\nFAT_NextCluster\nInternal function - gets the cluster linked from input cluster\n-----------------------------------------------------------------*/\n", "func_signal": "u32 FAT_NextCluster(u32 cluster, int ndmaSlot)", "code": "{\n\tu32 nextCluster = CLUSTER_FREE;\n\tu32 sector;\n\tint offset;\n\n\n\tswitch (discFileSystem)\n\t{\n\t\tcase FS_UNKNOWN:\n\t\t\tnextCluster = CLUSTER_FREE;\n\t\t\tbreak;\n\n\t\tcase FS_FAT12:\n\t\t\tsector = discFAT + (((cluster * 3) / 2) / BYTES_PER_SECTOR);\n\t\t\toffset = ((cluster * 3) / 2) % BYTES_PER_SECTOR;\n\t\t\tCARD_ReadSector(sector, globalBuffer, 0, 0);\n\t\t\tnextCluster = ((u8*) globalBuffer)[offset];\n\t\t\toffset++;\n\n\t\t\tif (offset >= BYTES_PER_SECTOR) {\n\t\t\t\toffset = 0;\n\t\t\t\tsector++;\n\t\t\t}\n\n\t\t\tCARD_ReadSector(sector, globalBuffer, 0, 0);\n\t\t\tnextCluster |= (((u8*) globalBuffer)[offset]) << 8;\n\n\t\t\tif (cluster & 0x01) {\n\t\t\t\tnextCluster = nextCluster >> 4;\n\t\t\t} else \t{\n\t\t\t\tnextCluster &= 0x0FFF;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase FS_FAT16:\n\t\t\tsector = discFAT + ((cluster << 1) / BYTES_PER_SECTOR);\n\t\t\toffset = cluster % (BYTES_PER_SECTOR >> 1);\n\n\t\t\tCARD_ReadSector(sector, globalBuffer, 0, 0);\n\t\t\t// read the nextCluster value\n\t\t\tnextCluster = ((u16*)globalBuffer)[offset];\n\n\t\t\tif (nextCluster >= 0xFFF7)\n\t\t\t{\n\t\t\t\tnextCluster = CLUSTER_EOF;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase FS_FAT32:\n\t\t\tsector = discFAT + ((cluster << 2) / BYTES_PER_SECTOR);\n\t\t\toffset = cluster % (BYTES_PER_SECTOR >> 2);\n\n\t\t\tCARD_ReadSector(sector, globalBuffer, 0, 0);\n\t\t\t// read the nextCluster value\n\t\t\tnextCluster = (((u32*)globalBuffer)[offset]) & 0x0FFFFFFF;\n\n\t\t\tif (nextCluster >= 0x0FFFFFF7)\n\t\t\t{\n\t\t\t\tnextCluster = CLUSTER_EOF;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tnextCluster = CLUSTER_FREE;\n\t\t\tbreak;\n\t}\n\n\treturn nextCluster;\n}", "path": "nds-bootstrap/hb/common/source/my_fat.c", "commit_date": "2020-05-13 00:00:00", "repo_name": "DS-Homebrew/nds-bootstrap", "stars": 1105, "license": "gpl-3.0", "language": "c", "size": 23485}
{"docstring": "/*-----------------------------------------------------------------\ngetBootFileCluster\n-----------------------------------------------------------------*/\n", "func_signal": "aFile getBootFileCluster (const char* bootName, int ndmaSlot)", "code": "{\n\tDIR_ENT dir;\n\tint firstSector = 0;\n\tbool notFound = false;\n\tbool found = false;\n//\tint maxSectors;\n\tu32 wrkDirCluster = discRootDirClus;\n\tu32 wrkDirSector = 0;\n\tint wrkDirOffset = 0;\n\tint nameOffset;\n\taFile file;\n\n\tdir.startCluster = CLUSTER_FREE; // default to no file found\n\tdir.startClusterHigh = CLUSTER_FREE;\n\n\n\t// Check if fat has been initialised\n\tif (discBytePerSec == 0)\n\t{\n\t\t#ifdef DEBUG\n\t\tnocashMessage(\"getBootFileCluster  fat not initialised\");\n\t\t#endif\n\n\t\tfile.firstCluster = CLUSTER_FREE;\n\t\tfile.currentCluster = file.firstCluster;\n\t\tfile.currentOffset=0;\n\t\treturn file;\n\t}\n\n\tchar *ptr = (char*)bootName;\n\twhile (*ptr != '.') ptr++;\n\tint namelen = ptr - bootName;\n\n//\tmaxSectors = (wrkDirCluster == FAT16_ROOT_DIR_CLUSTER ? (discData - discRootDir) : discSecPerClus);\n\t// Scan Dir for correct entry\n\tfirstSector = discRootDir;\n\tCARD_ReadSector (firstSector + wrkDirSector, globalBuffer, 0, 0);\n\tfound = false;\n\tnotFound = false;\n\twrkDirOffset = -1;\t// Start at entry zero, Compensating for increment\n\twhile (!found && !notFound) {\n\t\twrkDirOffset++;\n\t\tif (wrkDirOffset == BYTES_PER_SECTOR / sizeof (DIR_ENT))\n\t\t{\n\t\t\twrkDirOffset = 0;\n\t\t\twrkDirSector++;\n\t\t\tif ((wrkDirSector == discSecPerClus) && (wrkDirCluster != FAT16_ROOT_DIR_CLUSTER))\n\t\t\t{\n\t\t\t\twrkDirSector = 0;\n\t\t\t\twrkDirCluster = FAT_NextCluster(wrkDirCluster, ndmaSlot);\n\t\t\t\tif (wrkDirCluster == CLUSTER_EOF)\n\t\t\t\t{\n\t\t\t\t\tnotFound = true;\n\t\t\t\t}\n\t\t\t\tfirstSector = FAT_ClustToSect(wrkDirCluster);\n\t\t\t}\n\t\t\telse if ((wrkDirCluster == FAT16_ROOT_DIR_CLUSTER) && (wrkDirSector == (discData - discRootDir)))\n\t\t\t{\n\t\t\t\tnotFound = true;\t// Got to end of root dir\n\t\t\t}\n\t\t\tCARD_ReadSector (firstSector + wrkDirSector, globalBuffer, 0, 0);\n\t\t}\n\t\tdir = ((DIR_ENT*) globalBuffer)[wrkDirOffset];\n\t\tfound = true;\n\t\tif ((dir.attrib & ATTRIB_DIR) || (dir.attrib & ATTRIB_VOL))\n\t\t{\n\t\t\tfound = false;\n\t\t}\n\t\tif(namelen<8 && dir.name[namelen]!=0x20) found = false;\n\t\tfor (nameOffset = 0; nameOffset < namelen && found; nameOffset++)\n\t\t{\n\t\t\tif (ucase(dir.name[nameOffset]) != bootName[nameOffset])\n\t\t\t\tfound = false;\n\t\t}\n\t\tfor (nameOffset = 0; nameOffset < 3 && found; nameOffset++)\n\t\t{\n\t\t\tif (ucase(dir.ext[nameOffset]) != bootName[nameOffset+namelen+1])\n\t\t\t\tfound = false;\n\t\t}\n\t\tif (dir.name[0] == FILE_LAST)\n\t\t{\n\t\t\tnotFound = true;\n\t\t}\n\t}\n\n\t// If no file is found, return CLUSTER_FREE\n\tif (notFound)\n\t{\n\t\t#ifdef DEBUG\n\t\tnocashMessage(\"getBootFileCluster  notFound\");\n\t\t#endif\n\n\t\tfile.firstCluster = CLUSTER_FREE;\n\t\tfile.currentCluster = file.firstCluster;\n\t\tfile.currentOffset=0;\n\t\tfile.fatTableCached=false;\n\n\t\treturn file;\n\t}\n\n\t#ifdef DEBUG\n\tnocashMessage(\"getBootFileCluster  found\");\n\t#endif\n\n\tfile.firstCluster = (dir.startCluster | (dir.startClusterHigh << 16));\n\tfile.currentCluster = file.firstCluster;\n\tfile.currentOffset=0;\n\tfile.fatTableCached=false;\n\treturn file;\n}", "path": "nds-bootstrap/hb/common/source/my_fat.c", "commit_date": "2020-05-13 00:00:00", "repo_name": "DS-Homebrew/nds-bootstrap", "stars": 1105, "license": "gpl-3.0", "language": "c", "size": 23485}
{"docstring": "/*-------------------------------------------------------------------------\nresetMemory_ARM7\nClears all of the NDS's RAM that is visible to the ARM7\nWritten by Darkain.\nModified by Chishm:\n * Added STMIA clear mem loop\n--------------------------------------------------------------------------*/\n", "func_signal": "static void resetMemory_ARM7 (void)", "code": "{\n\tint i;\n\tu8 settings1, settings2;\n\tu32 settingsOffset = 0;\n\n\tREG_IME = 0;\n\n\tfor (i=0; i<16; i++) {\n\t\tSCHANNEL_CR(i) = 0;\n\t\tSCHANNEL_TIMER(i) = 0;\n\t\tSCHANNEL_SOURCE(i) = 0;\n\t\tSCHANNEL_LENGTH(i) = 0;\n\t}\n\n\tREG_SOUNDCNT = 0;\n\n\t//clear out ARM7 DMA channels and timers\n\tfor (i=0; i<4; i++) {\n\t\tDMA_CR(i) = 0;\n\t\tDMA_SRC(i) = 0;\n\t\tDMA_DEST(i) = 0;\n\t\tTIMER_CR(i) = 0;\n\t\tTIMER_DATA(i) = 0;\n\t}\n\n\tarm7clearRAM();\t\t\t\t\t\t\t\t// clear exclusive IWRAM\n\ttoncset((u32*)0x02004000, 0, 0x37C000);\t// clear most of EWRAM\n\ttoncset((u32*)0x02380000, 0, 0x60000);\n\ttoncset((u32*)0x023F1000, 0, 0xF000);\n\tif (romIsCompressed) {\n\t\ttoncset((u32*)0x02D00000, 0, 0x300000);\t// clear other part of EWRAM\n\t} else {\n\t\ttoncset((u32*)0x02400000, 0, 0xC00000);\t// clear other part of EWRAM\n\t}\n\n\tREG_IE = 0;\n\tREG_IF = ~0;\n\t(*(vu32*)(0x04000000-4)) = 0;  //IRQ_HANDLER ARM7 version\n\t(*(vu32*)(0x04000000-8)) = ~0; //VBLANK_INTR_WAIT_FLAGS, ARM7 version\n\tREG_POWERCNT = 1;  //turn off power to stuff\n\n\t// Get settings location\n\tboot_readFirmware((u32)0x00020, (u8*)&settingsOffset, 0x2);\n\tsettingsOffset *= 8;\n\n\t// Reload DS Firmware settings\n\tboot_readFirmware(settingsOffset + 0x070, &settings1, 0x1);\n\tboot_readFirmware(settingsOffset + 0x170, &settings2, 0x1);\n\n\tif ((settings1 & 0x7F) == ((settings2+1) & 0x7F)) {\n\t\tboot_readFirmware(settingsOffset + 0x000, (u8*)(NDS_HEADER-0x180), 0x70);\n\t} else {\n\t\tboot_readFirmware(settingsOffset + 0x100, (u8*)(NDS_HEADER-0x180), 0x70);\n\t}\n\n\tif ((*(u8*)0x02000400 & 0x0F) && (*(u8*)0x02000401 == 0) && (*(u8*)0x02000402 == 0) && (*(u8*)0x02000404 == 0) && (language == 0xFF || language == -1)) {\n\t\tlanguage = *(u8*)0x02000406;\n\t}\n\n\tif (language >= 0 && language <= 7) {\n\t\t// Change language\n\t\t*(u8*)((u32)NDS_HEADER - 0x11C) = language;\n\t}\n}", "path": "nds-bootstrap/hb/bootloader/source/arm7/main.arm7.c", "commit_date": "2020-06-22 00:00:00", "repo_name": "DS-Homebrew/nds-bootstrap", "stars": 1105, "license": "gpl-3.0", "language": "c", "size": 23485}
{"docstring": "//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n// Main function\n", "func_signal": "static u32 quickFind (const unsigned char* data, const unsigned char* search, u32 dataLen, u32 searchLen)", "code": "{\n\tconst int* dataChunk = (const int*) data;\n\tint searchChunk = ((const int*)search)[0];\n\tu32 i;\n\tu32 dataChunkEnd = (u32)(dataLen / sizeof(int));\n\n\tfor ( i = 0; i < dataChunkEnd; i++) {\n\t\tif (dataChunk[i] == searchChunk) {\n\t\t\tif ((i*sizeof(int) + searchLen) > dataLen) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (memcmp (&data[i*sizeof(int)], search, searchLen) == 0) {\n\t\t\t\treturn i*sizeof(int);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}", "path": "nds-bootstrap/hb/bootloader/source/arm7/main.arm7.c", "commit_date": "2020-06-22 00:00:00", "repo_name": "DS-Homebrew/nds-bootstrap", "stars": 1105, "license": "gpl-3.0", "language": "c", "size": 23485}
{"docstring": "/* return true if the command is completed and false if it is still ongoing */\n", "func_signal": "static bool sdmmc_check_command_ndma(struct mmcdevice *ctx, u32 cmd, int ndmaSlot)", "code": "{\n\tconst bool getSDRESP = (cmd << 15) >> 31;\n    u16 flags = (cmd << 15) >> 31;\n\tconst bool readdata = cmd & 0x20000;\n\tconst bool writedata = cmd & 0x40000;\n\n\tif(readdata || writedata)\n\t{\n\t\tflags |= TMIO_STAT0_DATAEND;\n\t}    \n    u16 status0 = 0;\n    \n    volatile u16 status1 = sdmmc_read16(REG_SDSTATUS1);\n    \n    if(status1 & TMIO_MASK_GW)\n\t{\n\t\tctx->error |= 4;\n\n        ctx->stat0 = sdmmc_read16(REG_SDSTATUS0);\n      \tctx->stat1 = sdmmc_read16(REG_SDSTATUS1);\n      \tsdmmc_write16(REG_SDSTATUS0,0);\n      \tsdmmc_write16(REG_SDSTATUS1,0);\n      \n      \tif(getSDRESP != 0)\n      \t{\n      \t\tctx->ret[0] = (u32)(sdmmc_read16(REG_SDRESP0) | (sdmmc_read16(REG_SDRESP1) << 16));\n      \t\tctx->ret[1] = (u32)(sdmmc_read16(REG_SDRESP2) | (sdmmc_read16(REG_SDRESP3) << 16));\n      \t\tctx->ret[2] = (u32)(sdmmc_read16(REG_SDRESP4) | (sdmmc_read16(REG_SDRESP5) << 16));\n      \t\tctx->ret[3] = (u32)(sdmmc_read16(REG_SDRESP6) | (sdmmc_read16(REG_SDRESP7) << 16));\n      \t}\n        *(u32*)(0x400411C+(ndmaSlot*0x1C)) = 0x48064000;\n        return true;    \n    }        \n    \n    if(!(status1 & TMIO_STAT1_CMD_BUSY))\n\t{\n\t\tstatus0 = sdmmc_read16(REG_SDSTATUS0);        \n\t\tif(sdmmc_read16(REG_SDSTATUS0) & TMIO_STAT0_CMDRESPEND)\n\t\t{\n\t\t\tctx->error |= 0x1;\n\t\t}\n\t\tif(status0 & TMIO_STAT0_DATAEND)\n\t\t{\n\t\t\tctx->error |= 0x2;\n\t\t}\n        \n        if((status0 & flags) != flags)\n        {\n            return false;\n        }\n\t\t\n        ctx->stat0 = sdmmc_read16(REG_SDSTATUS0);\n      \tctx->stat1 = sdmmc_read16(REG_SDSTATUS1);\n      \tsdmmc_write16(REG_SDSTATUS0,0);\n      \tsdmmc_write16(REG_SDSTATUS1,0);\n      \n      \tif(getSDRESP != 0)\n      \t{\n      \t\tctx->ret[0] = (u32)(sdmmc_read16(REG_SDRESP0) | (sdmmc_read16(REG_SDRESP1) << 16));\n      \t\tctx->ret[1] = (u32)(sdmmc_read16(REG_SDRESP2) | (sdmmc_read16(REG_SDRESP3) << 16));\n      \t\tctx->ret[2] = (u32)(sdmmc_read16(REG_SDRESP4) | (sdmmc_read16(REG_SDRESP5) << 16));\n      \t\tctx->ret[3] = (u32)(sdmmc_read16(REG_SDRESP6) | (sdmmc_read16(REG_SDRESP7) << 16));\n      \t}\n        *(u32*)(0x400411C+(ndmaSlot*0x1C)) = 0x48064000; \n        return true;\n\t} else return false;\n}", "path": "nds-bootstrap/retail/common/source/my_sdmmc.c", "commit_date": "2020-10-02 00:00:00", "repo_name": "DS-Homebrew/nds-bootstrap", "stars": 1105, "license": "gpl-3.0", "language": "c", "size": 23485}
{"docstring": "// Normal DLDI file\n", "func_signal": "int arm7_main (void)", "code": "{\n\tnocashMessage(\"bootloader\");\n\n\tinitMBK();\n\n\t// Wait for ARM9 to at least start\n\twhile (arm9_stateFlag < ARM9_START);\n\n\t// Get ARM7 to clear RAM\n\tnocashMessage(\"Getting ARM7 to clear RAM...\\n\");\n\n\tresetMemory_ARM7();\n\n\t// Init card\n\tif(!FAT_InitFiles(initDisc, 0))\n\t{\n\t\tnocashMessage(\"!FAT_InitFiles\");\n\t\treturn -1;\n\t}\n\n\taFile romFile = getFileFromCluster(storedFileCluster);\n\n\tconst char* bootName = \"BOOT.NDS\";\n\n\tif ((romFile.firstCluster < CLUSTER_FIRST) || (romFile.firstCluster >= CLUSTER_EOF)) {\n\t\tromFile = getBootFileCluster(bootName, 0);\n\t}\n\n\tif (romFile.firstCluster == CLUSTER_FREE) {\n\t\tnocashMessage(\"fileCluster == CLUSTER_FREE\");\n\t\treturn -1;\n\t}\n\n\tREG_GPIO_WIFI &= BIT(8);\t// New Atheros/DSi-Wifi mode\n\n\t// Load the NDS file\n\tnocashMessage(\"Load the NDS file\");\n\tloadBinary_ARM7(romFile);\n\n\t// Patch with DLDI if desired\n\tif (wantToPatchDLDI) {\n\t\tnocashMessage(\"wantToPatchDLDI\");\n\t\tdldiPatchBinary ((u8*)((u32*)NDS_HEADER)[0x0A], ((u32*)NDS_HEADER)[0x0B], (ramDiskCluster != 0));\n\t}\n\n\tif ((ndsHeader->arm9romOffset==0x4000 && dsiFlags==0) || !dsiMode) {\n\t\tNDSTouchscreenMode();\n\t\t*(u16*)0x4000500 = 0x807F;\n\t}\n\n\tif (dsiMode) {\n\t\tdsiModeConfirmed = true;\n\t} else {\n\t\tNTR_BIOS();\n\t\tREG_GPIO_WIFI |= BIT(8);\t// Old NDS-Wifi mode\n\t}\n\n\t// Pass command line arguments to loaded program\n\tpassArgs_ARM7();\n\n\tif (ramDiskCluster != 0 && ramDiskSize > 0) {\n\t\tvoid* ramDiskLocation = (void*)(dsiMode ? RAM_DISK_LOCATION_DSIMODE : RAM_DISK_LOCATION);\n\t\tarm9_ramDiskCluster = ramDiskCluster;\n\t\tif (ramDiskSize < (dsiMode ? 0x01001000 : 0x01C01000)) {\n\t\t\taFile ramDiskFile = getFileFromCluster(ramDiskCluster);\n\t\t\tif (romFileType != -1) {\n\t\t\t\ttonccpy ((char*)ramDiskLocation, (char*)0x023E0000, (romFileType == 1) ? RAM_DISK_SNESROM : RAM_DISK_MDROM);\n\t\t\t\ttoncset((u32*)0x023E0000, 0, 0x10000);\n\t\t\t\tif (romIsCompressed) {\n\t\t\t\t\tu8* lz77RomSrc = (u8*)RAM_DISK_LOCATION_LZ77ROM;\n\t\t\t\t\tu32 leng = (lz77RomSrc[1] | (lz77RomSrc[2] << 8) | (lz77RomSrc[3] << 16));\n\t\t\t\t\tif (romFileType == 1) {\n\t\t\t\t\t\t*(u32*)((u8*)ramDiskLocation+RAM_DISK_SNESROMSIZE) = leng;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t*(u32*)((u8*)ramDiskLocation+RAM_DISK_MDROMSIZE) = leng;\n\t\t\t\t\t}\n\t\t\t\t\ttoncset((u32*)RAM_DISK_LOCATION_LZ77ROM, 0, 0x400000);\t// clear compressed ROM\n\t\t\t\t} else {\n\t\t\t\t\tif (romFileType == 1) {\n\t\t\t\t\t\t*(u32*)((u8*)ramDiskLocation+RAM_DISK_SNESROMSIZE) = ramDiskSize;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t*(u32*)((u8*)ramDiskLocation+RAM_DISK_MDROMSIZE) = ramDiskSize;\n\t\t\t\t\t}\n\t\t\t\t\tfileRead((char*)((romFileType == 1) ? ramDiskLocation+RAM_DISK_SNESROM : ramDiskLocation+RAM_DISK_MDROM), ramDiskFile, 0, ramDiskSize, 0);\n\t\t\t\t}\n\t\t\t\tif (romFileType == 1 && cfgSize > 0) {\n\t\t\t\t\t// Load snemul.cfg\n\t\t\t\t\t*(u32*)((u8*)ramDiskLocation+RAM_DISK_SNESCFGSIZE) = cfgSize;\n\t\t\t\t\taFile cfgFile = getFileFromCluster(cfgCluster);\n\t\t\t\t\tfileRead((char*)RAM_DISK_SNESCFG, cfgFile, 0, cfgSize, 0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//buildFatTableCache(&ramDiskFile, 0);\n\t\t\t\tfileRead((char*)ramDiskLocation, ramDiskFile, 0, ramDiskSize, 0);\n\t\t\t\t//toncset((u32*)0x023A0000, 0, 0x40000);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Find the DLDI reserved space in the file\n\t\tu32 patchOffset = quickFind ((u8*)((u32*)NDS_HEADER)[0x0A], dldiMagicString, ((u32*)NDS_HEADER)[0x0B], sizeof(dldiMagicString));\n\t\tu32* wordCommandAddr = (u32 *) (((u32)((u32*)NDS_HEADER)[0x0A])+patchOffset+0x80);\n\n\t\thookNds(ndsHeader, (u32*)SDENGINE_LOCATION, wordCommandAddr);\n\t}\n\n\tif (dsiMode) {\n\t\ttonccpy ((char*)NDS_HEADER_16MB, (char*)NDS_HEADER, 0x1000);\t// Copy user data and header to last MB of main memory\n\t}\n\n\tarm9_boostVram = boostVram;\n\n\twhile (arm9_stateFlag != ARM9_READY);\n\tarm9_stateFlag = ARM9_SETSCFG;\n\twhile (arm9_stateFlag != ARM9_READY);\n\tif (!dsiMode && ramDiskSize == 0) {\n\t\tu32* a9exe = (u32*)ndsHeader->arm9executeAddress;\n\t\tbool recentLibnds =\n\t\t\t  (a9exe[0] == 0xE3A00301\n\t\t\t&& a9exe[1] == 0xE5800208\n\t\t\t&& a9exe[2] == 0xE3A00013\n\t\t\t&& a9exe[3] == 0xE129F000);\n\t\tif (recentLibnds) {\n\t\t\tarm9_stateFlag = ARM9_LOCKSCFG;\n\t\t\twhile (arm9_stateFlag != ARM9_READY);\n\t\t}\n\t}\n\n\tREG_SCFG_EXT &= ~(1UL << 31); // Lock SCFG\n\n\tstartBinary_ARM7();\n\n\treturn 0;\n}", "path": "nds-bootstrap/hb/bootloader/source/arm7/main.arm7.c", "commit_date": "2020-06-22 00:00:00", "repo_name": "DS-Homebrew/nds-bootstrap", "stars": 1105, "license": "gpl-3.0", "language": "c", "size": 23485}
{"docstring": "/*-----------------------------------------------------------------\nfileRead(buffer, cluster, startOffset, length)\n-----------------------------------------------------------------*/\n", "func_signal": "u32 fileRead (char* buffer, aFile file, u32 startOffset, u32 length, int ndmaSlot)", "code": "{\n\t#ifdef DEBUG\n\tnocashMessage(\"fileRead\");\n    dbg_hexa(buffer);\n    dbg_hexa(startOffset);\n    dbg_hexa(length);\n\t#endif\n\n\tint curByte;\n\tint curSect;\n\n\tint dataPos = 0;\n\tint chunks;\n\tint beginBytes;\n\n    u32 clusterIndex = 0;\n\n\tif (file.firstCluster == CLUSTER_FREE || file.firstCluster == CLUSTER_EOF)\n\t{\n\t\treturn 0;\n\t}\n\n\tif(startOffset<file.currentOffset) {\n\t\tfile.currentOffset=0;\n\t\tfile.currentCluster = file.firstCluster;\n\t}\n\n\tif(file.fatTableCached) {\n    \t#ifdef DEBUG\n        nocashMessage(\"fat table cached\");\n        #endif\n\t\tclusterIndex = startOffset/discBytePerClus;\n\t\tfile.currentCluster = file.fatTableCache[clusterIndex];\n\t\tfile.currentOffset=clusterIndex*discBytePerClus;\n\t} else {\n        #ifdef DEBUG\n        nocashMessage(\"fatTable not cached\");\n        #endif\n\t\tif(startOffset<file.currentOffset) {\n\t\t\tfile.currentOffset=0;\n\t\t\tfile.currentCluster = file.firstCluster;\n\t\t}\n\n\t\t// Follow cluster list until desired one is found\n\t\tfor (chunks = (startOffset-file.currentOffset) / discBytePerClus; chunks > 0; chunks--)\n\t\t{\n\t\t\tfile.currentCluster = FAT_NextCluster (file.currentCluster, ndmaSlot);\n\t\t\tfile.currentOffset+=discBytePerClus;\n\t\t}\n\t}\n\n\t// Calculate the sector and byte of the current position,\n\t// and store them\n\tcurSect = (startOffset % discBytePerClus) / BYTES_PER_SECTOR;\n\tcurByte = startOffset % BYTES_PER_SECTOR;\n\n\t// Load sector buffer for new position in file\n\tCARD_ReadSector( curSect + FAT_ClustToSect(file.currentCluster), globalBuffer, 0, 0);\n\tcurSect++;\n\n\t// Number of bytes needed to read to align with a sector\n\tbeginBytes = (BYTES_PER_SECTOR < length + curByte ? (BYTES_PER_SECTOR - curByte) : length);\n\n\t// Read first part from buffer, to align with sector boundary\n    dataPos=0;\n    tonccpy(buffer+dataPos,globalBuffer+curByte,beginBytes-dataPos);\n    curByte+=beginBytes;\n    dataPos+=beginBytes;\n\n\t// Read in all the 512 byte chunks of the file directly, saving time\n\tfor ( chunks = ((int)length - beginBytes) / BYTES_PER_SECTOR; chunks > 0;)\n\t{\n\t\tint sectorsToRead=0;\n\n\t\tif(file.fatTableCached) {\n\n              // Move to the next cluster if necessary\n              if (curSect >= discSecPerClus)\n  \t\t\t{\n                  clusterIndex+= curSect/discSecPerClus;\n                  curSect = curSect % discSecPerClus;;\n                  file.currentCluster = file.fatTableCache[clusterIndex];\n  \t\t\t\tfile.currentOffset+=discBytePerClus;\n  \t\t\t}\n\n               // Calculate how many sectors to read (try to group several cluster at a time if there is no fragmentation)\n              for(int tempClusterIndex=clusterIndex; sectorsToRead<=chunks; ) {\n                  if(file.fatTableCache[tempClusterIndex]+1 == file.fatTableCache[tempClusterIndex+1]) {\n                      #ifdef DEBUG\n                  \tnocashMessage(\"contiguous read\");\n                  \t#endif\n                      // the 2 cluster are consecutive\n                      sectorsToRead += discSecPerClus;\n                      tempClusterIndex++;\n                  } else {\n                      #ifdef DEBUG\n                  \tnocashMessage(\"non contiguous read\");\n                  \t#endif\n                      break;\n                  }\n              }\n\n              if(!sectorsToRead) sectorsToRead = discSecPerClus - curSect;\n              else sectorsToRead = sectorsToRead - curSect;\n\n              if(chunks < sectorsToRead) {\n\t\t\t    sectorsToRead = chunks;\n              }\n\n              #ifdef DEBUG\n              dbg_hexa(curSect + FAT_ClustToSect(file.currentCluster));\n              dbg_hexa(sectorsToRead);\n              dbg_hexa(buffer + dataPos);\n              #endif\n\n              // Read the sectors\n    \t\t\tCARD_ReadSectors(curSect + FAT_ClustToSect(file.currentCluster), sectorsToRead, buffer + dataPos, ndmaSlot);\n    \t\t\tchunks  -= sectorsToRead;\n    \t\t\tcurSect += sectorsToRead;\n    \t\t\tdataPos += BYTES_PER_SECTOR * sectorsToRead;\n\n              #ifdef DEBUG\n              dbg_hexa(discSecPerClus);\n              dbg_hexa(curSect/discSecPerClus);\n              #endif\n\n              clusterIndex+= curSect/discSecPerClus;\n              curSect = curSect % discSecPerClus;\n              file.currentCluster = file.fatTableCache[clusterIndex];\n          } else {\n              // Move to the next cluster if necessary\n  \t\t\tif (curSect >= discSecPerClus)\n  \t\t\t{\n  \t\t\t\tcurSect = 0;\n                  file.currentCluster = FAT_NextCluster (file.currentCluster, ndmaSlot);\n  \t\t\t\tfile.currentOffset+=discBytePerClus;\n  \t\t\t}\n\n              // Calculate how many sectors to read (read a maximum of discSecPerClus at a time)\n\t\t    sectorsToRead = discSecPerClus - curSect;\n\t\t    if(chunks < sectorsToRead)\n\t\t\tsectorsToRead = chunks;\n\n              // Read the sectors\n  \t\t\tCARD_ReadSectors(curSect + FAT_ClustToSect(file.currentCluster), sectorsToRead, buffer + dataPos, ndmaSlot);\n  \t\t\tchunks  -= sectorsToRead;\n  \t\t\tcurSect += sectorsToRead;\n  \t\t\tdataPos += BYTES_PER_SECTOR * sectorsToRead;\n          }\n\t}\n\n\t// Take care of any bytes left over before end of read\n\tif (dataPos < length)\n\t{\n          #ifdef DEBUG\n        \tnocashMessage(\"non aligned read, data is missing\");\n          if(length-dataPos>BYTES_PER_SECTOR) {\n              nocashMessage(\"error: unread sector are missing\");\n          }\n          #endif\n\n\t\t// Update the read buffer\n\t\tcurByte = 0;\n\t\tif (curSect >= discSecPerClus)\n\t\t{\n\t\t\tif(file.fatTableCached) {\n                  clusterIndex+= curSect/discSecPerClus;\n                  curSect = curSect % discSecPerClus;\n                  file.currentCluster = file.fatTableCache[clusterIndex];\n              } else {\n                  curSect = 0;\n                  file.currentCluster = FAT_NextCluster (file.currentCluster, ndmaSlot);\n              }\n\t\t\tfile.currentOffset+=discBytePerClus;\n\t\t}\n\n          #ifdef DEBUG\n          dbg_hexa(curSect + FAT_ClustToSect(file.currentCluster));\n          dbg_hexa(globalBuffer);\n          #endif\n\n\t\tCARD_ReadSector( curSect + FAT_ClustToSect(file.currentCluster), globalBuffer, 0, 0);\n\n\t\t// Read in last partial chunk\n          tonccpy(buffer+dataPos,globalBuffer+curByte,length-dataPos);\n          curByte+=length;\n          dataPos+=length;\n\t}\n\n      #ifdef DEBUG\n      nocashMessage(\"fileRead completed\");\n      nocashMessage(\"\");\n      #endif\n\n\treturn dataPos;\n\n}", "path": "nds-bootstrap/hb/common/source/my_fat.c", "commit_date": "2020-05-13 00:00:00", "repo_name": "DS-Homebrew/nds-bootstrap", "stars": 1105, "license": "gpl-3.0", "language": "c", "size": 23485}
{"docstring": "/*\n*   Look for @find and return the position of it.\n*   Brute Force algorithm\n*/\n", "func_signal": "u32* memsearch32(const u32* start, u32 dataSize, const u32* find, u32 findSize, bool forward)", "code": "{\n\tu32 dataLen = dataSize/sizeof(u32);\n\tu32 findLen = findSize/sizeof(u32);\n\n\tconst u32* end = forward ? (start + dataLen) : (start - dataLen);\n\tfor (u32* addr = (u32*)start; addr != end; forward ? ++addr : --addr) {\n\t\tbool found = true;\n\t\tfor (u32 j = 0; j < findLen; ++j) {\n\t\t\tif (addr[j] != find[j]) {\n\t\t\t\tfound = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (found) {\n\t\t\treturn (u32*)addr;\n\t\t}\n\t}\n\treturn NULL;\n}", "path": "nds-bootstrap/retail/bootloader/source/arm7/find_common.c", "commit_date": "2019-01-21 00:00:00", "repo_name": "DS-Homebrew/nds-bootstrap", "stars": 1105, "license": "gpl-3.0", "language": "c", "size": 23485}
{"docstring": "/*-----------------------------------------------------------------\nucase\nReturns the uppercase version of the given char\nchar IN: a character\nchar return OUT: uppercase version of character\n-----------------------------------------------------------------*/\n", "func_signal": "char ucase (char character)", "code": "{\n\tif ((character > 0x60) && (character < 0x7B))\n\t\tcharacter = character - 0x20;\n\treturn (character);\n}", "path": "nds-bootstrap/hb/common/source/my_fat.c", "commit_date": "2020-05-13 00:00:00", "repo_name": "DS-Homebrew/nds-bootstrap", "stars": 1105, "license": "gpl-3.0", "language": "c", "size": 23485}
{"docstring": "/*-------------------------------------------------------------------------\narm9_main\n\nClears the ARM9's DMA channels and resets video memory\nJumps to the ARM9 NDS binary in sync with the display and ARM7\nWritten by Darkain.\nModified by Chishm:\n * Changed MultiNDS specific stuff\n--------------------------------------------------------------------------*/\n", "func_signal": "void __attribute__((target(\"arm\"))) arm9_main(void)", "code": "{\n \tregister int i;\n  \n\t// Set shared ram to ARM7\n\tWRAM_CR = 0x03;\n\tREG_EXMEMCNT = 0xE880;\n\n\tinitMBKARM9();\n\n\tarm9_stateFlag = ARM9_START;\n\n\tREG_IME = 0;\n\tREG_IE = 0;\n\tREG_IF = ~0;\n\n\tarm9_clearCache();\n\n\tfor (i = 0; i < 16*1024; i += 4) { // First 16KB\n\t\t*(vu32*)(i + 0x00000000) = 0x00000000; // Clear ITCM\n\t\t*(vu32*)(i + 0x00800000) = 0x00000000; // Clear DTCM\n\t}\n\n\tfor (i = 16*1024; i < 32*1024; i += 4) { // Second 16KB\n\t\t*(vu32*)(i + 0x00000000) = 0x00000000; // Clear ITCM\n\t}\n\n\tarm9_stateFlag = ARM9_MEMCLR;\n\n\t*(vu32*)0x00803FFC = 0;  // IRQ_HANDLER ARM9 version\n\t*(vu32*)0x00803FF8 = ~0; // VBLANK_INTR_WAIT_FLAGS ARM9 version\n\n\t// Clear out ARM9 DMA channels\n\tfor (i = 0; i < 4; i++) {\n\t\tDMA_CR(i) = 0;\n\t\tDMA_SRC(i) = 0;\n\t\tDMA_DEST(i) = 0;\n\t\tTIMER_CR(i) = 0;\n\t\tTIMER_DATA(i) = 0;\n\t}\n\n\t// Clear out FIFO\n\tREG_IPC_SYNC = 0;\n\tREG_IPC_FIFO_CR = IPC_FIFO_ENABLE | IPC_FIFO_SEND_CLEAR;\n\tREG_IPC_FIFO_CR = 0;\n\n\tVRAM_A_CR = 0x80;\n\tVRAM_B_CR = 0x80;\n\tVRAM_C_CR = 0x80;\n\t// Don't mess with the VRAM used for execution\n\t//VRAM_D_CR = 0;\n\tVRAM_E_CR = 0x80;\n\tVRAM_F_CR = 0x80;\n\tVRAM_G_CR = 0x80;\n\tVRAM_H_CR = 0x80;\n\tVRAM_I_CR = 0x80;\n\tBG_PALETTE[0] = 0xFFFF;\n\tdmaFill((u16*)&arm9_BLANK_RAM, BG_PALETTE+1, (2*1024)-2);\n\tdmaFill((u16*)&arm9_BLANK_RAM, OAM, 2*1024);\n\tdmaFill((u16*)&arm9_BLANK_RAM, (u16*)0x04000000, 0x56);  // Clear main display registers\n\tdmaFill((u16*)&arm9_BLANK_RAM, (u16*)0x04001000, 0x56);  // Clear sub display registers\n\tdmaFill((u16*)&arm9_BLANK_RAM, VRAM_A, 0x20000*3);\t\t// Banks A, B, C\n\tdmaFill((u16*)&arm9_BLANK_RAM, VRAM_D, 272*1024);\t\t// Banks D (excluded), E, F, G, H, I\n\n\tREG_DISPSTAT = 0;\n\n\tVRAM_A_CR = 0;\n\tVRAM_B_CR = 0;\n\tVRAM_C_CR = 0;\n\t// Don't mess with the ARM7's VRAM\n\t//VRAM_D_CR = 0;\n\tVRAM_E_CR = 0;\n\tVRAM_F_CR = 0;\n\tVRAM_G_CR = 0;\n\tVRAM_H_CR = 0;\n\tVRAM_I_CR = 0;\n\tREG_POWERCNT = 0x820F;\n\n\t*(u16*)0x0400006C |= BIT(14);\n\t*(u16*)0x0400006C &= BIT(15);\n\n\t// Return to passme loop\n\t//*(vu32*)0x02FFFE04 = (u32)0xE59FF018; // ldr pc, 0x02FFFE24\n\t//*(vu32*)0x02FFFE24 = (u32)0x02FFFE04; // Set ARM9 Loop address\n\n\t//asm volatile(\n\t//\t\"\\tbx %0\\n\"\n\t//\t: : \"r\" (0x02FFFE04)\n\t//);\n\n\t// Set ARM9 state to ready and wait for it to change again\n\tarm9_stateFlag = ARM9_READY;\n\twhile (arm9_stateFlag != ARM9_BOOTBIN) {\n\t\tif (arm9_stateFlag == ARM9_SCRNCLR) {\n\t\t\tif (screenFadedIn) {\n\t\t\t\tfadeOut();\n\t\t\t\tdmaFill((u16*)&arm9_BLANK_RAM, VRAM_A, 0x18000);\t\t// Bank A\n\t\t\t\tVRAM_A_CR = 0;\n\t\t\t\tREG_POWERCNT = 0x820F;\n\t\t\t\tSetBrightness(0, 0);\n\t\t\t\tSetBrightness(1, 0);\n\t\t\t}\n\t\t\tarm9_stateFlag = ARM9_READY;\n\t\t}\n\t\tif (arm9_stateFlag == ARM9_DISPSCRN) {\n\t\t\tif (!screenFadedIn) {\n\t\t\t\tSetBrightness(0, 31);\n\t\t\t\tSetBrightness(1, 31);\n\t\t\t}\n\t\t\tif (!imageLoaded) {\n\t\t\t\tarm9_pleaseWaitText();\n\t\t\t\timageLoaded = true;\n\t\t\t}\n\t\t\tif (!screenFadedIn) {\n\t\t\t\tfadeIn();\n\t\t\t\tscreenFadedIn = true;\n\t\t\t}\n\t\t\tarm9_stateFlag = ARM9_READY;\n\t\t}\n\t\tif (arm9_stateFlag == ARM9_DISPERR) {\n\t\t\tif (!screenFadedIn) {\n\t\t\t\tSetBrightness(0, 31);\n\t\t\t\tSetBrightness(1, 31);\n\t\t\t}\n\t\t\tarm9_errorText();\n\t\t\tif (!screenFadedIn) {\n\t\t\t\tfadeIn();\n\t\t\t\tscreenFadedIn = true;\n\t\t\t}\n\t\t\tarm9_stateFlag = ARM9_READY;\n\t\t}\n\t\tif (arm9_stateFlag == ARM9_SETSCFG) {\n\t\t\t/*if (isGSDD) {       \n\t\t\t\tREG_MBK6 = 0x080037C0;  // WRAM-A mapped to the 0x37C0000 - 0x37FFFFF area : 256k\n\t\t\t}*/\n\t\t\tif (dsiModeConfirmed) {\n\t\t\t\tif (arm9_isSdk5 && ROMisDsiEnhanced(ndsHeader)) {\n\t\t\t\t\tinitMBKARM9_dsiEnhanced();\n\t\t\t\t}\n\t\t\t\tREG_SCFG_EXT = 0x8307F100;\n\t\t\t\tREG_SCFG_CLK = 0x87;\n\t\t\t\tREG_SCFG_RST = 1;\n\t\t\t} else {\n\t\t\t\tREG_SCFG_EXT = 0x8300C000;\n\t\t\t\tif (arm9_boostVram) {\n\t\t\t\t\tREG_SCFG_EXT |= BIT(13);\t// Extended VRAM Access\n\t\t\t\t}\n                REG_SCFG_EXT |= BIT(16);\t// NDMA\n\t\t\t\tif (extendedMemoryConfirmed) {\n\t\t\t\t\tif (moreMemory) {\n\t\t\t\t\t\tfor (int i = 0; i < 16; i++) {\n\t\t\t\t\t\t\ttransferToArm9(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Switch to 4MB mode\n\t\t\t\t\tREG_SCFG_EXT -= 0xC000;\n\t\t\t\t} else {\n\t\t\t\t\t// lock SCFG\n\t\t\t\t\tREG_SCFG_EXT &= ~(1UL << 31);\n\t\t\t\t}\n\t\t\t}\n\t\t\tarm9_stateFlag = ARM9_READY;\n\t\t}\n\t}\n\n\twhile (REG_VCOUNT != 191);\n\twhile (REG_VCOUNT == 191);\n\n\t// Start ARM9\n\tVoidFn arm9code = (VoidFn)ndsHeader->arm9executeAddress;\n\tarm9code();\n}", "path": "nds-bootstrap/retail/bootloader/source/arm9/main.arm9.c", "commit_date": "2020-05-07 00:00:00", "repo_name": "DS-Homebrew/nds-bootstrap", "stars": 1105, "license": "gpl-3.0", "language": "c", "size": 23485}
{"docstring": "/*-----------------------------------------------------------------\nfileWrite(buffer, cluster, startOffset, length)\n-----------------------------------------------------------------*/\n", "func_signal": "u32 fileWrite (const char* buffer, aFile file, u32 startOffset, u32 length, int ndmaSlot)", "code": "{\n\t#ifdef DEBUG\n\tnocashMessage(\"fileWrite\");\n\t#endif\n\n\tint curByte;\n\tint curSect;\n\n\tint dataPos = 0;\n\tint chunks;\n\tint beginBytes;\n    u32 clusterIndex = 0;\n\n\tif (file.firstCluster == CLUSTER_FREE || file.firstCluster == CLUSTER_EOF)\n\t{\n\t\t#ifdef DEBUG\n\t\tnocashMessage(\"CLUSTER_FREE or CLUSTER_EOF\");\n\t\t#endif\n\t\treturn 0;\n\t}\n\n\tif(file.fatTableCached) {\n\t\tclusterIndex = startOffset/discBytePerClus;\n\t\tfile.currentCluster = file.fatTableCache[clusterIndex];\n\t\tfile.currentOffset=clusterIndex*discBytePerClus;\n\t} else {\n\t\tif(startOffset<file.currentOffset) {\n\t\t\tfile.currentOffset=0;\n\t\t\tfile.currentCluster = file.firstCluster;\n\t\t}\n\n\t\t// Follow cluster list until desired one is found\n\t\tfor (chunks = (startOffset-file.currentOffset) / discBytePerClus; chunks > 0; chunks--)\n\t\t{\n\t\t\tfile.currentCluster = FAT_NextCluster (file.currentCluster, ndmaSlot);\n\t\t\tfile.currentOffset+=discBytePerClus;\n\t\t}\n\t}\n\n\t// Calculate the sector and byte of the current position,\n\t// and store them\n\tcurSect = (startOffset % discBytePerClus) / BYTES_PER_SECTOR;\n\tcurByte = startOffset % BYTES_PER_SECTOR;\n\n\t// Load sector buffer for new position in file\n\tCARD_ReadSector( curSect + FAT_ClustToSect(file.currentCluster), globalBuffer, 0, 0);\n\n\n\t// Number of bytes needed to read to align with a sector\n\tbeginBytes = (BYTES_PER_SECTOR < length + curByte ? (BYTES_PER_SECTOR - curByte) : length);\n\n\t// Read first part from buffer, to align with sector boundary\n    dataPos=0;\n    tonccpy(globalBuffer+curByte,buffer+dataPos,beginBytes-dataPos);\n    curByte+=beginBytes;\n    dataPos+=beginBytes;\n\n\tCARD_WriteSector(curSect + FAT_ClustToSect(file.currentCluster), globalBuffer, ndmaSlot);\n\n\tcurSect++;\n\n\t// Read in all the 512 byte chunks of the file directly, saving time\n\tfor ( chunks = ((int)length - beginBytes) / BYTES_PER_SECTOR; chunks > 0;)\n\t{\n\t\tint sectorsToWrite;\n\n\t\t// Move to the next cluster if necessary\n\t\tif (curSect >= discSecPerClus)\n\t\t{\n            if(file.fatTableCached) {\n                clusterIndex++;\n                file.currentCluster = file.fatTableCache[clusterIndex];\n            } else {\n                file.currentCluster = FAT_NextCluster (file.currentCluster, ndmaSlot);\n\n            }\n            file.currentOffset+=discBytePerClus;\n\t\t\tcurSect = 0;\n\n\t\t}\n\n\t\t// Calculate how many sectors to read (read a maximum of discSecPerClus at a time)\n\t\tsectorsToWrite = discSecPerClus - curSect;\n\t\tif(chunks < sectorsToWrite)\n\t\t\tsectorsToWrite = chunks;\n\n\t\t// Read the sectors\n\t\tCARD_WriteSectors(curSect + FAT_ClustToSect(file.currentCluster), sectorsToWrite, buffer + dataPos, ndmaSlot);\n\t\tchunks  -= sectorsToWrite;\n\t\tcurSect += sectorsToWrite;\n\t\tdataPos += BYTES_PER_SECTOR * sectorsToWrite;\n\t}\n\n\t// Take care of any bytes left over before end of read\n\tif (dataPos < length)\n\t{\n\n\t\t// Update the read buffer\n\t\tcurByte = 0;\n\t\tif (curSect >= discSecPerClus)\n\t\t{\n            if(file.fatTableCached) {\n                clusterIndex++;\n                file.currentCluster = file.fatTableCache[clusterIndex];\n            } else {\n                file.currentCluster = FAT_NextCluster (file.currentCluster, ndmaSlot);\n            }\n\t\t\tcurSect = 0;\n\t\t\tfile.currentOffset+=discBytePerClus;\n\t\t}\n\t\tCARD_ReadSector( curSect + FAT_ClustToSect(file.currentCluster), globalBuffer, 0, 0);\n\n\t\t// Read in last partial chunk\n        tonccpy(globalBuffer+curByte,buffer+dataPos,length-dataPos);\n        curByte+=length;\n        dataPos+=length;\n\n\t\tCARD_WriteSector( curSect + FAT_ClustToSect(file.currentCluster), globalBuffer, ndmaSlot);\n\t}\n\n\treturn dataPos;\n}", "path": "nds-bootstrap/hb/common/source/my_fat.c", "commit_date": "2020-05-13 00:00:00", "repo_name": "DS-Homebrew/nds-bootstrap", "stars": 1105, "license": "gpl-3.0", "language": "c", "size": 23485}
{"docstring": "//reads from rom image either gba rom or dldi\n", "func_signal": "inline ssize_t nitroSubRead(off_t *npos, void *ptr, size_t len)", "code": "{\n    if (ndsFile != NULL)\n    { //read from ndsfile\n        if (ndsFileLastpos != *npos)\n            fseek(ndsFile, *npos, SEEK_SET); //if we need to, move! (might want to verify this succeed)\n        len = fread(ptr, 1, len, ndsFile);\n    }\n    else\n    {                                             //reading from gbarom\n        memcpy(ptr, *npos + (void *)GBAROM, len); //len isnt checked here because other checks exist in the callers (hopefully)\n    }\n    if (len > 0)\n        *npos += len;\n    ndsFileLastpos = *npos; //save the current file nds pos\n    return (len);\n}", "path": "nds-bootstrap/retail/arm9/source/nitrofs.c", "commit_date": "2019-08-24 00:00:00", "repo_name": "DS-Homebrew/nds-bootstrap", "stars": 1105, "license": "gpl-3.0", "language": "c", "size": 23485}
{"docstring": "/*-------------------------------------------------------------------------\nstartBinary_ARM7\nJumps to the ARM7 NDS binary in sync with the display and ARM9\nWritten by Darkain.\nModified by Chishm:\n * Removed MultiNDS specific stuff\n--------------------------------------------------------------------------*/\n", "func_signal": "static void startBinary_ARM7 (void)", "code": "{\n\tREG_IME=0;\n\twhile(REG_VCOUNT!=191);\n\twhile(REG_VCOUNT==191);\n\n\t// Get the ARM9 to boot\n\tarm9_stateFlag = ARM9_BOOTBIN;\n\n\twhile (REG_VCOUNT != 191);\n\twhile (REG_VCOUNT == 191);\n\n\t// Start ARM7\n\tVoidFn arm7code = *(VoidFn*)(0x2FFFE34);\n\tarm7code();\n}", "path": "nds-bootstrap/hb/bootloader/source/arm7/main.arm7.c", "commit_date": "2020-06-22 00:00:00", "repo_name": "DS-Homebrew/nds-bootstrap", "stars": 1105, "license": "gpl-3.0", "language": "c", "size": 23485}
{"docstring": "//Directory functs\n", "func_signal": "DIR_ITER *nitroFSDirOpen(struct _reent *r, DIR_ITER *dirState, const char *path)", "code": "{\n    struct nitroDIRStruct *dirStruct = (struct nitroDIRStruct *)dirState->dirStruct; //this makes it lots easier!\n    struct stat st;\n    char dirname[NITRONAMELENMAX];\n    char *cptr;\n    char mydirpath[NITROMAXPATHLEN]; //to hold copy of path string\n    char *dirpath = mydirpath;\n    bool pathfound;\n    if ((cptr = strchr(path, ':')))\n        path = cptr + 1;                           //move path past any device names (if it was nixy style wouldnt need this step >_>)\n    strncpy(dirpath, path, sizeof(mydirpath) - 1); //copy the string (as im gonna mutalate it)\n    dirStruct->pos = 0;\n    if (*dirpath == '/')                   //if first character is '/' use absolute root path plz\n        dirStruct->cur_dir_id = NITROROOT; //first root dir\n    else\n        dirStruct->cur_dir_id = chdirpathid; //else use chdirpath\n    nitroDirReset(r, dirState);              //set dir to current path\n    do\n    {\n        while ((cptr = strchr(dirpath, '/')) == dirpath)\n        {\n            dirpath++; //move past any leading / or // together\n        }\n        if (cptr)\n            *cptr = 0; //erase /\n        if (*dirpath == 0)\n        {                     //are we at the end of the path string?? if so there is nothing to search for we're already here !\n            pathfound = true; //mostly this handles searches for root or /  or no path specified cases\n            break;\n        }\n        pathfound = false;\n        while (nitroFSDirNext(r, dirState, dirname, &st) == 0)\n        {\n            if ((st.st_mode == S_IFDIR) && !(strcmp(dirname, dirpath)))\n            {                                              //if its a directory and name matches dirpath\n                dirStruct->cur_dir_id = dirStruct->dir_id; //move us to the next dir in tree\n                nitroDirReset(r, dirState);                //set dir to current path we just found...\n                pathfound = true;\n                break;\n            }\n        };\n        if (!pathfound)\n            break;\n        dirpath = cptr + 1; //move to right after last / we found\n    } while (cptr);         // go till after the last /\n    if (pathfound)\n    {\n        return (dirState);\n    }\n    else\n    {\n        r->_errno = ENOENT;\n        return (NULL);\n    }\n}", "path": "nds-bootstrap/retail/arm9/source/nitrofs.c", "commit_date": "2019-08-24 00:00:00", "repo_name": "DS-Homebrew/nds-bootstrap", "stars": 1105, "license": "gpl-3.0", "language": "c", "size": 23485}
{"docstring": "/* Free a pointer allocated by png_malloc().  If ptr is NULL, return\n * without taking any action.\n */\n", "func_signal": "void PNGAPI\npng_free(png_structp png_ptr, png_voidp ptr)", "code": "{\n   if (png_ptr == NULL || ptr == NULL)\n      return;\n\n#  ifdef PNG_USER_MEM_SUPPORTED\n   if (png_ptr->free_fn != NULL)\n   {\n      (*(png_ptr->free_fn))(png_ptr, ptr);\n      return;\n   }\n\n   else\n      png_free_default(png_ptr, ptr);\n}", "path": "StarRuler2-Source/source/libpng/pngmem.c", "commit_date": "2018-07-17 00:00:00", "repo_name": "BlindMindStudios/StarRuler2-Source", "stars": 1438, "license": "other", "language": "c", "size": 503604}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_destroy_struct_2(png_voidp struct_ptr, png_free_ptr free_fn,\n    png_voidp mem_ptr)", "code": "{\n#  endif /* PNG_USER_MEM_SUPPORTED */\n   if (struct_ptr != NULL)\n   {\n#  ifdef PNG_USER_MEM_SUPPORTED\n      if (free_fn != NULL)\n      {\n         png_struct dummy_struct;\n         png_structp png_ptr = &dummy_struct;\n         png_ptr->mem_ptr=mem_ptr;\n         (*(free_fn))(png_ptr, struct_ptr);\n         return;\n      }\n#  endif /* PNG_USER_MEM_SUPPORTED */\n#  if defined(__TURBOC__) && !defined(__FLAT__)\n      farfree(struct_ptr);\n\n#  else\n#    if defined(_MSC_VER) && defined(MAXSEG_64K)\n      hfree(struct_ptr);\n\n#    else\n      free(struct_ptr);\n\n#    endif\n#  endif\n   }\n}", "path": "StarRuler2-Source/source/libpng/pngmem.c", "commit_date": "2018-07-17 00:00:00", "repo_name": "BlindMindStudios/StarRuler2-Source", "stars": 1438, "license": "other", "language": "c", "size": 503604}
{"docstring": "//////////////////////////////////////////////////////////////////////////\n//////                       GLFW platform API                      //////\n//////////////////////////////////////////////////////////////////////////\n", "func_signal": "void _glfwPlatformSetClipboardString(_GLFWwindow* window, const char* string)", "code": "{\n    WCHAR* wideString;\n    HANDLE stringHandle;\n    size_t wideSize;\n\n    wideString = _glfwCreateWideStringFromUTF8(string);\n    if (!wideString)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"Win32: Failed to convert clipboard string to \"\n                        \"wide string\");\n        return;\n    }\n\n    wideSize = (wcslen(wideString) + 1) * sizeof(WCHAR);\n\n    stringHandle = GlobalAlloc(GMEM_MOVEABLE, wideSize);\n    if (!stringHandle)\n    {\n        free(wideString);\n\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"Win32: Failed to allocate global handle for clipboard\");\n        return;\n    }\n\n    memcpy(GlobalLock(stringHandle), wideString, wideSize);\n    GlobalUnlock(stringHandle);\n\n    if (!OpenClipboard(window->win32.handle))\n    {\n        GlobalFree(stringHandle);\n        free(wideString);\n\n        _glfwInputError(GLFW_PLATFORM_ERROR, \"Win32: Failed to open clipboard\");\n        return;\n    }\n\n    EmptyClipboard();\n    SetClipboardData(CF_UNICODETEXT, stringHandle);\n    CloseClipboard();\n\n    free(wideString);\n}", "path": "StarRuler2-Source/source/glfw/src/win32_clipboard.c", "commit_date": "2018-07-17 00:00:00", "repo_name": "BlindMindStudios/StarRuler2-Source", "stars": 1438, "license": "other", "language": "c", "size": 503604}
{"docstring": "/* Print usage information */\n", "func_signal": "static void usage(void)", "code": "{\n    printf(\"Usage: heightmap [-v <vertex_shader_path>] [-f <fragment_shader_path>]\\n\");\n    printf(\"       heightmap [-h]\\n\");\n}", "path": "StarRuler2-Source/source/glfw/examples/heightmap.c", "commit_date": "2018-07-17 00:00:00", "repo_name": "BlindMindStudios/StarRuler2-Source", "stars": 1438, "license": "other", "language": "c", "size": 503604}
{"docstring": "/* Run the specified number of iterations of the generation process for the\n * heightmap\n */\n", "func_signal": "static void update_map(int num_iter)", "code": "{\n    assert(num_iter > 0);\n    while(num_iter)\n    {\n        /* center of the circle */\n        float center_x;\n        float center_z;\n        float circle_size;\n        float disp;\n        size_t ii;\n        generate_heightmap__circle(&center_x, &center_z, &circle_size, &disp);\n        disp = disp / 2.0f;\n        for (ii = 0u ; ii < MAP_NUM_TOTAL_VERTICES ; ++ii)\n        {\n            GLfloat dx = center_x - map_vertices[0][ii];\n            GLfloat dz = center_z - map_vertices[2][ii];\n            GLfloat pd = (2.0f * sqrtf((dx * dx) + (dz * dz))) / circle_size;\n            if (fabs(pd) <= 1.0f)\n            {\n                /* tx,tz is within the circle */\n                GLfloat new_height = disp + (float) (cos(pd*3.14f)*disp);\n                map_vertices[1][ii] += new_height;\n            }\n        }\n        --num_iter;\n    }\n}", "path": "StarRuler2-Source/source/glfw/examples/heightmap.c", "commit_date": "2018-07-17 00:00:00", "repo_name": "BlindMindStudios/StarRuler2-Source", "stars": 1438, "license": "other", "language": "c", "size": 503604}
{"docstring": "//////////////////////////////////////////////////////////////////////////\n//////                        GLFW public API                       //////\n//////////////////////////////////////////////////////////////////////////\n", "func_signal": "GLFWAPI int glfwInit(void)", "code": "{\n    if (_glfwInitialized)\n        return GL_TRUE;\n\n    memset(&_glfw, 0, sizeof(_glfw));\n\n    if (!_glfwPlatformInit())\n    {\n        _glfwPlatformTerminate();\n        return GL_FALSE;\n    }\n\n    _glfw.monitors = _glfwPlatformGetMonitors(&_glfw.monitorCount);\n    if (_glfw.monitors == NULL)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR, \"No monitors found\");\n        _glfwPlatformTerminate();\n        return GL_FALSE;\n    }\n\n    _glfwInitialized = GL_TRUE;\n\n    // Not all window hints have zero as their default value\n    glfwDefaultWindowHints();\n\n    return GL_TRUE;\n}", "path": "StarRuler2-Source/source/glfw/src/init.c", "commit_date": "2018-07-17 00:00:00", "repo_name": "BlindMindStudios/StarRuler2-Source", "stars": 1438, "license": "other", "language": "c", "size": 503604}
{"docstring": "/* Free a pointer allocated by png_malloc().  In the default\n * configuration, png_ptr is not used, but is passed in case it\n * is needed.  If ptr is NULL, return without taking any action.\n */\n", "func_signal": "void PNGAPI\npng_free(png_structp png_ptr, png_voidp ptr)", "code": "{\n   if (png_ptr == NULL || ptr == NULL)\n      return;\n\n#  ifdef PNG_USER_MEM_SUPPORTED\n   if (png_ptr->free_fn != NULL)\n   {\n      (*(png_ptr->free_fn))(png_ptr, ptr);\n      return;\n   }\n\n   else\n      png_free_default(png_ptr, ptr);\n}", "path": "StarRuler2-Source/source/libpng/pngmem.c", "commit_date": "2018-07-17 00:00:00", "repo_name": "BlindMindStudios/StarRuler2-Source", "stars": 1438, "license": "other", "language": "c", "size": 503604}
{"docstring": "/* Allocate memory.  For reasonable files, size should never exceed\n * 64K.  However, zlib may allocate more then 64K if you don't tell\n * it not to.  See zconf.h and png.h for more information.  zlib does\n * need to allocate exactly 64K, so whatever you call here must\n * have the ability to do that.\n */\n", "func_signal": "PNG_FUNCTION(png_voidp,PNGAPI\npng_calloc,(png_structp png_ptr, png_alloc_size_t size),PNG_ALLOCATED)", "code": "{\n   png_voidp ret;\n\n   ret = (png_malloc(png_ptr, size));\n\n   if (ret != NULL)\n      png_memset(ret,0,(png_size_t)size);\n\n   return (ret);\n}", "path": "StarRuler2-Source/source/libpng/pngmem.c", "commit_date": "2018-07-17 00:00:00", "repo_name": "BlindMindStudios/StarRuler2-Source", "stars": 1438, "license": "other", "language": "c", "size": 503604}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_destroy_struct(png_voidp struct_ptr)", "code": "{\n#  ifdef PNG_USER_MEM_SUPPORTED\n   png_destroy_struct_2(struct_ptr, NULL, NULL);\n}", "path": "StarRuler2-Source/source/libpng/pngmem.c", "commit_date": "2018-07-17 00:00:00", "repo_name": "BlindMindStudios/StarRuler2-Source", "stars": 1438, "license": "other", "language": "c", "size": 503604}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_destroy_struct(png_voidp struct_ptr)", "code": "{\n#  ifdef PNG_USER_MEM_SUPPORTED\n   png_destroy_struct_2(struct_ptr, NULL, NULL);\n}", "path": "StarRuler2-Source/source/libpng/pngmem.c", "commit_date": "2018-07-17 00:00:00", "repo_name": "BlindMindStudios/StarRuler2-Source", "stars": 1438, "license": "other", "language": "c", "size": 503604}
{"docstring": "/* Create VBO, IBO and VAO objects for the heightmap geometry and bind them to\n * the specified program object\n */\n", "func_signal": "static void make_mesh(GLuint program)", "code": "{\n    GLuint attrloc;\n\n    pglGenVertexArrays(1, &mesh);\n    pglGenBuffers(4, mesh_vbo);\n    pglBindVertexArray(mesh);\n    /* Prepare the data for drawing through a buffer inidices */\n    pglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, mesh_vbo[3]);\n    pglBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(GLuint)* MAP_NUM_LINES * 2, map_line_indices, GL_STATIC_DRAW);\n\n    /* Prepare the attributes for rendering */\n    attrloc = pglGetAttribLocation(program, \"x\");\n    pglBindBuffer(GL_ARRAY_BUFFER, mesh_vbo[0]);\n    pglBufferData(GL_ARRAY_BUFFER, sizeof(GLfloat) * MAP_NUM_TOTAL_VERTICES, &map_vertices[0][0], GL_STATIC_DRAW);\n    pglEnableVertexAttribArray(attrloc);\n    pglVertexAttribPointer(attrloc, 1, GL_FLOAT, GL_FALSE, 0, 0);\n\n    attrloc = pglGetAttribLocation(program, \"z\");\n    pglBindBuffer(GL_ARRAY_BUFFER, mesh_vbo[2]);\n    pglBufferData(GL_ARRAY_BUFFER, sizeof(GLfloat) * MAP_NUM_TOTAL_VERTICES, &map_vertices[2][0], GL_STATIC_DRAW);\n    pglEnableVertexAttribArray(attrloc);\n    pglVertexAttribPointer(attrloc, 1, GL_FLOAT, GL_FALSE, 0, 0);\n\n    attrloc = pglGetAttribLocation(program, \"y\");\n    pglBindBuffer(GL_ARRAY_BUFFER, mesh_vbo[1]);\n    pglBufferData(GL_ARRAY_BUFFER, sizeof(GLfloat) * MAP_NUM_TOTAL_VERTICES, &map_vertices[1][0], GL_DYNAMIC_DRAW);\n    pglEnableVertexAttribArray(attrloc);\n    pglVertexAttribPointer(attrloc, 1, GL_FLOAT, GL_FALSE, 0, 0);\n}", "path": "StarRuler2-Source/source/glfw/examples/heightmap.c", "commit_date": "2018-07-17 00:00:00", "repo_name": "BlindMindStudios/StarRuler2-Source", "stars": 1438, "license": "other", "language": "c", "size": 503604}
{"docstring": "/* Creates a shader object of the specified type using the specified text\n */\n", "func_signal": "static GLuint make_shader(GLenum type, const char* shader_src)", "code": "{\n    GLuint shader;\n    GLint shader_ok;\n    GLsizei log_length;\n    char info_log[8192];\n\n    shader = pglCreateShader(type);\n    if (shader != 0)\n    {\n        pglShaderSource(shader, 1, (const GLchar**)&shader_src, NULL);\n        pglCompileShader(shader);\n        pglGetShaderiv(shader, GL_COMPILE_STATUS, &shader_ok);\n        if (shader_ok != GL_TRUE)\n        {\n            fprintf(stderr, \"ERROR: Failed to compile %s shader\\n\", (type == GL_FRAGMENT_SHADER) ? \"fragment\" : \"vertex\" );\n            pglGetShaderInfoLog(shader, 8192, &log_length,info_log);\n            fprintf(stderr, \"ERROR: \\n%s\\n\\n\", info_log);\n            pglDeleteShader(shader);\n            shader = 0;\n        }\n    }\n    return shader;\n}", "path": "StarRuler2-Source/source/glfw/examples/heightmap.c", "commit_date": "2018-07-17 00:00:00", "repo_name": "BlindMindStudios/StarRuler2-Source", "stars": 1438, "license": "other", "language": "c", "size": 503604}
{"docstring": "/* This function is called when the application wants to use another method\n * of allocating and freeing memory.\n */\n", "func_signal": "void PNGAPI\npng_set_mem_fn(png_structp png_ptr, png_voidp mem_ptr, png_malloc_ptr\n  malloc_fn, png_free_ptr free_fn)", "code": "{\n   if (png_ptr != NULL)\n   {\n      png_ptr->mem_ptr = mem_ptr;\n      png_ptr->malloc_fn = malloc_fn;\n      png_ptr->free_fn = free_fn;\n   }\n}", "path": "StarRuler2-Source/source/libpng/pngmem.c", "commit_date": "2018-07-17 00:00:00", "repo_name": "BlindMindStudios/StarRuler2-Source", "stars": 1438, "license": "other", "language": "c", "size": 503604}
{"docstring": "/* Load a (text) file into memory and return its contents\n */\n", "func_signal": "static char* read_file_content(const char* filename)", "code": "{\n    FILE* fd;\n    size_t size = 0;\n    char* result = NULL;\n\n    fd = fopen(filename, \"r\");\n    if (fd != NULL)\n    {\n        size = fseek(fd, 0, SEEK_END);\n        (void) fseek(fd, 0, SEEK_SET);\n\n        result = malloc(size + 1);\n        result[size] = '\\0';\n        if (fread(result, size, 1, fd) != 1)\n        {\n            free(result);\n            result = NULL;\n        }\n        (void) fclose(fd);\n    }\n    return result;\n}", "path": "StarRuler2-Source/source/glfw/examples/heightmap.c", "commit_date": "2018-07-17 00:00:00", "repo_name": "BlindMindStudios/StarRuler2-Source", "stars": 1438, "license": "other", "language": "c", "size": 503604}
{"docstring": "//////////////////////////////////////////////////////////////////////////\n//////                         GLFW event API                       //////\n//////////////////////////////////////////////////////////////////////////\n", "func_signal": "void _glfwInputError(int error, const char* format, ...)", "code": "{\n    if (_glfwErrorCallback)\n    {\n        char buffer[16384];\n        const char* description;\n\n        if (format)\n        {\n            int count;\n            va_list vl;\n\n            va_start(vl, format);\n            count = vsnprintf(buffer, sizeof(buffer), format, vl);\n            va_end(vl);\n\n            if (count < 0)\n                buffer[sizeof(buffer) - 1] = '\\0';\n\n            description = buffer;\n        }\n        else\n            description = getErrorString(error);\n\n        _glfwErrorCallback(error, description);\n    }\n}", "path": "StarRuler2-Source/source/glfw/src/init.c", "commit_date": "2018-07-17 00:00:00", "repo_name": "BlindMindStudios/StarRuler2-Source", "stars": 1438, "license": "other", "language": "c", "size": 503604}
{"docstring": "/* Creates a program object using the specified vertex and fragment text\n */\n", "func_signal": "static GLuint make_shader_program(const char* vertex_shader_src, const char* fragment_shader_src)", "code": "{\n    GLuint program = 0u;\n    GLint program_ok;\n    GLuint vertex_shader = 0u;\n    GLuint fragment_shader = 0u;\n    GLsizei log_length;\n    char info_log[8192];\n\n    vertex_shader = make_shader(GL_VERTEX_SHADER, (vertex_shader_src == NULL) ? default_vertex_shader : vertex_shader_src);\n    if (vertex_shader != 0u)\n    {\n        fragment_shader = make_shader(GL_FRAGMENT_SHADER, (fragment_shader_src == NULL) ? default_fragment_shader : fragment_shader_src);\n        if (fragment_shader != 0u)\n        {\n            /* make the program that connect the two shader and link it */\n            program = pglCreateProgram();\n            if (program != 0u)\n            {\n                /* attach both shader and link */\n                pglAttachShader(program, vertex_shader);\n                pglAttachShader(program, fragment_shader);\n                pglLinkProgram(program);\n                pglGetProgramiv(program, GL_LINK_STATUS, &program_ok);\n\n                if (program_ok != GL_TRUE)\n                {\n                    fprintf(stderr, \"ERROR, failed to link shader program\\n\");\n                    pglGetProgramInfoLog(program, 8192, &log_length, info_log);\n                    fprintf(stderr, \"ERROR: \\n%s\\n\\n\", info_log);\n                    pglDeleteProgram(program);\n                    pglDeleteShader(fragment_shader);\n                    pglDeleteShader(vertex_shader);\n                    program = 0u;\n                }\n            }\n        }\n        else\n        {\n            fprintf(stderr, \"ERROR: Unable to load fragment shader\\n\");\n            pglDeleteShader(vertex_shader);\n        }\n    }\n    else\n    {\n        fprintf(stderr, \"ERROR: Unable to load vertex shader\\n\");\n    }\n    return program;\n}", "path": "StarRuler2-Source/source/glfw/examples/heightmap.c", "commit_date": "2018-07-17 00:00:00", "repo_name": "BlindMindStudios/StarRuler2-Source", "stars": 1438, "license": "other", "language": "c", "size": 503604}
{"docstring": "// Returns a generic string representation of the specified error\n//\n", "func_signal": "static const char* getErrorString(int error)", "code": "{\n    switch (error)\n    {\n        case GLFW_NOT_INITIALIZED:\n            return \"The GLFW library is not initialized\";\n        case GLFW_NO_CURRENT_CONTEXT:\n            return \"There is no current context\";\n        case GLFW_INVALID_ENUM:\n            return \"Invalid argument for enum parameter\";\n        case GLFW_INVALID_VALUE:\n            return \"Invalid value for parameter\";\n        case GLFW_OUT_OF_MEMORY:\n            return \"Out of memory\";\n        case GLFW_API_UNAVAILABLE:\n            return \"The requested client API is unavailable\";\n        case GLFW_VERSION_UNAVAILABLE:\n            return \"The requested client API version is unavailable\";\n        case GLFW_PLATFORM_ERROR:\n            return \"A platform-specific error occurred\";\n        case GLFW_FORMAT_UNAVAILABLE:\n            return \"The requested format is unavailable\";\n    }\n\n    return \"ERROR: UNKNOWN ERROR TOKEN PASSED TO glfwErrorString\";\n}", "path": "StarRuler2-Source/source/glfw/src/init.c", "commit_date": "2018-07-17 00:00:00", "repo_name": "BlindMindStudios/StarRuler2-Source", "stars": 1438, "license": "other", "language": "c", "size": 503604}
{"docstring": "/* This function returns a pointer to the mem_ptr associated with the user\n * functions.  The application should free any memory associated with this\n * pointer before png_write_destroy and png_read_destroy are called.\n */\n", "func_signal": "png_voidp PNGAPI\npng_get_mem_ptr(png_const_structp png_ptr)", "code": "{\n   if (png_ptr == NULL)\n      return (NULL);\n\n   return ((png_voidp)png_ptr->mem_ptr);\n}", "path": "StarRuler2-Source/source/libpng/pngmem.c", "commit_date": "2018-07-17 00:00:00", "repo_name": "BlindMindStudios/StarRuler2-Source", "stars": 1438, "license": "other", "language": "c", "size": 503604}
{"docstring": "/**********************************************************************\n * GLFW callback functions\n *********************************************************************/\n", "func_signal": "static void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods)", "code": "{\n    switch(key)\n    {\n        case GLFW_KEY_ESCAPE:\n            /* Exit program on Escape */\n            glfwSetWindowShouldClose(window, GL_TRUE);\n            break;\n    }\n}", "path": "StarRuler2-Source/source/glfw/examples/heightmap.c", "commit_date": "2018-07-17 00:00:00", "repo_name": "BlindMindStudios/StarRuler2-Source", "stars": 1438, "license": "other", "language": "c", "size": 503604}
{"docstring": "/* PRIVATE */\n", "func_signal": "png_destroy_struct_2(png_voidp struct_ptr, png_free_ptr free_fn,\n    png_voidp mem_ptr)", "code": "{\n#  endif\n   if (struct_ptr != NULL)\n   {\n#  ifdef PNG_USER_MEM_SUPPORTED\n      if (free_fn != NULL)\n      {\n         png_struct dummy_struct;\n         png_structp png_ptr = &dummy_struct;\n         png_ptr->mem_ptr=mem_ptr;\n         (*(free_fn))(png_ptr, struct_ptr);\n         return;\n      }\n\n#  endif /* PNG_USER_MEM_SUPPORTED */\n      farfree (struct_ptr);\n   }\n}", "path": "StarRuler2-Source/source/libpng/pngmem.c", "commit_date": "2018-07-17 00:00:00", "repo_name": "BlindMindStudios/StarRuler2-Source", "stars": 1438, "license": "other", "language": "c", "size": 503604}
{"docstring": "/*\n * Perform the forward DCT on a 6x6 sample block.\n */\n", "func_signal": "GLOBAL(void)\njpeg_fdct_6x6 (DCTELEM * data, JSAMPARRAY sample_data, JDIMENSION start_col)", "code": "{\n  INT32 tmp0, tmp1, tmp2;\n  INT32 tmp10, tmp11, tmp12;\n  DCTELEM *dataptr;\n  JSAMPROW elemptr;\n  int ctr;\n  SHIFT_TEMPS\n\n  /* Pre-zero output coefficient block. */\n  MEMZERO(data, SIZEOF(DCTELEM) * DCTSIZE2);\n\n  /* Pass 1: process rows. */\n  /* Note results are scaled up by sqrt(8) compared to a true DCT; */\n  /* furthermore, we scale the results by 2**PASS1_BITS. */\n  /* cK represents sqrt(2) * cos(K*pi/12). */\n\n  dataptr = data;\n  for (ctr = 0; ctr < 6; ctr++) {\n    elemptr = sample_data[ctr] + start_col;\n\n    /* Even part */\n\n    tmp0 = GETJSAMPLE(elemptr[0]) + GETJSAMPLE(elemptr[5]);\n    tmp11 = GETJSAMPLE(elemptr[1]) + GETJSAMPLE(elemptr[4]);\n    tmp2 = GETJSAMPLE(elemptr[2]) + GETJSAMPLE(elemptr[3]);\n\n    tmp10 = tmp0 + tmp2;\n    tmp12 = tmp0 - tmp2;\n\n    tmp0 = GETJSAMPLE(elemptr[0]) - GETJSAMPLE(elemptr[5]);\n    tmp1 = GETJSAMPLE(elemptr[1]) - GETJSAMPLE(elemptr[4]);\n    tmp2 = GETJSAMPLE(elemptr[2]) - GETJSAMPLE(elemptr[3]);\n\n    /* Apply unsigned->signed conversion */\n    dataptr[0] = (DCTELEM)\n      ((tmp10 + tmp11 - 6 * CENTERJSAMPLE) << PASS1_BITS);\n    dataptr[2] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp12, FIX(1.224744871)),                 /* c2 */\n\t      CONST_BITS-PASS1_BITS);\n    dataptr[4] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp10 - tmp11 - tmp11, FIX(0.707106781)), /* c4 */\n\t      CONST_BITS-PASS1_BITS);\n\n    /* Odd part */\n\n    tmp10 = DESCALE(MULTIPLY(tmp0 + tmp2, FIX(0.366025404)),     /* c5 */\n\t\t    CONST_BITS-PASS1_BITS);\n\n    dataptr[1] = (DCTELEM) (tmp10 + ((tmp0 + tmp1) << PASS1_BITS));\n    dataptr[3] = (DCTELEM) ((tmp0 - tmp1 - tmp2) << PASS1_BITS);\n    dataptr[5] = (DCTELEM) (tmp10 + ((tmp2 - tmp1) << PASS1_BITS));\n\n    dataptr += DCTSIZE;\t\t/* advance pointer to next row */\n  }\n\n  /* Pass 2: process columns.\n   * We remove the PASS1_BITS scaling, but leave the results scaled up\n   * by an overall factor of 8.\n   * We must also scale the output by (8/6)**2 = 16/9, which we fold\n   * into the constant multipliers:\n   * cK now represents sqrt(2) * cos(K*pi/12) * 16/9.\n   */\n\n  dataptr = data;\n  for (ctr = 0; ctr < 6; ctr++) {\n    /* Even part */\n\n    tmp0 = dataptr[DCTSIZE*0] + dataptr[DCTSIZE*5];\n    tmp11 = dataptr[DCTSIZE*1] + dataptr[DCTSIZE*4];\n    tmp2 = dataptr[DCTSIZE*2] + dataptr[DCTSIZE*3];\n\n    tmp10 = tmp0 + tmp2;\n    tmp12 = tmp0 - tmp2;\n\n    tmp0 = dataptr[DCTSIZE*0] - dataptr[DCTSIZE*5];\n    tmp1 = dataptr[DCTSIZE*1] - dataptr[DCTSIZE*4];\n    tmp2 = dataptr[DCTSIZE*2] - dataptr[DCTSIZE*3];\n\n    dataptr[DCTSIZE*0] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp10 + tmp11, FIX(1.777777778)),         /* 16/9 */\n\t      CONST_BITS+PASS1_BITS);\n    dataptr[DCTSIZE*2] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp12, FIX(2.177324216)),                 /* c2 */\n\t      CONST_BITS+PASS1_BITS);\n    dataptr[DCTSIZE*4] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp10 - tmp11 - tmp11, FIX(1.257078722)), /* c4 */\n\t      CONST_BITS+PASS1_BITS);\n\n    /* Odd part */\n\n    tmp10 = MULTIPLY(tmp0 + tmp2, FIX(0.650711829));             /* c5 */\n\n    dataptr[DCTSIZE*1] = (DCTELEM)\n      DESCALE(tmp10 + MULTIPLY(tmp0 + tmp1, FIX(1.777777778)),   /* 16/9 */\n\t      CONST_BITS+PASS1_BITS);\n    dataptr[DCTSIZE*3] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp0 - tmp1 - tmp2, FIX(1.777777778)),    /* 16/9 */\n\t      CONST_BITS+PASS1_BITS);\n    dataptr[DCTSIZE*5] = (DCTELEM)\n      DESCALE(tmp10 + MULTIPLY(tmp2 - tmp1, FIX(1.777777778)),   /* 16/9 */\n\t      CONST_BITS+PASS1_BITS);\n\n    dataptr++;\t\t\t/* advance pointer to next column */\n  }\n}", "path": "HummusJS/src/deps/LibJpeg/jfdctint.c", "commit_date": "2013-06-10 00:00:00", "repo_name": "galkahana/HummusJS", "stars": 1126, "license": "other", "language": "c", "size": 26954}
{"docstring": "/*\n * Perform the forward DCT on a 7x14 sample block.\n *\n * 7-point FDCT in pass 1 (rows), 14-point in pass 2 (columns).\n */\n", "func_signal": "GLOBAL(void)\njpeg_fdct_7x14 (DCTELEM * data, JSAMPARRAY sample_data, JDIMENSION start_col)", "code": "{\n  INT32 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6;\n  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15, tmp16;\n  INT32 z1, z2, z3;\n  DCTELEM workspace[8*6];\n  DCTELEM *dataptr;\n  DCTELEM *wsptr;\n  JSAMPROW elemptr;\n  int ctr;\n  SHIFT_TEMPS\n\n  /* Pre-zero output coefficient block. */\n  MEMZERO(data, SIZEOF(DCTELEM) * DCTSIZE2);\n\n  /* Pass 1: process rows. */\n  /* Note results are scaled up by sqrt(8) compared to a true DCT; */\n  /* furthermore, we scale the results by 2**PASS1_BITS. */\n  /* 7-point FDCT kernel, cK represents sqrt(2) * cos(K*pi/14). */\n\n  dataptr = data;\n  ctr = 0;\n  for (;;) {\n    elemptr = sample_data[ctr] + start_col;\n\n    /* Even part */\n\n    tmp0 = GETJSAMPLE(elemptr[0]) + GETJSAMPLE(elemptr[6]);\n    tmp1 = GETJSAMPLE(elemptr[1]) + GETJSAMPLE(elemptr[5]);\n    tmp2 = GETJSAMPLE(elemptr[2]) + GETJSAMPLE(elemptr[4]);\n    tmp3 = GETJSAMPLE(elemptr[3]);\n\n    tmp10 = GETJSAMPLE(elemptr[0]) - GETJSAMPLE(elemptr[6]);\n    tmp11 = GETJSAMPLE(elemptr[1]) - GETJSAMPLE(elemptr[5]);\n    tmp12 = GETJSAMPLE(elemptr[2]) - GETJSAMPLE(elemptr[4]);\n\n    z1 = tmp0 + tmp2;\n    /* Apply unsigned->signed conversion */\n    dataptr[0] = (DCTELEM)\n      ((z1 + tmp1 + tmp3 - 7 * CENTERJSAMPLE) << PASS1_BITS);\n    tmp3 += tmp3;\n    z1 -= tmp3;\n    z1 -= tmp3;\n    z1 = MULTIPLY(z1, FIX(0.353553391));                /* (c2+c6-c4)/2 */\n    z2 = MULTIPLY(tmp0 - tmp2, FIX(0.920609002));       /* (c2+c4-c6)/2 */\n    z3 = MULTIPLY(tmp1 - tmp2, FIX(0.314692123));       /* c6 */\n    dataptr[2] = (DCTELEM) DESCALE(z1 + z2 + z3, CONST_BITS-PASS1_BITS);\n    z1 -= z2;\n    z2 = MULTIPLY(tmp0 - tmp1, FIX(0.881747734));       /* c4 */\n    dataptr[4] = (DCTELEM)\n      DESCALE(z2 + z3 - MULTIPLY(tmp1 - tmp3, FIX(0.707106781)), /* c2+c6-c4 */\n\t      CONST_BITS-PASS1_BITS);\n    dataptr[6] = (DCTELEM) DESCALE(z1 + z2, CONST_BITS-PASS1_BITS);\n\n    /* Odd part */\n\n    tmp1 = MULTIPLY(tmp10 + tmp11, FIX(0.935414347));   /* (c3+c1-c5)/2 */\n    tmp2 = MULTIPLY(tmp10 - tmp11, FIX(0.170262339));   /* (c3+c5-c1)/2 */\n    tmp0 = tmp1 - tmp2;\n    tmp1 += tmp2;\n    tmp2 = MULTIPLY(tmp11 + tmp12, - FIX(1.378756276)); /* -c1 */\n    tmp1 += tmp2;\n    tmp3 = MULTIPLY(tmp10 + tmp12, FIX(0.613604268));   /* c5 */\n    tmp0 += tmp3;\n    tmp2 += tmp3 + MULTIPLY(tmp12, FIX(1.870828693));   /* c3+c1-c5 */\n\n    dataptr[1] = (DCTELEM) DESCALE(tmp0, CONST_BITS-PASS1_BITS);\n    dataptr[3] = (DCTELEM) DESCALE(tmp1, CONST_BITS-PASS1_BITS);\n    dataptr[5] = (DCTELEM) DESCALE(tmp2, CONST_BITS-PASS1_BITS);\n\n    ctr++;\n\n    if (ctr != DCTSIZE) {\n      if (ctr == 14)\n\tbreak;\t\t\t/* Done. */\n      dataptr += DCTSIZE;\t/* advance pointer to next row */\n    } else\n      dataptr = workspace;\t/* switch pointer to extended workspace */\n  }\n\n  /* Pass 2: process columns.\n   * We remove the PASS1_BITS scaling, but leave the results scaled up\n   * by an overall factor of 8.\n   * We must also scale the output by (8/7)*(8/14) = 32/49, which we\n   * fold into the constant multipliers:\n   * 14-point FDCT kernel, cK represents sqrt(2) * cos(K*pi/28) * 32/49.\n   */\n\n  dataptr = data;\n  wsptr = workspace;\n  for (ctr = 0; ctr < 7; ctr++) {\n    /* Even part */\n\n    tmp0 = dataptr[DCTSIZE*0] + wsptr[DCTSIZE*5];\n    tmp1 = dataptr[DCTSIZE*1] + wsptr[DCTSIZE*4];\n    tmp2 = dataptr[DCTSIZE*2] + wsptr[DCTSIZE*3];\n    tmp13 = dataptr[DCTSIZE*3] + wsptr[DCTSIZE*2];\n    tmp4 = dataptr[DCTSIZE*4] + wsptr[DCTSIZE*1];\n    tmp5 = dataptr[DCTSIZE*5] + wsptr[DCTSIZE*0];\n    tmp6 = dataptr[DCTSIZE*6] + dataptr[DCTSIZE*7];\n\n    tmp10 = tmp0 + tmp6;\n    tmp14 = tmp0 - tmp6;\n    tmp11 = tmp1 + tmp5;\n    tmp15 = tmp1 - tmp5;\n    tmp12 = tmp2 + tmp4;\n    tmp16 = tmp2 - tmp4;\n\n    tmp0 = dataptr[DCTSIZE*0] - wsptr[DCTSIZE*5];\n    tmp1 = dataptr[DCTSIZE*1] - wsptr[DCTSIZE*4];\n    tmp2 = dataptr[DCTSIZE*2] - wsptr[DCTSIZE*3];\n    tmp3 = dataptr[DCTSIZE*3] - wsptr[DCTSIZE*2];\n    tmp4 = dataptr[DCTSIZE*4] - wsptr[DCTSIZE*1];\n    tmp5 = dataptr[DCTSIZE*5] - wsptr[DCTSIZE*0];\n    tmp6 = dataptr[DCTSIZE*6] - dataptr[DCTSIZE*7];\n\n    dataptr[DCTSIZE*0] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp10 + tmp11 + tmp12 + tmp13,\n\t\t       FIX(0.653061224)),                 /* 32/49 */\n\t      CONST_BITS+PASS1_BITS);\n    tmp13 += tmp13;\n    dataptr[DCTSIZE*4] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp10 - tmp13, FIX(0.832106052)) + /* c4 */\n\t      MULTIPLY(tmp11 - tmp13, FIX(0.205513223)) - /* c12 */\n\t      MULTIPLY(tmp12 - tmp13, FIX(0.575835255)),  /* c8 */\n\t      CONST_BITS+PASS1_BITS);\n\n    tmp10 = MULTIPLY(tmp14 + tmp15, FIX(0.722074570));    /* c6 */\n\n    dataptr[DCTSIZE*2] = (DCTELEM)\n      DESCALE(tmp10 + MULTIPLY(tmp14, FIX(0.178337691))   /* c2-c6 */\n\t      + MULTIPLY(tmp16, FIX(0.400721155)),        /* c10 */\n\t      CONST_BITS+PASS1_BITS);\n    dataptr[DCTSIZE*6] = (DCTELEM)\n      DESCALE(tmp10 - MULTIPLY(tmp15, FIX(1.122795725))   /* c6+c10 */\n\t      - MULTIPLY(tmp16, FIX(0.900412262)),        /* c2 */\n\t      CONST_BITS+PASS1_BITS);\n\n    /* Odd part */\n\n    tmp10 = tmp1 + tmp2;\n    tmp11 = tmp5 - tmp4;\n    dataptr[DCTSIZE*7] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp0 - tmp10 + tmp3 - tmp11 - tmp6,\n\t\t       FIX(0.653061224)),                 /* 32/49 */\n\t      CONST_BITS+PASS1_BITS);\n    tmp3  = MULTIPLY(tmp3 , FIX(0.653061224));            /* 32/49 */\n    tmp10 = MULTIPLY(tmp10, - FIX(0.103406812));          /* -c13 */\n    tmp11 = MULTIPLY(tmp11, FIX(0.917760839));            /* c1 */\n    tmp10 += tmp11 - tmp3;\n    tmp11 = MULTIPLY(tmp0 + tmp2, FIX(0.782007410)) +     /* c5 */\n\t    MULTIPLY(tmp4 + tmp6, FIX(0.491367823));      /* c9 */\n    dataptr[DCTSIZE*5] = (DCTELEM)\n      DESCALE(tmp10 + tmp11 - MULTIPLY(tmp2, FIX(1.550341076)) /* c3+c5-c13 */\n\t      + MULTIPLY(tmp4, FIX(0.731428202)),         /* c1+c11-c9 */\n\t      CONST_BITS+PASS1_BITS);\n    tmp12 = MULTIPLY(tmp0 + tmp1, FIX(0.871740478)) +     /* c3 */\n\t    MULTIPLY(tmp5 - tmp6, FIX(0.305035186));      /* c11 */\n    dataptr[DCTSIZE*3] = (DCTELEM)\n      DESCALE(tmp10 + tmp12 - MULTIPLY(tmp1, FIX(0.276965844)) /* c3-c9-c13 */\n\t      - MULTIPLY(tmp5, FIX(2.004803435)),         /* c1+c5+c11 */\n\t      CONST_BITS+PASS1_BITS);\n    dataptr[DCTSIZE*1] = (DCTELEM)\n      DESCALE(tmp11 + tmp12 + tmp3\n\t      - MULTIPLY(tmp0, FIX(0.735987049))          /* c3+c5-c1 */\n\t      - MULTIPLY(tmp6, FIX(0.082925825)),         /* c9-c11-c13 */\n\t      CONST_BITS+PASS1_BITS);\n\n    dataptr++;\t\t\t/* advance pointer to next column */\n    wsptr++;\t\t\t/* advance pointer to next column */\n  }\n}", "path": "HummusJS/src/deps/LibJpeg/jfdctint.c", "commit_date": "2013-06-10 00:00:00", "repo_name": "galkahana/HummusJS", "stars": 1126, "license": "other", "language": "c", "size": 26954}
{"docstring": "/*\n * Perform the forward DCT on a 9x9 sample block.\n */\n", "func_signal": "GLOBAL(void)\njpeg_fdct_9x9 (DCTELEM * data, JSAMPARRAY sample_data, JDIMENSION start_col)", "code": "{\n  INT32 tmp0, tmp1, tmp2, tmp3, tmp4;\n  INT32 tmp10, tmp11, tmp12, tmp13;\n  INT32 z1, z2;\n  DCTELEM workspace[8];\n  DCTELEM *dataptr;\n  DCTELEM *wsptr;\n  JSAMPROW elemptr;\n  int ctr;\n  SHIFT_TEMPS\n\n  /* Pass 1: process rows. */\n  /* Note results are scaled up by sqrt(8) compared to a true DCT; */\n  /* we scale the results further by 2 as part of output adaption */\n  /* scaling for different DCT size. */\n  /* cK represents sqrt(2) * cos(K*pi/18). */\n\n  dataptr = data;\n  ctr = 0;\n  for (;;) {\n    elemptr = sample_data[ctr] + start_col;\n\n    /* Even part */\n\n    tmp0 = GETJSAMPLE(elemptr[0]) + GETJSAMPLE(elemptr[8]);\n    tmp1 = GETJSAMPLE(elemptr[1]) + GETJSAMPLE(elemptr[7]);\n    tmp2 = GETJSAMPLE(elemptr[2]) + GETJSAMPLE(elemptr[6]);\n    tmp3 = GETJSAMPLE(elemptr[3]) + GETJSAMPLE(elemptr[5]);\n    tmp4 = GETJSAMPLE(elemptr[4]);\n\n    tmp10 = GETJSAMPLE(elemptr[0]) - GETJSAMPLE(elemptr[8]);\n    tmp11 = GETJSAMPLE(elemptr[1]) - GETJSAMPLE(elemptr[7]);\n    tmp12 = GETJSAMPLE(elemptr[2]) - GETJSAMPLE(elemptr[6]);\n    tmp13 = GETJSAMPLE(elemptr[3]) - GETJSAMPLE(elemptr[5]);\n\n    z1 = tmp0 + tmp2 + tmp3;\n    z2 = tmp1 + tmp4;\n    /* Apply unsigned->signed conversion */\n    dataptr[0] = (DCTELEM) ((z1 + z2 - 9 * CENTERJSAMPLE) << 1);\n    dataptr[6] = (DCTELEM)\n      DESCALE(MULTIPLY(z1 - z2 - z2, FIX(0.707106781)),  /* c6 */\n\t      CONST_BITS-1);\n    z1 = MULTIPLY(tmp0 - tmp2, FIX(1.328926049));        /* c2 */\n    z2 = MULTIPLY(tmp1 - tmp4 - tmp4, FIX(0.707106781)); /* c6 */\n    dataptr[2] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp2 - tmp3, FIX(1.083350441))    /* c4 */\n\t      + z1 + z2, CONST_BITS-1);\n    dataptr[4] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp3 - tmp0, FIX(0.245575608))    /* c8 */\n\t      + z1 - z2, CONST_BITS-1);\n\n    /* Odd part */\n\n    dataptr[3] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp10 - tmp12 - tmp13, FIX(1.224744871)), /* c3 */\n\t      CONST_BITS-1);\n\n    tmp11 = MULTIPLY(tmp11, FIX(1.224744871));        /* c3 */\n    tmp0 = MULTIPLY(tmp10 + tmp12, FIX(0.909038955)); /* c5 */\n    tmp1 = MULTIPLY(tmp10 + tmp13, FIX(0.483689525)); /* c7 */\n\n    dataptr[1] = (DCTELEM) DESCALE(tmp11 + tmp0 + tmp1, CONST_BITS-1);\n\n    tmp2 = MULTIPLY(tmp12 - tmp13, FIX(1.392728481)); /* c1 */\n\n    dataptr[5] = (DCTELEM) DESCALE(tmp0 - tmp11 - tmp2, CONST_BITS-1);\n    dataptr[7] = (DCTELEM) DESCALE(tmp1 - tmp11 + tmp2, CONST_BITS-1);\n\n    ctr++;\n\n    if (ctr != DCTSIZE) {\n      if (ctr == 9)\n\tbreak;\t\t\t/* Done. */\n      dataptr += DCTSIZE;\t/* advance pointer to next row */\n    } else\n      dataptr = workspace;\t/* switch pointer to extended workspace */\n  }\n\n  /* Pass 2: process columns.\n   * We leave the results scaled up by an overall factor of 8.\n   * We must also scale the output by (8/9)**2 = 64/81, which we partially\n   * fold into the constant multipliers and final/initial shifting:\n   * cK now represents sqrt(2) * cos(K*pi/18) * 128/81.\n   */\n\n  dataptr = data;\n  wsptr = workspace;\n  for (ctr = DCTSIZE-1; ctr >= 0; ctr--) {\n    /* Even part */\n\n    tmp0 = dataptr[DCTSIZE*0] + wsptr[DCTSIZE*0];\n    tmp1 = dataptr[DCTSIZE*1] + dataptr[DCTSIZE*7];\n    tmp2 = dataptr[DCTSIZE*2] + dataptr[DCTSIZE*6];\n    tmp3 = dataptr[DCTSIZE*3] + dataptr[DCTSIZE*5];\n    tmp4 = dataptr[DCTSIZE*4];\n\n    tmp10 = dataptr[DCTSIZE*0] - wsptr[DCTSIZE*0];\n    tmp11 = dataptr[DCTSIZE*1] - dataptr[DCTSIZE*7];\n    tmp12 = dataptr[DCTSIZE*2] - dataptr[DCTSIZE*6];\n    tmp13 = dataptr[DCTSIZE*3] - dataptr[DCTSIZE*5];\n\n    z1 = tmp0 + tmp2 + tmp3;\n    z2 = tmp1 + tmp4;\n    dataptr[DCTSIZE*0] = (DCTELEM)\n      DESCALE(MULTIPLY(z1 + z2, FIX(1.580246914)),       /* 128/81 */\n\t      CONST_BITS+2);\n    dataptr[DCTSIZE*6] = (DCTELEM)\n      DESCALE(MULTIPLY(z1 - z2 - z2, FIX(1.117403309)),  /* c6 */\n\t      CONST_BITS+2);\n    z1 = MULTIPLY(tmp0 - tmp2, FIX(2.100031287));        /* c2 */\n    z2 = MULTIPLY(tmp1 - tmp4 - tmp4, FIX(1.117403309)); /* c6 */\n    dataptr[DCTSIZE*2] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp2 - tmp3, FIX(1.711961190))    /* c4 */\n\t      + z1 + z2, CONST_BITS+2);\n    dataptr[DCTSIZE*4] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp3 - tmp0, FIX(0.388070096))    /* c8 */\n\t      + z1 - z2, CONST_BITS+2);\n\n    /* Odd part */\n\n    dataptr[DCTSIZE*3] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp10 - tmp12 - tmp13, FIX(1.935399303)), /* c3 */\n\t      CONST_BITS+2);\n\n    tmp11 = MULTIPLY(tmp11, FIX(1.935399303));        /* c3 */\n    tmp0 = MULTIPLY(tmp10 + tmp12, FIX(1.436506004)); /* c5 */\n    tmp1 = MULTIPLY(tmp10 + tmp13, FIX(0.764348879)); /* c7 */\n\n    dataptr[DCTSIZE*1] = (DCTELEM)\n      DESCALE(tmp11 + tmp0 + tmp1, CONST_BITS+2);\n\n    tmp2 = MULTIPLY(tmp12 - tmp13, FIX(2.200854883)); /* c1 */\n\n    dataptr[DCTSIZE*5] = (DCTELEM)\n      DESCALE(tmp0 - tmp11 - tmp2, CONST_BITS+2);\n    dataptr[DCTSIZE*7] = (DCTELEM)\n      DESCALE(tmp1 - tmp11 + tmp2, CONST_BITS+2);\n\n    dataptr++;\t\t\t/* advance pointer to next column */\n    wsptr++;\t\t\t/* advance pointer to next column */\n  }\n}", "path": "HummusJS/src/deps/LibJpeg/jfdctint.c", "commit_date": "2013-06-10 00:00:00", "repo_name": "galkahana/HummusJS", "stars": 1126, "license": "other", "language": "c", "size": 26954}
{"docstring": "/*\n * Perform the forward DCT on a 15x15 sample block.\n */\n", "func_signal": "GLOBAL(void)\njpeg_fdct_15x15 (DCTELEM * data, JSAMPARRAY sample_data, JDIMENSION start_col)", "code": "{\n  INT32 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;\n  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15, tmp16;\n  INT32 z1, z2, z3;\n  DCTELEM workspace[8*7];\n  DCTELEM *dataptr;\n  DCTELEM *wsptr;\n  JSAMPROW elemptr;\n  int ctr;\n  SHIFT_TEMPS\n\n  /* Pass 1: process rows. */\n  /* Note results are scaled up by sqrt(8) compared to a true DCT. */\n  /* cK represents sqrt(2) * cos(K*pi/30). */\n\n  dataptr = data;\n  ctr = 0;\n  for (;;) {\n    elemptr = sample_data[ctr] + start_col;\n\n    /* Even part */\n\n    tmp0 = GETJSAMPLE(elemptr[0]) + GETJSAMPLE(elemptr[14]);\n    tmp1 = GETJSAMPLE(elemptr[1]) + GETJSAMPLE(elemptr[13]);\n    tmp2 = GETJSAMPLE(elemptr[2]) + GETJSAMPLE(elemptr[12]);\n    tmp3 = GETJSAMPLE(elemptr[3]) + GETJSAMPLE(elemptr[11]);\n    tmp4 = GETJSAMPLE(elemptr[4]) + GETJSAMPLE(elemptr[10]);\n    tmp5 = GETJSAMPLE(elemptr[5]) + GETJSAMPLE(elemptr[9]);\n    tmp6 = GETJSAMPLE(elemptr[6]) + GETJSAMPLE(elemptr[8]);\n    tmp7 = GETJSAMPLE(elemptr[7]);\n\n    tmp10 = GETJSAMPLE(elemptr[0]) - GETJSAMPLE(elemptr[14]);\n    tmp11 = GETJSAMPLE(elemptr[1]) - GETJSAMPLE(elemptr[13]);\n    tmp12 = GETJSAMPLE(elemptr[2]) - GETJSAMPLE(elemptr[12]);\n    tmp13 = GETJSAMPLE(elemptr[3]) - GETJSAMPLE(elemptr[11]);\n    tmp14 = GETJSAMPLE(elemptr[4]) - GETJSAMPLE(elemptr[10]);\n    tmp15 = GETJSAMPLE(elemptr[5]) - GETJSAMPLE(elemptr[9]);\n    tmp16 = GETJSAMPLE(elemptr[6]) - GETJSAMPLE(elemptr[8]);\n\n    z1 = tmp0 + tmp4 + tmp5;\n    z2 = tmp1 + tmp3 + tmp6;\n    z3 = tmp2 + tmp7;\n    /* Apply unsigned->signed conversion */\n    dataptr[0] = (DCTELEM) (z1 + z2 + z3 - 15 * CENTERJSAMPLE);\n    z3 += z3;\n    dataptr[6] = (DCTELEM)\n      DESCALE(MULTIPLY(z1 - z3, FIX(1.144122806)) - /* c6 */\n\t      MULTIPLY(z2 - z3, FIX(0.437016024)),  /* c12 */\n\t      CONST_BITS);\n    tmp2 += ((tmp1 + tmp4) >> 1) - tmp7 - tmp7;\n    z1 = MULTIPLY(tmp3 - tmp2, FIX(1.531135173)) -  /* c2+c14 */\n         MULTIPLY(tmp6 - tmp2, FIX(2.238241955));   /* c4+c8 */\n    z2 = MULTIPLY(tmp5 - tmp2, FIX(0.798468008)) -  /* c8-c14 */\n\t MULTIPLY(tmp0 - tmp2, FIX(0.091361227));   /* c2-c4 */\n    z3 = MULTIPLY(tmp0 - tmp3, FIX(1.383309603)) +  /* c2 */\n\t MULTIPLY(tmp6 - tmp5, FIX(0.946293579)) +  /* c8 */\n\t MULTIPLY(tmp1 - tmp4, FIX(0.790569415));   /* (c6+c12)/2 */\n\n    dataptr[2] = (DCTELEM) DESCALE(z1 + z3, CONST_BITS);\n    dataptr[4] = (DCTELEM) DESCALE(z2 + z3, CONST_BITS);\n\n    /* Odd part */\n\n    tmp2 = MULTIPLY(tmp10 - tmp12 - tmp13 + tmp15 + tmp16,\n\t\t    FIX(1.224744871));                         /* c5 */\n    tmp1 = MULTIPLY(tmp10 - tmp14 - tmp15, FIX(1.344997024)) + /* c3 */\n\t   MULTIPLY(tmp11 - tmp13 - tmp16, FIX(0.831253876));  /* c9 */\n    tmp12 = MULTIPLY(tmp12, FIX(1.224744871));                 /* c5 */\n    tmp4 = MULTIPLY(tmp10 - tmp16, FIX(1.406466353)) +         /* c1 */\n\t   MULTIPLY(tmp11 + tmp14, FIX(1.344997024)) +         /* c3 */\n\t   MULTIPLY(tmp13 + tmp15, FIX(0.575212477));          /* c11 */\n    tmp0 = MULTIPLY(tmp13, FIX(0.475753014)) -                 /* c7-c11 */\n\t   MULTIPLY(tmp14, FIX(0.513743148)) +                 /* c3-c9 */\n\t   MULTIPLY(tmp16, FIX(1.700497885)) + tmp4 + tmp12;   /* c1+c13 */\n    tmp3 = MULTIPLY(tmp10, - FIX(0.355500862)) -               /* -(c1-c7) */\n\t   MULTIPLY(tmp11, FIX(2.176250899)) -                 /* c3+c9 */\n\t   MULTIPLY(tmp15, FIX(0.869244010)) + tmp4 - tmp12;   /* c11+c13 */\n\n    dataptr[1] = (DCTELEM) DESCALE(tmp0, CONST_BITS);\n    dataptr[3] = (DCTELEM) DESCALE(tmp1, CONST_BITS);\n    dataptr[5] = (DCTELEM) DESCALE(tmp2, CONST_BITS);\n    dataptr[7] = (DCTELEM) DESCALE(tmp3, CONST_BITS);\n\n    ctr++;\n\n    if (ctr != DCTSIZE) {\n      if (ctr == 15)\n\tbreak;\t\t\t/* Done. */\n      dataptr += DCTSIZE;\t/* advance pointer to next row */\n    } else\n      dataptr = workspace;\t/* switch pointer to extended workspace */\n  }\n\n  /* Pass 2: process columns.\n   * We leave the results scaled up by an overall factor of 8.\n   * We must also scale the output by (8/15)**2 = 64/225, which we partially\n   * fold into the constant multipliers and final shifting:\n   * cK now represents sqrt(2) * cos(K*pi/30) * 256/225.\n   */\n\n  dataptr = data;\n  wsptr = workspace;\n  for (ctr = DCTSIZE-1; ctr >= 0; ctr--) {\n    /* Even part */\n\n    tmp0 = dataptr[DCTSIZE*0] + wsptr[DCTSIZE*6];\n    tmp1 = dataptr[DCTSIZE*1] + wsptr[DCTSIZE*5];\n    tmp2 = dataptr[DCTSIZE*2] + wsptr[DCTSIZE*4];\n    tmp3 = dataptr[DCTSIZE*3] + wsptr[DCTSIZE*3];\n    tmp4 = dataptr[DCTSIZE*4] + wsptr[DCTSIZE*2];\n    tmp5 = dataptr[DCTSIZE*5] + wsptr[DCTSIZE*1];\n    tmp6 = dataptr[DCTSIZE*6] + wsptr[DCTSIZE*0];\n    tmp7 = dataptr[DCTSIZE*7];\n\n    tmp10 = dataptr[DCTSIZE*0] - wsptr[DCTSIZE*6];\n    tmp11 = dataptr[DCTSIZE*1] - wsptr[DCTSIZE*5];\n    tmp12 = dataptr[DCTSIZE*2] - wsptr[DCTSIZE*4];\n    tmp13 = dataptr[DCTSIZE*3] - wsptr[DCTSIZE*3];\n    tmp14 = dataptr[DCTSIZE*4] - wsptr[DCTSIZE*2];\n    tmp15 = dataptr[DCTSIZE*5] - wsptr[DCTSIZE*1];\n    tmp16 = dataptr[DCTSIZE*6] - wsptr[DCTSIZE*0];\n\n    z1 = tmp0 + tmp4 + tmp5;\n    z2 = tmp1 + tmp3 + tmp6;\n    z3 = tmp2 + tmp7;\n    dataptr[DCTSIZE*0] = (DCTELEM)\n      DESCALE(MULTIPLY(z1 + z2 + z3, FIX(1.137777778)), /* 256/225 */\n\t      CONST_BITS+2);\n    z3 += z3;\n    dataptr[DCTSIZE*6] = (DCTELEM)\n      DESCALE(MULTIPLY(z1 - z3, FIX(1.301757503)) - /* c6 */\n\t      MULTIPLY(z2 - z3, FIX(0.497227121)),  /* c12 */\n\t      CONST_BITS+2);\n    tmp2 += ((tmp1 + tmp4) >> 1) - tmp7 - tmp7;\n    z1 = MULTIPLY(tmp3 - tmp2, FIX(1.742091575)) -  /* c2+c14 */\n         MULTIPLY(tmp6 - tmp2, FIX(2.546621957));   /* c4+c8 */\n    z2 = MULTIPLY(tmp5 - tmp2, FIX(0.908479156)) -  /* c8-c14 */\n\t MULTIPLY(tmp0 - tmp2, FIX(0.103948774));   /* c2-c4 */\n    z3 = MULTIPLY(tmp0 - tmp3, FIX(1.573898926)) +  /* c2 */\n\t MULTIPLY(tmp6 - tmp5, FIX(1.076671805)) +  /* c8 */\n\t MULTIPLY(tmp1 - tmp4, FIX(0.899492312));   /* (c6+c12)/2 */\n\n    dataptr[DCTSIZE*2] = (DCTELEM) DESCALE(z1 + z3, CONST_BITS+2);\n    dataptr[DCTSIZE*4] = (DCTELEM) DESCALE(z2 + z3, CONST_BITS+2);\n\n    /* Odd part */\n\n    tmp2 = MULTIPLY(tmp10 - tmp12 - tmp13 + tmp15 + tmp16,\n\t\t    FIX(1.393487498));                         /* c5 */\n    tmp1 = MULTIPLY(tmp10 - tmp14 - tmp15, FIX(1.530307725)) + /* c3 */\n\t   MULTIPLY(tmp11 - tmp13 - tmp16, FIX(0.945782187));  /* c9 */\n    tmp12 = MULTIPLY(tmp12, FIX(1.393487498));                 /* c5 */\n    tmp4 = MULTIPLY(tmp10 - tmp16, FIX(1.600246161)) +         /* c1 */\n\t   MULTIPLY(tmp11 + tmp14, FIX(1.530307725)) +         /* c3 */\n\t   MULTIPLY(tmp13 + tmp15, FIX(0.654463974));          /* c11 */\n    tmp0 = MULTIPLY(tmp13, FIX(0.541301207)) -                 /* c7-c11 */\n\t   MULTIPLY(tmp14, FIX(0.584525538)) +                 /* c3-c9 */\n\t   MULTIPLY(tmp16, FIX(1.934788705)) + tmp4 + tmp12;   /* c1+c13 */\n    tmp3 = MULTIPLY(tmp10, - FIX(0.404480980)) -               /* -(c1-c7) */\n\t   MULTIPLY(tmp11, FIX(2.476089912)) -                 /* c3+c9 */\n\t   MULTIPLY(tmp15, FIX(0.989006518)) + tmp4 - tmp12;   /* c11+c13 */\n\n    dataptr[DCTSIZE*1] = (DCTELEM) DESCALE(tmp0, CONST_BITS+2);\n    dataptr[DCTSIZE*3] = (DCTELEM) DESCALE(tmp1, CONST_BITS+2);\n    dataptr[DCTSIZE*5] = (DCTELEM) DESCALE(tmp2, CONST_BITS+2);\n    dataptr[DCTSIZE*7] = (DCTELEM) DESCALE(tmp3, CONST_BITS+2);\n\n    dataptr++;\t\t\t/* advance pointer to next column */\n    wsptr++;\t\t\t/* advance pointer to next column */\n  }\n}", "path": "HummusJS/src/deps/LibJpeg/jfdctint.c", "commit_date": "2013-06-10 00:00:00", "repo_name": "galkahana/HummusJS", "stars": 1126, "license": "other", "language": "c", "size": 26954}
{"docstring": "/*\n * Perform the forward DCT on a 2x2 sample block.\n */\n", "func_signal": "GLOBAL(void)\njpeg_fdct_2x2 (DCTELEM * data, JSAMPARRAY sample_data, JDIMENSION start_col)", "code": "{\n  INT32 tmp0, tmp1, tmp2, tmp3;\n  JSAMPROW elemptr;\n\n  /* Pre-zero output coefficient block. */\n  MEMZERO(data, SIZEOF(DCTELEM) * DCTSIZE2);\n\n  /* Pass 1: process rows. */\n  /* Note results are scaled up by sqrt(8) compared to a true DCT. */\n\n  /* Row 0 */\n  elemptr = sample_data[0] + start_col;\n\n  tmp0 = GETJSAMPLE(elemptr[0]) + GETJSAMPLE(elemptr[1]);\n  tmp1 = GETJSAMPLE(elemptr[0]) - GETJSAMPLE(elemptr[1]);\n\n  /* Row 1 */\n  elemptr = sample_data[1] + start_col;\n\n  tmp2 = GETJSAMPLE(elemptr[0]) + GETJSAMPLE(elemptr[1]);\n  tmp3 = GETJSAMPLE(elemptr[0]) - GETJSAMPLE(elemptr[1]);\n\n  /* Pass 2: process columns.\n   * We leave the results scaled up by an overall factor of 8.\n   * We must also scale the output by (8/2)**2 = 2**4.\n   */\n\n  /* Column 0 */\n  /* Apply unsigned->signed conversion */\n  data[DCTSIZE*0] = (DCTELEM) ((tmp0 + tmp2 - 4 * CENTERJSAMPLE) << 4);\n  data[DCTSIZE*1] = (DCTELEM) ((tmp0 - tmp2) << 4);\n\n  /* Column 1 */\n  data[DCTSIZE*0+1] = (DCTELEM) ((tmp1 + tmp3) << 4);\n  data[DCTSIZE*1+1] = (DCTELEM) ((tmp1 - tmp3) << 4);\n}", "path": "HummusJS/src/deps/LibJpeg/jfdctint.c", "commit_date": "2013-06-10 00:00:00", "repo_name": "galkahana/HummusJS", "stars": 1126, "license": "other", "language": "c", "size": 26954}
{"docstring": "/*\n * Perform the forward DCT on a 2x1 sample block.\n *\n * 2-point FDCT in pass 1 (rows), 1-point in pass 2 (columns).\n */\n", "func_signal": "GLOBAL(void)\njpeg_fdct_2x1 (DCTELEM * data, JSAMPARRAY sample_data, JDIMENSION start_col)", "code": "{\n  INT32 tmp0, tmp1;\n  JSAMPROW elemptr;\n\n  /* Pre-zero output coefficient block. */\n  MEMZERO(data, SIZEOF(DCTELEM) * DCTSIZE2);\n\n  elemptr = sample_data[0] + start_col;\n\n  tmp0 = GETJSAMPLE(elemptr[0]);\n  tmp1 = GETJSAMPLE(elemptr[1]);\n\n  /* We leave the results scaled up by an overall factor of 8.\n   * We must also scale the output by (8/2)*(8/1) = 2**5.\n   */\n\n  /* Even part */\n  /* Apply unsigned->signed conversion */\n  data[0] = (DCTELEM) ((tmp0 + tmp1 - 2 * CENTERJSAMPLE) << 5);\n\n  /* Odd part */\n  data[1] = (DCTELEM) ((tmp0 - tmp1) << 5);\n}", "path": "HummusJS/src/deps/LibJpeg/jfdctint.c", "commit_date": "2013-06-10 00:00:00", "repo_name": "galkahana/HummusJS", "stars": 1126, "license": "other", "language": "c", "size": 26954}
{"docstring": "/*\n * Perform the forward DCT on a 13x13 sample block.\n */\n", "func_signal": "GLOBAL(void)\njpeg_fdct_13x13 (DCTELEM * data, JSAMPARRAY sample_data, JDIMENSION start_col)", "code": "{\n  INT32 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6;\n  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15;\n  INT32 z1, z2;\n  DCTELEM workspace[8*5];\n  DCTELEM *dataptr;\n  DCTELEM *wsptr;\n  JSAMPROW elemptr;\n  int ctr;\n  SHIFT_TEMPS\n\n  /* Pass 1: process rows. */\n  /* Note results are scaled up by sqrt(8) compared to a true DCT. */\n  /* cK represents sqrt(2) * cos(K*pi/26). */\n\n  dataptr = data;\n  ctr = 0;\n  for (;;) {\n    elemptr = sample_data[ctr] + start_col;\n\n    /* Even part */\n\n    tmp0 = GETJSAMPLE(elemptr[0]) + GETJSAMPLE(elemptr[12]);\n    tmp1 = GETJSAMPLE(elemptr[1]) + GETJSAMPLE(elemptr[11]);\n    tmp2 = GETJSAMPLE(elemptr[2]) + GETJSAMPLE(elemptr[10]);\n    tmp3 = GETJSAMPLE(elemptr[3]) + GETJSAMPLE(elemptr[9]);\n    tmp4 = GETJSAMPLE(elemptr[4]) + GETJSAMPLE(elemptr[8]);\n    tmp5 = GETJSAMPLE(elemptr[5]) + GETJSAMPLE(elemptr[7]);\n    tmp6 = GETJSAMPLE(elemptr[6]);\n\n    tmp10 = GETJSAMPLE(elemptr[0]) - GETJSAMPLE(elemptr[12]);\n    tmp11 = GETJSAMPLE(elemptr[1]) - GETJSAMPLE(elemptr[11]);\n    tmp12 = GETJSAMPLE(elemptr[2]) - GETJSAMPLE(elemptr[10]);\n    tmp13 = GETJSAMPLE(elemptr[3]) - GETJSAMPLE(elemptr[9]);\n    tmp14 = GETJSAMPLE(elemptr[4]) - GETJSAMPLE(elemptr[8]);\n    tmp15 = GETJSAMPLE(elemptr[5]) - GETJSAMPLE(elemptr[7]);\n\n    /* Apply unsigned->signed conversion */\n    dataptr[0] = (DCTELEM)\n      (tmp0 + tmp1 + tmp2 + tmp3 + tmp4 + tmp5 + tmp6 - 13 * CENTERJSAMPLE);\n    tmp6 += tmp6;\n    tmp0 -= tmp6;\n    tmp1 -= tmp6;\n    tmp2 -= tmp6;\n    tmp3 -= tmp6;\n    tmp4 -= tmp6;\n    tmp5 -= tmp6;\n    dataptr[2] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp0, FIX(1.373119086)) +   /* c2 */\n\t      MULTIPLY(tmp1, FIX(1.058554052)) +   /* c6 */\n\t      MULTIPLY(tmp2, FIX(0.501487041)) -   /* c10 */\n\t      MULTIPLY(tmp3, FIX(0.170464608)) -   /* c12 */\n\t      MULTIPLY(tmp4, FIX(0.803364869)) -   /* c8 */\n\t      MULTIPLY(tmp5, FIX(1.252223920)),    /* c4 */\n\t      CONST_BITS);\n    z1 = MULTIPLY(tmp0 - tmp2, FIX(1.155388986)) - /* (c4+c6)/2 */\n\t MULTIPLY(tmp3 - tmp4, FIX(0.435816023)) - /* (c2-c10)/2 */\n\t MULTIPLY(tmp1 - tmp5, FIX(0.316450131));  /* (c8-c12)/2 */\n    z2 = MULTIPLY(tmp0 + tmp2, FIX(0.096834934)) - /* (c4-c6)/2 */\n\t MULTIPLY(tmp3 + tmp4, FIX(0.937303064)) + /* (c2+c10)/2 */\n\t MULTIPLY(tmp1 + tmp5, FIX(0.486914739));  /* (c8+c12)/2 */\n\n    dataptr[4] = (DCTELEM) DESCALE(z1 + z2, CONST_BITS);\n    dataptr[6] = (DCTELEM) DESCALE(z1 - z2, CONST_BITS);\n\n    /* Odd part */\n\n    tmp1 = MULTIPLY(tmp10 + tmp11, FIX(1.322312651));   /* c3 */\n    tmp2 = MULTIPLY(tmp10 + tmp12, FIX(1.163874945));   /* c5 */\n    tmp3 = MULTIPLY(tmp10 + tmp13, FIX(0.937797057)) +  /* c7 */\n\t   MULTIPLY(tmp14 + tmp15, FIX(0.338443458));   /* c11 */\n    tmp0 = tmp1 + tmp2 + tmp3 -\n\t   MULTIPLY(tmp10, FIX(2.020082300)) +          /* c3+c5+c7-c1 */\n\t   MULTIPLY(tmp14, FIX(0.318774355));           /* c9-c11 */\n    tmp4 = MULTIPLY(tmp14 - tmp15, FIX(0.937797057)) -  /* c7 */\n\t   MULTIPLY(tmp11 + tmp12, FIX(0.338443458));   /* c11 */\n    tmp5 = MULTIPLY(tmp11 + tmp13, - FIX(1.163874945)); /* -c5 */\n    tmp1 += tmp4 + tmp5 +\n\t    MULTIPLY(tmp11, FIX(0.837223564)) -         /* c5+c9+c11-c3 */\n\t    MULTIPLY(tmp14, FIX(2.341699410));          /* c1+c7 */\n    tmp6 = MULTIPLY(tmp12 + tmp13, - FIX(0.657217813)); /* -c9 */\n    tmp2 += tmp4 + tmp6 -\n\t    MULTIPLY(tmp12, FIX(1.572116027)) +         /* c1+c5-c9-c11 */\n\t    MULTIPLY(tmp15, FIX(2.260109708));          /* c3+c7 */\n    tmp3 += tmp5 + tmp6 +\n\t    MULTIPLY(tmp13, FIX(2.205608352)) -         /* c3+c5+c9-c7 */\n\t    MULTIPLY(tmp15, FIX(1.742345811));          /* c1+c11 */\n\n    dataptr[1] = (DCTELEM) DESCALE(tmp0, CONST_BITS);\n    dataptr[3] = (DCTELEM) DESCALE(tmp1, CONST_BITS);\n    dataptr[5] = (DCTELEM) DESCALE(tmp2, CONST_BITS);\n    dataptr[7] = (DCTELEM) DESCALE(tmp3, CONST_BITS);\n\n    ctr++;\n\n    if (ctr != DCTSIZE) {\n      if (ctr == 13)\n\tbreak;\t\t\t/* Done. */\n      dataptr += DCTSIZE;\t/* advance pointer to next row */\n    } else\n      dataptr = workspace;\t/* switch pointer to extended workspace */\n  }\n\n  /* Pass 2: process columns.\n   * We leave the results scaled up by an overall factor of 8.\n   * We must also scale the output by (8/13)**2 = 64/169, which we partially\n   * fold into the constant multipliers and final shifting:\n   * cK now represents sqrt(2) * cos(K*pi/26) * 128/169.\n   */\n\n  dataptr = data;\n  wsptr = workspace;\n  for (ctr = DCTSIZE-1; ctr >= 0; ctr--) {\n    /* Even part */\n\n    tmp0 = dataptr[DCTSIZE*0] + wsptr[DCTSIZE*4];\n    tmp1 = dataptr[DCTSIZE*1] + wsptr[DCTSIZE*3];\n    tmp2 = dataptr[DCTSIZE*2] + wsptr[DCTSIZE*2];\n    tmp3 = dataptr[DCTSIZE*3] + wsptr[DCTSIZE*1];\n    tmp4 = dataptr[DCTSIZE*4] + wsptr[DCTSIZE*0];\n    tmp5 = dataptr[DCTSIZE*5] + dataptr[DCTSIZE*7];\n    tmp6 = dataptr[DCTSIZE*6];\n\n    tmp10 = dataptr[DCTSIZE*0] - wsptr[DCTSIZE*4];\n    tmp11 = dataptr[DCTSIZE*1] - wsptr[DCTSIZE*3];\n    tmp12 = dataptr[DCTSIZE*2] - wsptr[DCTSIZE*2];\n    tmp13 = dataptr[DCTSIZE*3] - wsptr[DCTSIZE*1];\n    tmp14 = dataptr[DCTSIZE*4] - wsptr[DCTSIZE*0];\n    tmp15 = dataptr[DCTSIZE*5] - dataptr[DCTSIZE*7];\n\n    dataptr[DCTSIZE*0] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp0 + tmp1 + tmp2 + tmp3 + tmp4 + tmp5 + tmp6,\n\t\t       FIX(0.757396450)),          /* 128/169 */\n\t      CONST_BITS+1);\n    tmp6 += tmp6;\n    tmp0 -= tmp6;\n    tmp1 -= tmp6;\n    tmp2 -= tmp6;\n    tmp3 -= tmp6;\n    tmp4 -= tmp6;\n    tmp5 -= tmp6;\n    dataptr[DCTSIZE*2] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp0, FIX(1.039995521)) +   /* c2 */\n\t      MULTIPLY(tmp1, FIX(0.801745081)) +   /* c6 */\n\t      MULTIPLY(tmp2, FIX(0.379824504)) -   /* c10 */\n\t      MULTIPLY(tmp3, FIX(0.129109289)) -   /* c12 */\n\t      MULTIPLY(tmp4, FIX(0.608465700)) -   /* c8 */\n\t      MULTIPLY(tmp5, FIX(0.948429952)),    /* c4 */\n\t      CONST_BITS+1);\n    z1 = MULTIPLY(tmp0 - tmp2, FIX(0.875087516)) - /* (c4+c6)/2 */\n\t MULTIPLY(tmp3 - tmp4, FIX(0.330085509)) - /* (c2-c10)/2 */\n\t MULTIPLY(tmp1 - tmp5, FIX(0.239678205));  /* (c8-c12)/2 */\n    z2 = MULTIPLY(tmp0 + tmp2, FIX(0.073342435)) - /* (c4-c6)/2 */\n\t MULTIPLY(tmp3 + tmp4, FIX(0.709910013)) + /* (c2+c10)/2 */\n\t MULTIPLY(tmp1 + tmp5, FIX(0.368787494));  /* (c8+c12)/2 */\n\n    dataptr[DCTSIZE*4] = (DCTELEM) DESCALE(z1 + z2, CONST_BITS+1);\n    dataptr[DCTSIZE*6] = (DCTELEM) DESCALE(z1 - z2, CONST_BITS+1);\n\n    /* Odd part */\n\n    tmp1 = MULTIPLY(tmp10 + tmp11, FIX(1.001514908));   /* c3 */\n    tmp2 = MULTIPLY(tmp10 + tmp12, FIX(0.881514751));   /* c5 */\n    tmp3 = MULTIPLY(tmp10 + tmp13, FIX(0.710284161)) +  /* c7 */\n\t   MULTIPLY(tmp14 + tmp15, FIX(0.256335874));   /* c11 */\n    tmp0 = tmp1 + tmp2 + tmp3 -\n\t   MULTIPLY(tmp10, FIX(1.530003162)) +          /* c3+c5+c7-c1 */\n\t   MULTIPLY(tmp14, FIX(0.241438564));           /* c9-c11 */\n    tmp4 = MULTIPLY(tmp14 - tmp15, FIX(0.710284161)) -  /* c7 */\n\t   MULTIPLY(tmp11 + tmp12, FIX(0.256335874));   /* c11 */\n    tmp5 = MULTIPLY(tmp11 + tmp13, - FIX(0.881514751)); /* -c5 */\n    tmp1 += tmp4 + tmp5 +\n\t    MULTIPLY(tmp11, FIX(0.634110155)) -         /* c5+c9+c11-c3 */\n\t    MULTIPLY(tmp14, FIX(1.773594819));          /* c1+c7 */\n    tmp6 = MULTIPLY(tmp12 + tmp13, - FIX(0.497774438)); /* -c9 */\n    tmp2 += tmp4 + tmp6 -\n\t    MULTIPLY(tmp12, FIX(1.190715098)) +         /* c1+c5-c9-c11 */\n\t    MULTIPLY(tmp15, FIX(1.711799069));          /* c3+c7 */\n    tmp3 += tmp5 + tmp6 +\n\t    MULTIPLY(tmp13, FIX(1.670519935)) -         /* c3+c5+c9-c7 */\n\t    MULTIPLY(tmp15, FIX(1.319646532));          /* c1+c11 */\n\n    dataptr[DCTSIZE*1] = (DCTELEM) DESCALE(tmp0, CONST_BITS+1);\n    dataptr[DCTSIZE*3] = (DCTELEM) DESCALE(tmp1, CONST_BITS+1);\n    dataptr[DCTSIZE*5] = (DCTELEM) DESCALE(tmp2, CONST_BITS+1);\n    dataptr[DCTSIZE*7] = (DCTELEM) DESCALE(tmp3, CONST_BITS+1);\n\n    dataptr++;\t\t\t/* advance pointer to next column */\n    wsptr++;\t\t\t/* advance pointer to next column */\n  }\n}", "path": "HummusJS/src/deps/LibJpeg/jfdctint.c", "commit_date": "2013-06-10 00:00:00", "repo_name": "galkahana/HummusJS", "stars": 1126, "license": "other", "language": "c", "size": 26954}
{"docstring": "/*\n * Perform the forward DCT on a 14x7 sample block.\n *\n * 14-point FDCT in pass 1 (rows), 7-point in pass 2 (columns).\n */\n", "func_signal": "GLOBAL(void)\njpeg_fdct_14x7 (DCTELEM * data, JSAMPARRAY sample_data, JDIMENSION start_col)", "code": "{\n  INT32 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6;\n  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15, tmp16;\n  INT32 z1, z2, z3;\n  DCTELEM *dataptr;\n  JSAMPROW elemptr;\n  int ctr;\n  SHIFT_TEMPS\n\n  /* Zero bottom row of output coefficient block. */\n  MEMZERO(&data[DCTSIZE*7], SIZEOF(DCTELEM) * DCTSIZE);\n\n  /* Pass 1: process rows. */\n  /* Note results are scaled up by sqrt(8) compared to a true DCT; */\n  /* furthermore, we scale the results by 2**PASS1_BITS. */\n  /* 14-point FDCT kernel, cK represents sqrt(2) * cos(K*pi/28). */\n\n  dataptr = data;\n  for (ctr = 0; ctr < 7; ctr++) {\n    elemptr = sample_data[ctr] + start_col;\n\n    /* Even part */\n\n    tmp0 = GETJSAMPLE(elemptr[0]) + GETJSAMPLE(elemptr[13]);\n    tmp1 = GETJSAMPLE(elemptr[1]) + GETJSAMPLE(elemptr[12]);\n    tmp2 = GETJSAMPLE(elemptr[2]) + GETJSAMPLE(elemptr[11]);\n    tmp13 = GETJSAMPLE(elemptr[3]) + GETJSAMPLE(elemptr[10]);\n    tmp4 = GETJSAMPLE(elemptr[4]) + GETJSAMPLE(elemptr[9]);\n    tmp5 = GETJSAMPLE(elemptr[5]) + GETJSAMPLE(elemptr[8]);\n    tmp6 = GETJSAMPLE(elemptr[6]) + GETJSAMPLE(elemptr[7]);\n\n    tmp10 = tmp0 + tmp6;\n    tmp14 = tmp0 - tmp6;\n    tmp11 = tmp1 + tmp5;\n    tmp15 = tmp1 - tmp5;\n    tmp12 = tmp2 + tmp4;\n    tmp16 = tmp2 - tmp4;\n\n    tmp0 = GETJSAMPLE(elemptr[0]) - GETJSAMPLE(elemptr[13]);\n    tmp1 = GETJSAMPLE(elemptr[1]) - GETJSAMPLE(elemptr[12]);\n    tmp2 = GETJSAMPLE(elemptr[2]) - GETJSAMPLE(elemptr[11]);\n    tmp3 = GETJSAMPLE(elemptr[3]) - GETJSAMPLE(elemptr[10]);\n    tmp4 = GETJSAMPLE(elemptr[4]) - GETJSAMPLE(elemptr[9]);\n    tmp5 = GETJSAMPLE(elemptr[5]) - GETJSAMPLE(elemptr[8]);\n    tmp6 = GETJSAMPLE(elemptr[6]) - GETJSAMPLE(elemptr[7]);\n\n    /* Apply unsigned->signed conversion */\n    dataptr[0] = (DCTELEM)\n      ((tmp10 + tmp11 + tmp12 + tmp13 - 14 * CENTERJSAMPLE) << PASS1_BITS);\n    tmp13 += tmp13;\n    dataptr[4] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp10 - tmp13, FIX(1.274162392)) + /* c4 */\n\t      MULTIPLY(tmp11 - tmp13, FIX(0.314692123)) - /* c12 */\n\t      MULTIPLY(tmp12 - tmp13, FIX(0.881747734)),  /* c8 */\n\t      CONST_BITS-PASS1_BITS);\n\n    tmp10 = MULTIPLY(tmp14 + tmp15, FIX(1.105676686));    /* c6 */\n\n    dataptr[2] = (DCTELEM)\n      DESCALE(tmp10 + MULTIPLY(tmp14, FIX(0.273079590))   /* c2-c6 */\n\t      + MULTIPLY(tmp16, FIX(0.613604268)),        /* c10 */\n\t      CONST_BITS-PASS1_BITS);\n    dataptr[6] = (DCTELEM)\n      DESCALE(tmp10 - MULTIPLY(tmp15, FIX(1.719280954))   /* c6+c10 */\n\t      - MULTIPLY(tmp16, FIX(1.378756276)),        /* c2 */\n\t      CONST_BITS-PASS1_BITS);\n\n    /* Odd part */\n\n    tmp10 = tmp1 + tmp2;\n    tmp11 = tmp5 - tmp4;\n    dataptr[7] = (DCTELEM) ((tmp0 - tmp10 + tmp3 - tmp11 - tmp6) << PASS1_BITS);\n    tmp3 <<= CONST_BITS;\n    tmp10 = MULTIPLY(tmp10, - FIX(0.158341681));          /* -c13 */\n    tmp11 = MULTIPLY(tmp11, FIX(1.405321284));            /* c1 */\n    tmp10 += tmp11 - tmp3;\n    tmp11 = MULTIPLY(tmp0 + tmp2, FIX(1.197448846)) +     /* c5 */\n\t    MULTIPLY(tmp4 + tmp6, FIX(0.752406978));      /* c9 */\n    dataptr[5] = (DCTELEM)\n      DESCALE(tmp10 + tmp11 - MULTIPLY(tmp2, FIX(2.373959773)) /* c3+c5-c13 */\n\t      + MULTIPLY(tmp4, FIX(1.119999435)),         /* c1+c11-c9 */\n\t      CONST_BITS-PASS1_BITS);\n    tmp12 = MULTIPLY(tmp0 + tmp1, FIX(1.334852607)) +     /* c3 */\n\t    MULTIPLY(tmp5 - tmp6, FIX(0.467085129));      /* c11 */\n    dataptr[3] = (DCTELEM)\n      DESCALE(tmp10 + tmp12 - MULTIPLY(tmp1, FIX(0.424103948)) /* c3-c9-c13 */\n\t      - MULTIPLY(tmp5, FIX(3.069855259)),         /* c1+c5+c11 */\n\t      CONST_BITS-PASS1_BITS);\n    dataptr[1] = (DCTELEM)\n      DESCALE(tmp11 + tmp12 + tmp3 + tmp6 -\n\t      MULTIPLY(tmp0 + tmp6, FIX(1.126980169)),    /* c3+c5-c1 */\n\t      CONST_BITS-PASS1_BITS);\n\n    dataptr += DCTSIZE;\t\t/* advance pointer to next row */\n  }\n\n  /* Pass 2: process columns.\n   * We remove the PASS1_BITS scaling, but leave the results scaled up\n   * by an overall factor of 8.\n   * We must also scale the output by (8/14)*(8/7) = 32/49, which we\n   * partially fold into the constant multipliers and final shifting:\n   * 7-point FDCT kernel, cK represents sqrt(2) * cos(K*pi/14) * 64/49.\n   */\n\n  dataptr = data;\n  for (ctr = DCTSIZE-1; ctr >= 0; ctr--) {\n    /* Even part */\n\n    tmp0 = dataptr[DCTSIZE*0] + dataptr[DCTSIZE*6];\n    tmp1 = dataptr[DCTSIZE*1] + dataptr[DCTSIZE*5];\n    tmp2 = dataptr[DCTSIZE*2] + dataptr[DCTSIZE*4];\n    tmp3 = dataptr[DCTSIZE*3];\n\n    tmp10 = dataptr[DCTSIZE*0] - dataptr[DCTSIZE*6];\n    tmp11 = dataptr[DCTSIZE*1] - dataptr[DCTSIZE*5];\n    tmp12 = dataptr[DCTSIZE*2] - dataptr[DCTSIZE*4];\n\n    z1 = tmp0 + tmp2;\n    dataptr[DCTSIZE*0] = (DCTELEM)\n      DESCALE(MULTIPLY(z1 + tmp1 + tmp3, FIX(1.306122449)), /* 64/49 */\n\t      CONST_BITS+PASS1_BITS+1);\n    tmp3 += tmp3;\n    z1 -= tmp3;\n    z1 -= tmp3;\n    z1 = MULTIPLY(z1, FIX(0.461784020));                /* (c2+c6-c4)/2 */\n    z2 = MULTIPLY(tmp0 - tmp2, FIX(1.202428084));       /* (c2+c4-c6)/2 */\n    z3 = MULTIPLY(tmp1 - tmp2, FIX(0.411026446));       /* c6 */\n    dataptr[DCTSIZE*2] = (DCTELEM) DESCALE(z1 + z2 + z3, CONST_BITS+PASS1_BITS+1);\n    z1 -= z2;\n    z2 = MULTIPLY(tmp0 - tmp1, FIX(1.151670509));       /* c4 */\n    dataptr[DCTSIZE*4] = (DCTELEM)\n      DESCALE(z2 + z3 - MULTIPLY(tmp1 - tmp3, FIX(0.923568041)), /* c2+c6-c4 */\n\t      CONST_BITS+PASS1_BITS+1);\n    dataptr[DCTSIZE*6] = (DCTELEM) DESCALE(z1 + z2, CONST_BITS+PASS1_BITS+1);\n\n    /* Odd part */\n\n    tmp1 = MULTIPLY(tmp10 + tmp11, FIX(1.221765677));   /* (c3+c1-c5)/2 */\n    tmp2 = MULTIPLY(tmp10 - tmp11, FIX(0.222383464));   /* (c3+c5-c1)/2 */\n    tmp0 = tmp1 - tmp2;\n    tmp1 += tmp2;\n    tmp2 = MULTIPLY(tmp11 + tmp12, - FIX(1.800824523)); /* -c1 */\n    tmp1 += tmp2;\n    tmp3 = MULTIPLY(tmp10 + tmp12, FIX(0.801442310));   /* c5 */\n    tmp0 += tmp3;\n    tmp2 += tmp3 + MULTIPLY(tmp12, FIX(2.443531355));   /* c3+c1-c5 */\n\n    dataptr[DCTSIZE*1] = (DCTELEM) DESCALE(tmp0, CONST_BITS+PASS1_BITS+1);\n    dataptr[DCTSIZE*3] = (DCTELEM) DESCALE(tmp1, CONST_BITS+PASS1_BITS+1);\n    dataptr[DCTSIZE*5] = (DCTELEM) DESCALE(tmp2, CONST_BITS+PASS1_BITS+1);\n\n    dataptr++;\t\t\t/* advance pointer to next column */\n  }\n}", "path": "HummusJS/src/deps/LibJpeg/jfdctint.c", "commit_date": "2013-06-10 00:00:00", "repo_name": "galkahana/HummusJS", "stars": 1126, "license": "other", "language": "c", "size": 26954}
{"docstring": "/*\n * Perform the forward DCT on a 16x16 sample block.\n */\n", "func_signal": "GLOBAL(void)\njpeg_fdct_16x16 (DCTELEM * data, JSAMPARRAY sample_data, JDIMENSION start_col)", "code": "{\n  INT32 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;\n  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15, tmp16, tmp17;\n  DCTELEM workspace[DCTSIZE2];\n  DCTELEM *dataptr;\n  DCTELEM *wsptr;\n  JSAMPROW elemptr;\n  int ctr;\n  SHIFT_TEMPS\n\n  /* Pass 1: process rows. */\n  /* Note results are scaled up by sqrt(8) compared to a true DCT; */\n  /* furthermore, we scale the results by 2**PASS1_BITS. */\n  /* cK represents sqrt(2) * cos(K*pi/32). */\n\n  dataptr = data;\n  ctr = 0;\n  for (;;) {\n    elemptr = sample_data[ctr] + start_col;\n\n    /* Even part */\n\n    tmp0 = GETJSAMPLE(elemptr[0]) + GETJSAMPLE(elemptr[15]);\n    tmp1 = GETJSAMPLE(elemptr[1]) + GETJSAMPLE(elemptr[14]);\n    tmp2 = GETJSAMPLE(elemptr[2]) + GETJSAMPLE(elemptr[13]);\n    tmp3 = GETJSAMPLE(elemptr[3]) + GETJSAMPLE(elemptr[12]);\n    tmp4 = GETJSAMPLE(elemptr[4]) + GETJSAMPLE(elemptr[11]);\n    tmp5 = GETJSAMPLE(elemptr[5]) + GETJSAMPLE(elemptr[10]);\n    tmp6 = GETJSAMPLE(elemptr[6]) + GETJSAMPLE(elemptr[9]);\n    tmp7 = GETJSAMPLE(elemptr[7]) + GETJSAMPLE(elemptr[8]);\n\n    tmp10 = tmp0 + tmp7;\n    tmp14 = tmp0 - tmp7;\n    tmp11 = tmp1 + tmp6;\n    tmp15 = tmp1 - tmp6;\n    tmp12 = tmp2 + tmp5;\n    tmp16 = tmp2 - tmp5;\n    tmp13 = tmp3 + tmp4;\n    tmp17 = tmp3 - tmp4;\n\n    tmp0 = GETJSAMPLE(elemptr[0]) - GETJSAMPLE(elemptr[15]);\n    tmp1 = GETJSAMPLE(elemptr[1]) - GETJSAMPLE(elemptr[14]);\n    tmp2 = GETJSAMPLE(elemptr[2]) - GETJSAMPLE(elemptr[13]);\n    tmp3 = GETJSAMPLE(elemptr[3]) - GETJSAMPLE(elemptr[12]);\n    tmp4 = GETJSAMPLE(elemptr[4]) - GETJSAMPLE(elemptr[11]);\n    tmp5 = GETJSAMPLE(elemptr[5]) - GETJSAMPLE(elemptr[10]);\n    tmp6 = GETJSAMPLE(elemptr[6]) - GETJSAMPLE(elemptr[9]);\n    tmp7 = GETJSAMPLE(elemptr[7]) - GETJSAMPLE(elemptr[8]);\n\n    /* Apply unsigned->signed conversion */\n    dataptr[0] = (DCTELEM)\n      ((tmp10 + tmp11 + tmp12 + tmp13 - 16 * CENTERJSAMPLE) << PASS1_BITS);\n    dataptr[4] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp10 - tmp13, FIX(1.306562965)) + /* c4[16] = c2[8] */\n\t      MULTIPLY(tmp11 - tmp12, FIX_0_541196100),   /* c12[16] = c6[8] */\n\t      CONST_BITS-PASS1_BITS);\n\n    tmp10 = MULTIPLY(tmp17 - tmp15, FIX(0.275899379)) +   /* c14[16] = c7[8] */\n\t    MULTIPLY(tmp14 - tmp16, FIX(1.387039845));    /* c2[16] = c1[8] */\n\n    dataptr[2] = (DCTELEM)\n      DESCALE(tmp10 + MULTIPLY(tmp15, FIX(1.451774982))   /* c6+c14 */\n\t      + MULTIPLY(tmp16, FIX(2.172734804)),        /* c2+c10 */\n\t      CONST_BITS-PASS1_BITS);\n    dataptr[6] = (DCTELEM)\n      DESCALE(tmp10 - MULTIPLY(tmp14, FIX(0.211164243))   /* c2-c6 */\n\t      - MULTIPLY(tmp17, FIX(1.061594338)),        /* c10+c14 */\n\t      CONST_BITS-PASS1_BITS);\n\n    /* Odd part */\n\n    tmp11 = MULTIPLY(tmp0 + tmp1, FIX(1.353318001)) +         /* c3 */\n\t    MULTIPLY(tmp6 - tmp7, FIX(0.410524528));          /* c13 */\n    tmp12 = MULTIPLY(tmp0 + tmp2, FIX(1.247225013)) +         /* c5 */\n\t    MULTIPLY(tmp5 + tmp7, FIX(0.666655658));          /* c11 */\n    tmp13 = MULTIPLY(tmp0 + tmp3, FIX(1.093201867)) +         /* c7 */\n\t    MULTIPLY(tmp4 - tmp7, FIX(0.897167586));          /* c9 */\n    tmp14 = MULTIPLY(tmp1 + tmp2, FIX(0.138617169)) +         /* c15 */\n\t    MULTIPLY(tmp6 - tmp5, FIX(1.407403738));          /* c1 */\n    tmp15 = MULTIPLY(tmp1 + tmp3, - FIX(0.666655658)) +       /* -c11 */\n\t    MULTIPLY(tmp4 + tmp6, - FIX(1.247225013));        /* -c5 */\n    tmp16 = MULTIPLY(tmp2 + tmp3, - FIX(1.353318001)) +       /* -c3 */\n\t    MULTIPLY(tmp5 - tmp4, FIX(0.410524528));          /* c13 */\n    tmp10 = tmp11 + tmp12 + tmp13 -\n\t    MULTIPLY(tmp0, FIX(2.286341144)) +                /* c7+c5+c3-c1 */\n\t    MULTIPLY(tmp7, FIX(0.779653625));                 /* c15+c13-c11+c9 */\n    tmp11 += tmp14 + tmp15 + MULTIPLY(tmp1, FIX(0.071888074)) /* c9-c3-c15+c11 */\n\t     - MULTIPLY(tmp6, FIX(1.663905119));              /* c7+c13+c1-c5 */\n    tmp12 += tmp14 + tmp16 - MULTIPLY(tmp2, FIX(1.125726048)) /* c7+c5+c15-c3 */\n\t     + MULTIPLY(tmp5, FIX(1.227391138));              /* c9-c11+c1-c13 */\n    tmp13 += tmp15 + tmp16 + MULTIPLY(tmp3, FIX(1.065388962)) /* c15+c3+c11-c7 */\n\t     + MULTIPLY(tmp4, FIX(2.167985692));              /* c1+c13+c5-c9 */\n\n    dataptr[1] = (DCTELEM) DESCALE(tmp10, CONST_BITS-PASS1_BITS);\n    dataptr[3] = (DCTELEM) DESCALE(tmp11, CONST_BITS-PASS1_BITS);\n    dataptr[5] = (DCTELEM) DESCALE(tmp12, CONST_BITS-PASS1_BITS);\n    dataptr[7] = (DCTELEM) DESCALE(tmp13, CONST_BITS-PASS1_BITS);\n\n    ctr++;\n\n    if (ctr != DCTSIZE) {\n      if (ctr == DCTSIZE * 2)\n\tbreak;\t\t\t/* Done. */\n      dataptr += DCTSIZE;\t/* advance pointer to next row */\n    } else\n      dataptr = workspace;\t/* switch pointer to extended workspace */\n  }\n\n  /* Pass 2: process columns.\n   * We remove the PASS1_BITS scaling, but leave the results scaled up\n   * by an overall factor of 8.\n   * We must also scale the output by (8/16)**2 = 1/2**2.\n   */\n\n  dataptr = data;\n  wsptr = workspace;\n  for (ctr = DCTSIZE-1; ctr >= 0; ctr--) {\n    /* Even part */\n\n    tmp0 = dataptr[DCTSIZE*0] + wsptr[DCTSIZE*7];\n    tmp1 = dataptr[DCTSIZE*1] + wsptr[DCTSIZE*6];\n    tmp2 = dataptr[DCTSIZE*2] + wsptr[DCTSIZE*5];\n    tmp3 = dataptr[DCTSIZE*3] + wsptr[DCTSIZE*4];\n    tmp4 = dataptr[DCTSIZE*4] + wsptr[DCTSIZE*3];\n    tmp5 = dataptr[DCTSIZE*5] + wsptr[DCTSIZE*2];\n    tmp6 = dataptr[DCTSIZE*6] + wsptr[DCTSIZE*1];\n    tmp7 = dataptr[DCTSIZE*7] + wsptr[DCTSIZE*0];\n\n    tmp10 = tmp0 + tmp7;\n    tmp14 = tmp0 - tmp7;\n    tmp11 = tmp1 + tmp6;\n    tmp15 = tmp1 - tmp6;\n    tmp12 = tmp2 + tmp5;\n    tmp16 = tmp2 - tmp5;\n    tmp13 = tmp3 + tmp4;\n    tmp17 = tmp3 - tmp4;\n\n    tmp0 = dataptr[DCTSIZE*0] - wsptr[DCTSIZE*7];\n    tmp1 = dataptr[DCTSIZE*1] - wsptr[DCTSIZE*6];\n    tmp2 = dataptr[DCTSIZE*2] - wsptr[DCTSIZE*5];\n    tmp3 = dataptr[DCTSIZE*3] - wsptr[DCTSIZE*4];\n    tmp4 = dataptr[DCTSIZE*4] - wsptr[DCTSIZE*3];\n    tmp5 = dataptr[DCTSIZE*5] - wsptr[DCTSIZE*2];\n    tmp6 = dataptr[DCTSIZE*6] - wsptr[DCTSIZE*1];\n    tmp7 = dataptr[DCTSIZE*7] - wsptr[DCTSIZE*0];\n\n    dataptr[DCTSIZE*0] = (DCTELEM)\n      DESCALE(tmp10 + tmp11 + tmp12 + tmp13, PASS1_BITS+2);\n    dataptr[DCTSIZE*4] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp10 - tmp13, FIX(1.306562965)) + /* c4[16] = c2[8] */\n\t      MULTIPLY(tmp11 - tmp12, FIX_0_541196100),   /* c12[16] = c6[8] */\n\t      CONST_BITS+PASS1_BITS+2);\n\n    tmp10 = MULTIPLY(tmp17 - tmp15, FIX(0.275899379)) +   /* c14[16] = c7[8] */\n\t    MULTIPLY(tmp14 - tmp16, FIX(1.387039845));    /* c2[16] = c1[8] */\n\n    dataptr[DCTSIZE*2] = (DCTELEM)\n      DESCALE(tmp10 + MULTIPLY(tmp15, FIX(1.451774982))   /* c6+c14 */\n\t      + MULTIPLY(tmp16, FIX(2.172734804)),        /* c2+10 */\n\t      CONST_BITS+PASS1_BITS+2);\n    dataptr[DCTSIZE*6] = (DCTELEM)\n      DESCALE(tmp10 - MULTIPLY(tmp14, FIX(0.211164243))   /* c2-c6 */\n\t      - MULTIPLY(tmp17, FIX(1.061594338)),        /* c10+c14 */\n\t      CONST_BITS+PASS1_BITS+2);\n\n    /* Odd part */\n\n    tmp11 = MULTIPLY(tmp0 + tmp1, FIX(1.353318001)) +         /* c3 */\n\t    MULTIPLY(tmp6 - tmp7, FIX(0.410524528));          /* c13 */\n    tmp12 = MULTIPLY(tmp0 + tmp2, FIX(1.247225013)) +         /* c5 */\n\t    MULTIPLY(tmp5 + tmp7, FIX(0.666655658));          /* c11 */\n    tmp13 = MULTIPLY(tmp0 + tmp3, FIX(1.093201867)) +         /* c7 */\n\t    MULTIPLY(tmp4 - tmp7, FIX(0.897167586));          /* c9 */\n    tmp14 = MULTIPLY(tmp1 + tmp2, FIX(0.138617169)) +         /* c15 */\n\t    MULTIPLY(tmp6 - tmp5, FIX(1.407403738));          /* c1 */\n    tmp15 = MULTIPLY(tmp1 + tmp3, - FIX(0.666655658)) +       /* -c11 */\n\t    MULTIPLY(tmp4 + tmp6, - FIX(1.247225013));        /* -c5 */\n    tmp16 = MULTIPLY(tmp2 + tmp3, - FIX(1.353318001)) +       /* -c3 */\n\t    MULTIPLY(tmp5 - tmp4, FIX(0.410524528));          /* c13 */\n    tmp10 = tmp11 + tmp12 + tmp13 -\n\t    MULTIPLY(tmp0, FIX(2.286341144)) +                /* c7+c5+c3-c1 */\n\t    MULTIPLY(tmp7, FIX(0.779653625));                 /* c15+c13-c11+c9 */\n    tmp11 += tmp14 + tmp15 + MULTIPLY(tmp1, FIX(0.071888074)) /* c9-c3-c15+c11 */\n\t     - MULTIPLY(tmp6, FIX(1.663905119));              /* c7+c13+c1-c5 */\n    tmp12 += tmp14 + tmp16 - MULTIPLY(tmp2, FIX(1.125726048)) /* c7+c5+c15-c3 */\n\t     + MULTIPLY(tmp5, FIX(1.227391138));              /* c9-c11+c1-c13 */\n    tmp13 += tmp15 + tmp16 + MULTIPLY(tmp3, FIX(1.065388962)) /* c15+c3+c11-c7 */\n\t     + MULTIPLY(tmp4, FIX(2.167985692));              /* c1+c13+c5-c9 */\n\n    dataptr[DCTSIZE*1] = (DCTELEM) DESCALE(tmp10, CONST_BITS+PASS1_BITS+2);\n    dataptr[DCTSIZE*3] = (DCTELEM) DESCALE(tmp11, CONST_BITS+PASS1_BITS+2);\n    dataptr[DCTSIZE*5] = (DCTELEM) DESCALE(tmp12, CONST_BITS+PASS1_BITS+2);\n    dataptr[DCTSIZE*7] = (DCTELEM) DESCALE(tmp13, CONST_BITS+PASS1_BITS+2);\n\n    dataptr++;\t\t\t/* advance pointer to next column */\n    wsptr++;\t\t\t/* advance pointer to next column */\n  }\n}", "path": "HummusJS/src/deps/LibJpeg/jfdctint.c", "commit_date": "2013-06-10 00:00:00", "repo_name": "galkahana/HummusJS", "stars": 1126, "license": "other", "language": "c", "size": 26954}
{"docstring": "/*\n * Perform the forward DCT on a 1x2 sample block.\n *\n * 1-point FDCT in pass 1 (rows), 2-point in pass 2 (columns).\n */\n", "func_signal": "GLOBAL(void)\njpeg_fdct_1x2 (DCTELEM * data, JSAMPARRAY sample_data, JDIMENSION start_col)", "code": "{\n  INT32 tmp0, tmp1;\n\n  /* Pre-zero output coefficient block. */\n  MEMZERO(data, SIZEOF(DCTELEM) * DCTSIZE2);\n\n  tmp0 = GETJSAMPLE(sample_data[0][start_col]);\n  tmp1 = GETJSAMPLE(sample_data[1][start_col]);\n\n  /* We leave the results scaled up by an overall factor of 8.\n   * We must also scale the output by (8/1)*(8/2) = 2**5.\n   */\n\n  /* Even part */\n  /* Apply unsigned->signed conversion */\n  data[DCTSIZE*0] = (DCTELEM) ((tmp0 + tmp1 - 2 * CENTERJSAMPLE) << 5);\n\n  /* Odd part */\n  data[DCTSIZE*1] = (DCTELEM) ((tmp0 - tmp1) << 5);\n}", "path": "HummusJS/src/deps/LibJpeg/jfdctint.c", "commit_date": "2013-06-10 00:00:00", "repo_name": "galkahana/HummusJS", "stars": 1126, "license": "other", "language": "c", "size": 26954}
{"docstring": "/*\n * Perform the forward DCT on a 2x4 sample block.\n *\n * 2-point FDCT in pass 1 (rows), 4-point in pass 2 (columns).\n */\n", "func_signal": "GLOBAL(void)\njpeg_fdct_2x4 (DCTELEM * data, JSAMPARRAY sample_data, JDIMENSION start_col)", "code": "{\n  INT32 tmp0, tmp1;\n  INT32 tmp10, tmp11;\n  DCTELEM *dataptr;\n  JSAMPROW elemptr;\n  int ctr;\n  SHIFT_TEMPS\n\n  /* Pre-zero output coefficient block. */\n  MEMZERO(data, SIZEOF(DCTELEM) * DCTSIZE2);\n\n  /* Pass 1: process rows. */\n  /* Note results are scaled up by sqrt(8) compared to a true DCT. */\n  /* We must also scale the output by (8/2)*(8/4) = 2**3, which we add here. */\n\n  dataptr = data;\n  for (ctr = 0; ctr < 4; ctr++) {\n    elemptr = sample_data[ctr] + start_col;\n\n    /* Even part */\n\n    tmp0 = GETJSAMPLE(elemptr[0]);\n    tmp1 = GETJSAMPLE(elemptr[1]);\n\n    /* Apply unsigned->signed conversion */\n    dataptr[0] = (DCTELEM) ((tmp0 + tmp1 - 2 * CENTERJSAMPLE) << 3);\n\n    /* Odd part */\n\n    dataptr[1] = (DCTELEM) ((tmp0 - tmp1) << 3);\n\n    dataptr += DCTSIZE;\t\t/* advance pointer to next row */\n  }\n\n  /* Pass 2: process columns.\n   * We leave the results scaled up by an overall factor of 8.\n   * 4-point FDCT kernel,\n   * cK represents sqrt(2) * cos(K*pi/16) [refers to 8-point FDCT].\n   */\n\n  dataptr = data;\n  for (ctr = 0; ctr < 2; ctr++) {\n    /* Even part */\n\n    tmp0 = dataptr[DCTSIZE*0] + dataptr[DCTSIZE*3];\n    tmp1 = dataptr[DCTSIZE*1] + dataptr[DCTSIZE*2];\n\n    tmp10 = dataptr[DCTSIZE*0] - dataptr[DCTSIZE*3];\n    tmp11 = dataptr[DCTSIZE*1] - dataptr[DCTSIZE*2];\n\n    dataptr[DCTSIZE*0] = (DCTELEM) (tmp0 + tmp1);\n    dataptr[DCTSIZE*2] = (DCTELEM) (tmp0 - tmp1);\n\n    /* Odd part */\n\n    tmp0 = MULTIPLY(tmp10 + tmp11, FIX_0_541196100);       /* c6 */\n    /* Add fudge factor here for final descale. */\n    tmp0 += ONE << (CONST_BITS-1);\n\n    dataptr[DCTSIZE*1] = (DCTELEM)\n      RIGHT_SHIFT(tmp0 + MULTIPLY(tmp10, FIX_0_765366865), /* c2-c6 */\n\t\t  CONST_BITS);\n    dataptr[DCTSIZE*3] = (DCTELEM)\n      RIGHT_SHIFT(tmp0 - MULTIPLY(tmp11, FIX_1_847759065), /* c2+c6 */\n\t\t  CONST_BITS);\n\n    dataptr++;\t\t\t/* advance pointer to next column */\n  }\n}", "path": "HummusJS/src/deps/LibJpeg/jfdctint.c", "commit_date": "2013-06-10 00:00:00", "repo_name": "galkahana/HummusJS", "stars": 1126, "license": "other", "language": "c", "size": 26954}
{"docstring": "/*\n * Perform the forward DCT on a 12x12 sample block.\n */\n", "func_signal": "GLOBAL(void)\njpeg_fdct_12x12 (DCTELEM * data, JSAMPARRAY sample_data, JDIMENSION start_col)", "code": "{\n  INT32 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5;\n  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15;\n  DCTELEM workspace[8*4];\n  DCTELEM *dataptr;\n  DCTELEM *wsptr;\n  JSAMPROW elemptr;\n  int ctr;\n  SHIFT_TEMPS\n\n  /* Pass 1: process rows. */\n  /* Note results are scaled up by sqrt(8) compared to a true DCT. */\n  /* cK represents sqrt(2) * cos(K*pi/24). */\n\n  dataptr = data;\n  ctr = 0;\n  for (;;) {\n    elemptr = sample_data[ctr] + start_col;\n\n    /* Even part */\n\n    tmp0 = GETJSAMPLE(elemptr[0]) + GETJSAMPLE(elemptr[11]);\n    tmp1 = GETJSAMPLE(elemptr[1]) + GETJSAMPLE(elemptr[10]);\n    tmp2 = GETJSAMPLE(elemptr[2]) + GETJSAMPLE(elemptr[9]);\n    tmp3 = GETJSAMPLE(elemptr[3]) + GETJSAMPLE(elemptr[8]);\n    tmp4 = GETJSAMPLE(elemptr[4]) + GETJSAMPLE(elemptr[7]);\n    tmp5 = GETJSAMPLE(elemptr[5]) + GETJSAMPLE(elemptr[6]);\n\n    tmp10 = tmp0 + tmp5;\n    tmp13 = tmp0 - tmp5;\n    tmp11 = tmp1 + tmp4;\n    tmp14 = tmp1 - tmp4;\n    tmp12 = tmp2 + tmp3;\n    tmp15 = tmp2 - tmp3;\n\n    tmp0 = GETJSAMPLE(elemptr[0]) - GETJSAMPLE(elemptr[11]);\n    tmp1 = GETJSAMPLE(elemptr[1]) - GETJSAMPLE(elemptr[10]);\n    tmp2 = GETJSAMPLE(elemptr[2]) - GETJSAMPLE(elemptr[9]);\n    tmp3 = GETJSAMPLE(elemptr[3]) - GETJSAMPLE(elemptr[8]);\n    tmp4 = GETJSAMPLE(elemptr[4]) - GETJSAMPLE(elemptr[7]);\n    tmp5 = GETJSAMPLE(elemptr[5]) - GETJSAMPLE(elemptr[6]);\n\n    /* Apply unsigned->signed conversion */\n    dataptr[0] = (DCTELEM) (tmp10 + tmp11 + tmp12 - 12 * CENTERJSAMPLE);\n    dataptr[6] = (DCTELEM) (tmp13 - tmp14 - tmp15);\n    dataptr[4] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp10 - tmp12, FIX(1.224744871)), /* c4 */\n\t      CONST_BITS);\n    dataptr[2] = (DCTELEM)\n      DESCALE(tmp14 - tmp15 + MULTIPLY(tmp13 + tmp15, FIX(1.366025404)), /* c2 */\n\t      CONST_BITS);\n\n    /* Odd part */\n\n    tmp10 = MULTIPLY(tmp1 + tmp4, FIX_0_541196100);    /* c9 */\n    tmp14 = tmp10 + MULTIPLY(tmp1, FIX_0_765366865);   /* c3-c9 */\n    tmp15 = tmp10 - MULTIPLY(tmp4, FIX_1_847759065);   /* c3+c9 */\n    tmp12 = MULTIPLY(tmp0 + tmp2, FIX(1.121971054));   /* c5 */\n    tmp13 = MULTIPLY(tmp0 + tmp3, FIX(0.860918669));   /* c7 */\n    tmp10 = tmp12 + tmp13 + tmp14 - MULTIPLY(tmp0, FIX(0.580774953)) /* c5+c7-c1 */\n\t    + MULTIPLY(tmp5, FIX(0.184591911));        /* c11 */\n    tmp11 = MULTIPLY(tmp2 + tmp3, - FIX(0.184591911)); /* -c11 */\n    tmp12 += tmp11 - tmp15 - MULTIPLY(tmp2, FIX(2.339493912)) /* c1+c5-c11 */\n\t    + MULTIPLY(tmp5, FIX(0.860918669));        /* c7 */\n    tmp13 += tmp11 - tmp14 + MULTIPLY(tmp3, FIX(0.725788011)) /* c1+c11-c7 */\n\t    - MULTIPLY(tmp5, FIX(1.121971054));        /* c5 */\n    tmp11 = tmp15 + MULTIPLY(tmp0 - tmp3, FIX(1.306562965)) /* c3 */\n\t    - MULTIPLY(tmp2 + tmp5, FIX_0_541196100);  /* c9 */\n\n    dataptr[1] = (DCTELEM) DESCALE(tmp10, CONST_BITS);\n    dataptr[3] = (DCTELEM) DESCALE(tmp11, CONST_BITS);\n    dataptr[5] = (DCTELEM) DESCALE(tmp12, CONST_BITS);\n    dataptr[7] = (DCTELEM) DESCALE(tmp13, CONST_BITS);\n\n    ctr++;\n\n    if (ctr != DCTSIZE) {\n      if (ctr == 12)\n\tbreak;\t\t\t/* Done. */\n      dataptr += DCTSIZE;\t/* advance pointer to next row */\n    } else\n      dataptr = workspace;\t/* switch pointer to extended workspace */\n  }\n\n  /* Pass 2: process columns.\n   * We leave the results scaled up by an overall factor of 8.\n   * We must also scale the output by (8/12)**2 = 4/9, which we partially\n   * fold into the constant multipliers and final shifting:\n   * cK now represents sqrt(2) * cos(K*pi/24) * 8/9.\n   */\n\n  dataptr = data;\n  wsptr = workspace;\n  for (ctr = DCTSIZE-1; ctr >= 0; ctr--) {\n    /* Even part */\n\n    tmp0 = dataptr[DCTSIZE*0] + wsptr[DCTSIZE*3];\n    tmp1 = dataptr[DCTSIZE*1] + wsptr[DCTSIZE*2];\n    tmp2 = dataptr[DCTSIZE*2] + wsptr[DCTSIZE*1];\n    tmp3 = dataptr[DCTSIZE*3] + wsptr[DCTSIZE*0];\n    tmp4 = dataptr[DCTSIZE*4] + dataptr[DCTSIZE*7];\n    tmp5 = dataptr[DCTSIZE*5] + dataptr[DCTSIZE*6];\n\n    tmp10 = tmp0 + tmp5;\n    tmp13 = tmp0 - tmp5;\n    tmp11 = tmp1 + tmp4;\n    tmp14 = tmp1 - tmp4;\n    tmp12 = tmp2 + tmp3;\n    tmp15 = tmp2 - tmp3;\n\n    tmp0 = dataptr[DCTSIZE*0] - wsptr[DCTSIZE*3];\n    tmp1 = dataptr[DCTSIZE*1] - wsptr[DCTSIZE*2];\n    tmp2 = dataptr[DCTSIZE*2] - wsptr[DCTSIZE*1];\n    tmp3 = dataptr[DCTSIZE*3] - wsptr[DCTSIZE*0];\n    tmp4 = dataptr[DCTSIZE*4] - dataptr[DCTSIZE*7];\n    tmp5 = dataptr[DCTSIZE*5] - dataptr[DCTSIZE*6];\n\n    dataptr[DCTSIZE*0] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp10 + tmp11 + tmp12, FIX(0.888888889)), /* 8/9 */\n\t      CONST_BITS+1);\n    dataptr[DCTSIZE*6] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp13 - tmp14 - tmp15, FIX(0.888888889)), /* 8/9 */\n\t      CONST_BITS+1);\n    dataptr[DCTSIZE*4] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp10 - tmp12, FIX(1.088662108)),         /* c4 */\n\t      CONST_BITS+1);\n    dataptr[DCTSIZE*2] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp14 - tmp15, FIX(0.888888889)) +        /* 8/9 */\n\t      MULTIPLY(tmp13 + tmp15, FIX(1.214244803)),         /* c2 */\n\t      CONST_BITS+1);\n\n    /* Odd part */\n\n    tmp10 = MULTIPLY(tmp1 + tmp4, FIX(0.481063200));   /* c9 */\n    tmp14 = tmp10 + MULTIPLY(tmp1, FIX(0.680326102));  /* c3-c9 */\n    tmp15 = tmp10 - MULTIPLY(tmp4, FIX(1.642452502));  /* c3+c9 */\n    tmp12 = MULTIPLY(tmp0 + tmp2, FIX(0.997307603));   /* c5 */\n    tmp13 = MULTIPLY(tmp0 + tmp3, FIX(0.765261039));   /* c7 */\n    tmp10 = tmp12 + tmp13 + tmp14 - MULTIPLY(tmp0, FIX(0.516244403)) /* c5+c7-c1 */\n\t    + MULTIPLY(tmp5, FIX(0.164081699));        /* c11 */\n    tmp11 = MULTIPLY(tmp2 + tmp3, - FIX(0.164081699)); /* -c11 */\n    tmp12 += tmp11 - tmp15 - MULTIPLY(tmp2, FIX(2.079550144)) /* c1+c5-c11 */\n\t    + MULTIPLY(tmp5, FIX(0.765261039));        /* c7 */\n    tmp13 += tmp11 - tmp14 + MULTIPLY(tmp3, FIX(0.645144899)) /* c1+c11-c7 */\n\t    - MULTIPLY(tmp5, FIX(0.997307603));        /* c5 */\n    tmp11 = tmp15 + MULTIPLY(tmp0 - tmp3, FIX(1.161389302)) /* c3 */\n\t    - MULTIPLY(tmp2 + tmp5, FIX(0.481063200)); /* c9 */\n\n    dataptr[DCTSIZE*1] = (DCTELEM) DESCALE(tmp10, CONST_BITS+1);\n    dataptr[DCTSIZE*3] = (DCTELEM) DESCALE(tmp11, CONST_BITS+1);\n    dataptr[DCTSIZE*5] = (DCTELEM) DESCALE(tmp12, CONST_BITS+1);\n    dataptr[DCTSIZE*7] = (DCTELEM) DESCALE(tmp13, CONST_BITS+1);\n\n    dataptr++;\t\t\t/* advance pointer to next column */\n    wsptr++;\t\t\t/* advance pointer to next column */\n  }\n}", "path": "HummusJS/src/deps/LibJpeg/jfdctint.c", "commit_date": "2013-06-10 00:00:00", "repo_name": "galkahana/HummusJS", "stars": 1126, "license": "other", "language": "c", "size": 26954}
{"docstring": "/*\n * Perform the forward DCT on a 10x10 sample block.\n */\n", "func_signal": "GLOBAL(void)\njpeg_fdct_10x10 (DCTELEM * data, JSAMPARRAY sample_data, JDIMENSION start_col)", "code": "{\n  INT32 tmp0, tmp1, tmp2, tmp3, tmp4;\n  INT32 tmp10, tmp11, tmp12, tmp13, tmp14;\n  DCTELEM workspace[8*2];\n  DCTELEM *dataptr;\n  DCTELEM *wsptr;\n  JSAMPROW elemptr;\n  int ctr;\n  SHIFT_TEMPS\n\n  /* Pass 1: process rows. */\n  /* Note results are scaled up by sqrt(8) compared to a true DCT; */\n  /* we scale the results further by 2 as part of output adaption */\n  /* scaling for different DCT size. */\n  /* cK represents sqrt(2) * cos(K*pi/20). */\n\n  dataptr = data;\n  ctr = 0;\n  for (;;) {\n    elemptr = sample_data[ctr] + start_col;\n\n    /* Even part */\n\n    tmp0 = GETJSAMPLE(elemptr[0]) + GETJSAMPLE(elemptr[9]);\n    tmp1 = GETJSAMPLE(elemptr[1]) + GETJSAMPLE(elemptr[8]);\n    tmp12 = GETJSAMPLE(elemptr[2]) + GETJSAMPLE(elemptr[7]);\n    tmp3 = GETJSAMPLE(elemptr[3]) + GETJSAMPLE(elemptr[6]);\n    tmp4 = GETJSAMPLE(elemptr[4]) + GETJSAMPLE(elemptr[5]);\n\n    tmp10 = tmp0 + tmp4;\n    tmp13 = tmp0 - tmp4;\n    tmp11 = tmp1 + tmp3;\n    tmp14 = tmp1 - tmp3;\n\n    tmp0 = GETJSAMPLE(elemptr[0]) - GETJSAMPLE(elemptr[9]);\n    tmp1 = GETJSAMPLE(elemptr[1]) - GETJSAMPLE(elemptr[8]);\n    tmp2 = GETJSAMPLE(elemptr[2]) - GETJSAMPLE(elemptr[7]);\n    tmp3 = GETJSAMPLE(elemptr[3]) - GETJSAMPLE(elemptr[6]);\n    tmp4 = GETJSAMPLE(elemptr[4]) - GETJSAMPLE(elemptr[5]);\n\n    /* Apply unsigned->signed conversion */\n    dataptr[0] = (DCTELEM)\n      ((tmp10 + tmp11 + tmp12 - 10 * CENTERJSAMPLE) << 1);\n    tmp12 += tmp12;\n    dataptr[4] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp10 - tmp12, FIX(1.144122806)) - /* c4 */\n\t      MULTIPLY(tmp11 - tmp12, FIX(0.437016024)),  /* c8 */\n\t      CONST_BITS-1);\n    tmp10 = MULTIPLY(tmp13 + tmp14, FIX(0.831253876));    /* c6 */\n    dataptr[2] = (DCTELEM)\n      DESCALE(tmp10 + MULTIPLY(tmp13, FIX(0.513743148)),  /* c2-c6 */\n\t      CONST_BITS-1);\n    dataptr[6] = (DCTELEM)\n      DESCALE(tmp10 - MULTIPLY(tmp14, FIX(2.176250899)),  /* c2+c6 */\n\t      CONST_BITS-1);\n\n    /* Odd part */\n\n    tmp10 = tmp0 + tmp4;\n    tmp11 = tmp1 - tmp3;\n    dataptr[5] = (DCTELEM) ((tmp10 - tmp11 - tmp2) << 1);\n    tmp2 <<= CONST_BITS;\n    dataptr[1] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp0, FIX(1.396802247)) +          /* c1 */\n\t      MULTIPLY(tmp1, FIX(1.260073511)) + tmp2 +   /* c3 */\n\t      MULTIPLY(tmp3, FIX(0.642039522)) +          /* c7 */\n\t      MULTIPLY(tmp4, FIX(0.221231742)),           /* c9 */\n\t      CONST_BITS-1);\n    tmp12 = MULTIPLY(tmp0 - tmp4, FIX(0.951056516)) -     /* (c3+c7)/2 */\n\t    MULTIPLY(tmp1 + tmp3, FIX(0.587785252));      /* (c1-c9)/2 */\n    tmp13 = MULTIPLY(tmp10 + tmp11, FIX(0.309016994)) +   /* (c3-c7)/2 */\n\t    (tmp11 << (CONST_BITS - 1)) - tmp2;\n    dataptr[3] = (DCTELEM) DESCALE(tmp12 + tmp13, CONST_BITS-1);\n    dataptr[7] = (DCTELEM) DESCALE(tmp12 - tmp13, CONST_BITS-1);\n\n    ctr++;\n\n    if (ctr != DCTSIZE) {\n      if (ctr == 10)\n\tbreak;\t\t\t/* Done. */\n      dataptr += DCTSIZE;\t/* advance pointer to next row */\n    } else\n      dataptr = workspace;\t/* switch pointer to extended workspace */\n  }\n\n  /* Pass 2: process columns.\n   * We leave the results scaled up by an overall factor of 8.\n   * We must also scale the output by (8/10)**2 = 16/25, which we partially\n   * fold into the constant multipliers and final/initial shifting:\n   * cK now represents sqrt(2) * cos(K*pi/20) * 32/25.\n   */\n\n  dataptr = data;\n  wsptr = workspace;\n  for (ctr = DCTSIZE-1; ctr >= 0; ctr--) {\n    /* Even part */\n\n    tmp0 = dataptr[DCTSIZE*0] + wsptr[DCTSIZE*1];\n    tmp1 = dataptr[DCTSIZE*1] + wsptr[DCTSIZE*0];\n    tmp12 = dataptr[DCTSIZE*2] + dataptr[DCTSIZE*7];\n    tmp3 = dataptr[DCTSIZE*3] + dataptr[DCTSIZE*6];\n    tmp4 = dataptr[DCTSIZE*4] + dataptr[DCTSIZE*5];\n\n    tmp10 = tmp0 + tmp4;\n    tmp13 = tmp0 - tmp4;\n    tmp11 = tmp1 + tmp3;\n    tmp14 = tmp1 - tmp3;\n\n    tmp0 = dataptr[DCTSIZE*0] - wsptr[DCTSIZE*1];\n    tmp1 = dataptr[DCTSIZE*1] - wsptr[DCTSIZE*0];\n    tmp2 = dataptr[DCTSIZE*2] - dataptr[DCTSIZE*7];\n    tmp3 = dataptr[DCTSIZE*3] - dataptr[DCTSIZE*6];\n    tmp4 = dataptr[DCTSIZE*4] - dataptr[DCTSIZE*5];\n\n    dataptr[DCTSIZE*0] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp10 + tmp11 + tmp12, FIX(1.28)), /* 32/25 */\n\t      CONST_BITS+2);\n    tmp12 += tmp12;\n    dataptr[DCTSIZE*4] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp10 - tmp12, FIX(1.464477191)) - /* c4 */\n\t      MULTIPLY(tmp11 - tmp12, FIX(0.559380511)),  /* c8 */\n\t      CONST_BITS+2);\n    tmp10 = MULTIPLY(tmp13 + tmp14, FIX(1.064004961));    /* c6 */\n    dataptr[DCTSIZE*2] = (DCTELEM)\n      DESCALE(tmp10 + MULTIPLY(tmp13, FIX(0.657591230)),  /* c2-c6 */\n\t      CONST_BITS+2);\n    dataptr[DCTSIZE*6] = (DCTELEM)\n      DESCALE(tmp10 - MULTIPLY(tmp14, FIX(2.785601151)),  /* c2+c6 */\n\t      CONST_BITS+2);\n\n    /* Odd part */\n\n    tmp10 = tmp0 + tmp4;\n    tmp11 = tmp1 - tmp3;\n    dataptr[DCTSIZE*5] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp10 - tmp11 - tmp2, FIX(1.28)),  /* 32/25 */\n\t      CONST_BITS+2);\n    tmp2 = MULTIPLY(tmp2, FIX(1.28));                     /* 32/25 */\n    dataptr[DCTSIZE*1] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp0, FIX(1.787906876)) +          /* c1 */\n\t      MULTIPLY(tmp1, FIX(1.612894094)) + tmp2 +   /* c3 */\n\t      MULTIPLY(tmp3, FIX(0.821810588)) +          /* c7 */\n\t      MULTIPLY(tmp4, FIX(0.283176630)),           /* c9 */\n\t      CONST_BITS+2);\n    tmp12 = MULTIPLY(tmp0 - tmp4, FIX(1.217352341)) -     /* (c3+c7)/2 */\n\t    MULTIPLY(tmp1 + tmp3, FIX(0.752365123));      /* (c1-c9)/2 */\n    tmp13 = MULTIPLY(tmp10 + tmp11, FIX(0.395541753)) +   /* (c3-c7)/2 */\n\t    MULTIPLY(tmp11, FIX(0.64)) - tmp2;            /* 16/25 */\n    dataptr[DCTSIZE*3] = (DCTELEM) DESCALE(tmp12 + tmp13, CONST_BITS+2);\n    dataptr[DCTSIZE*7] = (DCTELEM) DESCALE(tmp12 - tmp13, CONST_BITS+2);\n\n    dataptr++;\t\t\t/* advance pointer to next column */\n    wsptr++;\t\t\t/* advance pointer to next column */\n  }\n}", "path": "HummusJS/src/deps/LibJpeg/jfdctint.c", "commit_date": "2013-06-10 00:00:00", "repo_name": "galkahana/HummusJS", "stars": 1126, "license": "other", "language": "c", "size": 26954}
{"docstring": "/*\n * Perform the forward DCT on a 12x6 sample block.\n *\n * 12-point FDCT in pass 1 (rows), 6-point in pass 2 (columns).\n */\n", "func_signal": "GLOBAL(void)\njpeg_fdct_12x6 (DCTELEM * data, JSAMPARRAY sample_data, JDIMENSION start_col)", "code": "{\n  INT32 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5;\n  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15;\n  DCTELEM *dataptr;\n  JSAMPROW elemptr;\n  int ctr;\n  SHIFT_TEMPS\n\n  /* Zero 2 bottom rows of output coefficient block. */\n  MEMZERO(&data[DCTSIZE*6], SIZEOF(DCTELEM) * DCTSIZE * 2);\n\n  /* Pass 1: process rows. */\n  /* Note results are scaled up by sqrt(8) compared to a true DCT; */\n  /* furthermore, we scale the results by 2**PASS1_BITS. */\n  /* 12-point FDCT kernel, cK represents sqrt(2) * cos(K*pi/24). */\n\n  dataptr = data;\n  for (ctr = 0; ctr < 6; ctr++) {\n    elemptr = sample_data[ctr] + start_col;\n\n    /* Even part */\n\n    tmp0 = GETJSAMPLE(elemptr[0]) + GETJSAMPLE(elemptr[11]);\n    tmp1 = GETJSAMPLE(elemptr[1]) + GETJSAMPLE(elemptr[10]);\n    tmp2 = GETJSAMPLE(elemptr[2]) + GETJSAMPLE(elemptr[9]);\n    tmp3 = GETJSAMPLE(elemptr[3]) + GETJSAMPLE(elemptr[8]);\n    tmp4 = GETJSAMPLE(elemptr[4]) + GETJSAMPLE(elemptr[7]);\n    tmp5 = GETJSAMPLE(elemptr[5]) + GETJSAMPLE(elemptr[6]);\n\n    tmp10 = tmp0 + tmp5;\n    tmp13 = tmp0 - tmp5;\n    tmp11 = tmp1 + tmp4;\n    tmp14 = tmp1 - tmp4;\n    tmp12 = tmp2 + tmp3;\n    tmp15 = tmp2 - tmp3;\n\n    tmp0 = GETJSAMPLE(elemptr[0]) - GETJSAMPLE(elemptr[11]);\n    tmp1 = GETJSAMPLE(elemptr[1]) - GETJSAMPLE(elemptr[10]);\n    tmp2 = GETJSAMPLE(elemptr[2]) - GETJSAMPLE(elemptr[9]);\n    tmp3 = GETJSAMPLE(elemptr[3]) - GETJSAMPLE(elemptr[8]);\n    tmp4 = GETJSAMPLE(elemptr[4]) - GETJSAMPLE(elemptr[7]);\n    tmp5 = GETJSAMPLE(elemptr[5]) - GETJSAMPLE(elemptr[6]);\n\n    /* Apply unsigned->signed conversion */\n    dataptr[0] = (DCTELEM)\n      ((tmp10 + tmp11 + tmp12 - 12 * CENTERJSAMPLE) << PASS1_BITS);\n    dataptr[6] = (DCTELEM) ((tmp13 - tmp14 - tmp15) << PASS1_BITS);\n    dataptr[4] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp10 - tmp12, FIX(1.224744871)), /* c4 */\n\t      CONST_BITS-PASS1_BITS);\n    dataptr[2] = (DCTELEM)\n      DESCALE(tmp14 - tmp15 + MULTIPLY(tmp13 + tmp15, FIX(1.366025404)), /* c2 */\n\t      CONST_BITS-PASS1_BITS);\n\n    /* Odd part */\n\n    tmp10 = MULTIPLY(tmp1 + tmp4, FIX_0_541196100);    /* c9 */\n    tmp14 = tmp10 + MULTIPLY(tmp1, FIX_0_765366865);   /* c3-c9 */\n    tmp15 = tmp10 - MULTIPLY(tmp4, FIX_1_847759065);   /* c3+c9 */\n    tmp12 = MULTIPLY(tmp0 + tmp2, FIX(1.121971054));   /* c5 */\n    tmp13 = MULTIPLY(tmp0 + tmp3, FIX(0.860918669));   /* c7 */\n    tmp10 = tmp12 + tmp13 + tmp14 - MULTIPLY(tmp0, FIX(0.580774953)) /* c5+c7-c1 */\n\t    + MULTIPLY(tmp5, FIX(0.184591911));        /* c11 */\n    tmp11 = MULTIPLY(tmp2 + tmp3, - FIX(0.184591911)); /* -c11 */\n    tmp12 += tmp11 - tmp15 - MULTIPLY(tmp2, FIX(2.339493912)) /* c1+c5-c11 */\n\t    + MULTIPLY(tmp5, FIX(0.860918669));        /* c7 */\n    tmp13 += tmp11 - tmp14 + MULTIPLY(tmp3, FIX(0.725788011)) /* c1+c11-c7 */\n\t    - MULTIPLY(tmp5, FIX(1.121971054));        /* c5 */\n    tmp11 = tmp15 + MULTIPLY(tmp0 - tmp3, FIX(1.306562965)) /* c3 */\n\t    - MULTIPLY(tmp2 + tmp5, FIX_0_541196100);  /* c9 */\n\n    dataptr[1] = (DCTELEM) DESCALE(tmp10, CONST_BITS-PASS1_BITS);\n    dataptr[3] = (DCTELEM) DESCALE(tmp11, CONST_BITS-PASS1_BITS);\n    dataptr[5] = (DCTELEM) DESCALE(tmp12, CONST_BITS-PASS1_BITS);\n    dataptr[7] = (DCTELEM) DESCALE(tmp13, CONST_BITS-PASS1_BITS);\n\n    dataptr += DCTSIZE;\t\t/* advance pointer to next row */\n  }\n\n  /* Pass 2: process columns.\n   * We remove the PASS1_BITS scaling, but leave the results scaled up\n   * by an overall factor of 8.\n   * We must also scale the output by (8/12)*(8/6) = 8/9, which we\n   * partially fold into the constant multipliers and final shifting:\n   * 6-point FDCT kernel, cK represents sqrt(2) * cos(K*pi/12) * 16/9.\n   */\n\n  dataptr = data;\n  for (ctr = DCTSIZE-1; ctr >= 0; ctr--) {\n    /* Even part */\n\n    tmp0 = dataptr[DCTSIZE*0] + dataptr[DCTSIZE*5];\n    tmp11 = dataptr[DCTSIZE*1] + dataptr[DCTSIZE*4];\n    tmp2 = dataptr[DCTSIZE*2] + dataptr[DCTSIZE*3];\n\n    tmp10 = tmp0 + tmp2;\n    tmp12 = tmp0 - tmp2;\n\n    tmp0 = dataptr[DCTSIZE*0] - dataptr[DCTSIZE*5];\n    tmp1 = dataptr[DCTSIZE*1] - dataptr[DCTSIZE*4];\n    tmp2 = dataptr[DCTSIZE*2] - dataptr[DCTSIZE*3];\n\n    dataptr[DCTSIZE*0] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp10 + tmp11, FIX(1.777777778)),         /* 16/9 */\n\t      CONST_BITS+PASS1_BITS+1);\n    dataptr[DCTSIZE*2] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp12, FIX(2.177324216)),                 /* c2 */\n\t      CONST_BITS+PASS1_BITS+1);\n    dataptr[DCTSIZE*4] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp10 - tmp11 - tmp11, FIX(1.257078722)), /* c4 */\n\t      CONST_BITS+PASS1_BITS+1);\n\n    /* Odd part */\n\n    tmp10 = MULTIPLY(tmp0 + tmp2, FIX(0.650711829));             /* c5 */\n\n    dataptr[DCTSIZE*1] = (DCTELEM)\n      DESCALE(tmp10 + MULTIPLY(tmp0 + tmp1, FIX(1.777777778)),   /* 16/9 */\n\t      CONST_BITS+PASS1_BITS+1);\n    dataptr[DCTSIZE*3] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp0 - tmp1 - tmp2, FIX(1.777777778)),    /* 16/9 */\n\t      CONST_BITS+PASS1_BITS+1);\n    dataptr[DCTSIZE*5] = (DCTELEM)\n      DESCALE(tmp10 + MULTIPLY(tmp2 - tmp1, FIX(1.777777778)),   /* 16/9 */\n\t      CONST_BITS+PASS1_BITS+1);\n\n    dataptr++;\t\t\t/* advance pointer to next column */\n  }\n}", "path": "HummusJS/src/deps/LibJpeg/jfdctint.c", "commit_date": "2013-06-10 00:00:00", "repo_name": "galkahana/HummusJS", "stars": 1126, "license": "other", "language": "c", "size": 26954}
{"docstring": "/*\n * Perform the forward DCT on a 10x5 sample block.\n *\n * 10-point FDCT in pass 1 (rows), 5-point in pass 2 (columns).\n */\n", "func_signal": "GLOBAL(void)\njpeg_fdct_10x5 (DCTELEM * data, JSAMPARRAY sample_data, JDIMENSION start_col)", "code": "{\n  INT32 tmp0, tmp1, tmp2, tmp3, tmp4;\n  INT32 tmp10, tmp11, tmp12, tmp13, tmp14;\n  DCTELEM *dataptr;\n  JSAMPROW elemptr;\n  int ctr;\n  SHIFT_TEMPS\n\n  /* Zero 3 bottom rows of output coefficient block. */\n  MEMZERO(&data[DCTSIZE*5], SIZEOF(DCTELEM) * DCTSIZE * 3);\n\n  /* Pass 1: process rows. */\n  /* Note results are scaled up by sqrt(8) compared to a true DCT; */\n  /* furthermore, we scale the results by 2**PASS1_BITS. */\n  /* 10-point FDCT kernel, cK represents sqrt(2) * cos(K*pi/20). */\n\n  dataptr = data;\n  for (ctr = 0; ctr < 5; ctr++) {\n    elemptr = sample_data[ctr] + start_col;\n\n    /* Even part */\n\n    tmp0 = GETJSAMPLE(elemptr[0]) + GETJSAMPLE(elemptr[9]);\n    tmp1 = GETJSAMPLE(elemptr[1]) + GETJSAMPLE(elemptr[8]);\n    tmp12 = GETJSAMPLE(elemptr[2]) + GETJSAMPLE(elemptr[7]);\n    tmp3 = GETJSAMPLE(elemptr[3]) + GETJSAMPLE(elemptr[6]);\n    tmp4 = GETJSAMPLE(elemptr[4]) + GETJSAMPLE(elemptr[5]);\n\n    tmp10 = tmp0 + tmp4;\n    tmp13 = tmp0 - tmp4;\n    tmp11 = tmp1 + tmp3;\n    tmp14 = tmp1 - tmp3;\n\n    tmp0 = GETJSAMPLE(elemptr[0]) - GETJSAMPLE(elemptr[9]);\n    tmp1 = GETJSAMPLE(elemptr[1]) - GETJSAMPLE(elemptr[8]);\n    tmp2 = GETJSAMPLE(elemptr[2]) - GETJSAMPLE(elemptr[7]);\n    tmp3 = GETJSAMPLE(elemptr[3]) - GETJSAMPLE(elemptr[6]);\n    tmp4 = GETJSAMPLE(elemptr[4]) - GETJSAMPLE(elemptr[5]);\n\n    /* Apply unsigned->signed conversion */\n    dataptr[0] = (DCTELEM)\n      ((tmp10 + tmp11 + tmp12 - 10 * CENTERJSAMPLE) << PASS1_BITS);\n    tmp12 += tmp12;\n    dataptr[4] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp10 - tmp12, FIX(1.144122806)) - /* c4 */\n\t      MULTIPLY(tmp11 - tmp12, FIX(0.437016024)),  /* c8 */\n\t      CONST_BITS-PASS1_BITS);\n    tmp10 = MULTIPLY(tmp13 + tmp14, FIX(0.831253876));    /* c6 */\n    dataptr[2] = (DCTELEM)\n      DESCALE(tmp10 + MULTIPLY(tmp13, FIX(0.513743148)),  /* c2-c6 */\n\t      CONST_BITS-PASS1_BITS);\n    dataptr[6] = (DCTELEM)\n      DESCALE(tmp10 - MULTIPLY(tmp14, FIX(2.176250899)),  /* c2+c6 */\n\t      CONST_BITS-PASS1_BITS);\n\n    /* Odd part */\n\n    tmp10 = tmp0 + tmp4;\n    tmp11 = tmp1 - tmp3;\n    dataptr[5] = (DCTELEM) ((tmp10 - tmp11 - tmp2) << PASS1_BITS);\n    tmp2 <<= CONST_BITS;\n    dataptr[1] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp0, FIX(1.396802247)) +          /* c1 */\n\t      MULTIPLY(tmp1, FIX(1.260073511)) + tmp2 +   /* c3 */\n\t      MULTIPLY(tmp3, FIX(0.642039522)) +          /* c7 */\n\t      MULTIPLY(tmp4, FIX(0.221231742)),           /* c9 */\n\t      CONST_BITS-PASS1_BITS);\n    tmp12 = MULTIPLY(tmp0 - tmp4, FIX(0.951056516)) -     /* (c3+c7)/2 */\n\t    MULTIPLY(tmp1 + tmp3, FIX(0.587785252));      /* (c1-c9)/2 */\n    tmp13 = MULTIPLY(tmp10 + tmp11, FIX(0.309016994)) +   /* (c3-c7)/2 */\n\t    (tmp11 << (CONST_BITS - 1)) - tmp2;\n    dataptr[3] = (DCTELEM) DESCALE(tmp12 + tmp13, CONST_BITS-PASS1_BITS);\n    dataptr[7] = (DCTELEM) DESCALE(tmp12 - tmp13, CONST_BITS-PASS1_BITS);\n\n    dataptr += DCTSIZE;\t\t/* advance pointer to next row */\n  }\n\n  /* Pass 2: process columns.\n   * We remove the PASS1_BITS scaling, but leave the results scaled up\n   * by an overall factor of 8.\n   * We must also scale the output by (8/10)*(8/5) = 32/25, which we\n   * fold into the constant multipliers:\n   * 5-point FDCT kernel, cK represents sqrt(2) * cos(K*pi/10) * 32/25.\n   */\n\n  dataptr = data;\n  for (ctr = DCTSIZE-1; ctr >= 0; ctr--) {\n    /* Even part */\n\n    tmp0 = dataptr[DCTSIZE*0] + dataptr[DCTSIZE*4];\n    tmp1 = dataptr[DCTSIZE*1] + dataptr[DCTSIZE*3];\n    tmp2 = dataptr[DCTSIZE*2];\n\n    tmp10 = tmp0 + tmp1;\n    tmp11 = tmp0 - tmp1;\n\n    tmp0 = dataptr[DCTSIZE*0] - dataptr[DCTSIZE*4];\n    tmp1 = dataptr[DCTSIZE*1] - dataptr[DCTSIZE*3];\n\n    dataptr[DCTSIZE*0] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp10 + tmp2, FIX(1.28)),        /* 32/25 */\n\t      CONST_BITS+PASS1_BITS);\n    tmp11 = MULTIPLY(tmp11, FIX(1.011928851));          /* (c2+c4)/2 */\n    tmp10 -= tmp2 << 2;\n    tmp10 = MULTIPLY(tmp10, FIX(0.452548340));          /* (c2-c4)/2 */\n    dataptr[DCTSIZE*2] = (DCTELEM) DESCALE(tmp11 + tmp10, CONST_BITS+PASS1_BITS);\n    dataptr[DCTSIZE*4] = (DCTELEM) DESCALE(tmp11 - tmp10, CONST_BITS+PASS1_BITS);\n\n    /* Odd part */\n\n    tmp10 = MULTIPLY(tmp0 + tmp1, FIX(1.064004961));    /* c3 */\n\n    dataptr[DCTSIZE*1] = (DCTELEM)\n      DESCALE(tmp10 + MULTIPLY(tmp0, FIX(0.657591230)), /* c1-c3 */\n\t      CONST_BITS+PASS1_BITS);\n    dataptr[DCTSIZE*3] = (DCTELEM)\n      DESCALE(tmp10 - MULTIPLY(tmp1, FIX(2.785601151)), /* c1+c3 */\n\t      CONST_BITS+PASS1_BITS);\n\n    dataptr++;\t\t\t/* advance pointer to next column */\n  }\n}", "path": "HummusJS/src/deps/LibJpeg/jfdctint.c", "commit_date": "2013-06-10 00:00:00", "repo_name": "galkahana/HummusJS", "stars": 1126, "license": "other", "language": "c", "size": 26954}
{"docstring": "/*\n * Perform the forward DCT on a 4x8 sample block.\n *\n * 4-point FDCT in pass 1 (rows), 8-point in pass 2 (columns).\n */\n", "func_signal": "GLOBAL(void)\njpeg_fdct_4x8 (DCTELEM * data, JSAMPARRAY sample_data, JDIMENSION start_col)", "code": "{\n  INT32 tmp0, tmp1, tmp2, tmp3;\n  INT32 tmp10, tmp11, tmp12, tmp13;\n  INT32 z1;\n  DCTELEM *dataptr;\n  JSAMPROW elemptr;\n  int ctr;\n  SHIFT_TEMPS\n\n  /* Pre-zero output coefficient block. */\n  MEMZERO(data, SIZEOF(DCTELEM) * DCTSIZE2);\n\n  /* Pass 1: process rows. */\n  /* Note results are scaled up by sqrt(8) compared to a true DCT; */\n  /* furthermore, we scale the results by 2**PASS1_BITS. */\n  /* We must also scale the output by 8/4 = 2, which we add here. */\n  /* 4-point FDCT kernel, cK represents sqrt(2) * cos(K*pi/16). */\n\n  dataptr = data;\n  for (ctr = 0; ctr < DCTSIZE; ctr++) {\n    elemptr = sample_data[ctr] + start_col;\n\n    /* Even part */\n\n    tmp0 = GETJSAMPLE(elemptr[0]) + GETJSAMPLE(elemptr[3]);\n    tmp1 = GETJSAMPLE(elemptr[1]) + GETJSAMPLE(elemptr[2]);\n\n    tmp10 = GETJSAMPLE(elemptr[0]) - GETJSAMPLE(elemptr[3]);\n    tmp11 = GETJSAMPLE(elemptr[1]) - GETJSAMPLE(elemptr[2]);\n\n    /* Apply unsigned->signed conversion */\n    dataptr[0] = (DCTELEM)\n      ((tmp0 + tmp1 - 4 * CENTERJSAMPLE) << (PASS1_BITS+1));\n    dataptr[2] = (DCTELEM) ((tmp0 - tmp1) << (PASS1_BITS+1));\n\n    /* Odd part */\n\n    tmp0 = MULTIPLY(tmp10 + tmp11, FIX_0_541196100);       /* c6 */\n    /* Add fudge factor here for final descale. */\n    tmp0 += ONE << (CONST_BITS-PASS1_BITS-2);\n\n    dataptr[1] = (DCTELEM)\n      RIGHT_SHIFT(tmp0 + MULTIPLY(tmp10, FIX_0_765366865), /* c2-c6 */\n\t\t  CONST_BITS-PASS1_BITS-1);\n    dataptr[3] = (DCTELEM)\n      RIGHT_SHIFT(tmp0 - MULTIPLY(tmp11, FIX_1_847759065), /* c2+c6 */\n\t\t  CONST_BITS-PASS1_BITS-1);\n\n    dataptr += DCTSIZE;\t\t/* advance pointer to next row */\n  }\n\n  /* Pass 2: process columns.\n   * We remove the PASS1_BITS scaling, but leave the results scaled up\n   * by an overall factor of 8.\n   */\n\n  dataptr = data;\n  for (ctr = 0; ctr < 4; ctr++) {\n    /* Even part per LL&M figure 1 --- note that published figure is faulty;\n     * rotator \"sqrt(2)*c1\" should be \"sqrt(2)*c6\".\n     */\n\n    tmp0 = dataptr[DCTSIZE*0] + dataptr[DCTSIZE*7];\n    tmp1 = dataptr[DCTSIZE*1] + dataptr[DCTSIZE*6];\n    tmp2 = dataptr[DCTSIZE*2] + dataptr[DCTSIZE*5];\n    tmp3 = dataptr[DCTSIZE*3] + dataptr[DCTSIZE*4];\n\n    /* Add fudge factor here for final descale. */\n    tmp10 = tmp0 + tmp3 + (ONE << (PASS1_BITS-1));\n    tmp12 = tmp0 - tmp3;\n    tmp11 = tmp1 + tmp2;\n    tmp13 = tmp1 - tmp2;\n\n    tmp0 = dataptr[DCTSIZE*0] - dataptr[DCTSIZE*7];\n    tmp1 = dataptr[DCTSIZE*1] - dataptr[DCTSIZE*6];\n    tmp2 = dataptr[DCTSIZE*2] - dataptr[DCTSIZE*5];\n    tmp3 = dataptr[DCTSIZE*3] - dataptr[DCTSIZE*4];\n\n    dataptr[DCTSIZE*0] = (DCTELEM) RIGHT_SHIFT(tmp10 + tmp11, PASS1_BITS);\n    dataptr[DCTSIZE*4] = (DCTELEM) RIGHT_SHIFT(tmp10 - tmp11, PASS1_BITS);\n\n    z1 = MULTIPLY(tmp12 + tmp13, FIX_0_541196100);\n    /* Add fudge factor here for final descale. */\n    z1 += ONE << (CONST_BITS+PASS1_BITS-1);\n    dataptr[DCTSIZE*2] = (DCTELEM)\n      RIGHT_SHIFT(z1 + MULTIPLY(tmp12, FIX_0_765366865), CONST_BITS+PASS1_BITS);\n    dataptr[DCTSIZE*6] = (DCTELEM)\n      RIGHT_SHIFT(z1 - MULTIPLY(tmp13, FIX_1_847759065), CONST_BITS+PASS1_BITS);\n\n    /* Odd part per figure 8 --- note paper omits factor of sqrt(2).\n     * 8-point FDCT kernel, cK represents sqrt(2) * cos(K*pi/16).\n     * i0..i3 in the paper are tmp0..tmp3 here.\n     */\n\n    tmp10 = tmp0 + tmp3;\n    tmp11 = tmp1 + tmp2;\n    tmp12 = tmp0 + tmp2;\n    tmp13 = tmp1 + tmp3;\n    z1 = MULTIPLY(tmp12 + tmp13, FIX_1_175875602); /*  c3 */\n    /* Add fudge factor here for final descale. */\n    z1 += ONE << (CONST_BITS+PASS1_BITS-1);\n\n    tmp0  = MULTIPLY(tmp0,    FIX_1_501321110);    /*  c1+c3-c5-c7 */\n    tmp1  = MULTIPLY(tmp1,    FIX_3_072711026);    /*  c1+c3+c5-c7 */\n    tmp2  = MULTIPLY(tmp2,    FIX_2_053119869);    /*  c1+c3-c5+c7 */\n    tmp3  = MULTIPLY(tmp3,    FIX_0_298631336);    /* -c1+c3+c5-c7 */\n    tmp10 = MULTIPLY(tmp10, - FIX_0_899976223);    /*  c7-c3 */\n    tmp11 = MULTIPLY(tmp11, - FIX_2_562915447);    /* -c1-c3 */\n    tmp12 = MULTIPLY(tmp12, - FIX_0_390180644);    /*  c5-c3 */\n    tmp13 = MULTIPLY(tmp13, - FIX_1_961570560);    /* -c3-c5 */\n\n    tmp12 += z1;\n    tmp13 += z1;\n\n    dataptr[DCTSIZE*1] = (DCTELEM)\n      RIGHT_SHIFT(tmp0 + tmp10 + tmp12, CONST_BITS+PASS1_BITS);\n    dataptr[DCTSIZE*3] = (DCTELEM)\n      RIGHT_SHIFT(tmp1 + tmp11 + tmp13, CONST_BITS+PASS1_BITS);\n    dataptr[DCTSIZE*5] = (DCTELEM)\n      RIGHT_SHIFT(tmp2 + tmp11 + tmp12, CONST_BITS+PASS1_BITS);\n    dataptr[DCTSIZE*7] = (DCTELEM)\n      RIGHT_SHIFT(tmp3 + tmp10 + tmp13, CONST_BITS+PASS1_BITS);\n\n    dataptr++;\t\t\t/* advance pointer to next column */\n  }\n}", "path": "HummusJS/src/deps/LibJpeg/jfdctint.c", "commit_date": "2013-06-10 00:00:00", "repo_name": "galkahana/HummusJS", "stars": 1126, "license": "other", "language": "c", "size": 26954}
{"docstring": "/*\n * Perform the forward DCT on a 4x4 sample block.\n */\n", "func_signal": "GLOBAL(void)\njpeg_fdct_4x4 (DCTELEM * data, JSAMPARRAY sample_data, JDIMENSION start_col)", "code": "{\n  INT32 tmp0, tmp1;\n  INT32 tmp10, tmp11;\n  DCTELEM *dataptr;\n  JSAMPROW elemptr;\n  int ctr;\n  SHIFT_TEMPS\n\n  /* Pre-zero output coefficient block. */\n  MEMZERO(data, SIZEOF(DCTELEM) * DCTSIZE2);\n\n  /* Pass 1: process rows. */\n  /* Note results are scaled up by sqrt(8) compared to a true DCT; */\n  /* furthermore, we scale the results by 2**PASS1_BITS. */\n  /* We must also scale the output by (8/4)**2 = 2**2, which we add here. */\n  /* cK represents sqrt(2) * cos(K*pi/16) [refers to 8-point FDCT]. */\n\n  dataptr = data;\n  for (ctr = 0; ctr < 4; ctr++) {\n    elemptr = sample_data[ctr] + start_col;\n\n    /* Even part */\n\n    tmp0 = GETJSAMPLE(elemptr[0]) + GETJSAMPLE(elemptr[3]);\n    tmp1 = GETJSAMPLE(elemptr[1]) + GETJSAMPLE(elemptr[2]);\n\n    tmp10 = GETJSAMPLE(elemptr[0]) - GETJSAMPLE(elemptr[3]);\n    tmp11 = GETJSAMPLE(elemptr[1]) - GETJSAMPLE(elemptr[2]);\n\n    /* Apply unsigned->signed conversion */\n    dataptr[0] = (DCTELEM)\n      ((tmp0 + tmp1 - 4 * CENTERJSAMPLE) << (PASS1_BITS+2));\n    dataptr[2] = (DCTELEM) ((tmp0 - tmp1) << (PASS1_BITS+2));\n\n    /* Odd part */\n\n    tmp0 = MULTIPLY(tmp10 + tmp11, FIX_0_541196100);       /* c6 */\n    /* Add fudge factor here for final descale. */\n    tmp0 += ONE << (CONST_BITS-PASS1_BITS-3);\n\n    dataptr[1] = (DCTELEM)\n      RIGHT_SHIFT(tmp0 + MULTIPLY(tmp10, FIX_0_765366865), /* c2-c6 */\n\t\t  CONST_BITS-PASS1_BITS-2);\n    dataptr[3] = (DCTELEM)\n      RIGHT_SHIFT(tmp0 - MULTIPLY(tmp11, FIX_1_847759065), /* c2+c6 */\n\t\t  CONST_BITS-PASS1_BITS-2);\n\n    dataptr += DCTSIZE;\t\t/* advance pointer to next row */\n  }\n\n  /* Pass 2: process columns.\n   * We remove the PASS1_BITS scaling, but leave the results scaled up\n   * by an overall factor of 8.\n   */\n\n  dataptr = data;\n  for (ctr = 0; ctr < 4; ctr++) {\n    /* Even part */\n\n    /* Add fudge factor here for final descale. */\n    tmp0 = dataptr[DCTSIZE*0] + dataptr[DCTSIZE*3] + (ONE << (PASS1_BITS-1));\n    tmp1 = dataptr[DCTSIZE*1] + dataptr[DCTSIZE*2];\n\n    tmp10 = dataptr[DCTSIZE*0] - dataptr[DCTSIZE*3];\n    tmp11 = dataptr[DCTSIZE*1] - dataptr[DCTSIZE*2];\n\n    dataptr[DCTSIZE*0] = (DCTELEM) RIGHT_SHIFT(tmp0 + tmp1, PASS1_BITS);\n    dataptr[DCTSIZE*2] = (DCTELEM) RIGHT_SHIFT(tmp0 - tmp1, PASS1_BITS);\n\n    /* Odd part */\n\n    tmp0 = MULTIPLY(tmp10 + tmp11, FIX_0_541196100);       /* c6 */\n    /* Add fudge factor here for final descale. */\n    tmp0 += ONE << (CONST_BITS+PASS1_BITS-1);\n\n    dataptr[DCTSIZE*1] = (DCTELEM)\n      RIGHT_SHIFT(tmp0 + MULTIPLY(tmp10, FIX_0_765366865), /* c2-c6 */\n\t\t  CONST_BITS+PASS1_BITS);\n    dataptr[DCTSIZE*3] = (DCTELEM)\n      RIGHT_SHIFT(tmp0 - MULTIPLY(tmp11, FIX_1_847759065), /* c2+c6 */\n\t\t  CONST_BITS+PASS1_BITS);\n\n    dataptr++;\t\t\t/* advance pointer to next column */\n  }\n}", "path": "HummusJS/src/deps/LibJpeg/jfdctint.c", "commit_date": "2013-06-10 00:00:00", "repo_name": "galkahana/HummusJS", "stars": 1126, "license": "other", "language": "c", "size": 26954}
{"docstring": "/*\n * Perform the forward DCT on a 1x1 sample block.\n */\n", "func_signal": "GLOBAL(void)\njpeg_fdct_1x1 (DCTELEM * data, JSAMPARRAY sample_data, JDIMENSION start_col)", "code": "{\n  /* Pre-zero output coefficient block. */\n  MEMZERO(data, SIZEOF(DCTELEM) * DCTSIZE2);\n\n  /* We leave the result scaled up by an overall factor of 8. */\n  /* We must also scale the output by (8/1)**2 = 2**6. */\n  /* Apply unsigned->signed conversion */\n  data[0] = (DCTELEM)\n    ((GETJSAMPLE(sample_data[0][start_col]) - CENTERJSAMPLE) << 6);\n}", "path": "HummusJS/src/deps/LibJpeg/jfdctint.c", "commit_date": "2013-06-10 00:00:00", "repo_name": "galkahana/HummusJS", "stars": 1126, "license": "other", "language": "c", "size": 26954}
{"docstring": "/*\n * Perform the forward DCT on a 6x12 sample block.\n *\n * 6-point FDCT in pass 1 (rows), 12-point in pass 2 (columns).\n */\n", "func_signal": "GLOBAL(void)\njpeg_fdct_6x12 (DCTELEM * data, JSAMPARRAY sample_data, JDIMENSION start_col)", "code": "{\n  INT32 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5;\n  INT32 tmp10, tmp11, tmp12, tmp13, tmp14, tmp15;\n  DCTELEM workspace[8*4];\n  DCTELEM *dataptr;\n  DCTELEM *wsptr;\n  JSAMPROW elemptr;\n  int ctr;\n  SHIFT_TEMPS\n\n  /* Pre-zero output coefficient block. */\n  MEMZERO(data, SIZEOF(DCTELEM) * DCTSIZE2);\n\n  /* Pass 1: process rows. */\n  /* Note results are scaled up by sqrt(8) compared to a true DCT; */\n  /* furthermore, we scale the results by 2**PASS1_BITS. */\n  /* 6-point FDCT kernel, cK represents sqrt(2) * cos(K*pi/12). */\n\n  dataptr = data;\n  ctr = 0;\n  for (;;) {\n    elemptr = sample_data[ctr] + start_col;\n\n    /* Even part */\n\n    tmp0 = GETJSAMPLE(elemptr[0]) + GETJSAMPLE(elemptr[5]);\n    tmp11 = GETJSAMPLE(elemptr[1]) + GETJSAMPLE(elemptr[4]);\n    tmp2 = GETJSAMPLE(elemptr[2]) + GETJSAMPLE(elemptr[3]);\n\n    tmp10 = tmp0 + tmp2;\n    tmp12 = tmp0 - tmp2;\n\n    tmp0 = GETJSAMPLE(elemptr[0]) - GETJSAMPLE(elemptr[5]);\n    tmp1 = GETJSAMPLE(elemptr[1]) - GETJSAMPLE(elemptr[4]);\n    tmp2 = GETJSAMPLE(elemptr[2]) - GETJSAMPLE(elemptr[3]);\n\n    /* Apply unsigned->signed conversion */\n    dataptr[0] = (DCTELEM)\n      ((tmp10 + tmp11 - 6 * CENTERJSAMPLE) << PASS1_BITS);\n    dataptr[2] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp12, FIX(1.224744871)),                 /* c2 */\n\t      CONST_BITS-PASS1_BITS);\n    dataptr[4] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp10 - tmp11 - tmp11, FIX(0.707106781)), /* c4 */\n\t      CONST_BITS-PASS1_BITS);\n\n    /* Odd part */\n\n    tmp10 = DESCALE(MULTIPLY(tmp0 + tmp2, FIX(0.366025404)),     /* c5 */\n\t\t    CONST_BITS-PASS1_BITS);\n\n    dataptr[1] = (DCTELEM) (tmp10 + ((tmp0 + tmp1) << PASS1_BITS));\n    dataptr[3] = (DCTELEM) ((tmp0 - tmp1 - tmp2) << PASS1_BITS);\n    dataptr[5] = (DCTELEM) (tmp10 + ((tmp2 - tmp1) << PASS1_BITS));\n\n    ctr++;\n\n    if (ctr != DCTSIZE) {\n      if (ctr == 12)\n\tbreak;\t\t\t/* Done. */\n      dataptr += DCTSIZE;\t/* advance pointer to next row */\n    } else\n      dataptr = workspace;\t/* switch pointer to extended workspace */\n  }\n\n  /* Pass 2: process columns.\n   * We remove the PASS1_BITS scaling, but leave the results scaled up\n   * by an overall factor of 8.\n   * We must also scale the output by (8/6)*(8/12) = 8/9, which we\n   * fold into the constant multipliers:\n   * 12-point FDCT kernel, cK represents sqrt(2) * cos(K*pi/24) * 8/9.\n   */\n\n  dataptr = data;\n  wsptr = workspace;\n  for (ctr = 0; ctr < 6; ctr++) {\n    /* Even part */\n\n    tmp0 = dataptr[DCTSIZE*0] + wsptr[DCTSIZE*3];\n    tmp1 = dataptr[DCTSIZE*1] + wsptr[DCTSIZE*2];\n    tmp2 = dataptr[DCTSIZE*2] + wsptr[DCTSIZE*1];\n    tmp3 = dataptr[DCTSIZE*3] + wsptr[DCTSIZE*0];\n    tmp4 = dataptr[DCTSIZE*4] + dataptr[DCTSIZE*7];\n    tmp5 = dataptr[DCTSIZE*5] + dataptr[DCTSIZE*6];\n\n    tmp10 = tmp0 + tmp5;\n    tmp13 = tmp0 - tmp5;\n    tmp11 = tmp1 + tmp4;\n    tmp14 = tmp1 - tmp4;\n    tmp12 = tmp2 + tmp3;\n    tmp15 = tmp2 - tmp3;\n\n    tmp0 = dataptr[DCTSIZE*0] - wsptr[DCTSIZE*3];\n    tmp1 = dataptr[DCTSIZE*1] - wsptr[DCTSIZE*2];\n    tmp2 = dataptr[DCTSIZE*2] - wsptr[DCTSIZE*1];\n    tmp3 = dataptr[DCTSIZE*3] - wsptr[DCTSIZE*0];\n    tmp4 = dataptr[DCTSIZE*4] - dataptr[DCTSIZE*7];\n    tmp5 = dataptr[DCTSIZE*5] - dataptr[DCTSIZE*6];\n\n    dataptr[DCTSIZE*0] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp10 + tmp11 + tmp12, FIX(0.888888889)), /* 8/9 */\n\t      CONST_BITS+PASS1_BITS);\n    dataptr[DCTSIZE*6] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp13 - tmp14 - tmp15, FIX(0.888888889)), /* 8/9 */\n\t      CONST_BITS+PASS1_BITS);\n    dataptr[DCTSIZE*4] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp10 - tmp12, FIX(1.088662108)),         /* c4 */\n\t      CONST_BITS+PASS1_BITS);\n    dataptr[DCTSIZE*2] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp14 - tmp15, FIX(0.888888889)) +        /* 8/9 */\n\t      MULTIPLY(tmp13 + tmp15, FIX(1.214244803)),         /* c2 */\n\t      CONST_BITS+PASS1_BITS);\n\n    /* Odd part */\n\n    tmp10 = MULTIPLY(tmp1 + tmp4, FIX(0.481063200));   /* c9 */\n    tmp14 = tmp10 + MULTIPLY(tmp1, FIX(0.680326102));  /* c3-c9 */\n    tmp15 = tmp10 - MULTIPLY(tmp4, FIX(1.642452502));  /* c3+c9 */\n    tmp12 = MULTIPLY(tmp0 + tmp2, FIX(0.997307603));   /* c5 */\n    tmp13 = MULTIPLY(tmp0 + tmp3, FIX(0.765261039));   /* c7 */\n    tmp10 = tmp12 + tmp13 + tmp14 - MULTIPLY(tmp0, FIX(0.516244403)) /* c5+c7-c1 */\n\t    + MULTIPLY(tmp5, FIX(0.164081699));        /* c11 */\n    tmp11 = MULTIPLY(tmp2 + tmp3, - FIX(0.164081699)); /* -c11 */\n    tmp12 += tmp11 - tmp15 - MULTIPLY(tmp2, FIX(2.079550144)) /* c1+c5-c11 */\n\t    + MULTIPLY(tmp5, FIX(0.765261039));        /* c7 */\n    tmp13 += tmp11 - tmp14 + MULTIPLY(tmp3, FIX(0.645144899)) /* c1+c11-c7 */\n\t    - MULTIPLY(tmp5, FIX(0.997307603));        /* c5 */\n    tmp11 = tmp15 + MULTIPLY(tmp0 - tmp3, FIX(1.161389302)) /* c3 */\n\t    - MULTIPLY(tmp2 + tmp5, FIX(0.481063200)); /* c9 */\n\n    dataptr[DCTSIZE*1] = (DCTELEM) DESCALE(tmp10, CONST_BITS+PASS1_BITS);\n    dataptr[DCTSIZE*3] = (DCTELEM) DESCALE(tmp11, CONST_BITS+PASS1_BITS);\n    dataptr[DCTSIZE*5] = (DCTELEM) DESCALE(tmp12, CONST_BITS+PASS1_BITS);\n    dataptr[DCTSIZE*7] = (DCTELEM) DESCALE(tmp13, CONST_BITS+PASS1_BITS);\n\n    dataptr++;\t\t\t/* advance pointer to next column */\n    wsptr++;\t\t\t/* advance pointer to next column */\n  }\n}", "path": "HummusJS/src/deps/LibJpeg/jfdctint.c", "commit_date": "2013-06-10 00:00:00", "repo_name": "galkahana/HummusJS", "stars": 1126, "license": "other", "language": "c", "size": 26954}
{"docstring": "/*\n * Perform the forward DCT on a 3x3 sample block.\n */\n", "func_signal": "GLOBAL(void)\njpeg_fdct_3x3 (DCTELEM * data, JSAMPARRAY sample_data, JDIMENSION start_col)", "code": "{\n  INT32 tmp0, tmp1, tmp2;\n  DCTELEM *dataptr;\n  JSAMPROW elemptr;\n  int ctr;\n  SHIFT_TEMPS\n\n  /* Pre-zero output coefficient block. */\n  MEMZERO(data, SIZEOF(DCTELEM) * DCTSIZE2);\n\n  /* Pass 1: process rows. */\n  /* Note results are scaled up by sqrt(8) compared to a true DCT; */\n  /* furthermore, we scale the results by 2**PASS1_BITS. */\n  /* We scale the results further by 2**2 as part of output adaption */\n  /* scaling for different DCT size. */\n  /* cK represents sqrt(2) * cos(K*pi/6). */\n\n  dataptr = data;\n  for (ctr = 0; ctr < 3; ctr++) {\n    elemptr = sample_data[ctr] + start_col;\n\n    /* Even part */\n\n    tmp0 = GETJSAMPLE(elemptr[0]) + GETJSAMPLE(elemptr[2]);\n    tmp1 = GETJSAMPLE(elemptr[1]);\n\n    tmp2 = GETJSAMPLE(elemptr[0]) - GETJSAMPLE(elemptr[2]);\n\n    /* Apply unsigned->signed conversion */\n    dataptr[0] = (DCTELEM)\n      ((tmp0 + tmp1 - 3 * CENTERJSAMPLE) << (PASS1_BITS+2));\n    dataptr[2] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp0 - tmp1 - tmp1, FIX(0.707106781)), /* c2 */\n\t      CONST_BITS-PASS1_BITS-2);\n\n    /* Odd part */\n\n    dataptr[1] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp2, FIX(1.224744871)),               /* c1 */\n\t      CONST_BITS-PASS1_BITS-2);\n\n    dataptr += DCTSIZE;\t\t/* advance pointer to next row */\n  }\n\n  /* Pass 2: process columns.\n   * We remove the PASS1_BITS scaling, but leave the results scaled up\n   * by an overall factor of 8.\n   * We must also scale the output by (8/3)**2 = 64/9, which we partially\n   * fold into the constant multipliers (other part was done in pass 1):\n   * cK now represents sqrt(2) * cos(K*pi/6) * 16/9.\n   */\n\n  dataptr = data;\n  for (ctr = 0; ctr < 3; ctr++) {\n    /* Even part */\n\n    tmp0 = dataptr[DCTSIZE*0] + dataptr[DCTSIZE*2];\n    tmp1 = dataptr[DCTSIZE*1];\n\n    tmp2 = dataptr[DCTSIZE*0] - dataptr[DCTSIZE*2];\n\n    dataptr[DCTSIZE*0] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp0 + tmp1, FIX(1.777777778)),        /* 16/9 */\n\t      CONST_BITS+PASS1_BITS);\n    dataptr[DCTSIZE*2] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp0 - tmp1 - tmp1, FIX(1.257078722)), /* c2 */\n\t      CONST_BITS+PASS1_BITS);\n\n    /* Odd part */\n\n    dataptr[DCTSIZE*1] = (DCTELEM)\n      DESCALE(MULTIPLY(tmp2, FIX(2.177324216)),               /* c1 */\n\t      CONST_BITS+PASS1_BITS);\n\n    dataptr++;\t\t\t/* advance pointer to next column */\n  }\n}", "path": "HummusJS/src/deps/LibJpeg/jfdctint.c", "commit_date": "2013-06-10 00:00:00", "repo_name": "galkahana/HummusJS", "stars": 1126, "license": "other", "language": "c", "size": 26954}
{"docstring": "/** Returns a negative integer if first < second, zero if first == second, and a positive integer if first > second. */\n", "func_signal": "int compareTimeval( const struct timeval* first, const struct timeval* second )", "code": "{\n\tint difference = first->tv_sec - second->tv_sec;\n\tif ( difference == 0 )\n\t{\n\t\t// If the seconds fields are equal, compare based on the microseconds\n\t\tdifference = first->tv_usec - second->tv_usec;\n\t}\n\t\n\treturn difference;\n}", "path": "wifi-arsenal/fakeaps.c", "commit_date": "2015-05-22 00:00:00", "repo_name": "0x90/wifi-arsenal", "stars": 1778, "license": "None", "language": "c", "size": 144205}
{"docstring": "/* findcliententry accepts the MAC addresses of the STA and BSSID, and a\n   pointer to the array of structs containing previously discovered stations.\n   If the STA and BSSID have already been added to the struct, we return 1.\n   Else, we return 0. */\n", "func_signal": "int findstamac(u8 stamac[6], struct clientlist_data *clientlist)", "code": "{\n\n   int i, found=0;\n\n   for(i=0; i < MAXCLIENTLIST; i++) {\n       if (memcmp(clientlist[i].stamac, stamac, 6) == 0) {\n           found=1;\n           break;\n       }\n\n       /* If we have a member of clientlist that is NULL, we have reached \n          past the last added member of the struct.  We don't need to look any\n          further. */\n       // Fix this stupid nonsense\n       if(memcmp(clientlist[i].stamac, \"\\0\\0\\0\\0\\0\\0\", 1) == 0)  {\n            found=0;\n            break;\n       }\n   }\n\n   return(found);\n\n}", "path": "wifi-arsenal/asleap/asleap.c", "commit_date": "2015-05-22 00:00:00", "repo_name": "0x90/wifi-arsenal", "stars": 1778, "license": "None", "language": "c", "size": 144205}
{"docstring": "/* 2.4 Ghz frequence to channel */\n", "func_signal": "int8_t \niw_freq2channel(uint16_t freq)", "code": "{\n    freq = freq - 2407;\n    return((int8_t)(freq/5));\n}", "path": "wifi-arsenal/hwk/src/iw.c", "commit_date": "2015-05-22 00:00:00", "repo_name": "0x90/wifi-arsenal", "stars": 1778, "license": "None", "language": "c", "size": 144205}
{"docstring": "/* Program usage. */\n", "func_signal": "void usage(char *message)", "code": "{\n\n    if (strlen(message) > 0) {\n        printf(\"%s: %s\\n\", PROGNAME, message);\n    }\n\n    printf(\"Usage: %s [options]\\n\", PROGNAME);\n    printf(\"\\n\"\n    \"\\t-r \\tRead from a libpcap file\\n\"\n    \"\\t-i \\tInterface to capture on\\n\"\n    \"\\t-f \\tDictionary file with NT hashes\\n\"\n    \"\\t-n \\tIndex file for NT hashes\\n\"\n    \"\\t-w \\tWrite the LEAP exchange to a libpcap file\\n\"\n    \"\\t-s \\tSkip the check to make sure authentication was successful\\n\"\n#ifdef _LINUX\n    \"\\t-a \\tPerform an active attack (faster, requires AirJack drivers)\\n\"\n    \"\\t-c \\tSpecify a channel (defaults to current)\\n\"\n    \"\\t-o \\tPerform channel hopping\\n\"\n    \"\\t-t \\tSpecify a timeout watching for LEAP exchange (default 5 seconds)\\n\"\n#endif\n    \"\\t-D \\tList available devices for live capture\\n\"\n    \"\\t-h \\tOutput this help information and exit\\n\"\n    \"\\t-v \\tPrint verbose information (more -v for more verbosity)\\n\"\n    \"\\t-V \\tPrint program version and exit\\n\"\n    \"\\t-W \\tASCII dictionary file (special purpose)\\n\"\n    \"\\n\");\n}", "path": "wifi-arsenal/asleap/asleap.c", "commit_date": "2015-05-22 00:00:00", "repo_name": "0x90/wifi-arsenal", "stars": 1778, "license": "None", "language": "c", "size": 144205}
{"docstring": "/** Converts a 16-bit integer from host byte order to little-endian byte order. Not implement yet. */\n", "func_signal": "inline uint16_t htole16( uint16_t src )", "code": "{ return src; }\n\n#define BEACON_INTERVAL 102400\n\n/** Returns a beacon packet for the specified descriptor. The packet will be allocated using malloc. */\nuint8_t* constructBeaconPacket( uint8_t dataRate, uint8_t channel, const struct AccessPointDescriptor* apDescription, size_t* beaconLength )\n{\n\t// Validate parameters\n\tassert( apDescription != NULL );\n\tassert( beaconLength != NULL );\n\t\n\tassert( 0 <= apDescription->ssidLength && apDescription->ssidLength <= 32 );\n\tassert( 1 <= apDescription->dataRatesLength && apDescription->dataRatesLength <= 8 );\n\t\n\tuint8_t dataRateValue = (dataRate & IEEE80211_RATE_VAL);\n\t// For 802.11b, either 1 or 2 Mbps is the permitted rate for broadcasts\n\t// For 802.11a, 6Mbps is the permitted rate for broadcasts\n\tassert( dataRateValue == 0x02 || dataRateValue == 0x04 || dataRateValue == 0x12 ); \n\t\n\t// Packet size: radiotap header + 1 byte for rate + ieee80211_frame header + beacon info + tags\n\t*beaconLength = sizeof(struct ieee80211_radiotap_header) + sizeof(dataRate) +\n\t\tsizeof(struct ieee80211_frame) + sizeof(struct ieee80211_beacon) +\n\t// SSID, rates, channel\n\t\tsizeof(struct ieee80211_info_element)*3 + apDescription->ssidLength +\n\t\tapDescription->dataRatesLength + sizeof(channel);\n\t\n\tuint8_t* packet = (uint8_t*) malloc( *beaconLength );\n\tassert( packet != NULL );\n\tif ( packet == NULL )\n\t{\n\t\treturn NULL;\n\t}\n\t\n\tsize_t remainingBytes = *beaconLength;\n\t\n\t// Add the radiotap header\n\tassert( remainingBytes >= sizeof(struct ieee80211_radiotap_header) );\n\tstruct ieee80211_radiotap_header* radiotap = (struct ieee80211_radiotap_header*) packet;\n\tuint8_t* packetIterator = packet + sizeof(*radiotap);\n\tremainingBytes -= sizeof(*radiotap);\n\t\n\tradiotap->it_version = 0;\n\tradiotap->it_len = sizeof(*radiotap) + sizeof(dataRate);\n\tradiotap->it_present = (1 << IEEE80211_RADIOTAP_RATE);\n\t\n\t// Add the data rate for the radiotap header\n\tassert( remainingBytes >= sizeof(dataRate) );\n\t*packetIterator = (dataRate & IEEE80211_RATE_VAL);\n\tpacketIterator ++;\n\tremainingBytes -= sizeof(dataRate);\n\t\n\t// Build the 802.11 header\n\tassert( remainingBytes >= sizeof(struct ieee80211_frame) );\n\tstruct ieee80211_frame* dot80211 = (struct ieee80211_frame*) packetIterator;\n\tpacketIterator += sizeof(*dot80211);\n\tremainingBytes -= sizeof(*dot80211);\n\t\n\t// Beacon packet flags\n\tdot80211->i_fc[0] = IEEE80211_FC0_VERSION_0 | IEEE80211_FC0_TYPE_MGT | IEEE80211_FC0_SUBTYPE_BEACON;\n\tdot80211->i_fc[1] = IEEE80211_FC1_DIR_NODS;\n\tdot80211->i_dur[0] = 0x0;\n\tdot80211->i_dur[1] = 0x0;\n\t// Destination = broadcast (no retries)\n\tmemcpy( dot80211->i_addr1, IEEE80211_BROADCAST_ADDR, IEEE80211_ADDR_LEN );\n\t// Source = our own mac address\n\tmemcpy( dot80211->i_addr2, apDescription->macAddress, IEEE80211_ADDR_LEN );\n\t// BSS = our mac address\n\tmemcpy( dot80211->i_addr3, apDescription->macAddress, IEEE80211_ADDR_LEN );\n\t// Sequence control: Automatically set by the driver\n\t\n\t// Add the beacon frame\n\tassert( remainingBytes >= sizeof(struct ieee80211_beacon) );\n\tstruct ieee80211_beacon* beacon = (struct ieee80211_beacon*) packetIterator;\n\tpacketIterator += sizeof(*beacon);\n\tremainingBytes -= sizeof(*beacon);\n\t\n\tbeacon->beacon_timestamp = 0;\n\t// interval = 100 \"time units\" = 102.4 ms\n\t// Each time unit is equal to 1024 us\n\tbeacon->beacon_interval = htole16( BEACON_INTERVAL/1024 );\n\t// capabilities = sent by ESS\n\tbeacon->beacon_capabilities = htole16( 0x0001 );\n\t\n\t// Add the SSID\n\tassert( remainingBytes >= sizeof(struct ieee80211_info_element) + apDescription->ssidLength );\n\tstruct ieee80211_info_element* info = (struct ieee80211_info_element*) packetIterator;\n\tpacketIterator += sizeof(struct ieee80211_info_element) + apDescription->ssidLength;\n\tremainingBytes -= sizeof(struct ieee80211_info_element) + apDescription->ssidLength;\n\t\n\tinfo->info_elemid = IEEE80211_ELEMID_SSID;\n\tinfo->info_length = apDescription->ssidLength;\n\tmemcpy( info->info, apDescription->ssid, apDescription->ssidLength );\n\t\n\t// Add the data rates\n\tassert( remainingBytes >= sizeof(struct ieee80211_info_element) + apDescription->dataRatesLength );\n\tinfo = (struct ieee80211_info_element*) packetIterator;\n\tpacketIterator += sizeof(struct ieee80211_info_element) + apDescription->dataRatesLength;\n\tremainingBytes -= sizeof(struct ieee80211_info_element) + apDescription->dataRatesLength;\n\t\n\tinfo->info_elemid = IEEE80211_ELEMID_RATES;\n\tinfo->info_length = apDescription->dataRatesLength;\n\tmemcpy( info->info, apDescription->dataRates, apDescription->dataRatesLength );\n\t\n\t// Add the channel\n\tassert( remainingBytes >= sizeof(struct ieee80211_info_element) + sizeof(channel) );\n\tinfo = (struct ieee80211_info_element*) packetIterator;\n\tpacketIterator += sizeof(struct ieee80211_info_element) + sizeof(channel);\n\tremainingBytes -= sizeof(struct ieee80211_info_element) + sizeof(channel);\n\t\n\tinfo->info_elemid = IEEE80211_ELEMID_DSPARMS;\n\tinfo->info_length = sizeof(channel);\n\tmemcpy( info->info, &channel, sizeof(channel) );\n\t\n\tassert( remainingBytes == 0 );\n\treturn packet;\n}", "path": "wifi-arsenal/fakeaps.c", "commit_date": "2015-05-22 00:00:00", "repo_name": "0x90/wifi-arsenal", "stars": 1778, "license": "None", "language": "c", "size": 144205}
{"docstring": "/* Brute-force all the matching NT hashes to discover the clear-text password */\n", "func_signal": "int getmschappw(struct asleap_data *asleap_ptr)", "code": "{\n\n    unsigned char zpwhash[16] =\n        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n    struct hashpass_rec rec;\n    struct hashpassidx_rec idxrec;\n    char password_buf[MAX_NT_PASSWORD];\n    int  passlen, recordlength, passwordlen, i;\n    FILE *buffp, *idxfp;\n\n    /* If the user passed an index file for our reference, fseek to\n       map the file and perform lookups based on indexed offsets.\n       If there is no index file, perform a linear search. \n    */\n\n    if (IsBlank(asleap_ptr->dictidx)) {\n\n        /* We have no index file.  Do a linear search */\n        if((buffp = fopen(asleap_ptr->dictfile, \"rb\")) == NULL) {\n            perror(\"[getmschappw] fopen\");\n            return(-1);\n        }\n\n        fflush(stdout);\n        while(!feof(buffp)) {\n\n            memset(&rec, 0, sizeof(rec));\n            memset(&password_buf, 0, sizeof(password_buf));\n            memset(&zpwhash, 0, sizeof(zpwhash));\n            fread(&rec.rec_size, sizeof(rec.rec_size), 1, buffp);\n            recordlength = abs(rec.rec_size);\n            passlen = (recordlength - (17)); \n            fread(&password_buf, passlen, 1, buffp);\n            fread(&zpwhash, 16, 1, buffp);\n        \n        /* Test last 2 characters of NT hash value of the current entry in the\n           dictionary file.  If the 2 bytes of the NT hash don't\n           match the calculated value that we store in asleap.endofhash, then\n           this NT hash isn't a potential match.  Move on to the next entry. */\n            if (zpwhash[14] != asleap_ptr->endofhash[0] ||\n                zpwhash[15] != asleap_ptr->endofhash[1]) {\n                /* last 2 bytes of hash don't match - continue */\n                continue;\n            }\n\n            /* With a potential match, test with this challenge */\n            if (testchal(asleap_ptr, zpwhash) == 0) {\n                /* Found a matching password!  Store in the asleap_ptr struct */\n                memcpy(asleap_ptr->nthash, zpwhash, 16);\n                strncpy(asleap_ptr->password, password_buf,\n                    strlen(password_buf));\n                fclose(buffp);\n                return(1);\n            }\n        }\n\n        /* Could not find a matching NT hash */\n        fclose(buffp);\n\n    } else {  /* Use referenced index file for hash searches */\n\n        memset(&idxrec, 0, sizeof(idxrec));\n\n        if ((idxfp = fopen(asleap_ptr->dictidx, \"rb\")) == NULL) {\n            perror(\"[getmschappw] Cannot open index file\");\n            return(-1);\n        }\n\n        /* Open the file with a buffered file handle */\n        if((buffp = fopen(asleap_ptr->dictfile, \"rb\")) == NULL) {\n            perror(\"[getmschappw] fopen\");\n            return(-1);\n        }\n\n        /* Read through the index file until we find the entry that matches\n           our hash information */\n        while (idxrec.hashkey[0] != asleap_ptr->endofhash[0] ||\n               idxrec.hashkey[1] != asleap_ptr->endofhash[1]) {\n\n            if (fread(&idxrec, sizeof(idxrec), 1, idxfp) != 1) {\n                /* Unsuccessful fread, or EOF */\n                printf(\"\\tReached end of index file.\\n\");\n                fclose(idxfp);\n                fclose(buffp);\n                return(0);\n\n            }\n        }\n\n\n        /* The offset entry in the idxrec struct points to the first\n           hash+pass record in the hash+pass file that matches our offset.  The\n           idxrec struct also tells us how many entries we can read from the\n           hash+pass file that match our hashkey information.  Collect records\n           from the hash+pass file until we read through the number of records\n           in idxrec.numrec */\n\n        /* fseek to the correct offset in the file */\n        if (fseeko(buffp, idxrec.offset, SEEK_SET) < 0) {\n            perror(\"[getmschappw] fread\");\n            fclose(buffp);\n            fclose(idxfp);\n            return(-1);\n        }\n\n        for (i=0; i < idxrec.numrec; i++) {\n\n            memset(&rec, 0, sizeof(rec));\n            memset(&password_buf, 0, sizeof(password_buf));\n            fread(&rec.rec_size, sizeof(rec.rec_size), 1, buffp);\n\n            /* The length of the password is the record size, 16 for the hash,\n               1 for the record length byte. */\n            passwordlen = rec.rec_size - 17;\n\n            /* Check for corrupt data conditions, prevent segfault */\n            if (passwordlen > MAX_NT_PASSWORD) {\n                fprintf(stderr, \"Reported password length (%d) is longer than \"\n                        \"the max password length (%d).\\n\", passwordlen,\n                        MAX_NT_PASSWORD);\n                return(-1);\n            }\n\n            /* Gather the clear-text password from the dict+hash file,\n               then grab the 16 byte hash */\n            fread(&password_buf, passwordlen, 1, buffp);\n            fread(&zpwhash, sizeof(zpwhash), 1, buffp);\n\n            /* Test the challenge and compare to our hash */\n            if (testchal(asleap_ptr, zpwhash) == 0) {\n                /* Found a matching password!  Store in the asleap_ptr struct */\n                memcpy(asleap_ptr->nthash, zpwhash, 16);\n                strncpy(asleap_ptr->password, password_buf,\n                    strlen(password_buf));\n                fclose(buffp);\n                fclose(idxfp);\n                /* success */\n                return(1);\n            }\n\n        }\n\n        /* Could not find a match - bummer */\n        fclose(buffp);\n        fclose(idxfp);\n\n    }\n\n    return(0);\n\n}", "path": "wifi-arsenal/asleap/asleap.c", "commit_date": "2015-05-22 00:00:00", "repo_name": "0x90/wifi-arsenal", "stars": 1778, "license": "None", "language": "c", "size": 144205}
{"docstring": "/* testgre examines a packet and returns a 0 if the packet contains a PPP\n * payload, anything else returns 1.\n */\n", "func_signal": "int testgre(unsigned char *packet, struct capturedata_s capdata)", "code": "{\n\n    struct grehdr *gre_ptr;\n\n    /* We have a packet, start testing it for EAP-Challenge */\n    gre_ptr = (struct grehdr *)&packet[capdata.iphdroffset+IPHDRLEN];\n   \n\t/* Examine this frame for the PPP protocol type */\n    if (ntohs(gre_ptr->type) == GREPROTOPPP) {\n        return(0);\n\t}\n\n    return(1);\n}", "path": "wifi-arsenal/asleap/asleap.c", "commit_date": "2015-05-22 00:00:00", "repo_name": "0x90/wifi-arsenal", "stars": 1778, "license": "None", "language": "c", "size": 144205}
{"docstring": "/* getnextrec accepts a record structure, a file pointer and a flag to indicate\n   if we want to populate the password member of the structure (requires a\n   malloc).  getnextrec populates the structure with the next record available,\n   and returns the record length on success, or negative on failure. */\n", "func_signal": "int getnextrec(struct hashpass_rec *rec, FILE *fp, int fillpass)", "code": "{\n\n    int passlen;\n    unsigned char passbuf[64];\n\n    fread(&rec->rec_size, 1, 1, fp);\n\n    passlen = (rec->rec_size - 17);\n\n    if (fillpass) {\n        if (passlen < 1) {\n            perror(\"[getnextrec] Too short password length\");\n            return(-1);\n        }\n\n        if ((rec->password = malloc(passlen)) == NULL) {\n            return(-1);\n        }\n\n        fread(rec->password, passlen, 1, fp);\n\n    } else {\n\n        fread(passbuf, passlen, 1, fp);\n    }\n\n    fread(rec->hash, 16, 1, fp);\n\n    return(rec->rec_size);\n}", "path": "wifi-arsenal/asleap/genkeys.c", "commit_date": "2015-05-22 00:00:00", "repo_name": "0x90/wifi-arsenal", "stars": 1778, "license": "None", "language": "c", "size": 144205}
{"docstring": "/** Add increment microseconds to time, computing the overflow correctly. */\n", "func_signal": "void incrementTimeval( struct timeval* time, suseconds_t increment )", "code": "{\n\tassert( time != NULL );\n\tassert( 0 <= time->tv_usec && time->tv_usec < 1000000 );\n\t\n\tif ( increment >= 1000000 )\n\t{\n\t\t// Add the seconds to the seconds field, and keep the remainder\n\t\ttime->tv_sec += (increment/1000000);\n\t\tincrement = increment % 1000000;\n\t}\n\t\n\tassert( increment < 1000000 );\n\t\n\ttime->tv_usec += increment;\n\tif ( time->tv_usec >= 1000000 )\n\t{\n\t\ttime->tv_sec += 1;\n\t\ttime->tv_usec -= 1000000;\n\t\t\n\t\tassert( 0 <= time->tv_usec && time->tv_usec < 1000000 );\n\t}\n}", "path": "wifi-arsenal/fakeaps.c", "commit_date": "2015-05-22 00:00:00", "repo_name": "0x90/wifi-arsenal", "stars": 1778, "license": "None", "language": "c", "size": 144205}
{"docstring": "/* testleap examines a packet and returns a 0 if the packet contains LEAP\n * headers, anything else returns 1.\n */\n", "func_signal": "int testleap(unsigned char *packet, struct capturedata_s capdata, int fromds)", "code": "{\n\n    struct ieee80211 *dot11_ptr;\n    struct eap_leap *leap_ptr;\n\n    /* We have a packet, start testing it for EAP-Challenge */\n    dot11_ptr = (struct ieee80211 *)&packet[capdata.dot11offset];\n    leap_ptr = (struct eap_leap *)&packet[capdata.leapoffset];\n   \n    /* Examine frames that have 802.11 headers for fromds flag */\n    if (capdata.captype == LPCAP_DLTRFMON_PCAP || \n        capdata.captype == LPCAP_DLTTZSP_PCAP ||\n        capdata.captype == APEEK_LEGACY_OFFLINE_PCAP ||\n        capdata.captype == APEEK_XML_OFFLINE_PCAP) {\n        if (dot11_ptr->from_ds != fromds) {\n            return(1);\n        }\n    }\n   \n\t/* Examine this frame for the LEAP characteristics */\n    if (leap_ptr->type == 17 && leap_ptr->version == 1) {\n        return(0);\n\t}\n\n    return(1);\n}", "path": "wifi-arsenal/asleap/asleap.c", "commit_date": "2015-05-22 00:00:00", "repo_name": "0x90/wifi-arsenal", "stars": 1778, "license": "None", "language": "c", "size": 144205}
{"docstring": "/* closebuckets accepts an array of type hashbucket_rec and closes each\n   file handle.  There is no return value. */\n", "func_signal": "void closebuckets(struct hashbucket_rec hbucket[256], int hsub)", "code": "{\n\n    char bucketfile[256];\n    for (hsub--; hsub != -1; hsub--) {\n        fclose(hbucket[hsub].sbucket);\n        sprintf(bucketfile, \"genk-bucket-%02x.tmp\", hsub);\n        remove(bucketfile);\n    }\n}", "path": "wifi-arsenal/asleap/genkeys.c", "commit_date": "2015-05-22 00:00:00", "repo_name": "0x90/wifi-arsenal", "stars": 1778, "license": "None", "language": "c", "size": 144205}
{"docstring": "/* Use a supplied dictionary file instead of the hash table and index file */\n", "func_signal": "int getmschapbrute(struct asleap_data *asleap_ptr)", "code": "{\n\n    FILE *wordlist;\n    char password[MAX_NT_PASSWORD+1];\n    unsigned char pwhash[MD4_SIGNATURE_SIZE];\n    unsigned long long count = 0;\n\n    if (*asleap_ptr->wordfile == '-') {\n        wordlist = stdin;\n    } else {\n        if ((wordlist = fopen(asleap_ptr->wordfile, \"rb\")) == NULL) {\n            perror(\"fopen\");\n            return -1;\n        }\n    }\n\n    while (!feof(wordlist)) {\n\n        fgets(password, MAX_NT_PASSWORD+1, wordlist);\n        /* Remove newline */\n        password[strlen(password)-1] = 0;\n\n#ifndef _OPENSSL_MD4\n        /* md4.c seems to have a problem with passwords longer than 31 bytes.\n           This seems odd to me, but it should have little impact on our\n           final product, since I assume there are few passwords we will be\n           able to identify with a dictionary attack that are longer than 31\n           bytes. */\n        password[31] = 0;\n#endif\n\n        NtPasswordHash(password, strlen(password), pwhash);\n\n        count++;\n        if ((count % 500000) == 0) {\n            printf(\"\\033[K\\r\");\n            printf(\"        Testing %lld: %s\\r\", count, password);\n            fflush(stdout);\n        }\n\n        if (pwhash[14] != asleap_ptr->endofhash[0] ||\n            pwhash[15] != asleap_ptr->endofhash[1])\n                continue;\n\n        if (testchal(asleap_ptr, pwhash) == 0) {\n            /* Found a matching password! w00t! */\n            memcpy(asleap_ptr->nthash, pwhash, 16);\n            strncpy(asleap_ptr->password, password, strlen(password));\n            fclose(wordlist);\n            return(1);\n        }\n    }\n    return 0;\n}", "path": "wifi-arsenal/asleap/asleap.c", "commit_date": "2015-05-22 00:00:00", "repo_name": "0x90/wifi-arsenal", "stars": 1778, "license": "None", "language": "c", "size": 144205}
{"docstring": "/* testppp examines a packet and returns a 0 if the packet contains a PPP CHAP\n * payload, anything else returns 1.\n */\n", "func_signal": "int testppp(unsigned char *packet, struct capturedata_s capdata)", "code": "{\n\n    struct ppphdr *ppp_ptr;\n    int offset;\n\n    offset = getgrelen(packet, capdata);\n    if (offset < 1) {\n        return(-1);\n    }\n\n    offset += capdata.iphdroffset;\n    offset += IPHDRLEN;\n    /* We have a packet, start testing it for EAP-Challenge */\n    ppp_ptr = (struct ppphdr *)&packet[offset];\n   \n\t/* Examine this frame for the PPP protocol type */\n    if (ntohs(ppp_ptr->proto) == PPPPROTOCHAP) {\n        return(0);\n\t}\n\n    return(1);\n}", "path": "wifi-arsenal/asleap/asleap.c", "commit_date": "2015-05-22 00:00:00", "repo_name": "0x90/wifi-arsenal", "stars": 1778, "license": "None", "language": "c", "size": 144205}
{"docstring": "/* Populates global *packet, returns status */\n", "func_signal": "int getpacket(struct capture_data *capdata)", "code": "{\n\n    /* Assume it's a libpcap file for now */\n    int ret;\n    ret = pcap_next_ex(p, &h, (const u_char **)&packet);\n    return(ret);\n}", "path": "wifi-arsenal/cowpatty/cowpatty.c", "commit_date": "2015-05-22 00:00:00", "repo_name": "0x90/wifi-arsenal", "stars": 1778, "license": "None", "language": "c", "size": 144205}
{"docstring": "/* Accepts the populated asleap_data structure with the challenge and \n   response text, and our guess at the full 16-byte hash (zpwhash). Returns 1\n   if the hash does not match, 0 if it does match. */\n", "func_signal": "int testchal(struct asleap_data *asleap_ptr, unsigned char *zpwhash)", "code": "{\n\n    unsigned char cipher[8];\n\n    DesEncrypt(asleap_ptr->challenge, zpwhash, cipher);\n    if (memcmp(cipher, asleap_ptr->response, 8) != 0)\n        return(1);\n\n    DesEncrypt(asleap_ptr->challenge, zpwhash + 7, cipher);\n    if (memcmp(cipher, asleap_ptr->response + 8, 8) != 0)\n        return(1);\n\n    /* else - we have a match */\n    return(0);\n}", "path": "wifi-arsenal/asleap/asleap.c", "commit_date": "2015-05-22 00:00:00", "repo_name": "0x90/wifi-arsenal", "stars": 1778, "license": "None", "language": "c", "size": 144205}
{"docstring": "/* testdot1x examines a packet and returns a 0 if the packet contains dot1X\n * headers, anything else returns 1.\n */\n", "func_signal": "int testdot1x(unsigned char *packet, struct capturedata_s capdata, int fromds)", "code": "{\n\n    struct ieee80211 *dot11_ptr;\n    struct ieee8021x *dot1x_ptr;\n\n    /* We have a packet, start testing it for EAP-Challenge */\n    dot11_ptr = (struct ieee80211 *)&packet[capdata.dot11offset];\n    dot1x_ptr = (struct ieee8021x *)&packet[capdata.dot1xoffset];\n\n    /* Examine frames that have 802.11 headers for fromds flag */\n    if (capdata.captype == LPCAP_DLTRFMON_PCAP || \n        capdata.captype == LPCAP_DLTTZSP_PCAP ||\n        capdata.captype == APEEK_LEGACY_OFFLINE_PCAP ||\n        capdata.captype == APEEK_XML_OFFLINE_PCAP) {\n        if (dot11_ptr->from_ds != fromds) {\n            return(1);\n        }\n    }\n   \n\t/* Examine this frame for the 802.1x characteristics */\n    if (dot1x_ptr->version == 1 && \n\t\t(dot1x_ptr->type == 0 || dot1x_ptr->type == 3)) {\n        return(0);\n\t}\n\n    return(1);\n}", "path": "wifi-arsenal/asleap/asleap.c", "commit_date": "2015-05-22 00:00:00", "repo_name": "0x90/wifi-arsenal", "stars": 1778, "license": "None", "language": "c", "size": 144205}
{"docstring": "/* Populate global packet[] with the next available packet */\n", "func_signal": "int getpacket(struct capturedata_s capturedata)", "code": "{\n\n    struct timeval tv;\n    int    n, pcapno, len;\n    struct apeekl_rec_h apeeklprec;\n    struct apeekx_rec_h apeekxprec;\n    struct timeval ptstamp;\n    fd_set rset;\n\n    if (capturedata.captype) {\n        switch(capturedata.captype) {\n\t\t\tcase LPCAP_DLTTZSP_PCAP:\n\t        case LPCAP_DLTETH_PCAP:\n            case LPCAP_DLTRFMON_PCAP: \n                if (!(packet = (u_char *)pcap_next(p, &h)) == 0) {\n                    return(0);\n                } else { \n                    return(1);\n                }\n                return(0);\n                break;\n\n            case APEEK_LEGACY_OFFLINE_PCAP: \n\n                /* Populate the Airopeek Packet Record for record length and\n                   other information. */\n                if (fread(&apeeklprec, sizeof(apeeklprec), 1,  \n                    capturedata.apeekfp) < 1) {\n                    /* Reached EOF on AiroPeek file */\n                    return(1);\n                }\n\n                /* Change byte ordering for packet length */\n                apeeklprec.length = ntohs(apeeklprec.length);\n                apeeklprec.slice_length = ntohs(apeeklprec.slice_length);\n\n                /* The value of slice_length overrides the reported length of\n                 * the packet. */\n                if (apeeklprec.slice_length) {\n                    len = apeeklprec.slice_length;\n                } else {\n                    len = apeeklprec.length;\n                }\n\n                /* Round up packet length to even byte boundary */\n                if (len % 2) \n                    len++;\n\n                /* Check for corrupt data */\n                if (len > MAX_80211_PACKET_LEN) {\n                    fprintf(stderr, \"Bad packet length: %d.\\n\", len);\n                    return(-1);\n                }\n\n                /* The packet length reported by AiroPeek includes 4 preceding\n                   bytes of 802.11 signal information, and a trailing 4 bytes\n                   for the FCS.  We include the preceding 4 bytes in the per-\n                   packet header, so read 4 fewer bytes here for just the raw\n                   packet payload. */\n                len = len - 4;\n\n                /* free up the memory used for the previous packet */\n                if (packet != NULL) {\n                    free(packet);\n                }\n\n                /* Allocate len bytes for this packet */\n                if ((packet = malloc(len)) == NULL) {\n                    fprintf(stderr, \"Unable to allocate %d bytes of memory.\\n\",\n                        len);\n                    perror(\"getpacket[malloc]\");\n                    return(-1);\n                }\n\n                /* Kludge up the pcap header to we can use pcap_dump to write\n                 * out packets */\n                h.caplen = h.len = len;\n                gettimeofday(&ptstamp, NULL);\n                h.ts.tv_sec = ptstamp.tv_sec;\n                h.ts.tv_usec = ptstamp.tv_usec;\n\n                if (fread(packet, len, 1, capturedata.apeekfp) < 1) {\n                    return(1);\n                } else {\n                    return(0);\n                }\n                break;\n\n            case APEEK_XML_OFFLINE_PCAP:\n                /* Airopeek 2.x and later save file format */\n                \n                memset(&apeekxprec, 0, sizeof(apeekxprec));\n\n                /* populate global packet[] */\n                if (packet != NULL) {\n                    free(packet);\n                }\n\n                /* Get the per-packet record header */\n                if (fread(&apeekxprec, sizeof(apeekxprec), 1, \n                     capturedata.apeekfp) < 1) {\n                    /* Reached EOF on AiroPeek file */\n                    return(1);\n                }\n\n                /* The record header stores the record length in two fields.\n                 * Use this to identify incorrect file handling or a corrupt\n                 * file location. \n                 */\n                if (apeekxprec.length1 != apeekxprec.length2) {\n                    fprintf(stderr, \"Mismatch in record length detected.\\n\");\n                    return(-1);\n                }\n\n                if ((packet = malloc(apeekxprec.length1+1)) == NULL) {\n                    fprintf(stderr, \"Unable to allocate %d bytes of memory.\\n\",\n                            apeekxprec.length1);\n                    perror(\"getpacket[malloc]\");\n                    return(-1);\n                }\n\n                /* Kludge up the pcap header to we can use pcap_dump to write\n                 * out packets \n                 */\n                h.caplen = h.len = apeekxprec.length1;\n                gettimeofday(&ptstamp, NULL);\n                h.ts.tv_sec = ptstamp.tv_sec;\n                h.ts.tv_usec = ptstamp.tv_usec;\n\n\n                /* Populate packet[] with the payload information */\n                if (fread(packet, apeekxprec.length1, 1, \n                     capturedata.apeekfp) < 1) {\n                    return(1);\n                } else {\n                    return(0);\n                }\n\n                break;\n                \n            default:\n                /* Shouldn't happen */\n                fprintf(stderr, \"Unknown error processing offline pcap \"\n                                \"file.\\n\");\n                return(-1);\n        }\n\n        /* Shouldn't get here */\n        return(-1);\n\n    } else { /* we are reading from a live interface. */\n\n        /* select on the pcap fd, waiting for a packet */\n        tv.tv_sec=0;\n        tv.tv_usec=250000;\n        pcapno = pcap_fileno(p); \n        FD_ZERO(&rset);\n        FD_SET(pcapno, &rset);\n        n = select(pcapno+1, &rset, NULL, NULL, &tv);\n        /* select() will return > 0 if something interesting was found */\n        if (n < 1) {\n            /* Check for errors */\n            if (errno == EAGAIN || errno == EINTR || errno == 0) {\n                return(-2);\n            }\n        } else if (n == 0) {\n            /* select() didn't find anything interesting.  Return. */\n            return(-1);\n        } else {\n            /* select returned a ready filehandle */\n            if (!(packet = (u_char *)pcap_next(p, &h)) == 0) {\n                return(0);\n            } else {\n            /* pcap_next returned NULL */\n                return(1);\n            }\n        }\n\n        /* Never gets here */\n        return(0);\n\n    }\n\n}", "path": "wifi-arsenal/asleap/asleap.c", "commit_date": "2015-05-22 00:00:00", "repo_name": "0x90/wifi-arsenal", "stars": 1778, "license": "None", "language": "c", "size": 144205}
{"docstring": "/** Get the current 802.11 64-bit timestamp from the system time. */\n", "func_signal": "uint64_t getCurrentTimestamp()", "code": "{\n\tstruct timeval t;\n\t\n\tint code = gettimeofday( &t, NULL );\n\tassert( code == 0 );\n\tif ( code != 0 )\n\t{\n\t\tperror( \"error calling gettimeofday\" );\n\t\tassert( 0 );\n\t}\n\t\n\t// Convert seconds to microseconds\n\t// For the purposes of 802.11 timestamps, we don't care about what happens\n\t// when this value wraps. As long as the value wraps consistently, we are\n\t// happy\n\tuint64_t timestamp = t.tv_sec * 1000000LL;\n\ttimestamp += t.tv_usec;\n\t\n\treturn timestamp;\n}", "path": "wifi-arsenal/fakeaps.c", "commit_date": "2015-05-22 00:00:00", "repo_name": "0x90/wifi-arsenal", "stars": 1778, "license": "None", "language": "c", "size": 144205}
{"docstring": "/* nextchannel accepts the current channel as input, and returns the new\n   channel.  nextchannel returns -1 on error. */\n", "func_signal": "int nextchannel(ajdata_t *ajdata, int currentchannel)", "code": "{\n\n    int newchannel = 0;\n    newchannel = ((currentchannel % MAXCHANNEL) + 1);\n\n    if (aj_setchannel(ajdata->ifname, newchannel) != 0) {\n        return(-1);\n    } else {\n        return(newchannel);\n    }\n\n}", "path": "wifi-arsenal/asleap/asleap.c", "commit_date": "2015-05-22 00:00:00", "repo_name": "0x90/wifi-arsenal", "stars": 1778, "license": "None", "language": "c", "size": 144205}
{"docstring": "/* addstamac() accepts the array of observed stations, the new station to add,\n   and the current counter position in the array of stations.  addstamac() does\n   not check to see if the entry has been added already, assumes findstamac()\n   has been run to identify if this is a new station or not. \n   This function returns the new value of the current position in the clientlist\n   array. */\n", "func_signal": "int addstamac(struct clientlist_data *clientlist, u8 stamac[6], int clntcntr)", "code": "{\n\n    memcpy(clientlist[clntcntr].stamac, stamac, 6);\n    clntcntr++;\n    if (clntcntr > MAXCLIENTLIST) {\n        /* Clear the stored array.  Everyone is a fresh target\n           again.  This sucks, I know.  Laziness kills. */\n        clntcntr=0;\n        memset(clientlist, 0, sizeof(clientlist));\n    }\n\n    return(clntcntr);\n}", "path": "wifi-arsenal/asleap/asleap.c", "commit_date": "2015-05-22 00:00:00", "repo_name": "0x90/wifi-arsenal", "stars": 1778, "license": "None", "language": "c", "size": 144205}
{"docstring": "/*\n * call-seq:\n *   Curl.idn?                                        => true or false\n *\n * Returns true if the installed libcurl was built with support for IDNA,\n * domain names with international letters. For libcurl versions < 7.12.0,\n * always returns false.\n */\n", "func_signal": "static VALUE ruby_curl_idn_q(VALUE mod)", "code": "{\n#ifdef HAVE_CURL_VERSION_IDN\n  curl_version_info_data *ver = curl_version_info(CURLVERSION_NOW);\n  return((ver->features & CURL_VERSION_IDN) ? Qtrue : Qfalse);\n#else\n  return Qfalse;\n#endif\n}", "path": "curb/ext/curb.c", "commit_date": "2020-11-03 00:00:00", "repo_name": "taf2/curb", "stars": 1283, "license": "other", "language": "c", "size": 1366}
{"docstring": "/*\n * call-seq:\n *   internal class for sending large file uploads\n */\n", "func_signal": "VALUE ruby_curl_upload_new(VALUE klass)", "code": "{\n  VALUE upload;\n  ruby_curl_upload *rbcu = ALLOC(ruby_curl_upload);\n  rbcu->stream = Qnil;\n  rbcu->offset = 0;\n  upload = Data_Wrap_Struct(klass, curl_upload_mark, curl_upload_free, rbcu);\n  return upload;\n}", "path": "curb/ext/curb_upload.c", "commit_date": "2016-04-10 00:00:00", "repo_name": "taf2/curb", "stars": 1283, "license": "other", "language": "c", "size": 1366}
{"docstring": "/*\n * call-seq:\n *   Curl.http2?                                       => true or false\n *\n * Returns true if the installed libcurl was built with support for HTTP2.\n * For libcurl versions < 7.33.0, always returns false.\n */\n", "func_signal": "static VALUE ruby_curl_http2_q(VALUE mod)", "code": "{\n#ifdef HAVE_CURL_VERSION_HTTP2\n  curl_version_info_data *ver = curl_version_info(CURLVERSION_NOW);\n  return((ver->features & CURL_VERSION_HTTP2) ? Qtrue : Qfalse);\n#else\n  return Qfalse;\n#endif\n}", "path": "curb/ext/curb.c", "commit_date": "2020-11-03 00:00:00", "repo_name": "taf2/curb", "stars": 1283, "license": "other", "language": "c", "size": 1366}
{"docstring": "/*\n * call-seq:\n *   Curl.ntlm?                                       => true or false\n *\n * Returns true if the installed libcurl supports HTTP NTLM.\n * For libcurl versions < 7.10.6, always returns false.\n */\n", "func_signal": "static VALUE ruby_curl_ntlm_q(VALUE mod)", "code": "{\n#ifdef HAVE_CURL_VERSION_NTLM\n  curl_version_info_data *ver = curl_version_info(CURLVERSION_NOW);\n  return((ver->features & CURL_VERSION_NTLM) ? Qtrue : Qfalse);\n#else\n  return Qfalse;\n#endif\n}", "path": "curb/ext/curb.c", "commit_date": "2020-11-03 00:00:00", "repo_name": "taf2/curb", "stars": 1283, "license": "other", "language": "c", "size": 1366}
{"docstring": "/* =================== INIT LIB =====================*/\n", "func_signal": "void init_curb_multi()", "code": "{\n  idCall = rb_intern(\"call\");\n  cCurlMulti = rb_define_class_under(mCurl, \"Multi\", rb_cObject);\n\n  /* Class methods */\n  rb_define_singleton_method(cCurlMulti, \"new\", ruby_curl_multi_new, 0);\n  rb_define_singleton_method(cCurlMulti, \"default_timeout=\", ruby_curl_multi_set_default_timeout, 1);\n  rb_define_singleton_method(cCurlMulti, \"default_timeout\", ruby_curl_multi_get_default_timeout, 0);\n  rb_define_singleton_method(cCurlMulti, \"autoclose=\", ruby_curl_multi_set_autoclose, 1);\n  rb_define_singleton_method(cCurlMulti, \"autoclose\", ruby_curl_multi_get_autoclose, 0);\n  /* Instance methods */\n  rb_define_method(cCurlMulti, \"max_connects=\", ruby_curl_multi_max_connects, 1);\n  rb_define_method(cCurlMulti, \"pipeline=\", ruby_curl_multi_pipeline, 1);\n  rb_define_method(cCurlMulti, \"_add\", ruby_curl_multi_add, 1);\n  rb_define_method(cCurlMulti, \"_remove\", ruby_curl_multi_remove, 1);\n  rb_define_method(cCurlMulti, \"perform\", ruby_curl_multi_perform, -1);\n  rb_define_method(cCurlMulti, \"_close\", ruby_curl_multi_close, 0);\n}", "path": "curb/ext/curb_multi.c", "commit_date": "2019-01-28 00:00:00", "repo_name": "taf2/curb", "stars": 1283, "license": "other", "language": "c", "size": 1366}
{"docstring": "/*\n * call-seq:\n *   Curl.sspi?                                       => true or false\n *\n * Returns true if the installed libcurl was built with support for SSPI.\n * This is only available on Windows and makes libcurl use Windows-provided\n * functions for NTLM authentication. It also allows libcurl to use the current\n * user and the current user's password without the app having to pass them on.\n * For libcurl versions < 7.13.2, always returns false.\n */\n", "func_signal": "static VALUE ruby_curl_sspi_q(VALUE mod)", "code": "{\n#ifdef HAVE_CURL_VERSION_SSPI\n  curl_version_info_data *ver = curl_version_info(CURLVERSION_NOW);\n  return((ver->features & CURL_VERSION_SSPI) ? Qtrue : Qfalse);\n#else\n  return Qfalse;\n#endif\n}", "path": "curb/ext/curb.c", "commit_date": "2020-11-03 00:00:00", "repo_name": "taf2/curb", "stars": 1283, "license": "other", "language": "c", "size": 1366}
{"docstring": "/*\n * call-seq:\n *   Curl.ssl?                                        => true or false\n *\n * Returns true if the installed libcurl supports SSL connections.\n * For libcurl versions < 7.10, always returns false.\n */\n", "func_signal": "static VALUE ruby_curl_ssl_q(VALUE mod)", "code": "{\n#ifdef HAVE_CURL_VERSION_SSL\n  curl_version_info_data *ver = curl_version_info(CURLVERSION_NOW);\n  return((ver->features & CURL_VERSION_SSL) ? Qtrue : Qfalse);\n#else\n  return Qfalse;\n#endif\n}", "path": "curb/ext/curb.c", "commit_date": "2020-11-03 00:00:00", "repo_name": "taf2/curb", "stars": 1283, "license": "other", "language": "c", "size": 1366}
{"docstring": "/*\n * call-seq:\n *   Curl::Multi.default_timeout = 4 => 4\n *\n * Set the global default time out for all Curl::Multi Handles.  This value is used\n * when libcurl cannot determine a timeout value when calling curl_multi_timeout.\n *\n */\n", "func_signal": "VALUE ruby_curl_multi_set_default_timeout(VALUE klass, VALUE timeout)", "code": "{\n  cCurlMutiDefaulttimeout = NUM2LONG(timeout);\n  return timeout;\n}", "path": "curb/ext/curb_multi.c", "commit_date": "2019-01-28 00:00:00", "repo_name": "taf2/curb", "stars": 1283, "license": "other", "language": "c", "size": 1366}
{"docstring": "/*\n * call-seq:\n *   Curl.ipv6?                                       => true or false\n *\n * Returns true if the installed libcurl supports IPv6.\n */\n", "func_signal": "static VALUE ruby_curl_ipv6_q(VALUE mod)", "code": "{\n  curl_version_info_data *ver = curl_version_info(CURLVERSION_NOW);\n  return((ver->features & CURL_VERSION_IPV6) ? Qtrue : Qfalse);\n}", "path": "curb/ext/curb.c", "commit_date": "2020-11-03 00:00:00", "repo_name": "taf2/curb", "stars": 1283, "license": "other", "language": "c", "size": 1366}
{"docstring": "/*\n * call-seq:\n *   internal class for sending large file uploads\n */\n", "func_signal": "VALUE ruby_curl_upload_stream_set(VALUE self, VALUE stream)", "code": "{\n  ruby_curl_upload *rbcu;\n  Data_Get_Struct(self, ruby_curl_upload, rbcu);\n  rbcu->stream = stream;\n  return stream;\n}", "path": "curb/ext/curb_upload.c", "commit_date": "2016-04-10 00:00:00", "repo_name": "taf2/curb", "stars": 1283, "license": "other", "language": "c", "size": 1366}
{"docstring": "/*\n * call-seq:\n *   Curl.conv?                                       => true or false\n *\n * Returns true if the installed libcurl was built with support for character\n * conversions. For libcurl versions < 7.15.4, always returns false.\n */\n", "func_signal": "static VALUE ruby_curl_conv_q(VALUE mod)", "code": "{\n#ifdef HAVE_CURL_VERSION_CONV\n  curl_version_info_data *ver = curl_version_info(CURLVERSION_NOW);\n  return((ver->features & CURL_VERSION_CONV) ? Qtrue : Qfalse);\n#else\n  return Qfalse;\n#endif\n}", "path": "curb/ext/curb.c", "commit_date": "2020-11-03 00:00:00", "repo_name": "taf2/curb", "stars": 1283, "license": "other", "language": "c", "size": 1366}
{"docstring": "/*\n * call-seq:\n * multi = Curl::Multi.new\n * easy1 = Curl::Easy.new('url')\n * easy2 = Curl::Easy.new('url')\n *\n * multi.add(easy1)\n * multi.add(easy2)\n *\n * multi.perform do\n *  # while idle other code my execute here\n * end\n *\n * Run multi handles, looping selecting when data can be transfered\n */\n", "func_signal": "VALUE ruby_curl_multi_perform(int argc, VALUE *argv, VALUE self)", "code": "{\n  CURLMcode mcode;\n  ruby_curl_multi *rbcm;\n  int maxfd, rc = -1;\n  fd_set fdread, fdwrite, fdexcep;\n#ifdef _WIN32\n  fd_set crt_fdread, crt_fdwrite, crt_fdexcep;\n#endif\n  long timeout_milliseconds;\n  struct timeval tv = {0, 0};\n  struct timeval tv_100ms = {0, 100000};\n  VALUE block = Qnil;\n#if defined(HAVE_RB_THREAD_BLOCKING_REGION) || defined(HAVE_RB_THREAD_CALL_WITHOUT_GVL)\n  struct _select_set fdset_args;\n#endif\n\n  rb_scan_args(argc, argv, \"0&\", &block);\n\n  Data_Get_Struct(self, ruby_curl_multi, rbcm);\n\n  timeout_milliseconds = cCurlMutiDefaulttimeout;\n\n  // Run curl_multi_perform for the first time to get the ball rolling\n  rb_curl_multi_run( self, rbcm->handle, &(rbcm->running) );\n\n  // Check the easy handles for new messages one more time before yielding\n  // control to passed ruby block.\n  //\n  // This call will block until all queued messages are processed and if any\n  // handle completed the transfer we will run the on_complete callback here too.\n  rb_curl_multi_read_info( self, rbcm->handle );\n\n  // There are no more messages to handle by curl and we can run the ruby block\n  // passed to perform method.\n  // When the block completes curl will resume.\n  if (block != Qnil) {\n    rb_funcall(block, rb_intern(\"call\"), 1, self);\n  }\n\n  do {\n    while (rbcm->running) {\n\n#ifdef HAVE_CURL_MULTI_TIMEOUT\n      /* get the curl suggested time out */\n      mcode = curl_multi_timeout(rbcm->handle, &timeout_milliseconds);\n      if (mcode != CURLM_OK) {\n        raise_curl_multi_error_exception(mcode);\n      }\n#else\n      /* libcurl doesn't have a timeout method defined, initialize to -1 we'll pick up the default later */\n      timeout_milliseconds = -1;\n#endif\n\n      if (timeout_milliseconds == 0) { /* no delay */\n        rb_curl_multi_run( self, rbcm->handle, &(rbcm->running) );\n        rb_curl_multi_read_info( self, rbcm->handle );\n        if (block != Qnil) { rb_funcall(block, rb_intern(\"call\"), 1, self);  }\n        continue;\n      }\n\n      if (timeout_milliseconds < 0 || timeout_milliseconds > cCurlMutiDefaulttimeout) {\n        timeout_milliseconds = cCurlMutiDefaulttimeout; /* libcurl doesn't know how long to wait, use a default timeout */\n                                                        /* or buggy versions libcurl sometimes reports huge timeouts... let's cap it */\n      }\n\n      tv.tv_sec  = 0; /* never wait longer than 1 second */\n      tv.tv_usec = (int)(timeout_milliseconds * 1000); /* XXX: int is the right type for OSX, what about linux? */\n\n      FD_ZERO(&fdread);\n      FD_ZERO(&fdwrite);\n      FD_ZERO(&fdexcep);\n\n      /* load the fd sets from the multi handle */\n      mcode = curl_multi_fdset(rbcm->handle, &fdread, &fdwrite, &fdexcep, &maxfd);\n      if (mcode != CURLM_OK) {\n        raise_curl_multi_error_exception(mcode);\n      }\n\n      if (maxfd == -1) {\n        /* libcurl recommends sleeping for 100ms */\n        rb_thread_wait_for(tv_100ms);\n        rb_curl_multi_run( self, rbcm->handle, &(rbcm->running) );\n        rb_curl_multi_read_info( self, rbcm->handle );\n        if (block != Qnil) { rb_funcall(block, rb_intern(\"call\"), 1, self);  }\n        continue;\n      }\n\n#ifdef _WIN32\n      create_crt_fd(&fdread, &crt_fdread);\n      create_crt_fd(&fdwrite, &crt_fdwrite);\n      create_crt_fd(&fdexcep, &crt_fdexcep);\n#endif\n\n\n#if (defined(HAVE_RB_THREAD_BLOCKING_REGION) || defined(HAVE_RB_THREAD_CALL_WITHOUT_GVL))\n      fdset_args.maxfd = maxfd+1;\n      fdset_args.fdread = &fdread;\n      fdset_args.fdwrite = &fdwrite;\n      fdset_args.fdexcep = &fdexcep;\n      fdset_args.tv = &tv;\n#endif\n\n#ifdef HAVE_RB_THREAD_CALL_WITHOUT_GVL\n      rc = (int)(VALUE) rb_thread_call_without_gvl((void *(*)(void *))curb_select, &fdset_args, RUBY_UBF_IO, 0);\n#elif HAVE_RB_THREAD_BLOCKING_REGION\n      rc = rb_thread_blocking_region(curb_select, &fdset_args, RUBY_UBF_IO, 0);\n#elif HAVE_RB_THREAD_FD_SELECT\n      rc = rb_thread_fd_select(maxfd+1, &fdread, &fdwrite, &fdexcep, &tv);\n#else\n      rc = rb_thread_select(maxfd+1, &fdread, &fdwrite, &fdexcep, &tv);\n#endif\n\n#ifdef _WIN32\n      cleanup_crt_fd(&fdread, &crt_fdread);\n      cleanup_crt_fd(&fdwrite, &crt_fdwrite);\n      cleanup_crt_fd(&fdexcep, &crt_fdexcep);\n#endif\n\n      switch(rc) {\n      case -1:\n        if(errno != EINTR) {\n          rb_raise(rb_eRuntimeError, \"select(): %s\", strerror(errno));\n          break;\n        }\n      case 0: /* timeout */\n      default: /* action */\n        rb_curl_multi_run( self, rbcm->handle, &(rbcm->running) );\n        rb_curl_multi_read_info( self, rbcm->handle );\n        if (block != Qnil) { rb_funcall(block, rb_intern(\"call\"), 1, self);  }\n        break;\n      }\n    }\n\n  } while( rbcm->running );\n\n  rb_curl_multi_read_info( self, rbcm->handle );\n  if (block != Qnil) { rb_funcall(block, rb_intern(\"call\"), 1, self);  }\n  if (cCurlMutiAutoClose  == 1) {\n    rb_funcall(self, rb_intern(\"close\"), 0);\n  }\n  return Qtrue;\n}", "path": "curb/ext/curb_multi.c", "commit_date": "2019-01-28 00:00:00", "repo_name": "taf2/curb", "stars": 1283, "license": "other", "language": "c", "size": 1366}
{"docstring": "/*\n * call-seq:\n *   Curl::Multi.new                                   => #&lt;Curl::Easy...&gt;\n *\n * Create a new Curl::Multi instance\n */\n", "func_signal": "VALUE ruby_curl_multi_new(VALUE klass)", "code": "{\n  ruby_curl_multi *rbcm = ALLOC(ruby_curl_multi);\n\n  ruby_curl_multi_init(rbcm);\n\n  /*\n   * The mark routine will be called by the garbage collector during its ``mark'' phase.\n   * If your structure references other Ruby objects, then your mark function needs to\n   * identify these objects using rb_gc_mark(value). If the structure doesn't reference\n   * other Ruby objects, you can simply pass 0 as a function pointer.\n  */\n  return Data_Wrap_Struct(klass, 0, curl_multi_free, rbcm);\n}", "path": "curb/ext/curb_multi.c", "commit_date": "2019-01-28 00:00:00", "repo_name": "taf2/curb", "stars": 1283, "license": "other", "language": "c", "size": 1366}
{"docstring": "/*\n * call-seq:\n *   internal class for sending large file uploads\n */\n", "func_signal": "VALUE ruby_curl_upload_stream_get(VALUE self)", "code": "{\n  ruby_curl_upload *rbcu;\n  Data_Get_Struct(self, ruby_curl_upload, rbcu);\n  return rbcu->stream;\n}", "path": "curb/ext/curb_upload.c", "commit_date": "2016-04-10 00:00:00", "repo_name": "taf2/curb", "stars": 1283, "license": "other", "language": "c", "size": 1366}
{"docstring": "/*\n * call-seq:\n * multi = Curl::Multi.new\n * multi.pipeline = true\n *\n * Pass a long set to 1 for HTTP/1.1 pipelining, 2 for HTTP/2 multiplexing, or 0 to disable.\n *  Enabling pipelining on a multi handle will make it attempt to perform HTTP Pipelining as \n * far as possible for transfers using this handle. This means that if you add a second request \n * that can use an already existing connection, the second request will be \"piped\" on the same\n * connection rather than being executed in parallel. (Added in 7.16.0, multiplex added in 7.43.0)\n *\n */\n", "func_signal": "static VALUE ruby_curl_multi_pipeline(VALUE self, VALUE method)", "code": "{\n#ifdef HAVE_CURLMOPT_PIPELINING\n  ruby_curl_multi *rbcm;\n\n  long value;\n\n  if (method == Qtrue) {\n    value = 1;\n  } else if (method == Qfalse) {\n    value  = 0;\n  } else {\n    value = NUM2LONG(method);\n  } \n\n  Data_Get_Struct(self, ruby_curl_multi, rbcm);\n  curl_multi_setopt(rbcm->handle, CURLMOPT_PIPELINING, value);\n#endif\n  return method == Qtrue ? 1 : 0;\n}", "path": "curb/ext/curb_multi.c", "commit_date": "2019-01-28 00:00:00", "repo_name": "taf2/curb", "stars": 1283, "license": "other", "language": "c", "size": 1366}
{"docstring": "/*\n * call-seq:\n *   Curl.debug?                                      => true or false\n *\n * Returns true if the installed libcurl was built with extra debug\n * capabilities built-in. For libcurl versions < 7.10.6, always returns\n * false.\n */\n", "func_signal": "static VALUE ruby_curl_debug_q(VALUE mod)", "code": "{\n#ifdef HAVE_CURL_VERSION_DEBUG\n  curl_version_info_data *ver = curl_version_info(CURLVERSION_NOW);\n  return((ver->features & CURL_VERSION_DEBUG) ? Qtrue : Qfalse);\n#else\n  return Qfalse;\n#endif\n}", "path": "curb/ext/curb.c", "commit_date": "2020-11-03 00:00:00", "repo_name": "taf2/curb", "stars": 1283, "license": "other", "language": "c", "size": 1366}
{"docstring": "/*\n * call-seq:\n *   Curl.spnego?                                     => true or false\n *\n * Returns true if the installed libcurl was built with support for SPNEGO\n * authentication (Simple and Protected GSS-API Negotiation Mechanism, defined\n * in RFC 2478). For libcurl versions < 7.10.8, always returns false.\n */\n", "func_signal": "static VALUE ruby_curl_spnego_q(VALUE mod)", "code": "{\n#ifdef HAVE_CURL_VERSION_SPNEGO\n  curl_version_info_data *ver = curl_version_info(CURLVERSION_NOW);\n  return((ver->features & CURL_VERSION_SPNEGO) ? Qtrue : Qfalse);\n#else\n  return Qfalse;\n#endif\n}", "path": "curb/ext/curb.c", "commit_date": "2020-11-03 00:00:00", "repo_name": "taf2/curb", "stars": 1283, "license": "other", "language": "c", "size": 1366}
{"docstring": "/*\n * call-seq:\n *   Curl.libz?                                       => true or false\n *\n * Returns true if the installed libcurl supports HTTP deflate\n * using libz. For libcurl versions < 7.10, always returns false.\n */\n", "func_signal": "static VALUE ruby_curl_libz_q(VALUE mod)", "code": "{\n#ifdef HAVE_CURL_VERSION_LIBZ\n  curl_version_info_data *ver = curl_version_info(CURLVERSION_NOW);\n  return((ver->features & CURL_VERSION_LIBZ) ? Qtrue : Qfalse);\n#else\n  return Qfalse;\n#endif\n}", "path": "curb/ext/curb.c", "commit_date": "2020-11-03 00:00:00", "repo_name": "taf2/curb", "stars": 1283, "license": "other", "language": "c", "size": 1366}
{"docstring": "/*\n * call-seq:\n *   multi.requests                                   => [#&lt;Curl::Easy...&gt;, ...]\n * \n * Returns an array containing all the active requests on this Curl::Multi object.\n */\n/*\n * call-seq:\n * multi = Curl::Multi.new\n * multi.max_connects = 800\n *\n * Set the max connections in the cache for a multi handle\n */\n", "func_signal": "static VALUE ruby_curl_multi_max_connects(VALUE self, VALUE count)", "code": "{\n#ifdef HAVE_CURLMOPT_MAXCONNECTS\n  ruby_curl_multi *rbcm;\n\n  Data_Get_Struct(self, ruby_curl_multi, rbcm);\n\n  curl_multi_setopt(rbcm->handle, CURLMOPT_MAXCONNECTS, NUM2LONG(count));\n#endif\n\n  return count;\n}", "path": "curb/ext/curb_multi.c", "commit_date": "2019-01-28 00:00:00", "repo_name": "taf2/curb", "stars": 1283, "license": "other", "language": "c", "size": 1366}
{"docstring": "/*\n * call-seq:\n *   Curl.gssnegotiate?                               => true or false\n *\n * Returns true if the installed libcurl supports HTTP GSS-Negotiate.\n * For libcurl versions < 7.10.6, always returns false.\n */\n", "func_signal": "static VALUE ruby_curl_gssnegotiate_q(VALUE mod)", "code": "{\n#ifdef HAVE_CURL_VERSION_GSSNEGOTIATE\n  curl_version_info_data *ver = curl_version_info(CURLVERSION_NOW);\n  return((ver->features & CURL_VERSION_GSSNEGOTIATE) ? Qtrue : Qfalse);\n#else\n  return Qfalse;\n#endif\n}", "path": "curb/ext/curb.c", "commit_date": "2020-11-03 00:00:00", "repo_name": "taf2/curb", "stars": 1283, "license": "other", "language": "c", "size": 1366}
{"docstring": "/* $begin eval */\n/* eval - Evaluate a command line */\n", "func_signal": "void eval(char *cmdline)", "code": "{\n    char *argv[MAXARGS]; /* Argument list execve() */\n    char buf[MAXLINE];   /* Holds modified command line */\n    int bg;              /* Should the job run in bg or fg? */\n    pid_t pid;           /* Process id */\n    \n    strcpy(buf, cmdline);\n    bg = parseline(buf, argv); \n    if (argv[0] == NULL)  \n\treturn;   /* Ignore empty lines */\n\n    if (!builtin_command(argv)) { \n        if ((pid = Fork()) == 0) {   /* Child runs user job */\n            if (execve(argv[0], argv, environ) < 0) {\n                printf(\"%s: Command not found.\\n\", argv[0]);\n                exit(0);\n            }\n        }\n\n\t/* Parent waits for foreground job to terminate */\n\tif (!bg) {\n\t    int status;\n\t    if (waitpid(pid, &status, 0) < 0)\n\t\tunix_error(\"waitfg: waitpid error\");\n\t}\n\telse\n\t    printf(\"%d %s\", pid, cmdline);\n    }\n    return;\n}", "path": "csapp/_codes/code/ecf/shellex.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "Hansimov/csapp", "stars": 1251, "license": "None", "language": "c", "size": 62235}
{"docstring": "/* $begin static */\n", "func_signal": "int f()", "code": "{\n    static int x = 0;\n    return x;\n}", "path": "csapp/_codes/code/link/static.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "Hansimov/csapp", "stars": 1251, "license": "None", "language": "c", "size": 62235}
{"docstring": "/* $begin dotprod */\n", "func_signal": "float dotprod(float x[8], float y[8])", "code": "{\n    float sum = 0.0;\n    int i;\n\n    for (i = 0; i < 8; i++)\n\tsum += x[i] * y[i];\n    return sum;\n}", "path": "csapp/_codes/code/mem/dotprod.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "Hansimov/csapp", "stars": 1251, "license": "None", "language": "c", "size": 62235}
{"docstring": "/* Variable stack frame incurred by alloca call */\n", "func_signal": "void print_revn_aa(char *s, size_t n)", "code": "{\n    char *buf = alloca(n+1);\n    size_t i;\n    for (i = 0; i < n; i++)\n\tbuf[n-i] = s[i];\n    /* Add terminating null character */\n    buf[n] = '\\0';\n    print_str(buf);\n}", "path": "csapp/_codes/code/asm/framepointer.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "Hansimov/csapp", "stars": 1251, "license": "None", "language": "c", "size": 62235}
{"docstring": "/* $begin forkprob8 */\n", "func_signal": "void foo(int n)", "code": "{\n    int i;\n\n    for (i = 0; i < n; i++) \n\tFork();\n    printf(\"hello\\n\");\n    exit(0);\n}", "path": "csapp/_codes/code/ecf/forkprob8.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "Hansimov/csapp", "stars": 1251, "license": "None", "language": "c", "size": 62235}
{"docstring": "/* $begin simd_eg */\n/* Compute inner product of SSE vector */\n", "func_signal": "data_t innerv(vec_t av, vec_t bv)", "code": "{\n    long int i;\n    vec_t pv = av * bv; //line:opt:simd_eg:mult\n    data_t result = 0;\n    for (i = 0; i < VSIZE; i++)\n\tresult += pv[i]; //line:opt:simd_eg:access\n    return result; \n}", "path": "csapp/_codes/code/opt/simd_eg.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "Hansimov/csapp", "stars": 1251, "license": "None", "language": "c", "size": 62235}
{"docstring": "/* Dynamic arrays */\n/* Variable stack frame incurred by alloca call */\n", "func_signal": "void print_revn_da(char *s, size_t n)", "code": "{\n    char buf[n+1];\n    size_t i;\n    for (i = 0; i < n; i++)\n\tbuf[n-i] = s[i];\n    /* Add terminating null character */\n    buf[n] = '\\0';\n    print_str(buf);\n}", "path": "csapp/_codes/code/asm/framepointer.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "Hansimov/csapp", "stars": 1251, "license": "None", "language": "c", "size": 62235}
{"docstring": "/* $begin parseline */\n/* parseline - Parse the command line and build the argv array */\n", "func_signal": "int parseline(char *buf, char **argv)", "code": "{\n    char *delim;         /* Points to first space delimiter */\n    int argc;            /* Number of args */\n    int bg;              /* Background job? */\n\n    buf[strlen(buf)-1] = ' ';  /* Replace trailing '\\n' with space */\n    while (*buf && (*buf == ' ')) /* Ignore leading spaces */\n\tbuf++;\n\n    /* Build the argv list */\n    argc = 0;\n    while ((delim = strchr(buf, ' '))) {\n\targv[argc++] = buf;\n\t*delim = '\\0';\n\tbuf = delim + 1;\n\twhile (*buf && (*buf == ' ')) /* Ignore spaces */\n            buf++;\n    }\n    argv[argc] = NULL;\n    \n    if (argc == 0)  /* Ignore blank line */\n\treturn 1;\n\n    /* Should the job run in the background? */\n    if ((bg = (*argv[argc-1] == '&')) != 0)\n\targv[--argc] = NULL;\n\n    return bg;\n}", "path": "csapp/_codes/code/ecf/shellex.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "Hansimov/csapp", "stars": 1251, "license": "None", "language": "c", "size": 62235}
{"docstring": "//line:conc:sharing:ptrdec\n", "func_signal": "int main()", "code": "{\n    int i;  \n    pthread_t tid;\n    char *msgs[N] = {\n\t\"Hello from foo\",  \n\t\"Hello from bar\"   \n    };\n\n    ptr = msgs; \n    for (i = 0; i < N; i++)  \n        Pthread_create(&tid, NULL, thread, (void *)i); \n    Pthread_exit(NULL); \n}", "path": "csapp/_codes/code/conc/sharing.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "Hansimov/csapp", "stars": 1251, "license": "None", "language": "c", "size": 62235}
{"docstring": "/* $end opt-aprod-c */\n", "func_signal": "double aprod1(double a[], long n)", "code": "{\n    long i;\n    double x, y, z;\n    double r = 1;\n    for (i = 0; i < n; i+= 3) {\n\tx = a[i]; y = a[i+1]; z = a[i+2];\n\t/* $begin opt-assoc-c */\n\tr = ((r * x) * y) * z; /* A1 */\n\t/* $end opt-assoc-c */\n    }\n    for (; i < n; i++)\n\tr *= a[i];\n    return r;\n}", "path": "csapp/_codes/code/opt/opt-meas.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "Hansimov/csapp", "stars": 1251, "license": "None", "language": "c", "size": 62235}
{"docstring": "/* Variable stack frame incurred by alloca call */\n", "func_signal": "void print_rev_aa(char *s)", "code": "{\n    size_t len = strlen(s);\n    char *buf = alloca(len+1);\n    size_t i;\n    for (i = 0; i < len; i++)\n\tbuf[len-i] = s[i];\n    /* Add terminating null character */\n    buf[len] = '\\0';\n    print_str(buf);\n}", "path": "csapp/_codes/code/asm/framepointer.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "Hansimov/csapp", "stars": 1251, "license": "None", "language": "c", "size": 62235}
{"docstring": "/* Perform test of combination function */\n", "func_signal": "static void run_test(int bench_index, int cnt)", "code": "{\n    double cyc;\n    char *description = benchmarks[bench_index].description;\n    data_t good_result;\n    current_benchmark = bench_index;\n    setup(cnt);\n    cyc = fcyc(run, NULL);\n    benchmarks[bench_index].cfunct(data, &combine_result);\n    benchmarks[bench_index].checkfunct(data, &good_result);\n    if (combine_result != good_result) {\n\tprintf(\"Function %s, Should be %d, Got %d\\n\",\n\t       description, (int) good_result, (int) combine_result);\n    }\n    /* print results */\n    /* Column Heading */\n    printf(\"%s %s %s:\\n\", DATA_NAME, OP_NAME, description);\n    printf(\"%.1f cycles, Net: %.2f cycles/element\\n\", cyc, cyc/cnt);\n}", "path": "csapp/_codes/code/opt/benchmark-ncpe.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "Hansimov/csapp", "stars": 1251, "license": "None", "language": "c", "size": 62235}
{"docstring": "/* If first arg is a builtin command, run it and return true */\n", "func_signal": "int builtin_command(char **argv)", "code": "{\n    if (!strcmp(argv[0], \"quit\")) /* quit command */\n\texit(0);  \n    if (!strcmp(argv[0], \"&\"))    /* Ignore singleton & */\n\treturn 1;\n    return 0;                     /* Not a builtin command */\n}", "path": "csapp/_codes/code/ecf/shellex.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "Hansimov/csapp", "stars": 1251, "license": "None", "language": "c", "size": 62235}
{"docstring": "/* Dynamic arrays */\n/* Variable stack frame incurred by alloca call */\n", "func_signal": "void print_rev_da(char *s)", "code": "{\n    size_t len = strlen(s);\n    char buf[len+1];\n    size_t i;\n    for (i = 0; i < len; i++)\n\tbuf[len-i] = s[i];\n    /* Add terminating null character */\n    buf[len] = '\\0';\n    print_str(buf);\n}", "path": "csapp/_codes/code/asm/framepointer.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "Hansimov/csapp", "stars": 1251, "license": "None", "language": "c", "size": 62235}
{"docstring": "/* $begin 300-swapadd-c */\n", "func_signal": "long swap_add(long *xp, long *yp)", "code": "{ \n    long x = *xp; \n    long y = *yp; \n    *xp = y; \n    *yp = x; \n    return x + y; \n}", "path": "csapp/_codes/code/asm/300-swapadd.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "Hansimov/csapp", "stars": 1251, "license": "None", "language": "c", "size": 62235}
{"docstring": "/*\n * fsecs - Return the running time of a function f (in seconds)\n */\n", "func_signal": "double fsecs(fsecs_test_funct f, void *argp)", "code": "{\n#if USE_FCYC\n    double cycles = fcyc(f, argp);\n    return cycles/(Mhz*1e6);\n#elif USE_ITIMER\n    return ftimer_itimer(f, argp, 10);\n#elif USE_GETTOD\n    return ftimer_gettod(f, argp, 10);\n#endif \n}", "path": "csapp/_codes/code/vm/malloc/fsecs.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "Hansimov/csapp", "stars": 1251, "license": "None", "language": "c", "size": 62235}
{"docstring": "/* $begin opt-aprod-c */\n", "func_signal": "double aprod(double a[], long n)", "code": "{\n    long i;\n    double x, y, z;\n    double r = 1;\n    for (i = 0; i < n-2; i+= 3) {\n\tx = a[i]; y = a[i+1]; z = a[i+2];\n\tr = r * x * y * z; /* Product computation */\n    }\n    for (; i < n; i++)\n\tr *= a[i];\n    return r;\n}", "path": "csapp/_codes/code/opt/opt-meas.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "Hansimov/csapp", "stars": 1251, "license": "None", "language": "c", "size": 62235}
{"docstring": "/* $end forkprob8 */\n", "func_signal": "int main(int argc, char **argv)", "code": "{\n    if  (argc < 2) {\n\tprintf(\"usage: %s <n>\\n\", argv[0]);\n\texit(0);\n    }\n    foo(atoi(argv[1]));\n    exit(0);\n}", "path": "csapp/_codes/code/ecf/forkprob8.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "Hansimov/csapp", "stars": 1251, "license": "None", "language": "c", "size": 62235}
{"docstring": "/*\n * init_fsecs - initialize the timing package\n */\n", "func_signal": "void init_fsecs(void)", "code": "{\n    Mhz = 0; /* keep gcc -Wall happy */\n\n#if USE_FCYC\n    if (verbose)\n\tprintf(\"Measuring performance with a cycle counter.\\n\");\n\n    /* set key parameters for the fcyc package */\n    set_fcyc_maxsamples(20); \n    set_fcyc_clear_cache(1);\n    set_fcyc_compensate(1);\n    set_fcyc_epsilon(0.01);\n    set_fcyc_k(3);\n    Mhz = mhz(verbose > 0);\n#elif USE_ITIMER\n    if (verbose)\n\tprintf(\"Measuring performance with the interval timer.\\n\");\n#elif USE_GETTOD\n    if (verbose)\n\tprintf(\"Measuring performance with gettimeofday().\\n\");\n#endif\n}", "path": "csapp/_codes/code/vm/malloc/fsecs.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "Hansimov/csapp", "stars": 1251, "license": "None", "language": "c", "size": 62235}
{"docstring": "/* $begin procmask1 */\n/* WARNING: This code is buggy! */\n", "func_signal": "void handler(int sig)", "code": "{\n    int olderrno = errno;\n    sigset_t mask_all, prev_all;\n    pid_t pid;\n\n    Sigfillset(&mask_all);\n    while ((pid = waitpid(-1, NULL, 0)) > 0) { /* Reap a zombie child */\n        Sigprocmask(SIG_BLOCK, &mask_all, &prev_all);\n        deletejob(pid); /* Delete the child from the job list */\n        Sigprocmask(SIG_SETMASK, &prev_all, NULL);\n    }\n    if (errno != ECHILD)\n        Sio_error(\"waitpid error\");\n    errno = olderrno;\n}", "path": "csapp/_codes/code/ecf/procmask1.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "Hansimov/csapp", "stars": 1251, "license": "None", "language": "c", "size": 62235}
{"docstring": "/**\n * ntfs_inode_sync_standard_information - update standard information attribute\n * @ni:\t\tntfs inode to update standard information\n *\n * Return 0 on success or -1 on error with errno set to the error code.\n */\n", "func_signal": "static int ntfs_inode_sync_standard_information(ntfs_inode *ni)", "code": "{\n\tntfs_attr_search_ctx *ctx;\n\tSTANDARD_INFORMATION *std_info;\n\tint err;\n\n\tntfs_log_trace(\"Entering for inode 0x%llx.\\n\", (LONG64) ni->mft_no);\n\n\tctx = ntfs_attr_get_search_ctx(ni, NULL);\n\tif (!ctx)\n\t\treturn -1;\n\tif (ntfs_attr_lookup(AT_STANDARD_INFORMATION, AT_UNNAMED,\n\t\t\t\t0, CASE_SENSITIVE, 0, NULL, 0, ctx)) {\n\t\terr = errno;\n\t\tntfs_log_trace(\"Failed to receive STANDARD_INFORMATION \"\n\t\t\t\t\"attribute.\\n\");\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\terrno = err;\n\t\treturn -1;\n\t}\n\tstd_info = (STANDARD_INFORMATION *)((u8 *)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->X.value_offset));\n\tstd_info->file_attributes = ni->flags;\n\tstd_info->creation_time = utc2ntfs(ni->creation_time);\n\tstd_info->last_data_change_time = utc2ntfs(ni->last_data_change_time);\n\tstd_info->last_mft_change_time = utc2ntfs(ni->last_mft_change_time);\n\tstd_info->last_access_time = utc2ntfs(ni->last_access_time);\n\tntfs_inode_mark_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\treturn 0;\n}", "path": "antispy/src/Antispy/SpyHunter/SpyHunter/ntfs/inode.c", "commit_date": "2019-11-09 00:00:00", "repo_name": "mohuihui/antispy", "stars": 1067, "license": "other", "language": "c", "size": 4006}
{"docstring": "/**\n * ntfs_inode_sync - write the inode (and its dirty extents) to disk\n * @ni:\t\tntfs inode to write\n *\n * Write the inode @ni to disk as well as its dirty extent inodes if such\n * exist and @ni is a base inode. If @ni is an extent inode, only @ni is\n * written completely disregarding its base inode and any other extent inodes.\n *\n * For a base inode with dirty extent inodes if any writes fail for whatever\n * reason, the failing inode is skipped and the sync process is continued. At\n * the end the error condition that brought about the failure is returned. Thus\n * the smallest amount of data loss possible occurs.\n *\n * Return 0 on success or -1 on error with errno set to the error code.\n * The following error codes are defined:\n *\tEINVAL\t- Invalid arguments were passed to the function.\n *\tEBUSY\t- Inode and/or one of its extents is busy, try again later.\n *\tEIO\t- I/O error while writing the inode (or one of its extents).\n */\n", "func_signal": "int ntfs_inode_sync(ntfs_inode *ni)", "code": "{\n\tint err = 0;\n\n\tif (!ni) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tntfs_log_trace(\"Entering for inode 0x%llx.\\n\", (LONG64) ni->mft_no);\n\n\t/* Update STANDARD_INFORMATION. */\n\tif ((ni->mrec->flags & MFT_RECORD_IN_USE) && ni->nr_extents != -1 &&\n\t\t\tntfs_inode_sync_standard_information(ni)) {\n\t\tif (!err || errno == EIO) {\n\t\t\terr = errno;\n\t\t\tif (err != EIO)\n\t\t\t\terr = EBUSY;\n\t\t}\n\t\tntfs_log_trace(\"Failed to sync standard information.\\n\");\n\t}\n\n\t/* Update FILE_NAME's in the index. */\n\tif ((ni->mrec->flags & MFT_RECORD_IN_USE)\n\t\t&& (ni->nr_extents != -1) \n\t\t&& /*(NInoFileNameTestAndClearDirty(ni))*/NInoFileNameTestAndClearDirty_func(ni) \n\t\t&& ntfs_inode_sync_file_name(ni)\n\t   ) \n\t{\n\t\tif (!err || errno == EIO) {\n\t\t\terr = errno;\n\t\t\tif (err != EIO)\n\t\t\t\terr = EBUSY;\n\t\t}\n\n\t\tntfs_log_trace(\"Failed to sync FILE_NAME attributes.\\n\");\n\t\tNInoFileNameSetDirty(ni);\n\t}\n\n\t/* Write out attribute list from cache to disk. */\n\tif ((ni->mrec->flags & MFT_RECORD_IN_USE) \n\t\t&& ni->nr_extents != -1 \n\t\t&& NInoAttrList(ni) \n\t\t&& /*NInoAttrListTestAndClearDirty(ni)*/ NInoAttrListTestAndClearDirty_func(ni)\n\t   ) \n\t{\n\t\tntfs_attr *na;\n\n\t\tna = ntfs_attr_open(ni, AT_ATTRIBUTE_LIST, AT_UNNAMED, 0);\n\t\tif (!na) \n\t\t{\n\t\t\tif (!err || errno == EIO) \n\t\t\t{\n\t\t\t\terr = errno;\n\t\t\t\tif (err != EIO)\n\t\t\t\t\terr = EBUSY;\n\t\t\t\tntfs_log_trace(\"Attribute list sync failed (open failed).\\n\");\n\t\t\t}\n\n\t\t\tNInoAttrListSetDirty(ni);\n\n\t\t} else \n\t\t{\n\t\t\tif (na->data_size == ni->attr_list_size)\n\t\t\t{\n\t\t\t\tif (ntfs_attr_pwrite(na, 0, ni->attr_list_size,\n\t\t\t\t\t\t\tni->attr_list) !=\n\t\t\t\t\t\t\tni->attr_list_size)\n\t\t\t\t{\n\t\t\t\t\tif (!err || errno == EIO) \n\t\t\t\t\t{\n\t\t\t\t\t\terr = errno;\n\t\t\t\t\t\tif (err != EIO) { err = EBUSY; }\n\t\t\t\t\t\tntfs_log_trace(\"Attribute list sync failed (write failed).\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tNInoAttrListSetDirty(ni);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terr = EIO;\n\t\t\t\tntfs_log_trace(\"Attribute list sync failed (invalid size).\\n\");\n\t\t\t\tNInoAttrListSetDirty(ni);\n\t\t\t}\n\t\t\tntfs_attr_close(na);\n\t\t}\n\t}\n\n\t/* Write this inode out to the $MFT (and $MFTMirr if applicable). */\n//\tif ( NInoTestAndClearDirty(ni) ) \n\tif ( NInoTestAndClearDirty_func(ni) ) \n\t{\n\t\tif (ntfs_mft_record_write(ni->vol, ni->mft_no, ni->mrec)) \n\t\t{\n\t\t\tif (!err || errno == EIO) {\n\t\t\t\terr = errno;\n\t\t\t\tif (err != EIO)\n\t\t\t\t\terr = EBUSY;\n\t\t\t}\n\n\t\t\tNInoSetDirty(ni);\n\t\t\tntfs_log_trace(\"Base MFT record sync failed.\\n\");\n\t\t}\n\t}\n\n\t/* If this is a base inode with extents write all dirty extents, too. */\n\tif (ni->nr_extents > 0) \n\t{\n\t\ts32 i;\n\n\t\tfor (i = 0; i < ni->nr_extents; ++i) \n\t\t{\n\t\t\tntfs_inode *eni;\n\n\t\t\teni = ni->extent_nis[i];\n\t\t//\tif ( NInoTestAndClearDirty(eni) ) \n\t\t\tif ( NInoTestAndClearDirty_func(eni) )\n\t\t\t{\n\t\t\t\tif (ntfs_mft_record_write(eni->vol, eni->mft_no, eni->mrec)) \n\t\t\t\t{\n\t\t\t\t\tif (!err || errno == EIO) {\n\t\t\t\t\t\terr = errno;\n\t\t\t\t\t\tif (err != EIO)\n\t\t\t\t\t\t\terr = EBUSY;\n\t\t\t\t\t}\n\n\t\t\t\t\tNInoSetDirty(eni);\n\t\t\t\t\tntfs_log_trace(\"Extent MFT record sync failed.\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!err) { return 0;}\n\terrno = err;\n\treturn -1;\n}", "path": "antispy/src/Antispy/SpyHunter/SpyHunter/ntfs/inode.c", "commit_date": "2019-11-09 00:00:00", "repo_name": "mohuihui/antispy", "stars": 1067, "license": "other", "language": "c", "size": 4006}
{"docstring": "/**\n * ntfs_inode_badclus_bad - check for $Badclus:$Bad data attribute\n * @mft_no:\t\tmft record number where @attr is present\n * @attr:\t\tattribute record used to check for the $Bad attribute\n *\n * Check if the mft record given by @mft_no and @attr contains the bad sector\n * list. Please note that mft record numbers describing $Badclus extent inodes\n * will not match the current $Badclus:$Bad check.\n * \n * On success return 1 if the file is $Badclus:$Bad, otherwise return 0.\n * On error return -1 with errno set to the error code.\n */\n", "func_signal": "int ntfs_inode_badclus_bad(u64 mft_no, ATTR_RECORD *attr)", "code": "{\n\tint len, ret = 0;\n\tntfschar *ustr;\n\n\tif (!attr) {\n\t\tntfs_log_error(\"Invalid argument.\\n\");\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\t\n\tif (mft_no != FILE_BadClus)\n\t       \treturn 0;\n\n\tif (attr->type != AT_DATA)\n\t       \treturn 0;\n\n\tif ((ustr = ntfs_str2ucs(\"$Bad\", &len)) == NULL) {\n\t\tntfs_log_perror(\"Couldn't convert '$Bad' to Unicode\");\n\t\treturn -1;\n\t}\n\n\tif (ustr && ntfs_names_are_equal(ustr, len,\n\t\t\t(ntfschar *)((u8 *)attr + le16_to_cpu(attr->name_offset)),\n\t\t\tattr->name_length, 0, NULL, 0))\n\t\tret = 1;\n\n\tntfs_ucsfree(ustr);\n\n\treturn ret;\n}", "path": "antispy/src/Antispy/SpyHunter/SpyHunter/ntfs/inode.c", "commit_date": "2019-11-09 00:00:00", "repo_name": "mohuihui/antispy", "stars": 1067, "license": "other", "language": "c", "size": 4006}
{"docstring": "// Fetch instruction\n", "func_signal": "int get_instruction(PINSTRUCTION inst, BYTE *addr, enum Mode mode)", "code": "{\n\tPINST ptr;\n\tint index = 0;\n\tint flags = 0;\n\tconst char *ext = NULL;\n\n\tmemset(inst, 0, sizeof(INSTRUCTION));\n\n\t// Parse flags, skip prefixes etc.\n\tget_real_instruction(addr, &index, &flags);\n\n\t// Select instruction table \n\n\t// FPU opcodes\n\tif (MASK_EXT(flags) == EXT_CP) {\n\t\tif (*(addr + index) < 0xc0) {\n\t\t\t// MODRM byte adds the additional byte\n\t\t\tindex--;\n\t\t\tinst->fpuindex = *(addr + index) - 0xd8;\n\t\t\tinst->opcode   = *(addr + index + 1);\n\t\t\tptr = &inst_table4[inst->fpuindex]\n\t\t\t\t[MASK_MODRM_REG(inst->opcode)];\n\t\t} else {\n\t\t\tinst->fpuindex = *(addr + index - 1) - 0xd8;\n\t\t\tinst->opcode   = *(addr + index);\n\t\t\tptr = &inst_table4[inst->fpuindex]\n\t\t\t\t[inst->opcode - 0xb8];\n\t\t}\n\n\t// 2 or 3-byte opcodes\n\t} else if (MASK_EXT(flags) == EXT_T2) {\n\t\tinst->opcode = *(addr + index);\n\t\tget_real_instruction2(addr + index, &flags);\n\n\t\t// 3-byte opcode tables\n\n\t\t// prefix 0x66\n\t\tif (MASK_PREFIX_OPERAND(flags) == 1) {\n\t\t\tptr = &inst_table3_66[inst->opcode];\n\n\t\t// prefix 0xf2\n\t\t} else if (MASK_PREFIX_G1(flags) == 2) {\n\t\t\tptr = &inst_table3_f2[inst->opcode];\n\n\t\t// prefix 0xf3\n\t\t} else if (MASK_PREFIX_G1(flags) == 3) {\n\t\t\tptr = &inst_table3_f3[inst->opcode];\n\n\t\t// normal 2-byte opcode table\n\t\t} else {\n\t\t\tptr = &inst_table2[inst->opcode];\n\t\t}\n\n\t// extension group 3 \"test\" (<-- stupid hack)\n\t} else if ((MASK_EXT(flags) == EXT_G3) &&\n\t\t\t!MASK_MODRM_REG(*(addr + index + 1))) {\n\t\tinst->opcode = *(addr + index);\n\t\tptr = &inst_table_test[inst->opcode - 0xf6];\n\n\t// finally, the default 1-byte opcode table\n\t} else {\n\t\tinst->opcode = *(addr + index);\n\t\tptr = &inst_table1[inst->opcode];\n\t}\n\n\t// Illegal instruction\n        if (!ptr->mnemonic) return 0;\n\n\t// Copy instruction type\n\tinst->type = ptr->type;\n\n\t// Pointer to instruction table\n\tinst->ptr = ptr;\n\n\t// Index points now to first byte after prefixes/escapes\n\tindex++;\n\n\t// Opcode extensions\n\tif (MASK_EXT(flags) && (MASK_EXT(flags) < EXT_T2)) {\n\t\tinst->extindex = MASK_MODRM_REG(*(addr + index));\n\t\text = ext_name_table[(MASK_EXT(flags)) - 1][inst->extindex];\n\t\tif (ext == NULL)\n\t\t\treturn 0;\n\t\t/*\n\t\t * Copy instruction type from extension table\n\t\t * except for groups 12-14. These are special groups\n\t\t * that are either MMX/SSE instructions. For these,\n\t\t * just use the type in INST structure.\n\t\t *\n\t\t */\n\t\tif ((MASK_EXT(flags) < 12) || (MASK_EXT(flags) > 14))\n\t\t\tinst->type =\n\t\t\t  ext_type_table[(MASK_EXT(flags)) - 1][inst->extindex];\n\t} \n\n\t// Parse operands\n\tif (!get_operand(ptr, ptr->flags1, inst, &inst->op1, addr, index,\n\t\t\tmode, flags))\n\t\treturn 0;\n\tif (!get_operand(ptr, ptr->flags2, inst, &inst->op2, addr, index,\n\t\t\tmode, flags))\n\t\treturn 0;\n\tif (!get_operand(ptr, ptr->flags3, inst, &inst->op3, addr, index,\n\t\t\tmode, flags))\n\t\treturn 0;\n\n\t// Add modrm/sib, displacement and immediate bytes in size\n\tinst->length += index + inst->immbytes + inst->dispbytes;\n\n\t// Copy addressing mode\n\tinst->mode = mode;\n\n\t// Copy instruction flags\n\tinst->flags = flags;\n\n\treturn inst->length;\n}", "path": "antispy/src/Antispy/SpyHunter/SpyHunter/libdasm.c", "commit_date": "2019-11-09 00:00:00", "repo_name": "mohuihui/antispy", "stars": 1067, "license": "other", "language": "c", "size": 4006}
{"docstring": "// Helper functions\n", "func_signal": "int get_register_type(POPERAND op)", "code": "{\n\t\n\tif (op->type != OPERAND_TYPE_REGISTER)\n\t\treturn 0;\n\tswitch (MASK_AM(op->flags)) {\n\t\tcase AM_REG:\n\t\t\tif (MASK_FLAGS(op->flags) == F_r)\n\t\t\t\treturn REGISTER_TYPE_SEGMENT;\n\t\t\telse if (MASK_FLAGS(op->flags) == F_f)\n\t\t\t\treturn REGISTER_TYPE_FPU;\n\t\t\telse\n\t\t\t\treturn REGISTER_TYPE_GEN;\n\t\tcase AM_E:\n\t\tcase AM_G:\n\t\tcase AM_R:\n\t\t\t\treturn REGISTER_TYPE_GEN;\n\t\tcase AM_C:\n\t\t\t\treturn REGISTER_TYPE_CONTROL;\n\t\tcase AM_D:\n\t\t\t\treturn REGISTER_TYPE_DEBUG;\n\t\tcase AM_S:\n\t\t\t\treturn REGISTER_TYPE_SEGMENT;\n\t\tcase AM_T:\n\t\t\t\treturn REGISTER_TYPE_TEST;\n\t\tcase AM_P:\n\t\tcase AM_Q:\n\t\t\t\treturn REGISTER_TYPE_MMX;\n\t\tcase AM_V:\n\t\tcase AM_W:\n\t\t\t\treturn REGISTER_TYPE_XMM;\n\t\tdefault:\n\t\t\t\tbreak;\n\t}\n\treturn 0;\n}", "path": "antispy/src/Antispy/SpyHunter/SpyHunter/libdasm.c", "commit_date": "2019-11-09 00:00:00", "repo_name": "mohuihui/antispy", "stars": 1067, "license": "other", "language": "c", "size": 4006}
{"docstring": "// XXX: note that source and destination are not always literal\n", "func_signal": "POPERAND get_source_operand(PINSTRUCTION inst)", "code": "{\n\tif (inst->op2.type != OPERAND_TYPE_NONE)\n\t\treturn &inst->op2;\n\telse\n\t\treturn NULL;\n}", "path": "antispy/src/Antispy/SpyHunter/SpyHunter/libdasm.c", "commit_date": "2019-11-09 00:00:00", "repo_name": "mohuihui/antispy", "stars": 1067, "license": "other", "language": "c", "size": 4006}
{"docstring": "/**\n * ntfs_inode_sync_file_name - update FILE_NAME attributes\n * @ni:\t\tntfs inode to update FILE_NAME attributes\n *\n * Update all FILE_NAME attributes for inode @ni in the index.\n *\n * Return 0 on success or -1 on error with errno set to the error code.\n */\n", "func_signal": "static int ntfs_inode_sync_file_name(ntfs_inode *ni)", "code": "{\n\tntfs_attr_search_ctx *ctx = NULL;\n\tntfs_index_context *ictx;\n\tntfs_inode *index_ni;\n\tFILE_NAME_ATTR *fn;\n\tint err = 0;\n\n\tntfs_log_trace(\"Entering for inode 0x%llx.\\n\", (LONG64) ni->mft_no);\n\n\tctx = ntfs_attr_get_search_ctx(ni, NULL);\n\tif (!ctx) {\n\t\terr = errno;\n\t\tntfs_log_trace(\"Failed to get attribute search context.\\n\");\n\t\tgoto err_out;\n\t}\n\t/* Walk through all FILE_NAME attributes and update them. */\n\twhile (!ntfs_attr_lookup(AT_FILE_NAME, NULL, 0, 0, 0, NULL, 0, ctx)) {\n\t\tfn = (FILE_NAME_ATTR *)((u8 *)ctx->attr +\n\t\t\t\tle16_to_cpu(ctx->attr->X.value_offset));\n\t\tif (MREF_LE(fn->parent_directory) == ni->mft_no) {\n\t\t\t/*\n\t\t\t * WARNING: We cheater here and obtain 2 attribute\n\t\t\t * search contexts for one inode (first we obtained\n\t\t\t * above, second will be obtained inside\n\t\t\t * ntfs_index_lookup), it's acceptable for library,\n\t\t\t * but will lock kernel.\n\t\t\t */\n\t\t\tindex_ni = ni;\n\t\t} else {\n\t\t\tindex_ni = ntfs_inode_open( ni->vol, le64_to_cpu(fn->parent_directory) );\n\t\t}\n\t\tif (!index_ni) {\n\t\t\tif (!err)\n\t\t\t\terr = errno;\n\t\t\tntfs_log_trace(\"Failed to open inode with index.\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tictx = ntfs_index_ctx_get(index_ni, NTFS_INDEX_I30, 4);\n\t\tif (!ictx) {\n\t\t\tif (!err)\n\t\t\t\terr = errno;\n\t\t\tntfs_log_trace(\"Failed to get index context.\\n\");\n\t\t\tntfs_inode_close(index_ni);\n\t\t\tcontinue;\n\t\t}\n\t\tif (ntfs_index_lookup(fn, sizeof(FILE_NAME_ATTR), ictx)) {\n\t\t\tif (!err) {\n\t\t\t\tif (errno == ENOENT)\n\t\t\t\t\terr = EIO;\n\t\t\t\telse\n\t\t\t\t\terr = errno;\n\t\t\t}\n\t\t\tntfs_log_trace(\"Index lookup failed.\\n\");\n\t\t\tntfs_index_ctx_put(ictx);\n\t\t\tntfs_inode_close(index_ni);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Update flags and file size. */\n\t\tfn = (FILE_NAME_ATTR *)ictx->data;\n\t\tfn->file_attributes =\n\t\t\t\t(fn->file_attributes & ~FILE_ATTR_VALID_FLAGS) |\n\t\t\t\t(ni->flags & FILE_ATTR_VALID_FLAGS);\n\t\tfn->allocated_size = cpu_to_sle64(ni->allocated_size);\n\t\tfn->data_size = cpu_to_sle64(ni->data_size);\n\t\tfn->creation_time = utc2ntfs(ni->creation_time);\n\t\tfn->last_data_change_time = utc2ntfs(ni->last_data_change_time);\n\t\tfn->last_mft_change_time = utc2ntfs(ni->last_mft_change_time);\n\t\tfn->last_access_time = utc2ntfs(ni->last_access_time);\n\t\tntfs_index_entry_mark_dirty(ictx);\n\t\tntfs_index_ctx_put(ictx);\n\t\tif (ni != index_ni)\n\t\t\tntfs_inode_close(index_ni);\n\t}\n\t/* Check for real error occurred. */\n\tif (errno != ENOENT) {\n\t\terr = errno;\n\t\tntfs_log_trace(\"Attribute lookup failed.\\n\");\n\t\tgoto err_out;\n\t}\n\tntfs_attr_put_search_ctx(ctx);\n\tif (err) {\n\t\terrno = err;\n\t\treturn -1;\n\t}\n\treturn 0;\nerr_out:\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\terrno = err;\n\treturn -1;\n}", "path": "antispy/src/Antispy/SpyHunter/SpyHunter/ntfs/inode.c", "commit_date": "2019-11-09 00:00:00", "repo_name": "mohuihui/antispy", "stars": 1067, "license": "other", "language": "c", "size": 4006}
{"docstring": "// Print instruction mnemonic, prefixes and operands\n", "func_signal": "int get_instruction_string(INSTRUCTION *inst, enum Format format, DWORD offset,\n\t\tchar *string, int length)", "code": "{\n\n\t// Print the actual instruction string with possible prefixes etc.\n\tget_mnemonic_string(inst, format, string, length);\n\n\tsnprintf(string + strlen(string), length - strlen(string), \" \");\n\t\n\t// Print operands\n\tif (!get_operands_string(inst, format, offset,\n\t\tstring + strlen(string), length - strlen(string)))\n\t\treturn 0;\n\n\treturn 1;\n}", "path": "antispy/src/Antispy/SpyHunter/SpyHunter/libdasm.c", "commit_date": "2019-11-09 00:00:00", "repo_name": "mohuihui/antispy", "stars": 1067, "license": "other", "language": "c", "size": 4006}
{"docstring": "// Parse operand and fill OPERAND structure\n", "func_signal": "int get_operand(PINST inst, int oflags, PINSTRUCTION instruction,\n\tPOPERAND op, BYTE *data, int offset, enum Mode mode, int iflags)", "code": "{\n\tBYTE *addr = data + offset;\n\tint index = 0, sib = 0, scale = 0;\n\tint reg      = REG_NOP;\n\tint basereg  = REG_NOP;\n\tint indexreg = REG_NOP;\n\tint dispbytes = 0;\n\tenum Mode pmode;\n\n\t// Is this valid operand?\n\tif (oflags == FLAGS_NONE) {\n\t\top->type = OPERAND_TYPE_NONE;\n\t\treturn 1;\n\t}\n\t// Copy flags\n\top->flags = oflags;\n\n\t// Set operand registers\n\top->reg      = REG_NOP;\n\top->basereg  = REG_NOP;\n\top->indexreg = REG_NOP;\n\n\t// Offsets\n\top->dispoffset = 0;\n\top->immoffset  = 0;\n\n\t// Parse modrm and sib\n\tif (inst->modrm) {\n\t\t// 32-bit mode\n\t\tif (((mode == MODE_32) && (MASK_PREFIX_ADDR(iflags) == 0)) ||\n\t\t    ((mode == MODE_16) && (MASK_PREFIX_ADDR(iflags) == 1)))\n\t\t\tpmode = MODE_32;\n\t\telse \n\t\t\tpmode = MODE_16;\n\n\t\t// Update length only once!\n\t\tif (!instruction->length) {\n\t\t\tinstruction->modrm = *addr;\n\t\t\tinstruction->length += 1;\n\t\t}\n\t\t// Register\n\t\treg =  MASK_MODRM_REG(*addr);\n\n\t\t// Displacement bytes\n\t\t// SIB can also specify additional displacement, see below\n\t\tif (MASK_MODRM_MOD(*addr) == 0) {\n\t\t\tif ((pmode == MODE_32) && (MASK_MODRM_RM(*addr) == REG_EBP))\n\t\t\t\tdispbytes = 4;\n\t\t\tif ((pmode == MODE_16) && (MASK_MODRM_RM(*addr) == REG_ESI))\n\t\t\t\tdispbytes = 2;\n\t\t} else if (MASK_MODRM_MOD(*addr) == 1) {\n\t\t\tdispbytes = 1;\n\n\t\t} else if (MASK_MODRM_MOD(*addr) == 2) {\n\t\t\tdispbytes = (pmode == MODE_32) ? 4 : 2; \n\t\t}\n\t\t// Base and index registers\n\n\t\t// 32-bit mode\n\t\tif (pmode == MODE_32) {\n\t\t\tif ((MASK_MODRM_RM(*addr) == REG_ESP) && \n\t\t\t\t\t(MASK_MODRM_MOD(*addr) != 3)) {\n\t\t\t\tsib = 1;\n\t\t\t\tinstruction->sib = *(addr + 1);\n\n\t\t\t\t// Update length only once!\n\t\t\t\tif (instruction->length == 1) {\n\t\t\t\t\tinstruction->sib = *(addr + 1);\n\t\t\t\t\tinstruction->length += 1;\n\t\t\t\t}\n\t\t\t\tbasereg  = MASK_SIB_BASE( *(addr + 1));\n\t\t\t\tindexreg = MASK_SIB_INDEX(*(addr + 1));\n\t\t\t\tscale    = MASK_SIB_SCALE(*(addr + 1)) * 2;\n\t\t\t\t// Fix scale *8\n\t\t\t\tif (scale == 6)\n\t\t\t\t\tscale += 2;\n\n\t\t\t\t// Special case where base=ebp and MOD = 0\n\t\t\t\tif ((basereg == REG_EBP) && !MASK_MODRM_MOD(*addr)) {\n\t\t\t\t\tbasereg = REG_NOP;\n\t\t\t\t\t\tdispbytes = 4;\n\t\t\t\t}\n\t\t\t\tif (indexreg == REG_ESP)\n\t\t\t\t\tindexreg = REG_NOP;\n\t\t\t} else {\n\t\t\t\tif (!MASK_MODRM_MOD(*addr) && (MASK_MODRM_RM(*addr) == REG_EBP))\n\t\t\t\t\tbasereg = REG_NOP;\n\t\t\t\telse\n\t\t\t\t\tbasereg = MASK_MODRM_RM(*addr);\n\t\t\t}\n\t\t// 16-bit\n\t\t} else {\n\t\t\tswitch (MASK_MODRM_RM(*addr)) {\n\t\t\t\tcase 0:\n\t\t\t\t\tbasereg  = REG_EBX;\n\t\t\t\t\tindexreg = REG_ESI;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tbasereg  = REG_EBX;\n\t\t\t\t\tindexreg = REG_EDI;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tbasereg  = REG_EBP;\n\t\t\t\t\tindexreg = REG_ESI;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tbasereg  = REG_EBP;\n\t\t\t\t\tindexreg = REG_EDI;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tbasereg  = REG_ESI;\n\t\t\t\t\tindexreg = REG_NOP;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\n\t\t\t\t\tbasereg  = REG_EDI;\n\t\t\t\t\tindexreg = REG_NOP;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 6:\n\t\t\t\t\tif (!MASK_MODRM_MOD(*addr))\n\t\t\t\t\t\tbasereg = REG_NOP;\n\t\t\t\t\telse\n\t\t\t\t\t\tbasereg = REG_EBP;\n\t\t\t\t\tindexreg = REG_NOP;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 7:\n\t\t\t\t\tbasereg  = REG_EBX;\n\t\t\t\t\tindexreg = REG_NOP;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (MASK_MODRM_MOD(*addr) == 3) {\n\t\t\t\tbasereg  = MASK_MODRM_RM(*addr);\n\t\t\t\tindexreg = REG_NOP;\n\t\t\t}\n\t\t}\n\t}\n\t// Operand addressing mode -specific parsing\n\tswitch (MASK_AM(oflags)) {\n\n\t\t// Register encoded in instruction\n\t\tcase AM_REG:\n\t\t\top->type = OPERAND_TYPE_REGISTER;\n\t\t\top->reg  = MASK_REG(oflags);\n\t\t\tbreak;\n\n\t\t// Register/memory encoded in MODRM\n\t\tcase AM_M:\n\t\t\tif (MASK_MODRM_MOD(*addr) == 3)\n\t\t\t\treturn 0;\n\t\t\tgoto skip_rest;\n\t\tcase AM_R:\n\t\t\tif (MASK_MODRM_MOD(*addr) != 3)\n\t\t\t\treturn 0;\nskip_rest:\n\t\tcase AM_Q:\n\t\tcase AM_W:\n\t\tcase AM_E:\n\t\t\top->type = OPERAND_TYPE_MEMORY;\n\t\t\top->dispbytes          = dispbytes;\n\t\t\tinstruction->dispbytes = dispbytes;\n\t\t\top->basereg            = basereg;\n\t\t\top->indexreg           = indexreg;\n\t\t\top->scale              = scale;\n\n\t\t\tindex = (sib) ? 1 : 0;\n\t\t\tif (dispbytes)\n\t\t\t\top->dispoffset = index + 1 + offset;\n\t\t\tswitch (dispbytes) {\n\t\t\t\tcase 0:\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\top->displacement = FETCH8(addr + 1 + index);\n\t\t\t\t\t// Always sign-extend\n\t\t\t\t\tif (op->displacement >= 0x80)\n\t\t\t\t\t\top->displacement |= 0xffffff00;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\top->displacement = FETCH16(addr + 1 + index);\n\n\t\t\t\t\t// Malformed opcode\n\t\t\t\t\tif (op->displacement < 0x80)\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\top->displacement = FETCH32(addr + 1 + index);\n\n\t\t\t\t\t// XXX: problems with [index*scale + disp] addressing\n\t\t\t\t\t//if (op->displacement < 0x80)\n\t\t\t\t\t//\treturn 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// MODRM defines register\n\t\t\tif ((basereg != REG_NOP) && (MASK_MODRM_MOD(*addr) == 3)) { \n\t\t\t\top->type = OPERAND_TYPE_REGISTER;\n\t\t\t\top->reg  = basereg;\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// Immediate byte 1 encoded in instruction\n\t\tcase AM_I1:\n\t\t\top->type = OPERAND_TYPE_IMMEDIATE;\n\t\t\top->immbytes  = 1;\n\t\t\top->immediate = 1;\n\t\t\tbreak;\n\t\t// Immediate value\n\t\tcase AM_J:\n\t\t\top->type = OPERAND_TYPE_IMMEDIATE;\n\t\t\t// Always sign-extend\n\t\t\toflags |= F_s;\n\t\tcase AM_I:\n\t\t\top->type = OPERAND_TYPE_IMMEDIATE;\n\t\t\tindex  = (inst->modrm) ? 1 : 0;\n\t\t\tindex += (sib) ? 1 : 0;\n\t\t\tindex += instruction->immbytes;\n\t\t\tindex += instruction->dispbytes;\n\t\t\top->immoffset = index + offset;\n\n\t\t\t// 32-bit mode\n\t\t\tif (((mode == MODE_32) && (MASK_PREFIX_OPERAND(iflags) == 0)) ||\n\t\t    \t    ((mode == MODE_16) && (MASK_PREFIX_OPERAND(iflags) == 1)))\n\t\t\t\tmode = MODE_32;\n\t\t\telse \n\t\t\t\tmode = MODE_16;\n\n\t\t\tswitch (MASK_OT(oflags)) {\n\t\t\t\tcase OT_b:\n\t\t\t\t\top->immbytes  = 1;\n\t\t\t\t\top->immediate = FETCH8(addr + index);\n\t\t\t\t\tif ((op->immediate >= 0x80) &&\n\t\t\t\t\t\t(MASK_FLAGS(oflags) == F_s))\n\t\t\t\t\t\top->immediate |= 0xffffff00;\n\t\t\t\t\tbreak;\n\t\t\t\tcase OT_v:\n\t\t\t\t\top->immbytes  = (mode == MODE_32) ?\n\t\t\t\t\t\t4 : 2;\n\t\t\t\t\top->immediate = (mode == MODE_32) ?\n\t\t\t\t\t\tFETCH32(addr + index) :\n\t\t\t\t\t\tFETCH16(addr + index);\n\t\t\t\t\tbreak;\n\t\t\t\tcase OT_w:\n\t\t\t\t\top->immbytes  = 2;\n\t\t\t\t\top->immediate =\tFETCH16(addr + index);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tinstruction->immbytes += op->immbytes;\n\t\t\tbreak;\n\n\t\t// 32-bit or 48-bit address\n\t\tcase AM_A:\n\t\t\top->type = OPERAND_TYPE_IMMEDIATE;\n\t\t\t// 32-bit mode\n\t\t\tif (((mode == MODE_32) && (MASK_PREFIX_OPERAND(iflags) == 0)) ||\n\t\t    \t    ((mode == MODE_16) && (MASK_PREFIX_OPERAND(iflags) == 1)))\n\t\t\t\tmode = MODE_32;\n\t\t\telse \n\t\t\t\tmode = MODE_16;\n\n\t\t\top->dispbytes    = (mode == MODE_32) ? 6 : 4;\n\t\t\top->displacement = (mode == MODE_32) ?\n\t\t\t\tFETCH32(addr) : FETCH16(addr);\n\t\t\top->section = FETCH16(addr + op->dispbytes - 2);\n\n\t\t\tinstruction->dispbytes    = op->dispbytes;\n\t\t\tinstruction->sectionbytes = 2;\n\t\t\tbreak;\n\n\t\t// Plain displacement without MODRM/SIB\n\t\tcase AM_O:\n\t\t\top->type = OPERAND_TYPE_MEMORY;\n\t\t\tswitch (MASK_OT(oflags)) {\n\t\t\t\tcase OT_b:\n\t\t\t\t\top->dispbytes    = 1;\n\t\t\t\t\top->displacement = FETCH8(addr);\n\t\t\t\t\tbreak;\n\t\t\t\tcase OT_v:\n\t\t\t\t\top->dispbytes    = (mode == MODE_32) ? 4 : 2;\n\t\t\t\t\top->displacement = (mode == MODE_32) ?\n\t\t\t\t\t\tFETCH32(addr) : FETCH16(addr);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tinstruction->dispbytes = op->dispbytes;\n\t\t\top->dispoffset = offset;\n\t\t\tbreak;\n\n\t\t// General-purpose register encoded in MODRM\n\t\tcase AM_G:\n\t\t\top->type = OPERAND_TYPE_REGISTER;\n\t\t\top->reg  = reg;\n\t\t\tbreak;\n\n\t\t// control register encoded in MODRM\n\t\tcase AM_C:\n\t\t// debug register encoded in MODRM\n\t\tcase AM_D:\n\t\t// Segment register encoded in MODRM\n\t\tcase AM_S:\n\t\t// TEST register encoded in MODRM\n\t\tcase AM_T:\n\t\t// MMX register encoded in MODRM\n\t\tcase AM_P:\n\t\t// XMM register encoded in MODRM\n\t\tcase AM_V:\n\t\t\top->type = OPERAND_TYPE_REGISTER;\n\t\t\top->reg  = MASK_MODRM_REG(instruction->modrm);\n\t\t\tbreak;\n\t}\n\treturn 1;\n}", "path": "antispy/src/Antispy/SpyHunter/SpyHunter/libdasm.c", "commit_date": "2019-11-09 00:00:00", "repo_name": "mohuihui/antispy", "stars": 1067, "license": "other", "language": "c", "size": 4006}
{"docstring": "// Parse 2 and 3-byte opcodes\n", "func_signal": "int get_real_instruction2(BYTE *addr, int *flags)", "code": "{\n\tswitch (*addr) {\n\n\t\t// opcode extensions for 2-byte opcodes\n\t\tcase 0x00:\n\t\t\t// Clear extension\n\t\t\t*flags &= 0xFFFFFF00;\n\t\t\t*flags |= EXT_G6;\n\t\t\tbreak;\n\t\tcase 0x01:\n\t\t\t*flags &= 0xFFFFFF00;\n\t\t\t*flags |= EXT_G7;\n\t\t\tbreak;\n\t\tcase 0x71:\n\t\t\t*flags &= 0xFFFFFF00;\n\t\t\t*flags |= EXT_GC;\n\t\t\tbreak;\n\t\tcase 0x72:\n\t\t\t*flags &= 0xFFFFFF00;\n\t\t\t*flags |= EXT_GD;\n\t\t\tbreak;\n\t\tcase 0x73:\n\t\t\t*flags &= 0xFFFFFF00;\n\t\t\t*flags |= EXT_GE;\n\t\t\tbreak;\n\t\tcase 0xae:\n\t\t\t*flags &= 0xFFFFFF00;\n\t\t\t*flags |= EXT_GF;\n\t\t\tbreak;\n\t\tcase 0xba:\n\t\t\t*flags &= 0xFFFFFF00;\n\t\t\t*flags |= EXT_G8;\n\t\t\tbreak;\n\t\tcase 0xc7:\n\t\t\t*flags &= 0xFFFFFF00;\n\t\t\t*flags |= EXT_G9;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn 0;\n}", "path": "antispy/src/Antispy/SpyHunter/SpyHunter/libdasm.c", "commit_date": "2019-11-09 00:00:00", "repo_name": "mohuihui/antispy", "stars": 1067, "license": "other", "language": "c", "size": 4006}
{"docstring": "/**\n * ntfs_inode_close - close an ntfs inode and free all associated memory\n * @ni:\t\tntfs inode to close\n *\n * Make sure the ntfs inode @ni is clean.\n *\n * If the ntfs inode @ni is a base inode, close all associated extent inodes,\n * then deallocate all memory attached to it, and finally free the ntfs inode\n * structure itself.\n *\n * If it is an extent inode, we disconnect it from its base inode before we\n * destroy it.\n *\n * Return 0 on success or -1 on error with errno set to the error code. On\n * error, @ni has not been freed. The user should attempt to handle the error\n * and call ntfs_inode_close() again. The following error codes are defined:\n *\n *\tEBUSY\t@ni and/or its attribute list runlist is/are dirty and the\n *\t\tattempt to write it/them to disk failed.\n *\tEINVAL\t@ni is invalid (probably it is an extent inode).\n *\tEIO\tI/O error while trying to write inode to disk.\n */\n", "func_signal": "int ntfs_inode_close(ntfs_inode *ni)", "code": "{\n\tif (!ni)\n\t\treturn 0;\n\n\t/* If we have dirty metadata, write it out. */\n\tif (NInoDirty(ni) || NInoAttrListDirty(ni)) {\n\t\tif (ntfs_inode_sync(ni)) {\n\t\t\tif (errno != EIO)\n\t\t\t\terrno = EBUSY;\n\t\t\treturn -1;\n\t\t}\n\t}\n\t/* Is this a base inode with mapped extent inodes? */\n\tif (ni->nr_extents > 0) {\n\t\twhile (ni->nr_extents > 0) {\n\t\t\tif (ntfs_inode_close(ni->extent_nis[0])) {\n\t\t\t\tif (errno != EIO)\n\t\t\t\t\terrno = EBUSY;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t} else if (ni->nr_extents == -1) {\n\t\tntfs_inode **tmp_nis;\n\t\tntfs_inode *base_ni;\n\t\ts32 i;\n\n\t\t/*\n\t\t * If the inode is an extent inode, disconnect it from the\n\t\t * base inode before destroying it.\n\t\t */\n\t\tbase_ni = ni->base_ni;\n\t\tfor (i = 0; i < base_ni->nr_extents; ++i) {\n\t\t\ttmp_nis = base_ni->extent_nis;\n\t\t\tif (tmp_nis[i] != ni)\n\t\t\t\tcontinue;\n\t\t\t/* Found it. Disconnect. */\n\t\t\tmemmove(tmp_nis + i, tmp_nis + i + 1,\n\t\t\t\t\t(base_ni->nr_extents - i - 1) *\n\t\t\t\t\tsizeof(ntfs_inode *));\n\t\t\t/* Buffer should be for multiple of four extents. */\n\t\t\tif ((--base_ni->nr_extents) & 3) {\n\t\t\t\ti = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * ElectricFence is unhappy with realloc(x,0) as free(x)\n\t\t\t * thus we explicitly separate these two cases.\n\t\t\t */\n\t\t\tif (base_ni->nr_extents) {\n\t\t\t\t/* Resize the memory buffer. */\n\t\t\t\ttmp_nis = realloc(tmp_nis, base_ni->nr_extents *\n\t\t\t\t\t\t  sizeof(ntfs_inode *));\n\t\t\t\t/* Ignore errors, they don't really matter. */\n\t\t\t\tif (tmp_nis)\n\t\t\t\t\tbase_ni->extent_nis = tmp_nis;\n\t\t\t} else if (tmp_nis)\n\t\t\t\tfree(tmp_nis);\n\t\t\t/* Allow for error checking. */\n\t\t\ti = -1;\n\t\t\tbreak;\n\t\t}\n\t\tif (i != -1)\n\t\t\tntfs_log_debug(\"Extent inode was not attached to base inode! \"\n\t\t\t\t\t\"Weird! Continuing regardless.\\n\");\n\t}\n\treturn __ntfs_inode_release(ni);\n}", "path": "antispy/src/Antispy/SpyHunter/SpyHunter/ntfs/inode.c", "commit_date": "2019-11-09 00:00:00", "repo_name": "mohuihui/antispy", "stars": 1067, "license": "other", "language": "c", "size": 4006}
{"docstring": "//\n// \u0436\u03fd\u0335\u0139\u037b\u05b8\n//\n", "func_signal": "NTSTATUS ProcessMenu(PVOID pInBuffer, ULONG uInSize, PVOID pOutBuffer, ULONG uOutSize, ULONG* dwRet)", "code": "{\n\tNTSTATUS status = STATUS_UNSUCCESSFUL;\n\tPCOMMUNICATE_PROCESS pCp = (PCOMMUNICATE_PROCESS)pInBuffer;\n\tPEPROCESS pEprocess = NULL;\n\tULONG hPid = 0;\n\tCOMMUNICATE_THREAD Cpt;\n\tPALL_THREADS pPt = NULL;\n\tULONG nThreadCnt = 1000;\n\tPRESUME_OR_SUSPEND pRos = (PRESUME_OR_SUSPEND)pOutBuffer;\n\tpfnExAllocatePoolWithTag MzfExAllocatePoolWithTag = (pfnExAllocatePoolWithTag)GetGlobalVeriable(enumExAllocatePoolWithTag);\n\tpfnExFreePoolWithTag MzfExFreePoolWithTag = (pfnExFreePoolWithTag)GetGlobalVeriable(enumExFreePoolWithTag);\n\tPEPROCESS pSpyHunterProess = (PEPROCESS)GetGlobalVeriable(enumAntiSpyEprocess);\n\n\tif (!MzfExAllocatePoolWithTag ||\n\t\t!MzfExFreePoolWithTag)\n\t{\n\t\treturn status;\n\t}\n\t\n\tKdPrint((\"ProcessMenu\\n\"));\n\n\t// \n\tif (!pInBuffer || \n\t\tuInSize != sizeof(COMMUNICATE_PROCESS) ||\n\t\t!pOutBuffer ||\n\t\tuOutSize != sizeof(RESUME_OR_SUSPEND))\n\t{\n\t\treturn STATUS_INVALID_PARAMETER;\n\t}\n\n\tpEprocess = (PEPROCESS)pCp->op.GetProcessSuspendStatus.pEprocess;\n\thPid = pCp->op.GetProcessSuspendStatus.nPid;\n\t\n\t// AS,\u05b1\u04f7\n\tif (pSpyHunterProess == pEprocess)\n\t{\n\t\tpRos->bResume = 0;\n\t\tpRos->bSuspend = 0;\n\t\treturn status;\n\t}\n\n\t// ,\u05b1\u04f7\n\tif (!IsRealProcess(pEprocess))\n\t{\n\t\treturn status;\n\t}\n\n\tCpt.nPid = hPid;\n\tCpt.pEprocess = (ULONG)pEprocess;\n\t\n\t// \u00f6\u022b\u07f3\n\tdo \n\t{\n\t\tULONG nSize = 0;\n\n\t\tif (pPt)\n\t\t{\n\t\t\tMzfExFreePoolWithTag(pPt, 0);\n\t\t\tpPt = NULL;\n\t\t}\n\n\t\tnSize = sizeof(ALL_THREADS) + nThreadCnt * sizeof(THREAD_INFO);\n\t\tpPt = (PALL_THREADS)MzfExAllocatePoolWithTag(NonPagedPool, nSize, MZFTAG);\n\t\tif (pPt)\n\t\t{\n\t\t\tmemset(pPt, 0, nSize);\n\t\t\tstatus = ListProcessThread(&Cpt, sizeof(COMMUNICATE_THREAD), pPt, nSize, NULL);\n\t\t}\n\n\t\tnThreadCnt = pPt->nCnt + 100;\n\n\t} while (!NT_SUCCESS(status) && status == STATUS_BUFFER_TOO_SMALL);\n\n\t// \u0436\u00ff\u07f3\u0335\u0139\n\tif (NT_SUCCESS(status))\n\t{\n\t\tULONG i = 0;\n\t\tfor (i = 0; i < pPt->nCnt; i++)\n\t\t{\n\t\t\tULONG nRet = 0;\n\t\t\tPspGetThreadSuspendCount((PETHREAD)pPt->Threads[i].pThread, &nRet);\n\n\t\t\tif (nRet)\n\t\t\t{\n\t\t\t\tpRos->bResume = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpRos->bSuspend = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pPt)\n\t{\n\t\tMzfExFreePoolWithTag(pPt, 0);\n\t\tpPt = NULL;\n\t}\n\t\n\treturn status;\n}", "path": "antispy/src/Antispy/SpyHunterDrv/SpyHunterDrv/Process.c", "commit_date": "2019-11-09 00:00:00", "repo_name": "mohuihui/antispy", "stars": 1067, "license": "other", "language": "c", "size": 4006}
{"docstring": "//\n// \u06ba\u02faNtTerminateProcess\n// \n", "func_signal": "NTSTATUS KillProcessByNtTerminateProcess(PEPROCESS pEprocess)", "code": "{\n\tpfnNtTerminateProcess MzfNtTerminateProcess = (pfnNtTerminateProcess)GetGlobalVeriable(enumNtTerminateProcess);\n\tpfnObOpenObjectByPointer MzfObOpenObjectByPointer = (pfnObOpenObjectByPointer)GetGlobalVeriable(enumObOpenObjectByPointer);\n\tpfnNtClose MzfNtClose = (pfnNtClose)GetGlobalVeriable(enumNtClose);\n\tpfnPsGetCurrentThread MzfPsGetCurrentThread = (pfnPsGetCurrentThread)GetGlobalVeriable(enumPsGetCurrentThread);\n\tPOBJECT_TYPE ProcessType = (POBJECT_TYPE)GetGlobalVeriable(enumPsProcessType);\n\tHANDLE hProcess;\n\tNTSTATUS status = STATUS_UNSUCCESSFUL;\n\n\tKdPrint((\"KillProcessByNtTerminateProcess \\n\"));\n\n\tif (!MzfNtTerminateProcess ||\n\t\t!MzfObOpenObjectByPointer ||\n\t\t!MzfNtClose ||\n\t\t!MzfPsGetCurrentThread ||\n\t\t!ProcessType)\n\t{\n\t\treturn status;\n\t}\n\n\tstatus = MzfObOpenObjectByPointer(pEprocess, OBJ_KERNEL_HANDLE, NULL, GENERIC_ALL, ProcessType, KernelMode, &hProcess);\n\tif (NT_SUCCESS(status))\n\t{\n\t\tPETHREAD pThread = MzfPsGetCurrentThread();\n\t\tCHAR PreMode = ChangePreMode(pThread);\n\t\tstatus = MzfNtTerminateProcess(hProcess, 0);\n\t\tMzfNtClose(hProcess);\n\t\tRecoverPreMode(pThread, PreMode);\n\t}\n\n\treturn status;\n}", "path": "antispy/src/Antispy/SpyHunterDrv/SpyHunterDrv/Process.c", "commit_date": "2019-11-09 00:00:00", "repo_name": "mohuihui/antispy", "stars": 1067, "license": "other", "language": "c", "size": 4006}
{"docstring": "/**\n * ntfs_inode_attach_all_extents - attach all extents for target inode\n * @ni:\t\topened ntfs inode for which perform attach\n *\n * Return 0 on success and -1 on error with errno set to the error code.\n */\n", "func_signal": "int ntfs_inode_attach_all_extents(ntfs_inode *ni)", "code": "{\n\tATTR_LIST_ENTRY *ale;\n\tu64 prev_attached = 0;\n\n\tif (!ni) {\n\t\tntfs_log_trace(\"Invalid arguments.\\n\");\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tif (ni->nr_extents == -1)\n\t\tni = ni->base_ni;\n\n\tntfs_log_trace(\"Entering for inode 0x%llx.\\n\", (LONG64) ni->mft_no);\n\n\t/* Inode haven't got attribute list, thus nothing to attach. */\n\tif (!NInoAttrList(ni))\n\t\treturn 0;\n\n\tif (!ni->attr_list) {\n\t\tntfs_log_trace(\"Corrupt in-memory struct.\\n\");\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\t/* Walk through attribute list and attach all extents. */\n\terrno = 0;\n\tale = (ATTR_LIST_ENTRY *)ni->attr_list;\n\twhile ((u8*)ale < ni->attr_list + ni->attr_list_size) {\n\t\tif (ni->mft_no != MREF_LE(ale->mft_reference) &&\n\t\t\t\tprev_attached != MREF_LE(ale->mft_reference)) {\n\t\t\tif (!ntfs_extent_inode_open(ni,\n\t\t\t\t\tMREF_LE(ale->mft_reference))) {\n\t\t\t\tntfs_log_trace(\"Couldn't attach extent inode.\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tprev_attached = MREF_LE(ale->mft_reference);\n\t\t}\n\t\tale = (ATTR_LIST_ENTRY *)((u8*)ale + le16_to_cpu(ale->length));\n\t}\n\treturn 0;\n}", "path": "antispy/src/Antispy/SpyHunter/SpyHunter/ntfs/inode.c", "commit_date": "2019-11-09 00:00:00", "repo_name": "mohuihui/antispy", "stars": 1067, "license": "other", "language": "c", "size": 4006}
{"docstring": "/**\n * ntfs_inode_update_time - update all times for ntfs inode\n * @ni:\t\tntfs inode for which update times\n *\n * This function updates last access, mft and data change times. Usually\n * get called when user write not metadata to inode. Do not update time for\n * system files.\n */\n", "func_signal": "void ntfs_inode_update_time(ntfs_inode *ni)", "code": "{\n\tif (!NVolReadOnly(ni->vol) && \n\t    (ni->mft_no >= FILE_first_user || ni->mft_no == FILE_root)) {\n\t\ttime_t now;\n\n\t\tnow = time(NULL);\n\t\tni->last_data_change_time = now;\n\t\tni->last_mft_change_time = now;\n\t\tNInoFileNameSetDirty(ni);\n\t\tNInoSetDirty(ni);\n\t}\n}", "path": "antispy/src/Antispy/SpyHunter/SpyHunter/ntfs/inode.c", "commit_date": "2019-11-09 00:00:00", "repo_name": "mohuihui/antispy", "stars": 1067, "license": "other", "language": "c", "size": 4006}
{"docstring": "//\n// \u06b4\u04340xcc\n//\n", "func_signal": "void KillProcessByFillUp0xcc(PEPROCESS pEprocess)", "code": "{\n\tpfnNtQuerySystemInformation MzfNtQuerySystemInformation = (pfnNtQuerySystemInformation)GetGlobalVeriable(enumNtQuerySystemInformation);\n\tpfnMmGetPhysicalAddress MzfMmGetPhysicalAddress = (pfnMmGetPhysicalAddress)GetGlobalVeriable(enumMmGetPhysicalAddress);\n\tpfnMmGetVirtualForPhysical MzfMmGetVirtualForPhysical = (pfnMmGetVirtualForPhysical)GetGlobalVeriable(enumMmGetVirtualForPhysical);\n\tpfnPsGetCurrentThread MzfPsGetCurrentThread = (pfnPsGetCurrentThread)GetGlobalVeriable(enumPsGetCurrentThread);\n\tpfnKeStackAttachProcess MzfKeStackAttachProcess = (pfnKeStackAttachProcess)GetGlobalVeriable(enumKeStackAttachProcess);\n\tpfnKeUnstackDetachProcess MzfKeUnstackDetachProcess = (pfnKeUnstackDetachProcess)GetGlobalVeriable(enumKeUnstackDetachProcess);\n\tpfnIoGetCurrentProcess MzfIoGetCurrentProcess = (pfnIoGetCurrentProcess)GetGlobalVeriable(enumIoGetCurrentProcess);\n\n\tKdPrint((\"KillProcessByFillUp0xcc \\n\"));\n\n\tif (MzfNtQuerySystemInformation &&\n\t\tMzfMmGetPhysicalAddress &&\n\t\tMzfMmGetVirtualForPhysical &&\n\t\tMzfPsGetCurrentThread &&\n\t\tMzfKeStackAttachProcess && \n\t\tMzfKeUnstackDetachProcess &&\n\t\tMzfIoGetCurrentProcess) \n\t{\n\t\tBOOL bAttach = FALSE;\n\t\tKAPC_STATE as;\n\t\tPETHREAD pThread = NULL;\n\t\tCHAR PreMode = 0;\n\t\tSYSTEM_BASIC_INFORMATION sbi;\n\t\tNTSTATUS status = STATUS_UNSUCCESSFUL;\n\n\t\tif (MzfIoGetCurrentProcess() != pEprocess)\n\t\t{\n\t\t\tMzfKeStackAttachProcess(pEprocess, &as);\n\t\t\tbAttach = TRUE;\n\t\t}\n\t\t\n\t\tpThread = MzfPsGetCurrentThread();\n\t\tPreMode = ChangePreMode(pThread);\n\t\t\n\t\tmemset(&sbi, 0, sizeof(SYSTEM_BASIC_INFORMATION));\n\t\tstatus = MzfNtQuerySystemInformation(SystemBasicInformation, &sbi, sizeof(SYSTEM_BASIC_INFORMATION), NULL);\n\t\tRecoverPreMode(pThread, PreMode);\n\n\t\tif (NT_SUCCESS(status))\n\t\t{\n\t\t\tULONG Address = 0x1000;\n\t\t\tSYSINF_PAGE_COUNT nMaxPhysicalPageSize = 0;\n\t\t\tSYSINF_PAGE_COUNT NumberOfPhysicalPages = sbi.NumberOfPhysicalPages;\n\t\t\tSYSINF_PAGE_COUNT HighestPhysicalPageNumber = sbi.HighestPhysicalPageNumber;\n\n\t\t\tif (NumberOfPhysicalPages > HighestPhysicalPageNumber)\n\t\t\t{\n\t\t\t\tNumberOfPhysicalPages = HighestPhysicalPageNumber;\n\t\t\t}\n\n\t\t\tnMaxPhysicalPageSize = NumberOfPhysicalPages * sbi.PageSize;\n\n\t\t\tdo \n\t\t\t{\n\t\t\t\tPHYSICAL_ADDRESS PhysicalAddress = MzfMmGetPhysicalAddress((PVOID)Address);\n\t\t\t\tif ( (PhysicalAddress.HighPart || PhysicalAddress.LowPart) &&\n\t\t\t\t\tPhysicalAddress.QuadPart < nMaxPhysicalPageSize)\n\t\t\t\t{\n\t\t\t\t\tif (MzfMmGetVirtualForPhysical(PhysicalAddress) == (PVOID)Address)\n\t\t\t\t\t{\n\t\t\t\t\t\t__try\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tWPOFF();\n\t\t\t\t\t\t\tmemset((PVOID)Address, 0xcc, PAGE_SIZE);\n\t\t\t\t\t\t\tWPON();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t__except(1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tAddress += PAGE_SIZE;\n\n\t\t\t} while (Address < SYSTEM_ADDRESS_START);\n\t\t}\n\n\t\tif (bAttach)\n\t\t{\n\t\t\tMzfKeUnstackDetachProcess(&as);\n\t\t\tbAttach = FALSE;\n\t\t}\n\t}\n}", "path": "antispy/src/Antispy/SpyHunterDrv/SpyHunterDrv/Process.c", "commit_date": "2019-11-09 00:00:00", "repo_name": "mohuihui/antispy", "stars": 1067, "license": "other", "language": "c", "size": 4006}
{"docstring": "// Print operands\n", "func_signal": "int get_operands_string(INSTRUCTION *inst, enum Format format, DWORD offset,\n\tchar *string, int length)", "code": "{\n\n\tif (format == FORMAT_ATT) {\n\t\tif (inst->op3.type != OPERAND_TYPE_NONE) {\n\t\t\tget_operand_string(inst, &inst->op3, format, offset,\n\t\t\t\tstring + strlen(string), length - strlen(string));\n\t\t\tsnprintf(string + strlen(string), length - strlen(string), \",\");\n\t\t}\n\t\tif (inst->op2.type != OPERAND_TYPE_NONE) {\n\t\t\tget_operand_string(inst, &inst->op2, format, offset,\n\t\t\t\tstring + strlen(string), length - strlen(string));\n\t\t\tsnprintf(string + strlen(string), length - strlen(string), \",\");\n\t\t}\n\t\tif (inst->op1.type != OPERAND_TYPE_NONE)\n\t\t\tget_operand_string(inst, &inst->op1, format, offset,\n\t\t\t\tstring + strlen(string), length - strlen(string));\n\t} else if (format == FORMAT_INTEL) {\n\t\tif (inst->op1.type != OPERAND_TYPE_NONE)\n\t\t\tget_operand_string(inst, &inst->op1, format, offset,\n\t\t\t\tstring + strlen(string), length - strlen(string));\n\t\tif (inst->op2.type != OPERAND_TYPE_NONE) {\n\t\t\tsnprintf(string + strlen(string), length - strlen(string), \",\");\n\t\t\tget_operand_string(inst, &inst->op2, format, offset,\n\t\t\t\tstring + strlen(string), length - strlen(string));\n\t\t}\n\t\tif (inst->op3.type != OPERAND_TYPE_NONE) {\n\t\t\tsnprintf(string + strlen(string), length - strlen(string), \",\");\n\t\t\tget_operand_string(inst, &inst->op3, format, offset,\n\t\t\t\tstring + strlen(string), length - strlen(string));\n\t\t}\n\t} else\n\t\treturn 0;\n\n\treturn 1;\n}", "path": "antispy/src/Antispy/SpyHunter/SpyHunter/libdasm.c", "commit_date": "2019-11-09 00:00:00", "repo_name": "mohuihui/antispy", "stars": 1067, "license": "other", "language": "c", "size": 4006}
{"docstring": "// Parse instruction flags, get opcode index\n", "func_signal": "int get_real_instruction(BYTE *addr, int *index, int *flags)", "code": "{\n\tswitch (*addr) {\n\n\t\t// 2-byte opcode\n\t\tcase 0x0f:\n\t\t\t*index += 1;\n\t\t\t*flags |= EXT_T2;\n\t\t\tbreak;\n\n\t\t// Prefix group 2\n\t\tcase 0x2e:\n\t\t\t*index += 1;\n\t\t\t// Clear previous flags from same group (undefined effect)\n\t\t\t*flags &= 0xFF00FFFF;\n\t\t\t*flags |= PREFIX_CS_OVERRIDE;\n\t\t\tget_real_instruction(addr + 1, index, flags);\n\t\t\tbreak;\n\t\tcase 0x36:\n\t\t\t*index += 1;\n\t\t\t*flags &= 0xFF00FFFF;\n\t\t\t*flags |= PREFIX_SS_OVERRIDE;\n\t\t\tget_real_instruction(addr + 1, index, flags);\n\t\t\tbreak;\n\t\tcase 0x3e:\n\t\t\t*index += 1;\n\t\t\t*flags &= 0xFF00FFFF;\n\t\t\t*flags |= PREFIX_DS_OVERRIDE;\n\t\t\tget_real_instruction(addr + 1, index, flags);\n\t\t\tbreak;\n\t\tcase 0x26:\n\t\t\t*index += 1;\n\t\t\t*flags &= 0xFF00FFFF;\n\t\t\t*flags |= PREFIX_ES_OVERRIDE;\n\t\t\tget_real_instruction(addr + 1, index, flags);\n\t\t\tbreak;\n\t\tcase 0x64:\n\t\t\t*index += 1;\n\t\t\t*flags &= 0xFF00FFFF;\n\t\t\t*flags |= PREFIX_FS_OVERRIDE;\n\t\t\tget_real_instruction(addr + 1, index, flags);\n\t\t\tbreak;\n\t\tcase 0x65:\n\t\t\t*index += 1;\n\t\t\t*flags &= 0xFF00FFFF;\n\t\t\t*flags |= PREFIX_GS_OVERRIDE;\n\t\t\tget_real_instruction(addr + 1, index, flags);\n\t\t\tbreak;\n\t\t// Prefix group 3 or 3-byte opcode\n\t\tcase 0x66:\n\t\t\t// Do not clear flags from the same group!!!!\n\t\t\t*index += 1;\n\t\t\t*flags |= PREFIX_OPERAND_SIZE_OVERRIDE;\n\t\t\tget_real_instruction(addr + 1, index, flags); \n\t\t\tbreak;\n\t\t// Prefix group 4\n\t\tcase 0x67:\n\t\t\t// Do not clear flags from the same group!!!!\n\t\t\t*index += 1;\n\t\t\t*flags |=  PREFIX_ADDR_SIZE_OVERRIDE;\n\t\t\tget_real_instruction(addr + 1, index, flags); \n\t\t\tbreak;\n\n\t\t// Extension group 1\n\t\tcase 0x80:\n\t\tcase 0x81:\n\t\tcase 0x82:\n\t\tcase 0x83:\n\t\t\t*flags |=  EXT_G1;\n\t\t\tbreak;\n\n\t\t// Extension group 2\n\t\tcase 0xc0:\n\t\tcase 0xc1:\n\t\tcase 0xd0:\n\t\tcase 0xd1:\n\t\tcase 0xd2:\n\t\tcase 0xd3:\n\t\t\t*flags |=  EXT_G2;\n\t\t\tbreak;\n\n\t\t// Escape to co-processor\n\t\tcase 0xd8:\n\t\tcase 0xd9:\n\t\tcase 0xda:\n\t\tcase 0xdb:\n\t\tcase 0xdc:\n\t\tcase 0xdd:\n\t\tcase 0xde:\n\t\tcase 0xdf:\n\t\t\t*index += 1;\n\t\t\t*flags |=  EXT_CP;\n\t\t\tbreak;\n\n\t\t// Prefix group 1 or 3-byte opcode\n\t\tcase 0xf0:\n\t\t\t*index += 1;\n\t\t\t*flags &= 0x00FFFFFF;\n\t\t\t*flags |=  PREFIX_LOCK;\n\t\t\tget_real_instruction(addr + 1, index, flags); \n\t\t\tbreak;\n\t\tcase 0xf2:\n\t\t\t*index += 1;\n\t\t\t*flags &= 0x00FFFFFF;\n\t\t\t*flags |=  PREFIX_REPNE;\n\t\t\tget_real_instruction(addr + 1, index, flags); \n\t\t\tbreak;\n\t\tcase 0xf3:\n\t\t\t*index += 1;\n\t\t\t*flags &= 0x00FFFFFF;\n\t\t\t*flags |=  PREFIX_REP;\n\t\t\tget_real_instruction(addr + 1, index, flags); \n\t\t\tbreak;\n\n\t\t// Extension group 3\n\t\tcase 0xf6:\n\t\tcase 0xf7:\n\t\t\t*flags |=  EXT_G3;\n\t\t\tbreak;\n\n\t\t// Extension group 4\n\t\tcase 0xfe:\n\t\t\t*flags |=  EXT_G4;\n\t\t\tbreak;\n\n\t\t// Extension group 5\n\t\tcase 0xff:\n\t\t\t*flags |=  EXT_G5;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn 0;\n}", "path": "antispy/src/Antispy/SpyHunter/SpyHunter/libdasm.c", "commit_date": "2019-11-09 00:00:00", "repo_name": "mohuihui/antispy", "stars": 1067, "license": "other", "language": "c", "size": 4006}
{"docstring": "/**\n * ntfs_inode_add_attrlist - add attribute list to inode and fill it\n * @ni: opened ntfs inode to which add attribute list\n *\n * Return 0 on success or -1 on error with errno set to the error code.\n * The following error codes are defined:\n *\tEINVAL\t- Invalid arguments were passed to the function.\n *\tEEXIST\t- Attribute list already exist.\n *\tEIO\t- Input/Ouput error occurred.\n *\tENOMEM\t- Not enough memory to perform add.\n */\n", "func_signal": "int ntfs_inode_add_attrlist(ntfs_inode *ni)", "code": "{\n\tint err;\n\tntfs_attr_search_ctx *ctx;\n\tu8 *al = NULL, *aln;\n\tint al_len = 0;\n\tATTR_LIST_ENTRY *ale = NULL;\n\tntfs_attr *na;\n\n\tif (!ni) {\n\t\tntfs_log_trace(\"Invalid arguments.\\n\");\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tntfs_log_trace(\"Entering for inode 0x%llx.\\n\", (LONG64) ni->mft_no);\n\n\tif (NInoAttrList(ni) || ni->nr_extents) {\n\t\tntfs_log_trace(\"Inode already has got attribute list.\\n\");\n\t\terrno = EEXIST;\n\t\treturn -1;\n\t}\n\n\t/* Form attribute list. */\n\tctx = ntfs_attr_get_search_ctx(ni, NULL);\n\tif (!ctx) {\n\t\terr = errno;\n\t\tntfs_log_trace(\"Couldn't get search context.\\n\");\n\t\tgoto err_out;\n\t}\n\n\t/* Walk through all attributes. */\n\twhile (!ntfs_attr_lookup(AT_UNUSED, NULL, 0, 0, 0, NULL, 0, ctx)) \n\t{\n\t\t\n\t\tint ale_size;\n\t\t\n\t\tif (ctx->attr->type == AT_ATTRIBUTE_LIST) \n\t\t{\n\t\t\terr = EIO;\n\t\t\tntfs_log_trace(\"Eeek! Attribute list already present.\\n\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t\t\n\t\tale_size = (sizeof(ATTR_LIST_ENTRY) + sizeof(ntfschar) * ctx->attr->name_length + 7) & ~7;\n\t\tal_len += ale_size;\n\t\t\n\t\taln = realloc(al, al_len);\n\t\tif (!aln) {\n\t\t\terr = errno;\n\t\t\tntfs_log_perror(\"Failed to realloc %d bytes\", al_len);\n\t\t\tgoto put_err_out;\n\t\t}\n\t\tale = (ATTR_LIST_ENTRY *)(aln + ((u8 *)ale - al));\n\t\tal = aln;\n\t\t\n\t\tmemset(ale, 0, ale_size);\n\t\t\n\t\t/* Add attribute to attribute list. */\n\t\tale->type = ctx->attr->type;\n\t\tale->length = cpu_to_le16((sizeof(ATTR_LIST_ENTRY) +\n\t\t\tsizeof(ntfschar) * ctx->attr->name_length + 7) & ~7);\n\t\tale->name_length = ctx->attr->name_length;\n\t\tale->name_offset = (u8 *)ale->name - (u8 *)ale;\n\t\tif (ctx->attr->non_resident)\n\t\t\tale->lowest_vcn = ctx->attr->X.lowest_vcn;\n\t\telse\n\t\t\tale->lowest_vcn = 0;\n\t\tale->mft_reference = MK_LE_MREF(ni->mft_no,\n\t\t\tle16_to_cpu(ni->mrec->sequence_number));\n\t\tale->instance = ctx->attr->instance;\n\t\tmemcpy(ale->name, (u8 *)ctx->attr +\n\t\t\t\tle16_to_cpu(ctx->attr->name_offset),\n\t\t\t\tctx->attr->name_length * sizeof(ntfschar));\n\t\tale = (ATTR_LIST_ENTRY *)(al + al_len);\n\t}\n\t/* Check for real error occurred. */\n\tif (errno != ENOENT) {\n\t\terr = errno;\n\t\tntfs_log_trace(\"Attribute lookup failed.\\n\");\n\t\tgoto put_err_out;\n\t}\n\n\t/* Set in-memory attribute list. */\n\tni->attr_list = al;\n\tni->attr_list_size = al_len;\n\tNInoSetAttrList(ni);\n\tNInoAttrListSetDirty(ni);\n\n\t/* Free space if there is not enough it for $ATTRIBUTE_LIST. */\n\tif (le32_to_cpu(ni->mrec->bytes_allocated) -\n\t\t\tle32_to_cpu(ni->mrec->bytes_in_use) <\n\t\t\toffsetof(ATTR_RECORD, X.resident_end)) {\n\t\tif (ntfs_inode_free_space(ni,\n\t\t\t\toffsetof(ATTR_RECORD, X.resident_end))) {\n\t\t\t/* Failed to free space. */\n\t\t\terr = errno;\n\t\t\tntfs_log_trace(\"Failed to free space for $ATTRIBUTE_LIST.\\n\");\n\t\t\tgoto rollback;\n\t\t}\n\t}\n\n\t/* Add $ATTRIBUTE_LIST to mft record. */\n\tif (ntfs_resident_attr_record_add(ni,\n\t\t\t\tAT_ATTRIBUTE_LIST, NULL, 0, NULL, 0, 0) < 0) {\n\t\terr = errno;\n\t\tntfs_log_trace(\"Couldn't add $ATTRIBUTE_LIST to MFT record.\\n\");\n\t\tgoto rollback;\n\t}\n\n\t/* Resize it. */\n\tna = ntfs_attr_open(ni, AT_ATTRIBUTE_LIST, AT_UNNAMED, 0);\n\tif (!na) {\n\t\terr = errno;\n\t\tntfs_log_trace(\"Failed to open just added $ATTRIBUTE_LIST.\\n\");\n\t\tgoto remove_attrlist_record;\n\t}\n\tif (ntfs_attr_truncate(na, al_len)) {\n\t\terr = errno;\n\t\tntfs_log_trace(\"Failed to resize just added $ATTRIBUTE_LIST.\\n\");\n\t\tntfs_attr_close(na);\n\t\tgoto remove_attrlist_record;;\n\t}\n\t\n\tntfs_attr_put_search_ctx(ctx);\n\tntfs_attr_close(na);\n\treturn 0;\n\nremove_attrlist_record:\n\t/* Prevent ntfs_attr_recorm_rm from freeing attribute list. */\n\tni->attr_list = NULL;\n\tNInoClearAttrList(ni);\n\t/* Remove $ATTRIBUTE_LIST record. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\tif (!ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx)) {\n\t\tif (ntfs_attr_record_rm(ctx))\n\t\t\tntfs_log_trace(\"Rollback failed. Failed to remove attribute list record.\\n\");\n\t} else\n\t\tntfs_log_trace(\"Rollback failed. Couldn't find attribute list record.\\n\");\n\t/* Setup back in-memory runlist. */\n\tni->attr_list = al;\n\tni->attr_list_size = al_len;\n\tNInoSetAttrList(ni);\nrollback:\n\t/*\n\t * Scan attribute list for attributes that placed not in the base MFT\n\t * record and move them to it.\n\t */\n\tntfs_attr_reinit_search_ctx(ctx);\n\tale = (ATTR_LIST_ENTRY*)al;\n\twhile ((u8*)ale < al + al_len) \n\t{\n\t\tif (MREF_LE(ale->mft_reference) != ni->mft_no)\n\t\t{\n\t\t\tif (!ntfs_attr_lookup(ale->type, ale->name,\n\t\t\t\t\t\tale->name_length,\n\t\t\t\t\t\tCASE_SENSITIVE,\n\t\t\t\t\t\tsle64_to_cpu(ale->lowest_vcn),\n\t\t\t\t\t\tNULL, 0, ctx)) {\n\t\t\t\tif (ntfs_attr_record_move_to(ctx, ni))\n\t\t\t\t\tntfs_log_trace(\"Rollback failed. Couldn't back attribute to base MFT record.\\n\");\n\t\t\t} else {\n\t\t\t\tntfs_log_trace(\"Rollback failed. ntfs_attr_lookup failed.\\n\");\n\t\t\t}\n\n\t\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\t}\n\n\t\tale = (ATTR_LIST_ENTRY*)((u8*)ale + le16_to_cpu(ale->length));\n\t}\n\t/* Remove in-memory attribute list. */\n\tni->attr_list = NULL;\n\tni->attr_list_size = 0;\n\tNInoClearAttrList(ni);\n\tNInoAttrListClearDirty(ni);\nput_err_out:\n\tntfs_attr_put_search_ctx(ctx);\nerr_out:\n\tfree(al);\n\terrno = err;\n\treturn -1;\n}", "path": "antispy/src/Antispy/SpyHunter/SpyHunter/ntfs/inode.c", "commit_date": "2019-11-09 00:00:00", "repo_name": "mohuihui/antispy", "stars": 1067, "license": "other", "language": "c", "size": 4006}
{"docstring": "// \n// \u0239NT\u02b5\u05b9\u07fb\u05b8\n//\n", "func_signal": "NTSTATUS WinXpAndLaterSuspendOrResumeProcess(PEPROCESS pEprocess, BOOL bSuspend)", "code": "{\n\tNTSTATUS status = STATUS_UNSUCCESSFUL;\n\tpfnObOpenObjectByPointer MzfObOpenObjectByPointer = (pfnObOpenObjectByPointer)GetGlobalVeriable(enumObOpenObjectByPointer);\n\tpfnNtClose MzfNtClose = (pfnNtClose)GetGlobalVeriable(enumNtClose);\n\tpfnPsGetCurrentThread MzfPsGetCurrentThread = (pfnPsGetCurrentThread)GetGlobalVeriable(enumPsGetCurrentThread);\n\tpfnNtResumeProcess MzfNtResumeProcess = (pfnNtResumeProcess)GetGlobalVeriable(enumNtResumeProcess);\n\tpfnNtSuspendProcess MzfNtSuspendProcess = (pfnNtSuspendProcess)GetGlobalVeriable(enumNtSuspendProcess);\n\tPOBJECT_TYPE ProcessType = (POBJECT_TYPE)GetGlobalVeriable(enumPsProcessType);\n\tHANDLE hProcess;\n\t\n\tif (!MzfNtClose\t\t\t\t\t||\n\t\t!MzfObOpenObjectByPointer\t||\n\t\t!MzfPsGetCurrentThread\t\t||\n\t\t!ProcessType\t\t\t\t||\n\t\t!MzfNtResumeProcess\t\t\t||\n\t\t!MzfNtSuspendProcess) \n\t{\n\t\treturn status;\n\t}\n\n\tstatus = MzfObOpenObjectByPointer(pEprocess, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, GENERIC_ALL, ProcessType, KernelMode, &hProcess);\n\tif (NT_SUCCESS(status))\n\t{\n\t\tPETHREAD pThread = MzfPsGetCurrentThread();\n\t\tCHAR PreMode = ChangePreMode(pThread);\n\n\t\tif (bSuspend)\n\t\t{\n\t\t\tstatus = MzfNtSuspendProcess(hProcess);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstatus = MzfNtResumeProcess(hProcess);\n\t\t}\n\n\t\tMzfNtClose(hProcess);\n\t\tRecoverPreMode(pThread, PreMode);\n\t}\n\n\treturn status;\n}", "path": "antispy/src/Antispy/SpyHunterDrv/SpyHunterDrv/Process.c", "commit_date": "2019-11-09 00:00:00", "repo_name": "mohuihui/antispy", "stars": 1067, "license": "other", "language": "c", "size": 4006}
{"docstring": "/***************************************************************************\n*\n*  Function: objectIndex\n*  ****/\n", "func_signal": "int objectIndex( lua_State * L )", "code": "{\n   lua_Number stateIndex;\n   const char * key;\n   jmethodID method;\n   jint checkField;\n   jobject * obj;\n   jstring str;\n   jthrowable exp;\n   JNIEnv * javaEnv;\n\n   /* Gets the luaState index */\n   lua_pushstring( L , LUAJAVASTATEINDEX );\n   lua_rawget( L , LUA_REGISTRYINDEX );\n\n   if ( !lua_isnumber( L , -1 ) )\n   {\n      lua_pushstring( L , \"Impossible to identify luaState id.\" );\n      lua_error( L );\n   }\n\n   stateIndex = lua_tonumber( L , -1 );\n   lua_pop( L , 1 );\n\n   if ( !lua_isstring( L , -1 ) )\n   {\n      lua_pushstring( L , \"Invalid Function call.\" );\n      lua_error( L );\n   }\n\n   key = lua_tostring( L , -1 );\n\n   if ( !isJavaObject( L , 1 ) )\n   {\n      lua_pushstring( L , \"Not a valid Java Object.\" );\n      lua_error( L );\n   }\n\n   javaEnv = getEnvFromState( L );\n   if ( javaEnv == NULL )\n   {\n      lua_pushstring( L , \"Invalid JNI Environment.\" );\n      lua_error( L );\n   }\n\n   obj = ( jobject * ) lua_touserdata( L , 1 );\n\n   method = ( *javaEnv )->GetStaticMethodID( javaEnv , luajava_api_class , \"checkField\" ,\n                                             \"(ILjava/lang/Object;Ljava/lang/String;)I\" );\n\n   str = ( *javaEnv )->NewStringUTF( javaEnv , key );\n\n   checkField = ( *javaEnv )->CallStaticIntMethod( javaEnv , luajava_api_class , method ,\n                                                   (jint)stateIndex , *obj , str );\n\n   exp = ( *javaEnv )->ExceptionOccurred( javaEnv );\n\n   /* Handles exception */\n   if ( exp != NULL )\n   {\n      jobject jstr;\n      const char * cStr;\n      \n      ( *javaEnv )->ExceptionClear( javaEnv );\n      jstr = ( *javaEnv )->CallObjectMethod( javaEnv , exp , get_message_method );\n\n      ( *javaEnv )->DeleteLocalRef( javaEnv , str );\n\n      if ( jstr == NULL )\n      {\n         jmethodID methodId;\n\n         methodId = ( *javaEnv )->GetMethodID( javaEnv , throwable_class , \"toString\" , \"()Ljava/lang/String;\" );\n         jstr = ( *javaEnv )->CallObjectMethod( javaEnv , exp , methodId );\n      }\n\n      cStr = ( *javaEnv )->GetStringUTFChars( javaEnv , jstr , NULL );\n\n      lua_pushstring( L , cStr );\n\n      ( *javaEnv )->ReleaseStringUTFChars( javaEnv , jstr, cStr );\n\n      lua_error( L );\n   }\n\n   ( *javaEnv )->DeleteLocalRef( javaEnv , str );\n\n   if ( checkField != 0 )\n   {\n      return checkField;\n   }\n\n   lua_getmetatable( L , 1 );\n\n   if ( !lua_istable( L , -1 ) )\n   {\n      lua_pushstring( L , \"Invalid MetaTable.\" );\n      lua_error( L );\n   }\n\n   lua_pushstring( L , LUAJAVAOBJFUNCCALLED );\n   lua_pushstring( L , key );\n   lua_rawset( L , -3 );\n\n   lua_pop( L , 1 );\n\n   lua_pushcfunction( L , &objectIndexReturn );\n\n   return 1;\n}", "path": "AndroLua/jni/luajava/luajava.c", "commit_date": "2011-02-03 00:00:00", "repo_name": "mkottman/AndroLua", "stars": 1038, "license": "mit", "language": "c", "size": 674}
{"docstring": "/************************************************************************\n*   JNI Called function\n*      Lua Exported Function\n************************************************************************/\n", "func_signal": "JNIEXPORT void JNICALL Java_org_keplerproject_luajava_LuaState__1setTable\n  (JNIEnv * env , jobject jobj , jobject cptr , jint idx)", "code": "{\n   lua_State * L = getStateFromCPtr( env , cptr );\n\n   lua_settable( L , ( int ) idx );\n}", "path": "AndroLua/jni/luajava/luajava.c", "commit_date": "2011-02-03 00:00:00", "repo_name": "mkottman/AndroLua", "stars": 1038, "license": "mit", "language": "c", "size": 674}
{"docstring": "/***************************************************************************\n*\n*  Function: javaLoadLib\n*  ****/\n", "func_signal": "int javaLoadLib( lua_State * L )", "code": "{\n   jint ret;\n   int top;\n   const char * className, * methodName;\n   lua_Number stateIndex;\n   jmethodID method;\n   jthrowable exp;\n   jstring javaClassName , javaMethodName;\n   JNIEnv * javaEnv;\n\n   top = lua_gettop( L );\n\n   if ( top != 2 )\n   {\n      lua_pushstring( L , \"Error. Invalid number of parameters.\" );\n      lua_error( L );\n   }\n\n   /* Gets the luaState index */\n   lua_pushstring( L , LUAJAVASTATEINDEX );\n   lua_rawget( L , LUA_REGISTRYINDEX );\n\n   if ( !lua_isnumber( L , -1 ) )\n   {\n      lua_pushstring( L , \"Impossible to identify luaState id.\" );\n      lua_error( L );\n   }\n\n   stateIndex = lua_tonumber( L , -1 );\n   lua_pop( L , 1 );\n\n\n   if ( !lua_isstring( L , 1 ) || !lua_isstring( L , 2 ) )\n   {\n      lua_pushstring( L , \"Invalid parameter. Strings expected.\" );\n      lua_error( L );\n   }\n\n   className  = lua_tostring( L , 1 );\n   methodName = lua_tostring( L , 2 );\n\n   /* Gets the JNI Environment */\n   javaEnv = getEnvFromState( L );\n   if ( javaEnv == NULL )\n   {\n      lua_pushstring( L , \"Invalid JNI Environment.\" );\n      lua_error( L );\n   }\n\n   method = ( *javaEnv )->GetStaticMethodID( javaEnv , luajava_api_class , \"javaLoadLib\" ,\n                                             \"(ILjava/lang/String;Ljava/lang/String;)I\" );\n\n   javaClassName  = ( *javaEnv )->NewStringUTF( javaEnv , className );\n   javaMethodName = ( *javaEnv )->NewStringUTF( javaEnv , methodName );\n   \n   ret = ( *javaEnv )->CallStaticIntMethod( javaEnv , luajava_api_class , method, (jint)stateIndex , \n                                            javaClassName , javaMethodName );\n\n   exp = ( *javaEnv )->ExceptionOccurred( javaEnv );\n\n   /* Handles exception */\n   if ( exp != NULL )\n   {\n      jobject jstr;\n      const char * str;\n      \n      ( *javaEnv )->ExceptionClear( javaEnv );\n      jstr = ( *javaEnv )->CallObjectMethod( javaEnv , exp , get_message_method );\n\n      ( *javaEnv )->DeleteLocalRef( javaEnv , javaClassName );\n      ( *javaEnv )->DeleteLocalRef( javaEnv , javaMethodName );\n\n      if ( jstr == NULL )\n      {\n         jmethodID methodId;\n\n         methodId = ( *javaEnv )->GetMethodID( javaEnv , throwable_class , \"toString\" , \"()Ljava/lang/String;\" );\n         jstr = ( *javaEnv )->CallObjectMethod( javaEnv , exp , methodId );\n      }\n\n      str = ( *javaEnv )->GetStringUTFChars( javaEnv , jstr , NULL );\n\n      lua_pushstring( L , str );\n\n      ( *javaEnv )->ReleaseStringUTFChars( javaEnv , jstr, str );\n\n      lua_error( L );\n   }\n\n   ( *javaEnv )->DeleteLocalRef( javaEnv , javaClassName );\n   ( *javaEnv )->DeleteLocalRef( javaEnv , javaMethodName );\n\n   return ret;\n}", "path": "AndroLua/jni/luajava/luajava.c", "commit_date": "2011-02-03 00:00:00", "repo_name": "mkottman/AndroLua", "stars": 1038, "license": "mit", "language": "c", "size": 674}
{"docstring": "/************************************************************************\n*   JNI Called function\n*      Lua Exported Function\n************************************************************************/\n", "func_signal": "JNIEXPORT void JNICALL Java_org_keplerproject_luajava_LuaState__1rawSetI\n  (JNIEnv * env , jobject jobj , jobject cptr , jint idx, jint n)", "code": "{\n   lua_State * L = getStateFromCPtr( env , cptr );\n\n   lua_rawseti( L , idx , n );\n}", "path": "AndroLua/jni/luajava/luajava.c", "commit_date": "2011-02-03 00:00:00", "repo_name": "mkottman/AndroLua", "stars": 1038, "license": "mit", "language": "c", "size": 674}
{"docstring": "/************************************************************************\n*   JNI Called function\n*      Lua Exported Function\n************************************************************************/\n", "func_signal": "JNIEXPORT jint JNICALL Java_org_keplerproject_luajava_LuaState__1gc\n  (JNIEnv * env , jobject jobj , jobject cptr , jint what , jint data)", "code": "{\n   lua_State * L = getStateFromCPtr( env , cptr );\n\n   return ( jint ) lua_gc( L , what , data );\n}", "path": "AndroLua/jni/luajava/luajava.c", "commit_date": "2011-02-03 00:00:00", "repo_name": "mkottman/AndroLua", "stars": 1038, "license": "mit", "language": "c", "size": 674}
{"docstring": "/************************************************************************\n*   JNI Called function\n*      Lua Exported Function\n************************************************************************/\n", "func_signal": "JNIEXPORT void JNICALL Java_org_keplerproject_luajava_LuaState__1remove\n  (JNIEnv * env , jobject jobj , jobject cptr , jint idx)", "code": "{\n   lua_State * L = getStateFromCPtr( env , cptr );\n\n   lua_remove( L , ( int ) idx );\n}", "path": "AndroLua/jni/luajava/luajava.c", "commit_date": "2011-02-03 00:00:00", "repo_name": "mkottman/AndroLua", "stars": 1038, "license": "mit", "language": "c", "size": 674}
{"docstring": "/************************************************************************\n*   JNI Called function\n*      Lua Exported Function\n************************************************************************/\n", "func_signal": "JNIEXPORT void JNICALL Java_org_keplerproject_luajava_LuaState__1pushValue\n  (JNIEnv * env , jobject jobj , jobject cptr , jint idx)", "code": "{\n   lua_State * L = getStateFromCPtr( env , cptr );\n\n   lua_pushvalue( L , ( int ) idx );\n}", "path": "AndroLua/jni/luajava/luajava.c", "commit_date": "2011-02-03 00:00:00", "repo_name": "mkottman/AndroLua", "stars": 1038, "license": "mit", "language": "c", "size": 674}
{"docstring": "/************************************************************************\n*   JNI Called function\n*      LuaJava API Functin\n************************************************************************/\n", "func_signal": "JNIEXPORT jobject JNICALL Java_org_keplerproject_luajava_LuaState__1getObjectFromUserdata\n  (JNIEnv * env , jobject jobj , jobject cptr , jint index )", "code": "{\n   /* Get luastate */\n   lua_State * L = getStateFromCPtr( env , cptr );\n   jobject *   obj;\n\n   if ( !isJavaObject( L , index ) )\n   {\n      ( *env )->ThrowNew( env , ( *env )->FindClass( env , \"java/lang/Exception\" ) ,\n                          \"Index is not a java object\" );\n      return NULL;\n   }\n\n   obj = ( jobject * ) lua_touserdata( L , index );\n\n   return *obj;\n}", "path": "AndroLua/jni/luajava/luajava.c", "commit_date": "2011-02-03 00:00:00", "repo_name": "mkottman/AndroLua", "stars": 1038, "license": "mit", "language": "c", "size": 674}
{"docstring": "/* LUA_NUMBER */\n", "func_signal": "static void read_numeral (LexState *ls, SemInfo *seminfo)", "code": "{\n  lua_assert(isdigit(ls->current));\n  do {\n    save_and_next(ls);\n  } while (isdigit(ls->current) || ls->current == '.');\n  if (check_next(ls, \"Ee\"))  /* `E'? */\n    check_next(ls, \"+-\");  /* optional exponent sign */\n  while (isalnum(ls->current) || ls->current == '_')\n    save_and_next(ls);\n  save(ls, '\\0');\n  buffreplace(ls, '.', ls->decpoint);  /* follow locale for decimal point */\n  if (!luaO_str2d(luaZ_buffer(ls->buff), &seminfo->r))  /* format error? */\n    trydecpoint(ls, seminfo); /* try to update decimal point separator */\n}", "path": "AndroLua/jni/lua/llex.c", "commit_date": "2013-01-24 00:00:00", "repo_name": "mkottman/AndroLua", "stars": 1038, "license": "mit", "language": "c", "size": 674}
{"docstring": "/************************************************************************\n*   JNI Called function\n*      Lua Exported Function\n************************************************************************/\n", "func_signal": "JNIEXPORT void JNICALL Java_org_keplerproject_luajava_LuaState__1newTable\n  (JNIEnv * env , jobject jobj , jobject cptr)", "code": "{\n   lua_State * L = getStateFromCPtr( env , cptr );\n\n   lua_newtable( L );\n}", "path": "AndroLua/jni/luajava/luajava.c", "commit_date": "2011-02-03 00:00:00", "repo_name": "mkottman/AndroLua", "stars": 1038, "license": "mit", "language": "c", "size": 674}
{"docstring": "/************************************************************************\n*   JNI Called function\n*      Lua Exported Function\n************************************************************************/\n", "func_signal": "JNIEXPORT void JNICALL Java_org_keplerproject_luajava_LuaState__1concat\n  (JNIEnv * env , jobject jobj , jobject cptr , jint n)", "code": "{\n   lua_State * L = getStateFromCPtr( env , cptr );\n\n   lua_concat( L , n );\n}", "path": "AndroLua/jni/luajava/luajava.c", "commit_date": "2011-02-03 00:00:00", "repo_name": "mkottman/AndroLua", "stars": 1038, "license": "mit", "language": "c", "size": 674}
{"docstring": "/************************************************************************\n*   JNI Called function\n*      Lua Exported Function\n************************************************************************/\n", "func_signal": "JNIEXPORT jint JNICALL Java_org_keplerproject_luajava_LuaState__1type\n  (JNIEnv * env , jobject jobj , jobject cptr , jint idx)", "code": "{\n   lua_State * L = getStateFromCPtr( env , cptr );\n\n   return ( jint ) lua_type( L , ( int ) idx );\n}", "path": "AndroLua/jni/luajava/luajava.c", "commit_date": "2011-02-03 00:00:00", "repo_name": "mkottman/AndroLua", "stars": 1038, "license": "mit", "language": "c", "size": 674}
{"docstring": "/************************************************************************\n*   JNI Called function\n*      Lua Exported Function\n************************************************************************/\n", "func_signal": "JNIEXPORT void JNICALL Java_org_keplerproject_luajava_LuaState__1setField\n  (JNIEnv * env , jobject jobj , jobject cptr , jint idx , jstring k)", "code": "{\n   lua_State * L = getStateFromCPtr( env , cptr );\n\n   const char * uniStr;\n   uniStr =  ( *env )->GetStringUTFChars( env , k , NULL );\n\n   lua_setfield( L , ( int ) idx , uniStr );\n   \n   ( *env )->ReleaseStringUTFChars( env , k , uniStr );\n}", "path": "AndroLua/jni/luajava/luajava.c", "commit_date": "2011-02-03 00:00:00", "repo_name": "mkottman/AndroLua", "stars": 1038, "license": "mit", "language": "c", "size": 674}
{"docstring": "/************************************************************************\n*   JNI Called function\n*      Lua Exported Function\n************************************************************************/\n", "func_signal": "JNIEXPORT jint JNICALL Java_org_keplerproject_luajava_LuaState__1LloadBuffer\n  (JNIEnv * env , jobject jobj , jobject cptr , jbyteArray buff , jlong sz , jstring n)", "code": "{\n   lua_State * L = getStateFromCPtr( env , cptr );\n   jbyte * cBuff = ( *env )->GetByteArrayElements( env , buff, NULL );\n   const char * name = ( * env )->GetStringUTFChars( env , n , NULL );\n   int ret;\n\n   ret = luaL_loadbuffer( L , ( const char * ) cBuff, ( int ) sz, name );\n\n   ( *env )->ReleaseStringUTFChars( env , n , name );\n\n   ( *env )->ReleaseByteArrayElements( env , buff , cBuff , 0 );\n\n   return ( jint ) ret;\n}", "path": "AndroLua/jni/luajava/luajava.c", "commit_date": "2011-02-03 00:00:00", "repo_name": "mkottman/AndroLua", "stars": 1038, "license": "mit", "language": "c", "size": 674}
{"docstring": "/************************************************************************\n*   JNI Called function\n*      Lua Exported Function\n************************************************************************/\n", "func_signal": "JNIEXPORT jint JNICALL Java_org_keplerproject_luajava_LuaState__1isString\n  (JNIEnv * env , jobject jobj , jobject cptr , jint idx)", "code": "{\n   lua_State * L = getStateFromCPtr( env , cptr );\n\n   return ( jint ) lua_isstring( L , ( int ) idx );\n}", "path": "AndroLua/jni/luajava/luajava.c", "commit_date": "2011-02-03 00:00:00", "repo_name": "mkottman/AndroLua", "stars": 1038, "license": "mit", "language": "c", "size": 674}
{"docstring": "/************************************************************************\n*   JNI Called function\n*      Lua Exported Function\n************************************************************************/\n", "func_signal": "JNIEXPORT jint JNICALL Java_org_keplerproject_luajava_LuaState__1LgetN\n  (JNIEnv * env , jobject jobj , jobject cptr , jint t)", "code": "{\n   lua_State * L = getStateFromCPtr( env , cptr );\n\n   return ( jint ) luaL_getn( L , ( int ) t );\n}", "path": "AndroLua/jni/luajava/luajava.c", "commit_date": "2011-02-03 00:00:00", "repo_name": "mkottman/AndroLua", "stars": 1038, "license": "mit", "language": "c", "size": 674}
{"docstring": "/************************************************************************\n*   JNI Called function\n*      Lua Exported Function\n************************************************************************/\n", "func_signal": "JNIEXPORT jobject JNICALL Java_org_keplerproject_luajava_LuaState__1open\n  (JNIEnv * env , jobject jobj)", "code": "{\n   lua_State * L = lua_open();\n\n   jobject obj;\n   jclass tempClass;\n\n   tempClass = ( *env )->FindClass( env , \"org/keplerproject/luajava/CPtr\" );\n    \n   obj = ( *env )->AllocObject( env , tempClass );\n   if ( obj )\n   {\n      ( *env )->SetLongField( env , obj , ( *env )->GetFieldID( env , tempClass , \"peer\", \"J\" ) , ( jlong ) L );\n   }\n   return obj;\n\n}", "path": "AndroLua/jni/luajava/luajava.c", "commit_date": "2011-02-03 00:00:00", "repo_name": "mkottman/AndroLua", "stars": 1038, "license": "mit", "language": "c", "size": 674}
{"docstring": "/* --------------------------------------------------------------- read --- */\n", "func_signal": "size_t luaZ_read (ZIO *z, void *b, size_t n)", "code": "{\n  while (n) {\n    size_t m;\n    if (luaZ_lookahead(z) == EOZ)\n      return n;  /* return number of missing bytes */\n    m = (n <= z->n) ? n : z->n;  /* min. between n and z->n */\n    memcpy(b, z->p, m);\n    z->n -= m;\n    z->p += m;\n    b = (char *)b + m;\n    n -= m;\n  }\n  return 0;\n}", "path": "AndroLua/jni/lua/lzio.c", "commit_date": "2011-02-03 00:00:00", "repo_name": "mkottman/AndroLua", "stars": 1038, "license": "mit", "language": "c", "size": 674}
{"docstring": "/************************************************************************\n*   JNI Called function\n*      Lua Exported Function\n************************************************************************/\n", "func_signal": "JNIEXPORT jint JNICALL Java_org_keplerproject_luajava_LuaState__1getGcCount\n  (JNIEnv * env , jobject jobj , jobject cptr)", "code": "{\n   lua_State * L = getStateFromCPtr( env , cptr );\n\n   return ( jint ) lua_getgccount( L );\n}", "path": "AndroLua/jni/luajava/luajava.c", "commit_date": "2011-02-03 00:00:00", "repo_name": "mkottman/AndroLua", "stars": 1038, "license": "mit", "language": "c", "size": 674}
{"docstring": "/************************************************************************\n*   JNI Called function\n*      Lua Exported Function\n************************************************************************/\n", "func_signal": "JNIEXPORT void JNICALL Java_org_keplerproject_luajava_LuaState__1replace\n  (JNIEnv * env , jobject jobj , jobject cptr , jint idx)", "code": "{\n   lua_State * L = getStateFromCPtr( env , cptr );\n\n   lua_replace( L , ( int ) idx );\n}", "path": "AndroLua/jni/luajava/luajava.c", "commit_date": "2011-02-03 00:00:00", "repo_name": "mkottman/AndroLua", "stars": 1038, "license": "mit", "language": "c", "size": 674}
{"docstring": "/* Search for a node which is duplicated from the node ORG_NODE, and\n   satisfies the constraint CONSTRAINT.  */\n", "func_signal": "static int\nsearch_duplicated_node (const re_dfa_t *dfa, int org_node,\n\t\t\tunsigned int constraint)", "code": "{\n  int idx;\n  for (idx = dfa->nodes_len - 1; dfa->nodes[idx].duplicated && idx > 0; --idx)\n    {\n      if (org_node == dfa->org_indices[idx]\n\t  && constraint == dfa->nodes[idx].constraint)\n\treturn idx; /* Found.  */\n    }\n  return -1; /* Not found.  */\n}", "path": "direwolf/external/regex/regcomp.c", "commit_date": "2019-12-01 00:00:00", "repo_name": "wb2osz/direwolf", "stars": 1440, "license": "gpl-2.0", "language": "c", "size": 142385}
{"docstring": "/* Internal entry point.\n   Compile the regular expression PATTERN, whose length is LENGTH.\n   SYNTAX indicate regular expression's syntax.  */\n", "func_signal": "static reg_errcode_t\nre_compile_internal (regex_t *preg, const char * pattern, size_t length,\n\t\t     reg_syntax_t syntax)", "code": "{\n  reg_errcode_t err = REG_NOERROR;\n  re_dfa_t *dfa;\n  re_string_t regexp;\n\n  /* Initialize the pattern buffer.  */\n  preg->fastmap_accurate = 0;\n  preg->syntax = syntax;\n  preg->not_bol = preg->not_eol = 0;\n  preg->used = 0;\n  preg->re_nsub = 0;\n  preg->can_be_null = 0;\n  preg->regs_allocated = REGS_UNALLOCATED;\n\n  /* Initialize the dfa.  */\n  dfa = (re_dfa_t *) preg->buffer;\n  if (BE (preg->allocated < sizeof (re_dfa_t), 0))\n    {\n      /* If zero allocated, but buffer is non-null, try to realloc\n\t enough space.  This loses if buffer's address is bogus, but\n\t that is the user's responsibility.  If ->buffer is NULL this\n\t is a simple allocation.  */\n      dfa = re_realloc (preg->buffer, re_dfa_t, 1);\n      if (dfa == NULL)\n\treturn REG_ESPACE;\n      preg->allocated = sizeof (re_dfa_t);\n      preg->buffer = (unsigned char *) dfa;\n    }\n  preg->used = sizeof (re_dfa_t);\n\n  err = init_dfa (dfa, length);\n  if (BE (err != REG_NOERROR, 0))\n    {\n      free_dfa_content (dfa);\n      preg->buffer = NULL;\n      preg->allocated = 0;\n      return err;\n    }\n#ifdef DEBUG\n  /* Note: length+1 will not overflow since it is checked in init_dfa.  */\n  dfa->re_str = re_malloc (char, length + 1);\n  strncpy (dfa->re_str, pattern, length + 1);\n#endif\n\n  __libc_lock_init (dfa->lock);\n\n  err = re_string_construct (&regexp, pattern, length, preg->translate,\n\t\t\t     syntax & RE_ICASE, dfa);\n  if (BE (err != REG_NOERROR, 0))\n    {\n    re_compile_internal_free_return:\n      free_workarea_compile (preg);\n      re_string_destruct (&regexp);\n      free_dfa_content (dfa);\n      preg->buffer = NULL;\n      preg->allocated = 0;\n      return err;\n    }\n\n  /* Parse the regular expression, and build a structure tree.  */\n  preg->re_nsub = 0;\n  dfa->str_tree = parse (&regexp, preg, syntax, &err);\n  if (BE (dfa->str_tree == NULL, 0))\n    goto re_compile_internal_free_return;\n\n  /* Analyze the tree and create the nfa.  */\n  err = analyze (preg);\n  if (BE (err != REG_NOERROR, 0))\n    goto re_compile_internal_free_return;\n\n#ifdef RE_ENABLE_I18N\n  /* If possible, do searching in single byte encoding to speed things up.  */\n  if (dfa->is_utf8 && !(syntax & RE_ICASE) && preg->translate == NULL)\n    optimize_utf8 (dfa);\n#endif\n\n  /* Then create the initial state of the dfa.  */\n  err = create_initial_state (dfa);\n\n  /* Release work areas.  */\n  free_workarea_compile (preg);\n  re_string_destruct (&regexp);\n\n  if (BE (err != REG_NOERROR, 0))\n    {\n      free_dfa_content (dfa);\n      preg->buffer = NULL;\n      preg->allocated = 0;\n    }\n\n  return err;\n}", "path": "direwolf/external/regex/regcomp.c", "commit_date": "2019-12-01 00:00:00", "repo_name": "wb2osz/direwolf", "stars": 1440, "license": "gpl-2.0", "language": "c", "size": 142385}
{"docstring": "/* Calculate \"eclosure\" for all the node in DFA.  */\n", "func_signal": "static reg_errcode_t\ncalc_eclosure (re_dfa_t *dfa)", "code": "{\n  int node_idx, incomplete;\n#ifdef DEBUG\n  assert (dfa->nodes_len > 0);\n#endif\n  incomplete = 0;\n  /* For each nodes, calculate epsilon closure.  */\n  for (node_idx = 0; ; ++node_idx)\n    {\n      reg_errcode_t err;\n      re_node_set eclosure_elem;\n      if (node_idx == dfa->nodes_len)\n\t{\n\t  if (!incomplete)\n\t    break;\n\t  incomplete = 0;\n\t  node_idx = 0;\n\t}\n\n#ifdef DEBUG\n      assert (dfa->eclosures[node_idx].nelem != -1);\n#endif\n\n      /* If we have already calculated, skip it.  */\n      if (dfa->eclosures[node_idx].nelem != 0)\n\tcontinue;\n      /* Calculate epsilon closure of `node_idx'.  */\n      err = calc_eclosure_iter (&eclosure_elem, dfa, node_idx, 1);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n\n      if (dfa->eclosures[node_idx].nelem == 0)\n\t{\n\t  incomplete = 1;\n\t  re_node_set_free (&eclosure_elem);\n\t}\n    }\n  return REG_NOERROR;\n}", "path": "direwolf/external/regex/regcomp.c", "commit_date": "2019-12-01 00:00:00", "repo_name": "wb2osz/direwolf", "stars": 1440, "license": "gpl-2.0", "language": "c", "size": 142385}
{"docstring": "/* This function build the following tree, from regular expression\n   (<reg_exp>):\n\t SUBEXP\n\t    |\n\t<reg_exp>\n*/\n", "func_signal": "static bin_tree_t *\nparse_sub_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, int nest, reg_errcode_t *err)", "code": "{\n  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;\n  bin_tree_t *tree;\n  size_t cur_nsub;\n  cur_nsub = preg->re_nsub++;\n\n  fetch_token (token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n\n  /* The subexpression may be a null string.  */\n  if (token->type == OP_CLOSE_SUBEXP)\n    tree = NULL;\n  else\n    {\n      tree = parse_reg_exp (regexp, preg, token, syntax, nest, err);\n      if (BE (*err == REG_NOERROR && token->type != OP_CLOSE_SUBEXP, 0))\n        *err = REG_EPAREN;\n      if (BE (*err != REG_NOERROR, 0))\n\treturn NULL;\n    }\n\n  if (cur_nsub <= '9' - '1')\n    dfa->completed_bkref_map |= 1 << cur_nsub;\n\n  tree = create_tree (dfa, tree, NULL, SUBEXP);\n  if (BE (tree == NULL, 0))\n    {\n      *err = REG_ESPACE;\n      return NULL;\n    }\n  tree->token.opr.idx = cur_nsub;\n  return tree;\n}", "path": "direwolf/external/regex/regcomp.c", "commit_date": "2019-12-01 00:00:00", "repo_name": "wb2osz/direwolf", "stars": 1440, "license": "gpl-2.0", "language": "c", "size": 142385}
{"docstring": "/* Parse an element in the bracket expression.  */\n", "func_signal": "static reg_errcode_t\nparse_bracket_element (bracket_elem_t *elem, re_string_t *regexp,\n\t\t       re_token_t *token, int token_len, re_dfa_t *dfa,\n\t\t       reg_syntax_t syntax, int accept_hyphen)", "code": "{\n#ifdef RE_ENABLE_I18N\n  int cur_char_size;\n  cur_char_size = re_string_char_size_at (regexp, re_string_cur_idx (regexp));\n  if (cur_char_size > 1)\n    {\n      elem->type = MB_CHAR;\n      elem->opr.wch = re_string_wchar_at (regexp, re_string_cur_idx (regexp));\n      re_string_skip_bytes (regexp, cur_char_size);\n      return REG_NOERROR;\n    }\n#endif /* RE_ENABLE_I18N */\n  re_string_skip_bytes (regexp, token_len); /* Skip a token.  */\n  if (token->type == OP_OPEN_COLL_ELEM || token->type == OP_OPEN_CHAR_CLASS\n      || token->type == OP_OPEN_EQUIV_CLASS)\n    return parse_bracket_symbol (elem, regexp, token);\n  if (BE (token->type == OP_CHARSET_RANGE, 0) && !accept_hyphen)\n    {\n      /* A '-' must only appear as anything but a range indicator before\n\t the closing bracket.  Everything else is an error.  */\n      re_token_t token2;\n      (void) peek_token_bracket (&token2, regexp, syntax);\n      if (token2.type != OP_CLOSE_BRACKET)\n\t/* The actual error value is not standardized since this whole\n\t   case is undefined.  But ERANGE makes good sense.  */\n\treturn REG_ERANGE;\n    }\n  elem->type = SB_CHAR;\n  elem->opr.ch = token->opr.c;\n  return REG_NOERROR;\n}", "path": "direwolf/external/regex/regcomp.c", "commit_date": "2019-12-01 00:00:00", "repo_name": "wb2osz/direwolf", "stars": 1440, "license": "gpl-2.0", "language": "c", "size": 142385}
{"docstring": "/* Mark the tree SRC as an optional subexpression.\n   To be called from preorder or postorder.  */\n", "func_signal": "static reg_errcode_t\nmark_opt_subexp (void *extra, bin_tree_t *node)", "code": "{\n  int idx = (int) (ptrdiff_t) extra;\n  if (node->token.type == SUBEXP && node->token.opr.idx == idx)\n    node->token.opt_subexp = 1;\n\n  return REG_NOERROR;\n}", "path": "direwolf/external/regex/regcomp.c", "commit_date": "2019-12-01 00:00:00", "repo_name": "wb2osz/direwolf", "stars": 1440, "license": "gpl-2.0", "language": "c", "size": 142385}
{"docstring": "/* Create a tree node.  */\n", "func_signal": "static bin_tree_t *\ncreate_tree (re_dfa_t *dfa, bin_tree_t *left, bin_tree_t *right,\n\t     re_token_type_t type)", "code": "{\n  re_token_t t;\n  t.type = type;\n  return create_token_tree (dfa, left, right, &t);\n}", "path": "direwolf/external/regex/regcomp.c", "commit_date": "2019-12-01 00:00:00", "repo_name": "wb2osz/direwolf", "stars": 1440, "license": "gpl-2.0", "language": "c", "size": 142385}
{"docstring": "/* Lowering pass: Turn each SUBEXP node into the appropriate concatenation\n   of OP_OPEN_SUBEXP, the body of the SUBEXP (if any) and OP_CLOSE_SUBEXP.  */\n", "func_signal": "static reg_errcode_t\nlower_subexps (void *extra, bin_tree_t *node)", "code": "{\n  regex_t *preg = (regex_t *) extra;\n  reg_errcode_t err = REG_NOERROR;\n\n  if (node->left && node->left->token.type == SUBEXP)\n    {\n      node->left = lower_subexp (&err, preg, node->left);\n      if (node->left)\n\tnode->left->parent = node;\n    }\n  if (node->right && node->right->token.type == SUBEXP)\n    {\n      node->right = lower_subexp (&err, preg, node->right);\n      if (node->right)\n\tnode->right->parent = node;\n    }\n\n  return err;\n}", "path": "direwolf/external/regex/regcomp.c", "commit_date": "2019-12-01 00:00:00", "repo_name": "wb2osz/direwolf", "stars": 1440, "license": "gpl-2.0", "language": "c", "size": 142385}
{"docstring": "/* Duplicate the epsilon closure of the node ROOT_NODE.\n   Note that duplicated nodes have constraint INIT_CONSTRAINT in addition\n   to their own constraint.  */\n", "func_signal": "static reg_errcode_t\ninternal_function\nduplicate_node_closure (re_dfa_t *dfa, int top_org_node, int top_clone_node,\n\t\t\tint root_node, unsigned int init_constraint)", "code": "{\n  int org_node, clone_node, ret;\n  unsigned int constraint = init_constraint;\n  for (org_node = top_org_node, clone_node = top_clone_node;;)\n    {\n      int org_dest, clone_dest;\n      if (dfa->nodes[org_node].type == OP_BACK_REF)\n\t{\n\t  /* If the back reference epsilon-transit, its destination must\n\t     also have the constraint.  Then duplicate the epsilon closure\n\t     of the destination of the back reference, and store it in\n\t     edests of the back reference.  */\n\t  org_dest = dfa->nexts[org_node];\n\t  re_node_set_empty (dfa->edests + clone_node);\n\t  clone_dest = duplicate_node (dfa, org_dest, constraint);\n\t  if (BE (clone_dest == -1, 0))\n\t    return REG_ESPACE;\n\t  dfa->nexts[clone_node] = dfa->nexts[org_node];\n\t  ret = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t  if (BE (ret < 0, 0))\n\t    return REG_ESPACE;\n\t}\n      else if (dfa->edests[org_node].nelem == 0)\n\t{\n\t  /* In case of the node can't epsilon-transit, don't duplicate the\n\t     destination and store the original destination as the\n\t     destination of the node.  */\n\t  dfa->nexts[clone_node] = dfa->nexts[org_node];\n\t  break;\n\t}\n      else if (dfa->edests[org_node].nelem == 1)\n\t{\n\t  /* In case of the node can epsilon-transit, and it has only one\n\t     destination.  */\n\t  org_dest = dfa->edests[org_node].elems[0];\n\t  re_node_set_empty (dfa->edests + clone_node);\n\t  if (dfa->nodes[org_node].type == ANCHOR)\n\t    {\n\t      /* In case of the node has another constraint, append it.  */\n\t      if (org_node == root_node && clone_node != org_node)\n\t\t{\n\t\t  /* ...but if the node is root_node itself, it means the\n\t\t     epsilon closure have a loop, then tie it to the\n\t\t     destination of the root_node.  */\n\t\t  ret = re_node_set_insert (dfa->edests + clone_node,\n\t\t\t\t\t    org_dest);\n\t\t  if (BE (ret < 0, 0))\n\t\t    return REG_ESPACE;\n\t\t  break;\n\t\t}\n\t      constraint |= dfa->nodes[org_node].opr.ctx_type;\n\t    }\n\t  clone_dest = duplicate_node (dfa, org_dest, constraint);\n\t  if (BE (clone_dest == -1, 0))\n\t    return REG_ESPACE;\n\t  ret = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t  if (BE (ret < 0, 0))\n\t    return REG_ESPACE;\n\t}\n      else /* dfa->edests[org_node].nelem == 2 */\n\t{\n\t  /* In case of the node can epsilon-transit, and it has two\n\t     destinations. In the bin_tree_t and DFA, that's '|' and '*'.   */\n\t  org_dest = dfa->edests[org_node].elems[0];\n\t  re_node_set_empty (dfa->edests + clone_node);\n\t  /* Search for a duplicated node which satisfies the constraint.  */\n\t  clone_dest = search_duplicated_node (dfa, org_dest, constraint);\n\t  if (clone_dest == -1)\n\t    {\n\t      /* There are no such a duplicated node, create a new one.  */\n\t      reg_errcode_t err;\n\t      clone_dest = duplicate_node (dfa, org_dest, constraint);\n\t      if (BE (clone_dest == -1, 0))\n\t\treturn REG_ESPACE;\n\t      ret = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t      if (BE (ret < 0, 0))\n\t\treturn REG_ESPACE;\n\t      err = duplicate_node_closure (dfa, org_dest, clone_dest,\n\t\t\t\t\t    root_node, constraint);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\treturn err;\n\t    }\n\t  else\n\t    {\n\t      /* There are a duplicated node which satisfy the constraint,\n\t\t use it to avoid infinite loop.  */\n\t      ret = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t      if (BE (ret < 0, 0))\n\t\treturn REG_ESPACE;\n\t    }\n\n\t  org_dest = dfa->edests[org_node].elems[1];\n\t  clone_dest = duplicate_node (dfa, org_dest, constraint);\n\t  if (BE (clone_dest == -1, 0))\n\t    return REG_ESPACE;\n\t  ret = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t  if (BE (ret < 0, 0))\n\t    return REG_ESPACE;\n\t}\n      org_node = org_dest;\n      clone_node = clone_dest;\n    }\n  return REG_NOERROR;\n}", "path": "direwolf/external/regex/regcomp.c", "commit_date": "2019-12-01 00:00:00", "repo_name": "wb2osz/direwolf", "stars": 1440, "license": "gpl-2.0", "language": "c", "size": 142385}
{"docstring": "/* Duplicate the node whose index is ORG_IDX and set the constraint CONSTRAINT.\n   Return the index of the new node, or -1 if insufficient storage is\n   available.  */\n", "func_signal": "static int\nduplicate_node (re_dfa_t *dfa, int org_idx, unsigned int constraint)", "code": "{\n  int dup_idx = re_dfa_add_node (dfa, dfa->nodes[org_idx]);\n  if (BE (dup_idx != -1, 1))\n    {\n      dfa->nodes[dup_idx].constraint = constraint;\n      if (dfa->nodes[org_idx].type == ANCHOR)\n\tdfa->nodes[dup_idx].constraint |= dfa->nodes[org_idx].opr.ctx_type;\n      dfa->nodes[dup_idx].duplicated = 1;\n\n      /* Store the index of the original node.  */\n      dfa->org_indices[dup_idx] = org_idx;\n    }\n  return dup_idx;\n}", "path": "direwolf/external/regex/regcomp.c", "commit_date": "2019-12-01 00:00:00", "repo_name": "wb2osz/direwolf", "stars": 1440, "license": "gpl-2.0", "language": "c", "size": 142385}
{"docstring": "/* This function build the following tree, from regular expression\n   <branch1>|<branch2>:\n\t   ALT\n\t   / \\\n\t  /   \\\n   <branch1> <branch2>\n\n   ALT means alternative, which represents the operator `|'.  */\n", "func_signal": "static bin_tree_t *\nparse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, int nest, reg_errcode_t *err)", "code": "{\n  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;\n  bin_tree_t *tree, *branch = NULL;\n  tree = parse_branch (regexp, preg, token, syntax, nest, err);\n  if (BE (*err != REG_NOERROR && tree == NULL, 0))\n    return NULL;\n\n  while (token->type == OP_ALT)\n    {\n      fetch_token (token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n      if (token->type != OP_ALT && token->type != END_OF_RE\n\t  && (nest == 0 || token->type != OP_CLOSE_SUBEXP))\n\t{\n\t  branch = parse_branch (regexp, preg, token, syntax, nest, err);\n\t  if (BE (*err != REG_NOERROR && branch == NULL, 0))\n\t    return NULL;\n\t}\n      else\n\tbranch = NULL;\n      tree = create_tree (dfa, tree, branch, OP_ALT);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n    }\n  return tree;\n}", "path": "direwolf/external/regex/regcomp.c", "commit_date": "2019-12-01 00:00:00", "repo_name": "wb2osz/direwolf", "stars": 1440, "license": "gpl-2.0", "language": "c", "size": 142385}
{"docstring": "/* Calculate epsilon closure of NODE.  */\n", "func_signal": "static reg_errcode_t\ncalc_eclosure_iter (re_node_set *new_set, re_dfa_t *dfa, int node, int root)", "code": "{\n  reg_errcode_t err;\n  unsigned int constraint;\n  int i, incomplete;\n  re_node_set eclosure;\n  incomplete = 0;\n  err = re_node_set_alloc (&eclosure, dfa->edests[node].nelem + 1);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n\n  /* This indicates that we are calculating this node now.\n     We reference this value to avoid infinite loop.  */\n  dfa->eclosures[node].nelem = -1;\n\n  constraint = ((dfa->nodes[node].type == ANCHOR)\n\t\t? dfa->nodes[node].opr.ctx_type : 0);\n  /* If the current node has constraints, duplicate all nodes.\n     Since they must inherit the constraints.  */\n  if (constraint\n      && dfa->edests[node].nelem\n      && !dfa->nodes[dfa->edests[node].elems[0]].duplicated)\n    {\n      err = duplicate_node_closure (dfa, node, node, node, constraint);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n    }\n\n  /* Expand each epsilon destination nodes.  */\n  if (IS_EPSILON_NODE(dfa->nodes[node].type))\n    for (i = 0; i < dfa->edests[node].nelem; ++i)\n      {\n\tre_node_set eclosure_elem;\n\tint edest = dfa->edests[node].elems[i];\n\t/* If calculating the epsilon closure of `edest' is in progress,\n\t   return intermediate result.  */\n\tif (dfa->eclosures[edest].nelem == -1)\n\t  {\n\t    incomplete = 1;\n\t    continue;\n\t  }\n\t/* If we haven't calculated the epsilon closure of `edest' yet,\n\t   calculate now. Otherwise use calculated epsilon closure.  */\n\tif (dfa->eclosures[edest].nelem == 0)\n\t  {\n\t    err = calc_eclosure_iter (&eclosure_elem, dfa, edest, 0);\n\t    if (BE (err != REG_NOERROR, 0))\n\t      return err;\n\t  }\n\telse\n\t  eclosure_elem = dfa->eclosures[edest];\n\t/* Merge the epsilon closure of `edest'.  */\n\tre_node_set_merge (&eclosure, &eclosure_elem);\n\t/* If the epsilon closure of `edest' is incomplete,\n\t   the epsilon closure of this node is also incomplete.  */\n\tif (dfa->eclosures[edest].nelem == 0)\n\t  {\n\t    incomplete = 1;\n\t    re_node_set_free (&eclosure_elem);\n\t  }\n      }\n\n  /* Epsilon closures include itself.  */\n  re_node_set_insert (&eclosure, node);\n  if (incomplete && !root)\n    dfa->eclosures[node].nelem = 0;\n  else\n    dfa->eclosures[node] = eclosure;\n  *new_set = eclosure;\n  return REG_NOERROR;\n}", "path": "direwolf/external/regex/regcomp.c", "commit_date": "2019-12-01 00:00:00", "repo_name": "wb2osz/direwolf", "stars": 1440, "license": "gpl-2.0", "language": "c", "size": 142385}
{"docstring": "/* Duplicate the node SRC, and return new node.  This is a preorder\n   visit similar to the one implemented by the generic visitor, but\n   we need more infrastructure to maintain two parallel trees --- so,\n   it's easier to duplicate.  */\n", "func_signal": "static bin_tree_t *\nduplicate_tree (const bin_tree_t *root, re_dfa_t *dfa)", "code": "{\n  const bin_tree_t *node;\n  bin_tree_t *dup_root;\n  bin_tree_t **p_new = &dup_root, *dup_node = root->parent;\n\n  for (node = root; ; )\n    {\n      /* Create a new tree and link it back to the current parent.  */\n      *p_new = create_token_tree (dfa, NULL, NULL, &node->token);\n      if (*p_new == NULL)\n\treturn NULL;\n      (*p_new)->parent = dup_node;\n      (*p_new)->token.duplicated = 1;\n      dup_node = *p_new;\n\n      /* Go to the left node, or up and to the right.  */\n      if (node->left)\n\t{\n\t  node = node->left;\n\t  p_new = &dup_node->left;\n\t}\n      else\n\t{\n\t  const bin_tree_t *prev = NULL;\n\t  while (node->right == prev || node->right == NULL)\n\t    {\n\t      prev = node;\n\t      node = node->parent;\n\t      dup_node = dup_node->parent;\n\t      if (!node)\n\t        return dup_root;\n\t    }\n\t  node = node->right;\n\t  p_new = &dup_node->right;\n\t}\n    }\n}", "path": "direwolf/external/regex/regcomp.c", "commit_date": "2019-12-01 00:00:00", "repo_name": "wb2osz/direwolf", "stars": 1440, "license": "gpl-2.0", "language": "c", "size": 142385}
{"docstring": "/* Pass 2: compute NEXT on the tree.  Preorder visit.  */\n", "func_signal": "static reg_errcode_t\ncalc_next (void *extra, bin_tree_t *node)", "code": "{\n  switch (node->token.type)\n    {\n    case OP_DUP_ASTERISK:\n      node->left->next = node;\n      break;\n    case CONCAT:\n      node->left->next = node->right->first;\n      node->right->next = node->next;\n      break;\n    default:\n      if (node->left)\n\tnode->left->next = node->next;\n      if (node->right)\n        node->right->next = node->next;\n      break;\n    }\n  return REG_NOERROR;\n}", "path": "direwolf/external/regex/regcomp.c", "commit_date": "2019-12-01 00:00:00", "repo_name": "wb2osz/direwolf", "stars": 1440, "license": "gpl-2.0", "language": "c", "size": 142385}
{"docstring": "/* This function build the following tree, from regular expression\n   <exp1><exp2>:\n\tCAT\n\t/ \\\n       /   \\\n   <exp1> <exp2>\n\n   CAT means concatenation.  */\n", "func_signal": "static bin_tree_t *\nparse_branch (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t      reg_syntax_t syntax, int nest, reg_errcode_t *err)", "code": "{\n  bin_tree_t *tree, *exp;\n  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;\n  tree = parse_expression (regexp, preg, token, syntax, nest, err);\n  if (BE (*err != REG_NOERROR && tree == NULL, 0))\n    return NULL;\n\n  while (token->type != OP_ALT && token->type != END_OF_RE\n\t && (nest == 0 || token->type != OP_CLOSE_SUBEXP))\n    {\n      exp = parse_expression (regexp, preg, token, syntax, nest, err);\n      if (BE (*err != REG_NOERROR && exp == NULL, 0))\n\t{\n\t  return NULL;\n\t}\n      if (tree != NULL && exp != NULL)\n\t{\n\t  tree = create_tree (dfa, tree, exp, CONCAT);\n\t  if (tree == NULL)\n\t    {\n\t      *err = REG_ESPACE;\n\t      return NULL;\n\t    }\n\t}\n      else if (tree == NULL)\n\ttree = exp;\n      /* Otherwise exp == NULL, we don't need to create new tree.  */\n    }\n  return tree;\n}", "path": "direwolf/external/regex/regcomp.c", "commit_date": "2019-12-01 00:00:00", "repo_name": "wb2osz/direwolf", "stars": 1440, "license": "gpl-2.0", "language": "c", "size": 142385}
{"docstring": "/* Helper function for re_compile_fastmap.\n   Compile fastmap for the initial_state INIT_STATE.  */\n", "func_signal": "static void\nre_compile_fastmap_iter (regex_t *bufp, const re_dfastate_t *init_state,\n\t\t\t char *fastmap)", "code": "{\n  re_dfa_t *dfa = (re_dfa_t *) bufp->buffer;\n  int node_cnt;\n  int icase = (dfa->mb_cur_max == 1 && (bufp->syntax & RE_ICASE));\n  for (node_cnt = 0; node_cnt < init_state->nodes.nelem; ++node_cnt)\n    {\n      int node = init_state->nodes.elems[node_cnt];\n      re_token_type_t type = dfa->nodes[node].type;\n\n      if (type == CHARACTER)\n\t{\n\t  re_set_fastmap (fastmap, icase, dfa->nodes[node].opr.c);\n#ifdef RE_ENABLE_I18N\n\t  if ((bufp->syntax & RE_ICASE) && dfa->mb_cur_max > 1)\n\t    {\n\t      unsigned char *buf = alloca (dfa->mb_cur_max), *p;\n\t      wchar_t wc;\n\t      mbstate_t state;\n\n\t      p = buf;\n\t      *p++ = dfa->nodes[node].opr.c;\n\t      while (++node < dfa->nodes_len\n\t\t     &&\tdfa->nodes[node].type == CHARACTER\n\t\t     && dfa->nodes[node].mb_partial)\n\t\t*p++ = dfa->nodes[node].opr.c;\n\t      memset (&state, '\\0', sizeof (state));\n\t      if (mbrtowc (&wc, (const char *) buf, p - buf,\n\t\t\t   &state) == p - buf\n\t\t  && (__wcrtomb ((char *) buf, towlower (wc), &state)\n\t\t      != (size_t) -1))\n\t\tre_set_fastmap (fastmap, 0, buf[0]);\n\t    }\n#endif\n\t}\n      else if (type == SIMPLE_BRACKET)\n\t{\n\t  int i, ch;\n\t  for (i = 0, ch = 0; i < BITSET_WORDS; ++i)\n\t    {\n\t      int j;\n\t      bitset_word_t w = dfa->nodes[node].opr.sbcset[i];\n\t      for (j = 0; j < BITSET_WORD_BITS; ++j, ++ch)\n\t\tif (w & ((bitset_word_t) 1 << j))\n\t\t  re_set_fastmap (fastmap, icase, ch);\n\t    }\n\t}\n#ifdef RE_ENABLE_I18N\n      else if (type == COMPLEX_BRACKET)\n\t{\n\t  int i;\n\t  re_charset_t *cset = dfa->nodes[node].opr.mbcset;\n\t  if (cset->non_match || cset->ncoll_syms || cset->nequiv_classes\n\t      || cset->nranges || cset->nchar_classes)\n\t    {\n# ifdef _LIBC\n\t      if (_NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES) != 0)\n\t\t{\n\t\t  /* In this case we want to catch the bytes which are\n\t\t     the first byte of any collation elements.\n\t\t     e.g. In da_DK, we want to catch 'a' since \"aa\"\n\t\t\t  is a valid collation element, and don't catch\n\t\t\t  'b' since 'b' is the only collation element\n\t\t\t  which starts from 'b'.  */\n\t\t  const int32_t *table = (const int32_t *)\n\t\t    _NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEMB);\n\t\t  for (i = 0; i < SBC_MAX; ++i)\n\t\t    if (table[i] < 0)\n\t\t      re_set_fastmap (fastmap, icase, i);\n\t\t}\n# else\n\t      if (dfa->mb_cur_max > 1)\n\t\tfor (i = 0; i < SBC_MAX; ++i)\n\t\t  if (__btowc (i) == WEOF)\n\t\t    re_set_fastmap (fastmap, icase, i);\n# endif /* not _LIBC */\n\t    }\n\t  for (i = 0; i < cset->nmbchars; ++i)\n\t    {\n\t      char buf[256];\n\t      mbstate_t state;\n\t      memset (&state, '\\0', sizeof (state));\n\t      if (__wcrtomb (buf, cset->mbchars[i], &state) != (size_t) -1)\n\t\tre_set_fastmap (fastmap, icase, *(unsigned char *) buf);\n\t      if ((bufp->syntax & RE_ICASE) && dfa->mb_cur_max > 1)\n\t\t{\n\t\t  if (__wcrtomb (buf, towlower (cset->mbchars[i]), &state)\n\t\t      != (size_t) -1)\n\t\t    re_set_fastmap (fastmap, 0, *(unsigned char *) buf);\n\t\t}\n\t    }\n\t}\n#endif /* RE_ENABLE_I18N */\n      else if (type == OP_PERIOD\n#ifdef RE_ENABLE_I18N\n\t       || type == OP_UTF8_PERIOD\n#endif /* RE_ENABLE_I18N */\n\t       || type == END_OF_RE)\n\t{\n\t  memset (fastmap, '\\1', sizeof (char) * SBC_MAX);\n\t  if (type == END_OF_RE)\n\t    bufp->can_be_null = 1;\n\t  return;\n\t}\n    }\n}", "path": "direwolf/external/regex/regcomp.c", "commit_date": "2019-12-01 00:00:00", "repo_name": "wb2osz/direwolf", "stars": 1440, "license": "gpl-2.0", "language": "c", "size": 142385}
{"docstring": "/* Optimization pass: if a SUBEXP is entirely contained, strip it and tell\n   re_search_internal to map the inner one's opr.idx to this one's.  Adjust\n   backreferences as well.  Requires a preorder visit.  */\n", "func_signal": "static reg_errcode_t\noptimize_subexps (void *extra, bin_tree_t *node)", "code": "{\n  re_dfa_t *dfa = (re_dfa_t *) extra;\n\n  if (node->token.type == OP_BACK_REF && dfa->subexp_map)\n    {\n      int idx = node->token.opr.idx;\n      node->token.opr.idx = dfa->subexp_map[idx];\n      dfa->used_bkref_map |= 1 << node->token.opr.idx;\n    }\n\n  else if (node->token.type == SUBEXP\n           && node->left && node->left->token.type == SUBEXP)\n    {\n      int other_idx = node->left->token.opr.idx;\n\n      node->left = node->left->left;\n      if (node->left)\n        node->left->parent = node;\n\n      dfa->subexp_map[other_idx] = dfa->subexp_map[node->token.opr.idx];\n      if (other_idx < BITSET_WORD_BITS)\n\t  dfa->used_bkref_map &= ~((bitset_word_t) 1 << other_idx);\n    }\n\n  return REG_NOERROR;\n}", "path": "direwolf/external/regex/regcomp.c", "commit_date": "2019-12-01 00:00:00", "repo_name": "wb2osz/direwolf", "stars": 1440, "license": "gpl-2.0", "language": "c", "size": 142385}
{"docstring": "/* Entry point of the parser.\n   Parse the regular expression REGEXP and return the structure tree.\n   If an error is occured, ERR is set by error code, and return NULL.\n   This function build the following tree, from regular expression <reg_exp>:\n\t   CAT\n\t   / \\\n\t  /   \\\n   <reg_exp>  EOR\n\n   CAT means concatenation.\n   EOR means end of regular expression.  */\n", "func_signal": "static bin_tree_t *\nparse (re_string_t *regexp, regex_t *preg, reg_syntax_t syntax,\n       reg_errcode_t *err)", "code": "{\n  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;\n  bin_tree_t *tree, *eor, *root;\n  re_token_t current_token;\n  dfa->syntax = syntax;\n  fetch_token (&current_token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n  tree = parse_reg_exp (regexp, preg, &current_token, syntax, 0, err);\n  if (BE (*err != REG_NOERROR && tree == NULL, 0))\n    return NULL;\n  eor = create_tree (dfa, NULL, NULL, END_OF_RE);\n  if (tree != NULL)\n    root = create_tree (dfa, tree, eor, CONCAT);\n  else\n    root = eor;\n  if (BE (eor == NULL || root == NULL, 0))\n    {\n      *err = REG_ESPACE;\n      return NULL;\n    }\n  return root;\n}", "path": "direwolf/external/regex/regcomp.c", "commit_date": "2019-12-01 00:00:00", "repo_name": "wb2osz/direwolf", "stars": 1440, "license": "gpl-2.0", "language": "c", "size": 142385}
{"docstring": "/* Initialize WORD_CHAR table, which indicate which character is\n   \"word\".  In this case \"word\" means that it is the word construction\n   character used by some operators like \"\\<\", \"\\>\", etc.  */\n", "func_signal": "static void\ninternal_function\ninit_word_char (re_dfa_t *dfa)", "code": "{\n  int i, j, ch;\n  dfa->word_ops_used = 1;\n  for (i = 0, ch = 0; i < BITSET_WORDS; ++i)\n    for (j = 0; j < BITSET_WORD_BITS; ++j, ++ch)\n      if (isalnum (ch) || ch == '_')\n\tdfa->word_char[i] |= (bitset_word_t) 1 << j;\n}", "path": "direwolf/external/regex/regcomp.c", "commit_date": "2019-12-01 00:00:00", "repo_name": "wb2osz/direwolf", "stars": 1440, "license": "gpl-2.0", "language": "c", "size": 142385}
{"docstring": "/* Free the allocated memory inside NODE. */\n", "func_signal": "static void\nfree_token (re_token_t *node)", "code": "{\n#ifdef RE_ENABLE_I18N\n  if (node->type == COMPLEX_BRACKET && node->duplicated == 0)\n    free_charset (node->opr.mbcset);\n  else\n#endif /* RE_ENABLE_I18N */\n    if (node->type == SIMPLE_BRACKET && node->duplicated == 0)\n      re_free (node->opr.sbcset);\n}", "path": "direwolf/external/regex/regcomp.c", "commit_date": "2019-12-01 00:00:00", "repo_name": "wb2osz/direwolf", "stars": 1440, "license": "gpl-2.0", "language": "c", "size": 142385}
{"docstring": "/*! \\brief\n * Free all memory used by the given structure\n * The structure must be removed from all linked\n * lists first\n */\n", "func_signal": "void free_urecord(urecord_t* _r)", "code": "{\n\tucontact_t* ptr;\n\n\twhile(_r->contacts) {\n\t\tptr = _r->contacts;\n\t\t_r->contacts = _r->contacts->next;\n\t\tfree_ucontact(ptr);\n\t}\n\n\tshm_free_all(_r->remote_aors);\n\tstore_destroy(_r->kv_storage);\n\n\tif (have_mem_storage() && !_r->is_static) {\n\t\tif (_r->aor.s) shm_free(_r->aor.s);\n\t\tshm_free(_r);\n\t} else {\n\t\t_r->contacts = NULL;\n\t}\n}", "path": "opensips/modules/usrloc/urecord.c", "commit_date": "2020-05-27 00:00:00", "repo_name": "OpenSIPS/opensips", "stars": 1179, "license": "other", "language": "c", "size": 161870}
{"docstring": "/*! \\brief\n * Create and initialize new record structure\n */\n", "func_signal": "int new_urecord(str* _dom, str* _aor, urecord_t** _r)", "code": "{\n\t*_r = (urecord_t*)shm_malloc(sizeof(urecord_t));\n\tif (*_r == 0) {\n\t\tLM_ERR(\"no more share memory\\n\");\n\t\treturn -1;\n\t}\n\tmemset(*_r, 0, sizeof(urecord_t));\n\n\t(*_r)->kv_storage = map_create(AVLMAP_SHARED);\n\tif (!(*_r)->kv_storage) {\n\t\tLM_ERR(\"oom\\n\");\n\t\tshm_free(*_r);\n\t\t*_r = NULL;\n\t\treturn -1;\n\t}\n\n\t(*_r)->aor.s = (char*)shm_malloc(_aor->len);\n\tif ((*_r)->aor.s == 0) {\n\t\tLM_ERR(\"no more share memory\\n\");\n\t\tshm_free(*_r);\n\t\t*_r = NULL;\n\t\treturn -1;\n\t}\n\tmemcpy((*_r)->aor.s, _aor->s, _aor->len);\n\t(*_r)->aor.len = _aor->len;\n\t(*_r)->domain = _dom;\n\t(*_r)->aorhash = core_hash(_aor, 0, 0);\n\n\treturn 0;\n}", "path": "opensips/modules/usrloc/urecord.c", "commit_date": "2020-05-27 00:00:00", "repo_name": "OpenSIPS/opensips", "stars": 1179, "license": "other", "language": "c", "size": 161870}
{"docstring": "/*! \\brief\n * Get pointer to ucontact with given contact\n * Returns:\n *      0 - found\n *      1 - not found\n *     -1 - invalid found\n *     -2 - found, but to be skipped (same cseq)\n */\n", "func_signal": "int get_ucontact(urecord_t* _r, str* _c, str* _callid, int _cseq,\n\t\t\t\t\t\t\t\tstruct ct_match *match, struct ucontact** _co)", "code": "{\n\tucontact_t* ptr;\n\tint no_callid;\n\n\tptr = 0;\n\tno_callid = 0;\n\t*_co = 0;\n\n\tif (match->mode == CT_MATCH_NONE)\n\t\tmatch->mode = matching_mode;\n\n\tLM_DBG(\"using ct matching mode %d\\n\", match->mode);\n\tswitch (match->mode) {\n\tcase CT_MATCH_CONTACT_ONLY:\n\t\tptr = contact_match(_r->contacts, _c);\n\t\tbreak;\n\tcase CT_MATCH_CONTACT_CALLID:\n\t\tptr = contact_callid_match(_r->contacts, _c, _callid);\n\t\tno_callid = 1;\n\t\tbreak;\n\tcase CT_MATCH_PARAMS:\n\t\tptr = contact_params_match(_r->contacts, _c, match->match_params);\n\t\tbreak;\n\tdefault:\n\t\tLM_CRIT(\"unknown contact matching mode %d\\n\", match->mode);\n\t\treturn -1;\n\t}\n\n\tif (ptr) {\n\t\tLM_DBG(\"successfully matched contact '%.*s'\\n\", ptr->c.len, ptr->c.s);\n\n\t\t/* found -> check callid and cseq */\n\t\tif (no_callid || str_match(_callid, &ptr->callid)) {\n\t\t\tif (_cseq<ptr->cseq)\n\t\t\t\treturn -1;\n\t\t\tif (_cseq==ptr->cseq) {\n\t\t\t\tget_act_time();\n\t\t\t\treturn (ptr->last_modified+cseq_delay>act_time)?-2:-1;\n\t\t\t}\n\t\t}\n\t\t*_co = ptr;\n\t\treturn 0;\n\t} else {\n\t\tLM_DBG(\"failed to match any existing contacts\\n\");\n\t}\n\n\treturn 1;\n}", "path": "opensips/modules/usrloc/urecord.c", "commit_date": "2020-05-27 00:00:00", "repo_name": "OpenSIPS/opensips", "stars": 1179, "license": "other", "language": "c", "size": 161870}
{"docstring": "/*! \\brief\n * This routine is used when 'sql_wmode' is set to SQL_WRITE_THROUGH\n */\n", "func_signal": "static inline int ALLOW_UNUSED wt_timer(urecord_t* _r)", "code": "{\n\tucontact_t* ptr, *t;\n\n\tptr = _r->contacts;\n\n\twhile(ptr) {\n\t\tif (!VALID_CONTACT(ptr, act_time)) {\n\t\t\t/* run callbacks for EXPIRE event */\n\t\t\tif (exists_ulcb_type(UL_CONTACT_EXPIRE)) {\n\t\t\t\trun_ul_callbacks( UL_CONTACT_EXPIRE, ptr);\n\t\t\t}\n\n\t\t\tLM_DBG(\"Binding '%.*s','%.*s' has expired\\n\",\n\t\t\t\tptr->aor->len, ZSW(ptr->aor->s),\n\t\t\t\tptr->c.len, ZSW(ptr->c.s));\n\n\t\t\tt = ptr;\n\t\t\tptr = ptr->next;\n\n\t\t\tif (db_delete_ucontact(t) < 0) {\n\t\t\t\tLM_ERR(\"deleting contact from database failed\\n\");\n\t\t\t}\n\t\t\tmem_delete_ucontact(_r, t);\n\t\t\tupdate_stat( _r->slot->d->expires, 1);\n\t\t} else {\n\t\t\tptr = ptr->next;\n\t\t}\n\t}\n\n\treturn 0;\n}", "path": "opensips/modules/usrloc/urecord.c", "commit_date": "2020-05-27 00:00:00", "repo_name": "OpenSIPS/opensips", "stars": 1179, "license": "other", "language": "c", "size": 161870}
{"docstring": "/**\n * prints the current point of execution in the OpenSIPS script\n *\n * @class - optional, string to be printed meaning the class of action (if any)\n * @action - mandatory, string with the name of action\n * @msg - mandatory, sip message\n * @line - line in script\n */\n", "func_signal": "void __script_trace(char *class, char *action, struct sip_msg *msg,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tchar *file, int line)", "code": "{\n\tstr val;\n\n\tif (pv_printf_s(msg, &script_trace_elem, &val) != 0) {\n\t\tLM_ERR(\"Failed to evaluate variables\\n\");\n\t\treturn;\n\t}\n\n\t/* Also print extra info */\n\tif (script_trace_info) {\n\t\tLM_GEN1(script_trace_log_level, \"[Script Trace][%s:%d][%s][%s %s]\"\\\n\t\t\t\" -> (%.*s)\\n\", file, line, script_trace_info,\n\t\t\tclass?class:\"\", action, val.len, val.s);\n\t} else {\n\t\tLM_GEN1(script_trace_log_level, \"[Script Trace][%s:%d][%s %s]\"\\\n\t\t\t\" -> (%.*s)\\n\", file, line,\n\t\t\tclass?class:\"\", action, val.len, val.s);\n\t}\n}", "path": "opensips/action.c", "commit_date": "2020-12-09 00:00:00", "repo_name": "OpenSIPS/opensips", "stars": 1179, "license": "other", "language": "c", "size": 161870}
{"docstring": "/*! \\brief\n * Remove the contact from lists\n */\n", "func_signal": "void mem_remove_ucontact(urecord_t* _r, ucontact_t* _c)", "code": "{\n\tint_str_t **rstore;\n\n\tstop_refresh_timer(_c);\n\n\tif (_c->prev) {\n\t\t_c->prev->next = _c->next;\n\t\tif (_c->next) {\n\t\t\t_c->next->prev = _c->prev;\n\t\t}\n\t} else {\n\t\t_r->contacts = _c->next;\n\t\tif (_c->next) {\n\t\t\t_c->next->prev = 0;\n\t\t}\n\t}\n\n\tif (sql_wmode != SQL_NO_WRITE) {\n\t\trstore = (int_str_t **)map_find(_c->kv_storage, urec_store_key);\n\t\tif (rstore && _r->contacts) {\n\t\t\tif (!put_ucontact_key(_r->contacts, &urec_store_key, *rstore))\n\t\t\t\tLM_ERR(\"oom\\n\");\n\t\t}\n\t}\n\n\tul_raise_contact_event(ei_c_del_id, _c);\n}", "path": "opensips/modules/usrloc/urecord.c", "commit_date": "2020-05-27 00:00:00", "repo_name": "OpenSIPS/opensips", "stars": 1179, "license": "other", "language": "c", "size": 161870}
{"docstring": "/* run a list of actions */\n", "func_signal": "int run_action_list(struct action* a, struct sip_msg* msg)", "code": "{\n\tint ret=E_UNSPEC;\n\tstruct action* t;\n\tfor (t=a; t!=0; t=t->next){\n\t\tret=do_action(t, msg);\n\t\t/* if action returns 0, then stop processing the script */\n\t\tif(ret==0)\n\t\t\taction_flags |= ACT_FL_EXIT;\n\n\t\t/* check for errors */\n\t\tif (_oser_err_info.eclass!=0 && sroutes->error.a!=NULL &&\n\t\t(route_type&(ONREPLY_ROUTE|LOCAL_ROUTE))==0 && !inside_error_route)\n\t\t\trun_error_route(msg, 0);\n\n\t\t/* continue or not ? */\n\t\tif (action_flags & (ACT_FL_RETURN | ACT_FL_EXIT | ACT_FL_BREAK))\n\t\t\tbreak;\n\t}\n\treturn ret;\n}", "path": "opensips/action.c", "commit_date": "2020-12-09 00:00:00", "repo_name": "OpenSIPS/opensips", "stars": 1179, "license": "other", "language": "c", "size": 161870}
{"docstring": "/*! \\brief\n * Remove contact from the list and delete\n */\n", "func_signal": "void mem_delete_ucontact(urecord_t* _r, ucontact_t* _c)", "code": "{\n\tmem_remove_ucontact(_r, _c);\n\tif_update_stat( _r->slot, _r->slot->d->contacts, -1);\n\tfree_ucontact(_c);\n}", "path": "opensips/modules/usrloc/urecord.c", "commit_date": "2020-05-27 00:00:00", "repo_name": "OpenSIPS/opensips", "stars": 1179, "license": "other", "language": "c", "size": 161870}
{"docstring": "/*! \\brief\n * Write-back timer\n */\n", "func_signal": "static inline int wb_timer(urecord_t* _r,query_list_t **ins_list)", "code": "{\n\tucontact_t* ptr, *t;\n\tcstate_t old_state;\n\tint op,ins_done=0;\n\n\tptr = _r->contacts;\n\n\tif (rr_persist == RRP_LOAD_FROM_SQL && persist_urecord_kv_store(_r) != 0)\n\t\tLM_DBG(\"failed to persist latest urecord K/V storage\\n\");\n\n\twhile(ptr) {\n\t\tif (!VALID_CONTACT(ptr, act_time)) {\n\t\t\t/* run callbacks for EXPIRE event */\n\t\t\tif (exists_ulcb_type(UL_CONTACT_EXPIRE)) {\n\t\t\t\trun_ul_callbacks( UL_CONTACT_EXPIRE, ptr);\n\t\t\t}\n\n\t\t\tLM_DBG(\"Binding '%.*s','%.*s' has expired\\n\",\n\t\t\t\tptr->aor->len, ZSW(ptr->aor->s),\n\t\t\t\tptr->c.len, ZSW(ptr->c.s));\n\n\t\t\tif (have_mem_storage())\n\t\t\t\tupdate_stat( _r->slot->d->expires, 1);\n\n\t\t\tt = ptr;\n\t\t\tptr = ptr->next;\n\n\t\t\t/* Should we remove the contact from the database ? */\n\t\t\tif (cid_vals && st_expired_ucontact(t) == 1\n\t\t\t        && !(t->flags & FL_MEM)) {\n\t\t\t\tVAL_BIGINT(cid_vals+cid_len) = t->contact_id;\n\t\t\t\tif ((++cid_len) == max_contact_delete) {\n\t\t\t\t\tif (db_multiple_ucontact_delete(_r->domain, cid_keys,\n\t\t\t\t\t\t\t\t\t\t\t\tcid_vals, cid_len) < 0) {\n\t\t\t\t\t\tLM_ERR(\"failed to delete contacts from database\\n\");\n\t\t\t\t\t\t/* pass over these contacts; we will try to delete\n\t\t\t\t\t\t * them later */\n\t\t\t\t\t\tcid_len = 0;\n\n\t\t\t\t\t\t/* do not delete from memory now - if we do, we'll get\n\t\t\t\t\t\t * a stuck record in DB. Future registrations will not\n\t\t\t\t\t\t * be able to get inserted due to index collision */\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tcid_len = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmem_delete_ucontact(_r, t);\n\t\t} else {\n\t\t\t/* Determine the operation we have to do */\n\t\t\told_state = ptr->state;\n\t\t\top = st_flush_ucontact(ptr);\n\n\t\t\tswitch(op) {\n\t\t\tcase 0: /* do nothing, contact is synchronized */\n\t\t\t\tbreak;\n\n\t\t\tcase 1: /* insert */\n\t\t\t\tif (db_insert_ucontact(ptr,ins_list,0) < 0) {\n\t\t\t\t\tLM_ERR(\"inserting contact into database failed\\n\");\n\t\t\t\t\tptr->state = old_state;\n\t\t\t\t}\n\t\t\t\tif (ins_done == 0)\n\t\t\t\t\tins_done = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 2: /* update */\n\t\t\t\tif (db_update_ucontact(ptr) < 0) {\n\t\t\t\t\tLM_ERR(\"updating contact in db failed\\n\");\n\t\t\t\t\tptr->state = old_state;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tptr = ptr->next;\n\t\t}\n\t}\n\n\n\treturn ins_done;\n}", "path": "opensips/modules/usrloc/urecord.c", "commit_date": "2020-05-27 00:00:00", "repo_name": "OpenSIPS/opensips", "stars": 1179, "license": "other", "language": "c", "size": 161870}
{"docstring": "/* run actions from a route */\n/* returns: 0, or 1 on success, <0 on error */\n/* (0 if drop or break encountered, 1 if not ) */\n", "func_signal": "static inline int run_actions(struct action* a, struct sip_msg* msg)", "code": "{\n\tint ret, has_name;\n\tstr top_route;\n\n\tif (route_stack_size > ROUTE_MAX_REC_LEV) {\n\t\tget_top_route_type(&top_route, &has_name);\n\t\tLM_ERR(\"route recursion limit reached, giving up! (nested routes: %d, \"\n\t\t           \"first: '%.*s', last: '%s')!\\n\", route_stack_size,\n\t\t        top_route.len, top_route.s, route_stack[ROUTE_MAX_REC_LEV]);\n\t\tret=E_UNSPEC;\n\t\tgoto error;\n\t}\n\n\tif (a==0){\n\t\tLM_WARN(\"null action list (route stack size: %d)\\n\",\n\t\t        route_stack_size);\n\t\tret=1;\n\t\tgoto error;\n\t}\n\n\tret=run_action_list(a, msg);\n\n\t/* if 'return', reset the flag */\n\tif(action_flags&ACT_FL_RETURN)\n\t\taction_flags &= ~ACT_FL_RETURN;\n\n\treturn ret;\n\nerror:\n\treturn ret;\n}", "path": "opensips/action.c", "commit_date": "2020-12-09 00:00:00", "repo_name": "OpenSIPS/opensips", "stars": 1179, "license": "other", "language": "c", "size": 161870}
{"docstring": "/**\n * functions used to populate $params() vars in the route_param structure\n */\n", "func_signal": "void route_params_push_level(char *rt_name, void *params, void *extra, param_getf_t getf)", "code": "{\n\troute_rec_level++;\n\troute_params[route_rec_level].params = params;\n\troute_params[route_rec_level].extra = extra;\n\troute_params[route_rec_level].get_param = getf;\n\n\tif (rt_name) {\n\t\troute_stack[route_stack_size] = rt_name;\n\t\troute_stack_size++;\n\t}\n}", "path": "opensips/action.c", "commit_date": "2020-12-09 00:00:00", "repo_name": "OpenSIPS/opensips", "stars": 1179, "license": "other", "language": "c", "size": 161870}
{"docstring": "/* function used to get parameter from a route scope */\n", "func_signal": "static int route_param_get(struct sip_msg *msg,  pv_param_t *ip,\n\t\tpv_value_t *res, void *params, void *extra)", "code": "{\n\tint index;\n\tpv_value_t tv;\n\taction_elem_p actions = (action_elem_p)params;\n\tint params_no = (int)(unsigned long)extra;\n\n\tif(ip->pvn.type==PV_NAME_INTSTR)\n\t{\n\t\tif (ip->pvn.u.isname.type != 0)\n\t\t{\n\t\t\tLM_ERR(\"$param expects an integer index here.  Strings \"\n\t\t\t       \"(named parameters) are only accepted within event_route\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tindex = ip->pvn.u.isname.name.n;\n\t} else\n\t{\n\t\t/* pvar -> it might be another $param variable! */\n\t\troute_rec_level--;\n\t\tif(pv_get_spec_value(msg, (pv_spec_p)(ip->pvn.u.dname), &tv)!=0)\n\t\t{\n\t\t\tLM_ERR(\"cannot get spec value\\n\");\n\t\t\troute_rec_level++;\n\t\t\treturn -1;\n\t\t}\n\t\troute_rec_level++;\n\n\t\tif(tv.flags&PV_VAL_NULL || tv.flags&PV_VAL_EMPTY)\n\t\t{\n\t\t\tLM_ERR(\"null or empty name\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (!(tv.flags&PV_VAL_INT) || str2int(&tv.rs,(unsigned int*)&index) < 0)\n\t\t{\n\t\t\tLM_ERR(\"invalid index <%.*s>\\n\", tv.rs.len, tv.rs.s);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!params)\n\t{\n\t\tLM_DBG(\"no parameter specified for this route\\n\");\n\t\treturn pv_get_null(msg, ip, res);\n\t}\n\n\tif (index < 1 || index > params_no)\n\t{\n\t\tLM_DBG(\"no such parameter index %d\\n\", index);\n\t\treturn pv_get_null(msg, ip, res);\n\t}\n\n\t/* the parameters start at 0, whereas the index starts from 1 */\n\tindex--;\n\tswitch (actions[index].type)\n\t{\n\tcase NULLV_ST:\n\t\tres->rs.s = NULL;\n\t\tres->rs.len = res->ri = 0;\n\t\tres->flags = PV_VAL_NULL;\n\t\tbreak;\n\n\tcase STRING_ST:\n\t\tres->rs.s = actions[index].u.string;\n\t\tres->rs.len = strlen(res->rs.s);\n\t\tres->flags = PV_VAL_STR;\n\t\tbreak;\n\n\tcase NUMBER_ST:\n\t\tres->rs.s = sint2str(actions[index].u.number, &res->rs.len);\n\t\tres->ri = actions[index].u.number;\n\t\tres->flags = PV_VAL_STR|PV_VAL_INT|PV_TYPE_INT;\n\t\tbreak;\n\n\tcase SCRIPTVAR_ST:\n\t\troute_rec_level--;\n\t\tif(pv_get_spec_value(msg, (pv_spec_p)actions[index].u.data, res)!=0)\n\t\t{\n\t\t\tLM_ERR(\"cannot get spec value\\n\");\n\t\t\troute_rec_level++;\n\t\t\treturn -1;\n\t\t}\n\t\troute_rec_level++;\n\t\tbreak;\n\n\tdefault:\n\t\tLM_ALERT(\"BUG: invalid parameter type %d\\n\",\n\t\t\t\tactions[index].type);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}", "path": "opensips/action.c", "commit_date": "2020-12-09 00:00:00", "repo_name": "OpenSIPS/opensips", "stars": 1179, "license": "other", "language": "c", "size": 161870}
{"docstring": "/*! \\brief\n * Release urecord previously obtained\n * through get_urecord\n */\n", "func_signal": "void release_urecord(urecord_t* _r, char is_replicated)", "code": "{\n\tswitch (cluster_mode) {\n\tcase CM_SQL_ONLY:\n\t\t/* force flushing to DB*/\n\t\tif (db_only_timer(_r) < 0)\n\t\t\tLM_ERR(\"failed to sync with db\\n\");\n\t\t/* now simply free everything */\n\t\tfree_urecord(_r);\n\t\tbreak;\n\tcase CM_FULL_SHARING_CACHEDB:\n\t\tif (cdb_flush_urecord(_r) < 0)\n\t\t\tLM_ERR(\"failed to flush AoR %.*s\\n\", _r->aor.len, _r->aor.s);\n\t\tfree_urecord(_r);\n\t\tbreak;\n\tdefault:\n\t\tif (_r->is_static || _r->contacts || _r->no_clear_ref > 0)\n\t\t\treturn;\n\n\t\tif (exists_ulcb_type(UL_AOR_DELETE))\n\t\t\trun_ul_callbacks(UL_AOR_DELETE, _r);\n\n\t\tif (!is_replicated && location_cluster) {\n\t\t\tif (cluster_mode == CM_FEDERATION_CACHEDB &&\n\t\t\t    cdb_update_urecord_metadata(&_r->aor, 1) != 0)\n\t\t\t\tLM_ERR(\"failed to delete metadata, aor: %.*s\\n\",\n\t\t\t\t       _r->aor.len, _r->aor.s);\n\n\t\t\treplicate_urecord_delete(_r);\n\t\t}\n\n\t\tmem_delete_urecord(_r->slot->d, _r);\n\t}\n}", "path": "opensips/modules/usrloc/urecord.c", "commit_date": "2020-05-27 00:00:00", "repo_name": "OpenSIPS/opensips", "stars": 1179, "license": "other", "language": "c", "size": 161870}
{"docstring": "/*! \\brief\n * Add a new contact\n * Contacts are ordered by: 1) q\n *                          2) descending modification time\n * before calling this function one must calculate the\n * contact_id inside the ucontact_info structure\n */\n", "func_signal": "ucontact_t* mem_insert_ucontact(urecord_t* _r, str* _c, ucontact_info_t* _ci)", "code": "{\n\tucontact_t* ptr, *prev = 0;\n\tucontact_t* c;\n\n\tif ( (c=new_ucontact(_r->domain, &_r->aor, _c, _ci)) == 0) {\n\t\tLM_ERR(\"failed to create new contact\\n\");\n\t\treturn 0;\n\t}\n\n\tif_update_stat( _r->slot, _r->slot->d->contacts, 1);\n\n\tif (c->kv_storage)\n\t\trestore_urecord_kv_store(_r, c);\n\n\tptr = _r->contacts;\n\n\tif (!desc_time_order) {\n\t\twhile(ptr) {\n\t\t\tif (ptr->q < c->q) break;\n\t\t\tprev = ptr;\n\t\t\tptr = ptr->next;\n\t\t}\n\t}\n\n\tif (ptr) {\n\t\tif (!ptr->prev) {\n\t\t\tptr->prev = c;\n\t\t\tc->next = ptr;\n\t\t\t_r->contacts = c;\n\t\t} else {\n\t\t\tc->next = ptr;\n\t\t\tc->prev = ptr->prev;\n\t\t\tptr->prev->next = c;\n\t\t\tptr->prev = c;\n\t\t}\n\t} else if (prev) {\n\t\tprev->next = c;\n\t\tc->prev = prev;\n\t} else {\n\t\t_r->contacts = c;\n\t}\n\n\tul_raise_contact_event(ei_c_ins_id, c);\n\treturn c;\n}", "path": "opensips/modules/usrloc/urecord.c", "commit_date": "2020-05-27 00:00:00", "repo_name": "OpenSIPS/opensips", "stars": 1179, "license": "other", "language": "c", "size": 161870}
{"docstring": "/* similar to get_ucontact, but does not use callid and cseq\n   to be used from MI functions where we have only contact */\n", "func_signal": "int get_simple_ucontact(urecord_t* _r, str* _c, struct ucontact** _co)", "code": "{\n\t*_co = contact_match( _r->contacts, _c);\n\treturn (*_co)?0:1;\n}", "path": "opensips/modules/usrloc/urecord.c", "commit_date": "2020-05-27 00:00:00", "repo_name": "OpenSIPS/opensips", "stars": 1179, "license": "other", "language": "c", "size": 161870}
{"docstring": "/*! \\brief\n * This timer routine is used when\n * 'rr_persist' is set to RRP_NONE\n */\n", "func_signal": "static inline int nodb_timer(urecord_t* _r)", "code": "{\n\tucontact_t* ptr, *t;\n\n\tptr = _r->contacts;\n\n\twhile(ptr) {\n\t\tif (!VALID_CONTACT(ptr, act_time)) {\n\t\t\t/* run callbacks for EXPIRE event */\n\t\t\tif (exists_ulcb_type(UL_CONTACT_EXPIRE))\n\t\t\t\trun_ul_callbacks( UL_CONTACT_EXPIRE, ptr);\n\n\t\t\tLM_DBG(\"Binding '%.*s','%.*s' has expired\\n\",\n\t\t\t\tptr->aor->len, ZSW(ptr->aor->s),\n\t\t\t\tptr->c.len, ZSW(ptr->c.s));\n\n\t\t\tt = ptr;\n\t\t\tptr = ptr->next;\n\n\t\t\tmem_delete_ucontact(_r, t);\n\t\t\tupdate_stat( _r->slot->d->expires, 1);\n\t\t} else {\n\t\t\tptr = ptr->next;\n\t\t}\n\t}\n\n\treturn 0;\n}", "path": "opensips/modules/usrloc/urecord.c", "commit_date": "2020-05-27 00:00:00", "repo_name": "OpenSIPS/opensips", "stars": 1179, "license": "other", "language": "c", "size": 161870}
{"docstring": "/**\n * \\not a timer function but it wraps up over wb_timer function\n */\n", "func_signal": "static inline int db_only_timer(urecord_t* _r)", "code": "{\n\n\tif (!_r) {\n\t\tLM_ERR(\"no urecord!\\n\");\n\t\treturn -1;\n\t}\n\n\tif (wb_timer(_r, 0) < 0) {\n\t\tLM_ERR(\"failed to sync with db\\n\");\n\t\treturn -1;\n\t}\n\n\t/* delete all the contacts left pending in the \"to-be-delete\" buffer */\n\tif (cid_len &&\n\tdb_multiple_ucontact_delete(_r->domain, cid_keys, cid_vals, cid_len) < 0) {\n\t\tLM_ERR(\"failed to delete contacts from database\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}", "path": "opensips/modules/usrloc/urecord.c", "commit_date": "2020-05-27 00:00:00", "repo_name": "OpenSIPS/opensips", "stars": 1179, "license": "other", "language": "c", "size": 161870}
{"docstring": "/*! \\brief\n * Delete ucontact from urecord\n */\n", "func_signal": "int delete_ucontact(urecord_t* _r, struct ucontact* _c, char is_replicated)", "code": "{\n\tif (!is_replicated && have_data_replication())\n\t\treplicate_ucontact_delete(_r, _c);\n\n\tif (exists_ulcb_type(UL_CONTACT_DELETE))\n\t\trun_ul_callbacks(UL_CONTACT_DELETE, _c);\n\n\tif (exists_ulcb_type(UL_AOR_UPDATE))\n\t\trun_ul_callbacks(UL_AOR_UPDATE, _r);\n\n\tLM_DBG(\"deleting contact '%.*s'\\n\", _c->c.len, _c->c.s);\n\n\tif (st_delete_ucontact(_c) > 0) {\n\t\tif (sql_wmode == SQL_WRITE_THROUGH) {\n\t\t\tif (db_delete_ucontact(_c) < 0) {\n\t\t\t\tLM_ERR(\"failed to remove contact from database\\n\");\n\t\t\t}\n\t\t}\n\n\t\tmem_delete_ucontact(_r, _c);\n\n\t\tif (cluster_mode == CM_SQL_ONLY) {\n\t\t\t/* force flushing to DB*/\n\t\t\tif (db_only_timer(_r) < 0)\n\t\t\t\tLM_ERR(\"failed to sync with db\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}", "path": "opensips/modules/usrloc/urecord.c", "commit_date": "2020-05-27 00:00:00", "repo_name": "OpenSIPS/opensips", "stars": 1179, "license": "other", "language": "c", "size": 161870}
{"docstring": "/* execute assignment operation */\n", "func_signal": "int do_assign(struct sip_msg* msg, struct action* a)", "code": "{\n\tstr st;\n\tint ret;\n\tpv_value_t lval, val;\n\tpv_spec_p dspec;\n\n\tdspec = (pv_spec_p)a->elem[0].u.data;\n\tif(!pv_is_w(dspec))\n\t{\n\t\tLM_ERR(\"read only PV in left expression\\n\");\n\t\tgoto error;\n\t}\n\n\tmemset(&val, 0, sizeof(pv_value_t));\n\tif(a->elem[1].type != NULLV_ST)\n\t{\n\t\tret = eval_expr((struct expr*)a->elem[1].u.data, msg, &val);\n\t\tif(ret < 0 || !(val.flags & (PV_VAL_STR | PV_VAL_INT | PV_VAL_NULL)))\n\t\t{\n\t\t\tLM_WARN(\"no value in right expression at %s:%d\\n\",\n\t\t\t\ta->file, a->line);\n\t\t\tgoto error2;\n\t\t}\n\t}\n\n\tswitch (a->type) {\n\tcase EQ_T:\n\tcase COLONEQ_T:\n\t\tbreak;\n\tcase PLUSEQ_T:\n\tcase MINUSEQ_T:\n\tcase DIVEQ_T:\n\tcase MULTEQ_T:\n\tcase MODULOEQ_T:\n\tcase BANDEQ_T:\n\tcase BOREQ_T:\n\tcase BXOREQ_T:\n\t\tif (pv_get_spec_value(msg, dspec, &lval) != 0) {\n\t\t\tLM_ERR(\"failed to get left-hand side value\\n\");\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (lval.flags & PV_VAL_NULL || val.flags & PV_VAL_NULL) {\n\t\t\tLM_ERR(\"NULL value(s) in complex assignment expressions \"\n\t\t\t         \"(+=, -=, etc.)\\n\");\n\t\t\tgoto error;\n\t\t}\n\n\t\t/* both include STR versions and neither is primarily an INT */\n\t\tif ((lval.flags & PV_VAL_STR) && (val.flags & PV_VAL_STR) &&\n\t\t\t!(lval.flags & PV_TYPE_INT) && !(val.flags & PV_TYPE_INT)) {\n\t\t\tval.ri = 0;\n\n\t\t\tif (a->type != PLUSEQ_T)\n\t\t\t\tgoto bad_operands;\n\n\t\t\tif (!(val.flags & PV_VAL_PKG)) {\n\t\t\t\tst = val.rs;\n\t\t\t\tval.rs.s = pkg_malloc(val.rs.len + lval.rs.len + 1);\n\t\t\t\tif (!val.rs.s) {\n\t\t\t\t\tval.rs.s = st.s;\n\t\t\t\t\tLM_ERR(\"oom 1\\n\");\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(val.rs.s, lval.rs.s, lval.rs.len);\n\t\t\t\tmemcpy(val.rs.s + lval.rs.len, st.s, st.len);\n\t\t\t\tval.rs.len += lval.rs.len;\n\t\t\t\tval.rs.s[val.rs.len] = '\\0';\n\t\t\t\tval.flags |= PV_VAL_PKG;\n\n\t\t\t\tif (val.flags & PV_VAL_SHM) {\n\t\t\t\t\tval.flags &= ~PV_VAL_SHM;\n\t\t\t\t\tshm_free(st.s);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tst.len = val.rs.len;\n\t\t\t\tif (pkg_str_extend(&val.rs, val.rs.len + lval.rs.len + 1) != 0) {\n\t\t\t\t\tLM_ERR(\"oom 2\\n\");\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tval.rs.len--;\n\t\t\t\tmemmove(val.rs.s + lval.rs.len, val.rs.s, st.len);\n\t\t\t\tmemcpy(val.rs.s, lval.rs.s, lval.rs.len);\n\t\t\t\tval.rs.s[val.rs.len] = '\\0';\n\t\t\t}\n\t\t} else if ((lval.flags & PV_VAL_INT) && (val.flags & PV_VAL_INT)) {\n\t\t\tif (val.flags & PV_VAL_STR)\n\t\t\t\tval.flags &= ~PV_VAL_STR;\n\t\t\tswitch (a->type) {\n\t\t\tcase PLUSEQ_T:\n\t\t\t\tval.ri = lval.ri + val.ri;\n\t\t\t\tbreak;\n\t\t\tcase MINUSEQ_T:\n\t\t\t\tval.ri = lval.ri - val.ri;\n\t\t\t\tbreak;\n\t\t\tcase DIVEQ_T:\n\t\t\t\tval.ri = lval.ri / val.ri;\n\t\t\t\tbreak;\n\t\t\tcase MULTEQ_T:\n\t\t\t\tval.ri = lval.ri * val.ri;\n\t\t\t\tbreak;\n\t\t\tcase MODULOEQ_T:\n\t\t\t\tval.ri = lval.ri % val.ri;\n\t\t\t\tbreak;\n\t\t\tcase BANDEQ_T:\n\t\t\t\tval.ri = lval.ri & val.ri;\n\t\t\t\tbreak;\n\t\t\tcase BOREQ_T:\n\t\t\t\tval.ri = lval.ri | val.ri;\n\t\t\t\tbreak;\n\t\t\tcase BXOREQ_T:\n\t\t\t\tval.ri = lval.ri ^ val.ri;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tgoto bad_operands;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tLM_ALERT(\"BUG -> unknown op type %d\\n\", a->type);\n\t\tgoto error;\n\t}\n\n\tscript_trace(\"assign\",\n\t\t(unsigned char)a->type == EQ_T      ? \"equal\" :\n\t\t(unsigned char)a->type == COLONEQ_T ? \"colon-eq\" :\n\t\t(unsigned char)a->type == PLUSEQ_T  ? \"plus-eq\" :\n\t\t(unsigned char)a->type == MINUSEQ_T ? \"minus-eq\" :\n\t\t(unsigned char)a->type == DIVEQ_T   ? \"div-eq\" :\n\t\t(unsigned char)a->type == MULTEQ_T  ? \"mult-eq\" :\n\t\t(unsigned char)a->type == MODULOEQ_T? \"modulo-eq\" :\n\t\t(unsigned char)a->type == BANDEQ_T  ? \"b-and-eq\" :\n\t\t(unsigned char)a->type == BOREQ_T   ? \"b-or-eq\":\"b-xor-eq\",\n\t\tmsg, a->file, a->line);\n\n\tif(a->elem[1].type == NULLV_ST || (val.flags & PV_VAL_NULL))\n\t{\n\t\tif(pv_set_value(msg, dspec, (int)a->type, 0)<0)\n\t\t{\n\t\t\tLM_ERR(\"setting PV failed\\n\");\n\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\tif(pv_set_value(msg, dspec, (int)a->type, &val)<0)\n\t\t{\n\t\t\tLM_ERR(\"setting PV failed\\n\");\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tpv_value_destroy(&val);\n\treturn 1;\n\nbad_operands:\n\tLM_ERR(\"unsupported operand type(s) for %s: %s and %s\\n\",\n\t       assignop_str(a->type),\n\t       lval.flags & PV_VAL_STR ? \"string\" : \"int\",\n\t       val.flags & PV_VAL_STR ? \"string\" : \"int\");\n\tpv_value_destroy(&val);\n\treturn -1;\n\nerror:\n\tLM_ERR(\"error at %s:%d\\n\", a->file, a->line);\nerror2:\n\tpv_value_destroy(&val);\n\treturn -1;\n}", "path": "opensips/action.c", "commit_date": "2020-12-09 00:00:00", "repo_name": "OpenSIPS/opensips", "stars": 1179, "license": "other", "language": "c", "size": 161870}
{"docstring": "/**\n * cdb_flush_urecord() - Sync memory state down to cache state in one query.\n * @_r: record to flush.\n *\n * Depending on their state:\n *  - CS_SYNC contacts of @_r are skipped\n *  - CS_NEW contacts of @_r are inserted\n *  - CS_DIRTY contacts of @_r are updated\n */\n", "func_signal": "int cdb_flush_urecord(urecord_t *_r)", "code": "{\n\tstatic const cdb_key_t aor_key = {{\"aor\", 3}, 1};\n\tcdb_filter_t *aor_filter = NULL;\n\tint_str_t val;\n\tucontact_t *it, *ct;\n\tcdb_dict_t ct_changes;\n\tcstate_t old_state;\n\tint op;\n\n\tcdb_dict_init(&ct_changes);\n\n\tit = _r->contacts;\n\twhile (it) {\n\t\tct = it;\n\t\tit = it->next;\n\n\t\tif (!VALID_CONTACT(ct, act_time)) {\n\t\t\t/* run callbacks for DELETE event */\n\t\t\tif (exists_ulcb_type(UL_CONTACT_DELETE))\n\t\t\t\trun_ul_callbacks(UL_CONTACT_DELETE, ct);\n\n\t\t\tLM_DBG(\"deleting AoR: %.*s, Contact: %.*s.\\n\",\n\t\t\t\tct->aor->len, ZSW(ct->aor->s),\n\t\t\t\tct->c.len, ZSW(ct->c.s));\n\n\t\t\tif (have_mem_storage())\n\t\t\t\tupdate_stat( _r->slot->d->expires, 1);\n\n\t\t\t/* Should we remove the contact from the cache? */\n\t\t\tif (st_expired_ucontact(ct) == 1 && !(ct->flags & FL_MEM)) {\n\t\t\t\tif (cdb_add_ct_update(&ct_changes, ct, 1) < 0) {\n\t\t\t\t\tLM_ERR(\"failed to prepare ct delete, AoR: %.*s ci: %.*s\\n\",\n\t\t\t\t\t       ct->aor->len, ct->aor->s, ct->callid.len,\n\t\t\t\t\t       ct->callid.s);\n\t\t\t\t\tgoto err_free;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tLM_DBG(\"adding AoR: %.*s, Contact: %.*s.\\n\",\n\t\t       ct->aor->len, ZSW(ct->aor->s), ct->c.len, ZSW(ct->c.s));\n\n\t\t/* Determine the operation we have to do */\n\t\told_state = ct->state;\n\t\top = st_flush_ucontact(ct);\n\n\t\tswitch (op) {\n\t\tcase 0: /* do nothing, contact is synchronized */\n\t\t\tbreak;\n\n\t\tcase 1: /* insert */\n\t\tcase 2: /* update */\n\t\t\tif (cdb_add_ct_update(&ct_changes, ct, 0) < 0) {\n\t\t\t\tLM_ERR(\"failed to prepare ct %s, AoR: %.*s ci: %.*s\\n\",\n\t\t\t\t       op == 1 ? \"insert\" : \"update\", ct->aor->len, ct->aor->s,\n\t\t\t\t       ct->callid.len, ct->callid.s);\n\t\t\t\tct->state = old_state;\n\t\t\t\tgoto err_free;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdbg_cdb_dict(\"final ct changes: \", &ct_changes);\n\tif (cdb_dict_empty(&ct_changes))\n\t\tgoto out;\n\n\tif (CDB_DICT_ADD_INT32(&ct_changes, \"aorhash\", _r->aorhash) != 0) {\n\t\tLM_ERR(\"oom\\n\");\n\t\tgoto err_free;\n\t}\n\n\tval.is_str = 1;\n\tval.s = _r->aor;\n\taor_filter = cdb_append_filter(NULL, &aor_key, CDB_OP_EQ, &val);\n\tif (!aor_filter) {\n\t\tLM_ERR(\"oom\\n\");\n\t\tgoto err_free;\n\t}\n\n\tif (cdbf.update(cdbc, aor_filter, &ct_changes) < 0) {\n\t\tLM_ERR(\"cache update query for AoR %.*s failed!\\n\",\n\t\t       _r->aor.len, _r->aor.s);\n\t\tgoto err_free;\n\t}\n\nout:\n\tcdb_free_filters(aor_filter);\n\tcdb_free_entries(&ct_changes, NULL);\n\treturn 0;\n\nerr_free:\n\tcdb_free_filters(aor_filter);\n\tcdb_free_entries(&ct_changes, NULL);\n\treturn -1;\n}", "path": "opensips/modules/usrloc/urecord.c", "commit_date": "2020-05-27 00:00:00", "repo_name": "OpenSIPS/opensips", "stars": 1179, "license": "other", "language": "c", "size": 161870}
{"docstring": "/**\n * Set a sequencer event to be a pitch bend event.\n * @param evt Sequencer event structure\n * @param channel MIDI channel number\n * @param pitch MIDI pitch bend value (0-16383, 8192 = no bend)\n */\n", "func_signal": "void\nfluid_event_pitch_bend(fluid_event_t *evt, int channel, int pitch)", "code": "{\n    evt->type = FLUID_SEQ_PITCHBEND;\n    evt->channel = channel;\n\n    if(pitch < 0)\n    {\n        pitch = 0;\n    }\n\n    if(pitch > 16383)\n    {\n        pitch = 16383;\n    }\n\n    evt->pitch = pitch;\n}", "path": "fluidsynth/src/synth/fluid_event.c", "commit_date": "2020-12-27 00:00:00", "repo_name": "FluidSynth/fluidsynth", "stars": 1669, "license": "lgpl-2.1", "language": "c", "size": 8995}
{"docstring": "/**\n * Set a sequencer event to be a note on event.\n * @param evt Sequencer event structure\n * @param channel MIDI channel number\n * @param key MIDI note number (0-127)\n * @param vel MIDI velocity value (0-127)\n */\n", "func_signal": "void\nfluid_event_noteon(fluid_event_t *evt, int channel, short key, short vel)", "code": "{\n    evt->type = FLUID_SEQ_NOTEON;\n    evt->channel = channel;\n    evt->key = key;\n    evt->vel = vel;\n}", "path": "fluidsynth/src/synth/fluid_event.c", "commit_date": "2020-12-27 00:00:00", "repo_name": "FluidSynth/fluidsynth", "stars": 1669, "license": "lgpl-2.1", "language": "c", "size": 8995}
{"docstring": "/**\n * Set a sequencer event to be a program change event.\n * @param evt Sequencer event structure\n * @param channel MIDI channel number\n * @param val MIDI program number (0-127)\n */\n", "func_signal": "void\nfluid_event_program_change(fluid_event_t *evt, int channel, int val)", "code": "{\n    evt->type = FLUID_SEQ_PROGRAMCHANGE;\n    evt->channel = channel;\n    evt->value = val;\n}", "path": "fluidsynth/src/synth/fluid_event.c", "commit_date": "2020-12-27 00:00:00", "repo_name": "FluidSynth/fluidsynth", "stars": 1669, "license": "lgpl-2.1", "language": "c", "size": 8995}
{"docstring": "/* This is a compromised solution for JNAerator for that 1) it cannot handle jobject with JNIEnv as parameters, and that 2) the returned pointer can be converted in the same manner that JNAerated methods. (Most likely my JNA usage issue but no one has answer for it.) */\n", "func_signal": "void Java_fluidsynth_androidextensions_NativeHandler_setAssetManagerContext(JNIEnv *env, jobject _this, jobject assetManager)", "code": "{\n\tif (assetManager == NULL)\n\t\treturn;\n\t\n    fluid_android_asset_manager = AAssetManager_fromJava (env, assetManager);\n}", "path": "fluidsynth/doc/android/fluidsynth-assetloader/fluid_androidasset.c", "commit_date": "2020-07-12 00:00:00", "repo_name": "FluidSynth/fluidsynth", "stars": 1669, "license": "lgpl-2.1", "language": "c", "size": 8995}
{"docstring": "/**\n * Set a sequencer event to be a MIDI control change event.\n * @param evt Sequencer event structure\n * @param channel MIDI channel number\n * @param control MIDI control number (0-127)\n * @param val MIDI control value (0-127)\n */\n", "func_signal": "void\nfluid_event_control_change(fluid_event_t *evt, int channel, short control, int val)", "code": "{\n    evt->type = FLUID_SEQ_CONTROLCHANGE;\n    evt->channel = channel;\n    evt->control = control;\n    evt->value = val;\n}", "path": "fluidsynth/src/synth/fluid_event.c", "commit_date": "2020-12-27 00:00:00", "repo_name": "FluidSynth/fluidsynth", "stars": 1669, "license": "lgpl-2.1", "language": "c", "size": 8995}
{"docstring": "/**\n * Set a sequencer event to be a reverb send event.\n * @param evt Sequencer event structure\n * @param channel MIDI channel number\n * @param val Reverb amount (0-127)\n */\n", "func_signal": "void\nfluid_event_reverb_send(fluid_event_t *evt, int channel, int val)", "code": "{\n    evt->type = FLUID_SEQ_REVERBSEND;\n    evt->channel = channel;\n\n    if(val < 0)\n    {\n        val = 0;\n    }\n\n    if(val > 127)\n    {\n        val = 127;\n    }\n\n    evt->value = val;\n}", "path": "fluidsynth/src/synth/fluid_event.c", "commit_date": "2020-12-27 00:00:00", "repo_name": "FluidSynth/fluidsynth", "stars": 1669, "license": "lgpl-2.1", "language": "c", "size": 8995}
{"docstring": "/**\n * Set a sequencer event to be a timer event.\n * @param evt Sequencer event structure\n * @param data User supplied data pointer\n */\n", "func_signal": "void\nfluid_event_timer(fluid_event_t *evt, void *data)", "code": "{\n    evt->type = FLUID_SEQ_TIMER;\n    evt->data = data;\n}", "path": "fluidsynth/src/synth/fluid_event.c", "commit_date": "2020-12-27 00:00:00", "repo_name": "FluidSynth/fluidsynth", "stars": 1669, "license": "lgpl-2.1", "language": "c", "size": 8995}
{"docstring": "/* Event alloc/free */\n", "func_signal": "void\nfluid_event_clear(fluid_event_t *evt)", "code": "{\n    FLUID_MEMSET(evt, 0, sizeof(fluid_event_t));\n\n    // by default, no type\n    evt->dest = -1;\n    evt->src = -1;\n    evt->type = -1;\n    evt->id = -1;\n}", "path": "fluidsynth/src/synth/fluid_event.c", "commit_date": "2020-12-27 00:00:00", "repo_name": "FluidSynth/fluidsynth", "stars": 1669, "license": "lgpl-2.1", "language": "c", "size": 8995}
{"docstring": "/**\n * Set a sequencer event to be a pitch wheel sensitivity event.\n * @param evt Sequencer event structure\n * @param channel MIDI channel number\n * @param value MIDI pitch wheel sensitivity value in semitones\n */\n", "func_signal": "void\nfluid_event_pitch_wheelsens(fluid_event_t *evt, int channel, int value)", "code": "{\n    evt->type = FLUID_SEQ_PITCHWHEELSENS;\n    evt->channel = channel;\n    evt->value = value;\n}", "path": "fluidsynth/src/synth/fluid_event.c", "commit_date": "2020-12-27 00:00:00", "repo_name": "FluidSynth/fluidsynth", "stars": 1669, "license": "lgpl-2.1", "language": "c", "size": 8995}
{"docstring": "/**\n * Set a sequencer event to be a note off event.\n * @param evt Sequencer event structure\n * @param channel MIDI channel number\n * @param key MIDI note number (0-127)\n */\n", "func_signal": "void\nfluid_event_noteoff(fluid_event_t *evt, int channel, short key)", "code": "{\n    evt->type = FLUID_SEQ_NOTEOFF;\n    evt->channel = channel;\n    evt->key = key;\n}", "path": "fluidsynth/src/synth/fluid_event.c", "commit_date": "2020-12-27 00:00:00", "repo_name": "FluidSynth/fluidsynth", "stars": 1669, "license": "lgpl-2.1", "language": "c", "size": 8995}
{"docstring": "/**\n * Set a sequencer event to be a all notes off event.\n * @param evt Sequencer event structure\n * @param channel MIDI channel number\n */\n", "func_signal": "void\nfluid_event_all_notes_off(fluid_event_t *evt, int channel)", "code": "{\n    evt->type = FLUID_SEQ_ALLNOTESOFF;\n    evt->channel = channel;\n}", "path": "fluidsynth/src/synth/fluid_event.c", "commit_date": "2020-12-27 00:00:00", "repo_name": "FluidSynth/fluidsynth", "stars": 1669, "license": "lgpl-2.1", "language": "c", "size": 8995}
{"docstring": "/**\n * Set a sequencer event to be a volume event.\n * @param evt Sequencer event structure\n * @param channel MIDI channel number\n * @param val Volume value (0-127)\n */\n", "func_signal": "void\nfluid_event_volume(fluid_event_t *evt, int channel, int val)", "code": "{\n    evt->type = FLUID_SEQ_VOLUME;\n    evt->channel = channel;\n\n    if(val < 0)\n    {\n        val = 0;\n    }\n\n    if(val > 127)\n    {\n        val = 127;\n    }\n\n    evt->value = val;\n}", "path": "fluidsynth/src/synth/fluid_event.c", "commit_date": "2020-12-27 00:00:00", "repo_name": "FluidSynth/fluidsynth", "stars": 1669, "license": "lgpl-2.1", "language": "c", "size": 8995}
{"docstring": "/**\n * Set a sequencer event to be a stereo pan event.\n * @param evt Sequencer event structure\n * @param channel MIDI channel number\n * @param val MIDI panning value (0-127, 0=left, 64 = middle, 127 = right)\n */\n", "func_signal": "void\nfluid_event_pan(fluid_event_t *evt, int channel, int val)", "code": "{\n    evt->type = FLUID_SEQ_PAN;\n    evt->channel = channel;\n\n    if(val < 0)\n    {\n        val = 0;\n    }\n\n    if(val > 127)\n    {\n        val = 127;\n    }\n\n    evt->value = val;\n}", "path": "fluidsynth/src/synth/fluid_event.c", "commit_date": "2020-12-27 00:00:00", "repo_name": "FluidSynth/fluidsynth", "stars": 1669, "license": "lgpl-2.1", "language": "c", "size": 8995}
{"docstring": "/**\n * Set a sequencer event to be a MIDI sustain event.\n * @param evt Sequencer event structure\n * @param channel MIDI channel number\n * @param val MIDI sustain value (0-127)\n */\n", "func_signal": "void\nfluid_event_sustain(fluid_event_t *evt, int channel, int val)", "code": "{\n    evt->type = FLUID_SEQ_SUSTAIN;\n    evt->channel = channel;\n\n    if(val < 0)\n    {\n        val = 0;\n    }\n\n    if(val > 127)\n    {\n        val = 127;\n    }\n\n    evt->value = val;\n}", "path": "fluidsynth/src/synth/fluid_event.c", "commit_date": "2020-12-27 00:00:00", "repo_name": "FluidSynth/fluidsynth", "stars": 1669, "license": "lgpl-2.1", "language": "c", "size": 8995}
{"docstring": "/**\n * Set a sequencer event to be a scale change event.\n * Useful for scheduling tempo changes.\n * @param evt Sequencer event structure\n * @param new_scale The new time scale to apply to the sequencer, see fluid_sequencer_set_time_scale()\n * @since 2.2.0\n */\n", "func_signal": "void\nfluid_event_scale(fluid_event_t *evt, double new_scale)", "code": "{\n    evt->type = FLUID_SEQ_SCALE;\n    evt->scale = new_scale;\n}", "path": "fluidsynth/src/synth/fluid_event.c", "commit_date": "2020-12-27 00:00:00", "repo_name": "FluidSynth/fluidsynth", "stars": 1669, "license": "lgpl-2.1", "language": "c", "size": 8995}
{"docstring": "/**\n * Set a sequencer event to be an all sounds off event.\n * @param evt Sequencer event structure\n * @param channel MIDI channel number\n */\n", "func_signal": "void\nfluid_event_all_sounds_off(fluid_event_t *evt, int channel)", "code": "{\n    evt->type = FLUID_SEQ_ALLSOUNDSOFF;\n    evt->channel = channel;\n}", "path": "fluidsynth/src/synth/fluid_event.c", "commit_date": "2020-12-27 00:00:00", "repo_name": "FluidSynth/fluidsynth", "stars": 1669, "license": "lgpl-2.1", "language": "c", "size": 8995}
{"docstring": "/**\n * Set a sequencer event to be a program select event.\n * @param evt Sequencer event structure\n * @param channel MIDI channel number\n * @param sfont_id SoundFont ID number\n * @param bank_num MIDI bank number (0-16383)\n * @param preset_num MIDI preset number (0-127)\n */\n", "func_signal": "void\nfluid_event_program_select(fluid_event_t *evt, int channel,\n                           unsigned int sfont_id, short bank_num, short preset_num)", "code": "{\n    evt->type = FLUID_SEQ_PROGRAMSELECT;\n    evt->channel = channel;\n    evt->duration = sfont_id;\n    evt->value = preset_num;\n    evt->control = bank_num;\n}", "path": "fluidsynth/src/synth/fluid_event.c", "commit_date": "2020-12-27 00:00:00", "repo_name": "FluidSynth/fluidsynth", "stars": 1669, "license": "lgpl-2.1", "language": "c", "size": 8995}
{"docstring": "/**\n * Set a sequencer event to be a chorus send event.\n * @param evt Sequencer event structure\n * @param channel MIDI channel number\n * @param val Chorus amount (0-127)\n */\n", "func_signal": "void\nfluid_event_chorus_send(fluid_event_t *evt, int channel, int val)", "code": "{\n    evt->type = FLUID_SEQ_CHORUSSEND;\n    evt->channel = channel;\n\n    if(val < 0)\n    {\n        val = 0;\n    }\n\n    if(val > 127)\n    {\n        val = 127;\n    }\n\n    evt->value = val;\n}", "path": "fluidsynth/src/synth/fluid_event.c", "commit_date": "2020-12-27 00:00:00", "repo_name": "FluidSynth/fluidsynth", "stars": 1669, "license": "lgpl-2.1", "language": "c", "size": 8995}
{"docstring": "/**\n * Create a new sequencer event structure.\n * @return New sequencer event structure or NULL if out of memory\n */\n", "func_signal": "fluid_event_t *\nnew_fluid_event()", "code": "{\n    fluid_event_t *evt;\n\n    evt = FLUID_NEW(fluid_event_t);\n\n    if(evt == NULL)\n    {\n        FLUID_LOG(FLUID_PANIC, \"event: Out of memory\\n\");\n        return NULL;\n    }\n\n    fluid_event_clear(evt);\n\n    return(evt);\n}", "path": "fluidsynth/src/synth/fluid_event.c", "commit_date": "2020-12-27 00:00:00", "repo_name": "FluidSynth/fluidsynth", "stars": 1669, "license": "lgpl-2.1", "language": "c", "size": 8995}
{"docstring": "/**\n * Delete a sequencer event structure.\n * @param evt Sequencer event structure created by new_fluid_event().\n */\n", "func_signal": "void\ndelete_fluid_event(fluid_event_t *evt)", "code": "{\n    fluid_return_if_fail(evt != NULL);\n\n    FLUID_FREE(evt);\n}", "path": "fluidsynth/src/synth/fluid_event.c", "commit_date": "2020-12-27 00:00:00", "repo_name": "FluidSynth/fluidsynth", "stars": 1669, "license": "lgpl-2.1", "language": "c", "size": 8995}
{"docstring": "/*************************************************************************\n**************************************************************************\n#cat: vorticity - Measures the amount of cummulative curvature incurred\n#cat:             among the IMAP neighbors of the given block.\n\n   Input:\n      imap  - 2D vector of ridge flow directions\n      mx    - horizontal coord of current IMAP block\n      my    - vertical coord of current IMAP block\n      mw    - width (in blocks) of the IMAP\n      mh    - height (in blocks) of the IMAP\n      ndirs - number of possible directions in the IMAP\n   Return Code:\n      Non-negative - the measured vorticity among the neighbors\n**************************************************************************/\n", "func_signal": "int vorticity(int *imap, const int mx, const int my,\n              const int mw, const int mh, const int ndirs)", "code": "{\n   int e_ind, w_ind, n_ind, s_ind;\n   int nw_val, n_val, ne_val, e_val, se_val, s_val, sw_val, w_val;\n   int vmeasure;\n\n   /* Compute neighbor coordinates to current IMAP direction */\n   e_ind = mx+1;  /* East index */\n   w_ind = mx-1;  /* West index */\n   n_ind = my-1;  /* North index */\n   s_ind = my+1;  /* South index */\n\n   /* 1. Get NW IMAP value.  */\n   /* If neighbor indices are within IMAP boundaries ... */\n   if((w_ind >= 0) && (n_ind >= 0))\n      /* Set neighbor value to IMAP value. */\n      nw_val = *(imap + (n_ind*mw) + w_ind);\n   else\n      /* Otherwise, set the neighbor value to INVALID. */\n      nw_val = INVALID_DIR;\n\n   /* 2. Get N IMAP value.  */\n   if(n_ind >= 0)\n      n_val = *(imap + (n_ind*mw) + mx);\n   else\n      n_val = INVALID_DIR;\n\n   /* 3. Get NE IMAP value. */\n   if((n_ind >= 0) && (e_ind < mw))\n      ne_val = *(imap + (n_ind*mw) + e_ind);\n   else\n      ne_val = INVALID_DIR;\n\n   /* 4. Get E IMAP value. */\n   if(e_ind < mw)\n      e_val = *(imap + (my*mw) + e_ind);\n   else\n      e_val = INVALID_DIR;\n\n   /* 5. Get SE IMAP value. */\n   if((e_ind < mw) && (s_ind < mh))\n      se_val = *(imap + (s_ind*mw) + e_ind);\n   else\n      se_val = INVALID_DIR;\n\n   /* 6. Get S IMAP value. */\n   if(s_ind < mh)\n      s_val = *(imap + (s_ind*mw) + mx);\n   else\n      s_val = INVALID_DIR;\n\n   /* 7. Get SW IMAP value. */\n   if((w_ind >= 0) && (s_ind < mh))\n      sw_val = *(imap + (s_ind*mw) + w_ind);\n   else\n      sw_val = INVALID_DIR;\n\n   /* 8. Get W IMAP value. */\n   if(w_ind >= 0)\n      w_val = *(imap + (my*mw) + w_ind);\n   else\n      w_val = INVALID_DIR;\n\n   /* Now that we have all IMAP neighbors, accumulate vorticity between */\n   /* the neighboring directions.                                       */\n\n   /* Initialize vorticity accumulator to zero. */\n   vmeasure = 0;\n\n   /* 1. NW & N */\n   accum_nbr_vorticity(&vmeasure, nw_val, n_val, ndirs);\n\n   /* 2. N & NE */\n   accum_nbr_vorticity(&vmeasure, n_val, ne_val, ndirs);\n\n   /* 3. NE & E */\n   accum_nbr_vorticity(&vmeasure, ne_val, e_val, ndirs);\n\n   /* 4. E & SE */\n   accum_nbr_vorticity(&vmeasure, e_val, se_val, ndirs);\n\n   /* 5. SE & S */\n   accum_nbr_vorticity(&vmeasure, se_val, s_val, ndirs);\n\n   /* 6. S & SW */\n   accum_nbr_vorticity(&vmeasure, s_val, sw_val, ndirs);\n\n   /* 7. SW & W */\n   accum_nbr_vorticity(&vmeasure, sw_val, w_val, ndirs);\n\n   /* 8. W & NW */\n   accum_nbr_vorticity(&vmeasure, w_val, nw_val, ndirs);\n\n   /* Return the accumulated vorticity measure. */\n   return(vmeasure);\n}", "path": "Validity90/libfprint/libfprint/nbis/mindtct/maps.c", "commit_date": "2017-02-01 00:00:00", "repo_name": "nmikhailov/Validity90", "stars": 1839, "license": "lgpl-2.1", "language": "c", "size": 1380}
{"docstring": "/* Calculade squared standand deviation of sum of two lines */\n", "func_signal": "static int upeksonly_get_deviation2(struct fpi_line_asmbl_ctx *ctx,\n\t\t\t  GSList *line1, GSList *line2)", "code": "{\n\tunsigned char *buf1 = line1->data, *buf2 = line2->data;\n\tint res = 0, mean = 0, i;\n\tfor (i = 0; i < ctx->line_width; i+= 2)\n\t\tmean += (int)buf1[i + 1] + (int)buf2[i];\n\n\tmean /= (ctx->line_width / 2);\n\n\tfor (i = 0; i < ctx->line_width; i+= 2) {\n\t\tint dev = (int)buf1[i + 1] + (int)buf2[i] - mean;\n\t\tres += dev*dev;\n\t}\n\n\treturn res / (ctx->line_width / 2);\n}", "path": "Validity90/libfprint/libfprint/drivers/upeksonly.c", "commit_date": "2017-02-01 00:00:00", "repo_name": "nmikhailov/Validity90", "stars": 1839, "license": "lgpl-2.1", "language": "c", "size": 1380}
{"docstring": "/*************************************************************************\n**************************************************************************\n#cat: init_dir2rad - Allocates and initializes a lookup table containing\n#cat:                cosine and sine values needed to convert integer IMAP\n#cat:                directions to angles in radians.\n\n   Input:\n      ndirs - the number of integer directions to be defined in a\n              semicircle\n   Output:\n      optr  - points to the allocated/initialized DIR2RAD structure\n   Return Code:\n      Zero     - successful completion\n      Negative - system error\n**************************************************************************/\n", "func_signal": "int init_dir2rad(DIR2RAD **optr, const int ndirs)", "code": "{\n   DIR2RAD *dir2rad;\n   int i;\n   double theta, pi_factor;\n   double cs, sn;\n\n   /* Allocate structure */\n   dir2rad = (DIR2RAD *)malloc(sizeof(DIR2RAD));\n   if(dir2rad == (DIR2RAD *)NULL){\n      fprintf(stderr, \"ERROR : init_dir2rad : malloc : dir2rad\\n\");\n      return(-10);\n   }\n\n   /* Assign number of directions */\n   dir2rad->ndirs = ndirs;\n\n   /* Allocate cosine vector */\n   dir2rad->cos = (double *)malloc(ndirs * sizeof(double));\n   if(dir2rad->cos == (double *)NULL){\n      /* Free memory allocated to this point. */\n      free(dir2rad);\n      fprintf(stderr, \"ERROR : init_dir2rad : malloc : dir2rad->cos\\n\");\n      return(-11);\n   }\n\n   /* Allocate sine vector */\n   dir2rad->sin = (double *)malloc(ndirs * sizeof(double));\n   if(dir2rad->sin == (double *)NULL){\n      /* Free memory allocated to this point. */\n      free(dir2rad->cos);\n      free(dir2rad);\n      fprintf(stderr, \"ERROR : init_dir2rad : malloc : dir2rad->sin\\n\");\n      return(-12);\n   }\n\n   /* Pi_factor sets the period of the trig functions to NDIRS units in x. */\n   /* For example, if NDIRS==16, then pi_factor = 2(PI/16) = .3926...      */\n   pi_factor = 2.0*M_PI/(double)ndirs;\n\n   /* Now compute cos and sin values for each direction.    */\n   for (i = 0; i < ndirs; ++i) {\n      theta = (double)(i * pi_factor);\n      cs = cos(theta);\n      sn = sin(theta);\n      /* Need to truncate precision so that answers are consistent */\n      /* on different computer architectures. */\n      cs = trunc_dbl_precision(cs, TRUNC_SCALE);\n      sn = trunc_dbl_precision(sn, TRUNC_SCALE);\n      dir2rad->cos[i] = cs;\n      dir2rad->sin[i] = sn;\n   }\n\n   *optr = dir2rad;\n   return(0);\n}", "path": "Validity90/libfprint/libfprint/nbis/mindtct/init.c", "commit_date": "2017-02-01 00:00:00", "repo_name": "nmikhailov/Validity90", "stars": 1839, "license": "lgpl-2.1", "language": "c", "size": 1380}
{"docstring": "/*************************************************************************\n**************************************************************************\n#cat: alloc_shape - Allocates and initializes a shape structure given the\n#cat:              the X and Y limits of the shape.\n\n   Input:\n      xmin   - left-most x-coord in shape\n      ymin   - top-most y-coord in shape\n      xmax   - right-most x-coord in shape\n      ymax   - bottom-most y-coord in shape\n   Output:\n      oshape - pointer to the allocated & initialized shape structure\n   Return Code:\n      Zero     - Shape successfully allocated and initialized\n      Negative - System error\n**************************************************************************/\n", "func_signal": "static int alloc_shape(SHAPE **oshape, const int xmin, const int ymin,\n                  const int xmax, const int ymax)", "code": "{\n   SHAPE *shape;\n   int alloc_rows, alloc_pts;\n   int i, j, y;\n\n   /* Compute allocation parameters. */\n   /* First, compute the number of scanlines spanned by the shape. */\n   alloc_rows = ymax - ymin + 1;\n   /* Second, compute the \"maximum\" number of contour points possible    */\n   /* on a row.  Here we are allocating the maximum number of contiguous */\n   /* pixels on each row which will be sufficiently larger than the      */\n   /* number of actual contour points.                                   */\n   alloc_pts = xmax - xmin + 1;\n\n   /* Allocate the shape structure. */\n   shape = (SHAPE *)malloc(sizeof(SHAPE));\n   /* If there is an allocation error... */\n   if(shape == (SHAPE *)NULL){\n      fprintf(stderr, \"ERROR : alloc_shape : malloc : shape\\n\");\n      return(-250);\n   }\n\n   /* Allocate the list of row pointers.  We now this number will fit */\n   /* the shape exactly.                                              */\n   shape->rows = (ROW **)malloc(alloc_rows * sizeof(ROW *));\n   /* If there is an allocation error... */\n   if(shape->rows == (ROW **)NULL){\n      /* Deallocate memory alloated by this routine to this point. */\n      free(shape);\n      fprintf(stderr, \"ERROR : alloc_shape : malloc : shape->rows\\n\");\n      return(-251);\n   }\n\n   /* Initialize the shape structure's attributes. */\n   shape->ymin = ymin;\n   shape->ymax = ymax;\n   /* The number of allocated rows will be exactly the number of */\n   /* assigned rows for the shape.                               */\n   shape->alloc = alloc_rows;\n   shape->nrows = alloc_rows;\n\n   /* Foreach row in the shape... */\n   for(i = 0, y = ymin; i < alloc_rows; i++, y++){\n      /* Allocate a row structure and store it in its respective position */\n      /* in the shape structure's list of row pointers.                   */\n      shape->rows[i] = (ROW *)malloc(sizeof(ROW));\n      /* If there is an allocation error... */\n      if(shape->rows[i] == (ROW *)NULL){\n         /* Deallocate memory alloated by this routine to this point. */\n         for(j = 0; j < i; j++){\n            free(shape->rows[j]->xs);\n            free(shape->rows[j]);\n         }\n         free(shape->rows);\n         free(shape);\n         fprintf(stderr, \"ERROR : alloc_shape : malloc : shape->rows[i]\\n\");\n         return(-252);\n      }\n\n      /* Allocate the current rows list of x-coords. */\n      shape->rows[i]->xs = (int *)malloc(alloc_pts * sizeof(int));\n      /* If there is an allocation error... */\n      if(shape->rows[i]->xs == (int *)NULL){\n         /* Deallocate memory alloated by this routine to this point. */\n         for(j = 0; j < i; j++){\n            free(shape->rows[j]->xs);\n            free(shape->rows[j]);\n         }\n         free(shape->rows[i]);\n         free(shape->rows);\n         free(shape);\n         fprintf(stderr,\n                 \"ERROR : alloc_shape : malloc : shape->rows[i]->xs\\n\");\n         return(-253);\n      }\n\n      /* Initialize the current row structure's attributes. */\n      shape->rows[i]->y = y;\n      shape->rows[i]->alloc = alloc_pts;\n      /* There are initially ZERO points assigned to the row. */\n      shape->rows[i]->npts = 0;\n   }\n\n   /* Assign structure to output pointer. */\n   *oshape = shape;\n\n   /* Return normally. */\n   return(0);\n}", "path": "Validity90/libfprint/libfprint/nbis/mindtct/shape.c", "commit_date": "2017-02-01 00:00:00", "repo_name": "nmikhailov/Validity90", "stars": 1839, "license": "lgpl-2.1", "language": "c", "size": 1380}
{"docstring": "/*************************************************************************\n**************************************************************************\n#cat: init_dftwaves - Allocates and initializes a set of wave forms needed\n#cat:                 to conduct DFT analysis on blocks of the input image\n\n   Input:\n      dft_coefs - array of multipliers used to define the frequency for\n                  each wave form to be computed\n      nwaves    - number of wave forms to be computed\n      blocksize - the width and height of each block of image data to\n                  be DFT analyzed\n   Output:\n      optr     - points to the allocated/initialized DFTWAVES structure\n   Return Code:\n      Zero     - successful completion\n      Negative - system error\n**************************************************************************/\n", "func_signal": "int init_dftwaves(DFTWAVES **optr, const double *dft_coefs,\n                  const int nwaves, const int blocksize)", "code": "{\n   DFTWAVES *dftwaves;\n   int i, j;\n   double pi_factor, freq, x;\n   double *cptr, *sptr;\n\n   /* Allocate structure */\n   dftwaves = (DFTWAVES *)malloc(sizeof(DFTWAVES));\n   if(dftwaves == (DFTWAVES *)NULL){\n      fprintf(stderr, \"ERROR : init_dftwaves : malloc : dftwaves\\n\");\n      return(-20);\n   }\n\n   /* Set number of DFT waves */\n   dftwaves->nwaves = nwaves;\n   /* Set wave length of the DFT waves (they all must be the same length) */\n   dftwaves->wavelen = blocksize;\n\n   /* Allocate list of wave pointers */\n   dftwaves->waves = (DFTWAVE **)malloc(nwaves * sizeof(DFTWAVE *));\n   if(dftwaves == (DFTWAVES *)NULL){\n      /* Free memory allocated to this point. */\n      free(dftwaves);\n      fprintf(stderr, \"ERROR : init_dftwaves : malloc : dftwaves->waves\\n\");\n      return(-21);\n   }\n\n   /* Pi_factor sets the period of the trig functions to BLOCKSIZE units */\n   /* in x.  For example, if BLOCKSIZE==24, then                         */\n   /*                         pi_factor = 2(PI/24) = .26179...           */\n   pi_factor = 2.0*M_PI/(double)blocksize;\n\n   /* Foreach of 4 DFT frequency coef ... */\n   for (i = 0; i < nwaves; ++i) {\n      /* Allocate wave structure */\n      dftwaves->waves[i] = (DFTWAVE *)malloc(sizeof(DFTWAVE));\n      if(dftwaves->waves[i] == (DFTWAVE *)NULL){\n         /* Free memory allocated to this point. */\n         { int _j; for(_j = 0; _j < i; _j++){\n            free(dftwaves->waves[_j]->cos);\n            free(dftwaves->waves[_j]->sin);\n            free(dftwaves->waves[_j]);\n         }}\n         free(dftwaves->waves);\n         free(dftwaves);\n         fprintf(stderr,\n                 \"ERROR : init_dftwaves : malloc : dftwaves->waves[i]\\n\");\n         return(-22);\n      }\n      /* Allocate cosine vector */\n      dftwaves->waves[i]->cos = (double *)malloc(blocksize * sizeof(double));\n      if(dftwaves->waves[i]->cos == (double *)NULL){\n         /* Free memory allocated to this point. */\n         { int _j; for(_j = 0; _j < i; _j++){\n            free(dftwaves->waves[_j]->cos);\n            free(dftwaves->waves[_j]->sin);\n            free(dftwaves->waves[_j]);\n         }}\n         free(dftwaves->waves[i]);\n         free(dftwaves->waves);\n         free(dftwaves);\n         fprintf(stderr,\n                 \"ERROR : init_dftwaves : malloc : dftwaves->waves[i]->cos\\n\");\n         return(-23);\n      }\n      /* Allocate sine vector */\n      dftwaves->waves[i]->sin = (double *)malloc(blocksize * sizeof(double));\n      if(dftwaves->waves[i]->sin == (double *)NULL){\n         /* Free memory allocated to this point. */\n         { int _j; for(_j = 0; _j < i; _j++){\n            free(dftwaves->waves[_j]->cos);\n            free(dftwaves->waves[_j]->sin);\n            free(dftwaves->waves[_j]);\n         }}\n         free(dftwaves->waves[i]->cos);\n         free(dftwaves->waves[i]);\n         free(dftwaves->waves);\n         free(dftwaves);\n         fprintf(stderr,\n                 \"ERROR : init_dftwaves : malloc : dftwaves->waves[i]->sin\\n\");\n         return(-24);\n      }\n\n      /* Assign pointer nicknames */\n      cptr = dftwaves->waves[i]->cos;\n      sptr = dftwaves->waves[i]->sin;\n\n      /* Compute actual frequency */\n      freq = pi_factor * dft_coefs[i];\n\n      /* Used as a 1D DFT on a 24 long vector of pixel sums */\n      for (j = 0; j < blocksize; ++j) {\n         /* Compute sample points from frequency */\n         x = freq * (double)j;\n         /* Store cos and sin components of sample point */\n         *cptr++ = cos(x);\n         *sptr++ = sin(x);\n      }\n   }\n\n   *optr = dftwaves;\n   return(0);\n}", "path": "Validity90/libfprint/libfprint/nbis/mindtct/init.c", "commit_date": "2017-02-01 00:00:00", "repo_name": "nmikhailov/Validity90", "stars": 1839, "license": "lgpl-2.1", "language": "c", "size": 1380}
{"docstring": "/*************************************************************************\n**************************************************************************\n#cat: smooth_direction_map - Takes a vector of integer directions and smooths\n#cat:               them by analyzing the direction of adjacent neighbors.\n\n   Input:\n      direction_map - vector of integer block values\n      mw        - width (in blocks) of the map\n      mh        - height (in blocks) of the map\n      dir2rad   - lookup table for converting integer directions\n      lfsparms - parameters and thresholds for controlling LFS\n   Output:\n      imap      - vector of smoothed input values\n**************************************************************************/\n", "func_signal": "void smooth_direction_map(int *direction_map, int *low_contrast_map,\n                 const int mw, const int mh,\n                 const DIR2RAD *dir2rad, const LFSPARMS *lfsparms)", "code": "{\n   int mx, my;\n   int *dptr, *cptr;\n   int avrdir, nvalid;\n   double dir_strength;\n\n   print2log(\"SMOOTH DIRECTION MAP\\n\");\n\n   /* Assign pointers to beginning of both maps. */\n   dptr = direction_map;\n   cptr = low_contrast_map;\n\n   /* Foreach block in maps ... */\n   for(my = 0; my < mh; my++){\n      for(mx = 0; mx < mw; mx++){\n         /* If the current block does NOT have LOW CONTRAST ... */\n         if(!*cptr){\n\n            /* Compute average direction from neighbors, returning the */\n            /* number of valid neighbors used in the computation, and  */\n            /* the \"strength\" of the average direction.                */\n            average_8nbr_dir(&avrdir, &dir_strength, &nvalid,\n                             direction_map, mx, my, mw, mh, dir2rad);\n\n            /* If average direction strength is strong enough */\n            /*    (Ex. thresh==0.2)...                        */\n            if(dir_strength >= lfsparms->dir_strength_min){\n               /* If Direction Map direction is valid ... */\n               if(*dptr != INVALID_DIR){\n                  /* Conduct valid neighbor test (Ex. thresh==3)... */\n                  if(nvalid >= lfsparms->rmv_valid_nbr_min){\n\n#ifdef LOG_REPORT /*vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/\n                     fprintf(logfp, \"   BLOCK %2d (%2d, %2d)\\n\",\n                             mx+(my*mw), mx, my);\n                     fprintf(logfp, \"      Average NBR :   %2d %6.3f %d\\n\",\n                             avrdir, dir_strength, nvalid);\n                     fprintf(logfp, \"      1. Valid NBR (%d >= %d)\\n\",\n                             nvalid, lfsparms->rmv_valid_nbr_min);\n                     fprintf(logfp, \"      Valid Direction = %d\\n\", *dptr);\n                     fprintf(logfp, \"      Smoothed Direction = %d\\n\", avrdir);\n#endif /*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/\n\n                     /* Reassign valid direction with average direction. */\n                     *dptr = avrdir;\n                  }\n               }\n               /* Otherwise direction is invalid ... */\n               else{\n                  /* Even if DIRECTION_MAP value is invalid, if number of */\n                  /* valid neighbors is big enough (Ex. thresh==7)...     */\n                  if(nvalid >= lfsparms->smth_valid_nbr_min){\n\n#ifdef LOG_REPORT /*vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/\n                     fprintf(logfp, \"   BLOCK %2d (%2d, %2d)\\n\",\n                             mx+(my*mw), mx, my);\n                     fprintf(logfp, \"      Average NBR :   %2d %6.3f %d\\n\",\n                             avrdir, dir_strength, nvalid);\n                     fprintf(logfp, \"      2. Invalid NBR (%d >= %d)\\n\",\n                             nvalid, lfsparms->smth_valid_nbr_min);\n                     fprintf(logfp, \"      Invalid Direction = %d\\n\", *dptr);\n                     fprintf(logfp, \"      Smoothed Direction = %d\\n\", avrdir);\n#endif /*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/\n\n                     /* Assign invalid direction with average direction. */\n                     *dptr = avrdir;\n                  }\n               }\n            }\n         }\n         /* Otherwise, block has LOW CONTRAST, so keep INVALID direction. */\n\n         /* Bump to next block in maps. */\n         dptr++;\n         cptr++;\n      }\n   }\n}", "path": "Validity90/libfprint/libfprint/nbis/mindtct/maps.c", "commit_date": "2017-02-01 00:00:00", "repo_name": "nmikhailov/Validity90", "stars": 1839, "license": "lgpl-2.1", "language": "c", "size": 1380}
{"docstring": "/*************************************************************************\n**************************************************************************\n#cat: smooth_imap - Takes a vector of integer directions and smooths them\n#cat:               by analyzing the direction of adjacent neighbors.\n\n   Input:\n      imap      - vector of IMAP integer directions\n      mw        - width (in blocks) of the IMAP\n      mh        - height (in blocks) of the IMAP\n      dir2rad   - lookup table for converting integer directions\n      lfsparms  - parameters and thresholds for controlling LFS\n   Output:\n      imap      - vector of smoothed input values\n**************************************************************************/\n", "func_signal": "void smooth_imap(int *imap, const int mw, const int mh,\n                 const DIR2RAD *dir2rad, const LFSPARMS *lfsparms)", "code": "{\n   int mx, my;\n   int *iptr;\n   int avrdir, nvalid;\n   double dir_strength;\n\n   print2log(\"SMOOTH MAP\\n\");\n\n   iptr = imap;\n   for(my = 0; my < mh; my++){\n      for(mx = 0; mx < mw; mx++){\n         /* Compute average direction from neighbors, returning the */\n         /* number of valid neighbors used in the computation, and  */\n         /* the \"strength\" of the average direction.                */\n         average_8nbr_dir(&avrdir, &dir_strength, &nvalid,\n                          imap, mx, my, mw, mh, dir2rad);\n\n         /* If average direction strength is strong enough */\n         /*    (Ex. thresh==0.2)...                        */\n         if(dir_strength >= lfsparms->dir_strength_min){\n            /* If IMAP direction is valid ... */\n            if(*iptr != INVALID_DIR){\n               /* Conduct valid neighbor test (Ex. thresh==3)... */\n               if(nvalid >= lfsparms->rmv_valid_nbr_min){\n\n#ifdef LOG_REPORT /*vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/\n                  fprintf(logfp, \"   BLOCK %2d (%2d, %2d)\\n\",\n                          mx+(my*mw), mx, my);\n                  fprintf(logfp, \"      Average NBR :   %2d %6.3f %d\\n\",\n                          avrdir, dir_strength, nvalid);\n                  fprintf(logfp, \"      1. Valid NBR (%d >= %d)\\n\",\n                          nvalid, lfsparms->rmv_valid_nbr_min);\n                  fprintf(logfp, \"      Valid Direction = %d\\n\", *iptr);\n                  fprintf(logfp, \"      Smoothed Direction = %d\\n\", avrdir);\n#endif /*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/\n\n                  /* Reassign valid IMAP direction with average direction. */\n                  *iptr = avrdir;\n               }\n            }\n            /* Otherwise IMAP direction is invalid ... */\n            else{\n               /* Even if IMAP value is invalid, if number of valid */\n               /* neighbors is big enough (Ex. thresh==7)...        */\n               if(nvalid >= lfsparms->smth_valid_nbr_min){\n\n#ifdef LOG_REPORT /*vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/\n                  fprintf(logfp, \"   BLOCK %2d (%2d, %2d)\\n\",\n                          mx+(my*mw), mx, my);\n                  fprintf(logfp, \"      Average NBR :   %2d %6.3f %d\\n\",\n                          avrdir, dir_strength, nvalid);\n                  fprintf(logfp, \"      2. Invalid NBR (%d >= %d)\\n\",\n                          nvalid, lfsparms->smth_valid_nbr_min);\n                  fprintf(logfp, \"      Invalid Direction = %d\\n\", *iptr);\n                  fprintf(logfp, \"      Smoothed Direction = %d\\n\", avrdir);\n#endif /*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/\n\n                  /* Assign invalid IMAP direction with average direction. */\n                  *iptr = avrdir;\n               }\n            }\n         }\n\n         /* Bump to next IMAP direction. */\n         iptr++;\n      }\n   }\n}", "path": "Validity90/libfprint/libfprint/nbis/mindtct/maps.c", "commit_date": "2017-02-01 00:00:00", "repo_name": "nmikhailov/Validity90", "stars": 1839, "license": "lgpl-2.1", "language": "c", "size": 1380}
{"docstring": "/*************************************************************************\n**************************************************************************\n#cat: num_valid_8nbrs - Given a block in an IMAP, counts the number of\n#cat:                   immediate neighbors that have a valid IMAP direction.\n\n   Input:\n      imap - 2-D vector of directional ridge flows\n      mx   - horizontal coord of current block in IMAP\n      my   - vertical coord of current block in IMAP\n      mw   - width (in blocks) of the IMAP\n      mh   - height (in blocks) of the IMAP\n   Return Code:\n      Non-negative - the number of valid IMAP neighbors\n**************************************************************************/\n", "func_signal": "int num_valid_8nbrs(int *imap, const int mx, const int my,\n                    const int mw, const int mh)", "code": "{\n   int e_ind, w_ind, n_ind, s_ind;\n   int nvalid;\n\n   /* Initialize VALID IMAP counter to zero. */\n   nvalid = 0;\n\n   /* Compute neighbor coordinates to current IMAP direction */\n   e_ind = mx+1;  /* East index */\n   w_ind = mx-1;  /* West index */\n   n_ind = my-1;  /* North index */\n   s_ind = my+1;  /* South index */\n\n   /* 1. Test NW IMAP value.  */\n   /* If neighbor indices are within IMAP boundaries and it is VALID ... */\n   if((w_ind >= 0) && (n_ind >= 0) && (*(imap + (n_ind*mw) + w_ind) >= 0))\n      /* Bump VALID counter. */\n      nvalid++;\n\n   /* 2. Test N IMAP value.  */\n   if((n_ind >= 0) && (*(imap + (n_ind*mw) + mx) >= 0))\n      nvalid++;\n\n   /* 3. Test NE IMAP value. */\n   if((n_ind >= 0) && (e_ind < mw) && (*(imap + (n_ind*mw) + e_ind) >= 0))\n      nvalid++;\n\n   /* 4. Test E IMAP value. */\n   if((e_ind < mw) && (*(imap + (my*mw) + e_ind) >= 0))\n      nvalid++;\n\n   /* 5. Test SE IMAP value. */\n   if((e_ind < mw) && (s_ind < mh) && (*(imap + (s_ind*mw) + e_ind) >= 0))\n      nvalid++;\n\n   /* 6. Test S IMAP value. */\n   if((s_ind < mh) && (*(imap + (s_ind*mw) + mx) >= 0))\n      nvalid++;\n\n   /* 7. Test SW IMAP value. */\n   if((w_ind >= 0) && (s_ind < mh) && (*(imap + (s_ind*mw) + w_ind) >= 0))\n      nvalid++;\n\n   /* 8. Test W IMAP value. */\n   if((w_ind >= 0) && (*(imap + (my*mw) + w_ind) >= 0))\n      nvalid++;\n\n   /* Return number of neighbors with VALID IMAP values. */\n   return(nvalid);\n}", "path": "Validity90/libfprint/libfprint/nbis/mindtct/maps.c", "commit_date": "2017-02-01 00:00:00", "repo_name": "nmikhailov/Validity90", "stars": 1839, "license": "lgpl-2.1", "language": "c", "size": 1380}
{"docstring": "/*************************************************************************\n**************************************************************************\n#cat: morph_tf_map - Takes a 2D vector of TRUE and FALSE values integers\n#cat:               and dialates and erodes the map in an attempt to fill\n#cat:               in voids in the map.\n\n   Input:\n      tfmap    - vector of integer block values\n      mw       - width (in blocks) of the map\n      mh       - height (in blocks) of the map\n      lfsparms - parameters and thresholds for controlling LFS\n   Output:\n      tfmap    - resulting morphed map\n**************************************************************************/\n", "func_signal": "int morph_TF_map(int *tfmap, const int mw, const int mh,\n                 const LFSPARMS *lfsparms)", "code": "{\n   unsigned char *cimage, *mimage, *cptr;\n   int *mptr;\n   int i;\n   \n\n   /* Convert TRUE/FALSE map into a binary byte image. */\n   cimage = (unsigned char *)malloc(mw*mh);\n   if(cimage == (unsigned char *)NULL){\n      fprintf(stderr, \"ERROR : morph_TF_map : malloc : cimage\\n\");\n      return(-660);\n   }\n\n   mimage = (unsigned char *)malloc(mw*mh);\n   if(mimage == (unsigned char *)NULL){\n      fprintf(stderr, \"ERROR : morph_TF_map : malloc : mimage\\n\");\n      return(-661);\n   }\n\n   cptr = cimage;\n   mptr = tfmap;\n   for(i = 0; i < mw*mh; i++){\n      *cptr++ = *mptr++;\n   }\n\n   dilate_charimage_2(cimage, mimage, mw, mh);\n   dilate_charimage_2(mimage, cimage, mw, mh);\n   erode_charimage_2(cimage, mimage, mw, mh);\n   erode_charimage_2(mimage, cimage, mw, mh);\n\n   cptr = cimage;\n   mptr = tfmap;\n   for(i = 0; i < mw*mh; i++){\n      *mptr++ = *cptr++;\n   }\n\n   free(cimage);\n   free(mimage);\n\n   return(0);\n}", "path": "Validity90/libfprint/libfprint/nbis/mindtct/maps.c", "commit_date": "2017-02-01 00:00:00", "repo_name": "nmikhailov/Validity90", "stars": 1839, "license": "lgpl-2.1", "language": "c", "size": 1380}
{"docstring": "/*************************************************************************\n**************************************************************************\n#cat: accum_nbor_vorticity - Accumlates the amount of curvature measures\n#cat:                        between neighboring IMAP blocks.\n\n   Input:\n      dir1  - first neighbor's integer IMAP direction\n      dir2  - second neighbor's integer IMAP direction\n      ndirs - number of possible IMAP directions\n   Output:\n      vmeasure - accumulated vorticity among neighbors measured so far\n**************************************************************************/\n", "func_signal": "void accum_nbr_vorticity(int *vmeasure, const int dir1, const int dir2,\n                         const int ndirs)", "code": "{\n   int dist;\n\n   /* Measure difference in direction between a pair of neighboring */\n   /* directions.                                                   */\n   /* If both neighbors are not equal and both are VALID ... */\n   if((dir1 != dir2) && (dir1 >= 0)&&(dir2 >= 0)){\n      /* Measure the clockwise distance from the first to the second */\n      /* directions.                                                 */\n      dist = dir2 - dir1;\n      /* If dist is negative, then clockwise distance must wrap around */\n      /* the high end of the direction range. For example:             */\n      /*              dir1 = 8                                         */\n      /*              dir2 = 3                                         */\n      /*       and   ndirs = 16                                        */\n      /*             3 - 8 = -5                                        */\n      /*        so  16 - 5 = 11  (the clockwise distance from 8 to 3)  */\n       if(dist < 0)\n         dist += ndirs;\n      /* If the change in clockwise direction is larger than 90 degrees as */\n      /* in total the total number of directions covers 180 degrees.       */\n      if(dist > (ndirs>>1))\n         /* Decrement the vorticity measure. */\n         (*vmeasure)--;\n      else\n         /* Otherwise, bump the vorticity measure. */\n         (*vmeasure)++;\n   }\n   /* Otherwise both directions are either equal or  */\n   /* one or both directions are INVALID, so ignore. */\n}", "path": "Validity90/libfprint/libfprint/nbis/mindtct/maps.c", "commit_date": "2017-02-01 00:00:00", "repo_name": "nmikhailov/Validity90", "stars": 1839, "license": "lgpl-2.1", "language": "c", "size": 1380}
{"docstring": "/* returns number of bytes left to be copied into rowbuf (capped to 62)\n * or -1 if we aren't capturing anything */\n", "func_signal": "static int rowbuf_remaining(struct sonly_dev *sdev)", "code": "{\n\tint r;\n\n\tif (sdev->rowbuf_offset == -1)\n\t\treturn -1;\n\n\tr = sdev->img_width - sdev->rowbuf_offset;\n\tif (r > 62)\n\t\tr = 62;\n\treturn r;\n}", "path": "Validity90/libfprint/libfprint/drivers/upeksonly.c", "commit_date": "2017-02-01 00:00:00", "repo_name": "nmikhailov/Validity90", "stars": 1839, "license": "lgpl-2.1", "language": "c", "size": 1380}
{"docstring": "/***** DRIVER STUFF *****/\n", "func_signal": "static void deactivate_done(struct fp_img_dev *dev)", "code": "{\n\tstruct sonly_dev *sdev = dev->priv;\n\n\tfp_dbg(\"\");\n\tfree_img_transfers(sdev);\n\tg_free(sdev->rowbuf);\n\tsdev->rowbuf = NULL;\n\n\tif (sdev->rows) {\n\t\tg_slist_foreach(sdev->rows, (GFunc) g_free, NULL);\n\t\tsdev->rows = NULL;\n\t}\n\n\tfpi_imgdev_deactivate_complete(dev);\n}", "path": "Validity90/libfprint/libfprint/drivers/upeksonly.c", "commit_date": "2017-02-01 00:00:00", "repo_name": "nmikhailov/Validity90", "stars": 1839, "license": "lgpl-2.1", "language": "c", "size": 1380}
{"docstring": "/*************************************************************************\n**************************************************************************\n#cat: free_shape - Deallocates a shape structure and all its allocated\n#cat:              attributes.\n\n   Input:\n      shape     - pointer to the shape structure to be deallocated\n**************************************************************************/\n", "func_signal": "void free_shape(SHAPE *shape)", "code": "{\n   int i;\n\n   /* Foreach allocated row in the shape ... */\n   for(i = 0; i < shape->alloc; i++){\n      /* Deallocate the current row's list of x-coords. */\n      free(shape->rows[i]->xs);\n      /* Deallocate the current row structure. */\n      free(shape->rows[i]);\n   }\n\n   /* Deallocate the list of row pointers. */\n   free(shape->rows);\n   /* Deallocate the shape structure. */\n   free(shape);\n}", "path": "Validity90/libfprint/libfprint/nbis/mindtct/shape.c", "commit_date": "2017-02-01 00:00:00", "repo_name": "nmikhailov/Validity90", "stars": 1839, "license": "lgpl-2.1", "language": "c", "size": 1380}
{"docstring": "/* add data to row buffer */\n", "func_signal": "static void add_to_rowbuf(struct fp_img_dev *dev, unsigned char *data, int size)", "code": "{\n\tstruct sonly_dev *sdev = dev->priv;\n\n\tmemcpy(sdev->rowbuf + sdev->rowbuf_offset, data, size);\n\tsdev->rowbuf_offset += size;\n\tif (sdev->rowbuf_offset >= sdev->img_width)\n\t\trow_complete(dev);\n\n}", "path": "Validity90/libfprint/libfprint/drivers/upeksonly.c", "commit_date": "2017-02-01 00:00:00", "repo_name": "nmikhailov/Validity90", "stars": 1839, "license": "lgpl-2.1", "language": "c", "size": 1380}
{"docstring": "/* TODO: process response properly */\n", "func_signal": "static void init_read_data_cb(struct libusb_transfer *transfer)", "code": "{\n\tstruct fpi_ssm *ssm = transfer->user_data;\n\n\tif (transfer->status == LIBUSB_TRANSFER_COMPLETED) {\n\t\tfpi_ssm_next_state(ssm);\n\t} else {\n\t\tfpi_ssm_mark_aborted(ssm, -EIO);\n\t}\n}", "path": "Validity90/libfprint/libfprint/drivers/upektc_img.c", "commit_date": "2017-02-01 00:00:00", "repo_name": "nmikhailov/Validity90", "stars": 1839, "license": "lgpl-2.1", "language": "c", "size": 1380}
{"docstring": "/* TODO: use calibration table, datasheet is rather terse on that\n * need more info for implementaion */\n", "func_signal": "static void calibrate_read_data_cb(struct libusb_transfer *transfer)", "code": "{\n\tstruct fpi_ssm *ssm = transfer->user_data;\n\n\tif (transfer->status == LIBUSB_TRANSFER_COMPLETED) {\n\t\tfpi_ssm_next_state(ssm);\n\t} else {\n\t\tfpi_ssm_mark_aborted(ssm, -EIO);\n\t}\n\tg_free(transfer->buffer);\n\tlibusb_free_transfer(transfer);\n}", "path": "Validity90/libfprint/libfprint/drivers/aes2550.c", "commit_date": "2017-02-01 00:00:00", "repo_name": "nmikhailov/Validity90", "stars": 1839, "license": "lgpl-2.1", "language": "c", "size": 1380}
{"docstring": "/*************************************************************************\n**************************************************************************\n#cat: gen_high_curve_map - Takes a Direction Map and generates a new map\n#cat:            that flags blocks with HIGH CURVATURE.\n\n   Input:\n      direction_map - map of blocks containing directional ridge flow\n      mw        - the width (in blocks) of the map\n      mh        - the height (in blocks) of the map\n      lfsparms  - parameters and thresholds for controlling LFS\n   Output:\n      ohcmap    - points to the created High Curvature Map\n   Return Code:\n      Zero     - successful completion\n      Negative - system error\n**************************************************************************/\n", "func_signal": "int gen_high_curve_map(int **ohcmap, int *direction_map,\n                   const int mw, const int mh, const LFSPARMS *lfsparms)", "code": "{\n   int *high_curve_map, mapsize;\n   int *hptr, *dptr;\n   int bx, by;\n   int nvalid, cmeasure, vmeasure;\n\n   mapsize = mw*mh;\n\n   /* Allocate High Curvature Map. */\n   high_curve_map = (int *)malloc(mapsize * sizeof(int));\n   if(high_curve_map == (int *)NULL){\n      fprintf(stderr,\n              \"ERROR: gen_high_curve_map : malloc : high_curve_map\\n\");\n      return(-530);\n   }\n   /* Initialize High Curvature Map to FALSE (0). */\n   memset(high_curve_map, 0, mapsize*sizeof(int));\n\n   hptr = high_curve_map;\n   dptr = direction_map;\n\n   /* Foreach row in maps ... */\n   for(by = 0; by < mh; by++){\n      /* Foreach column in maps ... */\n      for(bx = 0; bx < mw; bx++){\n\n         /* Count number of valid neighbors around current block ... */\n         nvalid = num_valid_8nbrs(direction_map, bx, by, mw, mh);\n\n         /* If valid neighbors exist ... */\n         if(nvalid > 0){\n            /* If current block's direction is INVALID ... */\n            if(*dptr == INVALID_DIR){\n               /* If a sufficient number of VALID neighbors exists ... */\n               if(nvalid >= lfsparms->vort_valid_nbr_min){\n                  /* Measure vorticity of neighbors. */\n                  vmeasure = vorticity(direction_map, bx, by, mw, mh,\n                                       lfsparms->num_directions);\n                  /* If vorticity is sufficiently high ... */\n                  if(vmeasure >= lfsparms->highcurv_vorticity_min)\n                     /* Flag block as HIGH CURVATURE. */\n                     *hptr = TRUE;\n               }\n            }\n            /* Otherwise block has valid direction ... */\n            else{\n               /* Measure curvature around the valid block. */\n               cmeasure = curvature(direction_map, bx, by, mw, mh,\n                                    lfsparms->num_directions);\n               /* If curvature is sufficiently high ... */\n               if(cmeasure >= lfsparms->highcurv_curvature_min)\n                  *hptr = TRUE;\n            }\n         } /* Else (nvalid <= 0) */\n\n         /* Bump pointers to next block in maps. */\n         dptr++;\n         hptr++;\n\n      } /* bx */\n   } /* by */\n\n   /* Assign High Curvature Map to output pointer. */         \n   *ohcmap = high_curve_map;\n\n   /* Return normally. */\n   return(0);\n}", "path": "Validity90/libfprint/libfprint/nbis/mindtct/maps.c", "commit_date": "2017-02-01 00:00:00", "repo_name": "nmikhailov/Validity90", "stars": 1839, "license": "lgpl-2.1", "language": "c", "size": 1380}
{"docstring": "/***** IMAGE PROCESSING *****/\n", "func_signal": "static void free_img_transfers(struct sonly_dev *sdev)", "code": "{\n\tint i;\n\tfor (i = 0; i < NUM_BULK_TRANSFERS; i++) {\n\t\tstruct libusb_transfer *transfer = sdev->img_transfer[i];\n\t\tif (!transfer)\n\t\t\tcontinue;\n\n\t\tg_free(transfer->buffer);\n\t\tlibusb_free_transfer(transfer);\n\t}\n\tg_free(sdev->img_transfer_data);\n}", "path": "Validity90/libfprint/libfprint/drivers/upeksonly.c", "commit_date": "2017-02-01 00:00:00", "repo_name": "nmikhailov/Validity90", "stars": 1839, "license": "lgpl-2.1", "language": "c", "size": 1380}
{"docstring": "/*************************************************************************\n**************************************************************************\n#cat: alloc_dir_powers - Allocates the memory associated with DFT power\n#cat:           vectors.  The DFT analysis is conducted block by block in the\n#cat:           input image, and within each block, N wave forms are applied\n#cat:           at M different directions.\n\n   Input:\n      nwaves - number of DFT wave forms\n      ndirs  - number of orientations (directions) used in DFT analysis\n   Output:\n      opowers - pointer to the allcated power vectors\n   Return Code:\n      Zero     - successful completion\n      Negative - system error\n**************************************************************************/\n", "func_signal": "int alloc_dir_powers(double ***opowers, const int nwaves, const int ndirs)", "code": "{\n   int w;\n   double **powers;\n\n   /* Allocate list of double pointers to hold power vectors */\n   powers = (double **)malloc(nwaves * sizeof(double*));\n   if(powers == (double **)NULL){\n      fprintf(stderr, \"ERROR : alloc_dir_powers : malloc : powers\\n\");\n      return(-40);\n   }\n   /* Foreach DFT wave ... */\n   for(w = 0; w < nwaves; w++){\n      /* Allocate power vector for all directions */\n      powers[w] = (double *)malloc(ndirs * sizeof(double));\n      if(powers[w] == (double *)NULL){\n         /* Free memory allocated to this point. */\n         { int _j; for(_j = 0; _j < w; _j++){\n            free(powers[_j]);\n         }}\n         free(powers);\n         fprintf(stderr, \"ERROR : alloc_dir_powers : malloc : powers[w]\\n\");\n         return(-41);\n      }\n   }\n\n   *opowers = powers;\n   return(0);\n}", "path": "Validity90/libfprint/libfprint/nbis/mindtct/init.c", "commit_date": "2017-02-01 00:00:00", "repo_name": "nmikhailov/Validity90", "stars": 1839, "license": "lgpl-2.1", "language": "c", "size": 1380}
{"docstring": "/*************************************************************************\n**************************************************************************\n#cat: curvature - Measures the largest change in direction between the\n#cat:             current IMAP direction and its immediate neighbors.\n\n   Input:\n      imap  - 2D vector of ridge flow directions\n      mx    - horizontal coord of current IMAP block\n      my    - vertical coord of current IMAP block\n      mw    - width (in blocks) of the IMAP\n      mh    - height (in blocks) of the IMAP\n      ndirs - number of possible directions in the IMAP\n   Return Code:\n      Non-negative - maximum change in direction found (curvature)\n      Negative     - No valid neighbor found to measure change in direction\n**************************************************************************/\n", "func_signal": "int curvature(int *imap, const int mx, const int my,\n              const int mw, const int mh, const int ndirs)", "code": "{\n   int *iptr;\n   int e_ind, w_ind, n_ind, s_ind;\n   int nw_val, n_val, ne_val, e_val, se_val, s_val, sw_val, w_val;\n   int cmeasure, dist;\n\n   /* Compute neighbor coordinates to current IMAP direction */\n   e_ind = mx+1;  /* East index */\n   w_ind = mx-1;  /* West index */\n   n_ind = my-1;  /* North index */\n   s_ind = my+1;  /* South index */\n\n   /* 1. Get NW IMAP value.  */\n   /* If neighbor indices are within IMAP boundaries ... */\n   if((w_ind >= 0) && (n_ind >= 0))\n      /* Set neighbor value to IMAP value. */\n      nw_val = *(imap + (n_ind*mw) + w_ind);\n   else\n      /* Otherwise, set the neighbor value to INVALID. */\n      nw_val = INVALID_DIR;\n\n   /* 2. Get N IMAP value.  */\n   if(n_ind >= 0)\n      n_val = *(imap + (n_ind*mw) + mx);\n   else\n      n_val = INVALID_DIR;\n\n   /* 3. Get NE IMAP value. */\n   if((n_ind >= 0) && (e_ind < mw))\n      ne_val = *(imap + (n_ind*mw) + e_ind);\n   else\n      ne_val = INVALID_DIR;\n\n   /* 4. Get E IMAP value. */\n   if(e_ind < mw)\n      e_val = *(imap + (my*mw) + e_ind);\n   else\n      e_val = INVALID_DIR;\n\n   /* 5. Get SE IMAP value. */\n   if((e_ind < mw) && (s_ind < mh))\n      se_val = *(imap + (s_ind*mw) + e_ind);\n   else\n      se_val = INVALID_DIR;\n\n   /* 6. Get S IMAP value. */\n   if(s_ind < mh)\n      s_val = *(imap + (s_ind*mw) + mx);\n   else\n      s_val = INVALID_DIR;\n\n   /* 7. Get SW IMAP value. */\n   if((w_ind >= 0) && (s_ind < mh))\n      sw_val = *(imap + (s_ind*mw) + w_ind);\n   else\n      sw_val = INVALID_DIR;\n\n   /* 8. Get W IMAP value. */\n   if(w_ind >= 0)\n      w_val = *(imap + (my*mw) + w_ind);\n   else\n      w_val = INVALID_DIR;\n\n   /* Now that we have all IMAP neighbors, determine largest change in */\n   /* direction from current block to each of its 8 VALID neighbors.   */\n\n   /* Initialize pointer to current IMAP value. */\n   iptr = imap + (my*mw) + mx;\n\n   /* Initialize curvature measure to negative as closest_dir_dist() */\n   /* always returns -1=INVALID or a positive value.                 */\n   cmeasure = -1;\n\n   /* 1. With NW */\n   /* Compute closest distance between neighboring directions. */\n   dist = closest_dir_dist(*iptr, nw_val, ndirs);\n   /* Keep track of maximum. */\n   if(dist > cmeasure)\n      cmeasure = dist;\n\n   /* 2. With N */\n   dist = closest_dir_dist(*iptr, n_val, ndirs);\n   if(dist > cmeasure)\n      cmeasure = dist;\n\n   /* 3. With NE */\n   dist = closest_dir_dist(*iptr, ne_val, ndirs);\n   if(dist > cmeasure)\n      cmeasure = dist;\n\n   /* 4. With E */\n   dist = closest_dir_dist(*iptr, e_val, ndirs);\n   if(dist > cmeasure)\n      cmeasure = dist;\n\n   /* 5. With SE */\n   dist = closest_dir_dist(*iptr, se_val, ndirs);\n   if(dist > cmeasure)\n      cmeasure = dist;\n\n   /* 6. With S */\n   dist = closest_dir_dist(*iptr, s_val, ndirs);\n   if(dist > cmeasure)\n      cmeasure = dist;\n\n   /* 7. With SW */\n   dist = closest_dir_dist(*iptr, sw_val, ndirs);\n   if(dist > cmeasure)\n      cmeasure = dist;\n\n   /* 8. With W */\n   dist = closest_dir_dist(*iptr, w_val, ndirs);\n   if(dist > cmeasure)\n      cmeasure = dist;\n\n   /* Return maximum difference between current block's IMAP direction */\n   /* and the rest of its VALID neighbors.                             */\n   return(cmeasure);\n}", "path": "Validity90/libfprint/libfprint/nbis/mindtct/maps.c", "commit_date": "2017-02-01 00:00:00", "repo_name": "nmikhailov/Validity90", "stars": 1839, "license": "lgpl-2.1", "language": "c", "size": 1380}
{"docstring": "/**********************************************************************************\n * Main function of the zxcvbn password entropy estimation\n */\n", "func_signal": "double ZxcvbnMatch(const char *Pwd, const char *UserDict[], ZxcMatch_t **Info)", "code": "{\n    int i, j;\n    ZxcMatch_t *Zp;\n    Node_t *Np;\n    double e;\n    int Len = strlen(Pwd);\n    const uint8_t *Passwd = (const uint8_t *)Pwd;\n    uint8_t *RevPwd;\n    /* Create the paths */\n    Node_t *Nodes = MallocFn(Node_t, Len+1);\n    memset(Nodes, 0, (Len+1) * sizeof *Nodes);\n    i = Cardinality(Passwd, Len);\n    e = log((double)i);\n\n    /* Do matching for all parts of the password */\n    for(i = 0; i < Len; ++i)\n    {\n        int MaxLen = Len - i;\n        /* Add all the 'paths' between groups of chars in the password, for current starting char */\n        UserMatch(&(Nodes[i].Paths), UserDict, Passwd, i, MaxLen);\n        DictionaryMatch(&(Nodes[i].Paths), Passwd, i, MaxLen);\n        DateMatch(&(Nodes[i].Paths), Passwd, i, MaxLen);\n        SpatialMatch(&(Nodes[i].Paths), Passwd, i, MaxLen);\n        SequenceMatch(&(Nodes[i].Paths), Passwd, i, MaxLen);\n        RepeatMatch(&(Nodes[i].Paths), Passwd, i, MaxLen);\n\n        /* Initially set distance to nearly infinite */\n        Nodes[i].Dist = DBL_MAX;\n    }\n\n    /* Reverse dictionary words check */\n    RevPwd = MallocFn(uint8_t, Len+1);\n    for(i = Len-1, j = 0; i >= 0; --i, ++j)\n        RevPwd[j] = Pwd[i];\n    RevPwd[j] = 0;\n    for(i = 0; i < Len; ++i)\n    {\n        ZxcMatch_t *Path = 0;\n        int MaxLen = Len - i;\n        DictionaryMatch(&Path, RevPwd, i, MaxLen);\n        UserMatch(&Path, UserDict, RevPwd, i, MaxLen);\n\n        /* Now transfer any reverse matches to the normal results */\n        while(Path)\n        {\n            ZxcMatch_t *Nxt = Path->Next;\n            Path->Next = 0;\n            Path->Begin = Len - (Path->Begin + Path->Length);\n            AddResult(&(Nodes[Path->Begin].Paths), Path, MaxLen);\n            Path = Nxt;\n        }\n    }\n\n    /* Add a set of brute force matches. Start by getting all the start points and all */\n    /* points at character position after end of the matches.  */\n    memset(RevPwd, 0, Len+1);\n    for(i = 0; i < Len; ++i)\n    {\n        ZxcMatch_t *Path = Nodes[i].Paths;\n        while(Path)\n        {\n            RevPwd[Path->Begin] |= 1;\n            RevPwd[Path->Begin + Path->Length] |= 2;\n            Path = Path->Next;\n        }\n    }\n    RevPwd[0] = 1;\n    RevPwd[Len] = 2;\n\n    /* Add the brute force matches */\n    for(i = 0; i < Len; ++i)\n    {\n        int MaxLen = Len - i;\n        int j;\n        if (!RevPwd[i])\n            continue;\n        for(j = i+1; j <= Len; ++j)\n        {\n            if (RevPwd[j])\n            {\n                Zp = AllocMatch();\n                Zp->Type = BRUTE_MATCH;\n                Zp->Begin = i;\n                Zp->Length = j - i;\n                Zp->Entrpy = e * (j - i);\n                AddResult(&(Nodes[i].Paths), Zp, MaxLen);\n            }\n        }\n    }\n    FreeFn(RevPwd);\n    /* End node has infinite distance/entropy, start node has 0 distance */\n    Nodes[i].Dist = DBL_MAX;\n    Nodes[0].Dist = 0.0;\n\n    /* Reduce the paths using Dijkstra's algorithm */\n    for(i = 0; i < Len; ++i)\n    {\n        int j;\n        double MinDist = DBL_MAX;\n        int MinIdx = 0;\n        /* Find the unvisited node with minimum distance or entropy */\n        for(Np = Nodes, j = 0; j < Len; ++j, ++Np)\n        {\n            if (!Np->Visit && (Np->Dist < MinDist))\n            {\n                MinIdx = j;\n                MinDist = Np->Dist;\n            }\n        }\n        /* Mark the minimum distance node as visited */\n        Np = Nodes + MinIdx;\n        Np->Visit = 1;\n        e = Np->Dist;\n        /* Update all unvisited neighbouring nodes with their new distance. A node is a */\n        /* neighbour if there is a path/match from current node Np to it. The neighbour */\n        /* distance is the current node distance plus the path distance/entropy. Only */\n        /* update if the new distance is smaller. */\n        for(Zp = Np->Paths; Zp; Zp = Zp->Next)\n        {\n            Node_t *Ep = Np + Zp->Length;\n            double d = e + Zp->MltEnpy;\n            if (!Ep->Visit &&  (d < Ep->Dist))\n            {\n                /* Update as lower dist, also remember the 'from' node */\n                Ep->Dist = d;\n                Ep->From = Zp;\n            }\n        }\n        /* If we got to the end node stop early */\n        /*if (Nodes[Len].Dist < DBL_MAX/2.0) */\n          /*  break; */\n    }\n    /* Make e hold entropy result and adjust to log base 2 */\n    e = Nodes[Len].Dist / log(2.0);\n\n    if (Info)\n    {\n        /* Construct info on password parts */\n        *Info = 0;\n        for(Zp = Nodes[Len].From; Zp; )\n        {\n            ZxcMatch_t *Xp;\n            i = Zp->Begin;\n\n            /* Remove all but required path */\n            Xp = Nodes[i].Paths;\n            Nodes[i].Paths = 0;\n            while(Xp)\n            {\n                ZxcMatch_t *p = Xp->Next;\n                if (Xp == Zp)\n                {\n                    /* Adjust the entropy to log to base 2 */\n                    Xp->Entrpy /= log(2.0);\n                    Xp->MltEnpy /= log(2.0);\n\n                    /* Put previous part at head of info list */\n                    Xp->Next = *Info;\n                    *Info = Xp;\n                }\n                else\n                {\n                    /* Not going on info list, so free it */\n                    FreeFn(Xp);\n                }\n                Xp = p;\n            }\n            Zp = Nodes[i].From;\n        }\n    }\n    /* Free all paths. Any being returned to caller have already been freed */\n    for(i = 0; i <= Len; ++i)\n    {\n        Zp = Nodes[i].Paths;\n        while(Zp)\n        {\n            ZxcMatch_t *p = Zp->Next;\n            FreeFn(Zp);\n            Zp = p;\n        }\n    }\n    FreeFn(Nodes);\n    return e;\n}", "path": "monero-gui/src/zxcvbn-c/zxcvbn.c", "commit_date": "2020-02-16 00:00:00", "repo_name": "monero-project/monero-gui", "stars": 1584, "license": "other", "language": "c", "size": 25057}
{"docstring": "/**********************************************************************************\n * Given a map entry create a string of all possible characters for following to\n * a child node\n */\n", "func_signal": "static int ListPossibleChars(uint8_t *List, const uint8_t *Map)", "code": "{\n    unsigned int i, j, k;\n    int Len = 0;\n    for(k = i = 0; i < SizeChildMapEntry; ++i, ++Map)\n    {\n        if (!*Map)\n        {\n            k += 8;\n            continue;\n        }\n        for(j = 0; j < 8; ++j)\n        {\n            if (*Map & (1<<j))\n            {\n                *List++ = CharSet[k];\n                ++Len;\n            }\n            ++k;\n        }\n    }\n    *List=0;\n    return Len;\n}", "path": "monero-gui/src/zxcvbn-c/zxcvbn.c", "commit_date": "2020-02-16 00:00:00", "repo_name": "monero-project/monero-gui", "stars": 1584, "license": "other", "language": "c", "size": 25057}
{"docstring": "/**********************************************************************************\n * Calculate potential number of different characters in the passed string.\n * Parameters:\n *  Str     The string of characters\n *  Len     The maximum number of characters to scan\n * Returns the potential number of different characters in the string.\n */\n", "func_signal": "static int Cardinality(const uint8_t *Str, int Len)", "code": "{\n    int Card=0, Types=0;\n    int c;\n    while(Len > 0)\n    {\n        c = *Str++ & 0xFF;\n        if (!c)\n            break;\n        if (islower(c))      Types |= 1;    /* Lowercase letter */\n        else if (isupper(c)) Types |= 2;    /* Uppercase letter */\n        else if (isdigit(c)) Types |= 4;    /* Numeric digit */\n        else if (c <= 0x7F)  Types |= 8;    /* Punctuation character */\n        else                 Types |= 16;   /* Other (Unicode?) */\n        --Len;\n    }\n    if (Types & 1)  Card += 26;\n    if (Types & 2)  Card += 26;\n    if (Types & 4)  Card += 10;\n    if (Types & 8)  Card += 33;\n    if (Types & 16) Card += 100;\n    return Card;\n}", "path": "monero-gui/src/zxcvbn-c/zxcvbn.c", "commit_date": "2020-02-16 00:00:00", "repo_name": "monero-project/monero-gui", "stars": 1584, "license": "other", "language": "c", "size": 25057}
{"docstring": "/**********************************************************************************\n * Try to match password part as a set of incrementing or decrementing characters.\n * Parameters:\n *  Result  Pointer head of linked list used to store results\n *  Passwd  The start of the password\n *  Start   Where in the password to start attempting to match\n *  MaxLen  Maximum number characters to consider\n */\n", "func_signal": "static void SequenceMatch(ZxcMatch_t **Result, const uint8_t *Passwd, int Start, int MaxLen)", "code": "{\n    int Len=0;\n    int SetLow, SetHigh, Dir;\n    uint8_t First, Next, IsDigits;\n    const uint8_t *Pwd;\n    Passwd += Start;\n    Pwd = Passwd;\n    First = Passwd[0];\n    Dir = Passwd[1] - First;\n    Len = 0;\n    IsDigits = 0;\n    /* Decide on min and max character code for sequence */\n    if (islower(*Passwd))\n    {\n        SetLow = 'a';\n        SetHigh = 'z';\n    }\n    else if (isupper(*Passwd))\n    {\n        SetLow = 'A';\n        SetHigh = 'Z';\n    }\n    else if (isdigit(*Passwd))\n    {\n        SetLow = '0';\n        SetHigh = '9';\n        if ((First == '0') && isdigit(Passwd[1]) && (Dir > MAX_SEQUENCE_STEP))\n        {\n            /* Special case for decrementing sequence of digits, treat '0 as a 'ten' character */\n            Dir = Passwd[1] - ('9' + 1);\n        }\n        IsDigits = 1;\n    }\n    else\n        return;\n\n    /* Only consider it a sequence if the character increment is not too large */\n    if (Dir && (Dir <= MAX_SEQUENCE_STEP) && (Dir >= -MAX_SEQUENCE_STEP))\n    {\n        ++Len;\n        while(1)\n        {\n            Next = Passwd[0] + Dir;\n            if (IsDigits && (Dir > 0) && (Next == ('9' + 1)) && (Passwd[1] == '0'))\n            {\n                /* Incrementing digits, consider '0' to be same as a 'ten' character */ \n                ++Len;\n                ++Passwd;\n                break;\n            }\n            if (IsDigits && (Dir < 0) && (Passwd[0] == '0') && (Passwd[1] == ('9'+1 + Dir)))\n            {\n                ++Len;\n                ++Passwd;\n            }\n            else if ((Next > SetHigh) || (Next < SetLow) || (Passwd[1] != Next))\n                break;\n            ++Len;\n            ++Passwd;\n            if (Len >= MaxLen)\n                break;\n        }\n    }\n    if (Len >= MIN_SEQUENCE_LEN)\n    {\n        /* Enough repeated char, so create results from number found down to min acceptable length */\n        int i;\n        double e;\n        if ((First == 'a') || (First == 'A') || (First == 'z') || (First == 'Z') ||\n            (First == '0') || (First == '1') || (First == '9'))\n            e = log(2.0);\n        else if (IsDigits)\n            e = log(10.0);\n        else if (isupper(First))\n            e = log(26*2.0);\n        else\n            e = log(26.0);\n        if (Dir < 0)\n            e += log(2.0);\n\n        for(i = Len; i >= MIN_SEQUENCE_LEN; --i)\n        {\n            ZxcMatch_t *p = AllocMatch();\n            /* Add new result to head of list as it has lower entropy */\n            p->Type = SEQUENCE_MATCH;\n            p->Begin = Start;\n            p->Length = i;\n            p->Entrpy = e + log((double)i);\n            AddMatchRepeats(Result, p, Pwd, MaxLen);\n            AddResult(Result, p, MaxLen);\n        }\n    }\n}", "path": "monero-gui/src/zxcvbn-c/zxcvbn.c", "commit_date": "2020-02-16 00:00:00", "repo_name": "monero-project/monero-gui", "stars": 1584, "license": "other", "language": "c", "size": 25057}
{"docstring": "/**********************************************************************************\n * Calculate the CRC-64 of passed data.\n * Parameters:\n *  Crc     The initial or previous CRC value\n *  v       Pointer to the data to add to CRC calculation\n *  Len     Length of the passed data\n * Returns the updated CRC value.\n */\n", "func_signal": "static uint64_t CalcCrc64(uint64_t Crc, const void *v, unsigned int Len)", "code": "{\n    const uint8_t *Data = (const unsigned char *)v;\n    while(Len--)\n    {\n        Crc = CrcTable[(Crc ^ (*Data >> 0)) & 0x0f] ^ (Crc >> 4);\n        Crc = CrcTable[(Crc ^ (*Data >> 4)) & 0x0f] ^ (Crc >> 4);\n        ++Data;\n    }\n    return Crc;\n}", "path": "monero-gui/src/zxcvbn-c/zxcvbn.c", "commit_date": "2020-02-16 00:00:00", "repo_name": "monero-project/monero-gui", "stars": 1584, "license": "other", "language": "c", "size": 25057}
{"docstring": "/**********************************************************************************\n * Allocate a ZxcMatch_t struct, clear it to zero\n */\n", "func_signal": "static ZxcMatch_t *AllocMatch()", "code": "{\n    ZxcMatch_t *p = MallocFn(ZxcMatch_t, 1);\n    memset(p, 0, sizeof *p);\n    return p;\n}", "path": "monero-gui/src/zxcvbn-c/zxcvbn.c", "commit_date": "2020-02-16 00:00:00", "repo_name": "monero-project/monero-gui", "stars": 1584, "license": "other", "language": "c", "size": 25057}
{"docstring": "/**********************************************************************************\n *  Try to match spatial patterns on the keyboard\n * Parameters:\n *  Result  Pointer head of linked list used to store results\n *  Passwd  The start of the password\n *  Start   Where in the password to start attempting to match\n *  MaxLen  Maximum number characters to consider\n */\n", "func_signal": "static void SpatialMatch(ZxcMatch_t **Result, const uint8_t *Passwd, int Start, int MaxLen)", "code": "{\n    unsigned int Indx;\n    int Len, CurLen;\n    SpatialMatchInfo_t Extra;\n    const Keyboard_t *k;\n    Passwd += Start;\n\n    for(CurLen = MaxLen; CurLen >= MIN_SPATIAL_LEN;CurLen = Len - 1)\n    {\n        Len = 0;\n        memset(&Extra, 0, sizeof Extra);\n        for(k = Keyboards, Indx = 0; Indx < (sizeof Keyboards / sizeof Keyboards[0]); ++Indx, ++k)\n        {\n            Len = DoSptlMatch(Passwd, CurLen, k, &Extra);\n            if (Len > 0)\n            {\n                /* Got a sequence of required length so add to result list */\n                int i, j, s;\n                double Degree, Entropy;\n                ZxcMatch_t *p;\n                Degree = (k->NumNear-1) - (double)k->NumBlank / (double)k->NumKeys;\n                s = k->NumKeys;\n                if (k->Shifts)\n                    s *= 2;\n\n                /* Estimate the number of possible patterns with length ranging 2 to match length and */\n                /* with turns ranging from 0 to match turns */\n                Entropy = 0.0;\n                for(i = 2; i <= Len; ++i)\n                {\n                    int PossTurns = Extra.Turns;\n                    if (PossTurns >= i)\n                        PossTurns = i-1;\n                    for(j = 1; j <= PossTurns; ++j)\n                        Entropy += nCk(i-1, j-1) * pow(Degree, j) * s;\n                }\n                if (Entropy > 0.0)\n                    Entropy = log(Entropy);\n                if (Extra.Shifts)\n                {\n                    /* Add extra entropy for shifted keys. (% instead of 5, A instead of a etc.) */\n                    /* Math is similar to extra entropy from uppercase letters in dictionary matches. */\n                    int Shift = Extra.Shifts;\n                    int Unshift = Len - Shift;\n\n                    Degree = 0.0;\n                    j = Shift;\n                    if (j > Unshift)\n                        j = Unshift;\n                    for(i = 0; i <= j; ++i)\n                    {\n                        Degree += nCk(Len, i);\n                    }\n                    if (Degree > 0.0)\n                        Entropy += log(Degree);\n                }\n                p = AllocMatch();\n                p->Type = SPATIAL_MATCH;\n                p->Begin = Start;\n                p->Entrpy = Entropy;\n                p->Length = Len;\n                AddMatchRepeats(Result, p, Passwd, MaxLen);\n                AddResult(Result, p, MaxLen);\n                break;\n            }\n        }\n    }\n}", "path": "monero-gui/src/zxcvbn-c/zxcvbn.c", "commit_date": "2020-02-16 00:00:00", "repo_name": "monero-project/monero-gui", "stars": 1584, "license": "other", "language": "c", "size": 25057}
{"docstring": "/**********************************************************************************\n * Function that does the word matching\n */\n", "func_signal": "static void DoDictMatch(const uint8_t *Passwd, int Start, int MaxLen, DictWork_t *Wrk, ZxcMatch_t **Result, DictMatchInfo_t *Extra, int Lev)", "code": "{\n    int Len;\n    uint8_t TempLeet[LEET_NORM_MAP_SIZE];\n    int Ord = Wrk->Ordinal;\n    int Caps = Wrk->Caps;\n    int Lower = Wrk->Lower;\n    unsigned int NodeLoc = Wrk->StartLoc;\n    uint8_t *PossChars = Wrk->PossChars;\n    int NumPossChrs = Wrk->NumPossChrs;\n    const uint8_t *Pwd = Passwd;\n    uint32_t NodeData = DictNodes[NodeLoc];\n    Passwd += Start;\n    for(Len = 0; *Passwd && (Len < MaxLen); ++Len, ++Passwd)\n    {\n        uint8_t c;\n        int w, x, y, z;\n        const uint8_t *q;\n        z = 0;\n        if (!Len && Wrk->First)\n        {\n            c = Wrk->First;\n        }\n        else\n        {\n            /* Get char and set of possible chars at current point in word. */\n            const uint8_t *Bmap;\n            c = *Passwd;\n            Bmap = ChildMap + (NodeData & ((1<<BITS_CHILD_PATT_INDEX)-1)) * SizeChildMapEntry;\n            NumPossChrs = ListPossibleChars(PossChars, Bmap);\n\n            /* Make it lowercase and update lowercase, uppercase counts */\n            if (isupper(c))\n            {\n                c = tolower(c);\n                ++Caps;\n            }\n            else if (islower(c))\n            {\n                ++Lower;\n            }\n            /* See if current char is a leet and can be converted  */\n            q = CharBinSearch(c, L33TCnv, sizeof L33TCnv / LEET_NORM_MAP_SIZE, LEET_NORM_MAP_SIZE);\n            if (q)\n            {\n                /* Found, see if used before */\n                unsigned int j;\n                unsigned int i = (q - L33TCnv ) / LEET_NORM_MAP_SIZE;\n                if (Wrk->LeetCnv[i])\n                {\n                    /* Used before, so limit characters to try */\n                    TempLeet[0] = c;\n                    TempLeet[1] = Wrk->LeetCnv[i];\n                    TempLeet[2] = 0;\n                    q = TempLeet;\n                }\n                for(j = 0; (*q > ' ') && (j < LEET_NORM_MAP_SIZE); ++j, ++q)\n                {\n                    const uint8_t *r = CharBinSearch(*q, PossChars, NumPossChrs, 1);\n                    if (r)\n                    {\n                        /* valid conversion from leet */\n                        DictWork_t w;\n                        w = *Wrk;\n                        w.StartLoc = NodeLoc;\n                        w.Ordinal = Ord;\n                        w.PwdLength += Len;\n                        w.Caps = Caps;\n                        w.Lower = Lower;\n                        w.First = *r;\n                        w.NumPossChrs = NumPossChrs;\n                        memcpy(w.PossChars, PossChars, sizeof w.PossChars);\n                        if (j)\n                        {\n                            w.LeetCnv[i] = *r;\n                            AddLeetChr(*r, -1, w.Leeted, w.UnLeet);\n                        }\n                        DoDictMatch(Pwd, Passwd - Pwd, MaxLen - Len, &w, Result, Extra, Lev+1);\n                    }\n                }\n                return;\n            }\n        }\n        q = CharBinSearch(c, PossChars, NumPossChrs, 1);\n        if (q)\n        {\n            /* Found the char as a normal char */\n            if (CharBinSearch(c, L33TChr, sizeof L33TChr - 1, 1))\n            {\n                /* Char matches, but also a normal equivalent to a leet char */\n                AddLeetChr(c, 0,  Wrk->Leeted, Wrk->UnLeet);\n            }\n        }\n        if (!q)\n        {\n            /* No match for char - return */\n            return;\n        }\n        /* Add all the end counts of the child nodes before the one that matches */\n        x = (q - Wrk->PossChars);\n        y = (NodeData >> BITS_CHILD_PATT_INDEX) & ((1 << BITS_CHILD_MAP_INDEX) - 1);\n        NodeLoc = ChildLocs[x+y];\n        for(w=0; w<x; ++w)\n        {\n            unsigned int Cloc = ChildLocs[w+y];\n            z = EndCountSml[Cloc];\n            if (Cloc < NumLargeCounts)\n                z += EndCountLge[Cloc]*256;\n            Ord += z;\n        }\n\n        /* Move to next node */\n        NodeData = DictNodes[NodeLoc];\n        if (WordEndBits[NodeLoc >> 3] & (1<<(NodeLoc & 7)))\n        {\n            /* Word matches, save result */\n            unsigned int v;\n            ZxcMatch_t *p;\n            v = Ranks[Ord];\n            if (v & (1<<15))\n                v = (v & ((1 << 15) - 1)) * 4 + (1 << 15);\n            Extra->Caps = Caps;\n            Extra->Rank = v;\n            Extra->Lower = Lower;\n            for(x = 0, y = sizeof Extra->Leeted - 1; y >= 0; --y)\n                x += Wrk->Leeted[y];\n            Extra->NumLeet = x;\n\n            memcpy(Extra->UnLeet, Wrk->UnLeet, sizeof Extra->UnLeet);\n            memcpy(Extra->Leeted, Wrk->Leeted, sizeof Extra->Leeted);\n\n            p = AllocMatch();\n            if (x)\n                p->Type = DICT_LEET_MATCH;\n            else\n                p->Type = DICTIONARY_MATCH;\n            p->Length = Wrk->PwdLength + Len + 1;\n            p->Begin = Wrk->Begin;\n            DictionaryEntropy(p, Extra, Pwd);\n            AddMatchRepeats(Result, p, Pwd, MaxLen);\n            AddResult(Result, p, MaxLen);\n            ++Ord;\n        }\n    }\n}", "path": "monero-gui/src/zxcvbn-c/zxcvbn.c", "commit_date": "2020-02-16 00:00:00", "repo_name": "monero-project/monero-gui", "stars": 1584, "license": "other", "language": "c", "size": 25057}
{"docstring": "/**********************************************************************************\n * Given details of a word match, update it with the entropy (as natural log of\n * number of possiblities)\n */\n", "func_signal": "static void DictionaryEntropy(ZxcMatch_t *m, DictMatchInfo_t *Extra, const uint8_t *Pwd)", "code": "{\n    double e = 0.0;\n    /* Add allowance for uppercase letters */\n    if (Extra->Caps)\n    {\n        if (Extra->Caps == m->Length)\n        {\n            /* All uppercase, common case so only 1 bit */\n            e += log(2.0);\n        }\n        else if ((Extra->Caps == 1) && (isupper(*Pwd) || isupper(Pwd[m->Length - 1])))\n        {\n            /* Only first or last uppercase, also common so only 1 bit */\n            e += log(2.0);\n        }\n        else\n        {\n            /* Get number of combinations of lowercase, uppercase letters */\n            int Up = Extra->Caps;\n            int Lo = Extra->Lower;\n            int i = Up;\n            if (i > Lo)\n                i = Lo;\n            for(Lo += Up; i >= 0; --i)\n                e += nCk(Lo, i);\n            if (e > 0.0)\n                e = log(e);\n        }\n    }\n    /* Add allowance for using leet substitution */\n    if (Extra->NumLeet)\n    {\n        int i;\n        double d = 0.0;\n        for(i = sizeof Extra->Leeted - 1; i >= 0; --i)\n        {\n            int Sb = Extra->Leeted[i];\n            if (Sb)\n            {\n                int Un = Extra->UnLeet[i];\n                int j = m->Length - Extra->NumLeet;\n                if ((j >= 0) && (Un > j))\n                    Un = j;\n                j = Sb;\n                if (j > Un)\n                    j = Un;\n                for(Un += Sb; j >= 0; --j)\n                {\n                    double z = nCk(Un, j);\n                    d += z;\n                }\n            }\n        }\n        if (d > 0.0)\n            d = log(d);\n        if (d < log(2.0))\n            d = log(2.0);\n        e += d;\n    }\n    /* Add entropy due to word's rank */\n    e += log((double)Extra->Rank);\n    m->Entrpy = e;\n}", "path": "monero-gui/src/zxcvbn-c/zxcvbn.c", "commit_date": "2020-02-16 00:00:00", "repo_name": "monero-project/monero-gui", "stars": 1584, "license": "other", "language": "c", "size": 25057}
{"docstring": "/**********************************************************************************\n * Add new match struct to linked list of matches. List ordered with shortest at\n * head of list. Note: passed new match struct in parameter Nu may be de allocated.\n */\n", "func_signal": "static void AddResult(ZxcMatch_t **HeadRef, ZxcMatch_t *Nu, int MaxLen)", "code": "{\n    /* Adjust the entropy to be used for calculations depending on whether the passed match is\n     * at the begining, middle or end of the password\n     */\n    if (Nu->Begin)\n    {\n        if (Nu->Length >= MaxLen)\n            Nu->MltEnpy = Nu->Entrpy + MULTI_END_ADDITION * log(2.0);\n        else\n            Nu->MltEnpy = Nu->Entrpy + MULTI_MID_ADDITION * log(2.0);\n    }\n    else\n        Nu->MltEnpy = Nu->Entrpy;\n\n    /* Find the correct insert point */\n    while(*HeadRef && ((*HeadRef)->Length < Nu->Length))\n        HeadRef = &((*HeadRef)->Next);\n\n    /* Add new entry or replace existing */\n    if (*HeadRef && ((*HeadRef)->Length == Nu->Length))\n    {\n        /* New entry has same length as existing, so one of them needs discarding */\n        if ((*HeadRef)->MltEnpy <= Nu->MltEnpy)\n        {\n            /* Existing entry has lower entropy - keep it, discard new entry */\n            FreeFn(Nu);\n        }\n        else\n        {\n            /* New entry has lower entropy - replace existing entry */\n            Nu->Next = (*HeadRef)->Next;\n            FreeFn(*HeadRef);\n            *HeadRef = Nu;\n        }\n    }\n    else\n    {\n        /* New entry has different length, so add it */\n        Nu->Next = *HeadRef;\n        *HeadRef = Nu;\n    }\n}", "path": "monero-gui/src/zxcvbn-c/zxcvbn.c", "commit_date": "2020-02-16 00:00:00", "repo_name": "monero-project/monero-gui", "stars": 1584, "license": "other", "language": "c", "size": 25057}
{"docstring": "/**********************************************************************************\n * Increment count of each char that could be leeted.\n */\n", "func_signal": "static void AddLeetChr(uint8_t c, int IsLeet, uint8_t *Leeted, uint8_t *UnLeet)", "code": "{\n    const uint8_t *p = CharBinSearch(c, L33TChr, sizeof L33TChr - 1, 1);\n    if (p)\n    {\n        int i = p - L33TChr;\n        if (IsLeet > 0)\n        {\n            Leeted[i] += 1;\n        }\n        else if (IsLeet < 0)\n        {\n            Leeted[i] += 1;\n            UnLeet[i] -= 1;\n        }\n        else\n        {\n            UnLeet[i] += 1;\n        }\n    }\n}", "path": "monero-gui/src/zxcvbn-c/zxcvbn.c", "commit_date": "2020-02-16 00:00:00", "repo_name": "monero-project/monero-gui", "stars": 1584, "license": "other", "language": "c", "size": 25057}
{"docstring": "/**********************************************************************************\n * Free the path info returned by ZxcvbnMatch().\n */\n", "func_signal": "void ZxcvbnFreeInfo(ZxcMatch_t *Info)", "code": "{\n    ZxcMatch_t *p;\n    while(Info)\n    {\n        p = Info->Next;\n        FreeFn(Info);\n        Info = p;\n    }\n}", "path": "monero-gui/src/zxcvbn-c/zxcvbn.c", "commit_date": "2020-02-16 00:00:00", "repo_name": "monero-project/monero-gui", "stars": 1584, "license": "other", "language": "c", "size": 25057}
{"docstring": "/**********************************************************************************\n * Try to match the password with the formats above.\n */\n", "func_signal": "static void DateMatch(ZxcMatch_t **Result, const uint8_t *Passwd, int Start, int MaxLen)", "code": "{\n    int CurFmt;\n    int YrLen = 0;\n    int PrevLen = 0;\n    uint8_t Sep = 0;\n    Passwd += Start;\n\n    for(CurFmt = 0; Formats[CurFmt]; ++CurFmt)\n    {\n        int Len = 0;\n        int Year = 0;\n        int Mon  = 0;\n        int Day  = 0;\n        int Fail = 0;\n        const uint8_t *p = Passwd;\n        const char *Fmt;\n        YrLen = 0;\n        Sep = 0;\n        /* Scan along the format, trying to match the password */\n        for(Fmt = Formats[CurFmt]; *Fmt && !Fail; ++Fmt)\n        {\n            if (*Fmt == '?')\n            {\n                if (!Sep && strchr(DateSeperators, *p))\n                        Sep = *p;\n                Fail = (*p != Sep);\n            }\n            else if (isdigit(*p))\n            {\n                if (*Fmt == 'd')\n                {\n                    Day = 10 * Day + *p - '0';\n                }\n                else if (*Fmt == 'm')\n                {\n                    Mon = 10 * Mon + *p - '0';\n                }\n                else\n                {\n                    Year = 10 * Year + *p - '0';\n                    ++YrLen;\n                }\n            }\n            else\n            {\n                Fail = 1;\n            }\n            ++p;\n            ++Len;\n            if (Len >= MaxLen)\n                break;\n        }\n        if (Len < 4)\n            Fail = 1;\n        if (!Fail)\n        {\n            /* Character matching is OK, now check to see if valid date */\n            if (((YrLen > 3) || (Len <= 4)) && ((Year < MIN_YEAR) || (Year > MAX_YEAR)))\n                Fail = 1;\n            else if (Len > 4)\n            {\n                if ((Mon > 12) && (Day < 13))\n                {\n                    /* Swap day,month to try to make both in range */\n                    int i = Mon;\n                    Mon = Day;\n                    Day = i;\n                }\n                /* Check for valid day, month. Currently assumes all months have 31 days. */\n                if ((Mon < 1) || (Mon > 12))\n                    Fail = 1;\n                else if ((Day < 1) || (Day > 31))\n                    Fail = 1;\n            }\n        }\n        if (!Fail && (Len > PrevLen))\n        {\n            /* String matched the date, store result */\n            double e;\n            ZxcMatch_t *p = AllocMatch();\n\n            if (Len <= 4)\n                e = log(MAX_YEAR - MIN_YEAR + 1.0);\n            else if (YrLen > 3)\n                e = log(31 * 12 * (MAX_YEAR - MIN_YEAR + 1.0));\n            else\n                e = log(31 * 12 * 100.0);\n            if (Sep)\n                e += log(4.0);  /* Extra 2 bits for separator */\n            p->Entrpy = e;\n            p->Type = DATE_MATCH;\n            p->Length = Len;\n            p->Begin = Start;\n            AddMatchRepeats(Result, p, Passwd, MaxLen);\n            AddResult(Result, p, MaxLen);\n            PrevLen = Len;\n        }\n    }\n}", "path": "monero-gui/src/zxcvbn-c/zxcvbn.c", "commit_date": "2020-02-16 00:00:00", "repo_name": "monero-project/monero-gui", "stars": 1584, "license": "other", "language": "c", "size": 25057}
{"docstring": "/**********************************************************************************\n * Free the data allocated by ZxcvbnInit().\n */\n", "func_signal": "void ZxcvbnUnInit()", "code": "{\n    if (DictNodes)\n        FreeFn(DictNodes);\n    DictNodes = 0;\n}", "path": "monero-gui/src/zxcvbn-c/zxcvbn.c", "commit_date": "2020-02-16 00:00:00", "repo_name": "monero-project/monero-gui", "stars": 1584, "license": "other", "language": "c", "size": 25057}
{"docstring": "/**********************************************************************************\n * Read the dictionary data from file.\n * Parameters:\n *  Filename    Name of the file to read.\n * Returns 1 on success, 0 on error\n */\n", "func_signal": "int ZxcvbnInit(const char *Filename)", "code": "{\n    FileHandle f;\n    uint64_t Crc = CHK_INIT;\n    if (DictNodes)\n        return 1;\n    MyOpenFile(f, Filename);\n    if (f)\n    {\n        unsigned int i, DictSize;\n\n        /* Get magic number */\n        if (!MyReadFile(f, &i, sizeof i))\n            i = 0;\n\n        /* Get header data */\n        if (!MyReadFile(f, &NumNodes, sizeof NumNodes))\n            i = 0;\n        if (!MyReadFile(f, &NumChildLocs, sizeof NumChildLocs))\n            i = 0;\n        if (!MyReadFile(f, &NumRanks, sizeof NumRanks))\n            i = 0;\n        if (!MyReadFile(f, &NumWordEnd, sizeof NumWordEnd))\n            i = 0;\n        if (!MyReadFile(f, &NumChildMaps, sizeof NumChildMaps))\n            i = 0;\n        if (!MyReadFile(f, &SizeChildMapEntry, sizeof SizeChildMapEntry))\n            i = 0;\n        if (!MyReadFile(f, &NumLargeCounts, sizeof NumLargeCounts))\n            i = 0;\n        if (!MyReadFile(f, &NumSmallCounts, sizeof NumSmallCounts))\n            i = 0;\n        if (!MyReadFile(f, &SizeCharSet, sizeof SizeCharSet))\n            i = 0;\n\n        /* Validate the header data */\n        if (NumNodes >= (1<<17))\n            i = 1;\n        if (NumChildLocs >= (1<<BITS_CHILD_MAP_INDEX))\n            i = 2;\n        if (NumChildMaps >= (1<<BITS_CHILD_PATT_INDEX))\n            i = 3;\n        if ((SizeChildMapEntry*8) < SizeCharSet)\n            i = 4;\n        if (NumLargeCounts >= (1<<9))\n            i = 5;\n        if (NumSmallCounts != NumNodes)\n            i = 6;\n\n        if (i != MAGIC)\n        {\n            MyCloseFile(f);\n            return 0;\n        }\n        Crc = CalcCrc64(Crc, &i,    sizeof i);\n        Crc = CalcCrc64(Crc, &NumNodes,     sizeof NumNodes);\n        Crc = CalcCrc64(Crc, &NumChildLocs, sizeof NumChildLocs);\n        Crc = CalcCrc64(Crc, &NumRanks,     sizeof NumRanks);\n        Crc = CalcCrc64(Crc, &NumWordEnd,   sizeof NumWordEnd);\n        Crc = CalcCrc64(Crc, &NumChildMaps, sizeof NumChildMaps);\n        Crc = CalcCrc64(Crc, &SizeChildMapEntry, sizeof SizeChildMapEntry);\n        Crc = CalcCrc64(Crc, &NumLargeCounts,   sizeof NumLargeCounts);\n        Crc = CalcCrc64(Crc, &NumSmallCounts,   sizeof NumSmallCounts);\n        Crc = CalcCrc64(Crc, &SizeCharSet,      sizeof SizeCharSet);\n\n        DictSize = NumNodes*sizeof(*DictNodes) + NumChildLocs*sizeof(*ChildLocs) + NumRanks*sizeof(*Ranks) +\n                   NumWordEnd + NumChildMaps*SizeChildMapEntry + NumLargeCounts + NumSmallCounts + SizeCharSet;\n        if (DictSize < MAX_DICT_FILE_SIZE)\n        {\n            DictNodes = MallocFn(unsigned int, DictSize / sizeof(unsigned int) + 1);\n            if (!MyReadFile(f, DictNodes, DictSize))\n            {\n                FreeFn(DictNodes);\n                DictNodes = 0;\n            }\n        }\n        MyCloseFile(f);\n\n        if (!DictNodes)\n            return 0;\n        /* Check crc */\n        Crc = CalcCrc64(Crc, DictNodes, DictSize);\n        if (memcmp(&Crc, WordCheck, sizeof Crc))\n        {\n            /* File corrupted */\n            FreeFn(DictNodes);\n            DictNodes = 0;\n            return 0;\n        }\n        fflush(stdout);\n        /* Set pointers to the data */\n        ChildLocs = DictNodes + NumNodes;\n        Ranks = (unsigned short *)(ChildLocs + NumChildLocs);\n        WordEndBits = (unsigned char *)(Ranks + NumRanks);\n        ChildMap = (unsigned char*)(WordEndBits + NumWordEnd);\n        EndCountLge = ChildMap + NumChildMaps*SizeChildMapEntry;\n        EndCountSml = EndCountLge + NumLargeCounts;\n        CharSet = (char *)EndCountSml + NumSmallCounts;\n        CharSet[SizeCharSet] = 0;\n        return 1;\n    }\n    return 0;\n}", "path": "monero-gui/src/zxcvbn-c/zxcvbn.c", "commit_date": "2020-02-16 00:00:00", "repo_name": "monero-project/monero-gui", "stars": 1584, "license": "other", "language": "c", "size": 25057}
{"docstring": "/**********************************************************************************\n * See if the match is repeated. If it is then add a new repeated match to the results.\n */\n", "func_signal": "static void AddMatchRepeats(ZxcMatch_t **Result, ZxcMatch_t *Match, const uint8_t *Passwd, int MaxLen)", "code": "{\n    int Len = Match->Length;\n    const uint8_t *Rpt = Passwd + Len;\n    int RepeatCount = 2;\n\n    while(MaxLen >= (Len * RepeatCount))\n    {\n        if (strncmp((const char *)Passwd, (const char *)Rpt, Len) == 0)\n        {\n            /* Found a repeat */\n            ZxcMatch_t *p = AllocMatch();\n            p->Entrpy = Match->Entrpy + log(RepeatCount);\n            p->Type = (ZxcTypeMatch_t)(Match->Type + MULTIPLE_MATCH);\n            p->Length = Len * RepeatCount;\n            p->Begin = Match->Begin;\n            AddResult(Result, p, MaxLen);\n        }\n        else\n            break;\n        ++RepeatCount;\n        Rpt += Len;\n    }\n}", "path": "monero-gui/src/zxcvbn-c/zxcvbn.c", "commit_date": "2020-02-16 00:00:00", "repo_name": "monero-project/monero-gui", "stars": 1584, "license": "other", "language": "c", "size": 25057}
{"docstring": "/**********************************************************************************\n * Try to match password part with user supplied dictionary words\n * Parameters:\n *  Result  Pointer head of linked list used to store results\n *  Words   Array of pointers to dictionary words\n *  Passwd  The start of the password\n *  Start   Where in the password to start attempting to match\n *  MaxLen  Maximum number characters to consider\n */\n", "func_signal": "static void UserMatch(ZxcMatch_t **Result, const char *Words[], const uint8_t *Passwd, int Start, int MaxLen)", "code": "{\n    int Rank;\n    if (!Words)\n        return;\n    Passwd += Start;\n    for(Rank = 0; Words[Rank]; ++Rank)\n    {\n        DictMatchInfo_t Extra;\n        uint8_t LeetChr[sizeof L33TCnv / LEET_NORM_MAP_SIZE + 1];\n        uint8_t TempLeet[3];\n        int Len = 0;\n        int Caps = 0;\n        int Lowers = 0;\n        int Leets = 0;\n        const uint8_t *Wrd = (const uint8_t *)(Words[Rank]);\n        const uint8_t *Pwd = Passwd;\n        memset(Extra.Leeted, 0, sizeof Extra.Leeted);\n        memset(Extra.UnLeet, 0, sizeof Extra.UnLeet);\n        memset(LeetChr, 0, sizeof LeetChr);\n        while(*Wrd)\n        {\n            const uint8_t *q;\n            uint8_t d = tolower(*Wrd++);\n            uint8_t c = *Pwd++;\n            if (isupper(c))\n            {\n                c = tolower(c);\n                ++Caps;\n            }\n            else if (islower(c))\n            {\n                ++Lowers;\n            }\n            /* See if current char is a leet and can be converted  */\n            q = CharBinSearch(c, L33TCnv, sizeof L33TCnv / LEET_NORM_MAP_SIZE, LEET_NORM_MAP_SIZE);\n            if (q)\n            {\n                /* Found, see if used before */\n                unsigned int j;\n                unsigned int i = (q - L33TCnv ) / LEET_NORM_MAP_SIZE;\n                if (LeetChr[i])\n                {\n                    /* Used before, so limit characters to try */\n                    TempLeet[0] = c;\n                    TempLeet[1] = LeetChr[i];\n                    TempLeet[2] = 0;\n                    q = TempLeet;\n                }\n                c = d+1;\n                for(j = 0; (*q > ' ') && (j < LEET_NORM_MAP_SIZE); ++j, ++q)\n                {\n                    if (d == *q)\n                    {\n                        c = d;\n                        if (i)\n                        {\n                            LeetChr[i] = c;\n                            AddLeetChr(c, 1, Extra.Leeted, Extra.UnLeet);\n                            ++Leets;\n                        }\n                        break;\n                    }\n                }\n                if (c != d)\n                {\n                    Len = 0;\n                    break;\n                }\n            }\n            else if (c == d)\n            {\n                /* Found the char as a normal char */\n                if (CharBinSearch(c, L33TChr, sizeof L33TChr - 1, 1))\n                {\n                    /* Char matches, but also a normal equivalent to a leet char */\n                    AddLeetChr(c, 0,  Extra.Leeted, Extra.UnLeet);\n                }\n            }\n            else\n            {\n                /* No Match */\n                Len = 0;\n                break;\n            }\n            if (++Len > MaxLen)\n            {\n                Len = 0;\n                break;\n            }\n        }\n        if (Len)\n        {\n            ZxcMatch_t *p = AllocMatch();\n            if (!Leets)\n                p->Type = USER_MATCH;\n            else\n                p->Type = USER_LEET_MATCH;\n            p->Length = Len;\n            p->Begin = Start;\n            /* Add Entrpy */\n            Extra.Caps = Caps;\n            Extra.Lower = Lowers;\n            Extra.NumLeet = Leets;\n            Extra.Rank = Rank+1;\n            DictionaryEntropy(p, &Extra, Passwd);\n            AddMatchRepeats(Result, p, Passwd, MaxLen);\n            AddResult(Result, p, MaxLen);\n        }\n    }\n}", "path": "monero-gui/src/zxcvbn-c/zxcvbn.c", "commit_date": "2020-02-16 00:00:00", "repo_name": "monero-project/monero-gui", "stars": 1584, "license": "other", "language": "c", "size": 25057}
{"docstring": "/**********************************************************************************\n * Binomial coefficient function. Uses method described at\n *      http://blog.plover.com/math/choose.html\n */\n", "func_signal": "static double nCk(int n, int k)", "code": "{\n    int d;\n    double r;\n    if (k > n)\n        return 0.0;\n    if (!k)\n        return 1.0;\n    r = 1.0;\n    for(d = 1; d <= k; ++d)\n    {\n        r *= n--;\n        r /= d;\n    }\n    return r;\n}", "path": "monero-gui/src/zxcvbn-c/zxcvbn.c", "commit_date": "2020-02-16 00:00:00", "repo_name": "monero-project/monero-gui", "stars": 1584, "license": "other", "language": "c", "size": 25057}
{"docstring": "/**********************************************************************************\n * Try to match password part as a set of repeated characters.\n * Parameters:\n *  Result  Pointer head of linked list used to store results\n *  Passwd  The start of the password\n *  Start   Where in the password to start attempting to match\n *  MaxLen  Maximum number characters to consider\n */\n", "func_signal": "static void RepeatMatch(ZxcMatch_t **Result, const uint8_t *Passwd, int Start, int MaxLen)", "code": "{\n    int Len, i;\n    uint8_t c;\n    Passwd += Start;\n    /* Remember first char and the count its occurances */\n    c = *Passwd;\n    for(Len = 1; (Len < MaxLen) && (c == Passwd[Len]); ++Len)\n    { }\n    if (Len >= MIN_REPEAT_LEN)\n    {\n        /* Enough repeated char, so create results from number found down to min acceptable repeats */\n        double Card = Cardinality(&c, 1);\n        for(i = Len; i >= MIN_REPEAT_LEN; --i)\n        {\n            ZxcMatch_t *p = AllocMatch();\n            p->Type = REPEATS_MATCH;\n            p->Begin = Start;\n            p->Length = i;\n            p->Entrpy = log(Card * i);\n            AddResult(Result, p, MaxLen);\n        }\n    }\n\n    /* Try to match a repeated sequence e.g. qxno6qxno6 */\n    for(Len = MaxLen/2; Len >= MIN_REPEAT_LEN; --Len)\n    {\n        const uint8_t *Rpt = Passwd + Len;\n        int RepeatCount = 2;\n        while(MaxLen >= (Len * RepeatCount))\n        {\n            if (strncmp((const char *)Passwd, (const char *)Rpt, Len) == 0)\n            {\n                /* Found a repeat */\n                int c = Cardinality(Passwd, Len);\n                ZxcMatch_t *p = AllocMatch();\n                p->Entrpy = log((double)c) * Len + log(RepeatCount);\n                p->Type = (ZxcTypeMatch_t)(BRUTE_MATCH + MULTIPLE_MATCH);\n                p->Length = Len * RepeatCount;\n                p->Begin = Start;\n                AddResult(Result, p, MaxLen);\n            }\n            else\n                break;\n            ++RepeatCount;\n            Rpt += Len;\n        }\n    }\n}", "path": "monero-gui/src/zxcvbn-c/zxcvbn.c", "commit_date": "2020-02-16 00:00:00", "repo_name": "monero-project/monero-gui", "stars": 1584, "license": "other", "language": "c", "size": 25057}
{"docstring": "/**********************************************************************************\n * Binary search function to find a character in a string.\n * Parameters:\n *  Ch      The character to find\n *  Ents    The string to search\n *  NumEnts The number character groups in the string Ents\n *  SizeEnt The size of each character group.\n * Returns a pointer to the found character, or null if not found.\n */\n", "func_signal": "static const uint8_t *CharBinSearch(uint8_t Ch, const uint8_t *Ents, unsigned int NumEnts, unsigned int SizeEnt)", "code": "{\n    while(NumEnts > 0)\n    {\n        const uint8_t *Mid = Ents + (NumEnts >> 1) * SizeEnt;\n        int Dif = Ch - *Mid;\n        if (!Dif)\n        {\n            return Mid;\n        }\n        if (Dif > 0)\n        {\n            Ents = Mid + SizeEnt;\n            --NumEnts;\n        }\n        NumEnts /= 2;\n    }\n    return 0;\n}", "path": "monero-gui/src/zxcvbn-c/zxcvbn.c", "commit_date": "2020-02-16 00:00:00", "repo_name": "monero-project/monero-gui", "stars": 1584, "license": "other", "language": "c", "size": 25057}
{"docstring": "/**\n* Gets a list of the pids in\n*/\n", "func_signal": "static GSList *getPids()", "code": "{\n    GSList *pids = NULL;\n    FILE *ps_output;\n    const gchar ps_command[] = \"ps -C tilda -o pid=\";\n    gchar buf[16]; /* Really shouldn't need more than 6 */\n\n    if ((ps_output = popen (ps_command, \"r\")) == NULL) {\n        g_printerr (_(\"Unable to run command: `%s'\\n\"), ps_command);\n        return NULL;\n    }\n\n    /* The popen() succeeded, get all of the pids */\n    while (fgets (buf, sizeof(buf), ps_output) != NULL)\n        pids = g_slist_append (pids, GINT_TO_POINTER (atoi (buf)));\n\n    /* We've read all of the pids, exit */\n    pclose (ps_output);\n    return pids;\n}", "path": "tilda/src/tilda-lock-files.c", "commit_date": "2020-12-29 00:00:00", "repo_name": "lanoxx/tilda", "stars": 1230, "license": "gpl-2.0", "language": "c", "size": 4155}
{"docstring": "/**\n *  This function is called, if the user has changed a single color. The function\n *  handles this color change, and sets the color schema to \"Custom\".\n */\n", "func_signal": "static void colorbutton_palette_n_set_cb (GtkWidget *w, tilda_window *tw)", "code": "{\n    DEBUG_FUNCTION(\"colorbutton_palette_n_set_cb\");\n    const GtkWidget *combo_palette_scheme =\n        GTK_WIDGET (gtk_builder_get_object (xml, \"combo_palette_scheme\"));\n    const gchar* name = gtk_buildable_get_name(GTK_BUILDABLE(w));\n    guint i;\n    tilda_term *tt;\n    GtkWidget *color_button;\n    GdkRGBA fg, bg;\n\n    /* The user just changed the palette manually, so we set the palette scheme to \"Custom\".\n     * \"Custom\" is the 0th element in the palette_schemes.\n     */\n    gtk_combo_box_set_active (GTK_COMBO_BOX(combo_palette_scheme), 0);\n    config_setint (\"palette_scheme\", 0);\n\n    /* We need the index part of the name string, which looks like this:\n     * \"colorbutton_palette_12\", so we set the button_index_str to the\n     * position of the first digit and then convert it into an integer.\n     */\n    const char* button_index_str = &name[sizeof(\"colorbutton_palette_\")-1];\n    i = atoi(button_index_str);\n\n    /* Now get the color that was set, save it. */\n    GdkRGBA *current_palette = tilda_palettes_get_current_palette ();\n\n    gtk_color_chooser_get_rgba (GTK_COLOR_CHOOSER(w), &current_palette[i]);\n\n    /* Why saving the whole palette, not the single color that was set,\n     * is if the config file doesn't exist, and we save the single color,\n     * then exit, the color always becomes the first color in the config file,\n     * no matter which one it actually is, and leaves other colors unset.\n     * Obviously this is not what we want.\n     * However, maybe there is a better solution for this issue.\n     */\n    for (i=0; i<TILDA_COLOR_PALETTE_SIZE; i++)\n    {\n        config_setnint (\"palette\", GUINT16_FROM_FLOAT(current_palette[i].red),   i*3);\n        config_setnint (\"palette\", GUINT16_FROM_FLOAT(current_palette[i].green), i*3+1);\n        config_setnint (\"palette\", GUINT16_FROM_FLOAT(current_palette[i].blue),  i*3+2);\n    }\n\n    /* Set terminal palette. */\n    color_button =\n        GTK_WIDGET (gtk_builder_get_object (xml, \"colorbutton_text\"));\n    gtk_color_chooser_get_rgba (GTK_COLOR_CHOOSER(color_button), &fg);\n    color_button =\n        GTK_WIDGET (gtk_builder_get_object (xml, \"colorbutton_back\"));\n    gtk_color_chooser_get_rgba (GTK_COLOR_CHOOSER(color_button), &bg);\n\n    for (i=0; i<g_list_length (tw->terms); i++)\n    {\n        tt = g_list_nth_data (tw->terms, i);\n        vte_terminal_set_colors (VTE_TERMINAL (tt->vte_term),\n                                 &fg,\n                                 &bg,\n                                 current_palette,\n                                 TILDA_COLOR_PALETTE_SIZE);\n    }\n}", "path": "tilda/src/wizard.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "lanoxx/tilda", "stars": 1230, "license": "gpl-2.0", "language": "c", "size": 4155}
{"docstring": "/* Connect all signals in the wizard. This should be done after setting all\n * values, that way all of the signal handlers don't get called */\n", "func_signal": "static void connect_wizard_signals (TildaWizard *wizard)", "code": "{\n    gint i;\n    tilda_window *tw = wizard->tw;\n\n    /* General Tab */\n    CONNECT_SIGNAL (\"check_display_on_all_workspaces\",\"toggled\",check_display_on_all_workspaces_toggled_cb, tw);\n    CONNECT_SIGNAL (\"check_set_as_desktop\",\"toggled\",check_set_as_desktop_toggled_cb, tw);\n    CONNECT_SIGNAL (\"check_do_not_show_in_taskbar\",\"toggled\",check_do_not_show_in_taskbar_toggled_cb, tw);\n    CONNECT_SIGNAL (\"check_show_notebook_border\",\"toggled\",check_show_notebook_border_toggled_cb, tw);\n    CONNECT_SIGNAL (\"check_always_on_top\",\"toggled\",check_always_on_top_toggled_cb, tw);\n    CONNECT_SIGNAL (\"check_start_tilda_hidden\",\"toggled\",check_start_tilda_hidden_toggled_cb, tw);\n    CONNECT_SIGNAL (\"combo_non_focus_pull_up_behaviour\",\"changed\",combo_non_focus_pull_up_behaviour_cb, tw);\n\n    CONNECT_SIGNAL (\"check_terminal_bell\",\"toggled\",check_terminal_bell_toggled_cb, tw);\n    CONNECT_SIGNAL (\"check_cursor_blinks\",\"toggled\",check_cursor_blinks_toggled_cb, tw);\n    CONNECT_SIGNAL (\"vte_cursor_shape\",\"changed\", combo_cursor_shape_changed_cb, tw);\n\n    CONNECT_SIGNAL (\"check_start_fullscreen\", \"toggled\", check_start_fullscreen_cb, tw);\n\n    CONNECT_SIGNAL (\"button_font\",\"font-set\",button_font_font_set_cb, tw);\n\n    CONNECT_SIGNAL (\"spin_auto_hide_time\",\"value-changed\",spin_auto_hide_time_value_changed_cb, tw);\n    CONNECT_SIGNAL (\"check_auto_hide_on_focus_lost\",\"toggled\",check_auto_hide_on_focus_lost_toggled_cb, tw);\n    CONNECT_SIGNAL (\"check_auto_hide_on_mouse_leave\",\"toggled\",check_auto_hide_on_mouse_leave_toggled_cb, tw);\n\n    CONNECT_SIGNAL (\"combo_on_last_terminal_exit\",\"changed\",combo_on_last_terminal_exit_changed_cb, tw);\n    CONNECT_SIGNAL (\"check_prompt_on_exit\",\"toggled\",check_prompt_on_exit_toggled_cb, tw);\n\n    /* Title and Command Tab */\n    CONNECT_SIGNAL (\"entry_title\",\"changed\",entry_title_changed_cb, tw);\n    CONNECT_SIGNAL (\"combo_dynamically_set_title\",\"changed\",combo_dynamically_set_title_changed_cb, tw);\n    CONNECT_SIGNAL (\"combo_title_behaviour\",\"changed\",combo_title_behaviour_changed_cb, tw);\n    CONNECT_SIGNAL (\"spin_title_max_length\",\"value-changed\", spin_max_title_length_changed_cb, tw);\n\n    CONNECT_SIGNAL (\"check_run_custom_command\",\"toggled\",check_run_custom_command_toggled_cb, tw);\n    CONNECT_SIGNAL (\"entry_custom_command\",\"focus-out-event\", validate_executable_command_cb, tw);\n    CONNECT_SIGNAL (\"combo_command_exit\",\"changed\",combo_command_exit_changed_cb, tw);\n    CONNECT_SIGNAL (\"check_command_login_shell\", \"toggled\", check_command_login_shell_cb, tw);\n\n    CONNECT_SIGNAL (\"check_control_activates_match\", \"toggled\", check_control_activates_match_cb, tw);\n\n    CONNECT_SIGNAL (\"check_match_web_uris\", \"toggled\", check_match_web_uris_cb, tw);\n    CONNECT_SIGNAL (\"check_custom_web_browser\", \"toggled\", check_custom_web_browser_cb, tw);\n\n    CONNECT_SIGNAL (\"check_match_file_uris\", \"toggled\", check_match_file_uris_cb, tw);\n    CONNECT_SIGNAL (\"check_match_email_addresses\", \"toggled\", check_match_email_addresses_cb, tw);\n    CONNECT_SIGNAL (\"check_match_numbers\", \"toggled\", check_match_numbers_cb, tw);\n\n    CONNECT_SIGNAL (\"entry_web_browser\",\"changed\",entry_web_browser_changed, tw);\n    CONNECT_SIGNAL (\"entry_web_browser\",\"focus-out-event\", validate_executable_command_cb, tw);\n\n    CONNECT_SIGNAL (\"check_confirm_close_tab\", \"toggled\", check_confirm_close_tab_cb, tw);\n\n    /* Appearance Tab */\n    CONNECT_SIGNAL (\"combo_choose_monitor\", \"changed\", combo_monitor_selection_changed_cb, tw);\n    CONNECT_SIGNAL (\"spin_height_percentage\",\"value-changed\",spin_height_percentage_value_changed_cb, tw);\n    CONNECT_SIGNAL (\"spin_height_pixels\",\"value-changed\",spin_height_pixels_value_changed_cb, tw);\n    CONNECT_SIGNAL (\"spin_width_percentage\",\"value-changed\",spin_width_percentage_value_changed_cb, tw);\n    CONNECT_SIGNAL (\"spin_width_pixels\",\"value-changed\",spin_width_pixels_value_changed_cb, tw);\n\n    CONNECT_SIGNAL (\"check_centered_horizontally\",\"toggled\",check_centered_horizontally_toggled_cb, tw);\n    CONNECT_SIGNAL (\"check_centered_vertically\",\"toggled\",check_centered_vertically_toggled_cb, tw);\n    CONNECT_SIGNAL (\"spin_x_position\",\"value-changed\",spin_x_position_value_changed_cb, tw);\n    CONNECT_SIGNAL (\"spin_y_position\",\"value-changed\",spin_y_position_value_changed_cb, tw);\n\n    CONNECT_SIGNAL (\"combo_tab_pos\",\"changed\",combo_tab_pos_changed_cb, tw);\n    CONNECT_SIGNAL (\"check_expand_tabs\",\"toggled\",check_expand_tabs_toggled_cb, tw);\n    CONNECT_SIGNAL (\"check_show_single_tab\",\"toggled\",check_show_single_tab_toggled_cb, tw);\n    CONNECT_SIGNAL (\"check_show_title_tooltip\",\"toggled\",check_show_title_tooltip_toggled_cb, tw);\n\n    CONNECT_SIGNAL (\"check_enable_transparency\",\"toggled\",check_enable_transparency_toggled_cb, tw);\n    CONNECT_SIGNAL (\"check_animated_pulldown\",\"toggled\",check_animated_pulldown_toggled_cb, tw);\n    CONNECT_SIGNAL (\"spin_level_of_transparency\",\"value-changed\",spin_level_of_transparency_value_changed_cb, tw);\n    CONNECT_SIGNAL (\"spin_animation_delay\",\"value-changed\",spin_animation_delay_value_changed_cb, tw);\n    CONNECT_SIGNAL (\"combo_animation_orientation\",\"changed\",combo_animation_orientation_changed_cb, tw);\n\n    /* Colors Tab */\n    CONNECT_SIGNAL (\"combo_colorschemes\",\"changed\",combo_colorschemes_changed_cb, tw);\n    CONNECT_SIGNAL (\"colorbutton_text\",\"color-set\",colorbutton_text_color_set_cb, tw);\n    CONNECT_SIGNAL (\"colorbutton_back\",\"color-set\",colorbutton_back_color_set_cb, tw);\n    CONNECT_SIGNAL (\"colorbutton_cursor\",\"color-set\",colorbutton_cursor_color_set_cb, tw);\n    CONNECT_SIGNAL (\"combo_palette_scheme\",\"changed\",combo_palette_scheme_changed_cb, tw);\n    for(i = 0; i < TILDA_COLOR_PALETTE_SIZE; i++)\n    {\n        char *s = g_strdup_printf (\"colorbutton_palette_%d\", i);\n        CONNECT_SIGNAL (s,\"color-set\",colorbutton_palette_n_set_cb, tw);\n        g_free (s);\n    }\n\n    /* Scrolling Tab */\n    CONNECT_SIGNAL (\"combo_scrollbar_position\",\"changed\",combo_scrollbar_position_changed_cb, tw);\n    CONNECT_SIGNAL (\"spin_scrollback_amount\",\"value-changed\",spin_scrollback_amount_value_changed_cb, tw);\n    CONNECT_SIGNAL (\"check_infinite_scrollback\", \"toggled\", check_infinite_scrollback_toggled_cb, tw);\n    CONNECT_SIGNAL (\"check_scroll_on_output\",\"toggled\",check_scroll_on_output_toggled_cb, tw);\n    CONNECT_SIGNAL (\"check_scroll_on_keystroke\",\"toggled\",check_scroll_on_keystroke_toggled_cb, tw);\n\n    /* Compatibility Tab */\n    CONNECT_SIGNAL (\"combo_backspace_binding\",\"changed\",combo_backspace_binding_changed_cb, tw);\n    CONNECT_SIGNAL (\"combo_delete_binding\",\"changed\",combo_delete_binding_changed_cb, tw);\n    CONNECT_SIGNAL (\"button_reset_compatibility_options\",\"clicked\",button_reset_compatibility_options_clicked_cb, tw);\n\n    /* Close Button */\n    CONNECT_SIGNAL (\"button_wizard_close\",\"clicked\", wizard_button_close_clicked_cb, wizard);\n    CONNECT_SIGNAL (\"wizard_window\",\"delete_event\", wizard_window_delete_event_cb, wizard);\n\n    CONNECT_SIGNAL (\"entry_word_chars\", \"changed\", entry_word_chars_changed, tw);\n}", "path": "tilda/src/wizard.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "lanoxx/tilda", "stars": 1230, "license": "gpl-2.0", "language": "c", "size": 4155}
{"docstring": "/* This will write out the current state of the config file to the disk.\n * It's use is generally discouraged, since config_free() will also write\n * out the configuration to disk. */\n", "func_signal": "gint config_write (const gchar *config_file)", "code": "{\n    DEBUG_FUNCTION (\"config_write\");\n    DEBUG_ASSERT (config_file != NULL);\n\n    gint ret = 0;\n    FILE *fp;\n\n    char *temp_config_file = g_strdup_printf (\"%s.tmp\", config_file);\n    fp = fopen(temp_config_file, \"w\");\n\n    if (fp != NULL)\n    {\n        config_mutex_lock ();\n        cfg_print (tc, fp);\n        config_mutex_unlock ();\n\n        if (fsync (fileno(fp)))\n        {\n            // Error occurred during sync\n            TILDA_PERROR ();\n            DEBUG_ERROR (\"Unable to sync file\");\n\n            g_printerr (_(\"Unable to sync the config file to disk\\n\"));\n            ret = 2;\n        }\n\n        if (fclose (fp))\n        {\n            // An error occurred\n            TILDA_PERROR ();\n            DEBUG_ERROR (\"Unable to close config file\");\n\n            g_printerr (_(\"Unable to close the config file\\n\"));\n            ret = 3;\n        }\n        if (rename(temp_config_file, config_file)) {\n            TILDA_PERROR ();\n            DEBUG_ERROR (\"Unable to rename temporary config file to final config file.\");\n        }\n    }\n    else\n    {\n        TILDA_PERROR ();\n        DEBUG_ERROR (\"Unable to write config file\");\n\n        g_printerr (_(\"Unable to write the config file to %s\\n\"), config_file);\n        ret = 4;\n    }\n\n    return ret;\n}", "path": "tilda/src/configsys.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "lanoxx/tilda", "stars": 1230, "license": "gpl-2.0", "language": "c", "size": 4155}
{"docstring": "/* Gets called just after the wizard is closed. This should clean up after\n * the wizard, and do anything that couldn't be done immediately during the\n * wizard's lifetime. */\n", "func_signal": "static void wizard_close_dialog (TildaWizard *wizard)", "code": "{\n    DEBUG_FUNCTION (\"wizard_close_dialog\");\n\n    tilda_window *tw = wizard->tw;\n\n    const GtkWidget *entry_custom_command =\n        GTK_WIDGET (gtk_builder_get_object(xml, \"entry_custom_command\"));\n    const GtkWidget *wizard_window = tw->wizard_window;\n    const gchar *command = gtk_entry_get_text (GTK_ENTRY(entry_custom_command));\n\n    if (!tilda_keybinding_save (wizard->keybinding, tw)) {\n        return;\n    }\n\n    tilda_keybinding_apply (wizard->keybinding);\n\n    tilda_keybinding_free (wizard->keybinding);\n\n    wizard->keybinding = NULL;\n\n    /* TODO: validate this?? */\n    config_setstr (\"command\", command);\n\n    /* Free the GtkBuilder data structure */\n    g_object_unref (G_OBJECT(xml));\n    xml = NULL;\n\n    /* Remove the wizard */\n    gtk_widget_destroy (GTK_WIDGET(wizard_window));\n    tw->wizard_window = NULL;\n\n    /* Write the config, because it probably changed. This saves us in case\n     * of an XKill (or crash) later ... */\n    config_write (tw->config_file);\n\n    /* Enables auto hide */\n    tw->disable_auto_hide = FALSE;\n\n    wizard->tw = NULL;\n    wizard->builder = NULL;\n    g_free (wizard);\n}", "path": "tilda/src/wizard.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "lanoxx/tilda", "stars": 1230, "license": "gpl-2.0", "language": "c", "size": 4155}
{"docstring": "/**\n * Get the number of screens and load the monitor geometry for each screen,\n * then set the position of the window according to the x and y offset\n * of that monitor. This function does not actually move or resize the window\n * but only changes the value of the spin buttons. The moving and resizing\n * is then done by the callback functions of the respective widgets.\n */\n", "func_signal": "static int\ncombo_monitor_selection_changed_cb (GtkWidget* widget, tilda_window *tw)", "code": "{\n    DEBUG_FUNCTION (\"combo_monitor_selection_changed_cb\");\n\n    GdkDisplay *display          = gdk_display_get_default ();\n    GdkMonitor *original_monitor = tilda_window_find_monitor_number (tw);\n    GdkMonitor *new_monitor;\n\n    GdkRectangle original_monitor_rectangle;\n    GdkRectangle selected_monitor_rectangle;\n\n    gdk_monitor_get_workarea (original_monitor, &original_monitor_rectangle);\n\n    GtkTreeIter active_iter;\n\n    GtkComboBox* combo_choose_monitor = GTK_COMBO_BOX(widget);\n\n    if(!gtk_combo_box_get_active_iter(combo_choose_monitor, &active_iter))\n    {\n        return FALSE;\n    }\n\n    gchar* new_monitor_name = NULL;\n    gint new_monitor_number;\n\n    gtk_tree_model_get(gtk_combo_box_get_model(combo_choose_monitor), &active_iter,\n                       0, &new_monitor_name,\n                       1, &new_monitor_number,\n                       -1);\n\n    new_monitor = gdk_display_get_monitor (display, new_monitor_number);\n    gdk_monitor_get_workarea (new_monitor, &selected_monitor_rectangle);\n\n    //Save the new monitor value\n    config_setstr(\"show_on_monitor\", new_monitor_name);\n\n    /* The dimensions of the monitor might have changed,\n     * so we need to update the spinner widgets for height,\n     * width, and their percentages as well as their ranges.\n     * Keep in mind that we use the max range of the pixel spinners\n     * to store the size of the screen.\n     */\n    GdkRectangle rectangle;\n    config_get_configured_window_size (&rectangle);\n\n    if(selected_monitor_rectangle.width != original_monitor_rectangle.width)\n    {\n        gint new_max_width = selected_monitor_rectangle.width;\n\n        SPIN_BUTTON_SET_RANGE (\"spin_width_pixels\", 0, new_max_width);\n        SPIN_BUTTON_SET_VALUE (\"spin_width_pixels\", rectangle.width);\n\n        gtk_window_resize (GTK_WINDOW(tw->window),\n                           rectangle.width,\n                           rectangle.height);\n    }\n\n    if(selected_monitor_rectangle.height != original_monitor_rectangle.height)\n    {\n        int new_max_height = selected_monitor_rectangle.height;\n\n        SPIN_BUTTON_SET_RANGE (\"spin_height_pixels\", 0, new_max_height);\n        SPIN_BUTTON_SET_VALUE (\"spin_height_pixels\", rectangle.height);\n\n        gtk_window_resize (GTK_WINDOW(tw->window),\n                           rectangle.width,\n                           rectangle.height);\n    }\n\n    gint screen_width, screen_height;\n    screen_size_get_dimensions (&screen_width, &screen_height);\n    SPIN_BUTTON_SET_RANGE (\"spin_x_position\", 0, screen_width);\n    SPIN_BUTTON_SET_VALUE(\"spin_x_position\", selected_monitor_rectangle.x);\n    SPIN_BUTTON_SET_RANGE (\"spin_y_position\", 0, screen_height);\n    SPIN_BUTTON_SET_VALUE(\"spin_y_position\", selected_monitor_rectangle.y);\n\n    tilda_window_update_window_position (tw);\n\n    return GDK_EVENT_STOP;\n}", "path": "tilda/src/wizard.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "lanoxx/tilda", "stars": 1230, "license": "gpl-2.0", "language": "c", "size": 4155}
{"docstring": "/**\n * Check that the value entered into the GtkEntry is a valid command\n * which is accessible from the users PATH environment variable.\n * If the command is not found on the users PATH then a small error\n * icon is displayed on the end of the entry.\n * This function can only be registered to Widgets of (sub)type GtkEntry\n */\n", "func_signal": "static void validate_executable_command_cb (GtkWidget *w,\n                                            G_GNUC_UNUSED GdkEvent *event,\n                                            G_GNUC_UNUSED tilda_window *tw)", "code": "{\n    g_return_if_fail(w != NULL && GTK_IS_ENTRY(w));\n    const char* command = gtk_entry_get_text (GTK_ENTRY(w));\n    /* Check that the command exists */\n    int argc = 0;\n    gchar** argv = NULL;\n    GError *error = NULL;\n    gboolean success = g_shell_parse_argv(command, &argc, &argv, &error);\n    char *command_filename = NULL;\n    if(success && argc > 0) {\n        command_filename = g_find_program_in_path(argv[0]);\n    }\n    g_strfreev(argv);\n\n    if (command_filename == NULL && gtk_widget_is_sensitive(w)) {\n        //wrong command\n        gtk_entry_set_icon_from_icon_name(GTK_ENTRY(w),\n                GTK_ENTRY_ICON_SECONDARY, \"dialog-error\");\n        gtk_entry_set_icon_tooltip_text(GTK_ENTRY(w),\n                GTK_ENTRY_ICON_SECONDARY,\n                \"The command you have entered is not a valid command.\\n\"\n                        \"Make sure that the specified executable is in your PATH environment variable.\"\n        );\n    } else {\n        gtk_entry_set_icon_from_icon_name(GTK_ENTRY(w),\n                GTK_ENTRY_ICON_SECONDARY,\n                NULL);\n        free(command_filename);\n    }\n}", "path": "tilda/src/wizard.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "lanoxx/tilda", "stars": 1230, "license": "gpl-2.0", "language": "c", "size": 4155}
{"docstring": "/*\n * This is called when a shortcut in the keybinding tree view widget\n * is clicked.\n */\n", "func_signal": "static gboolean\nkeybinding_button_press_event_cb (GtkWidget *tree_view,\n                                  GdkEventButton *event,\n                                  TildaKeybindingTreeView *keybindings)", "code": "{\n    GtkBuilder *builder = keybindings->builder;\n\n    const GtkWidget *wizard_window =\n            GTK_WIDGET (gtk_builder_get_object (builder, \"wizard_window\"));\n\n    if (event->button == 1 && event->type == GDK_2BUTTON_PRESS) {\n\n        GtkTreeIter iter;\n        GtkTreeSelection *selection =\n                gtk_tree_view_get_selection (GTK_TREE_VIEW (tree_view));\n\n        if (!gtk_tree_selection_get_selected (selection, NULL, &iter)) {\n            return GDK_EVENT_PROPAGATE;\n        }\n\n        /* Bring up the dialog that will accept the new keybinding */\n        GtkWidget *dialog\n                = gtk_message_dialog_new (GTK_WINDOW (wizard_window),\n                                          GTK_DIALOG_DESTROY_WITH_PARENT,\n                                          GTK_MESSAGE_QUESTION,\n                                          GTK_BUTTONS_CANCEL,\n                                          _ (\"Enter keyboard shortcut\"));\n\n        /* Connect the key grabber to the dialog */\n        g_signal_connect (G_OBJECT (dialog),\n                          \"key_press_event\",\n                          G_CALLBACK (keybinding_dialog_key_press_event_cb),\n                          keybindings);\n\n        gtk_window_set_keep_above (GTK_WINDOW (dialog), TRUE);\n        gtk_dialog_run (GTK_DIALOG (dialog));\n\n        gtk_widget_destroy (dialog);\n\n        return GDK_EVENT_STOP;\n    }\n\n    return GDK_EVENT_PROPAGATE;\n}", "path": "tilda/src/tilda-keybinding.c", "commit_date": "2020-12-21 00:00:00", "repo_name": "lanoxx/tilda", "stars": 1230, "license": "gpl-2.0", "language": "c", "size": 4155}
{"docstring": "/* Initialize the palette scheme menu.\n * Add the predefined schemes to the combo box.*/\n", "func_signal": "static void init_palette_scheme_menu (void)", "code": "{\n    gint i;\n    TildaColorScheme *paletteSchemes;\n    GtkWidget *combo_palette;\n\n    combo_palette = GTK_WIDGET (gtk_builder_get_object (xml,\n                                                        \"combo_palette_scheme\"));\n\n    i = tilda_palettes_get_n_palette_schemes ();\n    paletteSchemes = tilda_palettes_get_palette_schemes ();\n\n    while (i > 0) {\n        --i;\n        const char *palette_name = paletteSchemes[i].name;\n        gtk_combo_box_text_prepend_text (GTK_COMBO_BOX_TEXT (combo_palette),\n                                         _(palette_name));\n    }\n}", "path": "tilda/src/wizard.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "lanoxx/tilda", "stars": 1230, "license": "gpl-2.0", "language": "c", "size": 4155}
{"docstring": "/**\n * get_instance_number ()\n *\n * Gets the next available tilda instance number. This will always pick the\n * lowest non-running tilda available.\n *\n * Success: return next available instance number (>=0)\n * Failure: return 0\n */\n", "func_signal": "static gint get_instance_number ()", "code": "{\n    DEBUG_FUNCTION (\"get_instance_number\");\n\n    gchar *name;\n\n    GSequence *seq;\n    GSequenceIter *iter;\n    gint lowest_lock_instance = 0;\n    gint current_lock_instance;\n\n    GDir *dir;\n    struct lock_info *lock;\n    gchar *lock_dir = g_build_filename (g_get_user_cache_dir (), \"tilda\", \"locks\", NULL);\n\n    /* Open the lock directory */\n    dir = g_dir_open (lock_dir, 0, NULL);\n\n    /* Check for failure to open */\n    if (dir == NULL)\n    {\n        g_printerr (_(\"Unable to open lock directory: %s\\n\"), lock_dir);\n        g_free (lock_dir);\n        return 0;\n    }\n\n    /* Look through every file in the lock directory, and see if it is a lock file.\n     * If it is a lock file, insert it in a sorted sequence. */\n    seq = g_sequence_new(NULL);\n    while ((name = (gchar*)g_dir_read_name (dir)) != NULL)\n    {\n        lock = islockfile (name);\n\n        if (lock != NULL)\n        {\n            g_sequence_insert_sorted(seq, GINT_TO_POINTER(lock->instance), _cmp_locks, NULL);\n            g_free (lock);\n        }\n    }\n\n    g_dir_close (dir);\n    g_free (lock_dir);\n\n    /* We iterate the sorted sequence of lock instances to find the first (lowest) number *not* taken. */\n    for (iter = g_sequence_get_begin_iter(seq); !g_sequence_iter_is_end(iter); iter = g_sequence_iter_next(iter)) {\n        current_lock_instance = GPOINTER_TO_INT(g_sequence_get(iter));\n        if (lowest_lock_instance < current_lock_instance)\n            break;\n        else\n            lowest_lock_instance = current_lock_instance + 1;\n    }\n\n    g_sequence_free(seq);\n\n    return lowest_lock_instance;\n}", "path": "tilda/src/tilda-lock-files.c", "commit_date": "2020-12-29 00:00:00", "repo_name": "lanoxx/tilda", "stars": 1230, "license": "gpl-2.0", "language": "c", "size": 4155}
{"docstring": "/**\n * Remove stale lock files from the ~/.tilda/locks/ directory.\n *\n * Success: returns 0\n * Failure: returns non-zero\n */\n", "func_signal": "static gint remove_stale_lock_files (void)", "code": "{\n    DEBUG_FUNCTION (\"remove_stale_lock_files\");\n\n    GSList *pids = getPids();\n    if(pids == NULL) {\n        return -1;\n    }\n\n    struct lock_info *lock;\n    gchar *lock_dir = g_build_filename (g_get_user_cache_dir (), \"tilda\", \"locks\", NULL);\n    gchar *remove_file;\n    gchar *filename;\n    GDir *dir;\n\n    /* if the lock dir does not exist then there are no stale lock files to remove. */\n    if (!g_file_test (lock_dir, G_FILE_TEST_EXISTS)) {\n        g_free (lock_dir);\n        return 0;\n    }\n\n    /* Open the lock directory for reading */\n    dir = g_dir_open (lock_dir, 0, NULL);\n\n    if (dir == NULL)\n    {\n        g_printerr (_(\"Unable to open lock directory: %s\\n\"), lock_dir);\n        g_free (lock_dir);\n        return -2;\n    }\n\n    /* For each possible lock file, check if it is a lock, and see if\n     * it matches one of the running tildas */\n    while ((filename = (gchar*) g_dir_read_name (dir)) != NULL)\n    {\n        lock = islockfile (filename);\n\n        if (lock && (g_slist_find (pids, GINT_TO_POINTER (lock->pid)) == NULL))\n        {\n            /* We have found a stale element */\n            remove_file = g_build_filename (lock_dir, filename, NULL);\n            remove (remove_file);\n            g_free (remove_file);\n        }\n\n        if (lock)\n            g_free (lock);\n    }\n\n    g_dir_close (dir);\n    g_free (lock_dir);\n    g_slist_free(pids);\n\n    return 0;\n}", "path": "tilda/src/tilda-lock-files.c", "commit_date": "2020-12-29 00:00:00", "repo_name": "lanoxx/tilda", "stars": 1230, "license": "gpl-2.0", "language": "c", "size": 4155}
{"docstring": "/**\n * Start up the configuration system, using the configuration file given\n * to get the current values. If the configuration file given does not exist,\n * go ahead and write out the default config to the file.\n */\n", "func_signal": "gint config_init (const gchar *config_file)", "code": "{\n    DEBUG_FUNCTION (\"config_init\");\n\n    gint ret = 0;\n\n    // Can we use a more descriptive name than tc?\n    tc = cfg_init (config_opts, 0);\n\n    if (g_file_test (config_file,\n        G_FILE_TEST_IS_REGULAR))\n    {\n        /* Read in the existing configuration options */\n        ret = cfg_parse (tc, config_file);\n\n        if (ret == CFG_PARSE_ERROR) {\n            DEBUG_ERROR (\"Problem parsing config\");\n            return ret;\n        } else if (ret != CFG_SUCCESS) {\n            DEBUG_ERROR (\"Problem parsing config.\");\n            return ret;\n        }\n    }\n\n    /* Deprecate old config settings.\n     * This is a lame work around until we get a permanent solution to\n     * libconfuse lacking for this functionality\n     */\n    const gchar *deprecated_tilda_config_options[] = {\"show_on_monitor_number\",\n                                                      \"bold\",\n                                                      \"title_max_length_flag\",\n                                                      \"double_buffer\",\n                                                      \"antialias\",\n                                                      \"image\",\n                                                      \"transparency\",\n                                                      \"scroll_background\",\n                                                      \"use_image\",\n                                                      \"min_width\",\n                                                      \"min_height\",\n                                                      \"max_width\",\n                                                      \"max_height\"\n    };\n\n    invoke_deprecation_function (deprecated_tilda_config_options,\n                                 G_N_ELEMENTS(deprecated_tilda_config_options));\n\n    remove_deprecated_config_options(deprecated_tilda_config_options,\n                                     G_N_ELEMENTS(deprecated_tilda_config_options));\n\n    #ifndef NO_THREADSAFE\n        g_mutex_init(&mutex);\n    #endif\n\n    return ret;\n}", "path": "tilda/src/configsys.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "lanoxx/tilda", "stars": 1230, "license": "gpl-2.0", "language": "c", "size": 4155}
{"docstring": "/**\n * This function is called if a different color scheme is selected from the combo box.\n */\n", "func_signal": "static void combo_palette_scheme_changed_cb (GtkWidget *w, tilda_window *tw)", "code": "{\n    DEBUG_FUNCTION(\"combo_palette_scheme_changed_cb\");\n    gint i;\n    guint j;\n    tilda_term *tt;\n    GdkRGBA fg, bg;\n    GtkWidget *color_button;\n\n    i = gtk_combo_box_get_active (GTK_COMBO_BOX(w));\n    /* i = 0 means custom, in that case we do nothing */\n    TildaColorScheme *tildaPaletteSchemes = tilda_palettes_get_palette_schemes ();\n\n    if (i > 0 && i < tilda_palettes_get_n_palette_schemes ()) {\n\n        const GdkRGBA *current_palette = tildaPaletteSchemes[i].palette;\n\n        color_button =\n            GTK_WIDGET (gtk_builder_get_object (xml, \"colorbutton_text\"));\n        gtk_color_chooser_get_rgba (GTK_COLOR_CHOOSER(color_button), &fg);\n        color_button =\n            GTK_WIDGET (gtk_builder_get_object (xml, \"colorbutton_back\"));\n        gtk_color_chooser_get_rgba (GTK_COLOR_CHOOSER(color_button), &bg);\n\n        bg.alpha = (config_getbool(\"enable_transparency\")\n                    ? GUINT16_TO_FLOAT(config_getint (\"back_alpha\")) : 1.0);\n\n        tilda_palettes_set_current_palette (current_palette);\n\n        /* Set terminal palette. */\n        for (j=0; j<g_list_length (tw->terms); j++) {\n            tt = g_list_nth_data (tw->terms, j);\n            vte_terminal_set_colors (VTE_TERMINAL(tt->vte_term),\n                                     &fg,\n                                     &bg,\n                                     current_palette,\n                                     TILDA_COLOR_PALETTE_SIZE);\n        }\n\n        for (j=0; j<TILDA_COLOR_PALETTE_SIZE; j++) {\n            update_palette_color_button(j);\n\n            /* Set palette in the config. */\n            config_setnint (\"palette\", GUINT16_FROM_FLOAT(current_palette[j].red),   j*3);\n            config_setnint (\"palette\", GUINT16_FROM_FLOAT(current_palette[j].green), j*3+1);\n            config_setnint (\"palette\", GUINT16_FROM_FLOAT(current_palette[j].blue),  j*3+2);\n        }\n    }\n\n    /* Set palette scheme in the config*/\n    config_setint (\"palette_scheme\", i);\n}", "path": "tilda/src/wizard.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "lanoxx/tilda", "stars": 1230, "license": "gpl-2.0", "language": "c", "size": 4155}
{"docstring": "/******************************************************************************/\n/*      Utility functions to get the current monitors height and width        */\n/******************************************************************************/\n", "func_signal": "static int get_max_height()", "code": "{\n    gdouble height_min;\n    gdouble height_max;\n    SPIN_BUTTON_GET_RANGE(\"spin_height_pixels\", &height_min, &height_max);\n    return (int) height_max;\n}", "path": "tilda/src/wizard.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "lanoxx/tilda", "stars": 1230, "license": "gpl-2.0", "language": "c", "size": 4155}
{"docstring": "/**\n * Check if a filename corresponds to a valid lockfile. Note that this\n * routine does NOT check whether it is a stale lock, however. This\n * will return the lock file's corresponding pid, if it is a valid lock.\n *\n * @param filename the filename to check\n * @return a new struct lock_info\n *\n * Success: struct lock_info will be filled in and non-NULL\n * Failure: return NULL\n */\n", "func_signal": "static struct lock_info *islockfile (const gchar *filename)", "code": "{\n    DEBUG_FUNCTION (\"islockfile\");\n    DEBUG_ASSERT (filename != NULL);\n\n    struct lock_info *lock;\n\n    lock = g_malloc (sizeof (struct lock_info));\n\n    if (lock == NULL)\n        return NULL;\n\n    gboolean matches = g_str_has_prefix (filename, \"lock_\");\n    gboolean islock = FALSE;\n    gchar *pid_s, *instance_s;\n\n    if (matches) /* we are prefixed with \"lock_\" and are probably a lock */\n    {\n        pid_s = strstr (filename, \"_\");\n\n        if (pid_s) /* we have a valid pid */\n        {\n            /* Advance the pointer past the underscore */\n            pid_s++;\n\n            lock->pid = atoi (pid_s);\n            instance_s = strstr (pid_s, \"_\");\n\n            if (lock->pid > 0 && instance_s)\n            {\n                /* Advance the pointer past the underscore */\n                instance_s++;\n\n                /* Extract the instance number and store it */\n                lock->instance = atoi (instance_s);\n\n                /* we parsed everything, so yes, we were a lock */\n                islock = TRUE;\n            }\n        }\n    }\n\n    if (!islock)\n    {\n        g_free (lock);\n        lock = NULL;\n    }\n\n    return lock;\n}", "path": "tilda/src/tilda-lock-files.c", "commit_date": "2020-12-29 00:00:00", "repo_name": "lanoxx/tilda", "stars": 1230, "license": "gpl-2.0", "language": "c", "size": 4155}
{"docstring": "/*\n * Compares two config versions together.\n *\n * Returns -1 if config1 is older than config2 (UPDATE REQUIRED)\n * Returns  0 if config1 is equal to   config2 (NORMAL USAGE)\n * Returns  1 if config1 is newer than config2 (DISABLE WRITE)\n */\n", "func_signal": "static gboolean compare_config_versions (const gchar *config1, const gchar *config2)", "code": "{\n    DEBUG_FUNCTION (\"compare_config_versions\");\n    DEBUG_ASSERT (config1 != NULL);\n    DEBUG_ASSERT (config2 != NULL);\n\n    /*\n     * 1) Split apart both strings using the .'s\n     * 2) Compare the major-major version\n     * 3) Compare the major version\n     * 4) Compare the minor version\n     */\n\n    gchar **config1_tokens;\n    gchar **config2_tokens;\n    gint  config1_version[3];\n    gint  config2_version[3];\n    gint  i;\n\n    config1_tokens = g_strsplit (config1, \".\", 3);\n    config2_tokens = g_strsplit (config2, \".\", 3);\n\n    for (i=0; i<3; i++)\n    {\n        config1_version[i] = atoi (config1_tokens[i]);\n        config2_version[i] = atoi (config2_tokens[i]);\n    }\n\n    g_strfreev (config1_tokens);\n    g_strfreev (config2_tokens);\n\n    /* We're done splitting things, so compare now */\n    for (i=0; i<3; i++)\n    {\n        if (config1_version[i] > config2_version[i])\n            return CONFIG1_NEWER;\n\n        if (config1_version[i] < config2_version[i])\n            return CONFIG1_OLDER;\n    }\n\n    return CONFIGS_SAME;\n}", "path": "tilda/src/configsys.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "lanoxx/tilda", "stars": 1230, "license": "gpl-2.0", "language": "c", "size": 4155}
{"docstring": "/* Show the wizard. This will show the wizard, then exit immediately. */\n", "func_signal": "gint wizard (tilda_window *tw)", "code": "{\n    DEBUG_FUNCTION (\"wizard\");\n    DEBUG_ASSERT (tw != NULL);\n\n    gchar *window_title;\n\n    /* Make sure that there isn't already a wizard showing */\n    if (tw->wizard_window) {\n        gtk_window_present (GTK_WINDOW (tw->wizard_window));\n        return 0;\n    }\n\n    TildaWizard *wizard = g_malloc (sizeof (TildaWizard));\n\n    GError* error = NULL;\n    xml = gtk_builder_new ();\n\n#if ENABLE_NLS\n    gtk_builder_set_translation_domain (xml, PACKAGE);\n#endif\n\n    if(!gtk_builder_add_from_resource (xml, \"/org/tilda/tilda.ui\", &error)) {\n        g_prefix_error(&error, \"Error:\");\n        return EXIT_FAILURE;\n    }\n\n    if (!xml) {\n        g_warning (\"problem while loading the tilda.ui file\");\n        return 2;\n    }\n\n    wizard->builder = xml;\n    wizard->tw = tw;\n\n    tw->wizard_window = GTK_WIDGET (\n        gtk_builder_get_object (xml, \"wizard_window\")\n    );\n\n    /* GtkDialog windows need to have a transient parent or a warning will be logged. */\n    gtk_window_set_transient_for (GTK_WINDOW(tw->wizard_window), GTK_WINDOW(tw->window));\n\n    init_palette_scheme_menu ();\n\n    /* Copy the current program state into the wizard */\n    set_wizard_state_from_config (tw);\n\n    wizard->keybinding = tilda_keybinding_init (wizard->builder);\n\n    /* Connect all signal handlers. We do this after copying the state into\n     * the wizard so that all of the handlers don't get called as we copy in\n     * the values. This function manually connects the required signals for\n     * all the widgets */\n    connect_wizard_signals (wizard);\n\n    /* Unbind the current keybinding. I'm aware that this opens up an opportunity to\n     * let \"someone else\" grab the key, but it also saves us some trouble, and makes\n     * validation easier. */\n    tilda_keygrabber_unbind (config_getstr (\"key\"));\n\n    /* Adding widget title for CSS selection */\n    gtk_widget_set_name (GTK_WIDGET(tw->wizard_window), \"Wizard\");\n\n    /* Set the icon for the wizard window to our tilda icon. */\n    gchar* filename = g_build_filename (DATADIR, \"pixmaps\", \"tilda.png\", NULL);\n    GdkPixbuf *pixbuf = gdk_pixbuf_new_from_file(filename, NULL);\n    g_free(filename);\n    gtk_window_set_icon(GTK_WINDOW(tw->wizard_window), pixbuf);\n\n    window_title = g_strdup_printf (_(\"Tilda %d Config\"), tw->instance);\n    gtk_window_set_title (GTK_WINDOW(tw->wizard_window), window_title);\n    gtk_window_set_type_hint (GTK_WINDOW(tw->wizard_window), GDK_WINDOW_TYPE_HINT_DIALOG);\n\n    gtk_widget_show_all (tw->wizard_window);\n\n    /* This is needed to ensure that the wizard appears above of the terminal window */\n    gtk_window_present(GTK_WINDOW(tw->wizard_window));\n\n    g_free (window_title);\n\n    /* Disable auto hide */\n    tw->disable_auto_hide = TRUE;\n\n    return 0;\n}", "path": "tilda/src/wizard.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "lanoxx/tilda", "stars": 1230, "license": "gpl-2.0", "language": "c", "size": 4155}
{"docstring": "/*\n * This function gets called once per key that is pressed. This means we have to\n * manually ignore all modifier keys, and only register \"real\" keys.\n *\n * We return when the first \"real\" key is pressed.\n *\n * Note that this is called for the key_press_event for the key-grab dialog,\n * not for the keybinding tree view widget.\n */\n", "func_signal": "static gboolean\nkeybinding_dialog_key_press_event_cb (GtkWidget *dialog,\n                                      GdkEventKey *event,\n                                      TildaKeybindingTreeView *keybinding)", "code": "{\n    DEBUG_FUNCTION (\"keybinding_dialog_key_press_event_cb\");\n    DEBUG_ASSERT (keybinding != NULL);\n    DEBUG_ASSERT (event != NULL);\n\n    GtkWidget *tree_view = keybinding->tree_view;\n    GtkListStore *listStore = keybinding->list_store;\n\n    gchar *key;\n\n    if (gtk_accelerator_valid (event->keyval,\n                               (GdkModifierType) event->state))\n    {\n        GtkTreeIter iter;\n        GtkTreeSelection *selection;\n\n        selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (tree_view));\n\n        if (!gtk_tree_selection_get_selected (selection, NULL, &iter)) {\n            return GDK_EVENT_PROPAGATE;\n        }\n\n        /* This lets us ignore all ignorable modifier keys, including\n         * NumLock and many others. :)\n         *\n         * The logic is: keep only the important modifiers that were pressed\n         * for this event. */\n        event->state &= gtk_accelerator_get_default_mod_mask ();\n\n        /* Generate the correct name for this key */\n        key = gtk_accelerator_name (event->keyval,\n                                    (GdkModifierType) event->state);\n\n        gtk_list_store_set (listStore, &iter,\n                            KB_TREE_SHORTCUT, key,\n                            KB_TREE_SHORTCUT_DISPLAY, key,\n                            -1);\n\n        gtk_dialog_response (GTK_DIALOG (dialog), GTK_RESPONSE_ACCEPT);\n\n        g_debug (\"KEY GRABBED: %s\", key);\n\n        /* Free the string */\n        g_free (key);\n    }\n    return GDK_EVENT_PROPAGATE;\n}", "path": "tilda/src/tilda-keybinding.c", "commit_date": "2020-12-21 00:00:00", "repo_name": "lanoxx/tilda", "stars": 1230, "license": "gpl-2.0", "language": "c", "size": 4155}
{"docstring": "/* Read all state from the config system, and put it into\n * its visual representation in the wizard. */\n", "func_signal": "static void set_wizard_state_from_config (tilda_window *tw)", "code": "{\n    GdkRGBA text_color, back_color, cursor_color;\n    guint i;\n    GdkRGBA *current_palette;\n\n    /* General Tab */\n    CHECK_BUTTON (\"check_display_on_all_workspaces\", \"pinned\");\n    initialize_set_as_desktop_checkbox ();\n    CHECK_BUTTON (\"check_always_on_top\", \"above\");\n    CHECK_BUTTON (\"check_do_not_show_in_taskbar\", \"notaskbar\");\n    CHECK_BUTTON (\"check_start_tilda_hidden\", \"hidden\");\n    CHECK_BUTTON (\"check_show_notebook_border\", \"notebook_border\");\n    COMBO_BOX (\"combo_non_focus_pull_up_behaviour\", \"non_focus_pull_up_behaviour\");\n\n    CHECK_BUTTON (\"check_terminal_bell\", \"bell\");\n    CHECK_BUTTON (\"check_cursor_blinks\", \"blinks\");\n    COMBO_BOX (\"vte_cursor_shape\", \"cursor_shape\");\n\n    FONT_BUTTON (\"button_font\", \"font\");\n\n    SPIN_BUTTON_SET_RANGE (\"spin_auto_hide_time\", 0, 99999);\n    SPIN_BUTTON_SET_VALUE (\"spin_auto_hide_time\", config_getint (\"auto_hide_time\"));\n    CHECK_BUTTON (\"check_auto_hide_on_focus_lost\", \"auto_hide_on_focus_lost\");\n    CHECK_BUTTON (\"check_auto_hide_on_mouse_leave\", \"auto_hide_on_mouse_leave\");\n\n    /* Title and Command Tab */\n    TEXT_ENTRY (\"entry_title\", \"title\");\n    COMBO_BOX (\"combo_dynamically_set_title\", \"d_set_title\");\n    // Whether to limit the length of the title\n    COMBO_BOX (\"combo_title_behaviour\", \"title_behaviour\");\n    // The maximum length of the title\n    SPIN_BUTTON_SET_RANGE (\"spin_title_max_length\", 0, 99999);\n    SPIN_BUTTON_SET_VALUE (\"spin_title_max_length\", config_getint (\"title_max_length\"));\n\n    CHECK_BUTTON (\"check_run_custom_command\", \"run_command\");\n    TEXT_ENTRY (\"entry_custom_command\", \"command\");\n    CHECK_BUTTON (\"check_command_login_shell\", \"command_login_shell\");\n\n    CHECK_BUTTON (\"check_control_activates_match\", \"control_activates_match\");\n\n    CHECK_BUTTON (\"check_match_web_uris\", \"match_web_uris\");\n    CHECK_BUTTON (\"check_custom_web_browser\", \"use_custom_web_browser\");\n\n    CHECK_BUTTON (\"check_match_file_uris\", \"match_file_uris\");\n    CHECK_BUTTON (\"check_match_email_addresses\", \"match_email_addresses\");\n    CHECK_BUTTON (\"check_match_numbers\", \"match_numbers\");\n\n    COMBO_BOX (\"combo_command_exit\", \"command_exit\");\n    COMBO_BOX (\"combo_on_last_terminal_exit\", \"on_last_terminal_exit\");\n    CHECK_BUTTON (\"check_prompt_on_exit\", \"prompt_on_exit\");\n    SET_SENSITIVE_BY_CONFIG_BOOL (\"entry_custom_command\",\"run_command\");\n    SET_SENSITIVE_BY_CONFIG_BOOL (\"label_custom_command\", \"run_command\");\n\n    TEXT_ENTRY (\"entry_web_browser\", \"web_browser\");\n\n    update_custom_web_browser_sensitivity ();\n\n    CHECK_BUTTON (\"check_confirm_close_tab\", \"confirm_close_tab\");\n\n    /* Appearance Tab */\n    /* Initialize the monitor chooser combo box with the numbers of the monitor */\n    initialize_combo_choose_monitor(tw);\n\n\n    initialize_geometry_spinners(tw);\n    CHECK_BUTTON (\"check_enable_transparency\", \"enable_transparency\");\n    CHECK_BUTTON (\"check_animated_pulldown\", \"animation\");\n    SPIN_BUTTON (\"spin_animation_delay\", \"slide_sleep_usec\");\n    COMBO_BOX (\"combo_animation_orientation\", \"animation_orientation\");\n\n    COMBO_BOX (\"combo_tab_pos\", \"tab_pos\");\n    CHECK_BUTTON (\"check_expand_tabs\", \"expand_tabs\");\n    CHECK_BUTTON (\"check_show_single_tab\", \"show_single_tab\");\n    CHECK_BUTTON (\"check_show_title_tooltip\", \"show_title_tooltip\");\n\n    SET_SENSITIVE_BY_CONFIG_BOOL (\"label_level_of_transparency\",\"enable_transparency\");\n    SET_SENSITIVE_BY_CONFIG_BOOL (\"spin_level_of_transparency\",\"enable_transparency\");\n    SET_SENSITIVE_BY_CONFIG_BOOL (\"label_animation_delay\",\"animation\");\n    SET_SENSITIVE_BY_CONFIG_BOOL (\"spin_animation_delay\",\"animation\");\n    SET_SENSITIVE_BY_CONFIG_BOOL (\"label_animation_orientation\",\"animation\");\n    SET_SENSITIVE_BY_CONFIG_BOOL (\"combo_animation_orientation\",\"animation\");\n\n    /* Colors Tab */\n    COMBO_BOX (\"combo_colorschemes\", \"scheme\");\n    text_color.red =   GUINT16_TO_FLOAT(config_getint (\"text_red\"));\n    text_color.green = GUINT16_TO_FLOAT(config_getint (\"text_green\"));\n    text_color.blue =  GUINT16_TO_FLOAT(config_getint (\"text_blue\"));\n    text_color.alpha = 1.0;\n    COLOR_CHOOSER (\"colorbutton_text\", &text_color);\n    back_color.red =   GUINT16_TO_FLOAT(config_getint (\"back_red\"));\n    back_color.green = GUINT16_TO_FLOAT(config_getint (\"back_green\"));\n    back_color.blue =  GUINT16_TO_FLOAT(config_getint (\"back_blue\"));\n    back_color.alpha = 1.0;\n    COLOR_CHOOSER (\"colorbutton_back\", &back_color);\n    cursor_color.red = GUINT16_TO_FLOAT(config_getint (\"cursor_red\"));\n    cursor_color.green = GUINT16_TO_FLOAT(config_getint (\"cursor_green\"));\n    cursor_color.blue = GUINT16_TO_FLOAT(config_getint (\"cursor_blue\"));\n    cursor_color.alpha = 1.0;\n    COLOR_CHOOSER (\"colorbutton_cursor\", &cursor_color);\n\n    COMBO_BOX (\"combo_palette_scheme\", \"palette_scheme\");\n\n    current_palette = tilda_palettes_get_current_palette ();\n\n    for(i = 0;i < TILDA_COLOR_PALETTE_SIZE; i++) {\n        current_palette[i].red   = GUINT16_TO_FLOAT (config_getnint (\"palette\", i*3));\n        current_palette[i].green = GUINT16_TO_FLOAT (config_getnint (\"palette\", i*3+1));\n        current_palette[i].blue  = GUINT16_TO_FLOAT (config_getnint (\"palette\", i*3+2));\n        current_palette[i].alpha = 1.0;\n\n        update_palette_color_button(i);\n    }\n\n    /* Scrolling Tab */\n    initialize_scrollback_settings();\n\n    /* Compatibility Tab */\n    COMBO_BOX (\"combo_backspace_binding\", \"backspace_key\");\n    COMBO_BOX (\"combo_delete_binding\", \"delete_key\");\n\n    TEXT_ENTRY (\"entry_word_chars\", \"word_chars\");\n\n    gtk_spin_button_set_value(GTK_SPIN_BUTTON(gtk_builder_get_object(xml, (\"spin_level_of_transparency\"))),\n                              (100 - 100*GUINT16_TO_FLOAT(config_getint(\"back_alpha\"))));\n}", "path": "tilda/src/wizard.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "lanoxx/tilda", "stars": 1230, "license": "gpl-2.0", "language": "c", "size": 4155}
{"docstring": "/**\n* If lock->pid is 0 then the file is not opened exclusively. Instead flock() must be used to obtain a lock.\n* Otherwise an exclusive lock file is created for the process.\n*/\n", "func_signal": "static gchar *create_lock_file (struct lock_info *lock)", "code": "{\n    DEBUG_FUNCTION (\"create_lock_file\");\n    DEBUG_ASSERT (lock != NULL);\n    DEBUG_ASSERT (lock->instance >= 0);\n    DEBUG_ASSERT (lock->pid >= 0);\n\n    gint ret;\n    gchar *lock_file_full;\n    gchar *lock_dir = g_build_filename (g_get_user_cache_dir (), \"tilda\", \"locks\", NULL);\n    gchar *lock_file = g_strdup_printf (\"lock_%d_%d\", lock->pid, lock->instance);\n\n    /* Make the ~/.cache/tilda/locks directory */\n    ret = g_mkdir_with_parents (lock_dir,  S_IRUSR | S_IWUSR | S_IXUSR);\n\n    if (ret == -1)\n        goto mkdir_fail;\n\n    /* Create the full path to the lock file */\n    lock_file_full = g_build_filename (lock_dir, lock_file, NULL);\n\n    /* Create the lock file */\n    if(lock->pid == 0) {\n        ret = open(lock_file_full, O_CREAT, S_IRUSR | S_IWUSR);\n    } else {\n        ret = open(lock_file_full, O_WRONLY | O_CREAT | O_EXCL, 0);\n    }\n\n    if (ret == -1)\n        goto creat_fail;\n\n    lock->file_descriptor = ret;\n\n    g_free (lock_file);\n    g_free (lock_dir);\n\n    return lock_file_full;\n\n    /* Free memory and return NULL */\n    creat_fail:\n    g_free (lock_file_full);\n    mkdir_fail:\n    g_free (lock_file);\n    g_free (lock_dir);\n\n    return NULL;\n}", "path": "tilda/src/tilda-lock-files.c", "commit_date": "2020-12-29 00:00:00", "repo_name": "lanoxx/tilda", "stars": 1230, "license": "gpl-2.0", "language": "c", "size": 4155}
{"docstring": "/*\n** mark metamethods for basic types\n*/\n", "func_signal": "static void markmt (global_State *g)", "code": "{\n  int i;\n  for (i=0; i < LUA_NUMTAGS; i++)\n    markobjectN(g, g->mt[i]);\n}", "path": "likwid/ext/lua/src/lgc.c", "commit_date": "2016-03-22 00:00:00", "repo_name": "RRZE-HPC/likwid", "stars": 1515, "license": "gpl-3.0", "language": "c", "size": 31679}
{"docstring": "/*\n** sweep at most 'count' elements from a list of GCObjects erasing dead\n** objects, where a dead object is one marked with the old (non current)\n** white; change all non-dead objects back to white, preparing for next\n** collection cycle. Return where to continue the traversal or NULL if\n** list is finished.\n*/\n", "func_signal": "static GCObject **sweeplist (lua_State *L, GCObject **p, lu_mem count)", "code": "{\n  global_State *g = G(L);\n  int ow = otherwhite(g);\n  int white = luaC_white(g);  /* current white */\n  while (*p != NULL && count-- > 0) {\n    GCObject *curr = *p;\n    int marked = curr->marked;\n    if (isdeadm(ow, marked)) {  /* is 'curr' dead? */\n      *p = curr->next;  /* remove 'curr' from list */\n      freeobj(L, curr);  /* erase 'curr' */\n    }\n    else {  /* change mark to 'white' */\n      curr->marked = cast_byte((marked & maskcolors) | white);\n      p = &curr->next;  /* go to next element */\n    }\n  }\n  return (*p == NULL) ? NULL : p;\n}", "path": "likwid/ext/lua/src/lgc.c", "commit_date": "2016-03-22 00:00:00", "repo_name": "RRZE-HPC/likwid", "stars": 1515, "license": "gpl-3.0", "language": "c", "size": 31679}
{"docstring": "/*\n** performs a basic GC step when collector is running\n*/\n", "func_signal": "void luaC_step (lua_State *L)", "code": "{\n  global_State *g = G(L);\n  l_mem debt = getdebt(g);  /* GC deficit (be paid now) */\n  if (!g->gcrunning) {  /* not running? */\n    luaE_setdebt(g, -GCSTEPSIZE * 10);  /* avoid being called too often */\n    return;\n  }\n  do {  /* repeat until pause or enough \"credit\" (negative debt) */\n    lu_mem work = singlestep(L);  /* perform one single step */\n    debt -= work;\n  } while (debt > -GCSTEPSIZE && g->gcstate != GCSpause);\n  if (g->gcstate == GCSpause)\n    setpause(g);  /* pause until next cycle */\n  else {\n    debt = (debt / g->gcstepmul) * STEPMULADJ;  /* convert 'work units' to Kb */\n    luaE_setdebt(g, debt);\n    runafewfinalizers(L);\n  }\n}", "path": "likwid/ext/lua/src/lgc.c", "commit_date": "2016-03-22 00:00:00", "repo_name": "RRZE-HPC/likwid", "stars": 1515, "license": "gpl-3.0", "language": "c", "size": 31679}
{"docstring": "/*\n** open upvalues point to values in a thread, so those values should\n** be marked when the thread is traversed except in the atomic phase\n** (because then the value cannot be changed by the thread and the\n** thread may not be traversed again)\n*/\n", "func_signal": "static lu_mem traverseLclosure (global_State *g, LClosure *cl)", "code": "{\n  int i;\n  markobjectN(g, cl->p);  /* mark its prototype */\n  for (i = 0; i < cl->nupvalues; i++) {  /* mark its upvalues */\n    UpVal *uv = cl->upvals[i];\n    if (uv != NULL) {\n      if (upisopen(uv) && g->gcstate != GCSinsideatomic)\n        uv->u.open.touched = 1;  /* can be marked in 'remarkupvals' */\n      else\n        markvalue(g, uv->v);\n    }\n  }\n  return sizeLclosure(cl->nupvalues);\n}", "path": "likwid/ext/lua/src/lgc.c", "commit_date": "2016-03-22 00:00:00", "repo_name": "RRZE-HPC/likwid", "stars": 1515, "license": "gpl-3.0", "language": "c", "size": 31679}
{"docstring": "/*\n** Performs a full GC cycle; if 'isemergency', set a flag to avoid\n** some operations which could change the interpreter state in some\n** unexpected ways (running finalizers and shrinking some structures).\n** Before running the collection, check 'keepinvariant'; if it is true,\n** there may be some objects marked as black, so the collector has\n** to sweep all objects to turn them back to white (as white has not\n** changed, nothing will be collected).\n*/\n", "func_signal": "void luaC_fullgc (lua_State *L, int isemergency)", "code": "{\n  global_State *g = G(L);\n  lua_assert(g->gckind == KGC_NORMAL);\n  if (isemergency) g->gckind = KGC_EMERGENCY;  /* set flag */\n  if (keepinvariant(g)) {  /* black objects? */\n    entersweep(L); /* sweep everything to turn them back to white */\n  }\n  /* finish any pending sweep phase to start a new cycle */\n  luaC_runtilstate(L, bitmask(GCSpause));\n  luaC_runtilstate(L, ~bitmask(GCSpause));  /* start new collection */\n  luaC_runtilstate(L, bitmask(GCScallfin));  /* run up to finalizers */\n  /* estimate must be correct after a full GC cycle */\n  lua_assert(g->GCestimate == gettotalbytes(g));\n  luaC_runtilstate(L, bitmask(GCSpause));  /* finish collection */\n  g->gckind = KGC_NORMAL;\n  setpause(g);\n}", "path": "likwid/ext/lua/src/lgc.c", "commit_date": "2016-03-22 00:00:00", "repo_name": "RRZE-HPC/likwid", "stars": 1515, "license": "gpl-3.0", "language": "c", "size": 31679}
{"docstring": "/*\n** get GC debt and convert it from Kb to 'work units' (avoid zero debt\n** and overflows)\n*/\n", "func_signal": "static l_mem getdebt (global_State *g)", "code": "{\n  l_mem debt = g->GCdebt;\n  int stepmul = g->gcstepmul;\n  if (debt <= 0) return 0;  /* minimal debt */\n  else {\n    debt = (debt / STEPMULADJ) + 1;\n    debt = (debt < MAX_LMEM / stepmul) ? debt * stepmul : MAX_LMEM;\n    return debt;\n  }\n}", "path": "likwid/ext/lua/src/lgc.c", "commit_date": "2016-03-22 00:00:00", "repo_name": "RRZE-HPC/likwid", "stars": 1515, "license": "gpl-3.0", "language": "c", "size": 31679}
{"docstring": "/*\n** find last 'next' field in list 'p' list (to add elements in its end)\n*/\n", "func_signal": "static GCObject **findlast (GCObject **p)", "code": "{\n  while (*p != NULL)\n    p = &(*p)->next;\n  return p;\n}", "path": "likwid/ext/lua/src/lgc.c", "commit_date": "2016-03-22 00:00:00", "repo_name": "RRZE-HPC/likwid", "stars": 1515, "license": "gpl-3.0", "language": "c", "size": 31679}
{"docstring": "/*\n** traverse one gray object, turning it to black (except for threads,\n** which are always gray).\n*/\n", "func_signal": "static void propagatemark (global_State *g)", "code": "{\n  lu_mem size;\n  GCObject *o = g->gray;\n  lua_assert(isgray(o));\n  gray2black(o);\n  switch (o->tt) {\n    case LUA_TTABLE: {\n      Table *h = gco2t(o);\n      g->gray = h->gclist;  /* remove from 'gray' list */\n      size = traversetable(g, h);\n      break;\n    }\n    case LUA_TLCL: {\n      LClosure *cl = gco2lcl(o);\n      g->gray = cl->gclist;  /* remove from 'gray' list */\n      size = traverseLclosure(g, cl);\n      break;\n    }\n    case LUA_TCCL: {\n      CClosure *cl = gco2ccl(o);\n      g->gray = cl->gclist;  /* remove from 'gray' list */\n      size = traverseCclosure(g, cl);\n      break;\n    }\n    case LUA_TTHREAD: {\n      lua_State *th = gco2th(o);\n      g->gray = th->gclist;  /* remove from 'gray' list */\n      linkgclist(th, g->grayagain);  /* insert into 'grayagain' list */\n      black2gray(o);\n      size = traversethread(g, th);\n      break;\n    }\n    case LUA_TPROTO: {\n      Proto *p = gco2p(o);\n      g->gray = p->gclist;  /* remove from 'gray' list */\n      size = traverseproto(g, p);\n      break;\n    }\n    default: lua_assert(0); return;\n  }\n  g->GCmemtrav += size;\n}", "path": "likwid/ext/lua/src/lgc.c", "commit_date": "2016-03-22 00:00:00", "repo_name": "RRZE-HPC/likwid", "stars": 1515, "license": "gpl-3.0", "language": "c", "size": 31679}
{"docstring": "/*\n** Traverse a prototype. (While a prototype is being build, its\n** arrays can be larger than needed; the extra slots are filled with\n** NULL, so the use of 'markobjectN')\n*/\n", "func_signal": "static int traverseproto (global_State *g, Proto *f)", "code": "{\n  int i;\n  if (f->cache && iswhite(f->cache))\n    f->cache = NULL;  /* allow cache to be collected */\n  markobjectN(g, f->source);\n  for (i = 0; i < f->sizek; i++)  /* mark literals */\n    markvalue(g, &f->k[i]);\n  for (i = 0; i < f->sizeupvalues; i++)  /* mark upvalue names */\n    markobjectN(g, f->upvalues[i].name);\n  for (i = 0; i < f->sizep; i++)  /* mark nested protos */\n    markobjectN(g, f->p[i]);\n  for (i = 0; i < f->sizelocvars; i++)  /* mark local-variable names */\n    markobjectN(g, f->locvars[i].varname);\n  return sizeof(Proto) + sizeof(Instruction) * f->sizecode +\n                         sizeof(Proto *) * f->sizep +\n                         sizeof(TValue) * f->sizek +\n                         sizeof(int) * f->sizelineinfo +\n                         sizeof(LocVar) * f->sizelocvars +\n                         sizeof(Upvaldesc) * f->sizeupvalues;\n}", "path": "likwid/ext/lua/src/lgc.c", "commit_date": "2016-03-22 00:00:00", "repo_name": "RRZE-HPC/likwid", "stars": 1515, "license": "gpl-3.0", "language": "c", "size": 31679}
{"docstring": "/*\n** if object 'o' has a finalizer, remove it from 'allgc' list (must\n** search the list to find it) and link it in 'finobj' list.\n*/\n", "func_signal": "void luaC_checkfinalizer (lua_State *L, GCObject *o, Table *mt)", "code": "{\n  global_State *g = G(L);\n  if (tofinalize(o) ||                 /* obj. is already marked... */\n      gfasttm(g, mt, TM_GC) == NULL)   /* or has no finalizer? */\n    return;  /* nothing to be done */\n  else {  /* move 'o' to 'finobj' list */\n    GCObject **p;\n    if (issweepphase(g)) {\n      makewhite(g, o);  /* \"sweep\" object 'o' */\n      if (g->sweepgc == &o->next)  /* should not remove 'sweepgc' object */\n        g->sweepgc = sweeptolive(L, g->sweepgc, NULL);  /* change 'sweepgc' */\n    }\n    /* search for pointer pointing to 'o' */\n    for (p = &g->allgc; *p != o; p = &(*p)->next) { /* empty */ }\n    *p = o->next;  /* remove 'o' from 'allgc' list */\n    o->next = g->finobj;  /* link it in 'finobj' list */\n    g->finobj = o;\n    l_setbit(o->marked, FINALIZEDBIT);  /* mark it as such */\n  }\n}", "path": "likwid/ext/lua/src/lgc.c", "commit_date": "2016-03-22 00:00:00", "repo_name": "RRZE-HPC/likwid", "stars": 1515, "license": "gpl-3.0", "language": "c", "size": 31679}
{"docstring": "/* #####   FUNCTION DEFINITIONS  -  EXPORTED FUNCTIONS   ################## */\n", "func_signal": "int\ncpu_count(cpu_set_t* set)", "code": "{\n    uint32_t i;\n    int s = 0;\n    const __cpu_mask *p = set->__bits;\n    const __cpu_mask *end = &set->__bits[sizeof(cpu_set_t) / sizeof (__cpu_mask)];\n\n    while (p < end)\n    {\n        __cpu_mask l = *p++;\n\n        if (l == 0)\n        {\n            continue;\n        }\n\n        for (i=0; i< (sizeof(__cpu_mask)*8); i++)\n        {\n            if (l&(1UL<<i))\n            {\n                s++;\n            }\n        }\n    }\n    return s;\n}", "path": "likwid/src/topology.c", "commit_date": "2020-11-16 00:00:00", "repo_name": "RRZE-HPC/likwid", "stars": 1515, "license": "gpl-3.0", "language": "c", "size": 31679}
{"docstring": "/*\n** move all unreachable objects (or 'all' objects) that need\n** finalization from list 'finobj' to list 'tobefnz' (to be finalized)\n*/\n", "func_signal": "static void separatetobefnz (global_State *g, int all)", "code": "{\n  GCObject *curr;\n  GCObject **p = &g->finobj;\n  GCObject **lastnext = findlast(&g->tobefnz);\n  while ((curr = *p) != NULL) {  /* traverse all finalizable objects */\n    lua_assert(tofinalize(curr));\n    if (!(iswhite(curr) || all))  /* not being collected? */\n      p = &curr->next;  /* don't bother with it */\n    else {\n      *p = curr->next;  /* remove 'curr' from 'finobj' list */\n      curr->next = *lastnext;  /* link at the end of 'tobefnz' list */\n      *lastnext = curr;\n      lastnext = &curr->next;\n    }\n  }\n}", "path": "likwid/ext/lua/src/lgc.c", "commit_date": "2016-03-22 00:00:00", "repo_name": "RRZE-HPC/likwid", "stars": 1515, "license": "gpl-3.0", "language": "c", "size": 31679}
{"docstring": "/* #####   FUNCTION DEFINITIONS  -  EXPORTED FUNCTIONS   ################## */\n", "func_signal": "void\nhashTable_init()", "code": "{\n    for (int i=0; i<MAX_NUM_THREADS; i++)\n    {\n        threadList[i] = NULL;\n    }\n}", "path": "likwid/src/hashTable.c", "commit_date": "2017-04-18 00:00:00", "repo_name": "RRZE-HPC/likwid", "stars": 1515, "license": "gpl-3.0", "language": "c", "size": 31679}
{"docstring": "/*\n** Enter first sweep phase.\n** The call to 'sweeptolive' makes pointer point to an object inside\n** the list (instead of to the header), so that the real sweep do not\n** need to skip objects created between \"now\" and the start of the real\n** sweep.\n** Returns how many objects it swept.\n*/\n", "func_signal": "static int entersweep (lua_State *L)", "code": "{\n  global_State *g = G(L);\n  int n = 0;\n  g->gcstate = GCSswpallgc;\n  lua_assert(g->sweepgc == NULL);\n  g->sweepgc = sweeptolive(L, &g->allgc, &n);\n  return n;\n}", "path": "likwid/ext/lua/src/lgc.c", "commit_date": "2016-03-22 00:00:00", "repo_name": "RRZE-HPC/likwid", "stars": 1515, "license": "gpl-3.0", "language": "c", "size": 31679}
{"docstring": "/*\n** mark all objects in list of being-finalized\n*/\n", "func_signal": "static void markbeingfnz (global_State *g)", "code": "{\n  GCObject *o;\n  for (o = g->tobefnz; o != NULL; o = o->next)\n    markobject(g, o);\n}", "path": "likwid/ext/lua/src/lgc.c", "commit_date": "2016-03-22 00:00:00", "repo_name": "RRZE-HPC/likwid", "stars": 1515, "license": "gpl-3.0", "language": "c", "size": 31679}
{"docstring": "/*\n** mark root set and reset all gray lists, to start a new collection\n*/\n", "func_signal": "static void restartcollection (global_State *g)", "code": "{\n  g->gray = g->grayagain = NULL;\n  g->weak = g->allweak = g->ephemeron = NULL;\n  markobject(g, g->mainthread);\n  markvalue(g, &g->l_registry);\n  markmt(g);\n  markbeingfnz(g);  /* mark any finalizing object left from previous cycle */\n}", "path": "likwid/ext/lua/src/lgc.c", "commit_date": "2016-03-22 00:00:00", "repo_name": "RRZE-HPC/likwid", "stars": 1515, "license": "gpl-3.0", "language": "c", "size": 31679}
{"docstring": "/*\n** Traverse an ephemeron table and link it to proper list. Returns true\n** iff any object was marked during this traversal (which implies that\n** convergence has to continue). During propagation phase, keep table\n** in 'grayagain' list, to be visited again in the atomic phase. In\n** the atomic phase, if table has any white->white entry, it has to\n** be revisited during ephemeron convergence (as that key may turn\n** black). Otherwise, if it has any white key, table has to be cleared\n** (in the atomic phase).\n*/\n", "func_signal": "static int traverseephemeron (global_State *g, Table *h)", "code": "{\n  int marked = 0;  /* true if an object is marked in this traversal */\n  int hasclears = 0;  /* true if table has white keys */\n  int hasww = 0;  /* true if table has entry \"white-key -> white-value\" */\n  Node *n, *limit = gnodelast(h);\n  unsigned int i;\n  /* traverse array part */\n  for (i = 0; i < h->sizearray; i++) {\n    if (valiswhite(&h->array[i])) {\n      marked = 1;\n      reallymarkobject(g, gcvalue(&h->array[i]));\n    }\n  }\n  /* traverse hash part */\n  for (n = gnode(h, 0); n < limit; n++) {\n    checkdeadkey(n);\n    if (ttisnil(gval(n)))  /* entry is empty? */\n      removeentry(n);  /* remove it */\n    else if (iscleared(g, gkey(n))) {  /* key is not marked (yet)? */\n      hasclears = 1;  /* table must be cleared */\n      if (valiswhite(gval(n)))  /* value not marked yet? */\n        hasww = 1;  /* white-white entry */\n    }\n    else if (valiswhite(gval(n))) {  /* value not marked yet? */\n      marked = 1;\n      reallymarkobject(g, gcvalue(gval(n)));  /* mark it now */\n    }\n  }\n  /* link table into proper list */\n  if (g->gcstate == GCSpropagate)\n    linkgclist(h, g->grayagain);  /* must retraverse it in atomic phase */\n  else if (hasww)  /* table has white->white entries? */\n    linkgclist(h, g->ephemeron);  /* have to propagate again */\n  else if (hasclears)  /* table has white keys? */\n    linkgclist(h, g->allweak);  /* may have to clean white keys */\n  return marked;\n}", "path": "likwid/ext/lua/src/lgc.c", "commit_date": "2016-03-22 00:00:00", "repo_name": "RRZE-HPC/likwid", "stars": 1515, "license": "gpl-3.0", "language": "c", "size": 31679}
{"docstring": "/*\n** sweep a list until a live object (or end of list)\n*/\n", "func_signal": "static GCObject **sweeptolive (lua_State *L, GCObject **p, int *n)", "code": "{\n  GCObject **old = p;\n  int i = 0;\n  do {\n    i++;\n    p = sweeplist(L, p, 1);\n  } while (p == old);\n  if (n) *n += i;\n  return p;\n}", "path": "likwid/ext/lua/src/lgc.c", "commit_date": "2016-03-22 00:00:00", "repo_name": "RRZE-HPC/likwid", "stars": 1515, "license": "gpl-3.0", "language": "c", "size": 31679}
{"docstring": "/*\n** advances the garbage collector until it reaches a state allowed\n** by 'statemask'\n*/\n", "func_signal": "void luaC_runtilstate (lua_State *L, int statesmask)", "code": "{\n  global_State *g = G(L);\n  while (!testbit(statesmask, g->gcstate))\n    singlestep(L);\n}", "path": "likwid/ext/lua/src/lgc.c", "commit_date": "2016-03-22 00:00:00", "repo_name": "RRZE-HPC/likwid", "stars": 1515, "license": "gpl-3.0", "language": "c", "size": 31679}
{"docstring": "/*\n** Mark all values stored in marked open upvalues from non-marked threads.\n** (Values from marked threads were already marked when traversing the\n** thread.) Remove from the list threads that no longer have upvalues and\n** not-marked threads.\n*/\n", "func_signal": "static void remarkupvals (global_State *g)", "code": "{\n  lua_State *thread;\n  lua_State **p = &g->twups;\n  while ((thread = *p) != NULL) {\n    lua_assert(!isblack(thread));  /* threads are never black */\n    if (isgray(thread) && thread->openupval != NULL)\n      p = &thread->twups;  /* keep marked thread with upvalues in the list */\n    else {  /* thread is not marked or without upvalues */\n      UpVal *uv;\n      *p = thread->twups;  /* remove thread from the list */\n      thread->twups = thread;  /* mark that it is out of list */\n      for (uv = thread->openupval; uv != NULL; uv = uv->u.open.next) {\n        if (uv->u.open.touched) {\n          markvalue(g, uv->v);  /* remark upvalue's value */\n          uv->u.open.touched = 0;\n        }\n      }\n    }\n  }\n}", "path": "likwid/ext/lua/src/lgc.c", "commit_date": "2016-03-22 00:00:00", "repo_name": "RRZE-HPC/likwid", "stars": 1515, "license": "gpl-3.0", "language": "c", "size": 31679}
{"docstring": "/* Link a program with all currently attached shaders */\n", "func_signal": "GLint glueLinkProgram(GLuint program)", "code": "{\n\tGLint logLength, status;\n\t\n\tglLinkProgram(program);\n\tglGetProgramiv(program, GL_INFO_LOG_LENGTH, &logLength);\n\tif (logLength > 0)\n\t{\n\t\tGLchar *log = (GLchar *)malloc(logLength);\n\t\tglGetProgramInfoLog(program, logLength, &logLength, log);\n\t\tLogInfo(\"Program link log:\\n%s\", log);\n\t\tfree(log);\n\t}\n\t\n\tglGetProgramiv(program, GL_LINK_STATUS, &status);\n\tif (status == 0)\n\t\tLogError(\"Failed to link program %d\", program);\n\tglError();\n\t\n\treturn status;\n}", "path": "LearnOpenGLES/Tutorial08-\u5e27\u7f13\u5b58/LearnOpenGLES/UtilSrc/shaderUtil.c", "commit_date": "2016-04-22 00:00:00", "repo_name": "loyinglin/LearnOpenGLES", "stars": 1614, "license": "None", "language": "c", "size": 81797}
{"docstring": "/* _WIN32 */\n", "func_signal": "GLenum glewInit ()", "code": "{\n  GLenum r;\n  if ( (r = glewContextInit()) ) return r;\n#if defined(_WIN32)\n  return wglewContextInit();\n#elif !defined(__APPLE__) || defined(GLEW_APPLE_GLX) /* _UNIX */\n  return glxewContextInit();\n#else\n  return r;\n#endif /* _WIN32 */\n}", "path": "LearnOpenGLES/OpenGL/GLTools/src/glew.c", "commit_date": "2017-03-10 00:00:00", "repo_name": "loyinglin/LearnOpenGLES", "stars": 1614, "license": "None", "language": "c", "size": 81797}
{"docstring": "/* \n * Search for name in the extensions string. Use of strstr()\n * is not sufficient because extension names can be prefixes of\n * other extension names. Could use strtok() but the constant\n * string returned by glGetString might be in read-only memory.\n */\n", "func_signal": "GLboolean glewGetExtension (const char* name)", "code": "{    \n  GLubyte* p;\n  GLubyte* end;\n  GLuint len = _glewStrLen((const GLubyte*)name);\n  p = (GLubyte*)glGetString(GL_EXTENSIONS);\n  if (0 == p) return GL_FALSE;\n  end = p + _glewStrLen(p);\n  while (p < end)\n  {\n    GLuint n = _glewStrCLen(p, ' ');\n    if (len == n && _glewStrSame((const GLubyte*)name, p, n)) return GL_TRUE;\n    p += n+1;\n  }\n  return GL_FALSE;\n}", "path": "LearnOpenGLES/OpenGL/GLTools/src/glew.c", "commit_date": "2017-03-10 00:00:00", "repo_name": "loyinglin/LearnOpenGLES", "stars": 1614, "license": "None", "language": "c", "size": 81797}
{"docstring": "/* Compile a shader from the provided source(s) */\n", "func_signal": "GLint glueCompileShader(GLenum target, GLsizei count, const GLchar **sources, GLuint *shader)", "code": "{\n\tGLint logLength, status;\n\n\t*shader = glCreateShader(target);\t\n\tglShaderSource(*shader, count, sources, NULL);\n\tglCompileShader(*shader);\n\tglGetShaderiv(*shader, GL_INFO_LOG_LENGTH, &logLength);\n\tif (logLength > 0)\n\t{\n\t\tGLchar *log = (GLchar *)malloc(logLength);\n\t\tglGetShaderInfoLog(*shader, logLength, &logLength, log);\n\t\tLogInfo(\"Shader compile log:\\n%s\", log);\n\t\tfree(log);\n\t}\n\n\tglGetShaderiv(*shader, GL_COMPILE_STATUS, &status);\n\tif (status == 0)\n\t{\n\t\tint i;\n\t\t\n\t\tLogError(\"Failed to compile shader:\\n\");\n\t\tfor (i = 0; i < count; i++)\n\t\t\tLogInfo(\"%s\", sources[i]);\t\n\t}\n\tglError();\n\t\n\treturn status;\n}", "path": "LearnOpenGLES/Tutorial\u753b\u56fe/Classes/UtilSrc/shaderUtil.c", "commit_date": "2016-03-31 00:00:00", "repo_name": "loyinglin/LearnOpenGLES", "stars": 1614, "license": "None", "language": "c", "size": 81797}
{"docstring": "/* Validate a program (for i.e. inconsistent samplers) */\n", "func_signal": "GLint glueValidateProgram(GLuint program)", "code": "{\n\tGLint logLength, status;\n\t\n\tglValidateProgram(program);\n\tglGetProgramiv(program, GL_INFO_LOG_LENGTH, &logLength);\n\tif (logLength > 0)\n\t{\n\t\tGLchar *log = (GLchar *)malloc(logLength);\n\t\tglGetProgramInfoLog(program, logLength, &logLength, log);\n\t\tLogInfo(\"Program validate log:\\n%s\", log);\n\t\tfree(log);\n\t}\n\n\tglGetProgramiv(program, GL_VALIDATE_STATUS, &status);\n\tif (status == 0)\n\t\tLogError(\"Failed to validate program %d\", program);\n\tglError();\n\t\n\treturn status;\n}", "path": "LearnOpenGLES/util/APPLE/shaderUtil.c", "commit_date": "2016-03-31 00:00:00", "repo_name": "loyinglin/LearnOpenGLES", "stars": 1614, "license": "None", "language": "c", "size": 81797}
{"docstring": "//\n// Matrix math utils\n//\n", "func_signal": "void ksScale(KSMatrix4 *result, GLfloat sx, GLfloat sy, GLfloat sz)", "code": "{\n    result->m[0][0] *= sx;\n    result->m[0][1] *= sx;\n    result->m[0][2] *= sx;\n    result->m[0][3] *= sx;\n    \n    result->m[1][0] *= sy;\n    result->m[1][1] *= sy;\n    result->m[1][2] *= sy;\n    result->m[1][3] *= sy;\n    \n    result->m[2][0] *= sz;\n    result->m[2][1] *= sz;\n    result->m[2][2] *= sz;\n    result->m[2][3] *= sz;\n}", "path": "LearnOpenGLES/Tutorial/LearnOpenGLES/Utils/GLESMath.c", "commit_date": "2016-04-06 00:00:00", "repo_name": "loyinglin/LearnOpenGLES", "stars": 1614, "license": "None", "language": "c", "size": 81797}
{"docstring": "//\n// Matrix math utils\n//\n", "func_signal": "void ksScale(KSMatrix4 *result, GLfloat sx, GLfloat sy, GLfloat sz)", "code": "{\n    result->m[0][0] *= sx;\n    result->m[0][1] *= sx;\n    result->m[0][2] *= sx;\n    result->m[0][3] *= sx;\n    \n    result->m[1][0] *= sy;\n    result->m[1][1] *= sy;\n    result->m[1][2] *= sy;\n    result->m[1][3] *= sy;\n    \n    result->m[2][0] *= sz;\n    result->m[2][1] *= sz;\n    result->m[2][2] *= sz;\n    result->m[2][3] *= sz;\n}", "path": "LearnOpenGLES/Tutorial03-\u4e09\u7ef4\u53d8\u6362/LearnOpenGLES/Utils/GLESMath.c", "commit_date": "2016-03-23 00:00:00", "repo_name": "loyinglin/LearnOpenGLES", "stars": 1614, "license": "None", "language": "c", "size": 81797}
{"docstring": "/* Convenience wrapper that compiles, links, enumerates uniforms and attribs */\n", "func_signal": "GLint glueCreateProgram(const GLchar *vertSource, const GLchar *fragSource,\n                       GLsizei attribNameCt, const GLchar **attribNames, \n                       const GLint *attribLocations,\n                       GLsizei uniformNameCt, const GLchar **uniformNames, \n                       GLint *uniformLocations,\n                       GLuint *program)", "code": "{\n\tGLuint vertShader = 0, fragShader = 0, prog = 0, status = 1, i;\n\t\n\tprog = glCreateProgram();\n\n\tstatus *= glueCompileShader(GL_VERTEX_SHADER, 1, &vertSource, &vertShader);\n\tstatus *= glueCompileShader(GL_FRAGMENT_SHADER, 1, &fragSource, &fragShader);\n\tglAttachShader(prog, vertShader);\n\tglAttachShader(prog, fragShader);\n\t\n\tfor (i = 0; i < attribNameCt; i++)\n\t{\n\t\tif(strlen(attribNames[i]))\n\t\t\tglBindAttribLocation(prog, attribLocations[i], attribNames[i]);\n\t}\n\t\n\tstatus *= glueLinkProgram(prog);\n\tstatus *= glueValidateProgram(prog);\n\n\tif (status)\n\t{\t\n        for(i = 0; i < uniformNameCt; i++)\n\t\t{\n            if(strlen(uniformNames[i]))\n\t\t\t    uniformLocations[i] = glueGetUniformLocation(prog, uniformNames[i]);\n\t\t}\n\t\t*program = prog;\n\t}\n\tif (vertShader)\n\t\tglDeleteShader(vertShader);\n\tif (fragShader)\n\t\tglDeleteShader(fragShader);\n\tglError();\n\t\t\n\treturn status;\n}", "path": "LearnOpenGLES/Tutorial\u753b\u56fe/Classes/UtilSrc/shaderUtil.c", "commit_date": "2016-03-31 00:00:00", "repo_name": "loyinglin/LearnOpenGLES", "stars": 1614, "license": "None", "language": "c", "size": 81797}
{"docstring": "/* Convenience wrapper that compiles, links, enumerates uniforms and attribs */\n", "func_signal": "GLint glueCreateProgram(const GLchar *vertSource, const GLchar *fragSource,\n                       GLsizei attribNameCt, const GLchar **attribNames, \n                       const GLint *attribLocations,\n                       GLsizei uniformNameCt, const GLchar **uniformNames, \n                       GLint *uniformLocations,\n                       GLuint *program)", "code": "{\n\tGLuint vertShader = 0, fragShader = 0, prog = 0, status = 1, i;\n\t\n\tprog = glCreateProgram();\n\n\tstatus *= glueCompileShader(GL_VERTEX_SHADER, 1, &vertSource, &vertShader);\n\tstatus *= glueCompileShader(GL_FRAGMENT_SHADER, 1, &fragSource, &fragShader);\n\tglAttachShader(prog, vertShader);\n\tglAttachShader(prog, fragShader);\n\t\n\tfor (i = 0; i < attribNameCt; i++)\n\t{\n\t\tif(strlen(attribNames[i]))\n\t\t\tglBindAttribLocation(prog, attribLocations[i], attribNames[i]);\n\t}\n\t\n\tstatus *= glueLinkProgram(prog);\n\tstatus *= glueValidateProgram(prog);\n\n\tif (status)\n\t{\t\n        for(i = 0; i < uniformNameCt; i++)\n\t\t{\n            if(strlen(uniformNames[i]))\n\t\t\t    uniformLocations[i] = glueGetUniformLocation(prog, uniformNames[i]);\n\t\t}\n\t\t*program = prog;\n\t}\n\tif (vertShader)\n\t\tglDeleteShader(vertShader);\n\tif (fragShader)\n\t\tglDeleteShader(fragShader);\n\tglError();\n\t\t\n\treturn status;\n}", "path": "LearnOpenGLES/Tutorial08-\u5e27\u7f13\u5b58/LearnOpenGLES/UtilSrc/shaderUtil.c", "commit_date": "2016-04-22 00:00:00", "repo_name": "loyinglin/LearnOpenGLES", "stars": 1614, "license": "None", "language": "c", "size": 81797}
{"docstring": "/* Convenience wrapper that compiles, links, enumerates uniforms and attribs */\n", "func_signal": "GLint glueCreateProgram(const GLchar *vertSource, const GLchar *fragSource,\n                       GLsizei attribNameCt, const GLchar **attribNames, \n                       const GLint *attribLocations,\n                       GLsizei uniformNameCt, const GLchar **uniformNames, \n                       GLint *uniformLocations,\n                       GLuint *program)", "code": "{\n\tGLuint vertShader = 0, fragShader = 0, prog = 0, status = 1, i;\n\t\n\tprog = glCreateProgram();\n\n\tstatus *= glueCompileShader(GL_VERTEX_SHADER, 1, &vertSource, &vertShader);\n\tstatus *= glueCompileShader(GL_FRAGMENT_SHADER, 1, &fragSource, &fragShader);\n\tglAttachShader(prog, vertShader);\n\tglAttachShader(prog, fragShader);\n\t\n\tfor (i = 0; i < attribNameCt; i++)\n\t{\n\t\tif(strlen(attribNames[i]))\n\t\t\tglBindAttribLocation(prog, attribLocations[i], attribNames[i]);\n\t}\n\t\n\tstatus *= glueLinkProgram(prog);\n\tstatus *= glueValidateProgram(prog);\n\n\tif (status)\n\t{\t\n        for(i = 0; i < uniformNameCt; i++)\n\t\t{\n            if(strlen(uniformNames[i]))\n\t\t\t    uniformLocations[i] = glueGetUniformLocation(prog, uniformNames[i]);\n\t\t}\n\t\t*program = prog;\n\t}\n\tif (vertShader)\n\t\tglDeleteShader(vertShader);\n\tif (fragShader)\n\t\tglDeleteShader(fragShader);\n\tglError();\n\t\t\n\treturn status;\n}", "path": "LearnOpenGLES/util/APPLE/shaderUtil.c", "commit_date": "2016-03-31 00:00:00", "repo_name": "loyinglin/LearnOpenGLES", "stars": 1614, "license": "None", "language": "c", "size": 81797}
{"docstring": "/* Link a program with all currently attached shaders */\n", "func_signal": "GLint glueLinkProgram(GLuint program)", "code": "{\n\tGLint logLength, status;\n\t\n\tglLinkProgram(program);\n\tglGetProgramiv(program, GL_INFO_LOG_LENGTH, &logLength);\n\tif (logLength > 0)\n\t{\n\t\tGLchar *log = (GLchar *)malloc(logLength);\n\t\tglGetProgramInfoLog(program, logLength, &logLength, log);\n\t\tLogInfo(\"Program link log:\\n%s\", log);\n\t\tfree(log);\n\t}\n\t\n\tglGetProgramiv(program, GL_LINK_STATUS, &status);\n\tif (status == 0)\n\t\tLogError(\"Failed to link program %d\", program);\n\tglError();\n\t\n\treturn status;\n}", "path": "LearnOpenGLES/util/APPLE/shaderUtil.c", "commit_date": "2016-03-31 00:00:00", "repo_name": "loyinglin/LearnOpenGLES", "stars": 1614, "license": "None", "language": "c", "size": 81797}
{"docstring": "/* Validate a program (for i.e. inconsistent samplers) */\n", "func_signal": "GLint glueValidateProgram(GLuint program)", "code": "{\n\tGLint logLength, status;\n\t\n\tglValidateProgram(program);\n\tglGetProgramiv(program, GL_INFO_LOG_LENGTH, &logLength);\n\tif (logLength > 0)\n\t{\n\t\tGLchar *log = (GLchar *)malloc(logLength);\n\t\tglGetProgramInfoLog(program, logLength, &logLength, log);\n\t\tLogInfo(\"Program validate log:\\n%s\", log);\n\t\tfree(log);\n\t}\n\n\tglGetProgramiv(program, GL_VALIDATE_STATUS, &status);\n\tif (status == 0)\n\t\tLogError(\"Failed to validate program %d\", program);\n\tglError();\n\t\n\treturn status;\n}", "path": "LearnOpenGLES/Tutorial08-\u5e27\u7f13\u5b58/LearnOpenGLES/UtilSrc/shaderUtil.c", "commit_date": "2016-04-22 00:00:00", "repo_name": "loyinglin/LearnOpenGLES", "stars": 1614, "license": "None", "language": "c", "size": 81797}
{"docstring": "/* Return named uniform location after linking */\n", "func_signal": "GLint glueGetUniformLocation(GLuint program, const GLchar *uniformName)", "code": "{\n    GLint loc;\n\n    loc = glGetUniformLocation(program, uniformName);\n\n    return loc;\n}", "path": "LearnOpenGLES/util/APPLE/shaderUtil.c", "commit_date": "2016-03-31 00:00:00", "repo_name": "loyinglin/LearnOpenGLES", "stars": 1614, "license": "None", "language": "c", "size": 81797}
{"docstring": "/* Validate a program (for i.e. inconsistent samplers) */\n", "func_signal": "GLint glueValidateProgram(GLuint program)", "code": "{\n\tGLint logLength, status;\n\t\n\tglValidateProgram(program);\n\tglGetProgramiv(program, GL_INFO_LOG_LENGTH, &logLength);\n\tif (logLength > 0)\n\t{\n\t\tGLchar *log = (GLchar *)malloc(logLength);\n\t\tglGetProgramInfoLog(program, logLength, &logLength, log);\n\t\tLogInfo(\"Program validate log:\\n%s\", log);\n\t\tfree(log);\n\t}\n\n\tglGetProgramiv(program, GL_VALIDATE_STATUS, &status);\n\tif (status == 0)\n\t\tLogError(\"Failed to validate program %d\", program);\n\tglError();\n\t\n\treturn status;\n}", "path": "LearnOpenGLES/Tutorial\u753b\u56fe/Classes/UtilSrc/shaderUtil.c", "commit_date": "2016-03-31 00:00:00", "repo_name": "loyinglin/LearnOpenGLES", "stars": 1614, "license": "None", "language": "c", "size": 81797}
{"docstring": "/* Return named uniform location after linking */\n", "func_signal": "GLint glueGetUniformLocation(GLuint program, const GLchar *uniformName)", "code": "{\n    GLint loc;\n\n    loc = glGetUniformLocation(program, uniformName);\n\n    return loc;\n}", "path": "LearnOpenGLES/Tutorial08-\u5e27\u7f13\u5b58/LearnOpenGLES/UtilSrc/shaderUtil.c", "commit_date": "2016-04-22 00:00:00", "repo_name": "loyinglin/LearnOpenGLES", "stars": 1614, "license": "None", "language": "c", "size": 81797}
{"docstring": "/* Link a program with all currently attached shaders */\n", "func_signal": "GLint glueLinkProgram(GLuint program)", "code": "{\n\tGLint logLength, status;\n\t\n\tglLinkProgram(program);\n\tglGetProgramiv(program, GL_INFO_LOG_LENGTH, &logLength);\n\tif (logLength > 0)\n\t{\n\t\tGLchar *log = (GLchar *)malloc(logLength);\n\t\tglGetProgramInfoLog(program, logLength, &logLength, log);\n\t\tLogInfo(\"Program link log:\\n%s\", log);\n\t\tfree(log);\n\t}\n\t\n\tglGetProgramiv(program, GL_LINK_STATUS, &status);\n\tif (status == 0)\n\t\tLogError(\"Failed to link program %d\", program);\n\tglError();\n\t\n\treturn status;\n}", "path": "LearnOpenGLES/Tutorial\u753b\u56fe/Classes/UtilSrc/shaderUtil.c", "commit_date": "2016-03-31 00:00:00", "repo_name": "loyinglin/LearnOpenGLES", "stars": 1614, "license": "None", "language": "c", "size": 81797}
{"docstring": "/* Return named uniform location after linking */\n", "func_signal": "GLint glueGetUniformLocation(GLuint program, const GLchar *uniformName)", "code": "{\n    GLint loc;\n\n    loc = glGetUniformLocation(program, uniformName);\n\n    return loc;\n}", "path": "LearnOpenGLES/Tutorial\u753b\u56fe/Classes/UtilSrc/shaderUtil.c", "commit_date": "2016-03-31 00:00:00", "repo_name": "loyinglin/LearnOpenGLES", "stars": 1614, "license": "None", "language": "c", "size": 81797}
{"docstring": "/*\n * GLEW, just like OpenGL or GLU, does not rely on the standard C library.\n * These functions implement the functionality required in this file.\n */\n", "func_signal": "static GLuint _glewStrLen (const GLubyte* s)", "code": "{\n  GLuint i=0;\n  if (s == NULL) return 0;\n  while (s[i] != '\\0') i++;\n  return i;\n}", "path": "LearnOpenGLES/OpenGL/GLTools/src/glew.c", "commit_date": "2017-03-10 00:00:00", "repo_name": "loyinglin/LearnOpenGLES", "stars": 1614, "license": "None", "language": "c", "size": 81797}
{"docstring": "/* Compile a shader from the provided source(s) */\n", "func_signal": "GLint glueCompileShader(GLenum target, GLsizei count, const GLchar **sources, GLuint *shader)", "code": "{\n\tGLint logLength, status;\n\n\t*shader = glCreateShader(target);\t\n\tglShaderSource(*shader, count, sources, NULL);\n\tglCompileShader(*shader);\n\tglGetShaderiv(*shader, GL_INFO_LOG_LENGTH, &logLength);\n\tif (logLength > 0)\n\t{\n\t\tGLchar *log = (GLchar *)malloc(logLength);\n\t\tglGetShaderInfoLog(*shader, logLength, &logLength, log);\n\t\tLogInfo(\"Shader compile log:\\n%s\", log);\n\t\tfree(log);\n\t}\n\n\tglGetShaderiv(*shader, GL_COMPILE_STATUS, &status);\n\tif (status == 0)\n\t{\n\t\tint i;\n\t\t\n\t\tLogError(\"Failed to compile shader:\\n\");\n\t\tfor (i = 0; i < count; i++)\n\t\t\tLogInfo(\"%s\", sources[i]);\t\n\t}\n\tglError();\n\t\n\treturn status;\n}", "path": "LearnOpenGLES/util/APPLE/shaderUtil.c", "commit_date": "2016-03-31 00:00:00", "repo_name": "loyinglin/LearnOpenGLES", "stars": 1614, "license": "None", "language": "c", "size": 81797}
{"docstring": "/* Compile a shader from the provided source(s) */\n", "func_signal": "GLint glueCompileShader(GLenum target, GLsizei count, const GLchar **sources, GLuint *shader)", "code": "{\n\tGLint logLength, status;\n\n\t*shader = glCreateShader(target);\t\n\tglShaderSource(*shader, count, sources, NULL);\n\tglCompileShader(*shader);\n\tglGetShaderiv(*shader, GL_INFO_LOG_LENGTH, &logLength);\n\tif (logLength > 0)\n\t{\n\t\tGLchar *log = (GLchar *)malloc(logLength);\n\t\tglGetShaderInfoLog(*shader, logLength, &logLength, log);\n\t\tLogInfo(\"Shader compile log:\\n%s\", log);\n\t\tfree(log);\n\t}\n\n\tglGetShaderiv(*shader, GL_COMPILE_STATUS, &status);\n\tif (status == 0)\n\t{\n\t\tint i;\n\t\t\n\t\tLogError(\"Failed to compile shader:\\n\");\n\t\tfor (i = 0; i < count; i++)\n\t\t\tLogInfo(\"%s\", sources[i]);\t\n\t}\n\tglError();\n\t\n\treturn status;\n}", "path": "LearnOpenGLES/Tutorial08-\u5e27\u7f13\u5b58/LearnOpenGLES/UtilSrc/shaderUtil.c", "commit_date": "2016-04-22 00:00:00", "repo_name": "loyinglin/LearnOpenGLES", "stars": 1614, "license": "None", "language": "c", "size": 81797}
{"docstring": "/**\n * \\brief           Check for new data received with DMA\n */\n", "func_signal": "void\nusart_rx_check(void)", "code": "{\n    static size_t old_pos;\n    size_t pos;\n\n    /* Calculate current position in buffer */\n    pos = ARRAY_LEN(usart_rx_dma_buffer) - LL_DMA_GetDataLength(DMA1, LL_DMA_CHANNEL_1);\n    if (pos != old_pos) {                       /* Check change in received data */\n        if (pos > old_pos) {                    /* Current position is over previous one */\n            /* We are in \"linear\" mode */\n            /* Process data directly by subtracting \"pointers\" */\n            usart_process_data(&usart_rx_dma_buffer[old_pos], pos - old_pos);\n        } else {\n            /* We are in \"overflow\" mode */\n            /* First process data to the end of buffer */\n            usart_process_data(&usart_rx_dma_buffer[old_pos], ARRAY_LEN(usart_rx_dma_buffer) - old_pos);\n            /* Check and continue with beginning of buffer */\n            if (pos > 0) {\n                usart_process_data(&usart_rx_dma_buffer[0], pos);\n            }\n        }\n    }\n    old_pos = pos;                              /* Save current position as old */\n\n    /* Check and manually update if we reached end of buffer */\n    if (old_pos == ARRAY_LEN(usart_rx_dma_buffer)) {\n        old_pos = 0;\n    }\n}", "path": "stm32-usart-uart-dma-rx-tx/projects/usart_rx_idle_line_irq_G0/Src/main.c", "commit_date": "2019-11-11 00:00:00", "repo_name": "MaJerle/stm32-usart-uart-dma-rx-tx", "stars": 1126, "license": "mit", "language": "c", "size": 20623}
{"docstring": "/**\n  * @brief This function handles Pre-fetch fault, memory access fault.\n  */\n", "func_signal": "void BusFault_Handler(void)", "code": "{\n  /* USER CODE BEGIN BusFault_IRQn 0 */\n\n  /* USER CODE END BusFault_IRQn 0 */\n  while (1)\n  {\n    /* USER CODE BEGIN W1_BusFault_IRQn 0 */\n    /* USER CODE END W1_BusFault_IRQn 0 */\n  }\n  /* USER CODE BEGIN BusFault_IRQn 1 */\n\n  /* USER CODE END BusFault_IRQn 1 */\n}", "path": "stm32-usart-uart-dma-rx-tx/projects/usart_rx_polling_rtos_F4/Src/stm32f4xx_it.c", "commit_date": "2019-10-31 00:00:00", "repo_name": "MaJerle/stm32-usart-uart-dma-rx-tx", "stars": 1126, "license": "mit", "language": "c", "size": 20623}
{"docstring": "/**\n * \\brief           System Clock Configuration\n */\n", "func_signal": "void\nSystemClock_Config(void)", "code": "{\n    /* Configure flash latency */\n    LL_FLASH_SetLatency(LL_FLASH_LATENCY_2);\n    if (LL_FLASH_GetLatency() != LL_FLASH_LATENCY_2) {\n        while (1) {}\n    }\n\n    /* Configure HSI */\n    LL_RCC_HSI_Enable();\n    while (LL_RCC_HSI_IsReady() != 1) {}\n\n    /* Configure PLL */\n    LL_RCC_PLL_ConfigDomain_SYS(LL_RCC_PLLSOURCE_HSI, LL_RCC_PLLM_DIV_1, 8, LL_RCC_PLLR_DIV_2);\n    LL_RCC_PLL_Enable();\n    LL_RCC_PLL_EnableDomain_SYS();\n    while (LL_RCC_PLL_IsReady() != 1) {}\n\n    /* Configure system clock */\n    LL_RCC_SetAHBPrescaler(LL_RCC_SYSCLK_DIV_1);\n    LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_PLL);\n    while (LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_PLL) {}\n    LL_RCC_SetAPB1Prescaler(LL_RCC_APB1_DIV_1);\n\n    /* Configure systick */\n    LL_Init1msTick(64000000);\n    LL_SYSTICK_SetClkSource(LL_SYSTICK_CLKSOURCE_HCLK);\n    LL_SYSTICK_EnableIT();\n    LL_SetSystemCoreClock(64000000);\n    LL_RCC_SetUSARTClockSource(LL_RCC_USART2_CLKSOURCE_PCLK1);\n}", "path": "stm32-usart-uart-dma-rx-tx/projects/usart_rx_idle_line_irq_G0/Src/main.c", "commit_date": "2019-11-11 00:00:00", "repo_name": "MaJerle/stm32-usart-uart-dma-rx-tx", "stars": 1126, "license": "mit", "language": "c", "size": 20623}
{"docstring": "/**\n * \\brief           DMA1 stream1 interrupt handler for USART3 RX\n */\n", "func_signal": "void\nDMA1_Channel1_IRQHandler(void)", "code": "{\n    /* Check half-transfer complete interrupt */\n    if (LL_DMA_IsEnabledIT_HT(DMA1, LL_DMA_CHANNEL_1) && LL_DMA_IsActiveFlag_HT1(DMA1)) {\n        LL_DMA_ClearFlag_HT1(DMA1);             /* Clear half-transfer complete flag */\n        usart_rx_check();                       /* Check for data to process */\n    }\n\n    /* Check transfer-complete interrupt */\n    if (LL_DMA_IsEnabledIT_TC(DMA1, LL_DMA_CHANNEL_1) && LL_DMA_IsActiveFlag_TC1(DMA1)) {\n        LL_DMA_ClearFlag_TC1(DMA1);             /* Clear transfer complete flag */\n        usart_rx_check();                       /* Check for data to process */\n    }\n\n    /* Implement other events when needed */\n}", "path": "stm32-usart-uart-dma-rx-tx/projects/usart_rx_idle_line_irq_G0/Src/main.c", "commit_date": "2019-11-11 00:00:00", "repo_name": "MaJerle/stm32-usart-uart-dma-rx-tx", "stars": 1126, "license": "mit", "language": "c", "size": 20623}
{"docstring": "/**\n* @brief This function handles Memory management fault.\n*/\n", "func_signal": "void MemManage_Handler(void)", "code": "{\n  /* USER CODE BEGIN MemoryManagement_IRQn 0 */\n\n  /* USER CODE END MemoryManagement_IRQn 0 */\n  while (1)\n  {\n    /* USER CODE BEGIN W1_MemoryManagement_IRQn 0 */\n    /* USER CODE END W1_MemoryManagement_IRQn 0 */\n  }\n  /* USER CODE BEGIN MemoryManagement_IRQn 1 */\n\n  /* USER CODE END MemoryManagement_IRQn 1 */\n}", "path": "stm32-usart-uart-dma-rx-tx/projects/usart_rx_idle_line_irq_F1/Src/stm32f1xx_it.c", "commit_date": "2019-10-31 00:00:00", "repo_name": "MaJerle/stm32-usart-uart-dma-rx-tx", "stars": 1126, "license": "mit", "language": "c", "size": 20623}
{"docstring": "/**\n* @brief This function handles Undefined instruction or illegal state.\n*/\n", "func_signal": "void UsageFault_Handler(void)", "code": "{\n  /* USER CODE BEGIN UsageFault_IRQn 0 */\n\n  /* USER CODE END UsageFault_IRQn 0 */\n  while (1)\n  {\n    /* USER CODE BEGIN W1_UsageFault_IRQn 0 */\n    /* USER CODE END W1_UsageFault_IRQn 0 */\n  }\n  /* USER CODE BEGIN UsageFault_IRQn 1 */\n\n  /* USER CODE END UsageFault_IRQn 1 */\n}", "path": "stm32-usart-uart-dma-rx-tx/projects/usart_rx_idle_line_irq_F1/Src/stm32f1xx_it.c", "commit_date": "2019-10-31 00:00:00", "repo_name": "MaJerle/stm32-usart-uart-dma-rx-tx", "stars": 1126, "license": "mit", "language": "c", "size": 20623}
{"docstring": "/**\n  * @brief USART2 Initialization Function\n  * @param None\n  * @retval None\n  */\n", "func_signal": "void\nusart_init(void)", "code": "{\n    LL_USART_InitTypeDef USART_InitStruct = {0};\n    LL_GPIO_InitTypeDef GPIO_InitStruct = {0};\n\n    /* Peripheral clock enable */\n    LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_USART2);\n    LL_IOP_GRP1_EnableClock(LL_IOP_GRP1_PERIPH_GPIOA);\n    LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_DMA1);\n\n    /*\n     * USART2 GPIO Configuration\n     *\n     * PA2   ------> USART2_TX\n     * PA3   ------> USART2_RX\n     */\n    GPIO_InitStruct.Pin = LL_GPIO_PIN_2 | LL_GPIO_PIN_3;\n    GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;\n    GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;\n    GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;\n    GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;\n    GPIO_InitStruct.Alternate = LL_GPIO_AF_1;\n    LL_GPIO_Init(GPIOA, &GPIO_InitStruct);\n\n    /* USART2 DMA Init */\n    LL_DMA_SetPeriphRequest(DMA1, LL_DMA_CHANNEL_1, LL_DMAMUX_REQ_USART2_RX);\n    LL_DMA_SetDataTransferDirection(DMA1, LL_DMA_CHANNEL_1, LL_DMA_DIRECTION_PERIPH_TO_MEMORY);\n    LL_DMA_SetChannelPriorityLevel(DMA1, LL_DMA_CHANNEL_1, LL_DMA_PRIORITY_LOW);\n    LL_DMA_SetMode(DMA1, LL_DMA_CHANNEL_1, LL_DMA_MODE_CIRCULAR);\n    LL_DMA_SetPeriphIncMode(DMA1, LL_DMA_CHANNEL_1, LL_DMA_PERIPH_NOINCREMENT);\n    LL_DMA_SetMemoryIncMode(DMA1, LL_DMA_CHANNEL_1, LL_DMA_MEMORY_INCREMENT);\n    LL_DMA_SetPeriphSize(DMA1, LL_DMA_CHANNEL_1, LL_DMA_PDATAALIGN_BYTE);\n    LL_DMA_SetMemorySize(DMA1, LL_DMA_CHANNEL_1, LL_DMA_MDATAALIGN_BYTE);\n\n    LL_DMA_SetPeriphAddress(DMA1, LL_DMA_CHANNEL_1, (uint32_t)&USART2->RDR);\n    LL_DMA_SetMemoryAddress(DMA1, LL_DMA_CHANNEL_1, (uint32_t)usart_rx_dma_buffer);\n    LL_DMA_SetDataLength(DMA1, LL_DMA_CHANNEL_1, ARRAY_LEN(usart_rx_dma_buffer));\n\n    /* Enable HT & TC interrupts */\n    LL_DMA_EnableIT_HT(DMA1, LL_DMA_CHANNEL_1);\n    LL_DMA_EnableIT_TC(DMA1, LL_DMA_CHANNEL_1);\n\n    /* DMA interrupt init */\n    NVIC_SetPriority(DMA1_Channel1_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(), 0, 0));\n    NVIC_EnableIRQ(DMA1_Channel1_IRQn);\n\n    /* Configure USART2 */\n    USART_InitStruct.PrescalerValue = LL_USART_PRESCALER_DIV1;\n    USART_InitStruct.BaudRate = 115200;\n    USART_InitStruct.DataWidth = LL_USART_DATAWIDTH_8B;\n    USART_InitStruct.StopBits = LL_USART_STOPBITS_1;\n    USART_InitStruct.Parity = LL_USART_PARITY_NONE;\n    USART_InitStruct.TransferDirection = LL_USART_DIRECTION_TX_RX;\n    USART_InitStruct.HardwareFlowControl = LL_USART_HWCONTROL_NONE;\n    USART_InitStruct.OverSampling = LL_USART_OVERSAMPLING_16;\n    LL_USART_Init(USART2, &USART_InitStruct);\n    LL_USART_SetTXFIFOThreshold(USART2, LL_USART_FIFOTHRESHOLD_1_8);\n    LL_USART_SetRXFIFOThreshold(USART2, LL_USART_FIFOTHRESHOLD_1_8);\n    LL_USART_DisableFIFO(USART2);\n    LL_USART_ConfigAsyncMode(USART2);\n    LL_USART_EnableDMAReq_RX(USART2);\n    LL_USART_EnableIT_IDLE(USART2);\n\n    /* USART interrupt */\n    NVIC_SetPriority(USART2_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(), 0, 0));\n    NVIC_EnableIRQ(USART2_IRQn);\n\n    /* Enable USART and DMA */\n    LL_DMA_EnableChannel(DMA1, LL_DMA_CHANNEL_1);\n    LL_USART_Enable(USART2);\n}", "path": "stm32-usart-uart-dma-rx-tx/projects/usart_rx_idle_line_irq_G0/Src/main.c", "commit_date": "2019-11-11 00:00:00", "repo_name": "MaJerle/stm32-usart-uart-dma-rx-tx", "stars": 1126, "license": "mit", "language": "c", "size": 20623}
{"docstring": "/**\n  * @brief This function handles Memory management fault.\n  */\n", "func_signal": "void MemManage_Handler(void)", "code": "{\n  /* USER CODE BEGIN MemoryManagement_IRQn 0 */\n\n  /* USER CODE END MemoryManagement_IRQn 0 */\n  while (1)\n  {\n    /* USER CODE BEGIN W1_MemoryManagement_IRQn 0 */\n    /* USER CODE END W1_MemoryManagement_IRQn 0 */\n  }\n  /* USER CODE BEGIN MemoryManagement_IRQn 1 */\n\n  /* USER CODE END MemoryManagement_IRQn 1 */\n}", "path": "stm32-usart-uart-dma-rx-tx/projects/usart_rx_polling_rtos_F4/Src/stm32f4xx_it.c", "commit_date": "2019-10-31 00:00:00", "repo_name": "MaJerle/stm32-usart-uart-dma-rx-tx", "stars": 1126, "license": "mit", "language": "c", "size": 20623}
{"docstring": "/*\n * See header file for description.\n */\n", "func_signal": "StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )", "code": "{\n\t/* Simulate the stack frame as it would be created by a context switch\n\tinterrupt. */\n\n\t/* Offset added to account for the way the MCU uses the stack on entry/exit\n\tof interrupts, and to ensure alignment. */\n\tpxTopOfStack--;\n\n\t*pxTopOfStack = portINITIAL_XPSR;\t/* xPSR */\n\tpxTopOfStack--;\n\t*pxTopOfStack = ( StackType_t ) pxCode;\t/* PC */\n\tpxTopOfStack--;\n\t*pxTopOfStack = ( StackType_t ) prvTaskExitError;\t/* LR */\n\n\t/* Save code space by skipping register initialisation. */\n\tpxTopOfStack -= 5;\t/* R12, R3, R2 and R1. */\n\t*pxTopOfStack = ( StackType_t ) pvParameters;\t/* R0 */\n\n\t/* A save method is being used that requires each task to maintain its\n\town exec return value. */\n\tpxTopOfStack--;\n\t*pxTopOfStack = portINITIAL_EXEC_RETURN;\n\n\tpxTopOfStack -= 8;\t/* R11, R10, R9, R8, R7, R6, R5 and R4. */\n\n\treturn pxTopOfStack;\n}", "path": "stm32-usart-uart-dma-rx-tx/middlewares/FreeRTOS/Source/portable/RVDS/ARM_CM4F/port_cm4.c", "commit_date": "2019-10-27 00:00:00", "repo_name": "MaJerle/stm32-usart-uart-dma-rx-tx", "stars": 1126, "license": "mit", "language": "c", "size": 20623}
{"docstring": "/**\n * \\brief           Process received data over UART\n * \\note            Either process them directly or copy to other bigger buffer\n * \\param[in]       data: Data to process\n * \\param[in]       len: Length in units of bytes\n */\n", "func_signal": "void\nusart_process_data(const void* data, size_t len)", "code": "{\n    const uint8_t* d = data;\n\t\n    /*\n     * This function is called on DMA TC and HT events, aswell as on UART IDLE (if enabled) line event.\n     * \n     * For the sake of this example, function does a loop-back data over UART in polling mode.\n     * Check ringbuff RX-based example for implementation with TX & RX DMA transfer.\n     */\n\t\n    for (; len > 0; --len, ++d) {\n        LL_USART_TransmitData8(USART2, *d);\n        while (!LL_USART_IsActiveFlag_TXE(USART2)) {}\n    }\n    while (!LL_USART_IsActiveFlag_TC(USART2)) {}\n}", "path": "stm32-usart-uart-dma-rx-tx/projects/usart_rx_idle_line_irq_G0/Src/main.c", "commit_date": "2019-11-11 00:00:00", "repo_name": "MaJerle/stm32-usart-uart-dma-rx-tx", "stars": 1126, "license": "mit", "language": "c", "size": 20623}
{"docstring": "/**\n  * @brief This function handles Hard fault interrupt.\n  */\n", "func_signal": "void HardFault_Handler(void)", "code": "{\n  /* USER CODE BEGIN HardFault_IRQn 0 */\n\n  /* USER CODE END HardFault_IRQn 0 */\n  while (1)\n  {\n    /* USER CODE BEGIN W1_HardFault_IRQn 0 */\n    /* USER CODE END W1_HardFault_IRQn 0 */\n  }\n  /* USER CODE BEGIN HardFault_IRQn 1 */\n\n  /* USER CODE END HardFault_IRQn 1 */\n}", "path": "stm32-usart-uart-dma-rx-tx/projects/usart_rx_polling_rtos_F4/Src/stm32f4xx_it.c", "commit_date": "2019-10-31 00:00:00", "repo_name": "MaJerle/stm32-usart-uart-dma-rx-tx", "stars": 1126, "license": "mit", "language": "c", "size": 20623}
{"docstring": "/*\n * See header file for description.\n */\n", "func_signal": "BaseType_t xPortStartScheduler( void )", "code": "{\n\t/* configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.\n\tSee http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */\n\tconfigASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );\n\n\t/* This port can be used on all revisions of the Cortex-M7 core other than\n\tthe r0p1 parts.  r0p1 parts should use the port from the\n\t/source/portable/GCC/ARM_CM7/r0p1 directory. */\n\tconfigASSERT( portCPUID != portCORTEX_M7_r0p1_ID );\n\tconfigASSERT( portCPUID != portCORTEX_M7_r0p0_ID );\n\n\t#if( configASSERT_DEFINED == 1 )\n\t{\n\t\tvolatile uint32_t ulOriginalPriority;\n\t\tvolatile uint8_t * const pucFirstUserPriorityRegister = ( uint8_t * ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );\n\t\tvolatile uint8_t ucMaxPriorityValue;\n\n\t\t/* Determine the maximum priority from which ISR safe FreeRTOS API\n\t\tfunctions can be called.  ISR safe functions are those that end in\n\t\t\"FromISR\".  FreeRTOS maintains separate thread and ISR API functions to\n\t\tensure interrupt entry is as fast and simple as possible.\n\n\t\tSave the interrupt priority value that is about to be clobbered. */\n\t\tulOriginalPriority = *pucFirstUserPriorityRegister;\n\n\t\t/* Determine the number of priority bits available.  First write to all\n\t\tpossible bits. */\n\t\t*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;\n\n\t\t/* Read the value back to see how many bits stuck. */\n\t\tucMaxPriorityValue = *pucFirstUserPriorityRegister;\n\n\t\t/* The kernel interrupt priority should be set to the lowest\n\t\tpriority. */\n\t\tconfigASSERT( ucMaxPriorityValue == ( configKERNEL_INTERRUPT_PRIORITY & ucMaxPriorityValue ) );\n\n\t\t/* Use the same mask on the maximum system call priority. */\n\t\tucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;\n\n\t\t/* Calculate the maximum acceptable priority group value for the number\n\t\tof bits read back. */\n\t\tulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;\n\t\twhile( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )\n\t\t{\n\t\t\tulMaxPRIGROUPValue--;\n\t\t\tucMaxPriorityValue <<= ( uint8_t ) 0x01;\n\t\t}\n\n\t\t/* Shift the priority group value back to its position within the AIRCR\n\t\tregister. */\n\t\tulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;\n\t\tulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;\n\n\t\t/* Restore the clobbered interrupt priority register to its original\n\t\tvalue. */\n\t\t*pucFirstUserPriorityRegister = ulOriginalPriority;\n\t}\n\t#endif /* conifgASSERT_DEFINED */\n\n\t/* Make PendSV and SysTick the lowest priority interrupts. */\n\tportNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;\n\tportNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;\n\n\t/* Start the timer that generates the tick ISR.  Interrupts are disabled\n\there already. */\n\tvPortSetupTimerInterrupt();\n\n\t/* Initialise the critical nesting count ready for the first task. */\n\tuxCriticalNesting = 0;\n\n\t/* Ensure the VFP is enabled - it should be anyway. */\n\tprvEnableVFP();\n\n\t/* Lazy save always. */\n\t*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;\n\n\t/* Start the first task. */\n\tprvStartFirstTask();\n\n\t/* Should not get here! */\n\treturn 0;\n}", "path": "stm32-usart-uart-dma-rx-tx/middlewares/FreeRTOS/Source/portable/RVDS/ARM_CM4F/port_cm4.c", "commit_date": "2019-10-27 00:00:00", "repo_name": "MaJerle/stm32-usart-uart-dma-rx-tx", "stars": 1126, "license": "mit", "language": "c", "size": 20623}
{"docstring": "/**\n  * @brief This function handles System tick timer.\n  */\n", "func_signal": "void SysTick_Handler(void)", "code": "{\n    extern void xPortSysTickHandler(void);\n    xPortSysTickHandler();\n}", "path": "stm32-usart-uart-dma-rx-tx/projects/usart_rx_polling_rtos_F4/Src/stm32f4xx_it.c", "commit_date": "2019-10-31 00:00:00", "repo_name": "MaJerle/stm32-usart-uart-dma-rx-tx", "stars": 1126, "license": "mit", "language": "c", "size": 20623}
{"docstring": "/**\n  * @brief This function handles Hard fault interrupt.\n  */\n", "func_signal": "void HardFault_Handler(void)", "code": "{\n  /* USER CODE BEGIN HardFault_IRQn 0 */\n\n  /* USER CODE END HardFault_IRQn 0 */\n  while (1)\n  {\n    /* USER CODE BEGIN W1_HardFault_IRQn 0 */\n    /* USER CODE END W1_HardFault_IRQn 0 */\n  }\n  /* USER CODE BEGIN HardFault_IRQn 1 */\n\n  /* USER CODE END HardFault_IRQn 1 */\n}", "path": "stm32-usart-uart-dma-rx-tx/projects/usart_rx_idle_line_irq_F4/Src/stm32f4xx_it.c", "commit_date": "2019-10-31 00:00:00", "repo_name": "MaJerle/stm32-usart-uart-dma-rx-tx", "stars": 1126, "license": "mit", "language": "c", "size": 20623}
{"docstring": "/**\n  * @brief This function handles Memory management fault.\n  */\n", "func_signal": "void MemManage_Handler(void)", "code": "{\n  /* USER CODE BEGIN MemoryManagement_IRQn 0 */\n\n  /* USER CODE END MemoryManagement_IRQn 0 */\n  while (1)\n  {\n    /* USER CODE BEGIN W1_MemoryManagement_IRQn 0 */\n    /* USER CODE END W1_MemoryManagement_IRQn 0 */\n  }\n  /* USER CODE BEGIN MemoryManagement_IRQn 1 */\n\n  /* USER CODE END MemoryManagement_IRQn 1 */\n}", "path": "stm32-usart-uart-dma-rx-tx/projects/usart_rx_idle_line_irq_F4/Src/stm32f4xx_it.c", "commit_date": "2019-10-31 00:00:00", "repo_name": "MaJerle/stm32-usart-uart-dma-rx-tx", "stars": 1126, "license": "mit", "language": "c", "size": 20623}
{"docstring": "/**\n * \\brief           USART3 global interrupt handler\n */\n", "func_signal": "void\nUSART2_IRQHandler(void)", "code": "{\n    /* Check for IDLE line interrupt */\n    if (LL_USART_IsEnabledIT_IDLE(USART2) && LL_USART_IsActiveFlag_IDLE(USART2)) {\n        LL_USART_ClearFlag_IDLE(USART2);        /* Clear IDLE line flag */\n        usart_rx_check();                       /* Check for data to process */\n    }\n\n    /* Implement other events when needed */\n}", "path": "stm32-usart-uart-dma-rx-tx/projects/usart_rx_idle_line_irq_G0/Src/main.c", "commit_date": "2019-11-11 00:00:00", "repo_name": "MaJerle/stm32-usart-uart-dma-rx-tx", "stars": 1126, "license": "mit", "language": "c", "size": 20623}
{"docstring": "/**\n* @brief This function handles Prefetch fault, memory access fault.\n*/\n", "func_signal": "void BusFault_Handler(void)", "code": "{\n  /* USER CODE BEGIN BusFault_IRQn 0 */\n\n  /* USER CODE END BusFault_IRQn 0 */\n  while (1)\n  {\n    /* USER CODE BEGIN W1_BusFault_IRQn 0 */\n    /* USER CODE END W1_BusFault_IRQn 0 */\n  }\n  /* USER CODE BEGIN BusFault_IRQn 1 */\n\n  /* USER CODE END BusFault_IRQn 1 */\n}", "path": "stm32-usart-uart-dma-rx-tx/projects/usart_rx_idle_line_irq_F1/Src/stm32f1xx_it.c", "commit_date": "2019-10-31 00:00:00", "repo_name": "MaJerle/stm32-usart-uart-dma-rx-tx", "stars": 1126, "license": "mit", "language": "c", "size": 20623}
{"docstring": "/**\n  * @brief This function handles Pre-fetch fault, memory access fault.\n  */\n", "func_signal": "void BusFault_Handler(void)", "code": "{\n  /* USER CODE BEGIN BusFault_IRQn 0 */\n\n  /* USER CODE END BusFault_IRQn 0 */\n  while (1)\n  {\n    /* USER CODE BEGIN W1_BusFault_IRQn 0 */\n    /* USER CODE END W1_BusFault_IRQn 0 */\n  }\n  /* USER CODE BEGIN BusFault_IRQn 1 */\n\n  /* USER CODE END BusFault_IRQn 1 */\n}", "path": "stm32-usart-uart-dma-rx-tx/projects/usart_rx_idle_line_irq_F4/Src/stm32f4xx_it.c", "commit_date": "2019-10-31 00:00:00", "repo_name": "MaJerle/stm32-usart-uart-dma-rx-tx", "stars": 1126, "license": "mit", "language": "c", "size": 20623}
{"docstring": "/**\n* @brief This function handles Hard fault interrupt.\n*/\n", "func_signal": "void HardFault_Handler(void)", "code": "{\n  /* USER CODE BEGIN HardFault_IRQn 0 */\n\n  /* USER CODE END HardFault_IRQn 0 */\n  while (1)\n  {\n    /* USER CODE BEGIN W1_HardFault_IRQn 0 */\n    /* USER CODE END W1_HardFault_IRQn 0 */\n  }\n  /* USER CODE BEGIN HardFault_IRQn 1 */\n\n  /* USER CODE END HardFault_IRQn 1 */\n}", "path": "stm32-usart-uart-dma-rx-tx/projects/usart_rx_idle_line_irq_F1/Src/stm32f1xx_it.c", "commit_date": "2019-10-31 00:00:00", "repo_name": "MaJerle/stm32-usart-uart-dma-rx-tx", "stars": 1126, "license": "mit", "language": "c", "size": 20623}
{"docstring": "/**\n  * @brief This function handles Undefined instruction or illegal state.\n  */\n", "func_signal": "void UsageFault_Handler(void)", "code": "{\n  /* USER CODE BEGIN UsageFault_IRQn 0 */\n\n  /* USER CODE END UsageFault_IRQn 0 */\n  while (1)\n  {\n    /* USER CODE BEGIN W1_UsageFault_IRQn 0 */\n    /* USER CODE END W1_UsageFault_IRQn 0 */\n  }\n  /* USER CODE BEGIN UsageFault_IRQn 1 */\n\n  /* USER CODE END UsageFault_IRQn 1 */\n}", "path": "stm32-usart-uart-dma-rx-tx/projects/usart_rx_polling_rtos_F4/Src/stm32f4xx_it.c", "commit_date": "2019-10-31 00:00:00", "repo_name": "MaJerle/stm32-usart-uart-dma-rx-tx", "stars": 1126, "license": "mit", "language": "c", "size": 20623}
{"docstring": "/* Returns 1 if the first n bits of a and b are equal */\n", "func_signal": "static int\nbitmatch(const unsigned char *a, const unsigned char *b, int n)", "code": "{\n    if(n >= 8) {\n        if(memcmp(a, b, n / 8) != 0)\n            return 0;\n    }\n\n    if(n % 8 != 0) {\n        int mask = (~0) << (8 - n % 8);\n        if((a[n / 8] & mask) != (b[n / 8] & mask))\n            return 0;\n    }\n\n    return 1;\n}", "path": "polipo/io.c", "commit_date": "2015-08-19 00:00:00", "repo_name": "jech/polipo", "stars": 1790, "license": "mit", "language": "c", "size": 1588}
{"docstring": "/* Assumes the file descriptor is at offset 0.  Returns -1 on failure,\n   otherwise the offset at which the file descriptor is left. */\n/* If chunk is not null, it should be the first chunk of the object,\n   and will be written out in the same operation if possible. */\n", "func_signal": "static int\nwriteHeaders(int fd, int *body_offset_return,\n             ObjectPtr object, char *chunk, int chunk_len)", "code": "{\n    int n, rc, error = -1;\n    int body_offset = *body_offset_return;\n    char *buf = NULL;\n    int buf_is_chunk = 0;\n    int bufsize = 0;\n\n    if(object->flags & OBJECT_LOCAL)\n        return -1;\n\n    if(body_offset > CHUNK_SIZE)\n        goto overflow;\n\n    /* get_chunk might trigger object expiry */\n    bufsize = CHUNK_SIZE;\n    buf_is_chunk = 1;\n    buf = maybe_get_chunk();\n    if(!buf) {\n        bufsize = 2048;\n        buf_is_chunk = 0;\n        buf = malloc(2048);\n        if(buf == NULL) {\n            do_log(L_ERROR, \"Couldn't allocate buffer.\\n\");\n            return -1;\n        }\n    }\n\n format_again:\n    n = snnprintf(buf, 0, bufsize, \"HTTP/1.1 %3d %s\",\n                  object->code, object->message->string);\n\n    n = httpWriteObjectHeaders(buf, n, bufsize, object, 0, -1);\n    if(n < 0)\n        goto overflow;\n\n    n = snnprintf(buf, n, bufsize, \"\\r\\nX-Polipo-Location: \");\n    n = snnprint_n(buf, n, bufsize, object->key, object->key_size);\n\n    if(object->age >= 0 && object->age != object->date) {\n        n = snnprintf(buf, n, bufsize, \"\\r\\nX-Polipo-Date: \");\n        n = format_time(buf, n, bufsize, object->age);\n    }\n\n    if(object->atime >= 0) {\n        n = snnprintf(buf, n, bufsize, \"\\r\\nX-Polipo-Access: \");\n        n = format_time(buf, n, bufsize, object->atime);\n    }\n\n    if(n < 0)\n        goto overflow;\n\n    if(body_offset < 0)\n        body_offset = chooseBodyOffset(n, object);\n\n    if(body_offset > bufsize)\n        goto overflow;\n\n    if(body_offset > 0 && body_offset != n + 4)\n        n = snnprintf(buf, n, bufsize, \"\\r\\nX-Polipo-Body-Offset: %d\",\n                      body_offset);\n\n    n = snnprintf(buf, n, bufsize, \"\\r\\n\\r\\n\");\n    if(n < 0)\n        goto overflow;\n\n    if(body_offset < 0)\n        body_offset = n;\n    if(n > body_offset) {\n        error = -2;\n        goto fail;\n    }\n\n    if(n < body_offset)\n        memset(buf + n, 0, body_offset - n);\n\n again:\n#ifdef HAVE_READV_WRITEV\n    if(chunk_len > 0) {\n        struct iovec iov[2];\n        iov[0].iov_base = buf;\n        iov[0].iov_len = body_offset;\n        iov[1].iov_base = chunk;\n        iov[1].iov_len = chunk_len;\n        rc = writev(fd, iov, 2);\n    } else\n#endif\n        rc = write(fd, buf, body_offset);\n\n    if(rc < 0 && errno == EINTR)\n        goto again;\n\n    if(rc < body_offset)\n        goto fail;\n    if(object->length >= 0 && \n       rc - body_offset >= object->length)\n        object->flags |= OBJECT_DISK_ENTRY_COMPLETE;\n\n    *body_offset_return = body_offset;\n    if(buf_is_chunk)\n        dispose_chunk(buf);\n    else\n        free(buf);\n    return rc;\n\n overflow:\n    if(bufsize < bigBufferSize) {\n        char *oldbuf = buf;\n        buf = malloc(bigBufferSize);\n        if(!buf) {\n            do_log(L_ERROR, \"Couldn't allocate big buffer.\\n\");\n            goto fail;\n        }\n        bufsize = bigBufferSize;\n        if(oldbuf) {\n            if(buf_is_chunk)\n                dispose_chunk(oldbuf);\n            else\n                free(oldbuf);\n        }\n        buf_is_chunk = 0;\n        goto format_again;\n    }\n    /* fall through */\n\n fail:\n    if(buf_is_chunk)\n        dispose_chunk(buf);\n    else\n        free(buf);\n    return error;\n}", "path": "polipo/diskcache.c", "commit_date": "2014-10-12 00:00:00", "repo_name": "jech/polipo", "stars": 1790, "license": "mit", "language": "c", "size": 1588}
{"docstring": "/* Translate a Polipo error type into a syslog priority. */\n", "func_signal": "static int\ntranslatePriority(int type)", "code": "{\n    typedef struct\n    {\n        int type;\n        int priority;\n    } PrioritiesRec;\n\n    /* The list is terminated with a type of zero. */\n\n    PrioritiesRec priorities[] = {{ L_ERROR, LOG_ERR },\n                                  { L_WARN, LOG_WARNING },\n                                  { L_INFO, LOG_NOTICE },\n                                  { L_FORBIDDEN, LOG_DEBUG },\n                                  { L_UNCACHEABLE, LOG_DEBUG },\n                                  { L_SUPERSEDED, LOG_DEBUG },\n                                  { L_VARY, LOG_DEBUG },\n                                  { L_TUNNEL, LOG_NOTICE },\n                                  { 0, 0 }};\n    PrioritiesRec *current;\n\n    current = priorities;\n    while(current->type) {\n        if(current->type == type) {\n            return current->priority;\n        }\n        current++;\n    }\n\n    return LOG_DEBUG;\n}", "path": "polipo/log.c", "commit_date": "2014-01-11 00:00:00", "repo_name": "jech/polipo", "stars": 1790, "license": "mit", "language": "c", "size": 1588}
{"docstring": "/* floor(log2(x)) */\n", "func_signal": "int\nlog2_floor(int x)", "code": "{\n    int i, j;\n\n    assert(x > 0);\n\n    i = 0;\n    j = 1;\n    while(2 * j <= x) {\n        i++;\n        j *= 2;\n    }\n    return i;\n}", "path": "polipo/util.c", "commit_date": "2015-06-25 00:00:00", "repo_name": "jech/polipo", "stars": 1790, "license": "mit", "language": "c", "size": 1588}
{"docstring": "/* Check whether a character can be stored in a filename.  This is\n   needed since we want to support deficient file systems. */\n", "func_signal": "static int\nfssafe(char c)", "code": "{\n    if(c <= 31 || c >= 127)\n        return 0;\n    if((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||\n       (c >= '0' && c <= '9') ||  c == '.' || c == '-' || c == '_')\n        return 1;\n    return 0;\n}", "path": "polipo/diskcache.c", "commit_date": "2014-10-12 00:00:00", "repo_name": "jech/polipo", "stars": 1790, "license": "mit", "language": "c", "size": 1588}
{"docstring": "/* Determine whether p is below root */\n", "func_signal": "static int\nfilter(DiskObjectPtr p, const char *root, int n, int recursive)", "code": "{\n    char *cp;\n    int m = strlen(p->location);\n    if(m < n)\n        return 0;\n    if(memcmp(root, p->location, n) != 0)\n        return 0;\n    if(recursive)\n        return 1;\n    if(m == 0 || p->location[m - 1] == '/')\n        return 1;\n    cp = strchr(p->location + n, '/');\n    if(cp && cp - p->location != m - 1)\n        return 0;\n    return 1;\n}", "path": "polipo/diskcache.c", "commit_date": "2014-10-12 00:00:00", "repo_name": "jech/polipo", "stars": 1790, "license": "mit", "language": "c", "size": 1588}
{"docstring": "/* This may be called from object handlers. */\n", "func_signal": "int\nhttpClientLeanError(HTTPRequestPtr request, int code, AtomPtr message)", "code": "{\n    if(request->error_message)\n        releaseAtom(request->error_message);\n    request->error_code = code;\n    request->error_message = message;\n    return 1;\n}", "path": "polipo/client.c", "commit_date": "2016-01-30 00:00:00", "repo_name": "jech/polipo", "stars": 1790, "license": "mit", "language": "c", "size": 1588}
{"docstring": "/* ceil(log2(x)) */\n", "func_signal": "int\nlog2_ceil(int x)", "code": "{\n    int i, j;\n\n    assert(x > 0);\n\n    i = 0;\n    j = 1;\n    while(j < x) {\n        i++;\n        j *= 2;\n    }\n    return i;\n}", "path": "polipo/util.c", "commit_date": "2015-06-25 00:00:00", "repo_name": "jech/polipo", "stars": 1790, "license": "mit", "language": "c", "size": 1588}
{"docstring": "/* Given a local URL, constructs the filename where it can be found. */\n", "func_signal": "int\nlocalFilename(char *buf, int n, char *key, int len)", "code": "{\n    int i, j;\n    if(len <= 0 || key[0] != '/') return -1;\n\n    if(urlIsSpecial(key, len)) return -1;\n\n    if(checkRoot(localDocumentRoot) <= 0)\n        return -1;\n\n    if(n <= localDocumentRoot->length)\n        return -1;\n\n    i = 0;\n    if(key[i] != '/')\n        return -1;\n\n    memcpy(buf, localDocumentRoot->string, localDocumentRoot->length);\n    j = localDocumentRoot->length;\n    if(buf[j - 1] == '/')\n        j--;\n\n    while(i < len) {\n        if(j >= n - 1)\n            return -1;\n        if(key[i] == '/' && i < len - 2)\n            if(key[i + 1] == '.' && \n               (key[i + 2] == '.' || key[i + 2] == '/'))\n                return -1;\n        buf[j++] = key[i++];\n    }\n\n    if(buf[j - 1] == '/') {\n        if(j >= n - 11)\n            return -1;\n        memcpy(buf + j, \"index.html\", 10);\n        j += 10;\n    }\n\n    buf[j] = '\\0';\n    return j;\n}", "path": "polipo/diskcache.c", "commit_date": "2014-10-12 00:00:00", "repo_name": "jech/polipo", "stars": 1790, "license": "mit", "language": "c", "size": 1588}
{"docstring": "/* Flush any messages waiting to be logged. */\n", "func_signal": "void flushLog()", "code": "{\n    if(logF)\n        fflush(logF);\n\n#ifdef HAVE_SYSLOG\n    /* There shouldn't really be anything here, but let's be paranoid.\n       We can't pick a good value for `type', so just invent one. */\n    if(logSyslog && syslogBuf[0] != '\\0') {\n        accumulateSyslogN(L_INFO, \"\\n\", 1);\n    }\n\n    assert(syslogBufLength == 0);\n#endif\n}", "path": "polipo/log.c", "commit_date": "2014-01-11 00:00:00", "repo_name": "jech/polipo", "stars": 1790, "license": "mit", "language": "c", "size": 1588}
{"docstring": "/* Taken from the Linux timegm(3) man page. */\n", "func_signal": "time_t\nmktime_gmt(struct tm *tm)", "code": "{\n    time_t t;\n    char *tz;\n\n    tz = getenv(\"TZ\");\n    setenv(\"TZ\", \"GMT\", 1);\n    tzset();\n    t = mktime(tm);\n    if(tz)\n        setenv(\"TZ\", tz, 1);\n    else\n        unsetenv(\"TZ\");\n    tzset();\n    return t;\n}", "path": "polipo/util.c", "commit_date": "2015-06-25 00:00:00", "repo_name": "jech/polipo", "stars": 1790, "license": "mit", "language": "c", "size": 1588}
{"docstring": "/* Returns 1 if the address in data is in list */\n", "func_signal": "static int\nmatch(int af, unsigned char *data, NetAddressPtr list)", "code": "{\n    int i;\n#ifdef HAVE_IPv6\n    static const unsigned char v6mapped[] =\n        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF };\n#endif\n\n    i = 0;\n    while(list[i].af != 0) {\n        if(af == 4 && list[i].af == 4) {\n            if(bitmatch(data, list[i].data,\n                        list[i].prefix >= 0 ? list[i].prefix : 32))\n                return 1;\n#ifdef HAVE_IPv6\n        } else if(af == 6 && list[i].af == 6) {\n            if(bitmatch(data, list[i].data,\n                        list[i].prefix >= 0 ? list[i].prefix : 128))\n                return 1;\n        } else if(af == 6 && list[i].af == 4) {\n            if(bitmatch(data, v6mapped, 96)) {\n                if(bitmatch(data + 12, list[i].data,\n                            list[i].prefix >= 0 ? list[i].prefix : 32))\n                    return 1;\n            }\n        } else if(af == 4 && list[i].af == 6) {\n            if(bitmatch(list[i].data, v6mapped, 96)) {\n                if(bitmatch(data, list[i].data + 12,\n                            list[i].prefix >= 96 ?\n                            list[i].prefix - 96 : 32))\n                    return 1;\n            }\n#endif\n        } else {\n            abort();\n        }\n        i++;\n    }\n    return 0;\n}", "path": "polipo/io.c", "commit_date": "2015-08-19 00:00:00", "repo_name": "jech/polipo", "stars": 1790, "license": "mit", "language": "c", "size": 1588}
{"docstring": "/* Same interface as validateEntry -- see below */\n", "func_signal": "int\nvalidateLocalEntry(ObjectPtr object, int fd,\n                   int *body_offset_return, off_t *offset_return)", "code": "{\n    struct stat ss;\n    char buf[512];\n    int n, rc;\n    char *encoding;\n\n    rc = fstat(fd, &ss);\n    if(rc < 0) {\n        do_log_error(L_ERROR, errno, \"Couldn't stat\");\n        return -1;\n    }\n\n    if(S_ISREG(ss.st_mode)) {\n        if(!(ss.st_mode & S_IROTH) ||\n           (object->length >= 0 && object->length != ss.st_size) ||\n           (object->last_modified >= 0 && \n            object->last_modified != ss.st_mtime))\n            return -1;\n    } else {\n        notifyObject(object);\n        return -1;\n    }\n    \n    n = snnprintf(buf, 0, 512, \"%lx-%lx-%lx\",\n                  (unsigned long)ss.st_ino,\n                  (unsigned long)ss.st_size,\n                  (unsigned long)ss.st_mtime);\n    if(n >= 512)\n        n = -1;\n\n    if(n > 0 && object->etag) {\n        if(strlen(object->etag) != n ||\n           memcmp(object->etag, buf, n) != 0)\n            return -1;\n    }\n\n    if(!(object->flags & OBJECT_INITIAL)) {\n        if(!object->last_modified && !object->etag)\n            return -1;\n    }\n       \n    if(object->flags & OBJECT_INITIAL) {\n        object->length = ss.st_size;\n        object->last_modified = ss.st_mtime;\n        object->date = current_time.tv_sec;\n        object->age = current_time.tv_sec;\n        object->code = 200;\n        if(n > 0)\n            object->etag = strdup(buf); /* okay if fails */\n        object->message = internAtom(\"Okay\");\n        n = snnprintf(buf, 0, 512,\n                      \"\\r\\nServer: Polipo\"\n                      \"\\r\\nContent-Type: %s\",\n                      localObjectMimeType(object, &encoding));\n        if(encoding != NULL)\n            n = snnprintf(buf, n, 512,\n                          \"\\r\\nContent-Encoding: %s\", encoding);\n        if(n < 0)\n            return -1;\n        object->headers = internAtomN(buf, n);\n        if(object->headers == NULL)\n            return -1;\n        object->flags &= ~OBJECT_INITIAL;\n    }\n\n    if(body_offset_return)\n        *body_offset_return = 0;\n    if(offset_return)\n        *offset_return = 0;\n    return 0;\n}", "path": "polipo/diskcache.c", "commit_date": "2014-10-12 00:00:00", "repo_name": "jech/polipo", "stars": 1790, "license": "mit", "language": "c", "size": 1588}
{"docstring": "/* Given a URL, returns the directory name within which all files\n   starting with this URL can be found. */\n", "func_signal": "static int\nurlDirname(char *buf, int n, const char *url, int len)", "code": "{\n    int i, j;\n    if(len < 8)\n        return -1;\n    if(lwrcmp(url, \"http://\", 7) != 0)\n        return -1;\n\n    if(checkRoot(diskCacheRoot) <= 0)\n        return -1;\n\n    if(n <= diskCacheRoot->length)\n        return -1;\n\n    memcpy(buf, diskCacheRoot->string, diskCacheRoot->length);\n    j = diskCacheRoot->length;\n\n    if(buf[j - 1] != '/')\n        buf[j++] = '/';\n\n    for(i = 7; i < len; i++) {\n        if(i >= len || url[i] == '/')\n            break;\n        if(url[i] == '.' && i != len - 1 && url[i + 1] == '.')\n            return -1;\n        if(url[i] == '%' || !fssafe(url[i])) {\n            if(j + 3 >= n) return -1;\n            buf[j++] = '%';\n            buf[j++] = i2h((url[i] & 0xF0) >> 4);\n            buf[j++] = i2h(url[i] & 0x0F);\n        } else {\n            buf[j++] = url[i]; if(j >= n) return -1;\n        }\n    }\n    buf[j++] = '/'; if(j >= n) return -1;\n    buf[j] = '\\0';\n    return j;\n}", "path": "polipo/diskcache.c", "commit_date": "2014-10-12 00:00:00", "repo_name": "jech/polipo", "stars": 1790, "license": "mit", "language": "c", "size": 1588}
{"docstring": "/* Insert all missing directories in a sorted list of dobjects */\n", "func_signal": "DiskObjectPtr\ninsertDirs(DiskObjectPtr from)", "code": "{\n    DiskObjectPtr p, q, new;\n    int n, m;\n    char *cp;\n\n    p = NULL; q = from;\n    while(q) {\n        n = strlen(q->location);\n        if(n > 0 && q->location[n - 1] != '/') {\n            cp = strrchr(q->location, '/');\n            m = cp - q->location + 1;\n            if(cp && (!p || strlen(p->location) < m ||\n                      memcmp(p->location, q->location, m) != 0)) {\n                new = malloc(sizeof(DiskObjectRec));\n                if(!new) break;\n                new->location = strdup_n(q->location, m);\n                if(new->location == NULL) {\n                    free(new);\n                    break;\n                }\n                new->filename = NULL;\n                new->length = -1;\n                new->size = -1;\n                new->age = -1;\n                new->access = -1;\n                new->last_modified = -1;\n                new->expires = -1;\n                new->next = q;\n                if(p)\n                    p->next = new;\n                else\n                    from = new;\n            }\n        }\n        p = q;\n        q = q->next;\n    }\n    return from;\n}", "path": "polipo/diskcache.c", "commit_date": "2014-10-12 00:00:00", "repo_name": "jech/polipo", "stars": 1790, "license": "mit", "language": "c", "size": 1588}
{"docstring": "/* Create a file and all intermediate directories. */\n", "func_signal": "static int\ncreateFile(const char *name, int path_start)", "code": "{\n    int fd;\n    char buf[1024];\n    int n;\n    int rc;\n\n    if(name[path_start] == '/')\n        path_start++;\n\n    if(path_start < 2 || name[path_start - 1] != '/' ) {\n        do_log(L_ERROR, \"Incorrect name %s (%d).\\n\", name, path_start);\n        return -1;\n    }\n\n    fd = open(name, O_RDWR | O_CREAT | O_EXCL | O_BINARY,\n\t      diskCacheFilePermissions);\n    if(fd >= 0)\n        return fd;\n    if(errno != ENOENT) {\n        do_log_error(L_ERROR, errno, \"Couldn't create disk file %s\", name);\n        return -1;\n    }\n    \n    n = path_start;\n    while(name[n] != '\\0' && n < 1024) {\n        while(name[n] != '/' && name[n] != '\\0' && n < 512)\n            n++;\n        if(name[n] != '/' || n >= 1024)\n            break;\n        memcpy(buf, name, n + 1);\n        buf[n + 1] = '\\0';\n        rc = mkdir(buf, diskCacheDirectoryPermissions);\n        if(rc < 0 && errno != EEXIST) {\n            do_log_error(L_ERROR, errno, \"Couldn't create directory %s\", buf);\n            return -1;\n        }\n        n++;\n    }\n    fd = open(name, O_RDWR | O_CREAT | O_EXCL | O_BINARY,\n\t      diskCacheFilePermissions);\n    if(fd < 0) {\n        do_log_error(L_ERROR, errno, \"Couldn't create file %s\", name);\n        return -1;\n    }\n\n    return fd;\n}", "path": "polipo/diskcache.c", "commit_date": "2014-10-12 00:00:00", "repo_name": "jech/polipo", "stars": 1790, "license": "mit", "language": "c", "size": 1588}
{"docstring": "/* Note that this is different from GNU's strndup(3). */\n", "func_signal": "char *\nstrdup_n(const char *restrict buf, int n)", "code": "{\n    char *s;\n    s = malloc(n + 1);\n    if(s == NULL)\n        return NULL;\n    memcpy(s, buf, n);\n    s[n] = '\\0';\n    return s;\n}", "path": "polipo/util.c", "commit_date": "2015-06-25 00:00:00", "repo_name": "jech/polipo", "stars": 1790, "license": "mit", "language": "c", "size": 1588}
{"docstring": "/* Rewrite a disk cache entry, used when the body offset needs to change. */\n", "func_signal": "static int\nrewriteEntry(ObjectPtr object)", "code": "{\n    int old_body_offset = object->disk_entry->body_offset;\n    int fd, rc, n;\n    DiskCacheEntryPtr entry;\n    char* buf;\n    int buf_is_chunk, bufsize;\n    int offset;\n\n    fd = dup(object->disk_entry->fd);\n    if(fd < 0) {\n        do_log_error(L_ERROR, errno, \"Couldn't duplicate file descriptor\");\n        return -1;\n    }\n\n    rc = destroyDiskEntry(object, 1);\n    if(rc < 0) {\n        close(fd);\n        return -1;\n    }\n    entry = makeDiskEntry(object, 1);\n    if(!entry) {\n        close(fd);\n        return -1;\n    }\n\n    offset = diskEntrySize(object);\n    if(offset < 0) {\n        close(fd);\n        return -1;\n    }\n\n    bufsize = CHUNK_SIZE;\n    buf_is_chunk = 1;\n    buf = maybe_get_chunk();\n    if(!buf) {\n        bufsize = 2048;\n        buf_is_chunk = 0;\n        buf = malloc(2048);\n        if(buf == NULL) {\n            do_log(L_ERROR, \"Couldn't allocate buffer.\\n\");\n            close(fd);\n            return -1;\n        }\n    }\n\n    rc = lseek(fd, old_body_offset + offset, SEEK_SET);\n    if(rc < 0)\n        goto done;\n\n    while(1) {\n        CHECK_ENTRY(entry);\n        n = read(fd, buf, bufsize);\n        if(n < 0 && errno == EINTR)\n            continue;\n        if(n <= 0)\n            goto done;\n        rc = entrySeek(entry, entry->body_offset + offset);\n        if(rc < 0)\n            goto done;\n    write_again:\n        rc = write(entry->fd, buf, n);\n        if(rc >= 0) {\n            entry->offset += rc;\n            entry->size += rc;\n        } else if(errno == EINTR) {\n            goto write_again;\n        }\n        if(rc < n)\n            goto done;\n    }\n\n done:\n    CHECK_ENTRY(entry);\n    if(object->length >= 0 && entry->size == object->length)\n        object->flags |= OBJECT_DISK_ENTRY_COMPLETE;\n    close(fd);\n    if(buf_is_chunk)\n        dispose_chunk(buf);\n    else\n        free(buf);\n    return 1;\n}", "path": "polipo/diskcache.c", "commit_date": "2014-10-12 00:00:00", "repo_name": "jech/polipo", "stars": 1790, "license": "mit", "language": "c", "size": 1588}
{"docstring": "/* Abort a client connection.  It is only safe to abort the requests\n   if we know the connection is closed. */\n", "func_signal": "void\nhttpClientAbort(HTTPConnectionPtr connection, int closed)", "code": "{\n    HTTPRequestPtr request = connection->request;\n\n    pokeFdEvent(connection->fd, -EDOSHUTDOWN, POLLOUT);\n    if(closed) {\n        while(request) {\n            if(request->chandler) {\n                request->error_code = 500;\n                request->error_message = internAtom(\"Connection finishing\");\n                abortConditionHandler(request->chandler);\n                request->chandler = NULL;\n            }\n            request = request->next;\n        }\n    }\n}", "path": "polipo/client.c", "commit_date": "2016-01-30 00:00:00", "repo_name": "jech/polipo", "stars": 1790, "license": "mit", "language": "c", "size": 1588}
{"docstring": "/* Map a user-provided name to a syslog facility.\n\n   This is rendered quite ugly because POSIX hardly defines any, but we\n   should allow any the local system knows about. */\n", "func_signal": "static int\ntranslateFacility(AtomPtr facility)", "code": "{\n    typedef struct\n    {\n        const char *name;\n        int facility;\n    } FacilitiesRec;\n\n    /* List of all known valid syslog facilities.\n\n       This list is terminated by a NULL facility name. */\n\n    FacilitiesRec facilities[] = {\n        /* These are all the facilities found in glibc 2.5. */\n#ifdef LOG_AUTH\n        { \"auth\", LOG_AUTH },\n#endif\n#ifdef LOG_AUTHPRIV\n        { \"authpriv\", LOG_AUTHPRIV },\n#endif\n#ifdef LOG_CRON\n        { \"cron\", LOG_CRON },\n#endif\n#ifdef LOG_DAEMON\n        { \"daemon\", LOG_DAEMON },\n#endif\n#ifdef LOG_FTP\n        { \"ftp\", LOG_FTP },\n#endif\n#ifdef LOG_KERN\n        { \"kern\", LOG_KERN },\n#endif\n#ifdef LOG_LPR\n        { \"lpr\", LOG_LPR },\n#endif\n#ifdef LOG_MAIL\n        { \"mail\", LOG_MAIL },\n#endif\n#ifdef LOG_NEWS\n        { \"news\", LOG_NEWS },\n#endif\n#ifdef LOG_SYSLOG\n        { \"syslog\", LOG_SYSLOG },\n#endif\n#ifdef LOG_uucp\n        { \"uucp\", LOG_UUCP },\n#endif\n        /* These are required by POSIX. */\n        { \"user\", LOG_USER },\n        { \"local0\", LOG_LOCAL0 },\n        { \"local1\", LOG_LOCAL1 },\n        { \"local2\", LOG_LOCAL2 },\n        { \"local3\", LOG_LOCAL3 },\n        { \"local4\", LOG_LOCAL4 },\n        { \"local5\", LOG_LOCAL5 },\n        { \"local6\", LOG_LOCAL6 },\n        { \"local7\", LOG_LOCAL7 },\n        { NULL, 0 }};\n\n    FacilitiesRec *current;\n\n    /* It would be more fitting to return LOG_DAEMON, but POSIX does not\n       guarantee the existence of that facility. */\n\n    if(!facility) {\n        return LOG_USER;\n    }\n\n    current = facilities;\n    while(current->name) {\n        if(!strcmp(current->name, atomString(facility))) {\n            return current->facility;\n        }\n        current++;\n    }\n\n    /* This will go to stderr because syslog is not yet initialized. */\n    do_log(L_ERROR, \"Specified logFacility %s nonexistent on this system.\",\n           atomString(facility));\n\n    return LOG_USER;\n}", "path": "polipo/log.c", "commit_date": "2014-01-11 00:00:00", "repo_name": "jech/polipo", "stars": 1790, "license": "mit", "language": "c", "size": 1588}
{"docstring": "/***********************************************************************\n* flip finished frame into paused ps3-framebuffer\n***********************************************************************/\n", "func_signal": "void flip_frame()", "code": "{\n\tint32_t i, k, m, CANVAS_WW = CANVAS_W/2;\n\tuint64_t *canvas = (uint64_t*)ctx.canvas;\n\n\tfor(m = i = 0; i < CANVAS_H; i++, m = i * CANVAS_WW)\n\t\tfor(k = 0; k < CANVAS_WW; k++)\n\t\t  *(uint64_t*)(OFFSET(canvas_x + (k*2), canvas_y + (i))) = canvas[k + m];\n\n\t// after flip, clear frame buffer with background\n\tmemcpy((uint8_t *)ctx.canvas, (uint8_t *)ctx.bg, CANVAS_W * CANVAS_H * 4);\n}", "path": "webMAN-MOD/_Projects_/vsh_menu/blitting.c", "commit_date": "2020-05-24 00:00:00", "repo_name": "aldostools/webMAN-MOD", "stars": 1163, "license": "gpl-3.0", "language": "c", "size": 1317323}
{"docstring": "/***********************************************************************\n* get ucs4 code from utf8 sequence\n*\n* uint8_t *utf8   =  utf8 string\n* uint32_t *ucs4  =  variable to hold ucs4 code\n***********************************************************************/\n", "func_signal": "static int32_t utf8_to_ucs4(uint8_t *utf8, uint32_t *ucs4)", "code": "{\n\tint32_t len = 0;\n\tuint32_t c1 = 0, c2 = 0, c3 = 0, c4 = 0;\n\n\n\tc1 = (uint32_t)*utf8;\n\tutf8++;\n\n\tif(c1 <= 0x7F)                        // 1 byte sequence, ascii\n\t{\n\t\tlen = 1;\n\t\t*ucs4 = c1;\n\t}\n\telse if((c1 & 0xE0) == 0xC0)          // 2 byte sequence\n\t{\n\t\tlen = 2;\n\t\tc2 = (uint32_t)*utf8;\n\n\t\tif((c2 & 0xC0) == 0x80)\n\t\t\t*ucs4 = ((c1  & 0x1F) << 6) | (c2 & 0x3F);\n\t\telse\n\t\t\tlen = *ucs4 = 0;\n\t}\n\telse if((c1 & 0xF0) == 0xE0)          // 3 bytes sequence\n\t{\n\t\tlen = 3;\n\t\tc2 = (uint32_t)*utf8;\n\t\tutf8++;\n\n\t\tif((c2 & 0xC0) == 0x80)\n\t\t{\n\t\t\tc3 = (uint32_t)*utf8;\n\n\t\t\tif((c3 & 0xC0) == 0x80)\n\t\t\t\t*ucs4 = ((c1  & 0x0F) << 12) | ((c2 & 0x3F) << 6) | (c3 & 0x3F);\n\t\t\telse\n\t\t\t\tlen = *ucs4 = 0;\n\t\t}\n\t\telse\n\t\t\tlen = *ucs4 = 0;\n\t}\n\telse if((c1 & 0xF8) == 0xF0)          // 4 bytes sequence\n\t{\n\t\tlen = 4;\n\t\tc2 = (uint32_t)*utf8;\n\t\tutf8++;\n\n\t\tif((c2 & 0xC0) == 0x80)\n\t\t{\n\t\t\tc3 = (uint32_t)*utf8;\n\t\t\tutf8++;\n\n\t\t\tif((c3 & 0xC0) == 0x80)\n\t\t\t{\n\t\t\t\tc4 = (uint32_t)*utf8;\n\n\t\t\t\tif((c4 & 0xC0) == 0x80)\n\t\t\t\t*ucs4 = ((c1  & 0x07) << 18) | ((c2 & 0x3F) << 12) | ((c3 & 0x3F) <<  6) | (c4 & 0x3F);\n\t\t\t\telse\n\t\t\t\t  len = *ucs4 = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t  len = *ucs4 = 0;\n\t\t}\n\t\telse\n\t\t  len = *ucs4 = 0;\n\t}\n\telse\n\t\tlen = *ucs4 = 0;\n\n\treturn len;\n}", "path": "webMAN-MOD/_Projects_/vsh_menu/blitting.c", "commit_date": "2020-05-24 00:00:00", "repo_name": "aldostools/webMAN-MOD", "stars": 1163, "license": "gpl-3.0", "language": "c", "size": 1317323}
{"docstring": "/***********************************************************************\n* unbind and destroy renderer, close font instance\n***********************************************************************/\n", "func_signal": "void font_finalize(void)", "code": "{\n  FontUnbindRenderer(&ctx.font);\n  FontDestroyRenderer(&ctx.renderer);\n  FontCloseFont(&ctx.font);\n}", "path": "webMAN-MOD/_Projects_/vsh_menu/blitting.c", "commit_date": "2020-05-24 00:00:00", "repo_name": "aldostools/webMAN-MOD", "stars": 1163, "license": "gpl-3.0", "language": "c", "size": 1317323}
{"docstring": "/***********************************************************************\n* free callback\n***********************************************************************/\n", "func_signal": "static int32_t cb_free(void *ptr, void *cb_free_arg)", "code": "{\n\tCb_Arg_J *arg;\n\targ = (Cb_Arg_J *)cb_free_arg;\n\targ->freeCallCounts++;\n\tfree(ptr);\n\treturn 0;\n}", "path": "webMAN-MOD/_Projects_/slaunch/jpg_dec.c", "commit_date": "2017-03-07 00:00:00", "repo_name": "aldostools/webMAN-MOD", "stars": 1163, "license": "gpl-3.0", "language": "c", "size": 1317323}
{"docstring": "/***********************************************************************\n* dump background\n***********************************************************************/\n", "func_signal": "static void dump_bg(void)", "code": "{\n\tuint32_t i, k, CANVAS_WW = CANVAS_W/2;\n\tuint64_t *bg = (uint64_t*)ctx.bg;\n\n\tfor(i = 0; i < CANVAS_H; i++)\n\t\tfor(k = 0; k < CANVAS_WW; k++)\n\t\t\tbg[k + i * CANVAS_WW] = *(uint64_t*)(OFFSET(canvas_x + (k*2), canvas_y + (i)));\n}", "path": "webMAN-MOD/_Projects_/vsh_menu/blitting.c", "commit_date": "2020-05-24 00:00:00", "repo_name": "aldostools/webMAN-MOD", "stars": 1163, "license": "gpl-3.0", "language": "c", "size": 1317323}
{"docstring": "/***********************************************************************\n* set decode parameter\n***********************************************************************/\n", "func_signal": "static int32_t set_dec_param(jpg_dec_info\t*dec_ctx)", "code": "{\n\tCellJpgDecInfo      info;\n\tCellJpgDecInParam   in;\n\tCellJpgDecOutParam  out;\n\n\t// read jpg header\n\tif(cellJpgDecReadHeader(dec_ctx->main_h, dec_ctx->sub_h, &info)!=CELL_OK) return -1;\n\n\tjpg_w = info.imageWidth;\n\tjpg_h = info.imageHeight;\n\tif(!jpg_w || !jpg_h || (!ISHD(jpg_w) && (jpg_w*jpg_h)>MAX_WH4)) return -1;\n\n\t// set decoder parameter\n\tin.commandPtr\t\t\t= NULL;\n\tin.outputMode\t\t\t= CELL_JPGDEC_TOP_TO_BOTTOM;\n\tin.outputColorSpace\t\t= CELL_JPG_ARGB;\n\tin.method\t\t\t\t= CELL_JPGDEC_FAST;//CELL_JPGDEC_QUALITY\n\tin.outputColorAlpha\t\t= 0xFF;\n\tin.downScale\t\t\t= 1;\n\n\tif(!ISHD(jpg_w) && ((jpg_w*jpg_h*4)>(MAX_WH4) || jpg_w>MAX_W || jpg_h>MAX_H || gpp==40))\n\t{\n\t\tif(gpp==10)\n\t\t{\n\t\t\tin.downScale = 2;\n\t\t\tjpg_w/=2; jpg_w+=(jpg_w%4);\n\t\t\tjpg_h/=2;\n\t\t}\n\t\telse\n\t\tif(jpg_w>168 || jpg_h>168)\n\t\t{\n\t\t\tin.downScale = 2;\n\t\t\tjpg_w/=2; jpg_w+=(jpg_w%2);\n\t\t\tjpg_h/=2;\n\t\t}\n\t}\n\n\treturn cellJpgDecSetParameter(dec_ctx->main_h, dec_ctx->sub_h, &in, &out);\n}", "path": "webMAN-MOD/_Projects_/slaunch/jpg_dec.c", "commit_date": "2017-03-07 00:00:00", "repo_name": "aldostools/webMAN-MOD", "stars": 1163, "license": "gpl-3.0", "language": "c", "size": 1317323}
{"docstring": "/***********************************************************************\n* decode jpg stream\n***********************************************************************/\n", "func_signal": "static int32_t decode_jpg_stream(jpg_dec_info\t*dec_ctx, void *buf)", "code": "{\n\tuint8_t *out;\n\tCellJpgDecDataCtrlParam  param;\n\tCellJpgDecDataOutInfo    info;\n\n\tparam.outputBytesPerLine = jpg_w * 4;\n\tout = (void*)buf;\n\n\t// decode jpg...\n\treturn cellJpgDecDecodeData(dec_ctx->main_h, dec_ctx->sub_h, out, &param, &info);\n}", "path": "webMAN-MOD/_Projects_/slaunch/jpg_dec.c", "commit_date": "2017-03-07 00:00:00", "repo_name": "aldostools/webMAN-MOD", "stars": 1163, "license": "gpl-3.0", "language": "c", "size": 1317323}
{"docstring": "/***********************************************************************\n* draw png part into frame.\n*\n* int32_t can_x    =  start x coordinate into canvas\n* int32_t can_y    =  start y coordinate into canvas\n* int32_t png_x    =  start x coordinate into png\n* int32_t png_y    =  start y coordinate into png\n* int32_t w        =  width of png part to blit\n* int32_t h        =  height of png part to blit\n***********************************************************************/\n", "func_signal": "int32_t draw_png(int32_t idx, int32_t c_x, int32_t c_y, int32_t p_x, int32_t p_y, int32_t w, int32_t h)", "code": "{\n\tuint32_t i, k, hh = h, ww = w;\n\n\tconst uint32_t CANVAS_WW = CANVAS_W - c_x, CANVAS_HH = CANVAS_H - c_y;\n\n\tif(hh > CANVAS_HH) hh = CANVAS_HH;\n\tif(ww > CANVAS_WW) ww = CANVAS_WW;\n\n\tfor(i = 0; i < hh; i++)\n\t\tfor(k = 0; k < ww; k++)\n\t\t\tctx.canvas[(c_y + i) * CANVAS_W + c_x + k] =\n\t\t\tmix_color(ctx.canvas[(c_y + i) * CANVAS_W + c_x + k],\n\t\t\tctx.png[idx].addr[(p_x + p_y * ctx.png[idx].w) + (k + i * ctx.png[idx].w)]);\n\n\treturn (c_x + w);\n}", "path": "webMAN-MOD/_Projects_/vsh_menu/blitting.c", "commit_date": "2020-05-24 00:00:00", "repo_name": "aldostools/webMAN-MOD", "stars": 1163, "license": "gpl-3.0", "language": "c", "size": 1317323}
{"docstring": "/***********************************************************************\n* set new font values\n*\n* float_t font_w    =  char width\n* float_t font_h    =  char height\n* float_t weight    =  line weight\n* int32_t distance  =  distance between chars\n***********************************************************************/\n", "func_signal": "void set_font(float_t font_w, float_t font_h, float_t weight, int32_t distance)", "code": "{\n\t// max size is 32 * 32 pixels\n\tif(font_w > 32.f) font_w = 32.f;\n\tif(font_h > 32.f) font_h = 32.f;\n\n\t// set font\n\tFontSetScalePixel(&ctx.font, font_w, font_h);\n\tFontSetEffectWeight(&ctx.font, weight);\n\n\t// get and set new line height\n\tFontGetHorizontalLayout(&ctx.font, &bitmap->horizontal_layout);\n\tLINE_HEIGHT = bitmap->horizontal_layout.lineHeight;\n\n\tbitmap->count    = 0;                             // reset font cache\n\tbitmap->font_w   = font_w;\n\tbitmap->font_h   = font_h;\n\tbitmap->weight   = weight;\n\tbitmap->distance = distance;\n}", "path": "webMAN-MOD/_Projects_/vsh_menu/blitting.c", "commit_date": "2020-05-24 00:00:00", "repo_name": "aldostools/webMAN-MOD", "stars": 1163, "license": "gpl-3.0", "language": "c", "size": 1317323}
{"docstring": "/***********************************************************************\n* create jpg decoder\n***********************************************************************/\n", "func_signal": "static int32_t create_decoder(jpg_dec_info *dec_ctx)", "code": "{\n\tCellJpgDecThreadInParam   in;\n\tCellJpgDecThreadOutParam  out;\n\n\t// set params\n\tdec_ctx->cb_arg_j.mallocCallCounts\t=\n\tdec_ctx->cb_arg_j.freeCallCounts\t= 0;\n\n\tin.spuThreadEnable\t\t= CELL_JPGDEC_SPU_THREAD_ENABLE; //CELL_JPGDEC_SPU_THREAD_DISABLE;   //\n\tin.ppuThreadPriority\t= 512;\n\tin.spuThreadPriority\t= 200;\n\tin.cbCtrlMallocFunc\t\t= cb_malloc;\n\tin.cbCtrlMallocArg\t\t= &dec_ctx->cb_arg_j;\n\tin.cbCtrlFreeFunc\t\t= cb_free;\n\tin.cbCtrlFreeArg\t\t= &dec_ctx->cb_arg_j;\n\n\t// create jpg decoder\n\treturn cellJpgDecCreate(&dec_ctx->main_h, &in, &out);\n}", "path": "webMAN-MOD/_Projects_/slaunch/jpg_dec.c", "commit_date": "2017-03-07 00:00:00", "repo_name": "aldostools/webMAN-MOD", "stars": 1163, "license": "gpl-3.0", "language": "c", "size": 1317323}
{"docstring": "/***********************************************************************\n* unbind and destroy renderer, close font instance\n***********************************************************************/\n", "func_signal": "static void font_init(void)", "code": "{\n\tuint32_t user_id = 0, val = 0;\n\tCellFontRendererConfig rd_cfg;\n\tCellFont *opened_font = NULL;\n\n\tif(get_font_object() == FAILED) return;\n\n\t// get id of current logged in user for the xRegistry query we do next\n\tuser_id = xsetting_CC56EB2D()->GetCurrentUserNumber();\n\tif(user_id > 255) user_id = 1;\n\n\t// get current font style for the current logged in user\n\txsetting_CC56EB2D()->GetRegistryValue(user_id, 0x5C, &val);\n\n\t// fix font selection\n\tint val_lang = 1;\n\txsetting_0AF1F161()->GetSystemLanguage(&val_lang);\n\tif(((val_lang >= 9) && (val_lang <= 11)) || (val_lang == 16) || (val_lang == 19))\n\t\tval = 0;\n\tif(val_lang == 7)\n\t\tval = 4;\n\tif(val_lang == 8)\n\t\tval = 9;\n\n\t// get sysfont\n\tswitch(val)\n\t{\n\t\tcase 0:   // original\n\t\t  opened_font = (void*)(vsh_fonts[5]);\n\t\t  break;\n\t\tcase 1:   // rounded\n\t\t  opened_font = (void*)(vsh_fonts[8]);\n\t\t  break;\n\t\tcase 3:   // pop\n\t\t  opened_font = (void*)(vsh_fonts[10]);\n\t\t  break;\n\t\tcase 4:   // russian\n\t\t  opened_font = (void*)(vsh_fonts[1]);\n\t\t  break;\n\t\tdefault:  // better than nothing\n\t\t  opened_font = (void*)(vsh_fonts[9]);\n\t\t  break;\n\t}\n\n\tif(!opened_font) return;\n\n\tFontOpenFontInstance(opened_font, &ctx.font);\n\n\tmemset(&rd_cfg, 0, sizeof(CellFontRendererConfig));\n\tFontCreateRenderer(font_lib_ptr, &rd_cfg, &ctx.renderer);\n\n\tFontBindRenderer(&ctx.font, &ctx.renderer);\n\n\tset_font_default();\n}", "path": "webMAN-MOD/_Projects_/vsh_menu/blitting.c", "commit_date": "2020-05-24 00:00:00", "repo_name": "aldostools/webMAN-MOD", "stars": 1163, "license": "gpl-3.0", "language": "c", "size": 1317323}
{"docstring": "// wcrtomb()\n", "func_signal": "int wctomb(char *s, wchar_t wchar)", "code": "{\n\tstatic mbstate_t mbs;\n\tsize_t rval;\n\n\tif (s == NULL) {\n\t\tstdc_5909E3C4(&mbs, 0, sizeof(mbs));\t\t\t\t\t\t\t\t\t\t\t//memset\n\t\treturn (0);\n\t}\n\tif ((rval = stdc_B2702E15(s, wchar, &mbs)) == (size_t)-1)\t\t\t\t\t\t\t//wcrtomb\n\t\treturn (-1);\n\treturn ((int)rval);\n}", "path": "webMAN-MOD/libc.c", "commit_date": "2019-07-09 00:00:00", "repo_name": "aldostools/webMAN-MOD", "stars": 1163, "license": "gpl-3.0", "language": "c", "size": 1317323}
{"docstring": "/***********************************************************************\n* draw background, with current background color\n***********************************************************************/\n", "func_signal": "void draw_background()", "code": "{\n\tconst uint32_t CANVAS_SIZE = CANVAS_W * CANVAS_H;\n\n\tfor(uint32_t i = 0; i < CANVAS_SIZE; i++)\n\t\tctx.canvas[i] = mix_color(ctx.bg[i], ctx.bg_color);\n}", "path": "webMAN-MOD/_Projects_/vsh_menu/blitting.c", "commit_date": "2020-05-24 00:00:00", "repo_name": "aldostools/webMAN-MOD", "stars": 1163, "license": "gpl-3.0", "language": "c", "size": 1317323}
{"docstring": "/***********************************************************************\n* render a char glyph bitmap into bitmap cache by index\n*\n* int32_t cache_idx  =  index into cache\n* uint32_t code      =  unicode of char glyph to render\n***********************************************************************/\n", "func_signal": "static void render_glyph(int32_t idx, uint32_t code)", "code": "{\n\tCellFontRenderSurface  surface;\n\tCellFontGlyphMetrics   metrics;\n\tCellFontImageTransInfo transinfo;\n\tint32_t i, k, x, y, w, h;\n\tint32_t ibw;\n\n\n\t// setup render settings\n\tFontSetupRenderScalePixel(&ctx.font, bitmap->font_w, bitmap->font_h);\n\tFontSetupRenderEffectWeight(&ctx.font, bitmap->weight);\n\n\tx = ((int32_t)bitmap->font_w) * 2;\n\ty = ((int32_t)bitmap->font_h) * 2;\n\tw = x * 2;\n\th = y * 2;\n\n\t// set surface\n\tFontRenderSurfaceInit(&surface, NULL, w, 1, w, h);\n\n\t// set render surface scissor, (full area/no scissoring)\n\tFontRenderSurfaceSetScissor(&surface, 0, 0, w, h);\n\n\tbitmap->glyph[idx].code = code;\n\n\tFontRenderCharGlyphImage(&ctx.font, bitmap->glyph[idx].code, &surface,\n\t\t\t\t\t\t\t(float_t)x, (float_t)y, &metrics, &transinfo);\n\n\tbitmap->count++;\n\n\tibw = transinfo.imageWidthByte;\n\tbitmap->glyph[idx].w = transinfo.imageWidth;      // width of char image\n\tbitmap->glyph[idx].h = transinfo.imageHeight;     // height of char image\n\n\t// copy glyph bitmap into cache\n\tfor(k = 0; k < bitmap->glyph[idx].h; k++)\n\tfor(i = 0; i < bitmap->glyph[idx].w; i++)\n\t\tbitmap->glyph[idx].image[k*bitmap->glyph[idx].w + i] =\n\t\ttransinfo.Image[k * ibw + i];\n\n\tbitmap->glyph[idx].metrics = metrics;\n}", "path": "webMAN-MOD/_Projects_/vsh_menu/blitting.c", "commit_date": "2020-05-24 00:00:00", "repo_name": "aldostools/webMAN-MOD", "stars": 1163, "license": "gpl-3.0", "language": "c", "size": 1317323}
{"docstring": "/***********************************************************************\n* decode jpg file\n* const char *file_path  =  path to jpg file e.g. \"/dev_hdd0/test.jpg\"\n***********************************************************************/\n", "func_signal": "Buffer load_jpg(const char *file_path, void* buf_addr)", "code": "{\n\tBuffer tmp;\n\tjpg_dec_info dec_ctx;\n\ttmp.addr = (uint32_t*)buf_addr;\n\n\ttmp.b= // no transparency\n\ttmp.w=tmp.h=\n\ttmp.x=tmp.y=\n\tjpg_w=jpg_h=0;\n\n\t// create jpg decoder\n\tif(create_decoder(&dec_ctx)==CELL_OK)\n\t{\n\t\t// open jpg stream\n\t\tif(open_jpg(&dec_ctx, file_path)==CELL_OK)\n\t\t{\n\t\t\t// set decode parameter\n\t\t\tif(set_dec_param(&dec_ctx)==CELL_OK)\n\t\t\t{\n\t\t\t\t// decode jpg stream, into target buffer\n\t\t\t\tdecode_jpg_stream(&dec_ctx, buf_addr);\n\t\t\t\ttmp.w = jpg_w;\n\t\t\t\ttmp.h = jpg_h;\n\t\t\t}\n\n\t\t\t// close jpg stream\n\t\t\tcellJpgDecClose(dec_ctx.main_h, dec_ctx.sub_h);\n\t\t}\n\n\t\t// destroy jpg decoder\n\t\tcellJpgDecDestroy(dec_ctx.main_h);\n\t}\n\n\treturn tmp;\n}", "path": "webMAN-MOD/_Projects_/slaunch/jpg_dec.c", "commit_date": "2017-03-07 00:00:00", "repo_name": "aldostools/webMAN-MOD", "stars": 1163, "license": "gpl-3.0", "language": "c", "size": 1317323}
{"docstring": "/***********************************************************************\n* xmb screenshot\n*\n* uint8_t mode = 0(XMB only), 1(XMB + menu)\n***********************************************************************/\n", "func_signal": "void screenshot(uint8_t mode)", "code": "{\n\tchar path[64];\n\n\t// build file path\n\tCellRtcDateTime t;\n\tcellRtcGetCurrentClockLocalTime(&t);\n\tsprintf(path, \"/dev_hdd0/screenshot_%02d_%02d_%02d_%02d_%02d_%02d.bmp\", t.year, t.month, t.day, t.hour, t.minute, t.second);\n\n\t// create bmp file\n\tFILE *fd = NULL;\n\tfd = fopen(path, \"wb\"); if(!fd) return;\n\n\t// alloc buffers\n\tsys_memory_container_t mc_app = (sys_memory_container_t)-1;\n\tmc_app = vsh_memory_container_by_id(1);\n\n\tconst int32_t mem_size = 64 * 1024; // 64 KB (bmp data and frame buffer)\n\n\t// max frame line size = 1920 pixel * 4(byte per pixel) = 7680 byte = 8 KB\n\t// max bmp buffer size = 1920 pixel * 3(byte per pixel) = 5760 byte = 6 KB\n\n\tsys_addr_t sys_mem = NULL;\n\tsys_memory_allocate_from_container(mem_size, mc_app, SYS_MEMORY_PAGE_SIZE_64K, &sys_mem);\n\n\t// calc buffer sizes\n\tuint32_t line_frame_size = w * 4;\n\n\t// alloc buffers\n\tuint64_t *line_frame = (uint64_t*)sys_mem;\n\tuint8_t *bmp_buf = (uint8_t*)sys_mem + line_frame_size; // start offset: 8 KB\n\tuint64_t *bg = (uint64_t*)ctx.bg;\n\n\t// set bmp header\n\tuint32_t tmp = 0;\n\ttmp = _ES32(w*h*3+0x36);\n\tmemcpy(bmp_header + 2 , &tmp, 4);     // file size\n\ttmp = _ES32(w);\n\tmemcpy(bmp_header + 18, &tmp, 4);     // bmp width\n\ttmp = _ES32(h);\n\tmemcpy(bmp_header + 22, &tmp, 4);     // bmp height\n\ttmp = _ES32(w*h*3);\n\tmemcpy(bmp_header + 34, &tmp, 4);     // bmp data size\n\n\t// write bmp header\n\tfwrite(bmp_header, 1, sizeof(bmp_header), fd);\n\n\tuint32_t i, k, idx;\n\n\tuint32_t canvas_x_left = canvas_x/2, canvas_x_right = canvas_x_left + CANVAS_W/2, canvas_y_bottom = canvas_y + CANVAS_H, ww=w/2;\n\n\t// dump...\n\tfor(i = h; i > 0; i--)\n\t{\n\t\tfor(k = 0; k < ww; k++)\n\t\t\tline_frame[k] = *(uint64_t*)(OFFSET(k*2, i));\n\n\t\tif((mode == 0) && (i >= canvas_y) && (i < canvas_y_bottom))\n\t\t{\n\t\t\tfor(k = canvas_x_left; k < canvas_x_right; k++)\n\t\t\t{\n\t\t\t\tline_frame[k] = bg[(((i - canvas_y) * CANVAS_W) + ((k*2) - canvas_x)) /2];\n\t\t\t}\n\t\t}\n\n\t\t// convert line from ARGB to RGB\n\t\tuint8_t *tmp_buf = (uint8_t*)line_frame;\n\n\t\tidx = 0; //(h-1-i)*w*3;  // index into bmp buffer, ... f*****g bmp format\n\n\t\tfor(k = 0; k < line_frame_size; k+=4, idx+=3)\n\t\t{\n\t\t\tbmp_buf[idx]   = tmp_buf[k + 3];  // R\n\t\t\tbmp_buf[idx+1] = tmp_buf[k + 2];  // G\n\t\t\tbmp_buf[idx+2] = tmp_buf[k + 1];  // B\n\t\t}\n\n\t\t// write bmp data\n\t\tfwrite(bmp_buf, 1, idx, fd);\n\t}\n\n\t// padding\n\tint32_t rest = (w*3) % 4, pad = 0;\n\tif(rest)\n\t\tpad = 4 - rest;\n\tfseek(fd, pad, SEEK_CUR);\n\n\tfclose(fd);\n\tsys_memory_free((sys_addr_t)sys_mem);\n\n\tvshtask_notify(path);\n}", "path": "webMAN-MOD/_Projects_/vsh_menu/blitting.c", "commit_date": "2020-05-24 00:00:00", "repo_name": "aldostools/webMAN-MOD", "stars": 1163, "license": "gpl-3.0", "language": "c", "size": 1317323}
{"docstring": "/***********************************************************************\n* set font with default settings\n***********************************************************************/\n", "func_signal": "static void set_font_default(void)", "code": "{\n\tint32_t i;\n\tbitmap = mem_alloc(sizeof(Bitmap));\n\tmemset(bitmap, 0, sizeof(Bitmap));\n\n\t// set font\n\tFontSetScalePixel(&ctx.font, FONT_W, FONT_H);\n\tFontSetEffectWeight(&ctx.font, FONT_WEIGHT);\n\n\tFontGetHorizontalLayout(&ctx.font, &bitmap->horizontal_layout);\n\tLINE_HEIGHT = bitmap->horizontal_layout.lineHeight;\n\n\tbitmap->max    = FONT_CACHE_MAX;\n\tbitmap->count  = 0;\n\tbitmap->font_w = FONT_W;\n\tbitmap->font_h = FONT_H;\n\tbitmap->weight = FONT_WEIGHT;\n\n\tfor(i = 0; i < FONT_CACHE_MAX; i++)\n\t  bitmap->glyph[i].image = (uint8_t *)ctx.font_cache + (i * 0x400);\n}", "path": "webMAN-MOD/_Projects_/vsh_menu/blitting.c", "commit_date": "2020-05-24 00:00:00", "repo_name": "aldostools/webMAN-MOD", "stars": 1163, "license": "gpl-3.0", "language": "c", "size": 1317323}
{"docstring": "// strncmp()\n", "func_signal": "inline int strncmp(const char *str1, const char *str2, size_t num)", "code": "{return stdc_E1E83C65(str1, str2, num);}\n\nextern int stdc_3D85D6F8(const char *str1, const char *str2);\t\t\t\t\t\t\t// strcmp()\ninline int strcmp(const char *str1, const char *str2) {return stdc_3D85D6F8(str1, str2);}\n\nextern size_t stdc_2F45D39C(const char *str);\t\t\t\t\t\t\t\t\t\t\t// strlen()\ninline size_t strlen(const char *str) {return stdc_2F45D39C(str);}\n\nextern void *stdc_5909E3C4(void *str, int c, size_t n);\t\t\t\t\t\t\t\t\t// memset()\ninline void* memset(void *str, int c, size_t n) {return stdc_5909E3C4(str, c, n);}\n\nextern void *stdc_831D70A5(void *dest, const void *src, size_t num);\t\t\t\t\t// memcpy()\ninline void* memcpy(void *dest, const void *src, size_t num) {return stdc_831D70A5(dest, src, num);}\n\nextern char *stdc_C5C09834(const char *str1, const char *str2);\t\t\t\t\t\t\t// strstr()\ninline char* strstr(const char *str1, const char *str2) {return stdc_C5C09834(str1, str2);}\n\nextern int* stdc_44115DD0(void);\ninline int* _Geterrno(void){return stdc_44115DD0();}\t\t\t\t\t\t\t\t\t// _Geterrno\n\nextern void allocator_77A602DD(void *ptr);\t\t\t\t\t\t\t\t\t\t\t\t// free()\ninline void free(void *ptr) {allocator_77A602DD(ptr);}\n\nextern void *allocator_759E0635(size_t size);\t\t\t\t\t\t\t\t\t\t\t// malloc()\ninline void* malloc (size_t size) {return allocator_759E0635(size);}\n\nextern void *allocator_6137D196(size_t alignment, size_t size);\t\t\t\t\t\t\t// memalign()\ninline void* memalign(size_t alignment, size_t size) {return allocator_6137D196(alignment, size);}\n\nextern void *allocator_A72A7595(size_t nitems, size_t size);\t\t\t\t\t\t\t// calloc()\ninline void* calloc(size_t nitems, size_t size) {return allocator_A72A7595(nitems, size);}\n\nextern void *allocator_F7A14A22(void *ptr, size_t size);\t\t\t\t\t\t\t\t// realloc()\ninline void* realloc(void *ptr, size_t size) {return allocator_F7A14A22(ptr, size);}\n\nextern void *stdc_5B162B7F(void *str1, const void *str2, size_t n);\t\t\t\t\t\t// memmove()\ninline void* memmove(void *str1, const void *str2, size_t n) {return stdc_5B162B7F(str1, str2, n);}\n\nextern char *stdc_FC0428A6(const char *s);\t\t\t\t\t\t\t\t\t\t\t\t// strdup()\ninline char* strdup(const char *s) {return stdc_FC0428A6(s);}\n\nextern char *stdc_44796E5C(int errnum);\t\t\t\t\t\t\t\t\t\t\t\t\t// strerror()\ninline char* strerror(int errnum) {return stdc_44796E5C(errnum);}\n\nextern double stdc_519EBB77(double x);\t\t\t\t\t\t\t\t\t\t\t\t\t// floor()\ninline double floor(double x) {return stdc_519EBB77(x);}\n\nextern double stdc_21E6D304(double x);\t\t\t\t\t\t\t\t\t\t\t\t\t// ceil()\ninline double ceil(double x) {return stdc_21E6D304(x);}\n\nextern time_t stdc_89F6F026(time_t *timer);\t\t\t\t\t\t\t\t\t\t\t\t// time()\ninline time_t time(time_t *timer) {return stdc_89F6F026(timer);}\n\nextern size_t stdc_FCAC2E8E(wchar_t *dest, const char *src, size_t max);\t\t\t\t// mbstowcs()\ninline size_t mbstowcs(wchar_t *dest, const char *src, size_t max) {return stdc_FCAC2E8E(dest, src, max);}\n\nextern size_t stdc_12A55FB7(wchar_t *restrict pwc, const char *restrict s, size_t n, mbstate_t *restrict ps); // mbrtowc\nint mbtowc(wchar_t * restrict pwc, const char * restrict s, size_t n)\n{\n\tstatic mbstate_t mbs;\n\tsize_t rval;\n\n\tif (s == NULL) {\n\t\tstdc_5909E3C4(&mbs, 0, sizeof(mbs));\t\t\t\t\t\t\t\t\t\t\t//memset\n\t\treturn (0);\n\t}\n\trval = stdc_12A55FB7(pwc, s, n, &mbs);\t\t\t\t\t\t\t\t\t\t\t\t//mbrtowc\n\tif (rval == (size_t)-1 || rval == (size_t)-2)\n\t\treturn (-1);\n\treturn ((int)rval);\n}", "path": "webMAN-MOD/libc.c", "commit_date": "2019-07-09 00:00:00", "repo_name": "aldostools/webMAN-MOD", "stars": 1163, "license": "gpl-3.0", "language": "c", "size": 1317323}
{"docstring": "/***********************************************************************\n* load a png file\n*\n* int32_t idx      = index of png, max 4 (0 - 3)\n* const char *path = path to png file\n***********************************************************************/\n", "func_signal": "int32_t load_png_bitmap(int32_t idx, const char *path)", "code": "{\n\tif(idx > PNG_MAX) return FAILED;\n\n\tmem_free(ctx.png[idx].w * ctx.png[idx].h * 4);\n\n\tctx.png[idx] = load_png(path);\n\n\treturn 0;\n}", "path": "webMAN-MOD/_Projects_/vsh_menu/blitting.c", "commit_date": "2020-05-24 00:00:00", "repo_name": "aldostools/webMAN-MOD", "stars": 1163, "license": "gpl-3.0", "language": "c", "size": 1317323}
{"docstring": "/***********************************************************************\n* print text, (TTF)\n*\n* int32_t x       = start x coordinate into canvas\n* int32_t y       = start y coordinate into canvas\n* const char *str = string to print\n***********************************************************************/\n", "func_signal": "int32_t print_text(int32_t x, int32_t y, const char *str)", "code": "{\n\tint32_t i, k, len = 0;\n\tuint32_t code = 0;                                              // char unicode\n\tint32_t t_x = x, t_y = y;                                       // temp x/y\n\tint32_t o_x = x, o_y = y + bitmap->horizontal_layout.baseLineY; // origin x/y\n\tGlyph *glyph;                                                   // char glyph\n\tuint8_t *utf8 = (uint8_t*)str;\n\n\n\tmemset(&glyph, 0, sizeof(Glyph));\n\n\t// center text (only 1 line)\n\tif(x == CENTER_TEXT)\n\t{\n\t\twhile(1)                                  // get render length\n\t\t{\n\t\t\tutf8 += utf8_to_ucs4(utf8, &code);\n\n\t\t\tif(code == 0) break;\n\n\t\t\tglyph = get_glyph(code);\n\t\t\tlen += glyph->metrics.Horizontal.advance + bitmap->distance;\n\t\t}\n\n\t\to_x = t_x = (CANVAS_W - len - bitmap->distance) / 2;\n\t\tutf8 = (uint8_t*)str;\n\t}\n\n\t// render text\n\twhile(1)\n\t{\n\t\tutf8 += utf8_to_ucs4(utf8, &code);\n\n\t\tif(code == 0) break;\n\n\t\tif((code == '^') || ((code == '\\n') && (x != CENTER_TEXT)))\n\t\t{\n\t\t\to_x = x;\n\t\t\to_y += bitmap->horizontal_layout.lineHeight;\n\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// get glyph to draw\n\t\t\tglyph = get_glyph(code);\n\n\t\t\t// get bitmap origin(x, y)\n\t\t\tt_x = o_x + glyph->metrics.Horizontal.bearingX;\n\t\t\tt_y = o_y - glyph->metrics.Horizontal.bearingY;\n\n\t\t\t// draw bitmap\n\t\t\tfor(i = 0; i < glyph->h; i++)\n\t\t\t  for(k = 0; k < glyph->w; k++)\n\t\t\t    if((glyph->image[i * glyph->w + k]) && (t_x + k < CANVAS_W) && (t_y + i < CANVAS_H))\n\t\t\t\t\t\tctx.canvas[(t_y + i) * CANVAS_W + t_x + k] =\n\t\t\t\t\t\tmix_color(ctx.canvas[(t_y + i) * CANVAS_W + t_x + k],\n\t\t\t\t\t\t         ((uint32_t)glyph->image[i * glyph->w + k] <<24) |\n\t\t\t\t\t\t         (ctx.fg_color & 0x00FFFFFF));\n\n\t\t\t// get origin-x for next char\n\t\t\to_x += glyph->metrics.Horizontal.advance + bitmap->distance;\n\t\t}\n\t}\n\n\treturn o_x;\n}", "path": "webMAN-MOD/_Projects_/vsh_menu/blitting.c", "commit_date": "2020-05-24 00:00:00", "repo_name": "aldostools/webMAN-MOD", "stars": 1163, "license": "gpl-3.0", "language": "c", "size": 1317323}
{"docstring": "/* A helper function to read an unsigned integer from the stream safely. */\n", "func_signal": "_INLINE_ int read_stream_safe_uint64(_CodeInfo* ci, void* result)", "code": "{\n\tci->codeLen -= 8;\n\tif (ci->codeLen < 0) return FALSE;\n\t*(uint64_t*)result = RULLONG(ci->code);\n\tci->code += 8;\n\treturn TRUE;\n}", "path": "distorm/src/operands.c", "commit_date": "2020-05-31 00:00:00", "repo_name": "gdabah/distorm", "stars": 1198, "license": "other", "language": "c", "size": 1970}
{"docstring": "/* Calculates which prefixes weren't used and accordingly sets the bits in the unusedPrefixesMask. */\n", "func_signal": "uint16_t prefixes_set_unused_mask(_PrefixState* ps)", "code": "{\n\t/*\n\t * The decodedPrefixes represents the prefixes that were *read* from the binary stream for the instruction.\n\t * The usedPrefixes represents the prefixes that were actually used by the instruction in the *decode* phase.\n\t * Xoring between the two will result in a 'diff' which returns the prefixes that were read\n\t * from the stream *and* that were never used in the actual decoding.\n\t *\n\t * Only one prefix per type can be set in decodedPrefixes from the stream.\n\t * Therefore it's enough to check each type once and set the flag accordingly.\n\t * That's why we had to book-keep each prefix type and its position.\n\t * So now we know which bits we need to set exactly in the mask.\n\t */\n\t_iflags unusedPrefixesDiff = ps->decodedPrefixes ^ ps->usedPrefixes;\n\tuint16_t unusedPrefixesMask = ps->unusedPrefixesMask;\n\n\t/* Examine unused prefixes by type: */\n\t/*\n\t * About REX: it might be set in the diff although it was never in the stream itself.\n\t * This is because the vrex is shared between VEX and REX and some places flag it as REX usage, while\n\t * we were really decoding an AVX instruction.\n\t * It's not a big problem, because the prefixes_ignore func will ignore it anyway,\n\t * since it wasn't seen earlier. But it's important to know this.\n\t */\n\tif (unusedPrefixesDiff) {\n\t\tif (unusedPrefixesDiff & INST_PRE_REX) unusedPrefixesMask |= ps->pfxIndexer[PFXIDX_REX];\n\t\tif (unusedPrefixesDiff & INST_PRE_SEGOVRD_MASK) unusedPrefixesMask |= ps->pfxIndexer[PFXIDX_SEG];\n\t\tif (unusedPrefixesDiff & INST_PRE_LOKREP_MASK) unusedPrefixesMask |= ps->pfxIndexer[PFXIDX_LOREP];\n\t\tif (unusedPrefixesDiff & INST_PRE_OP_SIZE) unusedPrefixesMask |= ps->pfxIndexer[PFXIDX_OP_SIZE];\n\t\tif (unusedPrefixesDiff & INST_PRE_ADDR_SIZE) unusedPrefixesMask |= ps->pfxIndexer[PFXIDX_ADRS];\n\t\t/* If a VEX instruction was found, its prefix is considered as used, therefore no point for checking for it. */\n\t}\n\n\treturn unusedPrefixesMask;\n}", "path": "distorm/src/prefix.c", "commit_date": "2020-05-15 00:00:00", "repo_name": "gdabah/distorm", "stars": 1198, "license": "other", "language": "c", "size": 1970}
{"docstring": "/* A helper function to read an unsigned integer from the stream safely. */\n", "func_signal": "_INLINE_ int read_stream_safe_uint8(_CodeInfo* ci, void* result)", "code": "{\n\tci->codeLen -= 1;\n\tif (ci->codeLen < 0) return FALSE;\n\t*(uint8_t*)result = *(uint8_t*)ci->code;\n\tci->code += 1;\n\treturn TRUE;\n}", "path": "distorm/src/operands.c", "commit_date": "2020-05-31 00:00:00", "repo_name": "gdabah/distorm", "stars": 1198, "license": "other", "language": "c", "size": 1970}
{"docstring": "/* A helper function to read a signed integer from the stream safely. */\n", "func_signal": "_INLINE_ int read_stream_safe_sint32(_CodeInfo* ci, int64_t* result)", "code": "{\n\tci->codeLen -= 4;\n\tif (ci->codeLen < 0) return FALSE;\n\t*result = RLONG(ci->code);\n\tci->code += 4;\n\treturn TRUE;\n}", "path": "distorm/src/operands.c", "commit_date": "2020-05-31 00:00:00", "repo_name": "gdabah/distorm", "stars": 1198, "license": "other", "language": "c", "size": 1970}
{"docstring": "/*\n * For every memory-indirection operand we want to set a used segment.\n * If the segment is being overrided with a prefix, we will need to check if it's a default.\n * Defaults don't use their prefix, e.g \"mov [rsp]\" can ignore a given SS: prefix,\n * but still set the used segment as SS.\n * This function is called only with SS and DS as defaults.\n * If there's a segment prefix used, it will override the default one.\n * And If the prefix is a default seg in 64 bits, it will be ignored.\n */\n", "func_signal": "void prefixes_use_segment(_iflags defaultSeg, _PrefixState* ps, _DecodeType dt, _DInst* di)", "code": "{\n\t/* Extract given segment prefix from the decoded prefixes. */\n\t_iflags flags;\n\n\tif (dt == Decode64Bits) {\n\t\tif (ps->decodedPrefixes & INST_PRE_SEGOVRD_MASK64) { /* Either GS or FS. */\n\t\t\tdi->segment = ps->decodedPrefixes & INST_PRE_GS ? R_GS : R_FS;\n\t\t}\n\n\t\treturn;\n\t}\n\n\tflags = ps->decodedPrefixes & INST_PRE_SEGOVRD_MASK;\n\n\t/* Use the given prefix only if it's not the default. */\n\tif (flags && (flags != defaultSeg)) {\n\t\tps->usedPrefixes |= flags;\n\n\t\tswitch (flags >> 7) /* INST_PRE_CS is 1 << 7. And the rest of the prefixes follow as bit fields. */\n\t\t{\n\t\t\tcase 1: di->segment = R_CS; break;\n\t\t\tcase 2: di->segment = R_SS; break;\n\t\t\tcase 4: di->segment = R_DS; break;\n\t\t\tcase 8: di->segment = R_ES; break;\n\t\t\tcase 0x10: di->segment = R_FS; break;\n\t\t\tcase 0x20: di->segment = R_GS; break;\n\t\t}\n\t}\n\telse {\n\t\tif (defaultSeg == INST_PRE_SS) di->segment = SEGMENT_DEFAULT | R_SS;\n\t\telse di->segment = SEGMENT_DEFAULT | R_DS;\n\t}\n}", "path": "distorm/src/prefix.c", "commit_date": "2020-05-15 00:00:00", "repo_name": "gdabah/distorm", "stars": 1198, "license": "other", "language": "c", "size": 1970}
{"docstring": "/*\n * This seems to be the hardest part in decoding the operands.\n * If you take a look carefully at Table 2-2. 32-Bit Addressing Forms with the ModR/M Byte,\n * you will understand it's easy to decode the operands.\n\n * First we check the DT, so we can decide according to which Table in the documentation we are supposed to decode.\n * Then we follow the specific table whether it's 16 bits or 32/64 bits.\n\n * Don't forget that Operand Size AND Address Size prefixes may change the decoding!\n\n * Some instructions force the use of RM16 or other specific types, so take it into account.\n */\n", "func_signal": "static int operands_extract_modrm(_CodeInfo* ci, _PrefixState* ps, _DInst* di,\n                                  _DecodeType effAdrSz, unsigned int mod, unsigned int rm,\n                                  _iflags instFlags, _Operand* op)", "code": "{\n\tunsigned char sib = 0, base = 0;\n\n\t/* Memory indirection decoding ahead:) */\n\n\tps->usedPrefixes |= INST_PRE_ADDR_SIZE;\n\tif ((instFlags & INST_PRE_LOCK) && (ps->decodedPrefixes & INST_PRE_LOCK)) {\n\t\tps->usedPrefixes |= INST_PRE_LOCK;\n\t\tdi->flags |= FLAG_LOCK;\n\t}\n\n\tif (effAdrSz != Decode16Bits) { /* Decode32Bits or Decode64Bits! */\n\t\t/* Remember that from a 32/64 bits ModR/M byte a SIB byte could follow! */\n\t\tif ((rm == 5) && (mod == 0)) {\n\t\t\t/* 5 is a special case - only 32 bits displacement, or RIP relative. */\n\t\t\tdi->dispSize = 32;\n\t\t\tif (!read_stream_safe_sint32(ci, (int64_t*)&di->disp)) return FALSE;\n\n\t\t\t/* Absolute address: */\n\t\t\top->type = O_DISP;\n\n\t\t\tif (ci->dt == Decode64Bits) {\n\t\t\t\t/* In 64 bits decoding mode depsite of the address size, a RIP-relative address it is. */\n\t\t\t\top->type = O_SMEM;\n\t\t\t\top->index = R_RIP;\n\t\t\t\tdi->flags |= FLAG_RIP_RELATIVE;\n\t\t\t}\n\n\t\t\tprefixes_use_segment(INST_PRE_DS, ps, ci->dt, di);\n\t\t}\n\t\telse {\n\t\t\tif (rm == 4) {\n\t\t\t\t/* 4 is a special case - SIB byte + disp8/32 follows! */\n\t\t\t\t/* Read SIB byte. */\n\t\t\t\tif (!read_stream_safe_uint8(ci, &sib)) return FALSE;\n\t\t\t\toperands_extract_sib(di, ps, effAdrSz, sib, mod, op);\n\t\t\t}\n\t\t\telse {\n\t\t\t\top->type = O_SMEM;\n\t\t\t\tif (ps->vrex & PREFIX_EX_B) {\n\t\t\t\t\tps->usedPrefixes |= INST_PRE_REX;\n\t\t\t\t\trm += EX_GPR_BASE;\n\t\t\t\t}\n\n\t\t\t\tif (effAdrSz == Decode64Bits) op->index = (uint8_t)(REGS64_BASE + rm);\n\t\t\t\telse op->index = (uint8_t)(REGS32_BASE + rm);\n\t\t\t}\n\n\t\t\tif (mod == 1) {\n\t\t\t\tdi->dispSize = 8;\n\t\t\t\tif (!read_stream_safe_sint8(ci, (int64_t*)&di->disp)) return FALSE;\n\t\t\t}\n\t\t\telse if ((mod == 2) || ((sib & 7) == 5)) { /* If there is no BASE, read DISP32! */\n\t\t\t\tdi->dispSize = 32;\n\t\t\t\tif (!read_stream_safe_sint32(ci, (int64_t*)&di->disp)) return FALSE;\n\t\t\t}\n\n\t\t\t/* Get the base register. */\n\t\t\tbase = op->index;\n\t\t\tif (di->base != R_NONE) base = di->base;\n\t\t\telse if (di->scale >= 2) base = 0; /* If it's only an index but got scale, it's still DS. */\n\t\t\t/* Default for EBP/ESP is SS segment. 64 bits mode ignores DS anyway. */\n\t\t\tif ((base == R_EBP) || (base == R_ESP)) prefixes_use_segment(INST_PRE_SS, ps, ci->dt, di);\n\t\t\telse prefixes_use_segment(INST_PRE_DS, ps, ci->dt, di);\n\t\t}\n\t}\n\telse { /* Decode16Bits */\n\t\t/* Decoding according to Table 2-1. (16 bits) */\n\t\tif ((mod == 0) && (rm == 6)) {\n\t\t\t/* 6 is a special case - only 16 bits displacement. */\n\t\t\top->type = O_DISP;\n\t\t\tdi->dispSize = 16;\n\t\t\tif (!read_stream_safe_sint16(ci, (int64_t*)&di->disp)) return FALSE;\n\t\t}\n\t\telse {\n\t\t\t/*\n\t\t\t * Create the O_MEM for 16 bits indirection that requires 2 registers, E.G: [BS+SI].\n\t\t\t * or create O_SMEM for a single register indirection, E.G: [BP].\n\t\t\t */\n\t\t\tstatic uint8_t MODS[] = { R_BX, R_BX, R_BP, R_BP, R_SI, R_DI, R_BP, R_BX };\n\t\t\tstatic uint8_t MODS2[] = { R_SI, R_DI, R_SI, R_DI };\n\t\t\tif (rm < 4) {\n\t\t\t\top->type = O_MEM;\n\t\t\t\tdi->base = MODS[rm];\n\t\t\t\tdi->usedRegistersMask |= _REGISTERTORCLASS[MODS[rm]];\n\t\t\t\top->index = MODS2[rm];\n\t\t\t}\n\t\t\telse {\n\t\t\t\top->type = O_SMEM;\n\t\t\t\top->index = MODS[rm];\n\t\t\t}\n\n\t\t\tif (mod == 1) { /* 8 bits displacement + indirection */\n\t\t\t\tdi->dispSize = 8;\n\t\t\t\tif (!read_stream_safe_sint8(ci, (int64_t*)&di->disp)) return FALSE;\n\t\t\t}\n\t\t\telse if (mod == 2) { /* 16 bits displacement + indirection */\n\t\t\t\tdi->dispSize = 16;\n\t\t\t\tif (!read_stream_safe_sint16(ci, (int64_t*)&di->disp)) return FALSE;\n\t\t\t}\n\t\t}\n\n\t\tif ((rm == 2) || (rm == 3) || ((rm == 6) && (mod != 0))) {\n\t\t\t/* BP's default segment is SS, so ignore it. */\n\t\t\tprefixes_use_segment(INST_PRE_SS, ps, ci->dt, di);\n\t\t}\n\t\telse {\n\t\t\t/* Ignore default DS segment. */\n\t\t\tprefixes_use_segment(INST_PRE_DS, ps, ci->dt, di);\n\t\t}\n\t}\n\n\treturn TRUE;\n}", "path": "distorm/src/operands.c", "commit_date": "2020-05-31 00:00:00", "repo_name": "gdabah/distorm", "stars": 1198, "license": "other", "language": "c", "size": 1970}
{"docstring": "/*\n * Read as many prefixes as possible, up to 15 bytes, and halt when we encounter non-prefix byte.\n * This algorithm tries to imitate a real processor, where the same prefix can appear a few times, etc.\n * The tiny complexity is that we want to know when a prefix was superfluous and mark any copy of it as unused.\n * Note that the last prefix of its type will be considered as used, and all the others (of same type) before it as unused.\n */\n", "func_signal": "void prefixes_decode(_CodeInfo* ci, _PrefixState* ps)", "code": "{\n\tconst uint8_t* rexPos = NULL;\n\tconst uint8_t* start = ci->code;\n\tuint8_t byte, vex;\n\t/*\n\t * First thing to do, scan for prefixes, there are six types of prefixes.\n\t * There may be up to six prefixes before a single instruction, not the same type, no special order,\n\t * except REX/VEX must precede immediately the first opcode byte.\n\t * BTW - This is the reason why I didn't make the REP prefixes part of the instructions (STOS/SCAS/etc).\n\t *\n\t * Another thing, the instruction maximum size is 15 bytes, thus if we read more than 15 bytes, we will halt.\n\t *\n\t * We attach all prefixes to the next instruction, there might be two or more occurrences from the same prefix.\n\t * Also, since VEX can be allowed only once we will test it separately.\n\t */\n\tfor (unsigned int index = 0;\n\t\t(ci->codeLen > 0) && (index < INST_MAXIMUM_SIZE);\n\t\tci->code++, ci->codeLen--, index++) {\n\t\t/*\n\t\tNOTE: AMD treat lock/rep as two different groups... But I am based on Intel.\n\n\t\t\t- Lock and Repeat:\n\t\t\t\t- 0xF0  LOCK\n\t\t\t\t- 0xF2  REPNE/REPNZ\n\t\t\t\t- 0xF3 - REP/REPE/REPZ\n\t\t\t- Segment Override:\n\t\t\t\t- 0x2E - CS\n\t\t\t\t- 0x36 - SS\n\t\t\t\t- 0x3E - DS\n\t\t\t\t- 0x26 - ES\n\t\t\t\t- 0x64 - FS\n\t\t\t\t- 0x65 - GS\n\t\t\t- Operand-Size Override: 0x66, switching default size.\n\t\t\t- Address-Size Override: 0x67, switching default size.\n\n\t\t64 Bits:\n\t\t\t- REX: 0x40 - 0x4f, extends register access.\n\t\t\t- 2 Bytes VEX: 0xc4\n\t\t\t- 3 Bytes VEX: 0xc5\n\t\t32 Bits:\n\t\t\t- 2 Bytes VEX: 0xc4 11xx-xxxx\n\t\t\t- 3 Bytes VEX: 0xc5 11xx-xxxx\n\t\t*/\n\n\t\t/* Examine what type of prefix we got. */\n\t\tbyte = *ci->code;\n\t\tswitch (byte)\n\t\t{\n\t\tcase PREFIX_OP_SIZE: {/* Op Size type: */\n\t\t\tps->decodedPrefixes |= INST_PRE_OP_SIZE;\n\t\t\tprefixes_track_unused(ps, index, PFXIDX_OP_SIZE);\n\t\t} break;\n\t\t\t/* Look for both common arch prefixes. */\n\t\tcase PREFIX_LOCK: {\n\t\t\t/* LOCK and REPx type: */\n\t\t\tps->decodedPrefixes |= INST_PRE_LOCK;\n\t\t\tprefixes_track_unused(ps, index, PFXIDX_LOREP);\n\t\t} break;\n\t\tcase PREFIX_REPNZ: {\n\t\t\tps->decodedPrefixes |= INST_PRE_REPNZ;\n\t\t\tprefixes_track_unused(ps, index, PFXIDX_LOREP);\n\t\t} break;\n\t\tcase PREFIX_REP: {\n\t\t\tps->decodedPrefixes |= INST_PRE_REP;\n\t\t\tprefixes_track_unused(ps, index, PFXIDX_LOREP);\n\t\t} break;\n\t\tcase PREFIX_CS: {\n\t\t\t/* Seg Overide type: */\n\t\t\tps->decodedPrefixes &= ~INST_PRE_SEGOVRD_MASK;\n\t\t\tps->decodedPrefixes |= INST_PRE_CS;\n\t\t\tprefixes_track_unused(ps, index, PFXIDX_SEG);\n\t\t} break;\n\t\tcase PREFIX_SS: {\n\t\t\tps->decodedPrefixes &= ~INST_PRE_SEGOVRD_MASK;\n\t\t\tps->decodedPrefixes |= INST_PRE_SS;\n\t\t\tprefixes_track_unused(ps, index, PFXIDX_SEG);\n\t\t} break;\n\t\tcase PREFIX_DS: {\n\t\t\tps->decodedPrefixes &= ~INST_PRE_SEGOVRD_MASK;\n\t\t\tps->decodedPrefixes |= INST_PRE_DS;\n\t\t\tprefixes_track_unused(ps, index, PFXIDX_SEG);\n\t\t} break;\n\t\tcase PREFIX_ES: {\n\t\t\tps->decodedPrefixes &= ~INST_PRE_SEGOVRD_MASK;\n\t\t\tps->decodedPrefixes |= INST_PRE_ES;\n\t\t\tprefixes_track_unused(ps, index, PFXIDX_SEG);\n\t\t} break;\n\t\tcase PREFIX_FS: {\n\t\t\tps->decodedPrefixes &= ~INST_PRE_SEGOVRD_MASK;\n\t\t\tps->decodedPrefixes |= INST_PRE_FS;\n\t\t\tprefixes_track_unused(ps, index, PFXIDX_SEG);\n\t\t} break;\n\t\tcase PREFIX_GS: {\n\t\t\tps->decodedPrefixes &= ~INST_PRE_SEGOVRD_MASK;\n\t\t\tps->decodedPrefixes |= INST_PRE_GS;\n\t\t\tprefixes_track_unused(ps, index, PFXIDX_SEG);\n\t\t} break;\n\t\tcase PREFIX_ADDR_SIZE: {\n\t\t\t/* Addr Size type: */\n\t\t\tps->decodedPrefixes |= INST_PRE_ADDR_SIZE;\n\t\t\tprefixes_track_unused(ps, index, PFXIDX_ADRS);\n\t\t} break;\n\t\tdefault:\n\t\t\tif (ci->dt == Decode64Bits) {\n\t\t\t\t/* REX type, 64 bits decoding mode only: */\n\t\t\t\tif ((byte & 0xf0) == 0x40) {\n\t\t\t\t\tps->decodedPrefixes |= INST_PRE_REX;\n\t\t\t\t\trexPos = ci->code;\n\t\t\t\t\tps->vrex = byte & 0xf; /* Keep only BXRW. */\n\t\t\t\t\tps->prefixExtType = PET_REX;\n\t\t\t\t\tprefixes_track_unused(ps, index, PFXIDX_REX);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto _Break2;\n\t\t}\n\t}\n_Break2:\n\n\t/* 2 Bytes VEX: */\n\tif ((ci->codeLen >= 2) &&\n\t\t(*ci->code == PREFIX_VEX2b) &&\n\t\t((ci->code - start) <= INST_MAXIMUM_SIZE - 2)) {\n\t\t/*\n\t\t * In 32 bits the second byte has to be in the special range of Mod=11.\n\t\t * Otherwise it might be a normal LDS instruction.\n\t\t */\n\t\tif ((ci->dt == Decode64Bits) || (*(ci->code + 1) >= INST_DIVIDED_MODRM)) {\n\t\t\tps->vexPos = ci->code + 1;\n\t\t\tps->decodedPrefixes |= INST_PRE_VEX;\n\t\t\tps->prefixExtType = PET_VEX2BYTES;\n\n\t\t\t/*\n\t\t\t * VEX 1 byte bits:\n\t\t\t * |7-6--3-2-10|\n\t\t\t * |R|vvvv|L|pp|\n\t\t\t * |-----------|\n\t\t\t */\n\n\t\t\t/* -- Convert from VEX prefix to VREX flags -- */\n\t\t\tvex = *ps->vexPos;\n\t\t\tif (!(vex & 0x80) && (ci->dt == Decode64Bits)) ps->vrex |= PREFIX_EX_R; /* Convert VEX.R. */\n\t\t\tif (vex & 4) ps->vrex |= PREFIX_EX_L; /* Convert VEX.L. */\n\n\t\t\tci->code += 2;\n\t\t\tci->codeLen -= 2;\n\t\t}\n\t}\n\n\t/* 3 Bytes VEX: */\n\tif ((ci->codeLen >= 3) &&\n\t\t(*ci->code == PREFIX_VEX3b) &&\n\t\t((ci->code - start) <= INST_MAXIMUM_SIZE - 3) &&\n\t\t(!(ps->decodedPrefixes & INST_PRE_VEX))) {\n\t\t/*\n\t\t * In 32 bits the second byte has to be in the special range of Mod=11.\n\t\t * Otherwise it might be a normal LES instruction.\n\t\t * And we don't care now about the 3rd byte.\n\t\t */\n\t\tif ((ci->dt == Decode64Bits) || (*(ci->code + 1) >= INST_DIVIDED_MODRM)) {\n\t\t\tps->vexPos = ci->code + 1;\n\t\t\tps->decodedPrefixes |= INST_PRE_VEX;\n\t\t\tps->prefixExtType = PET_VEX3BYTES;\n\n\t\t\t/*\n\t\t\t * VEX first and second bytes:\n\t\t\t * |7-6-5-4----0|  |7-6--3-2-10|\n\t\t\t * |R|X|B|m-mmmm|  |W|vvvv|L|pp|\n\t\t\t * |------------|  |-----------|\n\t\t\t */\n\n\t\t\t/* -- Convert from VEX prefix to VREX flags -- */\n\t\t\tvex = *ps->vexPos;\n\t\t\tps->vrex |= ((~vex >> 5) & 0x7); /* Shift and invert VEX.R/X/B to their place */\n\t\t\tvex = *(ps->vexPos + 1);\n\t\t\tif (vex & 4) ps->vrex |= PREFIX_EX_L; /* Convert VEX.L. */\n\t\t\tif (vex & 0x80) ps->vrex |= PREFIX_EX_W; /* Convert VEX.W. */\n\n\t\t\t/* Clear some flags if the mode isn't 64 bits. */\n\t\t\tif (ci->dt != Decode64Bits) ps->vrex &= ~(PREFIX_EX_B | PREFIX_EX_X | PREFIX_EX_R | PREFIX_EX_W);\n\n\t\t\tci->code += 3;\n\t\t\tci->codeLen -= 3;\n\t\t}\n\t}\n\n\tif (ci->dt == Decode64Bits) {\n\t\tif (ps->decodedPrefixes & INST_PRE_REX) {\n\t\t\t/* REX prefix must precede first byte of instruction. */\n\t\t\tif (rexPos != (ci->code - 1)) {\n\t\t\t\tps->decodedPrefixes &= ~INST_PRE_REX;\n\t\t\t\tif (ps->prefixExtType == PET_REX) ps->prefixExtType = PET_NONE; /* It might be a VEX by now, keep it that way. */\n\t\t\t\tprefixes_ignore(ps, PFXIDX_REX);\n\t\t\t}\n\t\t\t/*\n\t\t\t * We will disable operand size prefix,\n\t\t\t * if it exists only after decoding the instruction, since it might be a mandatory prefix.\n\t\t\t * This will be done after calling inst_lookup in decode_inst.\n\t\t\t */\n\t\t}\n\t\t/* In 64 bits, segment overrides of CS, DS, ES and SS are ignored. So don't take'em into account. */\n\t\tif (ps->decodedPrefixes & INST_PRE_SEGOVRD_MASK32) {\n\t\t\tps->decodedPrefixes &= ~INST_PRE_SEGOVRD_MASK32;\n\t\t\tprefixes_ignore(ps, PFXIDX_SEG);\n\t\t}\n\t}\n\n\t/* Store number of prefixes scanned. */\n\tps->count = (uint8_t)(ci->code - start);\n}", "path": "distorm/src/prefix.c", "commit_date": "2020-05-15 00:00:00", "repo_name": "gdabah/distorm", "stars": 1198, "license": "other", "language": "c", "size": 1970}
{"docstring": "/* Helper function to concatenate an explicit size when it's unknown from the operands. */\n", "func_signal": "static void distorm_format_size(unsigned char** str, const _DInst* di, int opNum)", "code": "{\n\tint isSizingRequired = 0;\n\t/*\n\t * We only have to output the size explicitly if it's not clear from the operands.\n\t * For example:\n\t * mov al, [0x1234] -> The size is 8, we know it from the AL register operand.\n\t * mov [0x1234], 0x11 -> Now we don't know the size. Pam pam pam\n\t *\n\t * If given operand number is higher than 2, then output the size anyways.\n\t */\n\tisSizingRequired = ((opNum >= 2) || ((opNum == 0) && (di->ops[0].type != O_REG) && (di->ops[1].type != O_REG)));\n\n\t/* Still not sure? Try some special instructions. */\n\tif (!isSizingRequired) {\n\t\t/*\n\t\t * INS/OUTS are exception, because DX is a port specifier and not a real src/dst register.\n\t\t * A few exceptions that always requires sizing:\n\t\t * MOVZX, MOVSX, MOVSXD.\n\t\t * ROL, ROR, RCL, RCR, SHL, SHR, SAL, SAR.\n\t\t * SHLD, SHRD.\n\t\t */\n\t\tswitch (di->opcode)\n\t\t{\n\t\t\tcase I_INS:\n\t\t\tcase I_OUTS:\n\t\t\tcase I_MOVZX:\n\t\t\tcase I_MOVSX:\n\t\t\tcase I_MOVSXD:\n\t\t\tcase I_ROL:\n\t\t\tcase I_ROR:\n\t\t\tcase I_RCL:\n\t\t\tcase I_RCR:\n\t\t\tcase I_SHL:\n\t\t\tcase I_SHR:\n\t\t\tcase I_SAL:\n\t\t\tcase I_SAR:\n\t\t\tcase I_SHLD:\n\t\t\tcase I_SHRD:\n\t\t\t\tisSizingRequired = 1;\n\t\t\tbreak;\n\t\t\tdefault: /* Instruction doesn't require sizing. */ break;\n\t\t}\n\t}\n\n\tif (isSizingRequired)\n\t{\n\t\t/*case 0: break; OT_MEM's unknown size. */\n\t\tswitch (di->ops[opNum].size / 8)\n\t\t{\n\t\t\tcase 1: strcat_WS(*str,  \"BYTE    \", 8, 5); break;\n\t\t\tcase 2: strcat_WS(*str,  \"WORD    \", 8, 5); break;\n\t\t\tcase 4: strcat_WS(*str,  \"DWORD   \", 8, 6); break;\n\t\t\tcase 8: strcat_WS(*str,  \"QWORD   \", 8, 6); break;\n\t\t\tcase 10: strcat_WS(*str, \"TBYTE   \", 8, 6); break;\n\t\t\tcase 16: strcat_WS(*str, \"DQWORD  \", 8, 7); break;\n\t\t\tcase 32: strcat_WS(*str, \"YWORD   \", 8, 6); break;\n\t\t}\n\t}\n}", "path": "distorm/src/distorm.c", "commit_date": "2020-08-03 00:00:00", "repo_name": "gdabah/distorm", "stars": 1198, "license": "other", "language": "c", "size": 1970}
{"docstring": "/*\n * decode_internal\n *\n * supportOldIntr - Since now we work with new structure instead of the old _DecodedInst, we are still interested in backward compatibility.\n *                  So although, the array is now of type _DInst, we want to read it in jumps of the old array element's size.\n *                  This is in order to save memory allocation for conversion between the new and the old structures.\n *                  It really means we can do the conversion in-place now.\n */\n", "func_signal": "_DecodeResult decode_internal(_CodeInfo* _ci, int supportOldIntr, _DInst result[], unsigned int maxResultCount, unsigned int* usedInstructionsCount)", "code": "{\n\t_CodeInfo ci = *_ci; /* A working copy, we don't touch user's _ci except OUT params. */\n\t_PrefixState ps;\n\t/* Bookkeep these from ci below, as it makes things way simpler. */\n\tconst uint8_t* code;\n\tint codeLen;\n\t_OffsetType codeOffset;\n\n\t_DecodeResult ret = DECRES_SUCCESS;\n\n\t/* Current working decoded instruction in results. */\n\t_DInst* pdi = (_DInst*)&result[0]; /* There's always a room for at least one slot, checked earlier. */\n\t_DInst* maxResultAddr;\n\n\tunsigned int features = ci.features;\n\n\tunsigned int diStructSize;\n\t/* Use next entry. */\n#ifndef DISTORM_LIGHT\n\tif (supportOldIntr) {\n\t\tdiStructSize = sizeof(_DecodedInst);\n\t\tmaxResultAddr = (_DInst*)((size_t)&result[0] + (maxResultCount * sizeof(_DecodedInst)));\n\t}\n\telse\n#endif /* DISTORM_LIGHT */\n\t{\n\t\tdiStructSize = sizeof(_DInst);\n\t\tmaxResultAddr = &result[maxResultCount];\n\t}\n\n\tci.addrMask = (_OffsetType)-1;\n\n#ifdef DISTORM_LIGHT\n\tsupportOldIntr; /* Unreferenced. */\n\n\t/*\n\t * Only truncate address if we are using the decompose interface.\n\t * Otherwise, we use the textual interface which needs full addresses for formatting bytes output.\n\t * So distorm_format will truncate later.\n\t */\n\tif (features & DF_MAXIMUM_ADDR32) ci.addrMask = 0xffffffff;\n\telse if (features & DF_MAXIMUM_ADDR16) ci.addrMask = 0xffff;\n#endif\n\n\tps.count = 1; /* Force zero'ing ps below. */\n\n\t/* Decode instructions as long as we have what to decode/enough room in entries. */\n\twhile (ci.codeLen > 0) {\n\t\tcode = ci.code;\n\t\tcodeLen = ci.codeLen;\n\t\tcodeOffset = ci.codeOffset;\n\n\t\tif (ps.count) memset(&ps, 0, sizeof(ps));\n\n\t\t/**** INSTRUCTION DECODING NEXT: ****/\n\n\t\t/* Make sure we didn't run out of output entries. */\n\t\tif (pdi >= maxResultAddr) {\n\t\t\tret = DECRES_MEMORYERR;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = decode_inst(&ci, &ps, code, pdi);\n\t\t/* decode_inst keeps track (only if successful!) for code and codeLen but ignores codeOffset, fix it here. */\n\t\tci.codeOffset += pdi->size;\n\n\t\tif (ret == DECRES_SUCCESS) {\n\n\t\t\tif (features & (DF_SINGLE_BYTE_STEP | DF_RETURN_FC_ONLY | DF_STOP_ON_PRIVILEGED | DF_STOP_ON_FLOW_CONTROL)) {\n\n\t\t\t\t/* Sync codeinfo, remember that currently it points to beginning of the instruction and prefixes if any. */\n\t\t\t\tif (features & DF_SINGLE_BYTE_STEP) {\n\t\t\t\t\tci.code = code + 1;\n\t\t\t\t\tci.codeLen = codeLen - 1;\n\t\t\t\t\tci.codeOffset = codeOffset + 1;\n\t\t\t\t}\n\n\t\t\t\t/* See if we need to filter this instruction. */\n\t\t\t\tif ((features & DF_RETURN_FC_ONLY) && (META_GET_FC(pdi->meta) == FC_NONE)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/* Check whether we need to stop on any feature. */\n\t\t\t\tif ((features & DF_STOP_ON_PRIVILEGED) && (FLAG_GET_PRIVILEGED(pdi->flags))) {\n\t\t\t\t\tpdi = (_DInst*)((char*)pdi + diStructSize);\n\t\t\t\t\tbreak; /* ret = DECRES_SUCCESS; */\n\t\t\t\t}\n\n\t\t\t\tif (features & DF_STOP_ON_FLOW_CONTROL) {\n\t\t\t\t\tunsigned int mfc = META_GET_FC(pdi->meta);\n\t\t\t\t\tif (mfc && (((features & DF_STOP_ON_CALL) && (mfc == FC_CALL)) ||\n\t\t\t\t\t\t((features & DF_STOP_ON_RET) && (mfc == FC_RET)) ||\n\t\t\t\t\t\t((features & DF_STOP_ON_SYS) && (mfc == FC_SYS)) ||\n\t\t\t\t\t\t((features & DF_STOP_ON_UNC_BRANCH) && (mfc == FC_UNC_BRANCH)) ||\n\t\t\t\t\t\t((features & DF_STOP_ON_CND_BRANCH) && (mfc == FC_CND_BRANCH)) ||\n\t\t\t\t\t\t((features & DF_STOP_ON_INT) && (mfc == FC_INT)) ||\n\t\t\t\t\t\t((features & DF_STOP_ON_CMOV) && (mfc == FC_CMOV)) ||\n\t\t\t\t\t\t((features & DF_STOP_ON_HLT) && (mfc == FC_HLT)))) {\n\t\t\t\t\t\tpdi = (_DInst*)((char*)pdi + diStructSize);\n\t\t\t\t\t\tbreak; /* ret = DECRES_SUCCESS; */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Allocate at least one more entry to use, for the next instruction. */\n\t\t\tpdi = (_DInst*)((char*)pdi + diStructSize);\n\t\t}\n\t\telse { /* ret == DECRES_INPUTERR */\n\n\t\t\t/* Handle failure of decoding last instruction. */\n\t\t\tif ((!(features & DF_RETURN_FC_ONLY))) {\n\t\t\t\tmemset(pdi, 0, sizeof(_DInst));\n\t\t\t\tpdi->flags = FLAG_NOT_DECODABLE;\n\t\t\t\tpdi->imm.byte = *code;\n\t\t\t\tpdi->size = 1;\n\t\t\t\tpdi->addr = codeOffset & ci.addrMask;\n\t\t\t\tpdi = (_DInst*)((char*)pdi + diStructSize);\n\n\t\t\t\t/* If an instruction wasn't decoded then stop on undecodeable if set. */\n\t\t\t\tif (features & DF_STOP_ON_UNDECODEABLE) {\n\t\t\t\t\tret = DECRES_SUCCESS;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Skip a single byte in case of a failure and retry instruction. */\n\t\t\tci.code = code + 1;\n\t\t\tci.codeLen = codeLen - 1;\n\t\t\tci.codeOffset = codeOffset + 1;\n\n\t\t\t/* Reset return value. */\n\t\t\tret = DECRES_SUCCESS;\n\t\t}\n\t}\n\n\t/* Set OUT params. */\n\t*usedInstructionsCount = (unsigned int)(((size_t)pdi - (size_t)result) / (size_t)diStructSize);\n\t_ci->nextOffset = ci.codeOffset;\n\n\treturn ret;\n}", "path": "distorm/src/decoder.c", "commit_date": "2020-08-03 00:00:00", "repo_name": "gdabah/distorm", "stars": 1198, "license": "other", "language": "c", "size": 1970}
{"docstring": "/* A helper function to read a signed integer from the stream safely. */\n", "func_signal": "_INLINE_ int read_stream_safe_sint8(_CodeInfo* ci, int64_t* result)", "code": "{\n\tci->codeLen -= 1;\n\tif (ci->codeLen < 0) return FALSE;\n\t*result = *(int8_t*)ci->code;\n\tci->code += 1;\n\treturn TRUE;\n}", "path": "distorm/src/operands.c", "commit_date": "2020-05-31 00:00:00", "repo_name": "gdabah/distorm", "stars": 1198, "license": "other", "language": "c", "size": 1970}
{"docstring": "/* A helper function to fix the 8 bits register if REX is used (to support SIL, DIL, etc). */\n", "func_signal": "_INLINE_ unsigned int _FASTCALL_ operands_fix_8bit_rex_base(unsigned int reg)", "code": "{\n\tif ((reg >= 4) && (reg < 8)) return reg + REGS8_REX_BASE - 4;\n\treturn reg + REGS8_BASE;\n}", "path": "distorm/src/operands.c", "commit_date": "2020-05-31 00:00:00", "repo_name": "gdabah/distorm", "stars": 1198, "license": "other", "language": "c", "size": 1970}
{"docstring": "/* A helper function to set operand's type, size and index. */\n", "func_signal": "_INLINE_ void operands_set_tsi(_DInst* di, _Operand* op, _OperandType type, uint16_t size, unsigned int index)", "code": "{\n\top->type = type;\n\top->index = (uint8_t)index;\n\top->size = size;\n\tdi->usedRegistersMask |= _REGISTERTORCLASS[index];\n}", "path": "distorm/src/operands.c", "commit_date": "2020-05-31 00:00:00", "repo_name": "gdabah/distorm", "stars": 1198, "license": "other", "language": "c", "size": 1970}
{"docstring": "/* A helper function to look up special VEX instructions.\n * See if it's a MOD based instruction and fix index if required.\n * Only after a first lookup (that was done by caller), we can tell if we need to fix the index.\n * Because these are coupled instructions\n * (which means that the base instruction hints about the other instruction).\n * Note that caller should check if it's a MOD dependent instruction before getting in here.\n */\n", "func_signal": "static _InstInfo* inst_vex_mod_lookup(_CodeInfo* ci, _InstNode in, _InstInfo* ii, unsigned int index)", "code": "{\n\t/* Advance to read the MOD from ModRM byte. */\n\tci->code += 1;\n\tci->codeLen -= 1;\n\tif (ci->codeLen < 0) return NULL;\n\tif (*ci->code < INST_DIVIDED_MODRM) {\n\t\t/* MOD is not 11, therefore change the index to 8 - 12 range in the prefixed table. */\n\t\tindex += 4;\n\t\t/* Make a second lookup for this special instruction. */\n\t\treturn inst_get_info(in, index);\n\t}\n\t/* Return the original one, in case we didn't find a suited instruction. */\n\treturn ii;\n}", "path": "distorm/src/instructions.c", "commit_date": "2020-05-16 00:00:00", "repo_name": "gdabah/distorm", "stars": 1198, "license": "other", "language": "c", "size": 1970}
{"docstring": "/* If DECRES_SUCCESS is returned, CI is in sync, otherwise it loses sync. */\n/* Important note: CI is keeping track only for code and codeLen, in case of a failure caller has to restart on their own. */\n", "func_signal": "static _DecodeResult decode_inst(_CodeInfo* ci, _PrefixState* ps, const uint8_t* startCode, _DInst* di)", "code": "{\n\t/* Holds the info about the current found instruction. */\n\t_InstInfo* ii;\n\t_InstSharedInfo* isi;\n\n\t/* Calculate (and cache) effective-operand-size and effective-address-size only once. */\n\t_DecodeType effOpSz, effAdrSz;\n\t_iflags instFlags;\n\n\t/* The ModR/M byte of the current instruction. */\n\tunsigned int modrm = 0;\n\tint isPrefixed = 0;\n\n\tii = inst_lookup(ci, ps, &isPrefixed);\n\tif (ii == NULL) goto _Undecodable;\n\n\tisi = &InstSharedInfoTable[ii->sharedIndex];\n\tinstFlags = FlagsTable[isi->flagsIndex];\n\n\t/* Cache the effective operand-size and address-size. */\n\tif (isPrefixed) {\n\n\t\t/*\n\t\t* If both REX and OpSize are available we will have to disable the OpSize, because REX has precedence.\n\t\t* However, only if REX.W is set!\n\t\t* We had to wait with this test, since the operand size may be a mandatory prefix,\n\t\t* and we know it only after fetching opcode.\n\t\t*/\n\t\tif ((ps->decodedPrefixes & INST_PRE_OP_SIZE) &&\n\t\t\t(ps->prefixExtType == PET_REX) &&\n\t\t\t(ps->vrex & PREFIX_EX_W) &&\n\t\t\t(!ps->isOpSizeMandatory)) {\n\t\t\tps->decodedPrefixes &= ~INST_PRE_OP_SIZE;\n\t\t\tprefixes_ignore(ps, PFXIDX_OP_SIZE);\n\t\t}\n\n\t\teffAdrSz = decode_get_effective_addr_size(ci->dt, ps->decodedPrefixes);\n\t\teffOpSz = decode_get_effective_op_size(ci->dt, ps->decodedPrefixes, ps->vrex, instFlags);\n\t}\n\telse\n\t{\n\t\teffAdrSz = ci->dt; /* Default is current decoding type since there's no prefix. */\n\t\teffOpSz = decode_get_effective_op_size(ci->dt, 0, 0, instFlags);\n\t}\n\n\t/*\n\t * In this point we know the instruction we are about to decode and its operands (unless, it's an invalid one!),\n\t * so it makes it the right time for decoding-type suitability testing.\n\t * Which practically means, don't allow 32 bits instructions in 16 bits decoding mode, but do allow\n\t * 16 bits instructions in 32 bits decoding mode, of course...\n\n\t * NOTE: Make sure the instruction set for 32 bits has explicitly this specific flag set.\n\t * NOTE2: Make sure the instruction set for 64 bits has explicitly this specific flag set.\n\n\t * If this is the case, drop what we've got and restart all over after DB'ing that byte.\n\n\t * Though, don't drop an instruction which is also supported in 16 and 32 bits.\n\t */\n\n\t /* ! ! ! DISABLED UNTIL FURTHER NOTICE ! ! ! Decode16Bits CAN NOW DECODE 32 BITS INSTRUCTIONS ! ! !*/\n\t /* if (ii && (dt == Decode16Bits) && (instFlags & INST_32BITS) && (~instFlags & INST_16BITS)) ii = NULL; */\n\n\tmemset(di, 0, sizeof(_DInst));\n\n\tif (instFlags & INST_MODRM_REQUIRED) {\n\t\t/* If the ModRM byte is not part of the opcode, skip the last byte code, so code points now to ModRM. */\n\t\tif (!(instFlags & INST_MODRM_INCLUDED)) {\n\t\t\tci->code++;\n\t\t\tif (--ci->codeLen < 0) goto _Undecodable;\n\t\t}\n\t\tmodrm = *ci->code;\n\t}\n\n\tci->code++; /* Skip the last byte we just read (either last opcode's byte code or a ModRM). */\n\n\tdi->addr = ci->codeOffset & ci->addrMask;\n\tdi->opcode = ii->opcodeId;\n\tdi->flags = isi->meta & META_INST_PRIVILEGED;\n\n\t/*\n\t * Store the address size inside the flags.\n\t * This is necessary for the caller to know the size of rSP when using PUSHA for example.\n\t */\n\tdi->base = R_NONE;\n\tdi->segment = R_NONE;\n\n\tFLAG_SET_ADDRSIZE(di, effAdrSz);\n\n\t/* Try to extract the next operand only if the latter exists. */\n\tif (isi->d != OT_NONE) {\n\t\tunsigned int opsNo = 1;\n\t\t_Operand* op = &di->ops[0];\n\t\tif (instFlags & (INST_MODRR_REQUIRED | INST_FORCE_REG0)) {\n\t\t\t/* Some instructions enforce that mod=11, so validate that. */\n\t\t\tif ((modrm < INST_DIVIDED_MODRM) && (instFlags & INST_MODRR_REQUIRED)) goto _Undecodable;\n\t\t\t/* Some instructions enforce that reg=000, so validate that. (Specifically EXTRQ). */\n\t\t\tif ((instFlags & INST_FORCE_REG0) && (((modrm >> 3) & 7) != 0)) goto _Undecodable;\n\t\t}\n\t\tif (!operands_extract(ci, di, ii, instFlags, (_OpType)isi->d, modrm, ps, effOpSz, effAdrSz, op++)) goto _Undecodable;\n\n\t\tif (isi->s != OT_NONE) {\n\t\t\tif (!operands_extract(ci, di, ii, instFlags, (_OpType)isi->s, modrm, ps, effOpSz, effAdrSz, op++)) goto _Undecodable;\n\t\t\topsNo++;\n\t\t\t/* Use third operand, only if the flags says this InstInfo requires it. */\n\t\t\tif (instFlags & INST_USE_OP3) {\n\t\t\t\tif (!operands_extract(ci, di, ii, instFlags, (_OpType)((_InstInfoEx*)ii)->op3, modrm, ps, effOpSz, effAdrSz, op++)) goto _Undecodable;\n\t\t\t\topsNo++;\n\t\t\t\t/* Support for a fourth operand is added for (e.g:) INSERTQ instruction. */\n\t\t\t\tif (instFlags & INST_USE_OP4) {\n\t\t\t\t\tif (!operands_extract(ci, di, ii, instFlags, (_OpType)((_InstInfoEx*)ii)->op4, modrm, ps, effOpSz, effAdrSz, op++)) goto _Undecodable;\n\t\t\t\t\topsNo++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Copy DST_WR flag. */\n\t\tdi->flags |= (instFlags & INST_DST_WR) >> (31 - 6); /* Copy bit from INST_DST_WR (bit 31) to FLAG_DST_WR (bit 6). */\n\t\t/* operands_extract may touched it for FPU operands, so add on top. */\n\t\tdi->opsNo += (uint8_t)opsNo;\n\t}\n\n\tif (instFlags & (INST_3DNOW_FETCH |\n\t\tINST_PSEUDO_OPCODE |\n\t\tINST_NATIVE |\n\t\tINST_PRE_REPNZ |\n\t\tINST_PRE_REP |\n\t\tINST_PRE_ADDR_SIZE |\n\t\tINST_INVALID_64BITS |\n\t\tINST_64BITS_FETCH)) { /* 8 for 1! */\n\n\t\t/* If it's a native instruction copy OpSize Prefix. */\n\t\tif (ps && instFlags & INST_NATIVE) ps->usedPrefixes |= (ps->decodedPrefixes & INST_PRE_OP_SIZE);\n\n\t\tif (ci->dt != Decode64Bits) {\n\t\t\t/* If it's only a 64 bits instruction drop it in other decoding modes. */\n\t\t\tif (instFlags & INST_64BITS_FETCH) goto _Undecodable;\n\t\t}\n\t\telse {\n\t\t\t/* Drop instructions which are invalid in 64 bits. */\n\t\t\tif (instFlags & INST_INVALID_64BITS) goto _Undecodable;\n\t\t}\n\n\t\t/* If it were a 3DNow! instruction, we will have to find the instruction itself now that we got its operands extracted. */\n\t\tif (instFlags & INST_3DNOW_FETCH) {\n\t\t\tii = inst_lookup_3dnow(ci);\n\t\t\tif (ii == NULL) goto _Undecodable;\n\t\t\tisi = &InstSharedInfoTable[ii->sharedIndex];\n\t\t\tinstFlags = FlagsTable[isi->flagsIndex];\n\t\t\tdi->opcode = ii->opcodeId;\n\t\t}\n\n\t\t/* Check whether pseudo opcode is needed, only for CMP instructions: */\n\t\tif (instFlags & INST_PSEUDO_OPCODE) {\n\t\t\t/* Used only for special CMP instructions which have pseudo opcodes suffix. */\n\t\t\tunsigned int cmpType;\n\n\t\t\tif (--ci->codeLen < 0) goto _Undecodable;\n\t\t\tcmpType = *ci->code;\n\t\t\tci->code++;\n\n\t\t\t/*\n\t\t\t * The opcodeId is the offset to the FIRST pseudo compare mnemonic,\n\t\t\t * we will have to fix it so it offsets into the corrected mnemonic.\n\t\t\t * Therefore, we use another table to fix the offset.\n\t\t\t */\n\t\t\tif (instFlags & INST_PRE_VEX) {\n\t\t\t\t/* AVX Comparison type must be between 0 to 32, otherwise Reserved. */\n\t\t\t\tif (cmpType >= INST_VCMP_MAX_RANGE) goto _Undecodable;\n\n\t\t\t\t/* Use the AVX pseudo compare mnemonics table. */\n\t\t\t\tdi->opcode = ii->opcodeId + VCmpMnemonicOffsets[cmpType];\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* SSE Comparison type must be between 0 to 8, otherwise Reserved. */\n\t\t\t\tif (cmpType >= INST_CMP_MAX_RANGE) goto _Undecodable;\n\t\t\t\tdi->opcode = ii->opcodeId + CmpMnemonicOffsets[cmpType];\n\t\t\t}\n\n\t\t\tgoto _SkipOpcoding;\n\t\t}\n\n\t\t/* Start with prefix REP/N/Z. */\n\t\tif (isPrefixed && (instFlags & (INST_PRE_REPNZ | INST_PRE_REP))) {\n\t\t\tif ((instFlags & INST_PRE_REPNZ) && (ps->decodedPrefixes & INST_PRE_REPNZ)) {\n\t\t\t\tps->usedPrefixes |= INST_PRE_REPNZ;\n\t\t\t\tdi->flags |= FLAG_REPNZ;\n\t\t\t}\n\t\t\telse if ((instFlags & INST_PRE_REP) && (ps->decodedPrefixes & INST_PRE_REP)) {\n\t\t\t\tps->usedPrefixes |= INST_PRE_REP;\n\t\t\t\tdi->flags |= FLAG_REP;\n\t\t\t}\n\t\t}\n\n\t\tif (instFlags & INST_PRE_ADDR_SIZE) {\n\t\t\t/* If it's JeCXZ the ADDR_SIZE prefix affects them. */\n\t\t\tif (instFlags & INST_USE_EXMNEMONIC) {\n\t\t\t\tps->usedPrefixes |= INST_PRE_ADDR_SIZE;\n\t\t\t\tif (effAdrSz == Decode16Bits) di->opcode = ii->opcodeId;\n\t\t\t\telse if (effAdrSz == Decode32Bits) di->opcode = ((_InstInfoEx*)ii)->opcodeId2;\n\t\t\t\t/* Ignore REX.W in 64bits, JECXZ is promoted. */\n\t\t\t\telse /* Decode64Bits */ di->opcode = ((_InstInfoEx*)ii)->opcodeId3;\n\t\t\t}\n\n\t\t\t/* LOOPxx instructions are also native instruction, but they are special case ones, ADDR_SIZE prefix affects them. */\n\t\t\telse if (instFlags & INST_NATIVE) {\n\t\t\t\tdi->opcode = ii->opcodeId;\n\n\t\t\t\t/* If LOOPxx gets here from 64bits, it must be Decode32Bits because Address Size prefix is set. */\n\t\t\t\tps->usedPrefixes |= INST_PRE_ADDR_SIZE;\n\t\t\t}\n\n\t\t\tgoto _SkipOpcoding;\n\t\t}\n\t}\n\n\t/*\n\t * If we reached here the instruction was fully decoded, we located the instruction in the DB and extracted operands.\n\t * Use the correct mnemonic according to the DT.\n\t * If we are in 32 bits decoding mode it doesn't necessarily mean we will choose mnemonic2, alas,\n\t * it means that if there is a mnemonic2, it will be used.\n\t * Note:\n\t * If the instruction is prefixed by operand size we will format it in the non-default decoding mode!\n\t * So there might be a situation that an instruction of 32 bit gets formatted in 16 bits decoding mode.\n\t * Both ways should end up with a correct and expected formatting of the text.\n\t */\n\tif (effOpSz == Decode32Bits) { /* Decode32Bits */\n\n\t\t/* Set operand size. */\n\t\tFLAG_SET_OPSIZE(di, Decode32Bits);\n\n\t\t/* Give a chance for special mnemonic instruction in 32 bits decoding. */\n\t\tif (instFlags & INST_USE_EXMNEMONIC) {\n\t\t\t/* Is it a special instruction which has another mnemonic for mod=11 ? */\n\t\t\tif (instFlags & INST_MNEMONIC_MODRM_BASED) {\n\t\t\t\tif (modrm < INST_DIVIDED_MODRM) di->opcode = ((_InstInfoEx*)ii)->opcodeId2;\n\t\t\t}\n\t\t\telse di->opcode = ((_InstInfoEx*)ii)->opcodeId2;\n\t\t\tps->usedPrefixes |= INST_PRE_OP_SIZE;\n\t\t}\n\t}\n\telse if (effOpSz == Decode64Bits) { /* Decode64Bits, note that some instructions might be decoded in Decode32Bits above. */\n\n\t\t/* Set operand size. */\n\t\tFLAG_SET_OPSIZE(di, Decode64Bits);\n\n\t\tif (instFlags & (INST_USE_EXMNEMONIC | INST_USE_EXMNEMONIC2)) {\n\t\t\t/*\n\t\t\t * We shouldn't be here for MODRM based mnemonics with a MOD=11,\n\t\t\t * because they must not use REX (otherwise it will get to the wrong instruction which share same opcode).\n\t\t\t * See XRSTOR and XSAVEOPT.\n\t\t\t */\n\t\t\tif ((modrm >= INST_DIVIDED_MODRM) && (instFlags & INST_MNEMONIC_MODRM_BASED)) goto _Undecodable;\n\n\t\t\t/* Use third mnemonic, for 64 bits. */\n\t\t\tif ((instFlags & INST_USE_EXMNEMONIC2) && (ps->vrex & PREFIX_EX_W)) {\n\t\t\t\tps->usedPrefixes |= INST_PRE_REX;\n\t\t\t\tdi->opcode = ((_InstInfoEx*)ii)->opcodeId3;\n\t\t\t}\n\t\t\telse di->opcode = ((_InstInfoEx*)ii)->opcodeId2; /* Use second mnemonic. */\n\t\t}\n\t}\n\telse { /* Decode16Bits */\n\n\t\t/* Set operand size. */\n\t\tFLAG_SET_OPSIZE(di, Decode16Bits);\n\n\t\t/*\n\t\t * If it's a special instruction which has two mnemonics, then use the 16 bits one + update usedPrefixes.\n\t\t * Note: use 16 bits mnemonic if that instruction supports 32 bit or 64 bit explicitly.\n\t\t */\n\t\tif ((instFlags & (INST_USE_EXMNEMONIC | INST_32BITS | INST_64BITS)) == INST_USE_EXMNEMONIC) ps->usedPrefixes |= INST_PRE_OP_SIZE;\n\t}\n\n_SkipOpcoding:\n\n\t/* Check VEX mnemonics: */\n\tif (isPrefixed && (instFlags & INST_PRE_VEX) &&\n\t\t(((((_InstInfoEx*)ii)->flagsEx & INST_MNEMONIC_VEXW_BASED) && (ps->vrex & PREFIX_EX_W)) ||\n\t\t\t((((_InstInfoEx*)ii)->flagsEx & INST_MNEMONIC_VEXL_BASED) && (ps->vrex & PREFIX_EX_L)))) {\n\t\tdi->opcode = ((_InstInfoEx*)ii)->opcodeId2;\n\t}\n\n\t/* Instruction's size should include prefixes too if exist. */\n\tdi->size = (uint8_t)(ci->code - startCode);\n\t/*\n\t * There's a limit of 15 bytes on instruction length. The only way to violate\n\t * this limit is by putting redundant prefixes before an instruction.\n\t * start points to first prefix if any, otherwise it points to instruction first byte.\n\t */\n\tif (di->size > INST_MAXIMUM_SIZE) goto _Undecodable;\n\n\t/* Set the unused prefixes mask, if any prefixes (not) used at all. */\n\tif (isPrefixed) di->unusedPrefixesMask = prefixes_set_unused_mask(ps);\n\n\t/* Copy instruction meta. */\n\tdi->meta = isi->meta;\n\n\tif (ci->features & DF_FILL_EFLAGS) {\n\t\t/* Copy CPU affected flags. */\n\t\tif (isi->testedFlagsMask) CONVERT_FLAGS_TO_EFLAGS(di, isi, testedFlagsMask);\n\t\tif (isi->modifiedFlagsMask) CONVERT_FLAGS_TO_EFLAGS(di, isi, modifiedFlagsMask);\n\t\tif (isi->undefinedFlagsMask) CONVERT_FLAGS_TO_EFLAGS(di, isi, undefinedFlagsMask);\n\t}\n\n\t/*\n\t * Instruction can still be invalid if it's total length is over 15 bytes with prefixes.\n\t * Up to the caller to check that.\n\t */\n\treturn DECRES_SUCCESS;\n\n_Undecodable: /* If the instruction couldn't be decoded for some reason, fail. */\n\t/* Special case for WAIT instruction: If it's dropped as a prefix, we have to return a valid instruction! */\n\tif (*startCode == INST_WAIT_INDEX) {\n\t\tint delta;\n\t\tmemset(di, 0, sizeof(_DInst));\n\t\tdi->addr = ci->codeOffset & ci->addrMask;\n\t\tdi->imm.byte = INST_WAIT_INDEX;\n\t\tdi->segment = R_NONE;\n\t\tdi->base = R_NONE;\n\t\tdi->size = 1;\n\t\tdi->opcode = I_WAIT;\n\t\tMETA_SET_ISC(di, ISC_INTEGER);\n\n\t\t/* Fix ci because WAIT could be a prefix that failed, and ci->code is now out of sync. */\n\t\tdelta = (int)(ci->code - startCode); /* How many bytes we read so far. */\n\t\tci->codeLen += delta - 1;\n\t\tci->code = startCode + 1;\n\t\t/* codeOffset is fixed outside. */\n\n\t\treturn DECRES_SUCCESS;\n\t}\n\n\t/* Mark that we didn't manage to decode the instruction well, caller will drop it. */\n\treturn DECRES_INPUTERR;\n}", "path": "distorm/src/decoder.c", "commit_date": "2020-08-03 00:00:00", "repo_name": "gdabah/distorm", "stars": 1198, "license": "other", "language": "c", "size": 1970}
{"docstring": "/* A helper function to read an unsigned integer from the stream safely. */\n", "func_signal": "_INLINE_ int read_stream_safe_uint32(_CodeInfo* ci, void* result)", "code": "{\n\tci->codeLen -= 4;\n\tif (ci->codeLen < 0) return FALSE;\n\t*(uint32_t*)result = RULONG(ci->code);\n\tci->code += 4;\n\treturn TRUE;\n}", "path": "distorm/src/operands.c", "commit_date": "2020-05-31 00:00:00", "repo_name": "gdabah/distorm", "stars": 1198, "license": "other", "language": "c", "size": 1970}
{"docstring": "/*\n * Mark a prefix as unused, and bookkeep where we last saw this same type,\n * because in the future we might want to disable it too.\n */\n", "func_signal": "_INLINE_ void prefixes_track_unused(_PrefixState* ps, int index, _PrefixIndexer pi)", "code": "{\n\t/* Mark the previously used prefix (if exists) in the unused mask. */\n\tprefixes_ignore(ps, pi);\n\t/* Book-keep the current index for this type. */\n\tps->pfxIndexer[pi] = 1 << index;\n}", "path": "distorm/src/prefix.c", "commit_date": "2020-05-15 00:00:00", "repo_name": "gdabah/distorm", "stars": 1198, "license": "other", "language": "c", "size": 1970}
{"docstring": "/*\n * A helper function to look up the correct inst-info structure.\n * It does one fetch from the index-table, and then another to get the inst-info.\n * Note that it takes care about basic inst-info or inst-info-ex.\n * The caller should worry about boundary checks and whether it accesses a last-level table.\n */\n", "func_signal": "static _InstInfo* inst_get_info(_InstNode in, int index)", "code": "{\n\tint instIndex = 0;\n\n\tin = InstructionsTree[INST_NODE_INDEX(in) + index];\n\tif (in == INT_NOTEXISTS) return NULL;\n\n\tinstIndex = INST_NODE_INDEX(in);\n\treturn INST_NODE_TYPE(in) == INT_INFO ? &InstInfos[instIndex] : (_InstInfo*)&InstInfosEx[instIndex];\n}", "path": "distorm/src/instructions.c", "commit_date": "2020-05-16 00:00:00", "repo_name": "gdabah/distorm", "stars": 1198, "license": "other", "language": "c", "size": 1970}
{"docstring": "/* A helper function to set operand's type and size. */\n", "func_signal": "_INLINE_ void operands_set_ts(_Operand* op, _OperandType type, uint16_t size)", "code": "{\n\top->type = type;\n\top->size = size;\n}", "path": "distorm/src/operands.c", "commit_date": "2020-05-31 00:00:00", "repo_name": "gdabah/distorm", "stars": 1198, "license": "other", "language": "c", "size": 1970}
{"docstring": "/* Cache all ID's and classes! Release in unload. */\n", "func_signal": "jint JNI_OnLoad(JavaVM *vm, void *reserved)", "code": "{\n\tjclass jCls = NULL;\n\tJNIEnv* env = NULL;\n\n\tif ((*vm)->GetEnv(vm, (void**)&env, JNI_VERSION_1_6) != JNI_OK) {\n\t\treturn JNI_VERSION_1_6;\n\t}\n\n\tjCls = (*env)->FindClass(env, PACKAGE_PREFIX \"CodeInfo\");\n\tg_CodeInfoIds.jCls = (*env)->NewWeakGlobalRef(env, jCls);\n\tg_CodeInfoIds.ID_CodeOffset = (*env)->GetFieldID(env, jCls, \"mCodeOffset\", \"J\");\n\tg_CodeInfoIds.ID_Code = (*env)->GetFieldID(env, jCls, \"mCode\", \"Ljava/nio/ByteBuffer;\");\n\tg_CodeInfoIds.ID_DecodeType = (*env)->GetFieldID(env, jCls, \"mDecodeType\", \"I\");\n\tg_CodeInfoIds.ID_Features = (*env)->GetFieldID(env, jCls, \"mFeatures\", \"I\");\n\n\tjCls = (*env)->FindClass(env, PACKAGE_PREFIX \"DecodedResult\");\n\tg_DecodedResultIds.jCls = (*env)->NewWeakGlobalRef(env, jCls);\n\tg_DecodedResultIds.ID_MaxInstructions = (*env)->GetFieldID(env, jCls, \"mMaxInstructions\", \"I\");\n\tg_DecodedResultIds.ID_Instructions = (*env)->GetFieldID(env, jCls, \"mInstructions\", \"[L\" PACKAGE_PREFIX \"DecodedInst;\");\n\n\tjCls = (*env)->FindClass(env, PACKAGE_PREFIX \"DecodedInst\");\n\tg_DecodedInstIds.jCls = (*env)->NewWeakGlobalRef(env, jCls);\n\tg_DecodedInstIds.ID_Mnemonic = (*env)->GetFieldID(env, jCls, \"mMnemonic\", \"Ljava/lang/String;\");\n\tg_DecodedInstIds.ID_Operands = (*env)->GetFieldID(env, jCls, \"mOperands\", \"Ljava/lang/String;\");\n\tg_DecodedInstIds.ID_Hex = (*env)->GetFieldID(env, jCls, \"mHex\", \"Ljava/lang/String;\");\n\tg_DecodedInstIds.ID_Size = (*env)->GetFieldID(env, jCls, \"mSize\", \"I\");\n\tg_DecodedInstIds.ID_Offset = (*env)->GetFieldID(env, jCls, \"mOffset\", \"J\");\n\n\tjCls = (*env)->FindClass(env, PACKAGE_PREFIX \"DecomposedResult\");\n\tg_DecomposedResultIds.jCls = (*env)->NewWeakGlobalRef(env, jCls);\n\tg_DecomposedResultIds.ID_Instructions = (*env)->GetFieldID(env, jCls, \"mInstructions\", \"[L\" PACKAGE_PREFIX \"DecomposedInst;\");\n\tg_DecomposedResultIds.ID_MaxInstructions = (*env)->GetFieldID(env, jCls, \"mMaxInstructions\", \"I\");\n\n\tjCls = (*env)->FindClass(env, PACKAGE_PREFIX \"DecomposedInst\");\n\tg_DecomposedInstIds.jCls = (*env)->NewWeakGlobalRef(env, jCls);\n\tg_DecomposedInstIds.ID_Address = (*env)->GetFieldID(env, jCls, \"mAddr\", \"J\");\n\tg_DecomposedInstIds.ID_Size = (*env)->GetFieldID(env, jCls, \"mSize\", \"I\");\n\tg_DecomposedInstIds.ID_Flags = (*env)->GetFieldID(env, jCls, \"mFlags\", \"I\");\n\tg_DecomposedInstIds.ID_Segment = (*env)->GetFieldID(env, jCls, \"mSegment\", \"I\");\n\tg_DecomposedInstIds.ID_Base = (*env)->GetFieldID(env, jCls, \"mBase\", \"I\");\n\tg_DecomposedInstIds.ID_Scale = (*env)->GetFieldID(env, jCls, \"mScale\", \"I\");\n\tg_DecomposedInstIds.ID_Opcode = (*env)->GetFieldID(env, jCls, \"mOpcode\", \"I\");\n\tg_DecomposedInstIds.ID_Operands = (*env)->GetFieldID(env, jCls, \"mOperands\", \"[L\" PACKAGE_PREFIX \"Operand;\");\n\tg_DecomposedInstIds.ID_Disp = (*env)->GetFieldID(env, jCls, \"mDisp\", \"L\" PACKAGE_PREFIX \"DecomposedInst$DispVariant;\");\n\tg_DecomposedInstIds.ID_Imm = (*env)->GetFieldID(env, jCls, \"mImm\", \"L\" PACKAGE_PREFIX \"DecomposedInst$ImmVariant;\");\n\tg_DecomposedInstIds.ID_UnusedPrefixesMask = (*env)->GetFieldID(env, jCls, \"mUnusedPrefixesMask\", \"I\");\n\tg_DecomposedInstIds.ID_Meta = (*env)->GetFieldID(env, jCls, \"mMeta\", \"I\");\n\tg_DecomposedInstIds.ID_RegistersMask = (*env)->GetFieldID(env, jCls, \"mRegistersMask\", \"I\");\n\tg_DecomposedInstIds.ID_ModifiedFlagsMask = (*env)->GetFieldID(env, jCls, \"mModifiedFlagsMask\", \"I\");\n\tg_DecomposedInstIds.ID_TestedFlagsMask = (*env)->GetFieldID(env, jCls, \"mTestedFlagsMask\", \"I\");\n\tg_DecomposedInstIds.ID_UndefinedFlagsMask = (*env)->GetFieldID(env, jCls, \"mUndefinedFlagsMask\", \"I\");\n\n\tjCls = (*env)->FindClass(env, PACKAGE_PREFIX \"Operand\");\n\tg_OperandIds.jCls = (*env)->NewWeakGlobalRef(env, jCls);\n\tg_OperandIds.ID_Type = (*env)->GetFieldID(env, jCls, \"mType\", \"I\");\n\tg_OperandIds.ID_Index = (*env)->GetFieldID(env, jCls, \"mIndex\", \"I\");\n\tg_OperandIds.ID_Size = (*env)->GetFieldID(env, jCls, \"mSize\", \"I\");\n\n\tjCls = (*env)->FindClass(env, PACKAGE_PREFIX \"DecomposedInst$ImmVariant\");\n\tg_ImmIds.jCls = (*env)->NewWeakGlobalRef(env, jCls);\n\tg_ImmIds.ID_Value = (*env)->GetFieldID(env, jCls, \"mValue\", \"J\");\n\tg_ImmIds.ID_Size = (*env)->GetFieldID(env, jCls, \"mSize\", \"I\");\n\n\tjCls = (*env)->FindClass(env, PACKAGE_PREFIX \"DecomposedInst$DispVariant\");\n\tg_DispIds.jCls = (*env)->NewWeakGlobalRef(env, jCls);\n\tg_DispIds.ID_Displacement = (*env)->GetFieldID(env, jCls, \"mDisplacement\", \"J\");\n\tg_DispIds.ID_Size = (*env)->GetFieldID(env, jCls, \"mSize\", \"I\");\n\n\treturn JNI_VERSION_1_6;\n}", "path": "distorm/examples/java/jdistorm.c", "commit_date": "2019-12-24 00:00:00", "repo_name": "gdabah/distorm", "stars": 1198, "license": "other", "language": "c", "size": 1970}
{"docstring": "/* Ignore all prefix. */\n", "func_signal": "void prefixes_ignore_all(_PrefixState* ps)", "code": "{\n\tint i;\n\tfor (i = 0; i < PFXIDX_MAX; i++)\n\t\tprefixes_ignore(ps, i);\n}", "path": "distorm/src/prefix.c", "commit_date": "2020-05-15 00:00:00", "repo_name": "gdabah/distorm", "stars": 1198, "license": "other", "language": "c", "size": 1970}
{"docstring": "/*\n * pool_set_file_open -- (internal) opens pool set file or regular file\n */\n", "func_signal": "static struct pool_set_file *\npool_set_file_open(const char *fname, struct pool_params *params, int rdonly)", "code": "{\n\tLOG(3, NULL);\n\n\tstruct pool_set_file *file = calloc(1, sizeof(*file));\n\tif (!file)\n\t\treturn NULL;\n\n\tfile->fname = strdup(fname);\n\tif (!file->fname)\n\t\tgoto err;\n\n\tconst char *path = file->fname;\n\n\tif (params->type != POOL_TYPE_BTT) {\n\t\tint ret = util_poolset_create_set(&file->poolset, path,\n\t\t\t0, 0, true);\n\t\tif (ret < 0) {\n\t\t\tLOG(2, \"cannot open pool set -- '%s'\", path);\n\t\t\tgoto err_free_fname;\n\t\t}\n\t\tunsigned flags = (rdonly ? POOL_OPEN_COW : 0) |\n\t\t\t\t\tPOOL_OPEN_IGNORE_BAD_BLOCKS;\n\t\tif (util_pool_open_nocheck(file->poolset, flags))\n\t\t\tgoto err_free_fname;\n\n\t\tfile->size = file->poolset->poolsize;\n\n\t\t/* get modification time from the first part of first replica */\n\t\tpath = file->poolset->replica[0]->part[0].path;\n\t\tfile->addr = file->poolset->replica[0]->part[0].addr;\n\t} else {\n\t\tint oflag = rdonly ? O_RDONLY : O_RDWR;\n\t\tfile->fd = util_file_open(fname, NULL, 0, oflag);\n\t\tfile->size = params->size;\n\t}\n\n\tos_stat_t buf;\n\tif (os_stat(path, &buf)) {\n\t\tERR(\"%s\", path);\n\t\tgoto err_close_poolset;\n\t}\n\n\tfile->mtime = buf.st_mtime;\n\tfile->mode = buf.st_mode;\n\treturn file;\n\nerr_close_poolset:\n\tif (params->type != POOL_TYPE_BTT)\n\t\tutil_poolset_close(file->poolset, DO_NOT_DELETE_PARTS);\n\telse if (file->fd != -1)\n\t\tos_close(file->fd);\nerr_free_fname:\n\tfree(file->fname);\nerr:\n\tfree(file);\n\treturn NULL;\n}", "path": "pmdk/src/libpmempool/pool.c", "commit_date": "2020-02-12 00:00:00", "repo_name": "pmem/pmdk", "stars": 1317, "license": "other", "language": "c", "size": 81227}
{"docstring": "/*\n * util_uuid_generate -- generate a uuid\n *\n * This function reads the uuid string from  /proc/sys/kernel/random/uuid\n * It converts this string into the binary uuid format as specified in\n * https://www.ietf.org/rfc/rfc4122.txt\n */\n", "func_signal": "int\nutil_uuid_generate(uuid_t uuid)", "code": "{\n\tchar uu[POOL_HDR_UUID_STR_LEN];\n\n\tint fd = os_open(POOL_HDR_UUID_GEN_FILE, O_RDONLY);\n\tif (fd < 0) {\n\t\t/* Fatal error */\n\t\tLOG(2, \"!open(uuid)\");\n\t\treturn -1;\n\t}\n\tssize_t num = read(fd, uu, POOL_HDR_UUID_STR_LEN);\n\tif (num < POOL_HDR_UUID_STR_LEN) {\n\t\t/* Fatal error */\n\t\tLOG(2, \"!read(uuid)\");\n\t\tos_close(fd);\n\t\treturn -1;\n\t}\n\tos_close(fd);\n\n\tuu[POOL_HDR_UUID_STR_LEN - 1] = '\\0';\n\tint ret = util_uuid_from_string(uu, (struct uuid *)uuid);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}", "path": "pmdk/src/common/uuid_linux.c", "commit_date": "2020-02-12 00:00:00", "repo_name": "pmem/pmdk", "stars": 1317, "license": "other", "language": "c", "size": 81227}
{"docstring": "/*\n * pool_check_type_to_pool_type -- (internal) convert check pool type to\n *\tinternal pool type value\n */\n", "func_signal": "static enum pool_type\npool_check_type_to_pool_type(enum pmempool_pool_type check_pool_type)", "code": "{\n\tswitch (check_pool_type) {\n\tcase PMEMPOOL_POOL_TYPE_LOG:\n\t\treturn POOL_TYPE_LOG;\n\tcase PMEMPOOL_POOL_TYPE_BLK:\n\t\treturn POOL_TYPE_BLK;\n\tcase PMEMPOOL_POOL_TYPE_OBJ:\n\t\treturn POOL_TYPE_OBJ;\n\tdefault:\n\t\tERR(\"can not convert pmempool_pool_type %u to pool_type\",\n\t\t\tcheck_pool_type);\n\t\treturn POOL_TYPE_UNKNOWN;\n\t}\n}", "path": "pmdk/src/libpmempool/pool.c", "commit_date": "2020-02-12 00:00:00", "repo_name": "pmem/pmdk", "stars": 1317, "license": "other", "language": "c", "size": 81227}
{"docstring": "/*\n * pool_get_pool_type_str -- return human-readable pool type string\n */\n", "func_signal": "const char *\npool_get_pool_type_str(enum pool_type type)", "code": "{\n\tswitch (type) {\n\tcase POOL_TYPE_BTT:\n\t\treturn \"btt\";\n\tcase POOL_TYPE_LOG:\n\t\treturn \"pmemlog\";\n\tcase POOL_TYPE_BLK:\n\t\treturn \"pmemblk\";\n\tcase POOL_TYPE_OBJ:\n\t\treturn \"pmemobj\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}", "path": "pmdk/src/libpmempool/pool.c", "commit_date": "2020-02-12 00:00:00", "repo_name": "pmem/pmdk", "stars": 1317, "license": "other", "language": "c", "size": 81227}
{"docstring": "/*\n * pool_blk_get_first_valid_arena -- get first valid BTT Info in arena\n */\n", "func_signal": "int\npool_blk_get_first_valid_arena(struct pool_data *pool, struct arena *arenap)", "code": "{\n\tarenap->zeroed = true;\n\tuint64_t offset = pool_get_first_valid_btt(pool, &arenap->btt_info,\n\t\t2 * BTT_ALIGNMENT, &arenap->zeroed);\n\n\tif (offset != 0) {\n\t\tarenap->offset = offset;\n\t\tarenap->valid = true;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}", "path": "pmdk/src/libpmempool/pool.c", "commit_date": "2020-02-12 00:00:00", "repo_name": "pmem/pmdk", "stars": 1317, "license": "other", "language": "c", "size": 81227}
{"docstring": "/*\n * pool_params_from_header -- parse pool params from pool header\n */\n", "func_signal": "void\npool_params_from_header(struct pool_params *params, const struct pool_hdr *hdr)", "code": "{\n\tmemcpy(params->signature, hdr->signature, sizeof(params->signature));\n\tmemcpy(&params->features, &hdr->features, sizeof(params->features));\n\n\t/*\n\t * Check if file is a part of pool set by comparing the UUID with the\n\t * next part UUID. If it is the same it means the pool consist of a\n\t * single file.\n\t */\n\tint uuid_eq_next = uuidcmp(hdr->uuid, hdr->next_part_uuid);\n\tint uuid_eq_prev = uuidcmp(hdr->uuid, hdr->prev_part_uuid);\n\tparams->is_part = !params->is_poolset && (uuid_eq_next || uuid_eq_prev);\n\n\tparams->type = pool_hdr_get_type(hdr);\n}", "path": "pmdk/src/libpmempool/pool.c", "commit_date": "2020-02-12 00:00:00", "repo_name": "pmem/pmdk", "stars": 1317, "license": "other", "language": "c", "size": 81227}
{"docstring": "/*\n * pool_set_map -- (internal) map poolset\n */\n", "func_signal": "static int\npool_set_map(const char *fname, struct pool_set **poolset, unsigned flags)", "code": "{\n\tASSERTeq(util_is_poolset_file(fname), 1);\n\n\tstruct pool_hdr hdr;\n\tif (pool_set_read_header(fname, &hdr))\n\t\treturn -1;\n\n\tutil_convert2h_hdr_nocheck(&hdr);\n\n\t/* parse pool type from first pool set file */\n\tenum pool_type type = pool_hdr_get_type(&hdr);\n\tif (type == POOL_TYPE_UNKNOWN) {\n\t\tERR(\"cannot determine pool type from poolset\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Open the poolset, the values passed to util_pool_open are read\n\t * from the first poolset file, these values are then compared with\n\t * the values from all headers of poolset files.\n\t */\n\tstruct pool_attr attr;\n\tutil_pool_hdr2attr(&attr, &hdr);\n\tif (util_pool_open(poolset, fname, 0 /* minpartsize */, &attr,\n\t\t\t\tNULL, NULL, flags | POOL_OPEN_IGNORE_SDS |\n\t\t\t\t\t\tPOOL_OPEN_IGNORE_BAD_BLOCKS)) {\n\t\tERR(\"opening poolset failed\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}", "path": "pmdk/src/libpmempool/pool.c", "commit_date": "2020-02-12 00:00:00", "repo_name": "pmem/pmdk", "stars": 1317, "license": "other", "language": "c", "size": 81227}
{"docstring": "/*\n * pool_hdr_default -- return default pool header values\n */\n", "func_signal": "void\npool_hdr_default(enum pool_type type, struct pool_hdr *hdrp)", "code": "{\n\tmemset(hdrp, 0, sizeof(*hdrp));\n\tconst char *sig = pool_get_signature(type);\n\tASSERTne(sig, NULL);\n\n\tmemcpy(hdrp->signature, sig, POOL_HDR_SIG_LEN);\n\n\tswitch (type) {\n\tcase POOL_TYPE_LOG:\n\t\thdrp->major = LOG_FORMAT_MAJOR;\n\t\thdrp->features = log_format_feat_default;\n\t\tbreak;\n\tcase POOL_TYPE_BLK:\n\t\thdrp->major = BLK_FORMAT_MAJOR;\n\t\thdrp->features = blk_format_feat_default;\n\t\tbreak;\n\tcase POOL_TYPE_OBJ:\n\t\thdrp->major = OBJ_FORMAT_MAJOR;\n\t\thdrp->features = obj_format_feat_default;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}", "path": "pmdk/src/libpmempool/pool.c", "commit_date": "2020-02-12 00:00:00", "repo_name": "pmem/pmdk", "stars": 1317, "license": "other", "language": "c", "size": 81227}
{"docstring": "/*\n * pool_copy -- make a copy of the pool\n */\n", "func_signal": "int\npool_copy(struct pool_data *pool, const char *dst_path, int overwrite)", "code": "{\n\tstruct pool_set_file *file = pool->set_file;\n\tint dfd;\n\tint exists = util_file_exists(dst_path);\n\tif (exists < 0)\n\t\treturn -1;\n\n\tif (exists) {\n\t\tif (!overwrite) {\n\t\t\terrno = EEXIST;\n\t\t\treturn -1;\n\t\t}\n\t\tdfd = util_file_open(dst_path, NULL, 0, O_RDWR);\n\t} else {\n\t\terrno = 0;\n\t\tdfd = util_file_create(dst_path, file->size, 0);\n\t}\n\tif (dfd < 0)\n\t\treturn -1;\n\n\tint result = 0;\n\tos_stat_t stat_buf;\n\tif (os_stat(file->fname, &stat_buf)) {\n\t\tresult = -1;\n\t\tgoto out_close;\n\t}\n\n\tif (fchmod(dfd, stat_buf.st_mode)) {\n\t\tresult = -1;\n\t\tgoto out_close;\n\t}\n\n\tvoid *daddr = mmap(NULL, file->size, PROT_READ | PROT_WRITE,\n\t\tMAP_SHARED, dfd, 0);\n\tif (daddr == MAP_FAILED) {\n\t\tresult = -1;\n\t\tgoto out_close;\n\t}\n\n\tif (pool->params.type != POOL_TYPE_BTT) {\n\t\tvoid *saddr = pool_set_file_map(file, 0);\n\t\tmemcpy(daddr, saddr, file->size);\n\t\tgoto out_unmap;\n\t}\n\n\tvoid *buf = malloc(RW_BUFFERING_SIZE);\n\tif (buf == NULL) {\n\t\tERR(\"!malloc\");\n\t\tresult = -1;\n\t\tgoto out_unmap;\n\t}\n\n\tif (pool_btt_lseek(pool, 0, SEEK_SET) == -1) {\n\t\tresult = -1;\n\t\tgoto out_free;\n\t}\n\tssize_t buf_read = 0;\n\tvoid *dst = daddr;\n\twhile ((buf_read = pool_btt_read(pool, buf, RW_BUFFERING_SIZE))) {\n\t\tif (buf_read == -1)\n\t\t\tbreak;\n\n\t\tmemcpy(dst, buf, (size_t)buf_read);\n\t\tdst  = (void *)((ssize_t)dst + buf_read);\n\t}\n\nout_free:\n\tfree(buf);\nout_unmap:\n\tmunmap(daddr, file->size);\nout_close:\n\t(void) os_close(dfd);\n\treturn result;\n}", "path": "pmdk/src/libpmempool/pool.c", "commit_date": "2020-02-12 00:00:00", "repo_name": "pmem/pmdk", "stars": 1317, "license": "other", "language": "c", "size": 81227}
{"docstring": "/*\n * pool_get_signature -- (internal) return signature of specified pool type\n */\n", "func_signal": "static const char *\npool_get_signature(enum pool_type type)", "code": "{\n\tswitch (type) {\n\tcase POOL_TYPE_LOG:\n\t\treturn LOG_HDR_SIG;\n\tcase POOL_TYPE_BLK:\n\t\treturn BLK_HDR_SIG;\n\tcase POOL_TYPE_OBJ:\n\t\treturn OBJ_HDR_SIG;\n\tdefault:\n\t\treturn NULL;\n\t}\n}", "path": "pmdk/src/libpmempool/pool.c", "commit_date": "2020-02-12 00:00:00", "repo_name": "pmem/pmdk", "stars": 1317, "license": "other", "language": "c", "size": 81227}
{"docstring": "/*\n * pool_btt_lseek -- (internal) perform lseek in BTT file mode\n */\n", "func_signal": "static inline os_off_t\npool_btt_lseek(struct pool_data *pool, os_off_t offset, int whence)", "code": "{\n\tos_off_t result;\n\tif ((result = os_lseek(pool->set_file->fd, offset, whence)) == -1)\n\t\tERR(\"!lseek\");\n\n\treturn result;\n}", "path": "pmdk/src/libpmempool/pool.c", "commit_date": "2020-02-12 00:00:00", "repo_name": "pmem/pmdk", "stars": 1317, "license": "other", "language": "c", "size": 81227}
{"docstring": "/*\n * pool_memset -- memset pool part described by off and count\n */\n", "func_signal": "int\npool_memset(struct pool_data *pool, uint64_t off, int c, size_t count)", "code": "{\n\tint result = 0;\n\n\tif (pool->params.type != POOL_TYPE_BTT)\n\t\tmemset((char *)off, 0, count);\n\telse {\n\t\tif (pool_btt_lseek(pool, (os_off_t)off, SEEK_SET) == -1)\n\t\t\treturn -1;\n\n\t\tsize_t zero_size = min(count, RW_BUFFERING_SIZE);\n\t\tvoid *buf = malloc(zero_size);\n\t\tif (!buf) {\n\t\t\tERR(\"!malloc\");\n\t\t\treturn -1;\n\t\t}\n\t\tmemset(buf, c, zero_size);\n\t\tssize_t nwrite = 0;\n\t\tdo {\n\t\t\tzero_size = min(zero_size, count);\n\t\t\tnwrite = pool_btt_write(pool, buf, zero_size);\n\t\t\tif (nwrite < 0) {\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount -= (size_t)nwrite;\n\t\t} while (count > 0);\n\n\t\tfree(buf);\n\t}\n\n\treturn result;\n}", "path": "pmdk/src/libpmempool/pool.c", "commit_date": "2020-02-12 00:00:00", "repo_name": "pmem/pmdk", "stars": 1317, "license": "other", "language": "c", "size": 81227}
{"docstring": "/*\n * pool_set_read_header -- (internal) read a header of a pool set\n */\n", "func_signal": "static int\npool_set_read_header(const char *fname, struct pool_hdr *hdr)", "code": "{\n\tstruct pool_set *set;\n\tint ret = 0;\n\n\tif (util_poolset_read(&set, fname)) {\n\t\treturn -1;\n\t}\n\t/* open the first part set file to read the pool header values */\n\tconst struct pool_set_part *part = PART(REP(set, 0), 0);\n\tint fdp = util_file_open(part->path, NULL, 0, O_RDONLY);\n\tif (fdp < 0) {\n\t\tERR(\"cannot open poolset part file\");\n\t\tret = -1;\n\t\tgoto err_pool_set;\n\t}\n\n\t/* read the pool header from first pool set file */\n\tif (pread(fdp, hdr, sizeof(*hdr), 0) != sizeof(*hdr)) {\n\t\tERR(\"cannot read pool header from poolset\");\n\t\tret = -1;\n\t\tgoto err_close_part;\n\t}\n\nerr_close_part:\n\tos_close(fdp);\n\nerr_pool_set:\n\tutil_poolset_free(set);\n\treturn ret;\n}", "path": "pmdk/src/libpmempool/pool.c", "commit_date": "2020-02-12 00:00:00", "repo_name": "pmem/pmdk", "stars": 1317, "license": "other", "language": "c", "size": 81227}
{"docstring": "/*\n * test_worker -- (internal) test worker thread\n */\n", "func_signal": "static void *\ntest_worker(void *arg)", "code": "{\n\tutil_mutex_lock(&lock);\n\t/* before pool is closed */\n\tvoid *direct = pmemobj_direct(thread_oid);\n\tUT_ASSERT(OID_EQUALS(thread_oid, pmemobj_oid(direct)));\n\n\tflag = 0;\n\tos_cond_signal(&cond);\n\tutil_mutex_unlock(&lock);\n\n\tutil_mutex_lock(&lock);\n\twhile (flag == 0)\n\t\tos_cond_wait(&cond, &lock);\n\t/* after pool is closed */\n\tUT_ASSERT(OID_IS_NULL(pmemobj_oid(direct)));\n\n\tutil_mutex_unlock(&lock);\n\n\treturn NULL;\n}", "path": "pmdk/src/test/obj_oid_thread/obj_oid_thread.c", "commit_date": "2020-02-12 00:00:00", "repo_name": "pmem/pmdk", "stars": 1317, "license": "other", "language": "c", "size": 81227}
{"docstring": "/*\n * pool_write -- write to pool set file or regular file\n *\n * 'buff' has to be a buffer at least 'nbytes' long\n * 'off' is an offset from the beginning of the pool\n */\n", "func_signal": "int\npool_write(struct pool_data *pool, const void *buff, size_t nbytes,\n\tuint64_t off)", "code": "{\n\tif (off + nbytes > pool->set_file->size)\n\t\treturn -1;\n\n\tif (pool->params.type != POOL_TYPE_BTT) {\n\t\tmemcpy((char *)pool->set_file->addr + off, buff, nbytes);\n\t\tutil_persist_auto(pool->params.is_pmem,\n\t\t\t\t(char *)pool->set_file->addr + off, nbytes);\n\t} else {\n\t\tif (pool_btt_lseek(pool, (os_off_t)off, SEEK_SET) == -1)\n\t\t\treturn -1;\n\t\tif ((size_t)pool_btt_write(pool, buff, nbytes) != nbytes)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}", "path": "pmdk/src/libpmempool/pool.c", "commit_date": "2020-02-12 00:00:00", "repo_name": "pmem/pmdk", "stars": 1317, "license": "other", "language": "c", "size": 81227}
{"docstring": "/*\n * pool_get_first_valid_btt -- return offset to first valid BTT Info\n *\n * - Return offset to valid BTT Info header in pool file.\n * - Start looking from given offset.\n * - Convert BTT Info header to host endianness.\n * - Return the BTT Info header by pointer.\n * - If zeroed pointer provided would check if all checked BTT Info are zeroed\n *\twhich is useful for BLK pools\n */\n", "func_signal": "uint64_t\npool_get_first_valid_btt(struct pool_data *pool, struct btt_info *infop,\n\tuint64_t offset, bool *zeroed)", "code": "{\n\t/* if we have valid arena get BTT Info header from it */\n\tif (pool->narenas != 0) {\n\t\tstruct arena *arenap = PMDK_TAILQ_FIRST(&pool->arenas);\n\t\tmemcpy(infop, &arenap->btt_info, sizeof(*infop));\n\t\treturn arenap->offset;\n\t}\n\n\tconst size_t info_size = sizeof(*infop);\n\n\t/* theoretical offsets to BTT Info header and backup */\n\tuint64_t offsets[2] = {offset, 0};\n\n\twhile (offsets[0] < pool->set_file->size) {\n\t\t/* calculate backup offset */\n\t\toffsets[1] = pool_next_arena_offset(pool, offsets[0]) -\n\t\t\tinfo_size;\n\n\t\t/* check both offsets: header and backup */\n\t\tfor (int i = 0; i < 2; ++i) {\n\t\t\tif (pool_read(pool, infop, info_size, offsets[i]))\n\t\t\t\tcontinue;\n\n\t\t\t/* check if all possible BTT Info are zeroed */\n\t\t\tif (zeroed)\n\t\t\t\t*zeroed &= util_is_zeroed((const void *)infop,\n\t\t\t\t\tinfo_size);\n\n\t\t\t/* check if read BTT Info is valid */\n\t\t\tif (pool_btt_info_valid(infop)) {\n\t\t\t\tbtt_info_convert2h(infop);\n\t\t\t\treturn offsets[i];\n\t\t\t}\n\t\t}\n\n\t\t/* jump to next arena */\n\t\toffsets[0] += BTT_MAX_ARENA;\n\t}\n\n\treturn 0;\n}", "path": "pmdk/src/libpmempool/pool.c", "commit_date": "2020-02-12 00:00:00", "repo_name": "pmem/pmdk", "stars": 1317, "license": "other", "language": "c", "size": 81227}
{"docstring": "/*\n * pool_set_files_count -- get total number of parts of all replicas\n */\n", "func_signal": "unsigned\npool_set_files_count(struct pool_set_file *file)", "code": "{\n\tunsigned ret = 0;\n\tunsigned nreplicas = file->poolset->nreplicas;\n\tfor (unsigned r = 0; r < nreplicas; r++) {\n\t\tstruct pool_replica *rep = file->poolset->replica[r];\n\t\tret += rep->nparts;\n\t}\n\n\treturn ret;\n}", "path": "pmdk/src/libpmempool/pool.c", "commit_date": "2020-02-12 00:00:00", "repo_name": "pmem/pmdk", "stars": 1317, "license": "other", "language": "c", "size": 81227}
{"docstring": "/*\n * pool_parse_params -- parse pool type, file size and block size\n */\n", "func_signal": "static int\npool_params_parse(const PMEMpoolcheck *ppc, struct pool_params *params,\n\tint check)", "code": "{\n\tLOG(3, NULL);\n\tint is_btt = ppc->args.pool_type == PMEMPOOL_POOL_TYPE_BTT;\n\n\tparams->type = POOL_TYPE_UNKNOWN;\n\tparams->is_poolset = util_is_poolset_file(ppc->path) == 1;\n\n\tint fd = util_file_open(ppc->path, NULL, 0, O_RDONLY);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tint ret = 0;\n\n\tos_stat_t stat_buf;\n\tret = os_fstat(fd, &stat_buf);\n\tif (ret)\n\t\tgoto out_close;\n\n\tASSERT(stat_buf.st_size >= 0);\n\n\tparams->mode = stat_buf.st_mode;\n\n\tstruct pool_set *set;\n\tvoid *addr;\n\tif (params->is_poolset) {\n\t\t/*\n\t\t * Need to close the poolset because it will be opened with\n\t\t * flock in the following instructions.\n\t\t */\n\t\tos_close(fd);\n\t\tfd = -1;\n\n\t\tif (check) {\n\t\t\tif (pool_set_map(ppc->path, &set, 0))\n\t\t\t\treturn -1;\n\t\t} else {\n\t\t\tret = util_poolset_create_set(&set, ppc->path,\n\t\t\t\t0, 0, true);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG(2, \"cannot open pool set -- '%s'\",\n\t\t\t\t\tppc->path);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (set->remote) {\n\t\t\t\tERR(\"poolsets with remote replicas are not \"\n\t\t\t\t\t\"supported\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (util_pool_open_nocheck(set,\n\t\t\t\t\t\tPOOL_OPEN_IGNORE_BAD_BLOCKS))\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tparams->size = set->poolsize;\n\t\taddr = set->replica[0]->part[0].addr;\n\n\t\t/*\n\t\t * XXX mprotect for device dax with length not aligned to its\n\t\t * page granularity causes SIGBUS on the next page fault.\n\t\t * The length argument of this call should be changed to\n\t\t * set->poolsize once the kernel issue is solved.\n\t\t */\n\t\tif (mprotect(addr, set->replica[0]->repsize,\n\t\t\tPROT_READ) < 0) {\n\t\t\tERR(\"!mprotect\");\n\t\t\tgoto out_unmap;\n\t\t}\n\t\tparams->is_dev_dax = set->replica[0]->part[0].is_dev_dax;\n\t\tparams->is_pmem = set->replica[0]->is_pmem;\n\t} else if (is_btt) {\n\t\tparams->size = (size_t)stat_buf.st_size;\n#ifndef _WIN32\n\t\tif (params->mode & S_IFBLK)\n\t\t\tif (ioctl(fd, BLKGETSIZE64, &params->size)) {\n\t\t\t\tERR(\"!ioctl\");\n\t\t\t\tgoto out_close;\n\t\t\t}\n#endif\n\t\taddr = NULL;\n\t} else {\n\t\tenum file_type type = util_file_get_type(ppc->path);\n\t\tif (type < 0) {\n\t\t\tret = -1;\n\t\t\tgoto out_close;\n\t\t}\n\n\t\tssize_t s = util_file_get_size(ppc->path);\n\t\tif (s < 0) {\n\t\t\tret = -1;\n\t\t\tgoto out_close;\n\t\t}\n\t\tparams->size = (size_t)s;\n\t\tint map_sync;\n\t\taddr = util_map(fd, 0, params->size, MAP_SHARED, 1, 0,\n\t\t\t&map_sync);\n\t\tif (addr == NULL) {\n\t\t\tret = -1;\n\t\t\tgoto out_close;\n\t\t}\n\t\tparams->is_dev_dax = type == TYPE_DEVDAX;\n\t\tparams->is_pmem = params->is_dev_dax || map_sync ||\n\t\t\tpmem_is_pmem(addr, params->size);\n\t}\n\n\t/* stop processing for BTT device */\n\tif (is_btt) {\n\t\tparams->type = POOL_TYPE_BTT;\n\t\tparams->is_part = false;\n\t\tgoto out_close;\n\t}\n\n\tstruct pool_hdr hdr;\n\tmemcpy(&hdr, addr, sizeof(hdr));\n\tutil_convert2h_hdr_nocheck(&hdr);\n\tpool_params_from_header(params, &hdr);\n\n\tif (ppc->args.pool_type != PMEMPOOL_POOL_TYPE_DETECT) {\n\t\tenum pool_type declared_type =\n\t\t\tpool_check_type_to_pool_type(ppc->args.pool_type);\n\t\tif ((params->type & ~declared_type) != 0) {\n\t\t\tERR(\"declared pool type does not match\");\n\t\t\terrno = EINVAL;\n\t\t\tret = 1;\n\t\t\tgoto out_unmap;\n\t\t}\n\t}\n\n\tif (params->type == POOL_TYPE_BLK) {\n\t\tstruct pmemblk pbp;\n\t\tmemcpy(&pbp, addr, sizeof(pbp));\n\t\tparams->blk.bsize = le32toh(pbp.bsize);\n\t} else if (params->type == POOL_TYPE_OBJ) {\n\t\tstruct pmemobjpool *pop = addr;\n\t\tmemcpy(params->obj.layout, pop->layout,\n\t\t\tPMEMOBJ_MAX_LAYOUT);\n\t}\n\nout_unmap:\n\tif (params->is_poolset) {\n\t\tASSERTeq(fd, -1);\n\t\tASSERTne(addr, NULL);\n\t\tutil_poolset_close(set, DO_NOT_DELETE_PARTS);\n\t} else if (!is_btt) {\n\t\tASSERTne(fd, -1);\n\t\tASSERTne(addr, NULL);\n\t\tmunmap(addr, params->size);\n\t}\nout_close:\n\tif (fd != -1)\n\t\tos_close(fd);\n\treturn ret;\n}", "path": "pmdk/src/libpmempool/pool.c", "commit_date": "2020-02-12 00:00:00", "repo_name": "pmem/pmdk", "stars": 1317, "license": "other", "language": "c", "size": 81227}
{"docstring": "/*\n * pool_set_file_close -- (internal) closes pool set file or regular file\n */\n", "func_signal": "static void\npool_set_file_close(struct pool_set_file *file)", "code": "{\n\tLOG(3, NULL);\n\n\tif (file->poolset)\n\t\tutil_poolset_close(file->poolset, DO_NOT_DELETE_PARTS);\n\telse if (file->addr) {\n\t\tmunmap(file->addr, file->size);\n\t\tos_close(file->fd);\n\t} else if (file->fd)\n\t\tos_close(file->fd);\n\n\tfree(file->fname);\n\tfree(file);\n}", "path": "pmdk/src/libpmempool/pool.c", "commit_date": "2020-02-12 00:00:00", "repo_name": "pmem/pmdk", "stars": 1317, "license": "other", "language": "c", "size": 81227}
{"docstring": "/*\n * pool_data_alloc -- allocate pool data and open set_file\n */\n", "func_signal": "struct pool_data *\npool_data_alloc(PMEMpoolcheck *ppc)", "code": "{\n\tLOG(3, NULL);\n\n\tstruct pool_data *pool = calloc(1, sizeof(*pool));\n\tif (!pool) {\n\t\tERR(\"!calloc\");\n\t\treturn NULL;\n\t}\n\n\tPMDK_TAILQ_INIT(&pool->arenas);\n\tpool->uuid_op = UUID_NOP;\n\n\tif (pool_params_parse(ppc, &pool->params, 0))\n\t\tgoto error;\n\n\tint rdonly = CHECK_IS_NOT(ppc, REPAIR);\n\tint prv = CHECK_IS(ppc, DRY_RUN);\n\n\tif (prv && pool->params.is_dev_dax) {\n\t\terrno = ENOTSUP;\n\t\tERR(\"!cannot perform a dry run on dax device\");\n\t\tgoto error;\n\t}\n\n\tpool->set_file = pool_set_file_open(ppc->path, &pool->params, prv);\n\tif (pool->set_file == NULL)\n\t\tgoto error;\n\n\t/*\n\t * XXX mprotect for device dax with length not aligned to its\n\t * page granularity causes SIGBUS on the next page fault.\n\t * The length argument of this call should be changed to\n\t * pool->set_file->poolsize once the kernel issue is solved.\n\t */\n\tif (rdonly && mprotect(pool->set_file->addr,\n\t\tpool->set_file->poolset->replica[0]->repsize,\n\t\tPROT_READ) < 0)\n\t\tgoto error;\n\n\tif (pool->params.type != POOL_TYPE_BTT) {\n\t\tif (pool_set_file_map_headers(pool->set_file, rdonly, prv))\n\t\t\tgoto error;\n\t}\n\n\treturn pool;\n\nerror:\n\tpool_data_free(pool);\n\treturn NULL;\n}", "path": "pmdk/src/libpmempool/pool.c", "commit_date": "2020-02-12 00:00:00", "repo_name": "pmem/pmdk", "stars": 1317, "license": "other", "language": "c", "size": 81227}
{"docstring": "/* interface */\n", "func_signal": "void desc_load(void)", "code": "{\n\tchar\tfn[SMALLBUF];\n\tPCONF_CTX_t\tctx;\n\n\tsnprintf(fn, sizeof(fn), \"%s/cmdvartab\", datapath);\n\n\tpconf_init(&ctx, desc_file_err);\n\n\t/* this file is not required */\n\tif (!pconf_file_begin(&ctx, fn)) {\n\t\tupslogx(LOG_INFO, \"%s not found - disabling descriptions\", fn);\n\t\tpconf_finish(&ctx);\n\t\treturn;\n\t}\n\n\twhile (pconf_file_next(&ctx)) {\n\t\tif (pconf_parse_error(&ctx)) {\n\t\t\tupslogx(LOG_ERR, \"Parse error: %s:%d: %s\", fn, ctx.linenum, ctx.errmsg);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ctx.numargs < 3) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(ctx.arglist[0], \"CMDDESC\")) {\n\t\t\tdesc_add(&cmd_list, ctx.arglist[1], ctx.arglist[2]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(ctx.arglist[0], \"VARDESC\")) {\n\t\t\tdesc_add(&var_list, ctx.arglist[1], ctx.arglist[2]);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* unknown */\n\t}\n\n\tpconf_finish(&ctx);\n}", "path": "nut/server/desc.c", "commit_date": "2011-01-04 00:00:00", "repo_name": "networkupstools/nut", "stars": 1468, "license": "other", "language": "c", "size": 84787}
{"docstring": "/* FIXME */\n", "func_signal": "static const char * shut_strerror(void)", "code": "{ return \"\"; }\n\n/*!\n * From SHUT specifications\n * sync'ed with libusb\n */\n\ntypedef struct shut_ctrltransfer_s {\n\tuint8_t  bRequestType;\n\tuint8_t  bRequest;\n\tuint16_t wValue;\n\tuint16_t wIndex;\n\tuint16_t wLength;\n\n\tuint32_t timeout;      /* in milliseconds */\n\n\t/* pointer to data */\n\tvoid *data;\n\t/*   uint8_t  padding[8]; for use with shut_set_report?! */\n}", "path": "nut/drivers/libshut.c", "commit_date": "2020-11-29 00:00:00", "repo_name": "networkupstools/nut", "stars": 1468, "license": "other", "language": "c", "size": 84787}
{"docstring": "/* read from a file until a whole line is ready for use */\n", "func_signal": "int pconf_file_next(PCONF_CTX_t *ctx)", "code": "{\n\tif (!check_magic(ctx))\n\t\treturn 0;\n\n\tctx->linenum++;\n\n\t/* start over for the new line */\n\tctx->numargs = 0;\n\tctx->state = STATE_FINDWORDSTART;\n\n\twhile ((ctx->ch = fgetc(ctx->f)) != EOF) {\n\t\tparse_char(ctx);\n\n\t\tif (ctx->state == STATE_PARSEERR)\n\t\t\treturn 1;\n\n\t\tif (ctx->state == STATE_ENDOFLINE)\n\t\t\treturn 1;\n\t}\n\n\t/* deal with files that don't end in a newline */\n\n\tif (ctx->numargs != 0) {\n\n\t\t/* still building a word? */\n\t\tif (ctx->wordptr != ctx->wordbuf)\n\t\t\tendofword(ctx);\n\n\t\treturn 1;\n\t}\n\n\t/* finished with nothing left over */\n\treturn 0;\n}", "path": "nut/common/parseconf.c", "commit_date": "2020-11-20 00:00:00", "repo_name": "networkupstools/nut", "stars": 1468, "license": "other", "language": "c", "size": 84787}
{"docstring": "/* This function allows the subdriver to \"claim\" a device: return 1 if the device is supported by this subdriver, else 0. */\n", "func_signal": "static int\tvoltronic_qs_claim(void)", "code": "{\n\t/* We need at least M and QS to run this subdriver */\n\n\t/* UPS Protocol */\n\titem_t\t*item = find_nut_info(\"ups.firmware.aux\", 0, 0);\n\n\t/* Don't know what happened */\n\tif (!item)\n\t\treturn 0;\n\n\t/* No reply/Unable to get value */\n\tif (qx_process(item, NULL))\n\t\treturn 0;\n\n\t/* Unable to process value/Protocol not supported */\n\tif (ups_infoval_set(item) != 1)\n\t\treturn 0;\n\n\titem = find_nut_info(\"input.voltage\", 0, 0);\n\n\t/* Don't know what happened */\n\tif (!item) {\n\t\tdstate_delinfo(\"ups.firmware.aux\");\n\t\treturn 0;\n\t}\n\n\t/* No reply/Unable to get value */\n\tif (qx_process(item, NULL)) {\n\t\tdstate_delinfo(\"ups.firmware.aux\");\n\t\treturn 0;\n\t}\n\n\t/* Unable to process value */\n\tif (ups_infoval_set(item) != 1) {\n\t\tdstate_delinfo(\"ups.firmware.aux\");\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}", "path": "nut/drivers/nutdrv_qx_voltronic-qs.c", "commit_date": "2020-11-24 00:00:00", "repo_name": "networkupstools/nut", "stars": 1468, "license": "other", "language": "c", "size": 84787}
{"docstring": "/* return 1 if an error occurred, but only do it once */\n", "func_signal": "int pconf_parse_error(PCONF_CTX_t *ctx)", "code": "{\n\tif (!check_magic(ctx))\n\t\treturn 0;\n\n\tif (ctx->error == 1) {\n\t\tctx->error = 0;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}", "path": "nut/common/parseconf.c", "commit_date": "2020-11-20 00:00:00", "repo_name": "networkupstools/nut", "stars": 1468, "license": "other", "language": "c", "size": 84787}
{"docstring": "/**********************************************************************\n * shut_wait_ack()\n *\n * wait for an ACK packet\n *\n * returns 0 on success, -1 on error, -2 on NACK, -3 on NOTIFICATION\n *\n *********************************************************************/\n", "func_signal": "int shut_wait_ack(int arg_upsfd)", "code": "{\n\tint retCode = -1;\n\tunsigned char c = '\\0';\n\n\tser_get_char(arg_upsfd, &c, SHUT_TIMEOUT/1000, 0);\n\tif (c == SHUT_OK)\n\t{\n\t\tupsdebugx (2, \"shut_wait_ack(): ACK received\");\n\t\tretCode = 0;\n\t}\n\telse if (c == SHUT_NOK)\n\t{\n\t\tupsdebugx (2, \"shut_wait_ack(): NACK received\");\n\t\tretCode = -2;\n\t}\n\telse if ((c & 0x0f) == SHUT_TYPE_NOTIFY)\n\t{\n\t\tupsdebugx (2, \"shut_wait_ack(): NOTIFY received\");\n\t\tretCode = -3;\n\t}\n\telse if (c == '\\0')\n\t\tupsdebugx (2, \"shut_wait_ack(): Nothing received\");\n\n\treturn retCode;\n}", "path": "nut/drivers/libshut.c", "commit_date": "2020-11-29 00:00:00", "repo_name": "networkupstools/nut", "stars": 1468, "license": "other", "language": "c", "size": 84787}
{"docstring": "/* clean up memory before going back to the user */\n", "func_signal": "static void free_storage(PCONF_CTX_t *ctx)", "code": "{\n\tunsigned int\ti;\n\n\tfree(ctx->wordbuf);\n\n\t/* clear out the individual words first */\n\tfor (i = 0; i < ctx->maxargs; i++)\n\t\tfree(ctx->arglist[i]);\n\n\tfree(ctx->arglist);\n\tfree(ctx->argsize);\n\n\t/* put things back to the initial state */\n\tctx->arglist = NULL;\n\tctx->argsize = NULL;\n\tctx->numargs = 0;\n\tctx->maxargs = 0;\n}", "path": "nut/common/parseconf.c", "commit_date": "2020-11-20 00:00:00", "repo_name": "networkupstools/nut", "stars": 1468, "license": "other", "language": "c", "size": 84787}
{"docstring": "/* parse a provided line */\n", "func_signal": "int pconf_line(PCONF_CTX_t *ctx, const char *line)", "code": "{\n\tsize_t\ti, linelen;\n\n\tif (!check_magic(ctx))\n\t\treturn 0;\n\n\tctx->linenum++;\n\n\t/* start over for the new line */\n\tctx->numargs = 0;\n\tctx->state = STATE_FINDWORDSTART;\n\n\tlinelen = strlen(line);\n\n\tfor (i = 0; i < linelen; i++) {\n\t\tctx->ch = line[i];\n\n\t\tparse_char(ctx);\n\n\t\tif (ctx->state == STATE_PARSEERR)\n\t\t\treturn 1;\n\n\t\tif (ctx->state == STATE_ENDOFLINE)\n\t\t\treturn 1;\n\t}\n\n\t/* deal with any lingering characters */\n\n\t/* still building a word? */\n\tif (ctx->wordptr != ctx->wordbuf)\n\t\tendofword(ctx);\t\t/* tie it off */\n\n\treturn 1;\n}", "path": "nut/common/parseconf.c", "commit_date": "2020-11-20 00:00:00", "repo_name": "networkupstools/nut", "stars": 1468, "license": "other", "language": "c", "size": 84787}
{"docstring": "/* On success, fill in the curDevice structure and return the report\n * descriptor length. On failure, return -1.\n * Note: When callback is not NULL, the report descriptor will be\n * passed to this function together with the upsfd and SHUTDevice_t\n * information. This callback should return a value > 0 if the device\n * is accepted, or < 1 if not.\n */\n", "func_signal": "static int libshut_open(int *arg_upsfd, SHUTDevice_t *curDevice, char *arg_device_path,\n                 int (*callback)(int arg_upsfd, SHUTDevice_t *hd,\n                 unsigned char *rdbuf, int rdlen))", "code": "{\n\tint ret, res;\n\t/* Below we cast this buffer as sometimes containing entried of type\n\t * \"struct device_descriptor_s\" or \"struct my_hid_descriptor\".\n\t * Currently both of these are sized \"2\", and I don't see a way\n\t * to require a \"max()\" of such sizes to align for generally.\n\t */\n\tunsigned char buf[20] __attribute__((aligned(4)));\n\tchar string[MAX_STRING_SIZE];\n\tstruct my_hid_descriptor *desc;\n\tstruct device_descriptor_s *dev_descriptor;\n\n\t/* report descriptor */\n\tunsigned char\trdbuf[MAX_REPORT_SIZE];\n\tint\t\trdlen;\n\t/* All devices use HID descriptor at index 0. However, some newer\n\t * Eaton units have a light HID descriptor at index 0, and the full\n\t * version is at index 1 (in which case, bcdDevice == 0x0202) */\n\tint hid_desc_index = 0;\n\n\tupsdebugx(2, \"libshut_open: using port %s\", arg_device_path);\n\n\t/* If device is still open, close it */\n\tif (*arg_upsfd > 0) {\n\t\tser_close(*arg_upsfd, arg_device_path);\n\t}\n\n\t/* initialize serial port */\n\t/* FIXME: add variable baudrate detection */\n\t*arg_upsfd = ser_open(arg_device_path);\n\tser_set_speed(*arg_upsfd, arg_device_path, B2400);\n\tsetline(*arg_upsfd, 1);\n\n\t/* initialise communication */\n\tif (!shut_synchronise(*arg_upsfd))\n\t{\n\t\tupsdebugx(2, \"No communication with UPS\");\n\t\treturn -1;\n\t}\n\n\tupsdebugx(2, \"Communication with UPS established\");\n\n\t/* we can skip the rest due to serial bus specifics! */\n\tif (!callback) {\n\t\treturn 1;\n\t}\n\n\t/* Get DEVICE descriptor */\n\tdev_descriptor = (struct device_descriptor_s *)buf;\n\tres = shut_get_descriptor(*arg_upsfd, USB_DT_DEVICE, 0, buf, USB_DT_DEVICE_SIZE);\n\t/* res = shut_control_msg(devp, USB_ENDPOINT_IN+1, USB_REQ_GET_DESCRIPTOR,\n\t(USB_DT_DEVICE << 8) + 0, 0, buf, 0x9, SHUT_TIMEOUT); */\n\tif (res < 0)\n\t{\n\t\tupsdebugx(2, \"Unable to get DEVICE descriptor (%s)\", shut_strerror());\n\t\treturn -1;\n\t}\n\n\tif (res < 9)\n\t{\n\t\tupsdebugx(2, \"DEVICE descriptor too short (expected %d, got %d)\",\n\t\t      USB_DT_DEVICE_SIZE, res);\n\t\treturn -1;\n\t}\n\n\t/* collect the identifying information of this\n\t\tdevice. Note that this is safe, because\n\t\tthere's no need to claim an interface for\n\t\tthis (and therefore we do not yet need to\n\t\tdetach any kernel drivers). */\n\n\tfree(curDevice->Vendor);\n\tfree(curDevice->Product);\n\tfree(curDevice->Serial);\n\tfree(curDevice->Bus);\n\tmemset(curDevice, '\\0', sizeof(*curDevice));\n\n\tcurDevice->VendorID = dev_descriptor->idVendor;\n\tcurDevice->ProductID = dev_descriptor->idProduct;\n\tcurDevice->Bus = strdup(\"serial\");\n\tcurDevice->bcdDevice = dev_descriptor->bcdDevice;\n\tcurDevice->Vendor = strdup(\"Eaton\");\n\tif (dev_descriptor->iManufacturer) {\n\t\tret = shut_get_string_simple(*arg_upsfd, dev_descriptor->iManufacturer,\n\t\t\tstring, MAX_STRING_SIZE);\n\t\tif (ret > 0) {\n\t\t\tcurDevice->Vendor = strdup(string);\n\t\t}\n\t}\n\n\t/* ensure iProduct retrieval */\n\tif (dev_descriptor->iProduct) {\n\t\tret = shut_get_string_simple(*arg_upsfd, dev_descriptor->iProduct, string, MAX_STRING_SIZE);\n\t} else {\n\t\tret = 0;\n\t}\n\tif (ret > 0) {\n\t\tcurDevice->Product = strdup(string);\n\t} else {\n\t\tcurDevice->Product = strdup(\"unknown\");\n\t}\n\n\tif (dev_descriptor->iSerialNumber) {\n\t\tret = shut_get_string_simple(*arg_upsfd, dev_descriptor->iSerialNumber, string, 0x25);\n\t} else {\n\t\tret = 0;\n\t}\n\n\tif (ret > 0) {\n\t\tcurDevice->Serial = strdup(string);\n\t} else {\n\t\tcurDevice->Serial = strdup(\"unknown\");\n\t}\n\n\tupsdebugx(2, \"- VendorID: %04x\", curDevice->VendorID);\n\tupsdebugx(2, \"- ProductID: %04x\", curDevice->ProductID);\n\tupsdebugx(2, \"- Manufacturer: %s\", curDevice->Vendor);\n\tupsdebugx(2, \"- Product: %s\", curDevice->Product);\n\tupsdebugx(2, \"- Serial Number: %s\", curDevice->Serial);\n\tupsdebugx(2, \"- Bus: %s\", curDevice->Bus);\n\tupsdebugx(2, \"- Device release number: %04x\", curDevice->bcdDevice);\n\tupsdebugx(2, \"Device matches\");\n\n\tif ((curDevice->VendorID == 0x463) && (curDevice->bcdDevice == 0x0202)) {\n\t\t\tupsdebugx(1, \"Eaton device v2.02. Using full report descriptor\");\n\t\t\thid_desc_index = 1;\n\t}\n\n\t/* Get HID descriptor */\n\tdesc = (struct my_hid_descriptor *)buf;\n\tres = shut_get_descriptor(*arg_upsfd, USB_DT_HID, hid_desc_index, buf, 0x9);\n\t/* res = shut_control_msg(devp, USB_ENDPOINT_IN+1, USB_REQ_GET_DESCRIPTOR,\n\t\t\t(USB_DT_HID << 8) + 0, 0, buf, 0x9, SHUT_TIMEOUT); */\n\n\tif (res < 0)\n\t{\n\t\tupsdebugx(2, \"Unable to get HID descriptor (%s)\", shut_strerror());\n\t\treturn -1;\n\t}\n\n\tif (res < 9)\n\t{\n\t\tupsdebugx(2, \"HID descriptor too short (expected %d, got %d)\", 8, res);\n\t\treturn -1;\n\t}\n\n\t/* USB_LE16_TO_CPU(desc->wDescriptorLength); */\n\tdesc->wDescriptorLength = buf[7] | (buf[8] << 8);\n\tupsdebugx(2, \"HID descriptor retrieved (Reportlen = %u)\", desc->wDescriptorLength);\n\n/*\n\tif (!dev->config) {\n\t\tupsdebugx(2, \"  Couldn't retrieve descriptors\");\n\t\treturn -1;\n\t}\n*/\n\n\trdlen = desc->wDescriptorLength;\n\n\tif (rdlen > (int)sizeof(rdbuf)) {\n\t\tupsdebugx(2, \"HID descriptor too long %d (max %d)\", rdlen, (int)sizeof(rdbuf));\n\t\treturn -1;\n\t}\n\n\t/* Get REPORT descriptor */\n\tres = shut_get_descriptor(*arg_upsfd, USB_DT_REPORT, hid_desc_index, rdbuf, rdlen);\n\t/* res = shut_control_msg(devp, USB_ENDPOINT_IN+1, USB_REQ_GET_DESCRIPTOR,\n\t\t\t\t(USB_DT_REPORT << 8) + 0, 0, ReportDesc,\n\t\t\tdesc->wDescriptorLength, SHUT_TIMEOUT); */\n\tif (res == rdlen)\n\t{\n\t\tres = callback(*arg_upsfd, curDevice, rdbuf, rdlen);\n\t\tif (res < 1) {\n\t\t\tupsdebugx(2, \"Caller doesn't like this device\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tupsdebugx(2, \"Report descriptor retrieved (Reportlen = %d)\", rdlen);\n\t\tupsdebugx(2, \"Found HID device\");\n\t\tfflush(stdout);\n\n\t\treturn rdlen;\n\t}\n\n\tif (res < 0)\n\t{\n\t\tupsdebugx(2, \"Unable to get Report descriptor (%d)\", res);\n\t}\n\telse\n\t{\n\t\tupsdebugx(2, \"Report descriptor too short (expected %d, got %d)\", rdlen, res);\n\t}\n\n\tupsdebugx(2, \"libshut: No appropriate HID device found\");\n\tfflush(stdout);\n\n\treturn -1;\n}", "path": "nut/drivers/libshut.c", "commit_date": "2020-11-29 00:00:00", "repo_name": "networkupstools/nut", "stars": 1468, "license": "other", "language": "c", "size": 84787}
{"docstring": "/* This function allows the subdriver to \"claim\" a device: return 1 if the device is supported by this subdriver, else 0. */\n", "func_signal": "static int\tmecer_claim(void)", "code": "{\n\t/* Apart from status (Q1), try to identify protocol (QPI, for Voltronic Power P98 units) or whether the UPS uses '(ACK\\r'/'(NAK\\r' replies */\n\n\titem_t\t*item = find_nut_info(\"input.voltage\", 0, 0);\n\n\t/* Don't know what happened */\n\tif (!item)\n\t\treturn 0;\n\n\t/* No reply/Unable to get value */\n\tif (qx_process(item, NULL))\n\t\treturn 0;\n\n\t/* Unable to process value */\n\tif (ups_infoval_set(item) != 1)\n\t\treturn 0;\n\n\t/* UPS Protocol */\n\titem = find_nut_info(\"ups.firmware.aux\", 0, 0);\n\n\t/* Don't know what happened */\n\tif (!item) {\n\t\tdstate_delinfo(\"input.voltage\");\n\t\treturn 0;\n\t}\n\n\t/* No reply/Unable to get value/Command rejected */\n\tif (qx_process(item, NULL)) {\n\n\t\t/* No reply/Command echoed back or rejected with something other than '(NAK\\r' -> Not a '(ACK/(NAK' unit */\n\t\tif (!strlen(item->answer) || strcasecmp(item->answer, \"(NAK\\r\")) {\n\t\t\tdstate_delinfo(\"input.voltage\");\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* Command rejected with '(NAK\\r' -> '(ACK/(NAK' unit */\n\n\t\t/* Skip protocol query from now on */\n\t\titem->qxflags |= QX_FLAG_SKIP;\n\n\t} else {\n\n\t\t/* Unable to process value/Command echoed back or rejected with something other than '(NAK\\r'/Protocol not supported */\n\t\tif (ups_infoval_set(item) != 1) {\n\t\t\tdstate_delinfo(\"input.voltage\");\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* Voltronic Power P98 unit */\n\n\t}\n\n\treturn 1;\n}", "path": "nut/drivers/nutdrv_qx_mecer.c", "commit_date": "2020-11-24 00:00:00", "repo_name": "networkupstools/nut", "stars": 1468, "license": "other", "language": "c", "size": 84787}
{"docstring": "/* Protocol used by the UPS */\n", "func_signal": "static int\tvoltronic_qs_protocol(item_t *item, char *value, const size_t valuelen)", "code": "{\n\tif (strcasecmp(item->value, \"V\")) {\n\t\tupsdebugx(2, \"%s: invalid protocol [%s]\", __func__, item->value);\n\t\treturn -1;\n\t}\n\n#ifdef HAVE_PRAGMAS_FOR_GCC_DIAGNOSTIC_IGNORED_FORMAT_NONLITERAL\n#pragma GCC diagnostic push\n#endif\n#ifdef HAVE_PRAGMA_GCC_DIAGNOSTIC_IGNORED_FORMAT_NONLITERAL\n#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"\n#endif\n#ifdef HAVE_PRAGMA_GCC_DIAGNOSTIC_IGNORED_FORMAT_SECURITY\n#pragma GCC diagnostic ignored \"-Wformat-security\"\n#endif\n\tsnprintf(value, valuelen, item->dfl, item->value);\n#ifdef HAVE_PRAGMAS_FOR_GCC_DIAGNOSTIC_IGNORED_FORMAT_NONLITERAL\n#pragma GCC diagnostic pop\n#endif\n\n\treturn 0;\n}", "path": "nut/drivers/nutdrv_qx_voltronic-qs.c", "commit_date": "2020-11-24 00:00:00", "repo_name": "networkupstools/nut", "stars": 1468, "license": "other", "language": "c", "size": 84787}
{"docstring": "/*\n * set RTS to on and DTR to off\n *\n * set : 1 to set comm\n * set : 0 to stop commupsh.\n */\n", "func_signal": "void setline(int arg_upsfd, int set)", "code": "{\n\tif (arg_upsfd < 1) {\n\t\treturn;\n\t}\n\n\tupsdebugx(3, \"entering setline(%i)\", set);\n\n\tif (set == 1) {\n\t\tser_set_dtr(arg_upsfd, 0);\n\t\tser_set_rts(arg_upsfd, 1);\n\t} else {\n\t\tser_set_dtr(arg_upsfd, 1);\n\t\tser_set_rts(arg_upsfd, 0);\n\t}\n}", "path": "nut/drivers/libshut.c", "commit_date": "2020-11-29 00:00:00", "repo_name": "networkupstools/nut", "stars": 1468, "license": "other", "language": "c", "size": 84787}
{"docstring": "/* Protocol used by the UPS */\n", "func_signal": "static int\tvoltronic_p98_protocol(item_t *item, char *value, const size_t valuelen)", "code": "{\n\tif (strcasecmp(item->value, \"PI98\")) {\n\t\tupslogx(LOG_ERR, \"Protocol [%s] is not supported by this driver\", item->value);\n\t\treturn -1;\n\t}\n\n#ifdef HAVE_PRAGMAS_FOR_GCC_DIAGNOSTIC_IGNORED_FORMAT_NONLITERAL\n#pragma GCC diagnostic push\n#endif\n#ifdef HAVE_PRAGMA_GCC_DIAGNOSTIC_IGNORED_FORMAT_NONLITERAL\n#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"\n#endif\n#ifdef HAVE_PRAGMA_GCC_DIAGNOSTIC_IGNORED_FORMAT_SECURITY\n#pragma GCC diagnostic ignored \"-Wformat-security\"\n#endif\n\tsnprintf(value, valuelen, item->dfl, \"Voltronic Power P98\");\n#ifdef HAVE_PRAGMAS_FOR_GCC_DIAGNOSTIC_IGNORED_FORMAT_NONLITERAL\n#pragma GCC diagnostic pop\n#endif\n\n\treturn 0;\n}", "path": "nut/drivers/nutdrv_qx_mecer.c", "commit_date": "2020-11-24 00:00:00", "repo_name": "networkupstools/nut", "stars": 1468, "license": "other", "language": "c", "size": 84787}
{"docstring": "/* clean up the ctx space */\n", "func_signal": "void pconf_finish(PCONF_CTX_t *ctx)", "code": "{\n\tif (!check_magic(ctx))\n\t\treturn;\n\n\tif (ctx->f)\n\t\tfclose(ctx->f);\n\n\tfree_storage(ctx);\n\n\tctx->magic = 0;\n}", "path": "nut/common/parseconf.c", "commit_date": "2020-11-20 00:00:00", "repo_name": "networkupstools/nut", "stars": 1468, "license": "other", "language": "c", "size": 84787}
{"docstring": "/* take almost anything literally, but return to quotecollect */\n", "func_signal": "static int qc_literal(PCONF_CTX_t *ctx)", "code": "{\n\t/* continue onto the next line of the file */\n\tif (ctx->ch == 10)\n\t\treturn STATE_QUOTECOLLECT;\n\n\taddchar(ctx);\n\treturn STATE_QUOTECOLLECT;\n}", "path": "nut/common/parseconf.c", "commit_date": "2020-11-20 00:00:00", "repo_name": "networkupstools/nut", "stars": 1468, "license": "other", "language": "c", "size": 84787}
{"docstring": "/* list flags and values that you want to receive via -x */\n", "func_signal": "void upsdrv_makevartable(void)", "code": "{\n\taddvar(VAR_VALUE, \"lb\", \"Low battery threshold, default \" __XSTR__(LOW_BATTERY_THRESHOLD));\n\taddvar(VAR_VALUE, \"hb\", \"High battery threshold, default \" __XSTR__(HIGH_BATTERY_THRESHOLD));\n}", "path": "nut/drivers/asem.c", "commit_date": "2020-11-09 00:00:00", "repo_name": "networkupstools/nut", "stars": 1468, "license": "other", "language": "c", "size": 84787}
{"docstring": "/*****************************************************************************\n * shut_synchronise ()\n *\n * initiate communication with the UPS\n *\n * return TRUE on success, FALSE on failure\n *\n *****************************************************************************/\n", "func_signal": "int shut_synchronise(int arg_upsfd)", "code": "{\n\tint retCode = 0;\n\tunsigned char c = SHUT_SYNC_OFF, reply;\n\tint try;\n\n\tupsdebugx (2, \"entering shut_synchronise()\");\n\treply = '\\0';\n\n\t/* FIXME: re enable notification support?\n\tswitch (notification)\n\t{\n\t\tcase OFF_NOTIFICATION:\n\t\t\tc = SHUT_SYNC_OFF;\n\t\t\tbreak;\n\t\tcase LIGHT_NOTIFICATION:\n\t\t\tc = SHUT_SYNC_LIGHT;\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase COMPLETE_NOTIFICATION:\n\t\t\tc = SHUT_SYNC;\n\t\t\tbreak;\n\t}\n\t*/\n\n\t/* Sync with the UPS according to notification */\n\tfor (try = 0; try < MAX_TRY; try++)\n\t{\n\t\tupsdebugx (3, \"Syncing communication (try %i)\", try);\n\n\t\tif ((ser_send_char(arg_upsfd, c)) == -1)\n\t\t{\n\t\t\tupsdebugx (3, \"Communication error while writing to port\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tser_get_char(arg_upsfd, &reply, 1, 0);\n\t\tif (reply == c)\n\t\t{\n\t\t\tupsdebugx (3, \"Syncing and notification setting done\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn retCode;\n}", "path": "nut/drivers/libshut.c", "commit_date": "2020-11-29 00:00:00", "repo_name": "networkupstools/nut", "stars": 1468, "license": "other", "language": "c", "size": 84787}
{"docstring": "/**********************************************************************\n * shut_get_descriptor(int desctype, unsigned char *pkt)\n *\n * get descriptor specified by DescType and return it in Buf\n *\n * desctype  - from shutdataType\n * pkt       - where to store the report received\n *\n * return 0 on success, -1 on failure, -2 on NACK\n *\n *********************************************************************/\n", "func_signal": "static int shut_get_descriptor(int arg_upsfd, unsigned char type,\n                        unsigned char index, void *buf, int size)", "code": "{\n\tmemset(buf, 0, size);\n\n\tupsdebugx (2, \"entering shut_get_descriptor(n %02x, %i)\", type, size);\n\n\treturn shut_control_msg(arg_upsfd, USB_ENDPOINT_IN+(type>=USB_DT_HID?1:0),\n\t\t\t\t USB_REQ_GET_DESCRIPTOR, (type << 8) + index, 0, buf, size, SHUT_TIMEOUT);\n}", "path": "nut/drivers/libshut.c", "commit_date": "2020-11-29 00:00:00", "repo_name": "networkupstools/nut", "stars": 1468, "license": "other", "language": "c", "size": 84787}
{"docstring": "/* this function allows the subdriver to \"claim\" a device: return 1 if\n * the device is supported by this subdriver, else 0. */\n", "func_signal": "static int liebert_claim(HIDDevice_t *hd)", "code": "{\n\n\tint status = is_usb_device_supported(liebert_usb_device_table, hd);\n\n\tswitch (status) {\n\n\t\tcase POSSIBLY_SUPPORTED:\n\t\t\t/* by default, reject, unless the productid option is given */\n\t\t\tif (getval(\"productid\")) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tpossibly_supported(\"Liebert\", hd);\n\t\t\treturn 0;\n\n\t\tcase SUPPORTED:\n\t\t\treturn 1;\n\n\t\tcase NOT_SUPPORTED:\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n}", "path": "nut/drivers/liebert-hid.c", "commit_date": "2020-11-07 00:00:00", "repo_name": "networkupstools/nut", "stars": 1468, "license": "other", "language": "c", "size": 84787}
{"docstring": "/* return the report of ID=type in report\n * return -1 on failure, report length on success\n */\n", "func_signal": "static int libshut_get_report(int arg_upsfd, int ReportId,\n                       unsigned char *raw_buf, int ReportSize )", "code": "{\n\tif (arg_upsfd < 1) {\n\t\treturn 0;\n\t}\n\n\tupsdebugx(4, \"Entering libshut_get_report\");\n\n\treturn shut_control_msg(arg_upsfd,\n\t\tREQUEST_TYPE_GET_REPORT,\n\t\t/* == USB_ENDPOINT_IN + USB_TYPE_CLASS + USB_RECIP_INTERFACE, */\n\t\t 0x01,\n\t\t ReportId+(0x03<<8), /* HID_REPORT_TYPE_FEATURE */\n\t\t 0, raw_buf, ReportSize, SHUT_TIMEOUT);\n}", "path": "nut/drivers/libshut.c", "commit_date": "2020-11-29 00:00:00", "repo_name": "networkupstools/nut", "stars": 1468, "license": "other", "language": "c", "size": 84787}
{"docstring": "/*\n * Convert data from one encoding to another. Return:\n *\n *  -2 : memory allocation failed\n *  -1 : unknown encoding\n *   0 : data was converted exactly\n *   1 : data was converted inexactly\n *   2 : data was invalid (but still converted)\n *\n * We convert in two steps, via UTF-8, as this is the only\n * reliable way of distinguishing between invalid input\n * and valid input which iconv refuses to transliterate.\n * We convert from UTF-8 twice, because we have no way of\n * knowing whether the conversion was exact if iconv returns\n * E2BIG (due to a bug in the specification of iconv).\n * An alternative approach is to assume that the output of\n * iconv is never more than 4 times as long as the input,\n * but I prefer to avoid that assumption if possible.\n */\n", "func_signal": "int iconvert(const char *fromcode, const char *tocode,\n\t     const char *from, size_t fromlen,\n\t     char **to, size_t *tolen)", "code": "{\n  int ret = 0;\n  iconv_t cd1, cd2;\n  char *ib;\n  char *ob;\n  char *utfbuf = 0, *outbuf, *newbuf;\n  size_t utflen, outlen, ibl, obl, k;\n  char tbuf[2048];\n\n  cd1 = iconv_open(\"UTF-8\", fromcode);\n  if (cd1 == (iconv_t)(-1))\n    return -1;\n\n  cd2 = (iconv_t)(-1);\n  /* Don't use strcasecmp() as it's locale-dependent. */\n  if (!strchr(\"Uu\", tocode[0]) ||\n      !strchr(\"Tt\", tocode[1]) ||\n      !strchr(\"Ff\", tocode[2]) ||\n      tocode[3] != '-' ||\n      tocode[4] != '8' ||\n      tocode[5] != '\\0') {\n    char *tocode1;\n\n    /*\n     * Try using this non-standard feature of glibc and libiconv.\n     * This is deliberately not a config option as people often\n     * change their iconv library without rebuilding applications.\n     */\n    tocode1 = (char *)safe_malloc_add_2op_(strlen(tocode), /*+*/11);\n    if (!tocode1)\n      goto fail;\n\n    strcpy(tocode1, tocode);\n    strcat(tocode1, \"//TRANSLIT\");\n    cd2 = iconv_open(tocode1, \"UTF-8\");\n    free(tocode1);\n\n    if (cd2 == (iconv_t)(-1))\n      cd2 = iconv_open(tocode, fromcode);\n\n    if (cd2 == (iconv_t)(-1)) {\n      iconv_close(cd1);\n      return -1;\n    }\n  }\n\n  utflen = 1; /*fromlen * 2 + 1; XXX */\n  utfbuf = (char *)malloc(utflen);\n  if (!utfbuf)\n    goto fail;\n\n  /* Convert to UTF-8 */\n  ib = (char *)from;\n  ibl = fromlen;\n  ob = utfbuf;\n  obl = utflen;\n  for (;;) {\n    k = iconv(cd1, &ib, &ibl, &ob, &obl);\n    assert((!k && !ibl) ||\n\t   (k == (size_t)(-1) && errno == E2BIG && ibl && obl < 6) ||\n\t   (k == (size_t)(-1) &&\n\t    (errno == EILSEQ || errno == EINVAL) && ibl));\n    if (!ibl)\n      break;\n    if (obl < 6) {\n      /* Enlarge the buffer */\n      if(utflen*2 < utflen) /* overflow check */\n\tgoto fail;\n      utflen *= 2;\n      newbuf = (char *)realloc(utfbuf, utflen);\n      if (!newbuf)\n\tgoto fail;\n      ob = (ob - utfbuf) + newbuf;\n      obl = utflen - (ob - newbuf);\n      utfbuf = newbuf;\n    }\n    else {\n      /* Invalid input */\n      ib++, ibl--;\n      *ob++ = '#', obl--;\n      ret = 2;\n      iconv(cd1, 0, 0, 0, 0);\n    }\n  }\n\n  if (cd2 == (iconv_t)(-1)) {\n    /* The target encoding was UTF-8 */\n    if (tolen)\n      *tolen = ob - utfbuf;\n    if (!to) {\n      free(utfbuf);\n      iconv_close(cd1);\n      return ret;\n    }\n    newbuf = (char *)safe_realloc_add_2op_(utfbuf, (ob - utfbuf), /*+*/1);\n    if (!newbuf)\n      goto fail;\n    ob = (ob - utfbuf) + newbuf;\n    *ob = '\\0';\n    *to = newbuf;\n    iconv_close(cd1);\n    return ret;\n  }\n\n  /* Truncate the buffer to be tidy */\n  utflen = ob - utfbuf;\n  newbuf = (char *)realloc(utfbuf, utflen);\n  if (!newbuf)\n    goto fail;\n  utfbuf = newbuf;\n\n  /* Convert from UTF-8 to discover how long the output is */\n  outlen = 0;\n  ib = utfbuf;\n  ibl = utflen;\n  while (ibl) {\n    ob = tbuf;\n    obl = sizeof(tbuf);\n    k = iconv(cd2, &ib, &ibl, &ob, &obl);\n    assert((k != (size_t)(-1) && !ibl) ||\n\t   (k == (size_t)(-1) && errno == E2BIG && ibl) ||\n\t   (k == (size_t)(-1) && errno == EILSEQ && ibl));\n    if (ibl && !(k == (size_t)(-1) && errno == E2BIG)) {\n      /* Replace one character */\n      char *tb = \"?\";\n      size_t tbl = 1;\n\n      outlen += ob - tbuf;\n      ob = tbuf;\n      obl = sizeof(tbuf);\n      k = iconv(cd2, &tb, &tbl, &ob, &obl);\n      assert((!k && !tbl) ||\n\t     (k == (size_t)(-1) && errno == EILSEQ && tbl));\n      for (++ib, --ibl; ibl && (*ib & 0x80); ib++, ibl--)\n\t;\n    }\n    outlen += ob - tbuf;\n  }\n  ob = tbuf;\n  obl = sizeof(tbuf);\n  k = iconv(cd2, 0, 0, &ob, &obl);\n  assert(!k);\n  outlen += ob - tbuf;\n\n  /* Convert from UTF-8 for real */\n  outbuf = (char *)safe_malloc_add_2op_(outlen, /*+*/1);\n  if (!outbuf)\n    goto fail;\n  ib = utfbuf;\n  ibl = utflen;\n  ob = outbuf;\n  obl = outlen;\n  while (ibl) {\n    k = iconv(cd2, &ib, &ibl, &ob, &obl);\n    assert((k != (size_t)(-1) && !ibl) ||\n\t   (k == (size_t)(-1) && errno == EILSEQ && ibl));\n    if (k && !ret)\n      ret = 1;\n    if (ibl && !(k == (size_t)(-1) && errno == E2BIG)) {\n      /* Replace one character */\n      char *tb = \"?\";\n      size_t tbl = 1;\n\n      k = iconv(cd2, &tb, &tbl, &ob, &obl);\n      assert((!k && !tbl) ||\n\t     (k == (size_t)(-1) && errno == EILSEQ && tbl));\n      for (++ib, --ibl; ibl && (*ib & 0x80); ib++, ibl--)\n\t;\n    }\n  }\n  k = iconv(cd2, 0, 0, &ob, &obl);\n  assert(!k);\n  assert(!obl);\n  *ob = '\\0';\n\n  free(utfbuf);\n  iconv_close(cd1);\n  iconv_close(cd2);\n  if (tolen)\n    *tolen = outlen;\n  if (!to) {\n    free(outbuf);\n    return ret;\n  }\n  *to = outbuf;\n  return ret;\n\n fail:\n  if(0 != utfbuf)\n    free(utfbuf);\n  iconv_close(cd1);\n  if (cd2 != (iconv_t)(-1))\n    iconv_close(cd2);\n  return -2;\n}", "path": "ring/extensions/android/ringlibsdl/project/jni/flac-1.2.1/src/share/utf8/iconvert.c", "commit_date": "2020-04-15 00:00:00", "repo_name": "ring-lang/ring", "stars": 1206, "license": "mit", "language": "c", "size": 2325340}
{"docstring": "/**\n * We get called here from directly following a call to connect(2).\n * In order to determine if we've errored out or succeeded must call\n * getsockopt.\n */\n", "func_signal": "static void uv__stream_connect(uv_stream_t* stream)", "code": "{\n  int error;\n  uv_connect_t* req = stream->connect_req;\n  socklen_t errorsize = sizeof(int);\n\n  assert(stream->type == UV_TCP || stream->type == UV_NAMED_PIPE);\n  assert(req);\n\n  if (stream->delayed_error) {\n    /* To smooth over the differences between unixes errors that\n     * were reported synchronously on the first connect can be delayed\n     * until the next tick--which is now.\n     */\n    error = stream->delayed_error;\n    stream->delayed_error = 0;\n  } else {\n    /* Normal situation: we need to get the socket error from the kernel. */\n    assert(uv__stream_fd(stream) >= 0);\n    getsockopt(uv__stream_fd(stream),\n               SOL_SOCKET,\n               SO_ERROR,\n               &error,\n               &errorsize);\n    error = -error;\n  }\n\n  if (error == -EINPROGRESS)\n    return;\n\n  stream->connect_req = NULL;\n  uv__req_unregister(stream->loop, req);\n\n  if (error < 0 || QUEUE_EMPTY(&stream->write_queue)) {\n    uv__io_stop(stream->loop, &stream->io_watcher, POLLOUT);\n  }\n\n  if (req->cb)\n    req->cb(req, error);\n\n  if (uv__stream_fd(stream) == -1)\n    return;\n\n  if (error < 0) {\n    uv__stream_flush_write_queue(stream, -ECANCELED);\n    uv__write_callbacks(stream);\n  }\n}", "path": "ring/extensions/ringlibuv/libuv/src/unix/stream.c", "commit_date": "2018-01-25 00:00:00", "repo_name": "ring-lang/ring", "stars": 1206, "license": "mit", "language": "c", "size": 2325340}
{"docstring": "// Validates the VP8X header and skips over it.\n// Returns VP8_STATUS_BITSTREAM_ERROR for invalid VP8X header,\n//         VP8_STATUS_NOT_ENOUGH_DATA in case of insufficient data, and\n//         VP8_STATUS_OK otherwise.\n// If a VP8X chunk is found, found_vp8x is set to true and *width_ptr,\n// *height_ptr and *flags_ptr are set to the corresponding values extracted\n// from the VP8X chunk.\n", "func_signal": "static VP8StatusCode ParseVP8X(const uint8_t** const data,\n                               size_t* const data_size,\n                               int* const found_vp8x,\n                               int* const width_ptr, int* const height_ptr,\n                               uint32_t* const flags_ptr)", "code": "{\n  const uint32_t vp8x_size = CHUNK_HEADER_SIZE + VP8X_CHUNK_SIZE;\n  assert(data != NULL);\n  assert(data_size != NULL);\n  assert(found_vp8x != NULL);\n\n  *found_vp8x = 0;\n\n  if (*data_size < CHUNK_HEADER_SIZE) {\n    return VP8_STATUS_NOT_ENOUGH_DATA;  // Insufficient data.\n  }\n\n  if (!memcmp(*data, \"VP8X\", TAG_SIZE)) {\n    int width, height;\n    uint32_t flags;\n    const uint32_t chunk_size = get_le32(*data + TAG_SIZE);\n    if (chunk_size != VP8X_CHUNK_SIZE) {\n      return VP8_STATUS_BITSTREAM_ERROR;  // Wrong chunk size.\n    }\n\n    // Verify if enough data is available to validate the VP8X chunk.\n    if (*data_size < vp8x_size) {\n      return VP8_STATUS_NOT_ENOUGH_DATA;  // Insufficient data.\n    }\n    flags = get_le32(*data + 8);\n    width = 1 + get_le24(*data + 12);\n    height = 1 + get_le24(*data + 15);\n    if (width * (uint64_t)height >= MAX_IMAGE_AREA) {\n      return VP8_STATUS_BITSTREAM_ERROR;  // image is too large\n    }\n\n    if (flags_ptr != NULL) *flags_ptr = flags;\n    if (width_ptr != NULL) *width_ptr = width;\n    if (height_ptr != NULL) *height_ptr = height;\n    // Skip over VP8X header bytes.\n    *data += vp8x_size;\n    *data_size -= vp8x_size;\n    *found_vp8x = 1;\n  }\n  return VP8_STATUS_OK;\n}", "path": "ring/extensions/android/ringlibsdl/project/jni/SDL2_image/external/libwebp-0.3.0/src/dec/webp.c", "commit_date": "2020-04-15 00:00:00", "repo_name": "ring-lang/ring", "stars": 1206, "license": "mit", "language": "c", "size": 2325340}
{"docstring": "//------------------------------------------------------------------------------\n// Cropping and rescaling.\n", "func_signal": "int WebPIoInitFromOptions(const WebPDecoderOptions* const options,\n                          VP8Io* const io, WEBP_CSP_MODE src_colorspace)", "code": "{\n  const int W = io->width;\n  const int H = io->height;\n  int x = 0, y = 0, w = W, h = H;\n\n  // Cropping\n  io->use_cropping = (options != NULL) && (options->use_cropping > 0);\n  if (io->use_cropping) {\n    w = options->crop_width;\n    h = options->crop_height;\n    x = options->crop_left;\n    y = options->crop_top;\n    if (!WebPIsRGBMode(src_colorspace)) {   // only snap for YUV420 or YUV422\n      x &= ~1;\n      y &= ~1;    // TODO(later): only for YUV420, not YUV422.\n    }\n    if (x < 0 || y < 0 || w <= 0 || h <= 0 || x + w > W || y + h > H) {\n      return 0;  // out of frame boundary error\n    }\n  }\n  io->crop_left   = x;\n  io->crop_top    = y;\n  io->crop_right  = x + w;\n  io->crop_bottom = y + h;\n  io->mb_w = w;\n  io->mb_h = h;\n\n  // Scaling\n  io->use_scaling = (options != NULL) && (options->use_scaling > 0);\n  if (io->use_scaling) {\n    if (options->scaled_width <= 0 || options->scaled_height <= 0) {\n      return 0;\n    }\n    io->scaled_width = options->scaled_width;\n    io->scaled_height = options->scaled_height;\n  }\n\n  // Filter\n  io->bypass_filtering = options && options->bypass_filtering;\n\n  // Fancy upsampler\n#ifdef FANCY_UPSAMPLING\n  io->fancy_upsampling = (options == NULL) || (!options->no_fancy_upsampling);\n#endif\n\n  if (io->use_scaling) {\n    // disable filter (only for large downscaling ratio).\n    io->bypass_filtering = (io->scaled_width < W * 3 / 4) &&\n                           (io->scaled_height < H * 3 / 4);\n    io->fancy_upsampling = 0;\n  }\n  return 1;\n}", "path": "ring/extensions/android/ringlibsdl/project/jni/SDL2_image/external/libwebp-0.3.0/src/dec/webp.c", "commit_date": "2020-04-15 00:00:00", "repo_name": "ring-lang/ring", "stars": 1206, "license": "mit", "language": "c", "size": 2325340}
{"docstring": "/*\n * Retrieves the pointer to a winsock extension function.\n */\n", "func_signal": "static BOOL uv_get_extension_function(SOCKET socket, GUID guid,\n    void **target)", "code": "{\n  int result;\n  DWORD bytes;\n\n  result = WSAIoctl(socket,\n                    SIO_GET_EXTENSION_FUNCTION_POINTER,\n                    &guid,\n                    sizeof(guid),\n                    (void*)target,\n                    sizeof(*target),\n                    &bytes,\n                    NULL,\n                    NULL);\n\n  if (result == SOCKET_ERROR) {\n    *target = NULL;\n    return FALSE;\n  } else {\n    return TRUE;\n  }\n}", "path": "ring/extensions/ringlibuv/libuv/src/win/winsock.c", "commit_date": "2018-01-25 00:00:00", "repo_name": "ring-lang/ring", "stars": 1206, "license": "mit", "language": "c", "size": 2325340}
{"docstring": "//------------------------------------------------------------------------------\n// Advance decoding API\n", "func_signal": "int WebPInitDecoderConfigInternal(WebPDecoderConfig* config,\n                                  int version)", "code": "{\n  if (WEBP_ABI_IS_INCOMPATIBLE(version, WEBP_DECODER_ABI_VERSION)) {\n    return 0;   // version mismatch\n  }\n  if (config == NULL) {\n    return 0;\n  }\n  memset(config, 0, sizeof(*config));\n  DefaultFeatures(&config->input);\n  WebPInitDecBuffer(&config->output);\n  return 1;\n}", "path": "ring/extensions/android/ringlibsdl/project/jni/SDL2_image/external/libwebp-0.3.0/src/dec/webp.c", "commit_date": "2020-04-15 00:00:00", "repo_name": "ring-lang/ring", "stars": 1206, "license": "mit", "language": "c", "size": 2325340}
{"docstring": "/* Print a pixel from a row returned by libpng; determine the row format, find\n * the pixel, and print the relevant information to stdout.\n */\n", "func_signal": "static void\nprint_pixel(png_structp png_ptr, png_infop info_ptr, png_const_bytep row,\n   png_uint_32 x)", "code": "{\n   PNG_CONST unsigned int bit_depth = png_get_bit_depth(png_ptr, info_ptr);\n\n   switch (png_get_color_type(png_ptr, info_ptr))\n   {\n      case PNG_COLOR_TYPE_GRAY:\n         printf(\"GRAY %u\\n\", component(row, x, 0, bit_depth, 1));\n         return;\n\n      /* The palette case is slightly more difficult - the palette and, if\n       * present, the tRNS ('transparency', though the values are really\n       * opacity) data must be read to give the full picture:\n       */\n      case PNG_COLOR_TYPE_PALETTE:\n         {\n            PNG_CONST unsigned int index = component(row, x, 0, bit_depth, 1);\n            png_colorp palette = NULL;\n            int num_palette = 0;\n\n            if ((png_get_PLTE(png_ptr, info_ptr, &palette, &num_palette) &\n               PNG_INFO_PLTE) && num_palette > 0 && palette != NULL)\n            {\n               png_bytep trans_alpha = NULL;\n               int num_trans = 0;\n               if ((png_get_tRNS(png_ptr, info_ptr, &trans_alpha, &num_trans,\n                  NULL) & PNG_INFO_tRNS) && num_trans > 0 &&\n                  trans_alpha != NULL)\n                  printf(\"INDEXED %u = %d %d %d %d\\n\", index,\n                     palette[index].red, palette[index].green,\n                     palette[index].blue,\n                     index < num_trans ? trans_alpha[index] : 255);\n\n               else /* no transparency */\n                  printf(\"INDEXED %u = %d %d %d\\n\", index,\n                     palette[index].red, palette[index].green,\n                     palette[index].blue);\n            }\n\n            else\n               printf(\"INDEXED %u = invalid index\\n\", index);\n         }\n         return;\n\n      case PNG_COLOR_TYPE_RGB:\n         printf(\"RGB %u %u %u\\n\", component(row, x, 0, bit_depth, 3),\n            component(row, x, 1, bit_depth, 3),\n            component(row, x, 2, bit_depth, 3));\n         return;\n\n      case PNG_COLOR_TYPE_GRAY_ALPHA:\n         printf(\"GRAY+ALPHA %u %u\\n\", component(row, x, 0, bit_depth, 2),\n            component(row, x, 1, bit_depth, 2));\n         return;\n\n      case PNG_COLOR_TYPE_RGB_ALPHA:\n         printf(\"RGBA %u %u %u %u\\n\", component(row, x, 0, bit_depth, 4),\n            component(row, x, 1, bit_depth, 4),\n            component(row, x, 2, bit_depth, 4),\n            component(row, x, 3, bit_depth, 4));\n         return;\n\n      default:\n         png_error(png_ptr, \"invalid color type\");\n   }\n}", "path": "ring/extensions/android/ringlibsdl/project/jni/SDL2_image/external/libpng-1.6.2/contrib/examples/pngpixel.c", "commit_date": "2020-04-15 00:00:00", "repo_name": "ring-lang/ring", "stars": 1206, "license": "mit", "language": "c", "size": 2325340}
{"docstring": "// minimal amount will be read to fetch the remaining parameters.\n// If 'headers' is non-NULL this function will attempt to locate both alpha\n// data (with or without a VP8X chunk) and the bitstream chunk (VP8/VP8L).\n// Note: The following chunk sequences (before the raw VP8/VP8L data) are\n// considered valid by this function:\n// RIFF + VP8(L)\n// RIFF + VP8X + (optional chunks) + VP8(L)\n// ALPH + VP8 <-- Not a valid WebP format: only allowed for internal purpose.\n// VP8(L)     <-- Not a valid WebP format: only allowed for internal purpose.\n", "func_signal": "static VP8StatusCode ParseHeadersInternal(const uint8_t* data,\n                                          size_t data_size,\n                                          int* const width,\n                                          int* const height,\n                                          int* const has_alpha,\n                                          int* const has_animation,\n                                          WebPHeaderStructure* const headers)", "code": "{\n  int found_riff = 0;\n  int found_vp8x = 0;\n  VP8StatusCode status;\n  WebPHeaderStructure hdrs;\n\n  if (data == NULL || data_size < RIFF_HEADER_SIZE) {\n    return VP8_STATUS_NOT_ENOUGH_DATA;\n  }\n  memset(&hdrs, 0, sizeof(hdrs));\n  hdrs.data = data;\n  hdrs.data_size = data_size;\n\n  // Skip over RIFF header.\n  status = ParseRIFF(&data, &data_size, &hdrs.riff_size);\n  if (status != VP8_STATUS_OK) {\n    return status;   // Wrong RIFF header / insufficient data.\n  }\n  found_riff = (hdrs.riff_size > 0);\n\n  // Skip over VP8X.\n  {\n    uint32_t flags = 0;\n    status = ParseVP8X(&data, &data_size, &found_vp8x, width, height, &flags);\n    if (status != VP8_STATUS_OK) {\n      return status;  // Wrong VP8X / insufficient data.\n    }\n    if (!found_riff && found_vp8x) {\n      // Note: This restriction may be removed in the future, if it becomes\n      // necessary to send VP8X chunk to the decoder.\n      return VP8_STATUS_BITSTREAM_ERROR;\n    }\n    if (has_alpha != NULL) *has_alpha = !!(flags & ALPHA_FLAG);\n    if (has_animation != NULL) *has_animation = !!(flags & ANIMATION_FLAG);\n    if (found_vp8x && headers == NULL) {\n      return VP8_STATUS_OK;  // Return features from VP8X header.\n    }\n  }\n\n  if (data_size < TAG_SIZE) return VP8_STATUS_NOT_ENOUGH_DATA;\n\n  // Skip over optional chunks if data started with \"RIFF + VP8X\" or \"ALPH\".\n  if ((found_riff && found_vp8x) ||\n      (!found_riff && !found_vp8x && !memcmp(data, \"ALPH\", TAG_SIZE))) {\n    status = ParseOptionalChunks(&data, &data_size, hdrs.riff_size,\n                                 &hdrs.alpha_data, &hdrs.alpha_data_size);\n    if (status != VP8_STATUS_OK) {\n      return status;  // Found an invalid chunk size / insufficient data.\n    }\n  }\n\n  // Skip over VP8/VP8L header.\n  status = ParseVP8Header(&data, &data_size, hdrs.riff_size,\n                          &hdrs.compressed_size, &hdrs.is_lossless);\n  if (status != VP8_STATUS_OK) {\n    return status;  // Wrong VP8/VP8L chunk-header / insufficient data.\n  }\n  if (hdrs.compressed_size > MAX_CHUNK_PAYLOAD) {\n    return VP8_STATUS_BITSTREAM_ERROR;\n  }\n\n  if (!hdrs.is_lossless) {\n    if (data_size < VP8_FRAME_HEADER_SIZE) {\n      return VP8_STATUS_NOT_ENOUGH_DATA;\n    }\n    // Validates raw VP8 data.\n    if (!VP8GetInfo(data, data_size,\n                    (uint32_t)hdrs.compressed_size, width, height)) {\n      return VP8_STATUS_BITSTREAM_ERROR;\n    }\n  } else {\n    if (data_size < VP8L_FRAME_HEADER_SIZE) {\n      return VP8_STATUS_NOT_ENOUGH_DATA;\n    }\n    // Validates raw VP8L data.\n    if (!VP8LGetInfo(data, data_size, width, height, has_alpha)) {\n      return VP8_STATUS_BITSTREAM_ERROR;\n    }\n  }\n\n  if (has_alpha != NULL) {\n    // If the data did not contain a VP8X/VP8L chunk the only definitive way\n    // to set this is by looking for alpha data (from an ALPH chunk).\n    *has_alpha |= (hdrs.alpha_data != NULL);\n  }\n  if (headers != NULL) {\n    *headers = hdrs;\n    headers->offset = data - headers->data;\n    assert((uint64_t)(data - headers->data) < MAX_CHUNK_PAYLOAD);\n    assert(headers->offset == headers->data_size - data_size);\n  }\n  return VP8_STATUS_OK;  // Return features from VP8 header.\n}", "path": "ring/extensions/android/ringlibsdl/project/jni/SDL2_image/external/libwebp-0.3.0/src/dec/webp.c", "commit_date": "2020-04-15 00:00:00", "repo_name": "ring-lang/ring", "stars": 1206, "license": "mit", "language": "c", "size": 2325340}
{"docstring": "/* See description of uv_wsarecv_workaround. */\n", "func_signal": "int WSAAPI uv_wsarecvfrom_workaround(SOCKET socket, WSABUF* buffers,\n    DWORD buffer_count, DWORD* bytes, DWORD* flags, struct sockaddr* addr,\n    int* addr_len, WSAOVERLAPPED *overlapped,\n    LPWSAOVERLAPPED_COMPLETION_ROUTINE completion_routine)", "code": "{\n  NTSTATUS status;\n  void* apc_context;\n  IO_STATUS_BLOCK* iosb = (IO_STATUS_BLOCK*) &overlapped->Internal;\n  AFD_RECV_DATAGRAM_INFO info;\n  DWORD error;\n\n  if (overlapped == NULL || addr == NULL || addr_len == NULL ||\n      completion_routine != NULL) {\n    WSASetLastError(WSAEINVAL);\n    return SOCKET_ERROR;\n  }\n\n  info.BufferArray = buffers;\n  info.BufferCount = buffer_count;\n  info.AfdFlags = AFD_OVERLAPPED;\n  info.TdiFlags = TDI_RECEIVE_NORMAL;\n  info.Address = addr;\n  info.AddressLength = addr_len;\n\n  if (*flags & MSG_PEEK) {\n    info.TdiFlags |= TDI_RECEIVE_PEEK;\n  }\n\n  if (*flags & MSG_PARTIAL) {\n    info.TdiFlags |= TDI_RECEIVE_PARTIAL;\n  }\n\n  if (!((intptr_t) overlapped->hEvent & 1)) {\n    apc_context = (void*) overlapped;\n  } else {\n    apc_context = NULL;\n  }\n\n  iosb->Status = STATUS_PENDING;\n  iosb->Pointer = 0;\n\n  status = pNtDeviceIoControlFile((HANDLE) socket,\n                                  overlapped->hEvent,\n                                  NULL,\n                                  apc_context,\n                                  iosb,\n                                  IOCTL_AFD_RECEIVE_DATAGRAM,\n                                  &info,\n                                  sizeof(info),\n                                  NULL,\n                                  0);\n\n  *flags = 0;\n  *bytes = (DWORD) iosb->Information;\n\n  switch (status) {\n    case STATUS_SUCCESS:\n      error = ERROR_SUCCESS;\n      break;\n\n    case STATUS_PENDING:\n      error = WSA_IO_PENDING;\n      break;\n\n    case STATUS_BUFFER_OVERFLOW:\n      error = WSAEMSGSIZE;\n      break;\n\n    case STATUS_RECEIVE_EXPEDITED:\n      error = ERROR_SUCCESS;\n      *flags = MSG_OOB;\n      break;\n\n    case STATUS_RECEIVE_PARTIAL_EXPEDITED:\n      error = ERROR_SUCCESS;\n      *flags = MSG_PARTIAL | MSG_OOB;\n      break;\n\n    case STATUS_RECEIVE_PARTIAL:\n      error = ERROR_SUCCESS;\n      *flags = MSG_PARTIAL;\n      break;\n\n    default:\n      error = uv_ntstatus_to_winsock_error(status);\n      break;\n  }\n\n  WSASetLastError(error);\n\n  if (error == ERROR_SUCCESS) {\n    return 0;\n  } else {\n    return SOCKET_ERROR;\n  }\n}", "path": "ring/extensions/ringlibuv/libuv/src/win/winsock.c", "commit_date": "2018-01-25 00:00:00", "repo_name": "ring-lang/ring", "stars": 1206, "license": "mit", "language": "c", "size": 2325340}
{"docstring": "// Main flow\n", "func_signal": "static VP8StatusCode DecodeInto(const uint8_t* const data, size_t data_size,\n                                WebPDecParams* const params)", "code": "{\n  VP8StatusCode status;\n  VP8Io io;\n  WebPHeaderStructure headers;\n\n  headers.data = data;\n  headers.data_size = data_size;\n  status = WebPParseHeaders(&headers);   // Process Pre-VP8 chunks.\n  if (status != VP8_STATUS_OK) {\n    return status;\n  }\n\n  assert(params != NULL);\n  VP8InitIo(&io);\n  io.data = headers.data + headers.offset;\n  io.data_size = headers.data_size - headers.offset;\n  WebPInitCustomIo(params, &io);  // Plug the I/O functions.\n\n  if (!headers.is_lossless) {\n    VP8Decoder* const dec = VP8New();\n    if (dec == NULL) {\n      return VP8_STATUS_OUT_OF_MEMORY;\n    }\n#ifdef WEBP_USE_THREAD\n    dec->use_threads_ = params->options && (params->options->use_threads > 0);\n#else\n    dec->use_threads_ = 0;\n#endif\n    dec->alpha_data_ = headers.alpha_data;\n    dec->alpha_data_size_ = headers.alpha_data_size;\n\n    // Decode bitstream header, update io->width/io->height.\n    if (!VP8GetHeaders(dec, &io)) {\n      status = dec->status_;   // An error occurred. Grab error status.\n    } else {\n      // Allocate/check output buffers.\n      status = WebPAllocateDecBuffer(io.width, io.height, params->options,\n                                     params->output);\n      if (status == VP8_STATUS_OK) {  // Decode\n        if (!VP8Decode(dec, &io)) {\n          status = dec->status_;\n        }\n      }\n    }\n    VP8Delete(dec);\n  } else {\n    VP8LDecoder* const dec = VP8LNew();\n    if (dec == NULL) {\n      return VP8_STATUS_OUT_OF_MEMORY;\n    }\n    if (!VP8LDecodeHeader(dec, &io)) {\n      status = dec->status_;   // An error occurred. Grab error status.\n    } else {\n      // Allocate/check output buffers.\n      status = WebPAllocateDecBuffer(io.width, io.height, params->options,\n                                     params->output);\n      if (status == VP8_STATUS_OK) {  // Decode\n        if (!VP8LDecodeImage(dec)) {\n          status = dec->status_;\n        }\n      }\n    }\n    VP8LDelete(dec);\n  }\n\n  if (status != VP8_STATUS_OK) {\n    WebPFreeDecBuffer(params->output);\n  }\n  return status;\n}", "path": "ring/extensions/android/ringlibsdl/project/jni/SDL2_image/external/libwebp-0.3.0/src/dec/webp.c", "commit_date": "2020-04-15 00:00:00", "repo_name": "ring-lang/ring", "stars": 1206, "license": "mit", "language": "c", "size": 2325340}
{"docstring": "// Validates the RIFF container (if detected) and skips over it.\n// If a RIFF container is detected,\n// Returns VP8_STATUS_BITSTREAM_ERROR for invalid header, and\n//         VP8_STATUS_OK otherwise.\n// In case there are not enough bytes (partial RIFF container), return 0 for\n// *riff_size. Else return the RIFF size extracted from the header.\n", "func_signal": "static VP8StatusCode ParseRIFF(const uint8_t** const data,\n                               size_t* const data_size,\n                               size_t* const riff_size)", "code": "{\n  assert(data != NULL);\n  assert(data_size != NULL);\n  assert(riff_size != NULL);\n\n  *riff_size = 0;  // Default: no RIFF present.\n  if (*data_size >= RIFF_HEADER_SIZE && !memcmp(*data, \"RIFF\", TAG_SIZE)) {\n    if (memcmp(*data + 8, \"WEBP\", TAG_SIZE)) {\n      return VP8_STATUS_BITSTREAM_ERROR;  // Wrong image file signature.\n    } else {\n      const uint32_t size = get_le32(*data + TAG_SIZE);\n      // Check that we have at least one chunk (i.e \"WEBP\" + \"VP8?nnnn\").\n      if (size < TAG_SIZE + CHUNK_HEADER_SIZE) {\n        return VP8_STATUS_BITSTREAM_ERROR;\n      }\n      if (size > MAX_CHUNK_PAYLOAD) {\n        return VP8_STATUS_BITSTREAM_ERROR;\n      }\n      // We have a RIFF container. Skip it.\n      *riff_size = size;\n      *data += RIFF_HEADER_SIZE;\n      *data_size -= RIFF_HEADER_SIZE;\n    }\n  }\n  return VP8_STATUS_OK;\n}", "path": "ring/extensions/android/ringlibsdl/project/jni/SDL2_image/external/libwebp-0.3.0/src/dec/webp.c", "commit_date": "2020-04-15 00:00:00", "repo_name": "ring-lang/ring", "stars": 1206, "license": "mit", "language": "c", "size": 2325340}
{"docstring": "// Skips to the next VP8/VP8L chunk header in the data given the size of the\n// RIFF chunk 'riff_size'.\n// Returns VP8_STATUS_BITSTREAM_ERROR if any invalid chunk size is encountered,\n//         VP8_STATUS_NOT_ENOUGH_DATA in case of insufficient data, and\n//         VP8_STATUS_OK otherwise.\n// If an alpha chunk is found, *alpha_data and *alpha_size are set\n// appropriately.\n", "func_signal": "static VP8StatusCode ParseOptionalChunks(const uint8_t** const data,\n                                         size_t* const data_size,\n                                         size_t const riff_size,\n                                         const uint8_t** const alpha_data,\n                                         size_t* const alpha_size)", "code": "{\n  const uint8_t* buf;\n  size_t buf_size;\n  uint32_t total_size = TAG_SIZE +           // \"WEBP\".\n                        CHUNK_HEADER_SIZE +  // \"VP8Xnnnn\".\n                        VP8X_CHUNK_SIZE;     // data.\n  assert(data != NULL);\n  assert(data_size != NULL);\n  buf = *data;\n  buf_size = *data_size;\n\n  assert(alpha_data != NULL);\n  assert(alpha_size != NULL);\n  *alpha_data = NULL;\n  *alpha_size = 0;\n\n  while (1) {\n    uint32_t chunk_size;\n    uint32_t disk_chunk_size;   // chunk_size with padding\n\n    *data = buf;\n    *data_size = buf_size;\n\n    if (buf_size < CHUNK_HEADER_SIZE) {  // Insufficient data.\n      return VP8_STATUS_NOT_ENOUGH_DATA;\n    }\n\n    chunk_size = get_le32(buf + TAG_SIZE);\n    if (chunk_size > MAX_CHUNK_PAYLOAD) {\n      return VP8_STATUS_BITSTREAM_ERROR;          // Not a valid chunk size.\n    }\n    // For odd-sized chunk-payload, there's one byte padding at the end.\n    disk_chunk_size = (CHUNK_HEADER_SIZE + chunk_size + 1) & ~1;\n    total_size += disk_chunk_size;\n\n    // Check that total bytes skipped so far does not exceed riff_size.\n    if (riff_size > 0 && (total_size > riff_size)) {\n      return VP8_STATUS_BITSTREAM_ERROR;          // Not a valid chunk size.\n    }\n\n    // Start of a (possibly incomplete) VP8/VP8L chunk implies that we have\n    // parsed all the optional chunks.\n    // Note: This check must occur before the check 'buf_size < disk_chunk_size'\n    // below to allow incomplete VP8/VP8L chunks.\n    if (!memcmp(buf, \"VP8 \", TAG_SIZE) ||\n        !memcmp(buf, \"VP8L\", TAG_SIZE)) {\n      return VP8_STATUS_OK;\n    }\n\n    if (buf_size < disk_chunk_size) {             // Insufficient data.\n      return VP8_STATUS_NOT_ENOUGH_DATA;\n    }\n\n    if (!memcmp(buf, \"ALPH\", TAG_SIZE)) {         // A valid ALPH header.\n      *alpha_data = buf + CHUNK_HEADER_SIZE;\n      *alpha_size = chunk_size;\n    }\n\n    // We have a full and valid chunk; skip it.\n    buf += disk_chunk_size;\n    buf_size -= disk_chunk_size;\n  }\n}", "path": "ring/extensions/android/ringlibsdl/project/jni/SDL2_image/external/libwebp-0.3.0/src/dec/webp.c", "commit_date": "2020-04-15 00:00:00", "repo_name": "ring-lang/ring", "stars": 1206, "license": "mit", "language": "c", "size": 2325340}
{"docstring": "/* defined(__APPLE__) */\n", "func_signal": "void uv__stream_close(uv_stream_t* handle)", "code": "{\n  unsigned int i;\n  uv__stream_queued_fds_t* queued_fds;\n\n#if defined(__APPLE__)\n  /* Terminate select loop first */\n  if (handle->select != NULL) {\n    uv__stream_select_t* s;\n\n    s = handle->select;\n\n    uv_sem_post(&s->close_sem);\n    uv_sem_post(&s->async_sem);\n    uv__stream_osx_interrupt_select(handle);\n    uv_thread_join(&s->thread);\n    uv_sem_destroy(&s->close_sem);\n    uv_sem_destroy(&s->async_sem);\n    uv__close(s->fake_fd);\n    uv__close(s->int_fd);\n    uv_close((uv_handle_t*) &s->async, uv__stream_osx_cb_close);\n\n    handle->select = NULL;\n  }\n#endif /* defined(__APPLE__) */\n\n  uv__io_close(handle->loop, &handle->io_watcher);\n  uv_read_stop(handle);\n  uv__handle_stop(handle);\n\n  if (handle->io_watcher.fd != -1) {\n    /* Don't close stdio file descriptors.  Nothing good comes from it. */\n    if (handle->io_watcher.fd > STDERR_FILENO)\n      uv__close(handle->io_watcher.fd);\n    handle->io_watcher.fd = -1;\n  }\n\n  if (handle->accepted_fd != -1) {\n    uv__close(handle->accepted_fd);\n    handle->accepted_fd = -1;\n  }\n\n  /* Close all queued fds */\n  if (handle->queued_fds != NULL) {\n    queued_fds = handle->queued_fds;\n    for (i = 0; i < queued_fds->offset; i++)\n      uv__close(queued_fds->fds[i]);\n    uv__free(handle->queued_fds);\n    handle->queued_fds = NULL;\n  }\n\n  assert(!uv__io_active(&handle->io_watcher, POLLIN | POLLOUT));\n}", "path": "ring/extensions/ringlibuv/libuv/src/unix/stream.c", "commit_date": "2018-01-25 00:00:00", "repo_name": "ring-lang/ring", "stars": 1206, "license": "mit", "language": "c", "size": 2325340}
{"docstring": "//------------------------------------------------------------------------------\n// WebPDecParams\n", "func_signal": "void WebPResetDecParams(WebPDecParams* const params)", "code": "{\n  if (params != NULL) {\n    memset(params, 0, sizeof(*params));\n  }\n}", "path": "ring/extensions/android/ringlibsdl/project/jni/SDL2_image/external/libwebp-0.3.0/src/dec/webp.c", "commit_date": "2020-04-15 00:00:00", "repo_name": "ring-lang/ring", "stars": 1206, "license": "mit", "language": "c", "size": 2325340}
{"docstring": "/* SDL_VIDEO_DRIVER_X11_XCURSOR */\n", "func_signal": "static Cursor\nX11_CreatePixmapCursor(SDL_Surface * surface, int hot_x, int hot_y)", "code": "{\n    Display *display = GetDisplay();\n    XColor fg, bg;\n    Cursor cursor = None;\n    Uint32 *ptr;\n    Uint8 *data_bits, *mask_bits;\n    Pixmap data_pixmap, mask_pixmap;\n    int x, y;\n    unsigned int rfg, gfg, bfg, rbg, gbg, bbg, fgBits, bgBits;\n    unsigned int width_bytes = ((surface->w + 7) & ~7) / 8;\n\n    data_bits = SDL_calloc(1, surface->h * width_bytes);\n    if (!data_bits) {\n        SDL_OutOfMemory();\n        return None;\n    }\n\n    mask_bits = SDL_calloc(1, surface->h * width_bytes);\n    if (!mask_bits) {\n        SDL_free(data_bits);\n        SDL_OutOfMemory();\n        return None;\n    }\n\n    /* Code below assumes ARGB pixel format */\n    SDL_assert(surface->format->format == SDL_PIXELFORMAT_ARGB8888);\n\n    rfg = gfg = bfg = rbg = gbg = bbg = fgBits = bgBits = 0;\n    for (y = 0; y < surface->h; ++y) {\n        ptr = (Uint32 *)((Uint8 *)surface->pixels + y * surface->pitch);\n        for (x = 0; x < surface->w; ++x) {\n            int alpha = (*ptr >> 24) & 0xff;\n            int red   = (*ptr >> 16) & 0xff;\n            int green = (*ptr >> 8) & 0xff;\n            int blue  = (*ptr >> 0) & 0xff;\n            if (alpha > 25) {\n                mask_bits[y * width_bytes + x / 8] |= (0x01 << (x % 8));\n\n                if ((red + green + blue) > 0x40) {\n                    fgBits++;\n                    rfg += red;\n                    gfg += green;\n                    bfg += blue;\n                    data_bits[y * width_bytes + x / 8] |= (0x01 << (x % 8));\n                } else {\n                    bgBits++;\n                    rbg += red;\n                    gbg += green;\n                    bbg += blue;\n                }\n            }\n            ++ptr;\n        }\n    }\n\n    if (fgBits) {\n        fg.red   = rfg * 257 / fgBits;\n        fg.green = gfg * 257 / fgBits;\n        fg.blue  = bfg * 257 / fgBits;\n    }\n    else fg.red = fg.green = fg.blue = 0;\n\n    if (bgBits) {\n        bg.red   = rbg * 257 / bgBits;\n        bg.green = gbg * 257 / bgBits;\n        bg.blue  = bbg * 257 / bgBits;\n    }\n    else bg.red = bg.green = bg.blue = 0;\n\n    data_pixmap = X11_XCreateBitmapFromData(display, DefaultRootWindow(display),\n                                        (char*)data_bits,\n                                        surface->w, surface->h);\n    mask_pixmap = X11_XCreateBitmapFromData(display, DefaultRootWindow(display),\n                                        (char*)mask_bits,\n                                        surface->w, surface->h);\n    cursor = X11_XCreatePixmapCursor(display, data_pixmap, mask_pixmap,\n                                 &fg, &bg, hot_x, hot_y);\n    X11_XFreePixmap(display, data_pixmap);\n    X11_XFreePixmap(display, mask_pixmap);\n\n    return cursor;\n}", "path": "ring/extensions/android/ringlibsdl/project/jni/sdl2/src/video/x11/SDL_x11mouse.c", "commit_date": "2020-04-15 00:00:00", "repo_name": "ring-lang/ring", "stars": 1206, "license": "mit", "language": "c", "size": 2325340}
{"docstring": "/*\n * Read the specified image into an ABGR-format raster.\n */\n", "func_signal": "int\nTIFFReadImageIter(TIFF* tif,\n    uint32 rwidth, uint32 rheight, uint8* raster, int stop)", "code": "{\n    char emsg[1024];\n    TIFFImageIter img;\n    int ok;\n\n    if (TIFFImageIterBegin(&img, tif, stop, emsg)) {\n\t/* XXX verify rwidth and rheight against width and height */\n\tok = TIFFImageIterGet(&img, raster, rwidth, img.height);\n\tTIFFImageIterEnd(&img);\n    } else {\n\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), emsg);\n\tok = 0;\n    }\n    return (ok);\n}", "path": "ring/extensions/android/ringlibsdl/project/jni/tiff-4.0.3/contrib/pds/tif_imageiter.c", "commit_date": "2020-04-15 00:00:00", "repo_name": "ring-lang/ring", "stars": 1206, "license": "mit", "language": "c", "size": 2325340}
{"docstring": "/* defined(UV_HAVE_KQUEUE) */\n", "func_signal": "void uv__server_io(uv_loop_t* loop, uv__io_t* w, unsigned int events)", "code": "{\n  uv_stream_t* stream;\n  int err;\n\n  stream = container_of(w, uv_stream_t, io_watcher);\n  assert(events & POLLIN);\n  assert(stream->accepted_fd == -1);\n  assert(!(stream->flags & UV_CLOSING));\n\n  uv__io_start(stream->loop, &stream->io_watcher, POLLIN);\n\n  /* connection_cb can close the server socket while we're\n   * in the loop so check it on each iteration.\n   */\n  while (uv__stream_fd(stream) != -1) {\n    assert(stream->accepted_fd == -1);\n\n#if defined(UV_HAVE_KQUEUE)\n    if (w->rcount <= 0)\n      return;\n#endif /* defined(UV_HAVE_KQUEUE) */\n\n    err = uv__accept(uv__stream_fd(stream));\n    if (err < 0) {\n      if (err == -EAGAIN || err == -EWOULDBLOCK)\n        return;  /* Not an error. */\n\n      if (err == -ECONNABORTED)\n        continue;  /* Ignore. Nothing we can do about that. */\n\n      if (err == -EMFILE || err == -ENFILE) {\n        err = uv__emfile_trick(loop, uv__stream_fd(stream));\n        if (err == -EAGAIN || err == -EWOULDBLOCK)\n          break;\n      }\n\n      stream->connection_cb(stream, err);\n      continue;\n    }\n\n    UV_DEC_BACKLOG(w)\n    stream->accepted_fd = err;\n    stream->connection_cb(stream, 0);\n\n    if (stream->accepted_fd != -1) {\n      /* The user hasn't yet accepted called uv_accept() */\n      uv__io_stop(loop, &stream->io_watcher, POLLIN);\n      return;\n    }\n\n    if (stream->type == UV_TCP && (stream->flags & UV_TCP_SINGLE_ACCEPT)) {\n      /* Give other processes a chance to accept connections. */\n      struct timespec timeout = { 0, 1 };\n      nanosleep(&timeout, NULL);\n    }\n  }\n}", "path": "ring/extensions/ringlibuv/libuv/src/unix/stream.c", "commit_date": "2018-01-25 00:00:00", "repo_name": "ring-lang/ring", "stars": 1206, "license": "mit", "language": "c", "size": 2325340}
{"docstring": "/* Implements a best effort approach to mitigating accept() EMFILE errors.\n * We have a spare file descriptor stashed away that we close to get below\n * the EMFILE limit. Next, we accept all pending connections and close them\n * immediately to signal the clients that we're overloaded - and we are, but\n * we still keep on trucking.\n *\n * There is one caveat: it's not reliable in a multi-threaded environment.\n * The file descriptor limit is per process. Our party trick fails if another\n * thread opens a file or creates a socket in the time window between us\n * calling close() and accept().\n */\n", "func_signal": "static int uv__emfile_trick(uv_loop_t* loop, int accept_fd)", "code": "{\n  int err;\n  int emfile_fd;\n\n  if (loop->emfile_fd == -1)\n    return -EMFILE;\n\n  uv__close(loop->emfile_fd);\n  loop->emfile_fd = -1;\n\n  do {\n    err = uv__accept(accept_fd);\n    if (err >= 0)\n      uv__close(err);\n  } while (err >= 0 || err == -EINTR);\n\n  emfile_fd = uv__open_cloexec(\"/\", O_RDONLY);\n  if (emfile_fd >= 0)\n    loop->emfile_fd = emfile_fd;\n\n  return err;\n}", "path": "ring/extensions/ringlibuv/libuv/src/unix/stream.c", "commit_date": "2018-01-25 00:00:00", "repo_name": "ring-lang/ring", "stars": 1206, "license": "mit", "language": "c", "size": 2325340}
{"docstring": "/* Return component 'c' of pixel 'x' from the given row. */\n", "func_signal": "static unsigned int\ncomponent(png_const_bytep row, png_uint_32 x, unsigned int c,\n   unsigned int bit_depth, unsigned int channels)", "code": "{\n   /* PNG images can be up to 2^31 pixels wide, but this means they can be up to\n    * 2^37 bits wide (for a 64-bit pixel - the largest possible) and hence 2^34\n    * bytes wide.  Since the row fitted into memory, however, the following must\n    * work:\n    */\n   png_uint_32 bit_offset_hi = bit_depth * ((x >> 6) * channels);\n   png_uint_32 bit_offset_lo = bit_depth * ((x & 0x3f) * channels + c);\n\n   row = (png_const_bytep)(((PNG_CONST png_byte (*)[8])row) + bit_offset_hi);\n   row += bit_offset_lo >> 3;\n   bit_offset_lo &= 0x07;\n\n   /* PNG pixels are packed into bytes to put the first pixel in the highest\n    * bits of the byte and into two bytes for 16-bit values with the high 8 bits\n    * first, so:\n    */\n   switch (bit_depth)\n   {\n      case 1: return (row[0] >> (7-bit_offset_lo)) & 0x01;\n      case 2: return (row[0] >> (6-bit_offset_lo)) & 0x03;\n      case 4: return (row[0] >> (4-bit_offset_lo)) & 0x0f;\n      case 8: return row[0];\n      case 16: return (row[0] << 8) + row[1];\n      default:\n         /* This should never happen, it indicates a bug in this program or in\n          * libpng itself:\n          */\n         fprintf(stderr, \"pngpixel: invalid bit depth %u\\n\", bit_depth);\n         exit(1);\n   }\n}", "path": "ring/extensions/android/ringlibsdl/project/jni/SDL2_image/external/libpng-1.6.2/contrib/examples/pngpixel.c", "commit_date": "2020-04-15 00:00:00", "repo_name": "ring-lang/ring", "stars": 1206, "license": "mit", "language": "c", "size": 2325340}
{"docstring": "/* defined(__APPLE__) */\n", "func_signal": "int uv__stream_open(uv_stream_t* stream, int fd, int flags)", "code": "{\n#if defined(__APPLE__)\n  int enable;\n#endif\n\n  if (!(stream->io_watcher.fd == -1 || stream->io_watcher.fd == fd))\n    return -EBUSY;\n\n  assert(fd >= 0);\n  stream->flags |= flags;\n\n  if (stream->type == UV_TCP) {\n    if ((stream->flags & UV_TCP_NODELAY) && uv__tcp_nodelay(fd, 1))\n      return -errno;\n\n    /* TODO Use delay the user passed in. */\n    if ((stream->flags & UV_TCP_KEEPALIVE) && uv__tcp_keepalive(fd, 1, 60))\n      return -errno;\n  }\n\n#if defined(__APPLE__)\n  enable = 1;\n  if (setsockopt(fd, SOL_SOCKET, SO_OOBINLINE, &enable, sizeof(enable)) &&\n      errno != ENOTSOCK &&\n      errno != EINVAL) {\n    return -errno;\n  }\n#endif\n\n  stream->io_watcher.fd = fd;\n\n  return 0;\n}", "path": "ring/extensions/ringlibuv/libuv/src/unix/stream.c", "commit_date": "2018-01-25 00:00:00", "repo_name": "ring-lang/ring", "stars": 1206, "license": "mit", "language": "c", "size": 2325340}
{"docstring": "/* Mark an object */\n", "func_signal": "static void gc_mark_object(struct mjs *mjs, mjs_val_t *v)", "code": "{\n  struct mjs_object *obj_base;\n  struct mjs_property *prop;\n  struct mjs_property *next;\n\n  assert(mjs_is_object(*v));\n\n  obj_base = get_object_struct(*v);\n\n  /*\n   * we treat all object like things like objects but they might be functions,\n   * gc_check_val checks the appropriate arena per actual value type.\n   */\n  if (!gc_check_val(mjs, *v)) {\n    abort();\n  }\n\n  if (MARKED(obj_base)) return;\n\n  /* mark object itself, and its properties */\n  for ((prop = obj_base->properties), MARK(obj_base); prop != NULL;\n       prop = next) {\n    if (!gc_check_ptr(&mjs->property_arena, prop)) {\n      abort();\n    }\n\n    gc_mark(mjs, &prop->name);\n    gc_mark(mjs, &prop->value);\n\n    next = prop->next;\n    MARK(prop);\n  }\n\n  /* mark object's prototype */\n  /*\n   * We dropped support for object prototypes in MJS.\n   * If we ever bring it back, don't forget to mark it\n   */\n  /* gc_mark(mjs, mjs_get_proto(mjs, v)); */\n}", "path": "mjs/mjs.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "cesanta/mjs", "stars": 1804, "license": "other", "language": "c", "size": 5729}
{"docstring": "/* Amalgamated: #include \"common/cs_dbg.h\" */\n/* Amalgamated: #include \"mjs/src/mjs_tok.h\" */\n", "func_signal": "MJS_PRIVATE void pinit(const char *file_name, const char *buf,\n                       struct pstate *p)", "code": "{\n  memset(p, 0, sizeof(*p));\n  p->line_no = 1;\n  p->last_emitted_line_no = 1;\n  p->file_name = file_name;\n  p->buf = p->pos = buf;\n  mbuf_init(&p->offset_lineno_map, 0);\n}", "path": "mjs/mjs.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "cesanta/mjs", "stars": 1804, "license": "other", "language": "c", "size": 5729}
{"docstring": "/* key = identifier | string */\n", "func_signal": "static int json_parse_key(struct frozen *f)", "code": "{\n  int ch = json_cur(f);\n  if (json_isalpha(ch)) {\n    TRY(json_parse_identifier(f));\n  } else if (ch == '\"') {\n    TRY(json_parse_string(f));\n  } else {\n    return ch == END_OF_STRING ? JSON_STRING_INCOMPLETE : JSON_STRING_INVALID;\n  }\n  return 0;\n}", "path": "mjs/mjs.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "cesanta/mjs", "stars": 1804, "license": "other", "language": "c", "size": 5729}
{"docstring": "/*\n * mark an mbuf containing `mjs_val_t` values (*not pointers* to them)\n */\n", "func_signal": "static void gc_mark_mbuf_val(struct mjs *mjs, const struct mbuf *mbuf)", "code": "{\n  gc_mark_val_array(mjs, (mjs_val_t *) mbuf->buf,\n                    mbuf->len / sizeof(mjs_val_t));\n}", "path": "mjs/mjs.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "cesanta/mjs", "stars": 1804, "license": "other", "language": "c", "size": 5729}
{"docstring": "// Try to parse a token that takes exactly 4 chars.\n", "func_signal": "static int longtok4(struct pstate *p, char a, char b, char c, char d)", "code": "{\n  if (p->pos[0] == a && p->pos[1] == b && p->pos[2] == c && p->pos[3] == d) {\n    p->tok.len += 3;\n    p->pos += 3;\n    return p->pos[-3] << 24 | p->pos[-2] << 16 | p->pos[-1] << 8 | p->pos[0];\n  }\n  return TOK_EOF;\n}", "path": "mjs/mjs.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "cesanta/mjs", "stars": 1804, "license": "other", "language": "c", "size": 5729}
{"docstring": "/* Amalgamated: #include \"mjs/src/mjs_core.h\" */\n/* Amalgamated: #include \"mjs/src/mjs_exec.h\" */\n/* Amalgamated: #include \"mjs/src/mjs_internal.h\" */\n/* Amalgamated: #include \"mjs/src/mjs_primitive.h\" */\n/* Amalgamated: #include \"mjs/src/mjs_util.h\" */\n", "func_signal": "int main(int argc, char *argv[])", "code": "{\n  struct mjs *mjs = mjs_create();\n  mjs_val_t res = MJS_UNDEFINED;\n  mjs_err_t err = MJS_OK;\n  int i;\n\n  for (i = 1; i < argc && argv[i][0] == '-' && err == MJS_OK; i++) {\n    if (strcmp(argv[i], \"-l\") == 0 && i + 1 < argc) {\n      cs_log_set_level(atoi(argv[++i]));\n    } else if (strcmp(argv[i], \"-j\") == 0) {\n      mjs_set_generate_jsc(mjs, 1);\n    } else if (strcmp(argv[i], \"-e\") == 0 && i + 1 < argc) {\n      err = mjs_exec(mjs, argv[++i], &res);\n    } else if (strcmp(argv[i], \"-f\") == 0 && i + 1 < argc) {\n      err = mjs_exec_file(mjs, argv[++i], &res);\n    } else if (strcmp(argv[i], \"-h\") == 0 || strcmp(argv[i], \"--help\") == 0) {\n      printf(\"mJS (c) Cesanta, built: \" __DATE__ \"\\n\");\n      printf(\"Usage:\\n\");\n      printf(\"%s [OPTIONS] [js_file ...]\\n\", argv[0]);\n      printf(\"OPTIONS:\\n\");\n      printf(\"  -e string    - Execute JavaScript expression\\n\");\n      printf(\"  -j           - Enable code precompiling to .jsc files\\n\");\n      printf(\"  -f js_file   - Execute code from .js JavaScript file\\n\");\n      printf(\"  -l level     - Set debug level, from 0 to 5\\n\");\n      return EXIT_SUCCESS;\n    } else {\n      fprintf(stderr, \"Unknown flag: [%s]\\n\", argv[i]);\n      return EXIT_FAILURE;\n    }\n  }\n  for (; i < argc && err == MJS_OK; i++) {\n    err = mjs_exec_file(mjs, argv[i], &res);\n  }\n\n  if (err == MJS_OK) {\n    mjs_fprintf(res, mjs, stdout);\n    putchar('\\n');\n  } else {\n    mjs_print_error(mjs, stdout, NULL, 1 /* print_stack_trace */);\n  }\n  mjs_destroy(mjs);\n\n  return EXIT_SUCCESS;\n}", "path": "mjs/mjs.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "cesanta/mjs", "stars": 1804, "license": "other", "language": "c", "size": 5729}
{"docstring": "/*\n * mark an mbuf containing *pointers* to `mjs_val_t` values\n */\n", "func_signal": "static void gc_mark_mbuf_pt(struct mjs *mjs, const struct mbuf *mbuf)", "code": "{\n  mjs_val_t **vp;\n  for (vp = (mjs_val_t **) mbuf->buf; (char *) vp < mbuf->buf + mbuf->len;\n       vp++) {\n    gc_mark(mjs, *vp);\n  }\n}", "path": "mjs/mjs.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "cesanta/mjs", "stars": 1804, "license": "other", "language": "c", "size": 5729}
{"docstring": "/* JSON_ENABLE_BASE64 */\n", "func_signal": "static unsigned char hexdec(const char *s)", "code": "{\n#define HEXTOI(x) (x >= '0' && x <= '9' ? x - '0' : x - 'W')\n  int a = tolower(*(const unsigned char *) s);\n  int b = tolower(*(const unsigned char *) (s + 1));\n  return (HEXTOI(a) << 4) | HEXTOI(b);\n}", "path": "mjs/mjs.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "cesanta/mjs", "stars": 1804, "license": "other", "language": "c", "size": 5729}
{"docstring": "/*\n * TODO(dfrank): add support for unsigned ints to ffi and use\n * unsigned int here\n */\n", "func_signal": "double mjs_mem_get_int(void *ptr, int size, int bigendian)", "code": "{\n  uint8_t *p = (uint8_t *) ptr;\n  int i, inc = bigendian ? 1 : -1;\n  int res = 0;\n  p += bigendian ? 0 : size - 1;\n\n  for (i = 0; i < size; i++, p += inc) {\n    res <<= 8;\n    res |= *p;\n  }\n\n  /* sign-extend */\n  {\n    int extra = sizeof(res) - size;\n    for (i = 0; i < extra; i++) res <<= 8;\n    for (i = 0; i < extra; i++) res >>= 8;\n  }\n\n  return res;\n}", "path": "mjs/mjs.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "cesanta/mjs", "stars": 1804, "license": "other", "language": "c", "size": 5729}
{"docstring": "// Try to parse a token that can take one or two chars.\n", "func_signal": "static int longtok(struct pstate *p, const char *first_chars,\n                   const char *second_chars)", "code": "{\n  if (strchr(first_chars, p->pos[0]) == NULL) return TOK_EOF;\n  if (p->pos[1] != '\\0' && strchr(second_chars, p->pos[1]) != NULL) {\n    p->tok.len++;\n    p->pos++;\n    return p->pos[-1] << 8 | p->pos[0];\n  }\n  return p->pos[0];\n}", "path": "mjs/mjs.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "cesanta/mjs", "stars": 1804, "license": "other", "language": "c", "size": 5729}
{"docstring": "/* Callback for json_walk() */\n", "func_signal": "static void frozen_cb(void *data, const char *name, size_t name_len,\n                      const char *path, const struct json_token *token)", "code": "{\n  struct json_parse_ctx *ctx = (struct json_parse_ctx *) data;\n  mjs_val_t v = MJS_UNDEFINED;\n\n  (void) path;\n\n  mjs_own(ctx->mjs, &v);\n\n  switch (token->type) {\n    case JSON_TYPE_STRING: {\n      char *dst;\n      if (token->len > 0 && (dst = malloc(token->len)) != NULL) {\n        int len = json_unescape(token->ptr, token->len, dst, token->len);\n        if (len < 0) {\n          mjs_prepend_errorf(ctx->mjs, MJS_TYPE_ERROR, \"invalid JSON string\");\n          break;\n        }\n        v = mjs_mk_string(ctx->mjs, dst, len, 1 /* copy */);\n        free(dst);\n      } else {\n        /*\n         * This branch is for 0-len strings, and for malloc errors\n         * TODO(lsm): on malloc error, propagate the error upstream\n         */\n        v = mjs_mk_string(ctx->mjs, \"\", 0, 1 /* copy */);\n      }\n      break;\n    }\n    case JSON_TYPE_NUMBER:\n      v = mjs_mk_number(ctx->mjs, strtod(token->ptr, NULL));\n      break;\n    case JSON_TYPE_TRUE:\n      v = mjs_mk_boolean(ctx->mjs, 1);\n      break;\n    case JSON_TYPE_FALSE:\n      v = mjs_mk_boolean(ctx->mjs, 0);\n      break;\n    case JSON_TYPE_NULL:\n      v = MJS_NULL;\n      break;\n    case JSON_TYPE_OBJECT_START:\n      v = mjs_mk_object(ctx->mjs);\n      break;\n    case JSON_TYPE_ARRAY_START:\n      v = mjs_mk_array(ctx->mjs);\n      break;\n\n    case JSON_TYPE_OBJECT_END:\n    case JSON_TYPE_ARRAY_END: {\n      /* Object or array has finished: deallocate its frame */\n      ctx->frame = free_json_frame(ctx, ctx->frame);\n    } break;\n\n    default:\n      LOG(LL_ERROR, (\"Wrong token type %d\\n\", token->type));\n      break;\n  }\n\n  if (!mjs_is_undefined(v)) {\n    if (name != NULL && name_len != 0) {\n      /* Need to define a property on the current object/array */\n      if (mjs_is_object(ctx->frame->val)) {\n        mjs_set(ctx->mjs, ctx->frame->val, name, name_len, v);\n      } else if (mjs_is_array(ctx->frame->val)) {\n        /*\n         * TODO(dfrank): consult name_len. Currently it's not a problem due to\n         * the implementation details of frozen, but it might change\n         */\n        int idx = (int) strtod(name, NULL);\n        mjs_array_set(ctx->mjs, ctx->frame->val, idx, v);\n      } else {\n        LOG(LL_ERROR, (\"Current value is neither object nor array\\n\"));\n      }\n    } else {\n      /* This is a root value */\n      assert(ctx->frame == NULL);\n\n      /*\n       * This value will also be the overall result of JSON parsing\n       * (it's already owned by the `mjs_alt_json_parse()`)\n       */\n      ctx->result = v;\n    }\n\n    if (token->type == JSON_TYPE_OBJECT_START ||\n        token->type == JSON_TYPE_ARRAY_START) {\n      /* New object or array has just started, so we need to allocate a frame\n       * for it */\n      struct json_parse_frame *new_frame = alloc_json_frame(ctx, v);\n      new_frame->up = ctx->frame;\n      ctx->frame = new_frame;\n    }\n  }\n\n  mjs_disown(ctx->mjs, &v);\n}", "path": "mjs/mjs.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "cesanta/mjs", "stars": 1804, "license": "other", "language": "c", "size": 5729}
{"docstring": "/*\n * Scans the arena and add all unmarked cells to the free list.\n *\n * Empty blocks get deallocated. The head of the free list will contais cells\n * from the last (oldest) block. Cells will thus be allocated in block order.\n */\n", "func_signal": "void gc_sweep(struct mjs *mjs, struct gc_arena *a, size_t start)", "code": "{\n  struct gc_block *b;\n  struct gc_cell *cur;\n  struct gc_block **prevp = &a->blocks;\n#if MJS_MEMORY_STATS\n  a->alive = 0;\n#endif\n\n  /*\n   * Before we sweep, we should mark all free cells in a way that is\n   * distinguishable from marked used cells.\n   */\n  {\n    struct gc_cell *next;\n    for (cur = a->free; cur != NULL; cur = next) {\n      next = cur->head.link;\n      MARK_FREE(cur);\n    }\n  }\n\n  /*\n   * We'll rebuild the whole `free` list, so initially we just reset it\n   */\n  a->free = NULL;\n\n  for (b = a->blocks; b != NULL;) {\n    size_t freed_in_block = 0;\n    /*\n     * if it turns out that this block is 100% garbage\n     * we can release the whole block, but the addition\n     * of it's cells to the free list has to be undone.\n     */\n    struct gc_cell *prev_free = a->free;\n\n    for (cur = GC_CELL_OP(a, b->base, +, start);\n         cur < GC_CELL_OP(a, b->base, +, b->size);\n         cur = GC_CELL_OP(a, cur, +, 1)) {\n      if (MARKED(cur)) {\n        /* The cell is used and marked  */\n        UNMARK(cur);\n#if MJS_MEMORY_STATS\n        a->alive++;\n#endif\n      } else {\n        /*\n         * The cell is either:\n         * - free\n         * - garbage that's about to be freed\n         */\n\n        if (MARKED_FREE(cur)) {\n          /* The cell is free, so, just unmark it */\n          UNMARK_FREE(cur);\n        } else {\n          /*\n           * The cell is used and should be freed: call the destructor and\n           * reset the memory\n           */\n          if (a->destructor != NULL) {\n            a->destructor(mjs, cur);\n          }\n          memset(cur, 0, a->cell_size);\n        }\n\n        /* Add this cell to the `free` list */\n        cur->head.link = a->free;\n        a->free = cur;\n        freed_in_block++;\n#if MJS_MEMORY_STATS\n        a->garbage++;\n#endif\n      }\n    }\n\n    /*\n     * don't free the initial block, which is at the tail\n     * because it has a special size aimed at reducing waste\n     * and simplifying initial startup. TODO(mkm): improve\n     * */\n    if (b->next != NULL && freed_in_block == b->size) {\n      *prevp = b->next;\n      gc_free_block(b);\n      b = *prevp;\n      a->free = prev_free;\n    } else {\n      prevp = &b->next;\n      b = b->next;\n    }\n  }\n}", "path": "mjs/mjs.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "cesanta/mjs", "stars": 1804, "license": "other", "language": "c", "size": 5729}
{"docstring": "/* Free JSON parse frame, return the previous one (which may be NULL) */\n", "func_signal": "static struct json_parse_frame *free_json_frame(\n    struct json_parse_ctx *ctx, struct json_parse_frame *frame)", "code": "{\n  struct json_parse_frame *up = frame->up;\n  mjs_disown(ctx->mjs, &frame->val);\n  free(frame);\n  return up;\n}", "path": "mjs/mjs.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "cesanta/mjs", "stars": 1804, "license": "other", "language": "c", "size": 5729}
{"docstring": "/* Perform garbage collection */\n", "func_signal": "void mjs_gc(struct mjs *mjs, int full)", "code": "{\n  gc_mark_val_array(mjs, (mjs_val_t *) &mjs->vals,\n                    sizeof(mjs->vals) / sizeof(mjs_val_t));\n\n  gc_mark_mbuf_pt(mjs, &mjs->owned_values);\n  gc_mark_mbuf_val(mjs, &mjs->scopes);\n  gc_mark_mbuf_val(mjs, &mjs->stack);\n  gc_mark_mbuf_val(mjs, &mjs->call_stack);\n\n  gc_mark_ffi_cbargs_list(mjs, mjs->ffi_cb_args);\n\n  gc_compact_strings(mjs);\n\n  gc_sweep(mjs, &mjs->object_arena, 0);\n  gc_sweep(mjs, &mjs->property_arena, 0);\n  gc_sweep(mjs, &mjs->ffi_sig_arena, 0);\n\n  if (full) {\n    /*\n     * In case of full GC, we also resize strings buffer, but we still leave\n     * some extra space (at most, `_MJS_STRING_BUF_RESERVE`) in order to avoid\n     * frequent reallocations\n     */\n    size_t trimmed_size = mjs->owned_strings.len + _MJS_STRING_BUF_RESERVE;\n    if (trimmed_size < mjs->owned_strings.size) {\n      mbuf_resize(&mjs->owned_strings, trimmed_size);\n    }\n  }\n}", "path": "mjs/mjs.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "cesanta/mjs", "stars": 1804, "license": "other", "language": "c", "size": 5729}
{"docstring": "/* number = [ '-' ] digit+ [ '.' digit+ ] [ ['e'|'E'] ['+'|'-'] digit+ ] */\n", "func_signal": "static int json_parse_number(struct frozen *f)", "code": "{\n  int ch = json_cur(f);\n  SET_STATE(f, f->cur, \"\", 0);\n  if (ch == '-') f->cur++;\n  EXPECT(f->cur < f->end, JSON_STRING_INCOMPLETE);\n  if (f->cur + 1 < f->end && f->cur[0] == '0' && f->cur[1] == 'x') {\n    f->cur += 2;\n    EXPECT(f->cur < f->end, JSON_STRING_INCOMPLETE);\n    EXPECT(json_isxdigit(f->cur[0]), JSON_STRING_INVALID);\n    while (f->cur < f->end && json_isxdigit(f->cur[0])) f->cur++;\n  } else {\n    EXPECT(json_isdigit(f->cur[0]), JSON_STRING_INVALID);\n    while (f->cur < f->end && json_isdigit(f->cur[0])) f->cur++;\n    if (f->cur < f->end && f->cur[0] == '.') {\n      f->cur++;\n      EXPECT(f->cur < f->end, JSON_STRING_INCOMPLETE);\n      EXPECT(json_isdigit(f->cur[0]), JSON_STRING_INVALID);\n      while (f->cur < f->end && json_isdigit(f->cur[0])) f->cur++;\n    }\n    if (f->cur < f->end && (f->cur[0] == 'e' || f->cur[0] == 'E')) {\n      f->cur++;\n      EXPECT(f->cur < f->end, JSON_STRING_INCOMPLETE);\n      if ((f->cur[0] == '+' || f->cur[0] == '-')) f->cur++;\n      EXPECT(f->cur < f->end, JSON_STRING_INCOMPLETE);\n      EXPECT(json_isdigit(f->cur[0]), JSON_STRING_INVALID);\n      while (f->cur < f->end && json_isdigit(f->cur[0])) f->cur++;\n    }\n  }\n  json_truncate_path(f, fstate.path_len);\n  CALL_BACK(f, JSON_TYPE_NUMBER, fstate.ptr, f->cur - fstate.ptr);\n  return 0;\n}", "path": "mjs/mjs.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "cesanta/mjs", "stars": 1804, "license": "other", "language": "c", "size": 5729}
{"docstring": "/* like c_snprintf but returns `size` if write is truncated */\n", "func_signal": "static int v_sprintf_s(char *buf, size_t size, const char *fmt, ...)", "code": "{\n  size_t n;\n  va_list ap;\n  va_start(ap, fmt);\n  n = c_vsnprintf(buf, size, fmt, ap);\n  if (n > size) {\n    return size;\n  }\n  return n;\n}", "path": "mjs/mjs.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "cesanta/mjs", "stars": 1804, "license": "other", "language": "c", "size": 5729}
{"docstring": "/* pair = key ':' value */\n", "func_signal": "static int json_parse_pair(struct frozen *f)", "code": "{\n  int current_path_len;\n  const char *tok;\n  json_skip_whitespaces(f);\n  tok = f->cur;\n  TRY(json_parse_key(f));\n  {\n    f->cur_name = *tok == '\"' ? tok + 1 : tok;\n    f->cur_name_len = *tok == '\"' ? f->cur - tok - 2 : f->cur - tok;\n    current_path_len = json_append_to_path(f, f->cur_name, f->cur_name_len);\n  }\n  TRY(json_test_and_skip(f, ':'));\n  TRY(json_parse_value(f));\n  json_truncate_path(f, current_path_len);\n  return 0;\n}", "path": "mjs/mjs.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "cesanta/mjs", "stars": 1804, "license": "other", "language": "c", "size": 5729}
{"docstring": "/*\n * TODO(dfrank): add support for unsigned ints to ffi and use\n * unsigned int here\n */\n", "func_signal": "double mjs_mem_get_uint(void *ptr, int size, int bigendian)", "code": "{\n  uint8_t *p = (uint8_t *) ptr;\n  int i, inc = bigendian ? 1 : -1;\n  unsigned int res = 0;\n  p += bigendian ? 0 : size - 1;\n  for (i = 0; i < size; i++, p += inc) {\n    res <<= 8;\n    res |= *p;\n  }\n  return res;\n}", "path": "mjs/mjs.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "cesanta/mjs", "stars": 1804, "license": "other", "language": "c", "size": 5729}
{"docstring": "/* Amalgamated: #include \"mjs/src/mjs_internal.h\" */\n/* Amalgamated: #include \"mjs/src/mjs_bcode.h\" */\n/* Amalgamated: #include \"mjs/src/mjs_core.h\" */\n/* Amalgamated: #include \"mjs/src/mjs_tok.h\" */\n", "func_signal": "static void add_lineno_map_item(struct pstate *pstate)", "code": "{\n  if (pstate->last_emitted_line_no < pstate->line_no) {\n    int offset = pstate->cur_idx - pstate->start_bcode_idx;\n    size_t offset_llen = cs_varint_llen(offset);\n    size_t lineno_llen = cs_varint_llen(pstate->line_no);\n    mbuf_resize(&pstate->offset_lineno_map,\n                pstate->offset_lineno_map.size + offset_llen + lineno_llen);\n\n    /* put offset */\n    cs_varint_encode(offset, (uint8_t *) pstate->offset_lineno_map.buf +\n                                 pstate->offset_lineno_map.len,\n                     offset_llen);\n    pstate->offset_lineno_map.len += offset_llen;\n\n    /* put line_no */\n    cs_varint_encode(pstate->line_no,\n                     (uint8_t *) pstate->offset_lineno_map.buf +\n                         pstate->offset_lineno_map.len,\n                     lineno_llen);\n    pstate->offset_lineno_map.len += lineno_llen;\n\n    pstate->last_emitted_line_no = pstate->line_no;\n  }\n}", "path": "mjs/mjs.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "cesanta/mjs", "stars": 1804, "license": "other", "language": "c", "size": 5729}
{"docstring": "/*\n * Pushes call stack frame. Offset is a global bcode offset. Retval_stack_idx\n * is an index in mjs->stack at which return value should be written later.\n */\n", "func_signal": "static void call_stack_push_frame(struct mjs *mjs, size_t offset,\n                                  mjs_val_t retval_stack_idx)", "code": "{\n  /* Pop `this` value, and apply it */\n  mjs_val_t this_obj = mjs_pop_val(&mjs->arg_stack);\n\n  /*\n   * NOTE: the layout is described by enum mjs_call_stack_frame_item\n   */\n  push_mjs_val(&mjs->call_stack, mjs->vals.this_obj);\n  mjs->vals.this_obj = this_obj;\n\n  push_mjs_val(&mjs->call_stack, mjs_mk_number(mjs, (double) offset));\n  push_mjs_val(&mjs->call_stack,\n               mjs_mk_number(mjs, (double) mjs_stack_size(&mjs->scopes)));\n  push_mjs_val(\n      &mjs->call_stack,\n      mjs_mk_number(mjs, (double) mjs_stack_size(&mjs->loop_addresses)));\n  push_mjs_val(&mjs->call_stack, retval_stack_idx);\n}", "path": "mjs/mjs.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "cesanta/mjs", "stars": 1804, "license": "other", "language": "c", "size": 5729}
{"docstring": "/*\n  Write a block to disk where part of the data may be inside the record\n  buffer.  As all write calls to the data goes through the cache,\n  we will never get a seek over the end of the buffer\n*/\n", "func_signal": "int my_block_write(register IO_CACHE *info, const uchar *Buffer, size_t Count,\n\t\t   my_off_t pos)", "code": "{\n  size_t length;\n  int error=0;\n\n  /*\n    Assert that we cannot come here with a shared cache. If we do one\n    day, we might need to add a call to copy_to_read_buffer().\n  */\n  DBUG_ASSERT(!info->share);\n\n  if (pos < info->pos_in_file)\n  {\n    /* Of no overlap, write everything without buffering */\n    if (pos + Count <= info->pos_in_file)\n      return mysql_file_pwrite(info->file, Buffer, Count, pos,\n\t\t               info->myflags | MY_NABP);\n    /* Write the part of the block that is before buffer */\n    length= (uint) (info->pos_in_file - pos);\n    if (mysql_file_pwrite(info->file, Buffer, length, pos, info->myflags | MY_NABP))\n      info->error= error= -1;\n    Buffer+=length;\n    pos+=  length;\n    Count-= length;\n#ifndef HAVE_PREAD\n    info->seek_not_done=1;\n#endif\n  }\n\n  /* Check if we want to write inside the used part of the buffer.*/\n  length= (size_t) (info->write_end - info->buffer);\n  if (pos < info->pos_in_file + length)\n  {\n    size_t offset= (size_t) (pos - info->pos_in_file);\n    length-=offset;\n    if (length > Count)\n      length=Count;\n    memcpy(info->buffer+offset, Buffer, length);\n    Buffer+=length;\n    Count-= length;\n    /* Fix length of buffer if the new data was larger */\n    if (info->buffer+length > info->write_pos)\n      info->write_pos=info->buffer+length;\n    if (!Count)\n      return (error);\n  }\n  /* Write at the end of the current buffer; This is the normal case */\n  if (_my_b_write(info, Buffer, Count))\n    error= -1;\n  return error;\n}", "path": "inception/mysys/mf_iocache.c", "commit_date": "2015-08-28 00:00:00", "repo_name": "arkdb/inception", "stars": 1846, "license": "gpl-2.0", "language": "c", "size": 17825}
{"docstring": "/* ch_end():\n *\tFree the data structures used by the editor\n */\n", "func_signal": "protected void\nch_end(EditLine *el)", "code": "{\n\tel_free(el->el_line.buffer);\n\tel->el_line.buffer = NULL;\n\tel->el_line.limit = NULL;\n\tel_free(el->el_chared.c_undo.buf);\n\tel->el_chared.c_undo.buf = NULL;\n\tel_free(el->el_chared.c_redo.buf);\n\tel->el_chared.c_redo.buf = NULL;\n\tel->el_chared.c_redo.pos = NULL;\n\tel->el_chared.c_redo.lim = NULL;\n\tel->el_chared.c_redo.cmd = ED_UNASSIGNED;\n\tel_free(el->el_chared.c_kill.buf);\n\tel->el_chared.c_kill.buf = NULL;\n\tch_reset(el, 1);\n\tel_free(el->el_chared.c_macro.macro);\n\tel->el_chared.c_macro.macro = NULL;\n}", "path": "inception/cmd-line-utils/libedit/chared.c", "commit_date": "2015-08-28 00:00:00", "repo_name": "arkdb/inception", "stars": 1846, "license": "gpl-2.0", "language": "c", "size": 17825}
{"docstring": "/* cv_yank():\n *\tSave yank/delete data for paste\n */\n", "func_signal": "protected void\ncv_yank(EditLine *el, const Char *ptr, int size)", "code": "{\n\tc_kill_t *k = &el->el_chared.c_kill;\n\n\t(void)memcpy(k->buf, ptr, (size_t)size * sizeof(*k->buf));\n\tk->last = k->buf + size;\n}", "path": "inception/cmd-line-utils/libedit/chared.c", "commit_date": "2015-08-28 00:00:00", "repo_name": "arkdb/inception", "stars": 1846, "license": "gpl-2.0", "language": "c", "size": 17825}
{"docstring": "/* el_insertstr():\n *\tInsert string at cursorI\n */\n", "func_signal": "public int\nFUN(el,insertstr)(EditLine *el, const Char *s)", "code": "{\n\tsize_t len;\n\n\tif ((len = Strlen(s)) == 0)\n\t\treturn -1;\n\tif (el->el_line.lastchar + len >= el->el_line.limit) {\n\t\tif (!ch_enlargebufs(el, len))\n\t\t\treturn -1;\n\t}\n\n\tc_insert(el, (int)len);\n\twhile (*s)\n\t\t*el->el_line.cursor++ = *s++;\n\treturn 0;\n}", "path": "inception/cmd-line-utils/libedit/chared.c", "commit_date": "2015-08-28 00:00:00", "repo_name": "arkdb/inception", "stars": 1846, "license": "gpl-2.0", "language": "c", "size": 17825}
{"docstring": "/* cv_prev_word():\n *\tFind the previous word vi style\n */\n", "func_signal": "protected Char *\ncv_prev_word(Char *p, Char *low, int n, int (*wtest)(Int))", "code": "{\n\tint test;\n\n\tp--;\n\twhile (n--) {\n\t\twhile ((p > low) && Isspace(*p))\n\t\t\tp--;\n\t\ttest = (*wtest)(*p);\n\t\twhile ((p >= low) && (*wtest)(*p) == test)\n\t\t\tp--;\n\t}\n\tp++;\n\n\t/* p now points where we want it */\n\tif (p < low)\n\t\treturn low;\n\telse\n\t\treturn p;\n}", "path": "inception/cmd-line-utils/libedit/chared.c", "commit_date": "2015-08-28 00:00:00", "repo_name": "arkdb/inception", "stars": 1846, "license": "gpl-2.0", "language": "c", "size": 17825}
{"docstring": "/* c__next_word():\n *\tFind the next word\n */\n", "func_signal": "protected Char *\nc__next_word(Char *p, Char *high, int n, int (*wtest)(Int))", "code": "{\n\twhile (n--) {\n\t\twhile ((p < high) && !(*wtest)(*p))\n\t\t\tp++;\n\t\twhile ((p < high) && (*wtest)(*p))\n\t\t\tp++;\n\t}\n\tif (p > high)\n\t\tp = high;\n\t/* p now points where we want it */\n\treturn p;\n}", "path": "inception/cmd-line-utils/libedit/chared.c", "commit_date": "2015-08-28 00:00:00", "repo_name": "arkdb/inception", "stars": 1846, "license": "gpl-2.0", "language": "c", "size": 17825}
{"docstring": "/* ch_init():\n *\tInitialize the character editor\n */\n", "func_signal": "protected int\nch_init(EditLine *el)", "code": "{\n\tc_macro_t *ma = &el->el_chared.c_macro;\n\n\tel->el_line.buffer\t\t= el_malloc(EL_BUFSIZ *\n\t    sizeof(*el->el_line.buffer));\n\tif (el->el_line.buffer == NULL)\n\t\treturn -1;\n\n\t(void) memset(el->el_line.buffer, 0, EL_BUFSIZ *\n\t    sizeof(*el->el_line.buffer));\n\tel->el_line.cursor\t\t= el->el_line.buffer;\n\tel->el_line.lastchar\t\t= el->el_line.buffer;\n\tel->el_line.limit\t\t= &el->el_line.buffer[EL_BUFSIZ - EL_LEAVE];\n\n\tel->el_chared.c_undo.buf\t= el_malloc(EL_BUFSIZ *\n\t    sizeof(*el->el_chared.c_undo.buf));\n\tif (el->el_chared.c_undo.buf == NULL)\n\t\treturn -1;\n\t(void) memset(el->el_chared.c_undo.buf, 0, EL_BUFSIZ *\n\t    sizeof(*el->el_chared.c_undo.buf));\n\tel->el_chared.c_undo.len\t= -1;\n\tel->el_chared.c_undo.cursor\t= 0;\n\tel->el_chared.c_redo.buf\t= el_malloc(EL_BUFSIZ *\n\t    sizeof(*el->el_chared.c_redo.buf));\n\tif (el->el_chared.c_redo.buf == NULL)\n\t\treturn -1;\n\tel->el_chared.c_redo.pos\t= el->el_chared.c_redo.buf;\n\tel->el_chared.c_redo.lim\t= el->el_chared.c_redo.buf + EL_BUFSIZ;\n\tel->el_chared.c_redo.cmd\t= ED_UNASSIGNED;\n\n\tel->el_chared.c_vcmd.action\t= NOP;\n\tel->el_chared.c_vcmd.pos\t= el->el_line.buffer;\n\n\tel->el_chared.c_kill.buf\t= el_malloc(EL_BUFSIZ *\n\t    sizeof(*el->el_chared.c_kill.buf));\n\tif (el->el_chared.c_kill.buf == NULL)\n\t\treturn -1;\n\t(void) memset(el->el_chared.c_kill.buf, 0, EL_BUFSIZ *\n\t    sizeof(*el->el_chared.c_kill.buf));\n\tel->el_chared.c_kill.mark\t= el->el_line.buffer;\n\tel->el_chared.c_kill.last\t= el->el_chared.c_kill.buf;\n\tel->el_chared.c_resizefun\t= NULL;\n\tel->el_chared.c_resizearg\t= NULL;\n\n\tel->el_map.current\t\t= el->el_map.key;\n\n\tel->el_state.inputmode\t\t= MODE_INSERT; /* XXX: save a default */\n\tel->el_state.doingarg\t\t= 0;\n\tel->el_state.metanext\t\t= 0;\n\tel->el_state.argument\t\t= 1;\n\tel->el_state.lastcmd\t\t= ED_UNASSIGNED;\n\n\tma->level\t= -1;\n\tma->offset\t= 0;\n\tma->macro\t= el_malloc(EL_MAXMACRO * sizeof(*ma->macro));\n\tif (ma->macro == NULL)\n\t\treturn -1;\n\treturn 0;\n}", "path": "inception/cmd-line-utils/libedit/chared.c", "commit_date": "2015-08-28 00:00:00", "repo_name": "arkdb/inception", "stars": 1846, "license": "gpl-2.0", "language": "c", "size": 17825}
{"docstring": "/* cv__isword():\n *\tReturn if p is part of a word according to vi\n */\n", "func_signal": "protected int\ncv__isword(Int p)", "code": "{\n\tif (Isalnum(p) || p == '_')\n\t\treturn 1;\n\tif (Isgraph(p))\n\t\treturn 2;\n\treturn 0;\n}", "path": "inception/cmd-line-utils/libedit/chared.c", "commit_date": "2015-08-28 00:00:00", "repo_name": "arkdb/inception", "stars": 1846, "license": "gpl-2.0", "language": "c", "size": 17825}
{"docstring": "/* c__prev_word():\n *\tFind the previous word\n */\n", "func_signal": "protected Char *\nc__prev_word(Char *p, Char *low, int n, int (*wtest)(Int))", "code": "{\n\tp--;\n\n\twhile (n--) {\n\t\twhile ((p >= low) && !(*wtest)(*p))\n\t\t\tp--;\n\t\twhile ((p >= low) && (*wtest)(*p))\n\t\t\tp--;\n\t}\n\n\t/* cp now points to one character before the word */\n\tp++;\n\tif (p < low)\n\t\tp = low;\n\t/* cp now points where we want it */\n\treturn p;\n}", "path": "inception/cmd-line-utils/libedit/chared.c", "commit_date": "2015-08-28 00:00:00", "repo_name": "arkdb/inception", "stars": 1846, "license": "gpl-2.0", "language": "c", "size": 17825}
{"docstring": "/* c_hpos():\n *\tReturn the current horizontal position of the cursor\n */\n", "func_signal": "protected int\nc_hpos(EditLine *el)", "code": "{\n\tChar *ptr;\n\n\t/*\n\t * Find how many characters till the beginning of this line.\n\t */\n\tif (el->el_line.cursor == el->el_line.buffer)\n\t\treturn 0;\n\telse {\n\t\tfor (ptr = el->el_line.cursor - 1;\n\t\t     ptr >= el->el_line.buffer && *ptr != '\\n';\n\t\t     ptr--)\n\t\t\tcontinue;\n\t\treturn (int)(el->el_line.cursor - ptr - 1);\n\t}\n}", "path": "inception/cmd-line-utils/libedit/chared.c", "commit_date": "2015-08-28 00:00:00", "repo_name": "arkdb/inception", "stars": 1846, "license": "gpl-2.0", "language": "c", "size": 17825}
{"docstring": "/* cv_next_word():\n *\tFind the next word vi style\n */\n", "func_signal": "protected Char *\ncv_next_word(EditLine *el, Char *p, Char *high, int n, int (*wtest)(Int))", "code": "{\n\tint test;\n\n\twhile (n--) {\n\t\ttest = (*wtest)(*p);\n\t\twhile ((p < high) && (*wtest)(*p) == test)\n\t\t\tp++;\n\t\t/*\n\t\t * vi historically deletes with cw only the word preserving the\n\t\t * trailing whitespace! This is not what 'w' does..\n\t\t */\n\t\tif (n || el->el_chared.c_vcmd.action != (DELETE|INSERT))\n\t\t\twhile ((p < high) && Isspace(*p))\n\t\t\t\tp++;\n\t}\n\n\t/* p now points where we want it */\n\tif (p > high)\n\t\treturn high;\n\telse\n\t\treturn p;\n}", "path": "inception/cmd-line-utils/libedit/chared.c", "commit_date": "2015-08-28 00:00:00", "repo_name": "arkdb/inception", "stars": 1846, "license": "gpl-2.0", "language": "c", "size": 17825}
{"docstring": "/*\n  Unlock IO cache.\n\n  SYNOPSIS\n    unlock_io_cache()\n      cache                     The cache of the thread leaving the lock.\n\n  NOTE\n    This is called by the thread that filled the buffer. It marks all\n    threads as running and awakes them. This must not be done by any\n    other thread.\n\n    Do not signal cond_writer. Either there is no writer or the writer\n    is the only one who can call this function.\n\n    The reason for resetting running_threads to total_threads before\n    waking all other threads is that it could be possible that this\n    thread is so fast with processing the buffer that it enters the lock\n    before even one other thread has left it. If every awoken thread\n    would increase running_threads by one, this thread could think that\n    he is again the last to join and would not wait for the other\n    threads to process the data.\n\n  RETURN\n    void\n*/\n", "func_signal": "static void unlock_io_cache(IO_CACHE *cache)", "code": "{\n  IO_CACHE_SHARE *cshare= cache->share;\n  DBUG_ENTER(\"unlock_io_cache\");\n  DBUG_PRINT(\"io_cache_share\", (\"%s: 0x%lx  pos: %lu  running: %u\",\n                                (cache == cshare->source_cache) ?\n                                \"writer\" : \"reader\",\n                                (long) cache, (ulong) cshare->pos_in_file,\n                                cshare->total_threads));\n\n  cshare->running_threads= cshare->total_threads;\n  mysql_cond_broadcast(&cshare->cond);\n  mysql_mutex_unlock(&cshare->mutex);\n  DBUG_VOID_RETURN;\n}", "path": "inception/mysys/mf_iocache.c", "commit_date": "2015-08-28 00:00:00", "repo_name": "arkdb/inception", "stars": 1846, "license": "gpl-2.0", "language": "c", "size": 17825}
{"docstring": "/* c_gets():\n *\tGet a string\n */\n", "func_signal": "protected int\nc_gets(EditLine *el, Char *buf, const Char *prompt)", "code": "{\n\tChar ch;\n\tssize_t len;\n\tChar *cp = el->el_line.buffer;\n\n\tif (prompt) {\n\t\tlen = (ssize_t)Strlen(prompt);\n\t\t(void)memcpy(cp, prompt, (size_t)len * sizeof(*cp));\n\t\tcp += len;\n\t}\n\tlen = 0;\n\n\tfor (;;) {\n\t\tel->el_line.cursor = cp;\n\t\t*cp = ' ';\n\t\tel->el_line.lastchar = cp + 1;\n\t\tre_refresh(el);\n\n\t\tif (FUN(el,getc)(el, &ch) != 1) {\n\t\t\ted_end_of_file(el, 0);\n\t\t\tlen = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (ch) {\n\n\t\tcase 0010:\t/* Delete and backspace */\n\t\tcase 0177:\n\t\t\tif (len == 0) {\n\t\t\t\tlen = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcp--;\n\t\t\tcontinue;\n\n\t\tcase 0033:\t/* ESC */\n\t\tcase '\\r':\t/* Newline */\n\t\tcase '\\n':\n\t\t\tbuf[len] = ch;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif (len >= (ssize_t)(EL_BUFSIZ - 16))\n\t\t\t\tterminal_beep(el);\n\t\t\telse {\n\t\t\t\tbuf[len++] = ch;\n\t\t\t\t*cp++ = ch;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\tel->el_line.buffer[0] = '\\0';\n\tel->el_line.lastchar = el->el_line.buffer;\n\tel->el_line.cursor = el->el_line.buffer;\n\treturn (int)len;\n}", "path": "inception/cmd-line-utils/libedit/chared.c", "commit_date": "2015-08-28 00:00:00", "repo_name": "arkdb/inception", "stars": 1846, "license": "gpl-2.0", "language": "c", "size": 17825}
{"docstring": "/* cv__endword():\n *\tGo to the end of this word according to vi\n */\n", "func_signal": "protected Char *\ncv__endword(Char *p, Char *high, int n, int (*wtest)(Int))", "code": "{\n\tint test;\n\n\tp++;\n\n\twhile (n--) {\n\t\twhile ((p < high) && Isspace(*p))\n\t\t\tp++;\n\n\t\ttest = (*wtest)(*p);\n\t\twhile ((p < high) && (*wtest)(*p) == test)\n\t\t\tp++;\n\t}\n\tp--;\n\treturn p;\n}", "path": "inception/cmd-line-utils/libedit/chared.c", "commit_date": "2015-08-28 00:00:00", "repo_name": "arkdb/inception", "stars": 1846, "license": "gpl-2.0", "language": "c", "size": 17825}
{"docstring": "/*\n  Setup internal pointers inside IO_CACHE\n\n  SYNOPSIS\n    setup_io_cache()\n    info\t\tIO_CACHE handler\n\n  NOTES\n    This is called on automaticly on init or reinit of IO_CACHE\n    It must be called externally if one moves or copies an IO_CACHE\n    object.\n*/\n", "func_signal": "void setup_io_cache(IO_CACHE* info)", "code": "{\n  /* Ensure that my_b_tell() and my_b_bytes_in_cache works */\n  if (info->type == WRITE_CACHE)\n  {\n    info->current_pos= &info->write_pos;\n    info->current_end= &info->write_end;\n  }\n  else\n  {\n    info->current_pos= &info->read_pos;\n    info->current_end= &info->read_end;\n  }\n}", "path": "inception/mysys/mf_iocache.c", "commit_date": "2015-08-28 00:00:00", "repo_name": "arkdb/inception", "stars": 1846, "license": "gpl-2.0", "language": "c", "size": 17825}
{"docstring": "/* c_delbefore1():\n *\tDelete the character before the cursor, do not yank\n */\n", "func_signal": "protected void\nc_delbefore1(EditLine *el)", "code": "{\n\tChar *cp;\n\n\tfor (cp = el->el_line.cursor - 1; cp <= el->el_line.lastchar; cp++)\n\t\t*cp = cp[1];\n\n\tel->el_line.lastchar--;\n}", "path": "inception/cmd-line-utils/libedit/chared.c", "commit_date": "2015-08-28 00:00:00", "repo_name": "arkdb/inception", "stars": 1846, "license": "gpl-2.0", "language": "c", "size": 17825}
{"docstring": "/* c_delafter():\n *\tDelete num characters after the cursor\n */\n", "func_signal": "protected void\nc_delafter(EditLine *el, int num)", "code": "{\n\n\tif (el->el_line.cursor + num > el->el_line.lastchar)\n\t\tnum = (int)(el->el_line.lastchar - el->el_line.cursor);\n\n\tif (el->el_map.current != el->el_map.emacs) {\n\t\tcv_undo(el);\n\t\tcv_yank(el, el->el_line.cursor, num);\n\t}\n\n\tif (num > 0) {\n\t\tChar *cp;\n\n\t\tfor (cp = el->el_line.cursor; cp <= el->el_line.lastchar; cp++)\n\t\t\t*cp = cp[num];\n\n\t\tel->el_line.lastchar -= num;\n\t}\n}", "path": "inception/cmd-line-utils/libedit/chared.c", "commit_date": "2015-08-28 00:00:00", "repo_name": "arkdb/inception", "stars": 1846, "license": "gpl-2.0", "language": "c", "size": 17825}
{"docstring": "/*\n  Initialize an IO_CACHE object\n\n  SYNOPSOS\n    init_io_cache()\n    info\t\tcache handler to initialize\n    file\t\tFile that should be associated to to the handler\n\t\t\tIf == -1 then real_open_cached_file()\n\t\t\twill be called when it's time to open file.\n    cachesize\t\tSize of buffer to allocate for read/write\n\t\t\tIf == 0 then use my_default_record_cache_size\n    type\t\tType of cache\n    seek_offset\t\tWhere cache should start reading/writing\n    use_async_io\tSet to 1 of we should use async_io (if avaiable)\n    cache_myflags\tBitmap of differnt flags\n\t\t\tMY_WME | MY_FAE | MY_NABP | MY_FNABP |\n\t\t\tMY_DONT_CHECK_FILESIZE\n\n  RETURN\n    0  ok\n    #  error\n*/\n", "func_signal": "int init_io_cache(IO_CACHE *info, File file, size_t cachesize,\n\t\t  enum cache_type type, my_off_t seek_offset,\n\t\t  pbool use_async_io, myf cache_myflags)", "code": "{\n  size_t min_cache;\n  my_off_t pos;\n  my_off_t end_of_file= ~(my_off_t) 0;\n  DBUG_ENTER(\"init_io_cache\");\n  DBUG_PRINT(\"enter\",(\"cache: 0x%lx  type: %d  pos: %ld\",\n\t\t      (ulong) info, (int) type, (ulong) seek_offset));\n\n  info->file= file;\n  info->type= TYPE_NOT_SET;\t    /* Don't set it until mutex are created */\n  info->pos_in_file= seek_offset;\n  info->pre_close = info->pre_read = info->post_read = 0;\n  info->arg = 0;\n  info->alloced_buffer = 0;\n  info->buffer=0;\n  info->seek_not_done= 0;\n\n  if (file >= 0)\n  {\n    pos= mysql_file_tell(file, MYF(0));\n    if ((pos == (my_off_t) -1) && (my_errno == ESPIPE))\n    {\n      /*\n         This kind of object doesn't support seek() or tell(). Don't set a\n         flag that will make us again try to seek() later and fail.\n      */\n      info->seek_not_done= 0;\n      /*\n        Additionally, if we're supposed to start somewhere other than the\n        the beginning of whatever this file is, then somebody made a bad\n        assumption.\n      */\n      DBUG_ASSERT(seek_offset == 0);\n    }\n    else\n      info->seek_not_done= test(seek_offset != pos);\n  }\n\n  info->disk_writes= 0;\n  info->share=0;\n\n  if (!cachesize && !(cachesize= my_default_record_cache_size))\n    DBUG_RETURN(1);\t\t\t\t/* No cache requested */\n  min_cache=use_async_io ? IO_SIZE*4 : IO_SIZE*2;\n  if (type == READ_CACHE || type == SEQ_READ_APPEND)\n  {\t\t\t\t\t\t/* Assume file isn't growing */\n    if (!(cache_myflags & MY_DONT_CHECK_FILESIZE))\n    {\n      /* Calculate end of file to avoid allocating oversized buffers */\n      end_of_file= mysql_file_seek(file, 0L, MY_SEEK_END, MYF(0));\n      /* Need to reset seek_not_done now that we just did a seek. */\n      info->seek_not_done= end_of_file == seek_offset ? 0 : 1;\n      if (end_of_file < seek_offset)\n\tend_of_file=seek_offset;\n      /* Trim cache size if the file is very small */\n      if ((my_off_t) cachesize > end_of_file-seek_offset+IO_SIZE*2-1)\n      {\n\tcachesize= (size_t) (end_of_file-seek_offset)+IO_SIZE*2-1;\n\tuse_async_io=0;\t\t\t\t/* No need to use async */\n      }\n    }\n  }\n  cache_myflags &= ~MY_DONT_CHECK_FILESIZE;\n  if (type != READ_NET && type != WRITE_NET)\n  {\n    /* Retry allocating memory in smaller blocks until we get one */\n    cachesize= ((cachesize + min_cache-1) & ~(min_cache-1));\n    for (;;)\n    {\n      size_t buffer_block;\n      /*\n        Unset MY_WAIT_IF_FULL bit if it is set, to prevent conflict with\n        MY_ZEROFILL.\n      */\n      myf flags= (myf) (cache_myflags & ~(MY_WME | MY_WAIT_IF_FULL));\n\n      if (cachesize < min_cache)\n\tcachesize = min_cache;\n      buffer_block= cachesize;\n      if (type == SEQ_READ_APPEND)\n\tbuffer_block *= 2;\n      if (cachesize == min_cache)\n        flags|= (myf) MY_WME;\n\n      if ((info->buffer= (uchar*) my_malloc(buffer_block, flags)) != 0)\n      {\n\tinfo->write_buffer=info->buffer;\n\tif (type == SEQ_READ_APPEND)\n\t  info->write_buffer = info->buffer + cachesize;\n\tinfo->alloced_buffer=1;\n\tbreak;\t\t\t\t\t/* Enough memory found */\n      }\n      if (cachesize == min_cache)\n\tDBUG_RETURN(2);\t\t\t\t/* Can't alloc cache */\n      /* Try with less memory */\n      cachesize= (cachesize*3/4 & ~(min_cache-1));\n    }\n  }\n\n  DBUG_PRINT(\"info\",(\"init_io_cache: cachesize = %lu\", (ulong) cachesize));\n  info->read_length=info->buffer_length=cachesize;\n  info->myflags=cache_myflags & ~(MY_NABP | MY_FNABP);\n  info->request_pos= info->read_pos= info->write_pos = info->buffer;\n  if (type == SEQ_READ_APPEND)\n  {\n    info->append_read_pos = info->write_pos = info->write_buffer;\n    info->write_end = info->write_buffer + info->buffer_length;\n    mysql_mutex_init(key_IO_CACHE_append_buffer_lock,\n                     &info->append_buffer_lock, MY_MUTEX_INIT_FAST);\n  }\n#if defined(SAFE_MUTEX)\n  else\n  {\n    /* Clear mutex so that safe_mutex will notice that it's not initialized */\n    memset(&info->append_buffer_lock, 0, sizeof(info->append_buffer_lock));\n  }\n#endif\n\n  if (type == WRITE_CACHE)\n    info->write_end=\n      info->buffer+info->buffer_length- (seek_offset & (IO_SIZE-1));\n  else\n    info->read_end=info->buffer;\t\t/* Nothing in cache */\n\n  /* End_of_file may be changed by user later */\n  info->end_of_file= end_of_file;\n  info->error=0;\n  info->type= type;\n  init_functions(info);\n#ifdef HAVE_AIOWAIT\n  if (use_async_io && ! my_disable_async_io)\n  {\n    DBUG_PRINT(\"info\",(\"Using async io\"));\n    info->read_length/=2;\n    info->read_function=_my_b_async_read;\n  }\n  info->inited=info->aio_result.pending=0;\n#endif\n  DBUG_RETURN(0);\n}", "path": "inception/mysys/mf_iocache.c", "commit_date": "2015-08-28 00:00:00", "repo_name": "arkdb/inception", "stars": 1846, "license": "gpl-2.0", "language": "c", "size": 17825}
{"docstring": "/* Read one byte when buffer is empty */\n", "func_signal": "int _my_b_get(IO_CACHE *info)", "code": "{\n  uchar buff;\n  IO_CACHE_CALLBACK pre_read,post_read;\n  if ((pre_read = info->pre_read))\n    (*pre_read)(info);\n  if ((*(info)->read_function)(info,&buff,1))\n    return my_b_EOF;\n  if ((post_read = info->post_read))\n    (*post_read)(info);\n  return (int) (uchar) buff;\n}", "path": "inception/mysys/mf_iocache.c", "commit_date": "2015-08-28 00:00:00", "repo_name": "arkdb/inception", "stars": 1846, "license": "gpl-2.0", "language": "c", "size": 17825}
{"docstring": "/* ch_enlargebufs():\n *\tEnlarge line buffer to be able to hold twice as much characters.\n *\tReturns 1 if successful, 0 if not.\n */\n", "func_signal": "protected int\nch_enlargebufs(EditLine *el, size_t addlen)", "code": "{\n\tsize_t sz, newsz;\n\tChar *newbuffer, *oldbuf, *oldkbuf;\n\n\tsz = (size_t)(el->el_line.limit - el->el_line.buffer + EL_LEAVE);\n\tnewsz = sz * 2;\n\t/*\n\t * If newly required length is longer than current buffer, we need\n\t * to make the buffer big enough to hold both old and new stuff.\n\t */\n\tif (addlen > sz) {\n\t\twhile(newsz - sz < addlen)\n\t\t\tnewsz *= 2;\n\t}\n\n\t/*\n\t * Reallocate line buffer.\n\t */\n\tnewbuffer = el_realloc(el->el_line.buffer, newsz * sizeof(*newbuffer));\n\tif (!newbuffer)\n\t\treturn 0;\n\n\t/* zero the newly added memory, leave old data in */\n\t(void) memset(&newbuffer[sz], 0, (newsz - sz) * sizeof(*newbuffer));\n\t    \n\toldbuf = el->el_line.buffer;\n\n\tel->el_line.buffer = newbuffer;\n\tel->el_line.cursor = newbuffer + (el->el_line.cursor - oldbuf);\n\tel->el_line.lastchar = newbuffer + (el->el_line.lastchar - oldbuf);\n\t/* don't set new size until all buffers are enlarged */\n\tel->el_line.limit  = &newbuffer[sz - EL_LEAVE];\n\n\t/*\n\t * Reallocate kill buffer.\n\t */\n\tnewbuffer = el_realloc(el->el_chared.c_kill.buf, newsz *\n\t    sizeof(*newbuffer));\n\tif (!newbuffer)\n\t\treturn 0;\n\n\t/* zero the newly added memory, leave old data in */\n\t(void) memset(&newbuffer[sz], 0, (newsz - sz) * sizeof(*newbuffer));\n\n\toldkbuf = el->el_chared.c_kill.buf;\n\n\tel->el_chared.c_kill.buf = newbuffer;\n\tel->el_chared.c_kill.last = newbuffer +\n\t\t\t\t\t(el->el_chared.c_kill.last - oldkbuf);\n\tel->el_chared.c_kill.mark = el->el_line.buffer +\n\t\t\t\t\t(el->el_chared.c_kill.mark - oldbuf);\n\n\t/*\n\t * Reallocate undo buffer.\n\t */\n\tnewbuffer = el_realloc(el->el_chared.c_undo.buf,\n\t    newsz * sizeof(*newbuffer));\n\tif (!newbuffer)\n\t\treturn 0;\n\n\t/* zero the newly added memory, leave old data in */\n\t(void) memset(&newbuffer[sz], 0, (newsz - sz) * sizeof(*newbuffer));\n\tel->el_chared.c_undo.buf = newbuffer;\n\n\tnewbuffer = el_realloc(el->el_chared.c_redo.buf,\n\t    newsz * sizeof(*newbuffer));\n\tif (!newbuffer)\n\t\treturn 0;\n\tel->el_chared.c_redo.pos = newbuffer +\n\t\t\t(el->el_chared.c_redo.pos - el->el_chared.c_redo.buf);\n\tel->el_chared.c_redo.lim = newbuffer +\n\t\t\t(el->el_chared.c_redo.lim - el->el_chared.c_redo.buf);\n\tel->el_chared.c_redo.buf = newbuffer;\n\t\n\tif (!hist_enlargebuf(el, sz, newsz))\n\t\treturn 0;\n\n\t/* Safe to set enlarged buffer size */\n\tel->el_line.limit  = &el->el_line.buffer[newsz - EL_LEAVE];\n\tif (el->el_chared.c_resizefun)\n\t\t(*el->el_chared.c_resizefun)(el, el->el_chared.c_resizearg);\n\treturn 1;\n}", "path": "inception/cmd-line-utils/libedit/chared.c", "commit_date": "2015-08-28 00:00:00", "repo_name": "arkdb/inception", "stars": 1846, "license": "gpl-2.0", "language": "c", "size": 17825}
{"docstring": "/*\n * Write a single packet to either PCAP (*fd* != -1) or a network interface\n * (*fd* == -1).  Caller must ensure that *ctx* was initialized accordingly.\n * The packet will be in direction *direction*, use TCP flags *flags*, and\n * transmit a payload *payload*.  TCP sequence and acknowledgement numbers as\n * well as source and destination identifiers are taken from *ctx*.\n *\n * Caller must ensure that *payload* fits into a frame depending on the MTU\n * selected (interface in mirroring mode, MTU value in PCAP writing mode).\n */\n", "func_signal": "static int\nlogpkt_write_packet(logpkt_ctx_t *ctx, int fd, int direction, char flags,\n                    const uint8_t *payload, size_t payloadlen)", "code": "{\n\tint rv;\n\n\tif (fd != -1) {\n\t\tuint8_t buf[MAX_PKTSZ];\n\t\tsize_t sz;\n\t\tif (direction == LOGPKT_REQUEST) {\n\t\t\tsz = logpkt_pcap_build(buf,\n\t\t\t                       ctx->src_ether, ctx->dst_ether,\n\t\t\t                       CSA(&ctx->src_addr),\n\t\t\t                       CSA(&ctx->dst_addr),\n\t\t\t                       flags,\n\t\t\t                       ctx->src_seq, ctx->dst_seq,\n\t\t\t                       payload, payloadlen);\n\t\t} else {\n\t\t\tsz = logpkt_pcap_build(buf,\n\t\t\t                       ctx->dst_ether, ctx->src_ether,\n\t\t\t                       CSA(&ctx->dst_addr),\n\t\t\t                       CSA(&ctx->src_addr),\n\t\t\t                       flags,\n\t\t\t                       ctx->dst_seq, ctx->src_seq,\n\t\t\t                       payload, payloadlen);\n\t\t}\n\t\trv = logpkt_pcap_write(buf, sz, fd);\n\t\tif (rv == -1) {\n\t\t\tlog_err_printf(\"Error writing packet to PCAP file\\n\");\n\t\t\treturn -1;\n\t\t}\n\t} else {\n#ifndef WITHOUT_MIRROR\n\t\t/* Source and destination ether are determined by the actual\n\t\t * local MAC address and target MAC address for mirroring the\n\t\t * packets to; use them as-is for both directions. */\n\t\tif (direction == LOGPKT_REQUEST) {\n\t\t\trv = logpkt_mirror_build(ctx->libnet,\n\t\t\t                         ctx->src_ether, ctx->dst_ether,\n\t\t\t                         CSA(&ctx->src_addr),\n\t\t\t                         CSA(&ctx->dst_addr),\n\t\t\t                         flags,\n\t\t\t                         ctx->src_seq, ctx->dst_seq,\n\t\t\t                         payload, payloadlen);\n\t\t} else {\n\t\t\trv = logpkt_mirror_build(ctx->libnet,\n\t\t\t                         ctx->src_ether, ctx->dst_ether,\n\t\t\t                         CSA(&ctx->dst_addr),\n\t\t\t                         CSA(&ctx->src_addr),\n\t\t\t                         flags,\n\t\t\t                         ctx->dst_seq, ctx->src_seq,\n\t\t\t                         payload, payloadlen);\n\t\t}\n\t\tif (rv == -1) {\n\t\t\tlog_err_printf(\"Error building packet\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\trv = libnet_write(ctx->libnet);\n\t\tif (rv == -1) {\n\t\t\tlog_err_printf(\"Error writing packet: %s\\n\",\n\t\t\t               libnet_geterror(ctx->libnet));\n\t\t}\n\t\tlibnet_clear_packet(ctx->libnet);\n#else /* WITHOUT_MIRROR */\n\t\trv = -1;\n#endif /* WITHOUT_MIRROR */\n\t}\n\treturn rv;\n}", "path": "sslsplit/logpkt.c", "commit_date": "2020-12-06 00:00:00", "repo_name": "droe/sslsplit", "stars": 1706, "license": "bsd-2-clause", "language": "c", "size": 1832}
{"docstring": "/*\n * Handle a single request on a readable server socket.\n * Returns 0 on success, 1 on EOF and -1 on error.\n */\n", "func_signal": "static int WUNRES\nprivsep_server_handle_req(opts_t *opts, int srvsock)", "code": "{\n\tchar req[PRIVSEP_MAX_REQ_SIZE];\n\tchar ans[PRIVSEP_MAX_ANS_SIZE];\n\tssize_t n;\n\tint mkpath = 0;\n\n\tif ((n = sys_recvmsgfd(srvsock, req, sizeof(req),\n\t                       NULL)) == -1) {\n\t\tif (errno == EPIPE || errno == ECONNRESET) {\n\t\t\t/* unfriendly EOF, leave server */\n\t\t\treturn 1;\n\t\t}\n\t\tlog_err_printf(\"Failed to receive msg: %s (%i)\\n\",\n\t\t               strerror(errno), errno);\n\t\treturn -1;\n\t}\n\tif (n == 0) {\n\t\t/* EOF, leave server; will not happen for SOCK_DGRAM sockets */\n\t\treturn 1;\n\t}\n\tlog_dbg_printf(\"Received privsep req type %02x sz %zd on srvsock %i\\n\",\n\t               req[0], n, srvsock);\n\tswitch (req[0]) {\n\tcase PRIVSEP_REQ_CLOSE: {\n\t\t/* client indicates EOF through close message */\n\t\treturn 1;\n\t}\n\tcase PRIVSEP_REQ_OPENFILE_P:\n\t\tmkpath = 1;\n\t\t/* fall through */\n\tcase PRIVSEP_REQ_OPENFILE: {\n\t\tchar *fn;\n\t\tint fd;\n\n\t\tif (n < 2) {\n\t\t\tans[0] = PRIVSEP_ANS_INVALID;\n\t\t\tif (sys_sendmsgfd(srvsock, ans, 1, -1) == -1) {\n\t\t\t\tlog_err_printf(\"Sending message failed: %s (%i\"\n\t\t\t\t               \")\\n\", strerror(errno), errno);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (!(fn = malloc(n))) {\n\t\t\tans[0] = PRIVSEP_ANS_SYS_ERR;\n\t\t\t*((int*)&ans[1]) = errno;\n\t\t\tif (sys_sendmsgfd(srvsock, ans, 1 + sizeof(int),\n\t\t\t                  -1) == -1) {\n\t\t\t\tlog_err_printf(\"Sending message failed: %s (%i\"\n\t\t\t\t               \")\\n\", strerror(errno), errno);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tmemcpy(fn, req + 1, n - 1);\n\t\tfn[n - 1] = '\\0';\n\t\tif (privsep_server_openfile_verify(opts, fn, mkpath) == -1) {\n\t\t\tfree(fn);\n\t\t\tans[0] = PRIVSEP_ANS_DENIED;\n\t\t\tif (sys_sendmsgfd(srvsock, ans, 1, -1) == -1) {\n\t\t\t\tlog_err_printf(\"Sending message failed: %s (%i\"\n\t\t\t\t               \")\\n\", strerror(errno), errno);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif ((fd = privsep_server_openfile(fn, mkpath)) == -1) {\n\t\t\tfree(fn);\n\t\t\tans[0] = PRIVSEP_ANS_SYS_ERR;\n\t\t\t*((int*)&ans[1]) = errno;\n\t\t\tif (sys_sendmsgfd(srvsock, ans, 1 + sizeof(int),\n\t\t\t                  -1) == -1) {\n\t\t\t\tlog_err_printf(\"Sending message failed: %s (%i\"\n\t\t\t\t               \")\\n\", strerror(errno), errno);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tfree(fn);\n\t\t\tans[0] = PRIVSEP_ANS_SUCCESS;\n\t\t\tif (sys_sendmsgfd(srvsock, ans, 1, fd) == -1) {\n\t\t\t\tclose(fd);\n\t\t\t\tlog_err_printf(\"Sending message failed: %s (%i\"\n\t\t\t\t               \")\\n\", strerror(errno), errno);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tclose(fd);\n\t\t\treturn 0;\n\t\t}\n\t\t/* not reached */\n\t\tbreak;\n\t}\n\tcase PRIVSEP_REQ_OPENSOCK: {\n\t\tproxyspec_t *arg;\n\t\tint s;\n\n\t\tif (n != sizeof(char) + sizeof(arg)) {\n\t\t\tans[0] = PRIVSEP_ANS_INVALID;\n\t\t\tif (sys_sendmsgfd(srvsock, ans, 1, -1) == -1) {\n\t\t\t\tlog_err_printf(\"Sending message failed: %s (%i\"\n\t\t\t\t               \")\\n\", strerror(errno), errno);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\targ = *(proxyspec_t**)(&req[1]);\n\t\tif (privsep_server_opensock_verify(opts, arg) == -1) {\n\t\t\tans[0] = PRIVSEP_ANS_DENIED;\n\t\t\tif (sys_sendmsgfd(srvsock, ans, 1, -1) == -1) {\n\t\t\t\tlog_err_printf(\"Sending message failed: %s (%i\"\n\t\t\t\t               \")\\n\", strerror(errno), errno);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif ((s = privsep_server_opensock(arg)) == -1) {\n\t\t\tans[0] = PRIVSEP_ANS_SYS_ERR;\n\t\t\t*((int*)&ans[1]) = errno;\n\t\t\tif (sys_sendmsgfd(srvsock, ans, 1 + sizeof(int),\n\t\t\t                  -1) == -1) {\n\t\t\t\tlog_err_printf(\"Sending message failed: %s (%i\"\n\t\t\t\t               \")\\n\", strerror(errno), errno);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tans[0] = PRIVSEP_ANS_SUCCESS;\n\t\t\tif (sys_sendmsgfd(srvsock, ans, 1, s) == -1) {\n\t\t\t\tevutil_closesocket(s);\n\t\t\t\tlog_err_printf(\"Sending message failed: %s (%i\"\n\t\t\t\t               \")\\n\", strerror(errno), errno);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tevutil_closesocket(s);\n\t\t\treturn 0;\n\t\t}\n\t\t/* not reached */\n\t\tbreak;\n\t}\n\tcase PRIVSEP_REQ_CERTFILE: {\n\t\tchar *fn;\n\t\tint fd;\n\n\t\tif (n < 2) {\n\t\t\tans[0] = PRIVSEP_ANS_INVALID;\n\t\t\tif (sys_sendmsgfd(srvsock, ans, 1, -1) == -1) {\n\t\t\t\tlog_err_printf(\"Sending message failed: %s (%i\"\n\t\t\t\t               \")\\n\", strerror(errno), errno);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (!(fn = malloc(n))) {\n\t\t\tans[0] = PRIVSEP_ANS_SYS_ERR;\n\t\t\t*((int*)&ans[1]) = errno;\n\t\t\tif (sys_sendmsgfd(srvsock, ans, 1 + sizeof(int),\n\t\t\t                  -1) == -1) {\n\t\t\t\tlog_err_printf(\"Sending message failed: %s (%i\"\n\t\t\t\t               \")\\n\", strerror(errno), errno);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tmemcpy(fn, req + 1, n - 1);\n\t\tfn[n - 1] = '\\0';\n\t\tif (privsep_server_certfile_verify(opts, fn) == -1) {\n\t\t\tfree(fn);\n\t\t\tans[0] = PRIVSEP_ANS_DENIED;\n\t\t\tif (sys_sendmsgfd(srvsock, ans, 1, -1) == -1) {\n\t\t\t\tlog_err_printf(\"Sending message failed: %s (%i\"\n\t\t\t\t               \")\\n\", strerror(errno), errno);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif ((fd = privsep_server_certfile(fn)) == -1) {\n\t\t\tfree(fn);\n\t\t\tans[0] = PRIVSEP_ANS_SYS_ERR;\n\t\t\t*((int*)&ans[1]) = errno;\n\t\t\tif (sys_sendmsgfd(srvsock, ans, 1 + sizeof(int),\n\t\t\t                  -1) == -1) {\n\t\t\t\tlog_err_printf(\"Sending message failed: %s (%i\"\n\t\t\t\t               \")\\n\", strerror(errno), errno);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tfree(fn);\n\t\t\tans[0] = PRIVSEP_ANS_SUCCESS;\n\t\t\tif (sys_sendmsgfd(srvsock, ans, 1, fd) == -1) {\n\t\t\t\tclose(fd);\n\t\t\t\tlog_err_printf(\"Sending message failed: %s (%i\"\n\t\t\t\t               \")\\n\", strerror(errno), errno);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tclose(fd);\n\t\t\treturn 0;\n\t\t}\n\t\t/* not reached */\n\t\tbreak;\n\t}\n\tdefault:\n\t\tans[0] = PRIVSEP_ANS_UNK_CMD;\n\t\tif (sys_sendmsgfd(srvsock, ans, 1, -1) == -1) {\n\t\t\tlog_err_printf(\"Sending message failed: %s (%i\"\n\t\t\t               \")\\n\", strerror(errno), errno);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "path": "sslsplit/privsep.c", "commit_date": "2019-08-04 00:00:00", "repo_name": "droe/sslsplit", "stars": 1706, "license": "bsd-2-clause", "language": "c", "size": 1832}
{"docstring": "/*\n * Set up the listener for a single proxyspec and add it to evbase.\n * Returns the proxy_listener_ctx_t pointer if successful, NULL otherwise.\n */\n", "func_signal": "static proxy_listener_ctx_t *\nproxy_listener_setup(struct event_base *evbase, pxy_thrmgr_ctx_t *thrmgr,\n                     proxyspec_t *spec, opts_t *opts, int clisock)", "code": "{\n\tproxy_listener_ctx_t *plc;\n\tint fd;\n\n\tif ((fd = privsep_client_opensock(clisock, spec)) == -1) {\n\t\tlog_err_printf(\"Error opening socket: %s (%i)\\n\",\n\t\t               strerror(errno), errno);\n\t\treturn NULL;\n\t}\n\n\tplc = proxy_listener_ctx_new(thrmgr, spec, opts);\n\tif (!plc) {\n\t\tlog_err_printf(\"Error creating listener context\\n\");\n\t\tevutil_closesocket(fd);\n\t\treturn NULL;\n\t}\n\n\tplc->evcl = evconnlistener_new(evbase, proxy_listener_acceptcb,\n\t                               plc, LEV_OPT_CLOSE_ON_FREE, 1024, fd);\n\tif (!plc->evcl) {\n\t\tlog_err_printf(\"Error creating evconnlistener: %s\\n\",\n\t\t               strerror(errno));\n\t\tproxy_listener_ctx_free(plc);\n\t\tevutil_closesocket(fd);\n\t\treturn NULL;\n\t}\n\tevconnlistener_set_error_cb(plc->evcl, proxy_listener_errorcb);\n\treturn plc;\n}", "path": "sslsplit/proxy.c", "commit_date": "2019-08-04 00:00:00", "repo_name": "droe/sslsplit", "stars": 1706, "license": "bsd-2-clause", "language": "c", "size": 1832}
{"docstring": "/*\n * Dump a description of an evbase to debugging code.\n */\n", "func_signal": "static void\nproxy_debug_base(const struct event_base *ev_base)", "code": "{\n\tlog_dbg_printf(\"Using libevent backend '%s'\\n\",\n\t               event_base_get_method(ev_base));\n\n\tenum event_method_feature f;\n\tf = event_base_get_features(ev_base);\n\tlog_dbg_printf(\"Event base supports: edge %s, O(1) %s, anyfd %s\\n\",\n\t               ((f & EV_FEATURE_ET) ? \"yes\" : \"no\"),\n\t               ((f & EV_FEATURE_O1) ? \"yes\" : \"no\"),\n\t               ((f & EV_FEATURE_FDS) ? \"yes\" : \"no\"));\n}", "path": "sslsplit/proxy.c", "commit_date": "2019-08-04 00:00:00", "repo_name": "droe/sslsplit", "stars": 1706, "license": "bsd-2-clause", "language": "c", "size": 1832}
{"docstring": "/*\n * Signal handler for SIGTERM, SIGQUIT, SIGINT, SIGHUP, SIGPIPE and SIGUSR1.\n */\n", "func_signal": "static void\nproxy_signal_cb(evutil_socket_t fd, UNUSED short what, void *arg)", "code": "{\n\tproxy_ctx_t *ctx = arg;\n\n\tif (OPTS_DEBUG(ctx->opts)) {\n\t\tlog_dbg_printf(\"Received signal %i\\n\", fd);\n\t}\n\n\tswitch(fd) {\n\tcase SIGTERM:\n\tcase SIGQUIT:\n\tcase SIGINT:\n\tcase SIGHUP:\n\t\tproxy_loopbreak(ctx, fd);\n\t\tbreak;\n\tcase SIGUSR1:\n\t\tif (log_reopen() == -1) {\n\t\t\tlog_err_printf(\"Warning: Failed to reopen logs\\n\");\n\t\t} else {\n\t\t\tlog_dbg_printf(\"Reopened log files\\n\");\n\t\t}\n\t\tbreak;\n\tcase SIGPIPE:\n\t\tlog_err_printf(\"Warning: Received SIGPIPE; ignoring.\\n\");\n\t\tbreak;\n\tdefault:\n\t\tlog_err_printf(\"Warning: Received unexpected signal %i\\n\", fd);\n\t\tbreak;\n\t}\n}", "path": "sslsplit/proxy.c", "commit_date": "2019-08-04 00:00:00", "repo_name": "droe/sslsplit", "stars": 1706, "license": "bsd-2-clause", "language": "c", "size": 1832}
{"docstring": "/*\n * Receive a single ARP reply and copy the resulting ether to ctx->ether.\n */\n", "func_signal": "static void\nlogpkt_recv_arp_reply(uint8_t *user,\n                      UNUSED const struct pcap_pkthdr *h,\n                      const uint8_t *packet)", "code": "{\n\tlogpkt_recv_arp_reply_ctx_t *ctx = (logpkt_recv_arp_reply_ctx_t*)user;\n\tstruct libnet_802_3_hdr *heth = (void*)packet;\n\tstruct libnet_arp_hdr *harp = (void*)((char*)heth + LIBNET_ETH_H);\n\n\t/* skip if wrong protocol */\n\tif (htons(harp->ar_op) != ARPOP_REPLY)\n\t\treturn;\n\tif (htons(harp->ar_pro) != ETHERTYPE_IP)\n\t\treturn;\n\tif (htons(harp->ar_hrd) != ARPHRD_ETHER)\n\t\treturn;\n\n\t/* skip if wrong target IP address */\n\tif (!!memcmp(&ctx->ip, (char*)harp + harp->ar_hln + LIBNET_ARP_H, 4))\n\t\treturn;\n\n\t/* skip if source ether mismatch */\n\tif (!!memcmp((u_char*)harp + sizeof(struct libnet_arp_hdr),\n\t             heth->_802_3_shost, ETHER_ADDR_LEN))\n\t\treturn;\n\n\tmemcpy(ctx->ether,\n\t       (u_char*)harp + sizeof(struct libnet_arp_hdr),\n\t       ETHER_ADDR_LEN);\n\tctx->result = 0;\n}", "path": "sslsplit/logpkt.c", "commit_date": "2020-12-06 00:00:00", "repo_name": "droe/sslsplit", "stars": 1706, "license": "bsd-2-clause", "language": "c", "size": 1832}
{"docstring": "/*\n * Callback for error events on the socket listener bufferevent.\n */\n", "func_signal": "static void\nproxy_listener_errorcb(struct evconnlistener *listener, UNUSED void *ctx)", "code": "{\n\tstruct event_base *evbase = evconnlistener_get_base(listener);\n\tint err = EVUTIL_SOCKET_ERROR();\n\tlog_err_printf(\"Error %d on listener: %s\\n\", err,\n\t               evutil_socket_error_to_string(err));\n\tevent_base_loopbreak(evbase);\n}", "path": "sslsplit/proxy.c", "commit_date": "2019-08-04 00:00:00", "repo_name": "droe/sslsplit", "stars": 1706, "license": "bsd-2-clause", "language": "c", "size": 1832}
{"docstring": "/* !TRAVIS */\n", "func_signal": "START_TEST(proxyspec_parse_15)", "code": "{\n\tproxyspec_t *spec = NULL;\n\tint argc = 3;\n\tchar **argv = argv11;\n\n\tproxyspec_parse(&argc, &argv, NATENGINE, &spec);\n\tfail_unless(!!spec, \"failed to parse spec\");\n\tfail_unless(!spec->ssl, \"SSL\");\n\tfail_unless(!spec->http, \"HTTP\");\n\tfail_unless(spec->upgrade, \"not Upgrade\");\n\tfail_unless(spec->listen_addrlen == sizeof(struct sockaddr_in),\n\t            \"not IPv4 listen addr\");\n\tfail_unless(!spec->connect_addrlen, \"connect addr set\");\n\tfail_unless(!spec->sni_port, \"SNI port is set\");\n\tfail_unless(!!spec->natengine, \"natengine is not set\");\n\tfail_unless(!spec->natlookup, \"natlookup() is set\");\n\tfail_unless(!spec->natsocket, \"natsocket() is set\");\n\tfail_unless(!spec->next, \"next is set\");\n\tproxyspec_free(spec);\n}", "path": "sslsplit/opts.t.c", "commit_date": "2019-08-07 00:00:00", "repo_name": "droe/sslsplit", "stars": 1706, "license": "bsd-2-clause", "language": "c", "size": 1832}
{"docstring": "/* !DOCKER */\n", "func_signal": "START_TEST(proxyspec_parse_05)", "code": "{\n\tproxyspec_t *spec = NULL;\n\tint argc = 5;\n\tchar **argv = argv03;\n\n\tproxyspec_parse(&argc, &argv, NATENGINE, &spec);\n\tfail_unless(!!spec, \"failed to parse spec\");\n\tfail_unless(!spec->ssl, \"SSL\");\n\tfail_unless(spec->http, \"not HTTP\");\n\tfail_unless(!spec->upgrade, \"Upgrade\");\n\tfail_unless(spec->listen_addrlen == sizeof(struct sockaddr_in),\n\t            \"not IPv4 listen addr\");\n\tfail_unless(spec->connect_addrlen == sizeof(struct sockaddr_in),\n\t            \"not IPv4 connect addr\");\n\tfail_unless(!spec->sni_port, \"SNI port is set\");\n\tfail_unless(!spec->natengine, \"natengine is set\");\n\tfail_unless(!spec->natlookup, \"natlookup() is set\");\n\tfail_unless(!spec->natsocket, \"natsocket() is set\");\n\tfail_unless(!spec->next, \"next is set\");\n\tproxyspec_free(spec);\n}", "path": "sslsplit/opts.t.c", "commit_date": "2019-08-07 00:00:00", "repo_name": "droe/sslsplit", "stars": 1706, "license": "bsd-2-clause", "language": "c", "size": 1832}
{"docstring": "/*\n * Initialize the per-connection packet crafting context.  For mirroring,\n * *libnet* must be an initialized libnet instance and *mtu* must be the\n * target interface MTU greater than 0.  For PCAP writing, *libnet* must be\n * NULL and *mtu* must be 0.  The ether and sockaddr addresses are used as the\n * layer 2 and layer 3 addresses respectively.  For mirroring, the ethers must\n * match the actual link layer addresses to be used when sending traffic, not\n * some emulated addresses.\n */\n", "func_signal": "void\nlogpkt_ctx_init(logpkt_ctx_t *ctx, libnet_t *libnet, size_t mtu,\n                const uint8_t *src_ether, const uint8_t *dst_ether,\n                const struct sockaddr *src_addr, socklen_t src_addr_len,\n                const struct sockaddr *dst_addr, socklen_t dst_addr_len)", "code": "{\n\tctx->libnet = libnet;\n\tmemcpy(ctx->src_ether, src_ether, ETHER_ADDR_LEN);\n\tmemcpy(ctx->dst_ether, dst_ether, ETHER_ADDR_LEN);\n\tmemcpy(&ctx->src_addr, src_addr, src_addr_len);\n\tmemcpy(&ctx->dst_addr, dst_addr, dst_addr_len);\n\tctx->src_seq = 0;\n\tctx->dst_seq = 0;\n\tif (mtu) {\n\t\tctx->mss = mtu - sizeof(tcp_hdr_t)\n\t\t               - (dst_addr->sa_family == AF_INET\n\t\t                  ? sizeof(ip4_hdr_t)\n\t\t                  : sizeof(ip6_hdr_t));\n\t} else {\n\t\tctx->mss = dst_addr->sa_family == AF_INET ? MSS_IP4 : MSS_IP6;\n\t}\n}", "path": "sslsplit/logpkt.c", "commit_date": "2020-12-06 00:00:00", "repo_name": "droe/sslsplit", "stars": 1706, "license": "bsd-2-clause", "language": "c", "size": 1832}
{"docstring": "/*\n * Free the proxy data structures.\n */\n", "func_signal": "void\nproxy_free(proxy_ctx_t *ctx)", "code": "{\n\tif (ctx->gcev) {\n\t\tevent_free(ctx->gcev);\n\t}\n\tif (ctx->lctx) {\n\t\tproxy_listener_ctx_free(ctx->lctx);\n\t}\n\tfor (size_t i = 0; i < (sizeof(ctx->sev) / sizeof(ctx->sev[0])); i++) {\n\t\tif (ctx->sev[i]) {\n\t\t\tevent_free(ctx->sev[i]);\n\t\t}\n\t}\n\tif (ctx->thrmgr) {\n\t\tpxy_thrmgr_free(ctx->thrmgr);\n\t}\n\tif (ctx->evbase) {\n\t\tevent_base_free(ctx->evbase);\n\t}\n\tfree(ctx);\n}", "path": "sslsplit/proxy.c", "commit_date": "2019-08-04 00:00:00", "repo_name": "droe/sslsplit", "stars": 1706, "license": "bsd-2-clause", "language": "c", "size": 1832}
{"docstring": "/*\n * Called on a file descriptor open for reading and writing.\n * If the fd points to an empty file, a pcap header is added and 0 is returned.\n * If the fd points to a file with PCAP magic bytes, the file position is moved\n * to the end of the file and 0 is returned.\n * If the fd points to a file without PCAP magic bytes, the file is truncated\n * to zero bytes and a new PCAP header is written.\n * On a return value of 0, the caller can continue to write PCAP records to the\n * file descriptor.  On error, -1 is returned and the file descriptor is in an\n * undefined but still open state.\n */\n", "func_signal": "int\nlogpkt_pcap_open_fd(int fd)", "code": "{\n\tpcap_file_hdr_t hdr;\n\toff_t sz;\n\tssize_t n;\n\n\tsz = lseek(fd, 0, SEEK_END);\n\tif (sz == -1)\n\t\treturn -1;\n\n\tif (sz > 0) {\n\t\tif (lseek(fd, 0, SEEK_SET) == -1)\n\t\t\treturn -1;\n\t\tn = read(fd, &hdr, sizeof(pcap_file_hdr_t));\n\t\tif (n != sizeof(pcap_file_hdr_t))\n\t\t\treturn -1;\n\t\tif (hdr.magic_number == PCAP_MAGIC)\n\t\t\treturn lseek(fd, 0, SEEK_END) == -1 ? -1 : 0;\n\t\tif (lseek(fd, 0, SEEK_SET) == -1)\n\t\t\treturn -1;\n\t\tif (ftruncate(fd, 0) == -1)\n\t\t\treturn -1;\n\t}\n\n\treturn logpkt_write_global_pcap_hdr(fd);\n}", "path": "sslsplit/logpkt.c", "commit_date": "2020-12-06 00:00:00", "repo_name": "droe/sslsplit", "stars": 1706, "license": "bsd-2-clause", "language": "c", "size": 1832}
{"docstring": "/*\n * Emulate the necessary packets to write a single payload segment.  If\n * necessary, a SYN handshake will automatically be generated before emitting\n * the packet carrying the payload plus a matching ACK.\n */\n", "func_signal": "int\nlogpkt_write_payload(logpkt_ctx_t *ctx, int fd, int direction,\n                     const uint8_t *payload, size_t payloadlen)", "code": "{\n\tint other_direction = (direction == LOGPKT_REQUEST) ? LOGPKT_RESPONSE\n\t                                                    : LOGPKT_REQUEST;\n\n\tif (ctx->src_seq == 0) {\n\t\tif (logpkt_write_syn_handshake(ctx, fd) == -1)\n\t\t\treturn -1;\n\t}\n\n\twhile (payloadlen > 0) {\n\t\tsize_t n = payloadlen > ctx->mss ? ctx->mss : payloadlen;\n\t\tif (logpkt_write_packet(ctx, fd, direction,\n\t\t                        TH_PUSH|TH_ACK, payload, n) == -1) {\n\t\t\tlog_err_printf(\"Warning: Failed to write to pcap log\"\n\t\t\t               \": %s\\n\", strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t\tif (direction == LOGPKT_REQUEST) {\n\t\t\tctx->src_seq += n;\n\t\t} else {\n\t\t\tctx->dst_seq += n;\n\t\t}\n\t\tpayload += n;\n\t\tpayloadlen -= n;\n\t}\n\n\tif (logpkt_write_packet(ctx, fd, other_direction,\n\t                        TH_ACK, NULL, 0) == -1) {\n\t\tlog_err_printf(\"Warning: Failed to write to pcap log: %s\\n\",\n\t\t               strerror(errno));\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "path": "sslsplit/logpkt.c", "commit_date": "2020-12-06 00:00:00", "repo_name": "droe/sslsplit", "stars": 1706, "license": "bsd-2-clause", "language": "c", "size": 1832}
{"docstring": "/*\n * Build a packet using libnet intended for mirroring mode.  The packet will\n * be dynamically allocated on the heap by the libnet instance *libnet*.\n */\n", "func_signal": "static int\nlogpkt_mirror_build(libnet_t *libnet,\n                    uint8_t *src_ether, uint8_t *dst_ether,\n                    const struct sockaddr *src_addr,\n                    const struct sockaddr *dst_addr,\n                    char flags, uint32_t seq, uint32_t ack,\n                    const uint8_t *payload, size_t payloadlen)", "code": "{\n\tlibnet_ptag_t ptag;\n\n\tptag = libnet_build_tcp(htons(src_addr->sa_family == AF_INET\n\t                        ? CSIN(src_addr)->sin_port\n\t                        : CSIN6(src_addr)->sin6_port),\n\t                        htons(dst_addr->sa_family == AF_INET\n\t                        ? CSIN(dst_addr)->sin_port\n\t                        : CSIN6(dst_addr)->sin6_port),\n\t                        seq,\n\t                        ack,\n\t                        flags,\n\t                        32767,          /* window size */\n\t                        0,              /* checksum */\n\t                        0,              /* urgent pointer */\n\t                        LIBNET_TCP_H + payloadlen,\n\t                        (uint8_t *)payload, payloadlen,\n\t                        libnet, 0);\n\tif (ptag == -1) {\n\t\tlog_err_printf(\"Error building tcp header: %s\",\n\t\t               libnet_geterror(libnet));\n\t\treturn -1;\n\t}\n\n\tif (dst_addr->sa_family == AF_INET) {\n\t\tptag = libnet_build_ipv4(LIBNET_IPV4_H + LIBNET_TCP_H +\n\t\t                         payloadlen,\n\t\t                         0,             /* TOS */\n\t\t                         (uint16_t)\n\t\t                         sys_rand16(),  /* id */\n\t\t                         0x4000,        /* frag */\n\t\t                         64,            /* TTL */\n\t\t                         IPPROTO_TCP,   /* protocol */\n\t\t                         0,             /* checksum */\n\t\t                         CSIN(src_addr)->sin_addr.s_addr,\n\t\t                         CSIN(dst_addr)->sin_addr.s_addr,\n\t\t                         NULL, 0,\n\t\t                         libnet, 0);\n\t} else {\n\t\tptag = libnet_build_ipv6(0,             /* traffic class */\n\t\t                         0,             /* flow label */\n\t\t                         LIBNET_IPV6_H + LIBNET_TCP_H +\n\t\t                         payloadlen,\n\t\t                         IPPROTO_TCP,\n\t\t                         255,           /* hop limit */\n\t\t                         *(struct libnet_in6_addr *)\n\t\t                         &CSIN6(src_addr)->sin6_addr,\n\t\t                         *(struct libnet_in6_addr *)\n\t\t                         &CSIN6(dst_addr)->sin6_addr,\n\t\t                         NULL, 0,\n\t\t                         libnet, 0);\n\t}\n\tif (ptag == -1) {\n\t\tlog_err_printf(\"Error building ip header: %s\",\n\t\t               libnet_geterror(libnet));\n\t\treturn -1;\n\t}\n\n\tptag = libnet_build_ethernet(dst_ether,\n\t                             src_ether,\n\t                             dst_addr->sa_family == AF_INET\n\t                                     ? ETHERTYPE_IP : ETHERTYPE_IPV6,\n\t                             NULL, 0,\n\t                             libnet, 0);\n\tif (ptag == -1) {\n\t\tlog_err_printf(\"Error building ethernet header: %s\",\n\t\t               libnet_geterror(libnet));\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "path": "sslsplit/logpkt.c", "commit_date": "2020-12-06 00:00:00", "repo_name": "droe/sslsplit", "stars": 1706, "license": "bsd-2-clause", "language": "c", "size": 1832}
{"docstring": "/*\n * Build a frame from the given layer 2, layer 3 and layer 4 parameters plus\n * payload, write the resulting bytes into buffer pointed to by *pkt*, and fix\n * the checksums on all layers.  The receiving buffer must be at least\n * MAX_PKTSZ bytes large and payload must be a maximum of MSS_IP4 or MSS_IP6\n * respectively.  Layer 2 is Ethernet II, layer 3 is IPv4 or IPv6 depending on\n * the address family of *dst_addr*, and layer 4 is TCP.\n *\n * This function is stateless.  For header fields that cannot be directly\n * derived from the arguments, default values will be used.\n */\n", "func_signal": "static size_t\nlogpkt_pcap_build(uint8_t *pkt,\n                  uint8_t *src_ether, uint8_t *dst_ether,\n                  const struct sockaddr *src_addr,\n                  const struct sockaddr *dst_addr,\n                  char flags, uint32_t seq, uint32_t ack,\n                  const uint8_t *payload, size_t payloadlen)", "code": "{\n\tether_hdr_t *ether_hdr;\n\tip4_hdr_t *ip4_hdr;\n\tip6_hdr_t *ip6_hdr;\n\ttcp_hdr_t *tcp_hdr;\n\tsize_t sz;\n\tuint32_t sum;\n\n\tether_hdr = (ether_hdr_t *)pkt;\n\tmemcpy(ether_hdr->src_mac, src_ether, sizeof(ether_hdr->src_mac));\n\tmemcpy(ether_hdr->dst_mac, dst_ether, sizeof(ether_hdr->dst_mac));\n\tsz = sizeof(ether_hdr_t);\n\n\tif (dst_addr->sa_family == AF_INET) {\n\t\tether_hdr->ethertype = htons(ETHERTYPE_IP);\n\t\tip4_hdr = (ip4_hdr_t *)(((uint8_t *)ether_hdr) +\n\t\t                        sizeof(ether_hdr_t));\n\t\tip4_hdr->version_ihl = 0x45; /* version 4, ihl 5 words */\n\t\tip4_hdr->dscp_ecn = 0;\n\t\tip4_hdr->len = htons(sizeof(ip4_hdr_t) +\n\t\t                     sizeof(tcp_hdr_t) + payloadlen);\n\t\tip4_hdr->id = sys_rand16(),\n\t\tip4_hdr->frag = 0;\n\t\tip4_hdr->ttl = 64;\n\t\tip4_hdr->proto = IPPROTO_TCP;\n\t\tip4_hdr->src_addr = CSIN(src_addr)->sin_addr.s_addr;\n\t\tip4_hdr->dst_addr = CSIN(dst_addr)->sin_addr.s_addr;\n\t\tip4_hdr->chksum = 0;\n\t\tCHKSUM_INIT(sum);\n\t\tCHKSUM_ADD_RANGE(sum, ip4_hdr, sizeof(ip4_hdr_t));\n\t\tCHKSUM_FINALIZE(sum);\n\t\tip4_hdr->chksum = sum;\n\t\tsz += sizeof(ip4_hdr_t);\n\t\ttcp_hdr = (tcp_hdr_t *)(((uint8_t *)ip4_hdr) +\n\t\t                        sizeof(ip4_hdr_t));\n\t\ttcp_hdr->src_port = CSIN(src_addr)->sin_port;\n\t\ttcp_hdr->dst_port = CSIN(dst_addr)->sin_port;\n\t\t/* pseudo header */\n\t\tCHKSUM_INIT(sum);\n\t\tCHKSUM_ADD_UINT32(sum, ip4_hdr->src_addr);\n\t\tCHKSUM_ADD_UINT32(sum, ip4_hdr->dst_addr);\n\t\tCHKSUM_ADD_UINT16(sum, htons(ip4_hdr->proto));\n\t\tCHKSUM_ADD_UINT16(sum, htons(sizeof(tcp_hdr_t) + payloadlen));\n\t} else {\n\t\tether_hdr->ethertype = htons(ETHERTYPE_IPV6);\n\t\tip6_hdr = (ip6_hdr_t *)(((uint8_t *)ether_hdr) +\n\t\t                        sizeof(ether_hdr_t));\n\t\tip6_hdr->flags = htonl(0x60000000UL); /* version 6 */\n\t\tip6_hdr->len = htons(sizeof(tcp_hdr_t) + payloadlen);\n\t\tip6_hdr->next_hdr = IPPROTO_TCP;\n\t\tip6_hdr->hop_limit = 255;\n\t\tmemcpy(ip6_hdr->src_addr, CSIN6(src_addr)->sin6_addr.s6_addr,\n\t\t       sizeof(ip6_hdr->src_addr));\n\t\tmemcpy(ip6_hdr->dst_addr, CSIN6(dst_addr)->sin6_addr.s6_addr,\n\t\t       sizeof(ip6_hdr->dst_addr));\n\t\tsz += sizeof(ip6_hdr_t);\n\t\ttcp_hdr = (tcp_hdr_t *)(((uint8_t *)ip6_hdr) +\n\t\t                        sizeof(ip6_hdr_t));\n\t\ttcp_hdr->src_port = CSIN6(src_addr)->sin6_port;\n\t\ttcp_hdr->dst_port = CSIN6(dst_addr)->sin6_port;\n\t\t/* pseudo header */\n\t\tCHKSUM_INIT(sum);\n\t\tCHKSUM_ADD_RANGE(sum, ip6_hdr->src_addr,\n\t\t                 sizeof(ip6_hdr->src_addr));\n\t\tCHKSUM_ADD_RANGE(sum, ip6_hdr->dst_addr,\n\t\t                 sizeof(ip6_hdr->dst_addr));\n\t\tCHKSUM_ADD_UINT32(sum, ip6_hdr->len);\n\t\tCHKSUM_ADD_UINT16(sum, htons(IPPROTO_TCP));\n\t}\n\ttcp_hdr->seq = htonl(seq);\n\ttcp_hdr->ack = htonl(ack);\n\ttcp_hdr->flags = htons(0x5000|flags); /* data offset 5 words */\n\ttcp_hdr->win = htons(32767);\n\ttcp_hdr->urgp = 0;\n\ttcp_hdr->chksum = 0;\n\tsz += sizeof(tcp_hdr_t);\n\tmemcpy(((uint8_t *)tcp_hdr) + sizeof(tcp_hdr_t), payload, payloadlen);\n\tCHKSUM_ADD_RANGE(sum, tcp_hdr, sizeof(tcp_hdr_t) + payloadlen);\n\tCHKSUM_FINALIZE(sum);\n\ttcp_hdr->chksum = sum;\n\treturn sz + payloadlen;\n}", "path": "sslsplit/logpkt.c", "commit_date": "2020-12-06 00:00:00", "repo_name": "droe/sslsplit", "stars": 1706, "license": "bsd-2-clause", "language": "c", "size": 1832}
{"docstring": "/* !WITHOUT_MIRROR */\n", "func_signal": "typedef struct __attribute__((packed))", "code": "{\n\tuint32_t magic_number;  /* magic number */\n\tuint16_t version_major; /* major version number */\n\tuint16_t version_minor; /* minor version number */\n\tuint32_t thiszone;      /* GMT to local correction */\n\tuint32_t sigfigs;       /* accuracy of timestamps */\n\tuint32_t snaplen;       /* max length of captured packets, in octets */\n\tuint32_t network;       /* data link type */\n}", "path": "sslsplit/logpkt.c", "commit_date": "2020-12-06 00:00:00", "repo_name": "droe/sslsplit", "stars": 1706, "license": "bsd-2-clause", "language": "c", "size": 1832}
{"docstring": "/* !DOCKER */\n", "func_signal": "START_TEST(proxyspec_parse_18)", "code": "{\n\tproxyspec_t *spec = NULL;\n\tint argc = 8;\n\tchar **argv = argv14;\n\n\tproxyspec_parse(&argc, &argv, NATENGINE, &spec);\n\tfail_unless(!!spec, \"failed to parse spec\");\n\tfail_unless(!spec->ssl, \"SSL\");\n\tfail_unless(!spec->http, \"HTTP\");\n\tfail_unless(spec->upgrade, \"not Upgrade\");\n\tfail_unless(spec->listen_addrlen == sizeof(struct sockaddr_in),\n\t            \"not IPv4 listen addr\");\n\tfail_unless(spec->connect_addrlen == sizeof(struct sockaddr_in),\n\t            \"not IPv4 connect addr\");\n\tfail_unless(!spec->sni_port, \"SNI port is set\");\n\tfail_unless(!spec->natengine, \"natengine is set\");\n\tfail_unless(!spec->natlookup, \"natlookup() is set\");\n\tfail_unless(!spec->natsocket, \"natsocket() is set\");\n\tfail_unless(!!spec->next, \"next is not set\");\n\tfail_unless(spec->next->ssl, \"not SSL\");\n\tfail_unless(spec->next->http, \"not HTTP\");\n\tfail_unless(!spec->next->upgrade, \"Upgrade\");\n\tfail_unless(spec->next->listen_addrlen == sizeof(struct sockaddr_in),\n\t            \"not IPv4 listen addr\");\n\tfail_unless(!spec->next->connect_addrlen, \"connect addr set\");\n\tfail_unless(!spec->next->sni_port, \"SNI port is set\");\n\tfail_unless(!!spec->next->natengine, \"natengine is not set\");\n\tfail_unless(!spec->next->natlookup, \"natlookup() is set\");\n\tfail_unless(!spec->next->natsocket, \"natsocket() is set\");\n\tproxyspec_free(spec);\n}", "path": "sslsplit/opts.t.c", "commit_date": "2019-08-07 00:00:00", "repo_name": "droe/sslsplit", "stars": 1706, "license": "bsd-2-clause", "language": "c", "size": 1832}
{"docstring": "/*\n * Write the layer 2 frame contained in *pkt* to file descriptor *fd* already\n * open for writing.  First writes a PCAP record header, then the actual frame.\n */\n", "func_signal": "static int\nlogpkt_pcap_write(const uint8_t *pkt, size_t pktsz, int fd)", "code": "{\n\tpcap_rec_hdr_t rec_hdr;\n\tstruct timeval tv;\n\n\tgettimeofday(&tv, NULL);\n\trec_hdr.ts_sec = tv.tv_sec;\n\trec_hdr.ts_usec = tv.tv_usec;\n\trec_hdr.orig_len = rec_hdr.incl_len = pktsz;\n\n\tif (write(fd, &rec_hdr, sizeof(rec_hdr)) != sizeof(rec_hdr)) {\n\t\tlog_err_printf(\"Error writing pcap record hdr: %s\\n\",\n\t\t               strerror(errno));\n\t\treturn -1;\n\t}\n\tif (write(fd, pkt, pktsz) != (ssize_t)pktsz) {\n\t\tlog_err_printf(\"Error writing pcap record: %s\\n\",\n\t\t               strerror(errno));\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "path": "sslsplit/logpkt.c", "commit_date": "2020-12-06 00:00:00", "repo_name": "droe/sslsplit", "stars": 1706, "license": "bsd-2-clause", "language": "c", "size": 1832}
{"docstring": "/*\n * Look up the appropriate source and destination ethernet addresses for\n * mirroring packets to dst_ip_s on interface dst_if_s.\n * Only IPv4 mirror targets are supported.\n */\n", "func_signal": "int\nlogpkt_ether_lookup(libnet_t *libnet,\n                    uint8_t *src_ether, uint8_t *dst_ether,\n                    const char *dst_ip_s, const char *dst_if_s)", "code": "{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\n\tuint8_t broadcast_ether[ETHER_ADDR_LEN] = {\n\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\n\tuint8_t zero_ether[ETHER_ADDR_LEN] = {\n\t\t0x0, 0x0, 0x0, 0x0, 0x0, 0x0};\n\tstruct libnet_ether_addr *src_ether_addr;\n\tuint32_t src_ip;\n\tstruct bpf_program bp;\n\tint count = 50;\n\tlogpkt_recv_arp_reply_ctx_t ctx;\n\n\t/* handle case of just spitting packets out, not caring about a dest */\n\tif (!dst_ip_s) {\n\t\tuint8_t src[ETHER_ADDR_LEN] = {\n\t\t\t0x1, 0x1, 0x1, 0x1, 0x1, 0x1};\n\t\tuint8_t dst[ETHER_ADDR_LEN] = {\n\t\t\t0x2, 0x2, 0x2, 0x2, 0x2, 0x2};\n\t\tmemcpy(src_ether, &src, ETHER_ADDR_LEN);\n\t\tmemcpy(dst_ether, &dst, ETHER_ADDR_LEN);\n\t\treturn 0;\n\t}\n\n\tif (sys_get_af(dst_ip_s) != AF_INET) {\n\t\tlog_err_printf(\"Mirroring target must be an IPv4 address.\\n\");\n\t\treturn -1;\n\t}\n\n\tctx.result = -1;\n\tctx.ip = libnet_name2addr4(libnet, (char *)dst_ip_s,\n\t                           LIBNET_DONT_RESOLVE);\n\tif (ctx.ip == (uint32_t)-1) {\n\t\tlog_err_printf(\"Error converting dst IP address: %s\\n\",\n\t\t               libnet_geterror(libnet));\n\t\tgoto out;\n\t}\n\tsrc_ip = libnet_get_ipaddr4(libnet);\n\tif (src_ip == (uint32_t)-1) {\n\t\tlog_err_printf(\"Error getting src IP address: %s\\n\",\n\t\t               libnet_geterror(libnet));\n\t\tgoto out;\n\t}\n\tsrc_ether_addr = libnet_get_hwaddr(libnet);\n\tif (src_ether_addr == NULL) {\n\t\tlog_err_printf(\"Error getting src ethernet address: %s\\n\",\n\t\t               libnet_geterror(libnet));\n\t\tgoto out;\n\t}\n\tmemcpy(src_ether, src_ether_addr->ether_addr_octet, ETHER_ADDR_LEN);\n\n\tif (libnet_autobuild_arp(ARPOP_REQUEST,\n\t                         src_ether,\n\t                         (uint8_t*)&src_ip,\n\t                         zero_ether,\n\t                         (uint8_t*)&ctx.ip,\n\t                         libnet) == -1) {\n\t\tlog_err_printf(\"Error building arp header: %s\\n\",\n\t\t               libnet_geterror(libnet));\n\t\tgoto out;\n\t}\n\n\tif (libnet_autobuild_ethernet(broadcast_ether,\n\t                              ETHERTYPE_ARP,\n\t                              libnet) == -1) {\n\t\tlog_err_printf(\"Error building ethernet header: %s\",\n\t\t               libnet_geterror(libnet));\n\t\tgoto out;\n\t}\n\n\tpcap_t *pcap = pcap_open_live(dst_if_s, 100, 0, 10, errbuf);\n\tif (pcap == NULL) {\n\t\tlog_err_printf(\"Error in pcap_open_live(): %s\\n\", errbuf);\n\t\tgoto out;\n\t}\n\n\tif (pcap_compile(pcap, &bp, \"arp\", 0, -1) == -1) {\n\t\tlog_err_printf(\"Error in pcap_compile(): %s\\n\",\n\t\t               pcap_geterr(pcap));\n\t\tgoto out2;\n\t}\n\tif (pcap_setfilter(pcap, &bp) == -1) {\n\t\tlog_err_printf(\"Error in pcap_setfilter(): %s\\n\",\n\t\t               pcap_geterr(pcap));\n\t\tgoto out3;\n\t}\n\n\tdo {\n\t\tif (libnet_write(libnet) != -1) {\n\t\t\t/* Limit # of packets to process, so we can loop to\n\t\t\t * send arp requests on busy networks. */\n\t\t\tif (pcap_dispatch(pcap, 1000,\n\t\t\t                  (pcap_handler)logpkt_recv_arp_reply,\n\t\t\t                  (u_char*)&ctx) < 0) {\n\t\t\t\tlog_err_printf(\"Error in pcap_dispatch(): %s\\n\",\n\t\t\t\t               pcap_geterr(pcap));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tlog_err_printf(\"Error writing arp packet: %s\",\n\t\t\t               libnet_geterror(libnet));\n\t\t\tbreak;\n\t\t}\n\t\tsleep(1);\n\t} while (ctx.result == -1 && --count > 0);\n\n\tif (ctx.result == 0) {\n\t\tmemcpy(dst_ether, &ctx.ether, ETHER_ADDR_LEN);\n\t\tlog_dbg_printf(\"Mirror target is up: \"\n\t\t               \"%02x:%02x:%02x:%02x:%02x:%02x\\n\",\n\t\t               dst_ether[0], dst_ether[1], dst_ether[2],\n\t\t               dst_ether[3], dst_ether[4], dst_ether[5]);\n\t}\n\nout3:\n\tpcap_freecode(&bp);\nout2:\n\tpcap_close(pcap);\nout:\n\tlibnet_clear_packet(libnet);\n\treturn ctx.result;\n}", "path": "sslsplit/logpkt.c", "commit_date": "2020-12-06 00:00:00", "repo_name": "droe/sslsplit", "stars": 1706, "license": "bsd-2-clause", "language": "c", "size": 1832}
{"docstring": "/*\n * Run the event loop.\n * Returns 0 on non-signal termination, signal number when the event loop was\n * cancelled by a signal, or -1 on failure.\n */\n", "func_signal": "int\nproxy_run(proxy_ctx_t *ctx)", "code": "{\n\tif (ctx->opts->detach) {\n\t\tevent_reinit(ctx->evbase);\n\t}\n#ifndef PURIFY\n\tif (OPTS_DEBUG(ctx->opts)) {\n\t\tevent_base_dump_events(ctx->evbase, stderr);\n\t}\n#endif /* PURIFY */\n\tif (pxy_thrmgr_run(ctx->thrmgr) == -1) {\n\t\tlog_err_printf(\"Failed to start thread manager\\n\");\n\t\treturn -1;\n\t}\n\tif (OPTS_DEBUG(ctx->opts)) {\n\t\tlog_dbg_printf(\"Starting main event loop.\\n\");\n\t}\n\tevent_base_dispatch(ctx->evbase);\n\tif (OPTS_DEBUG(ctx->opts)) {\n\t\tlog_dbg_printf(\"Main event loop stopped (reason=%i).\\n\",\n\t\t               ctx->loopbreak_reason);\n\t}\n\treturn ctx->loopbreak_reason;\n}", "path": "sslsplit/proxy.c", "commit_date": "2019-08-04 00:00:00", "repo_name": "droe/sslsplit", "stars": 1706, "license": "bsd-2-clause", "language": "c", "size": 1832}
{"docstring": "/*\n * Document-class: Digest::RMD160 < Digest::Base\n * A class for calculating message digests using RIPEMD-160\n * cryptographic hash function, designed by Hans Dobbertin, Antoon\n * Bosselaers, and Bart Preneel.\n *\n * RMD160 calculates a digest of 160 bits (20 bytes).\n *\n * == Examples\n *  require 'digest'\n *\n *  # Compute a complete digest\n *  Digest::RMD160.hexdigest 'abc'      #=> \"8eb208f7...\"\n *\n *  # Compute digest by chunks\n *  rmd160 = Digest::RMD160.new               # =>#<Digest::RMD160>\n *  rmd160.update \"ab\"\n *  rmd160 << \"c\"                           # alias for #update\n *  rmd160.hexdigest                        # => \"8eb208f7...\"\n *\n *  # Use the same object to compute another digest\n *  rmd160.reset\n *  rmd160 << \"message\"\n *  rmd160.hexdigest                        # => \"1dddbe1b...\"\n */\n", "func_signal": "void\nInit_rmd160(void)", "code": "{\n    VALUE mDigest, cDigest_Base, cDigest_RMD160;\n\n#if 0\n    mDigest = rb_define_module(\"Digest\"); /* let rdoc know */\n#endif\n    mDigest = rb_digest_namespace();\n    cDigest_Base = rb_path2class(\"Digest::Base\");\n\n    cDigest_RMD160 = rb_define_class_under(mDigest, \"RMD160\", cDigest_Base);\n\n#undef RUBY_UNTYPED_DATA_WARNING\n#define RUBY_UNTYPED_DATA_WARNING 0\n    rb_iv_set(cDigest_RMD160, \"metadata\",\n\t      Data_Wrap_Struct(0, 0, 0, (void *)&rmd160));\n}", "path": "ruby-packer/ruby/ext/digest/rmd160/rmd160init.c", "commit_date": "2020-05-10 00:00:00", "repo_name": "pmq20/ruby-packer", "stars": 1550, "license": "mit", "language": "c", "size": 56805}
{"docstring": "/* Initialize CLOSURE with a trampoline to call FUN with\n   CIF and USER_DATA.  */\n", "func_signal": "ffi_status\nffi_prep_closure_loc (ffi_closure* closure,\n\t\t      ffi_cif* cif,\n\t\t      void (*fun) (ffi_cif*, void*, void**, void*),\n\t\t      void *user_data,\n\t\t      void *codeloc)", "code": "{\n  unsigned int *tramp = (unsigned int *) &closure->tramp[0];\n  int i;\n\n  if (cif->abi != FFI_SYSV)\n    return FFI_BAD_ABI;\n\n  /* The trampoline looks like:\n       movhi r8, %hi(ffi_closure_sysv)\n       ori r8, r8, %lo(ffi_closure_sysv)\n       movhi r9, %hi(ffi_closure_helper)\n       ori r0, r9, %lo(ffi_closure_helper)\n       movhi r10, %hi(closure)\n       ori r10, r10, %lo(closure)\n       jmp r8\n     and then ffi_closure_sysv retrieves the closure pointer out of r10\n     in addition to the arguments passed in the normal way for the call,\n     and invokes ffi_closure_helper.  We encode the pointer to\n     ffi_closure_helper in the trampoline because making a PIC call\n     to it in ffi_closure_sysv would be messy (it would have to indirect\n     through the GOT).  */\n\n#define HI(x) ((((unsigned int) (x)) >> 16) & 0xffff)\n#define LO(x) (((unsigned int) (x)) & 0xffff)\n  tramp[0] = (0 << 27) | (8 << 22) | (HI (ffi_closure_sysv) << 6) | 0x34;\n  tramp[1] = (8 << 27) | (8 << 22) | (LO (ffi_closure_sysv) << 6) | 0x14;\n  tramp[2] = (0 << 27) | (9 << 22) | (HI (ffi_closure_helper) << 6) | 0x34;\n  tramp[3] = (9 << 27) | (9 << 22) | (LO (ffi_closure_helper) << 6) | 0x14;\n  tramp[4] = (0 << 27) | (10 << 22) | (HI (closure) << 6) | 0x34;\n  tramp[5] = (10 << 27) | (10 << 22) | (LO (closure) << 6) | 0x14;\n  tramp[6] = (8 << 27) | (0x0d << 11) | 0x3a;\n#undef HI\n#undef LO\n\n  /* Flush the caches.\n     See Example 9-4 in the Nios II Software Developer's Handbook.  */\n  for (i = 0; i < 7; i++)\n    asm volatile (\"flushd 0(%0); flushi %0\" :: \"r\"(tramp + i) : \"memory\");\n  asm volatile (\"flushp\" ::: \"memory\");\n\n  closure->cif = cif;\n  closure->fun = fun;\n  closure->user_data = user_data;\n\n  return FFI_OK;\n}", "path": "ruby-packer/vendor/libffi/src/nios2/ffi.c", "commit_date": "2017-07-06 00:00:00", "repo_name": "pmq20/ruby-packer", "stars": 1550, "license": "mit", "language": "c", "size": 56805}
{"docstring": "/* Test of EVP_PKEY_ASN1_METHOD ordering */\n", "func_signal": "static int test_asn1_meths(void)", "code": "{\n    int i;\n    int prev = -1;\n    int good = 1;\n    int pkey_id;\n    const EVP_PKEY_ASN1_METHOD *ameth;\n\n    for (i = 0; i < EVP_PKEY_asn1_get_count(); i++) {\n        ameth = EVP_PKEY_asn1_get0(i);\n        EVP_PKEY_asn1_get0_info(&pkey_id, NULL, NULL, NULL, NULL, ameth);\n        if (pkey_id < prev)\n            good = 0;\n        prev = pkey_id;\n\n    }\n    if (!good) {\n        TEST_error(\"EVP_PKEY_ASN1_METHOD table out of order\");\n        for (i = 0; i < EVP_PKEY_asn1_get_count(); i++) {\n            const char *info;\n\n            ameth = EVP_PKEY_asn1_get0(i);\n            EVP_PKEY_asn1_get0_info(&pkey_id, NULL, NULL, &info, NULL, ameth);\n            if (info == NULL)\n                info = \"<NO NAME>\";\n            TEST_note(\"%d : %s : %s\", pkey_id, OBJ_nid2ln(pkey_id), info);\n        }\n    }\n    return good;\n}", "path": "ruby-packer/vendor/openssl/test/pkey_meth_test.c", "commit_date": "2020-07-18 00:00:00", "repo_name": "pmq20/ruby-packer", "stars": 1550, "license": "mit", "language": "c", "size": 56805}
{"docstring": "/*\n**\n**\toverwrite(win1, win2)\n**\n**\n**\toverwrite() writes the overlapping area of win1 behind win2\n**\ton win2 destructively.\n**\n**/\n", "func_signal": "NCURSES_EXPORT(int)\noverwrite(const WINDOW *win1, WINDOW *win2)", "code": "{\n    T((T_CALLED(\"overwrite(%p,%p)\"), (const void *) win1, (void *) win2));\n    returnCode(overlap(win1, win2, FALSE));\n}", "path": "ruby-packer/vendor/ncurses/ncurses/base/lib_overlay.c", "commit_date": "2017-07-06 00:00:00", "repo_name": "pmq20/ruby-packer", "stars": 1550, "license": "mit", "language": "c", "size": 56805}
{"docstring": "/* ffi_prep_args is called by the assembly routine to transfer arguments\n   to the stack using the pointers in the ecif array.\n   Note that the stack buffer is big enough to fit all the arguments,\n   but the first 16 bytes will be copied to registers for the actual\n   call.  */\n", "func_signal": "void ffi_prep_args (char *stack, extended_cif *ecif)", "code": "{\n  char *argp = stack;\n  unsigned int i;\n\n  /* The implicit return value pointer is passed as if it were a hidden\n     first argument.  */\n  if (ecif->cif->rtype->type == FFI_TYPE_STRUCT\n      && ecif->cif->rtype->size > 8)\n    {\n      (*(void **) argp) = ecif->rvalue;\n      argp += 4;\n    }\n\n  for (i = 0; i < ecif->cif->nargs; i++)\n    {\n      void *avalue = ecif->avalue[i];\n      ffi_type *atype = ecif->cif->arg_types[i];\n      size_t size = atype->size;\n      size_t alignment = atype->alignment;\n\n      /* Align argp as appropriate for the argument type.  */\n      if ((alignment - 1) & (unsigned) argp)\n\targp = (char *) ALIGN (argp, alignment);\n\n      /* Copy the argument, promoting integral types smaller than a\n\t word to word size.  */\n      if (size < sizeof (int))\n\t{\n\t  size = sizeof (int);\n\t  switch (atype->type)\n\t    {\n\t    case FFI_TYPE_SINT8:\n\t      *(signed int *) argp = (signed int) *(SINT8 *) avalue;\n\t      break;\n\t\t  \n\t    case FFI_TYPE_UINT8:\n\t      *(unsigned int *) argp = (unsigned int) *(UINT8 *) avalue;\n\t      break;\n\t\t  \n\t    case FFI_TYPE_SINT16:\n\t      *(signed int *) argp = (signed int) *(SINT16 *) avalue;\n\t      break;\n\t\t  \n\t    case FFI_TYPE_UINT16:\n\t      *(unsigned int *) argp = (unsigned int) *(UINT16 *) avalue;\n\t      break;\n\n\t    case FFI_TYPE_STRUCT:\n\t      memcpy (argp, avalue, atype->size);\n\t      break;\n\n\t    default:\n\t      FFI_ASSERT(0);\n\t    }\n\t}\n      else if (size == sizeof (int))\n\t*(unsigned int *) argp = (unsigned int) *(UINT32 *) avalue;\n      else\n\tmemcpy (argp, avalue, size);\n      argp += size;\n    }\n}", "path": "ruby-packer/vendor/libffi/src/nios2/ffi.c", "commit_date": "2017-07-06 00:00:00", "repo_name": "pmq20/ruby-packer", "stars": 1550, "license": "mit", "language": "c", "size": 56805}
{"docstring": "/*! Prints the copyright notice of the CRuby interpreter to stdout. */\n", "func_signal": "void\nruby_show_copyright(void)", "code": "{\n    PRINT(copyright);\n    fflush(stdout);\n}", "path": "ruby-packer/ruby/version.c", "commit_date": "2020-05-10 00:00:00", "repo_name": "pmq20/ruby-packer", "stars": 1550, "license": "mit", "language": "c", "size": 56805}
{"docstring": "/* Test of EVP_PKEY_METHOD ordering */\n", "func_signal": "static int test_pkey_meths(void)", "code": "{\n    size_t i;\n    int prev = -1;\n    int good = 1;\n    int pkey_id;\n    const EVP_PKEY_METHOD *pmeth;\n\n    for (i = 0; i < EVP_PKEY_meth_get_count(); i++) {\n        pmeth = EVP_PKEY_meth_get0(i);\n        EVP_PKEY_meth_get0_info(&pkey_id, NULL, pmeth);\n        if (pkey_id < prev)\n            good = 0;\n        prev = pkey_id;\n\n    }\n    if (!good) {\n        TEST_error(\"EVP_PKEY_METHOD table out of order\");\n        for (i = 0; i < EVP_PKEY_meth_get_count(); i++) {\n            pmeth = EVP_PKEY_meth_get0(i);\n            EVP_PKEY_meth_get0_info(&pkey_id, NULL, pmeth);\n            TEST_note(\"%d : %s\", pkey_id, OBJ_nid2ln(pkey_id));\n        }\n    }\n    return good;\n}", "path": "ruby-packer/vendor/openssl/test/pkey_meth_test.c", "commit_date": "2020-07-18 00:00:00", "repo_name": "pmq20/ruby-packer", "stars": 1550, "license": "mit", "language": "c", "size": 56805}
{"docstring": "/* Perform machine-dependent cif processing.  */\n", "func_signal": "ffi_status ffi_prep_cif_machdep (ffi_cif *cif)", "code": "{\n  /* We always want at least 16 bytes in the parameter block since it\n     simplifies the low-level call function.  Also round the parameter\n     block size up to a multiple of 4 bytes to preserve\n     32-bit alignment of the stack pointer.  */\n  if (cif->bytes < 16)\n    cif->bytes = 16;\n  else\n    cif->bytes = (cif->bytes + 3) & ~3;\n\n  return FFI_OK;\n}", "path": "ruby-packer/vendor/libffi/src/nios2/ffi.c", "commit_date": "2017-07-06 00:00:00", "repo_name": "pmq20/ruby-packer", "stars": 1550, "license": "mit", "language": "c", "size": 56805}
{"docstring": "/* This function is invoked from the closure trampoline to invoke\n   CLOSURE with argument block ARGS.  Parse ARGS according to\n   CLOSURE->cfi and invoke CLOSURE->fun.  */\n", "func_signal": "static UINT64\nffi_closure_helper (unsigned char *args,\n\t\t    ffi_closure *closure)", "code": "{\n  ffi_cif *cif = closure->cif;\n  unsigned char *argp = args;\n  void **parsed_args = alloca (cif->nargs * sizeof (void *));\n  UINT64 result;\n  void *retptr;\n  unsigned int i;\n\n  /* First figure out what to do about the return type.  If this is the\n     big-structure-return case, the first arg is the hidden return buffer\n     allocated by the caller.  */\n  if (cif->rtype->type == FFI_TYPE_STRUCT\n      && cif->rtype->size > 8)\n    {\n      retptr = *((void **) argp);\n      argp += 4;\n    }\n  else\n    retptr = (void *) &result;\n\n  /* Fill in the array of argument pointers.  */\n  for (i = 0; i < cif->nargs; i++)\n    {\n      size_t size = cif->arg_types[i]->size;\n      size_t alignment = cif->arg_types[i]->alignment;\n\n      /* Align argp as appropriate for the argument type.  */\n      if ((alignment - 1) & (unsigned) argp)\n\targp = (char *) ALIGN (argp, alignment);\n\n      /* Arguments smaller than an int are promoted to int.  */\n      if (size < sizeof (int))\n\tsize = sizeof (int);\n\n      /* Store the pointer.  */\n      parsed_args[i] = argp;\n      argp += size;\n    }\n\n  /* Call the user-supplied function.  */\n  (closure->fun) (cif, retptr, parsed_args, closure->user_data);\n  return result;\n}", "path": "ruby-packer/vendor/libffi/src/nios2/ffi.c", "commit_date": "2017-07-06 00:00:00", "repo_name": "pmq20/ruby-packer", "stars": 1550, "license": "mit", "language": "c", "size": 56805}
{"docstring": "/*\n * Create a data based on an existing policy. If 'id' is NULL use the OID in\n * the policy, otherwise use 'id'. This behaviour covers the two types of\n * data in RFC3280: data with from a CertificatePolicies extension and\n * additional data with just the qualifiers of anyPolicy and ID from another\n * source.\n */\n", "func_signal": "X509_POLICY_DATA *policy_data_new(POLICYINFO *policy,\n                                  const ASN1_OBJECT *cid, int crit)", "code": "{\n    X509_POLICY_DATA *ret;\n    ASN1_OBJECT *id;\n\n    if (policy == NULL && cid == NULL)\n        return NULL;\n    if (cid) {\n        id = OBJ_dup(cid);\n        if (id == NULL)\n            return NULL;\n    } else\n        id = NULL;\n    ret = OPENSSL_zalloc(sizeof(*ret));\n    if (ret == NULL) {\n        X509V3err(X509V3_F_POLICY_DATA_NEW, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n    ret->expected_policy_set = sk_ASN1_OBJECT_new_null();\n    if (ret->expected_policy_set == NULL) {\n        OPENSSL_free(ret);\n        ASN1_OBJECT_free(id);\n        X509V3err(X509V3_F_POLICY_DATA_NEW, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n\n    if (crit)\n        ret->flags = POLICY_DATA_FLAG_CRITICAL;\n\n    if (id)\n        ret->valid_policy = id;\n    else {\n        ret->valid_policy = policy->policyid;\n        policy->policyid = NULL;\n    }\n\n    if (policy) {\n        ret->qualifier_set = policy->qualifiers;\n        policy->qualifiers = NULL;\n    }\n\n    return ret;\n}", "path": "ruby-packer/vendor/openssl/crypto/x509v3/pcy_data.c", "commit_date": "2020-07-18 00:00:00", "repo_name": "pmq20/ruby-packer", "stars": 1550, "license": "mit", "language": "c", "size": 56805}
{"docstring": "/* Call FN using the prepared CIF.  RVALUE points to space allocated by\n   the caller for the return value, and AVALUE is an array of argument\n   pointers.  */\n", "func_signal": "void ffi_call (ffi_cif *cif, void (*fn) (void), void *rvalue, void **avalue)", "code": "{\n\n  extended_cif ecif;\n  UINT64 result;\n\n  /* If bigret is true, this is the case where a return value of larger\n     than 8 bytes is handled by being passed by reference as an implicit\n     argument.  */\n  int bigret = (cif->rtype->type == FFI_TYPE_STRUCT\n\t\t&& cif->rtype->size > 8);\n\n  ecif.cif = cif;\n  ecif.avalue = avalue;\n\n  /* Allocate space for return value if this is the pass-by-reference case\n     and the caller did not provide a buffer.  */\n  if (rvalue == NULL && bigret)\n    ecif.rvalue = alloca (cif->rtype->size);\n  else\n    ecif.rvalue = rvalue;\n\n  result = ffi_call_sysv (ffi_prep_args, &ecif, cif->bytes, fn);\n\n  /* Now result contains the 64 bit contents returned from fn in\n     r2 and r3.  Copy the value of the appropriate size to the user-provided\n     rvalue buffer.  */\n  if (rvalue && !bigret)\n    switch (cif->rtype->size)\n      {\n      case 1:\n\t*(UINT8 *)rvalue = (UINT8) result;\n\tbreak;\n      case 2:\n\t*(UINT16 *)rvalue = (UINT16) result;\n\tbreak;\n      case 4:\n\t*(UINT32 *)rvalue = (UINT32) result;\n\tbreak;\n      case 8:\n\t*(UINT64 *)rvalue = (UINT64) result;\n\tbreak;\n      default:\n\tmemcpy (rvalue, (void *)&result, cif->rtype->size);\n\tbreak;\n      }\n}", "path": "ruby-packer/vendor/libffi/src/nios2/ffi.c", "commit_date": "2017-07-06 00:00:00", "repo_name": "pmq20/ruby-packer", "stars": 1550, "license": "mit", "language": "c", "size": 56805}
{"docstring": "/* Simple PKCS#12 file reader */\n", "func_signal": "static char *find_friendly_name(PKCS12 *p12)", "code": "{\n    STACK_OF(PKCS7) *safes;\n    int n, m;\n    char *name = NULL;\n    PKCS7 *safe;\n    STACK_OF(PKCS12_SAFEBAG) *bags;\n    PKCS12_SAFEBAG *bag;\n\n    if ((safes = PKCS12_unpack_authsafes(p12)) == NULL)\n        return NULL;\n\n    for (n = 0; n < sk_PKCS7_num(safes) && name == NULL; n++) {\n        safe = sk_PKCS7_value(safes, n);\n        if (OBJ_obj2nid(safe->type) != NID_pkcs7_data\n                || (bags = PKCS12_unpack_p7data(safe)) == NULL)\n            continue;\n\n        for (m = 0; m < sk_PKCS12_SAFEBAG_num(bags) && name == NULL; m++) {\n            bag = sk_PKCS12_SAFEBAG_value(bags, m);\n            name = PKCS12_get_friendlyname(bag);\n        }\n        sk_PKCS12_SAFEBAG_pop_free(bags, PKCS12_SAFEBAG_free);\n    }\n\n    sk_PKCS7_pop_free(safes, PKCS7_free);\n\n    return name;\n}", "path": "ruby-packer/vendor/openssl/demos/pkcs12/pkread.c", "commit_date": "2020-07-18 00:00:00", "repo_name": "pmq20/ruby-packer", "stars": 1550, "license": "mit", "language": "c", "size": 56805}
{"docstring": "/*\n**\n**\toverlay(win1, win2)\n**\n**\n**\toverlay() writes the overlapping area of win1 behind win2\n**\ton win2 non-destructively.\n**\n**/\n", "func_signal": "NCURSES_EXPORT(int)\noverlay(const WINDOW *win1, WINDOW *win2)", "code": "{\n    T((T_CALLED(\"overlay(%p,%p)\"), (const void *) win1, (void *) win2));\n    returnCode(overlap(win1, win2, TRUE));\n}", "path": "ruby-packer/vendor/ncurses/ncurses/base/lib_overlay.c", "commit_date": "2017-07-06 00:00:00", "repo_name": "pmq20/ruby-packer", "stars": 1550, "license": "mit", "language": "c", "size": 56805}
{"docstring": "/*! Defines platform-depended Ruby-level constants */\n", "func_signal": "void\nInit_version(void)", "code": "{\n    enum {ruby_patchlevel = RUBY_PATCHLEVEL};\n    VALUE version;\n    VALUE ruby_engine_name;\n    /*\n     * The running version of ruby\n     */\n    rb_define_global_const(\"RUBY_VERSION\", (version = MKSTR(version)));\n    /*\n     * The date this ruby was released\n     */\n    rb_define_global_const(\"RUBY_RELEASE_DATE\", MKSTR(release_date));\n    /*\n     * The platform for this ruby\n     */\n    rb_define_global_const(\"RUBY_PLATFORM\", MKSTR(platform));\n    /*\n     * The patchlevel for this ruby.  If this is a development build of ruby\n     * the patchlevel will be -1\n     */\n    rb_define_global_const(\"RUBY_PATCHLEVEL\", MKINT(patchlevel));\n    /*\n     * The GIT commit hash for this ruby.\n     */\n    rb_define_global_const(\"RUBY_REVISION\", MKSTR(revision));\n    /*\n     * The copyright string for ruby\n     */\n    rb_define_global_const(\"RUBY_COPYRIGHT\", MKSTR(copyright));\n    /*\n     * The engine or interpreter this ruby uses.\n     */\n    rb_define_global_const(\"RUBY_ENGINE\", ruby_engine_name = MKSTR(engine));\n    ruby_set_script_name(ruby_engine_name);\n    /*\n     * The version of the engine or interpreter this ruby uses.\n     */\n    rb_define_global_const(\"RUBY_ENGINE_VERSION\", (1 ? version : MKSTR(version)));\n\n    rb_provide(\"ruby2_keywords.rb\");\n}", "path": "ruby-packer/ruby/version.c", "commit_date": "2020-05-10 00:00:00", "repo_name": "pmq20/ruby-packer", "stars": 1550, "license": "mit", "language": "c", "size": 56805}
{"docstring": "/*\n * Allocate a string into an array of chtype's.  If UTF-8 mode is\n * active, translate the string accordingly.\n */\n", "func_signal": "static NCURSES_CH_T *\nch_dup(char *src)", "code": "{\n    unsigned len = (unsigned) strlen(src);\n    NCURSES_CH_T *dst = typeMalloc(NCURSES_CH_T, len + 1);\n    size_t j, k;\n#if USE_WIDEC_SUPPORT\n    wchar_t wstr[CCHARW_MAX + 1];\n    wchar_t wch;\n    int l = 0;\n    size_t rc;\n    int width;\n#ifndef state_unused\n    mbstate_t state;\n#endif\n#endif /* USE_WIDEC_SUPPORT */\n\n#if USE_WIDEC_SUPPORT\n    reset_mbytes(state);\n#endif\n    for (j = k = 0; j < len; j++) {\n#if USE_WIDEC_SUPPORT\n\trc = (size_t) check_mbytes(wch, src + j, len - j, state);\n\tif (rc == (size_t) -1 || rc == (size_t) -2)\n\t    break;\n\tj += rc - 1;\n\tif ((width = wcwidth(wch)) < 0)\n\t    break;\n\tif ((width > 0 && l > 0) || l == CCHARW_MAX) {\n\t    wstr[l] = L'\\0';\n\t    l = 0;\n\t    if (setcchar(dst + k, wstr, 0, 0, NULL) != OK)\n\t\tbreak;\n\t    ++k;\n\t}\n\tif (width == 0 && l == 0)\n\t    wstr[l++] = L' ';\n\twstr[l++] = wch;\n#else\n\tdst[k++] = (chtype) UChar(src[j]);\n#endif\n    }\n#if USE_WIDEC_SUPPORT\n    if (l > 0) {\n\twstr[l] = L'\\0';\n\tif (setcchar(dst + k, wstr, 0, 0, NULL) == OK)\n\t    ++k;\n    }\n    wstr[0] = L'\\0';\n    setcchar(dst + k, wstr, 0, 0, NULL);\n#else\n    dst[k] = 0;\n#endif\n    return dst;\n}", "path": "ruby-packer/vendor/ncurses/test/view.c", "commit_date": "2017-07-06 00:00:00", "repo_name": "pmq20/ruby-packer", "stars": 1550, "license": "mit", "language": "c", "size": 56805}
{"docstring": "/* Set up an X509_ALGOR DigestAlgorithmIdentifier from an EVP_MD */\n", "func_signal": "void X509_ALGOR_set_md(X509_ALGOR *alg, const EVP_MD *md)", "code": "{\n    int param_type;\n\n    if (md->flags & EVP_MD_FLAG_DIGALGID_ABSENT)\n        param_type = V_ASN1_UNDEF;\n    else\n        param_type = V_ASN1_NULL;\n\n    X509_ALGOR_set0(alg, OBJ_nid2obj(EVP_MD_type(md)), param_type, NULL);\n\n}", "path": "ruby-packer/vendor/openssl/crypto/asn1/x_algor.c", "commit_date": "2020-07-18 00:00:00", "repo_name": "pmq20/ruby-packer", "stars": 1550, "license": "mit", "language": "c", "size": 56805}
{"docstring": "/*\n * This uses functions that are \"unsafe\", but it seems to work on SunOS. \n * Usually: the \"unsafe\" refers to the functions that POSIX lists which may be\n * called from a signal handler.  Those do not include buffered I/O, which is\n * used for instance in wrefresh().  To be really portable, you should use the\n * KEY_RESIZE return (which relies on ncurses' sigwinch handler).\n *\n * The 'wrefresh(curscr)' is needed to force the refresh to start from the top\n * of the screen -- some xterms mangle the bitmap while resizing.\n */\n", "func_signal": "static void\nadjust(int sig)", "code": "{\n    if (waiting || sig == 0) {\n\tstruct winsize size;\n\n\tif (ioctl(fileno(stdout), TIOCGWINSZ, &size) == 0) {\n\t    resize_term(size.ws_row, size.ws_col);\n\t    wrefresh(curscr);\n\t    show_all(sig ? \"SIGWINCH\" : \"interrupt\");\n\t}\n\tinterrupted = FALSE;\n    } else {\n\tinterrupted = TRUE;\n    }\n    (void) signal(SIGWINCH, adjust);\t/* some systems need this */\n}", "path": "ruby-packer/vendor/ncurses/test/view.c", "commit_date": "2017-07-06 00:00:00", "repo_name": "pmq20/ruby-packer", "stars": 1550, "license": "mit", "language": "c", "size": 56805}
{"docstring": "/* Policy Node routines */\n", "func_signal": "void policy_data_free(X509_POLICY_DATA *data)", "code": "{\n    if (data == NULL)\n        return;\n    ASN1_OBJECT_free(data->valid_policy);\n    /* Don't free qualifiers if shared */\n    if (!(data->flags & POLICY_DATA_FLAG_SHARED_QUALIFIERS))\n        sk_POLICYQUALINFO_pop_free(data->qualifier_set, POLICYQUALINFO_free);\n    sk_ASN1_OBJECT_pop_free(data->expected_policy_set, ASN1_OBJECT_free);\n    OPENSSL_free(data);\n}", "path": "ruby-packer/vendor/openssl/crypto/x509v3/pcy_data.c", "commit_date": "2020-07-18 00:00:00", "repo_name": "pmq20/ruby-packer", "stars": 1550, "license": "mit", "language": "c", "size": 56805}
{"docstring": "/* CAN_RESIZE */\n", "func_signal": "static void\nshow_all(const char *tag)", "code": "{\n    int i;\n    char temp[BUFSIZ];\n    NCURSES_CH_T *s;\n    time_t this_time;\n\n#if CAN_RESIZE\n    sprintf(temp, \"%.20s (%3dx%3d) col %d \", tag, LINES, COLS, shift);\n    i = (int) strlen(temp);\n    if ((i + 7) < (int) sizeof(temp)) {\n\tsprintf(temp + i, \"view %.*s\",\n\t\t(int) (sizeof(temp) - 7 - (size_t) i),\n\t\tfname);\n    }\n#else\n    (void) tag;\n    sprintf(temp, \"view %.*s\", (int) sizeof(temp) - 7, fname);\n#endif\n    move(0, 0);\n    printw(\"%.*s\", COLS, temp);\n    clrtoeol();\n    this_time = time((time_t *) 0);\n    strncpy(temp, ctime(&this_time), (size_t) 30);\n    if ((i = (int) strlen(temp)) != 0) {\n\ttemp[--i] = 0;\n\tif (move(0, COLS - i - 2) != ERR)\n\t    printw(\"  %s\", temp);\n    }\n\n    scrollok(stdscr, FALSE);\t/* prevent screen from moving */\n    for (i = 1; i < LINES; i++) {\n\tmove(i, 0);\n\tprintw(\"%3ld:\", (long) (lptr + i - vec_lines));\n\tclrtoeol();\n\tif ((s = lptr[i - 1]) != 0) {\n\t    int len = ch_len(s);\n\t    if (len > shift) {\n#if USE_WIDEC_SUPPORT\n\t\tadd_wchstr(s + shift);\n#else\n\t\taddchstr(s + shift);\n#endif\n\t    }\n#if defined(NCURSES_VERSION) || defined(HAVE_WCHGAT)\n\t    if (try_color)\n\t\twchgat(stdscr, -1, A_NORMAL, my_pair, NULL);\n#endif\n\t}\n    }\n    setscrreg(1, LINES - 1);\n    scrollok(stdscr, TRUE);\n    refresh();\n}", "path": "ruby-packer/vendor/ncurses/test/view.c", "commit_date": "2017-07-06 00:00:00", "repo_name": "pmq20/ruby-packer", "stars": 1550, "license": "mit", "language": "c", "size": 56805}
{"docstring": "/*! Prints the version information of the CRuby interpreter to stdout. */\n", "func_signal": "void\nruby_show_version(void)", "code": "{\n    if (MJIT_OPTS_ON) {\n        PRINT(description_with_jit);\n    }\n    else {\n        PRINT(description);\n    }\n#ifdef RUBY_LAST_COMMIT_TITLE\n    fputs(\"last_commit=\" RUBY_LAST_COMMIT_TITLE, stdout);\n#endif\n#ifdef HAVE_MALLOC_CONF\n    if (malloc_conf) printf(\"malloc_conf=%s\\n\", malloc_conf);\n#endif\n    fflush(stdout);\n}", "path": "ruby-packer/ruby/version.c", "commit_date": "2020-05-10 00:00:00", "repo_name": "pmq20/ruby-packer", "stars": 1550, "license": "mit", "language": "c", "size": 56805}
{"docstring": "/* ordering and symbolic analysis for a Cholesky factorization */\n", "func_signal": "css *cs_schol (CS_INT order, const cs *A)", "code": "{\n    CS_INT n, *c, *post, *P ;\n    cs *C ;\n    css *S ;\n    if (!CS_CSC (A)) return (NULL) ;        /* check inputs */\n    n = A->n ;\n    S = cs_calloc (1, sizeof (css)) ;       /* allocate result S */\n    if (!S) return (NULL) ;                 /* out of memory */\n    P = cs_amd (order, A) ;                 /* P = amd(A+A'), or natural */\n    S->pinv = cs_pinv (P, n) ;              /* find inverse permutation */\n    cs_free (P) ;\n    if (order && !S->pinv) return (cs_sfree (S)) ;\n    C = cs_symperm (A, S->pinv, 0) ;        /* C = spones(triu(A(P,P))) */\n    S->parent = cs_etree (C, 0) ;           /* find etree of C */\n    post = cs_post (S->parent, n) ;         /* postorder the etree */\n    c = cs_counts (C, S->parent, post, 0) ; /* find column counts of chol(C) */\n    cs_free (post) ;\n    cs_spfree (C) ;\n    S->cp = cs_malloc (n+1, sizeof (CS_INT)) ; /* allocate result S->cp */\n    S->unz = S->lnz = cs_cumsum (S->cp, c, n) ; /* find column pointers for L */\n    cs_free (c) ;\n    return ((S->lnz >= 0) ? S : cs_sfree (S)) ;\n}", "path": "igraph/vendor/cs/cs_schol.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "igraph/igraph", "stars": 1649, "license": "gpl-2.0", "language": "c", "size": 129802}
{"docstring": "/* Laplacian OAP, unweighted, directed. SVD, right eigenvectors. */\n", "func_signal": "static int igraph_i_lseembedding_oap_right(igraph_real_t *to,\n                                    const igraph_real_t *from,\n                                    int n, void *extra)", "code": "{\n    igraph_i_asembedding_data_t *data = extra;\n    igraph_adjlist_t *inlist = data->inlist;\n    const igraph_vector_t *deg_in = data->cvec;\n    const igraph_vector_t *deg_out = data->cvec2;\n    igraph_vector_t *tmp = data->tmp;\n    igraph_vector_int_t *neis;\n    int i, j, nlen;\n\n    /* to = O' from */\n    for (i = 0; i < n; i++) {\n        to[i] = VECTOR(*deg_out)[i] * from[i];\n    }\n\n    /* tmp = A' to */\n    for (i = 0; i < n; i++) {\n        neis = igraph_adjlist_get(inlist, i);\n        nlen = igraph_vector_int_size(neis);\n        VECTOR(*tmp)[i] = 0.0;\n        for (j = 0; j < nlen; j++) {\n            int nei = VECTOR(*neis)[j];\n            VECTOR(*tmp)[i] += to[nei];\n        }\n    }\n\n    /* to = P' tmp */\n    for (i = 0; i < n; i++) {\n        to[i] = VECTOR(*deg_in)[i] * VECTOR(*tmp)[i];\n    }\n\n    return 0;\n}", "path": "igraph/src/misc/embedding.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "igraph/igraph", "stars": 1649, "license": "gpl-2.0", "language": "c", "size": 129802}
{"docstring": "/* wrapper for free */\n", "func_signal": "void *cs_free (void *p)", "code": "{\n    if (p) free (p) ;       /* free p if it is not already NULL */\n    return (NULL) ;         /* return NULL to simplify the use of cs_free */\n}", "path": "igraph/vendor/cs/cs_malloc.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "igraph/igraph", "stars": 1649, "license": "gpl-2.0", "language": "c", "size": 129802}
{"docstring": "/* Adjacency matrix, weighted, undirected.\n   Eigendecomposition is used. */\n", "func_signal": "static int igraph_i_asembeddinguw(igraph_real_t *to, const igraph_real_t *from,\n                           int n, void *extra)", "code": "{\n    igraph_i_asembedding_data_t *data = extra;\n    igraph_inclist_t *outlist = data->eoutlist;\n    const igraph_vector_t *cvec = data->cvec;\n    const igraph_vector_t *weights = data->weights;\n    const igraph_t *graph = data->graph;\n    igraph_vector_int_t *incs;\n    int i, j, nlen;\n\n    /* to = (A+cD) from */\n    for (i = 0; i < n; i++) {\n        incs = igraph_inclist_get(outlist, i);\n        nlen = igraph_vector_int_size(incs);\n        to[i] = 0.0;\n        for (j = 0; j < nlen; j++) {\n            long int edge = VECTOR(*incs)[j];\n            long int nei = IGRAPH_OTHER(graph, edge, i);\n            igraph_real_t w = VECTOR(*weights)[edge];\n            to[i] += w * from[nei];\n        }\n        to[i] += VECTOR(*cvec)[i] * from[i];\n    }\n\n    return 0;\n}", "path": "igraph/src/misc/embedding.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "igraph/igraph", "stars": 1649, "license": "gpl-2.0", "language": "c", "size": 129802}
{"docstring": "/* Laplacian D-A, weighted, undirected. Eigendecomposition. */\n", "func_signal": "static int igraph_i_lsembedding_daw(igraph_real_t *to, const igraph_real_t *from,\n                             int n, void *extra)", "code": "{\n    igraph_i_asembedding_data_t *data = extra;\n    igraph_inclist_t *outlist = data->eoutlist;\n    const igraph_vector_t *cvec = data->cvec;\n    const igraph_vector_t *weights = data->weights;\n    const igraph_t *graph = data->graph;\n    igraph_vector_int_t *incs;\n    int i, j, nlen;\n\n    /* to = (D-A) from */\n    for (i = 0; i < n; i++) {\n        incs = igraph_inclist_get(outlist, i);\n        nlen = igraph_vector_int_size(incs);\n        to[i] = 0.0;\n        for (j = 0; j < nlen; j++) {\n            long int edge = VECTOR(*incs)[j];\n            long int nei = IGRAPH_OTHER(graph, edge, i);\n            igraph_real_t w = VECTOR(*weights)[edge];\n            to[i] -= w * from[nei];\n        }\n        to[i] += VECTOR(*cvec)[i] * from[i];\n    }\n\n    return 0;\n}", "path": "igraph/src/misc/embedding.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "igraph/igraph", "stars": 1649, "license": "gpl-2.0", "language": "c", "size": 129802}
{"docstring": "/* wrapper for realloc */\n", "func_signal": "void *cs_realloc (void *p, CS_INT n, size_t size, CS_INT *ok)", "code": "{\n    void *pnew ;\n    pnew = realloc (p, CS_MAX (n,1) * size) ; /* realloc the block */\n    *ok = (pnew != NULL) ;                  /* realloc fails if pnew is NULL */\n    return ((*ok) ? pnew : p) ;             /* return original p if failure */\n}", "path": "igraph/vendor/cs/cs_malloc.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "igraph/igraph", "stars": 1649, "license": "gpl-2.0", "language": "c", "size": 129802}
{"docstring": "/* Laplacian DAD, unweighted, undirected. Eigendecomposition. */\n", "func_signal": "static int igraph_i_lsembedding_dad(igraph_real_t *to, const igraph_real_t *from,\n                             int n, void *extra)", "code": "{\n\n    igraph_i_asembedding_data_t *data = extra;\n    igraph_adjlist_t *outlist = data->outlist;\n    const igraph_vector_t *cvec = data->cvec;\n    igraph_vector_t *tmp = data->tmp;\n    igraph_vector_int_t *neis;\n    int i, j, nlen;\n\n    /* to = D^1/2 from */\n    for (i = 0; i < n; i++) {\n        to[i] = VECTOR(*cvec)[i] * from[i];\n    }\n\n    /* tmp = A to */\n    for (i = 0; i < n; i++) {\n        neis = igraph_adjlist_get(outlist, i);\n        nlen = igraph_vector_int_size(neis);\n        VECTOR(*tmp)[i] = 0.0;\n        for (j = 0; j < nlen; j++) {\n            long int nei = (long int) VECTOR(*neis)[j];\n            VECTOR(*tmp)[i] += to[nei];\n        }\n    }\n\n    /* to = D tmp */\n    for (i = 0; i < n; i++) {\n        to[i] = VECTOR(*cvec)[i] * VECTOR(*tmp)[i];\n    }\n\n    return 0;\n}", "path": "igraph/src/misc/embedding.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "igraph/igraph", "stars": 1649, "license": "gpl-2.0", "language": "c", "size": 129802}
{"docstring": "/* Laplacian OAP, weighted, directed. SVD, right eigenvectors. */\n", "func_signal": "static int igraph_i_lseembedding_oapw_right(igraph_real_t *to,\n                                     const igraph_real_t *from,\n                                     int n, void *extra)", "code": "{\n    igraph_i_asembedding_data_t *data = extra;\n    igraph_inclist_t *inlist = data->einlist;\n    const igraph_vector_t *deg_in = data->cvec;\n    const igraph_vector_t *deg_out = data->cvec2;\n    const igraph_vector_t *weights = data->weights;\n    const igraph_t *graph = data->graph;\n    igraph_vector_t *tmp = data->tmp;\n    igraph_vector_int_t *neis;\n    int i, j, nlen;\n\n    /* to = O' from */\n    for (i = 0; i < n; i++) {\n        to[i] = VECTOR(*deg_out)[i] * from[i];\n    }\n\n    /* tmp = A' to */\n    for (i = 0; i < n; i++) {\n        neis = igraph_inclist_get(inlist, i);\n        nlen = igraph_vector_int_size(neis);\n        VECTOR(*tmp)[i] = 0.0;\n        for (j = 0; j < nlen; j++) {\n            int edge = VECTOR(*neis)[j];\n            int nei = IGRAPH_OTHER(graph, edge, i);\n            igraph_real_t w = VECTOR(*weights)[edge];\n            VECTOR(*tmp)[i] += w * to[nei];\n        }\n    }\n\n    /* to = P' tmp */\n    for (i = 0; i < n; i++) {\n        to[i] = VECTOR(*deg_in)[i] * VECTOR(*tmp)[i];\n    }\n\n    return 0;\n}", "path": "igraph/src/misc/embedding.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "igraph/igraph", "stars": 1649, "license": "gpl-2.0", "language": "c", "size": 129802}
{"docstring": "/* Laplacian OAP, weighted, directed. SVD. */\n", "func_signal": "static int igraph_i_lseembedding_oapw(igraph_real_t *to, const igraph_real_t *from,\n                               int n, void *extra)", "code": "{\n\n    igraph_i_asembedding_data_t *data = extra;\n    igraph_inclist_t *outlist = data->eoutlist;\n    igraph_inclist_t *inlist = data->einlist;\n    const igraph_vector_t *deg_in = data->cvec;\n    const igraph_vector_t *deg_out = data->cvec2;\n    const igraph_vector_t *weights = data->weights;\n    const igraph_t *graph = data->graph;\n    igraph_vector_t *tmp = data->tmp;\n    igraph_vector_int_t *neis;\n    int i, j, nlen;\n\n    /* tmp = O' from */\n    for (i = 0; i < n; i++) {\n        VECTOR(*tmp)[i] = VECTOR(*deg_out)[i] * from[i];\n    }\n\n    /* to = A' tmp */\n    for (i = 0; i < n; i++) {\n        neis = igraph_inclist_get(inlist, i);\n        nlen = igraph_vector_int_size(neis);\n        to[i] = 0.0;\n        for (j = 0; j < nlen; j++) {\n            int edge = VECTOR(*neis)[j];\n            int nei = IGRAPH_OTHER(graph, edge, i);\n            igraph_real_t w = VECTOR(*weights)[edge];\n            to[i] += w * VECTOR(*tmp)[nei];\n        }\n    }\n\n    /* tmp = P' to */\n    for (i = 0; i < n; i++) {\n        VECTOR(*tmp)[i] = VECTOR(*deg_in)[i] * to[i];\n    }\n\n    /* to = P tmp */\n    for (i = 0; i < n; i++) {\n        to[i] = VECTOR(*deg_in)[i] * VECTOR(*tmp)[i];\n    }\n\n    /* tmp = A to */\n    for (i = 0; i < n; i++) {\n        neis = igraph_inclist_get(outlist, i);\n        nlen = igraph_vector_int_size(neis);\n        VECTOR(*tmp)[i] = 0.0;\n        for (j = 0; j < nlen; j++) {\n            int edge = VECTOR(*neis)[j];\n            int nei = IGRAPH_OTHER(graph, edge, i);\n            igraph_real_t w = VECTOR(*weights)[edge];\n            VECTOR(*tmp)[i] += w * to[nei];\n        }\n    }\n\n    /* to = O tmp */\n    for (i = 0; i < n; i++) {\n        to[i] = VECTOR(*deg_out)[i] * VECTOR(*tmp)[i];\n    }\n\n    return 0;\n}", "path": "igraph/src/misc/embedding.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "igraph/igraph", "stars": 1649, "license": "gpl-2.0", "language": "c", "size": 129802}
{"docstring": "/* Adjacency matrix, weighted, directed. SVD, right eigenvectors. */\n", "func_signal": "static int igraph_i_asembeddingw_right(igraph_real_t *to, const igraph_real_t *from,\n                                int n, void *extra)", "code": "{\n    igraph_i_asembedding_data_t *data = extra;\n    igraph_inclist_t *inlist = data->einlist;\n    const igraph_vector_t *cvec = data->cvec;\n    const igraph_vector_t *weights = data->weights;\n    const igraph_t *graph = data->graph;\n    igraph_vector_int_t *incs;\n    int i, j, nlen;\n\n    /* to = (A+cD)' from */\n    for (i = 0; i < n; i++) {\n        incs = igraph_inclist_get(inlist, i);\n        nlen = igraph_vector_int_size(incs);\n        to[i] = 0.0;\n        for (j = 0; j < nlen; j++) {\n            long int edge = VECTOR(*incs)[j];\n            long int nei = IGRAPH_OTHER(graph, edge, i);\n            igraph_real_t w = VECTOR(*weights)[edge];\n            to[i] += w * from[nei];\n        }\n        to[i] += VECTOR(*cvec)[i] * from[i];\n    }\n\n    return 0;\n}", "path": "igraph/src/misc/embedding.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "igraph/igraph", "stars": 1649, "license": "gpl-2.0", "language": "c", "size": 129802}
{"docstring": "/* Adjacency matrix, weighted, directed. SVD. */\n", "func_signal": "static int igraph_i_asembeddingw(igraph_real_t *to, const igraph_real_t *from,\n                          int n, void *extra)", "code": "{\n    igraph_i_asembedding_data_t *data = extra;\n    igraph_inclist_t *outlist = data->eoutlist;\n    igraph_inclist_t *inlist = data->einlist;\n    const igraph_vector_t *cvec = data->cvec;\n    const igraph_vector_t *weights = data->weights;\n    const igraph_t *graph = data->graph;\n    igraph_vector_t *tmp = data->tmp;\n    igraph_vector_int_t *incs;\n    int i, j, nlen;\n\n    /* tmp = (A+cD)' from */\n    for (i = 0; i < n; i++) {\n        incs = igraph_inclist_get(inlist, i);\n        nlen = igraph_vector_int_size(incs);\n        VECTOR(*tmp)[i] = 0.0;\n        for (j = 0; j < nlen; j++) {\n            long int edge = VECTOR(*incs)[j];\n            long int nei = IGRAPH_OTHER(graph, edge, i);\n            igraph_real_t w = VECTOR(*weights)[edge];\n            VECTOR(*tmp)[i] += w * from[nei];\n        }\n        VECTOR(*tmp)[i] += VECTOR(*cvec)[i] * from[i];\n    }\n\n    /* to = (A+cD) tmp */\n    for (i = 0; i < n; i++) {\n        incs = igraph_inclist_get(outlist, i);\n        nlen = igraph_vector_int_size(incs);\n        to[i] = 0.0;\n        for (j = 0; j < nlen; j++) {\n            long int edge = VECTOR(*incs)[j];\n            long int nei = IGRAPH_OTHER(graph, edge, i);\n            igraph_real_t w = VECTOR(*weights)[edge];\n            to[i] += w * VECTOR(*tmp)[nei];\n        }\n        to[i] += VECTOR(*cvec)[i] * VECTOR(*tmp)[i];\n    }\n\n    return 0;\n}", "path": "igraph/src/misc/embedding.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "igraph/igraph", "stars": 1649, "license": "gpl-2.0", "language": "c", "size": 129802}
{"docstring": "/* Adjacency matrix, unweighted, directed. SVD, right eigenvectors */\n", "func_signal": "static int igraph_i_asembedding_right(igraph_real_t *to, const igraph_real_t *from,\n                               int n, void *extra)", "code": "{\n    igraph_i_asembedding_data_t *data = extra;\n    igraph_adjlist_t *inlist = data->inlist;\n    const igraph_vector_t *cvec = data->cvec;\n    igraph_vector_int_t *neis;\n    int i, j, nlen;\n\n    /* to = (A+cD)' from */\n    for (i = 0; i < n; i++) {\n        neis = igraph_adjlist_get(inlist, i);\n        nlen = igraph_vector_int_size(neis);\n        to[i] = 0.0;\n        for (j = 0; j < nlen; j++) {\n            long int nei = (long int) VECTOR(*neis)[j];\n            to[i] += from[nei];\n        }\n        to[i] += VECTOR(*cvec)[i] * from[i];\n    }\n\n    return 0;\n}", "path": "igraph/src/misc/embedding.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "igraph/igraph", "stars": 1649, "license": "gpl-2.0", "language": "c", "size": 129802}
{"docstring": "/* Takes a pointer vector of vectors. Sorts each vector, then sorts the pointer vector */\n", "func_signal": "void canonicalize_list(igraph_vector_ptr_t *list)", "code": "{\n    long i, len;\n    len = igraph_vector_ptr_size(list);\n    for (i = 0; i < len; ++i) {\n        igraph_vector_sort((igraph_vector_t *) VECTOR(*list)[i]);\n    }\n    qsort(&(VECTOR(*list)[0]), len, sizeof(void *), &compare_vectors);\n}", "path": "igraph/tests/unit/igraph_weighted_cliques.c", "commit_date": "2020-12-20 00:00:00", "repo_name": "igraph/igraph", "stars": 1649, "license": "gpl-2.0", "language": "c", "size": 129802}
{"docstring": "/* Adjacency matrix, unweighted, directed. SVD. */\n", "func_signal": "static int igraph_i_asembedding(igraph_real_t *to, const igraph_real_t *from,\n                         int n, void *extra)", "code": "{\n    igraph_i_asembedding_data_t *data = extra;\n    igraph_adjlist_t *outlist = data->outlist;\n    igraph_adjlist_t *inlist = data->inlist;\n    const igraph_vector_t *cvec = data->cvec;\n    igraph_vector_t *tmp = data->tmp;\n    igraph_vector_int_t *neis;\n    int i, j, nlen;\n\n    /* tmp = (A+cD)' from */\n    for (i = 0; i < n; i++) {\n        neis = igraph_adjlist_get(inlist, i);\n        nlen = igraph_vector_int_size(neis);\n        VECTOR(*tmp)[i] = 0.0;\n        for (j = 0; j < nlen; j++) {\n            long int nei = (long int) VECTOR(*neis)[j];\n            VECTOR(*tmp)[i] += from[nei];\n        }\n        VECTOR(*tmp)[i] += VECTOR(*cvec)[i] * from[i];\n    }\n\n    /* to = (A+cD) tmp */\n    for (i = 0; i < n; i++) {\n        neis = igraph_adjlist_get(outlist, i);\n        nlen = igraph_vector_int_size(neis);\n        to[i] = 0.0;\n        for (j = 0; j < nlen; j++) {\n            long int nei = (long int) VECTOR(*neis)[j];\n            to[i] += VECTOR(*tmp)[nei];\n        }\n        to[i] += VECTOR(*cvec)[i] * VECTOR(*tmp)[i];\n    }\n\n    return 0;\n}", "path": "igraph/src/misc/embedding.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "igraph/igraph", "stars": 1649, "license": "gpl-2.0", "language": "c", "size": 129802}
{"docstring": "/**\n * \\ingroup loadsave\n * \\function igraph_write_graph_edgelist\n * \\brief Writes the edge list of a graph to a file.\n *\n * </para><para>\n * One edge is written per line, separated by a single space.\n * For directed graphs edges are written in from, to order.\n * \\param graph The graph object to write.\n * \\param outstream Pointer to a stream, it should be writable.\n * \\return Error code:\n *         \\c IGRAPH_EFILE if there is an error writing the\n *         file.\n *\n * Time complexity: O(|E|), the\n * number of edges in the  graph. It is assumed that writing an\n * integer to the file requires O(1)\n * time.\n */\n", "func_signal": "int igraph_write_graph_edgelist(const igraph_t *graph, FILE *outstream)", "code": "{\n\n    igraph_eit_t it;\n\n    IGRAPH_CHECK(igraph_eit_create(graph, igraph_ess_all(IGRAPH_EDGEORDER_FROM),\n                                   &it));\n    IGRAPH_FINALLY(igraph_eit_destroy, &it);\n\n    while (!IGRAPH_EIT_END(it)) {\n        igraph_integer_t from, to;\n        int ret;\n        igraph_edge(graph, IGRAPH_EIT_GET(it), &from, &to);\n        ret = fprintf(outstream, \"%li %li\\n\",\n                      (long int) from,\n                      (long int) to);\n        if (ret < 0) {\n            IGRAPH_ERROR(\"Write error\", IGRAPH_EFILE);\n        }\n        IGRAPH_EIT_NEXT(it);\n    }\n\n    igraph_eit_destroy(&it);\n    IGRAPH_FINALLY_CLEAN(1);\n    return 0;\n}", "path": "igraph/src/io/edgelist.c", "commit_date": "2020-12-29 00:00:00", "repo_name": "igraph/igraph", "stars": 1649, "license": "gpl-2.0", "language": "c", "size": 129802}
{"docstring": "/* Laplacian OAP, unweighted, directed. SVD. */\n", "func_signal": "static int igraph_i_lseembedding_oap(igraph_real_t *to, const igraph_real_t *from,\n                              int n, void *extra)", "code": "{\n\n    igraph_i_asembedding_data_t *data = extra;\n    igraph_adjlist_t *outlist = data->outlist;\n    igraph_adjlist_t *inlist = data->inlist;\n    const igraph_vector_t *deg_in = data->cvec;\n    const igraph_vector_t *deg_out = data->cvec2;\n    igraph_vector_t *tmp = data->tmp;\n    igraph_vector_int_t *neis;\n    int i, j, nlen;\n\n    /* tmp = O' from */\n    for (i = 0; i < n; i++) {\n        VECTOR(*tmp)[i] = VECTOR(*deg_out)[i] * from[i];\n    }\n\n    /* to = A' tmp */\n    for (i = 0; i < n; i++) {\n        neis = igraph_adjlist_get(inlist, i);\n        nlen = igraph_vector_int_size(neis);\n        to[i] = 0.0;\n        for (j = 0; j < nlen; j++) {\n            int nei = VECTOR(*neis)[j];\n            to[i] += VECTOR(*tmp)[nei];\n        }\n    }\n\n    /* tmp = P' to */\n    for (i = 0; i < n; i++) {\n        VECTOR(*tmp)[i] = VECTOR(*deg_in)[i] * to[i];\n    }\n\n    /* to = P tmp */\n    for (i = 0; i < n; i++) {\n        to[i] = VECTOR(*deg_in)[i] * VECTOR(*tmp)[i];\n    }\n\n    /* tmp = A to */\n    for (i = 0; i < n; i++) {\n        neis = igraph_adjlist_get(outlist, i);\n        nlen = igraph_vector_int_size(neis);\n        VECTOR(*tmp)[i] = 0.0;\n        for (j = 0; j < nlen; j++) {\n            int nei = VECTOR(*neis)[j];\n            VECTOR(*tmp)[i] += to[nei];\n        }\n    }\n\n    /* to = O tmp */\n    for (i = 0; i < n; i++) {\n        to[i] = VECTOR(*deg_out)[i] * VECTOR(*tmp)[i];\n    }\n\n    return 0;\n}", "path": "igraph/src/misc/embedding.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "igraph/igraph", "stars": 1649, "license": "gpl-2.0", "language": "c", "size": 129802}
{"docstring": "/* Prints a clique vector along with its weight */\n", "func_signal": "void print_weighted_clique(const igraph_vector_t *clique, const igraph_vector_t *vertex_weights)", "code": "{\n    long int i, n = igraph_vector_size(clique);\n    igraph_real_t clique_weight = 0.0;\n    for (i = 0; i < n; i++) {\n        int v = VECTOR(*clique)[i];\n        clique_weight += igraph_vector_e(vertex_weights, v);\n        printf(\" %d\", v);\n    }\n    printf(\" w=%.1f\\n\", clique_weight);\n}", "path": "igraph/tests/unit/igraph_weighted_cliques.c", "commit_date": "2020-12-20 00:00:00", "repo_name": "igraph/igraph", "stars": 1649, "license": "gpl-2.0", "language": "c", "size": 129802}
{"docstring": "/* Laplacian D-A, unweighted, undirected. Eigendecomposition. */\n", "func_signal": "static int igraph_i_lsembedding_da(igraph_real_t *to, const igraph_real_t *from,\n                            int n, void *extra)", "code": "{\n    igraph_i_asembedding_data_t *data = extra;\n    igraph_adjlist_t *outlist = data->outlist;\n    const igraph_vector_t *cvec = data->cvec;\n    igraph_vector_int_t *neis;\n    int i, j, nlen;\n\n    /* to = (D-A) from */\n    for (i = 0; i < n; i++) {\n        neis = igraph_adjlist_get(outlist, i);\n        nlen = igraph_vector_int_size(neis);\n        to[i] = 0.0;\n        for (j = 0; j < nlen; j++) {\n            long int nei = (long int) VECTOR(*neis)[j];\n            to[i] -= from[nei];\n        }\n        to[i] += VECTOR(*cvec)[i] * from[i];\n    }\n\n    return 0;\n}", "path": "igraph/src/misc/embedding.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "igraph/igraph", "stars": 1649, "license": "gpl-2.0", "language": "c", "size": 129802}
{"docstring": "/* Adjacency matrix, unweighted, undirected.\n   Eigendecomposition is used */\n", "func_signal": "static int igraph_i_asembeddingu(igraph_real_t *to, const igraph_real_t *from,\n                          int n, void *extra)", "code": "{\n    igraph_i_asembedding_data_t *data = extra;\n    igraph_adjlist_t *outlist = data->outlist;\n    const igraph_vector_t *cvec = data->cvec;\n    igraph_vector_int_t *neis;\n    int i, j, nlen;\n\n    /* to = (A+cD) from */\n    for (i = 0; i < n; i++) {\n        neis = igraph_adjlist_get(outlist, i);\n        nlen = igraph_vector_int_size(neis);\n        to[i] = 0.0;\n        for (j = 0; j < nlen; j++) {\n            long int nei = (long int) VECTOR(*neis)[j];\n            to[i] += from[nei];\n        }\n        to[i] += VECTOR(*cvec)[i] * from[i];\n    }\n\n    return 0;\n}", "path": "igraph/src/misc/embedding.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "igraph/igraph", "stars": 1649, "license": "gpl-2.0", "language": "c", "size": 129802}
{"docstring": "/*initialization routine*/\n", "func_signal": "VOID\nf_init(Void)", "code": "{\tunit *p;\n\n\tf__init=1;\n\tp= &f__units[0];\n\tp->ufd=stderr;\n\tp->useek=f__canseek(stderr);\n\tp->ufmt=1;\n\tp->uwrt=1;\n\tp = &f__units[5];\n\tp->ufd=stdin;\n\tp->useek=f__canseek(stdin);\n\tp->ufmt=1;\n\tp->uwrt=0;\n\tp= &f__units[6];\n\tp->ufd=stdout;\n\tp->useek=f__canseek(stdout);\n\tp->ufmt=1;\n\tp->uwrt=1;\n}", "path": "igraph/vendor/f2c/err.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "igraph/igraph", "stars": 1649, "license": "gpl-2.0", "language": "c", "size": 129802}
{"docstring": "/**\n * rtw_halmac_set_rts_full_bw() - Send RTS to all covered channels\n * @d:\t\tstruct dvobj_priv*\n * @enable:\t_TRUE(enable), _FALSE(disable)\n *\n * Hradware will duplicate RTS packet to all channels which are covered in used\n * bandwidth.\n *\n * Return 0 if process OK, otherwise -1.\n */\n", "func_signal": "int rtw_halmac_set_rts_full_bw(struct dvobj_priv *d, u8 enable)", "code": "{\n\tstruct halmac_adapter *mac;\n\tstruct halmac_api *api;\n\tenum halmac_ret_status status;\n\tu8 full;\n\n\n\tmac = dvobj_to_halmac(d);\n\tapi = HALMAC_GET_API(mac);\n\tfull = (enable == _TRUE) ? 1 : 0;\n\n\tstatus = api->halmac_set_hw_value(mac, HALMAC_HW_RTS_FULL_BW, &full);\n\tif (HALMAC_RET_SUCCESS != status)\n\t\treturn -1;\n\n\treturn 0;\n}", "path": "rtl8821ce/hal/hal_halmac.c", "commit_date": "2019-10-22 00:00:00", "repo_name": "tomaspinho/rtl8821ce", "stars": 1531, "license": "other", "language": "c", "size": 6039}
{"docstring": "/* !CONFIG_SDIO_HCI */\n", "func_signal": "static u8 _halmac_mfree(void *p, void *buffer, u32 size)", "code": "{\n\trtw_mfree(buffer, size);\n\treturn RTW_HALMAC_SUCCESS;\n}", "path": "rtl8821ce/hal/hal_halmac.c", "commit_date": "2019-10-22 00:00:00", "repo_name": "tomaspinho/rtl8821ce", "stars": 1531, "license": "other", "language": "c", "size": 6039}
{"docstring": "/*this function is for BFer bug workaround*/\n", "func_signal": "void phydm_8822b_sutxbfer_workaroud(void *dm_void, boolean enable_su_bfer,\n\t\t\t\t    u8 nc, u8 nr, u8 ng, u8 CB, u8 BW,\n\t\t\t\t    boolean is_vht)", "code": "{\n\tstruct dm_struct *dm = (struct dm_struct *)dm_void;\n\n\tif (enable_su_bfer) {\n\t\todm_set_bb_reg(dm, R_0x19f8, BIT(22) | BIT(21) | BIT(20), 0x1);\n\t\todm_set_bb_reg(dm, R_0x19f8, BIT(25) | BIT(24) | BIT(23), 0x0);\n\t\todm_set_bb_reg(dm, R_0x19f8, BIT(16), 0x1);\n\n\t\tif (is_vht)\n\t\t\todm_set_bb_reg(dm, R_0x19f0, BIT(5) | BIT(4) | BIT(3) | BIT(2) | BIT(1) | BIT(0), 0x1f);\n\t\telse\n\t\t\todm_set_bb_reg(dm, R_0x19f0, BIT(5) | BIT(4) | BIT(3) | BIT(2) | BIT(1) | BIT(0), 0x22);\n\n\t\todm_set_bb_reg(dm, R_0x19f0, BIT(7) | BIT(6), nc);\n\t\todm_set_bb_reg(dm, R_0x19f0, BIT(9) | BIT(8), nr);\n\t\todm_set_bb_reg(dm, R_0x19f0, BIT(11) | BIT(10), ng);\n\t\todm_set_bb_reg(dm, R_0x19f0, BIT(13) | BIT(12), CB);\n\n\t\todm_set_bb_reg(dm, R_0xb58, BIT(3) | BIT(2), BW);\n\t\todm_set_bb_reg(dm, R_0xb58, BIT(7) | BIT(6) | BIT(5) | BIT(4), 0x0);\n\t\todm_set_bb_reg(dm, R_0xb58, BIT(9) | BIT(8), BW);\n\t\todm_set_bb_reg(dm, R_0xb58, BIT(13) | BIT(12) | BIT(11) | BIT(10), 0x0);\n\t} else {\n\t\todm_set_bb_reg(dm, R_0x19f8, BIT(16), 0x0);\n\t}\n\n\tPHYDM_DBG(dm, DBG_TXBF, \"[%s] enable_su_bfer = %d, is_vht = %d\\n\",\n\t\t  __func__, enable_su_bfer, is_vht);\n\tPHYDM_DBG(dm, DBG_TXBF,\n\t\t  \"[%s] nc = %d, nr = %d, ng = %d, CB = %d, BW = %d\\n\",\n\t\t  __func__, nc, nr, ng, CB, BW);\n}", "path": "rtl8821ce/hal/phydm/txbf/haltxbf8822b.c", "commit_date": "2019-08-05 00:00:00", "repo_name": "tomaspinho/rtl8821ce", "stars": 1531, "license": "other", "language": "c", "size": 6039}
{"docstring": "/**\n * rtw_halmac_set_max_dl_fw_size() - Set the MAX download firmware size\n * @d:\t\tstruct dvobj_priv*\n * @size:\tthe max download firmware size in one I/O\n *\n * Set the max download firmware size in one I/O.\n * Please also consider the max size of the callback function \"SEND_RSVD_PAGE\"\n * could accept, because download firmware would call \"SEND_RSVD_PAGE\" to send\n * firmware to IC.\n *\n * If the value of \"size\" is not even, it would be rounded down to nearest\n * even, and 0 and 1 are both invalid value.\n *\n * Return 0 for setting OK, otherwise fail.\n */\n", "func_signal": "int rtw_halmac_set_max_dl_fw_size(struct dvobj_priv *d, u32 size)", "code": "{\n\tstruct halmac_adapter *mac;\n\tstruct halmac_api *api;\n\tenum halmac_ret_status status;\n\n\n\tif (!size || (size == 1))\n\t\treturn -1;\n\n\tmac = dvobj_to_halmac(d);\n\tif (!mac) {\n\t\tRTW_ERR(\"%s: HALMAC is not ready!!\\n\", __FUNCTION__);\n\t\treturn -1;\n\t}\n\tapi = HALMAC_GET_API(mac);\n\n\tsize &= ~1; /* round down to even */\n\tstatus = api->halmac_cfg_max_dl_size(mac, size);\n\tif (status != HALMAC_RET_SUCCESS) {\n\t\tRTW_WARN(\"%s: Fail to cfg_max_dl_size(%d), err=%d!!\\n\",\n\t\t\t __FUNCTION__, size, status);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}", "path": "rtl8821ce/hal/hal_halmac.c", "commit_date": "2019-10-22 00:00:00", "repo_name": "tomaspinho/rtl8821ce", "stars": 1531, "license": "other", "language": "c", "size": 6039}
{"docstring": "/* !CONFIG_SDIO_HCI */\n", "func_signal": "static u8 _halmac_reg_read_8(void *p, u32 offset)", "code": "{\n\tstruct dvobj_priv *d;\n\tPADAPTER adapter;\n\n\n\td = (struct dvobj_priv *)p;\n\tadapter = dvobj_get_primary_adapter(d);\n\n\treturn rtw_read8(adapter, offset);\n}", "path": "rtl8821ce/hal/hal_halmac.c", "commit_date": "2019-10-22 00:00:00", "repo_name": "tomaspinho/rtl8821ce", "stars": 1531, "license": "other", "language": "c", "size": 6039}
{"docstring": "/**\n * rtw_halmac_reset_tsf() - Reset TSF timer of specific port\n * @d:\t\tstruct dvobj_priv*\n * @hwport:\tport\n *\n * Notice HALMAC to reset timing synchronization function(TSF) timer of\n * specific port.\n *\n * Rteurn 0 for OK, otherwise fail.\n */\n", "func_signal": "int rtw_halmac_reset_tsf(struct dvobj_priv *d, enum _hw_port hwport)", "code": "{\n\tstruct halmac_adapter *halmac;\n\tstruct halmac_api *api;\n\tenum halmac_portid port;\n\tenum halmac_ret_status status;\n\tint err = -1;\n\n\n\thalmac = dvobj_to_halmac(d);\n\tapi = HALMAC_GET_API(halmac);\n\tport = _hw_port_drv2halmac(hwport);\n\n\tstatus = api->halmac_cfg_tsf_rst(halmac, port);\n\tif (status != HALMAC_RET_SUCCESS)\n\t\tgoto out;\n\n\terr = 0;\nout:\n\treturn err;\n}", "path": "rtl8821ce/hal/hal_halmac.c", "commit_date": "2019-10-22 00:00:00", "repo_name": "tomaspinho/rtl8821ce", "stars": 1531, "license": "other", "language": "c", "size": 6039}
{"docstring": "/*\n * Description:\n *\tDownlaod Firmware Flow\n *\n * Parameters:\n *\td\tpointer of struct dvobj_priv\n *\tfw\tfirmware array\n *\tfwsize\tfirmware size\n *\tre_dl\tre-download firmware or not\n *\t\t0: run in init hal flow, not re-download\n *\t\t1: it is a stand alone operation, not in init hal flow\n *\n * Return:\n *\t0\tSuccess\n *\tothers\tFail\n */\n", "func_signal": "static int download_fw(struct dvobj_priv *d, u8 *fw, u32 fwsize, u8 re_dl)", "code": "{\n\tPHAL_DATA_TYPE hal;\n\tstruct halmac_adapter *mac;\n\tstruct halmac_api *api;\n\tstruct halmac_fw_version fw_vesion;\n\tenum halmac_ret_status status;\n\tint err = 0;\n\n\n\thal = GET_HAL_DATA(dvobj_get_primary_adapter(d));\n\tmac = dvobj_to_halmac(d);\n\tapi = HALMAC_GET_API(mac);\n\n\tif ((!fw) || (!fwsize))\n\t\treturn -1;\n\n\t/* 1. Driver Stop Tx */\n\t/* ToDo */\n\n\t/* 2. Driver Check Tx FIFO is empty */\n\terr = rtw_halmac_txfifo_wait_empty(d, 2000); /* wait 2s */\n\tif (err) {\n\t\terr = -1;\n\t\tgoto resume_tx;\n\t}\n\n\t/* 3. Config MAX download size */\n\t/*\n\t * Already done in rtw_halmac_init_adapter() or\n\t * somewhere calling rtw_halmac_set_max_dl_fw_size().\n\t */\n\n\tif (re_dl) {\n\t\t/* 4. Enter IC CPU sleep mode */\n\t\terr = _cpu_sleep(d, 2000);\n\t\tif (err) {\n\t\t\tRTW_ERR(\"%s: IC CPU fail to enter sleep mode!(%d)\\n\",\n\t\t\t\t__FUNCTION__, err);\n\t\t\t/* skip this error */\n\t\t\terr = 0;\n\t\t}\n\t}\n\n\t/* 5. Download Firmware */\n\tstatus = api->halmac_download_firmware(mac, fw, fwsize);\n\tif (status != HALMAC_RET_SUCCESS) {\n\t\tRTW_ERR(\"%s: download firmware FAIL! status=0x%02x\\n\",\n\t\t\t__FUNCTION__, status);\n\t\t_debug_dlfw_fail(d);\n\t\terr = -1;\n\t\tgoto resume_tx;\n\t}\n\n\t/* 5.1. (Driver) Reset driver variables if needed */\n\thal->LastHMEBoxNum = 0;\n\n\t/* 5.2. (Driver) Get FW version */\n\tstatus = api->halmac_get_fw_version(mac, &fw_vesion);\n\tif (status == HALMAC_RET_SUCCESS) {\n\t\thal->firmware_version = fw_vesion.version;\n\t\thal->firmware_sub_version = fw_vesion.sub_version;\n\t\thal->firmware_size = fwsize;\n\t}\n\nresume_tx:\n\t/* 6. Driver resume TX if needed */\n\t/* ToDo */\n\n\tif (err)\n\t\tgoto exit;\n\n\tif (re_dl) {\n\t\tenum halmac_trx_mode mode;\n\n\t\t/* 7. Change reserved page size */\n\t\terr = _cfg_drv_rsvd_pg_num(d);\n\t\tif (err)\n\t\t\treturn -1;\n\n\t\t/* 8. Init TRX Configuration */\n\t\tmode = _choose_trx_mode(d);\n\t\tstatus = api->halmac_init_trx_cfg(mac, mode);\n\t\tif (HALMAC_RET_SUCCESS != status)\n\t\t\treturn -1;\n\t\t_init_trx_cfg_drv(d);\n\n\t\t/* 9. Config RX Aggregation */\n\t\terr = rtw_halmac_rx_agg_switch(d, _TRUE);\n\t\tif (err)\n\t\t\treturn -1;\n\n\t\t/* 10. Send General Info */\n\t\terr = _send_general_info(d);\n\t\tif (err)\n\t\t\treturn -1;\n\t}\n\nexit:\n\treturn err;\n}", "path": "rtl8821ce/hal/hal_halmac.c", "commit_date": "2019-10-22 00:00:00", "repo_name": "tomaspinho/rtl8821ce", "stars": 1531, "license": "other", "language": "c", "size": 6039}
{"docstring": "/**\n * rtw_halmac_set_tx_address() - Set transmitter address of specific port\n * @d:\t\tstruct dvobj_priv*\n * @hwport:\tport\n * @addr:\ttransmitter address\n *\n * Set transmitter address of specific port to HALMAC.\n *\n * Rteurn 0 for OK, otherwise fail.\n */\n", "func_signal": "int rtw_halmac_set_tx_address(struct dvobj_priv *d, enum _hw_port hwport, u8 *addr)", "code": "{\n\tstruct halmac_adapter *halmac;\n\tstruct halmac_api *api;\n\tenum halmac_portid port;\n\tunion halmac_wlan_addr hwa;\n\tenum halmac_ret_status status;\n\tint err = -1;\n\n\n\thalmac = dvobj_to_halmac(d);\n\tapi = HALMAC_GET_API(halmac);\n\tport = _hw_port_drv2halmac(hwport);\n\t_rtw_memset(&hwa, 0, sizeof(hwa));\n\t_rtw_memcpy(hwa.addr, addr, 6);\n\n\tstatus = api->halmac_cfg_transmitter_addr(halmac, port, &hwa);\n\tif (status != HALMAC_RET_SUCCESS)\n\t\tgoto out;\n\n\terr = 0;\nout:\n\treturn err;\n}", "path": "rtl8821ce/hal/hal_halmac.c", "commit_date": "2019-10-22 00:00:00", "repo_name": "tomaspinho/rtl8821ce", "stars": 1531, "license": "other", "language": "c", "size": 6039}
{"docstring": "/***************SU & MU BFee Entry********************/\n", "func_signal": "void hal_txbf_8822b_rf_mode(\n\tvoid *dm_void,\n\tstruct _RT_BEAMFORMING_INFO *beamforming_info,\n\tu8 idx)", "code": "{\n#if 0\n\tstruct dm_struct\t*dm = (struct dm_struct *)dm_void;\n\tu8\t\t\t\ti, nr_index = 0;\n\tboolean\t\t\t\tis_self_beamformer = false;\n\tboolean\t\t\t\tis_self_beamformee = false;\n\tstruct _RT_BEAMFORMEE_ENTRY\tbeamformee_entry;\n\n\tif (idx < BEAMFORMEE_ENTRY_NUM)\n\t\tbeamformee_entry = beamforming_info->beamformee_entry[idx];\n\telse\n\t\treturn;\n\n\tif (dm->rf_type == RF_1T1R)\n\t\treturn;\n\n\tfor (i = RF_PATH_A; i < RF_PATH_B; i++) {\n\t\todm_set_rf_reg(dm, (enum rf_path)i, rf_welut_jaguar, 0x80000, 0x1);\n\t\t/*RF mode table write enable*/\n\t}\n\n\tif (beamforming_info->beamformee_su_cnt > 0 || beamforming_info->beamformee_mu_cnt > 0) {\n\t\tfor (i = RF_PATH_A; i < RF_PATH_B; i++) {\n\t\t\todm_set_rf_reg(dm, (enum rf_path)i, rf_mode_table_addr, 0xfffff, 0x18000);\n\t\t\t/*Select RX mode*/\n\t\t\todm_set_rf_reg(dm, (enum rf_path)i, rf_mode_table_data0, 0xfffff, 0xBE77F);\n\t\t\t/*Set Table data*/\n\t\t\todm_set_rf_reg(dm, (enum rf_path)i, rf_mode_table_data1, 0xfffff, 0x226BF);\n\t\t\t/*@Enable TXIQGEN in RX mode*/\n\t\t}\n\t\todm_set_rf_reg(dm, RF_PATH_A, rf_mode_table_data1, 0xfffff, 0xE26BF);\n\t\t/*@Enable TXIQGEN in RX mode*/\n\t}\n\n\tfor (i = RF_PATH_A; i < RF_PATH_B; i++) {\n\t\todm_set_rf_reg(dm, (enum rf_path)i, rf_welut_jaguar, 0x80000, 0x0);\n\t\t/*RF mode table write disable*/\n\t}\n\n\tif (beamforming_info->beamformee_su_cnt > 0) {\n\t\t/*@for 8814 19ac(idx 1), 19b4(idx 0), different Tx ant setting*/\n\t\todm_set_bb_reg(dm, REG_BB_TXBF_ANT_SET_BF1_8822B, BIT(28) | BIT29, 0x2);\t\t\t/*@enable BB TxBF ant mapping register*/\n\n\t\tif (idx == 0) {\n\t\t\t/*Nsts = 2\tAB*/\n\t\t\todm_set_bb_reg(dm, REG_BB_TXBF_ANT_SET_BF0_8822B, 0xffff, 0x0433);\n\t\t\todm_set_bb_reg(dm, REG_BB_TX_PATH_SEL_1_8822B, 0xfff00000, 0x043);\n\t\t\t/*odm_set_bb_reg(dm, REG_BB_TX_PATH_SEL_2, MASKLWORD, 0x430);*/\n\n\t\t} else {/*@IDX =1*/\n\t\t\todm_set_bb_reg(dm, REG_BB_TXBF_ANT_SET_BF1_8822B, 0xffff, 0x0433);\n\t\t\todm_set_bb_reg(dm, REG_BB_TX_PATH_SEL_1_8822B, 0xfff00000, 0x043);\n\t\t\t/*odm_set_bb_reg(dm, REG_BB_TX_PATH_SEL_2, MASKLWORD, 0x430;*/\n\t\t}\n\t} else {\n\t\todm_set_bb_reg(dm, REG_BB_TX_PATH_SEL_1_8822B, 0xfff00000, 0x1); /*@1SS by path-A*/\n\t\todm_set_bb_reg(dm, REG_BB_TX_PATH_SEL_2_8822B, MASKLWORD, 0x430); /*@2SS by path-A,B*/\n\t}\n\n\tif (beamforming_info->beamformee_mu_cnt > 0) {\n\t\t/*@MU STAs share the common setting*/\n\t\todm_set_bb_reg(dm, REG_BB_TXBF_ANT_SET_BF1_8822B, BIT(31), 1);\n\t\todm_set_bb_reg(dm, REG_BB_TXBF_ANT_SET_BF1_8822B, 0xffff, 0x0433);\n\t\todm_set_bb_reg(dm, REG_BB_TX_PATH_SEL_1_8822B, 0xfff00000, 0x043);\n\t}\n#endif\n}", "path": "rtl8821ce/hal/phydm/txbf/haltxbf8822b.c", "commit_date": "2019-08-05 00:00:00", "repo_name": "tomaspinho/rtl8821ce", "stars": 1531, "license": "other", "language": "c", "size": 6039}
{"docstring": "/**\n * rtw_halmac_get_mac_address() - Get MAC address of specific port\n * @d:\t\tstruct dvobj_priv*\n * @hwport:\tport\n * @addr:\tbuffer for storing MAC address\n *\n * Get MAC address of specific port from HALMAC.\n *\n * Rteurn 0 for OK, otherwise fail.\n */\n", "func_signal": "int rtw_halmac_get_mac_address(struct dvobj_priv *d, enum _hw_port hwport, u8 *addr)", "code": "{\n\tstruct halmac_adapter *halmac;\n\tstruct halmac_api *api;\n\tenum halmac_portid port;\n\tunion halmac_wlan_addr hwa;\n\tenum halmac_ret_status status;\n\tint err = -1;\n\n\n\tif (!addr)\n\t\tgoto out;\n\n\thalmac = dvobj_to_halmac(d);\n\tapi = HALMAC_GET_API(halmac);\n\tport = _hw_port_drv2halmac(hwport);\n\t_rtw_memset(&hwa, 0, sizeof(hwa));\n\n\tstatus = api->halmac_get_mac_addr(halmac, port, &hwa);\n\tif (status != HALMAC_RET_SUCCESS)\n\t\tgoto out;\n\n\t_rtw_memcpy(addr, hwa.addr, 6);\n\n\terr = 0;\nout:\n\treturn err;\n}", "path": "rtl8821ce/hal/hal_halmac.c", "commit_date": "2019-10-22 00:00:00", "repo_name": "tomaspinho/rtl8821ce", "stars": 1531, "license": "other", "language": "c", "size": 6039}
{"docstring": "/**\n * rtw_halmac_set_bcn_interval() - Set beacon interval of each port\n * @d:\t\tstruct dvobj_priv*\n * @hwport:\tport\n * @space:\tbeacon interval, unit is ms\n *\n * Set beacon interval of specific port to HALMAC.\n *\n * Rteurn 0 for OK, otherwise fail.\n */\n", "func_signal": "int rtw_halmac_set_bcn_interval(struct dvobj_priv *d, enum _hw_port hwport,\n\t\t\t\tu32 interval)", "code": "{\n\tstruct halmac_adapter *halmac;\n\tstruct halmac_api *api;\n\tenum halmac_portid port;\n\tenum halmac_ret_status status;\n\tint err = -1;\n\n\n\thalmac = dvobj_to_halmac(d);\n\tapi = HALMAC_GET_API(halmac);\n\tport = _hw_port_drv2halmac(hwport);\n\n\tstatus = api->halmac_cfg_bcn_space(halmac, port, interval);\n\tif (status != HALMAC_RET_SUCCESS)\n\t\tgoto out;\n\n\terr = 0;\nout:\n\treturn err;\n}", "path": "rtl8821ce/hal/hal_halmac.c", "commit_date": "2019-10-22 00:00:00", "repo_name": "tomaspinho/rtl8821ce", "stars": 1531, "license": "other", "language": "c", "size": 6039}
{"docstring": "/**\n * rtw_halmac_send_h2c() - Send H2C to firmware\n * @d:\t\tstruct dvobj_priv*\n * @h2c:\tH2C data buffer, suppose to be 8 bytes\n *\n * Send H2C to firmware by message box register(0x1D0~0x1D3 & 0x1F0~0x1F3).\n *\n * Assume firmware be ready to accept H2C here, please check\n * (hal->bFWReady == _TRUE) before call this function or make sure firmware is\n * ready.\n *\n * Return: 0 if process OK, otherwise fail to send this H2C.\n */\n", "func_signal": "int rtw_halmac_send_h2c(struct dvobj_priv *d, u8 *h2c)", "code": "{\n\tPADAPTER adapter = dvobj_get_primary_adapter(d);\n\tPHAL_DATA_TYPE hal = GET_HAL_DATA(adapter);\n\tu8 h2c_box_num = 0;\n\tu32 msgbox_addr = 0;\n\tu32 msgbox_ex_addr = 0;\n\tu32 h2c_cmd = 0;\n\tu32 h2c_cmd_ex = 0;\n\tint err = -1;\n\n\n\tif (!h2c) {\n\t\tRTW_WARN(\"%s: pbuf is NULL\\n\", __FUNCTION__);\n\t\treturn err;\n\t}\n\n\tif (rtw_is_surprise_removed(adapter)) {\n\t\tRTW_WARN(\"%s: surprise removed\\n\", __FUNCTION__);\n\t\treturn err;\n\t}\n\n\t_enter_critical_mutex(&d->h2c_fwcmd_mutex, NULL);\n\n\t/* pay attention to if race condition happened in H2C cmd setting */\n\th2c_box_num = hal->LastHMEBoxNum;\n\n\tif (!_is_fw_read_cmd_down(adapter, h2c_box_num)) {\n\t\tRTW_WARN(\" fw read cmd failed...\\n\");\n#ifdef DBG_CONFIG_ERROR_DETECT\n\t\thal->srestpriv.self_dect_fw = _TRUE;\n\t\thal->srestpriv.self_dect_fw_cnt++;\n#endif /* DBG_CONFIG_ERROR_DETECT */\n\t\tgoto exit;\n\t}\n\n\t/* Write Ext command (byte 4~7) */\n\tmsgbox_ex_addr = REG_HMEBOX_E0 + (h2c_box_num * EX_MESSAGE_BOX_SIZE);\n\t_rtw_memcpy((u8 *)(&h2c_cmd_ex), h2c + 4, EX_MESSAGE_BOX_SIZE);\n\th2c_cmd_ex = le32_to_cpu(h2c_cmd_ex);\n\trtw_write32(adapter, msgbox_ex_addr, h2c_cmd_ex);\n\n\t/* Write command (byte 0~3) */\n\tmsgbox_addr = REG_HMEBOX0 + (h2c_box_num * MESSAGE_BOX_SIZE);\n\t_rtw_memcpy((u8 *)(&h2c_cmd), h2c, 4);\n\th2c_cmd = le32_to_cpu(h2c_cmd);\n\trtw_write32(adapter, msgbox_addr, h2c_cmd);\n\n\t/* update last msg box number */\n\thal->LastHMEBoxNum = (h2c_box_num + 1) % MAX_H2C_BOX_NUMS;\n\terr = 0;\n\n#ifdef DBG_H2C_CONTENT\n\tRTW_INFO_DUMP(\"[H2C] - \", h2c, RTW_HALMAC_H2C_MAX_SIZE);\n#endif\nexit:\n\t_exit_critical_mutex(&d->h2c_fwcmd_mutex, NULL);\n\treturn err;\n}", "path": "rtl8821ce/hal/hal_halmac.c", "commit_date": "2019-10-22 00:00:00", "repo_name": "tomaspinho/rtl8821ce", "stars": 1531, "license": "other", "language": "c", "size": 6039}
{"docstring": "/*\n * Notices:\n *\tMake sure\n *\t1. rtw_hal_get_hwreg(HW_VAR_RF_TYPE)\n *\t2. HAL_DATA_TYPE.rfe_type\n *\talready ready for use before calling this function.\n */\n", "func_signal": "static int _halmac_init_hal(struct dvobj_priv *d, u8 *fw, u32 fwsize)", "code": "{\n\tPADAPTER adapter;\n\tstruct halmac_adapter *halmac;\n\tstruct halmac_api *api;\n\tenum halmac_ret_status status;\n\tu32 ok;\n\tu8 fw_ok = _FALSE;\n\tint err, err_ret = -1;\n\n\n\tadapter = dvobj_get_primary_adapter(d);\n\thalmac = dvobj_to_halmac(d);\n\tif (!halmac)\n\t\tgoto out;\n\tapi = HALMAC_GET_API(halmac);\n\n\t/* StatePowerOff */\n\n\t/* SKIP: halmac_init_adapter (Already done before) */\n\n\t/* halmac_pre_Init_system_cfg */\n\t/* halmac_mac_power_switch(on) */\n\t/* halmac_Init_system_cfg */\n\tok = rtw_hal_power_on(adapter);\n\tif (_FAIL == ok)\n\t\tgoto out;\n\n\t/* StatePowerOn */\n\n\t/* DownloadFW */\n\tif (fw && fwsize) {\n\t\terr = download_fw(d, fw, fwsize, 0);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tfw_ok = _TRUE;\n\t}\n\n\t/* InitMACFlow */\n\terr = init_mac_flow(d);\n\tif (err)\n\t\tgoto out;\n\n\t/* Driver insert flow: Enable TR/RX */\n\terr = _drv_enable_trx(d);\n\tif (err)\n\t\tgoto out;\n\n\t/* halmac_send_general_info */\n\tif (_TRUE == fw_ok) {\n\t\terr = _send_general_info(d);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\t/* Init Phy parameter-MAC */\n\tok = rtw_hal_init_mac_register(adapter);\n\tif (_FALSE == ok)\n\t\tgoto out;\n\n\t/* StateMacInitialized */\n\n\t/* halmac_cfg_drv_info */\n\terr = rtw_halmac_config_rx_info(d, HALMAC_DRV_INFO_PHY_STATUS);\n\tif (err)\n\t\tgoto out;\n\n\t/* halmac_set_hw_value(HALMAC_HW_EN_BB_RF) */\n\t/* Init BB, RF */\n\tok = rtw_hal_init_phy(adapter);\n\tif (_FALSE == ok)\n\t\tgoto out;\n\n\tstatus = api->halmac_init_interface_cfg(halmac);\n\tif (status != HALMAC_RET_SUCCESS)\n\t\tgoto out;\n\n\t/* SKIP: halmac_verify_platform_api */\n\t/* SKIP: halmac_h2c_lb */\n\n\t/* StateRxIdle */\n\n\terr_ret = 0;\nout:\n\treturn err_ret;\n}", "path": "rtl8821ce/hal/hal_halmac.c", "commit_date": "2019-10-22 00:00:00", "repo_name": "tomaspinho/rtl8821ce", "stars": 1531, "license": "other", "language": "c", "size": 6039}
{"docstring": "/**\n * rtw_halmac_set_bcn_ctrl() - Set beacon control setting of each port\n * @d:\t\tstruct dvobj_priv*\n * @hwport:\tport\n * @bcn_ctrl:\tsetting of beacon control\n *\n * Set beacon control setting of specific port to HALMAC.\n *\n * Rteurn 0 for OK, otherwise fail.\n */\n", "func_signal": "int rtw_halmac_set_bcn_ctrl(struct dvobj_priv *d, enum _hw_port hwport,\n\t\t\tstruct rtw_halmac_bcn_ctrl *bcn_ctrl)", "code": "{\n\tstruct halmac_adapter *halmac;\n\tstruct halmac_api *api;\n\tenum halmac_portid port;\n\tstruct halmac_bcn_ctrl ctrl;\n\tenum halmac_ret_status status;\n\tint err = -1;\n\n\n\thalmac = dvobj_to_halmac(d);\n\tapi = HALMAC_GET_API(halmac);\n\tport = _hw_port_drv2halmac(hwport);\n\t_rtw_memset(&ctrl, 0, sizeof(ctrl));\n\t_beacon_ctrl_drv2halmac(bcn_ctrl, &ctrl);\n\n\tstatus = api->halmac_rw_bcn_ctrl(halmac, port, 1, &ctrl);\n\tif (status != HALMAC_RET_SUCCESS)\n\t\tgoto out;\n\n\terr = 0;\nout:\n\treturn err;\n}", "path": "rtl8821ce/hal/hal_halmac.c", "commit_date": "2019-10-22 00:00:00", "repo_name": "tomaspinho/rtl8821ce", "stars": 1531, "license": "other", "language": "c", "size": 6039}
{"docstring": "/**\n * halmac_init_h2c_8821c() - config h2c packet buffer\n * @pHalmac_adapter : the adapter of halmac\n * Author : KaiYuan Chang/Ivan Lin\n * Return : HALMAC_RET_STATUS\n * More details of status code can be found in prototype document\n */\n", "func_signal": "HALMAC_RET_STATUS\nhalmac_init_h2c_8821c(\n\tIN PHALMAC_ADAPTER pHalmac_adapter\n)", "code": "{\n\tu8 value8;\n\tu32 value32;\n\tVOID *pDriver_adapter = NULL;\n\tPHALMAC_API pHalmac_api;\n\n\tif (HALMAC_RET_SUCCESS != halmac_adapter_validate(pHalmac_adapter))\n\t\treturn HALMAC_RET_ADAPTER_INVALID;\n\n\tif (HALMAC_RET_SUCCESS != halmac_api_validate(pHalmac_adapter))\n\t\treturn HALMAC_RET_API_INVALID;\n\n\tpDriver_adapter = pHalmac_adapter->pDriver_adapter;\n\tpHalmac_api = (PHALMAC_API)pHalmac_adapter->pHalmac_api;\n\n\tvalue8 = 0;\n\tHALMAC_REG_WRITE_8(pHalmac_adapter, REG_CR, value8);\n\tvalue8 = HALMAC_CR_TRX_ENABLE_8821C;\n\tHALMAC_REG_WRITE_8(pHalmac_adapter, REG_CR, value8);\n\n\tvalue32 = HALMAC_REG_READ_32(pHalmac_adapter, REG_H2C_HEAD);\n\t/* value32 = (value32 & 0xFFFC0000) | HALMAC_RSVD_H2C_QUEUE_BOUNDARY_8821C; */\n\tvalue32 = (value32 & 0xFFFC0000) | (pHalmac_adapter->txff_allocation.rsvd_h2c_queue_pg_bndy << HALMAC_TX_PAGE_SIZE_2_POWER_8821C);\n\tHALMAC_REG_WRITE_32(pHalmac_adapter, REG_H2C_HEAD, value32);\n\n\tvalue32 = HALMAC_REG_READ_32(pHalmac_adapter, REG_H2C_READ_ADDR);\n\t/* value32 = (value32 & 0xFFFC0000) | HALMAC_RSVD_H2C_QUEUE_BOUNDARY_8821C; */\n\tvalue32 = (value32 & 0xFFFC0000) | (pHalmac_adapter->txff_allocation.rsvd_h2c_queue_pg_bndy << HALMAC_TX_PAGE_SIZE_2_POWER_8821C);\n\tHALMAC_REG_WRITE_32(pHalmac_adapter, REG_H2C_READ_ADDR, value32);\n\n\tvalue32 = HALMAC_REG_READ_32(pHalmac_adapter, REG_H2C_TAIL);\n\t/* value32 = (value32 & 0xFFFC0000) | (HALMAC_RSVD_H2C_QUEUE_BOUNDARY_8821C + HALMAC_RSVD_H2C_QUEUE_SIZE_8821C); */\n\tvalue32 = (value32 & 0xFFFC0000) | ((pHalmac_adapter->txff_allocation.rsvd_h2c_queue_pg_bndy << HALMAC_TX_PAGE_SIZE_2_POWER_8821C) + (HALMAC_RSVD_H2C_QUEUE_PGNUM_8821C << HALMAC_TX_PAGE_SIZE_2_POWER_8821C));\n\tHALMAC_REG_WRITE_32(pHalmac_adapter, REG_H2C_TAIL, value32);\n\tvalue8 = HALMAC_REG_READ_8(pHalmac_adapter, REG_H2C_INFO);\n\tvalue8 = (u8)((value8 & 0xFC) | 0x01);\n\tHALMAC_REG_WRITE_8(pHalmac_adapter, REG_H2C_INFO, value8);\n\n\tvalue8 = HALMAC_REG_READ_8(pHalmac_adapter, REG_H2C_INFO);\n\tvalue8 = (u8)((value8 & 0xFB) | 0x04);\n\tHALMAC_REG_WRITE_8(pHalmac_adapter, REG_H2C_INFO, value8);\n\n\tvalue8 = HALMAC_REG_READ_8(pHalmac_adapter, REG_TXDMA_OFFSET_CHK + 1);\n\tvalue8 = (u8)((value8 & 0x7f) | 0x80);\n\tHALMAC_REG_WRITE_8(pHalmac_adapter, REG_TXDMA_OFFSET_CHK + 1, value8);\n\n\tpHalmac_adapter->h2c_buff_size = (HALMAC_RSVD_H2C_QUEUE_PGNUM_8821C << HALMAC_TX_PAGE_SIZE_2_POWER_8821C);\n\thalmac_get_h2c_buff_free_space_88xx(pHalmac_adapter);\n\n\tif (pHalmac_adapter->h2c_buff_size != pHalmac_adapter->h2c_buf_free_space) {\n\t\tPLATFORM_MSG_PRINT(pDriver_adapter, HALMAC_MSG_INIT, HALMAC_DBG_ERR, \"get h2c free space error!\\n\");\n\t\treturn HALMAC_RET_GET_H2C_SPACE_ERR;\n\t}\n\n\tPLATFORM_MSG_PRINT(pDriver_adapter, HALMAC_MSG_INIT, HALMAC_DBG_TRACE, \"h2c free space : %d\\n\", pHalmac_adapter->h2c_buf_free_space);\n\n\treturn HALMAC_RET_SUCCESS;\n}", "path": "rtl8821ce/hal/halmac/halmac_88xx/halmac_8821c/halmac_api_8821c.c", "commit_date": "2018-02-14 00:00:00", "repo_name": "tomaspinho/rtl8821ce", "stars": 1531, "license": "other", "language": "c", "size": 6039}
{"docstring": "/**\n * rtw_halmac_set_bssid() - Set BSSID of specific port\n * @d:\t\tstruct dvobj_priv*\n * @hwport:\tport\n * @addr:\tBSSID, mac address of AP\n *\n * Set BSSID of specific port to HALMAC.\n *\n * Rteurn 0 for OK, otherwise fail.\n */\n", "func_signal": "int rtw_halmac_set_bssid(struct dvobj_priv *d, enum _hw_port hwport, u8 *addr)", "code": "{\n\tstruct halmac_adapter *halmac;\n\tstruct halmac_api *api;\n\tenum halmac_portid port;\n\tunion halmac_wlan_addr hwa;\n\tenum halmac_ret_status status;\n\tint err = -1;\n\n\n\thalmac = dvobj_to_halmac(d);\n\tapi = HALMAC_GET_API(halmac);\n\tport = _hw_port_drv2halmac(hwport);\n\n\t_rtw_memset(&hwa, 0, sizeof(hwa));\n\t_rtw_memcpy(hwa.addr, addr, 6);\n\tstatus = api->halmac_cfg_bssid(halmac, port, &hwa);\n\tif (status != HALMAC_RET_SUCCESS)\n\t\tgoto out;\n\n\terr = 0;\nout:\n\treturn err;\n}", "path": "rtl8821ce/hal/hal_halmac.c", "commit_date": "2019-10-22 00:00:00", "repo_name": "tomaspinho/rtl8821ce", "stars": 1531, "license": "other", "language": "c", "size": 6039}
{"docstring": "/*\n * _cpu_sleep() - Let IC CPU enter sleep mode\n * @d:\t\tstruct dvobj_priv*\n * @timeout:\ttime limit of wait, unit is ms\n *\t\t0 for no limit\n *\n * Rteurn 0 for CPU in sleep mode, otherwise fail to enter sleep mode.\n * Error codes definition are as follow:\n * \t-1\tHALMAC enter sleep return fail\n *\t-2\tHALMAC get CPU mode return fail\n *\t-110\ttimeout\n */\n", "func_signal": "static int _cpu_sleep(struct dvobj_priv *d, u32 timeout)", "code": "{\n\tstruct halmac_adapter *mac;\n\tstruct halmac_api *api;\n\tenum halmac_ret_status status;\n\tenum halmac_wlcpu_mode mode = HALMAC_WLCPU_UNDEFINE;\n\tsystime start_t;\n\ts32 period = 0;\n\tu32 cnt = 0;\n\tint err = 0;\n\n\n\tmac = dvobj_to_halmac(d);\n\tapi = HALMAC_GET_API(mac);\n\n\tstart_t = rtw_get_current_time();\n\n\tstatus = _enter_cpu_sleep_mode(d);\n\tif (status != HALMAC_RET_SUCCESS) {\n\t\tif (status != HALMAC_RET_NOT_SUPPORT)\n\t\t\terr = -1;\n\t\tgoto exit;\n\t}\n\n\tdo {\n\t\tcnt++;\n\n\t\tmode = HALMAC_WLCPU_UNDEFINE;\n\t\tstatus = api->halmac_get_cpu_mode(mac, &mode);\n\n\t\tperiod = rtw_get_passing_time_ms(start_t);\n\n\t\tif (status != HALMAC_RET_SUCCESS) {\n\t\t\terr = -2;\n\t\t\tbreak;\n\t\t}\n\t\tif (mode == HALMAC_WLCPU_SLEEP)\n\t\t\tbreak;\n\t\tif (period > timeout) {\n\t\t\terr = -110;\n\t\t\tbreak;\n\t\t}\n\n\t\trtw_msleep_os(1);\n\t} while (1);\n\nexit:\n\tif (err)\n\t\tRTW_ERR(\"%s: Fail to enter sleep mode! (%d, %d)\\n\",\n\t\t\t__FUNCTION__, status, mode);\n\n\tRTW_INFO(\"%s: Cost %dms to polling %u times. (err=%d)\\n\",\n\t\t__FUNCTION__, period, cnt, err);\n\n\treturn err;\n}", "path": "rtl8821ce/hal/hal_halmac.c", "commit_date": "2019-10-22 00:00:00", "repo_name": "tomaspinho/rtl8821ce", "stars": 1531, "license": "other", "language": "c", "size": 6039}
{"docstring": "/* CONFIG_RTW_MACADDR_ACL */\n", "func_signal": "bool rtw_is_pre_link_sta(struct sta_priv *stapriv, u8 *addr)", "code": "{\n#if CONFIG_RTW_PRE_LINK_STA\n\tstruct pre_link_sta_ctl_t *pre_link_sta_ctl = &stapriv->pre_link_sta_ctl;\n\tstruct sta_info *sta = NULL;\n\tu8 exist = _FALSE;\n\tint i;\n\t_irqL irqL;\n\n\t_enter_critical_bh(&(pre_link_sta_ctl->lock), &irqL);\n\tfor (i = 0; i < RTW_PRE_LINK_STA_NUM; i++) {\n\t\tif (pre_link_sta_ctl->node[i].valid == _TRUE\n\t\t\t&& _rtw_memcmp(pre_link_sta_ctl->node[i].addr, addr, ETH_ALEN) == _TRUE\n\t\t) {\n\t\t\texist = _TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\t_exit_critical_bh(&(pre_link_sta_ctl->lock), &irqL);\n\n\treturn exist;\n#else\n\treturn _FALSE;\n#endif\n}", "path": "rtl8821ce/core/rtw_sta_mgt.c", "commit_date": "2019-08-05 00:00:00", "repo_name": "tomaspinho/rtl8821ce", "stars": 1531, "license": "other", "language": "c", "size": 6039}
{"docstring": "/*\n * Description:\n *\tPower off device hardware.\n *\n * Return:\n *\t0\tPower off success\n *\t-1\tPower off fail\n */\n", "func_signal": "int rtw_halmac_poweroff(struct dvobj_priv *d)", "code": "{\n\tstruct halmac_adapter *halmac;\n\tstruct halmac_api *api;\n\tenum halmac_ret_status status;\n\tint err = -1;\n\n\n\thalmac = dvobj_to_halmac(d);\n\tif (!halmac)\n\t\tgoto out;\n\n\tapi = HALMAC_GET_API(halmac);\n\n\tstatus = _power_switch(halmac, api, HALMAC_MAC_POWER_OFF);\n\tif ((HALMAC_RET_SUCCESS != status)\n\t    && (HALMAC_RET_PWR_UNCHANGE != status))\n\t\tgoto out;\n\n\terr = 0;\nout:\n\treturn err;\n}", "path": "rtl8821ce/hal/hal_halmac.c", "commit_date": "2019-10-22 00:00:00", "repo_name": "tomaspinho/rtl8821ce", "stars": 1531, "license": "other", "language": "c", "size": 6039}
{"docstring": "/**\n * rtw_halmac_get_rx_agg_align_size() - RX aggregation align size\n * @d:\t\tstruct dvobj_priv*\n * @size:\tRX aggregation align size, unit is byte\n *\n * Get RX aggregation align size(byte) from HALMAC.\n *\n * Rteurn 0 for OK, otherwise fail.\n */\n", "func_signal": "int rtw_halmac_get_rx_agg_align_size(struct dvobj_priv *d, u8 *size)", "code": "{\n\tstruct halmac_adapter *halmac;\n\tstruct halmac_api *api;\n\tenum halmac_ret_status status;\n\tu8 val = 0;\n\n\n\thalmac = dvobj_to_halmac(d);\n\tapi = HALMAC_GET_API(halmac);\n\n\tstatus = api->halmac_get_hw_value(halmac, HALMAC_HW_RX_AGG_ALIGN_SIZE, &val);\n\tif (status != HALMAC_RET_SUCCESS)\n\t\treturn -1;\n\n\t*size = val;\n\n\treturn 0;\n}", "path": "rtl8821ce/hal/hal_halmac.c", "commit_date": "2019-10-22 00:00:00", "repo_name": "tomaspinho/rtl8821ce", "stars": 1531, "license": "other", "language": "c", "size": 6039}
{"docstring": "/* return true if command timed out else false */\n", "func_signal": "static bool wait_for_bios_cmd_cpl(pci_devfn_t dev, uint32_t reg, uint32_t mask,\n\tuint32_t target)", "code": "{\n\tconst uint32_t max_delay = 5000; /* 5 seconds max */\n\tconst uint32_t step_delay = 50; /* 50 us */\n\tstruct stopwatch sw;\n\n\tstopwatch_init_msecs_expire(&sw, max_delay);\n\twhile ((pci_s_read_config32(dev, reg) & mask) != target) {\n\t\tudelay(step_delay);\n\t\tif (stopwatch_expired(&sw)) {\n\t\t\tprintk(BIOS_ERR, \"%s timed out for dev: %x, reg: 0x%x, \"\n\t\t\t\t\"mask: 0x%x, target: 0x%x\\n\", __func__, dev, reg, mask, target);\n\t\t\treturn true; /* timedout */\n\t\t}\n\t}\n\treturn false; /* successful */\n}", "path": "coreboot/src/soc/intel/xeon_sp/util.c", "commit_date": "2020-11-13 00:00:00", "repo_name": "coreboot/coreboot", "stars": 2032, "license": "gpl-2.0", "language": "c", "size": 235364}
{"docstring": "/* Get ME Firmware Capabilities */\n", "func_signal": "int mkhi_get_fwcaps(void)", "code": "{\n\tstruct {\n\t\tuint32_t rule_id;\n\t\tuint32_t rule_len;\n\n\t\tstruct me_fwcaps cap;\n\t} fwcaps;\n\n\tfwcaps.rule_id = 0;\n\tfwcaps.rule_len = 0;\n\n\tstruct mkhi_header mkhi = {\n\t\t.group_id\t= MKHI_GROUP_ID_FWCAPS,\n\t\t.command\t= MKHI_FWCAPS_GET_RULE,\n\t\t.is_response\t= 0,\n\t};\n\tstruct mei_header mei = {\n\t\t.is_complete\t= 1,\n\t\t.host_address\t= MEI_HOST_ADDRESS,\n\t\t.client_address\t= MEI_ADDRESS_MKHI,\n\t\t.length\t\t= sizeof(mkhi) + sizeof(fwcaps.rule_id),\n\t};\n\n\t/* Send request and wait for response */\n\tif (mei_sendrecv(&mei, &mkhi, &fwcaps.rule_id, &fwcaps.cap, sizeof(fwcaps.cap)) < 0) {\n\t\tprintf(\"ME: GET FWCAPS message failed\\n\");\n\t\treturn -1;\n\t}\n\n\tprint_cap(\"Full Network manageability                \", fwcaps.cap.caps_sku.full_net);\n\tprint_cap(\"Regular Network manageability             \", fwcaps.cap.caps_sku.std_net);\n\tprint_cap(\"Manageability                             \", fwcaps.cap.caps_sku.manageability);\n\tprint_cap(\"Small business technology                 \", fwcaps.cap.caps_sku.small_business);\n\tprint_cap(\"Level III manageability                   \", fwcaps.cap.caps_sku.l3manageability);\n\tprint_cap(\"IntelR Anti-Theft (AT)                    \", fwcaps.cap.caps_sku.intel_at);\n\tprint_cap(\"IntelR Capability Licensing Service (CLS) \", fwcaps.cap.caps_sku.intel_cls);\n\tprint_cap(\"IntelR Power Sharing Technology (MPC)     \", fwcaps.cap.caps_sku.intel_mpc);\n\tprint_cap(\"ICC Over Clocking                         \", fwcaps.cap.caps_sku.icc_over_clocking);\n\tprint_cap(\"Protected Audio Video Path (PAVP)         \", fwcaps.cap.caps_sku.pavp);\n\tprint_cap(\"IPV6                                      \", fwcaps.cap.caps_sku.ipv6);\n\tprint_cap(\"KVM Remote Control (KVM)                  \", fwcaps.cap.caps_sku.kvm);\n\tprint_cap(\"Outbreak Containment Heuristic (OCH)      \", fwcaps.cap.caps_sku.och);\n\tprint_cap(\"Virtual LAN (VLAN)                        \", fwcaps.cap.caps_sku.vlan);\n\tprint_cap(\"TLS                                       \", fwcaps.cap.caps_sku.tls);\n\tprint_cap(\"Wireless LAN (WLAN)                       \", fwcaps.cap.caps_sku.wlan);\n\n\treturn 0;\n}", "path": "coreboot/util/intelmetool/me.c", "commit_date": "2020-09-23 00:00:00", "repo_name": "coreboot/coreboot", "stars": 2032, "license": "gpl-2.0", "language": "c", "size": 235364}
{"docstring": "/* Get ME firmware version */\n", "func_signal": "int mkhi_get_fw_version(int *major, int *minor)", "code": "{\n\tuint32_t data = 0;\n\tstruct me_fw_version version = {0};\n\n\tstruct mkhi_header mkhi = {\n\t\t.group_id\t= MKHI_GROUP_ID_GEN,\n\t\t.command\t= GEN_GET_FW_VERSION,\n\t\t.is_response \t= 0,\n\t};\n\n\tstruct mei_header mei = {\n\t\t.is_complete\t= 1,\n\t\t.host_address\t= MEI_HOST_ADDRESS,\n\t\t.client_address\t= MEI_ADDRESS_MKHI,\n\t\t.length\t\t= sizeof(mkhi),\n\t};\n\n#ifndef OLDARC\n\t/* Send request and wait for response */\n\tif (mei_sendrecv(&mei, &mkhi, &data, &version, sizeof(version) ) < 0) {\n\t\tprintf(\"ME: GET FW VERSION message failed\\n\");\n\t\treturn -1;\n\t}\n\tprintf(\"ME: Firmware Version %u.%u.%u.%u (code) \"\n\t       \"%u.%u.%u.%u (recovery) \"\n\t       \"%u.%u.%u.%u (fitc)\\n\\n\",\n\t       version.code_major, version.code_minor,\n\t       version.code_build_number, version.code_hot_fix,\n\t       version.recovery_major, version.recovery_minor,\n\t       version.recovery_build_number, version.recovery_hot_fix,\n\t       version.fitcmajor, version.fitcminor,\n\t       version.fitcbuildno, version.fitchotfix);\n#else\n\t/* Send request and wait for response */\n\tif (mei_sendrecv(&mei, &mkhi, &data, &version, 2*sizeof(uint32_t) ) < 0) {\n\t\tprintf(\"ME: GET FW VERSION message failed\\n\");\n\t\treturn -1;\n\t}\n\tprintf(\"ME: Firmware Version %u.%u (code)\\n\\n\",\n\t       version.code_major, version.code_minor);\n#endif\n\tif (major)\n\t\t*major = version.code_major;\n\tif (minor)\n\t\t*minor = version.code_minor;\n\treturn 0;\n}", "path": "coreboot/util/intelmetool/me.c", "commit_date": "2020-09-23 00:00:00", "repo_name": "coreboot/coreboot", "stars": 2032, "license": "gpl-2.0", "language": "c", "size": 235364}
{"docstring": "/*\n * ME/MEI access helpers using memcpy to avoid aliasing.\n */\n", "func_signal": "static inline void mei_read_dword_ptr(void *ptr, uint32_t offset)", "code": "{\n\tuint32_t dword = read32(mei_mmap, offset);\n\tmemcpy(ptr, &dword, sizeof(dword));\n\n\tif (debug) {\n\t\tmei_dump(ptr, dword, offset, \"READ\");\n\t}\n}", "path": "coreboot/util/intelmetool/me.c", "commit_date": "2020-09-23 00:00:00", "repo_name": "coreboot/coreboot", "stars": 2032, "license": "gpl-2.0", "language": "c", "size": 235364}
{"docstring": "/* Wait for ME ready bit to be asserted */\n", "func_signal": "static int mei_wait_for_me_ready(void)", "code": "{\n\tstruct mei_csr me;\n\tunsigned try = ME_RETRY;\n\n\twhile (try--) {\n\t\tread_me_csr(&me);\n\t\tif (me.ready)\n\t\t\treturn 0;\n\t\tusleep(ME_DELAY);\n\t}\n\n\tprintf(\"ME: failed to become ready\\n\");\n\treturn -1;\n}", "path": "coreboot/util/intelmetool/me.c", "commit_date": "2020-09-23 00:00:00", "repo_name": "coreboot/coreboot", "stars": 2032, "license": "gpl-2.0", "language": "c", "size": 235364}
{"docstring": "/* read one intr-packet from queue, if available. extend the queue for new input.\n   return NULL if nothing new available.\n   Recommended use: while (data=poll_intr_queue(q)) process(data);\n */\n", "func_signal": "static u8 *\nxhci_poll_intr_queue(void *const q)", "code": "{\n\tif (!q)\n\t\treturn NULL;\n\n\tintrq_t *const intrq = (intrq_t *)q;\n\tendpoint_t *const ep = intrq->ep;\n\txhci_t *const xhci = XHCI_INST(ep->dev->controller);\n\n\t/* TODO: Reset interrupt queue if it gets halted? */\n\n\txhci_handle_events(xhci);\n\n\tu8 *reqdata = NULL;\n\twhile (!reqdata && intrq->ready) {\n\t\tconst int ep_id = xhci_ep_id(ep);\n\t\ttransfer_ring_t *const tr =\n\t\t\txhci->dev[ep->dev->address].transfer_rings[ep_id];\n\n\t\t/* Fetch the request's buffer */\n\t\treqdata = phys_to_virt(intrq->next->ptr_low);\n\n\t\t/* Enqueue the last (spare) TRB and ring doorbell */\n\t\txhci_enqueue_trb(tr);\n\t\txhci_ring_doorbell(ep);\n\n\t\t/* Reuse the current buffer for the next spare TRB */\n\t\txhci_clear_trb(tr->cur, tr->pcs);\n\t\ttr->cur->ptr_low = virt_to_phys(reqdata);\n\t\ttr->cur->ptr_high = 0;\n\t\tTRB_SET(TL,\ttr->cur, intrq->size);\n\t\tTRB_SET(TT,\ttr->cur, TRB_NORMAL);\n\t\tTRB_SET(ISP,\ttr->cur, 1);\n\t\tTRB_SET(IOC,\ttr->cur, 1);\n\n\t\t/* Check if anything was transferred */\n\t\tconst size_t read = TRB_GET(TL, intrq->next);\n\t\tif (!read)\n\t\t\treqdata = NULL;\n\t\telse if (read < intrq->size)\n\t\t\t/* At least zero it, poll interface is rather limited */\n\t\t\tmemset(reqdata + read, 0x00, intrq->size - read);\n\n\t\t/* Advance the interrupt queue */\n\t\tif (intrq->ready == intrq->next)\n\t\t\t/* This was last TRB being ready */\n\t\t\tintrq->ready = NULL;\n\t\tintrq->next = xhci_next_trb(intrq->next, NULL);\n\t}\n\n\treturn reqdata;\n}", "path": "coreboot/payloads/libpayload/drivers/usb/xhci.c", "commit_date": "2020-11-22 00:00:00", "repo_name": "coreboot/coreboot", "stars": 2032, "license": "gpl-2.0", "language": "c", "size": 235364}
{"docstring": "/* Mark the block with length 'len' as used */\n", "func_signal": "static void use_block(hdrtype_t volatile *ptr, int len)", "code": "{\n\t/* Align the size. */\n\tlen = ALIGN_UP(len, HDRSIZE);\n\n\thdrtype_t volatile *nptr = (hdrtype_t volatile *)\n\t\t((uintptr_t)ptr + HDRSIZE + len);\n\tint size = SIZE(*ptr);\n\tint nsize = size - (HDRSIZE + len);\n\n\t/*\n\t * If there is still room in this block, then mark it as such otherwise\n\t * account the whole space for that block.\n\t */\n\tif (nsize > 0) {\n\t\t/* Mark the block as used. */\n\t\t*ptr = USED_BLOCK(len);\n\n\t\t/* Create a new free block. */\n\t\t*nptr = FREE_BLOCK(nsize);\n\t} else {\n\t\t/* Mark the block as used. */\n\t\t*ptr = USED_BLOCK(size);\n\t}\n}", "path": "coreboot/payloads/libpayload/libc/malloc.c", "commit_date": "2020-09-19 00:00:00", "repo_name": "coreboot/coreboot", "stars": 2032, "license": "gpl-2.0", "language": "c", "size": 235364}
{"docstring": "/* finalize == 1: if data is of packet aligned size, add a zero length packet */\n", "func_signal": "static int\nxhci_bulk(endpoint_t *const ep, const int size, u8 *const src,\n\t  const int finalize)", "code": "{\n\t/* finalize: Hopefully the xHCI controller always does this.\n\t\t     We have no control over the packets. */\n\n\tu8 *data = src;\n\txhci_t *const xhci = XHCI_INST(ep->dev->controller);\n\tconst int slot_id = ep->dev->address;\n\tconst int ep_id = xhci_ep_id(ep);\n\tepctx_t *const epctx = xhci->dev[slot_id].ctx.ep[ep_id];\n\ttransfer_ring_t *const tr = xhci->dev[slot_id].transfer_rings[ep_id];\n\n\tconst size_t off = (size_t)data & 0xffff;\n\tif ((off + size) > ((TRANSFER_RING_SIZE - 2) << 16)) {\n\t\txhci_debug(\"Unsupported transfer size\\n\");\n\t\treturn -1;\n\t}\n\n\tif (!dma_coherent(src)) {\n\t\tdata = xhci->dma_buffer;\n\t\tif (size > DMA_SIZE) {\n\t\t\txhci_debug(\"Bulk transfer too large: %d\\n\", size);\n\t\t\treturn -1;\n\t\t}\n\t\tif (ep->direction == OUT)\n\t\t\tmemcpy(data, src, size);\n\t}\n\n\t/* Reset endpoint if it's not running */\n\tconst unsigned ep_state = EC_GET(STATE, epctx);\n\tif (ep_state > 1) {\n\t\tif (xhci_reset_endpoint(ep->dev, ep))\n\t\t\treturn -1;\n\t}\n\n\t/* Enqueue transfer and ring doorbell */\n\tconst unsigned mps = EC_GET(MPS, epctx);\n\tconst unsigned dir = (ep->direction == OUT) ? TRB_DIR_OUT : TRB_DIR_IN;\n\txhci_enqueue_td(tr, ep_id, mps, size, data, dir);\n\txhci_ring_doorbell(ep);\n\n\t/* Wait for transfer event */\n\tconst int ret = xhci_wait_for_transfer(xhci, ep->dev->address, ep_id);\n\tif (ret < 0) {\n\t\tif (ret == TIMEOUT) {\n\t\t\txhci_debug(\"Stopping ID %d EP %d\\n\",\n\t\t\t\t   ep->dev->address, ep_id);\n\t\t\txhci_cmd_stop_endpoint(xhci, ep->dev->address, ep_id);\n\t\t}\n\t\txhci_debug(\"Bulk transfer failed: %d\\n\"\n\t\t\t   \"  ep state: %d -> %d\\n\"\n\t\t\t   \"  usbsts:   0x%08\"PRIx32\"\\n\",\n\t\t\t   ret, ep_state,\n\t\t\t   EC_GET(STATE, epctx),\n\t\t\t   xhci->opreg->usbsts);\n\t\treturn ret;\n\t}\n\n\tif (ep->direction == IN && data != src)\n\t\tmemcpy(src, data, ret);\n\treturn ret;\n}", "path": "coreboot/payloads/libpayload/drivers/usb/xhci.c", "commit_date": "2020-11-22 00:00:00", "repo_name": "coreboot/coreboot", "stars": 2032, "license": "gpl-2.0", "language": "c", "size": 235364}
{"docstring": "/* create and hook-up an intr queue into device schedule */\n", "func_signal": "static void *\nxhci_create_intr_queue(endpoint_t *const ep,\n\t\t       const int reqsize, const int reqcount,\n\t\t       const int reqtiming)", "code": "{\n\t/* reqtiming: We ignore it and use the interval from the\n\t\t      endpoint descriptor configured earlier. */\n\n\txhci_t *const xhci = XHCI_INST(ep->dev->controller);\n\tconst int slot_id = ep->dev->address;\n\tconst int ep_id = xhci_ep_id(ep);\n\ttransfer_ring_t *const tr = xhci->dev[slot_id].transfer_rings[ep_id];\n\n\tif (reqcount > (TRANSFER_RING_SIZE - 2)) {\n\t\txhci_debug(\"reqcount is too high, at most %d supported\\n\",\n\t\t\t   TRANSFER_RING_SIZE - 2);\n\t\treturn NULL;\n\t}\n\tif (reqsize > 0x10000) {\n\t\txhci_debug(\"reqsize is too large, at most 64KiB supported\\n\");\n\t\treturn NULL;\n\t}\n\tif (xhci->dev[slot_id].interrupt_queues[ep_id]) {\n\t\txhci_debug(\"Only one interrupt queue per endpoint supported\\n\");\n\t\treturn NULL;\n\t}\n\n\t/* Allocate intrq structure and reqdata chunks */\n\n\tintrq_t *const intrq = malloc(sizeof(*intrq));\n\tif (!intrq) {\n\t\txhci_debug(\"Out of memory\\n\");\n\t\treturn NULL;\n\t}\n\n\tint i;\n\tint pcs = tr->pcs;\n\ttrb_t *cur = tr->cur;\n\tfor (i = 0; i < reqcount; ++i) {\n\t\tif (TRB_GET(C, cur) == pcs) {\n\t\t\txhci_debug(\"Not enough empty TRBs\\n\");\n\t\t\tgoto _free_return;\n\t\t}\n\t\tvoid *const reqdata = xhci_align(1, reqsize);\n\t\tif (!reqdata) {\n\t\t\txhci_debug(\"Out of memory\\n\");\n\t\t\tgoto _free_return;\n\t\t}\n\t\txhci_clear_trb(cur, pcs);\n\t\tcur->ptr_low = virt_to_phys(reqdata);\n\t\tcur->ptr_high = 0;\n\t\tTRB_SET(TL,\tcur, reqsize);\n\t\tTRB_SET(TT,\tcur, TRB_NORMAL);\n\t\tTRB_SET(ISP,\tcur, 1);\n\t\tTRB_SET(IOC,\tcur, 1);\n\n\t\tcur = xhci_next_trb(cur, &pcs);\n\t}\n\n\tintrq->size\t= reqsize;\n\tintrq->count\t= reqcount;\n\tintrq->next\t= tr->cur;\n\tintrq->ready\t= NULL;\n\tintrq->ep\t= ep;\n\txhci->dev[slot_id].interrupt_queues[ep_id] = intrq;\n\n\t/* Now enqueue all the prepared TRBs but the last\n\t   and ring the doorbell. */\n\tfor (i = 0; i < (reqcount - 1); ++i)\n\t\txhci_enqueue_trb(tr);\n\txhci_ring_doorbell(ep);\n\n\treturn intrq;\n\n_free_return:\n\tcur = tr->cur;\n\tfor (--i; i >= 0; --i) {\n\t\tfree(phys_to_virt(cur->ptr_low));\n\t\tcur = xhci_next_trb(cur, NULL);\n\t}\n\tfree(intrq);\n\treturn NULL;\n}", "path": "coreboot/payloads/libpayload/drivers/usb/xhci.c", "commit_date": "2020-11-22 00:00:00", "repo_name": "coreboot/coreboot", "stars": 2032, "license": "gpl-2.0", "language": "c", "size": 235364}
{"docstring": "/* Setting devtree variables is only allowed in ramstage. */\n", "func_signal": "static void get_core_thread_bits(uint32_t *core_bits, uint32_t *thread_bits)", "code": "{\n\tregister int ecx;\n\tstruct cpuid_result cpuid_regs;\n\n\t/* get max index of CPUID */\n\tcpuid_regs = cpuid(0);\n\tassert(cpuid_regs.eax >= 0xb); /* cpuid_regs.eax is max input value for cpuid */\n\n\t*thread_bits = *core_bits = 0;\n\tecx = 0;\n\twhile (1) {\n\t\tcpuid_regs = cpuid_ext(0xb, ecx);\n\t\tif (ecx == 0) {\n\t\t\t*thread_bits = (cpuid_regs.eax & 0x1f);\n\t\t} else {\n\t\t\t*core_bits = (cpuid_regs.eax & 0x1f) - *thread_bits;\n\t\t\tbreak;\n\t\t}\n\t\tecx++;\n\t}\n}", "path": "coreboot/src/soc/intel/xeon_sp/util.c", "commit_date": "2020-11-13 00:00:00", "repo_name": "coreboot/coreboot", "stars": 2032, "license": "gpl-2.0", "language": "c", "size": 235364}
{"docstring": "/* Tell ME to issue a global reset */\n", "func_signal": "uint32_t mkhi_global_reset(void)", "code": "{\n\tstruct me_global_reset reset = {\n\t\t.request_origin\t= GLOBAL_RESET_BIOS_POST,\n\t\t.reset_type\t= CBM_RR_GLOBAL_RESET,\n\t};\n\tstruct mkhi_header mkhi = {\n\t\t.group_id\t= MKHI_GROUP_ID_CBM,\n\t\t.command\t= MKHI_GLOBAL_RESET,\n\t};\n\tstruct mei_header mei = {\n\t\t.is_complete\t= 1,\n\t\t.length\t\t= sizeof(mkhi) + sizeof(reset),\n\t\t.host_address\t= MEI_HOST_ADDRESS,\n\t\t.client_address\t= MEI_ADDRESS_MKHI,\n\t};\n\n\tprintf(\"ME: Requesting global reset\\n\");\n\n\t/* Send request and wait for response */\n\tif (mei_sendrecv(&mei, &mkhi, &reset, NULL, 0) < 0) {\n\t\t/* No response means reset will happen shortly... */\n\t\tasm(\"hlt\");\n\t}\n\n\t/* If the ME responded it rejected the reset request */\n\tprintf(\"ME: Global Reset failed\\n\");\n\treturn -1;\n}", "path": "coreboot/util/intelmetool/me.c", "commit_date": "2020-09-23 00:00:00", "repo_name": "coreboot/coreboot", "stars": 2032, "license": "gpl-2.0", "language": "c", "size": 235364}
{"docstring": "/* Find free block of size >= len */\n", "func_signal": "static hdrtype_t volatile *find_free_block(int len, struct memory_type *type)", "code": "{\n\thdrtype_t header;\n\thdrtype_t volatile *ptr = (hdrtype_t volatile *)type->start;\n\n\t/* Align the size. */\n\tlen = ALIGN_UP(len, HDRSIZE);\n\n\tif (!len || len > MAX_SIZE)\n\t\treturn (void *)NULL;\n\n\t/* Make sure the region is setup correctly. */\n\tif (!HAS_MAGIC(*ptr)) {\n\t\tsize_t size = (type->end - type->start) - HDRSIZE;\n\t\t*ptr = FREE_BLOCK(size);\n#if CONFIG(LP_DEBUG_MALLOC)\n\t\ttype->magic_initialized = 1;\n\t\ttype->minimal_free = size;\n#endif\n\t}\n\n\t/* Find some free space. */\n\tdo {\n\t\theader = *ptr;\n\t\tint size = SIZE(header);\n\n\t\tif (!HAS_MAGIC(header) || size == 0) {\n\t\t\tprintf(\"memory allocator panic. (%s%s)\\n\",\n\t\t\t       !HAS_MAGIC(header) ? \" no magic \" : \"\",\n\t\t\t\t   size == 0 ? \" size=0 \" : \"\");\n\t\t\thalt();\n\t\t}\n\n\t\tif ((header & FLAG_FREE) && len <= size)\n\t\t\treturn ptr;\n\n\t\tptr = (hdrtype_t volatile *)((uintptr_t)ptr + HDRSIZE + size);\n\n\t} while (ptr < (hdrtype_t *) type->end);\n\n\t/* Nothing available. */\n\treturn NULL;\n}", "path": "coreboot/payloads/libpayload/libc/malloc.c", "commit_date": "2020-09-19 00:00:00", "repo_name": "coreboot/coreboot", "stars": 2032, "license": "gpl-2.0", "language": "c", "size": 235364}
{"docstring": "/* Enable debug of internal ME memory */\n", "func_signal": "int mkhi_debug_me_memory(void *physaddr)", "code": "{\n\tuint32_t data = 0;\n\n\t/* copy whole ME memory to a readable space */\n\tstruct me_debug_mem memory = {\n\t\t.debug_phys = (uintptr_t)physaddr,\n\t\t.debug_size = 0x2000000,\n\t\t.me_phys = 0x20000000,\n\t\t.me_size = 0x2000000,\n\t};\n\tstruct mkhi_header mkhi = {\n\t\t.group_id\t= MKHI_GROUP_ID_GEN,\n\t\t.command\t= GEN_SET_DEBUG_MEM,\n\t\t.is_response\t= 0,\n\t};\n\tstruct mei_header mei = {\n\t\t.is_complete\t= 1,\n\t\t.length\t\t= sizeof(mkhi) + sizeof(memory),\n\t\t.host_address\t= MEI_HOST_ADDRESS,\n\t\t.client_address\t= MEI_ADDRESS_MKHI,\n\t};\n\n\tprintf(\"ME: Debug memory to 0x%zx ...\", (size_t)physaddr);\n\tif (mei_sendrecv(&mei, &mkhi, &memory, &data, 0) < 0) {\n\t\tprintf(\"failed\\n\");\n\t\treturn -1;\n\t} else {\n\t\tprintf(\"done\\n\");\n\t}\n\treturn 0;\n}", "path": "coreboot/util/intelmetool/me.c", "commit_date": "2020-09-23 00:00:00", "repo_name": "coreboot/coreboot", "stars": 2032, "license": "gpl-2.0", "language": "c", "size": 235364}
{"docstring": "/* remove queue from device schedule, dropping all data that came in */\n", "func_signal": "static void\nxhci_destroy_intr_queue(endpoint_t *const ep, void *const q)", "code": "{\n\txhci_t *const xhci = XHCI_INST(ep->dev->controller);\n\tconst int slot_id = ep->dev->address;\n\tconst int ep_id = xhci_ep_id(ep);\n\ttransfer_ring_t *const tr = xhci->dev[slot_id].transfer_rings[ep_id];\n\n\tintrq_t *const intrq = (intrq_t *)q;\n\n\t/* Make sure the endpoint is stopped */\n\tif (EC_GET(STATE, xhci->dev[slot_id].ctx.ep[ep_id]) == 1) {\n\t\tconst int cc = xhci_cmd_stop_endpoint(xhci, slot_id, ep_id);\n\t\tif (cc != CC_SUCCESS)\n\t\t\txhci_debug(\"Warning: Failed to stop endpoint\\n\");\n\t}\n\n\t/* Process all remaining transfer events */\n\txhci_handle_events(xhci);\n\n\t/* Free all pending transfers and the interrupt queue structure */\n\tint i;\n\tfor (i = 0; i < intrq->count; ++i) {\n\t\tfree(phys_to_virt(intrq->next->ptr_low));\n\t\tintrq->next = xhci_next_trb(intrq->next, NULL);\n\t}\n\txhci->dev[slot_id].interrupt_queues[ep_id] = NULL;\n\tfree((void *)intrq);\n\n\t/* Reset the controller's dequeue pointer and reinitialize the ring */\n\txhci_cmd_set_tr_dq(xhci, slot_id, ep_id, tr->ring, 1);\n\txhci_init_cycle_ring(tr, TRANSFER_RING_SIZE);\n}", "path": "coreboot/payloads/libpayload/drivers/usb/xhci.c", "commit_date": "2020-11-22 00:00:00", "repo_name": "coreboot/coreboot", "stars": 2032, "license": "gpl-2.0", "language": "c", "size": 235364}
{"docstring": "/* return true if command timed out else false */\n", "func_signal": "static bool write_bios_mailbox_cmd(pci_devfn_t dev, uint32_t command, uint32_t data)", "code": "{\n\t/* verify bios is not in busy state */\n\tif (wait_for_bios_cmd_cpl(dev, PCU_CR1_BIOS_MB_INTERFACE_REG, BIOS_MB_RUN_BUSY_MASK, 0))\n\t\treturn true; /* timed out */\n\n\t/* write data to data register */\n\tprintk(BIOS_SPEW, \"%s - pci_s_write_config32 reg: 0x%x, data: 0x%x\\n\", __func__,\n\t\tPCU_CR1_BIOS_MB_DATA_REG, data);\n\tpci_s_write_config32(dev, PCU_CR1_BIOS_MB_DATA_REG, data);\n\n\t/* write the command */\n\tprintk(BIOS_SPEW, \"%s - pci_s_write_config32 reg: 0x%x, data: 0x%lx\\n\", __func__,\n\t\tPCU_CR1_BIOS_MB_INTERFACE_REG, command | BIOS_MB_RUN_BUSY_MASK);\n\tpci_s_write_config32(dev, PCU_CR1_BIOS_MB_INTERFACE_REG,\n\t\tcommand | BIOS_MB_RUN_BUSY_MASK);\n\n\t/* wait for completion or time out*/\n\treturn wait_for_bios_cmd_cpl(dev, PCU_CR1_BIOS_MB_INTERFACE_REG,\n\t\tBIOS_MB_RUN_BUSY_MASK, 0);\n}", "path": "coreboot/src/soc/intel/xeon_sp/util.c", "commit_date": "2020-11-13 00:00:00", "repo_name": "coreboot/coreboot", "stars": 2032, "license": "gpl-2.0", "language": "c", "size": 235364}
{"docstring": "/* return true if command timed out else false */\n", "func_signal": "static bool set_bios_reset_cpl_for_package(uint32_t socket, uint32_t rst_cpl_mask,\n\tuint32_t pcode_init_mask, uint32_t val)", "code": "{\n\tconst uint32_t bus = get_socket_stack_busno(socket, PCU_IIO_STACK);\n\tconst pci_devfn_t dev = PCI_DEV(bus, PCU_DEV, PCU_CR1_FUN);\n\n\tuint32_t reg = pci_s_read_config32(dev, PCU_CR1_BIOS_RESET_CPL_REG);\n\treg &= (uint32_t) ~rst_cpl_mask;\n\treg |= val;\n\n\t/* update BIOS RESET completion bit */\n\tpci_s_write_config32(dev, PCU_CR1_BIOS_RESET_CPL_REG, reg);\n\n\t/* wait for PCU ack */\n\treturn wait_for_bios_cmd_cpl(dev, PCU_CR1_BIOS_RESET_CPL_REG, pcode_init_mask,\n\t\tpcode_init_mask);\n}", "path": "coreboot/src/soc/intel/xeon_sp/util.c", "commit_date": "2020-11-13 00:00:00", "repo_name": "coreboot/coreboot", "stars": 2032, "license": "gpl-2.0", "language": "c", "size": 235364}
{"docstring": "/* Read the Extend register hash of ME firmware */\n", "func_signal": "int intel_me_extend_valid(struct pci_dev *dev)", "code": "{\n\tstruct me_heres status;\n\tuint32_t extend[8] = {0};\n\tint i, count = 0;\n\n\tpci_read_dword_ptr(dev, &status, PCI_ME_HERES);\n\tif (!status.extend_feature_present) {\n\t\tprintf(\"ME: Extend Feature not present\\n\");\n\t\treturn -1;\n\t}\n\n\tif (!status.extend_reg_valid) {\n\t\tprintf(\"ME: Extend Register not valid\\n\");\n\t\treturn -1;\n\t}\n\n\tswitch (status.extend_reg_algorithm) {\n\tcase PCI_ME_EXT_SHA1:\n\t\tcount = 5;\n\t\tprintf(\"ME: Extend SHA-1: \");\n\t\tbreak;\n\tcase PCI_ME_EXT_SHA256:\n\t\tcount = 8;\n\t\tprintf(\"ME: Extend SHA-256: \");\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"ME: Extend Algorithm %d unknown\\n\",\n\t\t       status.extend_reg_algorithm);\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < count; ++i) {\n\t\textend[i] = pci_read_long(dev, PCI_ME_HER(i));\n\t\tprintf(\"%08x\", extend[i]);\n\t}\n\tprintf(\"\\n\");\n\n\treturn 0;\n}", "path": "coreboot/util/intelmetool/me.c", "commit_date": "2020-09-23 00:00:00", "repo_name": "coreboot/coreboot", "stars": 2032, "license": "gpl-2.0", "language": "c", "size": 235364}
{"docstring": "/* Prepare ME for MEI messages */\n", "func_signal": "uint32_t intel_mei_setup(struct pci_dev *dev)", "code": "{\n\tstruct mei_csr host;\n\tuint16_t reg16;\n\tuint32_t pagerounded;\n\n\tmei_base_address = dev->base_addr[0] & ~0xf;\n\tpagerounded = mei_base_address & ~0xfff;\n\tmei_mmap = map_physical(pagerounded, 0x2000);\n\tmei_mmap += mei_base_address - pagerounded;\n\tif (mei_mmap == NULL) {\n\t\tprintf(\"Could not map ME setup memory.\\n\"\n\t\t       \"Do you have kernel cmdline argument 'iomem=relaxed' set ?\\n\");\n\t\treturn 1;\n\t}\n\n\t/* Ensure Memory and Bus Master bits are set */\n\treg16 = pci_read_word(dev, PCI_COMMAND);\n\treg16 |= PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY;\n\tpci_write_word(dev, PCI_COMMAND, reg16);\n\n\t/* Clean up status for next message */\n\tread_host_csr(&host);\n\thost.interrupt_generate = 1;\n\thost.ready = 1;\n\thost.reset = 0;\n\twrite_host_csr(&host);\n\n\treturn 0;\n}", "path": "coreboot/util/intelmetool/me.c", "commit_date": "2020-09-23 00:00:00", "repo_name": "coreboot/coreboot", "stars": 2032, "license": "gpl-2.0", "language": "c", "size": 235364}
{"docstring": "/*\n * Some structures must not cross page boundaries. To get this,\n * we align them by their size (or the next greater power of 2).\n */\n", "func_signal": "void *\nxhci_align(const size_t min_align, const size_t size)", "code": "{\n\tsize_t align;\n\tif (!(size & (size - 1)))\n\t\talign = size; /* It's a power of 2 */\n\telse\n\t\talign = 1 << ((sizeof(unsigned) << 3) - __builtin_clz(size));\n\tif (align < min_align)\n\t\talign = min_align;\n\txhci_spew(\"Aligning %zu to %zu\\n\", size, align);\n\treturn dma_memalign(align, size);\n}", "path": "coreboot/payloads/libpayload/drivers/usb/xhci.c", "commit_date": "2020-11-22 00:00:00", "repo_name": "coreboot/coreboot", "stars": 2032, "license": "gpl-2.0", "language": "c", "size": 235364}
{"docstring": "/* num_elements == 0 indicates a large aligned region instead of a smaller\n * region comprised of alignment-sized chunks. */\n", "func_signal": "static struct align_region_t *allocate_region(int alignment, int num_elements,\n\t\t\t\t\tsize_t size, struct memory_type *type)", "code": "{\n\tstruct align_region_t *r;\n\tsize_t extra_space;\n\n#if CONFIG(LP_DEBUG_MALLOC)\n\tprintf(\"%s(old align_regions=%p, alignment=%u, num_elements=%u, size=%zu)\\n\",\n\t\t__func__, type->align_regions, alignment, num_elements, size);\n#endif\n\n\tr = malloc(sizeof(*r));\n\n\tif (r == NULL)\n\t\treturn NULL;\n\n\tmemset(r, 0, sizeof(*r));\n\n\tif (num_elements != 0) {\n\t\tr->alignment = alignment;\n\t\tr->size = num_elements * alignment;\n\t\tr->free = num_elements;\n\t\t/* Allocate enough memory for alignment requirements and\n\t\t * metadata for each chunk. */\n\t\textra_space = num_elements;\n\t} else {\n\t\t/* Large aligned allocation. Set alignment = 0. */\n\t\tr->alignment = 0;\n\t\tr->size = size;\n\t\textra_space = 0;\n\t}\n\n\tr->start = alloc(r->size + alignment + extra_space, type);\n\n\tif (r->start == NULL) {\n\t\tfree(r);\n\t\treturn NULL;\n\t}\n\n\tr->start_data = (void *)ALIGN_UP((uintptr_t)r->start + extra_space,\n\t\t\t\t\talignment);\n\n\t/* Clear any (if requested) metadata. */\n\tmemset(r->start, 0, extra_space);\n\n\t/* Link the region with the rest. */\n\tr->next = type->align_regions;\n\ttype->align_regions = r;\n\n\treturn r;\n}", "path": "coreboot/payloads/libpayload/libc/malloc.c", "commit_date": "2020-09-19 00:00:00", "repo_name": "coreboot/coreboot", "stars": 2032, "license": "gpl-2.0", "language": "c", "size": 235364}
{"docstring": "/** Busy waits for the lock. */\n", "func_signal": "static inline __attribute__((unused)) void spn_lock(spn_lock_i *lock)", "code": "{\n  while (spn_trylock(lock)) {\n    reschedule_thread();\n  }\n}", "path": "facil.io/lib/facil/legacy/fio_mem.c", "commit_date": "2019-01-02 00:00:00", "repo_name": "boazsegev/facil.io", "stars": 1967, "license": "mit", "language": "c", "size": 12456}
{"docstring": "/*  Computes a facil.io Risky Hash. */\n", "func_signal": "static inline uintptr_t fio_risky_hash2(const void *data_, size_t len,\n                                        uint64_t seed)", "code": "{\n  /* The primes used by Risky Hash */\n  const uint64_t primes[] = {\n      0xFBBA3FA15B22113B, // 1111101110111010001111111010000101011011001000100001000100111011\n      0xAB137439982B86C9, // 1010101100010011011101000011100110011000001010111000011011001001\n  };\n  /* The consumption vectors initialized state */\n  uint64_t v[4] = {\n      seed ^ primes[1],\n      ~seed + primes[1],\n      fio_lrot64(seed, 17) ^ (primes[1] + primes[0]),\n      fio_lrot64(seed, 33) + (~primes[1]),\n  };\n\n  /* reading position */\n  const uint8_t *data = (uint8_t *)data_;\n\n  /* consume 256bit blocks */\n  for (size_t i = len >> 5; i; --i) {\n    fio_risky_consume(v[0], fio_str2u64(data));\n    fio_risky_consume(v[1], fio_str2u64(data + 8));\n    fio_risky_consume(v[2], fio_str2u64(data + 16));\n    fio_risky_consume(v[3], fio_str2u64(data + 24));\n    data += 32;\n  }\n  /* Consume any remaining 64 bit words. */\n  switch (len & 24) {\n  case 24:\n    fio_risky_consume(v[2], fio_str2u64(data + 16));\n  case 16: /* overflow */\n    fio_risky_consume(v[1], fio_str2u64(data + 8));\n  case 8: /* overflow */\n    fio_risky_consume(v[0], fio_str2u64(data));\n    data += len & 24;\n  }\n\n  uint64_t tmp = 0;\n  /* consume leftover bytes, if any */\n  switch ((len & 7)) {\n  case 7: /* overflow */\n    tmp |= ((uint64_t)data[6]) << 8;\n  case 6: /* overflow */\n    tmp |= ((uint64_t)data[5]) << 16;\n  case 5: /* overflow */\n    tmp |= ((uint64_t)data[4]) << 24;\n  case 4: /* overflow */\n    tmp |= ((uint64_t)data[3]) << 32;\n  case 3: /* overflow */\n    tmp |= ((uint64_t)data[2]) << 40;\n  case 2: /* overflow */\n    tmp |= ((uint64_t)data[1]) << 48;\n  case 1: /* overflow */\n    tmp |= ((uint64_t)data[0]) << 56;\n    /* ((len & 24) >> 3) is a 0-3 value representing the next state vector */\n    /* `switch` allows v[i] to be a register without a memory address */\n    /* using v[(len & 24) >> 3] forces implementation to use memory */\n    switch ((len & 24) >> 3) {\n    case 3:\n      fio_risky_consume(v[3], tmp);\n      break;\n    case 2:\n      fio_risky_consume(v[2], tmp);\n      break;\n    case 1:\n      fio_risky_consume(v[1], tmp);\n      break;\n    case 0:\n      fio_risky_consume(v[0], tmp);\n      break;\n    }\n  }\n\n  /* merge and mix */\n  uint64_t result = fio_lrot64(v[0], 17) + fio_lrot64(v[1], 13) +\n                    fio_lrot64(v[2], 47) + fio_lrot64(v[3], 57);\n  result += len;\n  result += v[0] * primes[1];\n  result ^= fio_lrot64(result, 13);\n  result += v[1] * primes[1];\n  result ^= fio_lrot64(result, 29);\n  result += v[2] * primes[1];\n  result ^= fio_lrot64(result, 33);\n  result += v[3] * primes[1];\n  result ^= fio_lrot64(result, 51);\n\n  /* irreversible avalanche... I think */\n  result ^= (result >> 29) * primes[0];\n  return result;\n}", "path": "facil.io/tests/collisions.c", "commit_date": "2019-01-22 00:00:00", "repo_name": "boazsegev/facil.io", "stars": 1967, "license": "mit", "language": "c", "size": 12456}
{"docstring": "/**\n * Decreases an object's reference count, releasing memory and\n * resources.\n *\n * This function affects nested objects, meaning that when an Array or\n * a Hash object is passed along, it's children (nested objects) are\n * also freed.\n */\n", "func_signal": "void fiobj_free_complex_object(FIOBJ o)", "code": "{\n  fiobj_stack_s stack = FIO_ARY_INIT;\n  do {\n    FIOBJECT2VTBL(o)->dealloc(o, fiobj_dealloc_task, &stack);\n  } while (!fiobj_stack_pop(&stack, &o));\n  fiobj_stack_free(&stack);\n}", "path": "facil.io/lib/facil/fiobj/fiobject.c", "commit_date": "2019-03-11 00:00:00", "repo_name": "boazsegev/facil.io", "stars": 1967, "license": "mit", "language": "c", "size": 12456}
{"docstring": "/* intializes the block header for an available block of memory. */\n", "func_signal": "static inline block_s *block_new(void)", "code": "{\n  block_s *blk = NULL;\n\n  if (memory.available) {\n    spn_lock(&memory.lock);\n    blk = (block_s *)memory.available;\n    if (blk) {\n      memory.available = ((block_s **)blk)[0];\n    }\n    spn_unlock(&memory.lock);\n  }\n  if (blk) {\n    spn_sub(&memory.count, 1);\n    ((block_s **)blk)[0] = NULL;\n    ((block_s **)blk)[1] = NULL;\n    return block_init(blk);\n  }\n  /* TODO: collect memory from the system */\n  blk = sys_alloc(FIO_MEMORY_BLOCK_SIZE, 0);\n  if (!blk)\n    return NULL;\n  return block_init(blk);\n  ;\n}", "path": "facil.io/lib/facil/legacy/fio_mem.c", "commit_date": "2019-01-02 00:00:00", "repo_name": "boazsegev/facil.io", "stars": 1967, "license": "mit", "language": "c", "size": 12456}
{"docstring": "/* *****************************************************************************\nRedis initialization\n***************************************************************************** */\n", "func_signal": "static void initialize_redis(void)", "code": "{\n  if (!fio_cli_get(\"-redis\") || !strlen(fio_cli_get(\"-redis\")))\n    return;\n  FIO_LOG_STATE(\"* Initializing Redis connection to %s\\n\",\n                fio_cli_get(\"-redis\"));\n  fio_url_s info =\n      fio_url_parse(fio_cli_get(\"-redis\"), strlen(fio_cli_get(\"-redis\")));\n  fio_pubsub_engine_s *e =\n      redis_engine_create(.address = info.host, .port = info.port,\n                          .auth = info.password);\n  if (e)\n    fio_state_callback_add(FIO_CALL_ON_FINISH,\n                           (void (*)(void *))redis_engine_destroy, e);\n  FIO_PUBSUB_DEFAULT = e;\n}", "path": "facil.io/examples/http-chat.c", "commit_date": "2019-01-17 00:00:00", "repo_name": "boazsegev/facil.io", "stars": 1967, "license": "mit", "language": "c", "size": 12456}
{"docstring": "/* HTTP upgrade callback */\n", "func_signal": "static void on_http_upgrade(http_s *h, char *requested_protocol, size_t len)", "code": "{\n  /* Upgrade to SSE or WebSockets and set the request path as a nickname. */\n  FIOBJ nickname;\n  if (fiobj_obj2cstr(h->path).len > 1) {\n    nickname = fiobj_str_new(fiobj_obj2cstr(h->path).data + 1,\n                             fiobj_obj2cstr(h->path).len - 1);\n  } else {\n    nickname = fiobj_str_new(\"Guest\", 5);\n  }\n  /* Test for upgrade protocol (websocket vs. sse) */\n  if (len == 3 && requested_protocol[1] == 's') {\n    if (fio_cli_get_bool(\"-v\")) {\n      fprintf(stderr, \"* (%d) new SSE connection: %s.\\n\", getpid(),\n              fiobj_obj2cstr(nickname).data);\n    }\n    http_upgrade2sse(h, .on_open = sse_on_open, .on_close = sse_on_close,\n                     .udata = (void *)nickname);\n  } else if (len == 9 && requested_protocol[1] == 'e') {\n    if (fio_cli_get_bool(\"-v\")) {\n      fprintf(stderr, \"* (%d) new WebSocket connection: %s.\\n\", getpid(),\n              fiobj_obj2cstr(nickname).data);\n    }\n    http_upgrade2ws(h, .on_message = ws_on_message, .on_open = ws_on_open,\n                    .on_shutdown = ws_on_shutdown, .on_close = ws_on_close,\n                    .udata = (void *)nickname);\n  } else {\n    fprintf(stderr, \"WARNING: unrecognized HTTP upgrade request: %s\\n\",\n            requested_protocol);\n    http_send_error(h, 400);\n    fiobj_free(nickname); // we didn't use this\n  }\n}", "path": "facil.io/examples/http-chat.c", "commit_date": "2019-01-17 00:00:00", "repo_name": "boazsegev/facil.io", "stars": 1967, "license": "mit", "language": "c", "size": 12456}
{"docstring": "/**\n * Single layer iteration using a callback for each nested fio object.\n *\n * Accepts any `FIOBJ ` type but only collections (Arrays and Hashes) are\n * processed. The container itself (the Array or the Hash) is **not** processed\n * (unlike `fiobj_each2`).\n *\n * The callback task function must accept an object and an opaque user pointer.\n *\n * Hash objects pass along a `FIOBJ_T_COUPLET` object, containing\n * references for both the key and the object. Keys shouldn't be altered once\n * placed as a key (or the Hash will break). Collections (Arrays / Hashes) can't\n * be used as keeys.\n *\n * If the callback returns -1, the loop is broken. Any other value is ignored.\n *\n * Returns the \"stop\" position, i.e., the number of items processed + the\n * starting point.\n */\n", "func_signal": "size_t fiobj_each2(FIOBJ o, int (*task)(FIOBJ obj, void *arg), void *arg)", "code": "{\n  if (!o || !FIOBJ_IS_ALLOCATED(o) || (FIOBJECT2VTBL(o)->each == NULL)) {\n    task(o, arg);\n    return 1;\n  }\n  /* run task for root object */\n  if (task(o, arg) == -1)\n    return 1;\n  uintptr_t pos = 0;\n  fiobj_stack_s stack = FIO_ARY_INIT;\n  struct task_packet_s packet = {\n      .task = task,\n      .arg = arg,\n      .stack = &stack,\n      .counter = 1,\n  };\n  do {\n    if (!pos)\n      packet.next = 0;\n    packet.incomplete = 0;\n    pos = FIOBJECT2VTBL(o)->each(o, pos, fiobj_task_wrapper, &packet);\n    if (packet.stop)\n      goto finish;\n    if (packet.incomplete) {\n      fiobj_stack_push(&stack, pos);\n      fiobj_stack_push(&stack, o);\n    }\n\n    if (packet.next) {\n      fiobj_stack_push(&stack, (FIOBJ)0);\n      fiobj_stack_push(&stack, packet.next);\n    }\n    o = FIOBJ_INVALID;\n    fiobj_stack_pop(&stack, &o);\n    fiobj_stack_pop(&stack, &pos);\n  } while (o);\nfinish:\n  fiobj_stack_free(&stack);\n  return packet.counter;\n}", "path": "facil.io/lib/facil/fiobj/fiobject.c", "commit_date": "2019-03-11 00:00:00", "repo_name": "boazsegev/facil.io", "stars": 1967, "license": "mit", "language": "c", "size": 12456}
{"docstring": "/* *****************************************************************************\nCleanup\n***************************************************************************** */\n", "func_signal": "static void cleanup(void)", "code": "{\n  print_flag = 0;\n  hash_name_free(&hash_names);\n  words_free(&words);\n}", "path": "facil.io/tests/collisions.c", "commit_date": "2019-01-22 00:00:00", "repo_name": "boazsegev/facil.io", "stars": 1967, "license": "mit", "language": "c", "size": 12456}
{"docstring": "/* returned a locked arena. Attempts the preffered arena first. */\n", "func_signal": "static inline arena_s *arena_lock(arena_s *preffered)", "code": "{\n  if (!preffered)\n    preffered = arenas;\n  if (!spn_trylock(&preffered->lock))\n    return preffered;\n  do {\n    arena_s *arena = preffered;\n    for (size_t i = (size_t)(arena - arenas); i < memory.cores; ++i) {\n      if ((preffered == arenas || arena != preffered) &&\n          !spn_trylock(&arena->lock))\n        return arena;\n      ++arena;\n    }\n    if (preffered == arenas)\n      reschedule_thread();\n    preffered = arenas;\n  } while (1);\n}", "path": "facil.io/lib/facil/legacy/fio_mem.c", "commit_date": "2019-01-02 00:00:00", "repo_name": "boazsegev/facil.io", "stars": 1967, "license": "mit", "language": "c", "size": 12456}
{"docstring": "/* frees memory using `munmap`. requires exact, page aligned, `len` */\n", "func_signal": "static inline void sys_free(void *mem, size_t len)", "code": "{ munmap(mem, len); }\n\nstatic void *sys_realloc(void *mem, size_t prev_len, size_t new_len) {\n  if (new_len > prev_len) {\n#if defined(__linux__) && defined(MREMAP_MAYMOVE)\n    void *result = mremap(mem, prev_len, new_len, MREMAP_MAYMOVE);\n    if (result == MAP_FAILED)\n      return NULL;\n#else\n    void *result =\n        mmap((void *)((uintptr_t)mem + prev_len), new_len - prev_len,\n             PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n    if (result == (void *)((uintptr_t)mem + prev_len)) {\n      result = mem;\n    } else {\n      /* copy and free */\n      munmap(result, new_len - prev_len); /* free the failed attempt */\n      result = sys_alloc(new_len, 1);     /* allocate new memory */\n      if (!result) {\n        return NULL;\n      }\n      fio_memcpy(result, mem, prev_len >> 4); /* copy data */\n      // memcpy(result, mem, prev_len);\n      munmap(mem, prev_len); /* free original memory */\n    }\n#endif\n    return result;\n  }\n  if (new_len + 4096 < prev_len) /* more than a single dangling page */\n    munmap((void *)((uintptr_t)mem + new_len), prev_len - new_len);\n  return mem;\n}", "path": "facil.io/lib/facil/legacy/fio_mem.c", "commit_date": "2019-01-02 00:00:00", "repo_name": "boazsegev/facil.io", "stars": 1967, "license": "mit", "language": "c", "size": 12456}
{"docstring": "/**\n * Allocates memory directly using `mmap`, this is prefered for larger objects\n * that have a long lifetime.\n *\n * `fio_free` can be used for deallocating the memory.\n */\n", "func_signal": "void *fio_mmap(size_t size)", "code": "{\n  if (!size) {\n    return NULL;\n  }\n  return big_alloc(size);\n}", "path": "facil.io/lib/facil/legacy/fio_mem.c", "commit_date": "2019-01-02 00:00:00", "repo_name": "boazsegev/facil.io", "stars": 1967, "license": "mit", "language": "c", "size": 12456}
{"docstring": "/**\n * Re-allocates memory. An attept to avoid copying the data is made only for big\n * memory allocations.\n *\n * This variation is slightly faster as it might copy less data\n */\n", "func_signal": "void *fio_realloc2(void *ptr, size_t new_size, size_t copy_length)", "code": "{\n  if (!ptr || ptr == (void *)&on_malloc_zero)\n    return fio_malloc(new_size);\n  if (!new_size) {\n    goto zero_size;\n  }\n  if (((uintptr_t)ptr & FIO_MEMORY_BLOCK_MASK) == 16) {\n    /* big reallocation - direct from the system */\n    return big_realloc(ptr, new_size);\n  }\n  /* allocated within block - don't even try to expand the allocation */\n  /* ceiling for 16 byte alignement, translated to 16 byte units */\n  void *new_mem = fio_malloc(new_size);\n  if (!new_mem)\n    return NULL;\n  new_size = ((new_size >> 4) + (!!(new_size & 15)));\n  copy_length = ((copy_length >> 4) + (!!(copy_length & 15)));\n  // memcpy(new_mem, ptr, (copy_length > new_size ? new_size : copy_length) <<\n  // 4);\n  fio_memcpy(new_mem, ptr, (copy_length > new_size ? new_size : copy_length));\n  block_slice_free(ptr);\n  return new_mem;\nzero_size:\n  fio_free(ptr);\n  return malloc(0);\n}", "path": "facil.io/lib/facil/legacy/fio_mem.c", "commit_date": "2019-01-02 00:00:00", "repo_name": "boazsegev/facil.io", "stars": 1967, "license": "mit", "language": "c", "size": 12456}
{"docstring": "/* *****************************************************************************\nNon-Block allocations (direct from the system)\n***************************************************************************** */\n", "func_signal": "static inline void *big_alloc(size_t size)", "code": "{\n  size = sys_round_size(size + 16);\n  size_t *mem = sys_alloc(size, 1);\n  if (!mem)\n    goto error;\n  *mem = size;\n  return (void *)(((uintptr_t)mem) + 16);\nerror:\n  return NULL;\n}", "path": "facil.io/lib/facil/legacy/fio_mem.c", "commit_date": "2019-01-02 00:00:00", "repo_name": "boazsegev/facil.io", "stars": 1967, "license": "mit", "language": "c", "size": 12456}
{"docstring": "/* *****************************************************************************\nFree complex objects (objects with nesting)\n***************************************************************************** */\n", "func_signal": "static void fiobj_dealloc_task(FIOBJ o, void *stack_)", "code": "{\n  // if (!o)\n  //   fprintf(stderr, \"* WARN: freeing a NULL no-object\\n\");\n  // else\n  //   fprintf(stderr, \"* freeing object %s\\n\", fiobj_obj2cstr(o).data);\n  if (!o || !FIOBJ_IS_ALLOCATED(o))\n    return;\n  if (OBJREF_REM(o))\n    return;\n  if (!FIOBJECT2VTBL(o)->each || !FIOBJECT2VTBL(o)->count(o)) {\n    FIOBJECT2VTBL(o)->dealloc(o, NULL, NULL);\n    return;\n  }\n  fiobj_stack_s *s = stack_;\n  fiobj_stack_push(s, o);\n}", "path": "facil.io/lib/facil/fiobj/fiobject.c", "commit_date": "2019-03-11 00:00:00", "repo_name": "boazsegev/facil.io", "stars": 1967, "license": "mit", "language": "c", "size": 12456}
{"docstring": "/** used internally for complext nested tests (Array / Hash types) */\n", "func_signal": "int fiobj_iseq____internal_complex__(FIOBJ o, FIOBJ o2)", "code": "{\n  // if (FIOBJECT2VTBL(o)->each && FIOBJECT2VTBL(o)->count(o))\n  //   return int fiobj_iseq____internal_complex__(const FIOBJ o, const FIOBJ\n  //   o2);\n  fiobj_stack_s left = FIO_ARY_INIT, right = FIO_ARY_INIT, queue = FIO_ARY_INIT;\n  do {\n    fiobj_each1(o, 0, fiobj_iseq____internal_complex__task, &left);\n    fiobj_each1(o2, 0, fiobj_iseq____internal_complex__task, &right);\n    while (fiobj_stack_count(&left)) {\n      o = FIOBJ_INVALID;\n      o2 = FIOBJ_INVALID;\n      fiobj_stack_pop(&left, &o);\n      fiobj_stack_pop(&right, &o2);\n      if (!fiobj_iseq_simple(o, o2))\n        goto unequal;\n      if (FIOBJ_IS_ALLOCATED(o) && FIOBJECT2VTBL(o)->each &&\n          FIOBJECT2VTBL(o)->count(o)) {\n        fiobj_stack_push(&queue, o);\n        fiobj_stack_push(&queue, o2);\n      }\n    }\n    o = FIOBJ_INVALID;\n    o2 = FIOBJ_INVALID;\n    fiobj_stack_pop(&queue, &o2);\n    fiobj_stack_pop(&queue, &o);\n    if (!fiobj_iseq_simple(o, o2))\n      goto unequal;\n  } while (o);\n  fiobj_stack_free(&left);\n  fiobj_stack_free(&right);\n  fiobj_stack_free(&queue);\n  return 1;\nunequal:\n  fiobj_stack_free(&left);\n  fiobj_stack_free(&right);\n  fiobj_stack_free(&queue);\n  return 0;\n}", "path": "facil.io/lib/facil/fiobj/fiobject.c", "commit_date": "2019-03-11 00:00:00", "repo_name": "boazsegev/facil.io", "stars": 1967, "license": "mit", "language": "c", "size": 12456}
{"docstring": "/* will return `inv` if `inv` is inverse of `n` */\n", "func_signal": "static uint64_t inverse64_test(uint64_t n, uint64_t inv)", "code": "{\n  uint64_t result = inv * (2 - (n * inv));\n  return result;\n}", "path": "facil.io/tests/collisions.c", "commit_date": "2019-01-22 00:00:00", "repo_name": "boazsegev/facil.io", "stars": 1967, "license": "mit", "language": "c", "size": 12456}
{"docstring": "/* *****************************************************************************\nWebSockets Callbacks\n***************************************************************************** */\n", "func_signal": "static void ws_on_message(ws_s *ws, fio_str_info_s msg, uint8_t is_text)", "code": "{\n  // Add the Nickname to the message\n  FIOBJ str = fiobj_str_copy((FIOBJ)websocket_udata_get(ws));\n  fiobj_str_write(str, \": \", 2);\n  fiobj_str_write(str, msg.data, msg.len);\n  // publish\n  fio_publish(.channel = CHAT_CANNEL, .message = fiobj_obj2cstr(str));\n  // free the string\n  fiobj_free(str);\n  (void)is_text; // we don't care.\n  (void)ws;      // this could be used to send an ACK, but we don't.\n}", "path": "facil.io/examples/http-chat.c", "commit_date": "2019-01-17 00:00:00", "repo_name": "boazsegev/facil.io", "stars": 1967, "license": "mit", "language": "c", "size": 12456}
{"docstring": "/* *****************************************************************************\nLibrary Initialization (initialize arenas and allocate a block for each CPU)\n***************************************************************************** */\n", "func_signal": "static void __attribute__((constructor)) fio_mem_init(void)", "code": "{\n  if (arenas)\n    return;\n\n#ifdef _SC_NPROCESSORS_ONLN\n  ssize_t cpu_count = sysconf(_SC_NPROCESSORS_ONLN);\n#else\n#warning Dynamic CPU core count is unavailable - assuming 8 cores for memory allocation pools.\n  ssize_t cpu_count = 8; /* fallback */\n#endif\n  memory.cores = cpu_count;\n  memory.count = 0 - (intptr_t)cpu_count;\n  arenas = big_alloc(sizeof(*arenas) * cpu_count);\n  if (!arenas) {\n    perror(\"FATAL ERROR: Couldn't initialize memory allocator\");\n    exit(errno);\n  }\n  size_t pre_pool = cpu_count > 32 ? 32 : cpu_count;\n  for (size_t i = 0; i < pre_pool; ++i) {\n    void *block = sys_alloc(FIO_MEMORY_BLOCK_SIZE, 0);\n    if (block) {\n      block_init(block);\n      block_free(block);\n    }\n  }\n  pthread_atfork(NULL, NULL, fio_malloc_after_fork);\n}", "path": "facil.io/lib/facil/legacy/fio_mem.c", "commit_date": "2019-01-02 00:00:00", "repo_name": "boazsegev/facil.io", "stars": 1967, "license": "mit", "language": "c", "size": 12456}
{"docstring": "/* *****************************************************************************\nDefaults / NOOPs\n***************************************************************************** */\n", "func_signal": "void fiobject___noop_dealloc(FIOBJ o, void (*task)(FIOBJ, void *), void *arg)", "code": "{\n  (void)o;\n  (void)task;\n  (void)arg;\n}", "path": "facil.io/lib/facil/fiobj/fiobject.c", "commit_date": "2019-03-11 00:00:00", "repo_name": "boazsegev/facil.io", "stars": 1967, "license": "mit", "language": "c", "size": 12456}
{"docstring": "/* *****************************************************************************\nCLI helpers\n***************************************************************************** */\n", "func_signal": "static void initialize_cli(int argc, char const *argv[])", "code": "{\n  /*     ****  Command line arguments ****     */\n  fio_cli_start(\n      argc, argv, 0, 0, NULL,\n      // Address Binding\n      FIO_CLI_PRINT_HEADER(\"Address Binding:\"),\n      FIO_CLI_INT(\"-port -p port number to listen to. defaults port 3000\"),\n      \"-bind -b address to listen to. defaults any available.\",\n      FIO_CLI_BOOL(\"-tls use a self signed certificate for TLS.\"),\n      // Concurrency\n      FIO_CLI_PRINT_HEADER(\"Concurrency:\"),\n      FIO_CLI_INT(\"-workers -w number of processes to use.\"),\n      FIO_CLI_INT(\"-threads -t number of threads per process.\"),\n      // HTTP Settings\n      FIO_CLI_PRINT_HEADER(\"HTTP Settings:\"),\n      \"-public -www public folder, for static file service.\",\n      FIO_CLI_INT(\n          \"-keep-alive -k HTTP keep-alive timeout (0..255). default: 10s\"),\n      FIO_CLI_INT(\n          \"-max-body -maxbd HTTP upload limit in Mega Bytes. default: 50Mb\"),\n      FIO_CLI_BOOL(\"-log -v request verbosity (logging).\"),\n      // WebSocket Settings\n      FIO_CLI_PRINT_HEADER(\"WebSocket Settings:\"),\n      FIO_CLI_INT(\"-ping websocket ping interval (0..255). default: 40s\"),\n      FIO_CLI_INT(\"-max-msg -maxms incoming websocket message \"\n                  \"size limit in Kb. default: 250Kb\"),\n      // Misc Settings\n      FIO_CLI_PRINT_HEADER(\"Misc:\"),\n      FIO_CLI_STRING(\"-redis -r an optional Redis URL server address.\"),\n      FIO_CLI_PRINT(\"\\t\\ta valid Redis URL would follow the pattern:\"),\n      FIO_CLI_PRINT(\"\\t\\t\\tredis://user:password@localhost:6379/\"),\n      FIO_CLI_INT(\"-verbosity -V facil.io verbocity 0..5 (logging level).\"));\n\n  /* Test and set any default options */\n  if (!fio_cli_get(\"-p\")) {\n    /* Test environment as well */\n    char *tmp = getenv(\"PORT\");\n    if (!tmp)\n      tmp = \"3000\";\n    /* CLI et functions (unlike fio_cli_start) ignores aliases */\n    fio_cli_set(\"-p\", tmp);\n    fio_cli_set(\"-port\", tmp);\n  }\n  if (!fio_cli_get(\"-b\")) {\n    char *tmp = getenv(\"ADDRESS\");\n    if (tmp) {\n      fio_cli_set(\"-b\", tmp);\n      fio_cli_set(\"-bind\", tmp);\n    }\n  }\n  if (!fio_cli_get(\"-public\")) {\n    char *tmp = getenv(\"HTTP_PUBLIC_FOLDER\");\n    if (tmp) {\n      fio_cli_set(\"-public\", tmp);\n      fio_cli_set(\"-www\", tmp);\n    }\n  }\n\n  if (!fio_cli_get(\"-redis\")) {\n    char *tmp = getenv(\"REDIS_URL\");\n    if (tmp) {\n      fio_cli_set(\"-redis\", tmp);\n      fio_cli_set(\"-r\", tmp);\n    }\n  }\n  if (fio_cli_get(\"-V\")) {\n    FIO_LOG_LEVEL = fio_cli_get_i(\"-V\");\n  }\n\n  fio_cli_set_default(\"-ping\", \"40\");\n\n  /* CLI set functions (unlike fio_cli_start) ignores aliases */\n  fio_cli_set_default(\"-k\", \"10\");\n  fio_cli_set_default(\"-keep-alive\", \"10\");\n\n  fio_cli_set_default(\"-max-body\", \"50\");\n  fio_cli_set_default(\"-maxbd\", \"50\");\n\n  fio_cli_set_default(\"-max-message\", \"250\");\n  fio_cli_set_default(\"-maxms\", \"250\");\n}", "path": "facil.io/examples/http-chat.c", "commit_date": "2019-01-17 00:00:00", "repo_name": "boazsegev/facil.io", "stars": 1967, "license": "mit", "language": "c", "size": 12456}
{"docstring": "/* The python void return value */\n", "func_signal": "SWIGRUNTIMEINLINE PyObject * \nSWIG_Py_Void(void)", "code": "{\n  PyObject *none = Py_None;\n  Py_INCREF(none);\n  return none;\n}", "path": "python-midi/src/sequencer_osx/sequencer_osx_wrap.c", "commit_date": "2011-04-20 00:00:00", "repo_name": "vishnubob/python-midi", "stars": 1481, "license": "mit", "language": "c", "size": 208}
{"docstring": "/* Error manipulation */\n", "func_signal": "SWIGINTERN void \nSWIG_Python_SetErrorObj(PyObject *errtype, PyObject *obj)", "code": "{\n  SWIG_PYTHON_THREAD_BEGIN_BLOCK; \n  PyErr_SetObject(errtype, obj);\n  Py_DECREF(obj);\n  SWIG_PYTHON_THREAD_END_BLOCK;\n}", "path": "python-midi/src/sequencer_osx/sequencer_osx_wrap.c", "commit_date": "2011-04-20 00:00:00", "repo_name": "vishnubob/python-midi", "stars": 1481, "license": "mit", "language": "c", "size": 208}
{"docstring": "/* MIDIPortConnectSource */\n", "func_signal": "void _MIDIPortConnectSource(MIDIPortRef port, MIDIEndpointRef endpoint)", "code": "{\n    OSStatus err;\n    MIDIPortRef outPort;\n    err = MIDIPortConnectSource(port, endpoint, NULL);\n    if(err != noErr)\n    {\n        PyErr_SetString(PyExc_SystemError, \"Error during MIDIPortConnectSource.\");\n    }\n}", "path": "python-midi/src/sequencer_osx/sequencer_osx_wrap.c", "commit_date": "2011-04-20 00:00:00", "repo_name": "vishnubob/python-midi", "stars": 1481, "license": "mit", "language": "c", "size": 208}
{"docstring": "/* Create a new pointer object */\n", "func_signal": "SWIGRUNTIME PyObject *\nSWIG_Python_NewPointerObj(void *ptr, swig_type_info *type, int flags)", "code": "{\n  if (!ptr) {\n    return SWIG_Py_Void();\n  } else {\n    int own = (flags & SWIG_POINTER_OWN) ? SWIG_POINTER_OWN : 0;\n    PyObject *robj = PySwigObject_New(ptr, type, own);\n    PySwigClientData *clientdata = type ? (PySwigClientData *)(type->clientdata) : 0;\n    if (clientdata && !(flags & SWIG_POINTER_NOSHADOW)) {\n      PyObject *inst = SWIG_Python_NewShadowInstance(clientdata, robj);\n      if (inst) {\n\tPy_DECREF(robj);\n\trobj = inst;\n      }\n    }\n    return robj;\n  }\n}", "path": "python-midi/src/sequencer_osx/sequencer_osx_wrap.c", "commit_date": "2011-04-20 00:00:00", "repo_name": "vishnubob/python-midi", "stars": 1481, "license": "mit", "language": "c", "size": 208}
{"docstring": "/*\n  Search for a swig_type_info structure for either a mangled name or a human readable name.\n  It first searches the mangled names of the types, which is a O(log #types)\n  If a type is not found it then searches the human readable names, which is O(#types).\n  \n  We start searching at module start, and finish searching when start == end.  \n  Note: if start == end at the beginning of the function, we go all the way around\n  the circular list.\n*/\n", "func_signal": "SWIGRUNTIME swig_type_info *\nSWIG_TypeQueryModule(swig_module_info *start, \n                     swig_module_info *end, \n\t\t     const char *name)", "code": "{\n  /* STEP 1: Search the name field using binary search */\n  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);\n  if (ret) {\n    return ret;\n  } else {\n    /* STEP 2: If the type hasn't been found, do a complete search\n       of the str field (the human readable name) */\n    swig_module_info *iter = start;\n    do {\n      register size_t i = 0;\n      for (; i < iter->size; ++i) {\n\tif (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))\n\t  return iter->types[i];\n      }\n      iter = iter->next;\n    } while (iter != end);\n  }\n  \n  /* neither found a match */\n  return 0;\n}", "path": "python-midi/src/sequencer_osx/sequencer_osx_wrap.c", "commit_date": "2011-04-20 00:00:00", "repo_name": "vishnubob/python-midi", "stars": 1481, "license": "mit", "language": "c", "size": 208}
{"docstring": "/* \n   Unpack binary data from a string\n*/\n", "func_signal": "SWIGRUNTIME const char *\nSWIG_UnpackData(const char *c, void *ptr, size_t sz)", "code": "{\n  register unsigned char *u = (unsigned char *) ptr;\n  register const unsigned char *eu = u + sz;\n  for (; u != eu; ++u) {\n    register char d = *(c++);\n    register unsigned char uu;\n    if ((d >= '0') && (d <= '9'))\n      uu = ((d - '0') << 4);\n    else if ((d >= 'a') && (d <= 'f'))\n      uu = ((d - ('a'-10)) << 4);\n    else \n      return (char *) 0;\n    d = *(c++);\n    if ((d >= '0') && (d <= '9'))\n      uu |= (d - '0');\n    else if ((d >= 'a') && (d <= 'f'))\n      uu |= (d - ('a'-10));\n    else \n      return (char *) 0;\n    *u = uu;\n  }\n  return c;\n}", "path": "python-midi/src/sequencer_osx/sequencer_osx_wrap.c", "commit_date": "2011-04-20 00:00:00", "repo_name": "vishnubob/python-midi", "stars": 1481, "license": "mit", "language": "c", "size": 208}
{"docstring": "/* \n   Pack 'void *' into a string buffer.\n*/\n", "func_signal": "SWIGRUNTIME char *\nSWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz)", "code": "{\n  char *r = buff;\n  if ((2*sizeof(void *) + 2) > bsz) return 0;\n  *(r++) = '_';\n  r = SWIG_PackData(r,&ptr,sizeof(void *));\n  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;\n  strcpy(r,name);\n  return buff;\n}", "path": "python-midi/src/sequencer_osx/sequencer_osx_wrap.c", "commit_date": "2011-04-20 00:00:00", "repo_name": "vishnubob/python-midi", "stars": 1481, "license": "mit", "language": "c", "size": 208}
{"docstring": "/*\n  Create a new instance object, whitout calling __init__, and set the\n  'this' attribute.\n*/\n", "func_signal": "SWIGRUNTIME PyObject* \nSWIG_Python_NewShadowInstance(PySwigClientData *data, PyObject *swig_this)", "code": "{\n#if (PY_VERSION_HEX >= 0x02020000)\n  PyObject *inst = 0;\n  PyObject *newraw = data->newraw;\n  if (newraw) {\n    inst = PyObject_Call(newraw, data->newargs, NULL);\n    if (inst) {\n#if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)\n      PyObject **dictptr = _PyObject_GetDictPtr(inst);\n      if (dictptr != NULL) {\n\tPyObject *dict = *dictptr;\n\tif (dict == NULL) {\n\t  dict = PyDict_New();\n\t  *dictptr = dict;\n\t  PyDict_SetItem(dict, SWIG_This(), swig_this);\n\t}\n      }\n#else\n      PyObject *key = SWIG_This();\n      PyObject_SetAttr(inst, key, swig_this);\n#endif\n    }\n  } else {\n    PyObject *dict = PyDict_New();\n    PyDict_SetItem(dict, SWIG_This(), swig_this);\n    inst = PyInstance_NewRaw(data->newargs, dict);\n    Py_DECREF(dict);\n  }\n  return inst;\n#else\n#if (PY_VERSION_HEX >= 0x02010000)\n  PyObject *inst;\n  PyObject *dict = PyDict_New();\n  PyDict_SetItem(dict, SWIG_This(), swig_this);\n  inst = PyInstance_NewRaw(data->newargs, dict);\n  Py_DECREF(dict);\n  return (PyObject *) inst;\n#else\n  PyInstanceObject *inst = PyObject_NEW(PyInstanceObject, &PyInstance_Type);\n  if (inst == NULL) {\n    return NULL;\n  }\n  inst->in_class = (PyClassObject *)data->newargs;\n  Py_INCREF(inst->in_class);\n  inst->in_dict = PyDict_New();\n  if (inst->in_dict == NULL) {\n    Py_DECREF(inst);\n    return NULL;\n  }\n#ifdef Py_TPFLAGS_HAVE_WEAKREFS\n  inst->in_weakreflist = NULL;\n#endif\n#ifdef Py_TPFLAGS_GC\n  PyObject_GC_Init(inst);\n#endif\n  PyDict_SetItem(inst->in_dict, SWIG_This(), swig_this);\n  return (PyObject *) inst;\n#endif\n#endif\n}", "path": "python-midi/src/sequencer_osx/sequencer_osx_wrap.c", "commit_date": "2011-04-20 00:00:00", "repo_name": "vishnubob/python-midi", "stars": 1481, "license": "mit", "language": "c", "size": 208}
{"docstring": "/* Convert a pointer value, signal an exception on a type mismatch */\n", "func_signal": "SWIGRUNTIME void *\nSWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int argnum, int flags)", "code": "{\n  void *result;\n  if (SWIG_Python_ConvertPtr(obj, &result, ty, flags) == -1) {\n    PyErr_Clear();\n    if (flags & SWIG_POINTER_EXCEPTION) {\n      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);\n      SWIG_Python_ArgFail(argnum);\n    }\n  }\n  return result;\n}", "path": "python-midi/src/sequencer_osx/sequencer_osx_wrap.c", "commit_date": "2011-04-20 00:00:00", "repo_name": "vishnubob/python-midi", "stars": 1481, "license": "mit", "language": "c", "size": 208}
{"docstring": "/* Set a constant value */\n", "func_signal": "SWIGINTERN void\nSWIG_Python_SetConstant(PyObject *d, const char *name, PyObject *obj)", "code": "{   \n  PyDict_SetItemString(d, (char*) name, obj);\n  Py_DECREF(obj);                            \n}", "path": "python-midi/src/sequencer_osx/sequencer_osx_wrap.c", "commit_date": "2011-04-20 00:00:00", "repo_name": "vishnubob/python-midi", "stars": 1481, "license": "mit", "language": "c", "size": 208}
{"docstring": "/* MIDIClientDispose */\n", "func_signal": "void _MIDIClientDispose(MIDIClientRef client)", "code": "{\n    OSStatus err;\n    err = MIDIClientDispose(client);\n    if(err != noErr)\n    {\n        PyErr_SetString(PyExc_SystemError, \"Error during MIDIClientDispose.\");\n    }\n}", "path": "python-midi/src/sequencer_osx/sequencer_osx_wrap.c", "commit_date": "2011-04-20 00:00:00", "repo_name": "vishnubob/python-midi", "stars": 1481, "license": "mit", "language": "c", "size": 208}
{"docstring": "/* Convert a packed value value */\n", "func_signal": "SWIGRUNTIME int\nSWIG_Python_ConvertPacked(PyObject *obj, void *ptr, size_t sz, swig_type_info *ty)", "code": "{\n  swig_type_info *to = PySwigPacked_UnpackData(obj, ptr, sz);\n  if (!to) return SWIG_ERROR;\n  if (ty) {\n    if (to != ty) {\n      /* check type cast? */\n      swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);\n      if (!tc) return SWIG_ERROR;\n    }\n  }\n  return SWIG_OK;\n}", "path": "python-midi/src/sequencer_osx/sequencer_osx_wrap.c", "commit_date": "2011-04-20 00:00:00", "repo_name": "vishnubob/python-midi", "stars": 1481, "license": "mit", "language": "c", "size": 208}
{"docstring": "/* Append a value to the result obj */\n", "func_signal": "SWIGINTERN PyObject*\nSWIG_Python_AppendOutput(PyObject* result, PyObject* obj)", "code": "{\n#if !defined(SWIG_PYTHON_OUTPUT_TUPLE)\n  if (!result) {\n    result = obj;\n  } else if (result == Py_None) {\n    Py_DECREF(result);\n    result = obj;\n  } else {\n    if (!PyList_Check(result)) {\n      PyObject *o2 = result;\n      result = PyList_New(1);\n      PyList_SetItem(result, 0, o2);\n    }\n    PyList_Append(result,obj);\n    Py_DECREF(obj);\n  }\n  return result;\n#else\n  PyObject*   o2;\n  PyObject*   o3;\n  if (!result) {\n    result = obj;\n  } else if (result == Py_None) {\n    Py_DECREF(result);\n    result = obj;\n  } else {\n    if (!PyTuple_Check(result)) {\n      o2 = result;\n      result = PyTuple_New(1);\n      PyTuple_SET_ITEM(result, 0, o2);\n    }\n    o3 = PyTuple_New(1);\n    PyTuple_SET_ITEM(o3, 0, obj);\n    o2 = result;\n    result = PySequence_Concat(o2, o3);\n    Py_DECREF(o2);\n    Py_DECREF(o3);\n  }\n  return result;\n#endif\n}", "path": "python-midi/src/sequencer_osx/sequencer_osx_wrap.c", "commit_date": "2011-04-20 00:00:00", "repo_name": "vishnubob/python-midi", "stars": 1481, "license": "mit", "language": "c", "size": 208}
{"docstring": "/* Convert a function ptr value */\n", "func_signal": "SWIGRUNTIME int\nSWIG_Python_ConvertFunctionPtr(PyObject *obj, void **ptr, swig_type_info *ty)", "code": "{\n  if (!PyCFunction_Check(obj)) {\n    return SWIG_ConvertPtr(obj, ptr, ty, 0);\n  } else {\n    void *vptr = 0;\n    \n    /* here we get the method pointer for callbacks */\n    const char *doc = (((PyCFunctionObject *)obj) -> m_ml -> ml_doc);\n    const char *desc = doc ? strstr(doc, \"swig_ptr: \") : 0;\n    if (desc) {\n      desc = ty ? SWIG_UnpackVoidPtr(desc + 10, &vptr, ty->name) : 0;\n      if (!desc) return SWIG_ERROR;\n    }\n    if (ty) {\n      swig_cast_info *tc = SWIG_TypeCheck(desc,ty);\n      if (!tc) return SWIG_ERROR;\n      *ptr = SWIG_TypeCast(tc,vptr);\n    } else {\n      *ptr = vptr;\n    }\n    return SWIG_OK;\n  }\n}", "path": "python-midi/src/sequencer_osx/sequencer_osx_wrap.c", "commit_date": "2011-04-20 00:00:00", "repo_name": "vishnubob/python-midi", "stars": 1481, "license": "mit", "language": "c", "size": 208}
{"docstring": "/* This function will propagate the clientdata field of type to\n* any new swig_type_info structures that have been added into the list\n* of equivalent types.  It is like calling\n* SWIG_TypeClientData(type, clientdata) a second time.\n*/\n", "func_signal": "SWIGRUNTIME void\nSWIG_PropagateClientData(void)", "code": "{\n  size_t i;\n  swig_cast_info *equiv;\n  static int init_run = 0;\n  \n  if (init_run) return;\n  init_run = 1;\n  \n  for (i = 0; i < swig_module.size; i++) {\n    if (swig_module.types[i]->clientdata) {\n      equiv = swig_module.types[i]->cast;\n      while (equiv) {\n        if (!equiv->converter) {\n          if (equiv->type && !equiv->type->clientdata)\n          SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);\n        }\n        equiv = equiv->next;\n      }\n    }\n  }\n}", "path": "python-midi/src/sequencer_osx/sequencer_osx_wrap.c", "commit_date": "2011-04-20 00:00:00", "repo_name": "vishnubob/python-midi", "stars": 1481, "license": "mit", "language": "c", "size": 208}
{"docstring": "/* Convert a pointer value */\n", "func_signal": "SWIGRUNTIME int\nSWIG_Python_ConvertPtrAndOwn(PyObject *obj, void **ptr, swig_type_info *ty, int flags, int *own)", "code": "{\n  if (!obj) return SWIG_ERROR;\n  if (obj == Py_None) {\n    if (ptr) *ptr = 0;\n    return SWIG_OK;\n  } else {\n    PySwigObject *sobj = SWIG_Python_GetSwigThis(obj);\n    while (sobj) {\n      void *vptr = sobj->ptr;\n      if (ty) {\n\tswig_type_info *to = sobj->ty;\n\tif (to == ty) {\n\t  /* no type cast needed */\n\t  if (ptr) *ptr = vptr;\n\t  break;\n\t} else {\n\t  swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);\n\t  if (!tc) {\n\t    sobj = (PySwigObject *)sobj->next;\n\t  } else {\n\t    if (ptr) *ptr = SWIG_TypeCast(tc,vptr);\n\t    break;\n\t  }\n\t}\n      } else {\n\tif (ptr) *ptr = vptr;\n\tbreak;\n      }\n    }\n    if (sobj) {\n      if (own) *own = sobj->own;\n      if (flags & SWIG_POINTER_DISOWN) {\n\tsobj->own = 0;\n      }\n      return SWIG_OK;\n    } else {\n      int res = SWIG_ERROR;\n      if (flags & SWIG_POINTER_IMPLICIT_CONV) {\n\tPySwigClientData *data = ty ? (PySwigClientData *) ty->clientdata : 0;\n\tif (data && !data->implicitconv) {\n\t  PyObject *klass = data->klass;\n\t  if (klass) {\n\t    PyObject *impconv;\n\t    data->implicitconv = 1; /* avoid recursion and call 'explicit' constructors*/\n\t    impconv = SWIG_Python_CallFunctor(klass, obj);\n\t    data->implicitconv = 0;\n\t    if (PyErr_Occurred()) {\n\t      PyErr_Clear();\n\t      impconv = 0;\n\t    }\n\t    if (impconv) {\n\t      PySwigObject *iobj = SWIG_Python_GetSwigThis(impconv);\n\t      if (iobj) {\n\t\tvoid *vptr;\n\t\tres = SWIG_Python_ConvertPtrAndOwn((PyObject*)iobj, &vptr, ty, 0, 0);\n\t\tif (SWIG_IsOK(res)) {\n\t\t  if (ptr) {\n\t\t    *ptr = vptr;\n\t\t    /* transfer the ownership to 'ptr' */\n\t\t    iobj->own = 0;\n\t\t    res = SWIG_AddCast(res);\n\t\t    res = SWIG_AddNewMask(res);\n\t\t  } else {\n\t\t    res = SWIG_AddCast(res);\t\t    \n\t\t  }\n\t\t}\n\t      }\n\t      Py_DECREF(impconv);\n\t    }\n\t  }\n\t}\n      }\n      return res;\n    }\n  }\n}", "path": "python-midi/src/sequencer_osx/sequencer_osx_wrap.c", "commit_date": "2011-04-20 00:00:00", "repo_name": "vishnubob/python-midi", "stars": 1481, "license": "mit", "language": "c", "size": 208}
{"docstring": "/*\n  Search for a swig_type_info structure only by mangled name\n  Search is a O(log #types)\n  \n  We start searching at module start, and finish searching when start == end.  \n  Note: if start == end at the beginning of the function, we go all the way around\n  the circular list.\n*/\n", "func_signal": "SWIGRUNTIME swig_type_info *\nSWIG_MangledTypeQueryModule(swig_module_info *start, \n                            swig_module_info *end, \n\t\t            const char *name)", "code": "{\n  swig_module_info *iter = start;\n  do {\n    if (iter->size) {\n      register size_t l = 0;\n      register size_t r = iter->size - 1;\n      do {\n\t/* since l+r >= 0, we can (>> 1) instead (/ 2) */\n\tregister size_t i = (l + r) >> 1; \n\tconst char *iname = iter->types[i]->name;\n\tif (iname) {\n\t  register int compare = strcmp(name, iname);\n\t  if (compare == 0) {\t    \n\t    return iter->types[i];\n\t  } else if (compare < 0) {\n\t    if (i) {\n\t      r = i - 1;\n\t    } else {\n\t      break;\n\t    }\n\t  } else if (compare > 0) {\n\t    l = i + 1;\n\t  }\n\t} else {\n\t  break; /* should never happen */\n\t}\n      } while (l <= r);\n    }\n    iter = iter->next;\n  } while (iter != end);\n  return 0;\n}", "path": "python-midi/src/sequencer_osx/sequencer_osx_wrap.c", "commit_date": "2011-04-20 00:00:00", "repo_name": "vishnubob/python-midi", "stars": 1481, "license": "mit", "language": "c", "size": 208}
{"docstring": "/*\n  Return the pretty name associated with this type,\n  that is an unmangled type name in a form presentable to the user.\n*/\n", "func_signal": "SWIGRUNTIME const char *\nSWIG_TypePrettyName(const swig_type_info *type)", "code": "{\n  /* The \"str\" field contains the equivalent pretty names of the\n     type, separated by vertical-bar characters.  We choose\n     to print the last name, as it is often (?) the most\n     specific. */\n  if (!type) return NULL;\n  if (type->str != NULL) {\n    const char *last_name = type->str;\n    const char *s;\n    for (s = type->str; *s; s++)\n      if (*s == '|') last_name = s+1;\n    return last_name;\n  }\n  else\n    return type->name;\n}", "path": "python-midi/src/sequencer_osx/sequencer_osx_wrap.c", "commit_date": "2011-04-20 00:00:00", "repo_name": "vishnubob/python-midi", "stars": 1481, "license": "mit", "language": "c", "size": 208}
{"docstring": "/* \n   Pack binary data into a string\n*/\n", "func_signal": "SWIGRUNTIME char *\nSWIG_PackData(char *c, void *ptr, size_t sz)", "code": "{\n  static const char hex[17] = \"0123456789abcdef\";\n  register const unsigned char *u = (unsigned char *) ptr;\n  register const unsigned char *eu =  u + sz;\n  for (; u != eu; ++u) {\n    register unsigned char uu = *u;\n    *(c++) = hex[(uu & 0xf0) >> 4];\n    *(c++) = hex[uu & 0xf];\n  }\n  return c;\n}", "path": "python-midi/src/sequencer_osx/sequencer_osx_wrap.c", "commit_date": "2011-04-20 00:00:00", "repo_name": "vishnubob/python-midi", "stars": 1481, "license": "mit", "language": "c", "size": 208}
{"docstring": "/* #define SWIG_PYTHON_SLOW_GETSET_THIS */\n", "func_signal": "SWIGRUNTIME PySwigObject *\nSWIG_Python_GetSwigThis(PyObject *pyobj)", "code": "{\n  if (PySwigObject_Check(pyobj)) {\n    return (PySwigObject *) pyobj;\n  } else {\n    PyObject *obj = 0;\n#if (!defined(SWIG_PYTHON_SLOW_GETSET_THIS) && (PY_VERSION_HEX >= 0x02030000))\n    if (PyInstance_Check(pyobj)) {\n      obj = _PyInstance_Lookup(pyobj, SWIG_This());      \n    } else {\n      PyObject **dictptr = _PyObject_GetDictPtr(pyobj);\n      if (dictptr != NULL) {\n\tPyObject *dict = *dictptr;\n\tobj = dict ? PyDict_GetItem(dict, SWIG_This()) : 0;\n      } else {\n#ifdef PyWeakref_CheckProxy\n\tif (PyWeakref_CheckProxy(pyobj)) {\n\t  PyObject *wobj = PyWeakref_GET_OBJECT(pyobj);\n\t  return wobj ? SWIG_Python_GetSwigThis(wobj) : 0;\n\t}\n#endif\n\tobj = PyObject_GetAttr(pyobj,SWIG_This());\n\tif (obj) {\n\t  Py_DECREF(obj);\n\t} else {\n\t  if (PyErr_Occurred()) PyErr_Clear();\n\t  return 0;\n\t}\n      }\n    }\n#else\n    obj = PyObject_GetAttr(pyobj,SWIG_This());\n    if (obj) {\n      Py_DECREF(obj);\n    } else {\n      if (PyErr_Occurred()) PyErr_Clear();\n      return 0;\n    }\n#endif\n    if (obj && !PySwigObject_Check(obj)) {\n      /* a PyObject is called 'this', try to get the 'real this'\n\t PySwigObject from it */ \n      return SWIG_Python_GetSwigThis(obj);\n    }\n    return (PySwigObject *)obj;\n  }\n}", "path": "python-midi/src/sequencer_osx/sequencer_osx_wrap.c", "commit_date": "2011-04-20 00:00:00", "repo_name": "vishnubob/python-midi", "stars": 1481, "license": "mit", "language": "c", "size": 208}
{"docstring": "/* Compresses current block of data */\n", "func_signal": "static cc_result Deflate_FlushBlock(struct DeflateState* state, int len)", "code": "{\n\tcc_uint32 hash, nextHash;\n\tint bestLen, maxLen, matchLen, depth;\n\tint bestPos, pos, nextPos;\n\tcc_uint16 oldHead;\n\tcc_uint8* input;\n\tcc_uint8* cur;\n\tcc_result res;\n\n\tif (!state->WroteHeader) {\n\t\tstate->WroteHeader = true;\n\t\tDeflate_PushBits(state, 3, 3); /* final block TRUE, block type FIXED */\n\t}\n\n\t/* Based off descriptions from http://www.gzip.org/algorithm.txt and\n\thttps://github.com/nothings/stb/blob/master/stb_image_write.h */\n\tinput = state->Input;\n\tcur   = input + DEFLATE_BLOCK_SIZE;\n\n\t/* Compress current block of data */\n\t/* Use > instead of >=, because also try match at one byte after current */\n\twhile (len > MIN_MATCH_LEN) {\n\t\thash   = Deflate_Hash(cur);\n\t\tmaxLen = min(len, MAX_MATCH_LEN);\n\n\t\tbestLen = MIN_MATCH_LEN - 1; /* Match must be at least 3 bytes */\n\t\tbestPos = 0;\n\n\t\t/* Find longest match starting at this byte */\n\t\t/* Only explore up to 5 previous matches, to avoid slow performance */\n\t\t/* (i.e prefer quickly saving maps/screenshots to completely optimal filesize) */\n\t\tpos = state->Head[hash];\n\t\tfor (depth = 0; pos != 0 && depth < 5; depth++) {\n\t\t\tmatchLen = Deflate_MatchLen(&input[pos], cur, maxLen);\n\t\t\tif (matchLen > bestLen) { bestLen = matchLen; bestPos = pos; }\n\t\t\tpos = state->Prev[pos];\n\t\t}\n\n\t\t/* Insert this entry into the hash chain */\n\t\tpos = (int)(cur - input);\n\t\toldHead = state->Head[hash];\n\t\tstate->Head[hash] = pos;\n\t\tstate->Prev[pos]  = oldHead;\n\n\t\t/* Lazy evaluation: Find longest match starting at next byte */\n\t\t/* If that's longer than the longest match at current byte, throwaway this match */\n\t\tif (bestPos) {\n\t\t\tnextHash = Deflate_Hash(cur + 1);\n\t\t\tnextPos  = state->Head[nextHash];\n\t\t\tmaxLen   = min(len - 1, MAX_MATCH_LEN);\n\n\t\t\tfor (depth = 0; nextPos != 0 && depth < 5; depth++) {\n\t\t\t\tmatchLen = Deflate_MatchLen(&input[nextPos], cur + 1, maxLen);\n\t\t\t\tif (matchLen > bestLen) { bestPos = 0; break; }\n\t\t\t\tnextPos = state->Prev[nextPos];\n\t\t\t}\n\t\t}\n\n\t\tif (bestPos) {\n\t\t\tDeflate_LenDist(state, bestLen, pos - bestPos);\n\t\t\tlen -= bestLen; cur += bestLen;\n\t\t} else {\n\t\t\tDeflate_Lit(state, *cur);\n\t\t\tlen--; cur++;\n\t\t}\n\n\t\t/* leave room for a few bytes and literals at end */\n\t\tif (state->AvailOut >= 20) continue;\n\t\tres = Stream_Write(state->Dest, state->Output, DEFLATE_OUT_SIZE - state->AvailOut);\n\t\tstate->NextOut  = state->Output;\n\t\tstate->AvailOut = DEFLATE_OUT_SIZE;\n\t\tif (res) return res;\n\t}\n\n\t/* literals for last few bytes */\n\twhile (len > 0) {\n\t\tDeflate_Lit(state, *cur);\n\t\tlen--; cur++;\n\t}\n\n\tres = Stream_Write(state->Dest, state->Output, DEFLATE_OUT_SIZE - state->AvailOut);\n\tstate->NextOut  = state->Output;\n\tstate->AvailOut = DEFLATE_OUT_SIZE;\n\n\tDeflate_MoveBlock(state);\n\treturn res;\n}", "path": "ClassiCube/src/Deflate.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "ClassiCube/ClassiCube", "stars": 1128, "license": "other", "language": "c", "size": 37452}
{"docstring": "/*########################################################################################################################*\n*---------------------------------------------------Lighting component----------------------------------------------------*\n*#########################################################################################################################*/\n", "func_signal": "static void OnReset(void)", "code": "{\n\tMem_Free(Lighting_Heightmap);\n\tLighting_Heightmap = NULL;\n}", "path": "ClassiCube/src/Lighting.c", "commit_date": "2020-12-11 00:00:00", "repo_name": "ClassiCube/ClassiCube", "stars": 1128, "license": "other", "language": "c", "size": 37452}
{"docstring": "/* Moves \"current block\" to \"previous block\", adjusting state if needed. */\n", "func_signal": "static void Deflate_MoveBlock(struct DeflateState* state)", "code": "{\n\tint i;\n\tMem_Copy(state->Input, state->Input + DEFLATE_BLOCK_SIZE, DEFLATE_BLOCK_SIZE);\n\tstate->InputPosition = DEFLATE_BLOCK_SIZE;\n\n\t/* adjust hash table offsets, removing offsets that are no longer in data at all */\n\tfor (i = 0; i < Array_Elems(state->Head); i++) {\n\t\tstate->Head[i] = state->Head[i] < DEFLATE_BLOCK_SIZE ? 0 : (state->Head[i] - DEFLATE_BLOCK_SIZE);\n\t}\n\tfor (i = 0; i < Array_Elems(state->Prev); i++) {\n\t\tstate->Prev[i] = state->Prev[i] < DEFLATE_BLOCK_SIZE ? 0 : (state->Prev[i] - DEFLATE_BLOCK_SIZE);\n\t}\n}", "path": "ClassiCube/src/Deflate.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "ClassiCube/ClassiCube", "stars": 1128, "license": "other", "language": "c", "size": 37452}
{"docstring": "/*########################################################################################################################*\n*----------------------------------------------------------Misc-----------------------------------------------------------*\n*#########################################################################################################################*/\n", "func_signal": "int Utils_ParseEnum(const cc_string* text, int defValue, const char* const* names, int namesCount)", "code": "{\n\tint i;\n\tfor (i = 0; i < namesCount; i++) {\n\t\tif (String_CaselessEqualsConst(text, names[i])) return i;\n\t}\n\treturn defValue;\n}", "path": "ClassiCube/src/Utils.c", "commit_date": "2020-12-30 00:00:00", "repo_name": "ClassiCube/ClassiCube", "stars": 1128, "license": "other", "language": "c", "size": 37452}
{"docstring": "/*########################################################################################################################*\n*--------------------------------------------------------Web task---------------------------------------------------------*\n*#########################################################################################################################*/\n", "func_signal": "static void LWebTask_Reset(struct LWebTask* task)", "code": "{\n\ttask->completed = false;\n\ttask->working   = true;\n\ttask->success   = false;\n\ttask->res       = 0;\n\ttask->status    = 0;\n}", "path": "ClassiCube/src/LWeb.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "ClassiCube/ClassiCube", "stars": 1128, "license": "other", "language": "c", "size": 37452}
{"docstring": "/*########################################################################################################################*\n*----------------------------------------------------------World----------------------------------------------------------*\n*#########################################################################################################################*/\n", "func_signal": "static void GenerateNewUuid(void)", "code": "{\n\tRNGState rnd;\n\tint i;\n\tRandom_SeedFromCurrentTime(&rnd);\n\n\t/* seed a bit more randomness for uuid */\n\tfor (i = 0; i < Game_Username.length; i++) {\n\t\tRandom_Next(&rnd, Game_Username.buffer[i] + 3);\n\t}\n\n\tfor (i = 0; i < WORLD_UUID_LEN; i++) {\n\t\tWorld.Uuid[i] = Random_Next(&rnd, 256);\n\t}\n\n\t/* Set version and variant bits */\n\tWorld.Uuid[6] &= 0x0F;\n\tWorld.Uuid[6] |= 0x40; /* version 4*/\n\tWorld.Uuid[8] &= 0x3F;\n\tWorld.Uuid[8] |= 0x80; /* variant 2*/\n}", "path": "ClassiCube/src/World.c", "commit_date": "2020-12-11 00:00:00", "repo_name": "ClassiCube/ClassiCube", "stars": 1128, "license": "other", "language": "c", "size": 37452}
{"docstring": "/* Attempts to read the next huffman encoded value from the bitstream, using given table */\n/* Returns -1 if there are insufficient bits to read the value */\n", "func_signal": "static int Huffman_Decode(struct InflateState* state, struct HuffmanTable* table)", "code": "{\n\tcc_uint32 i, j, codeword;\n\tint packed, bits, offset;\n\n\t/* Buffer as many bits as possible */\n\twhile (state->NumBits <= INFLATE_MAX_BITS) {\n\t\tif (!state->AvailIn) break;\n\t\tInflate_GetByte(state);\n\t}\n\n\t/* Try fast accelerated table lookup */\n\tif (state->NumBits >= INFLATE_FAST_BITS) {\n\t\tpacked = table->Fast[Inflate_PeekBits(state, INFLATE_FAST_BITS)];\n\t\tif (packed >= 0) {\n\t\t\tbits = packed >> INFLATE_FAST_BITS;\n\t\t\tInflate_ConsumeBits(state, bits);\n\t\t\treturn packed & 0x1FF;\n\t\t}\n\t}\n\n\t/* Slow, bit by bit lookup */\n\tcodeword = 0;\n\tfor (i = 1, j = 0; i < INFLATE_MAX_BITS; i++, j++) {\n\t\tif (state->NumBits < i) return -1;\n\t\tcodeword = (codeword << 1) | ((state->Bits >> j) & 1);\n\n\t\tif (codeword < table->EndCodewords[i]) {\n\t\t\toffset = table->FirstOffsets[i] + (codeword - table->FirstCodewords[i]);\n\t\t\tInflate_ConsumeBits(state, i);\n\t\t\treturn table->Values[offset];\n\t\t}\n\t}\n\n\tInflate_Fail(state, INF_ERR_INVALID_CODE);\n\treturn -1;\n}", "path": "ClassiCube/src/Deflate.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "ClassiCube/ClassiCube", "stars": 1128, "license": "other", "language": "c", "size": 37452}
{"docstring": "/*########################################################################################################################*\n*--------------------------------------------------------EntryList--------------------------------------------------------*\n*#########################################################################################################################*/\n", "func_signal": "void EntryList_Load(struct StringsBuffer* list, const char* file, char separator, EntryList_Filter filter)", "code": "{\n\tcc_string entry; char entryBuffer[1024];\n\tcc_string path;\n\tcc_string key, value;\n\tint lineLen, maxLen;\n\n\tcc_uint8 buffer[2048];\n\tstruct Stream stream, buffered;\n\tcc_result res;\n\n\tpath   = String_FromReadonly(file);\n\tmaxLen = list->_lenMask ? list->_lenMask : STRINGSBUFFER_DEF_LEN_MASK;\n\t\n\tres = Stream_OpenFile(&stream, &path);\n\tif (res == ReturnCode_FileNotFound) return;\n\tif (res) { Logger_SysWarn2(res, \"opening\", &path); return; }\n\n\t/* ReadLine reads single byte at a time */\n\tStream_ReadonlyBuffered(&buffered, &stream, buffer, sizeof(buffer));\n\tString_InitArray(entry, entryBuffer);\n\n\tfor (;;) {\n\t\tres = Stream_ReadLine(&buffered, &entry);\n\t\tif (res == ERR_END_OF_STREAM) break;\n\t\tif (res) { Logger_SysWarn2(res, \"reading from\", &path); break; }\n\t\t\n\t\t/* whitespace lines are ignored (e.g. if user manually edits file) */\n\t\tString_UNSAFE_TrimStart(&entry);\n\t\tString_UNSAFE_TrimEnd(&entry);\n\n\t\tif (!entry.length) continue;\n\t\tif (filter && !filter(&entry)) continue;\n\n\t\t/* Sometimes file becomes corrupted and replaced with NULL */\n\t\t/* If don't prevent this here, client aborts in StringsBuffer_Add */\n\t\tif (entry.length > maxLen) {\n\t\t\tlineLen      = entry.length;\n\t\t\tentry.length = 0;\n\t\t\tString_Format2(&entry, \"Skipping very long (%i characters) line in %c, file may be corrupted\", &lineLen, file);\n\t\t\tLogger_WarnFunc(&entry); continue;\n\t\t}\n\n\t\tif (separator) {\n\t\t\tString_UNSAFE_Separate(&entry, separator, &key, &value);\n\t\t\tEntryList_Set(list, &key, &value, separator);\n\t\t} else {\n\t\t\tStringsBuffer_Add(list, &entry);\n\t\t}\n\t}\n\n\tres = stream.Close(&stream);\n\tif (res) { Logger_SysWarn2(res, \"closing\", &path); }\n}", "path": "ClassiCube/src/Utils.c", "commit_date": "2020-12-30 00:00:00", "repo_name": "ClassiCube/ClassiCube", "stars": 1128, "license": "other", "language": "c", "size": 37452}
{"docstring": "/*########################################################################################################################*\n*----------------------------------------------------Lighting update------------------------------------------------------*\n*#########################################################################################################################*/\n", "func_signal": "static void Lighting_UpdateLighting(int x, int y, int z, BlockID oldBlock, BlockID newBlock, int index, int lightH)", "code": "{\n\tcc_bool didBlock  = Blocks.BlocksLight[oldBlock];\n\tcc_bool nowBlocks = Blocks.BlocksLight[newBlock];\n\tint oldOffset     = (Blocks.LightOffset[oldBlock] >> FACE_YMAX) & 1;\n\tint newOffset     = (Blocks.LightOffset[newBlock] >> FACE_YMAX) & 1;\n\tBlockID above;\n\n\t/* Two cases we need to handle here: */\n\tif (didBlock == nowBlocks) {\n\t\tif (!didBlock) return;              /* a) both old and new block do not block light */\n\t\tif (oldOffset == newOffset) return; /* b) both blocks blocked light at the same Y coordinate */\n\t}\n\n\tif ((y - newOffset) >= lightH) {\n\t\tif (nowBlocks) {\n\t\t\tLighting_Heightmap[index] = y - newOffset;\n\t\t} else {\n\t\t\t/* Part of the column is now visible to light, we don't know how exactly how high it should be though. */\n\t\t\t/* However, we know that if the old block was above or equal to light height, then the new light height must be <= old block.y */\n\t\t\tLighting_CalcHeightAt(x, y, z, index);\n\t\t}\n\t} else if (y == lightH && oldOffset == 0) {\n\t\t/* For a solid block on top of an upside down slab, they will both have the same light height. */\n\t\t/* So we need to account for this particular case. */\n\t\tabove = y == (World.Height - 1) ? BLOCK_AIR : World_GetBlock(x, y + 1, z);\n\t\tif (Blocks.BlocksLight[above]) return;\n\n\t\tif (nowBlocks) {\n\t\t\tLighting_Heightmap[index] = y - newOffset;\n\t\t} else {\n\t\t\tLighting_CalcHeightAt(x, y - 1, z, index);\n\t\t}\n\t}\n}", "path": "ClassiCube/src/Lighting.c", "commit_date": "2020-12-11 00:00:00", "repo_name": "ClassiCube/ClassiCube", "stars": 1128, "license": "other", "language": "c", "size": 37452}
{"docstring": "/*########################################################################################################################*\n*-----------------------------------------------------GZip (compress)-----------------------------------------------------*\n*#########################################################################################################################*/\n", "func_signal": "static cc_result GZip_StreamClose(struct Stream* stream)", "code": "{\n\tstruct GZipState* state = (struct GZipState*)stream->Meta.Inflate;\n\tcc_uint8 data[8];\n\tcc_result res;\n\n\tif ((res = Deflate_StreamClose(stream))) return res;\n\tStream_SetU32_LE(&data[0], state->Crc32 ^ 0xFFFFFFFFUL);\n\tStream_SetU32_LE(&data[4], state->Size);\n\treturn Stream_Write(state->Base.Dest, data, sizeof(data));\n}", "path": "ClassiCube/src/Deflate.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "ClassiCube/ClassiCube", "stars": 1128, "license": "other", "language": "c", "size": 37452}
{"docstring": "/*########################################################################################################################*\n*-------------------------------------------------------Respawning--------------------------------------------------------*\n*#########################################################################################################################*/\n", "func_signal": "float Respawn_HighestSolidY(struct AABB* bb)", "code": "{\n\tint minX = Math_Floor(bb->Min.X), maxX = Math_Floor(bb->Max.X);\n\tint minY = Math_Floor(bb->Min.Y), maxY = Math_Floor(bb->Max.Y);\n\tint minZ = Math_Floor(bb->Min.Z), maxZ = Math_Floor(bb->Max.Z);\n\tfloat highestY = RESPAWN_NOT_FOUND;\n\n\tBlockID block;\n\tstruct AABB blockBB;\n\tVec3 v;\n\tint x, y, z;\t\n\n\tfor (y = minY; y <= maxY; y++) { v.Y = (float)y;\n\t\tfor (z = minZ; z <= maxZ; z++) { v.Z = (float)z;\n\t\t\tfor (x = minX; x <= maxX; x++) { v.X = (float)x;\n\n\t\t\t\t/* TODO: Maybe use how picking gets blocks, so the bedrock */\n\t\t\t\t/* just below and just on borders of the map is treated as such */\n\t\t\t\t/* Not sure if this is really necessary though, it seems to work */\n\t\t\t\t/* just fine already when you're standing on the bottom of the map. */\n\t\t\t\tblock = World_SafeGetBlock(x, y, z);\n\t\t\t\tVec3_Add(&blockBB.Min, &v, &Blocks.MinBB[block]);\n\t\t\t\tVec3_Add(&blockBB.Max, &v, &Blocks.MaxBB[block]);\n\n\t\t\t\tif (Blocks.Collide[block] != COLLIDE_SOLID) continue;\n\t\t\t\tif (!AABB_Intersects(bb, &blockBB)) continue;\n\t\t\t\tif (blockBB.Max.Y > highestY) highestY = blockBB.Max.Y;\n\t\t\t}\n\t\t}\n\t}\n\treturn highestY;\n}", "path": "ClassiCube/src/World.c", "commit_date": "2020-12-11 00:00:00", "repo_name": "ClassiCube/ClassiCube", "stars": 1128, "license": "other", "language": "c", "size": 37452}
{"docstring": "/* Builds a huffman tree, based on input lengths of each codeword */\n", "func_signal": "static cc_result Huffman_Build(struct HuffmanTable* table, const cc_uint8* bitLens, int count)", "code": "{\n\tint bl_count[INFLATE_MAX_BITS], bl_offsets[INFLATE_MAX_BITS];\n\tint code, offset, value;\n\tint i, j;\n\n\t/* Initialise 'zero bit length' codewords */\n\ttable->FirstCodewords[0] = 0;\n\ttable->FirstOffsets[0]   = 0;\n\ttable->EndCodewords[0]   = 0;\n\n\t/* Count number of codewords assigned to each bit length */\n\tfor (i = 0; i < INFLATE_MAX_BITS; i++) bl_count[i] = 0;\n\tfor (i = 0; i < count; i++) {\n\t\tbl_count[bitLens[i]]++;\n\t}\n\n\t/* Ensure huffman tree actually makes sense */\n\tbl_count[0] = 0;\n\tfor (i = 1; i < INFLATE_MAX_BITS; i++) {\n\t\t/* Check if too many huffman codes for bit length */\n\t\tif (bl_count[i] > (1 << i)) return INF_ERR_NUM_CODES;\n\t}\n\n\t/* Compute the codewords for the huffman tree.\n\t*  Codewords are ordered, so consider this example tree:\n\t*     2 of length 2, 3 of length 3, 1 of length 4\n\t*  Codewords produced would be: 00,01 100,101,110, 1110 \n\t*/\n\tcode = 0; offset = 0;\n\tfor (i = 1; i < INFLATE_MAX_BITS; i++) {\n\t\tcode = (code + bl_count[i - 1]) << 1;\n\t\tbl_offsets[i] = offset;\n\n\t\ttable->FirstCodewords[i] = code;\n\t\ttable->FirstOffsets[i]   = offset;\n\t\toffset += bl_count[i];\n\n\t\t/* Last codeword is actually: code + (bl_count[i] - 1)\n\t\t*  However, when decoding we peform < against this value though, so need to add 1 here.\n\t\t*  This way, don't need to special case bit lengths with 0 codewords when decoding.\n\t\t*/\n\t\tif (bl_count[i]) {\n\t\t\ttable->EndCodewords[i] = code + bl_count[i];\n\t\t} else {\n\t\t\ttable->EndCodewords[i] = 0;\n\t\t}\n\t}\n\n\t/* Assigns values to each codeword.\n\t*  Note that although codewords are ordered, values may not be.\n\t*  Some values may also not be assigned to any codeword.\n\t*/\n\tvalue = 0;\n\tMem_Set(table->Fast, UInt8_MaxValue, sizeof(table->Fast));\n\tfor (i = 0; i < count; i++, value++) {\n\t\tint len = bitLens[i];\n\t\tif (!len) continue;\n\t\ttable->Values[bl_offsets[len]] = value;\n\n\t\t/* Compute the accelerated lookup table values for this codeword.\n\t\t* For example, assume len = 4 and codeword = 0100\n\t\t* - Shift it left to be 0100_00000\n\t\t* - Then, for all the indices from 0100_00000 to 0100_11111,\n\t\t*   - bit reverse index, as huffman codes are read backwards\n\t\t*   - set fast value to specify a 'value' value, and to skip 'len' bits\n\t\t*/\n\t\tif (len <= INFLATE_FAST_BITS) {\n\t\t\tcc_int16 packed = (cc_int16)((len << INFLATE_FAST_BITS) | value);\n\t\t\tint codeword = table->FirstCodewords[len] + (bl_offsets[len] - table->FirstOffsets[len]);\n\t\t\tcodeword <<= (INFLATE_FAST_BITS - len);\n\n\t\t\tfor (j = 0; j < 1 << (INFLATE_FAST_BITS - len); j++, codeword++) {\n\t\t\t\tint index = Huffman_ReverseBits(codeword, INFLATE_FAST_BITS);\n\t\t\t\ttable->Fast[index] = packed;\n\t\t\t}\n\t\t}\n\t\tbl_offsets[len]++;\n\t}\n\treturn 0;\n}", "path": "ClassiCube/src/Deflate.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "ClassiCube/ClassiCube", "stars": 1128, "license": "other", "language": "c", "size": 37452}
{"docstring": "/* Writes a length-distance pair to state->Output */\n", "func_signal": "static void Deflate_LenDist(struct DeflateState* state, int len, int dist)", "code": "{\n\tint j;\n\t/* TODO: Do we actually need the if (len_bits[j]) ????????? does writing 0 bits matter??? */\n\n\tfor (j = 0; len >= deflate_len[j + 1]; j++);\n\tDeflate_PushLit(state, j + 257);\n\tif (len_bits[j]) { Deflate_PushBits(state, len - deflate_len[j], len_bits[j]); }\n\tDeflate_FlushBits(state);\n\n\tfor (j = 0; dist >= deflate_dist[j + 1]; j++);\n\tDeflate_PushHuff(state, j, 5);\n\tif (dist_bits[j]) { Deflate_PushBits(state, dist - deflate_dist[j], dist_bits[j]); }\n\tDeflate_FlushBits(state);\n}", "path": "ClassiCube/src/Deflate.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "ClassiCube/ClassiCube", "stars": 1128, "license": "other", "language": "c", "size": 37452}
{"docstring": "/* Flushes any buffered data, then writes terminating symbol */\n", "func_signal": "static cc_result Deflate_StreamClose(struct Stream* stream)", "code": "{\n\tstruct DeflateState* state;\n\tcc_result res;\n\n\tstate = (struct DeflateState*)stream->Meta.Inflate;\n\tres   = Deflate_FlushBlock(state, state->InputPosition - DEFLATE_BLOCK_SIZE);\n\tif (res) return res;\n\n\t/* Write huffman encoded \"literal 256\" to terminate symbols */\n\tDeflate_PushLit(state, 256);\n\tDeflate_FlushBits(state);\n\n\t/* In case last byte still has a few extra bits */\n\tif (state->NumBits) {\n\t\twhile (state->NumBits < 8) { Deflate_PushBits(state, 0, 1); }\n\t\tDeflate_FlushBits(state);\n\t}\n\n\treturn Stream_Write(state->Dest, state->Output, DEFLATE_OUT_SIZE - state->AvailOut);\n}", "path": "ClassiCube/src/Deflate.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "ClassiCube/ClassiCube", "stars": 1128, "license": "other", "language": "c", "size": 37452}
{"docstring": "/*########################################################################################################################*\n*---------------------------------------------------Lighting heightmap----------------------------------------------------*\n*#########################################################################################################################*/\n", "func_signal": "static int Lighting_InitialHeightmapCoverage(int x1, int z1, int xCount, int zCount, int* skip)", "code": "{\n\tint elemsLeft = 0, index = 0, curRunCount = 0;\n\tint x, z, hIndex, lightH;\n\n\tfor (z = 0; z < zCount; z++) {\n\t\thIndex = Lighting_Pack(x1, z1 + z);\n\t\tfor (x = 0; x < xCount; x++) {\n\t\t\tlightH = Lighting_Heightmap[hIndex++];\n\n\t\t\tskip[index] = 0;\n\t\t\tif (lightH == HEIGHT_UNCALCULATED) {\n\t\t\t\telemsLeft++;\n\t\t\t\tcurRunCount = 0;\n\t\t\t} else {\n\t\t\t\tskip[index - curRunCount]++;\n\t\t\t\tcurRunCount++;\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\t\tcurRunCount = 0; /* We can only skip an entire X row at most. */\n\t}\n\treturn elemsLeft;\n}", "path": "ClassiCube/src/Lighting.c", "commit_date": "2020-12-11 00:00:00", "repo_name": "ClassiCube/ClassiCube", "stars": 1128, "license": "other", "language": "c", "size": 37452}
{"docstring": "/* Writes a literal to state->Output */\n", "func_signal": "static void Deflate_Lit(struct DeflateState* state, int lit)", "code": "{\n\tDeflate_PushLit(state, lit);\n\tDeflate_FlushBits(state);\n}", "path": "ClassiCube/src/Deflate.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "ClassiCube/ClassiCube", "stars": 1128, "license": "other", "language": "c", "size": 37452}
{"docstring": "/*########################################################################################################################*\n*-----------------------------------------------------ZLib (compress)-----------------------------------------------------*\n*#########################################################################################################################*/\n", "func_signal": "static cc_result ZLib_StreamClose(struct Stream* stream)", "code": "{\n\tstruct ZLibState* state = (struct ZLibState*)stream->Meta.Inflate;\n\tcc_uint8 data[4];\n\tcc_result res;\n\n\tif ((res = Deflate_StreamClose(stream))) return res;\t\n\tStream_SetU32_BE(&data[0], state->Adler32);\n\treturn Stream_Write(state->Base.Dest, data, sizeof(data));\n}", "path": "ClassiCube/src/Deflate.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "ClassiCube/ClassiCube", "stars": 1128, "license": "other", "language": "c", "size": 37452}
{"docstring": "/* Checks if an area is completely black, so Alex skins edited with Microsoft Paint are still treated as Alex */\n", "func_signal": "static cc_bool IsAllBlack(const struct Bitmap* bmp, int x1, int y1, int width, int height)", "code": "{\n\tint x, y;\n\tfor (y = y1; y < y1 + height; y++) {\n\t\tBitmapCol* row = Bitmap_GetRow(bmp, y);\n\n\t\tfor (x = x1; x < x1 + width; x++) {\n\t\t\tif (row[x] != BITMAPCOL_BLACK) return false;\n\t\t}\n\t}\n\treturn true;\n}", "path": "ClassiCube/src/Utils.c", "commit_date": "2020-12-30 00:00:00", "repo_name": "ClassiCube/ClassiCube", "stars": 1128, "license": "other", "language": "c", "size": 37452}
{"docstring": "/* Adds data to buffered output data, flushing if needed */\n", "func_signal": "static cc_result Deflate_StreamWrite(struct Stream* stream, const cc_uint8* data, cc_uint32 total, cc_uint32* modified)", "code": "{\n\tstruct DeflateState* state;\n\tcc_result res;\n\n\tstate = (struct DeflateState*)stream->Meta.Inflate;\n\t*modified = 0;\n\n\twhile (total > 0) {\n\t\tcc_uint8* dst = &state->Input[state->InputPosition];\n\t\tcc_uint32 len = total;\n\t\tif (state->InputPosition + len >= DEFLATE_BUFFER_SIZE) {\n\t\t\tlen = DEFLATE_BUFFER_SIZE - state->InputPosition;\n\t\t}\n\n\t\tMem_Copy(dst, data, len);\n\t\ttotal -= len;\n\t\tstate->InputPosition += len;\n\t\t*modified += len;\n\t\tdata += len;\n\n\t\tif (state->InputPosition == DEFLATE_BUFFER_SIZE) {\n\t\t\tres = Deflate_FlushBlock(state, DEFLATE_BLOCK_SIZE);\n\t\t\tif (res) return res;\n\t\t}\n\t}\n\treturn 0;\n}", "path": "ClassiCube/src/Deflate.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "ClassiCube/ClassiCube", "stars": 1128, "license": "other", "language": "c", "size": 37452}
{"docstring": "/* Scales up flag bitmap if necessary */\n", "func_signal": "static void FetchFlagsTask_Scale(struct Bitmap* bmp)", "code": "{\n\tstruct Bitmap scaled;\n\tint width  = Display_ScaleX(bmp->width);\n\tint height = Display_ScaleY(bmp->height);\n\t/* at default DPI don't need to rescale it */\n\tif (width == bmp->width && height == bmp->height) return;\n\n\tBitmap_TryAllocate(&scaled, width, height);\n\tif (!scaled.scan0) {\n\t\tLogger_SysWarn(ERR_OUT_OF_MEMORY, \"resizing flags bitmap\"); return;\n\t}\n\n\tBitmap_Scale(&scaled, bmp, 0, 0, bmp->width, bmp->height);\n\tMem_Free(bmp->scan0);\n\t*bmp = scaled;\n}", "path": "ClassiCube/src/LWeb.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "ClassiCube/ClassiCube", "stars": 1128, "license": "other", "language": "c", "size": 37452}
{"docstring": "/* This function tries to create a secondary audio buffer, and returns the\n   number of audio chunks available in the created buffer.\n*/\n", "func_signal": "static int\nCreateSecondary(_THIS, HWND focus)", "code": "{\n    LPDIRECTSOUND sndObj = this->hidden->sound;\n    LPDIRECTSOUNDBUFFER *sndbuf = &this->hidden->mixbuf;\n    Uint32 chunksize = this->spec.size;\n    const int numchunks = 8;\n    HRESULT result = DS_OK;\n    DSBUFFERDESC format;\n    LPVOID pvAudioPtr1, pvAudioPtr2;\n    DWORD dwAudioBytes1, dwAudioBytes2;\n    WAVEFORMATEX wfmt;\n\n    SDL_zero(wfmt);\n\n    if (SDL_AUDIO_ISFLOAT(this->spec.format)) {\n        wfmt.wFormatTag = WAVE_FORMAT_IEEE_FLOAT;\n    } else {\n        wfmt.wFormatTag = WAVE_FORMAT_PCM;\n    }\n\n    wfmt.wBitsPerSample = SDL_AUDIO_BITSIZE(this->spec.format);\n    wfmt.nChannels = this->spec.channels;\n    wfmt.nSamplesPerSec = this->spec.freq;\n    wfmt.nBlockAlign = wfmt.nChannels * (wfmt.wBitsPerSample / 8);\n    wfmt.nAvgBytesPerSec = wfmt.nSamplesPerSec * wfmt.nBlockAlign;\n\n    /* Update the fragment size as size in bytes */\n    SDL_CalculateAudioSpec(&this->spec);\n\n    /* Try to set primary mixing privileges */\n    if (focus) {\n        result = IDirectSound_SetCooperativeLevel(sndObj,\n                                                  focus, DSSCL_PRIORITY);\n    } else {\n        result = IDirectSound_SetCooperativeLevel(sndObj,\n                                                  GetDesktopWindow(),\n                                                  DSSCL_NORMAL);\n    }\n    if (result != DS_OK) {\n        return SetDSerror(\"DirectSound SetCooperativeLevel\", result);\n    }\n\n    /* Try to create the secondary buffer */\n    SDL_zero(format);\n    format.dwSize = sizeof(format);\n    format.dwFlags = DSBCAPS_GETCURRENTPOSITION2;\n    if (!focus) {\n        format.dwFlags |= DSBCAPS_GLOBALFOCUS;\n    } else {\n        format.dwFlags |= DSBCAPS_STICKYFOCUS;\n    }\n    format.dwBufferBytes = numchunks * chunksize;\n    if ((format.dwBufferBytes < DSBSIZE_MIN) ||\n        (format.dwBufferBytes > DSBSIZE_MAX)) {\n        return SDL_SetError(\"Sound buffer size must be between %d and %d\",\n                            DSBSIZE_MIN / numchunks, DSBSIZE_MAX / numchunks);\n    }\n    format.dwReserved = 0;\n    format.lpwfxFormat = &wfmt;\n    result = IDirectSound_CreateSoundBuffer(sndObj, &format, sndbuf, NULL);\n    if (result != DS_OK) {\n        return SetDSerror(\"DirectSound CreateSoundBuffer\", result);\n    }\n    IDirectSoundBuffer_SetFormat(*sndbuf, &wfmt);\n\n    /* Silence the initial audio buffer */\n    result = IDirectSoundBuffer_Lock(*sndbuf, 0, format.dwBufferBytes,\n                                     (LPVOID *) & pvAudioPtr1, &dwAudioBytes1,\n                                     (LPVOID *) & pvAudioPtr2, &dwAudioBytes2,\n                                     DSBLOCK_ENTIREBUFFER);\n    if (result == DS_OK) {\n        SDL_memset(pvAudioPtr1, this->spec.silence, dwAudioBytes1);\n        IDirectSoundBuffer_Unlock(*sndbuf,\n                                  (LPVOID) pvAudioPtr1, dwAudioBytes1,\n                                  (LPVOID) pvAudioPtr2, dwAudioBytes2);\n    }\n\n    /* We're ready to go */\n    return (numchunks);\n}", "path": "simplest_ffmpeg_mobile/simplest_sdl_android_helloworld/jni/src/audio/directsound/SDL_directsound.c", "commit_date": "2015-06-29 00:00:00", "repo_name": "leixiaohua1020/simplest_ffmpeg_mobile", "stars": 1913, "license": "None", "language": "c", "size": 91129}
{"docstring": "/* returns number of found touch devices as return value and ids in parameter ids */\n", "func_signal": "int Android_JNI_GetTouchDeviceIds(int **ids)", "code": "{\n    JNIEnv *env = Android_JNI_GetEnv();\n    jint sources = 4098; /* == InputDevice.SOURCE_TOUCHSCREEN */\n    jmethodID mid = (*env)->GetStaticMethodID(env, mActivityClass, \"inputGetInputDeviceIds\", \"(I)[I\");\n    jintArray array = (jintArray) (*env)->CallStaticObjectMethod(env, mActivityClass, mid, sources);\n    int number = 0;\n    *ids = NULL;\n    if (array) {\n        number = (int) (*env)->GetArrayLength(env, array);\n        if (0 < number) {\n            jint* elements = (*env)->GetIntArrayElements(env, array, NULL);\n            if (elements) {\n                int i;\n                *ids = SDL_malloc(number * sizeof (**ids));\n                for (i = 0; i < number; ++i) { /* not assuming sizeof (jint) == sizeof (int) */\n                    (*ids)[i] = elements[i];\n                }\n                (*env)->ReleaseIntArrayElements(env, array, elements, JNI_ABORT);\n            }\n        }\n        (*env)->DeleteLocalRef(env, array);\n    }\n    return number;\n}", "path": "simplest_ffmpeg_mobile/simplest_sdl_android_helloworld/jni/src/core/android/SDL_android.c", "commit_date": "2015-06-29 00:00:00", "repo_name": "leixiaohua1020/simplest_ffmpeg_mobile", "stars": 1913, "license": "None", "language": "c", "size": 91129}
{"docstring": "/* Float to long */\n", "func_signal": "void\n__declspec(naked)\n_ftol()", "code": "{\n    /* *INDENT-OFF* */\n    __asm {\n        push        ebp\n        mov         ebp,esp\n        sub         esp,20h\n        and         esp,0FFFFFFF0h\n        fld         st(0)\n        fst         dword ptr [esp+18h]\n        fistp       qword ptr [esp+10h]\n        fild        qword ptr [esp+10h]\n        mov         edx,dword ptr [esp+18h]\n        mov         eax,dword ptr [esp+10h]\n        test        eax,eax\n        je          integer_QnaN_or_zero\narg_is_not_integer_QnaN:\n        fsubp       st(1),st\n        test        edx,edx\n        jns         positive\n        fstp        dword ptr [esp]\n        mov         ecx,dword ptr [esp]\n        xor         ecx,80000000h\n        add         ecx,7FFFFFFFh\n        adc         eax,0\n        mov         edx,dword ptr [esp+14h]\n        adc         edx,0\n        jmp         localexit\npositive:\n        fstp        dword ptr [esp]\n        mov         ecx,dword ptr [esp]\n        add         ecx,7FFFFFFFh\n        sbb         eax,0\n        mov         edx,dword ptr [esp+14h]\n        sbb         edx,0\n        jmp         localexit\ninteger_QnaN_or_zero:\n        mov         edx,dword ptr [esp+14h]\n        test        edx,7FFFFFFFh\n        jne         arg_is_not_integer_QnaN\n        fstp        dword ptr [esp+18h]\n        fstp        dword ptr [esp+18h]\nlocalexit:\n        leave\n        ret\n    }\n    /* *INDENT-ON* */\n}", "path": "simplest_ffmpeg_mobile/simplest_sdl_android_helloworld/jni/src/stdlib/SDL_stdlib.c", "commit_date": "2015-06-29 00:00:00", "repo_name": "leixiaohua1020/simplest_ffmpeg_mobile", "stars": 1913, "license": "None", "language": "c", "size": 91129}
{"docstring": "/* returns a new global reference which needs to be released later */\n", "func_signal": "static jobject Android_JNI_GetSystemServiceObject(const char* name)", "code": "{\n    struct LocalReferenceHolder refs = LocalReferenceHolder_Setup(__FUNCTION__);\n    JNIEnv* env = Android_JNI_GetEnv();\n    jobject retval = NULL;\n\n    if (!LocalReferenceHolder_Init(&refs, env)) {\n        LocalReferenceHolder_Cleanup(&refs);\n        return NULL;\n    }\n\n    jstring service = (*env)->NewStringUTF(env, name);\n\n    jmethodID mid;\n\n    mid = (*env)->GetStaticMethodID(env, mActivityClass, \"getContext\", \"()Landroid/content/Context;\");\n    jobject context = (*env)->CallStaticObjectMethod(env, mActivityClass, mid);\n\n    mid = (*env)->GetMethodID(env, mActivityClass, \"getSystemServiceFromUiThread\", \"(Ljava/lang/String;)Ljava/lang/Object;\");\n    jobject manager = (*env)->CallObjectMethod(env, context, mid, service);\n\n    (*env)->DeleteLocalRef(env, service);\n\n    retval = manager ? (*env)->NewGlobalRef(env, manager) : NULL;\n    LocalReferenceHolder_Cleanup(&refs);\n    return retval;\n}", "path": "simplest_ffmpeg_mobile/simplest_sdl_android_helloworld/jni/src/core/android/SDL_android.c", "commit_date": "2015-06-29 00:00:00", "repo_name": "leixiaohua1020/simplest_ffmpeg_mobile", "stars": 1913, "license": "None", "language": "c", "size": 91129}
{"docstring": "/* EGL implementation of SDL OpenGL support */\n", "func_signal": "int\nWIN_GLES_LoadLibrary(_THIS, const char *path)", "code": "{\n\n    /* If the profile requested is not GL ES, switch over to WIN_GL functions  */\n    if (_this->gl_config.profile_mask != SDL_GL_CONTEXT_PROFILE_ES) {\n#if SDL_VIDEO_OPENGL_WGL\n        WIN_GLES_UnloadLibrary(_this);\n        _this->GL_LoadLibrary = WIN_GL_LoadLibrary;\n        _this->GL_GetProcAddress = WIN_GL_GetProcAddress;\n        _this->GL_UnloadLibrary = WIN_GL_UnloadLibrary;\n        _this->GL_CreateContext = WIN_GL_CreateContext;\n        _this->GL_MakeCurrent = WIN_GL_MakeCurrent;\n        _this->GL_SetSwapInterval = WIN_GL_SetSwapInterval;\n        _this->GL_GetSwapInterval = WIN_GL_GetSwapInterval;\n        _this->GL_SwapWindow = WIN_GL_SwapWindow;\n        _this->GL_DeleteContext = WIN_GL_DeleteContext;\n        return WIN_GL_LoadLibrary(_this, path);\n#else\n        return SDL_SetError(\"SDL not configured with OpenGL/WGL support\");\n#endif\n    }\n    \n    if (_this->egl_data == NULL) {\n        return SDL_EGL_LoadLibrary(_this, NULL, EGL_DEFAULT_DISPLAY);\n    }\n\n    return 0;\n}", "path": "simplest_ffmpeg_mobile/simplest_sdl_android_helloworld/jni/src/video/windows/SDL_windowsopengles.c", "commit_date": "2015-06-29 00:00:00", "repo_name": "leixiaohua1020/simplest_ffmpeg_mobile", "stars": 1913, "license": "None", "language": "c", "size": 91129}
{"docstring": "/* This function waits until it is possible to write a full sound buffer */\n", "func_signal": "static void\nESD_WaitDevice(_THIS)", "code": "{\n    Sint32 ticks;\n\n    /* Check to see if the thread-parent process is still alive */\n    {\n        static int cnt = 0;\n        /* Note that this only works with thread implementations\n           that use a different process id for each thread.\n         */\n        /* Check every 10 loops */\n        if (this->hidden->parent && (((++cnt) % 10) == 0)) {\n            if (kill(this->hidden->parent, 0) < 0 && errno == ESRCH) {\n                this->enabled = 0;\n            }\n        }\n    }\n\n    /* Use timer for general audio synchronization */\n    ticks = ((Sint32) (this->hidden->next_frame - SDL_GetTicks())) - FUDGE_TICKS;\n    if (ticks > 0) {\n        SDL_Delay(ticks);\n    }\n}", "path": "simplest_ffmpeg_mobile/simplest_sdl_android_helloworld/jni/src/audio/esd/SDL_esdaudio.c", "commit_date": "2015-06-29 00:00:00", "repo_name": "leixiaohua1020/simplest_ffmpeg_mobile", "stars": 1913, "license": "None", "language": "c", "size": 91129}
{"docstring": "/* Resume */\n", "func_signal": "void Java_org_libsdl_app_SDLActivity_nativeResume(\n                                    JNIEnv* env, jclass cls)", "code": "{\n    __android_log_print(ANDROID_LOG_VERBOSE, \"SDL\", \"nativeResume()\");\n\n    if (Android_Window) {\n        SDL_SendAppEvent(SDL_APP_WILLENTERFOREGROUND);\n        SDL_SendAppEvent(SDL_APP_DIDENTERFOREGROUND);\n        SDL_SendWindowEvent(Android_Window, SDL_WINDOWEVENT_FOCUS_GAINED, 0, 0);\n        SDL_SendWindowEvent(Android_Window, SDL_WINDOWEVENT_RESTORED, 0, 0);\n        /* Signal the resume semaphore so the event loop knows to resume and restore the GL Context\n         * We can't restore the GL Context here because it needs to be done on the SDL main thread\n         * and this function will be called from the Java thread instead.\n         */\n        if (!SDL_SemValue(Android_ResumeSem)) SDL_SemPost(Android_ResumeSem);\n    }\n}", "path": "simplest_ffmpeg_mobile/simplest_sdl_android_helloworld/jni/src/core/android/SDL_android.c", "commit_date": "2015-06-29 00:00:00", "repo_name": "leixiaohua1020/simplest_ffmpeg_mobile", "stars": 1913, "license": "None", "language": "c", "size": 91129}
{"docstring": "/* Surface Destroyed */\n", "func_signal": "void Java_org_libsdl_app_SDLActivity_onNativeSurfaceDestroyed(JNIEnv* env, jclass jcls)", "code": "{\n    /* We have to clear the current context and destroy the egl surface here\n     * Otherwise there's BAD_NATIVE_WINDOW errors coming from eglCreateWindowSurface on resume\n     * Ref: http://stackoverflow.com/questions/8762589/eglcreatewindowsurface-on-ics-and-switching-from-2d-to-3d\n     */\n    SDL_WindowData *data;\n    SDL_VideoDevice *_this;\n    \n    if (Android_Window == NULL || Android_Window->driverdata == NULL ) {\n        return;\n    }\n    \n    _this =  SDL_GetVideoDevice();\n    data = (SDL_WindowData *) Android_Window->driverdata;\n    \n    if (data->egl_surface != EGL_NO_SURFACE) {\n        SDL_EGL_MakeCurrent(_this, NULL, NULL);\n        SDL_EGL_DestroySurface(_this, data->egl_surface);\n        data->egl_surface = EGL_NO_SURFACE;\n    }\n    \n    /* GL Context handling is done in the event loop because this function is run from the Java thread */\n\n}", "path": "simplest_ffmpeg_mobile/simplest_sdl_android_helloworld/jni/src/core/android/SDL_android.c", "commit_date": "2015-06-29 00:00:00", "repo_name": "leixiaohua1020/simplest_ffmpeg_mobile", "stars": 1913, "license": "None", "language": "c", "size": 91129}
{"docstring": "/* Accelerometer */\n", "func_signal": "void Java_org_libsdl_app_SDLActivity_onNativeAccel(\n                                    JNIEnv* env, jclass jcls,\n                                    jfloat x, jfloat y, jfloat z)", "code": "{\n    fLastAccelerometer[0] = x;\n    fLastAccelerometer[1] = y;\n    fLastAccelerometer[2] = z;\n    bHasNewData = true;\n}", "path": "simplest_ffmpeg_mobile/simplest_sdl_android_helloworld/jni/src/core/android/SDL_android.c", "commit_date": "2015-06-29 00:00:00", "repo_name": "leixiaohua1020/simplest_ffmpeg_mobile", "stars": 1913, "license": "None", "language": "c", "size": 91129}
{"docstring": "/* Called before SDL_main() to initialize JNI bindings */\n", "func_signal": "void SDL_Android_Init(JNIEnv* mEnv, jclass cls)", "code": "{\n    __android_log_print(ANDROID_LOG_INFO, \"SDL\", \"SDL_Android_Init()\");\n\n    Android_JNI_SetupThread();\n\n    mActivityClass = (jclass)((*mEnv)->NewGlobalRef(mEnv, cls));\n\n    midGetNativeSurface = (*mEnv)->GetStaticMethodID(mEnv, mActivityClass,\n                                \"getNativeSurface\",\"()Landroid/view/Surface;\");\n    midFlipBuffers = (*mEnv)->GetStaticMethodID(mEnv, mActivityClass,\n                                \"flipBuffers\",\"()V\");\n    midAudioInit = (*mEnv)->GetStaticMethodID(mEnv, mActivityClass,\n                                \"audioInit\", \"(IZZI)I\");\n    midAudioWriteShortBuffer = (*mEnv)->GetStaticMethodID(mEnv, mActivityClass,\n                                \"audioWriteShortBuffer\", \"([S)V\");\n    midAudioWriteByteBuffer = (*mEnv)->GetStaticMethodID(mEnv, mActivityClass,\n                                \"audioWriteByteBuffer\", \"([B)V\");\n    midAudioQuit = (*mEnv)->GetStaticMethodID(mEnv, mActivityClass,\n                                \"audioQuit\", \"()V\");\n    midPollInputDevices = (*mEnv)->GetStaticMethodID(mEnv, mActivityClass,\n                                \"pollInputDevices\", \"()V\");\n\n    bHasNewData = false;\n\n    if(!midGetNativeSurface || !midFlipBuffers || !midAudioInit ||\n       !midAudioWriteShortBuffer || !midAudioWriteByteBuffer || !midAudioQuit || !midPollInputDevices) {\n        __android_log_print(ANDROID_LOG_WARN, \"SDL\", \"SDL: Couldn't locate Java callbacks, check that they're named and typed correctly\");\n    }\n    __android_log_print(ANDROID_LOG_INFO, \"SDL\", \"SDL_Android_Init() finished!\");\n}", "path": "simplest_ffmpeg_mobile/simplest_sdl_android_helloworld/jni/src/core/android/SDL_android.c", "commit_date": "2015-06-29 00:00:00", "repo_name": "leixiaohua1020/simplest_ffmpeg_mobile", "stars": 1913, "license": "None", "language": "c", "size": 91129}
{"docstring": "/* sends message to be handled on the UI event dispatch thread */\n", "func_signal": "int Android_JNI_SendMessage(int command, int param)", "code": "{\n    JNIEnv *env = Android_JNI_GetEnv();\n    if (!env) {\n        return -1;\n    }\n    jmethodID mid = (*env)->GetStaticMethodID(env, mActivityClass, \"sendMessage\", \"(II)Z\");\n    if (!mid) {\n        return -1;\n    }\n    jboolean success = (*env)->CallStaticBooleanMethod(env, mActivityClass, mid, command, param);\n    return success ? 0 : -1;\n}", "path": "simplest_ffmpeg_mobile/simplest_sdl_android_helloworld/jni/src/core/android/SDL_android.c", "commit_date": "2015-06-29 00:00:00", "repo_name": "leixiaohua1020/simplest_ffmpeg_mobile", "stars": 1913, "license": "None", "language": "c", "size": 91129}
{"docstring": "/*\n The routine MD5Final terminates the message-digest computation and\n ends with the desired message digest in mdContext->digest[0...15].\n*/\n", "func_signal": "void SDLTest_Md5Final(SDLTest_Md5Context * mdContext)", "code": "{\n  MD5UINT4  in[16];\n  int       mdi;\n  unsigned int i, ii;\n  unsigned int padLen;\n\n  if (mdContext == NULL) return;\n\n  /*\n   * save number of bits\n   */\n  in[14] = mdContext->i[0];\n  in[15] = mdContext->i[1];\n\n  /*\n   * compute number of bytes mod 64\n   */\n  mdi = (int) ((mdContext->i[0] >> 3) & 0x3F);\n\n  /*\n   * pad out to 56 mod 64\n   */\n  padLen = (mdi < 56) ? (56 - mdi) : (120 - mdi);\n  SDLTest_Md5Update(mdContext, MD5PADDING, padLen);\n\n  /*\n   * append length in bits and transform\n   */\n  for (i = 0, ii = 0; i < 14; i++, ii += 4)\n    in[i] = (((MD5UINT4) mdContext->in[ii + 3]) << 24) |\n      (((MD5UINT4) mdContext->in[ii + 2]) << 16) |\n      (((MD5UINT4) mdContext->in[ii + 1]) << 8) |\n      ((MD5UINT4) mdContext->in[ii]);\n  SDLTest_Md5Transform(mdContext->buf, in);\n\n  /*\n   * store buffer in digest\n   */\n  for (i = 0, ii = 0; i < 4; i++, ii += 4) {\n    mdContext->digest[ii] = (unsigned char) (mdContext->buf[i] & 0xFF);\n    mdContext->digest[ii + 1] =\n      (unsigned char) ((mdContext->buf[i] >> 8) & 0xFF);\n    mdContext->digest[ii + 2] =\n      (unsigned char) ((mdContext->buf[i] >> 16) & 0xFF);\n    mdContext->digest[ii + 3] =\n      (unsigned char) ((mdContext->buf[i] >> 24) & 0xFF);\n  }\n}", "path": "simplest_ffmpeg_mobile/simplest_sdl_android_helloworld/jni/src/test/SDL_test_md5.c", "commit_date": "2015-06-29 00:00:00", "repo_name": "leixiaohua1020/simplest_ffmpeg_mobile", "stars": 1913, "license": "None", "language": "c", "size": 91129}
{"docstring": "/*\n The routine MD5Update updates the message-digest context to\n account for the presence of each of the characters inBuf[0..inLen-1]\n in the message whose digest is being computed.\n*/\n", "func_signal": "void SDLTest_Md5Update(SDLTest_Md5Context * mdContext, unsigned char *inBuf,\n          unsigned int inLen)", "code": "{\n  MD5UINT4  in[16];\n  int       mdi;\n  unsigned int i, ii;\n\n  if (mdContext == NULL) return;\n  if (inBuf == NULL || inLen < 1) return;\n\n  /*\n   * compute number of bytes mod 64\n   */\n  mdi = (int) ((mdContext->i[0] >> 3) & 0x3F);\n\n  /*\n   * update number of bits\n   */\n  if ((mdContext->i[0] + ((MD5UINT4) inLen << 3)) < mdContext->i[0])\n    mdContext->i[1]++;\n  mdContext->i[0] += ((MD5UINT4) inLen << 3);\n  mdContext->i[1] += ((MD5UINT4) inLen >> 29);\n\n  while (inLen--) {\n    /*\n     * add new character to buffer, increment mdi\n     */\n    mdContext->in[mdi++] = *inBuf++;\n\n    /*\n     * transform if necessary\n     */\n    if (mdi == 0x40) {\n      for (i = 0, ii = 0; i < 16; i++, ii += 4)\n    in[i] = (((MD5UINT4) mdContext->in[ii + 3]) << 24) |\n      (((MD5UINT4) mdContext->in[ii + 2]) << 16) |\n      (((MD5UINT4) mdContext->in[ii + 1]) << 8) |\n      ((MD5UINT4) mdContext->in[ii]);\n      SDLTest_Md5Transform(mdContext->buf, in);\n      mdi = 0;\n    }\n  }\n}", "path": "simplest_ffmpeg_mobile/simplest_sdl_android_helloworld/jni/src/test/SDL_test_md5.c", "commit_date": "2015-06-29 00:00:00", "repo_name": "leixiaohua1020/simplest_ffmpeg_mobile", "stars": 1913, "license": "None", "language": "c", "size": 91129}
{"docstring": "/* Pause */\n", "func_signal": "void Java_org_libsdl_app_SDLActivity_nativePause(\n                                    JNIEnv* env, jclass cls)", "code": "{\n    __android_log_print(ANDROID_LOG_VERBOSE, \"SDL\", \"nativePause()\");\n    if (Android_Window) {\n        SDL_SendWindowEvent(Android_Window, SDL_WINDOWEVENT_FOCUS_LOST, 0, 0);\n        SDL_SendWindowEvent(Android_Window, SDL_WINDOWEVENT_MINIMIZED, 0, 0);\n        SDL_SendAppEvent(SDL_APP_WILLENTERBACKGROUND);\n        SDL_SendAppEvent(SDL_APP_DIDENTERBACKGROUND);\n    \n        /* *After* sending the relevant events, signal the pause semaphore \n         * so the event loop knows to pause and (optionally) block itself */\n        if (!SDL_SemValue(Android_PauseSem)) SDL_SemPost(Android_PauseSem);\n    }\n}", "path": "simplest_ffmpeg_mobile/simplest_sdl_android_helloworld/jni/src/core/android/SDL_android.c", "commit_date": "2015-06-29 00:00:00", "repo_name": "leixiaohua1020/simplest_ffmpeg_mobile", "stars": 1913, "license": "None", "language": "c", "size": 91129}
{"docstring": "/* Try to get the name of the program */\n", "func_signal": "static char *\nget_progname(void)", "code": "{\n    char *progname = NULL;\n#ifdef __LINUX__\n    FILE *fp;\n    static char temp[BUFSIZ];\n\n    SDL_snprintf(temp, SDL_arraysize(temp), \"/proc/%d/cmdline\", getpid());\n    fp = fopen(temp, \"r\");\n    if (fp != NULL) {\n        if (fgets(temp, sizeof(temp) - 1, fp)) {\n            progname = SDL_strrchr(temp, '/');\n            if (progname == NULL) {\n                progname = temp;\n            } else {\n                progname = progname + 1;\n            }\n        }\n        fclose(fp);\n    }\n#endif\n    return (progname);\n}", "path": "simplest_ffmpeg_mobile/simplest_sdl_android_helloworld/jni/src/audio/esd/SDL_esdaudio.c", "commit_date": "2015-06-29 00:00:00", "repo_name": "leixiaohua1020/simplest_ffmpeg_mobile", "stars": 1913, "license": "None", "language": "c", "size": 91129}
{"docstring": "/* 64-bit math operators for 32-bit systems */\n", "func_signal": "void\n__declspec(naked)\n_allmul()", "code": "{\n    /* *INDENT-OFF* */\n    __asm {\n        push        ebp\n        mov         ebp,esp\n        push        edi\n        push        esi\n        push        ebx\n        sub         esp,0Ch\n        mov         eax,dword ptr [ebp+10h]\n        mov         edi,dword ptr [ebp+8]\n        mov         ebx,eax\n        mov         esi,eax\n        sar         esi,1Fh\n        mov         eax,dword ptr [ebp+8]\n        mul         ebx\n        imul        edi,esi\n        mov         ecx,edx\n        mov         dword ptr [ebp-18h],eax\n        mov         edx,dword ptr [ebp+0Ch]\n        add         ecx,edi\n        imul        ebx,edx\n        mov         eax,dword ptr [ebp-18h]\n        lea         ebx,[ebx+ecx]\n        mov         dword ptr [ebp-14h],ebx\n        mov         edx,dword ptr [ebp-14h]\n        add         esp,0Ch\n        pop         ebx\n        pop         esi\n        pop         edi\n        pop         ebp\n        ret         10h\n    }\n    /* *INDENT-ON* */\n}", "path": "simplest_ffmpeg_mobile/simplest_sdl_android_helloworld/jni/src/stdlib/SDL_stdlib.c", "commit_date": "2015-06-29 00:00:00", "repo_name": "leixiaohua1020/simplest_ffmpeg_mobile", "stars": 1913, "license": "None", "language": "c", "size": 91129}
{"docstring": "/* returns 0 on success or -1 on error (others undefined then)\n * returns truthy or falsy value in plugged, charged and battery\n * returns the value in seconds and percent or -1 if not available\n */\n", "func_signal": "int Android_JNI_GetPowerInfo(int* plugged, int* charged, int* battery, int* seconds, int* percent)", "code": "{\n    struct LocalReferenceHolder refs = LocalReferenceHolder_Setup(__FUNCTION__);\n    JNIEnv* env = Android_JNI_GetEnv();\n    if (!LocalReferenceHolder_Init(&refs, env)) {\n        LocalReferenceHolder_Cleanup(&refs);\n        return -1;\n    }\n\n    jmethodID mid;\n\n    mid = (*env)->GetStaticMethodID(env, mActivityClass, \"getContext\", \"()Landroid/content/Context;\");\n    jobject context = (*env)->CallStaticObjectMethod(env, mActivityClass, mid);\n\n    jstring action = (*env)->NewStringUTF(env, \"android.intent.action.BATTERY_CHANGED\");\n\n    jclass cls = (*env)->FindClass(env, \"android/content/IntentFilter\");\n\n    mid = (*env)->GetMethodID(env, cls, \"<init>\", \"(Ljava/lang/String;)V\");\n    jobject filter = (*env)->NewObject(env, cls, mid, action);\n\n    (*env)->DeleteLocalRef(env, action);\n\n    mid = (*env)->GetMethodID(env, mActivityClass, \"registerReceiver\", \"(Landroid/content/BroadcastReceiver;Landroid/content/IntentFilter;)Landroid/content/Intent;\");\n    jobject intent = (*env)->CallObjectMethod(env, context, mid, NULL, filter);\n\n    (*env)->DeleteLocalRef(env, filter);\n\n    cls = (*env)->GetObjectClass(env, intent);\n\n    jstring iname;\n    jmethodID imid = (*env)->GetMethodID(env, cls, \"getIntExtra\", \"(Ljava/lang/String;I)I\");\n\n#define GET_INT_EXTRA(var, key) \\\n    iname = (*env)->NewStringUTF(env, key); \\\n    int var = (*env)->CallIntMethod(env, intent, imid, iname, -1); \\\n    (*env)->DeleteLocalRef(env, iname);\n\n    jstring bname;\n    jmethodID bmid = (*env)->GetMethodID(env, cls, \"getBooleanExtra\", \"(Ljava/lang/String;Z)Z\");\n\n#define GET_BOOL_EXTRA(var, key) \\\n    bname = (*env)->NewStringUTF(env, key); \\\n    int var = (*env)->CallBooleanMethod(env, intent, bmid, bname, JNI_FALSE); \\\n    (*env)->DeleteLocalRef(env, bname);\n\n    if (plugged) {\n        GET_INT_EXTRA(plug, \"plugged\") /* == BatteryManager.EXTRA_PLUGGED (API 5) */\n        if (plug == -1) {\n            LocalReferenceHolder_Cleanup(&refs);\n            return -1;\n        }\n        /* 1 == BatteryManager.BATTERY_PLUGGED_AC */\n        /* 2 == BatteryManager.BATTERY_PLUGGED_USB */\n        *plugged = (0 < plug) ? 1 : 0;\n    }\n\n    if (charged) {\n        GET_INT_EXTRA(status, \"status\") /* == BatteryManager.EXTRA_STATUS (API 5) */\n        if (status == -1) {\n            LocalReferenceHolder_Cleanup(&refs);\n            return -1;\n        }\n        /* 5 == BatteryManager.BATTERY_STATUS_FULL */\n        *charged = (status == 5) ? 1 : 0;\n    }\n\n    if (battery) {\n        GET_BOOL_EXTRA(present, \"present\") /* == BatteryManager.EXTRA_PRESENT (API 5) */\n        *battery = present ? 1 : 0;\n    }\n\n    if (seconds) {\n        *seconds = -1; /* not possible */\n    }\n\n    if (percent) {\n        GET_INT_EXTRA(level, \"level\") /* == BatteryManager.EXTRA_LEVEL (API 5) */\n        GET_INT_EXTRA(scale, \"scale\") /* == BatteryManager.EXTRA_SCALE (API 5) */\n        if ((level == -1) || (scale == -1)) {\n            LocalReferenceHolder_Cleanup(&refs);\n            return -1;\n        }\n        *percent = level * 100 / scale;\n    }\n\n    (*env)->DeleteLocalRef(env, intent);\n\n    LocalReferenceHolder_Cleanup(&refs);\n    return 0;\n}", "path": "simplest_ffmpeg_mobile/simplest_sdl_android_helloworld/jni/src/core/android/SDL_android.c", "commit_date": "2015-06-29 00:00:00", "repo_name": "leixiaohua1020/simplest_ffmpeg_mobile", "stars": 1913, "license": "None", "language": "c", "size": 91129}
{"docstring": "/* Basic MD5 step. Transforms buf based on in.\n */\n", "func_signal": "static void SDLTest_Md5Transform(MD5UINT4 * buf, MD5UINT4 * in)", "code": "{\n  MD5UINT4  a = buf[0], b = buf[1], c = buf[2], d = buf[3];\n\n  /*\n   * Round 1\n   */\n#define S11 7\n#define S12 12\n#define S13 17\n#define S14 22\n  FF(a, b, c, d, in[0], S11, 3614090360u);  /* 1 */\n  FF(d, a, b, c, in[1], S12, 3905402710u);  /* 2 */\n  FF(c, d, a, b, in[2], S13, 606105819u);   /* 3 */\n  FF(b, c, d, a, in[3], S14, 3250441966u);  /* 4 */\n  FF(a, b, c, d, in[4], S11, 4118548399u);  /* 5 */\n  FF(d, a, b, c, in[5], S12, 1200080426u);  /* 6 */\n  FF(c, d, a, b, in[6], S13, 2821735955u);  /* 7 */\n  FF(b, c, d, a, in[7], S14, 4249261313u);  /* 8 */\n  FF(a, b, c, d, in[8], S11, 1770035416u);  /* 9 */\n  FF(d, a, b, c, in[9], S12, 2336552879u);  /* 10 */\n  FF(c, d, a, b, in[10], S13, 4294925233u); /* 11 */\n  FF(b, c, d, a, in[11], S14, 2304563134u); /* 12 */\n  FF(a, b, c, d, in[12], S11, 1804603682u); /* 13 */\n  FF(d, a, b, c, in[13], S12, 4254626195u); /* 14 */\n  FF(c, d, a, b, in[14], S13, 2792965006u); /* 15 */\n  FF(b, c, d, a, in[15], S14, 1236535329u); /* 16 */\n\n  /*\n   * Round 2\n   */\n#define S21 5\n#define S22 9\n#define S23 14\n#define S24 20\n  GG(a, b, c, d, in[1], S21, 4129170786u);  /* 17 */\n  GG(d, a, b, c, in[6], S22, 3225465664u);  /* 18 */\n  GG(c, d, a, b, in[11], S23, 643717713u);  /* 19 */\n  GG(b, c, d, a, in[0], S24, 3921069994u);  /* 20 */\n  GG(a, b, c, d, in[5], S21, 3593408605u);  /* 21 */\n  GG(d, a, b, c, in[10], S22, 38016083u);   /* 22 */\n  GG(c, d, a, b, in[15], S23, 3634488961u); /* 23 */\n  GG(b, c, d, a, in[4], S24, 3889429448u);  /* 24 */\n  GG(a, b, c, d, in[9], S21, 568446438u);   /* 25 */\n  GG(d, a, b, c, in[14], S22, 3275163606u); /* 26 */\n  GG(c, d, a, b, in[3], S23, 4107603335u);  /* 27 */\n  GG(b, c, d, a, in[8], S24, 1163531501u);  /* 28 */\n  GG(a, b, c, d, in[13], S21, 2850285829u); /* 29 */\n  GG(d, a, b, c, in[2], S22, 4243563512u);  /* 30 */\n  GG(c, d, a, b, in[7], S23, 1735328473u);  /* 31 */\n  GG(b, c, d, a, in[12], S24, 2368359562u); /* 32 */\n\n  /*\n   * Round 3\n   */\n#define S31 4\n#define S32 11\n#define S33 16\n#define S34 23\n  HH(a, b, c, d, in[5], S31, 4294588738u);  /* 33 */\n  HH(d, a, b, c, in[8], S32, 2272392833u);  /* 34 */\n  HH(c, d, a, b, in[11], S33, 1839030562u); /* 35 */\n  HH(b, c, d, a, in[14], S34, 4259657740u); /* 36 */\n  HH(a, b, c, d, in[1], S31, 2763975236u);  /* 37 */\n  HH(d, a, b, c, in[4], S32, 1272893353u);  /* 38 */\n  HH(c, d, a, b, in[7], S33, 4139469664u);  /* 39 */\n  HH(b, c, d, a, in[10], S34, 3200236656u); /* 40 */\n  HH(a, b, c, d, in[13], S31, 681279174u);  /* 41 */\n  HH(d, a, b, c, in[0], S32, 3936430074u);  /* 42 */\n  HH(c, d, a, b, in[3], S33, 3572445317u);  /* 43 */\n  HH(b, c, d, a, in[6], S34, 76029189u);    /* 44 */\n  HH(a, b, c, d, in[9], S31, 3654602809u);  /* 45 */\n  HH(d, a, b, c, in[12], S32, 3873151461u); /* 46 */\n  HH(c, d, a, b, in[15], S33, 530742520u);  /* 47 */\n  HH(b, c, d, a, in[2], S34, 3299628645u);  /* 48 */\n\n  /*\n   * Round 4\n   */\n#define S41 6\n#define S42 10\n#define S43 15\n#define S44 21\n  II(a, b, c, d, in[0], S41, 4096336452u);  /* 49 */\n  II(d, a, b, c, in[7], S42, 1126891415u);  /* 50 */\n  II(c, d, a, b, in[14], S43, 2878612391u); /* 51 */\n  II(b, c, d, a, in[5], S44, 4237533241u);  /* 52 */\n  II(a, b, c, d, in[12], S41, 1700485571u); /* 53 */\n  II(d, a, b, c, in[3], S42, 2399980690u);  /* 54 */\n  II(c, d, a, b, in[10], S43, 4293915773u); /* 55 */\n  II(b, c, d, a, in[1], S44, 2240044497u);  /* 56 */\n  II(a, b, c, d, in[8], S41, 1873313359u);  /* 57 */\n  II(d, a, b, c, in[15], S42, 4264355552u); /* 58 */\n  II(c, d, a, b, in[6], S43, 2734768916u);  /* 59 */\n  II(b, c, d, a, in[13], S44, 1309151649u); /* 60 */\n  II(a, b, c, d, in[4], S41, 4149444226u);  /* 61 */\n  II(d, a, b, c, in[11], S42, 3174756917u); /* 62 */\n  II(c, d, a, b, in[2], S43, 718787259u);   /* 63 */\n  II(b, c, d, a, in[9], S44, 3951481745u);  /* 64 */\n\n  buf[0] += a;\n  buf[1] += b;\n  buf[2] += c;\n  buf[3] += d;\n}", "path": "simplest_ffmpeg_mobile/simplest_sdl_android_helloworld/jni/src/test/SDL_test_md5.c", "commit_date": "2015-06-29 00:00:00", "repo_name": "leixiaohua1020/simplest_ffmpeg_mobile", "stars": 1913, "license": "None", "language": "c", "size": 91129}
{"docstring": "/* Surface Created */\n", "func_signal": "void Java_org_libsdl_app_SDLActivity_onNativeSurfaceChanged(JNIEnv* env, jclass jcls)", "code": "{\n    SDL_WindowData *data;\n    SDL_VideoDevice *_this;\n\n    if (Android_Window == NULL || Android_Window->driverdata == NULL ) {\n        return;\n    }\n    \n    _this =  SDL_GetVideoDevice();\n    data =  (SDL_WindowData *) Android_Window->driverdata;\n    \n    /* If the surface has been previously destroyed by onNativeSurfaceDestroyed, recreate it here */\n    if (data->egl_surface == EGL_NO_SURFACE) {\n        if(data->native_window) {\n            ANativeWindow_release(data->native_window);\n        }\n        data->native_window = Android_JNI_GetNativeWindow();\n        data->egl_surface = SDL_EGL_CreateSurface(_this, (NativeWindowType) data->native_window);\n    }\n    \n    /* GL Context handling is done in the event loop because this function is run from the Java thread */\n    \n}", "path": "simplest_ffmpeg_mobile/simplest_sdl_android_helloworld/jni/src/core/android/SDL_android.c", "commit_date": "2015-06-29 00:00:00", "repo_name": "leixiaohua1020/simplest_ffmpeg_mobile", "stars": 1913, "license": "None", "language": "c", "size": 91129}
{"docstring": "/* Test for an exception and call SDL_SetError with its detail if one occurs */\n/* If the parameter silent is truthy then SDL_SetError() will not be called. */\n", "func_signal": "static bool Android_JNI_ExceptionOccurred(bool silent)", "code": "{\n    SDL_assert(LocalReferenceHolder_IsActive());\n    JNIEnv *mEnv = Android_JNI_GetEnv();\n\n    jthrowable exception = (*mEnv)->ExceptionOccurred(mEnv);\n    if (exception != NULL) {\n        jmethodID mid;\n\n        /* Until this happens most JNI operations have undefined behaviour */\n        (*mEnv)->ExceptionClear(mEnv);\n\n        if (!silent) {\n            jclass exceptionClass = (*mEnv)->GetObjectClass(mEnv, exception);\n            jclass classClass = (*mEnv)->FindClass(mEnv, \"java/lang/Class\");\n\n            mid = (*mEnv)->GetMethodID(mEnv, classClass, \"getName\", \"()Ljava/lang/String;\");\n            jstring exceptionName = (jstring)(*mEnv)->CallObjectMethod(mEnv, exceptionClass, mid);\n            const char* exceptionNameUTF8 = (*mEnv)->GetStringUTFChars(mEnv, exceptionName, 0);\n\n            mid = (*mEnv)->GetMethodID(mEnv, exceptionClass, \"getMessage\", \"()Ljava/lang/String;\");\n            jstring exceptionMessage = (jstring)(*mEnv)->CallObjectMethod(mEnv, exception, mid);\n\n            if (exceptionMessage != NULL) {\n                const char* exceptionMessageUTF8 = (*mEnv)->GetStringUTFChars(mEnv, exceptionMessage, 0);\n                SDL_SetError(\"%s: %s\", exceptionNameUTF8, exceptionMessageUTF8);\n                (*mEnv)->ReleaseStringUTFChars(mEnv, exceptionMessage, exceptionMessageUTF8);\n            } else {\n                SDL_SetError(\"%s\", exceptionNameUTF8);\n            }\n\n            (*mEnv)->ReleaseStringUTFChars(mEnv, exceptionName, exceptionNameUTF8);\n        }\n\n        return true;\n    }\n\n    return false;\n}", "path": "simplest_ffmpeg_mobile/simplest_sdl_android_helloworld/jni/src/core/android/SDL_android.c", "commit_date": "2015-06-29 00:00:00", "repo_name": "leixiaohua1020/simplest_ffmpeg_mobile", "stars": 1913, "license": "None", "language": "c", "size": 91129}
{"docstring": "/* parse_emph3 \u2022 parsing single emphase */\n/* finds the first closing tag, and delegates to the other emph */\n", "func_signal": "static size_t\nparse_emph3(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size, uint8_t c)", "code": "{\n\tsize_t i = 0, len;\n\tint r;\n\n\twhile (i < size) {\n\t\tlen = find_emph_char(data + i, size - i, c);\n\t\tif (!len) return 0;\n\t\ti += len;\n\n\t\t/* skip whitespace preceded symbols */\n\t\tif (data[i] != c || _isspace(data[i - 1]))\n\t\t\tcontinue;\n\n\t\tif (i + 2 < size && data[i + 1] == c && data[i + 2] == c && rndr->cb.triple_emphasis) {\n\t\t\t/* triple symbol found */\n\t\t\tstruct buf *work = rndr_newbuf(rndr, BUFFER_SPAN);\n\n\t\t\tparse_inline(work, rndr, data, i);\n\t\t\tr = rndr->cb.triple_emphasis(ob, work, rndr->opaque);\n\t\t\trndr_popbuf(rndr, BUFFER_SPAN);\n\t\t\treturn r ? i + 3 : 0;\n\n\t\t} else if (i + 1 < size && data[i + 1] == c) {\n\t\t\t/* double symbol found, handing over to emph1 */\n\t\t\tlen = parse_emph1(ob, rndr, data - 2, size + 2, c);\n\t\t\tif (!len) return 0;\n\t\t\telse return len - 2;\n\n\t\t} else {\n\t\t\t/* single symbol found, handing over to emph2 */\n\t\t\tlen = parse_emph2(ob, rndr, data - 1, size + 1, c);\n\t\t\tif (!len) return 0;\n\t\t\telse return len - 1;\n\t\t}\n\t}\n\treturn 0;\n}", "path": "sundown/src/markdown.c", "commit_date": "2012-10-19 00:00:00", "repo_name": "vmg/sundown", "stars": 1970, "license": "None", "language": "c", "size": 1219}
{"docstring": "/* is_atxheader \u2022 returns whether the line is a hash-prefixed header */\n", "func_signal": "static int\nis_atxheader(struct sd_markdown *rndr, uint8_t *data, size_t size)", "code": "{\n\tif (data[0] != '#')\n\t\treturn 0;\n\n\tif (rndr->ext_flags & MKDEXT_SPACE_HEADERS) {\n\t\tsize_t level = 0;\n\n\t\twhile (level < size && level < 6 && data[level] == '#')\n\t\t\tlevel++;\n\n\t\tif (level < size && data[level] != ' ')\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}", "path": "sundown/src/markdown.c", "commit_date": "2012-10-19 00:00:00", "repo_name": "vmg/sundown", "stars": 1970, "license": "None", "language": "c", "size": 1219}
{"docstring": "/* tag_length \u2022 returns the length of the given tag, or 0 is it's not valid */\n", "func_signal": "static size_t\ntag_length(uint8_t *data, size_t size, enum mkd_autolink *autolink)", "code": "{\n\tsize_t i, j;\n\n\t/* a valid tag can't be shorter than 3 chars */\n\tif (size < 3) return 0;\n\n\t/* begins with a '<' optionally followed by '/', followed by letter or number */\n\tif (data[0] != '<') return 0;\n\ti = (data[1] == '/') ? 2 : 1;\n\n\tif (!isalnum(data[i]))\n\t\treturn 0;\n\n\t/* scheme test */\n\t*autolink = MKDA_NOT_AUTOLINK;\n\n\t/* try to find the beginning of an URI */\n\twhile (i < size && (isalnum(data[i]) || data[i] == '.' || data[i] == '+' || data[i] == '-'))\n\t\ti++;\n\n\tif (i > 1 && data[i] == '@') {\n\t\tif ((j = is_mail_autolink(data + i, size - i)) != 0) {\n\t\t\t*autolink = MKDA_EMAIL;\n\t\t\treturn i + j;\n\t\t}\n\t}\n\n\tif (i > 2 && data[i] == ':') {\n\t\t*autolink = MKDA_NORMAL;\n\t\ti++;\n\t}\n\n\t/* completing autolink test: no whitespace or ' or \" */\n\tif (i >= size)\n\t\t*autolink = MKDA_NOT_AUTOLINK;\n\n\telse if (*autolink) {\n\t\tj = i;\n\n\t\twhile (i < size) {\n\t\t\tif (data[i] == '\\\\') i += 2;\n\t\t\telse if (data[i] == '>' || data[i] == '\\'' ||\n\t\t\t\t\tdata[i] == '\"' || data[i] == ' ' || data[i] == '\\n')\n\t\t\t\t\tbreak;\n\t\t\telse i++;\n\t\t}\n\n\t\tif (i >= size) return 0;\n\t\tif (i > j && data[i] == '>') return i + 1;\n\t\t/* one of the forbidden chars has been found */\n\t\t*autolink = MKDA_NOT_AUTOLINK;\n\t}\n\n\t/* looking for sometinhg looking like a tag end */\n\twhile (i < size && data[i] != '>') i++;\n\tif (i >= size) return 0;\n\treturn i + 1;\n}", "path": "sundown/src/markdown.c", "commit_date": "2012-10-19 00:00:00", "repo_name": "vmg/sundown", "stars": 1970, "license": "None", "language": "c", "size": 1219}
{"docstring": "/* htmlblock_end \u2022 checking end of HTML block : </tag>[ \\t]*\\n[ \\t*]\\n */\n/*\treturns the length on match, 0 otherwise */\n", "func_signal": "static size_t\nhtmlblock_end_tag(\n\tconst char *tag,\n\tsize_t tag_len,\n\tstruct sd_markdown *rndr,\n\tuint8_t *data,\n\tsize_t size)", "code": "{\n\tsize_t i, w;\n\n\t/* checking if tag is a match */\n\tif (tag_len + 3 >= size ||\n\t\tstrncasecmp((char *)data + 2, tag, tag_len) != 0 ||\n\t\tdata[tag_len + 2] != '>')\n\t\treturn 0;\n\n\t/* checking white lines */\n\ti = tag_len + 3;\n\tw = 0;\n\tif (i < size && (w = is_empty(data + i, size - i)) == 0)\n\t\treturn 0; /* non-blank after tag */\n\ti += w;\n\tw = 0;\n\n\tif (i < size)\n\t\tw = is_empty(data + i, size - i);\n\n\treturn i + w;\n}", "path": "sundown/src/markdown.c", "commit_date": "2012-10-19 00:00:00", "repo_name": "vmg/sundown", "stars": 1970, "license": "None", "language": "c", "size": 1219}
{"docstring": "/* parse_htmlblock \u2022 parsing of inline HTML block */\n", "func_signal": "static size_t\nparse_htmlblock(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size, int do_render)", "code": "{\n\tsize_t i, j = 0, tag_end;\n\tconst char *curtag = NULL;\n\tstruct buf work = { data, 0, 0, 0 };\n\n\t/* identification of the opening tag */\n\tif (size < 2 || data[0] != '<')\n\t\treturn 0;\n\n\ti = 1;\n\twhile (i < size && data[i] != '>' && data[i] != ' ')\n\t\ti++;\n\n\tif (i < size)\n\t\tcurtag = find_block_tag((char *)data + 1, (int)i - 1);\n\n\t/* handling of special cases */\n\tif (!curtag) {\n\n\t\t/* HTML comment, laxist form */\n\t\tif (size > 5 && data[1] == '!' && data[2] == '-' && data[3] == '-') {\n\t\t\ti = 5;\n\n\t\t\twhile (i < size && !(data[i - 2] == '-' && data[i - 1] == '-' && data[i] == '>'))\n\t\t\t\ti++;\n\n\t\t\ti++;\n\n\t\t\tif (i < size)\n\t\t\t\tj = is_empty(data + i, size - i);\n\n\t\t\tif (j) {\n\t\t\t\twork.size = i + j;\n\t\t\t\tif (do_render && rndr->cb.blockhtml)\n\t\t\t\t\trndr->cb.blockhtml(ob, &work, rndr->opaque);\n\t\t\t\treturn work.size;\n\t\t\t}\n\t\t}\n\n\t\t/* HR, which is the only self-closing block tag considered */\n\t\tif (size > 4 && (data[1] == 'h' || data[1] == 'H') && (data[2] == 'r' || data[2] == 'R')) {\n\t\t\ti = 3;\n\t\t\twhile (i < size && data[i] != '>')\n\t\t\t\ti++;\n\n\t\t\tif (i + 1 < size) {\n\t\t\t\ti++;\n\t\t\t\tj = is_empty(data + i, size - i);\n\t\t\t\tif (j) {\n\t\t\t\t\twork.size = i + j;\n\t\t\t\t\tif (do_render && rndr->cb.blockhtml)\n\t\t\t\t\t\trndr->cb.blockhtml(ob, &work, rndr->opaque);\n\t\t\t\t\treturn work.size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* no special case recognised */\n\t\treturn 0;\n\t}\n\n\t/* looking for an unindented matching closing tag */\n\t/*\tfollowed by a blank line */\n\ttag_end = htmlblock_end(curtag, rndr, data, size, 1);\n\n\t/* if not found, trying a second pass looking for indented match */\n\t/* but not if tag is \"ins\" or \"del\" (following original Markdown.pl) */\n\tif (!tag_end && strcmp(curtag, \"ins\") != 0 && strcmp(curtag, \"del\") != 0) {\n\t\ttag_end = htmlblock_end(curtag, rndr, data, size, 0);\n\t}\n\n\tif (!tag_end)\n\t\treturn 0;\n\n\t/* the end of the block has been found */\n\twork.size = tag_end;\n\tif (do_render && rndr->cb.blockhtml)\n\t\trndr->cb.blockhtml(ob, &work, rndr->opaque);\n\n\treturn tag_end;\n}", "path": "sundown/src/markdown.c", "commit_date": "2012-10-19 00:00:00", "repo_name": "vmg/sundown", "stars": 1970, "license": "None", "language": "c", "size": 1219}
{"docstring": "/* bufnullterm: NULL-termination of the string array */\n", "func_signal": "const char *\nbufcstr(struct buf *buf)", "code": "{\n\tassert(buf && buf->unit);\n\n\tif (buf->size < buf->asize && buf->data[buf->size] == 0)\n\t\treturn (char *)buf->data;\n\n\tif (buf->size + 1 <= buf->asize || bufgrow(buf, buf->size + 1) == 0) {\n\t\tbuf->data[buf->size] = 0;\n\t\treturn (char *)buf->data;\n\t}\n\n\treturn NULL;\n}", "path": "sundown/src/buffer.c", "commit_date": "2012-05-02 00:00:00", "repo_name": "vmg/sundown", "stars": 1970, "license": "None", "language": "c", "size": 1219}
{"docstring": "/* find_emph_char \u2022 looks for the next emph uint8_t, skipping other constructs */\n", "func_signal": "static size_t\nfind_emph_char(uint8_t *data, size_t size, uint8_t c)", "code": "{\n\tsize_t i = 1;\n\n\twhile (i < size) {\n\t\twhile (i < size && data[i] != c && data[i] != '`' && data[i] != '[')\n\t\t\ti++;\n\n\t\tif (i == size)\n\t\t\treturn 0;\n\n\t\tif (data[i] == c)\n\t\t\treturn i;\n\n\t\t/* not counting escaped chars */\n\t\tif (i && data[i - 1] == '\\\\') {\n\t\t\ti++; continue;\n\t\t}\n\n\t\tif (data[i] == '`') {\n\t\t\tsize_t span_nb = 0, bt;\n\t\t\tsize_t tmp_i = 0;\n\n\t\t\t/* counting the number of opening backticks */\n\t\t\twhile (i < size && data[i] == '`') {\n\t\t\t\ti++; span_nb++;\n\t\t\t}\n\n\t\t\tif (i >= size) return 0;\n\n\t\t\t/* finding the matching closing sequence */\n\t\t\tbt = 0;\n\t\t\twhile (i < size && bt < span_nb) {\n\t\t\t\tif (!tmp_i && data[i] == c) tmp_i = i;\n\t\t\t\tif (data[i] == '`') bt++;\n\t\t\t\telse bt = 0;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tif (i >= size) return tmp_i;\n\t\t}\n\t\t/* skipping a link */\n\t\telse if (data[i] == '[') {\n\t\t\tsize_t tmp_i = 0;\n\t\t\tuint8_t cc;\n\n\t\t\ti++;\n\t\t\twhile (i < size && data[i] != ']') {\n\t\t\t\tif (!tmp_i && data[i] == c) tmp_i = i;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\ti++;\n\t\t\twhile (i < size && (data[i] == ' ' || data[i] == '\\n'))\n\t\t\t\ti++;\n\n\t\t\tif (i >= size)\n\t\t\t\treturn tmp_i;\n\n\t\t\tswitch (data[i]) {\n\t\t\tcase '[':\n\t\t\t\tcc = ']'; break;\n\n\t\t\tcase '(':\n\t\t\t\tcc = ')'; break;\n\n\t\t\tdefault:\n\t\t\t\tif (tmp_i)\n\t\t\t\t\treturn tmp_i;\n\t\t\t\telse\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ti++;\n\t\t\twhile (i < size && data[i] != cc) {\n\t\t\t\tif (!tmp_i && data[i] == c) tmp_i = i;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tif (i >= size)\n\t\t\t\treturn tmp_i;\n\n\t\t\ti++;\n\t\t}\n\t}\n\n\treturn 0;\n}", "path": "sundown/src/markdown.c", "commit_date": "2012-10-19 00:00:00", "repo_name": "vmg/sundown", "stars": 1970, "license": "None", "language": "c", "size": 1219}
{"docstring": "/* bufput: appends raw data to a buffer */\n", "func_signal": "void\nbufput(struct buf *buf, const void *data, size_t len)", "code": "{\n\tassert(buf && buf->unit);\n\n\tif (buf->size + len > buf->asize && bufgrow(buf, buf->size + len) < 0)\n\t\treturn;\n\n\tmemcpy(buf->data + buf->size, data, len);\n\tbuf->size += len;\n}", "path": "sundown/src/buffer.c", "commit_date": "2012-05-02 00:00:00", "repo_name": "vmg/sundown", "stars": 1970, "license": "None", "language": "c", "size": 1219}
{"docstring": "/* bufreset: frees internal data of the buffer */\n", "func_signal": "void\nbufreset(struct buf *buf)", "code": "{\n\tif (!buf)\n\t\treturn;\n\n\tfree(buf->data);\n\tbuf->data = NULL;\n\tbuf->size = buf->asize = 0;\n}", "path": "sundown/src/buffer.c", "commit_date": "2012-05-02 00:00:00", "repo_name": "vmg/sundown", "stars": 1970, "license": "None", "language": "c", "size": 1219}
{"docstring": "/* parse_list \u2022 parsing ordered or unordered list block */\n", "func_signal": "static size_t\nparse_list(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size, int flags)", "code": "{\n\tstruct buf *work = 0;\n\tsize_t i = 0, j;\n\n\twork = rndr_newbuf(rndr, BUFFER_BLOCK);\n\n\twhile (i < size) {\n\t\tj = parse_listitem(work, rndr, data + i, size - i, &flags);\n\t\ti += j;\n\n\t\tif (!j || (flags & MKD_LI_END))\n\t\t\tbreak;\n\t}\n\n\tif (rndr->cb.list)\n\t\trndr->cb.list(ob, work, flags, rndr->opaque);\n\trndr_popbuf(rndr, BUFFER_BLOCK);\n\treturn i;\n}", "path": "sundown/src/markdown.c", "commit_date": "2012-10-19 00:00:00", "repo_name": "vmg/sundown", "stars": 1970, "license": "None", "language": "c", "size": 1219}
{"docstring": "/* prefix_code \u2022 returns prefix length for block code*/\n", "func_signal": "static size_t\nprefix_code(uint8_t *data, size_t size)", "code": "{\n\tif (size > 3 && data[0] == ' ' && data[1] == ' '\n\t\t&& data[2] == ' ' && data[3] == ' ') return 4;\n\n\treturn 0;\n}", "path": "sundown/src/markdown.c", "commit_date": "2012-10-19 00:00:00", "repo_name": "vmg/sundown", "stars": 1970, "license": "None", "language": "c", "size": 1219}
{"docstring": "/* char_langle_tag \u2022 '<' when tags or autolinks are allowed */\n", "func_signal": "static size_t\nchar_langle_tag(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)", "code": "{\n\tenum mkd_autolink altype = MKDA_NOT_AUTOLINK;\n\tsize_t end = tag_length(data, size, &altype);\n\tstruct buf work = { data, end, 0, 0 };\n\tint ret = 0;\n\n\tif (end > 2) {\n\t\tif (rndr->cb.autolink && altype != MKDA_NOT_AUTOLINK) {\n\t\t\tstruct buf *u_link = rndr_newbuf(rndr, BUFFER_SPAN);\n\t\t\twork.data = data + 1;\n\t\t\twork.size = end - 2;\n\t\t\tunscape_text(u_link, &work);\n\t\t\tret = rndr->cb.autolink(ob, u_link, altype, rndr->opaque);\n\t\t\trndr_popbuf(rndr, BUFFER_SPAN);\n\t\t}\n\t\telse if (rndr->cb.raw_html_tag)\n\t\t\tret = rndr->cb.raw_html_tag(ob, &work, rndr->opaque);\n\t}\n\n\tif (!ret) return 0;\n\telse return end;\n}", "path": "sundown/src/markdown.c", "commit_date": "2012-10-19 00:00:00", "repo_name": "vmg/sundown", "stars": 1970, "license": "None", "language": "c", "size": 1219}
{"docstring": "/* char_entity \u2022 '&' escaped when it doesn't belong to an entity */\n/* valid entities are assumed to be anything matching &#?[A-Za-z0-9]+; */\n", "func_signal": "static size_t\nchar_entity(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)", "code": "{\n\tsize_t end = 1;\n\tstruct buf work = { 0, 0, 0, 0 };\n\n\tif (end < size && data[end] == '#')\n\t\tend++;\n\n\twhile (end < size && isalnum(data[end]))\n\t\tend++;\n\n\tif (end < size && data[end] == ';')\n\t\tend++; /* real entity */\n\telse\n\t\treturn 0; /* lone '&' */\n\n\tif (rndr->cb.entity) {\n\t\twork.data = data;\n\t\twork.size = end;\n\t\trndr->cb.entity(ob, &work, rndr->opaque);\n\t}\n\telse bufput(ob, data, end);\n\n\treturn end;\n}", "path": "sundown/src/markdown.c", "commit_date": "2012-10-19 00:00:00", "repo_name": "vmg/sundown", "stars": 1970, "license": "None", "language": "c", "size": 1219}
{"docstring": "/* parse_atxheader \u2022 parsing of atx-style headers */\n", "func_signal": "static size_t\nparse_atxheader(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size)", "code": "{\n\tsize_t level = 0;\n\tsize_t i, end, skip;\n\n\twhile (level < size && level < 6 && data[level] == '#')\n\t\tlevel++;\n\n\tfor (i = level; i < size && data[i] == ' '; i++);\n\n\tfor (end = i; end < size && data[end] != '\\n'; end++);\n\tskip = end;\n\n\twhile (end && data[end - 1] == '#')\n\t\tend--;\n\n\twhile (end && data[end - 1] == ' ')\n\t\tend--;\n\n\tif (end > i) {\n\t\tstruct buf *work = rndr_newbuf(rndr, BUFFER_SPAN);\n\n\t\tparse_inline(work, rndr, data + i, end - i);\n\n\t\tif (rndr->cb.header)\n\t\t\trndr->cb.header(ob, work, (int)level, rndr->opaque);\n\n\t\trndr_popbuf(rndr, BUFFER_SPAN);\n\t}\n\n\treturn skip;\n}", "path": "sundown/src/markdown.c", "commit_date": "2012-10-19 00:00:00", "repo_name": "vmg/sundown", "stars": 1970, "license": "None", "language": "c", "size": 1219}
{"docstring": "/* char_linebreak \u2022 '\\n' preceded by two spaces (assuming linebreak != 0) */\n", "func_signal": "static size_t\nchar_linebreak(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)", "code": "{\n\tif (offset < 2 || data[-1] != ' ' || data[-2] != ' ')\n\t\treturn 0;\n\n\t/* removing the last space from ob and rendering */\n\twhile (ob->size && ob->data[ob->size - 1] == ' ')\n\t\tob->size--;\n\n\treturn rndr->cb.linebreak(ob, rndr->opaque) ? 1 : 0;\n}", "path": "sundown/src/markdown.c", "commit_date": "2012-10-19 00:00:00", "repo_name": "vmg/sundown", "stars": 1970, "license": "None", "language": "c", "size": 1219}
{"docstring": "/* check if a line begins with a code fence; return the\n * width of the code fence */\n", "func_signal": "static size_t\nprefix_codefence(uint8_t *data, size_t size)", "code": "{\n\tsize_t i = 0, n = 0;\n\tuint8_t c;\n\n\t/* skipping initial spaces */\n\tif (size < 3) return 0;\n\tif (data[0] == ' ') { i++;\n\tif (data[1] == ' ') { i++;\n\tif (data[2] == ' ') { i++; } } }\n\n\t/* looking at the hrule uint8_t */\n\tif (i + 2 >= size || !(data[i] == '~' || data[i] == '`'))\n\t\treturn 0;\n\n\tc = data[i];\n\n\t/* the whole line must be the uint8_t or whitespace */\n\twhile (i < size && data[i] == c) {\n\t\tn++; i++;\n\t}\n\n\tif (n < 3)\n\t\treturn 0;\n\n\treturn i;\n}", "path": "sundown/src/markdown.c", "commit_date": "2012-10-19 00:00:00", "repo_name": "vmg/sundown", "stars": 1970, "license": "None", "language": "c", "size": 1219}
{"docstring": "/* prefix_quote \u2022 returns blockquote prefix length */\n", "func_signal": "static size_t\nprefix_quote(uint8_t *data, size_t size)", "code": "{\n\tsize_t i = 0;\n\tif (i < size && data[i] == ' ') i++;\n\tif (i < size && data[i] == ' ') i++;\n\tif (i < size && data[i] == ' ') i++;\n\n\tif (i < size && data[i] == '>') {\n\t\tif (i + 1 < size && data[i + 1] == ' ')\n\t\t\treturn i + 2;\n\n\t\treturn i + 1;\n\t}\n\n\treturn 0;\n}", "path": "sundown/src/markdown.c", "commit_date": "2012-10-19 00:00:00", "repo_name": "vmg/sundown", "stars": 1970, "license": "None", "language": "c", "size": 1219}
{"docstring": "/* bufrelease: decrease the reference count and free the buffer if needed */\n", "func_signal": "void\nbufrelease(struct buf *buf)", "code": "{\n\tif (!buf)\n\t\treturn;\n\n\tfree(buf->data);\n\tfree(buf);\n}", "path": "sundown/src/buffer.c", "commit_date": "2012-05-02 00:00:00", "repo_name": "vmg/sundown", "stars": 1970, "license": "None", "language": "c", "size": 1219}
{"docstring": "/* parse_blockquote \u2022 handles parsing of a blockquote fragment */\n", "func_signal": "static size_t\nparse_blockquote(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size)", "code": "{\n\tsize_t beg, end = 0, pre, work_size = 0;\n\tuint8_t *work_data = 0;\n\tstruct buf *out = 0;\n\n\tout = rndr_newbuf(rndr, BUFFER_BLOCK);\n\tbeg = 0;\n\twhile (beg < size) {\n\t\tfor (end = beg + 1; end < size && data[end - 1] != '\\n'; end++);\n\n\t\tpre = prefix_quote(data + beg, end - beg);\n\n\t\tif (pre)\n\t\t\tbeg += pre; /* skipping prefix */\n\n\t\t/* empty line followed by non-quote line */\n\t\telse if (is_empty(data + beg, end - beg) &&\n\t\t\t\t(end >= size || (prefix_quote(data + end, size - end) == 0 &&\n\t\t\t\t!is_empty(data + end, size - end))))\n\t\t\tbreak;\n\n\t\tif (beg < end) { /* copy into the in-place working buffer */\n\t\t\t/* bufput(work, data + beg, end - beg); */\n\t\t\tif (!work_data)\n\t\t\t\twork_data = data + beg;\n\t\t\telse if (data + beg != work_data + work_size)\n\t\t\t\tmemmove(work_data + work_size, data + beg, end - beg);\n\t\t\twork_size += end - beg;\n\t\t}\n\t\tbeg = end;\n\t}\n\n\tparse_block(out, rndr, work_data, work_size);\n\tif (rndr->cb.blockquote)\n\t\trndr->cb.blockquote(ob, out, rndr->opaque);\n\trndr_popbuf(rndr, BUFFER_BLOCK);\n\treturn end;\n}", "path": "sundown/src/markdown.c", "commit_date": "2012-10-19 00:00:00", "repo_name": "vmg/sundown", "stars": 1970, "license": "None", "language": "c", "size": 1219}
{"docstring": "/***************************\n * HELPER FUNCTIONS *\n ***************************/\n", "func_signal": "static inline struct buf *\nrndr_newbuf(struct sd_markdown *rndr, int type)", "code": "{\n\tstatic const size_t buf_size[2] = {256, 64};\n\tstruct buf *work = NULL;\n\tstruct stack *pool = &rndr->work_bufs[type];\n\n\tif (pool->size < pool->asize &&\n\t\tpool->item[pool->size] != NULL) {\n\t\twork = pool->item[pool->size++];\n\t\twork->size = 0;\n\t} else {\n\t\twork = bufnew(buf_size[type]);\n\t\tstack_push(pool, work);\n\t}\n\n\treturn work;\n}", "path": "sundown/src/markdown.c", "commit_date": "2012-10-19 00:00:00", "repo_name": "vmg/sundown", "stars": 1970, "license": "None", "language": "c", "size": 1219}
{"docstring": "/**\n * @brief         Process user callback function\n *\n * @note          Internal function, not public\n * @param  device The timer device\n * @param  ctx    The context\n * @return int    The callback result\n */\n", "func_signal": "static int timer_interrupt_handler(timer_device_number_t device, void *ctx)", "code": "{\n    uint32_t channel_int_stat = timer[device]->intr_stat;\n\n    for(size_t i = 0; i < TIMER_CHANNEL_MAX; i++)\n    {\n        /* Check every bit for interrupt status */\n        if(channel_int_stat & 1)\n        {\n            if(timer_instance[device][i].callback)\n            {\n                /* Process user callback function */\n                timer_instance[device][i].callback(timer_instance[device][i].ctx);\n                /* Check if this timer is a single shot timer */\n                if(timer_instance[device][i].single_shot)\n                {\n                    /* Single shot timer, disable it */\n                    timer_set_enable(device, i, 0);\n                }\n            }\n            /* Clear timer interrupt flag for specific channel */\n            readl(&timer[device]->channel[i].eoi);\n        }\n        channel_int_stat >>= 1;\n    }\n\n    /*\n     * NOTE:\n     * Don't read timer[device]->eoi here, or you will lost some interrupt\n     * readl(&timer[device]->eoi);\n     */\n\n    return 0;\n}", "path": "A-Eye/tutorials/05-BadApple/kendryte_libraries/kendryte_standalone-sdk/lib/drivers/timer.c", "commit_date": "2020-02-10 00:00:00", "repo_name": "peng-zhihui/A-Eye", "stars": 1163, "license": "None", "language": "c", "size": 47882}
{"docstring": "/*Entry Point for PLIC Interrupt Handler*/\n", "func_signal": "uintptr_t __attribute__((weak))\nhandle_irq_m_ext(uintptr_t cause, uintptr_t epc)", "code": "{\n    /*\n     * After the highest-priority pending interrupt is claimed by a target\n     * and the corresponding IP bit is cleared, other lower-priority\n     * pending interrupts might then become visible to the target, and so\n     * the PLIC EIP bit might not be cleared after a claim. The interrupt\n     * handler can check the local meip/heip/seip/ueip bits before exiting\n     * the handler, to allow more efficient service of other interrupts\n     * without first restoring the interrupted context and taking another\n     * interrupt trap.\n     */\n    if(read_csr(mip) & MIP_MEIP)\n    {\n        /* Get current core id */\n        uint64_t core_id = current_coreid();\n        /* Get primitive interrupt enable flag */\n        uint64_t ie_flag = read_csr(mie);\n        /* Get current IRQ num */\n        uint32_t int_num = plic->targets.target[core_id].claim_complete;\n        /* Get primitive IRQ threshold */\n        uint32_t int_threshold = plic->targets.target[core_id].priority_threshold;\n        /* Set new IRQ threshold = current IRQ threshold */\n        plic->targets.target[core_id].priority_threshold = plic->source_priorities.priority[int_num];\n        /* Disable software interrupt and timer interrupt */\n        clear_csr(mie, MIP_MTIP | MIP_MSIP);\n        /* Enable global interrupt */\n        set_csr(mstatus, MSTATUS_MIE);\n        if(plic_instance[core_id][int_num].callback)\n            plic_instance[core_id][int_num].callback(\n                plic_instance[core_id][int_num].ctx);\n        /* Perform IRQ complete */\n        plic->targets.target[core_id].claim_complete = int_num;\n        /* Disable global interrupt */\n        clear_csr(mstatus, MSTATUS_MIE);\n        /* Set MPIE and MPP flag used to MRET instructions restore MIE flag */\n        set_csr(mstatus, MSTATUS_MPIE | MSTATUS_MPP);\n        /* Restore primitive interrupt enable flag */\n        write_csr(mie, ie_flag);\n        /* Restore primitive IRQ threshold */\n        plic->targets.target[core_id].priority_threshold = int_threshold;\n    }\n\n    return epc;\n}", "path": "A-Eye/firmware/kendryte_libraries/kendryte_standalone-sdk/lib/drivers/plic.c", "commit_date": "2019-10-02 00:00:00", "repo_name": "peng-zhihui/A-Eye", "stars": 1163, "license": "None", "language": "c", "size": 47882}
{"docstring": "/**\n * @brief             Get the timer irqn by device and channel object\n *\n * @note              Internal function, not public\n * @param  device     The device\n * @param  channel    The channel\n * @return plic_irq_t IRQ number\n */\n", "func_signal": "static plic_irq_t get_timer_irqn_by_device_and_channel(timer_device_number_t device, timer_channel_number_t channel)", "code": "{\n    if(device < TIMER_DEVICE_MAX && channel < TIMER_CHANNEL_MAX)\n    {\n        /*\n         * Select timer interrupt part\n         * Hierarchy of Timer interrupt to PLIC\n         *  +---------+       +-----------+\n         *  |        0+----+  |           |\n         *  |         |    +--+0A         |\n         *  |        1+----+  |           |\n         *  | TIMER0  |       |           |\n         *  |        2+----+  |           |\n         *  |         |    +--+0B         |\n         *  |        3+----+  |           |\n         *  +---------+       |           |\n         *                    |           |\n         *  +---------+       |           |\n         *  |        0+----+  |           |\n         *  |         |    +--+1A         |\n         *  |        1+----+  |           |\n         *  | TIMER1  |       |    PLIC   |\n         *  |        2+----+  |           |\n         *  |         |    +--+1B         |\n         *  |        3+----+  |           |\n         *  +---------+       |           |\n         *                    |           |\n         *  +---------+       |           |\n         *  |        0+----+  |           |\n         *  |         |    +--+2A         |\n         *  |        1+----+  |           |\n         *  | TIMER2  |       |           |\n         *  |        2+----+  |           |\n         *  |         |    +--+2B         |\n         *  |        3+----+  |           |\n         *  +---------+       +-----------+\n         *\n         */\n        if(channel < 2)\n        {\n            /* It is part A interrupt, offset + 0 */\n            return IRQN_TIMER0A_INTERRUPT + device * 2;\n        } else\n        {\n            /* It is part B interrupt, offset + 1 */\n            return IRQN_TIMER0B_INTERRUPT + device * 2;\n        }\n    }\n    return IRQN_NO_INTERRUPT;\n}", "path": "A-Eye/tutorials/05-BadApple/kendryte_libraries/kendryte_standalone-sdk/lib/drivers/timer.c", "commit_date": "2020-02-10 00:00:00", "repo_name": "peng-zhihui/A-Eye", "stars": 1163, "license": "None", "language": "c", "size": 47882}
{"docstring": "/* Compare memory block */\n", "func_signal": "static int mem_cmp(const void *dst, const void *src, UINT cnt)", "code": "{ /* ZR:same, NZ:different */\n    const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;\n    int r = 0;\n\n    do\n    {\n        r = *d++ - *s++;\n    } while(--cnt && r == 0);\n\n    return r;\n}", "path": "A-Eye/_staging/aeye-kpu-faceDetection/kendryte_libraries/kendryte_sdcard-standalone-driver/src/ff.c", "commit_date": "2020-01-16 00:00:00", "repo_name": "peng-zhihui/A-Eye", "stars": 1163, "license": "None", "language": "c", "size": 47882}
{"docstring": "/* Check if chr is contained in the string */\n", "func_signal": "static int chk_chr(const char *str, int chr)", "code": "{ /* NZ:contained, ZR:not contained */\n    while(*str && *str != chr)\n        str++;\n    return *str;\n}", "path": "A-Eye/tutorials/05-BadApple/kendryte_libraries/kendryte_sdcard-standalone-driver/src/ff.c", "commit_date": "2020-02-10 00:00:00", "repo_name": "peng-zhihui/A-Eye", "stars": 1163, "license": "None", "language": "c", "size": 47882}
{"docstring": "/*-----------------------------------------------------------------------*/\n/* Write Sector(s)                                                       */\n/*-----------------------------------------------------------------------*/\n", "func_signal": "DRESULT disk_write(BYTE pdrv, const BYTE *buff, DWORD sector, UINT count)", "code": "{\n    if(sd_write_sector_dma((BYTE *)buff, sector, count) == 0)\n        return RES_OK;\n    return RES_ERROR;\n}", "path": "A-Eye/tutorials/05-BadApple/kendryte_libraries/kendryte_sdcard-standalone-driver/src/diskio.c", "commit_date": "2020-02-10 00:00:00", "repo_name": "peng-zhihui/A-Eye", "stars": 1163, "license": "None", "language": "c", "size": 47882}
{"docstring": "/**\n * @brief             Get the timer irqn by device and channel object\n *\n * @note              Internal function, not public\n * @param  device     The device\n * @param  channel    The channel\n * @return plic_irq_t IRQ number\n */\n", "func_signal": "static plic_irq_t get_timer_irqn_by_device_and_channel(timer_device_number_t device, timer_channel_number_t channel)", "code": "{\n    if(device < TIMER_DEVICE_MAX && channel < TIMER_CHANNEL_MAX)\n    {\n        /*\n         * Select timer interrupt part\n         * Hierarchy of Timer interrupt to PLIC\n         *  +---------+       +-----------+\n         *  |        0+----+  |           |\n         *  |         |    +--+0A         |\n         *  |        1+----+  |           |\n         *  | TIMER0  |       |           |\n         *  |        2+----+  |           |\n         *  |         |    +--+0B         |\n         *  |        3+----+  |           |\n         *  +---------+       |           |\n         *                    |           |\n         *  +---------+       |           |\n         *  |        0+----+  |           |\n         *  |         |    +--+1A         |\n         *  |        1+----+  |           |\n         *  | TIMER1  |       |    PLIC   |\n         *  |        2+----+  |           |\n         *  |         |    +--+1B         |\n         *  |        3+----+  |           |\n         *  +---------+       |           |\n         *                    |           |\n         *  +---------+       |           |\n         *  |        0+----+  |           |\n         *  |         |    +--+2A         |\n         *  |        1+----+  |           |\n         *  | TIMER2  |       |           |\n         *  |        2+----+  |           |\n         *  |         |    +--+2B         |\n         *  |        3+----+  |           |\n         *  +---------+       +-----------+\n         *\n         */\n        if(channel < 2)\n        {\n            /* It is part A interrupt, offset + 0 */\n            return IRQN_TIMER0A_INTERRUPT + device * 2;\n        } else\n        {\n            /* It is part B interrupt, offset + 1 */\n            return IRQN_TIMER0B_INTERRUPT + device * 2;\n        }\n    }\n    return IRQN_NO_INTERRUPT;\n}", "path": "A-Eye/tutorials/04-SD-Card/kendryte_libraries/kendryte_standalone-sdk/lib/drivers/timer.c", "commit_date": "2020-02-10 00:00:00", "repo_name": "peng-zhihui/A-Eye", "stars": 1163, "license": "None", "language": "c", "size": 47882}
{"docstring": "/*-----------------------------------------------------------------------*/\n/* Write Sector(s)                                                       */\n/*-----------------------------------------------------------------------*/\n", "func_signal": "DRESULT disk_write(BYTE pdrv, const BYTE *buff, DWORD sector, UINT count)", "code": "{\n    if(sd_write_sector_dma((BYTE *)buff, sector, count) == 0)\n        return RES_OK;\n    return RES_ERROR;\n}", "path": "A-Eye/firmware/kendryte_libraries/kendryte_sdcard-standalone-driver/src/diskio.c", "commit_date": "2019-10-02 00:00:00", "repo_name": "peng-zhihui/A-Eye", "stars": 1163, "license": "None", "language": "c", "size": 47882}
{"docstring": "/*-----------------------------------------------------------------------*/\n/* Miscellaneous Functions                                               */\n/*-----------------------------------------------------------------------*/\n", "func_signal": "DRESULT disk_ioctl(BYTE pdrv, BYTE cmd, void *buff)", "code": "{\n    DRESULT res = RES_ERROR;\n\n    switch(cmd)\n    {\n        /* Make sure that no pending write process */\n        case CTRL_SYNC:\n            res = RES_OK;\n            break;\n        /* Get number of sectors on the disk (DWORD) */\n        case GET_SECTOR_COUNT:\n            *(DWORD *)buff = (cardinfo.SD_csd.DeviceSize + 1) << 10;\n            res = RES_OK;\n            break;\n        /* Get R/W sector size (WORD) */\n        case GET_SECTOR_SIZE:\n            *(WORD *)buff = cardinfo.CardBlockSize;\n            res = RES_OK;\n            break;\n        /* Get erase block size in unit of sector (DWORD) */\n        case GET_BLOCK_SIZE:\n            *(DWORD *)buff = cardinfo.CardBlockSize;\n            res = RES_OK;\n            break;\n        default:\n            res = RES_PARERR;\n    }\n    return res;\n}", "path": "A-Eye/tutorials/05-BadApple/kendryte_libraries/kendryte_sdcard-standalone-driver/src/diskio.c", "commit_date": "2020-02-10 00:00:00", "repo_name": "peng-zhihui/A-Eye", "stars": 1163, "license": "None", "language": "c", "size": 47882}
{"docstring": "/* Copy memory to memory */\n", "func_signal": "static void mem_cpy(void *dst, const void *src, UINT cnt)", "code": "{\n    BYTE *d = (BYTE *)dst;\n    const BYTE *s = (const BYTE *)src;\n\n    if(cnt)\n    {\n        do\n            *d++ = *s++;\n        while(--cnt);\n    }\n}", "path": "A-Eye/_staging/aeye-kpu-faceDetection/kendryte_libraries/kendryte_sdcard-standalone-driver/src/ff.c", "commit_date": "2020-01-16 00:00:00", "repo_name": "peng-zhihui/A-Eye", "stars": 1163, "license": "None", "language": "c", "size": 47882}
{"docstring": "/* Fill memory block */\n", "func_signal": "static void mem_set(void *dst, int val, UINT cnt)", "code": "{\n    BYTE *d = (BYTE *)dst;\n\n    do\n        *d++ = (BYTE)val;\n    while(--cnt);\n}", "path": "A-Eye/tutorials/05-BadApple/kendryte_libraries/kendryte_sdcard-standalone-driver/src/ff.c", "commit_date": "2020-02-10 00:00:00", "repo_name": "peng-zhihui/A-Eye", "stars": 1163, "license": "None", "language": "c", "size": 47882}
{"docstring": "/*-----------------------------------------------------------------------*/\n/* Inidialize a Drive                                                    */\n/*-----------------------------------------------------------------------*/\n", "func_signal": "DSTATUS disk_initialize(BYTE pdrv)", "code": "{\n    if(sd_init() == 0)\n        return 0;\n    return STA_NOINIT;\n}", "path": "A-Eye/tutorials/05-BadApple/kendryte_libraries/kendryte_sdcard-standalone-driver/src/diskio.c", "commit_date": "2020-02-10 00:00:00", "repo_name": "peng-zhihui/A-Eye", "stars": 1163, "license": "None", "language": "c", "size": 47882}
{"docstring": "/* Check if chr is contained in the string */\n", "func_signal": "static int chk_chr(const char *str, int chr)", "code": "{ /* NZ:contained, ZR:not contained */\n    while(*str && *str != chr)\n        str++;\n    return *str;\n}", "path": "A-Eye/_staging/aeye-kpu-faceDetection/kendryte_libraries/kendryte_sdcard-standalone-driver/src/ff.c", "commit_date": "2020-01-16 00:00:00", "repo_name": "peng-zhihui/A-Eye", "stars": 1163, "license": "None", "language": "c", "size": 47882}
{"docstring": "/*-----------------------------------------------------------------------*/\n/* Read Sector(s)                                                        */\n/*-----------------------------------------------------------------------*/\n", "func_signal": "DRESULT disk_read(BYTE pdrv, BYTE *buff, DWORD sector, UINT count)", "code": "{\n    if(sd_read_sector_dma(buff, sector, count) == 0)\n        return RES_OK;\n    return RES_ERROR;\n}", "path": "A-Eye/firmware/kendryte_libraries/kendryte_sdcard-standalone-driver/src/diskio.c", "commit_date": "2019-10-02 00:00:00", "repo_name": "peng-zhihui/A-Eye", "stars": 1163, "license": "None", "language": "c", "size": 47882}
{"docstring": "/* Fill memory block */\n", "func_signal": "static void mem_set(void *dst, int val, UINT cnt)", "code": "{\n    BYTE *d = (BYTE *)dst;\n\n    do\n        *d++ = (BYTE)val;\n    while(--cnt);\n}", "path": "A-Eye/_staging/aeye-kpu-faceDetection/kendryte_libraries/kendryte_sdcard-standalone-driver/src/ff.c", "commit_date": "2020-01-16 00:00:00", "repo_name": "peng-zhihui/A-Eye", "stars": 1163, "license": "None", "language": "c", "size": 47882}
{"docstring": "/* Compare memory block */\n", "func_signal": "static int mem_cmp(const void *dst, const void *src, UINT cnt)", "code": "{ /* ZR:same, NZ:different */\n    const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;\n    int r = 0;\n\n    do\n    {\n        r = *d++ - *s++;\n    } while(--cnt && r == 0);\n\n    return r;\n}", "path": "A-Eye/tutorials/05-BadApple/kendryte_libraries/kendryte_sdcard-standalone-driver/src/ff.c", "commit_date": "2020-02-10 00:00:00", "repo_name": "peng-zhihui/A-Eye", "stars": 1163, "license": "None", "language": "c", "size": 47882}
{"docstring": "/**\n * @brief         Process user callback function\n *\n * @note          Internal function, not public\n * @param  device The timer device\n * @param  ctx    The context\n * @return int    The callback result\n */\n", "func_signal": "static int timer_interrupt_handler(timer_device_number_t device, void *ctx)", "code": "{\n    uint32_t channel_int_stat = timer[device]->intr_stat;\n\n    for(size_t i = 0; i < TIMER_CHANNEL_MAX; i++)\n    {\n        /* Check every bit for interrupt status */\n        if(channel_int_stat & 1)\n        {\n            if(timer_instance[device][i].callback)\n            {\n                /* Process user callback function */\n                timer_instance[device][i].callback(timer_instance[device][i].ctx);\n                /* Check if this timer is a single shot timer */\n                if(timer_instance[device][i].single_shot)\n                {\n                    /* Single shot timer, disable it */\n                    timer_set_enable(device, i, 0);\n                }\n            }\n            /* Clear timer interrupt flag for specific channel */\n            readl(&timer[device]->channel[i].eoi);\n        }\n        channel_int_stat >>= 1;\n    }\n\n    /*\n     * NOTE:\n     * Don't read timer[device]->eoi here, or you will lost some interrupt\n     * readl(&timer[device]->eoi);\n     */\n\n    return 0;\n}", "path": "A-Eye/tutorials/04-SD-Card/kendryte_libraries/kendryte_standalone-sdk/lib/drivers/timer.c", "commit_date": "2020-02-10 00:00:00", "repo_name": "peng-zhihui/A-Eye", "stars": 1163, "license": "None", "language": "c", "size": 47882}
{"docstring": "/*-----------------------------------------------------------------------*/\n/* Miscellaneous Functions                                               */\n/*-----------------------------------------------------------------------*/\n", "func_signal": "DRESULT disk_ioctl(BYTE pdrv, BYTE cmd, void *buff)", "code": "{\n    DRESULT res = RES_ERROR;\n\n    switch(cmd)\n    {\n        /* Make sure that no pending write process */\n        case CTRL_SYNC:\n            res = RES_OK;\n            break;\n        /* Get number of sectors on the disk (DWORD) */\n        case GET_SECTOR_COUNT:\n            *(DWORD *)buff = (cardinfo.SD_csd.DeviceSize + 1) << 10;\n            res = RES_OK;\n            break;\n        /* Get R/W sector size (WORD) */\n        case GET_SECTOR_SIZE:\n            *(WORD *)buff = cardinfo.CardBlockSize;\n            res = RES_OK;\n            break;\n        /* Get erase block size in unit of sector (DWORD) */\n        case GET_BLOCK_SIZE:\n            *(DWORD *)buff = cardinfo.CardBlockSize;\n            res = RES_OK;\n            break;\n        default:\n            res = RES_PARERR;\n    }\n    return res;\n}", "path": "A-Eye/firmware/kendryte_libraries/kendryte_sdcard-standalone-driver/src/diskio.c", "commit_date": "2019-10-02 00:00:00", "repo_name": "peng-zhihui/A-Eye", "stars": 1163, "license": "None", "language": "c", "size": 47882}
{"docstring": "/*-----------------------------------------------------------------------*/\n/* Inidialize a Drive                                                    */\n/*-----------------------------------------------------------------------*/\n", "func_signal": "DSTATUS disk_initialize(BYTE pdrv)", "code": "{\n    if(sd_init() == 0)\n        return 0;\n    return STA_NOINIT;\n}", "path": "A-Eye/firmware/kendryte_libraries/kendryte_sdcard-standalone-driver/src/diskio.c", "commit_date": "2019-10-02 00:00:00", "repo_name": "peng-zhihui/A-Eye", "stars": 1163, "license": "None", "language": "c", "size": 47882}
{"docstring": "/* Copy memory to memory */\n", "func_signal": "static void mem_cpy(void *dst, const void *src, UINT cnt)", "code": "{\n    BYTE *d = (BYTE *)dst;\n    const BYTE *s = (const BYTE *)src;\n\n    if(cnt)\n    {\n        do\n            *d++ = *s++;\n        while(--cnt);\n    }\n}", "path": "A-Eye/tutorials/05-BadApple/kendryte_libraries/kendryte_sdcard-standalone-driver/src/ff.c", "commit_date": "2020-02-10 00:00:00", "repo_name": "peng-zhihui/A-Eye", "stars": 1163, "license": "None", "language": "c", "size": 47882}
{"docstring": "//output buffer and image width\n", "func_signal": "static bool _rgb_write(void * arg, uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint8_t *data)", "code": "{\n    rgb_jpg_decoder * jpeg = (rgb_jpg_decoder *)arg;\n    if(!data){\n        if(x == 0 && y == 0){\n            //write start\n            jpeg->width = w;\n            jpeg->height = h;\n            //if output is null, this is BMP\n            if(!jpeg->output){\n                jpeg->output = (uint8_t *)_malloc((w*h*3)+jpeg->data_offset);\n                if(!jpeg->output){\n                    return false;\n                }\n            }\n        } else {\n            //write end\n        }\n        return true;\n    }\n\n    size_t jw = jpeg->width*3;\n    size_t t = y * jw;\n    size_t b = t + (h * jw);\n    size_t l = x * 3;\n    uint8_t *out = jpeg->output+jpeg->data_offset;\n    uint8_t *o = out;\n    size_t iy, ix;\n\n    w = w * 3;\n\n    for(iy=t; iy<b; iy+=jw) {\n        o = out+iy+l;\n        for(ix=0; ix<w; ix+= 3) {\n            o[ix] = data[ix+2];\n            o[ix+1] = data[ix+1];\n            o[ix+2] = data[ix];\n        }\n        data+=w;\n    }\n    return true;\n}", "path": "esp32-camera/conversions/to_bmp.c", "commit_date": "2020-10-13 00:00:00", "repo_name": "espressif/esp32-camera", "stars": 1632, "license": "apache-2.0", "language": "c", "size": 2183}
{"docstring": "//night mode enable\n", "func_signal": "static int set_aec2(sensor_t *sensor, int enable)", "code": "{\n    int ret = 0;\n\n    if (ret == 0) {\n        ESP_LOGD(TAG, \"Set aec2 to: %d\", enable);\n        sensor->status.aec2 = enable;\n    }\n\n    return ret;\n}", "path": "esp32-camera/sensors/nt99141.c", "commit_date": "2020-10-16 00:00:00", "repo_name": "espressif/esp32-camera", "stars": 1632, "license": "apache-2.0", "language": "c", "size": 2183}
{"docstring": "//Gamma enable\n", "func_signal": "static int set_raw_gma_dsp(sensor_t *sensor, int enable)", "code": "{\n    int ret = 0;\n\n    if (ret == 0) {\n        ESP_LOGD(TAG, \"Set raw_gma to: %d\", enable);\n        sensor->status.raw_gma = enable;\n    }\n\n    return ret;\n}", "path": "esp32-camera/sensors/nt99141.c", "commit_date": "2020-10-16 00:00:00", "repo_name": "espressif/esp32-camera", "stars": 1632, "license": "apache-2.0", "language": "c", "size": 2183}
{"docstring": "//#define REG_DEBUG_ON\n", "func_signal": "static int read_reg(uint8_t slv_addr, const uint16_t reg)", "code": "{\n    int ret = SCCB_Read16(slv_addr, reg);\n#ifdef REG_DEBUG_ON\n    if (ret < 0) {\n        ESP_LOGE(TAG, \"READ REG 0x%04x FAILED: %d\", reg, ret);\n    }\n#endif\n    return ret;\n}", "path": "esp32-camera/sensors/ov5640.c", "commit_date": "2020-03-11 00:00:00", "repo_name": "espressif/esp32-camera", "stars": 1632, "license": "apache-2.0", "language": "c", "size": 2183}
{"docstring": "//Advanced AWB\n", "func_signal": "static int set_dcw_dsp(sensor_t *sensor, int enable)", "code": "{\n    int ret = 0;\n    ret = write_reg_bits(sensor->slv_addr, 0x5183, 0x80, !enable);\n    if (ret == 0) {\n        ESP_LOGD(TAG, \"Set dcw to: %d\", enable);\n        sensor->status.dcw = enable;\n    }\n    return ret;\n}", "path": "esp32-camera/sensors/ov3660.c", "commit_date": "2020-03-11 00:00:00", "repo_name": "espressif/esp32-camera", "stars": 1632, "license": "apache-2.0", "language": "c", "size": 2183}
{"docstring": "//Gamma enable\n", "func_signal": "static int set_raw_gma_dsp(sensor_t *sensor, int enable)", "code": "{\n    int ret = 0;\n    ret = write_reg_bits(sensor->slv_addr, 0x5000, 0x20, enable);\n    if (ret == 0) {\n        ESP_LOGD(TAG, \"Set raw_gma to: %d\", enable);\n        sensor->status.raw_gma = enable;\n    }\n    return ret;\n}", "path": "esp32-camera/sensors/ov3660.c", "commit_date": "2020-03-11 00:00:00", "repo_name": "espressif/esp32-camera", "stars": 1632, "license": "apache-2.0", "language": "c", "size": 2183}
{"docstring": "//real gain\n", "func_signal": "static int set_agc_gain(sensor_t *sensor, int gain)", "code": "{\n    int ret = 0;\n    ret = set_reg_bits(sensor, COM9, 4, 3, gain % 5);\n    if (ret == 0) {\n        ESP_LOGD(TAG, \"Set gain to: %d\", gain);\n        sensor->status.agc_gain = gain;\n    }\n    return ret;\n}", "path": "esp32-camera/sensors/ov7725.c", "commit_date": "2020-06-04 00:00:00", "repo_name": "espressif/esp32-camera", "stars": 1632, "license": "apache-2.0", "language": "c", "size": 2183}
{"docstring": "//#define REG_DEBUG_ON\n", "func_signal": "static int read_reg(uint8_t slv_addr, const uint16_t reg)", "code": "{\n    int ret = SCCB_Read16(slv_addr, reg);\n#ifdef REG_DEBUG_ON\n\n    if (ret < 0) {\n        ESP_LOGE(TAG, \"READ REG 0x%04x FAILED: %d\", reg, ret);\n    }\n\n#endif\n    return ret;\n}", "path": "esp32-camera/sensors/nt99141.c", "commit_date": "2020-10-16 00:00:00", "repo_name": "espressif/esp32-camera", "stars": 1632, "license": "apache-2.0", "language": "c", "size": 2183}
{"docstring": "//Advanced AWB\n", "func_signal": "static int set_dcw_dsp(sensor_t *sensor, int enable)", "code": "{\n    int ret = 0;\n    ret = write_reg_bits(sensor->slv_addr, 0x5183, 0x80, !enable);\n    if (ret == 0) {\n        ESP_LOGD(TAG, \"Set dcw to: %d\", enable);\n        sensor->status.dcw = enable;\n    }\n    return ret;\n}", "path": "esp32-camera/sensors/ov5640.c", "commit_date": "2020-03-11 00:00:00", "repo_name": "espressif/esp32-camera", "stars": 1632, "license": "apache-2.0", "language": "c", "size": 2183}
{"docstring": "//night mode enable\n", "func_signal": "static int set_aec2(sensor_t *sensor, int enable)", "code": "{\n    int ret = 0;\n    ret = write_reg_bits(sensor->slv_addr, 0x3a00, 0x04, enable);\n    if (ret == 0) {\n        ESP_LOGD(TAG, \"Set aec2 to: %d\", enable);\n        sensor->status.aec2 = enable;\n    }\n    return ret;\n}", "path": "esp32-camera/sensors/ov3660.c", "commit_date": "2020-03-11 00:00:00", "repo_name": "espressif/esp32-camera", "stars": 1632, "license": "apache-2.0", "language": "c", "size": 2183}
{"docstring": "//input buffer\n", "func_signal": "static uint32_t _jpg_read(void * arg, size_t index, uint8_t *buf, size_t len)", "code": "{\n    rgb_jpg_decoder * jpeg = (rgb_jpg_decoder *)arg;\n    if(buf) {\n        memcpy(buf, jpeg->input + index, len);\n    }\n    return len;\n}", "path": "esp32-camera/conversions/to_bmp.c", "commit_date": "2020-10-13 00:00:00", "repo_name": "espressif/esp32-camera", "stars": 1632, "license": "apache-2.0", "language": "c", "size": 2183}
{"docstring": "//real gain\n", "func_signal": "static int set_agc_gain(sensor_t *sensor, int gain)", "code": "{\n    ESP_LOGD(TAG, \"set_agc_gain can not be configured at present\");\n    // ESP_LOGD(TAG, \"GAIN = %d\\n\", gain);\n    int cnt = gain / 2;\n\n    switch (cnt) {\n        case 0:\n            ESP_LOGD(TAG, \"set_agc_gain: 1x\");\n            write_reg(sensor->slv_addr, 0X301D, 0X00);\n            break;\n\n        case 1:\n            ESP_LOGD(TAG,\"set_agc_gain: 2x\");\n            write_reg(sensor->slv_addr, 0X301D, 0X0F);\n            break;\n\n        case 2:\n            ESP_LOGD(TAG,\"set_agc_gain: 4x\");\n            write_reg(sensor->slv_addr, 0X301D, 0X2F);\n            break;\n\n        case 3:\n            ESP_LOGD(TAG,\"set_agc_gain: 6x\");\n            write_reg(sensor->slv_addr, 0X301D, 0X37);\n            break;\n\n        case 4:\n            ESP_LOGD(TAG,\"set_agc_gain: 8x\");\n            write_reg(sensor->slv_addr, 0X301D, 0X3F);\n            break;\n\n        default:\n            ESP_LOGD(TAG,\"fail set_agc_gain\");\n            break;\n    }\n\n    return 0;\n}", "path": "esp32-camera/sensors/nt99141.c", "commit_date": "2020-10-16 00:00:00", "repo_name": "espressif/esp32-camera", "stars": 1632, "license": "apache-2.0", "language": "c", "size": 2183}
{"docstring": "//real gain\n", "func_signal": "static int set_agc_gain(sensor_t *sensor, int gain)", "code": "{\n    int ret = 0;\n    if(gain < 0) {\n        gain = 0;\n    } else if(gain > 64) {\n        gain = 64;\n    }\n\n    //gain value is 6.4 bits float\n    //in order to use the max range, we deduct 1/16\n    int gainv = gain << 4;\n    if(gainv){\n        gainv -= 1;\n    }\n\n    ret = write_reg(sensor->slv_addr, 0x350a, gainv >> 8) || write_reg(sensor->slv_addr, 0x350b, gainv & 0xff);\n    if (ret == 0) {\n        ESP_LOGD(TAG, \"Set agc_gain to: %d\", gain);\n        sensor->status.agc_gain = gain;\n    }\n    return ret;\n}", "path": "esp32-camera/sensors/ov5640.c", "commit_date": "2020-03-11 00:00:00", "repo_name": "espressif/esp32-camera", "stars": 1632, "license": "apache-2.0", "language": "c", "size": 2183}
{"docstring": "//#define REG_DEBUG_ON\n", "func_signal": "static int read_reg(uint8_t slv_addr, const uint16_t reg)", "code": "{\n    int ret = SCCB_Read16(slv_addr, reg);\n#ifdef REG_DEBUG_ON\n    if (ret < 0) {\n        ESP_LOGE(TAG, \"READ REG 0x%04x FAILED: %d\", reg, ret);\n    }\n#endif\n    return ret;\n}", "path": "esp32-camera/sensors/ov3660.c", "commit_date": "2020-03-11 00:00:00", "repo_name": "espressif/esp32-camera", "stars": 1632, "license": "apache-2.0", "language": "c", "size": 2183}
{"docstring": "//Advanced AWB\n", "func_signal": "static int set_dcw_dsp(sensor_t *sensor, int enable)", "code": "{\n    int ret = 0;\n\n    if (ret == 0) {\n        ESP_LOGD(TAG, \"Set dcw to: %d\", enable);\n        sensor->status.dcw = enable;\n    }\n\n    return ret;\n}", "path": "esp32-camera/sensors/nt99141.c", "commit_date": "2020-10-16 00:00:00", "repo_name": "espressif/esp32-camera", "stars": 1632, "license": "apache-2.0", "language": "c", "size": 2183}
{"docstring": "//real gain\n", "func_signal": "static int set_agc_gain(sensor_t *sensor, int gain)", "code": "{\n    int ret = 0;\n    if(gain < 0) {\n        gain = 0;\n    } else if(gain > 64) {\n        gain = 64;\n    }\n\n    //gain value is 6.4 bits float\n    //in order to use the max range, we deduct 1/16\n    int gainv = gain << 4;\n    if(gainv){\n        gainv -= 1;\n    }\n\n    ret = write_reg(sensor->slv_addr, 0x350a, gainv >> 8) || write_reg(sensor->slv_addr, 0x350b, gainv & 0xff);\n    if (ret == 0) {\n        ESP_LOGD(TAG, \"Set agc_gain to: %d\", gain);\n        sensor->status.agc_gain = gain;\n    }\n    return ret;\n}", "path": "esp32-camera/sensors/ov3660.c", "commit_date": "2020-03-11 00:00:00", "repo_name": "espressif/esp32-camera", "stars": 1632, "license": "apache-2.0", "language": "c", "size": 2183}
{"docstring": "//night mode enable\n", "func_signal": "static int set_aec2(sensor_t *sensor, int enable)", "code": "{\n    int ret = 0;\n    ret = write_reg_bits(sensor->slv_addr, 0x3a00, 0x04, enable);\n    if (ret == 0) {\n        ESP_LOGD(TAG, \"Set aec2 to: %d\", enable);\n        sensor->status.aec2 = enable;\n    }\n    return ret;\n}", "path": "esp32-camera/sensors/ov5640.c", "commit_date": "2020-03-11 00:00:00", "repo_name": "espressif/esp32-camera", "stars": 1632, "license": "apache-2.0", "language": "c", "size": 2183}
{"docstring": "/*\n * Write a list of register settings; ff/ff stops the process.\n */\n", "func_signal": "static int ov7670_write_array(sensor_t *sensor, struct regval_list *vals)", "code": "{\nint ret = 0;\n\t\n\twhile ( (vals->reg_num != 0xff || vals->value != 0xff) && (ret == 0) ) {\n        ret = SCCB_Write(sensor->slv_addr, vals->reg_num, vals->value);\n\n\t    ESP_LOGD(TAG, \"reset reg %02X, W(%02X) R(%02X)\", vals->reg_num, \n                        vals->value, SCCB_Read(sensor->slv_addr, vals->reg_num) );\n\t\t\n\t\tvals++;\n\t}\n\n    return ret;\n}", "path": "esp32-camera/sensors/ov7670.c", "commit_date": "2020-03-11 00:00:00", "repo_name": "espressif/esp32-camera", "stars": 1632, "license": "apache-2.0", "language": "c", "size": 2183}
{"docstring": "//Gamma enable\n", "func_signal": "static int set_raw_gma_dsp(sensor_t *sensor, int enable)", "code": "{\n    int ret = 0;\n    ret = write_reg_bits(sensor->slv_addr, 0x5000, 0x20, enable);\n    if (ret == 0) {\n        ESP_LOGD(TAG, \"Set raw_gma to: %d\", enable);\n        sensor->status.raw_gma = enable;\n    }\n    return ret;\n}", "path": "esp32-camera/sensors/ov5640.c", "commit_date": "2020-03-11 00:00:00", "repo_name": "espressif/esp32-camera", "stars": 1632, "license": "apache-2.0", "language": "c", "size": 2183}
{"docstring": "/*\n * Calculate the frame control registers.\n */\n", "func_signal": "static int ov7670_frame_control(sensor_t *sensor, int hstart, int hstop, int vstart, int vstop)", "code": "{\nstruct regval_list frame[7];\n\n    frame[0].reg_num = HSTART;\n    frame[0].value = (hstart >> 3);\n\n    frame[1].reg_num = HSTOP;\n    frame[1].value = (hstop >> 3);\n\n    frame[2].reg_num = HREF;\n    frame[2].value = (((hstop & 0x07) << 3) | (hstart & 0x07));\n    \n    frame[3].reg_num = VSTART;\n    frame[3].value = (vstart >> 2);\n    \n    frame[4].reg_num = VSTOP;\n    frame[4].value = (vstop >> 2);\n\n    frame[5].reg_num = VREF;\n    frame[5].value = (((vstop & 0x02) << 2) | (vstart & 0x02));\n\n    /* End mark */\n    frame[5].reg_num = 0xFF;\n    frame[5].value = 0xFF;\n\n    return ov7670_write_array(sensor, frame);\n}", "path": "esp32-camera/sensors/ov7670.c", "commit_date": "2020-03-11 00:00:00", "repo_name": "espressif/esp32-camera", "stars": 1632, "license": "apache-2.0", "language": "c", "size": 2183}
{"docstring": "/* _al_save_wav_f:\n * Writes a sample into a wav packfile.\n * Returns true on success, false on error.\n */\n", "func_signal": "bool _al_save_wav_f(ALLEGRO_FILE *pf, ALLEGRO_SAMPLE *spl)", "code": "{\n   size_t channels, bits;\n   size_t data_size;\n   size_t samples;\n   size_t i, n;\n\n   ASSERT(spl);\n   ASSERT(pf);\n\n   /* XXX: makes use of ALLEGRO_SAMPLE internals */\n\n   channels = (spl->chan_conf >> 4) + (spl->chan_conf & 0xF);\n   bits = (spl->depth == ALLEGRO_AUDIO_DEPTH_INT8 ||\n           spl->depth == ALLEGRO_AUDIO_DEPTH_UINT8) ? 8 : 16;\n\n   if (channels < 1 || channels > 2) {\n      ALLEGRO_ERROR(\"Can only save samples with 1 or 2 channels as WAV.\\n\");\n      return false;\n   }\n\n   samples = spl->len;\n   data_size = samples * channels * bits / 8;\n   n = samples * channels;\n\n   al_fputs(pf, \"RIFF\");\n   al_fwrite32le(pf, 36 + data_size);\n   al_fputs(pf, \"WAVE\");\n\n   al_fputs(pf, \"fmt \");\n   al_fwrite32le(pf, 16);\n   al_fwrite16le(pf, 1);\n   al_fwrite16le(pf, (int16_t)channels);\n   al_fwrite32le(pf, spl->frequency);\n   al_fwrite32le(pf, spl->frequency * channels * bits / 8);\n   al_fwrite16le(pf, (int16_t)(channels * bits / 8));\n   al_fwrite16le(pf, (int16_t)bits);\n\n   al_fputs(pf, \"data\");\n   al_fwrite32le(pf, data_size);\n\n\n   if (spl->depth == ALLEGRO_AUDIO_DEPTH_UINT8) {\n      al_fwrite(pf, spl->buffer.u8, samples * channels);\n   }\n   else if (spl->depth == ALLEGRO_AUDIO_DEPTH_INT16) {\n      al_fwrite(pf, spl->buffer.s16, samples * channels * 2);\n   }\n   else if (spl->depth == ALLEGRO_AUDIO_DEPTH_INT8) {\n      int8_t *data = spl->buffer.s8;\n      for (i = 0; i < samples; ++i) {\n         al_fputc(pf, *data++ + 0x80);\n      }\n   }\n   else if (spl->depth == ALLEGRO_AUDIO_DEPTH_UINT16) {\n      uint16_t *data = spl->buffer.u16;\n      for (i = 0; i < n; ++i) {\n         al_fwrite16le(pf, *data++ - 0x8000);\n      }\n   }\n   else if (spl->depth == ALLEGRO_AUDIO_DEPTH_INT24) {\n      int32_t *data = spl->buffer.s24;\n      for (i = 0; i < n; ++i) {\n         const int v = ((float)(*data++ + 0x800000) / 0x7FFFFF) * 0x7FFF - 0x8000;\n         al_fwrite16le(pf, v);\n      }\n   }\n   else if (spl->depth == ALLEGRO_AUDIO_DEPTH_UINT24) {\n      uint32_t *data = spl->buffer.u24;\n      for (i = 0; i < n; ++i) {\n         const int v = ((float)(*data++) / 0x7FFFFF) * 0x7FFF - 0x8000;\n         al_fwrite16le(pf, v);\n      }\n   }\n   else if (spl->depth == ALLEGRO_AUDIO_DEPTH_FLOAT32) {\n      float *data = spl->buffer.f32;\n      for (i = 0; i < n; ++i) {\n         al_fwrite16le(pf, *data * 0x7FFF);\n         data++;\n      }\n   }\n   else {\n      ALLEGRO_ERROR(\"Unknown audio depth (%d) when saving wav ALLEGRO_FILE.\\n\",\n         spl->depth);\n      return false;\n   }\n\n   return true;\n}", "path": "allegro5/addons/acodec/wav.c", "commit_date": "2018-10-19 00:00:00", "repo_name": "liballeg/allegro5", "stars": 1738, "license": "other", "language": "c", "size": 38145}
{"docstring": "/* [gtk thread] */\n", "func_signal": "static gboolean do_destroy_display_hook(gpointer data)", "code": "{\n   ARGS_DESTROY *args = _al_gtk_lock_args(data);\n   ALLEGRO_DISPLAY_XGLX *d = args->display;\n   bool is_last = args->is_last;\n\n   gtk_widget_destroy(d->gtk->gtkwindow);\n\n   if (is_last) {\n      gtk_main_quit();\n   }\n\n   return _al_gtk_release_args(data);\n}", "path": "allegro5/addons/native_dialog/gtk_xgtk.c", "commit_date": "2020-08-23 00:00:00", "repo_name": "liballeg/allegro5", "stars": 1738, "license": "other", "language": "c", "size": 38145}
{"docstring": "/* [user thread] */\n", "func_signal": "static void xgtk_set_window_position(ALLEGRO_DISPLAY *display, int x, int y)", "code": "{\n   ARGS_POSITION args;\n\n   if (_al_gtk_init_args(&args, sizeof(args))) {\n      args.display = (ALLEGRO_DISPLAY_XGLX *)display;\n      args.x = x;\n      args.y = y;\n      _al_gtk_wait_for_args(do_set_window_position, &args);\n   }\n}", "path": "allegro5/addons/native_dialog/gtk_xgtk.c", "commit_date": "2020-08-23 00:00:00", "repo_name": "liballeg/allegro5", "stars": 1738, "license": "other", "language": "c", "size": 38145}
{"docstring": "/* [gtk thread] */\n", "func_signal": "static gboolean do_resize_display1(gpointer data)", "code": "{\n   ARGS_RESIZE *args = _al_gtk_lock_args(data);\n   ALLEGRO_DISPLAY_XGLX *d = args->display;\n   int w = args->w;\n   int h = args->h;\n\n   /* Using gtk_window_resize by itself is wrong because it does not take\n    * into account the space occupied by other widgets in the window.\n    *\n    * Using gtk_widget_set_size_request by itself is also insufficient as it\n    * sets the *minimum* size. If the socket widget was already larger then\n    * it would do nothing.\n    */\n   gtk_window_resize(GTK_WINDOW(d->gtk->gtkwindow), w, h);\n   gtk_widget_set_size_request(d->gtk->gtksocket, w, h);\n\n   return _al_gtk_release_args(data);\n}", "path": "allegro5/addons/native_dialog/gtk_xgtk.c", "commit_date": "2020-08-23 00:00:00", "repo_name": "liballeg/allegro5", "stars": 1738, "license": "other", "language": "c", "size": 38145}
{"docstring": "/* _al_save_wav:\n * Writes a sample into a wav ALLEGRO_FILE.\n * Returns true on success, false on error.\n */\n", "func_signal": "bool _al_save_wav(const char *filename, ALLEGRO_SAMPLE *spl)", "code": "{\n   ALLEGRO_FILE *pf = al_fopen(filename, \"wb\");\n\n   if (pf) {\n      bool rvsave = _al_save_wav_f(pf, spl);\n      bool rvclose = al_fclose(pf);\n      return rvsave && rvclose;\n   }\n   else {\n      ALLEGRO_ERROR(\"Unable to open %s for writing.\\n\", filename);\n   }\n\n   return false;   \n}", "path": "allegro5/addons/acodec/wav.c", "commit_date": "2018-10-19 00:00:00", "repo_name": "liballeg/allegro5", "stars": 1738, "license": "other", "language": "c", "size": 38145}
{"docstring": "/* wav_open:\n *  Opens f and prepares a WAVFILE struct with the WAV format info.\n *  On a successful return, the ALLEGRO_FILE is at the beginning of the sample data.\n *  returns the WAVFILE on success, or NULL on failure.\n */\n", "func_signal": "static WAVFILE *wav_open(ALLEGRO_FILE *f)", "code": "{\n   WAVFILE *wavfile = NULL;\n   char buffer[12];\n\n   if (!f)\n      goto wav_open_error;\n\n   /* prepare default values */\n   wavfile = al_malloc(sizeof(WAVFILE));\n   if (!wavfile) {\n      ALLEGRO_ERROR(\"Failed to allocate WAVFILE.\\n\");\n      return NULL;\n   }\n   wavfile->f = f;\n   wavfile->freq = 22050;\n   wavfile->bits = 8;\n   wavfile->channels = 1;\n\n   /* check the header */\n   if (al_fread(f, buffer, 12) != 12) {\n      ALLEGRO_ERROR(\"Unexpected EOF while reading the header.\\n\");\n      goto wav_open_error;\n   }\n\n   if (memcmp(buffer, \"RIFF\", 4) || memcmp(buffer+8, \"WAVE\", 4)) {\n      ALLEGRO_ERROR(\"Bad magic number.\\n\");\n      goto wav_open_error;\n   }\n   \n   /* Read as many leading fmt chunks as exist, then read until a data chunk\n    * is found.\n    */\n   while (true) {\n      int length = 0;\n      short pcm = 0;\n\n      if (al_fread(f, buffer, 4) != 4) {\n         ALLEGRO_ERROR(\"Unexpected EOF while reading RIFF type.\\n\");\n         goto wav_open_error;\n      }\n\n      /* check to see if it's a fmt chunk */\n      if (!memcmp(buffer, \"fmt \", 4)) {\n\n         length = al_fread32le(f);\n         if (length < 16) {\n            ALLEGRO_ERROR(\"Bad length: %d.\\n\", length);\n            goto wav_open_error;\n         }\n\n         /* should be 1 for PCM data */\n         pcm = al_fread16le(f);\n         if (pcm != 1) {\n            ALLEGRO_ERROR(\"Bad PCM value: %d.\\n\", pcm);\n            goto wav_open_error;\n         }\n\n         /* mono or stereo data */\n         wavfile->channels = al_fread16le(f);\n\n         if ((wavfile->channels != 1) && (wavfile->channels != 2)) {\n            ALLEGRO_ERROR(\"Bad number of channels: %d.\\n\", wavfile->channels);\n            goto wav_open_error;\n         }\n\n         /* sample frequency */\n         wavfile->freq = al_fread32le(f);\n       \n         /* skip six bytes */\n         al_fseek(f, 6, ALLEGRO_SEEK_CUR);   \n\n         /* 8 or 16 bit data? */\n         wavfile->bits = al_fread16le(f);\n         if ((wavfile->bits != 8) && (wavfile->bits != 16)) {\n            ALLEGRO_ERROR(\"Bad number of bits: %d.\\n\", wavfile->bits);\n            goto wav_open_error;\n         }\n\n         /* Skip remainder of chunk */\n         length -= 16;\n         if (length > 0)\n            al_fseek(f, length, ALLEGRO_SEEK_CUR);\n      }\n      else {\n         if (!memcmp(buffer, \"data\", 4)) {\n            ALLEGRO_ERROR(\"Bad RIFF type.\\n\");\n            break;\n         }\n         ALLEGRO_INFO(\"Ignoring chunk: %c%c%c%c\\n\", buffer[0], buffer[1],\n            buffer[2], buffer[3]);\n         length = al_fread32le(f);\n         al_fseek(f, length, ALLEGRO_SEEK_CUR);\n      }\n   }\n\n   /* find out how many samples exist */\n   wavfile->samples = al_fread32le(f);\n\n   if (wavfile->channels == 2) {\n      wavfile->samples = (wavfile->samples + 1) / 2;\n   }\n\n   if (wavfile->bits == 16) {\n      wavfile->samples /= 2;\n   }\n\n   wavfile->sample_size = wavfile->channels * wavfile->bits / 8;\n\n   wavfile->dpos = al_ftell(f);\n\n   return wavfile;\n\nwav_open_error:\n\n   if (wavfile)\n      al_free(wavfile);\n\n   return NULL;\n}", "path": "allegro5/addons/acodec/wav.c", "commit_date": "2018-10-19 00:00:00", "repo_name": "liballeg/allegro5", "stars": 1738, "license": "other", "language": "c", "size": 38145}
{"docstring": "/* [gtk thread] */\n", "func_signal": "static gboolean do_set_window_title(gpointer data)", "code": "{\n   ARGS_TITLE *args = _al_gtk_lock_args(data);\n   ALLEGRO_DISPLAY_XGLX *d = args->display;\n   const char *title = args->title;\n\n   gtk_window_set_title(GTK_WINDOW(d->gtk->gtkwindow), title);\n\n   return _al_gtk_release_args(data);\n}", "path": "allegro5/addons/native_dialog/gtk_xgtk.c", "commit_date": "2020-08-23 00:00:00", "repo_name": "liballeg/allegro5", "stars": 1738, "license": "other", "language": "c", "size": 38145}
{"docstring": "/* _al_load_wav:\n *  Reads a RIFF WAV format sample ALLEGRO_FILE, returning an ALLEGRO_SAMPLE\n *  structure, or NULL on error.\n */\n", "func_signal": "ALLEGRO_SAMPLE *_al_load_wav(const char *filename)", "code": "{\n   ALLEGRO_FILE *f;\n   ALLEGRO_SAMPLE *spl;\n   ASSERT(filename);\n\n   f = al_fopen(filename, \"rb\");\n   if (!f) {\n      ALLEGRO_ERROR(\"Unable to open %s for reading.\\n\", filename);\n      return NULL;\n   }\n\n   spl = _al_load_wav_f(f);\n\n   al_fclose(f);\n\n   return spl;\n}", "path": "allegro5/addons/acodec/wav.c", "commit_date": "2018-10-19 00:00:00", "repo_name": "liballeg/allegro5", "stars": 1738, "license": "other", "language": "c", "size": 38145}
{"docstring": "/* [gtk thread] */\n", "func_signal": "static gboolean do_create_display_hook(gpointer data)", "code": "{\n   const ARGS_CREATE *args = _al_gtk_lock_args(data);\n   ALLEGRO_DISPLAY *display = (ALLEGRO_DISPLAY *)args->display;\n   ALLEGRO_DISPLAY_XGLX *d = args->display;\n   const int w = args->w;\n   const int h = args->h;\n\n   GtkWidget *window;\n   GtkWidget *vbox;\n   GtkWidget *socket;\n\n   window = gtk_window_new(GTK_WINDOW_TOPLEVEL);\n   d->gtk->gtkwindow = window;\n   gtk_window_set_default_size(GTK_WINDOW(window), w, h);\n\n   g_signal_connect(G_OBJECT(window), \"delete-event\",\n      G_CALLBACK(xgtk_quit_callback), display);\n   g_signal_connect(G_OBJECT(window), \"configure-event\",\n      G_CALLBACK(xgtk_handle_configure_event), display);\n\n   vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);\n   gtk_container_add(GTK_CONTAINER(window), vbox);\n\n   socket = gtk_socket_new();\n   d->gtk->gtksocket = socket;\n   gtk_box_pack_end(GTK_BOX(vbox), socket, TRUE, TRUE, 0);\n   gtk_socket_add_id(GTK_SOCKET(socket), d->window);\n   ALLEGRO_DEBUG(\"gtk_socket_add_id: window = %ld\\n\", d->window);\n\n   gtk_window_set_title(GTK_WINDOW(window), args->title);\n\n   gtk_widget_show_all(window);\n\n   if (display->flags & ALLEGRO_RESIZABLE) {\n      /* Allow socket widget to be resized smaller than initial size. */\n      gtk_widget_set_size_request(socket, -1, -1);\n      gtk_window_set_resizable(GTK_WINDOW(window), true);\n   }\n   else {\n      gtk_window_set_resizable(GTK_WINDOW(window), false);\n   }\n\n   if (display->flags & ALLEGRO_FULLSCREEN_WINDOW) {\n      gtk_window_fullscreen(GTK_WINDOW(window));\n   }\n\n   d->overridable_vt = &xgtk_override_vt;\n\n   return _al_gtk_release_args(data);\n}", "path": "allegro5/addons/native_dialog/gtk_xgtk.c", "commit_date": "2020-08-23 00:00:00", "repo_name": "liballeg/allegro5", "stars": 1738, "license": "other", "language": "c", "size": 38145}
{"docstring": "/* wav_stream_rewind:\n *  Rewinds 'stream' to the beginning of the data chunk.\n *  Returns true on success, false on failure.\n */\n", "func_signal": "static bool wav_stream_rewind(ALLEGRO_AUDIO_STREAM *stream)", "code": "{\n   WAVFILE *wavfile = (WAVFILE *) stream->extra;\n   return wav_stream_seek(stream, wavfile->loop_start);\n}", "path": "allegro5/addons/acodec/wav.c", "commit_date": "2018-10-19 00:00:00", "repo_name": "liballeg/allegro5", "stars": 1738, "license": "other", "language": "c", "size": 38145}
{"docstring": "/* [gtk thread] */\n", "func_signal": "static gboolean do_resize_display2(gpointer data)", "code": "{\n   ARGS_RESIZE *args = _al_gtk_lock_args(data);\n   ALLEGRO_DISPLAY_XGLX *d = args->display;\n\n   /* Remove the minimum size constraint again. */\n   gtk_widget_set_size_request(d->gtk->gtksocket, -1, -1);\n\n   return _al_gtk_release_args(data);\n}", "path": "allegro5/addons/native_dialog/gtk_xgtk.c", "commit_date": "2020-08-23 00:00:00", "repo_name": "liballeg/allegro5", "stars": 1738, "license": "other", "language": "c", "size": 38145}
{"docstring": "/* _al_load_wav_audio_stream:\n*/\n", "func_signal": "ALLEGRO_AUDIO_STREAM *_al_load_wav_audio_stream(const char *filename,\n   size_t buffer_count, unsigned int samples)", "code": "{\n   ALLEGRO_FILE *f;\n   ALLEGRO_AUDIO_STREAM *stream;\n   ASSERT(filename);\n\n   f = al_fopen(filename, \"rb\");\n   if (!f) {\n      ALLEGRO_ERROR(\"Unable to open %s for reading.\\n\", filename);\n      return NULL;\n   }\n\n   stream = _al_load_wav_audio_stream_f(f, buffer_count, samples);\n   if (!stream) {\n      ALLEGRO_ERROR(\"Failed to load wav stream.\\n\");\n      al_fclose(f);\n   }\n\n   return stream;\n}", "path": "allegro5/addons/acodec/wav.c", "commit_date": "2018-10-19 00:00:00", "repo_name": "liballeg/allegro5", "stars": 1738, "license": "other", "language": "c", "size": 38145}
{"docstring": "/* [user thread] */\n", "func_signal": "static bool xgtk_resize_display(ALLEGRO_DISPLAY *display, int w, int h)", "code": "{\n   ALLEGRO_SYSTEM_XGLX *system = (ALLEGRO_SYSTEM_XGLX *)al_get_system_driver();\n   ALLEGRO_DISPLAY_XGLX *d = (ALLEGRO_DISPLAY_XGLX *)display;\n   bool ret = true;\n\n   _al_mutex_lock(&system->lock);\n\n   if (w != display->w || h != display->h) {\n      do {\n         const int old_resize_count = d->resize_count;\n         ARGS_RESIZE args;\n\n         d->programmatic_resize = true;\n\n         if (!_al_gtk_init_args(&args, sizeof(args))) {\n            ret = false;\n            break;\n         }\n         args.display = d;\n         args.w = w;\n         args.h = h;\n         _al_gtk_wait_for_args(do_resize_display1, &args);\n\n         _al_display_xglx_await_resize(display, old_resize_count, false);\n\n         if (_al_gtk_init_args(&args, sizeof(args))) {\n            args.display = d;\n            _al_gtk_wait_for_args(do_resize_display2, &args);\n         }\n\n         d->programmatic_resize = false;\n      } while (0);\n   }\n\n   _al_mutex_unlock(&system->lock);\n\n   return ret;\n}", "path": "allegro5/addons/native_dialog/gtk_xgtk.c", "commit_date": "2020-08-23 00:00:00", "repo_name": "liballeg/allegro5", "stars": 1738, "license": "other", "language": "c", "size": 38145}
{"docstring": "/* [gtk thread] */\n", "func_signal": "static gboolean do_set_fullscreen_window(gpointer data)", "code": "{\n   ARGS_FULLSCREEN_WINDOW *args = _al_gtk_lock_args(data);\n   ALLEGRO_DISPLAY_XGLX *d = args->display;\n   bool fullscreen = args->fullscreen;\n\n   if (fullscreen) {\n      gtk_window_fullscreen(GTK_WINDOW(d->gtk->gtkwindow));\n   }\n   else {\n      gtk_window_unfullscreen(GTK_WINDOW(d->gtk->gtkwindow));\n   }\n\n   return _al_gtk_release_args(args);\n}", "path": "allegro5/addons/native_dialog/gtk_xgtk.c", "commit_date": "2020-08-23 00:00:00", "repo_name": "liballeg/allegro5", "stars": 1738, "license": "other", "language": "c", "size": 38145}
{"docstring": "/* wav_stream_close:\n *  Closes the 'stream'.\n */\n", "func_signal": "static void wav_stream_close(ALLEGRO_AUDIO_STREAM *stream)", "code": "{\n   WAVFILE *wavfile = (WAVFILE *) stream->extra;\n\n   _al_acodec_stop_feed_thread(stream);\n   \n   al_fclose(wavfile->f);\n   wav_close(wavfile);\n   stream->extra = NULL;\n   stream->feed_thread = NULL;\n}", "path": "allegro5/addons/acodec/wav.c", "commit_date": "2018-10-19 00:00:00", "repo_name": "liballeg/allegro5", "stars": 1738, "license": "other", "language": "c", "size": 38145}
{"docstring": "/* [user thread] */\n", "func_signal": "static bool xgtk_create_display_hook(ALLEGRO_DISPLAY *display, int w, int h)", "code": "{\n   ALLEGRO_DISPLAY_XGLX *d = (ALLEGRO_DISPLAY_XGLX *)display;\n   ARGS_CREATE args;\n\n   d->gtk = al_calloc(1, sizeof(*(d->gtk)));\n   if (!d->gtk) {\n      ALLEGRO_WARN(\"Out of memory\\n\");\n      return false;\n   }\n\n   if (!_al_gtk_ensure_thread()) {\n      al_free(d->gtk);\n      d->gtk = NULL;\n      return false;\n   }\n\n   if (!_al_gtk_init_args(&args, sizeof(args))) {\n      al_free(d->gtk);\n      d->gtk = NULL;\n      return false;\n   }\n\n   args.display = d;\n   args.w = w;\n   args.h = h;\n   args.title = al_get_new_window_title();\n\n   return _al_gtk_wait_for_args(do_create_display_hook, &args);\n}", "path": "allegro5/addons/native_dialog/gtk_xgtk.c", "commit_date": "2020-08-23 00:00:00", "repo_name": "liballeg/allegro5", "stars": 1738, "license": "other", "language": "c", "size": 38145}
{"docstring": "/* [user thread] */\n", "func_signal": "static bool xgtk_set_window_constraints(ALLEGRO_DISPLAY *display,\n   int min_w, int min_h, int max_w, int max_h)", "code": "{\n   // FIXME\n   (void)display;\n   (void)min_w;\n   (void)min_h;\n   (void)max_w;\n   (void)max_h;\n   return true;\n}", "path": "allegro5/addons/native_dialog/gtk_xgtk.c", "commit_date": "2020-08-23 00:00:00", "repo_name": "liballeg/allegro5", "stars": 1738, "license": "other", "language": "c", "size": 38145}
{"docstring": "/* wav_stream_update:\n *  Updates 'stream' with the next chunk of data.\n *  Returns the actual number of bytes written.\n */\n", "func_signal": "static size_t wav_stream_update(ALLEGRO_AUDIO_STREAM *stream, void *data,\n   size_t buf_size)", "code": "{\n   int bytes_per_sample, samples, samples_read;\n   double ctime, btime;\n\n   WAVFILE *wavfile = (WAVFILE *) stream->extra;\n   bytes_per_sample = (wavfile->bits / 8) * wavfile->channels;\n   ctime = wav_stream_get_position(stream);\n   btime = ((double)buf_size / (double)bytes_per_sample) / (double)(wavfile->freq);\n   \n   if (stream->spl.loop == _ALLEGRO_PLAYMODE_STREAM_ONEDIR && ctime + btime > wavfile->loop_end) {\n      samples = ((wavfile->loop_end - ctime) * (double)(wavfile->freq));\n   }\n   else {\n      samples = buf_size / bytes_per_sample;\n   }\n   if (samples < 0)\n      return 0;\n\n   samples_read = wav_read(wavfile, data, samples);\n\n   return samples_read * bytes_per_sample;\n}", "path": "allegro5/addons/acodec/wav.c", "commit_date": "2018-10-19 00:00:00", "repo_name": "liballeg/allegro5", "stars": 1738, "license": "other", "language": "c", "size": 38145}
{"docstring": "/* _al_load_wav_audio_stream_f:\n*/\n", "func_signal": "ALLEGRO_AUDIO_STREAM *_al_load_wav_audio_stream_f(ALLEGRO_FILE* f,\n   size_t buffer_count, unsigned int samples)", "code": "{\n   WAVFILE* wavfile;\n   ALLEGRO_AUDIO_STREAM* stream;\n\n   wavfile = wav_open(f);\n   \n   if (wavfile == NULL) {\n      ALLEGRO_ERROR(\"Failed to load wav file.\\n\");\n      return NULL;\n   }\n\n   stream = al_create_audio_stream(buffer_count, samples, wavfile->freq,\n      _al_word_size_to_depth_conf(wavfile->bits / 8),\n      _al_count_to_channel_conf(wavfile->channels));\n\n   if (stream) {\n      stream->extra = wavfile;\n      wavfile->loop_start = 0.0;\n      wavfile->loop_end = wav_stream_get_length(stream);\n      stream->feeder = wav_stream_update;\n      stream->unload_feeder = wav_stream_close;\n      stream->rewind_feeder = wav_stream_rewind;\n      stream->seek_feeder = wav_stream_seek;\n      stream->get_feeder_position = wav_stream_get_position;\n      stream->get_feeder_length = wav_stream_get_length;\n      stream->set_feeder_loop = wav_stream_set_loop;\n      _al_acodec_start_feed_thread(stream);\n   }\n   else {\n      ALLEGRO_ERROR(\"Failed to load wav stream.\\n\");\n      wav_close(wavfile);\n   }\n\n   return stream;\n}", "path": "allegro5/addons/acodec/wav.c", "commit_date": "2018-10-19 00:00:00", "repo_name": "liballeg/allegro5", "stars": 1738, "license": "other", "language": "c", "size": 38145}
{"docstring": "/* [user thread] */\n", "func_signal": "static void xgtk_set_window_title(ALLEGRO_DISPLAY *display, const char *title)", "code": "{\n   ARGS_TITLE args;\n\n   if (_al_gtk_init_args(&args, sizeof(args))) {\n      args.display = (ALLEGRO_DISPLAY_XGLX *)display;\n      args.title = title;\n      _al_gtk_wait_for_args(do_set_window_title, &args);\n   }\n}", "path": "allegro5/addons/native_dialog/gtk_xgtk.c", "commit_date": "2020-08-23 00:00:00", "repo_name": "liballeg/allegro5", "stars": 1738, "license": "other", "language": "c", "size": 38145}
{"docstring": "//\n// MOVE A FLOOR TO IT'S DESTINATION (UP OR DOWN)\n//\n", "func_signal": "void T_MoveFloor(floormove_t* floor)", "code": "{\n    result_e\tres;\n\n    res = T_MovePlane(floor->sector,\n                      floor->speed,\n                      floor->floordestheight,\n                      floor->crush,0,floor->direction);\n\n    if (!(leveltime&7))\n        S_StartSound((mobj_t *)&floor->sector->soundorg,\n                     sfx_stnmov);\n\n    if (res == pastdest)\n    {\n        floor->sector->specialdata = NULL;\n\n        if (floor->direction == 1)\n        {\n            switch(floor->type)\n            {\n                case donutRaise:\n                    floor->sector->special = floor->newspecial;\n                    floor->sector->floorpic = floor->texture;\n                default:\n                    break;\n            }\n        }\n        else if (floor->direction == -1)\n        {\n            switch(floor->type)\n            {\n                case lowerAndChange:\n                    floor->sector->special = floor->newspecial;\n                    floor->sector->floorpic = floor->texture;\n                default:\n                    break;\n            }\n        }\n        P_RemoveThinker(&floor->thinker);\n\n        S_StartSound((mobj_t *)&floor->sector->soundorg,\n                     sfx_pstop);\n    }\n\n}", "path": "NyuziProcessor/software/apps/doom/p_floor.c", "commit_date": "2016-01-02 00:00:00", "repo_name": "jbush001/NyuziProcessor", "stars": 1881, "license": "apache-2.0", "language": "c", "size": 32907}
{"docstring": "//\n// R_InitPointToAngle\n//\n", "func_signal": "void R_InitPointToAngle (void)", "code": "{\n    // UNUSED - now getting from tables.c\n#if 0\n    int i;\n    long\t\tt;\n    float\t\tf;\n//\n// slope (tangent) to angle lookup\n//\n    for (i=0 ; i<=SLOPERANGE ; i++)\n    {\n        f = atan( (float)i/SLOPERANGE )/(3.141592657*2);\n        t = 0xffffffff*f;\n        tantoangle[i] = t;\n    }\n#endif\n}", "path": "NyuziProcessor/software/apps/doom/r_main.c", "commit_date": "2016-01-02 00:00:00", "repo_name": "jbush001/NyuziProcessor", "stars": 1881, "license": "apache-2.0", "language": "c", "size": 32907}
{"docstring": "// PS/2 scancodes set 2\n", "func_signal": "static unsigned int sdl_to_ps2(SDL_Scancode code)", "code": "{\n    switch (code)\n    {\n        case SDL_SCANCODE_A:\n            return 0x1c;\n        case SDL_SCANCODE_B:\n            return 0x32;\n        case SDL_SCANCODE_C:\n            return 0x21;\n        case SDL_SCANCODE_D:\n            return 0x23;\n        case SDL_SCANCODE_E:\n            return 0x24;\n        case SDL_SCANCODE_F:\n            return 0x2b;\n        case SDL_SCANCODE_G:\n            return 0x34;\n        case SDL_SCANCODE_H:\n            return 0x33;\n        case SDL_SCANCODE_I:\n            return 0x43;\n        case SDL_SCANCODE_J:\n            return 0x3b;\n        case SDL_SCANCODE_K:\n            return 0x42;\n        case SDL_SCANCODE_L:\n            return 0x4b;\n        case SDL_SCANCODE_M:\n            return 0x3a;\n        case SDL_SCANCODE_N:\n            return 0x31;\n        case SDL_SCANCODE_O:\n            return 0x44;\n        case SDL_SCANCODE_P:\n            return 0x4d;\n        case SDL_SCANCODE_Q:\n            return 0x15;\n        case SDL_SCANCODE_R:\n            return 0x2d;\n        case SDL_SCANCODE_S:\n            return 0x1b;\n        case SDL_SCANCODE_T:\n            return 0x2c;\n        case SDL_SCANCODE_U:\n            return 0x3c;\n        case SDL_SCANCODE_V:\n            return 0x2a;\n        case SDL_SCANCODE_W:\n            return 0x1d;\n        case SDL_SCANCODE_X:\n            return 0x22;\n        case SDL_SCANCODE_Y:\n            return 0x35;\n        case SDL_SCANCODE_Z:\n            return 0x1a;\n        case SDL_SCANCODE_1:\n            return 0x16;\n        case SDL_SCANCODE_2:\n            return 0x1e;\n        case SDL_SCANCODE_3:\n            return 0x26;\n        case SDL_SCANCODE_4:\n            return 0x25;\n        case SDL_SCANCODE_5:\n            return 0x2e;\n        case SDL_SCANCODE_6:\n            return 0x36;\n        case SDL_SCANCODE_7:\n            return 0x3d;\n        case SDL_SCANCODE_8:\n            return 0x3e;\n        case SDL_SCANCODE_9:\n            return 0x46;\n        case SDL_SCANCODE_0:\n            return 0x45;\n        case SDL_SCANCODE_RETURN:\n            return 0x5a;\n        case SDL_SCANCODE_ESCAPE:\n            return 0x76;\n        case SDL_SCANCODE_BACKSPACE:\n            return 0x66;\n        case SDL_SCANCODE_TAB:\n            return 0x0d;\n        case SDL_SCANCODE_SPACE:\n            return 0x29;\n        case SDL_SCANCODE_MINUS:\n            return 0x4e;\n        case SDL_SCANCODE_EQUALS:\n            return 0x55;\n        case SDL_SCANCODE_LEFTBRACKET:\n            return 0x54;\n        case SDL_SCANCODE_RIGHTBRACKET:\n            return 0x5b;\n        case SDL_SCANCODE_BACKSLASH:\n            return 0x5d;\n        case SDL_SCANCODE_SEMICOLON:\n            return 0x4c;\n        case SDL_SCANCODE_APOSTROPHE:\n            return 0x52;\n        case SDL_SCANCODE_GRAVE:\n            return 0x0e;\n        case SDL_SCANCODE_COMMA:\n            return 0x41;\n        case SDL_SCANCODE_PERIOD:\n            return 0x49;\n        case SDL_SCANCODE_SLASH:\n            return 0x4a;\n        case SDL_SCANCODE_CAPSLOCK:\n            return 0x58;\n        case SDL_SCANCODE_F1:\n            return 0x05;\n        case SDL_SCANCODE_F2:\n            return 0x06;\n        case SDL_SCANCODE_F3:\n            return 0x04;\n        case SDL_SCANCODE_F4:\n            return 0x0c;\n        case SDL_SCANCODE_F5:\n            return 0x03;\n        case SDL_SCANCODE_F6:\n            return 0x0b;\n        case SDL_SCANCODE_F7:\n            return 0x83;\n        case SDL_SCANCODE_F8:\n            return 0x0a;\n        case SDL_SCANCODE_F9:\n            return 0x01;\n        case SDL_SCANCODE_F10:\n            return 0x09;\n        case SDL_SCANCODE_F11:\n            return 0x78;\n        case SDL_SCANCODE_F12:\n            return 0x07;\n        case SDL_SCANCODE_PRINTSCREEN:\n            return 0xe012;\n        case SDL_SCANCODE_SCROLLLOCK:\n            return 0x7e;\n        case SDL_SCANCODE_INSERT:\n            return 0xe070;\n        case SDL_SCANCODE_HOME:\n            return 0xe06c;\n        case SDL_SCANCODE_PAGEUP:\n            return 0xe07d;\n        case SDL_SCANCODE_DELETE:\n            return 0xe071;\n        case SDL_SCANCODE_END:\n            return 0xe069;\n        case SDL_SCANCODE_PAGEDOWN:\n            return 0xe07a;\n        case SDL_SCANCODE_RIGHT:\n            return 0xe074;\n        case SDL_SCANCODE_LEFT:\n            return 0xe06b;\n        case SDL_SCANCODE_DOWN:\n            return 0xe072;\n        case SDL_SCANCODE_UP:\n            return 0xe075;\n        case SDL_SCANCODE_KP_DIVIDE:\n            return 0xe04a;\n        case SDL_SCANCODE_KP_MULTIPLY:\n            return 0x7c;\n        case SDL_SCANCODE_KP_MINUS:\n            return 0x7b;\n        case SDL_SCANCODE_KP_PLUS:\n            return 0x79;\n        case SDL_SCANCODE_KP_ENTER:\n            return 0xe05a;\n        case SDL_SCANCODE_KP_1:\n            return 0x69;\n        case SDL_SCANCODE_KP_2:\n            return 0x72;\n        case SDL_SCANCODE_KP_3:\n            return 0x7a;\n        case SDL_SCANCODE_KP_4:\n            return 0x6b;\n        case SDL_SCANCODE_KP_5:\n            return 0x73;\n        case SDL_SCANCODE_KP_6:\n            return 0x74;\n        case SDL_SCANCODE_KP_7:\n            return 0x6c;\n        case SDL_SCANCODE_KP_8:\n            return 0x75;\n        case SDL_SCANCODE_KP_9:\n            return 0x7d;\n        case SDL_SCANCODE_KP_0:\n            return 0x70;\n        case SDL_SCANCODE_KP_PERIOD:\n            return 0x71;\n        case SDL_SCANCODE_LCTRL:\n            return 0x14;\n        case SDL_SCANCODE_LSHIFT:\n            return 0x12;\n        case SDL_SCANCODE_LALT:\n            return 0x11;\n        case SDL_SCANCODE_LGUI:\n            return 0xe01f;\n        case SDL_SCANCODE_RCTRL:\n            return 0xe014;\n        case SDL_SCANCODE_RSHIFT:\n            return 0x59;\n        case SDL_SCANCODE_RALT:\n            return 0xe011;\n        case SDL_SCANCODE_RGUI:\n            return 0xe027;\n        default:\n            return 0xffffffff;\n    }\n}", "path": "NyuziProcessor/tools/emulator/fbwindow.c", "commit_date": "2016-11-10 00:00:00", "repo_name": "jbush001/NyuziProcessor", "stars": 1881, "license": "apache-2.0", "language": "c", "size": 32907}
{"docstring": "//\n// I_Quit\n//\n", "func_signal": "void I_Quit (void)", "code": "{\n    D_QuitNetGame ();\n    I_ShutdownSound();\n    I_ShutdownMusic();\n    M_SaveDefaults ();\n    I_ShutdownGraphics();\n    exit(0);\n}", "path": "NyuziProcessor/software/apps/doom/i_system.c", "commit_date": "2016-01-02 00:00:00", "repo_name": "jbush001/NyuziProcessor", "stars": 1881, "license": "apache-2.0", "language": "c", "size": 32907}
{"docstring": "//\n// R_PointOnSide\n// Traverse BSP (sub) tree,\n//\tcheck point against partition plane.\n// Returns side 0 (front) or 1 (back).\n//\n", "func_signal": "int\nR_PointOnSide\n( fixed_t\t\tx,\n  fixed_t\t\ty,\n  node_t*\t\tnode )", "code": "{\n    fixed_t\t\tdx;\n    fixed_t\t\tdy;\n    fixed_t\t\tleft;\n    fixed_t\t\tright;\n\n    if (!node->dx)\n    {\n        if (x <= node->x)\n            return node->dy > 0;\n\n        return node->dy < 0;\n    }\n    if (!node->dy)\n    {\n        if (y <= node->y)\n            return node->dx < 0;\n\n        return node->dx > 0;\n    }\n\n    dx = (x - node->x);\n    dy = (y - node->y);\n\n    // Try to quickly decide by looking at sign bits.\n    if ( (node->dy ^ node->dx ^ dx ^ dy)&0x80000000 )\n    {\n        if\t( (node->dy ^ dx) & 0x80000000 )\n        {\n            // (left is negative)\n            return 1;\n        }\n        return 0;\n    }\n\n    left = FixedMul ( node->dy>>FRACBITS , dx );\n    right = FixedMul ( dy , node->dx>>FRACBITS );\n\n    if (right < left)\n    {\n        // front side\n        return 0;\n    }\n    // back side\n    return 1;\n}", "path": "NyuziProcessor/software/apps/doom/r_main.c", "commit_date": "2016-01-02 00:00:00", "repo_name": "jbush001/NyuziProcessor", "stars": 1881, "license": "apache-2.0", "language": "c", "size": 32907}
{"docstring": "//\n// Add an active ceiling\n//\n", "func_signal": "void P_AddActiveCeiling(ceiling_t* c)", "code": "{\n    int\t\t\ti;\n\n    for (i = 0; i < MAXCEILINGS; i++)\n    {\n        if (activeceilings[i] == NULL)\n        {\n            activeceilings[i] = c;\n            return;\n        }\n    }\n}", "path": "NyuziProcessor/software/apps/doom/p_ceilng.c", "commit_date": "2016-01-02 00:00:00", "repo_name": "jbush001/NyuziProcessor", "stars": 1881, "license": "apache-2.0", "language": "c", "size": 32907}
{"docstring": "//\n// R_AddPointToBox\n// Expand a given bbox\n// so that it encloses a given point.\n//\n", "func_signal": "void\nR_AddPointToBox\n( int\t\t\tx,\n  int\t\t\ty,\n  fixed_t*\t\tbox )", "code": "{\n    if (x< box[BOXLEFT])\n        box[BOXLEFT] = x;\n    if (x> box[BOXRIGHT])\n        box[BOXRIGHT] = x;\n    if (y< box[BOXBOTTOM])\n        box[BOXBOTTOM] = y;\n    if (y> box[BOXTOP])\n        box[BOXTOP] = y;\n}", "path": "NyuziProcessor/software/apps/doom/r_main.c", "commit_date": "2016-01-02 00:00:00", "repo_name": "jbush001/NyuziProcessor", "stars": 1881, "license": "apache-2.0", "language": "c", "size": 32907}
{"docstring": "//\n// Move a plane (floor or ceiling) and check for crushing\n//\n", "func_signal": "result_e\nT_MovePlane\n( sector_t*\t\tsector,\n  fixed_t\t\tspeed,\n  fixed_t\t\tdest,\n  boolean\t\tcrush,\n  int\t\t\tfloorOrCeiling,\n  int\t\t\tdirection )", "code": "{\n    boolean\t\tflag;\n    fixed_t\t\tlastpos;\n\n    switch(floorOrCeiling)\n    {\n        case 0:\n            // FLOOR\n            switch(direction)\n            {\n                case -1:\n                    // DOWN\n                    if (sector->floorheight - speed < dest)\n                    {\n                        lastpos = sector->floorheight;\n                        sector->floorheight = dest;\n                        flag = P_ChangeSector(sector,crush);\n                        if (flag == true)\n                        {\n                            sector->floorheight =lastpos;\n                            P_ChangeSector(sector,crush);\n                            //return crushed;\n                        }\n                        return pastdest;\n                    }\n                    else\n                    {\n                        lastpos = sector->floorheight;\n                        sector->floorheight -= speed;\n                        flag = P_ChangeSector(sector,crush);\n                        if (flag == true)\n                        {\n                            sector->floorheight = lastpos;\n                            P_ChangeSector(sector,crush);\n                            return crushed;\n                        }\n                    }\n                    break;\n\n                case 1:\n                    // UP\n                    if (sector->floorheight + speed > dest)\n                    {\n                        lastpos = sector->floorheight;\n                        sector->floorheight = dest;\n                        flag = P_ChangeSector(sector,crush);\n                        if (flag == true)\n                        {\n                            sector->floorheight = lastpos;\n                            P_ChangeSector(sector,crush);\n                            //return crushed;\n                        }\n                        return pastdest;\n                    }\n                    else\n                    {\n                        // COULD GET CRUSHED\n                        lastpos = sector->floorheight;\n                        sector->floorheight += speed;\n                        flag = P_ChangeSector(sector,crush);\n                        if (flag == true)\n                        {\n                            if (crush == true)\n                                return crushed;\n                            sector->floorheight = lastpos;\n                            P_ChangeSector(sector,crush);\n                            return crushed;\n                        }\n                    }\n                    break;\n            }\n            break;\n\n        case 1:\n            // CEILING\n            switch(direction)\n            {\n                case -1:\n                    // DOWN\n                    if (sector->ceilingheight - speed < dest)\n                    {\n                        lastpos = sector->ceilingheight;\n                        sector->ceilingheight = dest;\n                        flag = P_ChangeSector(sector,crush);\n\n                        if (flag == true)\n                        {\n                            sector->ceilingheight = lastpos;\n                            P_ChangeSector(sector,crush);\n                            //return crushed;\n                        }\n                        return pastdest;\n                    }\n                    else\n                    {\n                        // COULD GET CRUSHED\n                        lastpos = sector->ceilingheight;\n                        sector->ceilingheight -= speed;\n                        flag = P_ChangeSector(sector,crush);\n\n                        if (flag == true)\n                        {\n                            if (crush == true)\n                                return crushed;\n                            sector->ceilingheight = lastpos;\n                            P_ChangeSector(sector,crush);\n                            return crushed;\n                        }\n                    }\n                    break;\n\n                case 1:\n                    // UP\n                    if (sector->ceilingheight + speed > dest)\n                    {\n                        lastpos = sector->ceilingheight;\n                        sector->ceilingheight = dest;\n                        flag = P_ChangeSector(sector,crush);\n                        if (flag == true)\n                        {\n                            sector->ceilingheight = lastpos;\n                            P_ChangeSector(sector,crush);\n                            //return crushed;\n                        }\n                        return pastdest;\n                    }\n                    else\n                    {\n                        lastpos = sector->ceilingheight;\n                        sector->ceilingheight += speed;\n                        flag = P_ChangeSector(sector,crush);\n// UNUSED\n#if 0\n                        if (flag == true)\n                        {\n                            sector->ceilingheight = lastpos;\n                            P_ChangeSector(sector,crush);\n                            return crushed;\n                        }\n#endif\n                    }\n                    break;\n            }\n            break;\n\n    }\n    return ok;\n}", "path": "NyuziProcessor/software/apps/doom/p_floor.c", "commit_date": "2016-01-02 00:00:00", "repo_name": "jbush001/NyuziProcessor", "stars": 1881, "license": "apache-2.0", "language": "c", "size": 32907}
{"docstring": "//\n// R_ScaleFromGlobalAngle\n// Returns the texture mapping scale\n//\tfor the current line (horizontal span)\n//\tat the given angle.\n// rw_distance must be calculated first.\n//\n", "func_signal": "fixed_t R_ScaleFromGlobalAngle (angle_t visangle)", "code": "{\n    fixed_t\t\t\t\tscale;\n    int\t\t\t\t\tanglea;\n    int\t\t\t\t\tangleb;\n    int\t\t\t\t\tsinea;\n    int\t\t\t\t\tsineb;\n    fixed_t\t\t\t\tnum;\n    int\t\t\t\t\tden;\n\n    // UNUSED\n#if 0\n    {\n        fixed_t\t\t\t\tdist;\n        fixed_t\t\t\t\tz;\n        fixed_t\t\t\t\tsinv;\n        fixed_t\t\t\t\tcosv;\n\n        sinv = finesine[(visangle-rw_normalangle)>>ANGLETOFINESHIFT];\n        dist = FixedDiv (rw_distance, sinv);\n        cosv = finecosine[(viewangle-visangle)>>ANGLETOFINESHIFT];\n        z = abs(FixedMul (dist, cosv));\n        scale = FixedDiv(projection, z);\n        return scale;\n    }\n#endif\n\n    anglea = ANG90 + (visangle-viewangle);\n    angleb = ANG90 + (visangle-rw_normalangle);\n\n    // both sines are allways positive\n    sinea = finesine[anglea>>ANGLETOFINESHIFT];\n    sineb = finesine[angleb>>ANGLETOFINESHIFT];\n    num = FixedMul(projection,sineb)<<detailshift;\n    den = FixedMul(rw_distance,sinea);\n\n    if (den > num>>16)\n    {\n        scale = FixedDiv (num, den);\n\n        if (scale > 64*FRACUNIT)\n            scale = 64*FRACUNIT;\n        else if (scale < 256)\n            scale = 256;\n    }\n    else\n        scale = 64*FRACUNIT;\n\n    return scale;\n}", "path": "NyuziProcessor/software/apps/doom/r_main.c", "commit_date": "2016-01-02 00:00:00", "repo_name": "jbush001/NyuziProcessor", "stars": 1881, "license": "apache-2.0", "language": "c", "size": 32907}
{"docstring": "//\n// R_RenderView\n//\n", "func_signal": "void R_RenderPlayerView (player_t* player)", "code": "{\n    R_SetupFrame (player);\n\n    // Clear buffers.\n    R_ClearClipSegs ();\n    R_ClearDrawSegs ();\n    R_ClearPlanes ();\n    R_ClearSprites ();\n\n    // check for new console commands.\n    NetUpdate ();\n\n    // The head node is the last node output.\n    R_RenderBSPNode (numnodes-1);\n\n    // Check for new console commands.\n    NetUpdate ();\n\n    R_DrawPlanes ();\n\n    // Check for new console commands.\n    NetUpdate ();\n\n    R_DrawMasked ();\n\n    // Check for new console commands.\n    NetUpdate ();\n}", "path": "NyuziProcessor/software/apps/doom/r_main.c", "commit_date": "2016-01-02 00:00:00", "repo_name": "jbush001/NyuziProcessor", "stars": 1881, "license": "apache-2.0", "language": "c", "size": 32907}
{"docstring": "// Transfer a single byte bidirectionally.\n", "func_signal": "static int spi_transfer(int value)", "code": "{\n    REGISTERS[REG_SD_SPI_WRITE] = value & 0xff;\n    while ((REGISTERS[REG_SD_SPI_STATUS] & 1) == 0)\n        ;\t// Wait for transfer to finish\n\n    return REGISTERS[REG_SD_SPI_READ];\n}", "path": "NyuziProcessor/software/kernel/sd_card.c", "commit_date": "2018-03-03 00:00:00", "repo_name": "jbush001/NyuziProcessor", "stars": 1881, "license": "apache-2.0", "language": "c", "size": 32907}
{"docstring": "//\n// Restart a ceiling that's in-stasis\n//\n", "func_signal": "void P_ActivateInStasisCeiling(line_t* line)", "code": "{\n    int\t\t\ti;\n\n    for (i = 0; i < MAXCEILINGS; i++)\n    {\n        if (activeceilings[i]\n                && (activeceilings[i]->tag == line->tag)\n                && (activeceilings[i]->direction == 0))\n        {\n            activeceilings[i]->direction = activeceilings[i]->olddirection;\n            activeceilings[i]->thinker.function.acp1\n                = (actionf_p1)T_MoveCeiling;\n        }\n    }\n}", "path": "NyuziProcessor/software/apps/doom/p_ceilng.c", "commit_date": "2016-01-02 00:00:00", "repo_name": "jbush001/NyuziProcessor", "stars": 1881, "license": "apache-2.0", "language": "c", "size": 32907}
{"docstring": "//\n// R_PointInSubsector\n//\n", "func_signal": "subsector_t*\nR_PointInSubsector\n( fixed_t\t\tx,\n  fixed_t\t\ty )", "code": "{\n    node_t*\t\tnode;\n    int\t\t\tside;\n    int\t\t\tnodenum;\n\n    // single subsector is a special case\n    if (!numnodes)\n        return subsectors;\n\n    nodenum = numnodes-1;\n\n    while (! (nodenum & NF_SUBSECTOR) )\n    {\n        node = &nodes[nodenum];\n        side = R_PointOnSide (x, y, node);\n        nodenum = node->children[side];\n    }\n\n    return &subsectors[nodenum & ~NF_SUBSECTOR];\n}", "path": "NyuziProcessor/software/apps/doom/r_main.c", "commit_date": "2016-01-02 00:00:00", "repo_name": "jbush001/NyuziProcessor", "stars": 1881, "license": "apache-2.0", "language": "c", "size": 32907}
{"docstring": "//\n// EV_DoCeiling\n// Move a ceiling up/down and all around!\n//\n", "func_signal": "int\nEV_DoCeiling\n( line_t*\t\tline,\n  ceiling_e\t\ttype )", "code": "{\n    int\t\t\tsecnum;\n    int\t\t\trtn;\n    sector_t*\tsec;\n    ceiling_t*\tceiling;\n\n    secnum = -1;\n    rtn = 0;\n\n    //\tReactivate in-stasis ceilings...for certain types.\n    switch(type)\n    {\n        case fastCrushAndRaise:\n        case silentCrushAndRaise:\n        case crushAndRaise:\n            P_ActivateInStasisCeiling(line);\n        default:\n            break;\n    }\n\n    while ((secnum = P_FindSectorFromLineTag(line,secnum)) >= 0)\n    {\n        sec = &sectors[secnum];\n        if (sec->specialdata)\n            continue;\n\n        // new door thinker\n        rtn = 1;\n        ceiling = Z_Malloc (sizeof(*ceiling), PU_LEVSPEC, 0);\n        P_AddThinker (&ceiling->thinker);\n        sec->specialdata = ceiling;\n        ceiling->thinker.function.acp1 = (actionf_p1)T_MoveCeiling;\n        ceiling->sector = sec;\n        ceiling->crush = false;\n\n        switch(type)\n        {\n            case fastCrushAndRaise:\n                ceiling->crush = true;\n                ceiling->topheight = sec->ceilingheight;\n                ceiling->bottomheight = sec->floorheight + (8*FRACUNIT);\n                ceiling->direction = -1;\n                ceiling->speed = CEILSPEED * 2;\n                break;\n\n            case silentCrushAndRaise:\n            case crushAndRaise:\n                ceiling->crush = true;\n                ceiling->topheight = sec->ceilingheight;\n            case lowerAndCrush:\n            case lowerToFloor:\n                ceiling->bottomheight = sec->floorheight;\n                if (type != lowerToFloor)\n                    ceiling->bottomheight += 8*FRACUNIT;\n                ceiling->direction = -1;\n                ceiling->speed = CEILSPEED;\n                break;\n\n            case raiseToHighest:\n                ceiling->topheight = P_FindHighestCeilingSurrounding(sec);\n                ceiling->direction = 1;\n                ceiling->speed = CEILSPEED;\n                break;\n        }\n\n        ceiling->tag = sec->tag;\n        ceiling->type = type;\n        P_AddActiveCeiling(ceiling);\n    }\n    return rtn;\n}", "path": "NyuziProcessor/software/apps/doom/p_ceilng.c", "commit_date": "2016-01-02 00:00:00", "repo_name": "jbush001/NyuziProcessor", "stars": 1881, "license": "apache-2.0", "language": "c", "size": 32907}
{"docstring": "//\n// EV_CeilingCrushStop\n// Stop a ceiling from crushing!\n//\n", "func_signal": "int\t\tEV_CeilingCrushStop(line_t\t\t*line)", "code": "{\n    int\t\t\ti;\n    int\t\t\trtn;\n\n    rtn = 0;\n    for (i = 0; i < MAXCEILINGS; i++)\n    {\n        if (activeceilings[i]\n                && (activeceilings[i]->tag == line->tag)\n                && (activeceilings[i]->direction != 0))\n        {\n            activeceilings[i]->olddirection = activeceilings[i]->direction;\n            activeceilings[i]->thinker.function.acv = (actionf_v)NULL;\n            activeceilings[i]->direction = 0;\t\t\t// in-stasis\n            rtn = 1;\n        }\n    }\n\n\n    return rtn;\n}", "path": "NyuziProcessor/software/apps/doom/p_ceilng.c", "commit_date": "2016-01-02 00:00:00", "repo_name": "jbush001/NyuziProcessor", "stars": 1881, "license": "apache-2.0", "language": "c", "size": 32907}
{"docstring": "//\n// R_SetupFrame\n//\n", "func_signal": "void R_SetupFrame (player_t* player)", "code": "{\n    int\t\t\ti;\n\n    viewplayer = player;\n    viewx = player->mo->x;\n    viewy = player->mo->y;\n    viewangle = player->mo->angle + viewangleoffset;\n    extralight = player->extralight;\n\n    viewz = player->viewz;\n\n    viewsin = finesine[viewangle>>ANGLETOFINESHIFT];\n    viewcos = finecosine[viewangle>>ANGLETOFINESHIFT];\n\n    sscount = 0;\n\n    if (player->fixedcolormap)\n    {\n        fixedcolormap =\n            colormaps\n            + player->fixedcolormap*256*sizeof(lighttable_t);\n\n        walllights = scalelightfixed;\n\n        for (i=0 ; i<MAXLIGHTSCALE ; i++)\n            scalelightfixed[i] = fixedcolormap;\n    }\n    else\n        fixedcolormap = 0;\n\n    framecount++;\n    validcount++;\n}", "path": "NyuziProcessor/software/apps/doom/r_main.c", "commit_date": "2016-01-02 00:00:00", "repo_name": "jbush001/NyuziProcessor", "stars": 1881, "license": "apache-2.0", "language": "c", "size": 32907}
{"docstring": "//\n// R_InitTables\n//\n", "func_signal": "void R_InitTables (void)", "code": "{\n    // UNUSED: now getting from tables.c\n#if 0\n    int\t\t\ti;\n    float\t\ta;\n    float\t\tfv;\n    int\t\t\tt;\n\n    // viewangle tangent table\n    for (i=0 ; i<FINEANGLES/2 ; i++)\n    {\n        a = (i-FINEANGLES/4+0.5)*PI*2/FINEANGLES;\n        fv = FRACUNIT*tan (a);\n        t = fv;\n        finetangent[i] = t;\n    }\n\n    // finesine table\n    for (i=0 ; i<5*FINEANGLES/4 ; i++)\n    {\n        // OPTIMIZE: mirror...\n        a = (i+0.5)*PI*2/FINEANGLES;\n        t = FRACUNIT*sin (a);\n        finesine[i] = t;\n    }\n#endif\n\n}", "path": "NyuziProcessor/software/apps/doom/r_main.c", "commit_date": "2016-01-02 00:00:00", "repo_name": "jbush001/NyuziProcessor", "stars": 1881, "license": "apache-2.0", "language": "c", "size": 32907}
{"docstring": "//\n// T_MoveCeiling\n//\n", "func_signal": "void T_MoveCeiling (ceiling_t* ceiling)", "code": "{\n    result_e\tres;\n\n    switch(ceiling->direction)\n    {\n        case 0:\n            // IN STASIS\n            break;\n        case 1:\n            // UP\n            res = T_MovePlane(ceiling->sector,\n                              ceiling->speed,\n                              ceiling->topheight,\n                              false,1,ceiling->direction);\n\n            if (!(leveltime&7))\n            {\n                switch(ceiling->type)\n                {\n                    case silentCrushAndRaise:\n                        break;\n                    default:\n                        S_StartSound((mobj_t *)&ceiling->sector->soundorg,\n                                     sfx_stnmov);\n                        // ?\n                        break;\n                }\n            }\n\n            if (res == pastdest)\n            {\n                switch(ceiling->type)\n                {\n                    case raiseToHighest:\n                        P_RemoveActiveCeiling(ceiling);\n                        break;\n\n                    case silentCrushAndRaise:\n                        S_StartSound((mobj_t *)&ceiling->sector->soundorg,\n                                     sfx_pstop);\n                    case fastCrushAndRaise:\n                    case crushAndRaise:\n                        ceiling->direction = -1;\n                        break;\n\n                    default:\n                        break;\n                }\n\n            }\n            break;\n\n        case -1:\n            // DOWN\n            res = T_MovePlane(ceiling->sector,\n                              ceiling->speed,\n                              ceiling->bottomheight,\n                              ceiling->crush,1,ceiling->direction);\n\n            if (!(leveltime&7))\n            {\n                switch(ceiling->type)\n                {\n                    case silentCrushAndRaise:\n                        break;\n                    default:\n                        S_StartSound((mobj_t *)&ceiling->sector->soundorg,\n                                     sfx_stnmov);\n                }\n            }\n\n            if (res == pastdest)\n            {\n                switch(ceiling->type)\n                {\n                    case silentCrushAndRaise:\n                        S_StartSound((mobj_t *)&ceiling->sector->soundorg,\n                                     sfx_pstop);\n                    case crushAndRaise:\n                        ceiling->speed = CEILSPEED;\n                    case fastCrushAndRaise:\n                        ceiling->direction = 1;\n                        break;\n\n                    case lowerAndCrush:\n                    case lowerToFloor:\n                        P_RemoveActiveCeiling(ceiling);\n                        break;\n\n                    default:\n                        break;\n                }\n            }\n            else // ( res != pastdest )\n            {\n                if (res == crushed)\n                {\n                    switch(ceiling->type)\n                    {\n                        case silentCrushAndRaise:\n                        case crushAndRaise:\n                        case lowerAndCrush:\n                            ceiling->speed = CEILSPEED / 8;\n                            break;\n\n                        default:\n                            break;\n                    }\n                }\n            }\n            break;\n    }\n}", "path": "NyuziProcessor/software/apps/doom/p_ceilng.c", "commit_date": "2016-01-02 00:00:00", "repo_name": "jbush001/NyuziProcessor", "stars": 1881, "license": "apache-2.0", "language": "c", "size": 32907}
{"docstring": "// Wrappers keep LLVM from creating inline versions of these automatically\n", "func_signal": "int get_sign(int value)", "code": "{\n    if (value < 0)\n        return -1;\n    else if (value > 0)\n        return 1;\n\n    return 0;\n}", "path": "NyuziProcessor/tests/libc/string.c", "commit_date": "2017-04-29 00:00:00", "repo_name": "jbush001/NyuziProcessor", "stars": 1881, "license": "apache-2.0", "language": "c", "size": 32907}
{"docstring": "//\n// This is a not-very-pretty routine which handles\n//\tthe face states and their timing.\n// the precedence of expressions is:\n//\tdead > evil grin > turned head > straight ahead\n//\n", "func_signal": "void ST_updateFaceWidget(void)", "code": "{\n    int\t\t\ti;\n    angle_t\t\tbadguyangle;\n    angle_t\t\tdiffang;\n    static int\tlastattackdown = -1;\n    static int\tpriority = 0;\n    boolean\t\tdoevilgrin;\n\n    if (priority < 10)\n    {\n        // dead\n        if (!plyr->health)\n        {\n            priority = 9;\n            st_faceindex = ST_DEADFACE;\n            st_facecount = 1;\n        }\n    }\n\n    if (priority < 9)\n    {\n        if (plyr->bonuscount)\n        {\n            // picking up bonus\n            doevilgrin = false;\n\n            for (i=0; i<NUMWEAPONS; i++)\n            {\n                if (oldweaponsowned[i] != plyr->weaponowned[i])\n                {\n                    doevilgrin = true;\n                    oldweaponsowned[i] = plyr->weaponowned[i];\n                }\n            }\n            if (doevilgrin)\n            {\n                // evil grin if just picked up weapon\n                priority = 8;\n                st_facecount = ST_EVILGRINCOUNT;\n                st_faceindex = ST_calcPainOffset() + ST_EVILGRINOFFSET;\n            }\n        }\n\n    }\n\n    if (priority < 8)\n    {\n        if (plyr->damagecount\n                && plyr->attacker\n                && plyr->attacker != plyr->mo)\n        {\n            // being attacked\n            priority = 7;\n\n            if (plyr->health - st_oldhealth > ST_MUCHPAIN)\n            {\n                st_facecount = ST_TURNCOUNT;\n                st_faceindex = ST_calcPainOffset() + ST_OUCHOFFSET;\n            }\n            else\n            {\n                badguyangle = R_PointToAngle2(plyr->mo->x,\n                                              plyr->mo->y,\n                                              plyr->attacker->x,\n                                              plyr->attacker->y);\n\n                if (badguyangle > plyr->mo->angle)\n                {\n                    // whether right or left\n                    diffang = badguyangle - plyr->mo->angle;\n                    i = diffang > ANG180;\n                }\n                else\n                {\n                    // whether left or right\n                    diffang = plyr->mo->angle - badguyangle;\n                    i = diffang <= ANG180;\n                } // confusing, aint it?\n\n\n                st_facecount = ST_TURNCOUNT;\n                st_faceindex = ST_calcPainOffset();\n\n                if (diffang < ANG45)\n                {\n                    // head-on\n                    st_faceindex += ST_RAMPAGEOFFSET;\n                }\n                else if (i)\n                {\n                    // turn face right\n                    st_faceindex += ST_TURNOFFSET;\n                }\n                else\n                {\n                    // turn face left\n                    st_faceindex += ST_TURNOFFSET+1;\n                }\n            }\n        }\n    }\n\n    if (priority < 7)\n    {\n        // getting hurt because of your own damn stupidity\n        if (plyr->damagecount)\n        {\n            if (plyr->health - st_oldhealth > ST_MUCHPAIN)\n            {\n                priority = 7;\n                st_facecount = ST_TURNCOUNT;\n                st_faceindex = ST_calcPainOffset() + ST_OUCHOFFSET;\n            }\n            else\n            {\n                priority = 6;\n                st_facecount = ST_TURNCOUNT;\n                st_faceindex = ST_calcPainOffset() + ST_RAMPAGEOFFSET;\n            }\n\n        }\n\n    }\n\n    if (priority < 6)\n    {\n        // rapid firing\n        if (plyr->attackdown)\n        {\n            if (lastattackdown==-1)\n                lastattackdown = ST_RAMPAGEDELAY;\n            else if (!--lastattackdown)\n            {\n                priority = 5;\n                st_faceindex = ST_calcPainOffset() + ST_RAMPAGEOFFSET;\n                st_facecount = 1;\n                lastattackdown = 1;\n            }\n        }\n        else\n            lastattackdown = -1;\n\n    }\n\n    if (priority < 5)\n    {\n        // invulnerability\n        if ((plyr->cheats & CF_GODMODE)\n                || plyr->powers[pw_invulnerability])\n        {\n            priority = 4;\n\n            st_faceindex = ST_GODFACE;\n            st_facecount = 1;\n\n        }\n\n    }\n\n    // look left or look right if the facecount has timed out\n    if (!st_facecount)\n    {\n        st_faceindex = ST_calcPainOffset() + (st_randomnumber % 3);\n        st_facecount = ST_STRAIGHTFACECOUNT;\n        priority = 0;\n    }\n\n    st_facecount--;\n\n}", "path": "NyuziProcessor/software/apps/doom/st_stuff.c", "commit_date": "2016-01-02 00:00:00", "repo_name": "jbush001/NyuziProcessor", "stars": 1881, "license": "apache-2.0", "language": "c", "size": 32907}
{"docstring": "/**\n * Parses commandline options\n * @param argc The arguments count\n * @param argv The arguments values\n * @param config_only 1 if the config file is the only option to be parsed\n */\n", "func_signal": "void bbconfig_parse_opts(int argc, char *argv[], int conf_round)", "code": "{\n  /* Parse the options, set flags as necessary */\n  int opt;\n  optind = 0;\n  const char *optString = bbconfig_get_optstr();\n  const struct option *longOpts = bbconfig_get_lopts();\n  while ((opt = getopt_long(argc, argv, optString, longOpts, 0)) != -1) {\n    if (opt == '?') {\n      /* if an option was not recognized */\n      print_usage(EXIT_FAILURE);\n    }\n    if (conf_round == PARSE_STAGE_LOG && bb_status.runmode == BB_RUN_SERVER) {\n      /* hack to get logging ready before parsing other options */\n      switch (opt) {\n        case 'D':\n        case OPT_USE_SYSLOG:\n          bb_status.use_syslog = TRUE;\n          break;\n      }\n    } else if (conf_round == PARSE_STAGE_PRECONF) {\n      int is_optirun = bb_status.runmode == BB_RUN_APP ||\n              bb_status.runmode == BB_RUN_STATUS;\n      switch (opt) {\n        case 'C':\n          set_string_value(&bb_config.bb_conf_file, optarg);\n          break;\n        case 'v':\n          if (bb_status.verbosity < VERB_ALL) {\n            bb_status.verbosity++;\n          }\n          break;\n        case 's': /* Unix socket to use for communication */\n          set_string_value(&bb_config.socket_path, optarg);\n          break;\n        case 'V'://print version\n          printf(\"%s (Bumblebee) %s\\n\",\n                  is_optirun ? \"optirun\" : \"bumblebeed\", GITVERSION);\n          printf(\"Copyright (C) 2011 The Bumblebee Project\\n\");\n          printf(\"License GPLv3+: GNU GPL version 3 or later\"\n                  \" <http://gnu.org/licenses/gpl.html>.\\n\");\n          printf(\"This is free software: you are free to change and redistribute\"\n                  \" it.\\n\");\n          printf(\"There is NO WARRANTY, to the extent permitted by law.\\n\");\n          exit(EXIT_SUCCESS);\n          break;\n        case 'h':\n          print_usage(EXIT_SUCCESS);\n          break;\n      }\n    } else if (conf_round == PARSE_STAGE_DRIVER) {\n      switch (opt) {\n        case OPT_DRIVER:\n          set_string_value(&bb_config.driver, optarg);\n          break;\n      }\n    } else if (conf_round == PARSE_STAGE_OTHER) {\n      /* try to find local options first, then try common options */\n      if (bbconfig_parse_options(opt, optarg) ||\n              bbconfig_parse_common(opt, optarg)) {\n        /* option has been parsed, continue with the next options */\n        continue;\n      }\n    }\n  }\n}", "path": "Bumblebee/src/bbconfig.c", "commit_date": "2013-04-22 00:00:00", "repo_name": "Bumblebee-Project/Bumblebee", "stars": 1286, "license": "gpl-3.0", "language": "c", "size": 800}
{"docstring": "/**\n * Whether vga_switcheroo is available for use\n *\n * @param info A struct containing information which would help with the\n * decision whether vga_switcheroo is usable or not\n * @return 1 if available for use for PM, 0 otherwise\n */\n", "func_signal": "int switcheroo_is_available(struct switch_info info)", "code": "{\n  if (strcmp(info.configured_pm, \"switcheroo\") != 0) {\n    bb_log(LOG_INFO, \"Skipping switcheroo PM method because it is not\"\n            \" explicitly selected in the configuration.\\n\");\n    return 0;\n  }\n  return 1;\n}", "path": "Bumblebee/src/switch/sw_switcheroo.c", "commit_date": "2013-04-22 00:00:00", "repo_name": "Bumblebee-Project/Bumblebee", "stars": 1286, "license": "gpl-3.0", "language": "c", "size": 800}
{"docstring": "/**\n * Substitutes DRIVER in the passed path\n * @param x_conf_file A path to be processed\n * @param driver The replacement for each occurence of DRIVER\n * @return A path to xorg.conf with DRIVER substituted for the driver\n */\n", "func_signal": "static char *xorg_path_w_driver(char *x_conf_file, char *driver)", "code": "{\n  static char *path;\n  const char *driver_keyword = \"DRIVER\";\n  unsigned int driver_occurences = 0;\n  int path_length;\n  char *pos, *next;\n\n  /* calculate the path buffer size */\n  pos = x_conf_file;\n  while ((next = strstr(pos, driver_keyword)) != 0) {\n    driver_occurences++;\n    pos = next + strlen(driver_keyword);\n  }\n  path_length = strlen(x_conf_file) +\n          driver_occurences * (strlen(driver_keyword) - 1);\n\n  /* allocate some memory including null byte and make it an empty string */\n  path = malloc(path_length + 1);\n  if (!path) {\n    bb_log(LOG_WARNING, \"Could not allocate memory for xorg conf path\\n\");\n    return NULL;\n  }\n  path[0] = 0;\n\n  /* now replace for real */\n  pos = x_conf_file;\n  while ((next = strstr(pos, driver_keyword)) != 0) {\n    int len = next - pos;\n    strncat(path, pos, len);\n    strncat(path, driver, path_length);\n\n    /* the next search starts at the position after %s */\n    pos = next + strlen(driver_keyword);\n  }\n  /* append the remainder after the last %s if any and overwrite the setting */\n  strncat(path, pos, path_length);\n  return path;\n}", "path": "Bumblebee/src/bbsecondary.c", "commit_date": "2013-04-26 00:00:00", "repo_name": "Bumblebee-Project/Bumblebee", "stars": 1286, "license": "gpl-3.0", "language": "c", "size": 800}
{"docstring": "/**\n * Parse configuration file given by bb_config.bb_conf_file\n *\n * @return A pointer to an GKeyFile object or NULL on failure\n */\n", "func_signal": "GKeyFile *bbconfig_parse_conf(void)", "code": "{\n  //Old behavior\n  //return read_configuration();\n\n  bb_log(LOG_DEBUG, \"Reading file: %s\\n\", bb_config.bb_conf_file);\n  GKeyFile *bbcfg;\n  GKeyFileFlags flags = G_KEY_FILE_NONE;\n  GError *err = NULL;\n\n  bbcfg = g_key_file_new();\n  if (!g_key_file_load_from_file(bbcfg, bb_config.bb_conf_file, flags, &err)) {\n    bb_log(LOG_WARNING, \"Could not open configuration file: %s\\n\", bb_config.bb_conf_file);\n    bb_log(LOG_WARNING, \"Using default configuration\\n\");\n    g_error_free(err);\n    g_key_file_free(bbcfg);\n    return NULL;\n  }\n\n  // First check for a key existence then parse it with appropriate format\n  // Use false as default for boolean arguments.\n  // TODO:optirun/bumblebeed must be parsed according to RUN_MODE\n\n  char* section;\n  char* key;\n  // Client settings\n  // [optirun]\n  section = \"optirun\";\n  key = \"Bridge\";\n  if (g_key_file_has_key(bbcfg, section, key, NULL)) {\n    free_and_set_value(&bb_config.optirun_bridge, g_key_file_get_string(bbcfg, section, key, NULL));\n  }\n  key = \"PrimusLibraryPath\";\n  if (g_key_file_has_key(bbcfg, section, key, NULL)) {\n    free_and_set_value(&bb_config.primus_ld_path, g_key_file_get_string(bbcfg, section, key, NULL));\n  }\n  key = \"VGLTransport\";\n  if (g_key_file_has_key(bbcfg, section, key, NULL)) {\n    free_and_set_value(&bb_config.vgl_compress, g_key_file_get_string(bbcfg, section, key, NULL));\n  }\n  key = \"AllowFallbackToIGC\";\n  if (g_key_file_has_key(bbcfg, section, key, NULL)) {\n    bb_config.fallback_start = g_key_file_get_boolean(bbcfg, section, key, NULL);\n  }\n\n  // Server settings\n  // [bumblebeed]\n  section = \"bumblebeed\";\n  key = \"VirtualDisplay\";\n  if (g_key_file_has_key(bbcfg, section, key, NULL)) {\n    free_and_set_value(&bb_config.x_display, g_key_file_get_string(bbcfg, section, key, NULL));\n  }\n  key = \"KeepUnusedXServer\";\n  if (g_key_file_has_key(bbcfg, section, key, NULL)) {\n    bb_config.stop_on_exit = !g_key_file_get_boolean(bbcfg, section, key, NULL);\n  }\n  key = \"Driver\";\n  if (g_key_file_has_key(bbcfg, section, key, NULL)) {\n    char *driver = g_key_file_get_string(bbcfg, section, key, NULL);\n    /* empty driv */\n    if (*driver != 0) {\n      free_and_set_value(&bb_config.driver, driver);\n      bb_log(LOG_INFO, \"Configured driver: %s\\n\", bb_config.driver);\n    } else {\n      g_free(driver);\n    }\n  }\n  key = \"ServerGroup\";\n  if (g_key_file_has_key(bbcfg, section, key, NULL)) {\n    free_and_set_value(&bb_config.gid_name, g_key_file_get_string(bbcfg, section, key, NULL));\n  }\n  key = \"TurnCardOffAtExit\";\n  if (g_key_file_has_key(bbcfg, section, key, NULL)) {\n    bb_config.card_shutdown_state = !g_key_file_get_boolean(bbcfg, section, key, NULL);\n  }\n  key = \"XorgConfDir\";\n  if (g_key_file_has_key(bbcfg, section, key, NULL)) {\n    free_and_set_value(&bb_config.x_conf_dir, g_key_file_get_string(bbcfg, section, key, NULL));\n  }\n  return bbcfg;\n}", "path": "Bumblebee/src/bbconfig.c", "commit_date": "2013-04-22 00:00:00", "repo_name": "Bumblebee-Project/Bumblebee", "stars": 1286, "license": "gpl-3.0", "language": "c", "size": 800}
{"docstring": "/**\n * Prints the current configuration with verbosity level LOG_DEBUG\n */\n", "func_signal": "void config_dump(void)", "code": "{\n  //print configuration as debug messages\n  bb_log(LOG_DEBUG, \"Active configuration:\\n\");\n  /* common options */\n  bb_log(LOG_DEBUG, \" bumblebeed config file: %s\\n\", bb_config.bb_conf_file);\n  bb_log(LOG_DEBUG, \" X display: %s\\n\", bb_config.x_display);\n  bb_log(LOG_DEBUG, \" LD_LIBRARY_PATH: %s\\n\", bb_config.ld_path);\n  bb_log(LOG_DEBUG, \" Socket path: %s\\n\", bb_config.socket_path);\n  if (bb_status.runmode == BB_RUN_SERVER || bb_status.runmode == BB_RUN_DAEMON) {\n    /* daemon options */\n#ifdef WITH_PIDFILE\n    bb_log(LOG_DEBUG, \" pidfile: %s\\n\", bb_config.pid_file);\n#endif\n    bb_log(LOG_DEBUG, \" xorg.conf file: %s\\n\", bb_config.x_conf_file);\n    bb_log(LOG_DEBUG, \" xorg.conf.d dir: %s\\n\", bb_config.x_conf_dir);\n    bb_log(LOG_DEBUG, \" ModulePath: %s\\n\", bb_config.mod_path);\n    bb_log(LOG_DEBUG, \" GID name: %s\\n\", bb_config.gid_name);\n    bb_log(LOG_DEBUG, \" Power method: %s\\n\",\n            bb_pm_method_string[bb_config.pm_method]);\n    bb_log(LOG_DEBUG, \" Stop X on exit: %i\\n\", bb_config.stop_on_exit);\n    bb_log(LOG_DEBUG, \" Driver: %s\\n\", bb_config.driver);\n    bb_log(LOG_DEBUG, \" Driver module: %s\\n\", bb_config.module_name);\n    bb_log(LOG_DEBUG, \" Card shutdown state: %i\\n\",\n            bb_config.card_shutdown_state);\n  } else {\n    /* client options */\n    bb_log(LOG_DEBUG, \" Accel/display bridge: %s\\n\", bb_config.optirun_bridge);\n    bb_log(LOG_DEBUG, \" VGL Compression: %s\\n\", bb_config.vgl_compress);\n    bb_log(LOG_DEBUG, \" VGLrun extra options: %s\\n\", bb_config.vglrun_options ? bb_config.vglrun_options : \"\");\n    bb_log(LOG_DEBUG, \" Primus LD Path: %s\\n\", bb_config.primus_ld_path);\n  }\n}", "path": "Bumblebee/src/bbconfig.c", "commit_date": "2013-04-22 00:00:00", "repo_name": "Bumblebee-Project/Bumblebee", "stars": 1286, "license": "gpl-3.0", "language": "c", "size": 800}
{"docstring": "/**\n * Takes a pointer to a char pointer, resizing and copying the string value to it.\n */\n", "func_signal": "void set_string_value(char ** configstring, char * newvalue)", "code": "{\n  //free the string if it already existed.\n  if (*configstring != 0) {\n    free(*configstring);\n    *configstring = 0;\n  }\n  //malloc a new buffer of strlen, plus one for the terminating null byte\n  *configstring = malloc(strlen(newvalue) + 1);\n  if (*configstring != 0) {\n    //copy the string if successful\n    strcpy(*configstring, newvalue);\n  } else {\n    //something, somewhere, went terribly wrong\n    bb_log(LOG_ERR, \"Could not allocate %i bytes for new config value, setting to empty string!\\n\", strlen(newvalue) + 1);\n    *configstring = malloc(1);\n    if (*configstring == 0) {\n      bb_log(LOG_ERR, \"FATAL: Could not allocate even 1 byte for config value!\\n\");\n      bb_log(LOG_ERR, \"Aborting - cannot continue without stable config!\\n\");\n      exit(1);\n    }\n    (*configstring)[0] = 0;\n  }\n}", "path": "Bumblebee/src/bbconfig.c", "commit_date": "2013-04-22 00:00:00", "repo_name": "Bumblebee-Project/Bumblebee", "stars": 1286, "license": "gpl-3.0", "language": "c", "size": 800}
{"docstring": "/**\n * Check for the availability of a PM method, warn if no method is available\n */\n", "func_signal": "void check_pm_method(void)", "code": "{\n  if (bb_config.pm_method == PM_DISABLED) {\n    bb_log(LOG_INFO, \"PM is disabled, not performing detection.\\n\");\n  } else {\n    struct switch_info info;\n    memset(&info, 0, sizeof info);\n    info.driver = bb_config.driver;\n    info.configured_pm = bb_pm_method_string[bb_config.pm_method];\n\n    const char *pm_method = NULL;\n    if (bb_config.pm_method != PM_AUTO) {\n      /* auto-detection override */\n      pm_method = bb_pm_method_string[bb_config.pm_method];\n    }\n\n    switcher = switcher_detect(pm_method, info);\n    if (switcher) {\n      bb_log(LOG_INFO, \"Switching method '%s' is available and will be used.\\n\",\n              switcher->name);\n    } else {\n      bb_log(LOG_WARNING, \"No switching method available. The dedicated card\"\n              \" will always be on.\\n\");\n    }\n  }\n}", "path": "Bumblebee/src/bbsecondary.c", "commit_date": "2013-04-26 00:00:00", "repo_name": "Bumblebee-Project/Bumblebee", "stars": 1286, "license": "gpl-3.0", "language": "c", "size": 800}
{"docstring": "/**\n * Check what drivers are available and autodetect if possible. Driver, module\n * library path and module path are set\n */\n", "func_signal": "void driver_detect(void)", "code": "{\n  /* determine driver to be used */\n  if (*bb_config.driver) {\n    bb_log(LOG_DEBUG, \"Skipping auto-detection, using configured driver\"\n            \" '%s'\\n\", bb_config.driver);\n  } else if (strlen(CONF_DRIVER)) {\n    /* if the default driver is set, use that */\n    set_string_value(&bb_config.driver, CONF_DRIVER);\n    bb_log(LOG_DEBUG, \"Using compile default driver '%s'\", CONF_DRIVER);\n  } else if (module_is_loaded(\"nouveau\")) {\n    /* loaded drivers take precedence over ones available for modprobing */\n    set_string_value(&bb_config.driver, \"nouveau\");\n    set_string_value(&bb_config.module_name, \"nouveau\");\n    bb_log(LOG_DEBUG, \"Detected nouveau driver\\n\");\n  } else if (module_is_available(CONF_DRIVER_MODULE_NVIDIA)) {\n    /* Ubuntu and Mandriva use nvidia-current.ko. nvidia cannot be compiled into\n     * the kernel, so module_is_available makes module_is_loaded redundant */\n    set_string_value(&bb_config.driver, \"nvidia\");\n    set_string_value(&bb_config.module_name, CONF_DRIVER_MODULE_NVIDIA);\n    bb_log(LOG_DEBUG, \"Detected nvidia driver (module %s)\\n\",\n            CONF_DRIVER_MODULE_NVIDIA);\n  } else if (module_is_available(\"nouveau\")) {\n    set_string_value(&bb_config.driver, \"nouveau\");\n    set_string_value(&bb_config.module_name, \"nouveau\");\n    bb_log(LOG_DEBUG, \"Detected nouveau driver\\n\");\n  }\n\n  if (!*bb_config.module_name) {\n    /* no module has been configured, set a sensible one based on driver */\n    if (strcmp(bb_config.driver, \"nvidia\") == 0 &&\n            module_is_available(CONF_DRIVER_MODULE_NVIDIA)) {\n      set_string_value(&bb_config.module_name, CONF_DRIVER_MODULE_NVIDIA);\n    } else {\n      set_string_value(&bb_config.module_name, bb_config.driver);\n    }\n  }\n\n  if (strcmp(bb_config.driver, \"nvidia\") == 0) {\n    set_string_value(&bb_config.ld_path, CONF_LDPATH_NVIDIA);\n    set_string_value(&bb_config.mod_path, CONF_MODPATH_NVIDIA);\n  }\n}", "path": "Bumblebee/src/driver.c", "commit_date": "2013-04-22 00:00:00", "repo_name": "Bumblebee-Project/Bumblebee", "stars": 1286, "license": "gpl-3.0", "language": "c", "size": 800}
{"docstring": "/**\n * Loads driver settings from an open GKeyFile\n * @param bbcfg A pointer to a GKeyFile\n * @param driver The string containing the driver to be loaded\n */\n", "func_signal": "void bbconfig_parse_conf_driver(GKeyFile *bbcfg, char *driver)", "code": "{\n  GError *err = NULL;\n  char *key, *section;\n\n  section = malloc(strlen(\"driver-\") + strlen(driver) + 1);\n  if (section == NULL) {\n    /* why can't we just assume that there is always enough memory available?\n     * If there is no memory, the program cannot do anything useful anyway. */\n    bb_log(LOG_WARNING, \"Driver settings could not be loaded: out of memory\\n\");\n    return;\n  }\n  strcpy(section, \"driver-\");\n  strcat(section, driver);\n\n  key = \"KernelDriver\";\n  if (g_key_file_has_key(bbcfg, section, key, NULL)) {\n    char *module_name = g_key_file_get_string(bbcfg, section, key, NULL);\n    /* if KernelDriver is empty, the default behavior is to copy Driver which\n     * is done in driver_detect() */\n    if (*module_name) {\n      free_and_set_value(&bb_config.module_name, module_name);\n    } else {\n      g_free(module_name);\n    }\n  }\n  key = \"LibraryPath\";\n  if (g_key_file_has_key(bbcfg, section, key, NULL)) {\n    free_and_set_value(&bb_config.ld_path, g_key_file_get_string(bbcfg, section, key, NULL));\n  }\n  key = \"XorgModulePath\";\n  if (g_key_file_has_key(bbcfg, section, key, NULL)) {\n    free_and_set_value(&bb_config.mod_path, g_key_file_get_string(bbcfg, section, key, NULL));\n  }\n  key = \"PMMethod\";\n  if (g_key_file_has_key(bbcfg, section, key, NULL)) {\n    char *val = g_key_file_get_string(bbcfg, section, key, NULL);\n    enum bb_pm_method pm_method_index = bb_pm_method_from_string(val);\n    bb_config.pm_method = pm_method_index;\n    g_free(val);\n  }\n  key = \"XorgConfFile\";\n  if (g_key_file_has_key(bbcfg, section, key, NULL)) {\n    free_and_set_value(&bb_config.x_conf_file, g_key_file_get_string(bbcfg, section, key, NULL));\n  }\n  if (err != NULL) {\n    g_error_free(err);\n  }\n  free(section);\n}", "path": "Bumblebee/src/bbconfig.c", "commit_date": "2013-04-22 00:00:00", "repo_name": "Bumblebee-Project/Bumblebee", "stars": 1286, "license": "gpl-3.0", "language": "c", "size": 800}
{"docstring": "/**\n * Returns the long options for this program\n * @return A option struct which can be used for getopt_long\n */\n", "func_signal": "const struct option *bbconfig_get_lopts(void)", "code": "{\n  static struct option longOpts[] = {\n    {\"failsafe\", 0, 0, OPT_FAILSAFE},\n    {\"no-failsafe\", 0, 0, OPT_NO_FAILSAFE},\n    {\"no-xorg\", 0, 0, OPT_NO_XORG},\n    {\"bridge\", 1, 0, 'b'},\n    {\"vgl-compress\", 1, 0, 'c'},\n    {\"vgl-options\", 1, 0, OPT_VGL_OPTIONS},\n    {\"primus-ldpath\", 1, 0, OPT_PRIMUS_LD_PATH},\n    {\"status\", 0, 0, OPT_STATUS},\n    BBCONFIG_COMMON_LOPTS\n  };\n  return longOpts;\n}", "path": "Bumblebee/src/optirun.c", "commit_date": "2020-11-29 00:00:00", "repo_name": "Bumblebee-Project/Bumblebee", "stars": 1286, "license": "gpl-3.0", "language": "c", "size": 800}
{"docstring": "/**\n * Reports the status of vga switcheroo\n *\n * @return SWITCH_OFF if card is off, SWITCH_ON if card is on and SWITCH_UNAVAIL\n * if switcheroo not available\n */\n", "func_signal": "int switcheroo_status(void)", "code": "{\n  char buffer[BBS_BUFFER];\n  int ret = SWITCH_UNAVAIL;\n  FILE * bbs = fopen(SWITCHEROO_PATH, \"r\");\n  if (bbs == 0) {\n    return SWITCH_UNAVAIL;\n  }\n  while (fgets(buffer, BBS_BUFFER, bbs)) {\n    if (strlen(buffer) > strlen(\"0:DIS: :Pwr\") &&\n            !strncmp(buffer + 2, \"DIS\", 3)) {//found the DIS line\n      // compare the first char after \"0:DIS: :\"\n      switch (buffer[strlen(\"0:DIS: :\")]) {\n        case 'P': // Pwr\n          ret = SWITCH_ON;\n          break;\n        case 'O':\n          ret = SWITCH_OFF;\n          break;\n      }\n    }\n  }\n  fclose(bbs);\n  return ret;\n}", "path": "Bumblebee/src/switch/sw_switcheroo.c", "commit_date": "2013-04-22 00:00:00", "repo_name": "Bumblebee-Project/Bumblebee", "stars": 1286, "license": "gpl-3.0", "language": "c", "size": 800}
{"docstring": "/**\n * Start the X server by fork-exec, turn card on and load driver if needed.\n * If after this method finishes X is running, it was successfull.\n * If it somehow fails, X should not be running after this method finishes.\n */\n", "func_signal": "bool start_secondary(bool need_secondary)", "code": "{\n  if (!switch_and_load())\n    return false;\n  if (!need_secondary)\n    return true;\n  //no problems, start X if not started yet\n  if (!bb_is_running(bb_status.x_pid)) {\n    char pci_id[12];\n    static char *x_conf_file;\n    snprintf(pci_id, 12, \"PCI:%02x:%02x:%o\", pci_bus_id_discrete->bus,\n            pci_bus_id_discrete->slot, pci_bus_id_discrete->func);\n    if (!x_conf_file) {\n      x_conf_file = xorg_path_w_driver(bb_config.x_conf_file, bb_config.driver);\n    }\n\n    bb_log(LOG_INFO, \"Starting X server on display %s.\\n\", bb_config.x_display);\n    char *x_argv[] = {\n      XORG_BINARY,\n      bb_config.x_display,\n      \"-config\", x_conf_file,\n      \"-configdir\", bb_config.x_conf_dir,\n      \"-sharevts\",\n      \"-nolisten\", \"tcp\",\n      \"-noreset\",\n      \"-verbose\", \"3\",\n      \"-isolateDevice\", pci_id,\n      \"-modulepath\", bb_config.mod_path, // keep last\n      NULL\n    };\n    enum {n_x_args = sizeof(x_argv) / sizeof(x_argv[0])};\n    if (!*bb_config.mod_path) {\n      x_argv[n_x_args - 3] = 0; //remove -modulepath if not set\n    }\n    //close any previous pipe, if it (still) exists\n    if (bb_status.x_pipe[0] != -1){close(bb_status.x_pipe[0]); bb_status.x_pipe[0] = -1;}\n    if (bb_status.x_pipe[1] != -1){close(bb_status.x_pipe[1]); bb_status.x_pipe[1] = -1;}\n    //create a new pipe\n    if (pipe2(bb_status.x_pipe, O_NONBLOCK | O_CLOEXEC)){\n      set_bb_error(\"Could not create output pipe for X\");\n      return false;\n    }\n    bb_status.x_pid = bb_run_fork_ld_redirect(x_argv, bb_config.ld_path, bb_status.x_pipe[1]);\n    //close the end of the pipe that is not ours\n    if (bb_status.x_pipe[1] != -1){close(bb_status.x_pipe[1]); bb_status.x_pipe[1] = -1;}\n  }\n\n  //check if X is available, for maximum 10 seconds.\n  time_t xtimer = time(0);\n  Display * xdisp = 0;\n  while ((time(0) - xtimer <= 10) && bb_is_running(bb_status.x_pid)) {\n    xdisp = XOpenDisplay(bb_config.x_display);\n    if (xdisp != 0) {\n      break;\n    }\n    check_xorg_pipe();//make sure Xorg errors come in smoothly\n    usleep(100000); //don't retry too fast\n  }\n  check_xorg_pipe();//make sure Xorg errors come in smoothly\n\n  //check if X is available\n  if (xdisp == 0) {\n    //X not available\n    /// \\todo Maybe check X exit status and/or messages?\n    if (bb_is_running(bb_status.x_pid)) {\n      //X active, but not accepting connections\n      set_bb_error(\"X unresponsive after 10 seconds - aborting\");\n      bb_stop(bb_status.x_pid);\n    } else {\n      //X terminated itself\n      set_bb_error(\"X did not start properly\");\n    }\n  } else {\n    //X accepted the connetion - we assume it works\n    XCloseDisplay(xdisp); //close connection to X again\n    bb_log(LOG_INFO, \"X successfully started in %i seconds\\n\", time(0) - xtimer);\n    //reset errors, if any\n    set_bb_error(0);\n    return true;\n  }\n  return false;\n}", "path": "Bumblebee/src/bbsecondary.c", "commit_date": "2013-04-26 00:00:00", "repo_name": "Bumblebee-Project/Bumblebee", "stars": 1286, "license": "gpl-3.0", "language": "c", "size": 800}
{"docstring": "/**\n * Parses common (shared) command line options\n * @param opt The short option\n * @param value Value for the option if any\n * @return 1 if the option has been processed, 0 otherwise\n */\n", "func_signal": "static int bbconfig_parse_common(int opt, char *value)", "code": "{\n  switch (opt) {\n    case 'q'://quiet mode\n      bb_status.verbosity = VERB_NONE;\n      break;\n    case OPT_DEBUG://debug mode\n      bb_status.verbosity = VERB_ALL;\n      break;\n    case 'd'://X display number\n      set_string_value(&bb_config.x_display, value);\n      break;\n    case 'l'://LD driver path\n      set_string_value(&bb_config.ld_path, value);\n      break;\n    default:\n      /* no options parsed */\n      return 0;\n  }\n  return 1;\n}", "path": "Bumblebee/src/bbconfig.c", "commit_date": "2013-04-22 00:00:00", "repo_name": "Bumblebee-Project/Bumblebee", "stars": 1286, "license": "gpl-3.0", "language": "c", "size": 800}
{"docstring": "/**\n * Returns a gboolean from true/false strings\n * @return TRUE if str=\"true\", FALSE otherwise\n */\n", "func_signal": "gboolean bb_bool_from_string(char* str)", "code": "{\n  if (strcmp(str, \"true\") == 0) {\n    return TRUE;\n  } else {\n    return FALSE;\n  }\n}", "path": "Bumblebee/src/bbconfig.c", "commit_date": "2013-04-22 00:00:00", "repo_name": "Bumblebee-Project/Bumblebee", "stars": 1286, "license": "gpl-3.0", "language": "c", "size": 800}
{"docstring": "/**\n *  Handle recieved signals - except SIGCHLD, which is handled in bbrun.c\n */\n", "func_signal": "static void handle_signal(int sig)", "code": "{\n  switch (sig) {\n    case SIGHUP:\n      bb_log(LOG_WARNING, \"Received %s signal (ignoring...)\\n\", strsignal(sig));\n      break;\n    case SIGINT:\n    case SIGQUIT:\n    case SIGTERM:\n      bb_log(LOG_WARNING, \"Received %s signal.\\n\", strsignal(sig));\n      socketClose(&bb_status.bb_socket); //closing the socket terminates the server\n      break;\n    default:\n      bb_log(LOG_WARNING, \"Unhandled signal %s\\n\", strsignal(sig));\n      break;\n  }\n}", "path": "Bumblebee/src/optirun.c", "commit_date": "2020-11-29 00:00:00", "repo_name": "Bumblebee-Project/Bumblebee", "stars": 1286, "license": "gpl-3.0", "language": "c", "size": 800}
{"docstring": "/**\n * Parse configuration file and command line arguments\n */\n", "func_signal": "void init_config(void)", "code": "{\n  /* clear pointers and settings */\n  memset(&bb_config, 0, sizeof bb_config);\n  /* set defaults if not set already */\n  set_string_value(&bb_config.x_display, CONF_XDISP);\n  set_string_value(&bb_config.bb_conf_file, CONFIG_FILE);\n  set_string_value(&bb_config.ld_path, \"\");\n  set_string_value(&bb_config.mod_path, \"\");\n  set_string_value(&bb_config.socket_path, CONF_SOCKPATH);\n  set_string_value(&bb_config.gid_name, CONF_GID);\n  set_string_value(&bb_config.x_conf_file, CONF_XORG);\n  set_string_value(&bb_config.x_conf_dir, CONF_XORG_DIR);\n  set_string_value(&bb_config.optirun_bridge, CONF_BRIDGE);\n  set_string_value(&bb_config.primus_ld_path, CONF_PRIMUS_LD_PATH);\n  set_string_value(&bb_config.vgl_compress, CONF_VGLCOMPRESS);\n  // default to auto-detect\n  set_string_value(&bb_config.driver, \"\");\n  set_string_value(&bb_config.module_name, \"\");\n  bb_config.pm_method = bb_pm_method_from_string(CONF_PM_METHOD);\n  bb_config.stop_on_exit = bb_bool_from_string(CONF_KEEPONEXIT);\n  bb_config.fallback_start = bb_bool_from_string(CONF_FALLBACKSTART);\n  bb_config.card_shutdown_state = bb_bool_from_string(CONF_TURNOFFATEXIT);\n#ifdef WITH_PIDFILE\n  set_string_value(&bb_config.pid_file, CONF_PIDFILE);\n#endif\n}", "path": "Bumblebee/src/bbconfig.c", "commit_date": "2013-04-22 00:00:00", "repo_name": "Bumblebee-Project/Bumblebee", "stars": 1286, "license": "gpl-3.0", "language": "c", "size": 800}
{"docstring": "/**\n * Parses local command line options\n * @param opt The short option\n * @param value Value for the option if any\n * @return 1 if the option has been processed, 0 otherwise\n */\n", "func_signal": "int bbconfig_parse_options(int opt, char *value)", "code": "{\n  switch (opt) {\n    case 'b':/* accel/display bridge, e.g. virtualgl or primus */\n      set_string_value(&bb_config.optirun_bridge, value);\n      break;\n    case 'c'://vglclient method\n      set_string_value(&bb_config.vgl_compress, value);\n      break;\n    case OPT_FAILSAFE:\n      bb_config.fallback_start = 1;\n      break;\n    case OPT_NO_FAILSAFE:\n      bb_config.fallback_start = 0;\n      break;\n    case OPT_NO_XORG:\n      bb_config.no_xorg = 1;\n      set_string_value(&bb_config.optirun_bridge, \"none\");\n      break;\n    case OPT_VGL_OPTIONS:\n      set_string_value(&bb_config.vglrun_options, value);\n      break;\n    case OPT_PRIMUS_LD_PATH:\n      set_string_value(&bb_config.primus_ld_path, value);\n      break;\n    case OPT_STATUS:\n      bb_status.runmode = BB_RUN_STATUS;\n      break;\n    default:\n      /* no options parsed */\n      return 0;\n  }\n  return 1;\n}", "path": "Bumblebee/src/optirun.c", "commit_date": "2020-11-29 00:00:00", "repo_name": "Bumblebee-Project/Bumblebee", "stars": 1286, "license": "gpl-3.0", "language": "c", "size": 800}
{"docstring": "/**\n * Unload the kernel module and power down the card\n */\n", "func_signal": "static void switch_and_unload(void)", "code": "{\n  char driver[BUFFER_SIZE];\n\n  if (bb_config.pm_method == PM_DISABLED && bb_status.runmode != BB_RUN_EXIT) {\n    /* do not disable the card if PM is disabled unless exiting */\n    return;\n  }\n\n  //if card is on and can be switched, switch it off\n  if (switcher) {\n    if (switcher->need_driver_unloaded) {\n      /* do not unload the drivers nor disable the card if the card is not on */\n      if (switcher->status() != SWITCH_ON) {\n        return;\n      }\n      /* unload the driver loaded by the graphica card */\n      if (pci_get_driver(driver, pci_bus_id_discrete, sizeof driver)) {\n        module_unload(driver);\n      }\n\n      //only turn card off if no drivers are loaded\n      if (pci_get_driver(NULL, pci_bus_id_discrete, 0)) {\n        bb_log(LOG_DEBUG, \"Drivers are still loaded, unable to disable card\\n\");\n        return;\n      }\n    }\n    if (switch_off() != SWITCH_OFF) {\n      bb_log(LOG_WARNING, \"Unable to disable discrete card.\");\n    }\n  }\n}", "path": "Bumblebee/src/bbsecondary.c", "commit_date": "2013-04-26 00:00:00", "repo_name": "Bumblebee-Project/Bumblebee", "stars": 1286, "license": "gpl-3.0", "language": "c", "size": 800}
{"docstring": "/**\n * Kill the second X server if any, turn card off if requested.\n */\n", "func_signal": "void stop_secondary()", "code": "{\n  // kill X if it is running\n  if (bb_is_running(bb_status.x_pid)) {\n    bb_log(LOG_INFO, \"Stopping X server\\n\");\n    bb_stop_wait(bb_status.x_pid);\n  }\n  switch_and_unload();\n}", "path": "Bumblebee/src/bbsecondary.c", "commit_date": "2013-04-26 00:00:00", "repo_name": "Bumblebee-Project/Bumblebee", "stars": 1286, "license": "gpl-3.0", "language": "c", "size": 800}
{"docstring": "/**\n * Prints the status of the Bumblebee server if available\n * @return EXIT_SUCCESS if the status is successfully retrieved,\n * EXIT_FAILURE otherwise\n */\n", "func_signal": "static int report_daemon_status(void)", "code": "{\n  char buffer[BUFFER_SIZE];\n  int r = snprintf(buffer, BUFFER_SIZE, \"Status?\");\n  socketWrite(&bb_status.bb_socket, buffer, r + 1);\n  while (bb_status.bb_socket != -1) {\n    r = socketRead(&bb_status.bb_socket, buffer, BUFFER_SIZE);\n    if (r > 0) {\n      ensureZeroTerminated(buffer, r, BUFFER_SIZE);\n      printf(\"Bumblebee status: %s\\n\", buffer);\n      socketClose(&bb_status.bb_socket);\n      return EXIT_SUCCESS;\n    }\n  }\n  return EXIT_FAILURE;\n}", "path": "Bumblebee/src/optirun.c", "commit_date": "2020-11-29 00:00:00", "repo_name": "Bumblebee-Project/Bumblebee", "stars": 1286, "license": "gpl-3.0", "language": "c", "size": 800}
{"docstring": "/* SOD_GPU */\n", "func_signal": "static void pull_batchnorm_layer(layer l)", "code": "{\n\tcuda_pull_array(l.scales_gpu, l.scales, l.c);\n\tcuda_pull_array(l.rolling_mean_gpu, l.rolling_mean, l.c);\n\tcuda_pull_array(l.rolling_variance_gpu, l.rolling_variance, l.c);\n}", "path": "sod/sod.c", "commit_date": "2020-03-03 00:00:00", "repo_name": "symisc/sod", "stars": 1708, "license": "other", "language": "c", "size": 3582}
{"docstring": "/*\n* Cross platform srtncmp\n*/\n", "func_signal": "static int sy_strcmp(const char *zA, const char *zB)", "code": "{\n\tfor (;;) {\n\t\tint c = tolower(zA[0]);\n\t\tint d = tolower(zB[0]);\n\t\tint e = c - d;\n\t\tif (e != 0) return e;\n\t\tif (c == 0) break;\n\t\tzA++;\n\t\tzB++;\n\t}\n\treturn 0; /* Equal string */\n}", "path": "sod/sod.c", "commit_date": "2020-03-03 00:00:00", "repo_name": "symisc/sod", "stars": 1708, "license": "other", "language": "c", "size": 3582}
{"docstring": "/*\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\n*/\n", "func_signal": "void sod_scale_image(sod_img m, float s)", "code": "{\n\tif (m.data) {\n\t\tint i;\n\t\tfor (i = 0; i < m.h*m.w*m.c; ++i) m.data[i] *= s;\n\t}\n}", "path": "sod/sod.c", "commit_date": "2020-03-03 00:00:00", "repo_name": "symisc/sod", "stars": 1708, "license": "other", "language": "c", "size": 3582}
{"docstring": "/*\n* From Berkeley Vision's Caffe!\n* https://github.com/BVLC/caffe/blob/master/LICENSE\n*/\n", "func_signal": "static inline void im2col_cpu(float* data_im,\n\tint channels, int height, int width,\n\tint ksize, int stride, int pad, float* data_col)", "code": "{\n\tint c, h, w;\n\tint height_col = (height + 2 * pad - ksize) / stride + 1;\n\tint width_col = (width + 2 * pad - ksize) / stride + 1;\n\tint channels_col = channels * ksize * ksize;\n\tint w_offset, h_offset, c_im, im_row, im_col, col_index;\n\tc = 0;\n\tfor (;;) {\n\t\tif (c >= channels_col) break;\n\t\tw_offset = c % ksize;\n\t\th_offset = (c / ksize) % ksize;\n\t\tc_im = c / ksize / ksize;\n\t\tfor (h = 0; h < height_col; ++h) {\n\t\t\tfor (w = 0; w < width_col; ++w) {\n\t\t\t\tim_row = h_offset + h * stride;\n\t\t\t\tim_col = w_offset + w * stride;\n\t\t\t\tcol_index = (c * height_col + h) * width_col + w;\n\t\t\t\tdata_col[col_index] = im2col_get_pixel(data_im, height, width,\n\t\t\t\t\tim_row, im_col, c_im, pad);\n\t\t\t}\n\t\t}\n\t\tc++;\n\t}\n}", "path": "sod/sod.c", "commit_date": "2020-03-03 00:00:00", "repo_name": "symisc/sod", "stars": 1708, "license": "other", "language": "c", "size": 3582}
{"docstring": "/*\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\n*/\n", "func_signal": "void sod_transpose_image(sod_img im)", "code": "{\n\tint n, m;\n\tint c;\n\tif (im.w != im.h) {\n\t\treturn;\n\t}\n\tif (im.data) {\n\t\tfor (c = 0; c < im.c; ++c) {\n\t\t\tfor (n = 0; n < im.w - 1; ++n) {\n\t\t\t\tfor (m = n + 1; m < im.w; ++m) {\n\t\t\t\t\tfloat swap = im.data[m + im.w*(n + im.h*c)];\n\t\t\t\t\tim.data[m + im.w*(n + im.h*c)] = im.data[n + im.w*(m + im.h*c)];\n\t\t\t\t\tim.data[n + im.w*(m + im.h*c)] = swap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "path": "sod/sod.c", "commit_date": "2020-03-03 00:00:00", "repo_name": "symisc/sod", "stars": 1708, "license": "other", "language": "c", "size": 3582}
{"docstring": "/*\n * CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\n */\n", "func_signal": "float sod_img_get_pixel(sod_img m, int x, int y, int c)", "code": "{\n\tif (x < 0) x = 0;\n\tif (x >= m.w) x = m.w - 1;\n\tif (y < 0) y = 0;\n\tif (y >= m.h) y = m.h - 1;\n\tif (c < 0 || c >= m.c) return 0;\n\treturn get_pixel(m, x, y, c);\n}", "path": "sod/sod.c", "commit_date": "2020-03-03 00:00:00", "repo_name": "symisc/sod", "stars": 1708, "license": "other", "language": "c", "size": 3582}
{"docstring": "/*\n** Convert microsoft unicode to UTF-8.  Space to hold the returned string is\n** obtained from HeapAlloc().\n** Taken from the sqlite3 source tree\n** status: Public Domain\n*/\n", "func_signal": "static char *unicodeToUtf8(const WCHAR *zWideFilename)", "code": "{\n\tchar *zFilename;\n\tint nByte;\n\n\tnByte = WideCharToMultiByte(CP_UTF8, 0, zWideFilename, -1, 0, 0, 0, 0);\n\tzFilename = (char *)HeapAlloc(GetProcessHeap(), 0, nByte);\n\tif (zFilename == 0) {\n\t\treturn 0;\n\t}\n\tnByte = WideCharToMultiByte(CP_UTF8, 0, zWideFilename, -1, zFilename, nByte, 0, 0);\n\tif (nByte == 0) {\n\t\tHeapFree(GetProcessHeap(), 0, zFilename);\n\t\treturn 0;\n\t}\n\treturn zFilename;\n}", "path": "sod/sod.c", "commit_date": "2020-03-03 00:00:00", "repo_name": "symisc/sod", "stars": 1708, "license": "other", "language": "c", "size": 3582}
{"docstring": "/*\n* Run across the tree and get its output.\n*/\n", "func_signal": "static float DetectorGetTreeOutput(sod_tree *pTree, int rs, int cs, int ss, sod_img *pTarget)", "code": "{\n\tint j, idx = 1;\n\tfor (j = 0; j < pTree->depth; j++) {\n\t\tint iNode = pTree->aNodes[idx - 1];\n\t\tidx = 2 * idx + BinTest(iNode, rs, cs, ss, &(*pTarget));\n\t}\n\treturn pTree->aLeafs[idx - (1 << pTree->depth)];\n}", "path": "sod/sod.c", "commit_date": "2020-03-03 00:00:00", "repo_name": "symisc/sod", "stars": 1708, "license": "other", "language": "c", "size": 3582}
{"docstring": "/* int (*xIsfile)(const char *) */\n", "func_signal": "static int UnixVfs_isfile(const char *zPath)", "code": "{\n\tstruct stat st;\n\tint rc;\n\trc = stat(zPath, &st);\n\tif (rc != 0) {\n\t\treturn -1;\n\t}\n\trc = S_ISREG(st.st_mode);\n\treturn rc ? SOD_OK : -1;\n}", "path": "sod/sod.c", "commit_date": "2020-03-03 00:00:00", "repo_name": "symisc/sod", "stars": 1708, "license": "other", "language": "c", "size": 3582}
{"docstring": "/* =============================================================== SHORTCUT =============================================================== */\n", "func_signal": "static void forward_shortcut_layer(const layer l, network_state state)", "code": "{\n\tcopy_cpu(l.outputs*l.batch, state.input, 1, l.output, 1);\n\tshortcut_cpu(l.batch, l.w, l.h, l.c, state.net->layers[l.index].output, l.out_w, l.out_h, l.out_c, l.output);\n\tactivate_array(l.output, l.outputs*l.batch, l.activation);\n}", "path": "sod/sod.c", "commit_date": "2020-03-03 00:00:00", "repo_name": "symisc/sod", "stars": 1708, "license": "other", "language": "c", "size": 3582}
{"docstring": "/* Based on the work: http://cis.k.hosei.ac.jp/~wakahara/ */\n", "func_signal": "static int minutiae_crossnumber(float *pixels,int y, int x, int w)", "code": "{\n\tint i, data[8];\n\tint cross;\n\n\tdata[0] = pixels[y * w + x + 1] == 0 ? 1 : 0;\n\tdata[1] = pixels[(y - 1) * w + x + 1] == 0 ? 1 : 0;\n\tdata[2] = pixels[(y - 1) * w + x] == 0 ? 1 : 0;\n\tdata[3] = pixels[(y - 1) * w + (x - 1)] == 0 ? 1 : 0;\n\tdata[4] = pixels[y * w + (x - 1)] == 0 ? 1 : 0;\n\tdata[5] = pixels[(y + 1) * w + (x - 1)] == 0 ? 1 : 0;\n\tdata[6] = pixels[(y + 1) * w + x] == 0 ? 1 : 0;\n\tdata[7] = pixels[(y + 1) * w + x + 1] == 0 ? 1 : 0;\n\tcross = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tcross += abs(data[(i + 1) % 8] - data[i]);\n\t}\n\tcross /= 2;\n\treturn cross;\n}", "path": "sod/sod.c", "commit_date": "2020-03-03 00:00:00", "repo_name": "symisc/sod", "stars": 1708, "license": "other", "language": "c", "size": 3582}
{"docstring": "/*\n* Duplicate a non-nil terminated string.\n*/\n", "func_signal": "static int DupSyString(SyString *pIn, SyString *pOut)", "code": "{\n\tchar *z = 0;\n\tpOut->nByte = 0; /* Marker */\n\tif (pOut->zString != 0) {\n\t\tz = (char *)pOut->zString;\n\t\tz = realloc(z, pIn->nByte);\n\t}\n\telse {\n\t\tz = malloc(pIn->nByte + 1);\n\t\tpOut->nByte = 0; /* Marker */\n\t}\n\tif (z == 0) return SOD_OUTOFMEM;\n\tmemcpy(z, (const void *)pIn->zString, pIn->nByte);\n\tz[pIn->nByte] = 0;\n\tpOut->zString = z;\n\tpOut->nByte = pIn->nByte;\n\treturn SOD_OK;\n}", "path": "sod/sod.c", "commit_date": "2020-03-03 00:00:00", "repo_name": "symisc/sod", "stars": 1708, "license": "other", "language": "c", "size": 3582}
{"docstring": "/*\n* Seed a RNN network.\n*/\n", "func_signal": "static void prepare_rnn_seed(sod_cnn *pNet, int len)", "code": "{\n\tint i;\n\tfor (i = 0; i < len - 1; ++i) {\n\t\tpNet->c_rnn = pNet->zRnnSeed[i];\n\t\tpNet->aInput[pNet->c_rnn] = 1;\n\t\tnetwork_predict(&pNet->net, pNet->aInput);\n\t\tpNet->aInput[pNet->c_rnn] = 0;\n\t}\n}", "path": "sod/sod.c", "commit_date": "2020-03-03 00:00:00", "repo_name": "symisc/sod", "stars": 1708, "license": "other", "language": "c", "size": 3582}
{"docstring": "/*\n* Apply Sobel operator on an input image.\n*/\n", "func_signal": "int main(int argc, char *argv[])", "code": "{\n\t/* Input image (pass a path or use the test image shipped with the samples ZIP archive) */\n\tconst char *zInput = argc > 1 ? argv[1] : \"./sobel.jpg\";\n\t/* Processed output image path */\n\tconst char *zOut = argc > 2 ? argv[2] : \"./out_sobel.png\";\n\t/* Load the input image in the grayscale colorspace */\n\tsod_img imgIn = sod_img_load_from_file(zInput, SOD_IMG_GRAYSCALE/* single channel colorspace (gray)*/);\n\tif (imgIn.data == 0) {\n\t\t/* Invalid path, unsupported format, memory failure, etc. */\n\t\tputs(\"Cannot load input image..exiting\");\n\t\treturn 0;\n\t}\n\t/* Apply Sobel operator. */\n\tsod_img imgOut = sod_sobel_image(imgIn);\n\t/* Finally save our processed image to the specified path */\n\tsod_img_save_as_png(imgOut, zOut);\n\t/* Cleanup */\n\tsod_free_image(imgIn);\n\tsod_free_image(imgOut);\n\treturn 0;\n}", "path": "sod/samples/sobel_operator_img.c", "commit_date": "2018-06-05 00:00:00", "repo_name": "symisc/sod", "stars": 1708, "license": "other", "language": "c", "size": 3582}
{"docstring": "/*\n* Erode an input binary image.\n*/\n", "func_signal": "int main(int argc, char *argv[])", "code": "{\n\t/* Input image (pass a path or use the test image shipped with the samples ZIP archive) */\n\tconst char *zInput = argc > 1 ? argv[1] : \"./text.jpg\";\n\t/* Processed output image path */\n\tconst char *zOut = argc > 2 ? argv[2] : \"./out_dilated.png\";\n\t/* Load the input image in the grayscale colorspace */\n\tsod_img imgIn = sod_img_load_grayscale(zInput);\n\tif (imgIn.data == 0) {\n\t\t/* Invalid path, unsupported format, memory failure, etc. */\n\t\tputs(\"Cannot load input image..exiting\");\n\t\treturn 0;\n\t}\n\t/* \n\t * Binarize the input image before the dilation process.\n\t */\n\tsod_img binImg = sod_binarize_image(imgIn, 0);\n\t/* Finally, erode the binary image, say  5 times */\n\tsod_img erodeImg = sod_erode_image(binImg, 5);\n\t/* Save the eroded image to the specified path */\n\tsod_img_save_as_png(erodeImg, zOut);\n\t/* Cleanup */\n\tsod_free_image(imgIn);\n\tsod_free_image(binImg);\n\tsod_free_image(erodeImg);\n\treturn 0;\n}", "path": "sod/samples/erode_image.c", "commit_date": "2018-06-04 00:00:00", "repo_name": "symisc/sod", "stars": 1708, "license": "other", "language": "c", "size": 3582}
{"docstring": "/*\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\n*/\n", "func_signal": "void sod_image_draw_circle_thickness(sod_img im, int x0, int y0, int radius, int width, float r, float g, float b)", "code": "{\n\tint i;\n\tfor (i = 0; i < width; i++) {\n\t\tsod_image_draw_circle(im, x0, y0, radius - i, r, g, b);\n\t}\n\t/* @chm: Fill empty pixels */\n}", "path": "sod/sod.c", "commit_date": "2020-03-03 00:00:00", "repo_name": "symisc/sod", "stars": 1708, "license": "other", "language": "c", "size": 3582}
{"docstring": "/*\n* Learn a new stage.\n*/\n", "func_signal": "static int DetectorLearnNewStage(sod_realnet_detector *pDet, float mintpr, float maxfpr, size_t maxtree, size_t nPos, size_t nNeg)", "code": "{\n\tsod_realnet_trainer *pTrainer = pDet->pTrainer;\n\tsod_tr_sample *aSample = (sod_tr_sample *)SySetBasePtr(&pTrainer->aSample);\n\tsize_t i, nSample = SySetUsed(&pTrainer->aSample);\n\tfloat threshold = 0.0f;\n\tfloat tpr, fpr;\n\tdouble *wt;\n\t/* Allocate the weights table */\n\twt = (double *)malloc(nSample * sizeof(double));\n\tif (wt == 0) {\n\t\tsod_config_log_msg(pTrainer, \"Running out-of-memory...aborting\\n\");\n\t\treturn SOD_ABORT;\n\t}\n\tmaxtree = SySetUsed(&pDet->aTree) + maxtree;\n\tfpr = 1.0f;\n\tnNeg = SySetUsed(&pTrainer->aSample) - nPos;\n\t/* Start the learning process */\n\tsod_config_log_msg(pTrainer, \"Learning new detection stage for epoch#%d\\n\", pTrainer->nEpoch);\n\twhile (SySetUsed(&pDet->aTree) < maxtree && fpr > maxfpr) {\n\t\tfloat end, start = pTrainer->pVfs->xTicks();\n\t\tsod_tr_sample *pEntry;\n\t\tdouble ws = 0.0;\n\t\tsod_tree sTree;\n\t\t/* Compute the weights first */\n\t\tfor (i = 0; i < nSample; ++i) {\n\t\t\tpEntry = &aSample[i];\n\t\t\tif (pEntry->tv > 0) {\n\t\t\t\twt[i] = exp(-1.0 * pEntry->score) / nPos;\n\t\t\t}\n\t\t\telse {\n\t\t\t\twt[i] = exp(+1.0 * pEntry->score) / nNeg;\n\t\t\t}\n\t\t\tws += wt[i];\n\t\t}\n\t\t/* Compute the average */\n\t\tfor (i = 0; i < nSample; ++i) wt[i] /= ws;\n\t\t/* Build the tree */\n\t\tmemset(&sTree, 0, sizeof(sod_tree));\n\t\tsTree.pDet = pDet;\n\t\tif (SOD_OK != DetectorBuildTree(&sTree, pDet->min_tree_depth, wt, aSample, nSample)) {\n\t\t\t/* Mostly out of memory, abort */\n\t\t\tfree(wt);\n\t\t\treturn SOD_ABORT;\n\t\t}\n\t\t/* Set a low confidence threshold first */\n\t\tsTree.threshold = -1337.0f /* -FLT_MAX */;\n\t\t/* Insert */\n\t\tif (SOD_OK != SySetPut(&pDet->aTree, &sTree)) {\n\t\t\tfree(sTree.aNodes);\n\t\t\tfree(sTree.aLeafs);\n\t\t\tfree(wt);\n\t\t\tsod_config_log_msg(pTrainer, \"Running out-of-memory...aborting\\n\");\n\t\t\treturn SOD_ABORT;\n\t\t}\n\t\t/* Update score */\n\t\tfor (i = 0; i < nSample; ++i) {\n\t\t\tfloat score;\n\t\t\tpEntry = &aSample[i];\n\t\t\tscore = DetectorGetTreeOutput(&sTree, pEntry->rs, pEntry->cs, pEntry->ss, &pEntry->sRaw);\n\t\t\tpEntry->score += score;\n\t\t}\n\t\t/* Calculate threshold */\n\t\tthreshold = 5.0f;\n\t\tdo {\n\t\t\tuint32_t ntps, nfps;\n\t\t\tntps = nfps = 0;\n\t\t\t/* Adjust threshold */\n\t\t\tthreshold -= 0.005f;\n\t\t\tfor (i = 0; i < nSample; ++i) {\n\t\t\t\tpEntry = &aSample[i];\n\t\t\t\tif (pEntry->tv > 0 && pEntry->score > threshold) ntps++;\n\t\t\t\tif (pEntry->tv < 0 && pEntry->score > threshold) nfps++;\n\t\t\t}\n\t\t\ttpr = ntps / (float)nPos;\n\t\t\tfpr = nfps / (float)nNeg;\n\t\t} while (tpr < mintpr);\n\t\t/* Tree generated, log that */\n\t\tend = pTrainer->pVfs->xTicks();\n\t\tsod_config_log_msg(pTrainer, \"Tree#%d of depth %d built in %d seconds: FPR: %f TPR: %f\\n\",\n\t\t(int)SySetUsed(&pDet->aTree),\n\t\tpDet->min_tree_depth,\n\t\t(int)(end - start),\n\t\tfpr,\n\t\ttpr\n\t\t);\n\t}\n\tif (SySetUsed(&pDet->aTree) > 0) {\n\t\t/* Set the final threshold */\n\t\tsod_tree *aTree = (sod_tree *)SySetBasePtr(&pDet->aTree);\n\t\taTree[SySetUsed(&pDet->aTree) - 1].threshold = threshold;\n\t\tsod_config_log_msg(&(*pTrainer), \"Final threshold value for tree#%d set to: %f\\n\",\n\t\t\t(int)SySetUsed(&pDet->aTree),\n\t\t\tthreshold\n\t\t);\n\t}\n\tif (fpr > maxfpr && pDet->min_tree_depth < pDet->max_tree_depth) {\n\t\t/* Increment the tree depth due to high false positive rate */\n\t\t/* \n\t\tpDet->min_tree_depth++;\n\t\tsod_config_log_msg(&(*pTrainer), \"Tree depth incremented to %d due to high false positive rate\\n\", pDet->min_tree_depth);\n\t\t*/\n\t}\n\t/* Cleanup */\n\tfree(wt);\n\treturn SOD_OK;\n}", "path": "sod/sod.c", "commit_date": "2020-03-03 00:00:00", "repo_name": "symisc/sod", "stars": 1708, "license": "other", "language": "c", "size": 3582}
{"docstring": "/* int (*xGetcwd)(SyBlob *) */\n", "func_signal": "static int WinVfs_getcwd(SyBlob *pCtx)", "code": "{\n\tWCHAR zDir[2048];\n\tchar *zConverted;\n\tDWORD rc;\n\t/* Get the current directory */\n\trc = GetCurrentDirectoryW(sizeof(zDir), zDir);\n\tif (rc < 1) {\n\t\treturn -1;\n\t}\n\tzConverted = unicodeToUtf8(zDir);\n\tif (zConverted == 0) {\n\t\treturn -1;\n\t}\n\tlibcox_result_string(pCtx, zConverted, -1/*Compute length automatically*/); /* Will make it's own copy */\n\tHeapFree(GetProcessHeap(), 0, zConverted);\n\treturn SOD_OK;\n}", "path": "sod/sod.c", "commit_date": "2020-03-03 00:00:00", "repo_name": "symisc/sod", "stars": 1708, "license": "other", "language": "c", "size": 3582}
{"docstring": "/*\n* CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\n*/\n", "func_signal": "sod_img sod_img_load_from_cv(const char *filename, int channels)", "code": "{\n\tIplImage* src = 0;\n\tint flag = -1;\n\tif (channels == 0) flag = -1;\n\telse if (channels == 1) flag = 0;\n\telse if (channels == 3) flag = 1;\n\telse {\n\t\treturn sod_make_empty_image(0, 0, 0);\n\t}\n\n\tif ((src = cvLoadImage(filename, flag)) == 0)\n\t{\n\t\treturn sod_make_empty_image(0, 0, 0);\n\t}\n\tsod_img out = sod_img_load_cv_ipl(src);\n\tcvReleaseImage(&src);\n\tsod_img_rgb_to_bgr(out);\n\treturn out;\n}", "path": "sod/sod.c", "commit_date": "2020-03-03 00:00:00", "repo_name": "symisc/sod", "stars": 1708, "license": "other", "language": "c", "size": 3582}
{"docstring": "/*\n * CAPIREF: Refer to the official documentation at https://sod.pixlab.io/api.html for the expected parameters this interface takes.\n */\n", "func_signal": "sod_img sod_img_get_layer(sod_img m, int l)", "code": "{\n\tsod_img out = sod_make_image(m.w, m.h, 1);\n\tint i;\n\tif (out.data && l >= 0 && l < m.c) {\n\t\tfor (i = 0; i < m.h*m.w; ++i) {\n\t\t\tout.data[i] = m.data[i + l * m.h*m.w];\n\t\t}\n\t}\n\treturn out;\n}", "path": "sod/sod.c", "commit_date": "2020-03-03 00:00:00", "repo_name": "symisc/sod", "stars": 1708, "license": "other", "language": "c", "size": 3582}
{"docstring": "/**\n  * @brief  Configure the SysTick clock source.\n  * @param  CLKSource specifies the SysTick clock source.\n  *          This parameter can be one of the following values:\n  *             @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source.\n  *             @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source.\n  * @retval None\n  */\n", "func_signal": "void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));\n  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)\n  {\n    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;\n  }\n  else\n  {\n    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;\n  }\n}", "path": "btstack/port/stm32-l073rz-nucleo-em9304/Drivers/STM32L0xx_HAL_Driver/Src/stm32l0xx_hal_cortex.c", "commit_date": "2019-03-30 00:00:00", "repo_name": "bluekitchen/btstack", "stars": 1549, "license": "other", "language": "c", "size": 95905}
{"docstring": "/**\n  * @brief  Start the Timeout function in interrupt mode.\n  * @note   The first trigger event will start the timer, any successive\n  *         trigger event will reset the counter and the timer restarts.\n  * @param  hlptim LPTIM handle\n  * @param  Period Specifies the Autoreload value.\n  *         This parameter must be a value between 0x0000 and 0xFFFF.\n  * @param  Timeout Specifies the TimeOut value to reset the counter.\n  *         This parameter must be a value between 0x0000 and 0xFFFF.\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_LPTIM_TimeOut_Start_IT(LPTIM_HandleTypeDef *hlptim, uint32_t Period, uint32_t Timeout)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_LPTIM_INSTANCE(hlptim->Instance));\n  assert_param(IS_LPTIM_PERIOD(Period));\n  assert_param(IS_LPTIM_PULSE(Timeout));\n\n  /* Set the LPTIM state */\n  hlptim->State = HAL_LPTIM_STATE_BUSY;\n\n  /* Enable EXTI Line interrupt on the LPTIM Wake-up Timer */\n  __HAL_LPTIM_WAKEUPTIMER_EXTI_ENABLE_IT(hlptim->Instance);\n\n  /* Set TIMOUT bit to enable the timeout function */\n  hlptim->Instance->CFGR |= LPTIM_CFGR_TIMOUT;\n\n  /* Enable the Peripheral */\n  __HAL_LPTIM_ENABLE(hlptim);\n\n  /* Clear flag */\n  __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_ARROK);\n\n  /* Load the period value in the autoreload register */\n  __HAL_LPTIM_AUTORELOAD_SET(hlptim, Period);\n\n  /* Wait for the completion of the write operation to the LPTIM_ARR register */\n  if (LPTIM_WaitForFlag(hlptim, LPTIM_FLAG_ARROK) == HAL_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n\n  /* Clear flag */\n  __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_CMPOK);\n\n  /* Load the Timeout value in the compare register */\n  __HAL_LPTIM_COMPARE_SET(hlptim, Timeout);\n\n  /* Wait for the completion of the write operation to the LPTIM_CMP register */\n  if (LPTIM_WaitForFlag(hlptim, LPTIM_FLAG_CMPOK) == HAL_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n\n  /* Disable the Peripheral */\n  __HAL_LPTIM_DISABLE(hlptim);\n\n  if (HAL_LPTIM_GetState(hlptim) == HAL_LPTIM_STATE_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n\n  /* Enable Compare match interrupt */\n  __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_CMPM);\n\n  /* Enable the Peripheral */\n  __HAL_LPTIM_ENABLE(hlptim);\n\n  /* Start timer in continuous mode */\n  __HAL_LPTIM_START_CONTINUOUS(hlptim);\n\n  /* Change the TIM state*/\n  hlptim->State = HAL_LPTIM_STATE_READY;\n\n  /* Return function status */\n  return HAL_OK;\n}", "path": "btstack/port/stm32-l451-miromico-sx1280/Drivers/STM32L4xx_HAL_Driver/Src/stm32l4xx_hal_lptim.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "bluekitchen/btstack", "stars": 1549, "license": "other", "language": "c", "size": 95905}
{"docstring": "/**\n  * @brief  Start the Counter mode.\n  * @param  hlptim LPTIM handle\n  * @param  Period Specifies the Autoreload value.\n  *         This parameter must be a value between 0x0000 and 0xFFFF.\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_LPTIM_Counter_Start(LPTIM_HandleTypeDef *hlptim, uint32_t Period)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_LPTIM_INSTANCE(hlptim->Instance));\n  assert_param(IS_LPTIM_PERIOD(Period));\n\n  /* Set the LPTIM state */\n  hlptim->State = HAL_LPTIM_STATE_BUSY;\n\n  /* If clock source is not ULPTIM clock and counter source is external, then it must not be prescaled */\n  if ((hlptim->Init.Clock.Source != LPTIM_CLOCKSOURCE_ULPTIM) && (hlptim->Init.CounterSource == LPTIM_COUNTERSOURCE_EXTERNAL))\n  {\n    /* Check if clock is prescaled */\n    assert_param(IS_LPTIM_CLOCK_PRESCALERDIV1(hlptim->Init.Clock.Prescaler));\n    /* Set clock prescaler to 0 */\n    hlptim->Instance->CFGR &= ~LPTIM_CFGR_PRESC;\n  }\n\n  /* Enable the Peripheral */\n  __HAL_LPTIM_ENABLE(hlptim);\n\n  /* Clear flag */\n  __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_ARROK);\n\n  /* Load the period value in the autoreload register */\n  __HAL_LPTIM_AUTORELOAD_SET(hlptim, Period);\n\n  /* Wait for the completion of the write operation to the LPTIM_ARR register */\n  if (LPTIM_WaitForFlag(hlptim, LPTIM_FLAG_ARROK) == HAL_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n\n  /* Start timer in continuous mode */\n  __HAL_LPTIM_START_CONTINUOUS(hlptim);\n\n  /* Change the TIM state*/\n  hlptim->State = HAL_LPTIM_STATE_READY;\n\n  /* Return function status */\n  return HAL_OK;\n}", "path": "btstack/port/stm32-l451-miromico-sx1280/Drivers/STM32L4xx_HAL_Driver/Src/stm32l4xx_hal_lptim.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "bluekitchen/btstack", "stars": 1549, "license": "other", "language": "c", "size": 95905}
{"docstring": "/**\n  * @brief  Start the LPTIM Set once mode in interrupt mode.\n  * @param  hlptim LPTIM handle\n  * @param  Period Specifies the Autoreload value.\n  *         This parameter must be a value between 0x0000 and 0xFFFF.\n  * @param  Pulse Specifies the compare value.\n  *         This parameter must be a value between 0x0000 and 0xFFFF.\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_LPTIM_SetOnce_Start_IT(LPTIM_HandleTypeDef *hlptim, uint32_t Period, uint32_t Pulse)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_LPTIM_INSTANCE(hlptim->Instance));\n  assert_param(IS_LPTIM_PERIOD(Period));\n  assert_param(IS_LPTIM_PULSE(Pulse));\n\n  /* Set the LPTIM state */\n  hlptim->State = HAL_LPTIM_STATE_BUSY;\n\n  /* Set WAVE bit to enable the set once mode */\n  hlptim->Instance->CFGR |= LPTIM_CFGR_WAVE;\n\n  /* Enable the Peripheral */\n  __HAL_LPTIM_ENABLE(hlptim);\n\n  /* Clear flag */\n  __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_ARROK);\n\n  /* Load the period value in the autoreload register */\n  __HAL_LPTIM_AUTORELOAD_SET(hlptim, Period);\n\n  /* Wait for the completion of the write operation to the LPTIM_ARR register */\n  if (LPTIM_WaitForFlag(hlptim, LPTIM_FLAG_ARROK) == HAL_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n\n  /* Clear flag */\n  __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_CMPOK);\n\n  /* Load the pulse value in the compare register */\n  __HAL_LPTIM_COMPARE_SET(hlptim, Pulse);\n\n  /* Wait for the completion of the write operation to the LPTIM_CMP register */\n  if (LPTIM_WaitForFlag(hlptim, LPTIM_FLAG_CMPOK) == HAL_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n\n  /* Disable the Peripheral */\n  __HAL_LPTIM_DISABLE(hlptim);\n\n  if (HAL_LPTIM_GetState(hlptim) == HAL_LPTIM_STATE_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n\n  /* Enable Autoreload write complete interrupt */\n  __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_ARROK);\n\n  /* Enable Compare write complete interrupt */\n  __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_CMPOK);\n\n  /* Enable Autoreload match interrupt */\n  __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_ARRM);\n\n  /* Enable Compare match interrupt */\n  __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_CMPM);\n\n  /* If external trigger source is used, then enable external trigger interrupt */\n  if ((hlptim->Init.Trigger.Source) != LPTIM_TRIGSOURCE_SOFTWARE)\n  {\n    /* Enable external trigger interrupt */\n    __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_EXTTRIG);\n  }\n\n  /* Enable the Peripheral */\n  __HAL_LPTIM_ENABLE(hlptim);\n\n  /* Start timer in single (one shot) mode */\n  __HAL_LPTIM_START_SINGLE(hlptim);\n\n  /* Change the TIM state*/\n  hlptim->State = HAL_LPTIM_STATE_READY;\n\n  /* Return function status */\n  return HAL_OK;\n}", "path": "btstack/port/stm32-l451-miromico-sx1280/Drivers/STM32L4xx_HAL_Driver/Src/stm32l4xx_hal_lptim.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "bluekitchen/btstack", "stars": 1549, "license": "other", "language": "c", "size": 95905}
{"docstring": "/**\n  * @brief  Stop the Counter mode.\n  * @param  hlptim LPTIM handle\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_LPTIM_Counter_Stop(LPTIM_HandleTypeDef *hlptim)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_LPTIM_INSTANCE(hlptim->Instance));\n\n  /* Set the LPTIM state */\n  hlptim->State = HAL_LPTIM_STATE_BUSY;\n\n  /* Disable the Peripheral */\n  __HAL_LPTIM_DISABLE(hlptim);\n\n  if (HAL_LPTIM_GetState(hlptim) == HAL_LPTIM_STATE_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n\n  /* Change the TIM state*/\n  hlptim->State = HAL_LPTIM_STATE_READY;\n\n  /* Return function status */\n  return HAL_OK;\n}", "path": "btstack/port/stm32-l451-miromico-sx1280/Drivers/STM32L4xx_HAL_Driver/Src/stm32l4xx_hal_lptim.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "bluekitchen/btstack", "stars": 1549, "license": "other", "language": "c", "size": 95905}
{"docstring": "/**\n  * @brief  Stop the LPTIM One pulse generation in interrupt mode.\n  * @param  hlptim LPTIM handle\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_LPTIM_OnePulse_Stop_IT(LPTIM_HandleTypeDef *hlptim)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_LPTIM_INSTANCE(hlptim->Instance));\n\n  /* Set the LPTIM state */\n  hlptim->State = HAL_LPTIM_STATE_BUSY;\n\n  /* Disable the Peripheral */\n  __HAL_LPTIM_DISABLE(hlptim);\n\n  if (HAL_LPTIM_GetState(hlptim) == HAL_LPTIM_STATE_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n\n  /* Disable Autoreload write complete interrupt */\n  __HAL_LPTIM_DISABLE_IT(hlptim, LPTIM_IT_ARROK);\n\n  /* Disable Compare write complete interrupt */\n  __HAL_LPTIM_DISABLE_IT(hlptim, LPTIM_IT_CMPOK);\n\n  /* Disable Autoreload match interrupt */\n  __HAL_LPTIM_DISABLE_IT(hlptim, LPTIM_IT_ARRM);\n\n  /* Disable Compare match interrupt */\n  __HAL_LPTIM_DISABLE_IT(hlptim, LPTIM_IT_CMPM);\n\n  /* If external trigger source is used, then disable external trigger interrupt */\n  if ((hlptim->Init.Trigger.Source) != LPTIM_TRIGSOURCE_SOFTWARE)\n  {\n    /* Disable external trigger interrupt */\n    __HAL_LPTIM_DISABLE_IT(hlptim, LPTIM_IT_EXTTRIG);\n  }\n#if defined(LPTIM_RCR_REP)\n\n  /* Enable Rep Update Ok interrupt */\n  __HAL_LPTIM_DISABLE_IT(hlptim, LPTIM_IT_REPOK);\n\n  /* Enable Update Event interrupt */\n  __HAL_LPTIM_DISABLE_IT(hlptim, LPTIM_IT_UPDATE);\n#endif\n\n  /* Change the TIM state*/\n  hlptim->State = HAL_LPTIM_STATE_READY;\n\n  /* Return function status */\n  return HAL_OK;\n}", "path": "btstack/port/stm32-l451-miromico-sx1280/Drivers/STM32L4xx_HAL_Driver/Src/stm32l4xx_hal_lptim.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "bluekitchen/btstack", "stars": 1549, "license": "other", "language": "c", "size": 95905}
{"docstring": "/**\n  * @brief  DeInitialize the LPTIM peripheral.\n  * @param  hlptim LPTIM handle\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_LPTIM_DeInit(LPTIM_HandleTypeDef *hlptim)", "code": "{\n  /* Check the LPTIM handle allocation */\n  if (hlptim == NULL)\n  {\n    return HAL_ERROR;\n  }\n\n  /* Change the LPTIM state */\n  hlptim->State = HAL_LPTIM_STATE_BUSY;\n\n  /* Disable the LPTIM Peripheral Clock */\n  __HAL_LPTIM_DISABLE(hlptim);\n\n  if (HAL_LPTIM_GetState(hlptim) == HAL_LPTIM_STATE_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n\n#if (USE_HAL_LPTIM_REGISTER_CALLBACKS == 1)\n  if (hlptim->MspDeInitCallback == NULL)\n  {\n    hlptim->MspDeInitCallback = HAL_LPTIM_MspDeInit;\n  }\n\n  /* DeInit the low level hardware: CLOCK, NVIC.*/\n  hlptim->MspDeInitCallback(hlptim);\n#else\n  /* DeInit the low level hardware: CLOCK, NVIC.*/\n  HAL_LPTIM_MspDeInit(hlptim);\n#endif /* USE_HAL_LPTIM_REGISTER_CALLBACKS */\n\n  /* Change the LPTIM state */\n  hlptim->State = HAL_LPTIM_STATE_RESET;\n\n  /* Release Lock */\n  __HAL_UNLOCK(hlptim);\n\n  /* Return function status */\n  return HAL_OK;\n}", "path": "btstack/port/stm32-l451-miromico-sx1280/Drivers/STM32L4xx_HAL_Driver/Src/stm32l4xx_hal_lptim.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "bluekitchen/btstack", "stars": 1549, "license": "other", "language": "c", "size": 95905}
{"docstring": "/**\n  * @brief  Stop the LPTIM PWM generation in interrupt mode.\n  * @param  hlptim LPTIM handle\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_LPTIM_PWM_Stop_IT(LPTIM_HandleTypeDef *hlptim)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_LPTIM_INSTANCE(hlptim->Instance));\n\n  /* Set the LPTIM state */\n  hlptim->State = HAL_LPTIM_STATE_BUSY;\n\n  /* Disable the Peripheral */\n  __HAL_LPTIM_DISABLE(hlptim);\n\n  if (HAL_LPTIM_GetState(hlptim) == HAL_LPTIM_STATE_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n\n  /* Disable Autoreload write complete interrupt */\n  __HAL_LPTIM_DISABLE_IT(hlptim, LPTIM_IT_ARROK);\n\n  /* Disable Compare write complete interrupt */\n  __HAL_LPTIM_DISABLE_IT(hlptim, LPTIM_IT_CMPOK);\n\n  /* Disable Autoreload match interrupt */\n  __HAL_LPTIM_DISABLE_IT(hlptim, LPTIM_IT_ARRM);\n\n  /* Disable Compare match interrupt */\n  __HAL_LPTIM_DISABLE_IT(hlptim, LPTIM_IT_CMPM);\n\n  /* If external trigger source is used, then disable external trigger interrupt */\n  if ((hlptim->Init.Trigger.Source) != LPTIM_TRIGSOURCE_SOFTWARE)\n  {\n    /* Disable external trigger interrupt */\n    __HAL_LPTIM_DISABLE_IT(hlptim, LPTIM_IT_EXTTRIG);\n  }\n#if defined(LPTIM_RCR_REP)\n\n  /* Enable Rep Update Ok interrupt */\n  __HAL_LPTIM_DISABLE_IT(hlptim, LPTIM_IT_REPOK);\n\n  /* Enable Update Event interrupt */\n  __HAL_LPTIM_DISABLE_IT(hlptim, LPTIM_IT_UPDATE);\n#endif\n\n  /* Change the TIM state*/\n  hlptim->State = HAL_LPTIM_STATE_READY;\n\n  /* Return function status */\n  return HAL_OK;\n}", "path": "btstack/port/stm32-l451-miromico-sx1280/Drivers/STM32L4xx_HAL_Driver/Src/stm32l4xx_hal_lptim.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "bluekitchen/btstack", "stars": 1549, "license": "other", "language": "c", "size": 95905}
{"docstring": "/**\n  * @brief  Start the Encoder interface in interrupt mode.\n  * @param  hlptim LPTIM handle\n  * @param  Period Specifies the Autoreload value.\n  *         This parameter must be a value between 0x0000 and 0xFFFF.\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_LPTIM_Encoder_Start_IT(LPTIM_HandleTypeDef *hlptim, uint32_t Period)", "code": "{\n  uint32_t          tmpcfgr;\n\n  /* Check the parameters */\n  assert_param(IS_LPTIM_ENCODER_INTERFACE_INSTANCE(hlptim->Instance));\n  assert_param(IS_LPTIM_PERIOD(Period));\n  assert_param(hlptim->Init.Clock.Source == LPTIM_CLOCKSOURCE_APBCLOCK_LPOSC);\n  assert_param(hlptim->Init.Clock.Prescaler == LPTIM_PRESCALER_DIV1);\n  assert_param(IS_LPTIM_CLOCK_POLARITY(hlptim->Init.UltraLowPowerClock.Polarity));\n\n  /* Set the LPTIM state */\n  hlptim->State = HAL_LPTIM_STATE_BUSY;\n\n  /* Configure edge sensitivity for encoder mode */\n  /* Get the LPTIMx CFGR value */\n  tmpcfgr = hlptim->Instance->CFGR;\n\n  /* Clear CKPOL bits */\n  tmpcfgr &= (uint32_t)(~LPTIM_CFGR_CKPOL);\n\n  /* Set Input polarity */\n  tmpcfgr |=  hlptim->Init.UltraLowPowerClock.Polarity;\n\n  /* Write to LPTIMx CFGR */\n  hlptim->Instance->CFGR = tmpcfgr;\n\n  /* Set ENC bit to enable the encoder interface */\n  hlptim->Instance->CFGR |= LPTIM_CFGR_ENC;\n\n  /* Enable the Peripheral */\n  __HAL_LPTIM_ENABLE(hlptim);\n\n  /* Clear flag */\n  __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_ARROK);\n\n  /* Load the period value in the autoreload register */\n  __HAL_LPTIM_AUTORELOAD_SET(hlptim, Period);\n\n  /* Wait for the completion of the write operation to the LPTIM_ARR register */\n  if (LPTIM_WaitForFlag(hlptim, LPTIM_FLAG_ARROK) == HAL_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n\n  /* Disable the Peripheral */\n  __HAL_LPTIM_DISABLE(hlptim);\n\n  if (HAL_LPTIM_GetState(hlptim) == HAL_LPTIM_STATE_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n\n  /* Enable \"switch to down direction\" interrupt */\n  __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_DOWN);\n\n  /* Enable \"switch to up direction\" interrupt */\n  __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_UP);\n\n  /* Enable the Peripheral */\n  __HAL_LPTIM_ENABLE(hlptim);\n\n  /* Start timer in continuous mode */\n  __HAL_LPTIM_START_CONTINUOUS(hlptim);\n\n  /* Change the TIM state*/\n  hlptim->State = HAL_LPTIM_STATE_READY;\n\n  /* Return function status */\n  return HAL_OK;\n}", "path": "btstack/port/stm32-l451-miromico-sx1280/Drivers/STM32L4xx_HAL_Driver/Src/stm32l4xx_hal_lptim.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "bluekitchen/btstack", "stars": 1549, "license": "other", "language": "c", "size": 95905}
{"docstring": "/**\n  * @brief  Disable the MPU.\n  * @retval None\n  */\n", "func_signal": "void HAL_MPU_Disable(void)", "code": "{\n\n  /*Data Memory Barrier setup */\n  __DMB();\n  /* Disable the MPU */\n  MPU->CTRL = 0;\n}", "path": "btstack/port/stm32-l073rz-nucleo-em9304/Drivers/STM32L0xx_HAL_Driver/Src/stm32l0xx_hal_cortex.c", "commit_date": "2019-03-30 00:00:00", "repo_name": "bluekitchen/btstack", "stars": 1549, "license": "other", "language": "c", "size": 95905}
{"docstring": "/**\n  * @brief  Stop the LPTIM Set once mode in interrupt mode.\n  * @param  hlptim LPTIM handle\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_LPTIM_SetOnce_Stop_IT(LPTIM_HandleTypeDef *hlptim)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_LPTIM_INSTANCE(hlptim->Instance));\n\n  /* Set the LPTIM state */\n  hlptim->State = HAL_LPTIM_STATE_BUSY;\n\n  /* Disable the Peripheral */\n  __HAL_LPTIM_DISABLE(hlptim);\n\n  if (HAL_LPTIM_GetState(hlptim) == HAL_LPTIM_STATE_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n\n  /* Disable Autoreload write complete interrupt */\n  __HAL_LPTIM_DISABLE_IT(hlptim, LPTIM_IT_ARROK);\n\n  /* Disable Compare write complete interrupt */\n  __HAL_LPTIM_DISABLE_IT(hlptim, LPTIM_IT_CMPOK);\n\n  /* Disable Autoreload match interrupt */\n  __HAL_LPTIM_DISABLE_IT(hlptim, LPTIM_IT_ARRM);\n\n  /* Disable Compare match interrupt */\n  __HAL_LPTIM_DISABLE_IT(hlptim, LPTIM_IT_CMPM);\n\n  /* If external trigger source is used, then disable external trigger interrupt */\n  if ((hlptim->Init.Trigger.Source) != LPTIM_TRIGSOURCE_SOFTWARE)\n  {\n    /* Disable external trigger interrupt */\n    __HAL_LPTIM_DISABLE_IT(hlptim, LPTIM_IT_EXTTRIG);\n  }\n\n  /* Change the TIM state*/\n  hlptim->State = HAL_LPTIM_STATE_READY;\n\n  /* Return function status */\n  return HAL_OK;\n}", "path": "btstack/port/stm32-l451-miromico-sx1280/Drivers/STM32L4xx_HAL_Driver/Src/stm32l4xx_hal_lptim.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "bluekitchen/btstack", "stars": 1549, "license": "other", "language": "c", "size": 95905}
{"docstring": "/**\n  * @brief  Initialize and configure the Region and the memory to be protected.\n  * @param  MPU_Init Pointer to a MPU_Region_InitTypeDef structure that contains\n  *                the initialization and configuration information.\n  * @retval None\n  */\n", "func_signal": "void HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));\n  assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));\n\n  /* Set the Region number */\n  MPU->RNR = MPU_Init->Number;\n\n  if ((MPU_Init->Enable) == MPU_REGION_ENABLE)\n  {\n    /* Check the parameters */\n    assert_param(IS_MPU_INSTRUCTION_ACCESS(MPU_Init->DisableExec));\n    assert_param(IS_MPU_REGION_PERMISSION_ATTRIBUTE(MPU_Init->AccessPermission));\n    assert_param(IS_MPU_ACCESS_SHAREABLE(MPU_Init->IsShareable));\n    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));\n    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));\n    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));\n    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));\n\n    /* Set the base adsress and set the 4 LSB to 0 */\n    MPU->RBAR = (MPU_Init->BaseAddress) & 0xfffffff0U;\n\n    /* Fill the field RASR */\n    MPU->RASR = ((uint32_t)MPU_Init->DisableExec        << MPU_RASR_XN_Pos)   |\n                ((uint32_t)MPU_Init->AccessPermission   << MPU_RASR_AP_Pos)   |\n                ((uint32_t)MPU_Init->IsShareable        << MPU_RASR_S_Pos)    |\n                ((uint32_t)MPU_Init->IsCacheable        << MPU_RASR_C_Pos)    |\n                ((uint32_t)MPU_Init->IsBufferable       << MPU_RASR_B_Pos)    |\n                ((uint32_t)MPU_Init->SubRegionDisable   << MPU_RASR_SRD_Pos)  |\n                ((uint32_t)MPU_Init->Size               << MPU_RASR_SIZE_Pos) |\n                ((uint32_t)MPU_Init->Enable             << MPU_RASR_ENABLE_Pos);\n  }\n  else\n  {\n    MPU->RBAR = 0x00U;\n    MPU->RASR = 0x00U;\n  }\n}", "path": "btstack/port/stm32-l073rz-nucleo-em9304/Drivers/STM32L0xx_HAL_Driver/Src/stm32l0xx_hal_cortex.c", "commit_date": "2019-03-30 00:00:00", "repo_name": "bluekitchen/btstack", "stars": 1549, "license": "other", "language": "c", "size": 95905}
{"docstring": "/**\n  * @brief  Disable LPTIM HW instance.\n  * @param  hlptim pointer to a LPTIM_HandleTypeDef structure that contains\n  *                the configuration information for LPTIM module.\n  * @note   The following sequence is required to solve LPTIM disable HW limitation.\n  *         Please check Errata Sheet ES0335 for more details under \"MCU may remain\n  *         stuck in LPTIM interrupt when entering Stop mode\" section.\n  * @retval None\n  */\n", "func_signal": "void LPTIM_Disable(LPTIM_HandleTypeDef *hlptim)", "code": "{\n  uint32_t tmpclksource = 0;\n  uint32_t tmpIER;\n  uint32_t tmpCFGR;\n  uint32_t tmpCMP;\n  uint32_t tmpARR;\n  uint32_t tmpOR;\n#if defined(LPTIM_RCR_REP)\n  uint32_t tmpRCR;\n#endif\n\n  __disable_irq();\n\n  /*********** Save LPTIM Config ***********/\n  /* Save LPTIM source clock */\n  switch ((uint32_t)hlptim->Instance)\n  {\n     case LPTIM1_BASE:\n       tmpclksource = __HAL_RCC_GET_LPTIM1_SOURCE();\n       break;\n#if defined(LPTIM2)\n     case LPTIM2_BASE:\n       tmpclksource = __HAL_RCC_GET_LPTIM2_SOURCE();\n       break;\n#endif /* LPTIM2 */\n     default:\n       break;\n  }\n\n  /* Save LPTIM configuration registers */\n  tmpIER = hlptim->Instance->IER;\n  tmpCFGR = hlptim->Instance->CFGR;\n  tmpCMP = hlptim->Instance->CMP;\n  tmpARR = hlptim->Instance->ARR;\n  tmpOR = hlptim->Instance->OR;\n#if defined(LPTIM_RCR_REP)\n  tmpRCR = hlptim->Instance->RCR;\n#endif\n\n  /*********** Reset LPTIM ***********/\n  switch ((uint32_t)hlptim->Instance)\n  {\n     case LPTIM1_BASE:\n       __HAL_RCC_LPTIM1_FORCE_RESET();\n       __HAL_RCC_LPTIM1_RELEASE_RESET();\n       break;\n#if defined(LPTIM2)\n     case LPTIM2_BASE:\n       __HAL_RCC_LPTIM2_FORCE_RESET();\n       __HAL_RCC_LPTIM2_RELEASE_RESET();\n       break;\n#endif /* LPTIM2 */\n     default:\n       break;\n  }\n\n  /*********** Restore LPTIM Config ***********/\n#if defined(LPTIM_RCR_REP)\n  if ((tmpCMP != 0UL) || (tmpARR != 0UL) || (tmpRCR != 0UL))\n#else\n  if ((tmpCMP != 0UL) || (tmpARR != 0UL))\n#endif\n  {\n    /* Force LPTIM source kernel clock from APB */\n    switch ((uint32_t)hlptim->Instance)\n    {\n       case LPTIM1_BASE:\n         __HAL_RCC_LPTIM1_CONFIG(RCC_LPTIM1CLKSOURCE_PCLK1);\n         break;\n#if defined(LPTIM2)\n       case LPTIM2_BASE:\n         __HAL_RCC_LPTIM2_CONFIG(RCC_LPTIM2CLKSOURCE_PCLK1);\n         break;\n#endif /* LPTIM2 */\n       default:\n         break;\n    }\n\n    if (tmpCMP != 0UL)\n    {\n      /* Restore CMP register (LPTIM should be enabled first) */\n      hlptim->Instance->CR |= LPTIM_CR_ENABLE;\n      hlptim->Instance->CMP = tmpCMP;\n\n      /* Wait for the completion of the write operation to the LPTIM_CMP register */\n      if (LPTIM_WaitForFlag(hlptim, LPTIM_FLAG_CMPOK) == HAL_TIMEOUT)\n      {\n        hlptim->State = HAL_LPTIM_STATE_TIMEOUT;\n      }\n      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_CMPOK);\n    }\n\n    if (tmpARR != 0UL)\n    {\n      /* Restore ARR register (LPTIM should be enabled first) */\n      hlptim->Instance->CR |= LPTIM_CR_ENABLE;\n      hlptim->Instance->ARR = tmpARR;\n\n      /* Wait for the completion of the write operation to the LPTIM_ARR register */\n      if (LPTIM_WaitForFlag(hlptim, LPTIM_FLAG_ARROK) == HAL_TIMEOUT)\n      {\n        hlptim->State = HAL_LPTIM_STATE_TIMEOUT;\n      }\n\n      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_ARROK);\n    }\n#if defined(LPTIM_RCR_REP)\n\n    if (tmpRCR != 0UL)\n    {\n      /* Restore RCR register (LPTIM should be enabled first) */\n      hlptim->Instance->CR |= LPTIM_CR_ENABLE;\n      hlptim->Instance->RCR = tmpRCR;\n\n      /* Wait for the completion of the write operation to the LPTIM_RCR register */\n      if (LPTIM_WaitForFlag(hlptim, LPTIM_FLAG_REPOK) == HAL_TIMEOUT)\n      {\n        hlptim->State = HAL_LPTIM_STATE_TIMEOUT;\n      }\n      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_REPOK);\n    }\n#endif\n\n    /* Restore LPTIM source kernel clock */\n    switch ((uint32_t)hlptim->Instance)\n    {\n       case LPTIM1_BASE:\n         __HAL_RCC_LPTIM1_CONFIG(tmpclksource);\n         break;\n#if defined(LPTIM2)\n       case LPTIM2_BASE:\n         __HAL_RCC_LPTIM2_CONFIG(tmpclksource);\n         break;\n#endif /* LPTIM2 */\n       default:\n         break;\n    }\n  }\n\n  /* Restore configuration registers (LPTIM should be disabled first) */\n  hlptim->Instance->CR &= ~(LPTIM_CR_ENABLE);\n  hlptim->Instance->IER = tmpIER;\n  hlptim->Instance->CFGR = tmpCFGR;\n  hlptim->Instance->OR = tmpOR;\n\n  __enable_irq();\n}", "path": "btstack/port/stm32-l451-miromico-sx1280/Drivers/STM32L4xx_HAL_Driver/Src/stm32l4xx_hal_lptim.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "bluekitchen/btstack", "stars": 1549, "license": "other", "language": "c", "size": 95905}
{"docstring": "/**\n  * @brief  Return the current Autoreload (Period) value.\n  * @param  hlptim LPTIM handle\n  * @retval Autoreload value.\n  */\n", "func_signal": "uint32_t HAL_LPTIM_ReadAutoReload(LPTIM_HandleTypeDef *hlptim)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_LPTIM_INSTANCE(hlptim->Instance));\n\n  return (hlptim->Instance->ARR);\n}", "path": "btstack/port/stm32-l451-miromico-sx1280/Drivers/STM32L4xx_HAL_Driver/Src/stm32l4xx_hal_lptim.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "bluekitchen/btstack", "stars": 1549, "license": "other", "language": "c", "size": 95905}
{"docstring": "/**\n  * @brief  Start the LPTIM PWM generation in interrupt mode.\n  * @param  hlptim LPTIM handle\n  * @param  Period Specifies the Autoreload value.\n  *         This parameter must be a value between 0x0000 and 0xFFFF\n  * @param  Pulse Specifies the compare value.\n  *         This parameter must be a value between 0x0000 and 0xFFFF\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_LPTIM_PWM_Start_IT(LPTIM_HandleTypeDef *hlptim, uint32_t Period, uint32_t Pulse)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_LPTIM_INSTANCE(hlptim->Instance));\n  assert_param(IS_LPTIM_PERIOD(Period));\n  assert_param(IS_LPTIM_PULSE(Pulse));\n\n  /* Set the LPTIM state */\n  hlptim->State = HAL_LPTIM_STATE_BUSY;\n\n  /* Reset WAVE bit to set PWM mode */\n  hlptim->Instance->CFGR &= ~LPTIM_CFGR_WAVE;\n\n  /* Enable the Peripheral */\n  __HAL_LPTIM_ENABLE(hlptim);\n\n  /* Clear flag */\n  __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_ARROK);\n\n  /* Load the period value in the autoreload register */\n  __HAL_LPTIM_AUTORELOAD_SET(hlptim, Period);\n\n  /* Wait for the completion of the write operation to the LPTIM_ARR register */\n  if (LPTIM_WaitForFlag(hlptim, LPTIM_FLAG_ARROK) == HAL_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n\n  /* Clear flag */\n  __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_CMPOK);\n\n  /* Load the pulse value in the compare register */\n  __HAL_LPTIM_COMPARE_SET(hlptim, Pulse);\n\n  /* Wait for the completion of the write operation to the LPTIM_CMP register */\n  if (LPTIM_WaitForFlag(hlptim, LPTIM_FLAG_CMPOK) == HAL_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n\n  /* Disable the Peripheral */\n  __HAL_LPTIM_DISABLE(hlptim);\n\n  if (HAL_LPTIM_GetState(hlptim) == HAL_LPTIM_STATE_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n\n  /* Enable Autoreload write complete interrupt */\n  __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_ARROK);\n\n  /* Enable Compare write complete interrupt */\n  __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_CMPOK);\n\n  /* Enable Autoreload match interrupt */\n  __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_ARRM);\n\n  /* Enable Compare match interrupt */\n  __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_CMPM);\n\n  /* If external trigger source is used, then enable external trigger interrupt */\n  if ((hlptim->Init.Trigger.Source) != LPTIM_TRIGSOURCE_SOFTWARE)\n  {\n    /* Enable external trigger interrupt */\n    __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_EXTTRIG);\n  }\n#if defined(LPTIM_RCR_REP)\n\n  /* Enable Rep Update Ok interrupt */\n  __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_REPOK);\n\n  /* Enable Update Event interrupt */\n  __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_UPDATE);\n#endif  \n\n  /* Enable the Peripheral */\n  __HAL_LPTIM_ENABLE(hlptim);\n\n  /* Start timer in continuous mode */\n  __HAL_LPTIM_START_CONTINUOUS(hlptim);\n\n  /* Change the TIM state*/\n  hlptim->State = HAL_LPTIM_STATE_READY;\n\n  /* Return function status */\n  return HAL_OK;\n}", "path": "btstack/port/stm32-l451-miromico-sx1280/Drivers/STM32L4xx_HAL_Driver/Src/stm32l4xx_hal_lptim.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "bluekitchen/btstack", "stars": 1549, "license": "other", "language": "c", "size": 95905}
{"docstring": "/**\n  * @brief  Start the LPTIM One pulse generation.\n  * @param  hlptim LPTIM handle\n  * @param  Period Specifies the Autoreload value.\n  *         This parameter must be a value between 0x0000 and 0xFFFF.\n  * @param  Pulse Specifies the compare value.\n  *         This parameter must be a value between 0x0000 and 0xFFFF.\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_LPTIM_OnePulse_Start(LPTIM_HandleTypeDef *hlptim, uint32_t Period, uint32_t Pulse)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_LPTIM_INSTANCE(hlptim->Instance));\n  assert_param(IS_LPTIM_PERIOD(Period));\n  assert_param(IS_LPTIM_PULSE(Pulse));\n\n  /* Set the LPTIM state */\n  hlptim->State = HAL_LPTIM_STATE_BUSY;\n\n  /* Reset WAVE bit to set one pulse mode */\n  hlptim->Instance->CFGR &= ~LPTIM_CFGR_WAVE;\n\n  /* Enable the Peripheral */\n  __HAL_LPTIM_ENABLE(hlptim);\n\n  /* Clear flag */\n  __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_ARROK);\n\n  /* Load the period value in the autoreload register */\n  __HAL_LPTIM_AUTORELOAD_SET(hlptim, Period);\n\n  /* Wait for the completion of the write operation to the LPTIM_ARR register */\n  if (LPTIM_WaitForFlag(hlptim, LPTIM_FLAG_ARROK) == HAL_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n\n  /* Clear flag */\n  __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_CMPOK);\n\n  /* Load the pulse value in the compare register */\n  __HAL_LPTIM_COMPARE_SET(hlptim, Pulse);\n\n  /* Wait for the completion of the write operation to the LPTIM_CMP register */\n  if (LPTIM_WaitForFlag(hlptim, LPTIM_FLAG_CMPOK) == HAL_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n\n  /* Start timer in single (one shot) mode */\n  __HAL_LPTIM_START_SINGLE(hlptim);\n\n  /* Change the TIM state*/\n  hlptim->State = HAL_LPTIM_STATE_READY;\n\n  /* Return function status */\n  return HAL_OK;\n}", "path": "btstack/port/stm32-l451-miromico-sx1280/Drivers/STM32L4xx_HAL_Driver/Src/stm32l4xx_hal_lptim.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "bluekitchen/btstack", "stars": 1549, "license": "other", "language": "c", "size": 95905}
{"docstring": "/**\n  * @brief  Stop the Encoder interface in interrupt mode.\n  * @param  hlptim LPTIM handle\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_LPTIM_Encoder_Stop_IT(LPTIM_HandleTypeDef *hlptim)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_LPTIM_ENCODER_INTERFACE_INSTANCE(hlptim->Instance));\n\n  /* Set the LPTIM state */\n  hlptim->State = HAL_LPTIM_STATE_BUSY;\n\n  /* Disable the Peripheral */\n  __HAL_LPTIM_DISABLE(hlptim);\n\n  if (HAL_LPTIM_GetState(hlptim) == HAL_LPTIM_STATE_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n\n  /* Reset ENC bit to disable the encoder interface */\n  hlptim->Instance->CFGR &= ~LPTIM_CFGR_ENC;\n\n  /* Disable \"switch to down direction\" interrupt */\n  __HAL_LPTIM_DISABLE_IT(hlptim, LPTIM_IT_DOWN);\n\n  /* Disable \"switch to up direction\" interrupt */\n  __HAL_LPTIM_DISABLE_IT(hlptim, LPTIM_IT_UP);\n\n  /* Change the TIM state*/\n  hlptim->State = HAL_LPTIM_STATE_READY;\n\n  /* Return function status */\n  return HAL_OK;\n}", "path": "btstack/port/stm32-l451-miromico-sx1280/Drivers/STM32L4xx_HAL_Driver/Src/stm32l4xx_hal_lptim.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "bluekitchen/btstack", "stars": 1549, "license": "other", "language": "c", "size": 95905}
{"docstring": "/**\n  * @brief  Stop the Timeout function.\n  * @param  hlptim LPTIM handle\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_LPTIM_TimeOut_Stop(LPTIM_HandleTypeDef *hlptim)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_LPTIM_INSTANCE(hlptim->Instance));\n\n  /* Set the LPTIM state */\n  hlptim->State = HAL_LPTIM_STATE_BUSY;\n\n  /* Disable the Peripheral */\n  __HAL_LPTIM_DISABLE(hlptim);\n\n  if (HAL_LPTIM_GetState(hlptim) == HAL_LPTIM_STATE_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n\n  /* Reset TIMOUT bit to enable the timeout function */\n  hlptim->Instance->CFGR &= ~LPTIM_CFGR_TIMOUT;\n\n  /* Change the TIM state*/\n  hlptim->State = HAL_LPTIM_STATE_READY;\n\n  /* Return function status */\n  return HAL_OK;\n}", "path": "btstack/port/stm32-l451-miromico-sx1280/Drivers/STM32L4xx_HAL_Driver/Src/stm32l4xx_hal_lptim.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "bluekitchen/btstack", "stars": 1549, "license": "other", "language": "c", "size": 95905}
{"docstring": "/**\n  * @brief  Enable a device specific interrupt in the NVIC interrupt controller.\n  * @note   To configure interrupts priority correctly, the NVIC_PriorityGroupConfig()\n  *         function should be called before. \n  * @param  IRQn External interrupt number .\n  *         This parameter can be an enumerator of  IRQn_Type enumeration\n  *         (For the complete STM32 Devices IRQ Channels list, please refer to stm32l0xx.h file)  \n  * @retval None\n  */\n", "func_signal": "void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));\n  \n  /* Enable interrupt */\n  NVIC_EnableIRQ(IRQn);\n}", "path": "btstack/port/stm32-l073rz-nucleo-em9304/Drivers/STM32L0xx_HAL_Driver/Src/stm32l0xx_hal_cortex.c", "commit_date": "2019-03-30 00:00:00", "repo_name": "bluekitchen/btstack", "stars": 1549, "license": "other", "language": "c", "size": 95905}
{"docstring": "/**\n  * @brief  Start the Counter mode in interrupt mode.\n  * @param  hlptim LPTIM handle\n  * @param  Period Specifies the Autoreload value.\n  *         This parameter must be a value between 0x0000 and 0xFFFF.\n  * @retval HAL status\n  */\n", "func_signal": "HAL_StatusTypeDef HAL_LPTIM_Counter_Start_IT(LPTIM_HandleTypeDef *hlptim, uint32_t Period)", "code": "{\n  /* Check the parameters */\n  assert_param(IS_LPTIM_INSTANCE(hlptim->Instance));\n  assert_param(IS_LPTIM_PERIOD(Period));\n\n  /* Set the LPTIM state */\n  hlptim->State = HAL_LPTIM_STATE_BUSY;\n\n  /* Enable EXTI Line interrupt on the LPTIM Wake-up Timer */\n  __HAL_LPTIM_WAKEUPTIMER_EXTI_ENABLE_IT(hlptim->Instance);\n\n  /* If clock source is not ULPTIM clock and counter source is external, then it must not be prescaled */\n  if ((hlptim->Init.Clock.Source != LPTIM_CLOCKSOURCE_ULPTIM) && (hlptim->Init.CounterSource == LPTIM_COUNTERSOURCE_EXTERNAL))\n  {\n    /* Check if clock is prescaled */\n    assert_param(IS_LPTIM_CLOCK_PRESCALERDIV1(hlptim->Init.Clock.Prescaler));\n    /* Set clock prescaler to 0 */\n    hlptim->Instance->CFGR &= ~LPTIM_CFGR_PRESC;\n  }\n\n  /* Enable the Peripheral */\n  __HAL_LPTIM_ENABLE(hlptim);\n\n  /* Clear flag */\n  __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_ARROK);\n\n  /* Load the period value in the autoreload register */\n  __HAL_LPTIM_AUTORELOAD_SET(hlptim, Period);\n\n  /* Wait for the completion of the write operation to the LPTIM_ARR register */\n  if (LPTIM_WaitForFlag(hlptim, LPTIM_FLAG_ARROK) == HAL_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n\n  /* Disable the Peripheral */\n  __HAL_LPTIM_DISABLE(hlptim);\n\n  if (HAL_LPTIM_GetState(hlptim) == HAL_LPTIM_STATE_TIMEOUT)\n  {\n    return HAL_TIMEOUT;\n  }\n\n  /* Enable Autoreload write complete interrupt */\n  __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_ARROK);\n\n  /* Enable Autoreload match interrupt */\n  __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_ARRM);\n\n#if defined(LPTIM_RCR_REP)\n  /* Enable Rep Update Ok interrupt */\n  __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_REPOK);\n\n  /* Enable Update Event interrupt */\n  __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_UPDATE);\n\n#endif\n  /* Enable the Peripheral */\n  __HAL_LPTIM_ENABLE(hlptim);\n\n  /* Start timer in continuous mode */\n  __HAL_LPTIM_START_CONTINUOUS(hlptim);\n\n  /* Change the TIM state*/\n  hlptim->State = HAL_LPTIM_STATE_READY;\n\n  /* Return function status */\n  return HAL_OK;\n}", "path": "btstack/port/stm32-l451-miromico-sx1280/Drivers/STM32L4xx_HAL_Driver/Src/stm32l4xx_hal_lptim.c", "commit_date": "2020-10-04 00:00:00", "repo_name": "bluekitchen/btstack", "stars": 1549, "license": "other", "language": "c", "size": 95905}
{"docstring": "/*\nvoid correct_yolo_boxes(detection *dets, int n, int w, int h, int netw, int neth, int relative, int letter)\n{\n    int i;\n    int new_w=0;\n    int new_h=0;\n    if (letter) {\n        if (((float)netw / w) < ((float)neth / h)) {\n            new_w = netw;\n            new_h = (h * netw) / w;\n        }\n        else {\n            new_h = neth;\n            new_w = (w * neth) / h;\n        }\n    }\n    else {\n        new_w = netw;\n        new_h = neth;\n    }\n    for (i = 0; i < n; ++i){\n        box b = dets[i].bbox;\n        b.x =  (b.x - (netw - new_w)/2./netw) / ((float)new_w/netw);\n        b.y =  (b.y - (neth - new_h)/2./neth) / ((float)new_h/neth);\n        b.w *= (float)netw/new_w;\n        b.h *= (float)neth/new_h;\n        if(!relative){\n            b.x *= w;\n            b.w *= w;\n            b.y *= h;\n            b.h *= h;\n        }\n        dets[i].bbox = b;\n    }\n}\n*/\n", "func_signal": "int yolo_num_detections(layer l, float thresh)", "code": "{\n    int i, n;\n    int count = 0;\n    for (i = 0; i < l.w*l.h; ++i){\n        for(n = 0; n < l.n; ++n){\n            int obj_index  = entry_index(l, 0, n*l.w*l.h + i, 4);\n            if(l.output[obj_index] > thresh){\n                ++count;\n            }\n        }\n    }\n    return count;\n}", "path": "MobileNet-Yolo/src/yolo_layer.c", "commit_date": "2020-06-22 00:00:00", "repo_name": "dog-qiuqiu/MobileNet-Yolo", "stars": 1675, "license": "other", "language": "c", "size": 144944}
{"docstring": "/*\nvoid avg_flipped_gaussian_yolo(layer l)\n{\n    int i,j,n,z;\n    float *flip = l.output + l.outputs;\n    for (j = 0; j < l.h; ++j) {\n        for (i = 0; i < l.w/2; ++i) {\n            for (n = 0; n < l.n; ++n) {\n                for(z = 0; z < l.classes + 8 + 1; ++z){\n                    int i1 = z*l.w*l.h*l.n + n*l.w*l.h + j*l.w + i;\n                    int i2 = z*l.w*l.h*l.n + n*l.w*l.h + j*l.w + (l.w - i - 1);\n                    float swap = flip[i1];\n                    flip[i1] = flip[i2];\n                    flip[i2] = swap;\n                    if(z == 0){\n                        flip[i1] = -flip[i1];\n                        flip[i2] = -flip[i2];\n                    }\n                }\n            }\n        }\n    }\n    for(i = 0; i < l.outputs; ++i){\n        l.output[i] = (l.output[i] + flip[i])/2.;\n    }\n}\n*/\n", "func_signal": "int get_gaussian_yolo_detections(layer l, int w, int h, int netw, int neth, float thresh, int *map, int relative, detection *dets, int letter)", "code": "{\n    int i,j,n;\n    float *predictions = l.output;\n    //if (l.batch == 2) avg_flipped_gaussian_yolo(l);\n    int count = 0;\n    for (i = 0; i < l.w*l.h; ++i){\n        int row = i / l.w;\n        int col = i % l.w;\n        for(n = 0; n < l.n; ++n){\n            int obj_index  = entry_gaussian_index(l, 0, n*l.w*l.h + i, 8);\n            float objectness = predictions[obj_index];\n            if (objectness <= thresh) continue;    // incorrect behavior for Nan values\n\n            if (objectness > thresh) {\n                int box_index = entry_gaussian_index(l, 0, n*l.w*l.h + i, 0);\n                dets[count].bbox = get_gaussian_yolo_box(predictions, l.biases, l.mask[n], box_index, col, row, l.w, l.h, netw, neth, l.w*l.h, l.yolo_point);\n                dets[count].objectness = objectness;\n                dets[count].classes = l.classes;\n\n                dets[count].uc[0] = predictions[entry_gaussian_index(l, 0, n*l.w*l.h + i, 1)]; // tx uncertainty\n                dets[count].uc[1] = predictions[entry_gaussian_index(l, 0, n*l.w*l.h + i, 3)]; // ty uncertainty\n                dets[count].uc[2] = predictions[entry_gaussian_index(l, 0, n*l.w*l.h + i, 5)]; // tw uncertainty\n                dets[count].uc[3] = predictions[entry_gaussian_index(l, 0, n*l.w*l.h + i, 7)]; // th uncertainty\n\n                dets[count].points = l.yolo_point;\n                //if (l.yolo_point != YOLO_CENTER) dets[count].objectness = objectness = 0;\n\n                for (j = 0; j < l.classes; ++j) {\n                    int class_index = entry_gaussian_index(l, 0, n*l.w*l.h + i, 9 + j);\n                    float uc_aver = (dets[count].uc[0] + dets[count].uc[1] + dets[count].uc[2] + dets[count].uc[3]) / 4.0;\n                    float prob = objectness*predictions[class_index] * (1.0 - uc_aver);\n                    dets[count].prob[j] = (prob > thresh) ? prob : 0;\n                }\n                ++count;\n            }\n        }\n    }\n    correct_gaussian_yolo_boxes(dets, count, w, h, netw, neth, relative, letter);\n    return count;\n}", "path": "MobileNet-Yolo/src/gaussian_yolo_layer.c", "commit_date": "2020-06-22 00:00:00", "repo_name": "dog-qiuqiu/MobileNet-Yolo", "stars": 1675, "license": "other", "language": "c", "size": 144944}
{"docstring": "/*\nvoid float_to_bit(float *src, unsigned char *dst, size_t size) {\n\n    size_t dst_size = size / 8 + 1;\n    memset(dst, 0, dst_size);\n    size_t i, dst_i, dst_shift;\n    for (i = 0; i < size; ++i) {\n        if (src[i] > 0) set_bit(dst, i);\n    }\n}\n*/\n", "func_signal": "void bit_to_float(unsigned char *src, float *dst, size_t size, size_t filters, float *mean_arr)", "code": "{\n    memset(dst, 0, size *sizeof(float));\n    size_t i;\n\n    for (i = 0; i < size; ++i) {\n        float mean_val = 1;\n        if(mean_arr != NULL) mean_val = fabs(mean_arr[i / (size / filters)]);\n        if(get_bit(src, i)) dst[i] = mean_val;\n        else dst[i] = -mean_val;\n    }\n}", "path": "MobileNet-Yolo/src/convolutional_layer.c", "commit_date": "2020-06-22 00:00:00", "repo_name": "dog-qiuqiu/MobileNet-Yolo", "stars": 1675, "license": "other", "language": "c", "size": 144944}
{"docstring": "/*\nvoid transfer_node(list *s, list *d, node *n)\n{\n    node *prev, *next;\n    prev = n->prev;\n    next = n->next;\n    if(prev) prev->next = next;\n    if(next) next->prev = prev;\n    --s->size;\n    if(s->front == n) s->front = next;\n    if(s->back == n) s->back = prev;\n}\n*/\n", "func_signal": "void *list_pop(list *l)", "code": "{\n    if(!l->back) return 0;\n    node *b = l->back;\n    void *val = b->val;\n    l->back = b->prev;\n    if(l->back) l->back->next = 0;\n    free(b);\n    --l->size;\n\n    return val;\n}", "path": "MobileNet-Yolo/src/list.c", "commit_date": "2020-06-22 00:00:00", "repo_name": "dog-qiuqiu/MobileNet-Yolo", "stars": 1675, "license": "other", "language": "c", "size": 144944}
{"docstring": "// simple - get pre-allocated pinned memory\n", "func_signal": "float *cuda_make_array_pinned_preallocated(float *x, size_t n)", "code": "{\n    pthread_mutex_lock(&mutex_pinned);\n    float *x_cpu = NULL;\n    const size_t memory_step = 512;// 4096;\n    const size_t size = sizeof(float)*n;\n    const size_t allocation_size = ((size / memory_step) + 1) * memory_step;\n\n    if (pinned_ptr && pinned_block_id < pinned_num_of_blocks && (allocation_size < pinned_block_size/2))\n    {\n        if ((allocation_size + pinned_index) > pinned_block_size) {\n            const float filled = (float)100 * pinned_index / pinned_block_size;\n            printf(\"\\n Pinned block_id = %d, filled = %f %% \\n\", pinned_block_id, filled);\n            pinned_block_id++;\n            pinned_index = 0;\n        }\n        if ((allocation_size + pinned_index) < pinned_block_size && pinned_block_id < pinned_num_of_blocks) {\n            x_cpu = (float *)((char *)pinned_ptr[pinned_block_id] + pinned_index);\n            pinned_index += allocation_size;\n        }\n        else {\n            //printf(\"Pre-allocated pinned memory is over! \\n\");\n        }\n    }\n\n    if(!x_cpu) {\n        if (allocation_size > pinned_block_size / 2) {\n            printf(\"Try to allocate new pinned memory, size = %d MB \\n\", size / (1024 * 1024));\n            cudaError_t status = cudaHostAlloc((void **)&x_cpu, size, cudaHostRegisterMapped);\n            if (status != cudaSuccess) fprintf(stderr, \" Can't allocate CUDA-pinned memory on CPU-RAM (pre-allocated memory is over too) \\n\");\n            CHECK_CUDA(status);\n        }\n        else {\n            printf(\"Try to allocate new pinned BLOCK, size = %d MB \\n\", size / (1024 * 1024));\n            pinned_num_of_blocks++;\n            pinned_block_id = pinned_num_of_blocks - 1;\n            pinned_index = 0;\n            pinned_ptr = (float **)realloc(pinned_ptr, pinned_num_of_blocks * sizeof(float *));\n            cudaError_t status = cudaHostAlloc((void **)&pinned_ptr[pinned_block_id], pinned_block_size, cudaHostRegisterMapped);\n            if (status != cudaSuccess) fprintf(stderr, \" Can't pre-allocate CUDA-pinned buffer on CPU-RAM \\n\");\n            CHECK_CUDA(status);\n            x_cpu = pinned_ptr[pinned_block_id];\n        }\n    }\n\n    if (x) {\n        cudaError_t status = cudaMemcpyAsync(x_cpu, x, size, cudaMemcpyDefault, get_cuda_stream());\n        CHECK_CUDA(status);\n    }\n\n    pthread_mutex_unlock(&mutex_pinned);\n    return x_cpu;\n}", "path": "MobileNet-Yolo/src/dark_cuda.c", "commit_date": "2020-06-22 00:00:00", "repo_name": "dog-qiuqiu/MobileNet-Yolo", "stars": 1675, "license": "other", "language": "c", "size": 144944}
{"docstring": "// https://github.com/Zzh-tju/DIoU-darknet\n// https://arxiv.org/abs/1911.08287\n", "func_signal": "void diounms_sort(detection *dets, int total, int classes, float thresh, NMS_KIND nms_kind, float beta1)", "code": "{\n    int i, j, k;\n    k = total - 1;\n    for (i = 0; i <= k; ++i) {\n        if (dets[i].objectness == 0) {\n            detection swap = dets[i];\n            dets[i] = dets[k];\n            dets[k] = swap;\n            --k;\n            --i;\n        }\n    }\n    total = k + 1;\n\n    for (k = 0; k < classes; ++k) {\n        for (i = 0; i < total; ++i) {\n            dets[i].sort_class = k;\n        }\n        qsort(dets, total, sizeof(detection), nms_comparator_v3);\n        for (i = 0; i < total; ++i)\n        {\n            if (dets[i].prob[k] == 0) continue;\n            box a = dets[i].bbox;\n            for (j = i + 1; j < total; ++j) {\n                box b = dets[j].bbox;\n                if (box_iou(a, b) > thresh && nms_kind == CORNERS_NMS)\n                {\n                    float sum_prob = pow(dets[i].prob[k], 2) + pow(dets[j].prob[k], 2);\n                    float alpha_prob = pow(dets[i].prob[k], 2) / sum_prob;\n                    float beta_prob = pow(dets[j].prob[k], 2) / sum_prob;\n                    //dets[i].bbox.x = (dets[i].bbox.x*alpha_prob + dets[j].bbox.x*beta_prob);\n                    //dets[i].bbox.y = (dets[i].bbox.y*alpha_prob + dets[j].bbox.y*beta_prob);\n                    //dets[i].bbox.w = (dets[i].bbox.w*alpha_prob + dets[j].bbox.w*beta_prob);\n                    //dets[i].bbox.h = (dets[i].bbox.h*alpha_prob + dets[j].bbox.h*beta_prob);\n                    /*\n                    if (dets[j].points == YOLO_CENTER && (dets[i].points & dets[j].points) == 0) {\n                        dets[i].bbox.x = (dets[i].bbox.x*alpha_prob + dets[j].bbox.x*beta_prob);\n                        dets[i].bbox.y = (dets[i].bbox.y*alpha_prob + dets[j].bbox.y*beta_prob);\n                    }\n                    else if ((dets[i].points & dets[j].points) == 0) {\n                        dets[i].bbox.w = (dets[i].bbox.w*alpha_prob + dets[j].bbox.w*beta_prob);\n                        dets[i].bbox.h = (dets[i].bbox.h*alpha_prob + dets[j].bbox.h*beta_prob);\n                    }\n                    dets[i].points |= dets[j].points;\n                    */\n                    dets[j].prob[k] = 0;\n                }\n                else if (box_iou(a, b) > thresh && nms_kind == GREEDY_NMS) {\n                    dets[j].prob[k] = 0;\n                }\n                else {\n                    if (box_diounms(a, b, beta1) > thresh && nms_kind == DIOU_NMS) {\n                        dets[j].prob[k] = 0;\n                    }\n                }\n            }\n\n            //if ((nms_kind == CORNERS_NMS) && (dets[i].points != (YOLO_CENTER | YOLO_LEFT_TOP | YOLO_RIGHT_BOTTOM)))\n            //    dets[i].prob[k] = 0;\n        }\n    }\n}", "path": "MobileNet-Yolo/src/box.c", "commit_date": "2020-06-22 00:00:00", "repo_name": "dog-qiuqiu/MobileNet-Yolo", "stars": 1675, "license": "other", "language": "c", "size": 144944}
{"docstring": "// custom CPU-pinned memory allocation\n", "func_signal": "void pre_allocate_pinned_memory(const size_t size)", "code": "{\n    const size_t num_of_blocks = size / pinned_block_size + ((size % pinned_block_size) ? 1 : 0);\n    printf(\"pre_allocate... pinned_ptr = %p \\n\", pinned_ptr);\n\n    pthread_mutex_lock(&mutex_pinned);\n    if (!pinned_ptr) {\n        pinned_ptr = (float **)calloc(num_of_blocks, sizeof(float *));\n        if(!pinned_ptr) error(\"calloc failed in pre_allocate() \\n\");\n\n        printf(\"pre_allocate: size = %Iu MB, num_of_blocks = %Iu, block_size = %Iu MB \\n\",\n            size / (1024*1024), num_of_blocks, pinned_block_size / (1024 * 1024));\n\n        int k;\n        for (k = 0; k < num_of_blocks; ++k) {\n            cudaError_t status = cudaHostAlloc((void **)&pinned_ptr[k], pinned_block_size, cudaHostRegisterMapped);\n            if (status != cudaSuccess) fprintf(stderr, \" Can't pre-allocate CUDA-pinned buffer on CPU-RAM \\n\");\n            CHECK_CUDA(status);\n            if (!pinned_ptr[k]) error(\"cudaHostAlloc failed\\n\");\n            else {\n                printf(\" Allocated %d pinned block \\n\", pinned_block_size);\n            }\n        }\n        pinned_num_of_blocks = num_of_blocks;\n    }\n    pthread_mutex_unlock(&mutex_pinned);\n}", "path": "MobileNet-Yolo/src/dark_cuda.c", "commit_date": "2020-06-22 00:00:00", "repo_name": "dog-qiuqiu/MobileNet-Yolo", "stars": 1675, "license": "other", "language": "c", "size": 144944}
{"docstring": "// https://github.com/Zzh-tju/DIoU-darknet\n// https://arxiv.org/abs/1911.08287\n", "func_signal": "float box_diou(box a, box b)", "code": "{\n    boxabs ba = box_c(a, b);\n    float w = ba.right - ba.left;\n    float h = ba.bot - ba.top;\n    float c = w * w + h * h;\n    float iou = box_iou(a, b);\n    if (c == 0) {\n        return iou;\n    }\n    float d = (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n    float u = pow(d / c, 0.6);\n    float diou_term = u;\n#ifdef DEBUG_PRINTS\n    printf(\"  c: %f, u: %f, riou_term: %f\\n\", c, u, diou_term);\n#endif\n    return iou - diou_term;\n}", "path": "MobileNet-Yolo/src/box.c", "commit_date": "2020-06-22 00:00:00", "repo_name": "dog-qiuqiu/MobileNet-Yolo", "stars": 1675, "license": "other", "language": "c", "size": 144944}
{"docstring": "/*\nchar **get_random_paths_indexes(char **paths, int n, int m, int *indexes)\n{\n    char **random_paths = calloc(n, sizeof(char*));\n    int i;\n    pthread_mutex_lock(&mutex);\n    for(i = 0; i < n; ++i){\n        int index = random_gen()%m;\n        indexes[i] = index;\n        random_paths[i] = paths[index];\n        if(i == 0) printf(\"%s\\n\", paths[index]);\n    }\n    pthread_mutex_unlock(&mutex);\n    return random_paths;\n}\n*/\n", "func_signal": "char **get_sequential_paths(char **paths, int n, int m, int mini_batch, int augment_speed)", "code": "{\n    int speed = rand_int(1, augment_speed);\n    if (speed < 1) speed = 1;\n    char** sequentia_paths = (char**)xcalloc(n, sizeof(char*));\n    int i;\n    pthread_mutex_lock(&mutex);\n    //printf(\"n = %d, mini_batch = %d \\n\", n, mini_batch);\n    unsigned int *start_time_indexes = (unsigned int *)xcalloc(mini_batch, sizeof(unsigned int));\n    for (i = 0; i < mini_batch; ++i) {\n        start_time_indexes[i] = random_gen() % m;\n        //printf(\" start_time_indexes[i] = %u, \", start_time_indexes[i]);\n    }\n\n    for (i = 0; i < n; ++i) {\n        do {\n            int time_line_index = i % mini_batch;\n            unsigned int index = start_time_indexes[time_line_index] % m;\n            start_time_indexes[time_line_index] += speed;\n\n            //int index = random_gen() % m;\n            sequentia_paths[i] = paths[index];\n            //if(i == 0) printf(\"%s\\n\", paths[index]);\n            //printf(\" index = %u - grp: %s \\n\", index, paths[index]);\n            if (strlen(sequentia_paths[i]) <= 4) printf(\" Very small path to the image: %s \\n\", sequentia_paths[i]);\n        } while (strlen(sequentia_paths[i]) == 0);\n    }\n    free(start_time_indexes);\n    pthread_mutex_unlock(&mutex);\n    return sequentia_paths;\n}", "path": "MobileNet-Yolo/src/data.c", "commit_date": "2020-06-22 00:00:00", "repo_name": "dog-qiuqiu/MobileNet-Yolo", "stars": 1675, "license": "other", "language": "c", "size": 144944}
{"docstring": "// Marsaglia's xorshf96 generator: period 2^96-1\n", "func_signal": "unsigned int random_gen_fast(void)", "code": "{\n    unsigned int t;\n    x ^= x << 16;\n    x ^= x >> 5;\n    x ^= x << 1;\n\n    t = x;\n    x = y;\n    y = z;\n    z = t ^ x ^ y;\n\n    return z;\n}", "path": "MobileNet-Yolo/src/utils.c", "commit_date": "2020-06-22 00:00:00", "repo_name": "dog-qiuqiu/MobileNet-Yolo", "stars": 1675, "license": "other", "language": "c", "size": 144944}
{"docstring": "// https://github.com/Zzh-tju/DIoU-darknet\n// https://arxiv.org/abs/1911.08287\n", "func_signal": "float box_ciou(box a, box b)", "code": "{\n    boxabs ba = box_c(a, b);\n    float w = ba.right - ba.left;\n    float h = ba.bot - ba.top;\n    float c = w * w + h * h;\n    float iou = box_iou(a, b);\n    if (c == 0) {\n        return iou;\n    }\n    float u = (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n    float d = u / c;\n    float ar_gt = b.w / b.h;\n    float ar_pred = a.w / a.h;\n    float ar_loss = 4 / (M_PI * M_PI) * (atan(ar_gt) - atan(ar_pred)) * (atan(ar_gt) - atan(ar_pred));\n    float alpha = ar_loss / (1 - iou + ar_loss + 0.000001);\n    float ciou_term = d + alpha * ar_loss;                   //ciou\n#ifdef DEBUG_PRINTS\n    printf(\"  c: %f, u: %f, riou_term: %f\\n\", c, u, ciou_term);\n#endif\n    return iou - ciou_term;\n}", "path": "MobileNet-Yolo/src/box.c", "commit_date": "2020-06-22 00:00:00", "repo_name": "dog-qiuqiu/MobileNet-Yolo", "stars": 1675, "license": "other", "language": "c", "size": 144944}
{"docstring": "// free CPU-pinned memory\n", "func_signal": "void free_pinned_memory()", "code": "{\n    if (pinned_ptr) {\n        int k;\n        for (k = 0; k < pinned_num_of_blocks; ++k) {\n            cuda_free_host(pinned_ptr[k]);\n        }\n        free(pinned_ptr);\n        pinned_ptr = NULL;\n    }\n}", "path": "MobileNet-Yolo/src/dark_cuda.c", "commit_date": "2020-06-22 00:00:00", "repo_name": "dog-qiuqiu/MobileNet-Yolo", "stars": 1675, "license": "other", "language": "c", "size": 144944}
{"docstring": "// where c is the smallest box that fully encompases a and b\n", "func_signal": "boxabs box_c(box a, box b)", "code": "{\n    boxabs ba = { 0 };\n    ba.top = fmin(a.y - a.h / 2, b.y - b.h / 2);\n    ba.bot = fmax(a.y + a.h / 2, b.y + b.h / 2);\n    ba.left = fmin(a.x - a.w / 2, b.x - b.w / 2);\n    ba.right = fmax(a.x + a.w / 2, b.x + b.w / 2);\n    return ba;\n}", "path": "MobileNet-Yolo/src/box.c", "commit_date": "2020-06-22 00:00:00", "repo_name": "dog-qiuqiu/MobileNet-Yolo", "stars": 1675, "license": "other", "language": "c", "size": 144944}
{"docstring": "// Absolute box from relative coordinate bounding box and image size\n", "func_signal": "boxabs box_to_boxabs(const box* b, const int img_w, const int img_h, const int bounds_check)", "code": "{\n    boxabs ba;\n    ba.left = (b->x - b->w / 2.)*img_w;\n    ba.right = (b->x + b->w / 2.)*img_w;\n    ba.top = (b->y - b->h / 2.)*img_h;\n    ba.bot = (b->y + b->h / 2.)*img_h;\n\n    if (bounds_check) {\n        if (ba.left < 0) ba.left = 0;\n        if (ba.right > img_w - 1) ba.right = img_w - 1;\n        if (ba.top < 0) ba.top = 0;\n        if (ba.bot > img_h - 1) ba.bot = img_h - 1;\n    }\n\n    return ba;\n}", "path": "MobileNet-Yolo/src/utils.c", "commit_date": "2020-06-22 00:00:00", "repo_name": "dog-qiuqiu/MobileNet-Yolo", "stars": 1675, "license": "other", "language": "c", "size": 144944}
{"docstring": "// binary transpose\n", "func_signal": "size_t binary_transpose_align_input(int k, int n, float *b, char **t_bit_input, size_t ldb_align, int bit_align)", "code": "{\n    size_t new_ldb = k + (ldb_align - k%ldb_align); // (k / 8 + 1) * 8;\n    //printf(\"\\n n = %d, bit_align = %d \\n\", n, bit_align);\n    size_t t_intput_size = new_ldb * bit_align;// n;\n    size_t t_bit_input_size = t_intput_size / 8;// +1;\n\n    memset(*t_bit_input, 0, t_bit_input_size * sizeof(char));\n    //int src_size = k * bit_align;\n\n    // b - [bit_align, k] - [l.bit_align, l.size*l.size*l.c] = src_size\n    // t_input - [bit_align, k] - [n', k]\n    // t_bit_input - [new_ldb, n] - [k', n]\n\n    //transpose_bin(t_input, *t_bit_input, k, n, bit_align, new_ldb, 8);\n    transpose_bin((uint32_t*)b, (uint32_t*)*t_bit_input, k, n, bit_align, new_ldb, 8);\n\n    return t_intput_size;\n}", "path": "MobileNet-Yolo/src/convolutional_layer.c", "commit_date": "2020-06-22 00:00:00", "repo_name": "dog-qiuqiu/MobileNet-Yolo", "stars": 1675, "license": "other", "language": "c", "size": 144944}
{"docstring": "// OPENCV\n", "func_signal": "void blend_images(image new_img, float alpha, image old_img, float beta)", "code": "{\n    int data_size = new_img.w * new_img.h * new_img.c;\n    int i;\n    #pragma omp parallel for\n    for (i = 0; i < data_size; ++i)\n        new_img.data[i] = new_img.data[i] * alpha + old_img.data[i] * beta;\n}", "path": "MobileNet-Yolo/src/data.c", "commit_date": "2020-06-22 00:00:00", "repo_name": "dog-qiuqiu/MobileNet-Yolo", "stars": 1675, "license": "other", "language": "c", "size": 144944}
{"docstring": "// From http://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform\n", "func_signal": "float rand_normal()", "code": "{\n    static int haveSpare = 0;\n    static double rand1, rand2;\n\n    if(haveSpare)\n    {\n        haveSpare = 0;\n        return sqrt(rand1) * sin(rand2);\n    }\n\n    haveSpare = 1;\n\n    rand1 = random_gen() / ((double) RAND_MAX);\n    if(rand1 < 1e-100) rand1 = 1e-100;\n    rand1 = -2 * log(rand1);\n    rand2 = (random_gen() / ((double)RAND_MAX)) * 2.0 * M_PI;\n\n    return sqrt(rand1) * cos(rand2);\n}", "path": "MobileNet-Yolo/src/utils.c", "commit_date": "2020-06-22 00:00:00", "repo_name": "dog-qiuqiu/MobileNet-Yolo", "stars": 1675, "license": "other", "language": "c", "size": 144944}
{"docstring": "// indicies to skip is a bit array\n", "func_signal": "float mag_array_skip(float *a, int n, int * indices_to_skip)", "code": "{\n    int i;\n    float sum = 0;\n    for (i = 0; i < n; ++i) {\n        if (indices_to_skip[i] != 1) {\n            sum += a[i] * a[i];\n        }\n    }\n    return sqrt(sum);\n}", "path": "MobileNet-Yolo/src/utils.c", "commit_date": "2020-06-22 00:00:00", "repo_name": "dog-qiuqiu/MobileNet-Yolo", "stars": 1675, "license": "other", "language": "c", "size": 144944}
{"docstring": "// Converts output of the network to detection boxes\n// w,h: image width,height\n// netw,neth: network width,height\n// relative: 1 (all callers seems to pass TRUE)\n", "func_signal": "void correct_yolo_boxes(detection *dets, int n, int w, int h, int netw, int neth, int relative, int letter)", "code": "{\n    int i;\n    // network height (or width)\n    int new_w = 0;\n    // network height (or width)\n    int new_h = 0;\n    // Compute scale given image w,h vs network w,h\n    // I think this \"rotates\" the image to match network to input image w/h ratio\n    // new_h and new_w are really just network width and height\n    if (letter) {\n        if (((float)netw / w) < ((float)neth / h)) {\n            new_w = netw;\n            new_h = (h * netw) / w;\n        }\n        else {\n            new_h = neth;\n            new_w = (w * neth) / h;\n        }\n    }\n    else {\n        new_w = netw;\n        new_h = neth;\n    }\n    // difference between network width and \"rotated\" width\n    float deltaw = netw - new_w;\n    // difference between network height and \"rotated\" height\n    float deltah = neth - new_h;\n    // ratio between rotated network width and network width\n    float ratiow = (float)new_w / netw;\n    // ratio between rotated network width and network width\n    float ratioh = (float)new_h / neth;\n    for (i = 0; i < n; ++i) {\n\n        box b = dets[i].bbox;\n        // x = ( x - (deltaw/2)/netw ) / ratiow;\n        //   x - [(1/2 the difference of the network width and rotated width) / (network width)]\n        b.x = (b.x - deltaw / 2. / netw) / ratiow;\n        b.y = (b.y - deltah / 2. / neth) / ratioh;\n        // scale to match rotation of incoming image\n        b.w *= 1 / ratiow;\n        b.h *= 1 / ratioh;\n\n        // relative seems to always be == 1, I don't think we hit this condition, ever.\n        if (!relative) {\n            b.x *= w;\n            b.w *= w;\n            b.y *= h;\n            b.h *= h;\n        }\n\n        dets[i].bbox = b;\n    }\n}", "path": "MobileNet-Yolo/src/yolo_layer.c", "commit_date": "2020-06-22 00:00:00", "repo_name": "dog-qiuqiu/MobileNet-Yolo", "stars": 1675, "license": "other", "language": "c", "size": 144944}
{"docstring": "// OPENCV\n", "func_signal": "void *load_thread(void *ptr)", "code": "{\n    //srand(time(0));\n    //printf(\"Loading data: %d\\n\", random_gen());\n    load_args a = *(struct load_args*)ptr;\n    if(a.exposure == 0) a.exposure = 1;\n    if(a.saturation == 0) a.saturation = 1;\n    if(a.aspect == 0) a.aspect = 1;\n\n    if (a.type == OLD_CLASSIFICATION_DATA){\n        *a.d = load_data_old(a.paths, a.n, a.m, a.labels, a.classes, a.w, a.h);\n    } else if (a.type == CLASSIFICATION_DATA){\n        *a.d = load_data_augment(a.paths, a.n, a.m, a.labels, a.classes, a.hierarchy, a.flip, a.min, a.max, a.w, a.h, a.angle, a.aspect, a.hue, a.saturation, a.exposure, a.mixup, a.blur, a.show_imgs, a.label_smooth_eps, a.dontuse_opencv);\n    } else if (a.type == SUPER_DATA){\n        *a.d = load_data_super(a.paths, a.n, a.m, a.w, a.h, a.scale);\n    } else if (a.type == WRITING_DATA){\n        *a.d = load_data_writing(a.paths, a.n, a.m, a.w, a.h, a.out_w, a.out_h);\n    } else if (a.type == REGION_DATA){\n        *a.d = load_data_region(a.n, a.paths, a.m, a.w, a.h, a.num_boxes, a.classes, a.jitter, a.hue, a.saturation, a.exposure);\n    } else if (a.type == DETECTION_DATA){\n        *a.d = load_data_detection(a.n, a.paths, a.m, a.w, a.h, a.c, a.num_boxes, a.classes, a.flip, a.gaussian_noise, a.blur, a.mixup, a.jitter,\n            a.hue, a.saturation, a.exposure, a.mini_batch, a.track, a.augment_speed, a.letter_box, a.show_imgs);\n    } else if (a.type == SWAG_DATA){\n        *a.d = load_data_swag(a.paths, a.n, a.classes, a.jitter);\n    } else if (a.type == COMPARE_DATA){\n        *a.d = load_data_compare(a.n, a.paths, a.m, a.classes, a.w, a.h);\n    } else if (a.type == IMAGE_DATA){\n        *(a.im) = load_image(a.path, 0, 0, a.c);\n        *(a.resized) = resize_image(*(a.im), a.w, a.h);\n    }else if (a.type == LETTERBOX_DATA) {\n        *(a.im) = load_image(a.path, 0, 0, a.c);\n        *(a.resized) = letterbox_image(*(a.im), a.w, a.h);\n    } else if (a.type == TAG_DATA){\n        *a.d = load_data_tag(a.paths, a.n, a.m, a.classes, a.flip, a.min, a.max, a.w, a.h, a.angle, a.aspect, a.hue, a.saturation, a.exposure);\n    }\n    free(ptr);\n    return 0;\n}", "path": "MobileNet-Yolo/src/data.c", "commit_date": "2020-06-22 00:00:00", "repo_name": "dog-qiuqiu/MobileNet-Yolo", "stars": 1675, "license": "other", "language": "c", "size": 144944}
{"docstring": "/**********************************************************************/\n/*   Fix instructions which do %RIP relative addressing, such as MOV  */\n/*   or  JMP,  since  our  instruction  trap  buffer is in the wrong  */\n/*   place.\t\t\t\t\t\t\t      */\n/**********************************************************************/\n", "func_signal": "static void\ncpu_fix_rel(cpu_core_t *this_cpu, cpu_trap_t *tp, unsigned char *orig_pc)", "code": "{\n#if defined(__amd64)\n\tunsigned char *pc = tp->ct_instr_buf;\n\tint\tmodrm = tp->ct_tinfo.t_modrm;\n\n\tif (modrm >= 0 && (pc[modrm] & 0xc7) == 0x05) {\n//dtrace_printf(\"pc:%p modrm=%d\\n\", orig_pc, modrm);\n\t\t/***********************************************/\n\t\t/*   We got one. A common idiom, e.g.\t       */\n\t\t/*   \t\t\t\t\t       */\n\t\t/*   48 8b 05 00 00 00 00 mov 0x0(%rip),%rax   */\n\t\t/*   \t\t\t\t\t       */\n\t\t/*   Now,  we  need  to  adjust  the relative  */\n\t\t/*   addressing   based  on  our  instruction  */\n\t\t/*   cache  buffer,  vs the original location  */\n\t\t/*   of the instruction.\t\t       */\n\t\t/***********************************************/\n\n\t\t/***********************************************/\n\t\t/*   We  have  some  complications  here. The  */\n\t\t/*   nn(%rip)  offset might be 16 or 32 bits,  */\n\t\t/*   but  we  might  be  too  far away in our  */\n\t\t/*   buffer to handle the displacement, so we  */\n\t\t/*   will  need to map the instruction to use  */\n\t\t/*   a long offset.\t\t\t       */\n\t\t/***********************************************/\n\t\tunsigned char *target;\n\t\tu32 new_target;\n\n//printk(\"%p disp=%p\\n\", orig_pc, *(u32 *) (pc + modrm+1));\n\t\ttarget = orig_pc + tp->ct_tinfo.t_inslen\n\t\t\t\t+ *(s32 *) (&pc[modrm + 1]);\n\t\tnew_target = target - (pc + tp->ct_tinfo.t_inslen);\n\n//dtrace_printf(\"%p:%p modrm=%d %02x %02x %02x %02x %02x disp=%p ndisp=%p\\n\", orig_pc, pc, modrm, pc[0], pc[1], pc[2], pc[4], pc[5], target, new_target);\n\t\t*(u32 *) (pc + modrm + 1) = (u32) new_target;\n\t}\n#endif\n\n}", "path": "linux/driver/cpu_x86.c", "commit_date": "2013-02-11 00:00:00", "repo_name": "dtrace4linux/linux", "stars": 1156, "license": "None", "language": "c", "size": 8259}
{"docstring": "/*ARGSUSED*/\n", "func_signal": "static void\ndt_dis_cmp(const dtrace_difo_t *dp, const char *name, dif_instr_t in, FILE *fp)", "code": "{\n\t(void) fprintf(fp, \"%-4s %%r%u, %%r%u\", name,\n\t    DIF_INSTR_R1(in), DIF_INSTR_R2(in));\n}", "path": "linux/libdtrace/dt_dis.c", "commit_date": "2012-02-08 00:00:00", "repo_name": "dtrace4linux/linux", "stars": 1156, "license": "None", "language": "c", "size": 8259}
{"docstring": "/**********************************************************************/\n/*   Code to implement /proc/dtrace/idt.\t\t\t      */\n/**********************************************************************/\n", "func_signal": "static void *gdt_seq_start(struct seq_file *seq, loff_t *pos)", "code": "{\n\tif (*pos > GDT_ENTRIES)\n\t\treturn 0;\n\treturn (void *) (long) (*pos + 1);\n}", "path": "linux/driver/intr.c", "commit_date": "2016-01-11 00:00:00", "repo_name": "dtrace4linux/linux", "stars": 1156, "license": "None", "language": "c", "size": 8259}
{"docstring": "/*ARGSUSED*/\n", "func_signal": "static void\ndt_dis_log(const dtrace_difo_t *dp, const char *name, dif_instr_t in, FILE *fp)", "code": "{\n\t(void) fprintf(fp, \"%-4s %%r%u, %%r%u, %%r%u\", name,\n\t    DIF_INSTR_R1(in), DIF_INSTR_R2(in), DIF_INSTR_RD(in));\n}", "path": "linux/libdtrace/dt_dis.c", "commit_date": "2012-02-08 00:00:00", "repo_name": "dtrace4linux/linux", "stars": 1156, "license": "None", "language": "c", "size": 8259}
{"docstring": "/**********************************************************************/\n/*   Interrupt  handler  for a double fault. (We may not enable this  */\n/*   if we dont see a need).\t\t\t\t\t      */\n/**********************************************************************/\n", "func_signal": "int \ndtrace_double_fault_handler(int type, struct pt_regs *regs)", "code": "{\nstatic int cnt;\n\ndtrace_printf(\"double-fault[%lu]: CPU:%d PC:%p\\n\", cnt++, smp_processor_id(), (void *) regs->r_pc-1);\n\treturn NOTIFY_KERNEL;\n}", "path": "linux/driver/intr.c", "commit_date": "2016-01-11 00:00:00", "repo_name": "dtrace4linux/linux", "stars": 1156, "license": "None", "language": "c", "size": 8259}
{"docstring": "/**********************************************************************/\n/*   After  a single step trap, we need to readjust the PC and maybe  */\n/*   other things, so handle the exceptions here.\t\t      */\n/**********************************************************************/\n", "func_signal": "int\ncpu_adjust(cpu_core_t *this_cpu, cpu_trap_t *tp, struct pt_regs *regs)", "code": "{\tuchar_t *pc = tp->ct_instr_buf;\n\tgreg_t *sp;\n\n\tpc = cpu_skip_prefix(pc);\n\n/* Just some debug to watch flag changes...\n\tif ((regs->r_rfl & X86_EFLAGS_IF) != (tp->ct_eflags & X86_EFLAGS_IF)) {\nprintk(\"flag change: %p: %02x : %02x %02x %02x %lx %lx\\n\",\ntp->ct_orig_pc0, tp->ct_orig_pc0[0], *pc, \ntp->ct_orig_pc0[1], tp->ct_orig_pc0[2], regs->r_rfl, tp->ct_eflags);\n\t}\n*/\n\n\t/***********************************************/\n\t/*   For  some  instructions,  we  need to be  */\n\t/*   careful of the IF/TF flags. So, do these  */\n\t/*   first.\t\t\t\t       */\n\t/***********************************************/\n\tswitch (*pc) {\n\t  case 0x9c: // pushfl\n\t  \t/***********************************************/\n\t  \t/*   If  we push flags, we have two copies on  */\n\t  \t/*   the stack - the one for the instruction,  */\n\t  \t/*   and the one for pt_regs we pushed on the  */\n\t  \t/*   stack  as  part  of  the  trap  handler.  */\n\t  \t/*   Update  the  invokers  flags, since ours  */\n\t  \t/*   are useless at this point (or, that they  */\n\t  \t/*   need to agree).\t\t\t       */\n\t\t/*   We  just  pushed  the  flags,  but those  */\n\t\t/*   flags  would  contain the TF bit set, so  */\n\t\t/*   we  must turn that off. Also, dont touch  */\n\t\t/*   the  IF bit - that stays as whatever the  */\n\t\t/*   original  code  had it. If we attempt to  */\n\t\t/*   execute the switch-statement below, then  */\n\t\t/*   we  would  turn  off  IF,  and  hit  the  */\n\t\t/*   infamous    \"BUG_ON/WARN_ONCE\"    errors  */\n\t\t/*   complaining  that  a  caller  may  sleep  */\n\t\t/*   because interrupts are disabled.\t       */\n\t  \t/***********************************************/\n\t\t{greg_t *fl = (greg_t *) regs->r_sp;\n\t\tregs->r_rfl &= ~X86_EFLAGS_TF;\n\t\t/***********************************************/\n\t\t/*   Put back the original flags at the point  */\n\t\t/*   we were going to breakpoint.\t       */\n\t\t/***********************************************/\n\t\t*fl = tp->ct_eflags;\n\t\tregs->r_pc = (greg_t) tp->ct_orig_pc;\n\t  \treturn FALSE;\n\t\t}\n\n\t  case 0x9d: // popf\n\t  \t/***********************************************/\n\t  \t/*   Very  rare  - a \"subroutine\" starting by  */\n\t  \t/*   popping   the  flags.  e.g.  \"not_same\".  */\n\t  \t/*   Really  limited  to  just assembler/trap  */\n\t  \t/*   handler   code.  Believe  whatever  this  */\n\t  \t/*   instruction has done to the flags.\t       */\n\t  \t/***********************************************/\n\t\tregs->r_pc = (greg_t) tp->ct_orig_pc;\n\t\treturn FALSE;\n\n\t  case 0xcf: { //iret\n//\t  \tgreg_t *flp = (greg_t *) (&regs->r_rfl + 3 * sizeof(greg_t));\n//dtrace_printf(\"iret rfl=%p\\n\", regs->r_rfl);\n\t\tregs->r_rfl = (regs->r_rfl & ~(X86_EFLAGS_TF));\n//\t\t*flp = (*flp & ~X86_EFLAGS_IF) | X86_EFLAGS_TF;\n\t  \treturn FALSE;\n\t\t}\n\t  }\n\n\t/***********************************************/\n\t/*   Put  back  the  IF  flag  the way it was  */\n\t/*   before  we turned off interrupts for the  */\n\t/*   single  step. Also, turn off the TF flag  */\n\t/*   because  we  will  have  finished single  */\n\t/*   stepping.\t\t\t\t       */\n\t/***********************************************/\n\tregs->r_rfl = (regs->r_rfl & ~(X86_EFLAGS_TF|X86_EFLAGS_IF)) | \n\t\t(tp->ct_eflags & (X86_EFLAGS_IF));\n\n#define\tSEE_ABOVE(opcode, text)\n#define\tSEE_BELOW(opcode, text)\n\n\tswitch (*pc) {\n\t  case 0x70: case 0x71: case 0x72: case 0x73:\n\t  case 0x74: case 0x75: case 0x76: case 0x77:\n\t  case 0x78: case 0x79: case 0x7a: case 0x7b:\n\t  case 0x7c: case 0x7d: case 0x7e: case 0x7f:\n\t  \t/***********************************************/\n\t  \t/*   These can happen for instr provider.      */\n\t\t/*   If  the  instruction  pointer  isnt  the  */\n\t\t/*   'next'  instruction  then  a  branch was  */\n\t\t/*   taken,   so   handle   the   destination  */\n\t\t/*   relative jump.\t\t\t       */\n\t  \t/***********************************************/\n\t\tif ((uchar_t *) regs->r_pc != tp->ct_instr_buf + 2)\n\t\t\tregs->r_pc = (greg_t) tp->ct_orig_pc + (char) tp->ct_instr_buf[1];\n\t\telse\n\t\t\tregs->r_pc = (greg_t) tp->ct_orig_pc;\n\t\tbreak;\n\n\t  SEE_ABOVE(0x9c, pushfl)\n\n\t  case 0xc2: //ret imm16\n\t  case 0xc3: //ret\n\t  case 0xca: //lret nn\n\t  case 0xcb: //lret\n\t  case 0xcd: //int $n -- hope we dont do this in kernel space.\n\t  case 0xce: //into -- hope we dont do this in kernel space.\n\t  \tbreak;\n\n\t  SEE_ABOVE(0x9c, iret);\n\n\t  case 0xe0: // LOOP rel8 - jump if count != 0\n\t\tregs->r_pc = (greg_t) tp->ct_orig_pc;\n\t  \tif (regs->r_rcx) {\n\t\t\tregs->r_pc += (char) pc[1];\n\t\t\treturn FALSE;\n\t\t}\n\t\tregs->r_rfl |= X86_EFLAGS_TF;\n\t\treturn TRUE;\n\t  case 0xe1: // LOOPZ rel8 - jump if count != 0 AND ZF=1\n\t\tregs->r_pc = (greg_t) tp->ct_orig_pc;\n\t  \tif (regs->r_rcx && regs->r_rfl & X86_EFLAGS_ZF) {\n\t\t\tregs->r_pc += (char) pc[1];\n\t\t\treturn FALSE;\n\t\t}\n\t\tregs->r_rfl |= X86_EFLAGS_TF;\n\t\treturn TRUE;\n\t  case 0xe2: // LOOPZ rel8 - jump if count != 0 AND ZF=0\n\t\tregs->r_pc = (greg_t) tp->ct_orig_pc;\n\t  \tif (regs->r_rcx && !(regs->r_rfl & X86_EFLAGS_ZF)) {\n\t\t\tregs->r_pc += (char) pc[1];\n\t\t\treturn FALSE;\n\t\t}\n\t\tregs->r_rfl |= X86_EFLAGS_TF;\n\t\treturn TRUE;\n\t  case 0xe3: // JRCXZ rel8 - jump if RCX == 0\n\t\tregs->r_pc = (greg_t) tp->ct_orig_pc;\n\t  \tif (regs->r_rcx == 0) {\n\t\t\tregs->r_pc += (char) pc[1];\n\t\t\treturn FALSE;\n\t\t}\n\t\tregs->r_rfl |= X86_EFLAGS_TF;\n\t\treturn TRUE;\n\n\t  SEE_BELOW(0xe4, in);\n\t  SEE_BELOW(0xe5, in);\n\t  SEE_BELOW(0xe6, out);\n\t  SEE_BELOW(0xe7, out);\n\n\t  case 0xe8: // CALLR nn32 call relative\n\t\tsp = (greg_t *) stack_ptr(regs);\n\t\tsp[0] = (greg_t) tp->ct_orig_pc;\n\n\t\tregs->r_pc = (long) tp->ct_orig_pc + \n\t\t\t*(s32 *) (tp->ct_orig_pc - 4);\n//printk(\"PC now %p\\n\", regs->r_pc);\n\t\tbreak;\n\n\t  case 0xe9: // 0xe9 nn32 jmp relative\n\t\tregs->r_pc = (greg_t) tp->ct_orig_pc +\n\t\t\t*(s32 *) (tp->ct_instr_buf + 1);\n\t  \tbreak;\n\t  case 0xea: // 0xea jmp abs\n\t  \tbreak;\n\t  case 0xeb: // 0xeb nn jmp relative\n\t\tregs->r_pc = (greg_t) tp->ct_orig_pc +\n\t\t\t*(char *) (tp->ct_instr_buf + 1);\n\t  \tbreak;\n\n\t  case 0xf2: // REPZ -- need to keep going\n\t  \tif ((regs->r_rfl & X86_EFLAGS_ZF) == 0 && regs->r_rcx) {\n\t\t\tregs->r_pc = (greg_t) tp->ct_instr_buf;\n\t\t\tregs->r_rfl |= X86_EFLAGS_TF;\n\t\t\treturn TRUE;\n\t\t} else {\n\t\t\tregs->r_pc = (greg_t) tp->ct_orig_pc;\n\t\t}\n\t  \tbreak;\n\n\t  case 0xf3: // REPNZ -- need to keep going\n\t  \tif (regs->r_rfl & X86_EFLAGS_ZF && regs->r_rcx) {\n\t\t\tregs->r_pc = (greg_t) tp->ct_instr_buf;\n\t\t\tregs->r_rfl |= X86_EFLAGS_TF;\n\t\t\treturn TRUE;\n\t\t} else {\n\t\t\tregs->r_pc = (greg_t) tp->ct_orig_pc;\n\t\t}\n\t  \tbreak;\n\n\t  case 0xfa: // CLI\n\t  \t/***********************************************/\n\t  \t/*   Notreached   -   we   emulate   this  in  */\n\t  \t/*   cpu_copy_instr  because  we  panic if we  */\n\t  \t/*   single   step.   Not   sure  why  -  but  */\n\t  \t/*   emulation is better anyhow.\t       */\n\t  \t/***********************************************/\n\t  \tregs->r_rfl &= ~X86_EFLAGS_IF;\n\t\tregs->r_pc = (greg_t) tp->ct_orig_pc;\n\t  \tbreak;\n\t  case 0xfb: // STI\n\t  \t/***********************************************/\n\t  \t/*   Notreached   -   we   emulate   this  in  */\n\t  \t/*   cpu_copy_instr  because  we  panic if we  */\n\t  \t/*   single   step.   Not   sure  why  -  but  */\n\t  \t/*   emulation is better anyhow.\t       */\n\t  \t/***********************************************/\n\t  \tregs->r_rfl |= X86_EFLAGS_IF;\n\t\tregs->r_pc = (greg_t) tp->ct_orig_pc;\n\t  \tbreak;\n\n\t  SEE_BELOW(0xfc, cld);\n\t  SEE_BELOW(0xfd, std);\n\n\t  case 0xff:\n\t  \t/***********************************************/\n\t  \t/*   If  we  execute  a  CALL instruction, we  */\n\t  \t/*   need  to  push  the  original  PC return  */\n\t  \t/*   address, not our buffers!\t\t       */\n\t  \t/***********************************************/\n\t  \tswitch (pc[1] & 0xf0) {\n\t\t  case 0x10: // call/lcall *(%reg)\n\t\t  case 0x50: // call/lcall *nn(%reg)\n\t\t  case 0x90: // call/lcall *nn32(%reg)\n\t\t  case 0xd0: // call/lcall *%reg\n\t\t  \t{greg_t *sp = (greg_t *) stack_ptr(regs);\n\t\t\t*sp = (greg_t) tp->ct_orig_pc;\n\t\t  \tbreak;\n\t\t\t}\n\n\t\t  case 0x20: // jmp/ljmp *(%reg)\n\t\t  case 0x60: // jmp/ljmp *nnn(%reg)\n\t\t  case 0xa0: // jmp/ljmp *nnn(%reg)\n\t\t  case 0xe0: // jmp/ljmp *%reg\n\t\t  \tbreak;\n\t\t  default:\n\t\t  \tgoto DEFAULT;\n\t\t  }\n\t\tbreak;\n\n\t  default:\n\t  DEFAULT: ;\n\t\tregs->r_pc = (greg_t) tp->ct_orig_pc;\n//regs->r_rfl = (regs->r_rfl & ~(X86_EFLAGS_TF|X86_EFLAGS_IF)) | (this_cpu->cpuc_eflags & (X86_EFLAGS_IF));\n\t\tbreak;\n\t  }\n\n\treturn FALSE;\n}", "path": "linux/driver/cpu_x86.c", "commit_date": "2013-02-11 00:00:00", "repo_name": "dtrace4linux/linux", "stars": 1156, "license": "None", "language": "c", "size": 8259}
{"docstring": "/*ARGSUSED*/\n", "func_signal": "static void\ndt_dis_pushts(const dtrace_difo_t *dp,\n    const char *name, dif_instr_t in, FILE *fp)", "code": "{\n\tstatic const char *const tnames[] = { \"D type\", \"string\" };\n\tuint_t type = DIF_INSTR_TYPE(in);\n\n\t(void) fprintf(fp, \"%-4s DT_TYPE(%u), %%r%u, %%r%u\",\n\t    name, type, DIF_INSTR_R2(in), DIF_INSTR_RS(in));\n\n\tif (type < sizeof (tnames) / sizeof (tnames[0]))\n\t\t(void) fprintf(fp, \"\\t! DT_TYPE(%u) = %s\", type, tnames[type]);\n}", "path": "linux/libdtrace/dt_dis.c", "commit_date": "2012-02-08 00:00:00", "repo_name": "dtrace4linux/linux", "stars": 1156, "license": "None", "language": "c", "size": 8259}
{"docstring": "/*\n * The cpu structure grows, with the addition of a machcpu member, if\n * _MACHDEP is defined.  This means that, for example, the cpu structure\n * in unix is different from the cpu structure in genunix.  As one might\n * expect, this causes merges to fail.  Since everyone indirectly contains\n * a pointer to a CPU structure, the failed merges can cause massive amounts\n * of duplication.  In the case of unix uniquifying against genunix, upwards\n * of 50% of the structures were unmerged due to this problem.  We fix this\n * by adding a cpu_m member.  If machcpu hasn't been defined in our module,\n * we make a forward node for it.\n */\n", "func_signal": "static void\nfix_small_cpu_struct(tdata_t *td)", "code": "{\n\ttdesc_t *cput, *cpu;\n\ttdesc_t *machcpu;\n\tmlist_t *ml, *lml;\n\tmlist_t *cpum;\n\tint foundcpucyc = 0;\n\tsize_t lmlsz;\n\n\t/*\n\t * We're going to take the circuitous route finding the cpu structure,\n\t * because we want to make sure that we find the right one.  It would\n\t * be nice if we could verify the header name too.\n\t */\n\tif ((cput = lookupname(\"cpu_t\")) == NULL || cput->t_type != TYPEDEF)\n\t\treturn;\n\n\tcpu = cput->t_tdesc;\n\tif (!streq(cpu->t_name, \"cpu\") || cpu->t_type != STRUCT)\n\t\treturn;\n\n\tfor (ml = cpu->t_members, lml = NULL; ml;\n\t    lml = ml, ml = ml->ml_next) {\n\t\tif (strcmp(ml->ml_name, \"cpu_cyclic\") == 0)\n\t\t\tfoundcpucyc = 1;\n\t}\n\n\tif (foundcpucyc == 0 || lml == NULL ||\n\t    strcmp(lml->ml_name, \"cpu_m\") == 0)\n\t\treturn;\n\n\t/*\n\t * We need to find out how big the last element is so we can compute the\n\t * offset of the new one.  If the last element has a size, we use it.\n\t * If it doesn't, it should be a pointer, which won't have a size.  In\n\t * that case, we look up the size of a long and use that as the size of\n\t * the pointer.\n\t */\n\tif (lml->ml_type->t_size)\n\t\tlmlsz = lml->ml_type->t_size * NBBY;\n\telse {\n\t\ttdesc_t *tdp = lookupname(\"long\");\n\t\tlmlsz = tdp->t_intr->intr_nbits;\n\t}\n\n\tif ((machcpu = lookupname(\"machcpu\")) == NULL) {\n\t\tmachcpu = xcalloc(sizeof (*machcpu));\n\t\tmachcpu->t_name = xstrdup(\"machcpu\");\n\t\tmachcpu->t_id = td->td_nextid++;\n\t\tmachcpu->t_type = FORWARD;\n\n\t} else if (machcpu->t_type != STRUCT)\n\t\treturn;\n\n\tdebug(3, \"Adding cpu_m machcpu %s to cpu struct\\n\",\n\t    (machcpu->t_type == FORWARD ? \"forward\" : \"struct\"));\n\n\tcpum = xmalloc(sizeof (*cpum));\n\tcpum->ml_offset = lml->ml_offset + lmlsz;\n\tcpum->ml_size = 0;\n\tcpum->ml_name = xstrdup(\"cpu_m\");\n\tcpum->ml_type = machcpu;\n\tcpum->ml_next = NULL;\n\n\tlml->ml_next = cpum;\n}", "path": "linux/cmd/ctfconvert/st_bugs.c", "commit_date": "2012-02-08 00:00:00", "repo_name": "dtrace4linux/linux", "stars": 1156, "license": "None", "language": "c", "size": 8259}
{"docstring": "/**********************************************************************/\n/*   In  Linux  3.4.6  (probably  before),  the  write_idt_entry can  */\n/*   invoke   xen_write_idt_entry   which   does   the   code  below  */\n/*   (approximately).  In  the  kernel,  it stops us overwriting the  */\n/*   vectors  we  care  about  in some cases, so we go direct to the  */\n/*   hypervisor, if its loaded.\t\t\t\t\t      */\n/**********************************************************************/\n", "func_signal": "static void \ndtrace_write_idt_entry(int vec, const gate_t *val)", "code": "{\n# if defined(__i386) || defined(__amd64)\n\tint\ti;\n\n\t/***********************************************/\n\t/*   Update  the  IDT,  but  this may have no  */\n\t/*   effect  in a Xen guest, where we need to  */\n\t/*   tell the hypervisor what happened.\t       */\n\t/***********************************************/\n\tmemory_set_rw(idt_table_ptr, 1, TRUE);\n\tidt_table_ptr[vec] = *val;\n\n\t/***********************************************/\n\t/*   Make  sure every CPU sees the IDT change  */\n\t/*   -  only  applicable for Xen (because Xen  */\n\t/*   virtualises  the IDT, so simply updating  */\n\t/*   the  IDT  has no direct effect - we have  */\n\t/*   to  hypercall  out  to let Xen know what  */\n\t/*   happened.\t\t\t\t       */\n\t/***********************************************/\n\tfor (i = 0; i < nr_cpus; i++) {\n\t\tSMP_CALL_FUNCTION_SINGLE(i, dtrace_write_idt_entry2, (void *) (long) vec, TRUE);\n\t}\n# endif\n}", "path": "linux/driver/intr.c", "commit_date": "2016-01-11 00:00:00", "repo_name": "dtrace4linux/linux", "stars": 1156, "license": "None", "language": "c", "size": 8259}
{"docstring": "/*ARGSUSED*/\n", "func_signal": "void\nsdt_getargdesc(void *arg, dtrace_id_t id, void *parg, dtrace_argdesc_t *desc)", "code": "{\n\tsdt_probe_t *sdp = parg;\n\tint i;\n\n\tdesc->dtargd_native[0] = '\\0';\n\tdesc->dtargd_xlate[0] = '\\0';\n\n\tfor (i = 0; sdt_args[i].sda_provider != NULL; i++) {\n\t\tsdt_argdesc_t *a = &sdt_args[i];\n\n\t\tif (strcmp(sdp->sdp_provider->sdtp_name, a->sda_provider) != 0)\n\t\t\tcontinue;\n\n\t\tif (a->sda_name != NULL &&\n\t\t    strcmp(sdp->sdp_name, a->sda_name) != 0)\n\t\t\tcontinue;\n\n\t\tif (desc->dtargd_ndx != a->sda_ndx)\n\t\t\tcontinue;\n\n\t\tif (a->sda_native != NULL)\n\t\t\t(void) strcpy(desc->dtargd_native, a->sda_native);\n\n\t\tif (a->sda_xlate != NULL)\n\t\t\t(void) strcpy(desc->dtargd_xlate, a->sda_xlate);\n\nprintk(\"sdp_provider=%p [%d] sdtp_name=%s native=%s xlate=%s\\n\", sdp->sdp_provider, a->sda_ndx, sdp->sdp_provider->sdtp_name,\ndesc->dtargd_native, desc->dtargd_xlate);\n\t\tdesc->dtargd_mapping = a->sda_mapping;\n\t\treturn;\n\t}\n\n\tdesc->dtargd_ndx = DTRACE_ARGNONE;\n}", "path": "linux/driver/sdt_subr.c", "commit_date": "2012-02-08 00:00:00", "repo_name": "dtrace4linux/linux", "stars": 1156, "license": "None", "language": "c", "size": 8259}
{"docstring": "/**********************************************************************/\n/*   Code to implement /proc/dtrace/idt.\t\t\t      */\n/**********************************************************************/\n", "func_signal": "static void *idt_seq_start(struct seq_file *seq, loff_t *pos)", "code": "{\n\tif (*pos > IDT_ENTRIES)\n\t\treturn 0;\n\treturn (void *) (long) (*pos + 1);\n}", "path": "linux/driver/intr.c", "commit_date": "2016-01-11 00:00:00", "repo_name": "dtrace4linux/linux", "stars": 1156, "license": "None", "language": "c", "size": 8259}
{"docstring": "/**********************************************************************/\n/*   'ipl'  function inside a probe - let us know if interrupts were  */\n/*   enabled or not.\t\t\t\t\t\t      */\n/**********************************************************************/\n", "func_signal": "int\ndtrace_getipl(void)", "code": "{\tcpu_core_t *this_cpu = THIS_CPU();\n\n\treturn this_cpu->cpuc_regs->r_rfl & X86_EFLAGS_IF ? 0 : 1;\n}", "path": "linux/driver/intr.c", "commit_date": "2016-01-11 00:00:00", "repo_name": "dtrace4linux/linux", "stars": 1156, "license": "None", "language": "c", "size": 8259}
{"docstring": "/**********************************************************************/\n/*   Skip  leading prefix for an instruction, so we can test what it  */\n/*   really is.\t\t\t\t\t\t\t      */\n/**********************************************************************/\n", "func_signal": "static uchar_t *\ncpu_skip_prefix(uchar_t *pc)", "code": "{\n#if defined(__amd64)\n\t/***********************************************/\n\t/*   Watch out for IRETQ (48 CF)\t       */\n\t/***********************************************/\n\tif (*pc == 0x48)\n\t\tpc++;\n#endif\n\n\t/***********************************************/\n\t/*   Skip  prefix  bytes,  so we can find the  */\n\t/*   underlying opcode.\t\t\t       */\n\t/***********************************************/\n\twhile (1) {\n\t\tswitch (*pc) {\n\t\t  case 0x26:\n\t\t  case 0x2e:\n\t\t  case 0x36:\n\t\t  case 0x3e:\n\t\t  case 0x64:\n\t\t  case 0x65:\n\t\t  case 0x66:\n\t\t  case 0x67:\n\t\t  case 0x9b:\n\t\t  case 0xf0: // lock\n\t\t  case 0xf2: // repnz\n\t\t  case 0xf3: // repz\n\t\t  \tpc++;\n\t\t\tcontinue;\n\t\t  }\n\t\tbreak;\n\t}\n\n\t/***********************************************/\n\t/*   REX - access to new 8-bit registers.      */\n\t/***********************************************/\n\tif (*pc == 0x40)\n\t\tpc++;\n\n\treturn pc;\n}", "path": "linux/driver/cpu_x86.c", "commit_date": "2013-02-11 00:00:00", "repo_name": "dtrace4linux/linux", "stars": 1156, "license": "None", "language": "c", "size": 8259}
{"docstring": "/**********************************************************************/\n/*   This  code  was  designed  to  help me debug page fault handler  */\n/*   issues.  Its  not  complete  (no amd64 output), and the i386 is  */\n/*   questionable.\t\t\t\t\t\t      */\n/**********************************************************************/\n", "func_signal": "static int gdt_seq_show(struct seq_file *seq, void *v)", "code": "{\tint\tn = (int) (long) v;\n\tunsigned long *g;\n\tunsigned long *gdt_table_ptr;\n\tstruct x86_descriptor desc = {0};\n\n\tstore_gdt((struct desc_ptr *) &desc);\n\tif (n == 1) {\n\t\tseq_printf(seq, \"GDT: %p entries=%d\\n\",\n\t\t\t(void *) desc.address, desc.size);\n\t\tseq_printf(seq, \"#Ent base limit flags...\\n\");\n\t\treturn 0;\n\t}\n\tif (n > GDT_ENTRIES + 1)\n\t\treturn 0;\n\n\tgdt_table_ptr = (unsigned long *) desc.address;\n\tif (gdt_table_ptr == NULL) {\n\t\tseq_printf(seq, \"No GDT support on this processor\\n\");\n\t\treturn 0;\n\t\t}\n\tg = &gdt_table_ptr[(n - 2) * 2];\n# if defined(__amd64)\n\n# elif defined(__i386)\n\t{\n\tunsigned long base0 = (g[0] & 0xffff0000) >> 16;\n\tunsigned long base1 = (g[1] & 0xff000000) >> 24;\n\tunsigned long base2 =  g[1] & 0x000000ff;\n\tunsigned long lim0 = g[1] & 0xffff;\n\tunsigned long lim1 = (g[0] >> 16) & 0x0f;\n\tunsigned long lim = (lim1 << 16) | lim0;\n\tunsigned int access = (g[1] & 0xff00) >> 8;\n\tunsigned int flags = (g[1] >> 20) & 0x0f;\n\tunsigned long addr = base0 | (base1 << 16) | (base2 << 24);\n\tif ((g[0] & 0x8000) == 0) {\n\t\tseq_printf(seq, \"%02x not-present\\n\", n - 2);\n\t\treturn 0;\n\t}\n\tif ((flags & 0x08) == 0) {\n\t\tlim <<= 12;\n\t\tlim |= 0xfff;\n\t}\n\tseq_printf(seq, \"%02x %s base=%p lim=%08lx %s pr=%d %s %s %s %s %s %s\\n\",\n\t\tn-2,\n\t\t(access & (0x08 | 0x02)) == (0x08 | 0x02) ? \"CodeRW\" :\n\t\t(access & (0x08 | 0x02)) == (0x08       ) ? \"CodeRO\" :\n\t\t(access & (0x08 | 0x02)) == (       0x02) ? \"DataRW\" :\n\t\t(access & (0x08 | 0x02)) == (       0000) ? \"DataRO\" : \"????\",\n\t\t(void *) addr,\n\t\tlim,\n\t\taccess & 0x80 ? \" P\" : \"NP\",\n\t\t(access & 0x60) >> 5,\n\t\taccess & 0x08 ? \"ex\" : \"nx\",\n\t\taccess & 0x04 ? \" dc\" : \"ndc\",\n\t\taccess & 0x02 ? \"rw\" : \"ro\",\n\t\taccess & 0x01 ? \"ac\" : \"na\",\n\t\tflags & 0x08 ? \"1b\" : \"4k\",\n\t\tflags & 0x04 ? \"16\" : \"32\"\n\t\t);\n\t}\n\n# elif defined(__arm__)\n\treturn 0;\n\n# else\n# \terror \"Please implement /proc/dtrace/gdt\"\n# endif\n\treturn 0;\n}", "path": "linux/driver/intr.c", "commit_date": "2016-01-11 00:00:00", "repo_name": "dtrace4linux/linux", "stars": 1156, "license": "None", "language": "c", "size": 8259}
{"docstring": "/**********************************************************************/\n/*   Update the IDT table for an interrupt. We just set the function  */\n/*   pointer (code which will be in intr_x86-XX.S).\t\t      */\n/**********************************************************************/\n", "func_signal": "void\nset_idt_entry(int intr, unsigned long func)", "code": "{\nstatic gate_t s;\n\n#if defined(__amd64)\n\t/***********************************************/\n\t/*   Keep  the  actual  IDT  entry,  but only  */\n\t/*   update the function address.\t       */\n\t/***********************************************/\n#if 1\n\ts = idt_table_ptr[intr];\n\ts.offset_low = PTR_LOW(func);\n\ts.offset_middle = PTR_MIDDLE(func);\n\ts.offset_high = PTR_HIGH(func);\n#else\n\tint\ttype = CPU_GATE_INTERRUPT;\n\tint\tdpl = 3;\n\tint\tseg = __KERNEL_CS;\n\n\tdtrace_bzero(&s, sizeof s);\n\n\ts.offset_low = PTR_LOW(func);\n\ts.segment = seg;\n        s.ist = intr == 14 ? 0 : GATE_DEBUG_STACK;\n        s.p = 1;\n        s.dpl = dpl;\n        s.zero0 = 0;\n        s.zero1 = 0;\n        s.type = type;\n        s.offset_middle = PTR_MIDDLE(func);\n        s.offset_high = PTR_HIGH(func);\n#endif\n\n#elif defined(__i386)\n\t/***********************************************/\n\t/*   We  only care about the address, not the  */\n\t/*   other  attributes  which  belong  to the  */\n\t/*   kernel  and  version  of  the kernel. So  */\n\t/*   dont perturb these (dpl, stack, type).    */\n\t/***********************************************/\n\ts = *(gate_t *) &idt_table_ptr[intr];\n\ts.base0 = (u16) (func & 0xffff);\n\ts.base1 = (u16) ((func & 0xffff0000) >> 16);\n\n\tif (dtrace_here) {\n\t\tgate_t *g2 = &idt_table_ptr[intr];\n\t\tprintk(\"set_idt_entry intr=%d\\n  addr=%p sz=%d\\n\"\n\t\t\t\"  s[0]=%lx %lx fl=%x addr=%04x%04x dpl=%d type=%x\\n\"\n\t\t\t\"  i[0]=%lx %lx fl=%x addr=%04x%04x dpl=%d type=%x\\n\", \n\t\t\tintr,\n\t\t\t&idt_table_ptr[intr], (int) sizeof s, \n\t\t\t((long *) &s)[0], \n\t\t\t((long *) &s)[1], \n\t\t\ts.flags, s.base1, s.base0,\n\t\t\t(s.flags >> 5) & 0x3,\n\t\t\ts.flags & 0x1f,\n\t\t\t\n\t\t\t((long *) &idt_table_ptr[intr])[0], \n\t\t\t((long *) &idt_table_ptr[intr])[1],\n\t\t\tg2->flags, g2->base1, g2->base0, \n\t\t\t(g2->flags >> 5) & 0x3,\n\t\t\tg2->flags & 0x1f\n\t\t\t);\n\t}\n\n# elif defined(__arm__)\n\tTODO();\n\n#else\n#  error \"set_idt_entry: please help me\"\n#endif\n\n\t/***********************************************/\n\t/*   Ensure  Xen/paravirt  knows  about  this  */\n\t/*   interrupt handler.\t\t\t       */\n\t/***********************************************/\n\tdtrace_write_idt_entry(intr, &s);\n}", "path": "linux/driver/intr.c", "commit_date": "2016-01-11 00:00:00", "repo_name": "dtrace4linux/linux", "stars": 1156, "license": "None", "language": "c", "size": 8259}
{"docstring": "/*ARGSUSED*/\n", "func_signal": "static void\ndt_dis_r1rd(const dtrace_difo_t *dp, const char *name, dif_instr_t in, FILE *fp)", "code": "{\n\t(void) fprintf(fp, \"%-4s %%r%u, %%r%u\", name,\n\t    DIF_INSTR_R1(in), DIF_INSTR_RD(in));\n}", "path": "linux/libdtrace/dt_dis.c", "commit_date": "2012-02-08 00:00:00", "repo_name": "dtrace4linux/linux", "stars": 1156, "license": "None", "language": "c", "size": 8259}
{"docstring": "/**********************************************************************/\n/*   In  the  single  step  trap handler, get ready to step over the  */\n/*   instruction. We copy it to a temp buffer, and set up so we know  */\n/*   what to do on return after the trap.\t\t\t      */\n/*   \t\t\t\t\t\t\t\t      */\n/*   We  may  need to patch the instruction if it uses %RIP relative  */\n/*   addressing mode (which x86-64 will do in the kernel).\t      */\n/*   \t\t\t\t\t\t\t\t      */\n/*   For  an  IRET,  we  cannot  single  step it, so we will need to  */\n/*   emulate it instead.\t\t\t\t\t      */\n/**********************************************************************/\n", "func_signal": "void\ncpu_copy_instr(cpu_core_t *this_cpu, cpu_trap_t *tp, struct pt_regs *regs)", "code": "{\n\n/*dtrace_printf(\"cpu_copy_instr: inslen=%d %02x %02x %02x %02x\\n\", tp->ct_tinfo.t_inslen,\ntp->ct_tinfo.t_opcode,\n((unsigned char *) regs->r_pc)[0],\n((unsigned char *) regs->r_pc)[1],\n((unsigned char *) regs->r_pc)[2]);*/\n\t/***********************************************/\n\t/*   Emulate  delicate  instructions. Without  */\n\t/*   this   we   can   hit  problems  in  the  */\n\t/*   syscall/interrupt handlers if we try and  */\n\t/*   single step the instructions.\t       */\n\t/*   Its  also faster and less overhead if we  */\n\t/*   do this here.\t\t\t       */\n\t/***********************************************/\n\tswitch (tp->ct_tinfo.t_opcode) {\n\t  case 0xfa: // CLI\n\t\tregs->r_rfl &= ~X86_EFLAGS_IF;\n\t\tthis_cpu->cpuc_mode = CPUC_MODE_IDLE;\n\t\treturn;\n\n\t  case 0xfb: // STI\n\t\tregs->r_rfl |= X86_EFLAGS_IF;\n\t\tthis_cpu->cpuc_mode = CPUC_MODE_IDLE;\n\t\treturn;\n\t}\n\n\ttp->ct_instr_buf[0] = tp->ct_tinfo.t_opcode;\n\tdtrace_memcpy(&tp->ct_instr_buf[1], \n\t\t(void *) regs->r_pc, \n\t\ttp->ct_tinfo.t_inslen - 1);\n\t/***********************************************/\n\t/*   Put   a   NOP   instruction   after  the  */\n\t/*   instruction we are going to single step.  */\n\t/*   Some  instructions, like \"MOV %CR3,%EAX\"  */\n\t/*   will  step the next instruction also. By  */\n\t/*   doing  this,  we  regain control even if  */\n\t/*   this  happens. 0x90 is a NOP in i386 and  */\n\t/*   amd64.\t\t\t\t       */\n\t/***********************************************/\n\ttp->ct_instr_buf[tp->ct_tinfo.t_inslen] = 0x90;\n\t/***********************************************/\n\t/*   Second  NOP  isnt  needed, but it is for  */\n\t/*   Xen.  This  may  be  a  cache  coherency  */\n\t/*   issue.\t\t\t\t       */\n\t/***********************************************/\n\ttp->ct_instr_buf[tp->ct_tinfo.t_inslen+1] = 0x90;\n\n//printk(\"step..len=%d %2x %2x\\n\", this_cpu->cpuc_tinfo.t_inslen, this_cpu->cpuc_instr_buf[0], this_cpu->cpuc_instr_buf[1]);\n\n\t/***********************************************/\n\t/*   Set  where  the next instruction is. The  */\n\t/*   instruction we hit could be a jump/call,  */\n\t/*   so  we  will  need to detect that on the  */\n\t/*   other  side of the single-step to ensure  */\n\t/*   we dont 'undo' the instruction.\t       */\n\t/***********************************************/\n\ttp->ct_orig_pc = (unsigned char *) regs->r_pc + \n\t\ttp->ct_tinfo.t_inslen - 1;\n\n\t/***********************************************/\n\t/*   May   need   to   rewrite   our   copied  */\n\t/*   instruction if we are doing RIP relative  */\n\t/*   addressing.\t\t\t       */\n\t/***********************************************/\n\tcpu_fix_rel(this_cpu, tp,\n\t\t(unsigned char *) regs->r_pc - 1);\n\n\t/***********************************************/\n\t/*   Go  into  single  step mode, and we will  */\n\t/*   return to our fake buffer.\t\t       */\n\t/***********************************************/\n\ttp->ct_eflags = regs->r_rfl;\n//printk(\"origpc=%p instpc=%p rfl=%p\\n\", regs->r_pc, tp->cpuc_instr_buf, regs->r_rfl);\n\tregs->r_rfl |= X86_EFLAGS_TF;\n\tregs->r_rfl &= ~X86_EFLAGS_IF;\n\tregs->r_pc = (greg_t) tp->ct_instr_buf;\n}", "path": "linux/driver/cpu_x86.c", "commit_date": "2013-02-11 00:00:00", "repo_name": "dtrace4linux/linux", "stars": 1156, "license": "None", "language": "c", "size": 8259}
{"docstring": "/**********************************************************************/\n/*   This    function   implements   the   logic   to   ensure   the  */\n/*   dtrace_int_page_fault_handler interrupt routine exists in every  */\n/*   processes  page  table.  System procs wont have an mm->pgd, but  */\n/*   will  be using the init_mm.pgd. We just need to ensure that all  */\n/*   other  procs  can  suffer  a  page  fault once we take over the  */\n/*   vector. (\"The impossible to debug\" bug).\t\t\t      */\n/**********************************************************************/\n", "func_signal": "void\nmy_vmalloc_sync_all(void)", "code": "{\n# if defined(__i386) && !defined(HAVE_VMALLOC_SYNC_ALL)\n\tstruct task_struct *t;\n\tunsigned int\tlevel;\nstruct map {\n\tchar *name;\n\tunsigned long addr;\n\t};\n#define\tENTRY(func) {#func, (unsigned long) func}\nstatic struct map tbl[] = {\n\tENTRY(dtrace_int_page_fault_handler),\n\tENTRY(dtrace_page_fault),\n\tENTRY(dtrace_int1_handler),\n\tENTRY(dtrace_int3_handler),\n\tENTRY(dtrace_int1),\n\tENTRY(dtrace_int3),\n\t};\n\n        if (SHARED_KERNEL_PMD)\n               return;\n\n\t/***********************************************/\n\t/*   We  lock  the process table - we wont be  */\n\t/*   long, but, just in case. This may not be  */\n\t/*   sufficient,   maybe   we  need  to  stop  */\n\t/*   scheduling.  But  its only during driver  */\n\t/*   load.\t\t\t\t       */\n\t/***********************************************/\n\trcu_read_lock();\n\tfor_each_process(t) {\n\t\tstruct mm_struct *mm;\n\t\tint\ti;\n\t\tpte_t *p;\n\t\tpmd_t\t*pmd;\n\n\t\tif ((mm = t->mm) == NULL)\n\t\t\tcontinue;\n# undef comm\n\t\t/***********************************************/\n\t\t/*   Make  sure both the page fault interrupt  */\n\t\t/*   handler,  and the C companion are in the  */\n\t\t/*   page  table.  We need to be very careful  */\n\t\t/*   the  page  fault C code does not jump to  */\n\t\t/*   other pages which we have not mapped (eg  */\n\t\t/*   dtrace_print  etc).  Even  if  we do, we  */\n\t\t/*   might  get  away  with it, since the bug  */\n\t\t/*   scenario is very obscure.\t\t       */\n\t\t/***********************************************/\n\t\tfor (i = 0; i < (int) (sizeof tbl / sizeof tbl[0]); i++) {\n\t\t\tp = lookup_address_mm(mm, tbl[i].addr, &level);\n\t\t\tif (p == NULL) {\n\t\t\t\tpmd = sync_swapper_pte(mm, tbl[i].addr);\n\t\t\t\tprintk(\"lockpf: %s pid%d %s %p\\n\", tbl[i].name, (int) t->pid, t->comm, pmd);\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n#endif\n}", "path": "linux/driver/intr.c", "commit_date": "2016-01-11 00:00:00", "repo_name": "dtrace4linux/linux", "stars": 1156, "license": "None", "language": "c", "size": 8259}
{"docstring": "/*ARGSUSED*/\n", "func_signal": "static void\ndt_dis_call(const dtrace_difo_t *dp, const char *name, dif_instr_t in, FILE *fp)", "code": "{\n\tuint_t subr = DIF_INSTR_SUBR(in);\n\n\t(void) fprintf(fp, \"%-4s DIF_SUBR(%u), %%r%u\\t\\t! %s\",\n\t    name, subr, DIF_INSTR_RD(in), dtrace_subrstr(NULL, subr));\n}", "path": "linux/libdtrace/dt_dis.c", "commit_date": "2012-02-08 00:00:00", "repo_name": "dtrace4linux/linux", "stars": 1156, "license": "None", "language": "c", "size": 8259}
{"docstring": "/*ARGSUSED*/\n", "func_signal": "static void\ndt_dis_load(const dtrace_difo_t *dp, const char *name, dif_instr_t in, FILE *fp)", "code": "{\n\t(void) fprintf(fp, \"%-4s [%%r%u], %%r%u\", name,\n\t    DIF_INSTR_R1(in), DIF_INSTR_RD(in));\n}", "path": "linux/libdtrace/dt_dis.c", "commit_date": "2012-02-08 00:00:00", "repo_name": "dtrace4linux/linux", "stars": 1156, "license": "None", "language": "c", "size": 8259}
{"docstring": "/* Creates the config and chatlog directories.\n *\n * Returns 0 on success.\n * Returns -1 on failure.\n */\n", "func_signal": "int create_user_config_dirs(char *path)", "code": "{\n    struct stat buf;\n    int mkdir_err = mkdir(path, 0700);\n\n    if (mkdir_err && (errno != EEXIST || stat(path, &buf) || !S_ISDIR(buf.st_mode))) {\n        return -1;\n    }\n\n    char *fullpath = malloc(strlen(path) + strlen(CONFIGDIR) + 1);\n    char *logpath = malloc(strlen(path) + strlen(LOGDIR) + 1);\n\n    if (fullpath == NULL || logpath == NULL) {\n        exit_toxic_err(\"failed in load_data_structures\", FATALERR_MEMORY);\n    }\n\n    strcpy(fullpath, path);\n    strcat(fullpath, CONFIGDIR);\n\n    strcpy(logpath, path);\n    strcat(logpath, LOGDIR);\n\n    mkdir_err = mkdir(fullpath, 0700);\n\n    if (mkdir_err && (errno != EEXIST || stat(fullpath, &buf) || !S_ISDIR(buf.st_mode))) {\n        free(fullpath);\n        free(logpath);\n        return -1;\n    }\n\n    mkdir_err = mkdir(logpath, 0700);\n\n    if (mkdir_err && (errno != EEXIST || stat(logpath, &buf) || !S_ISDIR(buf.st_mode))) {\n        free(fullpath);\n        free(logpath);\n        return -1;\n    }\n\n    free(logpath);\n    free(fullpath);\n    return 0;\n}", "path": "toxic/src/configdir.c", "commit_date": "2020-11-14 00:00:00", "repo_name": "JFreegman/toxic", "stars": 1149, "license": "gpl-3.0", "language": "c", "size": 18088}
{"docstring": "/* Terminate all sounds but wait for them to finish first */\n", "func_signal": "void graceful_clear(void)", "code": "{\n    control_lock();\n\n    while (1) {\n        int i;\n\n        for (i = 0; i < ACTIVE_NOTIFS_MAX; ++i) {\n            if (actives[i].active) {\n#ifdef BOX_NOTIFY\n\n                if (actives[i].box) {\n                    GError *ignore;\n                    notify_notification_close(actives[i].box, &ignore);\n                    actives[i].box = NULL;\n                }\n\n#endif /* BOX_NOTIFY */\n\n                if (actives[i].id_indicator) {\n                    *actives[i].id_indicator = -1;    /* reset indicator value */\n                }\n\n                if (actives[i].looping) {\n                    stop_sound(i);\n                } else {\n                    if (!is_playing(actives[i].source)) {\n                        clear_actives_index(i);\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (i == ACTIVE_NOTIFS_MAX) {\n            m_close_device(); /* In case it's opened */\n            control_unlock();\n            return;\n        }\n\n        sleep_thread(1000L);\n    }\n\n    control_unlock();\n}", "path": "toxic/src/notify.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "JFreegman/toxic", "stars": 1149, "license": "gpl-3.0", "language": "c", "size": 18088}
{"docstring": "/* Initializes an unused file transfer and returns its pointer.\n * Returns NULL on failure.\n */\n", "func_signal": "struct FileTransfer *new_file_transfer(ToxWindow *window, uint32_t friendnumber, uint32_t filenumber,\n                                       FILE_TRANSFER_DIRECTION direction, uint8_t type)", "code": "{\n    if (direction == FILE_TRANSFER_RECV) {\n        return new_file_receiver(window, friendnumber, filenumber, type);\n    }\n\n    if (direction == FILE_TRANSFER_SEND) {\n        return new_file_sender(window, friendnumber, filenumber, type);\n    }\n\n    return NULL;\n}", "path": "toxic/src/file_transfers.c", "commit_date": "2020-11-30 00:00:00", "repo_name": "JFreegman/toxic", "stars": 1149, "license": "gpl-3.0", "language": "c", "size": 18088}
{"docstring": "/* Returns a pointer to friendnumber's FileTransfer struct associated with filenumber.\n * Returns NULL if filenumber is invalid.\n */\n", "func_signal": "struct FileTransfer *get_file_transfer_struct(uint32_t friendnumber, uint32_t filenumber)", "code": "{\n    for (size_t i = 0; i < MAX_FILES; ++i) {\n        struct FileTransfer *ft_send = &Friends.list[friendnumber].file_sender[i];\n\n        if (ft_send->state != FILE_TRANSFER_INACTIVE && ft_send->filenumber == filenumber) {\n            return ft_send;\n        }\n\n        struct FileTransfer *ft_recv = &Friends.list[friendnumber].file_receiver[i];\n\n        if (ft_recv->state != FILE_TRANSFER_INACTIVE && ft_recv->filenumber == filenumber) {\n            return ft_recv;\n        }\n    }\n\n    return NULL;\n}", "path": "toxic/src/file_transfers.c", "commit_date": "2020-11-30 00:00:00", "repo_name": "JFreegman/toxic", "stars": 1149, "license": "gpl-3.0", "language": "c", "size": 18088}
{"docstring": "/* Opens primary device. Returns true on succe*/\n", "func_signal": "void m_open_device(void)", "code": "{\n    last_opened_update = get_unix_time();\n\n    if (device_opened) {\n        return;\n    }\n\n    /* Blah error check */\n    open_output_device(&Control.device_idx, 48000, 20, 1);\n\n    device_opened = true;\n}", "path": "toxic/src/notify.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "JFreegman/toxic", "stars": 1149, "license": "gpl-3.0", "language": "c", "size": 18088}
{"docstring": "/* creates initial progress line that will be updated during file transfer.\n   Assumes progline has room for at least MAX_STR_SIZE bytes */\n", "func_signal": "void init_progress_bar(char *progline)", "code": "{\n    strcpy(progline, \"0% [\");\n    int i;\n\n    for (i = 0; i < NUM_PROG_MARKS; ++i) {\n        strcat(progline, \"-\");\n    }\n\n    strcat(progline, \"] 0.0 B/s\");\n}", "path": "toxic/src/file_transfers.c", "commit_date": "2020-11-30 00:00:00", "repo_name": "JFreegman/toxic", "stars": 1149, "license": "gpl-3.0", "language": "c", "size": 18088}
{"docstring": "/**\n * @brief Get the user's config directory.\n *\n * This is without a trailing slash. Resulting string must be freed.\n *\n * @return The users config dir or NULL on error.\n */\n", "func_signal": "char *get_user_config_dir(void)", "code": "{\n    char home[NSS_BUFLEN_PASSWD] = {0};\n    get_home_dir(home, sizeof(home));\n\n    char *user_config_dir = NULL;\n    size_t len = 0;\n\n# if defined(__APPLE__)\n    len = strlen(home) + strlen(\"/Library/Application Support\") + 1;\n    user_config_dir = malloc(len);\n\n    if (user_config_dir == NULL) {\n        return NULL;\n    }\n\n    snprintf(user_config_dir, len, \"%s/Library/Application Support\", home);\n# else /* __APPLE__ */\n\n    const char *tmp = getenv(\"XDG_CONFIG_HOME\");\n\n    if (tmp == NULL) {\n        len = strlen(home) + strlen(\"/.config\") + 1;\n        user_config_dir = malloc(len);\n\n        if (user_config_dir == NULL) {\n            return NULL;\n        }\n\n        snprintf(user_config_dir, len, \"%s/.config\", home);\n    } else {\n        user_config_dir = strdup(tmp);\n    }\n\n# endif /* __APPLE__ */\n\n    return user_config_dir;\n}", "path": "toxic/src/configdir.c", "commit_date": "2020-11-14 00:00:00", "repo_name": "JFreegman/toxic", "stars": 1149, "license": "gpl-3.0", "language": "c", "size": 18088}
{"docstring": "/* prints a progress bar for file transfers. */\n", "func_signal": "void print_progress_bar(ToxWindow *self, double bps, double pct_done, uint32_t line_id)", "code": "{\n    if (bps < 0 || pct_done < 0 || pct_done > 100) {\n        return;\n    }\n\n    char pct_str[STR_BUF_SIZE];\n    snprintf(pct_str, sizeof(pct_str), \"%.1f%%\", pct_done);\n\n    char bps_str[STR_BUF_SIZE];\n    bytes_convert_str(bps_str, sizeof(bps_str), bps);\n\n    char prog_line[NUM_PROG_MARKS + 1];\n    prog_line[0] = 0;\n\n    int n = pct_done / (100 / NUM_PROG_MARKS);\n    int i, j;\n\n    for (i = 0; i < n; ++i) {\n        strcat(prog_line, \"=\");\n    }\n\n    if (pct_done < 100) {\n        strcpy(prog_line + n, \">\");\n    }\n\n    for (j = i; j < NUM_PROG_MARKS - 1; ++j) {\n        strcat(prog_line, \"-\");\n    }\n\n    size_t line_buf_size = strlen(pct_str) + NUM_PROG_MARKS + strlen(bps_str) + 7;\n    char *full_line = malloc(line_buf_size);\n\n    if (full_line == NULL) {\n        return;\n    }\n\n    snprintf(full_line, line_buf_size, \"%s [%s] %s/s\", pct_str, prog_line, bps_str);\n\n    line_info_set(self, line_id, full_line);\n\n    free(full_line);\n}", "path": "toxic/src/file_transfers.c", "commit_date": "2020-11-30 00:00:00", "repo_name": "JFreegman/toxic", "stars": 1149, "license": "gpl-3.0", "language": "c", "size": 18088}
{"docstring": "/* get the user's home directory. */\n", "func_signal": "void get_home_dir(char *home, int size)", "code": "{\n    struct passwd pwd;\n    struct passwd *pwdbuf;\n    const char *hmstr;\n    char buf[NSS_BUFLEN_PASSWD];\n\n    int rc = getpwuid_r(getuid(), &pwd, buf, NSS_BUFLEN_PASSWD, &pwdbuf);\n\n    if (rc == 0) {\n        hmstr = pwd.pw_dir;\n    } else {\n        hmstr = getenv(\"HOME\");\n\n        if (hmstr == NULL) {\n            return;\n        }\n\n        snprintf(buf, sizeof(buf), \"%s\", hmstr);\n        hmstr = buf;\n    }\n\n    snprintf(home, size, \"%s\", hmstr);\n}", "path": "toxic/src/configdir.c", "commit_date": "2020-11-14 00:00:00", "repo_name": "JFreegman/toxic", "stars": 1149, "license": "gpl-3.0", "language": "c", "size": 18088}
{"docstring": "/* Returns a pointer to the FileTransfer struct associated with index with the direction specified.\n * Returns NULL on failure.\n */\n", "func_signal": "struct FileTransfer *get_file_transfer_struct_index(uint32_t friendnumber, uint32_t index,\n        FILE_TRANSFER_DIRECTION direction)", "code": "{\n    if (direction != FILE_TRANSFER_RECV && direction != FILE_TRANSFER_SEND) {\n        return NULL;\n    }\n\n    for (size_t i = 0; i < MAX_FILES; ++i) {\n        struct FileTransfer *ft = direction == FILE_TRANSFER_SEND ?\n                                      &Friends.list[friendnumber].file_sender[i] :\n                                      &Friends.list[friendnumber].file_receiver[i];\n\n        if (ft->state != FILE_TRANSFER_INACTIVE && ft->index == index) {\n            return ft;\n        }\n    }\n\n    return NULL;\n}", "path": "toxic/src/file_transfers.c", "commit_date": "2020-11-30 00:00:00", "repo_name": "JFreegman/toxic", "stars": 1149, "license": "gpl-3.0", "language": "c", "size": 18088}
{"docstring": "/* refreshes active file transfer status bars. */\n", "func_signal": "void refresh_file_transfer_progress(ToxWindow *self, uint32_t friendnumber)", "code": "{\n    for (size_t i = 0; i < MAX_FILES; ++i) {\n        refresh_progress_helper(self, &Friends.list[friendnumber].file_receiver[i]);\n        refresh_progress_helper(self, &Friends.list[friendnumber].file_sender[i]);\n    }\n}", "path": "toxic/src/file_transfers.c", "commit_date": "2020-11-30 00:00:00", "repo_name": "JFreegman/toxic", "stars": 1149, "license": "gpl-3.0", "language": "c", "size": 18088}
{"docstring": "/* Kills active outgoing avatar file transfers for friendnumber */\n", "func_signal": "void kill_avatar_file_transfers_friend(Tox *m, uint32_t friendnumber)", "code": "{\n    for (size_t i = 0; i < MAX_FILES; ++i) {\n        struct FileTransfer *ft = &Friends.list[friendnumber].file_sender[i];\n\n        if (ft->file_type == TOX_FILE_KIND_AVATAR) {\n            close_file_transfer(NULL, m, ft, TOX_FILE_CONTROL_CANCEL, NULL, silent);\n        }\n    }\n}", "path": "toxic/src/file_transfers.c", "commit_date": "2020-11-30 00:00:00", "repo_name": "JFreegman/toxic", "stars": 1149, "license": "gpl-3.0", "language": "c", "size": 18088}
{"docstring": "/* Kills all active file transfers for friendnumber */\n", "func_signal": "void kill_all_file_transfers_friend(Tox *m, uint32_t friendnumber)", "code": "{\n    for (size_t i = 0; i < MAX_FILES; ++i) {\n        close_file_transfer(NULL, m, &Friends.list[friendnumber].file_sender[i], TOX_FILE_CONTROL_CANCEL, NULL, silent);\n        close_file_transfer(NULL, m, &Friends.list[friendnumber].file_receiver[i], TOX_FILE_CONTROL_CANCEL, NULL, silent);\n    }\n}", "path": "toxic/src/file_transfers.c", "commit_date": "2020-11-30 00:00:00", "repo_name": "JFreegman/toxic", "stars": 1149, "license": "gpl-3.0", "language": "c", "size": 18088}
{"docstring": "/* SOUND_NOTIFY */\n", "func_signal": "static int m_play_sound(Notification notif, uint64_t flags)", "code": "{\n#ifdef SOUND_NOTIFY\n    return play_notify_sound(notif, flags);\n#else\n\n    if (notif != silent) {\n        beep();\n    }\n\n    return -1;\n#endif /* SOUND_NOTIFY */\n}", "path": "toxic/src/notify.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "JFreegman/toxic", "stars": 1149, "license": "gpl-3.0", "language": "c", "size": 18088}
{"docstring": "/* Returns a pointer to an unused file sender.\n * Returns NULL if all file senders are in use.\n */\n", "func_signal": "static struct FileTransfer *new_file_sender(ToxWindow *window, uint32_t friendnumber, uint32_t filenumber, uint8_t type)", "code": "{\n    for (size_t i = 0; i < MAX_FILES; ++i) {\n        struct FileTransfer *ft = &Friends.list[friendnumber].file_sender[i];\n\n        if (ft->state == FILE_TRANSFER_INACTIVE) {\n            clear_file_transfer(ft);\n            ft->window = window;\n            ft->index = i;\n            ft->friendnumber = friendnumber;\n            ft->filenumber = filenumber;\n            ft->file_type = type;\n            ft->state = FILE_TRANSFER_PENDING;\n            return ft;\n        }\n    }\n\n    return NULL;\n}", "path": "toxic/src/file_transfers.c", "commit_date": "2020-11-30 00:00:00", "repo_name": "JFreegman/toxic", "stars": 1149, "license": "gpl-3.0", "language": "c", "size": 18088}
{"docstring": "/* Closes file transfer ft.\n *\n * Set CTRL to -1 if we don't want to send a control signal.\n * Set message or self to NULL if we don't want to display a message.\n */\n", "func_signal": "void close_file_transfer(ToxWindow *self, Tox *m, struct FileTransfer *ft, int CTRL, const char *message,\n                         Notification sound_type)", "code": "{\n    if (!ft) {\n        return;\n    }\n\n    if (ft->state == FILE_TRANSFER_INACTIVE) {\n        return;\n    }\n\n    if (ft->file) {\n        fclose(ft->file);\n    }\n\n    if (CTRL >= 0) {\n        tox_file_control(m, ft->friendnumber, ft->filenumber, (Tox_File_Control) CTRL, NULL);\n    }\n\n    if (message && self) {\n        if (self->active_box != -1 && sound_type != silent) {\n            box_notify2(self, sound_type, NT_NOFOCUS | NT_WNDALERT_2, self->active_box, \"%s\", message);\n        } else {\n            box_notify(self, sound_type, NT_NOFOCUS | NT_WNDALERT_2, &self->active_box, self->name, \"%s\", message);\n        }\n\n        line_info_add(self, false, NULL, NULL, SYS_MSG, 0, 0, \"%s\", message);\n    }\n\n    clear_file_transfer(ft);\n}", "path": "toxic/src/file_transfers.c", "commit_date": "2020-11-30 00:00:00", "repo_name": "JFreegman/toxic", "stars": 1149, "license": "gpl-3.0", "language": "c", "size": 18088}
{"docstring": "/* Kills all notifications for `id`. This must be called before freeing a ToxWindow. */\n", "func_signal": "void kill_notifs(int id)", "code": "{\n    control_lock();\n\n    for (size_t i = 0; i < ACTIVE_NOTIFS_MAX; ++i) {\n        if (!actives[i].id_indicator) {\n            continue;\n        }\n\n        if (*actives[i].id_indicator == id) {\n#ifdef BOX_NOTIFY\n\n            if (actives[i].box) {\n                GError *ignore;\n                notify_notification_close(actives[i].box, &ignore);\n            }\n\n#endif // BOX_NOTIFY\n            clear_actives_index(i);\n        }\n    }\n\n    control_unlock();\n}", "path": "toxic/src/notify.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "JFreegman/toxic", "stars": 1149, "license": "gpl-3.0", "language": "c", "size": 18088}
{"docstring": "/* coloured tab notifications: primary notification type */\n", "func_signal": "static void tab_notify(ToxWindow *self, uint64_t flags)", "code": "{\n    if (self == NULL) {\n        return;\n    }\n\n    if (flags & NT_WNDALERT_0) {\n        self->alert = WINDOW_ALERT_0;\n    } else if ((flags & NT_WNDALERT_1) && (!self->alert || self->alert > WINDOW_ALERT_0)) {\n        self->alert = WINDOW_ALERT_1;\n    } else if ((flags & NT_WNDALERT_2) && (!self->alert || self->alert > WINDOW_ALERT_1)) {\n        self->alert = WINDOW_ALERT_2;\n    }\n\n    ++self->pending_messages;\n}", "path": "toxic/src/notify.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "JFreegman/toxic", "stars": 1149, "license": "gpl-3.0", "language": "c", "size": 18088}
{"docstring": "/* Returns a pointer to an unused file receiver.\n * Returns NULL if all file receivers are in use.\n */\n", "func_signal": "static struct FileTransfer *new_file_receiver(ToxWindow *window, uint32_t friendnumber, uint32_t filenumber,\n        uint8_t type)", "code": "{\n    for (size_t i = 0; i < MAX_FILES; ++i) {\n        struct FileTransfer *ft = &Friends.list[friendnumber].file_receiver[i];\n\n        if (ft->state == FILE_TRANSFER_INACTIVE) {\n            clear_file_transfer(ft);\n            ft->window = window;\n            ft->index = i;\n            ft->friendnumber = friendnumber;\n            ft->filenumber = filenumber;\n            ft->file_type = type;\n            ft->state = FILE_TRANSFER_PENDING;\n            return ft;\n        }\n    }\n\n    return NULL;\n}", "path": "toxic/src/file_transfers.c", "commit_date": "2020-11-30 00:00:00", "repo_name": "JFreegman/toxic", "stars": 1149, "license": "gpl-3.0", "language": "c", "size": 18088}
{"docstring": "/* Opens primary device */\n", "func_signal": "int init_notify(int login_cooldown, int notification_timeout)", "code": "{\n#ifdef SOUND_NOTIFY\n    alutInitWithoutContext(NULL, NULL);\n#endif /* SOUND_NOTIFY */\n\n#if defined(SOUND_NOTIFY) || defined(BOX_NOTIFY)\n\n    if (pthread_mutex_init(Control.poll_mutex, NULL) != 0) {\n        return -1;\n    }\n\n    Control.poll_active = 1;\n    pthread_t thread;\n\n    if (pthread_create(&thread, NULL, do_playing, NULL) != 0 || pthread_detach(thread) != 0) {\n        pthread_mutex_destroy(Control.poll_mutex);\n        Control.poll_active = 0;\n        return -1;\n    }\n\n#endif /* defined(SOUND_NOTIFY) || defined(BOX_NOTIFY) */\n    Control.cooldown = time(NULL) + login_cooldown;\n\n\n#ifdef BOX_NOTIFY\n    notify_init(\"Toxic\");\n#endif\n    Control.notif_timeout = notification_timeout;\n    return 1;\n}", "path": "toxic/src/notify.c", "commit_date": "2020-11-25 00:00:00", "repo_name": "JFreegman/toxic", "stars": 1149, "license": "gpl-3.0", "language": "c", "size": 18088}
{"docstring": "/* SWVR - from EA games, demuxed from .av/trk/mis/etc [Future Cop L.A.P.D. (PS/PC), Freekstyle (PS2/GC), EA Sports Supercross (PS)] */\n", "func_signal": "VGMSTREAM * init_vgmstream_ea_swvr(STREAMFILE *streamFile)", "code": "{\n    VGMSTREAM * vgmstream = NULL;\n    off_t start_offset;\n    int loop_flag = 0, channel_count, sample_rate, big_endian;\n    coding_t coding;\n    uint32_t block_id;\n    int32_t (*read_32bit)(off_t,STREAMFILE*) = NULL;\n    int16_t (*read_16bit)(off_t,STREAMFILE*) = NULL;\n    int total_subsongs, target_subsong = streamFile->stream_index;\n\n\n    /* checks */\n    /* .stream: common (found inside files)\n     * .str: shortened, probably unnecessary */\n    if (!check_extensions(streamFile,\"stream,str\"))\n        goto fail;\n\n    /* blocks ids are in machine endianness */\n    if (read_32bitBE(0x00,streamFile) == 0x52565753) { /* \"RVWS\" (PS1/PS2/PC) */\n        big_endian = 0;\n        read_32bit = read_32bitLE;\n        read_16bit = read_16bitLE;\n        start_offset = read_32bit(0x04, streamFile);\n    }\n    else if (read_32bitBE(0x00,streamFile) == 0x53575652) { /* \"SWVR\" (GC) */\n        big_endian = 1;\n        read_32bit = read_32bitBE;\n        read_16bit = read_16bitBE;\n        start_offset = read_32bit(0x04, streamFile);\n    }\n    else if (read_32bitBE(0x00,streamFile) == 0x4D474156) { /* \"MGAV\", Freekstyle (PS2) raw movies */\n        big_endian = 0;\n        read_32bit = read_32bitLE;\n        read_16bit = read_16bitLE;\n        start_offset = 0x00;\n    }\n    else if (read_32bitBE(0x00,streamFile) == 0x4453504D) { /* \"DSPM\", Freekstyle (GC) raw movies */\n        big_endian = 1;\n        read_32bit = read_32bitBE;\n        read_16bit = read_16bitBE;\n        start_offset = 0x00;\n    }\n    else {\n        goto fail;\n    }\n\n    if (read_32bit(start_offset+0x00, streamFile) == 0x50414444) /* \"PADD\" (Freekstyle) */\n        start_offset += read_32bit(start_offset+0x04, streamFile);\n    else if (read_32bit(start_offset+0x10, streamFile) == 0x53484452) /* \"SHDR\" (Future Cop PC) */\n        start_offset += read_32bit(start_offset+0x04, streamFile);\n\n    if (read_32bit(start_offset+0x00, streamFile) == 0x46494C4C) /* \"FILL\" (Freekstyle) */\n        start_offset += read_32bit(start_offset+0x04, streamFile);\n\n    total_subsongs = 1;\n    block_id = read_32bit(start_offset, streamFile);\n\n    /* files are basically headerless so we inspect the first block\n     * Freekstyle uses multiblocks/subsongs (though some subsongs may be clones?) */\n    switch(block_id) {\n        case 0x5641474D: /* \"VAGM\" */\n            coding = coding_PSX;\n            if (read_16bit(start_offset+0x1a, streamFile) == 0x0024) {\n                total_subsongs = read_32bit(start_offset+0x0c, streamFile)+1;\n                sample_rate = 22050;\n            }\n            else {\n                sample_rate = 14008;\n            }\n            channel_count = 2;\n            break;\n        case 0x56414742: /* \"VAGB\" */\n            coding = coding_PSX;\n            if (read_16bit(start_offset+0x1a, streamFile) == 0x6400) {\n                sample_rate = 22050;\n            }\n            else {\n                sample_rate = 14008;\n            }\n            channel_count = 1;\n            break;\n        case 0x4453504D: /* \"DSPM\" */\n            coding = coding_NGC_DSP;\n            total_subsongs = read_32bit(start_offset+0x0c, streamFile)+1;\n            sample_rate = 22050;\n            channel_count = 2;\n            break;\n        case 0x44535042: /* \"DSPB\" */\n            coding = coding_NGC_DSP;\n            channel_count = 1;\n            sample_rate = 22050;\n            break;\n        case 0x4D534943: /* \"MSIC\" */\n            coding = coding_PCM8_U_int;\n            channel_count = 2;\n            sample_rate = 14008;\n            break;\n        case 0x53484F43: /* \"SHOC\" (a generic block but hopefully has PC sounds) */\n            if (read_32bit(start_offset+0x10, streamFile) == 0x53484F43) { /* SHDR */\n                coding = coding_PCM8_U_int; //todo there are other codecs\n                channel_count = 1;\n                sample_rate = 14008;\n            }\n            else {\n                goto fail;\n            }\n            break;\n        default:\n            VGM_LOG(\"EA SWVR: unknown block id\\n\");\n            goto fail;\n    }\n\n    if (target_subsong == 0) target_subsong = 1;\n    if (target_subsong < 0 || target_subsong > total_subsongs || total_subsongs < 1) goto fail;\n\n    loop_flag = 0;//(channel_count > 1); /* some Future Cop LAPD tracks repeat but other games have fadeouts */\n\n\n    /* build the VGMSTREAM */\n    vgmstream = allocate_vgmstream(channel_count,loop_flag);\n    if (!vgmstream) goto fail;\n\n    vgmstream->meta_type = meta_EA_SWVR;\n    vgmstream->sample_rate = sample_rate;\n    vgmstream->codec_endian = big_endian;\n    vgmstream->num_streams = total_subsongs;\n    vgmstream->stream_size = get_streamfile_size(streamFile) / total_subsongs; /* approx... */\n\n    vgmstream->coding_type = coding;\n    vgmstream->layout_type = layout_blocked_ea_swvr;\n    /* DSP coefs are loaded per block */\n    /* some files (voices etc) decode with pops but seems a mastering problem */\n\n    if (!vgmstream_open_stream(vgmstream,streamFile,start_offset))\n        goto fail;\n\n    /* calc num_samples manually */\n    {\n        int num_samples;\n        vgmstream->stream_index = target_subsong; /* needed to skip other subsong-blocks */\n        vgmstream->next_block_offset = start_offset;\n        do {\n            block_update(vgmstream->next_block_offset,vgmstream);\n            switch(vgmstream->coding_type) {\n                case coding_PSX:     \tnum_samples = ps_bytes_to_samples(vgmstream->current_block_size,1); break;\n                case coding_NGC_DSP: \tnum_samples = dsp_bytes_to_samples(vgmstream->current_block_size,1); break;\n                case coding_PCM8_U_int: num_samples = pcm_bytes_to_samples(vgmstream->current_block_size,1,8); break;\n                default:             \tnum_samples = 0; break;\n            }\n            vgmstream->num_samples += num_samples;\n        }\n        while (vgmstream->next_block_offset < get_streamfile_size(streamFile));\n        block_update(start_offset, vgmstream);\n    }\n\n    if (loop_flag) {\n        vgmstream->loop_start_sample = 0;\n        vgmstream->loop_end_sample = vgmstream->num_samples;\n    }\n\n    return vgmstream;\n\nfail:\n    close_vgmstream(vgmstream);\n    return NULL;\n}", "path": "vgmstream/src/meta/ea_swvr.c", "commit_date": "2019-12-27 00:00:00", "repo_name": "vgmstream/vgmstream", "stars": 1393, "license": "other", "language": "c", "size": 37865}
{"docstring": "/* .AST - from Nintendo games [Super Mario Galaxy (Wii), Pac-Man Vs (GC)] */\n", "func_signal": "VGMSTREAM * init_vgmstream_ast(STREAMFILE *streamFile)", "code": "{\n    VGMSTREAM * vgmstream = NULL;\n    off_t start_offset;\n    int loop_flag, channel_count, codec;\n    int big_endian;\n    int32_t (*read_32bit)(off_t,STREAMFILE*) = NULL;\n    int16_t (*read_16bit)(off_t,STREAMFILE*) = NULL;\n\n\n    /* checks */\n    if (!check_extensions(streamFile, \"ast\"))\n        goto fail;\n\n    if (((uint32_t)read_32bitBE(0x00, streamFile) == 0x5354524D) && /* \"STRM\" */\n        ((uint32_t)read_32bitBE(0x40, streamFile) == 0x424C434B)) { /* \"BLCK\" */\n        read_32bit = read_32bitBE;\n        read_16bit = read_16bitBE;\n        big_endian = 1;\n    } else if (((uint32_t)read_32bitBE(0x00, streamFile) == 0x4D525453) && /* \"MRTS\" */ // Super Mario Galaxy (Super Mario 3D All-Stars (Switch))\n               ((uint32_t)read_32bitBE(0x40, streamFile) == 0x4B434C42)) { /* \"KCLB\" */\n               read_32bit = read_32bitLE;\n               read_16bit = read_16bitLE;\n               big_endian = 0;\n    } else {\n        goto fail;\n    }\n\n    if (read_16bit(0x0a,streamFile) != 0x10) /* ? */\n        goto fail;\n\n    if (read_32bit(0x04,streamFile)+0x40 != get_streamfile_size(streamFile))\n        goto fail;\n\n    codec         = read_16bitBE(0x08,streamFile); // always big-endian?\n    channel_count = read_16bit(0x0c,streamFile);\n    loop_flag     = read_16bit(0x0e,streamFile);\n    //max_block   = read_32bit(0x20,streamFile);\n    start_offset  = 0x40;\n\n    /* build the VGMSTREAM */\n    vgmstream = allocate_vgmstream(channel_count,loop_flag);\n    if (!vgmstream) goto fail;\n\n    vgmstream->meta_type = meta_AST;\n    vgmstream->sample_rate = read_32bit(0x10,streamFile);\n    vgmstream->num_samples = read_32bit(0x14,streamFile);\n    vgmstream->loop_start_sample = read_32bit(0x18,streamFile);\n    vgmstream->loop_end_sample = read_32bit(0x1c,streamFile);\n    vgmstream->codec_endian = big_endian;\n\n    vgmstream->layout_type = layout_blocked_ast;\n    switch (codec) {\n        case 0x00: /* , Pikmin 2 (GC) */\n            vgmstream->coding_type = coding_NGC_AFC;\n            break;\n        case 0x01: /* Mario Kart: Double Dash!! (GC) */\n            vgmstream->coding_type = coding_PCM16BE;\n            break;\n        default:\n            goto fail;\n    }\n\n    if (!vgmstream_open_stream(vgmstream,streamFile,start_offset))\n        goto fail;\n    return vgmstream;\n\nfail:\n    close_vgmstream(vgmstream);\n    return NULL;\n}", "path": "vgmstream/src/meta/ast.c", "commit_date": "2020-09-15 00:00:00", "repo_name": "vgmstream/vgmstream", "stars": 1393, "license": "other", "language": "c", "size": 37865}
{"docstring": "/* sadl - from DS games with Procyon Studio audio driver [Professor Layton (DS), Soma Bringer (DS)] */\n", "func_signal": "VGMSTREAM* init_vgmstream_sadl(STREAMFILE* sf)", "code": "{\n    VGMSTREAM* vgmstream = NULL;\n    int channels, loop_flag;\n    off_t start_offset;\n    uint8_t flags;\n    uint32_t loop_start, data_size;\n\n\n    /* checks */\n    if (!check_extensions(sf, \"sad\"))\n        goto fail;\n\n    if (read_u32be(0x00,sf) != 0x7361646c) /* \"sadl\" */\n        goto fail;\n    /* 04: null */\n    /* 08: data size, or null in later files */\n    /* 0c: version? (x0410=Luminous Arc, 0x0411=Layton, 0x0415=rest) */\n    /* 0e: file id (for .sad packed in .spd) */\n    /* 14: name related? */\n    /* 20: short filename (may be null or nor match full filename) */\n\n    /* 30: flags? (0/1/2) */\n    loop_flag = read_u8(0x31,sf);\n    channels = read_u8(0x32,sf);\n    flags = read_u8(0x33,sf);\n    /* 34: flags? */\n    /* 38: flags? */\n    /* 3c: null? */\n    data_size = read_u32le(0x40,sf); //?\n    start_offset = read_u32le(0x48,sf); /* usually 0x100, 0xc0 in LA */\n    /* 4c: start offset again or 0x40 in LA */\n    /* 50: size or samples? */\n    loop_start = read_u32le(0x54,sf); //?\n    /* others: sizes/samples/flags? */\n\n    data_size -= start_offset;\n    loop_start -= start_offset;\n\n\n    /* build the VGMSTREAM */\n    vgmstream = allocate_vgmstream(channels, loop_flag);\n    if (!vgmstream) goto fail;\n\n    vgmstream->meta_type = meta_SADL;\n\n    switch (flags & 6) { /* possibly > 1? (0/1/2) */\n        case 4:\n            vgmstream->sample_rate = 32728;\n            break;\n        case 2: /* Layton */\n        case 0: /* Luminous Arc (DS) */\n            vgmstream->sample_rate = 16364;\n            break;\n        default:\n            goto fail;\n    }\n\n    vgmstream->layout_type = layout_interleave;\n    vgmstream->interleave_block_size = 0x10;\n\n    switch(flags & 0xf0) { /* possibly >> 6? (0/1/2) */\n        case 0x00: /* Luminous Arc (DS) (non-int IMA? all files are mono though) */\n        case 0x70: /* Ni no Kuni (DS), Professor Layton and the Curious Village (DS), Soma Bringer (DS) */\n            vgmstream->coding_type = coding_IMA_int;\n\n            vgmstream->num_samples = ima_bytes_to_samples(data_size, channels);\n            vgmstream->loop_start_sample = ima_bytes_to_samples(loop_start, channels);\n            vgmstream->loop_end_sample = vgmstream->num_samples;\n\n            {\n                int i;\n                for (i = 0; i < channels; i++) {\n                    vgmstream->ch[i].adpcm_history1_32 = read_s16le(0x80 + i*0x04 + 0x00, sf);\n                    vgmstream->ch[i].adpcm_step_index = read_s16le(0x80 + i*0x04 + 0x02, sf);\n                }\n            }\n            break;\n\n        //TODO: Luminous Arc 2 uses a variation of this, but value 0x70\n        case 0xb0: /* Soma Bringer (DS), Rekishi Taisen Gettenka (DS) */\n            vgmstream->coding_type = coding_NDS_PROCYON;\n\n            vgmstream->num_samples = data_size / channels / 16 * 30;\n            vgmstream->loop_start_sample = loop_start / channels / 16 *30;\n            vgmstream->loop_end_sample = vgmstream->num_samples;\n            break;\n\n        default:\n            goto fail;\n    }\n\n    if (!vgmstream_open_stream(vgmstream, sf, start_offset))\n        goto fail;\n    return vgmstream;\n\nfail:\n    close_vgmstream(vgmstream);\n    return NULL;\n}", "path": "vgmstream/src/meta/sadl.c", "commit_date": "2020-11-21 00:00:00", "repo_name": "vgmstream/vgmstream", "stars": 1393, "license": "other", "language": "c", "size": 37865}
{"docstring": "/* .dsb - from Namco games [Taiko no Tatsujin DS: Dororon! Yokai Daikessen!! (DS)] */\n", "func_signal": "VGMSTREAM* init_vgmstream_dsb(STREAMFILE* sf)", "code": "{\n    VGMSTREAM* vgmstream = NULL;\n    STREAMFILE* temp_sf = NULL;\n    off_t subfile_offset;\n    size_t subfile_size;\n\n\n    /* checks */\n    if (!check_extensions(sf,\"dsb\"))\n        goto fail;\n    if (read_u32be(0x00,sf) != 0x44535342) /* \"DSSB\" */\n        goto fail;\n    if (read_u32be(0x40,sf) != 0x44535354) /* \"DSST\" */\n        goto fail;\n\n    /* - DDSB:\n     * 0x04: chunk size\n     * 0x08: file name\n     * 0x14: sample rate\n     * 0x18: v01?\n     * 0x1c: file size\n     * 0x20: DSST offset\n     *\n     * - DDST:\n     * 0x44: chunk size\n     * 0x48: file name\n     * 0x58: small signed number?\n     * 0x5c: data size (with padding)\n     * 0x60: small signed number?\n     * 0x64: ?\n     * rest: null\n     */\n\n    subfile_offset = 0x80;\n    subfile_size   = read_u32be(0x80 + 0x04, sf) + 0x08; /* files are padded so use BNSF */\n\n    temp_sf = setup_subfile_streamfile(sf, subfile_offset, subfile_size, \"bnsf\");\n    if (!temp_sf) goto fail;\n\n    vgmstream = init_vgmstream_bnsf(temp_sf);\n    if (!vgmstream) goto fail;\n\n    close_streamfile(temp_sf);\n    return vgmstream;\n\nfail:\n    close_streamfile(temp_sf);\n    close_vgmstream(vgmstream);\n    return NULL;\n}", "path": "vgmstream/src/meta/dsb.c", "commit_date": "2020-08-01 00:00:00", "repo_name": "vgmstream/vgmstream", "stars": 1393, "license": "other", "language": "c", "size": 37865}
{"docstring": "/* for reading integers inexplicably packed into 80-bit ('double extended') floats, AKA:\n * \"80 bit IEEE Standard 754 floating point number (Standard AppleNumeric Environment [SANE] data type Extended)\" */\n", "func_signal": "static uint32_t read_f80be(off_t offset, STREAMFILE* sf)", "code": "{\n    uint8_t buf[0x0a];\n    int32_t exponent;\n    int32_t mantissa;\n    int i;\n\n    if (read_streamfile(buf, offset, sizeof(buf), sf) != sizeof(buf))\n        return 0;\n\n    exponent = ((buf[0]<<8) | (buf[1])) & 0x7fff;\n    exponent -= 16383;\n\n    mantissa = 0;\n    for (i = 0; i < 8; i++) {\n        int32_t shift = exponent-7-i*8;\n        if (shift >= 0)\n            mantissa |= buf[i+2] << shift;\n        else if (shift > -8)\n            mantissa |= buf[i+2] >> -shift;\n    }\n\n    return mantissa * ((buf[0]&0x80) ? -1 : 1);\n}", "path": "vgmstream/src/meta/aifc.c", "commit_date": "2020-12-05 00:00:00", "repo_name": "vgmstream/vgmstream", "stars": 1393, "license": "other", "language": "c", "size": 37865}
{"docstring": "/**\n * Gets info from a MPEG frame header at offset. Normally you would use mpg123_info but somehow\n * it's wrong at times (maybe because we use an ancient version) so here we do our thing.\n */\n", "func_signal": "static int mpeg_get_frame_info_h(uint32_t header, mpeg_frame_info* info)", "code": "{\n    /* index tables */\n    static const int versions[4] = { /* MPEG 2.5 */ 3, /* reserved */ -1,  /* MPEG 2 */ 2, /* MPEG 1 */ 1 };\n    static const int layers[4] = { -1,3,2,1 };\n    static const int bit_rates[5][16] = { /* [version index ][bit rate index] (0=free, -1=bad) */\n            { 0, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, -1 }, /* MPEG1 Layer I */\n            { 0, 32, 48, 56,  64,  80,  96, 112, 128, 160, 192, 224, 256, 320, 384, -1 }, /* MPEG1 Layer II */\n            { 0, 32, 40, 48,  56,  64,  80,  96, 112, 128, 160, 192, 224, 256, 320, -1 }, /* MPEG1 Layer III */\n            { 0, 32, 48, 56,  64,  80,  96, 112, 128, 144, 160, 176, 192, 224, 256, -1 }, /* MPEG2/2.5 Layer I */\n            { 0,  8, 16, 24,  32,  40,  48,  56,  64,  80,  96, 112, 128, 144, 160, -1 }, /* MPEG2/2.5 Layer II/III */\n    };\n    static const int sample_rates[4][4] = { /* [version][sample rate index] */\n            { 44100, 48000, 32000, -1}, /* MPEG1 */\n            { 22050, 24000, 16000, -1}, /* MPEG2 */\n            { 11025, 12000,  8000, -1}, /* MPEG2.5 */\n    };\n    static const int channels[4] = { 2,2,2, 1 }; /* [channel] */\n    static const int frame_samples[3][3] = { /* [version][layer] */\n            { 384, 1152, 1152 }, /* MPEG1 */\n            { 384, 1152, 576  }, /* MPEG2 */\n            { 384, 1152, 576  }  /* MPEG2.5 */\n    };\n\n    int idx, padding;\n\n\n    memset(info, 0, sizeof(*info));\n\n    if ((header >> 21) != 0x7FF) /* 31-21: sync */\n        goto fail;\n\n    info->version = versions[(header >> 19) & 0x3]; /* 20,19: version */\n    if (info->version <= 0) goto fail;\n\n    info->layer = layers[(header >> 17) & 0x3]; /* 18,17: layer */\n    if (info->layer <= 0 || info->layer > 3) goto fail;\n\n    //crc       = (header >> 16) & 0x1; /* 16: protected by crc? */\n\n    idx = (info->version==1 ? info->layer-1 : (3 + (info->layer==1 ? 0 : 1)));\n    info->bit_rate = bit_rates[idx][(header >> 12) & 0xf]; /* 15-12: bit rate */\n    if (info->bit_rate <= 0) goto fail;\n\n    info->sample_rate = sample_rates[info->version-1][(header >> 10) & 0x3]; /* 11-10: sampling rate */\n    if (info->sample_rate <= 0) goto fail;\n\n    padding     = (header >>  9) & 0x1; /* 9: padding? */\n    //private   = (header >>  8) & 0x1; /* 8: private bit */\n\n    info->channels = channels[(header >>  6) & 0x3]; /* 7,6: channel mode */\n\n    //js_mode   = (header >>  4) & 0x3; /* 5,4: mode extension for joint stereo */\n    //copyright = (header >>  3) & 0x1; /* 3: copyrighted */\n    //original  = (header >>  2) & 0x1; /* 2: original */\n    //emphasis  = (header >>  0) & 0x3; /* 1,0: emphasis */\n\n    info->frame_samples = frame_samples[info->version-1][info->layer-1];\n\n    /* calculate frame length (from hcs's fsb_mpeg) */\n    switch (info->frame_samples) {\n        case 384:  info->frame_size = (12l  * info->bit_rate * 1000l / info->sample_rate + padding) * 4; break; /* 384/32 = 12 */\n        case 576:  info->frame_size = (72l  * info->bit_rate * 1000l / info->sample_rate + padding); break; /* 576/8 = 72 */\n        case 1152: info->frame_size = (144l * info->bit_rate * 1000l / info->sample_rate + padding); break; /* 1152/8 = 144 */\n        default: goto fail;\n    }\n\n    return 1;\n\nfail:\n    return 0;\n}", "path": "vgmstream/src/coding/mpeg_custom_utils.c", "commit_date": "2020-11-06 00:00:00", "repo_name": "vgmstream/vgmstream", "stars": 1393, "license": "other", "language": "c", "size": 37865}
{"docstring": "/* init config and validate per type */\n", "func_signal": "int mpeg_custom_setup_init_default(STREAMFILE* sf, off_t start_offset, mpeg_codec_data* data, coding_t* coding_type)", "code": "{\n    mpeg_frame_info info;\n\n\n    /* get frame info at offset */\n    if ( !mpeg_get_frame_info(sf, start_offset, &info))\n        goto fail;\n    switch(info.layer) {\n        case 1: *coding_type = coding_MPEG_layer1; break;\n        case 2: *coding_type = coding_MPEG_layer2; break;\n        case 3: *coding_type = coding_MPEG_layer3; break;\n        default: goto fail;\n    }\n    data->channels_per_frame = info.channels;\n    data->samples_per_frame = info.frame_samples;\n    data->bitrate_per_frame = info.bit_rate;\n    data->sample_rate_per_frame = info.sample_rate;\n\n\n    /* extra checks per type */\n    switch(data->type) {\n        case MPEG_XVAG:\n            if (data->config.chunk_size <= 0 || data->config.interleave <= 0)\n                goto fail; /* needs external fixed size */\n            break;\n\n        case MPEG_FSB:\n            if (data->config.fsb_padding != 0\n                    && data->config.fsb_padding != 2\n                    && data->config.fsb_padding != 4\n                    && data->config.fsb_padding != 16)\n                goto fail; /* aligned to closest 0/2/4/16 bytes */\n\n            /* get find interleave to stream offsets are set up externally */\n            {\n                int current_data_size = info.frame_size;\n                int current_padding = 0;\n                /* FSB padding for Layer III or multichannel Layer II */\n                if ((info.layer == 3 && data->config.fsb_padding) || data->config.fsb_padding == 16) {\n                    current_padding = (current_data_size % data->config.fsb_padding)\n                            ? data->config.fsb_padding - (current_data_size % data->config.fsb_padding)\n                            : 0;\n                }\n\n                data->config.interleave = current_data_size + current_padding; /* should be constant for all stream */\n            }\n            break;\n\n        case MPEG_P3D:\n        case MPEG_SCD:\n            if (data->config.interleave <= 0)\n                goto fail; /* needs external fixed size */\n            break;\n\n        case MPEG_LYN:\n            if (data->config.interleave <= 0)\n                goto fail; /* needs external fixed size */\n            data->default_buffer_size = data->config.interleave;\n            //todo simplify/unify XVAG/P3D/SCD/LYN and just feed arbitrary chunks to the decoder\n            break;\n\n        case MPEG_STANDARD:\n        case MPEG_AHX:\n        case MPEG_EA:\n            if (info.channels != data->config.channels)\n                goto fail; /* no multichannel expected */\n            break;\n\n        default:\n            break;  /* nothing special needed */\n    }\n\n\n    //todo: test more: this improves the output, but seems formats aren't usually prepared\n    // (and/or the num_samples includes all possible samples in file, so by discarding some it'll reach EOF)\n\n    /* set encoder delay (samples to skip at the beginning of a stream) if needed, which varies with encoder used */\n    switch(data->type) {\n        //case MPEG_AHX: data->skip_samples = 480; break; /* observed default */\n        //case MPEG_P3D: data->skip_samples = info.frame_samples; break; /* matches Radical ADPCM (PC) output */\n\n        /* FSBs (with FMOD DLLs) don't seem to need it. Particularly a few games (all from Wayforward?)\n         * contain audible garbage at the beginning, but it's actually there in-game too */\n        //case MPEG_FSB: data->skip_samples = 0; break;\n\n        case MPEG_XVAG: /* set in header and needed for gapless looping */\n            data->skip_samples = data->config.skip_samples; break;\n        case MPEG_STANDARD:\n            data->skip_samples = data->config.skip_samples; break;\n        case MPEG_EA:\n            /* typical MP2 decoder delay, verified vs sx.exe, also SCHl blocks header takes discard\n             * samples into account (so block_samples+240*2+1 = total frame samples) */\n            if (info.layer == 2) {\n                data->skip_samples = 240*2 + 1;\n            }\n            /* MP3 probably uses 576 + 528+1 but no known games use it */\n            break;\n        default:\n            break;\n    }\n    data->samples_to_discard = data->skip_samples;\n\n\n    return 1;\nfail:\n    return 0;\n}", "path": "vgmstream/src/coding/mpeg_custom_utils.c", "commit_date": "2020-11-06 00:00:00", "repo_name": "vgmstream/vgmstream", "stars": 1393, "license": "other", "language": "c", "size": 37865}
{"docstring": "/* EZWAVE - EZ2DJ (Arcade) */\n", "func_signal": "VGMSTREAM * init_vgmstream_ezw(STREAMFILE *streamFile)", "code": "{\n    VGMSTREAM * vgmstream = NULL;\n\toff_t start_offset, data_size;\n    int loop_flag, channel_count;\n\n    /* check extension, case insensitive */\n    if ( !check_extensions(streamFile,\"ezw\"))\n        goto fail;\n\n\n    loop_flag = 0;\n\tchannel_count = read_8bit(0x0, streamFile);\n\tdata_size = read_32bitLE(0xE,streamFile);\n\n\n    /* build the VGMSTREAM */\n    vgmstream = allocate_vgmstream(channel_count,loop_flag);\n    if (!vgmstream) goto fail;\n\n\n\tstart_offset = 0x12;\n    vgmstream->sample_rate = read_32bitLE(0x2,streamFile);\n\tvgmstream->coding_type = coding_PCM16LE;\n    vgmstream->num_samples = data_size/(channel_count*2);\n\tvgmstream->layout_type = layout_interleave;\n\tvgmstream->interleave_block_size = 0x2;\n    vgmstream->meta_type = meta_EZW;\n\n    /* open the file for reading */\n    if ( !vgmstream_open_stream(vgmstream, streamFile, start_offset) )\n        goto fail;\n    return vgmstream;\n\nfail:\n    close_vgmstream(vgmstream);\n    return NULL;\n}", "path": "vgmstream/src/meta/ezw.c", "commit_date": "2017-11-22 00:00:00", "repo_name": "vgmstream/vgmstream", "stars": 1393, "license": "other", "language": "c", "size": 37865}
{"docstring": "/* Mattel Hyperscan,\n- Place all metas for this console here (there are just 5 games) */\n", "func_signal": "VGMSTREAM * init_vgmstream_hyperscan_kvag(STREAMFILE *streamFile)", "code": "{\n    VGMSTREAM * vgmstream = NULL;\n    char filename[PATH_LIMIT];\n    off_t start_offset;\n    int loop_flag = 0;\n    int channel_count;\n\n    /* check extension, case insensitive */\n    streamFile->get_name(streamFile,filename,sizeof(filename));\n    if (strcasecmp(\"bvg\",filename_extension(filename))) goto fail;\n\n    /* check header */\n    if (read_32bitBE(0x00,streamFile) != 0x4B564147) /* \"KVAG\" */\n        goto fail;\n\n    channel_count = 1;\n    \n    /* build the VGMSTREAM */\n    vgmstream = allocate_vgmstream(channel_count,loop_flag);\n    if (!vgmstream) goto fail;\n\n    /* fill in the vital statistics */\n    start_offset = 0xE;\n    vgmstream->channels = channel_count;\n    vgmstream->sample_rate = read_32bitLE(0x8,streamFile);\n    vgmstream->coding_type = coding_DVI_IMA;\n    vgmstream->num_samples = read_32bitLE(0x4,streamFile)*2;\n\n#if 0\n    if (loop_flag) {\n        vgmstream->loop_start_sample = (read_32bitLE(0x08,streamFile)-1)*28;\n        vgmstream->loop_end_sample = (read_32bitLE(0x0c,streamFile)-1)*28;\n    }\n#endif\n\n    vgmstream->layout_type = layout_none;\n    vgmstream->meta_type = meta_HYPERSCAN_KVAG;\n\n    /* open the file for reading */\n    {\n        int i;\n        STREAMFILE * file;\n        file = streamFile->open(streamFile,filename,STREAMFILE_DEFAULT_BUFFER_SIZE);\n        if (!file) goto fail;\n        for (i=0;i<channel_count;i++) {\n            vgmstream->ch[i].streamfile = file;\n\n            vgmstream->ch[i].channel_start_offset=\n                vgmstream->ch[i].offset=start_offset+\n                vgmstream->interleave_block_size*i;\n\n        }\n    }\n\n    return vgmstream;\n\n    /* clean up anything we may have opened */\nfail:\n    if (vgmstream) close_vgmstream(vgmstream);\n    return NULL;\n}", "path": "vgmstream/src/meta/mattel_hyperscan.c", "commit_date": "2013-05-27 00:00:00", "repo_name": "vgmstream/vgmstream", "stars": 1393, "license": "other", "language": "c", "size": 37865}
{"docstring": "/* fully encrypted FSBs */\n", "func_signal": "VGMSTREAM* init_vgmstream_fsb_encrypted(STREAMFILE* sf)", "code": "{\n    VGMSTREAM* vgmstream = NULL;\n\n    /* checks */\n    /* .fsb: standard\n     * .fsb.xen: various Guitar Hero (X360/PC) */\n    if (!check_extensions(sf, \"fsb,xen\"))\n        goto fail;\n\n    /* ignore non-encrypted FSB */\n    if ((read_u32be(0x00,sf) & 0xFFFFFF00) == 0x46534200) /* \"FSB\\0\" */\n        goto fail;\n\n\n    /* try fsbkey + all combinations of FSB4/5 and decryption algorithms */\n    {\n        STREAMFILE* temp_sf = NULL;\n        uint8_t key[FSB_KEY_MAX];\n        size_t key_size = read_key_file(key, FSB_KEY_MAX, sf);\n\n        if (key_size) {\n            {\n                temp_sf = setup_fsb_streamfile(sf, key,key_size, 0);\n                if (!temp_sf) goto fail;\n\n                if (!vgmstream) vgmstream = init_vgmstream_fsb(temp_sf);\n                if (!vgmstream) vgmstream = init_vgmstream_fsb5(temp_sf);\n\n                close_streamfile(temp_sf);\n            }\n\n            if (!vgmstream) {\n                temp_sf = setup_fsb_streamfile(sf, key,key_size, 1);\n                if (!temp_sf) goto fail;\n\n                if (!vgmstream) vgmstream = init_vgmstream_fsb(temp_sf);\n                if (!vgmstream) vgmstream = init_vgmstream_fsb5(temp_sf);\n\n                close_streamfile(temp_sf);\n            }\n        }\n    }\n\n\n    /* try all keys until one works */\n    if (!vgmstream) {\n        int i;\n        STREAMFILE* temp_sf = NULL;\n\n        for (i = 0; i < fsbkey_list_count; i++) {\n            fsbkey_info entry = fsbkey_list[i];\n            //;VGM_LOG(\"fsbkey: size=%i, is_fsb5=%i, is_alt=%i\\n\", entry.fsbkey_size,entry.is_fsb5, entry.is_alt);\n\n            temp_sf = setup_fsb_streamfile(sf, entry.fsbkey, entry.fsbkey_size, entry.is_alt);\n            if (!temp_sf) goto fail;\n\n            if (fsbkey_list[i].is_fsb5) {\n                vgmstream = init_vgmstream_fsb5(temp_sf);\n            } else {\n                vgmstream = init_vgmstream_fsb(temp_sf);\n            }\n\n            //;if (vgmstream) dump_streamfile(temp_sf, 0);\n\n            close_streamfile(temp_sf);\n            if (vgmstream) break;\n        }\n    }\n\n    if (!vgmstream)\n        goto fail;\n\n    return vgmstream;\n\nfail:\n    close_vgmstream(vgmstream);\n    return NULL;\n}", "path": "vgmstream/src/meta/fsb_encrypted.c", "commit_date": "2020-08-15 00:00:00", "repo_name": "vgmstream/vgmstream", "stars": 1393, "license": "other", "language": "c", "size": 37865}
{"docstring": "/* BKHD - Wwise soundbank container */\n", "func_signal": "VGMSTREAM* init_vgmstream_bkhd(STREAMFILE* sf)", "code": "{\n    VGMSTREAM* vgmstream = NULL;\n    STREAMFILE* temp_sf = NULL;\n    off_t subfile_offset, base_offset = 0;\n    size_t subfile_size;\n    uint32_t subfile_id;\n    int big_endian, version, is_riff = 0, is_dummy = 0, is_wmid = 0;\n    uint32_t (*read_u32)(off_t,STREAMFILE*);\n    float (*read_f32)(off_t,STREAMFILE*);\n    int total_subsongs, target_subsong = sf->stream_index;\n\n\n    /* checks */\n    if (!check_extensions(sf,\"bnk\"))\n        goto fail;\n\n    if (read_u32be(0x00, sf) == 0x414B424B) /* \"AKBK\" [Shadowrun (X360)] */\n        base_offset = 0x0c;\n    if (read_u32be(base_offset + 0x00, sf) != 0x424B4844) /* \"BKHD\" */\n        goto fail;\n    big_endian = guess_endianness32bit(base_offset + 0x04, sf);\n    read_u32 = big_endian ? read_u32be : read_u32le;\n    read_f32 = big_endian ? read_f32be : read_f32le;\n\n\n    /* Wwise banks have event/track/sequence/etc info in the HIRC chunk, as well\n     * as other chunks, and may have a DATA/DIDX index to memory .wem in DATA.\n     * We support the internal .wem mainly for quick tests, as the HIRC is\n     * complex and better handled with TXTP (some info from Nicknine's script).\n     * Use this to explore HIRC and covert to .txtp: https://github.com/bnnm/wwiser */\n\n    version = read_u32(base_offset + 0x08, sf);\n    if (version == 0 || version == 1) { /* early games */\n        version = read_u32(base_offset + 0x10, sf);\n    }\n\n    /* first chunk also follows standard chunk sizes unlike RIFF */\n    if (version <= 26) {\n        off_t data_offset, data_start, offset;\n        if (!find_chunk(sf, 0x44415441, base_offset, 0, &data_offset, NULL, big_endian, 0)) /* \"DATA\" */\n            goto fail;\n\n        /* index:\n         * 00: entries\n         * 04: null\n         * 08: entries size\n         * 0c: padding size after entries\n         * 10: data size\n         * 14: size? or null\n         * 18: data start\n         * 1c: data size\n         * per entry:\n         *  00: always -1\n         *  04: always 0\n         *  08: index number or -1\n         *  0c: 5 or -1?\n         *  0c: 5 or -1?\n         *  0c: 5 or -1?\n         *  10: stream offset (from data start) or -1 if none\n         *  14: stream size or 0 if none\n         */\n\n        total_subsongs = read_u32(data_offset + 0x00, sf);\n        if (target_subsong == 0) target_subsong = 1;\n        if (target_subsong < 0 || target_subsong > total_subsongs || total_subsongs < 1) goto fail;\n\n        data_start = read_u32(data_offset + 0x18, sf);\n        offset = data_offset + 0x20 + (target_subsong - 1) * 0x18;\n\n        subfile_id      = read_u32(offset + 0x08, sf);\n        subfile_offset  = read_u32(offset + 0x10, sf) + data_offset + 0x20 + data_start;\n        subfile_size    = read_u32(offset + 0x14, sf);\n    }\n    else {\n        off_t didx_offset, data_offset, offset;\n        size_t didx_size;\n        if (!find_chunk(sf, 0x44494458, 0x00,0, &didx_offset, &didx_size, big_endian, 0)) /* \"DIDX\" */\n            goto fail;\n        if (!find_chunk(sf, 0x44415441, 0x00,0, &data_offset, NULL, big_endian, 0)) /* \"DATA\" */\n            goto fail;\n\n        total_subsongs = didx_size / 0x0c;\n        if (target_subsong == 0) target_subsong = 1;\n        if (target_subsong < 0 || target_subsong > total_subsongs || total_subsongs < 1) goto fail;\n\n        offset = didx_offset + (target_subsong - 1) * 0x0c;\n        subfile_id      = read_u32(offset + 0x00, sf);\n        subfile_offset  = read_u32(offset + 0x04, sf) + data_offset;\n        subfile_size    = read_u32(offset + 0x08, sf);\n    }\n    \n    //;VGM_LOG(\"BKHD: %lx, %x\\n\", subfile_offset, subfile_size);\n\n    /* detect format */\n    if (subfile_offset <= 0 || subfile_size <= 0) {\n        /* some indexes don't have data */\n        is_dummy = 1;\n    }\n    else if (read_u32be(subfile_offset + 0x00, sf) == 0x52494646 || /* \"RIFF\" */\n             read_u32be(subfile_offset + 0x00, sf) == 0x52494658) { /* \"RIFX\" */\n        is_riff = 1;\n    }\n    else if (read_f32(subfile_offset + 0x02, sf) >= 30.0 && \n             read_f32(subfile_offset + 0x02, sf) <= 250.0) {\n        /* ignore Wwise's custom .wmid (similar to a regular midi but with simplified\n         *  chunks and custom fields: 0x00=MThd's division, 0x02: bpm (new), etc) */\n        is_wmid = 1;\n    }\n    /* default is sfx */\n\n\n    if (is_dummy || is_wmid) {\n        /* for now leave a dummy song for easier .bnk index-to-subsong mapping */\n        vgmstream = init_vgmstream_silence(0, 0, 0);\n        if (!vgmstream) goto fail;\n    }\n    else {\n        /* could pass .wem but few files need memory .wem detection */\n        temp_sf = setup_subfile_streamfile(sf, subfile_offset, subfile_size, NULL);\n        if (!temp_sf) goto fail;\n\n        if (is_riff) {\n            vgmstream = init_vgmstream_wwise(temp_sf);\n            if (!vgmstream) goto fail;\n        }\n        else {\n            vgmstream = init_vgmstream_bkhd_fx(temp_sf);\n            if (!vgmstream) goto fail;\n        }\n    }\n\n\n    vgmstream->num_streams = total_subsongs;\n\n    {\n        const char* info = NULL;\n        if (is_dummy)\n            info = \"dummy\";\n        else if (is_wmid)\n            info = \"wmid\";\n\n        /* old Wwise shows index or (more often) -1, unify to index*/\n        if (subfile_id == 0xFFFFFFFF)\n            subfile_id = target_subsong - 1;\n\n        if (info)\n            snprintf(vgmstream->stream_name, STREAM_NAME_SIZE, \"%u/%s\", subfile_id, info);\n        else\n            snprintf(vgmstream->stream_name, STREAM_NAME_SIZE, \"%u\", subfile_id);\n    }\n\n    close_streamfile(temp_sf);\n    return vgmstream;\n\nfail:\n    close_streamfile(temp_sf);\n    close_vgmstream(vgmstream);\n    return NULL;\n}", "path": "vgmstream/src/meta/bkhd.c", "commit_date": "2020-11-14 00:00:00", "repo_name": "vgmstream/vgmstream", "stars": 1393, "license": "other", "language": "c", "size": 37865}
{"docstring": "/* MC3 3-bit ADPCM (Paradigm Entertainment games).\n *\n * Layout: blocks with 32b header + 32b ch1, 32b ch2, 32b ch1...\n * Each 32b is a sub-block with 10 samples (3b x10) sharing a 'mode' of sorts.\n * More than one block is rarely used though.\n *\n * Tables and original algorithm by daemon1\n */\n", "func_signal": "void decode_mc3(VGMSTREAM * vgmstream, VGMSTREAMCHANNEL * stream, sample * outbuf, int channelspacing, int32_t first_sample, int32_t samples_to_do, int channel)", "code": "{\n    int i, sample_count = 0;\n\n    int32_t hist = stream->adpcm_history1_32;\n    int step_index = stream->adpcm_step_index;\n\n    /* internal interleave */\n    int block_samples = (vgmstream->interleave_block_size - 4) / 4 / vgmstream->channels * 10;\n    first_sample = first_sample % block_samples;\n\n\n    /* block header */\n    if (first_sample == 0) {\n        uint32_t header = (uint32_t)read_32bitLE(stream->offset, stream->streamfile);\n        header = (header >> channel*16);        /* lower 16=ch1, upper 16b=ch2 */\n        step_index = header & 0x3f;             /* 6b */\n        hist       = header & 0xffc0;           /* 16b sans 6b */\n        if (hist > 0x7fff) hist -= 0x10000;     /* sign extend */\n    }\n\n\n    /* block samples */\n    for (i = first_sample; i < first_sample + samples_to_do; i++) {\n        uint32_t subblock, mode, samples, index, sign, diff;\n\n        /* header + ch shift + sub-block number (ex. ch0 i=10: sub-block 1, ch0 i=23: sub-block 2) */\n        off_t subblock_offset = stream->offset + 4 + 4*channel + (i/10)*(4*vgmstream->channels);\n        int sample_shift = (i%10)*3;\n\n        /* expand 3b */\n        subblock = (uint32_t)read_32bitLE(subblock_offset, stream->streamfile);\n        mode     = (subblock >> 30) & 0x3;  /* upper 2b */\n        samples  = (subblock) & 0x3FFFFFFF; /* lower 3b*10 */\n\n        index    = (samples >> sample_shift) & 3; /* lower 2b */\n        sign     = (samples >> sample_shift) & 4; /* upper 1b */\n        diff     = mc3_table[mode][index][step_index];\n        if (sign == 0) \n            hist += (- 1 - diff);\n        else\n            hist += diff;\n\n        /* new step + clamp */\n        step_index += step_table[index];\n        if (step_index < 0) step_index = 0;\n        else if (step_index > 63) step_index = 63;\n\n        /* output */\n        outbuf[sample_count] = hist;\n        sample_count += channelspacing;\n    }\n\n\n    /* internal interleave: increment offset on complete frame */\n    if (i == block_samples) stream->offset += vgmstream->interleave_block_size;\n\n    stream->adpcm_history1_32 = hist;\n    stream->adpcm_step_index  = step_index;\n}", "path": "vgmstream/src/coding/mc3_decoder.c", "commit_date": "2017-04-28 00:00:00", "repo_name": "vgmstream/vgmstream", "stars": 1393, "license": "other", "language": "c", "size": 37865}
{"docstring": "/* variation of the above, for clean streams = no ID3/VBR headers\n * (maybe should be fused in a single thing with config, API is kinda messy too) */\n", "func_signal": "int32_t mpeg_get_samples_clean(STREAMFILE *sf, off_t start, size_t size, size_t* p_loop_start, size_t* p_loop_end, int is_vbr)", "code": "{\n    mpeg_frame_info info;\n    off_t offset = start;\n    int32_t num_samples = 0, loop_start = 0, loop_end = 0;\n\n    if (!is_vbr) {\n        /* CBR = quick calcs */\n        if (!mpeg_get_frame_info(sf, offset, &info))\n            goto fail;\n\n        num_samples = size / info.frame_size * info.frame_samples;\n        loop_start = *p_loop_start / info.frame_size * info.frame_samples;\n        loop_end = *p_loop_end / info.frame_size * info.frame_samples;\n    }\n    else {\n        /* VBR (or unknown) = count frames */\n        while (offset < start + size) {\n            if (!mpeg_get_frame_info(sf, offset, &info))\n                goto fail;\n\n            if (*p_loop_start + start == offset)\n                loop_start = num_samples;\n\n            num_samples += info.frame_samples;\n            offset += info.frame_size;\n\n            if (*p_loop_end + start == offset)\n                loop_end = num_samples;\n        }\n    }\n\n\n    *p_loop_start = loop_start;\n    *p_loop_end = loop_end;\n\n    return num_samples;\nfail:\n    VGM_LOG(\"MPEG: sample reader failed at %lx\\n\", offset);\n    return 0;\n}", "path": "vgmstream/src/coding/mpeg_custom_utils.c", "commit_date": "2020-11-06 00:00:00", "repo_name": "vgmstream/vgmstream", "stars": 1393, "license": "other", "language": "c", "size": 37865}
{"docstring": "/* BNSF - Bandai Namco Sound Format/File [Tales of Graces (Wii), Tales of Berseria (PS4)] */\n", "func_signal": "VGMSTREAM * init_vgmstream_bnsf(STREAMFILE *streamFile)", "code": "{\n    VGMSTREAM * vgmstream = NULL;\n    off_t start_offset = 0, first_offset = 0x0C;\n    int loop_flag = 0, channel_count = 0, sample_rate;\n    int num_samples, loop_start = 0, loop_end = 0, loop_adjust, block_samples;\n    uint32_t codec, flags = 0;\n    size_t bnsf_size, sdat_size, block_size;\n    off_t loop_chunk = 0, sfmt_chunk, sdat_chunk;\n\n\n    /* checks */\n    if (!check_extensions(streamFile,\"bnsf\"))\n        goto fail;\n    if (read_32bitBE(0,streamFile) != 0x424E5346) /* \"BNSF\" */\n        goto fail;\n\n    bnsf_size = read_32bitBE(0x04,streamFile);\n    codec = read_32bitBE(0x08,streamFile);\n\n    if (bnsf_size + (codec == 0x49533232 ? 0x00 : 0x08) != get_streamfile_size(streamFile)) /* IS22 uses full size */\n        goto fail;\n\n    if (!find_chunk_be(streamFile, 0x73666d74,first_offset,0, &sfmt_chunk,NULL)) /* \"sfmt\" */\n        goto fail;\n    if (!find_chunk_be(streamFile, 0x73646174,first_offset,0, &sdat_chunk,&sdat_size)) /* \"sdat\" */\n        goto fail;\n    if ( find_chunk_be(streamFile, 0x6C6F6F70,first_offset,0, &loop_chunk,NULL)) { /* \"loop\" */\n        loop_flag = 1;\n        loop_start = read_32bitBE(loop_chunk+0x00,streamFile); /* block-aligned */\n        loop_end   = read_32bitBE(loop_chunk+0x04,streamFile) + 1;\n    }\n\n    flags         = read_16bitBE(sfmt_chunk+0x00,streamFile);\n    channel_count = read_16bitBE(sfmt_chunk+0x02,streamFile);\n    sample_rate   = read_32bitBE(sfmt_chunk+0x04,streamFile);\n    num_samples   = read_32bitBE(sfmt_chunk+0x08,streamFile);\n    loop_adjust   = read_32bitBE(sfmt_chunk+0x0c,streamFile); /* 0 when no loop */\n    block_size    = read_16bitBE(sfmt_chunk+0x10,streamFile);\n    block_samples = read_16bitBE(sfmt_chunk+0x12,streamFile);\n    //max_samples = sdat_size / block_size * block_samples;\n\n    start_offset = sdat_chunk;\n\n    if (loop_adjust >= block_samples) /* decoder can't handle this */\n        goto fail;\n\n\n    /* build the VGMSTREAM */\n    vgmstream = allocate_vgmstream(channel_count, loop_flag);\n    if (!vgmstream) goto fail;\n\n    vgmstream->sample_rate = sample_rate;\n    vgmstream->num_samples = num_samples;\n    vgmstream->loop_start_sample = loop_start + loop_adjust;\n    vgmstream->loop_end_sample = loop_end;\n\n    vgmstream->meta_type = meta_BNSF;\n    vgmstream->layout_type = layout_interleave;\n    vgmstream->interleave_block_size = block_size / channel_count;\n\n    switch (codec) {\n#ifdef VGM_USE_G7221\n        case 0x49533134: /* \"IS14\" (interleaved Siren14) */\n            vgmstream->coding_type = coding_G7221C;\n            vgmstream->codec_data = init_g7221(vgmstream->channels, vgmstream->interleave_block_size);\n            if (!vgmstream->codec_data) goto fail;\n\n            /* get decryption key in .bnsfkey file or list, for later games' voices\n             * [The Idolm@ster 2 (PS3/X360), Tales of Zestiria (PS3/PC)] */\n            if (flags != 0) { /* only known value is 0x02 though */\n                size_t keysize;\n                uint8_t key[24] = {0}; /* keystring 0-padded to 192-bit */\n\n                keysize = read_key_file(key, sizeof(key), streamFile);\n#ifdef BNSF_BRUTEFORCE\n                if (1) {\n                    bruteforce_bnsf_key(streamFile, start_offset, vgmstream->codec_data, key);\n                } else\n#endif\n                if (keysize <= 0 || keysize > sizeof(key)) {\n                    find_bnsf_key(streamFile, start_offset, vgmstream->codec_data, key);\n                }\n                set_key_g7221(vgmstream->codec_data, key);\n            }\n\n            break;\n#endif\n#ifdef VGM_USE_G719\n        case 0x49533232: /* \"IS22\" (interleaved Siren22) */\n\n            /* same encryption as IS14 but not seen */\n            if (flags != 0)\n                goto fail;\n\n            vgmstream->coding_type = coding_G719;\n            vgmstream->codec_data = init_g719(vgmstream->channels, vgmstream->interleave_block_size);\n            if (!vgmstream->codec_data) goto fail;\n\n            break;\n#endif\n        default:\n            goto fail;\n    }\n\n\n    if (!vgmstream_open_stream(vgmstream,streamFile,start_offset))\n        goto fail;\n    return vgmstream;\n\nfail:\n    close_vgmstream(vgmstream);\n    return NULL;\n}", "path": "vgmstream/src/meta/bnsf.c", "commit_date": "2020-04-05 00:00:00", "repo_name": "vgmstream/vgmstream", "stars": 1393, "license": "other", "language": "c", "size": 37865}
{"docstring": "/* blocks with mini header (0x48124812 + unknown + block data + block size) */\n", "func_signal": "void block_update_ps2_iab(off_t block_offset, VGMSTREAM * vgmstream)", "code": "{\n    STREAMFILE* streamFile = vgmstream->ch[0].streamfile;\n    int i;\n    size_t block_size, channel_size;\n\n    channel_size = read_32bitLE(block_offset+0x08,streamFile) / vgmstream->channels;\n    block_size = read_32bitLE(block_offset+0x0c,streamFile);\n    if (!block_size)\n        block_size = 0x10; /* happens on last block */\n\n    vgmstream->current_block_size = channel_size;\n    vgmstream->current_block_offset = block_offset;\n    vgmstream->next_block_offset = block_offset + block_size;\n\n    for (i = 0; i < vgmstream->channels; i++) {\n        vgmstream->ch[i].offset = block_offset + 0x10 + channel_size*i;\n    }\n}", "path": "vgmstream/src/layout/blocked_ps2_iab.c", "commit_date": "2018-04-13 00:00:00", "repo_name": "vgmstream/vgmstream", "stars": 1393, "license": "other", "language": "c", "size": 37865}
{"docstring": "/* bruteforce keys in a string list extracted from executables or files near sound data, trying variations. */\n", "func_signal": "static void bruteforce_bnsf_key(STREAMFILE* sf, off_t start, g7221_codec_data* data, uint8_t* best_key)", "code": "{\n    STREAMFILE* sf_keys = NULL;\n    int best_score = -1;\n    int i, j;\n    char line[1024];\n    int bytes, line_ok;\n    off_t offset;\n    size_t keys_size;\n\n\n    VGM_LOG(\"BNSF: test keys\\n\");\n\n    sf_keys = open_streamfile_by_filename(sf, \"keys.txt\");\n    if (!sf_keys) goto done;\n    \n    keys_size = get_streamfile_size(sf_keys);\n    \n    offset = 0x00;\n    while (offset < keys_size) {\n        int line_len;\n\n        bytes = read_line(line, sizeof(line), offset, sf_keys, &line_ok);\n        if (!line_ok) break;\n\n        offset += bytes;\n\n        line_len = strlen(line);\n        for (i = 0; i < line_len - BNSF_MIN_KEY_LEN; i++) {\n            for (j = i + BNSF_MIN_KEY_LEN; j <= line_len; j++) {\n                int keylen = j - i;\n                const char* key = &line[i];\n                \n                test_key(sf, start, data, key, keylen, &best_score, best_key);\n                if (best_score == 1) {\n                    VGM_ASSERT(best_score > 0, \"BNSF: good key=%.24s (score=%i)\\n\", best_key, best_score);\n                    //goto done;\n                }\n            }\n        }\n    }\n\n//done:\n    VGM_ASSERT(best_score > 0, \"BNSF: best key=%.24s (score=%i)\\n\", best_key, best_score);\n    VGM_ASSERT(best_score < 0, \"BNSF: key not found\\n\");\n\n    close_streamfile(sf_keys);\n}", "path": "vgmstream/src/meta/bnsf.c", "commit_date": "2020-04-05 00:00:00", "repo_name": "vgmstream/vgmstream", "stars": 1393, "license": "other", "language": "c", "size": 37865}
{"docstring": "/* writes data to the buffer and moves offsets */\n", "func_signal": "int mpeg_custom_parse_frame_default(VGMSTREAMCHANNEL* stream, mpeg_codec_data* data, int num_stream)", "code": "{\n    mpeg_custom_stream *ms = data->streams[num_stream];\n    mpeg_frame_info info;\n    size_t current_data_size = 0;\n    size_t current_padding = 0;\n    size_t current_interleave_pre = 0; /* interleaved data size before current stream */\n    size_t current_interleave_post = 0; /* interleaved data size after current stream */\n    size_t current_interleave = 0; /* interleave in this block (usually this + pre + post = interleave*streams = block) */\n\n\n    /* Get data size to give to the decoder, per stream. Usually 1 frame at a time,\n     * but doesn't really need to be a full frame (decoder would request more data). */\n    switch(data->type) {\n\n        case MPEG_XVAG: /* frames of fixed size (though we could read frame info too) */\n            current_interleave = data->config.interleave; /* big interleave */\n            current_interleave_pre  = current_interleave*num_stream;\n            current_interleave_post = current_interleave*(data->streams_size-1) - current_interleave_pre;\n\n            current_data_size = data->config.chunk_size;\n            break;\n\n        case MPEG_FSB: /* frames with padding + interleave */\n            current_interleave = data->config.interleave; /* constant for multi-stream FSbs (1 frame + padding) */\n            current_interleave_pre  = current_interleave*num_stream;\n            current_interleave_post = current_interleave*(data->streams_size-1) - current_interleave_pre;\n\n            if (!mpeg_get_frame_info(stream->streamfile, stream->offset + current_interleave_pre, &info))\n                goto fail;\n            current_data_size = info.frame_size;\n\n            /* get FSB padding for Layer III or multichannel Layer II (Layer I isn't supported by FMOD).\n             * Padding sometimes contains garbage like the next frame header so we can't feed it to mpg123 or it gets confused. */\n            if ((info.layer == 3 && data->config.fsb_padding) || data->config.fsb_padding == 16) {\n                current_padding = (current_data_size % data->config.fsb_padding)\n                        ? data->config.fsb_padding - (current_data_size % data->config.fsb_padding)\n                        : 0;\n\n                /* Rare Mafia II (PS3) bug (GP_0701_music multilang only): some frame paddings \"4\" are incorrect,\n                 * calcs give 0xD0+0x00 but need 0xD0+0x04 (unlike all other fsbs, which never do that).\n                 * FMOD tools decode fine, so they may be doing special detection too, since even\n                 * re-encoding the same file and using the same FSB flags/modes won't trigger the bug. */\n                if (info.layer == 3 && data->config.fsb_padding == 4 && current_data_size == 0xD0) {\n                    uint32_t next_header;\n                    off_t next_offset;\n\n                    next_offset = stream->offset + current_data_size + current_padding;\n                    if (current_interleave && ((next_offset - stream->channel_start_offset + current_interleave_pre + current_interleave_post) % current_interleave == 0)) {\n                        next_offset += current_interleave_pre + current_interleave_post;\n                    }\n\n                    next_header = read_32bitBE(next_offset, stream->streamfile);\n                    if ((next_header & 0xFFE00000) != 0xFFE00000) { /* doesn't land in a proper frame, fix sizes and hope */\n                        VGM_LOG_ONCE(\"MPEG FSB: stream with wrong padding found\\n\");\n                        current_padding = 0x04;\n                    }\n                }\n\n            }\n\n            VGM_ASSERT(data->streams_size > 1 && current_interleave != current_data_size+current_padding,\n                    \"MPEG FSB: %i streams with non-constant interleave found @ 0x%08x\\n\", data->streams_size, (uint32_t)stream->offset);\n            break;\n\n        case MPEG_P3D: /* fixed interleave, not frame-aligned (ie. blocks may end/start in part of a frame) */\n        case MPEG_SCD:\n        case MPEG_LYN:\n            current_interleave = data->config.interleave;\n\n            /* check if current interleave block is short */\n            {\n                off_t block_offset = stream->offset - stream->channel_start_offset;\n                size_t next_block = data->streams_size*data->config.interleave;\n\n                if (data->config.data_size && block_offset + next_block >= data->config.data_size)\n                    current_interleave = (data->config.data_size % next_block) / data->streams_size; /* short_interleave*/\n            }\n\n            current_interleave_pre  = current_interleave*num_stream;\n            current_interleave_post = current_interleave*(data->streams_size-1) - current_interleave_pre;\n\n            current_data_size = current_interleave;\n            break;\n\n        default: /* standard frames (CBR or VBR) */\n            if ( !mpeg_get_frame_info(stream->streamfile, stream->offset, &info) )\n                goto fail;\n            current_data_size = info.frame_size;\n            break;\n    }\n    if (!current_data_size || current_data_size > ms->buffer_size) {\n        VGM_LOG(\"MPEG: incorrect data_size 0x%x vs buffer 0x%x\\n\", current_data_size, ms->buffer_size);\n        goto fail;\n    }\n\n    /* This assumes all streams' offsets start in the first stream, and advances\n     * the 'full interleaved block' at once, ex:\n     *  start at s0=0x00, s1=0x00, interleave=0x40 (block = 0x40*2=0x80)\n     *  @0x00 read 0x40 of s0, skip 0x40 of s1 (block of 0x80 done) > new offset = 0x80\n     *  @0x00 skip 0x40 of s0, read 0x40 of s1 (block of 0x80 done) > new offset = 0x800\n     */\n\n    /* read chunk (skipping other interleaves if needed) */\n    ms->bytes_in_buffer = read_streamfile(ms->buffer,stream->offset + current_interleave_pre, current_data_size, stream->streamfile);\n\n\n    /* update offsets and skip other streams */\n    stream->offset += current_data_size + current_padding;\n\n    /* skip rest of block (interleave per stream) once this stream's interleaved data is done, if defined */\n    if (current_interleave && ((stream->offset - stream->channel_start_offset + current_interleave_pre + current_interleave_post) % current_interleave == 0)) {\n        stream->offset += current_interleave_pre + current_interleave_post;\n    }\n\n\n    return 1;\nfail:\n    return 0;\n}", "path": "vgmstream/src/coding/mpeg_custom_utils.c", "commit_date": "2020-11-06 00:00:00", "repo_name": "vgmstream/vgmstream", "stars": 1393, "license": "other", "language": "c", "size": 37865}
{"docstring": "/* BKHD mini format, for FX plugins [Borderlands 2 (X360), Warhammer 40000 (PC)] */\n", "func_signal": "VGMSTREAM* init_vgmstream_bkhd_fx(STREAMFILE* sf)", "code": "{\n    VGMSTREAM* vgmstream = NULL;\n    off_t start_offset, data_size;\n    int big_endian, loop_flag, channels, sample_rate, entries;\n    uint32_t (*read_u32)(off_t,STREAMFILE*);\n\n\n    /* checks */\n    /* .wem: used when (rarely) external */\n    if (!check_extensions(sf,\"wem,bnk\"))\n        goto fail;\n    big_endian = guess_endianness32bit(0x00, sf);\n    read_u32 = big_endian ? read_u32be : read_u32le;\n\n    /* Not an actual stream but typically convolution reverb models and other FX plugin helpers.\n     * Useless but to avoid \"subsong not playing\" complaints. */\n\n    if (read_u32(0x00, sf) == 0x0400 &&\n        read_u32(0x04, sf) == 0x0800) {\n        sample_rate = read_u32(0x08, sf);\n        channels    = read_u32(0x0c, sf) & 0xFF; /* 0x31 at 0x0d in PC, field is 32b vs X360 */\n        /* 0x10: some id or small size? (related to entries?) */\n        /* 0x14/18: some float? */\n        entries     = read_u32(0x1c, sf);\n        /* 0x20 data size / 0x10 */\n        /* 0x24 usually 4, sometimes higher values? */\n        /* 0x30: unknown table of 16b that goes up and down, or is fixed */\n\n        start_offset = 0x30 + align_size_to_block(entries * 0x02, 0x10);\n        data_size = get_streamfile_size(sf) - start_offset;\n    }\n    else if (read_u32be(0x04, sf) == 0x00004844 && /* floats actually? */\n             read_u32be(0x08, sf) == 0x0000FA45 &&\n             read_u32be(0x1c, sf) == 0x80000000) {\n        /* seen in Crucible banks */\n        sample_rate = 48000; /* meh */\n        channels    = 1;\n\n        start_offset = 0;\n        data_size = get_streamfile_size(sf);\n        big_endian = 0;\n    }\n    else {\n        goto fail;\n    }\n\n    loop_flag = 0;\n\n\n    /* data seems divided in chunks of 0x2000 */\n\n    /* build the VGMSTREAM */\n    vgmstream = allocate_vgmstream(channels, loop_flag);\n    if (!vgmstream) goto fail;\n\n    vgmstream->meta_type = meta_WWISE_FX;\n    vgmstream->sample_rate = sample_rate;\n\n    vgmstream->coding_type = coding_PCMFLOAT;\n    vgmstream->layout_type = layout_interleave;\n    vgmstream->codec_endian = big_endian;\n    vgmstream->interleave_block_size = 0x4;\n\n    vgmstream->num_samples = pcm_bytes_to_samples(data_size, channels, 32);\n\n    if (!vgmstream_open_stream(vgmstream, sf, start_offset))\n        goto fail;\n    return vgmstream;\nfail:\n    close_vgmstream(vgmstream);\n    return NULL;\n}", "path": "vgmstream/src/meta/bkhd.c", "commit_date": "2020-11-14 00:00:00", "repo_name": "vgmstream/vgmstream", "stars": 1393, "license": "other", "language": "c", "size": 37865}
{"docstring": "/* AIFF/AIFF-C (Audio Interchange File Format - Compressed) - Apple format, from Mac/3DO/other games */\n", "func_signal": "VGMSTREAM* init_vgmstream_aifc(STREAMFILE* sf)", "code": "{\n    VGMSTREAM* vgmstream = NULL;\n    off_t start_offset = 0, coef_offset = 0;\n    size_t file_size;\n    coding_t coding_type = 0;\n    int channels = 0, sample_count = 0, sample_size = 0, sample_rate = 0;\n    int interleave = 0;\n    int loop_flag = 0;\n    int32_t loop_start = 0, loop_end = 0;\n\n    int is_aiff_ext = 0, is_aifc_ext = 0, is_aiff = 0, is_aifc = 0;\n    int fver_found = 0, comm_found = 0, data_found = 0;\n    off_t mark_offset = 0, inst_offset = 0;\n\n\n    /* checks */\n    /* .aif: common (AIFF or AIFC), .aiff: common AIFF, .aifc: common AIFC\n     * .laif/laifc/laiff: for plugins\n     * .aifcl/aiffl: for plugins?\n     * .cbd2: M2 games\n     * .bgm: Super Street Fighter II Turbo (3DO)\n     * .acm: Crusader - No Remorse (SAT)\n     * .adp: Sonic Jam (SAT)\n     * .ai: Dragon Force (SAT)\n     * (extensionless: Doom (3DO)\n     * .fda: Homeworld 2 (PC)\n     * .n64: Turok (N64) src */\n    if (check_extensions(sf, \"aif,laif,\")) {\n        is_aifc_ext = 1;\n        is_aiff_ext = 1;\n    }\n    else if (check_extensions(sf, \"aifc,laifc,aifcl,afc,cbd2,bgm,fda,n64\")) {\n        is_aifc_ext = 1;\n    }\n    else if (check_extensions(sf, \"aiff,laiff,acm,adp,ai,aiffl\")) {\n        is_aiff_ext = 1;\n    }\n    else {\n        goto fail;\n    }\n\n    file_size = get_streamfile_size(sf);\n    if (read_u32be(0x00,sf) != 0x464F524D &&  /* \"FORM\" */\n        read_u32be(0x04,sf)+0x08 != file_size)\n        goto fail;\n\n    /* AIFF originally allowed only PCM (non-compressed) audio, so newer AIFC was added,\n     * though some AIFF with other codecs exist */\n    if (read_u32be(0x08,sf) == 0x41494643) { /* \"AIFC\" */\n        if (!is_aifc_ext) goto fail;\n        is_aifc = 1;\n    }\n    else if (read_u32be(0x08,sf) == 0x41494646) { /* \"AIFF\" */\n        if (!is_aiff_ext) goto fail;\n        is_aiff = 1;\n    }\n    else {\n        goto fail;\n    }\n\n\n    /* read through chunks to verify format and find metadata */\n    {\n        off_t offset = 0x0c; /* start with first chunk within FORM */\n\n        while (offset < file_size) {\n            uint32_t chunk_type = read_u32be(offset + 0x00,sf);\n            uint32_t chunk_size = read_u32be(offset + 0x04,sf);\n\n            /* chunks must be padded to an even number of bytes but chunk\n             * size does not include that padding */\n            if (chunk_size % 2)\n                chunk_size++;\n\n            offset += 0x08;\n            if (offset + chunk_size > file_size)\n                goto fail;\n\n            switch(chunk_type) {\n                case 0x46564552:    /* \"FVER\" (version info, required) */\n                    if (fver_found) goto fail;\n                    if (is_aiff) goto fail; /* plain AIFF shouldn't have */\n                    fver_found = 1;\n\n                    if (chunk_size != 4)\n                        goto fail;\n                    /* Version 1 of AIFF-C spec timestamp */\n                    if (read_u32be(offset + 0x00,sf) != 0xA2805140)\n                        goto fail;\n                    break;\n\n                case 0x434F4D4D:    /* \"COMM\" (main header) */\n                    if (comm_found) goto fail;\n                    comm_found = 1;\n\n                    channels = read_u16be(offset + 0x00,sf);\n                    if (channels <= 0) goto fail;\n\n                    sample_count = read_u32be(offset + 0x02,sf); /* sample_frames in theory, depends on codec */\n                    sample_size  = read_u16be(offset + 0x06,sf);\n                    sample_rate  = read_f80be(offset + 0x08,sf);\n\n                    if (is_aifc) {\n                        uint32_t codec = read_u32be(offset + 0x12,sf);\n                        /* followed by \"pascal string\": name size + human-readable name (full count padded to even size)  */\n\n                        switch (codec) {\n                            case 0x53445832:    /* \"SDX2\" [3DO games: Super Street Fighter II Turbo (3DO), etc] */\n                                /* \"2:1 Squareroot-Delta-Exact compression\" */\n                                coding_type = coding_SDX2;\n                                interleave = 0x01;\n                                break;\n\n                            case 0x43424432:    /* \"CBD2\" [M2 (arcade 3DO) games: IMSA Racing (M2), etc] */\n                                /* \"2:1 Cuberoot-Delta-Exact compression\" */\n                                coding_type = coding_CBD2;\n                                interleave = 0x01;\n                                break;\n\n                            case 0x41445034:    /* \"ADP4\" */\n                                coding_type = coding_DVI_IMA_int;\n                                if (channels != 1) break; /* don't know how stereo DVI is laid out */\n                                break;\n\n                            case 0x696D6134:    /* \"ima4\"  [Alida (PC), Lunar SSS (iOS)] */\n                                /* \"IMA 4:1FLLR\" */\n                                coding_type = coding_APPLE_IMA4;\n                                interleave = 0x22;\n                                sample_count = sample_count * ((interleave-0x2)*2);\n                                break;\n\n                            case 0x434F4D50: {  /* \"COMP\" (generic compression) */\n                                uint8_t name_size = read_u8(offset + 0x16, sf);\n\n                                if (is_str(\"Relic Codec v1.6\", name_size, offset + 0x17, sf)) {\n                                    coding_type = coding_RELIC;\n                                    sample_count = sample_count * 512;\n                                }\n                                else {\n                                    goto fail;\n                                }\n                                break;\n                            }\n\n                            case 0x56415043: {  /* \"VAPC\" [N64 (SDK mainly but apparently may exist in ROMs)] */\n                                /* \"VADPCM ~4-1\" */\n                                coding_type = coding_VADPCM;\n\n                                /* N64 tools don't create FVER, but it's required by the spec (could skip the check though) */\n                                fver_found = 1;\n                                break;\n                            }\n\n                            default:\n                                VGM_LOG(\"AIFC: unknown codec\\n\");\n                                goto fail;\n                        }\n                    }\n                    else if (is_aiff) {\n                        switch (sample_size) {\n                            case 8:\n                                coding_type = coding_PCM8;\n                                interleave = 1;\n                                break;\n                            case 16:\n                                coding_type = coding_PCM16BE;\n                                interleave = 2;\n                                break;\n                            case 4: /* Crusader: No Remorse (SAT), Road Rash (3DO) */\n                                coding_type = coding_XA;\n                                break;\n                            default:\n                                VGM_LOG(\"AIFF: unknown codec\\n\");\n                                goto fail;\n                        }\n                    }\n                    break;\n\n                case 0x53534E44:    /* \"SSND\" (main data) */\n                case 0x4150434D:    /* \"APCM\" (main data for XA) */\n                    if (data_found) goto fail;\n                    data_found = 1;\n\n                    /* 00: offset (for aligment, usually 0)\n                     * 04: block size (ex. XA: 0x914) */\n                    start_offset = offset + 0x08 + read_u32be(offset + 0x00,sf);\n                    break;\n\n                case 0x4D41524B:    /* \"MARK\" (loops) */\n                    mark_offset = offset;\n                    break;\n\n                case 0x494E5354:    /* \"INST\" (loops) */\n                    inst_offset = offset;\n                    break;\n\n                case 0x4150504C:    /* \"APPL\" (application specific) */\n                    if (is_str(\"stoc\", 0, offset + 0x00, sf)) {\n                        uint8_t name_size = read_u8(offset + 0x4, sf);\n                        off_t next_offset = offset + 0x04 + align_size_to_block(0x1 + name_size, 0x02);\n\n                        /* chunks appears multiple times per substring */\n                        if (is_str(\"VADPCMCODES\", name_size, offset + 0x05, sf)) {\n                            coef_offset = next_offset;\n                        }\n                        else if (is_str(\"VADPCMLOOPS\", name_size, offset + 0x05, sf)) {\n                            /* goes with inst (spec says app chunks have less priority than inst+mark loops) */\n                            int version = read_u16be(next_offset + 0x00, sf);\n                            int loops   = read_u16be(next_offset + 0x02, sf);\n                            if (version != 1 || loops != 1) goto fail;\n\n                            loop_start  = read_u32be(next_offset + 0x04, sf);\n                            loop_end    = read_u32be(next_offset + 0x08, sf);\n                            loop_flag   = read_s32be(next_offset + 0x08, sf) != 0; /*-1 = infinite */\n                            /* 0x10: ADPCM state[16] (hists?) */\n                        }\n                        else {\n                            VGM_LOG(\"AIFC: unknown APPL chunk\\n\");\n                            goto fail;\n                        }\n                    }\n                    break;\n\n                default:\n                    break;\n            }\n\n            offset += chunk_size;\n        }\n    }\n\n    if (is_aifc) {\n        if (!fver_found || !comm_found || !data_found)\n            goto fail;\n    } else if (is_aiff) {\n        if (!comm_found || !data_found)\n            goto fail;\n    }\n\n\n    /* read loop points */\n    if (inst_offset && mark_offset) {\n        int start_marker;\n        int end_marker;\n\n        /* use the 'sustain loop', if playMode=ForwardLooping */\n        if (read_u16be(inst_offset + 0x08,sf) == 1) {\n            start_marker = read_u16be(inst_offset + 0x0a,sf);\n            end_marker = read_u16be(inst_offset + 0x0c,sf);\n            /* check for sustain markers != 0 (invalid marker no) */\n            if (start_marker && end_marker) {\n                /* find start marker */\n                loop_start = find_marker(sf, mark_offset, start_marker);\n                loop_end = find_marker(sf, mark_offset, end_marker);\n\n                /* find_marker is type uint32_t as the spec says that's the type\n                 * of the position value, but it returns a -1 on error, and the\n                 * loop_start and loop_end variables are int32_t, so the error\n                 * will become apparent.\n                 * We shouldn't have a loop point that overflows an int32_t anyway. */\n                loop_flag = 1;\n                if (loop_start == loop_end)\n                    loop_flag = 0;\n            }\n        }\n    }\n    if (!loop_flag && mark_offset) {\n        int mark_count = read_u16be(mark_offset + 0x00,sf);\n\n        /* use \"beg/end\" loop comments [Battle Tryst (Arcade)]\n         * Relic codec has 3 \"beg loop\" \"end loop\" \"start offset\" comments, but  always  begin = 0 and end = -1 */\n        if (mark_count == 2) {\n            /* per mark: \n             * 00(2): id\n             * 02(4): sample point\n             * 06(1): string size\n             * --(-): string (non-null terminated)\n             * --(1): null terminator */\n            /* simplified... */\n            if (read_u32be(mark_offset + 0x09,sf) == 0x62656720 &&  /* \"beg \" */\n                read_u32be(mark_offset + 0x19,sf) == 0x656E6420) {  /* \"end \" */\n                loop_start = read_s32be(mark_offset + 0x04, sf);\n                loop_end   = read_s32be(mark_offset + 0x14, sf);\n                loop_flag = 1;\n            }\n        }\n    }\n\n\n    /* build the VGMSTREAM */\n    vgmstream = allocate_vgmstream(channels, loop_flag);\n    if (!vgmstream) goto fail;\n\n    vgmstream->sample_rate = sample_rate;\n    vgmstream->num_samples = sample_count;\n    vgmstream->loop_start_sample = loop_start;\n    vgmstream->loop_end_sample = loop_end;\n\n    vgmstream->coding_type = coding_type;\n    switch(coding_type) {\n        case coding_XA:\n            vgmstream->layout_type = layout_blocked_xa_aiff;\n            /* AIFF XA can use sample rates other than 37800/18900 */\n            /* some Crusader: No Remorse tracks have XA headers with incorrect 0xFF, rip bug/encoder feature? */\n            break;\n\n        case coding_RELIC: {\n            int bitrate = read_u16be(start_offset, sf);\n            start_offset += 0x02;\n\n            vgmstream->codec_data = init_relic(channels, bitrate, sample_rate);\n            if (!vgmstream->codec_data) goto fail;\n            vgmstream->layout_type = layout_none;\n\n            vgmstream->sample_rate = 44100; /* fixed output */\n            break;\n        }\n\n        case coding_VADPCM:\n            if (channels > 1) goto fail; /* unknown layout */\n            if (coef_offset == 0) goto fail;\n\n            vgmstream->layout_type = layout_none;\n            {\n                int version = read_u16be(coef_offset + 0x00, sf);\n                int order   = read_u16be(coef_offset + 0x02, sf);\n                int entries = read_u16be(coef_offset + 0x04, sf);\n                if (version != 1) goto fail;\n\n                vadpcm_read_coefs_be(vgmstream, sf, coef_offset + 0x06, order, entries, 0);\n            }\n\n            //vgmstream->num_samples = vadpcm_bytes_to_samples(data_size, channels); /* unneeded */\n            break;\n\n        default:\n            vgmstream->layout_type = (channels > 1) ? layout_interleave : layout_none;\n            vgmstream->interleave_block_size = interleave;\n            break;\n    }\n\n    if (is_aifc)\n        vgmstream->meta_type = meta_AIFC;\n    else if (is_aiff)\n        vgmstream->meta_type = meta_AIFF;\n\n\n    if (!vgmstream_open_stream(vgmstream, sf, start_offset))\n        goto fail;\n    return vgmstream;\n\nfail:\n    close_vgmstream(vgmstream);\n    return NULL;\n}", "path": "vgmstream/src/meta/aifc.c", "commit_date": "2020-12-05 00:00:00", "repo_name": "vgmstream/vgmstream", "stars": 1393, "license": "other", "language": "c", "size": 37865}
{"docstring": "/* parse EA style blocks, id+size+samples+data */\n", "func_signal": "void block_update_ea_schl(off_t block_offset, VGMSTREAM * vgmstream)", "code": "{\n    STREAMFILE* streamFile = vgmstream->ch[0].streamfile;\n    int i;\n    size_t block_size, block_samples;\n    int32_t (*read_32bit)(off_t,STREAMFILE*) = vgmstream->codec_endian ? read_32bitBE : read_32bitLE;\n\n    uint32_t flag_lang = (vgmstream->codec_config >> 16) & 0xFFFF;\n    int flag_be = (vgmstream->codec_config & 0x02);\n    int flag_adpcm = (vgmstream->codec_config & 0x01);\n    int flag_offsets = (vgmstream->codec_config & 0x04);\n\n\n    /* EOF reads: signal we have nothing and let the layout fail */\n    if (block_offset >= get_streamfile_size(streamFile)) {\n        vgmstream->current_block_offset = block_offset;\n        vgmstream->next_block_offset = block_offset;\n        vgmstream->current_block_samples = -1;\n        return;\n    }\n\n    /* read a single block */\n    {\n        uint32_t block_id = read_32bitBE(block_offset+0x00,streamFile);\n\n        if (flag_be) /* size is always LE, except in early SS/MAC */\n            block_size = read_32bitBE(block_offset + 0x04,streamFile);\n        else\n            block_size = read_32bitLE(block_offset + 0x04,streamFile);\n\n        if (block_id == 0x5343446C || block_id == (0x53440000 | flag_lang)) {\n            /* \"SCDl\" or \"SDxx\" audio chunk */\n            if (vgmstream->coding_type == coding_PSX)\n                block_samples = ps_bytes_to_samples(block_size-0x10, vgmstream->channels);\n            else\n                block_samples = read_32bit(block_offset+0x08,streamFile);\n        }\n        else {\n            /* ignore other chunks (audio \"SCHl/SCCl/...\", non-target lang, video \"pIQT/MADk/...\", etc) */\n            block_samples = 0; /* layout ignores this */\n        }\n\n#ifdef VGM_USE_MPEG\n        /* \"SCHl\" start block, when decoding multi files pasted together */\n        if (block_id == 0x5343486C) {\n            switch(vgmstream->coding_type) {\n                case coding_MPEG_custom:\n                case coding_MPEG_layer1:\n                case coding_MPEG_layer2:\n                case coding_MPEG_layer3:\n                case coding_MPEG_ealayer3:\n                    /* need to reset MPEG decoder to reset discards and trailing samples in the buffers */\n                    flush_mpeg(vgmstream->codec_data);\n                    break;\n                default:\n                    break;\n            }\n        }\n#endif\n        /* padding between \"SCEl\" and next \"SCHl\" (when subfiles exist) */\n        if (block_id == 0x00000000)\n            block_size = 0x04;\n\n        /* guard against errors (happens in bad rips/endianness, observed max is vid ~0x20000) */\n        if (block_size == 0x00 || block_size > 0xFFFFF || block_samples > 0xFFFF) {\n            block_size = 0x04;\n            block_samples = 0;\n        }\n\n        /* \"SCEl\" end chunk should be 32b-aligned, fixes some multi-SCHl [ex. Need for Speed 2 (PC) .eam] */\n        if (((block_offset + block_size) % 0x04) && block_id == 0x5343456C) {\n            block_size += 0x04 - ((block_offset + block_size) % 0x04);\n        }\n    }\n\n\n    vgmstream->current_block_offset = block_offset;\n    vgmstream->next_block_offset = block_offset + block_size;\n    vgmstream->current_block_samples = block_samples;\n    vgmstream->current_block_size = 0; /* uses current_block_samples instead */\n\n    /* no need to setup offsets (plus could read over filesize near EOF) */\n    if (block_samples == 0)\n        return;\n\n\n    /* set new channel offsets and ADPCM history */\n    /* ADPCM hist could be considered part of the stream/decoder (some EAXA decoders call it \"EAXA R1\" when it has hist), and BNKs\n     * (with no blocks) may also have them in the first offset, but also may not. To simplify we just read them here. */\n    if (!flag_offsets) { /* v0 doesn't provide channel offsets, they need to be calculated */\n        switch (vgmstream->coding_type) {\n            /* id, size, samples, data */\n            case coding_PCM8_int:\n                for (i = 0; i < vgmstream->channels; i++) {\n                    vgmstream->ch[i].offset = block_offset + 0x0c + (i*0x01);\n                }\n\n                break;\n\n            /* id, size, samples, data */\n            case coding_PCM16_int:\n                for (i = 0; i < vgmstream->channels; i++) {\n                    vgmstream->ch[i].offset = block_offset + 0x0c + (i*0x02);\n                }\n\n                break;\n\n            /* id, size, samples, data */\n            case coding_PCM8:\n                for (i = 0; i < vgmstream->channels; i++) {\n                    vgmstream->ch[i].offset = block_offset + 0x0c + (block_samples*i*0x01);\n                }\n\n                break;\n\n            /* id, size, samples, data */\n            case coding_PCM16LE:\n            case coding_PCM16BE:\n                for (i = 0; i < vgmstream->channels; i++) {\n                    vgmstream->ch[i].offset = block_offset + 0x0c + (block_samples*i*0x02);\n                }\n\n                break;\n\n            /* id, size, unk1, unk2, interleaved data */\n            case coding_PSX:\n                for (i = 0; i < vgmstream->channels; i++) {\n                    size_t interleave = (block_size-0x10) / vgmstream->channels;\n                    vgmstream->ch[i].offset = block_offset + 0x10 + i*interleave;\n                }\n                /* 0x08/0x0c: unknown (doesn't look like hist or offsets, as 1ch files has them too) */\n\n                break;\n\n            /* id, size, samples, IMA hist, stereo/mono data */\n            case coding_DVI_IMA:\n                for(i = 0; i < vgmstream->channels; i++) {\n                    off_t header_offset = block_offset + 0xc + i*4;\n                    vgmstream->ch[i].adpcm_history1_32 = read_16bitLE(header_offset+0x00, vgmstream->ch[i].streamfile);\n                    vgmstream->ch[i].adpcm_step_index  = read_16bitLE(header_offset+0x02, vgmstream->ch[i].streamfile);\n                    vgmstream->ch[i].offset = block_offset + 0xc + (4*vgmstream->channels);\n                }\n\n                break;\n\n            /* id, size, samples, hists-per-channel, stereo/interleaved data */\n            case coding_EA_XA:\n            case coding_EA_XA_int:\n                for (i = 0; i < vgmstream->channels; i++) {\n                    int is_interleaved = vgmstream->coding_type == coding_EA_XA_int;\n                    size_t interleave;\n\n                    /* read ADPCM history from all channels before data (not actually read in sx.exe) */\n                    //vgmstream->ch[i].adpcm_history1_32 = read_16bit(block_offset + 0x0C + (i*0x04) + 0x00,streamFile);\n                    //vgmstream->ch[i].adpcm_history2_32 = read_16bit(block_offset + 0x0C + (i*0x04) + 0x02,streamFile);\n\n                    /* the block can have padding so find the channel size from num_samples */\n                    interleave = is_interleaved ? (block_samples / 28 * 0x0f) : 0;\n\n                    /* NOT channels*0x04, as seen in Superbike 2000 (PC) EA-XA v1 mono vids */\n                    vgmstream->ch[i].offset = block_offset + 0x0c + 2*0x04 + i*interleave;\n                }\n\n                break;\n\n            case coding_EA_MT: /* not seen in v0 streams so far, may not exist */\n            default:\n                VGM_LOG(\"EA SCHl: Unkonwn channel offsets in blocked layout\\n\");\n                vgmstream->current_block_samples = -1;\n                break;\n        }\n    } else {\n        switch(vgmstream->coding_type) {\n            /* id, size, samples, offsets-per-channel, flag (0x01 = data start), data */\n            case coding_EA_MT:\n                for (i = 0; i < vgmstream->channels; i++) {\n                    off_t channel_start = read_32bit(block_offset + 0x0C + (0x04*i),streamFile);\n                    vgmstream->ch[i].offset = block_offset + 0x0C + (0x04*vgmstream->channels) + channel_start + 0x01;\n                }\n\n                /* flush decoder in every block change */\n                flush_ea_mt(vgmstream);\n                break;\n\n    #ifdef VGM_USE_MPEG\n            /* id, size, samples, offsets, unknown (null for MP2, some size/config for EALayer3; only if not >2ch) */\n            case coding_MPEG_custom:\n            case coding_MPEG_layer1:\n            case coding_MPEG_layer2:\n            case coding_MPEG_layer3:\n            case coding_MPEG_ealayer3:\n                for (i = 0; i < vgmstream->channels; i++) {\n                    off_t channel_start;\n\n                    /* EALayer3 6ch uses 1ch*6 with offsets, no flag in header [Medal of Honor 2010 (PC) movies] */\n                    if (vgmstream->channels > 2) {\n                        channel_start = read_32bit(block_offset + 0x0C + 0x04*i,streamFile);\n                    } else {\n                        channel_start = read_32bit(block_offset + 0x0C,streamFile);\n                    }\n\n                    vgmstream->ch[i].offset = block_offset + 0x0C + (0x04*vgmstream->channels) + channel_start;\n                }\n                break;\n    #endif\n            /* id, size, samples, offsets-per-channel, interleaved data (w/ optional hist per channel) */\n            default:\n                for (i = 0; i < vgmstream->channels; i++) {\n                    off_t channel_start = read_32bit(block_offset + 0x0C + (0x04*i),streamFile);\n                    vgmstream->ch[i].offset = block_offset + 0x0C + (0x04*vgmstream->channels) + channel_start;\n                }\n\n                /* read ADPCM history before each channel if needed (not actually read in sx.exe) */\n                if (flag_adpcm) {\n                    for (i = 0; i < vgmstream->channels; i++) {\n                        //vgmstream->ch[i].adpcm_history1_32 = read_16bit(vgmstream->ch[i].offset+0x00,streamFile);\n                        //vgmstream->ch[i].adpcm_history3_32 = read_16bit(vgmstream->ch[i].offset+0x02,streamFile);\n                        vgmstream->ch[i].offset += 4;\n                    }\n                }\n\n                break;\n        }\n    }\n}", "path": "vgmstream/src/layout/blocked_ea_schl.c", "commit_date": "2020-11-01 00:00:00", "repo_name": "vgmstream/vgmstream", "stars": 1393, "license": "other", "language": "c", "size": 37865}
{"docstring": "/* call with d->lock held */\n", "func_signal": "static void queue(struct xenevt_dev_data *d, u_int port)", "code": "{\n\tKASSERT(mutex_owned(&d->lock));\n\n\tif (d->ring_cons == ((d->ring_prod + 1) & EVTDEV_RING_MASK)) {\n\t\td->flags |= EVTDEV_F_OVERFLOW;\n\t\tprintf(\"evtdev: ring overflow port %d\\n\", port);\n\t} else {\n\t\td->ring[d->ring_prod] = port;\n\t\tmembar_producer();\n\t\td->ring_prod = (d->ring_prod + 1) & EVTDEV_RING_MASK;\n\t}\n\t/* notify */\n\tcv_signal(&d->cv);\n\tselnotify(&d->selinfo, RBITS, NOTE_SUBMIT);\n}", "path": "rumprun/platform/xen/librumpxen_xendev/evtdev.c", "commit_date": "2016-02-11 00:00:00", "repo_name": "rumpkernel/rumprun", "stars": 1122, "license": "other", "language": "c", "size": 3421}
{"docstring": "/*----- request handling (writes to the device) -----*/\n", "func_signal": "static int\nxenevt_dev_write(struct file *fp, off_t *offset, struct uio *uio,\n\t\t kauth_cred_t cred, int flags)", "code": "{\n\tstruct xenevt_dev_data *d = fp->f_data;\n\tuint16_t *chans = NULL;\n\tint i, nentries, err;\n\tsize_t size = 0;\n\n\tDPRINTF((\"/dev/xenevt: write...\\n\"));\n\n\tif (uio->uio_resid == 0) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\tnentries = uio->uio_resid / sizeof(uint16_t);\n\tif (nentries > NR_EVENT_CHANNELS) {\n\t\terr = EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\tsize = nentries * sizeof(uint16_t);\n\tchans = kmem_alloc(size, KM_SLEEP);\n\n\terr = uiomove(chans, uio->uio_resid, uio);\n\tif (err) goto out;\n\n\tmutex_enter(&devevent_lock);\n\tfor (i = 0; i < nentries; i++) {\n\t\tif (chans[i] < NR_EVENT_CHANNELS &&\n\t\t    devevents[chans[i]] == d)\n\t\t\tminios_unmask_evtchn(chans[i]);\n\t}\n\tmutex_exit(&devevent_lock);\n\n\tKASSERT(err == 0);\nout:\n\tDPRINTF((\"/dev/xenevt: write done, err=%d\\n\", err));\n\tif (size) kmem_free(chans, size);\n\treturn err;\n}", "path": "rumprun/platform/xen/librumpxen_xendev/evtdev.c", "commit_date": "2016-02-11 00:00:00", "repo_name": "rumpkernel/rumprun", "stars": 1122, "license": "other", "language": "c", "size": 3421}
{"docstring": "/* ok, this isn't really random, but let's make-believe */\n", "func_signal": "int\nrumpuser_getrandom(void *buf, size_t buflen, int flags, size_t *retp)", "code": "{\n\tunsigned char *rndbuf;\n\n\tfor (*retp = 0, rndbuf = buf; *retp < buflen; (*retp)++) {\n\t\t*rndbuf++ = bmk_platform_cpu_clock_monotonic() & 0xff;\n\t}\n\n\treturn 0;\n}", "path": "rumprun/lib/libbmk_rumpuser/rumpuser_base.c", "commit_date": "2015-10-08 00:00:00", "repo_name": "rumpkernel/rumprun", "stars": 1122, "license": "other", "language": "c", "size": 3421}
{"docstring": "/*----- setup etc. -----*/\n", "func_signal": "static int\nxenevt_dev_close(struct file *fp)", "code": "{\n\tstruct xenevt_dev_data *d = fp->f_data;\n\tint i;\n\n\tDPRINTF((\"/dev/xenevt: close...\\n\"));\n\n\tmutex_enter(&devevent_lock);\n\tmutex_enter(&d->lock);\n\tfor (i = 0; i < NR_EVENT_CHANNELS; i++) {\n\t\tif (devevents[i] == d) {\n\t\t\tminios_unbind_evtchn(i);\n\t\t\tdevevents[i] = NULL;\n\t\t}\n\t}\n\tmutex_exit(&d->lock);\n\tmutex_exit(&devevent_lock);\n\n\tseldestroy(&d->selinfo);\n\tmutex_destroy(&d->lock);\n\tkmem_free(d, sizeof(*d));\n\tcv_destroy(&d->cv);\n\n\tDPRINTF((\"/dev/xenevt: close done.\\n\"));\n\n\tfp->f_data = NULL;\n\n\treturn 0;\n}", "path": "rumprun/platform/xen/librumpxen_xendev/evtdev.c", "commit_date": "2016-02-11 00:00:00", "repo_name": "rumpkernel/rumprun", "stars": 1122, "license": "other", "language": "c", "size": 3421}
{"docstring": "/*----- response and watch event handling (reads from the device) -----*/\n", "func_signal": "static struct xsd_sockmsg*\nprocess_watch_event(struct rumpxenbus_data_common *dc, struct xenbus_event *event,\n\t\t    struct xenbus_dev_watch *watch,\n\t\t    void (**mfree_r)(void*))", "code": "{\n\n\t/* We need to make a new XS_WATCH_EVENT message because the\n\t * one from xenstored (a) isn't visible to us here and (b)\n\t * anyway has the wrong token in it. */\n\n\tDPRINTF((\"/dev/xen/xenbus[%p]: watch event,\"\n\t\t \" wpath=%s user_token=%s epath=%s xb.token=%s\\n\",\n                 dc,\n\t\t watch->path, watch->user_token,\n\t\t event->path, watch->xb.token));\n\n\t/* Define the parts of the message */\n\n#define WATCH_MESSAGE_PART_STRING(PART,x)\t\t\\\n\tPART(strlen((x)) + 1, memcpy(p, (x), sz))\n\n#define WATCH_MESSAGE_PARTS(PART)\t\t\t\t\\\n\tPART(sizeof(struct xsd_sockmsg), (void)0)\t\t\\\n\tWATCH_MESSAGE_PART_STRING(PART,event->path)\t\t\\\n\tWATCH_MESSAGE_PART_STRING(PART,watch->user_token)\n\n\t/* Compute the size */\n\n\tsize_t totalsz = 0;\n\tsize_t sz = 0;\n\n#define WATCH_MESSAGE_PART_ADD_SIZE(calcpartsz, fill) \\\n\ttotalsz += (calcpartsz);\n\n\tWATCH_MESSAGE_PARTS(WATCH_MESSAGE_PART_ADD_SIZE);\n\n\tDPRINTF((\"/dev/xen/xenbus: watch event allocating %lu\\n\",\n\t\t (unsigned long)totalsz));\n\n\t/* Allocate it and fill in the header */\n\n\tstruct xsd_sockmsg *reply = xbd_malloc(totalsz);\n\tif (!reply) {\n\t\tprintf(\"xenbus dev: out of memory for watch event\"\n\t\t       \" wpath=`%s' epath=`%s'\\n\",\n\t\t       watch->path, event->path);\n\t\tdc->queued_enomem = 1;\n\t\tgoto end;\n\t}\n\n\tbzero(reply, sizeof(*reply));\n\treply->type = XS_WATCH_EVENT;\n\treply->len = totalsz - sizeof(*reply);\n\n\tchar *p = (void*)reply;\n\n\t/* Fill in the rest of the message */\n\n#define WATCH_MESSAGE_PART_ADD(calcpartsz, fill)\t\\\n\tsz = (calcpartsz);\t\t\t\t\\\n\tfill;\t\t\t\t\t\t\\\n\tp += sz;\n\n\tWATCH_MESSAGE_PARTS(WATCH_MESSAGE_PART_ADD);\n\n\tKASSERT(p == (const char*)reply + totalsz);\n\n\t/* Now we are done */\n\nend:\n\txenbus_free(event);\n\t*mfree_r = xbd_free;\n\treturn reply;\n}", "path": "rumprun/platform/xen/librumpxen_xendev/busdev_user.c", "commit_date": "2016-10-07 00:00:00", "repo_name": "rumpkernel/rumprun", "stars": 1122, "license": "other", "language": "c", "size": 3421}
{"docstring": "/*----- helpers -----*/\n", "func_signal": "static void\nfree_watch(struct xenbus_dev_watch *watch)", "code": "{\n\txbd_free(watch->path);\n\txbd_free(watch->user_token);\n\txbd_free(watch);\n}", "path": "rumprun/platform/xen/librumpxen_xendev/busdev_user.c", "commit_date": "2016-10-07 00:00:00", "repo_name": "rumpkernel/rumprun", "stars": 1122, "license": "other", "language": "c", "size": 3421}
{"docstring": "/*\n * Allocate tls and initialize it.\n * NOTE: does not initialize tcb, see inittcb().\n */\n", "func_signal": "void *\nbmk_sched_tls_alloc(void)", "code": "{\n\tchar *tlsmem, *p;\n\n\ttlsmem = p = bmk_memalloc(TLSAREASIZE, 0, BMK_MEMWHO_WIREDBMK);\n#ifdef _TLS_I\n\tbmk_memset(p, 0, 2*sizeof(void *));\n\tp += 2 * sizeof(void *);\n#endif\n\tbmk_memcpy(p, _tdata_start, TDATASIZE);\n\tbmk_memset(p + TDATASIZE, 0, TBSSSIZE);\n\n\treturn tlsmem + TCBOFFSET;\n}", "path": "rumprun/lib/libbmk_core/sched.c", "commit_date": "2015-08-16 00:00:00", "repo_name": "rumpkernel/rumprun", "stars": 1122, "license": "other", "language": "c", "size": 3421}
{"docstring": "/* Issue an aio */\n", "func_signal": "void blkfront_aio(struct blkfront_aiocb *aiocbp, int write)", "code": "{\n    struct blkfront_dev *dev = aiocbp->aio_dev;\n    struct blkif_request *req;\n    RING_IDX i;\n    int notify;\n    int n, j;\n    uintptr_t start, end;\n\n    // Can't io at non-sector-aligned location\n    ASSERT(!(aiocbp->aio_offset & (dev->info.sector_size-1)));\n    // Can't io non-sector-sized amounts\n    ASSERT(!(aiocbp->aio_nbytes & (dev->info.sector_size-1)));\n    // Can't io non-sector-aligned buffer\n    ASSERT(!((uintptr_t) aiocbp->aio_buf & (dev->info.sector_size-1)));\n\n    start = (uintptr_t)aiocbp->aio_buf & PAGE_MASK;\n    end = ((uintptr_t)aiocbp->aio_buf + aiocbp->aio_nbytes + PAGE_SIZE - 1) & PAGE_MASK;\n    aiocbp->n = n = (end - start) / PAGE_SIZE;\n\n    /* qemu's IDE max multsect is 16 (8KB) and SCSI max DMA was set to 32KB,\n     * so max 44KB can't happen */\n    ASSERT(n <= BLKIF_MAX_SEGMENTS_PER_REQUEST);\n\n    blkfront_wait_slot(dev);\n    i = dev->ring.req_prod_pvt;\n    req = RING_GET_REQUEST(&dev->ring, i);\n\n    req->operation = write ? BLKIF_OP_WRITE : BLKIF_OP_READ;\n    req->nr_segments = n;\n    req->handle = dev->handle;\n    req->id = (uintptr_t) aiocbp;\n    req->sector_number = aiocbp->aio_offset / 512;\n\n    for (j = 0; j < n; j++) {\n        req->seg[j].first_sect = 0;\n        req->seg[j].last_sect = PAGE_SIZE / 512 - 1;\n    }\n    req->seg[0].first_sect = ((uintptr_t)aiocbp->aio_buf & ~PAGE_MASK) / 512;\n    req->seg[n-1].last_sect = (((uintptr_t)aiocbp->aio_buf + aiocbp->aio_nbytes - 1) & ~PAGE_MASK) / 512;\n    for (j = 0; j < n; j++) {\n\tuintptr_t data = start + j * PAGE_SIZE;\n        if (!write) {\n            /* Trigger CoW if needed */\n            *(char*)(data + (req->seg[j].first_sect << 9)) = 0;\n            barrier();\n        }\n\taiocbp->gref[j] = req->seg[j].gref =\n            gnttab_grant_access(dev->dom, virtual_to_mfn(data), write);\n    }\n\n    dev->ring.req_prod_pvt = i + 1;\n\n    wmb();\n    RING_PUSH_REQUESTS_AND_CHECK_NOTIFY(&dev->ring, notify);\n\n    if(notify) minios_notify_remote_via_evtchn(dev->evtchn);\n}", "path": "rumprun/platform/xen/xen/blkfront.c", "commit_date": "2015-06-19 00:00:00", "repo_name": "rumpkernel/rumprun", "stars": 1122, "license": "other", "language": "c", "size": 3421}
{"docstring": "/*\n * calling times() causes crash.  rumprun issue #4\n */\n", "func_signal": "static int\ntest_times(void)", "code": "{\n\tstruct tms tms;\n\n\tprintf(\"checking that calling times() does not crash ... \");\n\ttimes(&tms);\n\tprfres(0);\n\n\treturn 0;\n}", "path": "rumprun/tests/basic/misc_test.c", "commit_date": "2016-02-04 00:00:00", "repo_name": "rumpkernel/rumprun", "stars": 1122, "license": "other", "language": "c", "size": 3421}
{"docstring": "/* thread context we use to deliver interrupts to the rump kernel */\n", "func_signal": "static void\ndoisr(void *arg)", "code": "{\n\tint i, totwork = 0;\n\n\trumpuser__hyp.hyp_schedule();\n\trumpuser__hyp.hyp_lwproc_newlwp(0);\n\trumpuser__hyp.hyp_unschedule();\n\n\tsplhigh();\n\tfor (;;) {\n\t\tunsigned int isrcopy;\n\t\tint nlocks = 1;\n\n\t\tisrcopy = isr_todo;\n\t\tisr_todo = 0;\n\t\tspl0();\n\n\t\ttotwork |= isrcopy;\n\n\t\trumpkern_sched(nlocks, NULL);\n\t\tfor (i = isr_lowest; isrcopy; i++) {\n\t\t\tstruct intrhand *ih;\n\n\t\t\tbmk_assert(i < sizeof(isrcopy)*8);\n\t\t\tif ((isrcopy & (1<<i)) == 0)\n\t\t\t\tcontinue;\n\t\t\tisrcopy &= ~(1<<i);\n\n\t\t\tif (isr_routed[i] == INTR_ROUTED_YES)\n\t\t\t\ti = routeintr(i);\n\n\t\t\tSLIST_FOREACH(ih, &isr_ih[i], ih_entries) {\n\t\t\t\tih->ih_fun(ih->ih_arg);\n\t\t\t}\n\t\t}\n\t\trumpkern_unsched(&nlocks, NULL);\n\n\t\tsplhigh();\n\t\tif (isr_todo)\n\t\t\tcontinue;\n\n\t\tcpu_intr_ack(totwork);\n\n\t\t/* no interrupts left. block until the next one. */\n\t\tbmk_sched_blockprepare();\n\n\t\tspl0();\n\n\t\tbmk_sched_block();\n\t\ttotwork = 0;\n\t\tsplhigh();\n\t}\n}", "path": "rumprun/platform/hw/intr.c", "commit_date": "2016-02-19 00:00:00", "repo_name": "rumpkernel/rumprun", "stars": 1122, "license": "other", "language": "c", "size": 3421}
{"docstring": "/*\n * Since this is serial, unlike in a framebuffer console,\n * we can just write a character and that's it.  NetBSD seems to use\n * a scheme where it waits for the FIFO to be empty before writing to\n * it, and also after writing to it.  Not sure why you need to wait\n * after writing.  Therefore, we just wait before writing.\n */\n", "func_signal": "void\ncons_putc(int c)", "code": "{\n\tvolatile uint8_t *const uartdr = (uint8_t *)(UART0 + UARTDR);\n\tvolatile uint16_t *const uartfr = (uint16_t *)(UART0 + UARTFR);\n\tint timo;\n\tunsigned char cw = c;\n\n\ttimo = 150000; /* magic value from NetBSD */\n\twhile (!(*uartfr & UARTFR_TXFE) && --timo)\n\t\tcontinue;\n\n\t*uartdr = cw;\n}", "path": "rumprun/platform/hw/arch/arm/integrator/serialcons.c", "commit_date": "2015-08-04 00:00:00", "repo_name": "rumpkernel/rumprun", "stars": 1122, "license": "other", "language": "c", "size": 3421}
{"docstring": "/* Returned value is from malloc() */\n", "func_signal": "static struct xsd_sockmsg*\nprocess_response(struct rumpxenbus_data_common *dc, struct xenbus_dev_request *req,\n\t\t void (**mfree_r)(void*))", "code": "{\n\tstruct rumpxenbus_data_user *const du = dc->du;\n\tstruct xenbus_dev_watch *watch;\n\tstruct xsd_sockmsg *msg = req->xb.reply;\n\n\tmsg->req_id = req->user_id;\n\n\t_Bool error = msg->type == XS_ERROR;\n\tKASSERT(error || msg->type == req->req_type);\n\n\tDPRINTF((\"/dev/xen/xenbus[%p,du=%p]:\"\n                 \" response, req_type=%d msg->type=%d\\n\",\n\t\t dc,du, req->req_type, msg->type));\n\n\tswitch (req->req_type) {\n\n\tcase XS_TRANSACTION_START:\n\t\tif (error)\n\t\t\tbreak;\n\t\tKASSERT(msg->len >= 2);\n\t\tKASSERT(!((uint8_t*)(msg+1))[msg->len-1]);\n\t\treq->u.trans->tx_id =\n\t\t\tstrtoul((char*)&msg + sizeof(*msg),\n\t\t\t\t0, 0);\n\t\tLIST_INSERT_HEAD(&du->transactions, req->u.trans,\n\t\t\t\t entry);\n\t\tbreak;\n\n\tcase XS_TRANSACTION_END:\n\t\txbd_free(req->u.trans);\n\t\tbreak;\n\n\tcase XS_WATCH:\n\t\twatch = req->u.watch;\n\t\tif (error)\n\t\t\tgoto do_unwatch;\n\t\twatch->visible_to_user = 1;\n\t\tbreak;\n\n\tcase XS_UNWATCH:\n\t\tKASSERT(!error);\n\t\twatch = req->u.watch;\n\tdo_unwatch:\n\t\tKASSERT(!watch->visible_to_user);\n\t\tLIST_REMOVE(watch, entry);\n\t\txenbus_watch_release(&watch->xb);\n\t\tfree_watch(watch);\n\t\tbreak;\n\n\t}\n\n\txenbus_id_release(req->xb_id);\n\txbd_free(req);\n\tKASSERT(du->outstanding_requests > 0);\n\tdu->outstanding_requests--;\n\n\t*mfree_r = xenbus_free;\n\treturn msg;\n}", "path": "rumprun/platform/xen/librumpxen_xendev/busdev_user.c", "commit_date": "2016-10-07 00:00:00", "repo_name": "rumpkernel/rumprun", "stars": 1122, "license": "other", "language": "c", "size": 3421}
{"docstring": "/*----- more exciting reading -----*/\n", "func_signal": "static int\nxenevt_dev_poll(struct file *fp, int events)", "code": "{\n\tstruct xenevt_dev_data *d = fp->f_data;\n\tint revents = 0;\n\n\tDPRINTF((\"/dev/xenevt: poll events=0x%x...\\n\", events));\n\n\tmutex_enter(&d->lock);\n\n\t/* always writable because write is used to unmask event\n\t * channel */\n\trevents |= events & WBITS;\n\n\tif ((events & RBITS) && (d->ring_prod != d->ring_cons))\n\t\trevents |= events & RBITS;\n\n\t/* in the case caller only interests in read but no data\n\t * available to read */\n\tif (!revents && (events & RBITS))\n\t\tselrecord(curlwp, &d->selinfo);\n\n\tmutex_exit(&d->lock);\n\tDPRINTF((\"/dev/xenevt: poll events=0x%x done, revents=0x%x\\n\",\n\t\t events, revents));\n\treturn revents;\n}", "path": "rumprun/platform/xen/librumpxen_xendev/evtdev.c", "commit_date": "2016-02-11 00:00:00", "repo_name": "rumpkernel/rumprun", "stars": 1122, "license": "other", "language": "c", "size": 3421}
{"docstring": "/*\n * Free tls\n */\n", "func_signal": "void\nbmk_sched_tls_free(void *mem)", "code": "{\n\n\tmem = (void *)((unsigned long)mem - TCBOFFSET);\n\tbmk_memfree(mem, BMK_MEMWHO_WIREDBMK);\n}", "path": "rumprun/lib/libbmk_core/sched.c", "commit_date": "2015-08-16 00:00:00", "repo_name": "rumpkernel/rumprun", "stars": 1122, "license": "other", "language": "c", "size": 3421}
{"docstring": "/* verify that a fd created in the main thread is accessible in another */\n", "func_signal": "static void *\nfdthread(void *arg)", "code": "{\n\tint fd = *(int *)arg;\n\tchar buf[1];\n\n\tif (read(fd, buf, 1) != 0)\n\t\terr(1, \"fdthread read\");\n\tif (close(fd) != 0)\n\t\terr(1, \"fdthread close\");\n\treturn (void *)0;\n}", "path": "rumprun/tests/basic/pthread_test.c", "commit_date": "2015-05-14 00:00:00", "repo_name": "rumpkernel/rumprun", "stars": 1122, "license": "other", "language": "c", "size": 3421}
{"docstring": "/*\n * Called with interrupts disabled\n */\n", "func_signal": "static void\nclear_runnable(void)", "code": "{\n\tstruct bmk_thread *thread = bmk_current;\n\tint newfl;\n\n\tbmk_assert(thread->bt_flags & THR_RUNNING);\n\n\t/*\n\t * Currently we require that a thread will block only\n\t * once before calling the scheduler.\n\t */\n\tbmk_assert((thread->bt_flags & THR_RUNQ) == 0);\n\n\tnewfl = thread->bt_flags;\n\tif (thread->bt_wakeup_time != BMK_SCHED_BLOCK_INFTIME) {\n\t\tnewfl |= THR_TIMEQ;\n\t\ttimeq_sorted_insert(thread);\n\t} else {\n\t\tnewfl |= THR_BLOCKQ;\n\t\tTAILQ_INSERT_TAIL(&blockq, thread, bt_schedq);\n\t}\n\tthread->bt_flags = newfl;\n}", "path": "rumprun/lib/libbmk_core/sched.c", "commit_date": "2015-08-16 00:00:00", "repo_name": "rumpkernel/rumprun", "stars": 1122, "license": "other", "language": "c", "size": 3421}
{"docstring": "/*\n * Insert thread into timeq at the correct place.\n */\n", "func_signal": "static void\ntimeq_sorted_insert(struct bmk_thread *thread)", "code": "{\n\tstruct bmk_thread *iter;\n\n\tbmk_assert(thread->bt_wakeup_time != BMK_SCHED_BLOCK_INFTIME);\n\n\t/* case1: no others */\n\tif (TAILQ_EMPTY(&timeq)) {\n\t\tTAILQ_INSERT_HEAD(&timeq, thread, bt_schedq);\n\t\treturn;\n\t}\n\n\t/* case2: not last in queue */\n\tTAILQ_FOREACH(iter, &timeq, bt_schedq) {\n\t\tif (iter->bt_wakeup_time > thread->bt_wakeup_time) {\n\t\t\tTAILQ_INSERT_BEFORE(iter, thread, bt_schedq);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* case3: last in queue with greatest current timeout */\n\tbmk_assert(TAILQ_LAST(&timeq, threadqueue)->bt_wakeup_time\n\t    <= thread->bt_wakeup_time);\n\tTAILQ_INSERT_TAIL(&timeq, thread, bt_schedq);\n}", "path": "rumprun/lib/libbmk_core/sched.c", "commit_date": "2015-08-16 00:00:00", "repo_name": "rumpkernel/rumprun", "stars": 1122, "license": "other", "language": "c", "size": 3421}
{"docstring": "/*----- more exciting reading -----*/\n", "func_signal": "static void\nxenbus_dev_xb_wakeup(struct xenbus_event_queue *queue)", "code": "{\n\t/* called with req_lock held */\n\tstruct rumpxenbus_data_user *du =\n\t\tcontainer_of(queue, struct rumpxenbus_data_user, replies);\n\tDPRINTF((\"/dev/xen/xenbus[queue=%p,du=%p]: wakeup...\\n\",queue,du));\n\tminios_wake_up(&du->replies.waitq);\n\trumpxenbus_dev_xb_wakeup(du->c);\n}", "path": "rumprun/platform/xen/librumpxen_xendev/busdev_user.c", "commit_date": "2016-10-07 00:00:00", "repo_name": "rumpkernel/rumprun", "stars": 1122, "license": "other", "language": "c", "size": 3421}
{"docstring": "/*\n * function template for strtoul, strtoull and strtoumax.\n *\n * parameters:\n *\t_FUNCNAME  : function name\n *      __UINT     : return type\n *      __UINT_MAX : upper limit of the return type\n */\n", "func_signal": "__UINT\n_FUNCNAME(const char *nptr, char **endptr, int base)", "code": "{\n\tconst char *s;\n\t__UINT acc, cutoff;\n\tunsigned char c;\n\tint i, neg, any, cutlim;\n\n\t/* check base value */\n\tif (base && (base < 2 || base > 36)) {\n\t\tbmk_platform_halt(\"invalid base to strtoul\");\n\t}\n\n\t/*\n\t * Skip white space and pick up leading +/- sign if any.\n\t * If base is 0, allow 0x for hex and 0 for octal, else\n\t * assume decimal; if base is already 16, allow 0x.\n\t */\n\ts = nptr;\n\tdo {\n\t\tc = *s++;\n\t} while (c == ' '|| (c >= '\\t' && c <= '\\r'));\n\tif (c == '-') {\n\t\tneg = 1;\n\t\tc = *s++;\n\t} else {\n\t\tneg = 0;\n\t\tif (c == '+')\n\t\t\tc = *s++;\n\t}\n\tif ((base == 0 || base == 16) &&\n\t    c == '0' && (*s == 'x' || *s == 'X')) {\n\t\tc = s[1];\n\t\ts += 2;\n\t\tbase = 16;\n\t}\n\tif (base == 0)\n\t\tbase = (c == '0' ? 8 : 10);\n\n\t/*\n\t * See strtol for comments as to the logic used.\n\t */\n\tcutoff = ((__UINT)__UINT_MAX / (__UINT)base);\n\tcutlim = (int)((__UINT)__UINT_MAX % (__UINT)base);\n\tfor (acc = 0, any = 0;; c = *s++) {\n\t\tif (c >= '0' && c <= '9')\n\t\t\ti = c - '0';\n\t\telse if (c >= 'a' && c <= 'z')\n\t\t\ti = (c - 'a') + 10;\n\t\telse if (c >= 'A' && c <= 'Z')\n\t\t\ti = (c - 'A') + 10;\n\t\telse\n\t\t\tbreak;\n\t\tif (i >= base)\n\t\t\tbreak;\n\t\tif (any < 0)\n\t\t\tcontinue;\n\t\tif (acc > cutoff || (acc == cutoff && i > cutlim)) {\n\t\t\tacc = __UINT_MAX;\n\t\t\tany = 0;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tany = 1;\n\t\t\tacc *= (__UINT)base;\n\t\t\tacc += i;\n\t\t}\n\t}\n\tif (neg && any > 0)\n\t\tacc = -acc;\n\tif (endptr != NULL)\n\t\t/* LINTED interface specification */\n\t\t*endptr = __UNCONST(any ? s - 1 : nptr);\n\treturn(acc);\n}", "path": "rumprun/lib/libbmk_core/strtoul.c", "commit_date": "2015-05-29 00:00:00", "repo_name": "rumpkernel/rumprun", "stars": 1122, "license": "other", "language": "c", "size": 3421}
{"docstring": "/* This callback is serialised by mini-os */\n", "func_signal": "static void rump_evtdev_callback(u_int port)", "code": "{\n\tif (xenevt_ring_cons == ((xenevt_ring_prod + 1) & EVTDEV_RING_MASK)) {\n\t\tprintf(\"xenevt driver ring overflowed!\\n\");\n\t} else {\n\t\txenevt_ring[xenevt_ring_prod] = port;\n\t\tmembar_producer();\n\t\txenevt_ring_prod = (xenevt_ring_prod + 1) & EVTDEV_RING_MASK;\n\t}\n\n\tminios_wake_up(&minios_events_waitq);\n}", "path": "rumprun/platform/xen/librumpxen_xendev/evtdev.c", "commit_date": "2016-02-11 00:00:00", "repo_name": "rumpkernel/rumprun", "stars": 1122, "license": "other", "language": "c", "size": 3421}
{"docstring": "/* Test if the byte is DBC 1st byte */\n", "func_signal": "static int dbc_1st (BYTE c)", "code": "{\n#if FF_CODE_PAGE == 0\t\t/* Variable code page */\n\tif (DbcTbl && c >= DbcTbl[0]) {\n\t\tif (c <= DbcTbl[1]) return 1;\t\t\t\t\t/* 1st byte range 1 */\n\t\tif (c >= DbcTbl[2] && c <= DbcTbl[3]) return 1;\t/* 1st byte range 2 */\n\t}\n#elif FF_CODE_PAGE >= 900\t/* DBCS fixed code page */\n\tif (c >= DbcTbl[0]) {\n\t\tif (c <= DbcTbl[1]) return 1;\n\t\tif (c >= DbcTbl[2] && c <= DbcTbl[3]) return 1;\n\t}\n#else\t\t\t\t\t\t/* SBCS fixed code page */\n\tif (c != 0) return 0;\t/* Always false */\n#endif\n\treturn 0;\n}", "path": "circle/addon/fatfs/ff.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "rsta2/circle", "stars": 1703, "license": "gpl-3.0", "language": "c", "size": 6873}
{"docstring": "/***********************************************************\n * Name: vc_dispmanx_resource_create\n *\n * Arguments:\n *       VC_IMAGE_TYPE_T type\n *       uint32_t width\n *       uint32_t height\n *\n * Description: Create a new resource (in Videocore memory)\n *\n * Returns: resource handle\n *\n ***********************************************************/\n", "func_signal": "VCHPRE_ DISPMANX_RESOURCE_HANDLE_T VCHPOST_ vc_dispmanx_resource_create( VC_IMAGE_TYPE_T type, uint32_t width, uint32_t height, uint32_t *native_image_handle )", "code": "{\n   uint32_t resourceCreateParams[] = { (uint32_t)VC_HTOV32(type), VC_HTOV32(width), VC_HTOV32(height) };\n\n   uint32_t resource = 0;\n\n   resource = dispmanx_get_handle(EDispmanResourceCreate, resourceCreateParams, sizeof(resourceCreateParams));\n\n   //We don't get an image handle back, so explicitly set this to zero to let the caller know\n   *native_image_handle = 0;\n   //The caller should call vc_dispmanx_resource_get_image_handle below to get the VC_IMAGE_T *\n   //This will be deprecated soon, however\n\n   return (DISPMANX_RESOURCE_HANDLE_T) resource;\n}", "path": "circle/addon/vc4/interface/vmcs_host/vc_vchi_dispmanx.c", "commit_date": "2019-02-11 00:00:00", "repo_name": "rsta2/circle", "stars": 1703, "license": "gpl-3.0", "language": "c", "size": 6873}
{"docstring": "/***********************************************************\n * Name: dispmanx_notify_handle\n *\n * Arguments: not used\n *\n * Description: this purely notifies the update callback\n *\n * Returns: does not return\n *\n ***********************************************************/\n", "func_signal": "static void *dispmanx_notify_func( void *arg )", "code": "{\n   int32_t success;\n   VCOS_STATUS_T status;\n\n   (void)arg;\n\n   while (1) {\n      DISPMANX_UPDATE_HANDLE_T handle;\n      status = vcos_event_wait(&dispmanx_notify_available_event);\n      if (status != VCOS_SUCCESS || !dispmanx_client.initialised)\n         break;\n\n      while (1) {\n         success = vchi_msg_dequeue( dispmanx_client.notify_handle[0], dispmanx_client.notify_buffer, sizeof(dispmanx_client.notify_buffer), &dispmanx_client.notify_length, VCHI_FLAGS_NONE );\n         if (success != 0)\n            break;\n\n         handle = (DISPMANX_UPDATE_HANDLE_T)dispmanx_client.notify_buffer[0];\n         if (handle) {\n            // This is the response to an update submit\n            // Decrement the use count - the corresponding \"use\" is in vc_dispmanx_update_submit.\n            vchi_service_release(dispmanx_client.notify_handle[0]);\n            if (dispmanx_client.update_callback ) {\n               vcos_assert( dispmanx_client.pending_update_handle == handle);\n               dispmanx_client.update_callback(handle, dispmanx_client.update_callback_param);\n            }\n         } else {\n            // This is a vsync notification\n            if (dispmanx_client.vsync_callback ) {\n               dispmanx_client.vsync_callback(handle, dispmanx_client.vsync_callback_param);\n            }\n         }\n      }\n   }\n   return 0;\n}", "path": "circle/addon/vc4/interface/vmcs_host/vc_vchi_dispmanx.c", "commit_date": "2019-02-11 00:00:00", "repo_name": "rsta2/circle", "stars": 1703, "license": "gpl-3.0", "language": "c", "size": 6873}
{"docstring": "/***********************************************************\n * Name: vc_dispmanx_display_open\n *\n * Arguments:\n *       uint32_t device\n *\n * Description:\n *\n * Returns:\n *\n ***********************************************************/\n", "func_signal": "VCHPRE_ DISPMANX_DISPLAY_HANDLE_T VCHPOST_ vc_dispmanx_display_open( uint32_t device )", "code": "{\n   uint32_t display_handle;\n#ifndef __circle__\n   char *env = getenv(\"VC_DISPLAY\");\n\n   if (device == 0 && env)\n   {\n      device = atoi(env);\n   }\n#endif\n\n   device = VC_HTOV32(device);\n   display_handle = dispmanx_get_handle(EDispmanDisplayOpen,\n                                                 &device, sizeof(device));\n\n   return (DISPMANX_DISPLAY_HANDLE_T) display_handle;\n}", "path": "circle/addon/vc4/interface/vmcs_host/vc_vchi_dispmanx.c", "commit_date": "2019-02-11 00:00:00", "repo_name": "rsta2/circle", "stars": 1703, "license": "gpl-3.0", "language": "c", "size": 6873}
{"docstring": "/***********************************************************\n * Name: vc_dispmanx_display_set_background\n *\n * Arguments:\n *       DISPMANX_UPDATE_HANDLE_T update\n *       DISPMANX_DISPLAY_HANDLE_T display\n *       uint8_t red\n *       uint8_t green\n *       uint8_t blue\n *\n * Description:\n *\n * Returns:\n *\n ***********************************************************/\n", "func_signal": "VCHPRE_ int VCHPOST_ vc_dispmanx_display_set_background( DISPMANX_UPDATE_HANDLE_T update, DISPMANX_DISPLAY_HANDLE_T display,\n                                                                       uint8_t red, uint8_t green, uint8_t blue )", "code": "{\n   uint32_t display_param[] = {(uint32_t)VC_HTOV32(update), (uint32_t) VC_HTOV32(display), VC_HTOV32(red), VC_HTOV32(green), VC_HTOV32(blue)};\n   int success = (int) dispmanx_send_command( EDispmanDisplaySetBackground | DISPMANX_NO_REPLY_MASK,\n                                        display_param, sizeof(display_param));\n   return success;\n}", "path": "circle/addon/vc4/interface/vmcs_host/vc_vchi_dispmanx.c", "commit_date": "2019-02-11 00:00:00", "repo_name": "rsta2/circle", "stars": 1703, "license": "gpl-3.0", "language": "c", "size": 6873}
{"docstring": "/***********************************************************\n * Name: vc_dispmanx_resource_delete\n *\n * Arguments:\n *       DISPMANX_RESOURCE_HANDLE_T res\n *\n * Description:\n *\n * Returns: 0 or failure\n *\n ***********************************************************/\n", "func_signal": "VCHPRE_ int VCHPOST_ vc_dispmanx_resource_delete( DISPMANX_RESOURCE_HANDLE_T res )", "code": "{\n   int status;\n   res = VC_HTOV32(res);\n   //We block to make sure the memory is freed after the call\n   status = (int) dispmanx_send_command(EDispmanResourceDelete, &res, sizeof(res));\n\n   return status;\n}", "path": "circle/addon/vc4/interface/vmcs_host/vc_vchi_dispmanx.c", "commit_date": "2019-02-11 00:00:00", "repo_name": "rsta2/circle", "stars": 1703, "license": "gpl-3.0", "language": "c", "size": 6873}
{"docstring": "/***********************************************************\n * Name: dispmanx_notify_callback\n *\n * Arguments: semaphore, callback reason and message handle\n *\n * Description: VCHI callback for the update callback\n *\n ***********************************************************/\n", "func_signal": "static void dispmanx_notify_callback( void *callback_param,\n                                      const VCHI_CALLBACK_REASON_T reason,\n                                      void *msg_handle )", "code": "{\n   VCOS_EVENT_T *event = (VCOS_EVENT_T *)callback_param;\n\n   (void)msg_handle;\n\n   if ( reason != VCHI_CALLBACK_MSG_AVAILABLE )\n      return;\n\n   if ( event == NULL )\n      return;\n\n   vcos_event_signal(event);\n}", "path": "circle/addon/vc4/interface/vmcs_host/vc_vchi_dispmanx.c", "commit_date": "2019-02-11 00:00:00", "repo_name": "rsta2/circle", "stars": 1703, "license": "gpl-3.0", "language": "c", "size": 6873}
{"docstring": "/******************************************************************************\nNAME\n   vc_dispmanx_query_image_formats\n\nPARAMS\n   uint32_t *support_formats - the returned supported image formats\n\nFUNCTION\n   Returns the support image formats from the VMCS host\n\nRETURNS\n   Success: 0\n   Otherwise non-zero\n******************************************************************************/\n", "func_signal": "VCHPRE_ int  VCHPOST_ vc_dispmanx_query_image_formats( uint32_t *supported_formats )", "code": "{\n   *supported_formats = dispmanx_get_handle(EDispmanQueryImageFormats, NULL, 0);\n   return (*supported_formats)? 0 : -1;\n}", "path": "circle/addon/vc4/interface/vmcs_host/vc_vchi_dispmanx.c", "commit_date": "2019-02-11 00:00:00", "repo_name": "rsta2/circle", "stars": 1703, "license": "gpl-3.0", "language": "c", "size": 6873}
{"docstring": "/***********************************************************\n * Name: vc_dispmanx_element_change_layer\n *\n * Arguments:\n *       DISPMANX_UPDATE_HANDLE_T update\n *       DISPMANX_ELEMENT_HANDLE_T element\n *       int32_t layer\n *\n * Description:\n *\n * Returns: VCHI error code\n *\n ***********************************************************/\n", "func_signal": "VCHPRE_ int VCHPOST_ vc_dispmanx_element_change_layer (DISPMANX_UPDATE_HANDLE_T update,\n                                                       DISPMANX_ELEMENT_HANDLE_T element,\n                                                       int32_t layer)", "code": "{\n   uint32_t element_param[] = { (uint32_t) VC_HTOV32(update),\n                                (uint32_t) VC_HTOV32(element),\n                                (uint32_t) VC_HTOV32(layer) };\n\n   int success = (int) dispmanx_send_command( EDispmanElementChangeLayer | DISPMANX_NO_REPLY_MASK,\n                                              element_param, sizeof(element_param));\n   return success;\n\n}", "path": "circle/addon/vc4/interface/vmcs_host/vc_vchi_dispmanx.c", "commit_date": "2019-02-11 00:00:00", "repo_name": "rsta2/circle", "stars": 1703, "license": "gpl-3.0", "language": "c", "size": 6873}
{"docstring": "/******************************************************************************\nStatic functions.\n******************************************************************************/\n//Lock the host state\n", "func_signal": "static __inline void lock_obtain (void)", "code": "{\n   VCOS_STATUS_T status;\n   uint32_t i;\n   vcos_assert(dispmanx_client.initialised);\n   status = vcos_mutex_lock( &dispmanx_client.lock );\n   if(dispmanx_client.initialised)\n   {\n      for (i=0; i<dispmanx_client.num_connections; i++) {\n         vchi_service_use(dispmanx_client.client_handle[i]);\n      }\n   }\n   vcos_assert(status == VCOS_SUCCESS);\n}", "path": "circle/addon/vc4/interface/vmcs_host/vc_vchi_dispmanx.c", "commit_date": "2019-02-11 00:00:00", "repo_name": "rsta2/circle", "stars": 1703, "license": "gpl-3.0", "language": "c", "size": 6873}
{"docstring": "/* Buffered write with code conversion */\n", "func_signal": "static void putc_bfd (putbuff* pb, TCHAR c)", "code": "{\n\tUINT n;\n\tint i, nc;\n#if FF_USE_LFN && FF_LFN_UNICODE\n\tWCHAR hs, wc;\n#if FF_LFN_UNICODE == 2\n\tDWORD dc;\n\tTCHAR *tp;\n#endif\n#endif\n\n\tif (FF_USE_STRFUNC == 2 && c == '\\n') {\t /* LF -> CRLF conversion */\n\t\tputc_bfd(pb, '\\r');\n\t}\n\n\ti = pb->idx;\t\t\t/* Write index of pb->buf[] */\n\tif (i < 0) return;\n\tnc = pb->nchr;\t\t\t/* Write unit counter */\n\n#if FF_USE_LFN && FF_LFN_UNICODE\n#if FF_LFN_UNICODE == 1\t\t/* UTF-16 input */\n\tif (IsSurrogateH(c)) {\t/* High surrogate? */\n\t\tpb->hs = c; return;\t/* Save it for next */\n\t}\n\ths = pb->hs; pb->hs = 0;\n\tif (hs != 0) {\t\t\t/* There is a leading high surrogate */\n\t\tif (!IsSurrogateL(c)) hs = 0;\t/* Discard high surrogate if not a surrogate pair */\n\t} else {\n\t\tif (IsSurrogateL(c)) return;\t/* Discard stray low surrogate */\n\t}\n\twc = c;\n#elif FF_LFN_UNICODE == 2\t/* UTF-8 input */\n\tfor (;;) {\n\t\tif (pb->ct == 0) {\t/* Out of multi-byte sequence? */\n\t\t\tpb->bs[pb->wi = 0] = (BYTE)c;\t/* Save 1st byte */\n\t\t\tif ((BYTE)c < 0x80) break;\t\t\t\t\t/* Single byte? */\n\t\t\tif (((BYTE)c & 0xE0) == 0xC0) pb->ct = 1;\t/* 2-byte sequence? */\n\t\t\tif (((BYTE)c & 0xF0) == 0xE0) pb->ct = 2;\t/* 3-byte sequence? */\n\t\t\tif (((BYTE)c & 0xF1) == 0xF0) pb->ct = 3;\t/* 4-byte sequence? */\n\t\t\treturn;\n\t\t} else {\t\t\t\t/* In the multi-byte sequence */\n\t\t\tif (((BYTE)c & 0xC0) != 0x80) {\t/* Broken sequence? */\n\t\t\t\tpb->ct = 0; continue;\n\t\t\t}\n\t\t\tpb->bs[++pb->wi] = (BYTE)c;\t/* Save the trailing byte */\n\t\t\tif (--pb->ct == 0) break;\t/* End of multi-byte sequence? */\n\t\t\treturn;\n\t\t}\n\t}\n\ttp = (TCHAR*)pb->bs;\n\tdc = tchar2uni(&tp);\t/* UTF-8 ==> UTF-16 */\n\tif (dc == 0xFFFFFFFF) return;\t/* Wrong code? */\n\twc = (WCHAR)dc;\n\ths = (WCHAR)(dc >> 16);\n#elif FF_LFN_UNICODE == 3\t/* UTF-32 input */\n\tif (IsSurrogate(c) || c >= 0x110000) return;\t/* Discard invalid code */\n\tif (c >= 0x10000) {\t\t/* Out of BMP? */\n\t\ths = (WCHAR)(0xD800 | ((c >> 10) - 0x40)); \t/* Make high surrogate */\n\t\twc = 0xDC00 | (c & 0x3FF);\t\t\t\t\t/* Make low surrogate */\n\t} else {\n\t\ths = 0;\n\t\twc = (WCHAR)c;\n\t}\n#endif\n\t/* A code point in UTF-16 is available in hs and wc */\n\n#if FF_STRF_ENCODE == 1\t\t/* Write a code point in UTF-16LE */\n\tif (hs != 0) {\t/* Surrogate pair? */\n\t\tst_word(&pb->buf[i], hs);\n\t\ti += 2;\n\t\tnc++;\n\t}\n\tst_word(&pb->buf[i], wc);\n\ti += 2;\n#elif FF_STRF_ENCODE == 2\t/* Write a code point in UTF-16BE */\n\tif (hs != 0) {\t/* Surrogate pair? */\n\t\tpb->buf[i++] = (BYTE)(hs >> 8);\n\t\tpb->buf[i++] = (BYTE)hs;\n\t\tnc++;\n\t}\n\tpb->buf[i++] = (BYTE)(wc >> 8);\n\tpb->buf[i++] = (BYTE)wc;\n#elif FF_STRF_ENCODE == 3\t/* Write a code point in UTF-8 */\n\tif (hs != 0) {\t/* 4-byte sequence? */\n\t\tnc += 3;\n\t\ths = (hs & 0x3FF) + 0x40;\n\t\tpb->buf[i++] = (BYTE)(0xF0 | hs >> 8);\n\t\tpb->buf[i++] = (BYTE)(0x80 | (hs >> 2 & 0x3F));\n\t\tpb->buf[i++] = (BYTE)(0x80 | (hs & 3) << 4 | (wc >> 6 & 0x0F));\n\t\tpb->buf[i++] = (BYTE)(0x80 | (wc & 0x3F));\n\t} else {\n\t\tif (wc < 0x80) {\t/* Single byte? */\n\t\t\tpb->buf[i++] = (BYTE)wc;\n\t\t} else {\n\t\t\tif (wc < 0x800) {\t/* 2-byte sequence? */\n\t\t\t\tnc += 1;\n\t\t\t\tpb->buf[i++] = (BYTE)(0xC0 | wc >> 6);\n\t\t\t} else {\t\t\t/* 3-byte sequence */\n\t\t\t\tnc += 2;\n\t\t\t\tpb->buf[i++] = (BYTE)(0xE0 | wc >> 12);\n\t\t\t\tpb->buf[i++] = (BYTE)(0x80 | (wc >> 6 & 0x3F));\n\t\t\t}\n\t\t\tpb->buf[i++] = (BYTE)(0x80 | (wc & 0x3F));\n\t\t}\n\t}\n#else\t\t\t\t\t\t/* Write a code point in ANSI/OEM */\n\tif (hs != 0) return;\n\twc = ff_uni2oem(wc, CODEPAGE);\t/* UTF-16 ==> ANSI/OEM */\n\tif (wc == 0) return;\n\tif (wc >= 0x100) {\n\t\tpb->buf[i++] = (BYTE)(wc >> 8); nc++;\n\t}\n\tpb->buf[i++] = (BYTE)wc;\n#endif\n\n#else\t\t\t\t\t\t\t\t\t/* ANSI/OEM input (without re-encoding) */\n\tpb->buf[i++] = (BYTE)c;\n#endif\n\n\tif (i >= (int)(sizeof pb->buf) - 4) {\t/* Write buffered characters to the file */\n\t\tf_write(pb->fp, pb->buf, (UINT)i, &n);\n\t\ti = (n == (UINT)i) ? 0 : -1;\n\t}\n\tpb->idx = i;\n\tpb->nchr = nc + 1;\n}", "path": "circle/addon/fatfs/ff.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "rsta2/circle", "stars": 1703, "license": "gpl-3.0", "language": "c", "size": 6873}
{"docstring": "/***********************************************************\n * Name: vc_dispmanx_element_remove\n *\n * Arguments:\n *       DISPMANX_UPDATE_HANDLE_T update\n *       DISPMANX_ELEMENT_HANDLE_T element\n *\n * Description:\n *\n * Returns:\n *\n ***********************************************************/\n", "func_signal": "VCHPRE_ int VCHPOST_ vc_dispmanx_element_remove( DISPMANX_UPDATE_HANDLE_T update, DISPMANX_ELEMENT_HANDLE_T element )", "code": "{\n   uint32_t element_param[] = {(uint32_t) VC_HTOV32(update), (uint32_t) VC_HTOV32(element)};\n   int success = (int) dispmanx_send_command( EDispmanElementRemove | DISPMANX_NO_REPLY_MASK,\n                                              element_param, sizeof(element_param));\n   return success;\n}", "path": "circle/addon/vc4/interface/vmcs_host/vc_vchi_dispmanx.c", "commit_date": "2019-02-11 00:00:00", "repo_name": "rsta2/circle", "stars": 1703, "license": "gpl-3.0", "language": "c", "size": 6873}
{"docstring": "/***********************************************************\n * Name: vc_dispmanx_display_open_mode\n *\n * Arguments:\n *       uint32_t device\n *       uint32_t mode\n *\n * Description:\n *\n * Returns:\n *\n ***********************************************************/\n", "func_signal": "VCHPRE_ DISPMANX_DISPLAY_HANDLE_T VCHPOST_ vc_dispmanx_display_open_mode( uint32_t device, uint32_t mode )", "code": "{\n   uint32_t display_open_param[] = {VC_HTOV32(device), VC_HTOV32(mode)};\n   uint32_t display_handle = dispmanx_get_handle(EDispmanDisplayOpenMode,\n                                                 &display_open_param, sizeof(display_open_param));\n\n   return (DISPMANX_DISPLAY_HANDLE_T) display_handle;\n}", "path": "circle/addon/vc4/interface/vmcs_host/vc_vchi_dispmanx.c", "commit_date": "2019-02-11 00:00:00", "repo_name": "rsta2/circle", "stars": 1703, "license": "gpl-3.0", "language": "c", "size": 6873}
{"docstring": "/***********************************************************\n * Name: dispmanx_get_handle\n *\n * Arguments: command, parameter buffer, parameter legnth\n *\n * Description: same as dispmanx_send_command but returns uint instead\n *\n * Returns: handle\n *\n ***********************************************************/\n", "func_signal": "static uint32_t dispmanx_get_handle(  uint32_t command, void *buffer, uint32_t length)", "code": "{\n   VCHI_MSG_VECTOR_T vector[] = { {&command, sizeof(command)},\n                                   {buffer, length} };\n   uint32_t success = 0;\n   uint32_t response = 0;\n   lock_obtain();\n   success += vchi_msg_queuev( dispmanx_client.client_handle[0],\n                               vector, sizeof(vector)/sizeof(vector[0]),\n                               VCHI_FLAGS_BLOCK_UNTIL_QUEUED, NULL );\n   if(success == 0)\n      success = dispmanx_wait_for_reply(&response, sizeof(response));\n\n   lock_release();\n   return VC_VTOH32(response);\n}", "path": "circle/addon/vc4/interface/vmcs_host/vc_vchi_dispmanx.c", "commit_date": "2019-02-11 00:00:00", "repo_name": "rsta2/circle", "stars": 1703, "license": "gpl-3.0", "language": "c", "size": 6873}
{"docstring": "/******************************************************************************\nNAME\n   vc_vchi_gencmd_init\n\nSYNOPSIS\n   void vc_vchi_gencmd_init(VCHI_INSTANCE_T initialise_instance, VCHI_CONNECTION_T **connections, uint32_t num_connections )\n\nFUNCTION\n   Initialise the general command service for use. A negative return value\n   indicates failure (which may mean it has not been started on VideoCore).\n\nRETURNS\n   int\n******************************************************************************/\n", "func_signal": "void vc_vchi_dispmanx_init (VCHI_INSTANCE_T initialise_instance, VCHI_CONNECTION_T **connections, uint32_t num_connections )", "code": "{\n   VCOS_STATUS_T status;\n   int32_t success;\n   uint32_t i;\n\n   if (dispmanx_client.initialised)\n     return;\n\n   // record the number of connections\n   memset( &dispmanx_client, 0, sizeof(DISPMANX_SERVICE_T) );\n   dispmanx_client.num_connections = num_connections;\n\n   status = vcos_mutex_create(&dispmanx_client.lock, \"HDispmanx\");\n   vcos_assert(status == VCOS_SUCCESS);\n\n   status = vcos_event_create(&dispmanx_message_available_event, \"HDispmanx\");\n   vcos_assert(status == VCOS_SUCCESS);\n\n   status = vcos_event_create(&dispmanx_notify_available_event, \"HDispmanx\");\n   vcos_assert(status == VCOS_SUCCESS);\n\n   dispmanx_client.initialised = 1;\n\n   for (i=0; i<dispmanx_client.num_connections; i++) {\n\n      VCOS_THREAD_ATTR_T attrs;\n\n      // Create a 'Client' service on the each of the connections\n      SERVICE_CREATION_T dispmanx_parameters = { VCHI_VERSION(VC_DISPMANX_VERSION),\n                                                 DISPMANX_CLIENT_NAME,     // 4cc service code\n                                                 connections[i],           // passed in fn ptrs\n                                                 0,                        // tx fifo size (unused)\n                                                 0,                        // tx fifo size (unused)\n                                                 &dispmanx_client_callback, // service callback\n                                                 &dispmanx_message_available_event,  // callback parameter\n                                                 VC_FALSE,                  // want_unaligned_bulk_rx\n                                                 VC_FALSE,                  // want_unaligned_bulk_tx\n                                                 VC_FALSE,                  // want_crc\n                                                 };\n\n      SERVICE_CREATION_T dispmanx_parameters2 = { VCHI_VERSION(VC_DISPMANX_VERSION),\n                                                  DISPMANX_NOTIFY_NAME,   // 4cc service code\n                                                  connections[i],           // passed in fn ptrs\n                                                  0,                        // tx fifo size (unused)\n                                                  0,                        // tx fifo size (unused)\n                                                  &dispmanx_notify_callback, // service callback\n                                                  &dispmanx_notify_available_event,  // callback parameter\n                                                  VC_FALSE,                  // want_unaligned_bulk_rx\n                                                  VC_FALSE,                  // want_unaligned_bulk_tx\n                                                  VC_FALSE,                  // want_crc\n                                                   };\n\n      success = vchi_service_open( initialise_instance, &dispmanx_parameters, &dispmanx_client.client_handle[i] );\n      vcos_assert( success == 0 );\n\n      // Create the async service of dispman to handle update callback\n\n      success = vchi_service_open( initialise_instance, &dispmanx_parameters2, &dispmanx_client.notify_handle[i] );\n      vcos_assert( success == 0 );\n\n      //Create the notifier task\n      vcos_thread_attr_init(&attrs);\n      vcos_thread_attr_setstacksize(&attrs, 2048);\n      vcos_thread_attr_settimeslice(&attrs, 1);\n\n      status = vcos_thread_create(&dispmanx_notify_task, \"HDispmanx Notify\", &attrs, dispmanx_notify_func, NULL);\n      vcos_assert(status == VCOS_SUCCESS);\n\n      // release services until they're actually used\n      vchi_service_release(dispmanx_client.client_handle[i]);\n      vchi_service_release(dispmanx_client.notify_handle[i]);\n   }\n}", "path": "circle/addon/vc4/interface/vmcs_host/vc_vchi_dispmanx.c", "commit_date": "2019-02-11 00:00:00", "repo_name": "rsta2/circle", "stars": 1703, "license": "gpl-3.0", "language": "c", "size": 6873}
{"docstring": "/* Flush remaining characters in the buffer */\n", "func_signal": "static int putc_flush (putbuff* pb)", "code": "{\n\tUINT nw;\n\n\tif (   pb->idx >= 0\t/* Flush buffered characters to the file */\n\t\t&& f_write(pb->fp, pb->buf, (UINT)pb->idx, &nw) == FR_OK\n\t\t&& (UINT)pb->idx == nw) return pb->nchr;\n\treturn EOF;\n}", "path": "circle/addon/fatfs/ff.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "rsta2/circle", "stars": 1703, "license": "gpl-3.0", "language": "c", "size": 6873}
{"docstring": "/***********************************************************\n * Name: vc_dispmanx_update_submit_sync\n *\n * Arguments:\n *       DISPMANX_UPDATE_HANDLE_T update\n *\n * Description:\n *\n * Returns: VCHI error code\n *\n ***********************************************************/\n", "func_signal": "VCHPRE_ int VCHPOST_ vc_dispmanx_update_submit_sync( DISPMANX_UPDATE_HANDLE_T update )", "code": "{\n   int success;\n   update = VC_HTOV32(update);\n   success = (int) dispmanx_send_command( EDispmanUpdateSubmitSync,\n                                          &update, sizeof(update));\n   return success;\n}", "path": "circle/addon/vc4/interface/vmcs_host/vc_vchi_dispmanx.c", "commit_date": "2019-02-11 00:00:00", "repo_name": "rsta2/circle", "stars": 1703, "license": "gpl-3.0", "language": "c", "size": 6873}
{"docstring": "/* Initialize write buffer */\n", "func_signal": "static void putc_init (putbuff* pb, FIL* fp)", "code": "{\n\tmem_set(pb, 0, sizeof (putbuff));\n\tpb->fp = fp;\n}", "path": "circle/addon/fatfs/ff.c", "commit_date": "2020-12-13 00:00:00", "repo_name": "rsta2/circle", "stars": 1703, "license": "gpl-3.0", "language": "c", "size": 6873}
{"docstring": "/***********************************************************\n * Name: vc_dispmanx_display_get_info\n *\n * Arguments:\n *       DISPMANX_DISPLAY_HANDLE_T display\n *       DISPMANX_MODEINFO_T * pinfo\n *\n * Description:\n *\n * Returns: VCHI error\n *\n ***********************************************************/\n", "func_signal": "VCHPRE_ int VCHPOST_\nvc_dispmanx_display_get_info (DISPMANX_DISPLAY_HANDLE_T display,\n                              DISPMANX_MODEINFO_T *pinfo)", "code": "{\n   GET_INFO_DATA_T info;\n   int32_t success;\n   display = VC_HTOV32(display);\n   success = dispmanx_send_command_reply (EDispmanDisplayGetInfo,\n                                          &display, sizeof(display),\n                                          &info, sizeof(info));\n   if(success == 0) {\n      pinfo->width = VC_VTOH32(info.width);\n      pinfo->height = VC_VTOH32(info.height);\n      pinfo->transform = (DISPMANX_TRANSFORM_T)VC_VTOH32(info.transform);\n      pinfo->input_format = (DISPLAY_INPUT_FORMAT_T)VC_VTOH32(info.input_format);\n   }\n\n   return (int) success;\n}", "path": "circle/addon/vc4/interface/vmcs_host/vc_vchi_dispmanx.c", "commit_date": "2019-02-11 00:00:00", "repo_name": "rsta2/circle", "stars": 1703, "license": "gpl-3.0", "language": "c", "size": 6873}
{"docstring": "/***********************************************************\n * Name: vc_dispmanx_rect_set\n *\n * Arguments:\n *       VC_RECT_T *rect\n *       uint32_t x_offset\n *       uint32_t y_offset\n *       uint32_t width\n *       uint32_t height\n *\n * Description: Fills in the fields of the supplied VC_RECT_T structure\n *\n * Returns: 0 or failure\n *\n ***********************************************************/\n", "func_signal": "VCHPRE_ int VCHPOST_ vc_dispmanx_rect_set( VC_RECT_T *rect, uint32_t x_offset, uint32_t y_offset, uint32_t width, uint32_t height )", "code": "{\n   rect->x = (int32_t) x_offset;\n   rect->y = (int32_t) y_offset;\n   rect->width = (int32_t) width;\n   rect->height = (int32_t) height;\n   return 0;\n}", "path": "circle/addon/vc4/interface/vmcs_host/vc_vchi_dispmanx.c", "commit_date": "2019-02-11 00:00:00", "repo_name": "rsta2/circle", "stars": 1703, "license": "gpl-3.0", "language": "c", "size": 6873}
{"docstring": "// Checks the key/value pair for known keys. Parses values as necessary\n// to populate an employee structure. \n// The week field is used to maintain stateful awareness of the week when logging hours. \n// See merge_employee_records for proper usage of key/value pairs\n", "func_signal": "void process_key_value(pemployee empl, char *key, char *value, int *week)", "code": "{\n\tif (equals(key, \"employee_id\"))\n\t{\n\t\templ->id = atoi(value);\n\t}\n\tif (equals(key, \"employee_name\"))\n\t{\n\t\tstrncpy(empl->name, value, EMPLOYEE_NAME_LEN);\n\t}\n\tif (equals(key, \"wage\"))\n\t{\n\t\tatom(&empl->wage, value);\n\t\t// Cap maximum wage at $75/hr\n\t\tif(empl->wage.dollars >= 75)\n\t\t{\n\t\t\templ->wage.dollars = 75;\n\t\t\templ->wage.cents = 0;\n\t\t}\n\t}\n\tif (equals(key, \"exempt\"))\n\t{\n\t\tif (equals(value, \"yes\"))\n\t\t{\n\t\t\templ->exempt = 1;\n\t\t}\n\t}\n\tif (equals(key, \"week\"))\n\t{\n\t\t*week = atoi(value);\n\t\tif ((*week < 0) || (*week >= 52))\n\t\t{\n\t\t\t*week = 0;\n\t\t}\n\t}\n\tif (equals(key, \"monday\") || \n\t\tequals(key, \"tuesday\") || \n\t\tequals(key, \"wednesday\") || \n\t\tequals(key, \"thursday\") || \n\t\tequals(key, \"friday\"))\n\t{\n\t\tlog_hours(&empl->paychecks[*week], value);\n\n\t}\n\tif (equals(key, \"saturday\") ||\n\t\tequals(key, \"sunday\"))\n\t{\n\t\tlog_overtime_hours(&empl->paychecks[*week], value);\n\t}\n}", "path": "afl-training/challenges/cyber-grand-challenge/CROMU_00007/src/timecard.c", "commit_date": "2017-06-28 00:00:00", "repo_name": "mykter/afl-training", "stars": 1168, "license": "other", "language": "c", "size": 541}
{"docstring": "// Calculate pay and add to a money struct\n", "func_signal": "void add_pay(pmoney pay, pmoney rate, ptime timeworked)", "code": "{\n\tfloat float_rate = (float)rate->dollars + ((float)rate->cents / 100.0);\n\tfloat minute_rate = float_rate / 60.0;\n\n\tadd_money(pay, timeworked->hours * float_rate + timeworked->minutes * minute_rate);\n}", "path": "afl-training/challenges/cyber-grand-challenge/CROMU_00007/src/timecard.c", "commit_date": "2017-06-28 00:00:00", "repo_name": "mykter/afl-training", "stars": 1168, "license": "other", "language": "c", "size": 541}
{"docstring": "// Converts a char string into a money struct. \n", "func_signal": "void atom(pmoney amount, char *str)", "code": "{\n\tsize_t i = 0;\n\tint negative = 0;\n\tamount->cents = 0;\n\tamount->dollars = 0;\n\n\tif(str[i] == '-')\n\t{\n\t\tnegative = 1;\n\t\ti++;\n\t}\n\tfor(; isdigit(str[i]); i++)\n\t{\n\t\tamount->dollars = (amount->dollars * 10) + (str[i] - '0');\n\t}\n\tif (str[i] == '.')\n\t{\n\t\tif (isdigit(str[i+1]))\n\t\t{\n\t\t\tamount->cents = 10 * (str[i+1] - '0');\n\t\t\tif (isdigit(str[i+2]))\n\t\t\t{\n\t\t\t\tamount->cents += (str[i+2] - '0');\n\t\t\t}\n\t\t}\n\t}\n\tif (negative)\n\t{\n\t\tamount->dollars = -amount->dollars;\n\t}\n}", "path": "afl-training/challenges/cyber-grand-challenge/CROMU_00007/src/timecard.c", "commit_date": "2017-06-28 00:00:00", "repo_name": "mykter/afl-training", "stars": 1168, "license": "other", "language": "c", "size": 541}
{"docstring": "// Reads input from the network in the format key-value` and parses the \n// key/value pair by searching for delimiters and replacing with NULL\n// Returns status code:\n// READ_ERROR - Indicates a problem receiving from the network\n// NEWLINE_RECEIVED - Indicates a newline character was received\n// KEY_VALUE_RECEIVED - Indicates a valid key/value pair received\n// \t\t**key points to start of null terminated key string\n//\t\t**value points to start of null terminated value string\n// OTHER_INPUT_RECEIVED - Input received that does not match previous options\n", "func_signal": "int get_key_value(char *inbuf, size_t length, char **key, char **value)", "code": "{\n\tint count;\n\tint pos = 0;\n\tchar c;\n\tchar buffer[80];\n\n\twhile ( (count = read(STDIN_FILENO, &c, 1)) == 1) {\n\t\tinbuf[pos++] = c;\n\t\tif(c == '\\n')\n\t\t{\n\t\t\treturn NEWLINE_RECEIVED;\n\t\t} else if(c == '`') {\n\t\t\tchar *search = inbuf + pos - 1;\n\t\t\t*search = '\\0';\n\t\t\twhile(search > inbuf)\n\t\t\t{\n\t\t\t\tsearch--;\n\t\t\t\tif (*search == '-')\n\t\t\t\t{\n\t\t\t\t\t*key = inbuf;\n\t\t\t\t\t*search = '\\0';\n\t\t\t\t\t*value = search + 1;\n\t\t\t\t\treturn KEY_VALUE_RECEIVED;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\tif (count != 0) {\n\t\treturn READ_ERROR;\n\t}\n\treturn OTHER_INPUT_RECEIVED; // EOF\n\n}", "path": "afl-training/challenges/cyber-grand-challenge/CROMU_00007/src/timecard.c", "commit_date": "2017-06-28 00:00:00", "repo_name": "mykter/afl-training", "stars": 1168, "license": "other", "language": "c", "size": 541}
{"docstring": "// Calculates overtime pay for an nonexempt employee based on wage and overtime worked \n// Used to populate the overtimepay field of an employee's weekly payroll\n", "func_signal": "void nonexempt_overtime(pmoney pay, pmoney rate, ptime timeworked)", "code": "{\n\tpay->dollars = 0;\n\tpay->cents = 0;\n\n\tfloat float_rate = ((float)rate->dollars + ((float)rate->cents / 100.0)) * 1.5;\n\tfloat minute_rate = (float_rate / 60.0);\n\tadd_money(pay, timeworked->hours * float_rate + timeworked->minutes * minute_rate );\n}", "path": "afl-training/challenges/cyber-grand-challenge/CROMU_00007/src/timecard.c", "commit_date": "2017-06-28 00:00:00", "repo_name": "mykter/afl-training", "stars": 1168, "license": "other", "language": "c", "size": 541}
{"docstring": "// Adds overtime to an employee's payroll (used for weekends)\n", "func_signal": "void log_overtime_hours(ppayroll paycheck, char *hours)", "code": "{\n\ttime t;\n\tatoh(&t, hours);\n\t// Round time worked to the nearest quarter hour \n\tround_minutes(&t);\n\tadd_time(&paycheck->overtime, t.hours, t.minutes);\n}", "path": "afl-training/challenges/cyber-grand-challenge/CROMU_00007/src/timecard.c", "commit_date": "2017-06-28 00:00:00", "repo_name": "mykter/afl-training", "stars": 1168, "license": "other", "language": "c", "size": 541}
{"docstring": "// Adds money to a money struct, rounding cents to nearest 1c.\n", "func_signal": "void add_money(pmoney dest, float money)", "code": "{\n\tfloat total;\n\t// Convert dest amount back to float\n\ttotal = (float)dest->dollars + ((float)dest->cents / 100.0);\n\t// Add money and round up/down to nearest cent\n\ttotal = total + money;\n\n\tif (total > 0)\n\t{\n\t\ttotal = total + 0.005;\n\t}\n\telse\n\t{\n\t\ttotal = total - 0.005;\n\t}\n\t// Convert back to money struct\n\tdest->dollars = (int)total;\n\tdest->cents = (int)((total - (float)dest->dollars) * 100);\n\n}", "path": "afl-training/challenges/cyber-grand-challenge/CROMU_00007/src/timecard.c", "commit_date": "2017-06-28 00:00:00", "repo_name": "mykter/afl-training", "stars": 1168, "license": "other", "language": "c", "size": 541}
{"docstring": "// Calculates total pay, subtracts taxes withheld, and outputs total to the \n// paycheck field of an employee's weekly payroll\n", "func_signal": "void calculate_totalpay(ppayroll paycheck)", "code": "{\n\tmoney total;\n\ttotal.dollars = 0;\n\ttotal.cents = 0;\n\tadd_money(&total, (float)paycheck->standardpay.dollars + (float)paycheck->standardpay.cents / 100.0);\n\tadd_money(&total, (float)paycheck->overtimepay.dollars + (float)paycheck->overtimepay.cents / 100.0);\n\tadd_money(&total, -1.0 * (((float)total.dollars + (float)total.cents/100.0) * PAYROLL_TAX_RATE) );\n\n\tmtoa((char *)&paycheck->paycheck, &total);\n}", "path": "afl-training/challenges/cyber-grand-challenge/CROMU_00007/src/timecard.c", "commit_date": "2017-06-28 00:00:00", "repo_name": "mykter/afl-training", "stars": 1168, "license": "other", "language": "c", "size": 541}
{"docstring": "// These functions are to be used by the poller to aleviate issues with floating point implementation differences \n// and rounding errors\n", "func_signal": "float c_standardpay(int hours, int minutes, int dollars, int cents)", "code": "{\n\tmoney total;\n\tfloat float_rate = (float)dollars + ((float)cents / 100.0);\n\tfloat minute_rate = (float_rate / 60.0);\n\ttotal.dollars = 0;\n\ttotal.cents = 0;\n\tadd_money(&total, hours * float_rate + minutes * minute_rate);\n\treturn (float)total.dollars + ((float)total.cents / 100.0);\n}", "path": "afl-training/challenges/cyber-grand-challenge/CROMU_00007/src/timecard.c", "commit_date": "2017-06-28 00:00:00", "repo_name": "mykter/afl-training", "stars": 1168, "license": "other", "language": "c", "size": 541}
{"docstring": "// Output an employee's payroll for one week\n", "func_signal": "void output_paycheck(pemployee empl, int week)", "code": "{\n\tchar outbuf[20];\n\t// Output result\n\tprintf(\"employee-\");\n\tprintf(\"%s\",empl->name);\n\tprintf(\"`week-%d\", week);\n\tprintf(\"`standardtime-\");\n\thtoa((char *)&outbuf, &empl->paychecks[week].standardtime);\n\tprintf(\"%s\",outbuf);\n\tprintf(\"`overtime-\");\n\thtoa((char *)&outbuf, &empl->paychecks[week].overtime);\n\tprintf(\"%s\",outbuf);\n\tprintf(\"`standardpay-\");\n\tmtoa((char *)&outbuf, &empl->paychecks[week].standardpay);\n\tprintf(\"%s\",outbuf);\n\tprintf(\"`overtimepay-\");\n\tmtoa((char *)&outbuf, &empl->paychecks[week].overtimepay);\n\tprintf(\"%s\",outbuf);\n\tprintf(\"`netpay-\");\n\tcalculate_totalpay(&empl->paychecks[week]);\n\tprintf(\"%s\",empl->paychecks[week].paycheck);\n\tprintf(\"`\\n\");\n}", "path": "afl-training/challenges/cyber-grand-challenge/CROMU_00007/src/timecard.c", "commit_date": "2017-06-28 00:00:00", "repo_name": "mykter/afl-training", "stars": 1168, "license": "other", "language": "c", "size": 541}
{"docstring": "// Converts a money struct into a character string\n// str should point to a buffer at least 19 bytes long to handle max value\n// $-2,147,483,647.00\n", "func_signal": "void mtoa(char *str, pmoney amount)", "code": "{\n\tchar buffer[20];\n\tsize_t pos = 0;\n\tsize_t outpos;\n\tint value = amount->cents;\n\tint negative = 0;\n\n\tif (value < 0)\n\t{\n\t\tvalue  = -value;\n\t}\n\tbuffer[pos++] = '0' + (value % 10);\n\tvalue /= 10;\n\tbuffer[pos++] = '0' + (value % 10);\n\tbuffer[pos++] = '.';\n\tvalue = amount->dollars;\n\tif (value < 0)\n\t{\n\t\tvalue = -value;\n\t\tnegative = 1;\n\t}\n\tdo\n\t{\n\t\tif ((pos == 6)||(pos == 10)||(pos==14))\n\t\t{\n\t\t\tbuffer[pos++] = ',';\n\t\t}\n\t\tbuffer[pos++] = '0' + value % 10;\n\t\tvalue /= 10;\n\t} while((value > 0) && (pos < 63));\n\tif (negative)\n\t{\n\t\tbuffer[pos++] = '-';\n\t}\n\toutpos = 1;\n\tstr[0] = '$';\n\twhile(outpos <= pos)\n\t{\n\t\tstr[outpos] = buffer[pos - outpos];\n\t\toutpos++;\n\t}\n\tstr[outpos] = '\\0';\n}", "path": "afl-training/challenges/cyber-grand-challenge/CROMU_00007/src/timecard.c", "commit_date": "2017-06-28 00:00:00", "repo_name": "mykter/afl-training", "stars": 1168, "license": "other", "language": "c", "size": 541}
{"docstring": "// Process the query based on type\n// \tQUERY_ALL - outputs all valid employee records \n// \tQUERY_ONE - outputs one employee record\n// \tQUERY_WEEK - outputs one week of one employees record\t\t\n", "func_signal": "void process_query(int query, employee *employee_list, pemployee temp, int week)", "code": "{\n\tswitch (query)\n\t{\n\t\tcase QUERY_ALL:\n\t\t{\n\t\t\tint employee, week;\n\t\t\tfor (employee=0; employee < NUMBER_OF_EMPLOYEES; employee++)\n\t\t\t{\n\t\t\t\t// Ignore unregistered slots\n\t\t\t\tif (employee_list[employee].id == -1)\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tfor (week=0; week < WEEKS_IN_A_YEAR; week++)\n\t\t\t\t{\n\t\t\t\t\toutput_paycheck(&employee_list[employee], week);\n\t\t\t\t}\n\t\t\t\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase QUERY_ONE:\n\t\t{\n\n\t\t\tint week;\n\t\t\tif ((temp->id >= 0) && (temp->id < NUMBER_OF_EMPLOYEES))\n\t\t\t{\n\t\t\t\t// Ignore unregistered slots\n\t\t\t\tif (employee_list[temp->id].id == -1)\n\t\t\t\t\tbreak;\n\n\t\t\t\tfor (week = 0; week < WEEKS_IN_A_YEAR; week++)\n\t\t\t\t{\n\t\t\t\t\toutput_paycheck(&employee_list[temp->id], week);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase QUERY_WEEK:\n#ifndef PATCHED\n\t\t\t// Ignore unregistered slots\n\t\t\tif (employee_list[temp->id].id == -1)\n\t\t\t\tbreak;\n#endif \n\n\t\t\tif ((temp->id >= 0) && (temp->id < NUMBER_OF_EMPLOYEES)\n\t\t\t\t&& (week >= 0) && (week < WEEKS_IN_A_YEAR))\n\t\t\t{\n#ifdef PATCHED\n\t\t\t\t// Ignore unregistered slots\n\t\t\t\tif (employee_list[temp->id].id == -1)\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\toutput_paycheck(&employee_list[temp->id], week);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase QUERY_WEEK_ALL:\n\t\t{\n\t\t\tint employee;\n\t\t\tif ((week >= 0) && (week < WEEKS_IN_A_YEAR))\n\t\t\t{\n\t\t\t\tfor (employee=0; employee<NUMBER_OF_EMPLOYEES; employee++)\n\t\t\t\t{\n\t\t\t\t\t// Ignore unregistered slots\n\t\t\t\t\tif (employee_list[employee].id == -1)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\toutput_paycheck(&employee_list[employee], week);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase QUERY_NONE:\n\t\tdefault:\n\t\t\tbreak;\n\t}\t\t\t\n\n}", "path": "afl-training/challenges/cyber-grand-challenge/CROMU_00007/src/timecard.c", "commit_date": "2017-06-28 00:00:00", "repo_name": "mykter/afl-training", "stars": 1168, "license": "other", "language": "c", "size": 541}
{"docstring": "// Merges the contents of one employee struct with another. \n// Used to add a line of input to the global employee record. \n// \n// When the line contains a name field, the line is treated as a\n// registration command which can have the following fields:\n//\temployee_id-#`\n//\temployee_name-ASCII`\n//\twage-#.##`\n//\texempt-(yes|no)`\n// Otherwise it is a time log which can have the following fields:\n//\temployee_id-#`\n//\tweek-#`\n//\tmonday-#h#m`\n//\t... \n//\tsunday-#h#m`\n", "func_signal": "void merge_employee_records(pemployee empl, pemployee temp)", "code": "{\n\t// Only populate employee record the first time a name is given\n\tif ((empl->id == -1) && (temp->name[0] != '\\0'))\n\t{\n\t\tstrncpy(empl->name, temp->name, EMPLOYEE_NAME_LEN);\n\t\templ->id = temp->id;\n\t\templ->wage.dollars = temp->wage.dollars;\n\t\templ->wage.cents = temp->wage.cents;\n\t\templ->exempt = temp->exempt;\n\t}\n\t// If employee does not yet exist and no name is given, ignore this line\n\telse if (empl->id == -1)\n\t{\n\t\treturn;\n\t}\n\t// Otherwise, treat line as a time log\n\telse\n\t{\n\t\tint week;\n\t\tfor (week = 0; week < WEEKS_IN_A_YEAR; week++)\n\t\t{\n\t\t\tadd_time(&empl->paychecks[week].standardtime, temp->paychecks[week].standardtime.hours, \n\t\t\t\ttemp->paychecks[week].standardtime.minutes);\n\t\t\tadd_time(&empl->paychecks[week].overtime, temp->paychecks[week].overtime.hours, \n\t\t\t\ttemp->paychecks[week].overtime.minutes);\n\n\t\t\tif (empl->exempt == 0)\n\t\t\t{\n\t\t\t\templ->paychecks[week].calculate_overtime = &nonexempt_overtime;\n\t\t\t}\n\n\t\t\tcalculate_standardpay(&empl->paychecks[week].standardpay, &empl->wage, &empl->paychecks[week].standardtime);\n\t\t\templ->paychecks[week].calculate_overtime(&empl->paychecks[week].overtimepay, &empl->wage, &empl->paychecks[week].overtime);\n\t\t}\n\t}\n}", "path": "afl-training/challenges/cyber-grand-challenge/CROMU_00007/src/timecard.c", "commit_date": "2017-06-28 00:00:00", "repo_name": "mykter/afl-training", "stars": 1168, "license": "other", "language": "c", "size": 541}
{"docstring": "// Calculates standard pay based on wage and timeworked \n// Used to populate the standardpay field of an employee's weekly payroll\n", "func_signal": "void calculate_standardpay(pmoney pay, pmoney wage, ptime timeworked)", "code": "{\n\tpay->dollars = 0;\n\tpay->cents = 0;\n\t\n\tadd_pay(pay, wage, timeworked);\n}", "path": "afl-training/challenges/cyber-grand-challenge/CROMU_00007/src/timecard.c", "commit_date": "2017-06-28 00:00:00", "repo_name": "mykter/afl-training", "stars": 1168, "license": "other", "language": "c", "size": 541}
{"docstring": "// Calculates overtime pay for an exempt employee based on wage and overtime worked \n// Used to populate the overtimepay field of an employee's weekly payroll\n", "func_signal": "void exempt_overtime(pmoney pay, pmoney wage, ptime timeworked)", "code": "{\n\tmoney overtime_wage;\n\tovertime_wage.dollars = 0;\n\tovertime_wage.cents = 0;\n\tpay->dollars = 0;\n\tpay->cents = 0;\n\n\tadd_money(&overtime_wage, ((float)wage->dollars + ((float)wage->cents/100.0)) * 1.0);\n\tadd_pay(pay, &overtime_wage, timeworked);\n}", "path": "afl-training/challenges/cyber-grand-challenge/CROMU_00007/src/timecard.c", "commit_date": "2017-06-28 00:00:00", "repo_name": "mykter/afl-training", "stars": 1168, "license": "other", "language": "c", "size": 541}
{"docstring": "// Converts a character string into a time struct\n", "func_signal": "void atoh(ptime t, char *str)", "code": "{\n\tint pos = 0;\n\tint value = 0;\n\tt->hours = 0;\n\tt->minutes = 0;\n\twhile(isdigit(str[pos]))\n\t{\n\t\tvalue = (value * 10) + (str[pos] - '0');\n\t\tpos++;\n\t}\n\tif(str[pos] == 'h')\n\t{\n\t\tt->hours = value;\n\t\tpos++;\n\t}\n\tvalue = 0;\n\twhile(isdigit(str[pos]))\n\t{\n\t\tvalue = (value * 10) + (str[pos] - '0');\n\t\tpos++;\n\t}\n\tif (str[pos] == 'm')\n\t{\n\t\tt->minutes = value;\n\t}\n\tif (t->hours > 24)\n\t{\n\t\tt->hours = 24;\n\t}\n\tif (t->minutes > 59)\n\t{\n\t\tt->minutes = 59;\n\t}\n}", "path": "afl-training/challenges/cyber-grand-challenge/CROMU_00007/src/timecard.c", "commit_date": "2017-06-28 00:00:00", "repo_name": "mykter/afl-training", "stars": 1168, "license": "other", "language": "c", "size": 541}
{"docstring": "// Initialize an employee structure \n", "func_signal": "void initialize_employee(pemployee empl)", "code": "{\n\tint i,j;\n\templ->name[0] = '\\0';\n\t// An id value of -1 is used elsewhere to determine whether an employee has been registered\n\templ->id = -1;\n\templ->wage.dollars = 0;\n\templ->wage.cents = 0;\n\templ->exempt = 0;\n\tfor (i=0; i<WEEKS_IN_A_YEAR; i++)\n\t{\n\t\templ->paychecks[i].standardtime.hours = 0;\n\t\templ->paychecks[i].standardtime.minutes = 0;\n\t\templ->paychecks[i].overtime.hours = 0;\n\t\templ->paychecks[i].overtime.minutes = 0;\n\t\templ->paychecks[i].calculate_overtime = &exempt_overtime;\n\t\templ->paychecks[i].payroll_tax.dollars = 0;\n\t\templ->paychecks[i].payroll_tax.cents = 0;\n\t\tmemset(empl->paychecks[i].paycheck, 0, sizeof(empl->paychecks[i].paycheck));\n\t}\n}", "path": "afl-training/challenges/cyber-grand-challenge/CROMU_00007/src/timecard.c", "commit_date": "2017-06-28 00:00:00", "repo_name": "mykter/afl-training", "stars": 1168, "license": "other", "language": "c", "size": 541}
{"docstring": "// Converts a time struct into a character string\n// str should point to a buffer at least 15 bytes long to handle the max value\n// h2147483647m60\\0\n", "func_signal": "void htoa(char *str, ptime t)", "code": "{\n\tchar buffer[15];\n\tint pos=0;\n\tint outpos = 0;\n\tint value;\n\tvalue = t->minutes;\n\tif (value > 60)\n\t{\n\t\tstr[outpos] = '\\0';\n\t\treturn;\n\t}\n\tbuffer[pos++] = 'm';\n\tdo\n\t{\n\t\tbuffer[pos++] = '0' + value % 10;\n\t\tvalue /= 10;\n\t} while(value > 0);\n\tbuffer[pos++] = 'h';\n\tvalue = t->hours;\n\tdo\n\t{\n\t\tbuffer[pos++] = '0' + value % 10;\n\t\tvalue /= 10;\n\t} while(value > 0);\n\twhile(outpos < pos)\n\t{\n\t\tstr[outpos] = buffer[pos - outpos - 1];\n\t\toutpos++;\n\t}\n\tstr[outpos] = '\\0';\n}", "path": "afl-training/challenges/cyber-grand-challenge/CROMU_00007/src/timecard.c", "commit_date": "2017-06-28 00:00:00", "repo_name": "mykter/afl-training", "stars": 1168, "license": "other", "language": "c", "size": 541}
{"docstring": "// Rounds time to the nearest quarter hour\n", "func_signal": "void round_minutes(ptime t)", "code": "{\n\n\tif (t->minutes < 8)\n\t{\n\t\tt->minutes = 0;\n\t}\n\telse if (t->minutes < 23)\n\t{\n\t\tt->minutes = 15;\n\t}\n\telse if (t->minutes < 38)\n\t{\n\t\tt->minutes = 30;\n\t}\n\telse if (t->minutes < 53)\n\t{\n\t\tt->minutes = 45;\n\t}\n\telse\n\t{\n\t\tt->hours += 1;\n\t\tt->minutes = 0;\n\t}\n}", "path": "afl-training/challenges/cyber-grand-challenge/CROMU_00007/src/timecard.c", "commit_date": "2017-06-28 00:00:00", "repo_name": "mykter/afl-training", "stars": 1168, "license": "other", "language": "c", "size": 541}
{"docstring": "// Adds hours and minutes to a time struct\n", "func_signal": "void add_time(ptime t, int hours, int minutes)", "code": "{\n\tt->hours += hours + (t->minutes + minutes) / 60;\n\tt->minutes = (t->minutes + minutes) % 60;\n}", "path": "afl-training/challenges/cyber-grand-challenge/CROMU_00007/src/timecard.c", "commit_date": "2017-06-28 00:00:00", "repo_name": "mykter/afl-training", "stars": 1168, "license": "other", "language": "c", "size": 541}
{"docstring": "/**\n * Initializes an ART tree\n * @return 0 on success.\n */\n", "func_signal": "int init_art_tree(art_tree *t)", "code": "{\n    t->root = NULL;\n    t->size = 0;\n    return 0;\n}", "path": "bloomd/src/bloomd/art.c", "commit_date": "2016-12-15 00:00:00", "repo_name": "armon/bloomd", "stars": 1233, "license": "other", "language": "c", "size": 3015}
{"docstring": "// Find the maximum leaf under a node\n", "func_signal": "static art_leaf* maximum(art_node *n)", "code": "{\n    // Handle base cases\n    if (!n) return NULL;\n    if (IS_LEAF(n)) return LEAF_RAW(n);\n\n    int idx;\n    switch (n->type) {\n        case NODE4:\n            return maximum(((art_node4*)n)->children[n->num_children-1]);\n        case NODE16:\n            return maximum(((art_node16*)n)->children[n->num_children-1]);\n        case NODE48:\n            idx=255;\n            while (!((art_node48*)n)->keys[idx]) idx--;\n            idx = ((art_node48*)n)->keys[idx] - 1;\n            return maximum(((art_node48*)n)->children[idx]);\n        case NODE256:\n            idx=255;\n            while (!((art_node256*)n)->children[idx]) idx--;\n            return maximum(((art_node256*)n)->children[idx]);\n        default:\n            abort();\n    }\n}", "path": "bloomd/src/bloomd/art.c", "commit_date": "2016-12-15 00:00:00", "repo_name": "armon/bloomd", "stars": 1233, "license": "other", "language": "c", "size": 3015}
{"docstring": "/**\n * Creates a copy of an ART tree. The two trees will\n * share the internal leaves, but will NOT share internal nodes.\n * This allows leaves to be added and deleted from each tree\n * individually. It is important that concurrent updates to\n * a given key has no well defined behavior since the leaves are\n * shared.\n * @arg dst The destination tree. Not initialized yet.\n * @arg src The source tree, must be initialized.\n * @return 0 on success.\n */\n", "func_signal": "int art_copy(art_tree *dst, art_tree *src)", "code": "{\n    dst->size = src->size;\n    dst->root = recursive_copy(src->root);\n    return 0;\n}", "path": "bloomd/src/bloomd/art.c", "commit_date": "2016-12-15 00:00:00", "repo_name": "armon/bloomd", "stars": 1233, "license": "other", "language": "c", "size": 3015}
{"docstring": "// Recursively destroys the tree\n", "func_signal": "static void destroy_node(art_node *n)", "code": "{\n    // Break if null\n    if (!n) return;\n\n    // Special case leafs\n    if (IS_LEAF(n)) {\n        // Only release the leaf if the ref count hits zero\n        art_leaf *l = LEAF_RAW(n);\n        int ref = __sync_sub_and_fetch(&l->ref_count, 1);\n        if (!ref)\n            free(l);\n        return;\n    }\n\n    // Handle each node type\n    int i;\n    union {\n        art_node4 *p1;\n        art_node16 *p2;\n        art_node48 *p3;\n        art_node256 *p4;\n    } p;\n    switch (n->type) {\n        case NODE4:\n            p.p1 = (art_node4*)n;\n            for (i=0;i<n->num_children;i++) {\n                destroy_node(p.p1->children[i]);\n            }\n            break;\n\n        case NODE16:\n            p.p2 = (art_node16*)n;\n            for (i=0;i<n->num_children;i++) {\n                destroy_node(p.p2->children[i]);\n            }\n            break;\n\n        case NODE48:\n            p.p3 = (art_node48*)n;\n            for (i=0;i<n->num_children;i++) {\n                destroy_node(p.p3->children[i]);\n            }\n            break;\n\n        case NODE256:\n            p.p4 = (art_node256*)n;\n            for (i=0;i<256;i++) {\n                if (p.p4->children[i])\n                    destroy_node(p.p4->children[i]);\n            }\n            break;\n\n        default:\n            abort();\n    }\n\n    // Free ourself on the way up\n    free(n);\n}", "path": "bloomd/src/bloomd/art.c", "commit_date": "2016-12-15 00:00:00", "repo_name": "armon/bloomd", "stars": 1233, "license": "other", "language": "c", "size": 3015}
{"docstring": "// Tests the call back, increments the in counter\n", "func_signal": "static int sbf_test_callback(void *in, uint64_t bytes, bloom_bitmap *map)", "code": "{\n    uint64_t *counter = (uint64_t*)in;\n    *counter = *counter + 1;\n    return bitmap_from_file(-1, bytes, ANONYMOUS, map);\n}", "path": "bloomd/tests/libbloom/test_sbf.c", "commit_date": "2013-03-18 00:00:00", "repo_name": "armon/bloomd", "stars": 1233, "license": "other", "language": "c", "size": 3015}
{"docstring": "/**\n * Checks if a leaf prefix matches\n * @return 0 on success.\n */\n", "func_signal": "static int leaf_prefix_matches(art_leaf *n, unsigned char *prefix, int prefix_len)", "code": "{\n    // Fail if the key length is too short\n    if (n->key_len < (uint32_t)prefix_len) return 1;\n\n    // Compare the keys\n    return memcmp(n->key, prefix, prefix_len);\n}", "path": "bloomd/src/bloomd/art.c", "commit_date": "2016-12-15 00:00:00", "repo_name": "armon/bloomd", "stars": 1233, "license": "other", "language": "c", "size": 3015}
{"docstring": "/**\n * Calculates the index at which the prefixes mismatch\n */\n", "func_signal": "static int prefix_mismatch(art_node *n, unsigned char *key, int key_len, int depth)", "code": "{\n    int max_cmp = min(min(MAX_PREFIX_LEN, n->partial_len), key_len - depth);\n    int idx;\n    for (idx=0; idx < max_cmp; idx++) {\n        if (n->partial[idx] != key[depth+idx])\n            return idx;\n    }\n\n    // If the prefix is short we can avoid finding a leaf\n    if (n->partial_len > MAX_PREFIX_LEN) {\n        // Prefix is longer than what we've checked, find a leaf\n        art_leaf *l = minimum(n);\n        max_cmp = min(l->key_len, key_len)- depth;\n        for (; idx < max_cmp; idx++) {\n            if (l->key[idx+depth] != key[depth+idx])\n                return idx;\n        }\n    }\n    return idx;\n}", "path": "bloomd/src/bloomd/art.c", "commit_date": "2016-12-15 00:00:00", "repo_name": "armon/bloomd", "stars": 1233, "license": "other", "language": "c", "size": 3015}
{"docstring": "/**\n * Deletes a value from the ART tree\n * @arg t The tree\n * @arg key The key\n * @arg key_len The length of the key\n * @return NULL if the item was not found, otherwise\n * the value pointer is returned.\n */\n", "func_signal": "void* art_delete(art_tree *t, unsigned char *key, int key_len)", "code": "{\n    art_leaf *l = recursive_delete(t->root, &t->root, key, key_len, 0);\n    if (l) {\n        t->size--;\n        void *old = l->value;\n\n        // Only release the leaf if the ref count hits zero\n        int ref = __sync_sub_and_fetch(&l->ref_count, 1);\n        if (!ref)\n            free(l);\n\n        return old;\n    }\n    return NULL;\n}", "path": "bloomd/src/bloomd/art.c", "commit_date": "2016-12-15 00:00:00", "repo_name": "armon/bloomd", "stars": 1233, "license": "other", "language": "c", "size": 3015}
{"docstring": "// Find the minimum leaf under a node\n", "func_signal": "static art_leaf* minimum(art_node *n)", "code": "{\n    // Handle base cases\n    if (!n) return NULL;\n    if (IS_LEAF(n)) return LEAF_RAW(n);\n\n    int idx;\n    switch (n->type) {\n        case NODE4:\n            return minimum(((art_node4*)n)->children[0]);\n        case NODE16:\n            return minimum(((art_node16*)n)->children[0]);\n        case NODE48:\n            idx=0;\n            while (!((art_node48*)n)->keys[idx]) idx++;\n            idx = ((art_node48*)n)->keys[idx] - 1;\n            return minimum(((art_node48*)n)->children[idx]);\n        case NODE256:\n            idx=0;\n            while (!((art_node256*)n)->children[idx]) idx++;\n            return minimum(((art_node256*)n)->children[idx]);\n        default:\n            abort();\n    }\n}", "path": "bloomd/src/bloomd/art.c", "commit_date": "2016-12-15 00:00:00", "repo_name": "armon/bloomd", "stars": 1233, "license": "other", "language": "c", "size": 3015}
{"docstring": "/**\n * Checks if a leaf matches\n * @return 0 on success.\n */\n", "func_signal": "static int leaf_matches(art_leaf *n, unsigned char *key, int key_len, int depth)", "code": "{\n    (void)depth;\n    // Fail if the key lengths are different\n    if (n->key_len != (uint32_t)key_len) return 1;\n\n    // Compare the keys starting at the depth\n    return memcmp(n->key, key, key_len);\n}", "path": "bloomd/src/bloomd/art.c", "commit_date": "2016-12-15 00:00:00", "repo_name": "armon/bloomd", "stars": 1233, "license": "other", "language": "c", "size": 3015}
{"docstring": "/**\n * Returns the number of prefix characters shared between\n * the key and node.\n */\n", "func_signal": "static int check_prefix(art_node *n, unsigned char *key, int key_len, int depth)", "code": "{\n    int max_cmp = min(min(n->partial_len, MAX_PREFIX_LEN), key_len - depth);\n    int idx;\n    for (idx=0; idx < max_cmp; idx++) {\n        if (n->partial[idx] != key[depth+idx])\n            return idx;\n    }\n    return idx;\n}", "path": "bloomd/src/bloomd/art.c", "commit_date": "2016-12-15 00:00:00", "repo_name": "armon/bloomd", "stars": 1233, "license": "other", "language": "c", "size": 3015}
{"docstring": "// Recursively copies a tree\n", "func_signal": "static art_node* recursive_copy(art_node *n)", "code": "{\n    // Handle the NULL nodes\n    if (!n) return NULL;\n\n    // Handle leaves\n    if (IS_LEAF(n)) {\n        // Re-use leaf, increment ref-count\n        art_leaf *l = LEAF_RAW(n);\n        __sync_fetch_and_add(&l->ref_count, 1);\n        return n;\n    }\n\n    union {\n        art_node4 *p1;\n        art_node16 *p2;\n        art_node48 *p3;\n        art_node256 *p4;\n    } p;\n    switch (n->type) {\n        case NODE4:\n            p.p1 = (art_node4*)alloc_node(NODE4);\n            copy_header((art_node*)p.p1, n);\n            memcpy(p.p1->keys, ((art_node4*)n)->keys, 4);\n            for (int i=0; i < n->num_children; i++) {\n                p.p1->children[i] = recursive_copy(((art_node4*)n)->children[i]);\n            }\n            return (art_node*)p.p1;\n\n        case NODE16:\n            p.p2 = (art_node16*)alloc_node(NODE16);\n            copy_header((art_node*)p.p2, n);\n            memcpy(p.p1->keys, ((art_node16*)n)->keys, 16);\n            for (int i=0; i < n->num_children; i++) {\n                p.p2->children[i] = recursive_copy(((art_node16*)n)->children[i]);\n            }\n            return (art_node*)p.p2;\n\n        case NODE48:\n            p.p3 = (art_node48*)alloc_node(NODE48);\n            copy_header((art_node*)p.p3, n);\n            memcpy(p.p3->keys, ((art_node48*)n)->keys, 256);\n            for (int i=0; i < n->num_children; i++) {\n                p.p3->children[i] = recursive_copy(((art_node48*)n)->children[i]);\n            }\n            return (art_node*)p.p3;\n\n        case NODE256:\n            p.p4 = (art_node256*)alloc_node(NODE256);\n            copy_header((art_node*)p.p4, n);\n            for (int i=0; i < 256; i++) {\n                p.p4->children[i] = recursive_copy(((art_node256*)n)->children[i]);\n            }\n            return (art_node*)p.p4;\n\n        default:\n            abort();\n    }\n}", "path": "bloomd/src/bloomd/art.c", "commit_date": "2016-12-15 00:00:00", "repo_name": "armon/bloomd", "stars": 1233, "license": "other", "language": "c", "size": 3015}
{"docstring": "/* force realloc(p, 0) and realloc (NULL, n) to return a valid pointer */\n", "func_signal": "void *\nrpl_realloc (void *p, size_t n)", "code": "{\n  if (n == 0)\n    n = 1;\n  if (p == 0)\n    return malloc (n);\n  return realloc (p, n);\n}", "path": "bloomd/deps/check-0.9.8/lib/realloc.c", "commit_date": "2012-01-30 00:00:00", "repo_name": "armon/bloomd", "stars": 1233, "license": "other", "language": "c", "size": 3015}
{"docstring": "/**\n * Searches for a value in the ART tree\n * @arg t The tree\n * @arg key The key\n * @arg key_len The length of the key\n * @return NULL if the item was not found, otherwise\n * the value pointer is returned.\n */\n", "func_signal": "void* art_search(art_tree *t, unsigned char *key, int key_len)", "code": "{\n    art_node **child;\n    art_node *n = t->root;\n    int prefix_len, depth = 0;\n    while (n) {\n        // Might be a leaf\n        if (IS_LEAF(n)) {\n            n = LEAF_RAW(n);\n            // Check if the expanded path matches\n            if (!leaf_matches((art_leaf*)n, key, key_len, depth)) {\n                return ((art_leaf*)n)->value;\n            }\n            return NULL;\n        }\n\n        // Bail if the prefix does not match\n        if (n->partial_len) {\n            prefix_len = check_prefix(n, key, key_len, depth);\n            if (prefix_len != min(MAX_PREFIX_LEN, n->partial_len))\n                return NULL;\n            depth = depth + n->partial_len;\n        }\n\n        // Recursively search\n        child = find_child(n, key[depth]);\n        n = (child) ? *child : NULL;\n        depth++;\n    }\n    return NULL;\n}", "path": "bloomd/src/bloomd/art.c", "commit_date": "2016-12-15 00:00:00", "repo_name": "armon/bloomd", "stars": 1233, "license": "other", "language": "c", "size": 3015}
{"docstring": "/**\n * Inserts a new value into the ART tree\n * @arg t The tree\n * @arg key The key\n * @arg key_len The length of the key\n * @arg value Opaque value.\n * @return NULL if the item was newly inserted, otherwise\n * the old value pointer is returned.\n */\n", "func_signal": "void* art_insert(art_tree *t, unsigned char *key, int key_len, void *value)", "code": "{\n    int old_val = 0;\n    void *old = recursive_insert(t->root, &t->root, key, key_len, value, 0, &old_val);\n    if (!old_val) t->size++;\n    return old;\n}", "path": "bloomd/src/bloomd/art.c", "commit_date": "2016-12-15 00:00:00", "repo_name": "armon/bloomd", "stars": 1233, "license": "other", "language": "c", "size": 3015}
{"docstring": "/* _POSIX_VERSION */\n", "func_signal": "enum fork_status srunner_fork_status (SRunner *sr)", "code": "{\n  if (sr->fstat == CK_FORK_GETENV) {\n    char *env = getenv (\"CK_FORK\");\n    if (env == NULL)\n      return CK_FORK;\n    if (strcmp (env,\"no\") == 0)\n      return CK_NOFORK;\n    else {\n#ifdef _POSIX_VERSION\n      return CK_FORK;\n#else /* _POSIX_VERSION */\n      eprintf(\"This version does not support fork\", __FILE__, __LINE__);\n      return CK_NOFORK;\n#endif /* _POSIX_VERSION */\n    }\n  } else\n    return sr->fstat;\n}", "path": "bloomd/deps/check-0.9.8/src/check_run.c", "commit_date": "2012-01-30 00:00:00", "repo_name": "armon/bloomd", "stars": 1233, "license": "other", "language": "c", "size": 3015}
{"docstring": "/**\n * Iterates through the entries pairs in the map,\n * invoking a callback for each that matches a given prefix.\n * The call back gets a key, value for each and returns an integer stop value.\n * If the callback returns non-zero, then the iteration stops.\n * @arg t The tree to iterate over\n * @arg prefix The prefix of keys to read\n * @arg prefix_len The length of the prefix\n * @arg cb The callback function to invoke\n * @arg data Opaque handle passed to the callback\n * @return 0 on success, or the return of the callback.\n */\n", "func_signal": "int art_iter_prefix(art_tree *t, unsigned char *key, int key_len, art_callback cb, void *data)", "code": "{\n    art_node **child;\n    art_node *n = t->root;\n    int prefix_len, depth = 0;\n    while (n) {\n        // Might be a leaf\n        if (IS_LEAF(n)) {\n            n = LEAF_RAW(n);\n            // Check if the expanded path matches\n            if (!leaf_prefix_matches((art_leaf*)n, key, key_len)) {\n                art_leaf *l = (art_leaf*)n;\n                return cb(data, (const unsigned char*)l->key, l->key_len, l->value);\n            }\n            return 0;\n        }\n\n        // If the depth matches the prefix, we need to handle this node\n        if (depth == key_len) {\n            art_leaf *l = minimum(n);\n            if (!leaf_prefix_matches(l, key, key_len))\n               return recursive_iter(n, cb, data);\n            return 0;\n        }\n\n        // Bail if the prefix does not match\n        if (n->partial_len) {\n            prefix_len = prefix_mismatch(n, key, key_len, depth);\n\n            // If there is no match, search is terminated\n            if (!prefix_len)\n                return 0;\n\n            // If we've matched the prefix, iterate on this node\n            else if (depth + prefix_len == key_len) {\n                return recursive_iter(n, cb, data);\n            }\n\n            // if there is a full match, go deeper\n            depth = depth + n->partial_len;\n        }\n\n        // Recursively search\n        child = find_child(n, key[depth]);\n        n = (child) ? *child : NULL;\n        depth++;\n    }\n    return 0;\n}", "path": "bloomd/src/bloomd/art.c", "commit_date": "2016-12-15 00:00:00", "repo_name": "armon/bloomd", "stars": 1233, "license": "other", "language": "c", "size": 3015}
{"docstring": "// Recursively iterates over the tree\n", "func_signal": "static int recursive_iter(art_node *n, art_callback cb, void *data)", "code": "{\n    // Handle base cases\n    if (!n) return 0;\n    if (IS_LEAF(n)) {\n        art_leaf *l = LEAF_RAW(n);\n        return cb(data, (const unsigned char*)l->key, l->key_len, l->value);\n    }\n\n    int idx, res;\n    switch (n->type) {\n        case NODE4:\n            for (int i=0; i < n->num_children; i++) {\n                res = recursive_iter(((art_node4*)n)->children[i], cb, data);\n                if (res) return res;\n            }\n            break;\n\n        case NODE16:\n            for (int i=0; i < n->num_children; i++) {\n                res = recursive_iter(((art_node16*)n)->children[i], cb, data);\n                if (res) return res;\n            }\n            break;\n\n        case NODE48:\n            for (int i=0; i < 256; i++) {\n                idx = ((art_node48*)n)->keys[i];\n                if (!idx) continue;\n\n                res = recursive_iter(((art_node48*)n)->children[idx-1], cb, data);\n                if (res) return res;\n            }\n            break;\n\n        case NODE256:\n            for (int i=0; i < 256; i++) {\n                if (!((art_node256*)n)->children[i]) continue;\n                res = recursive_iter(((art_node256*)n)->children[i], cb, data);\n                if (res) return res;\n            }\n            break;\n\n        default:\n            abort();\n    }\n    return 0;\n}", "path": "bloomd/src/bloomd/art.c", "commit_date": "2016-12-15 00:00:00", "repo_name": "armon/bloomd", "stars": 1233, "license": "other", "language": "c", "size": 3015}
{"docstring": "/**\n * Destroys an ART tree\n * @return 0 on success.\n */\n", "func_signal": "int destroy_art_tree(art_tree *t)", "code": "{\n    destroy_node(t->root);\n    return 0;\n}", "path": "bloomd/src/bloomd/art.c", "commit_date": "2016-12-15 00:00:00", "repo_name": "armon/bloomd", "stars": 1233, "license": "other", "language": "c", "size": 3015}
{"docstring": "/**\n * Allocates a node of the given type,\n * initializes to zero and sets the type.\n */\n", "func_signal": "static art_node* alloc_node(uint8_t type)", "code": "{\n    art_node* n;\n    switch (type) {\n        case NODE4:\n            n = calloc(1, sizeof(art_node4));\n            break;\n        case NODE16:\n            n = calloc(1, sizeof(art_node16));\n            break;\n        case NODE48:\n            n = calloc(1, sizeof(art_node48));\n            break;\n        case NODE256:\n            n = calloc(1, sizeof(art_node256));\n            break;\n        default:\n            abort();\n    }\n    n->type = type;\n    return n;\n}", "path": "bloomd/src/bloomd/art.c", "commit_date": "2016-12-15 00:00:00", "repo_name": "armon/bloomd", "stars": 1233, "license": "other", "language": "c", "size": 3015}
{"docstring": "// device_drv definition - miner.h\n", "func_signal": "static\nvoid zeusminer_drv_init()", "code": "{\n\t// based on Icarus\n\tzeusminer_drv = icarus_drv;\n\t\n\t// metadata\n\tzeusminer_drv.dname = \"zeusminer\";\n\tzeusminer_drv.name = \"ZUS\";\n\tzeusminer_drv.drv_min_nonce_diff = common_scrypt_min_nonce_diff;\n\t\n\t// detect device\n\tzeusminer_drv.lowl_probe = zeusminer_lowl_probe;\n\t\n\t// initialize thread\n\tzeusminer_drv.thread_init = zeusminer_thread_init;\n\t\n\t// Icarus scanhash mining hooks\n\tzeusminer_drv.job_prepare = zeusminer_job_prepare;\n\t\n\t// specify driver probe priority\n\t// currently setup specifically to probe before DualMiner\n\tzeusminer_drv.probe_priority = -100;\n\n\t// output the chip # when viewing per-proc stats\n\t// so we can easily ID chips vs cores\n\tzeusminer_drv.override_statline_temp2 = zeusminer_override_statline_temp2;\n\n\t// output the chip # via RPC API\n\tzeusminer_drv.get_api_extra_device_detail = zeusminer_get_api_extra_device_detail;\n\n\t// TUI support - e.g. setting clock via UI\n#ifdef HAVE_CURSES\n\tzeusminer_drv.proc_wlogprint_status = zeusminer_wlogprint_status;\n\tzeusminer_drv.proc_tui_wlogprint_choices = zeusminer_tui_wlogprint_choices;\n\tzeusminer_drv.proc_tui_handle_choice = zeusminer_tui_handle_choice;\n#endif\n}", "path": "bfgminer/driver-zeusminer.c", "commit_date": "2015-02-26 00:00:00", "repo_name": "luke-jr/bfgminer", "stars": 1770, "license": "other", "language": "c", "size": 36773}
{"docstring": "/* set work for given chip, returns true if a nonce range was finished */\n", "func_signal": "static\nbool set_work(struct cgpu_info * const dev, const uint8_t chip_id, struct work * const work)", "code": "{\n\tstruct aan_board_data * const board = dev->device_data;\n\tstruct spi_port * const spi = board->spi;\n\t\n\tstruct cgpu_info * const proc = aan_proc_for_chipid(dev, chip_id);\n\tstruct thr_info * const thr = proc->thr[0];\n\tstruct aan_chip_data * const chip = thr->cgpu_data;\n\tbool retval = false;\n\t\n\t++chip->last_jobid;\n\tchip->last_jobid &= 3;\n\n\tif (chip->works[chip->last_jobid] != NULL)\n\t{\n\t\tfree_work(chip->works[chip->last_jobid]);\n\t\tchip->works[chip->last_jobid] = NULL;\n\t\tretval = true;\n\t}\n\t\n\tif (!aan_spi_send_work(spi, chip_id, chip->last_jobid + 1, work))\n\t{\n\t\tfree_work(work);\n\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Failed to set work %d\", proc->proc_repr, chip->last_jobid + 1);\n\t}\n\telse\n\t\tchip->works[chip->last_jobid] = work;\n\tspi_clear_buf(spi);\n\t\n\treturn retval;\n}", "path": "bfgminer/driver-aan.c", "commit_date": "2015-10-22 00:00:00", "repo_name": "luke-jr/bfgminer", "stars": 1770, "license": "other", "language": "c", "size": 36773}
{"docstring": "// Algo benchmark, crash-prone, system independent stage\n", "func_signal": "double bench_algo_stage3(\n\tenum sha256_algos algo\n)", "code": "{\n\tstruct work work __attribute__((aligned(128)));\n\n\tget_benchmark_work(&work, false);\n\n\tstatic struct thr_info dummy;\n\n\tstruct timeval end;\n\tstruct timeval start;\n\tuint32_t max_nonce = opt_algo == ALGO_FASTAUTO ? (1<<8) : (1<<22);\n\tuint32_t last_nonce = 0;\n\n\ttimer_set_now(&start);\n\t\t\t{\n\t\t\t\tsha256_func func = sha256_funcs[algo];\n\t\t\t\t(*func)(\n\t\t\t\t\t&dummy,\n\t\t\t\t\t&work,\n\t\t\t\t\tmax_nonce,\n\t\t\t\t\t&last_nonce,\n\t\t\t\t\t0\n\t\t\t\t);\n\t\t\t}\n\ttimer_set_now(&end);\n\n\tuint64_t usec_end = ((uint64_t)end.tv_sec)*1000*1000 + end.tv_usec;\n\tuint64_t usec_start = ((uint64_t)start.tv_sec)*1000*1000 + start.tv_usec;\n\tuint64_t usec_elapsed = usec_end - usec_start;\n\n\tdouble rate = -1.0;\n\tif (0<usec_elapsed) {\n\t\trate = (1.0*(last_nonce+1))/usec_elapsed;\n\t}\n\treturn rate;\n}", "path": "bfgminer/driver-cpu.c", "commit_date": "2020-06-03 00:00:00", "repo_name": "luke-jr/bfgminer", "stars": 1770, "license": "other", "language": "c", "size": 36773}
{"docstring": "/* Parse S into tokens separated by characters in DELIM.\n   If S is NULL, the saved pointer in SAVE_PTR is used as\n   the next starting point.  For example:\n        char s[] = \"-abc-=-def\";\n        char *sp;\n        x = strtok_r(s, \"-\", &sp);      // x = \"abc\", sp = \"=-def\"\n        x = strtok_r(NULL, \"-=\", &sp);  // x = \"def\", sp = NULL\n        x = strtok_r(NULL, \"=\", &sp);   // x = NULL\n                // s = \"abc\\0-def\\0\"\n*/\n", "func_signal": "char *\n__strtok_r (char *s, const char *delim, char **save_ptr)", "code": "{\n  char *token;\n\n  if (s == NULL)\n    s = *save_ptr;\n\n  /* Scan leading delimiters.  */\n  s += strspn (s, delim);\n  if (*s == '\\0')\n    {\n      *save_ptr = s;\n      return NULL;\n    }\n\n  /* Find the end of the token.  */\n  token = s;\n  s = strpbrk (token, delim);\n  if (s == NULL)\n    /* This token finishes the string.  */\n    *save_ptr = __rawmemchr (token, '\\0');\n  else\n    {\n      /* Terminate the token and make *SAVE_PTR point past it.  */\n      *s = '\\0';\n      *save_ptr = s + 1;\n    }\n  return token;\n}", "path": "bfgminer/lib/strtok_r.c", "commit_date": "2012-09-12 00:00:00", "repo_name": "luke-jr/bfgminer", "stars": 1770, "license": "other", "language": "c", "size": 36773}
{"docstring": "// for setting clock and chips during probe / detect\n", "func_signal": "static\nconst char *alchemist_set_clock(struct cgpu_info * const device, const char * const option, const char * const setting, char * const replybuf, enum bfg_set_device_replytype * const success)", "code": "{\n\tstruct alchemist_chip * const chip = device->device_data;\n\tint val = atoi(setting);\n\t\n\tif (val < ALCHEMIST_MIN_CLOCK || val > ALCHEMIST_MAX_CLOCK || (val%16)) {\n\t\tsprintf(replybuf, \"invalid clock: '%s' valid range %d-%d and a mutiple of 16\",\n\t\t        setting, ALCHEMIST_MIN_CLOCK, ALCHEMIST_MAX_CLOCK);\n\t\treturn replybuf;\n\t} else\n\t\tchip->freq = val;\n\t\n\treturn NULL;\n}", "path": "bfgminer/driver-alchemist.c", "commit_date": "2018-01-04 00:00:00", "repo_name": "luke-jr/bfgminer", "stars": 1770, "license": "other", "language": "c", "size": 36773}
{"docstring": "// device detection\n", "func_signal": "static\nbool zeusminer_detect_one(const char *devpath)", "code": "{\n\tstruct device_drv *drv = &zeusminer_drv;\n\t\n\tstruct ICARUS_INFO *info = calloc(1, sizeof(struct ICARUS_INFO));\n\tif (unlikely(!info))\n\t\tquit(1, \"Failed to malloc ICARUS_INFO\");\n\t\n\tchar scrypt_golden_ob[] =\n\t\"55aa\"\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//Freq is set to 0x55*1.5=85Mhz\n\t\"0001\"\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//We want to find a Nonce which result's diff is at least 32768\n\t\"00038000\"\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//Starting Nonce\n\t\"063b0b1b\"\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//Bits (target in compact form)\n\t\"028f3253\"\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//Timestamp\n\t\"5e900609c15dc49a42b1d8492a6dd4f8f15295c989a1decf584a6aa93be26066\"\t//Merkle root\n\t\"d3185f55ef635b5865a7a79b7fa74121a6bb819da416328a9bd2f8cef72794bf\"\t//Previous hash\n\t\"02000000\";\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//Version\n\t\n\tconst char scrypt_golden_nonce[] = \"00038d26\";\n\t\n\t*info = (struct ICARUS_INFO){\n\t\t.baud = ZEUSMINER_IO_SPEED,\n\t\t.timing_mode = MODE_DEFAULT,\n\t\t// if do_icarus_timing is true, the timing adjustment may\n\t\t// result in a read_count that considers the device Idle\n\t\t.do_icarus_timing = false,\n\t\t.probe_read_count = 5,\n\t\t.golden_nonce = scrypt_golden_nonce,\n\t\t.chips = ZEUSMINER_CHIPS_COUNT,\n\t\t.freq = ZEUSMINER_DEFAULT_CLOCK,\n\t};\n\t\n\t//pick up any user-defined settings passed in via --set\n\tdrv_set_defaults(drv, zeusminer_set_device_funcs_probe, info, devpath, detectone_meta_info.serial, 1);\n\t\n\tinfo->work_division = upper_power_of_two_u32(info->chips * ZEUSMINER_CHIP_CORES);\n\tinfo->fpga_count = info->chips * ZEUSMINER_CHIP_CORES;\n\t\n\t//send the requested Chip Speed with the detect golden OB\n\t//we use the time this request takes in order to calc hashes\n\t//so we need to use the same Chip Speed used when hashing\n\tuint32_t clk_header = zeusminer_calc_clk_header(info->freq);\n\tchar clk_header_str[10];\n\tsprintf(clk_header_str, \"%08x\", clk_header + 1);\n\tmemcpy(scrypt_golden_ob, clk_header_str, 8);\n\t\n\tinfo->golden_ob = scrypt_golden_ob;\n\t\n\tif (!icarus_detect_custom(devpath, drv, info) &&\n\t\t//ZM doesn't respond to detection 1 out of ~30 times\n\t\t!icarus_detect_custom(devpath, drv, info))\n\t{\n\t\tfree(info);\n\t\treturn false;\n\t}\n\t\n\tdouble duration_sec;\n\tconst double hash_count = (double)0xd26;\n\tuint64_t default_hashes_per_core = (((info->freq * 2) / 3) * 1024) / ZEUSMINER_CHIP_CORES;\n\t\n\tif (info->ignore_golden_nonce)\n\t\tduration_sec = hash_count / default_hashes_per_core;\n\telse\n\t\tduration_sec = ((double)(info->golden_tv.tv_sec) + ((double)(info->golden_tv.tv_usec)) / ((double)1000000));\n\t\n\t//determines how the hash rate is calculated when no nonce is returned\n\tinfo->Hs = (double)(duration_sec / hash_count / info->chips / ZEUSMINER_CHIP_CORES);\n\t\n\t//set the read_count (how long to wait for a result) based on chips, cores, and time to find a nonce\n\tint chips_count_max = ZEUSMINER_CHIPS_COUNT_MAX;\n\tif (info->chips > chips_count_max)\n\t\tchips_count_max = upper_power_of_two_u32(info->chips);\n\t//golden_speed_per_core is the number of hashes / second / core\n\tuint64_t golden_speed_per_core = (uint64_t)(hash_count / duration_sec);\n\t//don't combine the following two lines - overflows leaving info->read_count at 0\n\tinfo->read_timeout_ms = ((uint64_t)(0x100000000 * 1000)) / (ZEUSMINER_CHIP_CORES * chips_count_max * golden_speed_per_core * 2);\n\tinfo->read_timeout_ms = info->read_timeout_ms * 3 / 4;\n\t\n\treturn true;\n}", "path": "bfgminer/driver-zeusminer.c", "commit_date": "2015-02-26 00:00:00", "repo_name": "luke-jr/bfgminer", "stars": 1770, "license": "other", "language": "c", "size": 36773}
{"docstring": "/*\n * scanhash mining loop\n */\n", "func_signal": "static\nvoid alchemist_submit_nonce(struct thr_info * const thr, const uint8_t buf[9], struct work * const work)", "code": "{\n\tstruct cgpu_info *device = thr->cgpu;\n\tstruct alchemist_chip *chips = device->device_data;\n\t\n\tuint32_t nonce = *(uint32_t *)buf;\n\tnonce = bswap_32(nonce);\n\t\n\tsubmit_nonce(thr, work, nonce);\n\t\n\t// hashrate calc\n\t\n\tconst uint8_t chipid = buf[8];\n\tconst uint8_t clstid = buf[7];\n\tuint32_t range = chips[chipid].clst_offset[clstid];\n\tuint32_t mutiple = ALCHEMIST_MAX_NONCE / chips[chipid].active_cores;\n\t\n\tdouble diff_mutiple = .5/work->work_difficulty;\n\t\n\tfor (unsigned x = 0; x < alchemist_max_cores_per_cluster; ++x) {\n\t\tif (nonce > range && nonce < (range + mutiple)) {\n\t\t\tuint64_t hashes = (nonce - range) * chips[chipid].active_cores * diff_mutiple;\n\t\t\t\n\t\t\tif (hashes > ALCHEMIST_MAX_NONCE)\n\t\t\t\thashes = 1;\n\t\t\t\n\t\t\thashes_done2(thr, hashes, NULL);\n\t\t}\n\t\t\n\t\trange += mutiple;\n\t}\n}", "path": "bfgminer/driver-alchemist.c", "commit_date": "2018-01-04 00:00:00", "repo_name": "luke-jr/bfgminer", "stars": 1770, "license": "other", "language": "c", "size": 36773}
{"docstring": "/**\n * salsa20_8(B):\n * Apply the salsa20/8 core to the provided block.\n */\n", "func_signal": "static inline void\nsalsa20_8(uint32_t B[16], const uint32_t Bx[16])", "code": "{\n\tuint32_t x00,x01,x02,x03,x04,x05,x06,x07,x08,x09,x10,x11,x12,x13,x14,x15;\n\tsize_t i;\n\n\tx00 = (B[ 0] ^= Bx[ 0]);\n\tx01 = (B[ 1] ^= Bx[ 1]);\n\tx02 = (B[ 2] ^= Bx[ 2]);\n\tx03 = (B[ 3] ^= Bx[ 3]);\n\tx04 = (B[ 4] ^= Bx[ 4]);\n\tx05 = (B[ 5] ^= Bx[ 5]);\n\tx06 = (B[ 6] ^= Bx[ 6]);\n\tx07 = (B[ 7] ^= Bx[ 7]);\n\tx08 = (B[ 8] ^= Bx[ 8]);\n\tx09 = (B[ 9] ^= Bx[ 9]);\n\tx10 = (B[10] ^= Bx[10]);\n\tx11 = (B[11] ^= Bx[11]);\n\tx12 = (B[12] ^= Bx[12]);\n\tx13 = (B[13] ^= Bx[13]);\n\tx14 = (B[14] ^= Bx[14]);\n\tx15 = (B[15] ^= Bx[15]);\n\tfor (i = 0; i < 8; i += 2) {\n#define R(a,b) (((a) << (b)) | ((a) >> (32 - (b))))\n\t\t/* Operate on columns. */\n\t\tx04 ^= R(x00+x12, 7);\tx09 ^= R(x05+x01, 7);\tx14 ^= R(x10+x06, 7);\tx03 ^= R(x15+x11, 7);\n\t\tx08 ^= R(x04+x00, 9);\tx13 ^= R(x09+x05, 9);\tx02 ^= R(x14+x10, 9);\tx07 ^= R(x03+x15, 9);\n\t\tx12 ^= R(x08+x04,13);\tx01 ^= R(x13+x09,13);\tx06 ^= R(x02+x14,13);\tx11 ^= R(x07+x03,13);\n\t\tx00 ^= R(x12+x08,18);\tx05 ^= R(x01+x13,18);\tx10 ^= R(x06+x02,18);\tx15 ^= R(x11+x07,18);\n\n\t\t/* Operate on rows. */\n\t\tx01 ^= R(x00+x03, 7);\tx06 ^= R(x05+x04, 7);\tx11 ^= R(x10+x09, 7);\tx12 ^= R(x15+x14, 7);\n\t\tx02 ^= R(x01+x00, 9);\tx07 ^= R(x06+x05, 9);\tx08 ^= R(x11+x10, 9);\tx13 ^= R(x12+x15, 9);\n\t\tx03 ^= R(x02+x01,13);\tx04 ^= R(x07+x06,13);\tx09 ^= R(x08+x11,13);\tx14 ^= R(x13+x12,13);\n\t\tx00 ^= R(x03+x02,18);\tx05 ^= R(x04+x07,18);\tx10 ^= R(x09+x08,18);\tx15 ^= R(x14+x13,18);\n#undef R\n\t}\n\tB[ 0] += x00;\n\tB[ 1] += x01;\n\tB[ 2] += x02;\n\tB[ 3] += x03;\n\tB[ 4] += x04;\n\tB[ 5] += x05;\n\tB[ 6] += x06;\n\tB[ 7] += x07;\n\tB[ 8] += x08;\n\tB[ 9] += x09;\n\tB[10] += x10;\n\tB[11] += x11;\n\tB[12] += x12;\n\tB[13] += x13;\n\tB[14] += x14;\n\tB[15] += x15;\n}", "path": "bfgminer/malgo/scrypt.c", "commit_date": "2014-11-22 00:00:00", "repo_name": "luke-jr/bfgminer", "stars": 1770, "license": "other", "language": "c", "size": 36773}
{"docstring": "/* cpu and memory intensive function to transform a 80 byte buffer into a 32 byte output\n   scratchpad size needs to be at least 63 + (128 * r * p) + (256 * r + 64) + (128 * r * N) bytes\n */\n", "func_signal": "static void scrypt_1024_1_1_256_sp(const uint32_t* input, char* scratchpad, uint32_t *ostate)", "code": "{\n\tuint32_t * V;\n\tuint32_t X[32];\n\tuint32_t i;\n\tuint32_t j;\n\tuint32_t k;\n\tuint64_t *p1, *p2;\n\n\tp1 = (uint64_t *)X;\n\tV = (uint32_t *)(((uintptr_t)(scratchpad) + 63) & ~ (uintptr_t)(63));\n\n\tPBKDF2_SHA256_80_128(input, X);\n\n\tfor (i = 0; i < 1024; i += 2) {\n\t\tmemcpy(&V[i * 32], X, 128);\n\n\t\tsalsa20_8(&X[0], &X[16]);\n\t\tsalsa20_8(&X[16], &X[0]);\n\n\t\tmemcpy(&V[(i + 1) * 32], X, 128);\n\n\t\tsalsa20_8(&X[0], &X[16]);\n\t\tsalsa20_8(&X[16], &X[0]);\n\t}\n\tfor (i = 0; i < 1024; i += 2) {\n\t\tj = X[16] & 1023;\n\t\tp2 = (uint64_t *)(&V[j * 32]);\n\t\tfor(k = 0; k < 16; k++)\n\t\t\tp1[k] ^= p2[k];\n\n\t\tsalsa20_8(&X[0], &X[16]);\n\t\tsalsa20_8(&X[16], &X[0]);\n\n\t\tj = X[16] & 1023;\n\t\tp2 = (uint64_t *)(&V[j * 32]);\n\t\tfor(k = 0; k < 16; k++)\n\t\t\tp1[k] ^= p2[k];\n\n\t\tsalsa20_8(&X[0], &X[16]);\n\t\tsalsa20_8(&X[16], &X[0]);\n\t}\n\n\tPBKDF2_SHA256_80_128_32(input, X, ostate);\n}", "path": "bfgminer/malgo/scrypt.c", "commit_date": "2014-11-22 00:00:00", "repo_name": "luke-jr/bfgminer", "stars": 1770, "license": "other", "language": "c", "size": 36773}
{"docstring": "// device helper functions\n", "func_signal": "static\nuint32_t zeusminer_calc_clk_header(uint16_t freq)", "code": "{\n\t//set clk_reg based on chip_clk\n\tuint32_t clk_reg = (uint32_t)freq * 2 / 3;\n\t\n\t//clock speed mask for header\n\tuint32_t clk_header = (clk_reg << 24) + ((0xff - clk_reg) << 16);\n\t\n\treturn clk_header;\n}", "path": "bfgminer/driver-zeusminer.c", "commit_date": "2015-02-26 00:00:00", "repo_name": "luke-jr/bfgminer", "stars": 1770, "license": "other", "language": "c", "size": 36773}
{"docstring": "// display the Chip # in the UI when viewing per-proc details\n", "func_signal": "static\nbool zeusminer_override_statline_temp2(char *buf, size_t bufsz, struct cgpu_info *device, __maybe_unused bool per_processor)", "code": "{\n\tif (per_processor && ((device->proc_id % ZEUSMINER_CHIP_CORES) == 0))\n\t{\n\t\ttailsprintf(buf, bufsz, \"C:%-3d\", device->proc_id / ZEUSMINER_CHIP_CORES);\n\t\treturn true;\n\t}\n\treturn false;\n}", "path": "bfgminer/driver-zeusminer.c", "commit_date": "2015-02-26 00:00:00", "repo_name": "luke-jr/bfgminer", "stars": 1770, "license": "other", "language": "c", "size": 36773}
{"docstring": "/* suspiciously similar to ScanHash* from bitcoin */\n", "func_signal": "bool scanhash_c(struct thr_info * const thr, struct work * const work,\n\t        uint32_t max_nonce, uint32_t *last_nonce,\n\t\tuint32_t n)", "code": "{\n\tconst uint8_t *midstate = work->midstate;\n\tuint8_t *data = work->data;\n\tuint8_t hash1[0x40];\n\tmemcpy(hash1, hash1_init, sizeof(hash1));\n\tuint8_t * const hash = work->hash;\n\t\n\tuint32_t *hash32 = (uint32_t *) hash;\n\tuint32_t *nonce = (uint32_t *)(data + 76);\n\tunsigned long stat_ctr = 0;\n\n\tdata += 64;\n\n\t// Midstate and data are stored in little endian\n\tLOCAL_swap32le(unsigned char, midstate, 32/4)\n\tLOCAL_swap32le(unsigned char, data, 64/4)\n\tuint32_t *nonce_w = (uint32_t *)(data + 12);\n\n\twhile (1) {\n\t\t*nonce_w = n;\n\n\t\t// runhash expects int32 data preprocessed into native endian\n\t\trunhash(hash1, data, midstate);\n\t\trunhash(hash, hash1, sha256_init_state);\n\n\t\tstat_ctr++;\n\n\t\tif (unlikely(hash32[7] == 0))\n\t\t{\n\t\t\t*nonce = htole32(n);\n\t\t\t*last_nonce = n;\n\t\t\treturn true;\n\t\t}\n\n\t\tif ((n >= max_nonce) || thr->work_restart) {\n\t\t\t*nonce = htole32(n);\n\t\t\t*last_nonce = n;\n\t\t\treturn false;\n\t\t}\n\n\t\tn++;\n\t}\n}", "path": "bfgminer/sha256_generic.c", "commit_date": "2014-11-14 00:00:00", "repo_name": "luke-jr/bfgminer", "stars": 1770, "license": "other", "language": "c", "size": 36773}
{"docstring": "// send work to the device\n", "func_signal": "static\nint64_t alchemist_scanhash(struct thr_info *thr, struct work *work, int64_t __maybe_unused max_nonce)", "code": "{\n\tstruct cgpu_info *device = thr->cgpu;\n\tint fd = device->device_fd;\n\tstruct alchemist_chip *chips = device->device_data;\n\tstruct timeval start_tv, nonce_range_tv;\n\t\n\t// amount of time it takes this device to scan a nonce range:\n\tuint32_t nonce_full_range_sec = ALCHEMIST_HASH_SPEED * 352.0 / ALCHEMIST_DEFAULT_FREQUENCY * 1728.0 / chips[0].active_cores;\n\t// timer to break out of scanning should we close in on an entire nonce range\n\t// should break out before the range is scanned, so we are doing 95% of the range\n\tuint64_t nonce_near_range_usec = (nonce_full_range_sec * 1000000. * 0.95);\n\ttimer_set_delay_from_now(&nonce_range_tv, nonce_near_range_usec);\n\t\n\t// start the job\n\ttimer_set_now(&start_tv);\n\t\n\tif (!alchemist_send_work(thr, work)) {\n\t\tapplog(LOG_DEBUG, \"Failed to start job\");\n\t\tdev_error(device, REASON_DEV_COMMS_ERROR);\n\t}\n\t\n\tuint8_t buf[9];\n\tint read = 0;\n\tbool range_nearly_scanned = false;\n\t\n\twhile (!thr->work_restart                                              // true when new work is available (miner.c)\n\t    && ((read = serial_read(fd, buf, 9)) >= 0)                         // only check for failure - allow 0 bytes\n\t    && !(range_nearly_scanned = timer_passed(&nonce_range_tv, NULL)))  // true when we've nearly scanned a nonce range\n\t{\n\t\tif (read == 0)\n\t\t\tcontinue;\n\t\t\n\t\tif (read == 9) {\n\t\t\talchemist_submit_nonce(thr, buf, work);\n\t\t}\n\t\telse\n\t\t\tapplog(LOG_ERR, \"%\"PRIpreprv\": Unrecognized response\", device->proc_repr);\n\t}\n\t\n\tif (read == -1)\n\t{\n\t\tapplog(LOG_ERR, \"%s: Failed to read result\", device->dev_repr);\n\t\tdev_error(device, REASON_DEV_COMMS_ERROR);\n\t}\n\t\n\treturn 0;\n}", "path": "bfgminer/driver-alchemist.c", "commit_date": "2018-01-04 00:00:00", "repo_name": "luke-jr/bfgminer", "stars": 1770, "license": "other", "language": "c", "size": 36773}
{"docstring": "/*\n * Encode a length len/4 vector of (uint32_t) into a length len vector of\n * (unsigned char) in big-endian form.  Assumes len is a multiple of 4.\n */\n", "func_signal": "static inline void\nbe32enc_vect(uint32_t *dst, const uint32_t *src, uint32_t len)", "code": "{\n\tuint32_t i;\n\n\tfor (i = 0; i < len; i++)\n\t\tdst[i] = htobe32(src[i]);\n}", "path": "bfgminer/malgo/scrypt.c", "commit_date": "2014-11-22 00:00:00", "repo_name": "luke-jr/bfgminer", "stars": 1770, "license": "other", "language": "c", "size": 36773}
{"docstring": "// Change non-blocking status on a file descriptor\n", "func_signal": "static void set_non_blocking(\n\t\tint fd,\n\t\tint yes\n\t)", "code": "{\n\t\tint flags = fcntl(fd, F_GETFL, 0);\n\t\tif (flags<0) {\n\t\t\tperror(\"fcntl(GET) failed\");\n\t\t\texit(1);\n\t\t}\n\t\tflags = yes ? (flags|O_NONBLOCK) : (flags&~O_NONBLOCK);\n\n\t\tint r = fcntl(fd, F_SETFL, flags);\n\t\tif (r<0) {\n\t\t\tperror(\"fcntl(SET) failed\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n#endif // defined(unix)\n\n// Algo benchmark, crash-safe, system-dependent stage\nstatic double bench_algo_stage2(\n\tenum sha256_algos algo\n)\n{\n\t// Here, the gig is to safely run a piece of code that potentially\n\t// crashes. Unfortunately, the Right Way (tm) to do this is rather\n\t// heavily platform dependent :(\n\n\tdouble rate = -1.23457;\n\n\t#if defined(unix)\n\n\t\t// Make a pipe: [readFD, writeFD]\n\t\tint pfd[2];\n\t\tint r = pipe(pfd);\n\t\tif (r<0) {\n\t\t\tperror(\"pipe - failed to create pipe for --algo auto\");\n\t\t\texit(1);\n\t\t}\n\n\t\t// Make pipe non blocking\n\t\tset_non_blocking(pfd[0], 1);\n\t\tset_non_blocking(pfd[1], 1);\n\n\t\t// Don't allow a crashing child to kill the main process\n\t\tsighandler_t sr0 = signal(SIGPIPE, SIG_IGN);\n\t\tsighandler_t sr1 = signal(SIGPIPE, SIG_IGN);\n\t\tif (SIG_ERR==sr0 || SIG_ERR==sr1) {\n\t\t\tperror(\"signal - failed to edit signal mask for --algo auto\");\n\t\t\texit(1);\n\t\t}\n\n\t\t// Fork a child to do the actual benchmarking\n\t\tpid_t child_pid = fork();\n\t\tif (child_pid<0) {\n\t\t\tperror(\"fork - failed to create a child process for --algo auto\");\n\t\t\texit(1);\n\t\t}\n\n\t\t// Do the dangerous work in the child, knowing we might crash\n\t\tif (0==child_pid) {\n\n\t\t\t// TODO: some umask trickery to prevent coredumps\n\n\t\t\t// Benchmark this algorithm\n\t\t\tdouble r = bench_algo_stage3(algo);\n\n\t\t\t// We survived, send result to parent and bail\n\t\t\tint loop_count = 0;\n\t\t\twhile (1) {\n\t\t\t\tssize_t bytes_written = write(pfd[1], &r, sizeof(r));\n\t\t\t\tint try_again = (0==bytes_written || (bytes_written<0 && EAGAIN==errno));\n\t\t\t\tint success = (sizeof(r)==(size_t)bytes_written);\n\n\t\t\t\tif (success)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (!try_again) {\n\t\t\t\t\tperror(\"write - child failed to write benchmark result to pipe\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\n\t\t\t\tif (5<loop_count) {\n\t\t\t\t\tapplog(LOG_ERR, \"child tried %d times to communicate with parent, giving up\", loop_count);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\t++loop_count;\n\t\t\t\tsleep(1);\n\t\t\t}\n\t\t\texit(0);\n\t\t}\n\n\t\t// Parent waits for a result from child\n\t\tint loop_count = 0;\n\t\twhile (1) {\n\n\t\t\t// Wait for child to die\n\t\t\tint status;\n\t\t\tint r = waitpid(child_pid, &status, WNOHANG);\n\t\t\tif ((child_pid==r) || (r<0 && ECHILD==errno)) {\n\n\t\t\t\t// Child died somehow. Grab result and bail\n\t\t\t\tdouble tmp;\n\t\t\t\tssize_t bytes_read = read(pfd[0], &tmp, sizeof(tmp));\n\t\t\t\tif (sizeof(tmp)==(size_t)bytes_read)\n\t\t\t\t\trate = tmp;\n\t\t\t\tbreak;\n\n\t\t\t} else if (r<0) {\n\t\t\t\tperror(\"bench_algo: waitpid failed. giving up.\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// Give up on child after a ~60s\n\t\t\tif (60<loop_count) {\n\t\t\t\tkill(child_pid, SIGKILL);\n\t\t\t\twaitpid(child_pid, &status, 0);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Wait a bit longer\n\t\t\t++loop_count;\n\t\t\tsleep(1);\n\t\t}\n\n\t\t// Close pipe\n\t\tr = close(pfd[0]);\n\t\tif (r<0) {\n\t\t\tperror(\"close - failed to close read end of pipe for --algo auto\");\n\t\t\texit(1);\n\t\t}\n\t\tr = close(pfd[1]);\n\t\tif (r<0) {\n\t\t\tperror(\"close - failed to close read end of pipe for --algo auto\");\n\t\t\texit(1);\n\t\t}\n\n\t#elif defined(WIN32)\n\n\t\t// Get handle to current exe\n\t\tHINSTANCE module = GetModuleHandle(0);\n\t\tif (!module) {\n\t\t\tapplog(LOG_ERR, \"failed to retrieve module handle\");\n\t\t\texit(1);\n\t\t}\n\n\t\t// Create a unique name\n\t\tchar unique_name[33];\n\t\tsnprintf(\n\t\t\tunique_name,\n\t\t\tsizeof(unique_name)-1,\n\t\t\t\"bfgminer-%p\",\n\t\t\t(void*)module\n\t\t);\n\n\t\t// Create and init a chunked of shared memory\n\t\tHANDLE map_handle = CreateFileMapping(\n\t\t\tINVALID_HANDLE_VALUE,   // use paging file\n\t\t\tNULL,                   // default security attributes\n\t\t\tPAGE_READWRITE,         // read/write access\n\t\t\t0,                      // size: high 32-bits\n\t\t\t4096,\t\t\t// size: low 32-bits\n\t\t\tunique_name\t\t// name of map object\n\t\t);\n\t\tif (NULL==map_handle) {\n\t\t\tapplog(LOG_ERR, \"could not create shared memory\");\n\t\t\texit(1);\n\t\t}\n\n\t\tvoid *shared_mem = MapViewOfFile(\n\t\t\tmap_handle,\t// object to map view of\n\t\t\tFILE_MAP_WRITE, // read/write access\n\t\t\t0,              // high offset:  map from\n\t\t\t0,              // low offset:   beginning\n\t\t\t0\t\t// default: map entire file\n\t\t);\n\t\tif (NULL==shared_mem) {\n\t\t\tapplog(LOG_ERR, \"could not map shared memory\");\n\t\t\texit(1);\n\t\t}\n\t\tSetEnvironmentVariable(\"BFGMINER_SHARED_MEM\", unique_name);\n\t\tCopyMemory(shared_mem, &rate, sizeof(rate));\n\n\t\t// Get path to current exe\n\t\tchar cmd_line[256 + MAX_PATH];\n\t\tconst size_t n = sizeof(cmd_line)-200;\n\t\tDWORD size = GetModuleFileName(module, cmd_line, n);\n\t\tif (0==size) {\n\t\t\tapplog(LOG_ERR, \"failed to retrieve module path\");\n\t\t\texit(1);\n\t\t}\n\n\t\t// Construct new command line based on that\n\t\tchar buf[0x20];\n\t\tsnprintf(buf, sizeof(buf), \"%d\", algo);\n\t\tSetEnvironmentVariable(\"BFGMINER_BENCH_ALGO\", buf);\n\n\t\t// Launch a debug copy of BFGMiner\n\t\tSTARTUPINFO startup_info;\n\t\tPROCESS_INFORMATION process_info;\n\t\tZeroMemory(&startup_info, sizeof(startup_info));\n\t\tZeroMemory(&process_info, sizeof(process_info));\n\t\tstartup_info.cb = sizeof(startup_info);\n\n\t\tBOOL ok = CreateProcess(\n\t\t\tNULL,\t\t\t// No module name (use command line)\n\t\t\tcmd_line,\t\t// Command line\n\t\t\tNULL,\t\t\t// Process handle not inheritable\n\t\t\tNULL,\t\t\t// Thread handle not inheritable\n\t\t\tFALSE,\t\t\t// Set handle inheritance to FALSE\n\t\t\tDEBUG_ONLY_THIS_PROCESS,// We're going to debug the child\n\t\t\tNULL,\t\t\t// Use parent's environment block\n\t\t\tNULL,\t\t\t// Use parent's starting directory\n\t\t\t&startup_info,\t\t// Pointer to STARTUPINFO structure\n\t\t\t&process_info\t\t// Pointer to PROCESS_INFORMATION structure\n\t\t);\n\t\tif (!ok) {\n\t\t\tapplog(LOG_ERR, \"CreateProcess failed with error %ld\\n\", (long)GetLastError() );\n\t\t\texit(1);\n\t\t}\n\n\t\t// Debug the child (only clean way to catch exceptions)\n\t\twhile (1) {\n\n\t\t\t// Wait for child to do something\n\t\t\tDEBUG_EVENT debug_event;\n\t\t\tZeroMemory(&debug_event, sizeof(debug_event));\n\n\t\t\tBOOL ok = WaitForDebugEvent(&debug_event, 60 * 1000);\n\t\t\tif (!ok)\n\t\t\t\tbreak;\n\n\t\t\t// Decide if event is \"normal\"\n\t\t\tint go_on =\n\t\t\t\tCREATE_PROCESS_DEBUG_EVENT== debug_event.dwDebugEventCode\t||\n\t\t\t\tCREATE_THREAD_DEBUG_EVENT == debug_event.dwDebugEventCode\t||\n\t\t\t\tEXIT_THREAD_DEBUG_EVENT   == debug_event.dwDebugEventCode\t||\n\t\t\t\tEXCEPTION_DEBUG_EVENT     == debug_event.dwDebugEventCode\t||\n\t\t\t\tLOAD_DLL_DEBUG_EVENT      == debug_event.dwDebugEventCode\t||\n\t\t\t\tOUTPUT_DEBUG_STRING_EVENT == debug_event.dwDebugEventCode\t||\n\t\t\t\tUNLOAD_DLL_DEBUG_EVENT    == debug_event.dwDebugEventCode;\n\t\t\tif (!go_on)\n\t\t\t\tbreak;\n\n\t\t\t// Some exceptions are also \"normal\", apparently.\n\t\t\tif (EXCEPTION_DEBUG_EVENT== debug_event.dwDebugEventCode) {\n\n\t\t\t\tint go_on =\n\t\t\t\t\tEXCEPTION_BREAKPOINT== debug_event.u.Exception.ExceptionRecord.ExceptionCode;\n\t\t\t\tif (!go_on)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// If nothing unexpected happened, let child proceed\n\t\t\tContinueDebugEvent(\n\t\t\t\tdebug_event.dwProcessId,\n\t\t\t\tdebug_event.dwThreadId,\n\t\t\t\tDBG_CONTINUE\n\t\t\t);\n\t\t}\n\n\t\t// Clean up child process\n\t\tTerminateProcess(process_info.hProcess, 1);\n\t\tCloseHandle(process_info.hProcess);\n\t\tCloseHandle(process_info.hThread);\n\n\t\t// Reap return value and cleanup\n\t\tCopyMemory(&rate, shared_mem, sizeof(rate));\n\t\t(void)UnmapViewOfFile(shared_mem);\n\t\t(void)CloseHandle(map_handle);\n\n\t#else\n\n\t\t// Not linux, not unix, not WIN32 ... do our best\n\t\trate = bench_algo_stage3(algo);\n\n\t#endif // defined(unix)\n\n\t// Done\n\treturn rate;\n}", "path": "bfgminer/driver-cpu.c", "commit_date": "2020-06-03 00:00:00", "repo_name": "luke-jr/bfgminer", "stars": 1770, "license": "other", "language": "c", "size": 36773}
{"docstring": "// Pick the fastest CPU hasher\n", "func_signal": "static enum sha256_algos pick_fastest_algo()", "code": "{\n\tdouble best_rate = -1.0;\n\tenum sha256_algos best_algo = 0;\n\tapplog(LOG_ERR, \"benchmarking all sha256 algorithms ...\");\n\n\tbench_algo(&best_rate, &best_algo, ALGO_C);\n\n\t#if defined(WANT_SSE2_4WAY)\n\t\tbench_algo(&best_rate, &best_algo, ALGO_4WAY);\n\t#endif\n\n\t#if defined(WANT_VIA_PADLOCK)\n\t\tbench_algo(&best_rate, &best_algo, ALGO_VIA);\n\t#endif\n\n\tbench_algo(&best_rate, &best_algo, ALGO_CRYPTOPP);\n\n\t#if defined(WANT_CRYPTOPP_ASM32)\n\t\tbench_algo(&best_rate, &best_algo, ALGO_CRYPTOPP_ASM32);\n\t#endif\n\n\t#if defined(WANT_X8632_SSE2)\n\t\tbench_algo(&best_rate, &best_algo, ALGO_SSE2_32);\n\t#endif\n\n\t#if defined(WANT_X8664_SSE2)\n\t\tbench_algo(&best_rate, &best_algo, ALGO_SSE2_64);\n\t#endif\n\n\t#if defined(WANT_X8664_SSE4)\n\t\tbench_algo(&best_rate, &best_algo, ALGO_SSE4_64);\n\t#endif\n\n        #if defined(WANT_ALTIVEC_4WAY)\n                bench_algo(&best_rate, &best_algo, ALGO_ALTIVEC_4WAY);\n        #endif\n\n\tsize_t n = max_name_len - strlen(algo_names[best_algo]);\n\tmemset(name_spaces_pad, ' ', n);\n\tname_spaces_pad[n] = 0;\n\tapplog(\n\t\tLOG_ERR,\n\t\t\"\\\"%s\\\"%s : is fastest algorithm at %.5f MH/s\",\n\t\talgo_names[best_algo],\n\t\tname_spaces_pad,\n\t\tbest_rate\n\t);\n\treturn best_algo;\n}", "path": "bfgminer/driver-cpu.c", "commit_date": "2020-06-03 00:00:00", "repo_name": "luke-jr/bfgminer", "stars": 1770, "license": "other", "language": "c", "size": 36773}
{"docstring": "// return the Chip # in via the API when procdetails is called\n", "func_signal": "static\nstruct api_data *zeusminer_get_api_extra_device_detail(struct cgpu_info *device)", "code": "{\n\tint chip = device->proc_id / ZEUSMINER_CHIP_CORES;\n\treturn api_add_int(NULL, \"Chip\", &chip, true);\n}", "path": "bfgminer/driver-zeusminer.c", "commit_date": "2015-02-26 00:00:00", "repo_name": "luke-jr/bfgminer", "stars": 1770, "license": "other", "language": "c", "size": 36773}
{"docstring": "/* Used by test_nonce functions */\n", "func_signal": "void scrypt_hash_data(void * const out_hash, const void * const pdata)", "code": "{\n\tuint32_t data[20], ohash[8];\n\tchar *scratchbuf;\n\n\tbe32enc_vect(data, pdata, 20);\n\tscratchbuf = alloca(SCRATCHBUF_SIZE);\n\tscrypt_1024_1_1_256_sp(data, scratchbuf, ohash);\n\tswap32tobe(out_hash, ohash, 32/4);\n}", "path": "bfgminer/malgo/scrypt.c", "commit_date": "2014-11-22 00:00:00", "repo_name": "luke-jr/bfgminer", "stars": 1770, "license": "other", "language": "c", "size": 36773}
{"docstring": "/* check for pending results in a chain, returns false if output queue empty */\n", "func_signal": "static\nbool get_nonce(struct cgpu_info * const dev, uint8_t * const nonce, uint8_t * const chip, uint8_t * const job_id)", "code": "{\n\tstruct aan_board_data * const board = dev->device_data;\n\tstruct spi_port * const spi = board->spi;\n\t\n\tint pollLen = MAX_POLL_NUM * dev->procs;\n\tif (pollLen <= 0)\n\t\tpollLen = MAX_POLL_NUM;\n\t\n\tif (!aan_spi_cmd_send(spi, AAN_READ_RESULT, AAN_ALL_CHIPS, NULL, 0))\n\t\treturn false;\n\t\n\tfor (int i = 0; i < pollLen; ++i)\n\t{\n\t\tspi_clear_buf(spi);\n\t\tspi_emit_nop(spi, 2);\n\t\tif (!spi_txrx(spi))\n\t\t\tapplogr(false, LOG_ERR, \"%s: SPI error in get_nonce\", dev->dev_repr);\n\t\tuint8_t * const spi_rx = spi_getrxbuf(spi);\n\t\tif (spi_rx[0] == AAN_READ_RESULT && spi_rx[1] == 0x00)\n\t\t\tapplogr(false, LOG_DEBUG, \"%s: Output queue empty\", dev->dev_repr);\n\t\tif ((spi_rx[0] & 0x0f) == AAN_READ_RESULT && spi_rx[1] != 0)\n\t\t{\n\t\t\t*job_id = spi_rx[0] >> 4;\n\t\t\t*chip = spi_rx[1];\n\t\t\t\n\t\t\tspi_emit_nop(spi, 2);\n\t\t\tif (!spi_txrx(spi))\n\t\t\t\tapplogr(false, LOG_ERR, \"SPI Err(%s):get_nonce\", dev->dev_repr);\n\t\t\tmemcpy(nonce, spi_rx, 4);\n\t\t\t\n\t\t\tapplog(LOG_DEBUG, \"%s: Got nonce for chip %d / job_id %d\", dev->dev_repr, *chip, *job_id);\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\treturn false;\n}", "path": "bfgminer/driver-aan.c", "commit_date": "2015-10-22 00:00:00", "repo_name": "luke-jr/bfgminer", "stars": 1770, "license": "other", "language": "c", "size": 36773}
{"docstring": "/*\n * SHA256 block compression function.  The 256-bit state is transformed via\n * the 512-bit input block to produce a new state.\n */\n", "func_signal": "static void\nSHA256_Transform(uint32_t * state, const uint32_t block[16], int swap)", "code": "{\n\tuint32_t W[64];\n\tuint32_t S[8];\n\tuint32_t t0, t1;\n\tint i;\n\n\t/* 1. Prepare message schedule W. */\n\tif(swap)\n\t\tfor (i = 0; i < 16; i++)\n\t\t\tW[i] = swab32(block[i]);\n\telse\n\t\tmemcpy(W, block, 64);\n\tfor (i = 16; i < 64; i += 2) {\n\t\tW[i] = s1(W[i - 2]) + W[i - 7] + s0(W[i - 15]) + W[i - 16];\n\t\tW[i+1] = s1(W[i - 1]) + W[i - 6] + s0(W[i - 14]) + W[i - 15];\n\t}\n\n\t/* 2. Initialize working variables. */\n\tmemcpy(S, state, 32);\n\n\t/* 3. Mix. */\n\tRNDr(S, W, 0, 0x428a2f98);\n\tRNDr(S, W, 1, 0x71374491);\n\tRNDr(S, W, 2, 0xb5c0fbcf);\n\tRNDr(S, W, 3, 0xe9b5dba5);\n\tRNDr(S, W, 4, 0x3956c25b);\n\tRNDr(S, W, 5, 0x59f111f1);\n\tRNDr(S, W, 6, 0x923f82a4);\n\tRNDr(S, W, 7, 0xab1c5ed5);\n\tRNDr(S, W, 8, 0xd807aa98);\n\tRNDr(S, W, 9, 0x12835b01);\n\tRNDr(S, W, 10, 0x243185be);\n\tRNDr(S, W, 11, 0x550c7dc3);\n\tRNDr(S, W, 12, 0x72be5d74);\n\tRNDr(S, W, 13, 0x80deb1fe);\n\tRNDr(S, W, 14, 0x9bdc06a7);\n\tRNDr(S, W, 15, 0xc19bf174);\n\tRNDr(S, W, 16, 0xe49b69c1);\n\tRNDr(S, W, 17, 0xefbe4786);\n\tRNDr(S, W, 18, 0x0fc19dc6);\n\tRNDr(S, W, 19, 0x240ca1cc);\n\tRNDr(S, W, 20, 0x2de92c6f);\n\tRNDr(S, W, 21, 0x4a7484aa);\n\tRNDr(S, W, 22, 0x5cb0a9dc);\n\tRNDr(S, W, 23, 0x76f988da);\n\tRNDr(S, W, 24, 0x983e5152);\n\tRNDr(S, W, 25, 0xa831c66d);\n\tRNDr(S, W, 26, 0xb00327c8);\n\tRNDr(S, W, 27, 0xbf597fc7);\n\tRNDr(S, W, 28, 0xc6e00bf3);\n\tRNDr(S, W, 29, 0xd5a79147);\n\tRNDr(S, W, 30, 0x06ca6351);\n\tRNDr(S, W, 31, 0x14292967);\n\tRNDr(S, W, 32, 0x27b70a85);\n\tRNDr(S, W, 33, 0x2e1b2138);\n\tRNDr(S, W, 34, 0x4d2c6dfc);\n\tRNDr(S, W, 35, 0x53380d13);\n\tRNDr(S, W, 36, 0x650a7354);\n\tRNDr(S, W, 37, 0x766a0abb);\n\tRNDr(S, W, 38, 0x81c2c92e);\n\tRNDr(S, W, 39, 0x92722c85);\n\tRNDr(S, W, 40, 0xa2bfe8a1);\n\tRNDr(S, W, 41, 0xa81a664b);\n\tRNDr(S, W, 42, 0xc24b8b70);\n\tRNDr(S, W, 43, 0xc76c51a3);\n\tRNDr(S, W, 44, 0xd192e819);\n\tRNDr(S, W, 45, 0xd6990624);\n\tRNDr(S, W, 46, 0xf40e3585);\n\tRNDr(S, W, 47, 0x106aa070);\n\tRNDr(S, W, 48, 0x19a4c116);\n\tRNDr(S, W, 49, 0x1e376c08);\n\tRNDr(S, W, 50, 0x2748774c);\n\tRNDr(S, W, 51, 0x34b0bcb5);\n\tRNDr(S, W, 52, 0x391c0cb3);\n\tRNDr(S, W, 53, 0x4ed8aa4a);\n\tRNDr(S, W, 54, 0x5b9cca4f);\n\tRNDr(S, W, 55, 0x682e6ff3);\n\tRNDr(S, W, 56, 0x748f82ee);\n\tRNDr(S, W, 57, 0x78a5636f);\n\tRNDr(S, W, 58, 0x84c87814);\n\tRNDr(S, W, 59, 0x8cc70208);\n\tRNDr(S, W, 60, 0x90befffa);\n\tRNDr(S, W, 61, 0xa4506ceb);\n\tRNDr(S, W, 62, 0xbef9a3f7);\n\tRNDr(S, W, 63, 0xc67178f2);\n\n\t/* 4. Mix local working variables into global state */\n\tfor (i = 0; i < 8; i++)\n\t\tstate[i] += S[i];\n}", "path": "bfgminer/malgo/scrypt.c", "commit_date": "2014-11-22 00:00:00", "repo_name": "luke-jr/bfgminer", "stars": 1770, "license": "other", "language": "c", "size": 36773}
{"docstring": "/* display an n-pnt float array using simple ascii chars */\n", "func_signal": "static CS_NOINLINE void DrawAscii_(CSOUND *csound, WINDAT *wdptr, char *points)", "code": "{\n    long    npts    = wdptr->npts;\n    MYFLT   absmax  = wdptr->absmax;\n    char    *s;\n    MYFLT   *fp = wdptr->fdata, *fplim = fp + npts;\n    int     n, vscale4, vpos, vmin = VER, vmax = 0, incr;\n    MYFLT   scalefactor;\n\n    scalefactor = YOFF4 / absmax;                   /*   get normalizing */\n    incr = (npts-1)/HOR + 1;                        /*   & sampling facs */\n    for (s = points + (YOFF * HOR), n = 0; fp < fplim; n++, fp += incr) {\n      s[n] = '_';                                   /* now write x-axis  */\n      vscale4 = (int) (*fp * scalefactor + YOFF4);\n      vpos = vscale4 >> 2;  /* and sampled pnts (with 1/4 line resolution) */\n      if ((unsigned int) vpos > (unsigned int) VER)\n        continue;\n      if (vpos < vmin)  vmin = vpos;\n      if (vpos > vmax)  vmax = vpos;\n      points[vpos * HOR + n] = \"_.-'\"[vscale4 & 3]; /* into dsplay array */\n    }\n    for (vpos = vmax; vpos >= vmin; vpos--) {       /* for all lines:    */\n      s = points + (vpos * HOR);\n      for (n = (HOR - 1); n >= 0 && s[n] == ' '; n--)\n        ;                                           /*  find last char & */\n      csoundMessage(csound, \"%.*s\\n\", n + 1, s);    /*  putline to there */\n    }\n}", "path": "csound/InOut/winascii.c", "commit_date": "2018-01-01 00:00:00", "repo_name": "csound/csound", "stars": 1175, "license": "lgpl-2.1", "language": "c", "size": 98904}
{"docstring": "/* called from csoundPreCompile() */\n", "func_signal": "void csound_init_rand(CSOUND *csound)", "code": "{\n    uint32_t  tmp;\n\n    csound->csRandState = &(csound->randState_);\n    csound->randSeed1 = 15937;\n    tmp = (uint32_t) csound->GetRandomSeedFromTime();\n    while (tmp >= (uint32_t) 0x7FFFFFFE)\n      tmp -= (uint32_t) 0x7FFFFFFE;\n    csound->randSeed2 = ((int) tmp + 1);\n    csound->SeedRandMT(&(csound->randState_), NULL, (uint32_t) 5489);\n}", "path": "csound/OOps/random.c", "commit_date": "2018-02-06 00:00:00", "repo_name": "csound/csound", "stars": 1175, "license": "lgpl-2.1", "language": "c", "size": 98904}
{"docstring": "/*********************************************************/\n/*  Algorithm 4 (TX81Z) Subclass of 4 Operator FM Synth  */\n/*  by Perry R. Cook, 1995-96  Recoded John ffitch 97/98 */\n/*                                                       */\n/*  Alg 4 is :      4->3--\\                              */\n/*                     2-- + -->1-->Out                  */\n/*                                                       */\n/*  Controls: control1 = total mod index                 */\n/*            control2 = crossfade of two                */\n/*                          modulators                   */\n/*                                                       */\n/*********************************************************/\n", "func_signal": "MYFLT FM4Alg4_tick(CSOUND *csound, FM4OP *p, MYFLT c1, MYFLT c2)", "code": "{\n    MYFLT       temp;\n    MYFLT       lastOutput;\n\n    temp = Wave_tick(&p->v_time, (int32_t)p->vibWave->flen,\n                     p->vibWave->ftable, p->v_rate, FL(0.0)) *\n      *p->modDepth * FL(0.2);\n    temp = p-> baseFreq * (FL(1.0) + temp)* csound->onedsr;\n    p->w_rate[0] = p->ratios[0] * temp * p->waves[0]->flen;\n    p->w_rate[1] = p->ratios[1] * temp * p->waves[1]->flen;\n    p->w_rate[2] = p->ratios[2] * temp * p->waves[2]->flen;\n    p->w_rate[3] = p->ratios[3] * temp * p->waves[3]->flen;\n\n    p->w_phase[3] = p->waves[3]->flen * p->twozero.lastOutput;\n    temp = p->gains[3] * ADSR_tick(&p->adsr[3]) *\n      Wave_tick(&p->w_time[3], (int32_t)p->waves[3]->flen, p->waves[3]->ftable,\n                p->w_rate[3], p->w_phase[3]);\n    TwoZero_tick(&p->twozero, temp);\n    p->w_phase[2] = p->waves[2]->flen * temp;\n    temp = (FL(1.0) - (c2 * FL(0.5))) * p->gains[2] * ADSR_tick(&p->adsr[2]) *\n      Wave_tick(&p->w_time[2], (int32_t)p->waves[2]->flen, p->waves[2]->ftable,\n                p->w_rate[2], p->w_phase[2]);\n    temp += c2 * FL(0.5) * p->gains[1] * ADSR_tick(&p->adsr[1]) *\n      Wave_tick(&p->w_time[1], (int32_t)p->waves[1]->flen, p->waves[1]->ftable,\n                p->w_rate[1], p->w_phase[1]);\n    temp = temp * c1;\n    p->w_phase[0] = p->waves[0]->flen * temp;\n    temp = p->gains[0] * ADSR_tick(&p->adsr[0]) *\n      Wave_tick(&p->w_time[0], (int32_t)p->waves[0]->flen, p->waves[0]->ftable,\n                p->w_rate[0], p->w_phase[0]);\n\n    lastOutput = temp * FL(0.5);\n    return lastOutput;\n}", "path": "csound/Opcodes/fm4op.c", "commit_date": "2020-03-01 00:00:00", "repo_name": "csound/csound", "stars": 1175, "license": "lgpl-2.1", "language": "c", "size": 98904}
{"docstring": "/*********************************************************/\n/*  Algorithm 5 (TX81Z) Subclass of 4 Operator FM Synth  */\n/*  by Perry R. Cook, 1995-96; recoded John ffitch 97/98 */\n/*  This connection topology is 2 simple FM Pairs summed */\n/*  together, like:                                      */\n/*                                                       */\n/*   Alg 5 is :      4->3--\\                             */\n/*                          + --> Out                    */\n/*                   2->1--/                             */\n/*                                                       */\n/*  Controls: control1 = mod index 1                     */\n/*            control2 = crossfade of two outputs        */\n/*                                                       */\n/*********************************************************/\n", "func_signal": "MYFLT FM4Alg5_tick(FM4OP *p, MYFLT c1, MYFLT c2)", "code": "{\n    MYFLT       temp,temp2;\n    MYFLT       lastOutput;\n\n    temp = p->gains[1] * ADSR_tick(&p->adsr[1]) *\n      Wave_tick(&p->w_time[1], (int32_t)p->waves[1]->flen, p->waves[1]->ftable,\n                p->w_rate[1], p->w_phase[1]);\n    temp = temp * c1;\n    p->w_phase[0] = p->waves[0]->flen * temp; /* addPhaseOffset */\n    p->w_phase[3] = p->waves[0]->flen * p->twozero.lastOutput;\n    temp =  p->gains[3] * ADSR_tick(&p->adsr[3]) *\n      Wave_tick(&p->w_time[3], (int32_t)p->waves[3]->flen, p->waves[3]->ftable,\n                p->w_rate[3], p->w_phase[3]);\n    TwoZero_tick(&p->twozero, temp);\n    p->w_phase[2] = p->waves[2]->flen * temp; /* addPhaseOffset */\n    temp = (FL(1.0) - ( c2 * FL(0.5))) *  p->gains[0] *\n      ADSR_tick(&p->adsr[0]) *\n      Wave_tick(&p->w_time[0], (int32_t)p->waves[0]->flen, p->waves[0]->ftable,\n                p->w_rate[0], p->w_phase[0]);\n    temp +=  c2 * FL(0.5) *  p->gains[2] * ADSR_tick(&p->adsr[2]) *\n      Wave_tick(&p->w_time[2], (int32_t)p->waves[2]->flen, p->waves[2]->ftable,\n                p->w_rate[2], p->w_phase[2]);\n\n    temp2 = Wave_tick(&p->v_time, (int32_t)p->vibWave->flen,\n                      p->vibWave->ftable, p->v_rate, FL(0.0)) *\n      *p->modDepth; /* Calculate amplitude mod */\n    temp = temp * (FL(1.0) + temp2); /*  and apply it to output */\n\n    lastOutput = temp * FL(0.5);\n    return  lastOutput;\n}", "path": "csound/Opcodes/fm4op.c", "commit_date": "2020-03-01 00:00:00", "repo_name": "csound/csound", "stars": 1175, "license": "lgpl-2.1", "language": "c", "size": 98904}
{"docstring": "/* if anyone wants it, there is enough information to select a\n   frequency range to output.*/\n", "func_signal": "PPROPS *new_pprops(void)", "code": "{\n    PPROPS *prop;\n    prop = (PPROPS *) malloc(sizeof(PPROPS));\n    if (prop) {\n      prop->numpoints = 0;\n      prop->maxamp    = 0.0f;\n      prop->maxfreq   = 0.0f;\n      prop->minfreq   = 0.0f;\n      prop->head      = NULL;   /* will point to head of partial[n]     */\n    }\n    return prop;\n}", "path": "csound/util/SDIF/sdif2adsyn.c", "commit_date": "2018-03-30 00:00:00", "repo_name": "csound/csound", "stars": 1175, "license": "lgpl-2.1", "language": "c", "size": 98904}
{"docstring": "/*****************************************************************/\n/*  Fender Rhodes Electric Piano Subclass of Algorithm 5 (TX81Z) */\n/*  Subclass of 4 Operator FM Synth by Perry R. Cook, 1995-96    */\n/*  Recoded in C by John ffitch 1997-98                          */\n/*****************************************************************/\n", "func_signal": "int32_t rhodeset(CSOUND *csound, FM4OP *p)", "code": "{\n    MYFLT       amp = *p->amp * AMP_RSCALE; /* Normalised */\n\n    if (UNLIKELY(make_FM4Op(csound,p))) return NOTOK;\n    if (UNLIKELY(FM4Op_loadWaves(csound,p))) return NOTOK; /* 3 times \"sinewave.raw\";\n                                                    1 x fwavblnk.raw */\n\n    FM4Op_setRatio(p, 0, FL(1.0));\n    FM4Op_setRatio(p, 1, FL(0.5));\n    FM4Op_setRatio(p, 2, FL(1.0));\n    FM4Op_setRatio(p, 3, FL(15.0));\n    p->gains[0] = amp * FM4Op_gains[99];\n    p->gains[1] = amp * FM4Op_gains[90];\n    p->gains[2] = amp * FM4Op_gains[99];\n    p->gains[3] = amp * FM4Op_gains[67];\n    ADSR_setAllTimes(csound, &p->adsr[0], FL(0.001), FL(1.50), FL(0.0), FL(0.04));\n    ADSR_setAllTimes(csound, &p->adsr[1], FL(0.001), FL(1.50), FL(0.0), FL(0.04));\n    ADSR_setAllTimes(csound, &p->adsr[2], FL(0.001), FL(1.00), FL(0.0), FL(0.04));\n    ADSR_setAllTimes(csound, &p->adsr[3], FL(0.001), FL(0.25), FL(0.0), FL(0.04));\n    /*      ADSR_setAll(&p->adsr[0], 0.05f,0.00003f,FL(0.0),0.02f); */\n    /*      ADSR_setAll(&p->adsr[1], 0.05f,0.00003f,FL(0.0),0.02f); */\n    /*      ADSR_setAll(&p->adsr[2], 0.05f,0.00005f,FL(0.0),0.02f); */\n    /*      ADSR_setAll(&p->adsr[3], 0.05f,0.0002f,FL(0.0),0.02f); */\n    p->twozero.gain = FL(1.0);\n    p->v_rate = FL(2.0) * p->vibWave->flen * csound->onedsr; /* Vib rate */\n    /* Set Freq */\n    p->baseFreq = *p->frequency;\n    p->w_rate[0] = p->baseFreq * p->ratios[0] * p->waves[0]->flen * csound->onedsr;\n    p->w_rate[1] = p->baseFreq * p->ratios[1] * p->waves[1]->flen * csound->onedsr;\n    p->w_rate[2] = p->baseFreq * p->ratios[2] * p->waves[2]->flen * csound->onedsr;\n    p->w_rate[3] = p->baseFreq * p->ratios[3] * p->waves[3]->flen * csound->onedsr;\n    ADSR_keyOn(&p->adsr[0]);\n    ADSR_keyOn(&p->adsr[1]);\n    ADSR_keyOn(&p->adsr[2]);\n    ADSR_keyOn(&p->adsr[3]);\n    return OK;\n}", "path": "csound/Opcodes/fm4op.c", "commit_date": "2020-03-01 00:00:00", "repo_name": "csound/csound", "stars": 1175, "license": "lgpl-2.1", "language": "c", "size": 98904}
{"docstring": "/* least significant r bits */\n", "func_signal": "static CS_NOINLINE void MT_update_state(uint32_t *mt)", "code": "{\n    /* mag01[x] = x * MATRIX_A  for x=0,1 */\n    const uint32_t  mag01[2] = { (uint32_t) 0, (uint32_t) MATRIX_A };\n    int32_t       i;\n    uint32_t  y;\n\n    for (i = 0; i < (N - M); i++) {\n      y = (mt[i] & UPPER_MASK) | (mt[i + 1] & LOWER_MASK);\n      mt[i] = mt[i + M] ^ (y >> 1) ^ mag01[y & (uint32_t) 1];\n    }\n    for ( ; i < (N - 1); i++) {\n      y = (mt[i] & UPPER_MASK) | (mt[i + 1] & LOWER_MASK);\n      mt[i] = mt[i + (M - N)] ^ (y >> 1) ^ mag01[y & (uint32_t) 1];\n    }\n    y = (mt[N - 1] & UPPER_MASK) | (mt[0] & LOWER_MASK);\n    mt[N - 1] = mt[M - 1] ^ (y >> 1) ^ mag01[y & (uint32_t) 1];\n}", "path": "csound/OOps/random.c", "commit_date": "2018-02-06 00:00:00", "repo_name": "csound/csound", "stars": 1175, "license": "lgpl-2.1", "language": "c", "size": 98904}
{"docstring": "/* *********************** needs total rewrite **************** */\n", "func_signal": "int32_t loscil(CSOUND *csound, LOSC *p)", "code": "{\n    IGN(csound);\n    FUNC    *ftp;\n    MYFLT   *ar1, *ar2, *ftbl, *xamp;\n    MYFLT    phs;\n    MYFLT    inc, beg, end;\n    uint32_t n = p->h.insdshead->ksmps_offset;\n    uint32_t early  = p->h.insdshead->ksmps_no_end;\n    uint32_t nsmps = CS_KSMPS;\n    int32_t      aamp;\n    MYFLT    xx;\n\n    ftp = p->ftp;\n    ftbl = ftp->ftable;\n    if ((inc = (*p->kcps * p->cpscvt)) < 0)\n      inc = -inc;\n    //printf(\"inc: %lf * %lf = %lf\\n\", *p->kcps, p->cpscvt, inc);\n    xamp = p->xamp;\n    xx = *xamp;\n    aamp = IS_ASIG_ARG(p->xamp) ? 1 : 0;\n    if (p->seg1) {                      /* if still segment 1  */\n      beg = p->beg1;\n      end = p->end1;\n      if (UNLIKELY(p->h.insdshead->relesing))     /*    sense note_off   */\n        p->looping = 0;\n    }\n    else {\n      beg = p->beg2;\n      end = p->end2;\n    }\n    phs = p->lphs;\n    ar1 = p->ar1;\n    if (UNLIKELY(n)) memset(ar1, '\\0', n*sizeof(MYFLT));\n    if (UNLIKELY(early)) {\n      nsmps -= early;\n      memset(&ar1[nsmps], '\\0', early*sizeof(MYFLT));\n    }\n    if (p->stereo) {\n      ar2 = p->ar2;\n      if (UNLIKELY(n)) memset(ar2, '\\0', n*sizeof(MYFLT));\n      if (UNLIKELY(early)) memset(&ar2[nsmps], '\\0', early*sizeof(MYFLT));\n      goto phsck2;\n    }\n phschk:\n    if (phs >= end && p->curmod != 3) {\n      //printf(\"****phs = %f end = %f\\n\", phs,end);\n      goto put0;\n    }\n    switch (p->curmod) {\n    case 0:\n      for (; n<nsmps; n++) {                    /* NO LOOPING  */\n        loscil_linear_interp_mono(&ar1[n], ftbl, phs, ftp->flen);\n        if (aamp) xx = xamp[n];\n        ar1[n] *= xx;\n        if ((phs += inc) >= end) {\n          //printf(\"****phs, end = %f, %f\\n\", phs, end);\n          goto nxtseg;\n        }\n      }\n      break;\n    case 1:\n      for (; n<nsmps; n++) {                    /* NORMAL LOOPING */\n        loscil_linear_interp_mono(&ar1[n], ftbl, phs, ftp->flen);\n        if (aamp) xx = xamp[n];\n        ar1[n] *= xx;\n        if (UNLIKELY((phs += inc) >= end)) {\n          if (!(p->looping)) goto nxtseg;\n          phs -= end - beg;\n        }\n      }\n      break;\n    case 2:\n    case2:\n      for (; n<nsmps; n++) {                    /* BIDIR FORW, EVEN */\n        loscil_linear_interp_mono(&ar1[n], ftbl, phs, ftp->flen);\n        if (aamp) xx = xamp[n];\n        ar1[n] *= xx;\n        if ((phs += inc) >= end) {\n          if (!(p->looping)) goto nxtseg;\n          phs -= (phs - end) * 2;\n          p->curmod = 3;\n          if (++n<nsmps) goto case3;\n          else break;\n        }\n      }\n      break;\n    case 3:\n    case3:\n      for (; n<nsmps; n++) {                    /* BIDIR BACK, EVEN */\n        loscil_linear_interp_mono(&ar1[n], ftbl, phs, ftp->flen);\n        if (aamp) xx = xamp[n];\n        ar1[n] *= xx;\n        if (UNLIKELY((phs -= inc) < beg)) {\n          phs += (beg - phs) * 2;\n          p->curmod = 2;\n          if (++n<nsmps) goto case2;\n          else break;\n        }\n      }\n      break;\n\n    nxtseg:\n      if (p->seg1) {\n        p->seg1 = 0;\n        if ((p->curmod = p->mod2) != 0)\n          p->looping = 1;\n        if (++n>nsmps) {\n          beg = p->beg2;\n          end = p->end2;\n          p->lphs = phs;\n          goto phschk;\n        }\n        break;\n      }\n      if (LIKELY(++n<nsmps)) goto phsout;\n      break;\n    }\n    p->lphs = phs;\n    return OK;\n\n phsout:\n    p->lphs = phs;\nput0:\n    //printf(\"****put0\\n\");\n    memset(&ar1[n], '\\0', sizeof(MYFLT)*(nsmps-n));\n    return OK;\n\n phsck2:\n    /*VL increment for stereo */\n    if (phs >= end && p->curmod != 3)\n      goto put0s;                               /* for STEREO:  */\n    switch (p->curmod) {\n    case 0:\n      for (; n<nsmps; n++) {                    /* NO LOOPING  */\n        loscil_linear_interp_stereo(&ar1[n], &ar2[n], ftbl, phs, ftp->flen);\n        if (aamp) xx = xamp[n];\n        ar1[n] *= xx;\n        ar2[n] *= xx;\n        if (UNLIKELY((phs += inc) >= end))\n          goto nxtseg2;\n      }\n      break;\n    case 1:\n      for (; n<nsmps; n++) {                    /* NORMAL LOOPING */\n        loscil_linear_interp_stereo(&ar1[n], &ar2[n], ftbl, phs, ftp->flen);\n        if (aamp) xx = xamp[n];\n        ar1[n] *= xx;\n        ar2[n] *= xx;\n        if (UNLIKELY((phs += inc) >= end)) {\n          if (!(p->looping)) goto nxtseg2;\n          phs -= end - beg;\n        }\n      }\n      break;\n    case 2:\n    case2s:\n      for (; n<nsmps; n++) {                    /* BIDIR FORW, EVEN */\n        loscil_linear_interp_stereo(&ar1[n], &ar2[n], ftbl, phs, ftp->flen);\n        if (aamp) xx = xamp[n];\n        ar1[n] *= xx;\n        ar2[n] *= xx;\n        if (UNLIKELY((phs += inc) >= end)) {\n          if (!(p->looping)) goto nxtseg2;\n          phs -= (phs - end) * 2;\n          p->curmod = 3;\n          if (++n<nsmps) goto case3s;\n          else break;\n        }\n      }\n      break;\n    case 3:\n    case3s:\n      for (; n<nsmps; n++) {                    /* BIDIR BACK, EVEN */\n       loscil_linear_interp_stereo(&ar1[n], &ar2[n], ftbl, phs, ftp->flen);\n        if (aamp) xx = xamp[n];\n        ar1[n] *= xx;\n        ar2[n] *= xx;\n        if (UNLIKELY((phs -= inc) < beg)) {\n          phs += (beg - phs) * 2;\n          p->curmod = 2;\n          if (++n<nsmps) goto case2s;\n          else break;\n        }\n      }\n      break;\n\n    nxtseg2:\n      if (p->seg1) {\n        p->seg1 = 0;\n        if ((p->curmod = p->mod2) != 0)\n          p->looping = 1;\n        if (++n<nsmps) {\n          beg = p->beg2;\n          end = p->end2;\n          p->lphs = phs;\n          goto phsck2;\n        }\n        break;\n      }\n      if (LIKELY(++n<nsmps)) goto phsout2;\n      break;\n    }\n    p->lphs = phs;\n    return OK;\n\n phsout2:\n    p->lphs = phs;\n put0s:\n    memset(&ar1[n], '\\0', sizeof(MYFLT)*(nsmps-n));\n    memset(&ar2[n], '\\0', sizeof(MYFLT)*(nsmps-n));\n    return OK;\n}", "path": "csound/OOps/ugens3.c", "commit_date": "2019-12-04 00:00:00", "repo_name": "csound/csound", "stars": 1175, "license": "lgpl-2.1", "language": "c", "size": 98904}
{"docstring": "/***************************************************************/\n/*  Tubular Bell (Orch. Chime) Subclass of Algorithm 5 (TX81Z) */\n/*  Subclass of 4 Operator FM Synth by Perry R. Cook, 1995-96  */\n/*  Recoded in C by John ffitch 1997-98                        */\n/***************************************************************/\n", "func_signal": "int32_t tubebellset(CSOUND *csound, FM4OP *p)", "code": "{\n    MYFLT       amp = *p->amp * AMP_RSCALE; /* Normalised */\n    MYFLT       opt = *p->opt;\n\n    if (UNLIKELY(make_FM4Op(csound,p))) return NOTOK;\n    if (UNLIKELY(FM4Op_loadWaves(csound,p)))\n      return NOTOK; /* 4 x \"rawwaves/sinewave.raw\" */\n\n    FM4Op_setRatio(p, 0, FL(1.0)   * FL(0.995));\n    FM4Op_setRatio(p, 1, FL(1.414) * FL(0.995));\n    FM4Op_setRatio(p, 2, FL(1.0)   * FL(1.005));\n    FM4Op_setRatio(p, 3, FL(1.414)            );\n    p->gains[0] = amp * FM4Op_gains[94];\n    p->gains[1] = amp * FM4Op_gains[76];\n    p->gains[2] = amp * FM4Op_gains[99];\n    p->gains[3] = amp * FM4Op_gains[71];\n    if (opt<= FL(0.0)) opt = FL(4.0);\n    ADSR_setAllTimes(csound, &p->adsr[0], FL(0.005), opt, FL(0.0), FL(0.04));\n    ADSR_setAllTimes(csound, &p->adsr[1], FL(0.005), opt, FL(0.0), FL(0.04));\n    ADSR_setAllTimes(csound, &p->adsr[2], FL(0.001),FL(0.5)*opt,FL(0.0), FL(0.04));\n    ADSR_setAllTimes(csound, &p->adsr[3], FL(0.004), opt, FL(0.0), FL(0.04));\n    /*      ADSR_setAll(csound, &p->adsr[0], 0.03f,0.00001f,FL(0.0),0.02f); */\n    /*      ADSR_setAll(csound, &p->adsr[1], 0.03f,0.00001f,FL(0.0),0.02f); */\n    /*      ADSR_setAll(csound, &p->adsr[2], 0.07f,0.00002f,FL(0.0),0.02f); */\n    /*      ADSR_setAll(csound, &p->adsr[3], FL(0.04),0.00001f,FL(0.0),0.02f); */\n    p->twozero.gain = FL(0.5);\n    p->v_rate = FL(2.0) * p->vibWave->flen * csound->onedsr; /* Vib rate */\n    /* Set Freq */\n    p->baseFreq = *p->frequency;\n    p->w_rate[0] = p->baseFreq * p->ratios[0] * p->waves[0]->flen * csound->onedsr;\n    p->w_rate[1] = p->baseFreq * p->ratios[1] * p->waves[1]->flen * csound->onedsr;\n    p->w_rate[2] = p->baseFreq * p->ratios[2] * p->waves[2]->flen * csound->onedsr;\n    p->w_rate[3] = p->baseFreq * p->ratios[3] * p->waves[3]->flen * csound->onedsr;\n    ADSR_keyOn(&p->adsr[0]);\n    ADSR_keyOn(&p->adsr[1]);\n    ADSR_keyOn(&p->adsr[2]);\n    ADSR_keyOn(&p->adsr[3]);\n    return OK;\n}", "path": "csound/Opcodes/fm4op.c", "commit_date": "2020-03-01 00:00:00", "repo_name": "csound/csound", "stars": 1175, "license": "lgpl-2.1", "language": "c", "size": 98904}
{"docstring": "/* Used by moog1.c as well */\n", "func_signal": "void make_TwoZero(TwoZero *p)", "code": "{\n    p->zeroCoeffs[0] = FL(0.0);\n    p->zeroCoeffs[1] = FL(0.0);\n    p->gain = FL(1.0);\n    p->inputs[0] = FL(0.0);\n    p->inputs[1] = FL(0.0);\n    p->lastOutput = FL(0.0);\n}", "path": "csound/Opcodes/fm4op.c", "commit_date": "2020-03-01 00:00:00", "repo_name": "csound/csound", "stars": 1175, "license": "lgpl-2.1", "language": "c", "size": 98904}
{"docstring": "/*\nPUBLIC int32_t csoundModuleCreate(CSOUND *csound)\n{\n    (void) csound;\n    return 0;\n}\n*/\n", "func_signal": "int32_t pvsopc_ModuleInit(CSOUND *csound)", "code": "{\n    int32_t     err = 0;\n\n    err |= ifd_init_(csound);\n    err |= partials_init_(csound);\n    err |= psynth_init_(csound);\n    err |= pvsbasic_init_(csound);\n    err |= pvscent_init_(csound);\n    err |= pvsdemix_init_(csound);\n    err |= pvsband_init_(csound);\n\n    return (err ? CSOUND_ERROR : CSOUND_SUCCESS);\n}", "path": "csound/Opcodes/pvs_ops.c", "commit_date": "2018-03-15 00:00:00", "repo_name": "csound/csound", "stars": 1175, "license": "lgpl-2.1", "language": "c", "size": 98904}
{"docstring": "/* generates a random number on [0,0xffffffff]-interval */\n", "func_signal": "PUBLIC uint32_t csoundRandMT(CsoundRandMTState *p)", "code": "{\n    int32_t       i = p->mti;\n    uint32_t  y;\n\n    if (i >= N) {                   /* generate N words at one time */\n      MT_update_state(&(p->mt[0]));\n      i = 0;\n    }\n    y = p->mt[i];\n    p->mti = i + 1;\n    /* Tempering */\n    y ^= (y >> 11);\n    y ^= (y << 7) & (uint32_t) 0x9D2C5680U;\n    y ^= (y << 15) & (uint32_t) 0xEFC60000U;\n    y ^= (y >> 18);\n\n    return y;\n}", "path": "csound/OOps/random.c", "commit_date": "2018-02-06 00:00:00", "repo_name": "csound/csound", "stars": 1175, "license": "lgpl-2.1", "language": "c", "size": 98904}
{"docstring": "/* simple linear congruential generator */\n", "func_signal": "PUBLIC int32_t csoundRand31(int32_t *seedVal)", "code": "{\n    uint64_t  tmp1;\n    uint32_t  tmp2;\n\n    /* x = (742938285 * x) % 0x7FFFFFFF */\n    tmp1 = (uint64_t) ((int32_t) (*seedVal) * (int64_t) 742938285);\n    tmp2 = (uint32_t) tmp1 & (uint32_t) 0x7FFFFFFF;\n    tmp2 += (uint32_t) (tmp1 >> 31);\n    tmp2 = (tmp2 & (uint32_t) 0x7FFFFFFF) + (tmp2 >> 31);\n    (*seedVal) = (int32_t) tmp2;\n    return (int32_t) tmp2;\n}", "path": "csound/OOps/random.c", "commit_date": "2018-02-06 00:00:00", "repo_name": "csound/csound", "stars": 1175, "license": "lgpl-2.1", "language": "c", "size": 98904}
{"docstring": "/**********************************************************/\n/*  Algorithm 8 (TX81Z) Subclass of 4 Operator FM Synth   */\n/*  by Perry R. Cook, 1995-96; recoded John ffitch 97-98  */\n/*  This connection topology is simple Additive Synthesis */\n/*                                                        */\n/*                   1 --.                                */\n/*                   2 -\\|                                */\n/*                       +-> Out                          */\n/*                   3 -/|                                */\n/*                   4 --                                 */\n/*                                                        */\n/*  Controls: control1 = op4 (fb) gain                    */\n/*            control2 = op3 gain                         */\n/*                                                        */\n/**********************************************************/\n", "func_signal": "MYFLT FM4Alg8_tick(FM4OP *p, MYFLT c1, MYFLT c2)", "code": "{\n    MYFLT       temp;\n    MYFLT       lastOutput;\n\n    p->w_phase[3] = p->waves[3]->flen * p->twozero.lastOutput;\n\n    temp = c1 * FL(2.0) * p->gains[3] * ADSR_tick(&p->adsr[3]) *\n      Wave_tick(&p->w_time[3], (int32_t)p->waves[3]->flen, p->waves[3]->ftable,\n                p->w_rate[3], p->w_phase[3]);\n    TwoZero_tick(&p->twozero, temp);\n    temp += c2 * FL(2.0) * p->gains[2] * ADSR_tick(&p->adsr[2]) *\n      Wave_tick(&p->w_time[2], (int32_t)p->waves[2]->flen, p->waves[2]->ftable,\n                p->w_rate[2], p->w_phase[2]);\n    temp += p->gains[1] * ADSR_tick(&p->adsr[1]) *\n      Wave_tick(&p->w_time[1], (int32_t)p->waves[1]->flen, p->waves[1]->ftable,\n                p->w_rate[1], p->w_phase[1]);\n    temp += p->gains[0] * ADSR_tick(&p->adsr[0]) *\n      Wave_tick(&p->w_time[0], (int32_t)p->waves[0]->flen, p->waves[0]->ftable,\n                p->w_rate[0], p->w_phase[0]);\n\n    lastOutput = temp * FL(0.125);\n    return lastOutput;\n}", "path": "csound/Opcodes/fm4op.c", "commit_date": "2020-03-01 00:00:00", "repo_name": "csound/csound", "stars": 1175, "license": "lgpl-2.1", "language": "c", "size": 98904}
{"docstring": "/***************************************************************/\n/*  Wurlitzer Electric Piano Subclass of Algorithm 5 (TX81Z)   */\n/*  Subclass of 4 Operator FM Synth by Perry R. Cook, 1995-96  */\n/*  Recoded in C by John ffitch 1997-98                        */\n/***************************************************************/\n", "func_signal": "int32_t wurleyset(CSOUND *csound, FM4OP *p)", "code": "{\n    MYFLT       amp = *p->amp * AMP_RSCALE; /* Normalised */\n\n    if (UNLIKELY(make_FM4Op(csound,p))) return NOTOK;\n    if (UNLIKELY(FM4Op_loadWaves(csound,p))) return NOTOK; /* 3 x \"sinewave.raw\";\n                                                    1 x fwavblnk.raw */\n\n    FM4Op_setRatio(p, 0, FL(1.0));\n    FM4Op_setRatio(p, 1, FL(4.05));\n    FM4Op_setRatio(p, 2, -FL(510.0));\n    FM4Op_setRatio(p, 3, -FL(510.0));\n    p->gains[0] = amp * FM4Op_gains[99];\n    p->gains[1] = amp * FM4Op_gains[82];\n    p->gains[2] = amp * FM4Op_gains[82];\n    p->gains[3] = amp * FM4Op_gains[68];\n    ADSR_setAllTimes(csound, &p->adsr[0], FL(0.001), FL(1.50), FL(0.0), FL(0.04));\n    ADSR_setAllTimes(csound, &p->adsr[1], FL(0.001), FL(1.50), FL(0.0), FL(0.04));\n    ADSR_setAllTimes(csound, &p->adsr[2], FL(0.001), FL(0.25), FL(0.0), FL(0.04));\n    ADSR_setAllTimes(csound, &p->adsr[3], FL(0.001), FL(0.15), FL(0.0), FL(0.04));\n    /*      ADSR_setAll(&p->adsr[0], 0.05f,0.00003f,FL(0.0),0.02f); */\n    /*      ADSR_setAll(&p->adsr[1], 0.05f,0.00003f,FL(0.0),0.02f); */\n    /*      ADSR_setAll(&p->adsr[2], 0.05f,0.0002f,FL(0.0),0.02f); */\n    /*      ADSR_setAll(&p->adsr[3], 0.05f,0.0003f,FL(0.0),0.02f); */\n    p->twozero.gain = FL(2.0);\n    /* Set Freq */\n    p->baseFreq = *p->frequency;\n    p->w_rate[0] = p->baseFreq * p->ratios[0] * p->waves[0]->flen * csound->onedsr;\n    p->w_rate[1] = p->baseFreq * p->ratios[1] * p->waves[1]->flen * csound->onedsr;\n    p->w_rate[2] =               p->ratios[2] * p->waves[2]->flen * csound->onedsr;\n    p->w_rate[3] =               p->ratios[3] * p->waves[3]->flen * csound->onedsr;\n    ADSR_keyOn(&p->adsr[0]);\n    ADSR_keyOn(&p->adsr[1]);\n    ADSR_keyOn(&p->adsr[2]);\n    ADSR_keyOn(&p->adsr[3]);\n    return OK;\n}", "path": "csound/Opcodes/fm4op.c", "commit_date": "2020-03-01 00:00:00", "repo_name": "csound/csound", "stars": 1175, "license": "lgpl-2.1", "language": "c", "size": 98904}
{"docstring": "/************************************************************/\n/*  Algorithm 6 (TX81Z) Subclass of 4 Operator FM Synth     */\n/*  by Perry R. Cook, 1995-96; recoded John ffitch 97-98    */\n/*  This connection topology is three Carriers and a common */\n/*  Modulator     /->1 -\\                                   */\n/*             4-|-->2 - +-> Out                            */\n/*                \\->3 -/                                   */\n/*                                                          */\n/*  Controls: control1 = vowel                              */\n/*            control2 = spectral tilt                      */\n/*                                                          */\n/************************************************************/\n", "func_signal": "MYFLT FM4Alg6_tick(CSOUND *csound, FM4OPV *q)", "code": "{\n    MYFLT       temp,temp2;\n    FM4OP       *p = (FM4OP*)q;\n\n    temp = p->gains[3] * ADSR_tick(&p->adsr[3]) *\n      Wave_tick(&p->w_time[3], (int32_t)p->waves[3]->flen, p->waves[3]->ftable,\n                p->w_rate[3], p->w_phase[3]);\n    /*  Calculate frequency mod  */\n    temp2 = Wave_tick(&p->v_time, (int32_t)p->vibWave->flen, p->vibWave->ftable,\n                      p->v_rate, FL(0.0)) * *p->modDepth * FL(0.1);\n\n    temp2 = (FL(1.0) + temp2) * p->baseFreq * csound->onedsr;\n    p->w_rate[0] = temp2 * p->ratios[0] * p->waves[0]->flen;\n    p->w_rate[1] = temp2 * p->ratios[1] * p->waves[1]->flen;\n    p->w_rate[2] = temp2 * p->ratios[2] * p->waves[2]->flen;\n    p->w_rate[3] = temp2 * p->ratios[3] * p->waves[3]->flen;\n\n    p->w_phase[0] = p->waves[0]->flen * temp * q->mods[0];\n    p->w_phase[1] = p->waves[1]->flen * temp * q->mods[1];\n    p->w_phase[2] = p->waves[2]->flen * temp * q->mods[2];\n    p->w_phase[3] = p->waves[3]->flen * p->twozero.lastOutput;\n\n    TwoZero_tick(&p->twozero, temp);\n\n    temp =  p->gains[0] * q->tilt[0] * ADSR_tick(&p->adsr[0]) *\n      Wave_tick(&p->w_time[0], (int32_t)p->waves[0]->flen, p->waves[0]->ftable,\n                p->w_rate[0], p->w_phase[0]);\n    temp += p->gains[1] * q->tilt[1] * ADSR_tick(&p->adsr[1]) *\n      Wave_tick(&p->w_time[1], (int32_t)p->waves[1]->flen, p->waves[1]->ftable,\n                p->w_rate[1], p->w_phase[1]);\n    temp += p->gains[2] * q->tilt[2] * ADSR_tick(&p->adsr[2]) *\n      Wave_tick(&p->w_time[2], (int32_t)p->waves[2]->flen, p->waves[2]->ftable,\n                p->w_rate[2], p->w_phase[2]);\n\n    return temp * FL(0.33);\n}", "path": "csound/Opcodes/fm4op.c", "commit_date": "2020-03-01 00:00:00", "repo_name": "csound/csound", "stars": 1175, "license": "lgpl-2.1", "language": "c", "size": 98904}
{"docstring": "/* pass props->head */\n/* NB does not check for over-range times */\n/* it also trusts that there is a freq element matching each amp element */\n", "func_signal": "int32_t write_partial(FILE *fp,const P_POINT *partial,float sfac,int32_t do_scale)", "code": "{\n    int32_t length = 0;\n    const P_POINT *head;\n    float scalefac = 32767.0f;\n    short amp,freq,time;\n    short amptag = -1, freqtag = -2;\n    short trackend = 32767;\n\n    if (fp==NULL)\n      return -1;\n    if (partial==NULL)\n      return -1;\n\n    if (do_scale)\n      scalefac *= sfac;\n\n    head = partial;\n    if ((fwrite((char *)&amptag,sizeof(short),1,fp)) < 1)\n      return -1;\n\n    /* nothing clever, just go through each list twice */\n\n    /*write amps, scaled to 32767 (oh for a f/p adsyn format...) */\n    while (head) {\n      time = (short)(1000.0f * head->pos);\n      if ((fwrite((char *) &time,sizeof(short),1,fp)) < 1)\n        return -1;\n      amp = (short) (scalefac * head->amp);\n      if ((fwrite((char *)&amp,sizeof(short),1,fp)) < 1)\n        return -1;\n      length++;\n      head = head->next;\n    }\n    if ((fwrite(&trackend,sizeof(short),1,fp)) < 1)\n      return -1;\n\n    head = partial;\n    if ((fwrite(&freqtag,sizeof(short),1,fp)) < 1)\n      return -1;\n    while(head) {\n      time = (short)(1000.0f * head->pos);\n      if ((fwrite((char *) &time,sizeof(short),1,fp)) < 1)\n        return -1;\n      freq = (short)(head->freq);\n      if ((fwrite(&freq,sizeof(short),1,fp)) < 1)\n        return -1;\n      head = head->next;\n    }\n    if ((fwrite(&trackend,sizeof(short),1,fp)) < 1)\n      return -1;\n    return length;\n}", "path": "csound/util/SDIF/sdif2adsyn.c", "commit_date": "2018-03-30 00:00:00", "repo_name": "csound/csound", "stars": 1175, "license": "lgpl-2.1", "language": "c", "size": 98904}
{"docstring": "/* initialise by an array with array-length */\n/* init_key is the array for initialising keys */\n/* key_length is its length */\n/* slight change for C++, 2004/2/26 */\n", "func_signal": "PUBLIC void csoundSeedRandMT(CsoundRandMTState *p,\n                             const uint32_t *initKey, uint32_t keyLength)", "code": "{\n    int32_t       i, j, k;\n    uint32_t  x;\n\n    /* if array is NULL, use length parameter as simple 32 bit seed */\n    x = (initKey == NULL ? keyLength : (uint32_t) 19650218);\n    p->mt[0] = x;\n    for (i = 1; i < N; i++) {\n      /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */\n      /* In the previous versions, MSBs of the seed affect   */\n      /* only MSBs of the array mt[].                        */\n      /* 2002/01/09 modified by Makoto Matsumoto             */\n      x = ((uint32_t) 1812433253 * (x ^ (x >> 30)) + (uint32_t) i);\n      p->mt[i] = x;\n    }\n    p->mti = N;\n    if (initKey == NULL)\n      return;\n    i = 0; j = 0;\n    k = (N > (int32_t) keyLength ? N : (int32_t) keyLength);\n    for ( ; k; k--) {\n      x = p->mt[i++];\n      p->mt[i] = (p->mt[i] ^ ((x ^ (x >> 30)) * (uint32_t) 1664525))\n                 + initKey[j] + (uint32_t) j;   /* non linear */\n      if (i == (N - 1)) {\n        p->mt[0] = p->mt[N - 1];\n        i = 0;\n      }\n      if (++j >= (int32_t) keyLength)\n        j = 0;\n    }\n    for (k = (N - 1); k; k--) {\n      x = p->mt[i++];\n      p->mt[i] = (p->mt[i] ^ ((x ^ (x >> 30)) * (uint32_t) 1566083941))\n                 - (uint32_t) i;                /* non linear */\n      if (i == (N - 1)) {\n        p->mt[0] = p->mt[N - 1];\n        i = 0;\n      }\n    }\n    /* MSB is 1; assuring non-zero initial array */\n    p->mt[0] = (uint32_t) 0x80000000U;\n}", "path": "csound/OOps/random.c", "commit_date": "2018-02-06 00:00:00", "repo_name": "csound/csound", "stars": 1175, "license": "lgpl-2.1", "language": "c", "size": 98904}
{"docstring": "/*********************************************************/\n/*  Algorithm 3 (TX81Z) Subclass of 4 Operator FM Synth  */\n/*  by Perry R. Cook, 1995-96; recoded John ffitch 97/98 */\n/*                                                       */\n/*  Alg 3 is :          4--\\                             */\n/*                  3-->2-- + -->1-->Out                 */\n/*                                                       */\n/*  Controls: control1 = total mod index                 */\n/*            control2 = crossfade of two modulators     */\n/*                                                       */\n/*********************************************************/\n", "func_signal": "MYFLT FM4Alg3_tick(FM4OP *p, MYFLT c1, MYFLT c2)", "code": "{\n    MYFLT       temp;\n    MYFLT       lastOutput;\n\n    temp = *p->modDepth * FL(0.2) *\n      Wave_tick(&p->v_time, (int32_t)p->vibWave->flen,\n                p->vibWave->ftable, p->v_rate, FL(0.0));\n    p->w_rate[0] = p->baseFreq * (FL(1.0) + temp) * p->ratios[0];\n    p->w_rate[1] = p->baseFreq * (FL(1.0) + temp) * p->ratios[1];\n    p->w_rate[2] = p->baseFreq * (FL(1.0) + temp) * p->ratios[2];\n    p->w_rate[3] = p->baseFreq * (FL(1.0) + temp) * p->ratios[3];\n\n    temp = p->gains[2] * ADSR_tick(&p->adsr[2]) *\n      Wave_tick(&p->w_time[2], (int32_t)p->waves[2]->flen, p->waves[2]->ftable,\n                p->w_rate[2], p->w_phase[2]);\n    p->w_phase[1] = p->waves[1]->flen * temp;\n    p->w_phase[3] = p->waves[3]->flen * p->twozero.lastOutput;\n    temp = (FL(1.0) - (c2 * FL(0.5))) * p->gains[3] * ADSR_tick(&p->adsr[3]) *\n      Wave_tick(&p->w_time[3], (int32_t)p->waves[3]->flen, p->waves[3]->ftable,\n                p->w_rate[3], p->w_phase[3]);\n    TwoZero_tick(&p->twozero, temp);\n\n    temp += c2 * FL(0.5) * p->gains[1] * ADSR_tick(&p->adsr[1]) *\n      Wave_tick(&p->w_time[1], (int32_t)p->waves[1]->flen, p->waves[1]->ftable,\n                p->w_rate[1], p->w_phase[1]);\n    temp = temp * c1;\n\n    p->w_phase[0] = p->waves[0]->flen * temp;\n    temp = p->gains[0] * ADSR_tick(&p->adsr[0]) *\n      Wave_tick(&p->w_time[0], (int32_t)p->waves[0]->flen, p->waves[0]->ftable,\n                p->w_rate[0], p->w_phase[0]);\n\n    lastOutput = temp * FL(0.5);\n    return lastOutput;\n}", "path": "csound/Opcodes/fm4op.c", "commit_date": "2020-03-01 00:00:00", "repo_name": "csound/csound", "stars": 1175, "license": "lgpl-2.1", "language": "c", "size": 98904}
{"docstring": "/**************************************************************/\n/*  Hammond(OID) Organ Subclass of Algorithm 8 (TX81Z)        */\n/*  Subclass of 4 Operator FM Synth by Perry R. Cook, 1995-96 */\n/*  Recoded in C by John ffitch 1997-98                       */\n/**************************************************************/\n", "func_signal": "int32_t b3set(CSOUND *csound, FM4OP *p)", "code": "{\n    MYFLT       amp = *p->amp * AMP_RSCALE; /* Normalised */\n    MYFLT       temp = p->baseFreq * csound->onedsr;\n\n    if (UNLIKELY(make_FM4Op(csound,p))) return NOTOK;\n    if (UNLIKELY(FM4Op_loadWaves(csound,p))) return NOTOK;         /* sines */\n    FM4Op_setRatio(p, 0, FL(0.999));\n    FM4Op_setRatio(p, 1, FL(1.997));\n    FM4Op_setRatio(p, 2, FL(3.006));\n    FM4Op_setRatio(p, 3, FL(6.009));\n\n    p->gains[0] = amp * FM4Op_gains[95];\n    p->gains[1] = amp * FM4Op_gains[95];\n    p->gains[2] = amp * FM4Op_gains[99];\n    p->gains[3] = amp * FM4Op_gains[95];\n    ADSR_setAllTimes(csound, &p->adsr[0], FL(0.005), FL(0.003), FL(1.0), FL(0.01));\n    ADSR_setAllTimes(csound, &p->adsr[1], FL(0.005), FL(0.003), FL(1.0), FL(0.01));\n    ADSR_setAllTimes(csound, &p->adsr[2], FL(0.005), FL(0.003), FL(1.0), FL(0.01));\n    ADSR_setAllTimes(csound, &p->adsr[3], FL(0.005), FL(0.001), FL(0.4), FL(0.03));\n    p->twozero.gain = FL(0.1);\n    ADSR_keyOn(&p->adsr[0]);\n    ADSR_keyOn(&p->adsr[1]);\n    ADSR_keyOn(&p->adsr[2]);\n    ADSR_keyOn(&p->adsr[3]);\n    p->w_rate[0] = p->ratios[0] * temp * p->waves[0]->flen;\n    p->w_rate[1] = p->ratios[1] * temp * p->waves[1]->flen;\n    p->w_rate[2] = p->ratios[2] * temp * p->waves[2]->flen;\n    p->w_rate[3] = p->ratios[3] * temp * p->waves[3]->flen;\n    return OK;\n}", "path": "csound/Opcodes/fm4op.c", "commit_date": "2020-03-01 00:00:00", "repo_name": "csound/csound", "stars": 1175, "license": "lgpl-2.1", "language": "c", "size": 98904}
{"docstring": "/* Computes the homography that, when applied to the points in l_pts,\n * minimizes the least-squares error between the result and the\n * corresponding points in r_pts.\n * \n * n -- number of points\n * r_pts -- matches\n * l_pts -- initial points \n * Tout -- on return, contains the 3x3 transformation matrix */\n", "func_signal": "void align_homography(int num_pts, v3_t *r_pts, v3_t *l_pts, \n\t\t      double *Tout, int refine)", "code": "{\n    int m = num_pts * 2;\n    int n = 8;\n    int nrhs = 1;\n    int i, base;\n\n    double *A = malloc(sizeof(double) * m * n);    /* Left-hand matrix */\n    double *B = malloc(sizeof(double) * m * nrhs); /* Right-hand matrix */\n\n    double Ttmp[9];\n    double T1[9], T2[9];\n\n#define _CONDITION_\n#ifdef _CONDITION_\n    /* Normalize the points */\n    v3_t *r_pts_norm = condition_points(num_pts, r_pts, T1);\n    v3_t *l_pts_norm = condition_points(num_pts, l_pts, T2);\n    double T1inv[9];\n#else\n    v3_t *r_pts_norm = r_pts;\n    v3_t *l_pts_norm = l_pts;\n#endif\n\n    for (i = 0; i < num_pts; i++) {\n\tbase = 2 * i * n;\n\tA[base + 0] = Vx(l_pts_norm[i]);\n\tA[base + 1] = Vy(l_pts_norm[i]);\n\tA[base + 2] = 1.0;\n\tA[base + 3] = A[base + 4] = A[base + 5] = 0.0;\n\tA[base + 6] = -Vx(l_pts_norm[i]) * Vx(r_pts_norm[i]);\n\tA[base + 7] = -Vy(l_pts_norm[i]) * Vx(r_pts_norm[i]);\n\n\tbase = (2 * i + 1) * n;\n\tA[base + 0] = A[base + 1] = A[base + 2] = 0.0;\n\tA[base + 3] = Vx(l_pts_norm[i]);\n\tA[base + 4] = Vy(l_pts_norm[i]);\n\tA[base + 5] = 1.0;\n\tA[base + 6] = -Vx(l_pts_norm[i]) * Vy(r_pts_norm[i]);\n\tA[base + 7] = -Vy(l_pts_norm[i]) * Vy(r_pts_norm[i]);\n    \n\tB[2 * i + 0] = Vx(r_pts_norm[i]);\n\tB[2 * i + 1] = Vy(r_pts_norm[i]);\n    }\n\n    /* Make the call to dgelsy */\n    dgelsy_driver(A, B, Tout, m, n, nrhs);\n\n    Tout[8] = 1.0;\n\n#ifdef _CONDITION_\n    /* Undo normalization */\n    matrix_invert(3, T1, T1inv);\n\n    matrix_product(3, 3, 3, 3, T1inv, Tout, Ttmp);\n    matrix_product(3, 3, 3, 3, Ttmp, T2, Tout);\n\n    matrix_scale(3, 3, Tout, 1.0 / Tout[8], Tout);\n#endif\n\n    if (refine) {\n\tmemcpy(Ttmp, Tout, sizeof(double) * 9);\n\talign_homography_non_linear(num_pts, r_pts, l_pts, Ttmp, Tout);\n    }\n    \n    free(A);\n    free(B);\n\n#ifdef _CONDITION_\n    free(r_pts_norm);\n    free(l_pts_norm);\n#endif\n}", "path": "bundler_sfm/lib/imagelib/homography.c", "commit_date": "2013-03-10 00:00:00", "repo_name": "snavely/bundler_sfm", "stars": 1507, "license": "None", "language": "c", "size": 6187}
{"docstring": "/* Use RANSAC to estimate a homography */\n", "func_signal": "void align_homography_ransac_matches(int num_pts, v3_t *a_pts, v3_t *b_pts, \n\t\t\t\t     int num_trials, double threshold, \n                                     double success_ratio,\n                                     int essential, double *H)", "code": "{\n#define MIN_SAMPLES 4\n    int i, j, k, idx;\n\n    v3_t l_pts_best[MIN_SAMPLES], r_pts_best[MIN_SAMPLES];\n\n    double Hbest[MIN_SAMPLES];\n    double *resid;\n    double error_min;\n    int inliers_max;\n\n    double *a_matrix, *b_matrix;\n\n    // double threshold = 1.0e-10;\n\n    // srand(time(0));\n\n    /* Make an array of all good correspondences */\n    if (num_pts < MIN_SAMPLES) {\n\tprintf(\"[align_homography_ransac] \"\n               \"Could not find 8 good correspondences, \"\n\t       \"homography estimation failed\\n\");\n\treturn;\n    }\n\n    a_matrix = malloc(sizeof(double) * 3 * num_pts);\n    b_matrix = malloc(sizeof(double) * 3 * num_pts);\n\n    for (i = 0; i < num_pts; i++) {\n        a_matrix[i] = Vx(a_pts[i]);\n        a_matrix[i+num_pts] = Vy(a_pts[i]);\n        a_matrix[i+2*num_pts] = Vz(a_pts[i]);\n\n        b_matrix[i] = Vx(b_pts[i]);\n        b_matrix[i+num_pts] = Vy(b_pts[i]);\n        b_matrix[i+2*num_pts] = Vz(b_pts[i]);        \n    }\n\n    error_min = DBL_MAX;\n    inliers_max = 0;\n    resid = (double *) malloc(sizeof(double) * num_pts);\n\n    /* Estimate the homography using RANSAC */\n    for (i = 0; i < num_trials; i++) {\n\tint idxs[MIN_SAMPLES];\n\tv3_t l_pts[MIN_SAMPLES], r_pts[MIN_SAMPLES];\n\tdouble Htmp[9];\n\t// double error;\n\tint num_inliers = 0;\n\tint success, nan = 0;\n        int round = 0;\n\n\t/* Sample 4 random correspondences */\n\tfor (j = 0; j < MIN_SAMPLES; j++) {\n\t    int reselect = 0;\n\n            if (round == 1000)\n                return;\n\n\t    idx = rand() % num_pts;\n\t    \n\t    /* Make sure we didn't sample this index yet */\n\t    for (k = 0; k < j; k++) {\n\t\tif (idx == idxs[k] ||\n                    (Vx(a_pts[idx]) == Vx(a_pts[idxs[k]]) &&\n                     Vy(a_pts[idx]) == Vy(a_pts[idxs[k]]) &&\n                     Vz(a_pts[idx]) == Vz(a_pts[idxs[k]])) ||\n                    (Vx(b_pts[idx]) == Vx(b_pts[idxs[k]]) &&\n                     Vy(b_pts[idx]) == Vy(b_pts[idxs[k]]) &&\n                     Vz(b_pts[idx]) == Vz(b_pts[idxs[k]]))) {\n\t\t    reselect = 1;\n\t\t    break;\n\t\t}\n\t    }\n\n\t    if (reselect) {\n                round++;\n\t\tj--;\n\t\tcontinue;\n\t    }\n\n\t    idxs[j] = idx;\n\t}\n\n\t/* Fill in the left and right points */\n\tfor (j = 0; j < 8; j++) {\n\t    l_pts[j] = b_pts[idxs[j]];\n\t    r_pts[j] = a_pts[idxs[j]];\n\t}\n\n\t/* Estimate the F-matrix */\n\tsuccess = estimate_fmatrix_linear(8, r_pts, l_pts, essential, \n                                          Ftmp, e1_tmp, e2_tmp);\n\n        if (success == 0)\n            nan = 1;\n\n\tfor (j = 0; j < 9; j++) {\n\t    if (Ftmp[j] != Ftmp[j] /* isnan(Ftmp[j]) */) {\n\t\tprintf(\"[estimate_fmatrix_ransac_matches] nan encountered\\n\");\n                nan = 1;\n\t\tbreak;\n\t    }\n\t}\n\n        /* Check for nan entries */\n        if (isnan(Ftmp[0]) || isnan(Ftmp[1]) || isnan(Ftmp[2]) ||\n            isnan(Ftmp[3]) || isnan(Ftmp[4]) || isnan(Ftmp[5]) ||\n            isnan(Ftmp[6]) || isnan(Ftmp[7]) || isnan(Ftmp[8])) {\n            printf(\"[estimate_fmatrix_ransac_matches] \"\n                   \"nan matrix encountered\\n\");\n            nan = 1;\n        }\n\n\tif (nan) {\n\t    // error = DBL_MAX;\n\t    num_inliers = 0;\n\t} else {\n            // printf(\"%0.3f\\n\", Ftmp[0]);\n\n\t    /* Compute residuals */\n#if 1\n\t    for (j = 0; j < num_pts; j++) {\n\t\tresid[j] = fmatrix_compute_residual(Ftmp, a_pts[j], b_pts[j]);\n\t\tif (resid[j] < threshold)\n\t\t    num_inliers++;\n\t    }\n#else\n            fmatrix_compute_residuals(num_pts, Ftmp, a_matrix, b_matrix,\n                                      resid);\n\n            for (j = 0; j < num_pts; j++) {\n\t\tif (resid[j] < threshold)\n\t\t    num_inliers++;                \n            }\n#endif\n\n#if 0\n\t    /* Find the median */\n\t    error = median(num_pts, resid);\n\n\t    if (error < error_min) {\n\t\terror_min = error;\n\t\tmemcpy(Fbest, Ftmp, sizeof(double) * 9);\n\t\tmemcpy(l_pts_best, l_pts, sizeof(v3_t) * 8);\n\t\tmemcpy(r_pts_best, r_pts, sizeof(v3_t) * 8);\n\t    }\n#else\n\t    if (num_inliers > inliers_max) {\n\t\tinliers_max = num_inliers;\n\t\tmemcpy(Fbest, Ftmp, sizeof(double) * 9);\n\t\tmemcpy(l_pts_best, l_pts, sizeof(v3_t) * 8);\n\t\tmemcpy(r_pts_best, r_pts, sizeof(v3_t) * 8);\n\t    }\n#endif\n\t}\n\t\n#if 0\n\tif (error < threshold)\n\t    break;\n#endif\n\n        if ((double) num_inliers / num_pts > success_ratio)\n            break;\n    }\n\n    // printf(\"Minimum error: %0.5e\\n\", error_min);\n    // printf(\"Maximum inliers: %d\\n\", inliers_max);\n\n    // matrix_print(3, 3, Fbest);\n\n    free(resid);\n\n    /* Copy out the F-matrix */\n    memcpy(F, Fbest, sizeof(double) * 9);\n\n    free(a_matrix);\n    free(b_matrix);\n}", "path": "bundler_sfm/lib/imagelib/homography.c", "commit_date": "2013-03-10 00:00:00", "repo_name": "snavely/bundler_sfm", "stars": 1507, "license": "None", "language": "c", "size": 6187}
{"docstring": "/* Project a point onto an image */\n", "func_signal": "v2_t project(double *R, double *t0, double *P)", "code": "{\n    double tmp[3], tmp2[3];\n    v2_t result;\n\n    /* Rigid transform */\n    matrix_product331(R, P, tmp);\n    matrix_sum(3, 1, 3, 1, tmp, t0, tmp2);\n    \n    /* Perspective division */\n    Vx(result) = tmp2[0] / tmp2[2];\n    Vy(result) = tmp2[1] / tmp2[2];\n\n    return result;\n}", "path": "bundler_sfm/lib/imagelib/triangulate.c", "commit_date": "2015-11-12 00:00:00", "repo_name": "snavely/bundler_sfm", "stars": 1507, "license": "None", "language": "c", "size": 6187}
{"docstring": "/* Find the point with the smallest squared projection error */\n", "func_signal": "v3_t triangulate(v2_t p, v2_t q, \n\t\t double *R0, double *t0, \n\t\t double *R1, double *t1, double *error)", "code": "{\n    double A[12];\n    double b[4];\n    double x[3];\n\n\tdouble dx1, dx2, dy1, dy2;\n\n    A[0] = R0[0] - Vx(p) * R0[6];  \n    A[1] = R0[1] - Vx(p) * R0[7];  \n    A[2] = R0[2] - Vx(p) * R0[8];\n    \n    A[3] = R0[3] - Vy(p) * R0[6];  \n    A[4] = R0[4] - Vy(p) * R0[7];  \n    A[5] = R0[5] - Vy(p) * R0[8];\n\n    A[6] = R1[0] - Vx(q) * R1[6];  \n    A[7] = R1[1] - Vx(q) * R1[7];  \n    A[8] = R1[2] - Vx(q) * R1[8];\n\n    A[9] = R1[3] - Vy(q) * R1[6];  \n    A[10] = R1[4] - Vy(q) * R1[7];  \n    A[11] = R1[5] - Vy(q) * R1[8];\n\n    b[0] = t0[2] * Vx(p) - t0[0];\n    b[1] = t0[2] * Vy(p) - t0[1];\n    b[2] = t1[2] * Vx(q) - t1[0];\n    b[3] = t1[2] * Vy(q) - t1[1];\n\n    /* Find the least squares result */\n    dgelsy_driver(A, b, x, 4, 3, 1);\n\n    /* Run a non-linear optimization to refine the result */\n    global_p = p;\n    global_q = q;\n    global_R0 = R0;  global_t0 = t0;\n    global_R1 = R1;  global_t1 = t1;\n    lmdif_driver(triangulation_residual, 4, 3, x, 1.0e-10);\n\n    if (error != NULL) {\n\tdouble pp[3], qp[3];\n\n\t/* Compute projection error */\n\tmatrix_product331(R0, x, pp);\n\tpp[0] += t0[0];\n\tpp[1] += t0[1];\n\tpp[2] += t0[2];\n\t\t\n\tmatrix_product331(R1, x, qp);\n\tqp[0] += t1[0];\n\tqp[1] += t1[1];\n\tqp[2] += t1[2];\t\n\n\tdx1 = pp[0] / pp[2] - Vx(p);\n\tdy1 = pp[1] / pp[2] - Vy(p);\n\n\tdx2 = qp[0] / qp[2] - Vx(q);\n\tdy2 = qp[1] / qp[2] - Vy(q);\n\n\t*error = dx1 * dx1 + dy1 * dy1 + dx2 * dx2 + dy2 * dy2;\n    }\n\n    return v3_new(x[0], x[1], x[2]);\n}", "path": "bundler_sfm/lib/imagelib/triangulate.c", "commit_date": "2015-11-12 00:00:00", "repo_name": "snavely/bundler_sfm", "stars": 1507, "license": "None", "language": "c", "size": 6187}
{"docstring": "/* Given an F matrix, two calibration matrices, and a point correspondence, find R and t */\n", "func_signal": "void find_extrinsics(double *F, double *K1, double *K2, \n                     v2_t p1, v2_t p2, double *R, double *t)", "code": "{\n    double E[9];\n    double K1_inv[9], K2_inv[9], tmp[9];\n    \n    /* Find the essential matrix */\n    matrix_invert(3, K1, K1_inv);\n    matrix_invert(3, K2, K2_inv);\n    \n    matrix_product33(F, K1, tmp);\n    matrix_transpose_product(3, 3, 3, 3, K2, tmp, E);\n\n    find_extrinsics_essential(E, p1, p2, R, t);\n}", "path": "bundler_sfm/lib/imagelib/triangulate.c", "commit_date": "2015-11-12 00:00:00", "repo_name": "snavely/bundler_sfm", "stars": 1507, "license": "None", "language": "c", "size": 6187}
{"docstring": "/*\n * Initialize coefficient buffer controller.\n */\n", "func_signal": "GLOBAL(void)\njinit_d_coef_controller (j_decompress_ptr cinfo, boolean need_full_buffer)", "code": "{\n  my_coef_ptr coef;\n\n  coef = (my_coef_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\tSIZEOF(my_coef_controller));\n  cinfo->coef = (struct jpeg_d_coef_controller *) coef;\n  coef->pub.start_input_pass = start_input_pass;\n  coef->pub.start_output_pass = start_output_pass;\n#ifdef BLOCK_SMOOTHING_SUPPORTED\n  coef->coef_bits_latch = NULL;\n#endif\n\n  /* Create the coefficient buffer. */\n  if (need_full_buffer) {\n#ifdef D_MULTISCAN_FILES_SUPPORTED\n    /* Allocate a full-image virtual array for each component, */\n    /* padded to a multiple of samp_factor DCT blocks in each direction. */\n    /* Note we ask for a pre-zeroed array. */\n    int ci, access_rows;\n    jpeg_component_info *compptr;\n\n    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n\t ci++, compptr++) {\n      access_rows = compptr->v_samp_factor;\n#ifdef BLOCK_SMOOTHING_SUPPORTED\n      /* If block smoothing could be used, need a bigger window */\n      if (cinfo->progressive_mode)\n\taccess_rows *= 3;\n#endif\n      coef->whole_image[ci] = (*cinfo->mem->request_virt_barray)\n\t((j_common_ptr) cinfo, JPOOL_IMAGE, TRUE,\n\t (JDIMENSION) jround_up((long) compptr->width_in_blocks,\n\t\t\t\t(long) compptr->h_samp_factor),\n\t (JDIMENSION) jround_up((long) compptr->height_in_blocks,\n\t\t\t\t(long) compptr->v_samp_factor),\n\t (JDIMENSION) access_rows);\n    }\n    coef->pub.consume_data = consume_data;\n    coef->pub.decompress_data = decompress_data;\n    coef->pub.coef_arrays = coef->whole_image; /* link to virtual arrays */\n#else\n    ERREXIT(cinfo, JERR_NOT_COMPILED);\n#endif\n  } else {\n    /* We only need a single-MCU buffer. */\n    JBLOCKROW buffer;\n    int i;\n\n    buffer = (JBLOCKROW)\n      (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\t  D_MAX_BLOCKS_IN_MCU * SIZEOF(JBLOCK));\n    for (i = 0; i < D_MAX_BLOCKS_IN_MCU; i++) {\n      coef->MCU_buffer[i] = buffer + i;\n    }\n    coef->pub.consume_data = dummy_consume_data;\n    coef->pub.decompress_data = decompress_onepass;\n    coef->pub.coef_arrays = NULL; /* flag for no virtual arrays */\n  }\n}", "path": "bundler_sfm/lib/jpeg/src/jdcoefct.c", "commit_date": "2013-03-10 00:00:00", "repo_name": "snavely/bundler_sfm", "stars": 1507, "license": "None", "language": "c", "size": 6187}
{"docstring": "/*\n * Initialize for an output processing pass.\n */\n", "func_signal": "METHODDEF(void)\nstart_output_pass (j_decompress_ptr cinfo)", "code": "{\n#ifdef BLOCK_SMOOTHING_SUPPORTED\n  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;\n\n  /* If multipass, check to see whether to use block smoothing on this pass */\n  if (coef->pub.coef_arrays != NULL) {\n    if (cinfo->do_block_smoothing && smoothing_ok(cinfo))\n      coef->pub.decompress_data = decompress_smooth_data;\n    else\n      coef->pub.decompress_data = decompress_data;\n  }\n#endif\n  cinfo->output_iMCU_row = 0;\n}", "path": "bundler_sfm/lib/jpeg/src/jdcoefct.c", "commit_date": "2013-03-10 00:00:00", "repo_name": "snavely/bundler_sfm", "stars": 1507, "license": "None", "language": "c", "size": 6187}
{"docstring": "/*\n * Decompress and return some data in the multi-pass case.\n * Always attempts to emit one fully interleaved MCU row (\"iMCU\" row).\n * Return value is JPEG_ROW_COMPLETED, JPEG_SCAN_COMPLETED, or JPEG_SUSPENDED.\n *\n * NB: output_buf contains a plane for each component in image.\n */\n", "func_signal": "METHODDEF(int)\ndecompress_data (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)", "code": "{\n  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;\n  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;\n  JDIMENSION block_num;\n  int ci, block_row, block_rows;\n  JBLOCKARRAY buffer;\n  JBLOCKROW buffer_ptr;\n  JSAMPARRAY output_ptr;\n  JDIMENSION output_col;\n  jpeg_component_info *compptr;\n  inverse_DCT_method_ptr inverse_DCT;\n\n  /* Force some input to be done if we are getting ahead of the input. */\n  while (cinfo->input_scan_number < cinfo->output_scan_number ||\n\t (cinfo->input_scan_number == cinfo->output_scan_number &&\n\t  cinfo->input_iMCU_row <= cinfo->output_iMCU_row)) {\n    if ((*cinfo->inputctl->consume_input)(cinfo) == JPEG_SUSPENDED)\n      return JPEG_SUSPENDED;\n  }\n\n  /* OK, output from the virtual arrays. */\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n       ci++, compptr++) {\n    /* Don't bother to IDCT an uninteresting component. */\n    if (! compptr->component_needed)\n      continue;\n    /* Align the virtual buffer for this component. */\n    buffer = (*cinfo->mem->access_virt_barray)\n      ((j_common_ptr) cinfo, coef->whole_image[ci],\n       cinfo->output_iMCU_row * compptr->v_samp_factor,\n       (JDIMENSION) compptr->v_samp_factor, FALSE);\n    /* Count non-dummy DCT block rows in this iMCU row. */\n    if (cinfo->output_iMCU_row < last_iMCU_row)\n      block_rows = compptr->v_samp_factor;\n    else {\n      /* NB: can't use last_row_height here; it is input-side-dependent! */\n      block_rows = (int) (compptr->height_in_blocks % compptr->v_samp_factor);\n      if (block_rows == 0) block_rows = compptr->v_samp_factor;\n    }\n    inverse_DCT = cinfo->idct->inverse_DCT[ci];\n    output_ptr = output_buf[ci];\n    /* Loop over all DCT blocks to be processed. */\n    for (block_row = 0; block_row < block_rows; block_row++) {\n      buffer_ptr = buffer[block_row];\n      output_col = 0;\n      for (block_num = 0; block_num < compptr->width_in_blocks; block_num++) {\n\t(*inverse_DCT) (cinfo, compptr, (JCOEFPTR) buffer_ptr,\n\t\t\toutput_ptr, output_col);\n\tbuffer_ptr++;\n\toutput_col += compptr->DCT_scaled_size;\n      }\n      output_ptr += compptr->DCT_scaled_size;\n    }\n  }\n\n  if (++(cinfo->output_iMCU_row) < cinfo->total_iMCU_rows)\n    return JPEG_ROW_COMPLETED;\n  return JPEG_SCAN_COMPLETED;\n}", "path": "bundler_sfm/lib/jpeg/src/jdcoefct.c", "commit_date": "2013-03-10 00:00:00", "repo_name": "snavely/bundler_sfm", "stars": 1507, "license": "None", "language": "c", "size": 6187}
{"docstring": "/* Use non-linear least squares to refine a homography */\n", "func_signal": "void align_homography_non_linear(int num_pts, v3_t *r_pts, v3_t *l_pts, \n\t\t\t\t double *Tin, double *Tout)", "code": "{\n    double x[8];\n\n    if (num_pts > 4) {\n\tprintf(\"pre: \");\n\tmatrix_print(3, 3, Tin);\n    }\n    \n    memcpy(x, Tin, 8 * sizeof(double));\n\n    global_num_pts = num_pts;\n    global_r_pts = r_pts;\n    global_l_pts = l_pts;\n    global_round = 0;\n\n    lmdif_driver(homography_resids, 2 * num_pts, 8, x, 1.0e-4);\n    \n    memcpy(Tout, x, 8 * sizeof(double));\n    Tout[8] = 1.0;\n\n    if (num_pts > 4) {\n\tprintf(\"post: \");\n\tmatrix_print(3, 3, Tout);\n    }\n}", "path": "bundler_sfm/lib/imagelib/homography.c", "commit_date": "2013-03-10 00:00:00", "repo_name": "snavely/bundler_sfm", "stars": 1507, "license": "None", "language": "c", "size": 6187}
{"docstring": "/* Given an E matrix and a point correspondence, find R and t */\n", "func_signal": "int find_extrinsics_essential(double *E, v2_t p1, v2_t p2, \n                              double *R, double *t)", "code": "{\n    double tmp[9], tmp2[3], Qv[3];\n    double U[9], S[3], VT[9];\n    double tu[3], Ra[9], Rb[9];\n\n    double D[9] = \n\t{  0.0, 1.0, 0.0,\n\t  -1.0, 0.0, 0.0,\n\t   0.0, 0.0, 1.0 };\n\n    double DT[9] = \n\t{  0.0, -1.0, 0.0,\n\t   1.0,  0.0, 0.0,\n\t   0.0,  0.0, 1.0 };\n\n    double I[9] = \n\t{  1.0, 0.0, 0.0, \n\t   0.0, 1.0, 0.0,\n\t   0.0, 0.0, 1.0 };\n    \n    double t0[3] = { 0.0, 0.0, 0.0 };\n\n    v3_t Q, PQ;\n    double c1, c2;\n    double error;\n\n    /* Now find the SVD of E */\n    dgesvd_driver(3, 3, E, U, S, VT);\n\n#if 0\n    printf(\"S[0] = %0.3e\\n\", S[0]);\n    printf(\"S[1] = %0.3e\\n\", S[1]);\n    printf(\"S[2] = %0.3e\\n\", S[2]);\n#endif\n\n    /* Now find R and t */\n    tu[0] = U[2];  tu[1] = U[5];  tu[2] = U[8];\n\n    matrix_product33(U, D, tmp);\n    matrix_product33(tmp, VT, Ra);\n    matrix_product33(U, DT, tmp);\n\n    matrix_product33(tmp, VT, Rb);\n\n    if (matrix_determinant3(Ra) < 0.0) {\n\t// printf(\"flipping...\\n\");\n\tmatrix_scale(3, 3, Ra, -1.0, Ra);\n    }\n\n    if (matrix_determinant3(Rb) < 0.0) {\n\t// printf(\"flopping...\\n\");\n\tmatrix_scale(3, 3, Rb, -1.0, Rb);\n    }\n\n    /* Figure out which configuration is correct using the supplied\n     * point */\n\n    Q = triangulate(p1, p2, I, t0, Ra, tu, &error);\n    Qv[0] = Vx(Q), Qv[1] = Vy(Q), Qv[2] = Vz(Q);\n    matrix_product331(Ra, Qv, tmp);\n    matrix_sum(3, 1, 3, 1, tmp, tu, tmp2);\n    PQ = v3_new(tmp2[0], tmp2[1], tmp2[2]);\n\n    c1 = Vz(Q);\n    c2 = Vz(PQ);\n\n    if (c1 < 0 && c2 < 0) {\n\tmemcpy(R, Ra, 9 * sizeof(double));\n\tt[0] = tu[0]; t[1] = tu[1]; t[2] = tu[2];\n    } else if (c1 > 0 && c2 > 0) {\n\tmemcpy(R, Ra, 9 * sizeof(double));\n\tt[0] = -tu[0]; t[1] = -tu[1]; t[2] = -tu[2];\n        Q = triangulate(p1, p2, I, t0, R, t, &error);\n    } else {\n        /* Triangulate again */\n        Q = triangulate(p1, p2, I, t0, Rb, tu, &error);\n        Qv[0] = Vx(Q), Qv[1] = Vy(Q), Qv[2] = Vz(Q);\n        matrix_product331(Rb, Qv, tmp);\n        matrix_sum(3, 1, 3, 1, tmp, tu, tmp2);\n        PQ = v3_new(tmp2[0], tmp2[1], tmp2[2]);\n\n        c1 = Vz(Q);\n        c2 = Vz(PQ);\n\n        if (c1 < 0 && c2 < 0) {\n            memcpy(R, Rb, 9 * sizeof(double));\n            t[0] = tu[0]; t[1] = tu[1]; t[2] = tu[2];\n        } else if (c1 > 0 && c2 > 0) {\n            memcpy(R, Rb, 9 * sizeof(double));\n            t[0] = -tu[0]; t[1] = -tu[1]; t[2] = -tu[2];\n            Q = triangulate(p1, p2, I, t0, R, t, &error);\n        } else {\n            printf(\"[find_extrinsics] Error: no case found!\\n\");\n            return 0;\n        }\n    }\n\n    matrix_product331(R, Q.p, tmp2);\n    matrix_sum(3, 1, 3, 1, tmp2, t, tmp2);\n\n    printf(\"[find_extrinsics] error: %0.3e\\n\", error);\n    // printf(\"  %0.3f => %0.3f\\n\", Vx(p2), tmp2[0] / tmp2[2]);\n    // printf(\"  %0.3f => %0.3f\\n\", Vy(p2), tmp2[1] / tmp2[2]);\n    // printf(\"  %0.3f\\n\", tmp2[2]);\n\n    return 1;\n}", "path": "bundler_sfm/lib/imagelib/triangulate.c", "commit_date": "2015-11-12 00:00:00", "repo_name": "snavely/bundler_sfm", "stars": 1507, "license": "None", "language": "c", "size": 6187}
{"docstring": "/*\n * Decompress and return some data in the single-pass case.\n * Always attempts to emit one fully interleaved MCU row (\"iMCU\" row).\n * Input and output must run in lockstep since we have only a one-MCU buffer.\n * Return value is JPEG_ROW_COMPLETED, JPEG_SCAN_COMPLETED, or JPEG_SUSPENDED.\n *\n * NB: output_buf contains a plane for each component in image,\n * which we index according to the component's SOF position.\n */\n", "func_signal": "METHODDEF(int)\ndecompress_onepass (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)", "code": "{\n  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;\n  JDIMENSION MCU_col_num;\t/* index of current MCU within row */\n  JDIMENSION last_MCU_col = cinfo->MCUs_per_row - 1;\n  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;\n  int blkn, ci, xindex, yindex, yoffset, useful_width;\n  JSAMPARRAY output_ptr;\n  JDIMENSION start_col, output_col;\n  jpeg_component_info *compptr;\n  inverse_DCT_method_ptr inverse_DCT;\n\n  /* Loop to process as much as one whole iMCU row */\n  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;\n       yoffset++) {\n    for (MCU_col_num = coef->MCU_ctr; MCU_col_num <= last_MCU_col;\n\t MCU_col_num++) {\n      /* Try to fetch an MCU.  Entropy decoder expects buffer to be zeroed. */\n      jzero_far((void FAR *) coef->MCU_buffer[0],\n\t\t(size_t) (cinfo->blocks_in_MCU * SIZEOF(JBLOCK)));\n      if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {\n\t/* Suspension forced; update state counters and exit */\n\tcoef->MCU_vert_offset = yoffset;\n\tcoef->MCU_ctr = MCU_col_num;\n\treturn JPEG_SUSPENDED;\n      }\n      /* Determine where data should go in output_buf and do the IDCT thing.\n       * We skip dummy blocks at the right and bottom edges (but blkn gets\n       * incremented past them!).  Note the inner loop relies on having\n       * allocated the MCU_buffer[] blocks sequentially.\n       */\n      blkn = 0;\t\t\t/* index of current DCT block within MCU */\n      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n\tcompptr = cinfo->cur_comp_info[ci];\n\t/* Don't bother to IDCT an uninteresting component. */\n\tif (! compptr->component_needed) {\n\t  blkn += compptr->MCU_blocks;\n\t  continue;\n\t}\n\tinverse_DCT = cinfo->idct->inverse_DCT[compptr->component_index];\n\tuseful_width = (MCU_col_num < last_MCU_col) ? compptr->MCU_width\n\t\t\t\t\t\t    : compptr->last_col_width;\n\toutput_ptr = output_buf[compptr->component_index] +\n\t  yoffset * compptr->DCT_scaled_size;\n\tstart_col = MCU_col_num * compptr->MCU_sample_width;\n\tfor (yindex = 0; yindex < compptr->MCU_height; yindex++) {\n\t  if (cinfo->input_iMCU_row < last_iMCU_row ||\n\t      yoffset+yindex < compptr->last_row_height) {\n\t    output_col = start_col;\n\t    for (xindex = 0; xindex < useful_width; xindex++) {\n\t      (*inverse_DCT) (cinfo, compptr,\n\t\t\t      (JCOEFPTR) coef->MCU_buffer[blkn+xindex],\n\t\t\t      output_ptr, output_col);\n\t      output_col += compptr->DCT_scaled_size;\n\t    }\n\t  }\n\t  blkn += compptr->MCU_width;\n\t  output_ptr += compptr->DCT_scaled_size;\n\t}\n      }\n    }\n    /* Completed an MCU row, but perhaps not an iMCU row */\n    coef->MCU_ctr = 0;\n  }\n  /* Completed the iMCU row, advance counters for next one */\n  cinfo->output_iMCU_row++;\n  if (++(cinfo->input_iMCU_row) < cinfo->total_iMCU_rows) {\n    start_iMCU_row(cinfo);\n    return JPEG_ROW_COMPLETED;\n  }\n  /* Completed the scan */\n  (*cinfo->inputctl->finish_input_pass) (cinfo);\n  return JPEG_SCAN_COMPLETED;\n}", "path": "bundler_sfm/lib/jpeg/src/jdcoefct.c", "commit_date": "2013-03-10 00:00:00", "repo_name": "snavely/bundler_sfm", "stars": 1507, "license": "None", "language": "c", "size": 6187}
{"docstring": "/* Given an E matrix and a point correspondence, find R and t */\n", "func_signal": "int find_extrinsics_essential_multipt(double *E, int n,\n                                      v2_t *p1, v2_t *p2, \n                                      double *R, double *t)", "code": "{\n    double tmp[9], tmp2[3], Qv[3];\n    double U[9], S[3], VT[9];\n    double tu[3], Ra[9], Rb[9];\n\n    double D[9] = \n\t{  0.0, 1.0, 0.0,\n\t  -1.0, 0.0, 0.0,\n\t   0.0, 0.0, 1.0 };\n\n    double DT[9] = \n\t{  0.0, -1.0, 0.0,\n\t   1.0,  0.0, 0.0,\n\t   0.0,  0.0, 1.0 };\n\n    double I[9] = \n\t{  1.0, 0.0, 0.0, \n\t   0.0, 1.0, 0.0,\n\t   0.0, 0.0, 1.0 };\n    \n    double t0[3] = { 0.0, 0.0, 0.0 };\n\n    v3_t Q, PQ;\n    double c1, c2;\n    double error;\n\n    int i;\n    int c1_pos = 0, c1_neg = 0;\n    int c2_pos = 0, c2_neg = 0;\n\n    /* Now find the SVD of E */\n    dgesvd_driver(3, 3, E, U, S, VT);\n\n#if 0\n    printf(\"S[0] = %0.3e\\n\", S[0]);\n    printf(\"S[1] = %0.3e\\n\", S[1]);\n    printf(\"S[2] = %0.3e\\n\", S[2]);\n#endif\n\n    /* Now find R and t */\n    tu[0] = U[2];  tu[1] = U[5];  tu[2] = U[8];\n\n    matrix_product33(U, D, tmp);\n    matrix_product33(tmp, VT, Ra);\n    matrix_product33(U, DT, tmp);\n\n    matrix_product33(tmp, VT, Rb);\n\n    if (matrix_determinant3(Ra) < 0.0) {\n\t// printf(\"flipping...\\n\");\n\tmatrix_scale(3, 3, Ra, -1.0, Ra);\n    }\n\n    if (matrix_determinant3(Rb) < 0.0) {\n\t// printf(\"flopping...\\n\");\n\tmatrix_scale(3, 3, Rb, -1.0, Rb);\n    }\n\n    /* Figure out which configuration is correct using the supplied\n     * points */\n\n    for (i = 0; i < n; i++) {\n        Q = triangulate(p1[i], p2[i], I, t0, Ra, tu, &error);\n        Qv[0] = Vx(Q), Qv[1] = Vy(Q), Qv[2] = Vz(Q);\n        matrix_product331(Ra, Qv, tmp);\n        matrix_sum(3, 1, 3, 1, tmp, tu, tmp2);\n        PQ = v3_new(tmp2[0], tmp2[1], tmp2[2]);\n\n        c1 = Vz(Q);\n        c2 = Vz(PQ);\n\n        if (c1 > 0)\n            c1_pos++;\n        else\n            c1_neg++;\n        \n        if (c2 > 0)\n            c2_pos++;\n        else\n            c2_neg++;\n    }\n\n    if (c1_pos < c1_neg && c2_pos < c2_neg) {\n\tmemcpy(R, Ra, 9 * sizeof(double));\n\tt[0] = tu[0]; t[1] = tu[1]; t[2] = tu[2];\n    } else if (c1_pos > c1_neg && c2_pos > c2_neg) {\n\tmemcpy(R, Ra, 9 * sizeof(double));\n\tt[0] = -tu[0]; t[1] = -tu[1]; t[2] = -tu[2];\n    } else {\n        /* Triangulate again */\n        c1_pos = c1_neg = c2_pos = c2_neg = 0;\n\n        for (i = 0; i < n; i++) {\n            Q = triangulate(p1[i], p2[i], I, t0, Rb, tu, &error);\n            Qv[0] = Vx(Q), Qv[1] = Vy(Q), Qv[2] = Vz(Q);\n            matrix_product331(Rb, Qv, tmp);\n            matrix_sum(3, 1, 3, 1, tmp, tu, tmp2);\n            PQ = v3_new(tmp2[0], tmp2[1], tmp2[2]);\n\n            c1 = Vz(Q);\n            c2 = Vz(PQ);\n\n            if (c1 > 0)\n                c1_pos++;\n            else\n                c1_neg++;\n        \n            if (c2 > 0)\n                c2_pos++;\n            else\n                c2_neg++;\n        }\n\n        if (c1_pos < c1_neg && c2_pos < c2_neg) {\n            memcpy(R, Rb, 9 * sizeof(double));\n            t[0] = tu[0]; t[1] = tu[1]; t[2] = tu[2];\n        } else if (c1_pos > c1_neg && c2_pos > c2_neg) {\n            memcpy(R, Rb, 9 * sizeof(double));\n            t[0] = -tu[0]; t[1] = -tu[1]; t[2] = -tu[2];\n        } else {\n            fprintf(stderr, \"[find_extrinsics] Error: no case found!\\n\");\n            return 0;\n        }\n    }\n\n    return 1;\n}", "path": "bundler_sfm/lib/imagelib/triangulate.c", "commit_date": "2015-11-12 00:00:00", "repo_name": "snavely/bundler_sfm", "stars": 1507, "license": "None", "language": "c", "size": 6187}
{"docstring": "/*\n * Initialize for an input processing pass.\n */\n", "func_signal": "METHODDEF(void)\nstart_input_pass (j_decompress_ptr cinfo)", "code": "{\n  cinfo->input_iMCU_row = 0;\n  start_iMCU_row(cinfo);\n}", "path": "bundler_sfm/lib/jpeg/src/jdcoefct.c", "commit_date": "2013-03-10 00:00:00", "repo_name": "snavely/bundler_sfm", "stars": 1507, "license": "None", "language": "c", "size": 6187}
{"docstring": "/* Solve for a 3x4 projection matrix, given a set of 3D points and 2D\n * projections */\n", "func_signal": "int find_projection_3x4(int num_pts, v3_t *points, v2_t *projs, double *P)", "code": "{\n    if (num_pts < 6) {\n\tprintf(\"[find_projection_3x4] Need at least 6 points!\\n\");\n\treturn -1;\n    } else {\n\n\t// #define _CONDITION_\n#ifdef _CONDITION_\n\tdouble Tpoints[16];\n\tv3_t *points_new = condition_points_3D(num_pts, points, Tpoints);\n\t\n\tdouble Tprojs[9];\n\tv2_t *projs_new = condition_points_2D(num_pts, projs, Tprojs);\n\n\tdouble Tprojs_inv[9];\n\tdouble Ptmp[12];\n#else\n\tv3_t *points_new = points;\n\tv2_t *projs_new = projs;\n#endif\n\n\tint num_eqns = 2 * num_pts;\n\tint num_vars = 11;\n\n\tdouble *A = malloc(sizeof(double) * num_eqns * num_vars);\n\tdouble *b = malloc(sizeof(double) * num_eqns);\n\tdouble X[11];\n\n\tdouble error = 0.0;\n    \n\tint i;\n\n\tfor (i = 0; i < num_pts; i++) {\n\t    double *row1 = A + 2 * i * num_vars;\n\t    double *row2 = A + (2 * i + 1) * num_vars;\n\t    \n\t    row1[0]  = Vx(points_new[i]);\n\t    row1[1]  = Vy(points_new[i]);\n\t    row1[2]  = Vz(points_new[i]);\n\t    row1[3]  = 1.0;\n\t\n\t    row1[4]  = 0.0;\n\t    row1[5]  = 0.0;\n\t    row1[6]  = 0.0;\n\t    row1[7]  = 0.0;\n\t\n\t    row1[8]  = Vx(projs_new[i]) * Vx(points_new[i]);\n\t    row1[9]  = Vx(projs_new[i]) * Vy(points_new[i]);\n\t    row1[10] = Vx(projs_new[i]) * Vz(points_new[i]);\n\t\n\t    b[2 * i] = -Vx(projs_new[i]);\n\n\n\t    row2[0]  = 0.0;\n\t    row2[1]  = 0.0;\n\t    row2[2]  = 0.0;\n\t    row2[3]  = 0.0;\n\n\t    row2[4]  = Vx(points_new[i]);\n\t    row2[5]  = Vy(points_new[i]);\n\t    row2[6]  = Vz(points_new[i]);\n\t    row2[7]  = 1.0;\t\n\n\t    row2[8]  = Vy(projs_new[i]) * Vx(points_new[i]);\n\t    row2[9]  = Vy(projs_new[i]) * Vy(points_new[i]);\n\t    row2[10] = Vy(projs_new[i]) * Vz(points_new[i]);\n\t\n\t    b[2 * i + 1] = -Vy(projs_new[i]);\n\t}\n\n\tdgelsy_driver(A, b, X, num_eqns, num_vars, 1);\n\n\tmemcpy(P, X, sizeof(double) * 11);\n\tP[11] = 1.0;\n\n#ifdef _CONDITION_\n\tmatrix_invert(3, Tprojs, Tprojs_inv);\n\tmatrix_product(3, 3, 3, 4, Tprojs_inv, P, Ptmp);\n\tmatrix_product(3, 4, 4, 4, Ptmp, Tpoints, P);\n\t\n\tmatrix_scale(3, 4, P, 1.0 / P[11], P);\n#endif\n\n\tfor (i = 0; i < num_pts; i++) {\n\t    double pt[4] = { Vx(points[i]), \n\t\t\t     Vy(points[i]), \n\t\t\t     Vz(points[i]), 1.0 };\n\t    double pr[3];\n\t    double dx, dy, dist;\n\n\t    matrix_product341(P, pt, pr);\n\t    pr[0] /= -pr[2];\n\t    pr[1] /= -pr[2];\n\t    \n\t    dx = pr[0] - Vx(projs[i]);\n\t    dy = pr[1] - Vy(projs[i]);\n\n\t    dist = dx * dx + dy * dy;\n\n\t    error += dist;\n\t}\n\n\t// printf(\"[find_projection_3x4] Average error is %0.3f\\n\", \n\t//       error / num_pts);\n\n\tfree(A);\n\tfree(b);\n\n#ifdef _CONDITION_\n\tfree(points_new);\n\tfree(projs_new);\n#endif\n\n\treturn 0;\n    }\n}", "path": "bundler_sfm/lib/imagelib/triangulate.c", "commit_date": "2015-11-12 00:00:00", "repo_name": "snavely/bundler_sfm", "stars": 1507, "license": "None", "language": "c", "size": 6187}
{"docstring": "/* Solve for a 3x4 projection matrix using RANSAC, given a set of 3D\n * points and 2D projections */\n", "func_signal": "int find_projection_3x4_ransac(int num_pts, v3_t *points, v2_t *projs, \n\t\t\t       double *P, \n\t\t\t       int ransac_rounds, double ransac_threshold)", "code": "{\n    if (num_pts < 6) {\n\tprintf(\"[find_projection_3x4_ransac] Error: need at least 6 points!\\n\");\n\treturn -1;\n    } else {\n#define MIN_PTS 6\n\t// const int min_pts = 6;\n\tint *inliers = (int *) malloc(sizeof(int) * num_pts);\n\tint indices[MIN_PTS];\n\tint round, i, j;\n\tint max_inliers = 0;\n\tdouble max_error = 0.0;\n\tdouble Pbest[12];\n\tint num_inliers = 0, num_inliers_new = 0;\n\tv3_t *pts_final = NULL;\n\tv2_t *projs_final = NULL;\n\tdouble Plinear[12];\n\n\tdouble Rinit[9];\n\tdouble triangular[9], orthogonal[9];\n\tint neg, sign;\n\n\tdouble thresh_sq = ransac_threshold * ransac_threshold;\n\tdouble error = 0.0;\n\n\tint num_inliers_polished = 0;\n\n\tfor (round = 0; round < ransac_rounds; round++) {\n\t    v3_t pts_inner[MIN_PTS];\n\t    v2_t projs_inner[MIN_PTS];\n\t    double Ptmp[12];\n\n\t    num_inliers = 0;\n\t    for (i = 0; i < MIN_PTS; i++) {\n\t\tint redo = 0;\n\t\tint idx;\n                int redo_count = 0;\n\n\t\tdo {\n                    if (redo_count > 10000) {\n                        free(inliers);\n                        return -1;\n                    }\n\n\t\t    idx = rand() % num_pts;\n\t\t    \n\t\t    redo = 0;\n\t\t    for (j = 0; j < i; j++) {\n\t\t\tif (idx == indices[j]) {\n\t\t\t    redo = 1;\n\t\t\t    break;\n\t\t\t} else if (Vx(projs[idx]) == Vx(projs[indices[j]]) && \n                                   Vy(projs[idx]) == Vy(projs[indices[j]])) {\n                            redo = 1;\n                        }\n\t\t    }\n\n                    redo_count++;\n\t\t} while(redo);\n\t    \n\t\tindices[i] = idx;\n\t\tpts_inner[i] = points[idx];\n\t\tprojs_inner[i] = projs[idx];\n\t    }\n\n\t    /* Solve for the parameters */\n\t    find_projection_3x4(MIN_PTS, pts_inner, projs_inner, Ptmp);\n\n#if 1\n\t    /* Fix the sign on the P matrix */\n            memcpy(Rinit + 0, Ptmp + 0, 3 * sizeof(double));\n            memcpy(Rinit + 3, Ptmp + 4, 3 * sizeof(double));\n            memcpy(Rinit + 6, Ptmp + 8, 3 * sizeof(double));\n\n            dgerqf_driver(3, 3, Rinit, triangular, orthogonal);\t    \n\n\t    /* Check the parity along the diagonal */\n\t    neg = \n\t\t(triangular[0] < 0.0) + \n\t\t(triangular[4] < 0.0) + \n\t\t(triangular[8] < 0.0);\n\n\t    if ((neg % 2) == 1) {\n\t\tsign = -1;\n\t    } else {\n\t\tsign = 1;\n\t    }\n#endif\n\t    \n\t    /* Count the number of inliers */\n\t    error = 0.0;\n\t    for (i = 0; i < num_pts; i++) {\n\t\tdouble pt[4] = { Vx(points[i]), \n\t\t\t\t Vy(points[i]), \n\t\t\t\t Vz(points[i]), 1.0 };\n\t\tdouble pr[3];\n\t\tdouble dx, dy, dist;\n\n\t\tmatrix_product341(Ptmp, pt, pr);\n\n\t\t/* Check cheirality */\n\t\tif (sign * pr[2] > 0.0) \n\t\t    continue;\n\n\t\tpr[0] /= -pr[2];\n\t\tpr[1] /= -pr[2];\n\t    \n\t\tdx = pr[0] - Vx(projs[i]);\n\t\tdy = pr[1] - Vy(projs[i]);\n\n\t\tdist = dx * dx + dy * dy;\n\n\t\tif (dist < thresh_sq) {\n\t\t    inliers[num_inliers] = i;\n\t\t    num_inliers++;\n\t\t    error += dist;\n\t\t}\n\t    }\n\t    \n\t    if (num_inliers > max_inliers) {\n\t\tmemcpy(Pbest, Ptmp, sizeof(double) * 12);\n\t\tmax_error = error;\n\t\tmax_inliers = num_inliers;\n\t    }\n\t}\n\t\n\tmemcpy(P, Pbest, sizeof(double) * 12);\n\n\tprintf(\"[find_projection_3x4_ransac] num_inliers = %d (out of %d)\\n\",\n\t       max_inliers, num_pts);\n\tprintf(\"[find_projection_3x4_ransac] error = %0.3f\\n\", \n\t       sqrt(max_error / max_inliers));\n\n        if (max_inliers < 6) {\n            printf(\"[find_projection_3x4_ransac] \"\n                   \"Too few inliers to continue.\\n\");\n            \n            free(inliers);\n\n            return -1;\n        }\n\t\n\t/* Do the final least squares minimization */\n\n#if 1\n\t/* Fix the sign on the P matrix */\n\tmemcpy(Rinit + 0, Pbest + 0, 3 * sizeof(double));\n\tmemcpy(Rinit + 3, Pbest + 4, 3 * sizeof(double));\n\tmemcpy(Rinit + 6, Pbest + 8, 3 * sizeof(double));\n\n\tdgerqf_driver(3, 3, Rinit, triangular, orthogonal);\t    \n\n\t/* Check the parity along the diagonal */\n\tneg = \n\t    (triangular[0] < 0.0) + \n\t    (triangular[4] < 0.0) + \n\t    (triangular[8] < 0.0);\n\n\tif ((neg % 2) == 1) {\n\t    sign = -1;\n\t} else {\n\t    sign = 1;\n\t}\n#endif\n\n\tnum_inliers = 0;\n\tpts_final = (v3_t *) malloc(sizeof(v3_t) * max_inliers);\n\tprojs_final = (v2_t *) malloc(sizeof(v2_t) * max_inliers);\n\t\n\tfor (i = 0; i < num_pts; i++) {\n\t    double pt[4] = { Vx(points[i]), \n\t\t\t     Vy(points[i]), \n\t\t\t     Vz(points[i]), 1.0 };\n\n\t    double pr[3];\n\t    double dx, dy, dist;\n\t    \n\t    matrix_product341(Pbest, pt, pr);\n\n\t    /* Check cheirality */\n\t    if (sign * pr[2] > 0.0) \n\t\tcontinue;\n\n\t    pr[0] /= -pr[2];\n\t    pr[1] /= -pr[2];\n\t    \n\t    dx = pr[0] - Vx(projs[i]);\n\t    dy = pr[1] - Vy(projs[i]);\n\n\t    dist = dx * dx + dy * dy;\n\n\t    if (dist < thresh_sq) {\n\t\tpts_final[num_inliers] = points[i];\n\t\tprojs_final[num_inliers] = projs[i];\n\t\tnum_inliers++;\n\t    }\n\t}\n\n\tif (num_inliers != max_inliers) {\n\t    printf(\"[find_projection_3x4_ransac] Error! There was a miscount \"\n\t\t   \"somewhere: (%d != %d)\\n\", num_inliers, max_inliers);\n\t}\n\n\tfind_projection_3x4(max_inliers, pts_final, projs_final, Plinear);\n\n#if 1\n\t/* Fix the sign on the P matrix */\n\tmemcpy(Rinit + 0, Plinear + 0, 3 * sizeof(double));\n\tmemcpy(Rinit + 3, Plinear + 4, 3 * sizeof(double));\n\tmemcpy(Rinit + 6, Plinear + 8, 3 * sizeof(double));\n\n\tdgerqf_driver(3, 3, Rinit, triangular, orthogonal);\t    \n\t\n\t/* Check the parity along the diagonal */\n\tneg = \n\t    (triangular[0] < 0.0) + \n\t    (triangular[4] < 0.0) + \n\t    (triangular[8] < 0.0);\n\n\tif ((neg % 2) == 1) {\n\t    sign = -1;\n\t} else {\n\t    sign = 1;\n\t}\n#endif\n\n\tfor (i = 0; i < num_pts; i++) {\n\t    double pt[4] = \n\t\t{ Vx(points[i]), Vy(points[i]), Vz(points[i]), 1.0 };\n\t    double pr[3];\n\t    double dx, dy, dist;\n\t    \n\t    matrix_product341(Plinear, pt, pr);\n\n\t    if (sign * pr[2] > 0.0)\n\t\tcontinue;\n\n\t    pr[0] /= -pr[2];\n\t    pr[1] /= -pr[2];\n\t    \n\t    dx = pr[0] - Vx(projs[i]);\n\t    dy = pr[1] - Vy(projs[i]);\n\n\t    dist = dx * dx + dy * dy;\n\n\t    if (dist < thresh_sq) {\n\t\tnum_inliers_new++;\n\t    }\n\t}\n\n\tif (num_inliers_new < max_inliers) {\n\t    printf(\"[find_projection_3x4_ransac] Reverting to old solution\\n\");\n\t    memcpy(Plinear, Pbest, 12 * sizeof(double));\n\t}\n\t\n\tprintf(\"Best matrix (pre-opt):\\n\");\n\tmatrix_print(3, 4, Plinear);\n\n\terror = 0.0;\n\tfor (i = 0; i < max_inliers; i++) {\n\t    double pt[4] = \n\t\t{ Vx(pts_final[i]), Vy(pts_final[i]), Vz(pts_final[i]), 1.0 };\n\t    double pr[3];\n\t    double dx, dy, dist;\n\t    \n\t    matrix_product341(Plinear, pt, pr);\n\t    pr[0] /= pr[2];\n\t    pr[1] /= pr[2];\n\t    \n\t    dx = pr[0] - Vx(projs_final[i]);\n\t    dy = pr[1] - Vy(projs_final[i]);\n\n\t    dist = dx * dx + dy * dy;\n\n\t    error += dist;\n\t}\n\t\n\tprintf(\"Old error: %0.3e\\n\", sqrt(error / max_inliers));\n\n\t/* Polish the result */\n\tif (max_inliers >= 6) {\n\t    int num_inliers_polished = 0;\n\t    find_projection_3x4_nonlinear(max_inliers, pts_final, projs_final,\n\t\t\t\t\t  Plinear, P);\n\n#if 1\n            /* Fix the sign on the P matrix */\n            memcpy(Rinit + 0, P + 0, 3 * sizeof(double));\n            memcpy(Rinit + 3, P + 4, 3 * sizeof(double));\n            memcpy(Rinit + 6, P + 8, 3 * sizeof(double));\n\n            dgerqf_driver(3, 3, Rinit, triangular, orthogonal);\t    \n            \n            /* Check the parity along the diagonal */\n            neg = \n                (triangular[0] < 0.0) + \n                (triangular[4] < 0.0) + \n                (triangular[8] < 0.0);\n\n            if ((neg % 2) == 1) {\n                sign = -1;\n            } else {\n                sign = 1;\n            }\n#endif\n\n            /* Check that the number of inliers hasn't gone down */\n\t    num_inliers_polished = 0;\n\t    for (i = 0; i < num_pts; i++) {\n\t\tdouble pt[4] = \n\t\t    { Vx(points[i]), Vy(points[i]), Vz(points[i]), 1.0 };\n\t\tdouble pr[3];\n\t\tdouble dx, dy, dist;\n\t    \n\t\tmatrix_product341(P, pt, pr);\n\n\t\tif (sign * pr[2] > 0.0)\n\t\t    continue;\n\n\t\tpr[0] /= -pr[2];\n\t\tpr[1] /= -pr[2];\n\t    \n\t\tdx = pr[0] - Vx(projs[i]);\n\t\tdy = pr[1] - Vy(projs[i]);\n\n\t\tdist = dx * dx + dy * dy;\n\n\t\tif (dist < thresh_sq) {\n\t\t    num_inliers_polished++;\n\t\t}\n\t    }\n\n\t    if (num_inliers_polished < max_inliers) {\n\t\tprintf(\"Decreased number of inliers (%d < %d), reverting\\n\",\n\t\t       num_inliers_polished, max_inliers);\n\n\t\tmemcpy(P, Plinear, sizeof(double) * 12);\t\t\n\t    }\n\t} else {\n\t    memcpy(P, Plinear, sizeof(double) * 12);\n\t}\n\n\tprintf(\"Best matrix (post-opt):\\n\");\n\tmatrix_print(3, 4, P);\n\n\terror = 0.0;\n\tfor (i = 0; i < max_inliers; i++) {\n\t    double pt[4] = \n\t\t{ Vx(pts_final[i]), Vy(pts_final[i]), Vz(pts_final[i]), 1.0 };\n\t    double pr[3];\n\t    double dx, dy, dist;\n\t    \n\t    matrix_product341(P, pt, pr);\n\n\t    pr[0] /= -pr[2];\n\t    pr[1] /= -pr[2];\n\t    \n\t    dx = pr[0] - Vx(projs_final[i]);\n\t    dy = pr[1] - Vy(projs_final[i]);\n\n\t    dist = dx * dx + dy * dy;\n\n\t    error += dist;\n\t}\n\t\n\tprintf(\"New error: %0.3e\\n\", sqrt(error / max_inliers));\n\n\tfree(inliers);\n\tfree(pts_final);\n\tfree(projs_final);\n\n\treturn max_inliers;\n    }\n#undef MIN_PTS\n}", "path": "bundler_sfm/lib/imagelib/triangulate.c", "commit_date": "2015-11-12 00:00:00", "repo_name": "snavely/bundler_sfm", "stars": 1507, "license": "None", "language": "c", "size": 6187}
{"docstring": "/* Solve for a 3x4 projection matrix, given a set of 3D points and 2D\n * projections using non-linear optimization */\n", "func_signal": "int find_projection_3x4_nonlinear(int num_pts, v3_t *points, v2_t *projs, \n\t\t\t\t  double *Pin, double *Pout)", "code": "{\n    if (num_pts < 6) {\n\tprintf(\"[find_projection_3x4_nonlinear] Need at least 6 points!\\n\");\n\treturn -1;\n    } else {\n\tint num_eqns = 2 * num_pts;\n\tint num_vars = 11;\n\tdouble x[11];\n\n\tglobal_num_pts = num_pts;\n\tglobal_points = points;\n\tglobal_projs = projs;\n\n\tmemcpy(x, Pin, sizeof(double) * 11);\n\tlmdif_driver(projection_residual, num_eqns, num_vars, x, 1.0e-5);\n\n\tmemcpy(Pout, x, sizeof(double) * 11);\n\tPout[11] = 1.0;\n\n\treturn 0;\n    }\n}", "path": "bundler_sfm/lib/imagelib/triangulate.c", "commit_date": "2015-11-12 00:00:00", "repo_name": "snavely/bundler_sfm", "stars": 1507, "license": "None", "language": "c", "size": 6187}
{"docstring": "/* Find the point with the smallest squared projection error */\n", "func_signal": "v3_t triangulate_n(int num_points, \n\t\t   v2_t *p, double *R, double *t, double *error_out)", "code": "{\n    int num_eqs = 2 * num_points;\n    int num_vars = 3;\n\n    double *A = (double *) malloc(sizeof(double) * num_eqs * num_vars);\n    double *b = (double *) malloc(sizeof(double) * num_eqs);\n    double *x = (double *) malloc(sizeof(double) * num_vars);\n\n    int i;\n    double error;\n\n    v3_t r;\n\n    for (i = 0; i < num_points; i++) {\n\tint Roff = 9 * i;\n\tint row = 6 * i;\n\tint brow = 2 * i;\n\tint toff = 3 * i;\n\n\tA[row + 0] = R[Roff + 0] - Vx(p[i]) * R[Roff + 6];  \n\tA[row + 1] = R[Roff + 1] - Vx(p[i]) * R[Roff + 7];  \n\tA[row + 2] = R[Roff + 2] - Vx(p[i]) * R[Roff + 8];\n\n\tA[row + 3] = R[Roff + 3] - Vy(p[i]) * R[Roff + 6];  \n\tA[row + 4] = R[Roff + 4] - Vy(p[i]) * R[Roff + 7];  \n\tA[row + 5] = R[Roff + 5] - Vy(p[i]) * R[Roff + 8];\n\n\tb[brow + 0] = t[toff + 2] * Vx(p[i]) - t[toff + 0];\n\tb[brow + 1] = t[toff + 2] * Vy(p[i]) - t[toff + 1];\n    }\n    \n    /* Find the least squares result */\n    dgelsy_driver(A, b, x, num_eqs, num_vars, 1);\n\n    error = 0.0;\n    for (i = 0; i < num_points; i++) {\n\tdouble dx, dy;\n\tint Roff = 9 * i;\n\tint toff = 3 * i;\n\tdouble pp[3];\n\n\t/* Compute projection error */\n\tmatrix_product331(R + Roff, x, pp);\n\tpp[0] += t[toff + 0];\n\tpp[1] += t[toff + 1];\n\tpp[2] += t[toff + 2];\n\n\tdx = pp[0] / pp[2] - Vx(p[i]);\n\tdy = pp[1] / pp[2] - Vy(p[i]);\n\terror += dx * dx + dy * dy;\n    }\n\n    error = sqrt(error / num_points);\n\n    // printf(\"[triangulate_n] Error [before polishing]: %0.3e\\n\", error);\n\n    /* Run a non-linear optimization to refine the result */\n    global_num_points = num_points;\n    global_ps = p;\n    global_Rs = R;  global_ts = t;\n    lmdif_driver(triangulate_n_residual, num_eqs, num_vars, x, 1.0e-5);\n\n    error = 0.0;\n    for (i = 0; i < num_points; i++) {\n\tdouble dx, dy;\n\tint Roff = 9 * i;\n\tint toff = 3 * i;\n\tdouble pp[3];\n\n\t/* Compute projection error */\n\tmatrix_product331(R + Roff, x, pp);\n\tpp[0] += t[toff + 0];\n\tpp[1] += t[toff + 1];\n\tpp[2] += t[toff + 2];\n\n\tdx = pp[0] / pp[2] - Vx(p[i]);\n\tdy = pp[1] / pp[2] - Vy(p[i]);\n\terror += dx * dx + dy * dy;\n    }\n\n    error = sqrt(error / num_points);\n\n    // printf(\"[triangulate_n] Error [after polishing]: %0.3e\\n\", error);\n\n    if (error_out != NULL) {\n\t*error_out = error;\n    }\n\n    r = v3_new(x[0], x[1], x[2]);\n\n    free(A);\n    free(b);\n    free(x);\n\n    return r;\n}", "path": "bundler_sfm/lib/imagelib/triangulate.c", "commit_date": "2015-11-12 00:00:00", "repo_name": "snavely/bundler_sfm", "stars": 1507, "license": "None", "language": "c", "size": 6187}
{"docstring": "/*\n * Determine whether block smoothing is applicable and safe.\n * We also latch the current states of the coef_bits[] entries for the\n * AC coefficients; otherwise, if the input side of the decompressor\n * advances into a new scan, we might think the coefficients are known\n * more accurately than they really are.\n */\n", "func_signal": "LOCAL(boolean)\nsmoothing_ok (j_decompress_ptr cinfo)", "code": "{\n  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;\n  boolean smoothing_useful = FALSE;\n  int ci, coefi;\n  jpeg_component_info *compptr;\n  JQUANT_TBL * qtable;\n  int * coef_bits;\n  int * coef_bits_latch;\n\n  if (! cinfo->progressive_mode || cinfo->coef_bits == NULL)\n    return FALSE;\n\n  /* Allocate latch area if not already done */\n  if (coef->coef_bits_latch == NULL)\n    coef->coef_bits_latch = (int *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n\t\t\t\t  cinfo->num_components *\n\t\t\t\t  (SAVED_COEFS * SIZEOF(int)));\n  coef_bits_latch = coef->coef_bits_latch;\n\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n       ci++, compptr++) {\n    /* All components' quantization values must already be latched. */\n    if ((qtable = compptr->quant_table) == NULL)\n      return FALSE;\n    /* Verify DC & first 5 AC quantizers are nonzero to avoid zero-divide. */\n    if (qtable->quantval[0] == 0 ||\n\tqtable->quantval[Q01_POS] == 0 ||\n\tqtable->quantval[Q10_POS] == 0 ||\n\tqtable->quantval[Q20_POS] == 0 ||\n\tqtable->quantval[Q11_POS] == 0 ||\n\tqtable->quantval[Q02_POS] == 0)\n      return FALSE;\n    /* DC values must be at least partly known for all components. */\n    coef_bits = cinfo->coef_bits[ci];\n    if (coef_bits[0] < 0)\n      return FALSE;\n    /* Block smoothing is helpful if some AC coefficients remain inaccurate. */\n    for (coefi = 1; coefi <= 5; coefi++) {\n      coef_bits_latch[coefi] = coef_bits[coefi];\n      if (coef_bits[coefi] != 0)\n\tsmoothing_useful = TRUE;\n    }\n    coef_bits_latch += SAVED_COEFS;\n  }\n\n  return smoothing_useful;\n}", "path": "bundler_sfm/lib/jpeg/src/jdcoefct.c", "commit_date": "2013-03-10 00:00:00", "repo_name": "snavely/bundler_sfm", "stars": 1507, "license": "None", "language": "c", "size": 6187}
{"docstring": "/* Find the point with the smallest squared projection error */\n", "func_signal": "v3_t triangulate_n_refine(v3_t pt, int num_points, \n\t\t\t  v2_t *p, double *R, double *t, double *error_out)", "code": "{\n    int num_eqs = 2 * num_points;\n    int num_vars = 3;\n\n    double x[3] = { Vx(pt), Vy(pt), Vz(pt) };\n    double error;\n\n    int i;\n\n    /* Run a non-linear optimization to polish the result */\n    global_num_points = num_points;\n    global_ps = p;\n    global_Rs = R;  global_ts = t;\n    lmdif_driver(triangulate_n_residual, num_eqs, num_vars, x, 1.0e-5);\n\n    error = 0.0;\n    for (i = 0; i < num_points; i++) {\n\tdouble dx, dy;\n\tint Roff = 9 * i;\n\tint toff = 3 * i;\n\tdouble pp[3];\n\n\t/* Compute projection error */\n\tmatrix_product331(R + Roff, x, pp);\n\tpp[0] += t[toff + 0];\n\tpp[1] += t[toff + 1];\n\tpp[2] += t[toff + 2];\n\n\tdx = pp[0] / pp[2] - Vx(p[i]);\n\tdy = pp[1] / pp[2] - Vy(p[i]);\n\terror += dx * dx + dy * dy;\n    }\n\n    error = sqrt(error / num_points);\n\n    // printf(\"[triangulate_n] Error [after polishing]: %0.3e\\n\", error);\n\n    if (error_out != NULL) {\n\t*error_out = error;\n    }\n\n    return v3_new(x[0], x[1], x[2]);\n}", "path": "bundler_sfm/lib/imagelib/triangulate.c", "commit_date": "2015-11-12 00:00:00", "repo_name": "snavely/bundler_sfm", "stars": 1507, "license": "None", "language": "c", "size": 6187}
{"docstring": "/*\n * Variant of decompress_data for use when doing block smoothing.\n */\n", "func_signal": "METHODDEF(int)\ndecompress_smooth_data (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)", "code": "{\n  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;\n  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;\n  JDIMENSION block_num, last_block_column;\n  int ci, block_row, block_rows, access_rows;\n  JBLOCKARRAY buffer;\n  JBLOCKROW buffer_ptr, prev_block_row, next_block_row;\n  JSAMPARRAY output_ptr;\n  JDIMENSION output_col;\n  jpeg_component_info *compptr;\n  inverse_DCT_method_ptr inverse_DCT;\n  boolean first_row, last_row;\n  JBLOCK workspace;\n  int *coef_bits;\n  JQUANT_TBL *quanttbl;\n  INT32 Q00,Q01,Q02,Q10,Q11,Q20, num;\n  int DC1,DC2,DC3,DC4,DC5,DC6,DC7,DC8,DC9;\n  int Al, pred;\n\n  /* Force some input to be done if we are getting ahead of the input. */\n  while (cinfo->input_scan_number <= cinfo->output_scan_number &&\n\t ! cinfo->inputctl->eoi_reached) {\n    if (cinfo->input_scan_number == cinfo->output_scan_number) {\n      /* If input is working on current scan, we ordinarily want it to\n       * have completed the current row.  But if input scan is DC,\n       * we want it to keep one row ahead so that next block row's DC\n       * values are up to date.\n       */\n      JDIMENSION delta = (cinfo->Ss == 0) ? 1 : 0;\n      if (cinfo->input_iMCU_row > cinfo->output_iMCU_row+delta)\n\tbreak;\n    }\n    if ((*cinfo->inputctl->consume_input)(cinfo) == JPEG_SUSPENDED)\n      return JPEG_SUSPENDED;\n  }\n\n  /* OK, output from the virtual arrays. */\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n       ci++, compptr++) {\n    /* Don't bother to IDCT an uninteresting component. */\n    if (! compptr->component_needed)\n      continue;\n    /* Count non-dummy DCT block rows in this iMCU row. */\n    if (cinfo->output_iMCU_row < last_iMCU_row) {\n      block_rows = compptr->v_samp_factor;\n      access_rows = block_rows * 2; /* this and next iMCU row */\n      last_row = FALSE;\n    } else {\n      /* NB: can't use last_row_height here; it is input-side-dependent! */\n      block_rows = (int) (compptr->height_in_blocks % compptr->v_samp_factor);\n      if (block_rows == 0) block_rows = compptr->v_samp_factor;\n      access_rows = block_rows; /* this iMCU row only */\n      last_row = TRUE;\n    }\n    /* Align the virtual buffer for this component. */\n    if (cinfo->output_iMCU_row > 0) {\n      access_rows += compptr->v_samp_factor; /* prior iMCU row too */\n      buffer = (*cinfo->mem->access_virt_barray)\n\t((j_common_ptr) cinfo, coef->whole_image[ci],\n\t (cinfo->output_iMCU_row - 1) * compptr->v_samp_factor,\n\t (JDIMENSION) access_rows, FALSE);\n      buffer += compptr->v_samp_factor;\t/* point to current iMCU row */\n      first_row = FALSE;\n    } else {\n      buffer = (*cinfo->mem->access_virt_barray)\n\t((j_common_ptr) cinfo, coef->whole_image[ci],\n\t (JDIMENSION) 0, (JDIMENSION) access_rows, FALSE);\n      first_row = TRUE;\n    }\n    /* Fetch component-dependent info */\n    coef_bits = coef->coef_bits_latch + (ci * SAVED_COEFS);\n    quanttbl = compptr->quant_table;\n    Q00 = quanttbl->quantval[0];\n    Q01 = quanttbl->quantval[Q01_POS];\n    Q10 = quanttbl->quantval[Q10_POS];\n    Q20 = quanttbl->quantval[Q20_POS];\n    Q11 = quanttbl->quantval[Q11_POS];\n    Q02 = quanttbl->quantval[Q02_POS];\n    inverse_DCT = cinfo->idct->inverse_DCT[ci];\n    output_ptr = output_buf[ci];\n    /* Loop over all DCT blocks to be processed. */\n    for (block_row = 0; block_row < block_rows; block_row++) {\n      buffer_ptr = buffer[block_row];\n      if (first_row && block_row == 0)\n\tprev_block_row = buffer_ptr;\n      else\n\tprev_block_row = buffer[block_row-1];\n      if (last_row && block_row == block_rows-1)\n\tnext_block_row = buffer_ptr;\n      else\n\tnext_block_row = buffer[block_row+1];\n      /* We fetch the surrounding DC values using a sliding-register approach.\n       * Initialize all nine here so as to do the right thing on narrow pics.\n       */\n      DC1 = DC2 = DC3 = (int) prev_block_row[0][0];\n      DC4 = DC5 = DC6 = (int) buffer_ptr[0][0];\n      DC7 = DC8 = DC9 = (int) next_block_row[0][0];\n      output_col = 0;\n      last_block_column = compptr->width_in_blocks - 1;\n      for (block_num = 0; block_num <= last_block_column; block_num++) {\n\t/* Fetch current DCT block into workspace so we can modify it. */\n\tjcopy_block_row(buffer_ptr, (JBLOCKROW) workspace, (JDIMENSION) 1);\n\t/* Update DC values */\n\tif (block_num < last_block_column) {\n\t  DC3 = (int) prev_block_row[1][0];\n\t  DC6 = (int) buffer_ptr[1][0];\n\t  DC9 = (int) next_block_row[1][0];\n\t}\n\t/* Compute coefficient estimates per K.8.\n\t * An estimate is applied only if coefficient is still zero,\n\t * and is not known to be fully accurate.\n\t */\n\t/* AC01 */\n\tif ((Al=coef_bits[1]) != 0 && workspace[1] == 0) {\n\t  num = 36 * Q00 * (DC4 - DC6);\n\t  if (num >= 0) {\n\t    pred = (int) (((Q01<<7) + num) / (Q01<<8));\n\t    if (Al > 0 && pred >= (1<<Al))\n\t      pred = (1<<Al)-1;\n\t  } else {\n\t    pred = (int) (((Q01<<7) - num) / (Q01<<8));\n\t    if (Al > 0 && pred >= (1<<Al))\n\t      pred = (1<<Al)-1;\n\t    pred = -pred;\n\t  }\n\t  workspace[1] = (JCOEF) pred;\n\t}\n\t/* AC10 */\n\tif ((Al=coef_bits[2]) != 0 && workspace[8] == 0) {\n\t  num = 36 * Q00 * (DC2 - DC8);\n\t  if (num >= 0) {\n\t    pred = (int) (((Q10<<7) + num) / (Q10<<8));\n\t    if (Al > 0 && pred >= (1<<Al))\n\t      pred = (1<<Al)-1;\n\t  } else {\n\t    pred = (int) (((Q10<<7) - num) / (Q10<<8));\n\t    if (Al > 0 && pred >= (1<<Al))\n\t      pred = (1<<Al)-1;\n\t    pred = -pred;\n\t  }\n\t  workspace[8] = (JCOEF) pred;\n\t}\n\t/* AC20 */\n\tif ((Al=coef_bits[3]) != 0 && workspace[16] == 0) {\n\t  num = 9 * Q00 * (DC2 + DC8 - 2*DC5);\n\t  if (num >= 0) {\n\t    pred = (int) (((Q20<<7) + num) / (Q20<<8));\n\t    if (Al > 0 && pred >= (1<<Al))\n\t      pred = (1<<Al)-1;\n\t  } else {\n\t    pred = (int) (((Q20<<7) - num) / (Q20<<8));\n\t    if (Al > 0 && pred >= (1<<Al))\n\t      pred = (1<<Al)-1;\n\t    pred = -pred;\n\t  }\n\t  workspace[16] = (JCOEF) pred;\n\t}\n\t/* AC11 */\n\tif ((Al=coef_bits[4]) != 0 && workspace[9] == 0) {\n\t  num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);\n\t  if (num >= 0) {\n\t    pred = (int) (((Q11<<7) + num) / (Q11<<8));\n\t    if (Al > 0 && pred >= (1<<Al))\n\t      pred = (1<<Al)-1;\n\t  } else {\n\t    pred = (int) (((Q11<<7) - num) / (Q11<<8));\n\t    if (Al > 0 && pred >= (1<<Al))\n\t      pred = (1<<Al)-1;\n\t    pred = -pred;\n\t  }\n\t  workspace[9] = (JCOEF) pred;\n\t}\n\t/* AC02 */\n\tif ((Al=coef_bits[5]) != 0 && workspace[2] == 0) {\n\t  num = 9 * Q00 * (DC4 + DC6 - 2*DC5);\n\t  if (num >= 0) {\n\t    pred = (int) (((Q02<<7) + num) / (Q02<<8));\n\t    if (Al > 0 && pred >= (1<<Al))\n\t      pred = (1<<Al)-1;\n\t  } else {\n\t    pred = (int) (((Q02<<7) - num) / (Q02<<8));\n\t    if (Al > 0 && pred >= (1<<Al))\n\t      pred = (1<<Al)-1;\n\t    pred = -pred;\n\t  }\n\t  workspace[2] = (JCOEF) pred;\n\t}\n\t/* OK, do the IDCT */\n\t(*inverse_DCT) (cinfo, compptr, (JCOEFPTR) workspace,\n\t\t\toutput_ptr, output_col);\n\t/* Advance for next column */\n\tDC1 = DC2; DC2 = DC3;\n\tDC4 = DC5; DC5 = DC6;\n\tDC7 = DC8; DC8 = DC9;\n\tbuffer_ptr++, prev_block_row++, next_block_row++;\n\toutput_col += compptr->DCT_scaled_size;\n      }\n      output_ptr += compptr->DCT_scaled_size;\n    }\n  }\n\n  if (++(cinfo->output_iMCU_row) < cinfo->total_iMCU_rows)\n    return JPEG_ROW_COMPLETED;\n  return JPEG_SCAN_COMPLETED;\n}", "path": "bundler_sfm/lib/jpeg/src/jdcoefct.c", "commit_date": "2013-03-10 00:00:00", "repo_name": "snavely/bundler_sfm", "stars": 1507, "license": "None", "language": "c", "size": 6187}
{"docstring": "/*\n * This callback is called for each string in the provided environment vector.\n * The string is inserted into the provided strlist, replacing any existing\n * list entry with the same variable name.\n */\n", "func_signal": "void\ncbEachEnvEntry(const char *array_name __unused, unsigned int idx\n  __unused, const char *val, void *arg0, void *arg1 __unused)", "code": "{\n    strlist_t *env = arg0;\n    char *env_name = NULL;\n    char *env_val = NULL;\n\n    if (splitEnvEntry(val, &env_name, &env_val) == ENV_IGNORE_ENTRY) {\n        return;\n    }\n\n    insertOrReplaceEnv(env, env_name, env_val);\n\n    free(env_name);\n    free(env_val);\n}", "path": "smartos-live/src/dockerinit/src/docker-common.c", "commit_date": "2017-08-31 00:00:00", "repo_name": "TritonDataCenter/smartos-live", "stars": 1540, "license": "None", "language": "c", "size": 51023}
{"docstring": "/* returns 0 on success and -1 on failure */\n", "func_signal": "static PyObject*\njsnode_to_pynode(JSContext* context, JSParseNode* jsnode)", "code": "{\n    JSContextData* data = JS_GetContextPrivate(context);\n    PyObject* pynode = NULL;\n    PyObject* kids = NULL;\n    JSTokenPtr tokenptr;\n\n    /* TODO: make sure no tuple item already exists */\n\n    if (!jsnode) {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n\n    /* pass in a dictionary of options */\n    pynode = PyInstance_New(data->node_class, NULL, NULL);\n    if (!pynode)\n        goto fail;\n\n    Py_INCREF(Py_None);\n    if (PyObject_SetAttrString(pynode, \"parent\", Py_None) == -1)\n        goto fail;\n    Py_INCREF(Py_None);\n    if (PyObject_SetAttrString(pynode, \"node_index\", Py_None) == -1)\n        goto fail;\n    if (PyObject_SetAttrString(pynode, \"kind\", Py_BuildValue(\"i\", TOK_TO_NUM(jsnode->pn_type))) == -1)\n        goto fail;\n\n    /* pass the position */\n    tokenptr = to_pyjsl_pos(data, jsnode->pn_pos.begin);\n    if (PyObject_SetAttrString(pynode, \"_start_line\", Py_BuildValue(\"i\", tokenptr.lineno)) == -1)\n        goto fail;\n    if (PyObject_SetAttrString(pynode, \"_start_col\", Py_BuildValue(\"i\", tokenptr.index)) == -1)\n        goto fail;\n    tokenptr = to_pyjsl_pos(data, jsnode->pn_pos.end);\n    if (PyObject_SetAttrString(pynode, \"_end_line\", Py_BuildValue(\"i\", tokenptr.lineno)) == -1)\n        goto fail;\n    if (PyObject_SetAttrString(pynode, \"_end_col\", Py_BuildValue(\"i\", tokenptr.index)) == -1)\n        goto fail;\n\n    if ((jsnode->pn_type == TOK_NAME || jsnode->pn_type == TOK_DOT ||\n        jsnode->pn_type == TOK_STRING) && ATOM_IS_STRING(jsnode->pn_atom)) {\n        /* Convert the atom to a string. */\n        if (PyObject_SetAttrString(pynode, \"atom\", atom_to_string(jsnode->pn_atom)) == -1)\n            goto fail;\n    }\n\n    if (PyObject_SetAttrString(pynode, \"opcode\", Py_BuildValue(\"i\", OPCODE_TO_NUM(jsnode->pn_op))) == -1)\n        goto fail;\n\n    if (jsnode->pn_type == TOK_NUMBER) {\n        if (PyObject_SetAttrString(pynode, \"dval\", Py_BuildValue(\"d\", jsnode->pn_dval)) == -1)\n            goto fail;\n    }\n\n    if (jsnode->pn_type == TOK_FUNCTION) {\n        JSObject* object = ATOM_TO_OBJECT(jsnode->pn_funAtom);\n        JSFunction* function = (JSFunction *) JS_GetPrivate(context, object);\n        JSScope* scope = OBJ_SCOPE(object);\n        JSScopeProperty* scope_property;\n        PyObject* fn_name;\n        PyObject* fn_args;\n        uint32 i;\n        JSPropertyDescArray props = {0, NULL};\n\n        /* get the function name */\n        if (function->atom) {\n            fn_name = atom_to_string(function->atom);\n        }\n        else {\n            Py_INCREF(Py_None);\n            fn_name = Py_None;\n        }\n        if (PyObject_SetAttrString(pynode, \"fn_name\", fn_name) == -1)\n            goto fail;\n\n        /* get the function arguments */\n        if (!JS_GetPropertyDescArray(context, object, &props))\n            props.length = 0;\n\n        fn_args = PyTuple_New(function->nargs);\n        for (i = 0; i < props.length; i++) {\n            PyObject* name;\n            if ((props.array[i].flags & JSPD_ARGUMENT) == 0)\n                continue;\n            name = jsstring_to_py(JSVAL_TO_STRING(props.array[i].id));\n            PyTuple_SET_ITEM(fn_args, props.array[i].slot, name);\n        }\n\n        /* Duplicate parameters are not included in the desc array. Go back and add them in. */\n        for (scope_property = SCOPE_LAST_PROP(scope);\n            scope_property != NULL;\n            scope_property = scope_property->parent) {\n            PyObject* name;\n\n            if ((scope_property->flags & SPROP_IS_DUPLICATE) == 0)\n                continue;\n            if (PyTuple_GET_ITEM(fn_args, scope_property->shortid) != NULL)\n                continue;\n\n            name = atom_to_string(JSID_TO_ATOM(scope_property->id));\n            PyTuple_SET_ITEM(fn_args, (uint16)scope_property->shortid, name);\n        }\n        if (PyObject_SetAttrString(pynode, \"fn_args\", fn_args) == -1)\n            goto fail;\n    }\n    else if (jsnode->pn_type == TOK_RB) {\n        PyObject* end_comma = PyBool_FromLong(jsnode->pn_extra & PNX_ENDCOMMA);\n        if (PyObject_SetAttrString(pynode, \"end_comma\", end_comma) == -1)\n            goto fail;\n    }\n\n    if (PyObject_SetAttrString(pynode, \"no_semi\", PyBool_FromLong(jsnode->pn_no_semi)) == -1)\n        goto fail;\n\n    switch (jsnode->pn_arity) {\n    case PN_FUNC:\n        kids = PyTuple_New(1);\n        PyTuple_SET_ITEM(kids, 0, jsnode_to_pynode(context, jsnode->pn_body));\n        break;\n\n    case PN_LIST: {\n        JSParseNode* p;\n        int i;\n        kids = PyTuple_New(jsnode->pn_count);\n        for (i = 0, p = jsnode->pn_head; p; p = p->pn_next, i++) {\n            PyTuple_SET_ITEM(kids, i, jsnode_to_pynode(context, p));\n        }\n    }\n    break;\n\n    case PN_TERNARY:\n        kids = PyTuple_New(3);\n        PyTuple_SET_ITEM(kids, 0, jsnode_to_pynode(context, jsnode->pn_kid1));\n        PyTuple_SET_ITEM(kids, 1, jsnode_to_pynode(context, jsnode->pn_kid2));\n        PyTuple_SET_ITEM(kids, 2, jsnode_to_pynode(context, jsnode->pn_kid3));\n        break;\n\n    case PN_BINARY:\n        kids = PyTuple_New(2);\n        PyTuple_SET_ITEM(kids, 0, jsnode_to_pynode(context, jsnode->pn_left));\n        PyTuple_SET_ITEM(kids, 1, jsnode_to_pynode(context, jsnode->pn_right));\n        break;\n\n    case PN_UNARY:\n        kids = PyTuple_New(1);\n        PyTuple_SET_ITEM(kids, 0, jsnode_to_pynode(context, jsnode->pn_kid));\n        break;\n\n    case PN_NAME:\n        kids = PyTuple_New(1);\n        PyTuple_SET_ITEM(kids, 0, jsnode_to_pynode(context, jsnode->pn_expr));\n        break;\n\n    case PN_NULLARY:\n        kids = PyTuple_New(0);\n        break;\n    }\n\n    if (!kids)\n        goto fail;\n\n    if (PyObject_SetAttrString(pynode, \"kids\", kids) == -1)\n        goto fail;\n\n    {\n        int i;\n        for (i = 0; i < PyTuple_GET_SIZE(kids); i++) {\n            PyObject* kid = PyTuple_GET_ITEM(kids, i);\n            if (!kid)\n                goto fail;\n            if (kid == Py_None)\n                continue;\n\n            Py_INCREF(pynode);\n            if (PyObject_SetAttrString(kid, \"parent\", pynode) == -1)\n                goto fail;\n            if (PyObject_SetAttrString(kid, \"node_index\", Py_BuildValue(\"i\", i)) == -1)\n                goto fail;\n        }\n    }\n\n    return pynode;\n\nfail:\n    if (pynode) {\n        Py_XDECREF(pynode);\n    }\n    return NULL;\n}", "path": "smartos-live/tools/javascriptlint/javascriptlint/pyspidermonkey/pyspidermonkey.c", "commit_date": "2012-02-17 00:00:00", "repo_name": "TritonDataCenter/smartos-live", "stars": 1540, "license": "None", "language": "c", "size": 51023}
{"docstring": "/*\n * Load the PATH environment variable from this environment, or if PATH is not\n * set, load the default.  Split the value, on each delimiting colon, into an\n * ordered list of search directories.  If a search directory is not fully\n * qualified, that directory will be appended to the provided \"working\n * directory\".\n */\n", "func_signal": "static int\ngetPathList(strlist_t *env, strlist_t *path, const char *working_directory)", "code": "{\n    char *r = NULL;\n    boolean_t dofree = B_TRUE;\n    custr_t *cu = NULL;\n    custr_t *searchdir = NULL;\n\n    if (custr_alloc(&cu) != 0 || custr_alloc(&searchdir) != 0) {\n        fatal(ERR_NO_MEMORY, \"custr_alloc failure\");\n    }\n\n    /*\n     * Check environment array for PATH value.\n     */\n    for (unsigned int idx = 0; strlist_get(env, idx) != NULL; idx++) {\n        char *sname;\n        char *svalue;\n\n        if (splitEnvEntry(strlist_get(env, idx), &sname, &svalue)\n\t    == ENV_IGNORE_ENTRY) {\n            continue;\n        }\n        if (strcmp(sname, \"PATH\") != 0) {\n            free(sname);\n            free(svalue);\n            continue;\n        }\n\n        free(sname);\n        r = svalue;\n        break;\n    }\n\n    /*\n     * If no PATH was found, fall back to the default:\n     */\n    if (r == NULL) {\n        r = DEFAULT_PATH;\n        dofree = B_FALSE;\n    }\n\n    /*\n     * Parse PATH (i.e., split on \":\" characters).\n     */\n    for (unsigned int i = 0; ; i++) {\n        char c = r[i];\n        if (c != ':' && c != '\\0') {\n            /*\n             * This is neither the end of an element of the colon-separated\n             * PATH list, nor the end of the entire list.  Save the character\n             * in the working buffer.\n             */\n            if (custr_appendc(cu, c) != 0) {\n                fatal(ERR_NO_MEMORY, \"custr_appendc failure\");\n            }\n            continue;\n        }\n\n        /*\n         * All paths must be fully-qualified, so start from \"/\".\n         */\n        custr_reset(searchdir);\n        if (strpath_append(searchdir, \"/\") != 0) {\n            fatal(ERR_NO_MEMORY, \"strpath_append failure\");\n        }\n\n        if (custr_len(cu) < 1 || custr_cstr(cu)[0] != '/') {\n            /*\n             * This path is not fully-qualified, or is the empty string.\n             * Prepend the working directory.\n             */\n            if (strpath_append(searchdir, working_directory) != 0) {\n                fatal(ERR_NO_MEMORY, \"strpath_append failure\");\n            }\n        }\n\n        if (custr_len(cu) > 0) {\n            /*\n             * Append the remainder of the path.\n             */\n            if (strpath_append(searchdir, custr_cstr(cu)) != 0) {\n                fatal(ERR_NO_MEMORY, \"strpath_append failure\");\n            }\n        }\n        custr_reset(cu);\n\n        /*\n         * Store the path in the list.\n         */\n        if (strlist_set_tail(path, custr_cstr(searchdir)) != 0) {\n            fatal(ERR_NO_MEMORY, \"strlist_set_tail failure\");\n        }\n\n        if (c == '\\0') {\n            break;\n        }\n    }\n\n    free(dofree ? r : NULL);\n    custr_free(cu);\n    custr_free(searchdir);\n    return (0);\n}", "path": "smartos-live/src/dockerinit/src/docker-common.c", "commit_date": "2017-08-31 00:00:00", "repo_name": "TritonDataCenter/smartos-live", "stars": 1540, "license": "None", "language": "c", "size": 51023}
{"docstring": "/* Try to work around apparent _copysign bustage in VC6 and VC7. */\n", "func_signal": "double\njs_copysign(double x, double y)", "code": "{\n    jsdpun xu, yu;\n\n    xu.d = x;\n    yu.d = y;\n    xu.s.hi &= ~JSDOUBLE_HI32_SIGNBIT;\n    xu.s.hi |= yu.s.hi & JSDOUBLE_HI32_SIGNBIT;\n    return xu.d;\n}", "path": "smartos-live/tools/javascriptlint/spidermonkey/src/jsmath.c", "commit_date": "2012-02-17 00:00:00", "repo_name": "TritonDataCenter/smartos-live", "stars": 1540, "license": "None", "language": "c", "size": 51023}
{"docstring": "/*\n * Called for each entry in the CMD and ENTRYPOINT arrays.  Copies the string\n * into the next available slot in the combined command string list.\n */\n", "func_signal": "void\ncbEachCmdEntry(const char *array_name __unused, unsigned int idx\n  __unused, const char *val, void *arg0, void *arg1)", "code": "{\n    strlist_t *cmdline = arg0;\n    const char *typ = arg1;\n\n    if (strlist_set_tail(cmdline, val) != 0) {\n        fatal(ERR_NO_MEMORY, \"strlist failure: %s\\n\", strerror(errno));\n    }\n\n    dlog(\"ARGV[%u]:%s \\\"%s\\\"\\n\", strlist_contig_count(cmdline) - 1, typ, val);\n}", "path": "smartos-live/src/dockerinit/src/docker-common.c", "commit_date": "2017-08-31 00:00:00", "repo_name": "TritonDataCenter/smartos-live", "stars": 1540, "license": "None", "language": "c", "size": 51023}
{"docstring": "/*\n * Split env inout \"foo=bar\" into separate name \"foo\" and value \"bar\" strings.\n *\n * Returns ENV_OK on success, or returns ENV_IGNORE_ENTRY if the env variable\n * is bogus and should be ignored.\n */\n", "func_signal": "static env_split_result\nsplitEnvEntry(const char *input, char **name, char **value)", "code": "{\n    const char *eq;\n\n    /*\n     * Everything before the first equals (\"=\") is the environment variable\n     * name.  Determine the length of the name:\n     */\n    if ((eq = strchr(input, '=')) == NULL || eq == input) {\n        dlog(\"WARN ignoring empty env var %s\\n\", input);\n        return (ENV_IGNORE_ENTRY);\n    }\n\n    /*\n     * Copy out the name string.\n     */\n    if (name != NULL && (*name = strndup(input, eq - input)) == NULL) {\n        fatal(ERR_STRDUP, \"strdup failure: %s\\n\", strerror(errno));\n    }\n\n    /*\n     * Copy out the value string.\n     */\n    if (value != NULL && (*value = strdup(eq + 1)) == NULL) {\n        fatal(ERR_STRDUP, \"strdup failure: %s\\n\", strerror(errno));\n    }\n\n    return (ENV_OK);\n}", "path": "smartos-live/src/dockerinit/src/docker-common.c", "commit_date": "2017-08-31 00:00:00", "repo_name": "TritonDataCenter/smartos-live", "stars": 1540, "license": "None", "language": "c", "size": 51023}
{"docstring": "/*\n * basic time calculation functionality for localtime and gmtime\n * setups up prtm argument with correct values based upon input number\n * of seconds.\n */\n", "func_signal": "static void\nPRMJ_basetime(JSInt64 tsecs, PRMJTime *prtm)", "code": "{\n    /* convert tsecs back to year,month,day,hour,secs */\n    JSInt32 year    = 0;\n    JSInt32 month   = 0;\n    JSInt32 yday    = 0;\n    JSInt32 mday    = 0;\n    JSInt32 wday    = 6; /* start on a Sunday */\n    JSInt32 days    = 0;\n    JSInt32 seconds = 0;\n    JSInt32 minutes = 0;\n    JSInt32 hours   = 0;\n    JSInt32 isleap  = 0;\n    JSInt64 result;\n    JSInt64\tresult1;\n    JSInt64\tresult2;\n    JSInt64 base;\n\n    JSLL_UI2L(result,0);\n    JSLL_UI2L(result1,0);\n    JSLL_UI2L(result2,0);\n\n    /* get the base time via UTC */\n    base = PRMJ_ToExtendedTime(0);\n    JSLL_UI2L(result,  PRMJ_USEC_PER_SEC);\n    JSLL_DIV(base,base,result);\n    JSLL_ADD(tsecs,tsecs,base);\n\n    JSLL_UI2L(result, PRMJ_YEAR_SECONDS);\n    JSLL_UI2L(result1,PRMJ_DAY_SECONDS);\n    JSLL_ADD(result2,result,result1);\n\n    /* get the year */\n    while ((isleap == 0) ? !JSLL_CMP(tsecs,<,result) : !JSLL_CMP(tsecs,<,result2)) {\n        /* subtract a year from tsecs */\n        JSLL_SUB(tsecs,tsecs,result);\n        days += 365;\n        /* is it a leap year ? */\n        if(IS_LEAP(year)){\n            JSLL_SUB(tsecs,tsecs,result1);\n            days++;\n        }\n        year++;\n        isleap = IS_LEAP(year);\n    }\n\n    JSLL_UI2L(result1,PRMJ_DAY_SECONDS);\n\n    JSLL_DIV(result,tsecs,result1);\n    JSLL_L2I(mday,result);\n\n    /* let's find the month */\n    while(((month == 1 && isleap) ?\n            (mday >= mtab[month] + 1) :\n            (mday >= mtab[month]))){\n\t yday += mtab[month];\n\t days += mtab[month];\n\n\t mday -= mtab[month];\n\n         /* it's a Feb, check if this is a leap year */\n\t if(month == 1 && isleap != 0){\n\t     yday++;\n\t     days++;\n\t     mday--;\n\t }\n\t month++;\n    }\n\n    /* now adjust tsecs */\n    JSLL_MUL(result,result,result1);\n    JSLL_SUB(tsecs,tsecs,result);\n\n    mday++; /* day of month always start with 1 */\n    days += mday;\n    wday = (days + wday) % 7;\n\n    yday += mday;\n\n    /* get the hours */\n    JSLL_UI2L(result1,PRMJ_HOUR_SECONDS);\n    JSLL_DIV(result,tsecs,result1);\n    JSLL_L2I(hours,result);\n    JSLL_MUL(result,result,result1);\n    JSLL_SUB(tsecs,tsecs,result);\n\n    /* get minutes */\n    JSLL_UI2L(result1,60);\n    JSLL_DIV(result,tsecs,result1);\n    JSLL_L2I(minutes,result);\n    JSLL_MUL(result,result,result1);\n    JSLL_SUB(tsecs,tsecs,result);\n\n    JSLL_L2I(seconds,tsecs);\n\n    prtm->tm_usec  = 0L;\n    prtm->tm_sec   = (JSInt8)seconds;\n    prtm->tm_min   = (JSInt8)minutes;\n    prtm->tm_hour  = (JSInt8)hours;\n    prtm->tm_mday  = (JSInt8)mday;\n    prtm->tm_mon   = (JSInt8)month;\n    prtm->tm_wday  = (JSInt8)wday;\n    prtm->tm_year  = (JSInt16)year;\n    prtm->tm_yday  = (JSInt16)yday;\n}", "path": "smartos-live/tools/javascriptlint/spidermonkey/src/prmjtime.c", "commit_date": "2012-02-17 00:00:00", "repo_name": "TritonDataCenter/smartos-live", "stars": 1540, "license": "None", "language": "c", "size": 51023}
{"docstring": "/*\n * get the difference in seconds between this time zone and UTC (GMT)\n */\n", "func_signal": "JSInt32\nPRMJ_LocalGMTDifference()", "code": "{\n#if defined(XP_UNIX) || defined(XP_WIN) || defined(XP_OS2) || defined(XP_BEOS)\n    struct tm ltime;\n\n    /* get the difference between this time zone and GMT */\n    memset((char *)&ltime,0,sizeof(ltime));\n    ltime.tm_mday = 2;\n    ltime.tm_year = 70;\n#ifdef SUNOS4\n    ltime.tm_zone = 0;\n    ltime.tm_gmtoff = 0;\n    return timelocal(&ltime) - (24 * 3600);\n#else\n    return mktime(&ltime) - (24L * 3600L);\n#endif\n#endif\n}", "path": "smartos-live/tools/javascriptlint/spidermonkey/src/prmjtime.c", "commit_date": "2012-02-17 00:00:00", "repo_name": "TritonDataCenter/smartos-live", "stars": 1540, "license": "None", "language": "c", "size": 51023}
{"docstring": "/*\n * This expects 'docker:user' to be one of:\n *\n *  \"<uid>\"\n *  \"<uid>:<gid>\"\n *  \"<user>\"\n *  \"<user>:<group>\"\n *\n * And if 'docker:user' is not set at all, will behave as though it were set to\n * \"0\".\n *\n * The user will be looked up against the /etc/passwd file and if a group is\n * specified, that group will be looked up (stored in global 'grp'). If no group\n * is specified, the user's default group will be used (from pwd.pw_gid).\n */\n", "func_signal": "void\ngetUserGroupData()", "code": "{\n    char *endptr;\n    char *separator = \":\";\n    char *token;\n    char *user;\n    char *user_orig;\n    long long int lli;\n    char *group;\n    boolean_t do_free = B_TRUE;\n\n    if ((user = mdataGet(\"docker:user\")) == NULL) {\n        /* default to root */\n        user = \"0\";\n        do_free = B_FALSE;\n    }\n    user_orig = strdup(user);\n    if (user_orig == NULL) {\n        fatal(ERR_STRDUP, \"failed to strdup(%s): %s\\n\", user, strerror(errno));\n    }\n\n    token = strtok(user, separator);\n    if ((token != NULL) && (user_orig[strlen(token)] == ':'))  {\n        user = token;\n        group = user_orig + (strlen(token) + 1); /* skip past ':' */\n\n        grp = getgrnam(group);\n        if (grp == NULL) {\n            /* The `group` field can be a number. */\n            lli = strtoll(group, &endptr, 10);\n            if (endptr != NULL && endptr[0] == '\\0') { /* entire string valid */\n                grp = getgrgid((gid_t) lli);\n            } else {\n                fatal(ERR_GID_NAN, \"GID is not a number: %s\\n\", group);\n            }\n        }\n        dlog(\"SPLIT user: '%s' group: '%s'\\n\", user, group);\n    }\n\n    pwd = getpwnam(user);\n    if (pwd == NULL) {\n        endptr = NULL;\n        /* The `user` field can be a number. */\n        lli = strtoll(user, &endptr, 10);\n        if (endptr != NULL && endptr[0] == '\\0') { /* entire string valid */\n            pwd = getpwuid((uid_t) lli);\n        } else {\n            fatal(ERR_UID_NAN, \"UID is not a number: %s\\n\", user);\n        }\n    }\n\n    if (pwd != NULL) {\n        dlog(\"INFO passwd.pw_name: %s\\n\", pwd->pw_name);\n        dlog(\"INFO passwd.pw_uid: %u\\n\", pwd->pw_uid);\n        dlog(\"INFO passwd.pw_gid: %u\\n\", pwd->pw_gid);\n        dlog(\"INFO passwd.pw_dir: %s\\n\", pwd->pw_dir);\n    }\n\n    if (grp == NULL && pwd != NULL) {\n        grp = getgrgid(pwd->pw_gid);\n    }\n\n    if (grp != NULL) {\n        dlog(\"INFO group.gr_name: %s\\n\", grp->gr_name);\n        dlog(\"INFO group.gr_gid: %u\\n\", grp->gr_gid);\n    }\n\n    if (do_free) {\n        free(user);\n    }\n}", "path": "smartos-live/src/dockerinit/src/docker-common.c", "commit_date": "2017-08-31 00:00:00", "repo_name": "TritonDataCenter/smartos-live", "stars": 1540, "license": "None", "language": "c", "size": 51023}
{"docstring": "/*\n * Math.random() support, lifted from java.util.Random.java.\n */\n", "func_signal": "static void\nrandom_setSeed(JSRuntime *rt, int64 seed)", "code": "{\n    int64 tmp;\n\n    JSLL_I2L(tmp, 1000);\n    JSLL_DIV(seed, seed, tmp);\n    JSLL_XOR(tmp, seed, rt->rngMultiplier);\n    JSLL_AND(rt->rngSeed, tmp, rt->rngMask);\n}", "path": "smartos-live/tools/javascriptlint/spidermonkey/src/jsmath.c", "commit_date": "2012-02-17 00:00:00", "repo_name": "TritonDataCenter/smartos-live", "stars": 1540, "license": "None", "language": "c", "size": 51023}
{"docstring": "/*\n * Contact the hypervisor metadata agent and request the value for the provided\n * key name.  Returns a C string if a value is found, NULL if no value is\n * found, or aborts the program on any other condition.  The caller is expected\n * to call free(3C) on the returned string.\n */\n", "func_signal": "char *\nmdataGet(const char *keyname)", "code": "{\n    char *errmsg = NULL;\n    string_t *mdata = NULL;\n    mdata_response_t mdr;\n    char *out;\n\n    if (initialized_proto == 0) {\n        if (proto_init(&mdp, &errmsg) != 0) {\n            fatal(ERR_MDATA_INIT, \"could not initialize metadata: %s\\n\",\n                errmsg);\n        }\n        initialized_proto = 1;\n    }\n\n    if (proto_execute(mdp, \"GET\", keyname, &mdr, &mdata) != 0) {\n        fatal(ERR_UNEXPECTED, \"failed to get metadata for '%s': unknown \"\n          \"error\\n\", keyname);\n    }\n\n    switch (mdr) {\n    case MDR_SUCCESS:\n        if ((out = strdup(dynstr_cstr(mdata))) == NULL) {\n            fatal(ERR_STRDUP, \"strdup failure\\n\");\n        }\n        dynstr_free(mdata);\n        dlog(\"MDATA %s=%s\\n\", keyname, out);\n        return (out);\n\n    case MDR_NOTFOUND:\n        dlog(\"INFO no metadata for '%s'\\n\", keyname);\n        dynstr_free(mdata);\n        return (NULL);\n\n    case MDR_UNKNOWN:\n        fatal(ERR_MDATA_FAIL, \"failed to get metadata for '%s': %s\\n\",\n            keyname, dynstr_cstr(mdata));\n        break;\n\n    case MDR_INVALID_COMMAND:\n        fatal(ERR_MDATA_FAIL, \"failed to get metadata for '%s': %s\\n\",\n            keyname, \"host does not support GET\");\n        break;\n\n    default:\n        fatal(ERR_UNEXPECTED, \"GET[%s]: unknown response\\n\", keyname);\n        break;\n    }\n\n    /* NOTREACHED */\n    abort();\n    return (NULL);\n}", "path": "smartos-live/src/dockerinit/src/docker-common.c", "commit_date": "2017-08-31 00:00:00", "repo_name": "TritonDataCenter/smartos-live", "stars": 1540, "license": "None", "language": "c", "size": 51023}
{"docstring": "/* JS_HAS_XML_SUPPORT */\n", "func_signal": "JSTokenType\njs_PeekToken(JSContext *cx, JSTokenStream *ts)", "code": "{\n    JSTokenType tt;\n\n    if (ts->lookahead != 0) {\n        tt = ts->tokens[(ts->cursor + ts->lookahead) & NTOKENS_MASK].type;\n    } else {\n        tt = js_GetToken(cx, ts);\n        js_UngetToken(ts);\n    }\n    return tt;\n}", "path": "smartos-live/tools/javascriptlint/spidermonkey/src/jsscan.c", "commit_date": "2012-02-17 00:00:00", "repo_name": "TritonDataCenter/smartos-live", "stars": 1540, "license": "None", "language": "c", "size": 51023}
{"docstring": "/* Format a time value into a buffer. Same semantics as strftime() */\n", "func_signal": "size_t\nPRMJ_FormatTime(char *buf, int buflen, char *fmt, PRMJTime *prtm)", "code": "{\n#if defined(XP_UNIX) || defined(XP_WIN) || defined(XP_OS2) || defined(XP_BEOS)\n    struct tm a;\n\n    /* Zero out the tm struct.  Linux, SunOS 4 struct tm has extra members int\n     * tm_gmtoff, char *tm_zone; when tm_zone is garbage, strftime gets\n     * confused and dumps core.  NSPR20 prtime.c attempts to fill these in by\n     * calling mktime on the partially filled struct, but this doesn't seem to\n     * work as well; the result string has \"can't get timezone\" for ECMA-valid\n     * years.  Might still make sense to use this, but find the range of years\n     * for which valid tz information exists, and map (per ECMA hint) from the\n     * given year into that range.\n\n     * N.B. This hasn't been tested with anything that actually _uses_\n     * tm_gmtoff; zero might be the wrong thing to set it to if you really need\n     * to format a time.  This fix is for jsdate.c, which only uses\n     * JS_FormatTime to get a string representing the time zone.  */\n    memset(&a, 0, sizeof(struct tm));\n\n    a.tm_sec = prtm->tm_sec;\n    a.tm_min = prtm->tm_min;\n    a.tm_hour = prtm->tm_hour;\n    a.tm_mday = prtm->tm_mday;\n    a.tm_mon = prtm->tm_mon;\n    a.tm_wday = prtm->tm_wday;\n    a.tm_year = prtm->tm_year - 1900;\n    a.tm_yday = prtm->tm_yday;\n    a.tm_isdst = prtm->tm_isdst;\n\n    /* Even with the above, SunOS 4 seems to detonate if tm_zone and tm_gmtoff\n     * are null.  This doesn't quite work, though - the timezone is off by\n     * tzoff + dst.  (And mktime seems to return -1 for the exact dst\n     * changeover time.)\n\n     */\n\n#if defined(SUNOS4)\n    if (mktime(&a) == -1) {\n        /* Seems to fail whenever the requested date is outside of the 32-bit\n         * UNIX epoch.  We could proceed at this point (setting a.tm_zone to\n         * \"\") but then strftime returns a string with a 2-digit field of\n         * garbage for the year.  So we return 0 and hope jsdate.c\n         * will fall back on toString.\n         */\n        return 0;\n    }\n#endif\n\n    return strftime(buf, buflen, fmt, &a);\n#endif\n}", "path": "smartos-live/tools/javascriptlint/spidermonkey/src/prmjtime.c", "commit_date": "2012-02-17 00:00:00", "repo_name": "TritonDataCenter/smartos-live", "stars": 1540, "license": "None", "language": "c", "size": 51023}
{"docstring": "/*\n * Peek n chars ahead into ts.  Return true if n chars were read, false if\n * there weren't enough characters in the input stream.  This function cannot\n * be used to peek into or past a newline.\n */\n", "func_signal": "static JSBool\nPeekChars(JSTokenStream *ts, intN n, jschar *cp)", "code": "{\n    intN i, j;\n    int32 c;\n\n    for (i = 0; i < n; i++) {\n        c = GetChar(ts);\n        if (c == EOF)\n            break;\n        if (c == '\\n') {\n            UngetChar(ts, c);\n            break;\n        }\n        cp[i] = (jschar)c;\n    }\n    for (j = i - 1; j >= 0; j--)\n        UngetChar(ts, cp[j]);\n    return i == n;\n}", "path": "smartos-live/tools/javascriptlint/spidermonkey/src/jsscan.c", "commit_date": "2012-02-17 00:00:00", "repo_name": "TritonDataCenter/smartos-live", "stars": 1540, "license": "None", "language": "c", "size": 51023}
{"docstring": "/* Returns NULL on success. Otherwise, it returns an error.\n * If the error is blank, an exception will be set.\n */\n", "func_signal": "static const char* create_jscontext(const char* strversion, PyObject* is_e4x,\n                                    void* ctx_data,\n                                    JSRuntime** runtime, JSContext** context,\n                                    JSObject** global)", "code": "{\n    JSVersion jsversion;\n\n    jsversion = JS_StringToVersion(strversion);\n    if (jsversion == JSVERSION_UNKNOWN) {\n        PyErr_SetString(PyExc_ValueError, \"\\\"version\\\" is invalid\");\n        return \"\";\n    }\n\n    *runtime = JS_NewRuntime(8L * 1024L * 1024L);\n    if (*runtime == NULL)\n        return \"cannot create runtime\";\n\n    *context = JS_NewContext(*runtime, 8192);\n    if (*context == NULL)\n        return \"cannot create context\";\n\n    JS_SetErrorReporter(*context, error_reporter);\n    JS_SetContextPrivate(*context, ctx_data);\n    JS_ToggleOptions(*context, JSOPTION_STRICT);\n    if (is_e4x == Py_True)\n        JS_ToggleOptions(*context, JSOPTION_XML);\n    else if (is_e4x != Py_False)\n        return \"e4x is not a boolean\";\n    JS_SetVersion(*context, jsversion);\n\n    *global = JS_NewObject(*context, NULL, NULL, NULL);\n    if (*global == NULL)\n        return \"cannot create global object\";\n\n    if (!JS_InitStandardClasses(*context, *global))\n        return \"cannot initialize standard classes\";\n\n    return NULL;\n}", "path": "smartos-live/tools/javascriptlint/javascriptlint/pyspidermonkey/pyspidermonkey.c", "commit_date": "2012-02-17 00:00:00", "repo_name": "TritonDataCenter/smartos-live", "stars": 1540, "license": "None", "language": "c", "size": 51023}
{"docstring": "/*\n * This function is used to handle fatal errors. It takes a standard printf(3c)\n * format and arguments and outputs to stderr. It then either:\n *\n *  - Calls abort() if the error code is 'ERR_UNEXPECTED'\n *  - Calls exit(code) for any other error code\n *\n * As such, it never returns control to the caller.\n */\n", "func_signal": "void\nfatal(dockerinit_err_t code, char *fmt, ...)", "code": "{\n     va_list ap;\n     va_start(ap, fmt);\n\n     (void) fprintf(log_stream, \"%s FATAL (code: %d): \",\n         getTimestamp(), (int)code);\n     (void) vfprintf(log_stream, fmt, ap);\n     fflush(log_stream);\n     va_end(ap);\n\n    if (code == ERR_UNEXPECTED) {\n        (void) abort();\n    } else {\n        exit((int) code);\n    }\n}", "path": "smartos-live/src/dockerinit/src/docker-common.c", "commit_date": "2017-08-31 00:00:00", "repo_name": "TritonDataCenter/smartos-live", "stars": 1540, "license": "None", "language": "c", "size": 51023}
{"docstring": "/*\n * Given an nvlist_t representing a JSON array of strings, walk each string in\n * the array and call the provided callback function.  The user-provided\n * \"array_name\", \"arg0\" and \"arg1\" values are passed through to the callback\n * unmodified.\n */\n", "func_signal": "static void\nforEachStringInArray(const char *array_name, nvlist_t *array_nvl,\n  forEachStringCb_t *funcp, void *arg0, void *arg1)", "code": "{\n    uint32_t len;\n\n    VERIFY(array_name != NULL);\n    VERIFY(funcp != NULL);\n\n    if (nvlist_lookup_uint32(array_nvl, \"length\", &len) != 0) {\n        fatal(ERR_UNEXPECTED, \"array \\\"%s\\\" is missing \\\"length\\\" property\\n\",\n          array_name);\n    }\n\n    for (uint32_t i = 0; i < len; i++) {\n        char idx[32];\n        char *val;\n\n        /*\n         * As part of the conversion from a JSON array to an nvlist, each\n         * array element is stored as a property where the name is the\n         * string representation of the index; e.g., the fifth element is\n         * named \"4\".\n         */\n        (void) snprintf(idx, sizeof (idx), \"%u\", i);\n\n        if (nvlist_lookup_string(array_nvl, idx, &val) != 0) {\n            fatal(ERR_UNEXPECTED, \"array \\\"%s\\\" missing string @ index [%s]\\n\",\n                array_name, idx);\n        }\n\n        funcp(array_name, i, val, arg0, arg1);\n    }\n}", "path": "smartos-live/src/dockerinit/src/docker-common.c", "commit_date": "2017-08-31 00:00:00", "repo_name": "TritonDataCenter/smartos-live", "stars": 1540, "license": "None", "language": "c", "size": 51023}
{"docstring": "/*\n * We have encountered a '\\': check for a Unicode escape sequence after it,\n * returning the character code value if we found a Unicode escape sequence.\n * Otherwise, non-destructively return the original '\\'.\n */\n", "func_signal": "static int32\nGetUnicodeEscape(JSTokenStream *ts)", "code": "{\n    jschar cp[5];\n    int32 c;\n\n    if (PeekChars(ts, 5, cp) && cp[0] == 'u' &&\n        JS7_ISHEX(cp[1]) && JS7_ISHEX(cp[2]) &&\n        JS7_ISHEX(cp[3]) && JS7_ISHEX(cp[4]))\n    {\n        c = (((((JS7_UNHEX(cp[1]) << 4)\n                + JS7_UNHEX(cp[2])) << 4)\n              + JS7_UNHEX(cp[3])) << 4)\n            + JS7_UNHEX(cp[4]);\n        SkipChars(ts, 5);\n        return c;\n    }\n    return '\\\\';\n}", "path": "smartos-live/tools/javascriptlint/spidermonkey/src/jsscan.c", "commit_date": "2012-02-17 00:00:00", "repo_name": "TritonDataCenter/smartos-live", "stars": 1540, "license": "None", "language": "c", "size": 51023}
{"docstring": "/* Convert from base time to extended time */\n", "func_signal": "static JSInt64\nPRMJ_ToExtendedTime(JSInt32 base_time)", "code": "{\n    JSInt64 exttime;\n    JSInt64 g1970GMTMicroSeconds;\n    JSInt64 low;\n    JSInt32 diff;\n    JSInt64  tmp;\n    JSInt64  tmp1;\n\n    diff = PRMJ_LocalGMTDifference();\n    JSLL_UI2L(tmp, PRMJ_USEC_PER_SEC);\n    JSLL_I2L(tmp1,diff);\n    JSLL_MUL(tmp,tmp,tmp1);\n\n    JSLL_UI2L(g1970GMTMicroSeconds,G1970GMTMICROHI);\n    JSLL_UI2L(low,G1970GMTMICROLOW);\n#ifndef JS_HAVE_LONG_LONG\n    JSLL_SHL(g1970GMTMicroSeconds,g1970GMTMicroSeconds,16);\n    JSLL_SHL(g1970GMTMicroSeconds,g1970GMTMicroSeconds,16);\n#else\n    JSLL_SHL(g1970GMTMicroSeconds,g1970GMTMicroSeconds,32);\n#endif\n    JSLL_ADD(g1970GMTMicroSeconds,g1970GMTMicroSeconds,low);\n\n    JSLL_I2L(exttime,base_time);\n    JSLL_ADD(exttime,exttime,g1970GMTMicroSeconds);\n    JSLL_SUB(exttime,exttime,tmp);\n    return exttime;\n}", "path": "smartos-live/tools/javascriptlint/spidermonkey/src/prmjtime.c", "commit_date": "2012-02-17 00:00:00", "repo_name": "TritonDataCenter/smartos-live", "stars": 1540, "license": "None", "language": "c", "size": 51023}
{"docstring": "/* Get the DST timezone offset for the time passed in */\n", "func_signal": "JSInt64\nPRMJ_DSTOffset(JSInt64 local_time)", "code": "{\n    JSInt64 us2s;\n    time_t local;\n    JSInt32 diff;\n    JSInt64  maxtimet;\n    struct tm tm;\n    PRMJTime prtm;\n#ifndef HAVE_LOCALTIME_R\n    struct tm *ptm;\n#endif\n\n\n    JSLL_UI2L(us2s, PRMJ_USEC_PER_SEC);\n    JSLL_DIV(local_time, local_time, us2s);\n\n    /* get the maximum of time_t value */\n    JSLL_UI2L(maxtimet,PRMJ_MAX_UNIX_TIMET);\n\n    if(JSLL_CMP(local_time,>,maxtimet)){\n        JSLL_UI2L(local_time,PRMJ_MAX_UNIX_TIMET);\n    } else if(!JSLL_GE_ZERO(local_time)){\n        /*go ahead a day to make localtime work (does not work with 0) */\n        JSLL_UI2L(local_time,PRMJ_DAY_SECONDS);\n    }\n    JSLL_L2UI(local,local_time);\n    PRMJ_basetime(local_time,&prtm);\n#ifndef HAVE_LOCALTIME_R\n    ptm = localtime(&local);\n    if(!ptm){\n        return JSLL_ZERO;\n    }\n    tm = *ptm;\n#else\n    localtime_r(&local,&tm); /* get dst information */\n#endif\n\n    diff = ((tm.tm_hour - prtm.tm_hour) * PRMJ_HOUR_SECONDS) +\n\t((tm.tm_min - prtm.tm_min) * 60);\n\n    if(diff < 0){\n\tdiff += PRMJ_DAY_SECONDS;\n    }\n\n    JSLL_UI2L(local_time,diff);\n\n    JSLL_MUL(local_time,local_time,us2s);\n\n    return(local_time);\n}", "path": "smartos-live/tools/javascriptlint/spidermonkey/src/prmjtime.c", "commit_date": "2012-02-17 00:00:00", "repo_name": "TritonDataCenter/smartos-live", "stars": 1540, "license": "None", "language": "c", "size": 51023}
{"docstring": "/*\n * Command handler function for 'decoders'\n * MPD returns the decoder plugins with their supported suffix and mime types.\n *\n * forked-daapd only uses libav/ffmepg for decoding and does not support decoder plugins,\n * therefor the function reports only ffmpeg as available.\n */\n", "func_signal": "static int\nmpd_command_decoders(struct evbuffer *evbuf, int argc, char **argv, char **errmsg, struct mpd_client_ctx *ctx)", "code": "{\n  int i;\n\n  evbuffer_add_printf(evbuf, \"plugin: ffmpeg\\n\");\n\n  for (i = 0; ffmpeg_suffixes[i]; i++)\n    {\n      evbuffer_add_printf(evbuf, \"suffix: %s\\n\", ffmpeg_suffixes[i]);\n    }\n\n  for (i = 0; ffmpeg_mime_types[i]; i++)\n    {\n      evbuffer_add_printf(evbuf, \"mime_type: %s\\n\", ffmpeg_mime_types[i]);\n    }\n\n  return 0;\n}", "path": "owntone-server/src/mpd.c", "commit_date": "2020-11-22 00:00:00", "repo_name": "owntone/owntone-server", "stars": 1905, "license": "gpl-2.0", "language": "c", "size": 48765}
{"docstring": "/*\n * Command handler function for 'seekcur'\n * Seeks the current song to the position in seconds given in argument argv[1] (fractions allowed).\n */\n", "func_signal": "static int\nmpd_command_seekcur(struct evbuffer *evbuf, int argc, char **argv, char **errmsg, struct mpd_client_ctx *ctx)", "code": "{\n  float seek_target_sec;\n  int seek_target_msec;\n  int ret;\n\n  seek_target_sec = strtof(argv[1], NULL);\n  seek_target_msec = seek_target_sec * 1000;\n\n  // TODO If prefixed by '+' or '-', then the time is relative to the current playing position.\n  ret = player_playback_seek(seek_target_msec, PLAYER_SEEK_POSITION);\n\n  if (ret < 0)\n    {\n      *errmsg = safe_asprintf(\"Failed to seek current song to time %d msec\", seek_target_msec);\n      return ACK_ERROR_UNKNOWN;\n    }\n\n  ret = player_playback_start();\n  if (ret < 0)\n    {\n      *errmsg = safe_asprintf(\"Player returned an error for start after seekcur\");\n      return ACK_ERROR_UNKNOWN;\n    }\n\n  return 0;\n}", "path": "owntone-server/src/mpd.c", "commit_date": "2020-11-22 00:00:00", "repo_name": "owntone/owntone-server", "stars": 1905, "license": "gpl-2.0", "language": "c", "size": 48765}
{"docstring": "/*\n * Checks if the given timestamp matches the \"If-Modified-Since\" request header\n *\n * If the request does not contains a \"If-Modified-Since\" header value or the value\n * does not match the given timestamp, it returns false (modified) and adds the\n * \"Cache-Control\" and \"Last-Modified\" headers to the response header.\n *\n * @param req The request with request and response headers\n * @param mtime The last modified timestamp for the requested resource\n * @return True if the given timestamp matches the request-header-value \"If-Modified-Since\", otherwise false\n */\n", "func_signal": "bool\nhttpd_request_not_modified_since(struct evhttp_request *req, time_t mtime)", "code": "{\n  struct evkeyvalq *input_headers;\n  struct evkeyvalq *output_headers;\n  char last_modified[1000];\n  const char *modified_since;\n  struct tm timebuf;\n\n  input_headers = evhttp_request_get_input_headers(req);\n  modified_since = evhttp_find_header(input_headers, \"If-Modified-Since\");\n\n  strftime(last_modified, sizeof(last_modified), \"%a, %d %b %Y %H:%M:%S %Z\", gmtime_r(&mtime, &timebuf));\n\n  // Return not modified, if given timestamp matches \"If-Modified-Since\" request header\n  if (modified_since && (strcasecmp(last_modified, modified_since) == 0))\n    return true;\n\n  // Add cache headers to allow client side caching\n  output_headers = evhttp_request_get_output_headers(req);\n  evhttp_add_header(output_headers, \"Cache-Control\", \"private,no-cache,max-age=0\");\n  evhttp_add_header(output_headers, \"Last-Modified\", last_modified);\n\n  return false;\n}", "path": "owntone-server/src/httpd.c", "commit_date": "2020-11-22 00:00:00", "repo_name": "owntone/owntone-server", "stars": 1905, "license": "gpl-2.0", "language": "c", "size": 48765}
{"docstring": "/*\n * Returns the next quoted string argument from the input string\n * with the quotes removed\n */\n", "func_signal": "static char*\nmpd_pars_quoted(char **input)", "code": "{\n  char *arg;\n  char *src;\n  char *dst;\n  char ch;\n\n  // skip double quote character\n  (*input)++;\n\n  src = dst = arg = *input;\n  while ((ch = *src) != '\"')\n    {\n      // A backslash character escapes the following character and should be removed\n      if (ch == '\\\\')\n\t{\n\t  ch = *(++src);\n\t}\n      *dst++ = ch;\n\n      if (ch == 0)\n\t{\n\t  // Error handling for missing double quote at end of parameter\n\t  DPRINTF(E_LOG, L_MPD, \"Error missing closing double quote in argument\\n\");\n\t  *input = src;\n\t  return NULL;\n\t}\n\n      ++src;\n    }\n\n  *dst = '\\0';\n  *input = ++src;\n\n  return arg;\n}", "path": "owntone-server/src/mpd.c", "commit_date": "2020-11-22 00:00:00", "repo_name": "owntone/owntone-server", "stars": 1905, "license": "gpl-2.0", "language": "c", "size": 48765}
{"docstring": "/*\n * Command handler function for 'replay_gain_status'\n * forked-daapd does not support replay gain, therefor this function returns always\n * \"replay_gain_mode: off\".\n */\n", "func_signal": "static int\nmpd_command_replay_gain_status(struct evbuffer *evbuf, int argc, char **argv, char **errmsg, struct mpd_client_ctx *ctx)", "code": "{\n  evbuffer_add(evbuf, \"replay_gain_mode: off\\n\", 22);\n  return 0;\n}", "path": "owntone-server/src/mpd.c", "commit_date": "2020-11-22 00:00:00", "repo_name": "owntone/owntone-server", "stars": 1905, "license": "gpl-2.0", "language": "c", "size": 48765}
{"docstring": "/*\n * Command handler function for 'plchangesposid'\n * Lists all changed songs in the queue since the given playlist version in argv[1] without metadata.\n */\n", "func_signal": "static int\nmpd_command_plchangesposid(struct evbuffer *evbuf, int argc, char **argv, char **errmsg, struct mpd_client_ctx *ctx)", "code": "{\n  struct query_params query_params;\n  struct db_queue_item queue_item;\n  int ret;\n\n  ret = plchanges_build_queryparams(&query_params, argc, argv, errmsg);\n  if (ret != 0)\n    return ret;\n\n  ret = db_queue_enum_start(&query_params);\n  if (ret < 0)\n    goto error;\n\n  while ((ret = db_queue_enum_fetch(&query_params, &queue_item)) == 0 && queue_item.id > 0)\n    {\n      evbuffer_add_printf(evbuf,\n      \t  \"cpos: %d\\n\"\n      \t  \"Id: %d\\n\",\n      \t  queue_item.pos,\n\t  queue_item.id);\n    }\n\n  db_queue_enum_end(&query_params);\n  free_query_params(&query_params, 1);\n\n  return 0;\n\n error:\n  db_queue_enum_end(&query_params);\n  free_query_params(&query_params, 1);\n  *errmsg = safe_asprintf(\"Failed to start queue enum for command plchangesposid\");\n  return ACK_ERROR_UNKNOWN;\n}", "path": "owntone-server/src/mpd.c", "commit_date": "2020-11-22 00:00:00", "repo_name": "owntone/owntone-server", "stars": 1905, "license": "gpl-2.0", "language": "c", "size": 48765}
{"docstring": "/*\n * Creates a new string for the given path that starts with a '/'.\n * If 'path' already starts with a '/' the returned string is a duplicate\n * of 'path'.\n *\n * The returned string needs to be freed by the caller.\n */\n", "func_signal": "static char *\nprepend_slash(const char *path)", "code": "{\n  char *result;\n\n  if (path[0] == '/')\n    result = strdup(path);\n  else\n    result = safe_asprintf(\"/%s\", path);\n\n  return result;\n}", "path": "owntone-server/src/mpd.c", "commit_date": "2020-11-22 00:00:00", "repo_name": "owntone/owntone-server", "stars": 1905, "license": "gpl-2.0", "language": "c", "size": 48765}
{"docstring": "/*\n * Command handler function for 'random'\n * Sets the shuffle mode, expects argument argv[1] to be an integer with\n *   0 = disable shuffle\n *   1 = enable shuffle\n */\n", "func_signal": "static int\nmpd_command_random(struct evbuffer *evbuf, int argc, char **argv, char **errmsg, struct mpd_client_ctx *ctx)", "code": "{\n  int enable;\n  int ret;\n\n  ret = safe_atoi32(argv[1], &enable);\n  if (ret < 0)\n    {\n      *errmsg = safe_asprintf(\"Argument doesn't convert to integer: '%s'\", argv[1]);\n      return ACK_ERROR_ARG;\n    }\n\n  player_shuffle_set(enable);\n  return 0;\n}", "path": "owntone-server/src/mpd.c", "commit_date": "2020-11-22 00:00:00", "repo_name": "owntone/owntone-server", "stars": 1905, "license": "gpl-2.0", "language": "c", "size": 48765}
{"docstring": "/*\n * Command handler function for 'listplaylists'\n * Lists all playlists with their last modified date.\n */\n", "func_signal": "static int\nmpd_command_listplaylists(struct evbuffer *evbuf, int argc, char **argv, char **errmsg, struct mpd_client_ctx *ctx)", "code": "{\n  struct query_params qp;\n  struct db_playlist_info dbpli;\n  char modified[32];\n  uint32_t time_modified;\n  int ret;\n\n  memset(&qp, 0, sizeof(struct query_params));\n\n  qp.type = Q_PL;\n  qp.sort = S_PLAYLIST;\n  qp.idx_type = I_NONE;\n  qp.filter = db_mprintf(\"(f.type = %d OR f.type = %d)\", PL_PLAIN, PL_SMART);\n\n  ret = db_query_start(&qp);\n  if (ret < 0)\n    {\n      db_query_end(&qp);\n      free(qp.filter);\n\n      *errmsg = safe_asprintf(\"Could not start query\");\n      return ACK_ERROR_UNKNOWN;\n    }\n\n  while (((ret = db_query_fetch_pl(&qp, &dbpli)) == 0) && (dbpli.id))\n    {\n      if (safe_atou32(dbpli.db_timestamp, &time_modified) != 0)\n\t{\n\t  *errmsg = safe_asprintf(\"Error converting time modified to uint32_t: %s\\n\", dbpli.db_timestamp);\n\t  db_query_end(&qp);\n\t  free(qp.filter);\n\t  return ACK_ERROR_UNKNOWN;\n\t}\n\n      mpd_time(modified, sizeof(modified), time_modified);\n\n      evbuffer_add_printf(evbuf,\n\t  \"playlist: %s\\n\"\n\t  \"Last-Modified: %s\\n\",\n\t  (dbpli.virtual_path + 1),\n\t  modified);\n    }\n\n  db_query_end(&qp);\n  free(qp.filter);\n\n  return 0;\n}", "path": "owntone-server/src/mpd.c", "commit_date": "2020-11-22 00:00:00", "repo_name": "owntone/owntone-server", "stars": 1905, "license": "gpl-2.0", "language": "c", "size": 48765}
{"docstring": "/* Thread: main */\n", "func_signal": "void mpd_deinit(void)", "code": "{\n  unsigned short port;\n  unsigned short http_port;\n  int ret;\n\n  port = cfg_getint(cfg_getsec(cfg, \"mpd\"), \"port\");\n  if (port <= 0)\n    {\n      DPRINTF(E_INFO, L_MPD, \"MPD not enabled\\n\");\n      return;\n    }\n\n  commands_base_destroy(cmdbase);\n\n  ret = pthread_join(tid_mpd, NULL);\n  if (ret != 0)\n    {\n      DPRINTF(E_FATAL, L_MPD, \"Could not join cache thread: %s\\n\", strerror(errno));\n      return;\n    }\n\n  listener_remove(mpd_listener_cb);\n\n  while (mpd_clients)\n    {\n      free_mpd_client_ctx(mpd_clients);\n    }\n\n  http_port = cfg_getint(cfg_getsec(cfg, \"mpd\"), \"http_port\");\n  if (http_port > 0)\n    evhttp_free(evhttpd);\n\n  // Note evconnlistener_free segfaults if you give it a null pointer, so we need the if\n  if (mpd_listener)\n    evconnlistener_free(mpd_listener);\n  if (mpd_listener6)\n    evconnlistener_free(mpd_listener6);\n\n  // Free event base (should free events too)\n  event_base_free(evbase_mpd);\n\n  free(default_pl_dir);\n}", "path": "owntone-server/src/mpd.c", "commit_date": "2020-11-22 00:00:00", "repo_name": "owntone/owntone-server", "stars": 1905, "license": "gpl-2.0", "language": "c", "size": 48765}
{"docstring": "/*\n * Command handler function for 'single'\n * Sets the repeat mode, expects argument argv[1] to be an integer.\n * forked-daapd only allows single-mode in combination with repeat, therefor the command\n * single translates (depending on the current repeat mode) into:\n * a) if repeat off:\n *   0 = repeat off\n *   1 = repeat song\n * b) if repeat all:\n *   0 = repeat all\n *   1 = repeat song\n * c) if repeat song:\n *   0 = repeat all\n *   1 = repeat song\n */\n", "func_signal": "static int\nmpd_command_single(struct evbuffer *evbuf, int argc, char **argv, char **errmsg, struct mpd_client_ctx *ctx)", "code": "{\n  int enable;\n  struct player_status status;\n  int ret;\n\n  ret = safe_atoi32(argv[1], &enable);\n  if (ret < 0)\n    {\n      *errmsg = safe_asprintf(\"Argument doesn't convert to integer: '%s'\", argv[1]);\n      return ACK_ERROR_ARG;\n    }\n\n  player_get_status(&status);\n\n  if (enable == 0 && status.repeat != REPEAT_OFF)\n    player_repeat_set(REPEAT_ALL);\n  else if (enable == 0)\n    player_repeat_set(REPEAT_OFF);\n  else\n    player_repeat_set(REPEAT_SONG);\n\n  return 0;\n}", "path": "owntone-server/src/mpd.c", "commit_date": "2020-11-22 00:00:00", "repo_name": "owntone/owntone-server", "stars": 1905, "license": "gpl-2.0", "language": "c", "size": 48765}
{"docstring": "/*\n * Command handler function for 'previous'\n * Skips to the previous song in the playqueue\n */\n", "func_signal": "static int\nmpd_command_previous(struct evbuffer *evbuf, int argc, char **argv, char **errmsg, struct mpd_client_ctx *ctx)", "code": "{\n  int ret;\n\n  ret = player_playback_prev();\n\n  if (ret < 0)\n    {\n      *errmsg = safe_asprintf(\"Failed to skip to previous song\");\n      return ACK_ERROR_UNKNOWN;\n    }\n\n  ret = player_playback_start();\n  if (ret < 0)\n    {\n      *errmsg = safe_asprintf(\"Player returned an error for start after previtem\");\n      return ACK_ERROR_UNKNOWN;\n    }\n\n  return 0;\n}", "path": "owntone-server/src/mpd.c", "commit_date": "2020-11-22 00:00:00", "repo_name": "owntone/owntone-server", "stars": 1905, "license": "gpl-2.0", "language": "c", "size": 48765}
{"docstring": "/*\n * Command handler function for 'toggleoutput'\n * Expects argument argv[1] to be the id of the speaker to enable/disable.\n */\n", "func_signal": "static int\nmpd_command_toggleoutput(struct evbuffer *evbuf, int argc, char **argv, char **errmsg, struct mpd_client_ctx *ctx)", "code": "{\n  struct output_get_param param;\n  uint32_t num;\n  int ret;\n\n  ret = safe_atou32(argv[1], &num);\n  if (ret < 0)\n    {\n      *errmsg = safe_asprintf(\"Argument doesn't convert to integer: '%s'\", argv[1]);\n      return ACK_ERROR_ARG;\n    }\n\n  memset(&param, 0, sizeof(struct output_get_param));\n  param.shortid = num;\n\n  player_speaker_enumerate(output_get_cb, &param);\n\n  if (param.output)\n    {\n      if (param.output->selected)\n\tret = player_speaker_disable(param.output->id);\n      else\n\tret = player_speaker_enable(param.output->id);\n\n      free_output(param.output);\n\n      if (ret < 0)\n\t{\n\t  *errmsg = safe_asprintf(\"Toggle speaker failed: %d\", num);\n\t  return ACK_ERROR_UNKNOWN;\n\t}\n    }\n\n  return 0;\n}", "path": "owntone-server/src/mpd.c", "commit_date": "2020-11-22 00:00:00", "repo_name": "owntone/owntone-server", "stars": 1905, "license": "gpl-2.0", "language": "c", "size": 48765}
{"docstring": "/*\n * Sets the filter (where clause) and the window (limit clause) in the given query_params\n * based on the given arguments\n *\n * @param argc Number of arguments in argv\n * @param argv Pointer to the first filter parameter\n * @param exact_match If true, creates filter for exact matches (e. g. find command) otherwise matches substrings (e. g. search command)\n * @param qp Query parameters\n */\n", "func_signal": "static int\nparse_filter_window_params(int argc, char **argv, bool exact_match, struct query_params *qp)", "code": "{\n  struct mpd_tagtype *tagtype;\n  char *c1;\n  int start_pos;\n  int end_pos;\n  int i;\n  uint32_t num;\n  int ret;\n\n  c1 = NULL;\n\n  for (i = 0; i < argc; i += 2)\n    {\n      // End of filter key/value pairs reached, if keywords \"window\" or \"group\" found\n      if (0 == strcasecmp(argv[i], \"window\") || 0 == strcasecmp(argv[i], \"group\"))\n\tbreak;\n\n      // Process filter key/value pair\n      if ((i + 1) < argc)\n        {\n\t  tagtype = find_tagtype(argv[i]);\n\n\t  if (!tagtype)\n\t    {\n\t      DPRINTF(E_WARN, L_MPD, \"Parameter '%s' is not supported by forked-daapd and will be ignored\\n\", argv[i]);\n\t      continue;\n\t    }\n\n\t  if (tagtype->type == MPD_TYPE_STRING)\n\t    {\n\t      if (exact_match)\n\t\tc1 = db_mprintf(\"(%s = '%q')\", tagtype->field, argv[i + 1]);\n\t      else\n\t\tc1 = db_mprintf(\"(%s LIKE '%%%q%%')\", tagtype->field, argv[i + 1]);\n\t    }\n\t  else if (tagtype->type == MPD_TYPE_INT)\n\t    {\n\t      ret = safe_atou32(argv[i + 1], &num);\n\t      if (ret < 0)\n\t\tDPRINTF(E_WARN, L_MPD, \"%s parameter '%s' is not an integer and will be ignored\\n\", tagtype->tag, argv[i + 1]);\n\t      else\n\t\tc1 = db_mprintf(\"(%s = %d)\", tagtype->field, num);\n\t    }\n\t  else if (tagtype->type == MPD_TYPE_SPECIAL)\n\t    {\n\t      if (0 == strcasecmp(tagtype->tag, \"any\"))\n\t        {\n\t\t  c1 = db_mprintf(\"(f.artist LIKE '%%%q%%' OR f.album LIKE '%%%q%%' OR f.title LIKE '%%%q%%')\", argv[i + 1], argv[i + 1], argv[i + 1]);\n\t\t}\n\t      else if (0 == strcasecmp(tagtype->tag, \"file\"))\n\t        {\n\t\t  if (exact_match)\n\t\t    c1 = db_mprintf(\"(f.virtual_path = '/%q')\", argv[i + 1]);\n\t\t  else\n\t\t    c1 = db_mprintf(\"(f.virtual_path LIKE '%%%q%%')\", argv[i + 1]);\n\t\t}\n\t      else if (0 == strcasecmp(tagtype->tag, \"base\"))\n\t        {\n\t\t  c1 = db_mprintf(\"(f.virtual_path LIKE '/%q%%')\", argv[i + 1]);\n\t\t}\n\t      else\n\t        {\n\t\t  DPRINTF(E_WARN, L_MPD, \"Unknown special parameter '%s' will be ignored\\n\", tagtype->tag);\n\t\t}\n\t    }\n\t}\n      else if (i == 0 && argc == 1)\n        {\n\t  // Special case: a single token is allowed if listing albums for an artist\n\t  c1 = db_mprintf(\"(f.album_artist = '%q')\", argv[i]);\n\t}\n      else\n        {\n\t  DPRINTF(E_WARN, L_MPD, \"Missing value for parameter '%s', ignoring '%s'\\n\", argv[i], argv[i]);\n\t}\n\n      if (c1)\n        {\n\t  append_string(&qp->filter, c1, \" AND \");\n\n\t  free(c1);\n\t  c1 = NULL;\n\t}\n    }\n\n  if ((i + 1) < argc && 0 == strcasecmp(argv[i], \"window\"))\n    {\n      ret = mpd_pars_range_arg(argv[i + 1], &start_pos, &end_pos);\n      if (ret == 0)\n        {\n\t  qp->idx_type = I_SUB;\n\t  qp->limit = end_pos - start_pos;\n\t  qp->offset = start_pos;\n\t}\n      else\n        {\n\t  DPRINTF(E_LOG, L_MPD, \"Window argument doesn't convert to integer or range: '%s'\\n\", argv[i + 1]);\n\t}\n      i += 2;\n    }\n\n  return 0;\n}", "path": "owntone-server/src/mpd.c", "commit_date": "2020-11-22 00:00:00", "repo_name": "owntone/owntone-server", "stars": 1905, "license": "gpl-2.0", "language": "c", "size": 48765}
{"docstring": "/*\n * Command handler function for 'enableoutput'\n * Expects argument argv[1] to be the id of the speaker to enable.\n */\n", "func_signal": "static int\nmpd_command_enableoutput(struct evbuffer *evbuf, int argc, char **argv, char **errmsg, struct mpd_client_ctx *ctx)", "code": "{\n  struct output_get_param param;\n  uint32_t num;\n  int ret;\n\n  ret = safe_atou32(argv[1], &num);\n  if (ret < 0)\n    {\n      *errmsg = safe_asprintf(\"Argument doesn't convert to integer: '%s'\", argv[1]);\n      return ACK_ERROR_ARG;\n    }\n\n  memset(&param, 0, sizeof(struct output_get_param));\n  param.shortid = num;\n\n  player_speaker_enumerate(output_get_cb, &param);\n\n  if (param.output && !param.output->selected)\n    {\n      ret = player_speaker_enable(param.output->id);\n      free_output(param.output);\n\n      if (ret < 0)\n\t{\n\t  *errmsg = safe_asprintf(\"Speakers deactivation failed: %d\", num);\n\t  return ACK_ERROR_UNKNOWN;\n\t}\n    }\n\n  return 0;\n}", "path": "owntone-server/src/mpd.c", "commit_date": "2020-11-22 00:00:00", "repo_name": "owntone/owntone-server", "stars": 1905, "license": "gpl-2.0", "language": "c", "size": 48765}
{"docstring": "/*\n * Command handler function for 'search'\n * Lists any song that matches the given list of arguments. Arguments are pairs of TYPE and WHAT, where\n * TYPE is the tag that contains WHAT (case insensitiv).\n *\n * TYPE can also be one of the special parameter:\n * - any: checks all tags\n * - file: checks the virtual_path\n * - base: restricts result to the given directory\n * - modified-since (not supported)\n * - window: limits result to the given range of \"START:END\"\n *\n * Example request: \"search artist foo album bar\"\n */\n", "func_signal": "static int\nmpd_command_search(struct evbuffer *evbuf, int argc, char **argv, char **errmsg, struct mpd_client_ctx *ctx)", "code": "{\n  struct query_params qp;\n  struct db_media_file_info dbmfi;\n  int ret;\n\n  if (argc < 3 || ((argc - 1) % 2) != 0)\n    {\n      *errmsg = safe_asprintf(\"Missing argument(s) for command 'search'\");\n      return ACK_ERROR_ARG;\n    }\n\n  memset(&qp, 0, sizeof(struct query_params));\n\n  qp.type = Q_ITEMS;\n  qp.sort = S_NAME;\n  qp.idx_type = I_NONE;\n\n  parse_filter_window_params(argc - 1, argv + 1, false, &qp);\n\n  ret = db_query_start(&qp);\n  if (ret < 0)\n    {\n      db_query_end(&qp);\n      free(qp.filter);\n\n      *errmsg = safe_asprintf(\"Could not start query\");\n      return ACK_ERROR_UNKNOWN;\n    }\n\n  while (((ret = db_query_fetch_file(&qp, &dbmfi)) == 0) && (dbmfi.id))\n    {\n      ret = mpd_add_db_media_file_info(evbuf, &dbmfi);\n      if (ret < 0)\n\t{\n\t  DPRINTF(E_LOG, L_MPD, \"Error adding song to the evbuffer, song id: %s\\n\", dbmfi.id);\n\t}\n    }\n\n  db_query_end(&qp);\n  free(qp.filter);\n\n  return 0;\n}", "path": "owntone-server/src/mpd.c", "commit_date": "2020-11-22 00:00:00", "repo_name": "owntone/owntone-server", "stars": 1905, "license": "gpl-2.0", "language": "c", "size": 48765}
{"docstring": "/*\n * Parses the argument string into an array of strings.\n * Arguments are seperated by a whitespace character and may be wrapped in double quotes.\n *\n * @param args the arguments\n * @param argc the number of arguments in the argument string\n * @param argv the array containing the found arguments\n */\n", "func_signal": "static int\nmpd_parse_args(char *args, int *argc, char **argv)", "code": "{\n  char *input;\n\n  input = args;\n  *argc = 0;\n\n  while (*input != 0)\n    {\n      // Ignore whitespace characters\n      if (*input == ' ')\n\t{\n\t  input++;\n\t  continue;\n\t}\n\n      // Check if the parameter is wrapped in double quotes\n      if (*input == '\"')\n\t{\n\t  argv[*argc] = mpd_pars_quoted(&input);\n\t  if (argv[*argc] == NULL)\n\t    {\n\t      return -1;\n\t    }\n\t  *argc = *argc + 1;\n\t}\n      else\n\t{\n\t  argv[*argc] = mpd_pars_unquoted(&input);\n\t  *argc = *argc + 1;\n\t}\n    }\n\n  return 0;\n}", "path": "owntone-server/src/mpd.c", "commit_date": "2020-11-22 00:00:00", "repo_name": "owntone/owntone-server", "stars": 1905, "license": "gpl-2.0", "language": "c", "size": 48765}
{"docstring": "/*\n * Command handler function for 'playlistid'\n * Displays a list of all songs in the queue, or if the optional argument is given, displays information\n * only for the song with ID.\n *\n * The order of the songs is always the not shuffled order.\n */\n", "func_signal": "static int\nmpd_command_playlistid(struct evbuffer *evbuf, int argc, char **argv, char **errmsg, struct mpd_client_ctx *ctx)", "code": "{\n  struct query_params query_params;\n  struct db_queue_item queue_item;\n  uint32_t songid;\n  int ret;\n\n  songid = 0;\n\n  if (argc > 1)\n    {\n      ret = safe_atou32(argv[1], &songid);\n      if (ret < 0)\n\t{\n\t  *errmsg = safe_asprintf(\"Argument doesn't convert to integer: '%s'\", argv[1]);\n\t  return ACK_ERROR_ARG;\n\t}\n    }\n\n  memset(&query_params, 0, sizeof(struct query_params));\n\n  if (songid > 0)\n    query_params.filter = db_mprintf(\"id = %d\", songid);\n\n  ret = db_queue_enum_start(&query_params);\n  if (ret < 0)\n    {\n      free(query_params.filter);\n      *errmsg = safe_asprintf(\"Failed to start queue enum for command playlistid: '%s'\", argv[1]);\n      return ACK_ERROR_ARG;\n    }\n\n  while ((ret = db_queue_enum_fetch(&query_params, &queue_item)) == 0 && queue_item.id > 0)\n    {\n      ret = mpd_add_db_queue_item(evbuf, &queue_item);\n      if (ret < 0)\n\t{\n\t  *errmsg = safe_asprintf(\"Error adding media info for file with id: %d\", queue_item.file_id);\n\n\t  db_queue_enum_end(&query_params);\n\t  free(query_params.filter);\n\t  return ACK_ERROR_UNKNOWN;\n\t}\n    }\n\n  db_queue_enum_end(&query_params);\n  free(query_params.filter);\n\n  return 0;\n}", "path": "owntone-server/src/mpd.c", "commit_date": "2020-11-22 00:00:00", "repo_name": "owntone/owntone-server", "stars": 1905, "license": "gpl-2.0", "language": "c", "size": 48765}
{"docstring": "/*\n * Adds the informations (path, id, tags, etc.) for the given song to the given buffer.\n *\n * Example output:\n *   file: foo/bar/song.mp3\n *   Last-Modified: 2013-07-14T06:57:59Z\n *   Time: 172\n *   Artist: foo\n *   AlbumArtist: foo\n *   ArtistSort: foo\n *   AlbumArtistSort: foo\n *   Title: song\n *   Album: bar\n *   Track: 1/11\n *   Date: 2012-09-11\n *   Genre: Alternative\n *   Disc: 1/1\n *   MUSICBRAINZ_ALBUMARTISTID: c5c2ea1c-4bde-4f4d-bd0b-47b200bf99d6\n *   MUSICBRAINZ_ARTISTID: c5c2ea1c-4bde-4f4d-bd0b-47b200bf99d6\n *   MUSICBRAINZ_ALBUMID: 812f4b87-8ad9-41bd-be79-38151f17a2b4\n *   MUSICBRAINZ_TRACKID: fde95c39-ee51-48f6-a7f9-b5631c2ed156\n *\n * @param evbuf the response event buffer\n * @param mfi media information\n * @return the number of bytes added if successful, or -1 if an error occurred.\n */\n", "func_signal": "static int\nmpd_add_db_media_file_info(struct evbuffer *evbuf, struct db_media_file_info *dbmfi)", "code": "{\n  char modified[32];\n  uint32_t time_modified;\n  uint32_t songlength;\n  int ret;\n\n  if (safe_atou32(dbmfi->time_modified, &time_modified) != 0)\n    {\n      DPRINTF(E_LOG, L_MPD, \"Error converting time modified to uint32_t: %s\\n\", dbmfi->time_modified);\n      return -1;\n    }\n\n  mpd_time(modified, sizeof(modified), time_modified);\n\n  if (safe_atou32(dbmfi->song_length, &songlength) != 0)\n    {\n      DPRINTF(E_LOG, L_MPD, \"Error converting song length to uint32_t: %s\\n\", dbmfi->song_length);\n      return -1;\n    }\n\n  ret = evbuffer_add_printf(evbuf,\n      \"file: %s\\n\"\n      \"Last-Modified: %s\\n\"\n      \"Time: %d\\n\"\n      \"duration: %.3f\\n\"\n      \"Artist: %s\\n\"\n      \"AlbumArtist: %s\\n\"\n      \"ArtistSort: %s\\n\"\n      \"AlbumArtistSort: %s\\n\"\n      \"Album: %s\\n\"\n      \"Title: %s\\n\"\n      \"Track: %s\\n\"\n      \"Date: %s\\n\"\n      \"Genre: %s\\n\"\n      \"Disc: %s\\n\",\n      (dbmfi->virtual_path + 1),\n      modified,\n      (songlength / 1000),\n      ((float) songlength / 1000),\n      dbmfi->artist,\n      dbmfi->album_artist,\n      dbmfi->artist_sort,\n      dbmfi->album_artist_sort,\n      dbmfi->album,\n      dbmfi->title,\n      dbmfi->track,\n      dbmfi->year,\n      dbmfi->genre,\n      dbmfi->disc);\n\n  return ret;\n}", "path": "owntone-server/src/mpd.c", "commit_date": "2020-11-22 00:00:00", "repo_name": "owntone/owntone-server", "stars": 1905, "license": "gpl-2.0", "language": "c", "size": 48765}
{"docstring": "/* Callback from the worker thread (async operation as it may block) */\n", "func_signal": "static void\nplaycount_inc_cb(void *arg)", "code": "{\n  int *id = arg;\n\n  db_file_inc_playcount(*id);\n}", "path": "owntone-server/src/httpd.c", "commit_date": "2020-11-22 00:00:00", "repo_name": "owntone/owntone-server", "stars": 1905, "license": "gpl-2.0", "language": "c", "size": 48765}
{"docstring": "// This interrupt find Card -> Reader SOC\n", "func_signal": "ISR(ACA_AC1_vect)", "code": "{ // this interrupt either finds the SOC or gets triggered before\n    ACA.AC1CTRL &= ~AC_INTLVL_HI_gc; // disable this interrupt\n    // enable the pause-finding timer\n    CODEC_TIMER_LOADMOD.CTRLD = TC_EVACT_RESTART_gc | TC_EVSEL_CH0_gc;\n    CODEC_TIMER_LOADMOD.CTRLA = TC_CLKSEL_DIV1_gc;\n}", "path": "ChameleonMini/Firmware/Chameleon-Mini/Codec/Reader14443-2A.c", "commit_date": "2019-12-08 00:00:00", "repo_name": "emsec/ChameleonMini", "stars": 1669, "license": "other", "language": "c", "size": 11090}
{"docstring": "/** Event handler for the USB_HostError event. This indicates that a hardware error occurred while in host mode. */\n", "func_signal": "void EVENT_USB_Host_HostError(const uint8_t ErrorCode)", "code": "{\n\tUSB_Disable();\n\tfor(;;);\n}", "path": "ChameleonMini/RevE/Firmware/LUFA/CodeTemplates/HostTemplate/HostApplication.c", "commit_date": "2016-10-07 00:00:00", "repo_name": "emsec/ChameleonMini", "stars": 1669, "license": "other", "language": "c", "size": 11090}
{"docstring": "/** Main program entry point. This routine contains the overall program flow, including initial\n *  setup of all components and the main program loop.\n */\n", "func_signal": "int main(void)", "code": "{\n\tSetupHardware();\n\n\tGlobalInterruptEnable();\n\n\tfor (;;)\n\t{\n\t\tUSB_USBTask();\n\t}\n}", "path": "ChameleonMini/RevE/Firmware/LUFA/CodeTemplates/DeviceTemplate/DeviceApplication.c", "commit_date": "2016-10-07 00:00:00", "repo_name": "emsec/ChameleonMini", "stars": 1669, "license": "other", "language": "c", "size": 11090}
{"docstring": "// End of Card-> reader communication and enter frame delay time\n", "func_signal": "INLINE void Reader14443A_EOC(void)", "code": "{\n    CODEC_TIMER_LOADMOD.INTCTRLB = 0;\n    CODEC_TIMER_LOADMOD.CTRLA = TC_CLKSEL_OFF_gc;\n    CODEC_TIMER_TIMESTAMPS.INTCTRLB = 0;\n    CODEC_TIMER_TIMESTAMPS.CTRLA = TC_CLKSEL_OFF_gc;\n    ACA.AC1CTRL &= ~AC_ENABLE_bm;\n\n    if (BitCount & 1) {\n        if (SampleRegister & 0x80)\n            Insert0();\n        else\n            Insert1();\n    }\n\n    if (BitCount % 8) // copy the last byte, if there is an incomplete byte\n        CodecBuffer[BitCount / 8] = SampleRegister >> (8 - (BitCount % 8));\n    Flags.RxDone = true;\n    Flags.RxPending = false;\n\n    // set up timer that forces the minimum frame delay time from PICC to PCD\n    CODEC_TIMER_LOADMOD.PER = 0xFFFF;\n    CODEC_TIMER_LOADMOD.CNT = 0;\n    CODEC_TIMER_LOADMOD.INTCTRLA = 0;\n    CODEC_TIMER_LOADMOD.INTCTRLB = 0;\n    CODEC_TIMER_LOADMOD.CTRLD = 0;\n    CODEC_TIMER_LOADMOD.CTRLA = ISO14443A_PICC_TO_PCD_FDT_PRESCALER;\n\n    State = STATE_FDT;\n}", "path": "ChameleonMini/Firmware/Chameleon-Mini/Codec/Reader14443-2A.c", "commit_date": "2019-12-08 00:00:00", "repo_name": "emsec/ChameleonMini", "stars": 1669, "license": "other", "language": "c", "size": 11090}
{"docstring": "/** Configures the board hardware and chip peripherals for the demo's functionality. */\n", "func_signal": "void SetupHardware(void)", "code": "{\n\t/* Disable watchdog if enabled by bootloader/fuses */\n\tMCUSR &= ~(1 << WDRF);\n\twdt_disable();\n\n\t/* Disable clock division */\n\tclock_prescale_set(clock_div_1);\n\n\t/* Hardware Initialization */\n\tUSB_Init(USB_MODE_Host, USB_DEVICE_OPT_FULLSPEED | USB_OPT_AUTO_PLL);\n}", "path": "ChameleonMini/RevE/Firmware/LUFA/CodeTemplates/HostTemplate/HostApplication.c", "commit_date": "2016-10-07 00:00:00", "repo_name": "emsec/ChameleonMini", "stars": 1669, "license": "other", "language": "c", "size": 11090}
{"docstring": "/* DISABLE_PERMISSIVE_DESFIRE_SETTINGS */\n", "func_signal": "CommandStatusIdType CommandDESFireLayoutPPrint(char *OutParam, const char *InParams)", "code": "{\n     if(!IsDESFireConfiguration()) {\n          ExitOnInvalidConfigurationError(OutParam); \n     }\n     char pprintListSpecStr[32];\n     BYTE StatusError = 0x00;\n     if(!sscanf_P(InParams, PSTR(\"%31s\"), pprintListSpecStr)) {\n          StatusError = 0x01;\n     }\n     else {\n          pprintListSpecStr[31] = '\\0';\n          if(!strcasecmp_P(pprintListSpecStr, PSTR(\"FullImage\"))) {\n               PrettyPrintPICCImageData((BYTE *) OutParam, TERMINAL_BUFFER_SIZE, 0x01);\n          }\n          else if(!strcasecmp_P(pprintListSpecStr, PSTR(\"HeaderData\"))) {\n               PrettyPrintPICCHeaderData((BYTE *) OutParam, TERMINAL_BUFFER_SIZE, 0x01);\n          }\n          else {\n               StatusError = 0x01;\n          }\n     }\n     if(StatusError) {\n          snprintf_P(OutParam, TERMINAL_BUFFER_SIZE, \n                     PSTR(\"%s <FullImage|HeaderData>\"), \n                     DFCOMMAND_LAYOUT_PPRINT);\n          return COMMAND_ERR_INVALID_USAGE_ID;\n     }\n     return COMMAND_INFO_OK_WITH_TEXT_ID;\n}", "path": "ChameleonMini/Firmware/Chameleon-Mini/Application/DESFire/DESFireChameleonTerminal.c", "commit_date": "2020-10-17 00:00:00", "repo_name": "emsec/ChameleonMini", "stars": 1669, "license": "other", "language": "c", "size": 11090}
{"docstring": "/****************************************************************/\n/*                                                              */\n/*                       Main Program                           */\n/*                                                              */\n/****************************************************************/\n", "func_signal": "int main(int argc, char **argv)", "code": "{\n\tunsigned char buf[260];\n\tint num, addr, r, first_block=1, waited=0;\n\n\t// parse command line arguments\n\tparse_options(argc, argv);\n\tif (!filename) {\n\t\tfprintf(stderr, \"Filename must be specified\\n\\n\");\n\t\tusage();\n\t}\n\tif (!code_size) {\n\t\tfprintf(stderr, \"MCU type must be specified\\n\\n\");\n\t\tusage();\n\t}\n\tprintf_verbose(\"Teensy Loader, Command Line, Version 2.0\\n\");\n\n\t// read the intel hex file\n\t// this is done first so any error is reported before using USB\n\tnum = read_intel_hex(filename);\n\tif (num < 0) die(\"error reading intel hex file \\\"%s\\\"\", filename);\n\tprintf_verbose(\"Read \\\"%s\\\": %d bytes, %.1f%% usage\\n\",\n\t\tfilename, num, (double)num / (double)code_size * 100.0);\n\n\t// open the USB device\n\twhile (1) {\n\t\tif (teensy_open()) break;\n\t\tif (hard_reboot_device) {\n\t\t\tif (!hard_reboot()) die(\"Unable to find rebootor\\n\");\n\t\t\tprintf_verbose(\"Hard Reboot performed\\n\");\n\t\t\thard_reboot_device = 0; // only hard reboot once\n\t\t\twait_for_device_to_appear = 1;\n\t\t}\n\t\tif (!wait_for_device_to_appear) die(\"Unable to open device\\n\");\n\t\tif (!waited) {\n\t\t\tprintf_verbose(\"Waiting for Teensy device...\\n\");\n\t\t\tprintf_verbose(\" (hint: press the reset button)\\n\");\n\t\t\twaited = 1;\n\t\t}\n\t\tdelay(0.25);\n\t}\n\tprintf_verbose(\"Found HalfKay Bootloader\\n\");\n\n\t// if we waited for the device, read the hex file again\n\t// perhaps it changed while we were waiting?\n\tif (waited) {\n\t\tnum = read_intel_hex(filename);\n\t\tif (num < 0) die(\"error reading intel hex file \\\"%s\\\"\", filename);\n\t\tprintf_verbose(\"Read \\\"%s\\\": %d bytes, %.1f%% usage\\n\",\n\t\t \tfilename, num, (double)num / (double)code_size * 100.0);\n\t}\n\n\t// program the data\n\tprintf_verbose(\"Programming\");\n\tfflush(stdout);\n\tfor (addr = 0; addr < code_size; addr += block_size) {\n\t\tif (addr > 0 && !ihex_bytes_within_range(addr, addr + block_size - 1)) {\n\t\t\t// don't waste time on blocks that are unused,\n\t\t\t// but always do the first one to erase the chip\n\t\t\tcontinue;\n\t\t}\n\t\tprintf_verbose(\".\");\n\t\tif (code_size < 0x10000) {\n\t\t\tbuf[0] = addr & 255;\n\t\t\tbuf[1] = (addr >> 8) & 255;\n\t\t} else {\n\t\t\tbuf[0] = (addr >> 8) & 255;\n\t\t\tbuf[1] = (addr >> 16) & 255;\n\t\t}\n\t\tihex_get_data(addr, block_size, buf + 2);\n\t\tr = teensy_write(buf, block_size + 2, first_block ? 3.0 : 0.25);\n\t\tif (!r) die(\"error writing to Teensy\\n\");\n\t\tfirst_block = 0;\n\t}\n\tprintf_verbose(\"\\n\");\n\n\t// reboot to the user's new code\n\tif (reboot_after_programming) {\n\t\tprintf_verbose(\"Booting\\n\");\n\t\tbuf[0] = 0xFF;\n\t\tbuf[1] = 0xFF;\n\t\tmemset(buf + 2, 0, sizeof(buf) - 2);\n\t\tteensy_write(buf, block_size + 2, 0.25);\n\t}\n\tteensy_close();\n\treturn 0;\n}", "path": "ChameleonMini/Firmware/LUFA/Bootloaders/HID/HostLoaderApp/hid_bootloader_cli.c", "commit_date": "2016-10-07 00:00:00", "repo_name": "emsec/ChameleonMini", "stars": 1669, "license": "other", "language": "c", "size": 11090}
{"docstring": "/* Perform access verification and commit data if passed */\n", "func_signal": "static uint8_t AppWritePage(uint8_t PageAddress, uint8_t *const Buffer)", "code": "{\n    if (!ActiveConfiguration.ReadOnly) {\n        MemoryWriteBlock(Buffer, PageAddress * MIFARE_ULTRALIGHT_PAGE_SIZE, MIFARE_ULTRALIGHT_PAGE_SIZE);\n    } else {\n        /* If the chameleon is in read only mode, it silently\n        * ignores any attempt to write data. */\n    }\n    return 0;\n}", "path": "ChameleonMini/Firmware/Chameleon-Mini/Application/MifareUltralight.c", "commit_date": "2020-10-17 00:00:00", "repo_name": "emsec/ChameleonMini", "stars": 1669, "license": "other", "language": "c", "size": 11090}
{"docstring": "/** Main program entry point. This routine configures the hardware required by the application, then\n *  enters a loop to run the application tasks in sequence.\n */\n", "func_signal": "int main(void)", "code": "{\n\tSetupHardware();\n\n\tGlobalInterruptEnable();\n\n\tfor (;;)\n\t{\n\t\tUSB_USBTask();\n\t}\n}", "path": "ChameleonMini/RevE/Firmware/LUFA/CodeTemplates/HostTemplate/HostApplication.c", "commit_date": "2016-10-07 00:00:00", "repo_name": "emsec/ChameleonMini", "stars": 1669, "license": "other", "language": "c", "size": 11090}
{"docstring": "/* parses a line of intel hex code, stores the data in bytes[] */\n/* and the beginning address in addr, and returns a 1 if the */\n/* line was valid, or a 0 if an error occurred.  The variable */\n/* num gets the number of bytes that were stored into bytes[] */\n", "func_signal": "int\nparse_hex_line(char *line)", "code": "{\n\tint addr, code, num;\n        int sum, len, cksum, i;\n        char *ptr;\n\n        num = 0;\n        if (line[0] != ':') return 0;\n        if (strlen(line) < 11) return 0;\n        ptr = line+1;\n        if (!sscanf(ptr, \"%02x\", &len)) return 0;\n        ptr += 2;\n        if ((int)strlen(line) < (11 + (len * 2)) ) return 0;\n        if (!sscanf(ptr, \"%04x\", &addr)) return 0;\n        ptr += 4;\n          /* printf(\"Line: length=%d Addr=%d\\n\", len, addr); */\n        if (!sscanf(ptr, \"%02x\", &code)) return 0;\n\tif (addr + extended_addr + len >= MAX_MEMORY_SIZE) return 0;\n        ptr += 2;\n        sum = (len & 255) + ((addr >> 8) & 255) + (addr & 255) + (code & 255);\n\tif (code != 0) {\n\t\tif (code == 1) {\n\t\t\tend_record_seen = 1;\n\t\t\treturn 1;\n\t\t}\n\t\tif (code == 2 && len == 2) {\n\t\t\tif (!sscanf(ptr, \"%04x\", &i)) return 1;\n\t\t\tptr += 4;\n\t\t\tsum += ((i >> 8) & 255) + (i & 255);\n        \t\tif (!sscanf(ptr, \"%02x\", &cksum)) return 1;\n\t\t\tif (((sum & 255) + (cksum & 255)) & 255) return 1;\n\t\t\textended_addr = i << 4;\n\t\t\t//printf(\"ext addr = %05X\\n\", extended_addr);\n\t\t}\n\t\tif (code == 4 && len == 2) {\n\t\t\tif (!sscanf(ptr, \"%04x\", &i)) return 1;\n\t\t\tptr += 4;\n\t\t\tsum += ((i >> 8) & 255) + (i & 255);\n        \t\tif (!sscanf(ptr, \"%02x\", &cksum)) return 1;\n\t\t\tif (((sum & 255) + (cksum & 255)) & 255) return 1;\n\t\t\textended_addr = i << 16;\n\t\t\t//printf(\"ext addr = %08X\\n\", extended_addr);\n\t\t}\n\t\treturn 1;\t// non-data line\n\t}\n\tbyte_count += len;\n        while (num != len) {\n                if (sscanf(ptr, \"%02x\", &i) != 1) return 0;\n\t\ti &= 255;\n\t\tfirmware_image[addr + extended_addr + num] = i;\n\t\tfirmware_mask[addr + extended_addr + num] = 1;\n                ptr += 2;\n                sum += i;\n                (num)++;\n                if (num >= 256) return 0;\n        }\n        if (!sscanf(ptr, \"%02x\", &cksum)) return 0;\n        if (((sum & 255) + (cksum & 255)) & 255) return 0; /* checksum error */\n        return 1;\n}", "path": "ChameleonMini/Firmware/LUFA/Bootloaders/HID/HostLoaderApp/hid_bootloader_cli.c", "commit_date": "2016-10-07 00:00:00", "repo_name": "emsec/ChameleonMini", "stars": 1669, "license": "other", "language": "c", "size": 11090}
{"docstring": "/** Configures the board hardware and chip peripherals for the demo's functionality. */\n", "func_signal": "void SetupHardware(void)", "code": "{\n\t#if (ARCH == ARCH_AVR8)\n\t\t/* Disable watchdog if enabled by bootloader/fuses */\n\t\tMCUSR &= ~(1 << WDRF);\n\t\twdt_disable();\n\n\t\t/* Disable clock division */\n\t\tclock_prescale_set(clock_div_1);\n\n\t\t/* Hardware Initialization */\n\t\tUSB_Init(USB_MODE_Device, USB_DEVICE_OPT_FULLSPEED | USB_OPT_AUTO_PLL);\n\t#elif (ARCH == ARCH_XMEGA)\n\t\t/* Start the PLL to multiply the 2MHz RC oscillator to 32MHz and switch the CPU core to run from it */\n\t\tXMEGACLK_StartPLL(CLOCK_SRC_INT_RC2MHZ, 2000000, F_CPU);\n\t\tXMEGACLK_SetCPUClockSource(CLOCK_SRC_PLL);\n\n\t\t/* Start the 32MHz internal RC oscillator and start the DFLL to increase it to 48MHz using the USB SOF as a reference */\n\t\tXMEGACLK_StartInternalOscillator(CLOCK_SRC_INT_RC32MHZ);\n\t\tXMEGACLK_StartDFLL(CLOCK_SRC_INT_RC32MHZ, DFLL_REF_INT_USBSOF, F_USB);\n\n\t\tPMIC.CTRL = PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_HILVLEN_bm;\n\n\t\t/* Hardware Initialization */\n\t\tUSB_Init(USB_OPT_RC32MCLKSRC | USB_OPT_BUSEVENT_PRIHIGH);\n\t#endif\n}", "path": "ChameleonMini/RevE/Firmware/LUFA/CodeTemplates/DeviceTemplate/DeviceApplication.c", "commit_date": "2016-10-07 00:00:00", "repo_name": "emsec/ChameleonMini", "stars": 1669, "license": "other", "language": "c", "size": 11090}
{"docstring": "/* Keys are stored in little Endian Order but we need them in Big  */\n", "func_signal": "static void rotateKey(uint8_t *Key)", "code": "{\n    uint8_t tmpstorage [8] ;\n    tmpstorage [0] = Key[7];\n    tmpstorage [1] = Key[6];\n    tmpstorage [2] = Key[5];\n    tmpstorage [3] = Key[4];\n    tmpstorage [4] = Key[3];\n    tmpstorage [5] = Key[2];\n    tmpstorage [6] = Key[1];\n    tmpstorage [7] = Key[0];\n    memcpy(Key, tmpstorage, 8);\n}", "path": "ChameleonMini/Firmware/Chameleon-Mini/Application/MifareUltralight.c", "commit_date": "2020-10-17 00:00:00", "repo_name": "emsec/ChameleonMini", "stars": 1669, "license": "other", "language": "c", "size": 11090}
{"docstring": "/****************************************************************/\n/*                                                              */\n/*                       Misc Functions                         */\n/*                                                              */\n/****************************************************************/\n", "func_signal": "int printf_verbose(const char *format, ...)", "code": "{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, format);\n\tif (verbose) {\n\t\tr = vprintf(format, ap);\n\t\tfflush(stdout);\n\t\treturn r;\n\t}\n\treturn 0;\n}", "path": "ChameleonMini/Firmware/LUFA/Bootloaders/HID/HostLoaderApp/hid_bootloader_cli.c", "commit_date": "2016-10-07 00:00:00", "repo_name": "emsec/ChameleonMini", "stars": 1669, "license": "other", "language": "c", "size": 11090}
{"docstring": "/** Event handler for the USB_DeviceEnumerationComplete event. This indicates that a device has been successfully\n *  enumerated by the host and is now ready to be used by the application.\n */\n", "func_signal": "void EVENT_USB_Host_DeviceEnumerationComplete(void)", "code": "{\n\tuint16_t ConfigDescriptorSize;\n\tuint8_t  ConfigDescriptorData[512];\n\n\tif (USB_Host_GetDeviceConfigDescriptor(1, &ConfigDescriptorSize, ConfigDescriptorData,\n\t                                       sizeof(ConfigDescriptorData)) != HOST_GETCONFIG_Successful)\n\t{\n\t\treturn;\n\t}\n\n\tif (USB_Host_SetDeviceConfiguration(1) != HOST_SENDCONTROL_Successful)\n\t{\n\t\treturn;\n\t}\n}", "path": "ChameleonMini/RevE/Firmware/LUFA/CodeTemplates/HostTemplate/HostApplication.c", "commit_date": "2016-10-07 00:00:00", "repo_name": "emsec/ChameleonMini", "stars": 1669, "license": "other", "language": "c", "size": 11090}
{"docstring": "/** This function is called by the library when in device mode, and must be overridden (see library \"USB Descriptors\"\n *  documentation) by the application code so that the address and size of a requested descriptor can be given\n *  to the USB library. When the device receives a Get Descriptor request on the control endpoint, this function\n *  is called so that the descriptor details can be passed back and the appropriate descriptor sent back to the\n *  USB host.\n */\n", "func_signal": "uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,\n                                    const uint8_t wIndex,\n                                    const void** const DescriptorAddress)", "code": "{\n    const uint8_t  DescriptorType   = (wValue >> 8);\n    const uint8_t  DescriptorNumber = (wValue & 0xFF);\n\n    const void* Address = NULL;\n    uint16_t    Size    = NO_DESCRIPTOR;\n\n    switch (DescriptorType)\n    {\n        case DTYPE_Device:\n            Address = &DeviceDescriptor;\n            Size    = sizeof(USB_Descriptor_Device_t);\n            break;\n        case DTYPE_Configuration:\n            Address = &ConfigurationDescriptor;\n            Size    = sizeof(USB_Descriptor_Configuration_t);\n            break;\n        case DTYPE_String:\n            switch (DescriptorNumber)\n            {\n                case 0x00:\n                    Address = &LanguageString;\n                    Size    = pgm_read_byte(&LanguageString.Header.Size);\n                    break;\n                case 0x01:\n                    Address = &ManufacturerString;\n                    Size    = pgm_read_byte(&ManufacturerString.Header.Size);\n                    break;\n                case 0x02:\n                    Address = &ProductString;\n                    Size    = pgm_read_byte(&ProductString.Header.Size);\n                    break;\n            }\n\n            break;\n    }\n\n    *DescriptorAddress = Address;\n    return Size;\n}", "path": "ChameleonMini/RevE/Firmware/Chameleon-Mini/LUFADescriptors.c", "commit_date": "2016-10-07 00:00:00", "repo_name": "emsec/ChameleonMini", "stars": 1669, "license": "other", "language": "c", "size": 11090}
{"docstring": "// ISR (TCD0_CCC_vect)\n// Frame Delay Time PCD to PICC ends\n", "func_signal": "ISR_SHARED isr_Reader14443_2A_TCD0_CCC_vect(void)", "code": "{\n    CODEC_TIMER_SAMPLING.INTFLAGS = TC0_CCCIF_bm;\n    CODEC_TIMER_SAMPLING.INTCTRLB = TC_CCCINTLVL_OFF_gc;\n\n    /* Enable the AC interrupt, which either finds the SOC and then starts the pause-finding timer,\n     * or it is triggered before the SOC, which mostly isn't bad at all, since the first pause\n     * needs to be found. */\n    ACA.STATUS = AC_AC1IF_bm;\n    ACA.AC1CTRL = AC_HSMODE_bm | AC_HYSMODE_NO_gc | AC_INTMODE_FALLING_gc | AC_INTLVL_HI_gc | AC_ENABLE_bm;\n\n    CodecBufferPtr = CodecBuffer; // use GPIOR for faster access\n    BitCount = 1; // FALSCH todo the first modulation of the SOC is \"found\" implicitly\n    SampleRegister = 0x00;\n\n    RxPendingSince = SystemGetSysTick();\n    Flags.RxPending = true;\n\n    // reset for future use\n    CodecBufferIdx = 0;\n    BitCountUp = 0;\n\n    State = STATE_IDLE;\n    PORTE.OUTTGL = PIN3_bm;\n}", "path": "ChameleonMini/Firmware/Chameleon-Mini/Codec/Reader14443-2A.c", "commit_date": "2019-12-08 00:00:00", "repo_name": "emsec/ChameleonMini", "stars": 1669, "license": "other", "language": "c", "size": 11090}
{"docstring": "// Decode the Card -> Reader signal\n// according to the pause and modulated period\n// if the half bit duration is modulated, then add 1 to buffer\n// if the half bit duration is not modulated, then add 0 to buffer\n", "func_signal": "ISR(CODEC_TIMER_LOADMOD_CCA_VECT)", "code": "{ // pause found\n    uint8_t tmp = CODEC_TIMER_TIMESTAMPS.CNTL;\n    CODEC_TIMER_TIMESTAMPS.CNT = 0;\n\n    /* This needs to be done only on the first call,\n     * but doing this only on a condition means wasting time, so we do it every time. */\n    CODEC_TIMER_TIMESTAMPS.CTRLA = TC_CLKSEL_DIV4_gc;\n\n    switch (tmp) { // decide how many half bit periods have been modulations\n        case 0 ... 48: // 32 ticks is one half of a bit period\n            return;\n\n        case 49 ... 80: // 64 ticks are a full bit period\n            Insert1();\n            Insert0();\n            return;\n\n        case 81 ... 112: // 96 ticks are 3 half bit periods\n            if (BitCount & 1) {\n                Insert1();\n                Insert1();\n                Insert0();\n            } else {\n                Insert1();\n                Insert0();\n                Insert0();\n            }\n            return;\n\n        default: // every value over 96 + 16 (tolerance) is considered to be 4 half bit periods\n            Insert1();\n            Insert1();\n            Insert0();\n            Insert0();\n            return;\n    }\n    return;\n}", "path": "ChameleonMini/Firmware/Chameleon-Mini/Codec/Reader14443-2A.c", "commit_date": "2019-12-08 00:00:00", "repo_name": "emsec/ChameleonMini", "stars": 1669, "license": "other", "language": "c", "size": 11090}
{"docstring": "/*\n * File management: creation, deletion, and misc routines\n */\n", "func_signal": "uint16_t GetFileDataAreaBlockId(uint8_t fileIndex)", "code": "{\n     SIZET fileStructAddr = ReadFileDataStructAddress(SelectedApp.Slot, fileIndex);\n     if(fileStructAddr == 0) {\n         return 0;\n     }\n     DESFireFileTypeSettings FileData;\n     MemoryReadBlock(&FileData, fileStructAddr, sizeof(DESFireFileTypeSettings));\n     return FileData.FileDataAddress;\n}", "path": "ChameleonMini/Firmware/Chameleon-Mini/Application/DESFire/DESFireFile.c", "commit_date": "2020-10-17 00:00:00", "repo_name": "emsec/ChameleonMini", "stars": 1669, "license": "other", "language": "c", "size": 11090}
{"docstring": "/* Handles processing of MF commands */\n", "func_signal": "static uint16_t AppProcess(uint8_t *const Buffer, uint16_t ByteCount)", "code": "{\n    uint8_t Cmd = Buffer[0];\n\n    /* Handle the compatibility write command */\n    if (ArmedForCompatWrite) {\n        ArmedForCompatWrite = false;\n\n        //Handle MF ULC counter\n        if (CompatWritePageAddress == MF_ULC_COUNTER_ADDRESS && Flavor == UL_C) {\n            if (IncrementCounter(&Buffer[0])) {\n                Buffer[0] = ACK_VALUE;\n                return ACK_FRAME_SIZE;\n            } else {\n                Buffer[0] = NAK_INVALID_ARG;\n                return NAK_FRAME_SIZE;\n            }\n        }\n\n        AppWritePage(CompatWritePageAddress, &Buffer[0]);\n        Buffer[0] = ACK_VALUE;\n        return ACK_FRAME_SIZE;\n    }\n\n    /* Handle EV0 commands */\n    switch (Cmd) {\n\n        case CMD_READ: {\n            uint8_t PageAddress = Buffer[1];\n            uint8_t PageLimit;\n            uint8_t Offset;\n            /* For EV1+ cards, ensure the wraparound is at the first protected page */\n            if (Flavor >= UL_C && ReadAccessProtected && !Authenticated) {\n                PageLimit = FirstAuthenticatedPage;\n            } else {\n                if (Flavor == UL_C) PageLimit = MF_ULC_READ_MAX_PAGE; // For ULC make sure wraparound is at the first key page\n                else PageLimit = PageCount;\n            }\n            /* Validation */\n            if (PageAddress >= PageLimit) {\n                Buffer[0] = NAK_INVALID_ARG;\n                return NAK_FRAME_SIZE;\n            }\n            /* Read out, emulating the wraparound */\n            for (Offset = 0; Offset < BYTES_PER_READ; Offset += 4) {\n                MemoryReadBlock(&Buffer[Offset], PageAddress * MIFARE_ULTRALIGHT_PAGE_SIZE, MIFARE_ULTRALIGHT_PAGE_SIZE);\n                PageAddress++;\n                if (PageAddress == PageLimit) {\n                    PageAddress = 0;\n                }\n            }\n            ISO14443AAppendCRCA(Buffer, BYTES_PER_READ);\n            return (BYTES_PER_READ + ISO14443A_CRCA_SIZE) * 8;\n        }\n\n        case CMD_WRITE: {\n            /* This is a write command containing 4 bytes of data that\n            * should be written to the given page address. */\n            uint8_t PageAddress = Buffer[1];\n\n            //Handle MF ULC counter\n            if (PageAddress == MF_ULC_COUNTER_ADDRESS && Flavor == UL_C) {\n                if (IncrementCounter(&Buffer[2])) {\n                    Buffer[0] = ACK_VALUE;\n                    return ACK_FRAME_SIZE;\n                } else {\n                    Buffer[0] = NAK_INVALID_ARG;\n                    return NAK_FRAME_SIZE;\n                }\n            }\n\n            /* Validation */\n            if ((PageAddress < PAGE_WRITE_MIN) || (PageAddress >= PageCount)) {\n                Buffer[0] = NAK_INVALID_ARG;\n                return NAK_FRAME_SIZE;\n            }\n            if (!VerifyAuthentication(PageAddress)) {\n                Buffer[0] = NAK_AUTH_REQUIRED;\n                return NAK_FRAME_SIZE;\n            }\n            AppWritePage(PageAddress, &Buffer[2]);\n            Buffer[0] = ACK_VALUE;\n            return ACK_FRAME_SIZE;\n        }\n\n        case CMD_COMPAT_WRITE: {\n            uint8_t PageAddress = Buffer[1];\n            /* Validation */\n            if ((PageAddress < PAGE_WRITE_MIN) || (PageAddress >= PageCount)) {\n                Buffer[0] = NAK_INVALID_ARG;\n                return NAK_FRAME_SIZE;\n            }\n            if (!VerifyAuthentication(PageAddress)) {\n                Buffer[0] = NAK_AUTH_REQUIRED;\n                return NAK_FRAME_SIZE;\n            }\n            /* CRC check passed and page-address is within bounds.\n            * Store address and proceed to receiving the data. */\n            CompatWritePageAddress = PageAddress;\n            ArmedForCompatWrite = true;\n            Buffer[0] = ACK_VALUE;\n            return ACK_FRAME_SIZE;\n        }\n\n        case CMD_HALT: {\n            /* Halts the tag. According to the ISO14443, the second\n            * byte is supposed to be 0. */\n            if (Buffer[1] == 0) {\n                /* According to ISO14443, we must not send anything\n                * in order to acknowledge the HALT command. */\n                State = STATE_HALT;\n                return ISO14443A_APP_NO_RESPONSE;\n            } else {\n                Buffer[0] = NAK_INVALID_ARG;\n                return NAK_FRAME_SIZE;\n            }\n        }\n        default:\n            break;\n    }\n    if (Flavor == UL_C) {\n        if (Cmd == CMD_ULC_AUTH) {\n            State = STATE_AUTH;\n\n            RandomGetBuffer(RNDBBuff, 8); // Get Random Number\n            memset(InitialVector, 0, 8);  // initialize InitialVector\n            CryptoEncrypt2KTDEA_CBCSend(1, RNDBBuff, &Buffer[1], InitialVector, TripleDesKey); // Crypt\n\n            Buffer [0] = CMD_ULC_AUTH_2 ;\n            ISO14443AAppendCRCA(Buffer, 9);\n            return (9 + ISO14443A_CRCA_SIZE) * 8;\n        }\n    }\n    /* Handle EV1 commands */\n    if (Flavor >= UL_EV1) {\n        switch (Cmd) {\n\n            case CMD_GET_VERSION: {\n                /* Provide hardcoded version response */\n                Buffer[0] = 0x00;\n                Buffer[1] = 0x04;\n                Buffer[2] = 0x03;\n                Buffer[3] = 0x01; /**/\n                Buffer[4] = 0x01;\n                Buffer[5] = 0x00;\n                Buffer[6] = PageCount == MIFARE_ULTRALIGHT_EV11_PAGES ? 0x0B : 0x0E;\n                Buffer[7] = 0x03;\n                ISO14443AAppendCRCA(Buffer, VERSION_INFO_LENGTH);\n                return (VERSION_INFO_LENGTH + ISO14443A_CRCA_SIZE) * 8;\n            }\n\n            case CMD_FAST_READ: {\n                uint8_t StartPageAddress = Buffer[1];\n                uint8_t EndPageAddress = Buffer[2];\n                /* Validation */\n                if ((StartPageAddress > EndPageAddress) || (StartPageAddress >= PageCount) || (EndPageAddress >= PageCount)) {\n                    Buffer[0] = NAK_INVALID_ARG;\n                    return NAK_FRAME_SIZE;\n                }\n                /* Check authentication only if protection is read&write */\n                if (ReadAccessProtected) {\n                    if (!VerifyAuthentication(StartPageAddress) || !VerifyAuthentication(EndPageAddress)) {\n                        Buffer[0] = NAK_AUTH_REQUIRED;\n                        return NAK_FRAME_SIZE;\n                    }\n                }\n                /* NOTE: With the current implementation, reading the password out is possible. */\n                ByteCount = (EndPageAddress - StartPageAddress + 1) * MIFARE_ULTRALIGHT_PAGE_SIZE;\n                MemoryReadBlock(Buffer, StartPageAddress * MIFARE_ULTRALIGHT_PAGE_SIZE, ByteCount);\n                ISO14443AAppendCRCA(Buffer, ByteCount);\n                return (ByteCount + ISO14443A_CRCA_SIZE) * 8;\n            }\n\n            case CMD_PWD_AUTH: {\n                uint8_t ConfigAreaAddress = PageCount * MIFARE_ULTRALIGHT_PAGE_SIZE - CONFIG_AREA_SIZE;\n                uint8_t Password[4];\n\n                /* Verify value and increment authentication attempt counter */\n                if (!AuthCounterIncrement()) {\n                    /* Too many failed attempts */\n                    Buffer[0] = NAK_AUTH_FAILED;\n                    return NAK_FRAME_SIZE;\n                }\n                /* Read and compare the password */\n                MemoryReadBlock(Password, ConfigAreaAddress + CONF_PASSWORD_OFFSET, 4);\n                if (Password[0] != Buffer[1] || Password[1] != Buffer[2] || Password[2] != Buffer[3] || Password[3] != Buffer[4]) {\n                    Buffer[0] = NAK_AUTH_FAILED;\n                    return NAK_FRAME_SIZE;\n                }\n                /* Authenticate the user */\n                AuthCounterReset();\n                Authenticated = 1;\n                /* Send the PACK value back */\n                MemoryReadBlock(Buffer, ConfigAreaAddress + CONF_PACK_OFFSET, 2);\n                ISO14443AAppendCRCA(Buffer, 2);\n                return (2 + ISO14443A_CRCA_SIZE) * 8;\n            }\n\n            case CMD_READ_CNT: {\n                uint8_t CounterId = Buffer[1];\n                /* Validation */\n                if (CounterId > CNT_MAX) {\n                    Buffer[0] = NAK_INVALID_ARG;\n                    return NAK_FRAME_SIZE;\n                }\n                /* Returned counter length is 3 bytes */\n                MemoryReadBlock(Buffer, (PageCount + CounterId) * MIFARE_ULTRALIGHT_PAGE_SIZE, 3);\n                ISO14443AAppendCRCA(Buffer, 3);\n                return (3 + ISO14443A_CRCA_SIZE) * 8;\n            }\n\n            case CMD_INCREMENT_CNT: {\n                uint8_t CounterId = Buffer[1];\n                uint32_t Addend = (Buffer[0]) | (Buffer[1] << 8) | ((uint32_t)Buffer[2] << 16);\n                uint32_t Counter;\n                /* Validation */\n                if (CounterId > CNT_MAX) {\n                    Buffer[0] = NAK_INVALID_ARG;\n                    return NAK_FRAME_SIZE;\n                }\n                /* Read the value out */\n                MemoryReadBlock(&Counter, (PageCount + CounterId) * MIFARE_ULTRALIGHT_PAGE_SIZE, MIFARE_ULTRALIGHT_PAGE_SIZE);\n                /* Add and check for overflow */\n                Counter += Addend;\n                if (Counter > CNT_MAX_VALUE) {\n                    Buffer[0] = NAK_CTR_ERROR;\n                    return NAK_FRAME_SIZE;\n                }\n                /* Update memory */\n                MemoryWriteBlock(&Counter, (PageCount + CounterId) * MIFARE_ULTRALIGHT_PAGE_SIZE, MIFARE_ULTRALIGHT_PAGE_SIZE);\n                Buffer[0] = ACK_VALUE;\n                return ACK_FRAME_SIZE;\n            }\n\n            case CMD_READ_SIG:\n                /* Hardcoded response */\n                memset(Buffer, 0xCA, SIGNATURE_LENGTH);\n                ISO14443AAppendCRCA(Buffer, SIGNATURE_LENGTH);\n                return (SIGNATURE_LENGTH + ISO14443A_CRCA_SIZE) * 8;\n\n            case CMD_CHECK_TEARING_EVENT:\n                /* Hardcoded response */\n                Buffer[0] = 0xBD;\n                ISO14443AAppendCRCA(Buffer, 1);\n                return (1 + ISO14443A_CRCA_SIZE) * 8;\n\n            case CMD_VCSL: {\n                uint8_t ConfigAreaAddress = PageCount * MIFARE_ULTRALIGHT_PAGE_SIZE - CONFIG_AREA_SIZE;\n                /* Input is ignored completely */\n                /* Read out the value */\n                MemoryReadBlock(Buffer, ConfigAreaAddress + CONF_VCTID_OFFSET, 1);\n                ISO14443AAppendCRCA(Buffer, 1);\n                return (1 + ISO14443A_CRCA_SIZE) * 8;\n            }\n\n            default:\n                break;\n        }\n    }\n    /* Command not handled. Switch to idle. */\n    State = STATE_IDLE;\n    return ISO14443A_APP_NO_RESPONSE;\n}", "path": "ChameleonMini/Firmware/Chameleon-Mini/Application/MifareUltralight.c", "commit_date": "2020-10-17 00:00:00", "repo_name": "emsec/ChameleonMini", "stars": 1669, "license": "other", "language": "c", "size": 11090}
{"docstring": "// Reader -> card send bits finished\n// Start Frame delay time PCD to PICC\n", "func_signal": "void Reader14443AMillerEOC(void)", "code": "{\n    CODEC_TIMER_SAMPLING.PER = 5 * SAMPLE_RATE_SYSTEM_CYCLES - 1;\n    CODEC_TIMER_SAMPLING.INTFLAGS = TC0_CCBIF_bm | TC0_CCCIF_bm;\n    CODEC_TIMER_SAMPLING.INTCTRLB = TC_CCBINTLVL_OFF_gc | TC_CCCINTLVL_HI_gc;\n    CODEC_TIMER_SAMPLING.PERBUF = SAMPLE_RATE_SYSTEM_CYCLES - 1;\n    PORTE.OUTTGL = PIN3_bm;\n}", "path": "ChameleonMini/Firmware/Chameleon-Mini/Codec/Reader14443-2A.c", "commit_date": "2019-12-08 00:00:00", "repo_name": "emsec/ChameleonMini", "stars": 1669, "license": "other", "language": "c", "size": 11090}
{"docstring": "/* Common function for creating a context from options.\n * We must NOT free a SSL_CTX with only SSL_CTX_free! Also free any password */\n", "func_signal": "void free_ssl_context(SSL_CTX *ssl_context)", "code": "{\n    if (!ssl_context) {\n        return;\n    }\n\n    /* If we have set a password string, free it here */\n    void *password = SSL_CTX_get_default_passwd_cb_userdata(ssl_context);\n    /* OpenSSL returns NULL if we have no set password */\n    free(password);\n\n    SSL_CTX_free(ssl_context);\n}", "path": "uSockets/src/crypto/openssl.c", "commit_date": "2020-09-05 00:00:00", "repo_name": "uNetworking/uSockets", "stars": 1190, "license": "apache-2.0", "language": "c", "size": 855}
{"docstring": "/* Not shared with SSL */\n", "func_signal": "void *us_socket_get_native_handle(int ssl, struct us_socket_t *s)", "code": "{\n#ifndef LIBUS_NO_SSL\n    if (ssl) {\n        return us_internal_ssl_socket_get_native_handle((struct us_internal_ssl_socket_t *) s);\n    }\n#endif\n\n    return (void *) (uintptr_t) us_poll_fd((struct us_poll_t *) s);\n}", "path": "uSockets/src/socket.c", "commit_date": "2020-08-24 00:00:00", "repo_name": "uNetworking/uSockets", "stars": 1190, "license": "apache-2.0", "language": "c", "size": 855}
{"docstring": "/* Returns NULL or SSL_CTX. May call missing server name callback */\n", "func_signal": "SSL_CTX *resolve_context(struct us_internal_ssl_socket_context_t *context, const char *hostname)", "code": "{\n\n    /* Try once first */\n    void *user = sni_find(context->sni, hostname);\n    if (!user) {\n        /* Emit missing hostname then try again */\n        if (!context->on_server_name) {\n            /* We have no callback registered, so fail */\n            return NULL;\n        }\n\n        context->on_server_name(context, hostname);\n\n        /* Last try */\n        user = sni_find(context->sni, hostname);\n    }\n\n    return user;\n}", "path": "uSockets/src/crypto/openssl.c", "commit_date": "2020-09-05 00:00:00", "repo_name": "uNetworking/uSockets", "stars": 1190, "license": "apache-2.0", "language": "c", "size": 855}
{"docstring": "// this whole function needs a complete clean-up\n", "func_signal": "struct us_internal_ssl_socket_t *ssl_on_data(struct us_internal_ssl_socket_t *s, void *data, int length)", "code": "{\n    // note: this context can change when we adopt the socket!\n    struct us_internal_ssl_socket_context_t *context = (struct us_internal_ssl_socket_context_t *) us_socket_context(0, &s->s);\n\n    struct us_loop_t *loop = us_socket_context_loop(0, &context->sc);\n    struct loop_ssl_data *loop_ssl_data = (struct loop_ssl_data *) loop->data.ssl_data;\n\n    // note: if we put data here we should never really clear it (not in write either, it still should be available for SSL_write to read from!)\n    loop_ssl_data->ssl_read_input = data;\n    loop_ssl_data->ssl_read_input_length = length;\n    loop_ssl_data->ssl_read_input_offset = 0;\n    loop_ssl_data->ssl_socket = &s->s;\n    loop_ssl_data->msg_more = 0;\n\n    if (us_internal_ssl_socket_is_shut_down(s)) {\n\n        int ret;\n        if ((ret = SSL_shutdown(s->ssl)) == 1) {\n            // two phase shutdown is complete here\n            //printf(\"Two step SSL shutdown complete\\n\");\n\n            /* Todo: this should also report some kind of clean shutdown */\n            return us_internal_ssl_socket_close(s, 0, NULL);\n        } else if (ret < 0) {\n\n            int err = SSL_get_error(s->ssl, ret);\n\n            if (err == SSL_ERROR_SSL || err == SSL_ERROR_SYSCALL) {\n                // we need to clear the error queue in case these added to the thread local queue\n                ERR_clear_error();\n            }\n\n        }\n\n        // no further processing of data when in shutdown state\n        return s;\n    }\n\n    // bug checking: this loop needs a lot of attention and clean-ups and check-ups\n    int read = 0;\n    restart:\n    while (1) {\n        int just_read = SSL_read(s->ssl, loop_ssl_data->ssl_read_output + LIBUS_RECV_BUFFER_PADDING + read, LIBUS_RECV_BUFFER_LENGTH - read);\n\n        if (just_read <= 0) {\n            int err = SSL_get_error(s->ssl, just_read);\n\n            // as far as I know these are the only errors we want to handle\n            if (err != SSL_ERROR_WANT_READ && err != SSL_ERROR_WANT_WRITE) {\n\n                // clear per thread error queue if it may contain something\n                if (err == SSL_ERROR_SSL || err == SSL_ERROR_SYSCALL) {\n                    ERR_clear_error();\n                }\n\n                // terminate connection here\n                return us_internal_ssl_socket_close(s, 0, NULL);\n            } else {\n                // emit the data we have and exit\n\n                // assume we emptied the input buffer fully or error here as well!\n                if (loop_ssl_data->ssl_read_input_length) {\n                    return us_internal_ssl_socket_close(s, 0, NULL);\n                }\n\n                // cannot emit zero length to app\n                if (!read) {\n                    break;\n                }\n\n                s = context->on_data(s, loop_ssl_data->ssl_read_output + LIBUS_RECV_BUFFER_PADDING, read);\n                if (us_socket_is_closed(0, &s->s)) {\n                    return s;\n                }\n\n                break;\n            }\n\n        }\n\n        read += just_read;\n\n        // at this point we might be full and need to emit the data to application and start over\n        if (read == LIBUS_RECV_BUFFER_LENGTH) {\n\n            // emit data and restart\n            s = context->on_data(s, loop_ssl_data->ssl_read_output + LIBUS_RECV_BUFFER_PADDING, read);\n            if (us_socket_is_closed(0, &s->s)) {\n                return s;\n            }\n\n            read = 0;\n            goto restart;\n        }\n    }\n\n    // trigger writable if we failed last write with want read\n    if (s->ssl_write_wants_read) {\n        s->ssl_write_wants_read = 0;\n\n        // make sure to update context before we call (context can change if the user adopts the socket!)\n        context = (struct us_internal_ssl_socket_context_t *) us_socket_context(0, &s->s);\n\n        s = (struct us_internal_ssl_socket_t *) context->sc.on_writable(&s->s); // cast here!\n        // if we are closed here, then exit\n        if (us_socket_is_closed(0, &s->s)) {\n            return s;\n        }\n    }\n\n    // check this then?\n    if (SSL_get_shutdown(s->ssl) & SSL_RECEIVED_SHUTDOWN) {\n        //printf(\"SSL_RECEIVED_SHUTDOWN\\n\");\n\n        //exit(-2);\n\n        // not correct anyways!\n        s = us_internal_ssl_socket_close(s, 0, NULL);\n\n        //us_\n    }\n\n    return s;\n}", "path": "uSockets/src/crypto/openssl.c", "commit_date": "2020-09-05 00:00:00", "repo_name": "uNetworking/uSockets", "stars": 1190, "license": "apache-2.0", "language": "c", "size": 855}
{"docstring": "/* Socket writable handler */\n", "func_signal": "struct us_socket_t *on_echo_socket_writable(struct us_socket_t *s)", "code": "{\n\tstruct echo_socket *es = (struct echo_socket *) us_socket_ext(SSL, s);\n\n\t/* Continue writing out our backpressure */\n\tint written = us_socket_write(SSL, s, es->backpressure, es->length, 0);\n\tif (written != es->length) {\n\t\tchar *new_buffer = (char *) malloc(es->length - written);\n\t\tmemcpy(new_buffer, es->backpressure, es->length - written);\n\t\tfree(es->backpressure);\n\t\tes->backpressure = new_buffer;\n\t\tes->length -= written;\n\t} else {\n\t\tfree(es->backpressure);\n\t\tes->length = 0;\n\t}\n\n\t/* Client is not boring */\n\tus_socket_timeout(SSL, s, 30);\n\n\treturn s;\n}", "path": "uSockets/examples/echo_server.c", "commit_date": "2020-06-26 00:00:00", "repo_name": "uNetworking/uSockets", "stars": 1190, "license": "apache-2.0", "language": "c", "size": 855}
{"docstring": "// todo: it would be nice to randomly select socket instead of\n// using the one responsible for the event\n", "func_signal": "struct us_socket_t *perform_random_operation(struct us_socket_t *s)", "code": "{\n    switch (rand() % 5) {\n        case 0: {\n            // close\n            return us_socket_close(SSL, s, 0, NULL);\n        }\n        case 1: {\n            // adoption cannot happen if closed!\n            if (!us_socket_is_closed(SSL, s)) {\n                if (rand() % 2) {\n                    s = us_socket_context_adopt_socket(SSL, websocket_context, s, sizeof(struct web_socket));\n                    struct http_socket *hs = (struct http_socket *) us_socket_ext(SSL, s);\n                    hs->is_http = 0;\n                } else {\n                    s = us_socket_context_adopt_socket(SSL, http_context, s, sizeof(struct http_socket));\n                    struct http_socket *hs = (struct http_socket *) us_socket_ext(SSL, s);\n                    hs->is_http = 1;\n                }\n            }\n\n            return perform_random_operation(s);\n        }\n        case 2: {\n            // write\n            us_socket_write(SSL, s, (char *) long_buffer, rand() % long_length, 0);\n        }\n        break;\n        case 3: {\n            // shutdown\n            us_socket_shutdown(SSL, s);\n        }\n        break;\n        case 4: {\n            // loop wakeup and timeout sweep\n            us_socket_timeout(SSL, s, 1);\n            us_wakeup_loop(us_socket_context_loop(SSL, us_socket_context(SSL, s)));\n        }\n        break;\n    }\n    return s;\n}", "path": "uSockets/examples/hammer_test.c", "commit_date": "2020-06-26 00:00:00", "repo_name": "uNetworking/uSockets", "stars": 1190, "license": "apache-2.0", "language": "c", "size": 855}
{"docstring": "// called by dispatch_ready_poll\n", "func_signal": "LIBUS_SOCKET_DESCRIPTOR bsd_accept_socket(LIBUS_SOCKET_DESCRIPTOR fd, struct bsd_addr_t *addr)", "code": "{\n    LIBUS_SOCKET_DESCRIPTOR accepted_fd;\n    addr->len = sizeof(addr->mem);\n\n#if defined(SOCK_CLOEXEC) && defined(SOCK_NONBLOCK)\n    // Linux, FreeBSD\n    accepted_fd = accept4(fd, (struct sockaddr *) addr, &addr->len, SOCK_CLOEXEC | SOCK_NONBLOCK);\n#else\n    // Windows, OS X\n    accepted_fd = accept(fd, (struct sockaddr *) addr, &addr->len);\n\n#endif\n\n    /* We cannot rely on addr since it is not initialized if failed */\n    if (accepted_fd == LIBUS_SOCKET_ERROR) {\n        return LIBUS_SOCKET_ERROR;\n    }\n\n    internal_finalize_bsd_addr(addr);\n\n    return bsd_set_nonblocking(apple_no_sigpipe(accepted_fd));\n}", "path": "uSockets/src/bsd.c", "commit_date": "2020-08-24 00:00:00", "repo_name": "uNetworking/uSockets", "stars": 1190, "license": "apache-2.0", "language": "c", "size": 855}
{"docstring": "/* Socket timeout handler */\n", "func_signal": "struct us_socket_t *on_echo_socket_timeout(struct us_socket_t *s)", "code": "{\n\tprintf(\"Client was idle for too long\\n\");\n\treturn us_socket_close(SSL, s, 0, NULL);\n}", "path": "uSockets/examples/echo_server.c", "commit_date": "2020-06-26 00:00:00", "repo_name": "uNetworking/uSockets", "stars": 1190, "license": "apache-2.0", "language": "c", "size": 855}
{"docstring": "/* Socket half-closed handler */\n", "func_signal": "struct us_socket_t *on_echo_socket_end(struct us_socket_t *s)", "code": "{\n\tus_socket_shutdown(SSL, s);\n\treturn us_socket_close(SSL, s, 0, NULL);\n}", "path": "uSockets/examples/echo_server.c", "commit_date": "2020-06-26 00:00:00", "repo_name": "uNetworking/uSockets", "stars": 1190, "license": "apache-2.0", "language": "c", "size": 855}
{"docstring": "/* Lazily inits loop ssl data first time */\n", "func_signal": "void us_internal_init_loop_ssl_data(struct us_loop_t *loop)", "code": "{\n    if (!loop->data.ssl_data) {\n        struct loop_ssl_data *loop_ssl_data = malloc(sizeof(struct loop_ssl_data));\n\n        loop_ssl_data->ssl_read_output = malloc(LIBUS_RECV_BUFFER_LENGTH + LIBUS_RECV_BUFFER_PADDING * 2);\n\n        OPENSSL_init_ssl(0, NULL);\n\n        loop_ssl_data->shared_biom = BIO_meth_new(BIO_TYPE_MEM, \"\u00b5S BIO\");\n        BIO_meth_set_create(loop_ssl_data->shared_biom, BIO_s_custom_create);\n        BIO_meth_set_write(loop_ssl_data->shared_biom, BIO_s_custom_write);\n        BIO_meth_set_read(loop_ssl_data->shared_biom, BIO_s_custom_read);\n        BIO_meth_set_ctrl(loop_ssl_data->shared_biom, BIO_s_custom_ctrl);\n\n        loop_ssl_data->shared_rbio = BIO_new(loop_ssl_data->shared_biom);\n        loop_ssl_data->shared_wbio = BIO_new(loop_ssl_data->shared_biom);\n        BIO_set_data(loop_ssl_data->shared_rbio, loop_ssl_data);\n        BIO_set_data(loop_ssl_data->shared_wbio, loop_ssl_data);\n\n        // reset handshake budget (doesn't matter what loop nr we start on)\n        loop_ssl_data->last_iteration_nr = 0;\n        loop_ssl_data->handshake_budget = MAX_HANDSHAKES_PER_LOOP_ITERATION;\n\n        loop->data.ssl_data = loop_ssl_data;\n    }\n}", "path": "uSockets/src/crypto/openssl.c", "commit_date": "2020-09-05 00:00:00", "repo_name": "uNetworking/uSockets", "stars": 1190, "license": "apache-2.0", "language": "c", "size": 855}
{"docstring": "// we ignore reading data for ssl sockets that are\n// in init state, if our so called budget for doing\n// so won't allow it. here we actually use\n// the kernel buffering to our advantage\n", "func_signal": "int ssl_ignore_data(struct us_internal_ssl_socket_t *s)", "code": "{\n\n    // fast path just checks for init\n    if (!SSL_in_init(s->ssl)) {\n        return 0;\n    }\n\n    // this path is run for all ssl sockets that are in init and just got data event from polling\n\n    struct us_loop_t *loop = s->s.context->loop;\n    struct loop_ssl_data *loop_ssl_data = loop->data.ssl_data;\n\n    // reset handshake budget if new iteration\n    if (loop_ssl_data->last_iteration_nr != us_loop_iteration_number(loop)) {\n        loop_ssl_data->last_iteration_nr = us_loop_iteration_number(loop);\n        loop_ssl_data->handshake_budget = MAX_HANDSHAKES_PER_LOOP_ITERATION;\n    }\n\n    if (loop_ssl_data->handshake_budget) {\n        loop_ssl_data->handshake_budget--;\n        return 0;\n    }\n\n    // ignore this data event\n    return 1;\n}", "path": "uSockets/src/crypto/openssl.c", "commit_date": "2020-09-05 00:00:00", "repo_name": "uNetworking/uSockets", "stars": 1190, "license": "apache-2.0", "language": "c", "size": 855}
{"docstring": "/* Todo: return error on failure? */\n", "func_signal": "void us_internal_ssl_socket_context_add_server_name(struct us_internal_ssl_socket_context_t *context, const char *hostname_pattern, struct us_socket_context_options_t options)", "code": "{\n\n    /* Try and construct an SSL_CTX from options */\n    SSL_CTX *ssl_context = create_ssl_context_from_options(options);\n\n    /* We do not want to hold any nullptr's in our SNI tree */\n    if (ssl_context) {\n        if (sni_add(context->sni, hostname_pattern, ssl_context)) {\n            /* If we already had that name, ignore */\n            free_ssl_context(ssl_context);\n        }\n    }\n}", "path": "uSockets/src/crypto/openssl.c", "commit_date": "2020-09-05 00:00:00", "repo_name": "uNetworking/uSockets", "stars": 1190, "license": "apache-2.0", "language": "c", "size": 855}
{"docstring": "// arg is context\n", "func_signal": "int sni_cb(SSL *ssl, int *al, void *arg)", "code": "{\n\n    if (ssl) {\n        const char *hostname = SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name);\n        if (hostname && hostname[0]) {\n            /* Try and resolve (match) required hostname with what we have registered */\n            SSL_CTX *resolved_ssl_context = resolve_context((struct us_internal_ssl_socket_context_t *) arg, hostname);\n            if (resolved_ssl_context) {\n                //printf(\"Did find matching SNI context for hostname: <%s>!\\n\", hostname);\n                SSL_set_SSL_CTX(ssl, resolved_ssl_context);\n            } else {\n                /* Call a blocking callback notifying of missing context */\n            }\n\n        }\n\n        return SSL_TLSEXT_ERR_OK;\n    }\n\n    /* Can we even come here ever? */\n    return SSL_TLSEXT_ERR_NOACK;\n}", "path": "uSockets/src/crypto/openssl.c", "commit_date": "2020-09-05 00:00:00", "repo_name": "uNetworking/uSockets", "stars": 1190, "license": "apache-2.0", "language": "c", "size": 855}
{"docstring": "/* This functions should never run recursively */\n", "func_signal": "void us_internal_timer_sweep(struct us_loop_t *loop)", "code": "{\n    struct us_internal_loop_data_t *loop_data = &loop->data;\n    for (loop_data->iterator = loop_data->head; loop_data->iterator; loop_data->iterator = loop_data->iterator->next) {\n\n        struct us_socket_context_t *context = loop_data->iterator;\n        for (context->iterator = context->head; context->iterator; ) {\n\n            struct us_socket_t *s = context->iterator;\n            if (s->timeout && --(s->timeout) == 0) {\n\n                context->on_socket_timeout(s);\n\n                /* Check for unlink / link */\n                if (s == context->iterator) {\n                    context->iterator = s->next;\n                }\n            } else {\n                context->iterator = s->next;\n            }\n        }\n    }\n}", "path": "uSockets/src/loop.c", "commit_date": "2020-10-14 00:00:00", "repo_name": "uNetworking/uSockets", "stars": 1190, "license": "apache-2.0", "language": "c", "size": 855}
{"docstring": "// return LIBUS_SOCKET_ERROR or the fd that represents listen socket\n// listen both on ipv6 and ipv4\n", "func_signal": "LIBUS_SOCKET_DESCRIPTOR bsd_create_listen_socket(const char *host, int port, int options)", "code": "{\n    struct addrinfo hints, *result;\n    memset(&hints, 0, sizeof(struct addrinfo));\n\n    hints.ai_flags = AI_PASSIVE;\n    hints.ai_family = AF_UNSPEC;\n    hints.ai_socktype = SOCK_STREAM;\n\n    char port_string[16];\n    snprintf(port_string, 16, \"%d\", port);\n\n    if (getaddrinfo(host, port_string, &hints, &result)) {\n        return LIBUS_SOCKET_ERROR;\n    }\n\n    LIBUS_SOCKET_DESCRIPTOR listenFd = LIBUS_SOCKET_ERROR;\n    struct addrinfo *listenAddr;\n    for (struct addrinfo *a = result; a && listenFd == LIBUS_SOCKET_ERROR; a = a->ai_next) {\n        if (a->ai_family == AF_INET6) {\n            listenFd = bsd_create_socket(a->ai_family, a->ai_socktype, a->ai_protocol);\n            listenAddr = a;\n        }\n    }\n\n    for (struct addrinfo *a = result; a && listenFd == LIBUS_SOCKET_ERROR; a = a->ai_next) {\n        if (a->ai_family == AF_INET) {\n            listenFd = bsd_create_socket(a->ai_family, a->ai_socktype, a->ai_protocol);\n            listenAddr = a;\n        }\n    }\n\n    if (listenFd == LIBUS_SOCKET_ERROR) {\n        freeaddrinfo(result);\n        return LIBUS_SOCKET_ERROR;\n    }\n\n    /* Always enable SO_REUSEPORT and SO_REUSEADDR _unless_ options specify otherwise */\n#if defined(__linux) && defined(SO_REUSEPORT)\n    if (!(options & LIBUS_LISTEN_EXCLUSIVE_PORT)) {\n        int optval = 1;\n        setsockopt(listenFd, SOL_SOCKET, SO_REUSEPORT, &optval, sizeof(optval));\n    }\n#endif\n\n    int enabled = 1;\n    setsockopt(listenFd, SOL_SOCKET, SO_REUSEADDR, (SETSOCKOPT_PTR_TYPE) &enabled, sizeof(enabled));\n\n#ifdef IPV6_V6ONLY\n    int disabled = 0;\n    setsockopt(listenFd, IPPROTO_IPV6, IPV6_V6ONLY, (SETSOCKOPT_PTR_TYPE) &disabled, sizeof(disabled));\n#endif\n\n    if (bind(listenFd, listenAddr->ai_addr, (socklen_t) listenAddr->ai_addrlen) || listen(listenFd, 512)) {\n        bsd_close_socket(listenFd);\n        freeaddrinfo(result);\n        return LIBUS_SOCKET_ERROR;\n    }\n\n    freeaddrinfo(result);\n    return listenFd;\n}", "path": "uSockets/src/bsd.c", "commit_date": "2020-08-24 00:00:00", "repo_name": "uNetworking/uSockets", "stars": 1190, "license": "apache-2.0", "language": "c", "size": 855}
{"docstring": "/* Socket opened handler */\n", "func_signal": "struct us_socket_t *on_echo_socket_open(struct us_socket_t *s, int is_client, char *ip, int ip_length)", "code": "{\n\tstruct echo_socket *es = (struct echo_socket *) us_socket_ext(SSL, s);\n\n\t/* Initialize the new socket's extension */\n\tes->backpressure = 0;\n\tes->length = 0;\n\n\t/* Start a timeout to close the socekt if boring */\n\tus_socket_timeout(SSL, s, 30);\n\n\tprintf(\"Client connected\\n\");\n\n\treturn s;\n}", "path": "uSockets/examples/echo_server.c", "commit_date": "2020-06-26 00:00:00", "repo_name": "uNetworking/uSockets", "stars": 1190, "license": "apache-2.0", "language": "c", "size": 855}
{"docstring": "/* This function should take any options and return SSL_CTX - which has to be free'd with\n * our destructor function - free_ssl_context() */\n", "func_signal": "SSL_CTX *create_ssl_context_from_options(struct us_socket_context_options_t options)", "code": "{\n    /* Create the context */\n    SSL_CTX *ssl_context = SSL_CTX_new(TLS_method());\n\n    /* Default options we rely on - changing these will break our logic */\n    SSL_CTX_set_read_ahead(ssl_context, 1);\n    SSL_CTX_set_mode(ssl_context, SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER);\n\n    /* Anything below TLS 1.2 is disabled */\n    SSL_CTX_set_min_proto_version(ssl_context, TLS1_2_VERSION);\n\n    /* The following are helpers. You may easily implement whatever you want by using the native handle directly */\n\n    /* Important option for lowering memory usage, but lowers performance slightly */\n    if (options.ssl_prefer_low_memory_usage) {\n       SSL_CTX_set_mode(ssl_context, SSL_MODE_RELEASE_BUFFERS);\n    }\n\n    if (options.passphrase) {\n        /* When freeing the CTX we need to check SSL_CTX_get_default_passwd_cb_userdata and\n         * free it if set */\n        SSL_CTX_set_default_passwd_cb_userdata(ssl_context, (void *) strdup(options.passphrase));\n        SSL_CTX_set_default_passwd_cb(ssl_context, passphrase_cb);\n    }\n\n    /* This one most probably do not need the cert_file_name string to be kept alive */\n    if (options.cert_file_name) {\n        if (SSL_CTX_use_certificate_chain_file(ssl_context, options.cert_file_name) != 1) {\n            free_ssl_context(ssl_context);\n            return NULL;\n        }\n    }\n\n    /* Same as above - we can discard this string afterwards I suppose */\n    if (options.key_file_name) {\n        if (SSL_CTX_use_PrivateKey_file(ssl_context, options.key_file_name, SSL_FILETYPE_PEM) != 1) {\n            free_ssl_context(ssl_context);\n            return NULL;\n        }\n    }\n\n    if (options.ca_file_name) {\n        STACK_OF(X509_NAME) *ca_list;\n        ca_list = SSL_load_client_CA_file(options.ca_file_name);\n        if(ca_list == NULL) {\n            free_ssl_context(ssl_context);\n            return NULL;\n        }\n        SSL_CTX_set_client_CA_list(ssl_context, ca_list);\n        if (SSL_CTX_load_verify_locations(ssl_context, options.ca_file_name, NULL) != 1) {\n            free_ssl_context(ssl_context);\n            return NULL;\n        }\n        SSL_CTX_set_verify(ssl_context, SSL_VERIFY_PEER, NULL);\n    }\n\n    if (options.dh_params_file_name) {\n        /* Set up ephemeral DH parameters. */\n        DH *dh_2048 = NULL;\n        FILE *paramfile;\n        paramfile = fopen(options.dh_params_file_name, \"r\");\n\n        if (paramfile) {\n            dh_2048 = PEM_read_DHparams(paramfile, NULL, NULL, NULL);\n            fclose(paramfile);\n        } else {\n            free_ssl_context(ssl_context);\n            return NULL;\n        }\n\n        if (dh_2048 == NULL) {\n            free_ssl_context(ssl_context);\n            return NULL;\n        }\n\n        const long set_tmp_dh = SSL_CTX_set_tmp_dh(ssl_context, dh_2048);\n        DH_free(dh_2048);\n\n        if (set_tmp_dh != 1) {\n            free_ssl_context(ssl_context);\n            return NULL;\n        }\n\n        /* OWASP Cipher String 'A+' (https://www.owasp.org/index.php/TLS_Cipher_String_Cheat_Sheet) */\n        if (SSL_CTX_set_cipher_list(ssl_context, \"DHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256\") != 1) {\n            free_ssl_context(ssl_context);\n            return NULL;\n        }\n    }\n\n    /* This must be free'd with free_ssl_context, not SSL_CTX_free */\n    return ssl_context;\n}", "path": "uSockets/src/crypto/openssl.c", "commit_date": "2020-09-05 00:00:00", "repo_name": "uNetworking/uSockets", "stars": 1190, "license": "apache-2.0", "language": "c", "size": 855}
{"docstring": "/* Socket closed handler */\n", "func_signal": "struct us_socket_t *on_echo_socket_close(struct us_socket_t *s, int code, void *reason)", "code": "{\n\tstruct echo_socket *es = (struct echo_socket *) us_socket_ext(SSL, s);\n\n\tprintf(\"Client disconnected\\n\");\n\n\tfree(es->backpressure);\n\n\treturn s;\n}", "path": "uSockets/examples/echo_server.c", "commit_date": "2020-06-26 00:00:00", "repo_name": "uNetworking/uSockets", "stars": 1190, "license": "apache-2.0", "language": "c", "size": 855}
{"docstring": "/* Socket data handler */\n", "func_signal": "struct us_socket_t *on_echo_socket_data(struct us_socket_t *s, char *data, int length)", "code": "{\n\tstruct echo_socket *es = (struct echo_socket *) us_socket_ext(SSL, s);\n\n\t/* Print the data we received */\n\tprintf(\"Client sent <%.*s>\\n\", length, data);\n\n\t/* Send it back or buffer it up */\n\tint written = us_socket_write(SSL, s, data, length, 0);\n\tif (written != length) {\n\t\tchar *new_buffer = (char *) malloc(es->length + length - written);\n\t\tmemcpy(new_buffer, es->backpressure, es->length);\n\t\tmemcpy(new_buffer + es->length, data + written, length - written);\n\t\tfree(es->backpressure);\n\t\tes->backpressure = new_buffer;\n\t\tes->length += length - written;\n\t}\n\n\t/* Client is not boring */\n\tus_socket_timeout(SSL, s, 30);\n\n\treturn s;\n}", "path": "uSockets/examples/echo_server.c", "commit_date": "2020-06-26 00:00:00", "repo_name": "uNetworking/uSockets", "stars": 1190, "license": "apache-2.0", "language": "c", "size": 855}
{"docstring": "/* These may have somewhat different meaning depending on the underlying event library */\n", "func_signal": "void us_internal_loop_pre(struct us_loop_t *loop)", "code": "{\n    loop->data.iteration_nr++;\n    loop->data.pre_cb(loop);\n}", "path": "uSockets/src/loop.c", "commit_date": "2020-10-14 00:00:00", "repo_name": "uNetworking/uSockets", "stars": 1190, "license": "apache-2.0", "language": "c", "size": 855}
{"docstring": "/* ndef OPENSSL_NO_NEXTPROTONEG */\n", "func_signal": "static int serverinfo_cli_parse_cb(SSL *s, unsigned int ext_type,\n                                   const unsigned char *in, size_t inlen,\n                                   int *al, void *arg)", "code": "{\n    char pem_name[100];\n    unsigned char ext_buf[4 + 65536];\n\n    /* Reconstruct the type/len fields prior to extension data */\n    inlen &= 0xffff; /* for formal memcmpy correctness */\n    ext_buf[0] = (unsigned char)(ext_type >> 8);\n    ext_buf[1] = (unsigned char)(ext_type);\n    ext_buf[2] = (unsigned char)(inlen >> 8);\n    ext_buf[3] = (unsigned char)(inlen);\n    memcpy(ext_buf + 4, in, inlen);\n\n    BIO_snprintf(pem_name, sizeof(pem_name), \"SERVERINFO FOR EXTENSION %d\",\n                 ext_type);\n    PEM_write_bio(bio_c_out, pem_name, \"\", ext_buf, 4 + inlen);\n    return 1;\n}", "path": "android-app/openvpn/src/main/cpp/openssl/apps/s_client.c", "commit_date": "2019-12-23 00:00:00", "repo_name": "ProtonVPN/android-app", "stars": 1850, "license": "gpl-3.0", "language": "c", "size": 241705}
{"docstring": "/*\n * Provide any AAD. This can be called multiple times. Only the final time can\n * have a partial block\n */\n", "func_signal": "int CRYPTO_ocb128_aad(OCB128_CONTEXT *ctx, const unsigned char *aad,\n                      size_t len)", "code": "{\n    u64 i, all_num_blocks;\n    size_t num_blocks, last_len;\n    OCB_BLOCK tmp;\n\n    /* Calculate the number of blocks of AAD provided now, and so far */\n    num_blocks = len / 16;\n    all_num_blocks = num_blocks + ctx->sess.blocks_hashed;\n\n    /* Loop through all full blocks of AAD */\n    for (i = ctx->sess.blocks_hashed + 1; i <= all_num_blocks; i++) {\n        OCB_BLOCK *lookup;\n\n        /* Offset_i = Offset_{i-1} xor L_{ntz(i)} */\n        lookup = ocb_lookup_l(ctx, ocb_ntz(i));\n        if (lookup == NULL)\n            return 0;\n        ocb_block16_xor(&ctx->sess.offset_aad, lookup, &ctx->sess.offset_aad);\n\n        memcpy(tmp.c, aad, 16);\n        aad += 16;\n\n        /* Sum_i = Sum_{i-1} xor ENCIPHER(K, A_i xor Offset_i) */\n        ocb_block16_xor(&ctx->sess.offset_aad, &tmp, &tmp);\n        ctx->encrypt(tmp.c, tmp.c, ctx->keyenc);\n        ocb_block16_xor(&tmp, &ctx->sess.sum, &ctx->sess.sum);\n    }\n\n    /*\n     * Check if we have any partial blocks left over. This is only valid in the\n     * last call to this function\n     */\n    last_len = len % 16;\n\n    if (last_len > 0) {\n        /* Offset_* = Offset_m xor L_* */\n        ocb_block16_xor(&ctx->sess.offset_aad, &ctx->l_star,\n                        &ctx->sess.offset_aad);\n\n        /* CipherInput = (A_* || 1 || zeros(127-bitlen(A_*))) xor Offset_* */\n        memset(tmp.c, 0, 16);\n        memcpy(tmp.c, aad, last_len);\n        tmp.c[last_len] = 0x80;\n        ocb_block16_xor(&ctx->sess.offset_aad, &tmp, &tmp);\n\n        /* Sum = Sum_m xor ENCIPHER(K, CipherInput) */\n        ctx->encrypt(tmp.c, tmp.c, ctx->keyenc);\n        ocb_block16_xor(&tmp, &ctx->sess.sum, &ctx->sess.sum);\n    }\n\n    ctx->sess.blocks_hashed = all_num_blocks;\n\n    return 1;\n}", "path": "android-app/openvpn/src/main/cpp/openssl/crypto/modes/ocb128.c", "commit_date": "2019-12-23 00:00:00", "repo_name": "ProtonVPN/android-app", "stars": 1850, "license": "gpl-3.0", "language": "c", "size": 241705}
{"docstring": "/*\n * Set the IV to be used for this operation. Must be 1 - 15 bytes.\n */\n", "func_signal": "int CRYPTO_ocb128_setiv(OCB128_CONTEXT *ctx, const unsigned char *iv,\n                        size_t len, size_t taglen)", "code": "{\n    unsigned char ktop[16], tmp[16], mask;\n    unsigned char stretch[24], nonce[16];\n    size_t bottom, shift;\n\n    /*\n     * Spec says IV is 120 bits or fewer - it allows non byte aligned lengths.\n     * We don't support this at this stage\n     */\n    if ((len > 15) || (len < 1) || (taglen > 16) || (taglen < 1)) {\n        return -1;\n    }\n\n    /* Reset nonce-dependent variables */\n    memset(&ctx->sess, 0, sizeof(ctx->sess));\n\n    /* Nonce = num2str(TAGLEN mod 128,7) || zeros(120-bitlen(N)) || 1 || N */\n    nonce[0] = ((taglen * 8) % 128) << 1;\n    memset(nonce + 1, 0, 15);\n    memcpy(nonce + 16 - len, iv, len);\n    nonce[15 - len] |= 1;\n\n    /* Ktop = ENCIPHER(K, Nonce[1..122] || zeros(6)) */\n    memcpy(tmp, nonce, 16);\n    tmp[15] &= 0xc0;\n    ctx->encrypt(tmp, ktop, ctx->keyenc);\n\n    /* Stretch = Ktop || (Ktop[1..64] xor Ktop[9..72]) */\n    memcpy(stretch, ktop, 16);\n    ocb_block_xor(ktop, ktop + 1, 8, stretch + 16);\n\n    /* bottom = str2num(Nonce[123..128]) */\n    bottom = nonce[15] & 0x3f;\n\n    /* Offset_0 = Stretch[1+bottom..128+bottom] */\n    shift = bottom % 8;\n    ocb_block_lshift(stretch + (bottom / 8), shift, ctx->sess.offset.c);\n    mask = 0xff;\n    mask <<= 8 - shift;\n    ctx->sess.offset.c[15] |=\n        (*(stretch + (bottom / 8) + 16) & mask) >> (8 - shift);\n\n    return 1;\n}", "path": "android-app/openvpn/src/main/cpp/openssl/crypto/modes/ocb128.c", "commit_date": "2019-12-23 00:00:00", "repo_name": "ProtonVPN/android-app", "stars": 1850, "license": "gpl-3.0", "language": "c", "size": 241705}
{"docstring": "/* Free |*dest| and optionally set it to a copy of |source|. */\n", "func_signal": "static void freeandcopy(char **dest, const char *source)", "code": "{\n    OPENSSL_free(*dest);\n    *dest = NULL;\n    if (source != NULL)\n        *dest = OPENSSL_strdup(source);\n}", "path": "android-app/openvpn/src/main/cpp/openssl/apps/s_client.c", "commit_date": "2019-12-23 00:00:00", "repo_name": "ProtonVPN/android-app", "stars": 1850, "license": "gpl-3.0", "language": "c", "size": 241705}
{"docstring": "/*\n * Perform an xor on in1 and in2 - each of len bytes. Store result in out\n */\n", "func_signal": "static void ocb_block_xor(const unsigned char *in1,\n                          const unsigned char *in2, size_t len,\n                          unsigned char *out)", "code": "{\n    size_t i;\n    for (i = 0; i < len; i++) {\n        out[i] = in1[i] ^ in2[i];\n    }\n}", "path": "android-app/openvpn/src/main/cpp/openssl/crypto/modes/ocb128.c", "commit_date": "2019-12-23 00:00:00", "repo_name": "ProtonVPN/android-app", "stars": 1850, "license": "gpl-3.0", "language": "c", "size": 241705}
{"docstring": "/*\n * Hex decoder that tolerates optional whitespace.  Returns number of bytes\n * produced, advances inptr to end of input string.\n */\n", "func_signal": "static ossl_ssize_t hexdecode(const char **inptr, void *result)", "code": "{\n    unsigned char **out = (unsigned char **)result;\n    const char *in = *inptr;\n    unsigned char *ret = app_malloc(strlen(in) / 2, \"hexdecode\");\n    unsigned char *cp = ret;\n    uint8_t byte;\n    int nibble = 0;\n\n    if (ret == NULL)\n        return -1;\n\n    for (byte = 0; *in; ++in) {\n        int x;\n\n        if (isspace(_UC(*in)))\n            continue;\n        x = OPENSSL_hexchar2int(*in);\n        if (x < 0) {\n            OPENSSL_free(ret);\n            return 0;\n        }\n        byte |= (char)x;\n        if ((nibble ^= 1) == 0) {\n            *cp++ = byte;\n            byte = 0;\n        } else {\n            byte <<= 4;\n        }\n    }\n    if (nibble != 0) {\n        OPENSSL_free(ret);\n        return 0;\n    }\n    *inptr = in;\n\n    return cp - (*out = ret);\n}", "path": "android-app/openvpn/src/main/cpp/openssl/apps/s_client.c", "commit_date": "2019-12-23 00:00:00", "repo_name": "ProtonVPN/android-app", "stars": 1850, "license": "gpl-3.0", "language": "c", "size": 241705}
{"docstring": "/* Convert the various cipher NIDs and dummies to a proper OID NID */\n", "func_signal": "int EVP_CIPHER_type(const EVP_CIPHER *ctx)", "code": "{\n    int nid;\n    ASN1_OBJECT *otmp;\n    nid = EVP_CIPHER_nid(ctx);\n\n    switch (nid) {\n\n    case NID_rc2_cbc:\n    case NID_rc2_64_cbc:\n    case NID_rc2_40_cbc:\n\n        return NID_rc2_cbc;\n\n    case NID_rc4:\n    case NID_rc4_40:\n\n        return NID_rc4;\n\n    case NID_aes_128_cfb128:\n    case NID_aes_128_cfb8:\n    case NID_aes_128_cfb1:\n\n        return NID_aes_128_cfb128;\n\n    case NID_aes_192_cfb128:\n    case NID_aes_192_cfb8:\n    case NID_aes_192_cfb1:\n\n        return NID_aes_192_cfb128;\n\n    case NID_aes_256_cfb128:\n    case NID_aes_256_cfb8:\n    case NID_aes_256_cfb1:\n\n        return NID_aes_256_cfb128;\n\n    case NID_des_cfb64:\n    case NID_des_cfb8:\n    case NID_des_cfb1:\n\n        return NID_des_cfb64;\n\n    case NID_des_ede3_cfb64:\n    case NID_des_ede3_cfb8:\n    case NID_des_ede3_cfb1:\n\n        return NID_des_cfb64;\n\n    default:\n        /* Check it has an OID and it is valid */\n        otmp = OBJ_nid2obj(nid);\n        if (OBJ_get0_data(otmp) == NULL)\n            nid = NID_undef;\n        ASN1_OBJECT_free(otmp);\n        return nid;\n    }\n}", "path": "android-app/openvpn/src/main/cpp/openssl/crypto/evp/evp_lib.c", "commit_date": "2019-12-23 00:00:00", "repo_name": "ProtonVPN/android-app", "stars": 1850, "license": "gpl-3.0", "language": "c", "size": 241705}
{"docstring": "/*\n * Copy an OCB128_CONTEXT object\n */\n", "func_signal": "int CRYPTO_ocb128_copy_ctx(OCB128_CONTEXT *dest, OCB128_CONTEXT *src,\n                           void *keyenc, void *keydec)", "code": "{\n    memcpy(dest, src, sizeof(OCB128_CONTEXT));\n    if (keyenc)\n        dest->keyenc = keyenc;\n    if (keydec)\n        dest->keydec = keydec;\n    if (src->l) {\n        if ((dest->l = OPENSSL_malloc(src->max_l_index * 16)) == NULL) {\n            CRYPTOerr(CRYPTO_F_CRYPTO_OCB128_COPY_CTX, ERR_R_MALLOC_FAILURE);\n            return 0;\n        }\n        memcpy(dest->l, src->l, (src->l_index + 1) * 16);\n    }\n    return 1;\n}", "path": "android-app/openvpn/src/main/cpp/openssl/crypto/modes/ocb128.c", "commit_date": "2019-12-23 00:00:00", "repo_name": "ProtonVPN/android-app", "stars": 1850, "license": "gpl-3.0", "language": "c", "size": 241705}
{"docstring": "/*\n * Perform a \"double\" operation as per OCB spec\n */\n", "func_signal": "static void ocb_double(OCB_BLOCK *in, OCB_BLOCK *out)", "code": "{\n    unsigned char mask;\n\n    /*\n     * Calculate the mask based on the most significant bit. There are more\n     * efficient ways to do this - but this way is constant time\n     */\n    mask = in->c[0] & 0x80;\n    mask >>= 7;\n    mask = (0 - mask) & 0x87;\n\n    ocb_block_lshift(in->c, 1, out->c);\n\n    out->c[15] ^= mask;\n}", "path": "android-app/openvpn/src/main/cpp/openssl/crypto/modes/ocb128.c", "commit_date": "2019-12-23 00:00:00", "repo_name": "ProtonVPN/android-app", "stars": 1850, "license": "gpl-3.0", "language": "c", "size": 241705}
{"docstring": "/*\n * Initialise an existing OCB128_CONTEXT\n */\n", "func_signal": "int CRYPTO_ocb128_init(OCB128_CONTEXT *ctx, void *keyenc, void *keydec,\n                       block128_f encrypt, block128_f decrypt,\n                       ocb128_f stream)", "code": "{\n    memset(ctx, 0, sizeof(*ctx));\n    ctx->l_index = 0;\n    ctx->max_l_index = 5;\n    if ((ctx->l = OPENSSL_malloc(ctx->max_l_index * 16)) == NULL) {\n        CRYPTOerr(CRYPTO_F_CRYPTO_OCB128_INIT, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n\n    /*\n     * We set both the encryption and decryption key schedules - decryption\n     * needs both. Don't really need decryption schedule if only doing\n     * encryption - but it simplifies things to take it anyway\n     */\n    ctx->encrypt = encrypt;\n    ctx->decrypt = decrypt;\n    ctx->stream = stream;\n    ctx->keyenc = keyenc;\n    ctx->keydec = keydec;\n\n    /* L_* = ENCIPHER(K, zeros(128)) */\n    ctx->encrypt(ctx->l_star.c, ctx->l_star.c, ctx->keyenc);\n\n    /* L_$ = double(L_*) */\n    ocb_double(&ctx->l_star, &ctx->l_dollar);\n\n    /* L_0 = double(L_$) */\n    ocb_double(&ctx->l_dollar, ctx->l);\n\n    /* L_{i} = double(L_{i-1}) */\n    ocb_double(ctx->l, ctx->l+1);\n    ocb_double(ctx->l+1, ctx->l+2);\n    ocb_double(ctx->l+2, ctx->l+3);\n    ocb_double(ctx->l+3, ctx->l+4);\n    ctx->l_index = 4;   /* enough to process up to 496 bytes */\n\n    return 1;\n}", "path": "android-app/openvpn/src/main/cpp/openssl/crypto/modes/ocb128.c", "commit_date": "2019-12-23 00:00:00", "repo_name": "ProtonVPN/android-app", "stars": 1850, "license": "gpl-3.0", "language": "c", "size": 241705}
{"docstring": "/*\n * Decode unsigned 0..255, returns 1 on success, <= 0 on failure. Advances\n * inptr to next field skipping leading whitespace.\n */\n", "func_signal": "static ossl_ssize_t checked_uint8(const char **inptr, void *out)", "code": "{\n    uint8_t *result = (uint8_t *)out;\n    const char *in = *inptr;\n    char *endp;\n    long v;\n    int e;\n\n    save_errno();\n    v = strtol(in, &endp, 10);\n    e = restore_errno();\n\n    if (((v == LONG_MIN || v == LONG_MAX) && e == ERANGE) ||\n        endp == in || !isspace(_UC(*endp)) ||\n        v != (*result = (uint8_t) v)) {\n        return -1;\n    }\n    for (in = endp; isspace(_UC(*in)); ++in)\n        continue;\n\n    *inptr = in;\n    return 1;\n}", "path": "android-app/openvpn/src/main/cpp/openssl/apps/s_client.c", "commit_date": "2019-12-23 00:00:00", "repo_name": "ProtonVPN/android-app", "stars": 1850, "license": "gpl-3.0", "language": "c", "size": 241705}
{"docstring": "/*\n * Shift a block of 16 bytes left by shift bits\n */\n", "func_signal": "static void ocb_block_lshift(const unsigned char *in, size_t shift,\n                             unsigned char *out)", "code": "{\n    int i;\n    unsigned char carry = 0, carry_next;\n\n    for (i = 15; i >= 0; i--) {\n        carry_next = in[i] >> (8 - shift);\n        out[i] = (in[i] << shift) | carry;\n        carry = carry_next;\n    }\n}", "path": "android-app/openvpn/src/main/cpp/openssl/crypto/modes/ocb128.c", "commit_date": "2019-12-23 00:00:00", "repo_name": "ProtonVPN/android-app", "stars": 1850, "license": "gpl-3.0", "language": "c", "size": 241705}
{"docstring": "/*\n * Calculate the number of binary trailing zero's in any given number\n */\n", "func_signal": "static u32 ocb_ntz(u64 n)", "code": "{\n    u32 cnt = 0;\n\n    /*\n     * We do a right-to-left simple sequential search. This is surprisingly\n     * efficient as the distribution of trailing zeros is not uniform,\n     * e.g. the number of possible inputs with no trailing zeros is equal to\n     * the number with 1 or more; the number with exactly 1 is equal to the\n     * number with 2 or more, etc. Checking the last two bits covers 75% of\n     * all numbers. Checking the last three covers 87.5%\n     */\n    while (!(n & 1)) {\n        n >>= 1;\n        cnt++;\n    }\n    return cnt;\n}", "path": "android-app/openvpn/src/main/cpp/openssl/crypto/modes/ocb128.c", "commit_date": "2019-12-23 00:00:00", "repo_name": "ProtonVPN/android-app", "stars": 1850, "license": "gpl-3.0", "language": "c", "size": 241705}
{"docstring": "/*-\n * This callback is used here for two purposes:\n * - extended debugging\n * - making some primality tests for unknown groups\n * The callback is only called for a non default group.\n *\n * An application does not need the call back at all if\n * only the standard groups are used.  In real life situations,\n * client and server already share well known groups,\n * thus there is no need to verify them.\n * Furthermore, in case that a server actually proposes a group that\n * is not one of those defined in RFC 5054, it is more appropriate\n * to add the group to a static list and then compare since\n * primality tests are rather cpu consuming.\n */\n", "func_signal": "static int ssl_srp_verify_param_cb(SSL *s, void *arg)", "code": "{\n    SRP_ARG *srp_arg = (SRP_ARG *)arg;\n    BIGNUM *N = NULL, *g = NULL;\n\n    if (((N = SSL_get_srp_N(s)) == NULL) || ((g = SSL_get_srp_g(s)) == NULL))\n        return 0;\n    if (srp_arg->debug || srp_arg->msg || srp_arg->amp == 1) {\n        BIO_printf(bio_err, \"SRP parameters:\\n\");\n        BIO_printf(bio_err, \"\\tN=\");\n        BN_print(bio_err, N);\n        BIO_printf(bio_err, \"\\n\\tg=\");\n        BN_print(bio_err, g);\n        BIO_printf(bio_err, \"\\n\");\n    }\n\n    if (SRP_check_known_gN_param(g, N))\n        return 1;\n\n    if (srp_arg->amp == 1) {\n        if (srp_arg->debug)\n            BIO_printf(bio_err,\n                       \"SRP param N and g are not known params, going to check deeper.\\n\");\n\n        /*\n         * The srp_moregroups is a real debugging feature. Implementors\n         * should rather add the value to the known ones. The minimal size\n         * has already been tested.\n         */\n        if (BN_num_bits(g) <= BN_BITS && srp_Verify_N_and_g(N, g))\n            return 1;\n    }\n    BIO_printf(bio_err, \"SRP param N and g rejected.\\n\");\n    return 0;\n}", "path": "android-app/openvpn/src/main/cpp/openssl/apps/s_client.c", "commit_date": "2019-12-23 00:00:00", "repo_name": "ProtonVPN/android-app", "stars": 1850, "license": "gpl-3.0", "language": "c", "size": 241705}
{"docstring": "/*\n * Provide any data to be decrypted. This can be called multiple times. Only\n * the final time can have a partial block\n */\n", "func_signal": "int CRYPTO_ocb128_decrypt(OCB128_CONTEXT *ctx,\n                          const unsigned char *in, unsigned char *out,\n                          size_t len)", "code": "{\n    u64 i, all_num_blocks;\n    size_t num_blocks, last_len;\n\n    /*\n     * Calculate the number of blocks of data to be decrypted provided now, and\n     * so far\n     */\n    num_blocks = len / 16;\n    all_num_blocks = num_blocks + ctx->sess.blocks_processed;\n\n    if (num_blocks && all_num_blocks == (size_t)all_num_blocks\n        && ctx->stream != NULL) {\n        size_t max_idx = 0, top = (size_t)all_num_blocks;\n\n        /*\n         * See how many L_{i} entries we need to process data at hand\n         * and pre-compute missing entries in the table [if any]...\n         */\n        while (top >>= 1)\n            max_idx++;\n        if (ocb_lookup_l(ctx, max_idx) == NULL)\n            return 0;\n\n        ctx->stream(in, out, num_blocks, ctx->keydec,\n                    (size_t)ctx->sess.blocks_processed + 1, ctx->sess.offset.c,\n                    (const unsigned char (*)[16])ctx->l, ctx->sess.checksum.c);\n    } else {\n        OCB_BLOCK tmp;\n\n        /* Loop through all full blocks to be decrypted */\n        for (i = ctx->sess.blocks_processed + 1; i <= all_num_blocks; i++) {\n\n            /* Offset_i = Offset_{i-1} xor L_{ntz(i)} */\n            OCB_BLOCK *lookup = ocb_lookup_l(ctx, ocb_ntz(i));\n            if (lookup == NULL)\n                return 0;\n            ocb_block16_xor(&ctx->sess.offset, lookup, &ctx->sess.offset);\n\n            memcpy(tmp.c, in, 16);\n            in += 16;\n\n            /* P_i = Offset_i xor DECIPHER(K, C_i xor Offset_i) */\n            ocb_block16_xor(&ctx->sess.offset, &tmp, &tmp);\n            ctx->decrypt(tmp.c, tmp.c, ctx->keydec);\n            ocb_block16_xor(&ctx->sess.offset, &tmp, &tmp);\n\n            /* Checksum_i = Checksum_{i-1} xor P_i */\n            ocb_block16_xor(&tmp, &ctx->sess.checksum, &ctx->sess.checksum);\n\n            memcpy(out, tmp.c, 16);\n            out += 16;\n        }\n    }\n\n    /*\n     * Check if we have any partial blocks left over. This is only valid in the\n     * last call to this function\n     */\n    last_len = len % 16;\n\n    if (last_len > 0) {\n        OCB_BLOCK pad;\n\n        /* Offset_* = Offset_m xor L_* */\n        ocb_block16_xor(&ctx->sess.offset, &ctx->l_star, &ctx->sess.offset);\n\n        /* Pad = ENCIPHER(K, Offset_*) */\n        ctx->encrypt(ctx->sess.offset.c, pad.c, ctx->keyenc);\n\n        /* P_* = C_* xor Pad[1..bitlen(C_*)] */\n        ocb_block_xor(in, pad.c, last_len, out);\n\n        /* Checksum_* = Checksum_m xor (P_* || 1 || zeros(127-bitlen(P_*))) */\n        memset(pad.c, 0, 16);           /* borrow pad */\n        memcpy(pad.c, out, last_len);\n        pad.c[last_len] = 0x80;\n        ocb_block16_xor(&pad, &ctx->sess.checksum, &ctx->sess.checksum);\n    }\n\n    ctx->sess.blocks_processed = all_num_blocks;\n\n    return 1;\n}", "path": "android-app/openvpn/src/main/cpp/openssl/crypto/modes/ocb128.c", "commit_date": "2019-12-23 00:00:00", "repo_name": "ProtonVPN/android-app", "stars": 1850, "license": "gpl-3.0", "language": "c", "size": 241705}
{"docstring": "/*\n * Host dNS Name verifier: used for checking that the hostname is in dNS format \n * before setting it as SNI\n */\n", "func_signal": "static int is_dNS_name(const char *host)", "code": "{\n    const size_t MAX_LABEL_LENGTH = 63;\n    size_t i;\n    int isdnsname = 0;\n    size_t length = strlen(host);\n    size_t label_length = 0;\n    int all_numeric = 1;\n\n    /*\n     * Deviation from strict DNS name syntax, also check names with '_'\n     * Check DNS name syntax, any '-' or '.' must be internal,\n     * and on either side of each '.' we can't have a '-' or '.'.\n     *\n     * If the name has just one label, we don't consider it a DNS name.\n     */\n    for (i = 0; i < length && label_length < MAX_LABEL_LENGTH; ++i) {\n        char c = host[i];\n\n        if ((c >= 'a' && c <= 'z')\n            || (c >= 'A' && c <= 'Z')\n            || c == '_') {\n            label_length += 1;\n            all_numeric = 0;\n            continue;\n        }\n\n        if (c >= '0' && c <= '9') {\n            label_length += 1;\n            continue;\n        }\n\n        /* Dot and hyphen cannot be first or last. */\n        if (i > 0 && i < length - 1) {\n            if (c == '-') {\n                label_length += 1;\n                continue;\n            }\n            /*\n             * Next to a dot the preceding and following characters must not be\n             * another dot or a hyphen.  Otherwise, record that the name is\n             * plausible, since it has two or more labels.\n             */\n            if (c == '.'\n                && host[i + 1] != '.'\n                && host[i - 1] != '-'\n                && host[i + 1] != '-') {\n                label_length = 0;\n                isdnsname = 1;\n                continue;\n            }\n        }\n        isdnsname = 0;\n        break;\n    }\n\n    /* dNS name must not be all numeric and labels must be shorter than 64 characters. */\n    isdnsname &= !all_numeric && !(label_length == MAX_LABEL_LENGTH);\n\n    return isdnsname;\n}", "path": "android-app/openvpn/src/main/cpp/openssl/apps/s_client.c", "commit_date": "2019-12-23 00:00:00", "repo_name": "ProtonVPN/android-app", "stars": 1850, "license": "gpl-3.0", "language": "c", "size": 241705}
{"docstring": "/*\n * Lookup L_index in our lookup table. If we haven't already got it we need to\n * calculate it\n */\n", "func_signal": "static OCB_BLOCK *ocb_lookup_l(OCB128_CONTEXT *ctx, size_t idx)", "code": "{\n    size_t l_index = ctx->l_index;\n\n    if (idx <= l_index) {\n        return ctx->l + idx;\n    }\n\n    /* We don't have it - so calculate it */\n    if (idx >= ctx->max_l_index) {\n        void *tmp_ptr;\n        /*\n         * Each additional entry allows to process almost double as\n         * much data, so that in linear world the table will need to\n         * be expanded with smaller and smaller increments. Originally\n         * it was doubling in size, which was a waste. Growing it\n         * linearly is not formally optimal, but is simpler to implement.\n         * We grow table by minimally required 4*n that would accommodate\n         * the index.\n         */\n        ctx->max_l_index += (idx - ctx->max_l_index + 4) & ~3;\n        tmp_ptr = OPENSSL_realloc(ctx->l, ctx->max_l_index * sizeof(OCB_BLOCK));\n        if (tmp_ptr == NULL) /* prevent ctx->l from being clobbered */\n            return NULL;\n        ctx->l = tmp_ptr;\n    }\n    while (l_index < idx) {\n        ocb_double(ctx->l + l_index, ctx->l + l_index + 1);\n        l_index++;\n    }\n    ctx->l_index = l_index;\n\n    return ctx->l + idx;\n}", "path": "android-app/openvpn/src/main/cpp/openssl/crypto/modes/ocb128.c", "commit_date": "2019-12-23 00:00:00", "repo_name": "ProtonVPN/android-app", "stars": 1850, "license": "gpl-3.0", "language": "c", "size": 241705}
{"docstring": "/*\n * Provide any data to be encrypted. This can be called multiple times. Only\n * the final time can have a partial block\n */\n", "func_signal": "int CRYPTO_ocb128_encrypt(OCB128_CONTEXT *ctx,\n                          const unsigned char *in, unsigned char *out,\n                          size_t len)", "code": "{\n    u64 i, all_num_blocks;\n    size_t num_blocks, last_len;\n\n    /*\n     * Calculate the number of blocks of data to be encrypted provided now, and\n     * so far\n     */\n    num_blocks = len / 16;\n    all_num_blocks = num_blocks + ctx->sess.blocks_processed;\n\n    if (num_blocks && all_num_blocks == (size_t)all_num_blocks\n        && ctx->stream != NULL) {\n        size_t max_idx = 0, top = (size_t)all_num_blocks;\n\n        /*\n         * See how many L_{i} entries we need to process data at hand\n         * and pre-compute missing entries in the table [if any]...\n         */\n        while (top >>= 1)\n            max_idx++;\n        if (ocb_lookup_l(ctx, max_idx) == NULL)\n            return 0;\n\n        ctx->stream(in, out, num_blocks, ctx->keyenc,\n                    (size_t)ctx->sess.blocks_processed + 1, ctx->sess.offset.c,\n                    (const unsigned char (*)[16])ctx->l, ctx->sess.checksum.c);\n    } else {\n        /* Loop through all full blocks to be encrypted */\n        for (i = ctx->sess.blocks_processed + 1; i <= all_num_blocks; i++) {\n            OCB_BLOCK *lookup;\n            OCB_BLOCK tmp;\n\n            /* Offset_i = Offset_{i-1} xor L_{ntz(i)} */\n            lookup = ocb_lookup_l(ctx, ocb_ntz(i));\n            if (lookup == NULL)\n                return 0;\n            ocb_block16_xor(&ctx->sess.offset, lookup, &ctx->sess.offset);\n\n            memcpy(tmp.c, in, 16);\n            in += 16;\n\n            /* Checksum_i = Checksum_{i-1} xor P_i */\n            ocb_block16_xor(&tmp, &ctx->sess.checksum, &ctx->sess.checksum);\n\n            /* C_i = Offset_i xor ENCIPHER(K, P_i xor Offset_i) */\n            ocb_block16_xor(&ctx->sess.offset, &tmp, &tmp);\n            ctx->encrypt(tmp.c, tmp.c, ctx->keyenc);\n            ocb_block16_xor(&ctx->sess.offset, &tmp, &tmp);\n\n            memcpy(out, tmp.c, 16);\n            out += 16;\n        }\n    }\n\n    /*\n     * Check if we have any partial blocks left over. This is only valid in the\n     * last call to this function\n     */\n    last_len = len % 16;\n\n    if (last_len > 0) {\n        OCB_BLOCK pad;\n\n        /* Offset_* = Offset_m xor L_* */\n        ocb_block16_xor(&ctx->sess.offset, &ctx->l_star, &ctx->sess.offset);\n\n        /* Pad = ENCIPHER(K, Offset_*) */\n        ctx->encrypt(ctx->sess.offset.c, pad.c, ctx->keyenc);\n\n        /* C_* = P_* xor Pad[1..bitlen(P_*)] */\n        ocb_block_xor(in, pad.c, last_len, out);\n\n        /* Checksum_* = Checksum_m xor (P_* || 1 || zeros(127-bitlen(P_*))) */\n        memset(pad.c, 0, 16);           /* borrow pad */\n        memcpy(pad.c, in, last_len);\n        pad.c[last_len] = 0x80;\n        ocb_block16_xor(&pad, &ctx->sess.checksum, &ctx->sess.checksum);\n    }\n\n    ctx->sess.blocks_processed = all_num_blocks;\n\n    return 1;\n}", "path": "android-app/openvpn/src/main/cpp/openssl/crypto/modes/ocb128.c", "commit_date": "2019-12-23 00:00:00", "repo_name": "ProtonVPN/android-app", "stars": 1850, "license": "gpl-3.0", "language": "c", "size": 241705}
{"docstring": "/*\n * Create a new OCB128_CONTEXT\n */\n", "func_signal": "OCB128_CONTEXT *CRYPTO_ocb128_new(void *keyenc, void *keydec,\n                                  block128_f encrypt, block128_f decrypt,\n                                  ocb128_f stream)", "code": "{\n    OCB128_CONTEXT *octx;\n    int ret;\n\n    if ((octx = OPENSSL_malloc(sizeof(*octx))) != NULL) {\n        ret = CRYPTO_ocb128_init(octx, keyenc, keydec, encrypt, decrypt,\n                                 stream);\n        if (ret)\n            return octx;\n        OPENSSL_free(octx);\n    }\n\n    return NULL;\n}", "path": "android-app/openvpn/src/main/cpp/openssl/crypto/modes/ocb128.c", "commit_date": "2019-12-23 00:00:00", "repo_name": "ProtonVPN/android-app", "stars": 1850, "license": "gpl-3.0", "language": "c", "size": 241705}
{"docstring": "/*\n * Release all resources\n */\n", "func_signal": "void CRYPTO_ocb128_cleanup(OCB128_CONTEXT *ctx)", "code": "{\n    if (ctx) {\n        OPENSSL_clear_free(ctx->l, ctx->max_l_index * 16);\n        OPENSSL_cleanse(ctx, sizeof(*ctx));\n    }\n}", "path": "android-app/openvpn/src/main/cpp/openssl/crypto/modes/ocb128.c", "commit_date": "2019-12-23 00:00:00", "repo_name": "ProtonVPN/android-app", "stars": 1850, "license": "gpl-3.0", "language": "c", "size": 241705}
{"docstring": "/* restore environment variable's old value, handle cases where\n   variable must be unset (old value is NULL) */\n", "func_signal": "static int restore_env(const char *name, const char *old_value)", "code": "{\n  int res;\n  if (old_value == NULL) {\n     res = unsetenv(name);\n  } else {\n     res = setenv(name, old_value, 1);\n  }\n  return res;\n}", "path": "check/tests/check_check_log.c", "commit_date": "2015-09-13 00:00:00", "repo_name": "libcheck/check", "stars": 1027, "license": "lgpl-2.1", "language": "c", "size": 2359}
{"docstring": "/* HAVE_FORK */\n", "func_signal": "START_TEST(test_nofork)", "code": "{\n  ck_assert_msg(srunner_ntests_failed(fork_sr) == 0,\n\t      \"Errors on nofork test\");\n}", "path": "check/tests/check_check_fork.c", "commit_date": "2015-09-13 00:00:00", "repo_name": "libcheck/check", "stars": 1027, "license": "lgpl-2.1", "language": "c", "size": 2359}
{"docstring": "/* save environment variable's value and set new value */\n", "func_signal": "static int save_set_env(const char *name, const char *value,\n                        const char **old_value)", "code": "{\n  *old_value = getenv(name);\n  return setenv(name, value, 1);\n}", "path": "check/tests/check_check_log.c", "commit_date": "2015-09-13 00:00:00", "repo_name": "libcheck/check", "stars": 1027, "license": "lgpl-2.1", "language": "c", "size": 2359}
{"docstring": "/* Test enabling logging via environment variable */\n", "func_signal": "START_TEST(test_set_log_env)", "code": "{\n  const char *old_val;\n  Suite *s = suite_create(\"Suite\");\n  SRunner *sr = srunner_create(s);\n\n  /* check that setting log file via environment variable works */\n  ck_assert_msg(save_set_env(\"CK_LOG_FILE_NAME\", \"test_log\", &old_val) == 0,\n              \"Failed to set environment variable\");\n\n  ck_assert_msg (srunner_has_log (sr), \"SRunner not logging\");\n  ck_assert_msg (strcmp(srunner_log_fname(sr), \"test_log\") == 0,\n\t       \"Bad file name returned\");\n\n  /* check that explicit call to srunner_set_log()\n     overrides environment variable */\n  srunner_set_log (sr, \"test2_log\");\n\n  ck_assert_msg (srunner_has_log (sr), \"SRunner not logging\");\n  ck_assert_msg (strcmp(srunner_log_fname(sr), \"test2_log\") == 0,\n\t       \"Bad file name returned\");\n\n  /* restore old environment */\n  ck_assert_msg(restore_env(\"CK_LOG_FILE_NAME\", old_val) == 0,\n              \"Failed to restore environment variable\");\n\n  srunner_free(sr);\n}", "path": "check/tests/check_check_log.c", "commit_date": "2015-09-13 00:00:00", "repo_name": "libcheck/check", "stars": 1027, "license": "lgpl-2.1", "language": "c", "size": 2359}
{"docstring": "/* HAVE_FORK */\n", "func_signal": "Suite *make_pack_suite(void)", "code": "{\n\n  Suite *s;\n  TCase *tc_core;\n  TCase *tc_limit;\n\n  s = suite_create (\"Pack\");\n  tc_core = tcase_create (\"Core\");\n  tc_limit = tcase_create (\"Limit\");\n\n  suite_add_tcase (s, tc_core);\n  tcase_add_test (tc_core, test_pack_fmsg);\n  tcase_add_test (tc_core, test_pack_loc);\n  tcase_add_test (tc_core, test_pack_ctx);\n  tcase_add_test (tc_core, test_pack_len);\n  tcase_add_test (tc_core, test_pack_abuse);\n#if defined(HAVE_FORK) && HAVE_FORK==1\n  tcase_add_test (tc_core, test_ppack);\n  tcase_add_test (tc_core, test_ppack_noctx);\n  tcase_add_test (tc_core, test_ppack_onlyctx);\n  tcase_add_test (tc_core, test_ppack_multictx);\n  tcase_add_test (tc_core, test_ppack_nofail);\n#endif /* HAVE_FORK */\n  suite_add_tcase (s, tc_limit);\n  tcase_add_test (tc_limit, test_pack_ctx_limit);\n  tcase_add_test (tc_limit, test_pack_fail_limit);\n  tcase_add_test (tc_limit, test_pack_loc_limit);\n#if defined(HAVE_FORK) && HAVE_FORK==1\n  tcase_add_test (tc_limit, test_ppack_big);\n#endif /* HAVE_FORK */\n\n  return s;\n}", "path": "check/tests/check_check_pack.c", "commit_date": "2020-06-28 00:00:00", "repo_name": "libcheck/check", "stars": 1027, "license": "lgpl-2.1", "language": "c", "size": 2359}
{"docstring": "/* Test enabling XML logging via environment variable */\n", "func_signal": "START_TEST(test_set_xml_env)", "code": "{\n  const char *old_val;\n  Suite *s = suite_create(\"Suite\");\n  SRunner *sr = srunner_create(s);\n\n  /* check that setting XML log file via environment variable works */\n  ck_assert_msg(save_set_env(\"CK_XML_LOG_FILE_NAME\", \"test_log.xml\", &old_val) == 0,\n              \"Failed to set environment variable\");\n\n  ck_assert_msg (srunner_has_xml (sr), \"SRunner not logging XML\");\n  ck_assert_msg (strcmp(srunner_xml_fname(sr), \"test_log.xml\") == 0,\n\t       \"Bad file name returned\");\n\n  /* check that explicit call to srunner_set_xml()\n     overrides environment variable */\n  srunner_set_xml (sr, \"test2_log.xml\");\n\n  ck_assert_msg (srunner_has_xml (sr), \"SRunner not logging XML\");\n  ck_assert_msg (strcmp(srunner_xml_fname(sr), \"test2_log.xml\") == 0,\n\t       \"Bad file name returned\");\n\n  /* restore old environment */\n  ck_assert_msg(restore_env(\"CK_XML_LOG_FILE_NAME\", old_val) == 0,\n              \"Failed to restore environment variable\");\n  \n  srunner_free(sr);\n}", "path": "check/tests/check_check_log.c", "commit_date": "2015-09-13 00:00:00", "repo_name": "libcheck/check", "stars": 1027, "license": "lgpl-2.1", "language": "c", "size": 2359}
{"docstring": "/* force realloc(p, 0) and realloc (NULL, n) to return a valid pointer */\n", "func_signal": "void *rpl_realloc(void *p, size_t n)", "code": "{\n    if(n == 0)\n        n = 1;\n    if(p == 0)\n        return malloc(n);\n    return realloc(p, n);\n}", "path": "check/lib/realloc.c", "commit_date": "2015-09-13 00:00:00", "repo_name": "libcheck/check", "stars": 1027, "license": "lgpl-2.1", "language": "c", "size": 2359}
{"docstring": "/**\n * Open a temporary file.\n *\n * If the file could be unlinked upon creation, the name\n * of the file is not returned via 'name'. However, if the\n * file could not be unlinked, the name is returned,\n * expecting the caller to both delete the file and\n * free the 'name' field after the file is closed.\n */\n", "func_signal": "FILE *open_tmp_file(char **name)", "code": "{\n    FILE *file = NULL;\n\n    *name = NULL;\n\n#if !HAVE_MKSTEMP\n    /* Windows does not like tmpfile(). This is likely because tmpfile()\n     * call unlink() on the file before returning it, to make sure the\n     * file is deleted when it is closed. The unlink() call also fails\n     * on Windows if the file is still open. */\n    /* also note that mkstemp is apparently a C90 replacement for tmpfile */\n    /* perhaps all we need to do on Windows is set TMPDIR to whatever is\n       stored in TEMP for tmpfile to work */\n    /* and finally, the \"b\" from \"w+b\" is ignored on OS X, not sure about WIN32 */\n\n    file = tmpfile();\n    if(file == NULL)\n    {\n        /*\n         * The heuristic for selecting a temporary folder is as follows:\n         * 1) If the TEMP environment variable is defined, use that directory.\n         * 2) If the P_tmpdir macro is defined, use that directory.\n         * 3) If the TMPDIR environment variable is defined, use that directory.\n         * 4) Use the platform defined temporary directory, or the current directory.\n         */\n        char *tmp = getenv(\"TEMP\");\n        char *tmp_file = tempnam(tmp, \"check_\");\n\n        /*\n         * Note, tempnam is not enough to get a unique name. Between\n         * getting the name and opening the file, something else also\n         * calling tempnam() could get the same name. It has been observed\n         * on MinGW-w64 builds on Wine that this exact thing happens\n         * if multiple instances of a unit tests are running concurrently.\n         * To prevent two concurrent unit tests from getting the same file,\n         * we append the pid to the file. The pid should be unique on the\n         * system.\n         */\n        char *uniq_tmp_file = ck_strdup_printf(\"%s.%d\", tmp_file, getpid());\n\n        file = fopen(uniq_tmp_file, \"w+b\");\n        *name = uniq_tmp_file;\n        free(tmp_file);\n    }\n#else\n    /*\n     * The heuristic for selecting a temporary folder is as follows:\n     * 1) If the TEMP environment variable is defined, use that directory.\n     * 2) If the P_tmpdir macro is defined, use that directory.\n     * 3) If the TMPDIR environment variable is defined, use that directory.\n     * 4) Use the current directory\n     */\n\n    int fd = -1;\n    const char *tmp_dir = getenv (\"TEMP\");\n#ifdef P_tmpdir\n    if (tmp_dir == NULL)\n    {\n        tmp_dir = P_tmpdir;\n    }\n#endif /*P_tmpdir*/\n    if (tmp_dir == NULL)\n    {\n        tmp_dir = getenv (\"TMPDIR\");\n    }\n    if (tmp_dir == NULL)\n    {\n        tmp_dir = \".\";\n    }\n\n    *name = ck_strdup_printf (\"%s/check_XXXXXX\", tmp_dir);\n\n    if (-1 < (fd = mkstemp (*name)))\n    {\n        file = fdopen (fd, \"w+b\");\n        if (0 == unlink (*name) || NULL == file)\n        {\n            free (*name);\n            *name = NULL;\n        }\n    }\n#endif\n    return file;\n}", "path": "check/src/check_msg.c", "commit_date": "2017-05-13 00:00:00", "repo_name": "libcheck/check", "stars": 1027, "license": "lgpl-2.1", "language": "c", "size": 2359}
{"docstring": "/* HAVE_DECL_SETENV */\n", "func_signal": "START_TEST(test_no_set_tap)", "code": "{\n  Suite *s = suite_create(\"Suite\");\n  SRunner *sr = srunner_create(s);\n\n  ck_assert_msg (!srunner_has_tap (sr), \"SRunner not logging TAP\");\n  ck_assert_msg (srunner_tap_fname(sr) == NULL, \"Bad file name returned\");\n\n  srunner_free(sr);\n}", "path": "check/tests/check_check_log.c", "commit_date": "2015-09-13 00:00:00", "repo_name": "libcheck/check", "stars": 1027, "license": "lgpl-2.1", "language": "c", "size": 2359}
{"docstring": "/* HAVE_DECL_SETENV */\n", "func_signal": "START_TEST(test_no_set_log)", "code": "{\n  Suite *s = suite_create(\"Suite\");\n  SRunner *sr = srunner_create(s);\n\n  ck_assert_msg (!srunner_has_log (sr), \"SRunner not logging\");\n  ck_assert_msg (srunner_log_fname(sr) == NULL, \"Bad file name returned\");\n\n  srunner_free(sr);\n}", "path": "check/tests/check_check_log.c", "commit_date": "2015-09-13 00:00:00", "repo_name": "libcheck/check", "stars": 1027, "license": "lgpl-2.1", "language": "c", "size": 2359}
{"docstring": "/* HAVE_FORK */\n", "func_signal": "enum fork_status srunner_fork_status(SRunner * sr)", "code": "{\n    if(sr->fstat == CK_FORK_GETENV)\n    {\n        char *env = getenv(\"CK_FORK\");\n\n        if(env == NULL)\n#if defined(HAVE_FORK) && HAVE_FORK==1\n            return CK_FORK;\n#else\n            return CK_NOFORK;\n#endif\n        if(strcmp(env, \"no\") == 0)\n            return CK_NOFORK;\n#if defined(HAVE_FORK) && HAVE_FORK==1\n        return CK_FORK;\n#else /* HAVE_FORK */\n        /* Ignoring, as Check is not compiled with fork support. */\n        return CK_NOFORK;\n#endif /* HAVE_FORK */\n    }\n    return sr->fstat;\n}", "path": "check/src/check_run.c", "commit_date": "2020-01-15 00:00:00", "repo_name": "libcheck/check", "stars": 1027, "license": "lgpl-2.1", "language": "c", "size": 2359}
{"docstring": "/**\n * Not all systems support the same clockid_t's. This call checks\n * if the CLOCK_MONOTONIC clockid_t is valid. If so, that is returned,\n * otherwise, CLOCK_REALTIME is returned.\n *\n * The clockid_t that was found to work on the first call is\n * cached for subsequent calls.\n */\n", "func_signal": "clockid_t check_get_clockid()", "code": "{\n    static clockid_t clockid = -1;\n\n/*\n * Only check if we have librt available. Otherwise, the clockid\n * will be ignored anyway, as the clock_gettime() and\n * timer_create() functions will be re-implemented in libcompat.\n * Worse, if librt and alarm() are unavailable, this check\n * will result in an assert(0).\n */\n#ifdef HAVE_LIBRT\n    timer_t timerid;\n\n    if(timer_create(CLOCK_MONOTONIC, NULL, &timerid) == 0)\n    {\n        timer_delete(timerid);\n        clockid = CLOCK_MONOTONIC;\n    }\n    else\n    {\n        clockid = CLOCK_REALTIME;\n    }\n#else\n    clockid = CLOCK_MONOTONIC;\n#endif\n\n    return clockid;\n}", "path": "check/src/check.c", "commit_date": "2020-06-22 00:00:00", "repo_name": "libcheck/check", "stars": 1027, "license": "lgpl-2.1", "language": "c", "size": 2359}
{"docstring": "/* check that XML special characters are properly escaped in XML log file */\n", "func_signal": "static Suite *make_xml_esc_suite(void)", "code": "{\n    Suite *s;\n    TCase *tc;\n\n    s = suite_create(\"XML escape \\\" ' < > & \\x9 \\xA\" \"X\"\"\\x08\"\" tests\"); /* backspace char \\x08 deletes the X */\n    tc = tcase_create(\"description \\\" ' < > & \\x9 \\xA\" \"X\"\"\\x08\"\" end\"); /* backspace char \\x08 deletes the X */\n    suite_add_tcase(s, tc);\n\n    tcase_add_test(tc, test_xml_esc_fail_msg);\n\n    return s;\n}", "path": "check/tests/ex_output.c", "commit_date": "2017-07-24 00:00:00", "repo_name": "libcheck/check", "stars": 1027, "license": "lgpl-2.1", "language": "c", "size": 2359}
{"docstring": "/*\n * Helper function to create a list of tags from\n * a space separated string.\n */\n", "func_signal": "List *tag_string_to_list(const char *tags_string)", "code": "{\n    List *list;\n    char *tags;\n    char *tag;\n\n    list = check_list_create();\n\n    if (NULL == tags_string)\n    {\n        return list;\n    }\n\n    tags = strdup(tags_string);\n    tag = strtok(tags, \" \");\n    while (tag)\n    {\n        check_list_add_end(list, strdup(tag));\n        tag = strtok(NULL, \" \");\n    }\n    free(tags);\n    return list;\n}", "path": "check/src/check.c", "commit_date": "2020-06-22 00:00:00", "repo_name": "libcheck/check", "stars": 1027, "license": "lgpl-2.1", "language": "c", "size": 2359}
{"docstring": "/* HAVE_DECL_SETENV */\n", "func_signal": "START_TEST(test_no_set_xml)", "code": "{\n  Suite *s = suite_create(\"Suite\");\n  SRunner *sr = srunner_create(s);\n\n  ck_assert_msg (!srunner_has_xml (sr), \"SRunner not logging XML\");\n  ck_assert_msg (srunner_xml_fname(sr) == NULL, \"Bad file name returned\");\n  \n  srunner_free(sr);\n}", "path": "check/tests/check_check_log.c", "commit_date": "2015-09-13 00:00:00", "repo_name": "libcheck/check", "stars": 1027, "license": "lgpl-2.1", "language": "c", "size": 2359}
{"docstring": "/* Test enabling TAP logging via environment variable */\n", "func_signal": "START_TEST(test_set_tap_env)", "code": "{\n  const char *old_val;\n  Suite *s = suite_create(\"Suite\");\n  SRunner *sr = srunner_create(s);\n\n  /* check that setting XML log file via environment variable works */\n  ck_assert_msg(save_set_env(\"CK_TAP_LOG_FILE_NAME\", \"test_log.tap\", &old_val) == 0,\n              \"Failed to set environment variable\");\n\n  ck_assert_msg (srunner_has_tap (sr), \"SRunner not logging TAP\");\n  ck_assert_msg (strcmp(srunner_tap_fname(sr), \"test_log.tap\") == 0,\n\t       \"Bad file name returned\");\n\n  /* check that explicit call to srunner_set_tap()\n     overrides environment variable */\n  srunner_set_tap (sr, \"test2_log.tap\");\n\n  ck_assert_msg (srunner_has_tap (sr), \"SRunner not logging TAP\");\n  ck_assert_msg (strcmp(srunner_tap_fname(sr), \"test2_log.tap\") == 0,\n\t       \"Bad file name returned\");\n\n  /* restore old environment */\n  ck_assert_msg(restore_env(\"CK_TAP_LOG_FILE_NAME\", old_val) == 0,\n              \"Failed to restore environment variable\");\n\n  srunner_free(sr);\n}", "path": "check/tests/check_check_log.c", "commit_date": "2015-09-13 00:00:00", "repo_name": "libcheck/check", "stars": 1027, "license": "lgpl-2.1", "language": "c", "size": 2359}
{"docstring": "/* HAVE_FORK */\n", "func_signal": "int\nmain (void)", "code": "{\n  int number_failed;\n  s = suite_create (\"ForkThreadStress\");\n  tc = tcase_create (\"ForkThreadStress\");\n  sr = srunner_create (s);\n  suite_add_tcase (s, tc);\n\n#ifdef HAVE_PTHREAD\n  tcase_add_loop_test (tc, test_stress_threads, 0, 100);\n#endif /* HAVE_PTHREAD */\n\n#if defined(HAVE_FORK) && HAVE_FORK==1\n  tcase_add_loop_test (tc, test_stress_forks, 0, 100);\n#endif /* HAVE_FORK */\n\n  srunner_run_all (sr, CK_VERBOSE);\n  number_failed = srunner_ntests_failed (sr);\n  srunner_free (sr);\n\n  /* hack to give us XFAIL on non-posix platforms */\n#ifndef HAVE_FORK\n  number_failed++;\n#endif /* !HAVE_FORK */\n\n  return number_failed ? EXIT_FAILURE : EXIT_SUCCESS;\n}", "path": "check/tests/check_thread_stress.c", "commit_date": "2019-05-31 00:00:00", "repo_name": "libcheck/check", "stars": 1027, "license": "lgpl-2.1", "language": "c", "size": 2359}
{"docstring": "/* env var driven tests */\n", "func_signal": "START_TEST(include_yellow_env)", "code": "{\n    reset_executed();\n\n    setenv (\"CK_INCLUDE_TAGS\", \"Yellow\", 1);\n    srunner_run_all(sr, CK_VERBOSE);\n\n    ck_assert(!test_executed[RED]);\n    ck_assert(!test_executed[BLUE]);\n    ck_assert(!test_executed[PURPLE]);\n    ck_assert(test_executed[YELLOW]);\n    ck_assert(!test_executed[BLACK]);\n\n    unsetenv (\"CK_INCLUDE_TAGS\");\n\n}", "path": "check/tests/check_check_tags.c", "commit_date": "2020-03-09 00:00:00", "repo_name": "libcheck/check", "stars": 1027, "license": "lgpl-2.1", "language": "c", "size": 2359}
{"docstring": "/*\n * Show that with no filter we run all the tests\n */\n", "func_signal": "START_TEST(null_filter)", "code": "{\n    reset_executed();\n\n    srunner_run_tagged(sr, NULL, NULL, NULL, NULL, CK_VERBOSE);\n\n    ck_assert(test_executed[RED]);\n    ck_assert(test_executed[BLUE]);\n    ck_assert(test_executed[PURPLE]);\n    ck_assert(test_executed[YELLOW]);\n    ck_assert(test_executed[BLACK]);\n\n}", "path": "check/tests/check_check_tags.c", "commit_date": "2020-03-09 00:00:00", "repo_name": "libcheck/check", "stars": 1027, "license": "lgpl-2.1", "language": "c", "size": 2359}
{"docstring": "/* HAVE_DECL_SETENV */\n", "func_signal": "START_TEST(test_set_log)", "code": "{\n  Suite *s = suite_create(\"Suite\");\n  SRunner *sr = srunner_create(s);\n\n  srunner_set_log (sr, \"test_log\");\n\n  ck_assert_msg (srunner_has_log (sr), \"SRunner not logging\");\n  ck_assert_msg (strcmp(srunner_log_fname(sr), \"test_log\") == 0,\n\t       \"Bad file name returned\");\n\n  srunner_free(sr);\n}", "path": "check/tests/check_check_log.c", "commit_date": "2015-09-13 00:00:00", "repo_name": "libcheck/check", "stars": 1027, "license": "lgpl-2.1", "language": "c", "size": 2359}
{"docstring": "/* generate a jump to a fixed address */\n", "func_signal": "void gjmp_addr(int a)", "code": "{\n    Sym *sym;\n    // I guess this routine is used for relative short\n    // local jumps, for now just handle it as the general\n    // case\n\n    // define a label that will be relocated\n\n    sym = get_sym_ref(&char_pointer_type, cur_text_section, a, 0);\n    greloc(cur_text_section, sym, ind, R_C60LO16);\n    greloc(cur_text_section, sym, ind + 4, R_C60HI16);\n\n    gjmp(0);\t\t\t// place a zero there later the symbol will be added to it\n}", "path": "tinycc/c67-gen.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "TinyCC/tinycc", "stars": 1750, "license": "lgpl-2.1", "language": "c", "size": 4761}
{"docstring": "/* generate an integer binary operation */\n", "func_signal": "void gen_opi(int op)", "code": "{\n    int r, fr, opc, t;\n\n    switch (op) {\n    case '+':\n    case TOK_ADDC1:\t\t/* add with carry generation */\n\topc = 0;\n      gen_op8:\n\n\n// C67 can't do const compares, must load into a reg\n// so just go to gv2 directly - tktk\n\n\n\n\tif (op >= TOK_ULT && op <= TOK_GT)\n\t    gv2(RC_INT_BSIDE, RC_INT);\t// make sure r (src1) is on the B Side of CPU\n\telse\n\t    gv2(RC_INT, RC_INT);\n\n\tr = vtop[-1].r;\n\tfr = vtop[0].r;\n\n\tC67_compare_reg = C67_B2;\n\n\n\tif (op == TOK_LT) {\n\t    C67_CMPLT(r, fr, C67_B2);\n\t    C67_invert_test = FALSE;\n\t} else if (op == TOK_GE) {\n\t    C67_CMPLT(r, fr, C67_B2);\n\t    C67_invert_test = TRUE;\n\t} else if (op == TOK_GT) {\n\t    C67_CMPGT(r, fr, C67_B2);\n\t    C67_invert_test = FALSE;\n\t} else if (op == TOK_LE) {\n\t    C67_CMPGT(r, fr, C67_B2);\n\t    C67_invert_test = TRUE;\n\t} else if (op == TOK_EQ) {\n\t    C67_CMPEQ(r, fr, C67_B2);\n\t    C67_invert_test = FALSE;\n\t} else if (op == TOK_NE) {\n\t    C67_CMPEQ(r, fr, C67_B2);\n\t    C67_invert_test = TRUE;\n\t} else if (op == TOK_ULT) {\n\t    C67_CMPLTU(r, fr, C67_B2);\n\t    C67_invert_test = FALSE;\n\t} else if (op == TOK_UGE) {\n\t    C67_CMPLTU(r, fr, C67_B2);\n\t    C67_invert_test = TRUE;\n\t} else if (op == TOK_UGT) {\n\t    C67_CMPGTU(r, fr, C67_B2);\n\t    C67_invert_test = FALSE;\n\t} else if (op == TOK_ULE) {\n\t    C67_CMPGTU(r, fr, C67_B2);\n\t    C67_invert_test = TRUE;\n\t} else if (op == '+')\n\t    C67_ADD(fr, r);\t// ADD  r,fr,r\n\telse if (op == '-')\n\t    C67_SUB(fr, r);\t// SUB  r,fr,r\n\telse if (op == '&')\n\t    C67_AND(fr, r);\t// AND  r,fr,r\n\telse if (op == '|')\n\t    C67_OR(fr, r);\t// OR  r,fr,r\n\telse if (op == '^')\n\t    C67_XOR(fr, r);\t// XOR  r,fr,r\n\telse\n\t    ALWAYS_ASSERT(FALSE);\n\n\tvtop--;\n\tif (op >= TOK_ULT && op <= TOK_GT)\n            vset_VT_CMP(0x80);\n\tbreak;\n    case '-':\n    case TOK_SUBC1:\t\t/* sub with carry generation */\n\topc = 5;\n\tgoto gen_op8;\n    case TOK_ADDC2:\t\t/* add with carry use */\n\topc = 2;\n\tgoto gen_op8;\n    case TOK_SUBC2:\t\t/* sub with carry use */\n\topc = 3;\n\tgoto gen_op8;\n    case '&':\n\topc = 4;\n\tgoto gen_op8;\n    case '^':\n\topc = 6;\n\tgoto gen_op8;\n    case '|':\n\topc = 1;\n\tgoto gen_op8;\n    case '*':\n    case TOK_UMULL:\n\tgv2(RC_INT, RC_INT);\n\tr = vtop[-1].r;\n\tfr = vtop[0].r;\n\tvtop--;\n\tC67_MPYI(fr, r);\t// 32 bit multiply  fr,r,fr\n\tC67_NOP(8);\t\t// NOP 8 for worst case\n\tbreak;\n    case TOK_SHL:\n\tgv2(RC_INT_BSIDE, RC_INT_BSIDE);\t// shift amount must be on same side as dst\n\tr = vtop[-1].r;\n\tfr = vtop[0].r;\n\tvtop--;\n\tC67_SHL(fr, r);\t\t// arithmetic/logical shift\n\tbreak;\n\n    case TOK_SHR:\n\tgv2(RC_INT_BSIDE, RC_INT_BSIDE);\t// shift amount must be on same side as dst\n\tr = vtop[-1].r;\n\tfr = vtop[0].r;\n\tvtop--;\n\tC67_SHRU(fr, r);\t// logical shift\n\tbreak;\n\n    case TOK_SAR:\n\tgv2(RC_INT_BSIDE, RC_INT_BSIDE);\t// shift amount must be on same side as dst\n\tr = vtop[-1].r;\n\tfr = vtop[0].r;\n\tvtop--;\n\tC67_SHR(fr, r);\t\t// arithmetic shift\n\tbreak;\n\n    case '/':\n\tt = TOK__divi;\n      call_func:\n\tvswap();\n\t/* call generic idiv function */\n\tvpush_helper_func(t);\n\tvrott(3);\n\tgfunc_call(2);\n\tvpushi(0);\n\tvtop->r = REG_IRET;\n\tvtop->r2 = VT_CONST;\n\tbreak;\n    case TOK_UDIV:\n    case TOK_PDIV:\n\tt = TOK__divu;\n\tgoto call_func;\n    case '%':\n\tt = TOK__remi;\n\tgoto call_func;\n    case TOK_UMOD:\n\tt = TOK__remu;\n\tgoto call_func;\n\n    default:\n\topc = 7;\n\tgoto gen_op8;\n    }\n}", "path": "tinycc/c67-gen.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "TinyCC/tinycc", "stars": 1750, "license": "lgpl-2.1", "language": "c", "size": 4761}
{"docstring": "/* generate a test. set 'inv' to invert test. Stack entry is popped */\n", "func_signal": "ST_FUNC int gjmp_cond(int op, int t)", "code": "{\n        int ind1;\n        int inv = op & 1;\n        if (nocode_wanted)\n            return t;\n\n\t/* fast case : can jump directly since flags are set */\n\t// C67 uses B2 sort of as flags register\n\tind1 = ind;\n\tC67_MVKL(C67_A0, t);\t//r=reg to load, constant\n\tC67_MVKH(C67_A0, t);\t//r=reg to load, constant\n\n\tif (C67_compare_reg != TREG_EAX &&\t// check if not already in a conditional test reg\n\t    C67_compare_reg != TREG_EDX &&\n\t    C67_compare_reg != TREG_ST0 && C67_compare_reg != C67_B2) {\n\t    C67_MV(C67_compare_reg, C67_B2);\n\t    C67_compare_reg = C67_B2;\n\t}\n\n\tC67_IREG_B_REG(C67_invert_test ^ inv, C67_compare_reg, C67_A0);\t// [!R] B.S2x  A0\n\tC67_NOP(5);\n\tt = ind1;\t\t//return where we need to patch\n\n        return t;\n}", "path": "tinycc/c67-gen.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "TinyCC/tinycc", "stars": 1750, "license": "lgpl-2.1", "language": "c", "size": 4761}
{"docstring": "/* computed goto support */\n", "func_signal": "void ggoto(void)", "code": "{\n    gcall_or_jmp(1);\n    vtop--;\n}", "path": "tinycc/c67-gen.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "TinyCC/tinycc", "stars": 1750, "license": "lgpl-2.1", "language": "c", "size": 4761}
{"docstring": "/* Return the number of registers needed to return the struct, or 0 if\n   returning via struct pointer. */\n", "func_signal": "ST_FUNC int gfunc_sret(CType *vt, int variadic, CType *ret, int *ret_align, int *regsize)", "code": "{\n    *ret_align = 1; // Never have to re-align return values for x86-64\n    return 0;\n}", "path": "tinycc/c67-gen.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "TinyCC/tinycc", "stars": 1750, "license": "lgpl-2.1", "language": "c", "size": 4761}
{"docstring": "/* 'is_jmp' is '1' if it is a jump */\n", "func_signal": "static void gcall_or_jmp(int is_jmp)", "code": "{\n    int r;\n    Sym *sym;\n\n    if ((vtop->r & (VT_VALMASK | VT_LVAL)) == VT_CONST) {\n\t/* constant case */\n\tif (vtop->r & VT_SYM) {\n\t    /* relocation case */\n\n\t    // get add into A0, then start the jump B3\n\n\t    greloc(cur_text_section, vtop->sym, ind, R_C60LO16);\t// rem the inst need to be patched\n\t    greloc(cur_text_section, vtop->sym, ind + 4, R_C60HI16);\n\n\t    C67_MVKL(C67_A0, 0);\t//r=reg to load, constant\n\t    C67_MVKH(C67_A0, 0);\t//r=reg to load, constant\n\t    C67_IREG_B_REG(0, C67_CREG_ZERO, C67_A0);\t//  B.S2x  A0\n\n\t    if (is_jmp) {\n\t\tC67_NOP(5);\t// simple jump, just put NOP\n\t    } else {\n\t\t// Call, must load return address into B3 during delay slots\n\n\t\tsym = get_sym_ref(&char_pointer_type, cur_text_section, ind + 12, 0);\t// symbol for return address\n\t\tgreloc(cur_text_section, sym, ind, R_C60LO16);\t// rem the inst need to be patched\n\t\tgreloc(cur_text_section, sym, ind + 4, R_C60HI16);\n\t\tC67_MVKL(C67_B3, 0);\t//r=reg to load, constant\n\t\tC67_MVKH(C67_B3, 0);\t//r=reg to load, constant\n\t\tC67_NOP(3);\t// put remaining NOPs\n\t    }\n\t} else {\n\t    /* put an empty PC32 relocation */\n\t    ALWAYS_ASSERT(FALSE);\n\t}\n    } else {\n\t/* otherwise, indirect call */\n\tr = gv(RC_INT);\n\tC67_IREG_B_REG(0, C67_CREG_ZERO, r);\t//  B.S2x  r\n\n\tif (is_jmp) {\n\t    C67_NOP(5);\t\t// simple jump, just put NOP\n\t} else {\n\t    // Call, must load return address into B3 during delay slots\n\n\t    sym = get_sym_ref(&char_pointer_type, cur_text_section, ind + 12, 0);\t// symbol for return address\n\t    greloc(cur_text_section, sym, ind, R_C60LO16);\t// rem the inst need to be patched\n\t    greloc(cur_text_section, sym, ind + 4, R_C60HI16);\n\t    C67_MVKL(C67_B3, 0);\t//r=reg to load, constant\n\t    C67_MVKH(C67_B3, 0);\t//r=reg to load, constant\n\t    C67_NOP(3);\t\t// put remaining NOPs\n\t}\n    }\n}", "path": "tinycc/c67-gen.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "TinyCC/tinycc", "stars": 1750, "license": "lgpl-2.1", "language": "c", "size": 4761}
{"docstring": "// mapping from tcc reg number to \n// C67 register to condition code field\n//\n// valid condition code regs are:\n//\n// tcc reg 2 ->B0 -> 1\n// tcc reg 3 ->B1 -> 2\n// tcc reg 0 -> A2 -> 5\n// tcc reg 1 -> A3 -> X\n// tcc reg      B2 -> 3\n", "func_signal": "int C67_map_regc(int r)", "code": "{\n    if (r == 0)\t\t\t// normal tcc regs\n\treturn 0x5;\n    else if (r == 2)\t\t// normal tcc regs\n\treturn 0x1;\n    else if (r == 3)\t\t// normal tcc regs\n\treturn 0x2;\n    else if (r == C67_B2)\t// normal tcc regs\n\treturn 0x3;\n    else if (r == C67_CREG_ZERO)\n\treturn 0;\t\t// Special code for no condition reg test\n    else\n\tALWAYS_ASSERT(FALSE);\n\n    return 0;\n}", "path": "tinycc/c67-gen.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "TinyCC/tinycc", "stars": 1750, "license": "lgpl-2.1", "language": "c", "size": 4761}
{"docstring": "/* generate a floating point operation 'v = t1 op t2' instruction. The\n   two operands are guaranteed to have the same floating point type */\n/* XXX: need to use ST1 too */\n", "func_signal": "void gen_opf(int op)", "code": "{\n    int ft, fc, fr, r;\n\n    if (op >= TOK_ULT && op <= TOK_GT)\n\tgv2(RC_EDX, RC_EAX);\t// make sure src2 is on b side\n    else\n\tgv2(RC_FLOAT, RC_FLOAT);\t// make sure src2 is on b side\n\n    ft = vtop->type.t;\n    fc = vtop->c.i;\n    r = vtop->r;\n    fr = vtop[-1].r;\n\n\n    if ((ft & VT_BTYPE) == VT_LDOUBLE)\n\ttcc_error(\"long doubles not supported\");\n\n    if (op >= TOK_ULT && op <= TOK_GT) {\n\n\tr = vtop[-1].r;\n\tfr = vtop[0].r;\n\n\tC67_compare_reg = C67_B2;\n\n\tif (op == TOK_LT) {\n\t    if ((ft & VT_BTYPE) == VT_DOUBLE)\n\t\tC67_CMPLTDP(r, fr, C67_B2);\n\t    else\n\t\tC67_CMPLTSP(r, fr, C67_B2);\n\n\t    C67_invert_test = FALSE;\n\t} else if (op == TOK_GE) {\n\t    if ((ft & VT_BTYPE) == VT_DOUBLE)\n\t\tC67_CMPLTDP(r, fr, C67_B2);\n\t    else\n\t\tC67_CMPLTSP(r, fr, C67_B2);\n\n\t    C67_invert_test = TRUE;\n\t} else if (op == TOK_GT) {\n\t    if ((ft & VT_BTYPE) == VT_DOUBLE)\n\t\tC67_CMPGTDP(r, fr, C67_B2);\n\t    else\n\t\tC67_CMPGTSP(r, fr, C67_B2);\n\n\t    C67_invert_test = FALSE;\n\t} else if (op == TOK_LE) {\n\t    if ((ft & VT_BTYPE) == VT_DOUBLE)\n\t\tC67_CMPGTDP(r, fr, C67_B2);\n\t    else\n\t\tC67_CMPGTSP(r, fr, C67_B2);\n\n\t    C67_invert_test = TRUE;\n\t} else if (op == TOK_EQ) {\n\t    if ((ft & VT_BTYPE) == VT_DOUBLE)\n\t\tC67_CMPEQDP(r, fr, C67_B2);\n\t    else\n\t\tC67_CMPEQSP(r, fr, C67_B2);\n\n\t    C67_invert_test = FALSE;\n\t} else if (op == TOK_NE) {\n\t    if ((ft & VT_BTYPE) == VT_DOUBLE)\n\t\tC67_CMPEQDP(r, fr, C67_B2);\n\t    else\n\t\tC67_CMPEQSP(r, fr, C67_B2);\n\n\t    C67_invert_test = TRUE;\n\t} else {\n\t    ALWAYS_ASSERT(FALSE);\n\t}\n        vset_VT_CMP(0x80);\n    } else {\n\tif (op == '+') {\n\t    if ((ft & VT_BTYPE) == VT_DOUBLE) {\n\t\tC67_ADDDP(r, fr);\t// ADD  fr,r,fr\n\t\tC67_NOP(6);\n\t    } else {\n\t\tC67_ADDSP(r, fr);\t// ADD  fr,r,fr\n\t\tC67_NOP(3);\n\t    }\n\t    vtop--;\n\t} else if (op == '-') {\n\t    if ((ft & VT_BTYPE) == VT_DOUBLE) {\n\t\tC67_SUBDP(r, fr);\t// SUB  fr,r,fr\n\t\tC67_NOP(6);\n\t    } else {\n\t\tC67_SUBSP(r, fr);\t// SUB  fr,r,fr\n\t\tC67_NOP(3);\n\t    }\n\t    vtop--;\n\t} else if (op == '*') {\n\t    if ((ft & VT_BTYPE) == VT_DOUBLE) {\n\t\tC67_MPYDP(r, fr);\t// MPY  fr,r,fr\n\t\tC67_NOP(9);\n\t    } else {\n\t\tC67_MPYSP(r, fr);\t// MPY  fr,r,fr\n\t\tC67_NOP(3);\n\t    }\n\t    vtop--;\n\t} else if (op == '/') {\n\t    if ((ft & VT_BTYPE) == VT_DOUBLE) {\n\t\t// must call intrinsic DP floating point divide\n\t\tvswap();\n\t\t/* call generic idiv function */\n\t\tvpush_helper_func(TOK__divd);\n\t\tvrott(3);\n\t\tgfunc_call(2);\n\t\tvpushi(0);\n\t\tvtop->r = REG_FRET;\n\t\tvtop->r2 = REG_IRE2;\n\n\t    } else {\n\t\t// must call intrinsic SP floating point divide\n\t\tvswap();\n\t\t/* call generic idiv function */\n\t\tvpush_helper_func(TOK__divf);\n\t\tvrott(3);\n\t\tgfunc_call(2);\n\t\tvpushi(0);\n\t\tvtop->r = REG_FRET;\n\t\tvtop->r2 = VT_CONST;\n\t    }\n\t} else\n\t    ALWAYS_ASSERT(FALSE);\n\n\n    }\n}", "path": "tinycc/c67-gen.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "TinyCC/tinycc", "stars": 1750, "license": "lgpl-2.1", "language": "c", "size": 4761}
{"docstring": "/* generate a jump to a label */\n", "func_signal": "int gjmp(int t)", "code": "{\n    int ind1 = ind;\n    if (nocode_wanted)\n        return t;\n\n    C67_MVKL(C67_A0, t);\t//r=reg to load,  constant\n    C67_MVKH(C67_A0, t);\t//r=reg to load,  constant\n    C67_IREG_B_REG(0, C67_CREG_ZERO, C67_A0);\t// [!R] B.S2x  A0\n    C67_NOP(5);\n    return ind1;\n}", "path": "tinycc/c67-gen.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "TinyCC/tinycc", "stars": 1750, "license": "lgpl-2.1", "language": "c", "size": 4761}
{"docstring": "/* store register 'r' in lvalue 'v' */\n", "func_signal": "void store(int r, SValue * v)", "code": "{\n    int fr, bt, ft, fc, size, t, element;\n\n    ft = v->type.t;\n    fc = v->c.i;\n    fr = v->r & VT_VALMASK;\n    bt = ft & VT_BTYPE;\n    /* XXX: incorrect if float reg to reg */\n\n    if (bt == VT_LDOUBLE) {\n\ttcc_error(\"long double not supported\");\n    } else {\n\tif (bt == VT_SHORT)\n\t    size = 2;\n\telse if (bt == VT_BYTE)\n\t    size = 1;\n\telse if (bt == VT_DOUBLE)\n\t    size = 8;\n\telse\n\t    size = 4;\n\n\tif ((v->r & VT_VALMASK) == VT_CONST) {\n\t    /* constant memory reference */\n\n\t    if (v->r & VT_SYM) {\n\t\tgreloc(cur_text_section, v->sym, ind, R_C60LO16);\t// rem the inst need to be patched\n\t\tgreloc(cur_text_section, v->sym, ind + 4, R_C60HI16);\n\t    }\n\t    C67_MVKL(C67_A0, fc);\t//r=reg to load,  constant\n\t    C67_MVKH(C67_A0, fc);\t//r=reg to load,  constant\n\n\t    if (size == 1)\n\t\tC67_STB_PTR(r, C67_A0);\t// STB  r, *A0\n\t    else if (size == 2)\n\t\tC67_STH_PTR(r, C67_A0);\t// STH  r, *A0\n\t    else if (size == 4 || size == 8)\n\t\tC67_STW_PTR(r, C67_A0);\t// STW  r, *A0\n\n\t    if (size == 8)\n\t\tC67_STW_PTR_PRE_INC(r + 1, C67_A0, 1);\t// STW  r, *+A0[1]\n\t} else if ((v->r & VT_VALMASK) == VT_LOCAL) {\n\t    // check case of storing to passed argument that\n\t    // tcc thinks is on the stack but for C67 is\n\t    // passed as a reg.  However it may have been\n\t    // saved to the stack, if that reg was required\n\t    // for a call to a child function\n\n\t    if (fc > 0)\t\t// argument ??\n\t    {\n\t\t// walk through sizes and figure which param\n\n\t\tint stack_pos = 8;\n\n\t\tfor (t = 0; t < NoCallArgsPassedOnStack; t++) {\n\t\t    if (fc == stack_pos)\n\t\t\tbreak;\n\n\t\t    stack_pos += TranslateStackToReg[t];\n\t\t}\n\n\t\t// param has been pushed on stack, get it like a local var\n\t\tfc = ParamLocOnStack[t] - 8;\n\t    }\n\n\t    if (size == 8)\n\t\telement = 4;\n\t    else\n\t\telement = size;\n\n\t    // divide offset in bytes to create word index\n\t    C67_MVKL(C67_A0, (fc / element) + 8 / element);\t//r=reg to load,  constant\n\t    C67_MVKH(C67_A0, (fc / element) + 8 / element);\t//r=reg to load,  constant\n\n\n\n\t    if (size == 1)\n\t\tC67_STB_SP_A0(r);\t// STB  r, SP[A0]\n\t    else if (size == 2)\n\t\tC67_STH_SP_A0(r);\t// STH  r, SP[A0]\n\t    else if (size == 4 || size == 8)\n\t\tC67_STW_SP_A0(r);\t// STW  r, SP[A0]\n\n\t    if (size == 8) {\n\t\tC67_ADDK(1, C67_A0);\t//  ADDK 1,A0\n\t\tC67_STW_SP_A0(r + 1);\t//  STW  r, SP[A0]\n\t    }\n\t} else {\n\t    if (size == 1)\n\t\tC67_STB_PTR(r, fr);\t// STB  r, *fr\n\t    else if (size == 2)\n\t\tC67_STH_PTR(r, fr);\t// STH  r, *fr\n\t    else if (size == 4 || size == 8)\n\t\tC67_STW_PTR(r, fr);\t// STW  r, *fr\n\n\t    if (size == 8) {\n\t\tC67_STW_PTR_PRE_INC(r + 1, fr, 1);\t// STW  r, *+fr[1]\n\t    }\n\t}\n    }\n}", "path": "tinycc/c67-gen.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "TinyCC/tinycc", "stars": 1750, "license": "lgpl-2.1", "language": "c", "size": 4761}
{"docstring": "/* generate function prolog of type 't' */\n", "func_signal": "void gfunc_prolog(Sym *func_sym)", "code": "{\n    CType *func_type = &func_sym->type;\n    int addr, align, size, func_call, i;\n    Sym *sym;\n    CType *type;\n\n    sym = func_type->ref;\n    func_call = sym->f.func_call;\n    addr = 8;\n    /* if the function returns a structure, then add an\n       implicit pointer parameter */\n    if ((func_vt.t & VT_BTYPE) == VT_STRUCT) {\n\tfunc_vc = addr;\n\taddr += 4;\n    }\n\n    NoOfCurFuncArgs = 0;\n\n    /* define parameters */\n    while ((sym = sym->next) != NULL) {\n\ttype = &sym->type;\n\tsym_push(sym->v & ~SYM_FIELD, type, VT_LOCAL | VT_LVAL, addr);\n\tsize = type_size(type, &align);\n\tsize = (size + 3) & ~3;\n\n\t// keep track of size of arguments so\n\t// we can translate where tcc thinks they\n\t// are on the stack into the appropriate reg\n\n\tTranslateStackToReg[NoOfCurFuncArgs] = size;\n\tNoOfCurFuncArgs++;\n\n#ifdef FUNC_STRUCT_PARAM_AS_PTR\n\t/* structs are passed as pointer */\n\tif ((type->t & VT_BTYPE) == VT_STRUCT) {\n\t    size = 4;\n\t}\n#endif\n\taddr += size;\n    }\n    func_ret_sub = 0;\n    /* pascal type call ? */\n    if (func_call == FUNC_STDCALL)\n\tfunc_ret_sub = addr - 8;\n\n    C67_MV(C67_FP, C67_A0);\t//  move FP -> A0\n    C67_MV(C67_SP, C67_FP);\t//  move SP -> FP\n\n    // place all the args passed in regs onto the stack\n\n    loc = 0;\n    for (i = 0; i < NoOfCurFuncArgs; i++) {\n\n\tParamLocOnStack[i] = loc;\t// remember where the param is\n\tloc += -8;\n\n\tC67_PUSH(TREG_C67_A4 + i * 2);\n\n\tif (TranslateStackToReg[i] == 8) {\n\t    C67_STW_PTR_PRE_INC(TREG_C67_A4 + i * 2 + 1, C67_SP, 3);\t// STW  r, *+SP[1] (go back and put the other)\n\t}\n    }\n\n    TotalBytesPushedOnStack = -loc;\n\n    func_sub_sp_offset = ind;\t// remember where we put the stack instruction \n    C67_ADDK(0, C67_SP);\t//  ADDK.L2 loc,SP  (just put zero temporarily)\n\n    C67_PUSH(C67_A0);\n    C67_PUSH(C67_B3);\n}", "path": "tinycc/c67-gen.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "TinyCC/tinycc", "stars": 1750, "license": "lgpl-2.1", "language": "c", "size": 4761}
{"docstring": "/* load 'r' from value 'sv' */\n", "func_signal": "void load(int r, SValue * sv)", "code": "{\n    int v, t, ft, fc, fr, size = 0, element;\n    BOOL Unsigned = FALSE;\n    SValue v1;\n\n    fr = sv->r;\n    ft = sv->type.t;\n    fc = sv->c.i;\n\n    v = fr & VT_VALMASK;\n    if (fr & VT_LVAL) {\n\tif (v == VT_LLOCAL) {\n\t    v1.type.t = VT_INT;\n\t    v1.r = VT_LOCAL | VT_LVAL;\n\t    v1.c.i = fc;\n\t    load(r, &v1);\n\t    fr = r;\n\t} else if ((ft & VT_BTYPE) == VT_LDOUBLE) {\n\t    tcc_error(\"long double not supported\");\n\t} else if ((ft & VT_TYPE) == VT_BYTE) {\n\t    size = 1;\n\t} else if ((ft & VT_TYPE) == (VT_BYTE | VT_UNSIGNED)) {\n\t    size = 1;\n\t    Unsigned = TRUE;\n\t} else if ((ft & VT_TYPE) == VT_SHORT) {\n\t    size = 2;\n\t} else if ((ft & VT_TYPE) == (VT_SHORT | VT_UNSIGNED)) {\n\t    size = 2;\n\t    Unsigned = TRUE;\n\t} else if ((ft & VT_BTYPE) == VT_DOUBLE) {\n\t    size = 8;\n\t} else {\n\t    size = 4;\n\t}\n\n\t// check if fc is a positive reference on the stack, \n\t// if it is tcc is referencing what it thinks is a parameter\n\t// on the stack, so check if it is really in a register.\n\n\n\tif (v == VT_LOCAL && fc > 0) {\n\t    int stack_pos = 8;\n\n\t    for (t = 0; t < NoCallArgsPassedOnStack; t++) {\n\t\tif (fc == stack_pos)\n\t\t    break;\n\n\t\tstack_pos += TranslateStackToReg[t];\n\t    }\n\n\t    // param has been pushed on stack, get it like a local var\n\n\t    fc = ParamLocOnStack[t] - 8;\n\t}\n\n\tif ((fr & VT_VALMASK) < VT_CONST)\t// check for pure indirect\n\t{\n\t    if (size == 1) {\n\t\tif (Unsigned)\n\t\t    C67_LDBU_PTR(v, r);\t// LDBU  *v,r\n\t\telse\n\t\t    C67_LDB_PTR(v, r);\t// LDB  *v,r\n\t    } else if (size == 2) {\n\t\tif (Unsigned)\n\t\t    C67_LDHU_PTR(v, r);\t// LDHU  *v,r\n\t\telse\n\t\t    C67_LDH_PTR(v, r);\t// LDH  *v,r\n\t    } else if (size == 4) {\n\t\tC67_LDW_PTR(v, r);\t// LDW  *v,r\n\t    } else if (size == 8) {\n\t\tC67_LDDW_PTR(v, r);\t// LDDW  *v,r\n\t    }\n\n\t    C67_NOP(4);\t\t// NOP 4\n\t    return;\n\t} else if (fr & VT_SYM) {\n\t    greloc(cur_text_section, sv->sym, ind, R_C60LO16);\t// rem the inst need to be patched\n\t    greloc(cur_text_section, sv->sym, ind + 4, R_C60HI16);\n\n\n\t    C67_MVKL(C67_A0, fc);\t//r=reg to load,  constant\n\t    C67_MVKH(C67_A0, fc);\t//r=reg to load,  constant\n\n\n\t    if (size == 1) {\n\t\tif (Unsigned)\n\t\t    C67_LDBU_PTR(C67_A0, r);\t// LDBU  *A0,r\n\t\telse\n\t\t    C67_LDB_PTR(C67_A0, r);\t// LDB  *A0,r\n\t    } else if (size == 2) {\n\t\tif (Unsigned)\n\t\t    C67_LDHU_PTR(C67_A0, r);\t// LDHU  *A0,r\n\t\telse\n\t\t    C67_LDH_PTR(C67_A0, r);\t// LDH  *A0,r\n\t    } else if (size == 4) {\n\t\tC67_LDW_PTR(C67_A0, r);\t// LDW  *A0,r\n\t    } else if (size == 8) {\n\t\tC67_LDDW_PTR(C67_A0, r);\t// LDDW  *A0,r\n\t    }\n\n\t    C67_NOP(4);\t\t// NOP 4\n\t    return;\n\t} else {\n\t    element = size;\n\n\t    // divide offset in bytes to create element index\n\t    C67_MVKL(C67_A0, (fc / element) + 8 / element);\t//r=reg to load,  constant\n\t    C67_MVKH(C67_A0, (fc / element) + 8 / element);\t//r=reg to load,  constant\n\n\t    if (size == 1) {\n\t\tif (Unsigned)\n\t\t    C67_LDBU_SP_A0(r);\t// LDBU  r, SP[A0]\n\t\telse\n\t\t    C67_LDB_SP_A0(r);\t// LDB  r, SP[A0]\n\t    } else if (size == 2) {\n\t\tif (Unsigned)\n\t\t    C67_LDHU_SP_A0(r);\t// LDHU  r, SP[A0]\n\t\telse\n\t\t    C67_LDH_SP_A0(r);\t// LDH  r, SP[A0]\n\t    } else if (size == 4) {\n\t\tC67_LDW_SP_A0(r);\t// LDW  r, SP[A0]\n\t    } else if (size == 8) {\n\t\tC67_LDDW_SP_A0(r);\t// LDDW  r, SP[A0]\n\t    }\n\n\n\t    C67_NOP(4);\t\t// NOP 4\n\t    return;\n\t}\n    } else {\n\tif (v == VT_CONST) {\n\t    if (fr & VT_SYM) {\n\t\tgreloc(cur_text_section, sv->sym, ind, R_C60LO16);\t// rem the inst need to be patched\n\t\tgreloc(cur_text_section, sv->sym, ind + 4, R_C60HI16);\n\t    }\n\t    C67_MVKL(r, fc);\t//r=reg to load, constant\n\t    C67_MVKH(r, fc);\t//r=reg to load, constant\n\t} else if (v == VT_LOCAL) {\n\t    C67_MVKL(r, fc + 8);\t//r=reg to load, constant C67 stack points to next free\n\t    C67_MVKH(r, fc + 8);\t//r=reg to load, constant\n\t    C67_ADD(C67_FP, r);\t// MV v,r   v -> r\n\t} else if (v == VT_CMP) {\n\t    C67_MV(C67_compare_reg, r);\t// MV v,r   v -> r\n\t} else if (v == VT_JMP || v == VT_JMPI) {\n\t    t = v & 1;\n\t    C67_B_DISP(4);\t//  Branch with constant displacement, skip over this branch, load, nop, load\n\t    C67_MVKL(r, t);\t//  r=reg to load, 0 or 1 (do this while branching)\n\t    C67_NOP(4);\t\t//  NOP 4\n\t    gsym(fc);\t\t//  modifies other branches to branch here\n\t    C67_MVKL(r, t ^ 1);\t//  r=reg to load, 0 or 1\n\t} else if (v != r) {\n\t    C67_MV(v, r);\t// MV v,r   v -> r\n\n\t    if ((ft & VT_BTYPE) == VT_DOUBLE)\n\t\tC67_MV(v + 1, r + 1);\t// MV v,r   v -> r\n\t}\n    }\n}", "path": "tinycc/c67-gen.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "TinyCC/tinycc", "stars": 1750, "license": "lgpl-2.1", "language": "c", "size": 4761}
{"docstring": "/* -------------------------------------------------------------\n *  This is for compiled windows resources in 'coff' format\n *  as generated by 'windres.exe -O coff ...'.\n */\n", "func_signal": "static int pe_load_res(TCCState *s1, int fd)", "code": "{\n    struct pe_rsrc_header hdr;\n    Section *rsrc_section;\n    int i, ret = -1, sym_index;\n    BYTE *ptr;\n    unsigned offs;\n\n    if (!read_mem(fd, 0, &hdr, sizeof hdr))\n        goto quit;\n\n    if (hdr.filehdr.Machine != IMAGE_FILE_MACHINE\n        || hdr.filehdr.NumberOfSections != 1\n        || strcmp((char*)hdr.sectionhdr.Name, \".rsrc\") != 0)\n        goto quit;\n\n    rsrc_section = new_section(s1, \".rsrc\", SHT_PROGBITS, SHF_ALLOC);\n    ptr = section_ptr_add(rsrc_section, hdr.sectionhdr.SizeOfRawData);\n    offs = hdr.sectionhdr.PointerToRawData;\n    if (!read_mem(fd, offs, ptr, hdr.sectionhdr.SizeOfRawData))\n        goto quit;\n    offs = hdr.sectionhdr.PointerToRelocations;\n    sym_index = put_elf_sym(symtab_section, 0, 0, 0, 0, rsrc_section->sh_num, \".rsrc\");\n    for (i = 0; i < hdr.sectionhdr.NumberOfRelocations; ++i) {\n        struct pe_rsrc_reloc rel;\n        if (!read_mem(fd, offs, &rel, sizeof rel))\n            goto quit;\n        // printf(\"rsrc_reloc: %x %x %x\\n\", rel.offset, rel.size, rel.type);\n        if (rel.type != RSRC_RELTYPE)\n            goto quit;\n        put_elf_reloc(symtab_section, rsrc_section,\n            rel.offset, R_XXX_RELATIVE, sym_index);\n        offs += sizeof rel;\n    }\n    ret = 0;\nquit:\n    return ret;\n}", "path": "tinycc/tccpe.c", "commit_date": "2020-12-17 00:00:00", "repo_name": "TinyCC/tinycc", "stars": 1750, "license": "lgpl-2.1", "language": "c", "size": 4761}
{"docstring": "/* generate function call with address in (vtop->t, vtop->c) and free function\n   context. Stack entry is popped */\n", "func_signal": "void gfunc_call(int nb_args)", "code": "{\n    int i, r, size = 0;\n    int args_sizes[NoCallArgsPassedOnStack];\n\n    if (nb_args > NoCallArgsPassedOnStack) {\n\ttcc_error(\"more than 10 function params not currently supported\");\n\t// handle more than 10, put some on the stack\n    }\n\n    for (i = 0; i < nb_args; i++) {\n\tif ((vtop->type.t & VT_BTYPE) == VT_STRUCT) {\n\t    ALWAYS_ASSERT(FALSE);\n\t} else {\n\t    /* simple type (currently always same size) */\n\t    /* XXX: implicit cast ? */\n\n\n\t    if ((vtop->type.t & VT_BTYPE) == VT_LLONG) {\n\t\ttcc_error(\"long long not supported\");\n\t    } else if ((vtop->type.t & VT_BTYPE) == VT_LDOUBLE) {\n\t\ttcc_error(\"long double not supported\");\n\t    } else if ((vtop->type.t & VT_BTYPE) == VT_DOUBLE) {\n\t\tsize = 8;\n\t    } else {\n\t\tsize = 4;\n\t    }\n\n\t    // put the parameter into the corresponding reg (pair)\n\n\t    r = gv(RC_C67_A4 << (2 * i));\n\n\t    // must put on stack because with 1 pass compiler , no way to tell\n\t    // if an up coming nested call might overwrite these regs\n\n\t    C67_PUSH(r);\n\n\t    if (size == 8) {\n\t\tC67_STW_PTR_PRE_INC(r + 1, C67_SP, 3);\t// STW  r, *+SP[3] (go back and put the other)\n\t    }\n\t    args_sizes[i] = size;\n\t}\n\tvtop--;\n    }\n    // POP all the params on the stack into registers for the\n    // immediate call (in reverse order)\n\n    for (i = nb_args - 1; i >= 0; i--) {\n\n\tif (args_sizes[i] == 8)\n\t    C67_POP_DW(TREG_C67_A4 + i * 2);\n\telse\n\t    C67_POP(TREG_C67_A4 + i * 2);\n    }\n    gcall_or_jmp(0);\n    vtop--;\n}", "path": "tinycc/c67-gen.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "TinyCC/tinycc", "stars": 1750, "license": "lgpl-2.1", "language": "c", "size": 4761}
{"docstring": "/* convert from one floating point type to another */\n", "func_signal": "void gen_cvt_ftof(int t)", "code": "{\n    int r, r2;\n\n    if ((vtop->type.t & VT_BTYPE) == VT_DOUBLE &&\n\t(t & VT_BTYPE) == VT_FLOAT) {\n\t// convert double to float\n\n\tgv(RC_FLOAT);\t\t// get it in a register pair\n\n\tr = vtop->r;\n\n\tC67_DPSP(r, r);\t\t// convert it to SP same register\n\tC67_NOP(3);\n\n\tvtop->type.t = VT_FLOAT;\n\tvtop->r2 = VT_CONST;\t// set this as unused\n    } else if ((vtop->type.t & VT_BTYPE) == VT_FLOAT &&\n\t       (t & VT_BTYPE) == VT_DOUBLE) {\n\t// convert float to double\n\n\tgv(RC_FLOAT);\t\t// get it in a register\n\n\tr = vtop->r;\n\n\tif (r == TREG_EAX) {\t// make sure the paired reg is avail\n\t    r2 = get_reg(RC_ECX);\n\t} else if (r == TREG_EDX) {\n\t    r2 = get_reg(RC_ST0);\n\t} else {\n\t    ALWAYS_ASSERT(FALSE);\n            r2 = 0; /* avoid warning */\n        }\n\n\tC67_SPDP(r, r);\t\t// convert it to DP same register\n\tC67_NOP(1);\n\n\tvtop->type.t = VT_DOUBLE;\n\tvtop->r2 = r2;\t\t// set this as unused\n    } else {\n\tALWAYS_ASSERT(FALSE);\n    }\n}", "path": "tinycc/c67-gen.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "TinyCC/tinycc", "stars": 1750, "license": "lgpl-2.1", "language": "c", "size": 4761}
{"docstring": "// map TCC reg to C67 reg number\n", "func_signal": "int C67_map_regn(int r)", "code": "{\n    if (r == 0)\t\t\t// normal tcc regs\n\treturn 0x2;\t\t// A2\n    else if (r == 1)\t\t// normal tcc regs\n\treturn 3;\t\t// A3\n    else if (r == 2)\t\t// normal tcc regs\n\treturn 0;\t\t// B0\n    else if (r == 3)\t\t// normal tcc regs\n\treturn 1;\t\t// B1\n    else if (r >= TREG_C67_A4 && r <= TREG_C67_B13)\t// these form a pattern of alt pairs\n\treturn (((r & 0xfffffffc) >> 1) | (r & 1)) + 2;\n    else if (r == C67_A0)\n\treturn 0;\t\t// set to A0 (offset reg)\n    else if (r == C67_B2)\n\treturn 2;\t\t// set to B2 (offset reg)\n    else if (r == C67_B3)\n\treturn 3;\t\t// set to B3 (return address reg)\n    else if (r == C67_SP)\n\treturn 15;\t\t// set to SP (B15) (offset reg)\n    else if (r == C67_FP)\n\treturn 15;\t\t// set to FP (A15) (offset reg)\n    else if (r == C67_CREG_ZERO)\n\treturn 0;\t\t// Special code for no condition reg test\n    else\n\tALWAYS_ASSERT(FALSE);\n\n    return 0;\n}", "path": "tinycc/c67-gen.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "TinyCC/tinycc", "stars": 1750, "license": "lgpl-2.1", "language": "c", "size": 4761}
{"docstring": "/* convert integers to fp 't' type. Must handle 'int', 'unsigned int'\n   and 'long long' cases. */\n", "func_signal": "void gen_cvt_itof(int t)", "code": "{\n    int r;\n\n    gv(RC_INT);\n    r = vtop->r;\n\n    if ((t & VT_BTYPE) == VT_DOUBLE) {\n\tif (t & VT_UNSIGNED)\n\t    C67_INTDPU(r, r);\n\telse\n\t    C67_INTDP(r, r);\n\n\tC67_NOP(4);\n\tvtop->type.t = VT_DOUBLE;\n    } else {\n\tif (t & VT_UNSIGNED)\n\t    C67_INTSPU(r, r);\n\telse\n\t    C67_INTSP(r, r);\n\tC67_NOP(3);\n\tvtop->type.t = VT_FLOAT;\n    }\n\n}", "path": "tinycc/c67-gen.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "TinyCC/tinycc", "stars": 1750, "license": "lgpl-2.1", "language": "c", "size": 4761}
{"docstring": "/* convert fp to int 't' type */\n/* XXX: handle long long case */\n", "func_signal": "void gen_cvt_ftoi(int t)", "code": "{\n    int r;\n\n    gv(RC_FLOAT);\n    r = vtop->r;\n\n    if (t != VT_INT)\n\ttcc_error(\"long long not supported\");\n    else {\n\tif ((vtop->type.t & VT_BTYPE) == VT_DOUBLE) {\n\t    C67_DPTRUNC(r, r);\n\t    C67_NOP(3);\n\t} else {\n\t    C67_SPTRUNC(r, r);\n\t    C67_NOP(3);\n\t}\n\n\tvtop->type.t = VT_INT;\n\n    }\n}", "path": "tinycc/c67-gen.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "TinyCC/tinycc", "stars": 1750, "license": "lgpl-2.1", "language": "c", "size": 4761}
{"docstring": "/* generate function epilog */\n", "func_signal": "void gfunc_epilog(void)", "code": "{\n    {\n\tint local = (-loc + 7) & -8;\t// stack must stay aligned to 8 bytes for LDDW instr\n\tC67_POP(C67_B3);\n\tC67_NOP(4);\t\t// NOP wait for load\n\tC67_IREG_B_REG(0, C67_CREG_ZERO, C67_B3);\t//  B.S2  B3\n\tC67_POP(C67_FP);\n\tC67_ADDK(local, C67_SP);\t//  ADDK.L2 loc,SP  \n\tC67_Adjust_ADDK((int *) (cur_text_section->data +\n\t\t\t\t func_sub_sp_offset),\n\t\t\t-local + TotalBytesPushedOnStack);\n\tC67_NOP(3);\t\t// NOP \n    }\n}", "path": "tinycc/c67-gen.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "TinyCC/tinycc", "stars": 1750, "license": "lgpl-2.1", "language": "c", "size": 4761}
{"docstring": "/* output a symbol and patch all calls to it */\n", "func_signal": "void gsym_addr(int t, int a)", "code": "{\n    int n, *ptr;\n    while (t) {\n\tptr = (int *) (cur_text_section->data + t);\n\t{\n\t    Sym *sym;\n\n\t    // extract 32 bit address from MVKH/MVKL\n\t    n = ((*ptr >> 7) & 0xffff);\n\t    n |= ((*(ptr + 1) >> 7) & 0xffff) << 16;\n\n\t    // define a label that will be relocated\n\n\t    sym = get_sym_ref(&char_pointer_type, cur_text_section, a, 0);\n\t    greloc(cur_text_section, sym, t, R_C60LO16);\n\t    greloc(cur_text_section, sym, t + 4, R_C60HI16);\n\n\t    // clear out where the pointer was\n\n\t    *ptr &= ~(0xffff << 7);\n\t    *(ptr + 1) &= ~(0xffff << 7);\n\t}\n\tt = n;\n    }\n}", "path": "tinycc/c67-gen.c", "commit_date": "2020-12-31 00:00:00", "repo_name": "TinyCC/tinycc", "stars": 1750, "license": "lgpl-2.1", "language": "c", "size": 4761}
{"docstring": "/*\n * Convert Excel A-XFD style column name to zero based number.\n */\n", "func_signal": "void\nlxw_col_to_name(char *col_name, lxw_col_t col_num, uint8_t absolute)", "code": "{\n    uint8_t pos = 0;\n    size_t len;\n    size_t i;\n\n    /* Change from 0 index to 1 index. */\n    col_num++;\n\n    /* Convert the column number to a string in reverse order. */\n    while (col_num) {\n\n        /* Get the remainder in base 26. */\n        int remainder = col_num % 26;\n\n        if (remainder == 0)\n            remainder = 26;\n\n        /* Convert the remainder value to a character. */\n        col_name[pos++] = 'A' + remainder - 1;\n        col_name[pos] = '\\0';\n\n        /* Get the next order of magnitude. */\n        col_num = (col_num - 1) / 26;\n    }\n\n    if (absolute) {\n        col_name[pos] = '$';\n        col_name[pos + 1] = '\\0';\n    }\n\n    /* Reverse the column name string. */\n    len = strlen(col_name);\n    for (i = 0; i < (len / 2); i++) {\n        char tmp = col_name[i];\n        col_name[i] = col_name[len - i - 1];\n        col_name[len - i - 1] = tmp;\n    }\n}", "path": "libxlsxwriter/src/utility.c", "commit_date": "2020-09-07 00:00:00", "repo_name": "jmcnamara/libxlsxwriter", "stars": 1347, "license": "other", "language": "c", "size": 24393}
{"docstring": "// Test the _write_override() function.\n", "func_signal": "CTEST(content_types, write_override)", "code": "{\n\n    char* got;\n    char exp[] = \"<Override PartName=\\\"/docProps/core.xml\\\" ContentType=\\\"app...\\\"/>\";\n    FILE* testfile = lxw_tmpfile(NULL);\n\n    lxw_content_types *content_types = lxw_content_types_new();\n    content_types->file = testfile;\n\n    _write_override(content_types, \"/docProps/core.xml\", \"app...\");\n\n    RUN_XLSX_STREQ(exp, got);\n\n    lxw_content_types_free(content_types);\n}", "path": "libxlsxwriter/test/unit/content_types/test_content_types_write_override.c", "commit_date": "2020-09-07 00:00:00", "repo_name": "jmcnamara/libxlsxwriter", "stars": 1347, "license": "other", "language": "c", "size": 24393}
{"docstring": "/*\n * Convert the second column of an Excel range ref to a zero indexed number.\n */\n", "func_signal": "uint16_t\nlxw_name_to_col_2(const char *col_str)", "code": "{\n    const char *p = col_str;\n\n    /* Find the : separator in the range. */\n    while (p && *p != ':')\n        p++;\n\n    if (p)\n        return lxw_name_to_col(++p);\n    else\n        return -1;\n}", "path": "libxlsxwriter/src/utility.c", "commit_date": "2020-09-07 00:00:00", "repo_name": "jmcnamara/libxlsxwriter", "stars": 1347, "license": "other", "language": "c", "size": 24393}
{"docstring": "// Test assembling a complete Worksheet file.\n", "func_signal": "CTEST(worksheet, worksheet_condtional_format19)", "code": "{\n\n    char* got;\n    char exp[] =\n            \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"yes\\\"?>\\n\"\n            \"<worksheet xmlns=\\\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\\\" xmlns:r=\\\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\\\">\"\n              \"<dimension ref=\\\"A1:A12\\\"/>\"\n              \"<sheetViews>\"\n                \"<sheetView tabSelected=\\\"1\\\" workbookViewId=\\\"0\\\"/>\"\n              \"</sheetViews>\"\n              \"<sheetFormatPr defaultRowHeight=\\\"15\\\"/>\"\n              \"<sheetData>\"\n                \"<row r=\\\"1\\\" spans=\\\"1:1\\\">\"\n                  \"<c r=\\\"A1\\\">\"\n                    \"<v>1</v>\"\n                  \"</c>\"\n                \"</row>\"\n                \"<row r=\\\"2\\\" spans=\\\"1:1\\\">\"\n                  \"<c r=\\\"A2\\\">\"\n                    \"<v>2</v>\"\n                  \"</c>\"\n                \"</row>\"\n                \"<row r=\\\"3\\\" spans=\\\"1:1\\\">\"\n                  \"<c r=\\\"A3\\\">\"\n                    \"<v>3</v>\"\n                  \"</c>\"\n                \"</row>\"\n                \"<row r=\\\"4\\\" spans=\\\"1:1\\\">\"\n                  \"<c r=\\\"A4\\\">\"\n                    \"<v>4</v>\"\n                  \"</c>\"\n                \"</row>\"\n                \"<row r=\\\"5\\\" spans=\\\"1:1\\\">\"\n                  \"<c r=\\\"A5\\\">\"\n                    \"<v>5</v>\"\n                  \"</c>\"\n                \"</row>\"\n                \"<row r=\\\"6\\\" spans=\\\"1:1\\\">\"\n                  \"<c r=\\\"A6\\\">\"\n                    \"<v>6</v>\"\n                  \"</c>\"\n                \"</row>\"\n                \"<row r=\\\"7\\\" spans=\\\"1:1\\\">\"\n                  \"<c r=\\\"A7\\\">\"\n                    \"<v>7</v>\"\n                  \"</c>\"\n                \"</row>\"\n                \"<row r=\\\"8\\\" spans=\\\"1:1\\\">\"\n                  \"<c r=\\\"A8\\\">\"\n                    \"<v>8</v>\"\n                  \"</c>\"\n                \"</row>\"\n                \"<row r=\\\"9\\\" spans=\\\"1:1\\\">\"\n                  \"<c r=\\\"A9\\\">\"\n                    \"<v>9</v>\"\n                  \"</c>\"\n                \"</row>\"\n                \"<row r=\\\"10\\\" spans=\\\"1:1\\\">\"\n                  \"<c r=\\\"A10\\\">\"\n                    \"<v>10</v>\"\n                  \"</c>\"\n                \"</row>\"\n                \"<row r=\\\"11\\\" spans=\\\"1:1\\\">\"\n                  \"<c r=\\\"A11\\\">\"\n                    \"<v>11</v>\"\n                  \"</c>\"\n                \"</row>\"\n                \"<row r=\\\"12\\\" spans=\\\"1:1\\\">\"\n                  \"<c r=\\\"A12\\\">\"\n                    \"<v>12</v>\"\n                  \"</c>\"\n                \"</row>\"\n              \"</sheetData>\"\n              \"<conditionalFormatting sqref=\\\"A1:A12\\\">\"\n                \"<cfRule type=\\\"dataBar\\\" priority=\\\"1\\\">\"\n                  \"<dataBar>\"\n                    \"<cfvo type=\\\"num\\\" val=\\\"5\\\"/>\"\n                    \"<cfvo type=\\\"percent\\\" val=\\\"90\\\"/>\"\n                    \"<color rgb=\\\"FF8DB4E3\\\"/>\"\n                  \"</dataBar>\"\n                \"</cfRule>\"\n              \"</conditionalFormatting>\"\n              \"<pageMargins left=\\\"0.7\\\" right=\\\"0.7\\\" top=\\\"0.75\\\" bottom=\\\"0.75\\\" header=\\\"0.3\\\" footer=\\\"0.3\\\"/>\"\n            \"</worksheet>\";\n\n    FILE* testfile = lxw_tmpfile(NULL);\n\n    lxw_worksheet *worksheet = lxw_worksheet_new(NULL);\n    worksheet->file = testfile;\n    worksheet_select(worksheet);\n\n    worksheet_write_number(worksheet, CELL(\"A1\"),   1, NULL);\n    worksheet_write_number(worksheet, CELL(\"A2\"),   2, NULL);\n    worksheet_write_number(worksheet, CELL(\"A3\"),   3, NULL);\n    worksheet_write_number(worksheet, CELL(\"A4\"),   4, NULL);\n    worksheet_write_number(worksheet, CELL(\"A5\"),   5, NULL);\n    worksheet_write_number(worksheet, CELL(\"A6\"),   6, NULL);\n    worksheet_write_number(worksheet, CELL(\"A7\"),   7, NULL);\n    worksheet_write_number(worksheet, CELL(\"A8\"),   8, NULL);\n    worksheet_write_number(worksheet, CELL(\"A9\"),   9, NULL);\n    worksheet_write_number(worksheet, CELL(\"A10\"), 10, NULL);\n    worksheet_write_number(worksheet, CELL(\"A11\"), 11, NULL);\n    worksheet_write_number(worksheet, CELL(\"A12\"), 12, NULL);\n\n    lxw_conditional_format *conditional_format = calloc(1, sizeof(lxw_conditional_format));\n\n    conditional_format->type          = LXW_CONDITIONAL_DATA_BAR;\n    conditional_format->min_value     = 5;\n    conditional_format->max_value     = 90;\n    conditional_format->min_rule_type = LXW_CONDITIONAL_RULE_TYPE_NUMBER;\n    conditional_format->max_rule_type = LXW_CONDITIONAL_RULE_TYPE_PERCENT;\n    conditional_format->bar_color     = 0x8DB4E3;\n\n    // Mid values should be ignored.\n    conditional_format->mid_value     = 52;\n    conditional_format->mid_rule_type = LXW_CONDITIONAL_RULE_TYPE_PERCENTILE;\n\n    worksheet_conditional_format_range(worksheet, RANGE(\"A1:A12\"), conditional_format);\n\n\n    free(conditional_format);\n\n    lxw_worksheet_assemble_xml_file(worksheet);\n\n    RUN_XLSX_STREQ_SHORT(exp, got);\n\n    lxw_worksheet_free(worksheet);\n}", "path": "libxlsxwriter/test/unit/worksheet/test_worksheet_conditional_format19.c", "commit_date": "2020-09-07 00:00:00", "repo_name": "jmcnamara/libxlsxwriter", "stars": 1347, "license": "other", "language": "c", "size": 24393}
{"docstring": "/*\n * Thin wrapper for tmpfile() so it can be over-ridden with a user defined\n * version if required for safety or portability.\n */\n", "func_signal": "FILE *\nlxw_tmpfile(char *tmpdir)", "code": "{\n#ifndef USE_STANDARD_TMPFILE\n    return tmpfileplus(tmpdir, NULL, NULL, 0);\n#else\n    (void) tmpdir;\n    return tmpfile();\n#endif\n}", "path": "libxlsxwriter/src/utility.c", "commit_date": "2020-09-07 00:00:00", "repo_name": "jmcnamara/libxlsxwriter", "stars": 1347, "license": "other", "language": "c", "size": 24393}
{"docstring": "/* Test the _write_defined_name() method. */\n", "func_signal": "CTEST(workbook, write_defined_name)", "code": "{\n    char* got;\n    char exp[] = \"<definedName name=\\\"_xlnm.Print_Titles\\\" localSheetId=\\\"0\\\">Sheet1!$1:$1</definedName>\";\n    FILE* testfile = lxw_tmpfile(NULL);\n    lxw_defined_name defined_name = {0, 0, \"_xlnm.Print_Titles\", \"\", \"Sheet1!$1:$1\", \"\", \"\", {NULL, NULL}};\n\n\n    lxw_workbook *workbook = workbook_new(NULL);\n    workbook->file = testfile;\n\n    _write_defined_name(workbook, &defined_name);\n\n    RUN_XLSX_STREQ(exp, got);\n\n    lxw_workbook_free(workbook);\n}", "path": "libxlsxwriter/test/unit/workbook/test_workbook_write_defined_name.c", "commit_date": "2020-09-07 00:00:00", "repo_name": "jmcnamara/libxlsxwriter", "stars": 1347, "license": "other", "language": "c", "size": 24393}
{"docstring": "/*\n * Convert zero indexed row and column pair to an Excel style A1:C5\n * range reference.\n */\n", "func_signal": "void\nlxw_rowcol_to_range(char *range,\n                    lxw_row_t first_row, lxw_col_t first_col,\n                    lxw_row_t last_row, lxw_col_t last_col)", "code": "{\n    size_t pos;\n\n    /* Add the first cell to the range. */\n    lxw_rowcol_to_cell(range, first_row, first_col);\n\n    /* If the start and end cells are the same just return a single cell. */\n    if (first_row == last_row && first_col == last_col)\n        return;\n\n    /* Get the end of the cell. */\n    pos = strlen(range);\n\n    /* Add the range separator. */\n    range[pos++] = ':';\n\n    /* Add the first cell to the range. */\n    lxw_rowcol_to_cell(&range[pos], last_row, last_col);\n}", "path": "libxlsxwriter/src/utility.c", "commit_date": "2020-09-07 00:00:00", "repo_name": "jmcnamara/libxlsxwriter", "stars": 1347, "license": "other", "language": "c", "size": 24393}
{"docstring": "// Test _datetime_to_excel_date().\n", "func_signal": "CTEST(utility, _datetime_date_and_time)", "code": "{\n\n    double got;\n    lxw_datetime *datetime;\n\n    TEST_DATETIME(1899, 12, 31,  0,  0,  0.000, 0);\n    TEST_DATETIME(1982,  8, 25,  0, 15, 20.213, 30188.010650613425);\n    TEST_DATETIME(2065,  4, 19,  0, 16, 48.290, 60376.011670023145);\n    TEST_DATETIME(2147, 12, 15,  0, 55, 25.446, 90565.038488958337);\n    TEST_DATETIME(2230,  8, 10,  1,  2, 46.891, 120753.04359827546);\n    TEST_DATETIME(2313,  4,  6,  1,  4, 15.597, 150942.04462496529);\n    TEST_DATETIME(2395, 11, 30,  1,  9, 40.889, 181130.04838991899);\n    TEST_DATETIME(2478,  7, 25,  1, 11, 32.560, 211318.04968240741);\n    TEST_DATETIME(2561,  3, 21,  1, 30, 19.169, 241507.06272186342);\n    TEST_DATETIME(2643, 11, 15,  1, 48, 25.580, 271695.07529606484);\n    TEST_DATETIME(2726,  7, 12,  2,  3, 31.919, 301884.08578609955);\n    TEST_DATETIME(2809,  3,  6,  2, 11, 11.986, 332072.09111094906);\n    TEST_DATETIME(2891, 10, 31,  2, 24, 37.095, 362261.10042934027);\n    TEST_DATETIME(2974,  6, 26,  2, 35,  7.220, 392449.10772245371);\n    TEST_DATETIME(3057,  2, 19,  2, 45, 12.109, 422637.1147234838);\n    TEST_DATETIME(3139, 10, 17,  3,  6, 39.990, 452826.12962951389);\n    TEST_DATETIME(3222,  6, 11,  3,  8,  8.251, 483014.13065105322);\n    TEST_DATETIME(3305,  2,  5,  3, 19, 12.576, 513203.13834);\n    TEST_DATETIME(3387, 10,  1,  3, 29, 42.574, 543391.14563164348);\n    TEST_DATETIME(3470,  5, 27,  3, 37, 30.813, 573579.15105107636);\n    TEST_DATETIME(3553,  1, 21,  4, 14, 38.231, 603768.17683137732);\n    TEST_DATETIME(3635,  9, 16,  4, 16, 28.559, 633956.17810832174);\n    TEST_DATETIME(3718,  5, 13,  4, 17, 58.222, 664145.17914608796);\n    TEST_DATETIME(3801,  1,  6,  4, 21, 41.794, 694333.18173372687);\n    TEST_DATETIME(3883,  9,  2,  4, 56, 35.792, 724522.20596981479);\n    TEST_DATETIME(3966,  4, 28,  5, 25, 14.885, 754710.2258667245);\n    TEST_DATETIME(4048, 12, 21,  5, 26,  5.724, 784898.22645513888);\n    TEST_DATETIME(4131,  8, 18,  5, 46, 44.068, 815087.24078782403);\n    TEST_DATETIME(4214,  4, 13,  5, 48,  1.141, 845275.24167987274);\n    TEST_DATETIME(4296, 12,  7,  5, 53, 52.315, 875464.24574438657);\n    TEST_DATETIME(4379,  8,  3,  6, 14, 48.580, 905652.26028449077);\n    TEST_DATETIME(4462,  3, 28,  6, 46, 15.738, 935840.28212659725);\n    TEST_DATETIME(4544, 11, 22,  7, 31, 20.407, 966029.31343063654);\n    TEST_DATETIME(4627,  7, 19,  7, 58, 33.754, 996217.33233511576);\n    TEST_DATETIME(4710,  3, 15,  8,  7, 43.130, 1026406.3386936343);\n    TEST_DATETIME(4792, 11,  7,  8, 29, 11.091, 1056594.3536005903);\n    TEST_DATETIME(4875,  7,  4,  9,  8, 15.328, 1086783.3807329629);\n    TEST_DATETIME(4958,  2, 27,  9, 30, 41.781, 1116971.3963169097);\n    TEST_DATETIME(5040, 10, 23,  9, 34,  4.462, 1147159.3986627546);\n    TEST_DATETIME(5123,  6, 20,  9, 37, 23.945, 1177348.4009715857);\n    TEST_DATETIME(5206,  2, 12,  9, 37, 56.655, 1207536.4013501736);\n    TEST_DATETIME(5288, 10,  8,  9, 45, 12.230, 1237725.406391551);\n    TEST_DATETIME(5371,  6,  4,  9, 54, 14.782, 1267913.412671088);\n    TEST_DATETIME(5454,  1, 28,  9, 54, 22.108, 1298101.4127558796);\n    TEST_DATETIME(5536,  9, 24, 10,  1, 36.151, 1328290.4177795255);\n    TEST_DATETIME(5619,  5, 20, 12,  9, 48.602, 1358478.5068125231);\n    TEST_DATETIME(5702,  1, 14, 12, 34,  8.549, 1388667.5237100578);\n    TEST_DATETIME(5784,  9,  8, 12, 56,  6.495, 1418855.5389640625);\n    TEST_DATETIME(5867,  5,  6, 12, 58, 58.217, 1449044.5409515856);\n    TEST_DATETIME(5949, 12, 30, 12, 59, 54.263, 1479232.5416002662);\n    TEST_DATETIME(6032,  8, 24, 13, 34, 41.331, 1509420.5657561459);\n    TEST_DATETIME(6115,  4, 21, 13, 58, 28.601, 1539609.5822754744);\n    TEST_DATETIME(6197, 12, 14, 14,  2, 16.899, 1569797.5849178126);\n    TEST_DATETIME(6280,  8, 10, 14, 36, 17.444, 1599986.6085352316);\n    TEST_DATETIME(6363,  4,  6, 14, 37, 57.451, 1630174.60969272);\n    TEST_DATETIME(6445, 11, 30, 14, 57, 42.757, 1660363.6234115392);\n    TEST_DATETIME(6528,  7, 26, 15, 10, 48.307, 1690551.6325035533);\n    TEST_DATETIME(6611,  3, 22, 15, 14, 39.890, 1720739.635183912);\n    TEST_DATETIME(6693, 11, 15, 15, 19, 47.988, 1750928.6387498612);\n    TEST_DATETIME(6776,  7, 11, 16,  4, 24.344, 1781116.6697262037);\n    TEST_DATETIME(6859,  3,  7, 16, 22, 23.952, 1811305.6822216667);\n    TEST_DATETIME(6941, 10, 31, 16, 29, 55.999, 1841493.6874536921);\n    TEST_DATETIME(7024,  6, 26, 16, 58, 20.259, 1871681.7071789235);\n    TEST_DATETIME(7107,  2, 21, 17,  4,  2.415, 1901870.7111390624);\n    TEST_DATETIME(7189, 10, 16, 17, 18, 29.630, 1932058.7211762732);\n    TEST_DATETIME(7272,  6, 11, 17, 47, 21.323, 1962247.7412190163);\n    TEST_DATETIME(7355,  2,  5, 17, 53, 29.866, 1992435.7454845603);\n    TEST_DATETIME(7437, 10,  2, 17, 53, 41.076, 2022624.7456143056);\n    TEST_DATETIME(7520,  5, 28, 17, 55,  6.044, 2052812.7465977315);\n    TEST_DATETIME(7603,  1, 21, 18, 14, 49.151, 2083000.7602910995);\n    TEST_DATETIME(7685,  9, 16, 18, 17, 45.738, 2113189.7623349307);\n    TEST_DATETIME(7768,  5, 12, 18, 29, 59.700, 2143377.7708298611);\n    TEST_DATETIME(7851,  1,  7, 18, 33, 21.233, 2173566.773162419);\n    TEST_DATETIME(7933,  9,  2, 19, 14, 24.673, 2203754.8016744559);\n    TEST_DATETIME(8016,  4, 27, 19, 17, 12.816, 2233942.8036205554);\n    TEST_DATETIME(8098, 12, 22, 19, 23, 36.418, 2264131.8080603937);\n    TEST_DATETIME(8181,  8, 17, 19, 46, 25.908, 2294319.8239109721);\n    TEST_DATETIME(8264,  4, 13, 20,  7, 47.314, 2324508.8387420601);\n    TEST_DATETIME(8346, 12,  8, 20, 31, 37.603, 2354696.855296331);\n    TEST_DATETIME(8429,  8,  3, 20, 39, 57.770, 2384885.8610853008);\n    TEST_DATETIME(8512,  3, 29, 20, 50, 17.067, 2415073.8682530904);\n    TEST_DATETIME(8594, 11, 22, 21,  2, 57.827, 2445261.8770581828);\n    TEST_DATETIME(8677,  7, 19, 21, 23,  5.519, 2475450.8910360998);\n    TEST_DATETIME(8760,  3, 14, 21, 34, 49.572, 2505638.8991848612);\n    TEST_DATETIME(8842, 11,  8, 21, 39,  5.944, 2535827.9021521294);\n    TEST_DATETIME(8925,  7,  4, 21, 39, 18.426, 2566015.9022965971);\n    TEST_DATETIME(9008,  2, 28, 21, 46,  7.769, 2596203.9070343636);\n    TEST_DATETIME(9090, 10, 24, 21, 57, 55.662, 2626392.9152275696);\n    TEST_DATETIME(9173,  6, 19, 22, 19, 11.732, 2656580.9299968979);\n    TEST_DATETIME(9256,  2, 13, 22, 23, 51.376, 2686769.9332335186);\n    TEST_DATETIME(9338, 10,  9, 22, 27, 58.771, 2716957.9360968866);\n    TEST_DATETIME(9421,  6,  5, 22, 43, 30.392, 2747146.9468795368);\n    TEST_DATETIME(9504,  1, 30, 22, 48, 25.834, 2777334.9502990046);\n    TEST_DATETIME(9586,  9, 24, 22, 53, 51.727, 2807522.9540709145);\n    TEST_DATETIME(9669,  5, 20, 23, 12, 56.536, 2837711.9673210187);\n    TEST_DATETIME(9752,  1, 14, 23, 15, 54.109, 2867899.9693762613);\n    TEST_DATETIME(9834,  9, 10, 23, 17, 12.632, 2898088.9702850925);\n    TEST_DATETIME(9999, 12, 31, 23, 59, 59.000, 2958465.999988426);\n}", "path": "libxlsxwriter/test/unit/utility/test_datetime_to_excel.c", "commit_date": "2020-09-07 00:00:00", "repo_name": "jmcnamara/libxlsxwriter", "stars": 1347, "license": "other", "language": "c", "size": 24393}
{"docstring": "/*\n * Convert an Excel style A1 cell reference to a zero indexed row number.\n */\n", "func_signal": "lxw_row_t\nlxw_name_to_row(const char *row_str)", "code": "{\n    lxw_row_t row_num = 0;\n    const char *p = row_str;\n\n    /* Skip the column letters and absolute symbol of the A1 cell. */\n    while (p && !isdigit((unsigned char) *p))\n        p++;\n\n    /* Convert the row part of the A1 cell to a number. */\n    if (p)\n        row_num = atoi(p);\n\n    if (row_num)\n        return row_num - 1;\n    else\n        return 0;\n}", "path": "libxlsxwriter/src/utility.c", "commit_date": "2020-09-07 00:00:00", "repo_name": "jmcnamara/libxlsxwriter", "stars": 1347, "license": "other", "language": "c", "size": 24393}
{"docstring": "/* Simple tolower() for strings. */\n", "func_signal": "void\nlxw_str_tolower(char *str)", "code": "{\n    int i;\n\n    for (i = 0; str[i]; i++)\n        str[i] = tolower(str[i]);\n}", "path": "libxlsxwriter/src/utility.c", "commit_date": "2020-09-07 00:00:00", "repo_name": "jmcnamara/libxlsxwriter", "stars": 1347, "license": "other", "language": "c", "size": 24393}
{"docstring": "/*\n * Hash a worksheet password. Based on the algorithm provided by Daniel Rentz\n * of OpenOffice.\n */\n", "func_signal": "uint16_t\nlxw_hash_password(const char *password)", "code": "{\n    size_t count;\n    size_t i;\n    uint16_t hash = 0x0000;\n\n    count = strlen(password);\n\n    for (i = 0; i < (uint8_t) count; i++) {\n        uint32_t low_15;\n        uint32_t high_15;\n        uint32_t letter = password[i] << (i + 1);\n\n        low_15 = letter & 0x7fff;\n        high_15 = letter & (0x7fff << 15);\n        high_15 = high_15 >> 15;\n        letter = low_15 | high_15;\n\n        hash ^= letter;\n    }\n\n    hash ^= count;\n    hash ^= 0xCE4B;\n\n    return hash;\n}", "path": "libxlsxwriter/src/utility.c", "commit_date": "2020-09-07 00:00:00", "repo_name": "jmcnamara/libxlsxwriter", "stars": 1347, "license": "other", "language": "c", "size": 24393}
{"docstring": "/* Create a quoted version of the worksheet name, or return an unmodified\n * copy if it doesn't required quoting. */\n", "func_signal": "char *\nlxw_quote_sheetname(const char *str)", "code": "{\n\n    uint8_t needs_quoting = 0;\n    size_t number_of_quotes = 2;\n    size_t i, j;\n    size_t len = strlen(str);\n\n    /* Don't quote the sheetname if it is already quoted. */\n    if (str[0] == '\\'')\n        return lxw_strdup(str);\n\n    /* Check if the sheetname contains any characters that require it\n     * to be quoted. Also check for single quotes within the string. */\n    for (i = 0; i < len; i++) {\n        if (!isalnum((unsigned char) str[i]) && str[i] != '_'\n            && str[i] != '.')\n            needs_quoting = 1;\n\n        if (str[i] == '\\'') {\n            needs_quoting = 1;\n            number_of_quotes++;\n        }\n    }\n\n    if (!needs_quoting) {\n        return lxw_strdup(str);\n    }\n    else {\n        /* Add single quotes to the start and end of the string. */\n        char *quoted_name = calloc(1, len + number_of_quotes + 1);\n        RETURN_ON_MEM_ERROR(quoted_name, NULL);\n\n        quoted_name[0] = '\\'';\n\n        for (i = 0, j = 1; i < len; i++, j++) {\n            quoted_name[j] = str[i];\n\n            /* Double quote inline single quotes. */\n            if (str[i] == '\\'') {\n                quoted_name[++j] = '\\'';\n            }\n        }\n        quoted_name[j++] = '\\'';\n        quoted_name[j++] = '\\0';\n\n        return quoted_name;\n    }\n}", "path": "libxlsxwriter/src/utility.c", "commit_date": "2020-09-07 00:00:00", "repo_name": "jmcnamara/libxlsxwriter", "stars": 1347, "license": "other", "language": "c", "size": 24393}
{"docstring": "/* Simple function to strdup() a formula string without the leading \"=\". */\n", "func_signal": "char *\nlxw_strdup_formula(const char *formula)", "code": "{\n    if (!formula)\n        return NULL;\n\n    if (formula[0] == '=')\n        return lxw_strdup(formula + 1);\n    else\n        return lxw_strdup(formula);\n}", "path": "libxlsxwriter/src/utility.c", "commit_date": "2020-09-07 00:00:00", "repo_name": "jmcnamara/libxlsxwriter", "stars": 1347, "license": "other", "language": "c", "size": 24393}
{"docstring": "/*\n * Create a worksheet with examples charts.\n */\n", "func_signal": "int main()", "code": "{\n\n    lxw_workbook     *workbook  = workbook_new(\"chart_bar.xlsx\");\n    lxw_worksheet    *worksheet = workbook_add_worksheet(workbook, NULL);\n    lxw_chart_series *series;\n\n    /* Add a bold format to use to highlight the header cells. */\n    lxw_format *bold = workbook_add_format(workbook);\n    format_set_bold(bold);\n\n    /* Write some data for the chart. */\n    write_worksheet_data(worksheet, bold);\n\n\n    /*\n     * Chart 1. Create a bar chart.\n     */\n    lxw_chart *chart = workbook_add_chart(workbook, LXW_CHART_BAR);\n\n    /* Add the first series to the chart. */\n    series = chart_add_series(chart, \"=Sheet1!$A$2:$A$7\", \"=Sheet1!$B$2:$B$7\");\n\n    /* Set the name for the series instead of the default \"Series 1\". */\n    chart_series_set_name(series, \"=Sheet1!$B$1\");\n\n    /* Add a second series but leave the categories and values undefined. They\n     * can be defined later using the alternative syntax shown below.  */\n    series = chart_add_series(chart, NULL, NULL);\n\n    /* Configure the series using a syntax that is easier to define programmatically. */\n    chart_series_set_categories(series, \"Sheet1\", 1, 0, 6, 0); /* \"=Sheet1!$A$2:$A$7\" */\n    chart_series_set_values(series,     \"Sheet1\", 1, 2, 6, 2); /* \"=Sheet1!$C$2:$C$7\" */\n    chart_series_set_name_range(series, \"Sheet1\", 0, 2);       /* \"=Sheet1!$C$1\"      */\n\n    /* Add a chart title and some axis labels. */\n    chart_title_set_name(chart,        \"Results of sample analysis\");\n    chart_axis_set_name(chart->x_axis, \"Test number\");\n    chart_axis_set_name(chart->y_axis, \"Sample length (mm)\");\n\n    /* Set an Excel chart style. */\n    chart_set_style(chart, 11);\n\n    /* Insert the chart into the worksheet. */\n    worksheet_insert_chart(worksheet, CELL(\"E2\"), chart);\n\n\n    /*\n     * Chart 2. Create a stacked bar chart.\n     */\n    chart = workbook_add_chart(workbook, LXW_CHART_BAR_STACKED);\n\n    /* Add the first series to the chart. */\n    series = chart_add_series(chart, \"=Sheet1!$A$2:$A$7\", \"=Sheet1!$B$2:$B$7\");\n\n    /* Set the name for the series instead of the default \"Series 1\". */\n    chart_series_set_name(series, \"=Sheet1!$B$1\");\n\n    /* Add the second series to the chart. */\n    series = chart_add_series(chart, \"=Sheet1!$A$2:$A$7\", \"=Sheet1!$C$2:$C$7\");\n\n    /* Set the name for the series instead of the default \"Series 2\". */\n    chart_series_set_name(series, \"=Sheet1!$C$1\");\n\n    /* Add a chart title and some axis labels. */\n    chart_title_set_name(chart,        \"Results of sample analysis\");\n    chart_axis_set_name(chart->x_axis, \"Test number\");\n    chart_axis_set_name(chart->y_axis, \"Sample length (mm)\");\n\n    /* Set an Excel chart style. */\n    chart_set_style(chart, 12);\n\n    /* Insert the chart into the worksheet. */\n    worksheet_insert_chart(worksheet, CELL(\"E18\"), chart);\n\n\n    /*\n     * Chart 3. Create a percent stacked bar chart.\n     */\n    chart = workbook_add_chart(workbook, LXW_CHART_BAR_STACKED_PERCENT);\n\n    /* Add the first series to the chart. */\n    series = chart_add_series(chart, \"=Sheet1!$A$2:$A$7\", \"=Sheet1!$B$2:$B$7\");\n\n    /* Set the name for the series instead of the default \"Series 1\". */\n    chart_series_set_name(series, \"=Sheet1!$B$1\");\n\n    /* Add the second series to the chart. */\n    series = chart_add_series(chart, \"=Sheet1!$A$2:$A$7\", \"=Sheet1!$C$2:$C$7\");\n\n    /* Set the name for the series instead of the default \"Series 2\". */\n    chart_series_set_name(series, \"=Sheet1!$C$1\");\n\n    /* Add a chart title and some axis labels. */\n    chart_title_set_name(chart,        \"Results of sample analysis\");\n    chart_axis_set_name(chart->x_axis, \"Test number\");\n    chart_axis_set_name(chart->y_axis, \"Sample length (mm)\");\n\n    /* Set an Excel chart style. */\n    chart_set_style(chart, 13);\n\n    /* Insert the chart into the worksheet. */\n    worksheet_insert_chart(worksheet, CELL(\"E34\"), chart);\n\n\n    return workbook_close(workbook);\n}", "path": "libxlsxwriter/examples/chart_bar.c", "commit_date": "2019-11-16 00:00:00", "repo_name": "jmcnamara/libxlsxwriter", "stars": 1347, "license": "other", "language": "c", "size": 24393}
{"docstring": "/* Simple strlen that counts UTF-8 characters. Assumes well formed UTF-8. */\n", "func_signal": "size_t\nlxw_utf8_strlen(const char *str)", "code": "{\n    size_t byte_count = 0;\n    size_t char_count = 0;\n\n    while (str[byte_count]) {\n        if ((str[byte_count] & 0xc0) != 0x80)\n            char_count++;\n\n        byte_count++;\n    }\n\n    return char_count;\n}", "path": "libxlsxwriter/src/utility.c", "commit_date": "2020-09-07 00:00:00", "repo_name": "jmcnamara/libxlsxwriter", "stars": 1347, "license": "other", "language": "c", "size": 24393}
{"docstring": "/*\n * Write some data to the worksheet.\n */\n", "func_signal": "void write_worksheet_data(lxw_worksheet *worksheet, lxw_format *bold)", "code": "{\n\n    int row, col;\n    uint8_t data[6][3] = {\n        /* Three columns of data. */\n        {2, 10, 30},\n        {3, 40, 60},\n        {4, 50, 70},\n        {5, 20, 50},\n        {6, 10, 40},\n        {7, 50, 30}\n    };\n\n    worksheet_write_string(worksheet, CELL(\"A1\"), \"Number\",  bold);\n    worksheet_write_string(worksheet, CELL(\"B1\"), \"Batch 1\", bold);\n    worksheet_write_string(worksheet, CELL(\"C1\"), \"Batch 2\", bold);\n\n    for (row = 0; row < 6; row++)\n        for (col = 0; col < 3; col++)\n            worksheet_write_number(worksheet, row + 1, col, data[row][col] , NULL);\n}", "path": "libxlsxwriter/examples/chart_bar.c", "commit_date": "2019-11-16 00:00:00", "repo_name": "jmcnamara/libxlsxwriter", "stars": 1347, "license": "other", "language": "c", "size": 24393}
{"docstring": "/*\n * Convert the second row of an Excel range ref to a zero indexed number.\n */\n", "func_signal": "uint32_t\nlxw_name_to_row_2(const char *row_str)", "code": "{\n    const char *p = row_str;\n\n    /* Find the : separator in the range. */\n    while (p && *p != ':')\n        p++;\n\n    if (p)\n        return lxw_name_to_row(++p);\n    else\n        return -1;\n}", "path": "libxlsxwriter/src/utility.c", "commit_date": "2020-09-07 00:00:00", "repo_name": "jmcnamara/libxlsxwriter", "stars": 1347, "license": "other", "language": "c", "size": 24393}
{"docstring": "/*\n * Convert a lxw_datetime struct to an Excel serial date, with a 1900\n * or 1904 epoch.\n */\n", "func_signal": "double\nlxw_datetime_to_excel_date_epoch(lxw_datetime *datetime, uint8_t date_1904)", "code": "{\n    int year = datetime->year;\n    int month = datetime->month;\n    int day = datetime->day;\n    int hour = datetime->hour;\n    int min = datetime->min;\n    double sec = datetime->sec;\n    double seconds;\n    int epoch = date_1904 ? 1904 : 1900;\n    int offset = date_1904 ? 4 : 0;\n    int norm = 300;\n    int range;\n    /* Set month days and check for leap year. */\n    int mdays[] = { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\n    int leap = 0;\n    int days = 0;\n    int i;\n\n    /* For times without dates set the default date for the epoch. */\n    if (!year) {\n        if (!date_1904) {\n            year = 1899;\n            month = 12;\n            day = 31;\n        }\n        else {\n            year = 1904;\n            month = 1;\n            day = 1;\n        }\n    }\n\n    /* Convert the Excel seconds to a fraction of the seconds in 24 hours. */\n    seconds = (hour * 60 * 60 + min * 60 + sec) / (24 * 60 * 60.0);\n\n    /* Special cases for Excel dates in the 1900 epoch. */\n    if (!date_1904) {\n        /* Excel 1900 epoch. */\n        if (year == 1899 && month == 12 && day == 31)\n            return seconds;\n\n        /* Excel 1900 epoch. */\n        if (year == 1900 && month == 1 && day == 0)\n            return seconds;\n\n        /* Excel false leapday */\n        if (year == 1900 && month == 2 && day == 29)\n            return 60 + seconds;\n    }\n\n    /* We calculate the date by calculating the number of days since the */\n    /* epoch and adjust for the number of leap days. We calculate the */\n    /* number of leap days by normalizing the year in relation to the */\n    /* epoch. Thus the year 2000 becomes 100 for 4-year and 100-year */\n    /* leapdays and 400 for 400-year leapdays. */\n    range = year - epoch;\n\n    if (year % 4 == 0 && (year % 100 > 0 || year % 400 == 0)) {\n        leap = 1;\n        mdays[2] = 29;\n    }\n\n    /*\n     * Calculate the serial date by accumulating the number of days\n     * since the epoch.\n     */\n\n    /* Add days for previous months. */\n    for (i = 0; i < month; i++) {\n        days += mdays[i];\n    }\n    /* Add days for current month. */\n    days += day;\n    /* Add days for all previous years.  */\n    days += range * 365;\n    /* Add 4 year leapdays. */\n    days += (range) / 4;\n    /* Remove 100 year leapdays. */\n    days -= (range + offset) / 100;\n    /* Add 400 year leapdays. */\n    days += (range + offset + norm) / 400;\n    /* Remove leap days already counted. */\n    days -= leap;\n\n    /* Adjust for Excel erroneously treating 1900 as a leap year. */\n    if (!date_1904 && days > 59)\n        days++;\n\n    return days + seconds;\n}", "path": "libxlsxwriter/src/utility.c", "commit_date": "2020-09-07 00:00:00", "repo_name": "jmcnamara/libxlsxwriter", "stars": 1347, "license": "other", "language": "c", "size": 24393}
{"docstring": "/*\n * Convert zero indexed row and column pairs to an Excel style $A$1:$C$5\n * range reference with absolute values.\n */\n", "func_signal": "void\nlxw_rowcol_to_range_abs(char *range,\n                        lxw_row_t first_row, lxw_col_t first_col,\n                        lxw_row_t last_row, lxw_col_t last_col)", "code": "{\n    size_t pos;\n\n    /* Add the first cell to the range. */\n    lxw_rowcol_to_cell_abs(range, first_row, first_col, 1, 1);\n\n    /* If the start and end cells are the same just return a single cell. */\n    if (first_row == last_row && first_col == last_col)\n        return;\n\n    /* Get the end of the cell. */\n    pos = strlen(range);\n\n    /* Add the range separator. */\n    range[pos++] = ':';\n\n    /* Add the first cell to the range. */\n    lxw_rowcol_to_cell_abs(&range[pos], last_row, last_col, 1, 1);\n}", "path": "libxlsxwriter/src/utility.c", "commit_date": "2020-09-07 00:00:00", "repo_name": "jmcnamara/libxlsxwriter", "stars": 1347, "license": "other", "language": "c", "size": 24393}
{"docstring": "/*\n * Convert zero indexed row and column to an Excel style A1 cell reference.\n */\n", "func_signal": "void\nlxw_rowcol_to_cell(char *cell_name, lxw_row_t row, lxw_col_t col)", "code": "{\n    size_t pos;\n\n    /* Add the column to the cell. */\n    lxw_col_to_name(cell_name, col, 0);\n\n    /* Get the end of the cell. */\n    pos = strlen(cell_name);\n\n    /* Add the row to the cell. */\n    lxw_snprintf(&cell_name[pos], LXW_MAX_ROW_NAME_LENGTH, \"%d\", ++row);\n}", "path": "libxlsxwriter/src/utility.c", "commit_date": "2020-09-07 00:00:00", "repo_name": "jmcnamara/libxlsxwriter", "stars": 1347, "license": "other", "language": "c", "size": 24393}
{"docstring": "/*! \\brief Queue a SLA event from the conference */\n", "func_signal": "static void sla_queue_event_conf(enum sla_event_type type, struct ast_channel *chan,\n\tstruct ast_conference *conf)", "code": "{\n\tstruct sla_station *station;\n\tstruct sla_trunk_ref *trunk_ref = NULL;\n\tchar *trunk_name;\n\tstruct ao2_iterator i;\n\n\ttrunk_name = ast_strdupa(conf->confno);\n\tstrsep(&trunk_name, \"_\");\n\tif (ast_strlen_zero(trunk_name)) {\n\t\tast_log(LOG_ERROR, \"Invalid conference name for SLA - '%s'!\\n\", conf->confno);\n\t\treturn;\n\t}\n\n\ti = ao2_iterator_init(sla_stations, 0);\n\twhile ((station = ao2_iterator_next(&i))) {\n\t\tao2_lock(station);\n\t\tAST_LIST_TRAVERSE(&station->trunks, trunk_ref, entry) {\n\t\t\tif (trunk_ref->chan == chan && !strcmp(trunk_ref->trunk->name, trunk_name)) {\n\t\t\t\tao2_ref(trunk_ref, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tao2_unlock(station);\n\t\tif (trunk_ref) {\n\t\t\t/* station reference given to sla_queue_event_full() */\n\t\t\tbreak;\n\t\t}\n\t\tao2_ref(station, -1);\n\t}\n\tao2_iterator_destroy(&i);\n\n\tif (!trunk_ref) {\n\t\tast_debug(1, \"Trunk not found for event!\\n\");\n\t\treturn;\n\t}\n\n\tsla_queue_event_full(type, trunk_ref, station, 1);\n}", "path": "asterisk/apps/app_meetme.c", "commit_date": "2019-11-07 00:00:00", "repo_name": "asterisk/asterisk", "stars": 1835, "license": "other", "language": "c", "size": 367375}
{"docstring": "/*! \\internal\n * \\brief Processes menu options for the standard menu (accessible through the 's' option for app_meetme)\n *\n * \\param menu_mode a pointer to the currently active menu_mode.\n * \\param dtmf a pointer to the dtmf value currently being processed against the menu.\n * \\param conf the active conference for which the user has called the menu from.\n * \\param confflags flags used by conf for various options\n * \\param chan ast_channel belonging to the user who called the menu\n * \\param user which meetme conference user invoked the menu\n */\n", "func_signal": "static void meetme_menu_normal(enum menu_modes *menu_mode, int *dtmf, struct ast_conference *conf, struct ast_flags64 *confflags, struct ast_channel *chan, struct ast_conf_user *user)", "code": "{\n\tswitch (*dtmf) {\n\tcase '1': /* Un/Mute */\n\t\t*menu_mode = MENU_DISABLED;\n\n\t\t/* user can only toggle the self-muted state */\n\t\tuser->adminflags ^= ADMINFLAG_SELFMUTED;\n\n\t\t/* they can't override the admin mute state */\n\t\tif (ast_test_flag64(confflags, CONFFLAG_MONITOR) || (user->adminflags & (ADMINFLAG_MUTED | ADMINFLAG_SELFMUTED))) {\n\t\t\tif (!ast_streamfile(chan, \"conf-muted\", ast_channel_language(chan))) {\n\t\t\t\tast_waitstream(chan, \"\");\n\t\t\t}\n\t\t} else {\n\t\t\tif (!ast_streamfile(chan, \"conf-unmuted\", ast_channel_language(chan))) {\n\t\t\t\tast_waitstream(chan, \"\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase '2':\n\t\t*menu_mode = MENU_DISABLED;\n\t\tif (user->adminflags & (ADMINFLAG_MUTED | ADMINFLAG_SELFMUTED)) {\n\t\t\tuser->adminflags |= ADMINFLAG_T_REQUEST;\n\t\t}\n\n\t\tif (user->adminflags & ADMINFLAG_T_REQUEST) {\n\t\t\tif (!ast_streamfile(chan, \"beep\", ast_channel_language(chan))) {\n\t\t\t\tast_waitstream(chan, \"\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase '4':\n\t\ttweak_listen_volume(user, VOL_DOWN);\n\t\tbreak;\n\tcase '5':\n\t\t/* Extend RT conference */\n\t\tif (rt_schedule) {\n\t\t\trt_extend_conf(conf->confno);\n\t\t}\n\t\t*menu_mode = MENU_DISABLED;\n\t\tbreak;\n\n\tcase '6':\n\t\ttweak_listen_volume(user, VOL_UP);\n\t\tbreak;\n\n\tcase '7':\n\t\ttweak_talk_volume(user, VOL_DOWN);\n\t\tbreak;\n\n\tcase '8':\n\t\t*menu_mode = MENU_DISABLED;\n\t\tbreak;\n\n\tcase '9':\n\t\ttweak_talk_volume(user, VOL_UP);\n\t\tbreak;\n\n\tdefault:\n\t\t*menu_mode = MENU_DISABLED;\n\t\tif (!ast_streamfile(chan, \"conf-errormenu\", ast_channel_language(chan))) {\n\t\t\tast_waitstream(chan, \"\");\n\t\t}\n\t\tbreak;\n\t}\n}", "path": "asterisk/apps/app_meetme.c", "commit_date": "2019-11-07 00:00:00", "repo_name": "asterisk/asterisk", "stars": 1835, "license": "other", "language": "c", "size": 367375}
{"docstring": "/*! \\brief Internal helper function which retrieves an object, or multiple objects, using fields for criteria */\n", "func_signal": "static void *sorcery_astdb_retrieve_fields_common(const struct ast_sorcery *sorcery, void *data, const char *type, const struct ast_variable *fields, struct ao2_container *objects)", "code": "{\n\tconst char *prefix = data;\n\tchar family[strlen(prefix) + strlen(type) + 2];\n\tRAII_VAR(struct ast_db_entry *, entries, NULL, ast_db_freetree);\n\tstruct ast_db_entry *entry;\n\n\tsnprintf(family, sizeof(family), \"%s/%s\", prefix, type);\n\n\tif (!(entries = ast_db_gettree(family, NULL))) {\n\t\treturn NULL;\n\t}\n\n\tfor (entry = entries; entry; entry = entry->next) {\n\t\tconst char *key = entry->key + strlen(family) + 2;\n\t\tRAII_VAR(struct ast_json *, json, NULL, ast_json_unref);\n\t\tstruct ast_json_error error;\n\t\tRAII_VAR(struct ast_variable *, existing, NULL, ast_variables_destroy);\n\t\tvoid *object = NULL;\n\n\t\tif (!(json = ast_json_load_string(entry->data, &error))) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (ast_json_to_ast_variables(json, &existing) != AST_JSON_TO_AST_VARS_CODE_SUCCESS) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\texisting = sorcery_astdb_filter_objectset(existing, sorcery, type);\n\n\t\tif (fields && !ast_variable_lists_match(existing, fields, 0)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!(object = ast_sorcery_alloc(sorcery, type, key)) ||\n\t\t\tast_sorcery_objectset_apply(sorcery, object, existing)) {\n\t\t\tao2_cleanup(object);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (!objects) {\n\t\t\treturn object;\n\t\t}\n\n\t\tao2_link(objects, object);\n\t\tao2_cleanup(object);\n\t}\n\n\treturn NULL;\n}", "path": "asterisk/res/res_sorcery_astdb.c", "commit_date": "2017-12-10 00:00:00", "repo_name": "asterisk/asterisk", "stars": 1835, "license": "other", "language": "c", "size": 367375}
{"docstring": "/*! \\brief Check to see if dialing this station already timed out for this ringing trunk\n * \\note Assumes sla.lock is locked\n */\n", "func_signal": "static int sla_check_timed_out_station(const struct sla_ringing_trunk *ringing_trunk,\n\tconst struct sla_station *station)", "code": "{\n\tstruct sla_station_ref *timed_out_station;\n\n\tAST_LIST_TRAVERSE(&ringing_trunk->timed_out_stations, timed_out_station, entry) {\n\t\tif (station == timed_out_station->station)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}", "path": "asterisk/apps/app_meetme.c", "commit_date": "2019-11-07 00:00:00", "repo_name": "asterisk/asterisk", "stars": 1835, "license": "other", "language": "c", "size": 367375}
{"docstring": "/*!\n * \\internal\n * \\brief Find an SLA trunk by name\n */\n", "func_signal": "static struct sla_trunk *sla_find_trunk(const char *name)", "code": "{\n\tstruct sla_trunk tmp_trunk = {\n\t\t.name = name,\n\t};\n\n\treturn ao2_find(sla_trunks, &tmp_trunk, OBJ_POINTER);\n}", "path": "asterisk/apps/app_meetme.c", "commit_date": "2019-11-07 00:00:00", "repo_name": "asterisk/asterisk", "stars": 1835, "license": "other", "language": "c", "size": 367375}
{"docstring": "/*!\n * \\brief Find or create a conference\n *\n * \\param confno The conference name/number\n * \\param pin The regular user pin\n * \\param pinadmin The admin pin\n * \\param make Make the conf if it doesn't exist\n * \\param dynamic Mark the newly created conference as dynamic\n * \\param refcount How many references to mark on the conference\n * \\param chan The asterisk channel\n * \\param test\n *\n * \\return A pointer to the conference struct, or NULL if it wasn't found and\n *         make or dynamic were not set.\n */\n", "func_signal": "static struct ast_conference *build_conf(const char *confno, const char *pin,\n\tconst char *pinadmin, int make, int dynamic, int refcount,\n\tconst struct ast_channel *chan, struct ast_test *test)", "code": "{\n\tstruct ast_conference *cnf;\n\tstruct dahdi_confinfo dahdic = { 0, };\n\tint confno_int = 0;\n\tstruct ast_format_cap *cap_slin = ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT);\n\n\tAST_LIST_LOCK(&confs);\n\n\tAST_LIST_TRAVERSE(&confs, cnf, list) {\n\t\tif (!strcmp(confno, cnf->confno))\n\t\t\tbreak;\n\t}\n\n\tif (cnf || (!make && !dynamic) || !cap_slin)\n\t\tgoto cnfout;\n\n\tast_format_cap_append(cap_slin, ast_format_slin, 0);\n\t/* Make a new one */\n\tcnf = ast_calloc(1, sizeof(*cnf));\n\tif (!cnf) {\n\t\tgoto cnfout;\n\t}\n\n\tcnf->usercontainer = ao2_container_alloc_list(AO2_ALLOC_OPT_LOCK_MUTEX, 0,\n\t\tNULL, user_no_cmp);\n\tif (!cnf->usercontainer) {\n\t\tgoto cnfout;\n\t}\n\n\tast_mutex_init(&cnf->playlock);\n\tast_mutex_init(&cnf->listenlock);\n\tcnf->recordthread = AST_PTHREADT_NULL;\n\tast_mutex_init(&cnf->recordthreadlock);\n\tcnf->announcethread = AST_PTHREADT_NULL;\n\tast_mutex_init(&cnf->announcethreadlock);\n\tast_copy_string(cnf->confno, confno, sizeof(cnf->confno));\n\tast_copy_string(cnf->pin, pin, sizeof(cnf->pin));\n\tast_copy_string(cnf->pinadmin, pinadmin, sizeof(cnf->pinadmin));\n\tast_copy_string(cnf->uniqueid, ast_channel_uniqueid(chan), sizeof(cnf->uniqueid));\n\n\t/* Setup a new dahdi conference */\n\tdahdic.confno = -1;\n\tdahdic.confmode = DAHDI_CONF_CONFANN | DAHDI_CONF_CONFANNMON;\n\tcnf->fd = open(\"/dev/dahdi/pseudo\", O_RDWR);\n\tif (cnf->fd < 0 || ioctl(cnf->fd, DAHDI_SETCONF, &dahdic)) {\n\t\tif (test) {\n\t\t\t/* if we are creating a conference for a unit test, it is not neccesary\n\t\t\t * to open a pseudo channel, so, if we fail continue creating\n\t\t\t * the conference. */\n\t\t\tast_test_status_update(test, \"Unable to open DAHDI pseudo device\\n\");\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Unable to open DAHDI pseudo device\\n\");\n\t\t\tif (cnf->fd >= 0)\n\t\t\t\tclose(cnf->fd);\n\t\t\tao2_ref(cnf->usercontainer, -1);\n\t\t\tast_mutex_destroy(&cnf->playlock);\n\t\t\tast_mutex_destroy(&cnf->listenlock);\n\t\t\tast_mutex_destroy(&cnf->recordthreadlock);\n\t\t\tast_mutex_destroy(&cnf->announcethreadlock);\n\t\t\tast_free(cnf);\n\t\t\tcnf = NULL;\n\t\t\tgoto cnfout;\n\t\t}\n\t}\n\n\tcnf->dahdiconf = dahdic.confno;\n\n\t/* Setup a new channel for playback of audio files */\n\tcnf->chan = ast_request(\"DAHDI\", cap_slin, NULL, chan, \"pseudo\", NULL);\n\tif (cnf->chan) {\n\t\tast_set_read_format(cnf->chan, ast_format_slin);\n\t\tast_set_write_format(cnf->chan, ast_format_slin);\n\t\tdahdic.chan = 0;\n\t\tdahdic.confno = cnf->dahdiconf;\n\t\tdahdic.confmode = DAHDI_CONF_CONFANN | DAHDI_CONF_CONFANNMON;\n\t\tif (ioctl(ast_channel_fd(cnf->chan, 0), DAHDI_SETCONF, &dahdic)) {\n\t\t\tif (test) {\n\t\t\t\tast_test_status_update(test, \"Error setting conference on pseudo channel\\n\");\n\t\t\t}\n\t\t\tast_log(LOG_WARNING, \"Error setting conference\\n\");\n\t\t\tif (cnf->chan)\n\t\t\t\tast_hangup(cnf->chan);\n\t\t\telse\n\t\t\t\tclose(cnf->fd);\n\t\t\tao2_ref(cnf->usercontainer, -1);\n\t\t\tast_mutex_destroy(&cnf->playlock);\n\t\t\tast_mutex_destroy(&cnf->listenlock);\n\t\t\tast_mutex_destroy(&cnf->recordthreadlock);\n\t\t\tast_mutex_destroy(&cnf->announcethreadlock);\n\t\t\tast_free(cnf);\n\t\t\tcnf = NULL;\n\t\t\tgoto cnfout;\n\t\t}\n\t}\n\n\t/* Fill the conference struct */\n\tcnf->start = time(NULL);\n\tcnf->maxusers = 0x7fffffff;\n\tcnf->isdynamic = dynamic ? 1 : 0;\n\tast_verb(3, \"Created MeetMe conference %d for conference '%s'\\n\", cnf->dahdiconf, cnf->confno);\n\tAST_LIST_INSERT_HEAD(&confs, cnf, list);\n\n\t/* Reserve conference number in map */\n\tif ((sscanf(cnf->confno, \"%30d\", &confno_int) == 1) && (confno_int >= 0 && confno_int < 1024))\n\t\tconf_map[confno_int] = 1;\n\ncnfout:\n\tao2_cleanup(cap_slin);\n\tif (cnf)\n\t\tast_atomic_fetchadd_int(&cnf->refcount, refcount);\n\n\tAST_LIST_UNLOCK(&confs);\n\n\treturn cnf;\n}", "path": "asterisk/apps/app_meetme.c", "commit_date": "2019-11-07 00:00:00", "repo_name": "asterisk/asterisk", "stars": 1835, "license": "other", "language": "c", "size": 367375}
{"docstring": "/*!\n * \\brief For a given station, choose the highest priority idle trunk\n * \\pre sla_station is locked\n */\n", "func_signal": "static struct sla_trunk_ref *sla_choose_idle_trunk(const struct sla_station *station)", "code": "{\n\tstruct sla_trunk_ref *trunk_ref = NULL;\n\n\tAST_LIST_TRAVERSE(&station->trunks, trunk_ref, entry) {\n\t\tif (trunk_ref->state == SLA_TRUNK_STATE_IDLE) {\n\t\t\tao2_ref(trunk_ref, 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn trunk_ref;\n}", "path": "asterisk/apps/app_meetme.c", "commit_date": "2019-11-07 00:00:00", "repo_name": "asterisk/asterisk", "stars": 1835, "license": "other", "language": "c", "size": 367375}
{"docstring": "/*! \\internal\n * \\brief creates directory structure and assigns absolute path from relative paths for filenames\n *\n * \\param filename contains the absolute or relative path to the desired file\n * \\param buffer stores completed filename, absolutely must be a buffer of PATH_MAX length\n */\n", "func_signal": "static void filename_parse(char *filename, char *buffer)", "code": "{\n\tchar *slash;\n\tif (ast_strlen_zero(filename)) {\n\t\tast_log(LOG_WARNING, \"No file name was provided for a file save option.\\n\");\n\t} else if (filename[0] != '/') {\n\t\tsnprintf(buffer, PATH_MAX, \"%s/meetme/%s\", ast_config_AST_SPOOL_DIR, filename);\n\t} else {\n\t\tast_copy_string(buffer, filename, PATH_MAX);\n\t}\n\n\tslash = buffer;\n\tif ((slash = strrchr(slash, '/'))) {\n\t\t*slash = '\\0';\n\t\tast_mkdir(buffer, 0777);\n\t\t*slash = '/';\n\t}\n}", "path": "asterisk/apps/app_meetme.c", "commit_date": "2019-11-07 00:00:00", "repo_name": "asterisk/asterisk", "stars": 1835, "license": "other", "language": "c", "size": 367375}
{"docstring": "/*! \\brief Check to see if this station has failed to be dialed in the past minute\n * \\note assumes sla.lock is locked\n */\n", "func_signal": "static int sla_check_failed_station(const struct sla_station *station)", "code": "{\n\tstruct sla_failed_station *failed_station;\n\tint res = 0;\n\n\tAST_LIST_TRAVERSE_SAFE_BEGIN(&sla.failed_stations, failed_station, entry) {\n\t\tif (station != failed_station->station)\n\t\t\tcontinue;\n\t\tif (ast_tvdiff_ms(ast_tvnow(), failed_station->last_try) > 1000) {\n\t\t\tAST_LIST_REMOVE_CURRENT(entry);\n\t\t\tsla_failed_station_destroy(failed_station);\n\t\t\tbreak;\n\t\t}\n\t\tres = 1;\n\t}\n\tAST_LIST_TRAVERSE_SAFE_END\n\n\treturn res;\n}", "path": "asterisk/apps/app_meetme.c", "commit_date": "2019-11-07 00:00:00", "repo_name": "asterisk/asterisk", "stars": 1835, "license": "other", "language": "c", "size": 367375}
{"docstring": "/*! \\brief The MeetMeChannelAdmin application\n\tMeetMeChannelAdmin(channel, command) */\n", "func_signal": "static int channel_admin_exec(struct ast_channel *chan, const char *data)", "code": "{\n\tchar *params;\n\tstruct ast_conference *conf = NULL;\n\tstruct ast_conf_user *user = NULL;\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(channel);\n\t\tAST_APP_ARG(command);\n\t);\n\n\tif (ast_strlen_zero(data)) {\n\t\tast_log(LOG_WARNING, \"MeetMeChannelAdmin requires two arguments!\\n\");\n\t\treturn -1;\n\t}\n\n\tparams = ast_strdupa(data);\n\tAST_STANDARD_APP_ARGS(args, params);\n\n\tif (!args.channel) {\n\t\tast_log(LOG_WARNING, \"MeetMeChannelAdmin requires a channel name!\\n\");\n\t\treturn -1;\n\t}\n\n\tif (!args.command) {\n\t\tast_log(LOG_WARNING, \"MeetMeChannelAdmin requires a command!\\n\");\n\t\treturn -1;\n\t}\n\n\tAST_LIST_LOCK(&confs);\n\tAST_LIST_TRAVERSE(&confs, conf, list) {\n\t\tif ((user = ao2_callback(conf->usercontainer, 0, user_chan_cb, args.channel))) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!user) {\n\t\tast_log(LOG_NOTICE, \"Specified user (%s) not found\\n\", args.channel);\n\t\tAST_LIST_UNLOCK(&confs);\n\t\treturn 0;\n\t}\n\n\t/* perform the specified action */\n\tswitch (*args.command) {\n\t\tcase 77: /* M: Mute */\n\t\t\tuser->adminflags |= ADMINFLAG_MUTED;\n\t\t\tbreak;\n\t\tcase 109: /* m: Unmute */\n\t\t\tuser->adminflags &= ~ADMINFLAG_MUTED;\n\t\t\tbreak;\n\t\tcase 107: /* k: Kick user */\n\t\t\tuser->adminflags |= ADMINFLAG_KICKME;\n\t\t\tbreak;\n\t\tdefault: /* unknown command */\n\t\t\tast_log(LOG_WARNING, \"Unknown MeetMeChannelAdmin command '%s'\\n\", args.command);\n\t\t\tbreak;\n\t}\n\tao2_ref(user, -1);\n\tAST_LIST_UNLOCK(&confs);\n\n\treturn 0;\n}", "path": "asterisk/apps/app_meetme.c", "commit_date": "2019-11-07 00:00:00", "repo_name": "asterisk/asterisk", "stars": 1835, "license": "other", "language": "c", "size": 367375}
{"docstring": "/*! \\brief Calculate the ring delay for a given ringing trunk on a station\n * \\param station the station\n * \\param ringing_trunk the trunk.  If NULL, the highest priority ringing trunk will be used\n * \\return the number of ms left before the delay is complete, or INT_MAX if there is no delay\n */\n", "func_signal": "static int sla_check_station_delay(struct sla_station *station,\n\tstruct sla_ringing_trunk *ringing_trunk)", "code": "{\n\tRAII_VAR(struct sla_trunk_ref *, trunk_ref, NULL, ao2_cleanup);\n\tunsigned int delay = UINT_MAX;\n\tint time_left, time_elapsed;\n\n\tif (!ringing_trunk)\n\t\tringing_trunk = sla_choose_ringing_trunk(station, &trunk_ref, 0);\n\telse\n\t\ttrunk_ref = sla_find_trunk_ref(station, ringing_trunk->trunk);\n\n\tif (!ringing_trunk || !trunk_ref)\n\t\treturn delay;\n\n\t/* If this station has a ring delay specific to the highest priority\n\t * ringing trunk, use that.  Otherwise, use the ring delay specified\n\t * globally for the station. */\n\tdelay = trunk_ref->ring_delay;\n\tif (!delay)\n\t\tdelay = station->ring_delay;\n\tif (!delay)\n\t\treturn INT_MAX;\n\n\ttime_elapsed = ast_tvdiff_ms(ast_tvnow(), ringing_trunk->ring_begin);\n\ttime_left = (delay * 1000) - time_elapsed;\n\n\treturn time_left;\n}", "path": "asterisk/apps/app_meetme.c", "commit_date": "2019-11-07 00:00:00", "repo_name": "asterisk/asterisk", "stars": 1835, "license": "other", "language": "c", "size": 367375}
{"docstring": "/*! \\brief The MeetmeCount application */\n", "func_signal": "static int count_exec(struct ast_channel *chan, const char *data)", "code": "{\n\tint res = 0;\n\tstruct ast_conference *conf;\n\tint count;\n\tchar *localdata;\n\tchar val[80] = \"0\";\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(confno);\n\t\tAST_APP_ARG(varname);\n\t);\n\n\tif (ast_strlen_zero(data)) {\n\t\tast_log(LOG_WARNING, \"MeetMeCount requires an argument (conference number)\\n\");\n\t\treturn -1;\n\t}\n\n\tlocaldata = ast_strdupa(data);\n\n\tAST_STANDARD_APP_ARGS(args, localdata);\n\n\tconf = find_conf(chan, args.confno, 0, 0, NULL, 0, 1, NULL);\n\n\tif (conf) {\n\t\tcount = conf->users;\n\t\tdispose_conf(conf);\n\t\tconf = NULL;\n\t} else\n\t\tcount = 0;\n\n\tif (!ast_strlen_zero(args.varname)) {\n\t\t/* have var so load it and exit */\n\t\tsnprintf(val, sizeof(val), \"%d\", count);\n\t\tpbx_builtin_setvar_helper(chan, args.varname, val);\n\t} else {\n\t\tif (ast_channel_state(chan) != AST_STATE_UP) {\n\t\t\tast_answer(chan);\n\t\t}\n\t\tres = ast_say_number(chan, count, \"\", ast_channel_language(chan), (char *) NULL); /* Needs gender */\n\t}\n\n\treturn res;\n}", "path": "asterisk/apps/app_meetme.c", "commit_date": "2019-11-07 00:00:00", "repo_name": "asterisk/asterisk", "stars": 1835, "license": "other", "language": "c", "size": 367375}
{"docstring": "/*! \\brief Ring a station\n * \\note Assumes sla.lock is locked\n */\n", "func_signal": "static int sla_ring_station(struct sla_ringing_trunk *ringing_trunk, struct sla_station *station)", "code": "{\n\tchar *tech, *tech_data;\n\tstruct ast_dial *dial;\n\tstruct sla_ringing_station *ringing_station;\n\tenum ast_dial_result res;\n\tint caller_is_saved;\n\tstruct ast_party_caller caller;\n\n\tif (!(dial = ast_dial_create()))\n\t\treturn -1;\n\n\tast_dial_set_state_callback(dial, sla_dial_state_callback);\n\ttech_data = ast_strdupa(station->device);\n\ttech = strsep(&tech_data, \"/\");\n\n\tif (ast_dial_append(dial, tech, tech_data, NULL) == -1) {\n\t\tast_dial_destroy(dial);\n\t\treturn -1;\n\t}\n\n\t/* Do we need to save off the caller ID data? */\n\tcaller_is_saved = 0;\n\tif (!sla.attempt_callerid) {\n\t\tcaller_is_saved = 1;\n\t\tcaller = *ast_channel_caller(ringing_trunk->trunk->chan);\n\t\tast_party_caller_init(ast_channel_caller(ringing_trunk->trunk->chan));\n\t}\n\n\tres = ast_dial_run(dial, ringing_trunk->trunk->chan, 1);\n\n\t/* Restore saved caller ID */\n\tif (caller_is_saved) {\n\t\tast_party_caller_free(ast_channel_caller(ringing_trunk->trunk->chan));\n\t\tast_channel_caller_set(ringing_trunk->trunk->chan, &caller);\n\t}\n\n\tif (res != AST_DIAL_RESULT_TRYING) {\n\t\tstruct sla_failed_station *failed_station;\n\t\tast_dial_destroy(dial);\n\t\tif ((failed_station = sla_create_failed_station(station))) {\n\t\t\tAST_LIST_INSERT_HEAD(&sla.failed_stations, failed_station, entry);\n\t\t}\n\t\treturn -1;\n\t}\n\tif (!(ringing_station = sla_create_ringing_station(station))) {\n\t\tast_dial_join(dial);\n\t\tast_dial_destroy(dial);\n\t\treturn -1;\n\t}\n\n\tstation->dial = dial;\n\n\tAST_LIST_INSERT_HEAD(&sla.ringing_stations, ringing_station, entry);\n\n\treturn 0;\n}", "path": "asterisk/apps/app_meetme.c", "commit_date": "2019-11-07 00:00:00", "repo_name": "asterisk/asterisk", "stars": 1835, "license": "other", "language": "c", "size": 367375}
{"docstring": "/*! \\brief Process trunk ring timeouts\n * \\note Called with sla.lock locked\n * \\return non-zero if a change to the ringing trunks was made\n */\n", "func_signal": "static int sla_calc_trunk_timeouts(unsigned int *timeout)", "code": "{\n\tstruct sla_ringing_trunk *ringing_trunk;\n\tint res = 0;\n\n\tAST_LIST_TRAVERSE_SAFE_BEGIN(&sla.ringing_trunks, ringing_trunk, entry) {\n\t\tint time_left, time_elapsed;\n\t\tif (!ringing_trunk->trunk->ring_timeout)\n\t\t\tcontinue;\n\t\ttime_elapsed = ast_tvdiff_ms(ast_tvnow(), ringing_trunk->ring_begin);\n\t\ttime_left = (ringing_trunk->trunk->ring_timeout * 1000) - time_elapsed;\n\t\tif (time_left <= 0) {\n\t\t\tpbx_builtin_setvar_helper(ringing_trunk->trunk->chan, \"SLATRUNK_STATUS\", \"RINGTIMEOUT\");\n\t\t\tAST_LIST_REMOVE_CURRENT(entry);\n\t\t\tsla_stop_ringing_trunk(ringing_trunk);\n\t\t\tres = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (time_left < *timeout)\n\t\t\t*timeout = time_left;\n\t}\n\tAST_LIST_TRAVERSE_SAFE_END;\n\n\treturn res;\n}", "path": "asterisk/apps/app_meetme.c", "commit_date": "2019-11-07 00:00:00", "repo_name": "asterisk/asterisk", "stars": 1835, "license": "other", "language": "c", "size": 367375}
{"docstring": "/*! \\brief Calculate the ring delay for a station\n * \\note Assumes sla.lock is locked\n */\n", "func_signal": "static int sla_calc_station_delays(unsigned int *timeout)", "code": "{\n\tstruct sla_station *station;\n\tint res = 0;\n\tstruct ao2_iterator i;\n\n\ti = ao2_iterator_init(sla_stations, 0);\n\tfor (; (station = ao2_iterator_next(&i)); ao2_ref(station, -1)) {\n\t\tstruct sla_ringing_trunk *ringing_trunk;\n\t\tint time_left;\n\n\t\t/* Ignore stations already ringing */\n\t\tif (sla_check_ringing_station(station))\n\t\t\tcontinue;\n\n\t\t/* Ignore stations already on a call */\n\t\tif (sla_check_inuse_station(station))\n\t\t\tcontinue;\n\n\t\t/* Ignore stations that don't have one of their trunks ringing */\n\t\tif (!(ringing_trunk = sla_choose_ringing_trunk(station, NULL, 0)))\n\t\t\tcontinue;\n\n\t\tif ((time_left = sla_check_station_delay(station, ringing_trunk)) == INT_MAX)\n\t\t\tcontinue;\n\n\t\t/* If there is no time left, then the station needs to start ringing.\n\t\t * Return non-zero so that an event will be queued up an event to\n\t\t * make that happen. */\n\t\tif (time_left <= 0) {\n\t\t\tres = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (time_left < *timeout)\n\t\t\t*timeout = time_left;\n\t}\n\tao2_iterator_destroy(&i);\n\n\treturn res;\n}", "path": "asterisk/apps/app_meetme.c", "commit_date": "2019-11-07 00:00:00", "repo_name": "asterisk/asterisk", "stars": 1835, "license": "other", "language": "c", "size": 367375}
{"docstring": "/*! \\brief Check to see if this station is already ringing\n * \\note Assumes sla.lock is locked\n */\n", "func_signal": "static int sla_check_ringing_station(const struct sla_station *station)", "code": "{\n\tstruct sla_ringing_station *ringing_station;\n\n\tAST_LIST_TRAVERSE(&sla.ringing_stations, ringing_station, entry) {\n\t\tif (station == ringing_station->station)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}", "path": "asterisk/apps/app_meetme.c", "commit_date": "2019-11-07 00:00:00", "repo_name": "asterisk/asterisk", "stars": 1835, "license": "other", "language": "c", "size": 367375}
{"docstring": "/*! \\internal\n * \\brief Processes menu options for the various menu types (accessible through the 's' option for app_meetme)\n *\n * \\param menu_mode a pointer to the currently active menu_mode.\n * \\param dtmf a pointer to the dtmf value currently being processed against the menu.\n * \\param conf the active conference for which the user has called the menu from.\n * \\param confflags flags used by conf for various options\n * \\param chan ast_channel belonging to the user who called the menu\n * \\param user which meetme conference user invoked the menu\n * \\param recordingtmp character buffer which may hold the name of the conference recording file\n */\n", "func_signal": "static void meetme_menu(enum menu_modes *menu_mode, int *dtmf,\n\tstruct ast_conference *conf, struct ast_flags64 *confflags, struct ast_channel *chan,\n\tstruct ast_conf_user *user, char *recordingtmp, int recordingtmp_size,\n\tstruct ast_format_cap *cap_slin)", "code": "{\n\tswitch (*menu_mode) {\n\tcase MENU_DISABLED:\n\t\tbreak;\n\tcase MENU_NORMAL:\n\t\tmeetme_menu_normal(menu_mode, dtmf, conf, confflags, chan, user);\n\t\tbreak;\n\tcase MENU_ADMIN:\n\t\tmeetme_menu_admin(menu_mode, dtmf, conf, confflags, chan, user);\n\t\t/* Admin Menu is capable of branching into another menu, in which case it will reset dtmf and change the menu mode. */\n\t\tif (*menu_mode != MENU_ADMIN_EXTENDED || (*dtmf <= 0)) {\n\t\t\tbreak;\n\t\t}\n\tcase MENU_ADMIN_EXTENDED:\n\t\tmeetme_menu_admin_extended(menu_mode, dtmf, conf, confflags, chan, user,\n\t\t\trecordingtmp, recordingtmp_size, cap_slin);\n\t\tbreak;\n\t}\n}", "path": "asterisk/apps/app_meetme.c", "commit_date": "2019-11-07 00:00:00", "repo_name": "asterisk/asterisk", "stars": 1835, "license": "other", "language": "c", "size": 367375}
{"docstring": "/*! \\brief The MeetMeadmin application\n\n  MeetMeAdmin(confno, command, caller) */\n", "func_signal": "static int admin_exec(struct ast_channel *chan, const char *data)", "code": "{\n\tchar *params;\n\tstruct ast_conference *cnf;\n\tstruct ast_conf_user *user = NULL;\n\tAST_DECLARE_APP_ARGS(args,\n\t\tAST_APP_ARG(confno);\n\t\tAST_APP_ARG(command);\n\t\tAST_APP_ARG(user);\n\t);\n\tint res = 0;\n\n\tif (ast_strlen_zero(data)) {\n\t\tast_log(LOG_WARNING, \"MeetMeAdmin requires an argument!\\n\");\n\t\tpbx_builtin_setvar_helper(chan, \"MEETMEADMINSTATUS\", \"NOPARSE\");\n\t\treturn -1;\n\t}\n\n\tparams = ast_strdupa(data);\n\tAST_STANDARD_APP_ARGS(args, params);\n\n\tif (!args.command) {\n\t\tast_log(LOG_WARNING, \"MeetmeAdmin requires a command!\\n\");\n\t\tpbx_builtin_setvar_helper(chan, \"MEETMEADMINSTATUS\", \"NOPARSE\");\n\t\treturn -1;\n\t}\n\n\tAST_LIST_LOCK(&confs);\n\tAST_LIST_TRAVERSE(&confs, cnf, list) {\n\t\tif (!strcmp(cnf->confno, args.confno))\n\t\t\tbreak;\n\t}\n\n\tif (!cnf) {\n\t\tast_log(LOG_WARNING, \"Conference number '%s' not found!\\n\", args.confno);\n\t\tAST_LIST_UNLOCK(&confs);\n\t\tpbx_builtin_setvar_helper(chan, \"MEETMEADMINSTATUS\", \"NOTFOUND\");\n\t\treturn 0;\n\t}\n\n\tast_atomic_fetchadd_int(&cnf->refcount, 1);\n\n\tif (args.user) {\n\t\tuser = find_user(cnf, args.user);\n\t\tif (!user) {\n\t\t\tast_log(LOG_NOTICE, \"Specified User not found!\\n\");\n\t\t\tres = -2;\n\t\t\tgoto usernotfound;\n\t\t}\n\t} else {\n\t\t/* fail for commands that require a user */\n\t\tswitch (*args.command) {\n\t\tcase 'm': /* Unmute */\n\t\tcase 'M': /* Mute */\n\t\tcase 't': /* Lower user's talk volume */\n\t\tcase 'T': /* Raise user's talk volume */\n\t\tcase 'u': /* Lower user's listen volume */\n\t\tcase 'U': /* Raise user's listen volume */\n\t\tcase 'r': /* Reset user's volume level */\n\t\tcase 'k': /* Kick user */\n\t\t\tres = -2;\n\t\t\tast_log(LOG_NOTICE, \"No user specified!\\n\");\n\t\t\tgoto usernotfound;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (*args.command) {\n\tcase 76: /* L: Lock */\n\t\tcnf->locked = 1;\n\t\tbreak;\n\tcase 108: /* l: Unlock */\n\t\tcnf->locked = 0;\n\t\tbreak;\n\tcase 75: /* K: kick all users */\n\t\tao2_callback(cnf->usercontainer, OBJ_NODATA, user_set_kickme_cb, NULL);\n\t\tbreak;\n\tcase 101: /* e: Eject last user*/\n\t{\n\t\tint max_no = 0;\n\t\tRAII_VAR(struct ast_conf_user *, eject_user, NULL, ao2_cleanup);\n\n\t\tao2_callback(cnf->usercontainer, OBJ_NODATA, user_max_cmp, &max_no);\n\t\teject_user = ao2_find(cnf->usercontainer, &max_no, 0);\n\t\tif (!eject_user) {\n\t\t\tres = -1;\n\t\t\tast_log(LOG_NOTICE, \"No last user to kick!\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!ast_test_flag64(&eject_user->userflags, CONFFLAG_ADMIN)) {\n\t\t\teject_user->adminflags |= ADMINFLAG_KICKME;\n\t\t} else {\n\t\t\tres = -1;\n\t\t\tast_log(LOG_NOTICE, \"Not kicking last user, is an Admin!\\n\");\n\t\t}\n\t\tbreak;\n\t}\n\tcase 77: /* M: Mute */\n\t\tuser->adminflags |= ADMINFLAG_MUTED;\n\t\tbreak;\n\tcase 78: /* N: Mute all (non-admin) users */\n\t\tao2_callback(cnf->usercontainer, OBJ_NODATA, user_set_muted_cb, &cnf);\n\t\tbreak;\n\tcase 109: /* m: Unmute */\n\t\tuser->adminflags &= ~(ADMINFLAG_MUTED | ADMINFLAG_SELFMUTED | ADMINFLAG_T_REQUEST);\n\t\tbreak;\n\tcase 110: /* n: Unmute all users */\n\t\tao2_callback(cnf->usercontainer, OBJ_NODATA, user_set_unmuted_cb, NULL);\n\t\tbreak;\n\tcase 107: /* k: Kick user */\n\t\tuser->adminflags |= ADMINFLAG_KICKME;\n\t\tbreak;\n\tcase 118: /* v: Lower all users listen volume */\n\t\tao2_callback(cnf->usercontainer, OBJ_NODATA, user_listen_voldown_cb, NULL);\n\t\tbreak;\n\tcase 86: /* V: Raise all users listen volume */\n\t\tao2_callback(cnf->usercontainer, OBJ_NODATA, user_listen_volup_cb, NULL);\n\t\tbreak;\n\tcase 115: /* s: Lower all users speaking volume */\n\t\tao2_callback(cnf->usercontainer, OBJ_NODATA, user_talk_voldown_cb, NULL);\n\t\tbreak;\n\tcase 83: /* S: Raise all users speaking volume */\n\t\tao2_callback(cnf->usercontainer, OBJ_NODATA, user_talk_volup_cb, NULL);\n\t\tbreak;\n\tcase 82: /* R: Reset all volume levels */\n\t\tao2_callback(cnf->usercontainer, OBJ_NODATA, user_reset_vol_cb, NULL);\n\t\tbreak;\n\tcase 114: /* r: Reset user's volume level */\n\t\treset_volumes(user);\n\t\tbreak;\n\tcase 85: /* U: Raise user's listen volume */\n\t\ttweak_listen_volume(user, VOL_UP);\n\t\tbreak;\n\tcase 117: /* u: Lower user's listen volume */\n\t\ttweak_listen_volume(user, VOL_DOWN);\n\t\tbreak;\n\tcase 84: /* T: Raise user's talk volume */\n\t\ttweak_talk_volume(user, VOL_UP);\n\t\tbreak;\n\tcase 116: /* t: Lower user's talk volume */\n\t\ttweak_talk_volume(user, VOL_DOWN);\n\t\tbreak;\n\tcase 'E': /* E: Extend conference */\n\t\tif (rt_extend_conf(args.confno)) {\n\t\t\tres = -1;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (args.user) {\n\t\t/* decrement reference from find_user */\n\t\tao2_ref(user, -1);\n\t}\nusernotfound:\n\tAST_LIST_UNLOCK(&confs);\n\n\tdispose_conf(cnf);\n\tpbx_builtin_setvar_helper(chan, \"MEETMEADMINSTATUS\", res == -2 ? \"NOTFOUND\" : res ? \"FAILED\" : \"OK\");\n\n\treturn 0;\n}", "path": "asterisk/apps/app_meetme.c", "commit_date": "2019-11-07 00:00:00", "repo_name": "asterisk/asterisk", "stars": 1835, "license": "other", "language": "c", "size": 367375}
{"docstring": "/*! \\brief Decrement reference counts, as incremented by find_conf() */\n", "func_signal": "static int dispose_conf(struct ast_conference *conf)", "code": "{\n\tint res = 0;\n\tint confno_int = 0;\n\n\tAST_LIST_LOCK(&confs);\n\tif (ast_atomic_dec_and_test(&conf->refcount)) {\n\t\t/* Take the conference room number out of an inuse state */\n\t\tif ((sscanf(conf->confno, \"%4d\", &confno_int) == 1) && (confno_int >= 0 && confno_int < 1024)) {\n\t\t\tconf_map[confno_int] = 0;\n\t\t}\n\t\tconf_free(conf);\n\t\tres = 1;\n\t}\n\tAST_LIST_UNLOCK(&confs);\n\n\treturn res;\n}", "path": "asterisk/apps/app_meetme.c", "commit_date": "2019-11-07 00:00:00", "repo_name": "asterisk/asterisk", "stars": 1835, "license": "other", "language": "c", "size": 367375}
{"docstring": "/*!\n * \\internal\n * \\brief Find an SLA station by name\n */\n", "func_signal": "static struct sla_station *sla_find_station(const char *name)", "code": "{\n\tstruct sla_station tmp_station = {\n\t\t.name = name,\n\t};\n\n\treturn ao2_find(sla_stations, &tmp_station, OBJ_POINTER);\n}", "path": "asterisk/apps/app_meetme.c", "commit_date": "2019-11-07 00:00:00", "repo_name": "asterisk/asterisk", "stars": 1835, "license": "other", "language": "c", "size": 367375}
{"docstring": "/* is_enable - wrapper to convert user input into integer.\n * LED colors: \n * - valid <1..6>, <0xE..0xF>\n * - reserved [0, 7]\n * - undefined <8..D>\n *\n * @argv_ptr: source string to convert from; usually argv\n * @enable_ptr: pointer where to store result\n * returns: zero on success, other values mean error\n */\n", "func_signal": "int\nis_led_color(const char *argv_ptr, uint8_t *led_color_ptr)", "code": "{\n\tif (!argv_ptr || !led_color_ptr) {\n\t\tlprintf(LOG_ERR, \"is_led_color(): invalid argument(s).\");\n\t\treturn (-1);\n\t}\n\tif (str2uchar(argv_ptr, led_color_ptr) != 0) {\n\t\tlprintf(LOG_ERR, \"Given LED Color '%s' is invalid.\",\n\t\t\t\targv_ptr);\n\t\tlprintf(LOG_ERR,\n\t\t\t\t\"LED Color must be from ranges: <1..6>, <0xE..0xF>\");\n\t\treturn (-1);\n\t}\n\tif ((*led_color_ptr >= 1 && *led_color_ptr <= 6)\n\t\t\t|| (*led_color_ptr >= 0xE && *led_color_ptr <= 0xF)) {\n\t\treturn 0;\n\t}\n\tlprintf(LOG_ERR, \"Given LED Color '%s' is out of range.\", argv_ptr);\n\tlprintf(LOG_ERR, \"LED Color must be from ranges: <1..6>, <0xE..0xF>\");\n\treturn (-1);\n}", "path": "ipmitool/lib/ipmi_picmg.c", "commit_date": "2020-06-10 00:00:00", "repo_name": "ipmitool/ipmitool", "stars": 1143, "license": "other", "language": "c", "size": 3233}
{"docstring": "/* is_clk_setting - wrapper to convert user input into integer.\n * Clock Setting is a 1B bitfield:\n * x [7:4] - reserved\n * x [3] - state - 0/1\n * x [2] - direction - 0/1\n * x [1:0] - PLL ctrl - 00/01/10/11[Reserved]\n *\n * @argv_ptr: source string to convert from; usually argv\n * @clk_setting_ptr: pointer where to store result\n * returns: zero on success, other values mean error\n */\n", "func_signal": "int\nis_clk_setting(const char *argv_ptr, uint8_t *clk_setting_ptr)", "code": "{\n\tif (!argv_ptr || !clk_setting_ptr) {\n\t\tlprintf(LOG_ERR, \"is_clk_setting(): invalid argument(s).\");\n\t\treturn (-1);\n\t}\n\tif (str2uchar(argv_ptr, clk_setting_ptr) == 0) {\n\t\treturn 0;\n\t}\n\t/* FIXME - validate bits 4-7 are 0 ? */\n\tlprintf(LOG_ERR, \"Given Clock Setting '%s' is invalid.\", argv_ptr);\n\treturn (-1);\n}", "path": "ipmitool/lib/ipmi_picmg.c", "commit_date": "2020-06-10 00:00:00", "repo_name": "ipmitool/ipmitool", "stars": 1143, "license": "other", "language": "c", "size": 3233}
{"docstring": "/* is_link_type - wrapper to convert user input into integer.\n * Link Type limits are unknown, bits [19:12]\n *\n * @argv_ptr: source string to convert from; usually argv\n * @link_type_ptr: pointer where to store result\n * returns: zero on success, other values mean error\n */\n", "func_signal": "int\nis_link_type(const char *argv_ptr, uint8_t *link_type_ptr)", "code": "{\n\tif (!argv_ptr || !link_type_ptr) {\n\t\tlprintf(LOG_ERR, \"is_link_type(): invalid argument(s).\");\n\t\treturn (-1);\n\t}\n\tif (str2uchar(argv_ptr, link_type_ptr) == 0) {\n\t\treturn 0;\n\t}\n\tlprintf(LOG_ERR, \"Given Link Type '%s' is invalid.\", argv_ptr);\n\treturn (-1);\n}", "path": "ipmitool/lib/ipmi_picmg.c", "commit_date": "2020-06-10 00:00:00", "repo_name": "ipmitool/ipmitool", "stars": 1143, "license": "other", "language": "c", "size": 3233}
{"docstring": "/* HAVE_READLINE */\n", "func_signal": "int\nipmi_shell_main(struct ipmi_intf *__UNUSED__(intf),\n                int __UNUSED__(argc),\n                char **__UNUSED__(argv))", "code": "{\n\tlprintf(LOG_ERR, \"Compiled without readline, shell is disabled\");\n\treturn -1;\n}", "path": "ipmitool/src/ipmishell.c", "commit_date": "2020-06-10 00:00:00", "repo_name": "ipmitool/ipmitool", "stars": 1143, "license": "other", "language": "c", "size": 3233}
{"docstring": "/* is_enable - wrapper to convert user input into integer.\n * Valid input range for Enable is <0..1>.\n *\n * @argv_ptr: source string to convert from; usually argv\n * @enable_ptr: pointer where to store result\n * returns: zero on success, other values mean error\n */\n", "func_signal": "int\nis_enable(const char *argv_ptr, uint8_t *enable_ptr)", "code": "{\n\tif (!argv_ptr || !enable_ptr) {\n\t\tlprintf(LOG_ERR, \"is_enable(): invalid argument(s).\");\n\t\treturn (-1);\n\t}\n\tif (str2uchar(argv_ptr, enable_ptr) == 0\n\t\t\t&& (*enable_ptr == 0 || *enable_ptr == 1)) {\n\t\treturn 0;\n\t}\n\tlprintf(LOG_ERR, \"Given Enable '%s' is invalid.\", argv_ptr);\n\treturn (-1);\n}", "path": "ipmitool/lib/ipmi_picmg.c", "commit_date": "2020-06-10 00:00:00", "repo_name": "ipmitool/ipmitool", "stars": 1143, "license": "other", "language": "c", "size": 3233}
{"docstring": "/* is_amc_port - wrapper to convert user input into integer.\n * AMC Port limits are unknown.\n *\n * @argv_ptr: source string to convert from; usually argv\n * @amc_port_ptr: pointer where to store result\n * returns: zero on success, other values mean error\n */\n", "func_signal": "int\nis_amc_port(const char *argv_ptr, int32_t *amc_port_ptr)", "code": "{\n\tif (!argv_ptr || !amc_port_ptr) {\n\t\tlprintf(LOG_ERR, \"is_amc_port(): invalid argument(s).\");\n\t\treturn (-1);\n\t}\n\tif (str2int(argv_ptr, amc_port_ptr) == 0 && *amc_port_ptr >= 0) {\n\t\treturn 0;\n\t}\n\tlprintf(LOG_ERR, \"Given PICMG Port '%s' is invalid.\", argv_ptr);\n\treturn (-1);\n}", "path": "ipmitool/lib/ipmi_picmg.c", "commit_date": "2020-06-10 00:00:00", "repo_name": "ipmitool/ipmitool", "stars": 1143, "license": "other", "language": "c", "size": 3233}
{"docstring": "/* is_clk_index - wrapper to convert user input into integer.\n * Clock Index limits are unknown[1B by spec]\n *\n * @argv_ptr: source string to convert from; usually argv\n * @clk_index_ptr: pointer where to store result\n * returns: zero on success, other values mean error\n */\n", "func_signal": "int\nis_clk_index(const char *argv_ptr, uint8_t *clk_index_ptr)", "code": "{\n\tif (!argv_ptr || !clk_index_ptr) {\n\t\tlprintf(LOG_ERR, \"is_clk_index(): invalid argument(s).\");\n\t\treturn (-1);\n\t}\n\tif (str2uchar(argv_ptr, clk_index_ptr) == 0) {\n\t\treturn 0;\n\t}\n\tlprintf(LOG_ERR, \"Given Clock Index '%s' is invalid.\", argv_ptr);\n\treturn (-1);\n}", "path": "ipmitool/lib/ipmi_picmg.c", "commit_date": "2020-06-10 00:00:00", "repo_name": "ipmitool/ipmitool", "stars": 1143, "license": "other", "language": "c", "size": 3233}
{"docstring": "/* is_led_id - wrapper to convert user input into integer.\n * LED ID range seems to be <0..255>\n *\n * @argv_ptr: source string to convert from; usually argv\n * @led_id_ptr: pointer where to store result\n * returns: zero on success, other values mean error\n */\n", "func_signal": "int\nis_led_id(const char *argv_ptr, uint8_t *led_id_ptr)", "code": "{\n\tif (!argv_ptr || !led_id_ptr) {\n\t\tlprintf(LOG_ERR, \"is_led_id(): invalid argument(s).\");\n\t\treturn (-1);\n\t}\n\tif (str2uchar(argv_ptr, led_id_ptr) == 0) {\n\t\treturn 0;\n\t}\n\tlprintf(LOG_ERR, \"Given LED ID '%s' is invalid.\", argv_ptr);\n\treturn (-1);\n}", "path": "ipmitool/lib/ipmi_picmg.c", "commit_date": "2020-06-10 00:00:00", "repo_name": "ipmitool/ipmitool", "stars": 1143, "license": "other", "language": "c", "size": 3233}
{"docstring": "/* is_led_function - wrapper to convert user input into integer.\n * LED functions, however, might differ by OEM:\n * - 0x00 - off override\n * - <0x01..0xFA> - blinking override\n * - 0xFB - lamp test state\n * - 0xFC - state restored to local ctrl state\n * - <0xFD..0xFE> - reserved\n * - 0xFF - on override\n *\n * @argv_ptr: source string to convert from; usually argv\n * @led_fn_ptr: pointer where to store result\n * returns: zero on success, other values mean error\n */\n", "func_signal": "int\nis_led_function(const char *argv_ptr, uint8_t *led_fn_ptr)", "code": "{\n\tif (!argv_ptr || !led_fn_ptr) {\n\t\tlprintf(LOG_ERR, \"is_led_function(): invalid argument(s).\");\n\t\treturn (-1);\n\t}\n\tif (str2uchar(argv_ptr, led_fn_ptr) == 0\n\t\t\t&& (*led_fn_ptr < 0xFD || *led_fn_ptr > 0xFE)) {\n\t\treturn 0;\n\t}\n\tlprintf(LOG_ERR, \"Given LED Function '%s' is invalid.\", argv_ptr);\n\treturn (-1);\n}", "path": "ipmitool/lib/ipmi_picmg.c", "commit_date": "2020-06-10 00:00:00", "repo_name": "ipmitool/ipmitool", "stars": 1143, "license": "other", "language": "c", "size": 3233}
{"docstring": "/* is_clk_acc - wrapper to convert user input into integer.\n * Clock Accuracy limits are unknown[1byte by spec].\n *\n * @argv_ptr: source string to convert from; usually argv\n * @clk_acc_ptr: pointer where to store result\n * returns: zero on success, other values mean error\n */\n", "func_signal": "int\nis_clk_acc(const char *argv_ptr, uint8_t *clk_acc_ptr)", "code": "{\n\tif (!argv_ptr || !clk_acc_ptr) {\n\t\tlprintf(LOG_ERR, \"is_clk_acc(): invalid argument(s).\");\n\t\treturn (-1);\n\t}\n\tif (str2uchar(argv_ptr, clk_acc_ptr) == 0) {\n\t\treturn 0;\n\t}\n\tlprintf(LOG_ERR, \"Given Clock Accuracy '%s' is invalid.\",\n\t\t\targv_ptr);\n\treturn (-1);\n}", "path": "ipmitool/lib/ipmi_picmg.c", "commit_date": "2020-06-10 00:00:00", "repo_name": "ipmitool/ipmitool", "stars": 1143, "license": "other", "language": "c", "size": 3233}
{"docstring": "/* HAVE_READLINE */\n", "func_signal": "int ipmi_echo_main(struct ipmi_intf *__UNUSED__(intf), int argc,\n                   char **argv)", "code": "{\n\tint i;\n\n\tfor (i=0; i<argc; i++) {\n\t\tprintf(\"%s \", argv[i]);\n\t}\n\tprintf(\"\\n\");\n\n\treturn 0;\n}", "path": "ipmitool/src/ipmishell.c", "commit_date": "2020-06-10 00:00:00", "repo_name": "ipmitool/ipmitool", "stars": 1143, "license": "other", "language": "c", "size": 3233}
{"docstring": "/* is_clk_resid - wrapper to convert user input into integer.\n * Clock Resource Index(?) limits are unknown, but maximum seems to be 15.\n *\n * @argv_ptr: source string to convert from; usually argv\n * @clk_resid_ptr: pointer where to store result\n * returns: zero on success, other values mean error\n */\n", "func_signal": "int\nis_clk_resid(const char *argv_ptr, int8_t *clk_resid_ptr)", "code": "{\n\tif (!argv_ptr || !clk_resid_ptr) {\n\t\tlprintf(LOG_ERR, \"is_clk_resid(): invalid argument(s).\");\n\t\treturn (-1);\n\t}\n\tif (str2char(argv_ptr, clk_resid_ptr) == 0\n\t\t\t&& *clk_resid_ptr > (-1)) {\n\t\treturn 0;\n\t}\n\tlprintf(LOG_ERR, \"Given Resource ID '%s' is invalid.\",\n\t\t\tclk_resid_ptr);\n\treturn (-1);\n}", "path": "ipmitool/lib/ipmi_picmg.c", "commit_date": "2020-06-10 00:00:00", "repo_name": "ipmitool/ipmitool", "stars": 1143, "license": "other", "language": "c", "size": 3233}
{"docstring": "/* is_clk_freq - wrapper to convert user input into integer.\n * Clock Frequency limits are unknown, but specification says\n * 3Bytes + 1B checksum\n *\n * @argv_ptr: source string to convert from; usually argv\n * @clk_freq_ptr: pointer where to store result\n * returns: zero on success, other values mean error\n */\n", "func_signal": "int\nis_clk_freq(const char *argv_ptr, uint32_t *clk_freq_ptr)", "code": "{\n\tif (!argv_ptr || !clk_freq_ptr) {\n\t\tlprintf(LOG_ERR, \"is_clk_freq(): invalid argument(s).\");\n\t\treturn (-1);\n\t}\n\tif (str2uint(argv_ptr, clk_freq_ptr) == 0) {\n\t\treturn 0;\n\t}\n\tlprintf(LOG_ERR, \"Given Clock Frequency '%s' is invalid.\",\n\t\t\targv_ptr);\n\treturn (-1);\n}", "path": "ipmitool/lib/ipmi_picmg.c", "commit_date": "2020-06-10 00:00:00", "repo_name": "ipmitool/ipmitool", "stars": 1143, "license": "other", "language": "c", "size": 3233}
{"docstring": "/* This function attempts to keep lan sessions active\n * so they do not time out waiting for user input.  The\n * readline timeout is set to 1 second but lan session\n * timeout is ~60 seconds.\n */\n", "func_signal": "static int rl_event_keepalive(void)", "code": "{\n\tstatic int internal_timer = 0;\n\n\tif (!shell_intf)\n\t\treturn -1;\n\tif (!shell_intf->keepalive)\n\t\treturn 0;\n#if defined (RL_READLINE_VERSION) && RL_READLINE_VERSION >= 0x0402\n\tif (internal_timer++ < RL_TIMEOUT)\n#else\n\t/* In readline < 4.2 keyboard timeout hardcoded to 0.1 second */\n\tif (internal_timer++ < RL_TIMEOUT * 10)\n#endif\n\t\treturn 0;\n\n\tinternal_timer = 0;\n\tshell_intf->keepalive(shell_intf);\n\n\treturn 0;\n}", "path": "ipmitool/src/ipmishell.c", "commit_date": "2020-06-10 00:00:00", "repo_name": "ipmitool/ipmitool", "stars": 1143, "license": "other", "language": "c", "size": 3233}
{"docstring": "/* is_clk_family - wrapper to convert user input into integer.\n * Clock Family limits are unknown[1byte by spec].\n *\n * @argv_ptr: source string to convert from; usually argv\n * @clk_family_ptr: pointer where to store result\n * returns: zero on success, other values mean error\n */\n", "func_signal": "int\nis_clk_family(const char *argv_ptr, uint8_t *clk_family_ptr)", "code": "{\n\tif (!argv_ptr || !clk_family_ptr) {\n\t\tlprintf(LOG_ERR, \"is_clk_family(): invalid argument(s).\");\n\t\treturn (-1);\n\t}\n\tif (str2uchar(argv_ptr, clk_family_ptr) == 0) {\n\t\treturn 0;\n\t}\n\tlprintf(LOG_ERR, \"Given Clock Family '%s' is invalid.\",\n\t\t\targv_ptr);\n\treturn (-1);\n}", "path": "ipmitool/lib/ipmi_picmg.c", "commit_date": "2020-06-10 00:00:00", "repo_name": "ipmitool/ipmitool", "stars": 1143, "license": "other", "language": "c", "size": 3233}
{"docstring": "/* is_link_group - wrapper to convert user input into integer.\n * Link Grouping ID limis are unknown, bits [31:24] by spec.\n *\n * @argv_ptr: source string to convert from; usually argv\n * @link_grp_ptr: pointer where to store result\n * returns: zero on success, other values mean error\n */\n", "func_signal": "int\nis_link_group(const char *argv_ptr, uint8_t *link_grp_ptr)", "code": "{\n\tif (!argv_ptr || !link_grp_ptr) {\n\t\tlprintf(LOG_ERR, \"is_link_group(): invalid argument(s).\");\n\t\treturn (-1);\n\t}\n\tif (str2uchar(argv_ptr, link_grp_ptr) == 0) {\n\t\treturn 0;\n\t}\n\tlprintf(LOG_ERR, \"Given Link Group '%s' is invalid.\", argv_ptr);\n\treturn (-1);\n}", "path": "ipmitool/lib/ipmi_picmg.c", "commit_date": "2020-06-10 00:00:00", "repo_name": "ipmitool/ipmitool", "stars": 1143, "license": "other", "language": "c", "size": 3233}
{"docstring": "/* is_clk_id - wrapper to convert user input into integer.\n * Clock ID limits are unknown, however it's 1B by specification and I've\n * found two ranges: <1..5> or <0..15>\n *\n * @argv_ptr: source string to convert from; usually argv\n * @clk_id_ptr: pointer where to store result\n * returns: zero on success, other values mean error\n */\n", "func_signal": "int\nis_clk_id(const char *argv_ptr, uint8_t *clk_id_ptr)", "code": "{\n\tif (!argv_ptr || !clk_id_ptr) {\n\t\tlprintf(LOG_ERR, \"is_clk_id(): invalid argument(s).\");\n\t\treturn (-1);\n\t}\n\tif (str2uchar(argv_ptr, clk_id_ptr) == 0) {\n\t\treturn 0;\n\t}\n\tlprintf(LOG_ERR, \"Given Clock ID '%s' is invalid.\", argv_ptr);\n\treturn (-1);\n}", "path": "ipmitool/lib/ipmi_picmg.c", "commit_date": "2020-06-10 00:00:00", "repo_name": "ipmitool/ipmitool", "stars": 1143, "license": "other", "language": "c", "size": 3233}
{"docstring": "/* is_amc_channel - wrapper to convert user input into integer\n * AMC Channel range seems to be <0..255>, bits [7:0]\n *\n * @argv_ptr: source string to convert from; usually argv\n * @amc_chan_ptr: pointer where to store result\n * returns: zero on success, other values mean error\n */\n", "func_signal": "int\nis_amc_channel(const char *argv_ptr, uint8_t *amc_chan_ptr)", "code": "{\n\tif (!argv_ptr || !amc_chan_ptr) {\n\t\tlprintf(LOG_ERR, \"is_amc_channel(): invalid argument(s).\");\n\t\treturn (-1);\n\t}\n\tif (str2uchar(argv_ptr, amc_chan_ptr) == 0) {\n\t\treturn 0;\n\t}\n\tlprintf(LOG_ERR, \"Given AMC Channel '%s' is invalid.\", argv_ptr);\n\treturn (-1);\n}", "path": "ipmitool/lib/ipmi_picmg.c", "commit_date": "2020-06-10 00:00:00", "repo_name": "ipmitool/ipmitool", "stars": 1143, "license": "other", "language": "c", "size": 3233}
{"docstring": "/* is_link_type_ext - wrapper to convert user input into integer.\n * Link Type Extension limits are unknown, bits [23:20] => <0..15> ?\n *\n * @argv_ptr: source string to convert from; usually argv\n * @link_type_ext_ptr: pointer where to store result\n * returns: zero on success, other values mean error\n */\n", "func_signal": "int\nis_link_type_ext(const char *argv_ptr, uint8_t *link_type_ext_ptr)", "code": "{\n\tif (!argv_ptr || !link_type_ext_ptr) {\n\t\tlprintf(LOG_ERR, \"is_link_type_ext(): invalid argument(s).\");\n\t\treturn (-1);\n\t}\n\tif (str2uchar(argv_ptr, link_type_ext_ptr) != 0\n\t\t\t|| *link_type_ext_ptr > 15) {\n\t\tlprintf(LOG_ERR,\n\t\t\t\t\"Given Link Type Extension '%s' is invalid.\",\n\t\t\t\targv_ptr);\n\t\treturn (-1);\n\t}\n\treturn 0;\n}", "path": "ipmitool/lib/ipmi_picmg.c", "commit_date": "2020-06-10 00:00:00", "repo_name": "ipmitool/ipmitool", "stars": 1143, "license": "other", "language": "c", "size": 3233}
{"docstring": "/* is_amc_dev - wrapper to convert user input into integer.\n * AMC Dev ID limits are unknown.\n *\n * @argv_ptr: source string to convert from; usually argv\n * @amc_dev_ptr: pointer where to store result\n * returns: zero on success, other values mean error\n */\n", "func_signal": "int\nis_amc_dev(const char *argv_ptr, int32_t *amc_dev_ptr)", "code": "{\n\tif (!argv_ptr || !amc_dev_ptr) {\n\t\tlprintf(LOG_ERR, \"is_amc_dev(): invalid argument(s).\");\n\t\treturn (-1);\n\t}\n\tif (str2int(argv_ptr, amc_dev_ptr) == 0 && *amc_dev_ptr >= 0) {\n\t\treturn 0;\n\t}\n\tlprintf(LOG_ERR, \"Given PICMG Device '%s' is invalid.\",\n\t\t\targv_ptr);\n\treturn (-1);\n}", "path": "ipmitool/lib/ipmi_picmg.c", "commit_date": "2020-06-10 00:00:00", "repo_name": "ipmitool/ipmitool", "stars": 1143, "license": "other", "language": "c", "size": 3233}
{"docstring": "/* A case insensitive version used for the command lookup table and other\n * places where case insensitive non binary-safe comparison is needed. */\n", "func_signal": "int dictSdsKeyCaseCompare(void *privdata, const void *key1,\n        const void *key2)", "code": "{\n    DICT_NOTUSED(privdata);\n\n    return strcasecmp(key1, key2) == 0;\n}", "path": "AnnotatedCode/redis-5.0/src/server.c", "commit_date": "2019-12-27 00:00:00", "repo_name": "chenyahui/AnnotatedCode", "stars": 1336, "license": "None", "language": "c", "size": 7553}
{"docstring": "/* The PING command. It works in a different way if the client is in\n * in Pub/Sub mode. */\n", "func_signal": "void pingCommand(client *c)", "code": "{\n    /* The command takes zero or one arguments. */\n    if (c->argc > 2) {\n        addReplyErrorFormat(c,\"wrong number of arguments for '%s' command\",\n            c->cmd->name);\n        return;\n    }\n\n    if (c->flags & CLIENT_PUBSUB) {\n        addReply(c,shared.mbulkhdr[2]);\n        addReplyBulkCBuffer(c,\"pong\",4);\n        if (c->argc == 1)\n            addReplyBulkCBuffer(c,\"\",0);\n        else\n            addReplyBulk(c,c->argv[1]);\n    } else {\n        if (c->argc == 1)\n            addReply(c,shared.pong);\n        else\n            addReplyBulk(c,c->argv[1]);\n    }\n}", "path": "AnnotatedCode/redis-5.0/src/server.c", "commit_date": "2019-12-27 00:00:00", "repo_name": "chenyahui/AnnotatedCode", "stars": 1336, "license": "None", "language": "c", "size": 7553}
{"docstring": "/* Our hash table implementation performs rehashing incrementally while\n * we write/read from the hash table. Still if the server is idle, the hash\n * table will use two tables for a long time. So we try to use 1 millisecond\n * of CPU time at every call of this function to perform some rehahsing.\n *\n * The function returns 1 if some rehashing was performed, otherwise 0\n * is returned. */\n", "func_signal": "int incrementallyRehash(int dbid)", "code": "{\n    /* Keys dictionary */\n    if (dictIsRehashing(server.db[dbid].dict)) {\n        dictRehashMilliseconds(server.db[dbid].dict,1);\n        return 1; /* already used our millisecond for this loop... */\n    }\n    /* Expires */\n    if (dictIsRehashing(server.db[dbid].expires)) {\n        dictRehashMilliseconds(server.db[dbid].expires,1);\n        return 1; /* already used our millisecond for this loop... */\n    }\n    return 0;\n}", "path": "AnnotatedCode/redis-5.0/src/server.c", "commit_date": "2019-12-27 00:00:00", "repo_name": "chenyahui/AnnotatedCode", "stars": 1336, "license": "None", "language": "c", "size": 7553}
{"docstring": "/* Return the mean of all the samples. */\n", "func_signal": "long long getInstantaneousMetric(int metric)", "code": "{\n    int j;\n    long long sum = 0;\n\n    for (j = 0; j < STATS_METRIC_SAMPLES; j++)\n        sum += server.inst_metric[metric].samples[j];\n    return sum / STATS_METRIC_SAMPLES;\n}", "path": "AnnotatedCode/redis-5.0/src/server.c", "commit_date": "2019-12-27 00:00:00", "repo_name": "chenyahui/AnnotatedCode", "stars": 1336, "license": "None", "language": "c", "size": 7553}
{"docstring": "/* This function is called immadiately after the event loop multiplexing\n * API returned, and the control is going to soon return to Redis by invoking\n * the different events callbacks. */\n", "func_signal": "void afterSleep(struct aeEventLoop *eventLoop)", "code": "{\n    UNUSED(eventLoop);\n    if (moduleCount()) moduleAcquireGIL();\n}", "path": "AnnotatedCode/redis-5.0/src/server.c", "commit_date": "2019-12-27 00:00:00", "repo_name": "chenyahui/AnnotatedCode", "stars": 1336, "license": "None", "language": "c", "size": 7553}
{"docstring": "/* It is possible to call the function forceCommandPropagation() inside a\n * Redis command implementation in order to to force the propagation of a\n * specific command execution into AOF / Replication. */\n", "func_signal": "void forceCommandPropagation(client *c, int flags)", "code": "{\n    if (flags & PROPAGATE_REPL) c->flags |= CLIENT_FORCE_REPL;\n    if (flags & PROPAGATE_AOF) c->flags |= CLIENT_FORCE_AOF;\n}", "path": "AnnotatedCode/redis-5.0/src/server.c", "commit_date": "2019-12-27 00:00:00", "repo_name": "chenyahui/AnnotatedCode", "stars": 1336, "license": "None", "language": "c", "size": 7553}
{"docstring": "/* Propagate the specified command (in the context of the specified database id)\n * to AOF and Slaves.\n *\n * flags are an xor between:\n * + PROPAGATE_NONE (no propagation of command at all)\n * + PROPAGATE_AOF (propagate into the AOF file if is enabled)\n * + PROPAGATE_REPL (propagate into the replication link)\n *\n * This should not be used inside commands implementation. Use instead\n * alsoPropagate(), preventCommandPropagation(), forceCommandPropagation().\n */\n", "func_signal": "void propagate(struct redisCommand *cmd, int dbid, robj **argv, int argc,\n               int flags)", "code": "{\n    if (server.aof_state != AOF_OFF && flags & PROPAGATE_AOF)\n        feedAppendOnlyFile(cmd,dbid,argv,argc);\n    if (flags & PROPAGATE_REPL)\n        replicationFeedSlaves(server.slaves,dbid,argv,argc);\n}", "path": "AnnotatedCode/redis-5.0/src/server.c", "commit_date": "2019-12-27 00:00:00", "repo_name": "chenyahui/AnnotatedCode", "stars": 1336, "license": "None", "language": "c", "size": 7553}
{"docstring": "/* Create the string returned by the INFO command. This is decoupled\n * by the INFO command itself as we need to report the same information\n * on memory corruption problems. */\n", "func_signal": "sds genRedisInfoString(char *section)", "code": "{\n    sds info = sdsempty();\n    time_t uptime = server.unixtime-server.stat_starttime;\n    int j;\n    struct rusage self_ru, c_ru;\n    int allsections = 0, defsections = 0;\n    int sections = 0;\n\n    if (section == NULL) section = \"default\";\n    allsections = strcasecmp(section,\"all\") == 0;\n    defsections = strcasecmp(section,\"default\") == 0;\n\n    getrusage(RUSAGE_SELF, &self_ru);\n    getrusage(RUSAGE_CHILDREN, &c_ru);\n\n    /* Server */\n    if (allsections || defsections || !strcasecmp(section,\"server\")) {\n        static int call_uname = 1;\n        static struct utsname name;\n        char *mode;\n\n        if (server.cluster_enabled) mode = \"cluster\";\n        else if (server.sentinel_mode) mode = \"sentinel\";\n        else mode = \"standalone\";\n\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n\n        if (call_uname) {\n            /* Uname can be slow and is always the same output. Cache it. */\n            uname(&name);\n            call_uname = 0;\n        }\n\n        unsigned int lruclock;\n        atomicGet(server.lruclock,lruclock);\n        info = sdscatprintf(info,\n            \"# Server\\r\\n\"\n            \"redis_version:%s\\r\\n\"\n            \"redis_git_sha1:%s\\r\\n\"\n            \"redis_git_dirty:%d\\r\\n\"\n            \"redis_build_id:%llx\\r\\n\"\n            \"redis_mode:%s\\r\\n\"\n            \"os:%s %s %s\\r\\n\"\n            \"arch_bits:%d\\r\\n\"\n            \"multiplexing_api:%s\\r\\n\"\n            \"atomicvar_api:%s\\r\\n\"\n            \"gcc_version:%d.%d.%d\\r\\n\"\n            \"process_id:%ld\\r\\n\"\n            \"run_id:%s\\r\\n\"\n            \"tcp_port:%d\\r\\n\"\n            \"uptime_in_seconds:%jd\\r\\n\"\n            \"uptime_in_days:%jd\\r\\n\"\n            \"hz:%d\\r\\n\"\n            \"configured_hz:%d\\r\\n\"\n            \"lru_clock:%ld\\r\\n\"\n            \"executable:%s\\r\\n\"\n            \"config_file:%s\\r\\n\",\n            REDIS_VERSION,\n            redisGitSHA1(),\n            strtol(redisGitDirty(),NULL,10) > 0,\n            (unsigned long long) redisBuildId(),\n            mode,\n            name.sysname, name.release, name.machine,\n            server.arch_bits,\n            aeGetApiName(),\n            REDIS_ATOMIC_API,\n#ifdef __GNUC__\n            __GNUC__,__GNUC_MINOR__,__GNUC_PATCHLEVEL__,\n#else\n            0,0,0,\n#endif\n            (long) getpid(),\n            server.runid,\n            server.port,\n            (intmax_t)uptime,\n            (intmax_t)(uptime/(3600*24)),\n            server.hz,\n            server.config_hz,\n            (unsigned long) lruclock,\n            server.executable ? server.executable : \"\",\n            server.configfile ? server.configfile : \"\");\n    }\n\n    /* Clients */\n    if (allsections || defsections || !strcasecmp(section,\"clients\")) {\n        size_t maxin, maxout;\n        getExpansiveClientsInfo(&maxin,&maxout);\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info,\n            \"# Clients\\r\\n\"\n            \"connected_clients:%lu\\r\\n\"\n            \"client_recent_max_input_buffer:%zu\\r\\n\"\n            \"client_recent_max_output_buffer:%zu\\r\\n\"\n            \"blocked_clients:%d\\r\\n\",\n            listLength(server.clients)-listLength(server.slaves),\n            maxin, maxout,\n            server.blocked_clients);\n    }\n\n    /* Memory */\n    if (allsections || defsections || !strcasecmp(section,\"memory\")) {\n        char hmem[64];\n        char peak_hmem[64];\n        char total_system_hmem[64];\n        char used_memory_lua_hmem[64];\n        char used_memory_scripts_hmem[64];\n        char used_memory_rss_hmem[64];\n        char maxmemory_hmem[64];\n        size_t zmalloc_used = zmalloc_used_memory();\n        size_t total_system_mem = server.system_memory_size;\n        const char *evict_policy = evictPolicyToString();\n        long long memory_lua = (long long)lua_gc(server.lua,LUA_GCCOUNT,0)*1024;\n        struct redisMemOverhead *mh = getMemoryOverheadData();\n\n        /* Peak memory is updated from time to time by serverCron() so it\n         * may happen that the instantaneous value is slightly bigger than\n         * the peak value. This may confuse users, so we update the peak\n         * if found smaller than the current memory usage. */\n        if (zmalloc_used > server.stat_peak_memory)\n            server.stat_peak_memory = zmalloc_used;\n\n        bytesToHuman(hmem,zmalloc_used);\n        bytesToHuman(peak_hmem,server.stat_peak_memory);\n        bytesToHuman(total_system_hmem,total_system_mem);\n        bytesToHuman(used_memory_lua_hmem,memory_lua);\n        bytesToHuman(used_memory_scripts_hmem,mh->lua_caches);\n        bytesToHuman(used_memory_rss_hmem,server.cron_malloc_stats.process_rss);\n        bytesToHuman(maxmemory_hmem,server.maxmemory);\n\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info,\n            \"# Memory\\r\\n\"\n            \"used_memory:%zu\\r\\n\"\n            \"used_memory_human:%s\\r\\n\"\n            \"used_memory_rss:%zu\\r\\n\"\n            \"used_memory_rss_human:%s\\r\\n\"\n            \"used_memory_peak:%zu\\r\\n\"\n            \"used_memory_peak_human:%s\\r\\n\"\n            \"used_memory_peak_perc:%.2f%%\\r\\n\"\n            \"used_memory_overhead:%zu\\r\\n\"\n            \"used_memory_startup:%zu\\r\\n\"\n            \"used_memory_dataset:%zu\\r\\n\"\n            \"used_memory_dataset_perc:%.2f%%\\r\\n\"\n            \"allocator_allocated:%zu\\r\\n\"\n            \"allocator_active:%zu\\r\\n\"\n            \"allocator_resident:%zu\\r\\n\"\n            \"total_system_memory:%lu\\r\\n\"\n            \"total_system_memory_human:%s\\r\\n\"\n            \"used_memory_lua:%lld\\r\\n\"\n            \"used_memory_lua_human:%s\\r\\n\"\n            \"used_memory_scripts:%lld\\r\\n\"\n            \"used_memory_scripts_human:%s\\r\\n\"\n            \"number_of_cached_scripts:%lu\\r\\n\"\n            \"maxmemory:%lld\\r\\n\"\n            \"maxmemory_human:%s\\r\\n\"\n            \"maxmemory_policy:%s\\r\\n\"\n            \"allocator_frag_ratio:%.2f\\r\\n\"\n            \"allocator_frag_bytes:%zu\\r\\n\"\n            \"allocator_rss_ratio:%.2f\\r\\n\"\n            \"allocator_rss_bytes:%zd\\r\\n\"\n            \"rss_overhead_ratio:%.2f\\r\\n\"\n            \"rss_overhead_bytes:%zd\\r\\n\"\n            \"mem_fragmentation_ratio:%.2f\\r\\n\"\n            \"mem_fragmentation_bytes:%zd\\r\\n\"\n            \"mem_not_counted_for_evict:%zu\\r\\n\"\n            \"mem_replication_backlog:%zu\\r\\n\"\n            \"mem_clients_slaves:%zu\\r\\n\"\n            \"mem_clients_normal:%zu\\r\\n\"\n            \"mem_aof_buffer:%zu\\r\\n\"\n            \"mem_allocator:%s\\r\\n\"\n            \"active_defrag_running:%d\\r\\n\"\n            \"lazyfree_pending_objects:%zu\\r\\n\",\n            zmalloc_used,\n            hmem,\n            server.cron_malloc_stats.process_rss,\n            used_memory_rss_hmem,\n            server.stat_peak_memory,\n            peak_hmem,\n            mh->peak_perc,\n            mh->overhead_total,\n            mh->startup_allocated,\n            mh->dataset,\n            mh->dataset_perc,\n            server.cron_malloc_stats.allocator_allocated,\n            server.cron_malloc_stats.allocator_active,\n            server.cron_malloc_stats.allocator_resident,\n            (unsigned long)total_system_mem,\n            total_system_hmem,\n            memory_lua,\n            used_memory_lua_hmem,\n            (long long) mh->lua_caches,\n            used_memory_scripts_hmem,\n            dictSize(server.lua_scripts),\n            server.maxmemory,\n            maxmemory_hmem,\n            evict_policy,\n            mh->allocator_frag,\n            mh->allocator_frag_bytes,\n            mh->allocator_rss,\n            mh->allocator_rss_bytes,\n            mh->rss_extra,\n            mh->rss_extra_bytes,\n            mh->total_frag, /* this is the total RSS overhead, including fragmentation, */\n            mh->total_frag_bytes, /* named so for backwards compatibility */\n            freeMemoryGetNotCountedMemory(),\n            mh->repl_backlog,\n            mh->clients_slaves,\n            mh->clients_normal,\n            mh->aof_buffer,\n            ZMALLOC_LIB,\n            server.active_defrag_running,\n            lazyfreeGetPendingObjectsCount()\n        );\n        freeMemoryOverheadData(mh);\n    }\n\n    /* Persistence */\n    if (allsections || defsections || !strcasecmp(section,\"persistence\")) {\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info,\n            \"# Persistence\\r\\n\"\n            \"loading:%d\\r\\n\"\n            \"rdb_changes_since_last_save:%lld\\r\\n\"\n            \"rdb_bgsave_in_progress:%d\\r\\n\"\n            \"rdb_last_save_time:%jd\\r\\n\"\n            \"rdb_last_bgsave_status:%s\\r\\n\"\n            \"rdb_last_bgsave_time_sec:%jd\\r\\n\"\n            \"rdb_current_bgsave_time_sec:%jd\\r\\n\"\n            \"rdb_last_cow_size:%zu\\r\\n\"\n            \"aof_enabled:%d\\r\\n\"\n            \"aof_rewrite_in_progress:%d\\r\\n\"\n            \"aof_rewrite_scheduled:%d\\r\\n\"\n            \"aof_last_rewrite_time_sec:%jd\\r\\n\"\n            \"aof_current_rewrite_time_sec:%jd\\r\\n\"\n            \"aof_last_bgrewrite_status:%s\\r\\n\"\n            \"aof_last_write_status:%s\\r\\n\"\n            \"aof_last_cow_size:%zu\\r\\n\",\n            server.loading,\n            server.dirty,\n            server.rdb_child_pid != -1,\n            (intmax_t)server.lastsave,\n            (server.lastbgsave_status == C_OK) ? \"ok\" : \"err\",\n            (intmax_t)server.rdb_save_time_last,\n            (intmax_t)((server.rdb_child_pid == -1) ?\n                -1 : time(NULL)-server.rdb_save_time_start),\n            server.stat_rdb_cow_bytes,\n            server.aof_state != AOF_OFF,\n            server.aof_child_pid != -1,\n            server.aof_rewrite_scheduled,\n            (intmax_t)server.aof_rewrite_time_last,\n            (intmax_t)((server.aof_child_pid == -1) ?\n                -1 : time(NULL)-server.aof_rewrite_time_start),\n            (server.aof_lastbgrewrite_status == C_OK) ? \"ok\" : \"err\",\n            (server.aof_last_write_status == C_OK) ? \"ok\" : \"err\",\n            server.stat_aof_cow_bytes);\n\n        if (server.aof_state != AOF_OFF) {\n            info = sdscatprintf(info,\n                \"aof_current_size:%lld\\r\\n\"\n                \"aof_base_size:%lld\\r\\n\"\n                \"aof_pending_rewrite:%d\\r\\n\"\n                \"aof_buffer_length:%zu\\r\\n\"\n                \"aof_rewrite_buffer_length:%lu\\r\\n\"\n                \"aof_pending_bio_fsync:%llu\\r\\n\"\n                \"aof_delayed_fsync:%lu\\r\\n\",\n                (long long) server.aof_current_size,\n                (long long) server.aof_rewrite_base_size,\n                server.aof_rewrite_scheduled,\n                sdslen(server.aof_buf),\n                aofRewriteBufferSize(),\n                bioPendingJobsOfType(BIO_AOF_FSYNC),\n                server.aof_delayed_fsync);\n        }\n\n        if (server.loading) {\n            double perc;\n            time_t eta, elapsed;\n            off_t remaining_bytes = server.loading_total_bytes-\n                                    server.loading_loaded_bytes;\n\n            perc = ((double)server.loading_loaded_bytes /\n                   (server.loading_total_bytes+1)) * 100;\n\n            elapsed = time(NULL)-server.loading_start_time;\n            if (elapsed == 0) {\n                eta = 1; /* A fake 1 second figure if we don't have\n                            enough info */\n            } else {\n                eta = (elapsed*remaining_bytes)/(server.loading_loaded_bytes+1);\n            }\n\n            info = sdscatprintf(info,\n                \"loading_start_time:%jd\\r\\n\"\n                \"loading_total_bytes:%llu\\r\\n\"\n                \"loading_loaded_bytes:%llu\\r\\n\"\n                \"loading_loaded_perc:%.2f\\r\\n\"\n                \"loading_eta_seconds:%jd\\r\\n\",\n                (intmax_t) server.loading_start_time,\n                (unsigned long long) server.loading_total_bytes,\n                (unsigned long long) server.loading_loaded_bytes,\n                perc,\n                (intmax_t)eta\n            );\n        }\n    }\n\n    /* Stats */\n    if (allsections || defsections || !strcasecmp(section,\"stats\")) {\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info,\n            \"# Stats\\r\\n\"\n            \"total_connections_received:%lld\\r\\n\"\n            \"total_commands_processed:%lld\\r\\n\"\n            \"instantaneous_ops_per_sec:%lld\\r\\n\"\n            \"total_net_input_bytes:%lld\\r\\n\"\n            \"total_net_output_bytes:%lld\\r\\n\"\n            \"instantaneous_input_kbps:%.2f\\r\\n\"\n            \"instantaneous_output_kbps:%.2f\\r\\n\"\n            \"rejected_connections:%lld\\r\\n\"\n            \"sync_full:%lld\\r\\n\"\n            \"sync_partial_ok:%lld\\r\\n\"\n            \"sync_partial_err:%lld\\r\\n\"\n            \"expired_keys:%lld\\r\\n\"\n            \"expired_stale_perc:%.2f\\r\\n\"\n            \"expired_time_cap_reached_count:%lld\\r\\n\"\n            \"evicted_keys:%lld\\r\\n\"\n            \"keyspace_hits:%lld\\r\\n\"\n            \"keyspace_misses:%lld\\r\\n\"\n            \"pubsub_channels:%ld\\r\\n\"\n            \"pubsub_patterns:%lu\\r\\n\"\n            \"latest_fork_usec:%lld\\r\\n\"\n            \"migrate_cached_sockets:%ld\\r\\n\"\n            \"slave_expires_tracked_keys:%zu\\r\\n\"\n            \"active_defrag_hits:%lld\\r\\n\"\n            \"active_defrag_misses:%lld\\r\\n\"\n            \"active_defrag_key_hits:%lld\\r\\n\"\n            \"active_defrag_key_misses:%lld\\r\\n\",\n            server.stat_numconnections,\n            server.stat_numcommands,\n            getInstantaneousMetric(STATS_METRIC_COMMAND),\n            server.stat_net_input_bytes,\n            server.stat_net_output_bytes,\n            (float)getInstantaneousMetric(STATS_METRIC_NET_INPUT)/1024,\n            (float)getInstantaneousMetric(STATS_METRIC_NET_OUTPUT)/1024,\n            server.stat_rejected_conn,\n            server.stat_sync_full,\n            server.stat_sync_partial_ok,\n            server.stat_sync_partial_err,\n            server.stat_expiredkeys,\n            server.stat_expired_stale_perc*100,\n            server.stat_expired_time_cap_reached_count,\n            server.stat_evictedkeys,\n            server.stat_keyspace_hits,\n            server.stat_keyspace_misses,\n            dictSize(server.pubsub_channels),\n            listLength(server.pubsub_patterns),\n            server.stat_fork_time,\n            dictSize(server.migrate_cached_sockets),\n            getSlaveKeyWithExpireCount(),\n            server.stat_active_defrag_hits,\n            server.stat_active_defrag_misses,\n            server.stat_active_defrag_key_hits,\n            server.stat_active_defrag_key_misses);\n    }\n\n    /* Replication */\n    if (allsections || defsections || !strcasecmp(section,\"replication\")) {\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info,\n            \"# Replication\\r\\n\"\n            \"role:%s\\r\\n\",\n            server.masterhost == NULL ? \"master\" : \"slave\");\n        if (server.masterhost) {\n            long long slave_repl_offset = 1;\n\n            if (server.master)\n                slave_repl_offset = server.master->reploff;\n            else if (server.cached_master)\n                slave_repl_offset = server.cached_master->reploff;\n\n            info = sdscatprintf(info,\n                \"master_host:%s\\r\\n\"\n                \"master_port:%d\\r\\n\"\n                \"master_link_status:%s\\r\\n\"\n                \"master_last_io_seconds_ago:%d\\r\\n\"\n                \"master_sync_in_progress:%d\\r\\n\"\n                \"slave_repl_offset:%lld\\r\\n\"\n                ,server.masterhost,\n                server.masterport,\n                (server.repl_state == REPL_STATE_CONNECTED) ?\n                    \"up\" : \"down\",\n                server.master ?\n                ((int)(server.unixtime-server.master->lastinteraction)) : -1,\n                server.repl_state == REPL_STATE_TRANSFER,\n                slave_repl_offset\n            );\n\n            if (server.repl_state == REPL_STATE_TRANSFER) {\n                info = sdscatprintf(info,\n                    \"master_sync_left_bytes:%lld\\r\\n\"\n                    \"master_sync_last_io_seconds_ago:%d\\r\\n\"\n                    , (long long)\n                        (server.repl_transfer_size - server.repl_transfer_read),\n                    (int)(server.unixtime-server.repl_transfer_lastio)\n                );\n            }\n\n            if (server.repl_state != REPL_STATE_CONNECTED) {\n                info = sdscatprintf(info,\n                    \"master_link_down_since_seconds:%jd\\r\\n\",\n                    (intmax_t)server.unixtime-server.repl_down_since);\n            }\n            info = sdscatprintf(info,\n                \"slave_priority:%d\\r\\n\"\n                \"slave_read_only:%d\\r\\n\",\n                server.slave_priority,\n                server.repl_slave_ro);\n        }\n\n        info = sdscatprintf(info,\n            \"connected_slaves:%lu\\r\\n\",\n            listLength(server.slaves));\n\n        /* If min-slaves-to-write is active, write the number of slaves\n         * currently considered 'good'. */\n        if (server.repl_min_slaves_to_write &&\n            server.repl_min_slaves_max_lag) {\n            info = sdscatprintf(info,\n                \"min_slaves_good_slaves:%d\\r\\n\",\n                server.repl_good_slaves_count);\n        }\n\n        if (listLength(server.slaves)) {\n            int slaveid = 0;\n            listNode *ln;\n            listIter li;\n\n            listRewind(server.slaves,&li);\n            while((ln = listNext(&li))) {\n                client *slave = listNodeValue(ln);\n                char *state = NULL;\n                char ip[NET_IP_STR_LEN], *slaveip = slave->slave_ip;\n                int port;\n                long lag = 0;\n\n                if (slaveip[0] == '\\0') {\n                    if (anetPeerToString(slave->fd,ip,sizeof(ip),&port) == -1)\n                        continue;\n                    slaveip = ip;\n                }\n                switch(slave->replstate) {\n                case SLAVE_STATE_WAIT_BGSAVE_START:\n                case SLAVE_STATE_WAIT_BGSAVE_END:\n                    state = \"wait_bgsave\";\n                    break;\n                case SLAVE_STATE_SEND_BULK:\n                    state = \"send_bulk\";\n                    break;\n                case SLAVE_STATE_ONLINE:\n                    state = \"online\";\n                    break;\n                }\n                if (state == NULL) continue;\n                if (slave->replstate == SLAVE_STATE_ONLINE)\n                    lag = time(NULL) - slave->repl_ack_time;\n\n                info = sdscatprintf(info,\n                    \"slave%d:ip=%s,port=%d,state=%s,\"\n                    \"offset=%lld,lag=%ld\\r\\n\",\n                    slaveid,slaveip,slave->slave_listening_port,state,\n                    slave->repl_ack_off, lag);\n                slaveid++;\n            }\n        }\n        info = sdscatprintf(info,\n            \"master_replid:%s\\r\\n\"\n            \"master_replid2:%s\\r\\n\"\n            \"master_repl_offset:%lld\\r\\n\"\n            \"second_repl_offset:%lld\\r\\n\"\n            \"repl_backlog_active:%d\\r\\n\"\n            \"repl_backlog_size:%lld\\r\\n\"\n            \"repl_backlog_first_byte_offset:%lld\\r\\n\"\n            \"repl_backlog_histlen:%lld\\r\\n\",\n            server.replid,\n            server.replid2,\n            server.master_repl_offset,\n            server.second_replid_offset,\n            server.repl_backlog != NULL,\n            server.repl_backlog_size,\n            server.repl_backlog_off,\n            server.repl_backlog_histlen);\n    }\n\n    /* CPU */\n    if (allsections || defsections || !strcasecmp(section,\"cpu\")) {\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info,\n        \"# CPU\\r\\n\"\n        \"used_cpu_sys:%ld.%06ld\\r\\n\"\n        \"used_cpu_user:%ld.%06ld\\r\\n\"\n        \"used_cpu_sys_children:%ld.%06ld\\r\\n\"\n        \"used_cpu_user_children:%ld.%06ld\\r\\n\",\n        (long)self_ru.ru_stime.tv_sec, (long)self_ru.ru_stime.tv_usec,\n        (long)self_ru.ru_utime.tv_sec, (long)self_ru.ru_utime.tv_usec,\n        (long)c_ru.ru_stime.tv_sec, (long)c_ru.ru_stime.tv_usec,\n        (long)c_ru.ru_utime.tv_sec, (long)c_ru.ru_utime.tv_usec);\n    }\n\n    /* Command statistics */\n    if (allsections || !strcasecmp(section,\"commandstats\")) {\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info, \"# Commandstats\\r\\n\");\n\n        struct redisCommand *c;\n        dictEntry *de;\n        dictIterator *di;\n        di = dictGetSafeIterator(server.commands);\n        while((de = dictNext(di)) != NULL) {\n            c = (struct redisCommand *) dictGetVal(de);\n            if (!c->calls) continue;\n            info = sdscatprintf(info,\n                \"cmdstat_%s:calls=%lld,usec=%lld,usec_per_call=%.2f\\r\\n\",\n                c->name, c->calls, c->microseconds,\n                (c->calls == 0) ? 0 : ((float)c->microseconds/c->calls));\n        }\n        dictReleaseIterator(di);\n    }\n\n    /* Cluster */\n    if (allsections || defsections || !strcasecmp(section,\"cluster\")) {\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info,\n        \"# Cluster\\r\\n\"\n        \"cluster_enabled:%d\\r\\n\",\n        server.cluster_enabled);\n    }\n\n    /* Key space */\n    if (allsections || defsections || !strcasecmp(section,\"keyspace\")) {\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info, \"# Keyspace\\r\\n\");\n        for (j = 0; j < server.dbnum; j++) {\n            long long keys, vkeys;\n\n            keys = dictSize(server.db[j].dict);\n            vkeys = dictSize(server.db[j].expires);\n            if (keys || vkeys) {\n                info = sdscatprintf(info,\n                    \"db%d:keys=%lld,expires=%lld,avg_ttl=%lld\\r\\n\",\n                    j, keys, vkeys, server.db[j].avg_ttl);\n            }\n        }\n    }\n    return info;\n}", "path": "AnnotatedCode/redis-5.0/src/server.c", "commit_date": "2019-12-27 00:00:00", "repo_name": "chenyahui/AnnotatedCode", "stars": 1336, "license": "None", "language": "c", "size": 7553}
{"docstring": "/* Populates the Redis Command Table starting from the hard coded list\n * we have on top of redis.c file. */\n// \u5c06redis\u652f\u6301\u7684\u547d\u4ee4\u653e\u5165server.commands\n", "func_signal": "void populateCommandTable(void)", "code": "{\n    int j;\n    int numcommands = sizeof(redisCommandTable)/sizeof(struct redisCommand);\n\n    for (j = 0; j < numcommands; j++) {\n        struct redisCommand *c = redisCommandTable+j;\n        char *f = c->sflags;\n        int retval1, retval2;\n\n        while(*f != '\\0') {\n            switch(*f) {\n            case 'w': c->flags |= CMD_WRITE; break;\n            case 'r': c->flags |= CMD_READONLY; break;\n            case 'm': c->flags |= CMD_DENYOOM; break;\n            case 'a': c->flags |= CMD_ADMIN; break;\n            case 'p': c->flags |= CMD_PUBSUB; break;\n            case 's': c->flags |= CMD_NOSCRIPT; break;\n            case 'R': c->flags |= CMD_RANDOM; break;\n            case 'S': c->flags |= CMD_SORT_FOR_SCRIPT; break;\n            case 'l': c->flags |= CMD_LOADING; break;\n            case 't': c->flags |= CMD_STALE; break;\n            case 'M': c->flags |= CMD_SKIP_MONITOR; break;\n            case 'k': c->flags |= CMD_ASKING; break;\n            case 'F': c->flags |= CMD_FAST; break;\n            default: serverPanic(\"Unsupported command flag\"); break;\n            }\n            f++;\n        }\n\n        retval1 = dictAdd(server.commands, sdsnew(c->name), c);\n        /* Populate an additional dictionary that will be unaffected\n         * by rename-command statements in redis.conf. */\n        retval2 = dictAdd(server.orig_commands, sdsnew(c->name), c);\n        serverAssert(retval1 == DICT_OK && retval2 == DICT_OK);\n    }\n}", "path": "AnnotatedCode/redis-5.0/src/server.c", "commit_date": "2019-12-27 00:00:00", "repo_name": "chenyahui/AnnotatedCode", "stars": 1336, "license": "None", "language": "c", "size": 7553}
{"docstring": "/* This function handles 'background' operations we are required to do\n * incrementally in Redis databases, such as active key expiring, resizing,\n * rehashing. */\n", "func_signal": "void databasesCron(void)", "code": "{\n    /* Expire keys by random sampling. Not required for slaves\n     * as master will synthesize DELs for us. */\n    if (server.active_expire_enabled) {\n        if (server.masterhost == NULL) {\n            activeExpireCycle(ACTIVE_EXPIRE_CYCLE_SLOW);\n        } else {\n            expireSlaveKeys();\n        }\n    }\n\n    /* Defrag keys gradually. */\n    if (server.active_defrag_enabled)\n        activeDefragCycle();\n\n    /* Perform hash tables rehashing if needed, but only if there are no\n     * other processes saving the DB on disk. Otherwise rehashing is bad\n     * as will cause a lot of copy-on-write of memory pages. */\n    if (server.rdb_child_pid == -1 && server.aof_child_pid == -1) {\n        /* We use global counters so if we stop the computation at a given\n         * DB we'll be able to start from the successive in the next\n         * cron loop iteration. */\n        static unsigned int resize_db = 0;\n        static unsigned int rehash_db = 0;\n        int dbs_per_call = CRON_DBS_PER_CALL;\n        int j;\n\n        /* Don't test more DBs than we have. */\n        if (dbs_per_call > server.dbnum) dbs_per_call = server.dbnum;\n\n        /* Resize */\n        for (j = 0; j < dbs_per_call; j++) {\n            tryResizeHashTables(resize_db % server.dbnum);\n            resize_db++;\n        }\n\n        /* Rehash */\n        if (server.activerehashing) {\n            for (j = 0; j < dbs_per_call; j++) {\n                int work_done = incrementallyRehash(rehash_db);\n                if (work_done) {\n                    /* If the function did some work, stop here, we'll do\n                     * more at the next cron loop. */\n                    break;\n                } else {\n                    /* If this db didn't need rehash, we'll try the next one. */\n                    rehash_db++;\n                    rehash_db %= server.dbnum;\n                }\n            }\n        }\n    }\n}", "path": "AnnotatedCode/redis-5.0/src/server.c", "commit_date": "2019-12-27 00:00:00", "repo_name": "chenyahui/AnnotatedCode", "stars": 1336, "license": "None", "language": "c", "size": 7553}
{"docstring": "/* Resets the stats that we expose via INFO or other means that we want\n * to reset via CONFIG RESETSTAT. The function is also used in order to\n * initialize these fields in initServer() at server startup. */\n", "func_signal": "void resetServerStats(void)", "code": "{\n    int j;\n\n    server.stat_numcommands = 0;\n    server.stat_numconnections = 0;\n    server.stat_expiredkeys = 0;\n    server.stat_expired_stale_perc = 0;\n    server.stat_expired_time_cap_reached_count = 0;\n    server.stat_evictedkeys = 0;\n    server.stat_keyspace_misses = 0;\n    server.stat_keyspace_hits = 0;\n    server.stat_active_defrag_hits = 0;\n    server.stat_active_defrag_misses = 0;\n    server.stat_active_defrag_key_hits = 0;\n    server.stat_active_defrag_key_misses = 0;\n    server.stat_active_defrag_scanned = 0;\n    server.stat_fork_time = 0;\n    server.stat_fork_rate = 0;\n    server.stat_rejected_conn = 0;\n    server.stat_sync_full = 0;\n    server.stat_sync_partial_ok = 0;\n    server.stat_sync_partial_err = 0;\n    for (j = 0; j < STATS_METRIC_COUNT; j++) {\n        server.inst_metric[j].idx = 0;\n        server.inst_metric[j].last_sample_time = mstime();\n        server.inst_metric[j].last_sample_count = 0;\n        memset(server.inst_metric[j].samples,0,\n            sizeof(server.inst_metric[j].samples));\n    }\n    server.stat_net_input_bytes = 0;\n    server.stat_net_output_bytes = 0;\n    server.aof_delayed_fsync = 0;\n}", "path": "AnnotatedCode/redis-5.0/src/server.c", "commit_date": "2019-12-27 00:00:00", "repo_name": "chenyahui/AnnotatedCode", "stars": 1336, "license": "None", "language": "c", "size": 7553}
{"docstring": "/* Return the max samples in the memory usage of clients tracked by\n * the function clientsCronTrackExpansiveClients(). */\n", "func_signal": "void getExpansiveClientsInfo(size_t *in_usage, size_t *out_usage)", "code": "{\n    size_t i = 0, o = 0;\n    for (int j = 0; j < CLIENTS_PEAK_MEM_USAGE_SLOTS; j++) {\n        if (ClientsPeakMemInput[j] > i) i = ClientsPeakMemInput[j];\n        if (ClientsPeakMemOutput[j] > o) o = ClientsPeakMemOutput[j];\n    }\n    *in_usage = i;\n    *out_usage = o;\n}", "path": "AnnotatedCode/redis-5.0/src/server.c", "commit_date": "2019-12-27 00:00:00", "repo_name": "chenyahui/AnnotatedCode", "stars": 1336, "license": "None", "language": "c", "size": 7553}
{"docstring": "/* =========================== Server initialization ======================== */\n", "func_signal": "void createSharedObjects(void)", "code": "{\n    int j;\n\n    shared.crlf = createObject(OBJ_STRING,sdsnew(\"\\r\\n\"));\n    shared.ok = createObject(OBJ_STRING,sdsnew(\"+OK\\r\\n\"));\n    shared.err = createObject(OBJ_STRING,sdsnew(\"-ERR\\r\\n\"));\n    shared.emptybulk = createObject(OBJ_STRING,sdsnew(\"$0\\r\\n\\r\\n\"));\n    shared.czero = createObject(OBJ_STRING,sdsnew(\":0\\r\\n\"));\n    shared.cone = createObject(OBJ_STRING,sdsnew(\":1\\r\\n\"));\n    shared.cnegone = createObject(OBJ_STRING,sdsnew(\":-1\\r\\n\"));\n    shared.nullbulk = createObject(OBJ_STRING,sdsnew(\"$-1\\r\\n\"));\n    shared.nullmultibulk = createObject(OBJ_STRING,sdsnew(\"*-1\\r\\n\"));\n    shared.emptymultibulk = createObject(OBJ_STRING,sdsnew(\"*0\\r\\n\"));\n    shared.pong = createObject(OBJ_STRING,sdsnew(\"+PONG\\r\\n\"));\n    shared.queued = createObject(OBJ_STRING,sdsnew(\"+QUEUED\\r\\n\"));\n    shared.emptyscan = createObject(OBJ_STRING,sdsnew(\"*2\\r\\n$1\\r\\n0\\r\\n*0\\r\\n\"));\n    shared.wrongtypeerr = createObject(OBJ_STRING,sdsnew(\n        \"-WRONGTYPE Operation against a key holding the wrong kind of value\\r\\n\"));\n    shared.nokeyerr = createObject(OBJ_STRING,sdsnew(\n        \"-ERR no such key\\r\\n\"));\n    shared.syntaxerr = createObject(OBJ_STRING,sdsnew(\n        \"-ERR syntax error\\r\\n\"));\n    shared.sameobjecterr = createObject(OBJ_STRING,sdsnew(\n        \"-ERR source and destination objects are the same\\r\\n\"));\n    shared.outofrangeerr = createObject(OBJ_STRING,sdsnew(\n        \"-ERR index out of range\\r\\n\"));\n    shared.noscripterr = createObject(OBJ_STRING,sdsnew(\n        \"-NOSCRIPT No matching script. Please use EVAL.\\r\\n\"));\n    shared.loadingerr = createObject(OBJ_STRING,sdsnew(\n        \"-LOADING Redis is loading the dataset in memory\\r\\n\"));\n    shared.slowscripterr = createObject(OBJ_STRING,sdsnew(\n        \"-BUSY Redis is busy running a script. You can only call SCRIPT KILL or SHUTDOWN NOSAVE.\\r\\n\"));\n    shared.masterdownerr = createObject(OBJ_STRING,sdsnew(\n        \"-MASTERDOWN Link with MASTER is down and replica-serve-stale-data is set to 'no'.\\r\\n\"));\n    shared.bgsaveerr = createObject(OBJ_STRING,sdsnew(\n        \"-MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. Commands that may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.\\r\\n\"));\n    shared.roslaveerr = createObject(OBJ_STRING,sdsnew(\n        \"-READONLY You can't write against a read only replica.\\r\\n\"));\n    shared.noautherr = createObject(OBJ_STRING,sdsnew(\n        \"-NOAUTH Authentication required.\\r\\n\"));\n    shared.oomerr = createObject(OBJ_STRING,sdsnew(\n        \"-OOM command not allowed when used memory > 'maxmemory'.\\r\\n\"));\n    shared.execaborterr = createObject(OBJ_STRING,sdsnew(\n        \"-EXECABORT Transaction discarded because of previous errors.\\r\\n\"));\n    shared.noreplicaserr = createObject(OBJ_STRING,sdsnew(\n        \"-NOREPLICAS Not enough good replicas to write.\\r\\n\"));\n    shared.busykeyerr = createObject(OBJ_STRING,sdsnew(\n        \"-BUSYKEY Target key name already exists.\\r\\n\"));\n    shared.space = createObject(OBJ_STRING,sdsnew(\" \"));\n    shared.colon = createObject(OBJ_STRING,sdsnew(\":\"));\n    shared.plus = createObject(OBJ_STRING,sdsnew(\"+\"));\n\n    for (j = 0; j < PROTO_SHARED_SELECT_CMDS; j++) {\n        char dictid_str[64];\n        int dictid_len;\n\n        dictid_len = ll2string(dictid_str,sizeof(dictid_str),j);\n        shared.select[j] = createObject(OBJ_STRING,\n            sdscatprintf(sdsempty(),\n                \"*2\\r\\n$6\\r\\nSELECT\\r\\n$%d\\r\\n%s\\r\\n\",\n                dictid_len, dictid_str));\n    }\n    shared.messagebulk = createStringObject(\"$7\\r\\nmessage\\r\\n\",13);\n    shared.pmessagebulk = createStringObject(\"$8\\r\\npmessage\\r\\n\",14);\n    shared.subscribebulk = createStringObject(\"$9\\r\\nsubscribe\\r\\n\",15);\n    shared.unsubscribebulk = createStringObject(\"$11\\r\\nunsubscribe\\r\\n\",18);\n    shared.psubscribebulk = createStringObject(\"$10\\r\\npsubscribe\\r\\n\",17);\n    shared.punsubscribebulk = createStringObject(\"$12\\r\\npunsubscribe\\r\\n\",19);\n    shared.del = createStringObject(\"DEL\",3);\n    shared.unlink = createStringObject(\"UNLINK\",6);\n    shared.rpop = createStringObject(\"RPOP\",4);\n    shared.lpop = createStringObject(\"LPOP\",4);\n    shared.lpush = createStringObject(\"LPUSH\",5);\n    shared.rpoplpush = createStringObject(\"RPOPLPUSH\",9);\n    shared.zpopmin = createStringObject(\"ZPOPMIN\",7);\n    shared.zpopmax = createStringObject(\"ZPOPMAX\",7);\n    for (j = 0; j < OBJ_SHARED_INTEGERS; j++) {\n        shared.integers[j] =\n            makeObjectShared(createObject(OBJ_STRING,(void*)(long)j));\n        shared.integers[j]->encoding = OBJ_ENCODING_INT;\n    }\n    for (j = 0; j < OBJ_SHARED_BULKHDR_LEN; j++) {\n        shared.mbulkhdr[j] = createObject(OBJ_STRING,\n            sdscatprintf(sdsempty(),\"*%d\\r\\n\",j));\n        shared.bulkhdr[j] = createObject(OBJ_STRING,\n            sdscatprintf(sdsempty(),\"$%d\\r\\n\",j));\n    }\n    /* The following two shared objects, minstring and maxstrings, are not\n     * actually used for their value but as a special object meaning\n     * respectively the minimum possible string and the maximum possible\n     * string in string comparisons for the ZRANGEBYLEX command. */\n    shared.minstring = sdsnew(\"minstring\");\n    shared.maxstring = sdsnew(\"maxstring\");\n}", "path": "AnnotatedCode/redis-5.0/src/server.c", "commit_date": "2019-12-27 00:00:00", "repo_name": "chenyahui/AnnotatedCode", "stars": 1336, "license": "None", "language": "c", "size": 7553}
{"docstring": "// \u4e0d\u4f7f\u7528changelist\u7684\u65f6\u5019\u7684epoll_add\n/*\n@base\n@fd\n@old\n@events\n@p\n*/\n", "func_signal": "static int\nepoll_nochangelist_add(struct event_base *base, evutil_socket_t fd,\n    short old, short events, void *p)", "code": "{\n\tstruct event_change ch;\n\tch.fd = fd;\n\tch.old_events = old;\n\tch.read_change = ch.write_change = ch.close_change = 0;\n\n\t// \u5224\u65ad\u8bfb\u5199\u4e8b\u4ef6\u662f\u5426\u9700\u8981\u4fee\u6539, \u4e3a\u4ec0\u4e48\u4f1a\u5bf9ET\u8fdb\u884c\u5355\u72ec\u5224\u65ad\u3002\n\tif (events & EV_WRITE)\n\t{\n\t\tch.write_change = EV_CHANGE_ADD |\n\t\t    (events & EV_ET);\n\t}\n\n\tif (events & EV_READ)\n\t{\n\t\tch.read_change = EV_CHANGE_ADD |\n\t\t\t\t\t(events & EV_ET);\n\t}\n\t\t\n\tif (events & EV_CLOSED)\n\t{\n\t\tch.close_change = EV_CHANGE_ADD |\n\t\t    (events & EV_ET);\n\t}\n    \n\treturn epoll_apply_one_change(base, base->evbase, &ch);\n}", "path": "AnnotatedCode/libevent/epoll.c", "commit_date": "2019-12-13 00:00:00", "repo_name": "chenyahui/AnnotatedCode", "stars": 1336, "license": "None", "language": "c", "size": 7553}
{"docstring": "/* After an RDB dump or AOF rewrite we exit from children using _exit() instead of\n * exit(), because the latter may interact with the same file objects used by\n * the parent process. However if we are testing the coverage normal exit() is\n * used in order to obtain the right coverage information. */\n", "func_signal": "void exitFromChild(int retcode)", "code": "{\n#ifdef COVERAGE_TEST\n    exit(retcode);\n#else\n    _exit(retcode);\n#endif\n}", "path": "AnnotatedCode/redis-5.0/src/server.c", "commit_date": "2019-12-27 00:00:00", "repo_name": "chenyahui/AnnotatedCode", "stars": 1336, "license": "None", "language": "c", "size": 7553}
{"docstring": "/* Check for timeouts. Returns non-zero if the client was terminated.\n * The function gets the current time in milliseconds as argument since\n * it gets called multiple times in a loop, so calling gettimeofday() for\n * each iteration would be costly without any actual gain. */\n", "func_signal": "int clientsCronHandleTimeout(client *c, mstime_t now_ms)", "code": "{\n    time_t now = now_ms/1000;\n\n    if (server.maxidletime &&\n        !(c->flags & CLIENT_SLAVE) &&    /* no timeout for slaves */\n        !(c->flags & CLIENT_MASTER) &&   /* no timeout for masters */\n        !(c->flags & CLIENT_BLOCKED) &&  /* no timeout for BLPOP */\n        !(c->flags & CLIENT_PUBSUB) &&   /* no timeout for Pub/Sub clients */\n        (now - c->lastinteraction > server.maxidletime))\n    {\n        serverLog(LL_VERBOSE,\"Closing idle client\");\n        freeClient(c);\n        return 1;\n    } else if (c->flags & CLIENT_BLOCKED) {\n        /* Blocked OPS timeout is handled with milliseconds resolution.\n         * However note that the actual resolution is limited by\n         * server.hz. */\n\n        if (c->bpop.timeout != 0 && c->bpop.timeout < now_ms) {\n            /* Handle blocking operation specific timeout. */\n            replyToBlockedClientTimedOut(c);\n            unblockClient(c);\n        } else if (server.cluster_enabled) {\n            /* Cluster: handle unblock & redirect of clients blocked\n             * into keys no longer served by this server. */\n            if (clusterRedirectBlockedClientIfNeeded(c))\n                unblockClient(c);\n        }\n    }\n    return 0;\n}", "path": "AnnotatedCode/redis-5.0/src/server.c", "commit_date": "2019-12-27 00:00:00", "repo_name": "chenyahui/AnnotatedCode", "stars": 1336, "license": "None", "language": "c", "size": 7553}
{"docstring": "/* Set if time in ms in given */\n", "func_signal": "void setGenericCommand(client *c, int flags, robj *key, robj *val, robj *expire, int unit, robj *ok_reply, robj *abort_reply)", "code": "{\n    long long milliseconds = 0; /* initialized to avoid any harmness warning */\n\n    if (expire) {\n        if (getLongLongFromObjectOrReply(c, expire, &milliseconds, NULL) != C_OK)\n            return;\n        if (milliseconds <= 0) {\n            addReplyErrorFormat(c,\"invalid expire time in %s\",c->cmd->name);\n            return;\n        }\n        if (unit == UNIT_SECONDS) milliseconds *= 1000;\n    }\n\n    if ((flags & OBJ_SET_NX && lookupKeyWrite(c->db,key) != NULL) ||\n        (flags & OBJ_SET_XX && lookupKeyWrite(c->db,key) == NULL))\n    {\n        addReply(c, abort_reply ? abort_reply : shared.nullbulk);\n        return;\n    }\n    setKey(c->db,key,val);\n    server.dirty++;\n    if (expire) setExpire(c,c->db,key,mstime()+milliseconds);\n    notifyKeyspaceEvent(NOTIFY_STRING,\"set\",key,c->db->id);\n    if (expire) notifyKeyspaceEvent(NOTIFY_GENERIC,\n        \"expire\",key,c->db->id);\n    addReply(c, ok_reply ? ok_reply : shared.ok);\n}", "path": "AnnotatedCode/redis-5.0/src/t_string.c", "commit_date": "2019-11-18 00:00:00", "repo_name": "chenyahui/AnnotatedCode", "stars": 1336, "license": "None", "language": "c", "size": 7553}
{"docstring": "/* This function is called once a background process of some kind terminates,\n * as we want to avoid resizing the hash tables when there is a child in order\n * to play well with copy-on-write (otherwise when a resize happens lots of\n * memory pages are copied). The goal of this function is to update the ability\n * for dict.c to resize the hash tables accordingly to the fact we have o not\n * running childs. */\n", "func_signal": "void updateDictResizePolicy(void)", "code": "{\n    if (server.rdb_child_pid == -1 && server.aof_child_pid == -1)\n        dictEnableResize();\n    else\n        dictDisableResize();\n}", "path": "AnnotatedCode/redis-5.0/src/server.c", "commit_date": "2019-12-27 00:00:00", "repo_name": "chenyahui/AnnotatedCode", "stars": 1336, "license": "None", "language": "c", "size": 7553}
{"docstring": "/* Lookup the command in the current table, if not found also check in\n * the original table containing the original command names unaffected by\n * redis.conf rename-command statement.\n *\n * This is used by functions rewriting the argument vector such as\n * rewriteClientCommandVector() in order to set client->cmd pointer\n * correctly even if the command was renamed. */\n", "func_signal": "struct redisCommand *lookupCommandOrOriginal(sds name)", "code": "{\n    struct redisCommand *cmd = dictFetchValue(server.commands, name);\n\n    if (!cmd) cmd = dictFetchValue(server.orig_commands,name);\n    return cmd;\n}", "path": "AnnotatedCode/redis-5.0/src/server.c", "commit_date": "2019-12-27 00:00:00", "repo_name": "chenyahui/AnnotatedCode", "stars": 1336, "license": "None", "language": "c", "size": 7553}
{"docstring": "/* Return zero if strings are the same, non-zero if they are not.\n * The comparison is performed in a way that prevents an attacker to obtain\n * information about the nature of the strings just monitoring the execution\n * time of the function.\n *\n * Note that limiting the comparison length to strings up to 512 bytes we\n * can avoid leaking any information about the password length and any\n * possible branch misprediction related leak.\n */\n", "func_signal": "int time_independent_strcmp(char *a, char *b)", "code": "{\n    char bufa[CONFIG_AUTHPASS_MAX_LEN], bufb[CONFIG_AUTHPASS_MAX_LEN];\n    /* The above two strlen perform len(a) + len(b) operations where either\n     * a or b are fixed (our password) length, and the difference is only\n     * relative to the length of the user provided string, so no information\n     * leak is possible in the following two lines of code. */\n    unsigned int alen = strlen(a);\n    unsigned int blen = strlen(b);\n    unsigned int j;\n    int diff = 0;\n\n    /* We can't compare strings longer than our static buffers.\n     * Note that this will never pass the first test in practical circumstances\n     * so there is no info leak. */\n    if (alen > sizeof(bufa) || blen > sizeof(bufb)) return 1;\n\n    memset(bufa,0,sizeof(bufa));        /* Constant time. */\n    memset(bufb,0,sizeof(bufb));        /* Constant time. */\n    /* Again the time of the following two copies is proportional to\n     * len(a) + len(b) so no info is leaked. */\n    memcpy(bufa,a,alen);\n    memcpy(bufb,b,blen);\n\n    /* Always compare all the chars in the two buffers without\n     * conditional expressions. */\n    for (j = 0; j < sizeof(bufa); j++) {\n        diff |= (bufa[j] ^ bufb[j]);\n    }\n    /* Length must be equal as well. */\n    diff |= alen ^ blen;\n    return diff; /* If zero strings are the same. */\n}", "path": "AnnotatedCode/redis-5.0/src/server.c", "commit_date": "2019-12-27 00:00:00", "repo_name": "chenyahui/AnnotatedCode", "stars": 1336, "license": "None", "language": "c", "size": 7553}
{"docstring": "// Render a value to text.\n", "func_signal": "static char *print_value(cJSON *item,int depth)", "code": "{\n\tchar *out=0;\n\tswitch (item->type)\n\t{\n\t\tcase cJSON_NULL:\tout=cJSON_strdup(\"null\");\tbreak;\n\t\tcase cJSON_False:\tout=cJSON_strdup(\"false\");break;\n\t\tcase cJSON_True:\tout=cJSON_strdup(\"true\"); break;\n\t\tcase cJSON_Number:\tout=print_number(item);break;\n\t\tcase cJSON_String:\tout=print_string(item);break;\n\t\tcase cJSON_Array:\tout=print_array(item,depth);break;\n\t\tcase cJSON_Object:\tout=print_object(item,depth);break;\n\t}\n\treturn out;\n}", "path": "openwrt-packages/oaf/src/cJSON.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "kiddin9/openwrt-packages", "stars": 1459, "license": "gpl-2.0", "language": "c", "size": 323008}
{"docstring": "// netcall timeout\n", "func_signal": "static void\nngx_netcall_timeout(ngx_event_t *ev)", "code": "{\n    ngx_netcall_ctx_t          *nctx;\n\n    nctx = ev->data;\n\n    if (nctx->ev.timer_set) {\n        ngx_del_timer(&nctx->ev);\n    }\n\n    if (nctx->ev.posted) {\n        ngx_delete_posted_event(&nctx->ev);\n    }\n\n    if (nctx->hcr) {\n        ngx_http_client_detach(nctx->hcr);\n        nctx->handler(nctx, NGX_ERROR);\n        nctx->hcr = NULL;\n    }\n}", "path": "openwrt-packages/luci-app-nginx-pingos/modules/nginx-rtmp-module/ngx_netcall.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "kiddin9/openwrt-packages", "stars": 1459, "license": "gpl-2.0", "language": "c", "size": 323008}
{"docstring": "/*\n * to keep cache locality for left leaf nodes, allocate nodes in following\n * order: node, left subtree, right subtree, inclusive subtree\n */\n", "func_signal": "static ngx_http_dynamic_location_tree_node_t *\nngx_http_dynamic_core_create_locations_tree(ngx_conf_t *cf,\n        ngx_queue_t *locations, size_t prefix)", "code": "{\n    size_t                                  len;\n    ngx_queue_t                            *q, tail;\n    ngx_http_dynamic_location_queue_t      *lq;\n    ngx_http_dynamic_location_tree_node_t  *node;\n\n    q = ngx_queue_middle(locations);\n\n    lq = (ngx_http_dynamic_location_queue_t *) q;\n    len = lq->name->len - prefix;\n\n    node = ngx_palloc(cf->pool,\n                offsetof(ngx_http_dynamic_location_tree_node_t, name) + len);\n    if (node == NULL) {\n        return NULL;\n    }\n\n    node->left = NULL;\n    node->right = NULL;\n    node->tree = NULL;\n    node->exact = lq->exact;\n    node->inclusive = lq->inclusive;\n\n    node->len = (u_char) len;\n    ngx_memcpy(node->name, &lq->name->data[prefix], len);\n\n    ngx_queue_split(locations, q, &tail);\n\n    if (ngx_queue_empty(locations)) {\n        /*\n         * ngx_queue_split() insures that if left part is empty,\n         * then right one is empty too\n         */\n        goto inclusive;\n    }\n\n    node->left = ngx_http_dynamic_core_create_locations_tree(cf, locations,\n                                                             prefix);\n    if (node->left == NULL) {\n        return NULL;\n    }\n\n    ngx_queue_remove(q);\n\n    if (ngx_queue_empty(&tail)) {\n        goto inclusive;\n    }\n\n    node->right = ngx_http_dynamic_core_create_locations_tree(cf, &tail,\n                                                              prefix);\n    if (node->right == NULL) {\n        return NULL;\n    }\n\ninclusive:\n\n    if (ngx_queue_empty(&lq->list)) {\n        return node;\n    }\n\n    node->tree = ngx_http_dynamic_core_create_locations_tree(cf, &lq->list,\n                                                             prefix + len);\n    if (node->tree == NULL) {\n        return NULL;\n    }\n\n    return node;\n}", "path": "openwrt-packages/luci-app-nginx-pingos/modules/nginx-toolkit-module/ngx_http_dynamic.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "kiddin9/openwrt-packages", "stars": 1459, "license": "gpl-2.0", "language": "c", "size": 323008}
{"docstring": "// merge all static pull into ngx_live_relay_static_main_conf_t;\n", "func_signal": "static char *\nngx_live_relay_static_init_main_dconf(ngx_conf_t *cf, void *conf)", "code": "{\n    ngx_live_relay_static_main_conf_t  *rsmcf;\n    ngx_live_relay_static_main_dconf_t *rsmdcf;\n    ngx_core_conf_t                    *ccf;\n    ngx_live_relay_t                   *relay;\n    ngx_live_relay_static_relay_t      *srelay, *old, *sl, *sln, **sll;\n    ngx_live_relay_static_ctx_t        *ctx;\n    ngx_live_relay_ctx_t               *rctx;\n    ngx_map_node_t                     *node;\n    unsigned                            used;\n    char                               *rc;\n    ngx_uint_t                          i, hash;\n\n    rsmdcf = conf;\n    rsmcf = ngx_rtmp_cycle_get_module_main_conf(ngx_cycle,\n                                                ngx_live_relay_static_module);\n    ccf = (ngx_core_conf_t *) ngx_get_conf(ngx_cycle->conf_ctx,\n                                           ngx_core_module);\n\n    used = rsmcf->used? 0: 1;\n    sl = NULL;\n    sll = &sl;\n\n    relay = rsmdcf->pulls.elts;\n    for (i = 0; i < rsmdcf->pulls.nelts; ++i, ++relay) {\n        // should static pull in current process?\n        if (ngx_process == NGX_PROCESS_WORKER) {\n            hash = ngx_hash_key_lc(relay->stream.data, relay->stream.len);\n            if (hash % ccf->worker_processes != ngx_worker) {\n                continue;\n            }\n        }\n\n        // check static pull duplicate\n        node = ngx_map_find(&rsmcf->pulls[used], (intptr_t) &relay->stream);\n        if (node) {\n            rc = \"duplicate static pull\";\n            goto error;\n        }\n\n        srelay = ngx_live_relay_get_static_relay(rsmcf);\n        if (srelay == NULL) {\n            rc = \"get static relay failed\";\n            goto error;\n        }\n        srelay->relay = relay;\n        srelay->node.raw_key = (intptr_t) &relay->stream;\n        ngx_map_insert(&rsmcf->pulls[used], &srelay->node, 0);\n\n        // check static pull is exist\n        node = ngx_map_find(&rsmcf->pulls[rsmcf->used],\n                            (intptr_t) &relay->stream);\n        if (node) {\n            old = (ngx_live_relay_static_relay_t *) node;\n            srelay->session = old->session;\n\n            // link swap static pull\n            *sll = old;\n            sll = &(*sll)->next;\n        }\n    }\n\n    // delete swap static pull from old\n    while (sl) {\n        sln = sl;\n        sl = sl->next;\n        ngx_map_delete(&rsmcf->pulls[rsmcf->used],\n                       (intptr_t) &sln->relay->stream);\n        ngx_live_relay_put_static_relay(rsmcf, sln);\n    }\n\n    // stop deleted static pull\n    node = ngx_map_begin(&rsmcf->pulls[rsmcf->used]);\n    while (node) {\n        srelay = (ngx_live_relay_static_relay_t *) node;\n        node = ngx_map_next(node);\n        ngx_live_relay_put_static_relay(rsmcf, srelay);\n\n        rctx = ngx_rtmp_get_module_ctx(srelay->session, ngx_live_relay_module);\n        rctx->giveup = 1;\n        srelay->session->finalize_reason = NGX_LIVE_NORMAL_CLOSE;\n        ngx_rtmp_finalize_session(srelay->session);\n\n        ngx_map_delete(&rsmcf->pulls[rsmcf->used],\n                       (intptr_t) &srelay->relay->stream);\n    }\n\n    // new static relay\n    node = ngx_map_begin(&rsmcf->pulls[used]);\n    for (; node; node = ngx_map_next(node)) {\n        srelay = (ngx_live_relay_static_relay_t *) node;\n        if (srelay->session == NULL) {\n            ngx_live_relay_static_relay(NULL, srelay);\n        } else {\n            ctx = ngx_rtmp_get_module_ctx(srelay->session,\n                                          ngx_live_relay_static_module);\n            ctx->relay = srelay;\n        }\n    }\n\n    rsmcf->used = used;\n\n    return NGX_CONF_OK;\n\nerror:\n    // recycle static relay resource\n    node = ngx_map_begin(&rsmcf->pulls[used]);\n    while (node) {\n        srelay = (ngx_live_relay_static_relay_t *) node;\n        node = ngx_map_next(node);\n        ngx_live_relay_put_static_relay(rsmcf, srelay);\n\n        ngx_map_delete(&rsmcf->pulls[used],\n                       (intptr_t) &srelay->relay->stream);\n    }\n\n    return rc;\n}", "path": "openwrt-packages/luci-app-nginx-pingos/modules/nginx-rtmp-module/ngx_live_relay_static.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "kiddin9/openwrt-packages", "stars": 1459, "license": "gpl-2.0", "language": "c", "size": 323008}
{"docstring": "/* Parse the input text to generate a number, and populate the result into item. */\n", "func_signal": "static const char *parse_number(cJSON *item,const char *num)", "code": "{\n\tint n=0,sign=1,scale=0;int subscale=0,signsubscale=1;\n\n\tif (*num=='-') sign=-1,num++;\t/* Has sign? */\n\tif (*num=='0') num++;\t\t\t/* is zero */\n\tif (*num>='1' && *num<='9')\tdo\tn=(n*10)+(*num++ -'0');\twhile (*num>='0' && *num<='9');\t/* Number? */\n\titem->valueint=(int)n;\n\titem->type=cJSON_Number;\n\treturn num;\n}", "path": "openwrt-packages/oaf/src/cJSON.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "kiddin9/openwrt-packages", "stars": 1459, "license": "gpl-2.0", "language": "c", "size": 323008}
{"docstring": "/*\n * pull reconnect need to trigger ngx_live_pull chain\n */\n", "func_signal": "static ngx_int_t\nngx_live_relay_pull_close(ngx_rtmp_session_t *s)", "code": "{\n    ngx_live_relay_ctx_t       *ctx;\n    ngx_flag_t                  has_player;\n    ngx_rtmp_core_ctx_t        *cctx;;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_live_relay_module);\n\n    has_player = 0;\n\n    if (s->static_pull == 0) {\n        for (cctx = s->live_stream->play_ctx; cctx; cctx = cctx->next) {\n            if (cctx->session->relay == 0) { // has pure player, not relay push\n                has_player = 1;\n                break;\n            }\n        }\n    }\n\n    if (has_player || s->static_pull) { // has player in stream\n        // ctx is NULL, s is a normal publisher\n        // ctx is not NULL, s is a puller, if giveup flag set\n        //      no need to create pull reconnect\n        if (ctx == NULL || !ctx->giveup) {\n            ngx_live_pull(s);\n        }\n    }\n\n    if (ctx && ctx->reconnect.timer_set) {\n        ngx_del_timer(&ctx->reconnect);\n    }\n\n    if (ctx && ctx->reconnect.posted) {\n        ngx_delete_posted_event(&ctx->reconnect);\n    }\n\n    return NGX_OK;\n}", "path": "openwrt-packages/luci-app-nginx-pingos/modules/nginx-rtmp-module/ngx_live_relay.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "kiddin9/openwrt-packages", "stars": 1459, "license": "gpl-2.0", "language": "c", "size": 323008}
{"docstring": "/*\n * access_log off;\n * access_log file;\n * access_log file format_name;\n * access_log file trunc=1m;\n * access_log file format_name trunc=1m;\n */\n", "func_signal": "static char *\nngx_rtmp_log_set_log(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)", "code": "{\n    ngx_rtmp_log_app_conf_t    *lacf = conf;\n\n    ngx_rtmp_log_main_conf_t   *lmcf;\n    ngx_rtmp_log_fmt_t         *fmt;\n    ngx_rtmp_log_t             *log;\n    ngx_str_t                  *value, name, timer;\n    ngx_uint_t                  n;\n    ngx_flag_t                  format_configured;\n\n    name.len = 0;\n    format_configured = 0;\n\n    value = cf->args->elts;\n\n    if (ngx_strcmp(value[1].data, \"off\") == 0) {\n        lacf->off = 1;\n        return NGX_CONF_OK;\n    }\n\n    if (lacf->logs == NULL) {\n        lacf->logs = ngx_array_create(cf->pool, 2, sizeof(ngx_rtmp_log_t));\n        if (lacf->logs == NULL) {\n            return NGX_CONF_ERROR;\n        }\n    }\n\n    log = ngx_array_push(lacf->logs);\n    if (log == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    ngx_memzero(log, sizeof(*log));\n\n    lmcf = ngx_rtmp_conf_get_module_main_conf(cf, ngx_rtmp_log_module);\n\n    log->file = ngx_conf_open_file(cf->cycle, &value[1]);\n    if (log->file == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    for (n = 2; n < cf->args->nelts; ++n) {\n        /* sizeof(\"trunc=\") - 1 = 6 */\n        if (ngx_memcmp(\"trunc=\", value[n].data, 6) == 0) {\n            timer.data = value[n].data + 6;\n            timer.len = value[n].len - 6;\n\n            log->trunc_timer = ngx_parse_time(&timer, 0);\n            if (log->trunc_timer == (ngx_msec_t) NGX_ERROR) {\n                ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n                        \"unknown trunc timer format \\\"%V\\\"\", &timer);\n                return NGX_CONF_ERROR;\n            }\n        } else {\n            if (format_configured) {\n                ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n                        \"format name has been configured\");\n                return NGX_CONF_ERROR;\n            }\n\n            format_configured = 1;\n            name = value[n];\n        }\n    }\n\n    if (name.len == 0) {\n        ngx_str_set(&name, \"combined\");\n        lmcf->combined_used = 1;\n\n    } else {\n        if (ngx_strcmp(name.data, \"combined\") == 0) {\n            lmcf->combined_used = 1;\n        }\n    }\n\n    fmt = lmcf->formats.elts;\n    for (n = 0; n < lmcf->formats.nelts; ++n, ++fmt) {\n        if (fmt->name.len == name.len &&\n            ngx_strncasecmp(fmt->name.data, name.data, name.len) == 0)\n        {\n            log->format = fmt;\n            break;\n        }\n    }\n\n    if (log->format == NULL) {\n        ngx_conf_log_error(NGX_LOG_WARN, cf, 0, \"unknown log format \\\"%V\\\"\",\n                           &name);\n        return NGX_CONF_ERROR;\n    }\n\n    return NGX_CONF_OK;\n}", "path": "openwrt-packages/luci-app-nginx-pingos/modules/nginx-rtmp-module/ngx_rtmp_log_module.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "kiddin9/openwrt-packages", "stars": 1459, "license": "gpl-2.0", "language": "c", "size": 323008}
{"docstring": "//-------------------------------------------------------------------\n//rtl8125_eeprom_type():\n//  tell the eeprom type\n//return value:\n//  0: the eeprom type is 93C46\n//  1: the eeprom type is 93C56 or 93C66\n//-------------------------------------------------------------------\n", "func_signal": "void rtl8125_eeprom_type(struct rtl8125_private *tp)", "code": "{\n        u16 magic = 0;\n\n        if (tp->mcfg == CFG_METHOD_DEFAULT)\n                goto out_no_eeprom;\n\n        if(RTL_R8(tp, 0xD2)&0x04) {\n                //not support\n                //tp->eeprom_type = EEPROM_TWSI;\n                //tp->eeprom_len = 256;\n                goto out_no_eeprom;\n        } else if(RTL_R32(tp, RxConfig) & RxCfg_9356SEL) {\n                tp->eeprom_type = EEPROM_TYPE_93C56;\n                tp->eeprom_len = 256;\n        } else {\n                tp->eeprom_type = EEPROM_TYPE_93C46;\n                tp->eeprom_len = 128;\n        }\n\n        magic = rtl8125_eeprom_read_sc(tp, 0);\n\nout_no_eeprom:\n        if ((magic != 0x8129) && (magic != 0x8128)) {\n                tp->eeprom_type = EEPROM_TYPE_NONE;\n                tp->eeprom_len = 0;\n        }\n}", "path": "openwrt-packages/r8125/src/rtl_eeprom.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "kiddin9/openwrt-packages", "stars": 1459, "license": "gpl-2.0", "language": "c", "size": 323008}
{"docstring": "// Internal constructor.\n", "func_signal": "static cJSON *cJSON_New_Item(void)", "code": "{\n\tcJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));\n\tif (node) memset(node,0,sizeof(cJSON));\n\treturn node;\n}", "path": "openwrt-packages/oaf/src/cJSON.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "kiddin9/openwrt-packages", "stars": 1459, "license": "gpl-2.0", "language": "c", "size": 323008}
{"docstring": "// Render the cstring provided to an escaped version that can be printed.\n", "func_signal": "static char *print_string_ptr(const char *str)", "code": "{\n\tconst char *ptr;char *ptr2,*out;int len=0;\n\t\n\tptr=str;while (*ptr && ++len) {if (*ptr<32 || *ptr=='\\\"' || *ptr=='\\\\') len++;ptr++;}\n\t\n\tout=(char*)cJSON_malloc(len+3);\n\tptr2=out;ptr=str;\n\t*ptr2++='\\\"';\n\twhile (*ptr)\n\t{\n\t\tif (*ptr>31 && *ptr!='\\\"' && *ptr!='\\\\') *ptr2++=*ptr++;\n\t\telse\n\t\t{\n\t\t\t*ptr2++='\\\\';\n\t\t\tswitch (*ptr++)\n\t\t\t{\n\t\t\t\tcase '\\\\':\t*ptr2++='\\\\';\tbreak;\n\t\t\t\tcase '\\\"':\t*ptr2++='\\\"';\tbreak;\n\t\t\t\tcase '\\b':\t*ptr2++='b';\tbreak;\n\t\t\t\tcase '\\f':\t*ptr2++='f';\tbreak;\n\t\t\t\tcase '\\n':\t*ptr2++='n';\tbreak;\n\t\t\t\tcase '\\r':\t*ptr2++='r';\tbreak;\n\t\t\t\tcase '\\t':\t*ptr2++='t';\tbreak;\n\t\t\t\tdefault: ptr2--;\tbreak;\t// eviscerate with prejudice.\n\t\t\t}\n\t\t}\n\t}\n\t*ptr2++='\\\"';*ptr2++=0;\n\treturn out;\n}", "path": "openwrt-packages/oaf/src/cJSON.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "kiddin9/openwrt-packages", "stars": 1459, "license": "gpl-2.0", "language": "c", "size": 323008}
{"docstring": "// only be called when reconnect\n", "func_signal": "static ngx_int_t\nngx_live_relay_static_pull(ngx_rtmp_session_t *s)", "code": "{\n    ngx_live_relay_static_ctx_t        *ctx;\n    ngx_live_relay_ctx_t               *rctx;\n\n    rctx = ngx_rtmp_get_module_ctx(s, ngx_live_relay_module);\n    if (rctx == NULL || rctx->tag != &ngx_live_relay_static_module) {\n        goto next;\n    }\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_live_relay_static_module);\n\n    if (ngx_live_relay_static_relay(s, ctx->relay) == NGX_OK) {\n        return NGX_OK;\n    }\n\nnext:\n    return next_pull(s);\n}", "path": "openwrt-packages/luci-app-nginx-pingos/modules/nginx-rtmp-module/ngx_live_relay_static.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "kiddin9/openwrt-packages", "stars": 1459, "license": "gpl-2.0", "language": "c", "size": 323008}
{"docstring": "/*\n * Hash function from http://www.azillionmonkeys.com/qed/hash.html\n * Copyright (C) 2004-2008 by Paul Hsieh\n */\n", "func_signal": "uint32_t sfh_hash(const char *data, int len)", "code": "{\n\tuint32_t hash = len, tmp;\n\tint rem;\n\n\tif (len <= 0 || data == NULL) return 0;\n\n\trem = len & 3;\n\tlen >>= 2;\n\n\t/* Main loop */\n\tfor (;len > 0; len--) {\n\t\thash  += sfh_get16(data);\n\t\ttmp    = (sfh_get16(data+2) << 11) ^ hash;\n\t\thash   = (hash << 16) ^ tmp;\n\t\tdata  += 2*sizeof(uint16_t);\n\t\thash  += hash >> 11;\n\t}\n\n\t/* Handle end cases */\n\tswitch (rem) {\n\t\tcase 3: hash += sfh_get16(data);\n\t\t\thash ^= hash << 16;\n\t\t\thash ^= data[sizeof(uint16_t)] << 18;\n\t\t\thash += hash >> 11;\n\t\t\tbreak;\n\t\tcase 2: hash += sfh_get16(data);\n\t\t\thash ^= hash << 11;\n\t\t\thash += hash >> 17;\n\t\t\tbreak;\n\t\tcase 1: hash += *data;\n\t\t\thash ^= hash << 10;\n\t\t\thash += hash >> 1;\n\t}\n\n\t/* Force \"avalanching\" of final 127 bits */\n\thash ^= hash << 3;\n\thash += hash >> 5;\n\thash ^= hash << 4;\n\thash += hash >> 17;\n\thash ^= hash << 25;\n\thash += hash >> 6;\n\n\treturn hash;\n}", "path": "openwrt-packages/luci-app-openclash/tools/po2lmo/src/template_lmo.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "kiddin9/openwrt-packages", "stars": 1459, "license": "gpl-2.0", "language": "c", "size": 323008}
{"docstring": "/*\n * NGX_OK       - exact or regex match\n * NGX_AGAIN    - inclusive match\n * NGX_DECLINED - no match\n */\n", "func_signal": "static ngx_int_t\nngx_http_dynamic_core_find_static_location(ngx_http_request_t *r,\n        ngx_http_dynamic_core_loc_conf_t *phdclcf,\n        ngx_http_dynamic_core_loc_conf_t **hdclcf)", "code": "{\n    ngx_http_dynamic_location_tree_node_t  *node;\n    u_char                                 *uri;\n    size_t                                  len, n;\n    ngx_int_t                               rc, rv;\n\n    len = r->uri.len;\n    uri = r->uri.data;\n\n    rv = NGX_DECLINED;\n\n    node = phdclcf->static_locations;\n\n    for ( ;; ) {\n\n        if (node == NULL) {\n            return rv;\n        }\n\n        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                       \"test location: \\\"%*s\\\"\",\n                       (size_t) node->len, node->name);\n\n        n = (len <= (size_t) node->len) ? len : node->len;\n\n        rc = ngx_filename_cmp(uri, node->name, n);\n\n        if (rc != 0) {\n            node = (rc < 0) ? node->left : node->right;\n\n            continue;\n        }\n\n        if (len > (size_t) node->len) {\n\n            if (node->inclusive) {\n\n                *hdclcf = node->inclusive->\n                            loc_conf[ngx_http_dynamic_core_module.ctx_index];\n                rv = NGX_AGAIN;\n\n                node = node->tree;\n                uri += n;\n                len -= n;\n\n                continue;\n            }\n\n            /* exact only */\n\n            node = node->right;\n\n            continue;\n        }\n\n        if (len == (size_t) node->len) {\n\n            if (node->exact) {\n                *hdclcf = node->exact->\n                            loc_conf[ngx_http_dynamic_core_module.ctx_index];\n                return NGX_OK;\n\n            } else {\n                *hdclcf = node->inclusive->\n                            loc_conf[ngx_http_dynamic_core_module.ctx_index];\n                return NGX_AGAIN;\n            }\n        }\n\n        /* len < node->len */\n\n        node = node->left;\n    }\n}", "path": "openwrt-packages/luci-app-nginx-pingos/modules/nginx-toolkit-module/ngx_http_dynamic.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "kiddin9/openwrt-packages", "stars": 1459, "license": "gpl-2.0", "language": "c", "size": 323008}
{"docstring": "//-------------------------------------------------------------------\n//rtl8125_eeprom_read_sc():\n//  read one word from eeprom\n//-------------------------------------------------------------------\n", "func_signal": "u16 rtl8125_eeprom_read_sc(struct rtl8125_private *tp, u16 reg)", "code": "{\n        int addr_sz = 6;\n        u8 x;\n        u16 data;\n\n        if(tp->eeprom_type == EEPROM_TYPE_NONE) {\n                return -1;\n        }\n\n        if (tp->eeprom_type==EEPROM_TYPE_93C46)\n                addr_sz = 6;\n        else if (tp->eeprom_type==EEPROM_TYPE_93C56)\n                addr_sz = 8;\n\n        x = Cfg9346_EEM1 | Cfg9346_EECS;\n        RTL_W8(tp, Cfg9346, x);\n\n        rtl8125_shift_out_bits(tp, RTL_EEPROM_READ_OPCODE, 3);\n        rtl8125_shift_out_bits(tp, reg, addr_sz);\n\n        data = rtl8125_shift_in_bits(tp);\n\n        rtl8125_eeprom_cleanup(tp);\n\n        RTL_W8(tp, Cfg9346, 0);\n\n        return data;\n}", "path": "openwrt-packages/r8125/src/rtl_eeprom.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "kiddin9/openwrt-packages", "stars": 1459, "license": "gpl-2.0", "language": "c", "size": 323008}
{"docstring": "// Render an array to text\n", "func_signal": "static char *print_array(cJSON *item,int depth)", "code": "{\n\tchar *out,*ptr,*ret;int len=5;\n\tcJSON *child=item->child;\n\t\n\tout=(char*)cJSON_malloc(len);*out='[';\n\tptr=out+1;*ptr=0;\n\twhile (child)\n\t{\n\t\tret=print_value(child,depth+1);\n\t\tif (!ret) {cJSON_free(out);return 0;}\t// Check for failure!\n\t\tlen+=strlen(ret)+3;\n\t\tout=(char*)cJSON_realloc(out,len);\n\t\tptr=out+strlen(out);\n\t\tptr+=sprintf(ptr,ret);\n\t\tif (child->next) {*ptr++=',';*ptr++=' ';*ptr=0;}\n\t\tchild=child->next;\n\t\tcJSON_free(ret);\n\t}\n\t*ptr++=']';*ptr++=0;\n\treturn out;\t\n}", "path": "openwrt-packages/oaf/src/cJSON.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "kiddin9/openwrt-packages", "stars": 1459, "license": "gpl-2.0", "language": "c", "size": 323008}
{"docstring": "/* Render the number nicely from the given item into a string. */\n", "func_signal": "static char *print_number(cJSON *item)", "code": "{\n\tchar *str;\n\tstr=(char*)cJSON_malloc(21);\n\tif (str)\n\t\tsprintf(str,\"%d\",item->valueint);\n\treturn str;\n}", "path": "openwrt-packages/oaf/src/cJSON.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "kiddin9/openwrt-packages", "stars": 1459, "license": "gpl-2.0", "language": "c", "size": 323008}
{"docstring": "/* NGX_WIN32 */\n", "func_signal": "static char *\nngx_rtmp_exec_conf(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)", "code": "{\n    char  *p = conf;\n\n    size_t                     n, nargs;\n    ngx_str_t                 *s, *value, v;\n    ngx_array_t               *confs;\n    ngx_rtmp_exec_conf_t      *ec;\n    ngx_rtmp_exec_app_conf_t  *eacf;\n\n    confs = (ngx_array_t *) (p + cmd->offset);\n\n    eacf = ngx_rtmp_conf_get_module_app_conf(cf, ngx_rtmp_exec_module);\n\n    if (confs->nalloc == 0 && ngx_array_init(confs, cf->pool, 1,\n                                             sizeof(ngx_rtmp_exec_conf_t))\n                              != NGX_OK)\n    {\n        return NGX_CONF_ERROR;\n    }\n\n    value = cf->args->elts;\n\n    ec = ngx_array_push(confs);\n    if (ec == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    ngx_memzero(ec, sizeof(ngx_rtmp_exec_conf_t));\n\n    /* type is undefined for explicit execs */\n\n    ec->type = NGX_CONF_UNSET_UINT;\n    ec->cmd = value[1];\n\n    if (ngx_array_init(&ec->names, cf->pool, 1, sizeof(ngx_str_t)) != NGX_OK) {\n        return NGX_CONF_ERROR;\n    }\n\n    if (cf->args->nelts == 2) {\n        return NGX_CONF_OK;\n    }\n\n    nargs = cf->args->nelts - 2;\n    if (ngx_array_init(&ec->args, cf->pool, nargs, sizeof(ngx_str_t)) != NGX_OK)\n    {\n        return NGX_CONF_ERROR;\n    }\n\n    for (n = 2; n < cf->args->nelts; n++) {\n\n        v = value[n];\n\n        if (eacf->options == 1) {\n\n            if (v.len >= 5 && ngx_strncmp(v.data, \"name=\", 5) == 0) {\n\n                s = ngx_array_push(&ec->names);\n                if (s == NULL) {\n                    return NGX_CONF_ERROR;\n                }\n\n                v.data += 5;\n                v.len -= 5;\n\n                *s = v;\n\n                continue;\n            }\n        }\n\n        s = ngx_array_push(&ec->args);\n        if (s == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        *s = v;\n    }\n\n    return NGX_CONF_OK;\n}", "path": "openwrt-packages/luci-app-nginx-pingos/modules/nginx-rtmp-module/ngx_rtmp_exec_module.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "kiddin9/openwrt-packages", "stars": 1459, "license": "gpl-2.0", "language": "c", "size": 323008}
{"docstring": "// Render an object to text.\n", "func_signal": "static char *print_object(cJSON *item,int depth)", "code": "{\n\tchar *out,*ptr,*ret,*str;int len=7,i;\n\tcJSON *child=item->child;\n\t\n\tdepth++;len+=depth;out=(char*)cJSON_malloc(len);*out='{';\n\tptr=out+1;*ptr++='\\n';*ptr=0;\n\twhile (child)\n\t{\n\t\tstr=print_string_ptr(child->string);\n\t\tif (!str) {cJSON_free(out);return 0;}\n\t\tret=print_value(child,depth);\n\t\tif (!ret) {cJSON_free(str);cJSON_free(out);return 0;}\t// Check for failure!\n\t\tlen+=strlen(ret)+strlen(str)+4+depth;\n\t\tout=(char*)cJSON_realloc(out,len);\n\t\tptr=out+strlen(out);\n\t\tfor (i=0;i<depth;i++) *ptr++='\\t';\n\t\tptr+=sprintf(ptr,str);\n\t\t*ptr++=':';*ptr++='\\t';\n\t\tptr+=sprintf(ptr,ret);\n\t\tif (child->next) *ptr++=',';\n\t\t*ptr++='\\n';*ptr=0;\n\t\tchild=child->next;\n\t\tcJSON_free(str);cJSON_free(ret);\n\t}\n\tfor (i=0;i<depth-1;i++) *ptr++='\\t';\n\t*ptr++='}';*ptr++=0;\n\treturn out;\t\n}", "path": "openwrt-packages/oaf/src/cJSON.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "kiddin9/openwrt-packages", "stars": 1459, "license": "gpl-2.0", "language": "c", "size": 323008}
{"docstring": "// Invote print_string_ptr (which is useful) on an item.\n", "func_signal": "static char *print_string(cJSON *item)", "code": "{return print_string_ptr(item->valuestring);}\n\n// Predeclare these prototypes.\nstatic const char *parse_value(cJSON *item,const char *value);\nstatic char *print_value(cJSON *item,int depth);\nstatic const char *parse_array(cJSON *item,const char *value);\nstatic char *print_array(cJSON *item,int depth);\nstatic const char *parse_object(cJSON *item,const char *value);\nstatic char *print_object(cJSON *item,int depth);\n\n// Utility to jump whitespace and cr/lf\nstatic const char *skip(const char *in) {while (in && *in<=32) in++; return in;}\n\n// Parse an object - create a new root, and populate.\ncJSON *cJSON_Parse(const char *value)\n{\n\tcJSON *c=cJSON_New_Item();\n\tif (!c) return 0;       /* memory fail */\n\n\tif (!parse_value(c,skip(value))) {cJSON_Delete(c);return 0;}\n\treturn c;\n}", "path": "openwrt-packages/oaf/src/cJSON.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "kiddin9/openwrt-packages", "stars": 1459, "license": "gpl-2.0", "language": "c", "size": 323008}
{"docstring": "/* interface from here */\n", "func_signal": "void *\nngx_http_get_module_main_dconf(ngx_http_request_t *r, ngx_module_t *m)", "code": "{\n    ngx_http_dynamic_conf_t                *hdcf;\n\n    hdcf = ngx_get_dconf(&ngx_http_dynamic_module);\n    if (hdcf == NULL) {\n        return NULL;\n    }\n\n    return hdcf->main_conf[m->ctx_index];\n}", "path": "openwrt-packages/luci-app-nginx-pingos/modules/nginx-toolkit-module/ngx_http_dynamic.c", "commit_date": "2020-12-14 00:00:00", "repo_name": "kiddin9/openwrt-packages", "stars": 1459, "license": "gpl-2.0", "language": "c", "size": 323008}
{"docstring": "/* djb hash, same as g_str_hash */\n", "func_signal": "static guint\nschema_table_hash(gconstpointer v)", "code": "{\n    const struct schema_table_t *st = v;\n    const signed char *p;\n    guint32 h = 5381;\n\n    for (p = st->schema; *p != '\\0'; p++)\n        h = (h << 5) + h + *p;\n    h = (h << 5) + h + '.';\n    for (p = st->table; *p != '\\0'; p++)\n        h = (h << 5) + h + *p;\n    return h;\n}", "path": "cetus/src/sharding-config.c", "commit_date": "2019-10-18 00:00:00", "repo_name": "session-replay-tools/cetus", "stars": 1242, "license": "gpl-2.0", "language": "c", "size": 9044}
{"docstring": "/* returned list must be freed */\n", "func_signal": "static GList* admin_get_all_options(chassis* chas)", "code": "{\n    GList* options = g_list_copy(chas->options->options); /* shallow copy */\n    return options;\n}", "path": "cetus/plugins/admin/admin-commands.c", "commit_date": "2019-09-30 00:00:00", "repo_name": "session-replay-tools/cetus", "stars": 1242, "license": "gpl-2.0", "language": "c", "size": 9044}
{"docstring": "/* skip some column (lenenc_str or NULL) */\n", "func_signal": "static inline gint\nskip_field(network_packet *packet, guint skip)", "code": "{\n    guint iter;\n\n    for (iter = 0; iter < skip; iter++) {\n        guint8 first = 0;\n        if (network_mysqld_proto_peek_int8(packet, &first) == -1) {\n            return -1;\n        }\n\n        if (first == MYSQLD_PACKET_NULL) {\n            network_mysqld_proto_skip(packet, 1);\n        } else {\n            if (network_mysqld_proto_skip_lenenc_str(packet) == -1) {\n                return -1;\n            }\n        }\n    }\n    return 0;\n}", "path": "cetus/src/resultset_merge.c", "commit_date": "2019-06-30 00:00:00", "repo_name": "session-replay-tools/cetus", "stars": 1242, "license": "gpl-2.0", "language": "c", "size": 9044}
{"docstring": "/**\n *  is_prior_to Relation(record_A *record_B) defined ORDER BY\n *  return 1 if record A is prior to record B  else 0\n */\n", "func_signal": "static gint\nis_prior_to(GString *pkt1, GString *pkt2, order_by_para_t *para,\n            int pkt1_index, int pkt2_index, int *is_record_equal, int *compare_failed)", "code": "{\n    int i, equal_field_cnt, result;\n    network_packet packet1;\n    network_packet packet2;\n\n    packet1.data = pkt1;\n    packet2.data = pkt2;\n\n    equal_field_cnt = 0;\n\n    g_debug(\"%s: call is_prior_to, index1:%d, index2:%d, count:%d, pkt1:%p, pkt2:%p\",\n            G_STRLOC, pkt1_index, pkt2_index, ++heap_count, pkt1, pkt2);\n\n    for (i = 0; i < para->order_array_size; i++) {\n        result = 0;\n        packet1.offset = NET_HEADER_SIZE;\n        packet2.offset = NET_HEADER_SIZE;\n\n        ORDER_BY *order = &(para->order_array[i]);\n\n        switch (order->type) {\n        case FIELD_TYPE_TINY:\n        case FIELD_TYPE_SHORT:\n        case FIELD_TYPE_LONG:\n        case FIELD_TYPE_LONGLONG:\n        case FIELD_TYPE_INT24:\n            if (!compare_value_from_records(&packet1, &packet2, order, FIELD_TYPE_LONG, &result, compare_failed)) {\n                return result;\n            }\n            equal_field_cnt++;\n            break;\n        case FIELD_TYPE_NEWDECIMAL:\n        case FIELD_TYPE_DECIMAL:\n        case FIELD_TYPE_FLOAT:\n        case FIELD_TYPE_DOUBLE:\n            if (!compare_value_from_records(&packet1, &packet2, order, FIELD_TYPE_DOUBLE, &result, compare_failed)) {\n                return result;\n            }\n            equal_field_cnt++;\n            break;\n        case FIELD_TYPE_DATE:\n            if (!compare_value_from_records(&packet1, &packet2, order, FIELD_TYPE_DATE, &result, compare_failed)) {\n                return result;\n            }\n\n            equal_field_cnt++;\n            break;\n        case FIELD_TYPE_TIME:\n            if (!compare_value_from_records(&packet1, &packet2, order, FIELD_TYPE_DATE, &result, compare_failed)) {\n                return result;\n            }\n            equal_field_cnt++;\n            break;\n        case FIELD_TYPE_YEAR:\n            if (!compare_value_from_records(&packet1, &packet2, order, FIELD_TYPE_DATE, &result, compare_failed)) {\n                return result;\n            }\n            equal_field_cnt++;\n            break;\n        case FIELD_TYPE_NEWDATE:\n            return 1;\n            /* case FIELD_TYPE_VARCHAR: */\n        case FIELD_TYPE_TIMESTAMP:\n        case FIELD_TYPE_DATETIME:\n        case FIELD_TYPE_VAR_STRING:\n        case FIELD_TYPE_STRING:\n            if (!compare_records_by_str(&packet1, &packet2, para, pkt1_index, pkt2_index, i, &result)) {\n                return result;\n            }\n            equal_field_cnt++;\n            break;\n        case FIELD_TYPE_NULL:\n        case FIELD_TYPE_BIT:\n        case FIELD_TYPE_ENUM:\n        case FIELD_TYPE_SET:\n        case FIELD_TYPE_TINY_BLOB:\n        case FIELD_TYPE_MEDIUM_BLOB:\n        case FIELD_TYPE_LONG_BLOB:\n        case FIELD_TYPE_BLOB:\n        case FIELD_TYPE_GEOMETRY:\n            return 1;\n        default:\n            *compare_failed = 1;\n            g_warning(\"%s:unknown Field Type: %d\", G_STRLOC, order->type);\n            return 1;\n        }\n    }\n\n    if (equal_field_cnt == para->order_array_size) {\n        if (is_record_equal) {\n            *is_record_equal = 1;\n        }\n    }\n\n    return 1;\n}", "path": "cetus/src/resultset_merge.c", "commit_date": "2019-06-30 00:00:00", "repo_name": "session-replay-tools/cetus", "stars": 1242, "license": "gpl-2.0", "language": "c", "size": 9044}
{"docstring": "/* short means 16-bit integer */\n", "func_signal": "static guint16 get_nth_short(guint64 base, int n)", "code": "{\n    g_assert(n < 4);\n    int i;\n    guint64 mask = 0xFFFF;\n    for (i = 0; i < n; i++) {\n        mask = mask << 16;\n    }\n    guint64 value = mask & base;\n\n    for (i = 0; i < n; i++) {\n        value = value >> 16;\n    }\n    return value;\n}", "path": "cetus/src/resultset_merge.c", "commit_date": "2019-06-30 00:00:00", "repo_name": "session-replay-tools/cetus", "stars": 1242, "license": "gpl-2.0", "language": "c", "size": 9044}
{"docstring": "/* these expr will be processed as leaf node */\n", "func_signal": "static gboolean\nsql_expr_is_leaf_node(sql_expr_t *expr)", "code": "{\n    return (expr->op == TK_DOT && expr->left && expr->right)    /* db.table */\n        ||(expr->op == TK_UMINUS && expr->left) /* -3 */\n        ||(expr->op == TK_UPLUS && expr->left)  /* +4 */\n        ||(expr->op == TK_BETWEEN)\n        || (expr->op == TK_NOT)\n        || (expr->op == TK_EXISTS)\n        || (expr->op == TK_IN);\n}", "path": "cetus/lib/sql-construction.c", "commit_date": "2019-04-26 00:00:00", "repo_name": "session-replay-tools/cetus", "stars": 1242, "license": "gpl-2.0", "language": "c", "size": 9044}
{"docstring": "/* only match % wildcard, case insensitive */\n", "func_signal": "static gboolean sql_pattern_like(const char* pattern, const char* string)", "code": "{\n    if (!pattern || pattern[0] == '\\0')\n        return TRUE;\n    char *glob = g_strdup(pattern);\n    int i = 0;\n    for (i=0; glob[i]; ++i) {\n        if (glob[i] == '%') glob[i] = '*';\n        glob[i] = tolower(glob[i]);\n    }\n    char* lower_str = g_ascii_strdown(string, -1);\n    gboolean rc = g_pattern_match_simple(glob, lower_str);\n    g_free(glob);\n    g_free(lower_str);\n    return rc;\n}", "path": "cetus/plugins/admin/admin-commands.c", "commit_date": "2019-09-30 00:00:00", "repo_name": "session-replay-tools/cetus", "stars": 1242, "license": "gpl-2.0", "language": "c", "size": 9044}
{"docstring": "/* sql construction */\n", "func_signal": "static void\nsql_append_expr(GString *s, sql_expr_t *p)", "code": "{\n    size_t len;\n    switch (p->op) {\n    case TK_ID:\n        len = s->len;\n        if (len > 0) {\n            if (s->str[len - 1] != ' ') {\n                g_string_append(s, \" \");\n            }\n        }\n        g_string_append(s, p->token_text);\n        break;\n    case TK_EQ:\n        g_string_append(s, \"=\");\n        break;\n    case TK_LT:\n        g_string_append(s, \"<\");\n        break;\n    case TK_GT:\n        g_string_append(s, \">\");\n        break;\n    case TK_LE:\n        g_string_append(s, \"<=\");\n        break;\n    case TK_GE:\n        g_string_append(s, \">=\");\n        break;\n    case TK_NE:\n        g_string_append(s, \"<>\");\n        break;\n    case TK_AND:\n        g_string_append(s, \" AND \");\n        break;\n    case TK_OR:\n        g_string_append(s, \" OR \");\n        break;\n    case TK_DOT:\n        g_string_append(s, \" \");\n        g_string_append(s, p->left->token_text);\n        g_string_append(s, \".\");\n        g_string_append(s, p->right->token_text);\n        break;\n    case TK_UPLUS:\n    case TK_UMINUS:\n    case TK_INTEGER:{\n        char valstr[32] = { 0 };\n        char *pstr = valstr;\n        if (p->op == TK_UMINUS) {\n            *pstr = '-';\n            ++pstr;\n        }\n        sprintf(pstr, \"%\" PRIu64, p->num_value);\n        g_string_append(s, valstr);\n        break;\n    }\n    case TK_STRING:\n        if (sql_is_quoted_string(p->token_text)) {  /* TODO: dequote all */\n            g_string_append(s, \" \");\n            g_string_append(s, p->token_text);\n        } else {\n            g_string_append_c(s, ' ');\n            string_append_quoted(s, p->token_text, '\\'');\n        }\n        break;\n    case TK_FUNCTION:{\n        g_string_append(s, \" \");\n        g_string_append(s, p->token_text);\n        g_string_append(s, \"(\");\n        sql_expr_list_t *args = p->list;\n        if (args) {\n            int i = 0;\n            for (i = 0; i < args->len; ++i) {\n                sql_expr_t *arg = g_ptr_array_index(args, i);\n                sql_expr_traverse(s, arg);\n                if (i < args->len - 1) {\n                    g_string_append(s, \",\");\n                }\n            }\n        }\n        g_string_append(s, \")\");\n        break;\n    }\n    case TK_BETWEEN:{\n        sql_append_expr(s, p->left);\n        g_string_append(s, \" BETWEEN \");\n        sql_expr_list_t *args = p->list;\n        if (args && args->len == 2) {\n            sql_expr_t *low = g_ptr_array_index(args, 0);\n            sql_expr_t *high = g_ptr_array_index(args, 1);\n            sql_expr_traverse(s, low);\n            g_string_append(s, \" AND \");\n            sql_expr_traverse(s, high);\n        }\n        break;\n    }\n    case TK_IN:{\n        sql_append_expr(s, p->left);\n        g_string_append(s, \" IN (\");\n        if (p->list) {\n            sql_expr_list_t *args = p->list;\n            int i;\n            for (i = 0; args && i < args->len; ++i) {\n                sql_expr_t *arg = g_ptr_array_index(args, i);\n                sql_append_expr(s, arg);\n                if (i < args->len - 1) {\n                    g_string_append_c(s, ',');\n                }\n            }\n        } else if (p->select) {\n            GString *sel = sql_construct_select(p->select, 0);\n            if (sel) {\n                g_string_append(s, sel->str);\n                g_string_free(sel, TRUE);\n            }\n        }\n        g_string_append(s, \")\");\n        break;\n    }\n    case TK_EXISTS:{\n        g_string_append(s, \" EXISTS (\");\n        GString *sel = sql_construct_select(p->select, 0);\n        if (sel) {\n            g_string_append(s, sel->str);\n            g_string_free(sel, TRUE);\n        }\n        g_string_append(s, \")\");\n        break;\n    }\n    case TK_LIKE_KW:\n        if (p->list) {\n            sql_expr_list_t *args = p->list;\n            if (args->len > 0) {\n                sql_expr_t *arg = g_ptr_array_index(args, 0);\n                sql_expr_traverse(s, arg);\n            }\n            g_string_append(s, \" LIKE \");\n            if (args->len > 1) {\n                sql_expr_t *arg = g_ptr_array_index(args, 1);\n                sql_append_expr(s, arg);\n            }\n            if (args->len > 2) {\n                sql_expr_t *arg = g_ptr_array_index(args, 2);\n                g_string_append(s, \" ESCAPE \");\n                sql_append_expr(s, arg);\n            }\n        }\n        break;\n    case TK_NOT:\n        g_string_append(s, \" NOT(\");\n        sql_expr_traverse(s, p->left);\n        g_string_append_c(s, ')');\n        break;\n    case TK_SELECT:{           /* subselect as an expression */\n        g_string_append(s, \"(\");\n        GString *sel = sql_construct_select(p->select, 0);\n        if (sel) {\n            g_string_append(s, sel->str);\n            g_string_free(sel, TRUE);\n        }\n        g_string_append(s, \")\");\n        break;\n    }\n    case TK_IS:\n        g_string_append(s, \" IS \");\n        break;\n    case TK_ISNOT:\n        g_string_append(s, \" IS NOT \");\n        break;\n    case TK_PLUS:\n        g_string_append_c(s, '+');\n        break;\n    case TK_MINUS:\n        g_string_append_c(s, '-');\n        break;\n    default:\n        g_string_append(s, \" \");\n        g_string_append(s, p->token_text);\n    }\n}", "path": "cetus/lib/sql-construction.c", "commit_date": "2019-04-26 00:00:00", "repo_name": "session-replay-tools/cetus", "stars": 1242, "license": "gpl-2.0", "language": "c", "size": 9044}
{"docstring": "/**\n * setup the options that can only appear on the command-line\n */\n", "func_signal": "int\nchassis_options_set_cmdline_only_options(chassis_options_t *opts, int *print_version, char **config_file)", "code": "{\n\n    chassis_options_add(opts, \"version\", 'V', 0, OPTION_ARG_NONE, print_version, \"Show version\", NULL, NULL, NULL, 0);\n\n    chassis_options_add(opts, \"defaults-file\", 0, 0, OPTION_ARG_STRING, config_file, \"configuration file\", \"<file>\", NULL, NULL, 0);\n\n    return 0;\n}", "path": "cetus/src/chassis-frontend.c", "commit_date": "2018-05-02 00:00:00", "repo_name": "session-replay-tools/cetus", "stars": 1242, "license": "gpl-2.0", "language": "c", "size": 9044}
{"docstring": "/* select a table, make it into a json */\n", "func_signal": "gboolean\nchassis_config_query_object(chassis_config_t *conf, const char *name, char **json_res, int refresh)", "code": "{\n    struct config_object_t *object = chassis_config_get_object(conf, name);\n    if (!object) {\n        object = g_new0(struct config_object_t, 1);\n        strncpy(object->name, name, RF_MAX_NAME_LEN - 1);\n\n        if (conf->objects_index == 0) {\n            conf->objects_one = g_list_append(conf->objects_one, object);\n        } else {\n            conf->objects_two = g_list_append(conf->objects_two, object);\n        }\n    } else {\n        if (refresh) {\n            time_t now = time(0);\n            chassis_config_object_set_cache(object, NULL, now);\n        } else {\n            if (object->cache) {\n                *json_res = g_strdup(object->cache);\n                return TRUE;\n            }\n        }\n    }\n\n    g_debug(G_STRLOC \": config type:%d\", conf->type);\n    switch (conf->type) {\n    case CHASSIS_CONF_MYSQL:\n        if (refresh) {\n            return FALSE;\n        } else {\n            if (chassis_config_mysql_query_object(conf, object, name)) {\n                if (object->cache) {\n                    *json_res = g_strdup(object->cache);\n                    return TRUE;\n                } else {\n                    return FALSE;\n                }\n            }  else {\n                return FALSE;\n            }\n        }\n    case CHASSIS_CONF_LOCAL:\n        return chassis_config_local_query_object(conf, object, name, json_res);\n    default:\n        return FALSE;\n    }\n}", "path": "cetus/src/chassis-config.c", "commit_date": "2019-02-20 00:00:00", "repo_name": "session-replay-tools/cetus", "stars": 1242, "license": "gpl-2.0", "language": "c", "size": 9044}
{"docstring": "/**\n * setup and check the basedir if nessesary\n */\n", "func_signal": "int\nchassis_frontend_init_basedir(const char *prg_name, char **_base_dir)", "code": "{\n    char *base_dir = *_base_dir;\n\n    if (base_dir) {             /* basedir is already known, check if it is absolute */\n        if (!g_path_is_absolute(base_dir)) {\n            g_critical(\"%s: --basedir option must be an absolute path, but was %s\", G_STRLOC, base_dir);\n            return -1;\n        } else {\n            return 0;\n        }\n    }\n\n    /* find our installation directory if no basedir was given\n     * this is necessary for finding files when we daemonize\n     */\n    base_dir = chassis_get_basedir(prg_name);\n    if (!base_dir) {\n        g_critical(\"%s: Failed to get base directory\", G_STRLOC);\n        return -1;\n    }\n\n    *_base_dir = base_dir;\n\n    return 0;\n\n}", "path": "cetus/src/chassis-frontend.c", "commit_date": "2018-05-02 00:00:00", "repo_name": "session-replay-tools/cetus", "stars": 1242, "license": "gpl-2.0", "language": "c", "size": 9044}
{"docstring": "/**\n * setup index & validate configurations\n */\n", "func_signal": "static gboolean\nshard_conf_try_setup(int is_partition_mode, GList *vdbs, GList *tables, GList *single_tables, int num_groups)", "code": "{\n    if (!vdbs || !tables) {\n        g_critical(\"empty vdb/table list\");\n        return FALSE;\n    }\n    GList *l = vdbs;\n    for (; l != NULL; l = l->next) {\n        sharding_vdb_t *vdb = l->data;\n        if (!sharding_vdb_is_valid(is_partition_mode, vdb, num_groups)) {\n            g_warning(\"invalid vdb config\");\n            return FALSE;\n        }\n    }\n    GList *all_groups = NULL;\n    GHashTable *table_dict = g_hash_table_new_full(schema_table_hash, schema_table_equal,\n                                                   (GDestroyNotify)schema_table_free,\n                                                   sharding_table_free);\n    l = tables;\n    for (; l != NULL; l = l->next) {\n        sharding_table_t *table = l->data;\n        sharding_vdb_t *vdb = shard_vdbs_get_by_id(vdbs, table->vdb_id);\n\n        /* Fill table with vdb info */\n        if (vdb) {\n            table->vdb_ref = vdb;\n            table->shard_key_type = vdb->key_type;\n        } else {\n            g_critical(G_STRLOC \" table:%s VDB ID cannot be found: %d\",\n                       table->name->str, table->vdb_id);\n            g_hash_table_destroy(table_dict);\n            return FALSE;\n        }\n        int i = 0;\n        for (i = 0; i < vdb->partitions->len; ++i) {\n            sharding_partition_t *part = g_ptr_array_index(vdb->partitions, i);\n            all_groups = string_list_distinct_append(all_groups, part->group_name);\n        }\n        struct schema_table_t *st = schema_table_new(table->schema->str, table->name->str);\n        g_hash_table_insert(table_dict, st, table);\n    }\n    /* `tables` has been transferred to `table_dict`, free it */\n    g_list_free(tables);\n\n    shard_conf_set_vdb_list(vdbs);\n    shard_conf_set_tables(table_dict);\n    shard_conf_set_single_tables(single_tables);\n    shard_conf_set_all_groups(all_groups);\n\n    parition_super_group = g_string_new(PARTITION_SUPER_GROUP);\n\n    return TRUE;\n}", "path": "cetus/src/sharding-config.c", "commit_date": "2019-10-18 00:00:00", "repo_name": "session-replay-tools/cetus", "stars": 1242, "license": "gpl-2.0", "language": "c", "size": 9044}
{"docstring": "/**\n * initialize the basic components of the chassis\n */\n", "func_signal": "int\nchassis_frontend_init_glib()", "code": "{\n    const gchar *check_str = NULL;\n#if 0\n    g_mem_set_vtable(glib_mem_profiler_table);\n#endif\n\n    if (!GLIB_CHECK_VERSION(2, 6, 0)) {\n        g_critical(\"the glib header is too old, need at least 2.6.0, got: %d.%d.%d\",\n                   GLIB_MAJOR_VERSION, GLIB_MINOR_VERSION, GLIB_MICRO_VERSION);\n\n        return -1;\n    }\n\n    check_str = glib_check_version(GLIB_MAJOR_VERSION, GLIB_MINOR_VERSION, GLIB_MICRO_VERSION);\n\n    if (check_str) {\n        g_critical(\"%s, got: lib=%d.%d.%d, headers=%d.%d.%d\",\n                   check_str,\n                   glib_major_version, glib_minor_version, glib_micro_version,\n                   GLIB_MAJOR_VERSION, GLIB_MINOR_VERSION, GLIB_MICRO_VERSION);\n\n        return -1;\n    }\n\n    if (!g_module_supported()) {\n        g_critical(\"loading modules is not supported on this platform\");\n        return -1;\n    }\n#if !GLIB_CHECK_VERSION(2, 32, 0)\n    /* GLIB below 2.32 must call thread_init */\n    g_thread_init(NULL);\n#endif\n\n    return 0;\n}", "path": "cetus/src/chassis-frontend.c", "commit_date": "2018-05-02 00:00:00", "repo_name": "session-replay-tools/cetus", "stars": 1242, "license": "gpl-2.0", "language": "c", "size": 9044}
{"docstring": "/**\n * @return GList<sharding_vdb_t *>\n */\n", "func_signal": "static GList *\nparse_vdbs(cJSON *vdb_root)", "code": "{\n    GList *vdb_list = NULL;\n    cJSON *p = vdb_root->child;\n    for (; p != NULL; p = p->next) {\n        cJSON *id = cJSON_GetObjectItem(p, \"id\");\n        cJSON *key_type = cJSON_GetObjectItem(p, \"type\");\n        cJSON *method = cJSON_GetObjectItem(p, \"method\");\n        cJSON *num = cJSON_GetObjectItem(p, \"num\");\n        cJSON *partitions = cJSON_GetObjectItem(p, \"partitions\");\n        if (!(id && key_type && method && num && partitions)) {\n            g_critical(\"parse vdbs error, neglected\");\n            continue;\n        }\n\n        struct sharding_vdb_t *vdb = sharding_vdb_new();\n        if (id->type == cJSON_Number) {\n            vdb->id = id->valueint;\n        } else {\n            vdb->id = atoi(id->valuestring);\n        }\n        vdb->key_type = sharding_key_type(key_type->valuestring);\n        if (vdb->key_type < 0) {\n            g_critical(\"Wrong sharding settings <key_type:%s>\", key_type->valuestring);\n        }\n        vdb->method = sharding_method(method->valuestring);\n        if (vdb->method < 0) {\n            g_critical(\"Wrong sharding settings <key_type:%s>\", method->valuestring);\n        }\n\n        if (num->type == cJSON_Number) {\n            vdb->logic_shard_num = num->valueint;\n        } else {\n            g_critical(\"no match num: %s\", num->valuestring);\n        }\n\n        parse_partitions(partitions, vdb, vdb->partitions);\n        setup_partitions(vdb->partitions, vdb);\n\n        vdb_list = g_list_append(vdb_list, vdb);\n    }\n    return vdb_list;\n}", "path": "cetus/src/sharding-config.c", "commit_date": "2019-10-18 00:00:00", "repo_name": "session-replay-tools/cetus", "stars": 1242, "license": "gpl-2.0", "language": "c", "size": 9044}
{"docstring": "/**\n * Get order_array.pos, order_array.type\n */\n", "func_signal": "static gboolean\nget_order_by_fields(cetus_result_t *res_merge, ORDER_BY *order_array,\n                    guint order_array_size, result_merge_t *merged_result)", "code": "{\n    int i;\n    for (i = 0; i < order_array_size; ++i) {\n        ORDER_BY *orderby = &(order_array[i]);\n\n        if (orderby->pos == -1) {\n            int index = cetus_result_find_fielddef(res_merge,\n                                                   orderby->table_name, orderby->name);\n            if (index == -1) {\n                merged_result->status = RM_FAIL;\n                char msg[128] = { 0 };\n                snprintf(msg, sizeof(msg), \"order by:no %s in field list\", orderby->name);\n                merged_result->detail = g_string_new(msg);\n                return FALSE;\n            }\n            orderby->pos = index;\n        }\n        network_mysqld_proto_fielddef_t *fdef = g_ptr_array_index(res_merge->fielddefs, orderby->pos);\n        orderby->type = fdef->type;\n    }\n    return TRUE;\n}", "path": "cetus/src/resultset_merge.c", "commit_date": "2019-06-30 00:00:00", "repo_name": "session-replay-tools/cetus", "stars": 1242, "license": "gpl-2.0", "language": "c", "size": 9044}
{"docstring": "/**\n * get array of groups pointers of a table\n * no more duplication check cause one group correspond multiple range value\n */\n", "func_signal": "GPtrArray *\nshard_conf_table_partitions(GPtrArray *partitions, const char *db, const char *table)", "code": "{\n    if (!db || !table) {\n        g_warning(G_STRLOC \" db or table name is NULL\");\n        return NULL;\n    }\n\n    sharding_vdb_t *vdb = sharding_vdbs_get_by_table(db, table);\n    if (!vdb) {\n        return NULL;\n    }\n    GPtrArray *all_partitions = vdb->partitions;\n    int i;\n    for (i = 0; i < all_partitions->len; i++) {\n        sharding_partition_t *part = g_ptr_array_index(all_partitions, i);\n        g_ptr_array_add(partitions, part);\n    }\n    return partitions;\n}", "path": "cetus/src/sharding-config.c", "commit_date": "2019-10-18 00:00:00", "repo_name": "session-replay-tools/cetus", "stars": 1242, "license": "gpl-2.0", "language": "c", "size": 9044}
{"docstring": "/**\n * @breif For all ORDER-BY columns, get their offsets inside Row-Packet\n * @return At most 4 offset values embedded in a 64-bit integer: 4 * int16_t --> int64_t\n */\n", "func_signal": "static guint64\nget_field_offsets(network_packet *packet, ORDER_BY order_array[], int order_array_size)", "code": "{\n    int i, max_pos = 0;\n    int orderby_count = MIN(order_array_size, 4);\n\n    for (i = 0; i < orderby_count; i++) {\n        if (order_array[i].pos > max_pos) {\n            max_pos = order_array[i].pos;\n        }\n    }\n\n    if (max_pos > MAX_ORDER_BY_ITEMS) {\n        return 0;\n    }\n\n    unsigned char map[MAX_ORDER_BY_ITEMS] = { 0 };  /* field pos ==> order by pos */\n    for (i = 0; i < orderby_count; i++) {\n        /* hack: add 1 for existence probing */\n        map[order_array[i].pos] = i + 1;\n    }\n\n    guint64 value = 0;\n    if (max_pos == 0) {\n        value = NET_HEADER_SIZE;\n    }\n\n    guint iter;\n    for (iter = 0; iter < max_pos; iter++) {\n        if (packet->data->str[packet->offset] == (char)MYSQLD_PACKET_NULL) {\n            network_mysqld_proto_skip(packet, 1);\n        } else {\n            if (network_mysqld_proto_skip_lenenc_str(packet) == -1) {\n                return 0;\n            }\n        }\n        size_t next_iter = iter + 1;\n        if (next_iter < MAX_ORDER_BY_ITEMS && map[next_iter]) {\n            int seq = map[next_iter] - 1;\n            guint64 new_value = packet->offset;\n            g_debug(\"offset value:%ld, seq=%d, iter=%d %p\", new_value, seq, iter, packet->data);\n            if (new_value <= 0xFFFF) {\n                int j;\n                for (j = 0; j < seq; j++) {\n                    new_value = new_value << 16;\n                }\n\n                value += new_value;\n            }\n            g_debug(\"part all value set:%ld for %p\", value, packet->data);\n        }\n    }\n\n    return value;\n}", "path": "cetus/src/resultset_merge.c", "commit_date": "2019-06-30 00:00:00", "repo_name": "session-replay-tools/cetus", "stars": 1242, "license": "gpl-2.0", "language": "c", "size": 9044}
{"docstring": "/* format as \" expr1,expr2,expr3 \"*/\n", "func_signal": "void\nsql_append_expr_list(GString *s, sql_expr_list_t *exprlist)", "code": "{\n    int i = 0;\n    for (i = 0; i < exprlist->len; ++i) {\n        sql_expr_t *expr = g_ptr_array_index(exprlist, i);\n        append_sql_expr(s, expr);\n        if (i != exprlist->len - 1) {\n            g_string_append_c(s, ',');\n        }\n    }\n}", "path": "cetus/lib/sql-construction.c", "commit_date": "2019-04-26 00:00:00", "repo_name": "session-replay-tools/cetus", "stars": 1242, "license": "gpl-2.0", "language": "c", "size": 9044}
{"docstring": "/**\n * log the versions of the initialized plugins\n */\n", "func_signal": "int\nchassis_frontend_log_plugin_versions(GPtrArray *plugins)", "code": "{\n    guint i;\n\n    for (i = 0; i < plugins->len; i++) {\n        chassis_plugin *p = plugins->pdata[i];\n\n        g_message(\"plugin %s %s started\", p->name, p->version);\n    }\n\n    return 0;\n}", "path": "cetus/src/chassis-frontend.c", "commit_date": "2018-05-02 00:00:00", "repo_name": "session-replay-tools/cetus", "stars": 1242, "license": "gpl-2.0", "language": "c", "size": 9044}
{"docstring": "/*\n  DATETIME partitions parsed from SQL originally marked as STR type,\n  change it to DATETIME here, release the string memory\n*/\n", "func_signal": "static gboolean convert_datetime_partitions(GPtrArray *partitions, sharding_vdb_t *vdb)", "code": "{\n    if (vdb->key_type == SHARD_DATA_TYPE_DATE\n        || vdb->key_type == SHARD_DATA_TYPE_DATETIME)\n    {\n        int i;\n        for (i = 0; i < partitions->len; ++i) {\n            sharding_partition_t *part = g_ptr_array_index(partitions, i);\n            if (part->key_type != SHARD_DATA_TYPE_STR) {\n                g_warning(\"convert_datetime: date time not string\");\n                return FALSE;\n            }\n            if (part->method != SHARD_METHOD_RANGE) {\n                g_warning(\"convert_datetime: date time not using range method\");\n                return FALSE;\n            }\n            gboolean ok = FALSE;\n            int epoch = chassis_epoch_from_string(part->value, &ok);\n            if (ok) {\n                part->key_type = vdb->key_type;\n                g_free(part->value);\n                part->value = (void *)(uint64_t)epoch;\n            } else {\n                g_warning(\"Wrong sharding param <datetime format:%s>\", part->value);\n                return FALSE;\n            }\n        }\n    }\n    return TRUE;\n}", "path": "cetus/plugins/admin/admin-commands.c", "commit_date": "2019-09-30 00:00:00", "repo_name": "session-replay-tools/cetus", "stars": 1242, "license": "gpl-2.0", "language": "c", "size": 9044}
{"docstring": "/** Get string from SII string section in slave EEPROM.\n *  @param[in]  context = context struct\n *  @param[out] str     = requested string, 0x00 if not found\n *  @param[in]  slave   = slave number\n *  @param[in]  Sn      = string number\n */\n", "func_signal": "void ecx_siistring(ecx_contextt *context, char *str, uint16 slave, uint16 Sn)", "code": "{\n   uint16 a,i,j,l,n,ba;\n   char *ptr;\n   uint8 eectl = context->slavelist[slave].eep_pdi;\n\n   ptr = str;\n   a = ecx_siifind (context, slave, ECT_SII_STRING); /* find string section */\n   if (a > 0)\n   {\n      ba = a + 2; /* skip SII section header */\n      n = ecx_siigetbyte(context, slave, ba++); /* read number of strings in section */\n      if (Sn <= n) /* is req string available? */\n      {\n         for (i = 1; i <= Sn; i++) /* walk through strings */\n         {\n            l = ecx_siigetbyte(context, slave, ba++); /* length of this string */\n            if (i < Sn)\n            {\n               ba += l;\n            }\n            else\n            {\n               ptr = str;\n               for (j = 1; j <= l; j++) /* copy one string */\n               {\n                  if(j <= EC_MAXNAME)\n                  {\n                     *ptr = (char)ecx_siigetbyte(context, slave, ba++);\n                     ptr++;\n                  }\n                  else\n                  {\n                     ba++;\n                  }\n               }\n            }\n         }\n         *ptr = 0; /* add zero terminator */\n      }\n      else\n      {\n         ptr = str;\n         *ptr = 0; /* empty string */\n      }\n   }\n   if (eectl)\n   {\n      ecx_eeprom2pdi(context, slave); /* if eeprom control was previously pdi then restore */\n   }\n}", "path": "SOEM/soem/ethercatmain.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "OpenEtherCATsociety/SOEM", "stars": 1139, "license": "other", "language": "c", "size": 1296}
{"docstring": "/** Read PDO assign structure */\n", "func_signal": "int si_PDOassign(uint16 slave, uint16 PDOassign, int mapoffset, int bitoffset)", "code": "{\n    uint16 idxloop, nidx, subidxloop, rdat, idx, subidx;\n    uint8 subcnt;\n    int wkc, bsize = 0, rdl;\n    int32 rdat2;\n    uint8 bitlen, obj_subidx;\n    uint16 obj_idx;\n    int abs_offset, abs_bit;\n\n    rdl = sizeof(rdat); rdat = 0;\n    /* read PDO assign subindex 0 ( = number of PDO's) */\n    wkc = ec_SDOread(slave, PDOassign, 0x00, FALSE, &rdl, &rdat, EC_TIMEOUTRXM);\n    rdat = etohs(rdat);\n    /* positive result from slave ? */\n    if ((wkc > 0) && (rdat > 0))\n    {\n        /* number of available sub indexes */\n        nidx = rdat;\n        bsize = 0;\n        /* read all PDO's */\n        for (idxloop = 1; idxloop <= nidx; idxloop++)\n        {\n            rdl = sizeof(rdat); rdat = 0;\n            /* read PDO assign */\n            wkc = ec_SDOread(slave, PDOassign, (uint8)idxloop, FALSE, &rdl, &rdat, EC_TIMEOUTRXM);\n            /* result is index of PDO */\n            idx = etohs(rdat);\n            if (idx > 0)\n            {\n                rdl = sizeof(subcnt); subcnt = 0;\n                /* read number of subindexes of PDO */\n                wkc = ec_SDOread(slave,idx, 0x00, FALSE, &rdl, &subcnt, EC_TIMEOUTRXM);\n                subidx = subcnt;\n                /* for each subindex */\n                for (subidxloop = 1; subidxloop <= subidx; subidxloop++)\n                {\n                    rdl = sizeof(rdat2); rdat2 = 0;\n                    /* read SDO that is mapped in PDO */\n                    wkc = ec_SDOread(slave, idx, (uint8)subidxloop, FALSE, &rdl, &rdat2, EC_TIMEOUTRXM);\n                    rdat2 = etohl(rdat2);\n                    /* extract bitlength of SDO */\n                    bitlen = LO_BYTE(rdat2);\n                    bsize += bitlen;\n                    obj_idx = (uint16)(rdat2 >> 16);\n                    obj_subidx = (uint8)((rdat2 >> 8) & 0x000000ff);\n                    abs_offset = mapoffset + (bitoffset / 8);\n                    abs_bit = bitoffset % 8;\n                    ODlist.Slave = slave;\n                    ODlist.Index[0] = obj_idx;\n                    OElist.Entries = 0;\n                    wkc = 0;\n                    /* read object entry from dictionary if not a filler (0x0000:0x00) */\n                    if(obj_idx || obj_subidx)\n                        wkc = ec_readOEsingle(0, obj_subidx, &ODlist, &OElist);\n                    printf(\"  [0x%4.4X.%1d] 0x%4.4X:0x%2.2X 0x%2.2X\", abs_offset, abs_bit, obj_idx, obj_subidx, bitlen);\n                    if((wkc > 0) && OElist.Entries)\n                    {\n                        printf(\" %-12s %s\\n\", dtype2string(OElist.DataType[obj_subidx]), OElist.Name[obj_subidx]);\n                    }\n                    else\n                        printf(\"\\n\");\n                    bitoffset += bitlen;\n                };\n            };\n        };\n    };\n    /* return total found bitlength (PDO) */\n    return bsize;\n}", "path": "SOEM/test/linux/slaveinfo/slaveinfo.c", "commit_date": "2019-05-10 00:00:00", "repo_name": "OpenEtherCATsociety/SOEM", "stars": 1139, "license": "other", "language": "c", "size": 1296}
{"docstring": "/** Read one byte from slave EEPROM via cache.\n *  If the cache location is empty then a read request is made to the slave.\n *  Depending on the slave capabilities the request is 4 or 8 bytes.\n *  @param[in] context = context struct\n *  @param[in] slave   = slave number\n *  @param[in] address = eeprom address in bytes (slave uses words)\n *  @return requested byte, if not available then 0xff\n */\n", "func_signal": "uint8 ecx_siigetbyte(ecx_contextt *context, uint16 slave, uint16 address)", "code": "{\n   uint16 configadr, eadr;\n   uint64 edat64;\n   uint32 edat32;\n   uint16 mapw, mapb;\n   int lp,cnt;\n   uint8 retval;\n\n   retval = 0xff;\n   if (slave != context->esislave) /* not the same slave? */\n   {\n      memset(context->esimap, 0x00, EC_MAXEEPBITMAP * sizeof(uint32)); /* clear esibuf cache map */\n      context->esislave = slave;\n   }\n   if (address < EC_MAXEEPBUF)\n   {\n      mapw = address >> 5;\n      mapb = (uint16)(address - (mapw << 5));\n      if (context->esimap[mapw] & (uint32)(1 << mapb))\n      {\n         /* byte is already in buffer */\n         retval = context->esibuf[address];\n      }\n      else\n      {\n         /* byte is not in buffer, put it there */\n         configadr = context->slavelist[slave].configadr;\n         ecx_eeprom2master(context, slave); /* set eeprom control to master */\n         eadr = address >> 1;\n         edat64 = ecx_readeepromFP (context, configadr, eadr, EC_TIMEOUTEEP);\n         /* 8 byte response */\n         if (context->slavelist[slave].eep_8byte)\n         {\n            put_unaligned64(edat64, &(context->esibuf[eadr << 1]));\n            cnt = 8;\n         }\n         /* 4 byte response */\n         else\n         {\n            edat32 = (uint32)edat64;\n            put_unaligned32(edat32, &(context->esibuf[eadr << 1]));\n            cnt = 4;\n         }\n         /* find bitmap location */\n         mapw = eadr >> 4;\n         mapb = (uint16)((eadr << 1) - (mapw << 5));\n         for(lp = 0 ; lp < cnt ; lp++)\n         {\n            /* set bitmap for each byte that is read */\n            context->esimap[mapw] |= (1 << mapb);\n            mapb++;\n            if (mapb > 31)\n            {\n               mapb = 0;\n               mapw++;\n            }\n         }\n         retval = context->esibuf[address];\n      }\n   }\n\n   return retval;\n}", "path": "SOEM/soem/ethercatmain.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "OpenEtherCATsociety/SOEM", "stars": 1139, "license": "other", "language": "c", "size": 1296}
{"docstring": "/** Pushes an error on the error list.\n *\n * @param[in] context        = context struct\n * @param[in] Ec pointer describing the error.\n */\n", "func_signal": "void ecx_pusherror(ecx_contextt *context, const ec_errort *Ec)", "code": "{\n   context->elist->Error[context->elist->head] = *Ec;\n   context->elist->Error[context->elist->head].Signal = TRUE;\n   context->elist->head++;\n   if (context->elist->head > EC_MAXELIST)\n   {\n      context->elist->head = 0;\n   }\n   if (context->elist->head == context->elist->tail)\n   {\n      context->elist->tail++;\n   }\n   if (context->elist->tail > EC_MAXELIST)\n   {\n      context->elist->tail = 0;\n   }\n   *(context->ecaterror) = TRUE;\n}", "path": "SOEM/soem/ethercatmain.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "OpenEtherCATsociety/SOEM", "stars": 1139, "license": "other", "language": "c", "size": 1296}
{"docstring": "/** Read EEPROM from slave bypassing cache.\n * @param[in] context   = context struct\n * @param[in] slave     = Slave number\n * @param[in] eeproma   = (WORD) Address in the EEPROM\n * @param[in] timeout   = Timeout in us.\n * @return EEPROM data 32bit\n */\n", "func_signal": "uint32 ecx_readeeprom(ecx_contextt *context, uint16 slave, uint16 eeproma, int timeout)", "code": "{\n   uint16 configadr;\n\n   ecx_eeprom2master(context, slave); /* set eeprom control to master */\n   configadr = context->slavelist[slave].configadr;\n\n   return ((uint32)ecx_readeepromFP(context, configadr, eeproma, timeout));\n}", "path": "SOEM/soem/ethercatmain.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "OpenEtherCATsociety/SOEM", "stars": 1139, "license": "other", "language": "c", "size": 1296}
{"docstring": "/** Write slave state, if slave = 0 then write to all slaves.\n * The function does not check if the actual state is changed.\n * @param[in]  context        = context struct\n * @param[in] slave    = Slave number, 0 = master\n * @return Workcounter or EC_NOFRAME\n */\n", "func_signal": "int ecx_writestate(ecx_contextt *context, uint16 slave)", "code": "{\n   int ret;\n   uint16 configadr, slstate;\n\n   if (slave == 0)\n   {\n      slstate = htoes(context->slavelist[slave].state);\n      ret = ecx_BWR(context->port, 0, ECT_REG_ALCTL, sizeof(slstate),\n\t            &slstate, EC_TIMEOUTRET3);\n   }\n   else\n   {\n      configadr = context->slavelist[slave].configadr;\n\n      ret = ecx_FPWRw(context->port, configadr, ECT_REG_ALCTL,\n\t        htoes(context->slavelist[slave].state), EC_TIMEOUTRET3);\n   }\n   return ret;\n}", "path": "SOEM/soem/ethercatmain.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "OpenEtherCATsociety/SOEM", "stars": 1139, "license": "other", "language": "c", "size": 1296}
{"docstring": "/** Read all slave states in ec_slave.\n * @param[in] context = context struct\n * @return lowest state found\n */\n", "func_signal": "int ecx_readstate(ecx_contextt *context)", "code": "{\n   uint16 slave, fslave, lslave, configadr, lowest, rval, bitwisestate;\n   ec_alstatust sl[MAX_FPRD_MULTI];\n   uint16 slca[MAX_FPRD_MULTI];\n   boolean noerrorflag, allslavessamestate;\n   boolean allslavespresent = FALSE;\n   int wkc;\n\n   /* Try to establish the state of all slaves sending only one broadcast datagram.\n    * This way a number of datagrams equal to the number of slaves will be sent only if needed.*/\n   rval = 0;\n   wkc = ecx_BRD(context->port, 0, ECT_REG_ALSTAT, sizeof(rval), &rval, EC_TIMEOUTRET);\n\n   if(wkc >= *(context->slavecount))\n   {\n      allslavespresent = TRUE;\n   }\n\n   rval = etohs(rval);\n   bitwisestate = (rval & 0x0f);\n\n   if ((rval & EC_STATE_ERROR) == 0)\n   {\n      noerrorflag = TRUE;\n      context->slavelist[0].ALstatuscode = 0;\n   }   \n   else\n   {\n      noerrorflag = FALSE;\n   }\n\n   switch (bitwisestate)\n   {\n      case EC_STATE_INIT:\n      case EC_STATE_PRE_OP:\n      case EC_STATE_BOOT:\n      case EC_STATE_SAFE_OP:\n      case EC_STATE_OPERATIONAL:\n         allslavessamestate = TRUE;\n         context->slavelist[0].state = bitwisestate;\n         break;\n      default:\n         allslavessamestate = FALSE;\n         break;\n   }\n    \n   if (noerrorflag && allslavessamestate && allslavespresent)\n   {\n      /* No slave has toggled the error flag so the alstatuscode\n       * (even if different from 0) should be ignored and\n       * the slaves have reached the same state so the internal state\n       * can be updated without sending any datagram. */\n      for (slave = 1; slave <= *(context->slavecount); slave++)\n      {\n         context->slavelist[slave].ALstatuscode = 0x0000;\n         context->slavelist[slave].state = bitwisestate;\n      }\n      lowest = bitwisestate;\n   }\n   else\n   {\n      /* Not all slaves have the same state or at least one is in error so one datagram per slave\n       * is needed. */\n      context->slavelist[0].ALstatuscode = 0;\n      lowest = 0xff;\n      fslave = 1;\n      do\n      {\n         lslave = (uint16)*(context->slavecount);\n         if ((lslave - fslave) >= MAX_FPRD_MULTI)\n         {\n            lslave = fslave + MAX_FPRD_MULTI - 1;\n         }\n         for (slave = fslave; slave <= lslave; slave++)\n         {\n            const ec_alstatust zero = { 0, 0, 0 };\n\n            configadr = context->slavelist[slave].configadr;\n            slca[slave - fslave] = configadr;\n            sl[slave - fslave] = zero;\n         }\n         ecx_FPRD_multi(context, (lslave - fslave) + 1, &(slca[0]), &(sl[0]), EC_TIMEOUTRET3);\n         for (slave = fslave; slave <= lslave; slave++)\n         {\n            configadr = context->slavelist[slave].configadr;\n            rval = etohs(sl[slave - fslave].alstatus);\n            context->slavelist[slave].ALstatuscode = etohs(sl[slave - fslave].alstatuscode);\n            if ((rval & 0xf) < lowest)\n            {\n               lowest = (rval & 0xf);\n            }\n            context->slavelist[slave].state = rval;\n            context->slavelist[0].ALstatuscode |= context->slavelist[slave].ALstatuscode;\n         }\n         fslave = lslave + 1;\n      } while (lslave < *(context->slavecount));\n      context->slavelist[0].state = lowest;\n   }\n  \n   return lowest;\n}", "path": "SOEM/soem/ethercatmain.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "OpenEtherCATsociety/SOEM", "stars": 1139, "license": "other", "language": "c", "size": 1296}
{"docstring": "/** Read OUT mailbox from slave.\n * Supports Mailbox Link Layer with repeat requests.\n * @param[in]  context    = context struct\n * @param[in]  slave      = Slave number\n * @param[out] mbx        = Mailbox data\n * @param[in]  timeout    = Timeout in us\n * @return Work counter (>0 is success)\n */\n", "func_signal": "int ecx_mbxreceive(ecx_contextt *context, uint16 slave, ec_mbxbuft *mbx, int timeout)", "code": "{\n   uint16 mbxro,mbxl,configadr;\n   int wkc=0;\n   int wkc2;\n   uint16 SMstat;\n   uint8 SMcontr;\n   ec_mbxheadert *mbxh;\n   ec_emcyt *EMp;\n   ec_mbxerrort *MBXEp;\n\n   configadr = context->slavelist[slave].configadr;\n   mbxl = context->slavelist[slave].mbx_rl;\n   if ((mbxl > 0) && (mbxl <= EC_MAXMBX))\n   {\n      osal_timert timer;\n\n      osal_timer_start(&timer, timeout);\n      wkc = 0;\n      do /* wait for read mailbox available */\n      {\n         SMstat = 0;\n         wkc = ecx_FPRD(context->port, configadr, ECT_REG_SM1STAT, sizeof(SMstat), &SMstat, EC_TIMEOUTRET);\n         SMstat = etohs(SMstat);\n         if (((SMstat & 0x08) == 0) && (timeout > EC_LOCALDELAY))\n         {\n            osal_usleep(EC_LOCALDELAY);\n         }\n      }\n      while (((wkc <= 0) || ((SMstat & 0x08) == 0)) && (osal_timer_is_expired(&timer) == FALSE));\n\n      if ((wkc > 0) && ((SMstat & 0x08) > 0)) /* read mailbox available ? */\n      {\n         mbxro = context->slavelist[slave].mbx_ro;\n         mbxh = (ec_mbxheadert *)mbx;\n         do\n         {\n            wkc = ecx_FPRD(context->port, configadr, mbxro, mbxl, mbx, EC_TIMEOUTRET); /* get mailbox */\n            if ((wkc > 0) && ((mbxh->mbxtype & 0x0f) == 0x00)) /* Mailbox error response? */\n            {\n               MBXEp = (ec_mbxerrort *)mbx;\n               ecx_mbxerror(context, slave, etohs(MBXEp->Detail));\n               wkc = 0; /* prevent emergency to cascade up, it is already handled. */\n            }\n            else if ((wkc > 0) && ((mbxh->mbxtype & 0x0f) == ECT_MBXT_COE)) /* CoE response? */\n            {\n               EMp = (ec_emcyt *)mbx;\n               if ((etohs(EMp->CANOpen) >> 12) == 0x01) /* Emergency request? */\n               {\n                  ecx_mbxemergencyerror(context, slave, etohs(EMp->ErrorCode), EMp->ErrorReg,\n                          EMp->bData, etohs(EMp->w1), etohs(EMp->w2));\n                  wkc = 0; /* prevent emergency to cascade up, it is already handled. */\n               }\n            }\n            else if ((wkc > 0) && ((mbxh->mbxtype & 0x0f) == ECT_MBXT_EOE)) /* EoE response? */\n            {\n               ec_EOEt * eoembx = (ec_EOEt *)mbx;\n               uint16 frameinfo1 = etohs(eoembx->frameinfo1);\n               /* All non fragment data frame types are expected to be handled by\n               * slave send/receive API if the EoE hook is set\n               */\n               if (EOE_HDR_FRAME_TYPE_GET(frameinfo1) == EOE_FRAG_DATA)\n               {\n                  if (context->EOEhook)\n                  {\n                     if (context->EOEhook(context, slave, eoembx) > 0)\n                     {\n                        /* Fragment handled by EoE hook */\n                        wkc = 0;\n                     }\n                  }\n               }\n            }\n            else\n            {\n               if (wkc <= 0) /* read mailbox lost */\n               {\n                  SMstat ^= 0x0200; /* toggle repeat request */\n                  SMstat = htoes(SMstat);\n                  wkc2 = ecx_FPWR(context->port, configadr, ECT_REG_SM1STAT, sizeof(SMstat), &SMstat, EC_TIMEOUTRET);\n                  SMstat = etohs(SMstat);\n                  do /* wait for toggle ack */\n                  {\n                     wkc2 = ecx_FPRD(context->port, configadr, ECT_REG_SM1CONTR, sizeof(SMcontr), &SMcontr, EC_TIMEOUTRET);\n                   } while (((wkc2 <= 0) || ((SMcontr & 0x02) != (HI_BYTE(SMstat) & 0x02))) && (osal_timer_is_expired(&timer) == FALSE));\n                  do /* wait for read mailbox available */\n                  {\n                     wkc2 = ecx_FPRD(context->port, configadr, ECT_REG_SM1STAT, sizeof(SMstat), &SMstat, EC_TIMEOUTRET);\n                     SMstat = etohs(SMstat);\n                     if (((SMstat & 0x08) == 0) && (timeout > EC_LOCALDELAY))\n                     {\n                        osal_usleep(EC_LOCALDELAY);\n                     }\n                  } while (((wkc2 <= 0) || ((SMstat & 0x08) == 0)) && (osal_timer_is_expired(&timer) == FALSE));\n               }\n            }\n         } while ((wkc <= 0) && (osal_timer_is_expired(&timer) == FALSE)); /* if WKC<=0 repeat */\n      }\n      else /* no read mailbox available */\n      {\n         if (wkc > 0)\n            wkc = EC_TIMEOUT;\n      }\n   }\n\n   return wkc;\n}", "path": "SOEM/soem/ethercatmain.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "OpenEtherCATsociety/SOEM", "stars": 1139, "license": "other", "language": "c", "size": 1296}
{"docstring": "/** Get PDO data from SII PDO section in slave EEPROM.\n *  @param[in]  context = context struct\n *  @param[in]  slave   = slave number\n *  @param[out] PDO     = PDO struct from SII\n *  @param[in]  t       = 0=RXPDO 1=TXPDO\n *  @return mapping size in bits of PDO\n */\n", "func_signal": "uint32 ecx_siiPDO(ecx_contextt *context, uint16 slave, ec_eepromPDOt* PDO, uint8 t)", "code": "{\n   uint16 a , w, c, e, er, Size;\n   uint8 eectl = context->slavelist[slave].eep_pdi;\n\n   Size = 0;\n   PDO->nPDO = 0;\n   PDO->Length = 0;\n   PDO->Index[1] = 0;\n   for (c = 0 ; c < EC_MAXSM ; c++) PDO->SMbitsize[c] = 0;\n   if (t > 1)\n      t = 1;\n   PDO->Startpos = ecx_siifind(context, slave, ECT_SII_PDO + t);\n   if (PDO->Startpos > 0)\n   {\n      a = PDO->Startpos;\n      w = ecx_siigetbyte(context, slave, a++);\n      w += (ecx_siigetbyte(context, slave, a++) << 8);\n      PDO->Length = w;\n      c = 1;\n      /* traverse through all PDOs */\n      do\n      {\n         PDO->nPDO++;\n         PDO->Index[PDO->nPDO] = ecx_siigetbyte(context, slave, a++);\n         PDO->Index[PDO->nPDO] += (ecx_siigetbyte(context, slave, a++) << 8);\n         PDO->BitSize[PDO->nPDO] = 0;\n         c++;\n         e = ecx_siigetbyte(context, slave, a++);\n         PDO->SyncM[PDO->nPDO] = ecx_siigetbyte(context, slave, a++);\n         a += 4;\n         c += 2;\n         if (PDO->SyncM[PDO->nPDO] < EC_MAXSM) /* active and in range SM? */\n         {\n            /* read all entries defined in PDO */\n            for (er = 1; er <= e; er++)\n            {\n               c += 4;\n               a += 5;\n               PDO->BitSize[PDO->nPDO] += ecx_siigetbyte(context, slave, a++);\n               a += 2;\n            }\n            PDO->SMbitsize[ PDO->SyncM[PDO->nPDO] ] += PDO->BitSize[PDO->nPDO];\n            Size += PDO->BitSize[PDO->nPDO];\n            c++;\n         }\n         else /* PDO deactivated because SM is 0xff or > EC_MAXSM */\n         {\n            c += 4 * e;\n            a += 8 * e;\n            c++;\n         }\n         if (PDO->nPDO >= (EC_MAXEEPDO - 1))\n         {\n            c = PDO->Length; /* limit number of PDO entries in buffer */\n         }\n      }\n      while (c < PDO->Length);\n   }\n   if (eectl)\n   {\n      ecx_eeprom2pdi(context, slave); /* if eeprom control was previously pdi then restore */\n   }\n\n   return (Size);\n}", "path": "SOEM/soem/ethercatmain.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "OpenEtherCATsociety/SOEM", "stars": 1139, "license": "other", "language": "c", "size": 1296}
{"docstring": "/** Report Mailbox Emergency Error\n *\n * @param[in]  context        = context struct\n * @param[in]  Slave      = Slave number\n * @param[in]  ErrorCode  = Following EtherCAT specification\n * @param[in]  ErrorReg\n * @param[in]  b1\n * @param[in]  w1\n * @param[in]  w2\n */\n", "func_signal": "static void ecx_mbxemergencyerror(ecx_contextt *context, uint16 Slave,uint16 ErrorCode,uint16 ErrorReg,\n    uint8 b1, uint16 w1, uint16 w2)", "code": "{\n   ec_errort Ec;\n\n   memset(&Ec, 0, sizeof(Ec));\n   Ec.Time = osal_current_time();\n   Ec.Slave = Slave;\n   Ec.Index = 0;\n   Ec.SubIdx = 0;\n   Ec.Etype = EC_ERR_TYPE_EMERGENCY;\n   Ec.ErrorCode = ErrorCode;\n   Ec.ErrorReg = (uint8)ErrorReg;\n   Ec.b1 = b1;\n   Ec.w1 = w1;\n   Ec.w2 = w2;\n   ecx_pusherror(context, &Ec);\n}", "path": "SOEM/soem/ethercatmain.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "OpenEtherCATsociety/SOEM", "stars": 1139, "license": "other", "language": "c", "size": 1296}
{"docstring": "/** Create list over available network adapters.\n *\n * @return First element in list over available network adapters.\n */\n", "func_signal": "ec_adaptert * ec_find_adapters (void)", "code": "{\n   ec_adaptert * ret_adapter;\n\n   ret_adapter = oshw_find_adapters ();\n\n   return ret_adapter;\n}", "path": "SOEM/soem/ethercatmain.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "OpenEtherCATsociety/SOEM", "stars": 1139, "license": "other", "language": "c", "size": 1296}
{"docstring": "/** Get index of next mailbox counter value.\n * Used for Mailbox Link Layer.\n * @param[in] cnt     = Mailbox counter value [0..7]\n * @return next mailbox counter value\n */\n", "func_signal": "uint8 ec_nextmbxcnt(uint8 cnt)", "code": "{\n   cnt++;\n   if (cnt > 7)\n   {\n      cnt = 1; /* wrap around to 1, not 0 */\n   }\n\n   return cnt;\n}", "path": "SOEM/soem/ethercatmain.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "OpenEtherCATsociety/SOEM", "stars": 1139, "license": "other", "language": "c", "size": 1296}
{"docstring": "/** Set eeprom control to master. Only if set to PDI.\n * @param[in] context   = context struct\n * @param[in] slave     = Slave number\n * @return >0 if OK\n */\n", "func_signal": "int ecx_eeprom2master(ecx_contextt *context, uint16 slave)", "code": "{\n   int wkc = 1, cnt = 0;\n   uint16 configadr;\n   uint8 eepctl;\n\n   if ( context->slavelist[slave].eep_pdi )\n   {\n      configadr = context->slavelist[slave].configadr;\n      eepctl = 2;\n      do\n      {\n         wkc = ecx_FPWR(context->port, configadr, ECT_REG_EEPCFG, sizeof(eepctl), &eepctl , EC_TIMEOUTRET); /* force Eeprom from PDI */\n      }\n      while ((wkc <= 0) && (cnt++ < EC_DEFAULTRETRIES));\n      eepctl = 0;\n      cnt = 0;\n      do\n      {\n         wkc = ecx_FPWR(context->port, configadr, ECT_REG_EEPCFG, sizeof(eepctl), &eepctl , EC_TIMEOUTRET); /* set Eeprom to master */\n      }\n      while ((wkc <= 0) && (cnt++ < EC_DEFAULTRETRIES));\n      context->slavelist[slave].eep_pdi = 0;\n   }\n\n   return wkc;\n}", "path": "SOEM/soem/ethercatmain.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "OpenEtherCATsociety/SOEM", "stars": 1139, "license": "other", "language": "c", "size": 1296}
{"docstring": "/** Check if IN mailbox of slave is empty.\n * @param[in] context  = context struct\n * @param[in] slave    = Slave number\n * @param[in] timeout  = Timeout in us\n * @return >0 is success\n */\n", "func_signal": "int ecx_mbxempty(ecx_contextt *context, uint16 slave, int timeout)", "code": "{\n   uint16 configadr;\n   uint8 SMstat;\n   int wkc;\n   osal_timert timer;\n\n   osal_timer_start(&timer, timeout);\n   configadr = context->slavelist[slave].configadr;\n   do\n   {\n      SMstat = 0;\n      wkc = ecx_FPRD(context->port, configadr, ECT_REG_SM0STAT, sizeof(SMstat), &SMstat, EC_TIMEOUTRET);\n      SMstat = etohs(SMstat);\n      if (((SMstat & 0x08) != 0) && (timeout > EC_LOCALDELAY))\n      {\n         osal_usleep(EC_LOCALDELAY);\n      }\n   }\n   while (((wkc <= 0) || ((SMstat & 0x08) != 0)) && (osal_timer_is_expired(&timer) == FALSE));\n\n   if ((wkc > 0) && ((SMstat & 0x08) == 0))\n   {\n      return 1;\n   }\n\n   return 0;\n}", "path": "SOEM/soem/ethercatmain.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "OpenEtherCATsociety/SOEM", "stars": 1139, "license": "other", "language": "c", "size": 1296}
{"docstring": "/** Get SM data from SII SM section in slave EEPROM.\n *  @param[in]  context = context struct\n *  @param[in]  slave   = slave number\n *  @param[out] SM      = first SM struct from SII\n *  @return number of SM's defined in section\n */\n", "func_signal": "uint16 ecx_siiSM(ecx_contextt *context, uint16 slave, ec_eepromSMt* SM)", "code": "{\n   uint16 a,w;\n   uint8 eectl = context->slavelist[slave].eep_pdi;\n\n   SM->nSM = 0;\n   SM->Startpos = ecx_siifind(context, slave, ECT_SII_SM);\n   if (SM->Startpos > 0)\n   {\n      a = SM->Startpos;\n      w = ecx_siigetbyte(context, slave, a++);\n      w += (ecx_siigetbyte(context, slave, a++) << 8);\n      SM->nSM = (uint8)(w / 4);\n      SM->PhStart = ecx_siigetbyte(context, slave, a++);\n      SM->PhStart += (ecx_siigetbyte(context, slave, a++) << 8);\n      SM->Plength = ecx_siigetbyte(context, slave, a++);\n      SM->Plength += (ecx_siigetbyte(context, slave, a++) << 8);\n      SM->Creg = ecx_siigetbyte(context, slave, a++);\n      SM->Sreg = ecx_siigetbyte(context, slave, a++);\n      SM->Activate = ecx_siigetbyte(context, slave, a++);\n      SM->PDIctrl = ecx_siigetbyte(context, slave, a++);\n   }\n   if (eectl)\n   {\n      ecx_eeprom2pdi(context, slave); /* if eeprom control was previously pdi then restore */\n   }\n\n   return SM->nSM;\n}", "path": "SOEM/soem/ethercatmain.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "OpenEtherCATsociety/SOEM", "stars": 1139, "license": "other", "language": "c", "size": 1296}
{"docstring": "/** Write EEPROM to slave bypassing cache.\n * @param[in] context   = context struct\n * @param[in] slave     = Slave number\n * @param[in] eeproma   = (WORD) Address in the EEPROM\n * @param[in] data      = 16bit data\n * @param[in] timeout   = Timeout in us.\n * @return >0 if OK\n */\n", "func_signal": "int ecx_writeeeprom(ecx_contextt *context, uint16 slave, uint16 eeproma, uint16 data, int timeout)", "code": "{\n   uint16 configadr;\n\n   ecx_eeprom2master(context, slave); /* set eeprom control to master */\n   configadr = context->slavelist[slave].configadr;\n   return (ecx_writeeepromFP(context, configadr, eeproma, data, timeout));\n}", "path": "SOEM/soem/ethercatmain.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "OpenEtherCATsociety/SOEM", "stars": 1139, "license": "other", "language": "c", "size": 1296}
{"docstring": "/** Read EEPROM from slave bypassing cache.\n * Parallel read step 1, make request to slave.\n * @param[in] context     = context struct\n * @param[in] slave       = Slave number\n * @param[in] eeproma     = (WORD) Address in the EEPROM\n */\n", "func_signal": "void ecx_readeeprom1(ecx_contextt *context, uint16 slave, uint16 eeproma)", "code": "{\n   uint16 configadr, estat;\n   ec_eepromt ed;\n   int wkc, cnt = 0;\n\n   ecx_eeprom2master(context, slave); /* set eeprom control to master */\n   configadr = context->slavelist[slave].configadr;\n   if (ecx_eeprom_waitnotbusyFP(context, configadr, &estat, EC_TIMEOUTEEP))\n   {\n      if (estat & EC_ESTAT_EMASK) /* error bits are set */\n      {\n         estat = htoes(EC_ECMD_NOP); /* clear error bits */\n         wkc = ecx_FPWR(context->port, configadr, ECT_REG_EEPCTL, sizeof(estat), &estat, EC_TIMEOUTRET3);\n      }\n      ed.comm = htoes(EC_ECMD_READ);\n      ed.addr = htoes(eeproma);\n      ed.d2   = 0x0000;\n      do\n      {\n         wkc = ecx_FPWR(context->port, configadr, ECT_REG_EEPCTL, sizeof(ed), &ed, EC_TIMEOUTRET);\n      }\n      while ((wkc <= 0) && (cnt++ < EC_DEFAULTRETRIES));\n   }\n}", "path": "SOEM/soem/ethercatmain.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "OpenEtherCATsociety/SOEM", "stars": 1139, "license": "other", "language": "c", "size": 1296}
{"docstring": "/** Pops an error from the list.\n *\n * @param[in] context        = context struct\n * @param[out] Ec = Struct describing the error.\n * @return TRUE if an error was popped.\n */\n", "func_signal": "boolean ecx_poperror(ecx_contextt *context, ec_errort *Ec)", "code": "{\n   boolean notEmpty = (context->elist->head != context->elist->tail);\n\n   *Ec = context->elist->Error[context->elist->tail];\n   context->elist->Error[context->elist->tail].Signal = FALSE;\n   if (notEmpty)\n   {\n      context->elist->tail++;\n      if (context->elist->tail > EC_MAXELIST)\n      {\n         context->elist->tail = 0;\n      }\n   }\n   else\n   {\n      *(context->ecaterror) = FALSE;\n   }\n   return notEmpty;\n}", "path": "SOEM/soem/ethercatmain.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "OpenEtherCATsociety/SOEM", "stars": 1139, "license": "other", "language": "c", "size": 1296}
{"docstring": "/** Get next SM data from SII SM section in slave EEPROM.\n *  @param[in]  context = context struct\n *  @param[in]  slave   = slave number\n *  @param[out] SM      = first SM struct from SII\n *  @param[in]  n       = SM number\n *  @return >0 if OK\n */\n", "func_signal": "uint16 ecx_siiSMnext(ecx_contextt *context, uint16 slave, ec_eepromSMt* SM, uint16 n)", "code": "{\n   uint16 a;\n   uint16 retVal = 0;\n   uint8 eectl = context->slavelist[slave].eep_pdi;\n\n   if (n < SM->nSM)\n   {\n      a = SM->Startpos + 2 + (n * 8);\n      SM->PhStart = ecx_siigetbyte(context, slave, a++);\n      SM->PhStart += (ecx_siigetbyte(context, slave, a++) << 8);\n      SM->Plength = ecx_siigetbyte(context, slave, a++);\n      SM->Plength += (ecx_siigetbyte(context, slave, a++) << 8);\n      SM->Creg = ecx_siigetbyte(context, slave, a++);\n      SM->Sreg = ecx_siigetbyte(context, slave, a++);\n      SM->Activate = ecx_siigetbyte(context, slave, a++);\n      SM->PDIctrl = ecx_siigetbyte(context, slave, a++);\n      retVal = 1;\n   }\n   if (eectl)\n   {\n      ecx_eeprom2pdi(context, slave); /* if eeprom control was previously pdi then restore */\n   }\n\n   return retVal;\n}", "path": "SOEM/soem/ethercatmain.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "OpenEtherCATsociety/SOEM", "stars": 1139, "license": "other", "language": "c", "size": 1296}
{"docstring": "/** Dump complete EEPROM data from slave in buffer.\n * @param[in]  context  = context struct\n * @param[in]  slave    = Slave number\n * @param[out] esibuf   = EEPROM data buffer, make sure it is big enough.\n */\n", "func_signal": "void ecx_esidump(ecx_contextt *context, uint16 slave, uint8 *esibuf)", "code": "{\n   uint16 configadr, address, incr;\n   uint64 *p64;\n   uint16 *p16;\n   uint64 edat;\n   uint8 eectl = context->slavelist[slave].eep_pdi;\n\n   ecx_eeprom2master(context, slave); /* set eeprom control to master */\n   configadr = context->slavelist[slave].configadr;\n   address = ECT_SII_START;\n   p16=(uint16*)esibuf;\n   if (context->slavelist[slave].eep_8byte)\n   {\n      incr = 4;\n   }\n   else\n   {\n      incr = 2;\n   }\n   do\n   {\n      edat = ecx_readeepromFP(context, configadr, address, EC_TIMEOUTEEP);\n      p64 = (uint64*)p16;\n      *p64 = edat;\n      p16 += incr;\n      address += incr;\n   } while ((address <= (EC_MAXEEPBUF >> 1)) && ((uint32)edat != 0xffffffff));\n\n   if (eectl)\n   {\n      ecx_eeprom2pdi(context, slave); /* if eeprom control was previously pdi then restore */\n   }\n}", "path": "SOEM/soem/ethercatmain.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "OpenEtherCATsociety/SOEM", "stars": 1139, "license": "other", "language": "c", "size": 1296}
{"docstring": "/* customized variant of memcpy, which can overwrite up to 32 bytes beyond dstEnd */\n", "func_signal": "LZ4_FORCE_O2_INLINE_GCC_PPC64LE\nvoid LZ4_wildCopy32(void* dstPtr, const void* srcPtr, void* dstEnd)", "code": "{\n    BYTE* d = (BYTE*)dstPtr;\n    const BYTE* s = (const BYTE*)srcPtr;\n    BYTE* const e = (BYTE*)dstEnd;\n\n    do { memcpy(d,s,16); memcpy(d+16,s+16,16); d+=32; s+=32; } while (d<e);\n}", "path": "Adrenaline/user/lz4/lz4.c", "commit_date": "2019-02-20 00:00:00", "repo_name": "TheOfficialFloW/Adrenaline", "stars": 1432, "license": "gpl-3.0", "language": "c", "size": 10414}
{"docstring": "/* customized variant of memcpy, which can overwrite up to 8 bytes beyond dstEnd */\n", "func_signal": "LZ4_FORCE_O2_INLINE_GCC_PPC64LE\nvoid LZ4_wildCopy(void* dstPtr, const void* srcPtr, void* dstEnd)", "code": "{\n    BYTE* d = (BYTE*)dstPtr;\n    const BYTE* s = (const BYTE*)srcPtr;\n    BYTE* const e = (BYTE*)dstEnd;\n\n    do { memcpy(d,s,8); d+=8; s+=8; } while (d<e);\n}", "path": "Adrenaline/user/lz4/lz4.c", "commit_date": "2019-02-20 00:00:00", "repo_name": "TheOfficialFloW/Adrenaline", "stars": 1432, "license": "gpl-3.0", "language": "c", "size": 10414}
{"docstring": "// 0x00001A14\n", "func_signal": "static void do_umd_notify(int arg)", "code": "{\n\tif(g_umd_cbid < 0) {\n\t\treturn;\n\t}\n\n\tsceKernelNotifyCallback(g_umd_cbid, arg);\n}", "path": "Adrenaline/cef/inferno/umd.c", "commit_date": "2018-07-09 00:00:00", "repo_name": "TheOfficialFloW/Adrenaline", "stars": 1432, "license": "gpl-3.0", "language": "c", "size": 10414}
{"docstring": "/*\nAdvanced decoding functions :\n*_usingDict() :\n    These decoding functions work the same as \"_continue\" ones,\n    the dictionary must be explicitly provided within parameters\n*/\n", "func_signal": "int LZ4_decompress_safe_usingDict(const char* source, char* dest, int compressedSize, int maxOutputSize, const char* dictStart, int dictSize)", "code": "{\n    if (dictSize==0)\n        return LZ4_decompress_safe(source, dest, compressedSize, maxOutputSize);\n    if (dictStart+dictSize == dest) {\n        if (dictSize >= 64 KB - 1)\n            return LZ4_decompress_safe_withPrefix64k(source, dest, compressedSize, maxOutputSize);\n        return LZ4_decompress_safe_withSmallPrefix(source, dest, compressedSize, maxOutputSize, dictSize);\n    }\n    return LZ4_decompress_safe_forceExtDict(source, dest, compressedSize, maxOutputSize, dictStart, dictSize);\n}", "path": "Adrenaline/user/lz4/lz4.c", "commit_date": "2019-02-20 00:00:00", "repo_name": "TheOfficialFloW/Adrenaline", "stars": 1432, "license": "gpl-3.0", "language": "c", "size": 10414}
{"docstring": "// 0x000002E8\n", "func_signal": "static int IoExit(PspIoDrvArg* arg)", "code": "{\n\tSceUInt timeout = 500000;\n\n\tsceKernelWaitSema(g_umd9660_sema_id, 1, &timeout);\n\tSAFE_FREE(g_sector_buf);\n\tsceKernelDeleteSema(g_umd9660_sema_id);\n\tg_umd9660_sema_id = -1;\n\n\treturn 0;\n}", "path": "Adrenaline/cef/inferno/iodrv_funcs.c", "commit_date": "2018-07-09 00:00:00", "repo_name": "TheOfficialFloW/Adrenaline", "stars": 1432, "license": "gpl-3.0", "language": "c", "size": 10414}
{"docstring": "/**\n * LZ4_compress_fast_extState_fastReset() :\n * A variant of LZ4_compress_fast_extState().\n *\n * Using this variant avoids an expensive initialization step. It is only safe\n * to call if the state buffer is known to be correctly initialized already\n * (see comment in lz4.h on LZ4_resetStream_fast() for a definition of\n * \"correctly initialized\").\n */\n", "func_signal": "int LZ4_compress_fast_extState_fastReset(void* state, const char* src, char* dst, int srcSize, int dstCapacity, int acceleration)", "code": "{\n    LZ4_stream_t_internal* ctx = &((LZ4_stream_t*)state)->internal_donotuse;\n    if (acceleration < 1) acceleration = ACCELERATION_DEFAULT;\n\n    if (dstCapacity >= LZ4_compressBound(srcSize)) {\n        if (srcSize < LZ4_64Klimit) {\n            const tableType_t tableType = byU16;\n            LZ4_prepareTable(ctx, srcSize, tableType);\n            if (ctx->currentOffset) {\n                return LZ4_compress_generic(ctx, src, dst, srcSize, NULL, 0, notLimited, tableType, noDict, dictSmall, acceleration);\n            } else {\n                return LZ4_compress_generic(ctx, src, dst, srcSize, NULL, 0, notLimited, tableType, noDict, noDictIssue, acceleration);\n            }\n        } else {\n            const tableType_t tableType = ((sizeof(void*)==4) && ((uptrval)src > MAX_DISTANCE)) ? byPtr : byU32;\n            LZ4_prepareTable(ctx, srcSize, tableType);\n            return LZ4_compress_generic(ctx, src, dst, srcSize, NULL, 0, notLimited, tableType, noDict, noDictIssue, acceleration);\n        }\n    } else {\n        if (srcSize < LZ4_64Klimit) {\n            const tableType_t tableType = byU16;\n            LZ4_prepareTable(ctx, srcSize, tableType);\n            if (ctx->currentOffset) {\n                return LZ4_compress_generic(ctx, src, dst, srcSize, NULL, dstCapacity, limitedOutput, tableType, noDict, dictSmall, acceleration);\n            } else {\n                return LZ4_compress_generic(ctx, src, dst, srcSize, NULL, dstCapacity, limitedOutput, tableType, noDict, noDictIssue, acceleration);\n            }\n        } else {\n            const tableType_t tableType = ((sizeof(void*)==4) && ((uptrval)src > MAX_DISTANCE)) ? byPtr : byU32;\n            LZ4_prepareTable(ctx, srcSize, tableType);\n            return LZ4_compress_generic(ctx, src, dst, srcSize, NULL, dstCapacity, limitedOutput, tableType, noDict, noDictIssue, acceleration);\n        }\n    }\n}", "path": "Adrenaline/user/lz4/lz4.c", "commit_date": "2019-02-20 00:00:00", "repo_name": "TheOfficialFloW/Adrenaline", "stars": 1432, "license": "gpl-3.0", "language": "c", "size": 10414}
{"docstring": "/* LZ4_FORCE_MEMORY_ACCESS */\n", "func_signal": "static U16 LZ4_readLE16(const void* memPtr)", "code": "{\n    if (LZ4_isLittleEndian()) {\n        return LZ4_read16(memPtr);\n    } else {\n        const BYTE* p = (const BYTE*)memPtr;\n        return (U16)((U16)p[0] + (p[1]<<8));\n    }\n}", "path": "Adrenaline/user/lz4/lz4.c", "commit_date": "2019-02-20 00:00:00", "repo_name": "TheOfficialFloW/Adrenaline", "stars": 1432, "license": "gpl-3.0", "language": "c", "size": 10414}
{"docstring": "/*! LZ4_setStreamDecode() :\n *  Use this function to instruct where to find the dictionary.\n *  This function is not necessary if previous data is still available where it was decoded.\n *  Loading a size of 0 is allowed (same effect as no dictionary).\n * @return : 1 if OK, 0 if error\n */\n", "func_signal": "int LZ4_setStreamDecode (LZ4_streamDecode_t* LZ4_streamDecode, const char* dictionary, int dictSize)", "code": "{\n    LZ4_streamDecode_t_internal* lz4sd = &LZ4_streamDecode->internal_donotuse;\n    lz4sd->prefixSize = (size_t) dictSize;\n    lz4sd->prefixEnd = (const BYTE*) dictionary + dictSize;\n    lz4sd->externalDict = NULL;\n    lz4sd->extDictSize  = 0;\n    return 1;\n}", "path": "Adrenaline/user/lz4/lz4.c", "commit_date": "2019-02-20 00:00:00", "repo_name": "TheOfficialFloW/Adrenaline", "stars": 1432, "license": "gpl-3.0", "language": "c", "size": 10414}
{"docstring": "/*===== Instantiate the API decoding functions. =====*/\n", "func_signal": "LZ4_FORCE_O2_GCC_PPC64LE\nint LZ4_decompress_safe(const char* source, char* dest, int compressedSize, int maxDecompressedSize)", "code": "{\n    return LZ4_decompress_generic(source, dest, compressedSize, maxDecompressedSize,\n                                  endOnInputSize, decode_full_block, noDict,\n                                  (BYTE*)dest, NULL, 0);\n}", "path": "Adrenaline/user/lz4/lz4.c", "commit_date": "2019-02-20 00:00:00", "repo_name": "TheOfficialFloW/Adrenaline", "stars": 1432, "license": "gpl-3.0", "language": "c", "size": 10414}
{"docstring": "/*\n*_continue() :\n    These decoding functions allow decompression of multiple blocks in \"streaming\" mode.\n    Previously decoded blocks must still be available at the memory position where they were decoded.\n    If it's not possible, save the relevant part of decoded data into a safe buffer,\n    and indicate where it stands using LZ4_setStreamDecode()\n*/\n", "func_signal": "LZ4_FORCE_O2_GCC_PPC64LE\nint LZ4_decompress_safe_continue (LZ4_streamDecode_t* LZ4_streamDecode, const char* source, char* dest, int compressedSize, int maxOutputSize)", "code": "{\n    LZ4_streamDecode_t_internal* lz4sd = &LZ4_streamDecode->internal_donotuse;\n    int result;\n\n    if (lz4sd->prefixSize == 0) {\n        /* The first call, no dictionary yet. */\n        assert(lz4sd->extDictSize == 0);\n        result = LZ4_decompress_safe(source, dest, compressedSize, maxOutputSize);\n        if (result <= 0) return result;\n        lz4sd->prefixSize = result;\n        lz4sd->prefixEnd = (BYTE*)dest + result;\n    } else if (lz4sd->prefixEnd == (BYTE*)dest) {\n        /* They're rolling the current segment. */\n        if (lz4sd->prefixSize >= 64 KB - 1)\n            result = LZ4_decompress_safe_withPrefix64k(source, dest, compressedSize, maxOutputSize);\n        else if (lz4sd->extDictSize == 0)\n            result = LZ4_decompress_safe_withSmallPrefix(source, dest, compressedSize, maxOutputSize,\n                                                         lz4sd->prefixSize);\n        else\n            result = LZ4_decompress_safe_doubleDict(source, dest, compressedSize, maxOutputSize,\n                                                    lz4sd->prefixSize, lz4sd->externalDict, lz4sd->extDictSize);\n        if (result <= 0) return result;\n        lz4sd->prefixSize += result;\n        lz4sd->prefixEnd  += result;\n    } else {\n        /* The buffer wraps around, or they're switching to another buffer. */\n        lz4sd->extDictSize = lz4sd->prefixSize;\n        lz4sd->externalDict = lz4sd->prefixEnd - lz4sd->extDictSize;\n        result = LZ4_decompress_safe_forceExtDict(source, dest, compressedSize, maxOutputSize,\n                                                  lz4sd->externalDict, lz4sd->extDictSize);\n        if (result <= 0) return result;\n        lz4sd->prefixSize = result;\n        lz4sd->prefixEnd  = (BYTE*)dest + result;\n    }\n\n    return result;\n}", "path": "Adrenaline/user/lz4/lz4.c", "commit_date": "2019-02-20 00:00:00", "repo_name": "TheOfficialFloW/Adrenaline", "stars": 1432, "license": "gpl-3.0", "language": "c", "size": 10414}
{"docstring": "// 0x000018A4\n// call @PRO_Inferno_Driver:sceUmd,0xF60013F8@\n", "func_signal": "void sceUmdSetDriveStatus(int status)", "code": "{\n\tint intr;\n\n\tintr = sceKernelCpuSuspendIntr();\n\n\tif(!(status & PSP_UMD_NOT_PRESENT)) {\n\t\tif(status & (PSP_UMD_PRESENT | PSP_UMD_CHANGED | PSP_UMD_INITING | PSP_UMD_INITED | PSP_UMD_READY)) {\n\t\t\tg_drive_status &= ~PSP_UMD_NOT_PRESENT;\n\t\t}\n\t} else {\n\t\tg_drive_status &= ~(PSP_UMD_PRESENT | PSP_UMD_CHANGED | PSP_UMD_INITING | PSP_UMD_INITED | PSP_UMD_READY);\n\t}\n\n\tif(!(status & PSP_UMD_INITING)) {\n\t\tif(status & (PSP_UMD_INITED | PSP_UMD_READY)) {\n\t\t\tg_drive_status &= ~PSP_UMD_INITING;\n\t\t}\n\t} else {\n\t\tg_drive_status &= ~(PSP_UMD_INITED | PSP_UMD_READY);\n\t}\n\n\tif(!(status & PSP_UMD_READY)) {\n\t\tg_drive_status &= ~PSP_UMD_READY;\n\t}\n\n\tg_drive_status |= status;\n\n\tif(g_drive_status & PSP_UMD_READY) {\n\t\tg_drive_status |= PSP_UMD_INITED;\n\t}\n\n\tif(g_drive_status & PSP_UMD_INITED) {\n\t\tg_drive_status |= PSP_UMD_PRESENT;\n\t\tsceUmdSetErrorStatus(0);\n\t}\n\n\tsceKernelSetEventFlag(g_drive_status_evf, g_drive_status);\n\tsceKernelCpuResumeIntr(intr);\n\tdo_umd_notify(g_drive_status);\n}", "path": "Adrenaline/cef/inferno/umd.c", "commit_date": "2018-07-09 00:00:00", "repo_name": "TheOfficialFloW/Adrenaline", "stars": 1432, "license": "gpl-3.0", "language": "c", "size": 10414}
{"docstring": "/* hidden debug function */\n/* strangely enough, gcc generates faster code when this function is uncommented, even if unused */\n", "func_signal": "int LZ4_compress_fast_force(const char* src, char* dst, int srcSize, int dstCapacity, int acceleration)", "code": "{\n    LZ4_stream_t ctx;\n    LZ4_resetStream(&ctx);\n\n    if (srcSize < LZ4_64Klimit) {\n        return LZ4_compress_generic(&ctx.internal_donotuse, src, dst, srcSize, NULL, dstCapacity, limitedOutput, byU16,    noDict, noDictIssue, acceleration);\n    } else {\n        tableType_t const addrMode = (sizeof(void*) > 4) ? byU32 : byPtr;\n        return LZ4_compress_generic(&ctx.internal_donotuse, src, dst, srcSize, NULL, dstCapacity, limitedOutput, addrMode, noDict, noDictIssue, acceleration);\n    }\n}", "path": "Adrenaline/user/lz4/lz4.c", "commit_date": "2019-02-20 00:00:00", "repo_name": "TheOfficialFloW/Adrenaline", "stars": 1432, "license": "gpl-3.0", "language": "c", "size": 10414}
{"docstring": "// 0x0000083C\n", "func_signal": "static int IoIoctl(PspIoDrvFileArg *arg, unsigned int cmd, void *indata, int inlen, void *outdata, int outlen)", "code": "{\n\tint ret, idx;\n\n\tidx = (int)arg->arg;\n\n\tif(cmd == 0x01F010DB) {\n\t\tret = 0;\n\t\tgoto exit;\n\t} else if(cmd == 0x01D20001) {\n\t\t/* added more data len checks */\n\t\tif(outdata == NULL || outlen < 4) {\n\t\t\tret = 0x80010016;\n\t\t\tgoto exit;\n\t\t}\n\t\t\n\t\t/* Read fd current offset */\n\t\tret = sceKernelWaitSema(g_umd9660_sema_id, 1, NULL);\n\n\t\tif(ret < 0) {\n\t\t\tret = -1;\n\t\t\tgoto exit;\n\t\t}\n\n\t\t_sw(g_open_slot[idx].offset, (u32)outdata);\n\t\tret = sceKernelSignalSema(g_umd9660_sema_id, 1);\n\n\t\tif(ret < 0) {\n\t\t\tret = -1;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tret = 0;\n\t\tgoto exit;\n\t} else if(cmd == 0x01F100A6) {\n\t\t/* UMD file seek whence */\n\t\tstruct IoIoctlSeekCmd *seek_cmd;\n\n\t\tif (indata == NULL || inlen < sizeof(struct IoIoctlSeekCmd)) {\n\t\t\tret = 0x80010016;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tseek_cmd = (struct IoIoctlSeekCmd *)indata;\n\t\tret = IoLseek(arg, seek_cmd->offset, seek_cmd->whence);\n\t\tgoto exit;\n\t} else if(cmd == 0x01F30003) {\n\t\tu32 len;\n\n\t\tif(indata == NULL || inlen < 4) {\n\t\t\tret = 0x80010016;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tlen = *(u32*)indata;\n\n\t\tif(outdata == NULL || outlen < len) {\n\t\t\tret = 0x80010016;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tret = IoRead(arg, outdata, len);\n\t\tgoto exit;\n\t}\n\n\tprintk(\"%s: Unknown ioctl 0x%08X\\n\", __func__, cmd);\n\tret = 0x80010086;\n\nexit:\n\tprintk(\"%s: cmd:0x%08X -> 0x%08X\\n\", __func__, cmd, ret);\n\n\treturn ret;\n}", "path": "Adrenaline/cef/inferno/iodrv_funcs.c", "commit_date": "2018-07-09 00:00:00", "repo_name": "TheOfficialFloW/Adrenaline", "stars": 1432, "license": "gpl-3.0", "language": "c", "size": 10414}
{"docstring": "/* LZ4_getIndexOnHash() :\n * Index of match position registered in hash table.\n * hash position must be calculated by using base+index, or dictBase+index.\n * Assumption 1 : only valid if tableType == byU32 or byU16.\n * Assumption 2 : h is presumed valid (within limits of hash table)\n */\n", "func_signal": "static U32 LZ4_getIndexOnHash(U32 h, const void* tableBase, tableType_t tableType)", "code": "{\n    LZ4_STATIC_ASSERT(LZ4_MEMORY_USAGE > 2);\n    if (tableType == byU32) {\n        const U32* const hashTable = (const U32*) tableBase;\n        assert(h < (1U << (LZ4_MEMORY_USAGE-2)));\n        return hashTable[h];\n    }\n    if (tableType == byU16) {\n        const U16* const hashTable = (const U16*) tableBase;\n        assert(h < (1U << (LZ4_MEMORY_USAGE-1)));\n        return hashTable[h];\n    }\n    assert(0); return 0;  /* forbidden case */\n}", "path": "Adrenaline/user/lz4/lz4.c", "commit_date": "2019-02-20 00:00:00", "repo_name": "TheOfficialFloW/Adrenaline", "stars": 1432, "license": "gpl-3.0", "language": "c", "size": 10414}
{"docstring": "/*! LZ4_saveDict() :\n *  If previously compressed data block is not guaranteed to remain available at its memory location,\n *  save it into a safer place (char* safeBuffer).\n *  Note : you don't need to call LZ4_loadDict() afterwards,\n *         dictionary is immediately usable, you can therefore call LZ4_compress_fast_continue().\n *  Return : saved dictionary size in bytes (necessarily <= dictSize), or 0 if error.\n */\n", "func_signal": "int LZ4_saveDict (LZ4_stream_t* LZ4_dict, char* safeBuffer, int dictSize)", "code": "{\n    LZ4_stream_t_internal* const dict = &LZ4_dict->internal_donotuse;\n    const BYTE* const previousDictEnd = dict->dictionary + dict->dictSize;\n\n    if ((U32)dictSize > 64 KB) dictSize = 64 KB;   /* useless to define a dictionary > 64 KB */\n    if ((U32)dictSize > dict->dictSize) dictSize = dict->dictSize;\n\n    memmove(safeBuffer, previousDictEnd - dictSize, dictSize);\n\n    dict->dictionary = (const BYTE*)safeBuffer;\n    dict->dictSize = (U32)dictSize;\n\n    return dictSize;\n}", "path": "Adrenaline/user/lz4/lz4.c", "commit_date": "2019-02-20 00:00:00", "repo_name": "TheOfficialFloW/Adrenaline", "stars": 1432, "license": "gpl-3.0", "language": "c", "size": 10414}
{"docstring": "/*! LZ4_decoderRingBufferSize() :\n *  when setting a ring buffer for streaming decompression (optional scenario),\n *  provides the minimum size of this ring buffer\n *  to be compatible with any source respecting maxBlockSize condition.\n *  Note : in a ring buffer scenario,\n *  blocks are presumed decompressed next to each other.\n *  When not enough space remains for next block (remainingSize < maxBlockSize),\n *  decoding resumes from beginning of ring buffer.\n * @return : minimum ring buffer size,\n *           or 0 if there is an error (invalid maxBlockSize).\n */\n", "func_signal": "int LZ4_decoderRingBufferSize(int maxBlockSize)", "code": "{\n    if (maxBlockSize < 0) return 0;\n    if (maxBlockSize > LZ4_MAX_INPUT_SIZE) return 0;\n    if (maxBlockSize < 16) maxBlockSize = 16;\n    return LZ4_DECODER_RING_BUFFER_SIZE(maxBlockSize);\n}", "path": "Adrenaline/user/lz4/lz4.c", "commit_date": "2019-02-20 00:00:00", "repo_name": "TheOfficialFloW/Adrenaline", "stars": 1432, "license": "gpl-3.0", "language": "c", "size": 10414}
{"docstring": "/*-******************************\n*  Compression functions\n********************************/\n", "func_signal": "static U32 LZ4_hash4(U32 sequence, tableType_t const tableType)", "code": "{\n    if (tableType == byU16)\n        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));\n    else\n        return ((sequence * 2654435761U) >> ((MINMATCH*8)-LZ4_HASHLOG));\n}", "path": "Adrenaline/user/lz4/lz4.c", "commit_date": "2019-02-20 00:00:00", "repo_name": "TheOfficialFloW/Adrenaline", "stars": 1432, "license": "gpl-3.0", "language": "c", "size": 10414}
{"docstring": "/* lie to the compiler about data alignment; use with caution */\n", "func_signal": "static U16 LZ4_read16(const void* memPtr)", "code": "{ return *(const U16*) memPtr; }\nstatic U32 LZ4_read32(const void* memPtr) { return *(const U32*) memPtr; }\nstatic reg_t LZ4_read_ARCH(const void* memPtr) { return *(const reg_t*) memPtr; }\n\nstatic void LZ4_write16(void* memPtr, U16 value) { *(U16*)memPtr = value; }\nstatic void LZ4_write32(void* memPtr, U32 value) { *(U32*)memPtr = value; }\n\n#elif defined(LZ4_FORCE_MEMORY_ACCESS) && (LZ4_FORCE_MEMORY_ACCESS==1)\n\n/* __pack instructions are safer, but compiler specific, hence potentially problematic for some compilers */\n/* currently only defined for gcc and icc */\ntypedef union { U16 u16; U32 u32; reg_t uArch; } __attribute__((packed)) unalign;\n\nstatic U16 LZ4_read16(const void* ptr) { return ((const unalign*)ptr)->u16; }\nstatic U32 LZ4_read32(const void* ptr) { return ((const unalign*)ptr)->u32; }\nstatic reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }\n\nstatic void LZ4_write16(void* memPtr, U16 value) { ((unalign*)memPtr)->u16 = value; }\nstatic void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }\n\n#else  /* safe and portable access through memcpy() */\n\nstatic U16 LZ4_read16(const void* memPtr)\n{\n    U16 val; memcpy(&val, memPtr, sizeof(val)); return val;\n}", "path": "Adrenaline/user/lz4/lz4.c", "commit_date": "2019-02-20 00:00:00", "repo_name": "TheOfficialFloW/Adrenaline", "stars": 1432, "license": "gpl-3.0", "language": "c", "size": 10414}
{"docstring": "/*===== streaming decompression functions =====*/\n", "func_signal": "LZ4_streamDecode_t* LZ4_createStreamDecode(void)", "code": "{\n    LZ4_streamDecode_t* lz4s = (LZ4_streamDecode_t*) ALLOC_AND_ZERO(sizeof(LZ4_streamDecode_t));\n    LZ4_STATIC_ASSERT(LZ4_STREAMDECODESIZE >= sizeof(LZ4_streamDecode_t_internal));    /* A compilation error here means LZ4_STREAMDECODESIZE is not large enough */\n    return lz4s;\n}", "path": "Adrenaline/user/lz4/lz4.c", "commit_date": "2019-02-20 00:00:00", "repo_name": "TheOfficialFloW/Adrenaline", "stars": 1432, "license": "gpl-3.0", "language": "c", "size": 10414}
{"docstring": "/* Exported, an obsolete API function. */\n", "func_signal": "int LZ4_decompress_safe_withPrefix64k(const char* source, char* dest, int compressedSize, int maxOutputSize)", "code": "{\n    return LZ4_decompress_generic(source, dest, compressedSize, maxOutputSize,\n                                  endOnInputSize, decode_full_block, withPrefix64k,\n                                  (BYTE*)dest - 64 KB, NULL, 0);\n}", "path": "Adrenaline/user/lz4/lz4.c", "commit_date": "2019-02-20 00:00:00", "repo_name": "TheOfficialFloW/Adrenaline", "stars": 1432, "license": "gpl-3.0", "language": "c", "size": 10414}
{"docstring": "/// Check if a timer is running.\n/// \\note API identical to osTimerIsRunning\n", "func_signal": "static uint32_t svcRtxTimerIsRunning (osTimerId_t timer_id)", "code": "{\n  os_timer_t *timer = osRtxTimerId(timer_id);\n  uint32_t    is_running;\n\n  // Check parameters\n  if ((timer == NULL) || (timer->id != osRtxIdTimer)) {\n    EvrRtxTimerIsRunning(timer, 0U);\n    //lint -e{904} \"Return statement before end of function\" [MISRA Note 1]\n    return 0U;\n  }\n\n  if (timer->state == osRtxTimerRunning) {\n    EvrRtxTimerIsRunning(timer, 1U);\n    is_running = 1U;\n  } else {\n    EvrRtxTimerIsRunning(timer, 0U);\n    is_running = 0;\n  }\n\n  return is_running;\n}", "path": "CMSIS_5/CMSIS/RTOS2/RTX/Source/rtx_timer.c", "commit_date": "2019-03-18 00:00:00", "repo_name": "ARM-software/CMSIS_5", "stars": 1191, "license": "apache-2.0", "language": "c", "size": 262506}
{"docstring": "/// Stop a timer.\n/// \\note API identical to osTimerStop\n", "func_signal": "static osStatus_t svcRtxTimerStop (osTimerId_t timer_id)", "code": "{\n  os_timer_t *timer = osRtxTimerId(timer_id);\n\n  // Check parameters\n  if ((timer == NULL) || (timer->id != osRtxIdTimer)) {\n    EvrRtxTimerError(timer, (int32_t)osErrorParameter);\n    //lint -e{904} \"Return statement before end of function\" [MISRA Note 1]\n    return osErrorParameter;\n  }\n\n  // Check object state\n  if (timer->state != osRtxTimerRunning) {\n    EvrRtxTimerError(timer, (int32_t)osErrorResource);\n    //lint -e{904} \"Return statement before end of function\" [MISRA Note 1]\n    return osErrorResource;\n  }\n\n  timer->state = osRtxTimerStopped;\n\n  TimerRemove(timer);\n\n  EvrRtxTimerStopped(timer);\n\n  return osOK;\n}", "path": "CMSIS_5/CMSIS/RTOS2/RTX/Source/rtx_timer.c", "commit_date": "2019-03-18 00:00:00", "repo_name": "ARM-software/CMSIS_5", "stars": 1191, "license": "apache-2.0", "language": "c", "size": 262506}
{"docstring": "/*--------------------------- os_set_env ------------------------------------*/\n", "func_signal": "__asm void os_set_env (void)", "code": "{\n   /* Switch to Unprivileged/Privileged Thread mode, use PSP. */\n        MOV     R0,SP                   ; PSP = MSP\n        MSR     PSP,R0\n        LDR     R0,=__cpp(&os_flags)\n        LDRB    R0,[R0]\n        LSLS    R0,#31\n        MOVNE   R0,#0x02                ; Privileged Thread mode, use PSP\n        MOVEQ   R0,#0x03                ; Unprivileged Thread mode, use PSP\n        MSR     CONTROL,R0\n        BX      LR\n\n        ALIGN\n}", "path": "CMSIS_5/CMSIS/RTOS/RTX/SRC/ARM/HAL_CM4.c", "commit_date": "2017-05-09 00:00:00", "repo_name": "ARM-software/CMSIS_5", "stars": 1191, "license": "apache-2.0", "language": "c", "size": 262506}
{"docstring": "/// Create and Initialize a timer.\n", "func_signal": "osTimerId_t osTimerNew (osTimerFunc_t func, osTimerType_t type, void *argument, const osTimerAttr_t *attr)", "code": "{\n  osTimerId_t timer_id;\n\n  EvrRtxTimerNew(func, type, argument, attr);\n  if (IsIrqMode() || IsIrqMasked()) {\n    EvrRtxTimerError(NULL, (int32_t)osErrorISR);\n    timer_id = NULL;\n  } else {\n    timer_id = __svcTimerNew(func, type, argument, attr);\n  }\n  return timer_id;\n}", "path": "CMSIS_5/CMSIS/RTOS2/RTX/Source/rtx_timer.c", "commit_date": "2019-03-18 00:00:00", "repo_name": "ARM-software/CMSIS_5", "stars": 1191, "license": "apache-2.0", "language": "c", "size": 262506}
{"docstring": "/// Timer Thread\n", "func_signal": "__WEAK __NO_RETURN void osRtxTimerThread (void *argument)", "code": "{\n  os_timer_finfo_t finfo;\n  osStatus_t       status;\n  (void)           argument;\n\n  osRtxInfo.timer.mq = osRtxMessageQueueId(\n    osMessageQueueNew(osRtxConfig.timer_mq_mcnt, sizeof(os_timer_finfo_t), osRtxConfig.timer_mq_attr)\n  );\n  osRtxInfo.timer.tick = osRtxTimerTick;\n\n  for (;;) {\n    //lint -e{934} \"Taking address of near auto variable\"\n    status = osMessageQueueGet(osRtxInfo.timer.mq, &finfo, NULL, osWaitForever);\n    if (status == osOK) {\n      EvrRtxTimerCallback(finfo.func, finfo.arg);\n      (finfo.func)(finfo.arg);\n    }\n  }\n}", "path": "CMSIS_5/CMSIS/RTOS2/RTX/Source/rtx_timer.c", "commit_date": "2019-03-18 00:00:00", "repo_name": "ARM-software/CMSIS_5", "stars": 1191, "license": "apache-2.0", "language": "c", "size": 262506}
{"docstring": "/*----------------------------------------------------------------------------\n  Reset Handler called on controller reset\n *----------------------------------------------------------------------------*/\n", "func_signal": "__NO_RETURN void Reset_Handler(void)", "code": "{\n  SystemInit();                             /* CMSIS System Initialization */\n  __PROGRAM_START();                        /* Enter PreMain (C library entry point) */\n}", "path": "CMSIS_5/CMSIS/RTOS2/RTX/Examples/MemPool/RTE/Device/ARMCM3/startup_ARMCM3.c", "commit_date": "2020-04-06 00:00:00", "repo_name": "ARM-software/CMSIS_5", "stars": 1191, "license": "apache-2.0", "language": "c", "size": 262506}
{"docstring": "/// Start or restart a timer.\n/// \\note API identical to osTimerStart\n", "func_signal": "static osStatus_t svcRtxTimerStart (osTimerId_t timer_id, uint32_t ticks)", "code": "{\n  os_timer_t *timer = osRtxTimerId(timer_id);\n\n  // Check parameters\n  if ((timer == NULL) || (timer->id != osRtxIdTimer) || (ticks == 0U)) {\n    EvrRtxTimerError(timer, (int32_t)osErrorParameter);\n    //lint -e{904} \"Return statement before end of function\" [MISRA Note 1]\n    return osErrorParameter;\n  }\n\n  if (timer->state == osRtxTimerRunning) {\n    TimerRemove(timer);\n  } else {\n    if (osRtxInfo.timer.tick == NULL) {\n      EvrRtxTimerError(timer, (int32_t)osErrorResource);\n      //lint -e{904} \"Return statement before end of function\" [MISRA Note 1]\n      return osErrorResource;\n    } else {\n      timer->state = osRtxTimerRunning;\n      timer->load  = ticks;\n    }\n  }\n\n  TimerInsert(timer, ticks);\n\n  EvrRtxTimerStarted(timer);\n\n  return osOK;\n}", "path": "CMSIS_5/CMSIS/RTOS2/RTX/Source/rtx_timer.c", "commit_date": "2019-03-18 00:00:00", "repo_name": "ARM-software/CMSIS_5", "stars": 1191, "license": "apache-2.0", "language": "c", "size": 262506}
{"docstring": "/*-------------------------- OS_Tick_Handler --------------------------------*/\n", "func_signal": "__asm void OS_Tick_Handler (void)", "code": "{\n        PRESERVE8\n\n        PUSH    {R4,LR}                 ; Save EXC_RETURN\n        BL      __cpp(os_tick_irqack)\n        BL      __cpp(rt_systick)\n        B       Sys_Switch\n\n        ALIGN\n}", "path": "CMSIS_5/CMSIS/RTOS/RTX/SRC/ARM/HAL_CM4.c", "commit_date": "2017-05-09 00:00:00", "repo_name": "ARM-software/CMSIS_5", "stars": 1191, "license": "apache-2.0", "language": "c", "size": 262506}
{"docstring": "/*-------------------------- SysTick_Handler --------------------------------*/\n", "func_signal": "__asm void SysTick_Handler (void)", "code": "{\n        PRESERVE8\n\n#ifdef  IFX_XMC4XXX\n        EXPORT  SysTick_Handler_Veneer\nSysTick_Handler_Veneer        \n#endif\n\n        PUSH    {R4,LR}                 ; Save EXC_RETURN\n        BL      __cpp(rt_systick)\n        B       Sys_Switch\n\n        ALIGN\n}", "path": "CMSIS_5/CMSIS/RTOS/RTX/SRC/ARM/HAL_CM4.c", "commit_date": "2017-05-09 00:00:00", "repo_name": "ARM-software/CMSIS_5", "stars": 1191, "license": "apache-2.0", "language": "c", "size": 262506}
{"docstring": "/*--------------------------- rt_set_PSP ------------------------------------*/\n", "func_signal": "__asm void rt_set_PSP (U32 stack)", "code": "{\n        MSR     PSP,R0\n        BX      LR\n}", "path": "CMSIS_5/CMSIS/RTOS/RTX/SRC/ARM/HAL_CM4.c", "commit_date": "2017-05-09 00:00:00", "repo_name": "ARM-software/CMSIS_5", "stars": 1191, "license": "apache-2.0", "language": "c", "size": 262506}
{"docstring": "/// Start or restart a timer.\n", "func_signal": "osStatus_t osTimerStart (osTimerId_t timer_id, uint32_t ticks)", "code": "{\n  osStatus_t status;\n\n  EvrRtxTimerStart(timer_id, ticks);\n  if (IsIrqMode() || IsIrqMasked()) {\n    EvrRtxTimerError(timer_id, (int32_t)osErrorISR);\n    status = osErrorISR;\n  } else {\n    status = __svcTimerStart(timer_id, ticks);\n  }\n  return status;\n}", "path": "CMSIS_5/CMSIS/RTOS2/RTX/Source/rtx_timer.c", "commit_date": "2019-03-18 00:00:00", "repo_name": "ARM-software/CMSIS_5", "stars": 1191, "license": "apache-2.0", "language": "c", "size": 262506}
{"docstring": "/*-------------------------- PendSV_Handler ---------------------------------*/\n", "func_signal": "__asm void PendSV_Handler (void)", "code": "{\n        PRESERVE8\n\n#ifdef  IFX_XMC4XXX\n        EXPORT  PendSV_Handler_Veneer\nPendSV_Handler_Veneer        \n#endif\n\n        PUSH    {R4,LR}                 ; Save EXC_RETURN\n        BL      __cpp(rt_pop_req)\n\nSys_Switch\n        POP     {R4,LR}                 ; Restore EXC_RETURN\n\n        LDR     R3,=__cpp(&os_tsk)\n        LDM     R3,{R1,R2}              ; os_tsk.run, os_tsk.next\n        CMP     R1,R2\n#ifdef  IFX_XMC4XXX\n        PUSHEQ  {LR}\n        POPEQ   {PC}\n#else\n        BXEQ    LR                      ; RETI, no task switch\n#endif\n\n        MRS     R12,PSP                 ; Read PSP\n        TST     LR,#0x10                ; is it extended frame?\n        VSTMDBEQ R12!,{S16-S31}         ; yes, stack also VFP hi-regs\n        MOVEQ   R0,#0x01                ; os_tsk->stack_frame val\n        MOVNE   R0,#0x00\n        STRB    R0,[R1,#TCB_STACKF]     ; os_tsk.run->stack_frame = val\n        STMDB   R12!,{R4-R11}           ; Save Old context\n        STR     R12,[R1,#TCB_TSTACK]    ; Update os_tsk.run->tsk_stack\n\n        PUSH    {R2,R3}\n        BL      rt_stk_check            ; Check for Stack overflow\n        POP     {R2,R3}\n\n        STR     R2,[R3]                 ; os_tsk.run = os_tsk.next\n\n        LDR     R12,[R2,#TCB_TSTACK]    ; os_tsk.next->tsk_stack\n        LDMIA   R12!,{R4-R11}           ; Restore New Context\n        LDRB    R0,[R2,#TCB_STACKF]     ; Stack Frame\n        CMP     R0,#0                   ; Basic/Extended Stack Frame\n        MVNEQ   LR,#:NOT:0xFFFFFFFD     ; set EXC_RETURN value\n        MVNNE   LR,#:NOT:0xFFFFFFED\n        VLDMIANE R12!,{S16-S31}         ; restore VFP hi-regs\n        MSR     PSP,R12                 ; Write PSP\n\nSys_Exit\n#ifdef  IFX_XMC4XXX\n        PUSH    {LR}\n        POP     {PC}\n#else\n        BX      LR                      ; Return to Thread Mode\n#endif\n\n        ALIGN\n}", "path": "CMSIS_5/CMSIS/RTOS/RTX/SRC/ARM/HAL_CM4.c", "commit_date": "2017-05-09 00:00:00", "repo_name": "ARM-software/CMSIS_5", "stars": 1191, "license": "apache-2.0", "language": "c", "size": 262506}
{"docstring": "/// Get name of a timer.\n/// \\note API identical to osTimerGetName\n", "func_signal": "static const char *svcRtxTimerGetName (osTimerId_t timer_id)", "code": "{\n  os_timer_t *timer = osRtxTimerId(timer_id);\n\n  // Check parameters\n  if ((timer == NULL) || (timer->id != osRtxIdTimer)) {\n    EvrRtxTimerGetName(timer, NULL);\n    //lint -e{904} \"Return statement before end of function\" [MISRA Note 1]\n    return NULL;\n  }\n\n  EvrRtxTimerGetName(timer, timer->name);\n\n  return timer->name;\n}", "path": "CMSIS_5/CMSIS/RTOS2/RTX/Source/rtx_timer.c", "commit_date": "2019-03-18 00:00:00", "repo_name": "ARM-software/CMSIS_5", "stars": 1191, "license": "apache-2.0", "language": "c", "size": 262506}
{"docstring": "/*--------------------------- rt_get_PSP ------------------------------------*/\n", "func_signal": "__asm U32 rt_get_PSP (void)", "code": "{\n        MRS     R0,PSP\n        BX      LR\n}", "path": "CMSIS_5/CMSIS/RTOS/RTX/SRC/ARM/HAL_CM4.c", "commit_date": "2017-05-09 00:00:00", "repo_name": "ARM-software/CMSIS_5", "stars": 1191, "license": "apache-2.0", "language": "c", "size": 262506}
{"docstring": "/*--------------------------- _alloc_box ------------------------------------*/\n", "func_signal": "__asm void *_alloc_box (void *box_mem)", "code": "{\n   /* Function wrapper for Unprivileged/Privileged mode. */\n        LDR     R12,=__cpp(rt_alloc_box)\n        MRS     R3,IPSR\n        LSLS    R3,#24\n        BXNE    R12\n        MRS     R3,CONTROL\n        LSLS    R3,#31\n        BXEQ    R12\n        SVC     0\n        BX      LR\n\n        ALIGN\n}", "path": "CMSIS_5/CMSIS/RTOS/RTX/SRC/ARM/HAL_CM4.c", "commit_date": "2017-05-09 00:00:00", "repo_name": "ARM-software/CMSIS_5", "stars": 1191, "license": "apache-2.0", "language": "c", "size": 262506}
{"docstring": "/// Delete a timer.\n/// \\note API identical to osTimerDelete\n", "func_signal": "static osStatus_t svcRtxTimerDelete (osTimerId_t timer_id)", "code": "{\n  os_timer_t *timer = osRtxTimerId(timer_id);\n\n  // Check parameters\n  if ((timer == NULL) || (timer->id != osRtxIdTimer)) {\n    EvrRtxTimerError(timer, (int32_t)osErrorParameter);\n    //lint -e{904} \"Return statement before end of function\" [MISRA Note 1]\n    return osErrorParameter;\n  }\n\n  if (timer->state == osRtxTimerRunning) {\n    TimerRemove(timer);\n  }\n\n  // Mark object as inactive and invalid\n  timer->state = osRtxTimerInactive;\n  timer->id    = osRtxIdInvalid;\n\n  // Free object memory\n  if ((timer->flags & osRtxFlagSystemObject) != 0U) {\n    if (osRtxInfo.mpi.timer != NULL) {\n      (void)osRtxMemoryPoolFree(osRtxInfo.mpi.timer, timer);\n    } else {\n      (void)osRtxMemoryFree(osRtxInfo.mem.common, timer);\n    }\n#if (defined(OS_OBJ_MEM_USAGE) && (OS_OBJ_MEM_USAGE != 0))\n    osRtxTimerMemUsage.cnt_free++;\n#endif\n  }\n\n  EvrRtxTimerDestroyed(timer);\n\n  return osOK;\n}", "path": "CMSIS_5/CMSIS/RTOS2/RTX/Source/rtx_timer.c", "commit_date": "2019-03-18 00:00:00", "repo_name": "ARM-software/CMSIS_5", "stars": 1191, "license": "apache-2.0", "language": "c", "size": 262506}
{"docstring": "/// Create and Initialize a timer.\n/// \\note API identical to osTimerNew\n", "func_signal": "static osTimerId_t svcRtxTimerNew (osTimerFunc_t func, osTimerType_t type, void *argument, const osTimerAttr_t *attr)", "code": "{\n  os_timer_t *timer;\n  uint8_t     flags;\n  const char *name;\n\n  // Check parameters\n  if ((func == NULL) || ((type != osTimerOnce) && (type != osTimerPeriodic))) {\n    EvrRtxTimerError(NULL, (int32_t)osErrorParameter);\n    //lint -e{904} \"Return statement before end of function\" [MISRA Note 1]\n    return NULL;\n  }\n\n  // Process attributes\n  if (attr != NULL) {\n    name  = attr->name;\n    //lint -e{9079} \"conversion from pointer to void to pointer to other type\" [MISRA Note 6]\n    timer = attr->cb_mem;\n    if (timer != NULL) {\n      //lint -e(923) -e(9078) \"cast from pointer to unsigned int\" [MISRA Note 7]\n      if ((((uint32_t)timer & 3U) != 0U) || (attr->cb_size < sizeof(os_timer_t))) {\n        EvrRtxTimerError(NULL, osRtxErrorInvalidControlBlock);\n        //lint -e{904} \"Return statement before end of function\" [MISRA Note 1]\n        return NULL;\n      }\n    } else {\n      if (attr->cb_size != 0U) {\n        EvrRtxTimerError(NULL, osRtxErrorInvalidControlBlock);\n        //lint -e{904} \"Return statement before end of function\" [MISRA Note 1]\n        return NULL;\n      }\n    }\n  } else {\n    name  = NULL;\n    timer = NULL;\n  }\n\n  // Allocate object memory if not provided\n  if (timer == NULL) {\n    if (osRtxInfo.mpi.timer != NULL) {\n      //lint -e{9079} \"conversion from pointer to void to pointer to other type\" [MISRA Note 5]\n      timer = osRtxMemoryPoolAlloc(osRtxInfo.mpi.timer);\n    } else {\n      //lint -e{9079} \"conversion from pointer to void to pointer to other type\" [MISRA Note 5]\n      timer = osRtxMemoryAlloc(osRtxInfo.mem.common, sizeof(os_timer_t), 1U);\n    }\n#if (defined(OS_OBJ_MEM_USAGE) && (OS_OBJ_MEM_USAGE != 0))\n    if (timer != NULL) {\n      uint32_t used;\n      osRtxTimerMemUsage.cnt_alloc++;\n      used = osRtxTimerMemUsage.cnt_alloc - osRtxTimerMemUsage.cnt_free;\n      if (osRtxTimerMemUsage.max_used < used) {\n        osRtxTimerMemUsage.max_used = used;\n      }\n    }\n#endif\n    flags = osRtxFlagSystemObject;\n  } else {\n    flags = 0U;\n  }\n\n  if (timer != NULL) {\n    // Initialize control block\n    timer->id         = osRtxIdTimer;\n    timer->state      = osRtxTimerStopped;\n    timer->flags      = flags;\n    timer->type       = (uint8_t)type;\n    timer->name       = name;\n    timer->prev       = NULL;\n    timer->next       = NULL;\n    timer->tick       = 0U;\n    timer->load       = 0U;\n    timer->finfo.func = func;\n    timer->finfo.arg  = argument;\n\n    EvrRtxTimerCreated(timer, timer->name);\n  } else {\n    EvrRtxTimerError(NULL, (int32_t)osErrorNoMemory);\n  }\n\n  return timer;\n}", "path": "CMSIS_5/CMSIS/RTOS2/RTX/Source/rtx_timer.c", "commit_date": "2019-03-18 00:00:00", "repo_name": "ARM-software/CMSIS_5", "stars": 1191, "license": "apache-2.0", "language": "c", "size": 262506}
{"docstring": "/// Delete a timer.\n", "func_signal": "osStatus_t osTimerDelete (osTimerId_t timer_id)", "code": "{\n  osStatus_t status;\n\n  EvrRtxTimerDelete(timer_id);\n  if (IsIrqMode() || IsIrqMasked()) {\n    EvrRtxTimerError(timer_id, (int32_t)osErrorISR);\n    status = osErrorISR;\n  } else {\n    status = __svcTimerDelete(timer_id);\n  }\n  return status;\n}", "path": "CMSIS_5/CMSIS/RTOS2/RTX/Source/rtx_timer.c", "commit_date": "2019-03-18 00:00:00", "repo_name": "ARM-software/CMSIS_5", "stars": 1191, "license": "apache-2.0", "language": "c", "size": 262506}
{"docstring": "/*----------------------------------------------------------------------------\n  System initialization function\n *----------------------------------------------------------------------------*/\n", "func_signal": "void SystemInit (void)", "code": "{\n\n#if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)\n  SCB->VTOR = (uint32_t) &(__VECTOR_TABLE[0]);\n#endif\n\n#if defined (__FPU_USED) && (__FPU_USED == 1U)\n  SCB->CPACR |= ((3U << 10U*2U) |           /* enable CP10 Full Access */\n                 (3U << 11U*2U)  );         /* enable CP11 Full Access */\n#endif\n\n#ifdef UNALIGNED_SUPPORT_DISABLE\n  SCB->CCR |= SCB_CCR_UNALIGN_TRP_Msk;\n#endif\n\n  SystemCoreClock = SYSTEM_CLOCK;\n}", "path": "CMSIS_5/Device/ARM/ARMCM7/Source/system_ARMCM7.c", "commit_date": "2019-12-04 00:00:00", "repo_name": "ARM-software/CMSIS_5", "stars": 1191, "license": "apache-2.0", "language": "c", "size": 262506}
{"docstring": "/// Timer Tick (called each SysTick).\n", "func_signal": "static void osRtxTimerTick (void)", "code": "{\n  os_timer_t *timer;\n  osStatus_t  status;\n\n  timer = osRtxInfo.timer.list;\n  if (timer == NULL) {\n    //lint -e{904} \"Return statement before end of function\" [MISRA Note 1]\n    return;\n  }\n\n  timer->tick--;\n  while ((timer != NULL) && (timer->tick == 0U)) {\n    TimerUnlink(timer);\n    status = osMessageQueuePut(osRtxInfo.timer.mq, &timer->finfo, 0U, 0U);\n    if (status != osOK) {\n      (void)osRtxErrorNotify(osRtxErrorTimerQueueOverflow, timer);\n    }\n    if (timer->type == osRtxTimerPeriodic) {\n      TimerInsert(timer, timer->load);\n    } else {\n      timer->state = osRtxTimerStopped;\n    }\n    timer = osRtxInfo.timer.list;\n  }\n}", "path": "CMSIS_5/CMSIS/RTOS2/RTX/Source/rtx_timer.c", "commit_date": "2019-03-18 00:00:00", "repo_name": "ARM-software/CMSIS_5", "stars": 1191, "license": "apache-2.0", "language": "c", "size": 262506}
{"docstring": "/* For direct MMAP, use MEM_TOP_DOWN to minimize interference */\n", "func_signal": "static void *direct_mmap(size_t size)", "code": "{\n  DWORD olderr = GetLastError();\n  void *ptr = NULL;\n  long st = ntavm(INVALID_HANDLE_VALUE, &ptr, NTAVM_ZEROBITS, &size,\n\t\t  MEM_RESERVE|MEM_COMMIT|MEM_TOP_DOWN, PAGE_READWRITE);\n  SetLastError(olderr);\n  return st == 0 ? ptr : MFAIL;\n}", "path": "luajit2/src/lj_alloc.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "openresty/luajit2", "stars": 1129, "license": "other", "language": "c", "size": 8878}
{"docstring": "/* Add debug info for newly compiled trace and notify GDB. */\n", "func_signal": "void lj_gdbjit_addtrace(jit_State *J, GCtrace *T)", "code": "{\n  GDBJITctx ctx;\n  GCproto *pt = &gcref(T->startpt)->pt;\n  TraceNo parent = T->ir[REF_BASE].op1;\n  const BCIns *startpc = mref(T->startpc, const BCIns);\n  ctx.T = T;\n  ctx.mcaddr = (uintptr_t)T->mcode;\n  ctx.szmcode = T->szmcode;\n  ctx.spadjp = CFRAME_SIZE_JIT +\n\t       (MSize)(parent ? traceref(J, parent)->spadjust : 0);\n  ctx.spadj = CFRAME_SIZE_JIT + T->spadjust;\n  lj_assertJ(startpc >= proto_bc(pt) && startpc < proto_bc(pt) + pt->sizebc,\n\t     \"start PC out of range\");\n  ctx.lineno = lj_debug_line(pt, proto_bcpos(pt, startpc));\n  ctx.filename = proto_chunknamestr(pt);\n  if (*ctx.filename == '@' || *ctx.filename == '=')\n    ctx.filename++;\n  else\n    ctx.filename = \"(string)\";\n  gdbjit_buildobj(&ctx);\n  gdbjit_newentry(J->L, &ctx);\n}", "path": "luajit2/src/lj_gdbjit.c", "commit_date": "2020-06-15 00:00:00", "repo_name": "openresty/luajit2", "stars": 1129, "license": "other", "language": "c", "size": 8878}
{"docstring": "/* -------------------------- System allocation -------------------------- */\n", "func_signal": "static void *alloc_sys(mstate m, size_t nb)", "code": "{\n  char *tbase = CMFAIL;\n  size_t tsize = 0;\n\n  /* Directly map large chunks */\n  if (LJ_UNLIKELY(nb >= DEFAULT_MMAP_THRESHOLD)) {\n    void *mem = direct_alloc(m, nb);\n    if (mem != 0)\n      return mem;\n  }\n\n  {\n    size_t req = nb + TOP_FOOT_SIZE + SIZE_T_ONE;\n    size_t rsize = granularity_align(req);\n    if (LJ_LIKELY(rsize > nb)) { /* Fail if wraps around zero */\n      char *mp = (char *)(CALL_MMAP(m->prng, rsize));\n      if (mp != CMFAIL) {\n\ttbase = mp;\n\ttsize = rsize;\n      }\n    }\n  }\n\n  if (tbase != CMFAIL) {\n    msegmentptr sp = &m->seg;\n    /* Try to merge with an existing segment */\n    while (sp != 0 && tbase != sp->base + sp->size)\n      sp = sp->next;\n    if (sp != 0 && segment_holds(sp, m->top)) { /* append */\n      sp->size += tsize;\n      init_top(m, m->top, m->topsize + tsize);\n    } else {\n      sp = &m->seg;\n      while (sp != 0 && sp->base != tbase + tsize)\n\tsp = sp->next;\n      if (sp != 0) {\n\tchar *oldbase = sp->base;\n\tsp->base = tbase;\n\tsp->size += tsize;\n\treturn prepend_alloc(m, tbase, oldbase, nb);\n      } else {\n\tadd_segment(m, tbase, tsize);\n      }\n    }\n\n    if (nb < m->topsize) { /* Allocate from new or extended top space */\n      size_t rsize = m->topsize -= nb;\n      mchunkptr p = m->top;\n      mchunkptr r = m->top = chunk_plus_offset(p, nb);\n      r->head = rsize | PINUSE_BIT;\n      set_size_and_pinuse_of_inuse_chunk(m, p, nb);\n      return chunk2mem(p);\n    }\n  }\n\n  return NULL;\n}", "path": "luajit2/src/lj_alloc.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "openresty/luajit2", "stars": 1129, "license": "other", "language": "c", "size": 8878}
{"docstring": "/* Allocate chunk and prepend remainder with chunk in successor base. */\n", "func_signal": "static void *prepend_alloc(mstate m, char *newbase, char *oldbase, size_t nb)", "code": "{\n  mchunkptr p = align_as_chunk(newbase);\n  mchunkptr oldfirst = align_as_chunk(oldbase);\n  size_t psize = (size_t)((char *)oldfirst - (char *)p);\n  mchunkptr q = chunk_plus_offset(p, nb);\n  size_t qsize = psize - nb;\n  set_size_and_pinuse_of_inuse_chunk(m, p, nb);\n\n  /* consolidate remainder with first chunk of old base */\n  if (oldfirst == m->top) {\n    size_t tsize = m->topsize += qsize;\n    m->top = q;\n    q->head = tsize | PINUSE_BIT;\n  } else if (oldfirst == m->dv) {\n    size_t dsize = m->dvsize += qsize;\n    m->dv = q;\n    set_size_and_pinuse_of_free_chunk(q, dsize);\n  } else {\n    if (!cinuse(oldfirst)) {\n      size_t nsize = chunksize(oldfirst);\n      unlink_chunk(m, oldfirst, nsize);\n      oldfirst = chunk_plus_offset(oldfirst, nsize);\n      qsize += nsize;\n    }\n    set_free_with_pinuse(q, qsize, oldfirst);\n    insert_chunk(m, q, qsize);\n  }\n\n  return chunk2mem(p);\n}", "path": "luajit2/src/lj_alloc.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "openresty/luajit2", "stars": 1129, "license": "other", "language": "c", "size": 8878}
{"docstring": "/* Initialize .debug_line section. */\n", "func_signal": "static void LJ_FASTCALL gdbjit_debugline(GDBJITctx *ctx)", "code": "{\n  uint8_t *p = ctx->p;\n\n  DSECT(line,\n    DU16(2);\t\t\t/* DWARF version. */\n    DSECT(header,\n      DB(1);\t\t\t/* Minimum instruction length. */\n      DB(1);\t\t\t/* is_stmt. */\n      DI8(0);\t\t\t/* Line base for special opcodes. */\n      DB(2);\t\t\t/* Line range for special opcodes. */\n      DB(3+1);\t\t\t/* Opcode base at DW_LNS_advance_line+1. */\n      DB(0); DB(1); DB(1);\t/* Standard opcode lengths. */\n      /* Directory table. */\n      DB(0);\n      /* File name table. */\n      DSTR(ctx->filename); DUV(0); DUV(0); DUV(0);\n      DB(0);\n    )\n\n    DLNE(DW_LNE_set_address, sizeof(uintptr_t)); DADDR(ctx->mcaddr);\n    if (ctx->lineno) {\n      DB(DW_LNS_advance_line); DSV(ctx->lineno-1);\n    }\n    DB(DW_LNS_copy);\n    DB(DW_LNS_advance_pc); DUV(ctx->szmcode);\n    DLNE(DW_LNE_end_sequence, 0);\n  )\n\n  ctx->p = p;\n}", "path": "luajit2/src/lj_gdbjit.c", "commit_date": "2020-06-15 00:00:00", "repo_name": "openresty/luajit2", "stars": 1129, "license": "other", "language": "c", "size": 8878}
{"docstring": "/* For direct MMAP, use MEM_TOP_DOWN to minimize interference */\n", "func_signal": "static void *direct_mmap(size_t size)", "code": "{\n  DWORD olderr = GetLastError();\n  void *ptr = LJ_WIN_VALLOC(0, size, MEM_RESERVE|MEM_COMMIT|MEM_TOP_DOWN,\n\t\t\t    PAGE_READWRITE);\n  SetLastError(olderr);\n  return ptr ? ptr : MFAIL;\n}", "path": "luajit2/src/lj_alloc.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "openresty/luajit2", "stars": 1129, "license": "other", "language": "c", "size": 8878}
{"docstring": "/* allocate a small request from the best fitting chunk in a treebin */\n", "func_signal": "static void *tmalloc_small(mstate m, size_t nb)", "code": "{\n  tchunkptr t, v;\n  mchunkptr r;\n  size_t rsize;\n  bindex_t i = lj_ffs(m->treemap);\n\n  v = t = *treebin_at(m, i);\n  rsize = chunksize(t) - nb;\n\n  while ((t = leftmost_child(t)) != 0) {\n    size_t trem = chunksize(t) - nb;\n    if (trem < rsize) {\n      rsize = trem;\n      v = t;\n    }\n  }\n\n  r = chunk_plus_offset(v, nb);\n  unlink_large_chunk(m, v);\n  if (rsize < MIN_CHUNK_SIZE) {\n    set_inuse_and_pinuse(m, v, (rsize + nb));\n  } else {\n    set_size_and_pinuse_of_inuse_chunk(m, v, nb);\n    set_size_and_pinuse_of_free_chunk(r, rsize);\n    replace_dv(m, r, rsize);\n  }\n  return chunk2mem(v);\n}", "path": "luajit2/src/lj_alloc.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "openresty/luajit2", "stars": 1129, "license": "other", "language": "c", "size": 8878}
{"docstring": "/* allocate a large request from the best fitting chunk in a treebin */\n", "func_signal": "static void *tmalloc_large(mstate m, size_t nb)", "code": "{\n  tchunkptr v = 0;\n  size_t rsize = ~nb+1; /* Unsigned negation */\n  tchunkptr t;\n  bindex_t idx;\n  compute_tree_index(nb, idx);\n\n  if ((t = *treebin_at(m, idx)) != 0) {\n    /* Traverse tree for this bin looking for node with size == nb */\n    size_t sizebits = nb << leftshift_for_tree_index(idx);\n    tchunkptr rst = 0;  /* The deepest untaken right subtree */\n    for (;;) {\n      tchunkptr rt;\n      size_t trem = chunksize(t) - nb;\n      if (trem < rsize) {\n\tv = t;\n\tif ((rsize = trem) == 0)\n\t  break;\n      }\n      rt = t->child[1];\n      t = t->child[(sizebits >> (SIZE_T_BITSIZE-SIZE_T_ONE)) & 1];\n      if (rt != 0 && rt != t)\n\trst = rt;\n      if (t == 0) {\n\tt = rst; /* set t to least subtree holding sizes > nb */\n\tbreak;\n      }\n      sizebits <<= 1;\n    }\n  }\n\n  if (t == 0 && v == 0) { /* set t to root of next non-empty treebin */\n    binmap_t leftbits = left_bits(idx2bit(idx)) & m->treemap;\n    if (leftbits != 0)\n      t = *treebin_at(m, lj_ffs(leftbits));\n  }\n\n  while (t != 0) { /* find smallest of tree or subtree */\n    size_t trem = chunksize(t) - nb;\n    if (trem < rsize) {\n      rsize = trem;\n      v = t;\n    }\n    t = leftmost_child(t);\n  }\n\n  /*  If dv is a better fit, return NULL so malloc will use it */\n  if (v != 0 && rsize < (size_t)(m->dvsize - nb)) {\n    mchunkptr r = chunk_plus_offset(v, nb);\n    unlink_large_chunk(m, v);\n    if (rsize < MIN_CHUNK_SIZE) {\n      set_inuse_and_pinuse(m, v, (rsize + nb));\n    } else {\n      set_size_and_pinuse_of_inuse_chunk(m, v, nb);\n      set_size_and_pinuse_of_free_chunk(r, rsize);\n      insert_chunk(m, r, rsize);\n    }\n    return chunk2mem(v);\n  }\n  return NULL;\n}", "path": "luajit2/src/lj_alloc.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "openresty/luajit2", "stars": 1129, "license": "other", "language": "c", "size": 8878}
{"docstring": "/* Need to define _GNU_SOURCE to get the mremap prototype. */\n", "func_signal": "static void *CALL_MREMAP_(void *ptr, size_t osz, size_t nsz, int flags)", "code": "{\n  int olderr = errno;\n  ptr = mremap(ptr, osz, nsz, flags);\n  errno = olderr;\n  return ptr;\n}", "path": "luajit2/src/lj_alloc.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "openresty/luajit2", "stars": 1129, "license": "other", "language": "c", "size": 8878}
{"docstring": "/* Return segment holding given address */\n", "func_signal": "static msegmentptr segment_holding(mstate m, char *addr)", "code": "{\n  msegmentptr sp = &m->seg;\n  for (;;) {\n    if (addr >= sp->base && addr < sp->base + sp->size)\n      return sp;\n    if ((sp = sp->next) == 0)\n      return 0;\n  }\n}", "path": "luajit2/src/lj_alloc.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "openresty/luajit2", "stars": 1129, "license": "other", "language": "c", "size": 8878}
{"docstring": "/* Initialize .eh_frame section. */\n", "func_signal": "static void LJ_FASTCALL gdbjit_ehframe(GDBJITctx *ctx)", "code": "{\n  uint8_t *p = ctx->p;\n  uint8_t *framep = p;\n\n  /* Emit DWARF EH CIE. */\n  DSECT(CIE,\n    DU32(0);\t\t\t/* Offset to CIE itself. */\n    DB(DW_CIE_VERSION);\n    DSTR(\"zR\");\t\t\t/* Augmentation. */\n    DUV(1);\t\t\t/* Code alignment factor. */\n    DSV(-(int32_t)sizeof(uintptr_t));  /* Data alignment factor. */\n    DB(DW_REG_RA);\t\t/* Return address register. */\n    DB(1); DB(DW_EH_PE_textrel|DW_EH_PE_udata4);  /* Augmentation data. */\n    DB(DW_CFA_def_cfa); DUV(DW_REG_SP); DUV(sizeof(uintptr_t));\n#if LJ_TARGET_PPC\n    DB(DW_CFA_offset_extended_sf); DB(DW_REG_RA); DSV(-1);\n#else\n    DB(DW_CFA_offset|DW_REG_RA); DUV(1);\n#endif\n    DALIGNNOP(sizeof(uintptr_t));\n  )\n\n  /* Emit DWARF EH FDE. */\n  DSECT(FDE,\n    DU32((uint32_t)(p-framep));\t/* Offset to CIE. */\n    DU32(0);\t\t\t/* Machine code offset relative to .text. */\n    DU32(ctx->szmcode);\t\t/* Machine code length. */\n    DB(0);\t\t\t/* Augmentation data. */\n    /* Registers saved in CFRAME. */\n#if LJ_TARGET_X86\n    DB(DW_CFA_offset|DW_REG_BP); DUV(2);\n    DB(DW_CFA_offset|DW_REG_DI); DUV(3);\n    DB(DW_CFA_offset|DW_REG_SI); DUV(4);\n    DB(DW_CFA_offset|DW_REG_BX); DUV(5);\n#elif LJ_TARGET_X64\n    DB(DW_CFA_offset|DW_REG_BP); DUV(2);\n    DB(DW_CFA_offset|DW_REG_BX); DUV(3);\n    DB(DW_CFA_offset|DW_REG_15); DUV(4);\n    DB(DW_CFA_offset|DW_REG_14); DUV(5);\n    /* Extra registers saved for JIT-compiled code. */\n    DB(DW_CFA_offset|DW_REG_13); DUV(LJ_GC64 ? 10 : 9);\n    DB(DW_CFA_offset|DW_REG_12); DUV(LJ_GC64 ? 11 : 10);\n#elif LJ_TARGET_ARM\n    {\n      int i;\n      for (i = 11; i >= 4; i--) { DB(DW_CFA_offset|i); DUV(2+(11-i)); }\n    }\n#elif LJ_TARGET_ARM64\n    {\n      int i;\n      DB(DW_CFA_offset|31); DUV(2);\n      for (i = 28; i >= 19; i--) { DB(DW_CFA_offset|i); DUV(3+(28-i)); }\n      for (i = 15; i >= 8; i--) { DB(DW_CFA_offset|32|i); DUV(28-i); }\n    }\n#elif LJ_TARGET_PPC\n    {\n      int i;\n      DB(DW_CFA_offset_extended); DB(DW_REG_CR); DUV(55);\n      for (i = 14; i <= 31; i++) {\n\tDB(DW_CFA_offset|i); DUV(37+(31-i));\n\tDB(DW_CFA_offset|32|i); DUV(2+2*(31-i));\n      }\n    }\n#elif LJ_TARGET_MIPS\n    {\n      int i;\n      DB(DW_CFA_offset|30); DUV(2);\n      for (i = 23; i >= 16; i--) { DB(DW_CFA_offset|i); DUV(26-i); }\n      for (i = 30; i >= 20; i -= 2) { DB(DW_CFA_offset|32|i); DUV(42-i); }\n    }\n#else\n#error \"Unsupported target architecture\"\n#endif\n    if (ctx->spadjp != ctx->spadj) {  /* Parent/interpreter stack frame size. */\n      DB(DW_CFA_def_cfa_offset); DUV(ctx->spadjp);\n      DB(DW_CFA_advance_loc|1);  /* Only an approximation. */\n    }\n    DB(DW_CFA_def_cfa_offset); DUV(ctx->spadj);  /* Trace stack frame size. */\n    DALIGNNOP(sizeof(uintptr_t));\n  )\n\n  ctx->p = p;\n}", "path": "luajit2/src/lj_gdbjit.c", "commit_date": "2020-06-15 00:00:00", "repo_name": "openresty/luajit2", "stars": 1129, "license": "other", "language": "c", "size": 8878}
{"docstring": "/* Delete debug info for trace and notify GDB. */\n", "func_signal": "void lj_gdbjit_deltrace(jit_State *J, GCtrace *T)", "code": "{\n  GDBJITentryobj *eo = (GDBJITentryobj *)T->gdbjit_entry;\n  if (eo) {\n    gdbjit_lock_acquire();\n    if (eo->entry.prev_entry)\n      eo->entry.prev_entry->next_entry = eo->entry.next_entry;\n    else\n      __jit_debug_descriptor.first_entry = eo->entry.next_entry;\n    if (eo->entry.next_entry)\n      eo->entry.next_entry->prev_entry = eo->entry.prev_entry;\n    __jit_debug_descriptor.relevant_entry = &eo->entry;\n    __jit_debug_descriptor.action_flag = GDBJIT_UNREGISTER;\n    __jit_debug_register_code();\n    gdbjit_lock_release();\n    lj_mem_free(J2G(J), eo, eo->sz);\n  }\n}", "path": "luajit2/src/lj_gdbjit.c", "commit_date": "2020-06-15 00:00:00", "repo_name": "openresty/luajit2", "stars": 1129, "license": "other", "language": "c", "size": 8878}
{"docstring": "/* Add a segment to hold a new noncontiguous region */\n", "func_signal": "static void add_segment(mstate m, char *tbase, size_t tsize)", "code": "{\n  /* Determine locations and sizes of segment, fenceposts, old top */\n  char *old_top = (char *)m->top;\n  msegmentptr oldsp = segment_holding(m, old_top);\n  char *old_end = oldsp->base + oldsp->size;\n  size_t ssize = pad_request(sizeof(struct malloc_segment));\n  char *rawsp = old_end - (ssize + FOUR_SIZE_T_SIZES + CHUNK_ALIGN_MASK);\n  size_t offset = align_offset(chunk2mem(rawsp));\n  char *asp = rawsp + offset;\n  char *csp = (asp < (old_top + MIN_CHUNK_SIZE))? old_top : asp;\n  mchunkptr sp = (mchunkptr)csp;\n  msegmentptr ss = (msegmentptr)(chunk2mem(sp));\n  mchunkptr tnext = chunk_plus_offset(sp, ssize);\n  mchunkptr p = tnext;\n\n  /* reset top to new space */\n  init_top(m, (mchunkptr)tbase, tsize - TOP_FOOT_SIZE);\n\n  /* Set up segment record */\n  set_size_and_pinuse_of_inuse_chunk(m, sp, ssize);\n  *ss = m->seg; /* Push current record */\n  m->seg.base = tbase;\n  m->seg.size = tsize;\n  m->seg.next = ss;\n\n  /* Insert trailing fenceposts */\n  for (;;) {\n    mchunkptr nextp = chunk_plus_offset(p, SIZE_T_SIZE);\n    p->head = FENCEPOST_HEAD;\n    if ((char *)(&(nextp->head)) < old_end)\n      p = nextp;\n    else\n      break;\n  }\n\n  /* Insert the rest of old top into a bin as an ordinary free chunk */\n  if (csp != old_top) {\n    mchunkptr q = (mchunkptr)old_top;\n    size_t psize = (size_t)(csp - old_top);\n    mchunkptr tn = chunk_plus_offset(q, psize);\n    set_free_with_pinuse(q, psize, tn);\n    insert_chunk(m, q, psize);\n  }\n}", "path": "luajit2/src/lj_alloc.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "openresty/luajit2", "stars": 1129, "license": "other", "language": "c", "size": 8878}
{"docstring": "/* This function supports releasing coalesed segments */\n", "func_signal": "static int CALL_MUNMAP(void *ptr, size_t size)", "code": "{\n  DWORD olderr = GetLastError();\n  MEMORY_BASIC_INFORMATION minfo;\n  char *cptr = (char *)ptr;\n  while (size) {\n    if (VirtualQuery(cptr, &minfo, sizeof(minfo)) == 0)\n      return -1;\n    if (minfo.BaseAddress != cptr || minfo.AllocationBase != cptr ||\n\tminfo.State != MEM_COMMIT || minfo.RegionSize > size)\n      return -1;\n    if (VirtualFree(cptr, 0, MEM_RELEASE) == 0)\n      return -1;\n    cptr += minfo.RegionSize;\n    size -= minfo.RegionSize;\n  }\n  SetLastError(olderr);\n  return 0;\n}", "path": "luajit2/src/lj_alloc.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "openresty/luajit2", "stars": 1129, "license": "other", "language": "c", "size": 8878}
{"docstring": "/* Append a decimal number. */\n", "func_signal": "static void gdbjit_catnum(GDBJITctx *ctx, uint32_t n)", "code": "{\n  if (n >= 10) { uint32_t m = n / 10; n = n % 10; gdbjit_catnum(ctx, m); }\n  *ctx->p++ = '0' + n;\n}", "path": "luajit2/src/lj_gdbjit.c", "commit_date": "2020-06-15 00:00:00", "repo_name": "openresty/luajit2", "stars": 1129, "license": "other", "language": "c", "size": 8878}
{"docstring": "/* Add a zero-terminated string. */\n", "func_signal": "static uint32_t gdbjit_strz(GDBJITctx *ctx, const char *str)", "code": "{\n  uint8_t *p = ctx->p;\n  uint32_t ofs = (uint32_t)(p - ctx->startp);\n  do {\n    *p++ = (uint8_t)*str;\n  } while (*str++);\n  ctx->p = p;\n  return ofs;\n}", "path": "luajit2/src/lj_gdbjit.c", "commit_date": "2020-06-15 00:00:00", "repo_name": "openresty/luajit2", "stars": 1129, "license": "other", "language": "c", "size": 8878}
{"docstring": "/* Win32 MMAP via VirtualAlloc */\n", "func_signal": "static void *mmap_plain(size_t size)", "code": "{\n  DWORD olderr = GetLastError();\n  void *ptr = LJ_WIN_VALLOC(0, size, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);\n  SetLastError(olderr);\n  return ptr ? ptr : MFAIL;\n}", "path": "luajit2/src/lj_alloc.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "openresty/luajit2", "stars": 1129, "license": "other", "language": "c", "size": 8878}
{"docstring": "/* Call section initializer and set the section offset and size. */\n", "func_signal": "static void gdbjit_initsect(GDBJITctx *ctx, int sect, GDBJITinitf initf)", "code": "{\n  ctx->startp = ctx->p;\n  ctx->obj.sect[sect].ofs = (uintptr_t)((char *)ctx->p - (char *)&ctx->obj);\n  initf(ctx);\n  ctx->obj.sect[sect].size = (uintptr_t)(ctx->p - ctx->startp);\n}", "path": "luajit2/src/lj_gdbjit.c", "commit_date": "2020-06-15 00:00:00", "repo_name": "openresty/luajit2", "stars": 1129, "license": "other", "language": "c", "size": 8878}
{"docstring": "/* Add new entry to GDB JIT symbol chain. */\n", "func_signal": "static void gdbjit_newentry(lua_State *L, GDBJITctx *ctx)", "code": "{\n  /* Allocate memory for GDB JIT entry and ELF object. */\n  MSize sz = (MSize)(sizeof(GDBJITentryobj) - sizeof(GDBJITobj) + ctx->objsize);\n  GDBJITentryobj *eo = lj_mem_newt(L, sz, GDBJITentryobj);\n  memcpy(&eo->obj, &ctx->obj, ctx->objsize);  /* Copy ELF object. */\n  eo->sz = sz;\n  ctx->T->gdbjit_entry = (void *)eo;\n  /* Link new entry to chain and register it. */\n  eo->entry.prev_entry = NULL;\n  gdbjit_lock_acquire();\n  eo->entry.next_entry = __jit_debug_descriptor.first_entry;\n  if (eo->entry.next_entry)\n    eo->entry.next_entry->prev_entry = &eo->entry;\n  eo->entry.symfile_addr = (const char *)&eo->obj;\n  eo->entry.symfile_size = ctx->objsize;\n  __jit_debug_descriptor.first_entry = &eo->entry;\n  __jit_debug_descriptor.relevant_entry = &eo->entry;\n  __jit_debug_descriptor.action_flag = GDBJIT_REGISTER;\n  __jit_debug_register_code();\n  gdbjit_lock_release();\n}", "path": "luajit2/src/lj_gdbjit.c", "commit_date": "2020-06-15 00:00:00", "repo_name": "openresty/luajit2", "stars": 1129, "license": "other", "language": "c", "size": 8878}
{"docstring": "/* Unmap and unlink any mmapped segments that don't contain used chunks */\n", "func_signal": "static size_t release_unused_segments(mstate m)", "code": "{\n  size_t released = 0;\n  size_t nsegs = 0;\n  msegmentptr pred = &m->seg;\n  msegmentptr sp = pred->next;\n  while (sp != 0) {\n    char *base = sp->base;\n    size_t size = sp->size;\n    msegmentptr next = sp->next;\n    nsegs++;\n    {\n      mchunkptr p = align_as_chunk(base);\n      size_t psize = chunksize(p);\n      /* Can unmap if first chunk holds entire segment and not pinned */\n      if (!cinuse(p) && (char *)p + psize >= base + size - TOP_FOOT_SIZE) {\n\ttchunkptr tp = (tchunkptr)p;\n\tif (p == m->dv) {\n\t  m->dv = 0;\n\t  m->dvsize = 0;\n\t} else {\n\t  unlink_large_chunk(m, tp);\n\t}\n\tif (CALL_MUNMAP(base, size) == 0) {\n\t  released += size;\n\t  /* unlink obsoleted record */\n\t  sp = pred;\n\t  sp->next = next;\n\t} else { /* back out if cannot unmap */\n\t  insert_large_chunk(m, tp, psize);\n\t}\n      }\n    }\n    pred = sp;\n    sp = next;\n  }\n  /* Reset check counter */\n  m->release_checks = nsegs > MAX_RELEASE_CHECK_RATE ?\n\t\t      nsegs : MAX_RELEASE_CHECK_RATE;\n  return released;\n}", "path": "luajit2/src/lj_alloc.c", "commit_date": "2020-10-12 00:00:00", "repo_name": "openresty/luajit2", "stars": 1129, "license": "other", "language": "c", "size": 8878}
